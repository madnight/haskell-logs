00:00:17 <jle`> @let (_,gt7000) = IS.split 6999 primeSet
00:00:18 <lambdabot>  Defined.
00:01:03 <jle`> @let (primeWindow, _) = IS.split 8001 gt7000
00:01:04 <lambdabot>  Defined.
00:01:22 <jle`> ^ that's how i'd "window" the set to only contain primes in an interval.  intset is optimized for operations like split
00:01:55 <jle`> but yeah, if you can't build the big set, the generation is probably the bottleneck :|
00:03:56 <jle`> that, or building the set.  but i don't think IntSet has any problems with ~1mil items
00:04:15 <jle`> @let stressTest = IS.fromAscList [1..1000000]
00:04:16 <lambdabot>  Defined.
00:04:21 <jle`> > IS.size stressTest
00:04:23 <lambdabot>  1000000
00:06:38 <jle`> no sweat
00:07:06 <pounce> how do I go from a Int to Integer
00:07:38 <jle`> fromIntegral works both ways :)
00:08:10 <jle`> its general type is polymorphic
00:09:39 <cocreature> fromIntegral typechecks both ways but might generate overflows
00:14:04 <pounce> oof, still runs out of time
00:19:35 <pounce> night and thank you all for the help :)
00:21:59 <jle`> pounce: have a good night :)
00:31:08 <mreh> I deleted my package.yml, can I generate one from my cabal file?
00:31:58 <cocreature> mreh: iirc there is a project called "hpack-convert" but I’m not sure if it’s still being actively developed
00:32:23 <cocreature> note that you don’t need the package.yaml file. working with the cabal file directly is perfectly fine
00:32:37 <mreh> I just initialised a new git repo in my project dir and .cabal was ignored by default, so I guess it's generated?
00:33:03 <mreh> cocreature: okay, I read that there's a 1-to-1 correspondence between the two
00:33:07 <cocreature> if you have a package.yaml file, stack will automatically generate a cabal file from that. if you don’t have one it will use the cabal file directly
00:33:27 <mreh> cocreature: okay, no problem
00:33:47 <cocreature> there’s no 1-to-1 correspondence. hpack has various ways to express the same cabal feature
00:38:01 <spear2> hi all, i am trying to install xmonad and i get the following error: '/usr/bin/x86_64-linux-gnu-ld.gold: fatal error: -pie and -r are incompatible' https://lpaste.net/679348162757918720 any ideas?
00:40:20 <sclv> right it's a many-to-one correspondence
00:40:32 <sclv> each hpack file generates a unique cabal file
00:40:50 <sclv> but there may be multiple hpack files that generate a single cabal file
00:41:21 <sclv> that doesn't mean we can't have a cabal-to-hpack converter that picks out a section or retract
00:41:59 <sclv> in fact hpack offers such a feature somewhere, i checked
00:42:11 <sclv> that said, you probably don't need it and can just stick to a cabal file :-)
00:43:03 <sclv> spear2: ghc shouldn't be linking with lid
00:43:07 <sclv> with ld.gold
00:43:18 <sclv> i think it doesn't work with the gold linker
00:44:56 <sclv> hrm  or maybe it does now -- it used to but i heard it doesnt' anymore, can't keep track
00:45:07 <sclv> the weird part is that -r and -pie would be getting passed simultaneously
00:45:32 <cocreature> GHC even links by default with ld.gold these days
00:45:37 <sclv> -r is for relocatable and is obviously incompat with pie
00:45:46 <cocreature> (if it’s available at configure time)
00:45:52 <sclv> cocreature: right, just checked the tickets. i heard somewhere there were issues again, but i guess i was wrong!
00:46:59 * hackage warp-tls-uid 0.2.0.5 - set group and user id before running server  http://hackage.haskell.org/package/warp-tls-uid-0.2.0.5 (YoshikuniJujo)
00:47:37 <sclv> spear2: what os are you running?
00:48:58 <sclv> spear2: oh, i have a theory!
00:49:02 <spear2> sclv: linux mint 19 xfce beta
00:49:03 <sclv> go to usr/local/haskell/ghc-___/lib/ghc-___/settings
00:49:09 <sclv> where the underscores are replaced with your ghc version
00:49:31 <sclv> and check if the "compiler supports -no-pie" flag is NO
00:49:36 <sclv> and try changing it to YES
00:50:40 <sclv> unless your ghc is prior to 8.0.2 in which case there's a different fix i guess
00:53:46 <spear2> sclv: that worked =) now i have an error with xmonad itself =( 'Could not deduce (Semigroup (X a)) ...'
00:54:07 <sclv> oh no
00:54:44 <sclv> xmonad hasn't been upgraded to work with ghc 8.4 yet
00:54:56 <sclv> so you have a recent compiler and the code needs to be fixed
00:55:03 <sclv> to work with some changes to the core libraries :-/
00:55:47 <sclv> spear2: ok, so there is a fix in git, but not yet released: https://github.com/xmonad/xmonad/pull/153
00:56:41 <sclv> so if you use the HEAD version there you should be fine?
01:06:21 <spear2> sclv: thanks that worked, had to do the same for xmonad-contrib
01:27:03 <Krisostoomus> https://www.youtube.com/watch?v=CS9OO0S5w2k&list=RDXEjLoHdbVeE&index=36
01:45:39 * hackage Chart 1.9 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-1.9 (TimDocker)
01:48:07 * hackage Chart-cairo 1.9 - Cairo backend for Charts.  http://hackage.haskell.org/package/Chart-cairo-1.9 (TimDocker)
01:50:59 * hackage hadolint 1.7.2 - Dockerfile Linter JavaScript API  http://hackage.haskell.org/package/hadolint-1.7.2 (lorenzo)
01:51:59 * hackage Chart-diagrams 1.9 - Diagrams backend for Charts.  http://hackage.haskell.org/package/Chart-diagrams-1.9 (TimDocker)
02:05:29 <ZeuPiark> hello
02:09:03 <liste> hi ZeuPiark
02:22:42 <ZeuPiark> hi liste :)
02:26:11 <electrocat> sclv: if only i could convince someone to make a new release..
02:28:38 <electrocat> maybe i should bother yorgey about it again
02:29:52 <pally> I am trying to grasp the notion that "functions are values".
02:30:39 <dminuoso> pally: a value is just something you can bind to a variable and pass around.
02:30:44 <pally> Generally, f(x) is a value when it is evaluated at x
02:31:10 <electrocat> you could define a value as: something you can't evualuate any further
02:31:15 <pally> dminuoso, in that sense, I see.
02:32:43 <dminuoso> pally: So from that notion we have some (rather arbitrary) terms like "higher order functions" which is just a function, but one that expects a *function* as an argument.
02:32:54 <dminuoso> :t map
02:32:55 <lambdabot> (a -> b) -> [a] -> [b]
02:33:33 <dminuoso> > map (\x -> x + 1) [1,2,3]
02:33:35 <lambdabot>  [2,3,4]
02:33:47 <merijn> pally: "functions are values" means "anything you can do with values like "True" and "1" can be done with functions"
02:33:52 <dminuoso> I used a lambda over a section for clarity. Note how I applied `map` to a function?
02:33:59 <merijn> pally: i.e. you can pass functions as arguments, store them in datatypes and containers, etc.
02:40:05 <pally> while most non-functional programmers would interpret 'map' as a function that accepts two parameters, but from Haskell's perspective it's not viewed as such, correct?
02:40:07 <pally> :t map
02:40:08 <lambdabot> (a -> b) -> [a] -> [b]
02:40:37 <Maxdamantus> :t uncurry map
02:40:38 <lambdabot> (a -> b, [a]) -> [b]
02:41:10 <Maxdamantus> If you're referring to the fact that in Haskell every function takes exactly one argument, sure.
02:41:10 <pally> It's Maxdamantus from #English.  Hey! :-)
02:41:16 <Maxdamantus> Hi.
02:41:17 <[exa]> pally: if you add the invisible parens it starts to look much better: (a->b)  ->  ([a]->[b])
02:41:30 <pally> Maxdamantus, yep, that's what I was thinking.
02:41:51 <Maxdamantus> People will often talk about numbers of "arguments" of functions in Haskell though.
02:42:13 <Maxdamantus> and I suspect people would generally consider `map` to have two arguments in that informal sense.
02:42:16 <pally> b/c I have in my notes here that says "A function that takes 2 parameters is also a function that takes 1 parameter and amps it to a function that takes 1 parameter"
02:42:29 <dminuoso> pally: Indeed. We call that "currying"
02:42:45 <dminuoso> `f a x = ...` is the same as `f = \a -> (\x -> ...)`
02:43:07 <liste> pally: correct. it's common to say that a function takes 2 parameters to mean that the function takes 1 parameter and returns a function that returns another 1 parameter
02:43:28 <liste> takes another 1 parameter*
02:43:36 <dminuoso> pally: Consider that function application is not a straight "function has 3 arguments so you need 3 arguments" - it may be easier to think in terms of "apply to one argument, and then apply the result to another argument, etc.."
02:44:44 <Maxdamantus> Function application takes zero arguments, obviously: ($) = id
02:44:58 <Maxdamantus> or maybe it takes one argument.
02:45:27 <liste> @let add x y = x + y
02:45:28 <lambdabot>  Defined.
02:45:44 <liste> > add 5 2 -- add takes two parameters
02:45:46 <lambdabot>  7
02:45:53 <liste> @let add1 = add 1
02:45:54 <lambdabot>  Defined.
02:46:02 <liste> > add1 20 -- add1 takes 1 parameter
02:46:05 <lambdabot>  21
02:47:22 <liste> so you can see "add" as a 'factory' that, given 1 argument, produces 1-argument functions
02:48:56 <pally> 1 sec here... add takes two parameters and then add1 is bound to add 1
02:48:58 <pally> that's weird
02:49:00 <pally> lol
02:49:22 <zincy> Why is quickcheck only running one example through a test by default? Apparantly only two "examples" were run for two passing tests
02:49:57 <dminuoso> pally: add doesnt really take two parameters
02:50:01 <dminuoso> pally: imagine I wrote this:
02:50:11 <Maxdamantus> pally: `add 1 20` is another way of writing `(add 1) 20`
02:50:13 <dminuoso> @let add' = \x -> (y -> x + 2)
02:50:13 <lambdabot>  Parse failed: NPlusKPatterns language extension is not enabled. Please add {...
02:50:25 <dminuoso> @let add' = \x -> (\y -> x + 2)
02:50:26 <lambdabot>  Defined.
02:50:35 <merijn> Anyone know if there's an easy way to find out when a Travis test started failing?
02:50:40 <Maxdamantus> pally: so when you do `add1 = add 1`, you're just saving the function in a variable instead of calling it immediately.
02:51:20 <cocreature> merijn: scroll through the builds until you see something green? :)
02:51:40 <dminuoso> pally: ^- when you apply `add'` to just one argument its obvious that you get a function back, right?
02:52:36 <merijn> cocreature: ugh, looks like there's been no code change since the last successfull test and stuff failing
02:52:37 <cocreature> zincy: how are you running quickcheck? iirc the default is to run 100 tests but you can change it
02:53:05 <cocreature> merijn: maybe it’s picking up different deps?
02:53:16 <dminuoso> @undef
02:53:16 <lambdabot> Undefined.
02:53:20 <dminuoso> @let add = \x -> (\y -> x + y)
02:53:22 <lambdabot>  Defined.
02:53:26 <dminuoso> :t add
02:53:27 <lambdabot> Num a => a -> a -> a
02:53:30 <dminuoso> :t add 2
02:53:32 <lambdabot> Num a => a -> a
02:53:34 <dminuoso> :t add 2 3
02:53:35 <merijn> cocreature: That'd explain build errors, not run errors
02:53:35 <lambdabot> Num a => a
02:53:51 <cocreature> merijn: deps can change their behavior without changing the type :)
02:55:00 <merijn> cocreature: Still seems unlikely given the internal errors
02:56:01 <Logio> merijn: if there's been no code change, what caused a new test to be run?
02:56:29 * hackage aeson-compat 0.3.8 - Compatibility layer for aeson  http://hackage.haskell.org/package/aeson-compat-0.3.8 (phadej)
02:56:30 <merijn> Logio: Doc change
02:57:37 <Logio> does reverting it fix the tests?
03:00:02 <merijn> Well, the commit after that reverts the doc change, but the tests are still broken >.>
03:02:19 <pally> @let add x y = x + y
03:02:20 <lambdabot>  .L.hs:158:1: error:
03:02:20 <lambdabot>      Multiple declarations of ‘add’
03:02:20 <lambdabot>      Declared at: .L.hs:157:1
03:02:39 <zincy> cocreature: I am calling runhaskell on the source file
03:03:30 <pally> <Maxdamantus> pally: `add 1 20` is another way of writing `(add 1) 20`
03:03:40 <pally> But what does (add 1) alone mean?
03:04:03 <pally> the add operation requires two operands
03:04:25 <cocreature> zincy: right but how are you calling quickcheck in that source file?
03:04:25 <Boomerang> :t add 1
03:04:26 <lambdabot> Num a => a -> a
03:04:57 <Boomerang> @let increment = add 1
03:04:58 <lambdabot>  Defined.
03:05:02 <Boomerang> > increment 5
03:05:05 <lambdabot>  6
03:06:17 <pally> Okay, I see what liste meant when he said it's a function "factory"
03:06:29 <pally> interesting
03:07:14 <Logio> defining add1 = \y -> 1 + y is also equivalent
03:07:44 <dminuoso> pally: Check my last definition
03:07:48 <dminuoso> @undef
03:07:48 <lambdabot> Undefined.
03:07:49 <dminuoso> @let add = \x -> (\y -> x + y)
03:07:51 <lambdabot>  Defined.
03:08:04 <Boomerang> One way to look at the signature "Num a => a -> a -> a", is like this: "Num a => a -> (a -> a)"
03:08:05 <dminuoso> pally: ^- this is what actually happens.
03:08:15 <zincy> cocreature: https://lpaste.net/1570306533806309376
03:08:26 <dminuoso> "add" is equal to "a function that returns.. "a function that returns two things added""
03:18:18 <cocreature> zincy: the number of examples is the number of hspec tests that you are running. for the number of quickcheck tests there should be a line like “OK, passed 100 tests”
03:18:55 <cocreature> a quickcheck property counts as one hspec example regardless of how many tests it runs
03:20:15 <zincy> ah thanks
03:20:28 <zincy> not seeing the “OK, passed 100 tests” though
03:21:02 <zincy> maybe hspec obscures quickcheck msgs when tests pass
03:21:37 <cocreature> I just tried your example (after modifying the test to remove the dependency on takePocketCards) and I’m definitely seeing the message
03:23:03 <zincy> hmm weird
03:27:25 <cocreature> zincy: ah are you on some older version of hspec? it looks like there might have been some changes in 2.5
03:29:29 * hackage serverless-haskell 0.6.0 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.6.0 (AlexeyKotlyarov)
03:31:46 <zincy> cocreature - that is possible how would I find out
03:33:34 <cocreature> zincy: if you’re just using runhaskell, ghc-pkg list should show you the installed packages and their versions
03:36:13 <zincy> cocreature: hspec isnt there
03:36:25 <zincy> does ghc-pkg list look globally or locally?
03:36:45 <cocreature> globally but runhaskell does that as well
03:37:05 <cocreature> or depends on what you mean by global and local I guess. it will look in ~/.ghc as well
03:37:39 <zincy> How do the tests work then with runhaskell if hspec isnt installed globally?
03:37:45 <zincy> One of my assumptions must be wrong
03:37:55 <cocreature> are you sure you are running runhaskell directly and not via cabal/stack?
03:38:49 <zincy> oh I am using stack runhaskell
03:39:08 <cocreature> then try "stack exec -- ghc-pkg list"
03:39:40 <zincy> hspec-2.4.4     hspec-core-2.4.4     hspec-discover-2.4.4
03:39:47 <zincy> There we go
03:40:01 <zincy> How would I upgrade?
03:40:21 <cocreature> either specify the version in extra-deps or switch to a snapshot that has 2.5
03:41:31 <zincy> what are snapshots?
03:42:01 <cocreature> the thing you specify via the "resolver" section in your stack.yaml file
03:42:26 <cocreature> it specifies a set of packages at a specific version that are known to work together
03:43:45 <zincy> so resolver is the version of ghc
03:43:58 <zincy> and resolvers come with snapshots of known to work pkgs
03:46:44 <zincy> what is an elegant way of calling splitAt recursively on a list?
03:47:47 <zincy> I want to call splitAt 2 on a list n times and return a tuple with ([[a]], [a])
03:49:04 <pavonia> You could use chunksOf from the spit package
03:49:26 <pavonia> *split
03:51:04 <zincy> perfect thanks
04:45:30 * hackage distributed-process 0.7.4 - Cloud Haskell: Erlang-style concurrency in Haskell  http://hackage.haskell.org/package/distributed-process-0.7.4 (FacundoDominguez)
05:22:30 * hackage asset-map 0.1.0.0 - Asset map support for the JavaScript broccoli-asset-rev library.  http://hackage.haskell.org/package/asset-map-0.1.0.0 (IanDuncan)
05:27:43 <arianvp2> Is there a conneciton between lenses and zippers?
05:27:54 <arianvp2> both seem to be some kind of "pointed context" into some piece of data
05:29:26 <maerwald> a zipper is something where you can understand the types
05:30:30 <dminuoso> arianvp2: The difference is a zipper can move around
05:30:49 <dminuoso> arianvp2: But there is a deep link in that both split data into "the focus" and "
05:30:56 <dminuoso> .. and "the whole with a hole"
05:42:55 <[exa]> arianvp2: there's term derivation (similar to derivation from calculus) that can more-or-less-automatically produce zippers from anything, maybe some similar intuition exists for lenses
05:43:15 <[exa]> arianvp2: (brb with the paper)
05:45:51 <[exa]> arianvp2: the paper-- http://strictlypositive.org/diff.pdf
05:47:28 <[exa]> note that e.g. Const exactly corresponds to C + 0×t
06:02:13 <arianvp2> [exa]: yeh I know this construct
06:02:24 <arianvp2> you just  apply product and sum rule of calculus on the algebraic representation of ur datatype
06:02:28 <arianvp2> and then you get a zipper
06:07:19 <stobix> If I have a data State a where { SelectNext :: a -> SomeNotRelevantType -> State a ; KeepCurrent :: SomeNotRelevantType -> State a}, how do I get KeepCurrent to have the correct type? ghci complains about it being "ambiguous" when I use KeepCurrent - a better wording would be "irrelevant".
06:37:23 <dminuoso> stobix: There's no ambiguous types in there. Are you sure you pasted the correct type?
06:39:27 <stobix> dminuoso: The thing is that the "constructor" KeepCurrent doesn't take an as a parameter, and thus can't always infer the a in State a.
06:39:44 <stobix> take an a as a parameter *
06:40:52 <dminuoso> stobix: Ambiguous types is the opposite - it's when you have a universal quantification that is not in the return type
06:42:02 <stobix> hmm
06:44:09 <dminuoso> stobix: Can you share the code in which you use KeepCurrent, perhaps together with a full error in a gist?
06:45:21 <stobix> let's make it simpler: data State a where { SelectNext :: a -> State a ; KeepCurrent :: State a }; If I have a foo :: a -> State a; foo _ = KeepCurrent , will it get the correct type?
06:45:41 <dminuoso> That depends on what you mean by "
06:45:45 <dminuoso> "correct type"
06:46:09 <dminuoso> @let data State a where { SelectNext :: a -> State a ; KeepCurrent :: State a }
06:46:10 <lambdabot>  .L.hs:160:28: error:
06:46:10 <lambdabot>      Ambiguous occurrence ‘State’
06:46:10 <lambdabot>      It could refer to either ‘Control.Monad.State.State’,
06:46:20 <dminuoso> @let data MState a where { SelectNext :: a -> MState a ; KeepCurrent :: MState a }
06:46:21 <lambdabot>  Defined.
06:46:27 <dminuoso> @let foo _ = KeepCurrent
06:46:28 <lambdabot>  Defined.
06:46:29 <dminuoso> :t foo
06:46:31 <lambdabot> p -> MState a
06:46:45 <dminuoso> @let bar :: a -> State a; bar _ = KeepCurrent
06:46:46 <lambdabot>  .L.hs:163:13: error:
06:46:46 <lambdabot>      • Expecting one more argument to ‘State a’
06:46:46 <lambdabot>        Expected a type, but ‘State a’ has kind ‘* -> *’
06:46:52 <dminuoso> @let bar :: a -> MState a; bar _ = KeepCurrent
06:46:53 <lambdabot>  Defined.
06:46:54 <dminuoso> :set bar
06:46:56 <dminuoso> :t bar
06:46:57 <lambdabot> a -> MState a
06:48:08 <stobix> hmm
06:49:27 <stobix> I guess it's something more specifi to my case, then.
06:50:29 * stobix puts the problem on the "things to do in three hours when no longer in transit" heap
06:58:56 <OtakuSenpai> /join ##ChatterZ
07:03:15 <OtakuSenpai> /join ##ChatterZ
07:16:33 * hackage blaze-html 0.9.1.1 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.9.1.1 (JasperVanDerJeugt)
07:18:38 <doomrobo> I have a Main.hs that uses a module that I'd like to debug. Doing cabal repl doesn't let me inspect the contents of the external module. How do I force that module to be interpreted by GHCI?
07:20:16 <shapr> doomrobo: cabal new-repl ModuleName ?
07:20:32 <shapr> is the module inside your project, or an external library?
07:20:50 <cocreature> doomrobo: by “the contents of the external module” you mean definitions that are not exported?
07:21:16 <cocreature> either way, I would recommend that you take a look at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#what-s-really-in-scope-at-the-prompt
07:21:33 <doomrobo> the module is an external library. cocreature, yes, I believe the problem is that defs aren't exported
07:21:44 <cocreature> oh yeah for an external lib you are out of luck
07:22:02 <doomrobo> shapr, new-repl seems to be doing something
07:22:15 <cocreature> but it does sound kind of weird to debug a module in an external library
07:22:43 <doomrobo> I have a minimal Main.hs that triggers a bug. I wanna trace that bug down
07:23:19 <cocreature> I would clone the source of the external package and then work in that project
07:23:56 <doomrobo> yeah I might do that instead
07:27:19 <shapr> doomrobo: that's the usual approach
07:38:00 * hackage websockets 0.12.5.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.12.5.1 (JasperVanDerJeugt)
07:58:41 <zincy__> Does manually deriving ToJSON instances for any ADT get round the need a ToJSON instance for the types of the field values
07:59:06 <clever> zincy__: i think so
08:00:03 <cocreature> zincy__: what do you mean by “manually deriving”?
08:00:06 <dgpratt> gonna be spending several hours in a metal tube on Monday and then Saturday -- any suggestions for what a mild to moderate Haskeller would like to have on their e-reader device?
08:01:16 <zincy__> cocreature: Not using deriveAnyClass extension and GHC.Generics to get the instance
08:01:45 <zincy__> dgpratt: Hutton if not read already
08:02:15 <dexterfoo> asyncWithUnmask. It is not clear from the docs if the new thread starts in the masked state, or if I need to call mask_ $ asyncWithUnmask ...
08:03:06 <cocreature> zincy__: so writing the instance manually rather than deriving it?
08:06:59 <zincy__> cocreature: correct
08:07:12 <dmj`> dgpratt: typing haskell in haskell
08:07:33 <lyxia> zincy__: You won't need ToJSON if you don't call toJSON on the fields, something that the generic implementation would do implicitly
08:07:50 <cocreature> zincy__: depends on how you write the instance then. GHC won’t impose any requirements on the fields in that case but if you call toJSON on the fields you still need the instances
08:08:36 <cocreature> zincy__: also just to ease communication in the future: deriving refers to generating the instance using a deriving clause, so “manually deriving” is slightly confusing :)
08:08:40 <lortabac> dmj`: about the issue we discussed yesterday, I opened this https://github.com/bos/aeson/issues/646
08:14:22 <dmj`> lortabac: very nice
08:15:30 <dmj`> lortabac: Would be nice to somehow be able to configure how generic deriving works, and optionally apply a Default constraint to the fields of an object if this option was chosen.
08:16:22 <zincy__> uhh No instance for (GHC.Generics.Generic Digest)         arising from a use of ‘aeson-1.2.4.0:Data.Aeson.Types.ToJSON.$dmtoJSON’     • In the expression:         aeson-1.2.4.0:Dat
08:17:23 <lortabac> dmj`: I think phadej's idea in issue 614 should allow this without requiring Default
08:18:03 <dgpratt> thanks for the suggestions, dmj` and zincy__
08:19:06 <dmj`> lortabac: Interesting, I can think of a tricky way to do it with an associated type family.
08:22:38 <phaazon> damn comonads are powerful
08:22:48 <shapr> show me!
08:22:50 <phaazon> oh lortabac you’re there! :D
08:22:56 <phaazon> shapr: right :D
08:23:02 <lortabac> dmj`: if I understand his proposal correctly, the FromJSONField class would allow us to define what to return if the key is not there
08:23:04 <phaazon> > pure "test"
08:23:06 <lambdabot>  error:
08:23:06 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M190126258896...
08:23:06 <lambdabot>        prevents the constraint ‘(Show (f0 [Char]))’ from being solved.
08:23:09 <phaazon> ok
08:23:24 <phaazon> > @import Control.Comonad
08:23:26 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
08:23:34 <phaazon> how do I do that again? :D
08:23:36 <dmj`> lortabac: if FromJSONField has an associated type family, then I think it’s the asme idea
08:23:43 <dmj`> same*
08:23:48 <cocreature> @let import Control.Comonad
08:23:50 <lambdabot>  Defined.
08:23:59 <phaazon> danke red-haired creature! \o
08:24:04 <lortabac> phaazon: :)
08:24:15 <cocreature> phaazon: oh no, now my cover is blown!
08:24:19 <phaazon> @let import Data.List.NonEmpty
08:24:20 <lambdabot>  Defined.
08:24:20 <phaazon> cocreature: :D
08:24:44 <dminuoso> cocreature: By the way - is your name in reference to the tradition in category theory?
08:24:49 <phaazon> (10 :| [1, 2, 3]) =>> \(h :| l) -> (h * 2, l)
08:24:54 <phaazon> > (10 :| [1, 2, 3]) =>> \(h :| l) -> (h * 2, l)
08:24:56 <lambdabot>  (20,[1,2,3]) :| [(2,[2,3]),(4,[3]),(6,[])]
08:24:57 <dminuoso> Do you consider yourself the dual of a creature? =)
08:24:58 <phaazon> shapr: ^
08:24:58 <cocreature> dminuoso: yeah :)
08:25:08 <dminuoso> cocreature: Figures. =)
08:25:08 <phaazon> it took me several minutes to actually get what was going on
08:25:14 <phaazon> also, duplicate for non-empty lists is funny
08:25:24 <phaazon> > duplicate $ 10 :| [1, 2, 3]
08:25:26 <lambdabot>  (10 :| [1,2,3]) :| [1 :| [2,3],2 :| [3],3 :| []]
08:25:34 <ocramz> hullo !
08:25:45 <dminuoso> phaazon: why is it funny?
08:25:57 <phaazon> I don’t know
08:26:05 <phaazon> it generates hilarity in the inner child of mine
08:26:06 <phaazon> :D
08:26:07 <shapr> phaazon: looks like a powerset at first glance
08:26:13 <shapr> for the duplicate call
08:26:17 <cocreature> hey ocramz :)
08:26:22 <phaazon> a powerset?
08:26:25 <phaazon> hello ocramz
08:26:26 <shapr> uh, all the subsets
08:26:36 <dminuoso> :t duplicate
08:26:37 <lambdabot> Comonad w => w a -> w (w a)
08:26:39 <shapr> hejsan ocramz
08:26:51 <phaazon> > duplicate (1, 2, "hey")
08:26:53 <lambdabot>  error:
08:26:53 <lambdabot>      • No instance for (Comonad ((,,) Integer Integer))
08:26:53 <lambdabot>          arising from a use of ‘e_112’
08:26:56 <phaazon> > duplicate (1, "hey")
08:26:57 <dminuoso> phaazon: This usually replaces each element with the entire container set to that elements focus.
08:26:58 <lambdabot>  (1,(1,"hey"))
08:27:04 <phaazon> dminuoso: yeah
08:27:18 <phaazon> I noticed that with extend (i.e. the =>> operator)
08:27:21 <shapr> phaazon: where have you been reading about this?
08:27:29 <phaazon> shapr: what do you mean?
08:27:35 <phaazon> where did I discover comonads?
08:27:39 <shapr> sure
08:27:42 <phaazon> a few years ago, in a blog post
08:27:53 <phaazon> maybe Gabriel’s one
08:27:54 <shapr> edwardk has tried to convince me that comonads are powerful, but I don't really get it.
08:27:55 <phaazon> or someone else
08:27:55 <dminuoso> phaazon: Note my emphasis on *usually* because formally Comonad is an abstract interface. But the main interesting instances tend to be kind of zipperish.
08:28:04 <phaazon> shapr: I don’t use them at all
08:28:10 <phaazon> but I’m trying to figure out use cases
08:28:14 <shapr> oh, cool
08:28:18 <shapr> will you be writing your own blog post?
08:28:23 <phaazon> shapr: sure
08:28:33 <phaazon> dminuoso: yeah, it’s kind of the same thing about contravariant functors
08:28:43 <phaazon> usually, they somehow adapt the input
08:28:55 <phaazon> but talking about input is wrong, because contravariant functors are an abstraction :)
08:29:34 <phaazon> shapr: I tend to see comonads as a way to recursively traverse a structure by having a “super zoom” power
08:30:44 <dminuoso> Right
08:30:50 <dminuoso> phaazon: (Though Im sure if you asked edward he could tell you endless stories about the joys of Comonad)
08:30:55 <dminuoso> Just be sure to bring a blanket, because the fire might not last that long.
08:31:08 <phaazon> dminuoso: also, I’m pretty sure I already had that exact talk with him years ago :D
08:31:13 <phaazon> I’m almost sure I did
08:31:24 <phaazon> haha
08:31:45 <phaazon> what I lack about comonads is the “oh, I recognize the use case!”
08:31:57 <phaazon> I have this for a lot of abstractions in Haskell, like contravariant functors, divisible, etc.
08:32:00 <phaazon> but comonads…
08:32:20 <phaazon> I’m always like “yeah whatever, I’ll rewrite the code every time, I don’t have to look for use case of that monster”
08:32:26 <phaazon> which is a wrong way of reasoning, anyway :)
08:32:41 <dminuoso> phaazon: Contravariant is boring by the way!
08:32:55 <shapr> I also learn the most when I try to find ways to use a new tool/toy.
08:33:04 <dminuoso> Profunctor is where the good stuff is.
08:33:07 <shapr> arrows!
08:33:12 * shapr goes back to the stone age
08:33:55 <dminuoso> phaazon: It was a really cool feeling to finally grok the "lenses are coalgebras of the costate comonad" by the way.
08:34:16 * shapr 's brain explodes
08:34:21 <dminuoso> (I didnt understand it in a useful sense, just enough to understand it roughly)
08:34:35 <phaazon> dminuoso: you’re speaking chinese te me
08:34:45 <ystael> dminuoso: i feel like what you just said is the haskell equivalent of that weaponized german joke from the monty python sketch
08:34:46 <phaazon> dminuoso: well
08:34:53 <phaazon> Contravariant / Profunctors are not really the same thing
08:35:05 <phaazon> you can’t say Contravariant is boring
08:35:11 <phaazon> because a predicate is a contravariant functor
08:35:16 <phaazon> while it’s surely not a profunctor :)
08:35:41 <dminuoso> Watch me: Contravariant is boring!
08:35:43 <phaazon> though, I don’t know what a coalgebra nor a costate is
08:35:55 <phaazon> dminuoso: please count to infinity
08:35:57 <phaazon> :D
08:36:04 <dmj`> lortabac: There’s definitely an easier way of doing this than changing aeson internals
08:36:12 <dstolfa> dminuoso: heh, yes they are (@ lenses)
08:37:13 <phaazon> I think I’ve never been to actually using comonads, codensities and all those things because they’re waaaaaaaaaay too more general to actually solve a specific use case
08:38:26 <dstolfa> phaazon: category theory is a nice way to think about a programming language in order to impose structure on it
08:38:32 <dstolfa> that's kind of the whole point of it
08:38:46 <dstolfa> however, solving specific problems by thinking of it in terms of category theory probably isn't sufficient, as you're really just talking about the structure
08:38:49 <dstolfa> not the details
08:38:53 <maerwald> it usually just produces more monadic weirdos
08:39:40 <maerwald> and, even if they are useful, they don't actually solve a *problem*
08:39:51 <dmj`> lortabac: I’ll try to write a small prototype at lunch
08:39:52 <maerwald> it's just another way of doing something
08:40:32 <phaazon> maerwald: sure :)
08:40:56 <maerwald> I like functional programming
08:41:09 <maerwald> so I write functions, not monads :>
08:41:19 <tsaka__> I thoroughly enjoyed doing these exercises https://github.com/data61/fp-course are there more like it?
08:41:31 <phaazon> we have a forever-lasting discussion at work about whether we should use recursion-schemes in our codebase
08:41:32 <shapr> maerwald: hey, you never did respond to my unit test vs property test question
08:41:54 <phaazon> it’s a bit opinionated, but I don’t see myself reasoning and thinking in terms of apomorphisms and histomorphisms :D
08:41:59 <phaazon> my brain is not ready yet
08:42:00 <phaazon> :D
08:42:21 <lortabac> dmj`: please tell me if you succeed
08:42:35 <drets> Hi, I have a data type with about 30 records, I also use RecordWildCards extension to build the value of the data type. A lot of records have Maybe Something type. Is there a nice way to default value to Nothing if I didn't provide the record in MyDataType{..}?
08:42:47 <lortabac> dmj`: I spent a couple of days on this issue, but I couldn't find a solution
08:42:52 <phaazon> drets: RecordWildCards
08:43:01 <maerwald> shapr: you use unit tests when you deal with "odd data", which you cannot auto-generate easily (or when it doesn't even make sense to autogenerate, e.g. with certain REST APIs, protocols etc)
08:43:02 <phaazon> drets: you’re going to be cursed!
08:43:26 <drets> phaazon: ?
08:43:35 <glguy> drets: You can make a "default" value of your record type and update it with record wild cards
08:43:44 <glguy> initialValueWithNothings{..}
08:43:53 <phaazon> drets: I don’t get why people like RecordWildCards
08:43:59 <phaazon> I truly hate it :D
08:44:15 <phaazon> it changes the type of a function by dropping a parameter
08:44:17 <phaazon> it’s so confusing
08:45:13 <glguy> I don't know what "changes the type of a function by dropping a parameter" means, but they are nice when constructing a record value: do field1 <- m1; field2 <- m2; return Record{..}
08:45:21 <listquestion> Hello guys, I have following question....are there possible cases where a list can be written as (x,xs)? I only know (x:xs), but am confused by some homework
08:45:33 <phaazon> glguy: even in that case, they’re not nice
08:45:43 <phaazon> because you don’t directly see which bindings go in the Record
08:45:47 <phaazon> and about the dropping parameter
08:45:47 <glguy> listquestion: No, (x,xs) always makes a tuple
08:45:49 <ski> listquestion : no, `(x,xs)' is a pair, not a list
08:45:58 <phaazon> if you define your type like this:
08:46:08 <phaazon> data Foo = Foo { x :: Float }
08:46:17 <phaazon> the type of x is x :: Foo -> Float
08:46:19 <listquestion> glguy, ski thank you
08:46:30 <phaazon> with RecordWildCards, it’s x :: Float
08:46:37 <drets> glguy, thank you. initialValueWithNothings has original type of MyDataType?
08:46:41 <phaazon> I remember the first time I read a codebase using it
08:46:49 <phaazon> I was so confused :)
08:46:54 <glguy> phaazon: Sure, it shadows the field accessors. I don't like it in patterns.
08:47:03 <phaazon> I don’t like it at all :D
08:47:11 <phaazon> I like the Puns extension, though
08:47:13 <ski> listquestion : the empty list is `[]'. all non-empty lists (at least one element) is of the form `x:xs', where `x' is the first (head) element, and `xs' is the rest of the elements (the tail of the list, which is itself a list, possibly empty)
08:47:18 <phaazon> because it doesn’t change the type
08:48:21 <ski> listquestion : all lists are of one of these two forms. then there's shorthand notation like `[a,b,c,d]' meaning `a:(b:(c:[]))' / `a:b:c:[]'
08:49:14 <ski> phaazon : yea .. record field extraction syntax is a mess, imho
08:49:16 <cocreature> phaazon: NamedFieldPuns still “changes” the type (i.e. the identifier has a different type than the one it shadows)
08:49:18 <dmj`> lortabac: We can piggy-back on top of FromJSON inside the generics instances for our type class to add Default constraints. Another approach is to create a function that returns a Parser while traversing the Generic Rep (where the arguments to this constructed function are the default values for the fields in the record, in the case they are missing).
08:50:01 <phaazon> cocreature: hm, not really IIRC
08:50:11 <ski> (in SML, if there's a field `x' in a record, then the field extraction function is written `#x', not just `x'. less confusing)
08:50:13 <phaazon> oh yeah you’re right
08:50:23 <cocreature> originally you have a selector in scope
08:50:28 <phaazon> yeah that’s right
08:50:33 <phaazon> I don’t like it either then
08:50:34 <phaazon> :D
08:50:42 <cocreature> in that regard it’s exactly the same as RecordWildCards
08:50:47 <phaazon> yeah
08:50:59 <cocreature> the difference is that for NamedFieldPuns you at least visually see that the identifier is being shadowed
08:51:00 <phaazon> it’s a bit better to me because you have to pass the bindings explicitely
08:51:05 <phaazon> yeah
08:51:38 <listquestion> ski, I am aware of that. I'm just confused by some code that we got as solution for an exercise. Because it takes a list as an input, but then the code is like that "parseProd l = let (summand1,rest1)" in case of....
08:52:28 <listquestion> so I'm trying to figure out where that tupel comes from, but the code is quite long so I don't think it makes sense to paste it all
08:57:12 <webhackerlol> hi Is it easy to build a board game webapp in haskell
08:58:30 <shiona_> For some it might be
08:58:35 <shiona_> but not for most
08:58:47 <webhackerlol> shiona_:  telling me ?
08:58:53 <shiona_> yes
08:59:10 <webhackerlol> so should I use nodejs ?
08:59:47 <shiona_> Well...
09:00:08 <maerwald> no, it isn't
09:00:23 <maerwald> maybe try elm for simple stuff
09:00:31 <shiona_> If you are taking a course or have some other sort of deadline to meet and you just need to make a webapp game then probably yes
09:01:08 <shiona_> didn't think of elm. That might be ok also
09:02:00 * hackage http-client 0.5.13 - An HTTP client engine  http://hackage.haskell.org/package/http-client-0.5.13 (MichaelSnoyman)
09:03:12 <pounce_> Hello, I'm just tried to import `Data.List.Ordered` and got an error "Could not find module ‘Data.List.Ordered'" but importing Data.List worked fine
09:03:26 <sm> We make these webapps in haskell, and master the tools and language and libraries and concepts, and do the other things.. not because they are easy, but because they are hard!
09:03:52 <glguy> pounce_: Data.List comes from the base package which you already had available. Whatever Data.List.Ordered is comes from a package you don't have. Which package did you have in mind?
09:04:00 <webhackerlol> elm never heard
09:04:02 <Welkin> pounce_: modules and packages are not the same thing
09:04:17 <Welkin> webhackerlol: what about elm?
09:04:30 <webhackerlol> Welkin:  elm I am checking
09:04:34 <webhackerlol> Never used it
09:04:44 <Welkin> webhackerlol: I use it
09:04:48 <pounce_> ooh, I thought it came from the base package. Looks like `data-ordlist`
09:05:43 <pounce> How do I install a package?
09:06:14 <ski> listquestion : well if there's `let (summand1,rest1) = ...' then the expression `...' there will evaluate to a pair. `parseProd l' doesn't have to evaluate to a pair, though
09:06:16 <Welkin> the official elm guide is okay, but it takes forever to get updated and is too trivial
09:06:31 <Welkin> I recently found this extremely good (free) book on elm http://elmprogramming.com/
09:06:38 <Welkin> it is up to date
09:08:03 <webhackerlol> I have some 3 months deadline to showcase any demo to my boss
09:09:23 <webhackerlol> is it spam ?
09:09:47 <glguy> Yes and no. It's from a chat bridge server that regularly spams us with its unreliability
09:09:51 <glguy> but not unexpected
09:10:18 <Welkin> thanksyes, it is matrix
09:10:53 <Welkin> webhackerlol: you should be able to build an app with elm by following that very in-depth guide in less than a week
09:11:11 <webhackerlol> Wow really
09:11:25 <webhackerlol> http://elmprogramming.com/  this I am reading now
09:11:29 <Welkin> yeah
09:11:44 <Welkin> it took me about 2 weeks to build an app in elm when I started learning it
09:11:49 <Welkin> if I had that guide it would have been much less
09:12:38 <Welkin> I also did it kind of wrong
09:12:49 <Welkin> or rather, poorly
09:13:31 <infinisil> That's how you learn stuff!
09:13:49 <Welkin> yes, indeed
09:15:24 <webhackerlol> Welkin:  do you know this game called ludo ?
09:17:07 <Welkin> no
09:20:58 <webhackerlol> https://en.wikipedia.org/wiki/Ludo_(board_game)  there are many games but I just want to build a duplicate app with different ideas in  ind
09:21:01 <webhackerlol> mind*
09:21:19 <webhackerlol> chess or checkers should be very hard
09:23:34 <wazdee_> I was wondering if there was a way to pass a command to stack ghci from the command line to run
09:25:09 <glguy> wazdee_: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html?highlight=#eval-mode
09:25:10 <Psybur> Is there a more concise way to do: f g x y = foldr (\a b -> foldr (\c d -> pure (g a c)) x y) y x ?
09:25:53 <infinisil> @pl f g x y = foldr (\a b -> foldr (\c d -> pure (g a c)) x y) y x
09:25:53 <lambdabot> f = join . (flip .) . flip flip id . ((ap . ((foldr . (const .)) .) . flip) .) . flip . ((foldr . ((const . pure) .)) .)
09:25:57 <wazdee_> @glguy thanks!
09:25:57 <lambdabot> Unknown command, try @list
09:26:10 <infinisil> That is more concise, right?!
09:26:29 <Psybur> lol
09:34:24 <glguy> Psybur: That one's related to, but behaves differently to, f<$>a<*>b <|> a <|> b that you asked about yesterday. What's actually behavior you're trying to build?
09:35:12 <Welkin> how does that expression associate?
09:35:22 <glguy> as indicated with the spacing
09:35:27 <Welkin> okay
09:35:42 <Psybur> If both, apply a function to their contents, otherwise return which one has stuff
09:35:50 <glguy> at what type?
09:35:58 <glguy> these things behave differently on different types
09:36:28 <Psybur> I'm working with maybes but wondering what the most generic way is
09:36:56 <Psybur> I don't like the alternative optional way because of the extra wrapping in maybe
09:37:01 <glguy> Those definitions behave differently on lists
09:37:09 <Psybur> nested fold seems more efficient
09:37:48 <Psybur> yes it will only use the heads of the lista
09:38:06 <Psybur> well head and tail
09:38:29 <Psybur> wait no heads
09:39:07 <Psybur> I could make g process the accumulators too to make it more generic
10:09:45 <webhackerlol> #elm dull :(
10:10:17 <shapr> webhackerlol: sharpen your tools!
10:10:38 <webhackerlol> shapr:  what you mean shapr  ?
10:11:53 <cocreature> shapr: more like shapr your tools :)
10:12:18 <pounce> Hello, when I run `cabal install data-ordlist` "could not find module 'Prelude'" and "could not find module 'Data.List'"
10:14:16 <pounce> I can use these modules from GHCI too
10:14:19 <glguy> pounce: That's unusual. To save some work it will help if you can paste the whole terminal contents to a pastebin including the commands you ran and the output you got: https://gist.github.com
10:18:34 <pounce> glguy: here are the commands I ran and their output https://gist.github.com/4e554c4c/7b3b22bb29f8ab633ec5247831f12141
10:19:01 <glguy> pounce: Is this Arch Linux?
10:19:28 <pounce> yes
10:20:16 <glguy> In order to use ArchLinux's package manager provided Haskell packages you have to jump through extra ArchLinux hoops
10:21:39 <glguy> Like the rest of arch, you can probably figure out how to fix it on the arch wiki. The general recommendation seems to be not to use archlinux's package manager for your Haskell dev, though
10:22:14 <pounce> ah, I had this problem with python pip too. pacman doesn't seem to play nice with language package managers
10:22:21 <cocreature> at least not for anything except for getting GHC
10:22:44 <geekosaur> like most package managers, it's interested in what it needs for its own ecosystem. not for the ecosystem you need (e.g. for development)
10:22:53 <glguy> I wouldn't bother getting GHC that way, either. I wouldn't want a pacman update to change my GHC version out from under me when I'm doing development
10:23:11 <pounce> the only things I installed through pacman were ghc and cabal
10:23:24 <geekosaur> and you pretty much have to go nix-style to escape that, because it's actually a rather hard problem
10:23:42 <geekosaur> the base package is wired into ghc
10:24:20 <pounce> installing cabal already took up half my drive space, but I'll see what I can do XwX
10:25:30 * hackage llvm-hs-pure 6.2.1 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-hs-pure-6.2.1 (cocreature)
10:26:31 <pounce> So should I let stack manage ghc and such?
10:27:28 <glguy> I prefer installing GHC myself into my home directory and using cabal's new-build command for building
10:41:00 * hackage llvm-hs 6.3.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-hs-6.3.0 (cocreature)
10:41:11 <lortabac> dmj`: both solutions seem quite hard in practice
10:42:03 <geekosaur> you will find that a number of other language communities will tell you the same thing (I know this happens with perl, python, ruby in particular): for dev don;t use the package manager, install your own copy
10:43:11 <t7> snap install haskell
10:43:32 <Welkin> I prefer to manage my own ghc installations too
10:43:51 <lortabac> dmj`: but if one of them works it would be great :)
10:44:11 <nshepperd> pounce: install cabal-static from AUR
10:44:14 <Welkin> lortabac: are you sure you are responding to the correct person?
10:44:25 <Welkin> I haven't seen dmj` say anything in here yet today
10:44:43 <lortabac> yes I am sure :)
10:44:57 <Welkin> lortabac: perhaps a pm would be more appropriate then
10:45:21 <nshepperd> stack is a good choice too, but I haven't got around to publishing the cleaned up aur package for it yet
10:46:33 <lortabac> Welkin: it's ok, we will resume our conversation tomorrow
10:59:18 <pikajude> does anyone know if there's some useful literature around for writing a pretty-printer for a grammar that has a certain set of operator precedences and associativities
11:00:15 <dmj`> lortabac: I think it’s possible. I currently do the default value if missing in envy for environment variables. But I’d like to try the type family synonym w/ a default generic instance approach.
11:01:54 <pikajude> does the Show instance deriver take precedence into account?
11:01:57 <pikajude> err, associativity
11:02:11 <pikajude> it doesn't seem to
11:02:54 <pikajude> ah no, it doesn't, it parenthesizes the expression instead
11:03:00 <pikajude> i'm trying to write a pretty-printer that doesn't need to do that, though
11:03:06 <infinisil> pikajude: Idris' Show does: https://github.com/idris-lang/Idris-dev/blob/master/libs/prelude/Prelude/Show.idr#L42-L66
11:03:50 <pikajude> associativity?
11:03:58 <pikajude> maybe i'm misunderstanding that code block, i've never written idris
11:05:00 <ixxie> pikajude: there was this really extensive blog post: http://journal.stuffwithstuff.com/2015/09/08/the-hardest-program-ive-ever-written/
11:05:03 <infinisil> I'm not sure how it works exactly, but it takes precedence into account
11:05:20 <infinisil> Ah yeah no associativity right
11:05:24 <glguy> pikajude: I doesn't appear to take associativity into account like you're asking about
11:05:24 <pikajude> oh that's a good URL slug
11:05:36 <ixxie> pikajude: they write a dart formatter program, but took great pains to document all the mistakes
11:05:42 <ixxie> pikajude: so this may be very helpful :)
11:05:54 <infinisil> pretty-printer != formatter though
11:05:58 <ixxie> pikajude: associated HN discussion found https://news.ycombinator.com/item?id=10195091
11:06:05 <ixxie> oh
11:06:06 <ixxie> lol
11:06:07 <infinisil> a pretty printer is much easier
11:06:09 <ixxie> thats true
11:06:14 <pikajude> yeah, i'm writing a formatter
11:06:20 <infinisil> Oh well then
11:06:37 <pikajude> lol
11:06:52 <infinisil> pikajude: What language?
11:06:55 <glguy> pikajude: it should be as simple as adding an extra parameter with type data Assoc = Left | Right | None (with names that don't collide with Either)
11:06:57 <pikajude> nix
11:07:02 <pikajude> lol
11:07:07 <pikajude> i hope nix doesn't already have a formatter
11:07:09 <pikajude> or rather, i hope it does
11:07:12 <pikajude> because i need one
11:07:20 <infinisil> pikajude: Lol, I just thought about this too recently!
11:07:26 <pikajude> glguy: yeah, i have the associativity data available, i was just trying to figure out how to *implement* it
11:07:32 <pikajude> i'm not as big-brained as some haskell users :(
11:07:59 <infinisil> pikajude: I thought about using hnix first, but that doesn't work, because formatting needs whitespace information, which hnix doesn't parse
11:08:09 <pikajude> it doesn't?
11:08:13 <glguy> pikajude: I don't know what that comment about other users has to do with anything, but once you have not only a precdence::Int parameter but an associativity one you'll be able to resolve the cases where the precedences match
11:08:16 <pikajude> oh, you mean like blank lines and comment preservation and stuff
11:08:30 <infinisil> pikajude: A parser for a language just throws away comments
11:08:36 <infinisil> pikajude: The linked blogpost mentions this as well
11:09:03 <pikajude> oh, wait, so i have to write a whitespace preserving parser for nix too?
11:09:05 <pikajude> ffs
11:09:10 <infinisil> Yup
11:09:24 <pikajude> ok this project just became not worth it
11:09:44 <infinisil> It would be really nice though, but I'm also kind of meh about it
11:09:52 <pikajude> it would be, yeah
11:09:57 <infinisil> We could (not) work on it together hah
11:10:14 <pikajude> yeah, i just realized recently how useful it is to have autoformatting for everything
11:10:22 <pikajude> at work we have it for every language i work in
11:10:33 <pikajude> removes a source of cognitive load
11:10:54 <pikajude> although from the blog post i think dart is a lot harder to format than something like nix or haskell is
11:11:00 <Welkin> pikajude: except when the autoformatting isn't what you want
11:11:13 <pikajude> well, if that day ever comes, then i'm sure i'll find a solution
11:11:14 <infinisil> FWIW, nix-mode just got an update that makes indentation much better: https://github.com/NixOS/nix-mode/pull/42
11:11:34 <pikajude> i don't think my brain is big enough for emacs either
11:11:53 <Welkin> haskell-mode is really good
11:11:58 <infinisil> vim-nix (or nix-vim?) has good indentation already too
11:12:01 <pikajude> oh
11:12:06 <pikajude> yeah
11:12:14 <Welkin> it makes me feel annoyed at other language modes that aren't as good, or ones that are even awful
11:12:19 <pikajude> i was looking more for good solutions to format long or confusing expressions
11:12:19 <Welkin> like elm-mode, which sucks in emacs :(
11:12:30 <pikajude> which i have a lot of in my darwin-configuration.nix
11:12:37 <Welkin> sadly some languages only get good modes in editors like vscode for some strange reason
11:12:39 <pikajude> and i don't feel like putting the effort in to fix it myself
11:12:42 <infinisil> pikajude: Can I see?
11:12:51 <infinisil> Welkin: LSP to the rescue
11:13:05 <pikajude> my configuration?
11:13:08 <pikajude> or the formatter?
11:13:10 <Welkin> infinisil: what's that?
11:13:18 <infinisil> pikajude: Why not both :D
11:13:38 <infinisil> Welkin: http://langserver.org/
11:14:32 <pikajude> one sec, i'll pastebin the configuration
11:15:23 <pikajude> https://gist.github.com/pikajude/a5bbb67632eacfbe5e183491e622a465
11:15:25 <pikajude> look at this monstrosity
11:15:36 <infinisil> I also want to eventually have a go at implementing an LSP server for Nix
11:16:00 * hackage gym-http-api 0.1.0.1 - REST client to the gym-http-api project  http://hackage.haskell.org/package/gym-http-api-0.1.0.1 (stites)
11:16:59 <infinisil> pikajude: That sure is something! Can I give some tips over on #nixos?
11:17:06 <pikajude> lol
11:17:07 <pikajude> sure
11:21:00 * hackage HNumeric 0.3.3.0 - Haskell Numeric Library with pure functionality, R & MATLAB Syntax.  http://hackage.haskell.org/package/HNumeric-0.3.3.0 (edeftg)
11:24:16 <sbrg> Hello. I'm trying to dockerize an application which uses mueval, which in turn uses hint. my naive try was originally to simply copy the two mueval binaries(mueval and mueval-core). this leads to a runtime error with openFile because it seems to try to open a `settings` file the path to which seems to be hardcoded to use the environment in which the binaries were built. is there something I can do to remedy
11:24:18 <sbrg> this? I'd prefer to avoid having to built the entire thing inside docker.
11:26:23 <geekosaur> sbrg, mueval links in the compiler it was built with. Because that's how the ghc-api works.
11:27:02 <geekosaur> No, this can't reasonably be changed. Compiler internals do not have a fixed API that can be stable across versions.
11:27:46 <sbrg> i was afraid this was the case. I guess i'll have to bite the bullet and built the entire thing inside docker
11:29:02 <geekosaur> (there is some work on this that mueval may be able to take advantage of at some point, but it's still in development.)
11:31:00 * hackage s-cargot-letbind 0.2.3.0 - Enables let-binding and let-expansion for s-cargot defined S-expressions.  http://hackage.haskell.org/package/s-cargot-letbind-0.2.3.0 (KevinQuick)
11:34:53 <Welkin> s-cargot? lol
11:53:37 <dmj`> @package s-cargot
11:53:37 <lambdabot> http://hackage.haskell.org/package/s-cargot
11:53:53 <pounce> Hello, I have a function `f :: (a -> bool) -> [a] -> ([a],[a])` and I want to make a recursive expantion that appends to one of the lists. I could do this with `f (x:xs) = (x: (fst (f xs)), snd (f xs))` but that calls `f` twice which doesn't seem to be needed
11:54:03 <pounce> Can I do this with only calling f once?
11:54:24 <pounce> (whoops, discard the predicate func for now)
11:54:29 <Cale> let (us, vs) = f xs in ...
11:54:32 <sbrg> yes, use a let-binding or `where`
12:12:52 <pounce> lmao I just realized I rewrote the partition function
12:14:21 <geekosaur> isn't there a "stages of a haskell programmer" entry about that?
12:14:31 <geekosaur> (i.e. we've all been there, one way or another)
12:14:33 <pounce> I'm probably at stage 0, whatever that is
12:14:56 <pounce> it was fun though! https://gist.github.com/4e554c4c/a9f634b380d21f5b23181893c2afb39a
12:15:15 <mitchellsalad__> Hello folks, can someone please help me understand what the purpose of avoiding let-floating here is: https://github.com/HeinrichApfelmus/reactive-banana/blob/ee9d5a3962c2bc48782512f54a3ae14a7a3d5b4b/reactive-banana/src/Reactive/Banana/Internal/Combinators.hs#L161
12:15:24 <cocreature> pounce: rewriting the standard library is a pretty good way to learn some Haskell :)
12:15:40 <infinisil> If you were only to write functions that don't exist already you wouldn't be writing much anyways
12:15:53 <maerwald> cocreature: and it's necessary to do useful stuff
12:16:46 <pounce> hehe that's what I figure
12:16:55 <Welkin> geekosaur: this? http://www.willamette.edu/~fruehr/haskell/evolution.html
12:17:11 <geekosaur> that's one of them but there are others
12:17:32 <pounce> Now I'm looking at the existing definition of partition, and it uses a functino that does patterns like this `select p x ~(ts,fs)...` what's the tilde for+
12:17:37 <blackandblue> hi. is there anyone here rocking 1366x768 laptop or am I the only crazy one? for haskell coding ofc
12:18:07 <zfnmxt> blackandblue: I have the same...not that it really matters.
12:18:13 <geekosaur> mine is retired. mostly because it's older than some of the people in this channel.
12:18:36 <Welkin> pounce: lazy pattern matching
12:18:42 <blackandblue> should I waste extra money to get full hd laptop?
12:19:00 <Welkin> blackandblue: full hd is not very high resolution either, lol
12:19:11 <blackandblue> hmm so 4k it is?
12:19:13 <Welkin> and yes, hidpi displays are pretty standard these days
12:19:16 <Welkin> no, not 4k
12:19:17 <blackandblue> damn 4k laptops are quite expensive
12:19:22 <Welkin> you are thinking of televisions
12:19:39 <blackandblue> then what resolution should I get if full hd is not good enough?
12:19:42 <geekosaur> I wouldn;t worry much about resolution. I ditched mine not because of resolution but because it's ancient and slooooooow
12:19:44 <Welkin> it is good enough o.o
12:19:53 <Welkin> it's just not "high resolution" these days
12:20:08 <Welkin> I am on 1440x900 for my main laptop
12:20:09 <dpanth3r_> 1440p is a good middle ground
12:20:10 <blackandblue> should I keep using 1366x768?
12:20:15 <Welkin> yes, if it suits you
12:20:20 <geekosaur> "high resolution" matters if you're playing (or making) games. for coding, not so much
12:20:23 <dmwit> You can't program Haskell well with any fewer than 16M pixels and 16M colors.
12:20:29 <Welkin> the vertical space might be a bit tight, but emacs can fix that
12:20:37 <blackandblue> because everything else I upgraded. its i5 dual core processor with 16 gigs ram and 256gb ssd.
12:20:46 <cocreature> dmwit: and I thought 2 colors should be enough for everyone
12:20:47 <Welkin> blackandblue: is this a laptop?
12:20:53 <dysfun> 1440x900 is quite small though. you surely want at least 1080p
12:20:59 <blackandblue> Welkin, yes old dell latitude
12:21:06 <geekosaur> enh. you can get by with less
12:21:11 <cocreature> a better resolution might be nice but it’s by no means necessary
12:21:20 <Welkin> dysfun: I find 1440x900 to be perfect
12:21:21 <blackandblue> I see
12:21:27 <ystael> blackandblue: once upon a time, X had a wonderful little font called `fixed`
12:21:30 <blackandblue> I heard its good for eyes when coding on good resolution
12:21:32 <dysfun> i find 1080 could be a little bit bigger ideally
12:21:37 <geekosaur> higher res means you get fancier toys alongside, but you don;t necessarily need the toys
12:21:39 <ystael> it is 6x13 pixels and worked just fine for many years
12:21:42 <Welkin> but it is nice to see how gorgeous text looks on my 3200x1800 display
12:21:52 <Welkin> super sharp
12:21:57 <geekosaur> then again I hail from the days of 80x24 terminals :[
12:21:59 <geekosaur> :p
12:22:00 <blackandblue> geekosaur, the specs I mentioned are good enough ?
12:22:08 <blackandblue> 3rd gen i5 dual core processor btw
12:22:10 <Welkin> yeah go with it
12:22:11 <geekosaur> if they're good enough for you,m they;re good enough
12:22:23 <geekosaur> there's no hard rules here, there's what you are comfortable with
12:22:24 <blackandblue> never tried heavy compiling, else it runs good
12:22:39 <zfnmxt> blackandblue: with xmonad, I think 768p is ok: http://i.hmp.me/m/decb7aa90ca2edd6d105bd5d261bbf66.png
12:22:40 <[exa]> since when we need super-res displays to code haskell?
12:23:15 <blackandblue> zfnmxt, cheers. you also are in my league
12:23:15 * [exa] crawls back to his 80x24 cave
12:23:16 <dysfun> you don't *need* it, but it can help you get more useful things on screen at once
12:23:16 <Welkin> [exa]: expect new reddit
12:23:19 <Welkin> except*
12:23:40 <zfnmxt> Haha, right
12:23:43 <Welkin> I mean, zfnmxt
12:24:10 <blackandblue> because all the fancy instagram coders I find are using dell xps or macbooks
12:24:12 <zfnmxt> My laptop started at 1080p actually, but the screen was smashed and I only could find a 768p replacement. It hasn't made so much of a difference, though. Only so much you can see on a 12.5" screen.
12:24:13 <[exa]> that sounds like I should probably open reddit to see what's new
12:24:15 <blackandblue> so I feel a bit demotivated
12:24:43 <hexagoxel> mitchellsalad__: i suppose let floating creates more sharing than desired in this case. it is a question about the "lifetime" of the `c` binding.
12:24:44 <blackandblue> zfnmxt, thats your main coding hardware?
12:24:45 <Welkin> [exa]: slow, bloated single-page-app with things hovering all over the place
12:25:12 <dysfun> Welkin: it's the future!
12:25:15 <zfnmxt> blackandblue: when I'm at uni, yeah. But at home I have a desktop. But it's fine on both. Hardware doesn't matter at all.
12:25:26 <blackandblue> I see
12:25:32 <Welkin> as long as you have at least 2 GB RAM, you are fine
12:25:37 <Welkin> ghc is a bit of a ram hog
12:25:45 <hexagoxel> mitchellsalad__: e.g. if you execute the `Moment (Cached Moment a)` action twice, do they use the same `c` ?
12:25:47 <Welkin> prefer 4 GB (which I have on this machine)
12:25:49 <dysfun> 2GB? you won't be wanting to run firefox then
12:25:50 <pounce> what the heck is `=<<`
12:25:52 <blackandblue> so I shouldn't worry about getting myself a desktop or another laptop right? I can use this laptop as main for coding ? zfnmxt
12:25:58 <zfnmxt> Buy a $300 chromebook and you'd probably still be okay :P
12:25:59 <Welkin> pounce: bind
12:26:01 <dysfun> pounce: it's >>= with arguments reversed
12:26:22 <zfnmxt> blackandblue: You should worry about writing Haskell and nothing else
12:26:25 <zfnmxt> :)
12:26:34 <pounce> what the heck is `>>=`
12:26:43 <Welkin> pounce: you'll learn in time about it
12:26:45 <blackandblue> hehe true true. thanks a lot guys. looks like I shouldnt worry about saving up for new laptop
12:26:46 <Welkin> don't worry until then
12:26:47 <geekosaur> it's what the <- in a "do" turns into
12:27:05 <[exa]> Welkin: "omg it's so big"
12:27:12 <zfnmxt> It pulls the filling out of your burrito and makes a new burrito :)
12:27:15 <pounce> blackandblue zfnmxt yeah a chromebook is where it's at. I'm running on a chrombook rn.
12:27:37 <blackandblue> where do you save all your files / code? since chromebook has little ssd
12:27:39 <mitchellsalad__> hexagoxel: Hrm, hard to chat in here with so much crosstalk, but I'll think about this for a moment & get back to you
12:27:49 <pounce> blackandblue: are you implying you need more than 16GB?
12:27:57 <geekosaur> there's -overflow
12:27:59 <pounce> running on 122mb of free space rn
12:28:06 <blackandblue> for code and files and pdfs etc... pounce
12:28:35 <zfnmxt> blackandblue: pounce: if you guys want to continue the non-haskell discussion you should probably go to #haskell-overflow
12:29:00 <pounce> ah, ok sorry for flooding
12:30:40 <pounce> So should I forget about >>= & friends for now and focus on other stuff?
12:30:53 <Welkin> it depends
12:31:09 <Welkin> I tach >>= in chapter 1 of my book because it is essential for doing IO
12:31:11 <Welkin> teach*
12:31:22 <geekosaur> eventually you should learn it because it'll help you understand what's really going on. But for now you can get by without.
12:31:27 <geekosaur> because of do notation
12:31:41 <geekosaur> but you really should learn what do botation is actually doing at some point
12:31:46 <geekosaur> *notation
12:31:54 <zfnmxt> Welkin: Can you link your book?
12:32:01 <Welkin> haskellroguelike.com
12:32:35 <mitchellsalad__> hexagoxel: Mind if I DM you?
12:32:52 <hexagoxel> feel free
12:32:57 <Cale> It's funny, I usually consider explicit use of >>= (at least without immediately being followed by \case) as being a good sign that something could be rewritten in a more legible form.
12:33:20 <Cale> Usually you simply want do-notation, but if not, at least =<<
12:33:29 <Welkin> Cale: yes, but you know how it all works, so you are free to use do notation without problems
12:33:41 <Welkin> for someone new, they shuld avoid do notation in my opinion
12:33:58 <exarkun> when stuff breaks, the closer that stuff is to the machine model, the easier the debugging ... sometimes.
12:34:23 <cocreature> exarkun: that’s why debugging C is so much easier than debugging Haskell? :)
12:34:25 <keegans> so, for example. i understand why Maybe is a monad (`Just 1 >>= (\x -> return $ x + 1)`), but why, for example is Redis a monad (in the Database.Redis module)
12:34:41 <exarkun> cocreature: I am completely and perfectly correct.  Because "sometimes". :)
12:35:02 <Welkin> keegans: it's not that something "is a monad" it's that it has an instance defined for the interface we call "Monad"
12:35:07 <cocreature> exarkun: well played :)
12:35:08 <exarkun> cocreature: Also, I don't know if you can remember what it's like to be a Haskell beginner, but for a Haskell beginner, debugging Haskell is not particularly easy.
12:35:36 <geekosaur> keegans, because one of the things Monad lets you do is carry around extra information. like database connections.
12:35:38 <keegans> Welkin: when is it appropriate to define a monad ?
12:35:42 <exarkun> (of course "easy" is relative and subjective ... so ...)
12:35:48 <Welkin> keegans: when it makes sense given the interface
12:35:53 <geekosaur> (this is what StateT and ReaderT do, one r/w and the other r/o)
12:36:23 <Welkin> Monad allows you to sequence things together and pass information from one thing to the next
12:36:52 <keegans> but in a kind of contained computation though
12:37:04 <keegans> so what situation , other than when computation can fail , is a monad needed ?
12:37:08 <Welkin> yes, with the constraint that they must be the same type of thing
12:37:19 <Welkin> you cannot sequence together Maybe and List, for example
12:37:20 <geekosaur> in this case it removes a lot of error-proone boilerplate
12:38:14 <geekosaur> by carrying things around in the background so you don't have to do so manually, by ensuring that operations happen in the proper order by introducing data dependencies (otherwise, being a pure language, they could be reordered_
12:38:30 <Welkin> keegans: it's not so much that something can "fail", but that the next thing can depend on the result of the previous thing
12:39:25 <keegans> Welkin: excuse my possible botching of this , but comparable to a JavaScript 'callback' in the respect that they need to be chained
12:40:11 <geekosaur> callbacks are actually not a bad comparison. that's what's behind the "haskell-likes" making inroads in the js community
12:40:11 <Welkin> keegans: yes, a javascript Promise is similar to Monad (but not the same thing)
12:41:56 <keegans> my next haskell goal is to understand the internals of the (in my inexperienced eyes) Discord.hs haskell library for constructing Discord bots
12:42:20 <keegans> as of right now i've narrowed it down to the DiscordM monad, Effects and eventing
12:42:36 <keegans> i also really still don't understand applicative functors (<*>)
12:42:55 <keegans> functors (fmap ) i can understand however
12:43:07 <Welkin> :t fmap
12:43:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:43:12 <Welkin> :t (<*>)
12:43:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:43:15 <Welkin> see the similarity?
12:43:39 <Welkin> applicatives are useful for things like this
12:43:51 <Welkin> > (,) <$> 2 <*> True
12:43:53 <lambdabot>  error:
12:43:53 <lambdabot>      • Couldn't match expected type ‘f a1’ with actual type ‘Bool’
12:43:53 <lambdabot>      • In the second argument of ‘(<*>)’, namely ‘True’
12:44:04 <Welkin> > (,) <$> Just 2 <*> Just True
12:44:06 <lambdabot>  Just (2,True)
12:44:33 <Welkin> where <$> = fmap
12:45:05 <Welkin> the most obvious use for applicatives is parsers
12:45:13 <Welkin> if you have not yet written your own parser, try it
12:46:50 <keegans> i have played around with Parsec
12:47:05 <keegans> but the operator i used that was important was <|>
12:47:37 <keegans> so your mapping the (,) operator over each of the contents of the functors ?
12:47:39 <keegans> hmm
12:47:59 <keegans> ah
12:48:20 <Welkin> keegans: no, I don't mean using parsec
12:48:27 <Welkin> I mean writing your own parser library from scratch
12:48:32 <Welkin> it's really easy using applicatives
12:48:51 <Welkin> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
12:48:57 <Welkin> look at the assignment for week 10
12:50:25 <keegans> Welkin: very cool, thank you
12:50:36 <keegans> this looks like a fun project
12:50:39 <Welkin> it is
13:00:37 <glittershark> has there been any not-three-years-old
13:00:54 <glittershark> work on non-endofunctor category stuff in haskell ala ekmett/hask ?
13:01:21 <blackandblue> Welkin, is it ok to learn the CIS194 course when I am 30+? I feel a bit shame because its university course and I am way old for it
13:01:29 <glittershark> I keep getting the feeling that `hoist` and `fmap` should be the same function :(
13:02:05 <Welkin> blackandblue: of course
13:02:08 <Welkin> there is no shame to be had
13:02:20 <Welkin> learning is a lifelong endeavor
13:02:23 <blackandblue> isnt it too late to learn haskell from university?
13:02:27 <blackandblue> True that.
13:02:37 <Welkin> in college I took classes with people who were 3 times my age
13:02:50 <blackandblue> ahan
13:02:52 <glittershark> I know certain people in this channel who went back to university at roughly your age to learn math and stuff :)
13:02:56 <Welkin> back to university after they already had a full career, to get a phd just because
13:03:03 <maerwald> you are too old to learn! err.. wait, what?
13:03:40 <geekosaur> I found I didn;'t have enough free time to take advantage of being staff at CMU, but no problem with taking courses with the undergrads
13:04:15 <blackandblue> I am so happy that university has released this haskell course online for free
13:04:38 <blackandblue> so people like me who cant afford to go to uni anymore ( due to age constraints and money) can still study
13:04:39 <hyperisco> anyone know of a data structure which supports efficient indexing (such as O(nlogn)) and efficient insertion (such as O(nlogn)) ?
13:05:09 <hyperisco> if you maintain a count of descendants on each node, this can be implemented with a balanced tree, but I figure someone has already done that and at least named it
13:05:09 <jle`> hyperisco: insertion at the ends, or in the middle?
13:05:18 <Welkin> hyperisco: Sequence?
13:05:28 <hyperisco> insertion between and two consecutive indices
13:05:36 <hyperisco> any* two
13:06:15 <jle`> Sequence (a finger tree) seems to be good for those cases
13:06:25 <glittershark> Is there any sort of justification for the classic "GHC ignores constraints when resolving instances" gotcha? I'm trying to explain this to a coworker and coming up short on *why*
13:06:28 <koala_man> hyperisco: that's not efficient. a linked list is better than that
13:06:44 <jle`> insertAt is O(log(min(i, n-i)))
13:06:53 <jle`> and so is index
13:06:56 <blackandblue> anyway thanks a lot Welkin maerwald geekosaur for motivation. back to learning <3
13:07:24 <jle`> linked list insertion is on the order of O(length of list) amortized
13:07:43 <hyperisco> koala_man, a linked list is linear in both operations, so you must have misunderstood me
13:08:00 <cocreature> hyperisco: you said O(nlogn) you probably mean O(log n)
13:08:25 <hyperisco> so I must have explained myself poorly
13:08:55 <[exa]> Hm, is there any parser for MIME e-mails, like, say, Parser Network.Mail.Mime.Mail ?
13:08:56 <jle`> http://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Sequence.html
13:09:07 <hyperisco> jle`, I heard you, thanks
13:09:31 <hyperisco> don't know much about finger trees but I am guessing they keep the size at each node
13:09:37 <[exa]> hyperisco: BB-alpha trees are nice for that
13:10:28 <Welkin> hyperisco: https://apfelmus.nfshost.com/articles/monoid-fingertree.html
13:10:59 <geekosaur> glittershark, separate compilation is one reason. you use that with a library that was compiled a year ago, there is no way it can know about constraints in the program you're linking it against.
13:11:01 <Welkin> and http://www.staff.city.ac.uk/~ross/papers/FingerTree.html
13:11:41 <hyperisco> awesome thanks, so I can just take Seq off the shelf here, exactly what I was hoping for
13:12:13 <hyperisco> fyi I was looking for an analog to the (possible) NodeList data structure, which has both indexing and insertion
13:12:47 <hyperisco> though, copying a linked list to an array for purposes of indexing is also possible… I am guessing browsers don't do that anymore
13:13:26 <hyperisco> it is funny because in my mind Seq was just about efficient cons on both ends, not efficient inserts into the middle
13:13:58 <geekosaur> glittershark, there's also questions of correctness, namely making sure everything is using the same rules; this is hard to guarantee if you allow constraints to affect instance selection, and (again) even more so with separate comoilation.
13:14:04 <jle`> hyperisco: i was on the same boat until i looked into the docs :)
13:14:19 <Welkin> Sequence remains the coolest data structure ever
13:14:39 <glittershark> geekosaur: separate compilation bites again...
13:14:39 <hyperisco> actually I didn't even know it had efficient indexing :P
13:14:46 <geekosaur> OO systems with virtual methods can do this, effectively by making every data value carry around its own stable of methods. at the cost of needing to always use them in the equivalent of this case
13:15:15 <geekosaur> becuase, for the same reason haskell ignores constraints here, an OO system can't optimize away the extra method indirections.
13:15:29 <glittershark> ahh, sure, because the typeclass dictionary gets inlined
13:16:17 <geekosaur> not quite. I mean you can;t treat a 3 as a 3, you have to use its .get and .set methods etc.
13:16:25 <glittershark> right
13:16:55 <glittershark> I'd love to see a concrete example of a backtracking search algorithm breaking coherence somewhere
13:17:14 <Zije> hey guys
13:17:18 <glittershark> this is definitely in the top 10 things I have to explain to my less-haskell-experienced coworkers
13:17:55 <geekosaur> I have seen them but don;t have examples on tap, and searching e.g. -cafe for them is kinda painful
13:18:00 <glittershark> heh
13:18:01 <glittershark> yeah
13:18:30 <glittershark> might actually send an email there asking for something, see if anyone has something lying around
13:18:38 <Zije> how can I become  an expert  IT guy?
13:18:52 <nshepperd_> Well, it breaks if there is an instance available in module A but not module B and you compile them separately
13:19:07 <nshepperd_> Since it'll choose a different instance
13:19:48 <glittershark> sure, I guess -fwarn-orphans is just a warning
13:26:58 <nshepperd_> Maybe you can cause some weirdness if you put (~) in the constraints as well
13:28:08 <nshepperd_> "cares about constraints" implies -XOverlappingInstances, doesn't it?
13:29:03 <nshepperd_> But whereas OverlappingInstances chooses always the most specific instance, in this case we hope that only one of the instances has satisfiable constraints?
13:31:13 <glittershark> yeah basically I'm thinking of not-haskell here
13:31:20 <[exa]> oh noes, there's really no haskell parser for rfc822/mime/rfc2045 mails?
13:31:33 <Welkin> [exa]: you could always write one
13:31:52 <glittershark> I'm wondering about what's wrong with a language like haskell with typeclasses that do a real, prolog-style backtracking search for instances
13:32:07 <glittershark> and I guess multi-module compilation is the answer
13:32:59 <Cale> glittershark: -XUndecidableInstances
13:33:00 * hackage push-notify-apn 0.1.0.8 - Send push notifications to mobile iOS devices  http://hackage.haskell.org/package/push-notify-apn-0.1.0.8 (hc)
13:33:05 <glittershark> heh Cale
13:33:11 <glittershark> no backtracking there though
13:33:31 <[exa]> Welkin: I was afraid of that, I don't have material to even test a reasonable subset of all MIME
13:33:38 <glittershark> ie if the instance heads match but only one of the constraint sets is satisfiable then overlapping instances will throw it out
13:36:02 <glittershark> [exa]: enron email database? lol
13:36:10 <nshepperd_> glittershark: what if you have two instances but both of them have satisfiable constraints?
13:36:26 <glittershark> nshepperd_: yep, that's what I'm realizing right now
13:36:39 <glittershark> that the underlying problem is that there's more than one way to satisfy a given constraint set
13:36:44 <glittershark> and that breaks coherence
13:37:27 <Cale> glittershark: Oh, I guess you also need OverlappingInstances
13:37:29 <glittershark> you could throw those out for overlap... but checking equality of constraint sets sounds undecidable-ish to me
13:37:56 <Cale> http://okmij.org/ftp/Haskell/poly2.hs
13:37:58 <glittershark> Cale: OverlappingInstances doesn't do backtracking either if I understand correctly, it only prioritizes some instances over others when doing initial lookup
13:38:25 <[exa]> glittershark: those are in fact quite old
13:38:47 <[exa]> nvm I'll start by just not being worse than PHP
13:39:04 <Cale> glittershark: It's possible to basically simulate it :)
13:39:37 <Cale> (of course, this should be obvious due to the fact that it's also possible to write a lambda calculus evaluator... :)
13:39:39 <geekosaur> if it would require backtracking, iirc the compiler considers it incoherent
13:39:59 <geekosaur> and then you enable IncoherentInstances and you get the luck of the draw, because just doing that doesn;t magically make it coherent
13:40:11 <geekosaur> it just tells the compiler to half-ass it and hope for the best
13:42:46 <Cale> http://okmij.org/ftp/Haskell/PeanoArithm.lhs haha
13:42:48 <glittershark> I'm personally a fan of the "extra parameter calculated by a closed type family" trick
13:43:03 <Cale> I'd somehow missed that one
13:43:12 <Cale> (this inverse arithmetic stuff)
13:49:00 * hackage sqlite-simple 0.4.16.0 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.16.0 (JanneHellsten)
13:51:00 <lukelau> Is there a good data strucutre for a two way map?
13:51:18 <lukelau> I.e. a Map a b where I can lookup via either a and b, both are guaranteed to be unique
13:51:47 <glittershark> lukelau: http://hackage.haskell.org/package/bimap-0.3.3/docs/Data-Bimap.html
13:52:56 <lukelau> glittershark: perfect, thank you!
13:53:07 <glittershark> the if you need a value too my work has a structure built on that internally that I just asked if we can open-source
13:53:23 <glittershark> ie (k -> v) and (k' -> v)
13:54:06 <lukelau> I don’t need a value with it but that sounds pretty useful
13:54:19 <glittershark> we're also maintaining a fork with some additions at https://github.com/urbint/bimap/commits/rm/export-constructors
13:54:32 <glittershark> yeah I might just open source it anyway :)
13:58:54 <glittershark> woo, got approval to open source it
13:59:00 <glittershark> should be up this week
14:07:53 <ZeuPiark> bye
14:08:49 <Profpatsch> Hm, I wonder which is faster: Text.any (== char) or Text.isInfixOf (Text.singleton char)
14:09:31 <Profpatsch> First should be linear over the Text and shortcuts because of ==
14:09:53 <glguy> Profpatsch: I think there's actually a rewrite rule in there for this
14:10:07 <Profpatsch> Ok, and isInfixOf is special-casing on isSingleton.
14:10:18 <Profpatsch> For the needle element
14:10:43 <Profpatsch> And you are right, there is a singleton rewrite rule for isInfixOf
14:11:28 <Profpatsch> None for any as far as I can see.
14:11:47 <Profpatsch> The isInfixOf one rewrites to Stream.elem.
14:12:14 <Profpatsch> Hm, more of a hypothetical question anyway, since my streams are rather short.
14:13:01 <orbisvicis> does anything provide an if-then-else function?
14:14:53 <hexagoxel> :t bool
14:14:54 <lambdabot> a -> a -> Bool -> a
14:15:39 <hexagoxel> else, then, cond
14:17:31 <Welkin> if...then...else is already an expression
14:19:48 <geekosaur> :t bool
14:19:49 <lambdabot> a -> a -> Bool -> a
14:19:53 <geekosaur> oh, already did that
14:19:54 <orbisvicis> hexagoxel: ty
14:20:00 <geekosaur> if/then/else is not first class
14:20:09 <orbisvicis> yeah, can't partially apply
14:20:12 <geekosaur> (and desugars to case with guards)
14:45:53 <dekem> Hey people!
14:47:14 <cjay-> yo
14:47:22 <Rembane> Geevening
14:48:56 <Nawab>  /join ##ChatterZ
14:58:47 --- mode: ChanServ set +o glguy
15:00:48 <zenspider> hi hi. I'm working on exercises in Hutton's book and I'm up to chapter 10 (interactive programming). I'm in emacs with what I think is a fairly normal setup and now that I'm starting to use IO monad + do, I'm getting indentation errors left and right. Is there advice or settings to deal with this?
15:01:16 <electrocat> zenspider: could you show an example?
15:01:59 <zenspider> I'm currently in 10.7, working on the game "nim", in the play function that has a nested do / if / do. It's insisting that the `else` must be at the same level of the first inner `do` instead of at the level of the `if`.
15:02:08 <zenspider> sure. lemme try to annotate this...
15:05:13 <geekosaur> zenspider, absent the NondecreasingIndentation language flag (nonstandard), then and else must be more indented than the corresponding if in anything using layout (including do)
15:05:20 <zenspider> https://gist.github.com/zenspider/d4d47d24281f6ece688234ec614af11e
15:05:41 <geekosaur> or DOAndIfThenElse
15:06:06 <geekosaur> Hutton is using standard Haskell, so you must indent
15:06:21 <glguy> The example in Hutton's book has the if and else at the same level
15:06:27 <glguy> which loads in GHC without an extension, at least currently
15:06:44 <geekosaur> hm, maybe that one hit H2010, then.
15:06:46 <glguy> but I think the question is actually about getting emacs to behave in particular
15:07:57 <Tuplanolla> This is the minimum, zenspider: https://lpaste.net/187772328048852992
15:08:05 <geekosaur> tab is probably obeying strict layout (i.e. without DoAndIfThenElse), onsidering it a continuation of an expression and therefore must be indented further than the start of the expression.
15:08:25 <dekem> exit
15:08:41 <jle`> kkkjkkkkkjjj
15:08:55 <jle`> ah, sorry :)
15:09:02 <Tuplanolla> Type  :quit<Enter>  to exit Vim
15:09:12 <glguy> :quit<Enter>
15:09:25 --- mode: glguy set -o glguy
15:09:47 <fishythefish> horrible api design imo, that should obviously be :quit<Exit>
15:11:21 <jle`> it means "quit entering"
15:11:38 <fishythefish> "stop opening nested vim sessions"
15:11:41 <jle`> "quit exit" would mean aborting your exit, keeping you locked in vim for all eternity :)
15:12:02 <geekosaur> anyway there's three different indent modes possible with haskell-mode, each of them has its own annoyances
15:13:58 <zenspider> glguy: yes. I'm trying to get emacs set up to infer indentation more correctly for here I am in this code. I would have thought that hitting return, typing "else" and then hitting tab would toggle back to the if level, then hitting return hitting tab would indent 1 deeper than the else
15:14:12 <zenspider> (still catching up)
15:14:59 <zenspider> Tuplanolla: I'm not sure what you're saying in that paste. I am not trying to reformat the code. I'm trying to type it and have emacs "Just Work"
15:15:37 <zenspider> geekosaur: what do you mean by DoAndIfThenElse ? Sounds like a haskell pragma?
15:15:50 <fishythefish> https://prime.haskell.org/wiki/DoAndIfThenElse
15:16:00 <geekosaur> it's a language extension, which can be expressed as a pragma or in other ways
15:16:17 <geekosaur> was an extension to haskell 98, may be in haskell 2010
15:16:18 <Tuplanolla> I see, zenspider. I'd just disable automatic indentation.
15:16:59 <geekosaur> which is part of the problem with having an editor do the right thing, it has no clue about indentation that can depend on the language level
15:17:14 <fishythefish> geekosaur: yeah, it's in H2010 and has full support without flags
15:17:34 <zenspider> I'm using plain vanilla ghc settings. I think the book expects that too. And the code in question is definitely lined up on if/else.
15:19:10 <glguy> zenspider: emacs is just out of date with Haskell. If you indent the else like we used to have to do it seems to work (for me) like I think you'd expected
15:19:47 <zenspider> Looking at haskell-indent customization... I've got all standard values including 0 on haskell-indent-thenelse
15:20:02 <zenspider> I do have these tho: (haskell-indentation-mode) (hindent-mode) -- maybe hindent-mode is messing stuff up?
15:20:14 <glguy> if_then_else_ is part of the syntax of expressions, not wasn't tied into do-notation
15:20:30 <glguy> and then in 2010 that was changed and do notation got some if_then_else_ awareness
15:20:40 <glguy> so if you want emacs to work nicely, do it the old way
15:26:36 <zenspider> seems like no matter how I format it, whether with hindent, whether do is hanging or not... emacs hates anything after else+do
15:27:04 <zenspider> (and at some point I need to ask why the inner `do`s are necessary, because I guess I don't get it yet.
15:27:06 <zenspider> )
15:27:32 <glguy> the outer do notation doesn't continue inside the then or else branches of an if expression
15:27:35 <geekosaur> because do is enabling that multiline stuff
15:27:45 <glguy> if_then_else_ is its own thing separate from do-notation
15:27:47 <geekosaur> it only applies at the level of top level expressions within it
15:28:07 <geekosaur> ionce you are inside if-then-else, you are not at the top level of the outer do, it is back in expression syntax, you need another do to switch to do syntax
15:28:39 <geekosaur> and when you compile haskell, one of the first things that happens is that "do" goes away, it's translated to the actual expressions
15:28:51 <geekosaur> @undo do x; y; z
15:28:51 <lambdabot> x >> y >> z
15:30:06 <pounce> How difficult is it to write super efficient haskell? like for project euler
15:30:41 <pounce> I sort of want to solve some problems with it, but I'm up to about lvl 54 and I don't want to do it to learn some Haskell if it's really hard
15:30:42 <glguy> The hard part of writing efficient project euler is coming up with the right algorithm. Project Euler doesn't generally stress one's Haskell skills directly
15:30:52 <zenspider> I might be getting ahead of myself... so do is more an expression than a keyword or mode... but if "it only applies at the level of top level expressions within it" how does return work nested inside of if/then/else ?
15:31:09 <geekosaur> return is not a keyword
15:31:15 <geekosaur> it's a badly named function
15:31:20 <glguy> pounce: If you're interested in programming exercises there are better sources of problems out there
15:31:21 <geekosaur> :t return
15:31:22 <lambdabot> Monad m => a -> m a
15:31:25 <zenspider> pounce: I've used euler to learn a number of languages. I think it's not a bad way to go.
15:31:32 <geekosaur> :t pure -- same with a more permissive constraint
15:31:33 <lambdabot> Applicative f => a -> f a
15:31:54 <zenspider> geekosaur: I (think I) get that part.
15:32:26 <zenspider> Yeah. I think I'm getting ahead of myself at this point. I'm gonna let that go instead of go down that rabbit hole.
15:32:39 <phadej> many euler problems are "bad" for learning haskell, as obvious solutions are very imperative in nature
15:32:40 <geekosaur> and as such it doesn't "do anything" when nested, because it just lifts a value into a monad, it doesn;t e.g. stop execution
15:32:40 <zenspider> Right now, emacs is driving me nuts. That seems more pressing.
15:32:54 <phadej> not the problems where haskell shines
15:33:10 <pounce> glguy: do you have any suggestions?
15:33:22 <zenspider> pounce: I just did problem #50 in a very functional way (using ruby). Try that one to see how it feels.
15:33:37 <zenspider> I was gonna redo it in haskell this evening...
15:34:27 <glguy> pounce: I liked the adventofcode.com problems (there are 3 years of them to do) and then there are the various online coding challenge sites that are more programming focused like hackerrank
15:35:01 <glguy> I'm not saying Project Euler isn't fun, I've done about 200 problems on it, it's just not that good as a source of Haskell exercises
15:35:07 <zenspider> (just 7 loc in ruby and only slightly optimized)
15:35:50 <zenspider> I should go back and do advent's 2016's CPU problems in haskell. Those were fun.
15:38:00 <glguy> pounce: A few of us have our adventofcode solutions available on github. If you're working through any of those problems you might enjoy seeing alternative approaches after you finish one
15:40:30 * hackage aig 0.2.6 - And-inverter graphs in Haskell.  http://hackage.haskell.org/package/aig-0.2.6 (AaronTomb)
15:46:24 <mojjo> good evening! I'm trying to grasp the concept of lenses following the Control-Lens-Tutorial. I'm a bit stuck at the point where they define a lense 'manually' without using the library. `point k atom = fmap (\newPoint -> atom { _point = newPoint }) (k (_point atom))` I understand this function and I was able to use it GHCI for updating a 'point' field in a record: `point (\x -> pure (x + 1))` So I can imagine how th
15:46:24 <mojjo> e `over` function is somehow build from this. However, I'm wondering how the `view` function from the lib could ever be generated just from this information. Does anyone have a hint for me?
15:48:27 <jle`> mojjo: the lens type signature is (a -> f b) -> (s -> f t)
15:49:06 <jle`> mojjo: and your 'view' is s -> a, right?
15:49:53 <zenspider> THIS! https://www.reddit.com/r/haskell/comments/52rkz1/the_state_of_indentation_support_in_emacs/ ALSO UGH
15:50:03 <mojjo> yes...
15:50:34 <jle`> mojjo: a (a -> f b) -> (s -> f t) can be thought to "lift" an (a -> f b) to an (s -> f t)
15:50:42 <geekosaur> as I said earlier, this is always going to be hard when the editor has to guess where you hid the knob saying which language level and accompanying indentation semantics it should use
15:50:57 <geekosaur> or you go full bore and assume it can read your mind
15:51:14 <jle`> mojjo: the general strategy is to "hitch a ride" on that lifting process
15:51:18 <pally> foldr (\x r -> x : r) ys lst
15:51:33 <pally> let's focus on the lambda abstraction part of the above
15:51:34 <jle`> mojjo: by picking a suitable 'f'
15:51:53 <pally> r is not bound is it?
15:51:58 <jle`> mojjo: if i picked an 'f' where `f t' is 'a', do you see how that can implement view?
15:52:17 <fishythefish> pally: yes, it's bound in the lambda head
15:52:18 <geekosaur> pally, both x and r are parameters
15:52:23 <geekosaur> \x r -> ...
15:52:29 <geekosaur> same as \x -> \r -> ...
15:52:31 <jle`> mojjo: because if 'f t' is 'a', then lifting your (a -> f b) would give you an (s -> a), essentially
15:52:41 <zenspider> geekosaur: "which language level"? I'm not writing anything that advanced. Emacs *should* be able to handle this. Parsing an `else` should be able to figure out the `if` that it corresponds to.
15:53:04 <geekosaur> zenspider, again. wha=ich indentation is correct depends on haskell98 vs. haskell2010
15:53:16 <geekosaur> and whether DoAndIfThenElse is enabled in H98 mode, or disabled in H2010
15:53:18 <mojjo> oh.. give me some time to digest those lines...
15:53:28 <geekosaur> it is not "this rule is always true"
15:53:47 <jle`> mojjo: so you just need to hand-make an 'f' so that 'f t' is 'a'.  then the "lifting" that the lens gives you will turn into (s -> a)
15:54:04 <jle`> this is usually done using a newtype wrapper, where 'f t' is a newtype that just contains an 'a'
15:54:07 <fishythefish> mojjo, jle`: fwiw, the tutorial at that point is still using the reduced definition `type Lens' a b = forall f . Functor f => (b -> f b) -> (a -> f a)`
15:54:09 <pally> ah... it's a shorthand for \x -> \r -> ...
15:54:20 <jle`> fishythefish: oh, thanks
15:54:28 <jle`> let me rephrase that then
15:54:33 <zenspider> I *think* I understand your last point. What's currently happening doesn't seem to fit EITHER of those two options. It's just broken after else/do
15:54:40 <jle`> a lens is (b -> f b) -> (a -> f a), so you want to make an "a -> b"
15:55:00 <jle`> so you just need to pick an "f" where "f a" is b :)  (usually you can make these yourself using newtype wrappers)
15:56:03 <jle`> how i do this myself is i make a newtype wrapper that gives me exactly what i want
15:56:13 <jle`> and then i look at the standard libs to see if one has already been made
15:58:17 <fishythefish> in this case, it's not hard to jump to `Const b`, though
15:58:39 <jle`> mojjo asked for a spoiler-free explanation :)
15:58:57 <jle`> but yeah once oyu write your own thing, the jump is clear
15:59:13 <fishythefish> oops ._.
15:59:24 <fishythefish> fwiw, http://hackage.haskell.org/package/lens-tutorial-1.0.3/docs/Control-Lens-Tutorial.html#g:6 also spoils it :P
16:11:00 <Tordek> hi; in an attempt to make a "real" haskell program I'm trying to build a chip-8 interpreter
16:12:42 <Tordek> so far, my memory is an UArray Word16 Word8; it works, but I'd assume that it being an immutable structure, it's not gonna be the fastest; what's the next best step? make my "State" happen in IO and use IOUArray?
16:15:10 <c_wraith> Tordek, that's an option. it's not your only option.
16:15:51 <c_wraith> if you do go that direction, check the vector library, you might prefer its api.
16:16:23 <jle`> you can also use ST instead of IO
16:16:26 <c_wraith> another reasonable option might include using Data.IntMap
16:18:15 <Tordek> what'd be another option?
16:18:53 <Tordek> jle`: I thought ST was for, like, contained computations that work well in a stateful way, but you escape them when you're done; the point of the interpreter is to be interactive
16:19:19 <c_wraith> abuse unordered-containers to remove the hashing part of the HAMT data structure it's built on!
16:19:37 <Tordek> ...what
16:21:22 <c_wraith> the array-mapped trie data structure is space efficient, cache-optimized, and supports fast updates as an immutable data structure.
16:21:29 <mojjo> thanks for the hints for the lense question.. My head is still spinning... It looks like the `Const` type is an important concept here..I defined it like `data Const a b = Const a deriving (Show)` ... I have problems with the funtor instance: `instance Functor (Const a) where fmap f (Const x) = Const (f x)` does not do..
16:21:40 <Neel> join ##ChatterZ
16:21:45 <Neel> guys!
16:21:45 <Cale> mojjo: To give another explanation, here's the general pattern: we want to break our data structure of type s into a piece of data (of type a) which is in a particular spot, and a function (b -> t) which would take any value of type b and give us back our original structure with the hole filled in (in general changing the type of the overall structure from s to t, given that we've replaced something of type a with something of type b)
16:21:45 <Cale> with that value plugged into the given spot. Rather than immediately applying that function to the value we popped out to get back our original data structure though, we take an arbitrary function (a -> f b)
16:21:57 --- mode: ChanServ set +o glguy
16:21:57 --- mode: glguy set +b *!*@117.194.195.189
16:22:10 <Cale> sorry, edit failure there :)
16:22:16 <c_wraith> but the only haskell implementation of one is inside unordered-containers, which combines it with hashing.
16:22:26 <Cale> The first line was good though :)
16:22:27 <jle`> mojjo: fmap f (Const x) = Const (f x) does not typecheck :)
16:22:30 * hackage yarn-lock 0.5.0 - Represent and parse yarn.lock files  http://hackage.haskell.org/package/yarn-lock-0.5.0 (Profpatsch)
16:22:33 <jle`> check the types of everything goin on
16:22:41 <jle`> but also in practice you can just derive the Functor instance automatically
16:22:42 <c_wraith> but you can always abuse your way around that with a custom Hashable implementation
16:23:35 <Cale> So, we split our data up into those two parts, and then we produce something which will apply an arbitrary function a -> f b to the data we popped out, before fmapping the function (b -> t) over the result of that
16:25:33 <Tordek> those are... words
16:25:44 <Cale> By picking f appropriately, that lets us do both view and set -- in particular, if we pick f = Identity, and use a suitable constant function, then this will basically give us set
16:25:53 <Tordek> thanks, c_wraith, lol, I just think it's a bit advenced for me at this point lol
16:26:22 <Cale> If we pick f = Const a, and use what is pretty much the identity function, it'll give us view
16:26:40 <pounce> advent of code #1 done \o/
16:27:23 <jle`> mojjo: following on what i mentioned earlier, you can use a lens to turn an (b -> f b) into an (a -> f a), and if you pick an 'f' where 'f a' is 'b', then you get a (a -> b) in the end
16:27:29 <jle`> pounce: congrats :D
16:27:29 <glguy> pounce: A bunch of people from #haskell have joined the private leaderboard 43100-84040706 if you're interested
16:27:35 <glguy> pounce: some of that links through to githubs
16:27:37 <c_wraith> Tordek, yeah, there are a lot of possible solutions that might be good under certain circumstances like that. but mutable arrays/vectors or some kind of tree (Like Data.IntMap) are your best first-pass options.
16:27:46 <jle`> so we can define a custom 'f' such that 'f a' is 'b':
16:28:02 <jle`> newtype Viewing b a = Viewing { getViewing :: b }
16:28:05 <Tordek> also, related; currently my `stepExecution` function is in IO because of one evil little `RND` function... any better ideas on how to handle it? put it into a randomstate monad?
16:28:38 <jle`> ^ in that data type, do you see how 'Viewing b a' is just 'b'?  we essentially defined an f (that is, Viewing b) that makes 'f a' the same thign as 'b'
16:29:09 <mojjo> right now I'm still wondering why my above fmap implementation does not do..
16:29:18 <jle`> so then view l = getViewing . l Viewing
16:29:25 <jle`> ^ just some manual newtype wrapping and unwrapping
16:29:30 <jle`> mojjo: ah, do you mean why it does not compile?
16:30:03 <mojjo> yes
16:30:08 <jle`> check the types :)
16:30:16 <jle`> what is the type of f, and the type of x?
16:31:19 <jle`> it might help to re-lable your type variables a bit to make it clearer, `data Const w a = Const { getConst :: w }`
16:31:23 <pounce> How would I read a line and turn it into a [Integer]?
16:31:25 <glguy> pounce: make sure you do both parts of day 1
16:32:14 <pounce> :O I didn't know there were two
16:32:35 <glguy> The second part is revealed when you successfully complete the first part. This is the case for all but the last day
16:34:21 <Nawab> join ##ChatterZ guys! lets chat and be friends!
16:34:42 --- mode: glguy set +b *!*@117.194.198.142
16:35:49 --- mode: glguy set +b *!*@117.194.192.0/20
16:36:51 <pounce> IS there I can turn a list into a list of (index,item)? (I know I can do this with scanl, but are there methods for it)
16:38:01 <Cale> pounce: zip [0..]
16:38:02 <geekosaur> zip it against [0..]\
16:38:36 <pounce> ty
16:58:00 * hackage pandoc-types 1.17.5.1 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.17.5.1 (JohnMacFarlane)
17:00:27 <pounce> How would I read a line and turn it into a [Integer]? (I'm back to number 2)
17:04:16 <glguy> getLine :: IO String    for getting the line
17:04:33 <glguy> in this case where you have a whitespace delimited list of numbers you can use
17:04:44 <glguy> > (map read . words) "1 2 3 4" :: [Int]
17:04:46 <lambdabot>  error:
17:04:46 <lambdabot>      Ambiguous occurrence ‘map’
17:04:46 <lambdabot>      It could refer to either ‘Data.List.map’,
17:05:07 <glguy> > (map read . words) "1 2 3 4" :: [Int]
17:05:09 <lambdabot>  [1,2,3,4]
17:05:36 <jle`> > words "1 2 3 4"
17:05:38 <lambdabot>  ["1","2","3","4"]
17:06:26 <glguy> Once you get yours working check out: https://github.com/glguy/advent2017/blob/master/execs/Day02.hs
17:06:30 * hackage butter 0.1.0.0 - Monad Transformer for Asyncronous Message Passing  http://hackage.haskell.org/package/butter-0.1.0.0 (mpahrens)
17:10:30 * hackage butter 0.1.0.1 - Monad Transformer for Asyncronous Message Passing  http://hackage.haskell.org/package/butter-0.1.0.1 (mpahrens)
17:16:43 <pally> > scanr (\x r -> x + r) 0 [1,2,3]
17:16:46 <lambdabot>  [6,5,3,0]
17:17:30 <pally> one thing I didn't expect from this experiment, how did I end up with a fourth item?
17:18:00 * hackage relational-query-HDBC 0.6.4.6 - HDBC instance of relational-query and typed query interface for HDBC  http://hackage.haskell.org/package/relational-query-HDBC-0.6.4.6 (KeiHibino)
17:18:19 <glguy> > scanr f a [b,c,d]
17:18:21 <lambdabot>  [f b (f c (f d a)),f c (f d a),f d a,a]
17:19:35 <pally> glguy, so the last item is always the second parameter (namely 'a')
17:19:36 <pally> ?
17:40:54 <pally> > scanl f a [b,c,d]
17:40:57 <lambdabot>  [a,f a b,f (f a b) c,f (f (f a b) c) d]
17:50:16 <dfeuer> pally: how did lambdabot do that?
17:53:33 <geekosaur> ...
17:53:42 <geekosaur> (that's the simple-reflect package)
17:54:51 <pally> In attempt to answer that question, I will turn to the type signature scanl :: (b -> a -> b) -> b -> [a] -> [b]
17:55:51 <pally> it ("the curried function) makes sense for all the items starting the 2nd
17:56:36 <pally> If we look at [a,f a b,f (f a b) c,f (f (f a b) c) d], the function f doesn't as though it applied to the first item, 'a'
17:56:52 <pally> doesn't seem
17:57:21 <jle`> yeah, the first item is the unmodified item
17:57:28 <jle`> it's meant to imitate 'iterate', i suppose
17:57:52 <pally> jle`, then it is consistent with the type signature.
17:58:47 <pally> Since I am at still in the learning phase, I try to trace it and see if things match/correspond.
18:00:56 <jle`> pally: one problem might be that you are mixing types and values
18:01:04 <jle`> > scanl f x [y,z]
18:01:06 <lambdabot>  [x,f x y,f (f x y) z]
18:01:14 <jle`> pally: it's a little confusing because the 'a' value you have has type 'b'
18:01:20 <jle`> pally: you might be thinking that 'a' has type 'a'
18:01:46 <jle`> in general it's helpful to not give your values the same name as your types, heh
18:01:57 <jle`> especially if you have a type variable 'b' and you call your value 'a' ;)
18:02:11 <jle`> that's why there's the x,y,z convention for values and a,b,c convention for types
18:06:12 <dfeuer> jle`: it's frustrating that you can't get nice total pattern matches with prisms. Has anyone come up with a solution to that? Dependent prisms or something?
18:06:55 <jle`> for the case of prisms on parameterized types, Tekmo has the total library
18:07:07 <jle`> @hackage total
18:07:07 <lambdabot> http://hackage.haskell.org/package/total
18:07:27 <jle`> it only works for types like `Either a b` where the fields in each constructor correspond to type variables though
18:07:49 <jcob> Hi I have a question that may be stupid. Monad is a higher kinded type right? Why does it have to be a higher order type?
18:08:02 <jcob> My intuition is because it is over containers... but I may be wrong
18:10:54 <geekosaur> "container" is not always correcy (IO doesn't "contain" anything, it is a recipe for something)
18:11:06 <dfeuer> jle`: sad, that. I wonder if something like that could be written for general Generic types....
18:11:21 <dfeuer> (as long as from and to are an isomorphism)
18:11:41 <dfeuer> Csongor would be the one to ask on that, probably.
18:11:54 <jcob> geekosaur: aghh IO doesn't contain anything? I thought it was like it was a burrito 😉
18:12:03 <Tordek> lol
18:14:38 <zenspider> I had to run to the dentist... are there IRC logs published somewhere? I see two possible log bots
18:15:07 <Tordek> topic, zenspider
18:15:16 <Tordek> Logs:
18:15:18 <Tordek>           http://tunes.org/~nef/logs/haskell/?C=M;O=D |
18:15:45 <jcob> geekosaur: what makes you say that IO isn't a container? and whyyyy is a monad a higher order type
18:16:15 <geekosaur> what makes you say it is?
18:16:18 <boj> jcob: i suppose if you consider Maybe a, it has the kind * -> *. this means you can stuff any other type inside it
18:16:22 <geekosaur> why is the only possibility a container?
18:16:46 <geekosaur> it's a program. we manipulate the program and then send it off to an impure runtime
18:17:02 <zenspider> tnx
18:17:10 <geekosaur> (or if you prefer, we add things to a recipe, then send it off to one of the kids at the culinary academy downtowm to be prepared)
18:17:55 <geekosaur> @quote /bin/ls
18:17:55 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
18:18:02 <jcob> Oh ok that makes sense. I guess since maybe is already of type * -> *, you have to have something with the sig (* -> *) -> * or something
18:18:14 <geekosaur> :k Monad
18:18:16 <lambdabot> (* -> *) -> Constraint
18:18:40 <geekosaur> you apply it to a type that itself requires another type
18:19:02 <jcob> Oh lord this is a real rabbit hole. It doesn't itself make a type when it is applied
18:19:02 <jcob>  
18:19:34 <geekosaur> instance Monad IO where ... -- but IO is not complete, it's IO Int or IO String or etc.
18:19:45 <geekosaur> instance Monad Maybe where ... -- same
18:20:52 <jcob> So is there like a lambda calculus of types where you can start playing around with them and reducing em and stuff
18:20:55 <Maxdamantus> It might be clearer to not think of `IO` as a type, but a function that takes a type (*) and returns a type (*)
18:21:11 <Maxdamantus> (hence why `IO`'s kind is `* -> *`)
18:21:18 <geekosaur> which giuarantees you do the same thing no matter what type IO or Maybe is applied to, because if you did then it would not follow the rules that make Monad useful
18:21:26 <Maxdamantus> > let a :: IO; a = a in a
18:21:29 <lambdabot>  error:
18:21:29 <lambdabot>      • Expecting one more argument to ‘IO’
18:21:29 <lambdabot>        Expected a type, but ‘IO’ has kind ‘* -> *’
18:21:55 <Tordek> jcob: category theory :)
18:22:41 <Maxdamantus> jcob: you can apply this stuff in the idris CLI, but it's a bit different to Haskell.
18:22:59 <Maxdamantus> eg, `Monad IO` is itself just a Type there.
18:23:18 <Maxdamantus> so Monad : (Type -> Type) -> Type
18:23:18 <geekosaur> (if it were "instance Monad (IO ...)" then you could have different instances for IO Int, IO String, ... --- and then an instance for (IO a) along with those would lead to other problems (can;t guarantee everything picks the same instance any more, and is disallowed for that reason)
18:23:30 * hackage sexp-grammar 2.0.1 - Invertible grammar combinators for S-expressions  http://hackage.haskell.org/package/sexp-grammar-2.0.1 (EugeneSmolanka)
18:28:07 <jcob> Maxdamantus: great I'm a huge fan of Idris
18:30:25 <infinisil> Idris \o/
18:32:39 <Maxdamantus> idris handles a lot of this stuff in a more theoretically concise way imo
18:33:46 <Maxdamantus> Since `Monad IO` is a type, its instance is an actual value that can be passed around: `the (Monad IO) %instance`
18:34:10 <infinisil> Yeah, which also allows for different implementations, they're just different values with the same type
18:34:35 <Maxdamantus> eg, `(>>=) @{the (Monad IO) %instance} (return 4) (\x => return (x + 5))`
18:35:06 <Maxdamantus> (the `@{..}` syntax is passing the usually-implicit class instance explicitly)
18:35:11 <Tordek> https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Unboxed.html how does one add custom syntax, like this is doing with <...,...,...>? (Or is it just for the examples?)
18:35:46 <Tordek> also, what's the {-# INLINE ... #-} thing?
18:40:48 <geekosaur> it's a pragma, sometimes just an optimization, sometimes may be needed for correctness (but not here that I can see, unless it's using unsafePerformIO under the hood)
18:41:28 <geekosaur> you don;t get to define your own syntax, aside from quasiquoters which aren't quite the same thing
18:41:55 <geekosaur> so I assume that's just for the example
18:46:15 <Tordek> geekosaur: alright, thanks!... what are quasiquotes, also?
18:47:34 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#template-haskell-quasi-quotation
18:47:46 <Tordek> thanks!
18:48:09 <geekosaur> gives you something like [vec| ... |] and at compile time it will look for a function "vec" in scope to parse what's inside it1
18:48:27 <geekosaur> which is painful in a number of ways, but the best you can do for new syntax
18:49:26 <infinisil> Not just new syntax, embed other languages in it!
18:50:04 <jcob> Just like lisp macros! how cool
18:51:51 <geekosaur> well, aside friom lisp macros give you lisp. ghc's internal AST is … less friendly
18:54:13 <infinisil> What I find really cool is how johnw_ used QuasiQuotes to have inline Nix evaluation: https://github.com/haskell-nix/hnix/blob/master/tests/EvalTests.hs#L136-L143
18:58:27 <aarvar> is this a thing? type InvSetter s t a b = Iso a b -> s -> t
19:20:51 <jle`> jcob: a monad is not a higher-kinded type
19:21:03 <jle`> monads cannot be higher-kinded types by definition
19:21:16 <jle`> at least, not Monads
19:22:01 <jle`> jcob: you might be thinking of the Monad typeclass, which is a "higher-kinded typeclass"
19:22:15 <jle`> jcob: but its instances, like IO, list, Maybe, Either e, etc., are not higher-kinded
19:22:59 <jle`> IO, list, Maybe, Either e, etc., are all "first-order" types
19:23:47 <jle`> but being able to talk about all monads under a uniform framework requires a higher-order abstraction
19:39:31 <pounce> Why does `main` have the IO () type?
19:39:37 <pally> How do I get ghci to perform the trace like lambda does?
19:39:40 <pally> e.g.
19:39:50 <pounce> I mean, what's wrong with main doing some computation and exiting?
19:39:50 <pally> lambdabot*
19:40:13 <pally> >foldr (-) z [b,c]
19:40:23 <pally> > foldr (-) z [b,c]
19:40:25 <lambdabot>  b - (c - z)
19:46:20 <geekosaur> pounce, it actually has type IO a, but what is supposed to do what with the a?
19:46:55 <pounce> huh, didn't know that
19:46:59 <geekosaur> you are building up a program in the form of an IO action, and handing that back to the runtime to be (impurely) run. the result of the thing generating the IO action isn't useful
19:49:37 <geekosaur> (conceptually at least. ghc actually does something else. but haskell, and in particular IO actions, will make a lot more sense if you think of it this way)
19:50:18 <geekosaur> and you can think of (>>) and (>>=) as attaching callbacks to the end of an IO action. the former fires on completion of the action on the left, the latter also receives its result.
19:50:49 <geekosaur> so you are purely manipulating a program to be handed off to an impure evaluator
19:50:58 <geekosaur> which is now we get away with IO in an ure language
19:51:02 <geekosaur> * a pure
19:51:47 <geekosaur> *how
19:53:57 <geekosaur> ghc actually does something a bit more optimal, but if you don;t understand what it's actually doing and how to manipulate it safely, you get https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L566
19:56:09 <pounce> Right now I'm getting an error "Couldn't match type ‘IO String’ with ‘[Char]’" when trying to call `words getLine`. I want this to have the type IO [String], but I'm not sure how to propogate the IO
19:57:07 <geekosaur> fmap words getLine
19:57:29 <geekosaur> you can't manipulate an IO String directly. it's not a String wrapped in IO, it's a program that can generate a String
19:57:44 <geekosaur> you have to attach a callback to it, via fmap or via (>>=)
19:59:17 <pdxleif> On this page, is the part about "if !impl(ghc >= 8.0) build-depends: semigroups == 0.18.*" supposed to say "if less than 8.0"? https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid#Writingcompatiblecode
19:59:35 <pdxleif> Data.Semigroup is already in > 8.0, so why would you need to add the lib in that case?
19:59:36 <pounce> how would I use >>= in this context?
19:59:53 <geekosaur> getLine >>= return . words
20:00:09 <geekosaur> but this is a bit of a code smell, since it's just a wordy version of `fmap words getLine`
20:00:11 <pdxleif> pounce: fmap words getLine or "words <$> getLine"
20:00:49 <pdxleif> by the monad laws >>= return is the same as fmap, so either one I guess
20:01:11 <pdxleif> or even do input <- getLine; return (words input)
20:01:49 <pdxleif> The error message was just saying you had an IO String instead of a String - "words" wants a String.
20:02:16 <pdxleif> Like if, you had a [String] or a Maybe String instead of String.
20:02:30 * hackage typenums 0.1.0.0 - Type level numbers using existing Nat functionality  http://hackage.haskell.org/package/typenums-0.1.0.0 (AdituV)
20:02:45 <geekosaur> you can also use `pure` instead of `return` in any of those, which is preferred these days provided you can be certain you won;t be forced to use a version of ghc which doesn't have `pure` yet (< 7.10 iirc)
20:02:53 <geekosaur> which is sometimes a problem on e.g. debian
20:03:01 <pounce> what's the differenece?
20:03:24 <pounce> <$> works pretty well for me, but I haven't a clue what it does
20:03:52 <petercommand> :t (<$>)
20:03:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:03:58 <geekosaur> <$> and fmap are the same thing, but <$> is an infix operator instead of a prefix function
20:04:00 <petercommand> <$> is fmap
20:04:07 <pounce> what is fmap?
20:04:21 <petercommand> a generalized map
20:04:28 <geekosaur> the fundamental operation of a Functor
20:05:33 <petercommand> > fmap (+1) [1,2]
20:05:36 <lambdabot>  [2,3]
20:05:44 <petercommand> > fmap (+1) (Just 10)
20:05:46 <lambdabot>  Just 11
20:05:57 <petercommand> > fmap (+1) Nothing
20:06:00 <pounce> ah, was just about to ask about Maybe :3
20:06:00 <lambdabot>  Nothing
20:06:08 <petercommand> :3
20:06:37 <pdxleif> > map (+1) [1,2]
20:06:39 <lambdabot>  [2,3]
20:07:28 <pdxleif> fmap and <$> are just aliases of each other. I like using <$> as an infix operator - sometimes saves me from having to write parens around its arguments.
20:08:14 <arahael> Can I format number-literals with a thousands separator of some sort?
20:10:15 <pdxleif> arahael: Like this? https://github.com/chrisdone/formatting/blob/master/src/Formatting/Examples.hs#L40
20:10:43 <pdxleif> Oh sorry, I misunderstood - you meant putting e.g. a comma every three digits?
20:10:49 <petercommand> > let f n = if n < 1000 then n else f (n `quot` 1000) :: [n `rem` 1000] in f 11234678
20:10:51 <lambdabot>  error:
20:10:51 <lambdabot>      • Couldn't match type ‘n1’ with ‘n2’
20:10:51 <lambdabot>          because type variables ‘k2’, ‘n2’ would escape their scope
20:10:59 <arahael> No, not as a string.  As a *literal*.
20:11:11 <petercommand> > let f n = if n < 1000 then n else f (n `quot` 1000) : [n `rem` 1000] in f 11234678
20:11:13 <lambdabot>  error:
20:11:14 <lambdabot>      • Occurs check: cannot construct the infinite type: a1 ~ [a1]
20:11:14 <lambdabot>      • In the expression: f (n `quot` 1000) : [n `rem` 1000]
20:11:15 <pdxleif> With a quasiquoter, I'd guess.
20:11:27 <arahael> ie, `1,200 :: Integer`
20:12:26 <pdxleif> With a quasiquoter you could have e.g. `[int|1,200]`
20:13:28 <pdxleif> With the qq-literals lib you just need to write a `String -> Either String Integer` function for that to work.
20:13:28 <arahael> Hmm, so only with a quasiquoter?
20:14:07 <pounce> How would I read all the lines from stdin instead of just one?
20:14:09 <arahael> One advantage for C++ and C#, I guess. :(
20:14:50 <pdxleif> You can write comma-delimited numbers in C?
20:15:21 <arahael> pdxleif: No, and I don't neccessarily need comma-delimited. I just want separators.
20:15:54 <arahael> Eg, in C++, you can do: int x = 1'200;  And in C#, you can do: int x = 1_200;
20:17:05 <arahael> C has no such support, though.
20:19:40 <glguy> GHC's getting _ separators for number literals soon
20:19:48 <arahael> Oh, nice.
20:19:50 <pdxleif> arahael: I'd be interested in something like that myself. If it doesn't have to be a comma, seems you might define some function to do that. But a literal 000 would still be just 0. I'm thinking something like a quasiquoter would be best for that. Maybe propose it as a language syntax extension if it catches on?
20:20:05 <glguy> https://ghc.haskell.org/trac/ghc/ticket/14473
20:20:07 <arahael> pdxleif: glguy has the answer I was after.
20:23:57 <pounce> How would I read all the lines from stdin instead of just one? (sorry to repeat, there was another conversation happening so idk if people saw)
20:24:13 <glguy> getContents does that
20:28:01 <krone_> p
20:30:33 <Axman6> arahael: I think GHC 8.4 added underscores in numbers a la Ada, 1_000_000, with an excvtension
20:31:20 <arahael> Very nice.  I think that's the same extension glguy referred to. :)
20:31:24 <pounce> so is `a . map b` equivilant `a <$> b` ?
20:31:27 <Axman6> -XNumericUnderscores https://ghc.haskell.org/trac/ghc/ticket/14473
20:31:41 <arahael> Yep, that's the same one.
20:31:45 <Axman6> oh, missed that. glguy always beats me
20:31:55 * Axman6 cowers in fear of another beating
20:31:59 <arahael> Haha. :)
20:32:32 <Axman6> hmm, 8.6 :(
20:34:06 <geekosaur> pounce, map is specific to lists. fmap works on any Functor
20:34:55 <pounce> err, `a . fmap b`
20:36:12 <pounce> third gold star achieved \o/
20:36:49 <pdxleif> That -XNumericUnderscores isn't in GHC 8.4.3.
20:36:55 <pavolzetor> hello, why does this not print the map? fmap (putStrLn . show) . eval $ res
20:37:05 <pavolzetor> but
20:37:13 <pavolzetor>  m <- eval res; putStrLn . show $ m
20:37:16 <pavolzetor> does print it
20:37:29 <pavolzetor> I am confused why the output is different
20:37:43 <glguy> pavolzetor: Compare the types of the two things
20:38:02 <pdxleif> pounce: What does `a . map b` mean?
20:38:30 <glguy> pavolzetor: One is going to be something like:   IO () and the other   IO (IO ())
20:38:37 <pdxleif> I know `f <$> b` is equivalent to `fmap f b`
20:39:06 <glguy> pounce: No,  `a . map b` isn't the same as `a <$> b`
20:39:20 <glguy> nor the same as `a . fmap b`
20:40:03 <glguy> pavolzetor: The one that works, using =<< is a single IO action that both evaluates and prints
20:40:21 <glguy> while the second is an action that evaluates and returns an action that would print the result of evaluation, if you ran it
20:40:30 <pavolzetor> I see, thanks that was helpful; I would need join
20:40:38 <glguy> correct
20:44:00 * hackage speechmatics 0.7.0.0 - Speechmatics api client  http://hackage.haskell.org/package/speechmatics-0.7.0.0 (Jappie)
20:59:32 <pounce> glguy: what does surrounding `x `divMod` y` with brackets do here? https://github.com/glguy/advent2017/blob/master/execs/Day02.hs#L48
20:59:49 <glguy> pounce: It makes a singleton list
20:59:50 <pounce> it doesn't seem like it builds a list
20:59:56 <pounce> oh, what for?
21:00:11 <glguy> so that it can pattern match against the pattern on the left side of the arrow
21:00:40 <pounce> the pattern on the left looks just like a tuple though, how is it a list?
21:00:45 <glguy> > [x | (x,True) <- [(1,True), (2,False), (3,True)] ]
21:00:47 <lambdabot>  [1,3]
21:01:02 <glguy> The way list comprehensions work is that each element of the list on the right side is matched against the pattern on the left
21:01:22 <glguy> > [ (x,y) | x <- [1,2], y <- [3,4] ]
21:01:24 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
21:02:00 <pounce> hmm
21:02:35 <glguy> If the pattern doesn't match, that element is skipped over
21:02:53 <glguy> > [ x | Just x <- [ Just 1, Nothing, Just 3 ] ]
21:02:55 <lambdabot>  [1,3]
21:03:45 <pureNonsense> hi, does anyone know how the vscode HIE plugin calls Brittany for formatting or is that done through HIE itself?
21:05:13 <pounce> what about the list comprehentions with booleans? like I was doing [x | x <- xs, any (\a -> a `mod` x == 0) (delete x xs)] because I thought they had to bee bools originally
21:05:59 <glguy> There are two things that can go on the right side of the | in a list comprehension, either _ <- _, or a boolean expression
21:06:59 <pounce> ah ok
21:06:59 <glguy> In the case of a boolean expression, the expression is evaluated and if it is True it succeeds and the current elements are kept and if it is False then the current element is skipped over
21:07:17 <glguy> > [ x | Just x <- [ Just 1, Nothing, Just 2 ], even x ]
21:07:20 <lambdabot>  [2]
21:07:48 <pounce> so you can chain them together with commas?
21:08:19 <glguy> > [ x | Just x <- [ Just 1, Nothing, Just 2 ], even x, 2 == x, True ]
21:08:21 <lambdabot>  [2]
21:08:30 <glguy> Yeah, you can keep going
21:09:05 <glguy> > [ 'a' | even 2 ] -- You don't even need any <- components in a list comprehension, you can just have boolean guards
21:09:07 <lambdabot>  "a"
21:09:20 <glguy> > [ 'a' | odd 2 ]
21:09:22 <lambdabot>  ""
21:09:38 <pounce> > [ x | Just x <- [ Just 1, Nothing, Just 2, Just 4], even x, 4 <- x ]
21:09:41 <lambdabot>  error:
21:09:41 <lambdabot>      • No instance for (Integral [Integer])
21:09:41 <lambdabot>          arising from a use of ‘e_11244’
21:09:46 <pounce> >…<
21:09:53 <glguy> x isn't a list in that example
21:10:00 <glguy> so it doesn't make sense to put it on the right side of <-
21:10:19 <mniip> > [() | 4 <- [2, 3, 4, 6, 3, 4]]
21:10:19 <pounce> ooh I think I'm getting it now, ty
21:10:21 <lambdabot>  [(),()]
21:10:28 <mniip> fun
21:11:03 <mniip> (an integer literal is a pattern after all)
21:11:45 <glguy> Yup, and the original impetus for the question was a 0 pattern
21:14:56 <glguy> % [ x | x+1 <- [0,10] ]
21:14:56 <yahb> glguy: [9]
21:20:29 <pounce> oh wow, that's a nice pattern. Is 0 not the successor of -1?
21:21:00 <glguy> That's a relic from the old times of Haskell98, an "n plus k pattern"
21:21:34 <pounce> reminds me of number theory
21:21:37 <glguy> the x+k patterns only matched such that x would be non-negative
21:21:51 <glguy> so you'd write: f 0 = this; f (x+1) = that
21:22:01 <glguy> or f 0 = this; f 1 = that; f (x+2) = theother
21:22:13 <pounce> yep, reminds me a lot of number theory xD
21:28:33 <pally> Is there a cool oneliner to do the following:
21:29:02 <pally> somefunc :: <type signature>
21:29:12 <pally> somefunc xs [] = []
21:29:20 <pally> somefunc [] xs = []
21:29:21 <pally> ...
21:29:27 <geekosaur> semicolons in place of newlines. otherwise, no
21:29:42 <pally> basically return the empty list if either lists is empty
21:30:59 <pally> the second pattern should be `[] ys`
21:31:15 <pally> but you are quick witted, so you knew what I was tryna get at.
21:34:07 <geekosaur> the names don't really matter
21:34:16 <geekosaur> we'd usually write _ instead of a name since it's not being used
21:36:23 <jle`> pally: what should it return if the lists are not empty?
21:36:32 <pounce> > somefunc xs ys = if xs == [] || ys == [] then [] else []
21:36:34 <lambdabot>  <hint>:1:16: error:
21:36:35 <lambdabot>      parse error on input ‘=’
21:36:35 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
21:36:50 <jle`> if you don't care, you can use (*>) or (<*)
21:37:22 <jle`> pounce: if neither are empty, then you also return []?
21:37:29 <jle`> pounce: sounds just like someFunc _ _ = []
21:37:40 <pounce> (just trying out pally's question)
21:37:52 <jle`> oh ah misread the username
21:38:41 <jle`> > [1,2,3] *> []
21:38:44 <lambdabot>  []
21:38:48 <jle`> > [] <* [1,2,3]
21:38:51 <lambdabot>  []
21:38:57 <geekosaur> pounce, lambdabot doesn't take definitions (at least not that way). you can use let-in, but not bare let (as in ghci or do blocks) or top level definitions
21:38:58 <pally> jle` the function will apply some user specified f on the cartesian product of two lists, which I will list comprehension to accomplish.  List comprehension is so far my favourite feature.
21:39:18 <jle`> pally: that sounds like liftA2 then?
21:39:25 <geekosaur> there is @let, but that will add to a shared context so you should consider your names carefully
21:39:26 <jle`> > liftA2 (,) [1,2,3] []
21:39:28 <lambdabot>  []
21:39:37 <jle`> > liftA2 (,) [] ['a','b','c']
21:39:39 <geekosaur> or someone will @undefine when they hit a collision and it'll go away
21:39:39 <lambdabot>  []
21:39:45 <jle`> > liftA2 (,) [1,2,3] ['a','b','c']
21:39:47 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
21:40:06 <jle`> but tbh the "return an empty list" part is the least interesting part ;)
21:40:44 <pally> while I still  haven't referred to the doc, but liftA2 is pretty gangsta
21:40:52 <pally> or so it seems.
21:41:12 <jle`> yeah, it was one of the biggest advancements to come out of haskell in the past decade
21:41:15 <pounce> > \xs ys = if xs == [] || ys == [] then [] else []
21:41:17 <lambdabot>  <hint>:1:8: error:
21:41:17 <lambdabot>      parse error on input ‘=’
21:41:18 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
21:41:24 <jle`> liftA2 changed the game when it was invented
21:41:32 <pounce> how do I try a function then?
21:42:00 <jle`> you can name them
21:42:01 <pally> list comprehension behave my instant favourite when I learned about it in The Gentle Intro
21:42:12 <geekosaur> like I said, @let --- but be careful what name you choose, some names are in use and some are just asking for others to run into it, become grumpy, and wipe the @let storage
21:42:44 <geekosaur> @let fuddle xs ys = if xs == [] || ys == [] then [] else []
21:42:45 <lambdabot>  Defined.
21:42:49 <geekosaur> :t fuddle
21:42:51 <lambdabot> (Eq a1, Eq a2) => [a1] -> [a2] -> [a3]
21:43:21 <geekosaur> note that we don;t use == to determineif a list is empty normally, because why would you care if the list's items can be ==d? use null instead
21:43:23 <geekosaur> :t null
21:43:24 <lambdabot> Foldable t => t a -> Bool
21:43:25 <pounce> well there's your (notso) clever oneliner pally <.<
21:43:45 <pounce> geekosaur: fair
21:47:40 <geekosaur> % :t null @[]
21:47:41 <yahb> geekosaur: [a] -> Bool
21:51:57 <pally> jle` originally I was going to use list comprehension but if I were to use liftA2 is there a way for me  apply a function on the components of each pair (not on the pair itself), sorta like Racket's 'apply' function.
21:52:14 <jle`> can you give an example of what you mean
21:52:18 <glguy> :t uncurry
21:52:19 <jle`> what is the list comprehension equivalent?
21:52:19 <lambdabot> (a -> b -> c) -> (a, b) -> c
21:52:23 <pally> your example is best
21:52:45 <pally> > liftA2 (,) [1,2,3] [4,5]
21:52:47 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
21:52:51 <jle`> there you go :)
21:52:57 <jle`> does that not do what you want?
21:53:20 <pally> now apply some function f on  the components of each pair
21:53:40 <jle`> what do you mean exactly?
21:53:44 <pally> like : [ f 1 4 , f 1 5, f 2 4,, ...]
21:53:46 <glguy> map (uncurry f)
21:54:07 <jle`> pally: i mean you could, but why would you want to do that, heh
21:54:11 <jle`> you could just liftA2 f
21:54:11 <glguy> or in this case:  liftA2 f
21:54:17 <jle`> > liftA2 (+) [1,2,3] [100,200,300]
21:54:20 <lambdabot>  [101,201,301,102,202,302,103,203,303]
21:54:29 <pally> if it is difficult, then I stick to list comprehension :-)
21:54:45 <jle`> i mean, why would you use (,) at all, if you were going to just apply a function? :)
21:54:58 <jle`> > liftA2 f [1,2,3] [4,5,6]
21:54:59 <pally> jle`, b/c that's what you had in your example.
21:55:01 <lambdabot>  error:
21:55:01 <lambdabot>      • Ambiguous type variable ‘c0’ arising from a use of ‘show_M251925508488...
21:55:01 <lambdabot>        prevents the constraint ‘(Show c0)’ from being solved.
21:55:02 <pally> heh
21:55:11 <jle`> pally: oh yeah, (,) was just ane xample of a function
21:55:17 <jle`> you can put any function there, heh
21:55:35 <jle`> (,) was just a generic function, but you can use any function you want
21:56:07 <jle`> i was trying to show you what `liftA2` did, not what `liftA2 (,)` did :)
21:56:15 <jle`> do you see what happened with liftA2 (+) up there?
21:56:41 <jle`> > liftA2 f [1,2,3] [4,5,6] :: [Expr]
21:56:44 <lambdabot>  [f 1 4,f 1 5,f 1 6,f 2 4,f 2 5,f 2 6,f 3 4,f 3 5,f 3 6]
21:56:54 <jle`> f is the 'user-supplied function' you were talking about
21:57:01 <pally> yes sir
21:57:03 <jle`> it doesn't have to be (,)
21:57:30 <jle`> > liftA2 f [x,y,z] [a,b,c] :: [Expr]
21:57:33 <lambdabot>  [f x a,f x b,f x c,f y a,f y b,f y c,f z a,f z b,f z c]
22:01:29 <pally> these features are really chill, compared to recursive ish I was reading (course notes) earlier.  I share with you 'myscanr' https://lpaste.net/6065036963516252160
22:01:30 <pally> heh
22:01:53 <guessWHo> is this return type fine Either Bool IO()
22:02:05 <jle`> guessWHo: that's not quite a real type no
22:02:09 <jle`> but Either Bool (IO ()) is
22:02:40 <jle`> pally: note that liftA2 for lists is implemented, under the hood, with recursion
22:02:56 <jle`> it's just a higher order function like map, foldr that abstracts over a common usage of lists
22:03:01 <pally> jle` I know I know.
22:03:01 <guessWHo> jle` : is it fine to have such return types i mean is this the "haskellish" way of doing things ?
22:03:24 <glguy> guessWHo: your type didn't kind check, remember that it parses like this: ((Either Bool) IO) ()
22:03:29 <jle`> guessWHo: i don't think there's anything particularly bad about it
22:04:02 <cocreature> it is somewhat uncommon. you see things like IO (Either Bool ()) a lot more often
22:04:17 <jle`> IO (Either Bool ()) is a completely different thing, though
22:04:41 <jle`> Either Bool (IO ()) is probably an ok way to represent the possiblity of either a Bool or an IO computation
22:04:48 <cocreature> sure, my point is that it’s useful way more often than Either Bool (IO ())
22:05:06 <cocreature> to the point that I wonder if the Either Bool (IO ()) isn’t a typo and it’s actually IO (Either Bool ())
22:05:26 <jle`> Either Bool (IO ()) often is an intermediate type that's awaiting a 'sequence'
22:05:38 <jle`> sequence :: Either Bool (IO ()) -> IO (Either Bool ())
22:05:46 <jle`> but usually people just use 'traverse' if possible
22:09:47 <jle`> :t print <$> Left True
22:09:48 <lambdabot> Either Bool (IO ())
22:09:55 <jle`> :t traverse print (Left True)
22:09:56 <lambdabot> IO (Either Bool ())
22:10:14 <jle`> i guess it really just depends on what you are going to be doing with that Either
22:11:54 <cocreature> huh I managed to get ghci to not have (-) in scope and I have no idea how I got to this point
22:12:54 <guessWHo> jle` : can we do this Right x -> Right $ do .. when my return type is Either Bool (Int()) ? i mean i tried and it throws errors
22:13:08 <jle`> ghci -XNoImplicitPrelude gets it for me, but i don't know how to get it out of scope once it's already in
22:13:18 <jle`> guessWHo: what is the error?
22:13:33 <jle`> guessWHo: and no, you can't have Either Bool (Int ())
22:13:36 <jle`> that's definitely not a thing
22:13:55 <jle`> unless you're using an `Int` that is user-defined and not the one included with ghc
22:14:11 <guessWHo> jle` : sorry i mean Either Bool (IO())
22:14:19 <jle`> ah, ok
22:14:33 <jle`> yeah, we can't really say anything without an error or the code that caused it
22:14:40 <jle`> having both would be best :)
22:18:05 <guessWHo> jle` : https://lpaste.net/4529369675959631872 this is a version of it
22:19:49 <cocreature> guessWHo: the problem is that foo 10 has type IO (Either x y).
22:20:04 <cocreature> so to decide whether bar returns Left or Right you need to execute IO
22:20:27 <cocreature> but Either CustomException (IO ()) would allow you to inspect whether the value is left of right without executing IO
22:20:54 <cocreature> you need something like "IO (Either CustomException (IO ())"
22:21:27 <guessWHo> cocreature : yeah i was thinking that but i was told it's not a very good idea ? is it not ?
22:21:58 <cocreature> I don’t think there is something inherently wrong with it, it depends on your usecase
22:22:26 <cocreature> IO (Either CustomException ()) might be more appropriate but that won’t allow you to delay the execution of the IO that you’re currently storing in the Right case
22:22:37 <cocreature> whether that matters depends on your application
22:23:29 <guessWHo> cocreature : naturally if i see too many functions returning IO , or working with IO , i feel something is wrong or i'm not  doing it in proper way
22:23:33 <jle`> guessWHo: remember that each line in an IO do block has to be IO something
22:23:48 <jle`> that's why 'case y of Right m -> Right ...' can't work
22:23:53 <cocreature> guessWHo: well if you want to execute IO, you have to work in IO
22:23:54 <jle`> the result has to be IO, since you're in an IO do block
22:24:11 <cocreature> so since foo executes IO you don’t have a choice here
22:24:18 <jbayardo> guessWHo: how about EitherT? https://hackage.haskell.org/package/either-4.4.1/docs/Control-Monad-Trans-Either.html
22:24:40 <jle`> that doesn't really do anything here
22:25:11 <cocreature> you could separate "bar" into two parts. a non-IO function that processes the result of executing foo and the plumbing that executes foo and passes the result to the pure function
22:25:19 <jle`> guessWHo: remember the difference between wiath Either Bool (IO ()) and IO (Either Bool ()) are
22:25:23 <jbayardo> foo :: Int -> EitherT CustomException IO Bool, and then bar :: Int -> EitherT CustomException IO ()
22:25:25 <jle`> they are completely different types
22:25:32 <cocreature> jle`: fwiw, you usually want to use ExceptT instead of EitherT
22:25:51 <jle`> in any case all ExceptT would do here is add a useless newtype wrapper around everything, heh
22:26:07 <jle`> it would serve no purpose, it'd be like using Sum Bool instead of Bool
22:26:23 <guessWHo> how can those be helpful here, still haven't read a lot on monad transformers , do point to any resource for me to get started with transformers
22:26:39 <cocreature> they aren’t helpful here as jle` mentioned :)
22:26:48 <jle`> like i said, there is nothing at all that ExceptT or EitherT could help here with, heh
22:27:04 <jle`> guessWHo: Either Bool (IO ()) is either a Bool or an IO action
22:27:15 <jle`> guessWHo: IO (Either Bool ()) is an IO action that returns either a Bool or ()
22:27:19 <jle`> what you have here is an IO action
22:27:44 <jle`> bar is itself an IO action
22:27:54 <guessWHo> cocreature, jle` : they might not be useful here but i have been meaning to learn monad transformers  specifically readerT and stateT and the whole readerT pattern
22:39:04 <guessWHo> jle` : so IO (Either Bool () and IO Either Bool (IO()) same
22:41:23 <cocreature> guessWHo: no, the latter one allows you to delay the execution of the IO part in the Right case
22:41:36 <cocreature> or not execute it at all
22:44:17 <guessWHo> cocreature : and what about the first one ?
22:45:11 <cocreature> the first one gives you an IO action that produces an "Either Bool ()". but the Right case just contains () in this case, there is nothing to execute there
22:45:34 <guessWHo> cocreature : by delay you mean when i do m <- bar 10 at this point either the IO action will be performed or not right ?
22:46:35 <cocreature> by delay I mean that if you have "x :: IO (Either Bool (IO ())" and you use something like "do x' <- x; case x of Left _ -> pure (); Right ioAction -> _" you can choose what you want to do with ioAction
22:46:44 <cocreature> you can execute it at some later point, not execute it at all, …
22:48:49 <guessWHo> cocreature : ah ohk i got it , also some beginner friendly resources on readerT pattern and monad transformer in general >?
22:52:10 <cocreature> don’t have a link handy, sry
22:53:24 <guessWHo> cocreature : it's okay , thanks for the help so far :) , can you describe in brief about the readerT pattern and when it should be used ?
22:55:27 <cocreature> all ReaderT does is to hide the plumbing of having to manually pass around an argument
22:58:33 <jle`> guessWHo: IO Either Bool (IO ()) is not a thing
22:58:47 <jle`> do you mean IO (Either Bool (IO ())) ?
23:00:56 <guessWHo> jle` : yeah i meant that and cocreature explained the difference while you were gone , thanks for the help so far :)
23:01:08 <guessWHo> jle` : can we move now to readerT :P
23:01:10 <jle`> no problem :)
23:11:26 <pdxleif> Can someone explain the reason for the "import Data.Semigroup as Sem" (instead of just "import Data.Semigroup") on https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid#Writingcompatiblecode ?
23:12:30 <jle`> pdxleif: back in the old days, Data.Semigroup exported a different (<>) than Data.Monoid did
23:12:54 <jle`> so if you didn't import it qualified, (<>) would be ambiguous
23:17:44 <dysfun> those were not good days
23:19:19 <pdxleif> jle`: Oh, so you risk breaking your code on old GHC (7.10 or something?) if you don't do that when adding a Semigroup instance?
23:27:00 * hackage vulkan-api 1.1.3.0 - Low-level low-overhead vulkan api bindings  http://hackage.haskell.org/package/vulkan-api-1.1.3.0 (achirkin)
23:37:42 <achirkin> Hey! Dear expert haskellers, I need your help :) I try to use POSIX mutexes in Haskell FFI and constantly get some processes hanging on pthread_cond_timedwait. I've posted the full description of the problem on https://stackoverflow.com/questions/50809983/pthread-cond-timedwait-does-not-return-in-ghc-ffi and also created a repo to make it easy to replicate it: https://github.com/achirkin/interprocess/tree/mvar-fail
23:37:47 <achirkin> And I am happy to answer any questions here or on stackoverflow or on github if you need more information.
23:38:24 <dminuoso> SO has new design? huh
23:41:00 * hackage soundgen 0.1.0.1 - sound generator  http://hackage.haskell.org/package/soundgen-0.1.0.1 (CIX_68)
23:47:46 <guessWHo> can i do type comparison with if ?? like if typeof x is Int
23:48:21 <dysfun> in general, you don't
23:48:49 <dysfun> what is the actual problem you're trying to solve?
23:49:49 <pavonia> guessWHo: Note that if-expressions are evaluated at runtime, while type checking already happens at compile time
23:49:51 <guessWHo> dysfun : i have this let temp = fst $ getPeer $ head $ fromMaybe [] lp it will either return a [] or a Custom type
23:50:29 <dysfun> guessWHo: create an ADT with two constructors and return that?
23:51:54 <guessWHo> dysfun  = not possible because i am storing this [customtype]  in an hash table and that's why need to use fromMaybe to extract value from it
23:51:54 <pavonia> Also that crashes if lp is Nothing
23:52:10 <pally> > liftA2 f [1,2,3] [4,5,6] :: [Expr]
23:52:13 <lambdabot>  [f 1 4,f 1 5,f 1 6,f 2 4,f 2 5,f 2 6,f 3 4,f 3 5,f 3 6]
23:52:24 <dysfun> right, it's not total
23:52:32 <pdxleif> And suggestions on how to use Data.Has with an API that as a HasFoo constriant?
23:52:38 <pally> how can I get ghci to do what lambdabot just did?
23:52:54 <pdxleif> It tells me it's not a terminating instance if I write instance Has Foo r => HasFoo r.
23:53:18 <pally> for ghci, f is not in scope.
23:53:27 <jle`> pdxleif: yes, the whole point of the article is for backwards compatibility.  if you don't worry about supporting really old ghc's, then importing Semigroup as it is should be fine :)
23:53:33 <pdxleif> And if I turn on undecidable instances, it tells the instance is ambiguous if I try to call something using that.
23:53:48 <jle`> pdxleif: can you give an example of code
23:54:32 <pavonia> pally: It's from the simple-reflect package, I think
23:54:53 <pdxleif> jle`: Given a function with this constraint: https://hackage.haskell.org/package/amazonka-1.6.0/docs/Control-Monad-Trans-AWS.html#t:AWSConstraint
23:55:38 <jle`> pally: yes, it's not really a ghci or lambdabot feature.  it's just a library that defines a value 'f', 'x', etc.
23:55:43 <jle`> that has interesting Show instances
23:55:50 <dysfun> guessWHo: anyway, you should not use fromMaybe here, you should match on the result where you attempt to put it in the map
23:55:53 <pdxleif> I aslo wanted to add a "HasBar" constraint to the reader environment. Only it's less boilerplate and I can just use a tuple of (Env, Bar) as the environment if I use Data.Has, e.g. https://hackage.haskell.org/package/data-has-0.3.0.0/docs/Data-Has.html
23:55:56 <jle`> remember that it's ok for a library to define a value called 'f'
23:56:07 <jle`> pdxleif: can you give the code that causes the error
23:56:10 <dminuoso> :t f
23:56:11 <lambdabot> FromExpr a => a
23:56:51 <jle`> pdxleif: everything you have linked seems good so far, so it's unclear what is causing the error
23:58:03 <pally> jle`, okay, now that I know it's from simple-reflect, I'll learn how to download, install, and/or import it later
23:58:08 <pdxleif> jle`: One sec, I'll come up with a minimal stand-alone example
23:58:24 <pally> in the meantime, I'll just use lambdabot
23:59:24 <dminuoso> I have the desire to write some `f :: forall e. SomeException e => e -> Maybe a -> IO a` - is this a wise idea?
23:59:51 <dminuoso> Oh. I missed a quantifier there, it should be `forall e a.`
