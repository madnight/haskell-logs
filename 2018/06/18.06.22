00:05:49 <johnw> any Eta users here?
00:06:03 <johnw> I wondering how I can subclass a Java class, and then make that subclass available to a Scala program
00:18:29 * hackage geodetics 0.0.6 - Terrestrial coordinate systems and geodetic calculations.  http://hackage.haskell.org/package/geodetics-0.0.6 (PaulJohnson)
00:51:48 <bwe> How can I cache with bitbucket pipelines haskell dependencies (using stack)? https://bitbucket.org/site/master/issues/12818/caching-dependencies-in-pipelines#comment-46319659
00:54:33 <bwe> Contrary to travis (https://www.fpcomplete.com/blog/2016/02/updated-haskell-travis-config), bitbucket seems not to support `directory` key specifier: https://confluence.atlassian.com/bitbucket/configure-bitbucket-pipelines-yml-792298910.html#Configurebitbucket-pipelines.yml-ci_cachescaches
00:59:05 <mreh_> I'm trying to compile GHC from some instructions, can anyone decypher this? "For GHC we need opt and llc from the llvm 4, which can be obtained from their release download website. (http://releases.llvm.org/download.html)"
01:02:41 <dminuoso> bwe: just like specified in that thread?
01:02:54 <dminuoso> bwe: you'll want to cache your ~/.stack/store
01:05:21 <cocreature> mreh: if you want to use GHC’s LLVM backend (which is not the default), you need (for the GHC release you are trying to install) the "opt" and "llc" binaries that you get from LLVM 4.x
01:06:12 <mreh> cocreature, I'm trying to cross compile to arm on android, so I guess LLVM is the backend for that
01:06:27 <cocreature> ah yeah, for arm you have to use LLVM
01:06:45 <mreh> someone was distributing prebuilt binaries but they're offline right now
01:07:16 <cocreature> if you are cross compiling you might also want to use the newest GHC release. afaik there have been quite a few improvements to cross-compilation recently
01:08:46 <mreh> cocreature, I read that zw3rk is adding "-target" to GHC too
01:09:01 <cocreature> yeah although I think that’s still a bit away
01:09:18 <alp> yeah, I think it's quite early in the making. angerman?
01:10:03 <angerman> yea, nothing soon.
01:10:18 <angerman> and yea, zw3rk = angerman for all practical pruposes :-)
01:10:49 <bwe> dminuoso: ~/.stack/store will suffice, then?
01:10:59 <mreh> angerman,  are you zw3rk?
01:11:10 <angerman> yea, pretty much :-)
01:11:29 <angerman> hackage.mobilehaskell.org should be back online soonish... stupid dns tricket me.
01:11:39 <mreh> angerman, thanks, I tweeted you
01:11:52 <mreh> I think... I'm still not sure it *is* you
01:12:29 <angerman> yea, thanks for letting me know.
01:12:30 <mreh> I thought it might be DNS, it was showing blanks in the A record
01:13:03 <angerman> yea, domains were moved due to some registrar issue. and apparently the NS copy didn't work out.
01:13:09 <mreh> angerman, can I use these to build GHC for mobile in the mean time? https://github.com/zw3rk/ghc-build-scripts/commits/master/build-mobile-ghcs
01:14:59 <angerman> mreh: you can use http://hackage.mobilehaskell.org.s3-website-ap-southeast-1.amazonaws.com/, and http://releases.mobilehaskell.org.s3-website-ap-southeast-1.amazonaws.com/ in the meantime
01:16:18 <angerman> mreh: I hope they are fully propagated by tonight again.
01:17:32 <mreh> angerman, okay, great
01:18:21 <angerman> sorry for the inconvenience :/
01:22:23 <mreh> angerman, have I got this right? http://releases.mobilehaskell.org.s3-website-ap-southeast-1.amazonaws.com/x86_64-linux/9824f6e473/ghc-8.4.0.20180109-armv7-linux-androideabi.tar.xz
01:22:57 <angerman> ohh sorry :-) just a sec
01:23:57 <angerman> mreh: this one: https://s3-ap-southeast-1.amazonaws.com/releases.mobilehaskell.org/x86_64-linux/9824f6e473/ghc-8.4.0.20180109-armv7-linux-androideabi.tar.xz
01:24:30 <mreh> angerman, that's better :) lets see if I can run this on Ubuntu
01:25:44 <angerman> you'll still need to setup the toolchain wrapper and your android toolchain, but apart from that, I think it should work :-)
01:26:20 <mreh> angerman, thanks, I'll follow the talk you gave, the slides and video
01:53:00 * hackage relational-query 0.11.3.0 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.11.3.0 (KeiHibino)
01:53:26 <bahamas> is there something equivalent for `npm install --save library` in haskell? that means both installing the library and adding it to dependencies in the cabal file
01:56:01 <Rembane> bahamas: I usually do it the other way around. I add the library to my stack.yaml and then run stack install.
01:56:14 <Rembane> bahamas: And then set version constraints.
02:03:23 <bahamas> Rembane: where do you add them? to extra-deps?
02:06:59 <Rembane> bahamas: Sorry, typo, I add them to my cabal file.
02:08:00 * hackage relational-record-examples 0.5.1.0 - Examples of Haskell Relationa Record  http://hackage.haskell.org/package/relational-record-examples-0.5.1.0 (KeiHibino)
02:28:17 <c50a326> (,) is a function :o
02:28:47 <merijn> c50a326: It's a data constructor, but those function a lot like functions, yes
02:29:00 <merijn> :t Just
02:29:01 <lambdabot> a -> Maybe a
02:29:23 <merijn> Think about it, "Just" has a function type from 'a' to 'Maybe a'
02:29:25 <merijn> :t (,)
02:29:26 <lambdabot> a -> b -> (a, b)
02:29:30 <lavalike> @type (,,) -- c50a326
02:29:31 <lambdabot> a -> b -> c -> (a, b, c)
02:29:36 <quicksilver> all data constructors are functions, but not all functions are data constructors.
02:29:49 <merijn> So, obviously the , constructor for tuples takes an 'a' and 'b' and returns a tuple
02:30:25 <quicksilver> unless you think that is inexact and you might prefer "all data constructors give rise to a corresponding function". But in haskell we use the same name for both.
02:30:33 <quicksilver> [unlike ocaml, say]
02:31:38 <gonz_> Which is infuriating behavior in OCaml, by the way
02:31:47 <quicksilver> I find it so :)
02:31:48 <gonz_> at least coming from the Haskell side of things
02:31:56 <quicksilver> that and the value restriction
02:32:07 <gonz_> To have to add a ppx to derive constructor functions
02:32:39 <gonz_> With bucklescript it's built-in, but still annoying if you temporarily forget to add the deriving directive
02:33:34 <c50a326> why does min only take 2 arguments, why can't it take n arguments
02:33:55 <merijn> :t minimum
02:33:57 <lambdabot> (Ord a, Foldable t) => t a -> a
02:34:27 <cocreature> :t minimum :: Ord a => [a] -> a
02:34:28 <lambdabot> Ord a => [a] -> a
02:34:35 <cocreature> in case you aren’t familiar with Foldable yet :)
02:34:55 <c50a326> I have seen the minimum function but still doesn't answer why min and max couldn't take more arguments
02:35:11 <merijn> c50a326: How would "variable number of arguments" work in Haskell's type system?
02:35:22 <c50a326> min 1 2 3 should return 1
02:35:38 <cocreature> c50a326: try finding a type for that version of "min"
02:35:54 <gonz_> :t minimum [1, 2, 3]
02:35:56 <lambdabot> (Num a, Ord a) => a
02:40:42 <jpcooper> Hello. Given `data X = forall a. X a` the function `id :: a -> a` and a value `X 666`, how can I apply `id` to the value `666` inside?
02:40:46 <c50a326> I don't understand any of these type definitions tbh, e.g.
02:40:51 <c50a326> :t [1..20]
02:40:53 <lambdabot> (Enum a, Num a) => [a]
02:41:04 <jpcooper> Is this possible?
02:41:14 <c50a326> well that's different, in ghci Enum a and Num a are the other way round for starters
02:41:29 <c50a326> and why aren't they just both the same type, like (Enum a, Enum a)
02:43:05 <merijn> c50a326: Because numeric literals are polymorphic Num typed and [..] sugar is shorthand for the Enum class
02:43:25 <merijn> c50a326: [x..y] is just syntactic sugar for "enumFromTo"
02:43:29 <merijn> :t enumFromTo
02:43:30 <lambdabot> Enum a => a -> a -> [a]
02:43:43 <jpcooper> Actually that isn't my full issue. I am trying to build `Constraint`s from https://hackage.haskell.org/package/limp-0.3.2.2/docs/Numeric-Limp-Program-Constraint.html by using what I have defined as `data SomeLinear v = forall k. SomeLinear (Linear v v k)` and unwrapping them. This doesn't seem to be possible even though the `Constraint` constructors don't actually care about the instance of `k`.
02:43:48 <cocreature> jpcooper: pattern match on X and apply id? you won’t be able to do much with the result
02:43:56 <cocreature> but that in itself should work
02:44:04 <merijn> ok, so we know that we have two values of type 'a' returning a '[a]' (where 'a' is an instance of Num)
02:44:07 <merijn> :t 1
02:44:08 <lambdabot> Num p => p
02:44:49 <merijn> c50a326: And 1 is 'Num a => a' i.e. any numeric type, so if we put the two together we get a list of "anything that happens to be both an instance of Num and an isntance of Enum
02:44:53 <jpcooper> cocreature, id (case X 666 of X r -> r) results in type scope errors
02:45:07 <cocreature> jpcooper: you need to use "id" inside the case
02:45:09 <merijn> jpcooper: Because you can't return the contents from the pattern match
02:45:18 <cocreature> you can’t escape type variables from an existential pattern match
02:45:26 <jpcooper> cocreature, same error
02:45:47 <jpcooper> (case X 666 of X r -> id r)
02:46:51 <c50a326> so is there some kind of type hierarchy in haskell
02:46:59 <c50a326> is there a nice page on type polymorphism?
02:47:05 <c50a326> at the moment i'm just reading learn you a haskell
02:47:07 <merijn> jpcooper: because now you're still trying to return the content of X
02:47:18 <merijn> jpcooper: You can *never* return the content from within X
02:47:49 <c50a326> ah there's a wiki page
02:48:22 <merijn> c50a326: There's no type hierarchy, but Haskell has builtin support for polymorphic literals
02:48:23 <quicksilver> c50a326: there is no type hierarchy, really
02:48:35 <quicksilver> c50a326: there is a hierarchy of *typeclasses*
02:49:00 * hackage odpic-raw 0.3.0 - Oracle Database Bindings  http://hackage.haskell.org/package/odpic-raw-0.3.0 (leptonyu)
02:49:14 <quicksilver> and there is the rather fundamental notion of "more specific types" which does look a bit like a hierarchy if you squint, but it's certainly not a classic type hierarchy.
02:49:52 <jpcooper> merijn, What can I do with the content within X?
02:50:04 <merijn> jpcooper: In your example? Not a whole lot
02:51:10 <merijn> Basically, you can apply "id" to it and wrap it back up into an X again
02:51:47 <jpcooper> Makes sense actually. I wouldn't be able to return a forall-typed value
02:52:48 <jpcooper> Thanks merijn and cocreature though. I've managed to solve the `Constraint` problem by a series of nested case matches
02:52:51 <cocreature> jpcooper: when you pattern match on an existential, you only get to know that it is of some type “a” (and if you add constraints, that these constraints hold for “a”)
02:53:38 <jpcooper> Makes sense
03:02:01 <mreh> angerman, do you think we could build android projects with stack?
03:03:29 <angerman> mreh, i honestly don’t know if anyone who has done so. It might work... I have only used cabal.
03:04:03 <mreh> angerman, I was just reading that in your slides, seeing as stack uses cabal, I wouldn't see why not
03:04:31 <mreh> would have to switch out the GHC binary somehow of course
03:06:20 <angerman> mreh, Stack does use lib:Cabal, cabal-install (which provides the cabal binary) does use lib:Cabal as well, however it doesn’t use the Setup.hs Interface but uses the API directly.
03:06:43 <angerman> Anyway, if you have a working stack setup, I’d certainly be interested to know.
03:13:17 <c50a326> why bother using 'let' here? http://learnyouahaskell.com/starting-out#an-intro-to-lists
03:13:21 <c50a326> it works the same without using let
03:14:40 <Boomerang> c50a326: It didn't used to work without let
03:18:06 * hackage names-th 0.2.0.5 - Manipulate name strings for TH  http://hackage.haskell.org/package/names-th-0.2.0.5 (KeiHibino)
03:20:10 <c50a326> and what's up with this, why are they different https://lpaste.net/4676818570406002688
03:20:45 <c50a326> oh wtf I put b^c not b^2 sorr
03:20:47 <c50a326> y
03:21:00 <jle`> keep in mind that LYAH was written like, 7 years ago
03:21:09 <jle`> and basically has never been updated
03:22:13 <jle`> in the past few years it has grown a bit out of favor
03:22:31 <c50a326> why are these different https://lpaste.net/5126078544773906432
03:23:03 <jle`> what makes you think they would be the same?
03:23:29 <c50a326> the a <-, b <- etc. are just ordered differently
03:24:32 <c50a326> oh no the hypotenuse should be the [1..10] one
03:24:39 <c50a326> and the other sides are the smaller sides
03:24:53 <jle`> the easiest way to see what these would turn out to be is to just manually evaluate it
03:25:03 <jle`> that's the nice thing about haskell, it's easy to manually expand out expressions and values
03:25:08 <jle`> it's basiclaly straight substitution
03:25:24 <jle`> you don't have to worry about any state to keep track of :)
03:26:12 <jle`> in this case we can just look at all possible values of a, b, and c generated
03:26:17 <jle`> and see which ones match the predicate
03:27:01 <jle`> if you follow this, you will see why the first one returns two items and the second one returns none
03:27:22 <c50a326> this is invalid though: [ (a, b, c) | a <- [1..c], b <- [1..a], c <- [1..10], a^2 + b^2 == c^2 ]
03:27:26 <jle`> in particular if you try out all possible combinations of a, b, and c in the second one, you will see that none of them will fulfill a^2 + b^2 == c^2
03:27:32 <c50a326> so the left to right thing seems to matter
03:27:57 <jle`> c50a326: ah yeah, list comprehensions have a quirk like that
03:28:06 <jle`> it's sort of necessary for order to matter
03:28:17 <jle`> since the order determines what is "nested"
03:28:38 <jle`> list comprehensions like that are basically the equivalent of nested for loops in other languages
03:28:38 <c50a326> has a lot changed since LYAH then? is there a better thing now?
03:29:04 <jle`> > [(a,b) | a <- [1,2,3], b <- "abc"]
03:29:07 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
03:29:16 <jle`> > [(a,b) | b <- "abc", a <- [1,2,3]]
03:29:18 <lambdabot>  [(1,'a'),(2,'a'),(3,'a'),(1,'b'),(2,'b'),(3,'b'),(1,'c'),(2,'c'),(3,'c')]
03:29:46 <mreh> angerman, do I need clang5?
03:29:52 <jle`> the basic principles are the same, but a lot of the surface parts of the language and libraries have changed
03:30:00 * hackage names-th 0.3.0.0 - Manipulate name strings for TH  http://hackage.haskell.org/package/names-th-0.3.0.0 (KeiHibino)
03:30:04 <mreh> unbuntu installs it as clang-5.0 helpfully
03:30:08 <quicksilver> there is nothing else as far as I know with LYAH's cheerful/informal style. Which some people find useful and some people hate.
03:30:12 <jle`> @where learnhaskell
03:30:12 <lambdabot> https://github.com/bitemyapp/learnhaskell
03:30:38 <angerman> mreh: you probably want to, but I would assume that llvm6 migth also work.
03:30:47 <jle`> there are some small things that are out of date that might confuse you if you aren't aware, but they aren't fundamental parts of the language really.  but when you're learning, it's hard to tell
03:31:01 * hackage indents 0.5.0.0 - indentation sensitive parser-combinators for parsec  http://hackage.haskell.org/package/indents-0.5.0.0 (JasperVanDerJeugt)
03:31:07 <jle`> the main complaint i've heard about LYAH is that it doesn't really have any exercises
03:31:13 <mreh> angerman, Ubuntu installs llvm3 by default
03:31:20 <jle`> so it's not really the best for "learning" haskell...just for showing off cool parts of it
03:31:46 <angerman> mreh: well that's a bit old. But you can just grab the binary distributions from the llvm.org website, and put their `bin` into your `PATH`.
03:31:53 <jle`> but it doesn't really do anything directly to help you learn how to write haskell
03:32:02 <jle`> er, write actual haskell programs
03:33:19 <mreh> angerman, will do
03:40:02 <mreh> angerman, do you need the NDK to build the project in those slides?
03:40:27 <angerman> Yes.
03:40:30 <mreh> meetup2018-01
03:41:20 <AWizzArd> I would like to have a `getField` method in a Lookup typeclass. The idea is that getField can return any field from a record. I thought about the type signature  getField :: a -> String -> b.  So I would pass in a value of my record of type `a` and a String and then just return something from that record.
03:42:16 <AWizzArd> However, when I try to implement   getField myPerson "Person.age" = age myPerson    I get the complaint that the Int doesn’t match with `b`.
03:42:16 <cocreature> AWizzArd: so you want to replace a nice typesafe record by a lookup function that gets the field name as a String?
03:42:22 <cocreature> that doesn’t sound like a win
03:42:39 <cocreature> "getField :: a -> String -> b" mean that the caller gets to choose "b"
03:42:50 <cocreature> that can’t possibly work since your field has a fixed type
03:42:59 <AWizzArd> cocreature: yes, is there a RankN type signature that would help?
03:43:13 <AWizzArd> cocreature: I want to be able to use this for any Record, as my code lives in my library and only the end user of this lib will have concrete types.
03:43:29 <cocreature> not in a useful way, you need to return some kind of sumtype that represents the possible field types
03:43:37 <AWizzArd> Okay I see.
03:43:48 <cocreature> or I guess Dynamic but at that point you might as well write javascript :P
03:44:22 * hackage regex-tdfa 1.2.3.1 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-tdfa-1.2.3.1 (Artyom)
03:44:57 <AWizzArd> cocreature: it’s for an interpreter that should be extensible by a user. Anyway, I think I can work around this by lifting the return value into my Term type.
03:49:14 <iron_houzi> If I want to split my code up into two files and using stack. Does this happen in the .cabal file with Exposed/Other-Modules, or in the stack.yaml file somehow?
03:49:24 <cocreature> iron_houzi: in the cabal file
03:49:27 <iron_houzi> ty
03:59:12 <iron_houzi> When I do `stack build` I don't get an import error for my new module I've declared in cabal file, but when I do `stack ghc src/Main.hs`, I get the import error, which is bugging me since my editor is using ghc for linting..
03:59:24 <iron_houzi> Any way to fix this?
03:59:59 <iron_houzi> ..sorry, my editor is using `stack ghc` for linting
04:00:34 <cocreature> I don’t think you can rely on "stack ghc" to behave the same way as a "stack build"
04:00:48 <merijn> iron_houzi: Because stack build setups up the package environment, etc. "stack ghc" would just call GHC I think
04:01:01 <cocreature> it’s missing all the options specified in the cabal file which includes things like include-dirs, …
04:01:29 <cocreature> in this case I would suspect that a missing -isrc flag (or something similar) is probably the difference
04:03:36 <mreh> angerman, did I miss a step? clang can't find math.h.
04:04:17 <angerman> mreh: are you using the wrapper-scripts?
04:04:43 <mreh> I'm just running make in 2018-1-MeetupDemo/app
04:05:17 <mreh> armv7-linux-androideabi-ghc \
04:05:20 <mreh>     -fllvmng -staticlib -fPIC \
04:05:20 <mreh>     -o hs-libs/armeabi-v7a/libHSmeetupdemo.a \
04:05:20 <mreh> 	-odir build/hs/armv7 -hidir build/hs/armv7 \
04:05:20 <mreh> 	src/main/hs/Lib.hs
04:05:21 <mreh> looks to me as if it is
04:05:32 <angerman> mreh: you'll probably need https://github.com/zw3rk/toolchain-wrapper, and adapt https://github.com/zw3rk/toolchain-wrapper/blob/master/linux-android-toolchain.config appropriately.
04:06:16 <iron_houzi> cocreature: `stack ghc` doesn't have `-isrc` flag, do you know why?
04:06:55 <cocreature> iron_houzi: "stack ghc" just sets up package databases. it makes no attempt to figure out which flags are appropriate to compile a specific file
04:07:05 <cocreature> (which is in general also not possible)
04:07:32 <mreh> angerman, I probably nuked my NDK
04:07:46 <mreh> ANDROID_NDK=${$HOME}/src/ndk-bundle
04:07:47 <mreh> HOST_ARCH=darwin-x86_64
04:07:47 <mreh> GCC_VERSION=4.9
04:07:47 <mreh> API_VERSION=24
04:07:58 <mreh> I'm pretty sure HOST_ARCH is incorrect
04:08:09 <iron_houzi> cocreature: but stack ghc calls some ghc binary, right?
04:08:18 <iron_houzi> *executes
04:08:24 <mreh> and I'm running GCC 5.4
04:08:36 <cocreature> iron_houzi: yes, the problem is not the ghc binary it calls. the problem is that compiling a source file often requires passing special flags to GHC
04:08:49 <cocreature> iron_houzi: if you run "stack build" stack will pass the right flags for each file
04:09:03 <iron_houzi> cocreature: Exactly, and there's no way to have stack ghc specify those flags??
04:09:18 <dminuoso> iron_houzi: thats what `stack build` is for.
04:09:19 <cocreature> nope, as I said it doesn’t have enough information to do that
04:09:33 <cocreature> you could include the same source file in multiple components with different flags
04:09:41 <cocreature> how should "stack ghc" decide which flags it needs to use?
04:09:52 <cocreature> but yeah that’s also just not the usecase stack ghc was made for
04:10:03 <dminuoso> I suppose `stack ghc` is just a convenience wrapper for `stack exec ghc`?
04:10:11 <iron_houzi> OK, any Vim users here using stack ghc for linting?
04:11:03 <iron_houzi> dminuoso: Yeah, that's fine, but I'm using stack ghc to get linting in my editor ..
04:11:37 <iron_houzi> dminuoso: .. so doing stack build, would compile all the files, right?
04:15:17 <cocreature> iron_houzi: I think the right answer here is “don’t use stack ghc for linting”. there is a reason why we have tools like intero, ghc-mod, …
04:15:26 <cocreature> I don’t use vim so I can’t make any specific recommendation
04:15:34 <cocreature> I mostly just have ghcid running in a separate window
04:15:47 <iron_houzi> cocreature: Yeah, thanks. I see there are other options, so I'll try hdevtools
04:34:18 <gonz_> I use neovim with a language server client plugin + `haskell-ide-engine`. So far it works without issue. `haskell-ide-engine` supports anything that supports the language server protocol, so it works fine with VSCode, etc.. Emacs has a "WIP" implementation that more or less works.
04:35:26 <gonz_> I started using this when I realized `ghc-mod` didn't work for the stack snapshot I was using. `haskell-ide-engine` ships with `ghc-mod` behind the scenes, so you get that part anyway.
04:36:16 <Rembane> I have the same setup as gonz_
04:36:25 <gonz_> An important detail is that type-of-expression doesn't work with f.e. neovim. It works in VSCode, but that's because they made it work. The language server protocol itself apparently doesn't deal with type-of-expression stuff.
04:36:27 <Rembane> gonz_: Do you have working type information?
04:36:34 <Rembane> Oh
04:36:37 <gonz_> Only for identifiers
04:36:41 <Rembane> Check.
04:36:41 <gonz_> Not for sub-expressions
04:36:49 <gonz_> (in neovim)
04:36:57 <Rembane> And it's a shortcoming of LSP?
04:36:57 <gonz_> But in VSCode I do have sub-expression types
04:37:00 <Rembane> Nice
04:37:14 <Rembane> What's your impression of VSCode?
04:37:49 <gonz_> It's pretty great once you've just accepted that you pay a memory cost
04:37:59 <gonz_> The interface is fine with vim-keys and the vim mode is decent
04:38:15 <__monty__> If that's a limitation of LSP then I hope the protocol can still be changed, would be a major disservice to type inferred languages.
04:41:34 <gonz_> __monty__:  There is an issue for it and people are looking into it: https://github.com/Microsoft/language-server-protocol/issues/377
04:48:58 <Rembane> gonz_: Sounds good. Is VSCode an Electron app?
04:50:06 <quicksilver> I believe so.
04:50:23 <Rembane> That makes me sad.
04:50:26 <c50a326> how can I operate on alternating element indexes of a list
04:50:44 <Rembane> c50a326: Like 0,2,4,6... ?
04:50:54 <c50a326> so far I have found elemIndex and also wondering if I could do something more functional like using take 1 drop 1 alternately
04:51:04 <c50a326> Rembane: yeah
04:51:25 <gonz_> Rembane: It is. It's one of the better made ones, though. The memory usage isn't sky-high and the performance overall is good. On a monster dev computer there is no real difference between other editors other than their interface.
04:51:46 <c50a326> so the first, third, fifth... or second, fourth, sixth... just in general what's the pattern for doing stuff to lists but to some subset of their elements like that
04:51:55 <c50a326> well, a subset that alternates like that
04:52:33 <Rembane> c50a326: f xs = catMaybes $ zipWith (\(a,b) -> if b then Just a else Nothing)  xs (cycle [True, False])
04:53:39 <Rembane> gonz_: That's nice. Sounds useful.
04:53:46 <__monty__> Rembane: I was recently convinced the problem with electron apps is not electron it's how electron is used.
04:54:07 <c50a326> Rembane: well that introduces a bunch of stuff I haven't seen before
04:54:10 <Rembane> __monty__: Oh. How is it used that makes it hm... not that good?
04:54:12 <c50a326> I'm a beginner
04:54:18 <c50a326> isn't there a simple way to do this simple thing
04:54:20 <Rembane> c50a326: It does indeed.
04:54:36 <Rembane> c50a326: You can also write a custom function for it that uses recursion.
04:55:05 <c50a326> Rembane: you're just confusing
04:55:17 <Rembane> c50a326: Sorry about that. :)
04:55:18 <__monty__> Rembane: Just like how most web apps are written. I'll look for the example demo web app he used as an example in my logs.
04:55:23 <quicksilver> if you have chunksOf you can do something like map head . chunksOf 2
04:55:26 <Rembane> __monty__: Thank you!
04:57:23 <quicksilver> maybe this one is close to your intuition of repeatedly dropping elements, c50a326
04:57:27 <quicksilver> > takeWhile (not.null) . iterate (drop 2) $ "abcdefghi"
04:57:29 <lambdabot>  ["abcdefghi","cdefghi","efghi","ghi","i"]
04:57:40 <quicksilver> if that seems intuitive then you can just map head on the result
04:57:45 <quicksilver> > map head . takeWhile (not.null) . iterate (drop 2) $ "abcdefghi"
04:57:47 <lambdabot>  "acegi"
04:58:33 <Boomerang> > let f (x:_:zs) = x : f zs; f xs = xs in f [0..10] -- Is that simpler? :)
04:58:36 <lambdabot>  [0,2,4,6,8,10]
04:59:04 <Rembane> Boomerang: Beautiful!
05:04:37 <c50a326> how could one just implement indexOf
05:04:47 <c50a326> or elemIndex or whatever
05:05:03 <Boomerang> > [0..] !! 5
05:05:05 <lambdabot>  5
05:05:25 <Boomerang> Or do you want to implement !! yourself?
05:05:28 <c50a326> > [ 0, 1, 2 ] !! 1
05:05:30 <lambdabot>  1
05:05:40 <c50a326> ahhhh !! okay
05:07:24 <Boomerang> > let f 0 (x:_) = x; f n (_:xs) = f (n-1) xs in f 10 ['a'..] -- f is similar to (!!) :)
05:07:26 <lambdabot>  'k'
05:08:04 <__monty__> Rembane: This is the POC he showed, note that it's from the pentium III era. Nothing groundbreaking but I'm 100% sure if it was implemented by most of the people that write web/electron apps today that you'd probably get stuttering with two or three windows: http://cryto.net/projects/jsde/demo/#
05:09:02 <merijn> cocreature: Do you have a minute to try and reproduce some new-build behaviour for me?
05:09:19 <merijn> (or anyone else, for that matter)
05:09:19 <cocreature> merijn: maybe, what do you need? :)
05:09:45 <merijn> cocreature: I'm seeing some really funky caching behaviour and I'm unsure if it's always been funky or just in HEAD
05:10:09 <Rembane> __monty__: Thank you! ^^
05:10:36 <cocreature> merijn: you’ll have to be a bit more precise if you want me to reproduce it :)
05:10:43 <merijn> cocreature: Basically, in a clean project (so no dist-newstyle around) I'm seeing that "new-repl" with -fobject-code in ~/.ghci builds the same binaries as new-build normally would, but upon future calls it KEEPS rebuilding them
05:10:54 <merijn> cocreature: Running a new-build afterwards *also* rebuilds.
05:11:00 <pally> Having trouble with a recursive algorithm to find a list of all acyclic paths
05:11:04 <pally> here's what I mean:
05:11:05 <pally> [("a", ["b","c"], ("b", ["a"]), ("c", ["a"])] => [["a","b"], ["b", "a", "c"], ["c", "a", b"]]
05:11:14 <Rembane> __monty__: It's not too advanced. Hm...
05:11:15 <cocreature> merijn: so do you want me to try this with HEAD or 2.2?
05:11:19 <merijn> cocreature: However, FIRST "new-build" *then* new-repl rebuilds once and all future "new-repl" reuse the existing objects
05:11:31 <merijn> cocreature: 2.2 I'm using HEAD myself :)
05:11:40 <merijn> And don't wanna invest an hour into building 2.2 :p
05:11:58 <Myrl-saki> Boomerang: Personally, I would use `head . filter _ . zip [0..]`
05:12:09 <merijn> Whereas I'd basically expect that in all those case only the very first new-build/new-repl should build and the other should reuse the artefacts
05:12:32 <Myrl-saki> let index xs i = head . filter (== i) . zip [0..] $ xs
05:12:34 <Myrl-saki> > let index xs i = head . filter (== i) . zip [0..] $ xs
05:12:36 <lambdabot>  <no location info>: error:
05:12:36 <lambdabot>      not an expression: ‘let index xs i = head . filter (== i) . zip [0..] $ xs’
05:12:40 <Boomerang> Myrl-saki: I rarely use explicit recursion anymore, I'm just trying to show the simplest Haskell possible :)
05:12:43 <Myrl-saki> > index xs i = head . filter (== i) . zip [0..] $ xs
05:12:46 <lambdabot>  <hint>:1:12: error:
05:12:46 <lambdabot>      parse error on input ‘=’
05:12:46 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
05:12:52 <Myrl-saki> Wellllllein
05:13:02 <pally> So far I've tried using list comprehension, but I don't know how to do it
05:13:06 <Myrl-saki> > let index xs i = head . filter (== i) . zip [0..] $ xs in index [3,2,1] 0
05:13:08 <lambdabot>  error:
05:13:08 <lambdabot>      • No instance for (Num (Integer, Integer))
05:13:08 <lambdabot>          arising from a use of ‘e_103210’
05:13:15 <Myrl-saki> Meh, I give up.
05:13:18 <Myrl-saki> You get the idea.
05:13:22 <c50a326> oh !! is get the element at position whatever... it's not indexOf :(
05:13:43 <__monty__> Rembane: Hence why it's an old POC. I've seen todo apps that aren't comfortable past 5 items, this POC can handle hundreds of windows in every tab.
05:14:07 <Boomerang> Oh right c50a326, I guess I missunderstood what you were after
05:14:08 <pally> as you can see, it's acyclic, meaning during the traversal it's not going anything that it has visited to (each) of its list
05:14:14 <pally> lists*
05:14:14 <Myrl-saki> Boomerang: Personally, composition is the simplest Haskell for me. :P
05:14:19 <cocreature> merijn: so I added ":set -fobject-code" to ~/.ghci, nuked dist-newstyle and ran "cabal new-repl" twice. the first time it build the object files. the second time it didn’t
05:14:30 <c50a326> there isn't an operator that's the opposite of !! then?
05:14:33 <pally> add anything*
05:14:34 <cocreature> merijn: so I guess the behavior is only in head if I understood you correctly
05:14:38 <Myrl-saki> c50a326: indexOf?
05:14:46 <Myrl-saki> Or findIndex?
05:14:47 <Boomerang> c50a326: elemIndex is good too
05:15:25 <Myrl-saki> Oh, findIndex is more general.
05:15:41 <Myrl-saki> c50a326: Learn to Hoogle. `:: Eq a => a -> [a] -> Maybe Int`
05:15:56 <Myrl-saki> :hoogle
05:16:02 <Myrl-saki> @hoogle
05:16:02 <lambdabot> package base
05:16:02 <lambdabot> package bytestring
05:16:02 <lambdabot> package containers
05:16:12 <c50a326> o_o
05:16:16 <Myrl-saki> @hoogle :: Eq a => a -> [a] -> Maybe Int
05:16:17 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
05:16:17 <lambdabot> GHC.OldList elemIndex :: Eq a => a -> [a] -> Maybe Int
05:16:17 <lambdabot> Data.List.Utils elemRIndex :: Eq a => a -> [a] -> Maybe Int
05:16:21 <Myrl-saki> There we go.
05:16:41 <merijn> cocreature: And if you run "new-build" then "new-repl"?
05:17:43 <Boomerang> Myrl-saki: composition requires a basic knowledge of the prelude :)
05:18:08 <__monty__> I've had trouble hoogling for monadic functions like foldM and mapM, hoogle always returns bracket and liftM2 and the like. Can I optimize my queries so mapM and the like are among the results?
05:18:15 <Myrl-saki> Boomerang: Right, but explicit recursion scares people off.
05:18:30 <pally> [("a", ["b","c"]), ("b", ["a"]), ("c", ["a"])] => [["a","b"], ["a", "c"], ["b", "a", "c"], ["c", "a", b"]]  is what I want.
05:18:37 <cocreature> __monty__: https://hoogle.haskell.org/?hoogle=(Foldable%20t%2C%20Monad%20m)%20%3D%3E%20(b%20-%3E%20a%20-%3E%20m%20b)%20-%3E%20b%20-%3E%20t%20a%20-%3E%20m%20b foldM is the first hit
05:18:48 <Myrl-saki> Boomerang: I get how you feel though.
05:19:22 <c50a326> [x*2|x<-xs, (mod (elemIndex x xs) 2) /= 0]
05:19:26 <c50a326> this doesn't work
05:19:28 <Myrl-saki> Seems like that can be done with traverse or something.
05:19:40 <Boomerang> It's always difficult to know what's best to bring beginners up to speed. Ideally they would just learn the Prelude really well by themselves ^^
05:19:41 <Myrl-saki> Oh wait no, I'm talking BS.
05:20:20 <Boomerang> What are you trying to do c50a326? :)
05:20:28 <__monty__> cocreature: So your solution is to include the class constraints? What if I don't know the relevant classes?
05:20:54 <cocreature> __monty__: ask in #haskell :)
05:20:59 <Myrl-saki> > map (\(x, y) -> x ++ y) [("a", ["b","c"]), ("b", ["a"]), ("c", ["a"])]
05:21:00 <c50a326> Boomerang: double the elements in an array if the index of the element is even
05:21:01 <lambdabot>  error:
05:21:01 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[Char]’
05:21:01 <lambdabot>      • In the expression: "b"
05:21:16 <Myrl-saki> > map (\(x, y) -> fmap (x ++) y) [("a", ["b","c"]), ("b", ["a"]), ("c", ["a"])]
05:21:18 <lambdabot>  [["ab","ac"],["ba"],["ca"]]
05:21:30 <Myrl-saki> Wait...
05:21:37 <cocreature> __monty__: the typesearch in the new hoogle is pretty useless without the constraints
05:21:38 <Boomerang> :t elemIndex
05:21:39 <lambdabot> Eq a => a -> [a] -> Maybe Int
05:21:41 <Myrl-saki> pally: Is this a graph?
05:21:55 <cocreature> __monty__: the old hoogle does better https://www.haskell.org/hoogle/?hoogle=%28b+-%3E+a+-%3E+m+b%29+-%3E+b+-%3E+t+a+-%3E+m+b but it indexes far less functions and old versions so I never use it
05:22:05 <c50a326> oh it returns a Just 1
05:22:18 <c50a326> or something like that, do I need to turn the Just Int into a normal Int?
05:22:25 <pally> Myrl-saki, yes.  I want to print the list of all ayclic paths.
05:22:26 <Boomerang> c50a326: So elemIndex is the wrong type for how you're using it, but I understand what you're trying to do. I'm not sure list comprehension is the best way to do this but I can give it a go
05:22:28 <c50a326> does mod not work with Just Int or Maybe Int or whatever it is?
05:22:50 <__monty__> cocreature: Hmm, interesting. Is there any discussion on why it has to be this way?
05:23:05 <Boomerang> > let xs = [3,4,5] in [ x*2 | (x, i) <- zip xs [0..], even i ]
05:23:06 <Myrl-saki> pally: Seems complicated. :P
05:23:07 <lambdabot>  [6,10]
05:23:11 <Myrl-saki> pally: Good luck.
05:23:12 <cocreature> __monty__: afaik the old hoogle didn’t scale well
05:23:13 <pally> yes, it is
05:23:38 <cocreature> __monty__: so the new hoogle compromises worse type search for better performance (indexing all of stackage takes a few minutes iirc)
05:24:01 <Myrl-saki> pally: Are Strings there being treated as Strings, or as [Char]?
05:24:09 <__monty__> cocreature: One of the annoying things for instance is looking for something that might require Functor or Applicative or Monad. Sometimes I don't care which I just know it's probably one of those.
05:24:26 <Boomerang> > let xs = [3,4,5] in [ x*2 | x <- xs, let Just i = elemIndex x xs, i `mod` 2 == 0 ] -- Or like this, but I think it's less efficient
05:24:27 <pally> Either is fine, really.
05:24:28 <__monty__> Then there's foldable/traversable.
05:24:28 <lambdabot>  [6,10]
05:24:29 <c50a326> I guess maybe I should learn about this zip thing... or maybe it's too early for that, sigh
05:24:44 <pally> Can someone give me a suggestion?  I've struggled on this for a good 4-5 hours
05:24:46 <cocreature> __monty__: tbh I usually just guess the name or the package that I expect it to be in and search that way
05:24:50 <Boomerang> c50a326: I just did a version without zip :)
05:24:53 <cocreature> I never got much out of hoogle’s type search
05:25:02 <Boomerang> Thought zip is nothing you should be affraid of
05:25:10 <Rembane> __monty__: Dang. 5 items in a TODO-app isn't anything. I built a Javascript app using Mithril that gives a nice UI for a planning system. It still runs smoothly, but it doesn't use any cool things. :)
05:25:27 <Myrl-saki> pally: Oh okay, if you're treating them as [Char], and you're fine with "god knows what big-O this is", then you can just keep appending to it until it converges to a value.
05:25:30 <__monty__> cocreature: That's what I've been resorting too. But that only works because I already vaguely now the *M variants of functions.
05:25:54 <c50a326> Boomerang: how to know what's acceptable in the comma-separated stuff in the list comprehension?
05:26:30 <pally> Myrl-saki, what do yo mean?  this is what I want <Myrl-saki> > map (\(x, y) -> fmap (x ++) y) [("a", ["b","c"]), ("b", ["a"]), ("c", ["a"])]
05:26:30 <pally>  <lambdabot>  [["ab","ac"],["ba"],["ca"]]
05:26:37 <pally> oops
05:26:54 <pally> [("a", ["b","c"]), ("b", ["a"]), ("c", ["a"])] => [["a","b"], ["a", "c"], ["b", "a", "c"], ["c", "a", b"]]  is what I want.
05:26:55 <cocreature> __monty__: yeah it’s not really satisfying but it works pretty well for me :)
05:27:01 <byorgey> c50a326: you can use any expressions you want in a list comprehension
05:27:02 <Boomerang> c50a326: List comprehensions are a bit weird if you don't know what they desugar to. But basically you can put "generators" and filters. The filters can be both booleans and pattern matches
05:27:21 <Myrl-saki> pally: Basically, by `converge`, I mean to run a step function until it no longer changes.
05:27:34 <cocreature> but I also just know the standard library/libraries pretty well at this point :)
05:27:54 <__monty__> Rembane: That's somewhat the point, you don't have to do anything fancy to get good performance. It's just that some people do stupid things with huge performance implications. The barrier to entry to electron is also fairly low, with "wordpress devs" writing desktop apps in javascript you can't expect too much. Especially when the startup mentality is very much slap on some features we can market,
05:28:00 <__monty__> rather than let's make this performant enough so it's useable/a joy to use.
05:28:15 <Myrl-saki> So, ("b", ["a"]) -> ("b", ["ac"])
05:28:22 <Myrl-saki> pally:
05:29:16 <Boomerang> > ([ 42 | False ], [ 42 | True ])
05:29:18 <lambdabot>  ([],[42])
05:29:35 <Myrl-saki> pally: OTOH, this hsould be easy to do with Monad.
05:29:38 <__monty__> cocreature: At least in agda the stdlib was still relatively small so I could just grep around the source : )
05:29:45 <c50a326> and what is ( let Just i = elemIndex x xs ) doing, and why can't I just do [ x*2 | x <- xs, (elemIndex x xs) `mod` 2 /= 0]
05:29:54 <Rembane> __monty__: That's a very good point. OTOH, having a short time to market is superimportant, and when things almost work you can start improving performance.
05:30:11 <Myrl-saki> Boomerang: I didn't know you could do that, and now I wish I didn't know you could do that. :P
05:30:25 <dminuoso> Do folks use monad comprehensions? If so, what for?
05:30:52 <Boomerang> c50a326: For this you would have to understand how Maybe works, but the short answer is that it is the wrong type: "Maybe Int" /= "Int"
05:31:10 <Myrl-saki> dminuoso: Mostly for :: [(a, [a])] -> [a]
05:31:21 <Rembane> dminuoso: No! They make me superconfused!
05:31:22 <Myrl-saki> Oh wait.
05:31:41 <Myrl-saki> dminuoso: I'm stupid. Didn't know you were talking about generaliaiton of list comprehensiosn :P
05:32:08 <Boomerang> Myrl-saki: That kind of list comprehension is great to replace "if test then [x] else []"
05:33:08 <Myrl-saki> pally: I think the best way is to take advantage of lazy evaluation, make it cyclic, then run a cycler remove.
05:33:42 <Myrl-saki> pally: So, convert it to "ababab", which is easy with Monad, then truncate it to "ab"
05:33:46 <bahamas> folks, I saw you talking about haskell in vs code earlier. is it normal that when I start typing "import" I get a completely irrelevant completion. I would just expect to write "imp" and have the word completed
05:35:01 <dminuoso> Rembane: I mean if it was just raw comprehensions I wouldnt mind much - but with TransformListComp and ParallelListComp that quickly turns into... really confusing code.
05:36:19 <Boomerang> > ([ x | x <- [0..5], let y = x + 1, even y], do x <- [0..5]; let y = x + 1; guard (even y); return x) -- Should be equivalent :)
05:36:21 <lambdabot>  <hint>:1:90: error: parse error on input ‘;’
05:36:36 <Boomerang> > ([ x | x <- [0..5], let y = x + 1, even y], do { x <- [0..5]; let y = x + 1; guard (even y); return x }) -- Should be equivalent :)
05:36:38 <lambdabot>  <hint>:1:92: error: parse error on input ‘;’
05:36:43 <Boomerang> Or not... :/
05:36:51 <Rembane> dminuoso: Yeah. I haven't used the raw ones enough to become comfortable with them. I'm much more into using functions on lists.
05:37:05 <pally> Myrl-saki, initially I was planning on keeping track of a sequence (call it "visitedList") of visited nodes and then do adjacentList \\ visitedList
05:37:23 <Boomerang> Oh, you can't use let in do one-liners? :o
05:37:27 <pally> that way it's never going to have cycles during the traversal
05:37:45 <cocreature> Boomerang: wait what? that’s weird …
05:37:58 <cocreature> > do let x = 1; pure x :: [Int]
05:38:00 <lambdabot>  <hint>:1:15: error:
05:38:00 <lambdabot>      Invalid type signature: pure x :: ...
05:38:00 <lambdabot>      Should be of form <variable> :: <type>
05:38:05 <cocreature> > do let x = 1; (pure x :: [Int])
05:38:06 <lambdabot>  <hint>:1:32: error:
05:38:06 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
05:38:11 <Boomerang> > ([ x*2 | x <- [0..5], even x], do x <- [0..5]; guard (even x); return (x*2)) -- Should be equivalent :)
05:38:13 <lambdabot>  ([0,4,8],[0,4,8])
05:38:17 <cocreature> > do { let x = 1; (pure x :: [Int]) }
05:38:19 <lambdabot>  <hint>:1:35: error: parse error on input ‘}’
05:38:35 <pally> but the difficulty I am having is figuring out how to  to recurse and split
05:38:41 <cocreature> > do { let x = 1; pure (x :: Int) }
05:38:43 <lambdabot>  <hint>:1:33: error: parse error on input ‘}’
05:38:50 <cocreature> ok my brain is apparently broken
05:39:10 <Boomerang> I couldn't get it to work in ghci either
05:40:11 <pally> [a]-> [a,b ...], [a, c], ...
05:40:43 <pally> so from one list (path) we diverse into two lists (paths
05:41:26 <fishythefish> > do { x <- [0..5]; let {y = x + 1}; guard (even y); return x } -- cocreature, Boomerang
05:41:28 <lambdabot>  [1,3,5]
05:41:39 <Boomerang> Ah :D nice one fishythefish
05:41:48 <pally> I don't know if  foldl will be of help
05:41:56 <dminuoso> fishythefish: Mmm. Why?
05:42:29 <fishythefish> dminuoso: I don't know if there's a better answer than "because the layout rule says so" https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3
05:43:20 <dminuoso> fishythefish: That answer is spot and and perfect. Thank you :)(
05:43:21 <cocreature> fishythefish: I think you can also use a semicolon to separate multiple let declarations. so if you didn’t require this the grammar would be ambiguous
05:43:43 <fishythefish> cocreature: yes, that sounds like a plausible reason
05:44:02 <Boomerang> > do x <- [0..5]; let y = x + 1 in do guard (even y); return (x*2)) -- You could also desugar the let manually :D
05:44:02 <fishythefish> there are a few ways around this - another option is to change that to `let ... in guard ...`
05:44:04 <lambdabot>  <hint>:1:65: error: parse error on input ‘)’
05:44:09 <pally> Myrl-saki, where can I find `converge` ?  It's not in `Data.List`
05:44:32 <Myrl-saki> pally: I don't think it's declared anywhere.
05:44:37 <Myrl-saki> Use this.
05:44:48 <Myrl-saki> https://gitlab.com/Myrl/mya/blob/master/lib/Powers/Squares.hs#L10-11
05:45:03 <Boomerang> cocreature: That makes perfect sense! :)
05:45:08 <Myrl-saki> pally: I probably ran that in pointless lol
05:45:36 <Myrl-saki> pally: I honestly have no idea how that works either.
05:45:47 <Myrl-saki> pally: But that basically is like fixedpoint, with an initial value.
05:46:01 <cocreature> friends don’t let friends use pointless
05:46:25 <Myrl-saki> > let converge = flip $ until =<< ((==) =<<) in converge 100 (`div` 2)
05:46:27 <lambdabot>  0
05:46:35 <Myrl-saki> pally: Does this make sense?
05:46:48 <Myrl-saki> cocreature: I'm a bad bad purrson. :(
05:46:59 <fishythefish> i'm preparing myself for disappointment:
05:47:01 <fishythefish> @unpl flip $ until =<< ((==) =<<)
05:47:01 <lambdabot> (\ x y -> until (y >>= (==)) y x)
05:47:10 * fishythefish shrugs
05:47:11 <Myrl-saki> fishythefish: Nice.
05:47:28 <c50a326> howcome I can change stuff in ghci? I keep reading that you cannot change something in haskell after you've set it... but in my ghci I can change it
05:47:45 <c50a326> x = 5, x = 6, and so on
05:47:50 <cocreature> c50a326: you can’t change it. you can create a new definition by the same name that hides the old definition
05:48:23 <fishythefish> ^ note that you're not changing the underlying value - that 5 is not now equal to 6, for example
05:48:27 <Ariakenom> You're running in a new environment
05:48:43 <Myrl-saki> > let 2 + 2 = 5; in 2 + 2
05:48:46 <lambdabot>  5
05:49:00 <jakov> hello ! could you please tell me, how could i rewrite this (\x -> return (B.unpack x)) into nicer code ?
05:49:01 <dminuoso> What :o
05:49:05 <dminuoso> Myrl-saki: what is this?
05:49:05 <Myrl-saki> :D
05:49:13 <c50a326> what is B
05:49:17 <Myrl-saki> > let 2 + 2 = 5; in 2 + 3
05:49:20 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
05:49:23 <Myrl-saki> Knew it.
05:49:28 <Myrl-saki> dminuoso: Redefinition of (+)
05:49:30 <wchresta> jakov: return . B.unpack ?
05:49:31 <jakov> Bytestring
05:49:31 <dminuoso> jakov: (return . B.unpack)
05:49:32 <fishythefish> jakov: depending on what you mean by nicer, you could try `pure . B.unpack`
05:49:39 <dminuoso> Myrl-saki: Oh hah.
05:49:53 <dminuoso> Myrl-saki: Completely fooled me there.
05:49:57 <Myrl-saki> dminuoso: :P
05:49:57 <jakov> thanks !
05:50:04 <Myrl-saki> dminuoso: TBF, Prelude.+
05:50:18 <Myrl-saki> > let 2 + 2 = 5; x + y = x Prelude.+ y; in 2 + 3
05:50:20 <lambdabot>  5
05:50:31 <Myrl-saki> > let 2 + 2 = 5; x + y = x Prelude.+ y; in 2 + 2
05:50:33 <lambdabot>  5
05:50:46 <c50a326> but for instance here http://www.cis.upenn.edu/~cis194/spring13/lectures/01-intro.html it tells me to expect an error like "Multiple declarations of"" but I don't get that
05:50:54 <c50a326> so did something change? if so, how and why?
05:51:09 <Myrl-saki> let x = 1; x = 2; in xc
05:51:12 <dminuoso> c50a326: No. The point is that in Haskell we *bind* a variable name to some value/expression.
05:51:13 <Myrl-saki> let x = 1; x = 2; in x
05:51:15 <Myrl-saki> > let x = 1; x = 2; in x
05:51:17 <lambdabot>  error:
05:51:17 <lambdabot>      Conflicting definitions for ‘x’
05:51:17 <lambdabot>      Bound at: <interactive>:1:5
05:51:19 <fishythefish> > 2 ＋ 3
05:51:21 <lambdabot>  6
05:51:27 <dmwit> c50a326: ghci is different in a couple ways from standard Haskell.
05:51:31 <Myrl-saki> fishythefish: What the
05:51:35 <c50a326> > x = 1; x = 2
05:51:37 <lambdabot>  <hint>:1:3: error:
05:51:38 <lambdabot>      parse error on input ‘=’
05:51:38 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
05:51:42 <fishythefish> Myrl-saki: I'm glad to see that one still gets people ;)
05:51:44 <cocreature> fishythefish: someone loves his unicode :)
05:51:50 <Myrl-saki> Okay.
05:51:52 <Myrl-saki> Uhhh
05:51:55 <int-e> > "+＋"
05:51:56 <Myrl-saki> fishythefish: Unicode to ASCII?
05:51:57 <lambdabot>  "+\65291"
05:51:58 <dminuoso> c50a326: It might be helpful to not try this in GHCi, GHCi is a bit special.
05:52:24 <dmwit> c50a326: The main one being that it acts like a big IO do block. But it also implicitly allows `let` statements without actually writing `let`, and also allows type and class declarations (which are not usually allowed in IO blocks).
05:52:31 <Myrl-saki> > ord '＋'
05:52:33 <lambdabot>  65291
05:52:36 <cocreature> > 2 + 2
05:52:39 <lambdabot>  5
05:52:44 <cocreature> I don’t even need unicode for this!
05:52:47 <c50a326> tbh ghci is the only way I know to run haskell at the moment. I tried "stack new" but that installed a bunch of shit in a directory that I didn't understand.
05:52:51 <dmwit> c50a326: If you did try to define `x` twice in a single let -- e.g. with `x=5;x=6` in ghci -- you would indeed get an error.
05:52:57 <Myrl-saki> Wtf. How did you guys redeclare it
05:53:09 <Myrl-saki> > 2 + 2
05:53:12 <dminuoso> c50a326: You can just write a plain Haskell file and use `stack ghc yourFile.hs` without a stack project directory.
05:53:14 <lambdabot>  error:
05:53:18 <lambdabot>      Ambiguous occurrence ‘+’
05:53:20 <lambdabot>      It could refer to either ‘Prelude.+’,
05:53:22 <dminuoso> c50a326: Or - if you have - just use your system GHC: ghc yourFile.hs
05:53:23 <Myrl-saki> rip.
05:53:28 <pally> I'll repaste my problem one more time, in case someone missed it
05:53:30 <c50a326> thanks
05:53:31 <dmwit> Myrl-saki: U N I C O D E
05:53:34 <cocreature> huh why did it break
05:53:37 <pally> ?let graph = [("a", ["b","c"]), ("b", ["a"]), ("c", ["a"])]
05:53:38 <lambdabot>  Defined.
05:53:44 <fishythefish> cocreature: someone probably undefined
05:53:57 <dminuoso> c50a326: Or it may sometimes be helpful to use runghc (available in system installations as well as through stack), which directly runs the code. :)
05:54:01 <pally> [["a","b"], ["a", "c"], ["b", "a", "c"], ["c", "a", b"]]  is what I want.
05:54:04 <cocreature> fishythefish: well if they had just undefined it it wouldn’t be ambiguous
05:54:09 <cocreature> I guess someone reimported prelude
05:54:12 <dmwit> c50a326: You might like https://stackoverflow.com/q/44406434/791604
05:54:17 <fishythefish> cocreature: well, I assume to play around with it themselves :P
05:54:29 <dmwit> c50a326: ("What is immutable data? Why can I write let a=123; let a=456?")
05:54:29 * hackage sql-words 0.1.6.2 - SQL keywords data constructors into OverloadedString  http://hackage.haskell.org/package/sql-words-0.1.6.2 (KeiHibino)
05:54:43 <cocreature> we’re all really bad people
05:55:16 <pally> a list of acyclic paths.  What I had in mind is to keep a visitedList during the traversal to avoid cycles.
05:55:27 <fishythefish> for more fun, start defining weird Num instance and change the defaults
05:55:49 <dminuoso> c50a326: One nice way to think about variable bindings in Haskell, is that they are statements of equalivalence/substitutability. For example `f x y = x + y` says that `f x y` can be freely substituted with `x + y` or vice versa.
05:55:50 <c50a326> cool thanks
05:56:18 <pally> by recursing on only adjacentList \\ vistedList
05:56:22 <dmwit> pally: fgl has several kinds of dfs: http://hackage.haskell.org/package/fgl-5.6.0.0/docs/Data-Graph-Inductive-Query-DFS.html
05:56:47 <cocreature> writing your own dfs for learning purposes is not a bad idea even if fgl has one :)
05:56:59 <c50a326> just writing a file with `x = 5; x` and then executing that with ghc doesn't work though, I guess I need to learn how to make haskell compile stuff
05:57:09 <dmwit> > 2+2
05:57:11 <lambdabot>  error:
05:57:11 <lambdabot>      Ambiguous occurrence ‘+’
05:57:11 <lambdabot>      It could refer to either ‘Prelude.+’,
05:57:13 <dmwit> ?undefine
05:57:13 <lambdabot> Undefined.
05:57:24 <dminuoso> c50a326: Every Haskell program requires a `main :: IO ()` which is the program.
05:57:31 <dmwit> c50a326: As I mentioned above, ghci is different from standard Haskell in several ways.
05:57:46 <dmwit> c50a326: That said, `x = 5; x` won't work in ghci, either. =)
05:57:50 <c50a326> LYAH and also many other guides don't deal with IO and all that for a good amount of time :\
05:58:07 <dminuoso> Which is a bit sad, there's nothing scary about IO.
05:58:07 <c50a326> which is pretty annoying, learning C I enjoyed that you quickly get to grips with IO
05:58:07 <dmwit> c50a326: Try this file instead: `x = 5; main = print x`
05:58:35 <c50a326> ah yeah I should define main
05:58:45 <dmwit> c50a326: If you want a quickstart on IO, I strongly recommend "The IO Monad for People who Simply Don't Care". http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
05:59:01 <ventonegro> :t interact
05:59:02 <lambdabot> (String -> String) -> IO ()
05:59:10 <merijn> dminuoso: Well, technically the () part is not required :p
05:59:13 <cocreature> I also quite like monochrome’s IO tutorial https://www.vex.net/~trebla/haskell/IO.xhtml
05:59:16 <dmwit> interact is also a cheap and cheerful way to get started.
05:59:27 <c50a326> haha people who simply don't care, sounds good
05:59:40 <dminuoso> merijn: It was an intentional lie that I considered morally acceptable. :P
06:00:15 <pally> dmwit, is it quite difficult to do w/o using that library?  This is to better help me decide
06:00:30 <dmwit> pally: No, it should be very straightforward to do yourself if you want.
06:00:32 <dminuoso> merijn: Ive come to accept that not mentioning some things can be easier.. for example its perfectly fine to not talk about levity polymorphism when beginners learn about kinds..
06:00:49 <dmwit> pally: I've done it several times when my graph-like structures couldn't easily be materialized into an fgl graph.
06:01:07 <__monty__> dminuoso: But then you get people like me who don't know what levity polymorphism is.
06:01:31 <merijn> __monty__: That's fine until way later where you go "man, I wish I could write C in Haskell" :p
06:01:39 <krokodil> Hi all! Can someone recommend a tutorial on Kmett's AD library?
06:01:52 <dminuoso> Sign up for Kmett University?
06:02:01 <dminuoso> Is that actually a thing?
06:02:14 <krokodil> dminuoso: I wish it was :)
06:02:16 <__monty__> merijn: No way that'll happen even if the multiverse thesis holds ; )
06:02:37 <krokodil> I have an OK knowledge of calculus and intuitively understand ‘AD is just chain rule’
06:02:39 <pally> dmwit, from my sample graph and description of what I want to do, can you give me some hints?  I've been stuck on this for 4-5 hours now.
06:02:43 <pally> > graph
06:02:44 <cocreature> krokodil: iirc I mostly just used the small examples in the docs to get started. anything specific you are having trouble with?
06:02:45 <lambdabot>  error: Variable not in scope: graph
06:02:57 <krokodil> But when I open the AD docs, they are so intimidating, with forward/reverse mode and whatnot
06:03:08 <dmwit> pally: Your proposed way forward sounded reasonable to me.
06:03:21 <c50a326> so `runghc` and `stack ghc` import Prelude but ghc doesn't?
06:03:34 <dminuoso> krokodil: Isnt that ad basics though?
06:03:45 <dmwit> c50a326: Why do you believe that?
06:03:50 <dminuoso> krokodil: I mean it sounds like you should be studying automatic differentiation, rather than learning the concept through his library
06:04:11 <dmwit> c50a326: (It is incorrect. But if you explain why you think it, we can help you identify the earliest mistake you made in your reasoning.)
06:04:20 <cocreature> it depends on whether you want to learn how to use the ad library or whether you want to learn how automatic differentiation works
06:04:24 <krokodil> dminuoso: Right, but I've watched a few YouTube talks on AD in general, it's just I don't know how to start with the Kmett's AD libraary
06:04:37 <krokodil> Googling for AD tutorials specifically for the library yields nothing
06:04:46 <c50a326> dmwit: I made this file like main = do\nprint "Hi" ... it works if I `runghc` or `stack ghc` it, but not if I `ghc` it (it moans that it can't find Prelude)
06:05:26 <dmwit> Could you paste the exact error, please? (Not in-channel; on a paste site, then give us a link.)
06:05:27 <dminuoso> c50a326: How did you install ghc?
06:05:42 <c50a326> sudo pacman -S ghc I think
06:05:52 <dmwit> Oh no, arch.
06:06:01 <dmwit> Everything Haskell is broken on arch.
06:06:08 <c50a326> https://lpaste.net/3638550105369346048
06:06:21 <cocreature> install ghc-static
06:06:53 <cocreature> krokodil: depending on how tied you are to using "ad" you might be interested in jle`’s backprop library  which has significantly more documentation and is also more flexible in some regards https://blog.jle.im/entry/introducing-the-backprop-library.html
06:06:58 <__monty__> Or dive in at the deep end and install nix then install a haskell environment with nix ; )
06:07:17 <dminuoso> Because learning nix in order to install haskell to learn haskell is sensible.
06:07:18 <c50a326> everyone in #haskell is famous
06:07:32 <maerwald> dminuoso: lol
06:08:29 <c50a326> well this is great my dl speed is 20kB/s and this package is massive lol
06:08:34 <dminuoso> __monty__: Though I guess the bottom-up approach can work sometimes.. I had this moment when I wanted to know "what the heck does `int main() { return 0; }` return to" let me to studying the tomasulo algorithm a month later..
06:08:37 <pally> dmwit, I will give a one more go and if I am continue to be stuck I'll come back and share my code.  The real trouble I am having right now is designing the recursion to recreate new lists
06:08:41 <dmwit> c50a326: sorry =(
06:09:04 <dmwit> pally: Sharing code is a great plan. We here in #haskell love to criticize actual code.
06:09:04 <pally> initially, I would need to give the function a starting node "a"
06:09:29 <dmwit> pally: Don't forget the criticism is out of love, though. It's not that we think you're bad at coding, it's that we want you to end the day with awesome code.
06:10:29 <pally> ["a"]-> ["a", "b"], ["a", "c"]....
06:10:41 <pally> ?let graph = [("a", ["b","c"]), ("b", ["a"]), ("c", ["a"])]
06:10:42 <lambdabot>  Defined.
06:11:18 <pally> it will give me all acycic paths that start from "a"
06:12:03 * dmwit . o O ( [('a', "bc"), ('b', "a"), ('c', "a")] )
06:12:34 <__monty__> dminuoso: My life on arch improved by using nix, just sugjesting (no typo) something that could save future grief. It's not like just getting up and running with haskell on nix is hard.
06:12:54 <dmwit> pally: Quick question: what about [('a', "bc"), ('b', "d"), ('c', "d")]? Would both "abd" and "acd" be in the result?
06:14:25 <__monty__> dminuoso: That's a deep dive indeed. I just wave my hands and say it's the exit-code you get in your shell : )
06:14:54 <pally> dmwit, you probably know that the 2nd component (`snd`) is an adjacency list, and that you should have a pair for (d, [])
06:15:12 <pally> dmwit, but yes, it's the idea
06:15:23 <c50a326> dmwit: it's okay I improved my speed by joining a wifi :0
06:15:38 <dmwit> pally: Okay. Then keeping a list of visited nodes is likely overkill. Just keep track of the node you started at and nothing more.
06:16:05 <dmwit> mmm
06:16:19 <pally> dmwit, w/o it you would have cycles.
06:16:22 <pally> remember my approach?
06:16:40 <pally> recurse on nodes that haven't been visited
06:16:40 <dmwit> I retract that. But you can throw away the list of visited nodes more often than you could otherwise.
06:16:54 <dmwit> (can/must)
06:17:19 <dmwit> Note that producing ["abd","acd"] requires visiting 'd' twice.
06:17:25 <pally> dmwit, no, because in fact the lists of visited nodes is what I want in the result
06:19:33 <pally> ?let graph = [("a", ["b","c"]), ("b", ["a"]), ("c", ["a"]), ("d", [])]
06:19:34 <lambdabot>  .L.hs:158:1: error:
06:19:34 <lambdabot>      Multiple declarations of ‘graph’
06:19:34 <lambdabot>      Declared at: .L.hs:157:1
06:19:51 <pally> ?let graph' = [("a", ["b","c"]), ("b", ["a"]), ("c", ["a"]), ("d", [])]
06:19:52 <lambdabot>  Defined.
06:20:29 <pally> I want a function that when you provide it a starting node, i'll give you a list of acyclic paths starting from that node
06:21:31 <pally> ?let graph' = [("a", ["b","c","d"]), ("b", ["a"]), ("c", ["a"]), ("d", [])]
06:21:32 <lambdabot>  .L.hs:159:1: error:
06:21:32 <lambdabot>      Multiple declarations of ‘graph'’
06:21:32 <lambdabot>      Declared at: .L.hs:158:1
06:21:34 <dmwit> Are you expecting somebody here to write it for you? Or why do you keep asking the exact same question when you already know how to make it happen?
06:23:38 <pally> I've been stuck on it, but yea I'll work on it again and hopefully it'll "happen" (heh) but if not I'll come back with broken code.
06:23:39 <catern> hmm
06:27:11 <catern> has anyone heard of such a thing as, using a singleton type, containing as its only value a single specific linearly-typed reference cell (not really a singleton type, since different states of the reference cell are different values), to represent a mutable variable with "identity"? such as a global mutable variable
06:31:12 <c50a326> ah yeah installing ghc-static worked
06:31:29 <dmwit> catern: I haven't. For whatever that's worth.
06:33:26 <merijn> catern: Yes, although you don't even need linear types for that, I think?
06:33:53 <merijn> catern: To the best of my knowledge linear types are a sort of generalisation of uniqueness types, which essentially cover what you describe
06:34:28 <merijn> catern: Clean (you know, that other lazy, purely functional language) uses uniqueness types to deal with IO, rather than monadic IO
06:36:59 * hackage persistable-record 0.6.0.4 - Binding between SQL database values and haskell records.  http://hackage.haskell.org/package/persistable-record-0.6.0.4 (KeiHibino)
06:38:06 <catern> merijn: well, as an example of the application of what I described: you could use to represent CPU registers
06:39:05 <catern> Each CPU register would have its own singleton type containing a linearly-typed reference cell
06:47:33 <catern> you couldn't do the same with a normal linear-reference-cell, because you wouldn't be accurately representing that there is only one of the thing you are working with
06:48:00 <catern> (which is really nice to represent for registers, because then you could just compile any usage down to a direct register reference...)
06:51:29 * hackage shake-ext 3.0.0.0 - Helper functions for linting with shake  http://hackage.haskell.org/package/shake-ext-3.0.0.0 (vmchale)
06:55:03 <maerwald> who else is using argon?
06:56:00 * hackage ats-pkg 2.10.2.5 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-2.10.2.5 (vmchale)
06:56:05 <c50a326> hindent and stylish-haskell moaning about last statement in a do block must be an expression
06:56:10 <c50a326> is `print x` not an expression?
06:56:40 <lyxia> it is
06:57:56 <merijn> tbh, I find most auto layout tools rather obnoxious in Haskell
06:59:55 <__monty__> maerwald: Argon2?
07:00:04 <maerwald> @hackage argon
07:00:05 <lambdabot> http://hackage.haskell.org/package/argon
07:00:15 <dminuoso> align-regexp is all you need =o
07:00:23 <__monty__> maerwald: Ah, then no.
07:01:22 <butterthebuddha> So I have some mutable state that I'd like to persist across the program, but it's only getting accessed in a single function
07:02:48 <butterthebuddha> Making that one function return a State monad isn't enough because the mutations get lost between function calls; do I _have_ to wrap all the functions in a State monad or is their.a better way of dealing with this?
07:05:12 <ij> Can I compose a lens and a prism to get a prism?
07:07:34 <c50a326> how can I learn what this hoogle stuff is all about, e.g. https://www.haskell.org/hoogle/?hoogle=getLine what is in the green? is it saying that getLine is provided by all these?
07:08:09 <simon> c50a326, yes, but some may be re-exports.
07:08:29 <fishythefish> c50a326: it's a comma separated list of entries, each of which gives you one way to access the value
07:08:35 <fishythefish> each entry is in the form <package> <module>
07:09:26 <c50a326> so Prelude and System.IO modules are in the base package
07:09:47 <fishythefish> yes, and it's available by default
07:10:04 <fishythefish> unless you've specifically messed with it, Prelude will also be automatically imported
07:10:35 <fishythefish> you can click on the module names to go to the relevant points in the docs
07:13:15 <ij> Lens could be a prism that always succeeds, so you can get a prism given a lens?
07:13:20 <c50a326> what's with hGetLine
07:13:22 <fishythefish> butterthebuddha: you shouldn't have to wrap everything in State
07:13:58 <fishythefish> butterthebuddha: if the changes to your State are getting lost, then you're probably not chaining the calls correctly
07:14:17 <fishythefish> c50a326: are you asking why it shows up in the results?
07:15:15 <c50a326> fishythefish: well mostly what the h is about... i clicked it and it said something about hdl... wondering if there's something where it uses C
07:15:28 <fishythefish> c50a326: the h just means handle
07:15:31 <butterthebuddha> fishythefish: https://lpaste.net/8349461615069888512
07:15:41 <butterthebuddha> That's what I'm doing :/
07:16:23 <quicksilver> ij: you can compose a lens and a prism, and if you do, you get a traversal
07:17:02 <quicksilver> ij: however not all lenses are prisms and not all prisms are lenses
07:17:10 <quicksilver> there is a hierarchy diagram on the lens homepage
07:17:13 <ij> ah, I thought they were strictly a subset
07:17:20 <ij> yeah, I've seen it, will take a look
07:18:28 <quicksilver> ij: a prism is a traversal which "knows when it doesn't match"
07:18:48 <quicksilver> a lense is a traversal which "focusses on at most one element"
07:19:33 <quicksilver> also prisms which do match can be turned around.
07:19:53 * quicksilver feels this is not a clear explanation ;)
07:20:26 <fishythefish> https://blog.jle.im/entry/lenses-products-prisms-sums.html
07:20:44 <ij> I felt like prisms were lenses that might not act if data's not present
07:21:16 <ij> so if prisms aren't lenses, they can act on multiple … things… idk?
07:22:34 <quicksilver> ij: well the simplest example is compare pairs and Either
07:22:38 <dminuoso> ij: prisms are the duals of lenses
07:22:44 <quicksilver> if you have (3,4) and you use a Lens to focus on the left element 3
07:22:49 <quicksilver> it's *definitely* there, right?
07:22:54 <quicksilver> all tuples have a left element.
07:22:55 <fishythefish> a lens zooms in from a "product" to one of its components; a prism goes from a "sum" to one of its components
07:22:58 <dminuoso> ij: a lens acts on product types whoe prisms act on sum types
07:23:01 <fishythefish> a product must definitely contain each of its components
07:23:03 <quicksilver> but given 3, we can't reconstruct the whole tuple.
07:23:15 <quicksilver> on the either have if you have "Left 3" and use the _Left prism
07:23:22 <fishythefish> a sum potentially contains each of its components
07:23:26 <quicksilver> obviously the _Left prism doesn't always match
07:23:28 <quicksilver> but, when it does
07:23:52 <quicksilver> you can get back from 3 to Left 3
07:23:58 <quicksilver> by reversing the prism
07:24:32 <quicksilver> > 3 ^. re _Left
07:24:34 <lambdabot>  Left 3
07:24:58 <ij> ha! now I see why it could be called a dual
07:25:13 * quicksilver nods
07:26:01 <fishythefish> butterthebuddha: if you're talking about losing state between iterations of "loop", that's to be expected
07:26:38 <fishythefish> each time rep is invoked, it starts with the same replEnv initial state
07:26:38 <butterthebuddha> Hence, I thought I'd have to wrap the loop and the intermediate calls in State
07:27:04 <fishythefish> sure, anything that needs to persist the state needs to be wrapped
07:27:12 <fishythefish> but you could also have parts of your program that don't care about the state at all
07:28:18 <butterthebuddha> again, that's why I was trying to get around wrapping the whole thing in State
07:29:38 <fishythefish> butterthebuddha: you have main :: IO () even though main eventually calls things that run outside of IO, right? same deal
07:39:09 <mreh> angerman, sorry to keep bugging you, but I'm still getting an error that math.h is missing
07:39:09 <mreh> https://pastebin.com/raw/gwyK6wVP
07:39:41 <edmundnoble> butterthebuddha: Stop using state, plumb the values around yourself. That will illustrate what is going wrong here.
07:39:42 <ij> How could I (do an action|print) all the _Lefts of a linked list?
07:39:51 <mreh> I think this falls outside of my knowledge
07:40:21 <mreh> ij, as in Lefts from Either?
07:40:24 <ij> Yeah.
07:40:32 <mreh> :t either
07:40:33 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
07:40:42 <mreh> ij, give you a clue?
07:41:00 <fishythefish> :t lefts
07:41:01 <lambdabot> [Either a b] -> [a]
07:41:03 <geekosaur> they want lens combinators, if I read _Left correctly
07:41:18 <angerman> mreh: Math.h comes from the NDK. So there‘s likely something wrong with the -I or -isystem flags passed.
07:41:25 <mreh> geekosaur, gotcha
07:41:31 <kangra> HOw will you compute stable fixed point for x=x+1/x in haskell?
07:41:39 <ij> mreh, geekosaur, Yup :), because the type's different and I want to preserve the other halfs
07:41:45 <ij> halves*
07:41:52 <fishythefish> kangra: x = _|_, done
07:42:19 <mreh> angerman, yeah I thought so, NDK seems to be set up correctly now
07:43:36 <mreh> ANDROID_NDK=$HOME/Android/Sdk/ndk-bundle
07:44:01 <kangra> fishythefish: could you elaborate ? thanks
07:44:11 <mreh> installed with Android studio this time
07:44:23 <fishythefish> > let x = x + 1/x in x -- kangra
07:44:26 <lambdabot>  *Exception: <<loop>>
07:44:51 <fishythefish> but I can already tell you that'll result in bottom since `x + 1/x` is strict in x
07:45:28 <kangra>  fishythefish: >  I ll cross check anyway  and post again . Thanks for the help yet
07:48:43 <TornjV> a
07:50:44 <pally> The following is a common description for foldr:
07:51:31 <pally> > foldr f z []     = z
07:51:32 <pally> > foldr f z (x:xs) = x `f` foldr f z xs
07:51:34 <lambdabot>  <hint>:1:18: error:
07:51:34 <lambdabot>      parse error on input ‘=’
07:51:34 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
07:51:34 <lambdabot>  <hint>:1:18: error:
07:51:35 <lambdabot>      parse error on input ‘=’
07:51:36 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
07:51:54 <quicksilver> unfortunately recursion produces the *least* fixed point, kangra / fishythefish
07:52:46 <fishythefish> quicksilver: this is true, but the question did say "in haskell", and that's what `fix` does in haskell
07:53:23 <fishythefish> if we're looking for a numeric fixed point, we need to talk about what the domain is, since x = x + 1/x doesn't have a solution in the reals
07:53:24 <pally> why does `x` appear before ``f``
07:53:37 <fishythefish> pally: x `f` y is the same as f x y
07:53:42 <dminuoso> ij: For a cool way to see how one is the dual of the other, one (old and antiquated) way to think of a lens is: data Lens s t a b = Lens { view :: s -> a, update :: b x s -> t }, whereas the same (old and antiquated) way to think of a lens is: `data Prism s t a b = Prism { match :: s -> t + a, build :: b -> t }`
07:54:00 <dminuoso> (Using some pseudo code to make sum and product types a bit more obvious)
07:54:53 <fishythefish> pally: you know how you can wrap an infix operator in parentheses to make it a standard prefix function? similarly, you can wrap a function name in backticks to make it infix
07:55:45 <pally> yes, I know one can wrap an infix with parens and make it a standard prefix function.
07:56:10 <Boomerang> > 10 `div` 3
07:56:11 <quicksilver> fishythefish: well ignoring the fact that the particular equation doesn't have solutions in R, haskell is a pretty neat language for finding numerical fixed points - it was one of the examples in "why functional programming matters" I think
07:56:12 <lambdabot>  3
07:59:36 <mreh> angerman, I was editing the wrong file... linux-android-toolchain.config instead of android-toolchain.config
07:59:38 <fishythefish> @let fix' f x = let y = f x in if x == y then x else fix' f y
07:59:39 <lambdabot>  Defined.
07:59:54 <fishythefish> > fix' (\x -> x + 1 / x) 1
08:00:00 <lambdabot>  mueval-core: Time limit exceeded
08:00:16 <fishythefish> > fix' (\x -> 1 / x) 2
08:00:22 <lambdabot>  mueval-core: Time limit exceeded
08:00:47 <fishythefish> still need to choose a function/starting guess appropriately
08:04:51 <byorgey> fishythefish: you probably also don't want to use == on floating-point numbers
08:05:29 <fishythefish> byorgey: yup, but i'll leave the question of finding an appropriate definition of equality as an exercise for the reader :P
08:06:24 <fishythefish> still, you can always just evaluate to machine precision
08:06:28 <fishythefish> > fix' (\x -> (x + 7 / x) / 11) 1234
08:06:30 <lambdabot>  0.8366600265340755
08:07:52 <Taneb> > fix' (\x -> 1 + (1 / x)) 1.5
08:07:55 <lambdabot>  1.618033988749895
08:08:08 <Taneb> > (1 + sqrt 5) / 2
08:08:10 <lambdabot>  1.618033988749895
08:08:12 <Taneb> :)
08:08:55 <dmwit> > let x = 0.8366600265340755 in 11*x^2 - x
08:08:58 <lambdabot>  6.863339973465923
08:10:05 <dmwit> > sqrt (7/10)
08:10:07 <lambdabot>  0.8366600265340756
08:11:51 <dminuoso> ij: Or, if its a simple lens/prism: data Lens' = Lens' { view :: s -> a, update :: a x s -> s }; data Prism' = Prism { match :: s -> s + a, build :: a -> s}
08:14:08 <quicksilver> right, agreed with all that, and 'why functional programming matters' has some good discussions around it :)
08:18:30 * hackage csa 0.1.0 - Connection-set algebra (CSA) library  http://hackage.haskell.org/package/csa-0.1.0 (jegp)
08:26:08 <Psybur> Is it possible to sink to a file that is also a source using conduit? Im getting a file locked error
08:26:55 <geekosaur> think about it.
08:27:44 <fendor> good morning, i want to change the color of a bitmap on demand, for gloss. The initial image is given as a png file. But i have no idea how that shall be done. I could load it from file, convert it to friday image, then apply threshold operation, and then convert it to a bitmap and then somehow load it from in-memory
08:28:12 <Psybur> @geekosaur, I think theres a way to access the file handle? Maybe I could close it before sinking
08:28:12 <lambdabot> Unknown command, try @list
08:28:30 <geekosaur> conduits are concurrent, aren't they?
08:28:41 <geekosaur> you'd be overwriting the data you intend to read
08:29:22 <Psybur> Ah good point
08:29:35 <Psybur> It doesnt read everything into memory
08:30:07 <Solonarv> if you can force the entire file into memory (or collect the entire output before sinking any of it), you can use the same file
08:30:14 <geekosaur> right, the whole point of conduit was to do lazy IO in a principled way that lets you e.g. deal with errors (readFile just swallows them)
08:30:20 <Cale> It's typically considered better practice to write to a new file, and then move the new file over the old once finished. Most filesystems will treat the move as an atomic operation.
08:30:40 <Psybur> I guess my plan of making a recursive sed -i isnt a task well suited for conduit :D?
08:31:13 <geekosaur> you can read it into a buffer and then use conduit-lazy to lazily process the buffer, iirc
08:31:27 <dminuoso> When partially applying the second argument, is sections the concise way to do it? (`f` 3)
08:31:29 <Solonarv> you can still use conduit with a temp file
08:31:32 <geekosaur> but the right answer is process to temp file and rename only on success
08:31:40 <dminuoso> Or is there some some common idiom with a combinator?
08:31:41 <geekosaur> what do you intend to do if something goes wrong partway through?
08:32:05 <Solonarv> you can also do (flip f 3) but infix + section is cleaner IMO
08:32:19 <fishythefish> dminuoso: sections are most common in my experience, but there's flip
08:32:21 * geekosaur always does write to temp file, rename orig to backup, rename temp to old name
08:32:31 <geekosaur> ...sysadmin paranoia
08:33:10 <fishythefish> worked with a guy who aliased rm to just mv to a trash folder, which he'd periodically verify before actually deleting
08:33:12 <dminuoso> fishythefish: I rather meant.. would you alias flip to some operator?
08:33:34 <dminuoso> `flip` is some noise and `flip x z` is less obvious
08:33:39 <fishythefish> dminuoso: imo you're not saving enough characters for this to be worth it
08:34:33 * JuanDaugherty is reminded of that scene in the movie Brazil in re source and sink the same 
08:34:45 <Solonarv> thinking about this I realize that I just don't like flip
08:34:47 <Solonarv> it makes me think
08:34:51 <Solonarv> I don't like having to think
08:35:04 <quicksilver> I don't really like sections for partially applying second argument unless it's a function with exactly two arguments which I habitually use infix
08:35:33 <Solonarv> so what do you use instead? flip? a lambda?
08:35:37 <quicksilver> for (longFunc x y z) I'd use (\x z -> longFunc x y z) -- second arg now fixed
08:35:41 * JuanDaugherty human centipede more recently
08:35:56 <quicksilver> whether I would ete-reduce the z would depend on my mood
08:36:02 <fishythefish> i'm pretty much with quicksilver on this one
08:40:22 <dminuoso> Fair enough. I guess sections
08:45:21 <mikelui> Is there syntax to import hierarchical modules of the same root, in the same line? I'm thinking similar to Rust's use declarations.
08:45:42 <mikelui> In rust I can do `use std::option::Options::{Some, None}
08:46:11 <mikelui> Can I do something like `import Data.{List,Text}`, or do I need a new import for each?
08:46:16 <Taneb> mikelui: you mean somthing like "import Data.Functor.{Sum, Product}"? Sadly, that doesn't exist
08:46:21 <Taneb> You'll need a new import for each
08:46:43 <mikelui> Oh well. Thanks
08:47:16 <Cale> heh, sometimes more than one import line per module.
08:47:23 <Cale> import Data.Map (Map)
08:47:30 <Cale> import qualified Data.Map as Map
08:48:03 <Cale> It would be nice if we could at least reduce things like that to one line.
08:48:21 <Boreeas> Hey, if I have a function 'f :: a -> m b' and a function 'g :: b -> c', is there a way to compose them (h :: a -> m c) point-free? I.e. not 'g <$> f x', but 'g <???> f'? Couldn't find anything on hoogle
08:49:05 <Cale> I don't know about trying to compress it further still... it might be better just to allow qualified re-export, so that modules which are commonly used throughout a project could be imported in one place and then re-exported from there.
08:49:46 <quicksilver> I think qualified re-export and re-named re-export would be really useful convenience features
08:49:46 <Cale> fmap g . f
08:53:17 <dmwit> Boreeas: Besides Cale's suggestion, you can use `(g<$>) . f` if you prefer `(<$>)` to `fmap`.
08:55:36 <rotaerk> I would choose between fmap and <$> based on whichever eliminates parentheses in a given context
08:55:49 <rotaerk> rather than deciding one is universally preferable over another
08:56:28 <Cale> I almost always use fmap, and basically change to <$> when I'm also using <*> nearby
08:57:06 <Cale> But that's mostly because I forget that <$> exists a lot of the time :)
08:57:25 <rotaerk> if I'm doing:  fmap f $ g, I would just prefer to do f <$> g
08:57:58 <Cale> I'd prefer fmap f g, but I know what you mean ;)
08:58:00 <__monty__> I lean towards using <$> because it resembles $ more. fmap is too magical viz. `fmap fmap fmap`.
08:58:13 <Cale> huh?
08:58:24 <stilgart_> :t fmap fmap fmap
08:58:26 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
08:59:02 <quicksilver> I lean towards using <$> because of something vaguely like consistency with not just $ but also <$ $> <*> <* and *>
08:59:08 <Boreeas> Cale, dmwit: Thanks!
08:59:37 <Solonarv> Cale: there's this thing https://theam.github.io/require/
08:59:41 <Boreeas> (I went with fmap, because I dislike how partially applied infix operators look)
08:59:59 <mreh_> Boreeas, sections?
09:00:13 <Cale> stilgart_: Yeah, I know about that, but (<$>) is exactly the same
09:00:23 <Boreeas> mreh_: sorry?
09:00:29 <Cale> :t (<$>) (<$>) (<$>)
09:00:30 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
09:00:41 <Taneb> :t (.) . (.)
09:00:43 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
09:00:47 <Solonarv> @source <$>
09:00:48 <lambdabot> Unknown command, try @list
09:00:50 <mreh_> oh guys!
09:00:52 <Solonarv> @list <$>
09:00:52 <lambdabot> No module "<$>" loaded
09:00:54 <Solonarv> grrr
09:01:00 <mpickering> Does anyone know a package which just depends on base?
09:01:16 <mreh_> Boreeas, this kind of thing? (+ 1)
09:01:17 <Taneb> mpickering: groups
09:01:39 <Cale> Solonarv: That's sort of cute, though usually I would want Text imported as T, and ByteString imported as BS, etc.
09:02:01 <Boreeas> mreh_: Aye. Tolerable for arithmetic operators, I guess, but (g <$>) just looks weird
09:02:15 <Solonarv> that link was posted on /r/haskell about a month ago, I think there was some discussion about that in the thread
09:02:29 <Solonarv> https://redd.it/8lltl4
09:02:44 <Cale> Solonarv: I was thinking of having a syntax something like:  import Data.ByteString (ByteString) qualified as BS
09:02:56 <Solonarv> yeah, that would be nice
09:03:40 <Cale> Also, it's annoying that qualified occurs on the left of the module name anyway :P
09:03:46 <Taneb> mpickering: why do you ask?
09:03:51 <mpickering> Taneb: Thanks, perfect
09:04:12 <mpickering> I'm testing some nix scaffolding for running plugins but my plugin only works with HEAD
09:04:19 <mpickering> so I can't run it on most packages as they fail to compile
09:05:03 <mreh_> angerman, (sorry, I'm so not a systems programmer), I'm getting undefined reference to libiconv now
09:05:06 <mreh_> emo.a(iconv.o):libraries/base/cbits/iconv.c:function hs_iconv_open: error: undefined reference to 'libiconv_open'
09:05:06 <mreh_> ../../../../hs-libs/armeabi-v7a/libHSmeetupdemo.a(iconv.o):libraries/base/cbits/iconv.c:function hs_iconv: error: undefined reference to 'libiconv'
09:05:06 <mreh_> ../../../../hs-libs/armeabi-v7a/libHSmeetupdemo.a(iconv.o):libraries/base/cbits/iconv.c:function hs_iconv_close: error: undefined reference to 'libiconv_close'
09:05:06 <mreh_> ../../../../hs-libs/armeabi-v7a/libHSmeetupdemo.a(PrelIOUtils.o):libraries/base/cbits/PrelIOUtils.c:function localeEncoding: error: undefined reference to 'locale_charset'
09:05:14 <Taneb> I tried to make groups as easy to compile as possible, let me know if anything goes wrong with it unexpectedly
09:05:17 <glguy> mreh_: No, don't paste like that to the channel, use a pastebin
09:05:30 <mreh_> glguy, I thought 3 lines was okay
09:05:36 <mreh_> +1
09:06:27 <mpickering> Well it compiles fine, but my plugin didn't work ;)
09:07:08 <__monty__> Cale I like the position of qualified, it's clearer, especially when using alignment.
09:07:36 <Cale> I don't like aligning module names :)
09:07:39 <mreh> The dudes over at Keera implied in a blog post that they were going to release their tools for bundling up Haskell for mobile some time last year, I just wish there was a nice platform to get things working
09:08:13 <mreh> I was thinking about eta, but I have no idea about graphics with Java
09:08:51 <mreh> would I have to use some Java interop to use OpenGL bindings?
09:10:21 <Cale> mreh: Have you looked at Obelisk / reflex-platform at all?
09:10:45 <mreh> Cale, yeah briefly, I was kinda bummed it tied you to reflex
09:10:50 <Cale> It doesn't
09:11:03 <mreh> Cale, great!
09:11:22 <mreh> > Obelisk provides an easy way to develop and deploy your Reflex project as web apps and as mobile apps.
09:11:24 <lambdabot>  <hint>:1:103: error:
09:11:24 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:11:28 <mreh> doesn't really say that
09:11:46 <Cale> Yeah, it's just assumed that you probably want to use reflex-dom, because that's so much nicer than not doing so :P
09:11:56 <mreh> I forgot lambdabot parses 4chan greentext
09:12:24 <mreh> Cale, I want to port a Yampa project to android
09:12:31 <Cale> ah, okay
09:13:35 <mreh> I'm pretty close to using the method where you cross compile your haskell as a C lib and compile it with the android SDK that I know Keera use
09:14:07 <mreh> they just never released it, but others have done work indepently of them and open sourced it
09:18:27 <iron_houzi> I'm trying to make my parser an instance of Monad and therefore need instance of Applicative, which is causing the following error: https://gist.github.com/ironhouzi/64057101f29a90884e2d4e693e72e2b7. Can someone please walk me through the error? As I see it, I'm conforming to the type signature of `ap`, but something is wrong with my understanding..  My code:
09:18:28 <iron_houzi> https://github.com/ironhouzi/hstib/blob/tib_monad/src/Main.hs#L33
09:19:29 <Cale> mreh:  https://github.com/obsidiansystems/android-activity  might be relevant to you
09:19:30 * hackage cl3-hmatrix-interface 1.0.0.1, cl3-linear-interface 1.0.0.1, cl3 1.0.0.2 (nwaivio)
09:20:10 <fishythefish> iron_houzi: you can always just define `(<*>) = ap`; that being said, do you still want the explanation?
09:20:27 <geekosaur> iron_houzi, f and p are both functions and have to be applied to something. note the "Probable cause"
09:20:50 <mreh> Cale, thanks, I'll have a look
09:20:51 <iron_houzi> fishythefish: Yeah .. I thought making my own ap would be a good excercise
09:21:23 <iron_houzi> geekosaur: hmm .. thanks, I'll see if that will help ..
09:21:47 <fishythefish> iron_houzi: here's a subexercise: without looking at the error, what should the types of `f` and `p` be?
09:22:27 <iron_houzi> hmm
09:22:33 <Cale> mreh: tbh, I'm not 100% familiar with all the details of how it works or how to use it separately from reflex-platform :)
09:23:07 <Cale> mreh: But there's a bunch of hopefully-useful code there :)
09:24:00 * hackage parsix 0.1.0.2 - Parser combinators with slicing, error recovery, and syntax highlighting  http://hackage.haskell.org/package/parsix-0.1.0.2 (OlleFredriksson)
09:28:43 <iron_houzi> fishythefish: `f` should have the type `a -> b` and `p` should have the type `b` .. is this too generic?
09:29:04 <fishythefish> iron_houzi: that's incorrect. What's the type of (<*>)?
09:29:32 <iron_houzi> fishythefish: Monad m => m (a -> b) -> m a -> m b
09:29:56 <fishythefish> Well, we can weaken that to Applicative, but in any case, let's specialize to Parser
09:30:26 <fishythefish> (<*>) :: Parser (a -> b) -> Parser a -> Parser b
09:30:27 <iron_houzi> OK: Parser (a -> b) -> Parser a -> Parser b
09:30:32 <hastuur> anyone doing web with hask?
09:30:32 <iron_houzi> yea
09:30:50 <hastuur> any video games in hask?
09:30:55 <fishythefish> so (Parser f) :: Parser (a -> b) and (Parser p) :: Parser a
09:31:03 <fishythefish> given the definition of Parser, what are the types of f and p, iron_houzi?
09:31:23 <maerwald> in hask?
09:31:32 <hastuur> haskell
09:31:51 <maerwald> ah, not really, except toy projects
09:31:55 <maerwald> wrt games
09:32:11 <fishythefish> people frequently get scolded for trying to do things in hask :P
09:32:23 <hastuur> oracle is cancer
09:32:28 <hastuur> wish haskell replace java
09:32:36 <maerwald> it never will
09:32:46 <hastuur> why? the jews?
09:32:52 <maerwald> errr???
09:32:58 <fishythefish> odd jump in reasoning there
09:33:35 <fishythefish> they fulfill fundamentally different niches - java is write once, run anywhere; haskell is rewrite every 5 minutes, run never
09:33:39 <geekosaur> hastuur, suggest you keep that kind of talk out of this channe
09:34:06 <iron_houzi> fishythefish: f :: [(a -> b, [Letter])], p :: [(a, [Letter])] .. correct?
09:34:21 <fishythefish> iron_houzi: better :)
09:34:33 <iron_houzi> but ..?
09:34:37 <fishythefish> so now it's clear why your initial attempt didn't make sense, right?
09:34:52 <iron_houzi> wait, it's correct?
09:35:01 <fishythefish> yup, those are the right types
09:35:06 <fishythefish> oh
09:35:08 <fishythefish> sorry, no
09:35:12 <fishythefish> i glossed over a piece
09:35:25 <fendor> what is the best way in haskell to play a sound? e.g. a song within gloss?
09:35:56 <fishythefish> iron_houzi: expand the type `Parser a`
09:36:10 <fishythefish> into its RHS from the definition
09:36:17 <iron_houzi> RHS?
09:36:20 <fishythefish> right hand side
09:36:31 <fishythefish> then compare that with `p` and see what you're missing
09:37:19 <humanoyd> Does `cabal new-build` help with the situation on Arch Linux? I.e. does it ignore the haskell-* packages installed via pacman?
09:37:26 <Gurkenglas> fendor, if you use the IO variant of the gloss interface, you can plug in any library that provides IO actions which play sound
09:37:45 <maerwald> humanoyd: just don't use the package manager for ghc
09:37:51 <fendor> Gurkenglas, we are, any recommendations in particular?
09:38:43 <Gurkenglas> Not cached in my memory, but I can google around. https://wiki.haskell.org/Applications_and_libraries/Music_and_sound was made Nov 2015
09:40:00 <geekosaur> there are packages for music and sound, but mostly for composing/generating same
09:40:29 <geekosaur> for just playing a sound, not so much — partly because there's no consistency across OSes (or even e.g.Linux distributions, necessarily)
09:40:56 <humanoyd> maerwald: so `cabal new-build` doesn't help? :)
09:41:36 <geekosaur> only up to a point. if the environment is hosed enough then nothing will help, really
09:41:41 <fendor> i want to play sound for a small game, using gloss, would ALUT work reliably?
09:41:54 <geekosaur> unless you do what stack does on arch which is install all its own everything and forcibly exclude the entire OS
09:41:57 <Gurkenglas> fendor, https://hackage.haskell.org/package/proteaaudio-0.7.0.1/docs/Sound-ProteaAudio.html last updated 2017. Speak, if this tier of support is insufficient.
09:42:04 <fendor> geekosaur, we dont need to support every environment ;D but some linux distros and windows would be enough
09:42:59 <Gurkenglas> (That was ambiguous. "Speak, if you think me looking further and reporting results is unlikely to help.")
09:43:00 * hackage bdcs-api 0.1.3 - BDCS API Server  http://hackage.haskell.org/package/bdcs-api-0.1.3 (clumens)
09:43:58 <fendor> Gurkenglas, i would be in interested in anything you can dig out for playing some sounds! The library you just posted seems promising, looking into it right now
09:44:26 <Gurkenglas> fendor, if this is for a game, say so, I would expect that to help it finding something compatible with you
09:44:29 <humanoyd> geekosaur: is it possible to make `cabal new-build` do that? ("install all its own everything and foricbly exclude the entire OS")
09:44:31 <Gurkenglas> *help in
09:44:42 <geekosaur> humanoyd, no, that's not its job.
09:44:46 <iron_houzi> fishythefish: Parser a :: Parser ([Letter] -> [(a, [Letter])])
09:44:59 <fendor> Gurkenglas, sorry, i thought, gloss would be enough ^^
09:45:00 <fishythefish> iron_houzi: right, so what's the type of p?
09:45:12 <fendor> * mentioning gloss
09:45:12 <humanoyd> geekosaur: thanks
09:45:20 <iron_houzi> fishythefish: So p :: [Letter] -> [(a, [Letter])]
09:45:49 <Gurkenglas> (And you failed, you responded to that line when you were interested in my results.)
09:46:18 <Gurkenglas> fendor, that is ambiguous. Did you hope mentioning gloss to make clear that you're doing game dev or that you're not doing game dev?
09:46:54 <Gurkenglas> I agree that a game dev should have available an interface as least as convenient as that which gloss provides.
09:47:16 <Solonarv> hastuur: a bit late, but I'm making a game in haskell using sdl2 + apecs
09:47:41 <fishythefish> iron_houzi: yup, and similarly, what's the type of f?
09:47:55 <Gurkenglas> fendor, https://wiki.haskell.org/Game_Development mentions http://hackage.haskell.org/packages/#cat:Sound
09:48:33 <iron_houzi> fishythefish: f :: [Letter] -> [(a -> b, [Letter])]
09:48:37 <fendor> that i am doing game dev ^^
09:48:50 <fishythefish> iron_houzi: okay, so now it's hopefully clear why your definition of (<*>) didn't work
09:49:48 <fishythefish> iron_houzi: you want to produce a Parser _ where _ :: [Letter] -> [(b, [Letter])]
09:50:23 <iron_houzi> fishythefish: Thank you, let me see if I can figure it out
09:50:36 <fendor> Gurkenglas, problem with these wiki pages is, that they are often outdated
09:50:57 <Solonarv> which is why you were also linked to the hackage page
09:51:02 <Solonarv> that one isn't outdated
09:51:26 <Gurkenglas> One definition of "game" might be 'f such that "f Graphics.Gloss.Interface.IO.Game.playIO" has type IO ()'. Does anyone see better-fitting variants? In particular, concrete not-as-yet-existent variants of playIO seem like a good answer.
09:52:13 <Gurkenglas> (For example, such a variant might come with batteries for sound and networking)
09:52:21 <Solonarv> I haven't done sound yet, but I found sdl2 quite pleasant to use; I'd expect sdl2-mixer to be similarly pleasant
09:52:33 <mpickering> Taneb: https://imgur.com/HUihQep - generated by "haskell.lib.addPlugin plugins.graphmod packages.groups"
09:52:36 <mpickering> Thanks for your suggestion
09:53:25 <Gurkenglas> To be clear, I'm not asking you to implement variants of playIO, only to name their properties, like I do in my previous line)
09:53:39 <Gurkenglas> -)+.
09:53:46 <fendor> Solonarv, is it possible to use sdl2 in combination with gloss? Because we currently cant rewrite the game to use sdl2 :D
09:54:49 <fendor> Gurkenglas, i dont get the question, you want me to name properties of playIO?
09:54:51 <Gurkenglas> Perhaps we should implement a middleware library which merely defines the interface a game developer should have. Backpack could then plug batteries into it.
09:55:12 <Gurkenglas> fendor, no. The question to the general channel is to describe the interface a game dev should have available.
09:55:40 <Solonarv> yeah, sdl2-mixer just lives in MonadIO m => m
09:55:45 <Solonarv> if you can run IO, you can use sdl2-mixer
09:56:09 <fendor> Solonarv, yes, i can run io, then i will look also look into that :)
09:56:36 <Solonarv> hackage docs seem to be broken (maybe because it uses code generation), so use stackage instead
09:56:47 <Solonarv> https://www.stackage.org/package/sdl2-mixer
09:56:55 <Gurkenglas> playIO is a start, but 1. features such as sound and networking are not integrated and 2. Its monadic interface has not been generalized in the MonadIO direction.
09:58:00 <dreamer_> yo
09:58:31 <Gurkenglas> An analogue to haskell-ide-engine. In fact, perhaps we should instead build haskell-engine-engine :3
09:58:47 <dreamer_> if I'm using stack is it possible to mod a package and tinker with its source
09:58:50 <Solonarv> yes
09:58:56 <dreamer_> as in https://www.reddit.com/r/haskell/comments/1g1jjd/can_i_use_gloss_interactively_in_ghci/
09:59:02 <dreamer_> nice
09:59:10 <Solonarv> have you looked at the stack docs? they have a section about that, IIRC
10:00:07 <dreamer_> wow, way easier than expected
10:00:08 <dreamer_> thanks
10:00:10 <Gurkenglas> I suppose it could be a little late for haskell-game-engine, considering the existence of the likes of http://hackage.haskell.org/package/helm
10:00:45 <dreamer_>  helm is okay but really hard to compile on windows
10:02:00 <Solonarv> you could look at https://github.com/keera-studios
10:02:23 <Solonarv> I haven't used their stuff myself, though
10:03:00 * hackage constaparser 0.1.0.1 - Parse ByteStrings of a prescribed length.  http://hackage.haskell.org/package/constaparser-0.1.0.1 (chessai)
10:04:08 <dreamer_> god those guys they said they would release
10:04:18 <dreamer_> their android engine and toolchain
10:04:19 <dreamer_> never did
10:04:23 <dreamer_> I cry every day
10:04:42 <nitrix> Are contravariant functors necessarily functions or types wrapping functions?
10:04:48 <nitrix> What are the other use cases?
10:05:21 <Solonarv> the type parameter can also be phantom, as in `Const c`
10:07:29 * hackage non-empty-containers 0.1.1.0 -   http://hackage.haskell.org/package/non-empty-containers-0.1.1.0 (andrewthad)
10:08:39 <fendor> Gurkenglas, helm does not seem to be updated anymore
10:09:36 <fendor> Gurkenglas, also, it has no support for sound, you can not implement a loading screen, loading of resources must be before rendering
10:10:24 <dreamer_> yeqh
10:10:28 <Gurkenglas> Ah. I merely saw that there are libraries which specialize in game dev and concluded that they are competent.
10:10:29 <dreamer_> I d rather use gloss
10:11:12 <fendor> Gurkenglas, unfortantely, not yet
10:11:18 <dreamer_>  making sound work is a pain in haskell too...
10:11:36 <dreamer_> easiest combo is openal + alut but on windows
10:11:45 <Gurkenglas> Hm, what would be a good interface for sound?
10:11:49 <dreamer_> its reaaallly anoying
10:12:10 <dreamer_> so you just end up using raw openal
10:12:29 * hackage siggy-chardust 1.0.0 - Rounding rationals to significant digits and decimal places.  http://hackage.haskell.org/package/siggy-chardust-1.0.0 (philderbeast)
10:12:43 <Gurkenglas> (world -> ((Time ~> (Frequency, Amplitude)) -> (Time ~> (Frequency, Amplitude)))), as a parallel to (world -> Picture)
10:12:45 <dreamer_> Well haskell is awesome if yo ufocus on sound
10:12:52 <dreamer_> like the super collider and csound libs
10:12:55 <dreamer_> are really nice
10:13:04 <dreamer_> but they're not adapted for games
10:13:21 <Gurkenglas> There would be playWav :: FilePath -> (Time ~> Frequency, Amplitude)
10:13:22 <fendor> gloss is the most flexible, due to the IO monad, other are either more high level but have fewer features, or really basic
10:15:08 <Gurkenglas> One could add (Frequency, Amplitude) to play sounds at the same time, and (Time ~> _) would be a functor
10:16:02 <fendor> Gurkenglas, proteaaudio seems to work!
10:16:12 <fendor> do you have any idea if it also works on windows?
10:16:22 <Gurkenglas> i do not
10:16:28 * hackage detour-via-sci 1.0.0, detour-via-uom 1.0.0 (philderbeast): https://qbin.io/devon-crap-qzlf
10:16:37 <Gurkenglas> it claims to
10:17:34 <dreamer_> I can try
10:17:37 <Gurkenglas> The github page has no issues from which one might have deduced a windows user experience
10:17:44 <fendor> dreamer_, that would be nice!
10:17:54 <fendor> Gurkenglas, maybe it just has no users? :P
10:20:35 <Gurkenglas> gloss does not use the likes of MonadIO because it uses other libraries which also do not use the likes of MonadIO, right?
10:21:55 <Gurkenglas> Perhaps gloss should parametrize its implementation on what it uses, so that someone might implement a variant of what it uses which can be plugged in there
10:21:57 <c50a326> hey I've just read this http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html and actually I'm pretty confused
10:22:06 <c50a326> is it just that a command is something that's in a do block, and an expression is...
10:22:12 <fendor> Gurkenglas, no clue
10:22:16 <c50a326> Well, what's an expression? And what's a command? I don't get it
10:23:04 <Gurkenglas> c50a326, "IO ()" is the type of that which the haskell compiler can turn into an executable
10:23:23 <nowhereman_> I've written a `maxSnd (a1, b1) (a2, b2) = if b1 > b2 then (a1, b1) else (a2, b2)` to test a couple on its second member and keep the whole couple
10:23:46 <nowhereman_> Is there a way to write that with a simple composition of existing functions, with lenses maybe?
10:23:52 <geekosaur> c50a326, that's kinda the point, tbh. I dislike things like that page because they generally just make things more confusih
10:24:00 <geekosaur> confusing
10:24:17 <lyxia> @pl maxSnd (a1, b1) (a2, b2) = if b1 > b2 then (a1, b1) else (a2, b2)
10:24:17 <lambdabot> maxSnd = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip (,) . (((.) . ap) .) . ap (flip . (if' .) . (>)) . (,))
10:24:59 <geekosaur> in haskell, everything is either a declaration or an expression. but when doing "procedural-like" things it is sometimes nice to be able to pretend that there are "commands"/"procedures". "do" does this by turning things that look like "commands" into the expressions that Haskell expects
10:25:07 <geekosaur> @undo do { a; b; c }
10:25:07 <lambdabot> a >> b >> c
10:25:15 <nowhereman_> lyxia: I would hope we can do better :-)
10:25:42 <c50a326> it seems like it's impossible to just try to define and give some simple examples of what "expressions" and "commands" are
10:25:50 <c50a326> I mean can somebody not give me a simple answer
10:25:57 <lyxia> nowhereman_: maybe you can use Arg instead of a tuple
10:25:58 <Solonarv> let's see...
10:26:05 <lyxia> nowhereman_: https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Semigroup.html#t:Arg
10:26:07 <nowhereman_> c50a326: there is no command in Haskell
10:26:09 <Solonarv> @hoogle Ord b => (a -> b) -> a -> a -> a
10:26:10 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
10:26:10 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
10:26:10 <lambdabot> Data.GI.Base.ShortPrelude (.) :: (b -> c) -> (a -> b) -> a -> c
10:26:17 <geekosaur> the simple answer is the page is lying to you. there;s no such thing as a "command in haskell
10:26:26 <Solonarv> okay, that didn't help...
10:26:29 <iron_houzi> fishythefish: I certainly see why my attempt is incorrect, but I am still stuck with trying to make my own <*> .. The difficulty seems to stem from the inability to "peal" the monad off of the value. Any hint?
10:26:32 <c50a326> okay so what is an expression?
10:26:55 <Gurkenglas> Your Haskell program should compute a "IO ()" value for the compiler to use. The standard library provides the value "putStrLn" of type "String -> IO ()", which you can use to compute a simple "IO ()" value, by defining the "main" that the compiler looks for as the application of "getLine" to the String "Hello, World!", using the syntax 'main = print "Hello, World!".
10:27:26 <Gurkenglas> -"getLine"+"putStrLn" <.<
10:27:34 <nowhereman_> c50a326: an expression is anything that has a value
10:27:40 <Gurkenglas> -"print"+"putStrLn" (whats wrong with me)
10:27:51 <c50a326> nowhereman_: how do you know when something "has a value" ?
10:28:37 <iron_houzi> I want to peel off the output of Parser (a->b) (i.e `f`) to just return (a->b) and apply that to the result of `p` ..
10:29:07 <nowhereman_> c50a326: you build the notion recursively, in your head and in the language
10:29:08 <Gurkenglas> The standard library also provides the value "getLine" of type "IO String", and a function which can combine values like getLine with values like putStrLn, which in this case would produce the "IO ()" which the compiler turns into that executable which, when it is run, reads a line from the user, then print that line back to him.
10:29:27 <Gurkenglas> Does that make sense, c50a326?
10:29:28 <nowhereman_> first, literals have a value: 5, "foobar", 3.141
10:29:40 <fishythefish> iron_houzi: you don't need to peel away a monad layer generically - the point is that you know how your parser works. The framework is `(Parser f) <*> (Parser x) = Parser $ \cs -> ...`. In that `...`, you first need to run `f`, then run `x` on the rest of the input (keeping in mind that there may be multiple successful parses), then apply the result of f to the result of x
10:29:57 <c50a326> f x = x + x ; does this have a value?
10:30:10 <c50a326> Gurkenglas: no, sorry ... you are typing functions in ""s... totally confusing
10:30:15 <nowhereman_> c50a326: (x+x) has a value
10:30:20 <fishythefish> c50a326: that's not an expression, but f has a value
10:30:37 <nowhereman_> c50a326: the whole line is a definition (or equation)
10:30:53 <c50a326> what is f's value? the function in its err... whatever it becomes when you define it?
10:30:58 <nowhereman_> that line also gives a value to f
10:31:11 <nowhereman_> yes, its value is the function
10:31:15 <Gurkenglas> c50a326, is it confusing because it is easy to mix up with a value of type String?
10:31:19 <c50a326> and what is x+x's value?
10:31:23 <fishythefish> c50a326: f's value is the function \x -> x + x
10:31:33 <fishythefish> the value of x+x is x+x
10:31:50 <c50a326> so is a list comprehension a value?
10:31:53 <fishythefish> sure
10:32:02 <c50a326> so a list comprehension is an expression?
10:32:05 <fishythefish> yes
10:32:10 <c50a326> but x <- getLine is not an expression?
10:32:22 <Solonarv> correct
10:32:26 <fishythefish> right
10:32:44 <nowhereman_> it's just syntactic sugar that evaluates to an expression
10:33:12 <fishythefish> c50a326: maybe a good rule of thumb for you is that an expression is something you can assign to a variable
10:33:52 <Gurkenglas> For example, you can assign a function to a variable.
10:34:34 <Solonarv> yes, that's a good rule of thumb
10:34:46 <Solonarv> if it can go on the right side of a = then it's an expression
10:36:42 <fishythefish> oh jeez, I skimmed the article again and this reasoning is gonna break down pretty quickly in that framework
10:40:05 <fishythefish> we (and haskell) consider getLine to be an expression, but in the IO crash course, getLine is a command
10:40:37 <fishythefish> it's presenting expressions vs commands as a dichotomy, but maybe a better lie is that commands are special cases of expressions which do IO
10:40:40 <fishythefish> i'm not a fan of this setup
10:46:56 <nitrix> If you understand the types and the implications, what you name it becomes secondary.
10:47:10 <nowhereman_> lyxia: the doc says that maximum has type  Ord a0 => Arg a a0 -> a0 , but when I apply it to a list of `Arg a b`, I get a vale of type `Arg a b` instead of `b`
10:47:19 <fendor> oh nose, has someone experience with haskell and pulseaudio on nixos? :D
10:47:19 <nowhereman_> did I get the doc wrong?
10:56:38 <encodes> this error is difficult to solve... https://lpaste.net/3331799757222838272
10:59:51 <cocreature> encodes: what are you hoping for here? there is only one instance and it doesn’t match your constraint so this can’t possible work.
11:00:15 <cocreature> you can mess around with Dict all you want, you won’t be able to make up instances that don’t exist
11:00:24 <dreamer_> ah yeah forgot this tidbit
11:00:38 <dreamer_> you can't use glfw as a gloss backend anymore
11:00:48 <zfnmxt> Are there any librarie that will print constructors in a nice tree, for easy human-readeability?
11:00:50 <dreamer_> doesnt work , version mismatch
11:00:57 <cocreature> zfnmxt: pretty-show
11:00:58 <encodes> the missing constraint should be entailed by the one make available by the Encodes instance provided....
11:01:13 <zfnmxt> cocreature: I actually just tried that but it just did exactly what `show` does...maybe I'm using it wrong.
11:01:25 <cocreature> zfnmxt: how are you using it? :)
11:03:18 <zfnmxt> cocreature: Uhm, retreact that. I was using ppShow and didn't notice the newlines it inserted >.<
11:03:22 <zfnmxt> It works. Nevermind :D
11:03:24 <zfnmxt> Thanks!
11:03:31 <cocreature> np :)
11:07:59 * hackage impure-containers 0.5.0 - Mutable containers in Haskell.  http://hackage.haskell.org/package/impure-containers-0.5.0 (andrewthad)
11:13:19 <AWizzArd> Is there a neat `stringJoin` function that I can use to put ", " between strings? Or some interleave fn that can do this?
11:13:46 <koala_man> :t intercalate
11:13:48 <lambdabot> [a] -> [[a]] -> [a]
11:14:09 <AWizzArd> thx
11:14:29 <cocreature> not to be confused with intersperse :)
11:16:06 <nowhereman_> @pl annotate f x = (f x, x)
11:16:06 <lambdabot> annotate = ((,) =<<)
11:19:53 <lyxia> nowhereman_: What docs are you looking at? maximum is overloaded and Arg is Foldable
11:20:16 <lyxia> nowhereman_: but if you're applying maximum to a list you're using the Foldable instance for [], not Arg.
11:22:46 <encodes> so this seems to work; https://lpaste.net/5473220771121725440
11:32:42 <encodes> though its not easy to see if its doing anything more than 'id'...
11:36:47 <Fold> bloop
11:38:45 --- mode: glguy set -o glguy
11:39:49 * Fold burps
11:42:06 <nowhereman_> lyxia: ha yes, I want to get the maximum according to the first argument of Arg but get the second argument at the end
11:48:36 <nowhereman_> @pl annotate f x = (x, f x)
11:48:36 <lambdabot> annotate = ap (,)
11:50:15 <pdxleif> maxBound :: Int in ghci indicates it's a 64-bit value. I see in the source all the Int{n}'s are represented as Int. I'm assuming everyone is going to run this on a 64-bit machine. I need at most 33 bits for the application. Am I fine with Int, or should I put Int64 in the type sigs?
11:50:58 <nowhereman_> I actually don't understand how `ap (,)` or `(,) =<<` can work…
11:51:27 <glguy> pdxleif: Int64 would be the right answer. If you want to cross your fingers obviously Int would work for the cases you have in mind at the moment
11:51:31 <pdxleif> ByteString.length returns an Int, so it seems easiest for me to just leave it as Int. It's not like this is performance sensitive where I'd care about the overhead of Integer, though - at most I'll have 10,000 of them.
11:51:39 <glguy> and then you can fix the bugs when you try to use that code later
11:51:51 <pdxleif> thanks!
11:52:01 <fakenullie> :t (,)
11:52:02 <lambdabot> a -> b -> (a, b)
11:52:04 <glguy> hopefully none of us has to use the code :)
11:53:17 <cgoldammer> I've got a question about a tasks queue in Haskell. I have an app that allows users to spin off computationally intensive tasks. I want to create a queue so that only one of those tasks runs at the same time.
11:53:54 <fakenullie> when you need specific number of bits, you should use specific size int
11:54:02 <cgoldammer> I've found some libraries like hworker, but this library seems to process tasks concurrently, which I don't want, because then, my users might bring down my instance
11:55:15 <cocreature> cgoldammer: you could have a Chan that stores the tasks and then have a thread that reads a tasks from this Chan, processes it, reads the next task, …
11:56:17 <cgoldammer> cocreature: Thanks! Yes, I am considering something like this. I was hoping there is a library that helps me with some of the more tricky parts (e.g. restarting failures, limiting job time)
11:56:35 <cgoldammer> but maybe it is easiest to simply use the basic building blocks in Haskell and create this myself
11:56:42 <maerwald> is there a nice comparison somewhere wrt data families vs type families, other than "one is injective, the other is not"?
11:56:58 <cocreature> don’t know of a library but depending on your needs it is fairly easy to builds this yourself
11:57:25 <cgoldammer> good to know - haven't used any Channells or Async stuff in Haskell so it's a good time to learn it anyways.
11:57:36 <cocreature> for limiting the job time you can use "timeout"
11:57:54 <cocreature> for restarts, catch the exception and keep a counter for how often you want to restart
11:58:37 <cgoldammer> good tips, will give it a go!
11:59:18 <cocreature> cgoldammer: if you haven’t dealt with concurrency in Haskell before, you might want to take a look at simon marlow’s excellent (and freely available) book https://web.archive.org/web/20171207155221/http://chimera.labs.oreilly.com:80/books/1230000000929/index.html in particular the second part should be interesting
11:59:36 <cgoldammer> Will do, thanks
12:00:19 <cocreature> concurrency is one of the best parts of Haskell so have fun :)
12:05:36 <Ariakenom> I like the freely available archive link :p
12:06:10 <c50a326> but I can assign the result of getLine to x with <-
12:06:18 <c50a326> so what's the real difference between <- and x
12:06:21 <c50a326> errr and =, sorry
12:06:37 <geekosaur> <- is actually the (>>=) operator
12:06:45 <geekosaur> :t (>>=)
12:06:47 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:06:53 <c50a326> :t <-
12:06:54 <lambdabot> error:
12:06:54 <lambdabot>     parse error on input ‘<-’
12:06:54 <lambdabot>     Perhaps this statement should be within a 'do' block?
12:06:58 <c50a326> pffft
12:07:13 <geekosaur> it's special syntax in do expressions, not an operator
12:07:23 <geekosaur> @undo do { x <- a; b x }
12:07:23 <lambdabot> a >>= \ x -> b x
12:07:28 <Ariakenom> do {x <- mx; f x} gets translated to mx >>= \x -> f x
12:07:35 <Ariakenom> Oh undo was fancy
12:07:39 <c50a326> so you can only use <- inside of do expressions? and do things are expressions?
12:08:10 <geekosaur> everything is an expression. do lets you pretend some things are "commands", if you must insist that there have to be "commands" hiding somewhere
12:08:17 <geekosaur> but there are only expressions
12:12:30 <byorgey> c50a326: the <- syntax also shows up in list comprehensions, but those are the only two places you can use <-
12:12:44 <byorgey> (and list comprehensions are secretly do expressions anyway)
12:13:25 <nowhereman_> byorgey: didn't know that they were, any doc on that?
12:13:31 <geekosaur> view patterns also
12:13:42 <byorgey> geekosaur: oh, good point, forgot about those
12:14:06 <merijn> No
12:14:12 <merijn> View patterns are ->
12:14:20 <merijn> unless I'm very mistaken
12:14:25 <geekosaur> sigh. always confuse those two
12:14:29 <geekosaur> view patterns, pattern guards
12:14:34 <byorgey> I think geekosaur meant pattern guards, right
12:14:52 <byorgey> nowhereman_: google for "monad comprehensions"
12:15:37 <geekosaur> yep, pattern guard
12:15:43 <byorgey> nowhereman_: also, it's a good exercise to write a list comprehension and then translate it to a do-block using the list monad.
12:15:58 * geekosaur wonders how many others get confused by these two
12:16:38 <byorgey> geekosaur: many, I'm sure.  I didn't even catch your mistake until merijn pointed it out.
12:16:40 <nowhereman_> c50a326: `x <- foo` means that the expression foo is a Monad of some sort that "contains" a value, and you put that value in the variable x
12:17:09 <geekosaur> except in pattern guards
12:17:32 <geekosaur> which I think is why they get confused; you can under some circumstances get that with view patterns but those use -> instead.
12:17:53 <nowhereman_> for example, getLine has type `IO String`, which means it's a monadic expression of the Monad IO and that it exposes a value of type String
12:18:16 <nowhereman_> hence you can do `x <- getLine` and x will have type String
12:18:24 <byorgey> I would say it "returns" or "results in" a value of type String
12:18:34 <byorgey> it doesn't "contain" a String.
12:18:49 <geekosaur> @quote /bin/ls
12:18:49 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
12:19:10 <byorgey> just like a cake recipe doesn't contain a cake
12:19:54 <cocreature> I would prefer cake recipes that do contain cake
12:20:17 <byorgey> that can be arranged
12:20:20 <geekosaur> that'd be one stale and squashed cake
12:20:42 <byorgey> data Recipe a = Recipe a (IO a)
12:21:07 * hexagoxel sifts through a box of old haskell snippets.. ah yeah, there it is
12:21:08 <byorgey> recipes must always come with samples.  This is the way recipes work on cooking shows.
12:21:08 <hexagoxel> > case 13 of x | Just ((+1) -> y) <- x + 1 -> y
12:21:10 <lambdabot>  error:
12:21:11 <lambdabot>      • No instance for (Num (Maybe Integer))
12:21:11 <lambdabot>          arising from a use of ‘e_11311’
12:21:29 <hexagoxel> > case 13 of x | ((+1) -> y) <- x + 1 -> y
12:21:31 <lambdabot>  15
12:21:45 <maerwald> is there a comparison somewhere wrt data families vs type families, other than "one is injective, the other is not"?
12:22:19 <byorgey> hexagoxel: my eyes!
12:23:14 <byorgey> maerwald: https://wiki.haskell.org/GHC/Type_families has a pretty good discussion
12:23:33 <maerwald> I found haskell wiki mostly hard to follow
12:24:01 <cocreature> data families are not just injective. they are generative, i.e., they generate new types
12:24:51 <maerwald> sure
12:24:59 <maerwald> those are just technical properties though
12:25:10 <pdxleif> I guess ByteString.length returns an Int because they didn't anticipate people having ByteStrings larger than 2GB?
12:26:16 <maerwald> explaining the properties of monads also doesn't give you any understanding of motivation, design space or intuition
12:26:18 <cocreature> pdxleif: well on a 64bit system Int is usually 64bit, so you can definitely have longer bytestrings
12:26:51 <pdxleif> Hmm - on GitHub it's defined as Int64 - https://github.com/haskell/bytestring/blob/master/Data/ByteString/Lazy.hs#L347
12:27:11 <pdxleif> Err, that's for lazy bytestrings
12:28:25 <cocreature> right lazy bytestrings can be longer than what you can keep in memory at a single time so even on a 32bit system you want a 64bit integer here
12:31:56 <maerwald> the wiki also only seems to compare fundeps with type families, not data families with type families
12:33:16 <maerwald> this SO post shows how to do Mutable Vectors with either of them, but makes a poor job at explaining why data families are better imo https://stackoverflow.com/questions/14195497/data-families-use-cases
12:43:31 <Cale> maerwald: The main difference with data families is that they are guaranteed to be injective.
12:45:57 <Cale> So similar to the difference between type and data normally, data family types can have instances defined on them while with type families, you can only put instances on the underlying types
12:48:12 <maerwald> people tend to say type families are more "powerful". Despite annoyances, what can you do with them that you cannot do with data families?
12:50:50 <c_wraith> maerwald, have different arguments resolve to the same type.
12:50:52 <mitchellsalad__> data families must return a type of type `Type`
12:51:07 <philippD> maerwald: data families always create new data types. data families are just function on types
12:51:21 <maerwald> philippD: I'm aware of the properties
12:51:26 <maerwald> c_wraith: example?
12:52:58 <c_wraith> um. if you know what data families do, isn't what they can't do obvious?
12:53:24 <maerwald> would I ask if it was?
12:53:51 <c_wraith> well, you rejected an explanation of the difference with "I already know that"
12:54:01 <c_wraith> so... do you already know that?
12:54:14 <maerwald> I didn't reject it, I asked for an example
12:54:43 <c_wraith> I meant philippD's response, which was far more informative than mine.
12:54:47 <maerwald> I'm aware
12:55:15 <Solonarv> `Base` from recursion-schemes is a pretty good example, IMO
12:55:18 <c_wraith> here's a quick example, I suppose.
12:55:39 <c_wraith> (1 + 3) ~ 4
12:56:14 <c_wraith> and (2 + 2) ~ 4
12:56:37 <c_wraith> two invocations of the + type family that resolve to the same type.
12:56:49 <philippD> https://lpaste.net/6575061748640907264
13:00:13 <c_wraith> :t (Proxy :: Proxy (1 + 3)) `asTypeOf` (Proxy :: Proxy (2 + 2)) -- maerwald
13:00:14 <lambdabot> Proxy 4
13:01:05 <c_wraith> maerwald, + couldn't be a data family for a bunch of reasons. one is that it's not injective. another is that doesn't result in a type of kind *
13:01:21 <encodes> maybe it could be to do with type-level lambdas? https://link.springer.com/chapter/10.1007/978-3-319-39110-6_4
13:02:00 <maerwald> philippD: https://lpaste.net/9120552083156631552
13:02:10 <maerwald> sure, it's not the same, but *shrug*
13:03:02 <maerwald> you just have a little more unwrapping to do, obviously. It impacts your API. But that's not really explaining the "more powerful" notion
13:06:15 <c_wraith> "more powerful" is a bit of a loaded term. I'd call it "more expressive". it can say more things, but it gives up guarantees like injectivity that you can otherwise use in your code in order to be more expressive. so the end result is that a user of a type family gets less power than the otherwise would. it's like the Monad/Applicative difference. which is more powerful? depends on whether you're creating an expression or using one someone else created.
13:07:20 <maerwald> so basically the only true difference is "data families bloat your API, but give you injectivity"
13:07:31 <maerwald> I don't see something more deep there
13:07:35 <c_wraith> no. did you ignore my example?
13:08:09 <c_wraith> type families can resolve to kinds that data families cannot.
13:08:30 <philippD> maerwald: how would you model `(+)` as a data family in such a way that you can still express equality?
13:09:02 <philippD> good point c_wraith. This becomes especially handy with ConstraintKinds
13:09:03 <nowhereman_> @pl loopState f state = f state >>= loopState f
13:09:03 <lambdabot> loopState = fix (liftM2 flip ((>>=) .))
13:09:36 <c_wraith> philippD, or DataKinds
13:09:44 <philippD> yeah
13:10:15 <maerwald> c_wraith: I didn't really understand your example
13:10:48 <c_wraith> @kind 4
13:10:49 <lambdabot> Nat
13:11:03 <nowhereman_> I just wrote this loopState function to loop in IO while retaining a state, previously I just used forever
13:11:39 <nowhereman_> is there a canonical way to do that? something with better syntax (I'll need a lambda for mine)
13:12:03 <c_wraith> nowhereman_, you'll need a lambda for anything that does that. your function is fine.
13:13:08 <maerwald> so that assumes one knows about DataKinds
13:14:00 * hackage tasty-golden 2.3.2 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.3.2 (RomanCheplyaka)
13:14:05 <c_wraith> maerwald, it's one trivial example. there are other ways to use kinds that data families don't feel happy with.
13:15:50 <c_wraith> nowhereman_, the only change I'd make is that I'd prefer to pass the state as the first parameter so that you don't need to put the initial state after the lambda. that can really help with call ergonomics
13:16:28 <cocreature> c_wraith: *sigh* runStateT …
13:16:43 <mnoonan> the worst :(
13:16:54 <c_wraith> cocreature, yes, it's sad. but I understand why it's the way it is, at least.
13:17:03 <cocreature> yeah
13:17:30 <mnoonan> wait, there is a *reason* why it is the way it is?
13:17:46 <mnoonan> (other than historical accident?)
13:17:51 <cocreature> mnoonan: it’s the newtype unwrapper function
13:18:16 <cocreature> newtype State s a = State { runState :: s -> (a, s) }
13:18:29 <mnoonan> ah.
13:18:44 <cocreature> ofc you could just make a separate function so it might not be a particularly good reason but at least it’s some kind of reason :)
13:18:48 <mnoonan> that also hits a pet peeve for me. I hate the "run" functions as record accessors.
13:18:54 <c_wraith> I don't find that reason to be especially compelling, but I understand why it was done that way.
13:20:59 * hackage nonemptymap 0.0.3.0 - A NonEmptyMap Implementation  http://hackage.haskell.org/package/nonemptymap-0.0.3.0 (ChristopherDavenport)
13:22:06 <Solonarv> I wouldn't be as annoyed by the runXXX record accessors if the module also exported a flipped variant of them
13:22:44 <cocreature> Solonarv: adding one more similarly named function runState, execState and evalState will definitely not make things even harder to remember :)
13:23:09 <Solonarv> fair point
13:23:12 <c_wraith> for State in particular, I'm really tempted to just use the lens operator all the time.
13:23:21 <c_wraith> but that doesn't generalize.
13:23:27 <cocreature> c_wraith: huh, which operator?
13:23:52 <c_wraith> unfortunately, I never remember the name of it. :)
13:24:02 <Gurkenglas> What's its type?
13:24:04 <mnoonan> but I mean.. why even have it be a record at all? If it was just "newtype State s a = State (s -> (a,s))" with a runState function, you'd already *know* the constructor name anyway.
13:24:45 <Gurkenglas> :t (&~) -- ah he probably means this
13:24:46 <lambdabot> s -> State s a -> s
13:24:52 <c_wraith> Gurkenglas, that's the one.
13:24:55 <Solonarv> if you're going to have a runState :: State s a -> s -> (a, s) then it might as well be the record field
13:25:05 <cocreature> neat!
13:25:23 <cocreature> one more operator that I won’t be able to remember and therefore won’t use ;)
13:25:31 <cocreature> is there a StateT version as well?
13:25:36 <c_wraith> cocreature, yep! me too. :)
13:25:37 <Gurkenglas> That one's type is actually hoogleable though.
13:25:39 <mnoonan> Solonarv: why? this seems like a convention with no real benefit, tbh
13:25:59 <Solonarv> it has a small benefit and no downside
13:26:10 <Solonarv> notice that I said "assuming you're going to export that function anyway"
13:26:22 <Gurkenglas> http://hayoo.fh-wedel.de/?query=s+-%3E+StateT+s+m+a+-%3E+m+s has a bunch of flipped aliases, but none are infix.
13:27:53 <c_wraith> > 5 &~ id -= 1
13:27:56 <lambdabot>  4
13:28:15 <Gurkenglas> run* seems annoying iff you have a concrete starting value at hand
13:28:22 <c_wraith> yeah, that looks nothing like haskell anymore. :)
13:28:49 <Gurkenglas> Is it missing some desirable property of Haskell?
13:29:17 <c_wraith> Gurkenglas, nah. I just meant by syntax, it's starting to look pretty far from non-lens haskell.
13:30:22 <geekosaur> lens does have certain aspects of incompatible dialect
13:37:46 <domenkozar> is there a way to call show without escaping newlines? :)
13:39:01 <koala_man> I have a directed cyclic graph, and I want to derive the linear ordering of the vertices that preserves the most edges from one vertex to the next. how can I do that?
13:39:21 <koala_man> specifically i have code blocks, and I want to order them to maximize fallthrough and minimize jumps
13:39:47 <geekosaur> domenkozar, no
13:40:19 <geekosaur> if you want custom behavior, use a custom formatter. Show is intended to produce Haskell source (for read, or that can be c&p-d into a program or ghci)
13:40:22 <cocreature> domenkozar: newtype your String and write a custom Show instance
13:40:29 <encodes> at this stage its daunting to think this error implies that the "Lift/ReifiableConstraint machinery" will need to be completely rewritten for types of kind (*->*)... maybe there is no other way...
13:40:29 <cocreature> but yeah only use that for debugging
13:40:43 <encodes> https://lpaste.net/4847066401095024640
13:41:31 <domenkozar> cocreature: right :)
13:45:48 <encodes> if thats not the case then there would be no need to attempt to wrangle that formidable unsafeCoerceConstraint...
13:46:33 <encodes> its difficult to tell...
13:49:09 <Gurkenglas> koala_mans problems can be written as: Given a boolean matrix A, find a permutation matrix P such that PA has minimal 1s under the diagonal.
13:49:30 <koala_man> hmm
13:51:55 <Gurkenglas> What time is acceptable to use on the problem? Matrix multiplication is polynomial with degree between 2 and 3
13:54:38 <koala_man> it's an offline but practical process, so it's open ended. O(n^4) wouldn't be crazy
13:55:59 * hackage nonemptymap 0.0.4.0 - A NonEmptyMap Implementation  http://hackage.haskell.org/package/nonemptymap-0.0.4.0 (ChristopherDavenport)
13:56:15 <koala_man> but 2^n would
13:57:39 <encodes> maybe there is an alternative....
14:04:38 <Gurkenglas> Let T have all 1s above the diagonal, and 0s else. Given a boolean matrix A, find a permutation matrix P such that TPA has minimal trace.
14:09:29 * hackage bloodhound 0.16.0.0 - Elasticsearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.16.0.0 (MichaelXavier)
14:10:30 * hackage StrictCheck 0.1.0 - StrictCheck: Keep Your Laziness In Check  http://hackage.haskell.org/package/StrictCheck-0.1.0 (kwf)
14:10:54 <Boreeas> Can someone explain to me why I can load a haskell file into ghci, but if I try to compile with ghc I get an error about 'module Prelude not found'
14:11:15 <glguy> Boreeas: How did you install GHC?
14:11:40 <Boreeas> On archlinux, with package ghc
14:11:44 <maerwald> philippD: I'm looking at this SO answer which tries to go into more detail there wrt kinds and type families https://stackoverflow.com/a/20908500/2976251
14:11:47 <monochrom> Oh! heh
14:11:48 <glguy> The problem is you're using Arch Linux
14:11:54 <Boreeas> ¯\_(ツ)_/¯
14:11:58 <maerwald> but the example doesn't seem to correlate to what the text says
14:12:00 <geekosaur> that's basically it. arch has a somewhat broken setup there
14:12:17 <monochrom> Boreeas: https://wiki.archlinux.org/index.php/Haskell#Problems_with_linking
14:12:50 <glguy> Boreeas: The best solution is not to use Arch Linux's package manager to manage your Haskell development environment
14:12:53 <maerwald> philippD: I don't see the simple type being a synonym for a constructor kind, they are both '*'
14:13:15 <maerwald> this is just an instance of non-injectivity + type annotation
14:13:25 <Gurkenglas> koala_man, aaaaaand ##math recalls it's NP-hard. Have you considered throwing a SAT solver at it?
14:13:50 <koala_man> I have not
14:14:18 <monochrom> Have you considered solving it in polynomial time and snatching the Millenium prize? >:)
14:14:26 <koala_man> lol
14:14:50 <philippD> maerwald: what part of the answer are you talking about?
14:14:56 <maerwald> the very last
14:15:02 <Gurkenglas> If you have, do a quick fermi division of the millenium prize by the total time people have spend on P = NP
14:15:10 <Gurkenglas> *spent
14:15:36 <koala_man> I'm going to try to brute force it and see if I can get an idea of how much of an improvement I could see
14:15:52 <c_wraith> Gurkenglas, that would approximate $0/hr
14:16:18 <Boreeas> monochrom: Thanks! Passing -dynamic fixes the problem
14:16:25 <Gurkenglas> c_wraith, thatsthejoke.jpg
14:16:25 <stevenxl> Hi folks. I have a pull request up https://github.com/yesodweb/yesod/pull/1524. I am trying to change the type signature of "emailPreviouslyRegisteredResponse :: AuthHandler site TypedContent" to "emailPreviouslyRegisteredResponse :: Maybe (AuthHandler site TypedContent)", but when doing so, I get a type error: https://drive.google.com/open?id=1BYUXc18mKC9hNsA8KDDBwE2bjXoG0yms
14:17:02 <philippD> maerwald: data families always create datatypes, so the kind of the result of a data family will always be *. type families can also return different kinds like * -> * ([], or Maybe for example).
14:17:16 <glguy> stevenxl: AuthHander is a type synonym for a quantified type. Type variables can't be instantiated with quantified types
14:17:20 <maerwald> philippD: but the example doesn't demonstrat that afais
14:17:30 <maerwald> which is why I find that confusing
14:17:40 <glguy> type AuthHandler master a = forall m. MonadAuthHandler master m => m a
14:17:52 <monochrom> -dynamic has its share of cons.  (pun intended)  It means the exe is unusable on another computer.  Or even just after you upgrade archlinux to a different version.  etc etc.
14:17:52 <philippD> maerwald: I'll try cooking something up
14:18:04 <maerwald> :*
14:18:08 <Gurkenglas> koala_man, https://en.wikipedia.org/wiki/Feedback_arc_set
14:18:29 <stevenxl> glguy: Hello. That is helpful. I have no idea what a quantified type is, but I can look it up.
14:18:32 <stevenxl> Thank you.
14:18:43 <glguy> stevenxl: the "forall" is a quantifier
14:18:45 <monochrom> Basically I use -dynamic when I'm compiling students' code for marking purposes meaning I just need to run it 8 times and forget.
14:19:05 <koala_man> neat. I'll have a look!
14:19:07 <tam1138> following on the question from Boreeas, and having read the description of different toolchain-installation options on haskell.org, is there a recommended path (minimal vs stack vs platform) for people who aren't too advanced but just want to get writing some simple applications with libraries?
14:19:13 <monochrom> in which case the saving in disk space is sweet.
14:20:21 <glguy> stevenxl: so instead of: Maybe (AuthHandler master a), you have to write: MonadAuthHandler master m => Maybe (m a)
14:20:55 <Boreeas> monochrom: That's absolutely fine for my usecase right now
14:20:57 <stevenxl> glguy: Thank you - I'll try this out.
14:20:59 <glguy> this has a slightly different meaning, but that difference might not matter for what you're doing
14:22:26 <glguy> tam1138: Minimal Haskell Platform is the way to go. It comes with a copy of stack should you ever need that later and with cabal-install's new-build which can handle installing any libraries you might end up wanting
14:23:00 * hackage currencies 0.2.0.0 - Currencies representation, pretty printing and conversion  http://hackage.haskell.org/package/currencies-0.2.0.0 (DanielCampoverde)
14:23:26 <philippD> maerwald: https://lpaste.net/4977880732585164800
14:23:59 <tam1138> glguy: thanks!  I assume you mean the thing called "Minimal installers" on this page: https://www.haskell.org/downloads (I don't see anything specifically called "minimal haskell platform" there)
14:25:05 <glguy> tam1138: No, it's under "Haskell Platform" and it was actually called "Core" and not "Minimal"
14:25:28 <glguy> I thought it used to be called minimal but maybe that changed or I forgot
14:25:28 <stevenxl> glguy: I had to make a slight modification because I was getting an ambigious type variable "emailPreviouslyRegisteredResponse :: MonadAuthHandler site m => Maybe (m TypedContent)".
14:25:54 <stevenxl> This still doesn't type check but I think it gets me into territory I can punch my way ou tof.
14:25:58 <stevenxl> Thank you!
14:27:35 <tam1138> glguy: thank you sir and/or madam
14:28:04 <glguy> bot*
14:30:16 <maerwald> philippD: does that only work with closed type families?
14:30:21 <philippD> maerwald: you can write something like this using data families. But you would have to use StandaloneDerving and GeneralizedNewtypeDeriving to get all the instances https://lpaste.net/8249683872606846976
14:30:35 <philippD> maerwald: no, it works with all typefamilies
14:31:02 <tam1138> having installed the haskell platform core thingy, is the recommended workflow to use cabal sandboxes for development?
14:31:27 <glguy> tam1138: The current state of the art is : https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
14:31:34 <philippD> maerwald: As I said there are also ConstraintKinds with which the result of a type family can be a constraint
14:31:43 <maerwald> I get errors writing it normally
14:31:54 <maerwald> as an open family
14:32:42 <tam1138> glguy: excellent, thank you again
14:33:22 <tam1138> hopefully one last question: what's the recommended workflow when a new version of haskell platform is released?  download & install the new platform and... is there a "rebuild all" option?
14:33:38 <glguy> maerwald: You'll need FlexibleContexts in both open and closed typefamilies cases of that code
14:33:46 <maerwald> I have
14:34:15 <glguy> maerwald: and kind signatures on the definition of the type family
14:34:17 <philippD> maerwald: you have to add a Kind singature to the family definition. Otherwise it will default to *
14:34:29 <glguy> type family F (b :: Bool) :: * -> *
14:34:38 <philippD> https://lpaste.net/8758751721838084096
14:35:28 <glguy> maerwald: an interesting difference in type families and data families is that you can partially apply data families because we know they introduce distinct types
14:35:43 <glguy> while type families, like normal type synonyms, do not allow this
14:36:30 <philippD> glguy: but you can kind of manually curry them like this example
14:37:17 <glguy> Right, like type synonyms you can eta reduce them in the cases where that's appropriate
14:37:37 <glguy> but you must always apply them to satisfy all the named parameters when you use one
14:37:50 <philippD> yup -.-
14:38:41 <maerwald> so data familiy can only ever be :: *
14:39:15 <maerwald> I can define a data family with * -> * kind, though
14:39:24 <glguy> well no a data family can just be of kind * if you want
14:39:27 <glguy> kind of useless, though
14:39:36 <glguy> data family D; data instance D = C
14:39:48 <glguy> You don't *have* to have parameters
14:40:00 <philippD> you can partially them though
14:40:47 <philippD> so `D` in `data family D a; data instance D Int = DInt` would have kind (* -> *)
14:41:58 <philippD> but the result of your data family can't have some fancier kind like Constraint or those possible through DataKinds
14:42:32 <maerwald> data family F' (b :: Bool) a :: * -> *
14:43:32 <philippD> `data family F :: Bool`
14:43:59 <glguy> so GHC will let you do: data family   D a :: * -> *; data instance D Int z = DI
14:44:27 <glguy> or: data family   D :: * -> * -> *; data instance D Int z = DI
14:44:54 <maerwald> but DI is of kind *
14:45:07 <glguy> Well, DI :: D Int z
14:45:13 <glguy> and D Int z :: *
14:45:51 <philippD> https://lpaste.net/4690859973842829312
14:47:20 <glguy> Type families don't have to have parameters, either: type family F; type instance F = Int
14:47:56 <glguy> You can spread those two declarations across different modules if you wanted, kind of just a delayed implemenation of an unparameterized type synonym
14:48:00 <philippD> maerwald: you cant express something like Not effectively as a data family. You essentially would have to recreate Nat and say that even number are True or something like this.
14:48:01 <maerwald> ok, so this is all very contrived though. The initial example https://stackoverflow.com/a/20908500/2976251 (at the end) that brought me here seems to be orthogonal to that
14:48:36 <glguy> maerwald: I'm late to the party. What's the actual question then?
14:49:01 <maerwald> just poking on the differences and confused by the last example in the SO thread
14:49:31 <maerwald> which, afais, is just "inference resolution by type annotation" and not really related to the 'kinds' thing
14:49:32 <monochrom> Perhaps the SO thread is answering a different question.
14:49:38 <maerwald> no, it's about kinds too
14:49:47 <maerwald> but the example appears to be orthogonal to what he wants to show
14:50:14 <maerwald> Data.MonoTraversable also doesn't really use DataKinds
14:50:15 <glguy> The differences in type families and data families aren't really visible at the kind level other than a restriction that data families will always, which sufficient type application, get to kind *
14:50:35 <monochrom> Oh! I just saw "(Boosting useful information from comments into an answer.)" now.  It probably means "this is deliberately orthogonal".
14:50:37 <philippD> I think IsList is a better exeample for what the SO answer wants to say
14:50:37 <philippD> https://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Exts.html#t:IsList
14:50:57 <maerwald> monochrom: yes, it appears it was just pieced together
14:51:56 <monochrom> It's normal for some commentator to leave a tangential comment.  As long as it is not called "answer" it's good discussion.
14:52:36 <monochrom> But you always have do-gooder moderators who promote that non-answer to "answer" because experts like information overload and showing off.
14:52:45 <monochrom> So much for SO.
14:53:18 <philippD> `IsList` has an associated `Item` type family which allows you to write the functions fromList and toList. With data families you couldn't write those functions. the user would have to wrap each element of the list with the data families constructor
14:56:24 * maerwald silentely goes back to fundeps
14:56:25 <encodes> glguy; it might be possible to consider replacing (p :: * -> Constraint) with (p :: * -> * -> Constraint) https://lpaste.net/6834688991220989952
14:56:55 <monochrom> For difference between data family and type family, my take is a very simplistic "each instance of a type family is a type synonym, each instance of a data family is an algebraic data type".  Now you re-use what you know about the difference between type synonym and algebraic data tyle.
14:57:09 <monochrom> err s/ tyle/ type/
14:58:32 <maerwald> I'm still not 100% sure if I understand "type families can resolve to kinds that data families cannot." correctly
14:58:55 <glguy> maerwald: Did you see the example of a type family that implements "not" at the type level ?
14:59:11 <glguy> as in on Bool as lifted by -XDataKinds
14:59:14 <maerwald> https://lpaste.net/4690859973842829312 this?
14:59:20 <glguy> yeah
14:59:48 <glguy> So that lets us define the type Not :: Bool -> Bool
15:00:18 <glguy> There are no values involved here, it's just a function on types
15:00:24 <maerwald> yeah, so that's kinda type-level computation
15:01:08 <philippD> type families are functions on types. So yeah, thats what they'll to ;)
15:01:25 <glguy> Yes, but data families are never that interesting, a data family's type constructor will never evaluate to anything when applied
15:01:44 <glguy> (They're almost always functions on types, but they don't have to be)
15:02:33 <maerwald> I'm scared now
15:02:40 <philippD> type families are more expressive in the same sense that functions are more expressive than data types.
15:02:54 <monochrom> Hmm, I guess I can't make a data family of kind Bool -> Bool.  Basically anything->Bool.
15:03:22 <philippD> monochrom: You can?
15:03:32 <monochrom> Can I still do Bool -> * though?
15:03:53 <glguy> monochrom: Sure, you can do Bool -> *
15:04:21 <philippD> the interesting part is the * at the end
15:04:28 <glguy> The valid kinds are: * or      k -> valid_kind
15:04:33 <monochrom> philippD: I mean suppose someone asked me to do "___ -> Bool, the ___ part is up to you", then I can't do it.
15:04:34 <glguy> where k can be any kind
15:05:17 <philippD> monochrom: I don't know what you are doing but `data family F :: Bool` doesn't compile
15:06:22 <glguy> monochrom said he *can't* make that Bool data family
15:06:30 * hackage Villefort 0.1.2.12 - Villefort is a task manager and time tracker  http://hackage.haskell.org/package/Villefort-0.1.2.12 (ChrisReuter)
15:06:39 <glguy> but I think perhaps maerwald and philippD are reading that messages as *can*
15:06:50 <philippD> yeah, I did
15:07:04 <philippD> It's getting late here
15:07:50 <glguy> time's funny like that :)
15:08:05 <maerwald> someone has to write a proper type family blog post now :P
15:08:10 <monochrom> I know right? American English pronounce "can" and "can't" with pretty much the same vowel. Only difference is intonation. Plus the extra "t" is practically silent.  Unlike British English which both uses a different vowel and makes sure the extra "t" is loud.
15:08:52 <glguy> Maybe next time type the British English "can't" instead of the American English "can't"
15:08:59 <geekosaur> heh
15:09:36 <philippD> I should set my IRC text to speech to british then
15:10:20 <maerwald> lpaste really has degenerated, I don't even know how to get raw text
15:10:22 <philippD> But isn't there a proper type/data families blogpost?
15:10:31 <maerwald> I have looked, I haven't found any
15:10:53 <maerwald> http://dev.stephendiehl.com/hask/#type-families-1
15:11:01 <maerwald> https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html
15:11:06 <maerwald> not very in-depth
15:11:15 <maerwald> then various so answers and a confusing haskell wiki page (as always)
15:11:20 <monochrom> Yeah actually what happened to lpaste?
15:11:29 <maerwald> monochrom: it was rewritten and now has 200 loc or something
15:11:32 <maerwald> so very simple...
15:11:52 <monochrom> I'm OK with simple but you've got to include the "raw" button.
15:12:12 <philippD> that shouldn't add to many locs either
15:12:27 <monochrom> And TBF it is not simple until the style sheet is empty.
15:12:27 <glguy> Yeah, making me edit /raw/ into the URL manually sucks, and copy/paste on the "pretty" output grabs the line numbers
15:12:56 <maerwald> let's write an lpaste with type families
15:14:06 <philippD> you mean, all the computation is done at compile time?
15:14:35 <glguy> That'd help reduce spam
15:15:33 <maerwald> also, there is so much information on deployment :>
15:15:37 <maerwald> as in: none
15:15:44 <philippD> Wait. We have compiler plugins. So we COULD write a compiler plugin that implements an HTTP stack ...
15:17:07 <maerwald> so your program compiles in a loop? xD
15:18:25 <philippD> yeah
15:19:09 <philippD> I just tried looking at lpaste's source. but the github repo seems to be missing. Does anyone know where it's hosted now?
15:19:30 <maerwald> https://github.com/lpaste/lambda-paste
15:21:07 <philippD> You don't have to rewrite it using type families. look at line 1 of Main.hs
15:21:33 <philippD> https://github.com/lpaste/lambda-paste/blob/master/app/Main.hs#L1
15:25:22 <pally> what is a thunk build up?
15:26:33 <pally> re: http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-List.html#v:iterate
15:27:31 <philippD> Haskell is a lazy language that means that values are calculated only once they are needed
15:28:31 <philippD> so functions don't return values but instead just a recipe to create the value
15:28:42 <philippD> this recipe is called a thunk
15:31:13 <mreh_> Cale: I think Obelisk is meant for web and native style apps, not sure it was meant for games
15:32:24 <pally> how is it related to the thunk sound?
15:32:35 <pally> (if it is related at all)
15:33:35 <glguy> It's not
15:34:05 <mreh> isn't it like the past participle of thought?
15:34:30 <mreh> "who'da thunk it?"
15:34:51 <geekosaur> somewhere or other there's some snark about that being the sound of a thunk being updated with its result
15:35:02 <geekosaur> but I don't think that's where it came from
15:35:19 <mreh> wiki says what I said
15:39:47 <glguy> If it's on the wiki then you know at least someone else believes its true, too
15:44:39 <godsmack_> Looking for a "stresser" service to use on my website. Will pay $800/day in bitcoin or monero, pm me if you can do it
15:45:03 --- mode: ChanServ set +o glguy
15:45:03 --- mode: glguy set +b *!*@dsl-olubng12-54fa06-160.dhcp.inet.fi
15:54:38 <shapr> glguy: thanks!
15:56:58 <koala_man> Gurkenglas: my experiment increased compilation time by 19x while reducing code size by 0.00052%, haha
15:58:16 <Gurkenglas> koala_man, if that was the brute-force approach, that sure sounds like it can be done in reasonable time
15:59:07 <Gurkenglas> koala_man, what portion of that reduce is covered by greedy?
15:59:30 <koala_man> what do you mean?
16:00:52 <koala_man> the greedy approach generated a 19MB binary, while the brute force approach managed 103 fewer bytes
16:02:18 <Gurkenglas> By greedy I mean something like, pick a code block, move it to wherever it minimizes code size, repeat until no code block can improve the code size
16:03:00 <koala_man> that's basically what you get with a depth first search
16:04:07 <Gurkenglas> I don't follow
16:05:09 <Gurkenglas> Do you mean that because this problem is (via toposort) equivalent to feedback arc set, we can do depth-first search to find cycles and remove edges as we find them completing cycles, and this is as good as what I called greedy?
16:05:51 <koala_man> if you just pick blocks by choosing a successor each time, you get the maximum saving per choice
16:07:59 <Gurkenglas> Ah, I would call that closer to selection sort.
16:10:00 * hackage katip 0.6.0.0 - A structured logging framework.  http://hackage.haskell.org/package/katip-0.6.0.0 (MichaelXavier)
16:10:30 * hackage katip-elasticsearch 0.4.2.0 - ElasticSearch scribe for the Katip logging framework.  http://hackage.haskell.org/package/katip-elasticsearch-0.4.2.0 (MichaelXavier)
16:17:56 <infinisil> ^^ katip sounds very interesting
16:22:01 <bwe> eitherDecode "\"0:10\"" :: Either String TimeOfDay -- fails
16:22:22 <bwe> eitherDecode "\"00:10\"" :: Either String TimeOfDay -- succeeds
16:23:32 <bwe> I wonder since https://hackage.haskell.org/package/time-1.8.0.2/docs/Data-Time-LocalTime.html#t:TimeOfDay says `todHour` might be a single 0. Should "\"0:10\"" be decoded into TimeOfDay or not?
16:24:05 <glguy> bwe: where is eitherDecode defined?
16:25:37 <bwe> glguy: https://hackage.haskell.org/package/aeson-1.3.1.1/docs/Data-Aeson.html#v:eitherDecode
16:25:52 <EvanR> 0:10 doesnt look right
16:26:18 <EvanR> you dont want to get into HTMLs original hell hole where data producers feel like they can output any arbitrary crap
16:26:30 <EvanR> and bank on the decoder being "smart"
16:26:57 <bwe> EvanR: I agree. But I am a little undecided yet since Data.Time says a single zero, as I understand it, would be fine.
16:27:14 <glguy> bwe: The thing you linked to isn't about any particular format
16:27:26 <glguy> it's saying that the todHour :: Int field might have the value 0
16:27:39 <glguy> The parser you're using uses this: Parse a time of the form @HH:MM[:SS[.SSS]]
16:28:16 <EvanR> bwe: todHour is a number from 0 to 23... that has nothing to do with parsing
16:28:25 <EvanR> parsing a string of characters
16:28:56 <EvanR> so were talking about two opposite things
16:28:59 <bwe> EvanR: Well, I have already my own instance of parseJSON, however that collides with the one shipped with Data.Aeson.
16:29:33 <bwe> EvanR: True. The parser is not the representation it returns.
16:29:43 <EvanR> no parse
16:30:23 <bwe> EvanR: Would you agree on cleaning up the mess before parsing it?
16:30:31 <EvanR> i would not customize the time parser to allow 0:10 or 0:1 or :1 or whatever
16:30:49 <EvanR> 00:00 please
16:32:33 <EvanR> clean up mess before parsing? is this a scraper or a reliable encoding-decoding plan
16:34:34 <bwe> EvanR: None purely. I get a json array and parse its fields to records.
16:35:00 <EvanR> do you have any agreement on the format for time-of-days
16:35:13 <EvanR> or is this a "parse and pray" situation
16:35:53 <glguy> bwe: If the time field is malformed you can take that as a Text field instead of a TimeOfDay when decoding from JSON
16:40:28 <bwe> glguy: No chance to decode it to TimeOfDay?
16:40:41 <glguy> Not if it's in the wrong format
16:41:02 <angerman> mreh: you need to build libiconv for Android separately unfortunately. There is a post on medium.com/@zw3rk on how to do that.
16:41:06 <glguy> you could write the FromJSON instances by hand and not use the FromJSON instance for TimeOfDay
16:45:16 <butterthebuddha> https://lpaste.net/5524632538972160000
16:45:53 <butterthebuddha> For some reason, the last parser (the one that parses Sym) is taking precedence over the Vec parser
16:46:57 <butterthebuddha> I'm not sure how to debug this :/
16:50:21 <glguy> butterthebuddha: I'm not saying that this is the problem, but why do you have the parsers nested like that where the ) build up all at the end?
16:50:33 <glguy> instead of (A <$> parseA) ||| (B <$> parseB) ||| ...
16:50:35 <butterthebuddha> glguy: I was hoping to force precedence that way
16:51:09 <butterthebuddha> It didn't really work :/
16:51:11 <glguy> I don't know what parser combinator library you're using, but I don't know any where that's how that works
16:51:37 <butterthebuddha> glguy: it's my solution for the fp-course parser exercise
16:52:13 <glguy> Have you checked that the thing you're trying to parse as a vector parses when you just parse it with parseVector ?
16:52:18 <butterthebuddha> Yep
16:52:33 <butterthebuddha> If I get rid of the Symb parser altogether, it parses with vec fine
16:53:17 <glguy> You probably haven't pasted enough code for anyone to help solve the one
16:53:35 <butterthebuddha> Yeah, I was just hoping for pointers on how i might go about debugging this on my own
16:53:54 <butterthebuddha> unless someone doesn't mind wading through some context :/
16:54:33 <glguy> The only pointer I can offer is to try and shrink your test case until you can't find anything else to remove from it without it starting to work again
16:54:40 <glguy> given that all the code is missing
16:55:10 <butterthebuddha> https://lpaste.net/578773635141992448
16:55:21 <butterthebuddha> ^ That's the entire module
17:00:00 <bwe> glguy: Done. I read it as String, then sanitise and convert it in the process of returning a result type from my instance FromJSON ...
17:00:21 <glguy> yay!
17:01:43 <nshepperd> butterthebuddha: my guess is a nested invocation of parseAtom inside of parseVector has broken the parse by eating too many characters
17:02:02 <butterthebuddha> nshepperd: My test case was [1 2 3]
17:02:08 <butterthebuddha> So the parser should break out by parsing an int :/
17:02:21 <nshepperd> butterthebuddha: i don't see ']' in your list of badChars
17:02:40 <mreh> angerman, thx
17:02:49 <mreh> I'll give it a go
17:03:24 <mreh> angerman, would iconv be part of the built library if I was just doing SDL stuff?
17:03:26 <butterthebuddha> nshepperd: A symbol should be allowed to have "[]" in it; a '[' starts a vector if and only if there is a space preceding it
17:03:43 <butterthebuddha> Or at least that's what I'd like
17:04:14 <butterthebuddha> is there any way to print all the function calls and outputs?
17:04:40 <nshepperd> butterthebuddha: ok, but what stops it from parsing the ] that terminates the list as another list entry then
17:04:51 <nshepperd> namely a symbol consisting only of ]
17:05:25 <butterthebuddha> True, I guess there are some messy edge cases with that
17:05:43 <butterthebuddha> Perhaps it's best to add "[]" to the badChars; that's probably what I'll do
17:07:00 <nshepperd> do that and test if it fixes the parse
17:07:11 <butterthebuddha> that does fix it
17:11:20 <nshepperd> one way you could have debugged this is by running parseVector directly on the test case and looking at the parse error
17:14:08 <nshepperd> this kind of thing is also why parsec made the right decision in having committed choice imo
17:15:34 <nshepperd> you want the parser to be committed to parsing a list once it encounters [ so that you get the proper error message about a missing ] instead of having it move onto the next possibility and complain that it's not a number or something
17:16:22 <Solonarv> isn't it also more performant?
17:16:32 <Solonarv> and, there's always `try` when you do need to backtrack
17:18:36 <nshepperd> yeah, it lets you discard the completely used input as you go
17:18:42 <Gurkenglas> Shouldn't the error message instead give you a complete tree of failed choices?
17:19:56 <tam1138> i'm building the haskell platform from scratch (for funsies).  i believe i've followed all the instructions correctly, but it fails.  hptool requires hastache, which requires base<4.11, but current platform provides base=4.11 (and build docs say they have to be the same version), so i'm confused as to how this ever built correctly for anybody.  any insight?
17:20:27 <Solonarv> are you building "the haskell platform", or "all of hackage"?
17:20:37 <tam1138> the haskell platform
17:20:49 <erisco> what is happening?
17:20:50 <Gurkenglas> (And then maybe one should give weights to choices in order to show the most probably relevant error message. Is SearchT applicable?)
17:20:52 <nshepperd> I suppose that would be another way to handle it
17:22:34 <tam1138> here is what's happening: https://lpaste.net/332095487031115776
17:23:27 <tam1138> hptool depends on hastache, which has been deprecated for a while: http://hackage.haskell.org/package/hastache
17:23:44 <Solonarv> in that case I have no idea - I haven't even looked at the haskell platform in a long time, I just use stack
17:23:54 <pally> > [ last ["all", "removed", "except", "the", "last"] ]
17:23:56 <lambdabot>  ["last"]
17:24:07 <tam1138> which also confuses me, because afaict, there does not exist a version of hastache that will work with the current platform
17:24:11 <pally> any better way?
17:25:27 <Solonarv> what are you trying to accomplish?
17:26:27 <tam1138> i'm trying to build a single package for ArchLinux that duplicates the Minimal Haskell Platform
17:26:44 <Solonarv> sorry, not you tam1138; I have no idea how to help you
17:26:58 <tam1138> ah, np
17:30:01 <Solonarv> pally what is your goal? what are you trying to do?
17:32:06 <pally> Solonarv, it's illustrated in the example
17:32:21 <pally> I want to drop all items except the last
17:32:42 <Solonarv> what's wrong with just using last? that's what it does
17:34:40 <pally> nvm, I can always cons (:)  it with the results list in my algorithm
17:35:28 <Solonarv> in general I would caution against using `last` unless you know that its input cannot be empty
17:35:49 <pally> yes, I know the input will not be empty
17:37:34 <Solonarv> in that case it's fine
17:37:56 <Solonarv> otherwise, you should probably use a function that forces you to handle the empty-list case
17:38:03 <Solonarv> and doesn't throw an error
17:38:30 <maerwald> anyone knows how ghc is on FreeBSD these days?
17:48:47 <Cale> @tell mreh yes, Obelisk specifically is definitely set up for web applications, but there's stuff in there for building Android apps (but most of that is in reflex-platform and jsaddle)
17:48:47 <lambdabot> Consider it noted.
18:12:34 <dmwit> > take 1 . reverse $ ["all", "removed", "except", "the", "last"]
18:12:36 <lambdabot>  ["last"]
18:12:46 <dmwit> > (take 1 . reverse $ [], [last []])
18:12:48 <lambdabot>  ([],[*Exception: Prelude.last: empty list
18:13:03 <infinisil> ??
18:13:23 <dmwit> Responding to a question from an hour ago. =P
18:13:26 <infinisil> Ohh
18:14:08 <infinisil> They left about 30 minutes ago heh
18:14:13 <Solonarv> @let lastMay = foldl' (const Just) Nothing
18:14:15 <lambdabot>  Defined.
18:14:18 <dmwit> So they did.
18:14:51 <Solonarv> > (lastMay [], lastMay [1, 2, 3])
18:14:53 <lambdabot>  (Nothing,Just 3)
18:35:04 <rotaerk> :t maybe
18:35:06 <lambdabot> b -> (a -> b) -> Maybe a -> b
18:35:21 <rotaerk> what would the list analogue of that be? fold?
18:35:32 <angerman> mreh, I believe the rts links against it.
18:37:19 <dmwit> rotaerk: foldr
18:38:02 <dmwit> Well. Since there's no recursion in Maybe, the question is a bit underspecified. There are many possible analogs.
18:38:31 <rotaerk> k
18:38:40 <dmwit> Another possible one would have type `b -> (a -> [a] -> b) -> [a] -> b`, for example.
18:38:51 <rotaerk> makes sense
18:42:08 <Solonarv> foldr is the "correct" answer in that it's the church encoding of [], much like maybe is the church encoding of Maybe
18:42:14 <Solonarv> (up to argument order)
18:43:56 <taumuon> is it possible to short circuit a recursive list operation? does the compiler do any short circuiting automatically?
18:44:34 <Solonarv> yes and sort-of-yes (it's not done by the compiler)
18:44:55 <Solonarv> haskell is a lazily-evaluated language, which means a value isn't computed unless it's actually needed
18:45:19 <dmwit> > foldr (||) False (True:undefined)
18:45:20 <butterthebuddha> Is there a way of representing subtype relationships?
18:45:20 <Solonarv> if you're applying a function to a list that doesn't require the tail of the list, the tail won't be evaluated
18:45:21 <lambdabot>  True
18:46:06 <taumuon> as an example, say I'm searching for the first true in a list of bools, and I want to stop after the first true is encountered
18:46:27 <jollygood2> :t any
18:46:28 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
18:46:34 <dmwit> taumuon: Great example. It's exactly the one I posted above.
18:46:37 <rotaerk> haha
18:46:41 <taumuon> LOL
18:47:10 <taumuon> sorry dmwit, got it!
18:47:20 <jollygood2> > any id (repeat True)
18:47:22 <lambdabot>  True
18:47:26 <jollygood2> > repeat True
18:47:28 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
18:47:40 <dmwit> `any id` can be spelled `or`.
18:47:51 <jollygood2> yeah, couldn't remember the name
18:48:27 <butterthebuddha> :t any
18:48:28 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
18:49:01 <butterthebuddha> > any (>2) [1,2,3,4]
18:49:04 <lambdabot>  True
18:49:16 <butterthebuddha> > any (>2) [1]
18:49:18 <lambdabot>  False
18:49:20 <butterthebuddha> Neat
18:49:47 <Solonarv> > any (>42) [1..]
18:49:49 <lambdabot>  True
18:50:00 <Solonarv> > [1..]
18:50:02 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:50:12 <taumuon> are there many situations where you have to "manually" code in recursive breaks?
18:50:22 <butterthebuddha> taumuon: what does that mean?
18:50:27 <butterthebuddha> breaks?
18:50:35 <Solonarv> what is a "recursive break"?
18:50:53 <butterthebuddha> do you mean a base case?
18:53:32 <taumuon> so I was thinking, like a accumulator variable that you could use as a flag to short circuit things if needed.. But i guess that's analagous to a pattern matched base case
18:53:49 <taumuon> ok i think i've got that straightened out in my head
18:55:30 <jollygood2> in most situations you don't have to manually recurse in haskell at all
18:59:45 <blonkhart> right just use an elgot coalgebra! http://blog.vmchale.com/article/elgot-performance
19:02:29 <rotaerk> cocreature, https://gist.github.com/Rotaerk/68a88c0456bb4286bdd137a2446200ec
19:04:21 <rotaerk> (added some exception collection during finalization)
19:04:42 <rotaerk> anyway, now to actually use/test it >_>
19:07:54 <tcsiwula> mmmm Elgot algebras <3
19:25:55 <jollygood2> > let takeLast n = reverse . take n . reverse in takeLast 2 "hi there"
19:25:57 <lambdabot>  "re"
19:26:01 <jollygood2> I could swear there was a function like this in prelude?
19:27:01 <glguy> Not that I'm aware of
19:27:29 * hackage ip 1.3.0 - Library for IP and MAC addresses  http://hackage.haskell.org/package/ip-1.3.0 (andrewthad)
19:29:32 <dreamer_> Hey
19:30:16 <dreamer_> I'm making a chess game and every time a player makes a move I store the state of the whole game in a stack
19:30:52 <dreamer_> the state includes the functions that give where pieces can go
19:31:39 <dreamer_> is the compiler smart enough to implicitly reuse the already made functions if they've been called once even if they're deeper in the stack ?
19:31:48 <dreamer_> not well worded sorry
19:31:52 <dreamer_> hope you get the idea
19:32:22 <Solonarv> I'm rather confused by your explanation, could you post your code?
19:32:57 <glguy> https://gist.github.com
19:33:50 <erisco> hoping for compiler smartness is probably a mistake
19:34:18 <Solonarv> not if what you think is "compiler smartness" is actually just a language feature
19:34:31 <Solonarv> e.g. laziness, which makes `take 3 [1..]` not blow up
19:35:41 <dreamer_> no I think just compiler smartness but I realize now it woulndt work most of the time because if a function gets evaluated but not used
19:35:49 <dreamer_> it means the stack has been popped and thus
19:36:00 <dreamer_> function no longer available
19:36:54 <dreamer_> even if the compiler could magically say "hey I remember this function being called with the exact same parameters" there's no result of the evaluation in memory or there shouldnt be
19:37:01 <dreamer_> maybe Im wrong
19:39:43 <dreamer_> Ok, just a snippet here sorry haven't uploaded to git yet
19:39:53 <dreamer_> https://lpaste.net/5717884931758096384
19:40:05 <hastuur> any monitoring systems in haskell?
19:40:20 <dreamer_> the functions I would like to be able to "reuse" are the legalMoves functions
19:40:51 <dreamer_> the results of the functions I would like to be able to reuse*
19:42:52 <hastuur> www.happstack.com looks cool
19:43:01 <hastuur> needs 1 big box tho probly
19:43:08 <Solonarv> ah, you're looking for memoization?
19:43:10 <hastuur> maybe with 40g network
19:43:28 <hastuur> is haskell more fun than other languages?
19:43:34 <hastuur> I dont know anything but bash
19:43:42 <hastuur> I tried lisp and forth a bit
19:43:44 <hastuur> didnt get far
19:44:47 <dreamer_> yeah Solonarv exactly =)
19:45:18 <dreamer_> its more for learning
19:45:24 <dreamer_> I dont think its necessary in this case
19:45:27 <Solonarv> you'll have to do that explicitly, the compiler doesn't memoize functions by itself
19:45:30 <dreamer_> the functions are not computer intensive
19:45:42 <pally> ?let list = [[1,2,3], [4,5,6], [7,8]]
19:45:43 <lambdabot>  Defined.
19:45:56 * erisco *computing intensifies*
19:46:27 <pally> is there a function to concatentate the lists within the list?
19:46:37 <dreamer_> hastuur : I love haskell but it feels a bit constraining some times
19:46:52 <dreamer_> and at others, allows you to do stuff you coulndt even dream of
19:46:53 <pally> so I get [1..8]
19:47:00 <dreamer_> concat
19:47:10 <erisco> the constraints only exist in your mind
19:47:19 <dreamer_> of course
19:47:33 <Solonarv> > concat list
19:47:36 <lambdabot>  [1,2,3,4,5,6,7,8]
19:48:04 <Solonarv> :t concat
19:48:05 <lambdabot> Foldable t => t [a] -> [a]
19:48:19 <Solonarv> :t concat @[]
19:48:21 <lambdabot> error:
19:48:21 <lambdabot>     Pattern syntax in expression context: concat@[]
19:48:21 <lambdabot>     Did you mean to enable TypeApplications?
19:49:24 <pally> I would think the type signature would be something like => t [[a]] -> [a]
19:50:15 <dreamer_> [[a]] -> [a] is a specific case of it
19:50:24 <Solonarv> :set -XTypeApplications
19:50:51 <Solonarv> :t concat :: [[a]] -> [a]
19:50:52 <lambdabot> [[a]] -> [a]
19:51:22 <geekosaur> you can't turn on TypeApplications in lambdabot
19:51:28 <geekosaur> but there;s another bot
19:51:36 <geekosaur> % :t concat @[]
19:51:36 <yahb> geekosaur: [[a]] -> [a]
19:51:53 <Solonarv> ah thank you
19:58:44 <pally> I still don't understand.
20:00:12 <Solonarv> the `t` in `Foldable t => t [a] -> [a]` can become `[]`
20:00:42 <Solonarv> so you replace `t` by `[]` and get `Foldable [] => [[a]] -> [a]`
20:01:00 <pally> oh....
20:01:08 <pally> Solonarv, now I understand :-)
20:01:15 <Solonarv> `Foldable []` is given, so the end result is `[[a]] -> [a]`
20:04:15 <pally> it says type signature says:  "type variable t has an instance of Foldable", right?
20:04:34 <pally> s/it says//
20:06:09 <Solonarv> yes
20:14:09 <geekosaur> might help to note that you can write [a] as ([] a) (or [Int] as ([] Int))
20:14:15 <geekosaur> so it behaves like Maybe, etc.
20:24:22 <pavolzetor> hello, I am strugling to figure out how to access IO inside the Foundation.Parser
20:24:52 <pavolzetor> I want to write single pass codegen without generating AST
20:25:34 <glguy> You don't access IO inside the parser. You can have the result of a successful parse be an IO (), though
20:28:29 <pavolzetor> Would I the have to manually sequence those?
20:29:00 <pavolzetor> eg do {a <- parseLhs; b <- parseRhs; pure (a >> b)}
20:29:59 * hackage shake-ats 1.9.0.0 - Utilities for building ATS projects with shake  http://hackage.haskell.org/package/shake-ats-1.9.0.0 (vmchale)
20:32:06 <pavolzetor> tested it and it seems so, that is annoying
20:32:32 <pavolzetor> thanks though, at least I can proceed :)
20:33:09 <glguy> With megaparsec you could accumulate that implicitly by using a WriterT around the parser
20:33:27 <glguy> and everything is generalized to use the MonadParsec typeclass
20:33:39 <glguy> and theres: instance (Monoid w, MonadParsec e s m) => MonadParsec e s (WriterT w m)Source
20:35:06 <pavolzetor> I will look at megaparsec
20:36:02 <Solonarv> I thought WriterT was plagued by horrible space leaks?
20:37:31 <glguy> Depends what you're doing with it
20:37:36 <glguy> in this case it's no worse than doing it manually
20:42:07 <Solonarv> I've kinda unlearned transformers that aren't ReaderT so I wasn't sure
20:43:29 * hackage shake-c 0.3.0.0 - Library for building C code with shake  http://hackage.haskell.org/package/shake-c-0.3.0.0 (vmchale)
20:51:04 <taumuon> say i wanted to look up the implementation of a function in base, like Data.Maybe.catMaybes - How would I do so?
20:51:16 <glguy> hackage has source links
20:51:33 <glguy> look on the right-hand side of the type signature in the documentation
20:53:20 <taumuon> fantastic, thanks.
21:11:18 <rotaerk> cocreature, Scope in action:  https://github.com/Rotaerk/vulkanTest/blob/master/main/src/Control/Monad/Catch/Scope.hs
21:11:28 <rotaerk> https://github.com/Rotaerk/vulkanTest/blob/master/main/src/Main.hs
21:11:48 <rotaerk> it could use some sort of improvements for usage...
21:12:33 <rotaerk> it works, but it doesn't seem right having to always be explicit about scope ... seems like there should be a default/current scope, and only require you to be explicit when using something else
21:16:03 <hololeap> is there a name for something that is both a monad and a comonad?
21:16:10 <glguy> Identity
21:16:29 <Solonarv> do something like `newtype ScopeT m a = ScopeT { runScopeT :: Scope m -> m a }`
21:17:49 <hololeap> glguy: what about ((,) e) ?
21:18:01 <glguy> That's a good one, too
21:18:22 <Solonarv> that's only a monad with Monoid e right?
21:18:34 <hololeap> right, Monoid e => ((,) e)
21:18:39 <hololeap> is there a name for those?
21:19:10 <Solonarv> I remember reading that any f which is both monad and comonad must be isomorphic to ((,) e) for some e
21:19:23 <Solonarv> not sure where I saw that though
21:19:48 <Solonarv> rotaerk: why not resourcet? https://www.stackage.org/package/resourcet
21:20:29 <rotaerk> I just replaced my usage of resourcet with that
21:20:44 <hololeap> i guess i should have searched first :/ https://stackoverflow.com/questions/27171960/is-there-a-term-for-a-monad-that-is-also-a-comonad
21:22:10 <rotaerk> and the reason is because with resourceT, you clean up resources before the end of the runResourceT by getting their key and explicitly releasing them, which then leaves some dangling references to released resources
21:23:05 <rotaerk> whereas the Scope-based approach I implemented allows interleaving of scopes while allowing language scoping to drive release, rather than calling explicit release
21:23:41 <rotaerk> I just need to look for ways to polish it
21:23:59 * hackage relational-schemas 0.1.6.2 - RDBMSs' schema templates for relational-query  http://hackage.haskell.org/package/relational-schemas-0.1.6.2 (KeiHibino)
21:25:09 <Solonarv> from looking at the source, runResourceT seems to release resources: 1) when you explicitly free them, 2) if runResourceT's argument throws an exception, 3) if runResourceT's argument finishes
21:25:43 <rotaerk> right
21:26:27 <rotaerk> withScope does #2 and #3 and avoids #1
21:27:33 <rotaerk> you might be able to nest runResourceT to achieve the same effect, but it will complicate the type like ResourceT (ResourceT (ResourceT IO)) etc
21:27:43 <Solonarv> so you're saying withScope is the same as runResourceT but the user can't explicitly free a resource?
21:27:53 <Solonarv> that doesn't sound like an advantage to me
21:28:01 <rotaerk> yeah, you don't need to explicitly free
21:28:29 <Solonarv> you don't *need* to do that in resourceT either!
21:30:36 <rotaerk> I think you can achieve the same thing with nested runResourceTs, but that changes the type for every nesting of scope
21:30:58 <rotaerk> which might not be too bad, I guess; I'll need to think about it
21:31:12 <rotaerk> I can just imagine tons of lifting
21:33:48 <Solonarv> you can nest runResourceTs or you can do (thingKey, thing) <- allocate ...; use thing; release thingKey
21:34:03 <Solonarv> or you can have one big runResourceT and wait for everything to be freed automatically at the end
21:34:42 <rotaerk> right, explicit releasing is what I'm trying to avoid, waiting for everything to be freed at the end is really bad, from a runtime behavior perspective
21:35:09 <rotaerk> so if nesting of runResourceT works well, then I might just do that instead of my scope thing
21:36:56 <Solonarv> I'm not sure where you get this idea that being able to explicitly release early is a bad thing
21:37:01 <Solonarv> in fact, hold on a minute
21:37:58 <Solonarv> if you didn't hide the IORef behind Scope you could implement explicit frees for that as well
21:38:26 <Solonarv> your code is just resourcet but you're hiding the ioref in a closure
21:40:17 <rotaerk> explicit frees are unnecessary, and they have the downside of leaving dangling references
21:40:26 <rotaerk> instead free by letting a scope end
21:41:02 <rotaerk> it also complicates the code a little by having to capture keys
21:42:52 <Solonarv> so define allocate' :: MonadResource m => IO a -> (a -> IO ()) -> m a; allocate' create free = snd <$> allocate create free
21:42:53 <Solonarv> and use that
21:43:21 <rotaerk> yeah I did that
21:43:49 <rotaerk> I'm saying when you DO want to release things, you have to deal with keys ... unless nesting runResourceT works
21:44:05 <Solonarv> nesting does work
21:44:14 <Solonarv> and how would you do it without dealing with keys?
21:45:00 * hackage text-postgresql 0.0.3.1 - Parser and Printer of PostgreSQL extended types  http://hackage.haskell.org/package/text-postgresql-0.0.3.1 (KeiHibino)
21:45:53 <rotaerk> Solonarv, here's the version of my code using resourceT: https://github.com/Rotaerk/vulkanTest/blob/6cfdd345bd858852972477f3dafe2356d2921a20/main/src/Main.hs#L908-L922
21:46:05 <rotaerk> currently with explicit releases ... lemme try rewriting this using nested runResourceT
21:50:10 <rotaerk> Solonarv, un-tested but something like:  https://gist.github.com/Rotaerk/b71258897ca80eb36ff1e404212b3dd4
21:50:31 <Solonarv> yeah that looks about right to me
21:50:52 <rotaerk> if that works as expected then I might drop this Scope thing
21:51:09 <rotaerk> oops, didn't indent the final line
21:51:35 <Solonarv> as far as I can tell your Scope thing is just a primordial resourceT anyway
21:52:29 * hackage persistable-types-HDBC-pg 0.0.3.3 - HDBC and Relational-Record instances of PostgreSQL extended types  http://hackage.haskell.org/package/persistable-types-HDBC-pg-0.0.3.3 (KeiHibino)
21:52:32 <rotaerk> one "advantage" the scope thing has is that scopes are passed explicitly, so you can provide a scope an arbitrary number of levels out
21:52:41 <rotaerk> whereas with runResourceT, I have to lift N times
21:52:49 <rotaerk> but that's probably not that useful of an advantage
21:52:53 <Solonarv> that just means you unwrapped the ReaderT
21:53:00 <Solonarv> you can do that with ResourceT if you really want
21:53:35 <Solonarv> https://www.stackage.org/haddock/lts-11.14/resourcet-1.2.1/Control-Monad-Trans-Resource.html#g:10
21:54:13 <rotaerk> I'm not sure how that would achieve what I'm talking about
21:55:10 <rotaerk> note that the type of line 4 in my code snippet is ResourceT ResIO Handle
21:55:30 <rotaerk> and theoretically I could have a ResourceT (ResourceT (ResourceT ResIO)) Handle
21:55:53 <rotaerk> and to access the innermost one, I would have to lift 3 times
21:55:55 <Solonarv> instead of hiding the `IORef [m ()]` in a closure, you can do newtype Scope m a = Scope { scopeFinalizers :: IORef [m ()] }
21:56:24 <rotaerk> I hid it in a closure because I implement that closure differently in withScopeLiftedTo
21:56:48 <rotaerk> I used to store the IORef inside of Scope
21:57:30 <Solonarv> now InternalState is Scope, ReleaseKey is Int, and you've got a ResourceT
21:57:31 <Solonarv> ah, yes
21:58:09 <Solonarv> if m is not an instance of MonadUnliftIO then whatever you're doing risks being unsound anyway
21:58:48 <Solonarv> so you can just use an IORef [IO ()] and use unliftio methods to convert your handlers into IO ()
21:59:50 <rotaerk> the purpose of withScopeLiftedTo is, for instance, to turn a `Scoped IO a` into a `MonadIO io => Scoped io a`
22:00:02 <Solonarv> anyway I'd love to stick around but tiredness is eroding my already questionable expertise
22:00:12 <Solonarv> yeah you can't do that soundly for a general MonadIO
22:00:37 <Solonarv> because exception safety
22:00:51 <rotaerk> could you give an example of how it colud be misused?
22:02:35 <Solonarv> uh just go look up some examples of why you can't bracket a StateT
22:02:37 <Solonarv> sorry, tired
22:03:57 <rotaerk> withScopeLiftedTo someMonadIOScope liftIO $ scoped someIOCreate someIORelease
22:04:23 <rotaerk> I would think that if it was unsound, there wouldn't be a lifting function that could be passed in to the second parameter
22:04:34 <rotaerk> anyway, bed time for me too
23:08:06 <pally> As a someone who is new to Haskell, I find myself using list comprehension most.
23:08:21 <rotaerk> I can't remember ever using it
23:08:27 <rotaerk> I usually forget it exists
23:10:26 <pally> I like the syntax, and I've grown to use it more than `filter` when I need to any filtering.
23:11:04 <pally> err, need to *do
23:22:21 <wz1000> Is there a wrapper for Map with instance (Ord k, Semigroup a) => Semigroup (Map k a)?
23:24:22 <wz1000> ok, found the discussion
23:24:24 <wz1000> https://mail.haskell.org/pipermail/libraries/2018-February/028519.html
23:34:04 <darkJedi> Hi! I had a doubt in Maybe Monad. https://lpaste.net/8585096319930990592
23:34:32 <darkJedi> What is MonadPlus instance?
23:35:09 <cocreature> wz1000: when I read these discussions I sometimes hope for some kind of benevolent dictator for core libraries so not all of them end in a ton of bikeshedding :/
23:35:38 <cocreature> darkJedi: what exactly do you mean? you have already defined the instance, so I’m not sure what you are asking?
23:37:46 <darkJedi> cocreature: I'm sorry. It's not my code. I have taken the code from the course Functional Programming in Haskell by University of Glasgow.
23:38:00 <cocreature> darkJedi: so are you asking about the purpose of the MonadPlus typeclass?
23:38:11 <darkJedi> cocreature: Yes
23:38:25 <cocreature> darkJedi: are you familiar with Alternative?
23:38:57 <darkJedi> cocreature: No I'm not familiar with Alternative.
23:39:10 <pally> I want to test a list contains an element that safisties a condition, and immediately returns `True` if one is found
23:39:17 <pally> I know there's `find`
23:39:42 <fishythefish> :t any
23:39:42 <pally> but that gives me a Maybe
23:39:43 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
23:39:45 <cocreature> darkJedi: alright, so just so you won’t get confused later: Alternative and MonadPlus are basically the same typeclass. the reason why we have both is mostly historical
23:40:15 <cocreature> darkJedi: now MonadPlus (https://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Monad.html#t:MonadPlus) gives you two methods: mzero and mplus
23:40:29 <cocreature> darkJedi: are you familiar with the Monoid typeclass?
23:41:38 <fishythefish> > any even [1, 3 .. 99]
23:41:41 <darkJedi> cocreature: One doubt! The use of instance is to create something be combining the properties of whatever we are adding in ```instance Monad Maybe where``` right?
23:41:41 <lambdabot>  False
23:41:42 <fishythefish> > any (== 22) [1..]
23:41:44 <lambdabot>  True
23:41:53 <fishythefish> pally ^
23:42:03 <darkJedi> cocreature: Is it the correct way to think about instance?
23:42:05 <cocreature> darkJedi: sry I don’t understand the question, can you perhaps try rephrasing it?
23:42:35 <cocreature> `mplus` is useful for getting the first `Just` value
23:42:49 <pally> fishythefish, thanks pal;  illustrates lazy too.
23:42:54 <cocreature> mzero is the identity for mplus so mzero `mplus` x = x and x `mplus` mzero = x
23:42:57 <taumuon> pally: thanks for asking about that, i wanted to know too.
23:43:01 <darkJedi> cocreature: What is the use of instance?
23:43:25 <cocreature> > Nothing `mplus` Nothing `mplus` Just 1 `mplus` Nothing
23:43:27 <lambdabot>  Just 1
23:43:33 <cocreature> > Just 3 `mplus` Nothing `mplus` Just 1 `mplus` Nothing
23:43:36 <lambdabot>  Just 3
23:43:42 <cocreature> so it always gives you the first Just value
23:43:54 <fishythefish> darkJedi: typeclasses/instances give you a way to constrain polymorphism
23:44:59 <fishythefish> for instance, we want (==) to be polymorphic so we don't have a separate operator for each type
23:45:07 <fishythefish> but not every type supports equality
23:45:19 <fishythefish> :t (==) -- so we use the Eq typeclass
23:45:20 <lambdabot> Eq a => a -> a -> Bool
23:47:26 <darkJedi> fishythefish: How do we specify which types are instance of the class Eq ?
23:47:39 <fishythefish> darkJedi: by writing `instance Eq MyType where ...`
23:47:42 <yasshek> Hi trying to learn new language and many haskell a good try
23:47:56 <jle`> yasshek: welcome to haskell :D
23:48:19 <darkJedi> fishythefish: Thanks :) I will read more about it from https://www.haskell.org/tutorial/classes.html
23:48:26 <fishythefish> darkJedi: as a result, this lets me substitute `MyType` in places where `Eq a => a` is expected
23:48:56 <yasshek> jle`:D
23:49:07 <yasshek> https://www.haskell.org/tutorial/  should I start here ?
23:49:16 <yasshek> one thing I found haskell not staright
23:49:32 <jle`> @where learnhaskell
23:49:32 <lambdabot> https://github.com/bitemyapp/learnhaskell
23:49:49 <jle`> but to be honest i had never seen that tutorial before you sent it
23:50:04 <jle`> it doesn't look like it has any exercises though
23:50:35 <taumuon> jle: i read that was the go to tutorial for a while back in the day
23:51:19 <taumuon> mostly because it was one of the only ones :)
23:52:30 * hackage starter 0.3.0 - Develop applications without restarts  http://hackage.haskell.org/package/starter-0.3.0 (rkaippully)
23:53:34 <taumuon> yasshek, have you done any graphics programming before?
23:54:00 <yasshek> taumuon: never why ?
23:54:07 <yasshek> taumuon:  is it important ?
23:54:34 <taumuon> no, i just thought I'd ask you, as this course starts you out with some graphics programming http://seas.upenn.edu/~cis194/fall16/
23:54:46 <taumuon> it's a fun way to start if you like that kind of thing
23:55:52 <yasshek> taumuon:  started now :)
23:58:16 <yasshek> Instead of following the instructions on Haskell.org, get Stack.   why ?
23:58:41 <yasshek> what is stack is it something like virtualenv ?
