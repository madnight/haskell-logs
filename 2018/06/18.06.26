00:25:24 <halogenandtoast> Also fun to have platform issues
00:25:42 <halogenandtoast> dminuoso: is there a particular reason you asked about that method, the definition was in that file
00:25:52 <halogenandtoast> am I doing something non-standard there?
00:35:34 <tdammers> looks very standard
00:35:43 <tdammers> the problem is a common one too
00:36:00 <tdammers> you have a series of checks that might fail, and you want to bail on the first failure that you encounter
00:36:10 <dminuoso> halogenandtoast: The main thing I just notice is that you have no mechanism to transport information *what* went wrong.
00:36:30 <Ariakenom> :t guard
00:36:31 <dminuoso> halogenandtoast: That is you have a couple spots where a registration might fail - but as it is right now you cant communicate as to what went wrong.
00:36:31 <lambdabot> Alternative f => Bool -> f ()
00:36:35 <tdammers> well; that's pretty much the Monad instance of Maybe, Either, or Error/Except right ther
00:36:52 <dminuoso> halogenandtoast: So `Either` or specific exceptions might be more suitable
00:37:45 <halogenandtoast> Hmm I guess I'm not sure how to correctly handle/rethrow the error into something more meaningful, the structure looks like this `SqlError {sqlState = "23505", sqlExecStatus = FatalError, sqlErrorMsg = "duplicate key value violates unique constraint \"unique_user\"", sqlErrorDetail = "Key (email)=(halogenandtoast@gmail.com) already exists.", sqlErrorHint = ""}`
00:38:08 <halogenandtoast> None of that is in a format I'd want to share with the user
00:38:24 <halogenandtoast> and it's not really in a good format for pattern matching on the error
00:38:47 <tdammers> you'd have to pick up the sqlState and map it to something meaningful
00:38:51 <halogenandtoast> I'm really surprised that persistent didn't have something better for catching errors
00:39:14 <tdammers> it's kind of bad that these sqlState codes are DBMS-specific (I think)
00:39:28 <dminuoso> halogenandtoast: You could just use ExceptT?
00:39:37 <halogenandtoast> yeah I guess 23505 is unique_violation
00:40:30 <Ariakenom> Oh it's the same nice semantics of errno?
00:42:04 <halogenandtoast> dminuoso: Maybe, I feel like I just barely understand transformers at the moment
00:43:43 <halogenandtoast> I'll spend some time trying some things out here
00:43:48 <halogenandtoast> to see if I can get more useful errors.
00:43:57 <halogenandtoast> I assume some of them should be at the form level, and some at the database
00:45:27 <Ariakenom> halogenandtoast: Are there expected errors and unexpected errors?
00:47:27 <tdammers> actually, in this context, there are only a handful of interesting things to tell the user
00:47:38 <Ariakenom> For unexpected database errors you might just present it as "internal" error or whatever. And you can probably need to add expected errors that need a message yourself. The db view of what's wrong probably doesn't match the user's view?
00:47:45 <tdammers> 1) is the problem caused by something on your side or mine?
00:48:02 <tdammers> 2) can resending the request help?
00:48:25 <tdammers> 3) if the problem is on your end, what do you need to change?
00:48:28 <tdammers> and that's basically it
00:48:53 <tdammers> and for security reasons, it's better to provide too little information than too much
00:49:29 <halogenandtoast> Sure, that's all fair, one question is whether or not to let the user know if the email already exists
00:49:45 <halogenandtoast> I've always seen this is a potential vector, but at the same time not letting the user know seems strange
00:50:13 <Ariakenom> Can they reasonably assume from the operation failing anyway?
00:50:44 <halogenandtoast> "Failed to sign up. You may or may not already have an account"
00:50:49 <Ariakenom> :p
00:51:39 <Ariakenom> Is there good terminology for "error"s somewhere? It's too broad.
00:57:49 <Ariakenom> The user existing & user not existing cases are more similar than an out of user not existing & memory error
00:58:28 <Ariakenom> than user not existing & out of memory error
00:59:02 <halogenandtoast> My application will "never" have an out of memory error!
00:59:06 <tdammers> enumerating user accounts is a vulnerability, but not a very severe one
00:59:36 <tdammers> also, a lot of apps out there do it wrong anyway
00:59:49 <halogenandtoast> tdammers: care to expand?
00:59:49 <tdammers> they won't tell you that the account name was wrong on the login page
01:00:06 <tdammers> but then when you try to file a "forgot password" request, they will tell you anyway
01:00:47 <tdammers> and even if they don't, you're still left with the problem that you can just try to sign up, and if that doesn't work you know that the account already exists
01:01:15 <tdammers> the defense against that is to accept the request anyway, and stop at the "please verify your e-mail address" step
01:01:27 <halogenandtoast> Yeah
01:01:34 <tdammers> but hardly anyone does that
01:02:08 <halogenandtoast> because it's annoying to the consumers and most apps want to gate them as little as possible
01:02:20 <halogenandtoast> it's proven to be more effective to capture as little as possible and let them in the gates
01:03:02 <halogenandtoast> if effectiveness is a measurement of convincing users to use your app (and/or potentially pay for it)
01:03:29 <halogenandtoast> Do you want to do the right thing and make potentially less money, or the slightly wrong thing and make more
01:03:48 <halogenandtoast> and we can all guess where most fall on that issue
01:04:01 <halogenandtoast> that or they're using some library that has already decided for them and can't be bothered.
01:06:33 <tdammers> yes
01:06:39 <tdammers> also, security isn't a boolean
01:07:06 <tdammers> it's often more profitable to accept a mild degree of vulnerability
01:07:14 <tdammers> this is why PIN codes are usually only 4 digits
01:08:12 <tdammers> easy to guess, but also a lot easier to remember, which drastically reduces the number of support calls, card reissue requests, cards being withdrawn due to incorrect PIN entry, and people writing their PIN down on or near the card
01:08:49 <dminuoso> halogenandtoast: Regarding monad transformers, merijn has done a nice homework: https://gist.github.com/merijn/098106abd45c940dab09  - just implement State and then StateT. You can then repeat the same excercise for Cont/ContT, Maybe/MaybeT, Reader/ReaderT - you will notice a pattern
01:08:58 <tdammers> so instead of using a 16-digit PIN, which would be a lot more secure in theory, you use 4 digits, and then log every goddamn thing, block the card after 3 incorrect attempts, etc
01:10:39 <dminuoso> halogenandtoast: You can do this for all the monads (though ListT is surprisingly difficult, so you should probably skip it), it's a very useful excercise. :)
01:10:56 <mniip> dmwit, almost
01:11:01 <mniip> it's just unsafecoerce at the moment
01:11:46 <dminuoso> halogenandtoast: Oh and Writer/WriterT. Those should be the common monad transformers. =)
01:14:49 <simon> I've got a function 'foo :: Monad m => ... -> m Bool' that I wish to repeat until it returns true: go = foo >>= (`unless` go) -- is there a monadic fixpoint combinator for this?
01:15:54 <liste> simon: https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:untilM
01:16:14 <liste> or iterateUntil maybe
01:16:19 <mniip> whileM?
01:18:27 <simon> it seems that they assume some 'm Bool' as the condition and some 'm a' as the result. so: foo `untilM_` return ()?
01:18:54 <simon> whoops, return () `untilM_` foo
01:19:08 <liste> simon: would iterateUntil do just what you want?
01:20:20 <c50a326> would it be possible to be a productive programmer in haskell without ever understanding monads?
01:20:36 <simon> c50a326, yes.
01:20:37 <mniip> if you're in 1995 maybe
01:20:51 <simon> c50a326, by the time you're a productive programmer in Haskell, it'll be a non-issue.
01:20:53 <mniip> but to be a productive programmer ever you need to strive to understand new stuff
01:20:56 <dminuoso> c50a326: Probably not. But Monads are not hard to learn. :)
01:21:08 <simon> c50a326, it is a false predicament.
01:21:12 <dminuoso> c50a326: Dont focus on learning monad, it comes on its own.
01:22:37 <simon> liste, no, iterateUntil :: Monad m => (a -> Bool) -> m a -> m a, and I have a 'Monad m => m Bool' that I want to iterate until it returns false.
01:22:51 <simon> liste, I want something like Control.Monad.forever, except not forever. :D
01:23:08 <mniip> simon, iterateUntil not foo
01:23:28 <mniip> though that's arguably on the same level as  return () `untilM_` foo
01:23:45 <simon> mniip, liste ah, I'm clearly not reading the type signature correctly.
01:24:14 <simon> mniip, I do like that slightly more than what I suggested, but probably not enough to add a dependency for this one line. ^_^
01:24:20 <mniip> you could also
01:24:24 <mniip> andM $ repeat foo
01:24:38 <mniip> though that kind of requires to turn your brain on when reading
01:25:02 <simon> isn't repeat list-specific?
01:25:11 <simon> sorry, non-monadic.
01:25:33 <mniip> foo :: M Bool
01:25:39 <mniip> repeat foo :: [M Bool]
01:25:45 <mniip> just as andM expects
01:26:10 <mniip> oh er
01:26:15 <mniip> I forgot to turn the brain on
01:26:18 <mniip> it's orM
01:26:26 <mniip> you need to iterate while it's false
01:26:33 <dminuoso> c50a326: The thing is, modern code uses a lot of monads and applicatives. Monad transformer stacks are rather common, you have monadic parser combinators. A lot of the really powerful tools in Haskell somehow rely on Applicative at least.
01:26:34 <simon> oh, right. I understood.
01:27:20 <mniip> dminuoso, I'd like to see monoid transformers be more popular than they are now :(
01:27:20 <halogenandtoast> dminuoso: thanks for the link, I'll check it out
01:29:09 <dminuoso> mniip: Are you talking about this? https://www.disi.unige.it/person/MoggiE/ftp/tcs10.pdf
01:30:10 <mniip> I don't suppose so
01:30:38 <dminuoso> Then Im curious. What is a monoid transformer?
01:31:30 <mniip> really just some T with an instance Monoid m => Monoid (T m)
01:31:46 <mniip> that alters m's behavior in some useful way
01:31:47 <tdammers> I would guess some type :: * -> * that transforms monoids like a monad transformer transforms monads
01:32:03 <halogenandtoast> Does anyone have any guidance on integrating something like VueJS with a Yesod app, I'm not sure how to setup a good way to build the assets and have Yesod reference them.
01:32:48 <tdammers> halogenandtoast: if you're going to use Vue or React or Angular, you're most likely building an SPA, and Yesod might not be the right tool
01:33:08 <tdammers> after all, you only need an API and a static file server then
01:33:23 <tdammers> none of that server-side dynamic HTML stuff that most of Yesod is about
01:33:50 <dminuoso> I can think of a few reasons to use React in a static server generated page setting.
01:34:10 <tdammers> maybe so
01:34:13 <mniip> @let newtype Share m = Share { getShare :: [[m]] } deriving Show
01:34:15 <lambdabot>  Defined.
01:34:18 <tdammers> it doesn't really fit Yesod's model though
01:34:19 <mniip> @let instance Monoid m => Monoid (Share m) where mempty = Share $ [mempty]:repeat []; mappend (Share x) (Share y) = Share $ join <$> zipWith (liftA2 mappend) x <$> reverse <$> tail (inits y)
01:34:20 <lambdabot>  Defined.
01:34:21 <halogenandtoast> tdammers: Do you have a suggestion outside of Yesod for building APIs?
01:34:26 <halogenandtoast> servant maybe?
01:34:28 <tdammers> halogenandtoast: Servant?
01:34:40 <tdammers> halogenandtoast: or if you don't need the decorum, Scotty?
01:34:46 <mniip> > getShare . foldMap (\x -> Share $ [[mempty], [pure x]]) $ "123" :: [[String]]
01:34:48 <lambdabot>  [[""],["3","2","1"],["23","13","12"],["123"],[],[],[],[],[],[],[],[],[],[],[...
01:34:58 <mniip> here's a nice Monoid transformer
01:34:59 <halogenandtoast> I've used Scotty for one other project and liked it
01:35:11 <halogenandtoast> I haven't touched Servant yet
01:35:46 <halogenandtoast> Maybe I'll try using Miso instead of VueJS
01:35:58 <halogenandtoast> and just build two apps and hook them together with some glue
01:36:35 <cocreature> regardless of which frontend lib you end up using, for your backend that’s usually just a bunch of static files that need to be served
01:36:47 <mniip> hmm
01:37:07 <halogenandtoast> cocreature: I figured the backend needs to talk to a DB
01:37:15 <halogenandtoast> and return JSON
01:37:39 <cocreature> halogenandtoast: sure but I don’t see how that contradicts my statement that the frontend is just a bunch of static files
01:37:59 <halogenandtoast> cocreature: I read your statement wrong
01:41:02 <mniip> dminuoso, I also implemented semidirect monoid product at one point
01:41:12 <mniip> or more specifically, semidirect monoid x group product
01:41:34 <mniip> it was for that advent of code hashing challenge
01:46:00 * hackage relational-query 0.12.0.0 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.12.0.0 (KeiHibino)
01:56:17 <c50a326> hey why does stack produce binaries with "-exe" on the end... I don't like that :(
01:56:20 <c50a326> it reminds me of windows
01:56:52 <c50a326> I invested a lot of time into becoming a linux guy for political reasons and now my binaries are ending with exe...
01:58:25 <liste> c50a326: probably to distinguish an executable from a library - they can have the same name
01:59:44 <tdammers> that's just the stack default template
01:59:58 <tdammers> you can edit the cabal file or whatever to change it
02:00:07 <hvr> you can chagne the suffix to .exe
02:00:21 <hvr> 'executable foo.exe` if that's better
02:00:27 <tdammers> uhm
02:00:32 <hvr> tdammers: just kidding =)
02:00:32 <c50a326> ah, in the executable line in the cabal file
02:00:33 <Ariakenom> uhm
02:00:37 <cocreature> hvr: you’re an evil person
02:00:53 <Ariakenom> -vs2008.exe
02:00:53 <hvr> cocreature: evil would be to suggest 'executable foo.com'
02:01:08 <c50a326> also what's the best dev flow? just edit files and then stack build && stack exec [executable name] manually?
02:01:14 <tdammers> executable AUTOEXEC.BAT
02:01:19 <hvr> lol
02:01:21 <c50a326> I guess I should use intero
02:01:23 <Ariakenom> oh god
02:01:48 <dminuoso> c50a326: Be prepared for frustration.
02:01:58 <dminuoso> c50a326: Im on the brink of switching to ghcid.
02:02:07 <tdammers> c50a326: that would work, yes. personally, I have developed a habit of scripting a development loop and put that in ./run-devel.sh
02:02:38 <tdammers> c50a326: that loop watches for file changes, automatically recompiles, and restarts or kicks whatever needs restarting or kicking
02:02:59 <c50a326> tdammers: that sounds cool, can you paste it?
02:03:04 <tdammers> c50a326: the beauty of it is that you can hook all sorts of things into that script - stack install --file-watch, but also stuff like SASS compilation, unit tests, etc.
02:03:08 <c50a326> what do you use to watch? inotify?
02:03:13 <c50a326> oh stack has an option?
02:03:55 <tdammers> c50a326: inotify if nothing else is available, but stack has --file-watch, sass can watch too, browserify has watchify, etc.
02:04:03 <tdammers> https://github.com/tdammers/sprinkles/blob/master/run-devel.sh <- here's an example btw
02:04:45 <c50a326> damn, stack exec doesn't have --file-watch
02:04:52 <c50a326> only build and install
02:04:55 <tdammers> no, of course not
02:05:30 <cocreature> afaik you can use stack build --file-watch --exec "stack exec abc"
02:05:34 <tdammers> it's not obvious what the semantics of stack exec --file-watch should be
02:05:47 <cocreature> although I’m not sure if that works properly, i.e., kills the running binary
02:05:56 <tdammers> should it run the program, then wait for it to terminate, then wait for file changes and run it again?
02:06:11 <tdammers> or should it fork off the program, wait for file changes, then kill the program and restart it?
02:06:43 <tdammers> for something like a one-shot CLI utility, you'd want the first; for a server-like thing, the latter
02:08:16 <cocreature> the --exec option might be useful either way
02:08:51 <tdammers> yes
02:08:56 <c50a326> yeah thanks
02:09:11 <tdammers> but it's not super important, because you can easily script up the equivalent yourself, and that gives you full control
02:13:51 <c50a326> but it's nice when you don't have to script everything up all the time
02:16:48 <trcc> I am trying to figure out the whole cabal/stack/nix. Previously I decided on cabal, but I was missing good IDE integration, so I switched to stack because of intero mode. But I guess intero mode will not work with nix, so what is used instead?
02:18:31 <merijn> trcc: "It Depends"
02:18:39 <merijn> I don't think there's a single golden solution atm
02:19:24 <trcc> merijn: ok. Guess i'll stick to stack then because of intero, and maybe try the nixintegration
02:32:02 <dminuoso> Does cabal have some mechanism to deal with packages that have overlapping modules?
02:33:20 <merijn> dminuoso: No, GHC has package imports to work around that
02:33:31 <merijn> dminuoso: But in general the solution is "don't reuse module names"
02:38:53 <dminuoso> merijn: Ah I see.
02:39:56 <c50a326> hey I made this in src/JLib.hs https://lpaste.net/4357273308526280704 if I then `stack ghci` and J tab, I get: *Main JLib Lib> J
02:39:58 <c50a326> JLib.JValue  JValue       Just
02:40:11 <c50a326> so these things seem to be imported, but if I try to use them I get data constructor not in scope
02:40:37 <cocreature> c50a326: you need to put JValue(..) in the export list
02:40:42 <cocreature> JValue will only export the type
02:40:49 <cocreature> JValue(..) will export the type and all its constructors
02:41:24 <c50a326> oic
02:41:56 <mniip> hmm
02:42:09 <mniip> I can write  class (forall a. a) => Cls
02:42:13 <mniip> to make sure it is never instantiated
02:42:53 <mniip> is there something similar that I can write that doesn't lead to a collapse of the constraint solver if I do actually end up with a dictionary for such a class
02:55:43 <freeman42x]NixOS> is there a recommended way of dealing with non-exhaustive patterns in the case when it is know for certain that one of the patterns will never be matched? should I use error "this should never happen" or undefined or what is recommended to do in that case?
02:56:48 <dminuoso> freeman42x]NixOS: Personally I use things along the lines of: error "this should never happen"
02:57:10 <Ariakenom> Is there a point to adding an explicit error?
02:57:18 <cocreature> Ariakenom: avoiding warnings
02:57:31 <Ariakenom> ok makes sense
02:57:34 <cocreature> also you can often give a better error message than the default one
02:57:48 <dminuoso> In case you turned out to be wrong...
02:58:20 <c50a326> how do you know when to use record syntax and when not to
02:58:33 <cocreature> you could have been right when you’ve written the code but some part of the code invalidated your assumption
02:58:45 <Ariakenom> ofc make that state impossible would be best.
02:58:49 <freeman42x]NixOS> cool, thank you
02:59:05 <cocreature> sure but that’s not always easily possible
03:01:33 <dminuoso> Considering that even I have triggered a few "the 'impossible' happened" in GHC..
03:02:11 <c50a326> lol this guy's blog motto is cool "functional programming debugs you" http://nikita-volkov.github.io/record/
03:03:36 <c50a326> the record syntax example in LYAH is only using built in types... I wonder if I can use my own types in record syntax, like in the JSON example in the paste above
03:03:39 <c50a326> guess I'll try
03:04:02 <Rembane> c50a326: I use record syntax when I have many fields in a type. Or when I need an easy way to access them.
03:04:05 <mniip> wait
03:04:15 <mniip> oooh
03:04:23 <mniip> you can have newtype instances for data families
03:04:32 <asheshambasta> So as I've embarked on my first production project with Haskell, I've been hearing horror stories about `String` all along. This project needs to do a decent bit of FilePath generation (concatinating various things together to generate paths) -- should I be worried about this?
03:04:44 <asheshambasta> case in point: https://hackage.haskell.org/package/rawfilepath-0.2.4#readme
03:06:22 <c50a326> ah I get this error https://lpaste.net/8452933677947551744
03:06:33 <Rembane> asheshambasta: Reading from or writing to disk should be glacially slower than concatenating file paths.
03:06:53 <tdammers> asheshambasta: many of the issues mentioned in that link aren't as bad as they seem
03:07:47 <tdammers> e.g., when you have strings that you only traverse once, in linear fashion, then they still use 24 bytes per character, but there is only a small, constant number of chaacters in physical RAM at a time, due to GC and lazy evaluation
03:08:22 <tdammers> malloc/free aren't used naively on this memory either; GHC uses its own allocator, and it's pretty good at dealing with lots of small allocations and deallocations
03:08:57 <asheshambasta> Rembane: tdammers: okay, thanks for clarifying. I'm going to stick with using FilePath for now and think about this when it becomes an issue
03:09:12 <Rembane> asheshambasta: That sounds like a good plan.
03:09:15 <tdammers> yes. and if in doubt, profile
03:09:15 <c50a326> I was just tryig to do the record syntax equivalent of the stuff that is commented
03:10:01 <Rembane> c50a326: The name of the fields need to start with a lowercase letter.
03:10:30 <c50a326> oh I think I don't want to define a record, only a type
03:10:34 <c50a326> so I can't use record syntax
03:10:47 <c50a326> I mean the fields shouldn't have names, it's just a definition of the types in JSON...
03:11:04 <mniip> wowie
03:11:04 <c50a326> I just wanted to do what is commented except generate those accessor functions
03:11:11 <c50a326> is that possible? I guess not
03:11:20 <mniip> holes are quite laggy
03:11:43 <Rembane> c50a326: I think you want to use a sum type.
03:11:53 <dminuoso> ^- this :)
03:11:55 <Rembane> mniip: Compiling-sword-fight-laggy?
03:12:10 <c50a326> sum type == ADT?
03:12:10 <mniip> about 1.5 seconds per :t _
03:12:15 <liste> c50a326: "data JValue = JString { jString :: String }| JNumber { jNumber :: Double } etc
03:12:23 <liste> c50a326: BUT note that the accessors are partial
03:12:32 <liste> so you get nasty crashes at runtime if you misuse them
03:12:42 <liste> so better define your own JValue -> Maybe Whatever accessors
03:12:49 <dminuoso> c50a326: What you are writing is a product type. Here's an equivalent form of what you wrote: `data JValue = JValue (String, Double, Bool, (), [String, JValue], [JValue])
03:13:08 <dminuoso> (Or rather tried to write)
03:13:17 <c50a326> dammit I always hate this stuff
03:13:22 <c50a326> this is why I hated java, it's so abstract
03:13:25 <c50a326> how do you practice
03:13:28 <__monty__> c50a326: Your two definitions are not equivalent, the first one is ~equivalent to `data JValue = JValue String Double Bool...`
03:13:36 <c50a326> with procedural and logic stuff it's easy, you just practice simple problems
03:13:46 <c50a326> with all this types stuff it's hard to figure it out practically
03:14:03 <Rembane> mniip: That is at least enough to draw a sword.
03:14:26 <dminuoso> c50a326: Haskell has a very dense mentality where we try to write compact code. It takes some getting used to.
03:14:48 <dminuoso> c50a326: If you want you can use GADTSyntax, it might help with some things.
03:15:12 <__monty__> c50a326: You're just not used to thinking about the problems up front. You're probably used to writing something wrong, then testing and refining it.
03:16:00 * hackage hzenity 0.2 - Haskell interface to Zenity dialogs  http://hackage.haskell.org/package/hzenity-0.2 (EmilAxelsson)
03:16:19 <c50a326> yeah pretty much. this page seems good, I'm going to read this http://www.cis.upenn.edu/~cis194/spring13/lectures/02-ADTs.html
03:16:25 <c50a326> LYAH sucks on types imo
03:17:00 <c50a326> also how does Show always know how to work?
03:17:29 <dminuoso> c50a326: deriving produces the necessary code.
03:18:45 <__monty__> I'm not convinced GADTs will help, they're very boilerplatey for simple types. I'd just hold off on record syntax until you're used to ADTs.
03:19:44 <malorie> when dealing with Text, is there a way to have ghci show readable strings?
03:19:52 <c50a326> also how do you guys read the | when you're reading the definitions?
03:19:59 <dminuoso> c50a326: +
03:20:03 <c50a326> I keep reading it as "or" in my head, not sure if this is healthy though
03:20:12 <Rembane> It is an or.
03:20:16 <liste> "or" is not wrong
03:20:29 <c50a326> oh ok cool
03:20:30 <Rembane> Either the type is a ... or a ... or a ...
03:20:30 <liste> "type JValue is an JObject or a JNumber or ...
03:20:40 <Rembane> liste: ^5!
03:20:53 <c50a326> dminuoso: why did you say +
03:21:02 * liste ^5s Rembane
03:21:08 <Rembane> \o/
03:21:08 <liste> c50a326: because it's a sum type
03:21:30 <liste> also has connections to the mathematical sum
03:21:39 <Rembane> Or the boolean one
03:21:55 <c50a326> are sum type and adt synonymous?
03:22:12 <liste> c50a326: Algebraic Data Types are sum and product types
03:22:19 <liste> sums of products, usually
03:22:49 <liste> c50a326: "data Foo = MkFoo Int String" -- a product type
03:22:51 <dminuoso> c50a326: `Maybe` for example is a type constructor that takes an arbitrary type and adds 1 (Nothing) to it. :)
03:23:02 <dminuoso> data Maybe a = Just a | Nothing
03:23:25 <liste> "data Bar = MkBar1 Int | MkBar2 String" -- a sum type
03:23:58 <dminuoso> c50a326: Btw regarding GADTSyntax. Here's two equivalent forms of your JValue data type. https://gist.github.com/dminuoso/2582b445e325adeba4ae8f1233ea513e
03:24:07 <dminuoso> c50a326: Be your own judge which one is more readable.
03:24:13 <c50a326> dminuoso: are things in lower case always arbitrary data types or is there another rule about that?
03:24:39 <liste> c50a326: lower case identifiers are always type variables in type definitions
03:25:32 <c50a326> oh I forgot the left side of the =
03:25:43 <c50a326> Maybe a = ... that's where the arbitrary a type comes from, sorry
03:25:53 <dminuoso> data Maybe a = Just a | Nothing
03:25:55 <dminuoso> add a = a + 1
03:26:15 <c50a326> just confusing because you seem to be able to define new data types on the right side of a new data type
03:26:25 <dminuoso> c50a326: Consider my last gist.
03:26:25 <c50a326> like JString and JObject etc on the right side of JValue
03:26:32 <c50a326> dminuoso: im looking :D
03:26:40 <liste> c50a326: those are not data types
03:26:46 <liste> c50a326: those are constructors
03:26:52 <dminuoso> c50a326: I used GADTSyntax in the bottom. It makes it a bit more obvious that JString is a function (also a data constructor here).
03:27:01 <dminuoso>   JString :: String -> JValue
03:27:07 <dminuoso> JString is a function from String to JValue
03:27:14 <c50a326> ohhhh yeah
03:27:53 <c50a326> could JObject be JObject :: [(JString, JValue)] -> JValue
03:28:13 <c50a326> rather than JObject :: [(String, JValue)] -> JValue
03:28:19 <liste> c50a326: no
03:28:22 <liste> JString is not a type
03:28:36 <c50a326> but it's a data constructor that returns a JValue isnt it
03:28:41 <liste> yes
03:28:47 <liste> JValue is the type
03:29:02 <liste> so it'd be JObject :: [(JValue, JValue)] -> JValue then
03:29:09 <c50a326> right I was just typing that
03:29:25 <c50a326> but that would be crazy because then you could have all sorts of stuff as keys, ok, claro
03:29:54 <c50a326> irc is the best book on haskell
03:29:56 <liste> it *could* be a type too, IF there was subtyping. but there isn't
03:34:55 <c50a326> ah what...  there are also "type functions" now to add to the complexity
03:35:44 <mniip> hmm
03:35:51 <cocreature> c50a326: there are type families which are a limited form of type-level functions but that’s an advanced Haskell feature that you definitely shouldn’t worry about atm
03:36:48 <mniip> I've hit this issue more than once:
03:37:25 <mniip> is there a finite set of ADTs you can use to structurally represent any haskell type
03:37:48 <barrucadu> Isn't that the idea behind GHC.Generics?
03:38:07 <mniip> I'm talking about quantified types
03:39:06 <mniip> ideally there'd be a simply typed lambda calculus of types without case analysis
03:39:20 <c50a326> was just reading this https://wiki.haskell.org/GADTs_for_dummies
03:39:25 <mniip> then I could write something like  End (/\a. a -> a)
03:39:58 <cocreature> c50a326: you don’t need to understand GADTs atm, dminuoso was suggesting that you use GADT _syntax_ not things that actually need to be GADTs
03:40:07 <c50a326> oh right
03:40:14 <mniip> basically
03:40:18 <cocreature> stick to one thing, you are only going to confuse yourself even more
03:40:41 <__monty__> mniip: (,), Either, () can represent any type afaik but you seem to be asking about something else?
03:40:42 <mniip> I want a datatype where in the end 'D a' contains a value of type 'a'
03:40:50 <mniip> but 'a' can be a quantified type
03:41:08 <mniip> which, obviously, you can't write 'F (forall ...)'
03:41:30 <mniip> __monty__, again, quanitified types
03:43:15 <__monty__> mniip: I don't get the question, the forall would quantify over (,), Either, ().
03:43:20 <mniip> SKI to the rescue I guess
03:43:46 <mniip> __monty__, how do you represent 'forall a. a -> a'
03:45:13 <Taneb> mniip: modulo strictness, () ;)
03:45:27 <mniip> funny
04:01:51 <mniip> haha!
04:01:53 <mniip> End (S0 (S1 (K2 (:-)) Typed) Typed)
04:02:18 <mniip> I'm sure many of you immediately recognize  forall a. Typed a => Typed a
04:04:14 <Ariakenom> Ah yes of course. *corrects monocle*
04:04:50 <Rembane> Nope! :D
04:05:07 <cocreature> mniip: reminds me of http://h2.jaguarpaw.co.uk/posts/hkd-pattern-type-level-ski/
04:05:44 <mniip> problem is
04:06:06 <mniip> K :: forall k. Constraint -> k -> Constraint
04:06:14 <mniip> that obviously doesn't work with K (:-)
04:06:23 <mniip> as (:-) :: Constraint -> Constraint -> Constraint
04:07:29 <mniip> so I need an infinite family of 'K' combinators
04:07:37 <mniip> for all possible kinds of arguments that end with Constraint
04:08:12 <mniip> class c p1 ... pn => Kn (c :: k1 -> ... -> kn -> Constraint) (d :: k) (p1 :: k1) ... (pn :: kn)
04:08:35 <mniip> same for S
04:09:33 * mniip . o O ( class family K (n :: Nat) ? )
04:09:49 <naldoco> @help
04:09:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:09:51 <mniip> actually that's something I can do I suspect
04:10:02 <mniip> with a dependent type family
04:11:30 <naldoco> @pl sumMult2 xs = sum $ map (2*) xs
04:11:30 <lambdabot> sumMult2 = sum . map (2 *)
04:14:26 <naldoco> ?? list
04:14:26 <lambdabot>  list
04:14:39 <naldoco> list
04:14:58 <ZeuPiark> hello
04:15:15 <trcc> Hi everyone. I have a :: IO (Maybe String) and b :: IO (Maybe String). and c :: String -> IO (Maybe String). I am interesting in performing something similar to: b = a >>= c. But I have to deal with both IO and Maybe. Basically, if a returns Nothing, I want to return Nothing wrapped in IO. But all the unpacking and casing seems extreme
04:15:31 <mniip> cocreature, HKD = higher kinded ?
04:16:09 <mniip> trcc, that's kind of the motivation behind monad transformers
04:16:55 <mniip> runMaybeT $ MaybeT a >>= (MaybeT . c)
04:16:58 <trcc> mniip: I'll check it out. Thanks!
04:17:23 <mniip> though if you have other stuff going on with IO (Maybe _) I suggest to do the MaybeT unpacking earlier/later
04:17:35 <cocreature> mniip: yeah it was a response to http://reasonablypolymorphic.com/blog/higher-kinded-data/ iirc
04:17:40 <trcc> It is exactly as I described in the case
04:23:42 <mniip> hmmmmmmmm
04:23:52 <mniip> cocreature, that last paragraph might come handy
04:24:11 <zincy> If I want to update a callback dynamically should I use the continuation monad?
04:24:55 <lyxia> your problem is way too unspecific to have an answer
04:28:44 <zincy> https://lpaste.net/1362563136112033792
04:28:54 <zincy> ^ There is some specificity
04:29:24 <zincy> Or should I say an actual description of the problem without speculation on the solution
04:34:09 <Ariakenom> zincy: If a callback is IO () then an updateable callback sounds like MVar (IO ())
04:35:42 <Ariakenom> :t join . readMVar
04:35:43 <lambdabot> error:
04:35:43 <lambdabot>     Variable not in scope: readMVar :: a -> m (m a1)
04:36:25 <Ariakenom> :t join . Control.Concurrent.readMVar
04:36:27 <lambdabot> GHC.MVar.MVar (IO a) -> IO a
04:38:04 <mckeankylej> Is it possible to restrict the kind of a type variable defined in a class head in a default signature?
04:38:21 <zincy> In fact what would be simpler than passing an expected action is just to say if an action is determined as valid then the we abort the timeout
04:38:38 <merijn> mckeankylej: I don't think so?
04:39:17 <mckeankylej> Im trying to make kind polymorphic functor that defaults to Data.Functor if the kind is * -> *
04:39:45 <mniip> mckeankylej, you need at least 1 type family
04:40:05 <mckeankylej> I thought about making a type family IsFunctor (i :: Type) (j :: Type) (f :: Type -> Type) :: Constraint where IsFunctor Type Type f = Prelude.Functor f
04:40:18 <mckeankylej> mniip: is that what you mean?
04:40:29 <mckeankylej> or do you mean the Dom and Cod type families
04:40:49 <mniip> no, the IsFunctor family precisely
04:40:59 <mniip> you could probably even write:
04:41:55 <mniip> hm, what I had in mind you can't write
04:42:38 <mckeankylej> hey that type family worked!
04:42:43 <mckeankylej> what a gross hack though
04:42:44 <mniip> type family FunctorConstraint (k :: *) :: (k -> Constraint) where FunctorConstraint (* -> *) = Functor
04:43:09 <mckeankylej> oh thats pretty ima go with that
04:43:20 <naldoco_> @pl sumMult2 xs = sum $ map (2*) xs
04:43:20 <lambdabot> sumMult2 = sum . map (2 *)
04:43:40 <mniip> I was hoping you could write type family F :: (k -> Constraint)
04:43:51 <mniip> and then in the equations for F you could pattern match on k
04:44:33 <c50a326> data FailableDouble = Failure | OK Double  -- I can now do :t Failure, :t OK, but :t FailableDouble fails with: Data constructor not in scope: FailableDouble
04:44:43 <c50a326> firstly, Failure and OK are functions?
04:45:00 <c50a326> but FailableDouble is not I guess?
04:45:12 <c50a326> ah because data constructors are functions
04:45:18 <merijn> c50a326: FailableDouble is a *type* not a value :)
04:45:19 <c50a326> but types are not functions
04:45:25 <liste> correct
04:45:38 <merijn> c50a326: Type don't have types (unless you are one of those TypeInType heretics)
04:45:39 <liste> they live in separate "universes"
04:46:09 <merijn> c50a326: The "type" of a type is normally called it's *kind*
04:46:36 <mniip> neat
04:47:00 <mniip> so it looks like if I have a (T => T) constraint
04:47:04 <mniip> ghc is able to infer T
04:47:33 <asheshambasta> For an example datatype, eg. some `data Foo = NotOk | Ok` whats the best way in Haskell to indicate success/failures for the data constructors?
04:48:33 <cocreature> asheshambasta: I’m not sure what you mean by that?
04:48:55 <mniip> indeed that is the case
04:49:27 <asheshambasta> cocreature: I could be having a brain-fart, but I'd like to use NotOk to indicate some sort of failure
04:49:38 <mniip> I appear to have written a very complicated 'fix'
04:49:39 <mniip> lol
04:49:43 <cocreature> asheshambasta: yeah so what’s wrong with the datatype that you have written?
04:50:27 <asheshambasta> cocreature: say I have `checkFailure :: Foo -> Bool` can I avoid having to match across the data constructors for type Foo?
04:50:34 <asheshambasta> (to check on success/failure)
04:50:58 <cocreature> checkFailure foo = Foo == Ok
04:51:20 <asheshambasta> I'm definitely having a brain-fart
04:51:21 <cocreature> although this is all starting to look dangerously close to boolean blindness and I wonder if there isn’t a better solution to the underlying problem
04:51:35 <mniip> checkFailure Ok = True
04:51:39 <mniip> checkFailure _ = False
04:52:06 <asheshambasta> yeah
04:52:11 <asheshambasta> my brain has farted
04:52:16 <asheshambasta> sorry about that guys
04:52:28 <asheshambasta> (and thanks for the patience)
04:53:58 <mniip> okay so my idea of ghc-driven exference seems to be a failure from the start
04:54:07 <mniip> ghc is smart enough to exfer  fix id :: a
04:55:08 <trcc> mniip: trying to wrap my head around:  runMaybeT $ MaybeT a >>= (MaybeT . c). Looking at >>= with the type: m a -> (a -> m b) -> m b. Is m = MaybeT IO?
04:56:57 <mniip> yes
04:57:04 <trcc> Great. Thanks! I got it then
05:05:24 <naldoco> @version
05:05:24 <lambdabot> lambdabot 5.1.0.1
05:05:24 <lambdabot> git clone https://github.com/lambdabot/lambdabot
05:06:26 <naldoco> @help
05:06:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:06:32 <naldoco> @list
05:06:32 <lambdabot> What module?  Try @listmodules for some ideas.
05:06:45 <naldoco> @listmodules
05:06:45 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
05:06:45 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
05:07:25 <naldoco> @list hoogle
05:07:25 <lambdabot> hoogle provides: hoogle hoogle+
05:07:35 <naldoco> @list eval
05:07:35 <lambdabot> eval provides: run let define letlpaste undefine
05:07:46 <naldoco> @list eval run
05:07:46 <lambdabot> No module "eval run" loaded
05:07:53 <naldoco> @list run
05:07:53 <lambdabot> eval provides: run let define letlpaste undefine
05:08:03 <naldoco> @help run
05:08:03 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
05:09:03 <cocreature> naldoco: you can talk to lambdabot in private messages
05:09:56 <c50a326> this page is f'ing golden on ADT's http://www.cis.upenn.edu/~cis194/spring13/lectures/02-ADTs.html I feel really clear about them now
05:10:06 <naldoco> @help slap
05:10:06 <lambdabot> slap <nick>. Slap someone amusingly.
05:11:57 <soupladler> Hey, is Foundations of Mathematical Logic (Haskell Curry) a good book?
05:12:40 <mniip> edwardk:
05:13:03 <[exa]> soupladler: well it is, if you're going after combinatory logic
05:14:01 <soupladler> I was actually interested just because it had a good german translation. My wife's german, and also likes logic, so I was hoping to find a book we can both read.
05:14:42 <soupladler> Preferably a foundations sort of book, since we're both not too advanced
05:14:54 <soupladler> like, we both did some formal logic at uni
05:15:00 <soupladler> but nothing after
05:16:29 <w1n5t0n> I'm trying to install a package on Windows and I'm getting a "the program 'c2hs' is required but cannot be found", I read somewhere that installing the full MinGW would solve this but apparently it's not the case. Any ideas?
05:19:18 <soupladler> Eh, damn - I got confused
05:19:25 <soupladler> there is no translation.
05:19:36 <soupladler> His phd is in german, so I assumed he was writing originals in german
05:27:33 <trcc> I have this case: a >>= \x -> b x >>= c. Any simple way of getting rid of \x?
05:27:43 <trcc> such that it is automatically applied to b
05:27:59 <merijn> trcc: Looks like you want the fish operator
05:28:02 <merijn> :t (>=>)
05:28:03 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
05:28:21 <merijn> Then your example becomes "a >>= (b >=> c)"
05:28:33 <merijn> Probably works without parenthesis too
05:29:49 <trcc> thanks, i'll try
05:30:48 <trcc> :t <><
05:30:50 <lambdabot> error: parse error on input ‘<><’
05:30:58 <Taneb> merijn: >=> is associative, so it'll work fine :)
05:32:08 <cocreature> Taneb: that’s not associativity though, is it? this mixes >>= and >=>
05:34:52 <trcc> I got precedence parsing error cannot mix '>>=' [infixl 1] and '>=>' [infixr 1] in the same infix expression, when I tried without parenthesis
05:42:59 <dminuoso> 14:28           merijn | Probably works without parenthesis too
05:43:17 <dminuoso> merijn: If you had attended Kmett university you'd knew that Kleisli arrows form a category!
05:43:25 <dminuoso> Which means their composition is guaranteed to be associative. :P
05:43:46 <merijn> I was not referring to associativity but conflicting fixity of >>= and >=> as cocreature mentioned
05:43:55 <merijn> Which indeed doesn't work out
05:43:57 <dminuoso> Ahh
05:44:03 <merijn> So you do need ()
05:44:19 <dminuoso> That's surprising
05:44:51 <dminuoso> merijn: I somehow read this as `a >=> (b >=> c)` even after looking at it twice.
05:55:07 <w1n5t0n> I'm trying to use ghci with emacs on Windows, but when I try to start a process it cannot find ghci. I can launch ghci from the windows command prompt, but not from the MSYS terminal (which is where emacs is launched from). Is my haskell installation not visible to MSYS and therefore emacs?
06:00:30 * hackage hadolint 1.8.0 - Dockerfile Linter JavaScript API  http://hackage.haskell.org/package/hadolint-1.8.0 (lorenzo)
06:10:26 <c50a326> hey can we talk about the bottom of this page https://i.imgur.com/rjUimXt.png
06:11:04 <c50a326> the page is http://www.cis.upenn.edu/~cis194/spring13/lectures/02-ADTs.html
06:11:23 <c50a326> underneath it says "The second line says that a variable by itself is a pattern: such a pattern matches anything, and “binds” the given variable name to the matched value."
06:11:46 <c50a326> hmmm those quote marks are funky unicode ones
06:12:20 <c50a326> so a variable is a name that refers to a value... so that is a function or the result of a function... right?
06:12:29 <c50a326> is that what a value is?
06:12:34 <c50a326> and a variable?
06:13:23 <c50a326> why is a variable a pattern
06:13:47 <ventonegro> c50a326: a value is something in normal form, i. e., cannot be reduced anymore
06:14:05 <ventonegro> c50a326: A variable is a name bound to a value
06:14:41 <ventonegro> A pattern *can* be a variable, it doesn't mean a variable is a pattern
06:14:49 <c50a326> a pattern is at a higher level?
06:15:08 <ventonegro> higher?
06:15:19 <c50a326> it can be reduced
06:16:06 <ventonegro> No, patterns are syntactic constructs
06:16:33 <ventonegro> When a pattern matches, the variables contained in pattern get bound
06:16:42 <ventonegro> in the*
06:17:22 <c50a326> longestChain' = length (maximum (map chain' [1..100]))
06:17:26 <c50a326> what here is a pattern?
06:17:35 <ventonegro> Nothing
06:17:45 <c50a326> are length, maximum, map and chain' not all variables?
06:17:49 <ventonegro> Yes
06:17:49 <c50a326> and longestChain' too
06:17:56 <c50a326> so they're all patterns then right?
06:18:02 <ventonegro> No
06:18:02 <c50a326> according to the definition on the linked page
06:18:19 <ventonegro> Why are you trying to conflate patterns and variables?
06:18:41 <c50a326> it says:  pat ::= ... |  var
06:19:13 <ventonegro> Yes, a pattern *can* be a variable, it doesn't mean that all variables are patterns
06:19:28 <c50a326> when is a variable a pattern and when isn't it
06:20:16 <ventonegro> Only when it's used for matching a pattern
06:20:21 <roconnor_> What's the free theorem for (foo :: Either (R b) (b -> R b))?
06:20:55 <c50a326> ventonegro: can you give an example or two if possible, sorry
06:21:36 <Ariakenom> longestChain' was a pattern there though?
06:22:28 <ventonegro> case x of Nothing -> 0; Just i -> i
06:22:49 <ventonegro> "Nothing" and "Just i" are the patterns
06:23:06 <mniip> roconnor_, depends on what R is
06:23:16 <roconnor_> R is a covariant functor.
06:24:10 <c50a326> well that's the ( Constructor pat1 pat2 ... patn ) definition isn't it
06:24:18 <Ariakenom> where "i" is a subpattern of "Just i"
06:24:35 <ventonegro> c50a326: At runtime, the program will try to "match" the shape of the value to one of the patterns, in sequence
06:25:10 <mniip> roconnor_, bimap (fmap f) (. f) foo == bimap (fmap f) (fmap f .) foo
06:25:27 <ventonegro> c50a326: When the shape of one of the patterns match, the variables inside the patterns will be bound to value, according to syntax of the pattern
06:25:39 <mniip> which due to the properties of bimap reduces to:  second (. f) foo == second (fmap f .) foo
06:25:55 <c50a326> ah I should practice case expressions
06:26:04 <ventonegro> Argh, I cannot seem to type today
06:26:07 <c50a326> with ADT's
06:26:15 <c50a326> thanks ventonegro and Ariakenom
06:26:22 <ventonegro> c50a326: sure
06:26:55 <roconnor_> mniip: ty.
06:26:56 <mniip> actually no
06:26:58 <mniip> that is wrong
06:27:15 <mniip> roconnor_, second (. f) foo == bimap (fmap f) (fmap f .) foo
06:27:53 <mniip> either the Either is a Right, or the R is a Const
06:29:18 <mniip> roconnor_, do you understand how to arrive at this?
06:29:38 <roconnor_> not yet
06:30:26 <mniip> basically you rewrite your type as a profunctor of two arguments: P(a, b) where a is the contravariant appearances and b is the covariant appearances
06:31:25 <mniip> then the free theorem which is the same as a profunctor end coherence condition, becomes that for f :: a -> b, P(f, b) == P(a, f)
06:32:05 <mniip> P(f, x) being the lifting of 'f' to the type P(b, x) -> P(a, x)
06:32:19 <mniip> (P is contravariant in the first argument)
06:32:42 <roconnor_> Right this makes sense.
06:33:00 <w1n5t0n> hey, I'm trying to install a library (hsndfile) on Windows but I get the following error "Missing (or bad) C library: sndfile". I have installed this library and added its lib, bin, and include folders to my path but it still cannot find it. Any suggestions?
06:33:04 <mniip> in your case,  Either (R b) (a -> R b)
06:33:40 <mniip> if you have f :: a -> b then a function  Either (R b) (b -> R b) -> Either (R b) (a -> R b)  is second (. f)
06:34:07 <mniip> and  Either (R a) (a -> R b) -> Either (R b) (a -> R b)  is bimap (fmap f) (fmap f .)
06:34:19 <roconnor_> perfect.
06:34:20 <mniip> the two must be equal
06:34:45 <mniip> oops
06:34:51 <mniip> Either (R a) (a -> R a) -> Either (R b) (a -> R b)
06:35:07 <roconnor_> yes that's what I figured.
06:36:17 <mniip> the two functions are  P(a, a) -> P(a, b) and P(b, b) -> P(a, b) respectively, so to say that they're equal means that for any inhabitant for 'forall x. P(x, x)' the two must produce equal results
06:37:19 <mniip> strictly categorically speacking an object 'X = forall x. P(x, x)' really comes with a bunch of morphisms for every x 'X -> P(x, x)'
06:37:58 <mniip> and 'X => P(a, a) => P(a, b)' with 'X => P(b, b) => P(a, b)' must make a commutative square
06:42:31 <roconnor_> mniip: I wish you were in #haskell-in-depth.  I want to know if (or how to show) that the coproduct of the ends of two profuctors is isomorphic to the end of the coproduct of the two profunctors.
06:42:50 <mniip> never heard of that before
06:43:45 <mniip> ima think about it in a bit
06:44:06 <roconnor_> I mean, handwavily if we have (forall a. P a a + Q a a) then every instance must yeild always yeild the same side of the disjuction due to *wavying hands* parametricity.
06:44:39 <roconnor_> so we really have (forall a. P a a) or (forall a. Q a a), i.e. we ahve (forall a. P a a) + (forall a. Q a a).
06:45:16 <roconnor_> But another part of me says that you cannot distributes limits over colimits willy-nilly.
06:47:33 <mniip> this handwaving makes sense in Set
06:47:44 <mniip> but such a proof is unsatisfactory :)
06:47:56 <mniip> I mean, the fact that you've proved :)
06:49:16 <glittershark> Has anyone attempted to write down laws for MonadError at any point?
06:49:42 <glittershark> I'm considering an instance that's a little... unconventional
06:50:02 <glittershark> and wondering if anyone's formalized the class in any way that my instance would break
06:50:20 <glittershark> (specifically, `throwError e >> pure x === throwError e` wouldn't hold)
06:54:10 <roconnor_> I think `throwError e >> f === throwError e` holds by parametricity.
06:55:23 <glittershark> well for Either, sure, but I'm considering something closer to Validation
06:55:43 <glittershark> basically I'm looking for someone to tell me it's a terrible idea :P
06:56:06 <glittershark> oh no roconnor_ I see what you mean now
06:56:12 <glittershark> :t throwError
06:56:13 <lambdabot> MonadError e m => e -> m a
06:56:18 <glittershark> because of the `a`
06:56:25 <glittershark> you're totally right, thanks
07:13:22 <mckeankylej> why does ghc not have the eta rule for products: tupleEta :: forall (i :: Type) (j :: Type) (a :: (i, j)). a :~: (Fst a, Snd a); tupleEta = Refl does not typecheck
07:13:44 <mckeankylej> is there a way to do this without unsafeCoerce Refl?
07:14:06 <mckeankylej> where Fst and Snd are the obvious type families
07:14:59 <glittershark> ghc is missing a *lot* of theorems in DataKinds
07:15:33 <mckeankylej> rip
07:15:41 <glittershark> my usual approach to this is to add new axioms to https://hackage.haskell.org/package/constraints-0.10/docs/Data-Constraint.html so at least they're open source somewhere
07:16:03 <glittershark> see eg https://hackage.haskell.org/package/constraints-0.10/docs/Data-Constraint-Nat.html
07:16:22 <glittershark> every single function in that module is implemented using unsafeCoerce Refl
07:16:48 <glittershark> or unsafeCoerce (Dict :: Dict (a ~ a))
07:17:39 <glittershark> I wonder if anyone's talking about adding better support for this stuff at the type-level, especially with -XDependentHaskell on the not-so-distant horizon
07:18:16 <mckeankylej> with -XDependentHaskell things like the eta rule should just exist
07:18:24 <mckeankylej> because that rule exists at the value level
07:18:26 <glittershark> yeah
07:18:27 <mckeankylej> at least i hope
07:18:32 <glittershark> I hope too :)
07:18:55 <mckeankylej> type level programming in haskell is like walking on a bed of nails
07:19:07 <mckeankylej> -XDependentHaskell cant come soon enough
07:19:12 <glittershark> amen
07:19:30 <glittershark> I've been teaching myself Agda over the weekends and I am spoiling myself terribly
07:19:40 <merijn> glittershark: Why Agda instead of Idris?
07:19:51 <mckeankylej> this is the first time ive written haskell after 5 months of Agda
07:19:57 <mckeankylej> its so hard to get back into haskell
07:20:03 <glittershark> I like Agda's syntax a *lot* :)
07:20:21 <glittershark> EqReasoning and friends are an absolute *godsend*
07:20:24 <mckeankylej> merijn: honestly i dont see any reason to use idris over agda unless you need the new linear types machinary
07:20:53 <mckeankylej> agdas modules are amazing
07:21:01 <glittershark> oh yeah also parametrized modules
07:21:14 <mckeankylej> the new coinduction support is awesome
07:21:25 <glittershark> when I discovered you could `let open Foo X` in a type signature I got so excited
07:21:28 <mckeankylej> so intuitive once you get through 20 linnes
07:21:36 <kuribas> why is Int garantueed 30 bits, not 32 bits?
07:22:11 <mckeankylej> idris just feels like what haskell should have been 10 years ago
07:22:12 <ventonegro> kuribas: The pointer tag
07:22:27 <AWizzArd> Why Agda/Idris and not LiquidHaskell?
07:22:37 <kuribas> > (minBound :: Int, maxBound :: Int)
07:22:39 <lambdabot>  (-9223372036854775808,9223372036854775807)
07:22:46 <kuribas> > (minBound :: Int64, maxBound :: Int64)
07:22:48 <lambdabot>  (-9223372036854775808,9223372036854775807)
07:22:58 <glittershark> real dependent types rather than a bolt-on refinement type system implemented inside of comment blocks
07:22:59 <kuribas> ventonegro: it seems Int and Int64 are the same
07:23:00 <mckeankylej> AWizzArd: LiquidHaskell is wildly unsound in my experience
07:23:01 <AWizzArd> I don’t remember who it was, but someone here said that LH is already very powerful and much simpler than dependend typing.
07:23:06 <dstolfa> AWizzArd: i think the answer for Agda is quite obvious. it's built from ground-up to be dependently typed and has a really good standard lib + ulf's prelude
07:23:20 <dstolfa> + unicode support. can't get enough of unicode support
07:23:21 <mckeankylej> every time i have used it i have found a crippling unsoundness bug
07:23:22 <glittershark> agda's standard lib is fantastic for everything *except* category theory, ironically
07:23:34 <dataN> is there way to define data families recursively?
07:23:40 <dstolfa> glittershark: i've not used category theory in agda, is it really that bad?
07:23:51 <mckeankylej> then it took average 6 months for the devs to fix it
07:23:54 <AWizzArd> mckeankylej: can you tell about one tiny example? What do you mean by unsoundness bug?
07:23:59 <dstolfa> glittershark: i've usually just defined my own primitives for it when i needed it
07:24:02 <kuribas> ventonegro: I suppose it's reserved for an implementation that uses the tag for lazyness?
07:24:08 <simon> I just started using tasty-discover. having a QuickCheck property prop_Every_Opcode_Has_Size shows up when I test, but if I were to run HSpec or Tasty's TestTree, I could specify a String description of the test too/instead. will tasty-discover somehow let me do that, too?
07:24:19 <Denommus> anyone using haskell-ide-engine?
07:24:20 <AWizzArd> Is it just that LH is buggy and can’t really be trusted, whereas Agda & Idris are more stable and their results can be trusted?
07:24:21 <glittershark> dstolfa: it's bad in the stdlib, but I've been working on extending https://github.com/copumpkin/categories and I like it a lot
07:24:25 <dstolfa> AWizzArd: unsoundness means that you can prove something that's not true
07:24:26 <ventonegro> kuribas: Int64 also has only 30 bits? Weird
07:24:42 <simon> hi AWizzArd :)
07:24:44 <mckeankylej> AWizzArd: https://github.com/ucsd-progsys/liquidhaskell/issues/791 this bug is 2 years old
07:24:55 <AWizzArd> mckeankylej: I see.
07:25:00 <dstolfa> glittershark: you know, i'd be up for fixing agda's stdlib category theory at some point if you want to collaborate on that :)
07:25:04 <mckeankylej> This basically means you cant use liquid haskell with monads in any meaningful way
07:25:04 <glittershark> dstolfa: the entire reason I picked up Agda was to work through proving constructions from category theory, because the only way I can understand math is by proving it myself
07:25:21 <kuribas> > 2^63 - 1
07:25:23 <lambdabot>  9223372036854775807
07:25:24 <glittershark> dstolfa: that's been most of what I've spent my weekends on over the last few weeks, so I'm totally down :)
07:25:34 <kuribas> ventonegro: the other way around :)
07:25:37 <geekosaur> the standard allows stealing bits. ghc doesn't
07:25:48 <ventonegro> kuribas: The tag is not for lazyness, it's for parametric code
07:26:09 <dstolfa> glittershark: currently i'm a bit boggled down with other things, but should i get some time i'll ping you :)
07:26:22 <glittershark> please do :)
07:26:22 <kuribas> ventonegro: doesn't that use a dictionary?
07:26:39 <kuribas> ventonegro: Int is 64 bits
07:26:44 <hexagoxel> mniip: that's why i usually don't include "fix" in the exference dictionary. too many false positives.
07:27:00 <glittershark> simon: tasty-discover allows test_foo :: TestTree
07:27:14 <dstolfa> glittershark: is the goal to be able to prove definitions from other things, i.e. that adjunctions give rise to a monad and that monads give rise to an adjunction and that they're monoids in a monoidal category of endofunctor or is the goal currently not to go that far?
07:27:21 <mniip> hexagoxel, I'm filing a bug :P
07:27:28 <glittershark> dstolfa: absolutely to go that far.
07:27:35 <simon> glittershark, ah, so I just put my property inside a testProperty there. thanks!
07:27:48 <dstolfa> glittershark: alright, sounds good to me ;)
07:28:05 <glittershark> dstolfa: I've got "adjunctions give rise to a monad" already down locally, gonna look at "monoids in the category of endofunctors" next
07:28:23 <glittershark> also proving that Agda setoids form a CCC, which is tougher than you'd think given function equality
07:28:26 <kuribas> ventonegro: I presume it works like this: the parametric code looks up the method in the dictionary, then passes the data to the dictionary without inspecting it.
07:28:52 <mckeankylej> while #haskell is on the topic of category theory im working to make hask2 (Ed Kmetts category theory in haskell)
07:28:54 <kuribas> ventonegro: since the method in the dictionary "knows" what type it is, the tag isn't necessary.
07:28:56 <mckeankylej> https://github.com/mckeankylej/kpf/blob/master/Control/Category.hs
07:29:06 <glittershark> also been working on the isomorphism between adjunctions on thin categories and Galois connections
07:29:08 <mckeankylej> currently type checks with ghc 8.4.2
07:29:10 <glittershark> mckeankylej: oooooooh
07:29:17 <kuribas> ventonegro: except for matching contructors
07:29:27 <dstolfa> glittershark: right, that should help quite a bit
07:29:29 <glittershark> mckeankylej: this is highly relevant to my interests
07:29:41 <ventonegro> kuribas: Dictionaries are used (conceptually) with typeclasses, I am talking about regular parametric functions
07:29:48 <mckeankylej> well im currently implementing the product category but if you want anything just ask
07:29:55 <mckeankylej> its so nice being on vaccation
07:29:56 <kuribas> ventonegro: well, they don't need to inspect the value at all.
07:30:03 <kuribas> ventonegro: they cannot
07:30:17 <dstolfa> mckeankylej: vacation, what's that?
07:30:23 <kuribas> ventonegro: except if they are Data.Dynamic, in which case they have a tag embedded.
07:30:48 <glittershark> mckeankylej: I'm definitely gonna pull this down and play with it over the weekend, might shoot you a PR or two :)
07:30:49 <kuribas> ventonegro: or an existential type, which also has the tag embedded.
07:31:02 <glittershark> multi-category haskell prelude is a huge dream of mine
07:31:16 <mckeankylej> glittershark: the cool thing about this is its fully backwards compatable
07:31:19 <glittershark> (fmap :: (Dict a -> Dict b) -> (a :- b)) :)
07:31:20 <glittershark> yeah!
07:31:33 <mckeankylej> we could change the Prelude to this and end users wouldnt notice
07:31:45 <ventonegro> kuribas: So when the GC goes through the heap, how does it know a word points to a constructor or is an integer?
07:32:13 <kuribas> ventonegro: I don't know.
07:32:25 <ventonegro> kuribas: My function says `Maybe a`, `a` could be anything
07:33:14 <kuribas> ventonegro: yes, but you cannot pattern match on what's inside a
07:33:18 <dataN> it can be written; forall a b c .. n . f a b c .. n :: (* -> * -> .. -> *) ?
07:34:00 <ventonegro> kuribas: Yes, the tags are invisible to the programmer, they are an implementation detail
07:34:01 <geekosaur> ventonegro, if you're asking about ghc specifically, https://ghc.haskell.org/trac/ghc/wiki/Commentary might be of interest
07:34:26 <ventonegro> kuribas: But the GC needs them, because of parametric functions
07:34:34 <jesyspa> dataN: The multirec paper does something like that by encoding them as tuples.
07:35:33 <dstolfa> as an aside note: how does haskell's GC work? is it just a generational stop-the-world GC or is it a bit smarter with green threads?
07:35:45 <dataN> that would not allow one data family to be used for various different types...
07:35:57 <merijn> dstolfa: generational, stop-the-world copy&compact GC
07:36:12 <dstolfa> merijn: alright, thanks
07:36:25 <merijn> dstolfa: Well, slightly more complex as there's per-thread nurseries and minor collections
07:36:52 <dstolfa> merijn: so it does do some per-thread trickery to avoid stop the world entirely?
07:36:55 <merijn> dstolfa: But eventually stuff ages out of nurseries and subject only to major collections, which are stop-the-world
07:37:07 <dataN> e.g. https://lpaste.net/3762422502693797888
07:37:13 <dstolfa> right, so young gens aren't stop-the-world but old ones are?
07:37:34 <merijn> dstolfa: Yeah, GHC's GC is optimised for lots of short-lived objects, so no point in doing major collections for stuff that's going to die soon
07:37:43 <dstolfa> merijn: alright cool, thanks :)
07:37:57 <merijn> dstolfa: See also: http://ezyang.com/jfp-ghc-rts-draft.pdf
07:38:12 <dstolfa> merijn: awesome, will read through
07:38:29 <merijn> And of course the GHC wiki
07:39:34 <dataN> would it?
07:41:26 <Denommus> ok
07:41:33 <Denommus> intero is much easier to boot and just works
07:41:39 <jesyspa> dataN: I'm not sure; I was just referring to how you can encode multiple datatypes as one.
07:41:41 <Denommus> I'm going to stick with it
07:42:07 <dataN> is datatype composition the same thing?
07:44:30 * hackage imap 0.3.0.8 - An efficient IMAP client library, with SSL and streaming  http://hackage.haskell.org/package/imap-0.3.0.8 (mkawalec)
07:44:51 <dataN> it could be related to type-level Int indexed kinds, e.g.  :k _ Z = * and :k _ (S Z) = * -> *
07:45:57 <dataN> so that a type-level Int could be used instead of (* -> * .. -> *) to represent the kind a of type.
08:01:43 <sgraf> cocreature: Sorry, this is 24 hours later. You probably want to store your analysis information in some kind of map from Identifiers to analysis result. What kind of analysis do you have in mind? I would be glad to help! I'm sure that would make for an excellent additional example.
08:02:21 <sgraf> cocreature: I've been wanting to write that part 2 of that blog post from last year for some time now, but never got around to it. I should probably take that time soon
08:02:50 <sgraf> cocreature: You could also drop by in my office, 031 :)
08:03:27 <cocreature> sgraf: I was toying with the idea of implementing ASAP (the memory management stuff)
08:04:15 <cocreature> sgraf: so my idea was that the map from identifiers to analysis results is already given by the map from Nodes to the domain (where the domain is my analysis result). I guess that’s not how things fit together?
08:06:14 <sgraf> cocreature: The library doesn't identify identifiers directly with nodes, because you might want to put fixpoints elsewhere, e.g. around a whole recursive group. So, you have to do the Id -> Lattice mapping yourself, I'm afraid
08:07:17 <w1n5t0n> hey guys, where should a C library be so that "cabal install" can find it as a dependency for a package? I have tried adding extra-lib-dirs and extra-include-dirs but no success :(
08:07:22 <sgraf> cocreature: I found ASAP really interesting myself, btw, have fun with that one
08:07:55 <cocreature> sgraf: alright, thanks! I’ll see if I can get things working and maybe make a PR with some minimal example that would have helped me to get started
08:07:58 <merijn> w1n5t0n: Well, did you add the appropriate -lmylib flag?
08:08:03 <sgraf> cocreature: unfortunately, I already forgot the details... also there were some aspects to it that were kind-of a deal breaker in a practical language
08:08:17 <merijn> w1n5t0n: GHC uses the same flags for linking that you'd pass to your C compiler
08:08:30 <sgraf> cocreature: Great, thanks! Come by at my office if you hit a road block
08:08:31 <cocreature> sgraf: I don’t care too much about the “practical” aspect atm :)
08:08:40 <cocreature> sgraf: will do, thank for the help!
08:08:44 <merijn> w1n5t0n: So "-L/my/lib/path -lmylib" to link with /my/lib/path/libmylib.so
08:10:45 <sclv> w1n5t0n: did you add the library itself in extra-libraries ?
08:15:06 <w1n5t0n> merijn: I'm a bit confused, should the command look something like "cabal install hsndfile -lsndfile"? the C library is "sndfile" but the files that came from the installer are called "libsndfile.dll" etc, is this a problem?
08:15:38 <sclv> w1n5t0n: is sndfile in the `extra-libraries` stanza?
08:15:39 <merijn> .dll sounds like windows and I don't know anything about windows linking :)
08:15:59 <w1n5t0n> to clarify, I'm trying to install the package hsndfile, I'm on Windows (out of necessity) with haskell platform and MinGW if that helps
08:16:06 <sclv> oh ok
08:16:13 <sclv> so finding libs on windows is awful
08:16:40 <sclv> some people might know better than me -- but one thing i've often found "just works" is literally copying the lib to the folder you are running cabal from
08:16:54 <sclv> (and when you distribute, copying the dll to the folder the exe is in)
08:18:48 <w1n5t0n> sclv: still get the same error, I've also tried pasting the .lib, .def, .dll etc files into haskell platform's AND MinGW's bin, include, lib folders
08:19:00 <simon> glittershark, so I'm using test_someFunction = testGroup "someFunction" [ test_someFunction_a, test_someFunction_b ], and the tests show up twice. is there a convention for picking names that won't be included but keeping them meaningfully named and at the top-level?
08:20:19 <w1n5t0n> sclv: the error is "Missing (or bad) C library: sndfile", but the name of the library as it was installed by the installer I downloaded is "libsndfile", could the problem be that cabal is looking for the wrong name library?
08:20:31 <sclv> hrm
08:20:39 <dataN> perhaps its something like type level lists of types but with lists of a given length, specified by a type level nat.
08:20:43 <glittershark> simon: just drop the test_ prefix on someFunction_a and someFunction_b
08:20:46 <sclv> on linux it translates sndfile into libsndfile
08:21:21 <simon> glittershark, sure, yeah, ok.
08:22:01 <sclv> according to what i've seen, in general linking dlls on windows just uses the search order as so: https://docs.microsoft.com/en-us/windows/desktop/Dlls/dynamic-link-library-search-order#search_order_for_desktop_applications
08:22:42 <sclv> you might be right with the sndfile/libsndfile thing though, couldn't hurt to try
08:24:24 <w1n5t0n> sclv: how would I try it, just rename the .lib and .dll files?
08:24:35 <sclv> i... guess?
08:25:31 <w1n5t0n> sclv: sorry I'm very much a noob when it comes to this, that didn't work either
08:25:38 <sclv> yeah i didn't think it would
08:25:46 <sclv> really if dlls are on the search path as described in the link
08:25:47 <sclv> it should find them
08:25:47 <c50a326> hey how can I flip the partial (div 10)  -- I know I can use like 20 `div` 10 but I just want to make flip work
08:26:20 <c50a326> flip . div 10 $ 20    flip (div 10) 20    things like this dont work D:
08:26:41 <hexagoxel> > (flip div 10) 20
08:26:44 <lambdabot>  2
08:26:52 <lyxia> (`div` 10)
08:26:59 <sclv> w1n5t0n: one tip is to try to move the directory that has the dll to the _start_ rather than end of your path?
08:27:07 <c50a326> oh thanks
08:27:13 <sclv> so if you have them in mingw's bin folder
08:27:17 <sclv> maybe put that at the start of your path
08:27:27 <c50a326> why does that work and not the ones I put
08:27:38 <c50a326> :t flip
08:27:40 <lambdabot> (a -> b -> c) -> b -> a -> c
08:28:23 <hexagoxel> c50a326: because (div 10) already passed the 10 as thing-to-be-devided to div. flip then is useless.
08:28:39 <hexagoxel> :t flip
08:28:41 <lambdabot> (a -> b -> c) -> b -> a -> c
08:28:49 <c50a326> ah yeah, makes sense I guess
08:30:32 <c50a326> ah yeah if I stick stuff in ()'s it's gonna evaluate them I guess?
08:30:43 <hexagoxel> no
08:30:43 <c50a326> before the stuff on the outside
08:30:50 <w1n5t0n> sclv: should the path point to MinGW's bin or Haskell Platform/minGW/bin? and do I need to restart for the path change to take effect?
08:30:54 <c50a326> oh :(
08:31:25 <hexagoxel> flip . div 10 $ 20  is  (flip . (div 10)) 20
08:31:30 <sclv> w1n5t0n: it should point to whatever bin folder you have your libsndfile dll in
08:31:46 <hexagoxel> flip (div 10) 20  is  ((flip (div 10)) 20
08:31:49 <sclv> you might want a new terminal  but that should be it
08:32:07 <hexagoxel> (flip div 10) 20  is  ((flip div) 10) 20
08:33:46 <w1n5t0n> sclv: I have it in all of them! Still doesn't work, I have a feeling it's the name that's confusing it
08:34:08 <w1n5t0n> is it the .dll that needs to be found or the header files too?
08:48:19 <c50a326> hey I'm trying to write this function splitInt to turn like 12345 into [1, 2, 3, 4, 5] so... splitInt :: (Int a) => a -> [a] is the type signature
08:48:41 <c50a326> intuitively I want to use foldl but that would meant I have to pass it an int and an empty list, which seems bad
08:49:09 <c50a326> I know I can use (`div` 10) recursively to do this I think
08:49:09 <geekosaur> you know about worker/wrapper?
08:49:14 <c50a326> no D:
08:50:25 <geekosaur> make a private function that works with foldl, then the public one invokes that. if you've ever seen ccode that has "foo ... = ... go ... where go ...", it's doing that
08:50:51 <geckos> Hi, I trying to import Network.Socket to get ifindextoname but got "    Failed to load interface for ‘Network.Socket’"
08:51:57 <dolboeb> hello
08:52:26 <geckos> I got, `cabal insall network`
08:52:29 <geckos> install*
08:52:29 <glguy> geckos: Add the 'network' package to the 'build-depends' section of your .cabal file
08:52:50 <dolboeb> what good books about haskell can you advise for a beginner?
08:52:59 * hackage happstack-server 7.5.1.1 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.5.1.1 (JeremyShaw)
08:53:24 <geckos> dolboeb: I am reading http://learnyouahaskell.com/
08:53:39 <geckos> dolboeb: and I am totally beginner
08:53:59 <glittershark> dolboeb: http://haskellbook.com/
08:54:27 <glittershark> oops
08:54:28 <glguy> dolboeb: Graham Hutton's Programming in Haskell is a good place to start
08:54:29 <glittershark> geckos:
08:54:32 <glguy> make sure you get the 2nd ed.
08:54:46 <Taneb> geckos: http://www.cs.nott.ac.uk/~pszgmh/pih.html (the book glguy mentioned)
08:54:56 <Taneb> I like it a lot :)
08:54:56 <geckos> uuuh thanks
08:55:52 <geckos> I'm still grasping functors on LYAH
08:56:25 <dataN> first, how can a fixed length list be used to make a higher kinded version of currying? then can the promotion of this process to type level be interpreted?
08:56:26 <geckos> I'll buy it
08:58:31 <glguy> dataN: You'd have to make a length-indexed list (GADTs, probably DataKinds) and then implement it using a typeclass
08:59:07 <dolboeb> Is Haskell faster than Python?
08:59:17 <Taneb> dolboeb: sometimes
08:59:18 <dolboeb> i suppose it is
08:59:22 <glittershark> Has anyone ever noticed any space leaks when using ResourceT?
08:59:51 <glittershark> I added a `runResourceT` to my code (without doing any resourcet-ey things) and the heap graph instantly went triangular
08:59:55 <glittershark> pulled it off and it's flat again
09:00:01 <dataN> glguy: so far its this; https://lpaste.net/3762422502693797888
09:00:06 <glittershark> this is specifically inside a big call to `traverse`
09:00:36 <dolboeb> What are advantages of Haskell over Python?
09:00:54 <dataN> dolboeb: fewer run time errors
09:01:21 <dataN> and well established higher-order paradigm
09:01:26 <Taneb> dolboeb: it's compiled, it's strongly-typed and purely functional, which means that there's fewer runtime errors and refactoring and reasoning are easier
09:01:40 <Solonarv> compiles to a native binary, so it doesn't need python to be installed
09:01:47 <Putonlalla> Better performance (almost always), dolboeb.
09:01:49 <Solonarv> (python can be compiled / bundled as well but it's a hassle)
09:02:44 <glguy> dataN: How about writing it in terms of: data Args :: [*] -> * where Nil  :: Args '[]; (:-) :: x -> Args xs -> Args (x ': xs)
09:02:45 <dataN> glguy: its a motivation for a generalised process which is proving difficult to implement. can it be done?
09:03:24 <Solonarv> I find python and haskell to be quite different; about the only common points are 1) meaningful whitespace and 2) good C interop
09:04:29 * hackage git-annex 6.20180626 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-6.20180626 (JoeyHess)
09:05:00 <dataN> [*] could be e.g. [Int,Bool] ?
09:05:43 <glguy> Yeah, the type [Int,Bool] has kind [*]
09:06:03 <Solonarv> % :k [Int, Bool]
09:06:03 <yahb> Solonarv: [Int, Bool] :: [*]
09:06:21 <dataN> is it clear from the paste what is being attempted?
09:09:52 <w1n5t0n> hey, I'm trying to install a package that has an external C dependency, I've checked the extra-lib-dir and include-dir and I've pasted files from the respective folders of the C library installation (i.e. lib and include) but it still cannot find it
09:10:14 <w1n5t0n> is the issue that it can't compile it, rather than find it?
09:10:19 <dataN> its a simple example which tries to show (via the types of emptyN appearing in the data instances) how the Sort (or length of the kind, if thats an ok way to put it) is supposed to be the same as the number appearing in the datatype DefN, where the representation of type level ints given by S,Z should be used as an argument instead.
09:10:20 <glguy> dataN: Something like this? https://gist.github.com/glguy/26c9456d7d9369458fdd243788062c4a
09:10:51 <geekosaur> w1n5t0n, it assumes external C dependencies have already been built
09:11:18 <geekosaur> cabal doesn;'t know how to build foreign packages (and can't; too many things that have their own weird build systems)
09:11:52 <w1n5t0n> geekosaur: if I have the .dll file then isn't it built?
09:12:14 <Solonarv> I use stack, so for me it's usually enough to go `stack exec -- pacman -S package_name_here`
09:12:16 <glguy> dataN: I was just going on your use of the word currying, I don't understand what this paste is trying to do. Do  you have an example of what this would allow you to do?
09:12:17 <geekosaur> if you have the dll file then why are you asking it it can compile it?
09:13:34 <sclv> w1n5t0n: typically it needs to find header files too
09:13:44 <w1n5t0n> geekosaur: I'm not, all I want to do is install a library called "hsndfile" which has a dependency on this C library, so I run "cabal install hsndfile" but get an error "Missing (or bad) C library: sndfile". I've tried adding --extra-include-dirs and lib-dirs but with no success
09:14:34 <dataN> glguy, its stemming from an attempt to extend this this approach to longer kinds... https://lpaste.net/8889766800099639296
09:14:42 <sclv> to set where it looks for headers you can pass the argument --extra-include-dirs
09:14:56 <sclv> but i think you know that
09:15:20 <w1n5t0n> sclv: I've pasted the header files in Haskell Platform/mingw/include, and when I run the cabal install command with -v3 I can see "extra-lib-dirs: "C:\\Program Files\\Haskell Platform\\8.4.3\\mingw\\lib" include-dirs:, "C:\\Program Files\\Haskell Platform\\8.4.3\\mingw\\include"
09:15:25 <sclv> w1n5t0n: the other thing you can do is run cabal with `-v3` to get verbose output
09:15:36 <sclv> oh you know that too :-)
09:16:24 <dataN> essentially, all classes can be then formed of tuples of instances of these EmptyN classes.
09:18:10 <dataN> here is an example of the approach in use https://lpaste.net/8843645233662001152
09:20:32 <w1n5t0n> sclv: this is the log if it's any help: https://pastebin.com/bzcrhRMh
09:21:59 <glguy> dataN: is this closer? https://gist.github.com/glguy/26c9456d7d9369458fdd243788062c4a#file-closer-hs
09:22:18 <sclv> w1n5t0n: oh there's your problem!
09:22:20 <sclv> "cabal: The program 'pkg-config' is required but it could not be found."
09:22:49 <sclv> or erm
09:23:03 <sclv> it might not be, but its a guess?
09:23:48 <glguy> dataN: So then you could write: example2 :: f a -> T Functor f; example2 fa = V (Step (Base fa))
09:24:30 * hackage http-client-restricted 0.0.1 - restricting the servers that http-client will use  http://hackage.haskell.org/package/http-client-restricted-0.0.1 (JoeyHess)
09:24:30 <glguy> Oh, I've got it existentially quantified and you wanted it universally?
09:24:53 <dataN> I think so, yes.
09:25:13 <dataN> It could be that a kind level Int is required...
09:26:16 <sclv> w1n5t0n: what shell are you running from?
09:26:39 <dataN> this would specify the extent of the tuple
09:26:47 <Solonarv> if you're doing type level naturals don't do them as `data Z; data S a`; instead do `data N = Z | S N`
09:26:52 <w1n5t0n> sclv: okay thanks, that's a start! I'm using the Windows command prompt, I tried using MSYS earlier but "cabal" was an unrecognised command
09:27:09 <glguy> dataN: OK, I updated the paste to use universal quantification
09:27:13 <sclv> i'm not sure about the pkgconfig thing actually
09:27:28 <Solonarv> the first variant is hackish and I'm not sure why people use it, other than "DataKinds didn't always exist"
09:27:29 <tvN> could you explain more by what you meant by higher-order paradigms?
09:27:37 <sclv> the cabal file in the hsndfile repo uses pkgconfig-depends which is more modern
09:27:43 <tvN> dataN
09:27:50 <sclv> but the one on hackage just uses the extra-libraries clause
09:28:05 <sclv> so it could be a red herring
09:29:17 <mniip> does pattern matching on an expression containing ambiguous type variables rigidize them in the match rhs?
09:30:49 <mniip> @let data F p where (forall a. p a) -> F p
09:30:49 <lambdabot>  Parse failed: Parse error: forall
09:30:59 <sclv> w1n5t0n: one other thought
09:31:02 <mniip> @let data F p where F :: (forall a. p a) -> F p
09:31:03 <lambdabot>  .L.hs:167:1: error:
09:31:03 <lambdabot>      Multiple declarations of ‘F’
09:31:03 <lambdabot>      Declared at: .L.hs:162:1
09:31:15 <sclv> can you install libsndfile with the pacman provided by the platform's msys install?
09:31:15 <mniip> @let data F p where F :: (forall a. p a) -> F p
09:31:17 <lambdabot>  Defined.
09:31:36 <mniip> :t \(F m) -> F (runIdentity m)
09:31:37 <lambdabot> forall k (p :: k -> *). F Identity -> F p
09:31:50 <mniip> hmm not that
09:32:03 <mniip> @let newtype M f a = M { runM :: f a }
09:32:04 <lambdabot>  Defined.
09:32:09 <mniip> :t \(F m) -> F (runM m)
09:32:10 <lambdabot> forall k (p :: k -> *). F (M p) -> F p
09:32:18 <mniip> :t \(F (M x)) -> F x
09:32:19 <lambdabot> error:
09:32:19 <lambdabot>     • Couldn't match type ‘a0’ with ‘a’
09:32:19 <lambdabot>         because type variable ‘a’ would escape its scope
09:32:28 <mniip> why the error?
09:34:33 <w1n5t0n> sclv: how would I go about doing that? I've never used the pacman
09:35:31 <glguy> dataN: I updated the paste to use a data family with newtype instances so there's no runtime representation overhead
09:36:12 <dataN> tvN: to a reasonable extent, all programs are built of a finite number of common patterns, the most frequently encountered are built into the Haskell Prelude in the form of classes such as (co)Monad, Applicative, Traversable, Foldable, Functor, Monoid and Alternative. The existence of these patterns as the most fundamental aspects of the language result in legible, maintainable and reusable programs.
09:36:26 <dataN> glguy: thanks!
09:42:26 <tvN> i see
09:46:45 <c50a326> omfg I did it
09:47:22 <c50a326> geekosaur: this is my first try at worker thingy https://lpaste.net/919018410300407808
09:48:02 <c50a326> hm it barfs on negative numbers but I guess that's fine
09:49:26 <Solonarv> isn't initLastInt just divMod (or quotRem)
09:50:46 <c50a326> divMod and quotRem don't work in ghci for me when passed an integer, so I don't know :o
09:51:18 <geekosaur> :t divMod
09:51:20 <lambdabot> Integral a => a -> a -> (a, a)
09:51:28 <c50a326> oh fromIntegral I probably need
09:51:32 <geekosaur> you sure you're passing it an integer?
09:52:03 <c50a326> oh and it takes 2 arguments
09:52:08 <c50a326> initLastInt takes only 1 argument
09:52:12 <c50a326> :t quotRem
09:52:13 <lambdabot> Integral a => a -> a -> (a, a)
09:52:19 <c50a326> same thing here
09:52:30 <Ariakenom> well 1 :: Double is an integer but not Integral and not Integer
09:52:39 <c50a326> initLastInt takes like 12345 and splits it into (1234, 5)
09:52:41 <c50a326> a tuple
09:53:03 <Ariakenom> > divMod 12345 10
09:53:05 <lambdabot>  (1234,5)
09:53:10 <geekosaur> I would say it's not an integer, it's a real number that happens to coincide with an integer
09:53:16 <c50a326> oh right
09:53:55 <geekosaur> (there are more formal ways to say "happens to coincide". "isomorphic to", for one. but also ways that demonstrate mathematical relationships, while keeping them distinct)
09:54:13 <Ariakenom> geekosaur: !? reals are a superset of integer. they are not disjunct
09:54:31 <Ariakenom> 1 :: Double is isomorphic to 1 :: Integer sure
09:54:47 <geekosaur> right, I'm not talking abstract math here
09:55:12 <geekosaur> except insofar as abstract math can give insight into something that is concrete and has limitations abtract math doesn't
09:55:57 <Ariakenom> well the concept of an integer or a real is from math. otherwise define your own
09:56:27 <sclv> w1n5t0n: sorry i haven't replied earlier
09:56:30 <geekosaur> languages like haskell do define their own.
09:56:37 <sclv> i was trying to run through the steps myself on a virtual windows machine
09:56:44 <sclv> to see if i understood things right
09:56:54 <sclv> but its too slow
09:57:10 <sclv> i'd like to understand this type of issue better
09:57:26 <sclv> but right now the vm is just destryong my system
09:57:34 <sclv> (probably a runaway defender process or something)
09:57:54 <Ariakenom> Integer is a definition. but I's make a difference between that and an integer
09:58:10 <geekosaur> put otherwise: (x :: type) is not selecting from a single set, it is specifying membership in one of a number of distinct sets. because that's how we design computer languages
09:58:55 <geekosaur> and then we come up with things like Num to hack around the differences between the abstract form and the concrete shape we've forced on them by using those languages
09:59:45 <geekosaur> …point here being that, for all that they "look and feel" the same, the computer will not treat (1 :: Double) and (1 :: Integer) as the same thing
10:01:29 <Ariakenom> I don't see how that point relates. My point is that the word integer applies to Rational too. ex if we want to talk about divisability or whatever
10:01:39 <geekosaur> it relates in the original question
10:02:01 <geekosaur> in being confused why (1 :: Double) isn't "integer" enough for divMod
10:03:35 <Solonarv> (1 :: Double) and (1 :: Int) are two completely different things
10:03:59 <Solonarv> they have the same mathematical meaning, but haskell doesn't precisely map to math
10:04:10 <geekosaur> yes, let's have that whole discussion again
10:04:57 <Solonarv> oh sorry I misread your previous message; I saw "I'm" instead of "in"
10:05:18 <Ariakenom> I don't think they do. I'm just saying that they're both integers. While one isn't Integral. Just thought your phrasing wasn't helpful
10:05:37 <w1n5t0n> sclv: I've tried putting the library's files everywhere and still no luck! I tried stuffing them in the same folder and adding it as an --extra-lib-dir and --extra-include-dir but it still can't find it, which makes me think that there's something else going wrong here
10:08:29 <dataN> is there a way to specify the kind of a data family instance?
10:11:00 <wz1000> dataN: I don't think so
10:11:15 <wz1000> you can specify the kind of the data family itself
10:13:27 <dataN> it throws this error; https://lpaste.net/9069017539371073536
10:14:13 <cocreature> the result kind of instances for data families must be *
10:15:42 <cocreature> apparently the data family can have a polymorphic kind according to the user guide but I have no idea what that is good for if instances have to be *
10:16:25 <ahri> if I have a type `data Title = Title String` and I run `makePrisms ''Title`, how do I get the String out of `t = Title "foo"`? I thought `t^._1` would work but it doesn't
10:16:54 <dmwit> cocreature: Polymorphism is good for type arguments. Otherwise you get the default * argument.
10:17:51 <dmwit> ahri: The prism will be named _Title.
10:17:52 <cocreature> dmwit: I’m not talking about the arguments to the data family, I’m talking about the result kind. according to the user guide the result kind of a data family can be polymorphic but for all instances it must be *
10:18:05 <dmwit> ahri: (After the data constructor, not the type constructor.)
10:18:20 <dmwit> cocreature: odd
10:18:43 <c50a326> hey is this checksum function written horribly or...? https://lpaste.net/2808641168265445376
10:19:10 <c50a326> doubleSeconds means double every 2nd element, not like time
10:19:13 <cocreature> I get the part that instances are limited to * (after all we are creating a new datatype here) but I’m not sure what the point of allowing a more general definition for the family itself is
10:19:32 <c50a326> but is this function composition overkill
10:19:38 <ahri> dmwit: oh. huh. thank you very much, I was very confused there!
10:20:08 <ahri> ah, if it has multiple types I'd need to select using _1, _2, etc. I see
10:20:27 <wz1000> dataN: Why do you have `(f :: k)` as a parameter? Just take k as your parameter instead
10:21:19 <dmwit> cocreature: Perhaps just a uniformity thing. Fewer special cases is better.
10:21:27 <dataN> wz1000: 'SomeN f' ?
10:22:12 <wz1000> dataN: No in Def
10:22:44 <wz1000> data family Def (x :: k -> Constraint ) k; data instance Def EmptyN k = ...
10:23:45 <dmwit> c50a326: Seems reasonable enough. I might consider `concatMap toDigits` so that I could replace `sum . map sum` with just `sum`.
10:24:13 <dataN> wz1000: then there is nothing to use for the type of empty_
10:24:39 <wz1000> dataN: you can do (f :: k) in the instance to bring k into scope
10:24:47 <dmwit> c50a326: There is also `divMod` for your `initLastInt` needs.
10:24:53 <dmwit> > 12345 `divMod` 10
10:24:55 <lambdabot>  (1234,5)
10:25:07 <wz1000> dataN: data instance Def EmptyN (f :: k) = EmptyN_ { emptyN_ :: k }
10:25:16 <i0-dfn> is there a way to force shadowing rather than recursion? let x = (..) in let x = f x in (..), in the second let i want the x on the RHS to refer to the old x rather than being a recursive definition
10:25:49 <dmwit> i0-dfn: You can use the fact that monad bindings are not recursive (without extensions).
10:26:03 <i0-dfn> ah but i'm not in a monad here
10:26:18 <dmwit> runIdentity $ do { x <- Identity ..; x <- Identity $ f x; Identity .. }
10:26:26 <dataN> wz1000: that gives; Variable `k' used as a kind variable before being bound
10:26:51 <i0-dfn> dmwit: oh fair enough. i guess if that's the only option then i'll just rename the var
10:27:04 <c50a326> dmwit: thanks, I'll check out concat
10:27:07 <i0-dfn> it's just slightly annoying with RecordWildCards, was hoping to be able to redefine the fields
10:27:08 <c50a326> oops, concatMap
10:27:35 <c50a326> man, the fact that this cis194 course with all the lectures in html and lhs and the homeworks in pdf and the files needed for the homeworks and the quality of the material is epic
10:27:41 <c50a326> whatever university released this is the best
10:27:53 * dmwit . o O ( head $ do { x <- [..]; x <- [f x]; [..] } )
10:28:18 <dmwit> byorgey++ for cis194
10:29:16 <wz1000> dataN: Which version of GHC are you using? It works for me
10:29:49 <dmwit> Oh, maybe he isn't the one to blame.
10:30:21 <wz1000> dataN: On ghc 8.4.3
10:31:19 <dataN> wz1000: perhaps if you shared your code? 8.2.2, should be ok
10:31:31 <glguy> dataN: https://lpaste.net/3967740476521447424
10:32:46 <wz1000> dataN: https://lpaste.net/3511658019618291712
10:32:46 <glguy> or: data PairOfLists a b = POL [a] [b]; instance EmptyN PairOfLists where emptyN = Step (Step (Base (POL [] [])))
10:34:23 <dminuoso> Uhh.. • Occurs check: cannot construct the infinite type: s ~ s -> Const s s
10:34:30 <dminuoso> How do I read this?
10:34:49 <dminuoso> Ohh wait haha. Wrong precedence in my head =)
10:34:51 <wz1000> s ~ (s -> Const s s)
10:34:59 <dminuoso> wz1000: Yeah. I bracketed that wrong. Thanks :)
10:35:30 <wz1000> if it was s ~ s => Const s s, that would kind check
10:36:00 <wz1000> but (s ~ s) -> Const s s doesn't even do that
10:36:50 <dminuoso> wz1000: Hence my total confusion "what does this even mean"
10:38:05 <dataN> glguy: is there any reason to prefer the data family AllN over the GADT SomeN?
10:38:17 <glguy> no runtime representation
10:38:55 <[exa]> is there any development on lava and similar chip-generating stuff?
10:39:51 <[exa]> (just got an invitation to talk called Formal Verification of Spacecraft Control Programs Using a Metalanguage for State Transformers, so trying to guess whether it's lava or not)
10:41:21 <monochrom> Kerbal Space Program formal verification? :)
10:41:57 <dmwit> It seems some people play KSP very differently than me.
10:42:27 <dmwit> Geobraking and sudden unplanned disassembly is the best part of the launch.
10:43:06 <[exa]> people underestimate the fun of crashing, yes
10:43:55 <veverak> [exa]: where is that talk?
10:44:00 <veverak> or is it possible to get more info?
10:44:03 <dmwit> (I once crashed into Kerbin so hard that the entire planet disappeared and I was forced to start the game over from scratch.)
10:44:20 <monochrom> haha
10:45:44 <[exa]> veverak: tomorrow 4PM at CVUT A-1435
10:46:15 <[exa]> dmwit: I like that approach
10:46:24 <veverak> [exa]: damn it, one city away :)
10:46:32 <[exa]> lol
10:46:47 <[exa]> anyway it seems like this paper https://arxiv.org/pdf/1802.01738.pdf
10:47:25 <veverak> had formal verification course this year
10:47:59 <veverak> [exa]: cool, thanks
10:48:03 <[exa]> veverak: people from formal verification courses should receive a bit of steganography training imo
10:48:25 <veverak> why? :)
10:48:39 <veverak> it enjoyed our course, showed how problematic is it to say "that program is OK"
10:48:41 <veverak> ;)
10:49:17 <[exa]> the steganographer's view is "you can't"
10:49:42 <dmwit> Hide the bug in the specification and you're good to go.
10:50:06 <glguy> feature*
10:50:17 <veverak> dmwit: I like to directly "enhance the specification with bugs as features"
10:50:28 <sclv> drat, w1n5t0n appears to have left
10:51:01 <sclv> @tell w1n5t0n i tested using pacman to install sndfile (i wanted to test the pacman path in general anyway) and got everything working
10:51:01 <lambdabot> Consider it noted.
10:51:20 <sclv> @tell w1n5t0n the rough steps: https://gist.github.com/gbaz/95a56ae10e36276071c067d3be714d9e
10:51:20 <lambdabot> Consider it noted.
10:51:27 <veverak> "wait, we did not required the device to reboot every 5 minutes!"
10:51:37 <veverak> "well, let me explain how good feature that is! ... "
10:52:24 <wz1000> sclv: hey, did you see my mail to ghc-devs?
10:52:36 <sclv> wz1000: yeah, looked good
10:52:46 <sclv> i was hoping for a bit more of an estimate breakdown in terms of remaning weeks
10:52:49 <sclv> for each poriton
10:52:56 <sclv> but other than that it sounds like a correct plan of action
10:53:09 <sclv> also you might mention in response to the question about why-not-a-plugin
10:53:22 <sclv> your idea of extending some of the ghci functionality for ides
10:53:35 <sclv> which makes it clear this sort of generalizes and improves on stuff already bodged in
10:54:04 <mniip> I appear to have completely defeated instance resolution
10:54:13 <Xal> I'd like to transform a (Cofree f a) into a (Fix f)
10:54:19 <Xal> uncofree = Fix . fmap uncofree . unwrap works fine
10:54:26 <mniip> % :t whatif -- no unsafecoerces!
10:54:26 <yahb> mniip: (c => r) -> r
10:54:40 <Xal> but this looks like some sort of catamorphism and I'd like to implement it with 'cata' from kmett's recursion-schemes package
10:55:00 <dminuoso> I wrote a comonad implementation of Pretext. Without spoonfeeding a solution, is there something I could try and improve? https://gist.github.com/dminuoso/43ca1b6b325933eb029ea1f5e68920ac
10:55:26 <Xal> eg I'd like to have uncofree = cata alg
10:55:40 <Xal> where alg has type Base (Cofree f a) (Fix f) -> Fix f
10:55:59 <dmwit> mniip: Go on, show your work!
10:56:07 <dmwit> No undefined's either?
10:56:18 <mniip> none!
10:56:35 <monochrom> That is pretty scary.
10:56:37 <dmwit> Magic and scary.
10:56:37 <mniip> class c => Irrel a c; instance c => Irrel a c
10:56:45 * dmwit high fives monochrom
10:56:45 <mniip> subsumeIrrel :: Proxy a -> Proxy c -> ((Irrel a c => Irrel a c) => r) -> r; subsumeIrrel _ _ x = x
10:56:47 <wz1000> sclv: I guess I can get the serialization stuff done over the next 2-3 weeks
10:56:51 <mniip> whatif :: forall c. forall r. (c => r) -> r; whatif x = subsumeIrrel Proxy (Proxy @c) x
10:56:57 * [exa] headxplodes
10:57:13 <wz1000> sclv: That is, steps 1-3
10:57:30 <dminuoso> And I must say, that Pretext Comonad instance was quite mindbending until I started treating it like a lens of sorts..
10:57:56 <sclv> that sounds optimistic, but what do i know
10:58:06 <sclv> or maybe its feasible
10:58:12 <dmwit> What does `((Irrel a c => Irrel a c) => r)` even mean
10:58:13 <sclv> nowhere in the gameplan do i see tests btw :-)
10:58:20 <mniip> dmwit, QuantifiedConstraints
10:58:34 <wz1000> sclv: I already have tests of a sort
10:58:37 <mniip> of course, that doesn't really "work" in any intended way, any dictionary you obtain from 'whatif' is bottom
10:58:42 <monochrom> @type runCont
10:58:44 <lambdabot> Cont r a -> (a -> r) -> r
10:58:47 <sclv> ok, so you can merge the tests into the tree too then?
10:58:47 <sclv> cool
10:59:25 <mniip> % whatif @(Bounded String) maxBound :: String
10:59:30 <yahb> mniip: "[Timed out]
10:59:50 <wz1000> sclv: see validAst and validateScopes
11:00:16 <dmwit> mniip: Oh. I guess to be fair I said "undefined", but I meant "bottom".
11:00:23 <wz1000> sclv: https://github.com/wz1000/haddock/blob/hiefile-2/haddock-api/src/Haddock/Backends/Hyperlinker/HieUtils.hs#L134
11:00:29 <mniip> the definition doens't use recursion
11:00:36 <mniip> it's the GHC constraint solver that comes up with one
11:00:38 <dmwit> Although it is tricky to see where the bottom comes from.
11:00:42 <mniip> namely by inferring c from c=>c
11:00:58 <wz1000> sclv: the time killer this past week has been running those on the GHC tree, then fixing everything thats broken
11:01:00 <monochrom> Oh, no wonder.  I was wondering where was the bottom.
11:01:09 <Solonarv> so basically you found a QuantifiedConstraints bug?
11:01:12 <mniip> yes
11:01:17 <mniip> I'm writing up a ticket as we speak
11:01:34 <monochrom> This is breaking my faith. :)
11:01:43 <sclv> wz1000: right, those are integrity checks
11:01:57 <sclv> what i guess i mean is you'll probably want to write actual tests for ghc
11:02:04 <sclv> that get run with the testsuite
11:02:06 <sclv> that make use of this
11:02:30 <dataN> it gives another error: https://lpaste.net/2321457775135162368
11:03:30 <wz1000> sclv: I guess adapting the hyperlinker tests would be a good start
11:03:48 <wz1000> sclv: The ones that already exist in haddock, that is
11:04:59 <mniip> so
11:05:15 <mniip> does anyone know a way to write class c => Irrel a c  without UndecidableSuperClasses
11:05:20 <mniip> that'd be super cool
11:05:38 <mniip> basically I need to be able to add a dummy variable onto an arbitrary constraint
11:06:31 <Solonarv> wait, your example uses UndecidableXXX? doesn't that come with a "this might cause typechecker / instance resolution to loop" label?
11:07:03 <monochrom> Compile-time looping is still different from run-time looping.
11:07:04 <dmwit> But instance resolution doesn't loop.
11:07:19 <dmwit> If it did, it would honestly be less worrying.
11:07:55 <Solonarv> hm, I wonder that the core for this looks like
11:07:57 <mniip> Solonarv, Irrel itself is totally fine
11:08:16 <mniip> and I cam remove UndecidableXXX provided I specialize 'whatif' onto a specific typeclass
11:08:27 <mniip> whatif :: (Show a => r) -> r
11:08:40 <Solonarv> oh, I see
11:10:30 <mniip> ah I know
11:12:16 <mniip> yeah got it I think
11:18:28 <mniip> ok look at this
11:18:32 * shapr looks around
11:19:33 <mniip> % class Irrel a (c :: Constraint) where instantiate :: Proxy a -> Proxy c -> (c => r) -> r
11:19:34 <yahb> mniip:
11:19:36 <mniip> % subsumeIrrel :: Proxy a -> Proxy c -> ((Irrel a c => Irrel a c) => r) -> r; subsumeIrrel _ _ x = x
11:19:36 <yahb> mniip:
11:20:08 <mniip> % whatif :: Proxy c -> (c => r) -> r; whatif p x = subsumeIrrel (Proxy @()) p (instantiate (Proxy @()) p x)
11:20:08 <yahb> mniip:
11:20:29 * hackage imm 1.3.0.0 - Execute arbitrary actions for each unread element of RSS/Atom feeds  http://hackage.haskell.org/package/imm-1.3.0.0 (koral)
11:20:47 <mniip> no Undecidable*
11:21:48 <[exa]> mniip: anyway, what's the purpose of that exercise? (sorry I wasn't able to find it in scrollback)
11:22:01 <mniip> [exa], which one
11:22:07 <Solonarv> % whatif (Proxy @(Bounded String)) maxBound
11:22:10 <[exa]> the Irrel thing
11:22:12 <yahb> Solonarv: [Timed out]
11:22:29 <mniip> [exa], well, you get a function that can locally satisfy any constraint
11:23:04 <Solonarv> hm, so the issue is that the (Irrel a c => Irrel a c) constraint magics up a (bottom) instance dicitonary
11:23:05 <Solonarv> right?
11:23:17 <mniip> yes
11:24:17 <mniip> now the fun part is that whatif is not otherwise bottom
11:25:02 <[exa]> oh wow
11:25:06 <mniip> % whatif (Proxy @(Bounded String)) (1, 2, show $ maxBound :: String)
11:25:12 <yahb> mniip: [Timed out]
11:25:13 <Solonarv> % whatif (Proxy @(Bounded Int)) maxBound
11:25:14 <yahb> Solonarv: ; <interactive>:1:1: error: Variable not in scope: whatif :: Proxy (Bounded Int) -> t0 -> t
11:25:16 <mniip> ...
11:25:23 <mniip> one moment...
11:25:25 <mniip> oh dang
11:25:30 <mniip> it is bottom after all
11:25:38 <mniip> this one at least...
11:25:53 <mniip> yeah, this new definition loses all magical properties
11:29:10 <mniip> ima put into a file
11:29:16 <w1n5t0n> I have installed a C library which gave me the folders bin, include, and lib, and I'm trying to install a Haskell package which has a dependency on it. Which files does cabal need to find with the --extra-include-dirs and --extra-lib-dirs arguments? In other words, do I pass the include and lib folders respectively?
11:29:19 <mniip> % :load whatif.hs
11:29:20 <yahb> mniip: [1 of 1] Compiling Main ( whatif.hs, interpreted ); Ok, one module loaded.
11:29:28 <mniip> % whatif (Proxy @(Bounded String)) (1, 2, show $ (maxBound :: String))
11:29:33 <yahb> mniip: (1,2,"\"[Timed out]
11:30:02 <sclv> w1n5t0n: did you see what i pased above?
11:30:03 <sclv> https://gist.github.com/gbaz/95a56ae10e36276071c067d3be714d9e
11:30:22 <sclv> i had wanted to work out the path with pacman on windows anyway, just to make sure i understood it
11:30:39 <sclv> getting it working was a bit of a hassle because of stupid permission issues plus needing to update keys
11:31:06 <sclv> but once i had it working, i could use it just like a linux package manager and install the lib into my msys distro that way
11:31:15 <sclv> and then i needed to add the paths
11:31:25 <__monty__> Pacman on windows?
11:31:27 <sclv> (note this installs it as a .a, not a .dll i think)
11:31:45 <sclv> after that i ran cabal install successfully
11:32:02 <sclv> i didn't try to reproduce the dll approach to see if i could make that work too
11:32:51 <Solonarv> pacman on windows via MSYS2, yes
11:33:34 <Solonarv> MSYS2 is a "unix-stuff-on-windows" project, and a version comes bundled with the haskell platform
11:34:02 <__monty__> What's the advantage compared to WSL?
11:34:16 <w1n5t0n> sclv: oh thanks, I hadn't seen that! when I run pacman-key --init I get "cannot create temp file for here-document: Permission denied"
11:34:26 <sclv> that's the permission stuff i mention
11:34:41 <geekosaur> WSL's still got lots of rough edges, too
11:34:45 <sclv> i had to set all the msys folders to have global permissions
11:34:59 <sclv> i might have been a bit indiscriminate in what permissions i granted
11:35:09 <sclv> i basically gave everythign to everyone -- i was getting frsutrated :-)
11:35:29 <Solonarv> WSL is also very new; msys has been around for way longer
11:35:46 <sclv> i think ultimately wsl might be the one true way
11:35:50 <Solonarv> I use win7, so no WSL for me (as an example)
11:35:53 <sclv> but people are still just getting stuff worked out
11:36:22 <geekosaur> and WSL's got an actual linux kernel of sorts behind it, so on the one hand it does some things better than msys2 can, but on the other there's no way to share some resources between native and WSL processes
11:36:42 <geekosaur> (midn, you'd have to be doing fairly tricky things to run into the latter)
11:36:50 <sclv> We really need a single "here's how to setup and use the msys pacman stuff on windows" guide
11:37:07 <mniip> "actual linux kernel" is abit of an overstatement
11:37:17 <sclv> i feverently hope someone besides me will write it, but i suspect i'll end up doing it
11:37:24 <sclv> even though it doesn't scratch a personal itch
11:37:28 <Solonarv> if you're using stack, it's amazingly easy - just prefix it all with `stack exec --`
11:37:41 <sclv> Solonarv: its not the path stuff
11:37:46 <geekosaur> well, it's loose. it's been rewired into a proper microkernel, but still has some single-server aspects
11:37:47 <sclv> its running pacman to install stuff
11:37:51 <mniip> Solonarv, stack exec -- startx
11:37:53 <sclv> the bits that hit me were all issues about msys
11:37:53 <geekosaur> er, microkernel guest
11:37:59 <sclv> not about cabal
11:40:16 <dmwit> mniip: You put your import on the same line as the language pragmas??
11:40:19 <dmwit> How does that even work.
11:40:30 <dmwit> Are pragmas ignored for indentation purposes?
11:40:37 <mniip> pragmas are just comments
11:40:50 <dmwit> Sure, but don't they affect which column you're in?
11:41:25 <dmwit> Do you indent your entire file by the width of your language pragma?
11:42:01 <mniip> it's all on one line
11:42:06 <dmwit> ohhhh
11:42:59 <dmwit> Multiple lines is indistinguishable from a single line with semicolons in in yahb output. =P
11:44:23 <mniip> %%
11:44:23 <yahb> mniip: http://qp.mniip.com/y/64
11:44:55 <mniip> that allows multiline output
11:45:11 <mniip> %%! cat ../usr/runghci/init
11:45:11 <yahb> mniip: http://qp.mniip.com/y/65
11:47:45 <dmwit> mniip: cool
11:48:29 * hackage squeal-postgresql 0.3.0.0 - Squeal PostgreSQL Library  http://hackage.haskell.org/package/squeal-postgresql-0.3.0.0 (echatav)
11:48:48 <dmwit> Oh, -dppr-cols is handy. Glad to learn about it.
12:02:23 <Zemyla> Is there any sort of Comonadic counterpart to Traversable?
12:02:48 <Zemyla> Something like (Cotraversable t, Comonad w) => (w a -> b) -> w (t a) -> t b?
12:06:32 <mniip> I found a Cotraversable in hs-functors but that seems different from what you're proposing
12:07:55 <mniip> Zemyla, according to edwardk it suffices to use Functor w
12:08:02 <dataN> Zemyla: thats (Traversable t,Comonad w)
12:08:16 <dataN> ?
12:08:21 <mniip> and then Cotraversable ~ Distributive
12:09:54 <mniip> % :t sequenceA
12:09:54 <yahb> mniip: (Traversable t, Applicative f) => t (f a) -> f (t a)
12:09:58 <dataN> oh, your want w (t a) -> t (w a) as a class over t?
12:09:58 <mniip> % :t Data.Distributive.distribute
12:09:59 <yahb> mniip: (Data.Distributive.Distributive g, Functor f) => f (g a) -> g (f a)
12:15:22 <uniquenick> is there an up to date/working guide to debugging ghc core dumps?
12:15:46 <mniip> it's always been a mess
12:16:31 <mniip> wait do you mean coredumps in the ELF coredump sense or Core language dumps?
12:16:57 <mnoonan_> (does "it's always been a mess" work for both?)
12:17:16 <mniip> nah dissecting Core is kind of okay
12:17:17 <w1n5t0n> sclv: YES! It worked! I would never think to try that, thanks so much dude you saved my ass!
12:17:26 <sclv> glad i could help
12:17:30 <sclv> i learned something out of this too
12:17:42 <sclv> i'll try to write it up for future reference
12:17:49 <uniquenick> in the ghc segfaults trying to compile packages that use template haskell sense
12:18:05 <mniip> that's different
12:18:18 <mniip> is the TH particularly bad TH?
12:18:33 <mniip> in the unsafeXXX sense?
12:19:01 <uniquenick> I know less than nothing about TH.  it is postgresql-simple
12:21:44 <mniip> well if you want to dig around in RTS code you've subscribed for a lot of hell
12:22:49 <mniip> also does it really use TH
12:23:10 <mniip> I see it uses types from template-haskell but it doesn't advertise using TemplateHaskell in the .cabal file
12:23:23 <mniip> suggesting that it only defines some quasiquoters and doesn't *use* them itsel
12:24:41 <uniquenick> yeah it pukes trying to compile FromField.hs, if I ghc -v4 it barfs after loading the packages
12:24:45 <uniquenick> Loading package vector-0.12.0.1 ... linking ... done.
12:24:45 <uniquenick> Loading package aeson-1.4.0.0 ... linking ... done.
12:24:45 <uniquenick> Bus error (core dumped)
12:25:15 <mniip> ah
12:25:18 <mniip> are you out of memory
12:25:47 <mniip> sounds like your kernel failed to handle a page fault in a MMAP_NORESERVE area
12:25:51 <mniip> likely for OOM reasons
12:26:11 <uniquenick> nope.  openbsd not linux
12:27:46 <uniquenick> it isn't always bus error.  it is randomly either segfault, bus error or illegal instruction
12:29:27 <mniip> I'd run memtest
12:29:42 <mniip> though it equally likely could be a fuckup somewhere deep in the RTS
12:29:53 <geekosaur> or a bug in dynamic linking
12:30:01 <mniip> or that
12:30:12 <uniquenick> it happens to everyone using ghc 8 on openbsd, its not a machine specific thing
12:30:56 <mniip> not sure how a dynamic linking issue would lead to SIGABRT
12:31:33 <mniip> err
12:31:34 <mniip> SIGBUS
12:32:02 <geekosaur> all it'd take was a mis-computed relocation
12:32:38 <mniip> and then?
12:33:17 <mniip> you're not suggesting someone uses alignment checking by default?
12:33:24 <geekosaur> and then it depends on how address faults get reflected as signals. openbsd follows different rules from linux
12:33:37 <lukelau> Is there a nicer way of composing <$> in a point free style? Instead of foo = (bar <$>) . baz
12:33:44 <mniip> ah yes, that totally skipped my mind
12:34:09 <dminuoso> lukelau: use `fmap`
12:34:12 <dminuoso> lukelau: fmap bar . baz
12:34:20 <geekosaur> with 2-level page tables, SIGBUS can mean missing entry in the upper level vs, SIGSEGV a missing entry in the lower one
12:34:55 <lukelau> dminuoso: That’s a lot cleaner thanks!
12:35:03 <uniquenick> openbsd does a bunch of stuff for exploit mitigation, at least one involves randomizing something when linking, so that could either have a bug, or be exposing a bug in ghc
12:35:38 <lukelau> Is there a function that does the equivalent of this? x `f` y = fmap x . y
12:35:48 <oak> Couldn't git bisect be used on ghc repository to find a specific commit which starts to cause this on openbsd? Assuming this issue does not appear on older ghc versions
12:35:58 <lukelau> I’m using it quite often
12:37:06 <dminuoso> lukelau: It might be easier to see a bit code, especially with the context.
12:37:46 <mniip> uniquenick, are you able to compile your own GHC?
12:37:47 <dminuoso> oak: You haven't compiled ghc recently, have you?
12:38:08 <oak> Well not on OpenBSD
12:38:56 <lukelau> dminuoso: In this context
12:38:57 <lukelau> https://lpaste.net/8310702172333408256
12:39:42 <uniquenick> yeah, I recompiled it with BuildFlavor = devel2 and the -g3 options
12:40:29 <mniip> uniquenick, can you build the stage2 in the 'debug' way?
12:41:14 <uniquenick> if you tell me what that means I can try
12:41:24 <mniip> ah it seems devel2 already does
12:41:38 <lukelau> It’s not the ugliest haskell, but would be nice to make it a bit nicer
12:42:26 <mniip> uniquenick, run GHC with +RTS -DS
12:42:28 <dminuoso> lukelau: You could extract `fmap (T.pack . fst) . targetPackage` into a separate binding
12:44:26 <uniquenick> hmm.  ghc: the flag -DS requires the program to be built with -debug
12:45:41 <dminuoso> lukelau: Are you using lens already?
12:46:11 <glitters1ark> is there a version of mapConcurrently somewhere that doesn't jump through the extra hoops to make sure the resulting list of results is in the same order?
12:46:33 <lukelau> Not for that no, but yeah I think I can just move that into a where helper function
12:46:51 <glitters1ark> I'd love to be able to just take results from a lazy list as they finish processing, rather than having to wait for the first element if something else finishes earlier
12:47:19 <mniip> uniquenick, add '-debug' to GhcStage2HcOpts in, say, mk/flavours/devel2.mk
12:48:02 <mniip> removing ghc/stage2/ should make it rebuild
12:48:47 <mniip> brb
12:49:44 <lukelau> Speaking of lenses though, is it possible to have something like this? https://lpaste.net/8730843990716317696
12:49:54 <uniquenick> it is rebuilding everything so it'll be a couple of hours
12:50:16 <Gurkenglas> lukelau, has searchTargets form "\f -> fmap (mapMaybe f) . _"?
12:51:15 <lukelau> Gurkenglas: Somewhere in the middle but its tied in between a bunch of IO stuff
12:52:27 <Gurkenglas> lukelau, similar problem as map show [123, ("asd",32)]
12:52:28 <lukelau> It makes sense that you can’t have a heterogenous array of lenses, is there a way to box them with the type variable constraint instead?
12:52:29 <dmwit> lukelau: Yes, but it will be just as syntactically noisy as `foldl' (.) id [applyLens lensOne, applyLens lensTwo, applyLens lensThree, applyLens lensFour]`.
12:53:06 <mniip> uniquenick, shouldn't be everything
12:53:14 <mniip> that rebuild just a couple dozen files for me
12:53:48 <dmwit> lukelau: (So the boxing isn't worth it unless you think the list can't be constructed statically.)
12:54:15 <lukelau> dmwit: Thought as much, was worth a shot anyway
12:54:26 <Gurkenglas> lukelau, depending on what SomeClass does there may be a trick to it
12:55:04 <Gurkenglas> (more precisely, what applyLens does)
12:55:37 <lukelau> Gurkenglas: The class is one of HasX classes that control.lens.th generates
12:55:48 <Gurkenglas> lukelau, have you considered template
12:56:21 <Gurkenglas> > template +~ 1 $ ("asd",5,1,3,"xda")
12:56:23 <lambdabot>  ("asd",6,2,4,"xda")
12:56:41 <dmwit> yikes
12:56:43 <dmwit> :t template
12:56:44 <lambdabot> (Typeable a, Applicative f, Data s) => (a -> f a) -> s -> f s
12:56:49 <dmwit> YIKES
12:56:55 <aarvar> ew
12:57:02 <Gurkenglas> > template +~ 1 $ ("asd",5,1,3,[(1,3,"asd"),(5,5,"")]) -- MWAHAHA
12:57:04 <lambdabot>  ("asd",6,2,4,[(2,4,"asd"),(6,6,"")])
12:57:20 <lukelau> :k Data
12:57:21 <lambdabot> * -> Constraint
12:57:36 <lukelau> :t +~
12:57:37 <lambdabot> error: parse error on input ‘+~’
12:57:42 <lukelau> :t (+~)
12:57:43 <lambdabot> Num a => ASetter s t a a -> a -> s -> t
12:58:44 <lukelau> Gurkenglas: woah
12:58:48 <Solonarv> oh god WHY
12:59:10 <Gurkenglas> (Don't use this on a runtime bottleneck, iirc)
12:59:25 <Gurkenglas> (it has to keep around all the type information for runtime)
12:59:52 <lukelau> I don’t think its worth it for having that typeable constraint lol
13:00:05 <Solonarv> personally I'd amend that to "don't use this"
13:00:06 <lukelau> Thats still pretty cool though
13:00:11 <aarvar> lukelau: (:$) l f = applyLens l . f; infixr :$; lensOne :$ lensTwo :$ lensThree :$ id
13:01:17 <aarvar> er, you could make that shorter
13:02:24 <aarvar> or just infixr applyLens; lensOne `applyLens` lensTwo `applyLens` x
13:03:19 <lukelau> aarvar: That looks pretty good
13:05:29 * hackage trackit 0.4 - A command-line tool for live monitoring  http://hackage.haskell.org/package/trackit-0.4 (EmilAxelsson)
13:05:54 <runeks> How do I printf a floating point number with some number of significant digits? the "%.g" formatting char doesn't seem to work with Text.Printf.printf
13:07:37 <pdxleif> @hoogle Monad m => (m a, b) => m (a, b)
13:07:37 <lambdabot> ICal.Parser getState :: Monad m => Parser m s s
13:07:37 <lambdabot> Game.VierGewinnt brettGroesse :: ((Int, Int), (Int, Int))
13:07:37 <lambdabot> Control.Monad.Trans.Peel idPeel :: (Monad m, Monad n, Monad o) => n (m a -> m (o a))
13:08:47 <pdxleif> > sequence (5, Just 10)
13:08:49 <lambdabot>  Just (5,10)
13:10:09 <Gurkenglas> In the coslice category of functors from the category of polynomial-time reductions, what's the product of all functors onto * -> * look like? (Is there a better way to ask this?)
13:10:50 <dmj`> What is recommended for dead code detection in Haskell
13:11:11 <exio4> GhC?
13:11:13 <Gurkenglas> dmj`, stack has a code coverage thing
13:11:13 <exio4> GHC*
13:11:22 <Gurkenglas> (which it gets from ghc, i think)
13:11:48 <Gurkenglas> hpc is a name of something in the chain of gets-it-froms, I think?
13:12:15 <hexagoxel> there is also the `weeder` package (have not used it myself)
13:12:20 <hexagoxel> @hackage weeder
13:12:20 <lambdabot> http://hackage.haskell.org/package/weeder
13:12:52 <Gurkenglas> Or do you want to find the dead code without actually running the program?
13:13:10 <cocreature> it kind of depends on what kind of dead code we are talking about. unused functions within a module, unused functions in a package, unused functions in multi-package projects, …
13:13:30 <dataN> now it gives this error; https://lpaste.net/1659998696625930240
13:13:34 <Gurkenglas> (the two approaches bound the set of code that never gets run from different sides)
13:22:34 <dmj`> Gurkenglas: I don’t use stack really
13:23:05 <dmj`> cocreature: unused modules would be great for starters
13:23:19 <dmj`> Gurkenglas: but I assume stack is calling into cabal / ghc and I can just make that call manually
13:24:54 <cocreature> dmj`: weeder can detect unused modules in other-modules
13:26:07 <cocreature> but it also requires stack and I think in weeder’s case it’s not trivial to replace that
13:28:59 <__monty__> You could install it with nix : )
13:30:25 <cocreature> that doesn’t help?
13:30:56 <__monty__> Ah, misunderstood the requires, my apologies.
13:30:59 * hackage servant-JuicyPixels 0.3.0.4 - Servant support for JuicyPixels  http://hackage.haskell.org/package/servant-JuicyPixels-0.3.0.4 (TvH)
13:31:27 <pdxleif> @djinn Monad f => (f a, b) -> f (a, b)
13:31:27 <lambdabot> -- f cannot be realized.
13:31:39 <pdxleif> I thought lambdabot claims if there is a solution it will find one?
13:31:42 <pdxleif> err, djinn
13:32:16 <pdxleif> That's just (fmap swap) . sequence . swap
13:33:12 <pdxleif> Maybe it doesn't have a Traversable instance for tuples.
13:33:24 <tdammers> I think it doesn't do tuples at all
13:33:39 <tdammers> @djinn (a, b) -> a
13:33:39 <lambdabot> f (a, _) = a
13:33:44 <tdammers> hmm so it does
13:33:45 <pdxleif> @djinn (a, b) -> (b, a)
13:33:45 <lambdabot> f (a, b) = (b, a)
13:34:41 <hexagoxel> it does not do typeclasses, to any useful degree
13:34:44 <hexagoxel> @djinn Monad m => a -> m a
13:34:45 <lambdabot> f = return
13:34:49 <hexagoxel> @djinn Monad m => b -> m b
13:34:49 <lambdabot> -- f cannot be realized.
13:35:06 <pdxleif> wat
13:35:21 <hodapp> that was 3 wishes
13:35:55 <hexagoxel> :exf " Monad f => (f a, b) -> f (a, b)"
13:35:56 <exferenceBot> \ a -> let ((,) c d) = a in fmap (\ g -> (g, d)) c
13:38:41 <geekosaur> pdxleif, it only understands typeclasses literally, so you have to use the exact type variables that djinn's definition of e.g. Monad does or it will get lost. and even that's a hack; it doesn't really understand typeclasses
13:39:14 <geekosaur> it does dumb substitutions and hopes for the best, rather than unifying them
13:43:08 <Tuplanolla> Accurate simulation of a real programmer.
13:43:31 <butterthebuddha> I have this global mutable "environment" in my program; sometimes I create a new environment and set its "parent" environment to be this global mutable environment; but the mutations of the global environment aren't reflected in the smaller child environment
13:43:54 <butterthebuddha> Is there a way of fixing this without having to pass the global environment around everywhere?
13:44:26 <pdxleif> So I can write "\a -> fmap (, fst a) (snd a)" instead of "sequence" - I guess that makes sense.
13:44:29 <Rembane> butterthebuddha: The State monad?
13:44:39 <Rembane> butterthebuddha: Or the Reader monad.
13:46:56 <butterthebuddha> Rembane: that may indeed work; a further issue is that I want to be able to construct an arbitrarily large tree of these environments
13:47:06 <butterthebuddha> How would I keep track of the parent environment?
13:47:32 <butterthebuddha> It might be the case that I'm just being really dumb and this is a non-issue
13:47:57 <hexagoxel> butterthebuddha: is it supposed to be thread-safe?
13:48:01 <fishythe_> butterthebuddha: by tracking the root of the tree?
13:48:13 <butterthebuddha> hexagoxel: that's not a concern, no
13:48:44 <glguy> sequenceOf _1 :: Monad f => (f a, b) -> f (a,b)
13:49:54 <hexagoxel> one day i will curate lens into the exference dictionary .. :)
13:50:26 <lin_> there is this huge project, managed by one cabal file, I'm trying to use stack now. and used stack init --force --solver. A stack.yaml file was created but stack build still tells me that for example Semigroup is missing. I am not sure where to add that, because it doesn't work if i add it in extra-deps
13:51:15 <butterthebuddha> fishythefish: How?
13:52:06 <Rembane> butterthebuddha: Create a list of evnironments, add a new env to the head of the list when you need one.
13:52:18 <Rembane> butterthebuddha: Remove it when you're done.
13:52:30 <fishythefish> butterthebuddha: e.g. if you're using State, then the state you store would be the whole tree of envs
13:52:57 <fishythefish> in a different language, you would specifically store the root node pointer or something, but you get this for free in haskell since you'll be pattern matching at the root node
13:53:46 <hexagoxel> (or use a zipper as the state? i don't feel i know enough about what you actually want to achieve..)
13:55:25 <fishythefish> I'm not sure what data your nodes carry, whether you need to be able to retrieve a parent given a child, etc. but you could tie the knot or use a zipper
13:55:44 <fishythefish> if you need to traverse toward the root
14:08:48 <lin_> if a hs file has import Data.Semigroup in it and that is without errors, why would the type constructor or class Semigroup not be in scope (in the same file)?
14:09:28 <glguy> which type constructor
14:09:41 <lin_> Semigroup
14:09:57 <glguy> perhaps the import is surrounded by CPP
14:13:25 <lin_> cpp as in c++?
14:13:37 <Solonarv> C PreProcessor
14:13:45 <lin_> nope
14:13:47 <lin_> its not
14:14:31 <lin_> the file that is giving trouble is this one https://github.com/LinFelix/vanda-haskell/blob/master/library/Data/Weight.hs
14:15:05 <mjoldfie_> That loads Data.Semiring not Semigroup
14:15:15 <lin_> ah
14:16:10 <lin_> Sorry to have bothered with my blindness and thanks for the quick help
14:16:49 <zenwan> greetings, RWH ch. 17 mentions a way of including a static library into ghci, (e.g. -lpcre). How could i do the same with a custom library, not in the system path (by giving a fully qualified path). -lib:mylib.a doesn't work.
14:17:32 <glitters1ark> zenwan: -optl-Wl,-rpath,path/to/mylib
14:17:34 <glitters1ark> I think
14:17:50 <glitters1ark> the -rpath is for relative, there's also -path iirc
14:20:03 <geekosaur> static lib
14:20:09 <geekosaur> just give the full path to the ,a file
14:20:12 <geekosaur> .a file
14:20:16 <zenwan> thanks, will try that. i guess that for a cabal project, the fields mentioned here should work: https://stackoverflow.com/questions/4959802/how-to-specify-dependency-on-external-c-library-in-cabal
14:20:29 <geekosaur> rpathis about finding .so files at runtime
14:21:28 <geekosaur> although you may need something to make it link in the whole archive, come to think of it; static linking is demand driven, if nothing at that point needs a symbol from a .o within the archive, it'll be ignored
14:21:32 <zenwan> geekosaur: wha do you mean? where should the path go?
14:22:03 <zenwan> i have a .hsc file that imports some c functions
14:22:39 <zenwan> right now, when calling said function in ghci i get : ghc: ^^ Could not load 'git_repository_open', dependency unresolved. See top entry above.
14:23:25 <geekosaur> looks like it just ignores .a files, actually. might have to unpack it and name the .o files explicitly
14:24:15 <geekosaur> oh, you don't actually mean static library, I suspect. you just want a C library. path to .so file does work
14:24:26 <geekosaur> or .so.N
14:24:27 <zenwan> git_repository_open is said c function from libgit2. I know i could just install the libgit2 into the system, and use -lgit2. I expect that to work, as in RWH ch17
14:24:43 <zenwan> i do want a static library (.a)
14:24:45 <geekosaur> hm, no, only recognizes .so.
14:25:18 <geekosaur> that's going to be a problem, then. static objects and archives are problematic in general for runtime loading
14:25:59 <geekosaur> and rwh is old enough that it may assume a 32-bit system where static objects could be loaded directly at runtime; a trick that doesn't work in 64 bit
14:27:37 <zenwan> so i just tried it and it does work if the library is installed into the system path (e.g. /usr/lib) and fed using -lgit2 in my case to ghci (X86_64 system)
14:28:10 <zenwan> but i want a custom library. and even that -l option is not documented as far as i can tell.
14:28:25 <zenwan> at least cabal should be able to link it, i hope.
14:28:38 <geekosaur> ghci's a bit … special
14:30:28 <dataN> ok, this error is easier to read; https://lpaste.net/4137127892117094400
14:31:08 <geekosaur> probably it needs to be taught to accept .a files and load all the .o files contained within. other stuff uses the system linker to do it, but ghci is trying to load things at runtime and can't use the system linker to do it
14:37:21 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#extra-libraries suggests $LD_LIBRARY_PATH might help. although it implies that it only looks for .so
14:38:30 <dataN> it might be something to do with the use of (k->*) in LiftN via ReifiableConstraintN, or the forall of Polymorphic upsetting the Reified context argument...
14:39:21 <dataN> as the error suggests
14:54:04 <mniip> uniquenick, any luck
14:57:33 <mreh> angerman, mobilehaskell.org DNS still seems to be off
15:02:59 * hackage hasql-migration 0.2.0 - PostgreSQL Schema Migrations  http://hackage.haskell.org/package/hasql-migration-0.2.0 (TvH)
15:07:57 <greymalkin> Anyone have experience with using monad-logger's runChanLoggingT and forkIO?
15:09:59 <lyxia> what about them
15:11:45 <greymalkin> I can't find the clean way to run the thread with whatever logger the caller had; I think it may be a symptom of my not understanding the monad soup that the logger monad is, and I would be open to a different implementation; I just need stdout to stop having interleaved messages :(
15:12:58 <greymalkin> In signature, I need something like `LoggingT IO a -> LoggingT IO ThreadId`
15:13:52 <lyxia> what output do you expect?
15:14:12 <greymalkin> Hmm... nevermind, I need to suss this out a bit more -- I'm using `ResourceT` to cleanly shutdown on exit; which means it will need to be slightly more complicated.
15:15:22 <dataN> it now gives this error; https://lpaste.net/672909504270041088
15:17:33 <dataN> normally just writing Sub Dict works but the Polymorphic is preventing this it seems
15:22:59 * hackage hbf 0.1.0.2 - An optimizing Brainfuck compiler and evaluator  http://hackage.haskell.org/package/hbf-0.1.0.2 (paraseba)
15:23:59 * hackage hs2ats 0.3.0.3 - Create ATS types from Haskell types  http://hackage.haskell.org/package/hs2ats-0.3.0.3 (vmchale)
15:25:35 <dataN> seems like the type to be accessed via proxy is buried underneath some unspecified depth
15:27:49 <dataN> this seems to be the tradeoff introduced by using the type Polymorphic to flatten the higher kinded versions
15:29:20 <dataN> so that rather than avoiding the need for the type Lift2, there should be something like it for arbitrary N, which is worse.
15:29:30 * hackage happstack-jmacro 7.0.12.1 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-7.0.12.1 (JeremyShaw)
15:40:00 * hackage ats-pkg 2.11.0.7 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-2.11.0.7 (vmchale)
15:40:38 <dataN> the error seems to suggest creating an instance (EmptyN (Lift EmptyN a s)), but this does not seem possible, even via recursion, since the depth isnt available. what seems more likely is that some chain of entailment should be provided somehow.
15:43:00 * hackage cdeps 0.1.1.4 - Extract dependencies from C code.  http://hackage.haskell.org/package/cdeps-0.1.1.4 (vmchale)
15:48:20 <johnw> is there a faster way to implement this: cmp xs ys = sort xs == sort ys
15:48:22 <uniquenick> mniip: it doesn't complain about "+RTS -DS" now, but it doesn't do anything different
15:48:27 <johnw> i.e., order agnostic membership comparison
15:49:52 <Solonarv> nothing comes to mind immediately
15:55:08 <dataN> what seems worse is there seems to be no way to terminate the recursion, even if it was clear
15:56:15 <dataN> https://lpaste.net/672909504270041088
16:01:30 * hackage google-static-maps 0.5.0.2 - Bindings to the Google Static Maps API  http://hackage.haskell.org/package/google-static-maps-0.5.0.2 (mpilgrem)
16:13:30 * hackage shake-ats 1.9.0.1 - Utilities for building ATS projects with shake  http://hackage.haskell.org/package/shake-ats-1.9.0.1 (vmchale)
16:22:36 <dmwit> johnw: There may be a faster sort than sort, depending on what `xs` and `ys` look like.
16:22:50 <johnw> [Int], of known length
16:23:10 <johnw> i.e., I will already know that length xs == length ys
16:23:10 <Welkin> List.sort is meresort
16:23:16 <Welkin> mergesort*
16:23:28 <dmwit> Comparing `IntMap Int`s for equality might be a bit faster. I'd want to profile to be sure.
16:23:49 <dmwit> (keys are elements from the original list, values are counts)
16:24:00 <hpc> if the lists are already sorted, id is fastest :D
16:24:09 <johnw> one of them is already sorted, the other is not
16:26:06 <dmwit> Are the elements unique?
16:26:32 <dmwit> Never mind. Even if they are the idea I had is still n*log n.
16:27:12 <johnw> the elements of one are unique, of the other maybe not
16:27:37 <byorgey> johnw: what about the bounds of the elements?
16:27:37 <johnw> (the sorted list is like [1,2,3,4,5], while the other list is also 5 elements long, but may contain duplicates or be in any order)
16:27:54 <johnw> the elements will be members of a range
16:28:13 <johnw> say, 1-1500, for example, but only ever N elements of that range
16:28:24 <byorgey> how big is the range?  because I am thinking of things involving updating a mutable array.
16:28:31 <dmwit> Oh, well then, counting sort with an array is probably the way to go.
16:28:40 <johnw> ah
16:28:46 <byorgey> there you go.  make a mutable array of booleans
16:28:46 <johnw> i have no idea how large the range might be
16:28:48 <dmwit> I was going to suggest that earlier but Int is too big without that extra knowledge.
16:29:12 <johnw> I also need to know that every element of the sorted list is present in the other list
16:29:41 <dmwit> I don't see that as a big barrier.
16:29:41 <johnw> i.e., for compare xs ys: length xs == length ys, sorted xs, ys `elem` permutations xs, unique xs
16:29:52 <dmwit> If all the counts match up, and you know the lengths are equal, you're done.
16:31:35 <mniip> uniquenick, so it still crashes?
16:33:17 <uniquenick> yep, and doesn't print anything extra
16:34:10 <nshepperd_> You could turn xs into a multiset in O(length xs) then run through ys removing elements in O(log(length xs) * length ys)
16:34:58 <nshepperd_> This may not be asymptotically better than sorting, but at least it's different
16:35:43 <johnw> nshepperd, dmwit, byorgey: hmm.. I appreciate the ideas
16:36:29 * hackage google-maps-geocoding 0.4.0.1 - Google Maps Geocoding API bindings  http://hackage.haskell.org/package/google-maps-geocoding-0.4.0.1 (mpilgrem)
16:37:13 <mniip> uniquenick, try -Dl then
16:38:10 <mniip> also -Dm
16:39:23 <mniip> maybe even -Da if it's broken deep in the RTS
16:43:04 <N3RGY> How do I create a type function of type "* -> Constraint"? I can write eg "type Unrestricted t = () ~ ()", but if I try to pass this as a type level function, I get "The type synonym ‘Unrestricted’ should have 1 argument, but has been given none"
16:43:39 <mniip> class Unrestricted t
16:43:42 <mniip> instance Unrestricted t
16:44:44 <N3RGY> What if I wanted "type IsInt t = t ~ Int"?
16:45:06 <mniip> type IsInt = ((~) Int)
16:45:33 <mniip> type synonyms and type families cannot be partially applied
16:46:17 <mniip> namely because if you have a type family of kind * -> Constraint  that (->) should be different to the one in, say, Maybe :: * -> *
16:46:34 <mniip> (unmatchable vs matchable)
16:47:32 <N3RGY> Don't see why the difference would prevent partial application. Both matchable and unmatchable functions are partially applicable at the term level
16:47:53 <N3RGY> But thanks for the tip, the prefix notation helps me for now. Don't know if it solves my general problem
16:48:37 <mniip> N3RGY, because you cannot pattern match on functions anyway
16:48:45 <mniip> but you can at the type level
16:49:02 <mniip> you can have  type family F (x :: * -> *) where F Just = ...
16:49:26 <N3RGY> Can I have a type family that returns  a constraint?
16:49:38 <mniip> and if we'd ever have dependent types as per goldfire's thesis we will be able to do so on terms too
16:49:53 <mniip> N3RGY, you can return a (* -> Constraint) from the family
16:49:55 <uniquenick> mniip: it seems to be crashing while doing lookupSymbols in openssl
16:50:08 <mniip> but if your family is * -> Constraint itself, then it'll have to appear fully applied
16:50:36 <N3RGY> Wait, how do dependent types let us match on term level functions? That is new to me
16:51:21 <mniip> with dependent types in mind there's two different types of arrow: matchable and unmatchable
16:51:36 <mniip> per goldfire's notation,  '->  and  ->  respectively
16:51:47 <N3RGY> cool
16:51:49 <mniip> all data constructors have matchable arrows
16:51:55 <mniip> all lambda functions have unmatchable arrows
16:51:56 <N3RGY> Man, we're gonna have a lot of arrows soon
16:52:03 <N3RGY> Looking forward to '-o
16:52:47 <mniip> the thing with matchable arrows is generativity
16:53:04 <mniip> if  f, g :: k '-> l
16:53:14 <mniip> and  f /= g
16:53:20 <mniip> then  f x /= g y
16:53:23 <mniip> for any x,y
16:53:41 <mniip> that's not something you can expect with "functions", but you can with data constructors
16:54:25 <mniip> more specifically iirc is that  f x = g y implies f = g, x = y
16:56:34 <N3RGY> Cool, thanks
16:56:42 <jle`> i've also seen ~> notation from goldfire for matchable arrows, but i can see why '-> would be nicer
16:56:51 <mniip> ~> is my notation iirc
16:57:02 <mniip> but it was that ~> is unmatchable and -> is matchaable
16:57:54 <N3RGY> ~> is used for (forall a . f a -> g a) -> t f -> t g in several contexts I've seen
16:58:24 <jle`> https://github.com/ghc-proposals/ghc-proposals/pull/52#issuecomment-300485400 is actually in response to your post actually heh, so he might have just been using yours that time :o
16:58:34 <jle`> N3RGY: yeah i like using ~> for that
16:58:43 <lin_> what is (..)?
16:59:01 <jle`> in what context?
16:59:15 <jle`> in import/export syntax it's used to say "and all associated things"
16:59:24 <lin_> yeah, there
16:59:26 <jle`> like record fields, constructors, typeclass methods
16:59:46 <jle`> module Data.Maybe where (Maybe(..)) is shorthand for exporting Maybe(Just, Nothing)
16:59:55 <jle`> and also any record accessors if Maybe has any
17:00:08 <jle`> exporting Monad(..) is shorthand for exporting Monad, return, and (>>=)
17:00:14 <lin_> I see, thanks jle`
17:00:30 <nyaomi> when i do "runhaskell" on a hello world it works fine, but when I do "ghc" on it it gives me "Could not find module ‘Prelude’; There are files missing in the ‘base-4.11.1.0’ package, try running 'ghc-pkg check'. Use -v to see a list of the files searched for."; running "ghc-pkg check" just prints a bunch of warnings about haddock-interfaces and haddock-html
17:01:44 <jle`> N3RGY: just fyi i've been using the singletons package to work with partially applied type synonyms
17:02:08 <jle`> it uses a trick called defunctionalization, and uses template haskell to make it slightly easier to work with
17:02:23 <mniip> ew
17:02:34 <mniip> I mean it's cool that it works but ew
17:02:35 <jle`> in singletons, ~> is a actually a matchable arrow, and -> is the unmatchable one
17:02:49 <jle`> mniip: yes heh i've been diving deep into it for a recent project
17:03:01 <geekosaur> nyaomi, are you on Arch by any chance?
17:03:02 <jle`> it's gross but if you squint at the ugly parts it's not too bad
17:03:06 <nyaomi> geekosaur: yes
17:03:26 <geekosaur> yep. suggest you check the Arch wiki =for the current workarounds. Archs ghc packages are … broken
17:03:38 <nyaomi> ah ok, thanks
17:03:58 <geekosaur> at minimum you want ghc and ghc-static. dunno if you need other things to get a working ghc
17:05:57 <jle`> the main way it works is a (a -> b) becomes (a ~> b), and an (a -> b -> c) becomes an (a ~> b ~> c) (no arguments expected) or an (a -> (b ~> c)) (single argument expected)
17:06:12 <jle`> so the ugly thing is that you need to give different names to the a -> (b ~> c) and the a ~> (b ~> c)
17:06:31 <jle`> and the a -> (b -> c), heh
17:06:45 <jle`> those are three separate things that need three separate names
17:07:12 <jle`> but if you pick a naming strategy then...it all kinda is barely usable
17:07:27 <jle`> just barely
17:10:05 <jle`> for singletons, if you define `type Foo a b = ...`, then the TH will give you `data FooSym0 :: a ~> b ~> c`, `data FooSym1 :: a -> (b ~> c)`, and `type FooSym2 a b = Foo a b`
17:10:22 <jle`> the trick is ignoring the 'Sym1' when you read it in code >___>
17:13:30 * hackage servant-static-th 0.2.1.0 - Embed a directory of static files in your Servant server  http://hackage.haskell.org/package/servant-static-th-0.2.1.0 (cdepillabout)
17:16:59 * hackage servant-static-th 0.2.2.0 - Embed a directory of static files in your Servant server  http://hackage.haskell.org/package/servant-static-th-0.2.2.0 (cdepillabout)
17:20:35 <uniquenick> mniip: https://lpaste.net/2603187022499676160
17:21:47 <mniip> I suspect at this point this might be more productive in #ghc
17:22:13 <uniquenick> oh yeah, that's a good idea
17:39:31 <lin_> if Data.Text.Lazy as T is qualified imported, what would T.Text look like?
17:39:48 <mniip> "look like"
17:39:50 <mniip> ?
17:40:33 <lin_> is it a (basically) String?
17:40:46 <mniip> there's a few major differences
17:40:55 <johnw> :t curry
17:40:56 <lambdabot> ((a, b) -> c) -> a -> b -> c
17:41:12 <johnw> oddly enough, Coq and Haskell are reversed in their definition of what curry and uncurry mean
17:42:47 <mniip> johnw, are they though
17:43:08 <johnw> prod_curry : forall A B C : Type, (A -> B -> C) -> A * B -> C
17:43:45 <johnw> I only notice it because I sometimes prototype in Haskell and then port to Coq, and this is one of the odd changes
17:43:52 <lin_> what would be an easy way to get the contents of a file as a Data.Text.Lazy.Text?
17:44:06 <johnw> Data.Text.Lazy.IO.readFile
17:44:30 <mniip> johnw, funny, the functions in Coq.Numbers.NaryFunctions are the converse
17:44:36 <johnw> although you can find blog posts suggesting this is a terrible function to use if you already know that the data will be UTF-8
17:44:59 * hackage learn-physics 0.6.2 - Haskell code for learning physics  http://hackage.haskell.org/package/learn-physics-0.6.2 (ScottWalck)
17:45:00 <johnw> ah, I'm looking at Coq.Init.Datatypes.prod_curry
17:45:06 <johnw> i haven't used the Coq.Numbers module
17:49:16 <mniip> if I have a function that goes  f :: (forall a. F a) -> ...
17:49:27 <mniip> for a noninjective F
17:50:02 <mniip> and I also have a value of type  F b, where b is an ambiguous tyvar
17:50:12 <mniip> is it ever possible to apply 'f' to that value
17:50:21 <mniip> considering I can't "abstract" over the forall explicitly
17:50:31 <mniip> and F a ~ F b isn't going to solve
17:50:39 <johnw> your F b is a value for a chosen b, not forall b
17:51:03 <mniip> no, b is not rigit
17:51:09 <mniip> it's ambiguous
17:51:30 <johnw> I guess what I mean is, you're trying to hand exists a, F a to a function wanting forall a, F a, no?
17:51:41 <mniip> no, one sec
17:51:57 <johnw> forall a, F a would, I think, only work if a is a phantom type
17:53:57 <mniip> % type family F a
17:53:57 <yahb> mniip:
17:54:04 <mniip> % data A = A (forall a. F a)
17:54:04 <yahb> mniip:
17:54:08 <mniip> % data B = B (forall a. F a)
17:54:08 <yahb> mniip:
17:54:16 <mniip> how to A -> B
17:54:26 <mniip> % :t (\(A x) -> B x)
17:54:26 <yahb> mniip: ; <interactive>:1:14: error:; * Couldn't match expected type `F a' with actual type `F a0'; NB: `F' is a non-injective type family; The type variable `a0' is ambiguous; * In the first argument of `B', namely `x'; In the expression: B x; In the expression: (\ (A x) -> B x)
17:56:32 <mniip> yes, AllowAmbiguousTypes is on
18:00:36 <lin_> if I use Data.Text.Lazy.IO.readFile, i get an IO Text, what could I do if I need an Text?
18:00:55 <mniip> johnw, this is trivially expressible in Core :(
18:01:45 <johnw> lin_: you'll need to be in an IO block, and say: str <- readFile ; return (f str), for your f that takes a Text
18:01:54 <johnw> passing the file name to readFile, of course
18:02:35 <mniip> lin_, you can't* do anything. There's no* way to turn an IO Text into a Text
18:02:47 <johnw> mniip: and if you turn on ScopedTypeVariables and TypeApplications and say \(A x :: A a) -> B @a x?
18:03:43 <mniip> johnw, A x :: A, though
18:03:51 <johnw> oh, right
18:04:00 <mniip> % :t (\(A (x :: t)) -> B @t x)
18:04:00 <yahb> mniip: ; <interactive>:1:19: error:; * Cannot apply expression of type `(forall a. F a) -> B'; to a visible type argument `t'; * In the expression: B @t x; In the expression: (\ (A (x :: t)) -> B @t x)
18:04:11 <mniip> doesn't work as expected because  B :: (forall a. F a) -> B
18:04:17 <mniip> the forall is inside
18:07:01 <mniip> % :t (\(A (x :: forall t. F t)) -> B (x @t))
18:07:02 <yahb> mniip: ; <interactive>:1:37: error: Not in scope: type variable `t'
18:12:12 <mniip> I'll just fudge with unsafeCoerce for now
18:25:00 * hackage extensible-effects-concurrent 0.3.0.0 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.3.0.0 (SvenHeyll)
18:26:01 <tam1138> i have an Int, upon which i can call "show" and then use Data.Text.Pack on the result.  but i can't use showHex: it returns a ShowS instead of a String.  how can I do what I want to do?  (get a value of type Text that contains the hex representation of an integer)
18:28:38 <pavonia> tam1138: Use showHex 123 ""
18:29:22 <tam1138> pavonia: thank you
18:29:55 <geekosaur> ^ a ShowS is a function, string concatenation expressed as function composition. so you get a String encoded as a function, and apply it to the empty string to render it
18:30:23 <tam1138> ah, i see
18:30:29 <tam1138> thanks for the explanation
18:30:35 <geekosaur> or compose it with other ShowS-s to concatenate them and build longer strings
18:30:48 <geekosaur> it's faster because it doesn;t have to traverse an ever-growing String to concatenate
18:31:10 <tam1138> gotcha
18:31:24 <tam1138> i read the description of the type, but it didn't click
18:56:27 <enterprisey> I'm writing a library providing a bidirectional map between Unicode codepoints & Unicode character names
18:56:40 <enterprisey> Is there a really efficient Haskell way to do this, or am I better off using gperf to make some C
19:04:02 <Solonarv> probably something like an Array / Vector in the codepoint -> name direction, and a strict HashMap for the other direction; use Text not String; use template haskell's Lift to avoid constructing the map at runtime
19:09:59 <pdxleif> Woohoo, I did it! All I had to do was put !'s, force, and Data.Tuple.Strict every place I saw, and my program can now processes arbitrarily large files without blowing the heap!
19:11:04 <`Guest00000> is there a library with a better Rational that is capable of division by zero?
19:11:31 <Solonarv> what would the result of such a division be? it can't be a rational number
19:11:36 <`Guest00000> returning (1 % 0)
19:11:50 <`Guest00000> which behaves like infinity from IEEE
19:12:21 <`Guest00000> 1 / 0 == 2 / 0
19:12:23 <Solonarv> if you want vague, mathematically questionable behavior, just use floats / doubles
19:12:29 <`Guest00000> no, i need Rational
19:12:29 <Solonarv> seriously though, why do you want this?
19:12:34 <Solonarv> what are you trying to accomplish?
19:12:46 <`Guest00000> i know what i'm trying to accomplish
19:13:01 <Solonarv> yes but I don't, which is why I'm asking
19:13:15 <pdxleif> Does anyone know if "sum" is strict these days, or is there something else I should be doing?
19:14:24 <`Guest00000> pdxleif: when using GHC optimization and Int's, it's strict (afaicr)
19:14:55 <`Guest00000> Solonarv: i'm trying to implement exact real numbers, and i need to store constant rational values for every expression which is really constant rational
19:15:18 <`Guest00000> but also need to be able to encode 1 / 0
19:15:26 <Solonarv> just roll your own I guess
19:15:42 <Solonarv> should be mostly a copy-paste from the existing Rational
19:16:23 <nshepperd> add data constructors for infinity alongside the rational one?
19:16:55 <`Guest00000> nshepperd: that will require adding a lot of cases into handling
19:17:15 <nshepperd> data MyReal = Rat Rational | Infinity | NegativeInfinity | Algabraic whatever
19:18:33 <`Guest00000> imo, a copy-paste isn't much easier than hand-writing, and at times is less easier, because need to review the code anyway, and reviewing some existing code may be more effortful than writing from scratch
19:18:46 <pdxleif> `Guest00000: I'm summing Int64's - which should be the same as Int on a 64-bit machine?
19:18:51 <Solonarv> write it from scratch then I suppose
19:19:31 <Solonarv> shouldn't be too hard since you can look at the existing Rational to figure out things like simplifying the fraction
19:24:00 * hackage extensible-effects 3.0.0.0 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-3.0.0.0 (shergill)
19:26:51 <crestfallen> hi I'm trying to get monoids based on what I know so far about using foldr with the 4 functions here, (including their logical unit values): https://ptpb.pw/CKDo   I'm attempting to flesh out my understanding by using this post, https://stackoverflow.com/questions/26581100/monoid-bool-in-haskell
19:27:26 <crestfallen> if anyone wouldn't mind walking me through some of that post
19:28:33 <crestfallen> first, is foldr technically a sort of monoid?
19:28:50 <crestfallen> or the folds both of them
19:29:33 <Solonarv> foldr is not a monoid, and in fact doesn't have much to do with monoids
19:29:53 <Solonarv> foldr is just a way to traverse lists or list-like structures
19:30:06 <crestfallen> but would you say the results are very similar at least in regards to lists.?
19:30:54 <crestfallen> so a monoid generalizes a way to traverse structures beyond lists, right?
19:31:28 <Solonarv> ehhh sort of?
19:31:50 <geekosaur> I would say no. a monoid specifies a way you can combine two values of the same type to get another value of the same type
19:32:01 <geekosaur> which is something that is often useful in the context of folds, and in other contexts
19:32:33 <Solonarv> a monoid also includes an identity value; if you combine the identity value with any other value you just get that other value back
19:32:48 <Solonarv> for example: (+, 0) on the integers is a monoid
19:34:02 <crestfallen> yes, so based on that first paste in my initial post above.. I understand the logic behind the identities of those functions
19:35:27 <crestfallen> but the stackoverflow post, it looks similar with the newtypes defined with what are I believe the identities...
19:35:41 <crestfallen> are*
19:36:31 <Solonarv> well the thing is there are four different monoids on Bool:
19:37:05 <Solonarv> (||, False); (&&, True); (xor, False); (xnor, True)
19:37:44 <Solonarv> however there can only be one Monoid Bool, so it'd have to pick one arbitrarily, which is not really great
19:37:48 <crestfallen> there's a note there saying 'boolean monoids under conjunction' so yeah False is the identity of OR and True of AND just like with using the folds
19:38:12 <crestfallen> what do you mean?
19:38:20 <Solonarv> please stop trying to think of this in terms of folds
19:38:23 <Solonarv> that isn't helpful
19:38:37 <geekosaur> you can only have one implementation of a given typeclass per type
19:38:45 <Solonarv> think of smashing two values together, and a special value that does nothing when smashed onto another value
19:38:47 <geekosaur> so we would have to choose one of them to be "the" Monoid
19:39:01 <geekosaur> but, none of them is obviously more important or special than the others
19:39:23 <geekosaur> so instead of giving Bool a Monoid instance, we make newtypes (zero-cost "wrappers") and give those Monoid instances
19:39:29 <geekosaur> hence All and Any
19:39:35 <`Guest00000> haskell's uniting of kinds and types feels clunky, contrasting to overall language feeling in other features
19:40:10 <Solonarv> yeah, type-level haskell is a bit unpleasant syntactically
19:40:38 <geekosaur> we do the same with Integer: neither (+, 0) nor (*, 1) is obviously "the" Monoid Integer, so we have Sum and Product newtypes, each with its own Monoid instance
19:41:14 <crestfallen> the tutorials I've seen are very terse including this stackoverflow, I feel. can we look at an example where we utilize the monoid Bools to do something beyond this barebones example?
19:41:43 <`Guest00000> which generally usable haskell-like languages with more pleasant syntax for type-level are there?
19:41:53 <monochrom> Monoid is supposed to have very little content.  You are not seeing terse, you're seeing nothing to talk about.
19:41:58 <geekosaur> ^
19:41:59 <crestfallen> ie just looking at the definitions alone is tough to get a handle on it.
19:42:08 <geekosaur> it;s a very simple idea that you may be trying to read too much into
19:42:24 <monochrom> You have a binary operator that's associative, and you have an identity.  Done.
19:42:37 <crestfallen> hmm
19:42:46 <geekosaur> `Guest00000, that's something of a "religious" question (one person's generally usable is another's incomprehensible gobbledygook)
19:42:50 <monochrom> If you're looking for examples, every example is like "integers and plus, done".
19:42:52 <geekosaur> idris is somewhat common
19:42:54 <crestfallen> I'm glad its simple at least :)
19:43:16 <Solonarv> I genuinely can't think of any `Guest00000 ; there's things like idris / agda (which I haven't used) but AFAIK they're not very mature for "real-world" uses
19:43:24 <oisdk> `Guest00000 really depends on what type-level stuff you want to do.
19:43:31 <glguy> `Guest00000: If you want to play with the value syntax at the type level Agda's fun
19:43:48 <geekosaur> but you should consider thatthe reason idris and agda exist is that people are still working out how to do things with type level
19:44:04 <geekosaur> and they;re both evolving fairly quickly as a result
19:44:20 <geekosaur> so your question might not be answerable yet
19:44:23 <`Guest00000> oisdk: just what Haskell can, but with simpler syntax
19:44:48 <geekosaur> and one branch of haskell development has been reaching in similar directions
19:44:58 <geekosaur> but different ways
19:45:09 <`Guest00000> i want to write an application
19:46:20 <Solonarv> that's not very specific, what does it do?
19:47:14 <`Guest00000> it can use a FFI and write arbitrary bytes in memory and execute as code
19:47:32 <Solonarv> you still didn't say what it *does*
19:48:10 <crestfallen> well, I lack the context to understand this, I mean, when / where would you use it?
19:49:12 <JuanDaugherty> it will be a neat trick if it can get arbitrary bytes to execute as code
19:49:26 <geekosaur> `Guest00000, you can do that in any language. where types, and type level programming as a higher level thereof, come in is in doing things like that while avoiding causing core dumps or getting incorrect results
19:49:55 <oisdk> `Guest00000 Like, if you're doing row-type things, and emulating that with a type-level list, a switch to purescript might make sense. If you're doing a lot of type-level arithmetic, you might just need a typechecker plugin. Lots of invariants etc. liquid Haskell might be the way to go. Other than that, Idris and Agda are the fully-fledged dependent languages closest to Haskell but they have downsides (Idris is still quite immature
19:49:55 <oisdk>  and Agda isn't really designed for production use)
19:49:57 <geekosaur> types give you one level of protection. type level programming lets you do more complex things while maintaining protection against erroneous operations
19:51:20 <geekosaur> type level programming is not where you write the applicaiton at type level. it's where you put rules for application logic to prevent you from combining application logical operation in incorrect ways
19:51:36 <`Guest00000> right
19:51:42 <`Guest00000> just Haskell is clunky, that's all
19:52:44 <geekosaur> but as yet, nobody's got solutions for now to do that "nicely"
19:52:48 <crestfallen> so far I have variations of this " You have a binary operator that's associative, and you have an identity.  Done. "   but sorry when is this applied?
19:53:00 <glguy> Fooling with types and getting an application written are kind of two different directions
19:53:13 <geekosaur> agda, idris, and haskell are all exploring different ways of reaching that goal. haskell's is much younger than the ither two, and is still rather clunky as a reuslt
19:53:20 <monochrom> Not very often, really.
19:53:27 <glguy> crestfallen: You can worry about it later, it's not actually that important.
19:53:33 <geekosaur> I'd say ":very often, so often that you doin';t notice it"
19:53:46 <crestfallen> ?? !!
19:53:46 <lambdabot>  !!
19:54:08 <glguy> Getting starting writing some programs will be more useful than picking through various type classes and small examples like this
19:54:44 <JuanDaugherty> agda is apparently '07, idris later
19:54:54 <geekosaur> you add two numbers together, you're using a monoid. you say "if condiiton_1 && condition_2 then", you're using a monoid. (or a semigroup if neither of those requires the ability to make part of that "go away" sometimes)
19:55:05 <`Guest00000> crestfallen: Monoid is any thing, any sequence of whose is "equivalent" to itself with two neighboring elements combined in a fixed way into one thing again
19:55:30 <Solonarv> that sentence is barely even grammatically correct, let alone meaningful
19:55:32 <monochrom> But you are not using the generality of monoid.
19:55:56 <`Guest00000> sorry
19:56:05 <crestfallen> so say you are evaluating a tree structure to find All or Any or somesuch
19:56:18 <Solonarv> you rarely need that unless you're writing a library (don't write a library)
19:56:45 <monochrom> I bet you that every time you count with natural numbers you don't think you're using category theory, despite the fact that a lot of category theory textbooks actually begin with that example (the numbers are the objects, the morphisms point from i to i+1).
19:57:03 <glguy> You're "using Monoids" when you're writing code that's generic in an arbitrary Monoid and you're using the laws the class is documented in the making and reasoning of that code
19:57:13 <`Guest00000> woo, the category of natural numbers
19:57:19 <oisdk> crestfallen one place that it's useful is that, for some types, foldr mappend mempty is more efficient, whereas for others, foldl mappend mempty is. When you call foldMap you allow the implementer of the foldable instance to choose the better one
19:57:23 <nshepperd> my favourite monoids are lists and strings
19:58:01 <`Guest00000> Solonarv: i was trying to express how i think of monoids in most general way
19:58:31 <glguy> crestfallen: Some of this stuff would be more obvious if you had some practice just writing programs first
19:58:58 <glguy> It's been a couple of years now, so it's not too early to start
19:59:09 <crestfallen> the funny thing about haskell, is things seem simple after I agonize over them long enough. I think I'm autistic seriously don't take offense. thanks, gotta go. many thanks kind people cafe's closing.
19:59:51 <geekosaur> that's just how experience works
20:00:02 <crestfallen> yes thanks all !
20:00:15 <`Guest00000> there's any "source" sequences of monoid things, and there's any sequences resulting from that combining operation, which all are equivalent, and folding is just endless combining until just one element is left, which is the result
20:03:30 * hackage hw-kafka-avro 2.1.0 - Avro support for Kafka infrastructure  http://hackage.haskell.org/package/hw-kafka-avro-2.1.0 (alexeyraga)
20:08:25 <greymalkin> P.S. For those hearing me gripe about monad-logger earlier, I decided to roll my own, where I have access to the handle (channel) to pass into forked reader monads.
20:15:19 <`Guest00000> ok, i'mma write my program in Haskell, without deptypes, "unrolling" the dependenty types into different types; this feels like a consistent scheme
20:15:27 <`Guest00000> so, there's Thing and there's Type
20:17:28 <`Guest00000> Things at runtime are always of a Type, and this all needs to be "type-consistent", that is, the types must never encode a meaningless thing, and there mustn't be code which does meaningless thing
20:17:49 <`Guest00000> so i have data Type = R | Arr Type Type | Prod [Type] | Bool | Union [Type] | ...
20:18:23 <`Guest00000> and data Thing = ThingR ThingR | ThingBool ThingBool | ThingArr Thing Thing | ThingProd [Thing] | ...
20:18:37 <`Guest00000> interesting is how to encode Thing of type Union _
20:19:22 <`Guest00000> i decided that: ... | ThingThis Thing [Type] | ThingOther Type ThingThis
20:20:01 <`Guest00000> Thing of type (Union [Type]) must encode only one Thing of a type from the list of types
20:20:27 <`Guest00000> and the structure of the list of types "got unrolled" into the constructors ThingThis, ThingOther
20:20:30 <Solonarv> when you're done writing whatever it is you're writing I want to see the entire code
20:20:56 <`Guest00000> i hope that's possible
20:21:28 <`Guest00000> these last messages i wrote, i'm asking, what's this "unrolling" and is there anything written about it?
20:22:32 <`Guest00000> oops, in "ThingOther Type ThingThis" s/ThingThis/ThingUnion/
20:25:28 <`Guest00000> point is, any Type of a Thing is "inside" that thing, and there's  typeOf :: Thing -> Type
20:25:29 <Solonarv> sorry, too tired to be helpful
20:36:22 <enterprisey> Solonarv: regarding what you said about TH's lifts, that would involve using the Lift instances for Data.HashMap.Strict and UArray?
20:36:33 <Solonarv> yes, assuming those exist
20:36:56 * glguy would be surprised if those existed
20:37:20 <glguy> but in their absense you can still just generate the appropriate syntax manually
20:38:57 <enterprisey> solid
20:41:14 <Solonarv> yeah the Lift instance is just to not have to figure out how to manually make a valid HashMap
20:42:40 <pally> > data Numeral = Num Sign Digits
20:42:42 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
20:42:50 <pally> ?data Numeral = Num Sign Digits
20:42:50 <lambdabot> Unknown command, try @list
20:43:28 <Solonarv> @let data Numeral = Num Sign Digits
20:43:29 <lambdabot>  .L.hs:160:20: error: Not in scope: type constructor or class ‘Sign’
20:43:29 <lambdabot>      |
20:43:29 <lambdabot>  160 | data Numeral = Num Sign Digits
20:45:26 <pally> My question is: if `Num` is not used in the `Num a => a -> a ` type context, the compiler won't recognize it us a type class, right?
20:46:01 <glguy> pally: There are two namespaces, one for types and one for values. What you did there put Num in the value namespace
20:47:42 <geekosaur> if you try to use a typeclass as a type, you'll get an error saying you did so. unless you are playing with type level extensions that cause the compiler to assume you're doing something tricky
20:48:18 <geekosaur> although I don;t recall offhand any extensions that would cause it to treat a typeclass as a type or kind, only as a constraint
20:49:05 <`Guest00000> ConstraintKinds
20:49:30 <geekosaur> no, that lets you use Constraint itself as a kind, not Constraints generally as kinds
20:49:54 <geekosaur> …come ot think of it, I';m not sure what happens if you define Num as a data constructor and then turn on DataKinds. probably just throw anerror if you don't use 'Num for the promoted one
20:50:08 <`Guest00000> geekosaur: sorry, how is that different?
20:50:15 <geekosaur> use/mention distinction
20:50:32 <glguy> geekosaur: If there's already a type C in scope then that's what GHC will use with DataKinds turned on
20:50:37 <glguy> in that case you'd have to use 'C to get the promoted one
20:50:50 <geekosaur> ConstraintKinds means you can use "Constraint" as a kind, not that you can use "Num" as a kind
20:51:50 <glguy> With ConstraintKinds the typeclass Num because a type with kind: * -> Constraint
20:52:40 <geekosaur> as opposed to a type with kind * or kind * -> *, which is what you're trying to do if you use it as a type (dpeending on whether you gave it a parameter or not)
20:57:03 <pally> "if you try to use a typeclass as a type, you'll get an error ", so something like `data Ord Num = Foo | Bar`
20:57:04 <pally> ?
20:57:13 <`Guest00000> is there a library which defines  newtype To a e = To (e -> a)  ?
20:57:40 <glguy> http://hackage.haskell.org/package/contravariant-1.4.1/docs/Data-Functor-Contravariant.html#t:Op
20:59:49 <juri_> how do i go from a list of a list of a thing, to a list of things?
20:59:59 <`Guest00000> glguy: thanks
21:00:01 <geekosaur> concat?
21:00:19 <juri_> oh. duh. thanks. ;)
21:00:31 <glguy> pally: Without the extension, in plain Haskell, constraints live in their own corner of the type world. They only get used in restricted ways on the left sides of =>
21:03:30 * hackage rank2classes 1.1 - standard type constructor class hierarchy, only with methods of rank 2 types  http://hackage.haskell.org/package/rank2classes-1.1 (MarioBlazevic)
21:18:55 <jle`> pally: that's not legal syntax anyways
21:19:19 <jle`> so things get rough for you even before the typechecking stage :)
21:20:37 <pally> that came from top answer of https://stackoverflow.com/questions/40695023/creating-instance-of-eq-for-custom-data-type-in-haskell
21:22:23 <`Guest00000> i realized that "ThingArr Thing Thing" is an invalid "unrolling" and it's challenging to find a correct one
21:24:14 <glguy> pally: The thing you wrote that was a syntax error was : data Ord Num = Foo | Bar
21:25:22 <glguy> where you had "Num" you'd need to have a type variable or nothing
21:25:58 <jle`> pally: where in the top answer do they write that?
21:28:03 <geekosaur> they're referring to [27 03:42:18] <pally> > data Numeral = Num Sign Digits
21:28:40 <jle`> ah ok, and not data Ord Num = Foo | Bar
21:29:16 <geekosaur> right, that was in response to something I said later
21:30:09 <jle`> the singletons library has a nice type
21:30:20 <jle`> data Decision a = Proved a | Disproved (a -> Void)
21:30:33 <jle`> but sometimes i would like
21:30:59 <jle`> data Undecisive a = Proved a | UnprovabeEitherWay | Disproved (a -> Void)
21:31:07 <jle`> hm oh i guess that's just Maybe (Decision a)
21:31:17 <fishythefish> the names kinda spell it out for you, don't they?
21:32:02 <geekosaur>  | WhyNotBoth
21:32:50 <jle`>  | IncludedMiddle a (a -> Void)
21:37:42 <dreamer_> Hey I think my stack installation has problems
21:37:58 <dreamer_> is there someone on windows that could test my project
21:38:10 <dreamer_> to know whether it's my computer or not
21:39:29 <dreamer_> for some reason stack repl works but not stack build...
21:40:26 <liste> dreamer_: how does it fail?
21:43:15 <dreamer_> I'll link the error
21:45:51 <dreamer_> this is the output of stack build
21:45:53 <dreamer_> https://paste.ee/p/qf4fy
21:46:06 <dreamer_> and stack repl https://paste.ee/p/FQTzF
21:47:19 <dreamer_> I had an old stack install which I thought I  purged ; despite deleting the stack folder and stack work
21:47:30 <dreamer_> it really wants to load the old msys path
21:47:39 <cocreature> dreamer_: have you added SFML to the build-depends section of the executable?
21:48:38 <cocreature> if you really want to purge the old install you probably have to delete the windows equivalent of ~/.stack
21:48:44 <dreamer_> I did..
21:48:50 <dreamer_> I mean the second oe
21:49:01 <dreamer_> I did not add SFML to the dependencies !
21:49:12 <dreamer_> aaaand it works.
21:49:15 <dreamer_> thanks.
21:50:00 <cocreature> dependencies are not transitive. just because you depend on a library (in this case probably your own lib) that depends on SFMC doesn’t mean you get to use SFMC automatically. you still need to add it to build-depends
21:51:01 <dreamer_> I wonder why it works in stack repl..
21:51:07 <dreamer_> thanks a lot. overlooked this
21:51:10 <cocreature> stack repl is kind of a hack
21:51:31 <cocreature> it loads all components at once, so libraries, executables, test suites …, and merges their flags
21:51:52 <cocreature> so if your lib depends on SFMC then that flag will be included even if the executable doesn’t
21:52:04 <cocreature> (it has to work that way due to limitations in ghci)
21:54:04 <dreamer_> I see !
21:54:09 <dreamer_> thanks again
21:54:23 <cocreature> np
22:02:32 <pally> @let data MyList a = Nil | Cons a (MyList a)
22:02:33 <lambdabot>  Defined.
22:03:14 <pally> If `Cons` is called the name of a data constructor  for type MyList
22:03:48 <pally> then does the remainder (`a (MyList a)`) called the body?
22:04:11 <pally> body of the constructor, I mean
22:04:32 <cocreature> more like “the arguments of the constructor”
22:04:49 <cocreature> I don’t think I ever heard the term body in this context
22:05:41 <jle`> i call it the fields sometimes
22:05:43 <pdxleif> When running  http-conduit stuff (amazonka) with runResourceT, is the runResourceT supposedto go at the top-level of the app, or around each request?
22:06:00 <jle`> or are we talking about syntax
22:06:17 <cocreature> the term “fields” is somewhat tied to records in my mind but that might just be me
22:06:47 <geekosaur> less so for me because records expose as more of a syntax variant
22:07:30 <geekosaur> (consider for exaple how you can use X {} for any data constructor X in a pattern, regardless of whether it was defined with record syntax or not)
22:08:19 <jle`> looking at the syntax level there is no name for the thing that comes after the constructor name
22:09:05 <geekosaur> pdxleif, it seems to me like around each request would make it fairly useless in most cases
22:09:10 <jle`> looking at the report
22:09:46 <pdxleif> From the looks of https://github.com/snoyberg/http-client/blob/9eb92877641db53efa179ea871a51d32989c6f52/http-conduit/Network/HTTP/Conduit.hs#L315 it seems like a per-request thing.
22:10:45 <pdxleif> I'm getting a leak running a request for each chunk inside a Conduit, unless I liftIO $ runResourceT $ runReaderT fooReq, instead of just fooReq.
22:11:10 <pdxleif> I don't even need any response bodies
22:15:53 <wchresta> For the type families in GHC.TypeLits, is it possible to follow commutativity of two KnownNats? id :: (KnownNat a, KnownNat b) => f (a+b) -> f (b+a) ?
22:16:00 <pdxleif> Looks like the result of Client.responseOpen will be released when "responseBody" is ran on the response, else it'll get cleaned up when runReaderT is ran?
22:19:25 <nshepperd> wchresta: ghc won't deduce it for you, but the type checker plugins eg. ghc-typelits-natnormalise can add those equalities
22:20:22 <pzp> :k (->)
22:20:23 <lambdabot> TYPE q -> TYPE r -> *
22:20:49 <pzp> Why is the kind not just `* -> * -> *` in this case?
22:20:58 <jle`> pzp: it's a little more polymorphic than that
22:21:13 <jle`> but * is essentially a type synonym
22:21:13 <wchresta> nshepperd: I'll look into that, thanks
22:21:27 <pzp> As in the types given to the constructor can be lifted or unboxed?
22:21:38 <geekosaur> among other things, yes
22:22:12 <jle`> pzp: yeah, there's some value of q where TYPE q is *
22:22:15 <jle`> i forgot what it was
22:22:24 <pzp> Any documentation or anything in writing about this?
22:22:45 <`Guest00000> how is the operation called which extracts the (f whatever) in a generalized type like  data T1 f = A (f ...) | B (f ...) | ... , forgetting the 'whatever' ?
22:23:40 <nshepperd> wchresta: type checker plugin ghc-typelits-knownnat will infer KnownNat constraints for you as well, such as (KnownNat a, KnownNat b) => KnownNat (a + b)
22:24:06 <jle`> pzp: TYPE is documented in base
22:24:49 <jle`> http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Exts.html#t:TYPE
22:24:58 <jle`> it looks liks its argument is a RuntimeRep http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Exts.html#t:RuntimeRep
22:25:14 <jle`> so i guess type * = TYPE 'LiftedRep
22:25:43 <cocreature> `Guest00000: I’m not sure what that is supposed to mean? how dou you “forget” the whatever?
22:26:43 <jle`> `Guest00000: Can you maybe use a specific example
22:27:07 <ammar2> I think they mean something that does `Maybe Int` -> `Int` and `[String]` -> `String`
22:28:18 <`Guest00000> data Type = Int | Bool
22:28:28 <cocreature> that’s a syntax error
22:28:29 <jle`> ammar2: those would be "algebras" then i think
22:28:35 <jle`> technically not a syntax error
22:28:38 <jle`> but probably not what they mean
22:28:47 <`Guest00000> data Expr f = ExprInt (f ExprInt) | ExprBool (f ExprBool)
22:29:00 <jle`> oh, it was what they mean
22:29:01 <cocreature> jle`: duh, yeah it’s too early :)
22:29:01 <liste> @let data Type = Int | Bool
22:29:03 <lambdabot>  Defined.
22:29:12 <`Guest00000> data Null a = Null
22:29:20 <liste> :)
22:29:27 <jle`> some people just want to watch the world burn
22:29:34 <liste> now Int and Bool are constructors of type Type
22:29:35 <jle`> :k Int
22:29:36 <lambdabot> *
22:29:42 <jle`> % :k Int
22:29:42 <yahb> jle`: Int :: *
22:29:45 <jle`> :k 'Int
22:29:46 <lambdabot> Type
22:29:52 <jle`> if only -XTypeInType was on, that would have made the joke good
22:29:54 <`Guest00000> forget Null
22:29:59 <`Guest00000> how'sThisCalled :: Expr f -> f ()
22:30:16 <`Guest00000> how'sThisCalled (ExprInt f) = () <$ f
22:30:19 <`Guest00000> how'sThisCalled (ExprBool f) = () <$ f
22:30:28 <`Guest00000> and so on, for 98 remaining Expr constructors
22:31:13 <jle`> hm, i'm not sure if there is a general name for that
22:31:40 <jle`> maybe a cutoff? since you're cutting off all of the leaves and only getting the first constructor
22:31:53 <`Guest00000> the funniest thing is that the cases of how'sThisCalled look like a repetition
22:32:03 <dminuoso> How does edward come up with all these bizarre names? For example, where does Pretext get its name from?
22:32:10 <jle`> you're basically killing the leaves and keeping on the top level root
22:32:28 <`Guest00000> dminuoso: some bizarre names give rise to more bizarre names
22:32:32 <`Guest00000> it starts with little
22:33:21 <`Guest00000> and maybe some bizarre names aren't visible in code, articles, papers, ..., it still works
22:33:24 <jle`> it reminds me of `cutoff 1` from Control.Monad.Free
22:33:48 <`Guest00000> maybe i should call it getExpr
22:33:55 <pzp> jle`: Thanks for those links!
22:34:01 <`Guest00000> like a field extractor
22:34:05 <`Guest00000> only
22:34:06 <jle`> `Guest00000: note that if all of your types are like that, you can unify those constructors with GADTs
22:34:12 <jle`> er, with a 'smart enum'
22:34:44 <jle`> data ExprType :: Type -> Type where EInt :: ExprType Int; EBool :: ExprType Bool
22:34:56 <jle`> data Expr f = Expr (ExprType a) (f a)
22:35:03 <`Guest00000> no
22:35:07 <jle`> there is an existential somewhere there
22:35:17 <`Guest00000> the (f a) part DEPENDS on the type! :0
22:35:19 <`Guest00000> :)   *
22:35:29 <jle`> `Guest00000: yeah, that's what the GADT does
22:35:39 <jle`> so the construct of ExprType picks what 'a' is
22:35:57 <jle`> if the ExprType is EInt, then you have (f Int)
22:36:01 <`Guest00000> i mean, instead of "(f a)" there's something else
22:36:08 <`Guest00000> for some types
22:36:08 <jle`> ah okay
22:36:15 <jle`> you mean, for come constructors?
22:36:22 <`Guest00000> of Expr, yes
22:36:45 <kvothe> hi..trying to implement a stateful udp using basic sockets..Posted https://stackoverflow.com/questions/51046157/using-so-reuseport-to-simulate-stateful-udp . Can anyone please have a look?
22:36:46 <`Guest00000> so it reminds me of dependent types
22:36:57 <`Guest00000> only need to manually repeat things
22:37:12 <`Guest00000> "unroll"
22:43:08 <geekosaur> kvothe, the main thing "wrong" with it is that haskell libraries don't generally assume that every computer runs linux
22:44:35 <geekosaur> and that SO_REUSEPORT behavior is linux-specific, and even then only on recentish kernel versions
22:46:09 <kvothe> geekosaur if I assume I'll run my app on only linux versions > 3.9, then is it a good way to do it?
22:47:54 <geekosaur> all I can suggest is try it and see if it works. I tend to avoid it, but I generally plan on stuff needing to work on linux + os x + windows + freebsd at minimum
22:48:33 <dev> can anyone tell what this means ` (+index) . (+1) <$> search n bs` in https://lpaste.net/5090128689253842944, what kind of syntax is this?
22:48:48 <cocreature> dev: which of the symbols confuses you?
22:48:49 <geekosaur> pointfree syntax
22:49:10 <geekosaur> @unpl  (+index) . (+1) <$> search n bs
22:49:10 <lambdabot> ((\ x -> (x + 1) + index) <$> search n bs)
22:49:17 <dev> cocreature: (+index) . (+1) <$> search n bs this line
22:49:28 <cocreature> dev: right but which part of that line?
22:49:42 <dev> cocreature: specifically this (+index) . (+1) <$>
22:49:53 <cocreature> <$> is the infix version of fmap
22:50:00 <liste> dev: do you mean what (+index) . (+1) means?
22:50:07 <cocreature> (+index) is equivalent to \x -> x + index
22:50:14 <cocreature> and . is function composition
22:50:26 <liste> > let { index = 5; f = (+index) . (+1) } in f 20
22:50:28 <lambdabot>  26
22:50:39 <cocreature> so (+index) . (+1) is equivalent to \x -> (x + 1) + index
22:51:21 <dev> cocreature : are they passing that increased index to search fucntion?
22:51:57 <cocreature> dev: no they call "search n bs" and then fmap \x -> (x + 1) + index over the result
22:53:01 <dev> cocreature: Thanks
22:53:19 <dev> liste:thanks
22:59:38 <dminuoso> `Guest00000: I suppose Im rather wondering whether his names have basis in some fields of mathematics.
22:59:54 <dminuoso> But I just cant "bazaar" or "pretext" as common mathematical constructs.
23:00:00 * dminuoso a verb there
23:02:12 <`Guest00000> what is the essence of naming in mathematics?
23:03:42 <ammar2> bazaar at least is found somewhat in economics
23:03:47 <ammar2> I think its arabic for market
23:04:41 <`Guest00000> it feels like usual ADTs (algebraic datatypes) contain dependent-typiness in themselves
23:05:31 <sharky_> we also say bazaar for market in hindi
23:05:46 <`Guest00000> already
23:05:48 <`Guest00000> they allow for specifying dependency of types of fields on the constructor, which is data
23:06:53 <dminuoso> `Guest00000: I suppose mathematics is not too different..
23:07:02 <dminuoso> I mean it's not like `Monad` was made up as a word for mathematics..
23:08:51 <mjoldfield> Chambers says of Monad: The number one, a unit (historical); An Ultimate unit of being, material and psychical; A spirit; God; ...
23:09:31 <mjoldfield> They say it comes from Greek monas, -ados a unit, from monos single, alone.
23:10:56 <geekosaur> @quote MacLane
23:10:56 <lambdabot> geekosaur says: so fwiw it looks like [Mac Lane] introduced it in _Categories for the Working Mathematician_, and his terminology note doesn't explain why he picked "monad", but perhaps can be
23:10:56 <lambdabot> understood to imply a sort of cross between "monoid" and "triad". (p.138 at http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf)
23:11:12 <geekosaur> and likely didn;'t realize it had other meanings
23:11:58 <dminuoso> StackExchange has a nice thread with some thoughts on that topic. One interesting one postulates monad as a backformation from dyad and triad.
23:12:39 <dminuoso> Or perhaps as a contraction between monoidal triad.
23:12:50 <geekosaur> after finding above quote I looked more closely and realized that the terminology note in question is in fact fairly precise in its derivation
23:13:58 <geekosaur> although if you read it loosely some of the logical arguments going into it look like rants
23:14:28 * geekosaur smells a logician with semantics training, actually
23:37:00 <c50a326> I read somewhere that monad is like mirror
23:37:23 <c50a326> yeah leibniz
23:37:33 <geekosaur> there are a lot of insane similes amnd metaphors for something that's actually fairly simple
23:38:25 <c50a326> real world haskell has a good suggestion I think
23:38:51 <c50a326> "As long as you feel like a novice with monads, we think you should prefer to explicitly write (>>=) over the syntactic sugar of do notation."
23:39:10 <c50a326> so today I'm gonna try this >>= stuff :)
23:48:10 <tdammers> whenever you read "monads are like...", stop reading and forget about it
23:49:06 <tdammers> http://dev.stephendiehl.com/hask/#monads <- best "monad tutorial" I know
23:50:11 <ammar2> oh its the guy who wrote/writes "write you a haskell"
23:50:19 <ammar2> his stuff is good
23:50:26 <tdammers> very.
