00:00:31 <jle`> ah yes, for some reason, AllTextMatches [] does not have a Foldable instance
00:00:46 <jle`> length is defined to work for anything with a Foldable instance
00:00:58 <jle`> it looks like it's probably because it's a really old library
00:01:06 <jle`> ah yeah, last updated in 2010
00:01:53 <jle`> you can probably use `getAllTextMatches :: AllTextMatches [] String -> [String]`
00:01:57 <jle`> and then get the length of that [String]
00:02:26 <jle`> if the library is still maintained, you can probably submit a PR or patch to add the Foldable instance :)
00:04:16 <imjacobclark> jle`: ah okay, thanks!
00:04:28 <jle`> np!
00:05:04 <cocreature> jle`: oh good point, I totally missed the difference between Compose and MaybeT here
00:06:20 <jle`> i actually only just realized it a month or two ago after a discussion here on irc
00:06:25 <jle`> blew my mind
00:07:08 <cocreature> I’m kind of sad now, my mental model was always that for Applicative you can just use Compose instead of the transformers which is obviously wrong :/
00:07:57 <jle`> in my mind i rationalize it as a [a] vs ZipList a thing
00:08:37 <jle`> F (Maybe a) has multiple Applicative instances
00:09:02 <jle`> and only one of them (in general for all Monad F) can also be made into a Monad where (<*>) = ap
00:09:18 <jle`> the `Compose f Maybe` instance cannot be Monad, like how ZipList can't be Monad
00:14:55 <ahri`> I'm struggling a bit, I have two Applicatives f & g, a function `f :: a -> b -> c` and a couple of values `a' :: f g a` and `b' :: f g b`, I can't do what I want: `f <$> a' <*> b'` as I have 2 layers of functor/applicative to get through, so how do I approach this?
00:15:00 * hackage distributed-process-async 0.2.6 - Cloud Haskell Async API  http://hackage.haskell.org/package/distributed-process-async-0.2.6 (AlexanderVershilov)
00:16:26 <cocreature> ahri`: have you seen the answers that I send to you when you asked this question an hour ago or so?
00:17:31 <ahri`> cocreature: no, I'm using riot.im and it appears to be having difficulties saying it's unable to connect, even on my (now stable) connection
00:17:55 <cocreature> ahri`: you can use the tunes.org link in the channel topic to take a look at the logs
00:18:07 <ahri`> awesome, I'll have a look, sorry about that
00:20:38 <ahri`> ah, double lifting looks like the answer I was looking for, I hadn't considered the liftA* functions for a while, preferring the infix
00:22:10 <ahri`> getCompose looks interesting, I'll have to read up on that, that may be a prettier way to approach it
00:22:47 <cocreature> Compose basically wraps up the double lifting so the regular Applicative operators will do that
00:30:24 <ahri`> the Compose solution seems prettiest to me, that's really awesome. I wonder how I might extend this to more than 2 layers of applicative, since the composition of liftA2 is extensible to any degree I encounter in the future
00:31:45 <cocreature> you can nest Compose
00:31:53 <cocreature> :t \f x y -> getCompose (getCompose (f <$> Compose (Compose x) <*> Compose (Compose y)))
00:31:55 <lambdabot> forall k2 k1 (f :: k1 -> *) (g1 :: k2 -> k1) (g2 :: * -> k2) a1 a2 a3. Applicative (Compose (Compose f g1) g2) => (a1 -> a2 -> a3) -> f (g1 (g2 a1)) -> f (g1 (g2 a2)) -> f (g1 (g2 a3))
00:32:26 <ahri`> I was worried it might end up looking like that!
00:32:55 <ahri`> it's really cool, and especially nice that I can still use the infix, but I feel like multi-liftA2 is more readable
00:35:15 <ahri`> thanks a lot to you both, cocreature  and jle`!
00:35:16 <cocreature> once you go above two levels of nesting, you probably want to define some newtype for your monad/applicative stack and always work on that rather than wrap and unwrap the individual values whenever you want to compose them
00:36:05 <ahri`> hmm I hadn't considered a newtype, that could make things a lot more readable now you mention it
00:52:30 * hackage show-prettyprint 0.2.1 - Robust prettyprinter for output of auto-generated Showinstances  http://hackage.haskell.org/package/show-prettyprint-0.2.1 (quchen)
00:57:00 * hackage show-prettyprint 0.2.2 - Robust prettyprinter for output of auto-generated Showinstances  http://hackage.haskell.org/package/show-prettyprint-0.2.2 (quchen)
01:02:41 <kuribas> "While I love the power of Lisp, I am not a devotee of functional programming. I see nothing bad about side effects and I do not make efforts to avoid them unless there is a practical reason."
01:02:45 <kuribas> Richard Stallman
01:03:15 <tdammers> the more I think about it, the more I am convinced that "lisp == FP" is blatantly false
01:03:52 <veverak> kuribas: like that! source?
01:04:10 <tdammers> FP is about (pure) functions. Not about first-class procedures.
01:04:21 <merijn> tdammers: Generally people consider "scheme == FP", which then got bastardized to "lisp == FP" by people claiming "scheme == lisp"
01:04:44 <kuribas> It's a common myth that FP means avoiding side effects.
01:04:50 <kuribas> Rather than separating them.
01:05:04 <kuribas> tdammers: also yeah
01:06:06 <tdammers> well, scheme is a lisp
01:06:06 <kuribas> scheme is more FP than other LISP dialects
01:06:29 <kuribas> like ocaml, but without static types
01:06:53 <ventonegro> By this logic not even SML is a functional language then
01:07:32 <kuribas> not purely functional
01:07:39 <tdammers> IMO the minimum requirement is to have some sort of notion of pure functions
01:07:55 <ventonegro> kuribas: That was not what he said
01:07:56 <tdammers> i.e., there must be a way to write actual functions
01:08:06 <veverak> pure function? Like C? :)
01:08:16 <veverak> (nut trolling, gcc actually has attribute 'pure' for functions)
01:08:46 <kuribas> ventonegro: he mentioned LISP in general, not scheme.
01:09:14 <veverak> yeah, __attribute__((const)) it is, or __attribute__((pure))
01:09:42 <ventonegro> kuribas: I am talking about the "FP is about (pure) functions" part
01:09:58 <ventonegro> Granted, "pure" is within parentheses :)
01:11:43 <kuribas> ventonegro: when he says he doesn't mind side-effects, it seems he means pure.
01:12:08 <ventonegro> kuribas: I'm not talking about RMS
01:12:53 <ventonegro> 10:03 <tdammers> FP is about (pure) functions. Not about
01:12:53 <ventonegro>                  first-class procedures.
01:13:11 <ventonegro> Then I said that not even SML is functional then
01:13:23 <kuribas> ventonegro: I disagree
01:13:39 <kuribas> because both SML and scheme are about pure functions.  It just doesn't enforce them.
01:13:47 <mreh> @pl \a b -> f b a
01:13:47 <lambdabot> flip f
01:13:55 <mreh> that stills works then \o/
01:14:31 <tdammers> scheme doesn't really have any means of controlling or containing effects
01:14:38 <tdammers> any procedure can be called from any context
01:14:41 <kuribas> ventonegro: that's why scheme has tail-call optimization for example
01:15:15 <ventonegro> kuribas: How so?
01:15:29 <kuribas> ventonegro: so you don't need to write mutating loops
01:16:18 <tdammers> the problem with not enforcing purity anywhere is that you can't realistically reason about effect (or the absence thereof) anymore
01:16:31 <quicksilver> < kuribas> It's a common myth that FP means avoiding side effects. Rather than separating them. <-- In my view the actual point here is a surprisingly subtle one about the definition of 'side'
01:16:35 <maerwald> tdammers: is that really a purity problem?
01:16:50 <maerwald> tdammers: in java you can nicely reason about all effects that are part of the exception system
01:16:54 <quicksilver> I believe that FP is about avoid things which occur as side-effects of evaluation.
01:17:24 <quicksilver> in that particular sense of the word *side*-effects, then I agree with kuribas's first sentence and disagree with his qualification :)
01:17:24 <ventonegro> kuribas: Not really. The reason was that the authors discovered that evaluating arguments, not function calls, push values on the stack
01:17:26 <maerwald> tdammers: and even worse, when you have IO in haskell, it is technically pure, but basically removes your ability to reason about the function (unless you read the whole body)
01:17:40 <ventonegro> kuribas: Scheme was not really about purity in the beginning
01:17:53 <quicksilver> so, we strive to separate effects and not have them occur implicitly as part of evaluation.
01:18:24 <maerwald> and FP is not about avoiding side-effects, FP is about functions :>
01:18:27 <ventonegro> kuribas: http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-443.pdf
01:18:31 <kuribas> ventonegro: scheme programmers, unlike lisp programmers, will also avoid using set!
01:18:45 <ventonegro> kuribas: Yes, as I am one. But that came later.
01:19:10 <kuribas> possibly
01:19:28 <ventonegro> kuribas: This is not at all why Scheme was created with tail call optimization. Just read the paper.
01:20:37 <kuribas> originally scheme was also about the actor model
01:21:10 <ventonegro> kuribas: Ok?
01:21:58 <kuribas> which is why it has call/cc
01:22:35 <kuribas> quicksilver: exactly
01:23:12 <kuribas> ventonegro: who uses scheme for scheme for actors now?
01:23:14 <zincy> How do I use <<**>> to map a 2 arity tuple with a function \(a, b) -> (a, b) ?
01:23:59 <ventonegro> kuribas: What's your point?
01:24:20 <kuribas> ventonegro: that scheme like it is used now, is mostly functional.
01:24:41 <ventonegro> kuribas: I don't think anybody disputes that
01:24:49 <kuribas> ah, ok then
01:26:15 <kuribas> tdammers: not everyone thinks that matters.
01:27:44 <kuribas> :t (<<**>>)
01:27:45 <lambdabot> error:
01:27:45 <lambdabot>     • Variable not in scope: <<**>>
01:27:45 <lambdabot>     • Perhaps you meant one of these:
01:28:04 <AWizzArd> Is there an extension available in 8.4 that allows multiple records to have the same field names?
01:28:33 <AWizzArd> I read about DuplicateRecordFields but also about OverloadedRecordFields.
01:28:38 <ventonegro> Modern Scheme compilers even optimize for code without assignments, and assignments usually pay the price of an extra box allocation
01:29:38 <cocreature> AWizzArd: DuplicateRecordFields exists since 8.0
01:29:39 <zincy> Maybe what I am looking for is a functor instance which doesn't seem to be possible for my tuple
01:29:47 <AWizzArd> cocreature: and is that the best solution in 8.4?
01:29:58 <cocreature> AWizzArd: still the same :)
01:30:06 <merijn> AWizzArd: Everything related to that is still work in progress, yes
01:30:24 <AWizzArd> merijn: yes, that was my feeling. It sounded like a proposal.
01:30:46 <cocreature> OverloadedRecordFields is a proposal and doesn’t exist yet afaik
01:31:19 <cocreature> and tbh I have my doubts that it ever will exist
01:33:10 <kuribas> tdammers: the nice thing is that you can have that and mutation if necessary, like when working with mutable vectors in the ST-monad.
01:33:23 <pbodev1> :t (<**>)
01:33:24 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
01:34:12 <zincy> hmm in the bifunctors package its (<<**>>) :: Biapplicative p => p a c -> p (a -> b) (c -> d) -> p b d infixl 4
01:35:13 <zincy> Oh <**> is not <<**>>
01:35:18 <zincy> :)
01:35:22 <cocreature> zincy: what exactly are you trying to do? map the same function over both elements in a tuple?
01:35:32 <zincy> yes
01:35:44 <cocreature> :t \f -> bimap f f
01:35:44 <zincy> think foldr but for a tuple
01:35:45 <merijn> :t \f -> bimap f f
01:35:46 <lambdabot> Bifunctor p => (a -> d) -> p a a -> p d d
01:35:46 <lambdabot> Bifunctor p => (a -> d) -> p a a -> p d d
01:35:49 <merijn> :p
01:35:58 <cocreature> merijn: hah!
01:36:03 <zincy> oh that looks like it
01:36:07 <merijn> :t join bimap
01:36:09 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
01:36:19 <merijn> For extra opaqueness!
01:36:24 <cocreature> if you use lens you can also use "both" but that’s certainly not something that you wan to add a lens dep for
01:36:45 <zincy> already have a dep on lens
01:36:53 <kuribas> tdammers: for many people it must feel like unnecessarily restricting yourself, but I find that using purely functional structures has many benefits.
01:36:58 <cocreature> :t over both
01:36:59 <lambdabot> Data.Bitraversable.Bitraversable r => (a -> b) -> r a a -> r b b
01:37:13 <cocreature> that’s the lens version
01:39:07 <zincy> im confused
01:39:23 <zincy> https://lpaste.net/1456565139699400704
01:39:49 <zincy> Essentially I want the deal function to bimap over the tuple of cards
01:40:04 <zincy> but I am getting Game.hs:48:19: error:     • Couldn't match expected type ‘([[Card]], [Player])’                   with actual type ‘[Player]’     • In the expression: players       In the third argument of ‘over’, namely ‘(pocketCards, players)’       In the expression:         (over both)           (\ (pockets, p@Player {..} : ps)              -> if _playerState == In then                     (Player {_pockets = 
01:41:06 <merijn> zincy: You seem to have reversed the tuple elements in the input and function processing it
01:41:49 <merijn> zincy: Actually, scratch that
01:42:11 <merijn> You're using "both" to apply a function to each side of a tuple while the function seems to require a tuple as input
01:43:05 <pbodev1> just testing no intrusion :)
01:43:09 <pbodev1> @let f' = getConst . forwards . traverse (Backwards . Const)
01:43:10 <lambdabot>  .L.hs:159:17: error:
01:43:11 <lambdabot>      Variable not in scope: forwards :: f0 (t b2) -> Const c b0
01:43:11 <lambdabot>      |
01:43:44 <zealvault> hey
01:43:52 <merijn> zincy: Also, this could be cleaner: https://lpaste.net/2892597350721650688
01:44:04 <Ariakenom> different a b x = assert a != b $ if x==a then b else a -- is there a function like this lying around somewhere?
01:44:06 <merijn> pbodev1: You can private mssage lambdabot if you wanna test things
01:44:44 <pbodev1> merijn: ah thanks
01:45:19 <zincy> merijn : ooh thanks
01:45:30 * hackage versioning 0.2.0.0 - Type-safe data versioning.  http://hackage.haskell.org/package/versioning-0.2.0.0 (lortabac)
02:16:34 <zincy> say I have two lists [1,0,1] and [True,True] what function would give me a [True, False True] as a result
02:17:18 <Ariakenom> zincy: const [True, False, True]
02:17:23 <zincy> haha
02:17:36 <Ariakenom> haw haw
02:17:39 <veverak> bad question, bad answer...
02:17:56 <dminuoso> zincy: what is `False True`?
02:18:05 <zincy> veverak: what would be a good answer?
02:18:12 <dminuoso> zincy: that depends on the question.
02:18:51 <dminuoso> zincy: Your description of an algorithm is rather poor. What is that function supposed to do?
02:18:58 <zincy> right so bad answer depends on the question too :)
02:19:03 <veverak> zincy: there is not a one for bad question
02:19:04 <Ariakenom> > toEnum 1
02:19:05 <veverak> :)
02:19:06 <lambdabot>  *Exception: Prelude.Enum.().toEnum: bad argument
02:19:08 <Ariakenom> > toEnum 1 :: Bool
02:19:10 <lambdabot>  True
02:19:20 <veverak> zincy: to be honet: your question does not make sense
02:19:22 <zincy> veverak: that makes no sense
02:19:28 <veverak> *honest
02:19:31 <zincy> neither of us make any sense
02:19:34 <zincy> haha
02:19:35 <veverak> so, what the function should do?
02:19:38 <veverak> why?
02:19:53 <dminuoso> :t const const
02:19:55 <lambdabot> b1 -> a -> b2 -> a
02:20:08 <dminuoso> @pl \_ _ x -> x
02:20:08 <lambdabot> const (const id)
02:20:28 <dminuoso> Oh well. Staring at it it seems obvious now.
02:20:28 <Ariakenom> :t const id
02:20:29 <lambdabot> b -> a -> a
02:20:45 <Ariakenom> :t const (flip const)
02:20:46 <lambdabot> b1 -> b2 -> c -> c
02:20:52 <dminuoso> Ariakenom: Im starting to prefer the const id perspective now.
02:21:00 <dminuoso> \_ -> (x -> x)
02:21:10 <dminuoso> \_ -> (\x -> x)
02:21:13 <dminuoso> So much more revealing =)
02:22:17 <Ariakenom> > map toEnum [1,0,1] :: [Bool]
02:22:20 <lambdabot>  [True,False,True]
02:22:31 <zincy> ok I want a function which when given two lists and a predicate if the predicate returns false on an element of the first list then for the same index on the second list an arbitrary value will be set
02:23:18 <dminuoso> zincy: map and zip?
02:23:31 <cocreature> an arbitrary value? where is that value supposed to come from
02:23:48 <zincy> supplied to the function?
02:23:57 <dminuoso> zincy: do you have some examples of input and output data?
02:24:06 <cocreature> so you want something like a -> (a -> Bool) -> [a] -> [a]?
02:24:23 <cocreature> oh wait no, I missed the second list
02:24:26 <zerobaud> Is there any way to create an algorithm based on X amount of before and after states? For example before A=5, after A=6. An returned algortihm would be A=A-1?
02:24:31 <cocreature> so b -> (a -> Bool) -> [a] -> [b] -> [b]?
02:24:37 <Ariakenom> b -> (a -> Bool) -> [a] -> [b]-> [b]?
02:24:42 <dminuoso> cocreature: There's too much confusion, said the joker to the thief.
02:27:40 <Ariakenom> :t \z p -> zipWith (\a b -> if p a then b else z)
02:27:41 <lambdabot> c -> (t -> Bool) -> [t] -> [c] -> [c]
02:28:11 <dminuoso> @pl \z p -> zipWith (\a b -> if p a then b else z)
02:28:11 <lambdabot> (zipWith .) . flip (flip . ((flip . if') .))
02:28:18 <Ariakenom> hmmm
02:28:18 <dminuoso> @pl \a b -> if p a then b else z
02:28:18 <lambdabot> flip flip z . if' . p
02:28:24 <dminuoso> :t flip flip
02:28:26 <lambdabot> b -> (a -> b -> c) -> a -> c
02:28:34 <dminuoso> Okay I didn't expect that =)
02:29:32 <zincy> https://lpaste.net/9095774004509147136
02:42:44 <jle`> zerobaud: there isn't any way in general
02:43:17 <jle`> zerobaud: that's basically what the entire field of mathematical modeling tries to look at
02:43:27 <jle`> zerobaud: but it's simple if you know a general shape of what sort of function you want
02:44:08 <jle`> well, simple depending on how simple the shape you want is, heh
02:44:35 <Ariakenom> Creating an nth degree polynomial for n states works for number states?
02:44:38 <zerobaud> jle`: so lets say state change is limited to logical operations like xor, not, and, sub, mul etc.. and that the state changes are never complex in the sense that you could base behavior on branching (if else etc). It should be trivial right?
02:45:03 <jle`> zerobaud: sounds kind of like a graph search
02:45:10 <jle`> but you don't have to ever talk about state here...
02:45:13 <jle`> you're just talking about a function
02:45:29 <jle`> there's no need to invoke the idea of state of any kind
02:45:38 <zerobaud> I guess I see what you mean
02:46:08 <jle`> you're basically looking for a mathematical function that fits your input and output pairs
02:46:14 <Ariakenom> zerobaud: Do you want a unique function? Some requirements on the function?
02:46:26 <jle`> of course this problem isn't a simple one in general
02:46:35 <zerobaud> Ariakenom: as many as possible, behaving the same as the "black box" function we want to emulate.
02:46:55 <jle`> this is the basic idea behind, say, image recognition, self-driving cars, game AI
02:47:09 <jle`> i give you a pair of x-ray images and the diagnosis, and you pick a function that gives the diagnosis from the image
02:47:21 <jle`> *give you many pairs
02:47:38 <jle`> do you see that this problem isn't really a simple one to solve in general?
02:48:50 <Ariakenom> But so far the simplest solution is to fit a polynomial to the curve f x = y
02:49:13 <jle`> right, that's technically correct, but will almost never generalized to unseen data points
02:49:21 <jle`> it also doesn't work if the same x is paired with different y's in observation
02:49:43 <zincy> In high school my biology teacher's approach was draw a straight line with a ruler that looked right across the graph
02:49:54 <Ariakenom> with different mappings  it's not a function or algorithm
02:50:08 <jle`> zincy: yes but that only works if your data points generally approximate a line
02:50:25 <zincy> Yes I found it funny though
02:50:43 <jle`> it's definitely not a simple problem in general, and is probably unsolvable in the general case
02:50:44 <zincy> Such mathematical rigout
02:50:47 <zincy> rigour
02:51:09 <jle`> but if you have the general shape of the function you want, you can get some useful results
02:51:44 <jle`> zincy: do you have a specific problem you are trying to solve?
02:51:51 <zincy> surely there is a better way to minimise error with a linear regression than taking a rules and drawing a line which feels right
02:52:18 <zincy> nope
02:52:25 <jle`> depends on what measurement you are using for 'better'
02:53:48 <Logio> zincy: drawing a line by hand is usually "good enough"
02:54:34 <kuribas> zincy: least squares fit?
02:54:55 <jle`> oh sorry, that question was meant for zerobaud
02:55:02 <jle`> zerobaud: do you have a specific problem you are trying to solve?
02:55:07 <zerobaud> well, yes.
02:55:15 <Logio> from experience, calculating the LS fit on pen and paper causes much more strain on the wrist for very little gain
02:55:30 <zincy> So all of machine learning is just the game of find this magic function?
02:55:32 <jle`> you'll probably get much better help the more specific you ask, here
02:55:42 <zerobaud> Ehm, I need to create basic blocks from a binary, and then modify them and write them back.
02:55:43 <jle`> zincy: not necessarily all
02:55:52 <zincy> What about generalised AI? Such a thing surely wouldnt be reducible to such a simple problem
02:56:14 <jle`> zerobaud: what is a basic block?
02:57:00 <zerobaud> jle`: defined more or less like "https://en.wikipedia.org/wiki/Basic_block" - TLDR series of assembly instructions with no flow control changes other then next instructions is the next instruction.
02:57:56 <zerobaud> link does not work since the last quote gets appended to the url
02:58:01 <jle`> how do you mean, create a basic block from a binary?
02:58:09 <zerobaud> jle`: I read the binary in memory
02:58:17 <zerobaud> then parse its ELF / PE header
02:58:33 <zerobaud> then get the .text section (for now) and start dissasembling the instructions
02:59:02 <zerobaud> The first instruction start the basic block, the basic block ends on JMP / CALL / RET / INT instructions (or if the current is a branch target)
02:59:22 <dminuoso> zerobaud: So you want to split machine code into basic blocks?
02:59:42 <zerobaud> dminuoso: I am already doing that.
03:00:01 <zerobaud> I want to change the basic blocks to look different while behaving the same and not having ANY knowledge about what the instructions are.
03:00:15 <zerobaud> besides knowing which instructions they are not... so I kind of know the ones that I will encounter.
03:00:21 <zerobaud> But I should not know what they do
03:00:40 <LiaoTao> https://en.wikipedia.org/wiki/Polymorphic_code
03:01:18 <zerobaud> LiaoTao: nope, polymorphic code does not have anything to do with this, polymorphic has a encryptor / decryptor or encoder / decoder.
03:01:38 <zerobaud> If you want to define what I am doing, it is more like a metamorphic engine.
03:01:39 <dminuoso> zerobaud: In effect peephole optimizations?
03:02:12 <zerobaud> dminuoso: I guess yes, except that they dont have to optimise the code. But its the same context as peephole optimizations.
03:03:02 <jle`> zerobaud: if you only have a limted number of instructions, you can just enumerate over all possible programs
03:03:08 <jle`> until you find one that matches
03:03:15 <zerobaud> If I give two sets of state (registers / cpu flags) of the start of the basic block and the end. How can I syntesize equally behaving basic blocks?
03:03:51 <jle`> all you can do is observe several input/output pairs?
03:03:53 <zerobaud> jle`: but I need multiple tries at least: since a NOP would satisfy before = "1" after = "1" while the input was 1.
03:04:02 <zerobaud> but the basic block actually did input * 1 = output
03:04:16 <jle`> zerobaud: so, you only have one possible try?
03:04:21 <zerobaud> no I have many
03:04:45 <zerobaud> But these edge cases, I dont know of a mathemtical model that can assure me that my synthesized basic blocks behave the same
03:05:02 <zerobaud> how can we even define equality? its obvious its not the input and output for only 1 try
03:05:10 <zerobaud> you need at least 2 tries but how many do you need really?
03:05:11 <jle`> if your registers are finite, you can just test all possible inputs and outputs
03:05:37 <zerobaud> So there is indeed a limit for test cases that can assure the blocks are identical...
03:05:46 <zerobaud> what optimizations can I make?
03:05:59 <zerobaud> Can I proof somehow that if it holds for X inputs and outputs it will hold always?
03:06:03 <jle`> the limit is that you only have a finite number of possible test cases
03:06:07 <jle`> if your registers are finite
03:06:16 <jle`> you don't have infinite possible test cases.
03:06:21 <zerobaud> true
03:06:30 <zerobaud> so we are good in the sense we can define equality 100%
03:06:35 <zerobaud> just by trying all cases
03:06:44 <zerobaud> but how can we define it more efficiently?
03:06:54 <jle`> the general thing you are looking at is called PL semantics
03:06:54 <zerobaud> Maybe we can proof that we only need 3 cases?
03:07:00 <zerobaud> with 3 different numbers?
03:07:11 <jle`> the field of defining what it means for programs to be equal
03:07:30 <jle`> zerobaud: you can't really say anything like that without limiting your operations
03:07:57 <zerobaud> they are limited, mostly to logical operations like xor, not, and, or, add, sub, mul, div
03:08:13 <zerobaud> basically they are all there are
03:08:15 <jle`> right, but do you see how we cannot say anything with certainty unless we consider *all* the operations
03:08:26 <jle`> you can't just talk about some of them
03:08:41 <zerobaud> you are rtight, okay lets limit the set to the afromentioned onces
03:09:02 <zerobaud> how would we go about optimising the cases? can we proof that if it holds for X different cases its equal?
03:09:31 <zerobaud> this is (probably) highly dependent on the operation, what works for xor would not for add I guess...
03:10:38 <jle`> i do'nt think so.  if you can "nxor" with arbitrary numbers, then there's no way of finding which number you are nxoring with unless you try all combination
03:11:13 <jle`> er hm i stated that incorrectly
03:11:39 <jle`> if you can find a way to test for equality to a given number, then there's no way of finding out what number that is unless you try all combiations
03:12:37 <jle`> so if "equal to 8952734545" is a possible operation somehow, then you can't test what that program would be except for trying all possible numbers.
03:13:41 <jle`> you can probably define an "equal to" operation in terms of successive bit shifts and xor's.
03:16:13 <dminuoso> Any docker and gitlab users here? How do you do CI?
03:16:57 <dminuoso> If I want my gitlab runner to build a docker image, I cant use fpco/stack-build, and if I use the docker base image I'll have to manage the tooling myself.
03:17:29 <dminuoso> Do I just have to bite the bullet and configure my Dockerfile to set up stack and clang?
03:21:19 <sigma_> if Maybe is a monad how to bind it's value to a variable like we can do for the IO monad >?
03:21:33 <dminuoso> sigma_: you dont "bind" really
03:21:42 <dminuoso> sigma_: do-notation is just syntax sugar for (>>) and (>>=)
03:21:53 <malice> Hi! I'm using Emacs, but I forgot how to run haskell's REPL
03:21:53 <dminuoso> sigma_: The logic you are looking for is described by (>>=)
03:22:01 <malice> What commands are there to do that? I'm not thinking of run-haskell
03:22:12 <malice> (the one I'm thinking about makes prompt be a lambda symbol)
03:22:47 <ventonegro> :t Nothing >>= Just
03:22:49 <lambdabot> Maybe b
03:22:52 <sigma_> dminuoso : i'm aware of the that but we can infact bind the value a monad encapsulates to a variable right ? like this a <- m where m :: IO String
03:22:54 <Boomerang> Well you can still use do notation for Maybe
03:23:11 <dminuoso> sigma_: for example: when you write `do { a <- getLine; putStrLn ("Hello" ++ a) }` it's desugared into `getLine >>= \a -> putStrLn ("Hello" ++ a)`
03:23:17 <dminuoso> sigma_: so its not really
03:23:19 <dminuoso> "binding"
03:24:02 <ventonegro> :t Nothing >>= (+ 1) . Just
03:24:04 <lambdabot> Num (Maybe b) => Maybe b
03:24:22 <dminuoso> sigma_: It's just a way of taking `Maybe a`, and some `a -> Maybe b` and plumbing them together in a lawful manner.
03:25:26 <sigma_> dminuoso : i'm confused now because i can do this for IO monad and not for Maybe moand?
03:25:42 <Boomerang> > do { x <- Just 2; y <- Just 3; z <- Just (x + y); return (z + 2) }
03:25:44 <lambdabot>  Just 7
03:25:48 <dminuoso> :t (>>=)
03:25:50 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:25:52 <dminuoso> sigma_: It's all about this function.
03:25:59 <dminuoso> And
03:26:01 <dminuoso> :t return
03:26:02 <lambdabot> Monad m => a -> m a
03:26:21 <Taneb> Hmm, should there be an instance Monoid e => Alternative (Either e)? that either gives you the first success or an accumulation of failures
03:26:23 <merijn> sigma_: The thing is that do notation requires that whatever comes out of that block still be "in" the original monad
03:26:40 <merijn> Taneb: Maybe you want Validation?
03:26:47 <sigma_> dminuoso : yeah one applies a value in context to a function and another puts a value in default context still not clear
03:26:57 <merijn> Taneb: Although that's slightly different in that it gives you either 1) all failures or 2) all successes
03:27:07 <dminuoso> sigma_: do-notation is just syntax sugar around (>>=) nothing more.
03:27:08 <Taneb> merijn: I'm aware of Validation :)
03:27:10 <dstolfa> a monad is just an adjunction with two natural transformations, what's the problem?! :)
03:27:37 <dminuoso> a monad is just the composition of two adjoint functors, whats the problem?
03:27:54 <dstolfa> dminuoso: a monad is just a monoid in the monoidal category of endofunctors, what's the problem?
03:27:55 <Boomerang> Taneb: Yeah but there's Validation from the validation package and the one from the either package
03:27:58 <Taneb> I'm just wondering whether this is a valid/useful instance
03:27:58 <merijn> This joke is so dead it's starting to resemble a lich....
03:28:14 <merijn> Boomerang: They have the same semantics, though
03:28:16 <dstolfa> merijn: ah see, but people keep coming up with new ways to define a monad
03:28:24 <dstolfa> merijn: and keep adding the "what's the problem?" :)
03:28:26 <dminuoso> dstolfa: an applicative is just a monoid in the monoidal category of endofunctors equipped with the Day convolution operator.
03:28:37 <Boomerang> I remember they had a small difference, can't remember what, I'll have a look
03:28:57 <dminuoso> dstolfa: My favourite one is still the kleisli category route.
03:28:59 <dminuoso> It feels very clean :)
03:29:02 <Taneb> It'd make Either () and Maybe pretty much exactly the same
03:29:04 <merijn> sigma_: Personally I recommend newcomers avoid using do-notation entirely until they're comfortable writing stuff with >>= and >> and only *then* switch to do-notation
03:29:14 <merijn> Taneb: Simple solution
03:29:17 <dstolfa> dminuoso: yes, i agree
03:29:19 <dstolfa> dminuoso: or the comonad one
03:29:23 <merijn> Taneb: "Validation Error (First Result)"
03:29:48 <Taneb> merijn: again, I'm not actually looking to use this
03:30:04 <merijn> Taneb: Yeah, but that proves it's lawful :)
03:30:06 <dminuoso> dstolfa: Whats that?
03:30:15 <Taneb> merijn: assuming Validation and Either have the same Applicative
03:30:18 <merijn> Taneb: Because you can reformulate it as two lawful instances
03:30:18 <Taneb> (which iirc they don't)
03:30:38 <merijn> Validation and Either don't have the same Applicative, no
03:30:43 <dstolfa> dminuoso: a monad is just a comonad of the dual of the opposite category :)
03:30:53 <sigma_> merijn : what the fact that do is syntactic sugar for >>= and >> has to do with the fact that i can't bind Maybe Int to a value without pattern matching or using formMaybe
03:31:22 <jle`> sigma_: you can bind the Int
03:31:29 <merijn> sigma_: You can, though?
03:31:44 <jle`> @let bindTheInt x = x >>= \i -> Just (i + 3)
03:31:45 <lambdabot>  Defined.
03:31:49 <jle`> > bindTheInt (Just 4)
03:31:52 <lambdabot>  Just 7
03:31:53 <edwardk> a comonad is just a comonoid object in the category of endofunctors, what is the problem?
03:31:56 <jle`> there, 'i' is bound to 4
03:32:02 <dstolfa> edwardk: monoidal category*
03:32:13 <zerobaud> jle`: but in order to perform if operations we must branch, the basic blocks by definition do not include branching. You might set a flag that gets used later to branch. But this is part of the transformed input forming the output that needs to be replicated.
03:32:23 <dstolfa> also it's a monoid
03:32:43 <edwardk> its a monoid in the dual category
03:32:47 <Taneb> merijn: this'd follow the MonadPlus laws as well
03:32:50 <jle`> zerobaud: you can implement "equal to 5" in terms of xor's and bitshifts, i think?  so you don't need any ifs or branching
03:33:03 <sigma_> merijn : ??
03:33:04 <dminuoso> edwardk: What is the most obscure definition of a monad that you can think of?
03:33:05 <jle`> zerobaud: a function that is 1 if a value is equal to 5, and 0 otherwise
03:33:25 <Taneb> I'm going to email the appropriate mailing list about this
03:33:26 <merijn> sigma_: See jle`'s example?
03:33:31 <dstolfa> edwardk: depends on which perspective you think about it from, sure :)
03:33:45 <dstolfa> edwardk: my point was that you can think about it in both ways
03:33:47 <dstolfa> so it's even more obscure
03:33:56 <Boomerang> So merijn it looks like Validation from either has an instance for Alternative that validation doesn't supply
03:34:10 <zerobaud> jle`: I think, yes you are right... does this prove that for the subset we choose ALL values must be tested? (I think it does)
03:35:04 <Boomerang> That's because Validation from validation doesn't accumulate errors in the Alt instance
03:35:23 <edwardk> well its a comonoid object in ([C,C],Compose,Identity). “the (monoidal) category of endofunctors equipped with functor composition, the same place where monads are monoid objects.
03:35:25 <zerobaud> what if we can generalize the problem, instead of testing for 5 we can substitute it with any other number. Can we syntetise an algorithm and proof it works for the generalization of the compare?
03:35:29 <jle`> zerobaud: yes if you have at minimum xnor and div
03:35:31 <Boomerang> (and doesn't require Semigroup on err like the one in either does)
03:35:42 <merijn> I don't like the validation package anyway, too many lenses and obnoxious ways to deal with them
03:35:48 <merijn> Validation in either is so much cleaner
03:35:50 <jle`> zerobaud: i don't know what you mean
03:35:55 <Boomerang> I agree :)
03:35:57 <jle`> merijn: Validation in transformers is best
03:36:01 <jle`> since it comes with ghc
03:36:25 <merijn> jle`: There is no Validation in transformers?
03:36:34 <zerobaud> jle`: well I think I know enough for now, I am not able to formulate my questions. Thank you so much showing me that all inputs are necesary in the conditioned we outlined above!
03:36:38 <jle`> merijn: there is but they don't call it Validation
03:36:51 <jle`> it's called Errors
03:37:18 <merijn> jle`: That's not the same
03:37:22 <merijn> jle`: That can't generate successes
03:37:37 <jle`> it can with pure ?
03:37:58 <merijn> ah, I missed lift
03:38:14 <merijn> But that doesn't slot nicely into coding using Either
03:38:53 <jle`> it pretty much has the same API as the validation one :o
03:38:59 <Taneb> I've emailed the libraries mailing list :)
03:39:48 <Taneb> Although last time I did that it turned out it'd already been implemented when I wasn't paying attention
03:40:34 <jle`> Taneb: Monoid e => Alternative (Either e) would be nice, except transformers defines an orphan instance for Alternative (Either e)
03:40:53 <jle`> so it'd have to happen at the same time as a change in transformers
03:41:16 <jle`> why does transformers even have that orphan instance
03:41:26 <jle`> this is one of the greatest haskell ecosystem mysteries, to me
03:41:46 <Taneb> jle`: soon it may no longer be an orphan but be in its rightful place!
03:42:00 <edwardk> dstolfa: guess i’d say “iff F -| U, UF is a monad” since it is sufficient to define them all thanks to Kleisli and E-M, so it can be read both ways and is informative about the nature of adjunctions, which are largely why category theory came into existence in the first place
03:42:02 <jle`> it is at the moment Error e => Alternative (Either e)
03:42:52 <jle`> so if anyone uses it, Monoid e => Alternative (Either e) would break any code currently using Either's Alternative instance :'(
03:43:04 <jle`> but i suspect that not many people are using it in the first place
03:43:18 <edwardk> jle`: we at least got Error out of the Monad constraint for Either e
03:43:35 <dstolfa> edwardk: i'm happy with everything you've said, i just tried to make it more convoluted :)
03:43:38 <jle`> edwardk: oh, was that actually a thing?
03:43:58 <edwardk> yeah used to live right next to that instance you hate
03:44:05 <jle`> hm
03:44:20 <dminuoso> edwardk: That intuition is not very useful for Haskell though is it? Do the adjoint functors even exist for most Monad instances?
03:44:22 <jle`> that deserves some commending :)
03:44:37 <jle`> but, dropping the constraint wouldn't break any code that already used it, would it?
03:44:47 <dstolfa> dminuoso: they definitely exist, but they may not directly usable in haskell! :)
03:44:55 <edwardk> dminuoso: not that can be defined on functors from hask->hask
03:45:14 <edwardk> the only one you really have there is the prod-hom adjunction
03:45:14 <jle`> in this case we're changing the constraint, so this would break almost all code that uses Alternative/MonadPlus for Either
03:45:43 <edwardk> and you can define cont in terms of the adjunction given by function-from but that goes through hask^op
03:46:27 <edwardk> jle`: basically nothing has happened there because all of those options suck for folks who have defined an Error instance that happens to be a monoid.
03:47:12 <edwardk> Error is kinda meh, but it does offer a touch more info than Monoid in that situation
03:47:19 <dminuoso> edwardk: with prod-hom adjunction you mean state/store?
03:47:55 <edwardk> (,e) -| (->)e which gives rise to state and store
03:48:07 <jle`> edwardk: the accumulation characteristics are different, compared to the (presumed) Monoid-based instance
03:48:18 <jle`> although i'm not sure if i would ever find that useful
03:48:30 <edwardk> and the cont one uses (->r) -| (->r)
03:49:19 <edwardk> accumulation is why things like Validation exist
03:50:51 <adjofun> edwardk: Maybe you can help me. I am searching for paper, in which author described that parametrized types are repelling all arguments against functional languages. Such arguments are pretty old, 1960s iirc.
03:51:46 <edwardk> anyways it isnt clear that the laws of MonadError allow grouping up errors this way, in fact its kinda strongly implied that it doesnt
03:52:21 <edwardk> adjofun: not sure i can help you. doesnt sound familiar
03:53:01 <Taneb> Ugh, I forgot how very slighty tedious replying to mailing list emails is in GMail
03:53:23 <Taneb> Have to carefully reply to librarys@ and not just one person
03:53:41 <adjofun> edwardk: welp, no effective propaganda in my workplace then =:)
03:54:19 <dstolfa> adjofun: parametrised types in the dependent type sense?
03:54:55 <Taneb> adjofun: only thing springing to mind is John Hughes' Why Functional Programming Matters
03:55:03 <adjofun> dstolfa: no, just types like `f a` as opposed to types `a`
03:55:10 <adjofun> Taneb: will look
03:55:19 <dstolfa> adjofun: what does "f" represent here
03:55:42 <dstolfa> are you talking about types depending on types? i.e. List(a)?
03:55:42 <zincy> What should I look for if my quickcheck test fails to terminate?
03:55:51 <Np-Harda`> hi everybody
03:55:58 <zincy> I guess infinite loop would be the only way?
03:56:41 <adjofun> dstolfa: Generally functors, i.e context attached to a type to laypeople
03:56:57 <dstolfa> adjofun: but in a type-theoretic sense, are they types or terms?
03:56:59 <merijn> zincy: Install a timeout?
03:57:16 <dstolfa> are we talking about a type depending on a term or are we talking about a type depending on another type
03:57:24 <dstolfa> because f a could just as well have been List a
03:57:29 <dstolfa> if they're both types, that is
03:58:01 <dstolfa> if f is a term, then we're talking about dependent types and we can augment it to a calculus of constructions and eventually end up proving theorems
03:58:15 <zincy> merijn: What does that mean :/
03:58:32 <merijn> zincy: Wrap the tests with a timeout that throws an exception after X seconds?
04:00:53 <adjofun> dstolfa: the point of paper is that Maybe a is more useful than a (encapsulates valid null state), List a is more useful than a (encapsulates many possible values in one), and ad infinium iirc
04:01:48 <dstolfa> adjofun: i mean, sure, but why is this exclusive to functional programming?
04:03:06 <dstolfa> one nice thing about functional programming is composability, that's how we get shit done. we write primitives and compose them instead of rewrite a bunch of things but a little bit differently
04:03:39 <dstolfa> in imperative languages, i.e. ones like C, you can write it similarly, but it's not really built for it and it becomes quite ugly
04:03:53 <zincy> merijn: How would you do that?
04:03:55 <dstolfa> but when it comes to types depending on other types, i.e. Maybe a, List a and so on, you can do that just fine
04:04:42 <merijn> zincy: https://hackage.haskell.org/package/base-4.11.1.0/docs/System-Timeout.html#v:timeout for example?
04:05:27 <zincy> merijn : Thanks!
04:06:16 <zincy> so how would we represent failure within types in imperative languages?
04:06:36 <dminuoso> zincy: Java has checked exceptions
04:06:39 <zincy> Javascript has null
04:06:43 <dminuoso> zincy: Optional types are also a way.
04:06:45 <adjofun> dstolfa: so, type composition is not a buzzword for a while now, I know, but I am still in need to show to Java programmers that they can use generics more effectively
04:07:04 <adjofun> so, the question about that paper persists
04:07:48 <zincy> Has anyone here come from say a long background in imperative languages like java or c? Did they find that it made haskell much tougher?
04:08:33 <adjofun> zincy: I wrote C before Haskell. I consider Haskell a better C now.
04:08:37 <dstolfa> adjofun: i mean, the point of type systems in programming languages is to help you catch runtime problems at compile-time (usually anyway)
04:08:57 <merijn> zincy: I mostly did Java, Python, and C when I started in university
04:09:00 <dstolfa> so why not use them :)
04:09:01 <cocreature> zincy: I have but I don’t really have anything to compare it to so it’s hard to say if it made it harder
04:09:05 <merijn> zincy: And most of my work is still C/C++
04:09:28 <merijn> zincy: I think it depends very much on your exact imperative background
04:10:01 <dstolfa> i come from a background of developing kernels where ad-hoc C is praised
04:10:04 <zincy> I guess maybe not really having a background before starting haskell was an advantage in my case
04:10:05 <dstolfa> it's not fun
04:10:09 <merijn> zincy: For example, most HPC C++ programmers I talk to find Haskell fairly easy to grasp, because due to their experience with the problems caused by mutability and manual memory maangement they appreciate Haskell's choices more ;)
04:10:19 <zincy> interesting
04:10:26 <adjofun> dstolfa: Yeah, why not. Tell than to old corn knobs in my workplace. I can only sway tham with recogniced authorities, sadly, like Dijkstra =\
04:10:44 <merijn> zincy: But people who write CRUD applications in Java, probably find it hard due to being "too different"
04:10:51 <zincy> merijn: For your own projects what split of you work is in haskell vs c/c++
04:10:59 <dstolfa> adjofun: so, they'll listen to dijkstra but not to alonzo church? ;)
04:11:08 <merijn> zincy: All the code I *can* write in Haskell is in Haskell :p
04:11:18 <dstolfa> merijn++
04:11:18 <zincy> hehe
04:11:21 <merijn> zincy: Last year I spent a ton of time replacing a bunch of python scripts with Haskell
04:11:22 <dstolfa> merijn: exactly this
04:11:28 <merijn> zincy: Massively improved my life
04:11:29 <dstolfa> i have to write C for the most part, but if i get the chance, it'll be haskell
04:11:42 <adjofun> dstolfa: generally they listen more to whitepapers than to me =\
04:11:50 <merijn> zincy: A lot of people say that python is amazing as "glue language" because it's so easy to call out to C when you need speed
04:11:52 <zincy> is c worth learning just to learn about memory management
04:12:01 <dstolfa> zincy: it's not even good memory management, it's actually crap
04:12:11 <merijn> zincy: I would say that Haskell actually makes it much easier to interact with C than python
04:12:15 <dstolfa> flat addresses spaces, storing metadata out of bounds
04:12:22 <dstolfa> compilers often doing the wrong thing
04:12:28 <zincy> what niche does python fill I never understood it
04:12:39 <dstolfa> if i were to recommend C to someone, it would be just so they realise how terrible it is
04:12:44 <dstolfa> what a terrible language
04:12:44 <zincy> hahaha
04:12:54 <merijn> dstolfa: I would say learning C is still important, not because of the language, but because understanding it requires a bunch of useful knowledge about stuff like linking, ABIs, etc. that is relevant in Haskell too
04:13:12 <dstolfa> merijn: i agree :)
04:13:21 <merijn> dstolfa: ANd there's much more literature explaining linkers for C than Haskell :p
04:13:27 <dstolfa> argh linkers
04:13:28 <zincy> say you only know a bit of haskell and javascript would a bit of c be the next logical step?
04:13:31 * dstolfa has done some lld work
04:13:35 * dstolfa does not like linkers
04:13:42 <merijn> zincy: A bit of C and/or just basic computer architecture
04:14:07 <zincy> I bought a kindle book on computer architecture to read in bed :)
04:14:08 <merijn> zincy: Basic computer architecture and OS stuff is *important* if you don't wanna write webapps for life
04:14:36 <merijn> zincy: Tanenbaum's "Operating Systems: Design & Implementation" is a very good and accessible book
04:14:47 <zincy> webapps are fun but I file like there is a growing chasm between the skill of web app developers and non-web app developers
04:14:48 <mniip> merijn, yeah but these days what isn't a webapp :p
04:14:52 <merijn> He has a good book on architecture too, although that's probably considerably more dated
04:14:55 <mniip> even ghc is WEBSCALE
04:15:01 <merijn> mniip: Someone has to write the hard backend stuff :p
04:15:17 <mniip> just wait until chrome is rewritten in asm.js
04:15:37 <dstolfa> here's my take on the whole thing, as someone who spends most of his time working on kernels, compilers and CPUs but has a background in maths: doing systems is a great way to realise what the shortcomings of current systems are (there are many) and what problems you encounter in the real world so that you can apply the maths meaningfully.
04:15:40 <cocreature> I’ve had good experience with throwing my hands in the air and sighing really loud whenever I have to mess with the linker. way less work than actually learning how they work
04:16:03 <Taneb> cocreature: :D
04:16:08 <adjofun> merijn: It also can push you to write your own kernel, and to start flame wars with Tanenbaum ;)
04:16:38 <dstolfa> merijn: many arch books are outdated :/
04:16:48 <merijn> adjofun: Naah, what pushed Linus was the fact that Tanenbaum was continuously rejecting 3rd party additions/contributions
04:16:54 <dstolfa> merijn: i find it surprising that very few books mention the shortcomings of an MMU-based architecture
04:17:02 <merijn> cocreature: I've always pawned my linker problems on other people :p
04:17:21 <merijn> dstolfa: MMU's are my friend!
04:17:25 <cocreature> merijn: that sounds like another nice solution :)
04:17:28 <merijn> Virtual memory is best memory!
04:17:31 <zincy> I dont even know what a linker is and get the feeling I dont want to find out
04:17:46 <zincy> whenever stack build throws a linker err I dont know what to do
04:17:53 <dstolfa> merijn: unless there's too many TLB entries, then the disk is your friend :>
04:18:04 <adjofun> zincy: No, you do need to know that =)
04:18:05 <merijn> zincy: Linkers take libraries and object files (basically, machine code) and links them together into a single executable/library
04:18:06 <zerobaud> jle`: wow check this! https://github.com/StanfordPL/stoke
04:18:30 <merijn> dstolfa: I just mmap all the things!
04:18:38 <merijn> Best syscall in existence!
04:18:57 <dstolfa> merijn: i think that's a bit of an oversimplification. they actually take object files that have certain structure and produces certain formats that the OS can interpreter to spawn a process (ELF, Mach-O, COFF)
04:19:02 <zerobaud> I dont know what verification algo they use, I will study STOKE and its underlying concepts once I am home. My boss is already thinking I am slacking again (which I am)
04:19:05 <adjofun> zerobaud: did someone just applied genetic algorithm to code transformations?
04:19:11 <merijn> zincy: PHK's "You're Doing it Wrong" is a good intro into *why* you need to know this stuff: https://queue.acm.org/detail.cfm?id=1814327
04:19:14 <mniip> dstolfa, in what case can you have too many TLB entries
04:19:25 <mniip> I'm assuming you do use hugepages when possible right?
04:19:36 <dstolfa> mniip: sandboxing. the only way to isolate things in an MMU-based architecture is to duplicate the TLB entries (i.e. fork a process)
04:19:46 <dstolfa> that's why chrome starts conflating sandboxes eventually
04:19:48 <cocreature> zerobaud: stoke is pretty cool, there is a nice talk about the optimization part on youtube iirc
04:19:52 <zerobaud> adjofun: I dont think STOKE uses genetic algorithms. from what I can see it justs tries untill it finds something quciker / better etc...
04:19:57 <mniip> hol up
04:19:59 <mniip> TLB vs page table
04:20:07 <zerobaud> cocreature: awesome, that will be a good starting point thanks!
04:21:11 <cocreature> zerobaud: stoke does mcmc on the assembly and uses some heuristic to judge performance iirc
04:21:16 <mniip> dstolfa, if I recall correctly TLB is flushed on context switch so multiple processes have no play in it at all
04:21:28 <dstolfa> merijn: phk is a nice person but very opinionated and can be hard to discuss some things with he's very opinionated on (personal experience :))
04:21:28 <mniip> except for the kernel pages which stay in there forever unless PTI is turned on
04:21:38 <cocreature> anyway, I’ll shut up now since it’s not really related to Haskell :)
04:21:41 <mniip> (or they are evicted by the process pages)
04:22:03 <quicksilver> merijn: I was unaware of that paper. Thanks, it looks interesting (from the first few pages)
04:22:28 <adjofun> zerobaud: I am pretty sure that "random transformation, and evaluating that transforamtion with respect to X" is in essence a genetic algorithm.
04:23:02 <dstolfa> mniip: that's not true, having more processes means you have more TLB entries, which means that pages go to disk once it's full. the more you have, the more go to disk. the worst case scenario is that you always access the page on disk and evict the next one you need to access. this is a very well known problem, described back in 2008-ish and we've since moved on to different architectures that natively
04:23:05 <zerobaud> adjofun: I see, well my knowledge is limited in that regard.
04:23:08 <dstolfa> support sandboxing without any kind of MMU (CHERI, for example)
04:23:20 <mniip> "go to disk"?
04:23:23 <mniip> I'm sorry?
04:23:42 <mniip> do you have the same "TLB" in mind as I do
04:24:22 <mniip> Translation Lookaside Buffer, the cache that caches GDT->PD->PT lookups
04:24:58 <merijn> quicksilver: Not really a peer-reviewed paper, more of an essay/editorial, but still interesting
04:25:00 <dstolfa> mniip: the problem is that you can't cache all the pages, so what you do is you put them on the disk to page them in later (so you can actually access things in physical memory). if you try to access something in physical memory and it's not present, you will get a page fault. the page fault handler is responsible for paging these things in (i.e. reading them from some storage, usually the disk)
04:25:11 <mniip> sure
04:25:16 <mniip> but what does this have to do with filling up the TLB
04:25:24 <mniip> you can have more "present" pages than the TLB can fit
04:25:27 <dstolfa> mniip: because when you fork a process, you end up with more pages
04:25:38 <dstolfa> mniip: the more pages you end up with, the slower it is when you access them
04:25:43 <mniip> sure
04:25:50 <merijn> dstolfa: Only *if* you access them :)
04:25:51 <mniip> but disk is not involved whatsoever
04:25:56 <mniip> also only on context switch
04:25:59 <dstolfa> merijn: well, why would you even bother sandboxing then? :)
04:26:07 <dstolfa> just remove the code
04:26:15 <dstolfa> merijn: aehm, no, it is involved.
04:26:19 <dstolfa> mniip: ^
04:26:38 <merijn> dstolfa: I don't use virtual memory for sandboxing, I use it because it removes the need for me to think about smart access pattern prefetching and offloading it all to the kernel :)
04:26:39 <dstolfa> mniip: if you read how the VM subsystem handles these page faults, you'll see that it explicitly goes to disk in one of the backends
04:27:07 <mniip> dstolfa, you realize there's two different systems at play
04:27:21 <dstolfa> mniip: it'll go VM subsystem -> something like pmap (which is the arch-specific bits for page tables) -> VFS -> filesystem backend -> disk in one path, for example
04:27:22 <merijn> dstolfa: You also don't have to worry about freeing/releasing memory, the OS will just page shit out for me and do a pretty good job
04:27:36 <mniip> dstolfa, I know that very well
04:27:42 <dstolfa> mniip: then why are you confused?
04:27:48 <mniip> I think it's you who is confused
04:28:14 <mniip> pages may get evicted to disk, and they are loaded back when a page fault at a "not present" page occurs, that much is correct
04:28:20 <mniip> TLB is a completely different story
04:28:22 * adjofun went to grab some popcorn
04:29:06 <mniip> popcorn? we're having a civil discussion
04:29:40 <Taneb> mniip: some people just like eating popcorn I guess
04:29:40 <adjofun> mniip: Text doesn't convey emotions, so I always assume flame war =:)
04:29:53 <dstolfa> popcorn is tasty
04:29:57 <adjofun> it is
04:30:13 <mniip> is it sweet popcorn or salty
04:30:19 <LiaoTao> Unless it's topped with sugar
04:30:19 <Taneb> I'm not a huge fan of popcorn
04:30:23 <merijn> #haskell is generally rather flamewar free
04:30:24 <dstolfa> mniip: but yes, sure, but i still don't understand how more pages is irrelevant for the TLB, it still slows down things the moment you evict things from the TLB
04:30:39 <Peaker> using alex: Pre-validation (^ rule) does not work, as it ignores skipped tokens :-(   using happy: Adding an alternative to an existing grammar *shrinks* the language(??) :-(
04:30:39 <dstolfa> even if you keep them off the disk (the disk was an extereme example)
04:30:40 <Taneb> Although now we are extremely off topic
04:30:43 <Peaker> alex/happy make me sad
04:30:48 <mniip> dstolfa, yes but things are evicted from the TLB any way
04:30:50 <Clint> haha
04:30:54 <mniip> on every context switch
04:31:13 <__monty__> merijn: I don't know, this popcorn business is getting me pretty irate. Everyone knows potato chips is where it's at.
04:31:14 <dstolfa> mniip: i'm not too sure about that. what do you mean by "context switch" here?
04:31:20 <dstolfa> you don't flush the TLB on every syscall, for example
04:31:22 <dstolfa> that would be far too slow
04:31:33 <mniip> okay right, when the scheduler switches threads
04:32:19 <mniip> (but also IIRC when PTI is on it *is* flushed on syscall entry/exit)
04:32:28 <mniip> (not sure about that)
04:32:29 <Peaker> Is it supposed to be possible in happy to add " | <option>" to an existing rule - and have it reject previously accepted inputs?
04:32:53 <Peaker> I thought "happy" generated an efficient parser that acts as if it backtracked to try everything
04:32:55 <dstolfa> mniip: AFAIK PTI is meant to isolate the kernel maps from the userspace maps, so they only need to flush the kernel bits (which is still a big perf hit, but not as big as a FULL flush)
04:33:24 <__monty__> Peaker: Are you sure the language shrinks? Maybe the parser is smaller because there's less inlining?
04:33:25 <mniip> probably true
04:33:29 <stiell> When constructors are automatically promoted to types under -XDataKinds, is there any way to "demote" such a type back to its corresponding constructor?
04:33:50 <Peaker> __monty__, I mean "shrink" as in reject programs that were accepted
04:33:52 <mniip> a TLB miss *in a process* doesn't happen more often when there's more processes
04:34:09 <mniip> so my point stands
04:34:18 <dstolfa> mniip: what do you mean in a process?
04:34:39 <mniip> when a single thread is executing the TLB is oblivious to any other threasd that exist in the system
04:34:52 <Peaker> __monty__, s/programs/inputs.   This is my 4th attempt maybe to give alex/happy a try. And I'm disappointed each time.  I got a contribution of a much-faster alex/happy parser (than the previous parsec parser) which is forcing me to use this
04:34:54 <mniip> so a fork does not change how "full" the TLB is
04:35:10 <__monty__> stiell: Not sure what you mean but the original type and contstructer you declared still exist.
04:35:17 <Peaker> I wonder how attoparsec will fare against alex/happy
04:36:27 <merijn> Peaker: Pretty well if you take care to write an effcient parser
04:36:33 <dstolfa> mniip: it does though, because you have a working set of pages (each process has their own set of pages), and if they don't fit in the TLB, they'll cause more misses which is much slower
04:36:52 <cocreature> megaparsec can often also at least get close to attoparsec so you don’t need to give up all the niceties
04:36:53 <Peaker> merijn, efficient as in not much backtracking?
04:36:54 <mniip> yes but a fork does not create more pages per process
04:37:03 <merijn> Peaker: Most of the (potential) slowdown with parser combinators/recursive descent parsers is backtracking. If you can commit to a grammar/parser that avoids backtracking it will be superfast
04:37:07 <merijn> Peaker: yeah
04:37:09 <dstolfa> mniip: nono, not per process. did i say that? if so, my bad. i meant it just creates more pages for the OS to deal with
04:37:18 <mniip> yes but that in the end does not affect the TLB
04:37:39 <dstolfa> mniip: it does because you end up with more threads in different address spaces
04:39:30 <stiell> __monty__: e.g. like natVal or symbolVal, but for other types than Integer or String.
04:40:11 <mniip> dstolfa, different address spaces means TLB flush
04:41:17 <dstolfa> mniip: not a full one, but yes, and forking creates this situation when creating sandboxes that have to interact with eachother (either via some kind of RPC or what have you)
04:41:41 <dstolfa> so for chrome, if you create 30+ tabs, it'll start conflating sandboxes into a single process simply because the overhead is too significant
04:42:39 <mniip> that sounds like optimizing away context switches
04:42:42 <mniip> not TLB space
04:43:11 <dstolfa> mniip: yep, i agree :)
04:43:26 <dstolfa> mniip: i never said we need more TLB space, just that it'd be a good idea not to use the MMU to implement sandboxing
04:43:37 <dstolfa> but for that you need an architecture which supports it
04:43:56 <dstolfa> the MMU is great for multitasking and makes unix work the way it does
04:44:08 <dstolfa> but there are downsides (number of accesses when traversing the page tables is another)
04:44:12 <dstolfa> especially nested pages
04:44:29 * dstolfa wrote an architectural nested page table walk with interrupts off from scratch and does not want to do it again
04:53:31 <__monty__> stiell: I think what you're looking for is singletons like in the hasochism paper.
04:58:08 <Ariakenom> EWD vs PHK. I read to papers from here that made nice opposites. https://www.cs.utexas.edu/users/EWD/ewd00xx/EWD32.PDF https://queue.acm.org/detail.cfm?id=1814327
04:59:00 <Ariakenom> "Some meditations on advanced programming" vs "You're doing it wrong"
05:01:39 <quicksilver> merijn: "anisotropic memory access delay" what a nice choice of adjective
05:01:55 <quicksilver> this paper is a much more nuanced version of the "O(1) is a myth" that I generally spout
05:03:36 <BalterNotz> @hoogle
05:03:36 <lambdabot> package base
05:03:36 <lambdabot> package bytestring
05:03:36 <lambdabot> package containers
05:06:14 <BalterNotz> :> take 5 [1..]
05:08:10 <mniip> quicksilver, your computer is not turing complete
05:08:13 <mniip> O(-) is a lie
05:08:36 <adjofun> >quickCheck (\x -> x == x)
05:08:49 <adjofun> > id x
05:08:51 <lambdabot>  x
05:09:09 <adjofun> > quickCheck (\x -> x == x)
05:09:11 <lambdabot>  error:
05:09:11 <lambdabot>      • Couldn't match expected type ‘Test.QuickCheck.Random.QCGen’
05:09:11 <lambdabot>                    with actual type ‘() -> Bool’
05:11:14 <lyxia> @check \x -> x == x
05:11:16 <lambdabot>  +++ OK, passed 100 tests.
05:11:37 <Boomerang> Is that defaulting to () for x?
05:11:43 <adjofun> oh, that is hoiw it's done. Can someone link me to a list of LambdaBot commands?
05:11:44 <merijn> quicksilver: Now you too can be lazy and just cite stuff ;)
05:12:05 <Boomerang> @check \x -> x == (x :: Float)
05:12:07 <lambdabot>  +++ OK, passed 100 tests.
05:12:21 <Boomerang> No NaN issues then...
05:12:26 <lyxia> adjofun: you can PM lambdabot with @help and follow the suggestions
05:12:55 <adjofun> lyxia: thanks!
05:14:57 <BalterNotz> @help
05:14:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:15:06 <BalterNotz> list
05:15:08 <BalterNotz> @list
05:15:09 <lambdabot> What module?  Try @listmodules for some ideas.
05:15:17 <BalterNotz> @listmodules
05:15:17 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
05:15:17 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
05:16:01 <lyxia> BalterNotz: /query lambdabot   to not spam the channel
05:16:13 <BalterNotz> ok
05:17:43 <BalterNotz> hello
05:17:57 <BalterNotz> ok, bye bye
05:43:06 <__monty__> quicksilver: I haven't heard your spiel about O(1), consider me a willing audience.
05:44:38 <opqdonut> summary: memory random access is O(log n) because pointer lengths are O(log n)
05:45:14 <opqdonut> (the standard RAM model in complexity analysis fixes this by assuming that word size is O(log n))
05:45:34 <Ariakenom> No it's probably about virtual memory. Where it takes O(log n) to walk a tree
05:46:16 <opqdonut> that's the practical side of the coin
05:46:24 <opqdonut> memory hierarchies
05:46:57 <Ariakenom> also sqrt n to travel to memory and back for a square shaped memory and n the are which is proportional to amount
05:47:11 <opqdonut> nice
05:47:30 <opqdonut> hadn't considered that
05:47:40 <Ariakenom> :)
05:49:13 <mniip> opqdonut, also computers aren't turing complete so truly it makes no sense to talk about "asymptotic" complexity
05:50:36 <opqdonut> that's kinda different
05:50:45 <opqdonut> you can still talk about asymptotic complexity of an algorithm
05:50:58 <mniip> sure, but not its implementation
05:51:09 <opqdonut> yeah
05:51:33 <opqdonut> I guess the trick is that the constant factors tend to be in the same ballpark so you can often cheat by just doing asymptotic analysis
05:51:49 <mniip> constant factors aren't the problem
05:52:17 <mniip> it's just that the input size is limited
05:52:33 <opqdonut> yeah I know what you mean
05:52:47 <opqdonut> I was just musing about why asymptotic analysis matters
05:52:50 <mniip> you're effectively only evaluating the algorithm's complexity on [1..a few trillion]
05:52:50 <opqdonut> in practice
05:53:10 <mniip> consider e.g Furer's algorithm for integer multiplication
05:53:24 <opqdonut> yeah or the bleeding edge matrix multiplication things
05:53:30 * hackage shake-cabal 0.1.0.1 - Shake library for use with cabal  http://hackage.haskell.org/package/shake-cabal-0.1.0.1 (vmchale)
05:53:37 <opqdonut> https://rjlipton.wordpress.com/2010/10/23/galactic-algorithms/
05:53:41 <mniip> you *cannot* see a performance improvement over Schonhage-Strassen if your pointer size is constant
05:53:53 <opqdonut> right
05:54:03 <opqdonut> yeah that's even more subtle
05:54:50 <Ariakenom> Random bignum link: https://gmplib.org/
05:57:27 <mniip> iirc SS is the "last" backend that libgmp uses
05:57:42 <mniip> for numbers with multiple tens of thousands of digits
05:57:53 <adjofun> offtopic, while I see GMP: can someone explain to me why where is no primops for integer^integer? GMP suports that iirc, and that could bring to `scientific` *reeeeeally* arbitrary precision numbers
05:59:00 <adjofun> someone already kicked the author of `scientific` because it is used in aeson, and someone in production already got to limit of Integer^Int, and it broke their code
05:59:51 <mniip> adjofun, GMP supports what?
06:00:11 <mniip> I see mpz_powm whish is modular exponentiation and mpz_pow_ui which has an int32 exponent
06:00:23 <mniip> sorry uint64 exponent
06:00:41 <sigma_> is atomically function from STM module is an example of monad transformer ?? because atomically :: STM a -> IO a
06:00:42 <adjofun> mniip: bignum exponentiation is not a thing in GMP, you saying?
06:00:55 <Ariakenom> https://gmplib.org/manual/Multiplication-Algorithms.html#Multiplication-Algorithms
06:01:11 <adjofun> sigma_: it is an example of natural transformation, rather
06:01:22 <mniip> Ariakenom, ah my bad, just plain FFT
06:01:30 * hackage distributed-process-client-server 0.2.5 - The Cloud Haskell Application Platform  http://hackage.haskell.org/package/distributed-process-client-server-0.2.5 (AlexanderVershilov)
06:01:32 <Ariakenom> "At large to very large sizes a Fermat style FFT multiplication is used, following Schönhage and Strassen "
06:01:42 <lyxia> sigma_: that's not a monad transformer.
06:01:50 <sigma_> adjofun : what's the difference ?
06:01:56 <mniip> adjofun, the ^^ in Prelude is of similar complexity to the best algorithm known to me
06:02:06 <Ariakenom> mniip: I linked GMP because i remembered Schönhage and Strassen from GMP
06:02:45 <adjofun> mniip: it is not about complexity, it is about arbitrary precision in `scientific`
06:03:01 <mniip> well-uh, use ^^
06:03:57 <adjofun> mniip: aeson uses Scientific for JSON Number, I willl link an issue
06:04:03 <mniip> sigma_, a monad transformer is a type of kind (* -> *) -> * -> *
06:04:34 <mniip> in general, T is a monad transformer when for any Monad m, T m is a Monad
06:05:14 <mniip> usually T "adds" some features onto m
06:05:35 <mniip> in that T's >>= uses m's >>= internally somehow, but also has extra logic of its own
06:06:16 <sigma_> mniip : how it's done than going from STM to IO because (>>=) restrict that right "m a -> (a -> m b) -> m b"
06:06:32 <mniip> ?
06:06:42 <mniip> not sure what you're asking
06:08:33 <__monty__> :t listToMaybe
06:08:34 <lambdabot> [a] -> Maybe a
06:08:50 <__monty__> sigma_: ^ not a monad transformer.
06:09:05 <adjofun> mniip: I remembered an issue incorrectly, someone in prodiction got hit by divergence of Fractional instance of Scientific. But there is an open issue for Integer^Integer: https://github.com/basvandijk/scientific/issues/62
06:10:27 <adjofun> sigma_: Natural transformation is a morphism with type m a -> n a. As examples, `listToMaybe` and `atomically` are natural transformations. Think of them as context transformations.
06:10:31 <dminuoso> sigma_: Generally if you have some `(Functor f1, Functor f2) => f1 a -> f2 a`, assuming it obeys some laws, natural transformation.
06:11:25 <Ariakenom> mniip: Did you see that GMP's last algo was indeed Schönhage and Strassen?
06:11:51 <adjofun> sigma_: Regarding monads: Monad is a functor with two natural transformations, pure :: a -> m a, and join :: m (m a) -> m a
06:11:52 <mniip> there's a difference
06:12:09 <mniip> between "FFT according to Schonhage and Strassen" and "Schonhage-Strassen algorithm"
06:12:32 <sigma_> adjofun : okay.. makes sense thank you.
06:12:48 <dstolfa> adjofun: it's not a functor, it's an adjunction, i.e. two adjoint functors
06:12:50 <mniip> the latter actually makes an improvement by picking the base as a power of two
06:13:02 <mniip> and then I think there's some recursion regarding the finite field operations
06:13:13 <malice> I've got a question: I'm following this tutorial: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Evaluation,_Part_2
06:13:19 <malice> specifically, I'm at implementing eqv
06:13:21 <dminuoso> dstolfa: it is a functor.
06:13:37 <dstolfa> dminuoso: it's an ENDOFUNCTOR :)
06:13:40 <dminuoso> dstolfa: Because Functor f => Functor (f :.: f)
06:13:44 <sigma_> anyone aware of some good resources on monad transformers and readerT and readerT pattern specifically please share
06:13:47 <dminuoso> Oh well!
06:13:47 <malice> This is a binary operation; however, there is some redundancy in the code
06:13:50 <adjofun> dstolfa: my category-theory-foo is weak, sadly =\
06:13:54 <malice> e.g. specialization for Number and for Bool look the same
06:14:09 <malice> is there a way to write the first four clauses as one?
06:14:14 <jinzhao> hello
06:14:19 <mniip> dstolfa, is there a definition of a monad that dos not require an endofunctor?
06:14:28 <BalterNotz> 你好 jinzhao
06:14:31 <dstolfa> mniip: hmm
06:14:44 <mniip> unless you mean we get an endofunctor by composing the two sides of the adjoint
06:14:55 <dstolfa> mniip: good question, i mean, an adjunction can be defined in terms of adjoint functors i.e. L for left-adjoint and R for right-adjoint with a natural transformation between them
06:15:07 <dstolfa> so you don't explicitly say "endofunctor" but yeah
06:15:27 <mniip> in an adjoint neither L nor R are endo
06:15:31 <dstolfa> yeah
06:15:34 <dstolfa> but LR gets you back
06:15:53 <mniip> are you saying every endofunctor is splittable into an adjunction?
06:15:55 <dstolfa> you could say it's an adjunction with 2 natural transformations being the unit and counit
06:15:56 <dminuoso> (F -| G) => Monad G :.: F
06:16:36 <dminuoso> Is there actually a typeclass to express adjunction?
06:16:54 * dminuoso checks edwards repositories
06:17:09 <mniip> I remember seeing that
06:17:15 <dminuoso> https://hackage.haskell.org/package/adjunctions-4.4/docs/Control-Monad-Trans-Adjoint.html mmm
06:17:30 <dminuoso> What is AdjointT :o
06:17:42 <Taneb> http://hackage.haskell.org/package/adjunctions-4.4/docs/Data-Functor-Adjunction.html
06:17:46 <mniip> f (w (g a)) pretty much
06:17:59 <mniip> that's a comonad transformer though
06:20:22 <mniip> I'm going to conjecture Maybe(X) = 1 + X does not decompose into an adjunction
06:21:31 <mniip> coproducts only pop up to the left of adjunctions while units only to the right
06:22:23 <Taneb> My copy of Categories for the WOrking Mathematician has just arrived! \o/
06:23:17 <adjofun> Taneb: congrats, now you will know how deep the rabbit hole goes =:)
06:23:36 <mniip> Taneb strikes me as the type of person to having already known that
06:23:42 <Taneb> adjofun: oh, I've already done a bit of diving in
06:23:59 <Taneb> This is me trying to reinforce the walls of my rabbit hole
06:24:43 <Ariakenom> So that they can take a strung gust.
06:24:54 <dstolfa> Taneb: i like ct4s by spivak as well :)
06:25:34 <__monty__> malice: No, you can't have a variable/wildcard match a constructor only a value.
06:26:28 <malice> too bad
06:27:19 <Taneb> dstolfa: I've also been recommended CT by Awodey
06:27:38 <Taneb> And when I was at university I enjoyed Categories by Schubert, but that's hard to get ahold of
06:28:16 <__monty__> malice: You can factor out the bodies of the four clauses though. Or if you had for example Expr Bool arg1, Expr Number arg1, etc. then you could treat those four clauses in a single definition.
06:29:32 <__monty__> malice: Would be something like eqv [(Expr a arg1), (Expr b arg2)] | a == b = return $ Expr Bool $ arg1 == arg2
06:31:20 <malice> well, Bool, Number etc. are of LispVal data type
06:31:44 <malice> but that won't help, I guess
06:32:30 <Psybur> @hoogle These (f a) (f a) -> f (These a a)
06:32:30 <lambdabot> Data.These mapThis :: (a -> c) -> These a b -> These c b
06:32:30 <lambdabot> Data.These mapThat :: (b -> d) -> These a b -> These a d
06:32:30 <lambdabot> Data.Align align :: Align f => f a -> f b -> f (These a b)
06:36:32 <__monty__> malice: The second solution would imply you scrap those constructors and make a new one whose first parameter would be an enum of the four things you just scrapped. Sure that refactoring may be involved but it's possible in principle, just depends how motivated you are to reduce the number of cases in eqv ; )
06:37:20 <dminuoso> Can I command stack to preinstall a resolver?
06:37:27 <Taneb> Psybur: the obvious thing there I think needs a Monad constraint
06:37:31 <dminuoso> (Preferrably without some fake project)
06:37:51 <Taneb> Or... no
06:38:00 <Taneb> I'm completely wrong here
06:38:10 <dmwit> Applicative should be enough.
06:38:29 <Taneb> Yeah, I completely misread it
06:38:47 <__monty__> malice: I'd probably just factor out the body of the clauses but you might not want the auxiliary function poluting the top level.
06:39:04 <dmwit> Psybur: If it has a Bitraversable instance, `bitraverse` can be given that type (with the `Applicative` constraint).
06:39:25 <dmwit> Psybur: Yay, the haddocks say it does have the appropriate instance!
06:39:59 <dmwit> Sorry, I mean bisequenceA, obviously.
06:46:30 * hackage ats-storable 0.3.0.5 - Marshal ATS types into Haskell  http://hackage.haskell.org/package/ats-storable-0.3.0.5 (vmchale)
06:57:34 <Psybur> Thanks
07:38:53 <ddellacosta> I was reading Justin Le's post on lenses and prisms (https://blog.jle.im/entry/lenses-products-prisms-sums.html) yesterday, and I got confused by one thing he brought up--the isomorphism between NonEmpty a and (a, [a]). Is there a way to express this in actual Haskell code? I don't know what `<~>` is, other than that it's expressing that isomorphism somehow
07:39:30 * hackage distributed-process-client-server 0.2.5.1 - The Cloud Haskell Application Platform  http://hackage.haskell.org/package/distributed-process-client-server-0.2.5.1 (AlexanderVershilov)
07:40:07 <darkJedi> Hi! What does ```let fibs = 1:1:(zipWith (+) fibs (tail fibs))```
07:40:30 <darkJedi> What does the expression mean over here ?
07:40:52 <darkJedi> I understood zipWith with it's type signatures
07:40:52 <adjofun> @let fibs = 1:1:(zipWith (+) fibs (tail fibs))
07:40:54 <lambdabot>  Defined.
07:41:01 <adjofun> > take 10 fibs
07:41:02 <darkJedi> But what does 1:1: mean over here
07:41:04 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
07:41:15 <Cale> It defines fibs to be the list which starts with two 1's and then continues with the elementwise sum of itself with its own tail
07:41:50 <darkJedi> Oh! Thanks
07:42:19 <darkJedi> This is probably the shortest fibonacci code that I ever saw.
07:42:20 <darkJedi> :)
07:44:31 <Cale> > fix ((0:) . scanl (+) 1)
07:44:33 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:44:53 <Cale> darkJedi: ^^ there's another one to puzzle over :)
07:45:38 <darkJedi> hi I had one more doubt. https://lpaste.net/6426402858828038144
07:45:59 <darkJedi> I tried to understand the type inference of cons.
07:46:09 <Cale> :t (:)
07:46:10 <lambdabot> a -> [a] -> [a]
07:46:19 <Cale> ^^ this might be more helpful :)
07:46:45 <darkJedi> What does ... mean in ```data [] a = ... | a : [a]```
07:46:46 <darkJedi> ?
07:47:14 <Cale> That's actually pseudocode, since the type of lists has built-in syntax, but what's meant is that : is one of its data constructors
07:47:26 <adjofun> darkJedi: Where are you even took that example?
07:47:34 <Cale> adjofun: From :i in ghci
07:47:41 <adjofun> huh
07:47:50 <darkJedi> @adjofun :i from ghci
07:47:51 <lambdabot> Unknown command, try @list
07:48:35 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-prim-0.5.2.0/src/GHC.Types.html#line-98
07:48:37 <darkJedi> :Cale Thanks
07:49:01 <Cale> It's funny that they can even really get away with that definition
07:49:04 <adjofun> darkJedi: So, define `data MyList a = MyNil | MyCons a (MyList a)`
07:49:27 <Cale> Yeah, you can imagine that if you'd defined something like adjofun's definition, and did :i MyCons
07:49:46 <Cale> it would show you something like  data MyList a = ... | MyCons a (MyList a)
07:50:00 <darkJedi> :adjofun Thanks I will try it right away.
07:50:59 <jbetz> https://github.com/alasconnect/auth0 <-- how would I use `ghcid` in a project like this? nix-shell doesn't have the `auth0` library package, so that doesn't work, but I'd think it'd be easy to add it, I just don't know how.
07:51:42 <jbetz> "that" being `ghcid --command="ghci test/Main.hs" inside the nix-shell
07:58:07 <jbetz> `ghcid -c="cabal new-repl lib:auth0"` <-- okay, got it working with this :)
07:58:44 <Cale> hmm
08:10:24 <quicksilver> opqdonut and Ariakenom not only accurate summarised my O(1) rant but they did so more accurately and coherently than I would have. IRC ftw.
08:13:24 <Ariakenom> woop!
08:16:04 <Cale> jbetz: I'd kind of expect that you'd want to add something for the native auth0 library to an extraPackages argument to mkDerivation in packages.nix, however, I'm not sure where to get that :)
08:16:34 <Cale> assuming it's a missing native build input? :)
08:16:40 <Ariakenom> Hm. More coherently. So quicksilver would have argued more than 2 views at once?
08:17:00 <Cale> Maybe I'm misunderstanding what's going wrong though
08:20:06 <Cale> jbetz: oh, I see what you mean -- you want a nix-shell with *your* auth0 library built
08:20:15 <jbetz> Cale: exactly
08:21:13 <jbetz> and `new-repl` gives me that, so I don't think I need to mess with the derivation at all
08:21:27 <jbetz> which is nice
08:22:23 <quicksilver> Ariakenom: frequently, yes.
08:22:40 <quicksilver> Ariakenom: I am both incoherent and overlapping. Often also undecidable.
08:22:50 <maerwald> Installing Stack to: /usr/local/bin/stack -- wth
08:23:20 <Ariakenom> Sounds pragmatic
08:24:12 <maerwald> ah, it supports --dest=, but ofc doesn't provide --help
08:24:15 <maerwald> very pragmatic
08:24:18 <Cale> jbetz: seems fair enough. There is a way to do it just with nix, but it would require a bit more editing.
08:24:23 <tdammers> stackmatic
08:24:51 <Ariakenom> bad timing. I was talking about quicksilver
08:25:07 <tdammers> fitting nonetheless :)
08:27:39 <maerwald> and the installer doesn't support my linux distribution :>
08:27:50 <maerwald> I guess I also have to switch distro to use it
08:28:06 <maerwald> so exciting
08:28:34 <tdammers> which distro would that be?
08:29:10 <maerwald> emacs
08:29:36 <tdammers> D:
08:29:40 <adjofun> vim is my favourite OS =:)
08:31:02 <maerwald> does ghc-mod even support stack?
08:31:38 <gentauro> Question, isn't the SAFE language Pragma pretty much useless? :) -> https://gitlab.com/snippets/1724709
08:31:49 <dminuoso> maerwald: Yes but the current lts is not supported afaik.
08:32:06 <gentauro> I would like to hear why my table isn't the way it should have been done :)
08:32:25 <dminuoso> It works up to 9.22 (or whatever the latest 9.xx is) I believe. Though there are some not-yet-released patches for newer versions
08:32:45 <geekosaur> gentauro, Trustworthy means you are asserting that you know the uses of e.g. unsafePerformIO have been vetted and won't cause problems
08:32:49 <glguy> gentauro: The point of Trustworthy modules is that you're asserting that the module, while internally unsafe, exports a safe public API and should be OK to import into safe modules
08:33:10 <gentauro> and that is a fair point
08:33:13 <glguy> and then at a package level users of the package get to decide if they want to honor your trustworthy assertions
08:33:28 <gentauro> but how can a module calling something Trustworthy become safe?
08:33:48 <glguy> Because you decide whether to accept trustworthy modules at the package level
08:33:49 <gentauro> I mean, I would accept that you bubbled up the Trustworthyness, but not convert it
08:34:14 <gentauro> glguy: yes, and that would at most make my library Trustworthy, not SAFE
08:34:17 <glguy> no
08:34:31 <gentauro> but it's possible as I show in my code, to make my app SAFE while it isn't ...
08:34:34 <glguy> The point of trustworthy modules is that they are intended to be imported by safe modules without futher verification
08:34:55 <glguy> once you're satisfied with the trustworthy modules not being dangerous it's OK to import them without further checks into a safe module
08:34:57 <gentauro> glguy: and that's is my point why I say that SAFE is pretty much useless :)
08:35:21 <glguy> then you're missing the point of you have to manually choose whether or not to accept trustworthy modules
08:35:28 <geekosaur> "Trustworthy" = asserted, "Safe" = inferred. And you're assuming a different threat model than Safe Haskell is designed for; the docs and original paper go over that part
08:35:53 <glguy> you can toggle your trust in a package with the ghc-pkg tool
08:36:06 <geekosaur> in particular, it is explicitly *not* a security model in the usual sense
08:36:24 <gentauro> glguy: yes, I'm able to remove all trust (even base) but code like the provided go smoothly through ...
08:36:27 <geekosaur> it's a *purity* model
08:36:27 <gentauro> :|
08:37:04 <gentauro> it's none of the above. It's a false safety "something"
08:37:12 <geekosaur> no
08:37:12 <glguy> gentauro: You lied to yourself and said that NotReallySafe was safe and then object when it wasn't?
08:37:20 <geekosaur> that's deciding the model you want is the only valid model
08:37:28 <gentauro> I would compare it to redirecting your HTTP calls to HTTPS with a JavaScript instead of disabling HTTP on server level
08:37:49 <glguy> then you'll need to reread the paper
08:38:22 <maerwald> Bootstrapping stack project environment failed -- lol
08:38:31 <glguy> maerwald: Have you tried stack?
08:38:37 <maerwald> :>
08:39:11 <gentauro> glguy: probably, but I'm also probably not going to go away from my analogi of SAFE pragma = HTTP to HTTPS redirect with JS
08:39:27 <glguy> ok, sounds good
08:49:30 * hackage observable 0.1.0 - Make your action to be observable and listen events from them.  http://hackage.haskell.org/package/observable-0.1.0 (iokasimovmt)
08:51:21 <maerwald>  ~/.stack/config.yaml: Unrecognized field in ConfigMonoid: resolver
08:55:27 <maerwald> https://docs.haskellstack.org/en/stable/yaml_configuration/#resolver
08:55:32 <maerwald> am I reading something wrong?
09:00:00 <gentauro> glguy: I might have another question
09:01:33 <gentauro> glguy: If I make a stack script and include a Trustworthy package (ex: http-client-tls), if I mark the script as SAFE, it will actually fail: https://gitlab.com/spisemisu/cleanse-facebook/blob/master/CFB.hs#L17-29
09:02:05 <gentauro> is there something "built-in" to Stack that doesn't allow the Trustworthy propagation to SAFE (this is actually what I'm looking for)
09:02:12 <glguy> packages can't be Trustworthy
09:02:14 <Psybur> @glguy, remember all that hubbub I was making about merging alternatives? Data.These and Data.Align are doing the trick
09:02:14 <lambdabot> Unknown command, try @list
09:02:22 <gentauro> but I don't seem to be able to do it "manually" with "ghc"
09:03:20 <glguy> gentauro: When you mark a package "trusted" you're saying that that package's Trustworth annotations on modules should be honored
09:05:01 <gentauro> so a simple "ghc -o foo *.o" linking, shouldn't be doing that right?
09:05:21 <glguy> depnds on what's set in your package database
09:05:59 <gentauro> my *.o are just local modules I have pre-built. For example: ghc -Wall -Werror -O3 -c Wrapper.hs -o wrapper.o
09:09:23 <gentauro> so I think I begin to get it. SAFE pragmas only work on packages (handled by ghc-pkg)
09:10:00 * hackage distributed-process-supervisor 0.2.1 - Supervisors for The Cloud Haskell Application Platform  http://hackage.haskell.org/package/distributed-process-supervisor-0.2.1 (AlexanderVershilov)
09:10:22 <gentauro> so in case I want to enforce safeness, the same way Stack does it, I will have to register my local modules as packages with ghc-pkg ... I will give that a try
09:10:31 <geekosaur> you were expecting ghc to somehow hook into the guts of the system linker?
09:10:39 <geekosaur> did you also expect it to hook the kernel?
09:11:16 <gentauro> geekosaur: when I linke an Unsafe pkg to a Safe app, it crashes (as expected)
09:11:40 <geekosaur> when you have packqages at ghc level yes
09:12:20 <gentauro> that's why I don't really got the grasp of why it will allow to link Trustworthy to Safe. But I can see that it's designed like this
09:12:32 <geekosaur> yes of course ghc should implent its own linker. like they're trying to get aaway from because that doesn;t work on ARM, that gets into trouble on OS X, it means chasing OSes that are constantly changing the rules
09:12:43 <gentauro> and that's also what I'm pointing out with my table of what actually give sense
09:17:40 <inkbottle> With elementary arithmetic evaluator state monad counting the 'div', I fail to find the equality in first formula there: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf#page=12 (section 2.3 is to be read section 2.8, BTW)
09:17:42 <inkbottle> (State (s -> ((), s+1)) >> return 3 =?= return 3 >> State (s -> ((), s+1))
09:24:14 <nshepper1> gentauro: it sounds like you want to -trust http-client-tls in your stack script?
09:25:05 <infinisil> Hey, I made myself a monad which does IRC actions, e.g. `replyPriv :: Text -> m ()`, now to actually run this, I'll need to pass it an input message
09:25:45 <infinisil> I mean to run the Monad, because i wanna reply to a certain message
09:26:28 <infinisil> What I can do I think is this: `instance IRCMonad (ReaderT InputMessage m) where`
09:27:06 <infinisil> Then I should be able to run it by doing runReaderT action inputMessage
09:27:18 <nshepper1> gentauro: that way the import of Network.HTTP.Client into your Safe modules should be ok
09:27:19 <infinisil> Is that how you're supposed to do this? Or am I missing something?
09:27:34 <nshepper1> but i've never really tried using SafeHaskell before
09:29:01 <gentauro> nshepper1: not really
09:30:05 <gentauro> I want to pass some functionallity with IO (get / post) to a safe submodule
09:30:11 <glguy> nshepper1: No, the one module that that package exports is not Trustworthy or Safe
09:31:11 <gentauro> that way, when I executed your code, I would have a certenty that the only IO you could perform would be to use my logic
09:31:52 <gentauro> my problem is that I'm assuming that your are nice and will provide me with some SAFE code (my goal is to accept binary)
09:32:06 <gentauro> but the GHC don't really helps me
09:32:23 <gentauro> well it helps me when you provide me with an Unsafe .o file
09:32:38 <glguy> gentauro: To restrict the IO that a Safe module can do, you'd make a new type and operations on that type that you want to allow, Then the restricted module can be required to export a value of that type that your outer program might be willing to convert to IO and execute
09:32:40 <gentauro> then GHC doesn't want to link Safe .o with Unsafe .o (ME GUSTA)
09:32:55 <glguy> you generally shouldn't be manually linking o files
09:33:26 <gentauro> but if you provide me with a "nasty" .o marked as Trustworthy, GHC will "eat it raw" an say "It's fine, lets link this stuff"
09:34:19 <gentauro> my general problem is that I assumed that Safe/Unsafe/Trustworthy was implemented in a "sound" way, but it seems that it isn't and is just trying to "forward HTTP to HTTPS with some JavaScript" :'(
09:34:35 <nshepperd> exactly what kind of certainty are you looking for?
09:34:38 <glguy> You're circumventing the system
09:34:55 <maerwald> sad, intero-neovim seems buggy even with stack
09:35:14 <nshepperd> security? that's impossible, I can put arbitrary code in a .o file and mark it any way I want
09:35:18 <gentauro> nshepperd: I would accept that if you provide me with a Trustworthy .o, I would it at least have to mark my module as Trustworthy
09:35:31 <glguy> gentauro: then you're still missing the point
09:35:40 <geekosaur> gentauro has one security model. it is the only conceivable security model, and therefore this must conform to it
09:35:48 <nshepperd> you should load source code
09:35:58 <gentauro> nshepperd: this is what I'm able to do now
09:36:08 <ZeuPiark> hello
09:36:18 <gentauro> but I'm thinking of people having some IP that they don't wan to share (and that is fair enough)
09:37:02 <gentauro> but if the problem is that you can't never trust any .o file and the compiler can't help you, then I will just rely on code
09:37:14 <geekosaur> it's not just the compiler you need checking
09:37:17 <geekosaur> it's the system linker
09:37:19 <geekosaur> it's the kernel
09:37:24 <geekosaur> it's libc
09:38:05 <geekosaur> or, yes, you do it yourself and make sure you've covered all bases, and there's no way that the kernel that isn;t following your threat model can do its own thing instead of yours
09:38:11 <geekosaur> or libc or etc.
09:38:44 <nshepperd> for all practical purposes, verifying a .o file does or doesn't do anything in particular is impossible
09:39:12 <gentauro> nshepperd: how is ghc able to not allow linking Unsafe / Safe .o together?
09:39:18 <gentauro> I mean, there must be a feature for this right?
09:39:28 <geekosaur> it only does so when it is using the package database and its annotations
09:39:32 <glguy> No, you aren't meant to use Safe Haskell at the object file level like this
09:39:35 <geekosaur> linking .o files does not use the package database
09:39:38 <geekosaur> it uses the system linker
09:39:48 <geekosaur> I ask again: do you expect ghc to patch the system linker to do its will?
09:39:53 <habbah> how do you test api endpoints with hspec?
09:40:26 <gentauro> geekosaur: what do I know? That's why I'm asking
09:40:31 <habbah> how do others here test api endpoints?
09:40:41 <geekosaur> and that's why I'm asnwering, and why glguy is answering
09:40:50 <geekosaur> but you keep rejecting those answers
09:40:56 <geekosaur> you want to hear something else
09:41:19 <gentauro> geekosaur: it's actually not the likner
09:41:38 <geekosaur> you say you don't know, but you can also say that
09:41:40 <nshepperd> even if there is such a thing as a 'Safe .o file' (it sounds like geekosaur is saying there is not), it would just be a flag set somewhere in the file asserting that when ghc built the file it verified that the source was Safe
09:41:40 <gentauro> linker (sorry). it's ghc when it tries to compile and I'm pointing to the .o file
09:41:52 <nshepperd> it would be trivial to set that same flag on any file
09:42:05 <shapr> silly question, how do I get the max value for the ID column from persistent?
09:42:39 <geekosaur> gentauro, you really do not know how this works. ghc cannot "compile" a .o file. and ghc cant even sensibly rerad it to see your magic unalterable safe/unsafe annotation
09:42:59 <geekosaur> ghc passes .o files to the system linker, ghc generates a .o file when given a .hs file and then passes that to the system linker
09:43:00 <shapr> I get an uploaded file, and I want it to have a unique name, is there a better way than using the max id value for the matching db row for uploaded form data?
09:43:17 <nshepperd> if people want to avoid sharing some IP, they should probably either not submit it or run the code through some kind of source-to-source obfuscator that preserves Safeness
09:43:34 <geekosaur> if you link in a package, it consults its package database to see (in this case) if it is safe, tne retrieves the package databse's information on .o/.so/.a/whatever and passes that to the system linker
09:44:18 <dminuoso> shapr: Use GUIDs and a unique constraint.
09:44:30 <shapr> unique constraint?
09:44:34 <shapr> guid is a good idea!
09:45:31 <dminuoso> shapr: If it needs to be unique, additionally enforce it with a unique constraint in the database. Surely persistent must have some interface for that.
09:45:42 <shapr> oh good point
09:46:01 <shapr> dminuoso: that solves the whole thing, thanks!
09:46:20 <gentauro> nshepperd: I just built the module both as Unsafe and TrustWorthy and diffed them
09:46:26 <gentauro> not difference between them :|
09:46:45 <geekosaur> it's in the package registry, as you've been told multiple times
09:49:01 <gentauro> geekosaur: where? I mean, executing -> ghc-pkg list show none of my local modules ...
09:49:16 <geekosaur> correct because they are not packages
09:49:21 <geekosaur> which you were also told multiple times
09:49:36 <geekosaur> yu keep insisting that what you are being told is wrong because it's not what you want to believe is actually happening
09:49:54 <geekosaur> which does not change what is actually happening to what you prefer to believe
09:50:35 <gentauro> geekosaur: forget
09:50:37 <gentauro> forget it
09:50:54 <geekosaur> what you want to have happen cannot be done by ghc
09:50:57 <geekosaur> or by gcc
09:51:06 <geekosaur> or by any other compiler
09:51:09 <nshepperd> where the annotation is doesn't really matter anyway
09:51:24 <nshepperd> the only way to verify a module is Safe is to compile it yourself
09:51:28 <geekosaur> it needs to be in the kernel, it needs to be supported by the entire system toolchain
09:52:03 <nshepperd> if you're accepting a module someone else compiled, you can't verify it
09:52:34 <gentauro> nshepperd: "if you're accepting a module someone else compiled, you can't verify it" got it
09:52:47 <gentauro> so no accept of others .o file. Give me the code or no show
09:52:49 <gentauro> thx
09:52:54 <geekosaur> pretty much, yes
09:52:59 <nshepperd> yep
09:53:11 <geekosaur> you get no guarantees anywhere. this kind of thing is *hard*
09:53:54 <geekosaur> (and you're still vulnerable to someone replacing key things. like the compiler or the linker.)
09:54:00 <geekosaur> @google reflections on trusting trust
09:54:01 <lambdabot> https://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf
09:59:26 <nshepperd> there /are/ forms of cryptographic wizardry ('Secure multi-party computation' protocols) that could in theory accomplish this, but they're a long way off from being remotely practical especially on something as complex as ghc
10:04:35 <dminuoso> geekosaur: This is one of the reasons why Linus only compiles his own kernel from his own git repo. =)
10:05:27 <liste> that doesn't save him from tainted compilers though
10:05:31 <liste> or tainted linkers
10:05:33 <geekosaur> ^
10:07:18 <dminuoso> liste: In a way it's scary because tainted hardware is *much* harder to prove. It's not reasonable to look at a modern DIE with an electron microscope and have any idea how it works, and whether in between the billions of transistors produced by the most propriertary HDL code on this planet have some kind taint.
10:08:30 <nshepperd_> I mean, "someone has already installed malware in my machine" is a very different threat model to "someone sent me a program, i want to check that it's not malware"
10:08:37 <geekosaur> dminuoso, dont forget things like hacked usb firmware
10:09:47 * geekosaur … is not a security expert. but knows far too much for comfort, even so
10:12:31 <dminuoso> geekosaur: I was really scared to learn how easy it is to ring escalate if you have hardware access.
10:12:41 <geekosaur> yep
10:12:56 <dminuoso> There's OTS PCI cards with an usb plug you can use to directly probe memory, its scary.
10:13:20 <dminuoso> And its not like they employ any hacks, this feature is basically in the design.
10:32:31 <infinisil> What's the difference between `type Foo m :: *` and `type Foo m :: *` in a typeclass?
10:32:48 <infinisil> Um, I mean `type Foo m :: *` and `data Foo m :: *`
10:33:07 <cocreature> infinisil: data families create new types, type families resolve to existing types
10:34:03 <infinisil> Hmm, okay then I think I want `type` in my case. It's a class that represents something that can provide an input of a specific type
10:39:09 <infinisil> Wow, I feel like a pro, I was able to use the "~" thing for once
10:39:56 * cocreature hands infinisil their Haskell-pro badge
10:44:08 <edmundnoble> Oooh show it
10:44:40 <infinisil> The ~?
10:48:37 <koala_man> nice. I still haven't done that ^^
10:57:26 <infinisil> Turns out I don't need it..
10:57:36 <APic> n
10:57:36 <infinisil> Hah
10:57:39 <APic> Sorry
10:59:51 <dmwit> Hand back your badge.
11:00:54 <infinisil> I already engraved it in my skin, too late!
11:05:17 <glguy> You'll just have to scratch it out then, yikes!
11:08:00 * hackage persistent-migration 0.0.1 - Manual migrations for the persistent library  http://hackage.haskell.org/package/persistent-migration-0.0.1 (brandonchinn178)
11:16:55 <reygoch> Hi peeps
11:19:56 <reygoch> I have the following code : https://lpaste.net/4968465867919589376
11:20:27 <dmwit> 2
11:20:32 <reygoch> problem is that it is becoming cumbersome to thread Semigroup constraints through all the functions that use it
11:20:34 <dmwit> (sorry)
11:21:58 <reygoch> I'm wondering if there is a better way to write that because I'm getting functions with type signatures like this one:
11:21:59 <reygoch> doTheType :: (Monad m, Semigroup (m (Maybe (Maybe [String])))) => Validator A m B
11:23:21 <reygoch> can anyone give me some advice?
11:23:34 <dmwit> What do you want `x i <> y i` to do?
11:23:55 <reygoch> combine in what ever way
11:23:57 <dmwit> Perhaps `liftA2 (<>) (x i) (y i)` would suit your needs, and require fewer constraint annotations.
11:23:57 <glguy> \i -> x i <> y i    is     x <> y
11:24:26 <dmwit> Just `Applicative m` as opposed to `Semigroup (m (Maybe (Maybe [String])))`, e.g.
11:24:48 <dmwit> Uh. I don't believe you actually mean "just combine in whatever way". You surely have an actual desired behavior.
11:25:02 <dmwit> Or else I'm going to recommend `x <> y = x`.
11:25:07 <glguy> > (flip replicate 'a' <> flip replicate 'b') 4
11:25:09 <dmwit> Which has very few constraints indeed.
11:25:09 <lambdabot>  "aaaabbbb"
11:25:49 <reygoch> well, I want it to be generic
11:25:52 * glguy leaves dmwit to figure out what the actually behavior was supposed to be
11:26:09 <dmwit> `x <> y = x` is very generic.
11:26:14 <reygoch> x i results in m ( Maybe e )
11:26:32 <reygoch> I don't know what e will be, I just know I want to combine it
11:26:36 <reygoch> if it is possible
11:26:49 <reygoch> I'll try with liftA2
11:26:54 <reygoch> and report back
11:26:59 <dmwit> hm
11:27:09 <dmwit> I am not a fan of this development strategy. But you do you, I guess.
11:28:38 <infinisil> Reading the Lens docs..
11:28:42 <infinisil> "A strong lax semi-monoidal endofunctor"
11:28:46 <infinisil> Ah yes, I know exactly what that is
11:29:01 <maerwald> largely made-up terms I'd say xD
11:29:52 <reygoch> ok, yes, this is much better
11:29:55 <reygoch> thanks a lot
11:30:44 <reygoch> dmwit: what do you mean by this development strategy?
11:31:22 <cocreature> infinisil: huh, where did you get that from? I can’t find it anywhere in lens’ source code
11:31:45 <infinisil> Ohhh it was just linked to from Lens
11:31:55 <infinisil> It's in semigroups: https://hackage.haskell.org/package/semigroupoids-5.2.2/docs/Data-Functor-Apply.html#t:Apply
11:32:07 <geekosaur> that's abstract math terminology.
11:32:13 <infinisil> Used by Fold1 in lens: https://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Type.html#t:Fold1
11:32:37 <infinisil> semigroupoids*
11:32:42 <cocreature> well it also has an explanation that’s fairly easy to understand so it’s not too bad
11:33:32 <infinisil> Yeah, it could be worse
11:34:09 <infinisil> Speaking of worse, what the hell is this: `type Optical p q f s t a b = p a (f b) -> q s (f t)`
11:34:40 <cocreature> it’s a generalization of the various optics in lens
11:35:05 <cocreature> if you replace p and q by (->) you already get something pretty close to the definition of Lens
11:35:32 <infinisil> Hmm yeah..
11:35:59 <infinisil> Never seen so many type arguments before
11:38:21 <Psybur> % import Data.These
11:38:22 <yahb> Psybur: ; <no location info>: error:; Could not find module `Data.These'; Perhaps you meant; Data.Tree (from containers-0.5.10.2); Data.Text (from text-1.2.3.0); Data.Time (from time-1.8.0.2)
11:39:00 * hackage extensible-effects-concurrent 0.1.3.0 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.1.3.0 (SvenHeyll)
11:41:31 <geekosaur> ob i m a s t a b u
11:41:55 * cocreature runs away from geekosaur screaming
11:42:51 <geekosaur> Mar 22 17:03:50 <edwardk>	tgeeky: you get 'stab' 'pabst' and all sorts of fun combinations out of lens. i'm pretty sure i had it all but say 'i m a s t a b u'  and i walked away
11:43:16 <geekosaur> sadly that was before I added year to the log format :/
11:43:36 <zachk> whats ob mean?
11:43:45 <geekosaur> 'obligatory (reference)'
11:44:19 <zachk> oic
11:44:21 <geekosaur> that wasa bit of a joke around the channel in 2016-2017
11:44:27 <Welkin> obgyn?
11:48:18 <dmwit> reygoch: "this development strategy" = "I don't want to think about what behavior I expect, let me just write some code that typechecks and cross my fingers that it turns out to behave well."
11:50:05 <reygoch> dmwit: well, I'm collecting errors (which can be custom user errors) and if they are Semigroup I want them to combine in what ever way user envisioned
11:50:16 <reygoch> dmwit: that's what I meant
11:50:47 <dmwit> "defer to `e`'s Semigroup instance" is a fine answer, but there is also a question of what you want the `m` and `Maybe` bits to do.
11:51:08 <dmwit> I'm fairly confident that whatever you have right now... doesn't do what you want. Whatever that is.
11:51:39 <reygoch> dmwit: m is user provided monad and Maybe is error result :D
11:52:03 <reygoch> dmwit: and actually it is working so far, I'm writing a validation library
11:52:14 <dmwit> Okay. And what do you want `(<>)` to do with those monad actions and the `Maybe` result?
11:52:27 <dmwit> "Just combine them" *isn't an answer*.
11:52:32 <dmwit> There's a lot of possible behaviors.
11:52:40 <reygoch> well that is for user to decide
11:52:47 <dmwit> And writing a `Semigroup` instance amounts to choosing one of those behaviors.
11:53:01 <dmwit> No, it is for you to decide, because you are writing the Semigroup instance for `MyType`.
11:54:11 <reygoch> hm... not sure what you are referring to... if user doesn't provide `Semigroup e` than he can't use Semigroup instance of MyType
11:54:18 <reygoch> and that is just a wrapper
11:54:25 <dmwit> User must decide how to combine `e`s: I'm on board. User must decide how to combine `Maybe e`s: I am not on board. Decide what you want to happen to `Nothing`s once and for all.
11:54:55 <dmwit> User must decide how to combine `m (Maybe e)`s: I will throw out the library and write my own.
11:55:22 <reygoch> oh.. that is decided by me already
11:55:30 <dmwit> User must decide how to combine `i -> m (Maybe e)`s: I will petition to have it removed from Hackage with blunt force. =P
11:55:31 <reygoch> only e is questionable
11:55:43 <reygoch> I think you misunderstood me
11:56:22 <dmwit> I don't think I did. Because you were happy to move from `x i <> y i` to `liftA2 (<>) (x i) (y i)` without a second thought. But those two *behave very differently*.
11:56:24 <reygoch> btw, is it possible to write two instances for the same type but different constraints?
11:56:33 <dmwit> And there are other choices which also typecheck with yet other behaviors.
11:56:55 <reygoch> I tested it and it did what I intended
11:57:17 <reygoch> like, I tested an example
11:57:24 <reygoch> not just if it type checked
11:59:36 <reygoch> dmwit: I'd like to bother you just a wee bit more :D
11:59:48 <reygoch> dmwit: is it possible to do something like this : https://lpaste.net/955565051526250496
12:00:04 <dmwit> No.
12:00:29 <reygoch> I mean, obviously not with type classes but maybe some clever roudabout way?
12:01:03 <dmwit> You can make a newtype, or you can construct and pass dictionaries explicitly without using typeclasses at all.
12:02:23 <reygoch> hm.. I think I'll check out dictionary approach. Thanks for advice!
12:03:33 <dmwit> I mean, for `Semigroup` in particular the dictionary is quite small. You are essentially just constructing and passing around an `X -> X -> X` function for some `X`.
12:36:30 * hackage xml-html-conduit-lens 0.3.2.4 - Optics for xml-conduit and html-conduit  http://hackage.haskell.org/package/xml-html-conduit-lens-0.3.2.4 (MatveyAksenov)
12:52:03 <Psybur> @hoogle Maybe a -> Option a
12:52:04 <lambdabot> Data.Semigroup Option :: Maybe a -> Option a
12:52:04 <lambdabot> Intro Option :: Maybe a -> Option a
12:52:04 <lambdabot> Data.Semigroup getOption :: Option a -> Maybe a
13:20:58 <rpme> Hi, I just tried to update cabal with cabal install cabal-install and it fails during building the hackage-security dependency. From what i can see it´s due to the new syntax used in the hacakge-security.cabal file
13:21:23 <rpme> any idea how to workaround this?
13:23:17 <rpme> here is the log https://pastebin.com/bXDGykUb
13:24:30 * hackage libstackexchange 0.3.1 - StackExchange API interface  http://hackage.haskell.org/package/libstackexchange-0.3.1 (MatveyAksenov)
13:25:15 <cocreature> rpme: no idea what your error means but you could try the bootstrap script for cabal-install to avoid relying on your existing installation
13:26:18 <cocreature> it doesn’t look like the error you’re seeing is related to the warning about build-tool-depends
13:26:30 * hackage siphon 0.8.1 - Encode and decode CSV files  http://hackage.haskell.org/package/siphon-0.8.1 (andrewthad)
13:26:58 <rpme> cocreature: ok, will try this. thanks
13:28:10 <sclv> hmm: https://github.com/haskell/cabal/issues/5203
13:28:17 <sclv> its not new syntax i think
13:28:39 <cocreature> the build-tool-depends warning is due to new syntax, it’s just unrelated to the error
13:29:01 <Hjulle> I'm trying ghcid and it keeps tells me "All good" even after I change that I loaded to include obvious type errors or even syntax errors. I used "ghcid path/to/Module.hs --reload=path/to/Module.hs" and it tells me "Reloading" and then "All good" every time I change the file. What am I doing wrong/missing?
13:29:34 <sclv> it looks like template-haskell got into a bad state somehow
13:42:21 <dmwit> Hjulle: Are you definitely writing to path/to/Module.hs?
14:00:13 <Hjulle> dmwit: Yes. Otherwise it wouldn't have auto-reloaded.
14:15:05 <butterthebuddha> Is there a source of exercises or the like for getting familiar with the reader/writer/state monads?
14:19:05 <maerwald> they all just hide function arguments in one way or another :)
14:36:25 <imjacobclark> could anybody help me with converting a simpleHttp request body to  a string?
14:36:28 <imjacobclark> https://pastebin.com/nXFYieX3
14:36:50 <imjacobclark> getting the following error and cant find much docs anywhere
14:36:51 <imjacobclark> Ambiguous type variable ‘m0’ arising from a use of ‘print’ prevents the constraint ‘(Show (m0 Data.ByteString.Lazy.Internal.ByteString))’ from being solved.
14:37:58 <pavonia> You probably want "getHaskell >>= print"
14:38:02 <dmwit> imjacobclark: Without testing, I would guess you probably intended to write `getHaskell >>= print`.
14:38:18 <imjacobclark> indeed but i'd like to _return_ the string from the function
14:38:23 <imjacobclark> as id like the pass the string to  another function
14:38:37 <dmwit> I don't understand why that's a problem.
14:38:52 <imjacobclark> it isn't i  just  don't know how  to do it
14:39:05 <imjacobclark> wouldn't getHaskell >>= print  just  print to stdout
14:39:18 <dmwit> Sure. But `getHaskell >>= f` would pass it along to `f` instead of `print`.
14:39:28 <imjacobclark> oh i see
14:39:35 <imjacobclark> would it pass  it  as a String?
14:39:51 <dmwit> I don't think so. From the docs, `simpleHttp :: MonadIO m => String -> m ByteString`.
14:39:55 <dmwit> So it's a `ByteString`.
14:40:05 <imjacobclark> okay - that could work
14:41:16 <imjacobclark> That worked
14:41:22 <imjacobclark> Fantastic, thanks  dmwit and pavonia
14:53:00 * hackage sws 0.4.2.0 - A simple web server for serving directories.  http://hackage.haskell.org/package/sws-0.4.2.0 (DerekElkins)
14:53:11 <imjacobclark> another questino - how can i convert a bytestring to a string?
14:53:20 <imjacobclark> I tried `bytecodeToString string = T.unpack string` where T is `import qualified Data.Text as T`
15:02:30 <zachk> imjacobclark, Data.Text and Data.ByteString provide two different string types, they are different from each other, just import the proper Data.ByteString qualifed as BS or what have you and use BS.unpack instead of T.unpack
15:03:06 <imjacobclark> zachk: so i tried import qualified Data.ByteString.Lazy as L
15:03:14 <imjacobclark> doing bytestringToString string = findNewsroundLinks (L.unpack string)
15:03:22 <imjacobclark> i get the error Couldn't match type ‘GHC.Word.Word8’ with ‘Char’
15:03:41 <zachk> I actually ran into this today
15:04:08 <zachk> you want: import qualified Data.ByteString.Lazy.Char8 as BSL if you want lazy bytestrings
15:04:31 <imjacobclark> zachk: so this is the full code  https://gist.github.com/imjacobclark/f45739924f4e3057eccd89cc3b185119
15:05:41 <zachk> just put that .Char8 after lazy and it should work
15:06:00 * hackage persistent-migration 0.0.2 - Manual migrations for the persistent library  http://hackage.haskell.org/package/persistent-migration-0.0.2 (brandonchinn178)
15:06:04 <zachk> imjacobclark, have you thought of using tagsoup to scrape the html you download for tags? it's rather nice
15:06:12 <imjacobclark> zachk: ah cool im a step further now
15:06:32 <imjacobclark> i have but im new to  haskell and im just trying to see if i can rewrite something i did in bash lol
15:10:34 <jle`> ddellacosta: yes, you can witness it by writing functions `split :: NonEmpty a -> (a, [a])`, and `unsplit :: (a,[a]) -> NonEmpty a`, where `split . unsplit  = id` and `unsplit . split = id`
15:10:50 <ddellacosta> jle`: awesome, thanks!
15:11:04 <ddellacosta> jle`: great piece (so far, not done yet) btw
15:11:16 <ddellacosta> really enjoying it
15:12:19 <jle`> thanks :)  glad you're enjoying it
15:12:34 <jle`> thanks for bringing this up though, i just edited the post with a clarification
15:14:49 <dysoco> Hello I have a coding style question. Let's say in my code I use (x:xs) as parameter for lists. Should I use it even if I don't use the head and tail for the sake of simplicity or should I use simply 'l' for example?
15:15:03 <dysoco> s/simplicity/consistency
15:15:08 <jle`> if you don't use a binding, you should not give it a name
15:15:19 <jle`> using _ acts like a wildcard pattern
15:16:03 <dysoco> I mean like
15:16:14 <fishythefish> similarly, if you need to refer to the list but you don't need to deconstruct it, just bind it to a single variable
15:16:19 <dysoco> doSomething (x:xs) = doOtherThing (x:xs) vs doSomething l = doOtherThing l
15:16:23 <dysoco> oh ok
15:17:18 <dysoco> Also what's your position on 'where' clauses? do you use them heavily or only when things start to get messy?
15:17:45 <jle`> dysoco: those two are different things
15:17:55 <jle`> your first version will fail if given []
15:18:12 <dysoco> oh interesting
15:18:20 <jle`> i'd probably write the first version was doSomething xs@(_:_) = doOtherTHing xs
15:18:27 <jle`> if i wanted to restrict it to only non-empty lists
15:18:49 <dysoco> I don't know what the @ means but we're not allowed to use anything not used in class so I'll stick with (x:xs) and l for this at least
15:18:51 <jle`> an "as-pattern" is a good way to restrict based on a pattern, but not care about the contents of the fields
15:18:55 <dysoco> I've seen it in a couple of places
15:19:12 <fishythefish> it's also common to write the empty list case first, so in that case, you can have `doSomething [] = doFirstThing; doSomething xs = doSecondThing xs`
15:19:27 <jle`> i also would probably not do that in general
15:19:42 <jle`> for lists it's fine, but it can cause problems in maintenance if you have a data type you cange
15:19:44 <jle`> *change
15:19:51 <fishythefish> for larger data types, this has maintainability concerns though
15:19:57 <fishythefish> gah, jle` beating me to the punch as usual
15:20:02 <jle`> ah, sorry :)
15:21:07 <sm> use where (or let) if they seem to make the code clearer, and if the declarations aren't useful outside the current scope
15:22:53 <sm> though when developing, declarations at module level can be easier to troubleshoot
15:25:38 <dukedave> If I have some higher order type `Loop a`, can I define `Eq Loop`-but-only-if `a` is `Eq` ?
15:25:59 <jle`> not in a sane way
15:26:20 <acertain> is there any way to get ahold of the types in a GADT without a Proxy argument or a helper function? like given `data Foo a where Foo :: forall a. Num a => Foo a`, `f (Foo @a) = ... @a ...`?
15:26:27 <nitrix> I believe that'd require existential types?
15:26:46 <jle`> dukedave: there are some sort of weird ways that can easily cause incoherent or breaking code
15:27:18 <jle`> dukedave: (also note that neither `Loop a` or `Loop` are considered higher-order types)
15:27:44 <jle`> acertain: you can use ScopedTypeVariables
15:27:44 <nitrix> dukedave: data SpecialLoop = forall a . Eq a => SpecialLoop a
15:28:21 <dukedave> jle`: Oh? I thought higher order was just any type with a kind with arrows in it? :)
15:28:35 <jle`> first order are when you have a -> b
15:28:41 <jle`> higher order is (a -> b) -> c
15:28:59 <dukedave> jle`: ah, gotcha, thanks for clarifying!
15:29:06 <jle`> no problem :)
15:29:17 <jle`> but yeah, there are some silly ways, but usually nothing i'd use seriously
15:29:26 <jle`> unless you know what sort of rabbit hole you are going down
15:29:38 <dukedave> nitrix: would that prevent me from writing `SpecialLoop TypeNotImplmentingEq`?
15:30:00 <jle`> in which case there are a lot of odd and quirky ways to abuse haskell's type system and/or ghc plugins to emulate what you want
15:30:05 <nitrix> dukedave: Notice the kind of SpecialLoop, it's not parametric.
15:30:21 <jle`> dukedave: do you have a use case for this type?
15:31:24 <nitrix> dukedave: The constraint `Eq a` requires that the kind of `a` be `*`. The `SpecialLoop` I created has the kind `*`, your `Loop a` has kind `* -> *`.
15:32:16 <dukedave> jle`: I'm iterating on this https://wiki.haskell.org/Tying_the_Knot to create a data structure which represents a track in this game: https://boardgamegeek.com/boardgame/150/pitchcar
15:32:47 <jle`> actually hm
15:32:51 <jle`> i misread your original question
15:32:54 <jle`> it's actually extremely simple
15:33:01 <jle`> you just need to define `Eq a => Loop a`
15:33:14 <jle`> so `Loop a` will only have an Eq instance if a does :)
15:33:34 <jle`> it's similar to the Eq instance for (Maybe a)
15:33:35 <dukedave> Oh yeah, that's what I was hoping for. So, you can do that?!
15:33:43 <jle`> yeah :)
15:33:52 <jle`> actually usually that's the default derived instance
15:33:56 <jle`> instance Eq a => Maybe a where
15:34:13 <nitrix> data Loop a = .... deriving (Eq)
15:34:22 <jle`> sorry, totaly misread originally :)  this is a very common thing
15:40:50 <boj> give a library A, which has a sub-library B that does ../src in hs-source-dirs, and then a project C which imports sub-library B, i get a build error saying it can't find that relative ../src path (it works if i hardcode a static path). how do i get around this?
15:41:59 <glguy> boj: Can you put the relevant cabal files on a pastebin?
15:42:21 <glguy> Why are these libraries depending on B's source files instead of its package?
15:43:34 <boj> A is a microservice, B is a servant-client which exports a sub-set of A to be consumed by unrelated project C without incurring unnecessary build dependencies from A
15:44:33 <glguy> so B should be a package that A and C depend on ?
15:45:04 <dukedave> nitrix: jle` : Thanks! I can't believe `deriving` is that smart, very cool
15:45:05 <boj> B is a package that C depends on
15:45:46 <boj> B itself depends on the src from A to re-export a few things, so it has hs-source-dirs: src ../src
15:46:38 <boj> when C goes to build, it sees that B is a dependent library and goes to build it. if the ../src is changed to a static path it works, the relative path is unfound otherwise
15:52:38 <nitrix> dukedave: Your use case is actually trivial. Sorry, I originally misunderstood you as well, throwing existential quantification at you :]
15:53:13 <ZeuPiark> bye
15:53:43 <nitrix> I'm baffled that no-one corrected me on "your `Loop a` has kind `* -> *`". Should have been `*`.
15:54:39 <nitrix> Man, I miss Haskell :(
15:54:47 <dstolfa> nitrix: so use it again! :)
16:02:05 <dmwit> boj: I'm with glguy. You should put whatever B is using from ../src in B proper, and have A depend on B.
16:02:54 <boj> ok, i see. i'll give that a shot, thanks
16:05:29 <dmwit> (More to the point, I'm pretty sure cabal does not allow source directories to go farther up the directory tree than the cabal file is.)
16:06:41 <boj> it works if you build within the project directory itself, but yeah, goes south if you build from an unrelated location
16:39:33 <nitrix> Does type inference always work from bottom-up? From the most generic type, `forall a. a`, then it gets constrainted as `forall a. C a => a`, where `C a` is a dictionary of types. With two constraints, `forall a. (C a, D a) => a`, they seem to act like an intersection of both set.
16:40:15 <nitrix> Does it always work that way are they other ways inference could work (possibly not by constraining and doing set intersections) ?
16:40:46 <nitrix> Sorry for the poorman terminology, I lack the theory and venturing in the unknown here (:
16:41:24 <nitrix> s/are they/or there/
16:43:42 <hpc> nitrix: i don't think i can answer your question perfectly for class constraints
16:43:53 <hpc> nitrix: but what you probably want to search for is "unification"
16:44:22 <hpc> basically, types and values build up a system of equations that then gets solved
16:44:42 <hpc> a = (b, c)
16:44:50 <hpc> b = (c, Int)
16:45:05 <hpc> c = Bool
16:45:09 <hpc> a = you get the point ;)
16:45:48 <hpc> :t let {a = (b, c); b = (c, 5); c = True} in a
16:45:49 <lambdabot> Num b => ((Bool, b), Bool)
16:46:03 <nitrix> Right. I'm guessing the way that bubbles down and gets solved efficiently is where algorithms like Hindley-Milner kicks in.
16:47:21 <hpc> H-M isn't a specific algorithm
16:47:34 <hpc> saying "H-M algorithm" is a bit like saying "tree balancing algorithm"
16:48:03 <hpc> i don't know that there's a name for ghc's implementation of type inference
16:48:14 <nitrix> I have this makeshift visual programming language without type classes, but I am playing with the idea of introducing polymorphism, still without introducing type classes.
16:48:29 <hpc> (which, type inference is subtly different from unification)
16:48:30 <nitrix> So no parametric polymorphism, just some poor ad-hoc function overloading.
16:48:53 <nitrix> And I was wondering if just some poor ad-hoc function overloading, I'm able to do type inference.
16:49:02 <hpc> (er actually ignore that)
16:49:46 <hpc> oh, yeah
16:49:56 <hpc> sounds like you're making something like https://en.wikipedia.org/wiki/System_F#System_F%CF%89
16:50:05 <nitrix> You know, you gather all the different signatures possible for that function that's overloaded, then infer all the stuff in the callers using that function... everything gets its own little dictionary of possible types.
16:50:19 <hpc> type classes are where all the hard type system stuff is anyway
16:50:43 <hpc> nitrix: don't think in terms of sets, think in terms of equations
16:50:50 <nitrix> But then, choosing a type for an argument might have impacts on the options you have left for another argument so it gets really messy :(
16:50:56 <nitrix> hpc: Oh?
16:51:17 <hpc> so, maybe an example will help
16:51:29 <nitrix> hpc: Actually you're totally right.
16:51:34 <hpc> let's imagine that T(a) means "the type of a", just so i can keep unique symbols everywhere
16:51:50 <hpc> and use {a = (b, c); b = (c, 5); c = True} as the value level
16:51:52 <nitrix> hpc: You write down the equations and as you learn about the concrete types, some of the equations becomes solved and you have less unknowns.
16:51:56 <hpc> True :: Bool
16:52:13 <hpc> b = (c, 5) creates the equation T(b) = (T(c), Int)
16:52:21 <hpc> and so forth
16:52:34 <hpc> don't even think about simplifying the equations
16:53:11 <hpc> just get the whole set of type-level equations from looking at the value-level equations
16:53:22 <hpc> and then put it into the solver of your choice
16:53:24 <hpc> pure math :D
16:53:46 <nitrix> hpc: Since it's a visual programming language, it'd be kind of cool to show the remainder of the types possible for an argument, as you pin the type of other arguments, for a given function.
16:54:24 <nitrix> Doesn't that require simplifying and/or solving the equations at some point?
16:55:48 <hpc> so like, if you don't know T(c) but still want to have the IDE do what-ifs for T(b)?
16:56:10 <hpc> maybe show the equations that still have unsolved variables (translated back to some in-language representation)
16:56:36 <hpc> have something next to it for "let T(c) = <type in here>"
16:56:47 <hpc> and run the type checker
16:57:29 <nitrix> hpc: Essentially, I want people to experience the polymorphism, by seeing this very generic function drawn, then as they connect arguments, observe the set of their possible choices shrinking for the remainder of the arguments.
16:57:30 <hpc> now you've reduced the problem to "how do i autocomplete just T(c)"
16:57:44 <hpc> which you can do by showing what's currently in scope in some filtered way
16:57:46 <nitrix> Which is why I keep thinking in sets -.-
16:57:51 <nitrix> :o
16:57:54 <hpc> assuming you're going to have a big standard library or whatever
16:58:13 <nitrix> hpc: Yeah, you pick what you import.
16:58:44 <hpc> oh, you said no parametric polymorphism, yes ad-hoc
16:58:58 <hpc> all of my advice might be totally irrelevant lol
16:59:29 <hpc> i have a very user-level understanding of how type classes work
17:00:46 <nitrix> I'll go eat and have my brain stir it all up nicely while I'm on autopilot :]
17:00:53 <nitrix> hpc: Thanks for the chit-chat :)
17:01:28 <hpc> oh!
17:01:35 <hpc> nitrix: check out agda's emacs integration sometime
17:02:27 <hpc> it's not exactly what you're thinking of, but it's quite nice regardless and maybe you'll get something from it
17:03:15 <nitrix> Noted
17:22:00 * hackage hoist-error 0.2.1.0 - Some convenience facilities for hoisting errors into a monad  http://hackage.haskell.org/package/hoist-error-0.2.1.0 (schalmers)
17:33:33 <jpgarcia> are there some good examples of all the power of haskell "dependen types" out there?
17:33:50 <jpgarcia> like HList but with modern techniques
17:34:44 <jpgarcia> I guess I'll release a good example soon, btw :)
17:36:31 <pt1973> hello world
17:37:34 <shapr> goodbye world?
17:38:50 <aarvar> jpgarcia: you mean not-dependent types?
17:41:05 <jpgarcia> I mean faking them, yes
18:10:30 <enterprisey> what does it mean when you import a module with a unit afterwards, like this: import Foo ()
18:10:56 <fishythefish> you can specify a list of things to import from a module; that's an empty list
18:11:05 <enterprisey> what's the point?
18:11:11 <enterprisey> to make a dependency for the compiler?
18:11:12 <fishythefish> it'll import typeclass instances and nothing else
18:11:20 <enterprisey> k thanks
19:00:26 <dfeuer> @ops
19:00:26 <lambdabot> Maybe you meant: pl oeis docs
19:02:39 <nitrix> dfeuer: There's #haskell-ops shall you need it.
19:04:03 <infinisil> Every once in a while I turn off irc filters (Alt-- with weechat) and am amazed how there are people who don't use them
19:07:13 --- mode: ChanServ set +o glguy
19:07:13 --- mode: glguy set +b *!*@217.64.113.52
19:08:25 <infinisil> glguy: Huh, why did they get the +b? I must be missing something
19:09:37 <shapr> silly question, "stack repl" gives me both Main and Lib in scope in ghci, but cabal new-repl exe:project does not, is there a way to get that same thing with new-repl?
19:09:56 <dfeuer> Thanks, glguy.
19:12:17 <shapr> ah, google says I can do ":module Main" in new-repl
19:50:00 * hackage hw-kafka-avro 2.0.0 - Avro support for Kafka infrastructure  http://hackage.haskell.org/package/hw-kafka-avro-2.0.0 (alexeyraga)
20:22:04 <nitrix> shapr: Try only "cabal new-repl"? I think the issue is the "exe:project" more than anything else.
20:22:33 <shapr> I tried that, only Lib was in scope
20:22:39 <nitrix> :(
20:22:45 <shapr> but :module Main works
20:22:50 * shapr shrugs
21:05:00 * hackage avro 0.3.0.5 - Avro serialization support for Haskell  http://hackage.haskell.org/package/avro-0.3.0.5 (alexeyraga)
21:11:30 * hackage hw-rankselect 0.12.0.3 - Rank-select  http://hackage.haskell.org/package/hw-rankselect-0.12.0.3 (GeorgeWilson)
22:02:33 <sigma_> is Data.HashTable.IO threadSafe ??
22:05:02 <cocreature> sigma_: no
22:05:50 <sigma_> cocreature : what about ST version of the same table "Data.HashTable.ST.Cuckoo"
22:06:11 <dminuoso> cocreature: What is the basis for that assessment?
22:07:35 <glguy> there aren't any primitives in ST for making things threadsafe, and that package does things in ST and then slams the result into IO
22:07:40 --- mode: glguy set -o glguy
22:08:04 <cocreature> dminuoso: the basis is that it relies on things like MutableArray which are not thread safe
22:08:21 <cocreature> sigma_: you can’t use ST in a multithreaded context
22:08:38 <sigma_> cocreature : what do you mean by that ?
22:09:16 <sigma_> cocreature : if no that can i put my IO hashtable into a Tvar to make it thread safe ??
22:10:02 <cocreature> sigma_: the universally quantified "s" type parameter in ST prevents you from escaping a reference created in ST to another thread
22:10:09 <cocreature> yeah putting it in a TVar is perfectly fine
22:10:15 <cocreature> or probably an MVar
22:10:47 <cocreature> since modifyTVar is not going to be enough here
22:11:12 <sigma_> cocreature : which is better sounds similar to me, just that Tvar allows atomic updates ??
22:11:38 <cocreature> but I would benchmark to see if you aren’t better off using a TVar and something like Data.Map or Data.HashMap
22:12:04 <cocreature> you need some way to block readers and other writers while you modify the HashMap in IO
22:12:26 <cocreature> for an MVar you can just use takeMVar to do so and putMVar once you’re done
22:13:16 <cocreature> but Data.HashTable is really not that fast for a lot of usecases ime and in a multithreaded context, I wouldn’t be surprised if it ends up being even slower than Data.Map or Data.HashMap
22:14:48 <sigma_> cocreature : how about how about "STMContainers.Map"
22:15:16 <cocreature> I’ve never used stm-containers so I can’t comment on the performance of that
22:15:47 <cocreature> I would start with a TVar on top of Data.Map or Data.HashMap (or Data.IntMap if you have integer keys) and see if it becomes a bottleneck
22:17:40 <sigma_> cocreature : okay everything you said make sense but i couldn't understand why Mvar would be preferred over Tvar ??
22:18:04 <cocreature> sigma_: how would you do an update of a mutable HashTable using a TVar?
22:18:54 <sigma_> but Data.Map is not mutable right >?
22:19:05 <cocreature> right, that’s why I said for Data.Map a TVar is fine
22:19:30 <cocreature> but for Data.HashTable.IO you are going to have a hard time with a TVar
22:20:05 <sigma_> ok so in a immutable context Tvars are preferable over Mvar right ?
22:21:05 <cocreature> it really depends on your usecase. MVars and TVars do not represent the same thing since MVars can be empty
22:21:21 <cocreature> also the performance varies depending on your access pattern
22:22:49 <sigma_> cocreature : last question is "STMContainers.Map" is mutable right ?
22:24:30 * hackage hw-dsv 0.2 - Unbelievably fast streaming DSV file parser  http://hackage.haskell.org/package/hw-dsv-0.2 (GeorgeWilson)
23:24:36 <sigma_> what does it mean when we say "streaming of monadic data structures."
23:36:48 <pavonia> Possibly infinitely nested monadic actions yielding a result at each level, I guess
23:37:30 <dminuoso> :t fixM
23:37:32 <lambdabot> error:
23:37:32 <lambdabot>     • Variable not in scope: fixM
23:37:32 <lambdabot>     • Perhaps you meant ‘fix’ (imported from Data.Function)
23:37:47 <dminuoso> :t mfix
23:37:48 <lambdabot> MonadFix m => (a -> m a) -> m a
23:38:04 <dminuoso> :t fix
23:38:05 <lambdabot> (a -> a) -> a
23:59:10 <charukiewicz> I'm using Servant and Persistent for a RESTful API. The data types that Persistent produces when I define my database schema are not representative of the JSON I want to send back to the API consumer. Should I define intermediary types that do? Or is this something that can be handled by writing JSON encoders?
