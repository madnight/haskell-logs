00:00:01 <dreamer_> I want to cry a bit. Okay time to learn this
00:00:14 <dreamer_> I love haskell but I 'm really not a fan of monads
00:00:29 <dysfun> i would say when using TH, monads are the least of your problems
00:00:45 <dreamer_>  ominous.
00:00:58 * dysfun has been TH free for over a year now
00:01:27 <mniip> TH is cool
00:02:02 <jackdk> Agreed, though I don't understand why that lib has a labyrinth of type synonyms - why have Foo and type FooQ = Q Foo and sometimes even type Foos = [Foo] and type FoosQ = Q Foos
00:02:22 <nshepperd> If I set RebindableSyntax and write (>>) = (+), I get this: No instance for (Num ()) arising from a do statement
00:02:26 <c_wraith> I do agree that all the FooQ type aliases for Q Foo are annoying.  why?
00:02:51 <dreamer_>  dysfun tell us about your use of TH and why you renounced it.
00:02:57 <jackdk> the helper functions in Language.Haskell.TH.Lib help a lot
00:03:27 <nshepperd> so I guess it works as expected, even though I don't know how
00:03:45 <dysfun> dreamer_: well, what i was doing isn't that interesting, but i renounced it because it was just painful and confusing
00:04:07 <dysfun> haskell is much nicer if you never TH
00:04:37 <MarcelineVQ> ymmv
00:06:05 <dysfun> also these days, there's less need than ever to use TH
00:06:11 <Ariakenom> nshepperd: what did you write, do{1;2}?
00:06:31 <nshepperd> Ariakenom: do{();()}
00:08:36 <quicksilver> on the bright side 'FoosQ' sounds like something Chandler would say, so you can always pretend you're in Friends.
00:08:57 <mniip> nshepperd, yeah I've verified that it works
00:09:20 <dysfun> quicksilver: doesn't sound right in my head.
00:10:29 <nshepperd> i can kind of see how you could do the lookup of (>>) and unify everything in the do block with it 'manually' without your head exploding
00:10:39 <nshepperd> but then I wonder how it interacts with ApplicativeDO
00:12:09 <aisqwe> how can i get the name of the list Cons in template haskell? something like lookupValueName "(:)"?
00:12:11 <nshepperd> btw, setting RebindableSyntax in an empty file then trying to write something involving strings apparently results in error: Not in scope: ‘fromString’
00:12:44 <mniip> ah
00:12:51 <mniip> I see
00:12:59 <mniip> HsDo contains a list of StmtLR
00:13:37 <nshepperd> oh wait that might just be because of my .ghci
00:13:39 <nshepperd> nvm
00:13:58 <mniip> % :i HsDo
00:13:58 <yahb> mniip: type role HsExpr nominal; data HsExpr p = ... | HsDo (HsStmtContext Name.Name) (SrcLoc.Located [ExprLStmt p]) (HsExtension.PostTc p TyCoRep.Type) | ...; -- Defined in `HsExpr'
00:14:03 <mniip> % :i ExprLStmt
00:14:04 <yahb> mniip: type ExprLStmt id = LStmt id (LHsExpr id) -- Defined in `HsExpr'
00:14:14 <dreamer_> https://lpaste.net/4394237725515972608
00:14:19 <dreamer_> whats wrong with this
00:14:40 <mniip> and constructors in StmtLR have an additional field:
00:14:44 <mniip> % :i LastStmt
00:14:44 <yahb> mniip: type role StmtLR nominal nominal representational; data StmtLR idL idR body = LastStmt body Bool (SyntaxExpr idR) | ...; -- Defined in `HsExpr'
00:14:55 <dreamer_> when I call it like that $(loadPiece "w" "b") (for white bishop, basically it gets the image for a chess piece)
00:14:56 <mniip> SyntaxExpr
00:14:58 <dreamer_> I get
00:15:06 <dreamer_> Couldn't match type `Language.Haskell.TH.Syntax.Dec'                      with `[Language.Haskell.TH.Syntax.Dec]'
00:15:09 <dreamer_> ??
00:16:02 <mniip> so when a do block is parsed, the parser sticks in a simple ">>=" in there,
00:16:26 <mniip> then the renamer either renames it to GHC.Base.>>= or if RebindableSyntax is on, the right identifier
00:16:46 <mniip> then the typechecker typechecks the do-block filling in the type of this specific SyntaxExpr
00:16:51 <aisqwe> how can I get the name of the cons operator of List type in template haskell?
00:17:22 <Ariakenom> For no particular reason, what are the ways to include a binary file into my program?
00:17:29 <mniip> aisqwe, '(:)
00:18:12 <mniip> Ariakenom, convert the binary into an object file and then ffi-import it as a char array
00:20:02 <cocreature> file-embed also works for binary data
00:21:59 <cocreature> dreamer_: can you show us the full error?
00:22:17 <aisqwe> mniip: could you elaborate a little on the '(:), i see promotedCons in the Type section but how do i get the name?
00:24:12 <cocreature> dreamer_: the problem is probably that top level splices must have type Q [Dec] whereas you have a Q Dec
00:24:21 <mniip> % :t '(:)
00:24:21 <yahb> mniip: Language.Haskell.TH.Syntax.Name
00:24:46 <dreamer_> uh
00:24:54 <dreamer_> so how would I go around resolving that
00:25:21 <dreamer_> the full error is indeed that
00:25:48 <dreamer_> https://lpaste.net/8878976532287062016
00:25:58 <cocreature> you can use "fmap (\x -> [x])" to go from Q Dec to Q [Dec]
00:26:43 <mniip> return <$> loadPiece
00:26:55 <dysfun> fmap (:[]) should work too
00:27:04 <mniip> :[]
00:27:06 <cocreature> dreamer_: btw what is your underlying goal here? it seems like you are still fairly new to Haskell so it seems kind of surprising that you are already reaching for TH. maybe there is a better solution here?
00:27:26 <Lokathor> oh my gosh i open #haskell for the first time in ages and two of my favorite #haskell pals are right here
00:27:30 <aisqwe> mniip: thanks , i got it now
00:27:46 <Lokathor> (a "haskell pal" is here defined as any username i recognize at all)
00:28:27 <Ariakenom> :t fmap pure
00:28:28 <lambdabot> (Functor f2, Applicative f1) => f2 a -> f2 (f1 a)
00:28:42 <mniip> is "favourite haskell pal" an atomic notation too
00:29:10 <Lokathor> yes
00:29:14 <Lokathor> Friends, how can i force stack to keep all of its files not in my APPDATA directory on windows?
00:29:49 <Lokathor> this is the first time i've seriously tried to install stack in like 2 years, i did the other day and it dumped all sorts of files in APPDATA instead of the D drive i tried to tell it to use
00:32:01 <dreamer_> cocreature : my goal is to create values wp wb wr bp bb br etc... that contain the chess picture instead of doing it by hand
00:32:23 <dreamer_> I'm.. not so new to haskell. but I never touched template haskell before. so I 'm trying to use it
00:32:42 <dreamer_> chess piece pictures*
00:32:52 <cocreature> how many of those values are there?
00:33:12 <dysfun> dreamer_: however, do you need it? generics are very powerful these days
00:34:04 <dreamer_> want to learn anyway, but if there's a better way do show me
00:34:14 <dreamer_> not so many.
00:34:23 <cocreature> then I wouldn’t bother trying to use TH for his
00:34:25 <cocreature> *this
00:34:29 <dreamer_> twelve
00:34:38 <dreamer_> yes but then how would I know how to use it later huh
00:34:39 <cocreature> chances are that the boilerplate for the TH is larger than the boilerplate of defining these manually
00:35:13 <dreamer_> I m proceeding in a need to learn priority not in a need to use
00:36:59 <cocreature> ah ok, if your goal is learning TH then avoiding it is obviously not going to cut it :)
00:37:13 * hackage hmatrix-backprop 0.1.2.3 - hmatrix operations lifted for backprop  http://hackage.haskell.org/package/hmatrix-backprop-0.1.2.3 (jle)
00:37:40 <dreamer_> anway, it works ! I didn' t think of using fmap rly %)
00:40:29 <dreamer_> interested in generics tho dysfun, what did you mean ?
00:42:27 * hackage DOH 0.1.3.0 - Complete API bindings for DigitalOcean API V2  http://hackage.haskell.org/package/DOH-0.1.3.0 (yigitozkavci)
00:44:41 <dysfun> dreamer_: it depends upon your problem, but i find often people reach for TH when generics would do
00:46:46 <cocreature> generics can’t eliminate the boilerplate of defining multiple top-level definitions. they can however shorten the individual definitions
00:54:26 <khilan> Hello! I'm trying some basic functions with images and am facing some difficulties in slicing an image. I want to implement the function as in psudocode <https://lpaste.net/2158638283658100736> and have tried <https://lpaste.net/8637509115809103872> . I'm facing some runtime errors (mostly becoz of line 59). Can someone plz help me figure out how can I do it better?
00:56:00 <dreamer_> how do you concat Monaded lists
00:56:34 <dreamer_> my problem now is that the top level splice is too nested
00:57:59 <cocreature> :t liftA2 (++)
00:58:01 <lambdabot> Applicative f => f [a] -> f [a] -> f [a]
00:58:10 <dreamer_> I tried this lol fmap (\[x] -> x)
00:58:55 <dminuoso> dreamer_: That doesn't exactly concat it, it just extracts the first element. It's equivalent to `fmap head`
00:59:05 <[exa]> dreamer_: why not 'fmap concat' ?
00:59:10 <dreamer_> oh RIGHT
00:59:22 <cocreature> dreamer_: it’s not, it crashes for non-singleton lists
00:59:28 <dreamer_> yeah noticed
00:59:30 <dreamer_> WHEW
00:59:31 <dreamer_> ok
00:59:37 <cocreature> eh that was for dminuoso
00:59:48 <dminuoso> cocreature: Oh right, its even worse heh
01:00:14 <dreamer_> ok it works fine now
01:00:31 <dreamer_> my issue is not TH really just lack of knowledge about monads
01:00:42 <dreamer_> because I usually go out of my way to sidestep them
01:00:50 * hackage DOH 0.1.4.0 - Complete API bindings for DigitalOcean API V2  http://hackage.haskell.org/package/DOH-0.1.4.0 (yigitozkavci)
01:00:59 <cocreature> that’s not going to get you very far in Haskell :)
01:01:42 <dreamer_> Yeah, I noticed..
01:02:04 <cocreature> luckily, they are also not nearly as scary or complicated as you might think!
01:02:06 <dminuoso> You're learning TH before you grasped monads?
01:02:14 <dminuoso> One of these is scary. The other is not. :<
01:04:18 <dreamer_> I swear I look at monadic code I want to curl up
01:04:34 <alexad> So, just out of curiosity, what's the general practice if a package on hackage is going unmaintained and one wants to fork and update it?
01:04:56 <Boomerang> Mmmh, how do you use TH without using the Q monad?
01:06:15 <cocreature> alexad: https://wiki.haskell.org/Taking_over_a_package
01:06:24 <cocreature> dreamer_: that feeling goes away once you stop trying to avoid them :)
01:06:51 <dminuoso> Monads make me feel warm and fuzzy.
01:06:58 <dminuoso> I dream of them from time to time..
01:07:07 <[exa]> monads are like blankets, nice for wrapping
01:07:24 * [exa] avoids burritos!
01:07:42 <cocreature> l
01:07:44 <cocreature> ups
01:07:50 <cocreature> [exa]: but they can also make you hot and sweaty? :)
01:09:24 <[exa]> mmmmmm :]
01:09:49 <alexad> cocreature, thanks as always
01:10:16 <alexad> it's nowhere near the "take over" period, but it's good to know there's a way to do it if I find I need to maintain this thing a fair bit
01:10:25 <alexad> for now I'm using git submodule instead of the hackage copy :(
01:11:01 <cocreature> well if you do intend to take it over start by sending the maintainer an email
01:11:14 <guessWHo> when i run this https://lpaste.net/8532562311485849600 i get Statsd.hs: getCurrentDirectory:getWorkingDirectory: resource exhausted (Too many open files in system)
01:11:36 <gonz_> dreamer_:  Monads will allow you to control exactly which scary actions you/people can execute. It's an opportunity for safety and much clearer specifications for what functions can do.
01:12:25 <[exa]> guessWHo: what's Statsd? Does it have any reason for not closing file descriptors?
01:12:54 <guessWHo> [exa] : it
01:13:16 <guessWHo> [exa] : it's a haskell lib to send metrices to statsd server https://github.com/tibbe/ekg-statsd
01:13:29 <kuribas> gonz_, dreamer_: not only that, they also apply to many domains, like non-deterministic programming, parsers, etc...
01:14:54 <kuribas> not just simulating effectful programming.
01:16:04 <[exa]> guessWHo: you can try to bump the limit a bit using ulimit (some systems have fd limit ridiculously low now)
01:16:32 <guessWHo> [exa] : i think i got it i was using the exposed function in a wrong manner
01:17:09 <[exa]> guessWHo: otherwise forking new sockets every second without checking if the previous one has terminated can DoS you quite easily
01:19:24 <alexad> cocreature, yeah, we'll see. if I end up adding a bunch more to the fork I'll poke the guy if he doesn't start accepting PRs
01:19:37 <cocreature> gonz_: Monads don’t allow you to do that, IO does. the fact that IO is an instance of Monad is mostly orthogonal to that
01:22:05 <gonz_> cocreature:  Creating your own monad stacks most definitely will let you do something akin to that.
01:22:45 <dminuoso> gonz_: Monad is just an abstract interface, like Monoid.
01:22:49 <cocreature> gonz_: sure but the fact that you can isolate effects still has only little to do that the resulting type will be an instance of Monad
01:22:55 <dminuoso> It doesn't have any instrinstic meaning other than the laws it requires.
01:23:08 * mniip . o O ( technically a monad *is* a monoid)
01:24:46 <ventonegro> gonz_: The IO type makes side-effects possible. A monad is a good way of combining functions that return IO types
01:25:55 <gonz_> I was giving dreamer_ an example of something he could do if he stopped avoiding/sidestepping monads in practice all the time
01:26:08 <dreamer_> what other way to do IO are there in haskell besides monads tho
01:26:12 <gonz_> The fact is if he learns how to use them he'll then be set to use something like mtl to make these things possible
01:26:23 <dreamer_> I want to learn how to use them ofc
01:26:38 <dreamer_> but the fact remains that I have been a monadcoward for a long time
01:26:43 <cocreature> dreamer_: you don’t “do IO with monads”. you use the IO type which happens to be an instance of Monad
01:27:12 <dreamer_> ok, do side effects then if you prefer.
01:28:23 <ventonegro> dreamer_: If you manually thread the state through pure functions to enforce sequencing in a pure functional languages, you will invent monads again
01:28:35 <ventonegro> language*
01:29:42 <ventonegro> dreamer_: Don't try to "learn monads" at first
01:29:56 <dreamer_> I'm not trying to learn monads it's more like
01:29:56 <ventonegro> First try to sequence functions that return Maybe types
01:30:02 <dreamer_> I want to do this
01:30:07 <dreamer_> ok you need to use this monadic lib
01:30:09 <dreamer_> ok I will
01:30:13 <ventonegro> Then try to sequence functions that return Either types
01:30:38 <ventonegro> Eventually you will see a pattern
01:30:57 <ventonegro> This pattern is what you want to learn
01:31:43 <kuribas> IMO monadic bind, apply and fmap are just generalisations of function application.
01:31:53 <kuribas> With different use-cases
01:32:04 <[exa]> you mean specializations
01:32:08 <dminuoso> dreamer_: Monad is just an abstract interface like Functor or Monoid. Again, it has no intrinsic meaning like "side effects" or anything. It's just an interface of two functions with some laws.
01:32:14 <kuribas> [exa]: no generalisations
01:32:56 * hackage HNumeric 0.5.0.2 - Haskell Numeric Library with pure functionality, R & MATLAB Syntax.  http://hackage.haskell.org/package/HNumeric-0.5.0.2 (edeftg)
01:32:58 <kuribas> [exa]: function application is fmap or (=<<) over the identity monad.
01:33:43 <cocreature> that seems like a weird way to look at it given that using fmap involves function application
01:34:13 <kuribas> cocreature: well, upto isomorphism :)
01:34:15 <dreamer_> I understand that dminuoso
01:34:26 <dreamer_> ventonegro I will follow your advice
01:34:26 <[exa]> it's certainly a very different view from the type-systemish one
01:34:34 <[exa]> kuribas: but yeah makes sense that way
01:35:10 <kuribas> ($) :: (a -> b) ->   a ->   b
01:35:37 <kuribas> fmap :: Functor f => (a -> b) -> f a -> f b
01:36:53 <dminuoso> And applicative generalizes to multi arg functions =0
01:36:57 <cocreature> you definitely have a point here. I just feel slightly uneasy about using the word “generalization”
01:37:33 <dminuoso> :t liftA2 (,)
01:37:35 <lambdabot> Applicative f => f a -> f b -> f (a, b)
01:37:42 <[exa]> de-special-case-ization
01:37:48 <kuribas> cocreature: superset?
01:38:00 <cocreature> kuribas: not sure, still thinking about what I would call it :)
01:38:25 <[exa]> parametrization maybe
01:38:31 <kuribas> expansion
01:38:42 <kuribas> it expands the capabilities of pure functions
01:40:39 <Ariakenom> Pure functions can express any computation though.
01:41:21 <dminuoso> kuribas: not sure how (=<<) fits into this though
01:41:41 <dminuoso> although I suppose in a way
01:41:43 <dminuoso> :t (.)
01:41:44 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:41:46 <dminuoso> :t (<=<)
01:41:47 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
01:41:56 <Ariakenom> And "Applicative f => f a -> f b -> f (a, b)" is a special case of "a->b->c"
01:42:19 <kuribas> dminuoso: that's composition
01:42:24 <dminuoso> kuribas: Yeah
01:43:18 <kuribas> :t (=<<)
01:43:19 <lambdabot> Monad m => (a -> m b) -> m a -> m b
01:43:24 <kuribas> :t ($)
01:43:25 <lambdabot> (a -> b) -> a -> b
01:43:41 <kuribas> dminuoso: substitute Identity for m, and you get application
01:43:41 <dminuoso> kuribas: thats just not symmetric anymore.
01:43:48 <dminuoso> mmm
02:30:22 <ongy> Is it cheaper to store an IO () with `pure ()`, or Maybe (IO ()) Nothing when I want to potentially (most of the time) execute nothing?
02:32:22 <AWizzArd> Is it common to have one single file  Types.hs  in which one adds all type declarations for the whole project?
02:32:40 <ongy> It can be necessary, if you have cyclic data structures
02:33:00 <ongy> I'd try to avoid it, since it's a bit annoying to work with, but it's not too uncommon IME
02:33:38 <AWizzArd> ongy: if you would have such a file would you also add implementations of type classes in there, such as a hand-baked implementation of Show?
02:33:51 <AWizzArd> Or should those implementations go into different files, style-wise?
02:34:52 <ongy> if you put them into other files you get orphan instances, so I generally place them in the same file.
02:34:54 <Taneb> AWizzArd: I'd say the instances should live with the types as much as possible
02:37:32 <thblt> With recent Stack, which are the files I need to have in version control?  I assume package.yaml and stack.yaml (for the resolver), MyPackage.cabal being just a byproduct?  Or do I even need stack.yaml?
02:38:18 <dminuoso> thblt: The stack.yaml contains information for stack, such as the the resolver/packages/extra-deps and other things.
02:38:54 <MRd1> Hello
02:39:55 <thblt> dminuoso: thanks, so I need these two, but not the .cabal, right?
02:40:17 <dminuoso> thblt: Correct.
02:40:22 <thblt> dminuoso: thank you!
02:40:51 <dminuoso> thblt: I think the package.yaml is just a different format used by hpack to generate the .cabal file from.
02:45:57 <thblt> That's what I assumed indeed.
02:46:51 <thblt> (minus the hpack, I thought it was stack's idea :)
02:48:11 <AWizzArd> ongy and Taneb: good, thx for the feedback.
02:49:40 <Taneb> :)
02:51:53 <dminuoso> thblt: Stack has hpack builtin so.. :)
03:13:31 <cocreature> stack has hpack builtin but hpack works perfectly fine without stack. stack just calls hpack for you if the package.yaml has changed to automatically regenaret the *.cabal file
03:14:05 <cocreature> and you also don’t need to use a package.yaml with stack. stack is perfectly happy working with a cabal file
03:14:35 <dreamer_> stack is cool
03:15:36 <thblt> Is there an example somewhere of having common options with subcommands in optparse-applicative (like what Stack does).  Eg myprogram [ --verbose ] [ --simulate ] COMMAND [options]?
03:17:09 <cocreature> thblt: you can use something like liftA2 (,) commonOptions (hsubparser (command … <> command …))
03:18:48 <thblt> cocreature: thanks, looking into this
03:21:08 * hackage relational-query-HDBC 0.6.8.0 - HDBC instance of relational-query and typed query interface for HDBC  http://hackage.haskell.org/package/relational-query-HDBC-0.6.8.0 (KeiHibino)
03:27:37 <gghpo> @ty foldr ($)
03:27:38 <lambdabot> Foldable t => a -> t (a -> a) -> a
03:37:52 <Franciman> Hi
03:38:01 <Franciman> https://lpaste.net/978541477292408832 <- I'm using Pipes.Network.TCP
03:38:22 <Franciman> but this code doesn't compile because ghc doesn't support impredicative polymorphism
03:38:25 <Franciman> what is wrong?
03:40:21 <Franciman> (I put the error message in the paste above)
03:41:25 <wz1000> Franciman: Just use Producer instead of Producer'
03:42:41 <Franciman> oh thank you!
03:51:39 <dminuoso> "GHC doesn't yet support impredicative polymorphism"
03:52:19 <liste> will it ever?
03:52:28 <dminuoso> That was exactly my thought :p
03:52:45 <cocreature> you can enable an extension called ImpredicateTypes!
04:01:29 <cocreature> sometimes I really hate the module hierarchy in base …
04:02:22 <liste> cocreature: any specific bad apples?
04:02:32 <cocreature> "guard" is in Control.Monad and not in Control.Applicative even though it has nothing to do with Monad
04:02:58 <cocreature> (I know that this is due to historic reasons but that doesn’t make it better)
04:03:23 <dminuoso> cocreature: Go wild, clean up base, make a diff and hope bgamari doesn't notice the failing tests left and right?
04:03:36 <maerwald> yeah and thanks for breaking everyone elses imports
04:03:52 <maerwald> because we don't have enough breaking API already
04:03:59 <cocreature> dminuoso: the problem is that I hate the bikeshedding that acompanies changes in base way too much for me to even attempt improving something :/
04:04:22 <Ariakenom> While you're at it could you remove the pointless prefixes? Control, Data?
04:04:39 <dminuoso> Ariakenom: Where would Functor reside in?
04:04:41 <barrucadu> Just merge Control and Data
04:04:47 <dminuoso> ^- this I agree with :)
04:05:10 <dminuoso> Especially as a beginner I found it incredibly confusing why some things were in Control and others in Data..
04:05:26 <Ariakenom> I'm just starting to guess right
04:07:11 <Ariakenom> dminuoso: What do you mean? Don't remove the modules, just remove their prefixes.
04:07:37 <dminuoso> Ariakenom: So that you would have `import Functor.Contravariant` for example?
04:08:34 <Ariakenom> Seems reasonable.
04:12:02 <Profpatsch> Does fromIntegral incur a performance cost?
04:12:23 <cocreature> Profpatsch: depends on the types that you are converting between?
04:12:31 <Profpatsch> Int -> Double
04:12:34 <Profpatsch> I hope not. :)
04:13:42 <Profpatsch> urgs
04:13:49 <Profpatsch> -- | general coercion from integral types
04:13:51 <Profpatsch> {-# NOINLINE [1] fromIntegral #-}
04:13:53 <Profpatsch> fromIntegral :: (Integral a, Num b) => a -> b
04:13:55 <Profpatsch> fromIntegral = fromInteger . toInteger
04:14:04 <Profpatsch> No rules for Int -> Double as far as I can see.
04:14:46 <cocreature> https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Float.hs#L1248
04:15:29 <Profpatsch> Ah, I was browsing GHC.Real
04:15:48 <cocreature> I just looked at what ghc -O2 spat out and grepped for the module that was in :)
04:16:03 <Profpatsch> Huh, that’s interesting.
04:16:25 <Profpatsch> Did you provide another flag?
04:16:25 <cocreature> no idea how efficient int2Double is but it does seem to use to some int2Double# primop which is hopefully pretty good
04:16:29 <cocreature> -ddump-simpl
04:16:33 <cocreature> to see the core
04:16:44 <Profpatsch> I have to remember that.
04:16:47 <cocreature> on a file containing f :: Int -> Double; f = fromIntegral
04:17:09 <cocreature> learning to read core is pretty useful if you want to see how GHC optimizes your code
04:18:18 <Profpatsch> I have to admit that I never had the desire to look at how my code optimized so far, it was pretty much just always fast enough from the start. :)
04:18:33 <cocreature> heh, good for you :)
04:21:07 <Profpatsch> int2double seems to map on a C-- prim-op.
04:21:29 <cocreature> that’s what I said above :)
04:21:41 <Profpatsch> So I suspect it is mapped to a x86 primitive or at least pretty close to that.
04:22:11 <cocreature> https://github.com/ghc/ghc/blob/master/compiler/nativeGen/X86/CodeGen.hs#L3129 should be the relevant part in the code generator
04:22:24 <Profpatsch> Ah, I wasn’t making the reference to Cmm from int2double# primop
04:22:44 <cocreature> sry should have been more clear :)
04:22:55 <Profpatsch> Are primops always related to symbols in Cmm?
04:23:06 <cocreature> although I think int2Double# isn’t actually implemented in cmm?
04:23:56 <cocreature> it seems to be converted to Int2DoubleOp which is then converted to MO_SF_Conv which is handled by the part of the code generator that I just linked to
04:25:33 <Profpatsch> Ah, and that maps to GITOD, which is an x86 float operation.
04:25:38 <Profpatsch> Nice. :)
04:25:47 <cocreature> or the sse2 stuff
04:25:56 <cocreature> not sure when that is enabled
04:26:58 <Profpatsch> I like that the comment above the x86 codegen starts with the words: “Intel, in their infinite wisdom”
04:27:00 <cocreature> apparently always on x86_64 if I read the code corerctly
04:27:05 <cocreature> *correctly
04:27:09 <Franciman> I'm trying to parse irc messages using attoparsec, and I wanted to use conduit to wire things up. But I get the results only after the connection is closed. How can I get the parse result at each parsed object?
04:27:15 <Franciman> parsed message*
04:27:23 <Franciman> get in the sense of printing, for example
04:30:36 <cocreature> Franciman: sounds like it might be a buffering issue?
04:31:04 <Franciman> maybe
04:31:29 <cocreature> maybe try using line buffering
04:31:39 <Franciman> ah you mean buffering of the output
04:31:43 <Franciman> stdoutput*
04:31:45 <cocreature> no of the input
04:32:07 <Franciman> let me try
04:32:10 <Franciman> thanks
04:35:11 <cocreature> Franciman: I’m just guessing here though. if you show us the code, someone might be able to provide more information
04:35:18 <Franciman> sure
04:35:21 <Franciman> 1 second
04:37:36 <Franciman> cocreature, https://github.com/Franciman/bouncer/blob/master/src/Main.hs
04:37:40 <Franciman> here's the main
04:38:05 <Franciman> and here's the parte regarding sockets: https://github.com/Franciman/bouncer/blob/master/src/ClientListener.hs
04:40:33 <cocreature> Franciman: the problem is that you are not using a parser that emits the items one by one but instead you parse a list and then emit all elements of that list at once
04:40:43 <Franciman> ah
04:40:45 <Franciman> ok
04:40:48 <cocreature> Franciman: try using sinkParser and remove the call to "many"
04:41:15 <cocreature> eh no conduitParser is correct, sry
04:41:26 <cocreature> but remove the "many"
04:42:01 <Franciman> ah so it automatically calls it again
04:42:10 <Franciman> I thought that it stopped when the parser finished
04:42:16 <Franciman> thanks it works perfectly!
05:01:35 <iron_houzi> Can someone please help me with my parser monad (https://github.com/ironhouzi/hstib/blob/tib_monad/src/Main.hs) - when I do `vowel A`, it works, but when I try to use `bind` like: `rago [Ra, Ga]`, I get the error: https://bpaste.net/show/fce6a459520d
05:02:31 <iron_houzi> It seems like I'm not able to get the data out of the Monad context ..
05:03:17 <lyxia> rago is not a function.
05:03:29 <lyxia> its type is Parser
05:03:45 <lyxia> use "parse"
05:04:04 <iron_houzi> I am expecting the output: [([Ra,Ga],[])]
05:04:13 <iron_houzi> ah indeed
05:05:12 <bwe> How can I cache stack dependencies with bitbucket pipelines?
05:05:16 <iron_houzi> lyxia: Wow! It was so close, I almost had it.. Thank you!
05:09:54 <iron_houzi> If Monads wraps your data in some context and represents that as an object. Do you always need an "unwrapper" function at the end of a bunch of monadic functional computation to kind of get your actual data from inside your Monad context? I know this question is a bit vague .. but please bear with me as I'm trying to learn and get an intuition for monads
05:10:41 <locallycompact> iron_houzi, more or less
05:11:17 <iron_houzi> locallycompact: appreciate you input .. what's the common way to get your Just value from a Maybe monad?
05:11:22 <Entroacceptor> iron_houzi: no, there are monads where there is no "wrapped value"
05:11:31 <Entroacceptor> what is the value of putStrLn?
05:11:44 <kuribas> iron_houzi: a parser has no wrapped value.
05:11:49 <kuribas> iron_houzi: you run the parser
05:12:26 <kuribas> Entroacceptor: ()
05:12:31 <kuribas> :-)
05:12:44 <locallycompact> iron_houzi, there are a coupleo f ways depending on if you want to handle the error case or just let it explode
05:12:52 <locallycompact> iron_houzi, so the maybe function is one http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Maybe.html#v:maybe
05:12:57 <Entroacceptor> kuribas: :P
05:13:00 <locallycompact> iron_houzi, where you supply a default value in the case of the Nothing
05:13:12 <locallycompact> iron_houzi, or fromJust if you just want a runtime explosion when a Nothing occurs
05:13:14 <iron_houzi> kuribas: .. but isn't running the parser in effect unwrapping the value from its parser context .. of course triggering the lazy evaluation ..
05:13:40 <kuribas> iron_houzi: no, there may be no value, for example a parser error
05:14:45 <kuribas> iron_houzi: It makes more sense thinking about what you can do with a Monad rather than what they are.
05:14:50 <iron_houzi> locallycompact: Thanks .. this is very helpful!
05:16:06 <iron_houzi> kuribas: At some point I'll expand from what I'm trying to establish right now .. I'll keep that in mind
05:16:19 <kuribas> iron_houzi: a monad is like a functor, but it can remove the extra layer
05:16:37 <kuribas> :t \f -> join . fmap f
05:16:39 <lambdabot> Monad m => (a1 -> m a2) -> m a1 -> m a2
05:17:01 <kuribas> iron_houzi: do you know what a Functor is?
05:18:04 <iron_houzi> kuribas: I have some intution on what a Functor is .. and I think I'm mixing that with what a Monad is ..
05:18:46 <kuribas> why do people want to learn about monads before knowing functors?
05:19:05 <dminuoso> kuribas: I blame bitemyapp :P
05:19:06 <locallycompact> because it's a meme at this point
05:19:18 <iron_houzi> kuribas: Hey .. now you're just making a lot of assumptions ..
05:19:27 <kuribas> iron_houzi: no offense :)
05:19:35 <dminuoso> kuribas: When I was looking around to learn Haskell I saw his book and saw the note: "Perhaps you were just looking for the 18 billionth* monad tutorial, certain that this time around you will understand monads once and for all."
05:19:44 <dminuoso> I felt challenged by that..
05:20:45 <kuribas> iron_houzi: The concept of a monad is easier to understand if you know what a functor is.
05:21:23 <ventonegro> and functors are more pervasive than monads, so should be learned first...
05:21:33 <dminuoso> though I think in some way Monoid is more useful than Functor
05:21:45 <dminuoso> Functor is far too often explained in terms of "containers" which is not helpful to learn Monad from
05:22:28 <kuribas> iron_houzi: in fact, monadic bind is just unpeeling a layer after calling fmap.
05:22:49 <dminuoso> "just" heh
05:23:23 <kuribas> dminuoso: right, the container analogy isn't great, but it's popping up a lot now.
05:24:12 <dminuoso> kuribas: In some ways its a useful intuition, but when learning Monad it's just in the way :(
05:24:21 <dminuoso> At least thats my experience
05:24:47 <kuribas> dminuoso: it should be made clear that a container can be a functor, but it isn't the other way around.
05:25:08 <kuribas> :t fmap putStrLn getLine
05:25:09 <lambdabot> IO (IO ())
05:26:05 <ventonegro> :t words <$> getLine
05:26:06 <lambdabot> IO [String]
05:26:48 <ventonegro> :t length . words <$> getLine
05:26:49 <lambdabot> IO Int
05:26:50 <Ariakenom> bind = \m f -> join $ fmap f m
05:26:53 <dminuoso> :t asum (many getLine)
05:26:55 <lambdabot> error:
05:26:55 <lambdabot>     • No instance for (Foldable IO) arising from a use of ‘asum’
05:26:55 <lambdabot>     • In the expression: asum (many getLine)
05:27:10 <ventonegro> You can do a lot just with the Functor interface
05:27:41 <kuribas> iron_houzi: monad is a meaningless pattern, which happens to have many interesting applications.
05:28:18 <kuribas> iron_houzi: containers being one of them.
05:28:22 <Ariakenom> :t fmap words $ many getLine
05:28:24 <lambdabot> error:
05:28:24 <lambdabot>     • Couldn't match type ‘[Char]’ with ‘Char’
05:28:24 <lambdabot>       Expected type: IO String
05:28:47 <Ariakenom> needs more fmap
05:29:28 <dminuoso> :t asum (repeat getLine)
05:29:30 <lambdabot> IO String
05:29:58 <dminuoso> @let first = asum . repeat
05:29:59 <lambdabot>  Defined.
05:30:00 <Ariakenom> :t fmap concat (many getLine)
05:30:01 <lambdabot> IO [Char]
05:30:13 <kuribas> iron_houzi: the same way the number 5 is a meaningless symbol, but it gets meaning because we assign to it.  You can say a number represents the count of objects, but it can represent countless other things.
05:30:18 <dminuoso> Mmm. asum.repeat might be a cool combinator...
05:30:34 <Profpatsch>      trans :: (PositionAbs -> k -> v) -> (Int -> k -> v)
05:30:36 <Profpatsch>      trans f = \i -> f (PositionAbs i)
05:30:42 <Profpatsch> I’m missing a combinator, right?
05:31:16 <Ariakenom> dminuoso: Why did you name it first
05:31:39 <Profpatsch> The currying aspect is a bit confusing, but I want to transform a f given to Vector.imap
05:32:07 <dminuoso> Ariakenom: yeah okay maybe more like..
05:32:28 <Profpatsch> lmap from profunctors should do the trick, right? Is there something like that in base?
05:32:42 <kuribas> :t asum
05:32:44 <dminuoso> Ariakenom: annoying = msum.repeat
05:32:44 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
05:33:04 <dminuoso> Ariakenom: naming things is hard.
05:33:17 <dminuoso> but I think it should be msum
05:33:30 <dminuoso> :t (msum . repeat)
05:33:31 <lambdabot> MonadPlus m => m a -> m a
05:34:03 <mniip> that doesn't...
05:34:26 <kuribas> why is IO an alternative?
05:34:43 <mniip> kuribas, it is alternative wrt exceptions
05:34:47 <electrocat> kuribas: i think because of IO exceptions
05:34:51 <kuribas> ah right!
05:34:57 <mniip> % evaluate undefined <|> pure ()
05:34:57 <yahb> mniip: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err; undefined, called at <interactive>:15:10 in interactive:Ghci1
05:35:08 <mniip> maybe
05:35:35 <dminuoso> Ariakenom: `last` might be a good name perhaps
05:35:41 <Ariakenom> mniip: only IOException
05:35:44 <mniip> ah
05:36:07 * hackage radius 0.5.0.2 - Remote Authentication Dial In User Service (RADIUS)  http://hackage.haskell.org/package/radius-0.5.0.2 (erick)
05:36:17 <Ariakenom> I've been posting ":t many getLine" unprompted for a few weeks :p. Tends to get a few looks
05:36:31 <minopret> Is a monad a "conjugacy class" as in group theory?
05:36:33 <dminuoso> Ariakenom: yeah except `many getLine` is a bit misleading isnt it?
05:36:38 <dminuoso> Ariakenom: shouldnt it be `repeat getLine`?
05:36:44 <dminuoso> oh wait..
05:36:49 <dminuoso> I didnt say that.
05:36:58 <dminuoso> Lets pretend I just observed in silence.
05:37:00 <Ariakenom> say what *wink*
05:37:18 <mniip> ah, error is ErrorCall
05:37:27 <mniip> while empty is IOError
05:37:43 <Ariakenom> :t msum
05:37:45 <lambdabot> (MonadPlus m, Foldable t) => t (m a) -> m a
05:37:49 <minopret> Is the name Haskell as in Haskell Curry derived from the word in the Hebrew language השכל, "understand"?
05:38:44 <mniip> google tells me it stands for "intelligence"
05:38:53 <Taneb> minopret: it could be Norse "Asketill" meaning God kettle
05:38:57 <minopret> Thanks @mniip
05:39:06 <Profpatsch> Oh man, it’s just f . PositionAbs
05:39:09 <Profpatsch> What am I doing.
05:45:56 * hackage require 0.3.2 - Scrap your qualified import clutter  http://hackage.haskell.org/package/require-0.3.2 (NickSeagull)
05:52:21 <RyanGlScott> Hey all. Does anyone have examples on hand of large, gnarly, hand-written instances for GADTs that you wish could be replaced with GHC.Generics?
05:59:52 <minopret> I don't know about handwritten GADTs. I have generated  GADTs from a Coq proof.  Nicer as GHC
06:00:16 <RyanGlScott> minopret: Those sound pretty interesting!
06:04:41 <Taneb> RyanGlScott: we have some at work but it's not code I can share...
06:06:01 <gentauro> Question with regard of nested modules in ML/OCaml vs Modules in Haskell: In "ML" I can see the parent module alegraic types (+constructors) from each of the submodules, but I can't in Haskell (unless I'm doing it wrong). What's the reason for this? Thx
06:06:50 <Taneb> gentauro: in Haskell you'd have to explicitly import them from the parent modules
06:07:27 <gentauro> Taneb: which means that I need to make constructors explicitly exposed (which I really don't want)
06:07:43 <Taneb> In Haskell, the modules Foo.Bar and Foo.Bar.Baz don't have anything to do with each other other than their names
06:07:54 <Taneb> They're not really "nested" in the same sense at all
06:08:02 <gentauro> Taneb: Thx, that's what I wanted to know
06:08:54 <cocreature> gentauro: you need to expose them from the module but you don’t need to expose that module.
06:08:56 <gentauro> Taneb: Next question, is there a way to create nested modules like in ML (in Haskell) :)
06:09:19 <Taneb> gentauro: no, sadly
06:09:37 <Taneb> One thing you can do is create a module with all your types, and then not expose that module in the library
06:10:25 <gentauro> Taneb: I would still be able to import Foo.Bar.Baz right?
06:10:34 <Taneb> Yes
06:10:42 <gentauro> then it's not good
06:10:58 <gentauro> for example my type is limited to 5 star ratings
06:11:10 <Taneb> Well, you would from Foo.Bar, but you can make it so I can't from X.Y in a different library
06:11:12 <cocreature> you can import Foo.Bar.Baz but that won’t give you access to the definition of the ADT
06:11:18 <gentauro> if you can go around "this logic" and create a rating with 2000 stars ...
06:12:11 <ysangkok> but you can have only three stars on hackage
06:12:20 <gentauro> cocreature: but then you don't expose anything from that module or how?
06:12:48 <gentauro> ysangkok: it's not stars, they are lambdas ... but it's not related to that, it's just an example
06:13:03 <cocreature> gentauro: I’m a bit confused. so you have two modules A and B. A defines some datatype that you use in B. and you don’t want to give users of your library access to the definition of A right?
06:13:19 <cocreature> s/definition of A/definition of the ADT defined in A/
06:15:59 <mizu_no_oto> gentauro: A fairly standard practice in Haskell is to make Foo.Bar.Internal that's imported by Foo.Bar and Foo.Bar.Baz
06:16:04 <gentauro> cocreature: I'm used to OCaml where I can have nested modules
06:16:34 <cocreature> gentauro: I’m not used to OCaml and we don’t have nested modules in the sense that you want as Taneb explained, so you are going to have to explain your goal in Haskell terms :)
06:16:41 <gentauro> I can define ADT on the parent module and limit exposure (constructors) but from my nested modules I have access to them
06:17:00 * hackage firebase-database 0.0.1 - Google Firebase Database SDK  http://hackage.haskell.org/package/firebase-database-0.0.1 (NickHamilton)
06:17:13 <gentauro> cocreature: well the problem is if the language doesn't support this feature, I can't ... obviously
06:17:25 <cocreature> is your goal to limit access to the ADT to external users of your library or to other modules in the same library?
06:17:33 <gentauro> and If I have to explain your the solution, why even ask?
06:17:46 <cocreature> …
06:17:51 <gentauro> cocreature: nevermind ...
06:19:21 <mizu_no_oto> You don't guarantee anything about Foo.Bar.Internal remaining stable or even being a good idea for people to use, but it's at least open to library consumers if they absolutely need it.
06:20:34 <butterthebuddha> Anybody here use intero with emacs?
06:20:47 <gentauro> butterthebuddha: yeah
06:21:13 <gentauro> butterthebuddha: I have an issue everytime I open a project (it looks for an old project and crashes)
06:21:22 <butterthebuddha> It doesn't recognize new packages until I restart Emacs
06:21:32 <cocreature> butterthebuddha: you can use M-x intero-restart iirc
06:22:01 <dminuoso> Better get used to restarting intero..
06:22:20 <Athas> Core workflow.
06:23:06 <gentauro> dminuoso: you can "hook" up if the package.yaml changes, then restart intero ;)
06:23:48 <dminuoso> gentauro: I might actually do that on every source file change.
06:24:12 <butterthebuddha> gentauro: How do you do that?
06:26:11 <minopret_> RyanGlScott: I wrote up my Coq-generated Haskell code: https://stackoverflow.com/questions/13334863/can-i-extract-a-coq-proof-as-a-haskell-function
06:28:10 <mizu_no_oto> gentauro: edwardk gave a lightning rant at Boston Haskell about the module thing a few years back: https://youtu.be/yFXzuCFeRGM?t=1h36m50s
06:29:00 * hackage barbies 0.1.2.0 - Classes for working with types that can change clothes.  http://hackage.haskell.org/package/barbies-0.1.2.0 (DanielGorin)
06:41:47 <edwardk> mizu_no_oto: hah i'd forgotten i gave that talk
06:43:07 <butterthebuddha> "badChar = getAll . ((All . (/= '-')) <> (All . (not . isDigit)))" <- can I get rid of the "All ."s in that code?
06:45:43 <barrucadu> badChar c = c /= '-' && not (isDigit c)
06:46:49 <butterthebuddha> Well, I was trying to make it point-free...
06:47:24 <barrucadu> But look how much clearer it is with a variable!
06:49:02 <AfC> "edwardk gave a rant..." we need someone to cut those into a movie. I'd buy popcorn to watch that.
06:49:16 <edwardk> =)
06:49:30 <liste> > let badChar = (&&) <*> (/= '-') <*> (not . isDigit) in badChar 'X'
06:49:33 <lambdabot>  error:
06:49:33 <lambdabot>      • Couldn't match type ‘Bool’ with ‘Bool -> b1’
06:49:33 <lambdabot>        Expected type: Bool -> Bool -> Bool -> b1
06:49:50 <liste> > let badChar = (&&) <$> (/= '-') <*> (not . isDigit) in badChar 'X'
06:49:52 <lambdabot>  True
06:49:59 <liste> > let badChar = (&&) <$> (/= '-') <*> (not . isDigit) in badChar '5'
06:50:00 * edwardk wants quantified constraints so badly. the code i'm writing right now cries out for them
06:50:01 <lambdabot>  False
06:51:14 <DigitalKiwi> edwardk lambdabot called you out on your lies!
06:51:38 <edwardk> fair
06:52:27 <mniip> edwardk, quantified in what sense
06:52:55 <mniip> forall c. (C c, c a) => T a ?
06:52:56 <edwardk> class (forall m. Monad m => Monad (t m)) => MonadTrans t where lift :: Monad m => m a -> t m a
06:53:05 <mniip> ah
06:53:30 <mniip> forall to the left of =>
06:53:48 <edwardk> in the current setting i have some class constraint "Evident t a" that is definitely implied by (ToJSON a, FromJSON a) but may well be weaker
06:54:01 <edwardk> but using the constraints package to open the proof all the time gets really tedious on the code i have
06:54:03 <mniip> is there a sound type theory behind this? and a typechecking algorithm
06:54:09 <edwardk> yes and yes
06:54:25 <edwardk> simon already has a patch for ghc for it
06:54:51 <mniip> so how is that going to work
06:55:11 <mniip> an instance of MonadTrans will have to offer a function of type 'forall m. Monad m -> Monad t m' ?
06:55:23 <mniip> (in Core I mean)
06:55:59 <mniip> ooo
06:56:11 <mniip> initial object in the constraint category
06:56:31 <mniip> class (forall c. c) => Never
06:56:33 <mizu_no_oto> https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0018-quantified-constraints.rst
06:57:55 <cocreature> QuantifiedConstraints is even merged in HEAD by now iirc
06:58:12 <edwardk> cocreature: did he ever get around to fixing the relaxation of the calling context stuff?
06:58:16 <edwardk> without that its kinda useless
06:58:38 <cocreature> edwardk: no idea, I only know that something™ will be in 8.6 :)
06:59:49 <edwardk> authenticated data structures in normal haskell https://www.irccloud.com/pastebin/bOBRfcEM/Authenticated.hs
07:00:22 <edwardk> This is the thing I'm experimenting with. I have a version that uses backpack and I have this one and i started a version using quantifiedconstraints which causes all the nonsense to melt away
07:00:42 <edwardk> There you get something like
07:00:48 <mniip> oh I see
07:01:11 <mniip> much like 'Eq a => Eq [a]' is a global dictinary
07:01:22 <mniip> it can be a local one
07:01:31 <DigitalKiwi> is edwardk streaming soon :D
07:01:37 <edwardk> class (forall a. (Show a, Read a) => Evident t a, forall a. Evident t (t a)) => Authenticated t where type Evident t a :: Constraint; auth :: Evident t a => a -> t a
07:02:01 <edwardk> DigitalKiwi: I'm in California through this coming weekend, but my travel schedule relaxes starting next weekend
07:02:28 <DigitalKiwi> ok
07:02:52 <edwardk> with the quantified constraints version, ideally i'd be able to state that thing directly, and 'authauth' and 'auths' and the unauth equivalents just vanish from that code
07:06:15 <nshepperd> we could also make all those Eq1/Show1/etc typeclasses be properly related to the normal ones, that would be good
07:06:19 <edwardk> the code there is basically the stuff from http://www.cs.umd.edu/~mwh/papers/gpads.pdf implemented as a library in the spirit of bob atkey's implementation in ocaml
07:06:44 <edwardk> technically Eq1, Show1, etc. aren't quite the same as type Eq1 f = forall a. Eq a => Eq (f a)
07:07:03 <edwardk> they aren't strong and they aren't weaker, they are incomparable.
07:07:37 <edwardk> Eq1 lets you supply the comparison yourself, but with Eq1 as a quantified constraint you'd have to be capable of fmapping to do the same.
07:07:51 <nshepperd> hmm
07:08:19 <nshepperd> well, Eq1 lets you write Eq
07:08:24 <nshepperd> so doesn't that make it stronger?
07:09:00 <AWizzArd> I have a sum type and want to derive Eq. This would work perfectly with the exception of one data constructor, which takes a function argument. How can I specify: „Dear GHC, please derive Eq for all constructors with the exception of Foo where I do this manually”?
07:09:13 <edwardk> :t Data.Functor.Classes.liftEq
07:09:15 <lambdabot> Data.Functor.Classes.Eq1 f => (a -> b -> Bool) -> f a -> f b -> Bool
07:10:02 <edwardk> Data.Functor.Classes.Eq is 'stronger' in the sense that it can use a heterogeneous equality check and doesn't require you have a functor instance to substitute in a type with the equality you want
07:10:04 <edwardk> on the other hand
07:10:12 <edwardk> Eq1 as a quantified constraint gets you a real Eq instance
07:10:28 <edwardk> hence both of them are stronger in different ways, meaning neither properly subsumes the other
07:10:39 <nshepperd> instance (Eq1 f, Eq a) => Eq (f a) where { (==) = liftEq (==) }
07:11:20 <edwardk> nshepperd: my point is that both of these are valuable things, and having one doesn't give you the other
07:11:48 <edwardk> you can then debate forever which is "more useful" but there are scenarios in which each one is individually indispensible
07:12:14 <nshepperd> I don't understand
07:12:42 <nshepperd> based on teh above instance, I should be able to write 'class (forall a. Eq a => Eq (f a)) => Eq1 f where { ... }'
07:12:49 <nshepperd> without invalidating any instances of Eq1
07:13:13 <nshepperd> and get both of these things for free
07:13:18 <edwardk> instance (Eq1 f, Eq a) => Eq (f a) where { (==) = liftEq (==) } -- says that _every_ Eq instance for anything that takes a parameter is formed that way.
07:13:23 <edwardk> that isn't the case
07:13:42 <edwardk> instances only look at the right hand side to decide, irrevocably what to do
07:14:20 * [exa] wishes the qualification separator wasn't arrow
07:15:10 <edwardk> if you say instance (Applicative f, Num a) => Num (f a) -- that works pointwise then you completely destroy the ability to make some other Num instance, like data Poly a = Poly [a] -- instance Num a => Num (Poly a) that does so in a different manner
07:15:11 <nshepperd> edwardk: well, I wouldn't actually write that instance
07:15:26 <nshepperd> edwardk: treat f as a metavariable
07:15:43 <nshepperd> irl you'll write your instances for Eq and Eq1 at the same time
07:16:16 <nshepperd> for the same f
07:16:20 <mniip> 1529503938 [17:12:18] <nshepperd> based on teh above instance, I should be able to write 'class (forall a. Eq a => Eq (f a)) => Eq1 f where { ... }'
07:16:21 <mniip> wrong
07:16:32 <mniip> you can't write liftEq
07:16:59 * hackage stackage2nix 0.7.1 - Convert Stack files into Nix build instructions.  http://hackage.haskell.org/package/stackage2nix-0.7.1 (typeable)
07:17:08 <UnkDevE> is there a way of mixing IO and non-IO functions without using unsafePerformIO?
07:17:14 <edwardk> my point is that (forall a. Eq a => Eq (f a)) is weaker then Eq1 f in the sense that i can't build the functionality of liftEq from it. On the other hand, Eq1 as it exists today is weaker than (forall a. Eq a => Eq (f a)) in that i can't use it to get an Eq instance for (f a) from Eq1 f, and Eq a
07:17:18 <nshepperd> mniip: er, that class definition does the reverse
07:17:30 <edwardk> we _could_ extend Eq1, Show1, Read1, etf.
07:17:35 <edwardk> to carry around an extra member
07:17:41 <Ariakenom> UnkDevE: Just use let bindings
07:17:55 <edwardk> eq1 :: Eq1 f => Eq a :- Eq (f a)
07:17:55 <mniip> edwardk, like uhhh
07:18:00 <edwardk> or something like that
07:18:03 <nshepperd> yeah, that's what I mean, we could make Eq1 not weaker, once we have Quantified constraints
07:18:11 <mniip> observe :: ((forall a. Eq a => Eq (f a)) => r) -> r
07:18:13 <edwardk> or we could use quantified constraints to make a superclass for Eq1
07:18:44 <edwardk> mniip: you need proxies or AllowAmbiguousTypes to use your version
07:18:50 <mniip> sure
07:19:07 <edwardk> with the constraints package the eq1 above is how i'd write it today probably
07:19:12 <Ariakenom> [exa]: What would be good? dots forall m. Monad m. a -> m a
07:19:14 <mniip> oh superclass for Eq1 sounds cool
07:19:46 <mniip> what methods would it have?
07:19:55 <mniip> other than require (forall a. Eq a => Eq (f a))
07:20:10 <edwardk> mniip: what i mean is the (forall a. Eq a => Eq (f a)) is the 'superclass' context of Eq1
07:20:15 <nshepperd> the superclass can be (forall a. Eq a => Eq (f a))
07:20:16 <mniip> right
07:20:38 <edwardk> class (forall a. Eq a => Eq (f a)) => Eq1 f where liftEq :: (a -> b -> Bool) -> f a -> f b -> Bool
07:21:19 <UnkDevE> Ariakenom: Thanks, but in what way would you use the let bindings?
07:21:19 <edwardk> it also means things like the "Lifting" class in constraints can become trivial.
07:21:27 <AWizzArd> Is it possible to derive Eq for a sum type but for one constructor specify my own implementation? Or will I have to write out the whole implementation by myself, where for seven cases I will in the end just do  x == y?
07:22:19 <nshepperd> right and that would make Eq1 a lot more usable imo
07:22:22 <edwardk> type Lifting p f = forall a. p a => p (f a)
07:22:27 <Ariakenom> UnkDevE: You could use do {print "hi"; let s = "world"; print s; return ();}
07:22:31 <edwardk> nshepperd: yeah i think we're in violent agreement there =)
07:23:14 <edwardk> AWizzArd: factor out the one constructor you want to make magic into its own data type, then you can derive for the thing that just delegates out to that
07:23:34 <AWizzArd> edwardk: yes okay, that could work.
07:24:05 <Ariakenom> UnkDevE: do{} is also an expression. do {print ""; let s = "" in do {print s; return ()}}
07:24:10 <Taneb> :t eq1 elem
07:24:11 <lambdabot> error:
07:24:11 <lambdabot>     • Variable not in scope: eq1 :: (() -> [()] -> Bool) -> t
07:24:11 <lambdabot>     • Perhaps you meant ‘eqT’ (imported from Data.Typeable)
07:24:16 <Taneb> :t liftEq elem
07:24:18 <lambdabot> error:
07:24:18 <lambdabot>     • Variable not in scope: liftEq :: (() -> [()] -> Bool) -> t
07:24:18 <lambdabot>     • Perhaps you meant one of these:
07:24:28 <edwardk> :t Data.Functor.Classes.liftEq elem
07:24:29 <lambdabot> (Eq a, Foldable t, Data.Functor.Classes.Eq1 f) => f a -> f (t a) -> Bool
07:24:34 <Logio> UnkDevE: what kind of functions are you trying to combine?
07:24:40 <nshepperd> :O what if we could also have 'class (forall a. MonoFoldable (f a)) => Foldable f'
07:25:07 <edwardk> nshepperd: good luck getting that one into base any time soon ;)
07:25:40 <edwardk> Prelude tends to be pretty conservative
07:25:58 <UnkDevE> Ariakenom: Im thinking the other way round a IO function to a pure function e.g. f = do {putStrLn "hello world"; return 1;} g = f + 1`
07:26:26 <UnkDevE> Logio: IO a and a
07:26:31 <edwardk> Data.Functor.Classes is kinda off in niche territory and could justify getting away with functionality on the bleeding edge that doesn't rule out any of the standard instances. MonadTrans could also kinad justify it as every legit transformer passes the test as well
07:26:48 <Taneb> > Data.Functor.Classes.liftEq elem "abc" ["aej", "banana", "oxford"]
07:26:50 <edwardk> but i'm guessing both of those will be a big fight when we go to do them
07:26:51 <lambdabot>  error:
07:26:51 <lambdabot>      Not in scope: ‘Data.Functor.Classes.liftEq’
07:26:51 <lambdabot>      No module named ‘Data.Functor.Classes’ is imported.
07:26:54 <nshepperd> and then we'll move all the methods of every Prelude class into the corresponding Mono class
07:27:08 <Taneb> :|
07:27:25 <edwardk> nshepperd: and shortly thereafter i'll give up and become a hermit ;)
07:27:30 <nshepperd> :)
07:28:13 <Ariakenom> UnkDevE: No. g should become IO Int. g = do {x <- f; return (x+1)}
07:28:22 <edwardk> @let import Data.Functor.Classes
07:28:23 <lambdabot>  Defined.
07:28:29 <edwardk> > Data.Functor.Classes.liftEq elem "abc" ["aej", "banana", "oxford"]
07:28:31 <lambdabot>  False
07:28:41 <Taneb> > Data.Functor.Classes.liftEq elem "abc" ["aej", "banana", "cambridge"]
07:28:43 <lambdabot>  True
07:28:59 <Logio> UnkDevE: the main point of the IO type is that you can never escape it (without using unsafeFunctions; that's why they're unsafe)
07:29:11 <UnkDevE> right ok
07:29:43 <jchia_1> Is there a library that lets me query in-memory data (e.g. lists or vector of records) like i would a RDBMS with SQL or SQL-like constructs performing joins, groupbys, aggregation etc without actually using a SQL engine talking to a server.
07:29:59 <UnkDevE> you see I have one pattern constructor that returns a and another that returns IO a, how do I get both to return IO a?
07:30:30 <Logio> :t return
07:30:31 <lambdabot> Monad m => a -> m a
07:30:48 <Logio> IO is a monad, so you can use return
07:31:01 <edwardk> jchia_1: tables used to kinda offer that functionality, but then there was a bug and i never fixed it and deprecated it
07:31:37 <nshepperd> like a blanket, monads make me feel warm and protect me from the RealWorld
07:32:18 <Logio> UnkDevE: for instance, if I have f x = x + 1 of type Int -> Int, defining g = return . f gives me Int -> IO Int (if I specify the type)
07:32:36 <UnkDevE> oh cool, thank you!
07:34:04 <Logio> you'll probably want to take a look at the Applicative typeclass actually
07:34:54 <merijn> jchia_1: SQLite?
07:34:59 <Taneb> edwardk: I still take a look at tables every few months
07:35:12 <merijn> jchia_1: That has both an in-memory and on disk option
07:35:17 <Logio> there they define pure (which is exactly the same as return), but also a ton of nice operators for combining functions and values in certain ways
07:35:45 <merijn> jchia_1: All the benefits of SQL, without having to invest the effort to run a server :p
07:36:44 <Ariakenom> I suppose SQLite is too much effort.
07:38:16 <nshepperd> select :: (Ord k, Monoid v, Foldable f) => (a -> k) -> (a -> v) -> f a -> Vector (k, v) -- i've used this before for quick sql-like hacking on data
07:38:59 <jchia_1> merijn: That should work. I haven't written the code so it's hard to say whether sqlite will make the code simpler or more complicated.
07:39:49 <jchia_1> one tradeoff is the use of IO
07:40:56 <mniip> edwardk, are you saying T2893 is in master now?
07:44:41 <edwardk> mniip: somebody else said it, not me
07:45:31 <quicksilver> jchia_1: there is this - https://hackage.haskell.org/package/HaskRel
07:45:35 <edwardk> jchia_1: if you just need to do a few joins there is support for linear time joining in the discrimination package
07:45:37 <quicksilver> which I haven't heard of
07:45:49 <mniip> edwardk, looks like it is
07:46:12 <mniip> I see tests in the repo
07:47:24 <jchia_1> edwardk: I'm looking for something to make the code clearer. I have ad-hoc code that does aggregation, grouping and joining of different record types all over the place that I think can expressed more clearly using SQL.
07:47:34 * hackage htoml-megaparsec 2.0.0.1 - Parser for TOML files  http://hackage.haskell.org/package/htoml-megaparsec-2.0.0.1 (vmchale)
07:49:16 <jchia_1> quicksilver: Have you used HaskRel?
07:50:30 <jchia_1> edwardk: Does discrimination do aggregation (sum and max)?
07:51:28 <maerwald> was there ever a discussion to port mtl to type families?
07:51:36 <quicksilver> jchia_1: nope :)
07:54:09 <edwardk> joining :: Discriminating f => f d -> ([a] -> [b] -> c) -> (a -> d)	-> (b -> d) -> [a]	-> [b] -> [c] -- is pretty general. f there can be Grouping or Sorting. d is the type of the part you want to join on, the ([a] -> [b] -> c) is given the lists of things you are trying to cross product together -- and can be used to compute inner/outer/left/right, etc. joins
07:54:26 <edwardk> maerwald: yes. monads-tf exists. its a trashfire
07:55:21 <edwardk> it really needs to use separate module names, but basically caused a pretty big mess when it was released. mind you at the time there was a fight between mtl, monads-fd and monads-tf splitting the community 3 ways all supplying the same module names with incompatible APIs
07:55:38 <edwardk> monads-fd and mtl merged back together to give us the current story
07:55:42 <edwardk> monads-tf was left to die
07:56:20 <maerwald> because I just read a rant about UndecidableInstances and mtl obviously makes quite some use of it
07:56:24 <edwardk> in theory if monads-tf was moved so that its modules were in a new space, like Control.Monad.Family.* or whatever then it could continue to exist alongside the monads-fd that was renamed to mtl
07:56:56 <edwardk> maerwald: the cure is kinda worse than the disease there. the subset of UndecidableInstances used by the mtl are really decidable
07:57:09 <edwardk> its just that ghc isn't smart enough to check that
07:57:11 <maerwald> I see
07:57:39 <electrocat> smart enough? it's not decidable :p
07:57:58 <mniip> edwardk, rank2 inference when
07:58:30 <edwardk> electrocat: sure it is. In MonadState s m the 's' is _determined_ by m, due to the fundep and we're doing recursion shrinking the parameter that determines the other.
07:58:50 <electrocat> edwardk: in those cases sure, but not in the general case i mean
07:58:55 <edwardk> the basic decidable instances check doesn't know anything about fundeps because it predates the idea of MPTCs entirely
07:59:13 <edwardk> yes, like i said "_the subset of UndecidableInstances used by the mtl_ are really decidable"
07:59:14 <electrocat> but ofcourse, more refined termination conditions are always welcome :p
07:59:40 <edwardk> i started a ghc proposal a few months back when this came up last time. i just haven't had time to go back and flesh it out
07:59:47 <electrocat> yes i remember
08:00:30 <electrocat> have you found any concrete refined conditions?
08:01:02 <edwardk> yeah, basically use the paterson conditions in general, then you can do the sort of thing i mentioned in the proposal only when you recurse through the same typeclass in the manner specified.
08:01:09 <edwardk> that covers the mtl
08:01:15 <edwardk> its a matter of specifying that correctly
08:01:36 <electrocat> ok, i should read that sometime
08:01:45 <electrocat> maybe try them out
08:01:59 <dmwit> For mtl specifically, you can probably just use the Paterson conditions directly, but only on those arguments which are not to the right of a fundep arrow.
08:02:22 <edwardk> MonadState s m => MonadState s (ReaderT e m) -- works because its recursing through the same type parameter m, and m determines all the remaining type parameter.
08:02:23 <dmwit> But that probably relies on mtl not having any cyclic fundeps.
08:02:38 <edwardk> on the other hand the paterson conditions allow you to recurse through any typeclass you want at all
08:03:48 <edwardk> dmwit: yeah the trick is handling all the multiple fundep situations which is the thing i was trying to cover with the proposal
08:03:52 <dmwit> yeah
08:03:55 <dmwit> That does seem tricky.
08:04:36 <edwardk> in the end the proposal i have can probably be tweaked slightly to work, the tweak is the thing i didn't have time to work out, as i immediately got stuck traveling for 2-3 months
08:04:41 <dmwit> Just pondered it for the last 30s and haven't solved it yet. ;-)
08:05:25 <edwardk> its a lot like totality checking in something like agda, etc. except you can't just infer an argument ordering, so its weaker
08:06:12 <edwardk> the paterson conditions can be seen as an obvious sufficient condition for soundness, but they aren't the largest generally sound condition
08:07:02 <dmwit> Of course. The largest sound condition isn't computable.
08:07:04 <edwardk> jchia_1: anyways that joining type signature i mentioned can do aggregation pretty easily.
08:07:30 <edwardk> dmwit: sure, just looking for better approximations than what we have that work in an open world situation
08:07:47 <edwardk> if we had a closed world situation then basically the agda style totality checker would be fine
08:07:48 <jchia_1> edwardk: Seems that I need to read the linked papers to grok this library. The links are broken. Do you have the titles?
08:08:12 <edwardk> google "fritz henglein discrimination"
08:08:33 <edwardk> https://www.youtube.com/watch?v=cB8DapKQz-I might also be informative
08:08:45 <edwardk> the category theory flies fast and furious for a while but then it settles down into code
08:09:03 <jchia_1> I was referring to links on the github: https://github.com/ekmett/discrimination/
08:09:12 <jchia_1> Yeah, I saw the youtube link, too
08:09:27 <jchia_1> Oh, that's a different video
08:09:31 <edwardk> the 'fritz henglein discrimination' thing should get you 2-3 papers by fritz
08:10:04 <edwardk> the video i linked was a talk i gave on this particular library from before i solved the productive stable unordered discrimination problem i posed at the end of the talk
08:10:05 <jchia_1> Is this library easier or harder to understand than lens?
08:10:07 <dmwit> edwardk: Ah, got it. Here's what I think makes it hard.
08:10:37 <dmwit> edwardk: Given any collection of variables that, by the fundeps, determines them all, applying the Paterson conditions consistently to that collection for all instances is going to work.
08:10:52 <dmwit> edwardk: But a given collection of fundeps may have multiple possible such collections. So you need a heuristic for choosing one.
08:11:11 <dmwit> edwardk: But perhaps it's not hard to identify the conditions in which there's exactly one such collection.
08:11:36 <edwardk> actually even with multiple collections you can check them all, its just possibly expensive
08:11:40 <dmwit> So e.g. for no fundeps at all, the sole collection is all the variables.
08:12:09 <dmwit> edwardk: Oh, sure, you could check them all.
08:12:25 <dmwit> But that's also too strong.
08:12:33 <dmwit> (Still weaker than what we have now, of course.)
08:13:11 <dmwit> edwardk: Perhaps we could push this onto the class declaration to say which collection (if any) is the one which can be checked.
08:13:12 <edwardk> the problem is the open world assumption makes doing something weaker dangerously unsound
08:13:59 <dmwit> edwardk: Why? If I choose collection "a b c" and the fundeps say that this determines all the remaining variables, then in every instance I check the Paterson conditions for "a b c" (and never choose a different collection to check), how is that unsound?
08:14:22 <edwardk> so the approach you're starting to take is the approach i took in https://github.com/ekmett/ghc-proposals/blob/decidable-instances/proposals/0000-decidable-instances.rst
08:14:24 <dmwit> Instead of "a b c", let me say "first argument, second argument, third argument".
08:14:34 <edwardk> the issue is more that you can recurse through other classes that have their own fundeps
08:14:52 <edwardk> and you don't know what those things will be in advance
08:16:32 <edwardk> the issue i had was the 2. Compute the set of structurally recursive parameters P. -- differs from the way the paterson condition checks it. in my case i have to loop through something that 'agrees' with my fundep structure in a nice way, trivially, i can always do so by recursing through the same class, but there may be others that i want to do the same for.
08:17:01 <dmwit> I'll give it a read and see how my thoughts mesh with yours.
08:17:02 <edwardk> the paterson condition is sound regardless of fundeps, hence why i said it makes a viable fallback when i don't know anything about the fundeps of the other stuff i'm recursing through
08:17:35 <edwardk> https://github.com/ghc-proposals/ghc-proposals/pull/114 <- in there AntC raised a pile of issues mostly around these funny recursive cases
08:17:47 <dmwit> brilliant
08:20:18 <edwardk> anyways once i incorporate the 'oh crap recursion can be through any class' which isn't a concern for the mtl-like usecase, then my step 2 needs some considerable refinement
08:20:53 <edwardk> i just haven't had a chance to go through and completely rephrase the construction i wound up with in the terms i'd need to have to make that change, and then worked through how much of the simple algorithm i have remains sound
08:21:44 <jchia_1> Does this function exist in a commonly-used library? Lens' s a -> (a -> a -> a) -> s -> s
08:22:02 <Taneb> jchia_1: what is that doing
08:22:19 <Taneb> :t \l f -> modify (join f)
08:22:19 <dmwit> Did you intend to have another -> s on the end, there?
08:22:20 <lambdabot> MonadState s m => p -> (s -> s -> s) -> m ()
08:22:33 <Taneb> :t \l f -> l %~ join f
08:22:34 <lambdabot> ASetter s t a b -> (a -> a -> b) -> s -> t
08:23:18 <edwardk> jchia_1: what are the two 'a's you want? the lens only gives you one
08:23:27 <jchia_1> Taneb: Actually, it wasn't very well thought out. I didn't say what to do with thou non-a parts of s
08:24:02 <jchia_1> Well, I'm trying to combine two s values by combining the individual parts, some with (+), some with max.
08:24:28 <edwardk> jchia_1: lens isn't going to be super helpful there, as it doesn't know how to break things into disjoint bits and pieces
08:25:15 <edwardk> unless you want to define an Iso between your s and some type that happens to be a monoid
08:25:42 <__monty__> edwardk: Any streams coming up in the near future?
08:25:56 <jchia_1> edwardk: That's what I'm doing now. I made two monoid wrappers, on that does (+) and one that does max.
08:25:59 <quicksilver> edwardk: was going to say, there are various things you can do with an Iso or a Lens to simple sum types
08:26:15 <quicksilver> which enable Lens to 'see' that your stuff breaks into disjoint components
08:27:00 <edwardk> __monty__: i get back to boston the 25th, but i may have to go down to new yrk the 28-29th, which would leave me kinda wiped out to do a stream on the 30th if it happens, if i don't have to then i can probably stream on the 30th, and regardless on the 7th, i'm definitely back and relaxed though
08:27:47 <__monty__> edwardk: Thanks, looking forward to it : )
08:28:04 <edwardk> jchia_1: Data.Semigroup and Data.Monoid should already have Sum and Min/Max
08:28:27 <mniip> goddammit gcc
08:28:32 <mniip> why is --enable-default-pie a thing now
08:29:59 <__monty__> mniip: To make code less exploitable?
08:30:42 <mniip> ASLR is just treating a symptom but that's beside the point
08:30:47 <mniip> it breaks compilation every so often
08:31:32 <jchia_1> Basically, I have this code for defining two ways for combining two Foo values, and I find it too verbose for a simple idea: https://gist.github.com/jchia/7daa8f4800748ed643c17646e8f7677c
08:35:04 <NemesisD> i'm trying to debug a stack overflow. i can repro it by setting the stack size to something really small. however, when trying to compile for profiling i get an error "cannot load -prof objects when ghc is built with -dynamic". what do i do?
08:35:13 <jollygood2> hi
08:37:00 <jollygood2> I have a single cabal file with two programs defined. when I type stack repl I get "The main module to load is ambiguous. Candidates are:" error. I can then pick which main module to use. but is there a way to specify that module in cabal or stack.yaml file?
08:37:54 <dmwit> edwardk: I believe my proposal does not require computing the "structurally recursive" parameters at all.
08:38:01 <jollygood2> (my issue is that the emacs haskell mode that I am using doesn't let me pick main module)
08:38:25 <dmwit> edwardk: So may not fall to the same trap wrt recursing through multiple classes that yours does.
08:38:54 <mniip> so, -optl -no-pie
08:38:59 <mniip> but where do I stick that in configure
08:39:56 <edwardk> dmwit: the concerns i'd have are to make sure that things like class Foo s t a b | s -> a, t -> b, s b -> t, t a -> s -- don't break
08:41:34 <dmwit> edwardk: I would expect that class to behave exactly the same way with what I'm proposing. (So no benefit, sadly, but no break.)
08:42:34 <dmwit> edwardk: Here's my proposal in a slightly more concrete way. Every class has a new piece of data attached to it (say, in the interface files).
08:43:06 <dmwit> edwardk: The new info is a collection of argument positions. (I'll talk about how this collection is chosen in a moment.)
08:43:36 <dmwit> edwardk: The compiler is in charge of checking that the collection of argument positions is large enough that, together with the fundeps, all positions of the class are determined if you know the ones in the collection.
08:43:39 <edwardk> the info is giving you the order for the totality check?
08:44:13 <edwardk> ok, i know where you're going
08:44:18 <dmwit> yeah
08:44:37 <dmwit> Then you just apply the Paterson conditions, but only to the positions specified by each class.
08:44:44 <edwardk> its one of the early versions i had for the proposal here, it is sufficient for handling the simple mtl style version
08:44:52 <edwardk> its kinda annoying that you have to put the annotations in though
08:45:01 <dmwit> I think in many cases the annotations can be omitted.
08:45:07 <dmwit> So this is the part I deferred above.
08:45:08 <Solonarv> jchia_1: you could try using HKD, as in https://gist.github.com/Solonarv/913b0dd293f076a996cea4e9ce3a2224 -- not that much shorter though
08:45:36 <dmwit> In almost all situations, there is a *minimal* collection (as in a subset of all other determining collections).
08:45:51 <dmwit> In those situations, the compiler chooses the minimal collection with no annotation required.
08:46:11 <dmwit> (Otherwise, yeah, for `Foo` e.g. you would need an annotation, or fall back to the default collection which is "all the positions".)
08:46:37 <dmwit> In mtl in particular there is a minimal determining collection.
08:47:12 <dmwit> I haven't worked out how the coverage check needs to be modified. Probably it has to stay exactly the same?
08:47:33 <edwardk> a potential middle ground is to just infer it when there is a minimal set, and leave everything else to UndecidableInstances and not even bother coming up with a syntax for the annotation
08:47:48 <dmwit> sure
08:47:57 <edwardk> that'd get you something larger than the current case, but smaller than my goal
08:47:58 <dmwit> But I think the annotation can be pretty syntactically cheap. e.g.
08:48:18 <dmwit> class Foo s t a b | s -> a, t -> b, s b -> t, t a -> s | s t -> a b -- or something
08:48:22 <edwardk> it just increases the "syntactic attack surface" of the proposal ;)
08:48:51 <edwardk> i'd expect it to be a pragma of some sort actually
08:49:43 <jollygood2> showText on Data.Text.Internal.Text giving me Text [<list of numbers>] 0 3158 instead of actual string. what can I use instead?  (read . show) worked, but isn't there a more straightforward way?
08:49:46 <dmwit> Oh, this wouldn't account for the `class (Foo a, Bar a) => Baz a; instance (Foo a, Bar a) => Baz a` thing, though.
08:50:05 <dmwit> That would still need UI.
08:50:08 <edwardk> yeah that is already kind of ailing though. since they decided to make that require MonoLocalBinds to use now all of a sudden
08:50:17 <edwardk> it rather drastically damaged a bunch of my APIs
08:50:21 <Solonarv> jollygood2: what are you trying to do?
08:50:52 <dmwit> jollygood2: unpack
08:50:54 <Solonarv> if you want to convert a Text into the equivalent String, use Data.Text.unpack
08:50:56 <jollygood2> Solonarv get a String that contains actual text from Data.Text.Internal.Text
08:51:06 <dmwit> jollygood2: But generally you should try to stay within Text for your operations and never go to String at all.
08:51:18 <jollygood2> oh right, I remember now
08:51:37 <dmwit> jollygood2: Right, we understand you want a String. But why do you want a String? Who's going to consume that String?
08:51:51 <Solonarv> I've definitely found myself having to use pack/unpack because of APIs using String (grr)
08:52:10 <jchia_1> Solonarv: Yeah, neat idea, expresses the combination in a more general way but still needs boilerplate.
08:52:33 <jollygood2> dmwit all the string functions I ever wrote use String. so do many Prelude functions. and since parsing the little text I have is not performance critical, I'll just use String
08:52:44 <adLucem> hey people
08:53:09 <adLucem> I'm trying to find an off-the-shelf NLP library in haskell
08:53:33 <adLucem> Something like, say, python's NLTK, or even better, python's spacy library- in haskell
08:53:48 <adLucem> (dependency parsing- of english- is the particular task I want to do)
08:53:57 <adLucem> is there a library like this?
08:57:21 <jchia_1> adLucern: I'm not familiar with this field in Haskell, but have you checked out the NLP category on hackage? https://hackage.haskell.org/packages/#cat:Natural%20Language%20Processing
09:00:24 <adLucem> @jchia_1 not what I was looking for. Thanks anyway :)
09:00:24 <lambdabot> Unknown command, try @list
09:00:54 <adLucem> I think I'll write a haskell wrapper for an existing dependency parsing tool then?
09:03:23 <paraseba> I'm trying to optimize a function that uses mutable vectors. If I let ghc deduce the function signature, I look at the generated core and it's all nice and fast, using primitive arithmetic. If I copy the deduced type signature from the generated core, and I add it verbatim to my code, the generated code is slow, using boxed arithmetic.
09:03:27 <paraseba> what am I doing wrong?
09:04:18 <paraseba> this is the type of the function in question: Data.Vector.Generic.Mutable.MVector v Int8  => [Op] -> v RealWorld Int8 -> Int -> IO Int
09:14:22 <cocreature> paraseba: sounds like you are hitting the monomorphism restriction which will cause GHC to not use the most general type when you don’t declare it
09:14:39 <NemesisD> uhh, is replicateM_ known to leak space or something? i took some code that was previously running replicateM_ 1000000000 doSomething and it blew the stack, but let go n = if n < 1000000000 then doSomething >> go (n + 1) else return () and it ceases to blow the stack
09:15:44 <Taneb> NemesisD: that's odd... that should be exactly what replicateM_ is doing
09:15:59 <paraseba> cocreature: the thing is I'm copying the function's type from what the generated core shows. I'm explicitly writing the type ghc deduced, and that changes completely the generated code. Anyway, any idea how I could test your hypothesis ?
09:16:46 <cocreature> paraseba: what do you mean by “the type ghc deduced”? how are you getting this type? you won’t see that exact same type in core since core has a different type system than Haskell
09:17:08 <cocreature> NemesisD: which Monad?
09:17:16 <mnoonan> NemesisD, it looks like replicateM_ uses (*>), any change that might have issues for your monad?
09:17:26 <NemesisD> Taneb: looking at the source of replicateM_ it looks pretty much the same except it is counting down instead of up and it uses *> instead of >>
09:17:32 <cocreature> NemesisD: my guess would be that you are using an older version of transformers which has broken definitions for (*>)
09:17:56 <NemesisD> right now the monad is KatipT IO, which is just a newtype over a ReaderT, i can see if it persists if i reduce that to just IO
09:18:31 <cocreature> try replacing >> by *> in your manual loop
09:18:53 <NemesisD> i'm on stackage lts 10.10 which uses 0.5.2.0
09:19:31 <NemesisD> cocreature: bingo
09:20:30 <cocreature> NemesisD: iirc the fixes are in 5.3
09:20:32 <cocreature> eh 0.5.3
09:20:47 <NemesisD> i see in transformers-0.5.5.0 a changelog of Defined explicit method definitions to fix space leaks
09:21:07 <cocreature> huh right, I might be mixing up versions here
09:21:22 <Taneb> cocreature: I'm trying to look at the history of the files of transformers and (>>) and (*>) for ReaderT were added in the same commit
09:21:37 <Taneb> (looking at a git mirror because darcshub is down)
09:21:37 <NemesisD> yiikes, lts is still on 0.5.2.0
09:21:55 <paraseba> cocreature: the generated core has type signatures that look just like the haskell ones, at least with all the -dsupress- options I'm using
09:21:57 <cocreature> stackage can’t upgrade transformers because it depends on ghc
09:22:05 <cocreature> paraseba: can you show us the relevant core?
09:22:23 <NemesisD> this seems like it would have widespread consequences
09:22:25 <paraseba> definitely, let me put it in a gist
09:22:30 <[exa]> how's (*>) semantically different from (>>)?
09:22:45 <Taneb> [exa]: they should be identical if (>>) is defined
09:23:05 <[exa]> like, wondering what difference triggered the problem
09:23:07 <cocreature> [exa]: it’s not. the problem is that a bunch of functions in base got switched over to use (*>) instead of (>>) and the default implementation of (*>) can have space leaks
09:23:13 <Taneb> But I think they have different (but provably equivalent) default implementaitons
09:23:25 <[exa]> cocreature: oh so, thanks
09:23:28 <NemesisD> we've been having mysterious space leaks in production for some time, maybe this is to blame
09:23:39 <Taneb> Aaah, the fix was in 0.5.3 as cocreature said
09:23:52 <NemesisD> time to go to nightlies i guess
09:24:02 <cocreature> just add it to extra-deps
09:26:01 <cocreature> https://www.reddit.com/r/haskell/comments/7xqfy8/space_leak_with_nested_strict_statet/dud4oqt/ has some information on the problem for StateT
09:28:37 <NemesisD> @cocreature but i thought it was linked to the ghc version. so why would i be able to use a ghc old enough to be stuck with 0.5.2.0 and use >= 0.5.3.0?
09:28:37 <lambdabot> Unknown command, try @list
09:30:05 <cocreature> NemesisD: stackage provides a consistent snapshot so there can be only one version of each package. that snapshot always includes the "ghc" package which has a dependency on "transformers" and can’t be reinstalled so stackage has to stick to the transformers version shipped with GHC. however, if your project doesn’t depend on the "ghc" package then you can use a newer version of transformers
09:30:51 <cocreature> note that “depending on the ghc package” also includes things like "doctests" which use the GHC API
09:31:03 <NemesisD> i guess we'll see, haha
09:31:12 <EvanR> nested StateT...
09:31:41 <EvanR> on one hand, that is the point of the Ts, to nest them
09:31:49 <EvanR> on the other hand... why would you want nested states
09:32:23 <NemesisD> reinstalling 211 packages
09:32:39 <maerwald> EvanR: well, not nested, but multiple
09:32:41 <cocreature> maybe you should stop depending on acme-everything :)
09:32:55 <NemesisD> tell me about it, lol
09:33:24 <paraseba> cocreature: here https://gist.github.com/paraseba/bee7e8d2f26efbbffc18a027434f9824
09:33:53 <EvanR> yeah you want multiple states
09:34:08 <EvanR> but doing it by nesting sounds masochistic, given the interface
09:34:21 <maerwald> that's the nature of transformers :>
09:34:25 <maerwald> masochism
09:34:38 <EvanR> class MonadMasochism
09:37:04 <cocreature> paraseba: is the "mutableEval" definition actually the one that is being used?
09:37:56 <cocreature> paraseba: anyway, I don’t think it’s too helpful to mess with core here. try giving a more specific type signature where you fix the vector type and see if it performs the same as the one without the type signature
09:38:02 <paraseba> It has a couple more cases for other Op constructors, but the behavior is the same if I comment out those other cases and leave only MRight
09:38:44 <paraseba> I'll give that a try, I did try using SPECIALIZE pragma, but I'll be more specific in the type signature
09:38:47 <cocreature> no I meant is that definition the one that is being used at the usesite
09:39:44 <paraseba> hmm I'm not sure what you are asking. If I don't have some other function with similar name somewhere else and getting confused? In that case no, very small code base, just this function is relevant in this module
09:40:21 <cocreature> paraseba: no I mean the usesite could already inline that function, use a specialized version of this function, …
09:41:40 <AWizzArd> Is there some function similar to `maybe` which implicitly returns a Just value, so that I can save using `id` here?  maybe Foo id (M.lookup name vars)
09:41:42 <paraseba> cocreature: it does, when I'm not giving the type signature it does inline it, with the primitive arithmetic, and using something that looks like the ByteBuffer under the vector
09:42:04 <paraseba> cocreature: giving the function the type signature: mutableEval :: [Op] -> UV.MVector (RealWorld) Int8 -> Int -> IO Int
09:42:09 <cocreature> paraseba: alternatively try enabling NoMonomorphismRestriction and see if that makes the version without the type signature as slow as the one with the type signature
09:42:09 <Solonarv> @hoogle fromMaybe
09:42:10 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
09:42:10 <lambdabot> Distribution.Compat.Prelude.Internal fromMaybe :: () => a -> Maybe a -> a
09:42:10 <lambdabot> Data.Strict.Maybe fromMaybe :: a -> Maybe a -> a
09:42:19 <AWizzArd> That’s it, thx!
09:42:32 <paraseba> cocreature: still getting non primitive arithmetic with that type signature
09:42:41 <paraseba> cocreature: nice!! I'll give that a try
09:43:01 <cocreature> hm if the explicit type signature doesn’t help something weird is going on
09:43:15 <cocreature> paraseba: is your full project public somewhere?
09:44:03 <paraseba> cocreature: no, but I could make it public tonight, it's a stupid BrainFuck evaluator anyway. It's just driving me crazy that the generate code is so slow, and i wanted to learn how to optimize it
09:44:17 <woodson> can anyone explain this syntax for me somefunc :: forall e. Eff (console :: CONSOLE, random :: RANDOM | e). I see it being used in puresript. I get that its just passing a tuple but the vertical bar and the type variable e is throwing me off. I kinda have a sense of whats happening just want someone to explain to me whats actually happening under the hood
09:44:40 <cocreature> paraseba: are you calling this function from another module?
09:45:41 <paraseba> cocreature: I am calling a different one that calls this one, I played with different export lists to no avail
09:45:56 <cocreature> woodson: it seems like you’ll have a better luck asking about purescript syntax in a purescript channel :)
09:46:06 <cocreature> paraseba: ah! maybe try adding an INLINABLE pragma
09:46:10 <paraseba> cocreature: {-# LANGUAGE NoMonomorphismRestriction    #-} didn't help
09:46:19 <paraseba> I have that cocreature
09:46:28 <cocreature> then I’m out of ideas :/
09:47:07 <paraseba> I think I have it down to the native/non-native arithmetic generated, that makes the code twice as fast, and seems independent of almost everything else except adding the signature or not
09:47:58 <paraseba> cocreature: I'll push the project tonight and ping you, in case you want to give it a look
09:48:01 <woodson> cocreature: Oh ok, I thought that it was some haskell extension thats why I though I'd ask here first
09:59:28 <NemesisD> @cocreature updating transformers did the trick. thank you!
09:59:28 <lambdabot> Unknown command, try @list
10:01:36 <superguest> is Haskell lazy and strict with the 2nd parameter of (||) ?
10:01:44 <superguest> > True || "hello"
10:01:46 <lambdabot>  error:
10:01:47 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
10:01:47 <lambdabot>      • In the second argument of ‘(||)’, namely ‘"hello"’
10:03:34 <Solonarv> it's lazy, but your example has nothing to do with laziness - that's a type error
10:04:01 <Solonarv> > True || error "boom" -- this doesn't throw an error
10:04:04 <lambdabot>  True
10:04:12 <Solonarv> > False || error "boom" -- this does
10:04:15 <lambdabot>  *Exception: boom
10:05:02 <superguest> :t error "boom"
10:05:03 <lambdabot> a
10:05:08 <Solonarv> > True || _
10:05:10 <lambdabot>  error:
10:05:10 <lambdabot>      • Found hole: _ :: Bool
10:05:10 <lambdabot>      • In the second argument of ‘(||)’, namely ‘_’
10:05:22 <Solonarv> this tells you that the second argument of (||) must be a Bool
10:05:33 <Solonarv> :t "hello"
10:05:34 <lambdabot> [Char]
10:05:52 <Solonarv> but "hello" is [Char], which is a different type than Bool
10:06:16 <superguest> Why is `error "boom" ` okay?  lambdabot tells us it's `a`
10:07:38 <Solonarv> `a` is a type variable, which means it can be replaced with any other type
10:08:39 <dmwit> I suppose there's two questions you might be thinking. One is "why is `error`'s return type so polymorphic?"; one is "why can we use a polymorphic value as a Bool?". Or maybe it's yet a third question.
10:09:54 <superguest> the application of `error boom` returns something of type `a` (a type variable)
10:11:12 <geekosaur> consider that a type signature is a contract between a function and its caller. here, "error" promises to produce any type the caller asks for
10:11:13 <superguest> dmwit, both
10:11:27 <geekosaur> (which it does by throwing an exception, because there are no values that fit)
10:12:08 <dmwit> superguest: Okay. I have a garden path I want you to walk down, but it's a few steps long.
10:12:18 <dmwit> superguest: So bear with me.
10:12:54 <dmwit> superguest: First: are you comfortable with giving infinite loops the type `a`? That is, are you happy believing that no matter what type you pick, I can write an infinite loop that, were it to finish, would produce a value of that type?
10:22:02 <superguest> so `error boom` is basically "Trust me for now"
10:23:45 <dmwit> I don't think so. But then I don't know what you mean by "trust", so...
10:25:35 <superguest> Tells the caller that it'll get the type it's looking for
10:25:44 <dmwit> (I'm still happy to walk down my garden path with you, by the way; but I do want to check in occasionally that we're still walking together, which motivates the question I asked above.)
10:26:26 <dmwit> Well, yes, that is what the type of `error` says.
10:26:55 <dmwit> I don't see that knowing the type answers your question, though, which I understood to be "why does it have that type?" not "what does that type mean?".
10:29:04 <superguest> dmwit, I think I understoood geekosaur answer more.  "error" _promises_ to produce any type the caller asks for.
10:29:33 <superguest> it didn't keep its promise, and then the error?
10:29:34 <geekosaur> part of the trick here is that types are compile time, but exceptions are run time
10:29:36 <dmwit> Okay. If you are satisfied with this, then I am happy.
10:29:59 <dmwit> If I were you I would not be satisfied. But I am not you, so anything follows from that condition. =)
10:30:02 <geekosaur> it kept its promise by thinking outside the box
10:30:43 <geekosaur> because whether it actually keeps it or not doesn't matter if that computation doesn't exist any more
10:31:01 * hackage ztar 0.1.0 - Creating and extracting arbitrary archives  http://hackage.haskell.org/package/ztar-0.1.0 (brandonchinn178)
10:32:14 <slack1256> How applicable are GHC notes documentation for other projects? I don't see why it isn't more popular
10:32:41 <slack1256> I guess it has the same problem of documentation getting out of sync with code it represents
10:33:03 <geekosaur> a shortcoming of it is indexing
10:33:22 <slack1256> the lack of a global index?
10:33:39 <slack1256> Or the cross references?
10:33:47 <geekosaur> both to some extent
10:34:13 <geekosaur> there've been multiplle "oh, that shold reference this note over here that you didn't know about" on the ghc devs list the past couple weeks, for example
10:35:46 <slack1256> I see, indeed it is annoying
10:35:59 <slack1256> those two are then the main problems
10:41:08 <dmwit> superguest: For what it's worth, I read `error "boom"` not as "trust me for now", but more like "you knew what you were getting into using a Turing complete language, now you get to suffer the consequences". Sort of the opposite of trust.
10:42:58 <dmwit> Specifically: every type has all the usual values of that type, plus an extra one (usually called "bottom") which represents infinite loops. So any time you have a term of a given type, you have to admit that it might eventually succeed at that type or it might loop forever.
10:43:25 <dmwit> `error` just hijacks that and forces you to admit that you'd be okay with the term failing before an infinite amount of resources have been wasted on looping.
10:45:27 <Ariakenom> dmwit: "But I am not you, so anything follows from that condition." I'm amused.
10:48:08 <malorie> is there a preferred/recommended regex package for haskell? I'm working with Text, and I'm trying to match some unicode strings
10:52:04 <Ariakenom> malorie: Are you sure you want regex, and have you considered a parser library?
10:52:45 <superguest> does Haskell do type-checking at compile time?
10:52:54 <Cale> superguest: Only, yes.
10:53:08 <Cale> superguest: Types don't exist at runtime.
10:53:49 <Cale> (though e.g. Typeable provides a way to keep around and make use of type information at runtime)
10:54:09 <doomrobo> Is there a way to define a type family that takes on kinds that aren't * ? In particular, I have type-level integers that I'd like to have an LCM type family for
10:54:25 <doomrobo> otherwise, a dummy class with an associated type works for me
10:55:32 <dmwit> malorie: I've enjoyed regex-tdfa for traditional uses and regex-applicative for parser-combinator-style uses.
10:55:39 <malorie> Ariakenom: well, my problem only requires the power of simple regular expressions. so I haven't considered a parser library yet.
10:56:04 <dmwit> doomrobo: Yes, you may declare the kind of a type family when you create it. You need some extension or other, but the compiler should tell you which one if you haven't already got it on.
10:56:17 <dmwit> KindSignatures, I think? I never bother to remember them all.
10:56:37 <Ariakenom> malorie: Allright good. I'm unfortunately not familiar with any
10:57:27 <superguest> Cale, can you explain the idea of bottom (⊥) " a value that represents infinite loops".  what's its purpose really?
10:57:51 <geekosaur> any time you have laziness, you have the potential for something to be infinitely lazy (i.e. never produce a value)
10:58:21 <doomrobo> thansk dmwit !
10:58:32 <geekosaur> bottom represents that condition. you don't normally worry about it in a strict context because if it can happen it will happen; but with laziness, it only *might* happen.
10:58:34 <superguest> geekosaur, thanks for being a straight-forward with your answers. :-)
10:58:37 <Solonarv> that doesn't require laziness, it'll happen in any turing-complete language
10:58:56 <Ariakenom> Or an exception? Why are we only talking about nontermination.
10:59:08 <geekosaur> for example, ([1..]) never terminates, but (take 3 [1..]) does. so it's not enough to look at a subpart.
10:59:34 <dmwit> Exceptions are just fancy observable nonterminations. ;-)
10:59:37 <geekosaur> (in a strict language, both never terminate)
11:00:09 <superguest> and thanks providing those examples, they really help
11:00:22 <Ariakenom> A reason for not talking about it is that statements don't have types in many other languages
11:00:33 <malorie> dmwit: thanks. googling for regex packages for haskell, I stumbled upon this: https://github.com/Gabriel439/slides/blob/master/regex/regex.md it basically claims to be way faster than regex-applicative, but hasn't been made into a package unfortunately, afaics
11:00:47 <geekosaur> so we do have to be able to reason about this, therefore we speak of "bottoms". (which term has to do with "definedness", which … is a bit complex. "bottom" is shorthand for "least defined value".)
11:02:31 <geekosaur> Haskell's type system doesn't know about nontermination or bottoms, except insofar as if anything claims to be able to produce a value of *any* type (like undefined or error do), it must produce bottom i.e. some form of nontermination
11:02:35 <geekosaur> :t forever
11:02:36 <lambdabot> Applicative f => f a -> f b
11:02:42 <geekosaur> another form of nontermination
11:03:48 <johnw> @src forever
11:03:48 <lambdabot> forever a = let a' = a >> a' in a'
11:03:49 <geekosaur> that one just keeps repeatedly applying an Applicative, with no way to stop (except something throwing an exception)
11:04:08 <johnw> guess that should be *> these days
11:04:13 <geekosaur> yes
11:04:26 <geekosaur> the @src database is manually curated, nobody's updated ut
11:04:27 <geekosaur> it
11:04:40 * johnw summons the great Curator
11:06:15 <geekosaur> anyway. one of the tricks here is that "bottom" isn't necessarily permanent in Haskell. it refers to *any* laziness that hasn't been forced. Bottoms that aren't forced don't cause loops or exceptions, which is why (take 3 [1..]) terminates
11:06:45 <johnw> i.e., undefined isn't a problem if you never need the definition?
11:07:04 <geekosaur> at any given time, the value of [1..] is a list whose final element is bottom, and as long as you don't try to completely enumerate the list this is not a problem
11:08:03 <geekosaur> first it's ⊥, then 1:⊥, then 1:2:⊥, then … extending by one item each time a value is demanded from it. so (take 3) never goes beyond demanding a third value, and the final ⊥ never "explodes"
11:09:06 <dmwit> uh
11:09:19 <dmwit> [1..] is not bottom, and never is.
11:09:32 <dmwit> There are no bottoms in [1..] at any time.
11:10:13 <dmwit> (Barring some stupid Num instance, since that is completely beside the point being made here.)
11:10:16 <geekosaur> at type Integer, its limit is available memory. which is outside your program
11:11:44 <glguy> I've never heard of bottom being used ot refer to an unevaluated expression
11:11:55 <geekosaur> ghci does so, for one
11:11:59 <Cale> dmwit: Well, there's a way of looking at evaluation in terms of producing an increasing sequence of values in the type, starting from _|_ and going upward as each constructor is discovered. I think that's what geekosaur is getting at.
11:12:12 <geekosaur> yes
11:12:19 <geekosaur> and conceptually [1..] is an infinite list
11:12:29 <geekosaur> at type Integer at least
11:12:34 <glguy> geekosaur: What do I need to type into GHCi to get it to do that?
11:13:06 <dmwit> glguy: :strace will print _ in place of thunks; this is probably what geekosaur is referring to.
11:13:14 <glguy> OK, but _ isn't bottom
11:13:23 <geekosaur> sorry, yes. I think it was one of the visualizers that used _|_ instead of _\
11:13:32 <geekosaur> but ghci uses hole syntax
11:13:40 <dmwit> glguy: Yes, this is my point, too. =)
11:13:49 <geekosaur> never mind, I see pointless pedantry wins yet again
11:13:55 <geekosaur> let's cause as much confusion as possible!
11:14:01 <glguy> The place I've seen _|_ used incrementally like that is when trying to show how many different ways a particular type can have undefined values
11:14:09 <glguy> but not simply to represent thunks
11:22:00 <nowhere_man> I'm reading the documentation of Control.Lens.Fold and Control.Lens.Indexed by I don't get how I'm supposed to use lenses to change a specific index in a list…
11:23:14 <Gurkenglas> > ix 2 +~ 1 $ [1..5]
11:23:16 <lambdabot>  [1,2,4,4,5]
11:31:51 <johnw> i often can't figure out how to use indexed lenses without trial and error either
11:33:26 <glguy> nowhere_man: You can make lenses with 'at' and traversals with 'ix' for manipulating various things. Perhaps take a look through the instance lists in Control.Lens.At 's documentation to see what all those can be used with
11:34:12 <glguy> johnw: Yeah, once you start mixing in  <. , .> , <.> , etc. things start to get quite fussy
11:34:30 * hackage non-empty-containers 0.1.0.0 -   http://hackage.haskell.org/package/non-empty-containers-0.1.0.0 (andrewthad)
11:34:37 <johnw> and the errors you get when you do it wrong... my goodness
11:39:48 <nowhere_man> thanks, I'll look there
11:50:00 * hackage language-docker 6.0.2 - Dockerfile parser, pretty-printer and embedded DSL  http://hackage.haskell.org/package/language-docker-6.0.2 (lorenzo)
12:00:20 <lukelau> Is it possible to derive MonadUnliftIO?
12:08:17 <Solonarv> lukelau: not in general, but it's possible with GeneralizedNewtypeDeriving
12:09:14 <nowhere_man> previously to importing Control.Lens, I didn't have access to ix
12:09:19 <nowhere_man> where is it defined?
12:09:34 <Gurkenglas> http://hayoo.fh-wedel.de/?query=ix says Data.Ix
12:09:45 <Gurkenglas> Wait, that's the wrong Ix :x
12:09:49 <Taneb> nowhere_man, Control.Monad.At
12:09:55 <Taneb> s/Monad/Lens
12:09:56 <Gurkenglas> says Control.Lens.At too
12:10:15 <nowhere_man> ha yes, At does the trick too
12:10:17 <nowhere_man> thx
12:11:11 <nowhere_man> I didn't know Hayoo
12:12:35 <cocreature> nowhere_man: you can also use the new hoogle https://hoogle.haskell.org/?hoogle=ix
12:13:33 <nowhere_man> I was using https://www.haskell.org/hoogle
12:13:42 <nowhere_man> not as useful as your one
12:16:10 <nowhere_man> Hmmm, the alpha version lacks type highlighting, that was a very useful feature
12:38:33 <cocreature> yeah the typesearch in the new hoogle is pretty bad but if you are just looking for an identifier, it is definitely the better choice
12:42:40 <maerwald> hayoo is better
12:58:08 <superguest> > data Fruit = Apple | Banana | Cherry deriving (Eq, Ord, Show)
12:58:10 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
12:59:35 <superguest> Anyway, my question is `..` is only for arithmetic sequences, right?
12:59:53 <fr33domlover> :t (..)
12:59:55 <lambdabot> error: parse error on input ‘..’
13:00:02 <superguest> i.e., [Apple  .. ] is wishful (silly thinking)
13:00:16 <fr33domlover> superguest, it's for types that are Enum instances
13:00:16 <dmwit> superguest: No, it is for any instance of `Enum`.
13:00:26 <fr33domlover> superguest, it can be your Fruit type too
13:00:29 <dmwit> ?let data Fruit = Apple | Banana | Cherry deriving (Show, Enum)
13:00:31 <lambdabot>  Defined.
13:00:32 <dmwit> > [Apple ..]
13:00:34 <lambdabot>  [Apple,Banana,Cherry]
13:01:02 <dmwit> > [Apple..] -- fun and common failure mode
13:01:04 <lambdabot>  <hint>:1:9: error: parse error on input ‘]’
13:01:20 <superguest> derived instance is a fantastic creation
13:01:27 <superguest> just like that. ^^
13:01:31 <dmwit> > enumFrom Apple
13:01:34 <lambdabot>  [Apple,Banana,Cherry]
13:01:58 <dmwit> (There is also `enumFromTo` and `enumFromThenTo`.)
13:02:09 * hackage self-extract 0.3.0 - A Haskell library to make self-extracting executables  http://hackage.haskell.org/package/self-extract-0.3.0 (brandonchinn178)
13:03:22 <dmwit> [a ..] -> enumFrom a; [a .. b] -> enumFromTo a b; [a, b ..] -> enumFromThen a b; [a, b .. c] -> enumFromThenTo a b c
13:04:01 <Zipheir> Hi all. If I'd like to have long and short formats for displaying a type, is there any elegant Show magic to do this?
13:04:23 <johnw> Zipheir: for any type, no; for your type, you could write long and short functions
13:05:12 <Zipheir> johnw: Right.
13:06:12 <dmwit> ?hackage ipprint Zipheir
13:06:13 <lambdabot> http://hackage.haskell.org/package/ipprint Zipheir
13:06:26 <Cale> Zipheir: usually I tend to stick to the convention that Show instances should pretty much always be the derived ones, since it's useful for debugging that the result is valid Haskell code.
13:06:51 <Cale> But nothing is stopping you from writing other functions for converting things into text of course :)
13:08:15 <Zipheir> Cale: That does seem like a good practice.
13:08:38 <Zipheir> dmwit: Looks useful, thanks.
13:16:16 <superguest> dmwit, just a small question.  When you showed: enumFrom a; [a .. b]
13:16:40 <superguest> shouldn't it be enumFrom a; [a .. a] ?
13:16:54 <superguest> since elements of a list must be of the same type?
13:17:20 <superguest> and that `a` denotes `b` I presume to be a different type
13:17:25 <glguy> superguest: a isn't intended to be a type variable in that
13:17:45 <glguy> Those are both value-level variables
13:18:01 <glguy> :t enumFrom
13:18:03 <lambdabot> Enum a => a -> [a]
13:18:17 <glguy> :t enumFromTo
13:18:18 <lambdabot> Enum a => a -> a -> [a]
13:18:34 <glguy> but the syntax [a .. b] desugars to the expression (enumFromTo a b)
13:19:36 <glguy> :t \a b -> [a .. b]
13:19:37 <lambdabot> Enum a => a -> a -> [a]
13:19:57 <glguy> the 'a' in the expression and the one in the type are different 'a's
13:20:27 <glguy> :t \x y -> [x .. y]
13:20:28 <lambdabot> Enum a => a -> a -> [a]
13:25:30 <nowhere_man> I got a <<loop>> issue with my program, I'm not sure how to get around it
13:25:38 <nowhere_man> the cleanest way, at least
13:25:57 <fishythefish> nowhere_man: probably by eliminating the loop, but it's hard to say more without seeing code
13:25:58 <nowhere_man> I'm building an array for a dungeon map (doing Code of Kutulu on CodinGame)
13:26:39 <nowhere_man> I transform an Array of chars to an Array of Cells (data Cell = Cell CellType [Cell])
13:27:29 <nowhere_man> I use array with a list comprehension for all possible indices
13:27:54 <nowhere_man> and for each couple of coordinates, I create a Cell with the 4 adjacent cells
13:28:01 <nowhere_man> up to that point, it works
13:28:47 <nowhere_man> but if instead I create each cell as Cell type $ filter isNotWall adjacents, then I get <<loop>>
13:29:11 <glguy> nowhere_man: You can use a profiling build to get some stack trace information when your program loops
13:29:27 <glguy> running it afterward with: ./YourProgram +RTS -xc
13:29:51 <nowhere_man> I guess I can build the Array twice, first with all 4 connections, then twice with filtering, is there a better way?
13:33:08 <fishythefish> nowhere_man: can you provide the actual code? right now, we're guessing at how you've defined/implemented everything
13:33:11 <fishythefish> @where lpaste
13:33:11 <lambdabot> http://lpaste.net/
13:37:46 <statusfailed> I found this library ixset-typed, which is a bit like a Map with multiple indexes - does anyone know of similar/alternative libraries?
13:38:38 <nowhere_man> fishythefish: https://lpaste.net/344124749829373952
13:39:49 <nowhere_man> glguy: I tried -O t GHC
13:40:07 <nowhere_man> ha, crap
13:40:15 <nowhere_man> I typed +RTC, not +RTS
13:41:01 <nowhere_man> glguy: what is -xc supposed to be?
13:41:11 <nowhere_man> the runtime doesn't know about it
13:41:31 <glguy> It won't know about it unless you use a profiling build
13:42:49 <nowhere_man> ha, sorry, it says I didn't use -prof
13:43:10 <glguy> e.g.: cabal new-run --enable-profiling YourProgram -- +RTS -xc
13:43:30 <nowhere_man> yeah, now I'm missing the profiling-enabled Prelude
13:43:51 <glguy> Maybe you installed GHC through your package manager and your package manager splits that out
13:44:06 <glguy> It's better not to use the package-manager provided packages for your own development
13:44:28 <fishythefish> nowhere_man: the issue is that in charGridToCells, in order to define `map`, you call `mkCell` on each pair of coordinates, but `mkCell` is defined in terms of `passages`, which looks up cells in `map`, which is defined in terms of `mkCell`, ...
13:45:45 <nowhere_man> fishythefish: do you know any tutorial on how to do this kind of thing properly? I'm guessing it's a common enough idiom with immutable data structures
13:46:30 <nowhere_man> I had identified the culprit but I don't know how to fix it
13:47:58 <lukelau> Is it possible to have a timeout for awaiting in a ConduitT?
13:48:59 <lukelau> I tried using unliftIO + system.timeout, but as it turns out UnliftIO can’t operate on transformers with continuations
14:08:20 <glguy> lukelau: I'd expect that you'll need to make a custom conduit source that can respond to requests for a certain number of bytes along with a timeout
14:09:25 <pdxleif> Kinda wondering why this CSV library is in terms of ByteString, and comments like "Uses UTF-8 encoding." on http://hackage.haskell.org/package/cassava-0.5.1.0/docs/Data-Csv.html#t:ToField weird me out. What is CSV if not text?
14:12:46 <superguest> I remember there being a way (a function? something along the lines of upperBound? ) to check the max value of a numeric type
14:13:10 <dminuoso> :t maxBound
14:13:11 <lambdabot> Bounded a => a
14:17:16 <superguest> geekosaur, For `[1..3]` "first it's ⊥, then 1:⊥, then 1:2:⊥, then … extending by one item each time a value is demanded from it. so (take 3) never goes beyond demanding a third value, and the final ⊥ never "explodes"
14:17:38 <superguest> So does it explode after `maxBound :: Int` ?
14:18:03 <superguest> opps
14:18:11 <superguest> I meant for `[1..]`
14:18:23 <geekosaur> no, because most CPUs don't provide a good way to check for that; it wraps.
14:18:43 <geekosaur> (Nasty practicalities getting in the way of a nice mathematical construct…)
14:19:10 <geekosaur> by default it'll use type Integer… which will explode by running out of memory
14:19:49 <geekosaur> (It could check it manually, but then every math operation on Integer has to do so. But the whole point of Int as opposed to Integer is speed.)
14:19:56 <geekosaur> er, on Int has to do so
14:21:32 <dminuoso> superguest: What is ⊥ supposed to denote in there? Thunks?
14:21:52 <geekosaur> yes
14:22:08 <geekosaur> ghci represents that as _ instead
14:23:09 <superguest> geekosaur, so the idea is really if you try to approach bottom, your machine will explode (or wraps) before you reach there.
14:23:13 <superguest> ?
14:23:56 <geekosaur> at that point it *has* reached therer. bottom is any form of nontermination: the expresson doesn;t produce a result, instead something else happens.
14:24:20 <dminuoso> superguest: In Haskell a function is a referentially transparent mapping between values right?
14:24:21 <geekosaur> exception, infinite loop, system starts thrashing because it's out of memory, whatever
14:24:37 <dminuoso> superguest: But if a function always maps a value to another, then what does `length [1..]` map to?
14:25:15 <dminuoso> Or what does `[1] !! 5` map to?
14:25:40 <superguest> it'll through an out-of-bounds exception?
14:25:44 <superguest> err, throw
14:26:12 <superguest> but I didn't answer your question: "what does it map to"
14:26:14 <superguest> ?
14:26:17 <superguest> I don't know heh
14:26:21 <superguest> :p
14:27:24 <glguy> dminuoso: those map to bottom
14:27:29 <geekosaur> nontermination via exception, hence bottom
14:27:51 <dminuoso> glguy: That was a rhetorical question for superguest =)
14:31:22 <superguest> Yet another newbish follow up question: If these enumerables, how do you determine non-termination ?  It just keeps going until you pull the plug right?
14:31:43 <superguest> these are* enumerables
14:31:57 <dminuoso> superguest: You can't, that's the halting problem.
14:32:14 <dminuoso> Which is why you cant test for bottom.
14:37:57 <wchresta> So I see a lot of newtypes defined in this runA fashion: newtype A = A { runA :: B }. What's up with that? Why is runA a good idea?
14:38:39 <lyxia> it's shorter than declaring a separate function
14:38:59 * hackage alarmclock 0.5.0.0 - Wake up and perform an action at a certain time.  http://hackage.haskell.org/package/alarmclock-0.5.0.0 (dcturner)
14:39:17 <MRd1> ...
14:39:21 <dminuoso> wchresta: `run` is freque
14:39:24 <dminuoso> ops.
14:40:22 <mpahrens> A lot of monad transformers are written that way, where `to run` means to evaluate to something in the inner context. newtype FooT m a = Foo { runFoo :: (m a) }. Maybe it is carried over from that where the `m` in this case is an implicit Identity?
14:55:20 <hexagoxel> ConnectionFailure (hackage.fpcomplete.com/package/hspec-expectations-0.8.2.tar.gz) .. is there some outage i should be aware of?
15:01:05 * geekosaur has no idea what, if any, monitoring fpco has
15:01:39 <hexagoxel> nevermind, the restarted job ran through, even though the automatic retries failed before.
15:19:13 --- mode: ChanServ set +o monochrom
15:19:28 --- mode: monochrom set -o monochrom
15:22:27 <nowhere_man> I do `case something of Entity {bar=foo} -> True
15:22:37 <nowhere_man> _ -> False
15:22:53 <nowhere_man> why is the second pattern redundant?
15:23:02 <nowhere_man> the first wouldn't match every Entity
15:26:18 <butterthebuddha> Is there a Map-like type where the value type is allowed to be different for each entry?
15:26:21 <geekosaur> yes it does, you captured the bar field of an Entity into local binding foo
15:27:03 <zachk> butterthebuddha, either use a algebraic sum type, or something like Dynamic
15:27:37 <geekosaur> there's at least one dependent map package on hackage iirc
15:28:39 <nowhere_man> it worked when foo was a string, not a variable
15:28:54 <nowhere_man> how can I filter records based on a value of a field, then?
15:28:57 <geekosaur> yes. constructors and literals match. variables capture and bind
15:29:01 <geekosaur> use a guard
15:30:30 <nowhere_man> ha yes, I see
15:30:47 <glguy> butterthebuddha: There's also DMap from http://hackage.haskell.org/package/dependent-map-0.2.4.0/docs/Data-Dependent-Map.html if you're doing something particularly complicated, but the sum-type like zachk mentioned is the straight-forward solution
15:31:31 <butterthebuddha> I'm gonna try and see if there is a simpler way of doing what I'm trying to do; if I can't figure anything out I'll ask you peeps later
15:31:39 <zachk> you could use lens and prisms from the lens package to access and mutate the values in your Data.Map if you use a sumtype
15:31:56 <ttoe> Hey there. in for-loops i can include print statements (e.g. to show progress) ... is there a 'map'like that can print something on every iteration?
15:32:19 <butterthebuddha> ttoe: I'm not sure what you're trying to do, but take a look at trace
15:32:30 <geekosaur> mapM / mapM_ or traverse / traverse_
15:34:31 <zachk> ttoe, mapM_ print [1..10] will print 1-10, I use mapM_ quite a bit
15:34:39 <hexagoxel> or for/for_
15:34:45 <ttoe> butterthebuddha: basically... for x in longlist: print("processing " ++ x); doheavylifting(x)
15:35:02 <Cale> forM_ [1..10] $ \n -> do
15:35:04 <Cale>   print n
15:35:49 <Cale> Or indeed, you can lose the _ and the results of each action will be collected into a list, which will be the result of the entire forM
15:36:50 <hexagoxel> so many ways of doing the same thing, thanks to the AMP :)
15:36:58 <ttoe> Cale: would the IO be collected somehow into the result?
15:37:20 <ttoe> i would not want that :D
15:37:36 <boj> ttoe: the _ version drops what is collected
15:38:10 <ttoe> I have many options to look at, as it seems. Thank you all!
15:38:46 <boj> > mapM return [1..10]
15:38:48 <lambdabot>  error:
15:38:48 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M388769049369...
15:38:48 <lambdabot>        prevents the constraint ‘(Show (m0 [Integer]))’ from being solved.
15:38:55 <boj> ah yeah
15:43:23 <hexagoxel> ttoe: really, there are only the two, traverse and traverse_. All other are either flipped versions of that or more specific (Monad instead of Applicative) (and mostly artefacts of pre-AMP times).
15:49:32 <ttoe> hexagoxel: Alright! I'll have a look in the source!
15:52:23 <Cale> ttoe: actually, let's have a quick look at something more basic than that
15:52:46 <Cale> ttoe: There's a function called sequence (actually, if you look at it now it'll have a slightly more general type, but I'll describe the one for lists)
15:53:09 <Cale> sequence :: [IO a] -> IO [a] -- in fact, let's specialise it to IO as well
15:53:41 <Cale> Its job is to take a list of IO actions then, and produce a single IO action which when executed, will run each of the actions in the list, and collect up a list of their results.
15:54:12 <Cale> sequence [] = return [] -- if the list of actions is empty, we'll just produce the action which does nothing, except to produce an empty list as its result
15:54:28 <Cale> sequence (x:xs) = do ... -- if the list is nonempty
15:54:56 <Cale> sequence (x:xs) = do v <- x; ... -- we'll execute the first action in the list, getting some result v
15:55:24 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ... -- and then execute the remainder of the actions in the list, getting some list of results vs
15:55:50 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs) -- and produce the combined list (v:vs) as our result
15:56:43 <Cale> ttoe: sequence is like a primordial loop of sorts: if we can decide ahead of time what's to be done on each iteration of a loop, and produce a list of those actions, it will glue them together into a single action
15:56:53 <Cale> So with that, we can write mapM:
15:57:01 <Cale> mapM f xs = sequence (map f xs)
15:57:10 <Cale> and forM is just mapM with the arguments flipped
15:58:00 <ttoe> that's cool
15:58:07 <ttoe> thanks!
16:01:14 <butterthebuddha> Which of the Except monad and the Either monad is preferred for error handling?
16:02:14 <ttoe> Cale: does this then have the "foldl-problem" of building up a huge list of ..hmm don't know the name... list of unevaluated stuff until 'xs' is empty?
16:03:50 <nowhere_man> I wrote a quick `annotate f x = (x, f x)`
16:04:01 <nowhere_man> doesn't that exist already in the base libraries?
16:04:33 <hpc> :t \f -> id &&& f
16:04:35 <lambdabot> (b -> c') -> b -> (b, c')
16:05:52 <Cale> ttoe: Well, it's not going to build up unevaluated expressions, because all the expressions it's constructing are built out of data constructors (specifically the (:) constructor for lists)
16:06:03 <Cale> Of course, it will be constructing that list, but you probably wanted it to
16:06:32 <hpc> nowhere_man: (&&&) is from Control.Arrow, so it's simple enough to compose from other things that it doesn't need its own definition
16:06:36 <Cale> If you don't want it to build a list, that's what the underscored versions are for -- there's a sequence_ which simply ignores the result of the actions, and produces () regardless.
16:07:11 <XenOmega> \x -> \y -> ?x
16:07:24 <XenOmega> the type would be a->b -> (c->a) ?
16:07:32 <hpc> :t \x -> \y -> ?x
16:07:33 <lambdabot> (?x::t) => p1 -> p2 -> t
16:07:48 <Solonarv> sequence_ also doesn't require Traversable, Foldable is enough
16:07:55 <Solonarv> :t sequence
16:07:57 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
16:07:57 <Solonarv> :t sequence_
16:07:59 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
16:07:59 <Cale> Did you mean to put that question mark there? That's an implicit parameter?
16:08:49 <XenOmega> the question ? is something that takes x as argument!
16:08:56 <Cale> ahh
16:09:09 <hpc> you're thinking of const, probably
16:09:12 <hpc> > const x y :: Expr
16:09:15 <lambdabot>  x
16:09:17 <hpc> :t const
16:09:19 <lambdabot> a -> b -> a
16:09:24 <Cale> Well, it'll be hard to tell what the type of that lambda expression is without knowing the type of ? then
16:09:26 <hpc> :t \x -> \y -> const x
16:09:27 <lambdabot> a -> p -> b -> a
16:09:44 <ttoe> Cale: i understand... thanks. i have a mwe running, so thanks for all the help
16:09:52 <XenOmega> trying to find the answer for my ,mock exam :(
16:10:02 <XenOmega> for example : [?, 1], ? is int
16:10:16 <hpc> oh
16:10:27 <Cale> XenOmega: Ohhh, you want the type of the thing which would go in place of the question mark?
16:10:40 <Cale> XenOmega: do you know what type the lambda itself ought to have?
16:10:49 <XenOmega> yeah
16:10:51 <XenOmega> no undefined
16:10:59 <XenOmega> which is why im using a generic type of a!
16:11:01 <Cale> XenOmega: we know that the ? must be of some function type
16:11:25 <hpc> does lambdabot have holes?
16:11:28 <XenOmega> yeah. And since we defined x as "a" type, then something a -> ?
16:11:29 <Cale> and that its domain type matches the type of x
16:11:38 <Cale> yeah
16:12:01 <Cale> We don't know anything at all about the type of its result
16:13:02 <Cale> :t \f -> (\x -> \y -> f x)
16:13:03 <lambdabot> (t1 -> t2) -> t1 -> p -> t2
16:13:22 <Cale> :t \x -> \y -> ?f x
16:13:24 <lambdabot> (?f::t1 -> t2) => t1 -> p -> t2
16:13:31 <Solonarv> \x -> y -> _hole x
16:13:47 <Solonarv> @let foo = \x -> y -> _hole x
16:13:47 <lambdabot>  Parse failed: Parse error: ->
16:13:54 <Solonarv> @let foo = \x -> \y -> _hole x
16:13:55 <lambdabot>  .L.hs:167:21: error:
16:13:55 <lambdabot>      • Found hole: _hole :: t -> t1
16:13:55 <lambdabot>        Where: ‘t’ is a rigid type variable bound by
16:13:57 <Solonarv> THERE
16:14:30 <lukelau> Is it possible to create an exception that sometimes takes in a type argument? Something like this: https://lpaste.net/2082178296602165248
16:15:57 <hpc> lukelau: that always needs a type signature
16:16:08 <hpc> it's not taking a type argument, you're just saying what type A has in that particular use
16:17:05 <lukelau> hpc: Is there any known pattern for dealing with this?
16:17:34 <lukelau> I don’t want to have to make an alias like `A = (A’ :: Foo ())
16:18:07 <hpc> in this case, GADTs if you know A is always going to have the type Foo ()
16:18:13 <hpc> data Foo a where
16:18:16 <hpc>   A :: Foo ()
16:18:20 <hpc>   B :: a -> Foo a
16:18:39 <hpc> not sure if that can still derive Show though
16:19:30 <hpc> there's a few other options, but for the most part you don't want to be wildly polymorphic in places where you're affected by class constraints
16:20:05 <hpc> instance resolution has requirements that make that infeasible most of the time
16:21:20 <lukelau> I don’t care what type A ends up with
16:21:39 <hpc> hmm
16:21:45 <lukelau> But GADTs seemed to do the trick
16:21:49 <hpc> that should still work yeah
16:22:14 <hpc> oh yeah
16:22:29 <hpc> i forget, are GADTs in haskell2010?
16:22:55 <electrocat> hpc: nope
16:22:56 <hpc> they should probably get folded in with the next standard revision imo
16:23:18 <hpc> or at least GADTSyntax
16:23:32 <hpc> i am increasingly convinced that it's a strictly better syntax than standard for defining data types
16:23:42 <hpc> even for new users
16:23:49 <hpc> especially for new users
16:23:59 <electrocat> sure, but the limits of ADTs are clearer with their syntax
16:24:11 <hpc> hmm, yeah
16:24:21 <mniip> what a dilemma
16:24:27 <hpc> but on the other other hand, teaching GADTs is even easier
16:24:31 <mniip> in 8.6.0 TypeOperators implies NoStarIsKind
16:24:41 <electrocat> hpc: look, their basically functions
16:25:41 <electrocat> i would agree putting GADTs in the language, but their inference can be weird at times
16:25:43 <lukelau> Is there any sticking point/reason why GADT syntax is an extension and not in haskell2010 already?
16:25:46 <hpc> i guess ADT syntax translates a bit more cleanly into algebraic notation
16:26:10 <lukelau> hpc: Yeah, it makes it more obvious the sum and product types
16:26:14 <hpc> electrocat: hmm, i guess that's a good reason to keep them out
16:26:27 <hpc> it just about automatically requires the (~) constraint
16:26:45 <geekosaur> lukelau, the language committee was … conservative. And eventually fell apart.
16:27:32 <geekosaur> I wouldn't expect full GADTs to go in, as just discussed, but I think GADT syntax for ADTs could make it into the next standard.
16:27:55 <hpc> yeah, that makes sense
16:28:37 <electrocat> i doubt that would happen, i don't think that many people purely use the syntax, it doesn't add any significant power
16:28:52 <electrocat> or convenience
16:28:55 <geekosaur> quite a few people think it's clearer than H'98 synytax
16:31:01 <electrocat> were there some plans for making a new standard?
16:31:19 <lukelau> hpc: Ok this is starting to get hairy, getting more typeable errors when using `anyFoo` exception handlers. I think I’ll just use concrete types…
16:33:14 <hpc> anecdotally, when i was first learning haskell it took me a few hours to get past "data Maybe a = Nothing | Just a"
16:34:10 <hpc> i couldn't get myself to read it as "data <type> <type> = <value> | <value> <type>"
16:34:33 <hpc> but "data <type> <type> where <value> :: <type>" you see all the time
16:34:49 <mniip> that feel when you don't need to google the git repository for a package
16:35:00 <hpc> :t id -- if you can read this, you can learn the GADTSyntax definition of Maybe
16:35:02 <mniip> because the package name is contrived enough you know it's ekmett
16:35:02 <lambdabot> a -> a
16:35:23 <hpc> er, id :: a -> a
16:35:41 <hpc> mniip: hackage links to project homepages
16:36:18 <mniip> yes but that requires changing to another window
16:37:15 <geekosaur> electrocat, yes, there's a new language committee working on Haskell2020
16:37:21 <butterthebuddha> Can I get guarantees regarding the constructor of the returned value of a function?
16:37:38 <electrocat> geekosaur: is there some way to follow their progress?
16:38:02 <zachk> butterthebuddha, what do you mean? a specific constructor from a sum type?
16:38:08 <butterthebuddha> zachk: Yes
16:38:25 <geekosaur> electrocat, http://mail.haskell.org/pipermail/haskell-prime/
16:38:27 <zachk> that would require subtyping and it's not supported
16:38:37 <electrocat> geekosaur: tnx
16:38:42 <butterthebuddha> Okay :(
16:38:50 <zachk> also some forms of subtyping iirc break type inference
16:38:57 <butterthebuddha> Is this something that could be added to GHC in the future?
16:40:20 <zachk> probably not, but I don't know enough of the theory of type inference and subtyping to say for sure, if dependent types ever make it into haskell you might be able to do it, but that also breaks type inference
16:40:30 <geekosaur> there is some work toward a DependentHaskell. it won't be happening soon.
16:40:31 <dyl> butterthebuddha: you could use phantom types and tagging with GADTs
16:40:41 <dyl> Just have a phantom type per constructor :p
16:40:45 <dyl> But that’s rather silly.
16:41:06 <hpc> DataKinds!
16:41:23 <dyl> Oh, yeah, you could also use kinds.
16:41:25 <hpc> data Foo = A Int | B String | C Bool
16:41:38 <hpc> data FooToken = AToken | BToken | CToken
16:41:55 <hpc> data BetterFoo token where A :: Int -> BetterFoo AToken; ...
16:42:17 <hpc> add in a kind signature somewhere, /me is sleepy
16:43:48 <butterthebuddha> This looks cool
16:43:53 <butterthebuddha> I'll take a look at it
16:46:11 <hpc> butterthebuddha: i suggest considering if you need that level of guarantee before you go implementing it, since it adds a type parameter to BetterFoo
16:46:29 <hpc> so you'll have lots of function :: BetterFoo a -> BetterFoo b -> BetterFoo c floating around
16:46:50 <hpc> or god forbid, [forall a. BetterFoo a]
16:46:51 <butterthebuddha> hpc: it's not essential, so if the boilerplate becomes too excessive, i might just not do it
16:47:00 <hpc> cool
16:52:55 <mniip> so I've updated yahb to 8.6 which is supposed to bring new typesystem tricks :D
16:54:05 * hackage wasm 1.0.0 - WebAssembly Language Toolkit and Interpreter  http://hackage.haskell.org/package/wasm-1.0.0 (irezvov)
16:55:29 * hackage riak 1.1.2.5 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-1.1.2.5 (lambda_foo)
16:56:51 <butterthebuddha> so https://lpaste.net/3608359564770017280
16:56:57 <butterthebuddha> Any suggested improvements to that code? I can provide more context if needed
16:58:30 <mniip> while I'm at it does anyone have any suggestions on what extra packages I could install
16:59:09 <fishythefish> butterthebuddha: personally, I find that amount of indentation hard to read
16:59:28 <fishythefish> I would also handle the yss stuff via pattern matching all at once rather than checking the length and then indexing repeatedly
17:01:16 <fishythefish> similarly, you could do `llp_eval env <pattern> = ...` rather than having the explicit `case ast of`
17:01:24 <mniip> %% :!../usr/bin/ghc-pkg list
17:01:25 <yahb> mniip: http://qp.mniip.com/y/62
17:01:34 <mniip> any suggestions to the above list^ :p
17:05:35 <Tuplanolla> Add `inline-c` and `inline-java`, mniip.
17:05:39 <fishythefish> butterthebuddha: also, I'm not sure how your Result type is defined, but I think you have a case of inexhaustive patterns
17:06:45 <Tuplanolla> Perhaps even replace or supplement `parsec` with `megaparsec`.
17:06:58 <butterthebuddha> fishythefish: llp_eval_ast is guaranteed to return a value of constructor List if passed in a value of constructor "
17:07:02 <butterthebuddha> constructor L*
17:07:37 <butterthebuddha> https://lpaste.net/2303384170501505024
17:09:09 <mniip> Tuplanolla, inline-c requires a working gcc
17:09:13 <mniip> which I do not posess
17:11:24 <mniip> I assume inline-java is similar
17:15:55 <lyxia> mniip: quickcheck?
17:18:14 <lyxia> constraints
17:26:04 <zachk> what happened to lpaste.net , it looks half finished/broken
17:32:26 <mniip> zachk, it's a redesign
17:32:37 <mniip> it's "fashion", you wouldn't know about that
17:33:19 <zachk> oh ok
17:39:08 <nowhere_man> why can't I have `data Foo = Foo {baz::Int}` and `data Bar = Bar {baz::Int}`?
17:39:31 <nowhere_man> could baz have type a -> Int ?
17:39:36 <mniip> no
17:39:47 <mniip> 'a -> Int' means 'forall a. a -> Int'
17:40:19 <mniip> in you case baz would only work for two types in place of 'a' hence a bare forall is inapppropriate
17:40:41 <nowhere_man> couldn't there be an implicit typeclass?
17:41:16 <nowhere_man> ha, but I couldn't type it, then
17:41:41 <mniip> an implicit typeclass is a solid idea actually. One that's actually already discussed
17:41:52 <nowhere_man> ho
17:41:57 <DigitalKiwi> what would you like on lpaste.net 20 ads a la pastebin?
17:42:07 <mniip> you could have baz :: Has "baz" a t => a -> t
17:42:18 <nowhere_man> nice
17:42:24 <mniip> with  class Has (s :: Symbol) (a :: *) (t :: *) | a -> t
17:42:27 <mniip> err
17:42:30 <mniip> s a -> t
17:43:30 <mniip> nowhere_man, https://github.com/adamgundry/ghc-proposals/blob/75d629038104c73ac9ba19cb8b864388a58a5da8/proposals/0000-overloaded-record-fields.rst
17:43:49 <mniip> (still only a proposal though)
17:47:09 <mniip> lyxia, added constraints and quickcheck
17:48:33 <lyxia> nice!
17:56:37 <mniip> anyway ghc now has cool stuff
17:56:52 <geekosaur> it's more than a proposal, but not fully implemented
17:57:00 <geekosaur> parts are there
17:57:19 <mniip> the cool stuff I am talking about right now is QuantifiedConstraints
17:57:26 <mniip> if that's what you're replying to
17:59:20 <mniip> % foo :: (forall a. Eq a => Eq f a, Functor f) => f a -> f b -> Bool; foo x y = fmap (const ()) x == fmap (const ()) y
17:59:20 <yahb> mniip: ; <interactive>:2:27: error:; * Expected kind `* -> Constraint', but `Eq f' has kind `Constraint'; * In the type signature: foo :: (forall a. Eq a => Eq f a, Functor f) => f a -> f b -> Bool; <interactive>:2:30: error:; * Expecting one more argument to `f'; Expected a type, but `f' has kind `* -> *'; * In the first argument of `Eq', namely `f'; In the type signature: foo :: (f
17:59:24 <mniip> oop
17:59:32 <mniip> % foo :: (forall a. Eq a => Eq (f a), Functor f) => f a -> f b -> Bool; foo x y = fmap (const ()) x == fmap (const ()) y
17:59:32 <yahb> mniip:
17:59:46 <mniip> % foo "hello" [1,2,3,4,5]
17:59:46 <yahb> mniip: True
17:59:48 <mniip> % foo "hello" [1,2,3,4]
17:59:48 <yahb> mniip: False
18:05:26 <pdxleif> Is there an attoparsec thing to match "empty string"? Should I just use `string ""`?
18:05:39 <lyxia> return ()
18:05:51 <mniip> pure ()
18:08:33 <pdxleif> Err, I want it to succeed only if there's no more input - like if the entire input is just the empty string.
18:09:01 <lyxia> endOfInput
18:10:06 <pdxleif> Ah, thanks!
18:34:59 * hackage turtle 1.5.9 - Shell programming, Haskell-style  http://hackage.haskell.org/package/turtle-1.5.9 (GabrielGonzalez)
18:45:30 * hackage eap 0.9.0.2 - Extensible Authentication Protocol (EAP)  http://hackage.haskell.org/package/eap-0.9.0.2 (erick)
19:17:59 * hackage menoh 0.1.0 - Haskell binding for Menoh DNN inference library  http://hackage.haskell.org/package/menoh-0.1.0 (MasahiroSakai)
19:27:06 <superguest>  /j #math
19:34:32 <enterprisey> In f <$> a <*> b <*> c, do we know that a, b, and c happen left-to-right?
19:34:41 <enterprisey> for example, if f is a constructor and a, b, and c are parser combinators
19:37:31 <geekosaur> Applicative would be pretty useless for IO if it didn't
19:37:54 <enterprisey> ty
19:38:01 <enterprisey> also that makes sense, lol
19:38:39 <geekosaur> (also for parsers, for that matter — but Applicative grew out of parsers. So you'd kinda expect it to do the right thing)
19:42:39 <monochrom> Applicative alone doesn't come with an expectation on effect order.  However, if a type is both an Applicative and a Monad, then we do expect <*> to be a special case of >>=, and then you have an effect order.
19:44:16 <monochrom> But even then the Tardis monad can mess with your mind.
19:45:17 <enterprisey> after looking into that monad a bit, I agree
19:54:49 <MRd1> Hi...
19:56:01 <MRd1>      
19:58:43 <monochrom> OK, mrd1 is just trying to annoy me.
19:59:15 <monochrom> Maybe annoy all of us too, but I just want to speak for myself.  Regardless, I'll do a thing on behalf of all of us.
19:59:32 --- mode: ChanServ set +o monochrom
20:00:02 --- mode: monochrom set +b *!~MRd@182.1.*
20:00:07 --- mode: monochrom set -o monochrom
20:01:51 --- mode: ChanServ set +o monochrom
20:02:09 --- mode: monochrom set +b-o *!~MRd@114.125.* monochrom
20:04:13 * exio4 annoys monochrom carefully
20:05:13 <monochrom> Ah you're fine. Mrd1 have been haunting us for days. Because someone else was some kind to them. This is what you get when you're kind to people who don't even know what this channel is for.
20:05:30 <monochrom> s/some kind/kind/
20:06:01 <exio4> oh, well
20:06:44 <geekosaur> we had a brief inclux of trolls. this one's the most persistent of the lot
20:06:47 <geekosaur> influx
20:26:22 <DigitalKiwi> is this the channel for pascal?
20:39:46 <enterprisey> While I'm asking dumb questions about parser semantics, the Alternative instance for parsers also tries them left-to-right, right?
20:40:16 <enterprisey> nm it's infixl
20:47:10 <monochrom> infixl doesn't actually tell you what's done first, despite K-12 white lies.
20:47:22 <enterprisey> yup that occurred to me
20:47:32 <enterprisey> yeah I should probably dig into the megaparsec source more
20:47:50 <monochrom> But most library authors are not out to troll you.  Most people expect left-to-right, therefore most authors oblige.
20:48:06 <Solonarv> every instance I've run into has been left-to-right
20:48:11 <Solonarv> yeah what monochrom said
20:48:17 <enterprisey> solid
20:49:17 <zfnmxt> Is it possible to define an "empty" type in Haskell that consists exclusively of bottom?
20:49:30 <zfnmxt> (I'm guessing you can't actually have an empty, empty type without bottom)
20:49:49 <geekosaur> data Void -- ?
20:50:17 <zfnmxt> Oh cool :)
20:50:48 <monochrom> Haskell 2010 permits it.
20:51:13 <ClaudiusMaximus> there's -XEmptyDataDecls, and i think you can get the same effect with a recursive newtype if you don't want to use the extension for some reason
20:51:44 <geekosaur> only H'98 needs EmptyDataDecls, as monochrom said
20:51:48 <monochrom> EmptyDataDecls got absorbed into 2010.
20:51:51 <ClaudiusMaximus> nice :)
20:52:24 <monochrom> This is why the giants answer slowly. Because they check the docs first.
20:53:25 <ClaudiusMaximus> is newtype Void = V Void equivalent?  not 100% sure
20:53:37 <zfnmxt> data Void = Void !Void. Is the strictness just to enforce that Void (bottom) = bottom?
20:54:09 <zfnmxt> What if you just wrote Void = Void Void?
20:54:43 <ClaudiusMaximus> without the strictness you could have _|_, Void _|_, Void (Void _|_), ...
20:54:56 <ClaudiusMaximus> the strictness collapses it all down to just _|_
20:56:27 <zfnmxt> I'm not sure I see how that works.
20:56:57 <geekosaur> if you try to construct a Void with a bottom, you get a bottom immediately instead of a constructor containing a bottom
20:56:58 <zfnmxt> My understanding is that strictness doesn't say anything about how a function behaves except when evaluated on bottom.
20:57:23 <geekosaur> the ! there applies specifically when constructing a value
20:57:30 <geekosaur> not evaluation of it
20:57:39 <zfnmxt> Ah, right. Okay. I see.
20:58:15 <zfnmxt> That's funny, that you can't actually have values of type Void that include the constructor Void.
20:58:32 <Solonarv> well that's the entire point of the type!
20:58:44 <zfnmxt> I know! But still, pecuiliar :)
20:59:16 <geekosaur> enh, it's just a list without a head :p
20:59:32 <Solonarv> @let newtype VoidNewtype = VoidNewtype VoidNewtype
20:59:34 <lambdabot>  Defined.
20:59:34 <Cale> zfnmxt: Note that there is no data constructor Void
20:59:51 <Solonarv> @let foo = VoidNewtype foo
20:59:53 <lambdabot>  Defined.
20:59:57 <Cale> oh, sorry, I didn't see that you redefined it :)
21:00:04 <Solonarv> > foo
21:00:06 <lambdabot>  error:
21:00:06 <lambdabot>      • No instance for (Show VoidNewtype)
21:00:06 <lambdabot>          arising from a use of ‘show_M38720037077763516603688’
21:00:34 <Solonarv> blargh, shouldn't that not be inhabited by bottom?
21:00:36 <zfnmxt> Cale: Not sure I understand that either since if I write data Void = VoidConst !Void isn't VoidConst, semantically, a data constructor?
21:01:19 <Cale> Sorry, yes.
21:01:37 <Cale> Usually, the data declaration for Void doesn't define any data constructors
21:01:59 <Cale> I just hadn't seen that you'd defined Void differently than usual.
21:03:19 <zfnmxt> Ah, I see. I just took that definition from the source: https://hackage.haskell.org/package/void-0.7.1/docs/Data-Void.html
21:03:21 <Cale> The strictness annotation there just means that whenever your Void data constructor occurs in an expression, it will be replaced by (\x -> Void $! x)
21:04:43 <Cale> Oh, interesting that it doesn't use EmptyDataDecls, given that's the entire point of that extension :P
21:05:03 <monochrom> Because Haskell 2010 happened.
21:05:04 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-EmptyDataDecls
21:05:12 <enterprisey> Parser performance question: if I'm trying to parse ab*, where a and b are big classes, is it better to use satisfy >> takeWhileP, or takeWhile1P >> takeWhileP?
21:05:36 <enterprisey> Semantically, of course, the former wins
21:05:38 <Cale> oh, right, this is just in base now
21:05:47 <Cale> Nobody actually uses this package anymore
21:06:06 <Cale> https://hackage.haskell.org/package/base-4.11.1.0/docs/src/Data.Void.html#Void
21:07:48 <Cale> enterprisey: those don't seem equivalent
21:08:32 <enterprisey> oh right, I forgot to mention that a is a subset of b
21:08:34 <enterprisey> lol
21:08:35 <Cale> the latter would get you something more like a+b*, right?
21:08:48 <enterprisey> otherwise they would indeed not be equivalent
21:08:50 <Cale> hmm
21:09:27 <enterprisey> the use case here is identifiers in a lexer, specifically a Python lexer
21:10:51 <superguest> :t fromJust
21:10:52 <lambdabot> Maybe a -> a
21:12:04 <Cale> superguest: Just as a warning, usually you'd prefer to use a case expression, simply because if you ever happen to apply fromJust to Nothing, and your code uses fromJust more than once, you'll be pulling your hair out trying to find it
21:12:29 <Cale> Actually it's probably better to write (\(Just x) -> x) instead, since that'll at least give you a line number when it crashes
21:12:33 <Solonarv> I've taken to using `fromMaybe (error "some helpful error message")` instead of fromJust
21:12:47 <Cale> > (\(Just x) -> x) Nothing
21:12:49 <lambdabot>  *Exception: <interactive>:3:2-15: Non-exhaustive patterns in lambda
21:12:59 <Solonarv> assuming I actually want to throw on Nothing, of course
21:13:07 <enterprisey> Solonarv's tip helps a lot in larger functions, even if I just use line numbers
21:13:16 <Cale> ^^ convenient inclusion of module name and line number / column span
21:13:25 <enterprisey> if I'm going very fast, sometimes I just smash my hand on the keyboard and grep later
21:13:30 <Solonarv> hah
21:13:42 <Cale> That way, you don't even have to write a custom message with it
21:13:43 <enterprisey> this was deployed successfully in my last group project
21:13:53 <Cale> similarly with stuff like (\(x:xs) -> x)
21:14:10 <Cale> it's always better to write that than to write 'head' except in particular idioms
21:14:13 <nitrix> Part of me wants fromJust to not exist and let people pattern match when that's their intention :(
21:14:30 <enterprisey> nitrix: begone, boilerplate :p
21:14:39 <Solonarv> or just rename it to reallyUnsafeFromJust
21:14:44 <enterprisey> it's like when I see Rust codebases full of if let's
21:15:08 <Solonarv> or remove fromJust and introduce fromJustOrError = fromMaybe . error ;)
21:15:11 <nitrix> I guess, but we have nicer things like MaybeT and stuff.
21:15:28 <enterprisey> true, true
21:15:41 <enterprisey> although my recent trend is to ditch taller stacks as much as possible
21:16:01 <enterprisey> in the parser I'm writing right now, I figured out how to eliminate the last bit of state, so I can ditch transformers entirely
21:16:38 <Solonarv> my current project (a game) just uses ReaderT / MonadReader and isomorphic monads
21:16:50 <enterprisey> sounds like fun
21:17:25 <enterprisey> at one point, we were doing complicated distributive laws in category theory class while writing our group project using them
21:17:52 <enterprisey> we never thought we'd be applying anything from that class haha
21:17:57 <Solonarv> I got pretty frustrated trying to get some C dependencies (namely, sdl2-gfx) working; I ended up just dropping it
21:18:14 <Solonarv> apecs is cool though
21:20:21 <superguest> I think fromMaybe is a good solution, but how might I use `case` to check for `Nothing` ?
21:21:45 <nitrix> > case Nothing of Nothing = "superguest"
21:21:47 <lambdabot>  <hint>:1:25: error:
21:21:47 <lambdabot>      parse error on input ‘=’
21:21:47 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
21:23:18 <Solonarv> > let foo = Nothing in case foo of Nothing -> "superguest"; Just s -> s
21:23:19 <lambdabot>  "superguest"
21:23:48 <nitrix> I'm rusty.
21:24:16 <Solonarv>  /j #rust
21:27:31 <superguest> why can't `case` accept `Nothing` directly?
21:27:44 <superguest> (just curious)
21:28:07 <enterprisey> > case Nothing of Nothing -> 1
21:28:09 <lambdabot>  1
21:28:32 <enterprisey> Also, any ideas on the fastest possible way to check if a character is in a bunch of non-overlapping ranges?
21:28:56 <superguest> >  case Nothing of Nothing -> "superguest"; Just s -> s
21:28:59 <lambdabot>  "superguest"
21:32:55 <cocreature> enterprisey: stuff them in a Set?
21:33:09 <Axman6> or just use a bunch of predicates
21:33:25 <cocreature> yeah depends on how many ranges you have
21:34:05 <Axman6> yeah if it's a small number of ranges, then predicates will be pretty fast
21:36:11 <Axman6> also for certain ranges, there may be some fun bit tricks you can use if you need ludacris speed
21:38:08 <cocreature> I would expect that at least the llvm backend can find a lot of those tricks for you
21:41:27 <superguest> "fromMaybe :: a -> Maybe a -> a"
21:41:51 <superguest> Does "Maybe" in the above denote typeclass?
21:42:01 <superguest> since 'a' is the type variable
21:42:08 <cocreature> no
21:42:34 <cocreature> Maybe is a type constructor that takes another type variable
21:42:48 <cocreature> "data Maybe a = Nothing | Just ä"
21:42:53 <cocreature> eh "Just a" :)
21:43:03 <superguest> cocreature, do you mean data constructor?
21:43:05 <rotaerk> type classes have type arguments too, but they're not the only thing
21:43:21 <Cale> superguest: Type classes show up to the left of the => in types, and they serve to constrain the types that type variables range over
21:43:32 <rotaerk> superguest, https://stackoverflow.com/questions/18204308/haskell-type-vs-data-constructor#18205862
21:43:41 <Cale> e.g.  sort :: (Ord a) => [a] -> [a]
21:43:42 <cocreature> superguest: actually, I don’t! the data constructors are "Nothing" and "Just". "Maybe" is the type constructor
21:44:16 <Cale> Ord there is a type class, and means that a must be a type that has the ordering operations (such as (<=)) defined on it
21:45:17 <superguest> thank you
21:56:46 <dminuoso> @let newtype Foo = Foo [(forall a. Num a => a)]
21:56:47 <lambdabot>  .L.hs:171:15: error:
21:56:47 <lambdabot>      • Illegal polymorphic type: forall a. Num a => a
21:56:47 <lambdabot>        GHC doesn't yet support impredicative polymorphism
21:58:17 <superguest> Cale, I remember someone saying that typeclasses in Haskell should not be viewed as OOP interfaces, but that description has the appearance of an interface. hehe
21:59:06 <dminuoso> superguest: Well they can be used as OOP interfaces.
21:59:09 <cocreature> dminuoso just can’t stop hoping for impredicative polymorphism :)
21:59:25 <dminuoso> cocreature: Heh. Trying to fully grasp the concept of it. :)
21:59:38 <dminuoso> cocreature: it just occured to me that this should be a natural thing.
22:02:51 <dminuoso> @let data Numish = forall a. Num a => Numish a
22:02:53 <lambdabot>  Defined.
22:02:56 <rotaerk> superguest, they have some things in common with OOP interfaces, but they're not equivalent to them
22:03:04 <dminuoso> @let newtype Foo = Foo [Numish]
22:03:06 <lambdabot>  Defined.
22:03:14 <dminuoso> I suppose that's the equivalent thing, right?
22:03:18 <cocreature> dminuoso: no
22:03:21 <cocreature> that’s an existential
22:03:27 <cocreature> the one above is universally quantified
22:03:43 <cocreature> data Numish = Numish (forall a. Num a => a) would be the equivalent
22:04:02 <dminuoso> cocreature: Okay I gotta ask... what is the meaning of that then?
22:04:14 <cocreature> of the existential?
22:04:54 <dminuoso> No of an impredicative type
22:04:54 <nowhere_man> wow, I'm really playing with Haskell on CodinGame, and it's the first non-toy program I'm really writing with it, and I must say, static typing feels like a free test suite
22:05:13 <dminuoso> nowhere_man: Indeed.
22:05:30 <cocreature> dminuoso: well as I said it’s equivalent to "data Numish = Numish (forall a. Num a => a)" (minus the wrapping). not sure what other meaning you are searching for
22:05:51 <dminuoso> cocreature: Im not sure what the difference is here
22:06:30 <cocreature> dminuoso: for the universal case once you unwrap it you get to choose the "a" that you want to instantiate it at
22:06:46 <cocreature> for the existential case you only get to know that there is _some_ a that is an instance of Num
22:06:57 <cocreature> all you can do with it is what this typeclass allows you to do
22:07:57 <Dockyard> ....
22:13:57 <orzo> Is "flip fmap" already bound in base somewhere?
22:14:04 <cocreature> :t (<&>)
22:14:05 <lambdabot> Functor f => f a -> (a -> b) -> f b
22:14:12 <orzo> cool beans
22:14:39 <orzo> uh, that's not base, is it?
22:14:52 <cocreature> https://hoogle.haskell.org/?hoogle=(%3C%26%3E)%20package%3Abase
22:15:41 <orzo> oh, i have base 4.9.1.0
22:15:49 <rotaerk> it shows up on hoogle for me, but it doesn't work for me
22:16:05 <orzo> it's Since: base-4.11.0.0
22:16:07 <cocreature> orzo: time to upgrade :)
22:16:16 <rotaerk> k
22:21:45 <rotaerk> though, (<&>) is really more like flip (<$>), there should be an ffor for fmap
22:22:42 <rotaerk> just cause fmap is *sometimes* nicer than <$>, and probably ffor would find its uses
22:24:41 <rotaerk> hmm I'm tempted to make something to use instead of resourcet, something that's a little closer to regions without the invasiveness
22:33:44 <rotaerk> basically, avoid having to ever call "release" explicitly, avoid ever having a reference to a resource that is not valid assuming you don't return it to a context after release
22:34:36 <rotaerk> but the property that regions guarantees: the inability for a resource reference to escape the scope in which it is acquired
22:34:47 <rotaerk> but sacrifice the property that *
22:35:04 <rotaerk> too costly of a guarantee, and doesn't really buy you much
22:35:06 * cocreature whispers “Linear Haskell is waiting for you”
22:35:57 <rotaerk> is linear haskell a real thing, or just a research topic
22:36:18 <cocreature> there is a branch for it and a GHC proposal but it hasn’t been merged yet
22:36:26 <rotaerk> I see
22:36:40 <rotaerk> well the approach I was thinking of was something like:
22:37:00 <dminuoso> nowhere_man: It's even better than a test suite because it proves the absence of certain behaviors, rather than test only cases the programmer specified.
22:37:16 <dminuoso> nowhere_man: So within the scope of what a type system proves, a type system is just more complete. :)
22:38:29 <dminuoso> For example when I see a signature `f :: Integer -> String` I know with certainty that this thing will not launch missiles when applied to 1. A test cannot give me that guarantee.
22:38:53 <dminuoso> Under the assumption nobody unsafePerformIO'd of course..
22:39:35 <rotaerk> cocreature, https://pastebin.com/rk7MGsLu
22:39:40 <rotaerk> something like that is what I had in mind
22:40:13 <rotaerk> with pattern, but instead of the resource being allocated and being passed in, a scope is created, to which resources are added ... when the scope ends, all resources in that scope are cleaned up
22:40:32 <rotaerk> so you can do nested scopes for interleaved resources
22:41:24 <cocreature> rotaerk: not sure how interleaved resources would look like here. if you have with-style functions you still get stack based resource allocation, no?
22:41:40 <rotaerk> well I did interleaved in that example, see line 7
22:42:22 <cocreature> ah right, I see
22:43:04 <cocreature> so your scopes are stack-based but since you don’t need to allocate at the beginning of a scope you get interleaving
22:43:09 <rotaerk> right
22:43:26 <rotaerk> this is basically how regions works, but it has type shenanigans to guarantee other things that are probably not worth it
22:44:23 <cocreature> tbh I don’t think I ever actually needed interleaved resource allocation :)
22:44:35 <rotaerk> I have a couple examples of it
22:44:40 <cocreature> it always kind of bugs me that "bracket" forces me into that pattern but then it never seems to cause problems for me :)
22:45:43 <ammar2> <dminuoso> For example when I see a signature `f :: Integer -> String` I know with certainty that this thing will not launch missiles when applied to 1. A test cannot give me that guarantee.
22:45:43 <ammar2> that's not true though
22:45:45 <rotaerk> cocreature, https://github.com/Rotaerk/vulkanTest/blob/master/main/src/Main.hs#L927-L935
22:46:04 <ammar2> it could be launching missiles and returning the status of the launch as the string :P
22:46:22 <cocreature> ammar2: not without unsafePerformIO
22:46:28 <geekosaur> only with unsafePerformIO, but you can enable Safe Haskell to catch that
22:46:38 <rotaerk> cocreature, so that first line is acquiring a buffer, and filling it with the contents of a file, then it's acquiring a shader based on its contents, but at that point I no longer need the buffer
22:46:53 <rotaerk> so that's a real example of interleaved
22:47:00 <ammar2> hey man you can launch missiles purely
22:47:02 <cocreature> rotaerk: thanks, that’s a nice example!
22:47:41 <cocreature> ammar2: well then launching missiles is not observable to the outside world and at that point why are you even launching missiles :)
22:47:47 <rotaerk> another example is a couple functions up, in fillBufferWithShaderFileContents
22:48:15 <ammar2> fair enough
22:51:04 <rotaerk> in that function I acquire a file handle, check the file's size, create a buffer of that size, fill the buffer from the file, close the file, and return the buffer
22:53:20 <dminuoso> So [(forall a. Num a => a)] is a list of polymorphic values?
22:54:18 <dminuoso> % set -XImpredicativeTypes
22:54:18 <yahb> dminuoso: ; <interactive>:6:6: error: Data constructor not in scope: XImpredicativeTypes :: ASetter s t a b -> b -> s -> t
22:54:30 * hackage postgresql-common 0.1.0.1 - Library for sharing common PostgreSQL types across Haskell PostgreSQL libraries.  http://hackage.haskell.org/package/postgresql-common-0.1.0.1 (IanDuncan)
22:54:33 <dminuoso> % :set -XImpredicativeTypes
22:54:33 <yahb> dminuoso:
22:55:08 <dminuoso> % let type NumList = [(forall a. Num a => a)]
22:55:08 <yahb> dminuoso: ; <interactive>:8:5: error: parse error on input `type'
22:55:30 <dminuoso> % let newtype List = List { unList :: [(forall a. Num a => a)] }
22:55:30 <yahb> dminuoso: ; <interactive>:9:5: error: parse error on input `newtype'
22:55:48 <dminuoso> % @let newtype List = List { unList :: [(forall a. Num a => a)] }
22:55:48 <yahb> dminuoso: ; <interactive>:10:1: error: parse error on input `@'
22:55:53 <geekosaur> prettu sure it doesn't need the "let"
22:55:58 <geekosaur> or want
22:55:58 <dminuoso> Oh
22:56:08 <dminuoso> % newtype List = List { unList :: [(forall a. Num a => a)] }
22:56:08 <yahb> dminuoso:
22:56:11 <dminuoso> geekosaur: Thank you =)
22:56:35 <geekosaur> not sure how persistent it is though
23:04:55 <dminuoso> % type Foo = [(forall a. Num a => a)]
23:04:55 <yahb> dminuoso:
23:05:08 <dminuoso> % g :: (forall a. Num a => [a]) -> Int; g = length
23:05:08 <yahb> dminuoso:
23:05:20 <dminuoso> % g ([1,2,3] :: Foo)
23:05:20 <yahb> dminuoso: ; <interactive>:17:4: error:; * Couldn't match type `a' with `forall a1. Num a1 => a1'; `a' is a rigid type variable bound by; a type expected by the context:; forall a. Num a => [a]; at <interactive>:17:1-18; Expected type: [a]; Actual type: Foo; * In the first argument of `g', namely `([1, 2, 3] :: Foo)'; In the expression: g ([1, 2, 3] :: Foo);
23:10:05 <dminuoso> Is there a relationship of RankNTypes and impredicative types? They do look kind of similar, almost as if the former was a special case of the latter
23:10:53 <geekosaur> impredicative types are types that cross ranks, sort of
23:12:48 <geekosaur> so, for example, runST. if you try to partially apply it with (.), you get
23:12:52 <geekosaur> :t (runST .)
23:12:53 <lambdabot> error:
23:12:53 <lambdabot>     • Couldn't match type ‘b’ with ‘forall s. ST s c’
23:12:53 <lambdabot>       ‘b’ is a rigid type variable bound by
23:13:14 <geekosaur> because b is expected to be rank-1, but needs to be instantiated to a rank-2 type
23:13:49 <geekosaur>       Expected type: b -> c
23:13:49 <geekosaur>         Actual type: (forall s. ST s c) -> c
23:14:32 <dminuoso> % :t (runST .)
23:14:33 <yahb> dminuoso: (a -> forall s. ST s c) -> a -> c
23:14:52 <dminuoso> Mmm okay I think this makes sense
23:15:45 <geekosaur> more precisely, we "want" b there to have *any* rank
23:16:00 <slack1256> how to import all the symbols from a module from ghci (and not just exported functions)?
23:16:51 <geekosaur> you can't, unless you have the source with you. packages are compiled, the only symbols that exist are the exported ones
23:17:10 <geekosaur> if you have source available you can force it to be loaded interpreted and get all the symbols
23:17:28 <slack1256> I have the source available!
23:17:36 <geekosaur> then load it directly
23:17:57 <geekosaur> if this is part of your own program/library and it's loading a compiled one instead of source, precede the name of the module with *
23:18:01 <cocreature> :l will bring all symbols in scope, as will :module + *ModuleName
23:18:19 <cocreature> in general, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#what-s-really-in-scope-at-the-prompt is quite helpful to read
23:18:25 <slack1256> Let me try that!
23:18:51 <geekosaur> also don't use -fobject-code because that probably also discards local symbols / unexported names
23:19:02 <cocreature> yeah it only works in interpreted mode
23:21:26 <cocreature> I’m trying to go from [a] to Map a Int where each a gets assigned a unique identifier (I don’t care which one). is there some convenient solution for that? I can ofc turn it into a Set, zip that with [1..] and then use Map.fromList but that seems wasteful from a performance standpoint. there is ofc also the foldl' solution where I check if the element already exists in the Map and if not I insert it with
23:21:28 <cocreature> a new key but I’m hoping for something that already does that for me
23:22:44 <cocreature> hm I guess I could just zip the original list with [0..] and use Map.fromList on that. I don’t care if identifiers are consecutive
23:24:31 <cocreature> yeah that works nicely
23:27:38 <hololeap> anyone work closely with FRP? what's your favorite library?
23:27:59 <slack1256> It works when using the :l or :module + *Mod syntax. Probably doesn't work inside cabal repl by the use of object code and not interpreted code. I will see if a flag can modify this behaviour.
23:28:09 <slack1256> thanks cocreature, geekosaur.
23:28:39 <cocreature> slack1256: cabal repl shouldn’t default to -fobject-code iirc. have you enabled that yourself?
23:29:04 <slack1256> *cabal new-repl
23:29:11 <cocreature> same there
23:30:06 <slack1256> No, I haven't enabled that flag. But using `cabal new-repl yi-keymap-emacs` and loading a module as `:module + *Yi.Keymap.Emacs` doesn't work as intended
23:30:28 <slack1256> Yet `:l source-file-of-that-module.hs` imports all the symbols as I want
23:33:41 <cocreature> is the module in a different component of your package, e.g., are you loading an executable in the repl and the module is from the lib?
23:56:26 <AfC> cocreature: I'd been using Haskell for five years before I understood the difference between Maybe the type constructor and Nothing|Just the data constructors. I mean, using it constantly but not realizing that Maybe a is the Maybe type constructor being applied.
23:57:12 <cocreature> AfC: heh, luckily things clicked a bit faster for me :)
23:57:53 <dminuoso> AfC: Sometimes I recommend GADTSyntax to beginners - it helps visualize the difference a bit,
23:58:23 <dminuoso> data Maybe a where Just :: a -> Maybe a; Nothing :: Maybe a
23:58:52 <dminuoso> Especially if you know to read `::` as "has type"
