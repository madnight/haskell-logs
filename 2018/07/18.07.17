00:02:43 <dminuoso> Is there anything inherently wrong with creating a global Manager (http-client) across a simple library?
00:03:00 <dminuoso> (initialized with unsafePerformIO)
00:06:15 <quicksilver> cognitive dissonance
00:07:12 <quicksilver> and of course the usual caveats for global variables
00:07:39 <quicksilver> but in practice, probably not - your OS is implicitly fully of things (like the input subsystem, or the graphics buffers etc)
00:07:50 <quicksilver> I still wouldn't do it as a matter of taste though.
00:08:24 <dminuoso> quicksilver: So you would require the consumer of the library to provide a Manager for your library to use?
00:09:35 <dminuoso> I mean in the end my library exposes a third-party service. All this manager seems to be for, is keep-alive of http connections.
00:13:23 <quicksilver> well I would think about initialisiation and threads. Does your library require explicit initialisation? How re-entrant is it?
00:13:37 <quicksilver> those are among the typical pitfalls with a simplistic global model
00:13:58 <quicksilver> but if you can provide a sensible API to your users then do whatever makes for the best sensible APi I think?
00:14:03 <quicksilver> that should be the priority of a library author.
00:14:49 <Zipheir`> Namely, be sensible!
00:18:50 <juhp> > [i|i<-"abcde", True]
00:18:52 <lambdabot>  "abcde"
00:21:57 <quicksilver> one of the things which derailed the whole 'officially support global variables in haskell' thread which I participated in 10 years ago was you very quickly get into a discussion on having a global initialisation phase for each module
00:22:04 <quicksilver> and then you have to decide which order
00:22:14 <quicksilver> and then you need to talk about global initialisation time for libraries
00:22:43 <quicksilver> and then you start to want config files and you're running arbitrary IO actions at program startup based on a dependency grid
00:22:52 <quicksilver> it is a genuine complexity tar pit in there :)
00:23:12 <quicksilver> C++ has global static constructors, and it's a pain.
00:26:36 <quicksilver> thread starts here: https://mail.haskell.org/pipermail/haskell-cafe/2007-May/025526.html
00:26:45 <quicksilver> but thre were other ones of course
00:35:02 <dminuoso> quicksilver: Fair enough. In this particular case there's no issue about initialization order - it's relatively harmless.
00:35:50 <dminuoso> Not quite sure what the purpose of Manager is anyway. Are there benefits in being able to manually control the connection pools for keep-alive?
00:36:42 * quicksilver doesn't know :)
00:44:37 <dminuoso> Ah I guess the documentation was slightly misleading. Among other things it gives me the ability to set the HTTP proxy.
00:44:59 <dminuoso> That alone is reason enough to not provide my own manager.
00:54:21 <fabianbergmark> is lpaste down?
00:57:21 <fabianbergmark> and hpaste.org
00:58:56 <gentauro> % :t fromMaybe
00:58:57 <yahb> gentauro: a -> Maybe a -> a
00:59:18 <phadej> dminuoso: in general, "Can I use unsafePerformIO", "Please don't"
01:00:21 <gentauro> % foo = req opt = req + (fromMaybe 10 opt)
01:00:22 <yahb> gentauro: ; <interactive>:12:15: error:; parse error on input `='; Perhaps you need a 'let' in a 'do' block?; e.g. 'let x = 5' instead of 'x = 5'
01:00:31 <gentauro> % foo req opt = req + (fromMaybe 10 opt)
01:00:31 <yahb> gentauro:
01:00:41 <gentauro> % :t foo
01:00:41 <yahb> gentauro: Num a => a -> Maybe a -> a
01:00:47 <phadej> dminuoso: e.g. in our work stuff I create single Manager and pass it to everything, except when I really need different one for some reason
01:01:01 <gentauro> % :t foo 42
01:01:01 <yahb> gentauro: Num a => Maybe a -> a
01:01:58 <gentauro> % :t (+ 2) foo 42
01:01:59 <yahb> gentauro: (Num a, Num (a -> Maybe a -> a)) => Maybe a -> a
01:02:19 <gentauro> % :t (foo 42) + 2
01:02:19 <dminuoso> phadej: So when you'd expose some third party library, you'd have some `Manager -> SomeRequest -> IO SomeResponse` ?
01:02:20 <yahb> gentauro: (Num a, Num (Maybe a -> a)) => Maybe a -> a
01:02:47 <phadej> dminuoso: yes.
01:03:37 * hackage relational-query 0.12.1.0 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.12.1.0 (KeiHibino)
01:04:20 <phadej> dminuoso: for example http://hackage.haskell.org/package/github-0.19/docs/GitHub-Request.html#v:executeRequestWithMgr
01:04:59 <gentauro> I don't seem to understand how this snippet works -> https://stackoverflow.com/a/7781350
01:05:14 <gentauro> basically what I'm looking for is an optional argument for my function
01:05:47 * hackage relational-query-HDBC 0.7.1.0 - HDBC instance of relational-query and typed query interface for HDBC  http://hackage.haskell.org/package/relational-query-HDBC-0.7.1.0 (KeiHibino)
01:06:52 <phadej> gentauro: it uses fromMaybe, and only plays with syntax to make its use look more convinient?
01:07:07 <geekosaur> gentauro, it's not optional in the sense of "completely omitted", it's optional in the sense of "may be Nothing". and otherwise, what phadej said
01:07:32 <geekosaur> there are ways to get completely optional parameters but they involve typeclasses, and play havoc with type inference; this is best avoided
01:07:53 <dminuoso> phadej: Ah that is helpful indeed. :)
01:12:44 <dminuoso> phadej: Out of curiosity. Is there a reason you are using raw http-client over some higher level library like say servant?
01:14:49 <alp> haha =)
01:15:35 <gentauro> dminuoso: simplicity?
01:16:18 <fabianbergmark> I'm working on a JavaScript (ECMA262) interpreter. I'm representing js values with either, and I'm trying to use a type class to convert (safely) between different types. This is what I got so far: https://pastebin.com/E3EnYA1N However it has problems with overlapping instances. Is there any nice language extension or other method that can achieve this?
01:17:02 <quicksilver> fabianbergmark: what you're trying to do is not really compatible with the way polymorphism works
01:17:40 <quicksilver> which is essentially why overlapping instances is an extension (and one that many woudl counsel against)
01:18:08 <quicksilver> to see why, ask yourself what the Inject instance should be for Int + Int?
01:18:20 <quicksilver> (I mean, Inject Int (Int + Int))
01:22:20 <fabianbergmark> quicksilver: True. This is soley for convenience. to avoid having to write Left . Left . Right . Right . Right $ val
01:22:35 <quicksilver> I understand that.
01:23:27 <quicksilver> I'm pretty sure there is a way to get the convenience you want, but I'm not sure what the best way is
01:27:43 <quicksilver> there are type class libraries designed for open unions
01:27:45 <quicksilver> which is what you're doing
01:27:53 <quicksilver> but I wouldn't expect to need that for javascript
01:28:02 <quicksilver> isn't the set of JS types known upfront
01:28:27 <quicksilver> is there a reason you don't just use data JSType = I Int | S String | F JSFun | O JSObj | .....
01:28:30 <quicksilver> ?
01:30:23 <dminuoso> phadej: Ah heh you seem to not actually make use of manager connection pools.
01:30:37 * hackage deriveJsonNoPrefix 0.1.0.1 - Derive ToJSON/FromJSON instances in a more prefix-friendly manner.  http://hackage.haskell.org/package/deriveJsonNoPrefix-0.1.0.1 (igrep)
01:30:37 <dminuoso> I guess that's another way of solving this issue. :-P
01:31:38 <dminuoso> quicksilver: Humerous pedantry: That should be `I Float` :-P
01:32:00 <quicksilver> dminuoso: yeah :)
01:32:04 <dminuoso> Not that it's really relevant, but still remarkable that after so many years JS still has no actual integer.
01:32:18 <quicksilver> yes, we heavily use strings-as-numbers in JS
01:32:30 <quicksilver> due to not wanting to use float arithmetic
01:33:28 <tdammers> dminuoso: lots of languages are flawed that way. C and PHP for example still have no actual strings.
01:33:38 <fabianbergmark> quicksilver: there is a fixed set of unions, like type Primitive = Null + Undefined + Number + String + Bool, type Value = Object + Primitive, type CallValue = Reference + Value
01:33:55 <quchen> tdammers: PHP has no actual strings? What are they?
01:34:01 <tdammers> quchen: byte arrays
01:34:11 <dminuoso> that funnily sometimes behave as floating point numbers.
01:34:17 <fabianbergmark> quicksilver: I use type patterns a lot to ease pattern matching, pattern PrimitiveString a = Right (Right (Right (Left a)))  :: Primitive
01:34:17 <dminuoso> See this: https://bugs.php.net/bug.php?id=54547
01:34:40 <dminuoso> tdammers: I think that's a problematic differentiation. What is a character anyway?
01:35:06 <quicksilver> fabianbergmark: I believe I'd just definte the three types (and any others) as fixed data types and then make the injections between them explicit.
01:35:13 <quicksilver> rather than using pattern synonums
01:35:18 <dminuoso> tdammers: In a world of ASCII, where C came from, char arrays are fine strings. :-)
01:35:25 <cocreature> yeah nesting Eithers is rarely a good idea
01:35:39 <quicksilver> I might use the lens library (prisms)
01:36:08 <quicksilver> but I'd be guided by what was most expressive for the algorithms I needed to write.
01:36:19 <quchen> ASCII is only 75% printable, so even in an ASCII world char arrays aren’t »fine strings«.
01:36:19 <tdammers> dminuoso: yes, it was fine on early non-networked UNIX, where you could just define "the" encoding for the entire computer system and all the files on it to be ASCII
01:36:44 <quchen> C has alright ASCII strings. :-)
01:36:45 <tdammers> but even then, yes, it is a simplification that made UNIX possible in the first place, but also created problems later
01:36:54 * quicksilver mutters about EBCDIC
01:37:14 <quicksilver> I'm reasonably sure that the first K&R book makes it quite clear that char isn't ASCII
01:37:19 <dminuoso> C++ is a bit more hilarious when you consider how std::string differs between linux and windows
01:37:22 <tdammers> anyway, the point being, PHP's "strings" don't know anything about their encoding, so you can't just use them as strings, even if what they contain is supposed to be textual data
01:37:56 <tdammers> quicksilver: true; it's whatever the local machine expects
01:38:02 <quchen> tdammers: so strlen("hällo") is something random?
01:38:21 <quchen> »Today let’s assume this is UTF-14«
01:39:07 <geekosaur> it's potentially whatever the web server decided it was, which might not be easy to work out. if you're lucky it's in the environment somewhere
01:39:34 <dminuoso> tdammers: Well PHP strings are great because equality behaves differently depending on the *content*
01:39:34 <geekosaur> sorry, what the web server and browser negotiated between themselves
01:39:38 <tdammers> quchen: no, not random. It just counts individual bytes, because that's all it knows about. And the string literal's byte encoding is exactly what PHP finds in the source file, so if your source file was encoded as latin-1, then that strlen() outputs 5, if it was encoded as UTF-8, then you get 6, if it was UTF-16, you get 10.
01:39:46 <dminuoso> When the content looks like a number, it gets turned into a IEEE-754 floating point number and compared that way.
01:39:58 <dminuoso> So they are not raw byte arrays either.
01:40:27 <dminuoso> '9223372036854775807' == '9223372036854775808'
01:40:29 <dminuoso> Obviously.
01:41:23 <merijn> dminuoso: That was fixed by introducing fifteen regressions
01:41:24 <tdammers> they are raw byte arrays
01:41:44 <tdammers> it's just that the == operator includes implicit conversion
01:45:19 <dminuoso> merijn: Oh it was?
01:47:00 <tdammers> I thought the consensus in the PHP community was to just recommend not using == at all
01:47:19 <tdammers> just throw it on the giant heap of forbidden features
01:48:40 <cocreature> can I throw PHP itself in the giant heap of forbidden features?
01:55:02 <tdammers> cocreature: I have.
01:56:18 <quicksilver> PHP is very useful.
01:56:33 <quicksilver> When someone tells you in an interview why they prefer PHP to other languages you... learn things about them.
01:56:33 <dysfun> sure, but i'm never very comfortable about deploying it
01:56:58 <dysfun> my last interview for a php job was fun "do you like php?" "no" "us neither"
01:57:47 <merijn> quicksilver: That applies to many technologies and opinions :p
01:58:09 <quicksilver> merijn: ya :) just talking is the thing. I was being a bit flippant.
01:58:55 <merijn> "I really like JavaScript!" 'oh...why?' *start backing away slowly*
01:59:10 <dysfun> i really like javascript. it's a great compile target for purescript!
01:59:30 <merijn> JavaScript is a terrible compile target for literally every language
01:59:32 <tdammers> merijn: actually JavaScript is probably the 4th most pleasant language I know, at least until about 1-2 hours into a project
01:59:39 <quicksilver> it's a pretty good VM.
01:59:49 <quicksilver> possibly for the wrong reasons :)
01:59:51 <merijn> quicksilver: Sure, if you don't mind not having integers...
02:00:02 <quicksilver> indeed, as discussed, that is pretty weird
02:00:06 <liste> one thing Javascript got right that others didn't: sandboxing
02:00:15 <dysfun> not sure it got that quite right...
02:00:31 <tdammers> the implementation running in firefox certainly didn't
02:00:36 <liste> every day hundreds of programs from untrusted sources run on my computer
02:00:47 <merijn> liste: And then Intel broke it :)
02:00:51 <quicksilver> webassembly will have integers AIUI
02:00:57 <dysfun> and you're lucky that most of those untrusted sources aren't out to get you
02:00:59 <dysfun> quicksilver: it already does
02:01:22 <liste> merijn: yeah
02:01:26 <dysfun> of course it doesn't have garbage collection yet...
02:01:29 <dysfun> or the hooks for it
02:02:02 <dminuoso> merijn: In all fairness it's not really Intels fault alone. Processor vendors are slowly learning what cryptography experts have been studying for a while now: Optimization induced side-channels.
02:02:31 <dminuoso> Without speculative optimizations left and right processors would be awfully slow nowadays.
02:02:41 <dysfun> the thing is, those side channel attacks were discussed at conferences all the vendors attended
02:03:51 <dysfun> (AMD devs noted so after the intel bugs came out)
02:04:27 <dminuoso> dysfun: Oh really, do you have any link at hand by any chance?
02:04:39 <dysfun> oh gosh, it was a while ago. let's see if i can find something
02:07:29 <fabianbergmark> Looking for contributors/code reviewers for my interpreter https://hackage.haskell.org/package/ecma262
02:09:10 <tdammers> fabianbergmark: is that what I think it is?
02:11:11 <fabianbergmark> tdammers: a js interpreter, then yes
02:12:14 <dysfun> dminuoso: no, sorry, i couldn't find anything now it's buried under hysteria and i'm bored of looking
02:12:37 <tdammers> fabianbergmark: sandboxable? that is, could I use it as a script interpreter for some host application, such that it can only touch things that I explicitly expose to the scripting system?
02:13:18 <dminuoso> dysfun: Dont worry about it. Ill dig some further myself. Thanks for trying.
02:13:23 <fabianbergmark> tdammers: it can run in an arbitrary monad
02:13:59 <fabianbergmark> tdammers: it has support for extension, check Host/Console
02:14:31 <fabianbergmark> tdammers: https://github.com/fabianbergmark/ECMA-262/blob/master/src/Language/JavaScript/Host/Console.hs
02:14:31 <tdammers> fabianbergmark: very cool, I'll probably give it a spin one of these days
02:14:43 <dysfun> that's pretty cool
02:15:04 <dysfun> one major feature that would be nice is to be able to run for N instructions and pause. can it do that?
02:16:22 <dminuoso> fabianbergmark: How conforming is your implementation?
02:16:57 <fabianbergmark> dminuoso: it should be 100 %, but i havent been able to run the test suit
02:17:19 <fabianbergmark> i basically wrote it in 2 months on vacation and then got busy with work
02:17:35 <dminuoso> fabianbergmark: That would be pretty cool. What version of ECMA-262 did you cover? 5th?
02:17:56 <fabianbergmark> there is some work to be done with the parser, some cleanup and then passing all the tets
02:18:41 <fabianbergmark> I think it was 5.1
02:21:54 <merijn> This versioning is ambiguous, because the last edition of the ECMA-262 standard was the 3rd edition, despite covering JS 6 or 7 (yay, confusion!)
02:22:56 <dysfun> ES 6 or 7 :)
02:23:07 <dysfun> it's not JS any more
02:23:45 <dminuoso> merijn: What do you mean?
02:24:44 <dminuoso> https://www.ecma-international.org/ecma-262/7.0/ is this not the 7th edition, literally?
02:24:50 <merijn> The 3rd edition of the ECMA-262 standard was standardised and released late last year
02:25:33 <merijn> dminuoso: There's confusingly, multiple versions of ECMA standardised by different organisations with different numberings
02:25:50 <dminuoso> Oh right. Are you referring to the ISO standard?
02:26:28 <dminuoso> merijn: Though isnt ECMA a standards organization?
02:26:55 <merijn> dminuoso: I think it was the ISO one, I don't even know or care anymore, tbh
02:28:25 <dminuoso> merijn: ES is defined by either ECMA-262 and ISO/IEC 16262. So ECMA-262 has (currently) 9 (or 8 if you dont count the 4th) editions, while ISO has.. three?
02:28:38 <dminuoso> ECMA-262 5th edition is non-ambiguous
02:29:00 <dminuoso> But "ES6" is ambiguous
02:29:06 <dminuoso> Or "ES5"
02:32:37 * hackage bench-graph 0.1.3 - Plot and compare benchmarks  http://hackage.haskell.org/package/bench-graph-0.1.3 (harendra)
02:34:37 * hackage summoner 1.0.5 - Tool for creating completely configured production Haskell projects.  http://hackage.haskell.org/package/summoner-1.0.5 (shersh)
02:58:11 <cloudhead> anyone know of a function with a signature like this: T (Maybe a) -> Maybe (T a)?
02:58:28 <Taneb> :t sequence
02:58:29 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
02:58:35 <Taneb> :t sequenceA
02:58:35 <cloudhead> T would be a data type
02:58:35 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
02:58:49 <cloudhead> ah yes this might work, forgot about it!
03:00:00 <phadej> once again the answer is `traverse` :)
03:00:02 <phadej> (kind of)
03:01:35 <liste> > traverse (Maybe [1,2,3])
03:01:37 <lambdabot>  error:
03:01:37 <lambdabot>      • Data constructor not in scope: Maybe :: [Integer] -> a -> f b
03:01:37 <lambdabot>      • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
03:01:47 <liste> > traverse (Just [1,2,3])
03:01:49 <lambdabot>  error:
03:01:49 <lambdabot>      • Couldn't match expected type ‘a -> f b’
03:01:49 <lambdabot>                    with actual type ‘Maybe [Integer]’
03:02:49 <Taneb> > sequenceA (Just [1,2,3])
03:02:51 <lambdabot>  [Just 1,Just 2,Just 3]
03:02:56 <cocreature> > traverse id (Just [1,2,3])
03:02:58 <lambdabot>  [Just 1,Just 2,Just 3]
03:02:59 <Taneb> > sequenceA [Just 1, Just 2, Just 3]
03:03:01 <lambdabot>  Just [1,2,3]
03:03:03 <cocreature> if you really want to stick to traverse :)
03:13:11 <dminuoso> :t (execWriter .) . traverse_ . (curry writer () .)
03:13:12 <lambdabot> (Monoid w, Foldable t) => (a -> w) -> t a -> w
03:13:21 <dminuoso> Traversable is so cool :)
03:13:45 <cloudhead> hmm ok my problem is a bit more complicated because I have two type parameters
03:13:50 <cocreature> dminuoso: that’s Foldable, not Traversable :)
03:13:53 <cloudhead> and it's the first I'm interested in
03:13:59 <dminuoso> cocreature: Yeah well..
03:14:12 <cloudhead> so it's more like: T (Maybe a) b -> Maybe (T a b)
03:14:27 <Taneb> :t bisequenceA
03:14:29 <lambdabot> error:
03:14:29 <lambdabot>     • Variable not in scope: bisequenceA
03:14:29 <lambdabot>     • Perhaps you meant one of these:
03:14:37 <cocreature> :t bitraverse id pure
03:14:39 <lambdabot> error:
03:14:39 <lambdabot>     • Variable not in scope:
03:14:39 <lambdabot>         bitraverse :: (a0 -> a0) -> (a1 -> f0 a1) -> t
03:14:51 <cocreature> @let import Data.Bitraversable
03:14:53 <lambdabot>  Defined.
03:14:54 <cocreature> :t bitraverse id pure
03:14:55 <lambdabot> (Applicative f, Bitraversable t) => t (f c) d -> f (t c d)
03:15:02 <cocreature> ^ cloudhead
03:15:04 <cloudhead> aha brilliant
03:16:27 <cloudhead> thanks
03:24:22 <quicksilver> seems counter intuitive to use bitraverse with pure
03:24:30 <quicksilver> feels like there should be a simpler way
03:27:01 <Taneb> quicksilver: there's nothing in Data.Bitraversable
03:27:13 <Taneb> But Bitraversable is actually a stronger constraint than we might want here
03:27:51 <Taneb> (I guess if it works it works)
03:27:56 <quicksilver> yeah, that's what I mean
03:28:20 <Taneb> Sadly I'm not sure "TraversableInFirstParameter" is a thing that exists
03:28:34 <quicksilver> well it kind of does
03:28:41 <quicksilver> you can do a type level Flip if you must
03:28:57 <quicksilver> but also, Traversal lets you concretise traversables
03:29:11 <cocreature> quicksilver: Flip doesn’t help. the Traversable instance for Flip has a Bitraversable constraint
03:30:02 <quicksilver> you can just write out the Traversal though
03:30:37 <gentauro> is there a way to see if a `tid` is still running? -> http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Concurrent.html#v:forkIO
03:30:52 <gentauro> like `threadStatus tid`
03:32:01 <tfc[m]> hi there. is there an operator that is like flipped `<$>`? i mean if this operator exists and e.g. called `<$>>>` then `a <$> b` would be equivalent to `b <$>>> a`. or is this stupid because there is a much better thing?
03:33:00 <merijn> tfc[m]: I think there' <&> somewhere
03:33:26 <cocreature> gentauro: I don’t think so but the async package has a "poll" function
03:35:04 <gentauro> cocreature: I don't really need the result
03:35:28 <gentauro> I mean, I call my logic like this: `_ <- forkIO $ ...`
03:35:29 <cocreature> gentauro: so? just set it to ()
03:35:42 <mdim> Greetings. Is anyone using the Atom editor for working with Haskell? If so, do you use the Haskell IDE Engine or something else?
03:36:04 <le_jonge> merijn: hm i found such a thing multiple times on hayoo e.g. in "lens", but i think there is nothing from "base". ok looks like i could use it if i have lens already (at least many projects have that dependency already) or define it myself. thank you, it helps to know that there is a <&> op
03:36:30 <cocreature> le_jonge: it is in base but only fairly recently https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Functor.html#v:-60--38--62-
03:36:40 <dminuoso> le_jonge: Quite a few packages tend to define `(<&>) = flip fmap` on the spot
03:36:58 <le_jonge> cocreature: wat why didn't hayoo list this (or i am blind) thanks for the link
03:37:29 <quicksilver> tfc[m]: last time I needed that I wrapped forkIO in something which recorded its status in an MVar or similar
03:37:31 <dminuoso> le_jonge: Probably because either Hayoo doesn't search against the most recent version, or the maintainers haven't updated their index yet?
03:37:40 <quicksilver> tfc[m]: (maybe something has been written since then)
03:38:33 <dminuoso> tfc[m]: Also don't be afraid to define such an operator yourself if it helps improve your code. =)
03:39:04 <cocreature> le_jonge: hayoo probably indexes some older version
03:39:13 <gentauro> cocreature: I guess I could also just ask for capabilities -> http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Concurrent.html#v:threadCapability
03:39:17 <cocreature> le_jonge: hoogle has it https://hoogle.haskell.org/?hoogle=(%3C%26%3E)
03:39:28 <quicksilver> oops my comment was for gentauro
03:39:33 <gentauro> If no thread is available, I would expect an error (maybe catch with `try`)
03:39:34 <quicksilver> sorry my eys are not working well
03:39:47 <cocreature> wrapping things in an MVar is pretty much what async does
03:39:51 <quicksilver> gentauro: last time I needed that I wrapped forkIO in something which recorded its status in an MVar or similar, (maybe something has been written since then)
03:40:00 <cocreature> so personally I wouldn’t bother reinventing that
03:40:03 <gentauro> quicksilver: cool
03:40:11 <le_jonge> dminuoso: yes, you're right. the code is short afterall. i was however very eager to find a "standard operator" for this that is in base. the reason is that i have code that is often read by "haskell sceptics" who go mad every time someone "AGAIN" uses some custom operator. "standard base operators" are easier to sell. :)
03:40:19 <cocreature> gentauro: it doesn’t look like threadCapability throws an exception
03:40:21 <gentauro> quicksilver: but how do you know that the thread is still active or just died?
03:40:58 <cocreature> you use forkFinally to ensure that it writes to the MVar even it it dies
03:41:00 <cocreature> *if
03:41:00 <quicksilver> exception handler writing something to the MVar
03:41:00 <gentauro> cocreature: if I call for a thread that isn't there, I would expect "something" (rather Either, but I'm guessing it's an error of some kind)
03:41:23 <cocreature> gentauro: how do you call for a thread that isn’t there? threads aren’t garbage collected while you hold their ThreadId
03:41:35 <tfc[m]> dminuoso: sorry was chatting from 2 different nicks. i am playing with matrix.org vs. my old irc client. :D
03:42:13 <cocreature> a thread that has terminated appears to still have some capability associated with it
03:42:18 * hackage yeshql-core 4.1.0.1 - YesQL-style SQL database abstraction (core)  http://hackage.haskell.org/package/yeshql-core-4.1.0.1 (TobiasDammers)
03:42:26 <gentauro> cocreature: that sounds reasanable
03:42:46 <gentauro> cocreature: forkFinally + MVar sounds like the way to go. I will give it a try :)
03:43:25 <cocreature> gentauro: as I mentioned before, forkFinally + MVar is pretty much what async does so I don’t see a reason to avoid it
03:43:37 * hackage yeshql-hdbc 4.1.0.1 - YesQL-style SQL database abstraction (HDBC backend)  http://hackage.haskell.org/package/yeshql-hdbc-4.1.0.1 (TobiasDammers)
03:43:41 <gentauro> tfc[m]: do you really own matrix.org? :D
03:43:44 <gentauro> (nice btw)
03:44:40 * hackage yeshql 4.1.0.1, yeshql-postgresql-simple 4.1.0.1 (TobiasDammers): https://qbin.io/states-laser-awe9
03:45:33 <gentauro> % :t void
03:45:33 <yahb> gentauro: Functor f => f a -> f ()
03:46:07 <tfc[m]> gentauro: no of course not. i just evaluate if i can live with using irc through the matrix client.
03:48:09 <gentauro> tfc[m]: ahhh, irssi does a pretty good job :)
03:59:43 * hackage indexation 0.1 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.1 (NikitaVolkov)
04:04:31 <dminuoso> le_jonge: I dont think "reinventing" an operator is too much of a trouble. But you could use hoogle to search by a type signature
04:04:33 <dminuoso> :t fmap
04:04:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:04:43 <dminuoso> What you asked for has the signature
04:04:50 <dminuoso> Functor f => f a -> (a -> b) -> f b
04:04:55 <dminuoso> punch that into hoogle and be amazed =)
04:05:27 <dminuoso> (You might have to scroll a bit)
04:05:48 <cocreature> or be disappointed because the type search in the new hoogle is crap :)
04:05:57 <le_jonge> dminuoso: oh so hayoo also spits out <**> from control.applicative. that is nice.
04:06:27 <Taneb> But not quite what you want
04:07:25 <le_jonge> right. it is not <$> just flipped
04:07:58 <le_jonge> ok i am happy with <&> being in recent base
04:08:01 <Taneb> le_jonge: in an ideal world the top result would be <&> from Data.Functor
04:08:59 <cocreature> the only place where I use (<**>) is for optparse-applicative because I keep copying the example because I forget how to use it :)
04:09:31 <le_jonge> yeah so far i only used <*> for constructors :D
04:09:41 <le_jonge> and i can't imagine where i would use <**>
04:10:18 <Taneb> It comes in handy every now and then
04:11:01 <le_jonge> yeah i guess knowing that it exists helps as soon as you need it.
04:48:41 * hackage structured-cli 0.9.4.0 - Application library for building interactive console CLIs  http://hackage.haskell.org/package/structured-cli-0.9.4.0 (erick)
04:51:35 <c50a326> how are packages that aren't in curated sets built by stack?
04:51:56 <c50a326> I mean in GHC terms, does stack automatically download/install the appropriate version of GHC?
04:53:01 <cocreature> c50a326: are you talking about running "stack install packagename" to install some executable or about adding some package to extra-deps?
04:55:40 <c50a326> cocreature: hmmm actually first do you know how I can basically remove everything that stack has installed except for whatever it installed from `stack setup` so like ghc, ghci etc?
04:55:48 <c50a326> in order to play with stack I need to know how to get back to 0 so I can try stuff
04:55:52 <c50a326> then I can refine my question
04:56:15 <c50a326> but I really need to understand how stack is working in order to ensure I have all the correct stuff for whatever the spacemacs haskell layer needs to be installed
04:56:31 <cocreature> rm -r ~/.stack/snapshots should kill all packages
04:57:04 <c50a326> one problem I have right now is that ghc-mod is installed in ~/.local/bin but I don't know what's installed it... if I do `stack uninstall ghc-mod` it says stack does not manage global installations :S
04:58:10 <cocreature> just remove the executable
04:58:15 <c50a326> I think I did do a `stack install` inside a repository directory having downloading one that had a stack.yaml in it
04:58:26 <c50a326> I think that was for ghc-mod but I can't find the repo dir on my system anymore, I may have deleted it -.-
04:58:29 <c50a326> okay I'll remove the binary
04:59:47 <c50a326> is there a way to list all the binaries that stack has installed globally?
04:59:59 <c50a326> I tried `stack ls` and that only shows snapshots and dependencies of a given project I think
05:00:09 <c50a326> `stack ls snapshots` works globally but not `stack ls dependencies`
05:00:30 <orion> What's a good way of pronouncing "<$>"? It's not listed here: https://wiki.haskell.org/Pronunciation
05:00:51 <infinisil> orion: fmap?
05:00:53 <c50a326> "maps over" or "fmap" I guess
05:01:31 <orion> <*> is listed as, "applied over"
05:01:34 <merijn> I'd just say fmap if I had to pronounce it
05:02:06 <cocreature> c50a326: stack doesn’t really attempt to manage global binaries. all "stack install" does is build the package and then copy the executable to ~/.local/bin
05:02:48 <c50a326> oh weird, it's not a package manager then
05:03:35 <cocreature> stack (and cabal is fairly similar in that regard) are primarily targetted at building projects and managing the dependencies of those
05:04:10 <c50a326> so really maybe my operating system
05:04:13 <c50a326> oops
05:04:28 <c50a326> my distro's package manager should manage things like the binaries that need to be available for my editor
05:04:58 <dminuoso> Curious that (.) doesn't mention "after"
05:05:07 <cocreature> "stack install" is fine, it’s just up to you to manage the binary if you want to do more than copy it to ~/.local/bin
05:06:37 <c50a326> oh I see... and what about this whole thing about the ghc-mod needs to have been compiled with the same version of ghc
05:07:06 <c50a326> hmmm so basically I should stick with 1 version of ghc and a matching version of ghc-mod
05:07:20 <c50a326> and then all other packages, if they're not in my lts, I can add them to extra-deps
05:07:43 <c50a326> and stack will have no problem with all that and things using ghc-mod should work at least mostly, maybe...?!
05:08:45 <cocreature> fwiw especially as a beginner, I wouldn’t recommend spending much time on trying to setup fancy editor tooling
05:09:06 <cocreature> trying to get it to work tends to consume far more time that it saves you
05:09:22 <cocreature> you can always try it again once you are a bit more familiar with things
05:09:29 <c50a326> ah but I've already invested >24hrs into this now
05:09:35 <c50a326> I've gone all in on spacemacs
05:09:37 <c50a326> lol
05:09:37 <dminuoso> By the time you get everything fixed GHC will have changed its API so much that it won't work anymore. :-P
05:09:37 <cocreature> if you want some basic tooling that is pretty easy to setup and doesn’t break too often, try ghcid
05:09:41 <c50a326> I'm actually very impressed with it
05:09:50 <hpc> and then once you have it working, things like autocomplete can get in the way of things like learning the standard library
05:10:05 <hpc> when whatever you want is an autocomplete away, it doesn't stick in your brain as well
05:10:28 <AndreasK> Well if autocomplete works it also doesn't need to stick :)
05:11:33 <hpc> heh
05:24:37 * hackage potoki-cereal 0.3 - Streaming serialization  http://hackage.haskell.org/package/potoki-cereal-0.3 (NikitaVolkov)
05:31:11 <rkrishnan> I have a problem where I have this commandline program which takes an optional "code" from the user. If the code is not given as a commandline option, in the program, I get a maybe value. If that value is nothing, I prompt the user for an input.
05:31:33 <rkrishnan> Now, in both the cases (whether the user supplied the input via cmdline args) or via user input, I have to do some action.
05:32:17 <rkrishnan> Right now, I have a case expression that checks Just or Nothing, if Nothing, I take user input and does the action. If it is Just value, I do only the action after picking the value.
05:33:06 <rkrishnan> It somehow feels not right to repeat this .. so I was wondering if there is any way to abstract this. Not sure "abstracting" is the right word. It really feels like there must be a better way to do it.
05:34:10 <cocreature> rkrishnan: you could use something like "getValue :: Maybe Value -> IO Value" that returns the initial value if there is one or asks the user for a new value
05:34:53 <rkrishnan> ah, ok. Thanks cocreature.
05:40:44 <Athas> So, does anyone know of a correct implementation of floating point rounding (e.g. C's round()) for Haskell?
05:41:13 <merijn> Athas: What's wrong with round?
05:41:29 <Athas> :t round
05:41:31 <lambdabot> (Integral b, RealFrac a) => a -> b
05:41:42 <Athas> It cannot possibly be correct if it rounds to an integer.
05:41:46 <Athas> What about NaNs or infinities?
05:41:49 <merijn> ah
05:42:05 <quchen> > round (0/0 :: Double) :: Int
05:42:07 <lambdabot>  0
05:42:15 <Athas> Maybe the easiest thing is to just use the FFI to call C's round().
05:43:22 <merijn> That seems like an oversight in the Prelude
05:44:21 <Athas> Well, most people don't understand floats, nor need their more exotic features.
05:44:27 <quchen> > round (0/1 :: Double) :: Int
05:44:29 <lambdabot>  0
05:44:32 <quchen> Oh.
05:44:37 <Athas> I guess there is little overlap between the Haskell designers and scientific programmers.
05:45:18 <quchen> > round (1/0 :: Double) :: Int
05:45:20 <lambdabot>  0
05:45:21 <quchen> Be maxint
05:45:23 <quchen> ....nope
05:46:23 <Athas> This is the first (and hopefully only) use of the FFI I will have in this package!
05:46:24 <dminuoso> Uh.. is there a difference between MonadError and MonadThrow+MonadCatch?
05:47:07 <merijn> dminuoso: Those are not remotely the same
05:47:19 <merijn> dminuoso: MonadError is for ExceptT, i.e. Either
05:47:24 <cocreature> dminuoso: MonadError is for Either-like things MonadThrow+MonadCatch is for exceptions
05:47:32 <merijn> dminuoso: MonadThrow/MonadCatch are for Control.Exception
05:47:44 <dminuoso> Ahh, I missed the Exception contraint.
06:03:07 * hackage indexation 0.2 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.2 (NikitaVolkov)
06:05:45 <c50a326> http://book.realworldhaskell.org/read/sockets-and-syslog.html#hs.sockets.tcp.syslog how old is this example? I'm trying to figure out their use of the `handle` function from Control.Exception
06:05:47 <quicksilver> Athas: RealFrac doesn't deal with NaN or infinity
06:05:49 <c50a326> but there's an old one and a new one
06:05:53 <quicksilver> I'm aware that doesn't really answer your question
06:06:00 <quicksilver> but it wasn't omitted in ignorance
06:06:46 <c50a326> neither type sig seems to make sense, they pass an `MVar ()` as the first parameter but Control.Exception.handle wants `(Exception e -> IO a)
06:07:00 <dminuoso> c50a326: RWH in general is rather old.
06:07:20 <c50a326> can `MVar ()` be `(e -> IO a)` though? Maybe it can :s
06:07:30 <dminuoso> c50a326: You are confusing things.
06:07:31 <quicksilver> I think Control.Exception might have changed its API twice since that book :(
06:07:46 <c50a326> dminuoso: no shit :p
06:07:55 <dminuoso> c50a326: they define their own `handle :: MVar () -> HandlerFunc`
06:08:08 <dminuoso> c50a326: It's not meant to be Control.Exception.handle
06:08:14 <c50a326> ohhhh yeah below
06:08:58 <Athas> quicksilver: ah, so can I solve this some other way, for the concrete Double/Float types?
06:11:21 <Athas> I guess I could use the building blocks of RealFloat to take apart the numbers and implement rounding from scratch, but come on...
06:12:31 <merijn> Athas: Time to submit a patch to prelude after you've added the function you want! :)
06:12:52 <Athas> foreign import ccall "round" c_round :: Double -> Double
06:12:55 <Athas> That's my function!
06:13:10 <Athas> Although I guess I should use CDouble instead?  I can't figure out what purpose it serves.
06:14:04 <merijn> Athas: Saves your ass if your C implementation isn't using IEEE754 doubles :)
06:14:25 <Athas> Yeah, alright.  But then the FFI call won't do what I want anyway.
06:14:43 <merijn> Athas: Yes, but CDouble lets you find out at compile time, rather than getting weird behaviour
06:18:32 <Raybih> , nontrinitarian denominations comprise a minority of modern Christianity.
06:34:47 <muyfine> If I have a lensy nested data structure, and I'm holding on to a Maybe value of the outer structure, how do I preserve the maybe value to get access to the nested value?
06:34:54 <muyfine> https://pastebin.com/XYiYwgy9
06:35:15 <Cale> fmap?
06:35:48 <muyfine> basically given Bar inside of Foo, how do I implement Maybe Foo -> Maybe Bar
06:36:04 <Cale> In this case,  fmap :: (Foo -> Bar) -> Maybe Foo -> Maybe Bar
06:36:12 * hackage indexation 0.2.0.1 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.2.0.1 (NikitaVolkov)
06:36:34 <muyfine> oh nice, yeah that works
06:36:44 <Cale> So perhaps you want fmap (\(Foo x) -> x)
06:37:47 <quicksilver> or you can compose with _Just
06:37:57 <quicksilver> if you prefer the lensy way of looking at it
06:39:01 <muyfine> yeah, I was thinking of the lensy way to do it - with a preview or something - but the fmap makes lots of sense
06:39:08 <muyfine> thanks for the help!
06:41:45 <quicksilver> muyfine: if you have a lense you're using like this with a function:
06:41:51 <quicksilver> > (1,3) & _1 .~ 5
06:41:53 <lambdabot>  (5,3)
06:41:59 <quicksilver> erm
06:42:09 <quicksilver> > (1,3) & _1 %~ (*2)
06:42:11 <lambdabot>  (2,3)
06:42:16 <quicksilver> better example, now it's actually a function :)
06:42:23 <quicksilver> then you can use that same lens under Just:
06:42:30 <quicksilver> > Just (1,3) & _Just._1 %~ (*2)
06:42:32 <lambdabot>  Just (2,3)
06:48:07 <infinisil> :t (&)
06:48:09 <lambdabot> a -> (a -> b) -> b
06:48:44 <infinisil> :t flip ($)
06:48:45 <lambdabot> a -> (a -> c) -> c
06:50:48 <muyfine> what about if there's a value inside the structure? how do I preserve the maybe without using a join? https://pastebin.com/ux2DeBKh
06:51:53 <quicksilver> I'd expect a join in that case
06:52:26 <merijn> Or just use bind
06:53:01 <dminuoso> Let's say I have a few actions like `a :: IO (Either Err A)` and `b :: IO (Either Err B)`. Is there some idiomatic way to run them inside an `ExceptT Err IO ()` stack? Would I pick some operator for coerce?
06:53:09 <merijn> "f :: Foo -> Maybe Baz" means that "how" is just (>>=f)
06:53:45 <merijn> dminuoso: You just wrap each with ExceptT and then use >> ?
06:53:53 <merijn> dminuoso: What would you need to coerce?
06:54:03 <dminuoso> merijn: Well Im trying to avoid writing ExceptT over and over again.
06:55:41 <dminuoso> @let (#) :: Coercible a b => a -> b; (#) = coerce
06:55:41 <lambdabot>  Parse failed: Parse error: )
06:56:07 <merijn> Rewrite 'a' and 'b' to already be ExceptT?
06:56:34 <dminuoso> Not a big fan of that either.. mmm.
06:58:00 <dminuoso> @let action :: IO (Either String Int); action = pure 4
06:58:01 <lambdabot>  .L.hs:162:15: error:
06:58:01 <lambdabot>      • No instance for (Num (Either String Int))
06:58:01 <lambdabot>          arising from the literal ‘4’
06:58:10 <dminuoso> @let action :: IO (Either String Int); action = pure (pure 4)
06:58:11 <lambdabot>  Defined.
06:58:26 <dminuoso> % (%%) :: Coercible a b => a -> b; (%%) = coerce
06:58:27 <yahb> dminuoso:
06:58:36 <dminuoso> Oh that would be easier
06:58:43 <dminuoso> % (#) :: Coercible a b => a -> b; (#) = coerce
06:58:43 <yahb> dminuoso: ; <interactive>:20:3: error: parse error on input `)'
06:59:19 <cocreature> inventing some weird symbol just to avoid repeating a name seems like a pretty bad idea
07:01:15 <quicksilver> why set (#) = coerce?
07:01:20 <quicksilver> why not set (#) = ExceptT?
07:01:41 <quicksilver> but I think you are solving a weird problem here, and probably the wrong problem
07:03:43 <dminuoso> quicksilver: Well based on the context it's clear that the do-block is inside ExceptT already. The thought was just provoked by having seen similar things in the lens internals.
07:04:34 <dminuoso> Which I think does something like (.#) p = coerce p
07:05:22 <merijn> dminuoso: Using a cryptic operator rather than coerce is needlessly confusing and coerce isn't particularly nicer than just using ExceptT
07:05:33 <dreamer_> Hey
07:05:36 * hackage indexation 0.2.0.2 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.2.0.2 (NikitaVolkov)
07:05:39 <dmwit> Get the worst of both worlds. coerce `asTypeOf` ExceptT
07:06:05 <dmwit> Then you get to type ExceptT over and over, *and* you get to type coerce over and over, plus as a bonus you get to type asTypeOf over and over completely free!
07:06:17 <cocreature> lovely!
07:06:18 <dminuoso> Okay! With 4 people telling me in a row what Im doing is not particularly bright Ill just stop right here, apologize and use the constructive criticism. =P
07:07:25 <cocreature> obviously the right solution is to use RebindableSyntax so you can locally override (>>=) such that it behaves like ExceptT’s monad instance for IO (Either e a)
07:07:58 <dmwit> Oh neat, is the desugaring that local?
07:08:10 <dmwit> I guess in retrospect it makes sense.
07:08:29 <dmwit> % :set -XRebindableSyntax
07:08:29 <yahb> dmwit:
07:08:57 <dmwit> > let (>>=) = (+) in do x <- 3; 4
07:08:59 <lambdabot>  error:
07:09:00 <lambdabot>      • Could not deduce (Num (m a0))
07:09:00 <lambdabot>        from the context: (Num (m b), Num (m a), Monad m)
07:09:04 <quicksilver> it might be that the right solution is `a :: MonadIO m, MonadError Err m => m a`
07:09:19 <quicksilver> with extra parentheses for bonus syntactic validity
07:09:38 <dmwit> cocreature: what have I don wrong
07:09:42 <quicksilver> `a :: (MonadIO m, MonadError Err m) => m A`
07:09:57 <quicksilver> then you can use those actions in different monads which match
07:10:07 * hackage eigen 3.3.4.1 - Eigen C++ library (linear algebra: matrices, sparse matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-3.3.4.1 (chessai)
07:10:08 <dmwit> Oh, I know what I've done wrong.
07:10:20 <dmwit> ...many things.
07:10:43 <dmwit> % let (>>) = (+) in do 3; 4
07:10:44 <yahb> dmwit: 7
07:11:01 <cocreature> beautiful
07:11:02 <dminuoso> quicksilver: Is there an instance that would me the behavior of `IO (Either Err a)`?
07:11:21 <dmwit> dminuoso: Yes, ExceptT Err IO.
07:11:33 <cocreature> that has a different Monad instance
07:12:07 <dmwit> Oh. If you actually want to ignore errors as IO (Either Err a) does, then I think the question is strange and possibly wrong.
07:12:43 <dminuoso> dmwit: well the thing is I have one part of the problem that prefers to have that shape. That is I really dont want local errors to shortcircuit.
07:12:51 <dminuoso> *one part of the program!
07:12:53 <dminuoso> Heh.
07:12:55 <dmwit> Anyway MonadError does give catchError.
07:13:41 <dreamer_> I' ve been trying to make a stateful monad to hide configuration and drawables / fonts/ sound entities for a game engine , so I tried to.. https://paste.ee/p/D8XFe It compiles and I'm happy, and I made a few helper functions. But now I realize I can't even test it because the main function must be IO. How do I "unmonad" my state so that I can run it in main ?
07:13:48 <dmwit> But, like... what a do you give when you don't short circuit?
07:15:11 <dmwit> dreamer_: Use `runGST`?
07:15:21 <dminuoso> Ah.. I think Im beginning to understand why what Im doing is silly .
07:15:33 <agentultra> if I have a `newtype VersionKey = VersionKey (UUID, Int)` and a record with a field of type `Maybe VersionKey`; how does one write a lens to extract the elemnts of the newtype-wrapped tuple by traversing the Maybe?
07:16:01 <agentultra> I've tried various incantations of `traverse`, _Just, etc but the lens errors are still too dense for me to understand on my own.
07:17:03 <dmwit> ?let newtype VersionKey = VersionKey (UUID, Int)
07:17:05 <lambdabot>  .L.hs:164:34: error: Not in scope: type constructor or class ‘UUID’
07:17:05 <lambdabot>      |
07:17:05 <lambdabot>  164 | newtype VersionKey = VersionKey (UUID, Int)
07:17:21 <agentultra> let's say Text for now then, UUID doesn't matter much
07:17:22 <dmwit> ?let type UUID = String
07:17:24 <lambdabot>  Defined.
07:17:25 <dmwit> ?let newtype VersionKey = VersionKey (UUID, Int)
07:17:26 <lambdabot>  Defined.
07:17:29 <phadej> agentultra: youWant :: Applicative f => (UUID -> f UUID) -> VersionKey -> f VersionKey -- write that function
07:17:55 <dmwit> :t iso VersionKey (\(VersionKey v) -> v)
07:17:56 <lambdabot> (Functor f, Profunctor p) => p VersionKey (f VersionKey) -> p (UUID, Int) (f (UUID, Int))
07:18:12 <phadej> and you want specifically something else than `youWant _ vk = pure vk`
07:18:13 <dmwit> ?let versionKey = iso VersionKey (\(VersionKey v) -> v)
07:18:15 <lambdabot>  Defined.
07:18:16 <phadej> as that won't do anything
07:18:47 <phadej> or than using building blocks dmwit is building for you
07:18:48 <phadej> :)
07:18:58 <agentultra> Heh, thanks. :)
07:19:43 <dmwit> :t _Just . from versionKey . _1
07:19:45 <lambdabot> Applicative f => (UUID -> f UUID) -> Maybe VersionKey -> f (Maybe VersionKey)
07:19:59 <dmwit> :t _Just . from versionKey . _2
07:20:00 <lambdabot> Applicative f => (Int -> f Int) -> Maybe VersionKey -> f (Maybe VersionKey)
07:20:21 <dreamer_> wo
07:20:27 <dreamer_> x)
07:20:29 <agentultra> nice.
07:20:44 <phadej> :t makeWrapped
07:20:45 <lambdabot> Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Lib.DecsQ
07:20:51 <dmwit> agentultra: But it's probably simpler to `data VersionKey = VersionKey { _uuid :: UUID, _version :: Int }` and use the lens-provided TH to get `uuid` and `version` lenses for free.
07:21:01 <phadej> ^ +1
07:21:07 <dmwit> newtype-wrapping a tuple is a code smell
07:21:31 <dreamer_> thankos
07:23:03 <agentultra> dmwit: thanks, I'll try that out. I was starting to get the sense that this was getting more complicated than it ought to be
07:23:43 <agentultra> but still, nice to learn. :)
07:24:19 <agentultra> also I have budget to hire another haskell programmer, another posting may be incoming on /r/haskell
07:25:09 <orion> agentultra: May I PM you?
07:25:27 <agentultra> orion: please, by all means
07:36:05 <dmwit> dreamer_: By the way, you should consider just using `StateT`.
07:36:37 * hackage keccak 0.1.2 - haskell keccak functions  http://hackage.haskell.org/package/keccak-0.1.2 (aupiff)
07:37:34 <dmwit> You might have to add `FontT fonts` or `GameState game` to some of your type signatures, but you wouldn't have to write any of these instances.
07:37:52 <dmwit> (Do those classes have more than one instance anyway?)
07:41:45 <natim87> arkadefr: o/
07:48:15 <arkadefr> natim87: hey :)
07:52:06 * hackage distribution-opensuse 1.0.0 - Types, functions, and tools to manipulate the openSUSE distribution  http://hackage.haskell.org/package/distribution-opensuse-1.0.0 (PeterSimons)
08:01:46 <orion> Does anyone know (without me adding more context), why I might be able to execute "runReaderT f undefined" and have the code compile and run correctly?
08:02:12 <tdammers> orion: the default ReaderT is non-strict
08:02:40 <tdammers> orion: so if the code ends up never looking at the original state, then the undefined never gets evaluated, and all is fine
08:02:41 <c_wraith> I don't think a strict ReaderT would add anything of value anyway
08:03:03 <dmwit> :t runReaderT
08:03:03 <tdammers> wait, Reader, not State, of coures
08:03:04 <lambdabot> forall k r (m :: k -> *) (a :: k). ReaderT r m a -> r -> m a
08:03:10 <orion> Ok. More context: I'm working with a library nearly identical to amazonka, which uses mtl-style for its type signatures.
08:03:21 <tdammers> but still - if the context is never demanded, then it won't be evaluated
08:03:35 <orion> There is a class called "HasEnv": https://www.stackage.org/haddock/lts-12.1/amazonka-1.6.0/Control-Monad-Trans-AWS.html#t:HasEnv
08:03:39 <tdammers> > runReaderT (liftIO $ putStrLn "hi!") undefined
08:03:41 <lambdabot>  error:
08:03:41 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M689702358995...
08:03:41 <lambdabot>        prevents the constraint ‘(Show (m0 ()))’ from being solved.
08:04:02 <tdammers> > runReader (return "hello") (undefined :: Int)
08:04:04 <lambdabot>  "hello"
08:04:15 <tdammers> or even:
08:04:31 <tdammers> > runReader (do { x <- ask; return "hello" }) (undefined :: Int)
08:04:33 <lambdabot>  "hello"
08:04:46 <tdammers> if you unwrap the Reader, it'll be a bit more obvious what's going on
08:04:50 <orion> Note: runAWST :: HasEnv r => r -> AWST' r m a -> m a <-- I am able to pass undefined to runAWST and have it work.
08:05:11 <orion> The environment is actually being read from the typeclass instance for HasEnv.
08:05:36 * hackage streaming-benchmarks 0.2.0 - Benchmarks to compare streaming packages  http://hackage.haskell.org/package/streaming-benchmarks-0.2.0 (harendra)
08:05:41 <dmwit> Why do you believe the environment is actually being read?
08:06:01 <orion> dmwit: If I instantiate my AppEnv with "environment = undefined" the application blows up at runtime.
08:06:23 <orion> e.g. instance HasEnv AppEnv where environment = undefined
08:06:33 <orion> (See link above for definition of HasEnv)
08:07:15 <dmwit> This tells me only that `environment` is being called, not that its result is being read.
08:07:59 <dmwit> :t lens
08:08:01 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
08:08:35 <dmwit> :t lens (const undefined) (\_ _ -> undefined)
08:08:36 <lambdabot> Functor f => (a -> f b1) -> b2 -> f t
08:08:37 <orion> It's being read because the application exhibits correct behavior which could only be achieved through information contained in the lens.
08:09:32 <orion> For example, let's say there is a database connection handle in the Env. If the program compiles and, when run, populates a datebase, then I can be confident that the lens was read.
08:09:40 <dmwit> Another possibility, I suppose, is that some part of the library is catching exceptions in a naughty way.
08:10:13 <dreamer_> I'm looking up StateT
08:10:14 <orion> I think the behavior I'm seeing is related to mtl-style.
08:10:17 <dreamer_> thanks
08:11:15 <orion> For example: send :: (AWSConstraint r m, AWSRequest a) => a -> m (Rs a)
08:11:23 <orion> Where: type AWSConstraint r m = (MonadThrow m, MonadResource m, MonadReader r m, HasEnv r)
08:12:14 <dmwit> Perhaps you could put together a minimal example which you think should definitely read from undefined, but doesn't appear to.
08:12:41 <orion> dmwit: Yes. It's tough in my case though because I'm writing proprietary code for my employer.
08:12:44 <dmwit> I estimate a 5% chance that you will see new ideas about what's happening appear in this channel  without doing that.
08:13:16 <orion> I think your estimate is sound.
08:15:51 <orion> dmwit: Are you aware of any common problems resulting from two ReaderTs layered on top of one another?
08:16:28 <tdammers> layering two ReaderT's hides the inner one from the MonadReader instance, so `ask` might not work as expected
08:16:54 <tdammers> personally, I'd tuple them up, or wrap them in a record type
08:17:02 <dmwit> Right. The main "problem" is just that it's annoying to lift the wrapped ask right.
08:17:22 <tdammers> then you can say fst <$> ask, or recordField <$> ask (or you can use asks, which boils down to the same thing)
08:17:45 <dmwit> If you don't mean literal ReaderTs -- e.g. if you may be asking about newtype-wrapped ReaderTs that do MonadReader differently -- the answer changes.
08:17:55 <dmwit> But there still aren't serious problems.
08:18:46 <dmwit> e.g. AWST is such a wrapper.
08:19:12 <dmwit> Oh, no it ain't. It gives the same MonadReader instance you would get from ReaderT. I admit I'm a bit surprised.
08:20:12 <orion> dmwit: What did you expect?
08:20:15 <dmwit> But: perhaps you are writing runReaderT undefined, and not runAWST undefined.
08:20:36 <dmwit> orion: I expected `instance MonadReader r m => MonadReader r (AWST r' m)`.
08:21:14 <dmwit> That is, I expected AWST was a newtype wrapper exactly to avoid exposing its argument as `ask`, and instead exposing it as some AWS-specific name, maybe, `askAWSEnv` or something.
08:21:57 <orion> ah
08:22:23 <orion> Yeah, it accesses the environment via HasEnv/environment.
08:22:35 <orion> It might as well be named "HasAWSEnv"
08:22:55 <dmwit> Anyway, if you are using runReaderT and not runAWST, you may be seeing type inference infer an extra ReaderT wrapper compared to what you intended.
08:23:52 <dmwit> > runReaderT (runStateT (get >>= put . (+1)) 0) undefined -- now imagine runStateT is runAWST and you thought you were passing undefined for the environment
08:23:54 <lambdabot>  error:
08:23:54 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M196381545603...
08:23:54 <lambdabot>        prevents the constraint ‘(Show
08:24:03 <dmwit> > runReader (runStateT (get >>= put . (+1)) 0) undefined -- now imagine runStateT is runAWST and you thought you were passing undefined for the environment
08:24:06 <lambdabot>  ((),1)
08:24:45 <orion> I just discovered something: Instead of "newtype App a = App { unApp :: ReaderT AppEnv (AWST' Env IO) a }" and "runApp env (App f) = runAWST undefined $ runReaderT f env", I can do the following:
08:25:16 <orion> "newtype App a = App { unApp :: ReaderT AppEnv IO a", "runApp env (App f) = runReaderT f env"
08:25:23 <orion> And it both compiles and runs properly.
08:26:14 <dmwit> Uh huh. So: you didn't lift any of your AWS actions, and all `ask`s were about the ReaderT, not the AWST.
08:27:28 <orion> indeed/
08:27:35 <orion> Looks like the mystery is solved.
08:28:09 <orion> It's kind of beautiful that I can get correct behavior with a simpler transformer *and* not have to lift anything.
08:30:39 * hackage cabal2spec 2.2.0 - Convert Cabal files into rpm spec files  http://hackage.haskell.org/package/cabal2spec-2.2.0 (PeterSimons)
08:32:20 <dmwit> orion: I'd just like to point out that everybody's first suggestion (your undefined environment isn't being read) was correct.
08:37:33 <dmwit> I wonder why AWST exists at all.
08:37:46 <dmwit> What does it do that ReaderT doesn't?
08:39:06 <merijn> dmwit: Maybe nothing
08:39:33 <merijn> dmwit: The advantage of a specific AWST rather than using ReaderT would be the fact that it doesn't stop users from using ReaderT for their own stuff
08:41:14 <dmwit> But because they didn't introduce a MonadAWS, and just reused MonadReader, that isn't even defensible.
08:41:22 <merijn> hmm
08:41:25 <dmwit> Because AWST already prevents users from using ReaderT for their own stuff.
08:43:02 * [exa] thought AWST is some new awesome version of RWST
08:43:18 <glguy> Users can continue ignoring MonadReader like they should be and they'll be just fine :)
08:43:38 <Taneb> [exa]: same
08:43:50 * [exa] saddened
08:43:59 <Taneb> Asynchronous Writer State Transformer
08:46:46 * hackage relational-query-HDBC 0.7.1.1 - HDBC instance of relational-query and typed query interface for HDBC  http://hackage.haskell.org/package/relational-query-HDBC-0.7.1.1 (KeiHibino)
09:09:44 <c_wraith> why is Data.Coerce marked Unsafe?
09:14:40 <c_wraith> hahaha... I can't ask lambdabot to import Data.Coerce because it's Unsafe. but..
09:14:46 <c_wraith> :t coerce
09:14:47 <lambdabot> Coercible s a => s -> a
09:15:08 <c_wraith> when lambdabot already has something equivalent in scope, I can fake it!
09:15:36 <noipmups> How can I transform some scalar value into a tuple? For example when I have value `42` and wants result (2*42, 42+3)?
09:15:41 <cocreature> c_wraith: maybe because it could break things if authors do not add role annotations?
09:16:46 <c_wraith> cocreature, ah, good point. it can break invariants that are intended to be preserved by module boundaries if role annotations are wrong.
09:17:34 <glguy> noipmups: You'd do exactly what you just wrote
09:18:04 <c_wraith> noipmups, you can use clever stuff from Control.Arrow if you really need to. but I'd just use a lambda.
09:18:48 <c_wraith> :t \x -> (2*x, x+3)
09:18:49 <lambdabot> Num b => b -> (b, b)
09:18:49 <noipmups> c_wraith: How the arrow solution could look like?
09:19:11 <c_wraith> :t (2*) &&& (+3)
09:19:12 <lambdabot> Num b => b -> (b, b)
09:19:40 <c_wraith> that's not even noticeably shorter than the lambda
09:20:50 <infinisil> What is the recommended way to deal with exceptions in haskell?
09:21:19 <infinisil> There is just returning Either's, using ExceptT, MonadFail, IO exceptions
09:21:27 <infinisil> And every library uses something different
09:22:33 <glguy> There are multiple solutions because there are multiple problems. If you're already using IO to solve a problem then using the IO exceptions machinery gives you good performance and flexibility
09:23:08 <glguy> If you're building up some small local pure computation Either works out
09:23:38 <glguy> ExceptT is useful when defining interesting newtype'd monads or used raw in some local isolated implementation
09:24:58 <infinisil> Hmm thanks I'll think about that
09:25:29 <truthadjustr> need some tip on how to do a variant of fold we shall call `foldx`. It alternates between two functions instead of one
09:26:02 <infinisil> truthadjustr: cycle + zip with $
09:26:28 <infinisil> Wait maybe not zip
09:27:18 <c_wraith> truthadjustr, just write it by hand reversing the function arguments in the recursive call?
09:29:09 <truthadjustr> c_wraith: but i need a state counter here, and check with modulo 2? i'm doing this to practice my haskell, by the way...
09:31:17 <c_wraith> truthadjustr, you don't need any sort of counter.
09:31:36 <c_wraith> truthadjustr, but what type do you have in mind? it can change things.
09:32:04 <c_wraith> truthadjustr, also, do you want this to be a foldr or a foldl?
09:33:00 <truthadjustr> c_wraith: don't care wither L or R.. i just want to see how to switch between 2 functions in alternate
09:33:28 <truthadjustr> without a state counter, how do you decide ?
09:35:22 <c_wraith> > let mapx f g xxs = case xxs of [] -> [] ; (x:xs) -> f x : mapx g f xs in mapx (+1) (*2) [1..10]
09:35:24 <lambdabot>  [2,4,4,8,6,12,8,16,10,20]
09:35:43 <jackhill> l
09:36:35 <c_wraith> there is no "decide", there is only "tell the future to do the opposite"
09:41:07 <truthadjustr> c_wraith: thanks...
09:50:59 <EvanR> i am writing my first android app. Nobody is allowed to complain about ghc/cabal build times anymore
10:03:39 <agentultra> EvanR: I complained a month ago at a talk at the local university where I am... guess I made the cutoff. :)
10:04:16 <EvanR> lucky
10:06:00 <zincy_> Say I have [(Int, a)]  how would I use lens to traverse and set the fst element of all the tuples to String?
10:06:41 <cocreature> zincy_: you want to set all of them to the same fixed string?
10:07:12 <zincy_> cocreature: rather call show on them all
10:07:57 <cocreature> > over (traverse . _1) show [(1,()), (2,())]
10:07:59 <lambdabot>  [("1",()),("2",())]
10:08:43 <cocreature> but you don’t really need lens for that
10:08:54 <cocreature> > map (first show) [(1,()),(2,())]
10:08:56 <lambdabot>  [("1",()),("2",())]
10:11:52 <zincy_> thanks!
10:12:32 <AWizzArd> Could someone show me a tiny example that demonstrates how RankN types „protect” ST state from escaping? That example wouldn’t compile of course, but it would show the intention of trying to let state escape.
10:12:34 <zincy_> :t first
10:12:35 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
10:14:12 <dmwit> AWizzArd: `runST (newSTRef 0)`
10:15:00 <cocreature> :t Data.Bifunctor.first -- zincy_: I was actually thinking of that one
10:15:01 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
10:15:37 <cocreature> they both work here but I don’t like Arrow very much :)
10:16:37 <tieTYT> hi, I don’t get this: ghci> Map.empty  => fromList []    What is that returning?  It looks like it’s returning a function with [] as an argument.  Am I reading that right?
10:17:10 <tieTYT> why isn’t it evaluated
10:17:10 <jbetz> how do I build an executable with profiling using `cabal new-build`?
10:17:59 <jbetz> `cabal new-build prof --enable-profiling --enable-library-profiling` fails with errors about not having profiling libraries for my build dependencies installed
10:18:20 <liste> tieTYT: that's just the Show instance of Map
10:18:34 <AWizzArd> dmwit: the author of this bit would hope to extract the 0 yes? Interesting, thx for this example.
10:18:35 <tieTYT> liste: ah!  That makes sense
10:18:52 <tieTYT> how could I have figured that out on my own?
10:19:18 <cocreature> jbetz: do you have some Haskell packages (not shipped with GHC) installed globally? otherwise cabal should handle this properly
10:19:18 <tieTYT> ah a :t returns Data.Map.Internal.Map k a
10:19:20 <zincy_> :t Data.Bifunctor.second
10:19:21 <lambdabot> Bifunctor p => (b -> c) -> p a b -> p a c
10:19:28 <cocreature> jbetz: oh also which version of new-build are you using?
10:19:40 <dmwit> > [(1, ()), (2, ())] >>= _1 (return . show)
10:19:43 <lambdabot>  [("1",()),("2",())]
10:19:58 <dmwit> AWizzArd: No, the author would hope to extract a mutable reference cell.
10:20:22 <liste> tieTYT: the P in ghci's REPL does 'show'
10:20:24 <jbetz> cocreature: I'm using cabal v 2.0.0.0
10:20:46 <dmwit> AWizzArd: Which they could then potentially update or read from within pure code.
10:20:51 <cocreature> jbetz: you probably want to upgrade to 2.2 if you are using new-build but I don’t think that’s the problem here
10:21:12 <dmwit> AWizzArd: If you just want the 0, that's perfectly fine: `runST (newSTRef 0 >>= readSTRef)` typechecks.
10:21:51 <jbetz> cocreature: as for your first question, I don't think so. to verify, I wiped out ~/.cabal and ran it again, and  it still failed in the same way.
10:22:37 <jbetz> should mention I'm running this inside a nix-shell that provides a bunch of packages. could that be the problem?
10:22:57 <dmwit> tieTYT: "figuring it out" would indeed be difficult. It is just a piece of knowledge you must have: ghci calls `show`. The documentation probably mentions it somewhere; that would be the easiest way to "figure it out".
10:24:01 <jbetz> when I run it outside the shell, it fails in a different way, saying that it can't resolve my project packages as dependencies
10:24:26 <cocreature> jbetz: I suspect so. packages provided by nix-shell are basically global packages for cabal. you should probably either let cabal manage your Haskell deps or have nix install them with profiling
10:25:54 <jbetz> cocreature: I'll see if I can get cabal to do it. so next question is, how can I help it find my project packages?
10:26:59 <AWizzArd> dmwit: so why does this hurt the constraint on runST?
10:27:05 <dmwit> jbetz: Create a `cabal.project` with `packages: /path/to/a /path/to/b /path/to/c`.
10:27:10 <cocreature> jbetz: hard to say without seeing the actual error
10:27:10 <geekosaur> jbetz, note that ~/.cabal is not the important thing tor emove there, ~/.ghc is
10:27:10 <jbetz> I have a cabal.project file in my root project directory that has each of the subpackages listed (basically same as this: https://github.com/ElvishJerricco/reflex-project-skeleton/blob/master/cabal.project)
10:27:26 <dmwit> jbetz: The paths can be on separate lines. I think they need to be indented to stay part of the `packages:` stanza, but I'm not super clear on cabal syntax, honestly.
10:27:34 <geekosaur> I don;t understand why everyone zeroes in on ~/.cabal so they can completely break ghc's package registry
10:27:41 <geekosaur> as if that somehow fixes everything
10:28:13 <cocreature> geekosaur: I think for new-build ~/.cabal or ~/.cabal/store more precisely is actually the place that matters?
10:28:14 <dmwit> AWizzArd: I don't understand the question. What is "this"? What does it mean to "hurt a constraint"?
10:29:13 <geekosaur> possibly. ~/.cabal seems overkill for new-build (and in fact old-build); it's still the wrong thing to do. some subdirs, yes
10:29:19 <AWizzArd> dmwit: why does  `runST (newSTRef 0)`  result in an error? What does the RankN type do here?
10:29:24 <geekosaur> but I guess it[s really important to do as much damage as possible
10:29:48 <elvishjerricco> jbetz: You're trying to get profiling working? Is this with reflex-platform?
10:30:02 <jbetz> cocreature: ```Resolving dependencies... cabal: Could not resolve dependencies: trying: backend-0.1.0.0 (user goal) unknown package: obelisk-executable-config-inject (dependency of backend-0.1.0.0) fail (backjumping, conf```
10:30:16 <elvishjerricco> reflex-platform has a Nix argument for enabling profiling
10:30:18 <jbetz> okay, so it's not a project package...
10:30:33 <jbetz> elvishjerricco: yup, an obelisk project
10:30:38 <dmwit> AWizzArd: `newSTRef 0` has type `ST s (STRef s Int)`. This can't be given type `forall s. ST s X` for any `X` because the two `s`s in its type are connected.
10:30:41 <elvishjerricco> Not sure how to do it with obelisk :/
10:31:12 <jbetz> elvishjerricco: I did try `(import ./.obelisk/impl { profiling = true; })`, but that didn't seem to help
10:31:17 <AWizzArd> dmwit: but the forall constraint is on `s` and not on the X.
10:31:22 <jbetz> I think that's only for profiling obelisk itself, not the apps that it runs
10:31:49 <dmwit> AWizzArd: The type of `runST` is `(forall s. ST s a) -> a`. Therefore the `a` may not mention `s`, because `s` is not in scope on the right-hand side of the arrow.
10:32:00 <cocreature> I only know how to do this with standard nixpkgs, no idea about obelisk
10:32:12 <elvishjerricco> jbetz: Hm... Well one thing is for sure; trying to let cabal build all your dependencies from Hackage is NOT the right way to do this with obelisk
10:32:35 <elvishjerricco> But sorry, I'm unfamiliar with obelisk.
10:32:49 <elvishjerricco> It's a bit too over the top and magical for me
10:32:58 <AWizzArd> dmwit: okay, but it would be on the right-hand side if we would actually „unwrap” the ST returned by `newSTRef 0.
10:33:25 <jbetz> elvishjerricco: is that because cabal can't install packages that aren't on hackage?
10:34:25 <cocreature> I think the main point of obelisk is to provide haskell deps in a format suitable for cross compilation, ghcjs, …
10:34:31 <cocreature> if you let cabal manage your deps, you lose all that
10:35:37 <elvishjerricco> jbetz: Yea, at the very least, the Reflex libraries are pinned from github, which cabal won't know to do on its own; you'd have to duplicate all the github pinnings with git submodules or something
10:35:56 <dmwit> AWizzArd: That... sounds like you're on the right track.
10:36:03 <elvishjerricco> And then there's the massive amount of curation in package versions, flags, and fixes for GHCJS.
10:36:35 <elvishjerricco> Plus system libraries for the ghc builds
10:37:03 <elvishjerricco> Cabal can't install those, let alone pin them but nix can
10:39:36 * hackage ivory-hw 0.1.0.6 - Ivory hardware model (STM32F4).  http://hackage.haskell.org/package/ivory-hw-0.1.0.6 (EricMertens)
10:40:39 * hackage ivory-backend-c 0.1.0.8 - Ivory C backend.  http://hackage.haskell.org/package/ivory-backend-c-0.1.0.8 (EricMertens)
10:42:58 <dmwit> Also I object to my first explanation ("This can't be given type `forall s. ST s X` for any `X`") on the grounds that it is stupid and wrong.
10:45:27 <jbetz> elvishjerricco: :/ the magic of `obelisk` is quickly losing it's allure
10:50:44 <jbetz> but I still want to use and improve it
11:49:08 * hackage data-standards 0.1.0.1 - A collection of standards representable by simple data types.  http://hackage.haskell.org/package/data-standards-0.1.0.1 (ageitilt)
11:53:53 <yuriy> hello.  what about remote jobs for haskell? am i able try to work (pre)junior dev somehow when prepare teoritically?
11:57:37 * hackage ztar 0.1.2 - Creating and extracting arbitrary archives  http://hackage.haskell.org/package/ztar-0.1.2 (brandonchinn178)
11:58:12 <yuriy> cardano? does anybody contribute to that project?
11:59:23 <cocreature> there are remote jobs but prejunior is probably going to be hard
12:00:48 <Gurkenglas> Might be interesting to have a thing where many anonymous people get into a collaborative editor and get shown a file of code and are to hack on it to "improve" it by generalizing, refactoring, etc and other applicable tasks, and a mod sees and moderates the changes as they happen, and maybe someone gets hired.
12:00:57 <Welkin> wtf is "prejunior"?
12:01:18 <Welkin> Gurkenglas: that is called Copdrpad
12:01:20 <Welkin> Coderpad
12:01:22 <Welkin> and it exists
12:01:40 <Welkin> interviewing is broken and stupid though, and that won't solve it
12:01:44 <ZeuPiark> hello
12:01:49 <Welkin> it makes it worse
12:02:15 <Gurkenglas> Welkin, the problem is that people can be better at interviews than jobs, right?
12:02:33 <Welkin> no
12:02:40 <Gurkenglas> Explain then pls
12:03:00 <Welkin> the problem is that the whole process is a big charade or wear down engineers to get them to accept a poor offer
12:03:28 <yuriy> prejunior - i mean like intern near starred developer
12:03:31 <Welkin> after all the tests and exams it still ends up being based on if they like you or not
12:03:31 <Welkin> charade to wear down*
12:03:34 <Gurkenglas> Wear down? It seems to me like interviews are more fun than jobs.
12:04:23 <Gurkenglas> In fact I'd guess I'd like a job that looks like just a series of technical interviews.
12:04:26 <Welkin> interviewers are incompetent and ask useless trivia questions, or ask you to do live coding while they stare over your shoulder and time you
12:04:34 <Welkin> it's a joke
12:05:37 <Welkin> this reinforces the idea that you are a commodity, because you are being "Tested" and competing against others for the same position
12:05:48 <Welkin> it only benefits the interviewer, and it only hurts you
12:05:52 <yuriy> if interviewer ask such questions maybe you don't need such job
12:06:17 <agentultra> Welkin: I resemble that :p
12:06:47 <agentultra> (and I am being sarcastic) ... interviewing is a process and not every company does it well.
12:06:54 <Gurkenglas> Why is it a bad thing to throw markets at it? You can take that both ways, "interview" at many places and keep working wherever they treat you like you want.
12:07:12 <agentultra> the better ones don't ask arbitrary trivia questions on the fly and make decisions based on "gut feeling"
12:07:25 <huytd> like: What is a monad? in an interview?
12:07:51 <monochrom> This is #haskell-offtopic material.
12:08:06 <agentultra> monochrom: indeed. apologies.
12:08:21 <yuriy> anyway - without interview you won't get job
12:08:25 <Gurkenglas> Transplanting conversations to other channels seems like it usually just kills them. I'd be less annoyed by that if that were explicit
12:08:35 <Welkin> yuriy: that's wrong
12:09:05 <monochrom> Oh that just shows you how much the participants really care about that conversation.
12:09:05 <dolio> The conversation can also be killed by monochrom banning a bunch of people. :)
12:09:07 <Welkin> my first job ever I just chatted with someone for about 30 minutes, then I gave them an estimate for how much the contract would cost
12:09:18 <Welkin> it was a contract job, but I just walked in and they offered a project to me
12:09:26 <monochrom> Welkin? Are you done?
12:09:30 <Welkin> yes
12:09:34 <Welkin> I'll move to offtopic
12:11:01 <Gurkenglas> monochrom, you think it wouldn't kill on-topic conversations?
12:35:21 <butterthebuddha> What do people think of mixing do notation with explicit calls to bind?
12:36:20 <c_wraith> butterthebuddha, it can be fine. it's a matter of taste as to if it's getting excessive or not.
12:36:25 <cocreature> butterthebuddha: nothing wrong with that
12:37:12 <butterthebuddha> I was expecting otherwise, but glad to be surprised
12:38:19 <butterthebuddha> I like to write code that's as pointfree as possible without losing readability because naming things is hard
12:38:41 <c_wraith> butterthebuddha, I find I use =<< more than >>= when doing that. it feels more like $
12:39:52 <butterthebuddha> =<< is more in line with the general pattern of composition, but the imperative programmer in me gets super confused at having to read backwards
12:40:31 <shapr> I never did figure out why code reads from right to left
12:40:45 <cocreature> it doesn’t look backwards if you compare it to regular function application
12:40:55 <cocreature> f . g = \x -> f (g x)
12:40:58 <cocreature> it’s the same order
12:41:02 <Welkin> it should read from top to bottom, left to right, like chinese and japanese
12:41:10 <Welkin> top to bottom, right to left*
12:41:29 <butterthebuddha> cocreature: I get that, but old habits die hard :P
12:43:01 <pally> :t (+1)
12:43:02 <lambdabot> Num a => a -> a
12:43:35 <cocreature> butterthebuddha: there is nothing inherently wrong with (>>=) either. some code is easier to read with (>>=), some is easier to read with (=<<)
12:43:55 <pally> Is there a problem with saying: "(+1) is a *value* of type a -> a, such that a is an instance of Num"?
12:44:30 <c_wraith> pally, I don't have any objections to that phrasing.
12:44:32 <geekosaur> only insofar as some people's brains break when you refer to a function as a value. on the other hand, that is kinda the definition of a functional programming language, that functions are values
12:44:50 <cocreature> in a Haskell context, I would object to not calling functions values :)
12:44:55 <c_wraith> pally, and I get really pedantic about terminology. :)
12:46:01 <pally> geekosaur, two weeks ago, my brain broke, but I've learn to accept.
12:46:04 <pally> learned*
12:46:34 <Welkin> pally wanna cracker?
12:47:59 <c50a326> woooo yeahhhh... I have smart completion working in an editor... go spacemacs woooo
12:48:01 <c_wraith> pally, if I go maximum pedant and look for anything to criticize, the most I come up with is that (+1) is an expression denoting a value... but that's hardly a useful distinction unless you're writing a compiler.
12:49:38 <dolio> shapr: Math.
12:50:40 <shapr> dolio: QED
12:57:17 <dmwit> I like using (=<<) and (.) together. With no (.), (>>=) feels more natural.
12:59:36 <glguy> I use a lot more =<< than >>=, using =<< feels closer to using normal function application
13:00:05 <glguy> also when using do notation it makes more sense to me when combined with <-
13:00:18 <glguy> x <- f =<< m =<< n
13:00:59 <Rembane> Mixing <$> and >>= makes for ... interesting code.
13:01:06 <glguy> >>= works well with a lambda, however
13:01:33 <Rembane> But <$> and =<< is really nice.
13:04:05 <infinisil> :t (=<<)
13:04:06 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:04:11 <infinisil> :t (>>=)
13:04:12 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:04:26 * infinisil is not surprised
13:04:50 <Welkin> do you often speak about yourself in the 3rd person?
13:05:01 * Rembane doesn't.
13:05:03 * infinisil doesn't know what Welkin is talking about
13:05:46 <dmwit> Perhaps Welkin does not understand the way his client shows actions.
13:07:37 * lambdabot acts.
13:08:07 <Tops2> ACTION asks: What's a good way to create Enum instances for the valid values of a bunch of product types of integers with statically known bounds (all from 0 or 1 to 20 at most). For example: data Gate = Gate { i :: Int, j :: Int, k :: Int} and I have predicates for valid values like (0 < i < j < 20) or like (i < 2j-1 <2j <k) or like (i == k implies k == j)  The enumeration needs to be contiguous. And I will be calling fromEnum mi
13:08:07 <Tops2> s of times, so it should be fast, though toEnum is not as important.
13:08:24 <glguy> Tops2: Your client doesn't know about actions when it linewraps :(
13:09:20 <glguy> also your client doesn't appear to know the maximum message length that you're able to send and you lost something in the middle
13:09:37 <dmwit> Tops2: A couple calls to `quotRem` ought to do the trick.
13:09:48 <dmwit> glguy: My guess is "llion".
13:14:36 * hackage errors-ext 0.4.2 - `bracket`-like functions for `ExceptT` over `IO` monad.  http://hackage.haskell.org/package/errors-ext-0.4.2 (warlock)
13:22:57 <Tops2> ? What did I lose in the middle?
13:22:57 <Tops2> I'm not sure how to quotRem helps me here. I can see it being useful for the implementation of toEnum, but other than that I don't know.
13:22:57 <Tops2> But line wrap normally works for me :(
13:22:57 <Tops2> What's a good way to create Enum instances for the valid values of a bunch of product types of integers with statically known bounds (all from 0 or 1 to 20 at most).
13:22:57 <Tops2> For example: data Gate = Gate { i :: Int, j :: Int, k :: Int} and I have predicates for valid values like (0 < i < j < 20) or like (i < 2j-1 <2j <k) or like (i == k implies k == j)
13:22:57 <Tops2> The enumeration needs to be contiguous. And I will be calling fromEnum millions of times, so it should be fast, though toEnum is not as important.
13:23:46 <wpcarro> I researching source-jumping solutions for Haskell in the form of hstags, etags, and ctags. Does anyone here use any of the aforementioned tools (or all of them) and have opinions about their reliability?
13:24:03 <noipmups> Can someone please help me with postgresql-simple (see https://stackoverflow.com/questions/51389602/nested-data-types-in-postgresql-simple)?
13:40:00 <c50a326> what is () again? An empty type?
13:40:14 <c50a326> (in the context of type signatures)
13:40:19 <glguy> No, it's the "unit" type
13:40:37 <glguy> It has a value: () -- at the value level
13:40:41 <glguy> Void is the "empty" type
13:42:35 <c50a326> ah ok thanks, phew I'm really tired all of a sudden, gonna sleep, nn!
13:55:25 <dmwit> Tops2: Right, quotRem is useful for toEnum. And (*)/(+) is for fromEnum.
13:55:37 <dmwit> Tops2: The rest can be implemented in terms of those.
13:56:34 <dmwit> ?tell wpcarro I use hasktags a lot and like it. It misses some declarations in complicated (extension-heavy) Haskell, though.
13:56:34 <lambdabot> Consider it noted.
13:57:30 <dmwit> ?tell wpcarro If you work on big projects with cabal new-* and lots of potentially overlapping submodules, you might like https://github.com/dmwit/cabtags but it is definitely overkill for less cluttered codebases.
13:57:30 <lambdabot> Consider it noted.
14:12:11 <AndreasK> Is there way to tell cabal new-*  to pull a dependency from git?
14:16:29 <reactormonk> Is there a "not equal" constraint, similar to ~ ?
14:17:06 <geekosaur> no, and there can't be except within a predefined set of types
14:18:01 <dukedave> Could someone explain what 'cannot be captured' means in the first bullet, here https://markkarpov.com/tutorial/th.html#the-q-monad ?
14:18:26 <Boarders> does anyone know any way to express the category of categories in haskell?
14:18:48 <dukedave> It seems like it should say 'can be captured', i.e. we want to generate things in THwhich we can reference elsewhere in the code?
14:20:16 <geekosaur> dukedave, it means that the name can't be captured by whatever code you're splicing it into. or put otherwise, it can't accidentally match a name in other code
14:20:36 <reactormonk> I wanna have two different ways you can derive a typeclass - will deriving via help me there?
14:20:40 <geekosaur> (there afe ways to get and use such names, butif you wnt to generate a new namer, it'd be bad for it to accidentally match one that's in use already)
14:21:06 <dukedave> geekosaur: ah I see! So like, no accidental monkey patching. I can see why that'd be an advantage, thanks.
14:22:58 <monoidal> reactormonk: You can define a "not equal" type family Equal a a = True; Equal a b = False and then Equal a b ~ False is a constraint
14:23:29 <monoidal> I'm not sure if it's really useful though.
14:24:38 <mniip> IfEq (a :: k) (b :: k) (p :: l) (q :: l) :: l   sure is useful for generating counterexamples to untouchable type variables in pattern matches
14:39:08 <dmwit> AndreasK: No, but you can clone it yourself and point new-* at the directory you created that way.
14:40:21 <dmwit> reactormonk: Yes, DerivingVia should help there.
14:44:00 <tieTYT> is there a difference between “typeclass” and “class”?
14:44:14 <tieTYT> my book is saying, to create a typeclass, you type “class...”
14:44:28 <tieTYT> and I find it very confusing that they’re not saying, “To create a class, you type “class…””
14:44:49 <geekosaur> we don't have OOP typeclasses. "class" in haskell is a typeclass
14:45:06 <geekosaur> the difference is basically to warn people that it's not OOp and it's going to bite you if you try to pretend that it is
14:45:27 <tieTYT> when you’re speaking/writing, do you say typeclass or class for this?
14:46:19 <tieTYT> I’m more comfortable with a consistent overloaded term than two terms for one concept.  Is it wrong to call these “classes”?
14:46:40 <glguy> No, it's not wrong. The Report mostly refers to them as "classes"
14:46:52 <tieTYT> k, thanks
14:47:07 <mniip> when it's clear that the context is haskell the two terms are interchangeable
14:50:24 <__monty__> In the context of haskell class is short for typeclass but if you only learn one I'd recommend the latter.
14:50:35 <__monty__> Less potential for confusion that way.
15:00:20 <AndreasK> dmwit: Thanks, guess I could script that into a one liner if it becommes a common thing
15:02:52 <tieTYT> when you do this `instance (Eq m) => Eq (Maybe m) where`, are you saying you’re not allowed to create a Maybe unless the m is an Eq type?  Or does it just mean that IF the m is an Eq type, here’s how the Eq is defined on the Maybe?
15:03:10 <glguy> Your first statement
15:03:16 <tieTYT> interesting
15:04:12 <glguy> Oh, you're not restricting Maybe, you're just saying that if you ever try to use the Eq instance for Maybe m, then you'll incur an additional constraint of  Eq m
15:04:41 <glguy> That's the say you can still have values of type: Maybe (IO ()), you just can't compare those values with ==
15:05:54 <tieTYT> ok I think that’s my second statement then
15:06:34 <glguy> It's not the second statement because the implication is the wrong way around, Maybe m is always an instance of Eq, but using that instance incurs the constraint
15:06:54 <glguy> so you can't make a second instance with a different (or no) Eq m constraint
15:06:59 <glguy> the one true instance has been declared
15:07:16 <tieTYT> is Maybe defined that way (is there a way to check Maybe in ghci?)
15:07:28 <glguy> You can type: :i Maybe   in GHCi to see its instances
15:07:52 <tieTYT> thank you, ok so that seems like yes it is
15:08:03 <tieTYT> but i created this: data TrafficLight = Red | Yellow | Green deriving (Show)
15:08:10 <tieTYT> and it let me say `Just Red`
15:08:20 <tieTYT> why is that allowed?  Red isn’t deriving Eq
15:08:44 <glguy> The Eq class is about the methods == and /=
15:09:20 <glguy> so if you try to use == or /=, then you'll have to check that the type you're using them with has an Eq instance
15:09:44 <glguy> the class is independent from any particular types like Maybe
15:09:54 <tieTYT> ok but I thought you said I shouldn’t be able to create a Maybe unless the m is Eq
15:10:11 <glguy> No, you can't use == at the Maybe m type unless m is also an instance of Eq
15:10:35 <glguy> :t (==)
15:10:36 <lambdabot> Eq a => a -> a -> Bool
15:11:04 <glguy> There are a bunch of different implementation of ==, which one you get is determined by the type you instantiate == with
15:11:07 <tieTYT> ok I’m trying to figure that out.  So what this allows me to do is use == on a Maybe without unpackin git first
15:11:57 <glguy> yeah
15:12:05 <glguy> > Just 'a' == Nothing
15:12:07 <lambdabot>  False
15:12:15 <tieTYT> it’s strange to me that the m doesn’t have to be Eq.
15:12:39 <glguy> the Eq class doesn't really have anything to do with Maybe, so the fact that there's an instance of that class doesn't affect what values of Maybe you can make
15:12:54 <glguy> instances are not like OOP with inheritence
15:13:26 <glguy> The Eq class is only about selecting appropriate implementations of ==
15:15:31 <glguy> Similarly if I write: example :: Num a => Maybe a; example = Just 42
15:15:49 <glguy> I'm not saying that you can only make Maybe a if a is an instance of Num in general
15:15:59 <glguy> I'm only saying you need that instance to use 'example'
15:16:21 <glguy> similarly with: instance Eq a => Eq (Maybe a)
15:16:38 <glguy> we're not saying you need an Eq a to use Maybe in general, only if you want to use this instance declaration
15:16:56 <glguy> and in the case of Eq, that instance declaration is providing an implementation of ==
15:21:00 <tieTYT> well what confuses me is if I :i Int, it says Instance Eq Int.  It’s my understanding that all Ints implement ==
15:21:39 <glguy> Sure, that instance has no further constraints
15:21:51 <tieTYT> I guess that is consistent.  instance Eq a => Eq (Maybe a)  means all Maybs implement Eq?
15:21:52 <glguy> If you try to use == at the type  Int -> Int -> Bool, it will always work
15:22:27 <glguy> Yeah, and it provides (==) :: Eq a => Maybe a -> Maybe a -> Bool
15:22:50 <tieTYT> so the left side of the => is a constraint that says, IF a is an Eq?
15:23:21 <iqubic> tieTYT: Yes.
15:23:44 <Wizek> Has anyone ran into this kind of ghc panic before? https://gist.github.com/Wizek/203dc2accc9a199da6606dfacbf48dfa
15:23:46 <tieTYT> ok.  That’s a little confusing to me because in functions if you have Eq a => … that says the function HAS TO take Eq
15:23:57 <arkeet> hmm, someone else try compiling this with ghc 8.4.x https://bpaste.net/show/ff725c6d561b
15:24:24 <glguy> tieTYT: IF really isn't the right word
15:24:26 <arkeet> for me it fails with no output (except the "Compiling Main ..." message)
15:24:33 <arkeet> but works fine on 8.2
15:24:48 <glguy> It's just that the constraints go on the left side of the =>
15:24:58 <iqubic> instance Eq a => Eq (Maybe a) states that you can have an instance of Eq (Maybe a) if, and only if there is an instance of Eq a
15:25:10 <arkeet> well, works as in gives a type error about the hole
15:26:32 <arkeet> what's more weird is it works if I change Eq to, say, Num
15:28:20 <glguy> tieTYT: this => all works the same way
15:29:10 <monoidal> Wizek: there's https://ghc.haskell.org/trac/ghc/ticket/14053, try ghc-pkg check
15:32:41 <Wizek> monoidal: thanks, reading
15:35:20 <nowhere_man> for the fun of it, I wrote a doubly-linked list, and I'm wondering about the functions to navigate them
15:35:52 <nowhere_man> is there a practical difference between defining `left Nil = undefined` and not defining it?
15:36:25 <nowhere_man> (with `left (Node _ l _) = l`)
15:36:31 <glguy> Practically you get a warning when you don't define it and you don't when you implement it as undefined
15:36:49 <glguy> Instead you should have it return a Maybe (List a)
15:37:58 <nowhere_man> ha…
15:38:44 <nowhere_man> but that's not the option taken by head/tail
15:39:11 <glguy> correct
15:39:16 <tieTYT> iqubic: gotcha
15:39:36 <arkeet> arguably head/tail are wrong.
15:39:39 * hackage slick 0.1.0.0 -   http://hackage.haskell.org/package/slick-0.1.0.0 (ChrisPenner)
15:41:08 <nowhere_man> arkeet: don't they just rely on exhaustive pattern matching? that doesn't seem wrong
15:42:48 <arkeet> there's no way in pure code to recover from a pattern match failure
15:43:40 <hpc> @src head
15:43:40 <lambdabot> head (x:_) = x
15:43:40 <lambdabot> head []    = error "Prelude.head: empty list"
15:45:08 <arkeet> (or from error)
15:46:07 <nowhere_man> I see. Couldn't `head []` not be defined so that the compiler would warn us we didn't prove we're working on a non-empty list?
15:46:36 <hpc> oho!
15:46:50 <glguy> nowhere_man: The way you prove what kind of value you have is by the type of the value
15:46:58 <hpc> ^
15:47:05 <glguy> If you want a type of non-empty lists you'd use a different type than [a]
15:47:14 <glguy> like: Data.List.NonEmpty.NonEmpty
15:47:21 <hpc> this is how automated theorem provers work, btw
15:51:37 * hackage ztar 0.1.3 - Creating and extracting arbitrary archives  http://hackage.haskell.org/package/ztar-0.1.3 (brandonchinn178)
15:52:11 <nowhere_man> glguy: cool, didn't know NonEmpty existed
15:52:29 <hpc> you can make your own NonEmpty with (a, [a]) :D
15:52:32 <glguy> and then ReallyNonEmpty when there are at least 2 elements...
15:53:34 <arkeet> and ReallyReallyNonEmpty when there are infinitely many...
15:58:06 <iqubic> glguy: "ReallyNonEmpty a" is isomorphic to "nonEmpty (nonEmpty a)"
15:58:45 <arkeet> how so?
15:59:20 <arkeet> I can think of a NonEmpty (NonEmpty a) with only one a
15:59:37 <iqubic> Oh, so can I.
15:59:40 <iqubic> Darn it.
15:59:53 <iqubic> I'm wrong.
16:00:39 <iqubic> "ReallyNonEmpty a" is isomorphic to "nonEmpty ((a, nonEmpty a))"
16:00:45 <iqubic> There.
16:00:53 <iqubic> Now you need at least 2 elements.
16:01:50 <iqubic> even simpler is: (a, nonEmpty a)
16:02:28 <iqubic> nonEmpty ((a, nonEmpty a)) requires an even amount of a's to be present.
16:02:52 <arkeet> it doesn't, but it's still not isomorphic.
16:03:02 <iqubic> What??!?!
16:03:06 <iqubic> I give up now.
16:03:32 <iqubic> I have to go. Perhap I can figure this out later.
16:03:38 <infinisil> In Idris: `Vect (S k) a` :)
16:03:49 <arkeet> nonempty x ~ x + x^2 + x^3 + ...
16:03:54 <arkeet> (x, nonempty x) ~ x^2 + x^3 + x^4 + ...
16:04:01 <infinisil> Or `Vect (10 + k) a` for a vector with at least 10 elements
16:04:35 <arkeet> nonempty (x, nonempty x) ~ x^2 + x^3 + 2x^4 + ...
16:04:57 <iqubic> Where did that last thing come from?
16:05:13 <iqubic> Oh, right... I see now.
16:06:18 <arkeet> i.e. there are two different shapes of values of nonempty (x, nonempty x) with 4 elements
16:06:52 <arkeet> namely, [[*,*,*,*]] and [[*,*],[*,*]]
16:13:06 <arkeet> ahhhhhh.
16:13:55 <arkeet> the x^n term in nonempty (x, nonempty x) is the (n-1)th Fibonacci number (n >= 1)
16:25:00 <monoidal> arkeet: I think [Either x (x^2)] ~ Nonempty (x, Nonempty x)
16:25:32 <butterthebuddha> Can't seem to find a function of type ByteString -> Word64
16:25:48 <monoidal> or that should be Nonempty (Either x (x^2))
16:26:00 <glguy> butterthebuddha:  It's not enough to say the type, you also need to say what it should do
16:26:14 <hpc> unsafeCoerce :: ByteString -> Word64
16:26:16 <glguy> const 0 :: ByteString -> Word64
16:26:25 <monoidal> for [Either x (x^2)] the connection with fibonacci is clear
16:27:23 <butterthebuddha> Well I know that the ByteString is <= 8 bytes, I just want to read it into a Word64
16:28:58 <arkeet> monoidal: well, you get exactly the fibonacci series with (x, [Either x (x^2)])
16:29:22 <monoidal> ah yes
16:32:45 <fishythefish> messing with formal power series: nonempty x ~ x / (1 - x), (x, nonempty x) ~ x^2 / (1 - x), nonempty (x, nonempty x) ~ (x^2 / (1 - x)) / (1 - x^2 / (1 - x)) = (x^2 / (1 - x)) / ((1 - x - x^2) / (1 - x)) = x^2 / (1 - x - x^2), and it's easy to show that 1 / (1 - z - z^2) is the generating function for fibonacci
16:33:11 <arkeet> yep
16:33:46 <arkeet> (well I prefer F_0 = 0, so z/(1-z-z^2))
16:49:14 <arkeet> :r
16:49:16 <arkeet> oops
16:56:03 <Brot_> Hello
16:57:37 <Brot_> I'm a newbie in Haskell, and I'm having trouble diagnosing the issue in a function that I have written.
16:57:42 <Brot_> Anyone available to help?
16:58:16 <fishythefish> Brot_: sure, but most of us won't say anything until a question is asked :P
16:58:21 <fishythefish> provide a paste and ask away
16:58:24 <Brot_> Also first time using IRC for this purpose, so I don't know what is the correct protocol.
16:58:30 <Brot_> Thanks, one second, I will.
16:59:02 <fishythefish> (the usual advice is something like "don't ask to ask, just ask")
17:01:31 <Brot_> Sorry, my IRC client crashed (hexchat).
17:01:34 <Brot_> I hope you're still here.
17:01:39 <fishythefish> yup
17:01:40 <Brot_> Here is the snippet of code in question: https://ghostbin.com/paste/zrrxs
17:02:05 <glguy> Brot_: and if you have questions about error messages you should include those in the paste
17:02:13 <fishythefish> okay, great. what's the issue you're trying to diagnose?
17:02:15 <Brot_> ok, one second then.
17:02:17 <glguy> but the . in this line is wrong: perms (x:xs)= flatten . map (interleave x) (perms xs)
17:02:21 <Brot_> well, it doesn't load in ghci.
17:02:31 <Brot_> yeah, the problem is with the flatten
17:02:40 <Brot_> or i guess, could be in the function composition there.
17:02:57 <glguy> function composition returns a new function, but you don't need a function! you need a list
17:03:19 <glguy> (flatten . ((map (interleave x)) (perms xs)))
17:04:06 <glguy> or to simplify that: f . g x    is     f . (g x)
17:05:00 <Brot_> Oh! So function composition doesn't work over multiple arguments?
17:05:21 <glguy> :t (.)
17:05:21 <Brot_> So if g takes two args, then the correct way to do it is (f . g) x y, rather than f . g x y?
17:05:22 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:05:39 <glguy> If g takes two arguments you write:  f (g x y)
17:06:06 <Brot_> Oh, okay. Thanks a lot, that's very helpful.
17:06:08 <fishythefish> there's a subtler discussion to be had here - all functions in haskell take only one argument
17:06:20 <Brot_> yeah true, because of currying.
17:06:39 <Brot_> But in my case, I was trying to "flatten" a function, which is my error.
17:06:58 <Brot_> Thanks a lot glguy.
17:07:07 <fishythefish> well, you weren't applying flatten to anything
17:07:40 <fishythefish> > concat [[1, 2], [3, 4]] -- side note
17:07:42 <lambdabot>  [1,2,3,4]
17:08:10 <glguy> also your flatten isn't the same as concat
17:08:23 <glguy> > let flatten = foldl (++) [] in flatten  [ [1,2] , [3,4] ]
17:08:25 <lambdabot>  [1,2,3,4]
17:08:38 <fishythefish> er
17:08:40 <Brot_> Wait, I didn't know that concat was a standard function... That would have saved me the trouble.
17:08:57 <Brot_> So, according to lambdabot, my function is okay, no?
17:09:12 <glguy> I guess I'm wrong, but your implementation isn't the same as concat's
17:09:27 <fishythefish> the implementation used to be `concat = foldr (++) []`
17:09:50 <Brot_> :info concat
17:09:58 <Brot_> >:info concat
17:10:07 <fishythefish> @src concat
17:10:07 <Brot_> lambdabot doesn't do info?
17:10:07 <lambdabot> concat = foldr (++) []
17:10:09 <fishythefish> (this is kind of a lie)
17:10:12 <Brot_> oh ty.
17:10:14 <fishythefish> now it's in foldable
17:10:41 <fishythefish> there's also concatMap, while we're here
17:10:49 <Brot_> @src concatMap
17:10:49 <lambdabot> concatMap f = foldr ((++) . f) []
17:11:01 <Brot_> That's perfect for me, thanks fishy :)
17:11:11 <glguy> Brot_: writing with foldl makes a concat that is 1) slow 2) doesn't stream / support infinite lists
17:11:12 <Brot_> makes the function definition a concise one liner.
17:11:47 <Brot_> I'm not clear on the performance differential between foldr and foldl, I can only think about it from an abstract mathematical point of view.
17:11:51 <fishythefish> we're this close to just talking about nondeterminism and the list monad :P
17:12:20 <Brot_> can you give me a quick synopsis of it, or link me to some place that discusses it, glguy?
17:12:32 <fishythefish> https://wiki.haskell.org/Foldr_Foldl_Foldl%27
17:12:44 <Brot_> I mean, aside from the associativity of the operation in question (hence assume the operation is both left and right associative)
17:12:53 <Brot_> ty fish.
17:13:59 <fishythefish> the tl;dr is that foldr usually plays nicest, but if you need a left fold and are okay with the downsides, you almost always want foldl' instead of foldl
17:14:00 <glguy> foldl can't produce a result until the end of the input list is reached, and repeatedly appending to the end of a singlely linked list is slow as it requires you to walk to the end of every intermediate list
17:14:27 <Brot_> Hah. From my uninformed newbie perspective, I actually assumed that foldl would have those advantage cited in the haskell.org page (thought about it in terms of stacks too).
17:14:55 <Brot_> I was right about there being a difference, but completely wrong about the who has the advantage lol.
17:15:17 <Brot_> thanks for the information. I got all I needed.
17:15:24 <Brot_> you guys are helpful.
17:15:58 <fishythefish> #haskell is generally a good place to hang out and get help
17:16:14 <Brot_> Oh, one last thing I suppose. Is there a "@src" equivalent on GHCi?
17:16:36 <Brot_> To read the source definition without having to open the source code.
17:17:10 <fishythefish> well, @src is a lie - it isn't actually looking up the source, it's getting it from a fixed file containing some "definitions" (but not all)
17:17:39 <c_wraith> @src concat
17:17:39 <lambdabot> concat = foldr (++) []
17:18:09 <c_wraith> hmm, that wasn't one. I know some entries in the db have multiple alternatives
17:18:09 <Brot_> Oh, ok.
17:18:21 <c_wraith> which is definitely not what the libraries do.
17:18:21 <fishythefish> but afaik, no, ghci has no such utility
17:19:18 <fishythefish> typically you'll find the haddock docs for a value and view the source from there
17:19:27 <Brot_> Any convenient online utility I could use for that purpose then?
17:19:39 <fishythefish> https://hoogle.haskell.org/
17:19:45 <Brot_> Quick lookup of definition(s) a common Haskell function.
17:19:48 <Brot_> Thanks!
17:20:03 <Brot_> absolutely perfect
17:21:24 <marvin2> hoogle lets you search functions by type, see the examples there
17:21:58 <fishythefish> type search has issues, though, so there's still https://www.haskell.org/hoogle/
17:22:34 <Brot_> Type search is also great, because for example, just yesterday I was looking for a function that parses strings to Ints.
17:22:59 <Brot_> I assume looking up [Char]->Num won't have a lot of functions and I'll narrow it down quickly
17:23:26 <pally> :t Monad
17:23:27 <lambdabot> error: Data constructor not in scope: Monad
17:23:35 <pally> :t (>>=)
17:23:36 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:24:17 <fishythefish> Well, Num isn't a type, so you probably mean `Num a => String -> a` (note that [Char] is the same as String)
17:24:32 <fishythefish> but this is too broad
17:24:35 <marvin2> @hoogle Num a => String -> a
17:24:35 <lambdabot> Prelude negate :: Num a => a -> a
17:24:35 <lambdabot> Prelude abs :: Num a => a -> a
17:24:35 <lambdabot> Prelude signum :: Num a => a -> a
17:24:55 <pally> In a Monad tutorial, it is said that the above signature is equivalent to Monad m => (a -> m b) -> m a -> m b
17:25:05 <fishythefish> > read "123" :: Int -- Brot_
17:25:07 <lambdabot>  123
17:25:17 <fishythefish> :t read
17:25:18 <lambdabot> Read a => String -> a
17:25:19 <pally> can someone comment on that claim?
17:25:29 <fishythefish> :t flip (>>=) -- pally
17:25:30 <lambdabot> Monad m => (a -> m b) -> m a -> m b
17:25:37 <fishythefish> :t (=<<)
17:25:38 <lambdabot> Monad m => (a -> m b) -> m a -> m b
17:26:26 <Brot_> Yes that's what I meant fishy. Still not used to type classes and all, only have been doing haskell for 2-3 days.
17:26:38 <Brot_> It's really great though, fits perfectly with my mathematical thinking.
17:26:41 <fishythefish> yeah, they can take some getting used to, but they're a powerful concept
17:27:00 <pally> fishythefish, I said comment :p
17:27:02 <Brot_> The fact that type theory fits so naturally with category theory (as opposed to the orthodox set theory) ignited my interest.
17:27:09 <Brot_> And I wasn't disappointed.
17:27:11 <fishythefish> pally: yes, the `--` introduces a comment :P
17:27:52 <fishythefish> pally: but there really isn't much more to say - `flip` just interchanges the order of the arguments; the function does essentially the same thing
17:28:49 <fishythefish> the resulting function does essentially the same thing as the original*
17:31:59 <pally> fishythefish, order the the arguments doesn't matter in Haskell?  This would assume commutativity.
17:32:24 <fishythefish> pally: order of arguments to the same function does matter
17:32:51 <fishythefish> what I'm saying is if you have a function that looks like `f x y = doSomething x y` and another function that looks like `g y x = doSomething x y`, are `f` and `g` substantially different?
17:34:28 <fishythefish> in the particular example above, `x >>= f` is the same as `f =<< x`. (>>=) and (=<<) have different type signatures (of course), but essentially do the same thing - it's just that the arguments are flipped
17:34:35 <fishythefish> this is why the tutorial called the two signatures equivalent
17:35:58 <fishythefish> instead of making (>>=) the minimal complete definition for a Monad instance, we could equivalently require (=<<) instead and define (>>=) = flip (=<<)
17:36:46 <johnw_> or join!
17:38:20 <fishythefish> :t flip join -- this requires a different conversation
17:38:21 <lambdabot> b -> (b -> b -> c) -> c
17:39:35 <johnw_> flip join would only really work for intances defined by a function type
17:40:08 <dmwit> pally: Quick reminder: equality is not the only possible equivalence relation.
17:40:50 <fishythefish> johnw_: yeah, hence the resulting type - it uses the ((->) b) monad
17:44:58 * pally takes note
18:20:24 <infinisil> Hey, how would I use conduits stdin and make it such that each await gets exactly one line, without the \n's?
18:45:59 <infinisil> Well I got it working, but I'm surprised I can't find a method like that on hackage
18:46:32 <infinisil> This is how I did it: https://gist.github.com/Infinisil/4c7cba92adbc1708fd97780ccc48f00b
18:46:50 <infinisil> Needs a bit less String and more ByteString though, or something
18:57:37 * hackage hspec-need-env 0.1.0.0 - Read environment variables for hspec tests  http://hackage.haskell.org/package/hspec-need-env-0.1.0.0 (debugito)
19:24:07 * hackage winery 0.1.2 - Sustainable serialisation library  http://hackage.haskell.org/package/winery-0.1.2 (FumiakiKinoshita)
19:35:55 <pally> I read (somewhere) that Monads have the Applicative instance.
19:37:28 <pally> But the programmer still has to provide implementations for the required methods (namely, pure and <*>)  right?
19:38:19 <pally> so...
19:38:56 <pally> instance Monad (Blah) where
19:39:16 <pally>   return a = pure a
19:39:28 <pally>   (>>=) ...
19:40:12 <pally> I can't just start using 'pure', I would still have to make Blah an instance of Applicative, right?
19:40:49 <dukedave> In this example, is `Proxy` a 'real' type? Hoogle isn't coming up with much. https://markkarpov.com/tutorial/th.html#example-1-instance-generation
19:41:30 <dukedave> Ah, http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Proxy.html !
19:42:34 <glguy> https://hoogle.haskell.org/?hoogle=Proxy&scope=set%3Astackage
19:43:02 <Xnuk> @hoogle Proxy
19:43:03 <lambdabot> module Data.Proxy
19:43:03 <lambdabot> Data.Proxy data Proxy t
19:43:03 <lambdabot> Data.Proxy Proxy :: Proxy t
20:05:37 * hackage fcm-client 0.1.0.0 - Admin API for Firebase Cloud Messaging  http://hackage.haskell.org/package/fcm-client-0.1.0.0 (shersh)
20:11:55 <dukedave> glguy: Ooh `&scope=set%3Astackage` is new to me. Is there an option in Hoogle web UI hidden somewhere?
20:12:13 <dukedave> Xnuk: ah, I forgot about @hoogle, thanks!
20:16:02 <dukedave> I'm still working through https://markkarpov.com/tutorial/th.html#example-1-instance-generation and in the definition of `deriveCountableSimple` there's suddenly the splice operator `$(...)` *inside* a quotation block `[d| ... |]`. That seems to be different to the use of the splice preceding this section, where the `$(...)` only occurred in 'regular code'. Am I crazy?
20:16:56 <dukedave> ^ this might be fine, and FWIW the splice makes sense, I just feel like the tutorial skips over it being a new way to use splice; unless I'm missing something?
20:20:53 <glguy> dukedave: That's just the default scope
20:21:13 <glguy> dukedave: There's two different versions of hoogle, the one you used and the one I linked to
20:21:32 <glguy> dukedave: It's just a normal splice, it means the same thing
20:24:09 <koz_> If I need to parse binary, what should I use?
20:24:43 <glguy> attoparsec and binary are good
20:24:52 <koz_> glguy: I will investigate both.
20:24:56 <koz_> Thanks!
20:25:09 * fr33domlover waves at koz_
20:25:16 <koz_> Hi fr33domlover! Long time no see.
20:25:20 <dukedave> glguy: oh nice, thanks for the clarification on the two Hoogles
20:25:30 <koz_> Wait there are two Hoogles?
20:25:34 <koz_> Do you mean Hoogle and Hayoo?
20:25:58 <glguy> no
20:26:39 <koz_> Then I'm curious about this.
20:26:44 <koz_> I was only aware of the one Hoogle.
20:27:01 <fr33domlover> koz_, haskell.org/hoogle and hoogle.haskell.org
20:27:25 <fr33domlover> koz_, the latter is more recent, former is stable older
20:27:54 <koz_> fr33domlover: Thanks!
20:29:11 <dukedave> Lol, looking at footer I see 'stable' is last (c) in 2013, I think a lot of JS frameworks could learn from that definition of 'stable'
20:29:40 <dukedave> But... Would be nice to at least acknowledge haskell.org/hoogle  there
20:30:31 <dukedave> glguy: when you said 'the default scope', is that what I'd consider 'normal' Haskell code (i.e. everything I've seen up until now as I'm seeing TH for the first time)
20:31:17 <dukedave> (and then inside the `[d|.. |]` I'm in a difference scope)?
20:31:42 <glguy> dukedave: No, I mean that the "&scope=set%3Astackage" part was the default
20:32:23 <dukedave> glguy: oh, ha, glad I clarified. My fault for asking two questions at once
20:32:30 <glguy> $(...) turns an ExpQ into some Haskell code, and quotes [| .... |] turn Haskell code back into ExpQ
20:34:08 <dukedave> Okay, that makes sense. I think I'm trying to over think it.
20:36:17 <koz_> For this data type: https://www.stackage.org/haddock/lts-12.1/attoparsec-0.13.2.2/Data-Attoparsec-ByteString.html#t:IResult, what is the purpose of the 'r' type parameter?
20:36:51 <glguy> It's the result of a successful parse
20:37:31 <koz_> Ah.
21:13:30 <pally> :info Monad
21:13:48 <pally> :t (>>=)
21:13:49 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:15:32 <pally> When I compare signature from reported by `:t (>>=)` to the one reported by `:info Monad`.  there is difference
21:16:13 <pally> The one reported by `:info Monad` suggests that `m` is an instance of Applicative
21:16:17 <pally> which makes more sense to me.
21:16:30 <glguy> You're looking at two different things
21:16:31 <koz_> How would I turn Text into a ByteString?
21:17:09 <glguy> pally: The declaration for the Monad class is listing Applicative as a "superclass"
21:17:27 <glguy> but when you're looking at the type of (>>=) in isolation it just shows the type of that method and its constraints
21:17:40 <glguy> It doesn't matter at that point that Applicative is a superclass of Monad
21:19:54 <dmwit> koz_: Data.Text.Encoding.encodeUtf8, for example
21:20:02 <dmwit> koz_: Or, if you need a different encoding, you should say which one.
21:20:27 <koz_> dmwit: UTF-8 is indeed the one I see.
21:20:31 <koz_> s/see/seek/
21:20:33 <dmwit> text or text-icu should have most of the popular ones. The encoding package has less popular ones.
21:20:33 <koz_> Thanks!
21:23:23 <dmwit> :t undefined :: (Applicative m, Monad m) => m a -- the simplified inferred type might be instructive, pally
21:23:24 <lambdabot> Monad m => m a
21:23:32 <koz_> Does encodeUtf8 produce lazy ByteStrings?
21:23:51 <koz_> This GHC error suggests one of Zlib.compress or that does, but it's a bit hard to tell which.
21:24:14 <dmwit> You can learn this from the haddocks.
21:24:42 <dmwit> Click or hover over the ByteString in the type of encodeUtf8 to learn which of the two modules that type is coming from.
21:24:58 <dmwit> (You can also ask ghci, of course.)
21:25:00 <koz_> Data.ByteString according to the haddock I'm reading.
21:25:18 <koz_> Wait, never mind.
21:25:23 <koz_> Should have checked which version I'm looking at, derp.
21:26:50 <begriffs> How do people inspect haskell expression types in vim nowadays? Is ghc-mod working again, or is there a preferred substitute?
21:27:04 <koz_> begriffs: Which version of GHC?
21:27:21 <koz_> dmwit: According to this: https://www.stackage.org/haddock/lts-11.17/text-1.2.3.0/Data-Text-Encoding.html#v:encodeUtf8 , it's Data.ByteString.
21:27:24 <koz_> No Lazy where I can see.
21:27:49 <nowhere_man> when there is no type ambiguity, I prefer not to explicitly type my functions, so that if I refactor them, I don't have to manually retype them;
21:27:51 <begriffs> koz_: I'd prefer to use the latest version on principle, but if the tooling all works on a previous version I could pin my environment to that.
21:27:54 <nowhere_man> is there a drawback?
21:28:31 <koz_> begriffs: I typically use Neomake + hdevtools + hlint.
21:28:37 <koz_> But that's Neovim, so YMMV.
21:28:55 <koz_> Unfortunately, both of those fail to build on lts-12.*, so I'm stuck at 11.17.
21:29:00 <koz_> I dunno if that helps you any.
21:29:51 <koz_> dmwit: OK, it seems Zlib.compress wants a lazy ByteString. How would I 'lazify' it?
21:30:40 <pally> class Applicative m => Monad (m :: * -> *) where ...
21:31:19 <pally> so you are saying Applicative is a superclass of Monad?
21:31:41 <pally> I read that as m is an instance of Applicative
21:33:26 <pally> E.g. `Maybe` is a suitable "m"
21:33:36 <begriffs> koz_: thanks, I'll look into that.
21:35:39 <pally> 'The declaration for the Monad class is listing Applicative as a "superclass"' , since you had superclass in double quotes, can I take it that you mean it in a loose sense?
21:36:03 <glguy> No, I mean that's the particular term for it
21:37:00 <pally> glguy, okay, I will take note. thanks.
21:44:55 <dmwit> koz_: fromStrict
21:46:34 <dmwit> nowhere_man: Why do my top-level functions need signatures? https://stackoverflow.com/q/19626801/791604
21:52:22 <revskill> The length function for [a] is not total, because if the list is infinite, no result is returned.
21:52:52 <revskill> so how to write function on list which needs access length ?
21:53:43 <glguy> Your choices are 1) don't use an infinite list as the input 2) don't use length
21:54:54 <revskill> OK, so how to detect a list is infinite ?
21:55:08 <glguy> nope :(
21:55:12 <revskill> one of solution is use drop i think
22:00:52 <cocreature> drop doesn’t let you detect if a list is infinite
22:02:27 <revskill> cocreature: i mean, drop is a function which could apply to both finite and infinite list
22:02:59 <revskill> so we could compose with other function to work with index parameter
22:24:00 <frobnicator> revskill: it is total I guess because there are no cases undefined
22:24:14 <frobnicator> it will never terminate for an infinite list but I don't think that has something to do with totality
22:24:52 <revskill> length is total on only FINITE LIST
22:25:07 <revskill> something like , List a b , type
22:25:32 <revskill> [a] is a stream, length has no meaning on stream
22:26:45 <frobnicator> Well, I'm no mathematician but I think totality is when there is an undefined output for an input and the output of length is well defined for all lists
22:26:56 <frobnicator> only for some it will not terminate
22:28:53 <revskill> frobnicator: i think, totality doesn't mean undefined output or not
22:29:06 <revskill> totality means defined for all inputs of the right type
22:29:39 <dminuoso> frobnicator: A total function is one that is defined for all possible inputs.
22:29:50 <frobnicator> I was of the understanding that it meant that for every input an output is defined
22:29:57 <dminuoso> frobnicator: Correct.
22:30:16 <frobnicator> and that is the case, but only some outputs take an inifinite time, it is not like hd where hd [] just isn't defined
22:30:26 <revskill> length [1..] is well-typed, but non-sense
22:30:36 <dminuoso> revskill: It is not non-sense.
22:30:40 <dminuoso> It produces bottom.
22:31:27 <frobnicator> hmm, the list of partial functions of the haskell wiki says length is partial:)
22:33:39 <dminuoso> In usual haskell terms a total function is one that cannot produce bottom, I guess?
22:34:18 <geekosaur> a total function is one which never produces bottom when all its parameters are non-bottom
22:34:39 <frobnicator> I wasn't aware that non-termination is considered bottom. Therefore length is indeed partial.
22:34:45 <geekosaur> lists being defined recursively, this is a little tricky
22:34:55 <dminuoso> geekosaur: Ah. That sounds more correct :)
22:35:00 <geekosaur> but "non-bottom" there is with respect to WHNF
22:36:00 <iqubic`> What are we talking about here?
22:36:07 <dminuoso> frobnicator: That little fact is makes it impossible to detect bottom by the way, as it would need to have a general solution to the halting problem. =)
22:36:42 <|Leary> Most models of computation have no real notion of "case", so non-termination is really the standard mode of partiality.
22:37:02 <dminuoso> |Leary: By "case" do you mean the haskell keyword?
22:37:13 <koz_> I too am curious what you mean by "case" here.
22:37:17 <frobnicator> dminuoso: yes, that's a pity:) and the beauty
22:37:39 <|Leary> Yes, that kind of construct. I think that's what frobnicator is referring to by undefined.
22:37:52 <|Leary> Something like an unmatched case
22:39:27 <|Leary> Well, I guess you could describe turing machines in terms of cases, but an equivalently powerful description should be able to rule out unmatched cases ... though I may actually be wrong about that.
22:41:18 <|Leary> It's been a few years since I wrote one of the bastards.
22:46:16 <nshepperd> i think in haskell one would say a total function is one that always produces a total output when the input is total
22:46:31 <geekosaur> that's more or less what I said, yes
22:47:36 <nshepperd> total values being something that doesn't contain bottom anywhere, basically
22:47:46 <geekosaur> that's inexact, though
22:48:01 <geekosaur> > length [undefined, error "foo", let x = x in x]
22:48:03 <lambdabot>  3
22:48:14 <iqubic> It's a thunk.
22:48:30 <iqubic> :t [undefined, error "foo", let x = x in x]
22:48:31 <lambdabot> [a]
22:48:34 <mniip> well using a sufficiently advanced number type you can take a length of an infinite list
22:48:58 <geekosaur> iqubic, it gets defaulted to a ~ () by ExtendedDefaultRules
22:49:28 <nshepperd> const [undefined] is non-total even though the output isn't bottom
22:49:32 <iqubic> geekosaur: So it's a case of the Dreaded Monomorphism Restriction?
22:50:25 <frobnicator> mniip: even if your number type contains inf, you can not know whether a list is infinite without going through every item
22:50:31 <frobnicator> :t [undefined]
22:50:33 <lambdabot> [a]
22:50:52 <mniip> @let data N = S N | Z deriving Show
22:50:53 <lambdabot>  Defined.
22:51:06 <mniip> @let len [] = Z; len (_:xs) = S (length xs)
22:51:07 <lambdabot>  .L.hs:165:19: error:
22:51:07 <lambdabot>      • Couldn't match expected type ‘N’ with actual type ‘Int’
22:51:07 <lambdabot>      • In the first argument of ‘S’, namely ‘(length xs)’
22:51:10 <mniip> @let len [] = Z; len (_:xs) = S (len xs)
22:51:11 <lambdabot>  Defined.
22:51:43 <mniip> can't know if this number is infinite without going through every item
22:52:01 <iqubic> Right.
22:52:12 <dminuoso> Note to self... {-# LANGAUGE DeriveGeneric #-} is silently accepted and does *not* what you think..
22:52:19 <dminuoso> Is there some GHC option to make it choke on this?
22:52:48 <mniip> dminuoso, no, you have to spell lengwhich correctly
22:53:53 <Maxdamantus> I'd say "total values" should mean values that can be evaluated to something without thunks where all functions are total.
22:54:22 * Maxdamantus can't remember the names of the normal forms.
22:55:02 <Maxdamantus> (that excludes infinite lists, since you can't evaluate an infinite list until it has no thunks)
22:55:03 <mniip> does NF imply the resulting tree has to be finite
22:55:21 <Maxdamantus> The one I'm talking about does.
22:55:22 <mniip> going by the deepseq package, it does
22:55:23 <geekosaur> dminuoso, -Wunrecognized-pragmas (and -Werror)
22:55:36 <frobnicator> Maxdamantus: higher order functions, twice is total I guess
22:55:40 <Maxdamantus> since you can't get an infinite tree (without thunks)
22:55:48 <geekosaur> not sure if recent ghc lets you make that warning an error (-Werror=... is at least intended at some point)
22:56:06 <Maxdamantus> fairfieldt: HOF should be covered by my definition.
22:56:17 <nshepperd> I think it's ok for infinite lists to be 'total'
22:56:21 <nshepperd> but i'm not sure
22:57:04 <nshepperd> > len [1..] >= S (S (S Z))
22:57:06 <lambdabot>  True
22:57:20 <nshepperd> confirmed, infinity is greater than three
22:58:03 <iqubic> How did you define (>=)?
22:58:38 <mniip> it could be derived but I messed up the order of S and Z in the declaration
22:58:49 <iqubic> > len [1..]
22:58:51 <lambdabot>  S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S...
22:59:01 <iqubic> How does haskell figure that out?
22:59:50 <iqubic> Wait, I see. That's just haskell being lazy.
23:02:32 <nshepperd> iqubic: recursively. S a >= S b  =  a >= b
23:02:43 <nshepperd> then two bases cases with zero on the left or right
23:03:22 <Maxdamantus> nshepperd: it's not if you want "total function" to mean "function that produces a total output for any total input"
23:03:30 <iqubic> nshepperd: I see.
23:03:34 <Maxdamantus> nshepperd: as demonstrated by `length`
23:03:37 <mniip> but then >>= is not total
23:03:40 <mniip> >-*
23:03:40 <nshepperd> Maxdamantus: why not?
23:03:44 <mniip> I mean >=
23:04:01 <iqubic> mniip: Why do you say that?
23:04:02 <mniip> > len [1..] >= len [1..]
23:04:09 <lambdabot>  mueval-core: Time limit exceeded
23:04:23 <iqubic> Right, that's an infinite computation?
23:04:58 <Maxdamantus> nshepperd: because `length` doesn't produce an output for infinite lists.
23:05:13 <Maxdamantus> so either infinite lengths are not total, or length is not total.
23:05:18 <nshepperd> Maxdamantus: i mean, then length is not 'total', that seems ok depending on your usage
23:05:38 <Maxdamantus> Okay, so you need another meaning of "total function".
23:06:01 <Maxdamantus> infinite lists*
23:06:07 <nshepperd> "very total function"
23:07:26 <dminuoso> I'd like to think that all functions in Haskell are total
23:07:38 <dminuoso> Oops.
23:07:40 <geekosaur> > head []
23:07:42 <lambdabot>  *Exception: Prelude.head: empty list
23:07:46 <geekosaur> counterexample
23:08:10 <Maxdamantus> > let f = fix id in f 4
23:08:12 <lambdabot>  *Exception: <<loop>>
23:08:14 <Maxdamantus> another counterexample
23:08:33 <Maxdamantus> (`fix` is not total, neither is `fix id`)
23:08:47 <iqubic> But that should be total. Of course the answer should be 4
23:08:56 <dminuoso> geekosaur: interesting I cant seem to make it an error. and with just a warning it wont actually show because it errors out on trying to use generics later first.
23:09:00 <Maxdamantus> Well, at least `fix id` should be considered non-total, but using the definition above, it's non-total because `fix` is non-total.
23:09:58 <dminuoso> So I guess it's like mniip said: Start typing correctly. =)
23:14:36 <nshepperd_> Totality actually seems pretty hard
23:14:57 <Maxdamantus> Do you mean defining it, or detecting it?
23:15:49 <nshepperd> defining it
23:16:48 <Maxdamantus> Dunno. I think my definition should be simple enough.
23:17:14 <Maxdamantus> I think you should be able to get rid of the special case for "structures" if you systematically turn the structures into some Church encoding.
23:20:48 <Maxdamantus> as a side note: I dislike the notion of "containing bottom", as used in an earlier definition.
23:21:22 <Maxdamantus> There is no bottom value, so something can't "contain bottom"
23:22:06 <johnw_> or, there is a bottom value, you just can't ever know what it is :)
23:22:37 <Maxdamantus> If there is a bottom value, prove it.
23:22:53 <johnw_> it's defined to not be provable
23:22:58 <nshepperd> what does [1, 2, 3, ⊥] do, if not contain bottom?
23:23:26 <dminuoso> nshepperd: Formally the standard does not clearly define a bottom value to exist. It ties the notion of bottom to expressions.
23:23:28 <Maxdamantus> nshepperd: when you say "⊥" there, you're just denoting a thunk that doesn't evaluate.
23:23:52 <Maxdamantus> (ie, trying to evaluate that thunk will never produce a value; it either goes into a loop or crashes)
23:24:10 <nshepperd> well, i'm really talking about... domain theory? is that what it's called
23:24:21 <quchen> dminuoso: To be fair, the Report isn’t very formal at all.
23:24:21 <johnw_> I remember asking the same question about "divided by zero" in high school
23:24:28 <Maxdamantus> I think some descriptions of Haskell's semantics use "bottom" in a funny way.
23:24:48 <Maxdamantus> afaict, the only real sensible meaning of "bottom" is in denoting a type that has no values.
23:24:57 <quchen> No, that would be the empty type.
23:25:05 <Maxdamantus> also known as a "bottom" type.
23:25:07 <nshepperd> I don't see the problem with calling ⊥ a value
23:25:30 <Maxdamantus> I don't think a "bottom value" is widely used in non-Haskell contexts.
23:25:32 <quchen> I don’t think calling the empty type »bottom type« is a very good idea.
23:25:44 <butterthebuddha> Is Wadler's "The Essence of Functional Programming" the first paper in which monads appeared in the context of Haskell?
23:26:04 <quchen> The »bottom type« would be more like the type of an uninhabited kind.
23:26:47 <Maxdamantus> quchen: I'm pretty sure those terms are pretty much used synonymously.
23:27:01 <Maxdamantus> quchen: except in some descriptions of Haskell, where people often use mathematical terms flimsily.
23:27:10 <quchen> I’ve never heard it in mathematics either.
23:27:14 <nshepperd> saying 'there is no bottom value' doesn't seem like it really means anything
23:27:33 <quchen> I have heard »empty type« many times. Or more briefly, simply »0«.
23:27:38 <Maxdamantus> It's the same as saying "there is no value that is of an empty type"
23:27:54 <quchen> That depends on your logical system. In Haskell there is.
23:28:03 <nshepperd> that doesn't even seem related
23:28:12 <nshepperd> bottom doesn't have anything to do with empty types
23:28:42 <Maxdamantus> Feel free to rewrite the Wikipedia article on "Bottom type".
23:29:32 <frobnicator> butterthebuddha: nope
23:29:42 <quchen> Now you’re trolling. Don’t do that.
23:29:52 <johnw> I find it interesting how ill defined 'undefined' appears to be
23:29:56 <nshepperd> just because there's a wikipedia page containing the word 'bottom' doesn't mean the things are related
23:30:00 <frobnicator> [1]P. Wadler, “Comprehending monads,” in Proceedings of the 1990 ACM conference on LISP and functional programming, 1990, pp. 61–78.
23:30:09 <frobnicator> is the oldest one I have
23:30:13 <johnw> it's almost onomatopoeic
23:30:32 <quchen> BRB, dictionary. :-D
23:30:36 <dminuoso> nshepperd: In all fairness the term is borroed from TaPL
23:30:47 <Maxdamantus> Feel free to tell Benjamin Pierce that he is using "bottom type" erroneously in https://www.asc.ohio-state.edu/pollard.4/type/books/pierce-tpl.pdf
23:31:07 <nan`> hello can i make a function that takes a type and returns a string, or can i make a typeclass function that takes no arguments?
23:31:13 <butterthebuddha> frobnicator: Just found that paper after a GScholar search
23:31:25 <dminuoso> nan`: Yes, but thats not really called a function, its just a polymorphic value
23:31:32 <frobnicator> butterthebuddha: if there is an older one, he probably referenced it in that one
23:31:37 <butterthebuddha> nan`: "typeclass function"?
23:31:37 <dminuoso> nan`: You will need to enable TypeApplications to make it useful, and AllowAmbiguousTypes to define it
23:32:01 <nan`> dminuoso: how do i use TypeApplications
23:32:05 <butterthebuddha> frobnicator: I'll take a look, ty
23:32:26 <nan`> butterthebuddha: i meant a function that goes in a typeclass, how do you say that?
23:32:39 <dminuoso> % :set -XAllowAmbiguousTypes
23:32:40 <yahb> dminuoso:
23:32:40 <nshepperd> in any case, 'fix id' might not be a 'real' 'value' but i still want to know how it works
23:32:43 <Maxdamantus> eg, in statements like “The first thing to notice is that Bot is empty—there are no closed values of type Bot“
23:32:44 <dminuoso> % :set -XTypeApplications
23:32:45 <yahb> dminuoso:
23:32:49 <nshepperd> and what happens when you put it in a list etc
23:32:51 <dminuoso> % class Bitsize a where sizeOf :: Int
23:32:52 <yahb> dminuoso:
23:33:07 <dminuoso> % instance Bitsize Int32 where sizeOf 32
23:33:07 <yahb> dminuoso: ; <interactive>:35:39: error: parse error (possibly incorrect indentation or mismatched brackets)
23:33:11 <dminuoso> % instance Bitsize Int32 where sizeOf = 32
23:33:12 <yahb> dminuoso:
23:33:20 <butterthebuddha> nan`: That's a fine way of saying it I guess'
23:33:21 <dminuoso> % sizeOf @Int32
23:33:21 <yahb> dminuoso: 32
23:33:28 <dminuoso> nan`: ^- like that
23:34:00 <nan`> dminuoso: but how do i use it as a value? i mean how do i choose the type for the polymorphic value
23:34:12 <dminuoso> nan`: With type applications. Do you see the @Int32 there?
23:34:55 <johnw> I find myself over-using TypeApplications now
23:35:01 <dminuoso> nan`: In a way you can think of a polymorphic value as a value that is abstracted over a type (i.e. its a value that requires an additional type argument). Usually GHC figures out and passes that type for you implicitly. But TypeApplications lets you do this manually
23:35:03 <johnw> it's a crutch
23:35:16 <johnw> (for me, that is)
23:35:17 <quchen> Maxdamantus: You cited the chapter about subtyping… that’s a wholly different bottom. It’s the subtype of every type, and he’s discussing it in that context only. (Likewise, Top is the supertype of every type in that chapter, hence its title.)
23:35:23 <mniip> johnw, we just need TypeAbstraction and then it's all good
23:35:36 <nan`> oh with the little ampersand
23:35:50 <johnw> it's too easy to make bad typeclasses, turn on AllowAmbiguousTypes, and then push through problems with TypeApplications
23:35:51 <dminuoso> nan`: at-sign @, not ampersend &
23:36:02 <johnw> thinking, "I'll fix this real soon now"
23:36:08 <nan`> yes at-sign @
23:36:21 <nshepperd> speaking of which, I figured out that the tensor for the monoidal category Hask is in fact... /strict/ pairs
23:36:34 <Maxdamantus> quchen: so where do you think "bottom" in other contexts comes from?
23:36:36 <nan`> hm, a new syntax!
23:36:37 <revskill> I create a safe list (!!) here: https://gist.github.com/revskill10/898835ba09c21782d02f28d5fcea28f6
23:36:44 <dminuoso> nan`: Have you ever seen a type variable (lowercase) in a type signature?
23:36:44 <nshepperd> they need to be strict to make the number of bottoms line up
23:36:57 <dminuoso> :t fmap
23:36:57 <nshepperd> (but the unit is still (), so that's nice)
23:36:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:37:09 <revskill> now you can access (!!!!) safely for both finite and infinite list
23:37:50 <dminuoso> nan`: you can think of `fmap` as taking 3 type arguments (one for `f`, one for `a` and one for `b`) and 2 value arguments. If you enable TypeApplications you can manually specify what `f`, `a` and `b` are supposed to be.
23:38:03 <dminuoso> :t fmap @[]
23:38:05 <lambdabot> error:
23:38:05 <lambdabot>     Pattern syntax in expression context: fmap@[]
23:38:05 <lambdabot>     Did you mean to enable TypeApplications?
23:38:10 <dminuoso> % :t fmap @[]
23:38:11 <yahb> dminuoso: (a -> b) -> [a] -> [b]
23:38:19 <dminuoso> % :t fmap @[] @Int
23:38:20 <yahb> dminuoso: (Int -> b) -> [Int] -> [b]
23:38:29 <nan`> aw maw
23:38:34 <cocreature> revskill: next step: switch to a data structure actually suited for getting elements by index :)
23:38:43 <Maxdamantus> quchen: I'm happy not to refer to something in Haskell as being of a "bottom type". The main issue I have is with there being some "bottom value".
23:39:26 <dminuoso> Maxdamantus: I've seen some articles talking about denotational semantics in Haskell, defining bottom to be the completely undefined value..
23:39:32 <Maxdamantus> though in many type theoretical contexts, "subtype" does not seem to mean there is some formal "subtyping" relation.
23:39:41 <dminuoso> Not that I would quote them, just saying..
23:39:47 <nan`> dminuoso: i like this type applications thank you
23:39:48 <Maxdamantus> and in those contexts, bottom/empty is a subtype of every type.
23:40:13 <revskill> [1..] !!!! 0 => Right 1
23:40:15 <revskill> sweet
23:40:17 <nshepperd> 'bottom value' comes from it being the least defined value of the type
23:40:21 <Maxdamantus> dminuoso: yes, that's what I'm referring to as something that I don't like.
23:40:27 <nshepperd> as in the bottom of a lattice
23:40:27 <nan`> dminuoso: it is for a postgresql-simple helper i am defining a table name for a type
23:40:51 <nshepperd> or something like that
23:41:01 <quchen> Maxdamantus: Bottom is the least element in the poset of the definedness of terms. ⊥ is less defined than (Left ⊥), (Left ⊥) is unrelated to (Right ⊥) in terms of definedness, and so on.
23:41:09 <dminuoso> nshepperd: https://en.wikibooks.org/wiki/Haskell/Denotational_semantics this?
23:41:30 <Maxdamantus> as an example of another issue I have: people in Haskell contexts often seem to call `IO` a type.
23:41:38 <quchen> The TaPL chapter that mentions the »Top/Bottom types« is specifically about subtyping as in OOP.
23:41:42 <dminuoso> Maxdamantus: But IO is a type..
23:41:47 <Maxdamantus> though GHC at least suggests that it's *NOT* a type.
23:41:47 <nshepperd> yes, and https://en.wikipedia.org/wiki/Domain_theory
23:41:53 <dminuoso> But I suppose that's a matter of perspective
23:41:58 <Maxdamantus> > let x :: IO; x = x in x
23:42:00 <lambdabot>  error:
23:42:00 <lambdabot>      • Expecting one more argument to ‘IO’
23:42:00 <lambdabot>        Expected a type, but ‘IO’ has kind ‘* -> *’
23:42:09 <Maxdamantus> Apparently IO is not a type.
23:42:14 <Maxdamantus> unless you want to fix GHC.
23:42:15 <dminuoso> Maxdamantus: that's a shitty diagonstic, one I prepared a PR for a while ago.
23:42:18 <|Leary> That's just a bad error message.
23:42:27 <dminuoso> Maxdamantus: The problem is that if you fix the diagonstics you will just confuse endless beginners..
23:42:29 <|Leary> :t Prelude.box
23:42:30 <lambdabot> error:
23:42:30 <lambdabot>     Not in scope: ‘Prelude.box’
23:42:31 <lambdabot>     Perhaps you meant one of these:
23:42:46 <|Leary> Hmm, what was that bad error message we had the other day...
23:42:47 <revskill> cocreature: You don't need to create new Number type to deal with `div` , right ?
23:42:52 <dminuoso> Maxdamantus: The only clean way to have that diagonstic read is: Expected an inhabitated type
23:43:02 <quchen> »Expected a type of kind ???« – where ??? will be fun to write down
23:43:04 <nshepperd> Maxdamantus: one error message is hardly conclusive, and is contradicted by the fact that ghc also lets you write 'type MyType = IO'
23:43:04 <Maxdamantus> dminuoso: is an empty type inhabited?
23:43:23 <Maxdamantus> dminuoso: because an empty type is perfectly acceptable there.
23:43:30 <cocreature> revskill: I don’t understand the question. you want a total version of div? you can just define some safeDiv function for that
23:43:34 <nshepperd> it hardly seems like sufficient cause to die on the rock of 'type = Type'
23:43:47 <revskill> yes, in my case, !!!! is like safe !!
23:44:15 <Maxdamantus> dminuoso: the real thing that is expected is something of kind "*"
23:44:20 <Maxdamantus> dminuoso: that kind is also known as "type"
23:44:22 <dminuoso> Maxdamantus: Except thats a lie too.
23:44:31 <dminuoso> Maxdamantus: Levity?
23:44:46 <Maxdamantus> What can you put there that is not of kind *?
23:44:49 <quchen> Expected a type »TYPE r« where r :: RuntimeRep
23:44:53 <quchen> #
23:44:56 <dminuoso> Heh
23:45:23 <Maxdamantus> Okay, don't know much about GHC extensions, but they should be fairly irrelevant here.
23:45:26 <nshepperd> 'Expected a habitable type'
23:45:30 <dminuoso> Maxdamantus: that is not extensions.
23:45:32 <dminuoso> Maxdamantus: that is core ghc.
23:45:35 <Maxdamantus> Preferably they would also not misuse type theoretical terms.
23:45:46 <dminuoso> % :i ($)
23:45:47 <yahb> dminuoso: ($) :: (a -> b) -> a -> b -- Defined in `GHC.Base'; infixr 0 $
23:45:51 * dminuoso sighs
23:46:09 <mniip> % :set -fprint-explicit-runtime-reps
23:46:09 <yahb> mniip:
23:46:11 <mniip> % :i ($)
23:46:12 <yahb> mniip: ($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b -- Defined in `GHC.Base'; infixr 0 $
23:46:32 <quchen> :i does that even without the -f, only :t is fixed
23:46:34 <nan`> dminuoso: if i have just an instance of that type is there any syntax to get the type of the instance? for example if i am writing a function that takes that type
23:46:43 <mniip> quchen, see above?
23:46:49 <dminuoso> mniip: Should you be in london at codenode in october you'll get a free cookie =)
23:47:03 <quchen> mniip: Oh, maybe I used an older GHCi then, woops
23:47:17 <quchen> 8.0.1 – waaait, what’s wrong with my $PATH
23:47:29 <dminuoso> nan`: Okay maybe we should start about what exactly you are trying to accomplish
23:47:43 <nan`> dminuoso: in the Int32 example i would have an Int32
23:47:47 <mniip> I have a new ghci. Newer. The newest!
23:48:51 <nan`> dminuoso: i am writing some database code and i want to refer to the table name for a given type
23:49:11 <dminuoso> nan`: What is "a given type"?
23:49:34 <nan`> dminuoso: i am making a general update-or-create database call for a database type called "Body"
23:49:56 <dminuoso> quchen: Though based on how RuntimeRep is defined, a diagnostic "an inhabitated type" should be equivalent.
23:49:56 <nan`> dminuoso: Body datatype maps to the "body" table in the database
23:50:10 <dminuoso> nan`: So when you say "type"
23:50:15 <dminuoso> do you mean a type in the haskell world?
23:50:54 <nan`> dminuoso: yes so for example body is a type with a constructor am i saying this right
23:51:35 <nan`> dminuoso: Body is a data type that corresponds to a row in the database
23:51:45 <nan`> dminuoso: for the 'body' table
23:52:05 <dminuoso> nan`: Ah I see. So far so good.
23:52:07 <nan`> i mean each body maps to a row
23:52:09 <nshepperd_> I thought my "habitable type" suggestion was actually good :'(
23:52:43 <quchen> nshepperd_: Void is more habitable than Monad. I like it!
23:53:03 <Maxdamantus> I think it's just adding weasle words to work around an incorrect term.
23:53:07 <Maxdamantus> `IO` is a function, not a type.
23:53:24 <Maxdamantus> You can call it a type-level function or something, to distinguish it from value-level functions or something.
23:53:34 <Maxdamantus> IO :: * -> *
23:53:35 <dminuoso> Maxdamantus: that depends on what you mean by type. If by type you mean some entity living in the type world then IO is a type just as much as `length` is a value.
23:53:47 <dminuoso> If `length` is a value, then IO should be a type.
23:53:49 <tdammers_> functions are values too!
23:54:04 <nan`> dminuoso: so now i'm writing this function called createOrUpdate that takes something like a body, and it generates an associative array of column names and "Actions" where Action is basically a sql string interp param
23:54:35 <Maxdamantus> dminuoso: as tdammers said, functions are values.
23:54:41 <Maxdamantus> dminuoso: values are not necessarily functions.
23:54:47 <tdammers> Maxdamantus: so type-level functions are also types
23:55:04 <nan`> dminuoso: so i decided that i need to know the table name for the Body type
23:55:06 <dminuoso> but not all types are type-level functions
23:55:35 <Maxdamantus> tdammers: if anything, that's just a result of the slightly misleading term "value-level functions"
23:55:38 <nshepperd_> type-level values
23:55:53 <Maxdamantus> tdammers: because I don't know what else to use to describe the "level below types"
23:55:55 <nshepperd_> value-level types
23:56:06 <tdammers> Maxdamantus: term-level? idk
23:56:32 <quchen> Type-0?
23:56:33 <Maxdamantus> tdammers: sure, but obviously you can refer to type-level things as terms too if you want.
23:56:40 <tdammers> right
23:56:57 <tdammers> personally, I don't care overly much, as long as your reasoning and your definitions are consistent
23:57:02 <Maxdamantus> Since you can do symbolic reduction etc on type-level thing.s
23:57:30 <dminuoso> nan`: I have a variety of ideas - but not enough experience to give you qualified advice.
23:57:39 <nan`> dminuoso: i'm ok with template haskell for each table type i think i will look into that
23:57:41 <tdammers> well yes, things are isomorphic across levels, that's why dependent types work in the first place
23:58:06 <tdammers> Int -> Int, Type -> Type, Kind -> Kind, etc.
23:58:30 <Maxdamantus> if/when I get around to implementing my language, I'll probably call type-level terms "vands", at least internally in the compiler.
23:58:43 <Maxdamantus> "vand" being something between values and kinds.
23:58:51 <dminuoso> nan`: So you probably will get much better help if you redirect your question to the channel again. My generic/TH/reflection foo is weak.
23:58:52 <tdammers> heh
23:59:13 <tdammers> speciesOf :: Term -> Term -- D:
23:59:46 <nan`> dminuoso: tanks
