00:01:34 <liste> c50a326: spider them and grep
00:05:38 <c50a326> o_o
00:06:05 <c50a326> it's okay, it's not that important
00:07:26 <mniip> hmm
00:07:33 <mniip> I've had a certain idea stuck in my mind for a while
00:08:05 <mniip> a library of STL-esque containers operating in the ST monad
00:10:16 <mniip> STArray/STUArray is kind of like std::array albeit with a runtime size (kind of like non-resizable std::vector)
00:10:44 <mniip> MVector from the vector package is like a slice of a vector
00:26:26 <cocreature> mniip: any specific containers that you are thinking about? there are some packages that have resizable vectors, e.g., dynamic-mvector and impure-containers. there are also packages that contain mutable hashtables (so the equivalent of unordered_map), e.g., the hashtables package
00:30:48 <mniip> cocreature, nothing specific yet
00:31:04 <mniip> I suppose Map/Set doesn't benefit from ST-ification
00:31:16 <mniip> and yes, there's hashtablels
00:31:42 <mniip> so the only thing left is stack,queue,priority_queue
00:31:50 <mniip> oh maybe deque
00:31:58 <mniip> and doubly linked list
00:38:11 <adjofun> butterthebuddha: Here are some slides for a basic idea: cs.bham.ac.uk/~drg/bll/steve.pdf
00:52:09 <nai> hi, say i have a function f :: a -> b -> c
00:52:38 <nai> i can write f2 = f 2 to "bind" the first argument to 2, and then call f2 3 which is the same as calling f 2 3
00:53:13 <nai> now if i want to "bind" the second argument instead, i can do: f_2 = \x -> f x 2
00:53:27 <nai> is there a simpler way, without using lambdas or argument variables?
00:53:38 <c50a326> flip
00:53:47 <nai> ah, that's one i heard of
00:53:54 <nai> but it seems a bit convoluted
00:54:04 <c50a326> and maybe `s for infix
00:54:30 <geekosaur> :t (`div` 2)
00:54:31 <lambdabot> Integral a => a -> a
00:54:58 <cocreature> I rarely would recommend flip. while there are some exceptions, it often just leads to hard to read code
00:55:00 <nai> ah, interesting
00:55:20 <nai> i'd thought there would be a way using ($)
00:55:42 <geekosaur> not usefully. (f $ a) is (f a)
00:57:16 <geekosaur> you can do things like ($ 1) but that doesn't commute parameters, it commutes the function and its first parameter
00:58:38 <c50a326> ah yeah just parenthesizing and infixing like geekosaur put is the best
00:58:51 <gentauro> anybody know why aeson isn't marked as Trustworthy? -> http://hackage.haskell.org/package/aeson
01:00:13 <nai> heh, jokes on you, i think i found a way
01:00:20 <nai> g = ($ 2) f   seems to work
01:00:52 <nai> wait no
01:00:58 <c50a326> nai: I think geekosaur just explained that. It seems to work but it's actually doing something different.
01:00:59 <gentauro> I mean, must (if not all) of it's dependent packages are marked either Safe or TrustWorthy ...
01:01:06 <nai> nevermind
01:01:39 <c50a326> what are you guys using to go to definitions and to get type signatures of everything in vim?
01:02:31 <iqubic> I use Emacs instead.
01:03:32 <cocreature> gentauro: nobody really cares about SafeHaskell these days so it might just be an oversight
01:04:07 <gentauro> hmmm ghc-prim, scientific, uuid-types and vector are marked as None
01:05:02 <gentauro> cocreature: I'm creating a Safe library, I can trust packages that are marked as -TrustWorthy but I can't trust packaged marked as None
01:05:08 <gentauro> which it's a bit annoying ...
01:06:08 <cocreature> just stop using SafeHaskell like the rest of us? :)
01:06:30 <gentauro> cocreature: you would like that right?
01:07:32 <cocreature> heh, I don’t really care what you do with your code so if you want to spend your time on that, be my guest. I’m just suggesting that given that the rest of the ecosystem doesn’t care much about that, it might not be worth your time.
01:07:54 <gentauro> cocreature: well there is a "reason" i care about this
01:08:26 <gentauro> and I'm totally fine with the majority of the community not giving a crap about it
01:08:33 <gentauro> as long as the compiler does
01:08:34 <gentauro> :)
01:09:00 <cocreature> fair enough
01:09:30 <gentauro> my question with regard of aeson was just why it's not trustworthy (both bytestring and text is)
01:09:53 <gentauro> so I can't see what aeson would do "under the hood" that the compiler find so difficult to infer "not-safe" :\
01:10:42 <gentauro> but it might have to do with: ghc-prim, scientific, uuid-types and vector beeing marked as None
01:16:37 * hackage math-functions 0.3.0.1 - Collection of tools for numeric computations  http://hackage.haskell.org/package/math-functions-0.3.0.1 (AlexeyKhudyakov)
01:20:57 <c50a326> ah I should use intero :D
01:21:14 <c50a326> so intero for jumping to defs and seeing type sigs, ale for all the rest, voila, everything should be good...
01:22:02 <c50a326> oh and deoplete for completion... hmmm... I'm still a bit curious what vs code with haskero might be like... i've never used vs-code... something would feel extremely treacherous about the whole thing...
01:22:24 <liste> c50a326: I'm a happy vscode+haskero user
01:22:41 <liste> I also use the vim bindings, it delegates :-commands directly to neovim
01:24:01 <c50a326> I mean it sounds great but...
01:24:28 <c50a326> sigh maybe I'll try it
01:24:48 <gentauro> c50a326: YES !!! Intero is so so so NICE !!!
01:25:16 <gentauro> liste: does intero play with vscode / atom?
01:25:33 <liste> gentauro: there's a vscode extension for intero called haskero
01:25:45 <gentauro> liste: roger that :)
01:27:59 <c50a326> liste: is there some funky stuff for deps/imports etc.?
01:28:26 <c50a326> liste: I mean if you add some deps to your package.yaml, can import statements then be auto-completed somehow?
01:28:40 <c50a326> gentauro: same question to you for your vim setup (presuming you use vim and not emacs)
01:29:09 <gentauro> c50a326: VIM SETUP !!!
01:29:15 <gentauro> JUAAAAAAAAAAATT !!!
01:29:19 <c50a326> I guess that's more to do with deoplete with vim (or other completion plugin) than intero
01:29:20 <gentauro> ARE YOU CRAZY !!!
01:29:21 <gentauro> OMG !!!
01:29:31 <gentauro> I'm one with my emacs !!!
01:29:33 <gentauro> :'(
01:29:34 <Strawberry> :)
01:29:36 * c50a326 o O ( this guy watches too much anime... )
01:29:41 <gentauro> I will lay down in the corner and cry
01:30:28 <cocreature> is there a -Safe flag for gentauro that disables capslock?
01:30:31 <c50a326> maybe I should also use Emacs again... I did use it for like 6 months or maybe a year
01:30:47 <gentauro> c50a326: yes, RMS approves -> https://stallman.org/saint.html
01:32:23 <gentauro> cocreature: yes there is, write the following in your linux box: '/bin/rm -frv /'
01:32:27 <gentauro> that will do :P
01:33:22 <cocreature> gentauro: sorry, won’t work :) cannot access '/bin/rm': No such file or directory
01:35:35 <c50a326> sigh... so trying to use deoplete with neco-ghc is what causes all these tmp dirs in the project directory -.-
01:35:43 <gentauro> nah, don't do it, you are actually the guy who answer most stuff in here :D
01:39:37 * hackage edges 0.4 - Tools for efficient immutable graphs  http://hackage.haskell.org/package/edges-0.4 (NikitaVolkov)
01:43:01 <c50a326> there's no alternative for completion in vim not using ghc-mod, is there? -.-
01:44:01 <tdammers> c50a326: dumb textual completion, vim's default
01:44:11 <tdammers> c50a326: I like it quite a bit
01:45:28 <c50a326> tdammers: what do you do for imports?
01:45:45 <tdammers> nothing
01:45:59 <c50a326> I'm just going to try vs-code, if it doesn't work out I might jump back to emacs
01:46:14 <tdammers> vim looks at the tags file, which contains everything defined in the codebase
01:46:23 <c50a326> I guess emacs is the de facto FP language editor/ide anyways, so at least if I have to do anything in other FP's I'll probably have an easier time with that
01:46:28 <c50a326> tdammers: oh what do you use for tags?
01:46:32 <tdammers> hasktags
01:46:45 <c50a326> oh cool I'll try that before I hand my vim badge in then
01:47:10 <tdammers> I'm still looking for a lightweight solution for import management though
01:47:44 <tdammers> something that doesn't depend on any particular GHC version, processes an import list in under 10 milliseconds, and never fails
01:49:41 <c50a326> tdammers: does hasktags even know about dependencies installed by stack?
01:50:09 <tdammers> c50a326: no, at least not unless you point it to them.
01:50:34 <tdammers> c50a326: but I get the impression that what you're looking for in terms of completion is not what I'm looking for
01:51:07 * hackage edges 0.4.0.1 - Tools for efficient immutable graphs  http://hackage.haskell.org/package/edges-0.4.0.1 (NikitaVolkov)
01:53:59 <c50a326> tdammers: just that if I've added the network package to my package.yaml, then I can do something like `im<tab>Net<tab>Sock<tab>hid<tab>(se<tab>, re<tab>)`
01:54:40 <c50a326> and that a menu is popping up and showing me the options before hitting tab, and I can go up and down
01:54:51 <c50a326> I used to write Java in Eclipse, so that kind of thing
01:55:01 <tdammers> yep, so that's definitely different
01:55:03 <c50a326> anyways I think I'm just going to try vs-code and spacemacs lol
01:55:10 <tdammers> you want "smart" autocompletion, I want "dumb"
01:55:10 <noipmups> Hello, what is the convention of naming Haskell libraries that wraps C libraries? For example if I translate C library named `clibfoo` into Haskell, should I name it `hlibfoo`, `hslibfoo`, `hfoo` or just `foo`?
01:55:43 <tdammers> noipmups: I don't think there's consensus there
01:56:53 <noipmups> tdammers: Ok, thank you.
01:57:12 <tdammers> noipmups: but it's customary to mention in the Summary field that it wraps the C library, if that's what it does
01:57:41 <tdammers> noipmups: e.g.: "hsfoobar: libfoobar bindings for Haskell"
01:58:06 <tdammers> noipmups: as opposed to "hsfoobar: pure Haskell implementation of the foobar protocol"
01:58:23 <tdammers> noipmups: people want to know whether you're introducing a C dependency
01:59:07 * hackage OTP 0.1.0.0 - HMAC-Based and Time-Based One-Time Passwords (HOTP & TOTP)  http://hackage.haskell.org/package/OTP-0.1.0.0 (HerbertValerioRiedel)
01:59:56 <noipmups> tdammers: Got it, thanks for the useful advice.
02:06:38 <merijn> Whoo! new-build git dependencies have been merged into HEAD :)
02:07:47 <f-a> I am reading about "dynamic dispatch". If I understood it correctly, it would be impossible to do in Haskell (90/2018), right?
02:08:07 <merijn> f-a: Naah, you can do it, it's just more painful :)
02:08:39 <merijn> f-a: Typeable and Data let you do all the awful type-based dispatch you want
02:08:50 <f-a> ok, with typeable and dynamic, right?
02:09:46 <merijn> f-a: In fact, this is heavily abused on the exception system. What many people gloss over is that the exception system actually allows subclassing and creating "groups" of exceptions (so you can group all your libraries exception into one group and let users catch everything inside that group)
02:10:51 <lantti> doesn't polymorphism imply dynamic dispatch anyway?
02:10:56 <merijn> No
02:11:10 <merijn> lantti: Dynamic dispatch relies on taking different codepaths for different types
02:11:41 <merijn> lantti: Parametric polymorphism like "id :: a -> a" has a single code path for each possible 'a' it doesn't inspect what 'a' is and call that specific types implementation
02:11:46 <lantti> for example '+' works on ints and floats but surely those are different code paths somewhere
02:11:51 <mniip> huh
02:11:56 <mniip> hackage randomly prompts me for a password
02:12:21 <mniip> happened more than once on pages that should be publicly accessible (package pages)
02:12:32 <merijn> lantti: Typeclasses work slightly different, they can have different implementation for different types, but don't generally do dynamic dispatch
02:12:51 <merijn> mniip: Yeah, there was a bug reported earlier where it'd sometimes prompt you to login after your login expired even when viewing public pages
02:12:52 <Rembane> mniip: Have you found darkage? The darknet of hackage?
02:13:11 <f-a> thanks merijn
02:13:19 <mniip> and then I press 'cancel' and it goes No authorization provided
02:13:34 <merijn> lantti: Dynamic dispatch in C++ parlance generally involves an indirection of having to lookup (at runtime) which code to call, but with typeclasses sometimes (actually, very often) you can statically resolve that dispatch at compile time
02:14:00 <merijn> f-a: If you wanna see how it gets abused in the exception system, the paper "An Extensible Dynamically-Typed Hierarchy of Exceptions" is a neat read
02:14:21 <lantti> ah, yes sure. haskell resolves all that statically
02:14:23 <merijn> f-a: Also a good way to figure out that most people are glossing over like 80% of the power that's in the exception implementation :)
02:14:28 <lantti> sorry for my brainfog :)
02:14:40 <merijn> lantti: Not always, sometimes it has to be done at runtime
02:14:52 <merijn> lantti: But dynamic dispatch *always* does it at runtime
02:14:55 <f-a> merijn: I am more reassured that it isn't used often bar exceptions :P
02:15:18 <merijn> f-a: That's because it becomes quite annoying when you have to add Typeable constraints everywhere ;)
02:15:54 <merijn> f-a: I've used it a few times, usually in the context of existential quantification and GADTs enforcing some type that GHC can't tell and needing Typeable to beat GHC into submission
02:16:14 <merijn> Although I suppose that case could also be handled by unsafeCoerce if you're feeling adventurous
02:16:19 <lortabac> merijn: in which cases are instances resolved at runtime?
02:16:47 <merijn> lortabac: Usually when you're doing some funky RankN stuff
02:17:39 <merijn> lortabac: See this gist I wrote to use as example for when Rank2 types are needed: https://gist.github.com/merijn/77e3fa9757658e59b01d
02:18:09 <merijn> lortabac: If I write "mangle (+1)" in my code using that second version, it can't resolve which version of (+1) is needed until runtime
02:18:29 <lortabac> merijn: true, I had never thought about that
02:19:35 <vaibhavsagar> can I set a configureFlag with a directory in it?
02:19:46 <vaibhavsagar> oops, wrong channel :)
02:19:56 <merijn> lortabac: GHC's implementation of typeclasses is explicitly passing the dictionary as extra argument to a function, but when the type is statically known it can inline that dictionary argument (and it's functions) completely and get rid of it. Which applies in basically all monomorphic cases. But in any case where there's no monomorphic type there's no way to tell at compile time what it'll be at runtime,
02:20:08 <merijn> so you need to keep the dictionary
02:20:22 <c50a326> maybe I'll have an easier time with elisp now that I know a bit of haskell
02:20:46 <Taneb> Are there any cases where it'd have to choose from an infinite number of instances at runtime?
02:21:08 <mniip> yes
02:21:51 <mniip> a polymorphically recursive datatype for example needs to corecursively apply dictionary transformers
02:23:25 <Taneb> I was thinking that may be the case
02:23:40 <mniip> lortabac, it's important to note that instances aren't *searched for* at runtime
02:24:21 <Taneb> Something like data Foo f a = Raw a | Nest (f (Foo (Compose f f) a) with instance Foldable f => Foldable (Foo f)
02:24:22 <Taneb> ?
02:24:38 <mniip> @let data D a = P a | T (D (a, a)) deriving Eq
02:24:39 <lambdabot>  Defined.
02:25:51 <lortabac> mniip: so what happens at runtime exactly?
02:26:47 <mniip> @let eqBranch :: Eq a => D (a, a) -> Bool; eqBranch (P (x, y)) = x == y; eqBranch (T x) = eqBranch x
02:26:48 <lambdabot>  Defined.
02:27:06 <merijn> Taneb: Also, I don't see how it being limited to a finite set makes it significantly easier to generate "better" code than just passing the dictionary
02:27:22 <mniip> lortabac, just dictionary passing
02:27:29 <merijn> lortabac: The caller of the function has to provide the dictionary to the function that's called
02:27:33 <mniip> consider the eqBranch above
02:27:52 <mniip> even if we monomorphize the 'a' there's no way we can inline the dictionary as in the last equation for the function there's polymorphic recursion
02:28:03 <mniip> eqBranch @Int  invokes eqBranch @(Int, Int) and so on
02:28:08 <lortabac> mniip: ok, I see
02:28:28 <mniip> therefore the dictionary passing has to be explicit like
02:28:46 <Taneb> merijn: it's more convincing to me when I don't feel like thinking too much about it
02:28:47 <mniip> eqBranch eqDict (P (x, y)) = (==) eqDict x y
02:29:03 <mniip> eqBranch eqDict (T x) = eqBranch (eqTrans eqDict) x
02:29:20 <mniip> where eqTrans is the dictionary transformer that corresponds to the instance  Eq a => Eq (a, a)
02:29:56 <mniip> well to be completely honest it's (Eq a, Eq b) => Eq (a, b), hence eqTrans will be a binary function but that's a minor detail
02:31:48 <mniip> when you define 'instance Cls Ty' you create a dictionary value
02:32:04 <mniip> an 'instance Cxt => Cls Ty' works more like a dictionary function
02:32:36 <sam___> Hiya, I'm new to Haskell and had a question about list comparisons
02:33:03 <sam___> I don't seem to understand why [1, 2, 3] > [0, 100, 100] is true
02:33:19 <merijn> sam___: It use lexiographical ordering
02:33:33 <Sornaensis> @info (>)
02:33:34 <lambdabot> (>)
02:33:36 <merijn> sam___: So first compare the first elements, then if those are equal, compare the second, etc.
02:33:36 <Sornaensis> thanks
02:33:42 <mniip> sam___, you don't seem to understand why we chose that meaning of '>' for lists, or how the result comes for the implementation of > for lists?
02:33:53 <merijn> Sornaensis: There is no @info, @info just auto corrects to the echo function
02:34:00 <sam___> How the result comes from the implementation
02:34:01 <Sornaensis> @src (>)
02:34:01 <lambdabot> x > y = case compare x y of
02:34:01 <lambdabot>           GT -> True
02:34:01 <lambdabot>           _  -> False
02:34:06 <c50a326> what's the technical word for that in math, where the left has a higher weight than the right, e.g. the 1's, 10's, 100's, 1000's columns in 2838
02:34:08 <mniip> merijn, not @undo?
02:34:16 <c50a326> the lefter digits have higher _____?
02:34:17 <merijn> mniip: Maybe, I forget
02:34:21 <mniip> c50a326, lexicographical
02:34:24 <merijn> c50a326: lexicographical ordering
02:34:25 <Sornaensis> 1 > 0
02:34:35 <sam___> But 2 is not greater than 100
02:34:38 <c50a326> hmmm I thought there was a different worker that would go in the _s... nvm if there isn't
02:34:40 <sam___> So does it just stop comparing?
02:34:47 <mniip> sam___, yes it does
02:34:50 <Sornaensis> yep
02:34:52 <mniip> that's what lexicographical means
02:35:05 <mniip> [1 ...] is always more than [0 ...]
02:35:08 <Sornaensis> think of it as comparing ordering of strings
02:35:10 <merijn> c50a326: I mean, I've always seen lexicographical used in a bunch of CS and math papers, so I'd just stick with that :)
02:35:12 <mniip> regardless of what's in the rest of either list
02:35:29 <adjofun> sam: same with strings: "axy" > "byz"
02:35:39 <mniip> adjofun, itym <
02:36:02 <c50a326> but lexicographical, when i google, says it's to do with "the way words are alphabetically ordered based on the alphabetical order of their component letters."
02:36:02 <adjofun> > [1, 2, 3] > [0, 100, 100]
02:36:04 <lambdabot>  True
02:36:14 <mniip> c50a326, 1,2,3... are like letters
02:36:16 <Sornaensis> the instance is defined for lists and strings are lists of characters
02:36:17 <c50a326> isn't there a term that's more specifically used for decimal number weights
02:36:18 <merijn> c50a326: Yeah, math people just generalised it
02:36:34 <adjofun> > "bxy" > "ayz"
02:36:36 <lambdabot>  True
02:36:42 <merijn> c50a326: Lexicographical ordering in math just means "pairwise comparison and stop after the first unequal pair"
02:36:45 <sam___> Awesome, I think I understand. Thanks a lot everyone!!
02:36:46 <c50a326> that they use when they teach you how to "carry", in long addition/subtraction etc?
02:36:58 <merijn> c50a326: For whatever comparison that happens to be for the relevant elements
02:37:24 <merijn> c50a326: So if we're comparing words lexicographically we'd do pairwise comparison of letters
02:37:32 <c50a326> merijn: yeah that's great, but I'm sure there's a different term for what I've just described, in the context of long addition/subtraction etc, I'll have a search
02:37:41 <Lears> place value?
02:37:43 <mniip> hmm
02:37:47 <sam___> And I've got to say, this has got to be the fastest answer/explanation I've had. This community's something else
02:37:51 <merijn> c50a326: See also: https://en.wikipedia.org/wiki/Lexicographical_order
02:38:35 <mniip> is there an equally fast but not as unsafe way of writing
02:38:54 <mniip> compare x y | I# (tagForCon# x) /= I# (tagForCon# y)
02:39:22 <c50a326> yeah maybe I was thinking of place value... it's silly anyway I guess, and good to learn what lexicographical order is
02:39:32 <merijn> c50a326: "carry" is quite common in addition/multiplication, etc. any other word seems likely to be some invention of high school curriculum or something
02:39:36 <merijn> mniip: Yes
02:39:44 <merijn> mniip: I think there's ==#?
02:40:03 <merijn> mniip: https://hackage.haskell.org/package/ghc-prim-0.5.1.1/docs/GHC-Prim.html#v:-61--61--35-
02:40:04 <mniip> % :t (==#)
02:40:05 <yahb> mniip: Int# -> Int# -> Int#
02:40:07 <mniip> is this what you mean
02:40:34 <merijn> mniip: There's also /=# and co
02:40:40 <mniip> merijn, I was pointing at the tagForCon#
02:40:49 <gentauro> > :t undefined
02:40:51 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
02:41:15 <gentauro>  % :t undefined
02:41:21 <gentauro> % :t undefined
02:41:21 <yahb> gentauro: a
02:41:23 <merijn> mniip: Ah, wait, that's doing something different that I thought
02:41:33 <gentauro> % :i undefined
02:41:34 <yahb> gentauro: undefined :: GHC.Stack.Types.HasCallStack => a -- Defined in `GHC.Err'
02:41:40 <merijn> mniip: That's gross, may god have mercy on your soul :)
02:42:01 <merijn> mniip: And no, absent a Eq instance I don't think there is, except maybe generics
02:42:14 <merijn> mniip: But hey, at least /=# will make it slightly faster!
02:42:18 <mniip> well consider an Ord instance for a datum with 1000 constructors
02:42:33 <mniip> to make it worse - none nullary
02:42:51 <mniip> does the generated Ord instance really have 1000000 equations?
02:43:00 <mniip> or 1000 nested 1000-branch cases?
02:43:08 <merijn> No clue
02:43:20 <merijn> Sounds like time to dump out the generated STG/Cmm
02:44:11 <mniip> % :set -ddump-deriv
02:44:12 <yahb> mniip:
02:44:30 <mniip> %% data D a = C1 a | C2 a | C3 a | C4 a | C5 a deriving (Eq, Ord)
02:44:31 <yahb> mniip: http://qp.mniip.com/y/82
02:44:35 <merijn> MagicHash and #, for when you think your Haskell isn't enough like C ;)
02:45:09 <mniip> well take a look at that
02:45:20 <mniip> that looks weird to me
02:46:02 <mniip> like C3 has a different branch
02:46:39 <mniip> "if tagToEnum# ... then"
02:46:40 <mniip> yuck
02:47:19 <mniip> %% data D a = C1 a | C2 a | C3 a | C4 a | C5 a | C6 a | C7 a | C8 a deriving (Eq, Ord)
02:47:19 <yahb> mniip: http://qp.mniip.com/y/83
02:48:33 <mniip> %% data D a = C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 deriving (Eq, Ord)
02:48:34 <yahb> mniip: http://qp.mniip.com/y/84
02:48:43 <adjofun> hm, it seems like first and last two cases are taking one branch, while other are taking in the middle
02:49:56 <mniip> adjofun, yes it looks like GHC decides not to use the dataToTag# trick when it can test for 1 or 2 branches
02:50:12 <mniip> pretty clever actually
02:50:52 <mniip> is dataToTag# expensive?
02:51:08 <mniip> wouldn't imagine it to be
02:51:22 <mniip> oh
02:51:28 <mniip> it uses it's own con2tag
02:51:40 <mniip> I guess because dataToTag# is a bit more low-level
02:51:50 <mniip> % I# (dataToTag# id)
02:51:51 <yahb> mniip: 0
02:54:40 <mniip> haha I found something more hilarious than 'fix error'
02:54:49 <mniip> % fix raise#
02:54:53 <yahb> mniip: ghc: panic! (the 'impossible' happened); (GHC version 8.6.0.20180620 for x86_64-unknown-linux):; heap overflow; Please report this as a GHC bug: http://www.haskell.org/ghc/reportabug
02:55:04 <merijn> Nice
02:55:51 <mniip> ghci tries to patternmatch on the SomeException
02:56:17 <mniip> but luckily the exception is wearing a smaller exception underneath
03:00:03 <mniip> merijn, you know, haskell with MagicHash feels like... typed assembly
03:00:41 <mniip> you shoot yourself in the foot but only because  gun :: Foot -> State# s -> State# s
03:01:54 <merijn> Honestly, I think Haskell is a better high level assembly than C
03:02:17 <merijn> Because low-level Haskell doesn't pretend to follow some abstract machine with BS rules like 'strict aliasing"
03:02:28 <mniip> there are no rules basically
03:03:10 <dstolfa> merijn: C's not even high level assembly, it's just a mush of undefined and implementation-defined behaviour that people can't even write down formally without running into contradictions from the official spec
03:03:15 <mniip> frankly I am yet to acquire a mental model for the interaction of sparks/HEC/threaded RTS and State#
03:08:33 <Tehnix> set weechat.color.chat_nick_colors "cyan,magenta,green,brown,lightblue,default,lightcyan,lightmagenta,lightgreen,blue,31,35,38,40,49,63,70,80,92,99,112,126,130,138,142,148,160,162,167,169,174,176,178,184,186,210,212,215,247"
03:08:50 <mniip> does the State# s parameter result in complete sequentialization of the code? wrt that parameter at least
03:09:00 <mniip> even if erased
03:21:15 <quicksilver> merijn: this GHC implementation detail stuff though - the things that I think mniip means by MagicHash - is a slightly exotic language whose semantics are not written down
03:21:31 <quicksilver> it probably is nicer than C, but it's definitely not easy
03:21:37 <quicksilver> and not specified anywhere.
03:21:48 <quicksilver> (aside - that's really not what MagicHash means)
03:22:14 <mniip> sure, MagicHash just means # is an alphanumeric
03:28:30 <ultracool> Can someone explain me the use case of Apply in real world
03:28:40 <ben> what's Apply
03:28:52 <liste> :t Apply
03:28:53 <lambdabot> error: Data constructor not in scope: Apply
03:28:55 <mdim> Hi everyone! Is there a Stack command that would clean up Hoogle-generated files (obtained by running `stack hoogle`), including those in .stack-work/hoogle/ ?
03:29:13 <ben> "Apply - a strong lax semimonoidal endofunctor" oh. yikes.
03:29:14 <mniip> ultracool, which Apply do you mean?
03:29:44 <phadej> I guess "Applicative without pure"
03:29:51 <ultracool> The apply in applicative type class
03:30:14 <mniip> there's no apply in the Control.Applicative.Applicative typeclass
03:30:16 <ultracool> f (a -> b) -> f a -> f b
03:30:20 <mniip> ah <*>
03:30:25 <phadej> mniip: semigroupoids
03:31:41 <ultracool> @mniip can you give me an example of the use case of <*>
03:31:41 <lambdabot> Unknown command, try @list
03:31:43 <cocreature> ultracool: do you know fmap?
03:31:56 <ultracool> yes fmap functor
03:31:58 <mniip> ultracool, a few "containers" don't have infinite versions like [] but are applicative  in the zipping sense nevertheless
03:32:20 <cocreature> ultracool: <*> allows you to extend that to curried functions that take multiple arguments
03:32:26 <cocreature> :t \f x y -> f <$> x <*> y
03:32:27 <lambdabot> Applicative f => (a1 -> a2 -> b) -> f a1 -> f a2 -> f b
03:33:01 <mniip> a nonzero amount of arguments
03:33:08 <mniip> for the zero case you need Pointed/Applicative
03:33:31 <ultracool> ohhh I get it
03:33:42 <ultracool> Thanks for the help :D
03:38:13 <reactormonk> Which regex library should I use that processes Text? They're a bit hard to find. And yes, I want regex, not parsers, because I got some regexes already from another system to reimplement.
03:39:58 <ggVGc> how can I do something like this? https://gist.github.com/99441630b0ebb62c25565314bc259546
03:40:28 <ggVGc> that semigroup instance is incorrect, but can I express the same thing some other way?
03:40:31 <ggVGc> also, why can't I do this?
03:40:39 <cocreature> ggVGc: make a newtype that uses this instance
03:41:11 <cocreature> ggVGc: for each type there can be only one instance. you are making an instance that matches every type and thereby collides with all other instances
03:41:57 <ggVGc> cocreature: well, what I want to express is "Every type that is also an instance of Lang"
03:42:10 <ggVGc> but I think it's not exprssible?
03:43:54 <mniip> ggVGc, is the 'c' determined by the caller of langCombine?
03:43:58 <cocreature> ggVGc: GHC decides which instance it chooses based on the instance head and only once it has decided which instance it chooses, it checks if the constraints on that instance are satisfied
03:49:43 <merijn> Sometimes I'm sad GHC never took up Habit's "instance chain" design
03:49:53 <merijn> I thought it was quite elegant
03:50:34 <merijn> reactormonk: I recall someone implementing a parser combinator library that turned regexes into parsers dynamically, but I forgot the name
03:51:02 <cocreature> there is regex-applicative(-text)
03:58:07 * hackage csg 0.1.0.4 - Analytical CSG (Constructive Solid Geometry) library  http://hackage.haskell.org/package/csg-0.1.0.4 (DmitryDzhus)
04:00:19 <mniip> hmm
04:00:29 <mniip> an 'STRef () a' is harmless right?
04:00:45 <mniip> if I specialize the thread parameter to a specific type the thing becomes unusable
04:01:20 <cocreature> mniip: harmless in what sense?
04:01:58 <merijn> You wouldn't even be able to run "STRef () a" in any transaction
04:02:14 <merijn> mniip: Why would you bother doing that, though?
04:02:53 <merijn> mniip: The entire way ST is setup any STRef's already get "defused" when you return them from an ST block, so they're already inert
04:03:41 <mniip> merijn, I want a quick "freeze" operation for a data structtre that uses STRefs and other ST magic
04:04:09 <mniip> (forall s. Datum s) -> Datum Any  sounds fitting
04:04:46 <mniip> hmm no
04:04:50 <mniip> that would make the refs unreadable
04:05:10 <merijn> I still don't see the point of this exercise, though
04:05:56 <mniip> well imagine you have a datatype speckled with STRefs
04:06:13 <mniip> and you want to go  (forall s. ST s (Datum s)) -> FrozenDatum
04:06:26 <mniip> that would in general require traversal of the whole structure
04:06:37 <mniip> there's gotta be a better way
04:08:33 <mniip> hmm there might not be a better way
04:10:21 <mniip> nothing you can do about a MutVar closure...
04:11:18 <mniip> and STRef Any a -> a  is not typesafe
04:11:37 <mniip> or is it
04:12:00 <merijn> It's not safe, no
04:12:14 <mniip> example?
04:12:23 <merijn> The entire point of the 's' is that you can't leak, so if you wanna read shit out, you have to traverse every STRef
04:12:56 <mniip> I'm looking past the hight level abstraction
04:13:00 <merijn> If you somehow find a way to make "STRef Any a" runnable again after returning from an ST action, then you lose all the memory safety/purity that ST gave you
04:13:10 <mniip> can you implement unsafeCoerce with   STRef Any a -> a
04:13:45 <hpc> mniip: probably - you can with a polymorphic IORef but iirc it has to be top-level?
04:13:58 <hpc> which, if you can make an STRef escape ST that's not hard
04:14:04 <mniip> I know the polymorphic IORef example but I don't see a way to apply it here
04:14:15 <hpc> the important thing is that it's polymorphic and mutable
04:14:29 <hpc> so you can write an Int to it, then read back a Char
04:15:07 <mniip> it's only mutable in ST and before specialized to Any
04:16:17 <hpc> i mean, all of this is assuming an implementation of ST that lets us construct that in the first place
04:16:24 <hpc> and you can run ST anywhere
04:16:40 <hpc> being mutable in ST isn't that big a hurdle
04:17:44 <mniip> % unpackSTRef :: STRef GHC.Exts.Any a -> a; unpackSTRef (STRef m) = case readMutVar# m (unsafeCoerce# realWorld#) of (# _, a #) -> a
04:17:44 <yahb> mniip:
04:19:05 <mniip> ah I could see how this violates RT
04:19:10 <mniip> same way as unsafeInterleaveIO
04:20:52 <hpc> every so often i have to go back and work out why unsafeInterleaveIO is worse than forkIO
04:21:08 <mniip> hmm
04:21:13 <mniip> I thought I saw it
04:22:38 <hpc> well, let's suppose you have some usable toplevelEvilRef :: STRef whocares a
04:23:11 <hpc> unsafeCoerce a = runST $ writeSTRef toplevelEvilRef a >> readSTRef toplevelEvilRef
04:23:20 <mniip> nuh uh
04:23:36 <hpc> yuh huh :P
04:23:37 <mniip> readSTRef toplevelEvilRef :: ST whocares a
04:23:42 <mniip> doesn't fit into runST
04:24:06 <mniip> assuming of course whocares is a concrete type and not a unification variable
04:24:20 <hpc> assuming the ref is usable
04:24:36 <hpc> which i forget who asked the original question but that's what we were explaining
04:25:18 <cocreature> mniip asked about STRef Any a -> a not ST s a -> a
04:25:44 <merijn> hpc: How would you manage to make a top-level STRef?
04:25:49 <hpc> toplevelEvilRef :: STRef WhoCares a then ;)
04:26:11 <cocreature> I still don’t see how that works. you can’t use writeSTRef on that
04:26:13 <hpc> merijn: you wouldn't be able to, this is just explaining what happens if you could
04:26:39 <mniip> hpc, you still can't use such an STRef in runST
04:26:41 <mniip> % :t runST
04:26:42 <yahb> mniip: (forall s. ST s a) -> a
04:26:46 <hpc> it explains why it's rank-2 in the first place
04:27:13 <hpc> mniip: /yes/, this assumes that's not the case because that's the hypothetical we were in to begin with
04:27:23 <hpc> otherwise you can't even make STRef Any a
04:27:37 <merijn> So, anyone at this "Curry On" conference thing in Amsterdam?
04:40:37 <romanix> does anyone know how to sort a (Vector Double) in the Accelerate library? (http://hackage.haskell.org/package/accelerate)
04:41:56 <Athas> romanix: you may find this thread useful: https://www.reddit.com/r/haskell/comments/7n22b1/fast_sorting_with_accelerate/
04:43:19 <romanix> Athas, thanks
04:44:07 * hackage superrecord 0.5.0.1 - Supercharged anonymous records  http://hackage.haskell.org/package/superrecord-0.5.0.1 (AlexanderThiemann)
04:53:44 <mniip> ooh
04:53:49 <mniip> monoid-on-monoid actions
05:08:07 * hackage deriveJsonNoPrefix 0.1.0.0 - Derive ToJSON/FromJSON instances in a more prefix-friendly manner.  http://hackage.haskell.org/package/deriveJsonNoPrefix-0.1.0.0 (igrep)
05:27:07 * hackage jord 0.2.0.0 - Geographical Position Calculations  http://hackage.haskell.org/package/jord-0.2.0.0 (CedricLiegeois)
06:19:14 <magicman> Is there a canonical way to run a parser "somewhere" in a given string?
06:20:14 <magicman> As in, `run (many isDigit) "abc123def"` gives me "abc" as prefix, "123" as result, and "def" as suffix?
06:20:37 <magicman> I could do something like that by trying after every character, but that sounds horrible.
06:20:56 <merijn> "skipMany (not <$> isDigit) >> many isDigit >> skipMany (not <$> isDigit)"?
06:21:40 <magicman> Yeah, that works for isDigit in particular, but for some external parser p, that I may not know beforehand?
06:22:13 <tdammers> manyTill?
06:23:01 <magicman> Yeah, something like that, but with the result of `end` instead of `p`.
06:23:29 <tdammers> you could probably also exploit notFollowedBy somehow
06:23:45 <tdammers> (too lazy to think it through though)
06:24:02 <fendor> how can i tell optparse-applicative that a flag is obligatory and must be the first parameter? e.g. no flag required for the parameter
06:25:12 <magicman> Aight, I'll work something out. Worst case it'll be "infix p = try p <|> satisfy (const True) >> infix p".
06:26:19 <dmwit> magicman: infix p = do { pre <- manyTill p; v <- p; suf <- many any; eof; return (pre, v, suf) } -- ?
06:26:55 <merijn> dmwit: I think manyTill would be less efficient than "skipMany" with inverted isDigit
06:26:56 <dmwit> Oops, `manyTill any p`.
06:27:07 <merijn> dmwit: Because with manyTill you end up trying two parser for every character that way
06:27:14 <dmwit> merijn: True. But that's harder to make work for arbitrary `p`, which was the request.
06:28:05 <merijn> True
06:30:11 <magicman> "manyTill any p" already runs p without returning its result. Hrm. "manyTill any (lookahead p) >> p"? Seems kinda horrible.
06:30:31 <dmwit> fendor: `argument`?
06:31:45 <dmwit> magicman: Oh. Well, then just copy the source of `manyTill` and change it to return the result of `p`.
06:31:58 <magicman> Fair!
06:32:09 <dmwit> Might even be worth including directly in the package, dunno.
06:33:54 <dmwit> fendor: There's also `strArgument` if you specifically want the value as a string.
06:35:31 <merijn> magicman: manyTill already wraps with lookahead
06:37:18 <dmwit> Depends which manyTill. There's lots lying around.
06:37:44 <dmwit> parsec's doesn't. attoparsec's can't given its type.
06:38:24 <dmwit> base's doesn't need to.
06:41:09 <fendor> dmwit, yeah, i mean that the first argument, not the flag, is obligatory and i want the argument to be passed in without a flag
06:42:49 <Pranky> Hi guys, next semester I can choose Haskell as a programming language. Can you tell me where it is used, what kinds of jobs can I get with it etc.
06:44:42 <tdammers> Pranky: that's kind of a broad question. https://wiki.haskell.org/Haskell_in_industry is probably a good starting point
06:45:14 <tdammers> Pranky: generally speaking, I think that asking "what kinds of jobs can I get with it" is the wrong mindset though (not just for Haskell, but for any specific tech)
06:45:19 <Pranky> :tdammers Thanks :)
06:45:27 <Ferdirand> tdammers++
06:45:49 <Pranky> tdammers: So, what mind set should I adopt?
06:46:52 <Pranky> tdammers: I am generally interested in biotech and AI related things
06:47:00 <tdammers> Pranky: in order to get a good programming job, you need to develop the right skills - communication, problem solving, critical thinking, deep understanding of programming concepts, and the ability to pick up new stuff as needed and as you go
06:47:22 <tdammers> if you're interested in bio tech, studying those areas a bit won't hurt eithe
06:49:35 <tdammers> you see, teaching a good programmer a new programming language is easy - it takes 4-8 weeks, and the outcome is predictable. but take someone who has memorized all the rules of a programming language, but sucks at understanding programming concepts or human communication, and try to teach them good programming habits, and you're in for a nasty surprise
06:50:03 <Pranky> tdammers: I have experience at competitive programming, some OO stuff, (build a Super Mario lvl in Python using PyGame, built a small platform game game in Java (Really basic)), did some really basic stuff in Octave ML related. Do you have any suggestions what could I pick up to grow as a developer over the summer?
06:50:46 <Pranky> Though about doing Java mostly as it's pretty demanding at my Uni
06:51:26 <fendor> @karma+ tdammers
06:51:26 <lambdabot> tdammers's karma raised to 17.
06:53:13 <tdammers> Pranky: I'd highly recommend learning some Haskell then - your brain is going to hurt, but in a good way. I'd also recommend C, ideally on some *nix platfom.
06:54:06 <tdammers> I'll have to warn you though; Haskell isn't something that you pick up in a month and get immediate rewards. It takes most people a lot longer to master the language and its ecosystem to a degree where they're comfortable doing anything in it
06:54:34 <Pranky> tdammers: I kinda know C, I've read K&R, implemented a lot of algorithms in C, it was used as a main language for courses on the first year
06:55:04 <Pranky> The thing I am interested in, how quickly can I transition from Haskell to Java
06:58:05 <quchen> The most important lession you learn doing Haskell and that’s immeasurably useful in all other languages is that avoiding state is not only useful, but also feasible.
06:58:15 <maerwald> transition from haskell to java, what?
06:58:54 <Pranky> maerwald: Yeah, I know. It's weird and doesn't make much sense
07:01:35 <maerwald> Pranky: not many haskell jobs there and it's not very popular in AI
07:01:41 <maerwald> if those things matter to you, stick to python or so
07:02:03 <maerwald> if you like programming languages and challenge your way of thinking, then do haskell
07:02:33 * dstolfa likes haskell
07:02:37 <pavonia> Pranky: If you are already familiar mostly with imperative programming languages (like C and Java), it's very useful to start learning a purely functional language like Haskell
07:02:41 * dstolfa wishes it had a better ecosystem :(
07:02:59 <Rembane> dstolfa: What do you miss?
07:03:12 <tdammers> quchen: mutable state, that is
07:03:14 <maerwald> let's start with a standard library that makes sense
07:03:58 <tdammers> maerwald: you mean like Python? or C? or PHP? or Java? or C++?
07:04:04 <maerwald> ;)
07:04:28 <dmwit> fendor: I don't understand your objection yet.
07:04:31 <dstolfa> Rembane: tooling around the language that doesn't end up in dep hells and breakages on almost every update of a reasonably large codebase :/
07:04:37 <dstolfa> Rembane: i can live with the stdlib
07:04:42 <dmwit> fendor: Can you give a few examples of command lines you would like to accept, and command lines you'd like to reject?
07:05:01 <maerwald> almost all tooling is broken :>
07:05:07 <Rembane> dstolfa: That's reasonable. Very reasonable.
07:05:08 <maerwald> syntax highlighting works though
07:05:09 <dmwit> fendor: (...that don't match up with what `argument` does, I mean.)
07:07:12 <Pranky> As I got it from you guys, Haskell should help me expand my way of thinking and it has it's use in AI world? I should do if mostly for fun and a challenge and not expect an easy job?
07:07:32 <maerwald> don't do it for jobs
07:08:07 <maerwald> I'm not aware that it's popular anywhere in AI
07:08:34 <maerwald> python and C++ is
07:08:46 <dstolfa> i'm not aware of anything other than python for ML
07:09:31 <Pranky> Ok, thanks guys
07:09:32 <Pranky> :)
07:10:52 <dstolfa> Rembane: FWIW, tooling-wise, it's an annoyance to me because i want to do things in haskell when i can choose the language @work, but i can't justify using it to anyone because nobody wants to maintain it due to tooling. i basically have to resort to doing it in ocaml because opam rarely ever breaks anything (at least not any more than anything in pip does)
07:10:59 <tdammers> don't do any language for jobs, but especially not haskell
07:11:13 <dstolfa> i'm personally fine with resolving it, but the moment i mention haskell i get angry looks due to nobody wanting to maintain it
07:11:21 <tdammers> there are haskell jobs, but it's a tiny market, and the odds of one of those jobs coming your way when you need it to are very small
07:11:29 <Rembane> dstolfa: Oh. That's legit. But if you never change anything Haskell is superstable
07:12:44 <tdammers> dstolfa: haskell tooling is currently sitting in a vicious circle that essentially locks it into the segment of companies fully committing to using Haskell as their main platform
07:12:48 <quchen> tdammers: So you’re at WT just incidentially? :-D
07:13:02 <tdammers> quchen: "incidentally", hehe... but yes
07:13:22 <tdammers> quchen: that is, I work for WT and intend to keep it that way
07:13:31 <quchen> You’re still in Israel though right?
07:13:39 <tdammers> never been.
07:13:43 <tdammers> Netherlands
07:13:53 <tdammers> also intend to keep it that way
07:13:55 <quchen> Huh? I thought you used to work in Israel.
07:14:06 <dstolfa> tdammers: hrm. i wish i had time to contribute to either cabal or stack, just to fix some of the issues that i've been hitting :(
07:14:14 <quchen> Come to think of it, I also remember you saying you »permanently emmigrated from Germany«.
07:14:20 <quchen> …to the Netherlands
07:14:23 <tdammers> yep
07:14:54 <quicksilver> dstolfa: I feel your pain but if you do things the simple way (just cabal install some packages) then it doesn't really need any maintenance
07:15:17 <quicksilver> dstolfa: once you have a vareity of different haskell installations with overlapping dependency trees then that is a pain
07:15:27 <quicksilver> but just a quick haskell solution to a quick haskell problem is ok()
07:15:40 <dstolfa> tdammers: what we're dealing with is a legacy C codebase that's enormous and people really don't want to change because it's a part of an operating system. what i would really like is all of our userspace components to be in haskell (or some functional language at least) and link against those libraries via bindings
07:15:42 <tdammers> yeah, especially if you make somewhat conservative choices
07:16:07 <maerwald> systems programming in haskell, ugh
07:16:08 <tdammers> dstolfa: that'd be a massive project though, no? and no immediate payoff. that's a very very hard sell to make.
07:16:25 <dstolfa> tdammers: well, we're writing new components so whenever possible i'm writing those in !C
07:16:31 <tdammers> dstolfa: if you can come up with a *new* thing written in haskell that would immediately reduce existing pain, then you'd probably have much better chances
07:16:43 <dstolfa> the old components are being changed if possible, and if it requires a substantial rewrite then it's just from scratch and there i argue we should do it in haskell
07:16:49 <dstolfa> but we end up doing it in ocaml because people give me angry looks :(
07:17:03 <tdammers> but in order to justify introducing an entirely new language into your codebase, the benefit has to be truly massive
07:17:23 <merijn> dstolfa: Write it in Haskell and claim it's "just a fancy meta-ocaml DSL"
07:17:24 <maerwald> haskell only really pays off when you either refactor a lot, or have a very fast-paced feature implementation workflow
07:17:30 <tdammers> also, I suspect that for systems programming, ocaml might actually be the better choice
07:17:41 <dstolfa> tdammers: is the benefit of replacing a giant C codebase for a relatively complicated compiler that requires exploration of all allowable behaviours for something in haskell/ocaml not a good justification? :)
07:17:42 <quchen> Or when you do any maintenance on your code.
07:17:48 <maerwald> that's too broad
07:18:09 <maerwald> I would be comfortable enough in rust too or some other lang that doesn't suck
07:18:21 <dstolfa> tdammers: i just like not having side-effects in functions by default
07:18:28 <dstolfa> monadic interfaces are great
07:18:30 <tdammers> dstolfa: the problem with replacing existing, working production software is that the benefit is neither immediate nor predictable, while the cost is very real and also somewhat unpredictable
07:18:37 <maerwald> dstolfa: weird, I never liked them
07:19:18 <dstolfa> tdammers: agreed, we don't replace those
07:19:25 <dstolfa> tdammers: just things that require a rewrite to make sense at all
07:19:32 <dstolfa> anyway, brb! :)
07:22:49 <maerwald> monadic interfaces are mostly annoying, because they are not declarative but rather object-oriented
07:23:53 <tdammers> FSVO "object-oriented"
07:24:31 <maerwald> sure, java people actually feel very comfortable designing and using them
07:24:35 <maerwald> because they feel familiar
07:24:42 <maerwald> stuff a lot of crap into one thing and make an API
07:24:46 <tdammers> > [1,2,3] >>= (\n -> replicate n n)
07:24:48 <lambdabot>  [1,2,2,3,3,3]
07:25:03 <noipmups> Which PostreSQL library is best for a small to medium sized project (opaleye, selda, …)?
07:25:25 <maerwald> then once you want to change that API, everything is broken :>
07:25:29 <maerwald> API-lock.
07:25:50 <tdammers> maerwald: that has absolutely nothing to do with the Monad interface
07:25:57 <maerwald> monadic
07:26:12 <tdammers> monadic = involves Monad
07:26:15 <maerwald> yes
07:26:25 <maerwald> monadic interface != monad interface
07:26:41 <tdammers> a monadic interface = an interface that involves the Monad interface
07:26:46 <maerwald> sure
07:27:15 <maerwald> I'm pretty sure dstolfa wasn't just talking about using the monad instance of lists, lol
07:27:45 <tdammers> my point being, I don't see how the fact that an interface happens to follow monadic patterns automatically leads to cruft or baroque degrees of coupling
07:28:02 <maerwald> that's my experience with most of the ecosystem
07:28:32 <maerwald> it's not bad, it's a design space, but I don't really like it
07:28:46 <tdammers> IME a much more popular source of annoyance comes from not being able to agree on a shared type for shared things between libraries
07:29:03 <maerwald> or even agree on how to model effects, yes
07:29:46 <maerwald> or people being funny with expressivity and abusing every possible ghc extension to do something you could have done with... just... functions :>
07:30:11 <maerwald> naah, must be type-level computation!
07:30:20 <tdammers> e.g., you may have a geodetic-calculations library that defines a Coordinates type (for map projections), and a graphics rendering library that also defines a Coordinates type, and both might be able to express "coordinates in a flat 2D space measured in metric units", but they'll both insist on defining their own, incompatible, types, so you end up marshalling between the two worlds as if you didn't have
07:30:22 <tdammers> anything better to do
07:30:42 <shapr> I enjoy writing Haskell, and I enjoy the monad interface.
07:30:55 <shapr> it's a nifty design space
07:30:57 <tdammers> the type level stuff is, well, a matter of taste, and we're only human and thus prone to going overboard on what seems like a good idea at the time
07:31:11 <tdammers> but it's definitely not without merits
07:31:18 <shapr> Yeah, I enjoy over-using a new feature or tool so I can find the edges, where it's good and where it's not.
07:31:27 <maerwald> tdammers: I think haskellers usually tend to abuse expressivity more than in other language communities
07:31:34 <maerwald> and care less about KISS
07:31:39 <tdammers> also keep in mind that there's a bit of an observation bias
07:31:46 <shapr> yeah, I want citations
07:32:22 <tdammers> those fancy extensions are very visible, but when it comes to production use, I'm pretty sure the average Haskell codebase is a lot more conservative and closer to straight-up Haskell2010
07:32:55 <maerwald> not sure about that
07:33:23 <tdammers> well, most of the production code I've seen so far is pretty much like that
07:33:50 <tdammers> much of the stuff that uses 20 fancy language extensions is highly experimental
07:39:05 <shapr> maerwald: do a survey of hackage libraries and github repos?
07:39:14 <maerwald> I mean... why would you write a web framework using type families, *sigh*
07:39:45 <shapr> maerwald: I look forward to your statistical analysis
07:39:49 <maerwald> ?
07:40:56 <merijn> Why would you *not* use type families in a web framework?
07:41:38 <dmwit> If you think users of other languages are shy about using compiler features, then may I point you at boost?
07:41:43 <maerwald> because type families are extremely expressive, can be hard to grasp for beginners, can cause odd compile failures, ...
07:41:48 <shapr> maerwald: I figured the way to support your statement that Haskellers tend to abuse expressivity is to first define abuse, and then look for those patterns in hackage and big Haskell repos
07:42:03 <dmwit> Or, like, the myriad projects that poke every gcc pragma and annotation possible.
07:42:04 <maerwald> shapr: I don't care
07:42:12 <shapr> maerwald: oh, well why make the statement then?
07:42:12 <maerwald> I'm not writing a thesis about it
07:42:19 <maerwald> why not?
07:42:39 <shapr> because this channel is for teaching Haskell and having a positive community around Haskell?
07:42:45 <maerwald> ???
07:42:49 <shapr> really it is!
07:42:58 <maerwald> I have no idea what you are implying
07:43:16 <shapr> maerwald: I'm saying if you see a problem, it helps to quantify the problem and describe how it could be solved
07:43:19 <maerwald> I didn't claim correctness or that I have data about anything, it's just my experience/feeling
07:43:31 <maerwald> shapr: I don't think it helps
07:43:38 <maerwald> and I don't have the time for that either
07:43:39 <shapr> what does help?
07:43:47 <maerwald> talking about it, gaterhing opinions
07:44:10 <shapr> I'm just not a fan of unsubstantiated opinion statements, I'd rather understand why and how.
07:44:29 <maerwald> well, culture is not about numbers
07:44:54 <Taneb> I don't think that a web framework needs to be easy to understand how it was implemented to be easy to use
07:45:07 <maerwald> Taneb: as long as you don't get compile failure :>
07:45:24 <maerwald> then something odd shines through the compile and winks "hey"
07:45:34 <Taneb> I vastly prefer a mysterious compile error to a mysterious runtime error
07:45:38 <maerwald> and you spend 90 minutes trying to figure out what has happened
07:45:47 <Taneb> And I've heard rails was a big success in its day
07:45:59 <tdammers> maerwald: it's a multi-faceted decision. type families are more expressive, allow for abstractions and generalizations that can't be had without them (or a comparable mechanism), and can make code cleaner for it. they also add to the learning curve, make for surprising compiler errors, and scare away beginners. So among other things, as a library author you have to consider you target audience.
07:46:28 <maerwald> tdammers: I don't know a single reason why I would pick servant over any other web framework, seriously
07:47:15 <Taneb> Does servant use type families? I think it uses every extension other than type families
07:47:21 <alp> it does
07:47:41 <Taneb> Oh, so it does
07:47:41 <alp> that's what makes some types variables depending on what's found in API descriptions
07:47:45 <Taneb> Been a while since I've used it
07:48:26 <maerwald> to me it just looks like an exercise "it can be done"
07:48:51 <Taneb> Wasn't there a blog post the other day about why servant is like it is?
07:49:00 <maerwald> does a framework like Snap really lack something fundamental that servant gibes me?
07:49:40 <Taneb> https://haskell-servant.github.io/posts/2018-07-12-servant-dsl-typelevel.html
07:49:41 <alp> maerwald, yes. I've written a post that explains why we went for that design with the type-level craziness, and why that was necessary given the requirements we had
07:49:47 <alp> right, this post ^^^
07:50:58 <maerwald> alp: cool, I'll check that out
07:52:12 <alp> and servant devs or users don't pretend that it's the ultimate solution to everything. it has some very nice properties/features that no other framework has, some problematic aspects (e.g the occasional incredibly ugly errors), it's just one point in the design space.
07:55:03 <revskill> i love servant very much, it has generator for clients so that client code has no boilerplate
07:55:44 <Taneb> (the elm generator doesn't like me using sum types :( )
07:56:09 <revskill> i'm using ghcjs client, it works like a charm, no more boilerplate
07:56:15 <revskill> it's actually a piece of art
08:01:32 <dstolfa> maerwald: i'm referring to using monadic interfaces to split up parts of the language, not necessarily shoving everything into it :)
08:02:42 <dstolfa> maerwald: i don't think it's a good idea to make everything monadic because it basically ends up being convoluted unnecessarily. however, those things that obviously have side-effects or are small DSLs for a specific purpose, it makes sense to build a monadic interface for them
08:07:06 <romanix> to the users of Accelerate (http://hackage.haskell.org/package/accelerate): What are typical speedups you get when moving your computations to the GPU? At the moment I'm getting about 5x, which is great but the CUDA documentation mentions the possibility of achieving 1-2 orders of magnitude speedups which certainly raised my expectations :)
08:07:33 <Taneb> romanix: it generally depends on both the problem and your GPU
08:08:16 <Athas> romanix: 5x is decent if you are comparing to a highly tuned and parallelised CPU implementation.
08:10:43 <romanix> Athas, neither implementation is highly tuned and the CPU version is sequential :) I didn't get any meaningful speedups on the CPUs alone using parallel strategies.
08:12:14 <romanix> I was just wondering how much overhead Accelerate itself adds compared to plain C-based CUDA code
08:13:04 <Athas> romanix: in the best case, very little.  But Accelerate is easy to misuse, such that it spends all its time either recompiling trivial variations on the GPU kernels (by replacing constants, say), or generates gigantic kernels with everything unrolled.
08:13:45 <Athas> But if you make Accelerate generate decent kernels, and they run for a decent amount of time (dozens of milliseconds, and ideally several times), then Accelerate has very little overhead that I've noticed.
08:16:21 <romanix> Athas, what tools do you use for optimisation? I know Accelerate has a bunch of +ACC flags. Also found nvvp (nice graphs) and nvprof.
08:18:54 <habbah> > let y = 2 in x = 2y + 3y
08:18:56 <lambdabot>  <hint>:1:16: error:
08:18:56 <lambdabot>      parse error on input ‘=’
08:18:56 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
08:20:35 <Athas> romanix: I don't use Accelerate much for writing my own code, to be honest.  When I have to investigate its performance, I usually to it by comparing it to other (GPU) implementations of the same program, and inspecting the kernels that it generates.  I don't remember how to make it dump the latter, though.
08:20:49 <dmwit> > let y = 2 in 2*y + 3*y
08:20:51 <lambdabot>  10
08:21:03 <Athas> Also, that might have been a bit easier with the old CUDA backend, which generated human-readable C instead of LLVM bitcode.
08:21:04 <dmwit> > let y=2; x = 2*y+3*y in x
08:21:07 <lambdabot>  10
08:21:54 <habbah> main = do { let y = 2; let x = 3y + 2y; in print x}
08:22:18 <habbah> parse error on input ‘in’
08:22:46 <habbah> i didn't type it like that though. it was on separate lines (not sure how to type it on a single line)
08:22:51 <the_2nd> Is there some sort of dynamic cast in Haskell? E.g. I have a function working for Eq, but within that I might want to do something else if also Show
08:23:17 <romanix> Athas, thanks for the tips! I'll check if it's still possible to dump C kernels somehow.
08:26:11 <habbah> thank you dmwit. that will work
08:27:14 <habbah> oh it works for lambdabot, not in ghci
08:27:58 <habbah> let y = 2; x = 2y + 3 in x results in "could not deduce (Num t0) from the context...bound by the inferred type for x
08:28:14 <Athas> romanix: what kind of programs are you looking to write with Accelerate?
08:28:45 <machined1od> Fingers crossed. We'll see
08:29:07 <habbah> oh right! i need a multiplication operator
08:31:23 <romanix> Athas, natural language processing (document similarity)
08:31:38 <dmwit> habbah: In do blocks, there is a special let form that does not require in.
08:32:28 <dmwit> habbah: So if you want the style you wrote first there, it would be `main = do { let { y = 2; x = 3*y + 2*y }; print x }` or `do { let { y = 2 }; let { x = 3*y + 2*y }; print x }`.
08:32:49 <Athas> romanix: cool.  Is that really amenable to array programming?
08:36:01 <dminuoso> Hi. Is there some idiom to do `Foo <$> b <*> c <*> d ...` with named fields?
08:36:19 <glguy> RecordWildCards and ApplicativeDo
08:36:29 <dmwit> habbah: As usual, you can use layout rather than explicit braces and semicolons, as in https://pastebin.com/YWU8FuBx
08:37:57 <inkbottle> :t \c i -> do {if [c] == show i then Just i else Nothing} -- What the purpose of do-keyword here? [https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus#Example:_parallel_parsing]
08:37:58 <lambdabot> Show a => Char -> a -> Maybe a
08:38:02 <inkbottle> :t \c i -> if [c] == show i then Just i else Nothing
08:38:03 <lambdabot> Show a => Char -> a -> Maybe a
08:38:13 <SrPx> Is there a stack command to just run Main.hs (with runghc)?
08:38:31 <romanix> Athas, it has been pretty easy so far. I've been using dense vectors/arrays so far though. Ideally I'd like to use sparse ones so we'll see how that goes in terms of complexity/performance.
08:40:31 <Athas> romanix: complexity will go up and performance will go down.  Sparse structures are a really nasty case for functional array programming.
08:41:20 <inkbottle> SrPx: stack exec executable-name -- (?)
08:41:52 <inkbottle> with executable name defined in the stack cabale file
08:42:36 <SrPx> inkbottle that requires a build before, no? That's quite slow, I wonder if it could just use runhaskell
08:43:46 <inkbottle> yes; and no clues for the second part
08:45:24 <tdammers> maerwald: servant is not really a "web framework"
08:45:51 <tdammers> maerwald: the idea is that the types are the API definition, and everything else is derived from that - the actual API, but also clients
08:47:17 <tdammers> maerwald: if you want this kind of "single source of truth", then the only alternatives are a) TemplateHaskell (a la Yesod), b) generating things at runtime, and thus giving up a certain level of type safety, c) code generators
08:50:43 <noipmups> Which PostreSQL library do you recommend for a small to medium sized project (opaleye, selda, …)?
08:51:25 <nai> hi, i don't understand the following type:  xmonad :: (LayoutClass l Window, Read (l Window)) => XConfig l -> IO ()
08:51:50 <nai> what is "l" ? it seems to be a type constructor from the "LayoutClass l Window", but then it's used as a type (i think) in "XConfig l"
08:51:59 <glguy> l is a type variable
08:52:10 <glguy> You can tell it's a variable and not a constructor because it's lowercased
08:52:15 <nai> right
08:52:26 <nai> so i don't understand "LayoutClass l Window"
08:52:30 <glguy> You can also tell it has kind * -> * the way its being used in Read
08:52:49 <glguy> LayoutClass is a "multi-parameter" type class
08:52:53 <nai> wait. i thought type variables had kind * and type constructors had more complex kinds
08:53:05 <glguy> no
08:53:06 <nai> aaah makes sense
08:53:12 <glguy> variable/constructor has nothing to do with kinds
08:54:09 <glguy> Here's the declaration of LayoutClass: https://github.com/xmonad/xmonad/blob/1b17d1c3781f882e8346acd4a3291a5cd632f4be/src/XMonad/Core.hs#L256
08:54:42 <glguy> It expects a type with kind * -> * and then one with kind *
08:54:59 <the_2nd> Is there some sort of dynamic cast in Haskell? E.g. I have a function working for Eq, but within that I might want to do something else if also Show
08:55:14 <nai> i don't understand how a type can have kind * -> *. do you have a common example for this?
08:55:17 <glguy> the_2nd: Not really, no.
08:55:30 <glguy> Maybe :: * -> *   ;   Either Int :: * -> *
08:55:41 <glguy> [] :: * -> *  -- the type constructor for lists
08:55:45 <nai> but Maybe is a type constructor
08:55:46 <glguy> those are all types that have that kind
08:55:47 <nai> right ?
08:55:54 <glguy> Yeah, but only because it is capitalized
08:56:04 <glguy> type constructors make takes
08:56:06 <glguy> types*
08:56:17 <glguy> typse have kinds
08:56:45 <glguy> If we had: data T f = MkT (f Int)  --   f is a type variable, it has kind * -> *
08:57:03 <glguy> We could apply T to the type    (Either Int):   T (Either Int)
08:57:37 <glguy> constructors are the capitalized names that are globally in scope when we write type signatures, they are things we can pattern match on in instance heads
08:57:46 <nai> ok, i think i get it
08:57:47 <glguy> variables are the lowercased things that are local to each type signature
08:58:27 <glguy> totally separately types have kinds. Some of those types are variables to be specified later, and some are constructors and are known now
08:58:40 <glguy> and some are expressions built up from variables and constructors
08:59:05 <nai> ok, i get the original declaration now
08:59:08 <nai> thanks
08:59:13 <glguy> yw :)
08:59:56 <nai> btw, how are these statements called?  foo :: bar
09:00:47 <glguy> That's a type signature declaration
09:00:57 <glguy> unless you mean it as an expression
09:01:00 <Athas> Oh no, one of my dependencies does not work with GHC 8.6, and it uses Darcs and has not been updated sine 2016.
09:01:39 <maerwald> "and it uses Darcs" :> what's wrong with that!
09:01:42 <nai> ok, thanks
09:01:49 <nai> it can't be an expression, can it?
09:01:56 <nai> i mean, :: isn't an operator
09:02:03 <glguy> Right, it's part of the syntax
09:02:14 <Athas> maerwald: it's more awkward.
09:02:37 <Athas> Instead of making a Github pull request I have to format a patch and send it off to the maintainers email address (which I hope is still active).
09:02:59 <maerwald> Github...
09:03:28 <maerwald> git was invented to be useful for more than one way of contributing
09:03:41 <maerwald> and darcs can be used similarly!
09:04:24 <Athas> Sure.  It's just that for drive-by patches that fix small things, Github provides the smoothest experience I've seen.
09:06:05 <Athas> Where are the sources to the GHC manpage?
09:06:47 <Athas> Oh, DPH finally got put out of its misery.
09:06:55 <Athas> That must be why vector-algorithms doesn't build with 8.6.
09:07:11 <maerwald> Athas: really? 1. click fork, 2. clone, 3. create branch, 4. do fix, 5. commit, 6. push branch to remote, 7. open github, 8. create a pull request
09:07:39 <Athas> Yes, really.
09:08:09 <maerwald> have seen more convenient workflows: 1. clone, 2. do fix, 3. commit, 4. git-am
09:08:25 <maerwald> err, send-email
09:08:34 <maerwald> which is half of the steps!
09:08:36 <Athas> That email is not visible to the community, though.
09:08:49 <Athas> With pull requests, I can just check the repository and see if someone has already submitted a fix.
09:08:56 <Athas> Sadly, this maintainer does not give me access to his private mailbox.
09:09:13 <maerwald> disappointing
09:12:08 <nilof> Question: what is the idiomatic way to describe an abstract data type in Haskell?
09:12:44 <nilof> if I want to write a generic implementation of various type classes for all instances of the abstract data type
09:13:40 <nilof> In OOP languages I would use inheritance, in ML dialects I would use module functors
09:13:59 <nilof> is there something equivalent in Haskell?
09:14:18 <Athas> Type classes can work, but they are not exactly the same.
09:17:00 <nilof> Yeah, I remember trying to make a heap typeclass and trying to implement monofoldable on it, but getting stuck because of restrictions to prevent orphan instances
09:18:07 <nilof> iirc
09:19:35 <ddellaco_> nilof: I'm not super familiar with them but in Haskell I believe backpack fulfills a similar niche to ML-style functors, may be worth a look: https://ghc.haskell.org/trac/ghc/wiki/Backpack
09:19:37 <nilof> I could write a generic implementation of a fold function, but I still needed to implement the monofoldable typeclass for each instance of heap
09:40:45 <greymalkin> Is there a good (recent) documentation of how to set up emacs so that it can run the repl shell on a cabal configuration including library AND application?
09:41:28 <greymalkin> I'm now building the application regularly, and don't like having to keep dropping back to a shell to run `cabal configure -flibrary-only` and then build the application with `cabal configure && cabal build`
09:43:51 <dyl> greymalkin try spacemacs?
09:44:10 <dyl> Oh, I misunderstood.
09:44:17 <dyl> You could probably script that and rebind it.
09:45:12 <dminuoso> glguy: Ah so Id just do the following? do { field1 <- a; field2 <- b; ... }; Foo {..}
09:45:41 <glguy> close, you'll have: do field1 <- a; field2 <- b; pure Foo{..}
09:46:03 <dminuoso> Oh right. That'll work thank you.
09:52:50 <nilof> huh, backpack seems interesting
09:57:55 <bmcnns> I'm getting an error message, Ambiguous type variable ‘a0’ arising from a use of ‘print’"
09:58:15 <bmcnns> I believe it's because the compiler doesn't know what type my variable is
09:58:20 <nshepperd_> nilof: just implement monofoldable for each type
09:58:24 <bmcnns> but I don't know how to explicitly declare a type yet.
09:58:40 <bmcnns> collatz n = if even n then n / 2 else 3 * n + 1
09:58:43 <bmcnns> That's the line causing the issue.
09:58:55 <f-a> bmcnns: add a signature
09:59:03 <c_wraith> there's no print on that line.
09:59:08 <f-a> collatz :: Integer -> Bool
09:59:23 <c_wraith> f-a, that's not the type..
09:59:38 <f-a> sorry
09:59:43 <f-a> add the proper signature then
10:00:07 <bmcnns> It should look like this ? collatz :: Integer n = if even n then n / 2 else 3 * n + 1
10:00:14 <c_wraith> bmcnns, if the type in question was able to default, you'd only be getting a warning for that.
10:00:22 <nshepperd_> bmcnns: you can't use / on integers
10:00:46 <bmcnns> right on. So I should use float
10:00:54 <bmcnns> Maybe double just in case.
10:01:23 <bmcnns>  
10:01:39 <f-a> bmcnns: or use `quot`
10:01:40 <pavonia> Replacing (/) by div would be a better fix, IMHO
10:01:41 <f-a> :t quot
10:01:42 <lambdabot> Integral a => a -> a -> a
10:01:44 <nshepperd_> Nno..
10:02:37 <bmcnns> Right on guys, got it working. Thank you!
10:03:05 <nilof> nshepperd  yeah, well, the point of my question was whether haskell had a sufficient ability to capture abstractions so that I don't have to do that, and having modules would have solved that
10:05:10 <nilof> or code generation, etc etc
10:05:18 <nshepperd_> nilof: well, you can wrap all your different heap types in a newtype, and give the generic instance for that newtype
10:05:42 <nilof> ah
10:05:48 <nilof> that's actually pretty interesting
10:06:43 <nilof> I can implement heap on the newtype as well
10:09:59 <nilof> or well, implementing heap would mean using GADT's, but that's not too bad
10:12:50 <nshepperd_> It shouldn't need anything special
10:13:24 <andromeda-galaxy> I was playing with Shake a bit, and I have a command that writes to stdout the contents of two files with
10:13:26 <nshepperd_> Just flexibleinstances so that you can write a heap instance for each wrapped type
10:16:48 <andromeda-galaxy> quite different names. I wanted to use `fileForward` to add a user rule to allow these files to be "built" in much the same way that `Files` does, but working with the fact that they have different names, but it seems that the necessary types to `addUserRule` something that the `File` rules will look at aren't exported. I was wondering if anyone knows of a way to add a user rule to Shake that
10:16:54 <andromeda-galaxy> will be used to resolve FilePath dependencies
10:37:57 <gentauro> github down or is it just me? https://github.com/bos/aeson
10:39:10 <Boomerang> gentauro: It seems down for me too
10:40:38 <cocreature> https://status.github.com/messages
10:40:56 <Boomerang> It took me forever to open the status page :p
10:49:27 <gentauro> typical M$, once they buy something, they let it die (Citrix, Skype and so many others) :'(
10:49:52 <gentauro> Boomerang: I needed to "steal" some source files from there
10:49:53 <gentauro> :D
10:51:56 <cocreature> github has definitely never been done before microsoft bought them
10:53:11 <gentauro> cocreature: been done? :o
10:53:36 <geekosaur> "down"
10:54:15 <cocreature> typing is hard :)
11:00:16 <revskill> Lol, github now has a blue screen of death
11:03:08 <dmwit> gentauro: Hackage has the full source for aeson.
11:03:21 <dmwit> Unless you really need something cutting edge that hasn't been released yet.
11:03:44 <dmwit> e.g. try cabal unpack aeson
11:05:56 <Zipheir`> revskill: Well, it _is_ MS software now...
11:06:30 <dmwit> andromeda-galaxy: `fileForward`?
11:06:40 <dmwit> I don't see that in shake.
11:06:50 <dmwit> `Files`, either.
11:11:42 <gentauro> dmwit: I have limited myself to `stack lts-11.11` so It's a bit difficult to find source specifically on `stackage` (they don't even link to GH)
11:11:54 <gentauro> even though must (if no all) projects are hosted on GH
11:12:22 <gentauro> (I mean, I added the homepgave to gitlab.com in my package.yaml and stack doesn't want to build)
11:12:48 <gentauro> revskill: I was actually seeing the unicorn page
11:12:52 <gentauro> no blue screen for me
11:13:47 <revskill> I did screenshot it . They fixed issue fast
11:14:27 <revskill> https://pbs.twimg.com/media/DiPnpL5V4AEH175.jpg:large
11:15:33 <revskill> hm, github is running on Windows, i guess
11:16:12 <gentauro> revskill: LOOOOOOOOOOOOOOOOOOOL
11:19:08 <revskill> yeah, maybe, somebody gonna restart computer , enter safe mode !
11:21:11 <gentauro> and people laughed at me cos I moved to GitLab, who is laughing now? :D
11:22:49 <revskill> gentauro: Better to pushing to both !
11:24:15 <revskill> The world could be a better place to live without Microsoft. I was born in wrong time. Sad
11:25:05 <shapr> microsoft has done lots of good things for the world
11:25:13 <shapr> They paid for Haskell
11:25:22 <shapr> hoi tromp, how's code?
11:26:48 <revskill> shapr: I don't think so. Their products considered harmful.
11:26:50 <gentauro> revskill: I used that approach before
11:27:14 <gentauro> my master was GitLab and I synced with GitHub. Otherwise my packages for Elm coudn't be used
11:27:18 <shapr> revskill: long years ago, PCs didn't have much in the way of electrical standards, and "being able to run windows" became the standard
11:27:22 <gentauro> but they are pretty f*ed
11:27:27 <Athas> gentauro: Elm only works with GitHub?
11:27:32 <phadej> I remember someone mentionedd that AT&Y has donw lots of good things, as they have Bell Labs...
11:27:33 <gentauro> cos their package manager "depends" on GH
11:27:36 <gentauro> Athas: yes
11:27:44 <shapr> I could also point out the language server protocol, that's a good thing from Microsoft
11:27:54 <shapr> phadej: yeah, many good things came out of bell labs
11:27:56 <gentauro> I found out all my packages are gone from the package manager (they don't even store a copy)
11:28:08 <shapr> Not gonna say everything microsoft does is good for the world at large, but they're also not all bad
11:28:27 <gentauro> shapr: how is your work at MS going?
11:28:37 <shapr> heh, I've never worked at MS, even when given the option
11:28:58 <gentauro> shapr: I was once offered a job at MS Denmark
11:28:58 <phadej> would you work at microsoft research?
11:29:08 <shapr> phadej: that I might do
11:29:13 <shapr> especially if I got to work on GHC
11:29:14 <gentauro> the "manager" said: "Yeah and you will be working +60 hours a week"
11:29:15 <phadej> shapr: see, they are not the same
11:29:19 <shapr> phadej: yeah, true that
11:29:24 <gentauro> and that's when the conversation ended
11:29:31 <shapr> gentauro: good reason to refuse that job
11:29:44 <gentauro> shapr: I mean, I live in Denmark
11:29:52 <gentauro> The most people work is 5 hours a week
11:30:03 <phadej> is it even legal there to ask for 40+?
11:30:09 <gentauro> 37.5 hours/week and most people just use the time talking
11:30:10 <gentauro> :|
11:30:25 <shapr> gentauro: jaså, jag bodde i Sverige, och alla änvandade(?) MS, men jag änvandade linux
11:30:26 <gentauro> phadej: yeah
11:30:52 <gentauro> they can't "force" you do extra hours (has to be enforced by management)
11:31:06 <gentauro> but then all your hours go from 100% -> 150% and 200%
11:31:20 <shapr> I'm also hopeful that microsoft has figured out how to be a more people-beneficial company with the recent changes
11:31:36 <gentauro> the problem in Denmark is that at some point, cos you earn so much, out of every 3 DKK your earn, 2 will go to Taxes
11:31:38 <shapr> anyway, microsoft oriented discussion should move to #haskell-offtopic
11:31:45 <gentauro> so nobody actually wnat to do extra work
11:31:57 <gentauro> shapr: roger that
11:32:02 <shapr> gentauro: thanks :-)
11:32:53 <gentauro> shapr: btw, I guess that you wrote something in Swedish? Cos I don't understand it :D
11:33:02 <shapr> no worries, I can barely understand Danish
11:33:35 <gentauro> shapr: neither can't danes ;)
11:33:39 <shapr> ha!
11:33:42 <gentauro> right Athas?
11:33:43 <shapr> lemmih might disagree
11:34:31 <phadej> fwiw, if aksed for work 60hours a week, I'll go on vacation every third onw
11:34:52 <phadej> like, the work isn't that important (especially if it's not your own business)
11:34:54 * shapr hugs lemmih 
11:35:14 <shapr> lemmih: I hear rumors equality saturation is being considered for lhc?
11:51:07 * hackage IPv6DB 0.3.0 - A RESTful microService for IPv6-related data  http://hackage.haskell.org/package/IPv6DB-0.3.0 (MichelBoucey)
12:05:07 * hackage cabal2nix 2.10.1 - Convert Cabal files into Nix build instructions.  http://hackage.haskell.org/package/cabal2nix-2.10.1 (PeterSimons)
12:10:07 * hackage libnotify 0.2.1 - Bindings to libnotify library  http://hackage.haskell.org/package/libnotify-0.2.1 (MatveyAksenov)
12:13:15 <droplet> Hi all, I'm trying to heap profile but the output profile is just a solid black PINNED throughout. What does this mean?
12:14:31 <cocreature> droplet: my guess would be ByteString
12:14:37 <andromeda-galaxy> dmwit: http://hackage.haskell.org/package/shake-0.16.4/docs/src/Development.Shake.Internal.Rules.File.html
12:14:50 <andromeda-galaxy> The `File` stuff looks to me like how
12:14:57 <droplet> cocreature: I'm not using ByteStrings at all...
12:15:28 <cocreature> droplet: interesting, and you’re sure you’re not using some library that uses ByteString under the hood?
12:16:16 <andromeda-galaxy> *the builtin rule for the "normal" file build targets in Shake, and each %> or whatever adds a user rule that tells it how to build one file. The addUserRule interface is more flexible under the hood & lets you define things like, in this case, that a target is actually produced by a different builtin rule (Development.Shake.Internal.Rules.Files does this), but this interface doesn't seem to be
12:16:22 <andromeda-galaxy> exposed
12:16:47 <cocreature> droplet: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC/Pinned has some info on what pinned actually means.
12:16:52 <droplet> cocreature: Fairly sure, I'm not doing any text/string-like manipulation at all
12:17:09 <cocreature> however, I don’t know any prominent users of pinned bytearrays except for ByteString
12:17:17 <droplet> Oh hold on
12:17:28 <droplet> I'm using JuicyPixels, which might be using ByteStrings to write images
12:17:36 <cocreature> ah yeah that sounds plausible
12:17:38 <reygoch> So, I've decided to use git repo of a package with stack after first using the hackage version, but stack won't download git version it uses the one from hackage.
12:17:53 <reygoch> Do I have to force this change somehow?
12:18:12 <cocreature> reygoch: what do you mean by “I’ve decided”? have you modified the stack.yaml file?
12:18:18 <reygoch> Yes
12:18:30 <cocreature> can you show us the stack.yaml file?
12:18:36 <reygoch> cocreature: sure, just a sec
12:19:09 <droplet> cocreature: I don't really understand what's going on on that link
12:19:39 <cocreature> droplet: basically pinned objects are treated specially by the GC (as described on that page)
12:19:59 <reygoch> cocreature: here it is https://pastebin.com/WqwEghrr
12:20:00 <cocreature> so for some cases, allocating pinned memory can make your application more efficient
12:22:12 <cocreature> reygoch: it’s been a while since I’ve used this myself but I think your syntax might be incorrect. take a look at https://docs.haskellstack.org/en/stable/yaml_configuration/#git-and-mercurial-repos
12:22:47 <cocreature> also you probably want to put this in extra-deps instead of packages but that shouldn’t matter when it comes to whether stack pulls the package from github or not
12:22:59 <droplet> cocreature: I see, thanks
12:23:41 <reygoch> cocreature: hm.. I'll try doing it with extra-deps, but it says in the docs it should work this way too https://docs.haskellstack.org/en/stable/nonstandard_project_init/#using-git-repositories
12:25:37 <reygoch> cocreature: ok, extra-deps was the problem. Thank you!
12:43:31 <kapil___> I liked purescript by example book, I want to learn more, which book I should read?
12:44:18 <tromp> hi shapr! code is slow lately. too many real world distractoiions. including great weather:-)
12:44:44 <tromp> i did put in some code in a hacker news discussion
12:50:12 <tromp> at https://news.ycombinator.com/item?id=17527530
12:55:18 <monoidal> you need parentheses in pair p:q:rest, if q = p + 2 should use ==
12:55:59 <monoidal> oh, you were replying to this, nevermind me
12:57:30 <Zemyla> I kind of wish that there were an Unbox instance for Integers.
12:58:00 <gentauro> tromp: are you the John Tromp, aka BLC? :o
13:11:47 <kapil___> ?book
13:11:47 <lambdabot> Unknown command, try @list
13:12:15 <kapil___> @list
13:12:15 <lambdabot> What module?  Try @listmodules for some ideas.
13:12:58 <kapil___> @listmodules
13:12:58 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
13:12:58 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
13:14:13 <glguy> kapil___: There's not a lambdabot command for books related to the one you read. lambdabot response to private messages if you want to explore its command set!
13:14:48 <kapil___> Thanks
13:15:01 <revskill> I have a render function, how can i make this call : render x :: XML, render x :: JSON,... ?
13:16:28 <shapr> tromp: oh that's cool!
13:18:53 <monoidal> revskill: if I understand you, you'd like class Document a, instance Document XML, instance Document JSON, render :: Document a => String -> a
13:20:16 <revskill> monoidal: How about this call ? render @XLM x
13:20:25 <dmwit> gentauro: According to https://www.stackage.org/lts-11.11 lts 11.11 has aeson-1.2.4.0. So `cabal unpack aeson-1.2.4.0` will get you a copy of the source for the right version.
13:20:57 <monoidal> revskill: Yes, or rely on type inference. that's assuming you have two different types XML and JSON
13:21:25 <revskill> so render x :: XML and render @XML x are the same ?
13:21:42 <revskill> according to your interface
13:22:03 <monoidal> yes
13:22:10 <revskill> interesting.
13:22:32 <monoidal> like read 2 :: Int and read @Int 2
13:22:37 * hackage zmidi-core 0.9.0 - Read and write MIDI files.  http://hackage.haskell.org/package/zmidi-core-0.9.0 (StephenTetley)
13:22:45 <monoidal> read "2" :: Int and read @Int "2"
13:23:35 <revskill> in my case, i have custom data type
13:23:57 <revskill> So it should be render :: MyType -> a
13:24:05 <revskill> instead of render :: String -> a
13:24:50 <monoidal> yes
13:24:57 <monoidal> with a constraint on a
13:26:28 <dmwit> Why is it important that your conversions to JSON and XML be named the same thing?
13:27:00 <revskill> my composition is that: (render @ByteString) . (render @XML) . parse $ input
13:27:50 <glguy> (renderByteString . renderXML . parse) input
13:27:51 <revskill> dmwit: Why naming differently when they're doing the same thing ?
13:27:52 <dmwit> Why is that better than renderByteString . renderXML . parse $ input?
13:28:00 <dmwit> But they are not doing the same thing.
13:28:07 * hackage hpack 0.29.5 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.29.5 (SimonHengel)
13:28:39 <dmwit> As for "why name them differently": because there is less boilerplate that way. You won't need an extra class declaration plus extra instance declarations.
13:28:55 <tromp> gentauro: yeah, that's me
13:30:16 <revskill> dmwit: So, in which case should we use TypeApplications ?
13:31:54 <dmwit> Type classes are great when there is some small collection of operations that are shared between many types, and some interesting larger operations that can be written in terms of the small ones.
13:32:32 <dmwit> If there is just one large operation, it's much less compelling.
13:33:20 <dmwit> TypeApplications is another thing. I'm not objecting to TypeApplications at all.
13:35:07 * hackage hspec-core 2.5.5 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.5.5 (SimonHengel)
13:36:07 * hackage hspec 2.5.5, hspec-discover 2.5.5 (SimonHengel): https://qbin.io/niger-friday-nexj
13:56:08 <chessandgo> im going to write a simple parser for a simple grammer, ive seen monads, arrows, and even applactives recommended. Should I go with monads (as any monad can be turned into an arrow) or start with arrow
13:58:26 <revskill> I think it depends on grammar. In most cases i found Applicatives are easier to use and reason about
13:58:45 <geekosaur> applicatives are probably the right starting place. arrows were an early cut at applicative, and while monads are useul for some kinds of grammars, applicatives tend to be more general and a better fit
13:59:00 <geekosaur> (well. arrows were more than that, but applicative grew out of arrow)
13:59:16 <geekosaur> *are useful for
13:59:31 <chessandgo> arent applicatives more restricted than arrows? I thought arrows where a new development
14:00:39 <geekosaur> no, arrows are fairly old. and turned out to be fairly limited; but they had Profucntor and Applicative embedded in a sense, and those were eventually untangled from Arrow
14:01:37 * hackage hpack-dhall 0.3.0 - Dhall support for Hpack  http://hackage.haskell.org/package/hpack-dhall-0.3.0 (SimonHengel)
14:02:20 <chessandgo> should arrows just be avoided then? I had my eyes set on them as a new advanced abstraction to understand
14:02:48 <geekosaur> they have their place. it's just that, every time you find a potential new use for them, you discover their limitations
14:03:12 <geekosaur> and udsually it turns out that the pattern you were really after was either Profunctor or Applicative
14:03:33 <geekosaur> that said, arrowized FRP is one of the cleaner approaches
14:04:02 <geekosaur> (functional reactive programming, aka declarative user interfaces)
14:04:23 <revskill> you mean excel ?
14:04:37 <chessandgo> is FRP used anywhere, native FP GUI haskell libraries arent very abundent
14:05:45 <revskill> chessandgo: which GUI library do you recommend to use ?
14:06:15 <geekosaur> well, it's an ongoing research subject. there's no Gtk or Qt equivalent in that area yet, but it does get use and it does have advantages over more procedural varieties
14:07:06 <geekosaur> hm, where's Cale when you need them? ( https://github.com/reflex-frp/reflex-platform/ )
14:07:57 <chessandgo> I have the freedom of having no existing GUI codebase, so if theres any decent FRP GUI libraries id be more ethan happy to use them
14:08:22 <chessandgo> any recommendations?
14:09:59 <revskill> I found Gloss is compilable
14:10:17 <revskill> not even know if things work or not
14:10:25 <revskill> other libraries can't get compiled at all
14:11:20 <chessandgo> well, that certainly makes my choice obvious
14:26:08 <yasar> https://projecteuler.net/problem=1 -> sum [x | x <- [1..1000], (x `mod` 3 == 0 || x `mod` 5 == 0)]
14:26:31 <yasar> My haskell version gives different result than my python version
14:26:41 <yasar> is this solution correct?
14:26:46 <glguy> no
14:27:07 <glguy> > [1..5]
14:27:09 <lambdabot>  [1,2,3,4,5]
14:27:12 <glguy> Find the sum of all the multiples of 3 or 5 below 1000.
14:27:20 <yasar> ohh
14:27:39 <yasar> I didn't realize haskell included both ends
14:40:44 <tdammers> also, for fun, look up Gauss' solution
14:40:48 <glguy> > let sum1To n = n*(n+1)`div`2; sumMultiples k n = k * sum1To (n`div`k) in (sumMultiples 3 + sumMultiples 5 - sumMultiples 15) 99
14:40:50 <lambdabot>  2318
14:44:26 <iqubic> Why don't we want to add in multiples of 15?
14:45:37 <glguy> The multiples of 15 are over-represented. They are accounted for in both the sum of the multiples of 3 and the multiples of 5
14:47:38 <typetetris> iqubic: inclusion - exclusion principle
14:48:05 <tdammers> let st t = let h = t `div` 2 in h * (t + 1) + (t `mod` 2) * h in let stm s t = s * (st (t `div` s)) in stm 3 1000 + stm 5 1000 - stm 15 1000
14:48:09 <tdammers> > let st t = let h = t `div` 2 in h * (t + 1) + (t `mod` 2) * h in let stm s t = s * (st (t `div` s)) in stm 3 1000 + stm 5 1000 - stm 15 1000
14:48:11 <lambdabot>  234165
14:50:35 <glguy> tdammers: That doesn't get the correct answer to the original question (even when 1000 is replaced with 999). Is it supposed to be computing something else?
14:53:13 <elvishjerricco> Anyone familiar with `vinyl`? I'm trying to make a `GCompare` instance for this `Union` type, but I have no idea how to do it:
14:53:13 <elvishjerricco> newtype Flap a f = Flap (f a)
14:53:13 <elvishjerricco> newtype Union ts a = Union (CoRec (Flap a) ts)
14:53:14 <glguy> You don't have to worry that `div` truncates in  n*(n+1)`div`2   , the number being divided will always be even
14:54:18 <infinisil> Hey, can I catch a fail?
14:54:20 <infinisil> :t fail
14:54:21 <lambdabot> Monad m => String -> m a
14:54:25 <glguy> You can!
14:54:35 <infinisil> How can I?
14:55:06 <c_wraith> depends on which fail.
14:55:26 <geekosaur> it depends on what form it takes, which is per monad. in Maybe, it's Nothing; in [], it's []; in IO it's throwIO and requires Control.Exception.catch or similar
14:55:40 <c_wraith> > fail "hello" :: Maybe ()
14:55:42 <lambdabot>  Nothing
14:55:50 <infinisil> Hmm..
14:55:54 <c_wraith> nothing to catch there! (pun intended)
14:55:58 <infinisil> Oh yeah, that makes sense
14:56:03 <infinisil> Not sure what I was thinking
14:56:18 <infinisil> I'll use MonadFail instead of Either String a then
14:56:28 <geekosaur> or you might be thinking of ExceptT
14:56:34 <infinisil> (am not)
14:56:45 * infinisil checks ExceptT
14:58:14 <infinisil> Probably not
15:01:42 <lyxia> elvishjerricco: that doesn't seem possible because the type parameters of CoRec are not determined by its constructors.
15:16:24 <glguy> elvishjerricco: Did you already figure out GEq?
15:16:54 <elvishjerricco> glguy: Nope
15:17:15 <elvishjerricco> I did find a rather unperformant avenue to a solution, but haven't quite solved it yet.
15:17:35 <glguy> That one's easier and doesn't appear to be possible either, at least not very generically
15:17:42 <elvishjerricco> All I need is `unconsCoRec :: CoRec f (t ': ts) -> Either (f t) (CoRec f ts)`
15:18:02 <elvishjerricco> If you have this you can do it with inductive instances
15:18:28 <elvishjerricco> Slow, in that it'll be `O(n)` where `n` is the length of the type level list, despite the data structure being constant size
15:18:48 <elvishjerricco> But I haven't quite figured out `unconsCoRec` yet
15:24:07 * hackage ztar 0.1.1 - Creating and extracting arbitrary archives  http://hackage.haskell.org/package/ztar-0.1.1 (brandonchinn178)
15:24:10 <tdammers> glguy: I probably f'd up somewhere, I'm very tired
15:57:49 <zahin> @search Giverning the lonestar state
15:57:50 <lambdabot> Unknown command, try @list
15:58:05 <zahin> @list governing the lonestar state
15:58:05 <lambdabot> No module "governing the lonestar state" loaded
15:58:15 <glguy> zahin: You can play with lambdabot in /msg
16:03:20 <N3RGY> Are there any libraries for automatically generating UIs (e.g. using HTMLs) given some type? I could imagine this working via TH or generics
16:04:29 <N3RGY> I'm basically imagining some cheap way of procedurally generating an HTML page for displaying or editing values of some type
16:04:41 <N3RGY> Along with a parser for getting the edited value back in to haskell
16:05:37 * hackage hw-simd 0.0.0.2 - SIMD library  http://hackage.haskell.org/package/hw-simd-0.0.0.2 (haskellworks)
16:07:01 <hpc> N3RGY: not that i know of and now that you mention it, it seems kind of obvious
16:07:07 <N3RGY> Right?
16:07:14 <hpc> as part of some web framework
16:07:24 <N3RGY> This seems super useful
16:07:27 <hpc> i guess you'd have to pick one
16:07:38 <hpc> or make it generic and make people write the glue themselves
16:07:39 <N3RGY> like that C++ library that lets you throw together a crappy but functional UI really fast
16:08:01 <N3RGY> I will screw around with this for a couple hours
16:08:03 <hpc> i've wanted that in the past for other languages
16:08:17 <hpc> take a look at the Data and Typeable type classes
16:08:28 <Rembane> There is one in Purescript. But I can't remember the name.
16:08:40 <N3RGY> Didn't Generic replace Data?
16:08:53 <N3RGY> Or did I get that backwards
16:09:00 <glguy> No, it's just a different approach, either replaces the other
16:09:16 <glguy> neither*
16:09:37 <hpc> Generic from syb?
16:09:46 <hpc> or is hoogle failing me?
16:09:55 <N3RGY> Data is syb
16:09:59 <glguy> There's syb/Data.Generics and GHC.Generics
16:10:19 <hpc> Data is base
16:10:19 <hpc> http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Data.html#t:Data
16:10:29 <glguy> Data is the GHC support for syb
16:10:31 <hpc> oh jk, it's syb and just folded in
16:10:32 <N3RGY> Data.Generics gives you a "Rep" type family that converts any ADT into an expanded representation with explicit sums and products
16:10:43 <N3RGY> *GHC.Generics
16:10:43 <glguy> No, that's GHC.Generics
16:17:19 <confuzed> What’s the best way to install Haskell these days
16:19:38 <hpc> stack makes it pretty easy because it's all behind a reproducible build system
16:20:30 <hpc> i personally am using os-packaged stack and ghc
16:21:24 <hpc> if you're on windows you have to use the platform to avoid going crazy
16:21:31 <hpc> not sure what the situation is on mac
16:22:54 <glguy> On the mac the platform works great, too. The core installer gets you a ghc, stack, and cabal-install executable
16:23:49 <glguy> having cabal-install is handy even if you have to use stack as the 'stack solver' will call out to it, saves manually doing dependency resolution when you're using packages that aren't in one of the resolvers
16:25:58 <N3RGY> I suspect that my knowledge of how to use stack and cabal new-* is really out of date. Let's say I want to start a random project where I'm just screwing around. I make a .hs file and use bare "ghc" to compile it. Now I want to actually get it set up with some sort of lts release or deterministic versioned build or something - what do I do? My current process is "cabal init" followed by "stack init"
16:26:07 * hackage self-extract 0.3.2 - A Haskell library to make self-extracting executables  http://hackage.haskell.org/package/self-extract-0.3.2 (brandonchinn178)
16:26:53 <glguy> N3RGY: You don't need to use stack init to get a reproducable snapshot of your contraints, cabal new-freeze handles that
16:27:17 <N3RGY> Right, how do I even start using that? Should I use cabal new-init instead of cabal init?
16:27:18 <glguy> and both are equally not reproducible when it comes to external language library dependencies
16:27:32 <hpc> when is new-cabal going to be cabal btw?
16:27:35 <glguy> cabal init makes a .cabal file that new-build works with
16:28:11 <glguy> stack , cabal build, and cabal new-build all work with the.cabal file that cabal init generates
16:51:12 <dmwit> hpc: Real Soon Now
16:51:32 <dmwit> hpc: cabal recently grew a passive-aggressive message when you use old-style commands.
16:52:07 <hpc> ooh yay
16:52:12 <dmwit> (not released yet)
16:52:49 <hpc> next step, a daring mission to rescue it's module structure from the year 1993
16:57:52 <revskill> N3RGY: How about nix-shell -p "haskell.packages.$ghcver.ghcWithPackages (pkgs: with pkgs; [$pkgs])" ?
17:41:09 <OmegaDoug> Hi there, just wondering is this SO post is correct in stating that a functor is stronger property than homomorphism because it also requires that the identity law is staisfied
17:41:10 <OmegaDoug> https://math.stackexchange.com/a/405479
17:42:43 <lyxia> a lot of it seems to be within the context of the comments
17:43:46 <infinisil> Where the hell is runEitherT
17:43:53 <infinisil> It's not in the either package
17:43:55 <infinisil> And not in mtl
17:44:48 <infinisil> Not anymore in either at least, it was there until version <5
17:45:29 <lyxia> would runExceptT be what you are looking for
17:46:10 <duncan^> THere is also monad eitherT according to good old hoogle.
17:46:32 <infinisil> lyxia: Ohhh..
17:46:34 <infinisil> Indeed
18:16:36 <wanger> hello
18:35:03 <pavolzetor> hello, I was some time complaining about foundation parser (and I rewrote the tiny compiler in go, but came back to haskell :)); I ended up rolling my own parser and lexer as it was trivial
18:35:21 <pavolzetor> however, I am stuck in recovery/reporting
18:36:23 <pavolzetor> for example, I synhronize on statement boundary, but I can either add IO as a member of the parser or lit all errors and then spit them out
18:36:28 <pavolzetor> not sure what is better solution
18:37:14 <pavolzetor> Aside, I find using this basic version of Haskell really enjoyable :)
18:53:28 <revskill> pavolzetor: which parsing library did u use ?
19:07:06 <fragamus> I was reading the recent Haskell AHA discussion and one person was making the argument that state monad and reader monad didn’t help the coder (FORTRAN in any language)
19:08:02 <fragamus> I remember thinking the same thing years back
19:10:04 <fragamus> But now I think the value is in being able to look at the monad and be able to reason that even if there’s FORTRAN-like implementation in there, we can know something
19:10:44 <fragamus> about what that thing can do and what it can’t
19:11:02 <fragamus> It’s not just for the compiler
19:11:39 <geekosaur> which is a point that was made in that discussion
19:12:03 <fragamus> I didn’t read it all I’m traveling sorry
19:12:14 <geekosaur> but at this point I'm having some trouble taking the whole thing seriously, after the one who tried to claim monads aren't from CT but were invented by functional programming
19:12:24 <Zipheir`> fragamus: link?
19:13:10 <fragamus> It’s in the mailing list I don’t know if it’s archived
19:13:42 <Zipheir`> Ah, ok.
19:14:15 <monochrom> Oh, no wonder why I'm receiving hundreds of haskell-cafe messages lately.
19:14:41 <fragamus> Yes it’s very readable these days
19:15:05 * monochrom deletes the whole thread.
19:15:09 <geekosaur> I think it's http://mail.haskell.org/pipermail/haskell-cafe/2018-July/129575.html or message sint hat subthread
19:15:38 * geekosaur is approaching muting the whole thread, s:n is far too close to 0
19:16:03 <Zipheir`> geekosaur: ty
19:16:09 <monochrom> The state monad is not going to be your aha moment; the String -> [(String, a)] parser monad is. But that won't work unless you saw state first.
19:17:15 <fragamus> For me the aha comes with seeing how concise code can get
19:18:30 <monochrom> And actually "use state to help relabel your tree data from 0 to n-1 in in-order order" is pretty cute.
19:18:57 <Zipheir`> fragamus: Exactly
19:19:12 <monochrom> Not useful, not practical, but cute and teaches something.
19:19:16 <pavolzetor> revskill: none, I wrote the few methods necessary (peek, advance) and it works great
19:20:22 <fragamus> I wrote a comonad to emit the declarative has_many belongs_to blah blah statements for a rails app. It was so much better than maintaining that by hand
19:22:13 <fragamus> It sucked up a graph defining the relationships and then emitted all valid declarations for those rails models
19:22:31 <pavolzetor> revskill: I think I will go with having a list of error messages as those errors are between repl commands
19:23:30 <fragamus> I tried very hard to write functional ruby also but it was unwieldy
19:26:23 <Zipheir`> fragamus: I see what geekosaur meant about that thread's low S/N ratio. I'm not really sure what point they're trying to make.
19:26:58 <fragamus> Well it’s like a friendly bar room brawl
19:28:04 <fragamus> Did anyone here ever try to do FP in ruby
19:28:22 <fragamus> I did and it was unexpectedly hard
19:31:04 <fragamus> Maybe someone more enlightened can write Haskell in ruby
21:29:03 <iqubic> I have just found the greatest Haskell demonstration ever.
21:29:06 <iqubic> https://www.youtube.com/watch?v=RqvCNb7fKsg
21:29:37 * hackage eigen 3.3.4.0 - Eigen C++ library (linear algebra: matrices, sparse matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-3.3.4.0 (chessai)
21:29:51 <iqubic> This man builds a <Insert Language Here> to Swedish translator in 10 minutes
21:31:03 <iqubic> @let swedish = intersperse "f"
21:31:04 <lambdabot>  Defined.
21:31:20 <iqubic> @let greeting = "hello"
21:31:22 <lambdabot>  Defined.
21:31:42 <iqubic> @let very f x = f (f (f x))
21:31:44 <lambdabot>  Defined.
21:31:58 <iqubic> > very swedish greeting
21:32:00 <lambdabot>  error:
21:32:00 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
21:32:00 <lambdabot>        Expected type: [[Char]]
21:32:22 <iqubic> > swedish greeting
21:32:25 <lambdabot>  error:
21:32:25 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
21:32:25 <lambdabot>        Expected type: [[Char]]
21:32:30 <iqubic> > greeting
21:32:32 <lambdabot>  "hello"
21:32:56 <iqubic> @let swedish = intersperse 'f'
21:32:57 <lambdabot>  .L.hs:161:1: error:
21:32:57 <lambdabot>      Multiple declarations of ‘swedish’
21:32:57 <lambdabot>      Declared at: .L.hs:159:1
21:33:02 <iqubic> @undefine
21:33:02 <lambdabot> Undefined.
21:33:12 <iqubic> @let greeting = "hello"
21:33:14 <lambdabot>  Defined.
21:33:30 <iqubic> @let swedish = intersperse 'f'
21:33:31 <lambdabot>  Defined.
21:33:48 <iqubic> @let very f x = f (f (f x))
21:33:49 <lambdabot>  Defined.
21:34:01 <iqubic> > swedish greeting
21:34:03 <lambdabot>  "hfeflflfo"
21:34:25 <iqubic> > very swedish greeting
21:34:27 <lambdabot>  "hfffffffeffffffflffffffflfffffffo"
21:34:31 <iqubic> What?!?!
21:34:46 <duoi> swedish greeting: "salam alaykum"
21:35:06 <iqubic> > very very swedish greeting
21:35:08 <lambdabot>  "hffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff...
21:35:18 <iqubic> What the actually heck just happened there?
21:35:50 <iqubic> I don't understand that interaction at all.
21:40:01 <c_wraith> isn't that just basic exponentiation?
21:40:15 <iqubic> It might be, but I'm not sure.
21:40:23 <c_wraith> there should be like 81 fs between the h and the e
21:41:04 <iqubic> I don't understand either "very swedish greeting" or "very very swedish greeting"
21:41:25 <c_wraith> :t very
21:41:26 <lambdabot> (t -> t) -> t -> t
21:41:31 <c_wraith> :t very swedish
21:41:32 <lambdabot> [Char] -> [Char]
21:42:03 <c_wraith> :t very very
21:42:04 <lambdabot> (t -> t) -> t -> t
21:42:19 * hackage hw-simd 0.0.0.3 - SIMD library  http://hackage.haskell.org/package/hw-simd-0.0.0.3 (haskellworks)
21:42:42 <iqubic> > intersperse 'f' (intersperse 'f' (intersperse 'f' "hello"))
21:42:44 <lambdabot>  "hfffffffeffffffflffffffflfffffffo"
21:42:47 <iqubic> Why?
21:42:55 <c_wraith> why not?
21:43:18 <iqubic> Why did we get 7 fs?
21:43:32 <Xnuk> > intersperse 'f' "hello"
21:43:34 <lambdabot>  "hfeflflfo"
21:44:01 <c_wraith> It's like drawing a complete binary tree
21:44:16 <iqubic> Oh, I see.
21:44:46 <iqubic> What does "very very (intersperse 'f' "hello")" do?
21:45:03 <c_wraith> > very very (+1) 0
21:45:05 <lambdabot>  27
21:45:24 <iqubic> So it runs intersperse 27 times.
21:45:32 <iqubic> How many f's is that/
21:46:00 <c_wraith> Heh.  following the previous observation - 2^27 - 1
21:46:20 <iqubic> > 2 ** 27 - 1
21:46:22 <lambdabot>  1.34217727e8
21:46:31 <iqubic> That is a lot of f's.
21:47:00 <iqubic> Why is there a minus 1 at all?
21:47:21 <mniip> why would there not be
21:48:05 <c_wraith> > intersperse 'f' "hello"
21:48:07 <lambdabot>  "hfeflflfo"
21:48:15 <c_wraith> 2^1 - 1
21:48:19 <iqubic> Right.
21:48:28 <c_wraith> > intersperse 'f' (intersperse 'f' "hello")
21:48:30 <lambdabot>  "hfffeffflffflfffo"
21:48:33 <c_wraith> 2^2 - 1
21:48:45 <iqubic> I see.
21:48:57 <c_wraith> you can actually use induction to prove it. :)
21:49:11 <iqubic> I don't nee induction. I see the pattern.
21:49:24 <c_wraith> you think there's a difference?
21:49:36 <iqubic> And I understand that this is not actually how Swedish works.
21:49:37 <c_wraith> induction is writing the pattern down
21:50:00 <iqubic> lol. yeah.
22:29:07 * hackage network-messagepack-rpc 0.1.0.0 - MessagePack RPC  http://hackage.haskell.org/package/network-messagepack-rpc-0.1.0.0 (KazuYamamoto)
22:30:07 * hackage network-messagepack-rpc-websocket 0.1.0.0 - WebSocket backend for MessagePack RPC  http://hackage.haskell.org/package/network-messagepack-rpc-websocket-0.1.0.0 (KazuYamamoto)
22:31:08 <xsperry> hello. I used hxt to webscrap a copule of years ago, and I wasn't overly  thrilled with arrow syntax it was using. what other library should I consider for a new project?
22:32:22 <jackdk> I had fun with taggy and taggy-lens on a recent webscraping hack, but it never went anywhere public
22:33:51 <xsperry> jackdk I suppose it works with malformed html? doesn't say in here. http://hackage.haskell.org/package/taggy
22:34:03 <cocreature> xsperry: I’ve been pretty happy with `xml-conduit` + `html-conduit` which, despite its name, works perfectly well without conduit
22:34:33 <cocreature> in particular the cursor interface in `xml-conduit` is quite nice
22:35:52 <xsperry> thanks I'll check both of them out
22:36:25 <jackdk> the git repo's description includes the word "tolerant"
22:37:00 <geekosaur> also I think these days hxt also provides a standard parser / applicative interface
22:37:08 <geekosaur> (the arrow one is still there)
23:19:11 <hololeap> i have an attoparsec parser which splits a document into a list of lines (Parser [ByteString]), and another one which parses each individual line. how can i nest these?
23:21:16 <dminuoso> hololeap: monadic bind? ..
23:22:22 <dminuoso> oh I think I misunderstood sorry
23:22:42 <cocreature> hololeap: call parseOnly for each individual line
23:24:26 <hololeap> cocreature: ok, i think i can make that work
23:27:08 * hackage mandrill 0.5.3.4 - Library for interfacing with the Mandrill JSON API  http://hackage.haskell.org/package/mandrill-0.5.3.4 (AlfredoDiNapoli)
23:29:04 <unconnect3d> my man
23:29:38 <Thugpro_> Skrt skrt
23:30:07 <unconnect3d> evrybody sleepin
23:30:11 <unconnect3d> deso
23:30:16 <Thugpro_> Red
23:30:38 <iqubic> I'm awake
23:30:55 <unconnect3d> sup my g
23:31:47 <Thugpro_>  Suh
23:50:33 <quicksilver> I used to use HXT without using arrow notation, which never really gelled with me
23:50:49 <quicksilver> but I also once used xml-conduit and found it fine
