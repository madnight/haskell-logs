00:26:21 <mcspud> @forget quicksilver "In particular, Big-O notation is there to abstract constant factors, but RAM accesses is not a constant time operation - not in theory, and not in practice." -- The Myth of RAM
00:26:21 <lambdabot> Done.
00:26:22 <mcspud> :D
00:26:53 <d45h0> hi what is haskell
00:27:27 <cocreature> d45h0: a functional programming language
00:27:39 <dminuoso> Haskell is both the first name of a famous logician, as well as the name of a purely functional lazy programming language.
00:27:49 <dminuoso> The former being the namegiver to the latter.
00:27:55 <d45h0> functional?
00:28:22 <mcspud> @remember quicksilver "In particular, Big-O notation is there to abstract constant factors, but RAM accesses is not a constant time operation - not in theory, and not in practice." -- The Myth of RAM
00:28:22 <lambdabot> I will remember.
00:28:55 <mcspud> d45h0 - Yes, functional
00:29:19 <mcspud> But it has a slippery definition so good luck getting a clear answer on it
00:29:40 <Lowl3v3l> d45h0: functional programming is a paradigm, where you try solve problems by decoupling them into smaller solvable functions ^^
00:29:47 <quicksilver> mcspud: ?
00:30:21 <mcspud> quicksilver I just wanted to see if it would work
00:30:22 <mcspud> I put it back in
00:30:53 * quicksilver shrugs
00:31:54 <mcspud> for what its worth im reading that artcle now
00:33:08 <revskill> How to simplify this expression ? : filter (not . first) . filter (not . second)
00:34:08 <Lowl3v3l> revskill: just use only one filter that checks for not ( first | second)
00:34:22 <liste> filter (\x -> not (first x || second x))
00:34:33 <revskill> first and second are both predicates
00:35:15 <revskill> liste, Lowl3v3l: good ideas, thanks
00:39:28 <quicksilver> filter(not . liftA2 (||) first second)
00:39:37 <quicksilver> I think that's probably a bad idea :)
00:40:06 <quicksilver> but if you spend a lot of time working with predicates you may actually define <||> = liftA2 (||) or something.
00:40:48 <d45h0> import Maybe :D
00:41:10 <d45h0> haskell crazy
00:41:24 * [exa] wishes for another kind of `backticks` that would liftA2 the functions&operators
00:41:56 <ongy> import Haskell.Crazy? :)
00:45:02 <dminuoso> @let (.||.) = liftM2 (||)
00:45:03 <lambdabot>  Defined.
00:46:48 <dminuoso> @let (.|||.) = liftM2 (||)
00:46:49 <lambdabot>  Defined.
00:46:56 <dminuoso> :t (even .|||. odd)
00:46:57 <lambdabot> Integral a => a -> Bool
00:47:24 <ongy> :t (|||)
00:47:25 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
00:56:47 <c50a326> wow I actually dreamt about something about MVars last night
00:57:29 <c50a326> can't remember but I definitely dreamt haskell D:
00:57:36 * hackage sv-core 0.1 - Encode and decode separated values (CSV, PSV, ...)  http://hackage.haskell.org/package/sv-core-0.1 (qfpl)
00:59:10 <dminuoso> I dreamt I was a monad once..
00:59:26 <dminuoso> It happened back when I was trying to learn monad really hard by starting with category theory..
01:00:06 * hackage sv 1.0 - Encode and decode separated values (CSV, PSV, ...)  http://hackage.haskell.org/package/sv-1.0 (qfpl)
01:00:13 <c50a326> that's one monad blog post I'd actually be interested in reading :D
01:00:15 <phadej> people are (if anything) comonading
01:02:06 * hackage sv-cassava 0.2 - Integration to use sv with cassava's parser  http://hackage.haskell.org/package/sv-cassava-0.2 (qfpl)
01:04:07 * hackage sv-svfactor 0.1 - sv-core + svfactor  http://hackage.haskell.org/package/sv-svfactor-0.1 (qfpl)
01:11:36 <quicksilver> [exa]: yeah, an outfix syntax for liftA2 of binary operations would be nice
01:11:58 <quicksilver> at least, it would be nice if you live in a world full of binary infix combinators
01:15:32 <revskill> :t foldMap (not .) [even, odd]
01:15:33 <lambdabot> error:
01:15:34 <lambdabot>     • Could not deduce (Monoid Bool) arising from a use of ‘foldMap’
01:15:34 <lambdabot>       from the context: Integral a
01:16:17 <cocreature> revskill: a -> b is only an instance of Monoid is b is an instance of Monoid
01:16:33 <cocreature> and Bool is not an instance of Monoid
01:16:48 <revskill> are pure functions Monoid with `.` as mappend ?
01:17:04 <cocreature> there are two newtypes for Bool that are an instance of Monoid namely All and Any
01:17:15 <cocreature> no
01:17:28 <cocreature> there is an Endo newtype for a -> a that has that Monoid instance
01:17:49 <cocreature> but the instance you get without a newtype is the Monoid b => Monoid (a -> b) instance
01:18:16 <dminuoso> :t foldMap (All .) [even, odd]
01:18:18 <lambdabot> Integral a => a -> All
01:18:55 <revskill> :t foldMap (All . not . ) [even, odd]
01:18:56 <lambdabot> error:
01:18:56 <lambdabot>     The operator ‘.’ [infixr 9] of a section
01:18:56 <lambdabot>         must have lower precedence than that of the operand,
01:21:25 <quchen> :t foldMap ((All . not) .) [even, odd]
01:21:27 <lambdabot> Integral a => a -> All
01:21:37 <revskill> sweet
01:21:49 <quchen> Those parentheses are necessary, unfortunately.
01:32:06 <butterthebuddha> Can head and tail be defined for a Foldable?
01:33:19 <ongy> :t fold
01:33:20 <lambdabot> (Monoid m, Foldable t) => t m -> m
01:33:58 <cocreature> butterthebuddha: head yeah (just compose it with toList), for tail it depends on how you want to generalize it
01:34:26 <ongy> butterthebuddha: in Theory you could define yourself something that behaves like head. Tail is iffy, You can get `Foldable t => t a-> [a]` that behaves like tail
01:42:14 <quchen> > foldr const (error "empty foldable") "hello world" -- butterthebuddha
01:42:16 <lambdabot>  'h'
01:43:22 <quchen> tail, hmm.
01:44:57 <quicksilver> > foldr ((Just .). const) Nothing "hello world"
01:44:59 <lambdabot>  Just 'h'
01:45:08 <quicksilver> safeHead :)
01:45:44 <cocreature> :t listToMaybe . toList
01:45:46 <lambdabot> error:
01:45:46 <lambdabot>     Ambiguous occurrence ‘toList’
01:45:46 <lambdabot>     It could refer to either ‘F.toList’,
01:45:49 <cocreature> :t listToMaybe . F.toList
01:45:50 <lambdabot> Foldable t => t a -> Maybe a
01:47:09 <quicksilver> I don't believe tail is expressible in the form "foldr f x xs" though
01:47:35 <quicksilver> to be slightly more precise, I don't believe tail xs is expressible in the form "foldr f x xs"
01:47:44 <quicksilver> if you're allowed to change the list it obviously is.
01:48:04 <ongy> you won't get `tail :: Foldable t => t a -> t a` in any nice way.
01:48:33 <cocreature> you won’t get it at all. Foldable is not sufficient for that
01:53:34 <Taneb> What's tail of Identity 'x'
01:54:46 <cocreature> if we are talking about "head" we are already allowing partial functions :)
01:54:58 <cocreature> so making "tail" partial isn’t really any different
01:54:59 <ongy> Taneb: what's tail of []?
01:55:08 <ongy> > tail []
01:55:10 <lambdabot>  *Exception: Prelude.tail: empty list
01:55:11 <Taneb> OK, fair
01:58:43 <quicksilver> it's always a bit disappointing to see that Foldable is really just toList
01:58:58 <quicksilver> it requires considerable mental effort to recover the perspective that actually Foldable is a lot more than toList
01:59:10 <quicksilver> worthwhile journey though.
01:59:21 <ongy> @src Foldable
01:59:21 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
01:59:43 <ongy> =.=
02:00:19 <ongy> anyways, I think everything in Foldable could be done with a function on lists and toList. And I wonder if that would even be much less effficient, after all the fancy optimizations GHC does
02:00:33 <quicksilver> it absolutely can be done that way, yes
02:00:39 <[exa]> (not haskell, but slightly related:) anyone know a patching tool that would be able to work with the output of wdiff, or git diff --word-diff ?
02:00:42 <quicksilver> that's what I meant by "Foldable is really just toList"
02:02:24 <Cale> It's not *exactly* just toList
02:03:24 <Cale> because foldMap can produce other associations of the elements
02:03:32 <Taneb> You can make a broadly sensible foldMap for bidirectional infinite streams
02:03:39 <Cale> Think about lazy snoc lists for example
02:03:42 <Cale> yeah
02:07:23 <quicksilver> Cale: yes, that's why I said 'really' not 'exactly'
02:07:37 <quicksilver> it was a particularly pedantic colloquialism
02:08:01 <quicksilver> the reasons that Foldable is more than toList are interesting
02:08:22 <Taneb> (so, by "really" you meant... "not really" :P )
02:08:26 <quicksilver> laziness, association order, memory locality
02:08:37 <ongy> how would it be different on lazy snoc list? Build them back to front instead of front to back?
02:08:59 <quicksilver> potentially even parallelism (but I'm not suggesting that actual haskell implementations are able of doing clever parallelism of large folds magically)
02:09:36 <quicksilver> Taneb: by "really" I meant - here is a simplification which is alluring and, if we restrict the domain slightly, is even true.
02:10:00 <quicksilver> isn't that the way everyone uses the adverb? ;)
02:11:38 <ongy> kind of like literally. We should have new adjectivies here. Like truthy
02:16:38 <c50a326> damn where did jle go
02:17:01 <c50a326> I'm just reading this https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/mark.pdf and wondered if he also took issue with SPJ's treatment of "the IO monad"
02:27:03 <[exa]> hm guys, how different is Frege from Haskell? (ie. are there any parts in common or is the implementation completely standalone?)
02:29:38 <quicksilver> do you mean to ask how different it is from GHC?
02:29:45 <quicksilver> Haskell is a language not an implementation
02:31:12 <quicksilver> as far as I know, the implementation is entirely independent from GHC
02:31:38 <cocreature> it’s a language with one relevant implementation that doesn’t implement the specification :)
02:36:28 <[exa]> oh yes I meant different from GHC.. :]
02:37:21 <[exa]> wow, it has namespaced records
02:40:16 <[exa]> omg the website says that 'main' is impure
02:43:30 <tdammers> IIRC the original idea with Frege was to make a language that is very similar to Haskell, but taking creative liberties to make it easier to implement on JVM, and also to fix some of the perceive shortcomings of Haskell; but it became obvious at some point that because this makes it incompatible with the large existing library ecosystem, it would be better to actually be as Haskell2010 compliant as possible,
02:43:31 <tdammers> so they started working on that. But I have no idea how far they have gotten on that front.
02:45:40 <[exa]> yeah I'm kindof surprised by the amount of duplicate effort there
02:46:10 <cocreature> eta seemed to be seeing a lot more activity at least for a while if you are looking for a Haskell for the JVM
02:46:37 <cocreature> and iirc they forked off at GHC 7.10 and are backporting things so it should also support a fair amount of GHC specifics
02:47:01 <Ke> I thought you will get raided by the haskell commando group, if you start using something as obsolete as 2010-compatible haskell
02:47:15 <[exa]> (iteresting side observation --- java people must love duplicate effort)
02:47:29 <c50a326> what was this [Response] -> [Request] thing that came before monads
02:47:43 <Ke> without a least some language extensions for each code file
02:47:46 <c50a326> the concepts are unintuitively backwards...
02:47:46 <[exa]> c50a326: lazy list IO
02:48:12 <c50a326> [exa]: is there somewhere where explains what it's all about simply, and why it's backwards compared to normal client/server intuition?
02:49:38 <[exa]> cocreature: I don't want to touch JVM at all, but got a thesis here for review that does something with Frege so trying to decide whether to agree or not
02:50:22 <cocreature> [exa]: ah, I see :)
02:50:29 <[exa]> Ke: nobody expects haskell extension!
02:50:35 <tdammers> well, the "Haskell on the JVM" problem can be tackled in one of two ways: a) port GHC to the JVM; b) implement Haskell2010 (or GHC-Haskell, or whatever you think is the best "standard Haskell" out there) from scratch
02:50:56 <tdammers> given that GHC is a 20-year old academic reseach codebase, it isn't obvious which one of these is ultimately the wiser chocie
02:51:13 <[exa]> oh f it, I'll just learn Frege
02:52:02 <tdammers> anyway, from what I've seen, Frege is sufficiently similar to Haskell that you can probably just memorize a handful of crucial differences and be on your way
02:55:33 <[exa]> tdammers: good to know, thanks. I guess there are no caveats until I start touching java?
02:56:12 <tdammers> [exa]: I've only skimmed things, so I have absolutely no idea - but I assume the abstraction is reasonably solid, and Java doesn't bleed through a lot
02:57:30 <[exa]> ok
02:58:50 <[exa]> related-- I just found out how java people look at domain specific languages
02:58:52 <[exa]> https://www.jetbrains.com/mps/
03:00:56 <__monty__> Fancy syntax?
03:06:55 <fishythefish> c50a326: it's [Response] -> [Request] because you issue (output) requests and operate on responses
03:07:30 <ZeusPiark> hello
03:07:51 <[exa]> __monty__: i wanted to say "ms office" but yes, fancy syntax
03:10:43 <fishythefish> c50a326: the things we now consider IO values were represented as requests to the runtime. main would produce a list of requests, and the input responses were the ones corresponding to your requests
03:11:14 <fishythefish> you might find section 7 (page 69) of http://haskell.cs.yale.edu/wp-content/uploads/2011/01/haskell-report-1.2.pdf illuminating
03:18:31 <quicksilver> we still have this:
03:18:33 <quicksilver> :t interact
03:18:34 <lambdabot> (String -> String) -> IO ()
03:18:46 <quicksilver> which is a descendant of that simple interaction model
03:20:35 <SamuelEvans-Powe> Hey everyone! I'm looking for this function `:: Monad m => [(a -> m a)] -> (a -> m a)` essentially threading the `a` from the `m a` of the preceeding function to the next.
03:20:41 <Maxdamantus> `interact` seems fairly orthogonal to the "lazy list" or whatever it's called paradigm.
03:20:58 <Maxdamantus> There's no sense of feedback in `interact`
03:21:56 <fishythefish> :t foldr (>=>) return
03:21:58 <lambdabot> (Monad m, Foldable t) => t (c -> m c) -> c -> m c
03:22:08 <fishythefish> SamuelEvans-Powe ^
03:23:05 <SamuelEvans-Powe> Suitable name ;) fishythefish
03:23:09 <SamuelEvans-Powe> Thank you!
03:23:24 <fishythefish> ><>
03:23:25 <quicksilver> Maxdamantus: surely it's exactly the same except the only possible Request is text input and the only possible Response is text output?
03:24:40 <Maxdamantus> quicksilver: well, in `[Response] -> [Request]`, the output influences the input.
03:25:02 <cocreature> that can happen for interact as well?
03:26:17 <Maxdamantus> Hm, I guess that's true.
03:26:30 <quicksilver> I said it backwards sorry
03:26:35 <quicksilver> but yes :)
03:26:48 <fishythefish> interact assumes that your requests are read-input followed by print-output (the latter of which requires a string argument), and the corresponding responses will be a string and ()
03:26:49 <Maxdamantus> wait, no.
03:26:58 <fishythefish> all told, you're left to implement the string -> string conversion in the middle
03:27:03 <Maxdamantus> Because it's the output of a single function call influencing the input to that same function call.
03:27:40 <Maxdamantus> with `interact`, it's the output of one function call influencing the input of another function call, which isn't weird at all.
03:28:16 <quicksilver> no you're right, interact is more local
03:28:31 <quicksilver> because you have to provide a single (String -> String)
03:28:41 <quicksilver> which obviously can't be aware of the context (history or future)
03:28:51 <quicksilver> I standby the concept that it's a *descendant*
03:29:01 <quicksilver> but it is a massively less expressive thing
03:29:17 <fishythefish> think of it as the internals of a special case - cf. my explanation
03:29:30 <fishythefish> the String -> String you're implementing gives you the translation from one Response to one Request
03:34:54 <cocreature> the String -> String function receives the entire input not individual lines = responses
03:35:04 <cocreature> so it can totally be aware of the context
03:36:06 <Maxdamantus> But the String returned by the function has no influence on the String that gets passed into that same call.
03:38:02 <Maxdamantus> The only places in Haskell where you can result in such feedback is in things that are not really purely functional.
03:38:05 <Maxdamantus> like `hGetContents`
03:39:14 <cocreature> hGetContents is exactly how interact is implemented
03:39:51 <Maxdamantus> Maybe so, but it doesn't have to be.
03:40:16 <Maxdamantus> You can just define it in terms of `getLine` and `putStrLn`, which don't have the conceptual issues that `hGetContents` has.
03:40:48 <Maxdamantus> (if it uses `hGetContents`, that's simply an implementation detail in GHC's `interact` or whatever)
03:41:04 <cocreature> no you can’t implement it in terms of getLine and putStrLn because it doesn’t operate on individual lines
03:41:09 <cocreature> you get the _entire_ stdin
03:41:37 <barrucadu> See http://hackage.haskell.org/package/base-4.11.1.0/docs/src/System.IO.html#interact
03:43:03 <Maxdamantus> Oh, okay. I thought `interact` did something completely different. I retract everything I've said about it.
03:43:09 <fishythefish> Maxdamantus: in the Request/Response variant of interact, the Request to output a string has no influence on the Response from reading input, so I'm not sure what your point is
03:43:22 <fishythefish> btw, the notion of a function's output affecting its input isn't *that* weird
03:43:24 <fishythefish> @src fix
03:43:24 <lambdabot> fix f = let x = f x in x
03:44:54 <Maxdamantus> fishythefish: when I said "affecting its input", I meant of the same call.
03:45:13 <Maxdamantus> fix does repeated calls of `f`, where the input is naturally different on each call.
03:46:06 <Maxdamantus> `interact` and the thing that calls the `[Response] -> [Request]` function is only calling the function once, and the input is decided based on that same call's output.
03:47:00 <fishythefish> I think you're misunderstanding `fix`
03:47:11 <cocreature> in "fix (\xs -> 1 : xs)" the input is also determined by the output
03:47:28 <mniip> 1531997086 [13:44:46] <Maxdamantus> fix does repeated calls of `f`, where the input is naturally different on each call.
03:47:28 <cocreature> the difference is that there is no “third party”, i.e., the outside world, involved
03:47:29 <mniip> no?
03:47:29 <Maxdamantus> I'm pretty sure I know how `fix` works. I've never wanted to use something like `interact` which is why I was unaware of what it did.
03:47:58 <mniip> there's only ever one application of 'f' constructed, with its output as input
03:48:04 <Maxdamantus> fix id = id (id (id (id (...)))
03:48:08 <fishythefish> it's a fixed point, what's the use of repeated calls?
03:48:14 <Maxdamantus> id is called many times.
03:48:18 <fishythefish> there's clearly only one call to f in the definition :P
03:48:19 <mniip> Maxdamantus, that's because you're writing it as a tree
03:48:23 <mniip> in reality it's a graph
03:48:45 <mniip> fix id = let x = id x in x
03:48:50 * dstolfa dumps the mandatory wikipedia article for maths niceness https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed_point_combinators_in_lambda_calculus
03:48:52 <mniip> now reduce id once to obtain
03:48:54 <mniip> fix id = let x = x in x
03:55:01 <mniip> % withAddr :: (Addr# -> a) -> b -> a; withAddr = unsafeCoerce id
03:55:02 <yahb> mniip:
03:55:12 <mniip> % dirtyId :: a -> a; dirtyId x = trace ("My result is entered with " ++ show (withAddr Ptr x)) x
03:55:12 <yahb> mniip:
03:55:16 <mniip> % fix dirtyId
03:55:21 <yahb> mniip: My result is entered with 0x000000420031bc30; My result is entered with 0x000000420031bc30; My result is entered with 0x000000420031bc30; My result is entered with 0x000000420031bc30; My result is entered with 0x000000420031bc30; My result is entered with 0x000000420031bc30; My result is entered with 0x000000420031bc30; My result is entered with 0x000000420031bc30; My result is entered with 0x000000420031
03:55:33 <fishythefish> nice
03:56:07 <mniip> abusing the calling convention here slightly
03:57:54 <Maxdamantus> mniip: why stop at 1 application? Why not write `fix id = let x = id (id x) in x`?
03:58:15 <Maxdamantus> mniip: that should be just as valid a definition, since both effectively do repeated application infinitely.
03:58:35 <Maxdamantus> The fact that it works out as a graph at some level is just a convenience of lazy evaluation.
03:59:14 <fishythefish> lazy evaluation was a premise for this whole conversation
03:59:15 <Taneb> Imagine "fix (lazyFunction expensiveToComputeUnmemoizedParameter)"
03:59:46 <Taneb> You want there to be as few actual calls to lazyFunction as possible because you don't want to recompute its first parameter
03:59:55 <mniip> Maxdamantus, the two have different data sharing properties
03:59:57 <Taneb> And if there's only one actual call, you don't have to
04:00:56 <mniip> do you see the difference between
04:01:01 <mniip> fix f = f (fix f)
04:01:07 <mniip> and the actual definition as seen above
04:01:45 <fishythefish> that extra let binding serves a purpose and shows up elsewhere - see `cata`, for example
04:01:46 <Maxdamantus> Not at an interfacial level.
04:02:23 <Maxdamantus> You can talk about how the graph in GHC's evaluation will be different, but it has no behavioural difference in this case.
04:03:01 <mniip> it affects the memory properties of your program
04:03:24 <Maxdamantus> If you start to worry about what GHC's graph looks like, you're presumably going to be claiming that things a different depending on what sort of "lifting" or whatever it's called that GHC does (the simple optimisation that moves things outside of functions)
04:04:17 <Maxdamantus> Okay, so does whatever optimisation GHC 8.(x + 1) does as compared to GHC 8.x
04:04:36 <Maxdamantus> It doesn't influence whether the program prints "4" or goes into a loop or crashes.
04:04:55 <mniip> if you're working on a turing machine - sure
04:05:06 <revskill> what's your recommendation library for database migration ?
04:05:23 <mniip> it's not going to affect whether your program terminates or not and if it does then it won't affect the result
04:05:39 <Maxdamantus> It would be perfectly reasonable for GHC to rewrite `fix f = f (fix f)` to `fix f = let x = f x in x`
04:05:48 <mniip> but you're not working on a turing machine
04:06:08 <Maxdamantus> and I wouldn't be surprised if it did.
04:06:11 <mniip> Maxdamantus, yes because more data sharing is always better than less data sharing
04:06:24 <mniip> now it would be completely unreasonable for it to rewrite the other way
04:06:32 <mniip> because programmers rely on data sharing in their programs
04:08:37 * hackage deferred-folds 0.6.2 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.6.2 (NikitaVolkov)
04:09:02 <quicksilver> mniip: more data sharing isn't always better than less data sharing.
04:09:12 <mniip> example?
04:09:19 <quicksilver> more data sharing leads to space leaks.
04:09:32 <mniip> how so
04:09:39 <quicksilver> because the data which is shared can't be GCed
04:09:55 <mniip> but if the data was unshared
04:09:55 <hpc> mniip: suppose the two calls that data is being shared between are very far apart in time
04:09:59 <mniip> it wouldn't be GCable either
04:10:05 <hpc> in between, you can gc the data
04:10:07 <quicksilver> if the data was unshared then the first copy could be GCed
04:10:14 <quicksilver> and the second copy hasn't been (lazily) evaluated yet
04:10:19 <mniip> ah true
04:10:30 <quicksilver> it's the well-known tradeoff of the let-floating optimisation
04:10:57 <quicksilver> if you google "ghc let floating space leak"
04:11:11 <quicksilver> you'll find a bunch of roughly relevant Trac tickets and some blog posts etc
04:11:41 <fishythefish> floating space does seem like the most likely kind of space to leak
04:12:45 <quicksilver> one really simple example which comes up occasionally on the mailing list is having an infinite list as a top-level value in a module
04:12:54 <Maxdamantus> Captain! There's a hole in the ship and all the space is leaking in!
04:12:58 <quicksilver> and then code which processes it 'streaming-fashion' runs fine as expected.
04:13:07 <quicksilver> but add a careless second reference
04:13:27 <quicksilver> and suddenly your code starts ballooning memory because it can't GC the head of the list any more
04:14:12 <quicksilver> GHC's optimisations are a bit opaque around let-floating, too. Its heuristics do the right thing in many cases but then cause great confusion when they get it wrong
04:14:20 <quicksilver> such is the nature of heuristic optimisation I suppose.
04:16:53 <c50a326> dang the monadic haskell code in this "The Awkward Squad" paper is so beautiful! the proper indentation of `f >>= \x -> g >>= h -> return ...` is really great
04:18:19 <c50a326> ah I think I forgot a \
04:28:36 <c50a326> and the getLine implementation really twists my brain... recursion with a closure :o
04:29:05 <liste> c50a326: in the awkward squad paper?
04:30:06 * hackage edit 1.0.0.0 - A monad for rewriting things.  http://hackage.haskell.org/package/edit-1.0.0.0 (theindigamer)
04:32:17 <fishythefish> and getLine isn't even a function ;)
04:33:30 <c50a326> yeah this https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/mark.pdf
04:34:49 <c50a326> damn, spacemacs haskell layer doesn't indent bind and lambda blocks like that nicely :\
04:36:36 <lin__> :- bar _ = \ _ -> const True
04:36:39 <lin__> :t bar _ = \ _ -> const True
04:36:40 <lambdabot> error:
04:36:40 <lambdabot>     parse error on input ‘=’
04:36:40 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
04:37:15 <quicksilver> :t let bar _ = \ _ -> const True in bar
04:37:16 <hpc> lin__: the thing you ask the type of needs to be an expression
04:37:16 <lambdabot> p1 -> p2 -> b -> Bool
04:38:17 <lin__> I want bar to just return a predicate that is always True
04:38:31 <quicksilver> bar = const True
04:38:37 <quicksilver> is all you need for that
04:38:39 <quicksilver> bar _ = True
04:38:42 <quicksilver> would be another option
04:38:57 <quicksilver> bar = \_ -> True
04:39:05 <quicksilver> would be a third :) You managed to combine all three of those.
04:40:02 <lin__> could I then "(bar x) anything" and it would yield True?
04:40:17 <liste> :t const . const . const True
04:40:19 <lambdabot> b1 -> b2 -> b3 -> Bool
04:40:43 <liste> > (const . const . const True) 1 2 3
04:40:45 <lambdabot>  True
04:41:04 <monoidal> > let bar = const True in bar 5
04:41:06 <lambdabot>  True
04:41:12 <lin__> ah, const was the function that creates constant functions
04:41:14 <hpc> perhaps it would help if you said what type you wanted?
04:41:18 <quicksilver> oh if you want (bar x) anything then you do need two
04:41:22 <quicksilver> bar _ = const True
04:41:43 <liste> or...
04:41:54 <liste> > let bar _ _ = True in (bar 5) 6
04:41:57 <lambdabot>  True
04:44:40 <lin__> my chatch all case is working, however, aparently using "read x :: Int" randomly doesn't work well
04:45:51 <lin__> My line is getp [x] = \y -> y == read x
04:46:00 <lin__> where [x] is of [String]
04:46:31 <lin__> I am probably thinking to imperatively here
04:48:30 <liste> lin__: how does it fail?
04:50:42 <lin__> I s
04:52:12 <lin__> I say it would yield a -> Bool, but a was not of Eq in the declaration...
04:54:29 <Franciman> Hi
04:55:10 <Franciman> I'm having an hard time understanding the differences between backpack and typeclasses
04:55:23 <Franciman> can somebody explain me what does backpack add?
04:55:46 <lortabac> hey Franciman :)
04:55:53 <Franciman> ciao lortabac
04:56:36 <lortabac> backpack gives you a kind of existential quantification
04:57:35 <lortabac> that is, in your signatures you see a concrete type instead of a type-variable
04:58:16 <lortabac> Franciman: look at these signatures http://hackage.haskell.org/package/unpacked-containers-0/docs/Map-Lazy.html
04:58:29 <lortabac> Key is a concrete type here
05:00:06 <Franciman> lortabac, so, it's sort of compile time? As opposed to typeclasses resolved at runtime?
05:00:24 <lortabac> Franciman: no, typeclasses are resolved at compile-time too
05:00:32 <Franciman> lol
05:00:41 <Franciman> then what's the difference with the usual Map?
05:00:49 <Franciman> Map k a
05:00:51 <quicksilver> I think the question is "why would I use a Signature to specify my abstract data type rather than a typeclass?"
05:01:06 <Franciman> yes
05:01:13 <Franciman> that's my question
05:02:05 <lortabac> I think it's just convenience
05:02:39 <lortabac> no need to make your types more complex if you don't need the full power of type-classes
05:02:42 <quicksilver> (I don't know the answer to that question either. It is also the quesiton I would ask after reading ezyang's blog post)
05:04:37 <jazwzd> are there more elements of forall a. Maybe a than just Nothing?
05:04:57 <Franciman> ok, thank you very much lortabac and quicksilver
05:05:04 <quchen> jazwzd: Depends whether you count (Just ⊥).
05:05:45 <quchen> So you can have ⊥, Nothing, (Just ⊥).
05:07:13 <jazwzd> I'm confused, because I'm trying to work out what `Nothing` is - i.e. where does it lie?
05:07:38 <hpc> @src Just
05:07:39 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:07:40 <hpc> er
05:07:42 <hpc> @src Maybe
05:07:42 <lambdabot> data Maybe a = Nothing | Just a
05:08:00 <hpc> jazwzd: it's a constructor for that type
05:08:04 <hpc> for comparison:
05:08:06 <hpc> @src Bool
05:08:06 <lambdabot> data Bool = False | True deriving (Eq, Ord)
05:08:25 <quchen> Nothing :: forall a. Maybe a
05:08:31 <quchen> Just :: forall a. a -> Maybe a
05:09:00 <jazwzd> but from a theoretical perspective - I can kind of make sense of Just "cat" being a member of Maybe String, but how can Nothing be part of Maybe String and, say, Maybe Integer
05:09:24 <hpc> it's polymorphic
05:09:27 <marvin2> :t Nothing
05:09:28 <hpc> > Nothing :: Maybe String
05:09:29 <lambdabot> Maybe a
05:09:30 <lambdabot>  Nothing
05:09:35 <hpc> > Nothing :: Maybe Integer
05:09:37 <lambdabot>  Nothing
05:10:25 <hpc> it's also why undefined is considered a member of every type
05:10:27 <hpc> :t undefined
05:10:28 <lambdabot> a
05:10:39 <quchen> jazwzd: It’s the same thing as [], which has type forall a. [a]
05:10:59 <jazwzd> does that mean there's an element (Nothing :: Maybe a) of each set Maybe a, and Nothing represents choosing that element from any such set?
05:11:02 <quchen> [] can be a list of integers, a list of bools, a list of a->b, …
05:12:06 <hpc> jazwzd: if you really want to you can think of them as different Nothing-s, but theory doesn't typically care about a value's "identity" in that way
05:12:24 <mniip> jazwzd, the type theoretical answer for that is that each set Maybe a has its own Nothing@a and Nothing is an element of a profunctor end. It comes with a mapping, for each a, Nothing |-> Nothing@a
05:13:01 <hpc> oh, interesting
05:13:31 <monoidal> suppose you have a function f :: Maybe Int -> Maybe Bool; f Nothing = Nothing. You cannot rewrite it to f x@Nothing = x, because that would be a type error.
05:13:34 <mniip> the '@' syntax is borrowed from the TypeApplications extension
05:13:40 <hpc> this reminds me i need to get in the habit of using @ syntax
05:13:54 <monoidal> (here @ is at-pattern, not type application)
05:14:14 <mniip> % :t Nothing @Int
05:14:14 <yahb> mniip: Maybe Int
05:14:26 <mniip> % case Nothing @Int of Just 'a' -> undefined
05:14:28 <yahb> mniip: ; <interactive>:6:27: error:; * Couldn't match expected type `Int' with actual type `Char'; * In the pattern: 'a'; In the pattern: Just 'a'; In a case alternative: Just 'a' -> undefined
05:15:27 <jazwzd> so is there a requirement that elements of forall a. Maybe a have some sensible behavior under fmap, or could we construct an element by selecting a value from Maybe a for each a?
05:15:52 <mniip> sure, there's a coherence condition
05:15:56 <dmwit> jazwzd: Yes, there are two laws about fmap: `fmap id = id` and `fmap f . fmap g = fmap (f . g)`.
05:16:03 <marvin2> > let x = Nothing :: Maybe Int; y = x :: Maybe String in (x, y)
05:16:03 <mniip> no that's not them
05:16:05 <lambdabot>  error:
05:16:05 <lambdabot>      • Couldn't match type ‘Int’ with ‘[Char]’
05:16:05 <lambdabot>        Expected type: Maybe String
05:16:15 <mniip> @free nothing :: a -> Maybe a
05:16:15 <lambdabot> $map_Maybe f . nothing = nothing . f
05:16:37 <mniip> $map_Maybe here is fmap
05:16:45 <hpc> @free apply :: (a -> b) -> Maybe a -> Maybe b
05:16:46 <lambdabot> g . h = k . f => $map_Maybe g . apply h = apply k . $map_Maybe f
05:17:14 <quchen> That’s the free theorem for fmap.
05:17:34 <hpc> which is different from the distributivity law for Functor, hmm
05:18:00 <mniip> I'd say it's the same
05:18:04 <dmwit> jazwzd: Actually, I'm having trouble making sense of your question. Did you actually intend to say "fmap" there? If I leave out "under fmap" entirely, the question makes sense to me.
05:18:08 <quchen> The distributivity law follows in a few steps, hpc
05:18:12 <mniip> @free $map_Maybe :: (a -> b) -> Maybe a -> Maybe b
05:18:12 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
05:18:16 <mniip> @free map_Maybe :: (a -> b) -> Maybe a -> Maybe b
05:18:17 <lambdabot> g . h = k . f => $map_Maybe g . map_Maybe h = map_Maybe k . $map_Maybe f
05:18:19 <dmwit> jazwzd: But with "under fmap" I'm having more trouble.
05:18:20 <quchen> hpc: Choose k=id, f=f.g
05:18:36 <hpc> oh hah, when you put it that way it's obvious
05:18:40 <mniip> dmwit, I already answered the question
05:18:59 <mniip> the answer is the free theorem for nothing :: a -> Maybe a
05:19:04 <hpc> so the functor laws are both free?
05:19:05 <mniip> which involves fmap@Maybe
05:19:06 <dmwit> I'm not so sure you did. You gave the free theorem, but for a different type than the one he's asking about.
05:19:16 <mniip> oh wee
05:19:19 <mniip> oh err*
05:19:27 <quchen> hpc: Only the second one. The first one (fmap id = id) isn’t.
05:19:33 <mniip> I gave the free theorem for Just
05:19:37 <mniip> @free nothing :: Maybe a
05:19:37 <lambdabot> $map_Maybe f nothing = nothing
05:19:40 <dmwit> indeed
05:19:41 <mniip> there we go
05:20:43 <dmwit> But now this is not a core principle of type theory. It would be perfectly sensible to have a type theory which had other inhabitants of the type `forall a. Maybe a`, including the ones he's proposing.
05:20:53 <hpc> actually, the first one is free
05:21:09 <dmwit> Parametricity is a property of a system that requires proof.
05:21:11 <hpc> for nothing, it's true because of that free theorem, $map_Maybe id nothing = nothing
05:21:34 <hpc> for Just, $map_Maybe id . Just = Just . id
05:21:40 <hpc> $map_Maybe id . Just = id . Just
05:21:43 <hpc> $map_Maybe id = id
05:22:03 <hpc> i think that works?
05:22:07 <mniip> hpc, you used injectivity of Just here
05:22:12 <mniip> monomorphicity
05:22:52 <hpc> not really, it's the same type in either use
05:22:58 <hpc> because it's composing with id
05:23:09 <mniip> 1532002873 [15:21:13] <hpc> $map_Maybe id . Just = id . Just   =>   1532002876 [15:21:16] <hpc> $map_Maybe id = id
05:23:29 <dmwit> hpc: No, that free theorem does not apply, because there are terms of the form `Just x` which do not have the type `forall a. Maybe a`.
05:23:42 <dmwit> hpc: (And the free theorem you're using only applies to terms of type `forall a. Maybe a`.)
05:23:49 <hpc> oh :/
05:24:29 <mniip> also I think it's worth noting what the @free command means by $map_Maybe
05:24:43 <mniip> it is *the* function that does a structural map
05:24:51 <mniip> as opposed to some abstract fmap
05:25:14 <dmwit> Yes, that too.
05:25:28 <mniip> you cannot reason about fmap laws because $map_Maybe is not fmap in terms of what's defined in terms of what
05:25:42 <quicksilver> jazwzd: as an interesting GHC aside, when GHC compiles haskell there is only one Nothing and only one []
05:25:49 <quicksilver> but that's an implementation detail.
05:26:47 <dmwit> I think even that's not quite true -- though right after a GC it is.
05:27:02 <quicksilver> oh, interesting.
05:27:13 <quicksilver> either it used to be true, or the person who told me was wrong :)
05:27:22 <quicksilver> because it was definitely a GHC implementor who told me that
05:27:25 <mniip> % withAddr Ptr Nothing
05:27:26 <yahb> mniip: 0x00007fe765414f90
05:27:28 <quicksilver> (maybe JaffaCake?)
05:27:28 <mniip> % withAddr Ptr $! lookup 'a' []
05:27:29 <yahb> mniip: 0x00007fe765414f91
05:27:45 <mniip> (the '1' is a constructor tag, the pointers are otherwise equal)
05:28:27 <dmwit> % withAddr Ptr []
05:28:27 <yahb> dmwit: 0x00007fe764a89670
05:28:35 <dmwit> % withAddr Ptr [x | x <- [1..5], False]
05:28:36 <yahb> dmwit: 0x0000004206c159d8
05:28:43 <mniip> that's pointer of the closure
05:28:45 <mniip> try $!
05:29:00 <mniip> % withAddr Ptr $! [x | x <- [1..5], False]
05:29:00 <yahb> mniip: 0x00007fe764a89671
05:29:01 <dmwit> % let y = [x | x <- [1..5], False] in y `seq` withAddr Ptr y
05:29:02 <yahb> dmwit: 0x0000004207f08020
05:29:22 <dmwit> uh?
05:29:30 <dmwit> % let y = [x | x <- [1..5], False] :: [Int] in y `seq` withAddr Ptr y
05:29:31 <yahb> dmwit: 0x00007fe764a89670
05:29:35 <dmwit> ouchie
05:29:38 <jazwzd> ok, cool, I think that gives me a place to start with figuring this out! thanks
05:29:41 <mniip> DMR?
05:29:43 <dmwit> That is... kind of not okay with me.
05:30:17 <dmwit> Oh, yeah, lack of DMR, actually.
05:30:24 <dmwit> The two y's are not connected.
05:30:57 <mniip> they are
05:31:05 <mniip> the 0x0000004207f08020 is probably just an IND thunk
05:31:19 <mniip> you can rewrite the contents of a closure but you cannot change its pointer
05:32:03 <mniip> withAddr was already applied to the 0x0000004207f08020 thunk, evaluating y may change the contents of said thunk but not its pointer
05:32:04 <dmwit> How do you reconcile that claim with the followup that has an explicit type signature?
05:34:05 <dmwit> I think it's just that, because y is typeclass polymorphic, it's instantiated twice in the RHS. `seq y (f y)` doesn't ensure that the `y` in `f y` is evaluated.
05:35:30 <mniip> sounds legit
05:35:32 <dmwit> % readFile "foo2"
05:35:33 <yahb> dmwit: ""
05:35:40 <dmwit> % readFile "foo2" >>= withAddr Ptr
05:35:40 <yahb> dmwit: ; <interactive>:28:21: error:; * Couldn't match type `Ptr' with `IO'; Expected type: String -> IO b; Actual type: String -> Ptr b; * In the second argument of `(>>=)', namely `withAddr Ptr'; In the expression: readFile "foo2" >>= withAddr Ptr; In an equation for `it': it = readFile "foo2" >>= withAddr Ptr
05:35:46 <dmwit> % readFile "foo2" >>= print . withAddr Ptr
05:35:46 <yahb> dmwit: 0x0000004208b1c3c8
05:35:53 <dmwit> There we go, that one looks more convincing.
05:35:56 <dmwit> A second [].
05:36:01 <liste> does yahb have IO?
05:36:04 <dmwit> Oh, wait, is it lazy again?
05:36:19 <dmwit> % readFile "foo2" >>= \s -> s `seq` print (withAddr Ptr s)
05:36:20 <yahb> dmwit: 0x00007fe764a89670
05:36:27 <dmwit> haha, I am wrong again =)
05:37:04 <dmwit> I wonder if I made this same mistake when I was observing that there were multiple copies of some nullary-constructor'd type, and have just been carrying around this misconception for a while.
05:37:13 <mniip> the [] is a universal singleton. Once it has been revealed it can be hidden lost
05:37:22 <mniip> or lost*
05:37:38 <mniip> ughhh
05:37:43 <mniip> the [] is a universal singleton. Once it has been revealed it cannot be hidden or lost
05:46:13 <drets> I use servant and want to make `Capture "pin" Text` more type-safe, so I created newtype wrapper and use it like`Capture "pin" Pin`. Now ghc says there is no `FromHttpApiData Pin` instance. Should I write the instance manually or there is a smarter solution?
05:46:46 <Taneb> You could use GeneralizedNewtypeDeriving, maybe?
05:46:47 <c_wraith> you can probably use GeneralizedNewtypeDeriving
05:52:47 <drets> Thanks, remembered, that's the thing. Now ghc says Data.Swagger.Internal.ParamSchema.ToParamSchema :(
05:53:06 <drets> no instance for ^
05:53:20 <drets> Can I derive this instance too?
05:53:44 <c_wraith> Unless there are role annotations getting in the way, GND will work with anything
05:54:17 <c_wraith> So give it a try.  If you get error messages that don't make sense to you, that's the time to ask. :)
05:55:10 <drets> c_wraith, you are absolutely correct ;-)
06:01:48 <drets> newtype Pin = Pin Text deriving (FromHttpApiData, ToParamSchema) and now I got the error containing: NB: We cannot know what roles the parameters to `proxy' have; we must assume that the role is nominal.
06:01:59 <c_wraith> hey, role errors!
06:02:11 <drets> I am lucky ;)
06:03:06 <c_wraith> GND won't work with that class then.  You're going to have to write the instance yourself.
06:03:38 <drets> Hackage: Instead of manually writing your ToParamSchema instance you can use a default generic implementation of toParamSchema.
06:03:47 <c_wraith> ah
06:05:04 <c_wraith> It looks like it has good instructions
06:05:18 <c_wraith> Derive Generic, write a single-line instance
06:05:28 <drets> yeah, it compiles \0/
06:05:44 <c_wraith> nice
06:05:51 <drets> Now we are safe
06:05:57 <drets> type-safe
06:06:00 <drets> thanks :)
06:07:42 <dreamer_> heyo
06:07:45 <dreamer_> what is a better way to mix lenses and monads than this :  mX >>= (\x -> return $ x & record %~ f)
06:08:53 <Taneb> :t mapped
06:08:54 <lambdabot> (Functor f2, Settable f1) => (a -> f1 b) -> f2 a -> f1 (f2 b)
06:09:03 <c_wraith> give or take some parens, record %~ f <$> mX
06:09:05 <Taneb> dreamer_: mX & mapped.record %~ f
06:11:21 <dreamer_> thanks !
06:19:07 * hackage haskus-utils-types 1.0 - Haskus utility modules  http://hackage.haskell.org/package/haskus-utils-types-1.0 (SylvainHenry)
06:20:07 * hackage haskus-utils-data 1.0 - Haskus utility modules  http://hackage.haskell.org/package/haskus-utils-data-1.0 (SylvainHenry)
06:20:38 <revskill> I found MonadTransformer is exactly the Black Hole which Einstein researched long time ago
06:21:36 * hackage haskus-utils-variant 1.0 - Haskus utility modules  http://hackage.haskell.org/package/haskus-utils-variant-1.0 (SylvainHenry)
06:22:01 <c50a326> ah what's this called ⊥
06:22:05 <dminuoso> c50a326: bottom
06:23:03 <Boarders> data Void
06:23:07 * hackage haskus-utils 1.0 - Haskus utility modules  http://hackage.haskell.org/package/haskus-utils-1.0 (SylvainHenry)
06:24:03 <lavalike> can ghc cross compile binaries for different architectures/oses?
06:24:35 <cies> I do not understand the Dual/Endo types and how to work with them using lens operators in order to override "serviceEndpoint" in the Env of of the amazonka lib. Any help is much appreciated. -- here's a pastebin detailing the problem I have (code/error/details): https://pastebin.com/SH55Bncb
06:27:06 <dminuoso> lavalike: https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
06:28:22 <Gurkenglas> Let my try to rephrase the type error, cies: "envOverride . serviceEndpoint .~ newEndpoint" should be "foo . envOverride . serviceEndpoint .~ newEndpoint" where foo has type "Setter' (Dual (Endo a)) a"
06:30:06 <Gurkenglas> And I expect foo will have form "bar . baz" where bar and baz have respective types "Setter' (Dual a) a" and "Setter' (Endo a) a"
06:30:35 <Gurkenglas> For bar, this is easy enough: The wrapper only changes the monoid instance, so we have a canonical isomorphism
06:31:49 <Gurkenglas> "Setter' (Endo a) a" ~ "(a -> a) -> (Endo a -> Endo a)" ~ "(a -> a) -> ((a -> a) -> (a -> a))", which has more than one possible implementation
06:32:09 <cies> Gurkenglas: Hmmm... I'm still kind of lost. The type you mention for foo is not something I have laying around.  Closest is envOverride but that has a tyle starting with Lens' instead of Setter'
06:32:20 <Gurkenglas> Every Lens' is a Setter'
06:32:25 <cies> ok
06:33:45 <Gurkenglas> cies, would you like to set the serviceEndpoint to newEndpoint before or after the existing encoded transformation?
06:34:40 <cies> Gurkenglas: now sure what you mean by encoded transformation
06:34:58 <cies> but I need the endpoint to be overridden before I can use the API
06:35:21 <Gurkenglas> cies, me neither, I am trying to find whatever intuition you have for the values your code indicates
06:35:31 <Gurkenglas> Because the type seems to leave something ambiguous
06:35:59 <cies> lens is used here to simplify setting of some configuration for a connection
06:36:12 <cies> since there are a lot of options in configuring it
06:36:17 <Gurkenglas> cies, do you have non-lens code to compare against?
06:36:21 <cies> nope
06:36:43 <cies> the amazonka lib provides this config setting only with lenses
06:37:11 <Gurkenglas> cies, Endo a is a newtype wrapper for a -> a, and lens wants to know from you what you mean when you say "In this 'a -> a', set the a to this value"
06:37:51 <cies> hmm
06:37:59 <Gurkenglas> Because setting an a to a value is like a function "a -> a" that ignores the argument and sets to yours, and then we can interpret "In this 'a -> a', set the a to this value" as "replace the a -> a with setting constantly to this a"
06:38:19 <Gurkenglas> or "After the previous a -> a, set constantly to this a" (which turns out to mean the same)
06:38:28 <Gurkenglas> or "Before the previous a -> a, set constantly to this a"
06:38:57 <cies> hmm
06:39:09 <cies> it a bit like the line ofcode above
06:39:22 <cies> i set the logger to something
06:39:38 <cies> in this line i want to install an override
06:40:02 <Gurkenglas> Let me find that lens
06:40:08 <Gurkenglas> http://hackage.haskell.org/package/amazonka-1.6.0/docs/Control-Monad-Trans-AWS.html#v:envLogger
06:40:13 <Gurkenglas> http://hackage.haskell.org/package/amazonka-1.6.0/docs/Control-Monad-Trans-AWS.html#v:envOverride
06:40:17 <Gurkenglas> "The currently applied overrides to all Service configuration."
06:40:28 <cies> yups
06:40:32 <cies> that one
06:40:40 <Gurkenglas> We have previously existing Service -> Service overrides, you want to place a new override
06:41:03 <Gurkenglas> Do you want it to apply after the existing ones (invalidating them), or before the existing ones? (letting the previous ones fire after yours)
06:41:53 <lavalike> dminuoso: thanks
06:42:08 <fvr> Has anyone used MonadSTM and MonadConc and what are your thoughts regarding them?
06:42:15 <Gurkenglas> cies, looking at your paste, I would guess that there aren't any preexisting overrides?
06:42:36 * hackage haskus-binary 1.0 - Haskus binary format manipulation  http://hackage.haskell.org/package/haskus-binary-1.0 (SylvainHenry)
06:42:39 <Gurkenglas> If so, and the overrider is currently set to doing nothing in particular, it doesn't matter which of the above you do
06:43:14 <cies> ok
06:43:18 <Gurkenglas> cies, have you produced the code in your paste by working off some template?
06:43:34 <cies> So I have to add dome After or Before constructor is
06:43:35 <cies> in
06:43:44 <cies> Not really
06:44:01 <cies> I did have a look at this code: https://github.com/paramander/poc-yesod-s3/blob/master/main.hs
06:44:35 <cies> And without the envOverride line the code works
06:44:56 <cies> (errors out at runtime because it needs to override, but that is expects)
06:45:49 <Gurkenglas> cies, http://hackage.haskell.org/package/amazonka-1.6.0/docs/Control-Monad-Trans-AWS.html#v:configure looks like it provides an interface that it expects you want as long as you don't know why there's a "Service -> Service" function there rather than just a Service value
06:46:39 <Gurkenglas> cies, http://hackage.haskell.org/package/amazonka-1.6.0/docs/Control-Monad-Trans-AWS.html#v:override is exactly as powerful as giving you access to the Dual(Endo Service) value
06:48:26 <Gurkenglas> The source of override, http://hackage.haskell.org/package/amazonka-1.6.0/docs/src/Network.AWS.Env.html#override , illustrates how you could add an (Service -> Service) function to the previous overrides using lens jargon
06:48:59 <cies> i think i see a possible solution now without the lens operator
06:49:01 <cies> s
06:49:08 <cies> using configure
06:49:12 <cies> and <$>
06:49:31 <Gurkenglas> The code shows why "Dual" is there: (<>~) adds the new monoidal value to the right, and the library author thinks you usually want to add the monoidal values (compose the functions) in the non-default order
06:49:39 <Gurkenglas> (the code of override)
06:49:47 <cies> I'll have a look at it. Not sure I'll manage, but... thanks A LOT already for your help; much appreciated!!
06:50:57 <Gurkenglas> (Man, looks like I've come a long way - I look at a lens error, know what it means, look at some new library that uses lens, know what it wants, etc)
06:51:38 <Gurkenglas> (compare grep lens gurkenglas in channel logs or something xP)
06:51:47 <cies> Gurkenglas: <>~ is the way to do it prolly, but I've grown a bit scared of lenses and their compile errors when not gettting them right
06:52:39 <Gurkenglas> I understand. There ought to be an automatic translator of lens errors into at least the form i gave
06:54:51 <Gurkenglas> A tool that modifies your code "as little as possible" to make it compile, with permission to use _ so long as their types are "simple"...
06:55:15 <Gurkenglas> Where "forall a. a" does not count as simple, but types that can be expressed using existing type aliases do
06:56:32 <Gurkenglas> But "forall a. a -> a" does count - perhaps that which scores types for "simplicity" could call exference and see whether it's inhabited/provably uninhabited?
06:56:46 <Gurkenglas> (exference and djinn etc)
06:56:54 <quicksilver> I think it's very hard but I'd love to see some experiments :)
06:57:27 <quicksilver> I see the type errors as a real practical issue with lens, and I haven't even tried to use it in anything 'big'
06:58:08 <Gurkenglas> An online service that places bounties on lens errors to have people like me translate them into more readable form...
06:58:18 <drets> I have `check :: Int -> IO Bool` and the array of `Int` s. I want to perform IO action for every element of the array till `check` gives me “`True`” then performAnotherAction, or if `check` never returns “`True`” do somethingElse.
06:58:34 <Gurkenglas> drets, Control.Monad.Loops implements many such patterns
06:58:59 <Gurkenglas> @import Control.Monad.Loops
06:58:59 <lambdabot> Unknown command, try @list
06:59:19 <Gurkenglas> In this case, orM :: Monad m => [m Bool] -> m Bool
06:59:21 <Gurkenglas> @let import Control.Monad.Loops
06:59:23 <lambdabot>  Defined.
06:59:56 <drets> nice, danke.
07:00:20 <Gurkenglas> :t do b <- orM $ map ?check [1..10]; if b then ?performAnotherAction; else ?somethingElse
07:00:21 <lambdabot> (?somethingElse::m b, ?performAnotherAction::m b, ?check::a -> m Bool, Enum a, Num a, Monad m) => m b
07:01:36 <drets> Oh, I need to install monad-loops package for that, okay.
07:01:44 <Gurkenglas> There should be something like "@let Num a `implies` a ~ Int" which makes [1..10] automatically check as [Int]
07:01:51 <Gurkenglas> till the next @undefine
07:01:57 <quicksilver> Gurkenglas: that doesn't shortcircuit the actions
07:02:01 <Gurkenglas> quicksilver, sure does
07:02:05 <quicksilver> or ... yes
07:02:12 <quicksilver> as you were :)
07:04:23 <Gurkenglas> drets, imo if "I need to install x for that" is a problem you should throw effort at making that never be a problem
07:04:44 <ij> is there an established name for fmap . fmap?
07:04:49 <drets> could you elaborate?
07:04:55 <Gurkenglas> ij, Data.Functor.Compose captures that
07:05:37 <Gurkenglas> drets, non-base packages contain many useful Haskell features and if you limit yourself not to use them you'll have a ceiling on how far you can go in the direction that made you prefer Haskell to Java in the first place
07:05:58 <ij> Ha! I just read about that, but "see" it in this case.
07:06:16 <drets> Gurkenglas, thanks for the tip.
07:06:41 <Gurkenglas> ij, I've heard it called .:, in the same sense that . is fmap
07:06:48 <Gurkenglas> (.:), not (.:,)
07:06:50 <drets> It's not the problem to me, I am just not allowed to use package which is not on stackage :)
07:07:19 <ij> Gurkenglas, I would've imagined it's <$$>
07:07:25 <Gurkenglas> monad-loops is not on stackage? Someone should address that.
07:07:30 <drets> No, no.
07:07:32 <drets> It is.
07:08:03 <drets> But I checked it after writing that message :)
07:08:28 <drets> Never mind, thank you :)
07:08:42 <rotaerk> it bothers me that the 'monad-loops' and 'extra' packages both have definitions of, say, whileM, but the signatures are different
07:09:27 <Gurkenglas> Ah. I suppose you could do worse than making the tradeoff between being able to convince your superiors and having as much space in the (Java->Haskell) direction as possible at stackage.
07:10:36 <Gurkenglas> rotaerk, the general solution is to have combinators instead that let you construct what those two libraries do
07:11:00 <Gurkenglas> Like a framework centered MaybeT, which encapsulates short-circuiting
07:11:05 <Gurkenglas> centered around
07:11:37 * hackage Agda 2.5.4.1 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.5.4.1 (AndresSicardRamirez)
07:11:43 <Gurkenglas> See manyLazy and PointedAlternative in the haskell logs, talked of that a bunch of times
07:12:00 <Gurkenglas> Anyone want maintainership of PointedAlternative? It was rather a stillbirth with the executive function available to me
07:12:14 <Thrush> Hello!  I'm new to learning Haskell, and I have a question concerning functions that return functions.
07:12:38 <rotaerk> ask away
07:12:49 <Gurkenglas> Thrush, general etiquette around here is to have your lines include enough information to let people start answering immediately
07:14:10 <Thrush> So, one of the projects I like to do to familiarize myself with a new language is to write a function that returns a linear function.  (I've done this in Perl, Python, and Ruby with closures.) ... (continued)
07:14:59 <Thrush> The first function takes (x1, y1) and (x2, y2) as input, and returns a new function that takes x as input, and returns y.
07:15:30 <Gurkenglas> Would you like an implementation that does what you want or enough of a hint to allow you to write it?
07:16:11 <Thrush> So I could do something like:  fToC = createLinearFunction(32,0 , -40,-40) and then I can call degreesC = fToC(212).
07:16:18 <Thrush> Let me explain a bit further...
07:16:30 <Thrush> So, I was thinking, that in Haskell, I could do this:
07:16:55 <Thrush> I could create a function with this signature:  Double -> Double -> Double -> Double -> Double -> Double
07:17:13 <rotaerk> right
07:17:17 <Gurkenglas> Yep, though I would structure the type as (Double, Double) -> (Double, Double) -> (Double -> Double)
07:17:35 <rotaerk> the last pair of parentheses are unnecessary
07:17:45 <Thrush> And then call it like this:  fToC = createLinearFunction 32 0 (-40) (-40)
07:17:59 <inkbottle> [intero]: The issue I had lately with emacs/intero not working was due to the emacs-script there [https://commercialhaskell.github.io/intero/], was silently ignoring the latest version, until I did `rm -r ~/.emacs.d/elpa/intero-20180117.921`; after that the emacs-script did upgrade the "melpa" package to the latest version. (it has been very annoying)
07:17:59 <Gurkenglas> Indeed. They are there to show the reader that I imagine the (Double -> Double) as a value in its own right
07:18:05 <Thrush> That way, I could call fToC 98.6 and it would return 37.
07:18:21 <Gurkenglas> Thrush, that would work. What is your question? :(
07:19:20 <elben> Is this comment true about hie, that it doesn’t support “show me the type of an arbitrary expression”? https://github.com/DanielG/ghc-mod/issues/900#issuecomment-396045668 I’ve been “stuck” on ghc 8.0 because I don’t want to screw up my great setup on vim + ghc-mod to get types of arbitary expressions. I’ve tried to move a project over to ghc 8.4 + hie + vscode, but the “show me the type” feature doesn’t work 100% o
07:19:20 <elben> the time for some reason, and I havent’ been able to show the of type an arbitrary expressions
07:19:49 <Thrush> Now, in Perl, Python, and Ruby, I apply the linear formula y = m * x + b to figure out m (the slope) and b (the y-intercept) in the first function, and then return the second function (that uses m and b).  In that way, the second function does not have to re-calculate m and b every time.
07:20:03 <rotaerk> elben, have you tried ghcid? it's a fairly low-tech solution, but it works nicely
07:20:17 <Thrush> So I can call the second function hundreds of times, and it never has to recalculate m and b.
07:20:36 <Gurkenglas> Thrush, you want to introduce the fifth Double argument using a lambda after you have calcualted m and b
07:20:40 <rotaerk> and it's more resilient to change than ghc-mod and such
07:21:05 <rotaerk> you can use _s to get ghcid to spit out the inferred type of something
07:21:14 <Gurkenglas> thrush x1 y1 x2 y2 = let m = ...; b = ... in \x -> …
07:21:43 <Thrush> So, if I were to use the six-argument approach in Haskell, by calling the function with four arguments to return a new function that returns two, my question is:  Does the new function recalculate m and b every time it is called, or never again?
07:21:50 <rotaerk> anyway, gotta go
07:22:35 <Thrush> In other words, if I call the new two-argument function hundreds of times, do m and b also get recalculated hundreds of time, or is the calculation only done once?
07:22:39 <barrucadu> Thrush: If you use a let like Gurkenglas suggested, it definitely won't re-caclulate
07:22:44 <Gurkenglas> Thrush, do my last two lines answer your question?
07:22:48 <barrucadu> If you don't, I suspect GHC will optimise it anyway
07:23:40 <elben> rotaerk: no, I haven’t heard of ghcid
07:23:44 <Gurkenglas> barrucadu, huh? Can anyone link to the ghc optimizer code that would do this step?
07:23:45 <Thrush> barrucadu & Gurkenglas:  I'm trying to figure out those two lines.
07:24:15 <barrucadu> Gurkenglas: I thought floating out bits of a function body which don't depend on all the arguments was a thing it just did?
07:24:41 <Gurkenglas> barrucadu, sounds like a thing you would only want to happen if nobody's using unsafe*
07:24:42 <quicksilver> yes, it is.
07:24:54 <quicksilver> let-floating is a thing that GHC will do.
07:24:54 <Thrush> So what would the signature of my creatorFunction look like?
07:25:12 <Gurkenglas> Thrush, that information is not contained in the type
07:25:28 <quicksilver> but explicitly putting the let at a higher level is safer.
07:25:49 <quicksilver> Worth pointing out I think that Thrush's question is an implementation question. 'haskell' doesn't specify so we're really just discussing what GHC does.
07:26:44 <Thrush> So would there be two separate functions?  Or just one?  I'm not sure I understand.
07:27:26 <Gurkenglas> Thrush, the distinction doesn't really matter, and function with two arguments can be seen as a function with one argument returning a function with one argument. (see "currying")
07:27:34 <Gurkenglas> -"and function"+"any function"
07:28:05 <barrucadu> f :: Double -> Double -> Double -> Double -> Double -> Double; f x1 y1 x2 y2 = let m = ...; b = ... in \x -> ...
07:28:09 <Gurkenglas> (Is there an IRC client that automatically turns lines like '-"and function"+"any function"' into a visible edit of previous lines?)
07:29:36 <fresheyeball> sup haskell homies
07:30:15 <Thrush> So, what barrucadu is saying is that I can return a straight lambda expression, which fits the last two Doubles?
07:30:24 <Cale> Thrush: It'll just be your createLinearFunction
07:30:29 <barrucadu> Yep
07:30:49 <Thrush> Okay, that makes sense.  I think.
07:30:54 <butterthebuddha> Is there a language extension for vector literals (for Data.Vector)
07:30:58 <fresheyeball> what yall use for migrations these days?
07:31:15 <fresheyeball> beam-migration is immature, and persistent migrations are not great
07:32:24 <dmwit> Gurkenglas: Not that I know of. I think it would be kind of hard; people use too many different (and often ambiguous) syntaxes.
07:32:39 <Thrush> As for my original approach (when I don't return a lambda), would that still calculate m and b every time I called the newFunction?
07:32:54 <dmwit> Gurkenglas: e.g. I've seen s/foo/bar/ as well, and just *bar when it's obvious (...to a human, anyway) what foo should be.
07:33:04 <dmwit> And there's probably others.
07:33:17 <dminuoso> Thrush: You may want to get used to calling it function application as opposed to "calling"
07:33:50 <dmwit> butterthebuddha: There's one that make list syntax be a call to fromList.
07:33:59 <revskill> How to convert Reader r a to ReaderT r m a ?
07:34:06 <dmwit> butterthebuddha: OverloadedLists
07:34:06 <Taneb> Thrush: your original approach would depend on compiler optimizations
07:34:07 <Thrush> Thanks, dminuoso.  As for function "signatures" (like Int -> Int), am I calling that by the correct name?
07:34:21 <butterthebuddha> dmwit: Thanks!
07:34:34 <dminuoso> Thrush: That's probably fine, type annotation is more common.
07:34:50 <Thrush> Thanks, dminuoso.
07:35:34 <Thrush> One more quick question:  Is there a way to do simple GUI programming (like button and input widgets) using Haskell Platform?
07:35:49 <dmwit> I would call it an annotation when it's in an expression, and a signature when it's in a declaration.
07:36:18 <Thrush> Wow... so much to learn!
07:36:21 <dmwit> e.g. `let x :: Foo; x = ...` is a signature, `let x = ... :: Foo` is an annotation.
07:36:47 <dmwit> But I don't think getting the name exactly right matters very much for this most of the time.
07:37:07 <dmwit> For GUIs: if you already know a GUI library from another language, I recommend seeking out bindings to that library.
07:37:09 <fresheyeball> Thrush: I recommend this one https://hackage.haskell.org/package/fltkhs
07:37:19 <dmwit> Otherwise I've heard good things about gloss as a starting point for its simplicity.
07:37:49 <fresheyeball> dmwit: gloss is the wrong move if you just want a form. You will have to build inputs from scratch opengl.
07:37:55 <Thrush> I've used Tk widgets in other languages, though I have no idea how to go about it in Haskell.
07:37:58 <Cale> Thrush: You might want to check out reflex-dom (via reflex-platform) for gui programming.
07:38:02 <dminuoso> dmwit: interesting the haskell report uses "type signature" exclusively.
07:38:14 <Taneb> Thrush: there's not really a super simple way for doing GUI programming in Haskell
07:38:22 <Cale> It can build desktop applications as well as web pages and mobile apps.
07:38:26 <Taneb> There's a bunch of not-quite super simple ways, though!
07:38:41 <dminuoso> dmwit: TIL =)
07:38:46 <dmwit> dminuoso: Ah, neat.
07:39:43 <fresheyeball> Thrush: I would call this as simple as it gets for a quick gui form https://github.com/deech/fltkhs-demos/blob/master/src/Examples/texteditor-simple.hs
07:39:56 <Cale> https://github.com/reflex-frp/reflex-platform -- there's a little tutorial here -- it's not the *most* beginner-friendly thing, but it's worth checking out.
07:39:59 <fresheyeball> Thrush: Cale is right if you want to do web based GUI
07:40:12 <dmwit> Bummer, the only Tk bindings I can find look like they haven't been updated in a long time.
07:40:15 <fresheyeball> Miso is also good or web based UI
07:40:25 <Thrush> Do I install reflex-platform with "cabal install reflex-dom" ?  I'm seeing that it has trouble fulfilling the goals base and reflex-dom.
07:40:45 <fresheyeball> Thrush: to use reflex-platform you have to buy into nix, and ghcjs.
07:40:52 <dmwit> Thrush: Have you ever run `cabal update`? If not, you must do that once.
07:40:57 <fresheyeball> which is why I think my approach is "simpler"
07:41:04 <Cale> Not just web-based -- you can compile with ghc rather than ghcjs and get a desktop application compiled to native code (which uses a webview widget for actual display, but the contents of the DOM are controlled by native code)
07:41:17 <bodisiw> does any IDE work well with ghcjs?  i tried miso and liked it, but it seemed to bork up vscode+hie
07:41:43 <dmj`> bodisiw: that’s an issue with GHCJS itself
07:41:56 <dminuoso> :t reader . runReader
07:41:58 <lambdabot> MonadReader r m => Reader r a -> m a
07:41:59 <dminuoso> revskill: ^-
07:41:59 <bodisiw> so it would apply equally to reflex as miso
07:42:14 <dmj`> Thrush: reflex-DOM lets you build for mobile, but it doesn’t take advantage of native components. It just runs your website in a web view.
07:42:25 <revskill> dminuoso: Thanks !
07:42:40 <dmj`> bodisiw: reflex-dom uses a project called jsaddle to stub out all the DOM manipulation so you can run it on GHC
07:42:41 <Cale> dmj`: Right, but it's not running javascript in that case
07:42:47 <revskill> i need to convert withReader to myWithReader, but my godness, there're exist withReaderT
07:42:53 <dminuoso> revskill: Is the Reader thing under your control?
07:42:56 <revskill> ^_~!
07:43:08 <Cale> (at least, not very much javascript, unless you explicitly include some)
07:43:09 <dmj`> Cale: it’s still using some javascript to render iiuc
07:43:10 <cies> Gurkenglas: I got it to work, once again: thanks a million!
07:43:14 <bodisiw> ah cool, maybe it is time for me to give reflex another look
07:43:24 <revskill> dminuoso: what do you mean by under my control ?
07:43:35 <dmj`> Cale: but reflex-DOM when compiled for the phone won’t use things like a native UIView or IOS date picker
07:43:36 <revskill> :t reader
07:43:38 <lambdabot> MonadReader r m => (r -> a) -> m a
07:43:41 <dminuoso> revskill: Well you can use `withReaderT`
07:43:58 <Cale> yeah
07:44:16 <Cale> I think there's some reflex-based work in that direction
07:44:18 <Thrush> dmwit, Yes, I've done a "cabal update".
07:44:29 <dmj`> Cale: reflex-DOM being truly “native” is oversold imo, and miso’s prerendering on the phone is extremely fast. Probably can open https://haskell-miso.org in safari just as fast
07:44:40 <dmj`> Cale: I’ve noticed yea
07:44:40 <dminuoso> revskill: Generally with monad transformers you can recover the original monads from the transformer. For example `type Reader r = ReaderT r Identity`
07:44:45 <Thrush> (Cabal was very nice in telling me I had to do a "cabal update".)
07:45:08 <revskill> dminuoso:  my monad is type MyRWT m = ReaderT [P.String] (WriterT P.String m)
07:45:46 <revskill> i generalize the base monad
07:46:00 <dminuoso> revskill: Not sure what this has to do with a plain `Reader`
07:46:25 <revskill> to lift withReader to MyRWT m
07:46:36 <revskill> withReader works with Reader r a only
07:46:46 <dminuoso> revskill: withReader is the specialized form.
07:46:51 <dminuoso> :t withReaderT
07:46:52 <lambdabot> forall k r' r (m :: k -> *) (a :: k). (r' -> r) -> ReaderT r m a -> ReaderT r' m a
07:47:03 <revskill> yeah, i discover withReaderT with hoogle
07:47:04 <dminuoso> (Dont let the type signature scare you away)
07:47:19 <Cale> dmj`: Our apps actually run faster on the phone in some cases than they do on desktop in a browser, lol
07:47:23 <revskill> hoogle is simpler
07:47:24 <revskill> Control.Monad.Reader withReaderT :: () => r' -> r -> ReaderT r m a -> ReaderT r' m a
07:47:25 <dminuoso> revskill: You might be intested in also looking at the documentation on hackage.
07:47:56 <revskill> withReaderT is live-saver (-.-)
07:47:56 <fresheyeball> lambdabot: you soo coo;
07:47:59 <fresheyeball> lambdabot: you soo cool
07:48:23 <drets> If I have encoded query param as a Text how can I decode it?
07:48:49 <fresheyeball> drets: how did you get it?
07:48:53 <dminuoso> :t fmap
07:48:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:49:10 <drets> frontend, servant, capture...
07:49:29 <fresheyeball> drets, then servant should have decoded it for you
07:49:32 <fresheyeball> dont use capture
07:49:38 <fresheyeball> use QueryParam
07:49:47 <fresheyeball> let Servant do that work
07:50:15 <fresheyeball> http://hackage.haskell.org/package/servant-0.14.1/docs/Servant-API-QueryParam.html#t:QueryParam
07:50:18 <fresheyeball> drets: ^^
07:50:37 <dmj`> Cale: Not sure how that is measured, but cool. Pre-rendering and browser caching should make the entire experience instantaneous
07:50:51 <drets> Thanks, hm why we need Capture then?
07:51:09 <fresheyeball> drets: because you might want a url segment
07:51:11 <fresheyeball> for example
07:51:21 <drets> Good, got it, thank you.
07:51:21 <fresheyeball> /foo/13?bar=hi
07:51:36 <Cale> dmj`: We do pre-rendering in some cases as well, but there may be a delay before pre-rendered content becomes "live" in such cases.
07:51:52 <fresheyeball> might be "foo" :> Capture "fooId" :> QueryParam "bar" :> GET ...
07:52:33 <Thrush> I have to go now, but thank you to everyone for all your help!
07:52:54 <drets> fresheyeball, thank you.
07:53:01 <fresheyeball> drets: :*
07:53:43 <Cale> You can just use reflex-dom on the backend to run your same frontend code with the StaticDomBuilder, and that'll get you some HTML that you can ship over, pretty much.
07:53:54 <dmj`> Cale: yes, the server will send the HTML to the client, but then reflex-DOM will have to destroy the DOM and repaint it. So there will be a blink. This is because an expression graph doesn’t have a 1-1 correspondance with the DOM.
07:54:33 <fresheyeball> Virtual dom solves this
07:54:40 <Cale> dmj`: There are a bunch of tricks for that. I haven't used pre-rendering for the entire page yet.
07:54:56 <Cale> Just for pages of content inside an app (e.g. chat channels)
07:55:40 <fresheyeball> Thats a major issue I have with reflex, everything that virtual dom just gives, is addressed by "a bunch of tricks", usually on some unreleased undocumented branch
07:55:53 <dmj`> Cale: there’s no way around it but having a data structure that is isomorphic to a rose tree. Since a dom node lives inside a monadic expression, it’s not a static data structure, it will always have to be generated dynamically
07:57:12 <Cale> Well, if you don't care about the DOM nodes actually being identified between the static and live ones, it's easier.
07:57:52 <Cale> You can just have your static pre-rendered content in a separate div which is stacked with the live one, and when the live content gets filled in, it just covers the static stuff.
07:58:38 <dmj`> Cale: Well, there’s no reason to redraw the page twice imo.
07:59:30 <dmj`> Cale: the browser has already parsed the HTML into the DOM, you just have to make the virtual DOM privvy to it
07:59:41 <chreekat> Can I make hlint just give me its warnings rather than its suggestions? -o restricts to particular hints, but some hints (or maybe just 'Avoid lambda') can be both warnings and suggestions
08:00:01 <fresheyeball> There are also techniques like morph that have this property and feel like a natural successor to vdom
08:00:24 <__monty__> Has anyone done mdns from haskell? All I want to do is resolve A records for .local domains.
08:00:31 <fresheyeball> chreekat: checkout the .hlint.yml docs
08:02:01 <fresheyeball> Cale: what do you use for migrations?
08:03:33 <Cale> fresheyeball: DB migrations? Some of our apps are using (an in-house modified version of) Groundhog for that, which is not great, but it does a reasonable enough job of ensuring that the DB is in the intended shape before our backend is running at least.
08:04:55 <Cale> There's some stuff in Beam that we've been considering using, and then there's a new system of migrations that Ryan's been working on (Obelisk has started using it experimentally in a couple of trivial ways) which will be used across DB migrations, protocol migrations and a bunch of other stuff
08:05:26 <Gurkenglas_> Can I ask TH what type would be inferred for a _ in a code block?
08:05:51 <fresheyeball> Cale: I tried out beam-migrate, its just not mature, no way to specifiy indexes, auto increment is not respected, ect...
08:06:34 <Boarders> doesn't type holes does tell you the type?
08:06:50 <Boarders> does -> just*
08:07:19 <Cale> Boarders: The question is whether you can get TH to tell you the type inside compile-time code.
08:07:25 <Cale> I doubt it, myself
08:07:44 <Cale> (but I'd be interested to know as well)
08:07:54 <Boarders> interesting
08:08:05 <Cale> fresheyeball: All database stuff just sucks, we're going to fix it eventually ;)
08:10:03 <lukelau> Is there a way to have a thread kill its child threads if itself gets killed?
08:10:26 <Cale> lukelau: Async can do that kind of thing
08:10:39 <Cale> (but not with just plain forkIO'ed threads)
08:10:42 <lukelau> Cale: awesome, will look into it!
08:11:36 * hackage haskus-system-build 1.0 - Haskus system build tool  http://hackage.haskell.org/package/haskus-system-build-1.0 (SylvainHenry)
08:16:18 <revskill> In math, the 0 is not solution of equation m * c(1/m) = 0
08:17:08 <revskill> But in Haskell, let c(x) = 1 in m * (c * (1/m))  always returns 0 if m = 0
08:17:25 <revskill> so Haskell is real Math, the math we learnt is not math
08:17:52 <Cale> ...
08:18:00 <Cale> > 0 * 1 * (1/0)
08:18:03 <lambdabot>  NaN
08:18:21 <mniip> did you mean to say
08:18:26 <Cale> Floating point arithmetic says otherwise
08:18:28 <mniip> m * (c (1 / m))
08:18:34 <revskill> yah
08:18:43 <mniip> that's because c is non-strict
08:19:00 <mniip> we could emulate this in math by setting 1 / m = _|_
08:19:00 <revskill> so mathematics is strict
08:19:04 <mniip> which is allowed by the field axioms
08:19:22 <mniip> (field axioms only concern x / y where y != 0)
08:19:45 <mniip> and c is non-strict because  c _|_ = 0
08:20:54 <Cale> Well, trying to include _|_ will make the field axioms unsatisfiable
08:20:57 <mniip> true
08:21:12 <mniip> the field is only the non-bottom subset of the type
08:21:51 <mniip> we could say  (^-1) :: R \ {0} -> R
08:22:08 <mniip> can't say that in a type theory though, so have to make do with   R -> Maybe R
08:22:15 <fresheyeball> Cale: :( why can't it be fixed now :( :(
08:22:26 <mniip> with the added axiom that x^-1 = Nothing <=> x=0
08:23:16 <revskill> it reminds me of complex numbers
08:23:18 <revskill> i^2 = 1
08:23:23 <revskill> i^2 = -1
08:23:29 <fresheyeball> Cale: Is there an entitled haskeller meme?
08:23:41 <fresheyeball> WAAAA, It should be solved before I got here, WAAAA
08:24:03 <mniip> fresheyeball, what's the fun living in a world where everything worth doing is already done
08:24:13 <barrucadu> revskill: i^2 is definitely not 1
08:24:31 <revskill> barrucadu: i fixed i^2 = -1
08:24:37 <revskill> it's the same as 1/x = Nothing
08:24:43 <mniip> C is just a quadratic extension over R:  R[x]/(x^2+1=0)
08:24:44 <revskill> ah, 1/0 = Nothing
08:25:09 <revskill> So Maybe is just a field in Maths (-.-)
08:25:19 <mniip> is not
08:25:21 <barrucadu> I don't quite see the problem with c(1/0) where c is some constant function.  Is the issue that "c(1/0)" contains a nonsense term, therefore the whole expression must be nonsense?
08:25:53 <revskill> mniip: if you define 1/0 = Nothing, it's the same as defining i^2 = -1 ?
08:25:56 <Cale> Yeah, usually in mathematics, you wouldn't have been allowed to write 1/0 in the first place
08:25:58 <mniip> no
08:26:10 <mniip> Cale, barrucadu, I say that depends on your foundational axioms
08:26:29 <mniip> in some sources the field axioms let you define 1/0 to be anything you want and it would be a valid field
08:26:42 <barrucadu> Yeah, I'm wondering what problems arise if you allow nonsense terms as long as they're not "used" (whatever that means)
08:26:46 <Cale> Sure, I mean, typically, (1,0) isn't in the domain of the division function
08:26:52 <mniip> then indeed 0 * (1/0) = 0
08:27:04 <mniip> and  x * (1 / x) = 0   has solution x=0
08:27:25 <Cale> I've never seen such a definition of fields.
08:27:45 <Cale> Certainly this isn't the case for most places where fields are described
08:28:12 <fresheyeball> mniip: I think that is a type error
08:28:37 <fresheyeball> the usage of / does not work on fractionals, only non-zero fractionals, its a different type
08:28:49 <mniip> well you can say that in a set theory
08:28:49 <fresheyeball> no?
08:28:57 <mniip> but not in a type theory
08:29:15 <fresheyeball> I can't say non-zero fractionals as a type? I think I can.
08:29:38 <mniip> 1 :: R;  1 :: R \ {0}
08:29:41 <mniip> you have to choose one
08:30:21 <fresheyeball> (/) :: (Fractional n, NonZero n) => n -> n -> n
08:30:45 <revskill> :t (/)
08:30:46 <lambdabot> Fractional a => a -> a -> a
08:31:02 <mniip> fresheyeball, that type makes no sense
08:31:12 <fresheyeball> how about this one?
08:31:35 <fresheyeball> (/) :: Fractional n => {n /= 0 } -> n -> n -> n
08:31:43 <fresheyeball> dependent types!
08:31:45 <mniip> still odesn't make sense
08:31:50 <glguy> You're willing to exclude dividing 0 by 1 ?
08:32:07 <mniip> what you *could* do is introduce filter types
08:32:10 <fresheyeball> ah I see now
08:32:19 <fresheyeball> then like this
08:32:44 <mniip> with construction axiom  A -> (A \ P + A)
08:32:47 <fresheyeball> (/) :: Fractional n => {x /= 0} -> n -> (x : n) -> n
08:32:54 <fresheyeball> there
08:33:04 <mniip> with property that if P(x) then  construct x = inl x
08:33:22 <mniip> or rather, not that,
08:33:28 <mniip> well you could make this sound anyway
08:33:49 <fresheyeball> (/) :: Fractional n => { x /= 0 } -> n -> (x :: n) -> n
08:34:04 <fresheyeball> totally possible to describe this as a type
08:34:49 <mniip> not in that order
08:37:45 <fresheyeball> I guess I just think that the type of / is complex and using the forall x. x * (1 / x) = 0 axiom with x = 0 is a type error
08:37:52 <revskill> type NonZero a = NonZero (NonEmpty a) a
08:37:57 <revskill> is this ok ?
08:38:21 <glguy> revskill: No. Did you mean to use 'data' instead of 'type'?
08:38:28 <revskill> you represent 1 as [1] 1, 2 as [1,1] 2
08:38:37 <revskill> glguy: Yeah, yup
08:38:50 <fresheyeball> revskill: how about negatives?
08:39:02 <revskill> fresheyeball: negative is just : -1 as [1] -1
08:39:18 <revskill> NonEmpty list allows us to encode NonZero thing, right ?
08:39:48 <fresheyeball> revskill: there are a ton of ways we can encode a NonZero thing
08:40:18 <fresheyeball> but the point is also clear that we dont want to exclude (0 / 1) so its important that the numerator be allowed to be zero
08:40:34 <fresheyeball> which is why I had to resort to dependent types to make my point
08:40:52 <fresheyeball> Its a nice resort though, they hav mojitos
08:41:00 <revskill> fresheyeball: you mean return type might depend on value of input ?
08:41:23 <fresheyeball> revskill: in this case the input of one arguement is restricted to be non-zero
08:41:39 <fresheyeball> revskill: dependent types are not just about codomains
08:45:00 <fresheyeball> Man I love you guys
08:45:11 <fresheyeball> I was so frustred being a UX guy
08:46:08 * hackage sitepipe 0.3.0.1 - A simple to understand static site generator  http://hackage.haskell.org/package/sitepipe-0.3.0.1 (ChrisPenner)
09:01:15 <robrob> I'm looking for a _simple_ xml library for parsing and creating xml documents, can someone suggest one ?
09:03:00 <reactormonk> robrob, I've been digging, all of them are mediocre one way or another
09:04:16 <robrob> reactormonk: thank you, i saw hexpat ... maybe i will go with it
09:06:37 * hackage JuicyPixels-extra 0.4.0 - Efficiently scale, crop, flip images with JuicyPixels  http://hackage.haskell.org/package/JuicyPixels-extra-0.4.0 (mrkkrp)
09:08:08 <reactormonk> robrob, using xml conduit here
09:09:43 <noipmups> In mtl, does it matter in which order I'll stack for example ReaderT and StateT?
09:10:06 * hackage non-empty 0.3.0.1 - List-like structures with static restrictions on the number of elements  http://hackage.haskell.org/package/non-empty-0.3.0.1 (HenningThielemann)
09:10:17 <revskill> noipmups: i think no. Because the ReaderT has no impact on result type
09:10:29 <reactormonk> noipmups, yeah. That's why some people recommend only ReaderT https://www.fpcomplete.com/blog/2017/06/readert-design-pattern
09:12:07 <butterthebuddha> Does the cereal package encode in big endian or little endian?
09:12:50 <reactormonk> Does SOP have something where I can transform '[Int, Int, String] to '[m Int, m Int, m String] ?
09:13:13 <noipmups> reactormonk: That's eye opening. Thanks.
09:13:59 <butterthebuddha> reactormonk: What's SOP? That looks like a simple map to me, but I guessing I'm grossly misunderstand what you're trying to do?
09:14:26 <butterthebuddha> I'm*
09:15:11 <butterthebuddha> Oh wait nvm, not what I thought it was
09:18:37 * hackage html-parse 0.2.0.2 - A high-performance HTML tokenizer  http://hackage.haskell.org/package/html-parse-0.2.0.2 (BenGamari)
09:23:20 <tieTYT> OK i’m still confused about something.  Applicative has this: `    (<*>) :: f (a -> b) -> f a -> f b  `. But you can do this: `pure (+) <*> Just 3 <*> Just 5`.  `:t pure (+)` is `f (a -> a -> a)`.  So why can you do <*> with that?  It’s of (a -> a -> a), not of (a -> b)
09:24:31 <mniip> tieTYT, did you know a -> a -> a  means a -> (a -> a)
09:24:47 <tieTYT> yes.  So it’s currying.  OK makes sense
09:24:57 <tieTYT> just like how I can do `map (+) [1,2,3]`
09:25:11 <mniip>  It’s of (a -> a -> a), not of (a -> b)
09:25:16 <mniip> (quoting you)
09:25:20 <mniip> what if I told you,  b = (a -> a)
09:25:30 <tieTYT> makes sense.  Thanks
09:30:17 <infinisil> Anybody know which package has the GenList type constructor?
09:30:33 <infinisil> Should be something quickcheck related, but I can't find GenList
09:31:07 <infinisil> Wait, tasty maybe
09:31:12 <quicksilver> hey, I found a picture of mniip https://imgflip.com/i/2ebkai
09:31:39 <mniip> is this one of those "may mays"
09:31:56 <quicksilver> something like that, sir
09:38:02 <infinisil> Ohhh it's from generic-random
10:34:05 <Boarders> Hi could someone tell me which online version of hoogle is recommended?
10:39:47 <infinisil> Boarders: I prefer http://hayoo.fh-wedel.de/
10:40:17 <geekosaur> depends on what you're doing. haskell.org/hoogle has working type search; hoogle.haskell.org has a more up to date database
10:40:31 <geekosaur> but I too have preferred hayoo for a while
10:41:20 <dyl> I'm amazed we don't have HaskJeeves yet.
10:47:46 <Boarders> does anyone know any resources on testing across a typeclass?
10:48:54 <Boarders> @infinisil, geekosaur: thanks!
10:48:54 <lambdabot> Unknown command, try @list
10:55:25 <Boarders> like for instance if I were testing something that accepts an applicative or traversable or whatever, how do people usually approach it?
10:55:36 * hackage git-annex 6.20180719 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-6.20180719 (JoeyHess)
10:57:14 <reactormonk> kosmikus, if you've got some time, does SOP have something where I can transform NP I '[Int, Int, String] to NP I '[m Int, m Int, m String] ?
11:00:51 <alx741> hello everyone. I'm working with servant, and wondering if is there a builtin way for API versioning? Or what would be a sensible way of doing so
11:03:08 <alp> no, there isn't a standard thing to do it for you, because people do it in all sorts of different ways =) we just let users handle that
11:04:10 <[exa]> alx741: versions of interfaces are evil!
11:05:18 <alx741> alp: any recommendation before i screw my code base my own way? :)
11:05:48 <alx741> [exa]: how so?
11:06:54 <alp> alx741, depends on your needs!
11:07:18 <[exa]> alx741: see, for what purpose are you planning to use the versioning?
11:07:21 <alp> I have to go for a while though, but feel free top hop on the much lower volume #servant channel if you want to discuss this later :)
11:07:42 <alp> but yeah, I'll need to know about your needs, how you'd like things to work.
11:08:22 <alx741> Well, I have an Android app that will consume it, I want to version it in such a way that a braking chance in the API wont break the app on phones that haven't yet updated to the current version (the one that uses the new API)
11:08:37 <alx741> s/chance/change
11:08:44 <[exa]> do you mean breaking change
11:09:18 <alx741> alp: thanks!
11:10:28 <[exa]> alx741: so you basically want to use a single resource name (url path or whatever) for multiple slightly different things. Will the app send some User-Agent information?
11:12:46 <hth313> I have a terrible performance issue with GHC, with profiling it says it should take 14 secs (which is way too slow, and I spent an awful lot of time tuning it to this point), but if I build a binary without profiling it takes 14 *minutes*
11:12:52 <alx741> no, just request some data on a path, say `domain.com/users/all` to get a JSON with all the users. But i'm thinking (Just a concern, not sure if it's gonna happen) what if a change the name of a field in that JSON it returns? then the android app brakes until phones get the new version...
11:13:40 <alx741> *if I then change the name of a field...
11:14:59 <alx741> *the app breaks... Sorry suck at typing english ¯\_(ツ)_/¯
11:16:26 <alx741> seems like there is support for prefixing that might work, will check that out
11:17:55 <c_wraith> hth313, maybe you're hitting the case where the full laziness optimization is bad? does your code involve calculating the same data structure multiple times?
11:20:35 <hth313> c_wraith, memory consumption is quite stable, running the binary built with profiling, but using no profiling options, takes about 30 seconds
11:22:07 <hth313> c_wraith, just touch a file and build again with no profiling runtime, 14 minutes
11:23:00 <c_wraith> there's a -fforce-recomp option so you don't need to touch a file. (irrelevant, but maybe helpful)
11:23:07 <marxS> does it make sense to create an algebraic datatype for date? So like data Date = (Year Int) (Month Int) (Day Int) ?
11:23:34 <mniip> I think one already exists in the 'date' package
11:23:35 <marxS> I've seen the package Data.dates, but ideally wanted to try and implement something from ground up just to become more familiar with haskell
11:23:36 <mniip> er
11:23:38 <mniip> time package
11:23:52 <[exa]> alx741: prefixing could do a lot but make sure you don't end up with too many prefixes :D
11:24:01 <mniip> working with datetime is one of the most horrifying things in programming, you may want to reconsider
11:24:14 <marxS> reconsider what, sorry?
11:24:26 <mniip> reconsider using datetime as an exercise
11:24:42 <marxS> the function i'm implementing is merely to count the number of days between two given dates
11:24:47 <marxS> so it's relatively simple
11:24:49 <mniip> haha
11:24:54 <marxS> just wanted familiarity in creating alg datatypes
11:25:01 <mniip> one of the most compilicated functions in the history of humanity
11:25:05 <marxS> lool
11:25:22 <marxS> will maybe use Data.Dates then :p
11:25:58 <mniip> how many days are there between Sep 1 1752 and Sep 30 1752
11:26:14 <marxS> 6?
11:26:30 <alx741> [exa]: will watch out of that :), thanks!
11:26:46 <mniip> 18 if you're in the US
11:26:46 <exio4> mniip: ⊥
11:26:53 <mniip> 29 in most other places
11:26:55 <exio4> the safe answer
11:27:00 <marxS> lol why 18 in the US?
11:27:09 <iqubic> What are we talking about?
11:27:17 <mniip> they switched from julian to gregorian calendar that year
11:27:25 <marxS> also I only need time between current date and some date in the next 1 month :p
11:27:27 <marxS> so shouldnt be too hard
11:27:45 <marxS> or at least not have weird stuff like that going on
11:40:05 --- mode: ChanServ set +o glguy
11:40:05 --- mode: glguy set -bo selfsymmetric!*@*$##fix_your_connection glguy
11:57:22 <marxS> do you think there should be some structure when learning haskell?
11:57:39 <marxS> I know with other languages you can kind of just "learn as you go" but it seems to be much harder here
12:00:00 <shapr> @where cis194
12:00:00 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
12:00:04 <shapr> marxS: I like that one
12:00:15 <marxS> yeah ive been using that a little
12:00:35 <marxS> and complimenting the reading with outside stuff (the core material seem to be a little barebones)
12:01:30 <marxS> shapr:  there's also this one https://www.inf.ed.ac.uk/teaching/courses/inf1/fp/ (was initially created by phil wadler)
12:06:26 <ZeusPiark> helllo
12:08:55 <marxS> hi
12:28:19 <marxS> how long did some of you guys learn haskell for before you were able to produce production-ready code?
12:28:48 <c_wraith> I started on code that was already in production! :)
12:30:47 <c_wraith> I think it took me a couple months before I had much of a clue beyond "for small-scope changes, the compiler catches most mistakes I make"
12:31:43 <marxS> yea it's a bloody steep learning curve
12:31:48 <marxS> although it's mostly been rewarding thus far
12:32:04 <selfsymmetric-pa> Yeah, you can start contributing immediately, but I think it takes about three months of work for a Haskell programmer to mature.
12:33:33 <marxS> ok cool
12:34:15 <marxS> also a question: with using newtype for a unary data constructor, why not just use a vanilla data declaration?
12:34:23 <marxS> i assume they're both considered same at run-time?
12:34:29 <marxS> so is it to do with the over-head?
12:34:44 <c_wraith> they have different semantics with pattern matching and strictness, actually.
12:35:15 <selfsymmetric-pa> https://stackoverflow.com/questions/2649305/why-is-there-data-and-newtype-in-haskell
12:35:25 <selfsymmetric-pa> Newtype is strict and data is lazy.
12:35:35 <marxS> ok will read now, thanks
12:35:39 <selfsymmetric-pa> I agree that Haskell doesn't do a great job of communicating this.
12:35:59 <c_wraith> selfsymmetric-pa, it's more complex than that.
12:36:07 <selfsymmetric-pa> c_wraith: What's funny is that linters often badger you to replace data with newtype.
12:36:28 <selfsymmetric-pa> That seems to suggest that newtype is almost always better.
12:36:43 <c_wraith> selfsymmetric-pa, matching on a data constructor forces evaluation. matching on a newtype constructor does nothing at runtime.
12:36:48 <selfsymmetric-pa> And if THAT'S true, then why not make the rare case an an override.
12:37:47 <c_wraith> this is why the "strict identity" monad is built from data, whereas "lazy identity" is built from a newtype.
12:39:30 <c_wraith> so you can't just say one is lazier. it's all about what specific properties you want.
12:40:10 <c_wraith> you can definitely say newtype has less runtime overhead, though!
12:41:50 <marxS> ok, maybe a little above my head right now but will bear it in mind
12:41:59 <selfsymmetric-pa> c_wraith: If you were designing Haskell from scratch, do you think it would be possible to communicate things better to neophytes?
12:43:50 <c_wraith> selfsymmetric-pa, dunno. lazy evaluation is a brand new model to most people. nothing is going to make learning a new model easier.
12:44:25 <hexagoxel> we could spend some time bikeshedding better names for data/newtype/type :)
12:44:36 <c_wraith> (I don't actually think it's a harder model than strict evaluation. it's just that learning any new model is a challenge)
12:51:24 <marxS> how can i add type constraints to an instance of a class? ive tried googling but it's not returning much which is making me think im misunderstanding this question
12:51:46 <sagax> hi all!
12:52:08 <c_wraith> instance (Show a) => Show (Foo a) where...
12:52:13 <mnoonan> instance YourConstraint t => YourClass t where yourClassMethod :: ...
12:52:19 <sagax> run haskell compiled code on machine without haskell - it's possible ?
12:52:46 <c_wraith> sagax, unless it links in ghc as a library, yes.
12:53:04 <sagax> without ghc library?
12:53:19 <geekosaur> or unless the distribution did something annoying, like e.g. arch which only installs shared versions of libraries
12:53:23 <sagax> maybe place ghc library to binary file
12:54:04 <geekosaur> that means ghc-api, which is the compiler packaged as a library. some programs use this for various reasons, e.g. dynamic evaluation or to implement IDE functionality
12:54:07 <geekosaur> it's not especially common
12:54:15 <c_wraith> sagax, most programs don't include ghc as a library. just ones that intend to interpret or compile haskell code at run time.
12:54:17 <marxS> hmm so this is what i have mnoonan , my attempt at the bottom is obvious incorrect https://paste.ofcode.org/gVdurhXGP6GLvM5FJWRXc8
12:54:40 <marxS> im trying to create a constract of (Num a, TooMany a) => (a,a) on class TooMany, i assume it doesn't matter that it's self-referential
12:56:35 <geekosaur> instance (Num a, TooMany a) => TooMany (a,a) where
12:57:35 <geekosaur> the way you have it would try to make an existential, which I don't think can ever make sense there (no way to select it)
13:02:23 <mnoonan> marxS: you're going to get an overlap with that (Int,Int) instance
13:02:28 <marxS> Then what is the type constraint actually constraining?
13:02:39 <marxS> in the code you posted geekosaur
13:03:07 <mnoonan> the instance's constraints aren't considered when ghc selects an instance
13:03:35 <geekosaur> marxS, it's the way to write what you want. but as mnoonan says, you also have na overlap problem. you cannot select instances that way, it leads to an inconsistent type system
13:03:47 <geekosaur> constraints are applied after instance selection
13:04:09 <marxS> oh
13:04:20 <geekosaur> consider that you write that and think it's unique, and then use it in a library. and a year later someone adds another instance that overlaps with it
13:04:31 <geekosaur> the compiler can't know someone will do that a year later
13:05:54 <oo_miguel> do I need to have "make" to run stack?
13:07:50 <mniip> let D be an epimorphic bifunctor over a codomain
13:10:56 <geekosaur> oo_miguel, stack itself shouldn't requie it. upgrading stack from source might, if there's no prebuilt executable for your platform. and some packages use make because they're too complex for simple build systems
13:15:37 <marxS> what do you guys/girls think of ocaml?
13:15:51 <marxS> apart from its severe lack of use in industry (besides that one company :p )
13:17:01 <[exa]> I thought ocaml isn't as rare
13:17:13 <johnw> doesn't Jane St. use it a lot?
13:17:26 <koala_man> that's the one company, yes
13:17:30 <marxS> yeah, Jane St was the one company I was referring to
13:17:30 <marxS> lol
13:17:40 <pauliesaint> Hi, I installed stack with the shell script but now I want to install with a package, how can I uninstall stack?
13:18:26 <koala_man> I've just submitted a couple of patches to ocaml software, and I found it pretty awkward because of the standard library. I don't remember exactly what was lacking, but it was things like matching a prefix of a string
13:18:42 <[exa]> why is jane st. t-shirt I grabbed on last ICFP stylised as haskell-ish then? *confused*
13:18:55 <koala_man> things that even C++ has stdlib functionality for
13:20:23 <pgiarrusso> pauliesaint: just remove the binary, IIRC? be ready to remove/move away `~/.stack` as well
13:20:26 <koala_man> from what I hear, Jane St has written their own huge library collection to make that less of a pain
13:20:27 <cjay-> jane st. also sponsored monadic.party despite it being about Haskell only
13:20:49 <pgiarrusso> koala_man: that's right, the other alternative stdlib is batteries IIUC
13:20:54 <marxS> yeah they're just pretty big into functional programming in general
13:21:00 <marxS> i think they hold a func prog conference each year
13:21:05 <[exa]> cool
13:21:23 <pauliesaint> ok
13:21:32 <koala_man> they had some event in SF last week, but they were booked full so I couldn't go
13:21:43 <marxS> koala_man:  you might've met me there :p
13:21:55 <koala_man> aww
13:22:47 <marxS> although my functional programming is very weak lol
13:38:46 <agentultra> is it possible to define a sum of product types that have a common field like "id" or some such?
13:39:38 <mniip> yes
13:41:35 <EvanR> i wonder how record update works in that case
13:41:59 <selfsymmetric-pa> It depends. If you have a sum of product constructors, and each of the constructors has `id`, then you should probably factor it out. So `(id, foo) | (id, bar)` should become `(id, foo | bar)`.
13:42:35 <selfsymmetric-pa> And if it's a sum of product _types_, then the type of `id` becomes a problem because you can't have `id :: Foo | Bar -> Id`. Not with vanilla Haskell, anyway.
13:43:11 <EvanR> the problem i see is the other fields which are "not common"
13:43:22 <EvanR> you cant hve just some fields named
13:43:34 <EvanR> the uncommon ones will spawn partial functions
13:43:53 <selfsymmetric-pa> Yeah. It's a nortorious Haskell deficiency. You don't even get a _warning_ from the compiler.
13:43:57 <agentultra> selfsymmetric-pa: the sum of product constructors is where I'm at but I'm repeating myself a lot; factoring out the field sounds reasonable
13:44:39 <selfsymmetric-pa> agentultra: Great. That should also help you avoid partial accessors. Remember, they're called algebraic datatypes for a reason. It's _literally_ refactoring. ;)
13:44:40 <agentultra> or just suffer the repetitive definitions and let lenses make it easy to use
13:45:01 <selfsymmetric-pa> That seems like overkill. If I were you I'd refactor it.
13:45:03 <agentultra> selfsymmetric-pa: indeed :)
13:45:03 <EvanR> HasId
13:45:44 <selfsymmetric-pa> Okay, sure, you can use a typeclass, but surely we shouldn't do with typeclasses and lenses what we can accomplish with ADTs alone.
13:46:14 <Berra> I'm wondering if/how I could apply some constraint on `data D f = D { a :: Apply f Text, b :: Apply f Text };` such that I could generate a ToJSON instance using the Aeson TH derivingJSON. Possible?
13:49:50 <tathougies> Berra, do you mean like `ToJSON (Apply f Text) => ToJSON (D f)`?
13:56:28 <Berra> tathougies: Hm - no I can't make it work with a constraint like that.
13:57:25 <Berra> tathougies: I'm using Apply from singleton and what I really want to do is to deriveJSON on the D (IdSym0) and D (TyCon1 Maybe)
13:58:34 <tathougies> What error are you getting? You'll have to enable UndecidableInstances
13:58:37 * hackage cabal2spec 2.2.1 - Convert Cabal files into rpm spec files  http://hackage.haskell.org/package/cabal2spec-2.2.1 (PeterSimons)
13:58:40 <tathougies> Berra ^
13:59:52 <agentultra> selfsymmetric-pa: would that refactoring look like a type parameter? how would I get the `a` back into the constructors so my values would have them if that's the case?
14:00:03 <Berra> tathougies: That no instance is arising - even with the constraint
14:00:25 <Berra> tathougies: I've tried applying the constraint both using DatatypeContexts and GADTs
14:00:55 <agentultra> data Field a = A { width :: Int } | B { maxSize :: Int } ?
14:07:55 <noipmups> Using Control.Arrow, how to make something of type a -> (b, c, d)?
14:08:18 <Berra> tathougies: The usage of singleton just appears to make it impossible to derive for some reason. Which is mad because the newtypes created using D (IdSym0) behave exactly as expected. So I don't understand why I can't derive for those newtypes.
14:09:07 <Berra> tathougies: Well I can't derive for those newtypes because D doesn't have a ToJSON instance - but I can't derive one for D because it has the singleton type applicator in it
14:15:03 <pavonia> noipmups: There's `arr` to lift a function to an arrow
14:15:41 <selfsymmetric-pa> agentultra: I thought you were talking about something simpler. `A { width :: Int, id :: Id} | B { maxSize :: Int, id :: Id}` could be transformed to `{id :: Id, ab :: AB}` where `AB = A { width :: Int} | B { maxSize :: Int}`.
14:18:03 <subleq> Are there any formal languages that do not always halt, but have a decideable halting problem?
14:19:27 <Eduard_Munteanu> subleq, I guess any total language qualifies if you can disable the termination checking.
14:19:31 <selfsymmetric-pa> subleq: I'm sure you could make a really boring one. Like a language restricted to unit and loop.
14:19:53 <subleq> Yeah, sure. I mean an interesting nontrivial one
14:20:15 <Eduard_Munteanu> E.g. Agda, which also has coinductive types.
14:24:00 <Eduard_Munteanu> Hm, wait, if termination checking fails that doesn't mean the program doesn't terminate, it just couldn't be proved to.
14:24:34 <subleq> Which is not the same as decidable termination right?
14:24:42 <Eduard_Munteanu> I guess so.
14:25:11 <subleq> you can answer yes/no/maybe even with a turing machine
14:25:47 <marxS> what do you think is the main hinderance in wider haskell adoption? do you think it's the learning curve?
14:25:52 <marxS> the user-friendliness?
14:26:15 <marxS> the unconventional functional paradigm forcing regular thought?
14:26:19 <hpc> going back to this morning with free theorems and fmap
14:26:27 <hpc> could the implication go in the other direction?
14:26:49 <hpc> that the functor laws ensure you're able to reason about fmap as if it was parametric?
14:26:55 <hpc> (since it's a class method)
14:27:52 <Boarders> marxS: mostly seems industry driven and they believe in pseudo science like agile so probably nothing sensible
14:28:53 <selfsymmetric-pa> marxS: In Haskell the easy things are hard. Learning curve, poor documentation, poor tooling.
14:29:32 <glguy> or even the prepetuated myth of those things
14:29:50 <glguy> perpetuated*
14:29:51 <Boarders> C++ has terrible learning curve, poor documentation and not great tooling
14:30:18 <selfsymmetric-pa> glguy: I dunno. I've been writing working with Haskell as a primary language for over a year now.
14:30:20 <selfsymmetric-pa> I think the myth is real.
14:30:58 <marxS> selfsymmetric-pa: ive found the documentation pretty good (although there's a wider problem of lack of learning materials but that comes from lack of use in industry and university classes) compared to a lot of other languages
14:31:00 <selfsymmetric-pa> Totally worth it, mind you.
14:31:07 <marxS> obviously if we're talking python, rust etc then documentation isn't close lol
14:31:09 <glguy> I've seen the state of documentation in popular languages like JavaScript and its not much better. Libraries documented only by their APIs via Doxygen is quite common in the world of Java, none of this is Haskell specific
14:31:24 <selfsymmetric-pa> marxS: Yeah., I'm spoiled. I actually worked with the Rust docs team for a few months.
14:31:33 <johnw> I would say that the easy things are hard to get started with. There comes a time when you have proper momentum, and then the easy things are really easy, even when the documentation is sometimes not the best.
14:31:58 <glguy> I find haddocks more useful than the documentation generated for Rust packages.
14:32:24 <selfsymmetric-pa> glguy: Really! I think that's a controversial opinion. What makes Haddocks better than Rust docs?
14:32:50 <marvin2> I find haskell's documentation far easier to follow than python's (types probably help there, as opposed to python's freestyle, very verbose documentation, which I guess is a necessity for such a language)
14:32:56 <glguy> I find them much easier to navigate to the information I need. The rust ones don't give me more information but feel much more cluttered
14:33:37 <selfsymmetric-pa> Another big reason is that people aren't generally _forced_ to learn Haskell.
14:33:43 <selfsymmetric-pa> Whereas that's often true for JS and C++.
14:33:54 <selfsymmetric-pa> If you're on the web, you gotta learn JS. If you work in graphics, you gotta learn C++.
14:34:06 <selfsymmetric-pa> People rarely learn Haskell _involuntarily_.
14:34:26 <marxS> yeah that's true
14:34:39 <johnw> very true
14:34:51 <marxS> had I not been forced to learn haskell as part of my degree i probably wouldnt have given it a second glance
14:35:03 <marxS> (granted, I have forgotten most of what I learned lol)
14:35:16 <johnw> I intentionally changed my career over to Haskell
14:35:20 <johnw> from C++
14:35:21 <equwal> /
14:35:42 <tdammers> marvin2: IMO this is closely related to the "consenting adults fallacy"
14:36:18 <tdammers> marvin2: you know, how python has this idea that "we're all consenting adults here, no need for formal rules"
14:40:56 <equwal> !lotgs
14:40:58 <equwal> !logs
14:41:05 <equwal> How do I use the bot in here?
14:42:57 <glguy> equwal: If you're looking for logs you can look in /topic
14:42:57 <alx741> Does the steps of a conduit or pipes pipeline get executed in parallel when possible? I mean that step 2 process the data given by step 1 while step 1 is already working on the new incoming chunk of data *at the same time*
14:43:04 <ij> > (*3) <$> [1,2]
14:43:06 <lambdabot>  [3,6]
14:43:09 <alx741> Not familiar with either library, but just curious :)
14:43:54 <equwal> Thank you.
14:45:19 <ij> it looks like the irc logs at http://ircbrowse.net/browse/haskell?events_page=740408 have stopped
14:45:33 <hpc> ij: logs are in the topic
14:46:01 <ij> haskell wiki provided two links, this was one of them
14:46:20 <marvin2> tdammers agreed
14:46:59 <lyxia> alx741: no
14:49:28 <alx741> lyxia: any way to get that behaviour with another library?
14:57:18 <lamba> hi, anyone know how to get a monoid instance for vinyl records?
15:17:07 * hackage hnix 0.5.2 - Haskell implementation of the Nix language  http://hackage.haskell.org/package/hnix-0.5.2 (JohnWiegley)
15:19:24 <glguy> lamba: It looks like they already have one
15:19:53 <Zemyla> Vinyl records have a Monoid instance? What?
15:20:26 <glguy> Which part of that did you want help with?
15:20:59 <Zemyla> Oh, you know that common "Once" pattern that would let you put a value into root normal form just once without having to rnf it every time you access it?
15:21:26 <mniip> glguy, are you participating in the ICFPC btw
15:21:33 <Zemyla> And how having it be an actual pattern synonym would require an NFData instance to deconstruct it as well as to construct it?
15:21:41 <Zemyla> I thought of a way around that.
15:21:50 <glguy> mniip: The programming contest?
15:21:56 <Zemyla> @let data RNF a where RNF :: NFData a => RNF a
15:21:57 <mniip> yes
15:21:57 <lambdabot>  .L.hs:161:16: error:
15:21:57 <lambdabot>      Not in scope: type constructor or class ‘NFData’
15:21:57 <lambdabot>      Perhaps you meant ‘Data’ (imported from Data.Data)
15:22:05 <Zemyla> @let import Control.DeepSeq
15:22:06 <lambdabot>  Defined.
15:22:22 <glguy> mniip: I hadn't been planning to. Are you?
15:22:25 <mniip> I am
15:22:34 <glguy> I see now that it is this weekend!
15:22:45 <mniip> less than 24 left!
15:23:15 <glguy> Also the Monoid instance in the released vinyl is broken, but is fixed in git
15:23:26 <Zemyla> Oh, vinyl is a package.
15:23:38 <mniip> I didn't get far with goldfire in that email chain :(
15:23:40 <glguy> Well, the Semigroup instance is broken more specifically
15:32:39 <lamba> glguy: i tried and it didn't work because ElField is missing the instance
15:40:27 <dexterfoo> what does "nominal" mean in NominalDiffTime?
15:51:37 * hackage fraxl 0.2.0.0 - Cached and parallel data fetching.  http://hackage.haskell.org/package/fraxl-0.2.0.0 (willfancher)
15:52:38 <glguy> lamba: You'd want to submit a pull request for ElField to have a Monoid instance, then. Vinyl records already have the instance but the first parameter you pick with Rec will also need the instance: https://gist.github.com/glguy/a0e74e9c718a377d70aa0d98fb16a041
16:01:56 <dmwit> dexterfoo: The difference between NominalDiffTime and DiffTime is in how they treat leap seconds.
16:02:00 <nai> hi, i couldn't find a source for "seq", is it because it does too low-level things and cannot be expressed in terms of Haskell ?
16:02:51 <dmwit> dexterfoo: I sort of think of NominalDiffTime as being the difference between the "names" of the times on its two ends -- e.g. the time "named" July 1 at 2300 and July 2 at 0100 is two "named" hours.
16:03:12 <dmwit> dexterfoo: Whereas those two points in time might actually be more than two hours apart when treated as actual moments in history.
16:03:48 <dmwit> nai: correct
16:04:04 <nai> thanks
16:04:06 <dexterfoo> dmwit: thanks. but why is the word "nominal" used? does it have a meaning in math?
16:04:24 <dmwit> "nominal" means "related to names"
16:04:29 <tieTYT> I’m looking at this: `class Monad m => MonadPlus m where`.  Could the language have just said m is a monoid and not needed to define mzero because the monoid mempty could have been reused?
16:04:54 <equwal>  nn
16:05:03 <dmwit> dexterfoo: Disclaimer: this is my way of remembering it, and I think a reasonable guess about how the name "NominalDiffTime" was chosen, but you might have to consult the library author to really be sure.
16:05:32 <tieTYT> looking at functor, applicative functor, and monad, it feels like they all have a pure/return.  Why don’t they just reuse one?
16:05:32 <dmwit> tieTYT: No, `MonadPlus m` says more, namely, that `m a` is a `Monoid` for *all* `a`.
16:06:41 <tieTYT> ok but my question is, why do so many classes have a function that takes an ‘x’ and puts it in a “box”?  Why doesn’t this just come from one base class that’s reused in the others?
16:07:12 <dmwit> tieTYT: e.g. there is a `Monoid a => Monoid (TMap k a)` (`TMap` is much like `Data.Map.Map`, but total) instance, so even though `TMap k` is a `Monad`, it isn't a `MonadPlus`.
16:07:13 <marvin2> functor does not have such a function
16:07:42 <marvin2> Monad and Applicative do, and the reason why is, I guess, because Monad came first
16:07:48 <dmwit> tieTYT: return and pure both exist for historical reasons. If we designed it today return would likely not exist (or else it would be in Applicative and pure would not exist).
16:08:03 <tieTYT> k
16:08:07 * hackage fraxl 0.2.0.1 - Cached and parallel data fetching.  http://hackage.haskell.org/package/fraxl-0.2.0.1 (willfancher)
16:08:13 <butterthebuddha> lpaste having trouble?
16:08:39 <dmwit> lpaste is dead, long live lpaste
16:09:12 <tieTYT> ok so back to MonadPlus, how does it say it’s a Monoid?  I don’t see Monoid mentioned anywhere
16:09:25 <dmwit> The maintainer recused themself long ago and nobody stepped up to fill their shoes.
16:09:40 <dmwit> tieTYT: It doesn't. They're not connected at all.
16:09:43 <tieTYT> oh
16:10:02 <fishythefish> dexterfoo: "nominal" can also mean "only in name" - if a value is expressed in terms of some kind of standard measurement without compensating for real world effects (such as leap-seconds), it's often called "nominal"
16:10:05 <dmwit> However, the types and laws together does say that each `MonadPlus m` instance gives rise to a monoid (lower-case) for `m a` for all `a`.
16:10:19 <dmwit> tieTYT: I was imprecise earlier when I said otherwise. Apologies.
16:10:33 <tieTYT> np
16:13:00 <lamba> glguy: thanks!
16:13:50 <butterthebuddha> Is the fold in sha1' here doing what I think it's doing: https://gist.github.com/anrddh/d1467fd86c844a484e6890417905c590
16:14:23 <butterthebuddha> SHA1 pseudocode here: https://en.wikipedia.org/wiki/SHA-1#Examples_and_pseudocode
16:15:07 * hackage ats-pkg 3.0.0.4 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-3.0.0.4 (vmchale)
16:15:24 <dmwit> butterthebuddha: Probably not.
16:15:46 <butterthebuddha> dmwit: can you be more precise?
16:16:01 <dmwit> butterthebuddha: From a quick inspection it seems to be proceeding backwards. But I often get my foldr/foldl mixed up, and also I don't know which way you think extend is going, so it may be worth trying it on a few simple examples.
16:16:13 <dmwit> butterthebuddha: Just gotta give me a few seconds to type. =)
16:16:15 <dmwit> (done now)
16:16:47 <butterthebuddha> dmwit: oh sorry, I've had some unpleasant experiences with people on other channels in the past
16:17:27 <glguy> I would be quite surprised if the chunks were supposed to be processed last first as in this code
16:17:54 <butterthebuddha> glguy: They're not; I always get confused between foldr/foldl
16:18:08 <fishythefish> suppose your chunks are c1 : (c2 : (c3 : [])) - then foldr processChunk s chunks gives you: c1 `processChunk` (c2 `processChunk` (c3 `processChunk` s))
16:18:59 <fishythefish> everyone has different ways of remembering which way they go, I prefer the "foldr f z substitutes f for (:) and z for []" mnemonic
16:20:14 <butterthebuddha> Switching to the foldl didn't change the output at all actually
16:20:45 <butterthebuddha> I guess it's gonna be a couple more hours of debugging
16:21:11 <dexterfoo> dmwit, fishythefish: thanks
16:21:15 <glguy> If your test case has 1 chunk it won't matter
16:22:13 <dmwit> > foldr (:) [] "abc"
16:22:15 <lambdabot>  "abc"
16:22:19 <dmwit> > foldl (flip (:)) [] "abc"
16:22:21 <lambdabot>  "cba"
16:27:58 <glguy> > foldl f z [a,b,c]
16:28:01 <lambdabot>  f (f (f z a) b) c
16:28:05 <glguy> > foldr f z [a,b,c]
16:28:07 <lambdabot>  f a (f b (f c z))
16:51:22 <dmwit> ask more questions, i'm bored
16:52:20 <hpc> is zorn's lemma true or false?
16:52:23 <mniip> dmwit, pattern synonyms
16:52:34 <mniip> why is their syntax so terrible and how to improve it
16:52:40 <dmwit> What's yellow and equivalent to the axiom of choice?
16:52:49 <dmwit> Zorn's lemon
16:53:33 <dmwit> mniip: Isn't there a recent proposal on that?
16:53:43 <mniip> hpc, I know a better question
16:53:46 <mniip> is falsehood derivable
16:53:57 <mniip> dmwit, linky?
16:54:03 <dmwit> https://github.com/ghc-proposals/ghc-proposals/pull/138
17:00:19 <mniip> worrying
17:00:28 <mniip> I have an idea of a related proposal that might clash with this one
17:00:40 <butterthebuddha> hpc: it depends on what you believe in
17:00:40 <butterthebuddha> hpc: Zorn's lemma can't be proved to be true or false if you believe in "ZF"-set theory
17:00:43 <butterthebuddha> But it's "equivalent" to the Axiom of Choice - if you believe in Choice, then Zorn's Lemma is true; if you don't believe in Choice, then Zorn's lemma is false
17:01:08 <Gurkenglas> Might "($()) $ let x = f y in \_ -> g x" ever behave differently from "let x = f y in g x"?
17:01:20 <butterthebuddha> Turns out the error in my SHA1 code was with a function that was parsing a ByteString into a Integral type :P
17:02:30 <dmwit> pretty sure hpc knew all of that
17:03:52 <butterthebuddha> Oh nvm, I missed the context of the question entirely
17:04:12 <dmwit> Gurkenglas: It sure seems like any differences would be slight indeed. Are you seeing something surprising that makes you wonder about that?
17:06:29 <haasn> Gurkenglas: the former may not type check in all situations in which the latter type checks.
17:06:43 <dmwit> really?
17:06:44 <haasn> specifically, if dealing with kinds other than *, such as unboxed/unlifted kinds
17:06:59 <haasn> But I'm not 100% sure
17:07:06 <haasn> I'm not sure how liberally kinded today's ($) is
17:07:18 <glguy> Today's $ is hard-coded magic
17:07:35 <dmwit> ($()) doesn't use today's $
17:07:56 <dmwit> But surely `\_ -> ...` can be made the right kind for ($) anyway.
17:08:21 <haasn> try it with `x` being Int# and `g` being some primitive operation? dunno
17:08:37 * hackage aeson-typescript 0.1.1.0 - Generate TypeScript definition files from your ADTs  http://hackage.haskell.org/package/aeson-typescript-0.1.1.0 (thomasjm)
17:08:47 <haasn> BUt that doesn't answer Gurkenglas's question anyway
17:08:54 <haasn> he asked for situations in which they _behave_ differently
17:09:00 <haasn> Not type checking, I'd argue, is not a difference in behavior
17:09:30 <dmwit> > I# (let x = (+#) 0# in \_ -> ($ 3#) x)
17:09:32 <lambdabot>  error:
17:09:32 <lambdabot>      • Data constructor not in scope: I# :: (p0 -> b0) -> t
17:09:32 <lambdabot>      • Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Tr...
17:09:47 <dmwit> ?let import GHC.Exts
17:09:49 <lambdabot>  .L.hs:135:1: error:
17:09:49 <lambdabot>      GHC.Exts: Can't be safely imported! The module itself isn't safe.
17:09:49 <lambdabot>      |
17:09:55 <dmwit> % import GHC.Exts
17:10:12 <dmwit> mniip: halp!
17:10:44 <mniip> the network is split
17:12:02 <dmwit> haasn: I# (let x = (+#) 0# in (\y -> y 3#) x)
17:12:07 <haasn> I# (($ ()) $ let x = 0# in \_ -> 1# +# x)
17:12:09 <haasn> this works locally
17:12:14 <dmwit> typechecks, as does I# (($()) $ let x = (+#) 0# in \_ -> (\y -> y 3#) x)
17:12:21 <haasn> Yeah, fair enough
17:13:41 <haasn> Then I'm out of ideas for breaking Gurkenglas's question
17:15:36 <fishythefish> hpc: I like Bona's description best: “The Axiom of Choice is obviously true, the well–ordering theorem is obviously false, and who can tell about Zorn’s Lemma?"
17:21:05 <hpc> fishythefish: obviously i asked the variation that would keep dmwit occupied :D
17:21:35 <fishythefish> hpc: follow-up: prove the consistency of Bona's statement
17:26:49 <mniip> hmm
17:26:54 <mniip> Void# is unrelated to Void, right?
17:26:56 <mniip> just the name
17:27:15 <hpc> what is Void#?
17:28:50 <mniip> GHC.Prim.Void#
17:30:01 <hpc> huh, i don't see it
17:30:15 <mniip> % :k Void#
17:30:16 <yahb> mniip: Void# :: TYPE ('TupleRep '[])
17:54:34 <haasn> apparently the fake haddock generated for GHC.Prim hasn't been updated to include Void#
17:55:18 <mniip> % :i Void#
17:55:19 <yahb> mniip: data Void# :: TYPE ('TupleRep '[]) -- Defined in `GHC.Prim'
17:55:31 <mniip> it's there in the hi
18:01:27 * dmwit waves at the Void#
18:02:02 <superguest> Hi guys.  Here is a first example from a Monad introduction https://ptpb.pw/GYlx.png
18:02:14 <superguest> I have two questions:
18:04:48 <superguest> 1) The bind operator (>=) is used in the `eval` function.  Since Maybe is an instance of class Monad, does the compiler automatically figure out which implementation `>>=` is bound to?
18:05:25 <superguest> by looking at signature:  eval :: Expr ->  Maybe Int
18:06:02 <infinisil> What's an example of a simple function that really shines with generics?
18:06:25 <infinisil> Hmm.. maybe Arrows
18:09:40 <superguest> 2) can someone be so kind to convert what he showed (using `>>=`) into an implementation that uses the do notation?
18:10:36 <superguest> https://ptpb.pw/GYlx.png
18:13:26 <pavonia> superguest: 1) Yes. 2) `foo >>= (\x -> ...)` is equivalent to `x <- foo; ...` in do-notation
18:14:31 <pavonia> So in that case it's `do { n <- eval x; m <- eval y; return (Safediv n m) }`
18:15:03 <superguest> pavonia, thank you Sir.
18:22:24 <Guest35127> Hi
18:25:31 <Foobar_> Hi, I'm here.
18:26:19 <superguest> In that example, it seems like the bind operator acts like a value validator.
18:28:48 <Rar__> Hi I'm here
18:29:21 <Foobar_> heya
18:29:33 <Foobar_> Hi Rar__
18:29:35 <Foobar_> it' N
18:29:45 <Foobar_> let me figure out how to PM, 1 sec
18:30:17 <Rar__> Mk
18:33:21 <Rar__> Hi
18:34:14 <Foobar_> heya
18:34:33 <Foobar_> did you get my private messages, or nah?
18:36:28 <Rar> Pm me again?
18:37:00 <Foobar_> actually, here
18:37:39 <Rar> was on mobile. switched to laptop. - it may be more successful
18:38:30 <equwal> Foobar_ hi?
18:38:37 <Rar> hi
18:38:49 * equwal hi?
18:38:59 <Foobar_> Rar, go to this link: www.disposablechat.com/chat/123?password=name
18:39:05 <Foobar_> but change name to my name in the URL
18:39:40 <Foobar_> e.g., www.disposablechat.com/chat/123?password=bob
18:39:44 <Foobar_> if my name was bob
18:39:45 <Foobar_> all lower case
18:40:35 <pavonia> Foobar_, Rar: Please note that this channel is about the Haskell programming language. For general chitchat you can use e.g. #haskell-offtopic
18:50:06 <cgoldamm1r> If I have data types like `data Suit = Club | Diamond | Heart | Spade`, how can I automatically derive functions to express theses as integers? More precisely, I need functions with signature `Suit -> Int` and `Int -> Maybe Suit`
18:50:31 <cgoldamm1r> I need that as part of persisting in a SQL database with Persistent
18:50:47 <monochrom> "deriving Enum"
18:51:07 <infinisil> Oh and I think loeb is a good example showcasing generics, lol
18:51:15 <infinisil> @let loeb x = go where go = fmap ($ go) x
18:51:17 <lambdabot>  Defined.
18:51:19 <infinisil> :t loeb
18:51:21 <lambdabot> Functor f => f (f b -> b) -> f b
18:51:33 <cgoldamm1r> ooh so nice. Love it! Thanks monochrom!
18:51:47 <infinisil> Okay that's only 2 generic types
19:15:07 <Gurkenglas> cgoldamm1r, for the Int -> Maybe a see http://hackage.haskell.org/package/safe-0.3.17/docs/Safe.html#v:toEnumMay
19:16:47 <Gurkenglas> How should I turn a code block with a _ in it into the type inferred for the _?
19:17:03 <Gurkenglas> (Using which (function from) which library, that is)
19:19:40 <vaibhavsagar> why isn't there an atomicallyModifyMVar?
19:20:19 <glguy> That's what modifyMVar is for
19:20:32 <vaibhavsagar> but it's not atomic, right?
19:21:18 <glguy> it's fine as long as your using the mvar in a principled way. It takes the mvar (which is then empty, nothing else can take it) and then puts back the new value
19:21:32 <vaibhavsagar> suppose I have a Seq inside an MVar and two threads that want to modify it from each end
19:21:42 <glguy> no, seq isn't relevant
19:21:53 <glguy> unless you're just being careful about where the outer-most evaluation actually happens
19:21:54 <vaibhavsagar> sure, a list then
19:22:06 <glguy> but atomic isn't about seq
19:22:17 <geekosaur> they mean Data.Sequence, not seq
19:22:25 <geekosaur> "from each end"
19:22:25 <vaibhavsagar> thanks, yes
19:22:45 <vaibhavsagar> okay, modifyMVar it is
19:22:52 <geekosaur> and the correct answer is that that's not what MVar is for. it's a synchronization primitive. you use it to *make* concurrent-safe containers, not *as* one
19:23:20 <vaibhavsagar> I realise that it's a primitive
19:23:26 <geekosaur> well, a closer one. as the docs say, there are cases where it's directly usable
19:24:14 <geekosaur> but you're hoping to wrap anything in an MVar and have it magically become concurrent. concurrency is by packaging the MVar alongside and take/put to grab / release lock, not by stuffing something inside
19:24:39 <vaibhavsagar> I'm not expecting it to magically become concurrent :)
19:25:18 <vaibhavsagar> but it sounds like putting the data behind an MVar might achieve what I want
19:50:33 <c_wraith> vaibhavsagar, using a single MVar to protect a pure structure isn't a bad approach. it falls apart under too much contention, as it becomes a serial bottleneck. but if it doesn't have that much contention, it can work for a long time.
20:09:41 <matthewhaney> nuser
20:54:01 <marxS> Hey, does anybody know anything about haskell developers and bitcoin? Only thing I can find from searching is haskcoin
20:54:08 <marxS> and every Bitcoin developer I know is Rust, C++ or Python
20:55:52 <vaibhavsagar> marxS: what are you hoping to find?
20:56:21 <marxS> I guess people working on bitcoin-related projects in Haskell?
20:56:30 <marxS> or some existing bitcoin projects in Haskell
20:59:23 <vaibhavsagar> marxS: https://github.com/clample/lambdabtc
20:59:56 <vaibhavsagar> that's the one project I know about
21:00:01 <marxS> last commit 4 months ago :(
21:10:08 <revskill> I have a monad transformer: type EsSi = ExceptT P.String (State Integer)
21:10:27 <revskill> and a function f :: State Integer Integer -> EsSI ()
21:10:39 <revskill> the question is how to get state in the do block
21:11:01 <revskill> if i do res <- lift state_computation, i can only get the result of state computation only
21:51:52 <Xnuk> @hoogle Control.Monad.Trans.State.Lazy.get
21:51:53 <lambdabot> Control.Monad.Trans.State.Lazy get :: (Monad m) => StateT s m s
21:51:53 <lambdabot> Control.Monad.Trans.State.Lazy gets :: (Monad m) => (s -> a) -> StateT s m a
22:43:24 <revskill> Xnuk: ah, i forget to use lift on get
22:55:23 <abueide> how bad is it to make a backup using cp -r ?
22:55:28 <abueide> i only have a live disk and no internet
22:56:07 * hackage pandoc 2.2.2.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-2.2.2.1 (JohnMacFarlane)
22:56:18 <abueide> woops wrong channel
22:57:19 <dminuoso> abueide: You might want to consider how to treak symlinks, and you probably might want to use -p as well to preserve mode, ownership and timestamps
22:57:47 <JuanDaugherty> bad if you care about hidden files and other complications
22:58:05 <Maxdamantus> Usually you want something like `cp -a`
22:58:45 <Maxdamantus> (which is pretty much the same as just using `tar c`)
22:58:59 <JuanDaugherty> rsync a for the non hidden and then rsync .??* will get them all done su
22:59:25 <dminuoso> rsync just to backup a directory is a bit overkill.. files are not magic - cp can do it =)
22:59:45 <dminuoso> or yeah like Maxdamantus mentioned, tar even. :)
23:00:15 <JuanDaugherty> there are many ways, tastes vary
23:00:22 <abueide> oh thanks guys
23:00:22 <c50a326> I like tar's -W
23:01:08 <abueide> i don't so much mind symlinks or ownership but I do mind hidden, I'm just backing up for personal and config files
23:01:15 <abueide> so cp -r -a will be fine?
23:01:35 <ym> Hi. Is there a haskell guide for lisp programmer?
23:01:42 <c50a326> dminuoso: I was under the impression rsync and tar -W hash verify, whereas cp does not verify itself
23:01:51 <c50a326> abueide: also ^^ I might be wrong though...
23:02:26 <c50a326> I remember having copy corruption problems when using cp with spinning disks
23:02:29 <Maxdamantus> abueide: yes, though -a implies -r
23:03:42 <c50a326> I have another slightly but maybe less off-topic question :D what tools are you guys using to map out "category thinking", if anything othe than paper and pen?
23:04:40 <dminuoso> c50a326: a paper and a pencil.
23:05:06 <dminuoso> c50a326: Or a whiteboard if you have one. ;-)
23:05:25 <c50a326> oh I wish
23:05:51 <dminuoso> c50a326: They are really cheap. You can get these huge 4-6 square meter whiteboards for under hundred bucks. :)
23:05:57 <c50a326> I guess paper/pen(cil) is great
23:06:06 <c50a326> I am currently a vagrant :D
23:06:55 <dminuoso> Hello ym. CIS194 is a common general good introduction. :)
23:07:17 <dminuoso> ym: How deep is your lisp-fu?
23:15:24 <ym> dminuoso, well, I learn programming languages more for the sake of my own thinking paradigm training, so I can't tell I'm very experienced, but used to try CLOS and MOP, my larges application in CL is about 2k lines and I enjoyed learning SBCL's inner architecture.
23:15:41 <ym> *largest
23:19:19 <dreamer_> I have a game monad that is both an instance of MonadIO and MonadState, and I'm wondering : would it be better in terms of performance to keep track of the time in the state as an immutable Int or as an IORef ? It would be updated every "tick" (event polling) and also read every tick, for the state of animation displaying. Previously I have used IORefs for that in a game and it worked very well, but I'm wondering.
23:22:50 <tdammers> personally, what I would do is have separate monads for the game logic and the rendering
23:23:09 <tdammers> the game logic monad is only MonadState, and the state includes something for in-game time
23:23:29 <tdammers> then you model the entire game logic in terms of Event -> State -> State
23:23:36 <tdammers> and timer ticks are just another Event
23:23:54 <tdammers> rendering is just State -> IO ()
23:24:02 <tdammers> or maybe RenderState -> LogicState -> IO ()
23:24:30 <tdammers> or probably IORef RenderState -> LogicState -> IO (), if you need to lazy-load resources while rendering
23:24:45 <tdammers> and then the main loop drives both
23:26:46 <tdammers> forever do { event <- pollEvent; modifyIORef stateVar (updateGameLogic event); readIORef stateVar >>= render } -- something like this
23:28:07 <dreamer_> that's actually quite close to what I used before
23:28:33 <dreamer_> but I wonder if having a huge immutable state is a good or bad thing
23:28:36 <dreamer_> in terms of perf
23:30:09 <dreamer_> well that way is really clean
23:31:10 <dreamer_> though I can see some complications for playing sounds etc
23:31:37 * hackage language-ats 1.2.0.15 - Parser and pretty-printer for ATS.  http://hackage.haskell.org/package/language-ats-1.2.0.15 (vmchale)
23:31:51 <tdammers> why would sounds introduce complications?
23:32:00 <tdammers> the game logic doesn't need to know anything about sounds, really
23:32:32 <tdammers> forever do { event <- pollEvent; modifyIORef stateVar (updateGameLogic event); state <- readIORef stateVar; render state; updateSounds state }
23:32:52 <tdammers> and then the sound subsystem keeps track of what sounds are playing, and updates those base on the new state
23:33:27 <tdammers> you will need to tag sounds in the sound subsystem so that you can match them to game logic entities, but that's not super complicated
23:35:11 <tdammers> the game logic would merely need a way to generate unique sound source IDs, and then you'd have a list of (SoundID, SoundInfo) on each entity, and the sound subsystem then creates and destroys sounds as needed based on that
23:39:54 <diginet> question: suppose I have a function foo which defined over the type bar and quux. if I have the sum type bar | quux, can I execute foo a value of bar | quux without destructuring?
23:50:29 <dreamer_> doesnt really adress the performance question
23:51:35 <tdammers> non-strict evaluation should address most of the perfomance issues naturally
23:51:46 <quchen> diginet: Can you put question into code? I don’t understand it.
23:51:55 <tdammers> but if it doesn't, you can still make things strict in crucial places
23:51:56 <quchen> +that
23:54:41 <diginet> quchen: data Sum = Float | Int, if I have function foo which is defined for both Float and Int, can I call that function on Sum?
23:59:06 <liste> diginet: there's no union types, only sum types
23:59:17 <liste> so it'd be data Sum = SumFloat Float | SumInt Int
23:59:33 <liste> where SumFloat and SumInt are constructors
