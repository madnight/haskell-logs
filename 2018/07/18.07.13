00:00:40 <mniip> I'd say that's not how that works
00:00:57 <simon> revskill, foldl is one generalisation of recursion, but there are many.
00:01:16 <simon> revskill, for example, foldr. :D
00:01:34 <mniip> you can't just substitute one function's definition in and be done with it
00:01:41 <cocreature> I wouldn’t call foldl a generalisation of recursion. it’s captures a specific recursion pattern so it’s more a specialization than a generalisation
00:01:55 <simon> cocreature, ok, that's better.
00:01:57 <revskill> input2 = input `substitute` definition1
00:02:02 <pavonia> You repeatedly apply functions until you get the final result, basically
00:02:05 <revskill> input3 = input2 `substitute` definition2
00:02:14 <ammar2> repeated substitution is an apt description of the lambda calculus
00:02:14 <revskill> is this a foldl ?
00:02:40 <mniip> revskill, you only substitute the functions that you see on the outside
00:03:01 <mniip> this leads to you sometimes substituting a function multiple times or not at all
00:03:56 <mniip> revskill, consider the program 'length (reverse [1,2,3])'
00:04:11 <mniip> you wouldn't substitute the definition of reverse first
00:05:12 <romanix> Hi Guys! I'm trying to port my code to Accelerate (http://hackage.haskell.org/package/accelerate) but I get strange results from using its fold function. It doesn't seem to behave like the usual folds. I'm sure it's a silly mistake on my part. Could someone take a look at https://lpaste.net/2746758536435335168? It's supposed to be a sum of squares of all elements of a vector.
00:06:18 <mniip> revskill, and even when you do substitute the definition of reverse at some point, reverse is recursive so one such substitution wouldn't make it
00:06:53 <mniip> revskill, evaluating a functional program isn't about globally substituting function definitions, on the contrary it's about locally substituting the needed definitions to reduce terms to WHNF
00:08:27 <cocreature> romanix: your fold function is not associative
00:08:30 <Athas> romanix: the fold operator has to be associative, and yours isn't.
00:08:31 <cocreature> > let f x y = x + y ** 2 in ((1 `f` 2) `f` 3, 1 `f` (2 `f` 3))
00:08:33 <lambdabot>  (14.0,122.0)
00:08:41 <Athas> Also, zero is not a neutral element for that function.
00:08:59 <cocreature> it looks like you might be able to first map (**2) over the elements and then fold with (+)
00:09:13 <revskill> we can define [1,2,3] `substitue` reverse = [3,2,1]
00:09:25 <revskill> then [3,2,1] `substitue` length = 3
00:09:36 <mniip> that's omitting all the interesting details
00:09:59 <revskill> actually, that substite is applying
00:10:50 <romanix> cocreature, Athas, thanks!
00:11:36 <mniip> revskill, what's '[1, 2, 3] ++ undefined'
00:12:22 <revskill> error ?
00:12:50 <revskill> What's interesting details do you talk about ?
00:13:04 <iqubic> > [1, 2, 3] ++ undefined -- think again
00:13:06 <lambdabot>  [1,2,3*Exception: Prelude.undefined
00:13:26 <iqubic> > head ([1,2,3] ++ undefined)
00:13:28 <lambdabot>  1
00:13:38 <iqubic> It works just like you'd think.
00:14:12 <mniip> revskill, if that's error then surely 'null ([1, 2, 3] ++ undefined)' is an error too
00:14:17 <mniip> let's check
00:14:18 <mniip> > null ([1, 2, 3] ++ undefined)
00:14:20 <lambdabot>  False
00:14:25 <mniip> oh no something is wrong with your model
00:14:33 <c50a326> anyone using haskell-lsp? the readme says it's not ready for casual use but... I'm curious
00:15:01 <iqubic> The error occurs when you try to use that value.
00:15:19 <iqubic> > head (undefined + [1,2,3])
00:15:21 <lambdabot>  error:
00:15:21 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_1123’
00:15:21 <lambdabot>      • In the expression: e_1123
00:15:32 <iqubic> > head (undefined ++ [1,2,3])
00:15:34 <lambdabot>  *Exception: Prelude.undefined
00:16:36 <iqubic> See, that's just giving me the string repersentation of undefined. It just gives me a printable version of undefined.
00:16:38 <revskill> so we can't know the result of a function when running is exception or not
00:24:02 <c50a326> why does getAddrInfo have to return `IO [AddrInfo]`? Why not just [AddrInfo]? What IO does it do?
00:24:11 <c50a326> (why can't this be pure?)
00:25:59 <xacktm> where is the address read from?
00:26:17 <cocreature> dns queries?
00:27:03 <typetetris> Did someone manage to build and install leksah in nixos?
00:27:48 <typetetris> oh, there is a ready to use nixpkg for it
00:30:42 <iqubic> typetetris: I can help you if you run into issues. I use NixOS.
00:32:52 <typetetris> .... if i try `nix-env -iA nixos.leksah` it starts to compile some stuff and fails, cause same package has a `ghc == 8.4.*` bound. But I use 18.03, which doesn't have ghc 8.4.*. So the build process for leksah did fetch some cabal package or something :( (so much for reproducible builds). I try updating my nixos-18.03 channel and try again.
00:33:27 <typetetris> Same error :(
00:34:39 <typetetris> haddock-api seems to be the offender
00:36:12 <hamishmack> typetetris https://github.com/leksah/leksah#nix-recommended-for-linux-and-macos-users
00:37:56 <hamishmack> leksah is a broken in nixpkgs itself and has been for some time, but if you run
00:37:58 <hamishmack> git clone --recursive https://github.com/leksah/leksah.git
00:38:03 <typetetris> hamishmack: I tried that, it build with "no error" but there isn't any usable binary later in `result`, just scripts, which don't seem to find the executable they want to start.
00:38:05 <hamishmack> cd leksah
00:38:11 <hamishmack> ./leksah-nix.sh
00:38:17 <hamishmack> it should install
00:38:32 <lavalike> c50a326: getAddrInfo is not deterministic
00:39:59 <typetetris> hamishmack: That is the error I get: `/nix/store/cx959n7yabxb0z4b2r3969qryr072qar-launch-leksah/bin/..launch-leksah-wrapped-wrapped: line 2: /home/typetetris/repos/leksah/dist-newstyle/build/x86_64-linux/ghc-8.0.2/leksah-0.17.0.0/x/leksah/build/leksah/leksah: No such file or directory`
00:40:24 <Ariakenom> c50a326, lavalike it also does network requests so literally I/O
00:40:39 <lavalike> Ariakenom: true!
00:41:10 <hamishmack> Interesting.  Does /home/typetetris/repos/leksah/dist-newstyle/build/x86_64-linux/ghc-8.0.2/leksah-0.17.0.0 exist ?
00:41:53 <c50a326> Ariakenom: is it possible though to just use the AddrInfo constructor deterministically?
00:42:19 <c50a326> I get that Socket needs to be IO Socket because it does IO
00:42:20 <cocreature> c50a326: sure just use the constructor directly instead of using getAddrInfo
00:43:13 <typetetris> hamismack: yes, but then there is no 'x' directory, but 'c'. If I call the binary there, it complains about missing config files.
00:43:23 <hamishmack> Ah
00:43:51 <hamishmack> So cabal changed the location it builds to from c to x
00:44:10 <typetetris> nice
00:44:23 <hamishmack> what version is cabal --version ?
00:45:07 <typetetris> How do I get the build environment, so I can call the cabal, the leksah builds uses? Or is really the cabal in my user environment relevant?
00:45:20 <typetetris> I use nixos.
00:45:58 <hamishmack> I think if it was picking up the one from the build env it should be using the newer one.  But it might pick up the one on the path when using linux-nix.sh
00:46:06 <hamishmack> I mean leksah-nix.sh
00:46:57 <typetetris> so its cabal-install 2.0.0.1 and cabal the library 2.0.1.0 and ghc 8.2.2 in my user env. But the build used ghc 8.0.2 so it should use a different cabal too?
00:47:02 <c50a326> can I use record syntax like additively... e.g. defaultHints returns a half full AddrInfo record. What's the syntax to build an AddrInfo from a defaultHints (without using getAddrInfo, just using record syntax)?
00:47:17 <typetetris> hamishmack: maybe we switch that to #nixos?
00:48:37 * hackage structured-cli 0.9.3.1 - Application library for building interactive console CLIs  http://hackage.haskell.org/package/structured-cli-0.9.3.1 (erick)
00:49:28 <cocreature> c50a326: you can use record updates, e.g., "defaultHints { addrAddress = … }"
00:49:44 <mniip> hmm
00:49:52 <mniip> is there something like STMap in a package somewhere
00:49:57 <c50a326> ah thanks
00:50:26 <cocreature> mniip: what is that supposed to be?
00:50:50 <mniip> the ST-mutable analog of Data.Map.Map
00:50:59 <koz_> mniip: hashtables package?
00:51:13 <koz_> Or do you need an _ordered_ map?
00:51:33 <cocreature> I’m not sure you gain much from making an ordered map mutable
00:51:43 <hamishmack> typetetris I have pushed a fix https://github.com/leksah/leksah/commit/0584fc92e6794494dd6443a443b8b35a8dcfe4d0
00:52:06 <c50a326> is there a way to configure `stack ghci` to always use overloaded strings?
00:52:25 <hamishmack> It moves the cabal-install pinned in default.nix to the front of the PATH in the launch script used to run cabal new-build in leksah-nix.sh
00:52:40 <mniip> cocreature, saving a few cycles on allocating a Bin constructor when you could've updated a MutVar instead?
00:53:40 <typetetris> hamishmack: I fear, I have to do a full rebuild now, with cabal version changed ... it took some time, so I will report in an hour or wether it helped
00:53:44 <cocreature> mniip: I’d be sceptical that this actually pays off but I’m happy to be proven wrong :)
00:55:32 <typetetris> hamishmack: Also the interpreter line of leksah-nix.sh should change from `#!/bin/bash` to `#!/usr/bin/env bash` otherwise one can't execute it on nixos.
00:57:49 <ventonegro> «OOP has long solved the "global state" problem»
00:57:52 <ventonegro> heh
00:58:52 <quicksilver> mniip: who knows. updated a MutVar might crash a write barrier, whilst allocating a Bin constructor in a CPU cache line is free, in a program where memory bandwidth is the bottleneck.
00:59:23 <hamishmack> Updated typetetris. Thanks
00:59:40 <quicksilver> mind you I don't really claim that Data.Map is the fastest solution to the problems it solves. I'm reasonably sure it isn't :) But, performance is subtle and allocation/GC inside CPU cache is way cheaper than you might imagine.
01:00:30 <typetetris> hamishmack: nice, dunno why but now it build nearly instantenously. Now I have to learn, how to setup my projects for leksah :)
01:00:51 <mniip> well yesterday I was investigating why 'length $ foldr id $ elems $ stuArrayOfBools' is 10 times slower than a manual loop
01:01:17 <drmr_> oh wow ghc 8.4 is out already
01:01:29 <Taneb> drmr_: 8.6 is coming very soon, too
01:01:36 <cocreature> drmr_: it has been out for months by now, 8.6 already has a first alpha :)
01:01:39 <drmr_> woah
01:01:48 <Taneb> (we're on a 6-month release cycle now)
01:03:48 <typetetris> hamishmack: hmm now it complains in its terminal window for the welcome project, that it is unable to build the test suite, due to some cabal black magic. But maybe I just have to learn cabal properly.
01:14:02 <typetetris> hamishmack: tried to add another package to the welcome project and now completion stopped working and I can't get it to get the package.
01:18:32 <c50a326> how can I constructor Word8 and Word32 values in GHCI? :s
01:18:44 <c50a326> construct
01:19:07 <Taneb> c50a326: just use the number literal, possibly with an explicit type signature
01:19:13 <Taneb> :t 17 :: Word8
01:19:14 <lambdabot> Word8
01:19:19 <Taneb> :t 12783 :: Word32
01:19:20 <lambdabot> Word32
01:19:32 <c50a326> oh type signatures, ok thanks
01:20:00 <c50a326> Taneb: ah what about a Word32 from 4 Word8's though?
01:20:21 <c50a326> > Word32 (1 :: Word8) (2 :: Word8) (3 :: Word8) (4 :: Word8)
01:20:21 <Taneb> That's trickier, I don't have a great way of doing that
01:20:24 <lambdabot>  error:
01:20:24 <lambdabot>      Data constructor not in scope:
01:20:24 <lambdabot>        Word32 :: Word8 -> Word8 -> Word8 -> Word8 -> t
01:20:27 <c50a326> :(
01:20:39 <gentauro>  :t fromIntegral
01:20:47 <gentauro> > :t fromIntegral
01:20:49 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
01:20:54 <c50a326> :t fromIntegral
01:20:55 <lambdabot> (Num b, Integral a) => a -> b
01:21:00 <gentauro> :t fromIntegral
01:21:01 <lambdabot> (Num b, Integral a) => a -> b
01:21:10 <gentauro> c50a326: that's your best friend ;)
01:21:32 <gentauro> I tend to use it when I do bitwise operations on bytes
01:21:40 <gentauro> and convert between Int/Word8/Char
01:21:45 <gentauro> works like a charm :)
01:22:04 <c50a326> gentauro: I don't get how that helps in this case, for the Word8 -> Word8 -> Word8 -> Word8 -> Word32 thing
01:23:14 <cocreature> \a b c d -> fromIntegral a `shiftL` 24 .|. fromIntegral b `shiftL` 16 .|. fromIntegral c `shiftL` 8 .|. fromIntegral d
01:23:17 <cocreature> :t \a b c d -> fromIntegral a `shiftL` 24 .|. fromIntegral b `shiftL` 16 .|. fromIntegral c `shiftL` 8 .|. fromIntegral d
01:23:18 <lambdabot> (Num a1, Integral a5, Integral a4, Integral a3, Integral a2, Bits a1) => a2 -> a3 -> a4 -> a5 -> a1
01:23:29 <cocreature> :t \a b c d -> fromIntegral a `shiftL` 24 .|. fromIntegral b `shiftL` 16 .|. fromIntegral c `shiftL` 8 .|. fromIntegral d :: Word8 -> Word8 -> Word8 -> Word8 -> Word32
01:23:31 <lambdabot> error:
01:23:31 <lambdabot>     • Could not deduce (Bits
01:23:31 <lambdabot>                           (Word8 -> Word8 -> Word8 -> Word8 -> Word32))
01:23:39 <cocreature> :t (\a b c d -> fromIntegral a `shiftL` 24 .|. fromIntegral b `shiftL` 16 .|. fromIntegral c `shiftL` 8 .|. fromIntegral d) :: Word8 -> Word8 -> Word8 -> Word8 -> Word32
01:23:41 <lambdabot> Word8 -> Word8 -> Word8 -> Word8 -> Word32
01:23:44 <cocreature> there you go :)
01:24:03 <c50a326> puh D:
01:24:33 <gentauro> c50a326: what cocreature wrote ;)
01:34:41 <mpickering> Can anyone recommend a CSV parsing library where the top-level parser has a signature of something like `parseCSV :: FilePath -> (CSVRow -> IO ()) -> IO ()` so the continuation is called immediately as each row is parsed
01:35:34 <merijn> mpickering: No clue if it's any good, but maybe csv-conduit?
01:35:46 <merijn> mpickering: This sounds like it begs for conduit/pipes/etc.
01:36:57 <mpickering> right something like transformCSV' could be what I need
01:37:19 <mpickering> good suggestion thanks
01:42:16 <hamishmack> typetetris you may need to restart ghci to get it to pick up the new package.  To do that click on the hammer and bug icon on the toolbar twice (once to turn off ghci mode and exit all running ghci sessions and once to reenable ghci mode).
01:44:15 <hamishmack> The autocomplete uses the cached cabal plan to determine the packages to include in autocompletion.  This is a bit unreliable and sometimes you may need to restart leksah for it to update properly.  Sometimes Tools -> Update System Data will work.
01:47:36 <gentauro> when I run: "stack --resolver lts-9.27 ..." are all these packages (.conf) files stored locally anywhere in ~/.stack? https://www.stackage.org/lts-9.21
01:48:01 <gentauro> or does it only retrieve pkg information for the used ones?
01:50:36 <gentauro> find ~/.stack -name "*.conf" <- hints me that only "used" packages are stored
01:52:25 <hamishmack> After adding a package if the autocomplete does not work I 1) Restart GHCi 2) Press Ctrl+B and make sure cabal is not failing to find a plan.  3) Restart Leksah.  If that does not fix it you can get more logging by running ./leksah-nix.sh --verbosity=DEBUG
01:52:46 <gentauro> is it possible to "download" all pkgs for a given LTS with stack? I recall for the MirageOS unikernel meetup in Marrakech that we had to previously download all pkgs due to really bad internets
01:52:50 <gentauro> :)
01:53:09 <lgas> "stack path" will show all the paths stack cares about.  I think global-pkg-db and local-pkg-db would be the ones relevant to your interest.
01:53:56 <gentauro> hamishmack: I tend to close emacs and start it up again, then intero solves it ;)
01:56:14 <power-fungus> There is no fedora-based ghc binary of 8.4.3 on https://www.haskell.org/ghc/download_ghc_8_4_3.html. Will there be someday?
01:56:21 <typetetris> hamishmack: Aehm i did exit leksah, but how do i restart it? result/bin/launch-leksah returns immediately and has return code 0 but no window appears.
01:57:02 <hamishmack> Just run ./leksah-nix.sh again
02:05:03 <typetetris> hamishmack: Hmm it complains: `Warning: The package list for 'hackage.haskell.org' does not exist. Run 'cabal update' to download it.` and `unknown package: doctest`. Sorry that I can't solve that myself, but I really don't know, how leksah manages all that stuff.
02:06:02 <hamishmack> I think yoy just need to run `cabal update` on the command line
02:06:54 <typetetris> hamishmack: Which working dir? `~/.leksah-0.17/leksah-welcome/` ?
02:07:07 <hamishmack> Any dir I think
02:07:41 <typetetris> ah, I don't used cabal up to now, just did `cabal2nix` and used `nix-shell` and `nix-build`.
02:07:42 <hamishmack> It downloads the hackage index into ~/.cabal somewhere
02:10:37 <typetetris> hamishmack: Ok leksah compiles the leksah-welcome project with the added conduit package now, but completion is still lacking. (did `cabal update` and restarted leksah).
02:15:31 <hamishmack> typetetris: It might still be collecting the metadata in the background.  After restarting leksah you should see something like this in the log.
02:15:38 <hamishmack> https://gist.github.com/hamishmack/176e4d6e92f4c668245e108e3885148c
02:15:53 <typetetris> I waited for all that to finish.
02:17:05 <typetetris> It completes the keyword `import`, but not the module names, which it did, when I first started it with the unmodified leksah-welcome project.
02:19:37 <hamishmack> Can you please restart leksah with ./leksah-nix.sh --verbosity=DEBUG and post the output to a gist or something?
02:19:56 <typetetris> of course
02:19:59 <hamishmack> It could be a ghc version mismatch issue
02:24:19 <hamishmack> You can change the version of ghc leksah-nix.sh uses to build leksah here https://github.com/leksah/leksah/blob/master/default.nix#L194
02:24:46 <hamishmack> The metadata collection works best if it matches the ghc that is in your PATH
02:25:09 <typetetris> That seems likely.
02:25:48 <typetetris> Ok, I'll try that, before I post a 4k lines log for you :D It it works, I don't waste your time like that.
03:12:47 <c50a326> yooooo wtf is all this https://i.imgur.com/7KwAhyT.png I think maybe it's from ALE?
03:13:25 <c50a326> I was writing some code and using stack and ale etc... and then my computer's power got cut off... I powered back up and now there are all these directories in my project root directory D:
03:14:34 <c50a326> this is horrible
03:21:36 <lavalike> you found the socks drawer
03:22:13 <c50a326> hahahaha
03:22:25 <c50a326> good one D: actually it does it even without powering off
03:24:07 <c50a326> hmmm https://github.com/DanielG/ghc-mod/pull/419
03:26:05 <c50a326> well I can't find any obvious answers with google :((
03:27:45 <c50a326> I guess I'll isolate which linter is causing this
03:28:24 <cocreature> there is a reason a fair amount of people avoid ghc-mod :)
03:31:38 <infinisil> Am also one of them
03:32:06 <infinisil> Struggled for too getting it to work, only for it to break next week
03:33:07 * hackage unwrapped-functors 0.1.0.0 - Unwrapping sums/products lifted to functors  http://hackage.haskell.org/package/unwrapped-functors-0.1.0.0 (int_index)
03:38:55 <c50a326> hey anyone using intero? I can't get out of the repl once I'm in it
03:39:03 <c50a326> I mean I can :q but then it's borked
03:39:06 <c50a326> this is in vim I mean
03:39:18 <c50a326> Esc doesn't work, C-w w doesn't work
03:39:37 * hackage inj-base 0.2.0.0 - 'Inj' instances for 'base'  http://hackage.haskell.org/package/inj-base-0.2.0.0 (int_index)
03:39:39 <c50a326> I can't send vim commands so I can't send :InteroHide
03:43:07 * hackage primitive-extras 0.1.9 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.1.9 (NikitaVolkov)
03:44:02 <AWizzArd> Is the Haste project still alive? The last commits seem to be 10 months old.
03:45:11 <Taneb> AWizzArd: ten months isn't that bad
03:49:53 <c50a326> ah, C-\ C-n
03:50:25 <c50a326> hmmm, C-\ C-n C-w C-w just to move back to the code :\
03:50:50 <c50a326> I think I'll drop intero, might as well just use a repl in an actual terminal
03:51:13 <quicksilver> what I find particularly confusing is that Haste is a dormant project from chalmers which shares a name with an older, unrelated (but still haskell) dormant project.
03:51:35 <quicksilver> naming's hard but they are both from chalmers! you think someone would have noticed...
03:58:40 <typetetris> hamishmack: So that worked.
03:59:00 <typetetris> But I still needed to restart leksah, but the completion worked then.
04:00:04 <hamishmack> I need to work out why the Tool -> Update System Metadata does not work as well as a restart
04:04:45 <typetetris> the completion worked before the restart too, but it didn't pick up the new modules. (I tried update system metadata).
04:08:38 <mniip> is there a book or something on performance in haskell
04:09:24 <mniip> like one of the major problems in haskell is that it hides runtime properties of the code from you
04:09:41 <mniip> inline a function and suddenly list fusion, specialization, unboxing, and your code is 100x faster
04:09:43 <c50a326> https://ptpb.pw/XIL8/hs how do I mold the types here :S
04:10:05 <c50a326> it moans about expecting Word32 and getting Word8 or vice versa
04:10:22 <c50a326> I tried throwing some `:: Word32` around
04:10:37 <mniip> the :: doesn't do a cast
04:10:44 <mniip> it specifies what the type should be
04:11:02 <mniip> you want to turn the 'x' from Word8 into Word32
04:11:22 <c50a326> (fromIntegral x :: Word32) maybe, I'll try that
04:11:36 <mniip> well that one doesn't need a type sig
04:11:43 <c50a326> aha it works! I think...
04:11:44 <quicksilver> just `fromIntegral x` will be enough
04:12:13 <quicksilver> by the way storing IPv4 addresses as Word32 is probably a terrible idea ;)
04:12:30 <quicksilver> but maybe that's not the point
04:13:42 <merijn> quicksilver: I don't think it is
04:13:55 <Taneb> quicksilver: that's how the `network` library does it
04:14:00 <merijn> quicksilver: Storing IPv4 addresses as Word32 is one of the canonical ways to store them
04:14:11 <merijn> quicksilver: dotted notation is crutch to visualise for humans
04:14:32 <c50a326> ah I also wanted a foldl rather than a foldr
04:14:43 <Maxdamantus> Makes things like subnet masking etc very easy too.
04:15:32 <Maxdamantus> I imagine you would at least want a newtype wrapper though, instead of just passing plain Word32s around in your program.
04:17:27 <quicksilver> merijn: I know it's canonical
04:17:45 <quicksilver> but it's probably not what you want inside a computer program written in haskell
04:17:51 <quicksilver> it might be what you use on the wire or on disk
04:18:41 <Maxdamantus> Well, people should probably generally recognise that the dotted notation is just that .. a human-level notation.
04:19:06 <Maxdamantus> We don't bother representing integers in decimal, even though that's the human-level notation. Why do it for IP addresses?
04:19:23 <quicksilver> because this is a typed programming language
04:19:36 <quicksilver> it doesn't make sense to multiply, add or subtract IPv4 addresses
04:19:41 <Maxdamantus> also, the "dotted notation" that I find most useful is more flexible than you would want when handling things internally.
04:19:45 <quicksilver> but it *does* make sense to do various other things with them
04:20:01 <Maxdamantus> eg, where you can write things like `127.1` or `0x7f.1`
04:20:18 <mniip> Maxdamantus, that depends on the parser
04:21:00 <Maxdamantus> Yeah, but those notations seem to work with most things I tend to enter IP addresses into (ping, curl, etc)
04:21:02 <mniip> I've seen great variation regarding support of '0177.0x1' in various IP address parsers
04:21:12 <Maxdamantus> Unfortunate that it tends not to work well in browsers.
04:21:29 <mniip> inet_pton
04:22:54 <mniip> ping is old enough that it might be using inet_aton
04:22:58 <mniip> no IPv6 support!
04:23:25 <merijn> mniip: That's what ping6 is for
04:23:34 <Maxdamantus> quicksilver: I don't see an issue with doing something like "127.0" + "1" .. "127.0" + "12345", etc
04:24:16 <Maxdamantus> "127.0" + "1" = "127.0.0.1"; "127.0" + "12345" = "127.48.57"
04:24:19 <mniip> Maxdamantus, I'd phrase that as ("127.0" <|>) <$> [1 .. 12345]
04:24:30 <mniip> using <|> and not +
04:24:32 <mniip> er
04:24:35 <mniip> I guess I meant .|.
04:24:47 <Maxdamantus> mniip: it wasn't meant to be an actual range, was just giving two similar examples.
04:26:26 <Maxdamantus> quicksilver: also note that the bit positions of the dots should be kind of irrelevant. In the example above the addresses are probably using a /8 subnet, but subnet lengths obviously don't have to be multiples of 8.
04:27:34 <quicksilver> you're kind of cross purposes to my point.
04:27:55 <quicksilver> All I'm saying is that IP4 addresses (and indeed subnets as you say) don't have the semantics of integers
04:28:15 <quicksilver> and in a typed programming language you'd want to use a richer type which has the operations you happen to need
04:28:22 <quicksilver> whatever those might be.
04:28:41 <Maxdamantus> Right .. so that probably just means wrapping a Word32
04:28:53 <liste> c50a326: foldl' is almost always better than foldl
04:29:01 <liste> though in this case it probably doesn't matter
04:29:06 <Maxdamantus> as the "network" library presumably does based on a previous comment.
04:32:37 * hackage primitive-extras 0.1.10 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.1.10 (NikitaVolkov)
04:39:37 * hackage named 0.2.0.0 - Named parameters (keyword arguments) for Haskell  http://hackage.haskell.org/package/named-0.2.0.0 (int_index)
05:09:48 <bwe> I try to implement "sub-types". What is a sane way to go about it? https://repl.it/repls/ThickTechnologicalSet
05:10:37 * hackage primitive-extras 0.1.11 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.1.11 (NikitaVolkov)
05:15:51 <Saulzar_> Do any of you use reflection instead of ReaderT to implement environments for their programs? Seems it should be a much more concise interface provided you're not modifying things with 'local'
05:16:33 <c50a326> so what does something like Network.Socket.bind do if the port is already in use :o I guess I'll try (docs don't cover this)
05:17:47 <Tuplanolla> See `man 2 bind`, c50a326.
05:18:40 <c50a326> thanks
05:18:41 <Tuplanolla> The Haskell version works the same with the addition of checking the return value and throwing an exception.
05:19:53 <c50a326> Tuplanolla: so do you just handle that with a Maybe somewhere, or...?
05:19:55 <c50a326> bind :: Socket -> SockAddr -> IO ()
05:19:57 <lyxia> Saulzar_: have you heard about ImplicitParams
05:20:09 <c50a326> you can't have Maybe IO () can you lol
05:20:34 <Tuplanolla> You're in `IO`, where `bracket` and friends operate.
05:20:54 <c50a326> oh yeah true, I read briefly about that. Okay thanks, I'll learn about bind now also
05:21:54 <mnoonan_> you can have "Maybe (IO ())"
05:22:07 * hackage primitive-extras 0.1.12 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.1.12 (NikitaVolkov)
05:22:28 <c50a326> lol AF_APPLETALK
05:22:31 <mnoonan_> "I might have an IO action"
05:24:04 <Saulzar_> lyxia, Yes.. from what I understand they've got a lot of problems which reflection avoids
05:27:05 <lyxia> Saulzar_: I guess that's true. I think it's just that the RankNType-ness of reflection makes it a nonobvious solution.
05:27:28 <dmj`> I have a haskell package locally, how do I nix-env -iA it into my profile
05:28:28 <Saulzar_> lyxia, I just haven't noticed if anyone actually uses it much in their programs, it seems to me that it has quite a bit less boilerplate than ReaderT (potentially)
05:30:16 <Vides> Client: HexChat 2.14.1 • OS: Microsoft Windows 10 Pro for Workstations (x64) • CPU: Intel(R) Xeon(R) CPU E5-2620 v3 @ 2.40GHz (2.40GHz) • Memory: 31.9 GiB Total (18.9 GiB Free) • Storage: 212.9 GiB / 476.3 GiB (263.5 GiB Free) • VGA: NVIDIA Quadro K2200 • Uptime: 1w 3d 0h 21m 0s
05:30:17 <quicksilver> ImplicitParams are nasty
05:30:41 <merijn> quicksilver: Implicit params let you do super neat hacks! \o/
05:30:53 <quicksilver> so do machetes
05:31:04 <merijn> I would argue that machetes are also cool :p
05:31:36 <cocreature> they might be cool but I still wouldn’t want one in my face
05:31:41 <lyxia> Saulzar_: The main difference seems to be that reflection can be used outside of a monadic context. But if you're already going to have monadic code (which is often), putting a MonadReader on top is not going to be much more costly.
05:31:42 <quicksilver> yes, as long as you don't keep them in my type system
05:32:28 <dmj`> wrong channel :)
05:33:02 <mniip> lyxia, Saulzar_ in fact reflection has about the same internal implementation as ReaderT
05:33:29 <mniip> just that in ReaderT the parameter passing is under a newtype, and in reflection the parameter passing is implicit
05:35:17 <Saulzar_> I just have a particular record which I pass around in a reflex program with some global environment/settings and I end up using it like:  myFunction = do MyEnv{..} <- ask; ...
05:35:52 <mniip> have you considered using
05:35:53 <mniip> :t asks
05:35:54 <Saulzar_> and I prefer to use where instead of let, reflection would allow me to shift lots of things into the 'where'
05:35:55 <lambdabot> MonadReader r m => (r -> a) -> m a
05:37:04 <Saulzar_> Oh yeah, I'm quite familiar with ReaderT - it's just I think reflection would clean things up nicely. I'm just curious if/why it's not used more
05:37:46 <mniip> hmm
05:37:59 <mniip> there was this guy dataN - I think I understand his ramblings now
05:38:31 <mniip> was he trying to implement StateT by analogy with ReaderT <=> Reifies
05:39:17 <Saulzar_> State seems like a whole different kettle of fish..
05:40:45 <cocreature> Saulzar_: ReaderT is something where you can fully understand the inner workings after having written Haskell for the few weeks. reflection relies on unsafeCoerce and knowledge about GHC internals. so I don’t think it’s particularly surprising that ReaderT is used far more often than reflection
05:41:15 <mniip> cocreature, actually there's a safer implementation of reflection
05:41:20 <mniip> requiring no unsafecoerce
05:41:44 <Saulzar_> Oh, nice. Is it a different package?
05:41:46 <cocreature> iirc that’s quite complex as well and nobody uses it :)
05:41:50 <mniip> no, it's the same package
05:41:57 <Saulzar_> Hmm
05:41:58 <mniip> you reflect individual bytes
05:42:05 <mniip> and then encode a StablePtr
05:43:10 <mniip> also in newer GHCs there's a thing called
05:43:16 <mniip> % :t GHC.Prim.magicDict
05:43:17 <Saulzar_> Ah, that's the 'slow' flag
05:43:26 <yahb> mniip: a
05:44:32 <mniip> now magicDict has a type that's not expressible in haskell, but it's expressible in core so you get a lint error if you use it wrong
05:45:22 <mniip> now to use it you do something like
05:45:34 <Ariakenom> mniip: Ah the Haskell type is too permissive?
05:46:06 <mniip> Ariakenom, no, the type is something like (c => a) -> c -> a
05:46:20 <mniip> can't do with Constraint ~/~ *  in source haskell
05:46:59 <Ariakenom> I meant the Haskell type (as  opposed to Core type) is too permissive so you get a Core error
05:47:11 <mniip> yes
05:47:19 <mniip> % magicDict ()
05:47:20 <yahb> mniip: ghc: ^^ Could not load 'ghczmprim_GHCziPrim_magicDict_closure', dependency unresolved. See top entry above.; ByteCodeLink.lookupCE; During interactive linking, GHCi couldn't find the following symbol:; ghczmprim_GHCziPrim_magicDict_closure; This may be due to you not asking GHCi to load extra object files,; archives or DLLs needed by your current session. Restart GHCi, specifying; the missing libra
05:47:52 <mniip> I suspect it's not usable from ghci at all
05:48:04 <cocreature> % :set -fobject-code
05:48:05 <yahb> cocreature:
05:48:08 <cocreature> % magicDict ()
05:48:08 <yahb> cocreature: ghc: ^^ Could not load 'ghczmprim_GHCziPrim_magicDict_closure', dependency unresolved. See top entry above.; ByteCodeLink.lookupCE; During interactive linking, GHCi couldn't find the following symbol:; ghczmprim_GHCziPrim_magicDict_closure; This may be due to you not asking GHCi to load extra object files,; archives or DLLs needed by your current session. Restart GHCi, specifying; the missing libra
05:48:16 <cocreature> hm
05:48:34 <mniip> it's a wired in symbol so
05:49:35 <mniip> https://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.TypeNats.html#withSNat
05:51:01 <mniip> note that SNat n  has the same representation as the KnownNat n  dictionary
05:51:35 <Saulzar_> I am not quite sure I see the point of the Reifies class (as opposed to Given), it gives you a type proxy - but then you'd need to pass around the type proxy to use it?!
05:51:47 <mniip> no
05:51:57 <mniip> you can use any other way to pass the type variable
05:52:15 <Saulzar_> Ah right, it's just you end up with an extra type variable
05:52:49 <Saulzar_> That makes sense
05:53:16 <mniip> you could use the uhhh
05:53:18 <mniip> Tagged monad!
05:53:52 <mniip> tAsk :: Reifies s a => Tagged s a
05:53:54 <mniip> :D
05:54:00 <Saulzar_> Haha
06:05:23 <power-fungus> has anybody experience with cabal new-build on archlinux?
06:07:10 <ixxie> does anybody know how haskell work with a schemaless document database?
06:08:01 <merijn> ixxie: Presumably the same way any other language does?
06:08:52 <ixxie> I mean, I heard that it works particulaly nicely with relational databases but I am wondering how the typing system works when the schema is dynamic
06:08:54 <cocreature> power-fungus: yes but that’s probably not your actual question, so I would recommend asking that instead :)
06:13:09 <c50a326> why do resources suggest that Applicative is great for learning Monad
06:13:54 <c50a326> and why is Functor under Data.Functor yet Applicative and Monad are under Control
06:14:18 <merijn> c50a326: Control vs Data is a rather arbitrary and nonsensical distinction, don't worry about it too much
06:14:32 <merijn> c50a326: So "hysterical raisins"
06:15:09 <merijn> Monad expands upon Applicative, which expands upon Functor, so learning them in order can help understand what exactly each step adds
06:15:15 <power-fungus> cocreature: When I build packages with more dependencies I get an error like "could not find module X; There are files missing in Y"
06:16:21 <c50a326> merijn: so if I want to do some IO, can I do some IO just using functor/applicative and not monad?
06:16:26 <merijn> c50a326: So a subset of all Functors is *also* an Applicative and a subset of all Applicatives is also a Monad.
06:16:33 <merijn> c50a326: Yes
06:16:57 <[exa]> ixxie: afaik it will be driven by the data format that the database outputs
06:17:16 <c50a326> is it possible to re-write the example code block at the top of this docs http://hackage.haskell.org/package/network-2.7.0.2/docs/Network-Socket.html without using Monad, only using Functor and Applicative methods? :S
06:17:17 <[exa]> ixxie: what's the database btw?
06:17:17 <merijn> c50a326: Alternatively, Applicative provides a subset of the functionality of Monad and Functor applies a subset of the functionality of Applicative
06:17:34 <c50a326> merijn: don't I need >>= to do IO?
06:17:41 <c50a326> (or do notation)
06:17:55 <c50a326> I can do IO with <*>? or also with <$>?
06:18:04 <[exa]> c50a326: you need >>= to retrieve IO results
06:18:18 <merijn> c50a326: That depends on what you're doing. You can't do the same things with all of those. For some things you want to do with IO you will need >>= (and thus Monad)
06:18:54 <merijn> c50a326: It just means that if you write code that only uses Applicative it can be used with more datatypes (since more things happen to be Applicatives)
06:19:33 <power-fungus> cocreature: example when building haskell-ide-engine: https://pastebin.com/9GR2sPcB
06:19:34 <merijn> c50a326: When dealing with one specific datatype (like IO) it doesn't really matter much which classes functions you use (except that some things can be done with Monad that can't be done using just Applicative)
06:19:56 <merijn> c50a326: So no, not everything in that example can be done with Applicative (in fact, quite a lot can't)
06:20:58 <merijn> c50a326: The key insight is that >>= lets future actions depend on the result of previous ones
06:21:01 <merijn> :t (>>=)
06:21:02 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:21:42 <merijn> c50a326: Here the returned "m b" is allowed to depend on the value of "a" (for example, the "listen" action can depend on the Socket produced earlier)
06:21:57 <merijn> c50a326: Applicative explicitly does not/cannot let actions depend on previous results
06:22:01 <merijn> :t (<*>)
06:22:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:23:37 <c50a326> I see
06:23:48 <c50a326> I kind of get it and I get how to use it... but I don't really get where the magic is happening tbh
06:23:53 <merijn> c50a326: Since both sides of <*> are already "f" so the effects don't depend on the results returned
06:24:07 <[exa]> c50a326: perhaps there's no magic? :D
06:25:12 <c50a326> I'm having a hard time matching up the "actions can depend on previous results" to the class type signatures
06:25:25 <c50a326> sorry to those method type signatures, I should say **
06:25:53 <[exa]> anyway guys -- I want to make a tiny protocol for sending a bit of structured information in UDP packets, mostly Ints and ByteStrings in lists. Is there some good format for such simple data with a simple parser/encoder in haskell?
06:26:21 <[exa]> (json is probably overkill)
06:26:36 <c50a326> ooo I'm interested in this question also ^^ I was thinking of making a binary format just for learning/fun soonish
06:26:48 <merijn> c50a326: Well, look at the second argument of >>=
06:26:59 <Saulzar_> mniip, I gave it a try in my application - one immediate downside is that it doesn't play so nicely with polymorphic types. I'm using reflex so my environment is parameterized by 't' - for non Reflex values e.g. Text, you get ambiguous type errors
06:27:14 <merijn> c50a326: The type is "a -> m b", so this is just a normal function taking an 'a' and it can do anything you want to that 'a'
06:27:36 <merijn> c50a326: consider '\b -> if b then return () else putStrLn "whoo!"'
06:27:36 <[exa]> c50a326: about the monads -- did you see how the do notation gets rewritten to >> and >>= ?
06:27:55 <merijn> c50a326: The result of that function depends on the Bool returned by the left hand of >>=
06:28:29 <Saulzar_> mniip, I would argue that the 't' parameter is should be disposed of - but that's another issue entirely :)
06:28:38 <merijn> c50a326: With <*> you just have "IO (a -> b)" and "IO a", note how 'a -> b' applied to 'a' can't actually affect which actions happen
06:29:09 <merijn> c50a326: Because the function 'a -> b' doesn't return anything related to IO
06:29:26 <c50a326> ah yes
06:29:57 <merijn> c50a326: This difference of "actions *can* depend on results of previous actions" is the exact difference between Monad and Applicative
06:30:36 <c50a326> thank you
06:30:57 <c50a326> it's really subtle in abstract, isn't it
06:31:05 <[exa]> there's the alternative explanation with 'join' btw... suppose you want to read a line and print it out
06:31:06 <c50a326> but yeah it makes sense
06:31:27 <merijn> c50a326: This is why, for example why Concurrently in the async library is Applicative, and not a Monad: https://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html#t:Concurrently
06:31:49 <merijn> c50a326: Because if actions cannot depend on previous results, that means you can trivially run them in parallel
06:32:04 <hexagoxel> power-fungus: have you followed the arch wiki haskell advice?
06:32:12 <c50a326> also how does an action even work?
06:32:23 <c50a326> I guess I can just look at the source for putStrLn
06:32:26 <merijn> c50a326: That depends on the concrete type you happen to be talking about
06:32:35 <[exa]> with functors/applicatives you'd try to do something like `putStrLn <$> getLine', but that has a type IO (IO ()), a monadic action returned by monadic action!
06:32:41 <c50a326> well for IO specifically
06:32:46 <merijn> c50a326: In case of IO "how it works" is "unspecified implementation specific magic"
06:33:17 <merijn> c50a326: (It abuses a low level magic version of State to enforce an ordering on IO operations)
06:33:43 <[exa]> and monads have the alternative 'join' definition with the type that exactly solves that monad-in-monad problem: join :: Monad m => m (m a) -> m a
06:33:56 <merijn> c50a326: In the end the actualy IO just happens as assembly that makes system calls to the OS, like any language
06:34:00 <power-fungus> hexagoxel: I tried, but there is to advice for new-*
06:35:42 <merijn> c50a326: In the end GHC just generates assembly, but IO's implementation is basically builtin magic that controls when it can get run, in which order, etc.
06:35:43 <cocreature> power-fungus: new-* doesn’t change anything here. the errors suggest that you have installed haskell packages using pacman
06:35:51 <cocreature> power-fungus: you sohuld only install ghc and ghc-static via pacman
06:37:09 <power-fungus> cocreature: indeed, I have installed many haskell-* libraries as dependency of many other tools (pandoc, stack, ...)
06:37:19 <merijn> c50a326: Function purity is a matter of "observable interface", GHC is free to use as many dirty/imperative tricks it likes, as long as the end result happens to behave as magical pure implementation would. (The same applies to every language that has a standard that's independent from it's implementation)
06:37:54 <hexagoxel> or install ghc/cabal from source instead of via pacman. i can confirm that this route works, at least.
06:38:18 <merijn> hexagoxel: I'd install from bindist, rather than source
06:38:31 <merijn> hexagoxel: Because source requires you to have a working GHC to begin with :)
06:38:40 <cocreature> how you install GHC is pretty much orthogonal to this problem
06:38:40 <hexagoxel> right
06:39:33 <hexagoxel> but bootlibs being available as static or not is a consequence of how you install ghc?
06:40:02 <cocreature> power-fungus: so remove all of those and then install cabal either via its bootstrap script, download a cabal bindist (not sure how well these work these days) or download a stack binary and use that to bootstrap cabal
06:40:14 <power-fungus> still, for example "cabal install doctest" complains with the above error https://pastebin.com/9GR2sPcB
06:40:15 <cocreature> hexagoxel: right but that’s easily solvable by installing ghc-static
06:40:27 <cocreature> have you installed ghc-static?
06:40:33 <hexagoxel> thats hardly orthogonal :/
06:41:00 <power-fungus> cocreature: I do not want remove haskell-* libraries as many other packages depend on them
06:41:40 <cocreature> hexagoxel: fair enough, my point is it is pretty to get a working GHC install regardless of whether you get it via pacman, build it yourself or download a bindist
06:41:47 <cocreature> the problem comes when you install more than ghc via pacman
06:41:58 <cocreature> power-fungus: well those packages are what are causing problems :)
06:42:29 <merijn> power-fungus: That's because the arch Haskell maintainer has decided to throw every single user under the bus with their believe that everything should be dynamically linked
06:43:10 <cocreature> if you insist on installing packages globally, you probably have to use dynamic linking all the way
06:43:18 <merijn> power-fungus: If you don't want to/can't uninstall those package your only option is to yell at the Haskell arch maintainer to stop breaking things so badly
06:43:18 <fendor> merijn, is it smarter to always link it statically?
06:43:26 <power-fungus> cocreature, merijn: indeed. I hoped that I can have an isolated ghc for development.
06:43:43 <merijn> fendor: I would argue, yes. But *especially* for Haskell
06:43:50 <cocreature> power-fungus: sure that should work. download a GHC bindist and add the GHC in there to your PATH
06:44:03 <cocreature> or pass "-w /path/to/ghc" to cabal
06:44:05 <hexagoxel> if you add the stuff to the cabal.config as suggested in the arch wiki, new-build should use dynamic linking consistently and work, right?
06:44:07 <fendor> merijn, why especially for haskell?
06:44:08 <merijn> fendor: GHC does not have a stable ABI, so you can't really upgrade a dependency without recompiling its dependents
06:44:12 <cocreature> then it should hopefully ignore the global mess
06:44:34 <fendor> merijn, is that a fault of haskell or is it just the way it is?
06:45:04 <power-fungus> cocreature: I will try that
06:45:18 <merijn> fendor: GHC fakes a form of "whole-code optimisation" in that it can do cross-module and cross-library inlining of code, which can gain you *a lot* of performance
06:45:38 <merijn> fendor: But it also means that unexposed implementation details of dependencies can leak into your executables
06:46:05 <power-fungus> cocreature: where to get a ghc for user-level installation?
06:46:13 <merijn> fendor: The two main arguments for dynamic linking are: 1) ability to upgrade independently and 2) saving disk space
06:46:45 <cocreature> power-fungus: https://www.haskell.org/ghc/download_ghc_8_4_3.html
06:46:55 <merijn> fendor: Due to the lack of ABI stability is out, so 2 is the only real gain. But the gain is rather minimal compared to hassle dynamic libs bring. Just building a single static executable makes life much simpler
06:47:07 <merijn> s/is out/1 is out/
06:48:04 <merijn> fendor: It's a restructuin of GHC Haskell, but whether you consider it a fault or feature depends on your point of view
06:48:38 <fendor> merijn, your explanations makes sense, but obviously the arch maintainer kind of disagrees :D
06:48:46 <fendor> *makes sense to me
06:49:20 <merijn> fendor: The Arch maintainer(s) have decided they want everything dynamically linked, so they only ship dynamic libs. However, GHC default is to build statically, so when you try and build your own stuff and it ends up using pacman installed dependencies everything goes to hell
06:49:28 <__monty__> merijn: Is the space savings really so small? I've heard 100's of MB per binary. That sounds non-negligible.
06:49:53 <merijn> __monty__: Depends whether you strip your binaries and use splitobjs
06:50:03 <merijn> __monty__: You can already save a lot of space that way
06:50:44 <merijn> __monty__: Those two can easily drop executables from 50mb to like 8mb
06:51:12 <merijn> And considering the space of modern harddrives, I don't really care about an executable being 100 MB
06:51:26 <merijn> Compared to the hassle of saving a few 10s of MB
06:52:03 <cocreature> the space savings also only apply _if_ you have multiple things linked against the exact same version
06:52:25 <cocreature> given the number of popular Haskell applications, that’s not super likely to happen for people that only use Haskell applications
06:52:27 <[exa]> merijn: you need to get that into memory
06:52:32 <Logio> merijn: isn't the space saving mainly a factor for RAM?
06:52:37 * hackage battleplace 0.1.0.6 - Core definitions for BattlePlace.io service  http://hackage.haskell.org/package/battleplace-0.1.0.6 (quyse)
06:52:39 <merijn> [exa]: Literally every OS uses lazy paging
06:52:42 <cocreature> and if you’re a dev, you are probably going to end up linking against different versions
06:52:42 <[exa]> merijn: also *cough* cache
06:52:43 <merijn> [exa]: So you don't
06:52:53 <merijn> [exa]: Cache only matters if that code actually runs
06:53:15 <[exa]> so it only matters if you only want performance
06:53:19 <[exa]> ... ok :]
06:53:19 <bwe> I am working through https://wiki.haskell.org/Typeclassopedia, "Implement Functor instances for Either e and ((->) e).": https://bpaste.net/show/53449a3feabd
06:53:36 <mniip> bwe, that's not correct
06:53:37 * hackage battleplace-api 0.1.0.2 - Public API definitions of BattlePlace.io service  http://hackage.haskell.org/package/battleplace-api-0.1.0.2 (quyse)
06:53:39 <merijn> [exa]: No. Because if that executable is split into multiple dynamic libraries you still have to load all that into memory
06:53:55 <merijn> [exa]: So you don't take less space in memory with dynamic linking, it's exactly the same thing
06:53:59 <[exa]> chances are that libc (and most others) are already there
06:54:02 <__monty__> Does it have to be a hassle though? Even if you need multiple versions of every dynamic lib it'd still be easier to just pass a --dynamic flag than to strip binaries or pass --split-objs (which is incompatible with backpack apparently).
06:54:12 <merijn> [exa]: We're talking about Haskell, though
06:54:22 <merijn> [exa]: libc is already linked dynamically in Haskell executables
06:54:26 <mniip> bwe, do you realize the difference between 'Either e' and 'Either'
06:54:32 <merijn> [exa]: Only Haskell dependencies are static by default
06:54:37 <[exa]> merijn: haskell cannot mmap the library code?
06:54:40 <agentultra> Does anyone know how to write the equivalent SQL query in Esqueleto? `select exists(select 1 from table where id = ? and version = ?)`? I wrote a function to map the `exists()` function using `unsafeSqlFunction` but I don't think I have it quite right; getting type mismatches. Maybe there's an easier way..
06:54:53 <merijn> [exa]: I dunno what you mean by that?
06:55:14 <[exa]> well normal C-style libraries are mmapped and shared so they actually don't consume ram
06:55:20 <[exa]> I thought haskell does the same
06:55:41 <merijn> [exa]: Executables generally get run the same way
06:56:37 <bwe> mniip: Not really, tbh. data Either a b = Left a | Right b  -- so Either e would then be partial application, is it?
06:56:39 <merijn> [exa]: So I suppose if you load many executables that share dependencies you might load slightly more stuff, but there's a million other things that will bottleneck you or run you out of RAM before that starts to matter
06:56:41 <Logio> merijn: isn't it still reasonable from a packaging standpoint (for users, not developers) to enforce dynamic linking, if most of the repo packages link to the same versions?
06:56:54 <mniip> bwe, it's a partial *type* application
06:57:13 <cocreature> Logio: users seems to be pretty unhappy with having to install 100 packages just to get pandoc
06:57:15 <mniip> 'Either a' is not a type in the sense that it isn't inhabited by values
06:57:21 <merijn> Logio: For end users, maybe. But the result of not shipping static libs on Arch is that it becomes unusable for developers
06:57:23 <[exa]> merijn: well imagine a UNIX made of completely static haskell
06:57:42 <mniip> bwe, in haskell we have a system of kinds (types of types) to reason about this
06:57:45 <merijn> Logio: And due to the small nature of Haskell libs the huge amount of dependencies annoys end users on Arch, yeah
06:57:55 <Logio> merijn: sure, but that's a separate problem
06:58:20 <cocreature> is it? I don’t think it makes sense to consider linking in isolation from how users are going to use these packages
06:58:36 <mniip> bwe, types with values (stuff you declare with 'data') have kind *
06:58:46 <Logio> cocreature: I don't see why the # of dependencies is a problem
06:58:47 <cocreature> once it’s realistic to expect pure users to install tens of Haskell apps linked against the same version of a dep, you can always reconsider your decision
06:58:49 <merijn> Logio: Well, the conclusion seems to be that Arch's dynamic apporach pisses off *both* Arch users *and* Haskell developers :)
06:58:55 <mniip> bwe, so  Either a b :: *
06:59:11 <mniip> but only if a and b are :: *, hence we can say that  Either :: * -> * -> *
06:59:13 <__monty__> cocreature: That's easily hidden in a UI though "Installing pandoc..." Instead of 'Installing a, b, c, d, kitchensink for pandoc..."
06:59:22 <bwe> :kind Either e would have Either :: * -> *
06:59:25 <Logio> I've dealt with the Arch ghc and it wasn't that painful once you realized what the deal was
06:59:42 <mniip> bwe, Either e :: * -> *
06:59:46 <mniip> if that's what you're saying
06:59:56 <cocreature> the thing is, ever since arch switched to dynamic linking we have multiple people per week coming here with problems caused by that
06:59:57 <power-fungus> cocreature: The fedora27 download is missing from https://www.haskell.org/ghc/download_ghc_8_4_3.html and the debian 9 download requires libtinfo.so.5, but I only have libtinfo.so.6
07:00:06 <bwe> :kind Either e :: * -> *
07:00:14 <Logio> cocreature: sure, I get the frustration
07:00:14 <bwe> mniip: Agreed upon.
07:00:16 <cocreature> so while it is possible to work with it, it has certainly caused much confusion and trouble
07:00:40 <cocreature> while the gains are at best 0
07:00:46 <merijn> Logio: See: https://www.reddit.com/r/archlinux/comments/7jtemw/which_package_do_you_hate_the_most/dr962cm/
07:01:31 <maerwald> directory and filepath :p
07:01:57 <bwe> mniip: Did I implement Either e correctly, then? https://bpaste.net/show/65736260c249
07:02:03 <Logio> merijn: I can't really sympathize with the arch frustration that much; I generally run Gentoo and have to actually compile all those deps for Pandoc :P
07:02:07 <mniip> bwe, no
07:02:30 <mniip> you say
07:02:30 <mniip>   fmap :: (a -> b) -> Either a -> Either b
07:02:34 <mniip> but Either a :: * -> *
07:02:44 <mniip> so this type signature is nonsense
07:03:18 <cocreature> power-fungus: maybe try 8.4.2?
07:03:34 <cocreature> or build it yourself
07:03:34 <maerwald> gentoo haskell is terrible too
07:03:48 <mniip> bwe, the type signature for fmap suggests that the type variable 'f' that appears in the instance head must be of kind  * -> *
07:03:50 <mniip> :t fmap
07:03:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:04:06 <mniip> hence, only *->* kinded things can be an instance of Functor
07:04:27 <Logio> maerwald: How so? I've found that portage does a nice job with haskell these days, and even the main repo is pretty up-to-date
07:04:37 <mniip> hence, literally "Either" cannot be an instance of Functor
07:04:40 <mniip> but "Either e" can
07:04:59 <mniip> but when defining an instance of Functor (Either e) you have to substitute (Either e) in place of f
07:05:06 <mniip> which you didn't do correctly
07:05:28 <Logio> there's a whole lot of compilation to do every time you update, sure, but that's just Gentoo
07:05:58 <maerwald> Portage is the most broken package manager. The ebuilds don't support hackage metadata revisions, but sed it, you can't run multiple ghc versions properly and the aubslotting technology for rebuilding is crap
07:07:37 <Logio> I'd say Portage is the worst package, if not for all the others
07:07:53 <fendor> well, so what operating system is suitable for haskell development? seems like a lot of them just cause hassle
07:07:55 <Logio> it's the only one that actually lets you solve problems
07:08:03 <mniip> fendor, templeos
07:08:09 <Logio> instead of waiting for someone upstream to solve them
07:08:23 <__monty__> fendor: NixOS is awesome for haskell.
07:08:30 <merijn> fendor: For development it's easy, just install GHC bindist yourself and don't use the package manager
07:08:55 <maerwald> merijn++
07:09:03 <merijn> fendor: On every *nix OS I work on I just download and install the GHC bindist, install cabal-install and then just install all Haskell things via cabal-install
07:09:10 <maerwald> the precompiled once can be installed in any prefix
07:09:30 <merijn> fendor: Works exactly the same on every *nix OS that's supported by GHC. Learn to do it once and you can work on any OS :)
07:09:47 <maerwald> so even if you don't like stack, it's easy to run multiple independent ghc versions
07:09:52 <bwe> mniip: I got until the point of partial type application: Either e -- has kind * -> *  ; which is required to imlement instance of Functor.
07:09:52 <fendor> merijn, what is the GHC bindist?
07:10:06 <merijn> fendor: "./configure --prefix=$HOME/ghc-Version/ && make install", change your path to switch GHC versions and done
07:10:17 <fendor> merijn, oh so building from source?
07:10:18 <merijn> fendor: https://www.haskell.org/ghc/download_ghc_8_4_3.html#binaries
07:10:18 <bwe> mniip: fmap :: (a -> b) -> (Either a) -> (Either b) -- Why is this wrong?
07:10:18 <cocreature> bindist = binary distribution
07:10:32 <merijn> fendor: No, bindist = binary distribution == precompiled
07:10:49 <merijn> fendor: Make install and configure just copy the files into the right directories and setup paths, etc.
07:11:32 <[exa]> bwe: Either type constructor should have 2 parameters
07:11:38 <fendor> but then i have to handle my installation kind of by myself?
07:11:54 <fendor> __monty__, i kind of disagree :D
07:11:56 <merijn> fendor: --prefix lets you specify a directory to install in
07:11:57 <cocreature> fendor: what do you mean by “handle your installation”?
07:12:02 <cocreature> it just sits in some directory
07:12:05 <maerwald> I have a bashrc function to switch ghc version, it's trivial
07:12:09 <merijn> fendor: So I change versions by change which subdir my path points too
07:12:21 <cocreature> or you can pass -w to cabal
07:12:27 <merijn> fendor: And uninstalling is just "rm -rf installdir" and then nuking .cabal/config
07:12:31 <merijn> eh
07:12:39 <merijn> "~/.cabal/" not .cabal/config
07:12:42 <fendor> cocreature, i have to manually update my ghc version, when working on projects with different ghc i have to manually change the path?
07:12:44 <maerwald> and your ghc versions never conflict with each other, because the database locations are all different
07:13:02 <merijn> fendor: You can pass explicit -w or adjust path to switch versions
07:13:05 <bwe> [exa]: which I would understand like https://bpaste.net/show/af60421008a3
07:13:07 <cocreature> right but new GHC versions are released fairly rarely
07:13:16 <cocreature> and passing -w or changing the path is pretty teasy
07:13:56 <merijn> I mean "changing ghc version" for me is just: PATH="$HOME/ghc82/bin/:$PATH" to switch to ghc 8.2
07:13:57 <cocreature> bwe: take a look at the types. you are making an instance for "Either e" so the "f" in the signature of fmap is "Either e"
07:14:06 <mniip> bwe, look again
07:14:09 <mniip> :t fmap
07:14:10 <cocreature> so (a -> b) -> f a -> f b becomes a -> b -> Either e a -> Either e b
07:14:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:14:17 <merijn> fendor: Which honestly is so little effort I don't care
07:14:18 <[exa]> bwe: that would be right, except the functor needs to work on (Either e)
07:14:20 <mniip> you need to substitute 'Either e' in place of f
07:14:38 <fendor> cocreature, fair enough that sounds easy.
07:15:16 <merijn> fendor: GHC (smartly!) encodes the GHC version into the path to the package database, so multiple GHC installs never conflict (unless you install the exact same GHC version multiple times, but why would you do that?)
07:15:30 <merijn> fendor: So no need to mess with virtualenvs and that sorta nonsense
07:15:56 <fendor> merijn, wait people have been using virtualenv for ghc installations? 0.o
07:16:14 <merijn> fendor: No, but people coming from JS/python/ruby seem to assume you have to
07:17:09 <fendor> merijn, well you need at least some kind of sandboxing... but i dislike virtualenv :D
07:17:36 <jiyaomu> Doesn’t stack play a bit the role of a virtual environment? (#beginner)
07:19:38 <geekosaur> it does. it's not required either
07:19:41 <jiyaomu> I mean of virtualenv
07:19:56 <bwe> cocreature: That gives me a clear understanding, finally: https://bpaste.net/show/75533a340b39
07:20:11 <maerwald> stack is terrible, unlike cabal, there is almost no way to recover from stack problems. you just rm rf your stack directories
07:20:17 <maerwald> it's Windows philosophy
07:21:09 <jiyaomu> Yeah but it should give you a better control over your software dependencies, as with Python virtualenv, isn’t it?
07:22:02 <cocreature> the difference is that stack (and cabal new-build) takes care of sandboxing things for you whereas with virtualenv it’s up to you to remember to enter the appropriate virtualenv and whatnot
07:22:05 <[exa]> maerwald: +1
07:22:11 <jiyaomu> maerwald: good to know, as I am starting to learn Haskell it seems like stack was the go to tool nowadays, but I have been running into a few problems with it....
07:22:50 <maerwald> I am forced to use stack, because of the project I'm working on. the more I use it, the more I hate it
07:22:56 <power-fungus> "stack is terrible" is not a true statement AS-IS. Both have their own benefits and shortcomings
07:23:40 <agentultra> i haven't used anything but stack since I started haskell development. I don't know what's terrible about it. works pretty well.
07:23:45 <agentultra> for me
07:24:36 <bwe> what do you think of https://bpaste.net/show/3db8db400f2b ?
07:25:24 <cocreature> bwe: have you tried compiling that? because that is definitely not going to work :)
07:25:24 <[exa]> bwe: it has some logic going, except you can't patternmatch a type constructor
07:25:38 <[exa]> bwe: you can patternmatch Left and Right, not Either
07:27:07 <bwe> cocreature: I've tried but was not sure whether that collides with builtin Either.
07:28:08 <[exa]> bwe: why not make your own Either' ?
07:28:14 <jiyaomu> Well not sure if it is really stack giving me issues in my case but to use Haskelly for Vs code I need to install stack-run and I am running in some dependencies issues
07:29:08 <fendor> jiyaomu, by the way you should proabbaly give the haskell-ide-engine a try, it is really great!
07:30:11 <jiyaomu> fendor: thanks! I will give it a go :)
07:31:11 <maerwald> hie also fails on big projects
07:31:36 <fendor> maerwald, true, but it improves quickly
07:31:45 <maerwald> the only thing that works reliably is ctags via codex/hasktags
07:31:50 <maerwald> and maybe hscope
07:32:11 <fendor> and it is by far the closest we have ever been to an ide
07:32:19 <maerwald> everything else takes minutes and kills your ram
07:32:28 <bwe> [exa]: I wonder why the type signature is wrong now... https://repl.it/repls/AngryBonyBackticks
07:32:37 * hackage language-docker 6.0.4 - Dockerfile parser, pretty-printer and embedded DSL  http://hackage.haskell.org/package/language-docker-6.0.4 (lorenzo)
07:32:38 <maerwald> for small projects hie works
07:32:38 <fendor> yeah currently you need like 16 GB of RAM for haskell development :D
07:32:59 <fendor> maerwald, how small are small projects in your opinion?
07:33:19 <maerwald> less than 600 modules
07:33:50 <maerwald> after that, you are f*cked
07:34:10 <fendor> 600 modules in one project? or including dependencies?
07:34:19 <maerwald> one project
07:34:41 <fendor> wouldnt it be possible to split that up in mutliple projects?
07:34:48 <fendor> or does this not the problem?
07:34:52 <fendor> *solve
07:34:55 <maerwald> maybe, but even 300 is terrible
07:37:21 <fendor> maerwald, how big is the team that manages over 600 modules in one project?
07:38:15 <maerwald> about 6 people
07:38:43 <maerwald> we tried intero, hie, ghc-mod, everything
07:38:48 <jiyaomu> maerwald: thanks for the warning. As I am just starting to learn I predict that most of my project for the next couple of months will stay small enough to be handled by hie :)
07:39:21 <maerwald> still think hie is the least terrible
07:39:45 <power-fungus> maerwald: base has 215 modules in one package. Why would you ever need >250 in one package?
07:39:58 <agentultra> i use intero which has been great so far. it's a little slow on completions but not too bad.
07:40:28 <maerwald> power-fungus: because you write an actual application?
07:40:30 <agentultra> would be nice to not have to restart it when module exports change but it's good enough
07:40:45 <fendor> agentultra, intero is pretty nice, used it for several months, too. However, hie is an umbreall project that reuses exisitng technologies, including intero :)
07:41:01 <agentultra> fendor: oh cool. i will have to give it a go. :)
07:41:14 <cocreature> fendor: no, it doesn’t reuse intero
07:41:25 <maerwald> intero chokes once it tries to load type info
07:41:30 <fendor> yeah, fake news, sorry
07:41:43 <fendor> just looked it up myself
07:41:49 <fendor> sorry :(
07:42:44 <fendor> agentultra, so that fake news, not using intero, but it is still cool!
07:43:00 <agentultra> aw. no worries.
07:43:19 <agentultra> my experience with tooling outside of stack+intero is limited
07:43:37 <agentultra> would be good to see what else is out there. haskell is always full of surprises. :)
07:44:43 <maerwald> just use codex and ghci
07:45:06 <agentultra> I'm a severe emacs addict so intero has been pretty good so far. :)
07:45:14 <maerwald> that covers most functionality, except auto completion
07:45:17 <fendor> maerwald, does ghcid not work for you, too?
07:45:22 <maerwald> no
07:45:25 <maerwald> it's broken
07:45:34 <fendor> really?
07:45:43 <fendor> you mean that you cannot scroll through the errors?
07:45:59 <maerwald> https://github.com/ndmitchell/ghcid/issues/175
07:46:06 <maerwald> the parser is a joke
07:46:13 <maerwald> just broken
07:46:39 <maerwald> I can't even configure it
07:49:25 <fendor> maerwald, the issue you describe seems to be cause by having multiple executables? but this actually works fine for me...
07:49:39 <maerwald> not here
07:50:37 <fendor> maybe old version?
07:50:45 <fendor> or new version :D
07:51:39 <fendor> oh, you want to load the executable itself into ghcid?
07:52:02 <maerwald> check the parser code
07:52:07 <maerwald> it's nonsense
07:52:43 <maerwald> https://github.com/ndmitchell/cmdargs/blob/master/System/Console/CmdArgs/Explicit/SplitJoin.hs#L31
07:57:52 <bwe> here is my current state of learning to implement Functor type class: https://repl.it/repls/AngryBonyBackticks -- no, it does not compile; ghc complains about line 15
07:57:55 <fendor> maerwald, looks kind of weird...
07:58:38 <fendor> bwe instance declarations seem to be wrong
07:58:40 <asheshambasta> https://gist.github.com/asheshambasta/9ca5429fdd7dbfb5a631e38e6468c134 <- is this a Haskell 'Wat'?
07:58:43 <maerwald> it tries to be compatible with windows I think, which might be the reason for the naive implementation
08:01:04 <Ariakenom> asheshambasta: it's ghci  that has some different ruels for types
08:01:16 <Ariakenom> hm
08:01:18 <Ariakenom> > ("abc" ++ "cde") :: Text
08:01:21 <lambdabot>  error:
08:01:21 <lambdabot>      Not in scope: type constructor or class ‘Text’
08:01:30 <bwe> I forgot `Functor` type class itself: https://repl.it/repls/AngryBonyBackticks
08:01:31 <Tuplanolla> Try concatenating with `<>`, asheshambasta.
08:01:50 <Ariakenom> oh yeah right. It's ++ my bad
08:02:10 <Ariakenom> :t (++)
08:02:11 <lambdabot> [a] -> [a] -> [a]
08:02:26 <asheshambasta> Tuplanolla: that doesn't really seem to help
08:03:11 <Ariakenom> > ("abc" <> "cde") :: Data.Text
08:03:12 <asheshambasta> > import Data.Semigroup ((<>))
08:03:14 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
08:03:14 <lambdabot>  error:
08:03:14 <lambdabot>      Not in scope: type constructor or class ‘Data.Text’
08:03:14 <lambdabot>      No module named ‘Data’ is imported.
08:04:13 <fendor> @import Data.Text
08:04:14 <lambdabot> Unknown command, try @list
08:04:17 <fendor> @list
08:04:17 <lambdabot> What module?  Try @listmodules for some ideas.
08:04:46 <[exa]> bwe: on line 9, what is the type the MyLeft holds?
08:05:40 <bwe> [exa]: e
08:05:56 <[exa]> and what is the type of the 'g' function?
08:06:03 <bwe> (a -> b)
08:06:14 <[exa]> so what is the type of (g v) when 'v' comes from MyLeft?
08:06:36 <bwe> v remains v
08:06:59 <[exa]> you still have (g v) there right?
08:07:19 <bwe> updated: https://repl.it/repls/AngryBonyBackticks
08:07:21 <[exa]> nicer
08:07:26 <[exa]> and now about l.15
08:07:33 <[exa]> you can't patternmatch a function
08:07:48 <bwe> oh, good to learn.
08:07:49 <[exa]> you just need to take it as one big parameter f
08:08:04 <asheshambasta> Tuplanolla: any kind of concatination causes OverloadedStrings to 'no longer work' in my case.
08:08:07 * hackage primitive-extras 0.2 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.2 (NikitaVolkov)
08:08:26 <[exa]> and give it parameters (anyway, "giving parameters" a.k.a. "calling" is the the only thing that you can do with functions; no other introspection)
08:09:54 <[exa]> bwe: anyway, for the implementation; your fmap type is (a->b) -> ((->) e a) -> ((->) e b) which we can rewrite to infix: (a -> b) -> (e -> a) -> (e -> b)
08:10:00 <[exa]> bwe: which could remind you something
08:10:55 <Tuplanolla> :t "Does lambdabot have `OverloadedStrings` on?"
08:10:56 <lambdabot> [Char]
08:11:10 <Tuplanolla> % :t "Does yahb have `OverloadedStrings` on?"
08:11:11 <yahb> Tuplanolla: [Char]
08:11:23 <Tuplanolla> % :seti -XOverloadedStrings
08:11:24 <yahb> Tuplanolla:
08:11:51 <Tuplanolla> % ("abc" <> "def") :: Text
08:11:51 <yahb> Tuplanolla: ; <interactive>:9:21: error: Not in scope: type constructor or class `Text'
08:12:13 <Tuplanolla> % import Data.Semigroup ((<>)); import Data.Text (Text)
08:12:13 <yahb> Tuplanolla: error: expecting a single import declaration
08:12:20 <Tuplanolla> % import Data.Text (Text)
08:12:20 <yahb> Tuplanolla:
08:12:27 <Tuplanolla> % ("abc" <> "def") :: Text
08:12:28 <yahb> Tuplanolla: "abcdef"
08:12:42 <[exa]> bwe: looking at your progress, again: you can't patternmatch function, the second parameter is just 'f'
08:12:48 <Tuplanolla> It works fine as demonstrated, asheshambasta.
08:13:07 * hackage herms 1.9.0.3 - A command-line manager for delicious kitchen recipes  http://hackage.haskell.org/package/herms-1.9.0.3 (JackKiefer)
08:13:42 <bwe> [exa]: then, how do I get its args?
08:13:45 <[exa]> bwe: reading the type --- you get a function (a->b) and a function (e->a), and you need to produce a function of type (e->b)
08:14:01 <[exa]> q: how do you _produce_ a function?
08:14:36 <[exa]> s/produce/create or make or code or so
08:16:23 <bwe> f :: Num a => a -> a; f v = v * 3 -- would be a function to me.
08:16:26 <asheshambasta> Tuplanolla: ah I'm a fool. I didn't have Data.Text (Text) imported in my module
08:16:47 <[exa]> bwe: ok and without having the definition syntax of = at hand?
08:16:53 <mniip> bwe, can you write that without naming it 'f'?
08:17:10 <confuzed> New to Haskell and FP, what’s a good http client lib that’s actively maintained? Also need to parse JSON and toml
08:17:24 <[exa]> confuzed: aeson is a good json parser
08:17:43 <maerwald> Wai?
08:17:52 <[exa]> confuzed: and http-conduit is pretty good for http
08:18:37 <confuzed> What do you guys recommend, should I try to use stack or just regular cabal? Should I be using nix?
08:18:48 <confuzed> For installing packages
08:19:08 <[exa]> confuzed: if you're on a reasonable system, cabal is perfectly sufficient
08:19:09 <bwe> mniip: Giving up ;).
08:19:15 <[exa]> bwe: lambdas?
08:19:31 <bwe> Ah, had that on mind but rejected it.
08:19:33 <asheshambasta> Tuplanolla: actually, this is quite interesting, that was not the issue
08:19:44 <bwe> (\x -> x * 30)
08:20:18 <[exa]> bwe: by opening a lambda in the definition, you instantly return something of type (x -> _)
08:20:20 <asheshambasta> I'm this as: someFunc $ "abc" <> "cde" where someFunc expects Text and not [Char]; and this doesn't compile.
08:20:34 <[exa]> bwe: _ depends on what you put in the lambda, and `x` is the type of the abstracted variable
08:21:05 <mniip> asheshambasta, with what type error
08:21:08 <[exa]> bwe: so in your case, the argument of the lambda you return will have type 'e', right?
08:21:28 <Gurkenglas> Compose maps "foldMap" to "foldMap . foldMap" modulo coerce. Can we generalize this beyond foldMap?
08:21:34 <Gurkenglas> The obvious approach tries:
08:21:38 <Gurkenglas> :t \f g (Compose x) -> Compose $ (f . f) g x
08:21:39 <lambdabot> forall k2 k3 k4 k5 (f1 :: k3 -> *) (g1 :: k2 -> k3) (a1 :: k2) (f2 :: k4 -> *) (g2 :: k5 -> k4) (a2 :: k5). ((f1 (g1 a1) -> f2 (g2 a2)) -> f1 (g1 a1) -> f2 (g2 a2)) -> (f1 (g1 a1) -> f2 (g2 a2)) ->
08:21:40 <lambdabot> Compose f1 g1 a1 -> Compose f2 g2 a2
08:21:50 <Gurkenglas> But this falsely assumes that f has the same type at both places
08:22:00 <Gurkenglas> -falsely+regretfully
08:22:07 <mniip> Gurkenglas, fmap . fmap
08:22:10 <bwe> [exa]: I can't follow you there.
08:22:18 <mniip> Gurkenglas, liftAn . liftAn
08:22:19 <dreamer_> I love when I get a new error
08:22:36 <asheshambasta> mniip: https://gist.github.com/asheshambasta/ee258ca3881e0d4f01e22a1c7b6db167
08:22:41 <dreamer_> "GHC doesn't yet support impredicative polymorphism" This one is encouraging even
08:22:58 <[exa]> bwe: put simply. You have function `g` of type (a->b) -- you can use it to turn stuff typed 'a' to stuff typed 'b'; and you also have function `f` of type (e->a).
08:23:05 <mniip> dreamer_, it's unlikely it ever will
08:23:11 <mniip> it's not a smart thing to have in a language
08:23:15 <[exa]> bwe: now you need to construct a function that takes 'e' and returns 'b'
08:23:24 <asheshambasta> mniip: the function `debugH` here expects a Text
08:23:51 <[exa]> bwe: so you create a lambda that takes the 'e', gives it to the functions in correct order, and returns the resulting 'b'
08:23:52 <mniip> asheshambasta, you have certFile' :: FilePath
08:23:53 <bwe> f :: Num a => a -> a; f v = v * 3 -- is equivalent to   (\v -> v * 3)   equivalent to (->) \v (v * 3)    so the e would be the \v??
08:24:01 <mniip> the string literals are inferred as FilePath as well
08:24:17 <[exa]> bwe: the -> in lambda definition is NOT an operator!
08:24:47 <[exa]> bwe: the whole \ ... -> syntax is one operator, which you can't prefix, and the arrow there -> has nothing to do with (->)
08:24:51 <asheshambasta> mniip: I'm getting the same thing with concat'ing `show x` into a regular string as well.
08:24:57 <dreamer_> sad
08:25:00 <[exa]> bwe: it's just a syntactical coincidence that they look the same
08:25:08 <bwe> [exa]: Thanks for clarifying this misunderstanding ;).
08:25:14 <bwe> [exa]: Give me a sec.
08:25:29 <[exa]> the whole \x-> is usually written as (λx)
08:25:34 <mniip> dreamer_, impredicative polymorphism has no clear type inference algorithms and can be counterintuitive in general
08:25:36 <mniip> consider e.g
08:25:37 <SrPx> Is it possible already to have a function that returns different types based on the input? `foo :: (b :: Bool) -> (if b then Int else String)`
08:25:49 <mniip> dreamer_, ["hello", False]
08:25:57 <mniip> you'd think this is a type error
08:26:07 <SrPx> I know many dependently typed features are present already
08:26:07 <asheshambasta> mniip: also, adding an explicit `show` before the certFile' doesn't seem to cut it either
08:26:35 <mniip> hm, this might be a type error
08:27:09 <mniip> asheshambasta, what's the type of show
08:27:10 <[exa]> mniip: instance IsString Bool --yolo fixed
08:27:34 <mniip> actually I forget what's the problem with impredicativity was
08:28:04 <asheshambasta> mniip: the regular `show` no?
08:28:07 <Taneb> SrPx: no
08:28:27 <mniip> asheshambasta, still what's the type on that
08:28:32 <[exa]> bwe: anyway, the first thing to fix should be the arguments, it is a 2-argument function and just takes 'f' and 'g', nothing more complicated is possible when the arguments are functions
08:28:44 <mniip> I know the answer but do you
08:28:57 <bwe> [exa]: fmap g f = g . f ?
08:29:00 <asheshambasta> mniip: show :: Show a => a -> String
08:29:15 <mniip> asheshambasta, right, so then  "foo" <> show certFile'
08:29:16 <[exa]> bwe: yeah, you can even look at the definition of (.)
08:29:18 <mniip> :: String
08:29:22 <SrPx> Taneb: ty
08:29:35 <[exa]> bwe: which is exactly the fmap for functions, so people usually write just `fmap = (.)`
08:29:47 <bwe> [exa]: Yay!
08:30:22 <asheshambasta> mniip: I don't get it; isn't `show x` evaluating to a string whatever the type of x before concatenation?
08:30:23 <[exa]> bwe: anyway, the long form with the lambda and "manual" construction of the function would be: fmap f g = \x -> f (g x)
08:31:00 <[exa]> bwe: which you simplify a bit to: fmap f g x = f (g x), which is IIRC the official implementation of (.)
08:31:39 <mniip> asheshambasta, sure
08:32:13 <bwe> [exa]: Now, https://repl.it/repls/AngryBonyBackticks looks better.
08:32:23 <mniip> [exa], the official implementation of (.) is  f . g = \x -> f (g x)  due to how inlining works
08:32:24 <bwe> Not only, I actually understand it.
08:33:33 <[exa]> mniip: oh so. what's the reason btw? (I guess some arity heuristic?)
08:34:20 <cocreature> [exa]: yep, GHC only inlines function applications that are fully saturated
08:34:32 <cocreature> and “saturated” depends on how many arguments appear in the definition
08:34:33 <mniip> inlining only works when your function is applied as many times as there are arguments in the binder
08:34:45 <[exa]> bwe: anyway, there's a nice intuition for Functor ((->) p) --- you view the functions as containers for their results that are "opened" by applying the 'p' parameter
08:34:54 <mniip> f x = ...; vs f = \x -> ...
08:35:22 <[exa]> cocreature: I kindof hoped that inliner was able to surpass such stuff
08:35:52 <mniip> might be intentional
08:36:18 <[exa]> (I only read one paper on that though, the old one that concerns loopbreaking)
08:36:37 * hackage bench-graph 0.1.2 - Plot and compare benchmarks  http://hackage.haskell.org/package/bench-graph-0.1.2 (harendra)
08:37:16 <[exa]> is there a way to tell it about the arity that's already good enough for inlining?
08:37:42 <bwe> [exa]: Thanks for accompanying me on the journey.
08:37:47 <[exa]> bwe: np
08:37:49 <monochrom> Speaking of which, the other day I was surprised to find out that join for Pair has to be join (Pair (Pair a1 _) (Pair _ a4)) = Pair a1 a4.
08:38:38 <[exa]> bwe: guess you're going for applicatives and will eventually reimplement State, returning lambdas is quite useful there
08:39:02 <cocreature> [exa]: change your definition
08:39:28 <[exa]> cocreature: definition of State?
08:39:29 <cocreature> that’s why (.) is implemented as f . g = \x -> f (g x) (or at least that’s a possible explanation, I don’t know the actual reason)
08:39:31 <monochrom> This is because the Pair monad arises from the adjunction Diagonal-functor |- Product-functor, and the formula that gives join says that.
08:39:45 <cocreature> no the definition of the function for which you want to change the arity
08:40:05 <[exa]> cocreature: oh so. :D okay, thanks
08:40:12 <monochrom> err s/|-/-|/
08:40:52 <[exa]> cocreature: I hoped for something a bit more explicit but I guess a comment will do
08:59:07 * hackage ivory 0.1.0.8 - Safe embedded C programming.  http://hackage.haskell.org/package/ivory-0.1.0.8 (EricMertens)
09:18:29 <mniip> glguy, regarding my mail to goldfire
09:18:36 <mniip> he brought a batch of counterexamples
09:20:18 <glguy> Oh, fun
09:20:29 <glguy> example?
09:21:34 <mniip> data T a b c where C :: (b ~ c) => a -> T a b c
09:21:52 <mniip> type family F a b c where F a b b = a; F a b c = Int
09:22:04 <mniip> (\(C x) -> x) :: T a b c -> F a b c
09:22:15 <mniip> incomparable with  T a b c -> a
09:23:31 <mniip> I suppose what this is saying is that b must not be determined by a,c
09:23:36 <mniip> ditto c by a,b
09:35:07 * hackage parallel 3.2.2.0 - Parallel programming library  http://hackage.haskell.org/package/parallel-3.2.2.0 (SimonMarlow)
09:50:27 <mniip> glguy, hmmm
09:51:14 <mniip> data T a b where (A a b ~ B a b) => a -> T a b
09:51:38 <mniip> type family F p q a where F p p a = a; F p q a = _
09:52:01 <mniip> (\(C x) -> x)) :: T a b -> F (A a b) (B a b) a
09:52:24 <mniip> which is only comparable with 'T a b -> a' if the second axiom branch is unreachable
09:52:44 <mniip> i.e A a b ~ B a b is a trivial equalit
10:14:26 <_d0t> ohai! Where can I read about the difference between (\x y -> ...) and (\x -> \y -> ...) notation?
10:14:38 <_d0t> I know how it works, I just want a page where it is formally explained.
10:16:00 <_d0t> I even remembed seeing it somewhere. I just can't recall where exactly.
10:16:04 <_d0t> *remember
10:18:57 <dstolfa> _d0t: i mean, there's no real difference due to currying tbh
10:19:08 <dstolfa> at least not semantically (not sure if ghc does something with it, but i suspect not?)
10:19:30 <_d0t> Yes there is.
10:19:34 <_d0t> Check this out.
10:19:42 <dstolfa> _d0t: mathematically there really isn't
10:19:44 <_d0t> >(\True -> \y -> 1) undefined `seq` 2
10:19:48 <_d0t> ugh...
10:19:53 <_d0t> How do I evaluate something?
10:19:54 <dstolfa> _d0t: try : in front, lambdabot like sthat
10:20:03 <_d0t> : (\True -> \y -> 1) undefined `seq` 2
10:20:09 <dstolfa> hrm
10:20:14 <dstolfa> poop
10:20:20 <dstolfa> :t foldr
10:20:22 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
10:20:23 <dstolfa> okay
10:20:27 <dstolfa> :eval 2 + 2
10:20:28 <bwe> What does the (Int -> a) in    data ITree a = Leaf (Int -> a) | Node [ITree a]    mean?
10:20:31 <_d0t> > (\True -> \y -> 1) undefined `seq` 2
10:20:32 <dstolfa> hm
10:20:34 <lambdabot>  *Exception: Prelude.undefined
10:20:39 <dstolfa> ah okay here it goes
10:20:41 <_d0t> > (\True y -> 1) undefined `seq` 2
10:20:44 <lambdabot>  2
10:20:45 <_d0t> see?
10:21:05 <_d0t> The former forces pattern matching, while the latter doesn't.
10:21:31 <c_wraith> _d0t, > followed by space
10:21:43 <_d0t> c_wraith, thx, already figured that out
10:21:47 <dstolfa> ... right. some ghc dev please explain ^
10:21:57 <dstolfa> what the hell are those semantics
10:22:35 <_d0t> I remember reading something about 'foo = \x -> ...' being impossible to inline while 'foo x = ...' not having this issue.
10:22:47 <_d0t> Can't recall where exactly that was.
10:23:03 <dstolfa> _d0t: this looks like it's due to some optimisation tbh
10:23:05 <dstolfa> but i can't say for sure
10:23:16 <dstolfa> in any case, surprising result if viewed from a mathematical standpoint
10:23:20 <_d0t> dstolfa, I don't think optimizations kick in in ghci.
10:23:35 <dstolfa> _d0t: well, it might be there to make some optimisation work (like inlining)
10:23:37 <c_wraith> bwe, it means that when you construct a value of type ITree a with the Leaf data constructor, the constructor expects an argument of type (Int ->a)
10:23:40 <cocreature> _d0t: GHC will only inline functions that are fully saturated and what that means depends on how many arguments you’ve used in the definition
10:23:45 <mniip> no
10:23:50 <mniip> I think the answer is
10:24:00 <mniip> \x -> case x of True -> \y -> 1
10:24:01 <mniip> versus
10:24:09 <mniip> \x -> \y -> case x of True -> 1
10:24:13 <c_wraith> bwe, that is, a function that takes an Int and returns a value of whatever type a is
10:24:20 <zincy_> Hey what does this compiler error mean? https://lpaste.net/7600413541916475392
10:24:22 <dstolfa> mniip: why is that semantic difference there?
10:24:27 <_d0t> mniip, neat
10:24:38 <_d0t> mniip, that even makes sense
10:24:39 <_d0t> thank you
10:24:39 <mniip> dstolfa, which semantic difference
10:24:40 <glguy> I wouldn't rely too much on what lambdabot does with these cases. GHC's optimizer likely behaves differently
10:24:53 <glguy> and which flags you're running GHC with
10:24:59 <dstolfa> mniip: why is \x y -> ... not the same as \x -> \y -> ...
10:25:07 <mniip> dstolfa, it is
10:25:13 <mniip> but
10:25:23 <mniip> \Pattern -> \Pattern ->... isn't
10:25:46 <dstolfa> oh, right.
10:25:48 <dstolfa> okay
10:26:07 <glguy> options like -ffull-laziness and -fpedantic-bottoms, and others will influence the meanings of these kinds of examples
10:26:10 <dstolfa> i retract my statement w.r.t. surprising result
10:26:27 <c_wraith> bwe, that is you can use the expression "Leaf (+1)" to create an ITree Int, or "Leaf show" to create an ITree String
10:27:13 <_d0t> mniip, yup, i tried rewriting that with explicit case
10:27:16 <_d0t> it works the same
10:27:24 <mniip> % (\(trace "hi" -> ()) -> \y -> ()) () `seq` ()
10:27:24 <yahb> mniip: hi; ()
10:27:30 <mniip> % (\(trace "hi" -> ()) y -> ()) () `seq` ()
10:27:30 <yahb> mniip: ()
10:27:53 <dstolfa> oh, yahb is in here too
10:32:21 <bwe> c_wraith: yet I don't understand the type definition: Leaf :: (Int -> a) -> ITree a -- I agree it takes something that takes an Int returning something of type a. But how does it happen that it returns an ITree a?
10:32:34 <glguy> zincy_: You tried to use a value with type 'Doc (Doc Void)', but one with type 'Doc a' was expected. You don't get to make any assumptions about what type 'a' is (like assuming that it is Doc Void)
10:32:55 <glguy> ohh, 'ann', rather than 'a'
10:34:11 <glguy> zincy_: If you had a value with type  Doc Void, and Doc was an instance of Function (which it likely is) then you could use 'fmap absurd :: Doc Void -> Doc a' to convert it. In this case, however, you have 'Doc (Doc Void)' which is probably just a mistake in the program
10:37:52 <zincy_> glguy: When I remove return
10:38:12 <zincy_> I then get a Doc Void when a Doc ann is needed? How would I transform the value?
10:43:27 <iqubic> :t fmap absurd
10:43:28 <lambdabot> Functor f => f Void -> f b
10:45:20 <yasar> https://lpaste.net/5607301695823413248
10:45:33 <yasar> I want to show double as integer if decimal part is zero
10:46:07 <yasar> code gives me error
10:47:12 <cocreature> :t truncate
10:47:13 <lambdabot> (Integral b, RealFrac a) => a -> b
10:47:31 <cocreature> that will give you something that is an instance of Integral
10:47:39 <cocreature> but == expects two things of the same type
10:47:47 <cocreature> and Double is not an instance of Integral
10:48:16 <c_wraith> bwe, that's just what standard data constructor syntax means. you list the name of the constructor and the type of the arguments to it, but you never specify the type of the value the constructor creates. that's just inferred.
10:49:30 <c_wraith> bwe, the GADT syntax actually does require you to specify the *full* type of the constructors, looking like their real function types.
10:50:25 <c_wraith> bwe, the standard syntax is shorter and works well for simple cases, but the GADT syntax can be much clearer if things are complex.
10:51:06 <yasar> cocreature, what would be the correct way to do it?
10:52:14 <yasar> if I knew a way to get only the decimal parts, I could compare it to 0.0
10:52:17 <cocreature> yasar: one option would be to convert back to Double using fromIntegral
10:52:20 <yasar> but I don't know a way
10:52:40 <c_wraith> isn't there a function that does that?
10:52:52 <yasar> cocreature, :) that sounds much simpler
10:53:08 <cocreature> > properFraction 1.42
10:53:11 <lambdabot>  (1,0.41999999999999993)
10:53:14 <cocreature> that might also be useful
10:54:01 <c_wraith> that's the one I was thinking of
10:54:15 <c_wraith> :t properFraction
10:54:16 <lambdabot> (Integral b, RealFrac a) => a -> (b, a)
10:54:20 <yasar> gotta love rounding
10:55:29 <yasar> this is my 3rd attempt to learn haskell
10:55:36 <yasar> I hope I will get it this time
10:56:02 <c_wraith> fwiw, I think numerical algorithms are one of the most painful ways to learn haskell.
10:56:48 <yasar> My first attempts where to follow learn you a haskell for great good
10:57:12 <yasar> It got confusing around monad parts
10:57:14 <c_wraith> most other languages have automatic type coercions between numeric types that mostly do what you want for numeric algorithms.
10:57:20 <yasar> This time I am following real world haskell
10:57:35 <c_wraith> oh, rwh is not how I'd go.
10:58:06 <yasar> it seems like a more practical option
10:58:06 <c_wraith> it was never a great book at the beginner level because it assumed a lot of knowledge already
10:58:19 <c_wraith> and it's really out of date now.
10:59:12 <c_wraith> a lot of its material refers to libraries that were updated (or moved away from) to get rid of problems rwh talks about.
10:59:35 <yasar> c_wraith, what would you suggest?
10:59:41 <c_wraith> the profiling chapter is still fantastic though. the book is worth it for that chapter alone
11:00:17 <butterthebuddha> For a recursive function with TCO, are computations in a where block that don't depend on the function arguments preserved across calls?
11:00:57 <c_wraith> butterthebuddha, if the optimizer floats the definition. that depends on how it feels.
11:01:33 <butterthebuddha> c_wraith: any way besides just passing in the values via the arguments to "force optimize" it?
11:01:50 <cocreature> most of the time GHC is quite keen on floating things out if you compile with -O2 (in particular with -ffull-laziness)
11:02:06 <c_wraith> yasar, not sure I have a recommendation, sadly. I hear a lot of good things about haskellbook.com but I haven't verified them. it's also not available for free.
11:02:41 <ZeuPiark> hello
11:03:00 <cocreature> yasar: a lot of people also seem to like the cis 194 course which has the advantage of being freely avaible https://www.seas.upenn.edu/%7Ecis194/spring13/lectures.html
11:03:01 <gentauro> I'm trying to map my "hand made" build script (that works) to stack (that doesn't). Can anybody see what's wrong? (bash) https://lpaste.net/5999241122558246912 and (stack) https://lpaste.net/8903701606743146496
11:03:05 <cocreature> but I’ve also not tried it myself
11:03:47 <butterthebuddha> yasar: I recommend doing the homework from CIS 194 (Spring 13)
11:03:49 <gentauro> I think stack doesn't know how to "eat" several "trust pkg" in ghc-options :(
11:04:28 <yasar> cis 194 seem nice, I guess it is for CS curriculum?
11:04:33 <c_wraith> gentauro, is that compiling student submissions?
11:04:54 <c_wraith> yasar, yeah it was a course Brent Yorgey taught.
11:04:58 <butterthebuddha> yasar: It's a half-credit class at UPenn, I think
11:05:18 <cocreature> gentauro: step 1. look at the cabal file to see if that is properly generated. step 2. compile with --verbose or whatever the stack option is called and check which options are actually being passed. step 3. tell us the actual error because “doesn’t work” is not a useful error for anyone trying to help you
11:05:23 <yasar> Homeworks aren't very trivial, which is good
11:05:32 <yasar> I will give it a go
11:05:35 <butterthebuddha> I recommend following that up with Data61's fp-course
11:06:26 <butterthebuddha> Plenty of code to write that will get you very well acquainted with Applicatives and Monads
11:07:20 <gentauro> cocreature: the error is -> "target ‘base’ is not a module name or a source file"
11:07:26 <gentauro> which doesn't really give sense
11:07:30 <gentauro> but I will try step 1 and 2
11:08:14 <c_wraith> gentauro, that makes it sound like it's messing up passing arguments to ghc.
11:09:01 <c_wraith> gentauro, definitely make sure the ghc options look right in the cabal file.
11:12:21 <gentauro> cocreature: and c_wraith I can confirm that flags are set correctly in .cabal
11:12:34 <gentauro> "ghc-options: -Wall -Werror -XSafe -fpackage-trust -trust base -trust bytestring"
11:12:38 <yasar> butterthebuddha, do you have a link for that?
11:12:56 <butterthebuddha> yasar: https://github.com/data61/fp-course
11:14:46 <cocreature> gentauro: I wonder if it’s the space that’s causing problems. maybe try -trust=base instead?
11:15:36 <gentauro> cocreature: D:
11:15:42 <gentauro> that actually worked :o
11:16:36 <gentauro> and I can see that .cabal now also have -trust=base -trust=bytestring
11:16:42 <gentauro> so that is how it works :)
11:17:23 <gentauro> I like how much docs are made -> https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/safe_haskell.html#package-trust but couldn't a "simple" example be written for each case?
11:17:27 <gentauro> just wondering :)
11:18:29 <cocreature> I doubt a PR that adds an example would be rejected :)
11:19:13 <c_wraith> fwiw, I think the problem was something assuming it could reorder arguments however it wanted, not realizing that -trust takes an argument.
11:19:42 <cocreature> I’d still be interested in seeing what arguments are actually being passed to ghc
11:19:50 <c_wraith> to some extent, I blame ghc for not having arguments that are easier to parse. :)
11:21:11 <yasar> I thought ghci wouldn't accept y = y + 1, but it did
11:21:24 <yasar> I don't know what it is supposed to do
11:21:36 <humanoyd> Do the changes needed for SMP (https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid#Writingcompatiblecode) require a PVP minor version change?
11:21:58 <fishythefish> yasar: that makes y a bottom value
11:22:04 <fishythefish> > let y = y + 1 in y
11:22:08 <lambdabot>  *Exception: <<loop>>
11:22:11 <cocreature> at least for most instances of Num :)
11:22:22 <fishythefish> well, assuming the usual defaults :P
11:22:38 <c_wraith> > let ones = 1 : ones in ones -- yasar it sometimes is helpful to be able to refer to yourself in non-function bindings
11:22:41 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:23:29 <gentauro> cocreature: sadly, I'm out of GitHub :(
11:23:36 <gentauro> so I can contribute to anything ...
11:23:40 <fishythefish> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- the classic
11:23:43 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:23:51 <gentauro> why did M$ had to buy GH :'(
11:24:16 <yasar> so, it is like infinite thing generator?
11:24:32 <c_wraith> gentauro, you realize Microsoft provided a *lot* of funding for the development ghc over the last 20 years?
11:24:33 <cocreature> gentauro: that’s not an excuse! you can submit patches using the phabricator instance hosted by GHC HQ itself
11:24:58 <cocreature> in fact that’s even preferred/required for everything but small doc patches
11:30:26 <gentauro> c_wraith: MS Research = cool, M$ = not so much :P
11:31:04 <gentauro> cocreature: I like that idea, do you have a link so I can read how to do it?
11:32:07 <gentauro> (I actually realize how errorneous it is to bind to a specific host. Stack doesn't allow me to point my sites to gitlab = build error. The elm community lost all my elm-pkgs when my account was deleted)
11:32:11 <cocreature> https://ghc.haskell.org/trac/ghc/wiki/Phabricator might be a good start
11:34:48 <gentauro> cocreature: -> https://phabricator.haskell.org/macro/
11:34:48 <gentauro> :D
11:35:58 <gentauro> cocreature: I'm guessing it's a bit overkill for adding a documentation snippet. Have you seen how the peps from GitLab does it? I wish more communities were like that :)
11:36:55 <cocreature> now you’re just trying to find excuses to not contribute :P
11:37:00 <gentauro> I will at least write a code snippet on my blog with searchable names so others don't have to waste a couple of hours on trial / error :)
11:37:37 * hackage hackage-whatsnew 0.1.1 - Check for differences between working directory and hackage  http://hackage.haskell.org/package/hackage-whatsnew-0.1.1 (JeremyShaw)
11:38:16 * hackage serverless-haskell 0.7.0 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.7.0 (AlexeyKotlyarov)
11:57:42 <yasar> https://lpaste.net/1537721892536844288
11:57:50 <yasar> I can't work out the types
11:58:30 <cocreature> in core, is there a difference between a let that binds a value of type Int# and a case? normally, I would expect the let to create a thunk but not for a value of type Int#
11:58:33 <monochrom> What is there to work out?  Which part got you stuck?
11:59:20 <yasar> ghci complains "Couldn't match expected type `Integer'"
11:59:24 <yasar> in otherwise case
11:59:28 <monochrom> cocreature: You actually saw a "let" that binds an Int#?
11:59:29 <yasar> underlining toInteger
11:59:52 <monochrom> OK do you accept that "f g x" means "(f g) x" not "f (g x)"?
12:00:24 <yasar> so, I should apply from left to right?
12:00:29 <cocreature> monochrom: yep, https://gist.github.com/cocreature/5d16e283674dcadc1d67567838333f18#file-main-dump-simpl-L51
12:01:04 <monochrom> I don't know what does "apply from left to right" mean.
12:01:36 <shapr> Is async one of those packages that comes with the ghc install?
12:01:39 <monochrom> cocreature: I would take a look at opt-cmm too to see what it translates to.
12:02:01 <[exa]> are there any good GUI toolkits for haskell?
12:02:05 <monochrom> No, async doesn't come with GHC. Go with Haskell Platform >:)
12:02:06 <yasar> Group function applications from left to right, my English might be a little rusty
12:02:17 <monochrom> Yes.
12:02:18 <shapr> [exa]: hsfltk has good reviews
12:02:19 <cocreature> monochrom: I’m more interested in the general case rather than what this specific example compiles to. i.e., is there ever a difference between a let of an unboxed type and a corresponding case
12:02:23 <[exa]> I'd like to make an app that visualises something in 3D (using opengl probably) and I need some clickety stuff around
12:02:41 <[exa]> hmm fltk was interesting last time I looked
12:02:46 <[exa]> shapr: thanks
12:03:22 <monochrom> cocreature: I would, with a grain of salt, make a couple of observations from a couple of specific examples, and extrapolate. :)
12:03:29 <cocreature> it does look like it’s a "case" in stg
12:03:46 <monochrom> Basically that's how I learned to read core and cmm.
12:03:53 <cocreature> heh, fair enough :)
12:04:01 <shapr> [exa]: tell me how it goes, I decided to stick with websites long ago, might try a native app if it's easy and fun.
12:04:39 <agentultra> webgl is pretty well supported these days
12:05:21 <revskill> How to minify Miso built ? Mine with a few models go up to near 1 MB !
12:05:34 <yasar> Can I make this function shorter/better? https://lpaste.net/835646309036720128
12:06:42 <monochrom> You need to learn that "div" exists.
12:07:12 <butterthebuddha> Is there an extension like OverloadedStrings that lets me use char syntax for Words?
12:07:30 <monochrom> No.
12:07:50 <monochrom> But you can write your own Num instance for Char. >:)
12:08:22 <yasar> monochrom, :) Thanks for that
12:10:28 <Ariakenom_> > 123 `mod` 10 -- you can use backticks to write functions infix yasar
12:10:30 <lambdabot>  3
12:11:06 <Ariakenom_> Although I usually prefer mod 123 10 tbh
12:11:32 <Ariakenom_> or (%) = mod; (//) = div
12:12:08 <cocreature> ok so let for unlifted types are only allowed if GHC can prove that the expression is “ok to speculate” which means that evaluating it is always ok (i.e., no exceptions, non-termination, …)
12:13:11 <cocreature> if that’s not the case, you have to use a "case". not yet sure what you gain by using let if you are allowed to
12:14:55 <bwe> c_wraith: How is the returned type of `ITree a` inferred in the type constructor `data ITree a = Leaf (Int -> a)` ?
12:15:03 <pikajude> lol, i defined an AsChar class and declared IsChar Char and Integral a => IsChar a
12:15:09 <pikajude> and now GHC is telling me those are overlapping
12:15:12 <pikajude> they most certainly are not
12:15:45 <bwe> c_wraith: Oh, Leaf (Int -> a) is the value. So its type is on the left side, per definition ;). Gotcha!
12:16:02 <c_wraith> bwe, exactly! :)
12:16:18 <lyxia> pikajude: overlap doesn't depend on the context (Integral a =>)
12:16:21 <geekosaur> pikajude, tjhey are
12:16:25 <monochrom> They do. "IsChar a" overlaps with "IsChar Char" for example. Oh you made sure you wrote "Integral a =>"? But it does not matter.
12:16:43 <geekosaur> the context is a postcondition, not part of the match
12:17:00 <pikajude> oh ok
12:17:33 <pikajude> well that's silly
12:18:00 <geekosaur> it's necessay for the type system to be consistent
12:18:23 <pikajude> silly of me, that is
12:18:34 <cocreature> monochrom: in case you’re interested: CorePrep seems to turn all unboxed lets into a case so at best it might make a slight difference for the optimizer whether it’s expressed as a let or a case but if it survives that, it will be turned into a case.
12:19:09 <monochrom> Yeah, I always -ddump-prep just in case. -ddump-simpl tells a few white lies.
12:19:58 <c_wraith> bwe, if you haven't seen it, you might like this extension: http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-GADTSyntax
12:20:14 <monochrom> But to be sure, simpl is so much easier to read than prep.  Because "let x = y+z*t" is still possible in simpl.  In prep it's the more tedious "let tmp1 = z*t in let x = y+tmp1"
12:20:52 <monochrom> But there will be times when you actually appreciate how prep breaks it down to pedantic pieces.
12:21:38 <bwe> c_wraith: I haven't. Thanks for the pointer.
12:21:56 <monochrom> I seldom read stg because prep gives similar information.
12:24:19 <bwe> c_wraith: Would you mind sharing your feedback with me on the Functor type class implementation for ITree, cf. line 46? https://repl.it/repls/AngryBonyBackticks
12:24:30 <bwe> c_wraith: It's just a working draft ;).
12:26:51 <c_wraith> bwe, was that link out of date? that Functor instance doesn't look like it should type check..
12:27:53 <bwe> c_wraith: I am trying to get a better understanding of the Leaf data constructor.
12:28:18 <c_wraith> bwe, oh, I misread "draft". known not working, got it.
12:28:26 <monochrom> Just being logical: Leaf (you need a function of type Int->b here)
12:28:56 <monochrom> And z::Int->a, f::a->b
12:29:04 <monochrom> err, s/f/g/
12:29:39 <monochrom> Sometimes it is valuable to play a "meaningless" logic game of types, and ditch "intuition".
12:30:10 <bwe> talking to some object in your room might help, too ;)
12:30:28 <bwe> z takes an Int to return an a
12:31:21 <bwe> I want a `b` and have a function `g` that takes an `a` turning it in a `b`. So,  fmap g (Leaf z) = Leaf (g z)  would be my proposal.
12:31:57 <c_wraith> closer, but still won't type check.
12:32:02 <bwe> z returns an `a` by which `g` is fed by, that in turn produces a `b` as required per definition.
12:32:18 <c_wraith> your explanation is correct, but not what your code says. :)
12:32:38 <monochrom> sin (cos 3) is not the same as sin cos.
12:32:45 <bwe> fmap g (Leaf z) = Leaf (g . z)
12:32:56 <monochrom> Yes.  sin . cos
12:34:25 <bwe> Feeling okay to accompany me with the data constructor   Node [ITree a]  ?  My proposal is    fmap g (Node [ITree a]) = Node [Itree (g a)]
12:34:53 <c_wraith> in words, what should fmap do with that constructor?
12:34:56 <monochrom> But there is no such thing as [ITree a]
12:35:34 <monochrom> And you expect recursion to appear anyway.
12:35:49 <bwe> ITree may be another Node or it may terminate into a Leaf
12:36:05 <bwe> The Leaf pattern is already covered, checked?
12:36:16 <c_wraith> you're mixing up type and value levels a bit.
12:36:22 <monochrom> Now you are micromanaging your own recursion.
12:36:26 <c_wraith> ITree is a type, not a value.
12:38:06 <bwe> data ITree a = Node [ITree a] -- the ITree on the left is a type constructor, right? The one on the right simply refers to the type constructor on the left. Is that true?
12:38:24 <c_wraith> I still recommend stepping back a moment and just describing what fmap should do with that constructor in English.
12:38:32 <monochrom> OK, look. Suppose "data MyList = Nil | Cons Int MyList".
12:38:44 <monochrom> you don't go write "f (Cons Int MyList) = ..." do you?
12:39:29 <bwe> c_wraith: fmap should turn any `a`s into `b`s retaining its "container" structure.
12:39:53 <bwe> monochrom: No, I pattern match only on data constructors.
12:39:53 <c_wraith> bwe, what does that mean in the context of that constructor?
12:41:28 <monochrom> And yet when you write "f (Node [ITree a]) = ..." you're doing the equivalent of "f (Cons Int MyList) = ...".
12:42:02 <bwe> [ITree a] -- if a list element is a Node, dig into that and apply fmap to the element if it is a Leaf.
12:43:14 <c_wraith> bwe, does that maybe sound like the sort of thing recursion can help with? :)
12:44:17 <rntz> is there a way in Haskell to print something for debugging even if you don't have a Show instance for it in scope?
12:44:29 <c_wraith> bwe, I mean, isn't fmap exactly the function to do that digging and replacing?
12:45:00 <bwe> c_wraith: fmap g (Node z) = fmap z -- would be too simple to be good ;).
12:45:26 <c_wraith> bwe, sure. it's more complex than that. but you can take ideas from that.
12:45:37 <bwe> I missed the g.
12:46:03 <monochrom> rntz: ghci has debugging features.  See your copy of GHC user's guide.  It may be able to print more information than Show instances.
12:46:13 <c_wraith> the left side is good. stick with that left side. :)
12:46:41 <c_wraith> bwe, but the right side will need a bit of massaging to work out.
12:46:47 <bwe> fmap g (Node z) = fmap g z -- has the g; fmap does not work on lists as per its type signature. So I need to make it work on lists.
12:46:56 <monochrom> You can say "but what about on the web" but then you need to watch out for version mismatch.  It is always safer to read the copy on your hard disk.
12:47:13 <c_wraith> > fmap (+1) [1..10]
12:47:15 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
12:47:17 <bwe> Why so? z is a list of [ITree a]
12:47:44 <monochrom> You can use "map" aka "[]'s fmap" when you run into a list so you don't have to roll your own.
12:48:40 <monochrom> You can roll your own, but it will be equivalent to using map.
12:49:08 <monochrom> Of course the best of both worlds is you roll your own for learning purpose and then erase it.
12:49:12 <bwe> Then I don't understand any more the type signature of   fmap :: (a -> b) -> ITree a -> ITree b -- oh wait, the container / list substitute is the ITree...
12:49:45 <c_wraith> bwe, it might help to think from the outside in. you know you need to create an ITree b with the same structure as the input
12:50:14 <c_wraith> bwe, to keep the structure, you'll have to use the same constructor, right?
12:50:49 <c_wraith> bwe, fmap g (Node z) = Node ... something using z
12:51:44 <bwe> c_wraith: fmap g (Node z) = Node (fmap g z) ?
12:51:58 <c_wraith> bwe, it turns out fmap is super mechanical. if you just keep following the "same structure" rule, you can get far.
12:52:17 <c_wraith> bwe, still more complex than that. the types don't work out right yet.
12:55:00 <bwe> I need to reconstruct the data structure    Node [ITree a]    -- I need something that creates a list of [ITree a]. No, a list of [ITree b]. One fmap for the list, another for the b.
12:55:08 <bwe> c_wraith: fmap g (Node z) = Node (fmap g . fmap g z) -- next iteration
12:55:51 <c_wraith> bwe, OK, you've got your English language description right. that's a good step. code still doesn't match it exactly.
12:56:22 <c_wraith> bwe, in this case, remember that the list does not contain values of type a
12:56:37 <c_wraith> bwe, so you can't fmap g over the list.
12:56:56 <c_wraith> bwe, the list contains ITree a values.
12:57:33 <c_wraith> bwe, so you have to (f)map the ITree a -> ITree b function.
12:58:01 <c_wraith> bwe, and you already have that function around. :)
12:58:11 <bwe> fmap g (Node z) = Node (fmap fmap . fmap g z) -- ?
12:58:31 <c_wraith> hmm. you're guessing too much now.
12:58:55 <c_wraith> what's the function for ITree a -> ITree b?
12:59:04 <bwe> g
12:59:21 <c_wraith> g is only a -> b
12:59:32 <bwe> so it's fmap
12:59:43 <c_wraith> more specific than that
12:59:56 <bwe> fmap g -- partial applied
13:00:07 <c_wraith> that's it.
13:00:27 <bwe> Something along the lines of   fmap g (Node z) = Node (fmap (fmap g) z)  ?
13:00:33 <c_wraith> now, what do you need to do with that function (in English)?
13:00:48 <bwe> Let's do it in English first.
13:01:35 <bwe> [ITree a] -> [ITree b] -- wanted
13:02:01 <bwe> ITree a -> ITree b -- fmap g
13:03:09 <c_wraith> correct so far, and I like how you're approaching it. keep going.
13:04:16 <Zemyla> What exactly is magicDict?
13:05:42 <bwe> List (ITree a) -> List (ITree b) -- let's change it a bit
13:05:58 <c_wraith> ok
13:06:11 <glguy> Zemyla: It's probably a placeholder for a value that the compiler is going to dynamically determine
13:06:34 <glguy> I'll ask Iavor about it when he gets back from lunch
13:06:54 <bwe> (fmap g) -- eats `ITree a` to produce `ITree b`.
13:08:15 <bwe> fmap (fmap g) z
13:08:56 <c_wraith> bwe, that's correct. (and you were right in your last guess above, I just wanted to let you think through it further)
13:09:07 <glguy> https://github.com/ghc/ghc/blob/master/compiler/basicTypes/MkId.hs#L1503-L1543
13:09:38 <bwe> c_wraith: Now I understand it better than in my guess before.
13:09:57 <bwe> The first fmap handles that List container.
13:10:02 <c_wraith> bwe, it looks like you're starting to get the hang of thinking in types. that's a big part of haskell. and why I wanted you to think it through. :)
13:10:05 <bwe> the second the ITree container.
13:10:39 <c_wraith> those are correct. but you don't need me to tell you that anymore, do you? :)
13:10:40 <bwe> Since they are nested, it's reflected in fmap nesting.
13:11:27 <bwe> ...just integrating the learned lesson.
13:11:36 <c_wraith> absolutely.
13:12:25 <Ariakenom_> :t \f -> fmap (fmap f)
13:12:26 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
13:13:12 <bwe> Matches nice to  (a -> b) -> List (ITree a) -> List (ITree b)
13:13:18 <c_wraith> as a small follow-up: fmap isn't just "mostly" mechanical. as long as you make sure you are preserving structure, it's completely mechanical. you can always figure it out just from preserving structure and making the types work.
13:13:58 <bwe> c_wraith: Would you mind elabourating on what you exactly mean with mechanical?
13:14:18 <c_wraith> bwe, there are no choices to make. there's a single correct implementation
13:14:40 <glguy> I seem to remember that it's unique as long as there aren't strict fields involved
13:15:24 <bwe> c_wraith: One more: "making the types work" would you define like ...?
13:16:02 <c_wraith> bwe, oh. I mean that the compiler doesn't report a type error.
13:16:51 <jit10> can't you just derve functors
13:16:52 <bwe> c_wraith: Interestingly I understood it differently: Let the types guide you step by step the way to the single correct implementation.
13:17:17 <c_wraith> bwe, it's the opposite direction of the same idea
13:17:26 <bwe> c_wraith: True ;)
13:17:40 <c_wraith> bwe, each of them implies the other, in Haskell's type system.
13:18:47 <c_wraith> jit10, yes, and that's really nice when writing production code. but it's less helpful when learning haskell and what fmap does in the first place. :)
13:18:51 <bwe> I still wonder how it has happened to become real. That so many interesting things fit together.
13:20:10 <Ariakenom_> math. how does it work
13:20:29 <c_wraith> bwe, it's honestly a mystery. there's no reason to believe that it should just work out nicely like that. but it does.
13:21:36 <c_wraith> bwe, https://www.dartmouth.edu/~matc/MathDrama/reading/Wigner.html gets into that idea from the philosophical side, a bit.
13:23:35 <c_wraith> bwe, there are discussions along the same lines from the computer science side - a common topic for them is the Curry-Howard isomorphism
13:23:48 <[exa]> mystery?
13:23:50 <c_wraith> bwe, but now we're far off into philosophy. :)
13:24:34 <bwe> c_wraith: Yet I coincided the Curry-Howard isomorphism yesterday. Yet to be understood.
13:25:14 <c_wraith> [exa], absolutely. there are unanswered questions about why the theories end up fitting together so nicely. it's not obvious that they have to.
13:26:23 <[exa]> well, there are crowds of logicians and mathematicians trying to push every theory to fit a nice, communicable picture; for more than 200 years now in formal logic and ~100 years in type systems
13:26:34 <[exa]> it would be shame if there wouldn't be some results already
13:26:51 <patlv> hi all, struggling with the fold_ function in the mysql-simple package, passing it: conn "SELECT here" the rest I'm not sure
13:27:48 <c_wraith> [exa], https://www.cs.cmu.edu/~rwh/papers/unreasonable/basl.pdf gets into what I mean a bit. sure, they've succeeded. it's awesome! but.. is it just a coincidence that it works so nicely?
13:28:39 <[exa]> no, logic was designed for that
13:29:00 <c_wraith> logic was created with that goal. why did it succeed?
13:29:38 <[exa]> I highly suggest reading the first papers from church, schonfinkel, or possibly some notes from babbage, they all have a great lot of intuition but the formal side was just forming
13:29:43 <glguy> patlv: 'query' is simpler, do you know how to use that?
13:29:58 <[exa]> and showing the formal side is sound and without flaws takes a lot of time
13:30:04 <bwe> c_wraith: What is the discrimination between math and Haskell / Functional Languages then (considering your first link focuses on math)?
13:30:32 <patlv> glguy: yes, I use the query, but in the doc they recommend using the fold_ when there's a lot of records
13:30:47 <[exa]> c_wraith: so I'm kindof happy that we finally see their vision going full speed forward :]
13:30:47 <c_wraith> bwe, functional languages are built on the lambda calculus, a mathematical model of computation.
13:30:55 <glguy> patlv: OK, fold_ is like using query and foldl together
13:31:13 <bwe> c_wraith: But there comes something on top of it, still, isn't it?
13:31:30 <geekosaur> bwe, programming languages tend to be used beyond the realm of well-behaved formalisms
13:31:31 <dstolfa> bwe: yes, of course. models of computation are just that, models.
13:31:38 <Berra> I need to write a function where I for every field of a record encode the name of that field and the show value for it's value into a list of tuples (queryString representation). I was wondering if I should/could try to use Data.Data to do this. Am I mistaken?
13:32:04 <patlv> glguy: do you know of any example showing how to use it, I could just found some trivial examples with Only
13:32:06 <[exa]> c_wraith: anyway, the story about "godel tries to disprove himself" is a good read on formalism acceptance rate :D
13:32:10 <bwe> c_wraith: Or would you say lambda calculus is the major source of the mystery (fitting all things perfectly together)?
13:32:37 <c_wraith> bwe, the pieces fit nicely together at higher levels, too.
13:33:03 <dstolfa> bwe: programming languages adopt some model of computation as a base and then build on top of it to achieve certain things. here's a simple example: how do you model interrupts in a turing machine? how do you do I/O in lambda calculus? what is I/O even? in monadic pi-calculus, how do you stop a partially deadlocked process?
13:33:04 <bwe> geekosaur: But interestingly, some implemented the logic (to make the pieces fit) while others not.
13:33:12 <geekosaur> Berra, or depending on how it's used, template haskell. or if it's a one-time thing, I'd consider a script :)
13:33:15 <dstolfa> bwe: the difference is the axioms
13:33:19 <dstolfa> bwe: some axioms are reasonable, others are not
13:33:31 <glguy> patlv: No, I haven't used this package or know any uses of it
13:33:33 <dstolfa> bwe: python, for example, axiomatises that everything is a unit type and all is well
13:33:34 * dyl is an unreasonable axiom himself.
13:33:48 <glguy> patlv: But foldl is a really common pattern
13:33:55 <dstolfa> you then end up with runtime exceptions
13:33:59 <c_wraith> bwe, all programming languages implement *some* logic.  it's just about what the logics allow.
13:34:09 <[exa]> bwe: it was designed to be brutally simple and capture everything, the process took many steps by logicians in first half of the last century (kindof finalized by Church)
13:34:13 <dstolfa> languages like haskell, agda, idris and so on are based on a different logic and different axioms
13:34:16 <geekosaur> bwe, there are multiple approaches. functional languages tend to orient around lambda calculus, and vary based on e.g. different type systems. others take other approaches. some of them also involve formalisms, just different ones
13:34:31 <c_wraith> bwe, haskell has stayed relatively close to constructive intuistionist logic.
13:34:41 <Berra> geekosaur: Script as in what kind? I'm very inclined to try writing a solution using either Data.Data or TH - I'm just not able to envision which one is best suited (pros/cons)
13:34:50 <dyl> [exa] that's why it's the lambda calculus, they had to go all the way through alpha to kappa first!
13:34:57 <[exa]> lol
13:35:07 <dyl> But actually, why is it lambda in particular.
13:35:09 <dyl> I don't know.
13:35:13 <patlv> glguy: right, I'm just struggling with the types (from the signature of fold_): QueryResults r => Connection -> Query -> a -> (a -> r -> IO a) -> IO a, this part I can't figure out: (a -> r -> IO a)
13:35:51 <geekosaur> Berra, write a script/program to generate boilerplate code. which I've been known to do in emacs (rarely), more often a quick haskell program that e.g. reads a data declaration and writes out another haskell program that does those mappings
13:36:01 <geekosaur> (or a perl/python script, or whatever floats your boat)
13:36:13 <bwe> I wonder whether there is some (written) historical account summarising the evolution of Logic in the last 200 centuries, side-highlighting Haskell and some imperative languages.
13:36:19 <glguy> patlv: That function will be applied to the current "accumulator" value and the next result row from your query producing an updated accumulator value
13:36:19 <dyl> " The notation did not just happen to be chosen but was to distinguish it from another construction by Whitehead and Russell represented as “xˆ.” For his new system, Church initially used “∧x,” then replaced it to “λx” to ease printing, obviously, interpreting the former logical symbol as the capital Greek letter “Λ.”"
13:36:20 <[exa]> dyl: the abstracted variables were written with a hat before (iirc even Russel sometimes uses that convention). lambda is the closest thing you can do on a typewriter
13:36:21 <geekosaur> sometimes it's not worth overthinking things :)
13:36:23 <dyl> Interesting.
13:36:30 <glguy> patlv: That will be repeated once for each row in the result
13:37:21 <Berra> geekosaur: Sure - that's very pragmatic. I could write out the solution by hand in that case - it's not too bad. I more or less just want to derive the implementation using Data.Data or TH if it could be done in about the same amount of code as writing it out manually.
13:38:06 <patlv> glguy: thanks, gonna dig more
13:38:28 <geekosaur> it can be done, Data is somewhat annoying and prone to slowness, TH faster but also has annoyances (you're working with the AST directly, not Haskell code as such)
13:38:44 <geekosaur> I prefer avoiding both
13:38:52 <zincy> If I have a [Bool] and an Int representing the index of the current position marker. How would I write a function such that the marker will increment in modulo fashion to the next True value.?
13:38:58 <Berra> geekosaur: What is your major reasons for avoiding them?
13:39:39 <glguy> Berra: Yes, Data.Data can do this, so can GHC.Generics, so can Template Haskell
13:39:52 <geekosaur> what I just said, both are annoying in their own ways. I find whipping up a quick script less unpleasant
13:40:02 <geekosaur> but that's personal taste, really
13:40:17 <geekosaur> there's plenty of packages on hackage that use TH to do similar things
13:40:25 <geekosaur> or Data.Data, or Generics, etc.
13:42:06 <glguy> Oh, actually calling 'show' on the fields generically might actually not be possible. You'd need to provide some list of supported types you can show
13:42:08 <Berra> geekosaur, glguy I think I can find good material on how to learn more on each respective approach. Finding discussion on how they compare and how to select the right tool for the job seems less straight forward.
13:42:10 <glguy> in the case of Data.Data
13:42:16 <dyl> Do we not have Data.Data.Data yet?
13:42:22 <dyl> acme-data-data-data?
13:42:51 <geekosaur> dyl, that's the data type :)
13:43:02 <dyl> :k Data.Data.Data
13:43:04 <lambdabot> * -> Constraint
13:43:05 <dyl> :i Data.Data.Data
13:43:10 <dyl> Oh, there we go, heh.
13:43:21 <dyl> The best thing about Data.Data is the name 'gunfold'.
13:43:22 <geekosaur> hm, typeclass then. whoops
13:43:31 <geekosaur> %% :i Data.Data.Data
13:43:35 <yahb> geekosaur: http://qp.mniip.com/y/78
13:44:01 <glguy> Berra: You've made the problem slightly harder by throwing in Show. GHC.Generics will make that really easy. Template Haskell allows you to generate arbitrary code, so there aren't many limits to what you can emit
13:44:14 <glguy> well "really easy" if you know how to do it already
13:44:26 <dyl> glguy you can't emit infinite code though.
13:44:32 <dyl> Or, well, you can, but not in any finite time.
13:44:35 <glguy> ok, thanks
13:44:41 <Berra> glguy: I want to find out a way to gain a better intuition why I would use Generics over Data.Data in such a case.
13:44:46 <Berra> or wise versa
13:45:03 <glguy> Berra: well, you can't really do it in Data.Data so this won't be a good example
13:45:19 <cocreature> that’s a pretty good reason to use Generics over Data.Data :)
13:45:31 <fishythefish> dyl: clearly we just need more laziness
13:45:43 <geekosaur> Data.Data is left over from an older version of generics, really.
13:45:45 <Berra> glguy: Right - but that's even more reason to understand given that Data.Data has those kinds of restrictions (which I don't know about or understand yet) why it would be used.
13:45:59 <dyl> fishythefish: a lazy templated program would require eval though.
13:46:03 <dyl> Begone with your heresy!
13:46:11 <glguy> Berra: If you want to understand these things you'd just start learning how write thing things in each system
13:46:19 <Berra> geekosaur: That's great to know - so Generics supplants Data.Data ?
13:46:23 <glguy> no
13:46:55 <glguy> GHC.Generics is very typeclass driven, explicit about which instances are supported to be either generically consumed or produced
13:47:01 <fishythefish> dyl: i'm sensing an application of greenspun's tenth rule
13:47:06 <Berra> glguy: Before I start reading thoroughly - do you know of some example case where Data.Data is preferable to Generics?
13:47:16 <glguy> Data.Generics (syb) is driven by Typeable and some generic functions for contructing and folding ADT values
13:47:16 <Berra> Sorry for asking questions - I should just get reading
13:47:33 <dyl> Don’t apologize for asking questions.
13:47:35 <glguy> syb will allow you to write tiny one-liners
13:47:42 <glguy> GHC.Generics is more flexible and more verbose
13:47:50 <geekosaur> they're different approaches, and Data.Data still has uses beyond the generics layer. And syb is still around on hackage.
13:47:52 <dyl> 0.o?
13:48:02 <dyl> You mean Data.Data (syb)?
13:48:06 <geekosaur> because it got a fair amount of use before the new GHC.Generics
13:48:27 <glguy> Berra: Here's an example using syb: https://github.com/glguy/AddParens/blob/master/Main.hs#L29-L49
13:48:32 <geekosaur> there are also other approaches to generics on hackage. GHC.Generics isn't the be-all and end-all
13:48:39 <glguy> this can be done in GHC.Generics and it would just be much more verbose
13:49:09 <glguy> There are some other GHC.Generics approaches that end up being more complicated in hopes of being less verbose
13:49:30 <glguy> Data.Data is lots of dynamic run-time checks
13:50:04 <Berra> This does also mean that something implemented using Data.Data could potentially work for compiling with for example ghcjs but GHC.Generics obviously wouldn't?
13:50:19 <glguy> Data.Data is pretty terrible for working with types with kind * -> * where you want to be able to change that type parameter
13:50:19 <Ariakenom_> bwe: Sounded like you may like this Philip Wadler - Propositions as Types (Lambda Days 2016) https://www.youtube.com/watch?v=aeRVdYN6fE8
13:50:32 <glguy> Berra: No, both of these would work in ghcjs
13:51:11 <Ariakenom_> that was the wrong link https://www.youtube.com/watch?v=IOiZatlZtGU
13:51:17 <Berra> glguy: Interesting - I see - but there are non GHC compiler where it wouldn't I guess.
13:51:24 <cloudhead> hey, anyone know how to use shuffle from Random.Shuffle?
13:51:42 <pie_> is there any sort of gui programming paradigm that makes concurrency in a gui approachable? i.e. mainly not hanging while doing background operations
13:51:42 <Ariakenom_> :t Random.Shuffle
13:51:44 <lambdabot> error:
13:51:44 <lambdabot>     Not in scope: data constructor ‘Random.Shuffle’
13:51:44 <lambdabot>     No module named ‘Random’ is imported.
13:51:45 <glguy> Berra: there's no reason that either of the two would be harder or easier to implement in a hypothetical compiler that you aren't using
13:51:47 <Berra> Insignificant reason to pick one or the other  of course
13:52:04 <pie_> or is it not that hard, i just havent figured it out yet?
13:52:11 <Ariakenom_> ihateoverlyhierarchicalmodules
13:52:13 <glguy> I guess GHC.Generics relies on having type families
13:52:24 <glguy> so maybe the hypothetical complier would find it easier to implement syb
13:52:31 <Ariakenom_> :t System.Random.Shuffle
13:52:32 <lambdabot> error:
13:52:32 <lambdabot>     Not in scope: data constructor ‘System.Random.Shuffle’
13:52:32 <lambdabot>     No module named ‘System.Random’ is imported.
13:52:50 <zincy> Is there an easy way to cycle through a list infinitely?
13:52:53 <glguy> Ariakenom_: without some dots in that sentence I'm not able to read it
13:52:59 <glguy> :t cycle
13:53:00 <lambdabot> [a] -> [a]
13:53:34 <Berra> glguy geekosaur Thanks a bunch - I'll take a close read on GHC.Generics and Data.Data. Thanks
13:53:36 <Ariakenom_> glguy: Good. I'm not constructive, just whining
13:54:37 <zincy> glguy: Thanks!
13:55:46 <geekosaur> pie_, there's some work on functional reactive programming. But the real problem is that most GUIs aren't reentrant; in particular, X11 (unix/linux) requires each thread to have its own connection to the X server, making it hard for them to share resources (although it's possible)
13:56:54 <pie_> geekosaur, *cries*. i've only done qt so far though
13:58:39 <Ariakenom_> some not-necessarily-functional async and stm might be make it nicer though
13:59:15 <pie_> ideals is one thing and practice is another in this case, im curious about both but bogged down in the latter
14:00:17 <Ariakenom_> pie_: are you writing in haskell? You know the Async and STM modules?
14:00:39 <pie_> yes im writing in haskell, i am a very tiny bit familiar with Async
14:00:50 <pie_> (im using Qtah actually, for QT)
14:01:13 <pie_> i can fire off background tasks, but i only know how to get their results while blocking the main thread
14:01:29 <geekosaur> Ariakenom, it's not always enough to just lock the connection because X11 is asynchronous. if an event comes in, who gets it?
14:01:36 <pie_> whereas ideally i would like the main thread to remain responsive for the user while still being "updated by" the background tasks
14:01:56 <pie_> the only idea ive really had is some sort of inversion of inversion of control
14:02:20 <pie_> where i would make the background tasks pass some handler back to the gui thread or something, but im pretty lost.
14:02:28 <zincy> Say you have a list is there a way to specify and index where you take all the preceding elements of the list and append them to the end?
14:02:44 <Ariakenom_> pie_: You should definitely be able to get results without blocking
14:03:22 <pie_> Ariakenom_, im not saying its impossible, i just dont know how to learn how to do this (with a GUI/ Qt)
14:03:36 <zincy> pie_: Concurrency is a pain
14:03:56 <Ariakenom_> are the background tasks doing QT stuff?
14:04:57 <pie_> Ariakenom_, the concrete problem is that i want to download a gallery of images without blocking the gui, and then display the images
14:05:19 <pie_> so the "unit" operation here would be downnloading and displaying a single image without blocking the gui thread
14:05:35 <bwe> Can I implement (+) for a type different than of Num type class?
14:05:41 <pie_> the downloading is simple, but how do i pass the downloaded record back to the gui thread?
14:05:44 <zincy> pie: withAsync?
14:05:49 <Ariakenom_> pie_: Sounds like you want to create a muuutaaable reference
14:06:14 <pie_> the gui thread also needs to be able to figure out when to update it's gallery
14:06:27 <geekosaur> bwe, only if one or both has a qualified name.
14:06:33 <pie_> i.e. what would trigger a "refresh gallery list" event? (i dont know)
14:07:05 <zincy> waitAny :: [Async a] -> IO (Async a, a)
14:07:07 <pie_> something needs to pass the image and trigger a (addImageToGallery gallery image) function in the gui thread
14:07:19 <Ariakenom_> pie_: Can't you poll the gallery? Instead of events
14:07:27 <pie_> zincy, wouldnt any sort of `wait` be a blocking function?
14:07:56 <zincy> Yeah but you can block on the wait in a forked thread
14:08:10 <zincy> async and withAsync will fork a new thread to run the blocking computation in it
14:08:22 <pie_> geekosaur, hm, your comment about reentrancy suddenly clicked with me i think. if it was reentrant i could just call gui functions in the other threads, yeah? :(
14:08:43 <bwe> geekosaur: what is a qualified name?
14:08:49 <zincy> As far as I am aware you don't get non-blocking IO right in haskell
14:09:02 <geekosaur> yes. except that the connection to the server is a socket, and if two threads write to it at the same time the server sees interleaved messages. and two threads reading form it, one will randomly get the message (or part of it)
14:09:06 <zachk> pie_, do you have access to an event system and maybe an event loop? provided by the gui though
14:09:17 <zincy> to pass the downloaded value back you need to use an Mvar or a Tvar
14:09:44 <pie_> zincy, im not convinced your suggestions will work, but you probably have more experience than i do so ill definitely take a look :D
14:10:01 <zincy> Im not convinced they will work either
14:10:12 <Ariakenom_> pie_: Do you need to fire an event or can you simply poll a channel for updates?
14:10:12 <geekosaur> zincy, the RTS does non-blocking I/O, the assumption is that threads block on I/O and threads are cheap
14:10:13 <zachk> reading on an mvar usually blocks as well
14:10:31 <geekosaur> so you let the RTS be the master event loop
14:10:31 <zincy> it seems you can do most things in concurrent haskell by learning the async and stm libraries
14:10:55 <pie_> geekosaur, makes sense i guess. havent ever looked at x11 internals
14:11:12 <zincy> geekosaur: Doesn't the runtime of any language do non-blocking IO
14:11:44 <geekosaur> zincy, there are languages with single-threaded runtimes (and lousy thread support. perl 5, python, ...)
14:11:54 <zachk> zincy, not all languages have a runtime, take c for example no runtime system or garbage collection
14:11:57 <pie_> zachk, sort of. im pretty sure Qt has something like that. i will have to add it to the qtah bindings though since nothing related to it seems to be implemented. not horribly complicated but annoying for my nooby self nevertheless
14:12:04 <zincy> interesting
14:12:08 <geekosaur> which is when you have to haul out poll() or other event-based stuff
14:12:35 <zincy> a runtime systems sounds a lot like an interpreter
14:12:38 <geekosaur> and you might want to think about what you are saying because poll() also blocks. you do not want to busywait if you can help it, unless you know it will be a very short wait
14:13:07 <geekosaur> rather, you want as many things as possible to be blockable events that can be harvested with a single operation
14:13:28 <glguy> C has a runtime component, but it's focused on startup
14:13:57 <geekosaur> startup, stdio, malloc pool management
14:14:06 <Ariakenom_> i'd count stack management to runtime as well
14:14:50 <pie_> zachk, what if i have access to an event system/loop?
14:15:14 <Ariakenom_> pie_: Do you need to fire an event or can you simply poll a channel for updates at some point?
14:15:25 <pie_> Ariakenom_, im not sure.
14:15:37 <pie_> Ariakenom_, pretty sure i need to fire an event
14:15:50 <geekosaur> except that in C, most stakc management is by individual functions, so it's less runtime than compiler
14:16:50 <pie_> Ariakenom_, it would be a waste to poll every 0.1 seconds when new images should only be loaded when scrolling and not otherwise. i mean, the information for when an update should happen is availible
14:16:58 <pie_> it is when the download finishes.
14:17:55 <zachk> pie_, id forkIO another thread to do the dirty work and have it signal via an event back to the gui loop, then have an event handler run when it's signalled to present the images you downloaded
14:17:58 <pie_> actually, im not sure when you would choose polling ever... (which is just my lack of knowledge)
14:18:13 <Ariakenom_> polling every 0.1s sounds fine. It probably takes 0.0001s
14:18:44 <pie_> Ariakenom_, i guesss
14:19:20 <pie_> zachk, that makes sense i think.
14:19:24 <Ariakenom_> i do remember someone linking a benchmark for those using refs. I tihnk it was around 100 ns
14:20:11 <pie_> man GUIs are hard >_>
14:20:35 <zachk> you could just use an mvar that stores all the images though and just update it in another thread and do the mvar read from it that doesnt empty the mvar in the gui thread
14:20:50 <pie_> i guess this is why everyone does everything with javascript now
14:21:44 <geekosaur> pretty much
14:21:46 <zachk> they do it with javascript/web so they can just run it on anything with a web browser, a pc , a mac, linux system, smartphone etc
14:22:09 <geekosaur> or using very high level toolkits (gnome, kde) and letting those manage the events
14:22:56 <pie_> zachk, i dont understand what you meant by the mvar read part
14:26:08 <zachk> pie_, you want to use readMvar in the gui thread so it doesnt block and make sure your mvar is always full with something even a data structure representing no images
14:26:17 <zachk> https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Concurrent-MVar.html
14:26:36 <pie_> zachk, ok, what i dont understand is how it would know when to update. unless you were thinking of polling
14:27:29 <zachk> you just always display, in the gui thread, the contents of the mvar, even if you haven't loaded any images into it yet
14:31:18 <dmwit> > let g ... h = g `seq` h `seq` \x -> g (h x) in seq (undefined ... id) ()
14:31:19 <pie_> zachk, so something like checking every frame? (isnt that technically polling?)
14:31:20 <lambdabot>  *Exception: Prelude.undefined
14:31:51 <dataN> type level prime numbers can be generated, as can type level programs to check that these are correct. both the promoted prime checker and their generators have various possible implementations, and so form respective classes. how can these classes be declared?
14:31:59 <dmwit> % let g ... h = g `seq` h `seq` \x -> g (h x) in seq (undefined ... id) ()
14:32:00 <yahb> dmwit: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:18:53 in interactive:Ghci8
14:32:08 <dmwit> % :! ghci --version
14:32:09 <yahb> dmwit: /bin/sh: 1: ghci: not found
14:32:13 <dmwit> booo
14:33:45 <pie_> zachk, i guess this is what i want http://doc.qt.io/qt-5/qt.html#ConnectionType-enum the queuedconnection
14:34:09 <pie_> context: qt has signals and slots for connecting stuff up, signals are basically events and slots are thing that take events
14:34:13 <pie_> something like that.
14:34:40 <glguy> % System.Info.compilerVersion
14:34:41 <yahb> glguy: Version {versionBranch = [8,6], versionTags = []}
14:34:46 <glguy> dmwit: ^
14:34:49 <dmwit> thanks!
14:35:03 <pie_> so id have to make a queuedconnection from the workerk thread to the GUI thread that fires the image update commeand yeah? and creating a connection and that stuff is reentrant so it will work.
14:38:12 <zachk> pie_, dunno, never worked with qt at all
14:38:25 <pie_> zachk, sure just trying to see if you think this makes sense
14:38:38 <pie_> but if you dont want to deal with it, thats fine
14:39:29 <zachk> you would need to signal the worker thread that you scrolled down as well, and to download more images
14:39:50 <zachk> not sure how to do that
14:41:34 <pie_> zachk, i just fire the worker threads from the gui thread that deals with scrolling?
14:41:42 <pie_> firing a thread is cheap yeah?
14:42:16 <pie_> if i need some kind of common downloader object i probably pass an ioref or something?
14:45:24 <pie_> if i need a long-lived thread i think i could use the same signal/slot mechanism, just in the other direction.
14:45:58 <pie_> hmmmmm.
14:46:05 <dataN> its for use in declaring a shaped container, where a substructure which is a graph supports another graph consisting of some of its nodes, the edges between which are lists of edges of between the substructure nodes. The user should be able to specify a rule which defines the way to get between nodes, i.e. how to generate lists of substructure edges.
14:46:31 <pie_> zachk, i think i might not need any special new functionality, but how can i ensure that a function gets run in the main thread when its called from a worker thread?
14:46:51 <pie_> zachk, ah sorry dumb question. that would presumably be handled by the signal/slot mechanism.
14:47:50 <dataN> that these navigational instructions (to traverse the substructure, generating the list of edges) result in a navigation between nodes, i.e that following these edges leads to the next node, should be enforced at type level. so the class which defines the shape of the structure needs to demand some kind of type equality, hence the example using prime numbers.
14:54:58 <dmwit> pie_: Dunno about Qt, but in Gtk, that kind of thing is provided by the GUI library.
14:55:29 <dmwit> e.g. postGUISync/postGUIAsync in gtk will send an IO action from an arbitrary thread to be run by the GUI thread.
14:56:00 <Ariakenom_> pie_: note on terminology. you use the word "function" C-style.
14:57:07 <Ariakenom_> :t \t -> many $ readTVar t
14:57:08 <lambdabot> error:
14:57:08 <lambdabot>     Variable not in scope: readTVar :: t -> f a
14:57:36 <Ariakenom_> :t \t -> many $ STM.readTVar t
14:57:38 <lambdabot> error:
14:57:38 <lambdabot>     Not in scope: ‘STM.readTVar’
14:57:38 <lambdabot>     No module named ‘STM’ is imported.
14:58:19 <dataN> the idea is that *any* prime number checker which works correctly can be used to check *all* possible prime number generators, so that providing such a checker is in scope, it should be possible to determine at compile time if a user defined prime number generator is correct (assuming it only generates a finite number of primes)
15:00:40 <Ariakenom_> anyway. random thought. (many . readTChan :: TChan a -> STM [a])  will read all available items.
15:01:12 <dataN> and the question is what is the type of the function defining the class of type level primes, given the existence of a type level prime checker (which is a type family?)
15:02:51 * pie_ mumbles something at dataN about the halting problem?
15:03:06 <pie_> (ignore me if irrelevant)
15:03:42 <geekosaur> if it only generates a finite number of primes, arguably it is incorrect :)
15:05:55 <dataN> ok, so for a finite graph, if it does not compile in finite time, then the user has specified an incorrect navigational function.
15:07:16 <dataN> or it could hit the boundaries or something...
15:07:58 <dataN> thought the graphs in question are cyclic...
15:09:12 * Ariakenom_ mumbles something about the halting problem always being irrelevant
15:09:41 * lambdabot mumbles about mumbling
15:10:07 <dataN> but for example, a finite binary tree, where the substructure would be the locations of a zipper that is not at the leaves, checking the validity of instructions to find the next leaf should be determinable
15:14:41 <dataN> actually, its very easy to do so, kind of like finding the next prime number. is it correct to think that this is an extension of simple examples of equality over type families?
15:15:04 <dmwit> Ariakenom: neat
15:16:56 <Ariakenom> asum is select. fmap Just and append Nothing to poll
15:28:23 <zincy> Is it a good idea to use splitAt and cycle for doing a modulo increment on a list? Or is there a better way
15:28:50 <lyxia> what's that
15:29:05 <lyxia> "modulo increment on a list"
15:29:55 <zincy> Increment a list and if you go off the end then start at the beginning
15:30:07 <zincy> increment the index *
15:30:16 <fishythefish> that's imperative talk
15:30:19 <fishythefish> what are you trying to do with this?
15:30:57 <zincy> So I have a list of record values which are players
15:31:19 <zincy> I have an int representing the current player to act and want to get the next player to act
15:31:53 <zincy> so we start at the current index and then find the index of the  next player such that one of their fields satisfies a predicate
15:32:25 <fishythefish> this still sounds pretty imperative, but have you considered just taking the index modulo the length of the list instead?
15:32:34 <zincy> Here is my failed attempt at an implementation
15:32:34 <zincy> https://lpaste.net/616589791391121408
15:32:59 <zincy> fishythefish: The issue with that is that you have to skip a player that is sat out
15:33:19 <fishythefish> yes, but I assume you take care of that when you check if the field satisfies the predicate
15:33:20 <zincy> Which is denoted by a record field on the player /== In
15:33:23 <fishythefish> if it fails, on to the next one
15:33:37 <lyxia> have you tried not using cycle
15:34:39 <zincy> Tried cycle but it didnt work as I expected
15:36:26 <lyxia> you need the index of a player, so we can start with  iplayers = zip [0 ..] _players
15:36:36 <lyxia> to put the players next to their index.
15:37:44 <zincy> Cool, so how do we start counting from a given index?
15:38:03 <lyxia> then we need to start iterating from somewhere in the middle in the list   iplayers' = let (a, b) = splitAt _currentPosToAct iplayers in (b <> a)   no cycle, once we're through the whole list that's it.
15:38:06 <zincy> I thought about splitAt but that seemed overly complex
15:39:42 <Solonarv> if you're only going to use one of the halves, there's drop / take
15:40:02 <lyxia> then we need to find some ready player, and there's a "find" function    (nextIx, nextPlayer) = find (\(_, p) -> _playerState p == In) iplayers'
15:40:20 <dstolfa> are there any official haskell bindings for z3?
15:40:37 <lyxia> (they mentioned they want to wrap around earlier)
15:41:14 <lyxia> zincy: ah I forgot find returns a Maybe.
15:41:19 <Solonarv> ah, I wasn't there yet and I don't have scrollback set up
15:41:22 <fishythefish> dstolfa: based on the repo, no
15:41:35 <dstolfa> fishythefish: :(
15:41:40 <dstolfa> this is very frustrating
15:42:43 <lyxia> zincy: but that's basically it in three lines
15:43:25 <lyxia> I guess there might be a less imperative way to explain them...
15:44:07 <zincy> nice ... thanks!
15:45:06 <zincy> lyxia: Is the iX of the reversed list?
15:45:17 <zincy> nextIX I mean
15:45:20 <lyxia> zincy: it's the index of the next player
15:45:37 <lyxia> remember that iplayers' is a list of pairs of indices and the corresponding player
15:46:12 <zincy> ah
15:48:48 <zincy> lyxia: weird but my test case is failing for two players where the current pos is 1 -  I would expect the resulting nextIX to be 0
15:49:22 <dmwit> Thus sounds awfully complicated. Can't we just make an `Array Int Player` and be done with it?
15:49:28 <dmwit> Just use, like, *actual* indexing.
15:49:51 <dmwit> Use `IntMap Player` instead if you need efficient updates at a given index.
15:50:58 <lyxia> That sounds like a better idea
15:51:11 <zincy> dmwit: Why is that approach better?
15:51:17 <dmwit> dstolfa: Dunno about "official", but: http://hackage.haskell.org/package/z3 ?
15:51:46 <dmwit> zincy: 1. simpler, therefore less opportunities for bugs 2. almost certainly faster
15:52:04 <glguy> dmwit: What are the upsides?
15:52:41 <zincy> Im most often accessing the players by name
15:52:52 <dmwit> Then perhaps you'd like a `Map Name Player`.
15:52:55 <zincy> So I have an idea of using a map with the name of the players as keys
15:53:01 <zincy> Yeah
15:53:12 <zincy> Then we are back to the indexing madness though right
15:53:28 <dmwit> If you need both kinds of indexing, there are a couple choices.
15:53:34 <dmwit> The heavyweight one is ixset.
15:53:45 <dmwit> The lightweight one is `Map Name Int` and `IntMap Player`.
15:54:27 <zincy> Will intMap Player not be slower if I am doing lots of name lookups
15:54:28 <dmwit> (Or the other way around, `IntMap Name` and `Map Name Player`.)
15:54:41 <dmwit> Slower than a list? It's hard to imagine.
15:54:51 <Zipheir`> You could also project the Map Name Player to a list for indexing operations.
15:55:31 <zincy> IntMap name , doesnt that lose the player type?
15:55:52 <dmwit> Yes. That's why I didn't suggest `IntMap Name`.
15:56:00 <dmwit> I suggested `IntMap Name` and `Map Name Player`.
15:56:11 <Solonarv> if the indexes are contiguous, Array Int or Vector would beat IntMap
15:56:17 <zincy> ah ok
15:56:21 <dmwit> Solonarv: Maybe. Unless there's lots of updates.
15:58:04 <epta> is brittany supposed to sort imports out of the box?
15:58:07 <dstolfa> dmwit: that might do
15:58:11 <Solonarv> as long as they're in-place (or get optimized to in-place) it should be fine, no?
15:58:12 <epta> or should it be enabled by some option?
17:33:20 <ChaiTRex> Does `ghc +RTS -N -RTS File.hs` make GHC use more than one core?
17:34:44 * hackage serverless-haskell 0.6.2 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.6.2 (AlexeyKotlyarov)
17:36:53 <hpc> ChaiTRex: you probably want to use cabal to build your project
17:41:23 <ChaiTRex> hpc: Oh, I am, I'm just wondering.
17:43:29 <Solonarv> I don't think GHC can multi-thread compiling a *single* module; if you're compiling multiple modules with ghc --make, you can use the -j option
17:43:36 <Solonarv> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#ghc-flag--j[%E2%9F%A8n%E2%9F%A9]
17:46:17 <ChaiTRex> Solonarv: Oh, OK. Thanks.
17:54:22 <fresheyeball> how com Bools are not lazy?
17:55:41 <Solonarv> what do you mean?
17:55:54 <Solonarv> what are you doing, what do you expect to happening, and what's happening instead?
18:00:33 <hpc> fresheyeball: they're as lazy as the definition "data Bool = False | True" allows them to be
18:00:51 <fresheyeball> hpc: ok so
18:00:55 <hpc> operations on Bool might be slightly stricter, or you're seeing optimizations, it really depends on what you're doing
18:01:00 <fresheyeball> let x = 1; :sprint x
18:01:02 <fresheyeball> give
18:01:05 <fresheyeball> x = _
18:01:10 <fresheyeball> let y = Truel :sprint y
18:01:12 <fresheyeball> gives
18:01:15 <fresheyeball> y = True
18:01:18 <hpc> ah
18:01:29 <hpc> that happens with any constructor assignment
18:01:32 <hpc> 1 isn't actually 1
18:01:36 <shachaf> Try let y = 1::Int
18:01:39 <hpc> it's fromInteger TheIntegerOne
18:01:51 <hpc> try y = id True
18:01:51 <fresheyeball> uh
18:02:02 <fresheyeball> hpc: if I define my own type
18:02:04 <hpc> and y = 'c'
18:02:11 <fresheyeball> data Foo = Bar; b = Bar
18:02:14 <fresheyeball> :sprint b
18:02:18 <fresheyeball> b = _
18:02:30 <fresheyeball> so, something is different about Bool
18:02:34 <fresheyeball> its not lazy in the same way
18:02:44 <fresheyeball> and it could be
18:02:50 <hpc> must be something about how you're defining Foo
18:02:58 <fresheyeball> what?
18:03:03 <hpc> interpreted vs compiled might matter, i forget if anything else does too
18:03:14 <fresheyeball> I am just in the repl
18:03:29 <fresheyeball> and I dont think they differ in terms of normal form
18:03:37 <hpc> i just tried it like this: https://www.lpaste.net/5897606403740139520
18:03:56 <hpc> ghc 8.0.2
18:04:52 <hpc> i don't think you're running into anything Bool-specific here
18:05:07 <fresheyeball> oh oh oh!
18:05:08 <Solonarv> yeah Bool is actually just defined as data Bool = False | True
18:05:13 <fresheyeball> yeah, not bool specific
18:05:22 <fresheyeball> I think all the bool refs are shared
18:05:33 <fresheyeball> and so my mental model of this is wrong
18:05:48 <fresheyeball> I think all things that are `True` are refering the same computation
18:05:50 <fresheyeball> let me check
18:05:58 <geekosaur> in some cases yes, iirc
18:06:13 <geekosaur> True and False are wired-in names
18:06:43 <Lears> In my ghci the difference is whether you 'let' or not.
18:06:50 <geekosaur> but I think that should have only limited effect since "wired-in" relates to the compiler. and any constuctor is known to the compiler and can be shared
18:07:21 <fresheyeball> nope
18:07:23 <fresheyeball> hu
18:07:44 <fresheyeball> https://hastebin.com/rawanaloci.shell
18:07:48 <Lears> Well, for Bool anyway.
18:08:26 <fresheyeball> oh wait
18:08:28 <fresheyeball> wait
18:08:32 <fresheyeball> wait
18:08:39 <fresheyeball> its the usage of `let` in the repl
18:09:01 <Solonarv> in any case: this has nothing to do with Bool being lazy or not; it only makes sense to talk about a the laziness of a data type's constructor fields, not the data type itself
18:09:23 <fresheyeball> right I get what you are saying and how this is supposed to work
18:09:24 <geekosaur> hm. if it's using the normal processing, let would be lazier than a top level binding. not that I know what ghci is up to there
18:09:26 <hpc> oh! that makes sense
18:09:31 <fresheyeball> I am baffled by a behavior I am seeing the repl
18:09:54 <fresheyeball> https://hastebin.com/denucicoye.shell
18:10:05 <hpc> geekosaur: hmm, it makes sense up to a point
18:10:12 <hpc> x = undefined doesn't error out right away
18:10:22 <hpc> but somehow it knows that x = True is a constructor
18:10:58 <fresheyeball> https://hastebin.com/iqokibozid.shell
18:11:03 <fresheyeball> ok NOW I am confused
18:12:39 <hpc> this is probably the most complicated thing you can try to understand that's this close to language semantics
18:12:54 <hpc> because it depends on implementation details
18:13:12 <hpc> and many circumstantial details
18:13:15 <fresheyeball> I just want to what what is special about let
18:13:25 <fresheyeball> can I get a sense?
18:14:10 <Solonarv> I'm mostly just surprised that using let vs. not affects the behavior
18:14:21 <hpc> let-in does irrefutable matches, that miiiiiight be part of it
18:14:27 <Solonarv> I thought being able to omit let in ghci was purely syntactic
18:14:39 <hpc> > let (Left x) = Right 5 in x
18:14:41 <lambdabot>  *Exception: <interactive>:3:5-22: Irrefutable pattern failed for pattern Left x
18:14:50 <hpc> > let (Left x) = Right 5 in "no error"
18:14:52 <lambdabot>  "no error"
18:15:19 <fresheyeball> > let x = error "no"
18:15:21 <lambdabot>  <no location info>: error: not an expression: ‘let x = error "no"’
18:15:31 <Solonarv> I think lambdabot needs @let instead
18:15:50 <hpc> it also works differently in yet another way
18:15:56 <hpc> it puts it in L.hs or something like that
18:15:58 <fresheyeball> > @let doesntEval = error "no"
18:16:01 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
18:16:10 <fresheyeball> @let doesntEval = error "no"
18:16:10 <hpc> #ghc might enjoy analyzing this
18:16:12 <lambdabot>  Defined.
18:16:42 <Solonarv> try yahb instead? IIRC that one's closer to raw ghci
18:16:55 <Solonarv> % let x = error "boom"
18:16:56 <yahb> Solonarv:
18:17:06 <Solonarv> % x
18:17:07 <yahb> Solonarv: *** Exception: boom; CallStack (from HasCallStack):; error, called at <interactive>:3:9 in interactive:Ghci5
18:23:46 <geekosaur> fwiw the difference between literal constructors and undefined (or any other non-constructor) is that the constructor can be recognized syntactically as something that will never be bottom
18:24:10 <hpc> oh right
18:24:11 <geekosaur> so there's no reason to indirect them through thunks
18:25:56 <geekosaur> (this may not apply to things defined within ghci, though; it depends on how they do it. I have a very vague memory of someone asking about this previously in #ghc)
18:27:01 <Solonarv> yeah geekosaur that was my thinking; the thing that puzzles me is that constructors bound without let are still turned into thunks
18:27:06 <geekosaur> but the stuff I mentioned about wired-in names may end up applying there, because it knows even more about the name and so may just point to the wired-in stuff. there's multiple levels of "wired-in", some of which include predefined values in the RTS
18:27:29 <geekosaur> that code was added afterward and might not do the same thing
18:27:52 <geekosaur> i.e. they didn't just copy-paste or invoke the existing code, they did something different
18:28:10 <geekosaur> there's been a few of those found as well
18:29:35 <Solonarv> hmmm... you may be on to something with the wired-in names
18:30:26 <Solonarv> with -XNoImplicitPrelude and defining data Bool = False | True, I get a thunk in both cases
18:30:29 <geekosaur> as I said, it might have more to do with wired-in values. some often-used constructors, the values are wired into the RTS instead of new thunks being created
18:31:16 <Solonarv> however I did *not* notice this behavior with single-constructor sum types
18:31:35 <geekosaur> which is kinda trivial in this case because they're both nullary, so there just has to be an 0 or 1 word somewhere known to represent False and True respectively, and it points directly to that
18:32:51 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/WiredIn Bool is fully wired-in (it's the example of such), so it might well get special treatment
18:33:16 <geekosaur> there's also known-key, where the name is known but the value isn't wired-in
18:54:07 * hackage texrunner 0.0.1.2 - Functions for running Tex from Haskell.  http://hackage.haskell.org/package/texrunner-0.0.1.2 (cchalmers)
18:54:28 <geekosaur> hm, so 'let' goes through GHC.execStmt but without let it's GHC.runDeclsWithLocation
18:55:07 * hackage composition-prelude 1.5.0.7 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-1.5.0.7 (vmchale)
19:02:27 <geekosaur> this rabbit hole's getting too deep. but they're definitely different code paths. whether they should do the same thing or not is a question
19:03:04 <geekosaur> whether they *can* do the same thing may also be a question, since the code is shared with ghc
19:11:10 <pikajude> in floatToDigits :: ... -> ([Int], Int) what's the second `Int` for?
19:12:02 <pikajude> oh it's the exponent, that's right
19:38:05 <blankhart> i am experiencing intense nostalgia for open union types like unsealed traits in scala
19:39:07 * hackage streamly 0.4.1 - Beautiful Streaming, Concurrent and Reactive Composition  http://hackage.haskell.org/package/streamly-0.4.1 (harendra)
20:13:07 * hackage pointfree-fancy 1.1.1.8 - Tool for refactoring expressions into pointfree form  http://hackage.haskell.org/package/pointfree-fancy-1.1.1.8 (vmchale)
21:08:34 <butterthebuddha> Is there a function for updating a bytestring at a given index?
21:09:33 <butterthebuddha> Nvm, lens can do it
21:51:51 <pwestling> Any stack experts here? I'm trying to move to using two separate stack.yamls for my project, one for docker and one for local dev. When I run STACK_YAML=stack-docker.yaml stack build, stack starts redownloading GHC even though if I rename the file to stack.yaml and run without the env var, it realizes it's already done all that work. Is it expected that stack rebuilds everything if you change the name of the config
21:51:51 <pwestling>  file? Any workarounds?
21:52:29 <suzu> stack with docker always seemed wrong to me
21:52:41 <suzu> i opted for an approach where i build my own docker image that installs stack and then builds the app
22:15:00 <roconnor> How come ContT doesn't have a MonadWriter instance?
22:21:04 <roconnor> I guess it must be because of listen and/or pass.
22:21:15 <roconnor> tell is algebraic so it must be fine.
22:38:55 <vaibhavsagar> what's the fastest way to go from a number to its representation as a bytestring?
22:40:29 <vaibhavsagar> preferably keeping track of endianness
23:05:54 <cocreature> vaibhavsagar: the binary package?
23:06:53 <vaibhavsagar> cocreature: you mean using the putWord* functions?
23:07:23 <vaibhavsagar> another wrinkle for me is that I also want to use varint encodings
23:07:39 <vaibhavsagar> I'm trying to improve my git implementation
23:08:28 <cocreature> yeah, I don’t think binary has something builtin for varints but it should be reasonably easy to build it yourself
23:10:15 <vaibhavsagar> also I find lazy bytestrings very confusing
23:10:31 <ab9rf> what's confusing about them?
23:10:47 <cocreature> vaibhavsagar: lazy bytestrings are basically a list of strict bytestrings
23:11:18 <vaibhavsagar> I know that, but I haven't wrapped my head around working with them :(
23:11:56 <vaibhavsagar> especially when dealing with functions that expect either a strict or a lazy bytestring
23:12:06 <ab9rf> there are functions that expect either?
23:13:36 <vaibhavsagar> no, that's the problem
23:13:48 <ab9rf> i suppose you could use an (IsString s) constraint but IsString only has toString as a method
23:13:59 <ab9rf> sorry fromString
23:14:44 <vaibhavsagar> sure, but then converting back and forth loses the advantages of both
23:15:00 <cocreature> yeah there’s not really a nice solution here
23:15:15 <ab9rf> it's not generally feasible to do that
23:15:34 <cocreature> ideally backpack might eventually be able to help but until stack supports backpack, it seems to have trouble to become popular
23:28:36 <qeyoa> The very last variable (namely robotTwo) in this code https://lpaste.net/7231996238017593344 shows the error: "couldn't match type". I tried looking at ":t fight" and it seems to infer different types for it's arguments. Is this where the problem stems from?
23:31:46 <cocreature> qeyoa: I would recommend that you start by adding some type annotations
23:34:17 <qeyoa> this example is supposed to be without types
23:34:42 <qeyoa> it tries to simulate oop
23:35:19 <cocreature> there is no “without types” in Haskell. everything still has a type, even if you don’t specify the type explicitely
23:35:36 <qeyoa> yes i know, but you said i should add types
23:35:41 <cocreature> the problem is that if you don’t specify things explicitely, it a) gets hard to read and b) your error messages suffer
23:36:06 <cocreature> so since you seem to have run into an error, I recommend type signatures to get more useful error messages
23:37:19 <qeyoa> ok, i will try to add one for the robot and fight
23:40:44 <pavonia> qeyoa: It's recommended to add type signatures to all top-level defintions, otherwise the monomorphism restriction/type defaulting will bite you sooner or later
23:43:43 <ZeuPiark> hello
23:52:43 <qeyoa> pavonia: it seems like i need to add type annotation to all the functions in my example
23:57:07 <cocreature> you probably don’t strictly need them but it will at least make it significantly easier to find the error
