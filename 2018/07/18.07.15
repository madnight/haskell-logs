00:06:20 <cocreature> revskill: are you running those commands using a shell? because then there is no way for hoogle to differentiate between those since it never sees the quotes
00:06:57 <revskill> cocreature: In my case, i hoogle "gen", and it generates, instead of finding "gen" function
00:07:12 <cocreature> revskill: right, my point is the quotes are already stripped by the shell
00:07:27 <cocreature> so the arguments that hoogle sees are literally the same with and without quotes
00:07:39 <revskill> I see, it made sense
00:07:51 <revskill> gen is a reserved word
00:08:48 <cocreature> try escaping the quotes
00:09:06 <cocreature> or wrap the argument in single quotes
00:13:57 <revskill> Yeah, it works.
00:40:17 <piark_> hello
00:53:48 <iqubic> hey piark_
01:04:07 * hackage infer-license 0.1.0 - Infer software license from a given license file  http://hackage.haskell.org/package/infer-license-0.1.0 (SimonHengel)
01:23:51 <revskill> In ELM architecture, do we need to get all data needed to re-render everything for every request to server ?
01:24:14 <revskill> So caching at server seems "more correct" than caching at client
01:56:16 * [exa] tempted to use cyrillic ю as a turnstile for linear logic
02:16:07 * hackage hw-json-lens 0.1.0.0 - Lens for hw-json  http://hackage.haskell.org/package/hw-json-lens-0.1.0.0 (haskellworks)
02:25:43 <kosmikus> reactormonk: did you get your sop projections question answered the other day?
02:28:37 * hackage hash-store 0.1.0 - Hash as cache  http://hackage.haskell.org/package/hash-store-0.1.0 (shersh)
03:01:22 <obiwahn> hi
03:01:38 <obiwahn> is it possible to use stack to install something like xmonad?
03:03:41 <obiwahn> It looks like the tool is strictly focused on building single projects. Therefor it might be wrong to expect that it installs anything to ~/.stack/bin
03:03:58 <reactormonk> kosmikus, yeap. https://github.com/reactormonk/modules/blob/master/src/V2.hs#L188-L194
03:04:38 <cocreature> obiwahn: "stack install xmonad" will build the executable and copy it to ~/.local/bin/xmonad
03:05:37 <cocreature> obiwahn: xmonad is somewhat tricky since it has a feature where it tries to recompile itself when you changed the config. if you want that to work, you probably need some extra configuration. afaik people have managed to get that to work with stack, so I would just search for some tutorials/instructions
03:07:11 <kosmikus> reactormonk: why unsafeCoerce?
03:07:41 <reactormonk> kosmikus, now I'm wondering how I could create a default instance for DefaultRecipe so you can derive https://github.com/reactormonk/modules/blob/master/src/HedgehogExample.hs#L34-L39 - would you have me some hints on that? I'd start with https://github.com/well-typed/basic-sop/blob/master/src/Generics/SOP/Arbitrary.hs - looks pretty good
03:07:42 <obiwahn> The xmonad installation fails indeed. Then I tried "lambadbot" that asks me to add really a lot of extra-deps.
03:07:56 <kosmikus> reactormonk: and why Head?
03:08:22 <kosmikus> reactormonk: if you already say (Code a ~ '[l]), then you can simply use l again.
03:08:24 <reactormonk> ... deleted unsafeCoerce
03:09:07 <reactormonk> ... deleted Head
03:11:17 <kosmikus> reactormonk: there's also `IsProductType a l` already in the library, which expands to `(Generic a, Code a ~ '[l])`
03:11:57 <kosmikus> reactormonk: your function there is really just `productFrom` here: https://github.com/well-typed/generics-sop/blob/1e6ae80705800a1826f768f373fdebebec246c2f/src/Generics/SOP/Universe.hs#L174-L176
03:12:02 <kosmikus> reactormonk: unfortunately, that one isn't merged
03:12:40 <kosmikus> reactormonk: doing a DefaultRecipe instance looks plausible, but I have limited experience with Hedgehog.
03:12:59 <reactormonk> kosmikus, reload page, it's now generalized to Applicative
03:14:37 <reactormonk> ... can I have a default associated type?
03:14:59 <reactormonk> https://stackoverflow.com/questions/50167812/can-i-have-a-default-type-value-for-an-associated-type-family -.-
03:16:52 <oldandwise> in, 'f :: (a->b->a) -> a -> [b] -> a', is it correct to say that these letters a and b are types?
03:17:15 <kosmikus> reactormonk: in princple, yes
03:19:41 <kosmikus> reactormonk: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#associated-type-synonym-defaults
03:58:44 <c50a326> https://ptpb.pw/Tur_/hs this says it's expecting [Word32] instead of [Word8] on the input, why?
04:01:51 <cocreature> :t foldl1
04:01:52 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
04:02:06 <cocreature> t a is [Word8] in your case
04:02:11 <cocreature> but that means that a is Word8
04:02:18 <cocreature> but your type signature claims that you return Word32
04:05:04 <c50a326> ah I wanted toIP :: Bits a => [a] -> a
04:06:08 <c50a326> it works now... without any fromIntegral anywhere... yet it takes [Word8] and returns Word32
04:06:24 <c50a326> wait no I'm actually passing it Ints I think
04:06:36 <c50a326> or just numbers, in ghci, whatever they are by default
04:21:16 <dataN> are both stack and cabal maintained?
04:22:10 <cocreature> yes
04:22:41 <djtyml> hi, all~I would like to ask some advice. If I want to make a simple webpage that has google map javascript api,
04:23:33 <djtyml> what's the good choice? miso ghcjs elm purescript coffeescript servant spock haste...
04:26:46 <c50a326> hey how do you recv until the end of the stream?
04:27:07 <c50a326> djtyml: clojurescript
04:27:49 <dataN> employers are not aware that these version control systems are more powerful than github for developing haskell, forcing us to also use github, and the haskell coder to upload to github hackage and stackage. as if it wasn't difficult enough to try and explain why we use haskell, it is expected that a developer has to further explain these features of the haskell environment, and the lack of definitive answer to the stack vs cabal quest
04:28:37 <djtyml> Thank you very much c50a326,, I'll check out clojurescript.
04:28:53 <c50a326> djtyml: oh I was just spouting another option
04:29:04 <djtyml> yes?
04:29:20 <c50a326> djtyml: I don't have much experience at all across all those languages, I was just adding an entry, I don't know which will be best
04:30:03 <c50a326> djtyml: pretty sure cljs, elm and purescript all compile to js though so that should make them good options... spock is just a haskell web framework which is something different I believe... though I haven't used spock so i might be wrong
04:30:37 <djtyml> I see. It's all right. I'll check which one is easy enough for me to understand..haha
04:30:48 <cocreature> dataN: what? how does Haskell force you to use github? and if you are developing for a company, you probably don’t want to upload your packages to either hackage or stackage
04:30:57 <c50a326> djtyml: well none of those will be easy to understand compared with javascript... i heard elm is probably the easiest of the FP's though
04:31:41 <c50a326> cocreature: do you know the best practice for re-calling recv until there are no bytes left to be received?
04:31:58 <dataN> why are there 2 different tools? obviously it would be difficult to depreciate one, and there may be advantages to supporting two different approaches, but what are they? without knowing this, it would be easy to falter at the first stage of interview with a developer directing a recruiter to their libraries, and being unable to communicate clearly the current state of the haskell repos
04:32:21 <c50a326> in some example I am seeing `unless` used like: unless (S.null msg) $ ...
04:32:38 <dataN> cocreature: recruiters expect to see some visible open source contributions.
04:33:09 <cocreature> I still don’t see your point. how is that different from any other language?
04:33:20 <c50a326> ooo, unless is pretty interesting http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Monad.html#v:unless
04:33:33 <c50a326> :t unless
04:33:34 <lambdabot> Applicative f => Bool -> f () -> f ()
04:33:35 <cocreature> and stackage is not separate from hackage. it’s a subset of hackage with specific versions that are known to work together
04:34:52 <djtyml> c50a326: I see. I just want to show some route computation that I have done in haskell. So I guess Elm is the shortest path for me. Anyway, thanks for your opinion~
04:35:13 <dataN> cocreature: not all languages have their own maintained repositories and recruiters prefer to see the developer use github
04:36:18 <c50a326> dataN: pretty weird and twisted thing to latch on to, do you have mental problems?
04:36:41 <cocreature> dataN: you are confusing two different things. github is where you develop your code, hackage is a repository of released version. that’s no different from npm, ruby gems, crates.io, …
04:36:55 <dataN> haha, actually looking for a job trying to get a strong CV together
04:37:19 <c50a326> try to think of positives rather than negatives :D
04:38:07 <c50a326> are you saying that showing code that is on hackage or something won't be as impressive? :s
04:38:37 <dataN> cocreature: its not generally accepted to use cabal sandbox to develop in teams? i guess github private sharing would be advantageous there
04:39:05 <cocreature> dataN: cabal sandbox is not a version control system
04:39:15 <cocreature> you are mixing up more and more unrelated concepts :)
04:40:08 <dataN> c50a326: its more of a case of anticipating obvious confusion so it can be avoided at interview.
04:41:19 <dataN> cocreature: yes, thats why github would be helpful
04:42:54 <dataN> however, unless working collaboratively, such advanced version control is not always needed.
04:44:37 <dataN> anyway the question wasnt about github, it was that if asked - how can stack vs cabal be explained succinctly
04:46:37 * hackage tpdb 2.1.1 - Data Type for Rewriting Systems  http://hackage.haskell.org/package/tpdb-2.1.1 (JohannesWaldmann)
04:46:50 <dataN> the confusion here is that as well as being the industry standard version control system, github is also the common point of visibility of an indidual developers work, wheras we have hackage
04:47:10 <cocreature> hackage does in no way replace hackage
04:47:15 <cocreature> *replace github
04:47:40 <cocreature> most packages on hackage are being developed on github
04:48:40 <c50a326> w00t, I made a program that listens on a port and then appends the bytes to a file if I netcat and write something to the socket :D
04:48:51 <dataN> but its where you can see a developers code, most packages on hackage are built in collaboration
04:49:37 * hackage hpack 0.29.3 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.29.3 (SimonHengel)
04:50:32 <c50a326> hmmm netcat is sending a null byte when I press return I guess?!~
04:51:05 <dataN> so, aside from indicating that a developer is the sole contributor to all their publicly available projects, how can the existence of stack be explained to a curious outsider?
04:51:45 <c50a326> https://ptpb.pw/cr_y/hs this is the program, I guess I should write a client in haskell also, netcat might be doing funny things
04:52:15 <c50a326> but I was expecting this to stay open and accept carriage returns... well it does write a carriage return but netcat also exits so the socket is closed for some reason when I send return through netcat
04:52:24 <cocreature> I have no idea why you are tying stack’s existence to the fact that someone is the sole contributor but the main difference between stack and cabal is that cabal uses constraint solving to figure out package versions whereas stackage uses version pinning
04:53:20 <dataN> sorry, that was not to imply that stack would only be used when github isnt, but where github serves ONLY as a way to direct a recruiter to hackage and/or stackage, it certainly invites the question about the interplay between these tools.
04:55:21 <dataN> cocreature: thanks, that certainly explains why one has not replaced the other...
04:56:44 <cocreature> the difference is really far less important than some of the heated discussions might make it seem
05:00:07 * hackage invariant 0.5.1 - Haskell98 invariant functors  http://hackage.haskell.org/package/invariant-0.5.1 (ryanglscott)
05:00:24 <dataN> it does form part of the considerations pertinent to the uphill struggle of haskell becoming the global programming industry leading standard.
05:02:14 <c50a326> how can you waste such time on such airy nonsense lol
05:07:43 * dstolfa never got stack to work and has given up
05:07:49 * dstolfa uses cabal
05:08:59 <dstolfa> most complaints i get about haskell is the terrible tooling compared to other languages
05:09:19 <dstolfa> these are people who don't mind the language itself, just get pissed at dependency hells and things magically stopping to work after an update
05:09:38 <dstolfa> compare that to say, opam, it's never happened to me
05:09:49 <dstolfa> eventhough i personally prefer haskell
05:38:07 * hackage dejafu 1.11.0.3 - A library for unit-testing concurrent programs.  http://hackage.haskell.org/package/dejafu-1.11.0.3 (barrucadu)
05:41:36 <zincy> Why doesn't this work :    True || True || True
05:41:55 <zincy> Do I need brackets
05:42:51 <Lears> > True || True || True
05:42:53 <lambdabot>  True
05:43:10 <zincy> Oh I was confused by another error
05:43:18 <zincy> Thanks :)
05:43:20 <dstolfa> > True || (True || False) || True && False
05:43:22 <lambdabot>  True
06:21:36 <joel135> Hello, I want to make a tiny graphical and interactive math application.
06:22:18 <JuanDaugherty> please state the nature of the haskell newbie emergency
06:24:37 <hpc> heh
06:25:16 <hpc> joel135: describe the problem you're having and post any relevant code
06:25:17 <hpc> @lpaste
06:25:17 <lambdabot> Haskell pastebin: http://lpaste.net/
06:25:22 <joel135> I have a function f : C -> C -> RGB where C is some floating point complex number type and RGB is some color type. I want a canvas with mouse events and whose pixels are associated to C such that when the user presses w the canvas will be filled according to f w.
06:25:41 <joel135> I am just wondering what library to use.
06:26:33 <hpc> sounds like JuicyPixels for the image manipulation part of it
06:27:06 <joel135> ok
06:27:21 <hpc> for putting it in a window, what you need i think depends on what else you need the window to do?
06:27:39 <hpc> if you literally don't need anything else, i would personally use sdl because i am familiar with it
06:27:47 <hpc> but that might be annoying to install if eg, you're on windows
06:27:53 <hpc> er, sdl2
06:28:14 <hpc> otherwise if you need menus and a proper desktop gui, i don't know
06:28:18 <joel135> i'm on linux
06:28:24 <hpc> ah cool
06:38:39 <joel135> i get this from cabal https://lpaste.net/3754078502224134144
06:38:52 <joel135> maybe i should install from source
06:41:43 <hpc> it wants sdl2 in pkg-config
06:41:50 <hpc> which means sdl2 itself?
06:42:11 <joel135> ooh i see
06:42:57 <joel135> yes, now it seems to install properly
06:45:51 <joel135> "building kan-extensions" :P
06:49:16 <hpc> oh hah, right
06:49:20 <hpc> http://hackage.haskell.org/package/sdl2-2.4.0.1/docs/SDL-Vect.html
06:49:30 <hpc> pulls in the linear package, which pulls in lens, which pulls in everything
06:50:12 <hpc> but you get all sorts of nice linear algebra primitives that are totally useless for your problem :D
06:53:08 * JuanDaugherty lols (kan extensions vs tiny)
06:53:28 <joel135> xD
07:08:15 <mniip> [exa], funny, in colloquial speech in russian everyone refers to the Г on the lhs of the turnstile as the cyrillic Ghe rather than greek Gamma
07:10:23 <lantti> refers to roughly the same sound anyway
07:22:19 <mpickering> If I want to write some image processing algorithms, am I better off using repa, accelerate or friday?
07:27:06 <Athas> mpickering: Accelerate is the only one of those that is being actively maintained.
07:27:55 <mpickering> friday looks like I would have to do the least work myself
07:28:28 <Athas> Right.  If friday works, it's probably best.
07:28:37 <Athas> But Haskell moves fast and it was last updated in 2016...
07:29:08 <obiwahn> Is there a channel dedicated to stack?
07:29:23 <mpickering> I want to do some experiments to see how fast they are compared to a rust implementation of some algorithms
07:29:59 <Athas> I'd expect Accelerate on GPU to perform quite well.
07:30:07 <sm> obiwahn: #haskell-stack
07:30:16 <Athas> Repa can be pretty fast too, but I find it hard to use.
07:30:17 <asheshambasta> obiwahn: there's a #haskell-stack
07:30:30 <obiwahn> just joined there, thank you sm and asheshambasta
07:30:30 <mpickering> Because it seems that people doing geoinformatics are not using things like SIMD like opencv
07:38:25 <rotaerk> geekosaur, if I pass -optl-somethingwrong to ghci, and then run my program, it says that -somethingwrong is an unrecognized command line option
07:38:35 <rotaerk> only that error message is prefixed with gcc:
07:38:43 <rotaerk> is gcc itself being used as the linker?
07:39:09 <cocreature> rotaerk: at least on linux that’s the default
07:39:26 <hpc> not ld directly?
07:39:30 <rotaerk> I just figured ld would be used
07:39:52 <cocreature> gcc will then call ld
07:40:08 <cocreature> (or gold or lld
07:40:10 <cocreature> )
07:40:28 <hpc> do you know why it goes through gcc?
07:40:39 <cocreature> dunno
07:41:01 <hpc> hmm
07:41:07 <hpc> maybe there's some sort of FFI reason for it
07:41:20 <rotaerk> so if I want to ACTUALLY pass something to the linker, I guess I need to do:  -optl-Xlinker
07:41:24 <hpc> like if you call the linker through gcc you know it's always going to link with c code
07:48:16 <joel135> how to convert CInt <-> Double?
07:49:07 * hackage infer-license 0.2.0 - Infer software license from a given license file  http://hackage.haskell.org/package/infer-license-0.2.0 (SimonHengel)
07:49:08 <cocreature> joel135: for CInt -> Double you can use fromIntegral
07:49:20 <cocreature> for the other directions, you first need to decide what kind of conversion you want
07:49:25 <cocreature> truncate, round, …
07:49:58 <joel135> ok thanks!
07:50:13 <rotaerk> hrm what am I doing wrong here:  ghci -optl '-Xlinker -help' src/Main.hs
07:50:33 <rotaerk> gcc complains that '-Xlinker -help' is not a valid option, and asks if I meant '-Xlinker'
07:50:48 <rotaerk> as though it doesn't acknowledge that I'm passing an argument to that flag
07:51:22 <cocreature> sounds like gcc is receiving this as a single argument but expects two arguments
07:51:33 <cocreature> try something like ghci -optl -Xlinker -optl -help src/Main.hs
07:52:12 <rotaerk> ahh thanks
07:54:00 <droplet> I'm getting the cabal error "Unrecognised stanza on line 16", and line 16 reads repository hackage.haskell.org, and seems to be exactly what's specified in the cabal documentation - how can I fix?
07:54:45 <rotaerk> bleh, passing -rpath, --enable/disable-new-dtags to the linker has 0 impact on it
07:54:59 <rotaerk> s/,/ or/
08:03:35 <rotaerk> ghci seems to ignore the -dynload flag
08:05:14 <rotaerk> oh... yeah, dynload shows up in ghc --show-options, but not in ghci --show-options
08:07:42 <sclv> droplet: what  version of cabal?
08:08:22 <c50a326> blah how do I use forever? this is what I've tried https://ptpb.pw/Ixhh/hs
08:08:54 <rotaerk> any idea why GHCI seems to use -dynload sysdep, without the ability to override it?
08:09:34 <cocreature> c50a326: don’t make us guess what the error with your current code sample is :)
08:10:15 <c50a326> error: parse error on input ‘msg’
08:10:25 <c50a326> if I remove the forever $, there's no such error
08:11:00 <cocreature> there is no "forever $" in your code
08:11:11 <cocreature> try reducing the indentation of "where"
08:11:12 <geekosaur> rotaerk, hpc, cocreature: so itat ghc doesn't need to know what magic is needed to link C programs
08:11:25 <c50a326> oh yeah
08:11:31 <c50a326> sorry that was a different version
08:11:55 <c50a326> cocreature: reducing? at the moment it's only indented to 2 spaces in
08:12:06 <mniip> rotaerk, it's totally overrideable
08:12:55 <rotaerk> well if I pass it -dynload deploy, it doesn't complain, it just doesn't ... change the behavior
08:13:21 <cocreature> c50a326: the "where" belongs to the definition of "listenerLoop" not to the call to forever
08:13:25 <rotaerk> it still tries to link in the library that WOULD go into the RUNPATH (if it were actually compiling a binary), and ignores what's in LD_LIBRARY_PATH
08:13:30 <cocreature> c50a326: and relative to that it’s indented by 4 spaces
08:13:52 <rotaerk> basically if I want ghci to work again, I need to either get it to use LD_LIBRARY_PATH to lookup libraries, or I need to figure out why the libGL pointed to by RUNPATH doesn't work
08:13:55 <c50a326> oic
08:14:21 <mniip> % readFile "/proc/self/cmdline"
08:14:21 <yahb> mniip: "/var/lib/xsbot/sandbox/root/usr/lib/ghc-8.6.0.20180620/bin/ghc\NUL-B/var/lib/xsbot/sandbox/root/usr/lib/ghc-8.6.0.20180620\NUL-dynload\NULdeploy\NUL--interactive\NUL-v0\NUL-ghci-script\NUL/var/lib/xsbot/sandbox/root/usr/runghci/init\NUL-tmpdir\NUL/var/lib/xsbot/sandbox/root/data/ghci/\NUL-odir\NUL/var/lib/xsbot/sandbox/root/data/ghci/\NUL-hidir\NUL/var/lib/xsbot/sandbox/root/data/ghci/\NUL-ignore
08:14:28 <mniip> see the "dynload deploy"
08:16:46 <rotaerk> I don't know what that tells me
08:16:57 <rotaerk> not familiar with /proc/self/cmdline
08:17:19 <glguy> mniip: Has yahb always allowed reading from proc?
08:17:21 <mniip> oh that's the ghci process used by yahb
08:17:27 <mniip> glguy, just the /proc/self
08:17:39 <rotaerk> here's a write-up of my problem https://discourse.nixos.org/t/libgl-undefined-symbol-glxgl-core-functions/512/3
08:17:57 <rotaerk> https://discourse.nixos.org/t/libgl-undefined-symbol-glxgl-core-functions/512
08:18:00 <mniip> rotaerk, are you sure LD_LIBRARY_PATH actually points to the libgl?
08:18:03 <rotaerk> not sure how that 3 got in at the end
08:18:09 <glguy> Ah, that's what I should have tried. I was trying to look in proc to figure out the path to GHCi yesterday to help dmwit :)
08:18:35 <rotaerk> mniip, yeah
08:19:12 <rotaerk> it works if I cabal build, which produces a binary containing RUNPATH, which is overridden by LD_LIBRARY_PATH, which contains:  /run/opengl-driver/lib:/run/opengl-driver-32/lib:/nix/store/fkgjdl6h5xpmba6449ikhfzrlq96lm2x-vulkan-validation-layers-1.1.77.0/lib
08:19:31 <mniip> %%! cat ../usr/runghci/runghci # glguy
08:19:32 <yahb> mniip: http://qp.mniip.com/y/81
08:20:27 <c50a326> I need to open a socket and open a file and keep them both open and read from the socket and write to the file until the socket is closed. Should I use bracket or what?
08:20:41 <Myrl-saki> I was curious about how RSA is unbreakable despite primes getting scarcer as the value gets larger.
08:20:46 <Myrl-saki> And
08:20:48 <Myrl-saki> > let log 0 = -1; log x = 1 + log (x `div` 10); pi x = x `div` log x; in pi $ 2^2000
08:20:50 <lambdabot>  1907193845970522465503045184680534857179929737688862459265187270474694786366...
08:21:00 <rotaerk> mniip, but if I readelf -d my cabal-built binary, the RUNPATH contains a bunch of paths including: /nix/store/bmlp2ppjxxfsd15fgh1jw44l17p4iw6a-libGL-1.0.0/lib
08:21:10 <rotaerk> and THAT is the one it's trying to use from ghci
08:21:40 <c50a326> I was thinking of having a function, getSockH :: IO Socket, and a function getFileH :: IO Handle
08:22:04 <Myrl-saki> > let log 0 = -1; log x = 1 + log (x `div` 10); pi x = x `div` log x; in log $ pi $ 2^2000
08:22:06 <lambdabot>  599
08:22:10 <c50a326> and then another function :: IO Socket -> IO Handle -> IO ()
08:22:36 <Myrl-saki> There's 10^600 primes less than 2^2000, assuming RSA-4096
08:23:07 <c50a326> to handle reading from the socket and writing to the file... but I guess I need to use something to clean up when the socket is closed and also other circumstances
08:23:35 <ab9rf> Myrl-saki: shouldn't take that long to test all of them
08:23:41 <Myrl-saki> ab9rf: Ikr.
08:24:31 <rotaerk> mniip, if I LD_DEBUG=libs and then run my cabal-built binary, it shows that it used the LD_LIBRARY_PATH search path, and that it used the one under /run/opengl-driver/lib
08:25:15 <mniip> Myrl-saki, how does scarcity of primes affect security...
08:25:48 <Myrl-saki> mniip: I'm just assuming brute forcing it.
08:25:52 <Myrl-saki> mniip: Think diminshing returns.
08:26:09 <mniip> brute forcing all the primes?
08:26:26 <Myrl-saki> mniip: Someone asked me "why is RSA secure when it's easy to generate primes?"
08:26:27 <mniip> good luck knowing what they are, first
08:26:55 <mniip> to my knowledge we use indeterministic algorithms to generate large primes
08:27:07 <rotaerk> hmm interesting... if I:  LD_DEBUG=libs ghci -dynload deploy src/Main.hs 2> ghci.ld
08:27:44 <rotaerk> it does show it searching for libGL.so.1 in the LD_LIBRARY_PATH
08:28:07 <rotaerk> but it still ends up somehow pulling in the one from RUNPATH later on
08:28:48 <rotaerk> https://ptpb.pw/bgT2
08:29:40 <rotaerk> if you search for "library=libGL.so" you see where it finds it via LD_LIBRARY_PATH, but then if you search for "error", you see where it's throwing an error while trying to use a different libGL
08:29:47 <rotaerk> I don't know what mechanism is causing that
08:29:55 <mniip> ah right, the AKS test with running time ~ (log n)^6
08:30:30 <rotaerk> my only guess is it has something to do with the init of GLFW immediately before the error
08:35:15 <Myrl-saki> I wonder where merijn has been.
08:40:03 <c50a326> hey can bracket be used with multiple resources?
08:40:16 <c50a326> I'm doing something with a file and a socket
08:41:54 <cocreature> you can nest two uses of bracket
08:45:16 <rotaerk> file=/nix/store/bmlp2ppjxxfsd15fgh1jw44l17p4iw6a-libGL-1.0.0/lib/libGL.so [0];  dynamically loaded by /nix/store/j7cmnm48p0vmp6dqmnal7x1dhczwim3b-ghc-8.2.2/lib/ghc-8.2.2/bin/../rts/libHSrts_thr-ghc8.2.2.so [0]
08:45:35 <rotaerk> wonder why it did that... that's the first mention of the file in the ld output
08:45:50 <rotaerk> it doesn't show it discovering that file via search paths
08:46:07 * hackage hpack 0.29.4 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.29.4 (SimonHengel)
08:47:14 <rotaerk> at least this tells me that it's the RTS loader doing it
08:56:43 <rotaerk> where the heck are the RTS options documented
08:57:59 <cocreature> rotaerk: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html
08:59:13 <rotaerk> weird, I did a search of 'RTS' within the user guide and it didn't lead me to that
09:00:25 <monochrom> But the RTS options don't have parameters for dynamic loading.
09:01:22 <rotaerk> yeah, doesn't look like it
09:02:14 <rotaerk> bleh, doesn't seem to be a way to get it NOT to use that libGL version; I'll just have to figure out why that error happens with that version of libGL
09:09:17 <rotaerk> oh, bindings-GLFW are causing it, I think; they're explicitly calling dlopen
09:10:29 <rotaerk> is * it's *
09:33:35 <rotaerk> nm; has nothing to do with that dlopen
09:40:07 <rotaerk> hurr, looks like runghc also has the same problem
09:43:26 <cocreature> runghc and ghci are fairly similar
10:12:53 <droplet> sclv: version 2.2.0.0
10:14:46 <Berra> I'm using turtle - is there some preferred way to bracket procs and Shells?
10:16:37 * hackage stratosphere 0.24.3 - EDSL for AWS CloudFormation  http://hackage.haskell.org/package/stratosphere-0.24.3 (jdreaver)
10:20:32 <cocreature> Berra: probably MonadManaged
10:20:38 <cocreature> if I understand your question correctly
10:22:02 <sclv> droplet: which os?
10:23:10 <Berra> cocreature: Yeah I need to look closer into how I utilize it
10:25:04 <sclv> if you really force a fresh config file that error should basically never happen
10:31:06 <cocreature> Berra: the builtin stuff should be overloaded so you don’t have to do anything special. if you have some custom resource, you can build a managed value using "managed" and use it with "using"
10:32:21 <Berra> cocreature: My specific case is that I want to run one setup command - run application code - then run final proc command using turtle to tear down.
10:33:00 <Berra> I Just want `finally` but for a shell
10:33:12 <droplet> sclv: macos
10:34:43 <sclv> droplet: so your cabal config file is in ~/.cabal/config
10:34:52 <sclv> did you try just renaming that one to force a new one to be generated?
10:35:10 <cocreature> Berra: Shell is an instance of MonadMask so you should be able to use https://hackage.haskell.org/package/exceptions-0.10.0/docs/Control-Monad-Catch.html#v:finally
10:36:31 <butterthebuddha> sequence $ replicate n get
10:36:48 <butterthebuddha> ^ Will that run the state function inside the State monad n times and give me the results in a list?
10:37:27 <Berra> cocreature: Hmm hmm - I see. Trying that.
10:38:47 <Berra> cocreature: It appears that Shell does not have an MonadMask instance?
10:39:07 <cocreature> Berra: oh indeed, sry. I misread the instance list
10:42:31 <cocreature> Berra: do you need to run your finalizer in Shell or does that only need to use IO?
10:43:13 <Berra> cocreature: It would preferable since otherwise I need to thread filepath information back - but yeah I could do it like that
10:43:37 * hackage SDL 0.6.7.0 - Binding to libSDL  http://hackage.haskell.org/package/SDL-0.6.7.0 (fffaaa)
10:44:00 <Berra> cocreature: I'm trying that now
10:44:22 <cocreature> Berra: something like "\finalizer -> using (managed_ (`finally` finalizer))" might work
10:44:28 <butterthebuddha> Nvm, I was confused. What I really want to do is bind a State monad to itself n times and collect the "results" of each in a list
10:45:05 <Berra> cocreature: Hmm - ok let me try that up next
10:45:47 <cocreature> Berra: I don’t think MonadManaged is sufficient if you want your finalizer to not live in IO. but depending on your code you might be able to just use "sh" on the finalizer to go from Shell a to IO a
10:46:40 <Berra> cocreature: sh :: Shell a ->  io () not a problem?
10:46:53 <Berra> cocreature: Ah the fold
10:50:13 <droplet> sclv: Yup, and the new one has the same problem
10:52:37 * hackage SDL-gfx 0.6.1.0 - Binding to libSDL_gfx  http://hackage.haskell.org/package/SDL-gfx-0.6.1.0 (fffaaa)
10:55:37 * hackage SDL-image 0.6.2.0 - Binding to libSDL_image  http://hackage.haskell.org/package/SDL-image-0.6.2.0 (fffaaa)
10:57:37 * hackage gtk-sni-tray 0.1.5.0 - A standalone StatusNotifierItem/AppIndicator tray  http://hackage.haskell.org/package/gtk-sni-tray-0.1.5.0 (eyevanmalicesun)
10:58:37 * hackage SDL-mixer 0.6.3.0 - Binding to libSDL_mixer  http://hackage.haskell.org/package/SDL-mixer-0.6.3.0 (fffaaa)
11:00:07 * hackage SDL-ttf 0.6.3.0 - Binding to libSDL_ttf  http://hackage.haskell.org/package/SDL-ttf-0.6.3.0 (fffaaa)
11:06:02 <f-a> hello. I am getting a build failure of a package I am maintaining on hackage
11:06:05 <f-a> https://hackage.haskell.org/package/SDL-gfx-0.6.1.0/reports/1
11:06:09 <f-a> configure: error: *** SDL_gfx lib not found! Get SDL_gfx from
11:06:22 <f-a> what is the correct way to handle this? just ignore build failures?
11:06:41 <geekosaur> yes. the hackage buildbot doesn;t have and isn't going to have every C / C++ dependency installed
11:06:55 <geekosaur> you probably want ot generate docs locally and upload them
11:07:03 <f-a> roger that
11:07:08 <geekosaur> (cabal haddock --for-hackage, iirc)
11:12:36 <sclv> droplet: can you paste the full error. this is bizarre
11:14:39 <sclv> droplet: here are two different repo lines that should both work!? https://lpaste.net/4932707430501974016
11:21:07 * hackage keccak 0.1.1 - haskell keccak functions  http://hackage.haskell.org/package/keccak-0.1.1 (aupiff)
11:24:50 <f-a> thanks geekosaur ( for everyone reading the logs, at least for new-build, the option is --haddock-for-hackage )
11:24:59 <wuffie> what would the type of a function using both Reader and IO look like?
11:25:14 <wuffie> or is that the wrong question to ask
11:25:20 <f-a> wuffie: are you thinking or ReaderT (the transformer?)
11:25:32 <wuffie> maybe?
11:25:37 <geekosaur> wuffie, depending on what you are doing, I suspect ReaderT e IO for whaever environment e you are using
11:25:39 <wuffie> im not well versed on how reader works
11:25:57 <f-a> wuffie: reader is (conceptually) just an enviroment parameter
11:26:08 <f-a> imagine someFun :: Env -> IO ()
11:26:24 <f-a> where `Env` is your environment
11:26:56 <f-a> Reader and ReaderT are the monad and monad-transformer which (among other things) alleviate the pain of passing that damn parameter every call
11:27:00 <wuffie> i could instead use someFun :: ReaderT Env IO ()
11:27:02 <wuffie> right?
11:27:10 <f-a> so the Read- yeah
11:27:17 <f-a> yes exactly
11:27:32 <wuffie> maybe that was the wrong question to ask then
11:27:39 <f-a> it is : someFun :: ReaderT Env IO
11:27:41 <f-a> without the ()
11:28:25 <geekosaur> no, that's kind * -> *
11:28:52 <wuffie> am i supposed to apply liftIO to all io related actions inside of such a function?
11:29:10 <f-a> oh, sorry, yeah geekosaur is correct
11:29:15 <geekosaur> unless they have MonadIO instances, in whicch case they lift themselves
11:29:38 <wuffie> id assume stuff like copyFile doesnt then
11:29:40 <c50a326> is anyone here using haskell-ide-engine in (neo)vim?
11:29:51 <rotaerk> :t ((x :: ReaderT Env IO a) >>=)
11:29:52 <lambdabot> error:
11:29:52 <lambdabot>     Not in scope: type constructor or class ‘Env’
11:29:58 <rotaerk> :t ((x :: ReaderT e IO a) >>=)
11:29:59 <lambdabot> error:
11:29:59 <lambdabot>     • Couldn't match expected type ‘ReaderT e1 IO a1’
11:29:59 <lambdabot>                   with actual type ‘Expr’
11:30:24 <rotaerk> err whoops
11:30:51 <rotaerk> :t \(x :: ReaderT e IO a) -> (x >>=)
11:30:52 <lambdabot> ReaderT e IO a -> (a -> ReaderT e IO b) -> ReaderT e IO b
11:31:52 <rotaerk> wuffie, note that when you bind it, your function must return a ReaderT e IO b, so yes, you must lift that IO x into that type first
11:33:08 <rotaerk> you can do it with lift in this case, since the IO is only one level deep in the monad transformer stack
11:33:43 <rotaerk> but liftIO is more common since it will handles picking the right number of lifts for an arbitrary transformer stack
11:33:47 <rotaerk> will handle *
11:37:42 <wuffie> im in a very strange situation where mapM_ is expecting a and not [a] and its within a function of type ReaderT e IO ()
11:38:28 <monochrom> Show actual code and actual error message and enough code and instruction for reproduction of the error.
11:38:30 <wuffie> i could pastebin it, but its kind of messy due to a lot of rewriting for readert
11:38:31 <f-a> you probably goofed the function
11:38:33 <wuffie> alright
11:38:41 <f-a> wuffie: put a _ where the function should go
11:38:50 <f-a> see what ghci suggests
11:40:00 <blackandblue> edwardk, hi
11:41:49 <wuffie> am i supposed to always use ReaderT?
11:41:57 <wuffie> in what situations do i use Reader as opposed to ReaderT
11:42:03 <monochrom> But these days mapM_ is more general than list.  So it's going to say "a, with Foldable a" rather than "[a]".
11:42:22 <monochrom> Hmm is it Foldable? Traversable?
11:42:27 <f-a> wuffie: readerT is a transformer
11:42:43 <f-a> so you can combine it with other monads (in your case, IO)
11:42:58 <f-a> when you need Reader but not IO, just use Reader e a
11:50:18 <infinisil>   liftIO i = NixpkgsT $ lift $ lift $ liftIO i
11:50:22 <infinisil> Am I doing this right lol
11:52:18 <wuffie> am i still supposed to bind the results of a function applied to liftIO?
11:52:23 <wuffie> or do i use let
11:52:31 <haasn> :t liftIO
11:52:33 <lambdabot> MonadIO m => IO a -> m a
11:52:40 <haasn> it still results in a monadic action
11:52:52 <haasn> so you need to bind it if you want to get access to the 'a'
11:53:54 <wuffie> oh i think i might have figured it out
11:54:26 <wuffie> im probably supposed to do filterM (\a -> liftIO a)
11:54:31 <wuffie> instead of liftIO $ filterM ...
11:54:52 <haasn> :t filterM
11:54:53 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
11:55:24 <haasn> :t \f -> liftIO . filterM f
11:55:25 <lambdabot> MonadIO m => (a -> IO Bool) -> [a] -> m [a]
11:55:36 <haasn> :t \f -> filterM (liftIO . f)
11:55:37 <lambdabot> MonadIO m => (a -> IO Bool) -> [a] -> m [a]
11:55:45 <haasn> ^ it doesn't matter which way you do it
11:55:47 <wuffie> oh
11:55:51 <haasn> pretty sure some law of liftIO implies that
11:56:03 <haasn> or some monad transformer law
11:56:35 <haasn> which I think states somewhere that lift a >>= lift . f is the same as lift (a >>= f)
11:57:43 <haasn> yeah that's a literal law of MonadTrans
11:58:51 <wuffie> within a function of type ReaderT e IO () how would i bind to a function of type Reader e
11:59:44 <haasn> that's more difficult, since you're trying to change the monad *base* from Identity to IO
12:00:00 <haasn> it would be easier to extract the 'e' from your ReaderT and manually pass this to the Reader e
12:00:17 <f-a> wuffie: do you happen to have it in (e -> ()) form too?
12:00:51 <haasn> :t \a -> ask >>= runReader a
12:00:52 <lambdabot> MonadReader r m => Reader r (m b) -> m b
12:01:29 <wuffie> the function i want to bind to is of type Reader e [a]
12:01:38 <haasn> or, well, this plus something else to *do* with the result of runReader
12:03:04 <haasn> :t hoist (return . runIdentity)
12:03:05 <lambdabot> error:
12:03:05 <lambdabot>     Variable not in scope: hoist :: (Identity a0 -> m0 a0) -> t
12:04:21 <wuffie> this is starting to sound really complex
12:04:54 <f-a> :t runReader
12:04:55 <lambdabot> Reader r a -> r -> a
12:05:14 <haasn> It doesn't have to be. The In general monad transformers get messy when your actions are not al of the same monad transformer stack type
12:05:49 <wuffie> maybe its a matter of better sorting out my code
12:06:09 <haasn> Perhaps you can rewrite the Reader function to be abstract in MonadReader m instead
12:06:14 <wuffie> id just like to perform IO actions when i need to but there are some things that require the use of the env without IO
12:06:28 <haasn> That way you could use it as either Reader e a or ReaderT e IO a
12:06:45 <haasn> The `mtl` library is dedicated to solving this problem
12:06:56 <haasn> :t ask
12:06:57 <lambdabot> MonadReader r m => m r
12:07:00 <haasn> :t modify
12:07:01 <lambdabot> MonadState s m => (s -> s) -> m ()
12:13:17 <glguy> wuffie: Minor point: things with types (ReaderT e IO ()) and (Reader e ()) aren't functions, though they happen to be implemented in terms of them
12:15:24 <wuffie> oh i think i understand
12:15:37 <wuffie> would i be using runReader from within the ReaderT e IO () function then?
12:16:06 <wuffie> in order to get the values of non-IO Reader e functions
12:16:36 <glguy> I don't know what "from within" means, but you can use 'runReader' to turn a value with type (ReaderT e m a) into a function
12:17:20 <f-a> glguy: you are talking about runReaderT, he is talking about the non-transformer version
12:17:45 <wuffie> i want to make use of a persistant environment in a function that uses functions that use that environment and may or may not also use IO
12:17:53 <glguy> yeah, I should have used the 'T' version in both or neither places
12:18:05 <glguy> but in either case ReaaderT e m a and Reader e a are not functions
12:18:43 <f-a> glguy: I was just trying to point what (I think) wuffie meant wit "from within"
12:19:09 <f-a> wuffie: in general a good idea is to make every function that can be pure pure
12:19:23 <f-a> and then sandwich IO outside of it, when needed
12:19:31 <wuffie> yeah, all functions that make use of the env are of type Reader e
12:19:51 <wuffie> and all functions that make use of IO and the env are of type ReaderT e IO
12:19:51 <glguy> functions never have the type (Reader e)
12:20:59 <haasn> wuffie: it still seems to me as though abstracting over MonadReader would be the easiest for you, then you wouldn't hae to worry about making them compatible - they already are
12:21:10 <glguy> 'ask' is already generalized. You don't have to involve mtl
12:21:24 <glguy> ask :: ReaderT e m a -- m could be IO or Identity
12:21:37 <haasn> That too
12:21:59 <glguy> type Reader e = ReaderT e Identity    -- Reader is already a synonym for ReaderT with Identity
12:22:05 <haasn> but MonadReader may help if you plan to add more monad transformers in the future
12:22:34 <glguy> If you're going to make things more complicated in the future it would be better not to rely on mtl typeclasses but to make typeclasses specific to the problem you're solving
12:23:25 <haasn> In either case, solving this problem is probably as easy as changing a type signature
12:23:47 <haasn> I'm guessing you have :: Reader e a in your type signatures somwhere
12:23:52 <wuffie> yeah
12:24:07 <wuffie> i could technically replace them all with ReaderT e IO
12:24:08 <haasn> if you change that to :: Monad m => ReaderT e m a  as glguy suggested, it would be more general
12:24:09 <wuffie> a
12:24:14 <wuffie> oh i see
12:24:16 <haasn> And also allow using it in contexts without IO
12:24:27 <haasn> Since as glguy pointed out, Reader is just a synonym for ReaderT e Identity a
12:24:32 <haasn> Reader e a is*
12:24:35 <wuffie> ok i think im starting to grok this
12:25:16 <haasn> (This particular method of polymorphism would work whether you're using `mtl` or `transformers`)
12:56:37 <wuffie> attempting to use ask within ReaderT e m a gives an error
12:57:03 <wuffie> actually i dont think its ask in specific
12:57:12 <wuffie> No instance for (Monad m) arising from a do statement
12:57:42 <wuffie> any sort of binding elicits a similar sort of complaint
12:58:27 <f-a> wuffie: you might want to post some code
12:58:38 <wuffie> alright
12:58:58 <wuffie> i might just put the code on github
13:08:50 <int-e> wuffie: well, you need m to be a monad, so if you have given an explicit type signature then you need a Monad m context like Monad m => ReaderT e m a... if you haven't then you may be running into the monomorphism restriction, if your function has no arguments.
13:18:53 <wuffie> https://github.com/wu4/steam-shortcut
13:19:32 <wuffie> main' is the function that makes use of those functions, located in main.hs
13:19:47 <wuffie> the ones that cause the errors are in Shortcut/Program.hs
13:21:16 <wuffie> i should have probably placed some comments to make the code easier to navigate
13:23:18 <wuffie> the code is very much not working in its current state and especially the code within main' is a mess
13:23:59 <wuffie> i had it all working sans ReaderT, passing the configuration as an argument, but i figured it would be a neat practice to try and integrate it since it would be convenient
13:24:31 <geekosaur> ok, yes, I see a bunch of uses of ReaderT ... m... without specifying a constraint on m
13:24:31 <haasn> wuffie: as int-e pointed out, you need `m` to be a Monad
13:24:38 <geekosaur> you must specify that constraint
13:24:48 <Boarders> Hi, if I am trying to do categories like this then how can I write this instance: https://lpaste.net/5393157847670325248
13:24:49 <wuffie> do i write uhhh
13:24:49 <f-a> wuffie: exePrograms :: Monad m => ProgramsFile -> ReaderT Config m [Program]
13:24:51 <f-a> 161
13:24:51 <geekosaur> it might also be wise to just use IO, unless you have good reason to believe it'll need to chaneg
13:24:52 <Boarders> do I need to use coerce?
13:25:14 <wuffie> well i dont think any of them make use of IO
13:25:51 <haasn> What I usually do in this sort of self-contained program is define a type SteamM = ReaderT e (StateT s (WhateverT IO))
13:26:00 <haasn> and then make every function, even utility functions, live in SteamM
13:26:06 <haasn> that reduces complexity long-term I've found
13:26:25 <haasn> you never know when you might want to add e.g. better error handling to your "isolated" functions
13:26:40 <wuffie> this is my first haskell related project, so im very unfamiliar with proper paradigms
13:26:55 <haasn> Well what I described is a popular but also very "un-functional" paradigm
13:27:01 <geekosaur> yes, was going to add that but then "I don't think any of them make use of". that said, you're still better off being more concrete, you gain nothing by being more generic there since it's app specific logic unlikely to be reusable as such
13:27:29 <geekosaur> basically, the time to be polymorphic is when something is likely to be reusable
13:27:50 <haasn> True, the original question made it seem like he needed to evaluate that utility function in a pure context somewhere
13:27:59 <haasn> Which is why the suggestion was made to make it polymorphic
13:28:17 <geekosaur> for app specific logic, it's better to use a fixed application monad stack in general, because you're likely to need it anyway as you add functionality
13:28:33 <geekosaur> so you can add it to the newtype for the app's stack
13:28:46 <fresheyeball> http://hackage.haskell.org/package/beam-core-0.7.2.2/docs/Database-Beam-Query.html
13:28:49 <wuffie> yeah it does kind of seem like less of a pain to just give everything the IO monad
13:28:56 <fresheyeball> Anyone see a way to do an insert and get the id back out?
13:29:08 <fresheyeball> so I can do another insert where the foriegn key is that id?
13:29:15 <haasn> But in retrospect I might have misinterpreted this: 21:05 <wuffie> id just like to perform IO actions when i need to but there are some things that require the use of the env without IO
13:29:58 <haasn> The "throw one big monad at the problem and make everything live in it" is basically how you write imperative code in haskell
13:30:00 <haasn> with all the caveats
13:30:15 <haasn> Like random functions being able to (unintentionally?) mutate your state at times you didn't expect them to
13:30:23 <haasn> And all the associated headaches of imperative programming
13:30:41 <haasn> So in that vain it might be a good idea to make your function polymorphic just to codify the assumption that it /won't/ perform IO
13:30:46 <haasn> s/vain/vein/
13:31:00 <wuffie> yeah, but im not sure how exactly to go about that
13:31:05 <wuffie> im not sure how monad instances work
13:31:09 <haasn> f-a:  gave you an example
13:31:39 <haasn> Polymorphism in haskell is generally done by replacing your concrete types by type variables and then adding constraints indicating what you need to be able to do with those values
13:31:47 <f-a> wuffie: if it is your first project, in my very humble opinion, just have an Env and pass it around
13:32:08 <haasn> in this case, the requirement that `m` is a Monad doesn't come directly from your code but rather from the fact that you use ReaderT e m as a monad
13:32:18 <haasn> And the Monad instance for ReaderT e m requires `Monad m` as well
13:32:55 <haasn> (I think you could even solve your type error by adding a Monad (ReaderT Config m) => constraint)
13:34:58 <Gurkenglas> Boarders, as far as I know, yes, coerce is the way to turn "newtype A = A { runA :: B }" into "forall f. f A -> f B"
13:35:12 <Gurkenglas> Boarders, if you like, you could go via Control.Lens.Equality
13:35:15 <f-a> wuffie: if you use `mtl` then you can write signatures like
13:35:15 <f-a> exePrograms :: MonadReader r => ProgramsFile -> r Config [Program]
13:35:35 <haasn> Gurkenglas: that statement is not even true
13:35:36 <f-a> which maybe better express what you have in mind?
13:35:42 <haasn> unsafeCoerce is the only way to satisfy that
13:35:53 <haasn> It's also undefined behavior, since that function lets you implement unsafePerformIO
13:36:13 <haasn> (and thereby break the universe)
13:37:23 <haasn> Consider: data F where Good :: Int -> F A; Bad :: Bool -> F B
13:37:24 <Gurkenglas> haasn, could be, that was only as far as I know. How would you implement unsafePerformIO using that?
13:37:35 <haasn> Or various related constructions involving type families
13:38:15 <Gurkenglas> Ah, I wasn't considering GADTs or type families. Can you do it vanilla?
13:38:38 <haasn> I don't think so
13:38:54 <Gurkenglas> Then I suppose there's a way to say what I said such that it's true
13:39:31 <Gurkenglas> Define a class C less restrictive than functor such that newtypes give us exactly forall f. C f => f A -> f B
13:40:17 <Gurkenglas> Similar to the Data class, maybe
13:40:53 <haasn> well coerce :: forall f. Coercible (f a) (f b) => f a -> f b
13:41:08 <haasn> s/a/A/g s/b/B/g
13:41:28 <nshepperd_> forall f. (ArgumentIsRepresentational f) => f a -> f b
13:41:59 <haasn> and that is only inhabited if `f`'s type parameter has the type role representational
13:42:15 <haasn> nshepperd_: does that exist in GHC, or did you make that up?
13:42:35 <nshepperd_> It's not a thing as far as i know
13:43:18 <haasn> Gurkenglas: You can have Data instances on non-representational things such as GADTs
13:43:21 <haasn> I'm relatively sure
13:43:26 <haasn> Data just encodes the structure of the constructors
13:43:46 <wuffie> oh ok now i actually get it
13:44:06 <wuffie> i need to make use of constraints to avoid too much ambiguity
13:44:26 <Gurkenglas> So Boarders, fmap' = (coerce :: cat3 (f (g a)) (f (g b)) -> cat3 (Comp f g a) (Comp f g b)) . fmap' . fmap'
13:44:54 <f-a> wuffie: yep
13:45:31 <Gurkenglas> (And if that requires constraints, you'll need them.)
13:46:26 <haasn> FWIW I don't think my GADT is enough to break it, you probably need a cleverer construction
13:46:35 <Gurkenglas> And if that annoys you, I've enjoyed that Coq seems to actually let you have arbitrary polymorphic functions at type level
13:47:47 <haasn> But that being said I thought of a way you can definitely break unsafeCoerce even with a weaker extension: existentials
13:48:30 <haasn> consider data HasDict a = Num a => StoresDict
13:48:48 <Boarders> Gurkenglas: Thanks, though GHC was super unhappy with that
13:48:51 <haasn> your type would let me coerce HasDict A to HasDict B
13:49:01 <Boarders> I'll see if constraints helps me out
13:49:04 <haasn> and suddenly make my Num a constraint be treated as Num b instead
13:49:17 <haasn> with disastrous runtime consequences
13:49:55 <haasn> especially for dicts more maliciously cratfed than Num
13:49:57 <hpc> Gurkenglas: that's the whole point of dependent types ;)
13:52:52 <haasn> wuffie: It's not just about ambiguity, but also about actually needing to do things
13:53:16 <haasn> I mean a function :: a -> a is completely ambiguous about what `a` is, but that's also therefore a boring function since it can't really do anything interesting with `a` other than returning it (or crashing)
13:53:38 <haasn> Adding a constraint like :: Num a => to the mix suddenly lets you implement infinitely many interesting functions
13:53:54 <haasn> In your case, with the absence of a Monad m constraint you would be unable to combine your ReaderT actions at all
13:54:00 <Gurkenglas> Boarders, as in, I expect you want "Coercible (cat3 (f (g a)) (f (g b))) (cat3 (Comp f g a) (Comp f g b))" as a superclass of that Functor'
13:54:06 <wuffie> could i replace m with Monad?
13:54:12 <haasn> No, that's not how constraints work
13:54:15 <f-a> no
13:54:22 <haasn> The constraint specifies an attribute of the type `m`, it's not in itself a type
13:54:29 <haasn> (at least not superficially)
13:54:44 <f-a> wuffie: if you are not comfortable around type sig, keep it as simple as possible
13:54:52 <geekosaur> Monad is a constraint, not a type. "Monad m => ... m" means "some type m, provided it has a Monad instance". You can have other constraints as well
13:55:11 <Lears> :k Monad
13:55:13 <lambdabot> (* -> *) -> Constraint
13:56:03 <wuffie> ok, then would ReaderT e Monad m be functionally similar to Monad m => ReaderT e m?
13:56:07 * hackage decimal-arithmetic 0.5.1.0 - An implementation of the General Decimal ArithmeticSpecification  http://hackage.haskell.org/package/decimal-arithmetic-0.5.1.0 (RobLeslie)
13:56:17 <haasn> We just answered that question :[
13:56:21 <haasn> :p *
13:56:31 <wuffie> i meant Monad m as opposed to just m
13:56:35 <wuffie> er
13:56:40 <haasn> ReaderT e Monad would be a kind error
13:56:40 <wuffie> Monad m as opposed to Monad
13:56:48 <haasn> so would ReaderT e (Monad m)
13:56:56 <wuffie> is IO also a constraint?
13:56:59 <haasn> Constriants can only go on the left of =>
13:57:01 <haasn> Nope
13:57:09 <wuffie> oh ok, thats where my misunderstanding came from
13:57:18 <haasn> :k IO
13:57:19 <Lears> :k IO
13:57:20 <lambdabot> * -> *
13:57:20 <lambdabot> * -> *
13:57:23 <haasn> :k ReaderT
13:57:24 <lambdabot> * -> (k -> *) -> k -> *
13:57:26 <haasn> :k Constraint
13:57:27 <lambdabot> *
13:57:28 <haasn> err
13:57:33 <haasn> :k Monad
13:57:34 <lambdabot> (* -> *) -> Constraint
13:57:52 <haasn> See the conflict here? Monad produces a Constraint but on the right side of type signatures you're only dealing with stuff of form * or * -> * ...
13:58:42 <haasn> (Ignore the `k` in the signature of ReaderT, you can just read that as * instead for now)
13:59:33 <haasn> :k (=>)
13:59:35 <lambdabot> error: parse error on input ‘=>’
13:59:37 <haasn> aaw
13:59:50 <haasn> well it would be (=>) :: Constraint -> * -> *
14:00:04 <wuffie> im having trouble wrapping my head around the concept of (* -> *) -> Constraint being represented as Monad m =>
14:00:05 <haasn> (or something like that but more polymorpic)
14:00:23 <haasn> a `Constraint` is something that goes to the left of the =>
14:00:56 <haasn> This is all sort of advanced haskell anyway, in haskell98 the concept of a constraint kind isn't even something that exists
14:01:58 <haasn> It might be easier to ignore the kind of Monad and just focus on the relationship between type class instances and the => syntax
14:02:19 <haasn> It also might be easier to forget Monad for the time being and focus on a simpler class like Show or Num
14:02:49 <wuffie> :k Num
14:02:50 <lambdabot> * -> Constraint
14:02:55 <wuffie> ok that makes more sense
14:03:05 <haasn> `Num` is a class, `Num Int` is a class instance
14:03:17 <haasn> Constraints contain all the class instances that need to exist for your function to be able to work
14:03:53 <haasn> if I write f :: a -> a, all my function could do is give you your `a` back
14:04:22 <wuffie> to be clear, either and maybe are not classes, right?
14:04:29 <wuffie> theyre datatypes and those are separate
14:04:34 <hpc> correct
14:04:54 <haasn> if I write g :: Num a => a -> a, I could take your value and do stuff with it (negate it, multiply it by two, decide whether or not it's the answer to the universe, ...)
14:05:18 <haasn> This allows me more flexibility when writing my function but conversely allows you less flexibility when *using* my function
14:05:35 <wuffie> ok i see, so Num a => a -> a could be considered a more polymorphic version of Int -> Int
14:05:44 <wuffie> one that could take Integers
14:05:49 <haasn> Since for you to call my function `g` on a concrete type like `Bar`, the instance Num Bar must exist
14:05:58 <haasn> Yeah
14:06:31 <haasn> To further illustrate why e.g. `Num -> Num` can't really make much sense, you can have multiple constraints on the same thing
14:06:43 <haasn> e.g. foo :: (Show a, Num a, Ord a)
14:06:59 <haasn> e.g. foo :: (Show a, Num a, Ord a) => a -> String
14:07:37 <haasn> Now when calling this for a particular `a` like Bar, *all* of these constraints much exist
14:07:43 <haasn> anyway my train is about to arrive so see ya
14:07:55 <wuffie> ok thanks for all the info
14:07:57 <wuffie> cya
14:08:04 <f-a> o/
14:22:19 <yasar> https://lpaste.net/1954409822774362112
14:22:24 <yasar> I am getting syntax error here
14:22:51 <yasar> in the last line
14:23:06 <glguy> remove the ()s around (Error _)
14:24:01 <glguy> oops, misread
14:24:15 <glguy> You forgot the LogMessage constructor
14:24:34 <glguy> so it'll be, for example:   getTimeStamp (LogMessage (Error _) ts _)
14:25:51 <erisco> Simultaneously, do you really want -1? Haskell has sum types such as Maybe to cope with partiality like this.
14:27:01 <glguy> The original assignment is a bit poorly specified in the first place
14:27:14 <glguy> Embedding Unknown in the LogMessage type instead of using Maybe
14:27:24 <erisco> Oh. I wasn't here to hear the assignment.
14:27:34 <glguy> I think it's from CIS 194
14:27:51 <yasar> glguy, yes it is https://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf
14:28:45 <yasar> glguy, I know about the maybe type, but I didn't want to use it here because it wasn't mentioned in the class notes
14:30:00 <Zemyla> Is there a type for mutable hash tables that is O(1) and is backed with an array?
14:31:30 <erisco> I failed an assignment because although my program worked, it was not implemented in the expected way.
14:33:50 <erisco> To play the game of academics successfully you have to understand your professors.
14:34:26 <yasar> erisco, I am my own professor, which is kind of cool :)
14:34:37 * hackage Octree 0.6.0.1 - Simple unbalanced Octree for storing data about 3D points  http://hackage.haskell.org/package/Octree-0.6.0.1 (MichalGajda)
14:35:07 <hpc> heh, in my CS logic class i had a test where the first question was this horrendous forall/exists expression, and we had to rewrite it so it didn't have negation
14:35:11 <erisco> So what is your allegiance to these notes?
14:35:15 <hpc> so i worked out what the expression meant and just wrote "true"
14:35:16 <hpc> got full marks
14:37:30 <erisco> I wrote a test on relational algebra where I was severely docked marks for not writing the relations in the expected order.
14:39:04 <erisco> It was just math, not a procedural program, so I saw no problem with writing something like  R1 := union R2 R3  and on the next line  R2 := ...
14:39:26 <erisco> but ohhhh no
14:39:32 <hpc> your professor's a dick, relations are unordered
14:40:25 <dstolfa> erisco: wtf
14:40:45 <hpc> yasar: anyhoo yeah, if you're following those notes on your own just to learn the language yourself
14:41:20 <hpc> yasar: then using something ahead of the lessons for some minor purpose is even better than not
14:41:34 <hpc> as long as you're not using it to circumvent whatever it's trying to teach in the first place
14:43:16 <erisco> You also have to deal with these peculiarities in the work place, so whatever.
14:43:53 <hpc> erisco: i was about to say "in the workplace it's usually for good reasons like maintainability" but... well..
14:44:28 <zenspider> hi hi. I'm working through the monadic parsing chapter in the Hutton book. I've defined empty and <|> for the Alternative Parser instance. `parse (many digit) "abc"` works fine but the equivalent with some says that some is not in scope? I thought it defined by the Alternative class?
14:44:56 <hpc> zenspider: interesting, can you paste code?
14:45:05 <revskill> A monad is a monoid in category of endfunctor, means: class (Functor f) => Monoid (Monad f) where ????
14:45:27 <zenspider> hrm... no. it works in the repl... this must be something odd with the evaluator function from dante
14:45:33 <zenspider> :info some works fine
14:45:39 <erisco> I mean you have to cooperate with people who are going to unshakably hang onto strange ideas. Customers, 3rd parties, etc.
14:45:50 <zenspider> and the code runs... but if I use C-c " it errors (but not for many?!?)
14:45:52 <hpc> revskill: that's a category-theoretical statement, so translating it to haskell isn't quite so direct
14:46:07 * hackage filepath 1.4.2.1 - Library for manipulating FilePaths in a cross platform way.  http://hackage.haskell.org/package/filepath-1.4.2.1 (NeilMitchell)
14:46:08 <revskill> Any guide/tutorial to demonstrate that statement ?
14:46:20 <hpc> revskill: take a look at (<=<) and return though
14:46:23 <geekosaur> not readily. Haskell's not the ideal tool to explore category theory
14:46:23 <hpc> :t (<=<)
14:46:24 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
14:47:00 <hpc> revskill: and take a look at the definition of Kleisli
14:47:03 <hpc> @src Kleisli
14:47:03 <lambdabot> Source not found.
14:47:05 <hpc> :(
14:47:08 <zenspider> so many sigils... I'm nover gonna grok this language
14:47:17 <Cale> revskill: The notion of monoid is quite a different one
14:47:23 <hpc> newtype Kleisli m a b = Kleisli {runKleisli :: a -> m b}
14:47:34 <Cale> revskill:  https://en.wikipedia.org/wiki/Monoid_(category_theory)
14:48:09 <revskill> A, i just want an instance of Monoid with mempty and mappend with Functor
14:48:21 <Cale> revskill: This definition of monoid specialises to the usual one if you pick the category of sets, with the one element set for I, and the Cartesian product for (x)
14:48:35 <hpc> revskill: actually just listen to Cale
14:49:08 <erisco> zenspider, the Korean language looks and sounds alien to me, but it seems millions of humans are able to wield it successfully. Trust that you too can follow where so many others have been.
14:49:19 <Cale> It also specialises to the definition of a monad on the category C, if you pick the category of endofunctors on C (with the natural transformations between them as arrows), and the identity functor for I, and *composition of functors* for (x)
14:49:41 <revskill> Thanks, i'll explore more.
14:49:43 <Cale> So, what would multiplication and unit look like then?
14:50:00 <geekosaur> suspect you're well over their head, given that they haven't figured out that you are talking about a different monoid and functor than the Haskell ones
14:50:09 <Cale> A monoid object (in this second case) is going to be some endofunctor M: C -> C
14:50:16 <c50a326> zenspider: yeah even I'm kind of getting there with haskell, and I'm a total spoon
14:50:19 <Cale> with two natural transformations:
14:50:31 <zenspider> erisco: that's a great rationale... but it doesn't account for plasticity (or lack thereof). :P
14:50:34 <Cale> mu: M . M -> M
14:50:40 <Cale> and eta: I -> M
14:50:46 <Cale> such that certain conditions hold
14:50:52 <c50a326> it's not that hard, you just have to keep reading and writing and be creative about breaking things down and setting yourself challenges when you get stuck
14:50:53 <dataN> why does hmatrix use blas/lapack?
14:51:25 <zenspider> hrm... emacs user here. I'd really like to be able to put a snippet in a comment in my source and evaluate it, putting the result into a comment or the repl (preferably the comment, but I can connect the dots)
14:51:37 <zenspider> I'm currently using dante. Is there a better setup to do something like this?
14:51:39 <Cale> Now, in Haskell, natural transformations between functors F -> G usually correspond to polymorphic functions of type forall a. F a -> G a
14:52:10 <Cale> So, this means mu is going to be something of type M (M a) -> M a
14:52:26 <Cale> and eta will be something of type a -> M a
14:52:37 <Cale> and you might already recognise what those things are: join and return
14:53:10 <yasar> Can anyone familiar with cs194 spot what is wrong with my "whatWentWrong" function. I am testing it against "sample.log" file but it returns empty list.
14:53:13 <yasar> https://lpaste.net/3052579195960950784
14:54:08 <Cale> yasar: Well, could you perhaps try doing only part of what it does at a time and see where it goes wrong?
14:54:34 <Cale> Start with the build xs, and see if you get the result you expect, and then inOrder, and filter isSevere...
14:54:50 <revskill> I found this helpful: https://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-proble%E2%85%BF
14:55:20 <revskill> ok, it's join and return that made Monad is really a monoid in category of Endfunctor
14:55:22 <zenspider> yasar: I'd go a step further on Cale's suggestion and write HUnit tests for those from the bottom up
14:55:53 <revskill> :t join
14:55:54 <lambdabot> Monad m => m (m a) -> m a
14:56:00 <revskill> :t return
14:56:01 <lambdabot> Monad m => a -> m a
14:56:01 <yasar> zenspider, I am not yet familiar with HUnit, but I assume it is for unit testing
14:56:20 <Cale> That shouldn't be necessary, just try it at the ghci prompt :P
14:56:24 <c50a326> yasar: I did this quite recently. I will share this with you https://lpaste.net/5581867694065451008 it's just some phony data that you can use to look at whether your build is building the tree as you expect
14:56:25 <zenspider> yup yup. so you'd write 3 tests for isSevere
14:56:28 <hpc> unit testing's a lot more upfront effort than this is worth i think
14:56:36 <hpc> yeah, just play with it in ghci
14:56:40 <revskill> aha, join and return are both natural transformation.
14:56:41 <dataN> seems like it would either be because these C libraries are trusted, or because they are better than could be written in haskell, or because they have not *yet* been written in haskell, or, a pure version exists elsewhere. how does it compare to e.g. repa?
14:56:48 <hpc> sometimes just by writing something so you /can/ interact with it meaningfully in ghci will fix your bug
14:57:25 <zenspider> hpc: I'd say the same thing about designing something to be easily testable
14:57:26 <c50a326> yasar: I remember that I also had a version of the code that only produced an empty list, I can't remember what the problem was but it will be better if you figure it out for yourself
14:57:41 <dstolfa> dataN: i would not trust any C code in existence, ever
14:58:04 <dataN> dstolfa, perhaps it could be helpful to people who do
14:58:20 <hpc> zenspider: agreed, but it takes longer up-front with unit tests
14:58:33 <c50a326> yasar: if you can test and verify that your functions do what they should and you're confident about them and you're still clueless, then ask again, I would suggest (also ensure you've broken your functions down enough... let me count how many functions I wrote compared with you...)
14:58:49 <yasar> c50a326, Hmm, according to your test case, my build tree only returns 1 Node :/
14:59:04 <dataN> but, if a pure haskell implementation of comparable extent exists, it would be helpful to know how it compares in terms of performance.
14:59:14 <Cale> dataN: blas/lapack are just old and well-known libraries. I doubt there's a particularly good reason for hmatrix specifically to rely on them, but *some* binding probably ought to exist, so it might as well be that.
14:59:35 <dataN> fair enough
15:00:21 <c50a326> yasar: also I used guards for the insert function which means it looks a lot nicer than the way your code leans way across to the right with huge lines
15:00:43 <c50a326> yasar: and I split up parseMessage to call a couple of other functions depending on the types
15:00:44 <Cale> I know that a fair amount of effort has been put into optimising the code in those libraries
15:01:07 <Cale> So it might be tricky to write straightforward Haskell code which performs as well.
15:02:22 <zenspider> hpc: agreed... and the tests persist where the repl is transient. you might regress later tweaking stuff. I especially find them valuable when teaching something because it forces the students to get clear on their thinking / approach
15:02:32 <geekosaur> dataN, blas and lapack started out as Fortran. they're old, very well optimized, very very well tested.
15:02:38 <zenspider> both have benefits
15:02:53 <Rembane> geekosaur: Were they reimplemented in C?
15:03:14 <geekosaur> and very, very little gets anywhere near them. some GPU libs, but only via brute force: they'd be even faster after 30+ years of optimization like blas and lapack got
15:03:31 <geekosaur> Rembane, translated, I think. then further optimized after.
15:03:46 <dstolfa> i am not convinced BLAS and lapack are C
15:03:48 <dstolfa> that's a stupid idea
15:03:48 <geekosaur> long enough ago that the C versions are likewise heavily optimized and very well tested
15:03:49 <dstolfa> for many reasons
15:04:05 <geekosaur> dstolfa, they are, for one good reason: C is more portable than Fortran
15:04:17 <geekosaur> show me an optimized Fortran compiler for ARM
15:04:19 <dstolfa> geekosaur: i REALLY doubt they're C
15:04:20 <dstolfa> the reason is
15:04:25 <geekosaur> you are allowed to doubt all you want
15:04:28 <dstolfa> C is a horrible language to do any kind of vectorisation and automated parallelisation in
15:04:31 <dstolfa> moreover
15:04:33 <dataN> so, the linear algebra community like matlab because of the syntax and low overhead to the majority of common linear algebra subroutines such as those that can be accessed via e.g. lapack through hmatrix. however, this is not a lightweight solution which particularly reflect of haskells expressive and high performance capabilities. hmatrix is often recommended because of its obvious (to the C community at least) established reliability
15:04:33 <dstolfa> and it was fortran
15:04:35 <dstolfa> i've used BLAS recently
15:04:40 <dstolfa> so
15:04:44 <dstolfa> you're talking about one BLAS implementation in C
15:04:47 <dstolfa> the one i've used was fortran
15:04:54 <geekosaur> I told you the history
15:05:03 <c50a326> yasar: and !! is a little frowned upon I think, because it can cause out of bounds exception
15:05:08 <dataN> what library should matlab users be directed to that can better promote the advantages of pure haskell?
15:05:12 <dstolfa> geekosaur: and i'm telling you that there's not only one blas implementation and it's wrong to claim that. moreover, it's a very stupid idea to write it in C
15:05:19 <revskill> what's your recommended GUI library in Haskell ?
15:05:28 <dstolfa> simply beacuse of the alias analysis undecidability and the default assumption that things alias if we can't figure it out
15:05:30 <Rembane> geekosaur: Sweet!
15:05:37 <zenspider> https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms -> says implemented in fortran, bindings available for C
15:05:40 <geekosaur> dstolfa, have you actually looked at the history?
15:05:54 <dstolfa> geekosaur: sure? i still don't get your point?
15:06:03 <zenspider> that said, dstolfa's flagrant throwing around of "stupid" is turning me off.
15:06:56 <yasar> So, my insert was broken. It was returning only the last Node, not the whole tree
15:07:21 <dstolfa> zenspider: the problem is with pointers. in fortran, you have arrays of things that are guaranteed not to alias by the language and you can start reordering things and vectorising them arbitrarily. same goes for parallelisation. in C and C++, we have to do a bunch of alias analysis that is usually O(n^3) and still gives very poor results. you often get the answer of: "they don't alias" or "they maybe
15:07:27 <dstolfa> alias". you usually end up with the latter. in the latter case, the only correct thing for the compiler to do is to say that they do alias, in which case you can't vectorise things.
15:07:48 <zenspider> dstolfa: I don't care.
15:07:54 <dstolfa> that's why it's a stupid idea to write anything that heavily relies on vectorisation and parallelisation in C. you may get away with it in C++ if you use std::array or std::vector, but you won't get away with it in C
15:07:56 <zenspider> yasar: good job!
15:09:30 <erisco> no predicted rain and starts down pouring oO
15:10:08 <hpc> it's speculative rain, it'll get rolled back at the end of the day
15:10:29 <dataN> geekosaur, Cale, so this trustedness is to do with a perceived performance advantage, being optimised somehow for hardware in an unclear way. with the existence of advanced proof assistants, why are these poorly understood optimisations used? if there are techniques which can improve performance they should be understood and made available through higher order functions.
15:11:14 <erisco> oh seems it was 10% rain... not enough for Google Assistant to inform me
15:11:27 <geekosaur> dataN, because this stuff was not invented just now and in Haskell or Idris or whatever. it's been around forever, its API is considered a standard
15:12:42 <geekosaur> yes, I know there's a current thing for "burn it all own and reinvent everything completely from scratch"
15:14:06 <incomprehensibly> opinions on accelerate vs hmatrix?
15:15:10 <dataN> dstolfa: the argument is that in the absence of vectorisation, which is a kind of shotgun approach to fast random access containers, that performance critical applications leverage on understanding intrinsic geometry of the problem at hand, and intelligent algorithmic design often outperforms these more widely applicable automatic optimisation via "fast containers" such as vectors
15:16:42 <Rembane> dataN: I'm lost, does what you just wrote mean that really good custom algorithms are faster than just using vectors?
15:19:30 <dataN> geekosaur: quite the opposite, it should be machine readable, and if not, human efforts in cataloguing exactly how and why a particular implementation is fast can enable reuse of these efforts in a wider setting.
15:20:07 <geekosaur> dataN, that works up to a point.
15:20:34 <geekosaur> these algorithms are designed for use on huge datasets, and you optimize at every level you can to get performance.
15:21:03 <zenspider> looks like dante runs its OWN repl rather than using haskell-interactive-mode's session. It runs via `cabal repl --builddir=dist/dante`, does a couple :set cmds, and then a :l on the source before it runs my snippet... for some reason THAT is broken, but regular ghci + load + snippet is fine
15:21:33 <zenspider> I don't normally use cabal. IS `cabal repl` missing some of the prelude or anything?
15:21:57 <sclv> no
15:22:09 <dataN> Rembane: yes, certainly. a good example is stencil convolution common in finite difference schemes, here, retraversing a container is unnecessary, instead, adjacent elements should be accessed using e.g. Zippers.
15:22:28 <zenspider> well... I'm explicitly requiring Control.Applicative... so it shouldn't be that either
15:22:30 <Rembane> dataN: Ah, yes, indeed.
15:22:46 <sclv> zenspider: what happens if you just run cabal repl on your source directly?
15:22:57 <dataN> geekosaur: what levels!?
15:23:29 <geekosaur> if you don't know the answer to that, perhaps you should not be complaining
15:23:53 <zenspider> sclv: seems to work fine
15:24:06 <sclv> weird
15:24:11 <zenspider> I'm stumped. I turned on all the debuggy stuff that dante offers and can't replicate the error
15:24:28 <zenspider> oh. hrm. I also don't know how to nuke their process vs the ghci one
15:28:46 <dataN> the point is that these unknown optimisations are unhelpful, perhaps there are various standards they implement (well, they are the industry standard since forever). perhaps the question is as to what resources exist to understand these various optimisations, and where possible, to extract them automatically. aside from this, the various high performance haskell libraries should cover at least a large subset of the possible optimisitai
15:33:44 <zenspider> ok. I have a minimal reproduction but don't understand it yet. What is "*" in a :load ?
15:36:15 <dataN> anyway, if most linear algebra research uses a few of the more simple operations, it is then apparent that this perception of an unfathomable sprawl of magically optimised C code or fortran binding is totally misleading if all that is needed is type level bounds checking, LU factorisation, transpose, reasonably fast matrix inverses and some tools for over and under determined linear systems, inner and outer product e.t.c. enough that a
15:37:08 <hpc> dataN: your lines keep getting cut off
15:37:17 <sclv> zenspider: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:load
15:37:20 <hpc> try and keep them under 200-ish characters
15:37:31 <glguy> Or get a client that knows about cutoff !
15:37:40 <dataN> ah
15:37:43 <sclv> forces bytecode
15:38:33 <dataN> where is the pure haskell linear algebra for matlab coders package?
15:38:53 <zenspider> ok. that doesn't seem to matter to the end result. I have all my parser stuff in parser.hs, if I :l it, then :set -fobject-code, then :r, then run my snippet, it says it isn't defined.
15:39:47 <zenspider> and ALL of those lines are needed for it not to work. Unfortunately, there aren't many knobs to tweak what dante sends to the process
15:40:01 <zenspider> but the cmd is really nice for documenting my progress
15:42:15 <dataN> is there need of one?
15:43:31 <dataN> maybe its just the tendency of online tutorials to use hmatrix which is causing this.
15:45:33 <dataN> repa biplate!?
15:47:20 <zenspider> anyone here use doctest? similar idea
15:49:16 <erisco> dataN, or start a blog :)
15:49:49 <hpc> zenspider: doctest is one of my favorite libraries i have never used
15:50:54 <dataN> erisco: equivalent to replacing industry leading high performance linear algebra libraries!? might as well promote them to type level and use GHC's magic optimisation...
15:52:26 <nai> i am amazed by the average message length on this channel
15:52:39 <nai> every time i look at #haskell my screen is filled with text
15:53:24 <erisco> I am not sure what else an IRC client window would be filled with.
15:53:31 <Rembane> Joins and parts?
15:53:42 <nai> filled in both directions, that is
15:53:44 <erisco> Oh, I silenced those :)
15:53:54 <Rembane> ^^
15:54:41 <erisco> Holy guacamole! Only 830 people in here?
15:54:43 <infinisil> I have once been kicked from a channel because somebody was annoyed over me joining quitting a couple times in a row...
15:55:01 <Rembane> erisco: Someone stole an op's account and kicked everyone.
15:56:47 <hpc> sometimes i wish there was a ranking of when you joined the channel, just so i could be #10 right now :D
15:57:19 <hpc> it happened to a couple of other channels too
15:59:10 <geekosaur> there used to be, I think. bunch of channel stats including graphs and various top-10s
16:01:27 <glguy> I think hpc means #10 to join after the mass-kick
16:02:43 <c_wraith> fascinating how many people never re-joined.  says something about IRC usage patterns.  "oh, sure, I might as well join that channel too, even if I never look at it"
16:03:57 <hpc> glguy: yeah
16:04:43 <hpc> c_wraith: i wonder if it's like how people use their web browser, never closing tabs when they're done with them
16:04:58 <hpc> and some of the people that didn't rejoin just have 50+ channels to go through?
16:06:43 <freeman42x]NixOS> is there a more concise way of doing: (hh:mm:ss:[]) = splitOn "|" "01|15|59" ? the pattern mathching bit
16:07:07 <glguy> [hh,mm,ss] ?
16:07:15 <erisco> Sure. You can remove the parentheses :)
16:07:46 <hpc> freeman42x]NixOS: assuming the string isn't hardcoded and you're trying to parse it, not particularly
16:07:56 <hpc> freeman42x]NixOS: if it's part of a larger parser, use a parser combinator library maybe?
16:08:21 <freeman42x]NixOS> thank you
16:08:25 <hpc> glguy's suggestion is probably best
16:08:31 <hpc> [hh,mm,ss] = splitOn ...
16:09:32 <erisco> This would be four lines without pattern matching. What a wonderful world we live in.
16:10:35 <infinisil> slap some read <$> in there which would probably be the next thing to do
16:12:40 <mff> I have an FFI thing that returns a small struct (data Foo = Foo !Word64 !Word64 !Word64). i'm alloca-ing a small buffer, peeking each word out and building the Foo. is there something better I should be doing?
16:13:44 <infinisil> Hey, I wrote my own mtl Monady thing. Does mtl code always look like this or am I missing something? https://gist.github.com/Infinisil/d2680d19e1e05af19d1217f25b92690e
16:17:51 <Solonarv> you can use DefaultSignatures to simplify writing the instances, let me whip up an example real quick
16:20:52 <Solonarv> infinisil here's an example of what I mean: https://gist.github.com/Solonarv/d8e03b1309fca7e5f3abb2dcee8100fa
16:21:20 <infinisil> Hmm.. interesting
16:21:56 <infinisil> But kinda disappointing that this repetition can't be dealt with without extensions
16:22:02 <Solonarv> I think you need the DefaultSignatures and TypeOperators extensions
16:22:33 <Solonarv> bah, there are some extensions that are questionable but those aren't among them
16:23:38 <infinisil> I just found this page :O https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html
16:23:47 <infinisil> I shall bookmark it
16:23:49 <Solonarv> IMO there's no need to be parsimonious with extensions
16:24:47 <ph88> hurray, stack has the new ghc !
16:32:02 <csantill> Hello... installing Stack on new Ubuntu 18.04 machine... I am getting the following error...  https://lpaste.net/2127152307907854336
16:33:46 <csantill> when trying to install stack-run
16:38:03 <hpc> looks like you already have stack and are installing something else with it
16:38:29 <csantill> sorry, yes I am trying to install stack-run
16:38:30 <hpc> in which case, maybe try a different version?
16:38:48 <geekosaur> stack-run apparently wants an older version of the Cabal library
16:38:52 <hpc> the nice part of stack is that builds are reproducible
16:39:00 <geekosaur> but the installer uses allow-newer, so
16:39:00 <hpc> the bad part is build failures also faithfully reproduce in any environment
16:39:07 <hpc> so there's not really a workaround
16:39:13 <csantill> Yes, I could not figure out how to change cabal version...
16:39:28 <hpc> (specifically a different version of stack-run)
16:39:55 <Solonarv> you can try `stack unpack stack-run` to get the source, then fiddle with the stack.yaml
16:40:55 <glguy> The joy of stack is that you get to figure out the build-plan yourself. stack-run builds with lts-9, at a minimum
16:41:29 <patlv> hi, having an issue with mysql-simple to parse an SQLType of "Date", getting: Incompatible {errSQLType = "Date", errHaskellType = "UTCTime", errFieldName = "date", errMessage = "types incompatible"}
16:42:19 <csantill> thanks, will try that... (unpack)
16:43:43 <csantill> I read that Distribution.PackageDescription.Parse was deprecated in Cabal 2.2.0.0 but cannot figure out how to use older version
16:46:06 <csantill> Looks like stack-run uses cabal to build... (not stack)
16:46:40 <hpc> oh, maybe build it with an old enough lts then?
16:47:03 <hpc> not sure how to do that without a stack.yaml, off the top of my head
16:48:36 <csantill> trying with older lts
17:00:37 <Solonarv> just `stack install stack-run --resolver blah`
17:52:43 <HallaSurvivor> does anyone in here use Tidal?
17:52:56 <HallaSurvivor> it's some music making software, and I want to get into it
17:55:08 <abueide> so I have a local package that I wrote and I copy pasted it inside of another project and added to my stack.yaml file like this:
17:55:09 <abueide> packages:
17:55:09 <abueide> - .
17:55:09 <abueide> - hs-ipfs-api
17:56:17 <abueide> however I'm getting Import errors when I try to build it with stack "could not find module IPFS" even though it works fine in the Main class in the subproject
18:10:33 <Zipheir`> What's a decent structure with which to represent a 2D game board? I'm not much concerned with performance ATM--mainly, I need something more idiomatic for the purpose than lists.
18:12:06 <Solonarv> Array (Int, Int) Tile should work
18:14:40 <Zipheir`> Solonarv: Right, that's what I've been looking at. Unfortunately, Data.Array seems to have a pretty limited interface--most operations seem to require projecting the Array to an alist, etc.
18:14:52 <Solonarv> huh? what operations are you looking at?
18:15:50 <Zipheir`> Oh wait, Array is traversable and foldable. OK, derp.
18:16:43 <Solonarv> there you go :D
18:16:52 <Zipheir`> Solonarv: ty
18:17:01 <orion> I have a "Lens' Foo UserId". How do I convert it to a "Lens' Foo (Maybe UserId)" via Just without introducing a Contravariant constraint?
18:18:04 <c_wraith> orion: what should Nothing map to?
18:19:19 <c_wraith> orion: remember, Lens is bidirectional.  If you have a Lens' Foo (Maybe UserId), it needs to do something when the Maybe UserId is set to Nothing
18:21:00 <infinisil> Should be possible to create a lens from a function that takes the default value
18:21:06 <orion> Hmm. Indeed Nothing doesn't make sense. Perhaps I want a Getter instead?
18:21:16 <orion> Something unidirectional.
18:21:19 <c_wraith> well, the Contravariant constraint being added is from making it into a fold
18:21:26 <c_wraith> Which is unidirectional
18:22:46 <Solonarv> that's definitely possible; if you don't need the not-actually-a-lens to be able to set values you can just use "myLens . to Just"
18:24:41 <orion> Could not deduce (Contravariant f) arising from a use of 'to'
18:24:43 <orion> :(
18:24:55 <orion> I tried "myLens . re _Just" also.
18:26:04 <orion> Holy crap, changing it from a Lens' to a Getter magically make it type check.
18:26:20 <Solonarv> well the result isn't be a lens, so saying "this is a lens" is an error
18:27:41 <orion> Thank you all.
18:30:26 <Zipheir`> WRT Array, is [i | (i,e) <- assocs someArray, p e] the best one can do for finding the elements of someArray that satisfy a predicate?
18:31:18 <Zipheir`> sorry, *finding _the indices of_ the elements of someArray
18:34:42 <c_wraith> Zipheir`: unless you want to drag lenses into it and use indexed folds..  which probably work out to the same code being run at the end anyway
18:36:12 <Zipheir`> c_wraith: OK, thanks.
18:53:35 <slack1256> To understand the gi-gtk api, should I learn the C api for GTK?
18:53:45 <slack1256> Or there is a haskell centric tutorial somewhere?
19:29:07 * hackage language-ats 1.2.0.14 - Parser and pretty-printer for ATS.  http://hackage.haskell.org/package/language-ats-1.2.0.14 (vmchale)
19:33:53 <ClaireBookworm> Hello!
19:34:30 * lambdabot waves.
19:35:11 <ClaireBookworm> I'm new here, so...
19:35:44 <ClaireBookworm> Hi people!
19:40:34 <lyxia> hi ClaireBookworm
19:41:04 <lyxia> ClaireBookworm: do you like Haskell
20:08:38 <c50a326> does anybody know where the name Haskell comes from? I mean I know it comes from Haskell Curry but this is a strange name for an american too isn't it?
20:09:35 <c50a326> I was taking this lady out the other day and she asked me about what I was doing so I told her I'm learning Haskell and why it's called Haskell and she was most surprised that there was a dude named Haskell Curry, she thought it was a real weird name
20:10:29 <c50a326> I did just check wikipedia, nothing there
20:11:47 <geekosaur> it's a name that was rather more popular in the 1800s
20:13:45 <geekosaur> and https://en.wikipedia.org/wiki/Haskell_Curry doesn't look like nothing there to me
20:14:05 <lambdabotch> it comes from the surnames, like naming a kid Dylan or Madison
20:14:59 <geekosaur> I could see it being Biblical in origin, as an Anglicization of Hebrew
20:15:59 <geekosaur> (see also "Chaskiel" which is a different anglicization of the same word/name)
21:08:01 <ClaireBookworm> Hello
21:08:02 <ClaireBookworm> Erm
21:08:31 <ClaireBookworm> How would I write haskell in Atom editor? like download the kernels?
21:08:35 <ClaireBookworm> I do'nt know if this is the place to ask
21:18:56 <iqubic> This is the right place to ask.
21:21:30 <pikajude> would it be insanely hard to make Cabal's parser preserve comments and source locations?
21:21:40 <pikajude> honestly i'm thinking of taking a whack at it
21:25:59 <cocreature> pikajude: doesn’t the new parsec parser already preserve source locations?
21:26:03 <cocreature> not sure about comments
21:26:54 <pikajude> how new we talking
21:29:13 <pikajude> oh, i'm sorry, i need to clarify
21:29:27 <pikajude> haskell-src-exts exposes an AST annotated with source locations
21:29:37 <pikajude> i meant something more like that
21:30:02 <cocreature> there does at least seem to be a low-level AST like that https://hackage.haskell.org/package/Cabal-2.2.0.1/docs/Distribution-Parsec-Parser.html
21:30:10 <cocreature> not sure how far up those locations are preserved
21:30:34 <pikajude> basically, far up enough that you can figure out what is and isn't a field
21:30:47 <pikajude> but all of the validation logic takes place later in the stack once annotations have been dropped
21:31:09 <pikajude> to be honest, given the contents of that module, I could probably already write the thing I want
21:31:46 <pikajude> thanks for the pointer cocreature
21:31:53 <pikajude> i will have to tweak the lexer to preserve comments but otherwise this should work ok
21:37:37 * hackage hw-excess 0.2.0.2 - Excess  http://hackage.haskell.org/package/hw-excess-0.2.0.2 (haskellworks)
21:45:53 <cocreature> pikajude: iirc I’ve seen a few issues in the cabal issue tracker related to this so you might want to search through those first
21:56:07 * hackage pandoc 2.2.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-2.2.2 (JohnMacFarlane)
22:48:37 * hackage solve 1.0 - Solving simple games  http://hackage.haskell.org/package/solve-1.0 (JoeHurd)
23:04:20 <haz> So it seems the State monad has been changed to StateT
23:04:33 <haz> As someone trying to learn it (for the first time), that invalidates all the tutorials I can find
23:04:48 <haz> Does anyone have a good resource that is current?
23:05:02 <cocreature> haz: the changes required should be relatively small. anything specific you are having trouble with?
23:06:15 <geekosaur> State is still there, but it's a type alias. the main difference is that uses of the State constructor have changed; use lowercase "state" instead of "State", unless it's in a pattern. (And with sufficiently recent mtl, I think State should work in patterns now? a pattern synonym was in the works)
23:08:09 <tdammers> yeah, it's not so much that "the" state monad has been "changed to StateT", it's just that instead of implementing them separately, State is now expressed in terms of StateT - but the interface is mostly the same
23:10:13 <haz> Ah, so I should be fine just substituting the "State" constructor for "state" ? I'll have a deeper look into the type definitions
23:25:24 <tdammers> I rarely construct State(T) values directly, really
23:26:11 <tdammers> the usual way I use State is that I pass an initial state to runState, and then inside the monadic body, all manipulations go through MonadState methods - get, put, modify, and things written in terms of those
23:30:40 <haz> Fantastic, I've got a (very basic) working example, which I'm halfway to understanding. Thanks for your help!
23:30:43 <dennisb> and you don't even need to use runState but can use evalState or execState instead
23:32:01 <tdammers> dennisb: well, sure, one of those 3, as the case may be
23:39:31 <c50a326> `/topic
23:41:50 <c50a326> what's up with these irc logs, I can't search them?
23:42:29 <c50a326> there's this tunes.org site, as well as ircbrowse.net, I can't see search functionality on either
23:43:41 <butterthebuddha> https://arxiv.org/pdf/1710.09756.pdf
23:43:59 <butterthebuddha> Page 2 of that paper - "Informally, a function is “linear” if it consumes its argument exactly once. (It is “affine” if it consumes
23:44:01 <butterthebuddha> it at most once.)"
23:44:23 <butterthebuddha> How are linear and affine as discussed here consistent with the linear algebra definitions?
