00:01:38 <quicksilver> a categorist would say that a free construction is just a left adjoint to a forgetful functor
00:01:38 <[exa]> there should be a picture of how e.g. State is basically a tree of transformations
00:02:00 <quicksilver> surely State is "basically" just functions?
00:02:32 <quicksilver> State is a way to use monadic combinators (and/or monadic notation) to construct functions
00:03:06 <[exa]> yes
00:03:23 <[exa]> the point with "free" is that you can take out the functions and put something else in the tree
00:04:14 <[exa]> at least that's the best direct visualization I've found
00:05:09 <pavonia> Anyone knows of a Map variant that works with (possibly infinite) ranges of values as keys and provides a zipWith-like function? I tried implementing a version based on Data.Map and Data.Range, but it seems harder that expected to get the intersection of ranges right
00:06:10 <[exa]> pavonia: well you can't reasonably build an infinite balanced tree
00:07:09 <pavonia> The tree doesn't need to be infinite, you can have ranges for (-Infinity, x] and [y, Infinity)
00:07:10 <butterthebuddha> :t (>>=)
00:07:11 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:07:50 <butterthebuddha> Is CPS similar to Monads in the following sense: given a function f :: a -> b, the CPS version would be f' :: a -> (b -> r) -> r
00:08:17 <butterthebuddha> Where f' x y = y (f x)
00:08:54 <butterthebuddha> with (f x) representing "a computation" whose result we then pass on to a transformation
00:09:49 <butterthebuddha> In a sense, f is analogous to a function of the type "m a -> a"
00:10:10 <butterthebuddha> I'm not sure if I'm being precise or clear enough
00:10:37 <[exa]> butterthebuddha: well partially. You might want to see the implementation of ContT
00:12:03 <quicksilver> pavonia: google haskell interval tree. There are a couple of implementations of segment trees and interval maps in the first page of the results.
00:12:28 <quicksilver> and a possibly relevant blog post.
00:12:53 <[exa]> pavonia: IOC I've misread the 'ranges'
00:13:33 <quicksilver> butterthebuddha: the 'analogy' is that Cont is one example of monad, yes.
00:16:23 <quicksilver> possibly read this, too : https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads
00:17:16 <butterthebuddha> I'm trying to arrive at the answer organically
00:17:33 <butterthebuddha> So I'm trying to delay reading any literature for as long as I can :P
00:18:01 <quicksilver> I think it's something of a false enlightenment. I don't think Cont is actually foundational.
00:18:09 <quicksilver> but I could be wrong :)
00:18:15 <quicksilver> it's certainly interesting.
00:18:53 <butterthebuddha> CPS is interesting because it seems it could be used to simulate monads in any language with first-class functions
00:19:08 <dminuoso> quicksilver: the mother of all monads should be the free monad... :P
00:19:19 <pavonia> quicksilver: Thanks, Data.IntervalMap.FingerTree looks promising, though it doesn't provide infinite intervals out of the box
00:19:34 <pavonia> I guess I can work around that with a newtype
00:19:58 <pavonia> or special interval parameter type rather
00:21:00 <quchen> Whenever someone says »mother of all monads« I remember someone joking »try creating State using Cont« and I haven’t understood that joke? reference? for maybe 5 years now.
00:21:07 * hackage nonfree 0.1.0.4 - Free structures sans laws  http://hackage.haskell.org/package/nonfree-0.1.0.4 (ShachafBenKiki)
00:21:42 <quchen> And here’s a release by Shachaf, who might just have been that person.
00:21:53 <shachaf> The real "mother of all monads" is Codensity, not Cont.
00:22:15 <shachaf> And you can certainly do anything State can do with either of them, as described in that one article.
00:22:57 <quchen> That one article being the neighbourhood of infinity one? I remember it being mostly about emulating Maybe and List using Cont and then ending. Maybe I should revisit it.
00:24:03 <shachaf> Well, it's not titled "the mother of mostly Maybe and List"
00:24:33 <quicksilver> pavonia: yes you get to choose your type as long as it has an Ord instances
00:24:36 <butterthebuddha> Heh
00:24:46 <quicksilver> obviously no problem creating a type with Plus/MinusInfinity
00:25:32 <quicksilver> obviously List is the mother of Maybe and List
00:25:38 <quicksilver> which is biologically improbable
00:25:53 <shachaf> Well, certainly every monad is its own mother by this classification.
00:25:54 <quicksilver> but maybe biology is a poor intuition for types and programming languages
00:26:00 <jackdk> who else just got nerdsniped into writing out the Functor/Applicative/Monad instances for Cont?
00:26:05 <shachaf> In fact Codensity (s ->) is even the same type as State s
00:26:24 <quicksilver> I'm too old and grey haired to be nerdsniped that easily jackdk :)
00:26:26 <quchen> shachaf: That’s why I mentioned it – I remember the article being two base cases and then a huge ellipsis instead of an induction step.
00:26:44 <[exa]> jackdk: writing State now
00:26:48 <[exa]> (from Cont)
00:26:50 <[exa]> :]
00:27:10 <shachaf> But in this usage "M is the mother of N" means that you can lift N into M and do things and then lower it and get the same result. Or something.
00:27:20 * [exa] added nerdsnipe to the dictionary
00:28:06 <shachaf> The article seems pretty clear to me.
00:28:22 <jackdk> [exa]: https://www.xkcd.com/356/
00:30:03 <shachaf> Cont looks complicated until you learn that you can get the definition for free from the adjunction (-> r) : Hask -| Hask^op
00:30:27 <shachaf> Then it still looks complicated but at least it's easy to write the definition out.
00:31:43 <gabe4k> jackdk: :)
00:32:06 <butterthebuddha> Well, viewing the CPS version of a function f as the bind operator for a monad that has an extraction operator f limits one to comonads right
00:32:17 <butterthebuddha> Unless you're willing to sacrifice purity
00:32:30 <shachaf> Anyway the article says "the above should work for any monad" and then gives an example with IO, so it seems pretty clear.
00:33:19 <shachaf> Purity? What?
00:33:34 <quchen> shachaf: Thanks for the pointers, I’ll read it again now :-)
00:33:55 <butterthebuddha> Well, you end up having to write partial functions for Maybe and Either a for example?
00:34:07 <shachaf> To do what?
00:34:23 <butterthebuddha> to define an extraction functin
00:34:31 <butterthebuddha> s/functin/function
00:34:42 <shachaf> Why are you defining an extraction function?
00:34:54 <alexad> Pattern match, don't extract
00:35:25 <shachaf> Someone is pattern-matching on a conversation in here...
00:35:34 <butterthebuddha> Well, given a function f : c -> d, and defining the CPS version, f' : c -> (d -> r) -> r
00:35:40 <alexad> probably. *slinks away*
00:35:56 <butterthebuddha> f' is bind if c = m a, d = a, r = m b
00:36:09 <butterthebuddha> bind :: m a -> (a -> m b) -> m b
00:36:33 <butterthebuddha> and f is an "extraction function:
00:36:55 <butterthebuddha> because f' x g = g (f x)
00:37:31 <[exa]> jackdk: oh great now I'm spending the time with resistors :D
00:38:22 <shachaf> I don't follow.
00:39:00 <butterthebuddha> Well, for a monad m, suppose that you had a function extract :: m a -> a
00:39:18 <butterthebuddha> Then bind is the CPS version of extract
00:40:40 <shachaf> You're saying that if you take the type "m a -> (a -> r) -> r" and let r=m b then you get "m a -> (a -> m b) -> m b"?
00:40:52 <butterthebuddha> Yep
00:40:54 <shachaf> That's true, but there are many other implementations of the latter type.
00:41:23 <shachaf> Because the b is polymorphic, but (>>=) knows all about m and can do things based on it.
00:51:43 <pally> If I have a newtype that is declared as follows
00:52:11 <pally> newtype State s a = StateOf {deState :: s -> (s, a) }
00:52:52 <pally> and we're making this newtype an instance of Monad that looks something like this
00:53:26 <pally> instance Monad (State s) where ...
00:56:37 * hackage hspec-megaparsec 1.1.0 - Utility functions for testing Megaparsec parsers with Hspec  http://hackage.haskell.org/package/hspec-megaparsec-1.1.0 (mrkkrp)
00:57:47 <pavonia> *suspense, suspense*
00:58:06 <quchen> pavonia: Glad I’m not the only one
00:58:08 <pally> I am so confused right now... sorry
00:58:20 <pally> I'll return in a minute.
01:00:14 <quchen> State st >>= f = State (\s -> let (s', x') = deState st s in deState (f x') s') -- that one?
01:00:53 <pally> pavonia, quchen okay, since I am so f*ckin confused right now.  I'll just admit i have no grip of anything and ask the basic question.
01:01:37 <dminuoso> pally: It might also be helpful to prepare a gist/pastie containing the Haskell code you want to talk about if it's a few lines. :)
01:01:46 <dminuoso> Especially since you can take your time in preparing it right.
01:02:00 <pally> What does it mean to include type variable 's' (in this case):
01:02:01 <pally> instance Monad (State s) where ...
01:02:15 <pally> or instance Monad (State s a) where ...
01:02:33 <pavonia> Also, no worries, I was just kidding :)
01:02:33 <dminuoso> pally: It's a type variable. It means that `instance Monad (State s)` is valid for any possible choice of s.
01:03:08 <pally> pavonia, the notation + the State Monad is a real treat(-ment)
01:03:30 <quchen> (State s) is a monad, like (Maybe) is a monad. (State s a) is not a monad like (Maybe a) is not a monad, it’s a type error. Only things that take a single left out type argument can be monads.
01:03:43 <dminuoso> % :i Monad
01:03:44 <yahb> dminuoso: class Applicative m => Monad (m :: * -> *) where; (>>=) :: m a -> (a -> m b) -> m b; (>>) :: m a -> m b -> m b; return :: a -> m a; fail :: String -> m a; {-# MINIMAL (>>=) #-}; -- Defined in `GHC.Base'; instance [safe] (Monoid w, Monad m) => Monad (WriterT w m) -- Defined in `Control.Monad.Trans.Writer.Lazy'; instance [safe] Monad m => Monad (StateT s m) -- Defined in `Control.Monad.Trans.St
01:03:51 <quchen> Maybe takes a single type argument. (Maybe a) takes no single type argument so it can’t be a monad.
01:03:55 <dminuoso> :k Monad
01:03:56 <lambdabot> (* -> *) -> Constraint
01:04:25 <[exa]> pally: in other words, the monad definition has to be completely independent of the internal type (same as for the simpler Functor)
01:04:49 <pally> quchen, I get what you are sayin,  and before I am get overwhelmed with the "info" let me follow up with the next question
01:04:51 <quchen> pally: You can read »instance Monad (State s) where« as »(State s) is a Monad for any choice of s«.
01:04:56 <dminuoso> pally: You could think of it like this: For any possible choice of `s` (State s) is a Monad.
01:05:32 <pally> right, (State s) is a monad for any possible choice of 's', what about (State) <- on its own?
01:05:42 <pally> I mean
01:05:47 <dminuoso> pally: Monad only works of things with the kind * -> *
01:05:49 <pally> `Monad (State)`
01:05:57 <dminuoso> pally: If you check
01:06:01 <dminuoso> :k Monad
01:06:02 <lambdabot> (* -> *) -> Constraint
01:06:03 <quchen> State on its own takes two type parameters, it’s not the right kind (»type of types«)
01:06:03 <dminuoso> Or
01:06:07 <dminuoso> % :i Monad
01:06:07 <yahb> dminuoso: class Applicative m => Monad (m :: * -> *) where; (>>=) :: m a -> (a -> m b) -> m b; (>>) :: m a -> m b -> m b; return :: a -> m a; fail :: String -> m a; {-# MINIMAL (>>=) #-}; -- Defined in `GHC.Base'; instance [safe] (Monoid w, Monad m) => Monad (WriterT w m) -- Defined in `Control.Monad.Trans.Writer.Lazy'; instance [safe] Monad m => Monad (StateT s m) -- Defined in `Control.Monad.Trans.St
01:06:35 <quchen> pally: Do you understand why you cannot write »instance Eq Maybe where«?
01:06:38 <dminuoso> pally: You can see that `class ... Monad (m :: * -> *)` which means that whatever you want to write a Monad instance for, it must take exactly one type argument itself.
01:07:44 <pally> quchen, in short, Only `instance Monad (State) where` would not work?
01:07:56 <quchen> The compiler would reject it.
01:07:57 <gentauro> are there any performance measure on `Integer` operations?
01:08:06 <quchen> gentauro: »Pretty fast«
01:08:09 <gentauro> like what's the cost of adding two really big numbers
01:08:14 <pally> quchen, okay, now that I have those answers I will read the msg log again.
01:08:14 <dminuoso> "Really low"
01:08:22 <pally> and digest/take it in.
01:08:46 <gentauro> quchen: asymtotic time complexity + "real life performance" measures?
01:09:57 <quchen> Asymptotic time complexity has nothing to do with how much time an operation takes on a CPU. As for »real life performance«, GHC uses a very efficient binding to libgmp.
01:10:38 <pally> I watched a Lambdaconf once, and the title of the talk was "How to Learn Haskell in less than 5 years), and the speaker gave #haskell @freenode props
01:10:42 <gentauro> quchen: roger that -> this is not really helpfull at all -> https://wiki.haskell.org/Performance/Integers
01:11:06 <gentauro> pally: #haskell here is awesome !!!
01:11:17 <gentauro> and the language itself is also.
01:11:36 <gentauro> the diff now from back in the days when I didn't catched on, was the tools
01:11:56 <pally> gentauro, the thing with his talk is that the struggle he shared resonates with every bone in my body right now.
01:12:00 <quchen> pally: You’d be surprised how little Haskell you need to know to be productive in it. There is a lot more to it, but it’s not like you need a vast knowledge to get shit done™,
01:12:00 <gentauro> I mean, you have to give kudos to everything that surrounds the language at the moment ;)
01:12:08 <geekosaur> gentauro, with gmp the first qurestion is "how large are the integers we're talking about?"
01:12:51 <geekosaur> that said, the binding to gmp is as close to direct/raw as it gets, so any performance data you find for gmp applies pretty much directly
01:13:03 <gentauro> geekosaur: pretty long? :D
01:13:32 <quchen> So I’ll assume around 10 decimal digits? Yes that’ll work.
01:13:45 <geekosaur> heh
01:13:47 <quchen> For better answers please refine your question :>
01:13:51 <geekosaur> ^
01:14:00 <gentauro> geekosaur: somebody here refered to this approach -> https://pdfs.semanticscholar.org/c42c/2dcd3ab811c85e3962c31fb5f12ee5965b63.pdf
01:14:22 <gentauro> "The Arithmetic of Recursively Run-length Compressed
01:14:23 <gentauro> Natural Numbers"
01:14:41 <quchen> Okay.
01:14:43 <gentauro> but I guess it's slower than HS "built-in" Integers
01:15:05 <gentauro> quchen: geekosaur 1 billion digits?
01:15:11 <gentauro> 1 trillion digits?
01:15:12 <gentauro> :D
01:16:39 <quchen> Well, try benchmarking it, > 10^(10^9) `mod` 12
01:17:22 <quchen> That’ll stop being fun unless you order a truckload of RAM soon though
01:18:02 <quchen> If we’re talking numbers the size of Gödel numbers then at some point you’ll have to ask yourself whether running that on a computer is a good idea :-)
01:20:50 <cocreature> gentauro: http://www.wilfred.me.uk/blog/2014/10/20/the-fastest-bigint-in-the-west/ has some benchmarks where GHC comes out pretty well
01:20:54 <geekosaur> by the time you get to a billion digits, you may want to consider alternative approaches like throwing number theory at them first to reduce them to something mroe tractable
01:21:18 <geekosaur> the phrase "unbearable trial and colossal error" comes to mind
01:21:54 * quchen puts »colossal« into his active vocabulary
01:22:26 <gentauro> cocreature: :o
01:23:03 <gentauro> Would love to see C there as well just to see how close HS really is :)
01:24:07 <pally> `Maybe` is considered a "type constructor"
01:24:26 <pally> Is `State s` (w/o the 'a' parameter') considered a type constructor?
01:25:06 * hackage battleplace 0.1.0.7 - Core definitions for BattlePlace.io service  http://hackage.haskell.org/package/battleplace-0.1.0.7 (quyse)
01:25:13 <quchen> Yes, you could say that. (State s) takes another parameter to become a type that has values.
01:25:23 <quchen> We call those types »of kind * (star)«.
01:25:44 <quchen> (State s) has kind * -> *, meaning it takes another parameter to become a type of kind *.
01:25:50 <cocreature> I’d say the type constructor is State, not State s
01:26:07 * hackage battleplace-api 0.1.0.3 - Public API definitions of BattlePlace.io service  http://hackage.haskell.org/package/battleplace-api-0.1.0.3 (quyse)
01:26:08 <cocreature> just like I wouldn’t call "(,) 1" a constructor
01:26:09 <quchen> Similarly, a -> b -> c is a function, and if you apply it to an a you get a b -> c which is still a function.
01:48:41 <lavalike> pavonia: did you get your range-indexed zippable map working? (:
01:52:22 <fredefox> Howdy everyone, how do I declare a deriving instance with a type family constraint?
01:52:30 <fendor> on windows, my haskell-ide-engine dies because of the cabal-helper-wrapper.exe (https://hastebin.com/hequgixove.sql)
01:53:03 <alanz> fendor, do you have cabal-install installed on your machine?
01:54:14 <fendor> alanz, well, apparently not, `stack install cabal-install` at least installs somehting...
01:54:37 <alanz> ok, hopefully that will sort out the problem
01:54:50 <pavonia> lavalike: Not yet, but I think the IntervalMap brought me a step closer
01:56:11 <fendor> thanks, i suppose, it probably will
01:57:54 <fendor> I actually thought cabal and cabal-install are the same packages...
01:58:08 <philippD> fredefox: Do you mean a typefamily with kind Constraint as a constraint on the derived class? If so you could use -XStandaloneDeriving
01:59:17 <fredefox> I'm trying to derive `IsSet` from `mono-traversable`
01:59:37 <cocreature> fendor: there is the Cabal package which contains the Cabal library and there is the cabal-install package which provides the executable called "cabal"
01:59:37 <fredefox> GHC complains that the type family application must be *inside* the class instance
01:59:47 <fredefox> but there is no inside since it's a derived instance
02:00:22 <fendor> cocreature, so if i have the executable `cabal`, then `cabal-install` should be installed? because I have the executable
02:00:30 <fredefox> I probably shouldn't have used the word constraint...
02:00:50 <cocreature> fendor: yeah
02:01:09 <cocreature> fredefox: which type family are you talking about? the "IsSet" class doesn’t have an associated type family
02:01:15 <fendor> unfortunate... is it possible that hie does not find the cabal installed with haskell-platform or something like that
02:02:13 <fredefox> So, without the type family application it gives me: "No instance for SetContainer MyType"
02:02:14 <fendor> ok, error is not resolved, restarted the vscode and it still fails to createProcess
02:02:48 <fredefox> *facepalm* I was missing a super class
02:04:07 * hackage snappy-framing 0.1.2 - Snappy Framing Format in Haskell  http://hackage.haskell.org/package/snappy-framing-0.1.2 (KimAltintop)
02:04:14 <fendor> and the program `cabal-helper-wrapper.exe` exists
02:16:17 <ZeuPiark> hello
02:16:52 <lavalike> howdy
02:22:23 <fendor> sorry, internet died, did someone address my problem?
02:23:42 <cocreature> fendor: there are logs in the topic
02:24:06 <fendor> cocreature, i realized and looked it up, no one did :)
02:27:31 <tabaqui1> err
02:27:33 <tabaqui1> https://hackage.haskell.org/package/base-4.11.0.0/docs/src/System.Posix.Types.html#CNlink
02:27:39 <tabaqui1> https://hackage.haskell.org/package/base-4.11.1.0/docs/src/System.Posix.Internals.html#FD
02:27:49 <tabaqui1> look at FD definition in both files
02:28:08 <tabaqui1> in first it is a type CInt, while in second it is newtype CInt
02:28:52 <tabaqui1> and GHC.IO.Handle.FD and System.Posix.IO have duplicates with different Fd type
02:29:15 <merijn> FD and Fd are not the same thing, though
02:30:24 <mreh> I'm trying to compile some Haskell into an android app with -shared and -static, but I get 'dlopen failed: cannot locate symbol "stg_ap_v_info"'
02:30:49 <merijn> heh, -shared *and* -static?
02:31:00 <mreh> merijn: yesh
02:31:08 <mreh> that makes sense to me
02:31:08 <merijn> mreh: That doesn't make sense?
02:32:01 <mreh> the docs say if you supply -static with -shared GHC will compile GHC's and your Haskell dependencies into your library
02:32:24 <tabaqui1> merijn: what is the difference?
02:32:25 <mreh> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html?highlight=#ghc-flag--shared
02:33:46 <merijn> tabaqui1: They are different types that happen to have the same definition. Keep in mind that Hackage docs are build on Hackage itself and thus reflect the results of building on *nix. Some abstractions like FD are implemented differently on Windows, so on windows one of those two might have a different definition
02:34:35 <merijn> mreh: ah, looks like -shared does something different from what I thought
02:34:55 <cocreature> merijn: I think you might have confused -shared and -dynamic
02:35:00 <mreh> marijn: there's some dynamic dependency that I can't track down
02:35:32 <merijn> cocreature: Yeah
02:37:57 <tabaqui1> merijn: so Fd from unix is unix fd, while FD from base is some abstract fd?
02:38:10 <merijn> tabaqui1: Right
02:44:28 <tabaqui1> ok, thanks
02:51:14 <mreh> maybe the RTS isn't linked with -shared -static
03:01:20 <mreh> I think I have found my answer
03:01:34 <mreh> In principle you can use -shared without -dynamic in the link step. That means to statically link the runtime system and all of the base libraries into your new shared library. This would make a very big, but standalone shared library. On most platforms however that would require all the static libraries to have been built with -fPIC so that the code is suitable to include into a shared library and we do
03:01:40 <mreh> not do that at the moment.
03:02:14 <mreh> So, if I compile with -shared and -dynamic, I have to link in all the packages I've used along with the RTS?
03:31:45 <zincy> Is there a more elegant alternative to using (>>) and then return?
03:32:15 <quchen> x <$ action === action >> return x
03:32:18 <Taneb> :t (<$)
03:32:19 <lambdabot> Functor f => a -> f b -> f a
03:32:31 <Taneb> quchen++
03:35:44 <zincy> ooh thanks
03:40:39 <zincy> hmm I am ending up with m m a
03:41:11 <Taneb> zincy: are you doing something like "return x <$ y"?
03:41:17 <zincy> Any ideas why I would end up with an extra monadic layer after changing from >> return to <$
03:41:18 <Taneb> If so, do "x <$ y" instead
03:41:40 <zincy> Ah flip the args?
03:41:47 <Taneb> Yeah
03:42:17 <cocreature> or use $> instead
03:42:18 <zincy> Thanks that worked
03:42:29 <zincy> :t $>
03:42:30 <lambdabot> error: parse error on input ‘$>’
03:42:35 <zincy> :t ($>)
03:42:36 <lambdabot> error:
03:42:36 <lambdabot>     • Variable not in scope: $>
03:42:36 <lambdabot>     • Perhaps you meant one of these:
03:42:40 <zincy> Thanks cocreature
03:42:41 <cocreature> @let import Data.Functor
03:42:43 <lambdabot>  Defined.
03:42:43 <cocreature> :t ($>)
03:42:45 <lambdabot> Functor f => f a -> b -> f b
03:43:10 <zincy> Whats the difference between these operators and standard <$>
03:43:22 <zincy> They dont take a function right just a value?
03:43:33 <zincy> Like an fmap swap
03:43:47 <cocreature> x <$ y = fmap (\_ -> x) y
03:44:09 <marvin3> @src ($>)
03:44:10 <lambdabot> Source not found. I've seen penguins that can type better than that.
03:46:14 <quchen> const x <$> f   ===   x <$ f
03:46:18 <zincy> :) Thanks
03:46:29 <marvin3> weird, lambdabot's type is different than what I'm getting in ghci
03:46:40 <marvin3> (*>) :: Applicative f => f a -> f b -> f b
03:46:46 <marvin3> there are two *>?
03:47:04 <quchen> <* too, yes.
03:47:07 * hackage Win32-services 0.4 - Windows service applications  http://hackage.haskell.org/package/Win32-services-0.4 (gussen)
03:48:56 <cocreature> marvin3: *> and $> are not the same symbol
03:49:59 <marvin3> good point! looking at the screen from 6 ft away
04:02:23 <ZeuPiark> hello
04:04:14 <Athas> Any simple way to copy a directory from Haskell?
04:05:45 <lavalike> Athas: maybe this package http://hackage.haskell.org/package/filesystem-trees-0.1.0.6/docs/System-File-Tree.html#v:copyTo
04:06:20 <Athas> lavalike: it has not been updated since 2015 and its restrictive upper bounds prevent it from working.
04:06:35 <Athas> Something like shelly could work, but it's a great big hammer.
04:09:23 <xenon-> hi
04:10:09 <xenon-> is Parsec still the library most people turn to?
04:10:24 <cocreature> xenon-: I use megaparsec for most of my parsing tasks these days
04:10:44 <xenon-> does it have any advantages over Parsec?
04:10:45 <Taneb> xenon-: megaparsec is a more modern fork of parsec
04:10:55 <Athas> Megaparsec is Parsec, just better.
04:11:04 <Athas> Faster, better error messages, more readable code.
04:11:13 <Taneb> https://github.com/mrkkrp/megaparsec#megaparsec-vs-parsec
04:12:10 <cocreature> I’d say for new projects the only reason to choose parsec over megaparsec would be that you have to worry about the slightly larger dependency footprint (e.g. for Cabal depending on megaparsec was probably not an option so they chose parsec)
04:13:22 <merijn> xenon-: megaparsec started as a straight fork of Parsec, but focussed on fixing warts. So aside from backwards compat and smaller dependency footprint I'd say megaparsec is probably superior to parsec in every way
04:14:01 <merijn> especially parsec's operators conflicting with Control.Applicative is super annoying
04:14:15 <merijn> That alone feels like a good enough reason to switch
04:14:35 <xenon-> that has annoyed me as well.. I went through the list on that page, and I'm convinced. I'll go for megaparsec for this project
04:15:25 <merijn> xenon-: It's because Control.Applicative was invented after parsec :p
04:17:12 <merijn> Most of the conflicting operators in Control.Applicative were actually copied from/inspired by parsec
04:21:36 <xenon-> merijn, that is no fault of parsec then I guess.except for not removing Parsec specific operators after the fact (assuming Applicative ones worked)
04:22:33 <merijn> xenon-: The applicative ones were given slightly different precedence, so updating parsec would've potentially broken existing parsec code
04:24:09 <lavalike> Athas: or you could lift the implementations of the handy functions you need from it (:
04:29:43 <pally> @let data X = C{a::Int, b::Bool} deriving (Show)
04:29:45 <lambdabot>  Defined.
04:30:57 <pally> > foo = C 3 True
04:30:59 <lambdabot>  <hint>:1:5: error:
04:30:59 <lambdabot>      parse error on input ‘=’
04:30:59 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
04:31:06 <pally> > C 3 True
04:31:08 <guessWho> i am getting this runtime error what does this mean "writev: does not exist (Connection refused) Main: file descriptor 178671616 out of range for select (0--1024). Recompile with -threaded to work around this."
04:31:09 <lambdabot>  C {a = 3, b = True}
04:31:26 <pally> > foo = (C 3 True)
04:31:28 <lambdabot>  <hint>:1:5: error:
04:31:29 <lambdabot>      parse error on input ‘=’
04:31:29 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
04:33:18 <pally> Is there a way to access the components 'a' and 'b' ?
04:33:25 <cocreature> guessWho: have you tried following the suggestion?
04:33:33 <lavalike> guessWho: it seems like people have been reporting it as a misleading error message in the past, but the solution working
04:33:42 <lavalike> pally: definitely
04:33:52 <cocreature> > let foo = C 3 True in a foo
04:33:54 <lambdabot>  error:
04:33:54 <lambdabot>      Ambiguous occurrence ‘a’
04:33:54 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.a’,
04:34:01 <cocreature> meh
04:34:14 <lavalike> > let foo = C 3 True in (\(C a b) -> (a == 3) && b) foo
04:34:16 <lambdabot>  True
04:34:41 <lavalike> i.e. pattern matching is a way
04:36:02 <pally> lavalike, I understand our example, but you don't find that awkward?
04:36:10 <cocreature> or use the record selectors called "a" and "b"
04:36:12 <pally> your*
04:36:30 <pally> cocreature, example?
04:36:44 <lavalike> > let foo = C 3 True in (\c -> (a c == 3) && b c) foo
04:36:45 <merijn> > a (C 3 True)
04:36:46 <lambdabot>  error:
04:36:46 <lambdabot>      Ambiguous occurrence ‘a’
04:36:46 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.a’,
04:36:47 <lambdabot>  error:
04:36:47 <lambdabot>      Ambiguous occurrence ‘a’
04:36:48 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.a’,
04:36:52 <merijn> > L.a (C 3 True)
04:36:53 <lavalike> haha
04:36:54 <lambdabot>  3
04:36:55 <cocreature> pally: the one I showed above (which failed due to lambdabot being annoying but it works in general)
04:37:05 <merijn> cocreature: Just qualify it with L :)
04:37:12 <merijn> > L.b (C 3 True)
04:37:14 <lambdabot>  True
04:37:17 <cocreature> merijn: ah right, I had forgotten about that :)
04:37:22 <lavalike> funny
04:37:49 <merijn> lavalike: Local definition from @define are stored in L.hs for lambdabot, so that disambiguates conflicts :)
04:37:50 <cocreature> you can also use record syntax when pattern matching
04:38:03 <cocreature> the NamedFieldPuns and the RecordWildCards extension might also be worth a look
04:38:04 <lavalike> merijn: I see!
04:38:31 <merijn> And SimpleReflect's a is kinda neat too
04:38:39 <merijn> > foldr f z [a,b,c]
04:38:41 <lambdabot>  error:
04:38:41 <lambdabot>      Ambiguous occurrence ‘a’
04:38:41 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.a’,
04:38:50 <lavalike> except now it's ambiguous the other way too
04:38:55 <merijn> > foldr f z [Debug.SimpleReflect.a,Debug.SimpleReflect.b,c]
04:38:57 <lambdabot>  f a (f b (f c z))
04:39:08 <pally> Prelude> L.a (C 3 True)
04:39:08 <pally> <interactive>:28:1: error:
04:39:08 <pally>     Not in scope: ?L.a?
04:39:08 <pally>     No module named ?L? is imported.
04:39:14 <lavalike> > foldl f z [c,d,e]
04:39:16 <lambdabot>  f (f (f z c) d) e
04:39:21 <merijn> pally: The L is lambdabot specific
04:39:42 <merijn> pally: Just use "a"
04:40:09 <merijn> lavalike: It's using typeclass voodoo: https://hackage.haskell.org/package/simple-reflect
04:40:14 <merijn> lavalike: Pretty neat, actually :)
04:42:18 <lavalike> > minimum [x,y,z]
04:42:20 <lambdabot>  min (min x y) z
04:42:23 <lavalike> lovely
04:43:07 * hackage madlang 4.0.2.8 - Randomized templating language DSL  http://hackage.haskell.org/package/madlang-4.0.2.8 (vmchale)
04:43:51 <guessWho> cocreature : i want to understand what the error actually means and what the suggestion is going to do >>
04:43:52 <guessWho> ?
04:44:13 <lavalike> guessWho: https://ghc.haskell.org/trac/ghc/ticket/4351#comment:1
04:45:50 <cocreature> GHC has two runtimes: the single-threaded runtime and the multi-threaded runtime enabled by compiling with -threaded
04:46:12 <cocreature> apparently the single-threaded runtime uses the "select" syscall which has some limitations that you are running into here
04:46:26 <cocreature> the multithreaded runtime doesn’t have this limitation
04:49:05 <[exa]> guessWho: select() has a limit on monitored file descriptors. It kindof looks like you're leaking open file descriptors though, with 178 millions
04:50:03 <hpc> ouch
04:50:12 <bwe> Is there reall no better way than relying on QuickCheck to pick a random element from a list? https://stackoverflow.com/a/27883428
04:50:15 <hpc> my box doesn't even have that many inodes on its filesystems
04:50:37 * hackage primitive-extras 0.4 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.4 (NikitaVolkov)
04:50:56 <merijn> cocreature: I don't think the single-threaded one always uses select? Although I admit I'm not sure :p
04:51:56 <hpc> bwe: that's kind of a weird answer to that question, quickcheck is a testing framework
04:52:18 <hpc> bwe: decompose it into two problems - indexing a list, and picking a random number in the range of that list's length
04:53:16 <cocreature> merijn: what do you mean by “always”? I guess if you don’t do any file IO it might not use "select" but iirc most of the file IO is proxied using "select"
04:53:45 <merijn> cocreature: I somehow thought it used something like epoll even in the unthreaded one, except on some platforms
04:53:55 <hpc> bwe: then instead of using quickcheck to write randItem, it's something like randItem list = do {ix <- rng 0 (length list); return (list !! ix);}
04:54:15 <cocreature> merijn: last I checked linux used "select". no idea about other platforms
04:54:26 <merijn> cocreature: I could be wrong
04:54:26 <hpc> rng might be something with randomIO, or maybe you use your own StdGen in some stateful computation
04:54:48 <hpc> bwe: see also http://hackage.haskell.org/package/random
04:57:16 <lukelau> Does anyone know where stack installs ghc to on windows?
04:58:22 <quchen> lukelau: Run »stack path --programs«
04:58:23 <cocreature> lukelau: try "stack path --programs"
04:58:32 <cocreature> heh
04:58:41 <lukelau> I’m not on a windows machine unfortunately
04:58:53 <lukelau> I’m trying to setup caching on an appveyor build
04:59:02 <lukelau> Is it supposed to be in c:\sr?
04:59:08 <quchen> Then write a script to run »stack path --programs« and use the output of that
04:59:39 <lukelau> touché
05:10:09 <bwe> hpc: Will do so. Thanks for your guidance!
05:12:45 <bwe> How is the extension called that automagically fills out the record names with the names in the current namespace?
05:14:53 <cocreature> bwe: RecordWildCards
05:17:38 <bwe> cocreature: Thanks ;).
05:25:55 <dminuoso> I have the need to store two pool of IP addresses (one for IPv4 addresses and one for IPv6 prefixes), from which I can hand out an IP address to an interested party or collect one.
05:26:12 <dminuoso> Ive been pondering about this for a while and I think a trie might be a good fit. Am I on the wrong track here?
05:26:29 <merijn> why a try?
05:26:38 <merijn> eh, trie
05:26:47 <merijn> Do you ever need to lookup prefixes?
05:27:46 <dminuoso> merijn: Possibly yes.
05:29:19 <pally> I find that emacs is more popular among Haskell programmers over vim; is there some native support in emacs that makes it for favourable?
05:29:22 <dminuoso> Okay lets separate this. IPv4 is less of an issue, here I could just keep a static list of the entire pool since it's not an issue.
05:29:51 <merijn> pally: I'd say the editor distribution here is about 1/3rd vim, 1/3rd emacs, 1/3rd miscellaneous (atom, VS Code, whatever the cool kids use now)
05:30:13 <merijn> pally: So I disagree with your starting point. You probably just have a biased sample of programmers :)
05:30:52 <Taneb> My office of Haskell programmers, for example, is almost entirely vim or neovim
05:31:07 <Taneb> There's one guy using Atom and one guy using Spacemacs (I think)
05:31:30 <Lowl3v3l1> i suppose people tend to not choose a "new" editor for haskell but just continue using the one they already used
05:31:45 <merijn> Lowl3v3l1: Pretty much, yes
05:31:56 <Lowl3v3l1> i am another guy with spacemacs( but hey its just emacs with some nice defaults and vim keybindings :P)
05:32:05 <__monty__> Lowl3v3l1: That's how I choose my editor for *any* language : )
05:32:23 <dminuoso> merijn: The reason for using a trie (or a radix tree I guess?) is that it would be space efficient even if gaps started forming. Finding an empty slot seems trivial
05:32:31 <Taneb> I switched from emacs to neovim when I started here (because I've found emacs difficult to set up for Haskell in the past and I wanted to make a change)
05:37:36 * hackage quickcheck-classes 0.4.14.1 - QuickCheck common typeclasses  http://hackage.haskell.org/package/quickcheck-classes-0.4.14.1 (andrewthad)
05:41:41 <tdammers> haskell as a language is pretty oblivious to editors; whatever works well for your day-to-day general-purpose editing needs will typically also work well for Haskell
05:41:53 <tdammers> you simply won't need a lot of support from the editor to be productive
05:42:13 <Taneb> ^
05:42:29 <mniip> code completion only works out for languages with subtyping
05:42:40 <merijn> Having warnings/errors highlighted in the editor is helpful and a bit brittle with new-build atm, sadly :\
05:43:23 <tdammers> many of the things that are typically implemented as IDE features or external tooling are simply not needed in Haskell, because the language has them built in, or has features built into it that render them redundant
05:43:55 <mniip> merijn, if only compilers could agree on an error message format
05:44:05 <tdammers> e.g., I see people maintain entire libraries of "code snippets", essentially little templates that allow them to quickly pump out parametrized boilerplate
05:44:25 <tdammers> whereas in Haskell, the idiomatic approach is to distill the boilerplate into a proper abstraction and then use that
05:44:25 <merijn> mniip: The issue isn't that. The issues is knowing how to run the compiler on a file to get errors/warnings
05:44:37 <mniip> that too
05:44:55 <tdammers> "jump to error" is probably the one thing I'm missing right now
05:45:25 <lavalike> I have switched to no syntax highlighting or other amenities to see what would happen a couple years ago and it happened that I stuck with it and have been very happy since.
05:46:33 <merijn> tdammers: Vim supports that easily enough if you get the error highlighting working
05:46:49 <tdammers> merijn: "if"
05:47:24 <tdammers> merijn: I just don't feel like going through the trouble of getting it to understand the error output of six different GHC versions run through four different build tools simultaneously
05:47:38 <merijn> tdammers: Right. With a bit of luck I finish writing this thesis chapter before thursday and then I need to do some Haskell hacking again, at which point I might finally invest the effort to get my new-build highlighter working good enough to use
05:48:43 <lavalike> I remember yi back in the day promised actual syntax highlighting based on parsing, everything else always seemed broken, but I'm not using yi hehe
05:49:42 <Taneb> Hmm
05:49:50 <mniip> syntax highlighting sounds like it might be related to monoidal parsing
05:49:58 <xsperry> Taneb does neovim give you correct indenting? I am stuggling to get that working in emacs. everything else works (repl, function name completion, type hints), but not indenting
05:50:17 <tdammers> I think one of the reasons VS syntax highlighting is so good is because the languages it parses were designed specifically with an IDE in mind
05:50:20 <Taneb> xsperry: I've not been frustrated by it
05:50:22 <mniip> in the sense that you want to elaborately tokenize the part of the code you're looking at, but merely skim the rest to figure out what context you're in
05:50:50 <Taneb> I wonder if there's a case for adding a GHC flag to output errors + warnings in a machine-readable format
05:51:01 <tdammers> mniip: for many languages, "figure out what context you're in" more or less amounts to doing most of the actual parsing
05:51:26 <tdammers> Taneb: I believe people are talking about exactly that
05:51:38 <mniip> if you're lenient,
05:51:42 <tdammers> Taneb: also, exposing AST in a uniform, machine-readable format
05:52:02 <Taneb> tdammers: both of those I think would be super cool and useful for editor integration
05:52:12 <Taneb> I'm surprised it's not a thing that everything does
05:52:52 <mniip> tdammers, instance Show (HsExpr p)  :P
05:53:14 <tdammers> mniip: problem is that that's 1) not easy to parse, and 2) subject to change with every GHC release
05:54:05 <mniip> instance Read (HsExpr p) :D
05:54:11 <mniip> true though
05:55:05 <mniip> what would you rather use?  Tree String?
05:55:06 <tdammers> ideally, you'd want to be able to do something like have GHC 8.6 parse a file, poop out AST, run a Python script over it, and then read it back into GHC 8.10 or something
05:56:02 <tdammers> so it would have to be built on top of something somewhat standard, and it would have to have a reasonable degree of forward and backwards compatibility designed in
06:05:08 <xsperry> Sacha Baron Cohen's show featured Georgia state Rep. Jason Spencer yelling all sorts of horrifying racial epithets. GOP State Lawmaker Screams 'N****r,' Brandishes Bare Butt On 'Who Is America?' https://www.huffingtonpost.com/entry/rep-jason-spencer-screams-n-word-brandishes-bare-butt-on-who-is-america_us_5b5545b1e4b0de86f48e5a5e
06:05:14 <xsperry> how dumb are these people?
06:06:28 <adjofun> is that a request for a haskell code to measure dumbness? =)
06:07:00 <merijn> adjofun: He's spamming that in many channels
06:07:29 <adjofun> but why tho
06:07:29 * [exa] interested why huffington post would need spammers
06:07:43 <xsperry> calling it spam suggests I am profiting from this
06:08:04 <xsperry> as opposed to just sharing something funny with fellow programmers
06:08:47 <[exa]> oh okay
06:09:01 <quchen> It’s offtopic and unwanted here.
06:09:03 <[exa]> I find it quite sad though
06:09:03 <tdammers> thing is, #haskell is a rather big channel, and people kind of prefer it being about Haskell
06:09:23 <tdammers> if you want to post things that aren't directly haskell-related, there's haskell-offtopic and haskell-blah
06:09:57 <Lowl3v3l1> funny jokes are abslutely fine. as long as they are about haskell.
06:10:15 <merijn> Spam is any unwanted mass communication, not just for-profit unwanted mass communication
06:11:04 <Taneb> Lowl3v3l1: what about unfunny jokes about Haskell like "Knock knock / who's there? / Mona / Mona who? / Monads are just monoids in the category of endofunctors"
06:11:24 <Lowl3v3l1> not bad! :D
06:12:03 <dminuoso> https://ro-che.info/ccc/11
06:12:27 <Lowl3v3l1> https://u.cubeupload.com/zZMoRL.jpg
06:13:06 * hackage shake-google-closure-compiler 0.1.0.0 - Shake rules for the Google closure compiler  http://hackage.haskell.org/package/shake-google-closure-compiler-0.1.0.0 (vmchale)
06:13:09 <gentauro> are HS arrays -> http://hackage.haskell.org/package/array-0.5.2.0/docs/Data-Array.html allocated in stack over heap?
06:13:23 <mniip> gentauro, what's a stack
06:13:41 <gentauro> mniip: type of memory
06:14:06 <mniip> the GHC runtime does not use conventional "C" types of storage
06:14:15 <merijn> gentauro: there's no real notion of stack/heap as in imperative languages
06:14:22 <merijn> gentauro: For example, there is no call stack at all
06:14:53 <gentauro> merijn: -> *** Exception: stack overflow
06:14:53 <gentauro> :D
06:14:58 <merijn> gentauro: The only stack used by GHC is the pattern match stack, and even that one isn't similar to, say, C stacks, as it is not limited and can grow
06:15:09 <merijn> gentauro: That's not a call stack overflow, it's a pattern match stack overflow
06:15:25 <gentauro> merijn: hmmm
06:15:50 <quchen> Anyway, Array is on the Heap. :-)
06:16:01 <gentauro> quchen: :D :D :D
06:16:22 <gentauro> quchen: thought so ... that's why I'm implementing my own immutable arrays on the "stack" :P
06:16:24 <merijn> Also, lemme take this chance to tell you about the wonders of our lord and saviour, vector :)
06:16:33 <gentauro> but it seems that I reach SO pretty fast ..
06:16:34 <[exa]> the continuation stack mentioned in the STG commentary exists no more?
06:16:47 <merijn> [exa]: That *is* the pattern match stack :)
06:17:00 <gentauro> merijn: my iarray are pretty much the bestets that has ever been implemented in HS
06:17:04 <[exa]> oh okay
06:17:05 <merijn> [exa]: The pattern match stack tracks the possible continuation that are taken after matching a pattern
06:17:07 <gentauro> I mean it's pretty much LULZ
06:17:33 <gentauro> (I'm just "pushing" the language to it's boundries ... and beyond) :D
06:17:46 <merijn> [exa]: So you can think of it as "the stack of pending pattern matches" or "the stack of continuations that have to be used after pattern matches finish"
06:18:01 <merijn> Potato, potato ;)
06:18:09 <[exa]> hm ok, cool
06:18:18 <[exa]> gentauro: anyway what trick are you using to stackoverflow it?
06:18:40 <quchen> Arrays on the stack in GHC, that’s going to be fun.
06:18:51 <quchen> It’s very esoteric and highly impractical, but maybe it’s possible.
06:19:01 <gentauro> [exa]: one second, I will just move code around and I will post an lpaste snippet in af few minutes :D
06:19:26 <dminuoso> gentauro: If you are curioous you might want to take a look at this paper, it's really accessible for the most part https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf
06:20:08 <quchen> Or you look at the implementation of that paper, https://github.com/quchen/stgi/
06:22:23 <gentauro> dminuoso: and quchen thx
06:26:17 <mniip> hmm
06:27:05 <mniip> I notice Milner's paper calls "monotonic" functions "continuous"
06:27:56 <mniip> is that because to each join-semilattice with a maximal element you can correspond a topological space?
06:30:05 <[exa]> which one paper?
06:30:46 <mniip> A theory of type polymorphism in programming, 1978
06:32:56 <Taneb> mniip: hmm, you can assign to each topological space a join-semilattice over the open sets
06:33:09 <Taneb> With the relation "is a subset of" and join being union
06:33:33 <mniip> can you do the opposite however?
06:33:34 <phadej> Top is a category of topological spaces and continuous functions; Ord is a category of preordered sets with monotonic functions
06:33:44 <Taneb> But I'm not sure if continuity and monotonity correspond with that notion
06:33:58 <phadej> zoom far enough, and it's all quite the same
06:34:02 <mniip> Taneb, this is like a functor from Top to Ord and back
06:34:02 <Taneb> mniip: not trivially, but probably
06:34:14 <phadej> (especially if your topology is based on set theory)
06:36:53 <mniip> well consider the total order on [-infty, +infty]
06:37:05 <mniip> you can definitely assign to each x the set {y | y < x}
06:37:33 <mniip> together with the complement of the empty set that makes a topology
06:37:52 <mniip> question is how much you can loosen this
06:37:53 <Taneb> mniip: hmm, can you do that for any join semilattice?
06:38:09 <mniip> can you use a partial order? do you need global maxima/minima
06:38:11 <Taneb> Assign to each x the set {y | y < x}
06:38:26 <Taneb> Without a join you don't get a topological space
06:39:09 <mniip> if your semilattice isn't bounded you're missing either the empty set or its complement
06:39:41 <Taneb> Ack, you're right
06:39:59 <mniip> and you do need infinitary joins
06:40:47 <Taneb> You're double right (I don't know latices as well as I'd like)
06:41:08 <mniip> me neither. I'm paging wikipedia into my brain as we speak
06:41:13 <Taneb> :)
06:41:21 <lin__> Evening, I want to filter my own type: data MyOType = SubtypeA {a::String, b::Int} | SubtypeB {c::Int, b::Int}
06:41:52 <mniip> Taneb, I feell like you might need to add other sets
06:41:55 <merijn> lin__: And you wanna keep all SubtypeA's from a list?
06:42:02 <lin__> I have a list of MyOType und want to only act on SubtypeA things, but I am failing to create the right pattern match or filter
06:42:11 <lin__> merijn: yes
06:42:25 <mniip> Taneb, if you have a lattice that looks like the letter M
06:42:27 <merijn> lin__: Try the following magic: "[x | x@SubtypeA{} <- yourList]" :)
06:42:41 <Taneb> mniip: then you don't have join?
06:42:43 <mniip> then the intersection of the two sets corresponding to the top points
06:42:45 <dminuoso> Is there an elegant way to avoid this duplicated case? https://gist.github.com/dminuoso/4d542584bb6ccb47ac6ac83671311845
06:42:53 <merijn> > [x | x@Left{} <- [Left True, Right 1, Left False, Right 5]]
06:42:53 <Taneb> Unless I'm upside-down
06:42:55 <lambdabot>  [Left True,Left False]
06:42:55 <mniip> okay complete it to a lattice
06:43:09 <mniip>  /\
06:43:10 <mniip> /\/\
06:43:47 <merijn> dminuoso: add a where clause with a function that takes o and a string and then use that?
06:44:31 <mniip> naming the points a,b,c,d,e,f:  b=join(d,e); c=join(e,f); a=join(b,c)
06:44:43 <dminuoso> merijn: what string are you referring to?
06:44:49 <dminuoso> mniip: the family?
06:44:52 <mniip> under our topological functor
06:44:55 <merijn> dminuoso: the "local" thing
06:44:55 <dminuoso> Oops..
06:45:03 <mniip> b mapsto {d, e},  c mapsto {e, f}
06:45:18 <mniip> then {d, e} intersection {e, f} = {e} should be an open set too
06:45:23 <dstolfa> mniip: hmmm, how is that a lattice? :)
06:45:27 <mniip> but it's not of the form {y | y < x}
06:45:31 <dstolfa> mniip: it needs a unique supremum and a unique infimum
06:45:32 <mniip> dstolfa, it is a join-semilattice
06:45:35 <dstolfa> ah
06:45:36 <dstolfa> okay then
06:45:43 <dstolfa> i'm happy with that
06:45:50 <merijn> dminuoso: The only difference in the two uses of case is the string passed to .:, so just abstract that out
06:46:11 <mniip> Taneb, oh I think I know
06:46:32 <dminuoso> merijn: but that wont get rid of the case
06:46:42 <dminuoso> (unless I re-parse the `family`)
06:46:43 <mniip> if L is a join semilattice, then to each subset A of L we correspond the set {y | forall x in A, y < x}
06:46:47 <merijn> dminuoso: But you'll only have one?
06:47:31 <merijn> dminuoso: pattern matching on a single constructor like Inet is going to be utterly negligible
06:47:55 <dminuoso> merijn: Its definitely not about performance - at all.
06:48:05 <mniip> this will automatically generate the empty set when A=L, and the whole space when A=nothing
06:48:29 <lin__> thanks merijn for the magic
06:49:10 <Taneb> mniip: does this get us the property that we want, that monotone and continuous functions correspond?
06:49:17 <dminuoso> merijn: https://gist.github.com/dminuoso/4d542584bb6ccb47ac6ac83671311845 something along those lines?
06:49:33 <mniip> Taneb, for finite L I think it does
06:49:38 <Taneb> :)
06:49:42 <mniip> for infinite L you need a stronger condition
06:50:47 <merijn> dminuoso: Ah, the with ruins a simple where, but you can still do it with let
06:51:15 <dminuoso> merijn: yeah no worries, I presumed you'd know I'd do that. :P
06:51:36 <dminuoso> ah or not! I see what you mean
06:51:40 <POGtastic> tfw you type a question into IRC and answer your own question while typing it :/
06:51:50 <POGtastic> i've done that three times in the last five minutes
06:52:04 <merijn> dminuoso: I was thinking along these lines: https://bpaste.net/show/6b23609d67b9
06:52:27 <dminuoso> merijn: Ah. That looks about right.
06:52:35 <merijn> POGtastic: It's called rubber ducking :)
06:52:36 <mniip> Taneb, lemme sketch a proof
06:52:56 <merijn> POGtastic: Or rubber duck debugging :p
07:08:56 <orion> I am building a "ConduitT i AMQP.Message m ()". These AMQP messages require positive acknowledgement. Given that conduit is "pull" based, is it safe for me to use this logic?: 1. getMsg, 2. yield 3. ackMsg
07:09:36 <orion> The underlying assumption I have is that step 2 will block until the message is processed by the sink.
07:15:40 <Boarders> the description here: https://hackage.haskell.org/package/compact-0.1.0.1 says this only works with GHC 8.2
07:15:50 <Boarders> does this mean 8.2 and above or only 8.2?
07:16:12 <Boarders> I don't currently have a good way to test it out but figure somewhere here might just know
07:16:54 <quchen> FWIW bgamari and ezyang are the authors of that package, Boreeas
07:16:59 <quchen> Boarders I nmean
07:17:05 <merijn> Boarders: Compact regions were added in GHC8.2, so I'm guessing it means 8.2 and up
07:17:15 <merijn> Boarders: But maybe no one has tested/updated bounds for 8.4 yet
07:17:36 <Boarders> That was my impression too
07:18:11 <Boreeas> :)
07:18:56 <bgamari> Boarders, hmm, yes, good call
07:25:06 <bgamari> Boarders, I've fixed the language
07:25:22 <infandum> We need strictness if we want (!i, !j, !k) -> i + j + k to prevent leaks. Do I need those bangs for (i, j, k) -> ((i, j), k) ?
07:25:26 <bgamari> at least upstream; I'll probably cut a new release for GHC 8.6
07:25:45 <Boarders> cool, thanks!
07:27:17 <bgamari> infandum, matching on (i, j, k) will only force the (,,) constructor; it won't force i, j, or k
07:28:24 <infandum> bgamari: but that would only lead to leaks if I use some kind of accumulator, right?
07:29:18 <bgamari> infandum, I think I need to see a more concrete example
07:30:37 * hackage hapistrano 0.3.5.9 - A deployment library for Haskell applications  http://hackage.haskell.org/package/hapistrano-0.3.5.9 (juanpaucar)
07:30:54 <infandum> bgamari: It would just be converting a list of (i, j, k) to ((i, j), k)
07:31:15 <bgamari> accumulating how?
07:31:49 <mniip> bgamari, interesting, is #...# some kind of inline comment in haddock? The documentation related to compacts in GHC.Prim is especially unreadable
07:32:42 <bgamari> mniip, I suspect the problem is not haddock but rather the preprocessor that generates the documentation for GHC.Prim
07:32:47 <infandum> bgamari: No accumulation
07:32:49 <bgamari> there was recently a patch which fixed this
07:33:09 <bgamari> hmm, I'm confused
07:33:46 <mniip> -- | Returns 1# if the object is contained in the compact, 0# otherwise.
07:33:51 <mniip> "Returns 1 otherwise."
07:34:10 <nshepperd1> (\(i, j, k) -> i + j + k) is already about as strict as it can be
07:34:46 <mniip> bgamari, looks like the comments look fine in the .hs stub
07:34:57 <bgamari> mniip, hmm, interesting
07:35:02 <nshepperd1> Assuming i,j,k are a typical flat number type like Int
07:36:37 <bgamari> mniip, I suspect this is the syntax it's hitting: http://haskell-haddock.readthedocs.io/en/latest/markup.html#anchors
07:37:06 <mniip> bgamari, maybe consider @0#@
07:37:55 <piark_> hello
07:40:33 <wz1000> bgamari: could you take a look at my comments on #hackage?
07:40:38 <bgamari> piark_, hi
07:40:40 <bgamari> wz1000, sure
07:44:45 <dmj`> glguy: My lexer went from 30 micros to 20 micros parsing a small document when switching from String to strict ByteString, Text oddly took ~40 micros.
07:45:21 <clever> dmj`: what about lazy text?
07:45:46 <clever> in theory, a lazy text can just be a reference to the original input text, an offset, and a length
07:45:53 <clever> so it wont have to do any copy's
07:46:00 <mniip> how are you timing this
07:46:24 <dmj`> mniip: criterion
07:47:05 <dmj`> mniip: I have a quasi quoter that I can write the language in, and it parses into the raw AST. I think pretty print it back into a ByteString
07:47:29 <dmj`> clever: the issue is how alex handles input
07:47:39 <dmj`> clever: text uses an Array of Word16
07:47:52 <dmj`> clever: ByteString is a linked list of Word8 which is exactly what alex wants
07:48:19 <cocreature> ByteString is not a linked list
07:48:21 <merijn> dmj`: ByteString isn't a linked list of Word8...
07:48:31 <merijn> It just lets you convert to that
07:48:38 <clever> pretty sure ByteString is a foreignptr
07:48:39 <mniip> lazy bytestring is a linked list of word8 blocks, but still
07:49:10 <dmj`> The point is that you need to produce a utf8 encoded list of Word8s
07:49:24 <dmj`> String and Text give you a Char, but then you need to properly translate Char to [Word8]
07:49:36 <dmj`> which is where the overhead comes in
07:49:37 <merijn> dmj`: Eh, you just encode Text to ByteString?
07:49:50 <merijn> You don't translate one Char at a time
07:49:56 <dmj`> merijn: that would be redundant
07:50:26 <dmj`> merijn: alex expects one byte at a time
07:50:46 <dmj`> merijn: you have to manually encode each Char into [Word8]
07:50:47 <dmj`> merijn: https://github.com/simonmar/alex/blob/master/templates/wrappers.hs#L34
07:51:00 <dmj`> merijn: but w/ ByteString you don’t have to
07:51:28 <dmj`> ByteString.uncons doesn’t need to call utf8Encode, but T.uncons does
07:52:04 <clever> https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/src/Data.ByteString.html#uncons
07:52:09 <merijn> dmj`: That's because you don't encode one Char at a time, you just use Data.Text.Encoding to encode the entire bytestring in one go
07:52:25 <clever> dmj`: accursedUnutterablePerformIO  is used by uncons, lol
07:52:27 <merijn> dmj`: Why would you be using T.uncons and encode individual Char?
07:53:07 <clever> https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/src/Data.ByteString.Internal.html#ByteString
07:53:20 <dmj`> merijn: alex operates a Byte at a time, when you have a chunk of Text you need to get the next byte. uncons gives you not a Word8, but a Char which is a unicode code point, which can be up to 4 bytes, this is why you need to translate it from Char -> [Word8]
07:53:27 <clever> merijn: found it, a ByteString is just a strict record, containing a ForeignPtr, an offset, and a length
07:54:43 <merijn> dmj`: You need to reformulate your actual problem. So far you're saying "ByteString works" "text is slow because I need to encode one element at a time" to which I propose that you should encode the entire Text in one go and then just pass the ByteString to alex
07:55:10 <merijn> 'cause I'm lost with what your problem even is at this point
07:57:23 <cocreature> you shouldn’t encode and decode anything. get your input as a ByteString and parse it directly to alex without any intermediate steps
07:57:49 <dmj`> merijn: I have a lexer and parser. I’m trying to tokenize as quickly as possible. I’ve found that lexing on a ByteString performs faster than the equivalent on Text or String. My hypothesis is that this is due to additional allocations required by dealing with Char as opposed to Word8 directly.
07:57:56 <quicksilver> well if his input isn't actually UTF8-encoded then he does have to do something.
07:58:14 <dminuoso> Why is GHCs parser choking on this? https://gist.github.com/dminuoso/fb7ecaf6bbfdbfef2b50bc565d1f7aba
07:58:15 <dmj`> quicksilver: true, and I’m assuming it is.
07:58:38 <merijn> dminuoso: Not indented far enough
07:58:42 <quicksilver> well I think it's probably a mistake to point your finger at allocations per se
07:58:52 <quicksilver> just say "it's slower with Text because Text is not UTF8 encoded"
07:58:54 <merijn> dminuoso: Has to be indented further than 'y'
07:59:24 <quicksilver> I doubt it's the allocations, I'd guess it was the bit-shuffling
08:00:16 <dminuoso> merijn: Oh that's interesting. Thanks
08:00:50 <merijn> dminuoso: If you indent less than 'y' GHC concludes you have ended the let block
08:00:53 <dmj`> quicksilver: yea, I bet you’re right, the document I was benchmarking the parse on was just ASCII, so it wouldn’t have allocated additional cons cells
08:01:20 <Squarism> woh, just found I had a bug because of statement on the form a = a + 1.
08:01:21 <Squarism> ("a" wasnt even defined earlier)
08:01:22 <quicksilver> allocation is faster than you think.
08:01:23 <Squarism> why is that legel even?
08:01:34 <merijn> Squarism: How else would recursion work?
08:01:44 <dmj`> quicksilver: allocation affects speed since GC stops the world
08:02:02 <quicksilver> but local GC is faster than a cache miss
08:02:05 <merijn> Squarism: Consider "map f (x:xs) = f x : map f xs"  <- map has to be defined in its own right hand side to work
08:02:07 <monochrom> Because "x = () : x" is legal.
08:02:19 <quicksilver> so local GCs stop the world for such a short time you don't notice
08:02:20 <quicksilver> maybe
08:02:23 <quicksilver> depends what you are doing.
08:02:43 <Squarism> merijn, i need to think about it for a second. =D
08:02:45 <merijn> Squarism: ML generally special cases this by making you write either "let" or "let rec" (for recursive bindings)
08:02:55 <dmj`> quicksilver: my GC time is 3.2% of the parse, 96.8% productive
08:02:56 <merijn> Squarism: In haskell all bindings are just implicitly recursive
08:03:08 <quicksilver> dmj`: which is pretty low I'd say?
08:03:18 <dmj`> quicksilver: I’m happy with it
08:03:33 <quicksilver> considering the timing differences between the data types you showed earlier were in the 30-50% range
08:05:00 <Squarism> merijn, ok. Right, just thought it wouldnt work with non function values.
08:05:30 <merijn> Squarism: It can be annoying sometimes, but it also lets you do cool stuff
08:05:44 <merijn> > let ones = 1 : ones in ones -- Squarism: like this
08:05:46 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:06:12 <monochrom> which is what I said with "x = () : x" but no one noticed.
08:06:29 <merijn> monochrom: I did, but I went ahead and stole your glory anyway :)
08:07:19 <Squarism> merijn, for plain values its easy to make a typo. Especially in "mutation type" statement sequences.
08:08:32 <Solonarv> there's no in-principle difference between functions and what you call "plain values"
08:09:46 <Solonarv> if you must have an equivalent of "a = a + 1", work in a do block and use "a <- pure (a + 1)"
08:10:21 <mniip> ($ a + 1) $ \a -> ...
08:10:25 <shapr> hopefully I'll get a blog post up on how to generate a shared object from Haskell code, and then use gcc to link it into a C program.
08:11:50 <tdammers> or you could import Control.Lens and then go execState { a += 1 } something -- where a is some lens of type Lens' Something Int
08:12:15 <tdammers> but none of that is very useful for understanding Haskell
08:12:29 <mniip> let a' = a + 1 in let a = a' in
08:12:48 <Solonarv> that way lies madness
08:13:14 <mniip> absolute madman
08:19:44 <quicksilver> > let fib = 1 : 1 : zipWith (+) fib (tail fib)
08:19:46 <lambdabot>  <no location info>: error:
08:19:46 <lambdabot>      not an expression: ‘let fib = 1 : 1 : zipWith (+) fib (tail fib)’
08:19:50 <quicksilver> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib
08:19:52 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:20:30 <quicksilver> Squarism: try not to think in terms of "mutation type" statement sequences at all.
08:20:38 <quicksilver> Squarism: in fact, try not to think in terms of statements.
08:50:10 <bwe> How can I get along with IO here? https://bpaste.net/show/3a6e28d6ce6a
08:51:07 <bwe> liftIO :: IO a -> m a
08:52:07 <bwe> so I am providing pPrint  (m a) while I should provide it `a` only. Is that assumption correct? How do I can untangle the `a` from the `m`?
08:53:05 <Solonarv> I'm not sure what you're trying to do, but whatever it is, this isn't the way to achieve it
08:53:06 * hackage xmonad-vanessa 0.2.0.2 - Custom xmonad, which builds with stack or cabal.  http://hackage.haskell.org/package/xmonad-vanessa-0.2.0.2 (vmchale)
08:53:38 <orbisvicis> monochrom: in "Functions with several Arguments" monotonicity isn't covered, but doesn
08:53:43 <bwe> functionWithIO :: IO MyDataType
08:53:46 <Solonarv> do you want to run functionWithIO and then (pretty-) print the result?
08:53:47 <cocreature> bwe: probably something like "functionWithIO >>= pPrint
08:53:55 <cocreature> but functionWithIO is also not a function :)
08:55:49 <orbisvicis> *doesn't {True a b = a; False a b = b} break monotonicity? Given (True,True,_|_)->True and (False,True,False)->False, can't it be said that (True,True,_|_) <= (False,True,False) but True !<= False
09:01:25 <Zemyla> Anyways, I missed what people said to me before, but what I was thinking was that an Integer can be described as a product between a BigNat and an Int, and if the BigNat is the null BigNat then the Integer's value is that of the Int; otherwise, it's that of the BigNat times 1 if the Int is >= 0 or times -1 if the Int is < 0. Similarly, a Natural can be described as the product of a Word and a potentially null BigNat, and a Rational
09:07:13 <Solonarv> you seem to harbor some misunderstandings about how products work
09:07:29 <Solonarv> in particular, it isn't possible for one of its components to "be null"; this isn't java
09:11:07 * hackage zre 0.1.0.1 - ZRE protocol implementation  http://hackage.haskell.org/package/zre-0.1.0.1 (srk)
09:11:55 <quicksilver> orbisvicis: (True,True,_|_) <= (False,True,False) -- yes this part is true
09:12:10 <quicksilver> True !<= False
09:12:11 <quicksilver> that's also true
09:12:14 <quicksilver> but there is no contradiction.
09:12:21 <quicksilver> erm
09:12:23 <quicksilver> I misread it.
09:12:31 <quicksilver> (True,True,_|_) <= (False,True,False) -- this is false :)
09:12:53 <quicksilver> (False,True,False) is not a correct refinement of (True,True,_|_)
09:13:12 <quicksilver> the only two points above (True,True,_|_) in the definedness order are (True,True,True) and (True,True,False)
09:13:42 <quicksilver> (assuming we can assume that the type of that third param is indeed boolean)
09:19:47 <bwe> cocreature: Exactly what I needed. Thanks.
09:21:20 <orbisvicis> quicksilver: hmm I guess that's covered by the next chapter. So both those tuples are ordered, in the graph, above _|_ (indirectly) but not between themselves. Is there a difference between uncurried tuples ((True,True),_|_) and flat tuples ?
09:22:15 <quicksilver> orbisvicis: they are completely unrelated in teh definedness order, because they are different shapes.
09:22:24 <fishythefish> yes, because there's a difference between _|_ and (_|_, _|_)
09:22:45 <quicksilver> although _|_ and (_|_,_|_) are in fact related :)
09:22:51 <Athas> How come GHC does not build multiple modules concurrently?  I could have sworn it used to do that.  Am I missing some option flag somewhere?
09:22:55 <quicksilver> _|_ <= (_|_,_|_)
09:23:04 <fishythefish> well, _|_ <= anything
09:23:09 <fishythefish> hence "bottom"
09:23:36 <Solonarv> Athas: pass -j4 to compile 4 modules in parallel, etc
09:23:40 <quicksilver> _|_ has no shape information at all - it could be any shape.
09:23:59 <quicksilver> and shape is just an informal intuition for data constructors, mostly.
09:24:01 <Solonarv> generally the number you give should match the number of CPU cores you're using
09:24:02 <lavalike> uhm I upgraded GHC from 8.0 to 8.4 and now a dependency doesn't compile anymore, missing Semigroup instance for the Monoid instance :(
09:24:22 <quicksilver> (the "mostly" is because sometimes we talk about \_ -> _ and lambda is not a data constructor)
09:24:25 <Solonarv> you'll likely need a newer version of that dependency
09:24:35 <lavalike> Solonarv: what if there isn't one
09:24:55 <Athas> Solonarv: oh, nice.  How come stack doesn't pass that by default?
09:24:59 <Solonarv> then I guess you'll have to patch it yourself, or stay on the older GHC version
09:25:33 <Solonarv> Athas: idk, you'd have to check the docs. That same option also works when passing it to stack directly
09:26:59 <lavalike> Solonarv: http://hackage.haskell.org/package/binary-strict https://github.com/idontgetoutmuch/binary-low-level/pull/7 I guess they did add the instance but they didn't make a release?
09:27:40 <glguy> The normal binary package already deserializes from strict bytestrings, so there isn't much use in using a separate package
09:27:47 <Solonarv> sounds likely
09:28:06 * hackage test-karya 0.0.2 - Testing framework.  http://hackage.haskell.org/package/test-karya-0.0.2 (EvanLaforge)
09:28:23 <Solonarv> you can tell stack to fetch packages from a git repo, look at the stack docs to see how
09:28:24 <lavalike> glguy: I used it because it provides a BitBuilder to serialize to a non-aligned binary format
09:28:50 <lavalike> Solonarv: ah interesting, I'm using cabal new-build & company not stack though, maybe I can tell cabal that
09:29:37 * hackage battleplace 0.1.0.8 - Core definitions for BattlePlace.io service  http://hackage.haskell.org/package/battleplace-0.1.0.8 (quyse)
09:29:44 <Solonarv> I don't use cabal directly, but I'm pretty sure that's possible
09:29:55 <cocreature> lavalike: you can’t tell it that directly but you can add it as a submodule and point to it in your cabal.project file
09:30:06 <glguy> To have new-build use git you can clone the package and add the local cone to your packages: section
09:30:35 <cocreature> I think the PR for adding that feature to cabal has actually been merged a few days ago but it’s not in any released version
09:31:36 <nshepperd> people were discussing 'continuous' and 'monotonic' being the same here earlier. iirc the keyword for that fact is 'scott topology' https://en.wikipedia.org/wiki/Scott_continuity
09:31:58 <lavalike> so I replicate their .cabal inside mine basically
09:34:09 <Solonarv> no, no
09:34:40 <Solonarv> you `git clone` the repository into some directory, and tell cabal to look for packages in that directory
09:35:01 <Zemyla> Solonarv: There is a null BigNat in the GHC.Integer.GMP.Internals module. BigNat is a wrapper around ByteArray, and the "null" BigNat is one whose length is 0.
09:35:23 <Solonarv> oh, I see. don't mind me
09:35:45 <lavalike> oh I misunderstood what cloning locally entailed, I clone it to some directory outside my project, and figure out the syntax to depend on that path instead of the hackage package
09:36:12 <orbisvicis> quicksilver: is this the correct definedness of all 2-tuples? https://lpaste.net/7010336433319706624
09:36:24 <glguy> lavalike: https://www.haskell.org/cabal/users-guide/nix-local-build.html#specifying-the-local-packages
09:36:44 <nshepperd> my intuition for it is that the open sets in any data type are, for each value x, {y | x <= y}, and all the unions thereof
09:41:17 <lavalike> glguy: \o/ thank you, appreciate it!
09:41:32 <orbisvicis> ah nevermind, (_|_,__|_) should be above _|_
09:43:56 <orbisvicis> nshepperd: the only example I can think of something that is continuous but not montonic is Integer->A where all values of A are totally ordered over definedness so that the least upper bound doesn't exist
09:44:07 <orbisvicis> I can't see any practical value to this, though
09:44:55 <orbisvicis> err, I meant monotonic but not continuous
09:45:32 <nshepperd1> Or maybe it is x < y? One of those
09:55:41 <elliptic0> hi
09:57:04 <elliptic0> Hi, anyone know how to log all input and output to a file in GHCI? I know there is file call ghci_history under ./ghc/
09:57:27 <lavalike> by any chance does anyone know how to stop the Interactive-Haskell prompt in emacs to scroll to the middle of the window when the output reaches the bottom?
10:14:30 <Zemyla> Oh, wow. If you use RebindableSyntax to define >>= and >> so they can handle unlifted types, then do-notation will handle the unlifted types just fine as well.
10:15:10 <Solonarv> yeah, RebindableSyntax is really powerful
10:17:03 <mniip> Zemyla, that requires a polykinded monad
10:18:54 <mniip> hmm
10:18:55 <mniip> I wonder
10:18:55 <Solonarv> IIRC do-notation has nothing to do with monads, once you enable RebindableSyntax
10:19:03 <mniip> sure,
10:19:19 <mniip> but I was assuming you have the same  m a -> (a -> m b) -> m b, just with a polykinded a
10:20:01 <Zemyla> Yeah, my definition was newtype S (r :: RuntimeRep) s (a :: TYPE r) = S { unS :: State# s -> (# State# s, a #) }.
10:21:57 <mniip> class RepresentedMonad (m :: TYPE r -> TYPE r') where (>>=) :: forall (a :: TYPE r). m a -> (a -> m b) -> m b
10:22:20 <mniip> hmm, can you say
10:23:06 * hackage gcodehs 0.1.1.0 - GCode processor  http://hackage.haskell.org/package/gcodehs-0.1.1.0 (srk)
10:23:14 <mniip> class RepresentedMonad (m :: TYPE r -> TYPE (RepVia m r)) where type famile RepVia m :: RuntimeRep -> RuntimeRep; (>>=) :: forall (a :: TYPE r) (b :: TYPE (RepVia m r)). m a -> (a -> m b) -> m b
10:26:38 <glguy> mniip: Do you have an example in mind of a type that needs the extra generality of (TYPE r -> TYPE (RepVia m r)) as opposed to (TYPE r -> *)?
10:26:53 <mniip> Proxy#?
10:27:05 <mniip> partially applied (#,#)
10:27:06 <glguy> ok, cool
10:27:22 <mniip> but yeah it's pretty limited
10:27:37 <mniip> I think anything you can write with 'data' or 'newtype' is TYPE PtrRepLifted
10:30:20 <mniip> I mean LiftedRep
10:31:27 <sternmull> i want to detect cycles in a dependency graph. I successfully made  a function that returns all cycles... but some of them are really meaningful (for example some only have a prefix for an already listed cycle). Is there a common way of listing cycles? Is there even a finite set of cycles or should i just report the first one?
10:31:57 <Zemyla> https://gist.github.com/Zemyla/2fa9b41e003cbe98aaba0f5d134a4f8f
10:32:17 <glguy> I anticipate that one of the problems of this lifted monad class would be the inability to write the traditional monad combinators generically
10:32:28 <glguy> You'd only ever be able to use it at specific instances
10:33:33 <Zemyla> I was planning on using this stuff to help me out because I want to write a pure-Haskell alternative to GMP for GHC that doesn't rely on linked lists like GHC.Integer.Simple.
10:35:42 <mniip> ugh
10:35:48 <mniip> this :t bug
10:36:24 <mniip> where it instantiates all RuntimeRep tyvars with LiftedRep regardless of whether you've set -fprint-explicit-runtime-reps or not
10:36:57 <sternmull> here is my work-in-progress code to detect cycles in a graph: http://tpcg.io/r3fRqD It is working (it reports cycles) but maybe someone could give me advice what the most sensible result should look like...
10:38:17 <Einwq> How difficult, as a newbie, would it be to create an instagram crawler with a GUI that just shows the images in Haskell?
10:41:08 <Solonarv> probably not massively difficult? although finding a working gui library can be a bit trying
10:42:28 <cocreature> sternmull: you might want to use a Set instead of a list to store the nodes you’ve already seen. that would allow you to turn the linear search into a logarithmic membership check
10:42:52 <cocreature> sternmull: you could also replace "concat . map" with "concatMap"
10:43:16 <aeline> Sorry, could give me a link that explains how set membership testing is logarithmic? Hand't seen that before.
10:43:45 <sternmull> cocreature: I thought about Set, but i wanted to report the cycles in the correct order, so a user has it easy to see which chain is building the cycle
10:43:46 <cocreature> sternmull: and instead of "map fst $ Map.toList m" you can use "Map.keys m"
10:44:09 <cocreature> sternmull: you could do both. keep a list that you output at the end and a Set for membership tests
10:44:18 <sternmull> cocreature: Thanks for concatMap and Map.keys, will use them!
10:44:43 <cocreature> aeline: I don’t have a link to recommend but if you search for “binary search tree” you should find a bunch of results
10:45:27 <fishythefish> if you just want a statement from the docs: http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Set.html#v:member
10:46:01 <cocreature> sternmull: you could also consider to return Map k [k] instead of [[k]]. that makes it a bit easier to see which node a cycle comes from
10:46:02 <sternmull> cocreature: Right, could use both datastructures. But at the moment i am not even sure if it makes sense to enumerate all the cycles. In practice the dependencies will be read from config files... so i could just report the first cycle and let the user try again. But if there is a good way to report all cycles then that would be nicer.
10:46:18 <cocreature> ah no, I read that wrong
10:46:20 <mniip> glguy, the sad part is there's no way to do induction on [RuntimeRep]
10:46:27 <mniip> in the SumRep and TupleRep case
10:47:22 <cocreature> sternmull: due to laziness you don’t have to pay for calculating all cycles if you just check if the list is empty
10:47:32 <cocreature> so you don’t necessarily have to change that part
10:48:01 <mniip> hmm
10:49:17 <sternmull> cocreature: yes, but my list looks a bit stupid at the moment ["abca","aca","bcab","bcac","cabc","cac"]  has a lot of redundancy. And i am not sure if i can get rid of that in an easy way. If there is no simple solution to that then i will just report the firs cycle.
10:55:36 <ph88> is this value chainScore unused?  https://github.com/jtobin/declarative/blob/master/lib/Numeric/MCMC.hs#L171
10:57:04 <cocreature> ph88: no, it is used using RecordWildCards
11:00:15 <aeline> cocreature, thanks
11:02:45 <phadej> someone talked about continuous and monomorphic here today: mniip and Taneb iirc: https://en.wikipedia.org/wiki/Scott_continuity found that
11:04:28 <mniip> phadej, ah so it is a topology
11:07:14 <mniip> I suppose you could define  x v y = sup (repeat [x, y])
11:07:27 <mniip> then a scott-continuous function would be monotonic
11:07:56 <cocreature> what is the Coercion constructor in core used for https://github.com/ghc/ghc/blob/master/compiler/coreSyn/CoreSyn.hs#L280 ?
11:08:55 <mniip> cocreature, to pass coercions to functions
11:10:35 <cocreature> mniip: when would you do that? I’m having trouble understanding the distiniction between the Cast and the Coercion constructor
11:10:58 <mniip> ((x :: A) `cast` (c :: A ~ B)) :: B
11:11:00 <mniip> that's cast
11:11:29 <mniip> ((f :: (A ~ B) => D) (c :: A ~ B)) :: D
11:11:35 <mniip> that's `App` with a Coercsion
11:11:36 <gentauro> cocreature: iarrays built on top of `Integer` :D (for the LULZ) https://lpaste.net/686835196992946176 (mod) and https://lpaste.net/3567297688850399232 (example)
11:11:40 <gentauro> cos why not? :P
11:12:04 <cocreature> mniip: ah I see, thanks!
11:12:17 <gentauro> they are pretty much unusable, both speed and usability and no to mention "stack overflow"
11:13:55 <cocreature> sounds great :)
11:16:28 <gentauro> in my SHA1 I just need to store at most 80 Word32. That fits :P
11:16:47 <mniip> why not use
11:17:10 <mniip> data SHA1State = SHA1State Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32 Word32
11:17:28 <cocreature> gentauro: it also fits into a regular array :)
11:17:57 <gentauro> mniip: we need more words !!! Word !!!
11:18:21 <cocreature> more bangs and unpack pragmas
11:18:52 <gentauro> mniip: how would yo populate SHA1State?
11:19:21 <gentauro> given that you know the first 15 values and from those you deduce the rest ...
11:19:26 <mniip> SHA1State 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
11:19:50 <mniip> hmmm
11:20:10 <gentauro> mniip: you need to add Maybe to each of them :P
11:22:06 <gentauro> is anybody else experiencing really hot weather? (Denmark)
11:22:22 <gentauro> I mean, it's like +30 and really humid
11:22:41 <Logio> It's been 30ish weather in Finland as well for the past few weeks
11:23:14 <gentauro> Logio: Ditto en Copenhagen
11:23:17 <gentauro> it's unbearable
11:23:19 <Logio> and set to continue for the next 10 days :/
11:23:26 <gentauro> (no global warming? yeah right)
11:24:50 * hodapp blows airhorn
11:24:51 <hodapp> FAKE NEWS
11:27:12 <gentauro> the iarray are very much crap :D -> https://i.imgur.com/1HwlrXm.png
11:27:24 <glguy> This channel isn't for weather or airhorns
11:27:58 <gentauro> the add function is pretty bad as it requires for the hole underlaying Integer array to be copied :\
11:28:18 <gentauro> so making a few add just destroys performance
11:28:30 <gentauro> glguy: airhorns?
11:29:09 <mniip> gentauro, consider!
11:29:43 <mniip> % type Word8 = W
11:29:44 <yahb> mniip: ; <interactive>:1:14: error: Not in scope: type constructor or class `W'
11:29:49 <mniip> % type W = Word8
11:29:49 <yahb> mniip:
11:29:54 <mniip> % data SHA1State = SHA1State W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W deriving (Show, Data)
11:29:55 <yahb> mniip:
11:30:06 <mniip> % fromConstrB (fromConstr (mkIntegralConstr (dataTypeOf (undefined :: Word8)) 0)) (indexConstr (dataTypeOf (undefined :: SHA1State)) 0) :: SHA1State
11:30:07 <yahb> mniip: SHA1State 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
11:30:43 <gentauro> :o
11:30:48 <gentauro> what is this madness?
11:30:59 <mniip> % :t fromConstrB
11:31:00 <yahb> mniip: Data a => (forall d. Data d => d) -> Constr -> a
11:33:25 <gentauro> mniip: I think you gave me an idea ..
11:33:31 <gentauro> with your approach
11:33:47 <gentauro> so why not just store in a regular list?
11:34:49 <gentauro> w_t0 : w_t2 : ... : w_t79]:[]
11:35:13 <gentauro> that way I just need to deconstruct the list once (80 x O(1) = O(1)
11:35:42 <Solonarv> because lists have weaker guarantees, and worse performance characteristics
11:36:31 <sternmull> cocreature: Thanks for your suggestions about my graph-cycle thing. Used all your suggestions.
11:36:45 <gentauro> Solonarv: but I know that my list will always be 80 (I ensure this by padding my Lazy ByteString => k' n = (448 - (n + 1)) .&. 511
11:37:08 <gentauro> that will ensure that I will always have 512 bits = 64 bytes (Word8)
11:37:09 <Solonarv> while the syntax doesn't show this, there's no such thing as "deconstructing a list once". If you deconstruct a list you get its head and its tail; if you want more elements you then need to deconstruct the tail, etc
11:37:31 <gentauro> Solonarv: x:y:z:_
11:37:35 <glguy> Using [Word8] is much much less memory efficient than a datatype of unpacked Word64s if you know the exact size you're working with
11:37:53 <Solonarv> yes, that parses as (x : (y : (z : _)))
11:38:05 <Solonarv> you can leave out the parens because of the associativity of (:)
11:38:26 <gentauro> Solonarv: but we agree that each "head" should be in constant time right (O(1))
11:38:38 <Solonarv> yes of course
11:38:52 <Solonarv> but big-O doesn't always tell the entire picture
11:39:07 <glguy> The operations on a constant length list are also O(1), and also that doesn't matter
11:39:11 <Solonarv> the problem here is constant size, so big-O is completely irrelevant
11:39:17 <gentauro> glguy: what I want to achieve is that I want to re-use 80 - 85 % of the code to implement SHA2 (pretty much the same, only rounds and some inner functions change)
11:40:58 <gentauro> but I still haven't found my (performance) but in my SHA-1 and it's no way ByteString (had to implement something else to convince myself: Base64 encoding with no memory trace -> http://blog.stermon.com/articles/2018/07/24/haskell-base64-encoding-with-profiling.html)
11:42:25 <gentauro> I base64 encoded a +630 MB file and memory never went above 80k which is pretty nice :o
11:52:34 <dmj`> quicksilver: In the alex templates, the bystring wrapper uses w2c (w2c = unsafeChr . fromIntegral), which compiles to a no-op, and unsafeChr being (unsafeChr (I# i#) = C# (chr# i#)), I bet if the String and Text wrappers used w2c the performance would be identical. This is only for tracking a previous character, which is optional.
11:54:52 <dmj`> quicksilver: actually no, they’d still have to call encodeUtf8 :: Char -> [Word8]
12:06:46 <Zemyla> Ooh, I think I figured out how to have the defaults work properly with levity-polymorphic values in typeclasses.
12:08:42 <dmj`> quicksilver: actually, unconsing a String or Text produces a Char, so w2c wouldn’t be necessary, it’s def. the encodeUtf8, lexing on ByteString just assumes you’re operating on utf8 w/ alex.
12:12:50 <shapr> has anyone heard of a project that automates/simplifies wrapping Haskell code into a shared object in a Python wheel?
12:25:38 <mniip> phadej, Taneb, so Scott topology is a functor from the category of directed-suprema-preserving monotonic functions on posets into Top!
12:26:24 <mniip> likely left adjoint to the "forgetful" functor that goes the other way
12:27:07 <Tuplanolla> Looks like this place hasn't changed a bit while I was gone.
12:27:50 <AndreasK> xD
12:29:25 <mniip> now for a completely orthogonal question
12:32:48 <mniip> can we relate profunctor ends with continuity
12:35:51 <noidedsuper> In a monad transformer stack, is it better to have something like ExceptT ErrorType (StateT StateType m) or StateT StateType (ExceptT ErrorType m)
12:35:53 <noidedsuper> ?
12:36:20 <c_wraith> depends on which you want.
12:36:21 <mniip> noidedsuper, literally no difference
12:36:24 <mniip> ah er
12:36:24 <mniip> no
12:36:28 <mniip> disregard that
12:37:02 <c_wraith> basically, do you want catching errors to cause state to backtrack?
12:37:31 <c_wraith> or do you want state changes to persist over thrown errors?
12:37:33 <mniip> StateT ExceptT loses state when throwing yes
12:37:48 <mniip> and ExceptT StateT threads the state across a throw/catch
12:38:31 <c_wraith> these effects do not commute with each other. one ordering means what you do. pick that one. :)
12:38:40 <nshepperd1> I'm a bit confused because it seems like in order to say that haskell can compute all continuous functions per Scott topology we need to add some sort of ambiguous choice operator. As in: race :: a -> a -> a which starts evaluating both and returns whichever finishes first
12:41:58 <c_wraith> nshepperd1, is lub sufficient
12:42:00 <nshepperd1> We need that to write f :: ((), ()) -> () which matches (returns () for) exactly the open set (_, ()) u ((), _)
12:42:13 <noidedsuper> Thanks c_wraith/mniip. I think in my case I want the state changes to get chucked, because the exceptional case is generally exceptional enough that it's best to give up and try again
12:42:52 <c_wraith> nshepperd1, OK, that's built on the primitive "unamb"
12:43:11 <c_wraith> nshepperd1, which is close to what you're asking for, but with some additional constraints
12:43:22 <c_wraith> nshepperd1, http://conal.net/blog/posts/merging-partial-values
12:43:54 <nshepperd1> Can it be defined so that we don't have to worry about nondeterminism?
12:44:03 <c_wraith> nshepperd1, you can certainly implement it in ghc haskell, but the type system isn't strong enough to prove it's correct.
12:44:09 <mniip> nshepperd1, in case of (bottom1, bottom2), what do you return
12:44:34 <mniip> in your idealized cpod world there's only one bottom but in the RealWorld there's multiple
12:44:52 <nshepperd1> mniip: a bottom, i don't care which
12:44:59 <mniip> well then 'unamb'
12:45:08 <sternmull> Should i use mtl or transformers? Or is mtl based on transformers? Should i use them even if i don't need monad transformers at the moment but most likely later?
12:45:29 <mniip> sternmull, mtl is a bunch of typeclass boilerplate on top of transformers
12:45:42 <mniip> transformers defines ReaderT, mtl defines MonadReader
12:46:03 <sternmull> now i am even more confused...
12:47:12 <noidedsuper> I'm not an expert but it seems like MTL basically says "These types of monad transformers have these operations" while transformers provides the concrete implementations
12:47:39 <c_wraith> noidedsuper, that's correct
12:47:45 <noidedsuper> But then you can use the MTL classes for better polymorphism, *and* MTL does typelevel magic stuff with FunDeps to make sure that type inference will still work
12:47:46 <nshepperd1> The answer is mu. You should use mtl *and* transformers
12:49:03 <sternmull> Ok, so i go with mtl and import Control.Monad.Writer.
12:50:43 <rschmukler> alanz: If you happen to be around I'm hitting an interesting issue on a new machine with hie.
12:51:19 <alanz> rschmukler, what kind of machine, o/s?
12:51:23 <rschmukler> darwin
12:51:42 <rschmukler> It seems that because ghc isn't installed in my global path, and the hie process isn't spawned with its CWD, it's not finding ghc via stack and dying immediately
12:52:09 <alanz> does stack install ghc for you?
12:52:12 <rschmukler> That's my hypothesis anyway, I haven't been able to get the hie error message though so I might be completely wrong (any way I could verify would also be helpful)
12:52:34 <alanz> no idea, I am a linux user. only.
12:52:36 <rschmukler> It's installed, yes, but only for the project (ie. if my CWD is not in the project, then ghc isn't in my path)
12:53:13 <rschmukler> The answer might just be "install ghc" and move on with my life
12:53:16 <alanz> via "stack setup 8.4.3" or whatever?
12:53:53 <rschmukler> correct
12:54:54 <alanz> what ide are you using?
12:55:18 <rschmukler> emacs (via your haskell-lsp)
12:55:42 <alanz> that should launch hie in the right directory
12:55:52 <rschmukler> Hmmmm alright - my hypothesis could be incorrect then
12:56:12 <alanz> btw, you need to have cabal install available too, so do "stack install cabal-install"
12:56:29 <alanz> and make sure the directory stack installs to is on your path
12:56:39 <rschmukler> Alright, I'll install all the packages in `haskell-ide-engine` - I've done that on other machines
12:56:47 <rschmukler> (HaRe, ghc-mod, etc)
12:57:15 <alanz> that should not be necessary
12:57:49 <alanz> so long as hie itself is installed. But mac binary search paths and the like are not things I know about
12:58:21 <rschmukler> Alright, just cabal-install then :)
12:59:19 <alanz> yes, there was an issue we closed today about that being needed
12:59:21 <rschmukler> alanz: still getting lsp-haskell has exited (exited abnormally with code 1)
12:59:36 <alanz> and hie master should now give a warning if it is not found
12:59:59 <alanz> toggle-debug-on-error and see what it complains about
13:01:00 <rschmukler> and today I learned about toggle-debug-on-error... Teach a man to fish...
13:03:31 * shapr hugs alanz 
13:03:49 <rschmukler> lsp-timed-out-error on lsp--send-wait - not seeing too much more than that
13:04:34 <rschmukler> Does mismatched ghc versions cause hie to not respond to requests?
13:05:10 <c_wraith> that double '-' is a little suspicious to an outsider. is that expected there?
13:05:46 <rschmukler> I believe that's just a convention regarding an internal function, but I'm not a (good) lisp developer
13:06:46 <c_wraith> well, as I said, I'm an outsider. if it looks normal to you, it probably is.
13:08:40 <rschmukler> Just updated the project I'm working on to use 8.4.3 (version I built hie with) and it still errors
13:11:22 <noidedsuper> Has anybody used pointedlist before?
13:11:24 <noidedsuper> Is it good?
13:12:07 <lavalike> noidedsuper: yeah!
13:13:57 <noidedsuper> Awesome
13:15:20 <AndroUser2> Is real world haskell a good book to start haskell with?
13:15:21 <sternmull> Reading the docs of Control.Monad.Writer reminds me how unhelpful the terse documentation of Haskell APIs can be. I am sure it is all very simple but it doesn't give any context, i am supposed to already know what it is good for and how it is used. A sentence like "writer (a,w) embeds a simple writer action." just doesn't tell much to me.
13:15:54 <c_wraith> sternmull, well-kept secret: you probably shouldn't use Writer for anything
13:16:02 <geekosaur> mtl has a bad habit of assuming you've read the papers linked at its top level
13:16:10 <[exa]> a few words about "why" would be useful even in some other packages
13:16:13 <geekosaur> but also what c_wraith said: it's not as helpful as you might think
13:16:24 <c_wraith> sternmull, it has some design flaws that make it a poor choice in almost all cases.
13:17:34 <sternmull> hm, ok. My intention was to use it to collect errors/log entries that allow a function to complete but must be reported at the end.
13:18:15 <lavalike> c_wraith: is it mostly because of laziness?
13:18:34 <sternmull> There seems to be a strict Writer class.
13:18:36 <c_wraith> lavalike, yes. there's no way to get it to mappend strictly
13:18:42 <lavalike> brutal!
13:19:00 <c_wraith> sternmull, it isn't strict enough for many cases.
13:19:29 <sternmull> So the problem is that it will accumulate thunks instead of building the output immediately?
13:19:43 <c_wraith> yes, that is a problem it has.
13:20:06 <sternmull> So what should i use instead? State?
13:20:25 <c_wraith> well, your case is one where that might be acceptable.
13:20:39 <c_wraith> since you intend to build a big structure anyway.
13:20:40 <noipmups> Why `foo a = fromIntegral (a `shiftR` 8)` returns 0 for every input?
13:21:00 <noipmups> `foo :: Word 8 -> Word16`
13:21:03 <lavalike> @type shiftR
13:21:04 <lambdabot> Bits a => a -> Int -> a
13:21:06 * hackage liveplot 0.1.0.0 - Liveplotting  http://hackage.haskell.org/package/liveplot-0.1.0.0 (srk)
13:21:17 <c_wraith> noipmups, try the fromIntegral *first*
13:21:17 <sternmull> what other alternatives do i have? I basically want logging without IO, so i have pure functions i can test in isolation.
13:21:43 <c_wraith> noipmups, you're shifting all the bits away, then converting to Word16
13:21:52 <noipmups> c_wraith: No luck.
13:22:38 <c_wraith> sternmull, yeah, you can use Writer for that, if you're careful to not throw giant thunks into it.
13:22:44 <noipmups> c_wraith: `foo a = ((fromIntegral a) `shiftR` 8)` still returns 0.
13:23:09 <lavalike> > let foo a = a `shiftR` 8 in foo (512 :: Integer)
13:23:11 <lambdabot>  2
13:23:18 <c_wraith> sternmull, since the thunks representing the mappends aren't really any bigger than the concatenated lists themselves
13:23:23 <[exa]> btw is Accum any better than Writer?
13:23:37 <c_wraith> noipmups, maybe you mean shiftL?
13:23:46 <[exa]> except for the generality ofc.
13:23:48 <lavalike> maybe your test cases are too small
13:24:00 <c_wraith> lavalike, the input is a Word8
13:24:05 <noipmups> c_wraith: Definitely. Thanks.
13:25:17 <lavalike> c_wraith: ha.
13:26:11 <sternmull> c_wraith: I think i will have only relative small parts of my program that do such logging that are evaluated in IO before they build up much data. So Writer should be ok for me. But of course, if there is a better way then i would like to use it right away.
13:28:09 <c_wraith> sternmull, https://www.reddit.com/r/haskell/comments/50hf2s/stricter_writert_and_rwst_replacements/ is a summary of the problems with links to details.
13:29:11 <sternmull> thanks
13:31:41 <piark_> hello
13:31:48 <lavalike> sup
13:36:45 <sternmull> Control.Monad.Trans.Accum reads exactly like the thing i want. But does it behave more strict than Writer or would i run into the same problem when writing a lot?
13:37:06 <[exa]> sternmull: I was hoping someone here would answer that
13:37:08 <[exa]> :]
13:37:45 <[exa]> sternmull: perhaps you can make a Monoid that does deepseq on appending stuff
13:38:04 <lavalike> the link c_wraith provided has links to "properly strict" implementations
13:38:19 <c_wraith> yes, but I wouldn't call any of them canonical
13:38:19 <sternmull> [exa]: That doesn't sound very clean to me.
13:38:33 <[exa]> it's not. :]
13:40:03 <sternmull> Also i don't like deepseq because its a library function that will traverse data structures everytime it is evaluated... even if they are already where "deepsequed". But that is a topic for another day.
13:41:22 <sternmull> today i just want a logging-thingy that is solid :)
13:41:54 <c_wraith> Accum is weird. it's certainly not strict in the mappend,l
13:42:51 <sternmull> i don't understand where it differs to Writer... except for naming.
13:43:26 <c_wraith> yeah, the documentation is lacking. that implementation of (>>=) looks really weird to me.
13:44:07 <butterthebuddha> Is it fair to say that monads generalize composition?
13:44:19 <c_wraith> I don't understand when that is ever desired, and I'm not even convinced it's a valid implementation.
13:44:32 <geekosaur> sort of? the problem is there are many different ways to generalize
13:44:43 <noidedsuper> butterthebuddha, I think that monoids are a better way to generalize composition
13:44:44 <c_wraith> butterthebuddha, generalize the (.) operator, sure.
13:44:56 <geekosaur> Arrow started out as a way to generalize composition over both monads and (.), which ran into problems
13:44:57 <noidedsuper> or semigroups
13:45:10 <geekosaur> but Applicatives are another approach to doing so
13:45:13 <c_wraith> butterthebuddha, but there are a lot of different things composition can mean than just (.)
13:45:36 <geekosaur> there's more than one way to generalize, and each introduces its own restrictions at the same time
13:46:06 <c_wraith> Kleisli composition is an extension of function composition!
13:46:23 <c_wraith> but it's not the only one.
13:46:26 <butterthebuddha> the intuition here is that function composition lets you sequence function application
13:46:39 <butterthebuddha> and monads let you sequence "effects"
13:47:21 <butterthebuddha> (and so do applicatives)
13:47:39 <c_wraith> butterthebuddha, it's certainly not wrong. it's just something you need to be a bit careful about. kleisli composition (monads as categories) is not the only extension of function composition around.
13:48:06 <geekosaur> but applicatives do so differently. and there are packages which rely on tis because you can use it to distinnguish between strict sequential and racing/concurrent steps
13:50:07 <butterthebuddha> geekosaur: what do you mean by "racing/concurrent steps"?
13:50:29 <geekosaur> a composition of applicatives can be done in parallel with respect to each othe
13:50:45 <geekosaur> but sequenced with respect to a larger computation which they are part of
13:51:08 <geekosaur> whereas monadic composition enforces strict sequencing.
13:51:14 <butterthebuddha> Because they don't depend on context?
13:51:18 <geekosaur> yes
13:59:39 <dolio> Applicatives are about putting things in a list, and monads are about building trees.
14:00:31 <ph88> anyone know how to do mcmc with discrete samples ?
14:23:37 * hackage bustle 0.7.2 - Draw sequence diagrams of D-Bus traffic  http://hackage.haskell.org/package/bustle-0.7.2 (WillThompson)
14:25:22 <iqubic> How hard is it to get GHCJS installed on my machine?
14:26:02 <Tuplanolla> Only you can answer that, iqubic.
14:26:22 <iqubic> And are there any tutorials to teach me GHCJS?
14:26:50 <iqubic> Tuplanolla: I'm wanting to get GHCJS going on NixOS.
14:36:23 <mniip> dolio, can you elaborate on that analogy?
14:37:19 <Lucifer333_> hi
14:38:26 <Lucifer333_> let x = [[1,2,3]] in map sum $ x
14:38:31 <Lucifer333_> what does "$" do?
14:38:34 <Lucifer333_> what does it mean?
14:38:48 <koz_> :t ($)
14:38:49 <lambdabot> (a -> b) -> a -> b
14:39:02 <mniip> '$' is just a really low precedence "apply" operator
14:39:08 <hpc> f $ x = f x
14:39:19 <mniip> map sum $ x = (map sum) (x)
14:39:24 <Lucifer333_> also
14:39:24 <Lucifer333_> map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]
14:40:03 <Lucifer333_> gives [18,8,6,17]
14:40:12 <Lucifer333_> so $ is a "flatten"?
14:40:16 <mniip> no
14:40:26 <Lucifer333_> what is it?
14:40:30 <mniip> hpc literally cited the definition up there
14:40:39 <Squarism> is there some best practice on how to mock say : findUser :: (MonadIO m) -> UserId -> SqlPersistT m (Maybe User)
14:40:52 <Lucifer333_> mniip: thats not an answer
14:41:02 <Lucifer333_> "up there"? where?
14:41:08 <mniip> 1532468318 [00:38:38] <hpc> f $ x = f x
14:41:11 <hpc> that reminds me, i have invented a remarkable idiom bracket syntax for ($)
14:41:19 <hpc> first surround your expression with parens
14:41:27 <hpc> and then wherever you would use $, use the )( operator instead
14:41:46 <Lucifer333_> what?
14:41:51 <hpc> (that's a joke)
14:41:56 <c_wraith> that operator looks pretty syntactic
14:42:07 <Lucifer333_> normal english please
14:42:10 <mniip> hpc, and then operator sections turn into type errors
14:42:23 <Lucifer333_> what?
14:42:43 <mniip> Lucifer333_, okay so I'll repeat, $ is a low-precedence "apply" operator
14:42:55 <hpc> the definition of ($) is this:
14:42:57 <hpc> f $ x = f x
14:42:58 <hpc> ^
14:43:05 <mniip> operationally it's identical to juxtaposition (writing two things next to each other)
14:43:06 <Lucifer333_> seems useless
14:43:12 <Lucifer333_> juxtapostion?
14:43:22 <hpc> (writing two things next to each other)
14:43:30 <Lucifer333_> why not leave it out?
14:43:32 <mniip> the thing you use when you write 'f x' is called juxtaposition
14:43:46 <c_wraith> because it's low-precedence
14:43:48 <Lucifer333_> if i leave the $ out it doesnt woek
14:43:51 <Lucifer333_> work*
14:43:54 <mniip> you see,  'f (g x)' and 'f g x' have different meanings
14:44:06 <Lucifer333_> ah yes
14:44:07 <hpc> Lucifer333_: would you rather write doTheThing $ anotherFunctionName [big list] a b c
14:44:10 <mniip> 'f $ g x' translates to the former, not the latter
14:44:16 <hpc> or (doTheThing) (...)
14:44:40 <Lucifer333_> let x = [[1,2,3]] in ( map sum ) x
14:44:44 <Lucifer333_> ok
14:44:57 <mniip> in 'map sum $ x' it is indeed useless
14:45:06 <Lucifer333_> no
14:45:11 <Lucifer333_> if you leave it out it doesnt work
14:45:16 <mniip> > let x = [[1,2,3]] in map sum x
14:45:18 <lambdabot>  [6]
14:45:20 <mniip> looks like it works
14:45:24 <Lucifer333_> ah yes
14:45:25 <Lucifer333_> mm
14:45:31 <Lucifer333_> i was tinkering with it too much
14:45:36 <mniip> in the transpose thing it is necessary though
14:45:44 <hpc> Lucifer333_: it serves a minor syntactic purpose as well, some ways of writing expressions are inconvenient to just put right next to each other
14:45:46 <Lucifer333_> let x = [[1,2,3],[345]] in ( map sum ) x
14:45:52 <Lucifer333_> let x = [[1,2,3],[345]] in  map sum  x
14:45:53 <hpc> you can write doWorkWithFunction $ \x -> ...
14:45:58 <hpc> but not doWorkWithFunction \x -> ...
14:46:03 <Lucifer333_> let x = [[1,2,3],[345]] in  map sum $ x
14:46:12 <Lucifer333_> let x = [[1,2,3],[3,4,5]] in  map sum $ x
14:46:14 <mniip> all three of these work
14:46:39 <Lucifer333_> why doesnt lambdabot work for me?
14:46:44 <fishythe_> need to start with >
14:46:48 <mniip> you need to prefix your code with '> '
14:46:50 <Lucifer333_> > let x = [[1,2,3],[3,4,5]] in  map sum $ x
14:46:53 <lambdabot>  [6,12]
14:46:56 <Lucifer333_> > let x = [[1,2,3],[3,4,5]] in  map sum  x
14:46:58 <lambdabot>  [6,12]
14:47:00 <Lucifer333_> ok
14:47:01 <lukelau> Should the `in` underneath a `let` be indented?
14:47:02 <hpc> Lucifer333_: the final thing it does is it lets you pass function application as a parameter to other things
14:47:06 <pie_> are there any haskell editors that can case split data constructor matching?
14:47:08 <Tuplanolla> When's `ArgumentDo` landing?
14:47:09 <fishythefish> you can also privmsg lambdabot if you wanna experiment
14:47:14 <mniip> lukelau, it should be more indented than the let
14:47:15 <hpc> and do functional things with it like this:
14:47:18 <hpc> :t ($ True)
14:47:19 <lambdabot> (Bool -> b) -> b
14:47:25 <mniip> Tuplanolla, what's that
14:47:25 <Lucifer333_> i still dont know why $ is needed
14:47:36 <fishythefish> Tuplanolla: 8.6.1 I thikn
14:47:41 <Tuplanolla> Allowing `f do ...` and `f \ x -> ...`, mniip.
14:47:45 <fishythefish> https://ghc.haskell.org/trac/ghc/ticket/10843
14:47:47 <mniip> Lucifer333_, if you have   f a $ g b $ h c $ l d
14:47:59 <mniip> Lucifer333_, without $ you have to write  f a (g b (h c (l d)))
14:48:01 <Lucifer333_> map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]
14:48:04 <mniip> and at that point you're writing lisp
14:48:05 <Lucifer333_> > map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]
14:48:07 <hpc> Lucifer333_: it's needed in the same way for-loops are needed
14:48:07 <lambdabot>  [18,8,6,17]
14:48:13 <hpc> sometimes it keeps you from going crazy
14:48:17 <Lucifer333_> doesnt make sense
14:48:21 <Lucifer333_> small steps
14:48:23 <mniip> what doesn't
14:48:28 <Lucifer333_> for loops
14:48:33 <Lucifer333_> ok so
14:48:36 <hpc> nobody wants to write while-loops all the time, nobody wants to riddle their code with parens all the time
14:48:43 <Tuplanolla> Sweet.
14:48:44 <Lucifer333_> $ is a placeholder for a subarray?
14:48:48 <mniip> what
14:48:49 <mniip> no
14:48:53 <koz_> hpc: Or GOTO jumps, if you're really unlucky.
14:49:01 <mniip> $ is a binary operator
14:49:02 <Lucifer333_> > transpose [ [0,3,5,9],[10,0,0,9],[8,5,1,-1]]
14:49:04 <lambdabot>  [[0,10,8],[3,0,5],[5,0,1],[9,9,-1]]
14:49:08 <mniip> it applies whatever's to the left, to whatever's to the right
14:49:10 <Lucifer333_> array of arrays
14:49:18 <Lucifer333_> ok binary
14:49:32 <fishythefish> he means "two arguments" not "base-2"
14:49:34 <pie_> Lucifer333_, the "trick" with $ is that it's right associative, and its basically application
14:49:34 <Lucifer333_> so on the right side we have an array
14:49:37 <mniip> binary as in it takes two arguments
14:49:47 <Lucifer333_> on the left side we have sum
14:49:49 <mniip> yes, on the left we have 'map sum' - a function
14:49:55 <Lucifer333_> ah map sum
14:50:19 <Lucifer333_> ok so it takes an array of array
14:50:37 <Lucifer333_> > ($) (map sum)  transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]
14:50:39 <lambdabot>  error:
14:50:39 <lambdabot>      • Couldn't match expected type ‘[[Integer]] -> t’
14:50:39 <lambdabot>                    with actual type ‘[Integer]’
14:50:45 <mniip> needs more parentheses
14:50:47 <Lucifer333_> > ($) (map sum)  (transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]])
14:50:49 <lambdabot>  [18,8,6,17]
14:50:51 <Lucifer333_> ok
14:51:03 <Lucifer333_> interesting
14:51:16 <mniip> it doesn't take only "arrays of arrays"
14:51:23 <mniip> its type is very general
14:51:25 <Lucifer333_> it takes if it fitst
14:51:26 <fishythefish> :t map sum
14:51:27 <lambdabot> (Num b, Foldable t) => [t b] -> [b]
14:51:34 <Lucifer333_> ok thanks i get it
14:51:44 <mniip> it can take any function on the left, and an appropriate argument on the right
14:51:49 <mniip> :t ($)
14:51:50 <lambdabot> (a -> b) -> a -> b
14:52:06 <mniip> the '(a -> b)' is the first argument, 'a' is the second. 'b' is the result type
14:52:31 <mniip> Tuplanolla, that's cool
15:05:06 * hackage git-mediate 1.0.4 - Remove trivial conflict markers in a git repository  http://hackage.haskell.org/package/git-mediate-1.0.4 (EyalLotem)
15:14:07 * hackage stack2nix 0.2 - Convert stack.yaml files into Nix build instructions.  http://hackage.haskell.org/package/stack2nix-0.2 (domenkozar)
15:18:36 * hackage git-mediate 1.0.5 - Tool to help resolving git conflicts  http://hackage.haskell.org/package/git-mediate-1.0.5 (EyalLotem)
16:03:37 * hackage tasty 1.1.0.3 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-1.1.0.3 (RomanCheplyaka)
16:04:27 <dolio> mniip: The analogy doesn't even really capture it. Something closer would be this...
16:06:02 <mniip> I see applicative as a family of liftAn :: (a -> b -> ... r) -> f a -> f b -> ... f r  liftings
16:06:24 <mniip> that or a way to commute categorical products with your functor
16:06:34 <dolio> Applicative is like building a binary tree, where at the leaves you have stuff like `f a` `f b` `f c` ..., and at the nodes you say how to combine the 'a' 'b' 'c' parts, which label your immediate children into a new type 'x', and so on.
16:06:59 <mniip> so akin to attributive grammars
16:07:25 <mniip> I guess for the grammar part you do need Alternative
16:07:29 <dolio> And that's related to lists built out of Empty, Singleton, Branch and quotienting.
16:07:45 <dolio> That's how it's like lists.
16:08:24 <dolio> Arrows are also like that, but instead you have two things `f a b` and the adjacent things have to match.
16:09:43 <dolio> But you can use functions to fix things up, which is kind of like the information at the nodes of applicatives, so it's similar.
16:10:22 <dolio> With monads, you have a tree with nested fs.
16:11:10 <dolio> And changing the parameter type involves going to the leaves and gluing in new trees.
16:11:23 <dolio> Adding more nesting.
16:12:19 <dolio> That is the only sense in which they're 'sequential.' 'Later' stuff goes underneath 'earlier' stuff in the tree.
16:12:58 <dolio> (Some don't even make sense to describe in that way, of course.)
16:14:49 <c_wraith> Free ((->) r) is a fun type
16:28:38 <dolio> In the case of something like IO, going 'under' some parts of the tree mean you just store a continuation, and can't even see the lower parts of the tree until you're interpreting it as a specification for doing stuff.
16:28:52 <dolio> Unless you simulate some input or something.
16:34:25 <dataN> given a value of some type and list of functions from x to y where x and y are drawn from type level list provided, can the functions be separated into those which can be composed (starting with the given type, to provide values to feed into the functions of this list) and those that cant, i.e. those from a type that will not be returned in the successfully composed chain?
16:38:12 <Gurkenglas> dataN, can you write that as a type signature?
16:54:57 <dataN> Gurkenglas: maybe. is that an equivalent problem?
16:59:20 <dataN> also, there is more; supposing such a process proceeds one function at a time, lazily deferring the inclusion of the return type into the growing list of types that have values that appear in the unbroken chain from the initial type, can it be made that a encountering a strict type would throw an error if a value of its input type is not yet available?
17:08:39 <dataN> the idea is to create a monad so that functions can be collected in any order and it will still typecheck, as long as there is a way to produce a value of some type at the time that this value is actually demanded.
17:09:55 <dataN> probably it should also throw an error if there is more than one way to get to any type.
17:11:37 <Gurkenglas> dataN, what you said before my line sounded like the sort of question that is equivalent to one of form "Is this type inhabited?", and questions in such form are more formal -> approachable
17:12:35 <rschmukler> alanz: if you happen to be around, sorry to be a pain, but any thing I could do in terms of next steps of debugging would be awesome. Again, lsp (emacs) claims timeout, but no logs in hie
17:13:57 <lin__> can I read a file in a normal function?
17:14:05 <koz_> lin__: Define 'normal'?
17:14:29 <geekosaur> if you mean a pure function, no. (there are hacks but if you try to use them you will learn why that's a really bad idea)
17:14:31 <lin__> FilePath -> mytpe -> Bool
17:14:40 <mniip> dataN, yes, I've done that
17:15:10 <mniip> you just have to package a GADT with enough type evidence to support what you're doing
17:15:55 <geekosaur> lin__, in short, don't try to cheat, do it in IO
17:16:15 <koz_> Could someone please tell me what I'm missing here, and whether what I wanna do is even possible? https://lpaste.net/88843816584347648
17:16:15 <mniip> ah no, it wasn't a monad, merely an applicative
17:17:15 <mniip> koz_, that's not what a Newtype instance looks like
17:17:26 <lin__> could I throw it into an if in main?
17:17:40 <koz_> mniip: I was following this: https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Unboxed.html
17:18:02 <mniip> koz_, no I mean the instance for the Newtype typeclass
17:18:09 <mniip> the 'newtype instance' declarations themselves are fine
17:18:19 <koz_> mniip: I was going with the example here: https://www.stackage.org/haddock/lts-11.18/newtype-generics-0.5.3/Control-Newtype-Generics.html
17:18:38 <mniip> that's a poor example
17:18:44 <mniip> in  newtype A = B C
17:18:52 <mniip> you declare instance Newtype A, not B
17:19:12 <mniip> that should be evident from the method types hwever
17:19:22 <mniip> pack :: O n -> n
17:19:33 <koz_> Ah, I see what you mean. MV_Categorical is a constructor, not a type.
17:19:55 <koz_> Right?
17:19:58 <mniip> a data constructor, not a type constructor
17:20:09 <mniip> that's what GHC told you
17:20:20 <koz_> Ah, right, thanks for the terminology fix.
17:21:01 <koz_> OK, got it now, plus one more extension. Thanks mniip!
17:21:18 <mniip> what extension
17:21:27 <koz_> FlexibleInstances.
17:21:37 <koz_> So I can write 'instance Newtype (VU.MVector s Categorical)'.
17:22:34 <mniip> ah so FlexibleInstances?
17:22:46 <Squarism> how do I implement an MonadIO instance for mocking purposes?
17:22:59 <koz_> mniip: Yeah, as I said.
17:24:03 <dataN> the idea is to use such a construction with constraint definitions
17:25:18 <geekosaur> lin__, I'm not sure what you're asking
17:25:47 <mniip> dataN, what you're describing sounds like recursive coyoneda
17:26:25 <mniip> data D a where P :: a -> D a; F :: D b -> (b -> a) -> D a
17:26:33 <mniip> and sure enough you can write a  D a -> a
17:26:43 <siraben> mniip: Does category theory for programmers give a good definition of the Yoneda Lemma?
17:26:49 <siraben> I'm still somewhat confused after reading it
17:27:10 <mniip> are you referring to a specific article/text?
17:27:33 <siraben> Yes, but what text do you recommend to understand the yoneda lemma?
17:27:50 <siraben> I understand functors, hom-sets, natural transformations, morphisms etc. already
17:28:23 <siraben> mniip: I'm referring to https://bartoszmilewski.com/2015/09/01/the-yoneda-lemma/
17:28:38 <mniip> can't say I understand the yoneda lemma myself in full capacity
17:28:40 <johnw> siraben: my take is that any object is equivalent to the set of things you can do to it, or with it, since you know nothing more than this
17:29:08 <siraben> Hmm seems hard to express in type theory
17:29:16 <siraben> Apparently it's more obvious in more mathematical areas
17:29:52 <johnw> well, consider the equivalence between data types and their church encoded forms
17:31:00 <johnw> one is a data, the other is the ability to apply operations to that data without having any access to the data itself (even though you can "recover" it with the right operations)
17:32:45 <siraben> Hmm.
17:33:06 <dataN> it does not seem to have anything to do with the yoneda lemma in any obvious way.
17:33:14 <johnw> Yoneda and CPS transformations are also very closely related
17:33:20 <siraben> But finally understanding monads (great lecture https://www.youtube.com/watch?v=gHiyzctYqZ0 ) has been useful
17:33:36 <siraben> johnw: How so?  That example was also brought up
17:34:01 <johnw> for example, going from a -> b to a -> (b -> r) -> r
17:34:08 <johnw> take the functor to be (->) a
17:34:16 <johnw> and rewrite the CPS form to (b -> r) -> a -> r
17:34:22 <johnw> now it's (b -> r) -> f r
17:34:24 <johnw> there you go
17:34:31 <johnw> f b =~ (b -> r) -> f r
17:35:08 <dataN> johnw: perhaps its not obvious how cps transformations are the solution... is it because it uses the concept of deferring evaluation of some of what seems to be something like a difference list of functions, and so makes reference to future computations?
17:35:47 <koz_> :t by
17:35:49 <lambdabot> error:
17:35:49 <lambdabot>     • Variable not in scope: by
17:35:49 <lambdabot>     • Perhaps you meant one of these:
17:35:54 <koz_> :t on
17:35:55 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
17:36:01 <johnw> dataN: I don't think I fully understood your question
17:36:37 <siraben> johnw: I don't follow.
17:36:37 <dataN> which part?
17:36:51 <johnw> Yoneda says that I can talk about cars by talking about nothing more than what you can do with a car. I don't need the car itself to reason about it.
17:37:07 <siraben> How do hom-sets get involved?
17:37:16 <mniip> johnw, do you know an example that doesn't involve a functor from a category enriched over itself?
17:37:21 <siraben> [C, Set](C(a, -), F) ≅ F a
17:39:13 <johnw> mniip: assume any functor 'f', and some object 'f a'. If the category in which 'f a' exists is ornery, I can use Yoneda to work instead with the hom-set 'C(a,r) ~> f r'
17:39:16 <dataN> what have continuations got to do with checking if a type is inhabited given a list of functions?
17:39:42 <johnw> dataN: where did this list of functions idea come from?
17:39:55 <heebo> hello but which library do most use for monad transformers?
17:40:03 <johnw> heebo: transformers and/or mtl
17:40:55 <heebo> johnw: i didnt know they could be used together, if you had to choose one library which would it be?
17:41:26 <johnw> heebo: I typically use both; mtl to state my constraints, and transformers to provide the actual implementation type
17:41:49 <johnw> i.e., my function needs a MonadReader, but my application newtype wrapper is defined using ReaderT
17:42:00 <c_wraith> heebo, it is literally impossible to use mtl without transformers. it re-exports types from transformers
17:42:32 <heebo> johnw: c_wraith thank you
17:43:03 <dataN> johnw, trying to make some way of gathering constraints, checking which can be inferred by definitions which demand other constraints, just in the same way as at top level, instances can be given in any order, this seems similar to the version where a list of functions are chained together with (.) but where the functions are provided in the wrong order.
17:43:35 <siraben> Where can I find those libraries that people say "only have types as documentation"?
17:43:44 <siraben> I want to see if the rumors are true!
17:46:17 <siraben> Why does [ (x,y,z) | x <- [1..], y <- [1..], z <- [1..], x^2 + y^2 == z^2] not work?
17:46:28 <siraben> But [ (x,y,z) | x <- [1..1000], y <- [1..1000], z <- [1..1000], x^2 + y^2 == z^2] does?
17:48:06 <geekosaur> define not work
17:48:06 <johnw> i think because it's exhausting the space of 'x' with y = 1 and z = 1
17:48:21 <johnw> it doesn't know that "all the rest won't work"
17:48:24 <siraben> Can't it do breath-first search?
17:48:27 <johnw> no
17:48:27 <c_wraith> siraben, pretend it's three nested loops. when does it increment x?
17:48:30 <dataN> Its actually not necessary to consider the extension to constraints, but thats the motivation.
17:48:31 <siraben> breadth*
17:48:39 <siraben> c_wraith: Never
17:48:51 <siraben> But suppose I want to get /all/ the pythagorean triples
17:49:03 <c_wraith> apply bounds.
17:49:11 <siraben> So no infinite stream of triples?
17:49:23 <c_wraith> you can create an infinite stream
17:49:30 <siraben> How?
17:49:38 <c_wraith> bound the nest iteration.
17:50:07 <siraben> [ (x,y,z) | x <- [1..100], y <- [1..], z <- [1..], x^2 + y^2 == z^2]
17:50:09 <siraben> Doesn't work either.
17:50:49 <johnw> now it exhausts y with z = 1
17:51:03 <johnw> you have to bound both x and y
17:51:09 <johnw> you shouldn't need to bound z
17:51:11 <siraben> Ok but [ (x,y,z) | x <- [1..100], y <- [1..100], z <- [1..], x^2 + y^2 == z^2]
17:51:12 <dataN> It does not seem difficult to do something like type level quicksort, but the part which is confusing is throwing a type error when two values cannot be commuted because, in this example of functions composing, one of them is strict, and so can not be lazily deferred, if that terminology works.
17:51:13 <siraben> Doesn't work?
17:51:17 <johnw> no?
17:51:19 <siraben> No.
17:51:33 <johnw> huh, ok, then bound that too
17:51:35 <johnw> bind them all!
17:51:42 <siraben> But that defeats the original purpose!
17:51:45 <johnw> uh oh!
17:51:47 <johnw> bound the purpose!
17:51:53 <siraben> But... non!
17:52:43 <siraben> Ok but I thought [(x,y) | x <- [1..], y <- [1..]] would do something like traversing all the points in a 2D plane
17:52:58 <siraben> and give [(1,1), (1,2), (2,1), (2,2) ...]
17:53:00 <johnw> yes, but there you have no guard
17:53:06 <siraben> Instead of just _|_
17:53:14 <siraben> bottom
17:53:17 <pavonia> There's a method to enumerato all the pairs such that no infinite loop occurs, but I forget the name of it
17:53:19 <johnw> in the pythogorean case, your guard ends up answering False to an infinite series
17:53:25 <c_wraith> > [(c, b, a) | a <- [1..], b <- [1..a], c <- [1..b], b * b + c * c == a * a]
17:53:28 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(15,20,25),(7,24,...
17:53:37 <siraben> c_wraith: Oh!
17:53:42 <johnw> c_wraith++
17:54:47 <c_wraith> you can make it more efficient if you write an isPerfectSquare check and only iterate over two variables
17:55:05 <c_wraith> but that version gets the point across. bound the nest loops, not the outer.
17:55:13 <c_wraith> *nested
17:55:38 <dataN> similarly, if there was a branch in the chain, i.e. there were two functions in the list with the same argument type, how can this be made not to type check?
17:56:35 <johnw> dataN: edwardk is an expert at constraints-based programming in Haskell
17:56:45 <dataN> its just a list of functions
17:57:13 <johnw> without seeing code, I really don't understand at all what you're trying to describe
17:57:16 <dataN> the constraints stuff can be left until after
17:57:19 <johnw> and sadly, I must leave the house in a moment
17:58:06 <dataN> yes, admittedly it is difficult to envisage a list of functions between types given in a type level list.
17:59:51 <dataN> might look something like e.g. ; (x@[Int,Bool ... ]',[a->b|a `elem` x,b `elem` x])
17:59:53 <johnw> siraben: another point to consider: if you take 'f' to be the identity, this special case of Yoneda says that a ≅ (a -> r) -> r
18:00:44 <siraben> johnw: Yeah, that is pretty obvious
18:00:46 <siraben> It's like CPS
18:00:49 <johnw> yep
18:00:58 <johnw> it just generalizes the idea to any 'f'
18:01:11 <johnw> if we pick a few well-known functors, it starts looking like things we use all the time
18:01:19 <siraben> Has category theory been formalized in Coq by any chance?
18:01:27 <johnw> several times
18:01:38 <johnw> and my own: https://github.com/jwiegley/category-theory
18:02:12 <dmwit> siraben: For this you don't need it. But for when you do need it, the universe package offers ways to do infinite Cartesian products.
18:02:14 <dataN> siraben: apparently it is not as good as haskell for dependant types...
18:02:24 <siraben> I can't get over how fluffy category theory seems at times
18:02:29 <siraben> It's so abstract
18:02:29 <johnw> fluffy?
18:02:42 <siraben> Well I mean abstract
18:02:56 <johnw> it asks the question, "What doesn't change when I map an idea between domains?"
18:02:57 <siraben> How does one even come up with these non-intuitive ideas?
18:03:05 <siraben> Hm.
18:03:19 <siraben> Or maybe it's just abstract as set theory is
18:03:23 <Zipheir> johnw: That's a good description, actually.
18:03:31 <dmwit> siraben: (+*+) and `choices` here: http://hackage.haskell.org/package/universe-base-1.0.2.1/docs/Data-Universe-Helpers.html
18:03:45 <johnw> Zipheir: this was a major focus of MacLane's teacher
18:05:41 <dmwit> siraben: e.g. on my machine, ` [(a,b,c) | [a,b,c] <- choices (replicate 3 [1..]), a^2 + b^2 == c^2]` starts printing answers right away.
18:05:59 <dmwit> It gets slow really soon, though. =D
18:06:49 <siraben> dmwit: :)
18:11:26 <dataN> wow, this is more difficult that anticipated. even 'a list of values with types appearing in a type level list' is difficult...
18:11:37 <koz_> What module is the Identity {functor, applicative, monad} in?
18:11:46 <mniip> Data.Functor.Identity
18:11:49 <mniip> % :i Identity
18:11:50 <yahb> mniip: newtype Identity a = Identity {runIdentity :: a} -- Defined in `Data.Functor.Identity'; instance Applicative Identity -- Defined in `Data.Functor.Identity'; instance Eq a => Eq (Identity a) -- Defined in `Data.Functor.Identity'; instance Functor Identity -- Defined in `Data.Functor.Identity'; instance Monad Identity -- Defined in `Data.Functor.Identity'; instance Monoid a => Monoid (Identity a) -- Def
18:11:50 <siraben> :t <-
18:11:51 <koz_> mniip: Thank yoU!
18:11:52 <lambdabot> error:
18:11:52 <lambdabot>     parse error on input ‘<-’
18:11:52 <lambdabot>     Perhaps this statement should be within a 'do' block?
18:12:04 <koz_> :t (<-)
18:12:05 <lambdabot> error:
18:12:06 <lambdabot>     parse error on input ‘<-’
18:12:06 <lambdabot>     Perhaps this statement should be within a 'do' block?
18:12:21 <iqubic> That's not a function, it's a piece of do block syntax
18:12:23 <siraben> /o\
18:13:09 <dataN> how to write; (a~Bool || a~ Int)=>[a] ?
18:13:22 <iqubic> I don't think you can.
18:13:23 <Gurkenglas> @undo do a <- b; c a d -- siraben, lambdabot has a do desugarer thing that gives you code with actual functions
18:13:24 <lambdabot> b >>= \ a -> c a d
18:13:32 <lin__> why can I not have to putStrLn after another?
18:13:41 <siraben> So <- is syntactic sugar
18:13:42 <siraben> ?
18:13:48 <Gurkenglas> siraben, yep
18:13:54 <iqubic> dataN: That seems like a dependent type.
18:14:02 <dataN> does it?
18:14:16 <Gurkenglas> > do a <- Identity 2; return (a + a)
18:14:18 <lambdabot>  Identity 4
18:14:33 <Gurkenglas> > Identity 2 >>= \a -> return (a + a)
18:14:35 <lambdabot>  Identity 4
18:14:36 <iqubic> dataN: At best you could create a new data type that could only contain Ints or Bools, and just use that.
18:14:46 <Gurkenglas> :t (>>=)
18:14:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:15:00 <Gurkenglas> m can be Identity, or IO, or State s, etc.
18:15:04 <siraben> Is there a Maybe monad that works with Int | Bool ?
18:15:11 <iqubic> No.
18:15:28 <Gurkenglas> siraben, what do you mean by "work with"?
18:15:33 <dataN> ok, sure thats easy enough, but can it then take a type level list of types to specify the potential types of its contents?
18:15:59 <siraben> Like a polymorphic dispatch on types, but it would have to be Int | Bool | Nothing and by then one should just use Just | Nothing
18:16:09 <siraben> I think.
18:16:23 <siraben> So either I work with all types or a single one?
18:16:26 <iqubic> dataN: It seems like you want a haskell list that can store both Ints and Bools. That's not possible.
18:16:42 <siraben> dataN: You could use a list of (Int, Bool) instead
18:17:18 <siraben> Can you subvert the type system in Haskell?
18:17:37 <mniip> yes but why
18:17:45 <dataN> erm, something more like Either
18:17:51 <siraben> Yes Either
18:18:23 <dataN> as in let x = undefined :: [Bool,Int]' in EitherN x (True)
18:18:30 <dataN> and then have a list of such values
18:19:54 <Gurkenglas> dataN, why do you want to have a list of Bools and Ints?
18:20:27 <dataN> the idea is to then build up to having a list of functions between types specified by a type level list
18:20:56 <dataN> and throw a type error if they cannot be put in an order where they can be composed
18:21:09 <Gurkenglas> "foo :: [Type] -> [Type -> Type]; foo x = zipWith (->) x (tail x)"?
18:21:41 <dataN> what is that!?
18:21:44 <Gurkenglas> (I suppose (->) ought to get a different name)
18:21:57 <Gurkenglas> dataN, just improvizing syntax to guess what you mean because that's better than improvizing english
18:22:20 <dataN> oh yeah sort of like that
18:22:22 <Gurkenglas> *improvising. damn German accent.
18:22:34 <Gurkenglas> dataN, well why do you want such a list of functions?
18:22:35 <dataN> except they would not be in the correct order to begin with
18:23:13 <Gurkenglas> dataN, that sounds like the correct way to write it into syntax would be different. Would you try?
18:23:35 <dataN> ok the easyest way is to refer to the fact that if instead of functions they were mappings between constraint continuations, that this would be able to emulate the GHC constraint inference solver
18:24:40 <Gurkenglas> Sounds like the sort of compiler work you want value-level types for
18:25:36 <dataN> no, the constraint continuations work ok
18:25:59 <c_wraith> dataN, I think you're confusing things by talking about constraints
18:26:01 <dataN> e.g. p=>x->(q=>y)->y
18:27:17 <dataN> sure, but if the question is why bother trying to see if a list of functions forms a chain, then the answer has to refer to this.
18:27:23 <siraben> Why is the list functor not representable?
18:28:01 <Gurkenglas> siraben, [a] would have to be isomorphic to some (r -> a)
18:28:20 <c_wraith> siraben, I think it requires an uncountable domain
18:28:30 <jchia> Question about warp package: Why is it "type Port = Int" instead of "type Port = Word16"? Valid port numbers are less than 65536.
18:29:01 <jchia> If people care about catching errors at compile-time as much as possible, shouldn't Port be Word16?
18:29:05 <siraben> So the stream functor is representable?
18:29:12 <Gurkenglas> siraben, presumably you'd want to choose r to be the natural numbers, but [a] wouldn't be (Nat -> a), because lists can be finite
18:29:17 <dataN> the above says that "x returns a definition of a constraint continuation of q from the constraint p"
18:29:19 <Gurkenglas> siraben, yes
18:29:24 <mniip> jchia, only if you're working with AF_INET
18:29:27 <mniip> or AF_INET6
18:30:01 <siraben> I don't understand how contravariant and covariant functors differ
18:30:11 <mud> Does warp support anything other than those?
18:30:27 <geekosaur> isn't it Word32 for INET6?
18:30:31 <c_wraith> dataN, it sounds like you're really describing a graph algorithm. nodes are types, functions are edges between them, and you want to see if you have a path between two nodes.
18:30:55 <Gurkenglas> (ie value level types)
18:31:47 <c_wraith> dataN, a breadth-first search would be an appropriate first algorithm, unless its observed performance is abysmal
18:31:55 <Gurkenglas> Scratch that, I suppose you could imagine the graph algorithm to be solved at compile time.
18:31:56 <jchia> mniip, geekosaur: It says "TCP port number". Can TCP port numbers be greater than 65535? http://hackage.haskell.org/package/warp-3.2.23/docs/Network-Wai-Handler-Warp.html#t:Port
18:33:13 <geekosaur> ok, apparently tcp6 still uses 0-65535. so I don't know unless there's some annoyance with platform integration
18:33:32 <geekosaur> hm, or they're avoiding the PortNum nonsense in the network library
18:33:55 <c_wraith> if you're working entirely in concrete types, BFS is probably good. if polymorphism gets involved, you might want to consider something like A* to try to keep your search pointed in the right direction
18:34:20 <geekosaur> which is that specifying it as Int gets it byte-swapped appropriately for the platform, as Word16 uses it literally which means it may have the wrong byte order
18:34:38 <c_wraith> PortNum is awful.
18:35:05 <c_wraith> because it's really more like PortBitStreamInNetworkOrder
18:35:13 <jchia> geekosaur: I haven't encountered PortNum, maybe I'll see the problem some time.
18:36:38 <geekosaur> basically fromIntegral in the low level network lib from Int to the internal port number type byte-swaps so that the value is correct for direct use in raw network APIs. but for Word16 it is used as is and you need to know whether your platform is big- or little-endian.
18:37:04 <dataN> whats BFS?
18:37:06 <geekosaur> so they use Int rather than make the user figure out how to prepare the port number. this is a longstanding annoyance in the low level network glue
18:37:16 <c_wraith> dataN, breadth-first search
18:37:29 <dataN> oh right, yes this sounds ok
18:37:40 <dataN> whats A*?
18:37:43 <c_wraith> dataN, along with depth-first search, one of the classic graph search algorithms
18:38:11 <c_wraith> a fancier graph search algorithm that uses a search heuristic
18:39:00 <c_wraith> careful tuning of the heuristic can make it exactly BFS or DFS. usually you aim to be much more goal-directed than either of those.
18:39:47 <dataN> well actually, its not clear how e.g. (a,[(a->b),(b->c),(d->e),(c->d)]) will typecheck, but e.g. (a,[(a->b),(x->y)]) wouldnt - using BFS...
18:40:47 <c_wraith> dataN, I don't think you're going to be able to stuff everything into the type system. I think you'll have to do more work at the value level.
18:41:06 <dataN> it needs to be a compile error
18:41:34 <dataN> just as constraint inference is
18:41:40 <c_wraith> ghc doesn't do that kind of searching.
18:41:56 <c_wraith> if you want it to happen at compile time, try template haskell
18:42:05 <dataN> sure, thats why this needs writing!
18:42:11 <dataN> why template haskell?
18:42:35 <dataN> not sure generics are necessary at this point...
18:42:35 <c_wraith> because it runs at compile time and can spit out compiler errors
18:43:44 <dataN> so its a type level algorithm to put the list in order and compose the functions, it should return a type error if it fails, seems reasonable?
18:44:13 <c_wraith> and if it succeeds, it produces the composed function?
18:45:07 <dataN> well ok, so the use case is the constraints again, it just gives a context in cps such as; (((p,q,r)=>x)->x)
18:45:53 <c_wraith> that syntax already means something, and not what you're describing.
18:46:12 <dataN> constraint continuations?
18:47:23 <dataN> sorry, this makes the leap that (a->b) becomes (y,a=>y->((b=>x)->x))
18:48:28 <c_wraith> that, on the other hand, looks like a kind error.
18:48:47 <c_wraith> Constraint and Type are not interchangeable kinds
18:49:33 <dataN> ah, yes, sorry. ok whats meant is that rather than composing functions, it is continuations that are being composed.
18:50:29 <dataN> essentially, while it might be tempting to compose all the functions together, when composing constraints, its more relevant to realise that all the intermediate constraints are satisfied, which is more helpful than being able to produce any of the intermidiate values in a chain of function compositions
18:51:59 <dataN> (y,p=>y->((q=>x)->x)) says that "y provides a locally instance of q, returning it as a constraint continuation, it requires that constraint p is implemented"
18:52:25 <dataN> local*
18:53:24 <c_wraith> I think you're using these words to mean different things than I think they mean.
18:54:24 <c_wraith> what's your end goal? what should compile?
18:54:31 <dataN> then a list of such things would produce a composite context in the form of a constraint continuation representing the local instances of all the constraints defined within it; (((p,q,r)=>x)->x)
18:56:39 <dataN> the idea is that gathering up all the definitions, that as long as the constraints the definitions rely on are provided at some point in the list, that they can be added to the "context" (that the (p,q,r) part), and a compile time error is thrown if a definition which demands some constraints are satisfied appears in the list when these constraints are not implemented by definitions in the list or are declared at top level as regular c
18:58:02 <c_wraith> so... if it compiles successfully, what does it compile to?
18:58:39 <dataN> [(y,forall a. (p=>a)->a),(z,forall a. p=>(q=>a)->a)] compiles, regardless of the order of the list
18:59:27 <c_wraith> but what is the result of it?
18:59:34 <dataN> sorry that should be; [(y,y->(forall a. (p=>a)->a)),(z,z->p=>(forall a. (q=>a)->a))]
19:01:07 <dataN> resulting in; (forall a. ((p,q)=>a)->a)
19:01:12 <c_wraith> are you just writing these as type-level assertions, or is there some associated value?
19:01:25 <dataN> having used the definitions y and z in producing this
19:01:44 <dataN> which are datatypes
19:02:15 <dataN> and yes, there are values of these "constraint continuation" types
19:03:10 <dataN> heres an example; https://gist.github.com/dataN-hs/18caf53bb6c97ef9a29e663e1e61baf8
19:03:20 <dataN> the function recode has the right type.
19:03:49 <dataN> it has a type error, but this is solved with careful use of proxy types... to be updated soon
19:05:00 <dataN> oh wait, that does not show a definition which requires a constraint...
19:05:48 <dataN> the problem of gathering up all the constraints if declared in the wrong order was preventing the complete write up...
19:06:21 <dataN> butif its not going to be possible without, then probably this will have to wait
19:47:08 <yaboo> hello
19:47:17 <yaboo> anyone here using ghc and cabal-install on archlinux?
19:47:25 <yaboo> I am struggling with cabal-install implicit
19:47:39 <yaboo> I know very little haskell and really want to use implicitcad
19:50:48 <glguy> yaboo: ArchLinux makes it harder to get started, you'll need to pay special attention to the archlinux wiki
19:51:05 <yaboo> alright, I will have a look
19:51:08 <yaboo> it used to work just fine :(
19:51:11 <yaboo> not sure what is happening
19:51:22 <glguy> The archlinux devs made it worse
19:51:23 <yaboo> what paste do you guys prefer?
19:51:29 <glguy> gist.github.com is good
19:52:12 <yaboo> I just want to do "cabal update && cabal install implicit" :)
19:52:27 <yaboo> okay, waiting for update cause I nuked everything
19:52:30 <yaboo> will paste errors
19:56:57 <POGtastic> hi guys, can someone clarify how applicatives apply to curried functions? For example, [(+), (*)] <*> [1, 2] is equal to [(1+),(2+),(1*),(2*)]. I've been understanding most of the explanations for simpler examples of applicatives, but this one is throwing me for a loop.
19:57:31 <glguy> This is about the Applicative instance for the [] type
19:57:36 <geekosaur> lists are cartesian products.
19:57:38 <glguy> > [f,g] <*> [x,y]
19:57:40 <lambdabot>  error:
19:57:40 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M794553456304...
19:57:40 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
19:57:46 <glguy> ?undefine
19:57:46 <lambdabot> Undefined.
19:58:02 <yaboo> githab has gone microsoft and no anon gist
19:58:03 <glguy> > [f,g :: Expr -> Expr] <*> [x,y] ::
19:58:05 <lambdabot>  <hint>:1:35: error:
19:58:05 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:58:06 <yaboo> so here it is http://ix.io/1ijo
19:58:11 <yaboo> the first line is the unix command I run
19:58:14 <glguy> > [f,g :: Expr -> Expr] <*> [x,y] -- last try
19:58:16 <lambdabot>  [f x,f y,g x,g y]
19:58:43 <glguy> yaboo: That's the normal errors for ArchLinux now. The wiki is supposed to explain what they did
19:58:55 <yaboo> okay
19:58:56 <yaboo> reading the wiki
19:59:59 <dmwit> POGtastic: Do you feel your question has been answered? If not, you might need to clarify exactly what you find confusing.
20:00:00 <POGtastic> I think I'm getting it. Maybe? going off of this instance of Applicative with respect to []: https://pastebin.com/DtCGbLZ2
20:00:20 <POGtastic> the weird part to me is how these definitions keep switching "f" to be either "functor" or "function"
20:00:42 <yaboo> i don't know much haskell and the ecosystem
20:01:00 <glguy> POGtastic: f is traditionally used as a function whether at the type or value level
20:01:07 <yaboo> which part exactly should I care about for implicit cad? static linking?
20:02:27 <POGtastic> i might be under a misconception with regard to functions itself. Say that I have a binary function. I call it with one argument. that returns a **function** that takes one more argument, right?
20:02:33 <POGtastic> > :t (+) 1
20:02:35 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
20:03:12 <geekosaur> :t (+) 1
20:03:13 <lambdabot> Num a => a -> a
20:03:17 <glguy> POGtastic: all functions take one argument. Some of those functions return a function as the result
20:03:35 <POGtastic> so when I have an applicative of binary functions, and I call <*> on a list of single arguments, I get an applicative of unary functions.
20:04:06 <dmwit> Up to terminology quibbles, everything you've said sounds right to me so far.
20:05:21 <POGtastic> now, um, does the type of applicative matter? can I mix and match applicatives when chaining these together? for example, say that I have a list of functions, and I apply them to a Maybe.
20:05:32 <glguy> :t (<*>)
20:05:34 <POGtastic> > [(+1), (+2)] <*> Just 5
20:05:34 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:05:36 <lambdabot>  error:
20:05:36 <lambdabot>      • Couldn't match type ‘Maybe’ with ‘[]’
20:05:36 <lambdabot>        Expected type: [b]
20:05:38 <suzu> the type matters
20:05:54 <glguy> POGtastic: Notice how the same 'f' is used in 3 places in the type of (<*>)
20:06:08 <POGtastic> gotcha. it'd be Applicative f, Applicative g => ... if it didn't
20:06:23 <suzu> yes
20:06:51 <POGtastic> ok, thanks a lot. LYAH has some great explanations, but it starts to build abstractions with this and it's hard to follow sometimes.
20:07:11 <POGtastic> also, what do people usually call the <*> operator?
20:07:30 <butterthebuddha> POGtastic: ap or apply
20:08:22 <POGtastic> butterthebuddha: thanks.
20:08:39 * dmwit . o O ( frequency-modulated ap )
20:11:02 <jackdk> I have also heard "spaceship"
20:12:58 <suzu> who says spaceship?
20:13:03 <Zipheir> I've heard 'applied over', but that's sort of wordy.
20:13:25 <suzu> i use ap. because it is ap
20:13:27 <suzu> :t ap
20:13:29 <lambdabot> Monad m => m (a -> b) -> m a -> m b
20:13:34 <suzu> except over Applicative
20:13:36 <suzu> ./shrug
20:14:36 <butterthebuddha> That's a good reason
20:16:57 <POGtastic> :t (++) <$> getLine
20:16:58 <lambdabot> IO ([Char] -> [Char])
20:17:02 <POGtastic> yeesh
20:18:17 <glguy> :t (<$>)
20:18:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:18:34 <POGtastic> so, um, in the above, fmap is of type Functor f => (a -> b) -> f a -> f b. In this case, a is of type IO [Char], and b is of type IO ([Char] -> [Char])
20:18:48 <glguy> no
20:19:01 <butterthebuddha> :t (++)
20:19:02 <lambdabot> [a] -> [a] -> [a]
20:19:06 <glguy> f is the type IO, a is String, b is String -> String
20:19:08 <POGtastic> er, ([Char] -> [Char])
20:19:13 <glguy> and [Char] is synonymous with String
20:19:13 <butterthebuddha> a = [Char], b = [Char]
20:19:19 <glguy> butterthebuddha: no
20:19:28 <butterthebuddha> [Char] -> [Char], my bad
20:19:31 <suzu> b = String -> String
20:19:32 <suzu> ye
20:20:14 <POGtastic> :t (++) <$> getLine <*> getLine
20:20:15 <lambdabot> IO [Char]
20:20:34 <butterthebuddha> Or, as I would write it:
20:20:39 <POGtastic> ok. now, in this case, we have to look at the implementation of the instance of Applicative with respect to IO.
20:20:42 <butterthebuddha> :t liftA2 (++) getLine
20:20:43 <lambdabot> IO [Char] -> IO [Char]
20:20:53 <dmwit> POGtastic: We do?
20:20:58 <POGtastic> er, I do.
20:21:01 <dmwit> Why?
20:21:03 <POGtastic> the royal "we"
20:21:13 <butterthebuddha> :t liftA2
20:21:14 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
20:21:22 <glguy> dmwit's point isn't that we don't have to look at the implementation, it's that *you* don't
20:21:32 <butterthebuddha> :t liftA2 (++) getLine getLine
20:21:33 <lambdabot> IO [Char]
20:21:55 <suzu> the implementation of Applicative does not matter
20:21:58 <dmwit> POGtastic: You don't have to. You don't want to. And you really should avoid it. You won't learn anything useful at this point.
20:22:06 <suzu> all we're doing is playing with type-lego
20:22:12 <suzu> we don't need to look under the hood
20:22:17 <suzu> to know if this is legal
20:22:18 <dmwit> % writeFile "foo" "bar"
20:22:18 <yahb> dmwit:
20:22:30 <dmwit> % (++) <$> readFile "foo" <*> readFile "foo"
20:22:30 <yahb> dmwit: "barbar"
20:22:44 <butterthebuddha> the applicative instance of IO is "compiler magic" isn't it?
20:23:02 <butterthebuddha> (or "haskell runtime magic", blah blah, whatever)
20:23:04 <suzu> Applicative isn't
20:23:06 <suzu> Monad is
20:23:07 <dmwit> As it happens, no. The compiler magic happens a bit lower. But it's near indistinguishable from compiler magic.
20:23:36 <butterthebuddha> Is Applicative implemented using Monad?
20:23:50 <suzu> yes ;)
20:23:53 <butterthebuddha> _That_ would be some real cheese
20:24:04 <suzu> it is, haha
20:24:12 <suzu> pure   = returnIO
20:24:13 <suzu>     m *> k = m >>= \ _ -> k
20:24:15 <suzu>     (<*>)  = ap
20:24:26 <suzu> three easy lines for Applicative IO
20:24:33 <suzu> as for what /those/ do.. that's magic
20:24:38 <geekosaur> surem that's common whne retrofitting Applicative instances for Monads
20:24:42 <POGtastic> i'm having difficulty putting this to words. so all I need to know is that <*> takes two things: an Applicative of functions, and an Applicative of "elements" (?) it then returns an Applicative of the result(s) of the functions, with the "elements" as arguments.
20:25:14 <suzu> :t (<*>)
20:25:15 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:25:31 <butterthebuddha> POGtastic: that's right from the type tetris pov
20:25:42 <POGtastic> so because (++) <$> getLine returns an IO (String -> String), and getLine is of type IO String, the types line up, and i'm happy.
20:25:46 <suzu> it takes: an Applicative holding a function, and an Applicative that has a value in it
20:25:50 <butterthebuddha> Some applicatives have like list have special interpretaions that might not be clear at first though
20:26:04 <suzu> and returns: an Applicative containing that value pushed through the aforementioned function
20:26:38 <glguy> There's no promise that any values with the "function" or "element" type are involved, though
20:26:42 <glguy> Just that the types will work out
20:27:06 * hackage xmonad-vanessa 0.2.0.3 - Custom xmonad, which builds with stack or cabal.  http://hackage.haskell.org/package/xmonad-vanessa-0.2.0.3 (vmchale)
20:27:27 <suzu> what it actually _does_ is up to the Applicative in question
20:28:14 <dmwit> ("What if we push the 'number of elements' knob all the way to zero?" https://blog.plover.com/math/pettifoggery.html )
20:28:47 <dmwit> (Don't read that if you are trying to learn Applicative. It won't help. But do read it if you're just hanging out here because you're bored, because it will help with that.)
20:30:39 <POGtastic> lol
20:30:45 <yaboo> is Stack my best option for archlinux?
20:31:04 <suzu> yes
20:31:04 <yaboo> or am I supposed to be able to install https://hackage.haskell.org/package/implicit with cabal-install from archlinux?
20:31:09 <suzu> NO
20:31:16 <geekosaur> arch is brokebn
20:31:20 <suzu> don't trust arch with haskell
20:31:22 <suzu> they fucked it all up
20:31:27 <yaboo> yeah
20:31:28 <glguy> The best option is the one that doesn't involve archlinux whether that's stack or installing your own cabal-install and ghc
20:31:31 <suzu> i mean technically they did the "right thing" but it is fucked
20:31:35 <suzu> stick to stack
20:31:36 <geekosaur> any more, I have to say the best option for haskell on arch is vbox with something sane running in it
20:31:58 <suzu> ^ lmao
20:32:04 <yaboo> lmfao
20:32:11 <butterthebuddha>  Isn't the discrete topology always disconnected?
20:32:24 <butterthebuddha> dmwit: ^
20:32:27 <dmwit> butterthebuddha: What if we push the "number of elements" knob all the way down to 1?
20:32:29 <yaboo> discrete is not disconnected.
20:32:32 <yaboo> it is discrete.
20:32:35 <glguy> dmwit: I'm liking this horned sphere
20:32:35 <suzu> i use arch and the only things i let pacman install for me are xmonad, xmonad-contrib, and stack
20:32:37 <butterthebuddha> goddamnmit
20:32:42 <dmwit> glguy: pretty crazy, right?
20:33:37 <yaboo> suzu please walk through a noob. I removed ghc, ghc-static, and all things haskell with pacman.
20:33:40 <yaboo> Then install stack
20:33:42 <yaboo> now what?
20:33:58 <yaboo> the end goal for me is to get this software: https://hackage.haskell.org/package/implicit
20:34:09 <yaboo> and then hack on it later.
20:34:15 <yaboo> But right now, just gotta run it first.
20:34:24 <suzu> you want to use the executible?
20:34:31 <yaboo> yes.
20:34:38 <suzu> okay. `stack install implicit`
20:35:00 <yaboo> where is the stack bin folder?
20:35:01 <suzu> that will fetch the right ghc, build the thing, and place the executibles in (iirc) ~/.local/bin/
20:35:17 <yaboo> great.
20:35:21 <yaboo> let's see how this goes.
20:35:23 <suzu> `stack path` will tell you all of it's paths
20:35:27 <yaboo> Really appreciate the help. :)
20:35:31 <suzu> looks like for me it is ~/.local/bin
20:35:34 <suzu> np, yw!
20:37:21 <POGtastic> :t (+) <*> (*100)
20:37:23 <lambdabot> Num a => a -> a
20:37:58 <POGtastic> > (+) <*> (*100) $ 5
20:38:00 <lambdabot>  505
20:39:08 <POGtastic> :t <*>
20:39:10 <lambdabot> error: parse error on input ‘<*>’
20:39:13 <POGtastic> :t (<*>)
20:39:15 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:40:24 <dmwit> % :t (<*>) @((->) Int)
20:40:24 <yahb> dmwit: (Int -> a -> b) -> (Int -> a) -> Int -> b
20:40:58 <glguy> A value choice of 'f' is the type  (->) Int
20:41:00 <POGtastic> so we've got Num a, Applicative f => f a -> (a -> a), being applied to an Applicative of type f (a -> a)
20:41:36 <glguy> "A valid choice"*
20:41:43 <dmwit> Where did the `f a -> (a -> a)` part of your claim come from?
20:42:05 <POGtastic> it's an applicative that contains a value of type a -> a -> a, or a -> (a -> a)
20:42:19 <dmwit> huh?
20:42:25 <POGtastic> :t (+)
20:42:26 <lambdabot> Num a => a -> a -> a
20:42:43 <POGtastic> and a function is an applicative, right?
20:43:01 <dmwit> If you want to call that an Applicative, the type it "contains" is `a -> a`, not `a -> a -> a`. But that still doesn't explain where you got `f a -> (a -> a)` from.
20:43:12 <dmwit> Oh, maybe you parenthesized it wrong.
20:43:21 <dmwit> Perhaps you meant `f (a -> (a -> a))`.
20:43:27 <POGtastic> dmwit: yessir
20:43:30 <POGtastic> that's what I meant
20:43:34 <dmwit> Okay, got it. Then you're wrong.
20:43:39 <POGtastic> lol
20:43:39 <fishythefish> might be worth just looking at Int. :t (+) = Int -> Int -> Int = Int -> (Int -> Int) = f (Int -> Int) where f = (->) Int
20:43:45 <dmwit> =)
20:44:37 <dmwit> So, yeah, (+), thought of as an Applicative value, "contains" a unary function.
20:44:45 <dmwit> It *is* a binary function; but it *contains* a unary one.
20:45:00 <butterthebuddha> I goddamn hate it when pointfree starts using the (->) e Applicative instance
20:45:04 <POGtastic> oh wow.
20:45:20 <glguy> "binary function" is a shorthand for types of the form:   a -> (b -> c)
20:45:27 <fishythefish> we also have :t (*100) = Int -> Int = f Int. Therefore, (+) <*> (* 100) works out, since we can pick f = (->) Int, a = Int, and b = Int
20:45:36 <dmwit> I agree with glguy's clarification.
20:45:59 <POGtastic> glguy: so a binary function is of type f :: (-> a) => f (b -> c)?
20:46:17 <dmwit> no no
20:46:19 <POGtastic> (probably getting the syntax wrong)
20:46:20 <fishythefish> most generally, a "binary" function has type a -> b -> c
20:46:25 <fishythefish> or a -> (b -> c) if you like parens
20:46:53 <butterthebuddha> btw, has anybody here worked at Fcebook on Haskell projects?
20:47:00 <butterthebuddha> Facebook*
20:47:16 <fishythefish> it happens that we can also view this as f (b -> c) where f is (->) a
20:47:33 <dmwit> Maybe slightly improved: if `f` *is* `(-> a)`, then `f (b -> c)` is the type of a binary function.
20:47:57 <fishythefish> (->) a but sure
20:48:15 <dmwit> Note that there is a difference here between "`f` is `(-> a)`" (sensible) and "`f` has type `(-> a)`" (not).
20:48:23 <glguy> or the mythical (a ->)
20:48:36 <yaboo> i did stack install and now my laptop is on turbojet mode
20:48:42 <yaboo> hopefully it wont fry before it is install
20:48:46 <dmwit> Oops, yes, I meant "if `f` is `(->) a`". Thank you both for the correction.
20:49:44 <butterthebuddha> glguy: is there an extension for that?
20:49:48 <glguy> Nope
20:49:54 <dmwit> bummer
20:49:56 * butterthebuddha i s sad
20:50:50 <fishythefish> anyway, just because `(->) a` has an Applicative instance doesn't mean every `a -> b` is worth calling `f b` all the time
20:51:10 <dmwit> (An aside: I usually try to be pretty forgiving about terminology and syntax mistakes. But this one I think comes from a thinking mistake that is worth correcting: it's important to be careful about distinguishing between types and computations. So I called this one out especially.)
20:51:31 <POGtastic> yep, the verbiage is important here.
20:52:13 <POGtastic> :t pure (+) :: (->) Int
20:52:14 <lambdabot> error:
20:52:14 <lambdabot>     • Expecting one more argument to ‘(->) Int’
20:52:14 <lambdabot>       Expected a type, but ‘(->) Int’ has kind ‘* -> *’
20:52:28 <dmwit> % :t pure @((->) Int) (+)
20:52:29 <yahb> dmwit: Num a => Int -> a -> a -> a
20:52:51 <POGtastic> dmwit: thanks. what exactly does the @ do?
20:52:58 <fishythefish> it's called visible type application
20:52:59 <fishythefish> :t pure
20:53:00 <lambdabot> Applicative f => a -> f a
20:53:06 * hackage sv-core 0.2 - Encode and decode separated values (CSV, PSV, ...)  http://hackage.haskell.org/package/sv-core-0.2 (qfpl)
20:53:17 <fishythefish> the @ says to give me this type, but actually substitute ((->) Int) for f
20:53:38 <dmwit> POGtastic: You know how polymorphic types have type variables in them? You can use @ to pick a specific type (which may itself have variables in it) for each variable.
20:53:56 <dmwit> There are some restrictions to make this a sensible thing to do, but that's the high-level picture.
20:53:58 <fishythefish> https://ghc.haskell.org/trac/ghc/wiki/TypeApplication
20:54:23 <dmwit> POGtastic: So, in `pure @Whatever`, we take the `f` in the type of `pure` and make it be `Whatever`.
20:54:40 <dmwit> POGtastic: You can do another @ to choose the `a`, as in:
20:54:49 <dmwit> % :t pure @[] @Int
20:54:49 <yahb> dmwit: Int -> [Int]
20:55:13 <dmwit> And you can use wildcards if you only want later type arguments.
20:55:18 <dmwit> % :t pure @_ @Int
20:55:18 <yahb> dmwit: Applicative w => Int -> w Int
20:56:04 <POGtastic> % :t pure @Maybe 5
20:56:04 <yahb> POGtastic: Num a => Maybe a
20:56:32 <POGtastic> > pure @Maybe 5 -- should be Just 5?
20:56:34 <lambdabot>  error:
20:56:34 <lambdabot>      Pattern syntax in expression context: pure@Maybe
20:56:34 <lambdabot>      Did you mean to enable TypeApplications?
20:56:49 <dmwit> Yeah, lambdabot doesn't have the extension turned on, so you need to use yahb for this.
20:56:51 <POGtastic> % pure @Maybe 5
20:56:52 <yahb> POGtastic: Just 5
20:56:52 <fishythefish> nope, we're just talking about types here - Just is a value constructor
20:56:54 <POGtastic> gotcha
20:57:08 <fishythefish> oh you mean if you evaluate as a value, yes
20:57:19 <thebnq> How does yahb differ from lambdabot?
20:57:41 <dmwit> yahb is a ghci instance in a security jail.
20:58:00 <dmwit> It can do everything ghci can do (and very little more).
20:58:26 <dmwit> ...this is a complete answer if you already know a lot about lambdabot.
20:59:21 <thebnq> heh i got lamdabot barely working for another server but don't know too much about it
21:00:03 <dmwit> If not, then I guess the highlights are that lambdabot can't do IO, has more limited introspection queries, and its ?let mechanism is pretty limited by comparison to yahb. But it has lots of non-Haskell-evaluation plugins that are very handy.
21:01:21 <thebnq> I see, that makes sense
21:01:37 * hackage sv 1.1 - Encode and decode separated values (CSV, PSV, ...)  http://hackage.haskell.org/package/sv-1.1 (qfpl)
21:01:55 <thebnq> I know theres a lot you can do in ghci.
21:02:04 <dmwit> hum
21:02:06 <dmwit> % :set +s
21:02:07 <yahb> dmwit:
21:02:14 <dmwit> % last [1..10000]
21:02:14 <yahb> dmwit: 10000; (0.05 secs, 873,424 bytes)
21:02:19 <dmwit> neato
21:02:29 <thebnq> yes! last useful thing I learnt for ghci
21:02:52 <dmwit> % :unset +s
21:02:53 <yahb> dmwit:
21:05:39 <POGtastic> back to our above case of (+) <*> (*100). (+) is (Num a, (->) a f) => f (a -> a), and (*100) is (Num a, (->) a f) => f a, right?
21:06:55 <POGtastic> :t <*>
21:06:57 <lambdabot> error: parse error on input ‘<*>’
21:07:01 <POGtastic> urrgh
21:07:06 <POGtastic> :t (<*>)
21:07:07 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:07:24 <clever> https://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#v:-60--42--62-
21:07:41 <POGtastic> assuming this is the case, we now have (Num a, Applicative f) => f (a -> a) -> f a -> f a
21:07:47 <POGtastic> i think this is making sense
21:11:58 <POGtastic> how does `(->) a f => f a` get resolved to (a -> a)?
21:14:24 <mniip> what
21:18:43 <butterthebuddha> POGtastic: "(->) a f" doesn't make any sense?
21:19:03 <butterthebuddha> But if f = (->) a, then f a = (->) a a = a -> a
21:20:42 <POGtastic> I didn't know how else to say it... ghci sure doesn't like it lol
21:23:30 <butterthebuddha> POGtastic: (->) a f = (->) a ((->) a) = a -> ((->) a)
21:23:55 <butterthebuddha> Wait nvm, that's wrong, ignore me
21:24:38 <c_wraith> POGtastic: (->) a f => ...  doesn't make any sense
21:24:48 <c_wraith> :k (->)
21:24:49 <lambdabot> TYPE q -> TYPE r -> *
21:25:06 <c_wraith> see?  the fully saturated kind is *, not Constraint
21:25:13 <c_wraith> So it can't go on the left side of =>
21:25:30 <|Leary> @let g = id :: (->) a ~ f => f a -- This does though.
21:25:31 <lambdabot>  Defined.
21:25:34 <|Leary> :t g
21:25:35 <lambdabot> error:
21:25:35 <lambdabot>     Ambiguous occurrence ‘g’
21:25:35 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.g’,
21:25:44 <c_wraith> :t L.g
21:25:45 <|Leary> Gah.
21:25:45 <lambdabot> a -> a
21:25:47 <siraben> How can I tell if a functor is covariant or contravariant?
21:25:51 <siraben> And why would it matter?
21:26:08 <c_wraith> siraben: newtype Predicate a = Predicate (a -> Bool)
21:26:17 <c_wraith> siraben: try writing a Functor instance for that
21:28:09 <siraben> c_wraith: Sorry I don't know much Haskell, perhaps you could demonstrate?
21:28:36 <siraben> A functor fmap :: (a -> b) -> f a -> f b, right?
21:28:48 <c_wraith> siraben: There isn't much to demonstrate.  fmap f (Predicate p) = ...
21:29:12 <c_wraith> siraben: f :: (a -> b), p :: (a -> Bool)
21:29:28 <c_wraith> siraben: is there any way to construct a (b -> Bool) from those pieces?
21:29:48 <siraben> Um. No?
21:29:55 <c_wraith> Then it's not a covariant functor.
21:30:06 <siraben> Otherwise, what, then?
21:30:10 <c_wraith> On the other hand...
21:30:12 <c_wraith> :t contramap
21:30:13 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
21:30:31 <c_wraith> contramap f (Pred p) = ...
21:30:43 <c_wraith> f :: (a -> b), p :: b -> Bool
21:30:52 <c_wraith> think you can construct an (a -> Bool) out of that?
21:31:05 <siraben> Wait so you need a contravariant functor to be able to construct f b -> f a from a -> b ?
21:31:15 <c_wraith> yes
21:31:23 <siraben> Can you do that with the list functor?
21:31:26 <c_wraith> No
21:31:34 <siraben> Which functors can you do it with?
21:31:49 <c_wraith> Only things involving being the argument to a function
21:32:51 <c_wraith> a basic rule of thumb is that something is contravariant when it *consumes* values of the type in question
21:33:00 <siraben> c_wraith: Yes, simple, compose p . f
21:33:13 <c_wraith> siraben: exactly
21:33:47 <c_wraith> There are also invariant functors
21:33:58 <c_wraith> They're not so useful, but it's worth pointing out there are 3 different classes
21:34:07 <siraben> Contravariant, covariant and what else?
21:34:19 <c_wraith> An example of an invariant functor would be something like newtype Endo a = Endo (a -> a)
21:34:37 <siraben> That seems like an identity functor?
21:34:39 <c_wraith> It both consumes and produces values of type a
21:34:56 <siraben> c_wraith: How did you come to understand functors?
21:35:01 <systemfault> c_wraith: Is there an actual use for such a type?
21:35:13 <siraben> Integer -> Integer
21:35:32 <c_wraith> systemfault: https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Monoid.html#t:Endo
21:35:47 <c_wraith> systemfault: I was paraphrasing the standard library :)
21:36:00 <siraben> c_wraith: Is composing f :: a -> b, p :: b -> c not just a standard composition?
21:36:06 <siraben> It doesn't mean it's a functor, right?
21:36:12 <siraben> p . f
21:36:17 <systemfault> c_wraith: Thanks
21:36:59 <c_wraith> siraben: that composition is just standard composition.  remember, it's only when you look at it as an operation on the Predicate type that it becomes contramap
21:37:18 <siraben> I'd like an example of when contramap is useful
21:37:28 <siraben> It's still quite vague..
21:37:37 <c_wraith> siraben: and as for how I learned all this stuff?  I'd say 80% of what I've learned about Haskell has come from asking questions here, or paying attention when someone else asks a question I don't know the answer to.
21:38:22 <siraben> And the other 20?
21:38:47 <siraben> Ok so a functor is useful for composition, right?
21:38:55 <JuanDaugherty> doing prolly
21:38:56 <cocreature> siraben: maybe take a hasql, iirc it uses contramap pretty heavily
21:38:56 <c_wraith> siraben: I don't think I've ever used Contravariant myself, though I have used Profunctor (which is a combination of contravariant and covariant)
21:39:01 <cocreature> *take a look
21:39:10 <siraben> Where can I learn more about all these functors?
21:41:55 <cocreature> siraben: http://lambdajam.yowconference.com.au/slides/yowlambdajam2017/Wilson-ExtendedFunctoFamily.pdf might be a good starting point (the talk should also be on youtube iirc)
21:43:17 <POGtastic> % (,,) <$> (+3) <*> (*2) <*> (/2) $ 5
21:43:17 <yahb> POGtastic: (8.0,10.0,2.5)
21:43:52 <siraben> categories
21:44:24 <POGtastic> :t (,,) <$> (+3)
21:44:25 <lambdabot> Num a => a -> b -> c -> (a, b, c)
21:46:37 <POGtastic> :t (,,) <$> (+3) <*> (*2)
21:46:39 <lambdabot> Num a => a -> c -> (a, a, c)
22:03:06 * hackage shakers 0.0.49 - Shake helpers.  http://hackage.haskell.org/package/shakers-0.0.49 (markfine)
22:05:06 * hackage preamble 0.0.62 - Yet another prelude.  http://hackage.haskell.org/package/preamble-0.0.62 (markfine)
22:14:43 <renzhi> is there an apt repository for debian that I can get the latest ghc (8.4.x)?
22:17:05 <cocreature> renzhi: I only know of an ubuntu ppa which I think doesn’t work directly on debian. however, the official bindists are built on debian so I would just get those
22:17:07 * hackage warped 0.0.6 - Warp and Wai Library.  http://hackage.haskell.org/package/warped-0.0.6 (markfine)
22:19:05 <renzhi> cocreature: thanks, I guess I'll need to do the manual install then
22:19:06 * hackage postgresql-connector 0.2.6 - Initial project postgresql-connector from stack  http://hackage.haskell.org/package/postgresql-connector-0.2.6 (markfine)
22:19:54 <cocreature> renzhi: installing GHC is pretty easy and you can also install it to wherever you want. just change the PATH or use cabal’s -w option if you want to use a specific installation
22:21:32 <renzhi> cocreature: I have a personal installation, but still like to have the OS take care of it, if possible, because upgrading is a lot easier :)
22:22:21 <cocreature> renzhi: it’s just a matter of download the new bindist and delete the old one. sure a repo might be slightly easier but the difference is really not that large
22:22:30 <cocreature> and often you also want to install multiple bindists side by side
22:23:27 <renzhi> yeah, agree.
22:30:34 <iqubic> Are there any good GHCJS tutorials out there that I can read.
22:42:02 <iqubic> When the heck is GHCJS so gosh darn memory intensive during compilation?
22:55:48 <dminuoso> Is there a way to force evaluation of a top level binding with TH?
22:56:59 <dminuoso> In particular I just want to force some `read ...`
22:57:19 <glguy> You can do the computation in TH and then serialize that down to the syntax for the result
22:58:15 <cocreature> for a "read" I would be surprised if you gain a whole lot by doing that
22:58:42 <glguy> so... myTopLevelThing = $(lift (read "10" :: Int))
23:07:33 <iqubic> When the heck is GHCJS so gosh darn memory intensive during compilation? Like what is it doing?
23:08:42 <cocreature> compiling things?
23:13:43 <dminuoso> glguy: That works great thanks. :)
23:13:58 <dminuoso> cocreature: The benefit is just avoiding partiality. Im in a place where I really dont want readMaybe. :P
23:14:42 <dminuoso> Im just defining a few bindings like ipv6LinkLocal = $(lift (read "fde80::/64" :: AddrRange IPv6))
23:15:27 <cocreature> dminuoso: ah makes sense, I was thinking of performance
23:15:50 <cocreature> dminuoso: merijn has a package for this https://hackage.haskell.org/package/validated-literals
23:24:03 <glguy> Tonight's project was adding some mouse support to my vty implementation of Quarto. Had to add it after my kid reached for the mouse when I was playing it with him :)
23:25:05 <glguy> https://github.com/glguy/quarto https://en.m.wikipedia.org/wiki/Quarto_(board_game)
23:33:06 * hackage preamble 0.0.63 - Yet another prelude.  http://hackage.haskell.org/package/preamble-0.0.63 (markfine)
23:37:46 <dminuoso> cocreature: Mmm, it's a bit overly restrictive on the base dependency.
23:43:07 * hackage warped 0.0.7 - Warp and Wai Library.  http://hackage.haskell.org/package/warped-0.0.7 (markfine)
23:49:08 <wuffie> is it possible to run something impure through a pure function before binding it?
23:49:23 <quicksilver> yes
23:49:33 <quicksilver> I mean the word 'before' doesn't really mean before in this context
23:49:49 <quicksilver> l <- fmap length getLine
23:49:51 <tdammers> how about a concrete use case
23:50:09 <dminuoso> If you do something impure in a pure function, then that pure function is definitely no longer pure.
23:50:12 <quicksilver> ^^ the "impure" IO action getLine is run through the pure function length "before" binding it to l
23:50:18 <quicksilver> which I suspect is what wuffie means?
23:50:50 <wuffie> i want to run fromIntegral on a Word32 that i receive from getWord32
23:50:54 <quicksilver> yes.
23:51:00 <quicksilver> use fmap just like my example
23:51:06 <quicksilver> or if you like operators
23:51:12 <quicksilver> l <- length <$> getLine
23:51:12 <wuffie> i use <$> right
23:51:12 <tdammers> :t fmap
23:51:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:51:19 <quicksilver> <$> is just an operator version of fmap
23:51:21 <wuffie> cool beans
23:51:25 <wuffie> thanks
23:52:30 <dminuoso> :t fmap
23:52:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:52:52 <quicksilver> amazing. The type of fmap hasn't changed in the intervening 120 seconds since tdammers checked ;P
23:53:19 <dminuoso> That's purity for you!
23:53:21 <tdammers> quicksilver: immutability ftw!?>
23:53:23 * quicksilver agrees
23:53:53 <tdammers> although you could argue that different types got substituted for 'f', so you don't get the same functor
23:54:31 <koz_> For the various signed Int types, is there a function which gives the largest negative number they can represent?
23:54:52 <cocreature> > minBound :: Int
23:54:54 <lambdabot>  -9223372036854775808
23:54:56 <dminuoso> Largest negative number?
23:54:58 <koz_> cocreature: Thanks!
23:54:59 <dminuoso> Do you mean -1?
23:55:01 <cocreature> if you want the largest magnitude
23:55:08 <koz_> dminuoso: Largest magnitude.
23:55:13 <koz_> cocreature read my mind.
23:55:40 <quicksilver> if you spend a couple of years programming primarily in haskell you too will be able to read minds.
23:55:53 <koz_> quicksilver: Wow, really? Sounds like Haskellers should run the world by now.
23:56:21 <cocreature> koz_: we already are, we just don’t tell anyone about it :)
23:56:31 <koz_> cocreature: The Haskell Conspiracy. Gotcha.
23:56:45 <koz_> (until the Haskell Dan Brown writes some books about it)
23:57:13 <quicksilver> why do you think the package manager is called 'cabal' ?
23:57:20 <dminuoso> koz_: It's written on-demand. When you thumb through the book Dan Brown will write it.
23:57:29 <koz_> Lol, lazy authoring.
23:58:13 <dminuoso> In a lot of ways software development is lazy too. I mean we try to ship early and then implement features as their necessity is discovered...
23:58:36 * hackage graphmod 1.4.2 - Present the module dependencies of a program as a "dot" graph.  http://hackage.haskell.org/package/graphmod-1.4.2 (IavorDiatchki)
23:58:46 <koz_> dminuoso: That must be why Haskell so good.
23:58:59 <quicksilver> dminuoso: amazon famously have the policy of writing the press release first
23:59:10 <quicksilver> and then the FAQ
23:59:16 <quicksilver> and then actually building it
23:59:46 <dminuoso> quicksilver: Oh really?
