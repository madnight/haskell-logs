00:00:19 <qeyoa> cocreature: it seems like would have to rewrite this in a functional style, adding annotations makes this example look a bit silly: https://lpaste.net/3186685714372755456 and it still does not work
00:00:45 <qeyoa> i think i will just skip the idea of implementing the threeRoundFight function
00:00:50 <qeyoa> in this manner
00:04:16 <Lears> Is there a sane way to place a constraint on a * -> * kinded typevar that it derives a certain * kinded class? E.g. (forall a. Monoid a => Monoid (m a)) => ... (if that were legal)
00:06:22 <cocreature> qeyoa: I’m not sure why you think that looks silly. I find that significantly easier to understand than the version without type signatures. if you replace the tuple by something like "data RobotData = RobotData { robotName :: String, robotAttack :: Integer, robotHp :: Integer }", your type signature should shrink a bit
00:06:56 <cocreature> you could also consider making a newtype for "(String, Integer, Integer) -> ((String, Integer, Integer) -> t) -> t"
00:07:47 <cocreature> but I’m also not sure what you are hoping to achieve by choosing that slightly weird encoding
00:08:41 <qeyoa> what do you mean by "slightly weird encoding"?
00:12:16 <cocreature> you pass around these weird continuation style encoding of a robot rather than just passing around (String, Integer, Integer)
00:13:47 <qeyoa> this is an example from a book
00:13:54 <Lears> Oh, I want QuantifiedConstraints but it's GHC 8.6
00:14:27 <cocreature> qeyoa: well I don’t know the book but the example in the book probably doesn’t have a ton of type errors :)
00:14:55 <qeyoa> it does not, when i added my threeroundfight function
00:15:07 <qeyoa> was when i got the type error in the last line
00:15:36 <cocreature> even your getAttack function has a type error
00:15:41 <qeyoa> but anyway, this is not that important as i'm not going to write haskell code in this manner anyway
00:17:20 <cocreature> qeyoa: I’m curious. which book is that from? this seems like a pretty odd example to see in a Haskell book
00:18:57 <qeyoa> it's this one
00:19:00 <qeyoa> https://manning-content.s3.amazonaws.com/download/4/bc50b20-f943-494f-acea-6e338d3f575a/SampleLesson05.pdf
00:31:03 <maerwald> can you break the type system with DataKinds? and if so, how
00:31:35 <maerwald> I can't stop but have the feeling that it can't be consistent
00:34:07 * hackage vector-sized 1.0.4.0 - Size tagged vectors  http://hackage.haskell.org/package/vector-sized-1.0.4.0 (jophish)
00:36:23 <Cale> maerwald: Well, what do you mean by "break"? It doesn't make the type system any more inconsistent than it already is.
00:37:46 <Cale> If you disallowed general recursion to begin with and got rid of the type level recursion via newtype/data, then DataKinds wouldn't give you a way to reintroduce loops.
00:42:50 <pavonia> How powerful is GHC's type system currently, is it Turing-complete?
00:44:31 <Cale> Yeah, in a bunch of different ways, particularly if you turn on UndecidableInstances
00:47:35 <maerwald> I'm wondering if there is a way to encode in a type that its sub-types cannot be changed, unless you explicitly allow so.
00:48:08 <maerwald> say, you have a type that will be encoded into some binary form, and changing subtypes would break it
00:48:29 <maerwald> instead of just being careful and writing tests, it would be nicer to do it on type level
00:48:37 * hackage hw-parser 0.1.0.0 - Simple parser support  http://hackage.haskell.org/package/hw-parser-0.1.0.0 (haskellworks)
00:49:17 <Cale> I don't think you can do that kind of reflection directly at the type level, but you could certainly check something like that in TH.
00:49:46 <maerwald> I have a feeling this would be easy in ruby :P
00:51:12 <Cale> Seems impossible in ruby... given that it doesn't have a static type system at all.
00:57:31 <maerwald> well, it would fail at startup time :P
00:57:49 <maerwald> but you wouldn't have to write tests, but have crazy meta-programming reflection instead
01:04:18 <Cale> Well, that's sort of like the TH thing... though manipulating TH datastructures is usually not so fun, you could just dump the result of reifying your favourite datatypes and then check for equality with the actual result at compile time.
01:06:27 <maerwald> that sounds not too complicated, yeah
01:20:10 <revskill> How to handle multiple response types in Servant
01:28:01 <Guest72> Hello, I am browsing Data.IORef. Question: is there any usecase for the non `atomic` versions?
01:28:56 <rizary> between `streaming` and `conduit` which one did you use and find satisfied in your backend project? or any other project?
01:34:49 <revskill> https://hackage.haskell.org/package/streamly-0.4.0/docs
01:34:52 <revskill> How about this one ?
01:48:46 <abbe> hi!
01:49:12 <abbe> does anyone know what "type LinkType endpoint :: Type" is in https://haskell-servant.github.io/posts/2018-07-12-servant-dsl-typelevel.html ?
01:50:40 <cocreature> abbe: it’s an associated type family
01:50:59 <cocreature> abbe: the ":: Type" specifies the kind of the returned type
01:51:17 <cocreature> abbe: and Type is a synonym for *
01:52:45 <abbe> thanks, do you know where can I read more about it ?
01:53:19 <cocreature> about which part specifically?
01:54:11 <abbe> mostly trying to understand the "instance HasLink api => HasLink (Capture :> api) where"
01:54:32 <abbe> there they create a type instance (i believe?): type LinkType (Capture :> api) = String -> LinkType api
01:55:54 <abbe> actually in the next example.
01:55:58 <cocreature> there is https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#type-families
01:56:21 <piark_> hello
01:56:31 <cocreature> which has a subsection on associated type families but there is nothing particularly special about those once you understand “normal” type families
01:56:51 <cocreature> iirc there is also a page on the Haskell wiki that might be more approachable
01:56:51 <abbe> okay
01:57:29 <abbe> reading the wiki page, thank you for providing the name for that.
02:03:27 <fendor> does the haskell-ide-engine also work when I have single file projects? e.g. bang line for some stack script
02:03:52 <alanz> fendor, its supposed to
02:04:36 <fendor> alanz, would it require any configuration?
02:04:49 <alanz> nope
02:05:34 <fendor> maybe i need the hie-wrapper script or something? https://hastebin.com/eqahidajih.rb
02:06:41 <alanz> it works for me. Except my default GHC is currently 8.6a1, which is not supported in hie
02:07:07 <alanz> fendor, nix is the wild west for hie
02:07:31 <fendor> hehehe
02:07:36 <alanz> all I can say is that on a "normal" setup, (Debian testing, for me), it does work
02:07:37 <fendor> ok, then it is my fault
02:07:42 <fendor> probably
02:07:56 <fendor> maybe i can ask in the nixos irc
02:07:58 <alanz> well, fault is the wrong word. Nix requires you to be very particular about your setup
02:08:31 <fendor> alanz, it requires me to actually know what i am doing, which can be unfortunate
02:08:45 <alanz> that's another way of putting it
02:09:20 <reactormonk> I'm tinkering around with Generic.SOP - how would I write empty :: forall (deps :: [*]). NP Maybe deps ?
02:11:10 <fendor> kind of the arch experience
02:18:14 <fendor> does hie work with ghc 8.4?
02:18:32 <fendor> yes
02:18:35 <fendor> it does
02:46:15 <kuribas> why do I get "No module named ‘Data.Text’ is imported." https://pastebin.com/dDhz04xU
02:46:19 <kuribas> it's obviously imported
02:46:51 <toni1> hi
02:47:59 <kuribas> ghc bug?
02:52:16 <Lears> I get the same kuribas. Looks like it's an inaccurate error message for any module-name qualified value ghc can't find.
02:52:29 <kuribas> yeah
03:24:45 <asheshambasta> So, hmmm. I upgraded stack or cabal on my system and now stack throws errors like these: https://gist.github.com/asheshambasta/a563369d7fc8aa98c3a1341329665a39
03:24:57 <asheshambasta> I have no clue what is going on. Anyone have some pointers?
03:29:55 <int-e> kuribas: funny, it even does that for  :t Prelude.foo ... and it's been that way since ghc 8.0 (and before that, no such error was printed at all, as far as I can make out. so it has always been wrong.)
03:30:40 <kuribas> :t Prelude.foo
03:30:40 <int-e> kuribas: and by "no such error" I mean the "No module named ‘...’ is imported." part.
03:30:41 <lambdabot> error:
03:30:42 <lambdabot>     Not in scope: ‘Prelude.foo’
03:30:42 <lambdabot>     Perhaps you meant one of these:
03:30:53 <kuribas> int-e: yeah
03:31:27 <dreamer_> I cry
03:31:45 <dreamer_> when everything works with ghci and then it breaks when I build
03:33:22 <dreamer_> are the indentation rules in IO monad different ? that's crazy
03:35:17 <cocreature> dreamer_: I would recommend that especially as a beginner you define your code in a file and load that into ghci and limit yourself to typing very simple expressions in ghci
03:35:33 <dreamer_> I mean stack ghci
03:35:34 <int-e> dreamer_: ghci has some multi-line input hack that has its own indentation rules.
03:35:35 <dreamer_> sorry
03:35:46 <cocreature> that doesn’t change my statement :)
03:35:56 <dreamer_> as in Ioad the whole project into ghci
03:36:10 <dreamer_> from files
03:36:42 <int-e> :load <file.hs> and :reload (which can be abbreviated to :r) are very useful for that kind of workflow.
03:37:16 <cocreature> dreamer_: wait, so you get an error when you try to build your project using "stack build" but not when you load your project using "stack ghci"?
03:37:46 <dreamer_> yep, an indentation error
03:37:48 <dreamer_> let me paste it
03:41:02 <dreamer_> https://lpaste.net/8886569643624366080
03:43:10 <cocreature> ah yeah, that’s a confusing error. by default ghc has an extension called NonDecreasingIndentation enabled, however that extension is disabled if you compile in Haskell2010 mode which stack/cabal will do if you have a "default-language: Haskell2010" line in your cabal file
03:44:29 <erikd> i'm looking at https://hackage.haskell.org/package/time-1.9.1/docs/Data-Time-Format.html#v:formatTime
03:44:49 <dreamer_> woah thanks
03:44:57 <erikd> what do i use for TimeLocale if i *want* to format UTC?
03:47:55 <cocreature> erikd: the TimeLocale doesn’t have anything to do with the timezone you want to print your time in. if you want your time to be printed in utc, convert it to UTCTime
03:48:27 <cocreature> the timelocale determines the textual names for months and things like that
03:49:46 <erikd> cocreature: ah thanks. the documentation is not that clear
03:49:46 <zincy> If you have a function which purely determines if a state transition is valid in an automaton then would returning Maybe MyError be appropriate?
03:50:15 <zincy> I feel though Nothing to denote an absence of Error is a bit weird but cant think of anything better
03:50:34 <erikd> Either MyError () makes sense
03:50:51 <reactormonk> kosmikus, if you're around, what exactly is a projection in NP?
03:51:25 <dreamer_> hm I can't figure out how to add default-language: Haskell-2010 in hpack
03:51:47 <zincy> erikd: I like that thanks
03:52:03 <cocreature> reactormonk: a projection generally refers to the function that gives you one element of a product type
03:52:15 <cocreature> reactormonk: so for a pair, the projects are "fst" and "snd"
03:53:01 <dreamer_> in the library fields on the hpackgithub there is no field for defaultlanguage , maybe I'm getting it wrong
03:53:14 <reactormonk> cocreature, I'm trying to understand what https://github.com/well-typed/generics-sop/blob/master/src/Generics/SOP/NP.hs#L337 does / how it works
03:53:15 <cocreature> dreamer_: the build error suggests that it is already enabled, so maybe hpack adds it implicitely
03:53:56 <cocreature> reactormonk: looks like it gives you a product of functions for extracting the individual elements
03:53:57 <reactormonk> Currently trying to write a function (NP f xs) -> f x for a type-indexed lookup
03:54:45 <reactormonk> cocreature, oh, nice. Thanks.
03:54:48 <Berra> Working on a api client I'm using aeson for encoding/decoding of the JSON related to the API. However I have a data type representing the Query options for the API - and I need to serialize that. I could serialize it using aeson.. but that seems incorrect - and I imagine I should instead use cereal. Is this sound reasoning?
03:55:45 <cocreature> Berra: why would aeson be incorrect?
03:56:05 <cocreature> whether binary serialization or json serialization is appropriate depends on the context
03:57:00 <Berra> cocreature: I'm questioning if it's correct given that I'm serializing for the use in a queryString in a URL. Sure I of course can use ToJSON for that. I'm considering if I should or not.
03:57:29 <Berra> cocreature: I'm going to need a ByteString eventually to use with http-client
03:57:30 <cocreature> binary serialization seems even more inappropriate in that case
03:57:37 <Cale> Just be careful that whatever you're using to construct URLs does appropriate quoting.
03:57:46 <cocreature> then you end up having to base64 encode your query string or whatever
03:57:49 <Berra> cocreature: How come it's more inappropriate?
03:58:01 <Cale> Well, it'll result in even uglier URLs
03:58:06 <dreamer_> ok ok
03:58:41 <cocreature> I would generally see binary serialization as a form of optimization. if you don’t need it, stick to a textual serialization since it’s going to be easier to debug
03:58:55 <Berra> cocreature: http-client takes query string representations of type [(BS, Maybe BS)]
03:59:34 <Berra> cocreature: Makes sense - so maybe aeson does fit the bill perfectly since what you're allow to encode in an url is a subset of json
04:00:13 <cocreature> depending on how complex your params are, I wouldn’t even bother going via aeson and instead directly write an encoding to query params
04:00:22 <Cale> cocreature: Yeah, if you give Chrome binary websocket frames, it won't even display what's inside them.
04:00:53 <cocreature> if you want a typeclass, you could use the one in http-types https://hackage.haskell.org/package/http-types-0.12.1/docs/Network-HTTP-Types-QueryLike.html
04:01:33 <Berra> cocreature: I want all values of my Query record to share some way to serialize to a query string value representation so that I can generalize how the query record is turned into [(BS, Maybe BS)]
04:02:24 <Berra> cocreature: Oh - didn't happen upon that one. Looking at it now
04:02:58 <Berra> cocreature: Yea this is what I wanted but couldn't find. I must be blind.
04:05:02 <zincy> Can anyone refactor this function? https://lpaste.net/1292456762896547840       I feel as though there is too much repetition
04:06:54 <dreamer_> nice, another gamedev
04:07:32 <zincy> haskell is a dream for building the back ends of web games
04:08:21 <Cale> zincy: just bind the action to a variable and use a case expression inside
04:08:47 <Cale> (or even use \case)
04:09:39 <zincy> thanks!
04:09:49 <zincy> Do you a  link to \case ?
04:10:00 <zincy> Google is failing me
04:10:08 <Cale> http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-LambdaCase
04:10:28 <zincy> thanks
04:10:37 <Cale> Also, consider using Either GameErr
04:11:08 <Cale> The Maybe monad sort of goes in the wrong direction for most of this, because Nothing is supposed to be its error case.
04:12:28 <Cale> Even if it seems a little weird, Either GameErr () is probably more natural.
04:12:30 <zincy> Cale: Yes I am planning on Either GameErr ()
04:14:16 <marvin2> hi. is this supposed to work? because it doesn't.    read "2018-07-14 13:12:50.294596 Central European Daylight Time" :: ZonedTime   =>    *** Exception: Prelude.read: no parse
04:15:02 <marvin2> (the string above is what show <$> getZonedTime returns)
04:18:23 <cocreature> marvin2: looking at the source, no https://github.com/haskell/time/blob/0aa8e23cce380bca6a3c9cca9e3ea1b8becf68aa/lib/Data/Time/Format/Parse.hs#L163
04:18:51 <cocreature> marvin2: if you want to parse time use parseTimeM
04:20:06 <cocreature> oh missed the False parameter to parseParen
04:21:00 <marvin2> cocreature could this be considered a bug?
04:21:44 <cocreature> marvin2: dunno but you’re not supposed to use "read" for parsing input anyway :)
04:21:46 <marvin2> usually you can read what you show. always until now
04:21:51 <marvin2> for me anyway
04:22:05 <cocreature> that’s a rule of thumb but not a hard rule respected everywhere
04:22:18 <cocreature> usuall show should also not attempt to pretty print output
04:38:14 <ocramz> hullo !
04:40:18 <ocramz> I have a question/doubt on tooling
04:40:32 <ocramz> the relationship between stack and hackage, specifically
04:41:15 <ocramz> so, by default "sdist" doesn't package up the stack.yaml file, so there's no telling for a user of the package which stackage snapshot(s) the package can be built with
04:41:45 <ocramz> wouldn't it be simpler if stack managed the lower package bounds in the .cabal file, based on the stackage snapshot?
04:42:27 <ocramz> otherwise, figuring out the lower bounds is a pretty tedious job
04:43:17 <cocreature> ocramz: sounds like you are looking for the --pvp-bounds option in "stack upload"
04:43:27 <ocramz> aha !
04:43:29 <cocreature> (or sdist)
04:43:47 <ocramz> I knew this was too trivial to be an open problem ;)
04:43:49 <ocramz> thanks cocreature
04:43:56 <cocreature> np :)
04:48:37 * hackage primitive-extras 0.3 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.3 (NikitaVolkov)
04:55:16 <orion> I have a Monad transformer: newtype App a =
04:55:19 <orion> err
04:55:53 <orion> I have a Monad transformer: newtype App a = App { runApp :: ReaderT AppEnv (FooLibraryT IO) a }
04:56:09 <cocreature> that’s not a transformer
04:56:12 <orion> I guess at this point it's just a plain Monad.
04:56:28 <orion> cocreature: Right, otherwise it would be AppT m a ...
04:56:28 <cocreature> yep
04:57:27 <orion> I want to call a function whose type is FooLibraryT IO Int from within App. I am able to do it via this function: f x = App . ReaderT $ \_ x
04:58:03 <orion> Am I approaching this incorrectly? I feel like the function 'f' here is a very common pattern.
04:58:58 <cocreature> if there is no typeclass that abstracts over what FooLibraryT does, then that is probably the right choice
04:59:21 <reactormonk> orion, lift
04:59:40 <cocreature> libraries like mtl work around this by abstracting over the behavior provided using a concrete Monad transformer
04:59:52 <cocreature> "lift" doesn’t help you directly because App is not a transformer
05:00:00 <cocreature> at the very least you still have to do the newtype wrapping
05:00:01 <reactormonk> cocreature, oh, right.
05:00:12 <reactormonk> coerce . lift
05:00:28 <cocreature> that’s not really an improvement over App . lift :)
05:00:47 <reactormonk> ... just listen to cocreature
05:01:19 <orion> Ok, that worked too.
05:01:28 <cocreature> the problem with "lift" is that it forces you to manually choose how many levels of lifting you want
05:01:53 <cocreature> that’s why mtl provides typeclasses like MonadReader that use instance selection to figure out the right amount of lifting
05:02:53 <orion> FooLibraryT is a ReaderT underneath, and its purpose is to interact with a RESTful API.
05:03:40 <reactormonk> what's the type signature of one of the FooLibraryT functions?
05:05:13 <orion> https://gist.github.com/centromere/baec6675fba1bce04c2a885410bcc0b6
05:06:50 <orion> Should it even *be* a transformer?
05:07:21 <reactormonk> You could write yourself a wrapper that's moving the FooLibraryT into an mtl MonadReader - or just say "screw it" and go generalize the library signatures.
05:08:57 <orion> Generalize the library signatures? You mean with a MonadReader FooLibraryEnv m typeclass constraint?
05:10:09 <reactormonk> Exactly
05:10:27 <orion> Would it be helpful/less confusing to make FooLibraryT m a in to FooLibrary a where m = IO?
05:10:48 <reactormonk> similar to https://www.stackage.org/haddock/lts-12.0/amazonka-1.6.0/Control-Monad-Trans-AWS.html#t:AWSConstraint
05:11:33 <roconnor> Is there an equivalent of instance Monoid r => MonadPlus (Cont r) implemented anywhere?
05:12:28 <reactormonk> orion, I think the amazonka design of the mtl stuff is reasonable.
05:13:32 <orion> reactormonk: Cool, thanks for the example.
05:16:08 <ggVGc> hm.. I think I actually, for the first time ever, need type families :|
05:16:42 <ggVGc> I have a class A, and a class B, and I'd like to make an instance for B for any types that also have an instance of A
05:16:45 <ggVGc> this is type families, right?
05:17:55 <lyxia> doesn't sound like it
05:18:00 <ggVGc> hm
05:18:05 <ggVGc> what could I do then?
05:18:23 <lyxia> derivingvia would be useful
05:18:37 <lyxia> but it's a bleeding edge feature
05:19:03 <ggVGc> :(
05:19:08 <ggVGc> I feel like I'm doing something stupid then
05:26:41 <cocreature> ggVGc: define functions corresponding to the implementation of B’s methods in terms of A
05:26:50 <cocreature> then in the instance declarations reference those methods
05:33:33 <ben> im reading about ghc stop-the-world gc pauses scaling linearly with live heap size etc
05:33:45 <ben> at what kinda heap sizes do i actually need to worry about that sort of thing?
05:40:07 * hackage potoki-core 2.2.2 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.2.2 (NikitaVolkov)
05:41:07 * hackage potoki-core 2.2.2.1 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.2.2.1 (NikitaVolkov)
05:43:37 * hackage potoki 2.0.2 - Simple streaming in IO  http://hackage.haskell.org/package/potoki-2.0.2 (NikitaVolkov)
05:52:27 <dmwit> ben: Maybe never. Depends on your goals.
05:52:43 <dmwit> e.g. games care a lot about GC pauses; scientific computing cares not at all
05:54:33 <dmwit> ggVGc: You might like DefaultSignatures. It would let you write, e.g. `class B a where foo :: a -> a; default foo :: A a => a -> a; foo x = useAnAMethodHere x`
05:55:01 <dmwit> ggVGc: You still need to write one `instance B X` for each `instance A X`, but at least there doesn't need to be any code inside the `B` instance.
05:55:30 <ben> my frame of reference is maintaining a network service with a dozen GiB or two of live heap per process
05:55:49 <orion> reactormonk: What does generalizing the type signatures buy me?
06:02:52 <ahri> I have a function `a -> b -> m (Either Error b)` and I have a list of `a`s and a `b`, I want to sequentially apply my function maintaining the semantics of `Either`. I'm not familiar with MTL and I can't see how to use `ExceptT` to actually solve my goal. Previously I didn't have the wrapper `m` and I was using `foldM` which worked nicely. Where am I going wrong?
06:04:06 <reactormonk> orion, no lifting required
06:13:37 * hackage haskdogs 0.5.3 - Generate tags file for Haskell project and its nearest deps  http://hackage.haskell.org/package/haskdogs-0.5.3 (SergeyMironov)
06:15:48 <orion> reactormonk: Would you be abble to characterize the "mtl style" in a single sentence?
06:16:05 <the_2nd> Any suggestions for cross-platform UI frameworks/libs?
06:16:29 <orion> the_2nd: blaze-html
06:16:57 <the_2nd> orion, no decent non-web solutions?
06:19:08 <orion> the_2nd: Not that I can think of.
06:22:43 <lyxia> ahri: once you compose that function with ExceptT you get  (a -> b -> ExceptT Error m b)   and (ExceptT Error m) is a monad so you can think of it as (a -> b -> m' b) and use the usual monadic combinators
06:22:45 <reactormonk> orion, there's http://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html
06:22:51 <reactormonk> and https://www.fpcomplete.com/blog/2017/06/readert-design-pattern
06:24:04 <orion> Thank you. Though I was wondering if the "essence" of mtl could be distilled down. Maybe it can't.
06:25:33 <reactormonk> orion, I could, but using terms that already have a specific meaning. To understand a single-sentence explanation, you gotta go the long way.
06:26:07 * hackage hw-json 0.8.0.0 - Memory efficient JSON parser  http://hackage.haskell.org/package/hw-json-0.8.0.0 (haskellworks)
06:30:55 <tirej> in haskell wiki there is fn defined as "echoes = foldr (\ x xs -> (replicate x x) ++ xs) []" which has confused me because foldr requires 3 args and there is only 2 without the arg. and is x and xs in lambda represent the [] or  am i missing something? btw, i am new to haskell.
06:31:24 <tirej> the acc arg*
06:34:38 <dennisb> tirej: foldr take 3 arguments and you give it 2, so echoes is a function that take 1 argument
06:36:22 <Guest4n0n> dennisb: but still not clear to me, echoes takes the array e.g [1,2,3] not the accumulator isnt that right?
06:37:13 <hpc> Guest4n0n: if you have something like f x = g x
06:37:16 <Guest4n0n> where the acc gets passed to the foldr ?
06:37:18 <hpc> Guest4n0n: you can write it as f = g instead
06:37:19 <dennisb> yes, it take the list (in this case) as an input and produce a list as output
06:38:50 <Guest4n0n> hpc: so it automatically passes the arg? no arg order is required?
06:39:02 <ahri> lyxia: I think I understand, and I'm trying to apply that technique but I'm struggling to get it compiling; https://gist.github.com/ahri/40889b27b0da96fb7be3ee0783e002de
06:40:37 * hackage table-layout 0.8.0.2 - Layout text as grid or table.  http://hackage.haskell.org/package/table-layout-0.8.0.2 (muesli4)
06:40:39 <hpc> Guest4n0n: the concept here is currying
06:40:47 <Guest4n0n> hpc: according to foldr signature the acc arg should be passed right before the []. but i dont see any acc arg here?
06:40:59 <dennisb> you could evaluate the expression (see, foldr got all 3 arguments): foldr (\ x xs -> (replicate x x) ++ xs) [] [1,2,3]
06:41:13 <Berra> https://lpaste.net/3889579901459628032 Anyone have some advice (not saying it's needed) on how one would best derive the implementation? I could map over the fields but I don't know how I would match the fields to the lenses corresponding to them.
06:41:30 <lyxia> ahri: replace (ExceptT z) with z. What is the error message?
06:41:45 <hpc> the arg order of foldr is foldr f z list
06:41:58 <hpc> and the result is list, with (:) replaced with f
06:42:01 <hpc> and [] replaced with z
06:42:22 <hpc> > foldr f z (1 : 2 : 3 : []) :: Expr
06:42:25 <lambdabot>  f 1 (f 2 (f 3 z))
06:42:39 <hpc> so in your definition, [] is z
06:44:03 <lyxia> Berra: here's a short generics example https://wiki.haskell.org/GHC.Generics
06:44:46 <haskell_noob5> Where do i find haddock.sty? I am not able to generate pdf documentation, latex2pdf complains about missing haddock.sty file.
06:45:37 <Berra> lyxia: Ok thanks - it does not become apparent to me how I move forward with my example reading that. I guess I need to read more and build up more intuition.
06:45:57 <Guest4n0n> thanks hpc and dennisb very helpful
06:47:58 <ahri> lyxia: I've put it in a repl so you can see the error: https://repl.it/repls/LawfulBowedUnit
06:48:00 <lyxia> Berra: you don't need to map fields to their lenses, since you have direct access to the fields
06:48:48 <Berra> lyxia: I'm guessing what I should do is to define instances QueryValueLike as described in the wiki you linked.
06:49:20 <Berra> lyxia: For products types - and it would then work for my Query?
06:50:17 <lyxia> ahri: there I fixed it
06:50:43 <ahri> lyxia: I think that website forks the code each time, do you have your URL so I can compare?
06:51:39 <lyxia> ahri: https://repl.it/repls/ImmediateBelatedTaskscheduling
06:53:31 <lyxia> Berra: you need at least a new GQueryLike class which is to QueryLike as GSerialize is to Serialize
06:53:52 <Berra> lyxia: Hm - I see I see. Ok I'll try.
06:57:00 <ahri> lyxia: ah, I see. Thank you very much! I got myself very confused there
07:14:58 <orion> I am faced with a choice: Add a Logging function to my ReaderT Env, or use MonadLog from the logging-effect package. What are the trade-offs?
07:54:17 <zincy> How would I get this stm action to retry based  on the value read failing some predicate?    readTChan dupChan >>=   ???
07:54:45 <akfp> Anyone happen to know if the <> operation on finger trees is associative - i.e. if the resulting tree data structure is identical?
07:54:53 <akfp> Data.Sequence
07:57:40 <zincy> Taking a shot here readTChan dupChan >>= \msg -> if isValidAction then return msg else retry
07:58:35 <cocreature> zincy: readTChan dupChan >>= \msg -> guard isValidAction *> pure msg should also work
07:59:12 <zincy> ooh thanks :)
08:00:46 <cocreature> zincy: note that guard is not specific to SMT, it works for anything that is an instance of Alternative
08:01:14 <zincy> :t *>
08:01:16 <lambdabot> error: parse error on input ‘*>’
08:01:23 <cocreature> :t (*>)
08:01:24 <lambdabot> Applicative f => f a -> f b -> f b
08:01:33 <cocreature> that’s the Applicative version of >>
08:01:58 <zincy> :t >>
08:01:59 <lambdabot> error: parse error on input ‘>>’
08:02:08 <zincy> :t (>>)
08:02:09 <lambdabot> Monad m => m a -> m b -> m b
08:02:26 <cocreature> x >> y = x >>= \_ -> y
08:02:38 <zincy> So does guard have the effect of throwing away the result of the channel read based on the predicate
08:03:34 <zincy> Also STM must be an instance of applicative then
08:04:07 <cocreature> guard isValidAction *> pure msg = (if isValidAction then pure () else retry) *> pure msg
08:04:37 * hackage FAI 0.1.0.17 - Haskell Foreign Accelerate Interface  http://hackage.haskell.org/package/FAI-0.1.0.17 (qinka)
08:05:09 <zincy> what would pure () do ... surely that would return an STM () ?
08:05:35 <zincy> I would have thought you would want to return an STM MyMsgType
08:08:03 <cocreature> you do return an SMT MyMsgType, you missed the *> pure msg part
08:08:05 <cocreature> :t (*>)
08:08:07 <lambdabot> Applicative f => f a -> f b -> f b
08:08:14 <cocreature> the return type is determined by its second argument
08:12:01 <zincy> Ah okay so the guard expression before the  *> essentially short circuits the monadic sequence based on the predicate
08:12:04 <zincy> I think I get it now
08:12:06 <zincy> thanks
08:12:13 <roconnor> akfp: I'm not certain but I expect the trees will not be identical in general.
08:14:09 <roconnor> akfp: I don't think there are any functions in Data.Sequence that can observe the difference though.
08:18:41 <w1n5t0n> is anyone aware of any 1D smooth noise functions? I'm looking for something that, given an increasing/decreasing double, will return a perlin noise-like shape
08:19:02 <the_2nd> perlin noise?
08:19:27 <hpc> w1n5t0n: a simple technique is to just sample a line in higher-dimensional noise space
08:20:02 <w1n5t0n> hpc: so use a 2D function and keep one axis constant?
08:20:13 <hpc> this trick is commonly used to make 2d noise that wraps
08:20:19 <hpc> by sampling a torus in 4d space
08:20:25 <hpc> yeah
08:21:27 <hpc> it miiiight need to be sampled in 3d space in order to remain perlin noise?
08:22:00 <hpc> i suggest looking it up online, i don't know the math but there's some issue like that for the 4d/2d trick
08:22:09 <hpc> which makes sampling from 3d space not work
08:22:27 <w1n5t0n> are there any efficient implementations? I'm not visualizing so it doesn't have to look perfect, I just want to add some non-periodic smooth randomness to sonified signals
08:22:45 <hpc> ah
08:22:59 <hpc> search hoogle for "noise", iirc that's the one i used
08:27:55 <gentauro> so I ended up installing Elm like this -> https://lpaste.net/3563948099690823680
08:28:32 <gentauro> I then noticed when I try to open a .hs file from the root (where stack.yaml) is saved, I get issues with intero
08:28:47 <gentauro> it's like intero doesn't understand the "package" contect in a project
08:28:49 <gentauro> :\
08:30:08 <gentauro> is there a way to tell "intero" that it should look for .stack-work where "stack.yaml" is and not for it in each of the packages
08:30:34 <gentauro> as I'm assuming it's doing?
08:31:21 <cocreature> I somewhat doubt that this is what it is doing. what’s the error you are seeing?
08:37:21 <gentauro> cocreature: "/home/user/scripts/elm/elm-platform/elm-make/: getDirectoryContents:openDirStream: does not exist (No such file or directory)"
08:37:29 <gentauro> hmm
08:38:08 <gentauro> looks like it can't see the other folders
08:38:15 <gentauro> I will delete it all and start again
08:38:18 <gentauro> one second
08:40:44 <gentauro> I mean, it should work (even with url like github) -> https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#i-need-to-use-a-package-or-version-of-a-package-that-is-not-available-on-hackage-what-should-i-do
08:40:53 <gentauro> (but that is just stack)
08:42:21 <gentauro> maybe the thought is that you shouldn't be making changes to packages, therefore it doesn't give sense to support intero
08:42:44 <gentauro> but I find it usefull to read code that way ...
08:47:17 <gentauro> OK, so it actually worked :o
08:47:34 <gentauro> I just had to remove all .stack-work from each folder
08:47:41 <gentauro> and now it's working as expected :D
08:55:49 <albeit> I am reading data form threaded sockets, processing it through a series of concurrent queues, and then writing to files (whose handles are stored in a state). But at some randomish point during execution, it will just stop writing to specific files with no exceptions or other indication of failure. I feel like it is related to lazy IO, but don't know how - any ideas?
08:59:31 <gentauro> albeit: I maybe have something related to that. I just pipe from sockets to stdout (and piping output to a file)
08:59:48 <gentauro> nothing really hapens, util I close the server, then the client actually writes to disk ...
09:00:02 <gentauro> I haven't found out why, but I'm guessing it's the lazy IO as well
09:02:02 <albeit> gentauro: Are you using the pipes package? I thought that should mainly solve the lazy IO issues...
09:04:27 <cocreature> writes are not lazy
09:04:39 <cocreature> it’s reads that are sometimes lazy depending on the API
09:04:47 <maerwald> I never understood the need for lazy IO. You should just code in such a way that you only do syscalls when you actually need them.
09:09:13 <gentauro> albeit: I mean, I pipe in `bash` the output of my Haskell bin
09:09:33 <gentauro> I just wonder why, nothing is outputted to the file (foo > log.txt)
09:09:44 <gentauro> until I kill the server where foo is connected to :|
09:10:02 <cocreature> sounds like a buffering problem
09:11:08 <gentauro> cocreature: probably :\
09:12:03 <geekosaur> import System.IO and use (hSetBuffering stdout NoBuffering)
09:12:09 <Boomerang> gentauro: Would "hSetBuffering stdout NoBuffering" help? Or a few "hFlush stdout"
09:13:16 <reactormonk> Looks like I'm running the compiler around a loop agian... https://gist.github.com/reactormonk/d5ac1cdf49a6a595eebbba1c74d3d41f
09:13:35 <Boomerang> I think the default is LineBuffering, if that's the case and you're not outputting any "\n", then you won't see anything
09:14:14 <geekosaur> default to a pipe will be block buffering. usually 4k or 8k
09:14:28 <geekosaur> linebuffering is only to a terminal or something that looks like one
09:14:37 <geekosaur> (this behavior is taken from C's stdio)
09:14:55 <Boomerang> Ah, good to know! :)
09:19:59 <gentauro> Boomerang: I'm using `putStrLn`
09:20:00 <gentauro> :\
09:20:23 <geekosaur> so?
09:20:25 <gentauro> like regular pipe to stdout
09:20:46 <gentauro> I don't think that is lazy, unless you use the L8.putStrLn right?
09:21:00 <geekosaur> this is not laziness, it is buffering, the same I/O buffering C does
09:21:29 <geekosaur> which was just discussed and you apparently ignored, so here is a repeat: output to a pipe is block buffered, 4k or 8k. output to a terminal is line buffered
09:21:49 <gentauro> ahh, didn't see that :)
09:28:53 <glguy> L8.putStrLn is not lazy
09:40:23 <monochrom> It is not like if you are not watching then L8.putStrLn will not print.
10:01:29 <albeit> If I'm writing to ~10 files that grow to about ~10GB, is there any reason why the platform/OS would stop writing to one of them, assuming there is enough disk space?
10:06:59 <hexagoxel> how do i write the unidirectional pattern synonym that never matches?
10:10:25 <glguy> You could use a PatternSynonym for a ViewPattern with const False
10:12:37 <hexagoxel> yeah. but i think that only works for arity 0?
10:12:38 <hpc> how do you write a regular pattern that never matches?
10:12:55 <hexagoxel> _ | False ->
10:13:01 <hpc> ah right
10:14:41 <glguy> then I don't understand the question: pattern NoMatch <- (const False -> True) ; case 'a' of NoMatch -> 1; _ -> 2 ; -- 2
10:15:00 <pavonia> Why would you use such a pattern?
10:15:12 <cocreature> albeit: I don’t see one. are you sure that the threads writing to the files are still alive and that there is data to write?
10:16:44 <hexagoxel> #if APIVERSION1 pattern MyCompatFoo x <- Foo x
10:16:58 <hexagoxel> #if APIVERSION2 pattern MyCompatFoo _ <- (const False -> True)
10:17:20 <hexagoxel> "parse error on input ‘_’"
10:17:25 <hexagoxel> meh :p
10:18:54 <albeit> cocreature: The threads are called with forkFinally with logging if something is thrown, so I'm pretty sure the threads are still alive. And I have alarms/timers that checks the sockets if there is no data for some duration, and they aren't firing, so there should be data to write.
10:19:19 <hpc> pavonia: i can see it being useful for iterating on a function you haven't finished writing yet
10:19:26 <cocreature> albeit: maybe start by throwing strace at the process?
10:20:52 <cocreature> albeit: the various RTS options provided by GHC might also be useful
10:21:37 <geekosaur> albeit: buffering if one is not growing quickly enough to force regular flushes. file size rlimits (or cgroups limits)
10:22:23 <geekosaur> as mentioned, I'd probably be using strace from the syscall direction, and probably Debug.Trace to check the haskell side
10:23:40 <albeit> Okay, buffering is set to LineBuffering, so I think that's not the issue. The file "hang" happens hours into the process, so really hard to debug. I'll try some strace/traces
10:25:10 <cocreature> you can attach strace to a running process
10:26:12 <albeit> Ah okay. Never used it before, just looking at it now. Would I mainly be looking at strace logs to see if there are references/writes/errors to the hung file of some sort?
10:27:15 <cocreature> often the syscall that your program is stuck in can give you some ideas as to what it might be doing
10:30:55 <albeit> Okay. Thanks!
10:52:29 <erisco> The curry must flow.
10:52:38 <dataN> implementing 'difference :: f a -> (f a -> f a,f a)' for 'f = Free g' allows for a "vertical" zipper over e.g. 'g = Zipper []', where 'Zipper f a = [f a ->f a] f a'. this is daunting at type level.
10:53:07 <dataN> (f a)*
10:57:07 <dataN> e.g. 2d grids can have their dimensions specified at compile time using type level Nats, so that the type level representation can be constructed (specifying the dimensions as kind level Nats!?) and then zipping up down left and right at type level, in order to prove properties about the validity of the definition of structures in terms of their specified type level navigational programs.
10:58:37 * hackage byteunits 0.4.0.2 - Human friendly conversion between byte units (KB, MB, GB...)  http://hackage.haskell.org/package/byteunits-0.4.0.2 (chrissound)
10:59:42 <dataN> running sanity checkers for the implementation of types at compile time to see if they are reasonable in a comprehensive way
11:01:26 <erisco> IRC remains superior to Slack because here I can modify my part messages.
11:03:18 <hexagoxel> ah, i was stupid. the solution is
11:03:29 <hexagoxel> pattern MyCompatFoo x <- (const Nothing -> Just x)
11:04:08 <hexagoxel> which extends to arbitrary arities, too
11:07:51 <marxS> what sort of programs does haskell (or functional programming in general) work particularly well for?
11:08:18 <lyxia> haskell compilers
11:08:24 <int-e> compilers
11:08:25 <int-e> hah
11:08:49 <monochrom> Data processing programs.
11:09:36 <int-e> it's probably not a good question... the answer tends to be whatever someone has written a well-designed library for
11:09:49 <erisco> it works really well for the programs you write with Haskell
11:10:47 <marxS> int-e, that's fair to say
11:11:28 <int-e> Since Haskell is quite excellent for abstractions, it is usually possible to design such libraries. It also has a quite nice FFI so libraries can overcome many performance problems by interfacing C code.
11:11:59 <marxS> ok nice
11:12:11 <glguy> hexagoxel: What does involving Maybe buy?
11:12:28 <marxS> I'm creating a new prog dept at a company and so wanted to explore using haskell as the base
11:12:30 <statusfailed> is there a nice way to do a "scan" with lens? e.g. cumulative values of 2nd elements of [(Int, Int)]
11:12:47 <hexagoxel> glguy: we can some bind some variables to use on the left
11:12:49 <glguy> statusfailed: like: scanlOf ?
11:13:11 <erisco> Why would you found the department on technology you are not familiar with? Who is going to lead?
11:13:16 <statusfailed> glguy: :O
11:13:32 <glguy> statusfailed: I mean: scanl1Of
11:13:59 <monochrom> erisco: Perhaps they will then hire you to lead. :)
11:14:00 <marxS> erisco, I hire somebody to lead lol
11:14:24 <marxS> but on the job description I can put "looking for haskell programmer" etc
11:14:29 <erisco> I'll need double my current salary and probably a work visa ;)
11:14:48 <statusfailed> glguy: yep, I still should've found that.... thanks :-)
11:14:58 <glguy> hexagoxel: Ah, I see.
11:15:01 <hexagoxel> i am trying to (ab)use pattern synonyms to avoid breaking up a pattern-match with CPP
11:15:21 <hexagoxel> where the CPP is necessary because of API changes of the data type being matched on
11:15:29 <monochrom> With the Canadian dollar dropping, they don't have to change anything, and your salary will double automatically >:)
11:15:35 <erisco> lol
11:15:38 <hexagoxel> it has changed, new, and deleted constructors
11:15:47 <erisco> I am not so confident in the US dollar right now with these trade wars going on
11:17:25 <int-e> So what is Haskell bad at... I guess when it comes to hard real time (garbage collection is a problem there), or really small platforms with tight memory constraints. Though this is not inherent in Haskell itself, but really a matter of implementations.
11:17:46 <int-e> Do we have any maintained Haskell compilers left besides ghc? Is jhc or some derivative still around?
11:17:46 <erisco> marxS, I am sure you already know this, but the choice of technology is not going to be the most significant factor to your department's success or failure. It will be the people.
11:17:59 <monochrom> Haskell could be bad at some high-performance code. (But not all.)
11:18:15 <monochrom> ghcjs
11:18:46 <marxS> erisco, yeah for sure - although generally speaking, those who I've interviewed who are competent in functional programming have better problem solving skills
11:19:15 <int-e> (jhc is the only implementation I remember that cared about code size.)
11:20:16 <erisco> marxS, well if everyone is going to be a new hire then go for it.
11:20:30 <int-e> Anyway, hardware tends to be big and people manage to use Haskell with soft realtime requirements (music synthesis being the most prominent case, perhaps)
11:22:00 <erisco> I am extrapolating from my anecdotal evidence, but from what I see, those involved with FP excel above others in autodidacticism, out of necessity.
11:26:30 <infinisil> How do I go about defining my own FancyMonadT?
11:26:54 <infinisil> class FancyMonad a where <define operations it supports here>
11:27:05 <infinisil> class FancyMonad m where <define operations it supports here>
11:27:19 <erisco> infinisil, you define a data type which implements Monad
11:28:02 <dmj`> Anyone have an implementation of logistic regression in Haskell
11:28:44 <infinisil> Okay so then I'd do something like newtype FancyMonadT a = FancyMonadT (StateT IO a)
11:28:56 <infinisil> If I wanted to run it on something that has IO?
11:29:09 <int-e> infinisil: You don't really need such a type class unless you want to interact with monad transformers without writing "lift" all the time. And you can add the type class later when that actually happens.
11:29:27 <erisco> infinisil, your question is too big. Here is a talk which may give you some ideas on simple Monads you could make. https://www.youtube.com/watch?v=GlUcCPmH8wI
11:29:30 <int-e> infinisil: that looks like a good start (but you didn't add the actual state for the StateT)
11:29:43 <infinisil> int-e: I'm going for mtl style though
11:29:48 <erisco> granted it is PureScript and not Haskell, but the languages are similar enough that you should have no problem.
11:30:01 <int-e> infinisil: and I guess FancyMonadT is a misnomer since it's not a transformer.
11:30:20 <infinisil> Oh right, so I should take an m and use s/IO/m
11:30:26 <infinisil> erisco: I'll take a look thanks
11:30:34 <int-e> infinisil: if you want a transformer, you may end up with... that, and MonadIO constraints for m.
11:31:39 <infinisil> Hmm I see
11:31:51 <erisco> The talk goes down a path of abstracting ordinary effectful code, and takes advantage of Monad to do so.
11:32:03 <int-e> my usualy attitude there is to keep it simple... don't introduce a class, don't make a transformer, unless I find I actually need them.
11:32:14 <int-e> *usual
11:33:33 <infinisil> My whole code is structured in mtl style already though, what I'm going for is to be able to do add `MonadFancy m => ` to functions and be able to use it
11:33:48 <infinisil> And have a runFancy function to "untransform" it
11:34:24 <erisco> In OOP you might find it similar to dependency injection.
11:34:58 <infinisil> I'll just try messing around with newtype and classes a bit
11:35:00 <int-e> I complain about this in OOP as well... all these interfaces with a single implementation...
11:35:21 <infinisil> Hmm.. That is a good point..
11:36:11 <dmwit> Do you want FancyMonad to do something that MonadState+MonadIO don't already do?
11:36:29 <erisco> That sometimes happens in OOP because of a tribal adherence to certain practices. Having an interface for everything is one such practice. The idea is that this lets you modify or adapt your code more freely in the future.
11:36:55 <int-e> erisco: I know. But I don't have to like it :)
11:37:07 <infinisil> dmwit: I want to bundle related functionality into that monad, and it needs State and IO to implement it
11:37:15 <erisco> In my opinion, every ill-devised abstraction is a future burden.
11:41:24 <erisco> This is because it is easy to justify doing the least work to implement new features. As a result, the poorly designed abstractions will be used but their use will be clumsy.
11:42:17 <infinisil> Hmm.. Okay so I might just go for a bunch of functions that each have MonadState and MonadIO as their constraints
11:42:22 <dmwit> infinisil: Why not just write the related functionality to be polymorphic over MonadState+MonadIO, then?
11:42:29 <infinisil> Heh
11:42:38 <int-e> erisco: It may even come at a cost... There's an ocaml code base I'm involved with which defines module types for basically everything... which are resolved at runtime (since ocaml 3.12 which introduced first-class modules), causing a 0.3s startup overhead. That's not terribly big but completely unnecessary, so it annoys me. Not enough to actually refactor the code, mind you, but still...
11:42:43 <dmwit> (There *are* good reasons not to do that. But I wonder whether you're in the situation where those reasons apply.)
11:42:56 <erisco> I have seen abstractions so ridiculous that the use of a generic type parameter becomes  if (T instanceof Impl1) { ... } else if (T instance of Impl2) { ... } ...
11:43:06 <infinisil> I'm honestly not quite sure what I really want/need. I guess I'll just code a bit and see if problems arise
11:43:16 <dmwit> (e.g. look at MonadRandom. The RandomT that is the canonical instance is just a newtype wrapper around MonadState. But there's a very good reason not to just reuse MonadState.)
11:43:17 <erisco> The exact antipattern of a generic type parameter! Depressing.
11:43:32 <dmwit> *newtype wrapper around StateT
11:44:33 <int-e> But ghc is often quite good at resolving type classes statically (and one can SPECIALIZE code when that fails) so the overhead of abstracting an interface in a typeclass is generally not much of an issue for Haskell.
11:44:35 <erisco> infinisil, I suggested that talk because it will reveal to you a need present in most applications.
11:45:05 <infinisil> erisco: That is? I am writing an application right now and it's getting to a decent size
11:45:54 <Zemyla> Hmm, I had a potentially silly thought. Would it be desirable for Seq.fmap to run in the ST monad, make a hash table of all the elements and nodes it's fmapped over so far, and potentially refer to that to reduce the size of the resulting Seq?
11:46:16 <Zemyla> So that, for instance, fmap f (replicate n a) would truly be equal in structure to replicate n (f a)?
11:46:28 <erisco> infinisil, minimally, a use is to enable offline testing of your application. By using the proposed technique, you will be able to provide dummy or in-memory implementations of effectful actions.
11:46:46 <infinisil> erisco: Ah I see, yeah I thought about something like that
11:47:17 <erisco> More broadly, it will be possible to give many interpretations to your program.
11:48:02 <Zemyla> For instance, rnf (fmap traceShowId $ replicate n a) would only show a single trace instead of n of them.
11:48:16 <erisco> Another such use I can think of is to enable deeper inspection of your program. You could, for example, automatically log the use of every effectful action as part of interpretation.
11:48:45 <erisco> Logging remains an important diagnostic tool, especially for remote systems.
11:49:24 <infinisil> erisco: Whoa, that is indeed something I could use.. I'm currently just using MonadLogger where I desperately need it
11:49:53 <erisco> Yes. This subverts how logging would be done. Instead of inline with your program, it is done outside of it, so to speak.
11:50:41 <erisco> You should develop a good sense for what you can do with Monad in an interpretive sense. For example, Pipes and Conduit can be understood from this perspective.
11:51:02 <infinisil> I'll keep the talk in a tab for later viewing then
11:51:07 * hackage hadolint 1.10.3 - Dockerfile Linter JavaScript API  http://hackage.haskell.org/package/hadolint-1.10.3 (lorenzo)
11:51:55 <erisco> "yield" and "await" are actions which are interpreted by the Pipes library. I often find tasks difficult to describe with Pipes or Conduit, but you will be able to create your own vocabulary if such a need arises.
11:54:03 <int-e> Zemyla: That could be a fun exercise (you could do it for any Traversable, not just Data.Seq.Seq). But I'm not sure how useful it would really be. Haskell implementations lose sharing all the time, because preserving sharing tends to be expensive.
11:54:52 <Zemyla> Well, it'd at least be somewhat useful for Seq, because you could share not just values but Nodes and Digits.
11:55:24 <erisco> I would say that 95% of programming I do nowadays is from the perspective of defining vocabularies and interpreting them.
11:58:11 <int-e> Zemyla: if your Seq has many duplicate elements and you are going to fmap them a lot, it may be more efficient to just change the representation... a Seq Int and an accompanying array mapping the ints to the actual values.
12:00:27 <int-e> Zemyla: Anyway, as I said, it's a cute operation and probably fun to implement but I have doubts about it being actually useful.
12:04:54 <rotaerk> hmm, recently, I upgraded to the latest version of nixpkgs, and found that my program was throwing an error like this:  /nix/store/bmlp2ppjxxfsd15fgh1jw44l17p4iw6a-libGL-1.0.0/lib/libGL.so: undefined symbol: __GLXGL_CORE_FUNCTIONS)
12:06:52 <rotaerk> I found that it was loading the wrong libGL.  this was because the correct one, specified in the LD_LIBRARY_PATH environment variable, wasn't being used.
12:07:13 <rotaerk> it turned out that this was because the binary was linked with the ELF dtag called RPATH set instead of the one called RUNPATH
12:08:17 <rotaerk> because RPATH overrides LD_LIBRARY_PATH, but LD_LIBRARY_PATH can override RUNPATH
12:09:03 <rotaerk> and this was because someone upgraded to the latest binutils version in nixpkgs, and the patch that causes binutils to be built with RUNPATH on by default ... stopped working with the latest version of binutils
12:09:34 <rotaerk> I just did a fix to the binutils package, and now my program builds with RUNPATH set, and it all works fine and dandy
12:09:46 <rotaerk> but when I run cabal repl, I still get the same undefined symbol error
12:09:55 <rotaerk> any ideas why that might be?
12:11:00 <rotaerk> even tried cabal repl --ghc-options=-optl--enable-new-dtags
12:11:02 <rotaerk> and nothing happened
12:11:09 <rotaerk> err nothing changed
12:13:06 <infinisil> erisco: So this is the basic thing which seems to do what I want: https://gist.github.com/Infinisil/c2b2410962e146620923bfc9455a73c3
12:13:32 <infinisil> Except I need to add the StateT thing, same as RandT
12:14:19 <rotaerk> I guess the question is ... how is cabal repl determining the libraries to use
12:19:31 <geekosaur> can you try that with ghci directly?
12:19:51 <geekosaur> ghci has its own linker, separate from the system one, and it may use a different library resolution mechanism
12:21:11 <rotaerk> K
12:36:16 <rotaerk> geekosaur, just did ghci <my hs file>, and then ran :main, and got the same libGL error
12:36:40 <geekosaur> ok, so this stands a decent chance of being a difference in ghc/ghci's runtime linker
12:36:55 <rotaerk> thing is, there were actually two changes to nixpkgs that contributed to the problem
12:37:25 <rotaerk> 1) binutils (particularly ld) was broken such that RPATH was used in the built binaries
12:37:46 <rotaerk> 2) the libGL specified in the RPATH changed from one that worked to one that did not
12:38:21 <rotaerk> so even though my fix addresses #1, if ghci is still using the one specified in the RPATH (now RUNPATH, after my fix), instead of LD_LIBRARY_PATH...
12:38:31 <rotaerk> then that's a problem
12:39:48 <rotaerk> and that's what it appears to be doing:  ignoring LD_LIBRARY_PATH, and just using the one that would normally get put into the RUNPATH (and then ignored at runtime due to LD_LIBRARY_PATH overriding it)
12:41:38 <rotaerk> I wonder if the one now specified in RUNPATH should also be fixed
12:57:52 <butterthebuddha> Is there a library function available for converting a Word64 into a little-endian ByteString?
12:58:04 <dukedave> Any .hsc experts around, who might know what `{}` means, in this context? https://github.com/chpatrick/haskell-opencv/blob/a701500ac20740fdd46fe7787c993280fac81d02/src/OpenCV/ImgProc/GeometricImgTransform.hsc#L325
13:03:14 <geekosaur> that's an Inline.C quasiquote
13:05:37 * hackage wuss 1.1.10 - Secure WebSocket (WSS) clients  http://hackage.haskell.org/package/wuss-1.1.10 (fozworth)
13:05:39 <cocreature> butterthebuddha: use the binary library
13:07:49 <geekosaur> this is C++ code and {} is being used as a constructor for an empty InputMap
13:08:01 <geekosaur> er, InputArray
13:08:13 <geekosaur> map2 – The second map of y values having the type CV_16UC1 , CV_32FC1 , or none (empty map if map1 is (x,y) points), respectively.
13:08:24 <geekosaur> (from opencv docs for cv::remap)
13:13:29 <dukedave> geekosaur: do you think is `{}` some magic way to create an empty `Mat` ?
13:13:58 <geekosaur> in C++ it is, yes
13:14:37 * hackage salve 1.0.4 - Semantic version numbers and constraints.  http://hackage.haskell.org/package/salve-1.0.4 (fozworth)
13:14:49 <geekosaur> (C++11 and on)
13:15:37 * hackage hPDB 1.3.0.0 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-1.3.0.0 (MichalGajda)
13:15:41 <dukedave> Ah, the `C++11` and on might be the clue I needed! It's blowing up on MacOS: https://github.com/LumiGuide/haskell-opencv/issues/121
13:15:42 <geekosaur> https://en.cppreference.com/w/cpp/language/list_initialization
13:16:29 <dukedave> I fixed it like this https://github.com/dukedave/haskell-opencv/commit/21699d547c71be724cfb0c86145b4ef10a537071, but I wonder if the underlying issue is that it's not being complied with C++11 support :\
13:17:07 * hackage strive 5.0.6 - A client for the Strava V3 API.  http://hackage.haskell.org/package/strive-5.0.6 (fozworth)
13:17:17 <geekosaur> quite possible. or conflicts with Apple specific syntax (blocks) maybe
13:17:31 <cocreature> it does look like they set the flag https://github.com/LumiGuide/haskell-opencv/blob/master/opencv/opencv.cabal#L110
13:17:35 <geekosaur> although I thinkt hat should be ^{}
13:18:23 <cocreature> I wonder if you have an older version of Cabal that doesn’t know about cxx-options and just ignores this
13:18:30 <dukedave> geekosaur: where does `^` come from?
13:18:51 <geekosaur> https://en.wikipedia.org/wiki/Blocks_(C_language_extension)
13:19:05 <geekosaur> it's an Apple specific weirdness
13:19:20 <cocreature> although iirc there should at least be a warning for unknown fields
13:19:37 * hackage hPDB 1.4.0.0 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-1.4.0.0 (MichalGajda)
13:19:46 <geekosaur> I was trying to figure out if that initializer style (the 7th example on the cppreference page) was somehow conflicting, but it looks like you need the ^ for it to be an Apple-style block
13:19:58 <geekosaur> so I don't know why it's not parsing that kind of initializer
13:20:17 <geekosaur> possibly just a bug in that version of clang++
13:20:27 <geekosaur> or it's using clang instead of clang++ for some reason
13:20:57 <dukedave> I'm using stack 1.7.1, so that's Cabal 2.2, which I _believe_ has `cxx-options`?
13:21:07 <cocreature> yeah should be in 2.2
13:21:12 <geekosaur> apple should be forcing c++11 anyway
13:22:31 <geekosaur> but this is all kinda weird on macos, because there are license issues around pre-C++11 vs. C++11 and later. which causes problems all over the place :(
13:23:12 <geekosaur> libstdc++ (pre-C++11; lgpl2) vs. libc++ (C++11)
13:23:23 <dukedave> Oh dear. Well thanks for all the help. My `Mat map2` workaround gets past the trouble with `{}`, but now it's dying later on. Perhaps time to switch to Docker...
13:23:41 <pikajude> macos, sigh
13:25:22 <dukedave> Yeeah. Hard to complain when company gives me a shiny new laptop, but boy I miss Ubuntu right now :\
13:26:31 <geekosaur> parallels >.>
13:26:37 <blankhart> say i have lenses Lens' A Int and Lens' B Int.  Is there a terse way to create Lens' C Int where data C = MkA A | MkB B and the effect is to dispatch to the injected types?
13:26:48 <geekosaur> (I used vmware but that was because $company provided that too :)
13:29:07 * hackage github-release 1.2.2 - Upload files to GitHub releases.  http://hackage.haskell.org/package/github-release-1.2.2 (fozworth)
13:30:15 <blankhart> these lenses are defined under a typeclass so if there were an ability to generically derive corresponding lenses for the sum type that would work
13:34:07 * hackage ratel-wai 1.0.3 - Notify Honeybadger about exceptions via a WAI middleware.  http://hackage.haskell.org/package/ratel-wai-1.0.3 (fozworth)
13:34:48 <geekosaur> isn't there TH for that? although it may need to be a prism instead of a Lens'
13:35:13 * geekosaur is not a lens expert, but no examples for Lens for a type without named fields
13:35:22 <geekosaur> :t _1
13:35:24 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
13:36:08 <blankhart> TH would let me create prisms to A and B and then use the lenses for A and B, but i want to "lift" the A and B lenses directly onto C
13:38:06 <albeit> If I need very large integers, is it better to use Integer or Int128 from data-dword?
13:39:07 * hackage json-feed 1.0.3 - JSON Feed  http://hackage.haskell.org/package/json-feed-1.0.3 (fozworth)
13:40:07 * hackage hPDB 1.5.0.0 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-1.5.0.0 (MichalGajda)
13:42:54 <blankhart> more generally, say i have instance Foo A and instance Foo B.  is there a terse way to manufacture an instance Foo C for data C = MkA A | MkB B?
13:43:07 * hackage ratel 1.0.5 - Notify Honeybadger about exceptions.  http://hackage.haskell.org/package/ratel-1.0.5 (fozworth)
13:45:58 <blankhart> maybe i should have a look back at datatypes a la carte and give that a think. without that, probably not in general
13:46:37 * hackage lackey 1.0.5 - Generate Ruby clients from Servant APIs.  http://hackage.haskell.org/package/lackey-1.0.5 (fozworth)
13:47:27 <Solonarv> it depends on what the class even *is*, but if you control the class you can use generics
13:47:37 * hackage flow 1.0.14 - Write more understandable Haskell.  http://hackage.haskell.org/package/flow-1.0.14 (fozworth)
13:48:37 * hackage autoexporter 1.1.10 - Automatically re-export modules.  http://hackage.haskell.org/package/autoexporter-1.1.10 (fozworth)
13:52:07 * hackage derulo 1.0.3 - Parse and render JSON simply.  http://hackage.haskell.org/package/derulo-1.0.3 (fozworth)
13:53:40 <blankhart> the class defines simple lenses on the underlying types
14:01:00 <dukedave> Boo, so I'm using `resolver: lts-11.17` with stack, but I'm getting `opencv.cabal: Unknown fields: cxx-options` because `This package description follows version 2.2 of the Cabal specification. This tool only supports up to version 2.0.1.1.`. What gives?
14:01:57 <dukedave> `stack --version` gives `1.7.1`, which is supposed to have Cabal 2.2? https://docs.haskellstack.org/en/stable/ChangeLog/#v171
14:04:01 <u0_a129> hi
14:04:37 * hackage rattletrap 4.1.2 - Parse and generate Rocket League replays.  http://hackage.haskell.org/package/rattletrap-4.1.2 (fozworth)
14:19:53 <butterthebuddha> https://github.com/bgamari/mersenne-random-pure64/blob/master/System/Random/Mersenne/Pure64/Internal.hs
14:19:59 <butterthebuddha> What does the exclamation point mean?
14:20:02 <butterthebuddha> (line 15)
14:21:00 <bgamari> butterthebuddha, it indicates that the field is strict
14:21:59 <bgamari> butterthebuddha, that is, when a new PureMT constructor is built the MTBlock and Int fields will be evaluated to weak head normal form
14:22:38 <butterthebuddha> I don't know what "weak head normal form" is
14:22:51 <bgamari> butterthebuddha, something that isn't a thunk
14:23:02 <butterthebuddha> Ah
14:23:04 <butterthebuddha> https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/pragmas.html#unpack-pragma
14:23:43 <butterthebuddha> I also don't understand that ^
14:23:46 <bgamari> right, so in this case strict evaluation is nice since it allows GHC to unpack the fields into the constructor
14:23:47 <v0d1ch> https://www.irccloud.com/pastebin/IDBlawjk/
14:24:22 <bgamari> e.g. the Int field will be represented by the integer value itself instead of a pointer to an Int constructor
14:24:23 <glguy> One thing to watch out for with constructors with strict fields is that applying that constructor to arguments can now create thunks itself where it wouldn't have previously
14:24:24 <grindelmort> i know there are some smart motherfuckers up in here, so someone in here must know of a particularly sexy-ass word that could describe something between that which is static and that which is dynamic ("gradual" won't cut it; not nearly sexy enough). don't let me down, now; you guys are supposed to be geniuses and shit, so help me think of a word, yeah?
14:24:50 <geekosaur> v0d1ch, nothing built in. I recently wanted something similar, but cycle was good enough for my need
14:25:04 <bgamari> butterthebuddha, does this make sense?
14:25:27 <butterthebuddha> glguy: Can you give an example?
14:25:32 <butterthebuddha> bgamari: yep
14:26:27 <Orbstheorem> Hi, how can I get the hash to use in src.sha256sum in a file imported via `nix add-to-store`?
14:26:46 <glguy> If you have: data T = MkT !Int:     f (T x)   -- this applies f to the thunk that evaluates (T x)
14:26:59 <v0d1ch> geekosaur: I should probably dig more around base library 🤦‍♂️
14:27:14 <glguy> while if you have: data T = MkT Int; f (MkT x)   actually just allocates a new value of T and skips making a thunk
14:27:20 <glguy> (I meant to use MkT in the first example)
14:28:04 <Orbstheorem> I did `nix-prefetch-url --type sha256 file://$(pwd)/$(tmux showb)`, but seems hacky :P
14:28:16 <butterthebuddha> So it essentially moves thunking up a level?
14:28:28 <glguy> Sure, kind of
14:28:49 <butterthebuddha> I assume there are ways of making it strict all the way up?
14:29:08 <glguy> If you wanted to move that up another level you could write:  f $! MkT x
14:29:16 <Orbstheorem> Ups, really sorry, wrong channel x)
14:29:45 <butterthebuddha> Ah, I see. Thanks!
14:31:37 * hackage intrinsic-superclasses 0.4.0.0 - A quasiquoter for better instance deriving and default methods  http://hackage.haskell.org/package/intrinsic-superclasses-0.4.0.0 (dailectic)
14:35:10 <dataN> is there a type level /= ?
14:35:48 <geekosaur> no, and they're difficult in general
14:36:59 <dataN> something like the opposite of ~ where compilation will fail on matching both sides to be equal...
14:37:27 <hpc> if you have type-level (/=) you have general type-level negation, which iirc has some halting problem implications
14:37:34 <geekosaur> ^
14:37:52 <pikajude> using microlens, is it possible to coerce Getting Foo s Foo to ASetter s s a Foo?
14:38:01 <hpc> i forget the math behind it, but there's a similar reason for there not being a general negation in prolog
14:38:06 <hpc> if you want to try and find it yourself
14:38:06 <pikajude> i feel like since the same value can be inferred to have either type, it's gotta be a simple "coerce" somewhere that i'm missing
14:38:59 <dataN> ffs
14:39:33 <lyxia> dataN: I have an example of encoding a disequality constraint http://blog.poisson.chat/posts/2018-06-06-hlists-dependent-haskell.html
14:40:18 <lyxia> use a boolean (==) type family and assert the result is equal (~) to 'False
14:43:43 <dataN> lyxia: why is there no halting problem?
14:43:58 <hpc> because not everything is in the family
14:44:07 <lyxia> there was no halting problem in the first place
14:44:50 <pikajude> oh it's not actually needed to coerce, i just need to specify the value has type Lens' s a
14:46:53 <pikajude> oh because this needs RankNTypes and inference doesn't really work with those
14:46:54 <pikajude> i see
14:53:55 <dysfun> oh, is that why RankNTypes isn't default?
14:57:20 <geekosaur> yes
14:57:53 <geekosaur> rank-2 is actually decidable iirc but difficult, higher ranks are not
15:04:30 <Gurkenglas> @let data C = MkA A | MkB B
15:04:32 <lambdabot>  Defined.
15:04:45 <Gurkenglas> :t \l r f -> \case MkA a -> MkA <$> l f a; MkB b -> MkB <$> r f b -- blankhart, you want a TH thing that generates this, yes?
15:04:46 <lambdabot> Functor f => (t -> A -> f A) -> (t -> B -> f B) -> t -> C -> f C
15:19:58 <parenthetical> Hi all! I'm not too sure how to avoid having to add t to the Crdt type here; it's an implementation detail which only matters when "compiling" the Crdt GADT to some actual implementation, all that matters is that the implementation ensures (Ord t): https://lpaste.net/3951202941171400704
15:20:32 <glguy> blankhart: You can do this: https://gist.github.com/glguy/d009ff1bf0d8dcbdff2876d65846efeb
15:20:51 <glguy> Look at all the savings :)
15:47:07 * hackage hPDB-examples 1.5.0.0 - Examples for hPDB library  http://hackage.haskell.org/package/hPDB-examples-1.5.0.0 (MichalGajda)
15:50:14 <Gurkenglas> blankhart, of course there's always \l r -> unsafeSingular $ _MkA . l `failing` _MkB . r
15:51:26 <Gurkenglas> blankhart, and your case might admit "unsafeSingular template"
16:36:38 <nai> :help
16:36:57 <nai> :t 42
16:36:58 <lambdabot> Num p => p
16:38:09 <nai> hi, i'd like to understand why typing "return 1" at ghci shows 1
16:38:46 <nai> does the fact that i'm implicitly calling "show" on the value force the monad type to be something for which show makes sense? (and what?)
16:38:49 <geekosaur> because ghci tries an expression as (Show a => IO a) first
16:39:03 <geekosaur> and only afterward as Show a => a
16:40:18 <nai> i'm lost
16:40:42 <geekosaur> the monad doesn't have to have a Show instance
16:40:45 <nai> i just tried  return 1  followed by  :t it  and it prints  it :: Integer
16:40:55 <nai> why isn't it a monad
16:41:26 <geekosaur> because, having recognized that it needed a monad because of 'return', it used IO, then did in effect it <- return 1
16:42:05 <nai> ah, so the interpreter can use <- instead of = if it sees a monad?
16:42:11 <geekosaur> yes
16:42:17 <nai> ok, that part makes sense
16:42:54 <geekosaur> ghci is a little weird
16:42:57 <nai> now doesn't that solve my problem?
16:43:12 <nai> if it does that, then it can just show "it", which is an integer
16:43:19 <nai> i don't see at what point IO is involved
16:43:46 <geekosaur> so it took your expression as unifying with (Monad m, Show a) => m a, with m ~ IO and for a it ends up with (Show a, Num a) => a and defaulting gives a ~ Integer
16:44:24 <geekosaur> IO is involved because ghci tries the monadic one first, and uses IO because that's what's wired into ghci
16:45:23 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#using-a-custom-interactive-printing-function talks about how it prints values, and shows where the IO comes from
16:45:33 <nai> ok. thanks
16:46:28 <geekosaur> but the short version is, if you give it a monadic expression, it will use IO as the monad and run it. otherwise, it will look for (by default) a Show instance, evaluate it, and "print" it
16:46:36 <geekosaur> :t print
16:46:38 <lambdabot> Show a => a -> IO ()
16:48:28 <marvin2> :t return 1
16:48:29 <lambdabot> (Num a, Monad m) => m a
16:49:11 <Solonarv> :t (do it <- return 1; print it)
16:49:13 <lambdabot> IO ()
18:17:35 <pikajude> so i'm using backpack, right
18:17:47 <pikajude> i want to write a library that exposes a suite of hspec tests
18:17:55 <pikajude> which uses a quasi-quoter that's defined in an indefinite packge
18:18:14 <pikajude> is it unrealistic to expect GHC to be able to compile it
18:25:24 <pikajude> according to https://ghc.haskell.org/trac/ghc/ticket/14212 i guess it is
18:25:59 <pikajude> the part that confuses me is that the splice i'm using doesn't *use* any of the functions defined in hsig files
18:26:06 <pikajude> although it does produce code that references them
18:26:26 <pikajude> i feel like that should work...
18:28:48 <mniip> 7/15/2018 [02:41:43] <nai> ah, so the interpreter can use <- instead of = if it sees a monad?
18:29:00 <mniip> it doesn't look for a *monad*
18:29:17 <mniip> it looks for IO (), Show a => IO a, Show a => a,  in this order
18:43:07 * hackage composition-prelude 1.5.0.8 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-1.5.0.8 (vmchale)
18:52:07 * hackage hOpenPGP 2.7.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-2.7.1 (ClintAdams)
19:03:27 <dreamer_> is there any downside to scopedtypevariables ?
19:03:41 <mniip> it's an extension
19:36:54 <blankhart> glguy, Gurkenglas, thank you so much - i had to step out but you've given me a lot for quiet contemplation and self-study
20:34:07 * hackage jord 0.1.0.0 - Geographic position calculations on Great Circles  http://hackage.haskell.org/package/jord-0.1.0.0 (CedricLiegeois)
20:40:39 <pikajude> how do I get a package onto next-hackage?
20:41:55 <mniip> there's an "upload" button
20:41:58 <mniip> ah er
20:42:01 <mniip> I misread your question
20:43:10 <mniip> actually there still is an upload button but
20:51:07 * hackage process 1.6.4.0 - Process libraries  http://hackage.haskell.org/package/process-1.6.4.0 (MichaelSnoyman)
20:59:18 <haz> Can you hide imports while also specifying specific functions?
20:59:35 <haz> Like import Network (sendAll) hiding (accept)
21:04:48 <c_wraith> haz: why?  if you list specific functions, nothing else is imported anyway.  (except instances, of course)
21:05:21 <haz> Ahh -- thanks @c_wraith! Bit of a dumb moment for me. Cheers.
21:05:41 <c_wraith> haz: I wasn't sure.  Maybe you had a clever idea!
21:20:12 <mniip> import Mod (TC(..)) hiding (DC) would be cool
21:21:52 <c_wraith> yeah, I wondered if maybe that was what the question was about.  Because it would be cool
21:26:59 <marxS> anybody know of any quantitative finance libraries in haskell/
21:27:00 <marxS> ?
21:27:11 <marxS> all I can find is quantfin http://hackage.haskell.org/package/quantfin
21:35:32 <XorSwap> just a general question for everyone here, what's the largest size of tuple you've seen used in non-crazy code?
21:36:00 <XorSwap> me and a friend are designing a language and are wondering about what sizes should be expected
21:37:36 <c_wraith> Anything bigger than 3 and I start thinking there should be a real type instead
21:37:55 <c_wraith> Which isn't to say I haven't seen bigger.  Just that I think it probably should be something else
21:54:30 <marxS> why do we have data types where the type argument is a phantom?
21:54:39 <marxS> or it has no witness
22:06:10 <cocreature> marxS: there are quite a few reasons. 1. It helps to prevent you from accidentally mixing up values that can’t be used interchangably (in that case you often also have constructors that are not exposed). 2. it allows you to make use of existing abstractions that except a type parameter (e.g. you might be able to make a Functor instance). 3. it allows you to pass around types using something like
22:06:12 <cocreature> Data.Proxy.
22:06:26 <cocreature> that is by no means an exhaustive list but those are the first reasons that come to mind
22:15:26 <pikajude> mniip: yeah, i forgot that hackage has an upload button
22:15:28 <pikajude> lol
22:49:07 * hackage typesafe-precure 0.6.3.1 - Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)  http://hackage.haskell.org/package/typesafe-precure-0.6.3.1 (igrep)
23:08:07 * hackage warp 3.2.23 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.2.23 (MichaelSnoyman)
23:22:37 * hackage hw-json 0.8.1.0 - Memory efficient JSON parser  http://hackage.haskell.org/package/hw-json-0.8.1.0 (haskellworks)
23:43:51 <revskill> Interesting bug in Hoogle: it can't differentiate between <hoogle generate> and <hoogle "generate">
23:49:36 <maerwald> I wonder if it's a good idea to implement file operations as an rpc server
23:50:01 <maerwald> which could delay, orchestrate and even refuse operations based on consistency checks etc
23:52:05 <maerwald> but then you would need a pretty good method to stop/cancel operations and react to errors
23:55:06 <maerwald> and not sure if there is a suitable haskell rpc framework
23:55:35 <typetetris> hmm documentation on hackage seems to be broken again. At least for optparse-applicative in the newest version.
23:55:47 <typetetris> Didn't they solved that once and for all?
23:56:27 <typetetris> ah sorry it's just the links in the tutorial, which don't work.
