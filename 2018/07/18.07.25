00:01:35 <tdammers> explains why their web shop software is so atrocious
00:01:42 <quicksilver> dminuoso: https://hitenism.com/amazon-working-backwards/
00:02:55 <tdammers> manager: "we're going to use automatic translation to serve customers in other countries" (writes press release) - programmer: "uh, that's not going to work, see, all this product data here, it's just tiny snippets of text without much context, machine-translating that is going to produce useless garbage, and..." - manager: "too late, press release is out, make it work"
00:03:15 <tdammers> that must be one awesome job
00:03:58 <quicksilver> it doesn't quite go like that :)
00:04:18 <koz_> tdammers: Sounds like my personal version of hell.
00:04:45 <tdammers> quicksilver: trying to use amazon.de in NL sure feels like it did
00:04:56 <koz_> tdammers: Are you in NL?
00:05:00 <tdammers> koz_: yes
00:05:03 <koz_> Cool.
00:05:04 <geekosaur> I get the impression it depends on the division. some folks I know have horror stories, others have only good things to say about it
00:05:06 <koz_> It's a nice place.
00:05:49 <tdammers> and, even funnier, amazon.de routinely decides that, because my wife's phone uses a dutch locale, whenever she logs in, she must want the Dutch version, despite her repeatedly changing her language preference to "German"
00:05:51 <cocreature> geekosaur: which is probably true for most large companies :)
00:06:15 <tdammers> so everytime she opens amazon.de on her phone, she gets an e-mail saying "your language preferences have been changed successfully"
00:06:21 <koz_> tdammers: That reminds me of booking.com constantly thinking my mum's in Taiwan, even though she's never been there.
00:06:54 <Ke> tdammers: I bet you also force her to invalidate all the cookies at tab close
00:06:59 <tdammers> and then nothing works, because now any search query you enter gets translated from Dutch to German, then they run the search on that, and then they translate the results back to Dutch
00:07:16 <AndreasK> I tried to get amazon to stay english for a while. But I've given up an accepted that it will stay german.
00:07:22 <typetetris> Can I run ghc via cabal, so that `default-extensions` in the cabal file is respected? `cabal exec -- ghc <somefile>` runs ghc with the correct package database, but the default-extensions aren't respected ...
00:07:25 <koz_> :t NaN
00:07:26 <lambdabot> error: Data constructor not in scope: NaN
00:07:36 <koz_> How do I get a NaN in Haskell?
00:07:48 <cocreature> typetetris: afaik you can’t
00:07:50 <tdammers> AndreasK: well, that is somewhat bearable, since the German version actually has product descriptions originally entered in German
00:07:54 <AndreasK> koz_: read "NaN" :: Double
00:07:55 <jackdk> > sqrt (-1)
00:07:57 <lambdabot>  NaN
00:08:10 <tdammers> > 0/0 -- maybe?
00:08:12 <lambdabot>  NaN
00:08:21 <AndreasK>  > read "NaN" :: Double
00:08:24 <koz_> Is there no constant corresponding to NaN? Weird.
00:08:27 <cocreature> it’s kind of annoying that we do not have definitions of nan and infinity in base
00:08:33 <koz_> sqrt(-1) will do.
00:08:38 <AndreasK> > read "NaN" :: Double
00:08:40 <lambdabot>  NaN
00:09:31 <AndreasK> tdammers: True, but you still get the product translation feature. Which is especially annoying when you search for something where the name is actually english
00:09:49 <tdammers> easy solution: don't buy from amazon
00:10:05 <AndreasK> Sometimes I feel the the UX of amazon has actually gotten worse over time.
00:22:10 <mikeplus64> anyone know how clever ghc is wrt type synonym result 'caching'?
00:23:11 <koz_> mikeplus64: What do you mean by that?
00:23:21 <mikeplus64> that is, if i have `type X = Some Expensive Type Family Thing Here`, which might include both closed and open type families, does GHC only evaluate it once per module, or only when a new instance is added to a relevant open type family, or just always?
00:23:42 <mikeplus64> if it only involves closed type families, will X only be evaluated once, ever?
00:26:02 <mikeplus64> and i assume that X is only evaluated when it's used by a value, or typeclass ctx ...
00:31:01 <iqubic> is there a way to make GHCJS use less memory?
00:31:41 <pavonia> Is there already a common combination function for two Maybes in the base that uses a given function if both values are present, and works like (<|>) otherwise?
00:32:55 <cocreature> pavonia: I don’t think so but \f x y -> liftA2 f x y <|> x <|> y is reasonably simple
00:32:55 <dminuoso> pavonia: liftA2
00:33:09 <cocreature> liftA2 won’t behave like <|>
00:33:28 <iqubic> Is there a channel for GHCJS where I can ask my questions?
00:33:43 <pavonia> Hhm okay
00:33:43 <cocreature> there is #ghcjs but it’s not particularly active
00:35:12 <quicksilver> :t (<|>)
00:35:13 <lambdabot> Alternative f => f a -> f a -> f a
00:35:24 <glguy> Pavonia: align from these package
00:35:29 <quicksilver> > Nothing <|> Just 1
00:35:31 <lambdabot>  Just 1
00:35:34 <quicksilver> > Just 1 <|> Nothinig
00:35:36 <quicksilver> > Just 1 <|> Nothing
00:35:36 <lambdabot>  error:
00:35:36 <lambdabot>      • Data constructor not in scope: Nothinig :: Maybe a
00:35:36 <lambdabot>      • Perhaps you meant one of these:
00:35:38 <lambdabot>  Just 1
00:35:52 <quicksilver> isn't what pavonia is asking for the Monoid instance for Maybe?
00:36:16 <quicksilver> > Just (Sum 3) <> Just (Sum 5)
00:36:19 <lambdabot>  Just (Sum {getSum = 8})
00:36:25 <quicksilver> > Just (Sum 3) <> Nothing
00:36:27 <lambdabot>  Just (Sum {getSum = 3})
00:36:32 <glguy> Only if f is<>
00:36:34 <pavonia> quicksilver: No, you cannot provide an extra function to (<>)
00:36:38 <quicksilver> > Nothing <> Just (Sum 5)
00:36:40 <lambdabot>  Just (Sum {getSum = 5})
00:36:46 <quicksilver> well yes, it does require your function to be mappened
00:37:07 <quicksilver> but are you sure your chosen function isn't mappend for some appropriate monoid? :)
00:37:16 <quicksilver> it seems algebraically plausible that it might be.
00:37:53 <quicksilver> worse case, use the free monoid and then fold it back
00:38:04 <quicksilver> > Just [3] <> Just [5]
00:38:06 <lambdabot>  Just [3,5]
00:44:41 * tdammers just used deepseq and now feels dirty
00:47:21 <cocreature> tdammers: repent by using 3 irrefutable patterns
00:47:26 <koz_> Dat dirty dirty deepseq.
00:48:23 <tdammers> I should have paid better attention during Church lectures
00:48:59 <koz_> LOL
00:50:07 * koz_ sads at the fact GADTs don't seem to be able to autoderive Eq.
00:50:35 <koz_> Can they autoderive anything?
00:50:50 <AndreasK> With new-build if I use --ghc-options "Foo", then rebuild using "Bar". Should building with Foo again after that use cached libraries or rebuild them? There seems to be more rebuilding going on than I would have expected
00:51:16 <Taneb> koz_: you need to use standalone deriving, I think
00:51:31 <cocreature> the problem with Eq is that you often need a stronger function for GADTs
00:51:41 <cocreature> something like f a -> f b -> Bool
00:51:54 <koz_> cocreature: Yeah, fair enough.
00:52:04 <koz_> Is it possible to autoderive Generic and then lean on _that_ for equality?
00:52:04 <cocreature> if you have a GADT where that is not required, standalone deriving should work
00:52:38 <koz_> What do you mean by 'standalone deriving'?
00:53:14 <cocreature> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=standalone%20deriving#extension-StandaloneDeriving
00:53:29 <pally> <*> is pronounced as "ap"
00:53:35 <koz_> Or 'splat'.
00:53:36 <pally> what about <$> ?
00:53:39 <cocreature> fmap
00:53:46 <koz_> pally: We came to the consensus 'Superman' recently.
00:54:31 <koz_> So I would read ' (+) <$> 3 <*> 4' as 'plus superman 3 splat 4'.
00:54:36 <koz_> YMMV of course.
00:55:51 <pally> koz_ is "superman" a joke, or is there really a consensus?
00:56:11 <koz_> pally: Well, 'consensus' might be a strong word, but I heard that suggestion from some folks here and liked it.
00:56:12 <tdammers> sounds like INTERCAL
00:56:16 <koz_> So I call it 'superman'.
00:56:26 <cocreature> there is definitely not a consensus to call it superman
00:56:29 <cocreature> call it fmap
00:56:46 <tdammers> but I thought the consensus was to just not pronounce anything at all, considering how awkward talking to humans is in the first place
00:56:57 <koz_> cocreature: Awww, you no fun. :P
00:57:11 <pally> cocreature, it does resemble the logo though
00:57:15 <tdammers> (btw., I tend to call it "infix fmap" or "operator fmap"
00:57:16 <tdammers> )
00:57:36 <cocreature> yeah not talking to humans sounds like a good plan
00:58:38 <tdammers> filthy stinky frightful humans
01:00:09 <pally> You sound like the kinda guy that would be happy to become a pet of the AI you programmed. heh
01:00:55 <nyingen> Hello...I'm following the Stack user guide, and it refers to a file package.yaml which should be in my project directory. But I see only stack.yaml
01:01:22 <nyingen> well, I mean stack.yaml is the only yaml file
01:01:52 <nyingen> I want to add a dependency, so do I do that in stack.yaml? Or do I need to create package.yaml instead?
01:02:28 <cocreature> nyingen: do you have a *.cabal file?
01:04:11 <nyingen> cocreature: Yes
01:04:53 <nyingen> Also this is a brand new stack install. So did something change regarding the yaml files?
01:05:06 <nyingen> I mean, in terms of what's documented vs new development?
01:06:10 <cocreature> nyingen: you can just use the cabal file in that case. package.yaml is just a different syntax from which stack will generate a cabal file
01:06:58 <nyingen> cocreature: Ok. So my next question is why I have no package.yaml as expected
01:07:19 <nyingen> I used 'stack new MyProj simple', but I notice that the User Guide said to use 'stack new MyProj new-template'
01:07:25 <nyingen> could that be the cause?
01:07:57 <cocreature> yeah some templates come with a package.yaml, some come with a cabal file
01:08:28 <cocreature> tbh I’d say (and I’m not the only one here), switching the default template to a package.yaml was a mistake as it has caused way more confusion
01:09:19 <nyingen> Ok, so to recap: I don't add dependencies in the 'packages' field of stack.yaml. I add them in the cabal file. Is that right?
01:09:59 <cocreature> yep
01:10:03 <nyingen> I did a lot of haskell programming in the pre-stack days, then took a long hiatus. I'm trying to learn stack this time around.
01:10:13 <cocreature> the stack.yaml file declares where deps come from. the cabal file declares which packages you depend on
01:10:25 <cocreature> you always need to add deps to your cabal file
01:10:42 <cocreature> if they are in the stackage resolver that you have specified in your stack.yaml file you don’t need to do anything else
01:11:17 <cocreature> if they are not in the stackage resolver, you need to tell stack where it should fetch them from in the extra-deps section of your stack.yaml file _in addition_ to specifying that you depend on the package in your cabal file
01:11:37 <nyingen> Hm, I see
01:12:09 <Ferdirand> sta/win 18
01:12:10 <Ferdirand> oops
01:13:35 <nyingen> cocreature: Thanks for the help. I'll try this
01:16:10 <koz_> :t maybe
01:16:12 <lambdabot> b -> (a -> b) -> Maybe a -> b
01:16:15 <koz_> :i maybe
01:16:29 <koz_> Wait no that's not right.
01:17:15 <cocreature> koz_: what are you trying to do?
01:17:29 <koz_> Look up where 'maybe' lives.
01:17:50 <cocreature> % :i maybe
01:17:51 <yahb> cocreature: maybe :: b -> (a -> b) -> Maybe a -> b -- Defined in `Data.Maybe'
01:17:56 <koz_> That's the one, thanks.
01:22:07 * hackage dfinity-radix-tree 0.2.1 - A generic data integrity layer.  http://hackage.haskell.org/package/dfinity-radix-tree-0.2.1 (EnzoHaussecker)
01:27:46 <koz_> How would I get negative and positive infinity for Float? Another Read-based trick?
01:28:00 <tdammers> > 1/0
01:28:02 <lambdabot>  Infinity
01:28:07 <tdammers> > (-1)/0
01:28:10 <lambdabot>  -Infinity
01:28:16 <koz_> tdammers: Thanks!
01:28:27 <tdammers> > 1/(-0)
01:28:29 <lambdabot>  -Infinity
01:28:31 <tdammers> oh boy
01:28:43 <tdammers> > (-((-1)/(-0)))
01:28:46 <lambdabot>  -Infinity
01:29:15 <cocreature> fwiw "read" will work as well
01:29:23 <cocreature> > read "Infinity" :: Double
01:29:26 <lambdabot>  Infinity
01:37:36 <ddfdf> I have somehow a dumb question: how can I transform [IO String] into IO [String]?
01:37:43 <dminuoso> :t sequence
01:37:45 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
01:37:48 <dminuoso> ddfdf: ^-
01:38:04 <dminuoso> ddfdf: Also I think your question was a good one. :)
01:38:31 <dminuoso> ddfdf: You might also be interested into the following related/similar functions
01:38:33 <dminuoso> :t traverse
01:38:35 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
01:38:36 <dminuoso> :t traverse_
01:38:37 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
01:38:38 <dminuoso> :t sequence_
01:38:39 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
01:38:52 <ddfdf> is there any standard haskell function for that?
01:39:18 <ddfdf> ah sry, you wrote sequence
01:41:47 <dminuoso> Can someone tell me why Im getting this ambiguous type variable error? https://gist.github.com/dminuoso/d3bccff63500a965ecc89e0a120dbe0b
01:42:31 <quchen> Most questions prefixed with »this is a dumb question« are good questions.
01:42:48 <ddfdf> @dminuoso thx it worked :)
01:42:48 <lambdabot> Unknown command, try @list
01:42:57 * tdammers mumbles something about Zeno's paradox
01:44:18 <dminuoso> ddfdf: For future reference, there's a big difference between dumb questions and beginner questions. The quality of a question depends on how you state the question, and whether you have done reasonable research/spent reasonable time on the problem yourself. We really don't mind beginner questions. =)
01:45:35 <alexad> despite a popular myth, the haskell community is not hostile and evil
01:45:43 <alexad> It's probably the most positive and supportive one I know
01:45:59 <koz_> I agree with alexad.
01:46:01 <alexad> so don't be afraid to ask anything ever
01:46:08 <alexad> Want a toxic place? ##c++
01:46:21 <koz_> I wouldn't still be writing Haskell today if it wasn't for #haskell being patient with me.
01:46:34 <dminuoso> alexad: It's even more amazing that when you ask on say stackoverflow or reddit that you get high quality responses, frequently in very little time even.
01:46:39 <alexad> it's not just #haskell but the overall haskell community
01:46:46 <koz_> Yeah, true dat.
01:46:56 <alexad> It's a community of people who give a shit
01:47:33 <alexad> Which I recently learned is a phrase that can be confusing to some second language speakers. My roommate thought I was saying something mean when I said "you give a shit" once.
01:47:42 <alexad> so, yeah, that's a good thing.
01:49:50 <dminuoso> Oh.. I think I understand where the problem is.. because Im using `fromLiteral` it can't infer the first type argument..
01:50:17 <dminuoso> At least not the way I use it..
01:51:02 <dminuoso> Is it possible that GHC cant assume `a0` to be String because other `instances Validate k IPv4` could exist, for some choice of k?
01:51:51 <cocreature> dminuoso: GHC always operates under the open-world assumption, i.e., that it doesn’t know all instances that might exist
01:52:01 <cocreature> so it will never use the fact that there is only a single instance to deduce a type
01:53:31 <dminuoso> cocreature: It's amusing, validated-literals is much harder to use than I thought.. :P
02:00:44 <ddfdf> Okay thanks :) I am a complete beginner in Haskell :D I have only worked with OCaml before, but I started hating OCaml
02:00:44 <dminuoso> Jackpot.    • GHC internal error: ‘a’ is not in scope during type checking, but it passed the renamer
02:01:07 <ph88> does anyone know if this lib is still good? https://hackage.haskell.org/package/markov-chain it seems a bit old
02:01:33 <dminuoso> ddfdf: Feel free to hang around and ask if you have further questions. :)
02:01:49 <ddfdf> dminuoso: thanks :)
02:02:38 <cocreature> ph88: doesn’t look like a lib that requires a lot of maintenance so if it does what you need, I’d say go for it
02:06:36 <alexad> ddfdf, it gives me a break from may dayjob writing scala, so questions are always welcome <3
02:25:42 <gentauro> hmmm, I think I have some issue understanding "lazyness" in Haskell. I have tried to debug my mem usage with lazy ByteStrings and I have created the following examples: https://lpaste.net/5552247598137475072
02:26:00 <gentauro> I don't really get how foo crashes
02:26:17 <gentauro> I mean, I have written it just like I would write the `lenght` function for list
02:26:49 <gentauro> I wouldn't use this approach in a strict language as OCaml as it will blow up with SO very easy, but I would expect Haskell and it's lazyness to not crash
02:26:53 <gentauro> but it does ...
02:26:56 <gentauro> :\
02:27:51 <alexad> gentauro, how big is the string?
02:27:55 <cocreature> how do you expect laziness to help you here?
02:28:11 <ph88> i have this in IO monad https://bpaste.net/show/63605e7daacc now i need to do turns (for different players too) for as long as some condition in the player record hasn't been met .. what function would be good to use for the loop ?
02:28:13 <gentauro> alexad: string? you mean +600 bytes (ISO file) :0
02:28:16 <cocreature> (+) for Word8 is strict in both arguments
02:28:17 <alexad> if you're getting stack overflows I don't think laziness is your problem. I think a lack of tailrec
02:28:24 <gentauro> cocreature: :o
02:28:32 <gentauro> so that "triggers" stricness
02:28:44 <gentauro> that's why the `identity` function actually works
02:28:46 <cocreature> what do you expect to happen here?
02:28:58 <cocreature> how should (+) behave lazily for Word8?
02:29:24 <gentauro> cocreature: I didn't know that (+) was strict
02:29:40 <gentauro> I would expect that it would add the numbers when needed
02:30:11 <alp> yes, but when you want to determine how strict a function is in its arguments, you start by assuming that someone needs the result of the function call
02:30:12 <gentauro> for example: let _ = 42 + 42 in 007 would never perform the addition
02:30:21 <cocreature> that’s exactly what happens
02:30:38 <alp> because with the argument you just made, whatever you write on the right hand side of =, it'll just never be evaluated
02:30:57 <cocreature> if you don’t evaluate the result, you never force the evaluation of (+) so it doesn’t matter that it’s strict
02:31:23 <cocreature> but if you force the result (+) can’t do anything but force both arguments (with some exceptions like if one argument is 0, but (+) doesn’t try to do that)
02:31:46 <cocreature> so at some point your code is going to force the result and at that point things will blow up
02:32:13 <gentauro> so in order to write "decent" and (safe) Haskell code, I should just apply the techniques learned from OCaml experience (always use acc)
02:32:22 <dminuoso> Hey merijn. Im at a loss regarding your validated-literals.
02:32:31 <gentauro> that way I know for sure that my calculations will be tail recursive
02:32:49 <dminuoso> After trying a bit (and successfully crashing GHC), I'm not quite sure how to use it correctly.
02:33:14 <cocreature> gentauro: tail recursion is not sufficient in general. your code will still not run in constant memory if you compile with -O0
02:33:24 <merijn> dminuoso: I can try and help, but the current version is pretty "prototypy"
02:33:25 <cocreature> and I wouldn’t recommend relying on strictness analysis
02:33:42 <gentauro> % length' [    ] = 0; length' (_:xs) = 1 + length' xs
02:33:42 <yahb> gentauro:
02:33:49 <gentauro> > length' [    ] = 0; length' (_:xs) = 1 + length' xs
02:33:50 <merijn> dminuoso: Making it more production ready has been on my todo list for a few months, but you know, thesis writing :)
02:33:52 <lambdabot>  <hint>:1:16: error:
02:33:52 <lambdabot>      parse error on input ‘=’
02:33:52 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
02:33:55 <dminuoso> merijn: https://gist.github.com/dminuoso/d3bccff63500a965ecc89e0a120dbe0b this covers it all.
02:34:09 <gentauro> so you would also never write a lenght function like that?
02:34:43 <dminuoso> And trying to fiddle that ambiguous paramter through crashes GHC. So Im not sure how hackySpliceValid is supposed to work here
02:34:45 <cocreature> yep
02:35:14 <merijn> dminuoso: Line 7 looks completely wrong :p
02:35:33 <dminuoso> merijn: That's just hackySpliceValid expanded.
02:35:35 <merijn> dminuoso: Also, in newer GHC (and thus a new version) the hackSpliceValid hack shouldn't be necessary
02:35:49 <dminuoso> merijn: Well I dont want to have a Lift instance for IPv4...
02:36:00 <dminuoso> Because Im scared about orphan instances.
02:36:12 <merijn> dminuoso: New GHC should auto derive Lift instances
02:36:48 <dminuoso> merijn: But I still have to specify that `deriving Lift` right?
02:36:53 <dminuoso> What about a third party type?
02:36:55 <merijn> dminuoso: Lemme check
02:37:51 <merijn> I really wish we had a better story for orphans
02:38:24 <merijn> ok, yeah, now I remember what I was doing :)
02:38:46 <merijn> dminuoso: oh, I think I see the problem :)
02:39:02 <merijn> dminuoso: Do you happen to have OverloadedStrings enabled? :p
02:39:15 <dminuoso> Uh yes..
02:39:22 <ddfdf> I use readProcess to call a program on 99 different inputs. Somehow readProcess is not terminating. What could be the problem, because the program terminates on all 99 inputs?
02:39:37 * hackage secp256k1 0.5.3 - Bindings for secp256k1 library from Bitcoin Core  http://hackage.haskell.org/package/secp256k1-0.5.3 (xenog)
02:39:59 <merijn> dminuoso: It's complaining that the first type argument to the Valid class is ambiguous, because OverloadedStrings turns string literals polymorphic, so it has to decide which type it should interpret String as
02:40:05 <dminuoso> ddfdf: If it doesn't terminate, it might be due to multiple reasons. Perhaps you are applying it to a computation that never finishes?
02:40:22 <merijn> dminuoso: Which is why there is a "validString" in ValidLiterals
02:40:23 <dminuoso> (Possibly)
02:40:26 <ph88> i have a list of players, i already have a rotate function for this list so they can keep turns. But how can i figure out which round it is? Maybe a list is not a good data structure to keep track of rounds and turns ??
02:40:30 <merijn> dminuoso: Which removes the ambiguity
02:40:45 <dminuoso> merijn: Im using validString?
02:40:46 <merijn> dminuoso: This is also something I wanna revisit when I redo the entire thing
02:40:52 <ddfdf> dminuoso: Yeah that wsa my first thought, but the program , which I call with readProcess terminates, if I call it from command line
02:41:03 <merijn> hmmm
02:41:27 <merijn> dminuoso: Oh!
02:41:40 <merijn> dminuoso: Do you by any chance have the use and class in the same module?
02:42:00 <dminuoso> merijn: Nope. Besides, that wouldn't work because of the stage restriction, wouldn't it?
02:42:13 <merijn> dminuoso: Well, hence why I thought it might be happening
02:42:43 <dminuoso> merijn: The thing is, the ambiguity stems from the fact that `fromLiteral` is ambiguous.
02:42:49 <dminuoso>     fromLiteral :: a -> Maybe b
02:42:55 <dminuoso> So based on the usage it cant possibly infer `a`
02:43:31 <dminuoso> Trying to modify this with ScopedTypeVariables and TypeApplications will crash GHC as it stands for now, though a proxy might work. What is confusing me however, is why your example doesnt have the same problem
02:43:42 <merijn> Only if the input is polymorphic, which validString should fix
02:44:23 <merijn> dminuoso: Keep in mind, this was written several GHC versions ago and there was a GHC version not too long ago which fixed a bug where GHC would happily use some extensions during type inference even if they weren't enabled
02:44:41 <dminuoso> merijn: I compiled your examples with the same GHC version, so they work. ;)
02:44:50 <dminuoso> (after giving them the treatment that I made a PR for)
02:45:04 <merijn> This is slowly turning into a murder mystery
02:45:59 <cocreature> maybe try making some minimal example? too often I made some silly mistake and didn’t actually include that in the code that I showed when I asked a question :)
02:46:46 <merijn> At least my examples apparently worked, so I'm cautiously optimistic I didn't fuck up :p
02:46:53 <dminuoso> Oh shoot me..
02:47:03 <dminuoso> Hey merijn! How is it going? Nice day?
02:47:08 <merijn> :)
02:47:12 <merijn> What did you do?
02:48:22 <merijn> dminuoso: FYI, the orphan lift instance would make it better, in the sense that that way it'd actually do the conversion at compile time. This way it's still happening at runtime, but only after we checked it worked at compile time (so it better be pure!)
02:48:39 <dminuoso> merijn: I dont care about the runtime overhead. I just care about the validity
02:49:30 <merijn> Sure, I've just always felt uncomfortable with redoing the conversion at runtime. I worry about itty-bitty gremlins somehow breaking it! :)
02:50:19 * cocreature sneaks unsafePerformIO in merijn’s conversion functions
02:50:48 <merijn> cocreature: Pfft
02:50:57 <merijn> I just use "State# RealWorld" directly :)
02:51:05 <cocreature> badass :)
02:52:06 <merijn> tbh, I don't think I've ever actually done that, despite all my MagicHash abuse
02:52:53 <cocreature> we all need a bit more MagicHash in our lives
02:53:36 * hackage OpenGLRaw 3.3.0.2 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-3.3.0.2 (SvenPanne)
02:53:52 <dminuoso> merijn: Okay so this is utterly and completely confusing.
02:54:18 <dminuoso> merijn: So if I just import `hackySpliceValid` and use that all is well.
02:54:32 <dminuoso> If I copy the *exact* implementation in a local binding and use that, I get the error.
02:54:39 <dminuoso> If I copy the implementation and inline it, I get that error.
02:55:07 <dminuoso> This is beginning to feel like some sort of bug if moving the definition into a separate module changes this behavior.
02:55:09 <merijn> oh, can you link youre code again? I think I know :)
02:55:16 <dminuoso> merijn: One moment
02:55:43 <small> I know it might sound stupid and simple, but I have following let expression let (x,y) = (\(_) -> y, 2) in  x1  the result of it is 2. I understand that but I am not exactly sure how to read it
02:56:30 <small> why is the 2 in the lambda expression beeing assigned to the y?
02:56:37 <dminuoso> merijn: Heh strike that. I got mixed up with all the weird stages in TH.
02:56:54 <merijn> small: The two isn't in the lambda
02:57:15 <dminuoso> let (x,y) = ((\_ -> y), 2) in x2
02:57:26 <small> so the lambda is the x basically and the 2 is the y
02:57:32 <merijn> small: That parses as: ((\(_) -> y), 2)
02:57:34 <merijn> small: Right
02:57:48 <merijn> small: And the lambda returns the 'y' you just bound on the left (so 2)
02:58:49 <small> ah okay, I thought so
02:58:55 <small> I was just confused for a moment
02:58:58 <small> thanks for the quick help
03:05:31 <dminuoso> merijn: Okay I have to correct myself once again. Im at a loss, I thought everything worked when I modified some things, but it was just because I changed the string and it triggered the validation error.
03:06:06 <merijn> dminuoso: pastebin the exact code you're using :) (I'm going for lunch now, I'll have a look when I get back)
03:19:07 <mschr> I want to extract all the css classes out of bootstrap.css
03:19:21 <mschr> I was trying with grep, but didn't quite work
03:19:48 <mschr> Now was trying to parse it with Text.ParserCombinators.ReadP
03:20:24 <mschr> Any advice on how to only match on class names and ignore everything else?
03:26:19 <tdammers> try one of the Parsecs
03:26:25 <tdammers> Parsec, Megaparsec, Attoparsec
03:30:49 <ph88> i made this type for my game   data Game = Game Bool [(Player, [Turn])] [(Player, [Turn])]   how can i apply a function in IO while the Bool in that type is not False ?
03:32:24 <tdammers> something like: go game = do { game' <- f game; when (keepGoing game') (go game') }
03:32:45 <tdammers> where keepGoing is a function Game -> Bool that extracts the boolean you're interested in
03:33:26 <ph88> thx
03:39:20 <pally> I am practicing converting between do-notation and the use of >>= operator.  Please tell me if I got the form correct.
03:39:21 <pally> statefulSum (x:xs) = do
03:39:21 <pally>     s <- get
03:39:21 <pally>     put (s+x)
03:39:21 <pally>     statefulSum xs
03:39:32 <pally> statefulSum (x:xs) = get >>= (\s -> put (s+x); - - Do I need a ; here?
03:39:32 <pally> 								   statefulSum xs)
03:39:41 <tdammers> no ;
03:39:59 <pally> tdammers, you are so fast.
03:40:05 <tdammers> in general, when you desugar do notation, you shouldn't have ; in the result
03:40:26 <tdammers> do { a; b } --> a >> b
03:41:03 <pally> tdammers, it took like less than 5 secs.
03:41:06 <w3stside|> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
03:41:10 <w3stside|> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
03:41:14 <w3stside|> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
03:41:17 <w3stside|> Voice your opinions at https://webchat.freenode.net/?channels=#freenode
03:42:17 <ph88> tdammers, i'm getting some compile errors with your suggestion https://bpaste.net/show/bc26d4e7ff7f
03:43:39 <lavalike> ph88: what game are you implementing?
03:46:00 <ph88> lavalike, https://www.planbgames.com/en/home/8-century-spice-road.html
03:48:04 <lavalike> ph88: cool!
03:54:09 <|Leary> :t when -- ph88: `when` only works for actions that don't return anything useful (otherwise it wouldn't know what to do in the False case). If that doesn't work for you then just use an explicit if-then-else (or `Data.Bool.bool`, or a case statement).
03:54:10 <lambdabot> Applicative f => Bool -> f () -> f ()
04:01:50 <ph88> well i'm pretty interested in how the game is finishing :P
04:03:38 <ph88> lavalike, https://bpaste.net/show/fa5d66ea349c
04:09:05 <ph88> ok the game is playing but it's slow as molasses
04:09:11 <lavalike> hehe
04:09:36 <ph88> maybe ghci thing .. let me try compiling
04:09:48 <lavalike> oh yeah code in ghci is interpreted not compiled
04:10:55 <ph88> nope it's still slow ..
04:12:11 <cocreature> have you compiled with optimizations enabled?
04:15:08 <ph88> stack build --ghc-options="-j4 -O2 -optc-O3 -optc-ffast-math"
04:15:24 <ph88> it just hangs from time to time a little bit ..
04:16:14 <ph88> here is the code i'm running https://bpaste.net/show/8d48b0160228
04:16:36 <ph88> i use these deps: containers, random, random-extras, random-fu, random-shuffle, random-source, text, text-show
04:19:20 <cocreature> hanging from time to time sounds like GC
04:19:36 * hackage Tensor 1.1.0.2 - Tensor data types  http://hackage.haskell.org/package/Tensor-1.1.0.2 (SvenPanne)
04:20:20 <quicksilver> text mode game hanging frmo time to time?
04:20:35 <quicksilver> that sounds more like a bad algorithm in there somewhere
04:20:58 <quicksilver> it's not like it's generating garbage all the time in its display loop (which is why graphic games have this issue)
04:21:58 <JuanDaugherty> a "hang" is a binary thing, you mean lag
04:22:12 <JuanDaugherty> "hang" a lil bit is like a bit dead
04:24:25 <JuanDaugherty> the fact that in practice patience is generally the determining factor in finding out which (short of debugging) notwithstanding
04:25:44 <dminuoso> merijn: Yeah it's due to OverloadedStrings.
04:26:13 <dminuoso> merijn: Interestingly it even triggers when I use `ip = $$(valid ("127.0.0.1" :: String))`
04:26:19 <dminuoso> Which I found surprising
04:26:35 <merijn> That...shouldn't happen, I think?
04:26:45 <cocreature> yeah that sounds wrong
04:26:59 <cocreature> but I think we really need to see the exact code here to figure out what is going wrong
04:27:15 <dminuoso> Let me cook up an isolated testcase without the library
04:33:52 <tdammers> overloaded strings could cause an inefficient fromString implementation to be evaluated
04:34:08 <dminuoso> merijn, cocreature: https://gist.github.com/dminuoso/142ec6ab576eb3a6eb0c0f92c21740c1
04:34:17 <dminuoso> Remove the OverloadedStrings pragma and it compiles
04:35:11 <merijn> Weird
04:35:28 <merijn> dminuoso: Does it work normally with validString?
04:35:36 <dminuoso> merijn: Same problem
04:35:48 <merijn> That's weird
04:36:41 <merijn> oh
04:37:05 <merijn> I have an idea
04:37:14 <dminuoso> merijn: https://ghc.haskell.org/trac/ghc/ticket/15437 in case you thought of this road
04:37:38 <merijn> So, that's encoded by producing an AST which runs fromLiteral on a (Lift produced) String in the AST
04:37:54 <merijn> What if OverloadedStrings is reapplying the fromString to the Lift produced literal?
04:38:59 <merijn> What do you get if you dump splices?
04:39:08 <merijn> That sounds obnoxious and dumb enough to be the problem, tbh
04:39:13 <dminuoso> Nothing of interest
04:39:27 <merijn> dminuoso: I wanna see the splices anyway :)
04:39:52 <dminuoso> Oh
04:40:07 <merijn> dminuoso: Also, what happens if you remove the spliceValid implementation in this instance?
04:40:10 <merijn> Does it work then?
04:40:13 <dminuoso> merijn: https://gist.github.com/dminuoso/d0d2e9ee494edfbe5d11193034ff326d
04:40:29 <merijn> (String should be a Lift instance, so the default implementation should work)
04:40:38 <cocreature> it looks like the Lift instance for String doesn’t force a String
04:41:10 <merijn> cocreature: Yeah, that's obnoxious...but I don't think I ever thought to try it with OverloadedStrings
04:42:01 <merijn> I guess that's another point in favour of finally reworking it :p
04:42:23 <dminuoso> merijn: compiles just fine
04:42:47 <merijn> dminuoso: Right, because that way it's not trying to apply fromLiteral to an ambiguous literal...
04:42:59 <merijn> hmm, that's annoying to quickly fix in the current approach, though :\
04:45:31 <dminuoso> merijn: Fair enough. Ill just use `spliceValid v _ = [|| fromJust (fromLiteral @String v) ||]`
04:45:36 <dminuoso> Which is good enough =)
04:46:31 <merijn> dminuoso: Awful, though :p
04:47:17 <dminuoso> Yeah but that's hidden away in the module where the instances lie. As long as the actual code is clean.. :P
04:51:57 <dibblego> fromJust is naughty
04:57:42 <merijn> dibblego: fromJust in this context is just a hack around the fact that GHC doesn't always derive Lift instances
04:58:02 <dibblego> ok
04:58:21 <dminuoso> merijn: Mind my asking, what exactly is the problem? I mean I read what cocreature wrote, but Im not sure I fully understand.
04:59:17 <merijn> dibblego: Basically, I wrote a prototype that abuses Typed TH to perform partial conversions for literals at compile time. So if you have a newtype wrapper + smart constructor type dealio "Int -> Maybe Even", you still sometimes want to write a literal "2" in your code, in which case the smart constructor is a hassle.
04:59:27 <cocreature> dminuoso: lifting a String (which is done implicitely in your code) apparently produces a String literal without a type annotation so if you have OverloadedStrings enabled, this literal will be polymorphic
05:00:17 <dibblego> merijn: why not? _Even :: Prism' Even Int
05:00:21 <merijn> dibblego: So I (ab)use Typed TH to do it at compiletime and error out if the smart constructor fails. But if the type your converting to has no Lift instance, you can't put the result in the TH AST, so instead I splice "fromJust (theConverion ourLiteral)" into the AST to redo it at runtime
05:00:36 <dibblego> oh I see
05:00:53 <merijn> dibblego: You have to handle the failure case, even though a failing literal will NEVER work, so if you type the wrong literal in your code, you'd want to find out at compiletime
05:01:16 <merijn> dibblego: Rather than writing a 1) useless failure path and 2) continuously exercising it for a compile time mistake
05:01:25 <dibblego> right
05:01:38 <dminuoso> cocreature: Oh so something like `LitE (StringL "foo")` might not be a string?
05:01:57 <merijn> dminuoso: the fromString wrapping by OverloadedStrings gets applied to that generated literal, yeah
05:02:02 <merijn> dminuoso: At least, that's what it looks like
05:02:22 <cocreature> I don’t know the exact term that the Lift instance produces but LitE (StringL "foo") seems plausible :)
05:02:27 <merijn> dminuoso: So the TH first generates the String literal + conversion, only to *then* re-polymorphise the literal, causing it to become ambiguous
05:02:37 <merijn> dminuoso: "whoops..."
05:02:56 <merijn> dminuoso: Your @String just immediately undoes the re-polymorphisation in the generated code
05:03:07 <warbo> hello, I'm trying to 'cabal new-freeze' all of my dependencies, but it doesn't seem to be taking into account 'packages: ...' directories specified in 'cabal.project.local'; is that expected?
05:04:43 <warbo> specifically, my package depends on a non-hackage package, which I've specified a path to in 'cabal.project.local', but I don't think that package's dependencies are appearing in my 'cabal.project.freeze' file
05:06:11 <merijn> warbo: Might wanna try asking in #hackage where a lot of the new-X people hang out
05:06:26 <dminuoso> So that'
05:06:32 <dminuoso> So that's where all the cool people went.
05:06:44 <warbo> merijn: thanks
05:07:43 <dminuoso> merijn: where exactly does the re-polymorphization happen?
05:08:18 <merijn> dminuoso: The TH computed splice (i.e. the code you just linked) gets OverloadedStrings applied to it (again)
05:09:35 <dminuoso> I mean when I apply valid to `("127.0.0.1" :: String)`, then I get `valid :: Validate String b => String -> Q (TExp b)`, applying spliceValid to that first argument should use a function `String -> Maybe b`..
05:10:32 <merijn> dminuoso: Yes, but you forget that the result of spliceValid is a Haskell AST
05:11:00 <merijn> dminuoso: Specifically, due to the lack of Lift instance that resulting AST is the AST for: Data.Maybe.fromJust (fromLiteral """")
05:11:21 <merijn> dminuoso: And OverloadedStrings applies to everything in the module, *including* that splice
05:11:47 <merijn> dminuoso: So fromLiteral gets applied to that String literal, which OverloadedStrings just happily turned into "IsString a => a" again
05:11:58 <merijn> dminuoso: So now our use of fromLiteral is ambiguous again
05:12:27 <dminuoso> merijn: Oh I see. I thought GHC would have inserted type applications already.
05:12:42 <dminuoso> But I guess that's actually much later in Core?
05:12:44 <merijn> dminuoso: I would've assumed that too, but clearly not :)
05:13:01 <dminuoso> Interesting. Do you think this might be worth to report as a potential bug/improvement?
05:13:25 <dminuoso> I mean the interaction between TH and OverloadedStrings does not appear nice in this regard
05:13:33 <merijn> dminuoso: I don't think it's a bug, tbh
05:14:45 <Wizek> Is it supposed to be possible to use HasCallStack with a typeclass function?
05:15:18 <Wizek> I get `Illegal implicit parameter ‘?callStack::CallStack’` when I try to put it in either the class or an instance
05:21:39 <warbo> how can I get a list of all dependencies chosen by cabal, in a way which includes extra package directories (e.g. add-source in a sandbox, or packages:... in a cabal.project file?)
05:27:44 <rschmukler> alanz: I did some more debugging. The issue was a combination of the following: 1) emacs-lsp spawns `hie` with a CWD of the buffer's folder (eg. $ROOT/src/File.hs -> $ROOT/src) - the root directory invoked by the lsp plugin (ie. lsp-haskell) is sent to the server, but it doesnt affect the process dir
05:28:47 <rschmukler> 2) Because hie uses the presence of `$CWD/.stack-work` to determine whether to use stack ghc or global ghc, it attempted to look for global. Since I didn't have a global ghc install, it didn't work and exited immediately
05:30:54 <rschmukler> I'm currently looking into lsp-mode spawning the child process (hie) with the correct directory (based off of the plugins root) but am unsure what side-effects that might have. Another option would be to add recursive parent directory traversal to hie's stack detection
05:45:58 <AndroUser> How can i hide the mapM function of prelude?
05:46:16 <merijn> AndroUser: "import Prelude hiding (mapM)"
05:47:00 <AndroUser> thank you :)
05:50:58 <lantti_> is there some way to examine an exception caught with Control.Exception.onException?
05:51:13 <ph88> is it possible that the DevRandom source is slow ?
05:54:39 <merijn> lantti: Eh, use catch inside it? :p
05:55:16 <merijn> lantti: onException is for cleanup style things (like within bracket)
05:55:27 <merijn> lantti: If you wanna inspect/handle exception, use catch/handle
05:57:32 <lantti> merijn: I'm debugging somebody elses code so i didn't want to change it too much in case it accidently starts working :)
06:01:00 <AndroUser> merijn: I get always ambiguous occurrence 🤔
06:03:10 <jhrcek> I'd like to write simple program to read some text from stdin and does simple text transformation. I'm trying Data.Text.IO.interact, but that only ever reads the first 4096 bytes of the input. Can you suggest how to fix that?
06:03:18 <dminuoso> AndroUser: What does the error message say?
06:03:47 <AndroUser> That i import mapM from prelude and Control.Monad.Parallel
06:03:49 <quicksilver> jhrcek: what is your evidence that it only reads 4096 characters?
06:03:52 <c_wraith> jhrcek: are you running inside some sort of IDE?
06:04:01 <AndroUser> Although I wrote import Prelude hiding (mapM)
06:04:07 <dminuoso> AndroUser: Did you save the file?
06:04:13 <AndroUser> Zes
06:04:16 <AndroUser> *Yes
06:04:27 <jhrcek> quicksilver I'm running it on Fedora 28 in standard GNOME terminal program
06:04:28 <dminuoso> AndroUser: Do you have any other `import Prelude` lines?
06:04:30 <merijn> You might be importing mapM from other modules too
06:04:33 <AndroUser> no
06:04:44 <merijn> dminuoso: mapM could also be coming from Monad, Traversable, etc.
06:04:52 <dminuoso> merijn: 15:03     AndroUser | That i import mapM from prelude and Control.Monad.Parallel
06:05:04 <quicksilver> jhrcek: need more details.
06:05:21 <quicksilver> does the program 'hang'? does it appear to terminate? is there an error message?
06:05:37 <dminuoso> AndroUser: Where are you getting this from? intero?
06:05:42 <c_wraith> jhrcek: nothing in the code of interact should limit input length
06:06:13 <AndroUser> merijn: It was my fault.......I have two Main files in different dir's (one with stack, one without) and I wrote it in the wrong file -.-
06:06:26 <AndroUser> Sorry for the inconvenience
06:07:16 <porcupinen00b> Hi people. I have a piece of haskell code that's intriguing me.
06:07:19 <ClaudiusMaximus> jhrcek: where are you getting stdin from (and sending stdout to)?
06:07:37 <jhrcek> Here's core logic of the program: https://gist.github.com/jhrcek/501e45b550b34c0ac63ae7e265d40784
06:08:06 * hackage avro 0.3.3.1 - Avro serialization support for Haskell  http://hackage.haskell.org/package/avro-0.3.3.1 (alexeyraga)
06:08:12 <jhrcek> I run it on CLI and paste one 20k line of text, press enter and CTRL+D
06:08:28 <jhrcek> Then it outputs just the first 4096 bytes as the output
06:08:36 <quicksilver> and does it terminate?
06:09:02 <jhrcek> Yes after pressing CTRL+D
06:09:25 <quicksilver> suspect your terminal is eating the output
06:09:28 <merijn> jhrcek: Are you using redirection? i.e. pipes or < ?
06:09:31 <jhrcek> prints the first 4096 chars with the replacements applied and then returns to cli
06:09:35 <quicksilver> try running it using redirection
06:09:42 <quicksilver> instead of pasting 20k in one line
06:09:47 <quicksilver> ./Main < input > output
06:09:49 <jhrcek> merijn no redirection, just ctrl+v to terminal
06:10:08 <quicksilver> I suspect your terminal is eating either the input or the output
06:10:32 <dminuoso> Could this be a flushing thing?
06:10:35 <alanz> rschmukler, thanks, I will make a ticket to investigate. I always start emacs in the root dir of the project, so maybe that is why it is masked.
06:10:39 <jhrcek> quicksilver you're right, tried `prog < input` and now it processes everything
06:10:49 <porcupinen00b> I think it has something to do with bottoms but it surprised me a bit: https://lpaste.net/5729760430432190464
06:11:14 <rschmukler> alanz: great! I'm curious to see where you resolve this. It wasn't really a "bug" - just a series of unfortunate events :P
06:11:31 <alanz> rschmukler, see https://github.com/haskell/haskell-ide-engine/issues/714
06:11:52 <alanz> this thing must just work, or tell you what to do to get it to work
06:11:54 <cocreature> porcupinen00b: which part are you surprised about?
06:12:37 <porcupinen00b> it's basically a type which is an infinity regress and I can seemingly write a function that "extracts" a value of any type from it (of course it never actually runs because there are infinitely many layers to peel, but it compiles)
06:12:57 <dminuoso> porcupinen00b: Yes. The value of a never ending computation is bottom.
06:12:58 <rschmukler> Awesome! Would have created an issue but I wasn't sure if it was appropriate since it's not really a bug. Anyway, thanks for the help!
06:13:07 <dminuoso> Bottom is incidentally a member of every (lifted) type.
06:13:15 <porcupinen00b> Hummm!
06:13:16 <quicksilver> > let x = x in (x :: Int)
06:13:18 <dminuoso> :t forever
06:13:19 <lambdabot>  *Exception: <<loop>>
06:13:19 <lambdabot> Applicative f => f a -> f b
06:13:29 <dminuoso> porcupinen00b: ^- that's the reason for the return type of `forever`
06:13:45 <dminuoso> porcupinen00b: A morally correct version should read: forever :: Applicative f => f a -> f Void
06:14:16 <dminuoso> porcupinen00b: Another way to see this:
06:14:30 <dminuoso> @let fun = fun
06:14:31 <lambdabot>  .L.hs:159:7: error:
06:14:31 <lambdabot>      Ambiguous occurrence ‘fun’
06:14:31 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.fun’,
06:14:32 <dminuoso> :t fun
06:14:33 <lambdabot> FromExpr a => String -> a
06:14:36 <dminuoso> @let fun' = fun'
06:14:37 <lambdabot>  Defined.
06:14:38 <dminuoso> :t fun'
06:14:39 <lambdabot> t
06:14:46 <dminuoso> that is, `forall t. t`
06:15:32 <dminuoso> porcupinen00b: So you cant extract an arbitrary value out of it, you get something back that is so polymorphic that it fits into every type.
06:15:41 <porcupinen00b> I see. So, values which lead to this kind of infinite regress can be of any haskell type? Is there some known type system where this can be avoided?
06:15:41 <porcupinen00b> ?
06:15:59 <jhrcek> quicksilver, c_wraith, ClaudiusMaximus, merijn: thanks for pointing me in the right direction. I found the culprit and it's not Haskell again :) https://unix.stackexchange.com/questions/131105/how-to-read-over-4k-input-without-new-lines-on-a-terminal#answer-131274
06:16:05 <cocreature> there are type systems that check for termination
06:16:24 <cocreature> but that only works if you give up turing completness
06:16:49 <porcupinen00b> Oh yes, that's that theorem, right?
06:17:14 <porcupinen00b> the halting problem, right?
06:17:15 <cocreature> yep :)
06:17:53 <porcupinen00b> I think this is helping me grasp better what the halting problem actually means.
06:17:54 <porcupinen00b> Thanks!
06:18:03 <quchen> The problem with losing Turing completeness is not that you need it in practice, it’s that it’s much harder to convince the computer that your algorithm is indeed productive in finite time.
06:18:05 <reactormonk> How do I tell deriving whether to use GND or DAC?
06:18:13 <dminuoso> porcupinen00b: It might be interesting to see why we have bottom in the first place. If a function is a pure (!) mapping from values to values, then what does a function map to, when the computation never ends?
06:18:40 <warbo> porcupinen00b: the key to your example is that Haskell definitions are (mutually) recursive by default
06:19:33 <porcupinen00b> dminuoso: hummm... interesting point. If the computation never ends, how can I ever precisely grasp what value it would return?
06:19:49 <porcupinen00b> So I can't know which type would this value be
06:20:07 <porcupinen00b> so it must be `forall t . t`, which is the type of "anything"
06:20:24 <warbo> porcupinen00b: when checking/inferring a type, we start from the most general possible type, then use the definition to constrain what's actually allowed
06:20:53 <cocreature> reactormonk: recent versions of GHC have a DerivingStrategies extension that allows you to do exactly that
06:20:56 <dminuoso> porcupinen00b: No you know what the type would be.
06:21:15 <dminuoso> porcupinen00b: Let's say we have a function: `f :: Int -> Int; f x = (f x) + 1`
06:21:31 <warbo> porcupinen00b: for a completely recursive definition, like "foo = foo", there are no constraints, so we get "forall t. t"
06:21:44 <dminuoso> porcupinen00b: Clearly we have something of type `Int`, but it cant be a number clearly.
06:23:09 <dminuoso> porcupinen00b: That is if we now consider applying `f` to some value: `f 1`
06:23:31 <dminuoso> Then `f 1 :: Int` - that's basic type rules
06:24:22 <dminuoso> So `Int` must not purely consist of numbers. There must be some kind of (semantic) value to represent failure/infinite computation. We call that value bottom - and that bottom inhabits all types
06:25:29 <porcupinen00b> hummmm
06:25:47 <porcupinen00b> so, this happens even for values that do have a specific type
06:25:53 <porcupinen00b> interesting
06:26:19 <porcupinen00b> but the value itself is a "non-terminating thing"
06:26:26 <dminuoso> porcupinen00b: Or a failure.
06:26:35 <porcupinen00b> Is there a notion of equality between this bottoms?
06:26:40 <dminuoso> porcupinen00b: Consider: what should `head []` give you?
06:26:43 <dminuoso> :t head
06:26:45 <lambdabot> [a] -> a
06:26:55 <porcupinen00b> Are every bottom the same bottom or are there infinitely many different bottoms?
06:26:58 <dminuoso> Or maybe a monomorphized version: head :: [Int] -> Int
06:27:04 <tdammers> bottom is like refusing to answer a question
06:27:23 <tdammers> you ask the computer what the first element of the empty list is, and it refuses to answer
06:27:42 <tdammers> but asking whether two refusals to answer are the same answer is a bit nonsensical, isn't it
06:27:51 <tdammers> I mean, they are, but not in a useful way
06:28:23 <tdammers> if you ask two random people what their names are, and both refuse to answer, then you are in a way getting the same answer from both, but that doesn't mean they have the same names
06:29:58 <dminuoso> porcupinen00b: Perhaps you can deduce this on your own. Do you think a function `isBottom :: a -> Bool` can exist?
06:29:59 <OwenBarfield> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
06:30:01 <OwenBarfield> Voice your opinions at https://webchat.freenode.net/?channels=#freenode
06:30:36 <quchen> tdammers: One might be mute and one might spit in your face though. That distinction would interest me in advance.
06:30:58 <mreh> does GHC strip the static libs it produces?
06:31:07 <quchen> Which is a bit like telling apart nontermination from an exception.
06:31:08 <mreh> running strip --strip-unneeded has no effect
06:31:08 <tdammers> quchen: I think that's where the metaphor breaks ;)
06:31:54 <dminuoso> tdammers: Is it? I mean in Haskell the RTS might throw a <<loop>> exception, I might get some other `error`, or perhaps Ill have to wait a *real long time*
06:32:17 <mreh> :t fix (:[])
06:32:18 <lambdabot> error:
06:32:18 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ [a]
06:32:18 <lambdabot>       Expected type: [a] -> [a]
06:32:28 <mreh> err
06:32:45 <quchen> For a mathematician, all bottoms are equal. For an engineer not so much.
06:32:46 <mreh> what's am I trying to do
06:33:07 <monoidal> Sometimes a bottom value will correspond to an infinite loop, sometimes to an exception. However, there's no way to tell cleanly. Consider undefined + loop, if you were able to say whether this throws an exception you would know the evaluation order of + which is an implementation detail.
06:33:31 <quchen> You can wrap things in unsafePerformIO, catching the pure exception. You can have a time cutoff. You can kill threads that do something weird.
06:34:16 <quchen> seq undefined (fix id) -- Let the compiler choose which ⊥ to use :-D
06:34:26 <tdammers> dminuoso: point in case
06:36:53 <Whooa21> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
06:36:53 <Whooa21> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
06:36:53 <Whooa21> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
06:36:56 <Whooa21> Voice your opinions at https://webchat.freenode.net/?channels=#freenode
06:39:37 * hackage deferred-folds 0.6.6 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.6.6 (NikitaVolkov)
06:41:34 <warbo> I think "refusing to answer" feels more like NULL, since we can imagine taking that and moving on
06:41:56 <warbo> bottom is more like you ask someone their name and the entire universe is annihilated :P
06:44:08 <ph88> how can i find out why my code is slow ?
06:45:34 <agentultra> ph88: start by measuring, look for any obvious loops-in-loops giving you n^2 or quadratic behaviour, remove them, measure again... is one way. :)
06:46:11 <ph88> don't see any obvious things
06:47:26 <agentultra> That's about the best I can do in Haskell rn... if it were C I'd have a lot more to share. :)
06:47:50 <agentultra> in principle, measure, adjust, measure works regardless of the language.
06:49:22 <warbo> ph88: there are a few ways, https://wiki.haskell.org/Performance lists some
06:50:13 <warbo> ph88: profiling is the most important thing https://wiki.haskell.org/Performance/GHC#Measuring_performance
06:52:09 <Geeky_Bear> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
06:52:12 <Geeky_Bear> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
06:52:15 <Geeky_Bear> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
06:52:18 <Geeky_Bear> Voice your opinions at https://webchat.freenode.net/?channels=#freenode
07:01:53 <drot|> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
07:01:56 <drot|> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
07:02:00 <drot|> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
07:02:04 <drot|> Voice your opinions at https://webchat.freenode.net/?channels=#freenode
07:16:50 <vdamewood> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
07:16:53 <vdamewood> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
07:16:57 <vdamewood> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
07:17:00 <vdamewood> Voice your opinions at https://webchat.freenode.net/?channels=#freenode
07:17:03 <HarryS|> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
07:17:06 <HarryS|> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
07:17:10 <HarryS|> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
07:17:12 <HarryS|> Voice your opinions at https://webchat.freenode.net/?channels=#freenode
07:18:57 <dminuoso> Curious. This is starting to look like accounts have been hijacked.
07:19:46 --- mode: ChanServ set +o mniip
07:20:29 <rkrishnan> wow! The documentation generated for the same version of conduit in hackage and stackage look different! hackage has a few missing functions. Wonder why it is so..
07:22:08 <glguy> Which version and function?
07:22:36 * hackage focus 1 - A general abstraction for manipulating elements of container data structures  http://hackage.haskell.org/package/focus-1 (NikitaVolkov)
07:23:30 <rkrishnan> for instance, mapC is listed here in stackage: https://www.stackage.org/haddock/lts-12.2/conduit-1.3.0.3/Conduit.html#v:mapC However, mapC is not listed here at all: https://hackage.haskell.org/package/conduit-1.3.0.3/docs/Data-Conduit.html
07:24:44 <glguy> https://hackage.haskell.org/package/conduit-1.3.0.3/docs/Conduit.html#v:mapC
07:24:47 <dminuoso> rkrishnan: You are in the wrong modulke
07:24:57 <glguy> You were looking at the wrong module
07:25:01 <dminuoso> rkrishnan: On stackage you are looking at Conduit, on hackage you are looking at Data.Conduit
07:25:04 <rkrishnan> oh. :-(
07:25:07 <rkrishnan> Yes, got it.
07:25:37 * hackage primitive-extras 0.5.0.2 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.5.0.2 (NikitaVolkov)
07:26:06 <rkrishnan> I totally missed the top-level module. (on stackage I arrived at the page via a search)
07:26:15 <rkrishnan> Sorry for the noise!
07:27:26 <krysjonaz> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
07:27:36 * hackage stm-hamt 1 - STM-specialised Hash Array Mapped Trie  http://hackage.haskell.org/package/stm-hamt-1 (NikitaVolkov)
07:28:39 <dminuoso> Say I have a function `g :: (A a, B b) => a -> b -> Int` and I use said function, is there a good paper or resource that explains how the type checker proceeds? In particluar Im interested in the correct *terminology*
07:28:55 <dminuoso> I've seen articles that talk about "compiler dispatching a proof for `A a1`"
07:30:30 <c_wraith> there are a bunch of equivalent theoretical views of classes.  Whether that's what the compiler uses as its internal terminology isn't especially relevant.
07:33:45 <glguy> rkrishnan: I fixed the quickjump links on the hackage version of the documentation. You can press 's' while you'll looking at that page and type in "mapC" now and it will take you straight to it :)
07:35:01 <rkrishnan> glguy: thanks a lot.
07:37:23 <electrocat> the problem with correct terminology for TC's is that you can look at it from different equivalent perspectives
07:38:48 <electrocat> from the perspective of type-inference, from the generated Core
07:39:08 <c_wraith> At the point of generated core, classes no longer exist
07:39:19 <c_wraith> They really only exist during type inference/checking
07:40:05 <c_wraith> I guess a short bit longer, when specializing is happening.  But they're gone by the time the code reaches core
07:40:16 <electrocat> c_wraith: evidence of type classes is present in the generated Core, proof for "A a1", could be seen als a type class dictionary for "A a1"
07:40:56 <c_wraith> electrocat: yes, but it's all be rewritten as explicit argument passing.  It's exactly identical to any other function argument.
07:41:15 <electrocat> sure
07:41:16 <c_wraith> electrocat: at which point it's no longer classes
07:42:40 <electrocat> my point is that you can see the generated Core as proof for a TC constraint
07:44:23 <ph88> found it :P
07:47:36 * hackage deferred-folds 0.6.7 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.6.7 (NikitaVolkov)
08:03:29 <lavalike> glguy: are you saying something happens if one presses 's' here, and then types 'mapC' ? https://hackage.haskell.org/package/conduit-1.3.0.3/docs/Conduit.html
08:07:13 <orbisvicis> can builin types (int,char) be viewed as builtin ADTs?
08:08:43 <dminuoso> orbisvicis: Yes.
08:09:27 <dminuoso> orbisvicis: (,) is a product type, just like Either is a coproduct type.
08:10:06 <dminuoso> orbisvicis: iow: `data A = A B C` is isomorphic to (B,C), and `data A = B | C` is isomorphic to `Either B C`
08:11:27 <orbisvicis> err I meant int or char, separately
08:11:53 <dminuoso> orbisvicis: What do you mean?
08:12:32 <orbisvicis> can Int or Char be viewed as a builtin algebraic data type, and if so, what about Integer ?
08:12:50 <cocreature> you could think of Int as data Int = 0 | 1 | 2 | 3  | … but that’s not how they’re implemented and I don’t think it’s a particularly useful view
08:13:34 <dminuoso> data Int = Nil | Succ Int
08:13:51 <dminuoso> That would be a more useful perspective, even though it's also not how they are implemented.
08:14:12 <dminuoso> Although wait.. that should be `data Nat = Nil | Succ Nat`, not Inbt.
08:14:40 <cocreature> I’m not sure that’s a more useful perspective. that type is fundamentally different from Int. a giant disjunction does at least come somewhat close
08:14:42 <nshepperd1> That has the wrong strictness though
08:15:47 <noipmups> Why mtl does not contains MaybeT?
08:15:50 <cocreature> it has the wrong strictness, the wrong performance guarantees both in terms of runtime and in terms of memory usage, …
08:16:05 <nshepperd1> Nat = Nil | Succ !Nat has the right strictness at least, but still the wrong runtime properties
08:16:26 <|Leary> It also has an ordinal member which isn't a natural, but I like that.
08:16:52 <jimbeamm> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
08:16:52 <jimbeamm> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
08:16:52 <jimbeamm> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
08:18:30 <dminuoso> nshepperd1: Bah. Ill just use it and pretend GHC will do its magic and optimize everything away.
08:18:50 <nshepperd1> Heh
08:19:32 <orbisvicis> nshepperd1: by strictness, you mean not a flat domain ?
08:21:42 <orbisvicis> anyway, can I view functions such as id and succ (a -> ...) as strict by pattern matching on an adt constructor of type a ?
08:22:07 * hackage stm-containers 1 - Containers for STM  http://hackage.haskell.org/package/stm-containers-1 (NikitaVolkov)
08:23:06 * hackage slave-thread 1.0.2.1 - A fundamental solution to ghost threads and silent exceptions  http://hackage.haskell.org/package/slave-thread-1.0.2.1 (NikitaVolkov)
08:23:26 <cocreature> dminuoso: even then it’s wrong. your type is not bounded whereas Int is bounded
08:25:47 <nshepperd1> orbisvicis: yeah, that's what i meant
08:29:36 <naos|> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
08:29:36 <naos|> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
08:29:36 <naos|> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
08:30:36 * hackage asciichart 1.0.0 - Line charts in terminal  http://hackage.haskell.org/package/asciichart-1.0.0 (madnight)
08:30:46 <zachk> @src guard
08:30:47 <lambdabot> guard True  = pure ()
08:30:47 <lambdabot> guard False = empty
08:31:10 <zachk> @src empty
08:31:10 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:31:36 * hackage deferred-folds 0.6.8 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.6.8 (NikitaVolkov)
08:31:37 <glguy> zachk: If you want to see the actual source code for things you can go on hackage.haskell.org and click the source links next
08:33:25 <zachk> whats empty though?
08:33:42 <merijn> zachk: from the Alternative typeclass
08:33:48 <merijn> zachk: in Control.Applicative
08:33:56 <merijn> :t Control.Applicative.empty
08:33:57 <lambdabot> Alternative f => f a
08:34:11 <Contessa> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
08:34:19 <merijn> > empty :: Maybe a
08:34:22 <lambdabot>  Nothing
08:34:36 <zachk> those links seem to have hijacking in them
08:34:41 <merijn> Man, it's really script kiddie day
08:34:47 <zachk> my autoprotect went off
08:34:49 <merijn> zachk: Yes, they've been spamming all of freenode all day
08:35:07 <merijn> zachk: Some random scriptkiddie/spammer attack
08:35:11 <zachk> why would you, it's such a pleasant network compared to most, at least most channels
08:35:34 <merijn> zachk: freenode gets hit by spammers all the time
08:35:51 <merijn> zachk: Mostly people out for "revenge" for being banned or trying to prove something
08:36:24 <merijn> zachk: Alternative is kind of a "higher order" monoid, so you have
08:36:25 <merijn> :t (<
08:36:27 <lambdabot> error:
08:36:27 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
08:36:30 <merijn> :t (<|>)
08:36:32 <lambdabot> Alternative f => f a -> f a -> f a
08:36:34 <merijn> As binary operation
08:36:36 <merijn> and
08:36:37 <zachk> i've only been banned on and off from one channel, and it's kind of crude most of the time so I don't even go there anymore
08:36:39 <merijn> :t empty
08:36:40 <lambdabot> Alternative f => f a
08:36:51 <merijn> As the left and right identity for <|>
08:37:01 <zachk> so what would empty be for [] ?
08:37:16 <merijn> > empty :: [a]
08:37:18 <lambdabot>  []
08:37:24 <merijn> Very exciting!
08:37:41 <zachk> > (return ()) :: [a]
08:37:41 <merijn> zachk: Note that Alternative only constrains 'f' so it has no way to generate the 'a' inside it
08:37:43 <lambdabot>  error:
08:37:44 <lambdabot>      • Couldn't match type ‘a1’ with ‘()’
08:37:44 <lambdabot>        ‘a1’ is a rigid type variable bound by
08:37:54 <zachk> :t return
08:37:55 <lambdabot> Monad m => a -> m a
08:38:05 <merijn> So logically, "empty" can only exists for Applicatives that have some kind of, well, "empty" option
08:38:12 <merijn> Such as lists and Maybe
08:38:23 <zachk> :t pure ()
08:38:24 <lambdabot> Applicative f => f ()
08:38:40 <zachk> > (pure ()) :: [a]
08:38:42 <lambdabot>  error:
08:38:42 <lambdabot>      • Couldn't match type ‘a1’ with ‘()’
08:38:42 <lambdabot>        ‘a1’ is a rigid type variable bound by
08:38:49 <zachk> how would I get that to work?
08:38:52 <merijn> zachk: That can't typecheck as () can't be any random a
08:39:02 <merijn> zachk: You can't, you'd have to write "pure () :: [()]"
08:39:31 <merijn> zachk: Pure produces an Applicative with it's argument type in there, so you can make it generate a completely unrelated structure
08:40:12 <merijn> zachk: Whereas "empty" says "regardless of what you want inside it, I can give you a structure!" which only makes sense for structures not actually containing anything. Otherwise you'd have to create the contents from thin air
08:40:33 <merijn> > empty :: Maybe Bool
08:40:36 <lambdabot>  Nothing
08:41:40 <merijn> I mean, I suppose you could do "pure undefined :: [a]", but that seems obviously cheating
08:41:47 <merijn> Anyhoo, gotta run
08:44:17 <mcspud1310> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
08:44:17 <mcspud1310> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
08:44:17 <mcspud1310> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
08:45:42 <shapr> really hate spammers
08:46:03 <noipmups> Can someone give me opinion on Haskell project structure (it's my first time)? I have one top level monad transformer `type App a = ReaderT Env IO a` which contains app configuration + global functions. Then I have nested monad transformers for specific jobs like `type NuclearMissile a = ExceptT (StateT NuclearMissileState App a)`, `type Gateway a = StateT GatewayState App a` and running this transformers in a loop (always keeping and passing new
08:46:03 <noipmups>  state). Is this architecture good?
08:47:07 <lavalike> noipmups: be very careful with architectures involving nuclear missiles!
08:47:38 <cocreature> if you are already in IO, you might want to consider using an IORef/TVar instead of StateT.
08:47:50 <cocreature> that will make things a lot easier if you start adding concurrency
08:48:38 <cocreature> whether ExceptT on top of IO is a contentious topic so I’m not going to comment on that :)
08:50:15 <noipmups> concreature: So should I have one big global state in ReaderT using IORefs and passing subset of that state to each component?
08:50:42 <zachk> why not use StateT if you want single threaded state?
08:51:20 <cocreature> noipmups: I would probably just pass the IORef around manually
08:52:35 <zachk> :t guard
08:52:36 <lambdabot> Alternative f => Bool -> f ()
08:53:22 <cottongin10> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
08:53:22 <cottongin10> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
08:53:22 <cottongin10> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
08:53:31 <noipmups> concreature: But in case when app will run only in one thread, is using multiple StateT in ReaderT sufficient?
08:54:20 <cocreature> it might be sufficient but I’d say it’s harder to use than an IORef so it’s not the IORef that needs justification. it’s the StateT that needs justification
08:54:21 <noipmups> cocreature: And sorry for second username misspeling...
08:54:53 <cocreature> and multiple StateT tend to work fairly badly, you are usually better off having a single StateT layer with a product of the individual parts of your state
08:54:56 <acowley> noipmups: Do you really need to layer things atop App like that? That's bringing IO into everything. A common approach is to have something like App at the top level, but helpers being `State NuclearMissileState a`.
08:55:58 <acowley> For me, a takeaway of the wisdom of cocreature's advice (namely, just use an IORef) is that I've made an architectural mistake.
08:56:07 <noipmups> acowley: Indeed, I don't need it.
08:56:31 <cocreature> right if you can eliminate the IO then StateT is perfectly fine
08:56:36 <|Leary> Argument for StateT: you can have a consistent interface to your state in both pure and IO contexts.
08:56:47 <acowley> In that case, you can lift the pure functions into the bigger App type with relative ease.
08:57:12 <acowley> And that's definitely the way to go if you can pull it off because those functions become much more tightly defined.
08:58:13 <cocreature> generally keep the IO parts of your app simple and try to push complexity into functions that don’t need to perform IO
08:58:20 <Taneb> |Leary: I'd use "MonadState NuclearMissileState m => m foo" then
08:58:56 <glguy> Yuck! if you're going to use typeclasses, make one specific to the problem
08:59:09 <glguy> If you're using MonadState with something other than a type variable you're probably using it wrong
09:01:07 <Taneb> glguy: ?
09:24:32 <Kamilion6> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
09:31:53 <maskedlua29> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
09:31:53 <maskedlua29> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
09:31:53 <maskedlua29> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
09:41:07 * hackage comfort-array 0.0.1.1 - Arrays where the index type is a function of the shape type  http://hackage.haskell.org/package/comfort-array-0.0.1.1 (HenningThielemann)
09:50:06 * hackage text-format 0.3.2 - Text formatting  http://hackage.haskell.org/package/text-format-0.3.2 (phadej)
09:50:36 <limenius> Hello. Is there anyone who read book "Real World Haskell"? I would appreciate some help regarding examples in this book.
09:54:40 <d__b> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
09:54:40 <d__b> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
09:54:40 <d__b> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
09:58:32 <dungodung248> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
09:59:14 <dysfun> limenius: what's the problem?
10:09:43 <SlashLife24> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
10:11:07 * hackage focus 1.0.1 - A general abstraction for manipulating elements of container data structures  http://hackage.haskell.org/package/focus-1.0.1 (NikitaVolkov)
10:16:15 <lavalike> do I remember incorrectly that there is a ghc option to redirect *all* intermediate build files generated to a directory? i.e. a way to override the default of "."?
10:16:34 <lavalike> I'm finding options for each kind of artifact, I thought there was one for all of them but I can't find it anymore
10:17:13 <cocreature> lavalike: -outputdir?
10:17:57 <lavalike> cocreature: deary me it's there! thanks
10:18:57 <cocreature> lavalike: fwiw ghc --show-options in combination with grep is often useful for finding options that might be relevant
10:19:34 <lavalike> cocreature: appreciate it
10:20:14 <lavalike> I developed some selective blindness looking at the HTML documentation, could see odir hidir .. but not outputdir hiding in plain sight between them (:
10:20:38 <geekosaur> (anti)pattern blindness
10:26:07 * hackage indexation 0.2.0.3 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.2.0.3 (NikitaVolkov)
10:27:36 <Guest31218> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
10:33:20 <madknight> For which NixOS branch do I have to open a Pull Request in order to add a new Haskell library?
10:33:53 <cocreature> madknight: you are probably going to have more luck asking that question in #nixos
10:36:46 <madknight> cocreature, hmm okay
10:37:19 <dsaravanan> In C, for modulo % is used, what is the equivalent in haskell?
10:37:24 <glguy> `mod`
10:37:43 <glguy> > 13 `mod` 3
10:37:43 <geekosaur> with the backquotes (they indicate infix use of a prefix function)
10:37:45 <lambdabot>  1
10:41:50 <roger_rabbit3> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
10:41:50 <roger_rabbit3> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
10:41:50 <roger_rabbit3> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
10:45:33 <limenius> #join #hashell.cz
10:49:32 <crobbins> what's a good way to "extract" the types into something like an hlist with ghc generics? essentially trying to prove
10:49:33 <crobbins> (Generic a, Generic b, Rep a ~ (Rep b :*: c))
10:50:32 <crobbins> such that type b has the same substructure as type a
10:53:05 <crobbins> i.e. `a` must have all of the same field types, in the same order, as `b`, but `b` doesn't need to have the extra fields that `a` might have
10:54:17 <glguy> That's not something that GHC.Generics is well suited to
10:58:24 <crobbins> glguy: hmm, is there an alternate type class out there that might work better for this?
10:58:43 <crobbins> maybe something that can, preferably with type families, produce an hlist?
11:02:53 <limenius> Has anyone read book "Real world haskell"
11:02:55 <limenius> ?
11:03:02 <glguy> Yeah, lots of people have
11:03:30 <Rembane> Yup
11:03:48 <limenius> There are quite a few examples and usually some functions collide with built in Prelude functions. How am I supposed to fix that?
11:04:12 <glguy> What's an example?
11:05:18 <noidedsuper> `import Prelude hiding (someFunc)`
11:06:18 <limenius> In chapter 5, you're creating library to parse JSON, and at some point there is implemented (<>) which collide with Prelude.<>
11:07:00 <geekosaur> yes, that was added since it was published
11:07:08 <geekosaur> so you probably want to do what noidedsuper said
11:07:34 <limenius> Thanks for your advice. I'll try it
11:08:11 <geekosaur> there are some other things you'll run into, like the whole exception handling system was redone a couple months after the book was published
11:08:17 <geekosaur> dead trees don't self-update
11:08:48 <glguy> neither does the online version of that book, unfortunately
11:09:33 <limenius> That doesn't sound good :-(
11:09:50 <geekosaur> well, there's an associated blog, it's often worth looking through the entries in it
11:10:08 <geekosaur> including per page which should have such things
11:10:18 <limenius> name of that blog, please?
11:11:23 <geekosaur> it's embedded. you'll see links like "12 comments" after various things
11:11:55 <geekosaur> I see them after each paragraph and example
11:12:35 <limenius> is that by any chance www.realworldhaskell.org/blog ?
11:14:19 <geekosaur> that's the standalone blog
11:14:36 <geekosaur> I am looking at http://book.realworldhaskell.org/read/io-case-study-a-library-for-searching-the-filesystem.html and every paragraph and every example has a comment link after it
11:15:20 <mdunn> has anyone read Haskell Programming From First Principles?
11:15:26 <geekosaur> note that if you use an extension that hides comments on e.g. media sites, it may be hiding those links as well
11:15:31 <mdunn> trying to see if it's worth recommending to beginners
11:18:08 <limenius> Oh thanks. I bought Humble Bundle in which was copy of Real world Haskell and there are no links to comments
11:19:42 <geekosaur> oh, yeh, that's almost as bad as a dead tree copy, it won't know about the master site
11:19:55 <geekosaur> because random ereaders wouldn;t be able to handle the links
11:23:27 <monochrom> Wait, Humble Bundle is a bundle of books, not a bundle of games?!
11:23:37 <yushyin> both
11:23:41 <limenius> There are various bundles
11:23:56 <monochrom> That's crazy.  Will they also bundle operas too?!
11:23:58 <limenius> Books, games, early access
11:24:06 <glguy> it's bundles of anything you wouldn't normally buy unless bundled, not just games
11:24:32 <limenius> Well the craziest part was book bundle about 3 week earlier, full of gay literature...
11:25:51 <glguy> ls
11:26:42 <Rembane> It was amazing!
11:26:56 <exio4> glguy: the bundles of games often have quite a few fun ones
11:27:01 <exio4> and you get DRM-free!
11:37:02 <piark_> hello
11:41:06 <hololeap> where can i read up on the theory(ies) behind the recursion-schemes library?
11:44:27 <dminuoso> electrocat: Mmm fair enough, its just difficult because so many people seem to be flinging around different words..
11:44:45 <dminuoso> Like edward kmett calls a context an "obligation" that needs to be discharged somehow.
11:45:14 <dminuoso> At least when he's talking about his package constraints
11:46:02 <mniip> curry-howard!
11:46:22 <mniip> covariant values are things you posess, contravariant values are things you're obliged to provide
11:51:58 <mnoonan_> hololeap: I think the "Programming with Bananas, Lenses, and Barbed Wire" is the start of things: https://maartenfokkinga.github.io/utwente/mmf91m.pdf
11:52:43 <mnoonan_> (the notation in that paper is.. really something else)
11:53:05 <hololeap> mnoonan_: ah, thanks for that
11:53:37 <dminuoso> mnoonan_: Oh.. so "A => B" really is some "if you want to use B you are obliged to prove B"?
11:56:05 <dminuoso> *if you want to use B you are obliged to prove A
11:56:05 <DLange10> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
11:56:05 <dminuoso> Or mniip actually. Mixed you up =)
11:56:07 <monochrom> Everyone uses "=>" to mean something else.
11:56:23 <dstolfa> monochrom: what do you mean, everyone knows that => is just greater or equal!
11:56:40 <monochrom> That's >=
11:56:46 <dstolfa> monochrom: nonono
11:57:01 <dminuoso> dstolfa: => is equal or greater.
11:57:03 <dminuoso> dstolfa: yesyesyes
11:57:21 <hyperisco> And >>= is much greater than or equal.
11:57:22 <dstolfa> dminuoso: same thing
11:57:25 <dstolfa> hyperisco: yes.
11:57:39 <dminuoso> dstolfa: missed my play on the order of the words, reflecting.. oh nevermind.
11:57:55 <dstolfa> dminuoso: i didn't miss it, i'm just taking a piss
11:57:57 <monochrom> Learn You A Haskell for Greater Greater Equal Good (LYAH >>= Good)
11:58:02 <dminuoso> hyperisco: why not bitshift and equal?
11:58:53 <monochrom> Because "Learn You A Haskell for Bitshift Equal Good" simply sounds wrong. >:)
11:59:35 <dstolfa> if JS can have ===, then we can have >>=, <<=, <=<, >=>, >>>, <<< and so on
11:59:43 <Solonarv> Learn You A Haskell For Monadic Bind Good?
11:59:48 <monochrom> I agree.
12:00:33 <butterthebuddha> What's >=>?
12:00:44 <butterthebuddha> Greater than or equal to or greater than?
12:00:54 <monochrom> x >=> y  =  \f -> x f >>= y
12:01:08 <butterthebuddha> ( I know the actual definition)
12:01:12 <monochrom> @type (>=>)
12:01:14 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
12:01:29 <dminuoso> So what is <=<
12:01:29 <dminuoso> butterthebuddha: no it's "roughly greater or equal than"
12:01:33 <monochrom> OK, then what does your question mean?
12:02:12 <Solonarv> <=< is just flipped >=>
12:02:15 <monochrom> What does "what is" mean?
12:13:58 <mobattah> Anyone know an active Azure community on freenode or elswhere?
12:17:45 <johnw> interesting that you'd think we would know...
12:18:16 <bitemyapp> we're one of the more populous channels on Freenode
12:18:26 <bitemyapp> randos sort by "top channels" and copy-and-paste their question
12:19:02 <mobattah> Ha, bitemyapp, you're funny. I've asked other channels and haven't gotten anywhere. Didn't know there was a listing for the most populous channels.
12:19:06 <mobattah> populated*
12:31:37 <hololeap> mobattah: /msg alis list azure
12:32:10 <smaudet> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
12:33:17 <Rembane> Are there any ops around?
12:33:28 <Rembane> Aha!
12:33:30 <Rembane> Nvm
12:33:38 <geekosaur> they're hitting lots of channels
12:34:06 <some_weirdo13> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
12:35:40 <mobattah> thank you hololeap!
12:35:46 <mobattah> What's this pedo spam?
12:36:51 <geekosaur> all over freenode :(
12:37:18 <Rembane> All over all servers they find regardless of network.
12:37:40 <fredefox> pedo spam?
12:39:09 <fredefox> oh jeez, I see,,,
12:44:28 <zhongfu28> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
12:46:17 <ddellacosta> ffs
12:49:17 <liste> that's just harassment ^
12:49:23 <[exa]> I wonder why freenode servers can't have a quick global regex K-line trigger
12:49:49 <geekosaur> one example was someone oin xmonad making a joke about the spam, which would probably have triggered it
12:49:56 <geekosaur> people are people
12:50:19 <geekosaur> and automation is, as a rule, dumb
12:51:27 <[exa]> well not _that_ dumb rules, but something quickly installable to match exactly that ^ message
12:51:32 <c_wraith> I've been accidentally hit with an automated k-line on freenode before.
12:51:51 <c_wraith> the admins don't have the best track record with that.
12:52:02 <c_wraith> iirc, that one hit thousands of people accidentally
12:52:05 <[exa]> :]
12:52:30 <Welkin> with not emblezzling their funds?
12:53:54 <Welkin> the numbers have gone up since the last purge
12:54:14 <Welkin> idlers beware
12:56:26 <c_wraith> Welkin, it was a discussion on possible responses to the current network-wide spam attacks
12:59:18 <mniip> 1532548133 [22:48:53] <[exa]> I wonder why freenode servers can't have a quick global regex K-line trigger
12:59:22 <mniip> that's what we do via Sigyn
13:01:10 <Welkin> mniip: since when are you an op?
13:02:21 <mniip> I don't remember. But I am also freenode staff which is a bit higher
13:04:27 <Kraps18> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
13:04:40 <Dave248> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
13:04:53 <Welkin> what
13:05:34 <Welkin> is that the spam you mentioned?
13:05:50 <ddellacosta> yeah, it's been non-stop for the past day-ish
13:05:50 <johnw> yes
13:08:30 <Azure3> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
13:08:31 <obserd> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
13:08:40 <Welkin> haha
13:08:55 <Welkin> who is this guy?
13:09:41 <johnw> and who would want a crowd of irate people coming to their blog?
13:10:31 <johnw> mniip: as freenode staff, you should be @@mniip or something :)
13:12:10 <mniip> johnw, Welkin see topic in #freenode
13:16:51 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org' by ChanServ
13:18:21 <jercos22> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
13:18:21 <jercos22> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
13:18:21 <jercos22> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
13:18:38 <L0j1k0> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
13:18:38 <L0j1k0> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
13:18:38 <L0j1k0> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
13:18:46 <Welkin> is the release schedule every 6-9 months now for major versions of ghc?
13:20:48 * arkeet . o O ( const = fmap getConst . distribute . Const )
13:21:02 <c_wraith> iirc, the target is 6 months, but they're still working on processes for that.
13:26:48 <tjyoco> Hi all, I'm running into an error while following the llvm-hs kaleidoscope tutorial: https://github.com/llvm-hs/llvm-hs .. Chapter3/Codegen.hs is saying 'Expected Type: 'Data.ByteString.Short.Internal.ShortByteString' Actual Type: [Char]'  I'm having trouble finding the best way to fix this.  Can anyone help?
13:27:47 <Welkin> looks like an OverloadedStrings issue
13:28:13 <Welkin> add that pragma to your file
13:28:44 <tjyoco> That is already up there
13:29:07 <Welkin> then somewhere in your program it has been set as a String
13:29:15 <Welkin> you can manually convert it
13:36:36 * hackage preamble 0.0.64 - Yet another prelude.  http://hackage.haskell.org/package/preamble-0.0.64 (markfine)
13:44:35 <hololeap> mobattah: /msg alis list azure
13:44:50 <hololeap> sorry... fat fingers
13:51:56 <edwardk> anything anybody particularly wants me to cover in today's twitch stream?
13:58:35 <primalz021> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
13:59:25 <mniip> edwardk, any of the two things I mentioned?
13:59:29 --- mode: mniip set -o mniip
14:00:23 <edwardk> mniip i forget which they were
14:00:28 <edwardk> something something constraints
14:00:34 <edwardk> and something something else? =)
14:00:44 <dstolfa> edwardk: connection between applicatives and monads :)
14:00:52 <mniip> quantified, yes
14:00:58 <mniip> and maybe something about typechecking in general
14:01:09 <dstolfa> mniip: hindley-milner type system & inference algorithm!
14:01:18 <edwardk> dstolfa i already did that one as a talk, kinda. see the talk on 'discrimination is wrong: improving group productivity'
14:01:23 <dstolfa> that's simple enough and quite useful
14:01:34 <edwardk> type checking will probably be a future stream as i'll need more prep time
14:01:36 <edwardk> ok, starting
14:01:37 <mniip> I'm not sure if hindley-milner includes quite exactly what I'm hoping to see
14:01:38 <Gurkenglas> edwardk, that lensy way to do monad transformers
14:01:59 <dstolfa> mniip: it's a good first step in types to cover
14:02:02 <dstolfa> it's practical and easy
14:04:57 <mniip> dstolfa, if I understand correctly, HM doesn't do any constraint solving
14:04:59 <mniip> just unification
14:05:20 <dstolfa> mniip: you're right, but it's a good first step for the audience, no?
14:06:50 <Welkin> HM just sells cheap clothing
14:12:07 <Boarders> I would love one at some point on free theorems - both the mathematics and also practically how the free theorem bots work
14:15:27 <orbisvicis> does whnf arise naturally from non-strict constructors, and is lazy evaluation the only way to implement non-strictness ?
14:16:22 <JuanDaugherty> weak hindley normal form?
14:16:28 <monochrom> head
14:16:31 <JuanDaugherty> ah
14:19:53 <orbisvicis> well I guess if strictness analysis was perfect, lazy evaluation would be pointless
14:22:07 <fishythefish> orbisvicis: no, you can implement non-strictness without lazy evaluation
14:23:04 <fishythefish> not sure what it means for whnf to arise, though
14:29:24 <hololeap> does anyone know of a haskell gui library that isn't just low-level bindings to some toolkit?
14:30:09 <hpc> sdl2 is high-level bindings to some toolkit!
14:30:11 * hpc ducks
14:30:21 <Welkin> they are all written in c
14:30:22 <Welkin> so no
14:30:59 <c_wraith> hololeap, does brick count?
14:32:21 <hololeap> well, i wasn't wanting it to be terminal-based
14:33:16 <hololeap> i was hoping there might be some higher level interface to a popular gui toolkit that is more "haskell-friendly"
14:33:25 <Welkin> imgui?
14:33:43 <Welkin> I don't know if there are haskell bindings to that
14:33:46 <lavalike> gloss might also count
14:33:48 <c_wraith> as far as I know, brick is the only library that's really tried to make a windowing library that feels like haskell. it just happened to be targeting ncurses
14:33:56 <Welkin> but an immediate mode gui is very much in line with fp
14:34:06 <Welkin> lavalike: gloss is not for GUIs
14:34:12 <lavalike> Welkin: well :D
14:37:29 <hololeap> Welkin: i don't see bindings for haskell, but i appreciate you showing me that. it looks interesting
14:37:57 <geekosaur> frp is the main direction for non-low-level bindings
14:37:58 <c_wraith> hololeap, there are things like reactive-banana
14:38:04 <geekosaur> such as that
14:38:13 <c_wraith> hololeap, which has gtk and wxwindows bindings
14:38:14 <Welkin> hololeap: you can also look at webview
14:38:41 <Gurkenglas> Say I wrote foo, and wanted to write bar, and I noticed this because I noticed x with foo x /= bar x. bar has yet to be written down.
14:38:43 <c_wraith> ... and sdl and threepenny. ok, more than I thought
14:39:01 <Welkin> https://github.com/zserge/webview
14:39:31 <orbisvicis> fishythefish: oh, something like optimistic evaluation ?
14:39:44 <fishythefish> orbisvicis: right - sometimes you'll see that called "lenient evaluation" as well
14:40:20 <Gurkenglas> Could the computer build a complete evaluation tree of foo x, choose an evaluation node "y" such that ~half of the nodes lie below it, ask me whether y behaves as expected, then binary search down to find the bug?
14:41:21 <Gurkenglas> With logarithmically many queries to the user in the time spent computing
14:42:06 <Gurkenglas> (I suppose it's an evaluation DAG but it should still allow logarithmically many queries)
14:42:55 <fishythefish> orbisvicis: rereading your other question, perhaps the answer you're looking for is that lambda abstractions are also in whnf
14:43:23 <orbisvicis> as for the first part, I guess that was nonsense as strictness references the domain and whnf the evaluation. I just noticed that whnf of lazy evaluation corresponds to items that are guaranteed non-strict (and partially applied functions, I guess)
14:44:32 <Gurkenglas> (And the binary search would have to be preceded by exponential exploration in case foo x is infinite)
14:44:55 <fishythefish> whnf doesn't specify how different parts of an expression are evaluated
14:45:00 <fishythefish> just which parts (at least) are evaluated
14:45:21 <Gurkenglas> (Though I suppose you could just immediately bound the evaluation DAG of foo x at the same point where the user noticed the difference)
14:45:33 <fishythefish> an expression in normal form is still in whnf
14:47:26 <Gurkenglas> (And I suppose the exploration would be not just exponential, but as busy-beaver-like as you can make it in order to minimize expected user queries)
14:47:47 <Welkin> beavers are funny
14:48:03 <Welkin> they have an instinct to build dams out of whatever material is around
14:48:54 <Gurkenglas> (Same for the case that the evaluation node chosen from an eldritch-size evaluation tree ought to be chosen closer to the root than "half")
14:50:26 <Gurkenglas> In short, is there an interactive fault localization tool for Haskell?
14:50:51 <Welkin> eldritch? o.o
14:51:07 <Welkin> what's love(craft) got to do with it?
14:52:22 <Gurkenglas> Welkin, astronomical is like 10^80, combinatorial is like 10^(10^80), eldritch is like busy beaver/variants of that for more powerful machine models
14:52:56 <Gurkenglas> The numbers where your axioms start having trouble proving they're not infinite
14:52:58 <Welkin> I've never heard of that terminology
14:53:23 <Gurkenglas> I'm not sure whether I absorbed or improvised that
14:54:07 <weq13> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
15:00:02 --- mode: ChanServ set +o dibblego
15:00:23 --- mode: ChanServ set -o dibblego
15:27:03 <droplet> Does anyone know if there is a ghcjs starter project available? I can't seem to be able to install ghcjs at all
15:38:29 <Skaag26> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
15:38:29 <Skaag26> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
15:38:29 <Skaag26> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
15:40:37 <c_wraith> hmm. I already thought this spam had no credibility. linking to ed drops it to strongly negative credibility.
15:45:40 <nshepperd> I wonder if I should tell mst that some troll has a website impersonating him
15:46:06 * hackage emd 0.1.0.0 - Empirical Mode Decomposition (Hilbert-Huang Transform)  http://hackage.haskell.org/package/emd-0.1.0.0 (jle)
15:46:21 <nshepperd> well, i'm sure freenode staff already know
15:47:35 <duncan^> I think it is statistically unlikely they wouldn't know by now
15:48:34 <drewbert> In #freenode "Topic: We're aware of spam being sent on other networks with URLs to fake blog posts impersonating freenode staffers, please just ignore them and don't exacerbate things by distributing them further.  We are aware."
15:48:36 <geekosaur> mst also hangs out in other channels that have been hit by this bot
15:51:38 <Gurkenglas> Freenode doesn't have ready-made tools to quickly globally badword a link?
15:53:29 <nshepperd> I haven't heard of an ircd mod like that
15:54:19 <orion> Is there a more idiomatic way of writing this function?: https://gist.github.com/centromere/c1c9915e4dc4ffe09bf85d888060de54
15:55:28 <orion> (Without pattern matching on mx)
15:55:35 <nshepperd> orion: MaybeT?
15:57:44 <Solonarv> this is the super-short version: https://gist.github.com/Solonarv/a09db5374eef443ebe0958ef4c25b77f
15:58:13 <Solonarv> ...actually that may not quite be right
15:59:31 <hexagoxel> the inner `case` is a forM
15:59:58 <Solonarv> aka traverse
16:00:14 <Solonarv> :t traverse
16:00:15 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:00:16 <Solonarv> :t forM
16:00:17 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
16:00:27 <Gurkenglas> Solonarv, you're gonna need fmap join too
16:00:29 <systemfault> traverse with a flip? :/
16:00:40 <hexagoxel> yeah, Gurkenglas is correct
16:00:43 <Solonarv> :t for
16:00:44 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
16:00:48 <Solonarv> there!
16:00:50 <hexagoxel> ioStuff >>= mapM (Content x)
16:00:58 <hexagoxel> oh wait, it is pure
16:03:07 * hackage haskell-overridez 0.10.2.0 - Manage nix overrides for haskell packages  http://hackage.haskell.org/package/haskell-overridez-0.10.2.0 (adetokunbo)
16:03:47 <Gurkenglas> :t \mx -> runMaybeT $ ?content <$> maybe empty pure mx <*> MaybeT ?ioStuff
16:03:48 <lambdabot> (?ioStuff::m (Maybe a2), ?content::a1 -> a2 -> a3, Monad m) => Maybe a1 -> m (Maybe a3)
16:05:53 <orion> Thank you
16:08:19 <tigermousr0> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
16:15:04 <droplet> Has anyone here successfully installed ghcjs recently (on macOS)? Nothing I'm trying seems to work - and I'm pretty sure I've tried everything!
16:15:56 <Welkin> install with reflex-platform https://github.com/reflex-frp/reflex-platform
16:16:00 <Welkin> or just plain nix
16:17:00 <droplet> Ah, I haven't tried using nix yet, I'll have a go. Thanks!
16:28:06 * hackage antiope-core 1.0.0 -   http://hackage.haskell.org/package/antiope-core-1.0.0 (newhoggy)
16:28:54 <buhman> are there any particularly nice data validation libraries that support nested/recursive types?
16:30:10 * hackage antiope-sns 1.0.0, antiope-dynamodb 1.0.0, antiope-athena 1.0.0, antiope-sqs 1.0.0, antiope-s3 2.0.0 (newhoggy)
16:32:04 <QQQQQ> help
16:48:48 <sushichef> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
16:59:06 * hackage emd 0.1.1.0 - Empirical Mode Decomposition (Hilbert-Huang Transform)  http://hackage.haskell.org/package/emd-0.1.1.0 (jle)
17:14:45 <noipmups> Anybody willing to help with https://stackoverflow.com/questions/51529298/idiomatic-stateful-loop-in-haskell?
17:16:30 <Welkin> a stateful loop?
17:16:38 <Welkin> use recursion
17:16:43 <Welkin> or a fold
17:16:44 <Welkin> same thing
17:16:58 <Welkin> it's a functional loop
17:17:19 <laucha> hi
17:19:10 <pavonia> noipmups: Another idea is to use StateT in conjunction with forever, depending what exactly you want to do
17:28:56 <N3RGY> So I just swapped my webserver over to using Servant. I was very impressed at Servant's power/weight ratio - it lets you express a lot of complicated "business logic" very tersely. Are there any other (families of) libraries with similar goals in other areas of "business logic"? A few spring to mind, like persistent or quickcheck, but I'm curious if there are any cool ones I've not heard of
17:30:45 <Gurkenglas> noipmups, "main = fix (zipWithM ($) [runService1, runService2, runService3] >=>) [initState1, initState2, initState3]"
17:32:22 <noipmups> Gurkenglas: Thank you. This looks promising.
17:33:04 <Gurkenglas> :t \run -> fix (zipWithM ($) run >=>)
17:33:06 <lambdabot> Monad m => [a -> m a] -> [a] -> m c
17:33:31 <Gurkenglas> :t fix . (>=>) . zipWithM ($)
17:33:32 <lambdabot> Monad m => [c1 -> m c1] -> [c1] -> m c2
17:34:10 <ben_zen13> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
17:34:22 <chreekat> ^ how long has that been going on?
17:34:29 <geekosaur> all day
17:34:32 <Welkin> all day kitkat
17:34:41 <chreekat> good times
17:39:08 <hololeap> noipmups: here's another way to do it, using the moand-loops package: http://dpaste.com/3N8HCKD
17:40:03 <Solonarv> ah, now that's cleaner
17:40:06 <hololeap> *monad-loops
17:40:17 <Gurkenglas> iterateM_ is just fix . (>=>)
17:40:26 <noipmups> hololeap: Thank you, I'll take a look.
17:40:36 * hackage natural 0.1.0.0 - Natural number  http://hackage.haskell.org/package/natural-0.1.0.0 (qfpl)
17:40:59 <N3RGY> That spam link is absolutely whack - false flag against Kloeri?
17:41:45 <hololeap> Gurkenglas: that's an interesting point
17:42:21 <Solonarv> sure, but it's useful to have well-named aliases
17:43:54 <Gurkenglas> Oh wait, dangit! noipmups, my solution only works if State1 = State2 = State3
17:46:53 <Gurkenglas> newtype Service = Service { runService :: exists s. (s, s -> (IO (), s)) }
17:47:34 <Gurkenglas> newtype Service = Service { runService :: exists s. (s, s -> IO s) } actually
17:50:55 <Gurkenglas> loop :: [Service] -> IO (); loop = fix . (>=>) $ traverse $ \(Service (s, f)) -> fmap (Service . (,f)) $ f s
17:52:17 <geekosaur> I'm not sure any of these are any better than the straightforward and readable one, tbh
17:52:35 <Gurkenglas> it's a work in progress
17:53:20 <niek0> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
17:53:20 <niek0> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
17:53:20 <niek0> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
17:53:29 <October> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
17:53:29 <October> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
17:53:29 <October> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
17:54:00 <Gurkenglas> noipmups, maybe you don't care for the lockstep and want "forkIO (fix (runService1 >=>) initState1)"?
17:54:19 <Welkin> Gurkenglas likes to try being too clever
17:54:23 <Welkin> that rarely ends well
17:55:18 <Gurkenglas> Hey, I thought you guys might be interested in this line that makes you think I'm one of them https://gottaputinfiller.com/
18:01:21 <Gurkenglas> newtype Service = Service { runService :: IO Service }
18:01:48 <Gurkenglas> loop :: [Service] -> IO (); loop = fix (traverse runService >=>)
18:04:24 <shapr> any feedback? https://github.com/shapr/usehaskellfromc
18:06:02 <Gurkenglas> service :: (s -> IO s) -> s -> Service; service f = Service . fmap (service f) . f -- writable in terms of hylo
18:08:50 <Neo3> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
18:09:57 <Gurkenglas> noipmups, using data-fix and monad-loops, main = iterateM_ (traverse unFix) [ana runService1 initState1, ana runService2 initState2, ana runService3 initState3]
18:11:31 <cim-mbp> what is the point of haskell?
18:11:58 <Gurkenglas> cim-mbp, let mathematicians speak math to a computer
18:12:32 <cim-mbp> Gurkenglas: so it's not something for conventional use?
18:12:56 <Gurkenglas> cim-mbp, mathematicians can also use it to tell a computer to do conventional stuff
18:13:08 <shapr> cim-mbp: I think the point is really awesome abstractions
18:13:08 <Welkin> it is a general purpose programming language
18:13:16 <Welkin> I mostly use it to build web applications
18:13:26 <cim-mbp> is it OOP?
18:13:52 <shapr> I use Haskell to write shell scripts, or analyze wireshark output, or build websites, or rewrite my girlfriend's GNU R code, or ...
18:13:52 <Welkin> if you want it to be
18:13:54 <Gurkenglas> You can do OOP with it if you really want to, but that's usually not the most elegant way to say what to do using math
18:14:22 <cim-mbp> interesting
18:14:26 <cim-mbp> it's like an all in one language
18:14:44 <Solonarv> that describes most commonly-used programming languages, tbh
18:14:45 <cim-mbp> a swiss knife of sorts
18:14:58 <Welkin> shapr also uses it as a gameshark for his gameboy
18:15:38 <Welkin> it is commonly used to write compilers
18:15:53 <jackdk> I use it to build backend web services, and to compile libraries to js that would be impractical to write in a less-disciplined language. I also use it to teach people programming
18:16:08 <adjofun> Hi everyone! Is notation `Hom(A, B)` equivalent to notation `B^A`?
18:16:14 <hololeap> i use it to compile haskell code (the haskell compiler is written in haskell)
18:16:16 <Gurkenglas> If all goes well, choose a language from who you are, not what you want to do
18:16:37 <Solonarv> I'm using it to write a game
18:16:48 <Solonarv> (well, when I don't drop it for months at a time)
18:17:07 <cim-mbp> i'm a web dev so you know the basics php, js, html, css, etc.
18:17:33 <hololeap> check out yesod
18:17:36 <Welkin> no
18:17:39 <Welkin> avoid yesod
18:17:39 <Welkin> lol
18:17:46 <Welkin> look at scotty
18:17:50 * cim-mbp googles anyways
18:17:53 <shapr> cim-mbp: have you used flask in Python? that's scotty / spock
18:18:03 <shapr> oh, I can show you code I've written to do that:
18:18:16 <cim-mbp> nope
18:18:18 <shapr> cim-mbp: https://github.com/shapr/sporkle/blob/master/app/Main.hs
18:18:21 <cim-mbp> i don't use python
18:18:38 <shapr> fair enough, the python/flask approach is to match on the HTTP method and the url together.
18:18:46 <Welkin> it is a simple http server library
18:18:54 <cim-mbp> you guys don't use brackets or ;
18:18:58 <shapr> so here's "GET /exercise" https://github.com/shapr/sporkle/blob/master/app/Main.hs#L68
18:19:03 <geekosaur> we can, we just don't
18:19:09 <shapr> and here's "POST /exercise" https://github.com/shapr/sporkle/blob/master/app/Main.hs#L89
18:19:14 <geekosaur> (most of us. one of the core ghc devs always uses them)
18:19:28 <cim-mbp> isn't that dangerous?
18:19:35 <shapr> cim-mbp: how so?
18:19:44 <cim-mbp> the code will continue to run? idk
18:20:12 <shapr> oh, this gets compiled in with a really fast web server
18:20:15 <shapr> so it is always running.
18:20:16 <Gurkenglas> The compiler knows when leaving out the brackets wouldnt work and tells us so before it ever tries to run it
18:20:23 <shapr> oh, that
18:20:40 <cim-mbp> code remins me of js
18:21:16 <Gurkenglas> We leave out the brackets when we can because it's not always possible, and that it's possible is a sign we're using the right approach
18:21:43 <cim-mbp> reminds me of react
18:21:55 <Gurkenglas> Compare to a cook's white clothing, on which all stains would be visible
18:22:35 <shapr> cim-mbp: I've heard react is functional, so I'd believe it?
18:23:39 <Welkin> no, react is still quite oop, like javascript
18:23:58 <cim-mbp> i prefer jquery to be honest
18:39:07 * hackage reactive-banana-gi-gtk 0.4.0.0 - Simple reactive programming with GTK GObject Introspection  http://hackage.haskell.org/package/reactive-banana-gi-gtk-0.4.0.0 (miscyb)
18:39:39 <cim-mbp> hmm
18:39:49 <cim-mbp> i'm surprised this channel hasn't gotten spammed by this bot yet
18:40:11 <dmwit> It has.
18:40:19 <cim-mbp> was it the pedo links?
18:41:14 <dmwit> Let's not talk about it. It's better that way.
18:42:55 <cim-mbp> you're right
18:43:50 <cim-mbp> so when an agency (web, marketing, media, etc) that's been around for 6 years suddenly vanishes out of fat air, wha're your thoughts?
18:44:55 <dmwit> Let's focus on Haskell.
18:46:57 <laucha> hi everyone, i have some questions
18:47:01 <laucha> i'm new to this
18:47:06 * hackage reactive-banana-gi-gtk 0.4.0.1 - Simple reactive programming with GTK GObject Introspection  http://hackage.haskell.org/package/reactive-banana-gi-gtk-0.4.0.1 (miscyb)
18:48:10 <laucha> why does this not work?
18:48:27 <laucha> function = (==0).rem
18:49:18 <dmwit> Because you want that to mean `\x y -> 0 == rem x y`, but it actually means `\x y -> (0 == rem x) y`.
18:49:39 <dmwit> ?src (.)
18:49:39 <lambdabot> (f . g) x = f (g x)
18:49:57 <dmwit> So `(==0) . rem` is `\x -> (== 0) (rem x)`.
18:50:05 <dmwit> rem didn't get enough arguments!
18:51:17 <Solonarv> @pl \x y -> 0 == rem x y
18:51:17 <lambdabot> ((0 ==) .) . rem
18:52:15 <laucha> so what would be correct?
18:52:28 <dmwit> How about `\x y -> 0 == rem x y`?
18:52:38 <dmwit> I highly recommend it.
18:52:48 <dmwit> It's simple, clear, and hard to get wrong.
18:52:49 <laucha> oh sorry
18:53:11 <hololeap> `\x y -> 0 == rem x y`, `\x -> (0 ==) . rem x`, or `((0 ==) .) . rem`
18:53:19 <hololeap> the first is most readable
18:53:43 <jimbeamm> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
18:53:43 <jimbeamm> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
18:53:43 <jimbeamm> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
18:55:24 <pavonia> :t ((.) . (.)) (== 0) rem
18:55:25 <lambdabot> Integral b => b -> b -> Bool
18:56:07 * hackage ftp-client 0.5.0.1 - Transfer files with FTP and FTPS  http://hackage.haskell.org/package/ftp-client-0.5.0.1 (miscyb)
18:56:37 * hackage ftp-client-conduit 0.5.0.2 - Transfer file with FTP and FTPS with Conduit  http://hackage.haskell.org/package/ftp-client-conduit-0.5.0.2 (miscyb)
18:58:14 <laucha> i'm doing an online programming course and it's very badly explained
18:59:18 <laucha> ((0 ==) .) . rem worked, since it asked me to use composition and partial application
19:00:05 <c_wraith> sections using (.) are awkward to pick up. don't worry too much about why that works.
19:00:22 <c_wraith> focus on why your previous attempt didn't
19:00:48 <jelly25> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
19:02:56 <laucha> all the examples of composition were like this 'function1 = function2.function3
19:03:49 <shapr> aw, cim left
19:03:58 <laucha> and all it said was function1 takes as parameters whatever function3 does and returns whatever function2 does
19:04:31 <c_wraith> laucha, I think what's tripping you up is that in a very real sense, functions in Haskell take only one argument.
19:05:30 <c_wraith> whenever someone discusses a function as having more than one argument, it's a kind of shorthand notation. it's a little inaccurate, but it's a polite fiction to make discussion faster.
19:06:06 <c_wraith> laucha, so.. rem is a function that takes one argument, not two.
19:06:35 <Solonarv> so (rem x y) is actually ((rem x) y), for example
19:08:59 <c_wraith> laucha, so when you write '(== 0) . rem' there is no logic that says "rem is a two argument function, so take two arguments before passing the result along"
19:10:15 <c_wraith> laucha, at a technical level, there are no two-argument functions. so rem is a one-argument function. and that one-argument function is what's being composed with (==0)
19:11:25 <laucha> i should read more about that
19:11:47 <c_wraith> laucha, I would say this is an area where the most common ways of describing things in Haskell have misled you. it's not a mistake you made all by yourself. you were tricked! :)
19:11:58 <laucha> i believe this course is really barebones
19:12:31 <c_wraith> which course is it?
19:13:08 <laucha> it's something from my country
19:13:20 <laucha> my province to be precise
19:13:33 <c_wraith> laucha, keywords for related topics: "currying" and "partial application"
19:13:47 <c_wraith> to help you dig up more to read about it.
19:14:05 <laucha> thank you
19:17:23 <laucha> in this one they asked for a function that doubles the sum of 2 values modified by another function
19:17:37 <laucha> i dont even know if i wrote that right
19:18:04 <laucha> it would be ( f(x) + f(y) )*2
19:18:20 <c_wraith> that English is a good description of your equation
19:19:29 <laucha> i wrote 'function a b f = (f a + f b)*2 and it says it works but they want composition in there
19:19:32 <c_wraith> err. expression. no = in it, can't be an equation. :)
19:20:06 <laucha> how would i do that?
19:20:08 <c_wraith> fire the course author. in no way does writing that with composition make it better or teach you anything useful
19:20:21 <Solonarv> agreed
19:20:26 <laucha> i have been thinking that for a while
19:20:41 <Solonarv> though, for amusement:
19:20:52 <Solonarv> @pl \a b -> (f a + f b) * 2
19:20:52 <lambdabot> flip flip 2 . ((*) .) . (. f) . (+) . f
19:21:10 <laucha> i did the java part really easy but this is totally new to me and they are doing an awful job at teaching
19:21:11 <c_wraith> Solonarv, you should have f as an argument too
19:21:17 <Solonarv> @pl \f a b -> (f a + f b) * 2
19:21:17 <lambdabot> flip flip 2 . ((flip . ((*) .)) .) . (flip =<< (((.) . (+)) .))
19:21:23 <Solonarv> what have I DONE
19:21:34 <c_wraith> yeah. see how that is not good for anything?
19:21:48 <laucha> hahahah what the hell is that
19:22:53 <laucha> also i have no idea what @pl and \a b -> mean
19:23:31 <c_wraith> \args -> expression is anonymous function syntax
19:24:04 <Solonarv> "function args = blah" means the same thing as "function = \args -> blah"
19:24:15 <c_wraith> > (\x y -> x * 2 + y *3) 4 5
19:24:17 <lambdabot>  23
19:24:37 <c_wraith> it just is a way to define a function without giving it a name
19:24:41 <Solonarv> and "@pl" is a command for lambdabot which basically makes it do your assignment
19:25:04 <Solonarv> i.e. "rewrite this function to use composition etc. instead of explicitly handling arguments"
19:25:48 <laucha> i feel like they should have told me about that earlier
19:26:03 <Gurkenglas> @pl \f a b -> 2 * (f a + f b) -- a bit more palatable
19:26:03 <lambdabot> (((2 *) .) .) . (flip =<< (((.) . (+)) .))
19:26:55 <Solonarv> oh, yeah; lambdabot doesn't know (*) is commutative
19:26:57 <dmwit> ?pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> g u r k e n g l a s
19:27:17 <Solonarv> uh oh...
19:27:25 <c_wraith> dmwit, I think you broke it.
19:27:28 <dmwit> I blame everybody but me.
19:27:39 <dmwit> ?botsnack
19:27:45 <lambdabot> const . const . const . ((const . ((const . const . const . (((const . ((const . const . const . ((((const . ((const . const . const . const . const) .)) .) . flip) .)) .)) .) .)) .)) .) . flip (
19:27:45 <lambdabot> flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .)) .)) .) . join . ((flip . ((flip . ((flip . (flip .)) .) . flip . (flip .)) .)) .) . flip (flip . ((flip . (
19:27:45 <lambdabot> :)
19:27:50 <dmwit> phew
19:28:09 <c_wraith> did you know @pl can go exponential?
19:28:17 <c_wraith> now you do!
19:28:19 <dmwit> Isn't there an iteration limit, though?
19:28:31 <jrabe4> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
19:28:33 <dmwit> I feel confident I've seen "optimization suspended" as a response before.
19:28:43 <c_wraith> probably, but it's not running on a host with a ton of free cpu
19:29:02 <c_wraith> so it can take a while to hit the limit
19:31:10 <laucha> it seems like i can skip through the course any way i like
19:49:53 <siraben> What is the use of a co-yoneda?
19:50:22 <siraben> If the Yoneda lemma can be specialized to CPS, what about the opposite category?
19:54:54 <c_wraith> Coyoneda is mostly a practical tool. you can use it to create a Functor instance for anything
19:54:55 <Tycale21> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
19:55:48 <c_wraith> and sometimes that Functor is even useful. :)
19:56:20 <siraben> c_wraith: But only if the functor is representable?
20:00:14 <dmwit> No, there is no restriction (other than kind). Any type of the appropriate kind can be made a Functor.
20:00:39 <siraben> So, how could I apply the Stream Functor?
20:00:45 <siraben> Which happens to be representable
20:01:01 <siraben> (side note: is it contravariant or covariant?)
20:02:57 <dmwit> What does "apply" mean?
20:03:19 <siraben> I mean use the Yoneda with the Stream functor
20:04:10 <dmwit> Presumably Stream is already a Functor, and so it's not super useful to use Yoneda on it.
20:04:26 <dmwit> But... the way you would do it is just `Yoneda Stream`.
20:04:28 <siraben> So what can be made a functor?
20:04:37 <siraben> With the yoneda lemma
20:04:45 <geekosaur> anything with kind * -> *. note that this does not mean it's necessarily useful
20:04:53 <siraben> Integer -> Integer ?
20:04:59 <siraben> As an example
20:05:01 <geekosaur> kind level, not type
20:05:06 <geekosaur> :k Maybe
20:05:07 <lambdabot> * -> *
20:05:09 <dmwit> siraben: For example, consider `newtype FlippedArrow a b = FlippedArrow (b -> a)`.
20:05:15 <siraben> :k Either
20:05:15 <geekosaur> but Maybe is already a Functor, so
20:05:16 <lambdabot> * -> * -> *
20:05:29 <siraben> :k State
20:05:30 <lambdabot> * -> * -> *
20:05:41 <dmwit> siraben: This is a contravariant functor, not a covariant on. But `Yoneda (FlippedArrow a)` is a covariant Functor.
20:05:47 <dmwit> Is it useful? Probably not.
20:07:02 <siraben> So a covariant functor maps A -> B to F a -> F b?
20:07:17 <siraben> And contravariant A -> B to F b -> F a
20:07:59 <dmwit> Right.
20:08:31 <dmwit> :t fmap
20:08:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:08:33 <dmwit> :t contramap
20:08:35 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
20:09:11 <siraben> So fmap takes a functor and a function, right?
20:09:22 <siraben> And to use fmap we need an instance of Functor?
20:10:59 <dmwit> Up to terminology quibbles, yes, I think you have the right idea.
20:11:38 <dmwit> (Specifically, I wouldn't call a value of type `f a` a "functor", even if `f` is an instance of `Functor`.)
20:12:13 <dmwit> (And I don't think there's a common name for values of such a type.)
20:16:18 <shachaf> Especially if you consider "type Id a = a" to be a functor.
20:16:39 <shachaf> (Just about anything is in the image of *some* functor, even if you can't express that with the usual Haskell class.)
20:39:06 * hackage asif 1.0.0 -   http://hackage.haskell.org/package/asif-1.0.0 (newhoggy)
20:43:24 <nullcone> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
20:43:24 <nullcone> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
20:43:24 <nullcone> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
20:43:25 <liste22> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
20:43:25 <liste22> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
20:43:25 <liste22> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
20:53:54 <Gurkenglas> https://github.com/wireapp/wire-server/pull/417 wants me to sign with my real name, postal address and telephone number. Is there a way for me to stay pseudonymous?
20:54:49 <c_wraith> not in any way that satisfies their legal worry
20:57:26 <Gurkenglas> Is there some way that gurantees privacy of that information?
20:58:05 <c_wraith> possibly.  you'd have to contact them directly to ask.  I'd hope they'd allow it, but they might need to create a procedure for it.
21:00:38 <Gurkenglas> I suppose I'll just comment that on that PR and see what they do. This sort of testing of waters is socially agreeable, right?
21:00:47 <c_wraith> yes
21:01:38 <c_wraith> I understand why they want a CLA, there are real jerks out there would would, in fact, sue them over code they added.  But I think it's totally reasonable that you'd like your personal information kept private.
21:05:36 * hackage http-date 0.0.8 - HTTP Date parser/formatter  http://hackage.haskell.org/package/http-date-0.0.8 (KazuYamamoto)
21:06:37 <pally> `Maybe Int` is a type, and since the Type constructor is the Maybe monad, can I call a "monadic type"?
21:08:11 <pally> there are references of both "monadic type" and "monad type"
21:08:16 <pally> online
21:13:07 * hackage aeson-quick 0.1.2.1 - Quick JSON extractions with Aeson  http://hackage.haskell.org/package/aeson-quick-0.1.2.1 (ssadler)
21:17:17 <Gurkenglas> pally, I usually understand monadic to be that property of an identifier which causes you to put an M at the end
21:18:06 <Gurkenglas> For example these http://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
21:18:10 <geekosaur> so how you explain mfilter? :p
21:22:12 <Gurkenglas> geekosaur, I would call mfilter monadic and argue that my heuristic identifies a concept without technically being equivalent to it
21:22:57 <Gurkenglas> which distinction was technically not omitted, as I said "usually"
21:28:07 <pie_> any recommendations for which inotify library to use?
21:29:23 <pie_> oh hm this looks helpful http://hackage.haskell.org/package/fsnotify
21:46:28 <pie_> is there any reason to pick one of these over the other? http://hackage.haskell.org/package/plugins-1.5.7 http://hackage.haskell.org/package/hint
21:47:48 <dminuoso> pie_: They are different things?
21:48:29 <geekosaur> you can manage plugins with hint, it's more work though
21:49:07 <geekosaur> hint is more general, and you might find that what pit provides is actually preferable to dynamically loaded haskell plugins
21:49:11 <geekosaur> *it provides
21:49:38 <pie_> my goal at the moment is to use fnotify to reload shaders for gpipe at runtime
21:50:47 <pie_> this is an example but it doesnt actually compile yet for some reason (probably types not restricted properly...) https://bpaste.net/show/88576613c2c0
21:51:22 <pie_> this is the caller code https://bpaste.net/show/7707f91ae989
21:51:31 <pie_> (hint will probaly be fine im guessing)
21:53:43 <pikajude> does there exist an automated tool for inserting an "import" statement into an hs file for a given identifier
21:53:59 <pikajude> one that preferably could search the package db for the right package that contains it and import the correct module
21:54:13 <pie_> pikajude, i dont know but sounds like a helpful ide feature
21:54:28 <pie_> i.e. if you can make it user triggered
21:54:43 <pie_> the few times i used java the ide had something like that
21:54:46 <pikajude> i'd like it to be an IDE feature since it is in things like intellij
21:54:48 <pikajude> right
21:54:51 <pikajude> java tooling is amazing
21:54:56 <pikajude> and managing imports in vim is incredibly frustrating
21:55:13 <pikajude> before i knew about hindent, I had to arrange them all manually too :/
21:55:38 <pie_> just to be a bit snarky ;p i guess the tooling does have to be good to generate so much boilerplate ;D
21:56:04 <pikajude> i've previously been surprised by what does actually exist in terms of haskell tooling
21:56:04 * pie_ looks at his page long imports list
21:56:09 <pikajude> but almost all of it is for emacs
21:56:11 <pikajude> which i don't know how to use
21:56:15 <pie_> aw
21:56:23 <pie_> ive kind of resigned myself to not using tooling till i learn emacs
21:56:37 <pie_> (havent started yet) :p
21:56:45 <pikajude> there's a better way...
21:57:06 <pikajude> a long time ago i had a vim plugin that would do identifier autocomplete even for modules which weren't in scope
21:57:09 <pikajude> so it has to be possible
21:57:38 <pie_> you can probably use hoogle somehow
21:58:30 <clever> programmer4: i use you-complete-me, with absolutely none of it configured properly
21:58:41 <clever> pikajude: oops, wrong tab-complete
21:59:02 <clever> 80% of the time, it just auto-completes any "word" in any currently open file, so it doesnt have to be in-scope
21:59:55 <pikajude> yeah
21:59:57 <pikajude> i already have that set up, lol
22:00:08 <pikajude> but i also want to insert the import
22:00:10 <pikajude> :/
22:05:45 <pally> class Monad f =>  ASubclass f where
22:05:46 <pally> ...
22:05:54 <renzhi> is there a way to set ghc-options globally so that it applies to all projects, instead of having to set it in project-specific stack.yaml?
22:06:07 <pally> is the `f` necessary?
22:06:11 <dminuoso> renzhi: I dont think that'd be a good idea.
22:06:15 <dminuoso> pally: Check this out
22:06:17 <dminuoso> :k Monad
22:06:19 <lambdabot> (* -> *) -> Constraint
22:07:24 <renzhi> dminuoso: I'd like to have "-Wall" to all projects by default
22:07:32 <dminuoso> renzhi: Then set it like that in your template?
22:07:47 <geekosaur> pally, think of it this way7: if it's mentioned, it can be used. if it's not, it can't be. in this case, well, you need the type to do anything useful, so f is required
22:08:12 <renzhi> dminuoso: yeah, that's about the only thing I can think of too. thnx
22:08:56 <geekosaur> and this is a constraint, it doesn't work like partial application
22:09:03 <dminuoso> renzhi: Id be surprised if that was possible at all. I mean it would promote settings "it compiles on my box"
22:09:19 <jackdk> pally: note also that it generalises to multiple parameters (with extensions), so I can write something like `class Resource requestType resultType where { request :: requestType -> IO resultType }`
22:11:48 <dataN> JOBS IN HASKELL?
22:13:29 <pally> geekosaur, jackdk, just to be clear, 'f' is a concrete type right?  (e.g. Int, Char, what have you)
22:13:42 <dminuoso> pally: Not necessarily/
22:13:45 <dminuoso> pally: In case of Monad it's actually not.
22:14:00 <dminuoso> % :i Monad
22:14:00 <yahb> dminuoso: class Applicative m => Monad (m :: * -> *) where; (>>=) :: m a -> (a -> m b) -> m b; (>>) :: m a -> m b -> m b; return :: a -> m a; fail :: String -> m a; {-# MINIMAL (>>=) #-}; -- Defined in `GHC.Base'; instance [safe] (Monoid w, Monad m) => Monad (WriterT w m) -- Defined in `Control.Monad.Trans.Writer.Lazy'; instance [safe] Monad m => Monad (StateT s m) -- Defined in `Control.Monad.Trans.St
22:14:09 <dminuoso> class Applicative m => Monad (m :: * -> *) where; ...
22:14:11 <dminuoso> Do you see this?
22:14:34 <geekosaur> in general, typeclasses re when you want implementation to be per instance, where an instance is associated with a type; here "f" is that type
22:14:55 <geekosaur> (or a set of types, for multiparameter typeclasses)
22:15:04 <geekosaur> *are for when
22:18:08 <jackdk> so to be specific even the types that are instances of `Functor` are not concrete, that's what the kind `* -> *` means: "The type constructor `f` has to accept one concrete type and return a concrete type"
22:18:41 <glguy> "concrete" doesn't really mean anything specific, people use it for many different things
22:19:04 <jackdk> true. here I use it to mean "types of kind `*`"
22:19:06 <glguy> It's better to be more specific about what you're trying to say like if you're refering the type's kind or to its lack of variables or something else
22:19:25 <glguy> f isn't a type constructor, it's a type variable
22:19:54 <jackdk> also true.
22:20:08 <dminuoso> glguy: When you say "referring to the type's kind" do you mean to also squint really hard and pretend levity doesn't exist?
22:20:32 <dminuoso> I really dislike the spot where we have to kind of lie to avoid confusing beginners..
22:20:52 <glguy> dminuoso: I'm not sure what you're getting at
22:22:00 <dataN> dminuoso: thats a bad idea.
22:23:32 <rotaerk> hmm just now learning type families, and one thing I don't understand is ... if an associated family is allowed to be indexed by a subset of the type arguments of the type class, doesn't that mean that a given index may exist in multiple class instances, each with different definitions?
22:23:32 <geekosaur> there are rules about that, a type instance will be rejected if they don't have the same definition
22:23:32 <rotaerk> ah
22:23:51 <rotaerk> that sounds a little messy
22:24:21 <rotaerk> tying multiple instances together like that
22:24:52 <exio4> dminuoso: there are lies, and confusing statements
22:25:35 <exio4> dminuoso: when you're trying to teach something, you often have 'lies' which are said to be 'something different'/'more complex'/etc in the fine print
22:25:35 <dataN> yeah, like the burritos...
22:25:41 <exio4> well, not like burritos
22:26:04 <pally> Okay, I think I get the pattern.
22:26:07 <exio4> but e.g. if you're teaching FP, from scratch, you might at first avoid introducing pattern matching and use () for passing arguments
22:26:26 <pally> since I want to make a subclass of Monad, then the said subclass too have to follow the parent's signature?
22:26:42 <exio4> which are very unidiomatic patterns, sure - but the guy starting to grasp recursive algorithms will not finish grasping them if he has to understand 40 concepts at once
22:27:04 <geekosaur> "lies to children" are a thing. and not always just to chiildren. (quick,. why's the sky blue?)
22:27:08 <exio4> I'm not following on the argument - but just taking from the last sentence
22:27:09 <dataN> as in, why is the first statement about monads that they have common unhelpful statements about them...
22:27:27 <exio4> geekosaur: because something to do with the atmosphere? :P
22:27:57 <rotaerk> I'll never actually have kids, but if I did, and they asked me something like that, I'd be like
22:28:00 <rotaerk> "google it"
22:28:35 <geekosaur> the first statement about monads should be that they have >>= and return that are related in a certain way. if you mention category theory, you're doing ti wrong
22:28:56 <cloe23> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
22:29:10 <dataN> even that isnt as good as defining those things.
22:29:13 <rotaerk> IMO don't even talk about monads until they understand a few particular monads
22:29:28 <rotaerk> and then introduce monads as a generalization of the things they know
22:29:32 <dataN> why?
22:29:44 <dataN> they are not difficult to understand.
22:29:46 <exio4> dataN: humans are good at learning patterns
22:29:48 <dataN> :t concat
22:29:48 <lambdabot> Foldable t => t [a] -> [a]
22:30:02 <exio4> ... if they're familiar with them
22:30:02 <rotaerk> because abstractions are best understood through exposure to concrete examples, and then intuiting the common pattern
22:30:22 <rotaerk> rigorous definition just takes the intuition and helps solidify it
22:30:22 <dataN> m (m a) -> m a is way easyer to understand than any actual monad instance
22:31:10 <dataN> it kind of hides bind behind join, but thats the easiest introduction.
22:31:18 <rotaerk> yes, join is one way to demonstrate the concept, but you really should show it in terms of concrete examples first
22:31:27 <tdammers> indeed
22:31:47 <tdammers> m (m a) -> m a -- is fine and dandy, but the big question is going to be, why the F** would I need this?
22:31:56 <dataN> so use reader and cont! thats a great way to deter people.
22:32:00 <tdammers> what kind of thing is m, even?
22:32:07 <exio4> learning examples first also help on the intuition of using it, when, where
22:32:12 <exio4> why? etc
22:33:02 <tdammers> one thing that I think leads to a lot of confusion is trying to grasp Monad via IO
22:33:37 <tdammers> when IO is the only Monad you know, it gets difficult separating IO's Monadic structure from the rest of the things that are somewhat special about it
22:33:40 <rotaerk> I don't really like people referring to IO as "the IO monad"
22:33:56 <glguy> Probably because they see other people doing it
22:34:15 <tdammers> well, yeah - I mean, it's a Monad, and it's IO, so it's not technically wrong
22:34:42 <tdammers> but it does support the incorrect assumption that IO can do what it does because it's a Monad, when really IO can do what it does because it's IO
22:34:53 <rotaerk> like, non-haskell people who think they have a clue about how haskell works ... give this hand-wavey "haskell is pure, and it does side-effects through the magic of monads"
22:35:42 <rotaerk> no... it does it through binding a top-level "main" to an IO action... monads just help you to construct non-trivial actions
22:35:58 <jackdk> I have had some success describing the IO type to OO-folk as "what the command pattern wishes it could be"
22:36:02 <tdammers> not even that, actually
22:36:22 <tdammers> Monad is just a common pattern, an interface, to things that follow a common structure, and IO happens to be one of those things
22:36:51 <rotaerk> yeah I worded that poorly
22:36:59 <dataN> tdammers: thats a good way to proceed, by something thats not flippant or convoluted or relying on the ability to build intuition over several examples when it might be the make or break for someone learning the language. if they get the impression its difficult, they are more inclined to give up. much better to give the satisfaction associated with a comprehensible statement such as "if there is a way to concatenate nested containers,
22:37:39 <dataN> or something like "foldable monoids are monads, for example"...
22:38:05 <rotaerk> "concatenate nested containers" isn't a good representation of join though, only certain implementations of it
22:38:23 <tdammers> another problem with teaching / learning about Monad is that people jump from "OK, so I understand function application" to "what's an Monad"
22:38:46 <tdammers> rather than going types -> typeclasses -> Monoid -> Functor -> Applicative -> Monad
22:38:46 <justyns27> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
22:39:40 <tdammers> Monoid is kind of optional there, but it's such a fundamental and easy to understand concept, yet helps form an intuition about typeclasses in general, that I think it should be introduced first anyway
22:39:50 <rotaerk> I'm trying to get a friend of mine to let me teach him haskell
22:39:50 <tdammers> (or Semigroup and Monoid, oh well)
22:40:00 <dataN> "collect the elements from nested containers into one container"... but yeah its a container centric intuition, but thats better than burritos or "its too difficult to understand, stick with python"
22:40:06 <rotaerk> and I figure I'll start with hello world, do-syntax, and IO
22:40:19 <rotaerk> without actually explaining monad stuff under the hood until later
22:40:44 <rotaerk> he doesn't know programming at all
22:40:50 <tdammers> so what I'd do essentially is take each of these typeclasses and present the motivation in the form of concrete examples
22:40:59 <dataN> foldable replacing for loops is a pretty good intro, and the recursive definition of multiply
22:41:17 <tdammers> for Monoid, you can look at, say, string concatenation, numbers over addition, numbers over multiplication, etc.
22:41:28 <rotaerk> and once he's got hello world down, I'll teach him monad-fix
22:41:31 <rotaerk> *cough* not really
22:41:49 <tdammers> and then you go, OK, what's the common pattern there, can we generalize that
22:42:18 <tdammers> and of course the generalization is that you have a type with an associated binary operator and a neutral element: Monoid m where { mappend, mempty }
22:43:09 <dataN> anyway, the community gets stuck at the point of "how to introduce a beginer" and then strait to "how to confuse an expert" as if the learning curve was some kind of distorting vortex
22:43:59 <tdammers> dataN: part of it, I think, is because even many intermediate concepts are still quite new, and awfully close to the moving target of ongoing R&D
22:44:04 <dataN> some kind of artefact of a "research language"
22:44:45 <tdammers> like, right now Haskell is slowly approaching dependent types, and that has all sorts of consequences for the existing language
22:44:45 <geekosaur> well, there's also that beginners pop in here and run straight into someone asking how ekmett's klatest lib works >.>
22:45:04 <dataN> the point is to delay the point of despair until *after* they can use it at work.
22:45:06 <tdammers> and while the "old" explanations mostly still hold in principle, not mentioning the newer features that generalize them feels kind of dishonest
22:45:43 <tdammers> e.g., the "OK so we have values, types, and kinds" thing is, in principle, still a useful intuition, but there are plenty of people in the community who already consider the distinction obsolete
22:45:48 <dataN> tdammers: the dependant types stuff is old oleg stuff..
22:45:55 <rotaerk> delay the despair until they're too far down the rabbit hole to turn back
22:46:29 <tdammers> we also tend to forget how bloody damn awesome "straight up Haskell 2010" is already
22:46:49 <jackdk> the hedonic treadmill meets FP R&D
22:46:53 <pie_> uh geekosaur i might have a problem. http://hackage.haskell.org/package/hint-0.8.0/docs/Language-Haskell-Interpreter.html says for loadModules "The rule of thumb is: never make the interpreter run on the directory with the source code of your program! If you want your interpreted code to use some type that is defined in your program, then put the defining module on a library and make your program depend on that package."
22:46:56 <tdammers> just because GHC Haskell in its current and future forms is even more awesome
22:47:23 <nshepperd> sorry, I can't hear you over the sound of my 18 ghc extension pragmas
22:47:36 <dataN> rotaerk: this kind of leads to an ecosystem that relies on developers trapped in a wormhole. its not healthy.
22:47:43 <rotaerk> I know, I'm kidding
22:49:05 <rotaerk> but haskell is really deceptively simple
22:49:05 <pie_> pffff /me chokes on his own spit :p
22:49:05 <tdammers> 18? Pfff, amateur...
22:49:05 <rotaerk> it's just so powerful for such a simple language
22:49:21 <tdammers> it's also amazing that the compiler is pretty damn complex for such a simple language
22:49:21 <geekosaur> pie_, that's going to be true anyway. the problem is that you end up with two copies of your program running in that case, one compiled and one interpreted; there are ways to pull it off when it's all jumbled together, but very easy to get it wrong.
22:49:57 <rotaerk> the bulk of the complexity ends up in the stuff built on top of the language, not the language itself
22:50:21 <pie_> geekosaur, ugh. idk this seems pretty scary, wat do? :/
22:50:23 <rotaerk> as opposed to C++ which is a monstrosity without even looking at the libraries
22:50:28 <geekosaur> plugins has the same restriction, phrased differently: you are not loading part of your program, you are loading a shared object representing a different package which uses your types
22:51:45 <pie_> geekosaur, i mean is the issue here that it will try to have two GPipes since its imported in both Main.hs and Shader.hs?
22:52:08 <pie_> i kind of understand the problem but im not sure where it leaves me.
22:53:07 <nshepperd> so I recently had the opportunity to use UndecidableSuperclasses, and had a weird issue where the compiler recommended me to use IncoherentInstances at a certain use site
22:53:29 <geekosaur> it just means you build your project as a main program, a library providing the shared interface, subpackages with the plugins that depend on the shared interface.
22:53:29 <nshepperd> i couldn't really make sense of the problem
22:53:35 <dodobrain4> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
22:53:37 <dodobrain4> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
22:53:37 <dodobrain4> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
22:53:54 <nshepperd> so I ended up just working around it by writing my constraint differently
22:54:39 <pie_> geekosaur, so i would have to compile gpipe separately?
22:54:52 <geekosaur> both stack and cabal know how to build projects with subprojects
22:54:59 <nshepperd> has anyone had an issue like that with UndecidableSuperClasses here?
22:55:52 <nshepperd> I would normally have expected that IncoherentInstances are only relevant when you're actually writing some instances that overlap
22:56:27 <dataN> and that wasnt the case?
22:56:52 <pie_> geekosaur, i havent tried to figure those out yet xD
22:56:52 <pie_> ive just been using raw ghc commands
22:56:56 <nshepperd> dataN: nope
22:57:05 <dataN> do you have a paste?
23:05:09 <dataN> rotaerk: speaking of dependant types, there was a neat example that was kind of tough to solve, where two classes each of one defining function which are mutual inverses are defined locally, execpt only by providing a definition for one of the functions, and the other was implemented at the time of use of the first.
23:06:00 <dataN> the problem being that the ability to place the new constraint (the implementation of the inverse) into some kind of local scope needed some kind of continuation...
23:08:09 <nshepperd1> Great, my internet went down just as i was about to paste something
23:08:37 <wsm16> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
23:08:37 <wsm16> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
23:08:37 <wsm16> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
23:23:38 <th3bmw19> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
23:23:38 <th3bmw19> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
23:23:38 <th3bmw19> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
23:24:39 <nshepperd1> Ah, hold on, this actually seems to be a FlexibleContexts problem?
23:25:04 * nshepperd1 trying to make a minimal example
23:25:06 <saurabhnanda> is it just me or is haddock really slow? Every time I run it, it seems to process every single file, even if it hasn't been touched.
23:25:53 <cocreature> saurabhnanda: it’s not just you. it is just slow
23:26:15 <saurabhnanda> it seems that haddock can be invoked on one file at a time, is that correct?
23:26:33 <saurabhnanda> I was thinking of writing a gulp-watcher for this, if it works as expected.
23:27:04 <saurabhnanda> however, I can't seem to get haddock working with stack properly.
23:27:27 <cocreature> not sure. there is a gsoc project this year that should help somewhat afaik
23:29:37 <nshepperd1> I've got a class Foo (ds :: [Nat]) and instances for Foo [] and (KnownNat d, Foo ds) => Foo (d:ds) and it's throwing these errors when i try to write a function that has Foo [a,b,c] in the context and makes use of Foo [2*a,2*b,c] in the body
23:30:31 <nshepperd1> The error states that there's overlapping instances for Foo '[2*a, 2*b, c]
23:30:42 <cocreature> nshepperd1: you’ll make things a lot easier if you show us a self-contained example
23:33:01 <nshepperd> internet came back, finally
23:33:35 <nshepperd> https://lpaste.net/1100535324641067008
23:35:26 <nshepperd> so the UndecidableSuperClasses didn't turn out to be part of it
23:37:27 <dataN> does writing a different proxy for each type rather than one for the whole list help?
23:37:31 <nshepperd> ah, hmm. it looks like maybe it's saying that it doesn't know that it can't use the KnownDims [a, b, c] from the context because it can't see through the (*) operator and confirm or deny that [a, b, c] ~ [2*a, 2*b, c]
23:40:31 <cocreature> exactly
23:42:03 <nshepperd> dataN: writing knownDims (Proxy @ '[2*a]) or similar gives the expected error about 'cannot deduce KnownNat a'
23:43:36 <nshepperd> (because i've turned off the type checker plugin for KnownNats for this minimal example)
23:43:53 <siraben> Has anyone here read "The Haskell School of Music?"
23:43:55 <siraben> How is that book?
23:44:09 <nshepperd> er, the error is about deducing KnownNat for 2*a, of course
23:44:43 <dataN> nshepperd: right, its the same as trying to write tuples of proxys? seems not to work
23:45:40 <cocreature> hm, not sure if there’s a nice solution that does not involve IncoherentInstances
23:45:41 <nshepperd> I guess I'm a little surprised that I haven't come across this before, because it seems like it would happen in many situations where you use FlexibleContexts
23:46:36 <cocreature> without type-level families that seems hard to hit
23:46:39 <nshepperd> well, I suppose it requires a type family
23:48:43 <cocreature> it looks like you can’t even use per-instance INCOHERENT pragmas since it’s the instance you get via the context of bad, that needs to be marked INCOHERENT
23:51:18 <nshepperd> yeah it's not really the fault of the class or its instances
23:54:54 <nshepperd> I wonder if it would be problematic for instances obtained via FlexibleContexts to be treated as INCOHERENT by default
23:55:40 <nshepperd> if you could check at the call site that they're not actually overlapping when you construct them
23:56:13 <nshepperd> nah, i bet that doesn't work
23:58:14 <cocreature> nshepperd: you can avoid IncoherentInstances, if you change the type signature to "bad :: forall a b c proxy. (KnownNat a, KnownNat b, KnownNat c) => proxy [a, b, c] -> [Int]" (using the plugin)
23:59:47 <cocreature> if you don’t use the plugin add KnownNat (2 * a), KnownNat (2 * b), KnownNat (3 * c) as well
