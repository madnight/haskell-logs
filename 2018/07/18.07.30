00:01:09 <ZoOBoO> Hello, can anyone tell me what everything after the bar/pipe is doing here? (Functor f, Representable u) =>  Adjunction f u | f -> u, u -> f 
00:01:18 <ZoOBoO> ^from here: http://comonad.com/reader/2011/monads-from-comonads/
00:01:39 <Axman6> those are functional dependencies
00:02:08 <Axman6> the state that the choice of f determines the choice of us, and the choice of u determines the choice of f
00:02:18 <koz_> Axman6: So for each f, we gotta have a unique u?
00:02:59 <Axman6> so if I have have Adjunction Int Char, and had a constrraint somewhere which was Adjunction Int u => ... u ..., then u must be Char since f -> u
00:03:03 <Axman6> koz_: yeah
00:03:14 <Axman6> and vice versa
00:03:21 <geekosaur> yes. for multiparameter typeclasses, that allows the compiler to do type inference; otherwise you'd have to annotate every use of that typeclass
00:03:51 <geekosaur> (and in some cases that would mean TypeApplications, which is a very recent extension)
00:04:06 <Axman6> if it only had f -> u, then we could have instances for Adjunction Int Char and Adjunction Bool Char; f determines u, but there can be many f's which determine the same u
00:04:29 <Axman6> (I think I have that right)
00:05:09 <Axman6> ZoOBoO: does that help at all?
00:05:44 <Axman6> I guess not :\
00:07:11 <koz_> Axman6: :(
00:12:10 <dataN> https://lpaste.net/3498670407882375168
00:12:28 <dataN> why is this an error?
00:17:01 <pavonia> It doesn't seem to know which intermediate e to choose
00:18:31 <pavonia> dataN: "move e d xs = direction d xs `asTypeOf` e >>= edge >>= \f -> f xs" maybe
00:20:11 <pavonia> Err no
00:20:19 <dataN> oh
00:22:08 <dataN> some kind of higher kinded version of that?
00:23:24 <dataN> problem is annotating the type of edge does nothing..
00:23:25 <pavonia> If you remove the proxy, "direction d xs `asTypeOf` (Just e)" works. But there must be a nicer way
00:24:26 <dataN> right, that seems like an example restricted to Maybe...
00:25:32 <dataN> probably trying to use the arity and location of the proxy variable is possible but not easy to use
00:28:48 <dataN> wait what? where is this value e?
00:29:39 <dataN> `asTypeOf` (undefined :: Maybe e) does not work, same error
00:29:40 <Ariakenom> shouldn't "move :: Navigable d e f => ..." be "move :: ..."
00:30:47 <dataN> oh sure, just put it there so it could be commented out without error...
00:31:41 <dataN> it does not affect the code
00:32:59 <dataN> (so that if move was used elsewhere it appear in scope even if undefined..)
00:33:39 <dataN> leaving the type signature in the class declaration 
00:34:24 <ZoOBoO> So, data constructors starting with capital letters is a mistake, right? Future languages aren't going to do that, right?
00:35:02 <c_wraith> ZoOBoO: why wouldn't they?  It's a fantastic way to disambiguate patterns
00:35:15 <revskill> My monad stack has a configs , but it's for production only. How to disable during test ?
00:35:38 <ZoOBoO> c_wraith: But they're for concrete types :/
00:36:13 <c_wraith> yes, data constructors construct (or pattern match) concrete types.  That's their entire purpose.
00:36:45 <ZoOBoO> let's say they were small, what would be confusing?
00:36:55 <marvin2> I think the question is whether type constructors shoudl have been lower case, and only concrete types upper case
00:37:13 <c_wraith> type constructors aren't data constructors
00:37:15 <dataN> ZoOBoO: the pattern wouldnt be able to resolve
00:37:49 <marvin2> c_wraith, yes, I meant data constructors
00:37:55 <ZoOBoO> dataN: can you give me an example? I don't understand. I could do fromMaybe (just c) = ...
00:37:58 <c_wraith> ZoOBoO: are you familiar with pattern matching?
00:38:07 <ZoOBoO> just as much as fromMaybe (Just c)
00:38:13 <c_wraith> ZoOBoO: how do you tell the difference between a data constructor and a variable?
00:38:18 <dataN> no you couldnt!
00:39:04 <c_wraith> ZoOBoO: in (just c), is c a variable or a data constructor?
00:39:18 <ZoOBoO> dataN: huh, right I got it, that was silly.
00:39:31 <ZoOBoO> but caps make me think type level,
00:39:45 <ZoOBoO> I get confused with caps at the term level
00:39:50 <c_wraith> this isn't java or c#.
00:40:17 <Hafydd> ZoOBoO: there are also symbols without an initial capital (e.g. type variables) at the type level.
00:41:13 <dataN> still no way to solve this? https://lpaste.net/3498670407882375168
00:41:20 <ZoOBoO> Hafydd: right, maybe with enough experience they seem like different colors, but right now it's still often confusing (especially with type-punning) and the like
00:41:30 <c_wraith> ZoOBoO: basically - pattern matching syntax is *way* easier to use if there's a trivial lexical distinction between constructors to match and and variables to bind.
00:42:13 <c_wraith> ZoOBoO: just be glad you're not using erlang, which chose the opposite - capital letters imply variables, lowercase imply constructors
00:43:09 <ZoOBoO> c_wraith: at least that's consistent. Here, you have to say "yeah, capital letters are for concrete types. Oh, and there's this totally other thing called pattern matching which it's used for"
00:43:46 <c_wraith> ZoOBoO: what's inconsistent?  Capital -> concrete, lowercase -> variable
00:43:51 <Hafydd> In Erlang, functions also start with a lowercase better.
00:43:51 <c_wraith> ZoOBoO: it's the same in both
00:44:16 <ZoOBoO> perhaps they could have gone with a leading underscore or something, for disambiguating vars and constructors
00:44:27 <Hafydd> Disgusting.
00:45:15 <Hafydd> I believe in ML there's a leading single-quote character for type variables, or something.
00:45:20 <c_wraith> ZoOBoO: anyway, Haskell has independent value and type namespaces.  If you don't keep them separate, you're in for a lot of headaches
00:45:34 <Ariakenom> :t (\x -> 65 <= x && x <= 90) . fromEnum . head
00:45:35 <lambdabot> Enum a => [a] -> Bool
00:46:20 <ZoOBoO> c_wraith: yeah, you're right of course, I wish there was a reminder though
00:46:25 <ZoOBoO> ...like different colors or something
00:46:34 <c_wraith> there are for me!
00:46:37 <Hafydd> A text editor could be made to do that.
00:46:46 <Hafydd> Since they only occur in different syntactic categories.
00:47:02 <dataN> that seems to be starting to get used when a class and a type have the same name, the introduction to dependant types also uses a postfix _ to indicate local instance definitions. 
00:47:27 <ZoOBoO> is there an existing extension for a color thing?
00:47:28 <c_wraith> basically every syntax highlighter for Haskell colors types and values differently - and they all can be configured to do so.
00:48:45 <Hafydd> (I used a syntax highlighter for years that didn't, though, and I didn't have any problems, so it's possible to get used to it.)
00:48:50 <ZoOBoO> I remember using haskell-vim-now, IIRC, both types and data constructors had the same color
00:49:22 <ZoOBoO> Hafydd: "(I used a language for years that didn't use static types, though, and I didn't have any problems, so it's possible to get used to it.)"
00:49:59 <Hafydd> ZoOBoO: I don't understand what you're trying to communicate.
00:50:50 <lavalike> a couple years ago I switched to no syntax highlighting at all just to see what would happen and then I ended up sticking to it, it's a calm experience, with the upside of no inconsistent colors because of regexp parsing
00:51:17 <dataN> Hafydd: something like wouldnt it be cool to have 3 kinds of capital letters?
00:51:28 <Hafydd> What?!
00:51:44 <dataN> i know! seems off topic right!?
00:52:34 <Hafydd> Tangentially.
00:53:20 <Hafydd> In a way, there are multiple kinds of capital letters, i.e. the different scripts used in mathematics, e.g. blackboard bold, fraktur, calligraphic, roman, italic, etc.
00:53:32 <dataN> *oh no*
00:54:31 <cocreature> smallcaps :)
00:54:56 <ZoOBoO> Hafydd: with that quote I was trying to say that people say they don't need static types, but it helps with the thinking. Someone sufficiently smart could do without. Same for "separate types and terms by color"
00:55:22 <tdammers> how about ComicSans for term-level, Architecture for type-level, and Bodoni Poster for kind-level?
00:55:32 <Hafydd> ZoOBoO: alright, but I'd say the latter is much easier to overcome than the former. The latter is just cosmetic.
00:55:36 <Hafydd> LOL
00:55:40 * hackage bhoogle 0.1.3.2 - Simple terminal GUI for local hoogle.  http://hackage.haskell.org/package/bhoogle-0.1.3.2 (andrevdm)
00:55:42 <liste> don't syntax highlighting that separates the namespaces require an actual Haskell parser?
00:55:47 <liste> or would regex be enough?
00:55:48 <ZoOBoO> tdammers: haha, but that would help though :3
00:55:55 <liste> many syntax highlighters are regex based
00:56:23 <tdammers> anyway, type checking is useful in way more regards than just being able to quickly see what sort of thing something is
00:57:08 <ZoOBoO> Hafydd: yeah, I should probably take people's word for it at this point. It helps to keep as much cognition outside my brain as possible though
00:57:13 <Hafydd> (And, in Haskell, it's not uncommon to omit the text giving the types, anyway.)
00:57:31 <tdammers> also, the problem with syntax highlighters is that they need to be fast, and ideally incremental - you don't want to run the better part of a 10-second compilation just to get pretty colors in your source code
00:57:52 <tdammers> in most cases, that means you have to make some sacrifices
00:58:32 <Ariakenom> most of compilation time is code gen though?
00:59:01 <tdammers> Ariakenom: depends on the compiler, but GHC spends a lot of time on type checking
00:59:09 <Ariakenom> I see
00:59:59 <tdammers> also, with GHC's staged approach, the distinction between "parsing" and "code gen" is a bit blurry - we transform the input into a series of intermediate languages, each one a bit closer to the "metal"
01:04:04 <dataN> maybe its better as a gist? https://gist.github.com/dataN-hs/9f799c0f785d0edc4b52617295ad5a3c
01:04:36 <dataN> would be good to be able to fix these kinds of errors...
01:06:13 <dataN> unable to get Proxy or asTypeOf to work...
01:09:26 <cocreature> dataN: https://gist.github.com/cocreature/db0565b579462eda2c845800f4d7fb7c
01:10:37 <dataN> hmm, so adding annotations to the type of direction seems to work; (direction:: d -> f a -> Maybe e) 
01:10:53 <dataN> cocreature: what are tose @ symbols?
01:10:59 <dataN> those*
01:10:59 <cocreature> TypeApplications
01:11:20 <dataN> that might help considerably! 
01:11:22 <dataN> thanks
01:12:09 <cocreature> ignore the AllowAmbigousTypes extension, I added that because I accidentally deleted the "d" parameter from direction
01:12:23 <dataN> ah, ok
01:12:39 <cq1> Hey folks. Is there an easy way to stop compilation at the STG level?
01:14:39 <dataN> just a comment on the code; the notion of a Path presented seems difficult from the type, but its a sufficient abstraction. It allows for containers to be countable and so traversable by imposing an order of visitation... though incorrect instructions could be a problem...
01:15:43 <dataN> thats the next presentation anyway...
01:16:42 <dataN> the concept is a "structure directing path" where a list of navigational edges defines the Lens and the resulting Traversable instance...
01:19:44 <kuribas> does a bytestring builder use mutability to construct the chunks?
01:19:57 <kuribas> like ST monad?
01:23:03 <tdammers> AFAIK it doesn't
01:23:21 <tdammers> the main trick behind builders is to group concatenations to minimize copying
01:24:09 <asheshambasta> Has anyone used `Beam` here? (https://github.com/tathougies/beam)
01:24:09 <kuribas> so it copies everything once?
01:24:23 <tdammers> so if you need to concatenate "a", "b", "c", "d", instead of going "a" -> "ab" -> "abc" -> "abcd", you go ("a", "c") -> ("ab", "cd") -> "abcd"
01:24:32 <asheshambasta> (if so, how has your experience been so far?)
01:25:10 <kuribas> tdammers: how does it know the size of the chunks?
01:25:13 <tdammers> however, bytestring library makes heavy use of all sorts of optimizations, so it's perfectly possible that you effectively end up with in-place mutations after all
01:25:42 <cocreature> iirc a builder is a sequence of IO actions under the hood
01:26:08 <kuribas> using unsafePerformIO?
01:26:54 <cocreature> yeah 
01:27:01 <cocreature> but just look at the source if you want to know the internals :)
01:27:02 <tdammers> bytestring uses lots of those under the hood
01:27:32 <kuribas> lol: This \"function\" has a superficial similarity to 'unsafePerformIO' but it is in fact a malevolent agent of chaos. 
01:28:14 <kuribas> accursedUnutterablePerformIO :: IO a -> a
01:28:19 <Ariakenom> Behold its trail of destruction!
01:29:21 <tdammers> that one is famous
01:29:23 <Ariakenom> Yield not to its blasphemous call! Flee traveller! Flee or you will be
01:29:23 <Ariakenom>  corrupted and devoured!
01:29:41 <lavalike> asheshambasta: I haven't used it before but I have used postgres a lot from other languages and the beam documentation is impressing me!
01:30:52 <kuribas> I experimented with it.  It looks nice, with the higher kinded approach, but it's a bit heavy on typeclasses.
01:31:04 <kuribas> asheshambasta: ^
01:34:21 <lavalike> it doesn't seem to support COPY but I found that limitation in other languages' drivers too
02:07:03 <guru107> Hello haskellrs
02:09:40 * hackage hriemann 0.2.2.1 - Initial project template from stack  http://hackage.haskell.org/package/hriemann-0.2.2.1 (shmish111)
02:10:24 <Ariakenom> hi guru107 
02:11:10 * hackage hriemann 0.2.2.2 - Initial project template from stack  http://hackage.haskell.org/package/hriemann-0.2.2.2 (shmish111)
02:11:49 <tdammers> DAE think it's a bad thing for scaffolding tools to put placeholder text in fields?
02:12:43 <merijn> tdammers: DAE think the existence of scaffolding tools are a language failure? :p
02:13:09 * hackage hriemann 0.3.1.0 - Initial project template from stack  http://hackage.haskell.org/package/hriemann-0.3.1.0 (shmish111)
02:13:44 <merijn> tdammers: Ah, now I see what you mean :)
02:13:56 <merijn> Also, when did Hackage abandon the "use real names" requirement?
02:16:41 <tdammers> no idea
02:17:20 <tdammers> scaffolding tools aren't really a smell IMO - I'd say that your favorite scaffolding templates reflect how you prefer to lay out your projects
02:17:47 <tdammers> the situation is simply such that project layout is something you get to choose as a programmer, but you don't want to manually type it all in every time
02:18:09 * hackage xmonad 0.14 - A tiling window manager  http://hackage.haskell.org/package/xmonad-0.14 (PeterSimons)
02:18:32 <tdammers> as long as there isn't too much redundancy there, or you generate the redundant stuff on the fly, I don't see a problem
02:18:56 <tdammers> and the alternative, "convention over configuration", is arguably worse if enforced to its full extent
02:23:17 <Clint> woo
02:35:18 <petercommand> what's convention over configuration?
02:36:08 <merijn> petercommand: "smart defaults" in the tool reading the config
02:36:26 <merijn> petercommand: So that you have to magically guess what the default behaviour is
02:36:46 <merijn> i.e., the opposite of "Explicit is better than implicit" from the Zen of Python :)
02:37:07 <cocreature> smart defaults implies that you can actually change things. often convention over configuration goes so far as to just remove the option to change things.
02:37:12 <petercommand> merijn: Ah, ok..
02:40:02 <tdammers> the idea behind "convention over configuration" is to make things simpler by removing configurability
02:41:05 <tdammers> it's related to the "opinionated tools" ideas
02:41:30 <tdammers> an opinionated tool makes the tasks it was designed for simpler, because it doesn't have to take its non-use cases into account
02:41:39 <tdammers> but the downside is that it's not suitable for many things
02:41:41 <petercommand> tdammers: that sounds aweful #removing configurability
02:41:46 <petercommand> *awful
02:41:49 <tdammers> petercommand: it's a tradeoff
02:42:13 <tdammers> petercommand: e.g., in an ORM, the ability to support a dozen different ways of setting up your database schema leads to enormous amounts of complexity
02:43:02 <petercommand> tdammers: it's possible to have simple and advanced configurations
02:43:03 <tdammers> whereas if you mandate a few conventions, such as "every normal table shall have a primary key column that is an auto-incrementing integer, and it is always named `id`", then the ORM gets considerably simpler
02:43:38 <petercommand> it's possible to do both at the same time
02:43:46 <tdammers> the problem with having "simple and advanced configurations" is that as soon as anything is *possible*, anyone who deals with it has to consider it *likely*
02:43:48 <petercommand> by putting these options into "advanced settings"
02:43:55 <tdammers> that doesn't matter
02:44:00 <tdammers> and it doesn't help, really
02:44:11 <tdammers> the problem is not "how do I configure this to do what I want"
02:44:32 <tdammers> the problem is, "given the system in its current state, how can I predict its behavior"
02:45:47 <tdammers> for example, if you encounter the following line in a PHP application: $pdo->prepare("SELECT * WHERE SELECT");
02:46:05 <tdammers> do you know how many things you need to check to predict what exactly this will do?
02:46:17 <petercommand> I have no idea
02:46:37 <tdammers> there are about a dozen different configuration files and other things that can influence this
02:46:47 * petercommand not familiar with php
02:47:00 <johnnyv[m]> does anyone have any ideas about resolving an ambiguous interface error. I'm using `servant-server` and `servant-snap` and they both produce a Servant module, but I want to use the servant-server one for the authentication but I'm currently serving my app using servant-snap
02:47:06 <tdammers> depending on these settings, this line might produce one of several error messages, and those messages may end up in a log file, on the console, or in the HTTP response
02:47:34 <tdammers> and even if you manage to find all of those configuration files, it isn't immediately obvious in what order they are processed
02:47:41 <noipmups> Is there any equivalent of imperative `if (!cond) return val;` in a do notation?
02:47:49 <cocreature> :t unless
02:47:50 <lambdabot> Applicative f => Bool -> f () -> f ()
02:47:58 <tdammers> so that kind of thing is where the "convention over configuration" idea came from
02:47:58 <cocreature> but that won‚Äôt give you the early exit
02:48:00 <alp> johnnyv[m], doesn't sound like using both is a good idea, but you can look into the PackageImports extension or something along those lines.
02:48:22 <johnnyv[m]> alp: ok thanks!
02:48:29 <tdammers> instead of making everything configurable, you'd just make a lot of "common-sense" choices, and just do that
02:49:09 <tdammers> e.g., instead of giving the user six different configurable choices as to where to write log entries, just poop them out on stdout, and let the user code route them wherever they want
02:49:33 <tdammers> instead of parsing 12 different configuration files, just use environment variables
02:49:35 <tdammers> stuff like that
02:49:40 <alp> johnnyv[m], see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#package-qualified-imports for me 
02:50:42 <petercommand> I don't think this is necessarily true > "as soon as anything is *possible*, anyone who deals with it has to consider it *likely*
02:50:45 <noipmups> cocreature: I would like to exit early. Is `if then else` the only solution?
02:51:46 <petercommand> um, this is okay, since the user is still able to achieve their original goal > just poop them out on stdout, and let the user code route them whereever they want
02:53:22 <kalii> Is there a semantic significance in the difference in quote marks in GHCi error messages like: No instance of (Ord Ego) arising from a use of `>'?
02:53:39 * hackage primitive-extras 0.6 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.6 (NikitaVolkov)
02:53:55 <petercommand> tdammers: if the user can route the output to anywhere they want, isn't that making it harder to predict the behavior of the system?
02:54:13 <cocreature> noipmups: either if then else, something like ExceptT or exceptions. ExceptT and exceptions are usually used for exiting early with an error rather than a regular exit, so I would generally go for if-then-else
02:54:25 <tdammers> petercommand: at least it's easier to reason about that component in isolation
02:54:39 * hackage static-text 0.2.0.2 - Lists, Texts, ByteStrings and Vectors of statically known length  http://hackage.haskell.org/package/static-text-0.2.0.2 (DmitryDzhus)
02:54:59 <tdammers> petercommand: and when you have 60 such components that all follow the same convention, then managing that is still easier than juggling 60+ configuration files using 60 different formats
02:55:24 <noipmups> cocreature: Ok, thank you.
02:55:24 <petercommand> so it's all able interfaces then
02:55:32 <petercommand> *about
02:55:37 <tdammers> well, yes
02:55:45 <tdammers> configuration is generally about interfaces
02:56:02 <tdammers> you have a component, and the host wants to tell it how to behave
02:56:05 <tdammers> that's what configuration is about
02:56:39 * hackage wordpass 1.0.0.10 - Dictionary-based password generator  http://hackage.haskell.org/package/wordpass-1.0.0.10 (MichalGajda)
02:57:18 <petercommand> tdammers: I agree
03:01:36 <zincy> I am struggling to add a dependency: quickcheck must match -any, but the stack  configuration has no specified  version
03:01:56 <opqdonut> might the problem be that the name of the package is actually QuickCheck
03:02:28 <zincy> oh thats unconventional
03:02:32 <opqdonut> one of the few packages, yeah
03:02:36 <zincy> thanks
03:03:06 <opqdonut> I bump into that regularly :)
03:20:02 <kalii> @version
03:20:02 <lambdabot> lambdabot 5.1.0.1
03:20:02 <lambdabot> git clone https://github.com/lambdabot/lambdabot
03:51:09 * hackage bit-protocol 0.2.1.0 - Encode binary protocols with some odd bit numbers into a bytestring  http://hackage.haskell.org/package/bit-protocol-0.2.1.0 (k_bx)
04:09:58 <jsjolen> sequence :: [Promise a] -> Promise [a]. Assume sequence' :: [Promise Maybe a] -> Promise Maybe [a] where a Nothing will propagate. I need sequence'' :: SomeInductiveDatatype Promise Maybe a -> Promise Maybe SomeInductiveDatatype a
04:10:18 <jsjolen> So that clearly means that I need a recursion scheme (the a is clearly misplaced)
04:10:30 <jsjolen> But I don't know which recursion scheme I need :-D
04:11:02 <jsjolen> Any idea which one it is I need?
04:11:41 <asheshambasta> lavalike: (sorry about the late reply) Yeah, Beam is very well documented, and I agree that its quite heavy on Typeclasses. 
04:12:32 <asheshambasta> lavalike: I'm impressed overall by the abundance of these nice 'type-level' libraries in the Haskell ecosystem
04:13:32 <Ariakenom> :t traverse
04:13:32 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
04:13:54 <Ariakenom> traverse id
04:13:56 <Ariakenom> :t traverse id
04:13:57 <lambdabot> (Applicative f, Traversable t) => t (f b) -> f (t b)
04:14:19 <merijn> asheshambasta: A lot of that stuff is people just experimenting with "how far can we push this?"
04:14:32 <merijn> asheshambasta: Sometimes it works spectacularly, other times it ends up a horrid mess ;)
04:15:27 <jsjolen> Ariakenom: Sweet, so if I have Applicative and Traversable I have it through traverse
04:15:49 <jsjolen> You know this Haskell stuff is pretty nice.
04:18:32 <Ariakenom> jsjolen: I agree
04:18:41 <Ariakenom> traverse is very useful I've heard
04:19:05 <jsjolen> Mhm, unfortunately I have to code what I described above in Javascript, wish me luck lol.
04:20:07 <Ariakenom> gl "hf"
04:28:40 * hackage bit-protocol 0.2.2.0 - Encode binary protocols with some odd bit numbers into a bytestring  http://hackage.haskell.org/package/bit-protocol-0.2.2.0 (k_bx)
04:33:14 <ifeiweiow> hello
04:35:10 <Ariakenom> greetings
04:38:02 <bo> Hi everyone! Is it possible in Haskell to filter some values from range during destructuring? 
04:38:40 <dmwit> > [x | x <- [1..10], not (x `inRange` (3,7))]
04:38:41 <lambdabot>  error:
04:38:41 <lambdabot>      ‚Ä¢ No instance for (Num ((Integer, Integer), (Integer, Integer)))
04:38:41 <lambdabot>          arising from a use of ‚Äòe_111037‚Äô
04:38:47 <dmwit> :t inRange
04:38:48 <lambdabot> Ix a => (a, a) -> a -> Bool
04:38:58 <dmwit> > [x | x <- [1..10], not (inRange (3,7) x)]
04:39:00 <lambdabot>  [1,2,8,9,10]
04:39:49 <dmwit> bo: I don't really understand the question yet, but I'm pretty sure the answer is that it is possible.
04:40:04 <bo> Say, i want to create a function that sums up only positive elements of a list. Is it possible to filter the negatives in the function declaration? Allow me to provide an example
04:40:14 <Ariakenom> bo: I think you want ViewPatterns, let me find a link
04:40:24 <dmwit> > sum . filter (>0) $ [-10 .. 10]
04:40:26 <lambdabot>  55
04:42:23 <Ariakenom> bo: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ViewPatterns
04:42:27 <bo> sumPositives (list, itemOfList > 0) = sum list
04:42:53 <dmwit> sumPositives list = sum (filter (>0) list)
04:42:54 <bo> something like this, to filter the values during destructuring. Or am i overthinking it? 
04:43:20 <dmwit> In addition to actually working, my version is shorter by four characters, too. ;-)
04:43:30 <opqdonut> you could use view patterns for that I guess
04:43:40 <bo> dmwin: i see, I'm overthinking it :)
04:44:00 <Solonarv> you can even eta reduce: sumPositives = sum . filter (>0)
04:44:25 <Ariakenom> sumPositives (filterPositives -> xs) = sum xs -- with viewpattern
04:44:25 <dmwit> (That's not *just* eta reduction. There was also a delta expansion step in there.)
04:45:51 <bo> Alright, i've lost track with these words, will keep reading the tutorial until i understand what you've just said :D
04:46:03 <dmwit> These terms are not important.
04:46:06 <bo> Thanks everyone for the answers! The issue is resolved :)
04:46:12 <dmwit> He just meant you don't need to actually name the `list` parameter.
04:46:24 <dmwit> If you don't want to.
04:46:42 <bo> Oh, i see. Didn't get to that point in tutorial yet, i believe
04:46:55 <dmwit> I think it's mostly an aesthetic choice, especially if you put an explicit type signature.
04:47:22 <Ariakenom> > (\ ( (<=0)->xs) -> sum xs) [-1,1,2]
04:47:23 <lambdabot>  error:
04:47:24 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äò[a]‚Äô with actual type ‚ÄòBool‚Äô
04:47:24 <lambdabot>      ‚Ä¢ In the first argument of ‚Äòsum‚Äô, namely ‚Äòxs‚Äô
04:48:00 <Ariakenom> > (\ ( filter (0<=) ->xs) -> sum xs) [-1,1,2]
04:48:02 <lambdabot>  3
04:48:22 <Ariakenom> :t (&)
04:48:23 <lambdabot> a -> (a -> b) -> b
04:48:52 <bo> Works! I'll copy myself this line and examine it more carefully, thanks
04:49:23 <dvaergiller> :info (&)
04:49:31 <dvaergiller> no?
04:49:41 <Ariakenom> bo: which?
04:50:13 <merijn> Ariakenom: That's awfully unidiomatic, tbh
04:50:16 <Solonarv> % :i &
04:50:16 <yahb> Solonarv: (&) :: a -> (a -> b) -> b -- Defined in `Data.Function'; infixl 1 &
04:50:27 <dmwit> bo: Don't copy that, gross.
04:50:41 <dmwit> bo: He wrote that to satisfy your terrible requirements, not because it's good Haskell.
04:50:49 <merijn> ViewPatterns can be nice in some cases, but not here
04:51:41 <Ariakenom> > \(filter(0<=).sum -> xs) -> xs & [-1,1,2] -- better? :p
04:51:43 <lambdabot>  error:
04:51:43 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äò[a] -> b‚Äô
04:51:43 <lambdabot>                    with actual type ‚Äò[Integer]‚Äô
04:52:08 <dmwit> y u do dis?
04:52:12 <Ariakenom> > \(sum.filter(0<=) -> xs) -> xs & [-1,1,2] -- cant code today
04:52:14 <lambdabot>  error:
04:52:14 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äòa -> b‚Äô
04:52:14 <lambdabot>                    with actual type ‚Äò[Integer]‚Äô
04:52:50 <dmwit> The whole reason you're using (&) is so you can put the function second...
04:53:20 <Ariakenom> right that was actually $ order
04:53:26 <Ariakenom> I'll stop trying to code now
05:02:13 <Ariakenom> > [0..10] & \(sum . filter (0<=) -> xs) -> xs -- most tasteful solution
05:02:15 <lambdabot>  55
05:05:55 <kalii> I'm not qualified to work in the technology industry in any capacity, so I have nothing really to dictate direction, so to possibly become a quasi-sophisticated Haskell programmer, what sorts of programming goals should I have?
05:11:12 <Ariakenom> of course more lambda is better :/   [0..10] & \(\xs -> sum ( filter odd xs) -> xs) -> xs
05:13:06 <lukelau> Is it possible to pattern match an existing binded variable? https://gist.github.com/Bubba/863703703af68af564ec03da51a5d3d7
05:13:25 <merijn> lukelau: No
05:13:35 <lukelau> Damn
05:13:47 <merijn> lukelau: You can, however use guards
05:14:11 <merijn> lukelau: "case Foo 32 of y | y == x -> putStrLn "matched""
05:14:12 <Ariakenom> f x y | x == y = ...
05:14:43 <lukelau> Didn‚Äôt realise you could use guards inside a case statement
05:22:23 <Ariakenom> kalii: eh don't think I understand. 
05:22:55 <merijn> lukelau: You can use guards on any pattern match, including inside case-of :)
05:23:17 <merijn> lukelau: Learn something new everyday ;)
05:24:03 <Ariakenom> relatedly, you can bind in guards
05:24:07 <Ariakenom> > case () of () | a <- 3 -> a
05:24:09 <lambdabot>  3
05:24:14 <merijn> That's not bind, though
05:24:21 <merijn> That's a pattern guard
05:24:39 <lukelau> Is that >>= bind?
05:24:40 <Ariakenom> right, I meant a binding and not >>=
05:24:46 <lukelau> Ah
05:25:38 <Ariakenom> :t [x+1| x<-xs]
05:25:39 <lambdabot> error:
05:25:39 <lambdabot>     ‚Ä¢ Variable not in scope: xs :: [a]
05:25:39 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
05:27:16 <kalii> Ariakenom: Presumably goals or demands dictate direction. Direction can lead to sophisticated abilities. In my case, I can probably only expect to obtain quasi-sophisticated abilities at best. If only I had direction. I wouldn't have direction in the form of external demands. So I'm asking for suggestions on direction in the form of internal goals.
05:30:18 <Ariakenom> kalii go build some standard beginner project?
05:31:55 <kalii> Ariakenom: What's a standard beginner project may be a uni insider thing. I don't know what one would be.
05:37:12 <Ariakenom> kalii: "Doing puzzles like the Advent of Code helps me improve "  "My favorite beginner project in Haskell is trying to write a parser for some bizarre file type using parsec"  https://www.reddit.com/r/haskell/comments/5uijni/haskell_projects_for_beginners/ 
05:38:55 <kalii> Ariakenom: Okay. tysm
05:41:21 <Ariakenom> kalii: but maybe you'd want to follow some tutorial. maybe someone has a suggestion
05:47:03 <kalii> Ariakenom: Right now I'm studying Haskell Programming from First Principles. Just not getting inspired. And therefore doubting if I'll ever obtain "an outlook" deep enough that I can imagine myself eventually doing quasi-interesting things. Haskell seems important, but I don't know if I can appreciate why (for non-blind motivation).
05:49:59 <Ariakenom> Allright, I've heard good things about that one kalii. I've also heard the complaint it's slow from some. While some have found LYAH to be inspiring but not that good at teaching. Maybe that's what you want. http://learnyouahaskell.com/chapters
05:55:00 <Ariakenom> To be clear those are not my own impressions. Literally have just heard some say that and thought it may help.
05:55:58 <kalii> ty Ariakenom, it does
05:58:39 * hackage indexation 0.2.1 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.2.1 (NikitaVolkov)
06:16:59 <Ariakenom> kalii: Does that mean I've heard one more find LYAH motivating?
06:17:21 <ollehar> is there a language which combines linear types with algebraic effects (like e.g. koka)?
06:23:42 <kalii> Ariakenom: Well, its projects do also seem too mundane. Nonetheless, it seems worthy of extended attention at the very least for its initial humor and nice layout.
06:25:47 <Ariakenom> ok
06:26:51 <kalii> Ariakenom you're not the author of it or anything are you?
06:27:50 <Ariakenom> I've authored nothing
06:28:47 <Logio> kalii: I'd suggest finding something you want to code, and then doing it in Haskell
06:31:12 <Logio> or possibly, finding something neat done in another language and then implementing it in Haskell
06:33:10 * hackage stm-hamt 1.1.0.1 - STM-specialised Hash Array Mapped Trie  http://hackage.haskell.org/package/stm-hamt-1.1.0.1 (NikitaVolkov)
06:33:10 <kalii> Logio, I wasn't sure if this was a stupid idea but had started to form visions of studying Elements of Computing Systems and then trying to implement a virtual computer plus compiler with Haskell.
06:34:18 <kalii> ... since my computer science is severely lacking in the first place
06:38:32 <Logio> that doesn't seem like a bad project if you have the patience for it
06:40:41 <ph88> how can lift a type class through common monadtransformers ? i want to make an implementation
06:45:16 <pavonia> ph88: I don't think you can, you have to define an instance for each type
06:45:24 <kalii> Logio, my first inclination was to go forward with that idea but with Unreal Engine rather than Haskell. But presumably there'd be better longer-lasting general cognitive benefits from doing it in Haskell.... Just, I can imagine, long sequences will be very dull and boringly frustrating. Will require some patience like you say.
06:45:36 <ph88> pavonia, yes how do i define this instance for each type ?
06:46:24 <Solonarv> well that depends on the class, and which transformers you're lifting through
06:46:38 <pavonia> ph88: It depends on the type, usually just unwrapping, lifting, re-wrapping
06:46:59 <ph88> pavonia, do you know an example of that? i don't know where to start
06:47:24 <pavonia> Maybe have a look at the instances in the mtl/transformer packages
06:48:13 <cocreature> a default implementation in terms of MonadTrans can help if that‚Äôs possible for your typeclass
06:49:41 <ph88> i want to make an implementation for the RandomSource typeclass
06:51:16 <ph88> like this?  https://hackage.haskell.org/package/transformers-0.5.5.0/docs/src/Control.Monad.Trans.Reader.html#line-195
06:52:28 <ph88> i would like to combine RandomSource with ReaderT so i'm looking for another example of a typeclass that can work with ReaderT
06:53:07 <Solonarv> look at mtl, not transformers
06:53:12 <sohail> [beginner-here]
06:53:12 <sohail> Hey, trying to get my head around the functional way.
06:53:12 <sohail> can we say the "steps" in imperative way can roughly translate to "little functions" in Haskell?
06:53:12 <sohail> Because even if we are in Haskell we still have to have some kinda "steps" for doing things, een if it means passing functions or their output around.
06:53:45 <sohail> *even.
06:53:52 <sohail> am I wrong?
06:53:57 <Solonarv> they're roughly similar, yes
06:54:51 <Solonarv> much like you break down an imperative program into steps (which are themselves made of smaller steps, etc), a functional program can be broken down into a bunch of functions which are themselves made of smaller functions.
07:03:57 <sohail> Solonarv: üëç
07:05:13 <Solonarv> uh, my client doesn't seem to like that character
07:05:16 <Solonarv> what did you send?
07:05:23 <Akii> thumbs up
07:05:39 * hackage FAI 0.1.0.20 - Haskell Foreign Accelerate Interface  http://hackage.haskell.org/package/FAI-0.1.0.20 (qinka)
07:05:40 <Akii> set your client to utf-8
07:05:42 <revskill> I ask myself when will people stop supporting OOP languages and convert their great library to FP languages
07:05:58 <Ariakenom> they're lying. it was poop /s
07:06:03 <revskill> what a waste of time to develop a library for a OOP language :(
07:07:14 <mnoonan> sohail: imo the big difference is that an imperative description focuses on the thing being manipulated, while a functional description focuses on the manipulations.
07:07:58 <ph88> pavonia, cocreature, Solonarv am i going in the right direction here ?  https://bpaste.net/show/afdd98d48df0
07:08:54 <Solonarv> no, because you're writing an orphan instance
07:09:42 <ph88> what kind of instance should i write ?
07:10:04 <Solonarv> ones that aren't orphans ;)
07:10:21 <ph88> so "normal" instances ?
07:10:27 <Solonarv> yes
07:10:29 <ph88> how do they differ from orphan instances ?
07:10:39 <cocreature> well if you are writing this in an application instead of a library, orphan instances are not that bad
07:10:54 <Solonarv> non-orphan instances are in the same module as the class, or the same module as the type it's for
07:11:22 <ph88> it's suppose to go in the same module ..
07:11:50 <ph88> anyway .. despite the location, the code stays the same ?
07:12:44 <Solonarv> I mean, yes, that is an instance you could write
07:13:32 <ph88> so i should implement the getRandomPrim function ?
07:13:41 <merijn> \o/
07:13:49 <ph88> hi
07:13:53 <Solonarv> have you *looked* at the RandomSource documentation?
07:13:59 <merijn> Subrepo dependencies in new-build are awesome :D
07:14:14 <ph88> Solonarv, yes it says Minimum implementation is either the internal getRandomPrim or all other functions 
07:14:24 <ph88> but i like confirmation :P
07:14:58 <ph88> also have to change some things in the types ... Env is just something specific to me application so this should be a variable for sure
07:19:09 <cocreature> ph88: I would expect something more like "instance RandomSource m s => RandomSource (ReaderT e m) s"
07:19:27 <ph88> yes i already changed this ..
07:19:31 <ph88> i will put my new code
07:20:16 <ph88> https://bpaste.net/show/2b29b5766096
07:21:17 <ph88> ah i get it .. instead of   m = ReaderT a b    m is now inside this .. is this the transformation ?
07:25:22 <ph88> do i get that error because this file https://hackage.haskell.org/package/random-source-0.3.0.6/docs/src/Data-Random-Internal-Source.html= does not export the getRandomPrim function ?
07:27:25 <jkup> 1
07:28:48 <lyxia> it does export it
07:28:52 <cocreature> ph88: you could import it from Data.Random.Internal.Source but the .Internal. name suggests that you‚Äôre not really supposed to do that and the docs say you should create an instance using TH.
07:33:21 <JuanDaugherty> y u no use servant?
07:34:23 <sohail__> mnoonan: got it.
07:34:52 <dvaergiller> hello. am I missing something or does this guide seem a bit outdated? https://haskell-servant.github.io/extending.html 
07:35:10 <JuanDaugherty> trynna make a dll/so igess
07:35:19 <ph88> cocreature, i want to put it in the original library, maybe it doesn't need to be TH. Anyway i tried TH but i get a syntax error https://bpaste.net/show/7250f22a1f5e
07:35:36 <dvaergiller> the type for 'serve' does not seem to match what is in the documentation in hackage
07:35:44 <cocreature> ph88: if you want to put it in the original lib then importing the internal module is probably fine
07:36:15 <alp> dvaergiller, right this page is outdated and not checked by CI unlike the tutorial and cookbook on readthedocs
07:36:28 <alp> but the spirit is the same
07:38:18 <phadej> it's outdated, and there's not even a link to that page
07:38:19 <dvaergiller> alp, thank you. I was looking for something to help me do custom input validation and I found a StackOverflow thread but that seems to be outdated as well, or at least not that clear for a beginner like me
07:38:25 <phadej> maybe I should just removed it from the site
07:38:53 <phadej> one probably can still find it through google :/
07:39:00 <dvaergiller> phadej, yep
07:40:26 <dvaergiller> https://www.google.com/search?q=extending+servant
07:42:19 <dvaergiller> phadej, maybe I am just on the wrong track trying to figure out how to do input validation with Servant. making a combinator for it sounds like a good idea to me, but since there is not much material on that maybe people do these things in a very different way?
07:42:35 <phadej> input validation?
07:42:47 <phadej> are you looking for `FromHttpApiData` class?
07:43:16 <phadej> (which isn't btw servant specific - any ideas how to make that clearer would be great)
07:43:45 <dvaergiller> sorry, I wasn't clear
07:44:48 <alp> yeah tell us about your problem and we can then maybe give some input on how you could proceed
07:44:55 <dvaergiller> lets say for example that I want a validation step for each endpoint that validates the request body in an arbitrary way. for example, if I want to make sure that a certain field of the JSON input matches some regex or whatever
07:45:20 <alp> why not do it in the FromJSON instance?
07:46:00 <alp> (I imagine there's a reason, so I'm basically asking what it is)
07:46:03 <dvaergiller> I would have to do that in every instance. hm. yes, maybe
07:46:35 <phadej> if there's some (different) invariants you want to enforce, use newtypes 
07:46:43 <dvaergiller> but I might want to do even more. I might want to compare a field to some header, or a capture
07:46:53 <phadej> it will save you time in the longer run (what's validated and how, and what's not)
07:47:13 <dvaergiller> maybe it's a smell, but one think I want to do is to check that a URL capture matches an ID in my JSON body
07:47:19 <phadej> that becomes handler logic
07:47:21 <alp> dvaergiller, in that case this has to happen in the handlers.
07:47:30 <alp> you can still abstract it out as a separate function you can use in each handler
07:48:31 <dvaergiller> I was just hoping for some way to not have to do it in each handler, and enforce in the type system that a "validate" has to be done
07:48:46 <alp> and maybe try to play some games to "apply it to each handler automatically", even though you'd regret it =) but yeah if you need things from elsewhere in the request or in the world, it has to run in your handler I think, this is not about the HTTP request anymore but about the values you find in it and whether you're happy with them etc
07:49:01 <phadej> dvaergiller: newtypes
07:49:12 <phadej> validate :: CaptureVal -> MyVal -> ValidatedVal
07:49:27 <phadej> you don't need anything more complex than Haskell98 for that
07:49:39 <dmead> Hi guys
07:49:43 <phadej> tomorrow's you will thank today's you for not using all GHC extensions for that simple task ;)
07:49:52 <dmead> Is anyone aware of a cobol parser written in Haskell?
07:50:06 <Solonarv> I mean, it's servant - you need to turn on all those fancy extensions anyway ;)
07:50:15 <alp> <dvaergiller> I was just hoping for some way to not have to do it in each handler <<< you can use hoistServer to this effect (source monad = target monad, but you run some action first
07:50:16 <alp> )
07:50:36 <alp> but it has to be independent of the arguments of all those handlers
07:50:57 <alp> and if it's not, then there's just no way you'd get automatical validation, whatever the approach/technique
07:53:27 <dvaergiller> ok. I have a couple of things to look into now. I will try a more manual version suggested by phadej, and look into hoistServer as well. thank you all!
07:56:03 <phadej> Solonarv: not that many in fact. It's like DataKinds + TypeFamilies and extensions we already use in `mtl`
07:56:36 <phadej> and typefamilies is kind-of accidental extra, as mtl doesn't use them (but for servant TF is more convinent than FunctionalDependencies)
07:59:21 <alp> type operators, to
07:59:23 <alp> too*
08:00:05 <phadej> nah, those you need to write Generics
08:00:22 <phadej> We don't use anything not present in 7.4: https://ghc.haskell.org/trac/ghc/wiki/LanguagePragmaHistory
08:00:31 <phadej> the only feature of 7.8 are Symbol literals
08:00:59 <phadej> (and polykinds is broken in 7.4)
08:01:17 <phadej> but GHC-wise, servant uses 5 year old technology
08:01:53 <alp> phadej, well, we need TypeOperators for :> and :<|>, which are used in basically all API types =)
08:02:44 <phadej> alp: yeah, but TypeOperators were present for ages in GHC
08:03:37 <alp> yeah, but it's still an extension =)
08:03:38 <phadej> it's syntactical extension, which you  could avoid (but then API types would be completely unreadable, so better not to)
08:04:08 <phadej> anyway,  I count it as something you'd enable anyway if you use DataKinds
08:04:22 <phadej> (as well as KindSignatures
08:04:23 <phadej> )
08:05:17 <britican> Hey everyone, new to Haskell. I'm coming from a web background, any recommendations on a starting technology? I'm reading the servant tutorial right now since i'm primarily interested in building APIs. Thanks!
08:05:27 <phadej> :)
08:05:44 <Solonarv> seems like you've already gravitated to the thing I was going to recommend anyway
08:06:07 <phadej> anyway, servant internals are IMHO on par in complexity with aeson Generics deriving stuff
08:07:34 <britican> Solonarv: Great, it looks promising!
08:07:38 <alp> yeah, same principles. there's more going on because we're dealing with HTTP :)
08:07:55 <phadej> but people are less scared to use latter (though there are "defaults", so it's indeed easier to start)
08:08:19 <Solonarv> idunno, I've always found generics to be annoyingly noisy/complex
08:08:23 <alp> britican, servant might be a bit hard to digest at first, but many have done it, many have given up too.
08:08:31 <alp> well we picked reasonable name for things, that's the big difference IMO
08:08:40 <alp> + quantity of docs
08:15:40 * hackage primitive-extras 0.6.1 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.6.1 (NikitaVolkov)
08:18:28 <drbrule> hello all
08:19:00 <drbrule> I am attempting to get `nix build` to actually output all Haskell Spec tests.
08:19:14 <drbrule> Anyone have any clue how to accomplish that?
08:21:20 <JuanDaugherty> ask in #nixos?
08:24:02 <JuanDaugherty> of course you could actually learn how to script nix
08:25:40 <ph88> i have this constraint on all my functions (MonadReader Env m, MonadIO m, MonadRandom m, RandomSource m (Gen RealWorld))  is it possible to make an alias for this ?
08:26:27 <drbrule> Yeah I'm still learning nix
08:26:40 <drbrule> For some reason, maybe it's a doc issue, but I'm learning slowly.
08:26:54 <drbrule> I also did cross-post to #nixops
08:27:07 <madnight> better use cabal2nix
08:31:44 <dmwit> ph88: Sure, `type Foo m = (MonadReader Env m, ...)`.
08:32:09 <ph88> o_O wow
08:32:16 <c_wraith> dmwit, as long as you enable ConstraintKinds
08:32:23 <juhp> Is there a best practice for building packages without a Setup file without cabal-install - well just one's own, right?
08:32:29 <dmwit> Yep. But I don't bother saying so any more, because the compiler says it for me. =)
08:32:55 <dmwit> juhp: Why is that a goal?
08:33:12 <juhp> packaging :)
08:33:27 <dmwit> Why does packaging require you to not have a Setup file and not use cabal-install?
08:34:07 <juhp> hmm fair question - well there could be a bootstrapping issue too then
08:34:15 <dmwit> If you are doing binary packaging, you don't need to build. If you are doing from-source packaging, you need to package your build tools, too.
08:34:33 <Athas> You can invoke ghc directly.
08:34:33 <madnight> juhp: packaging for me is: cabal sdist
08:34:42 <Athas> Basically do what cabal-install would do, but do it by hand.
08:34:45 <juhp> I mean distro packaging
08:34:58 <dmwit> Surely for distro packaging you want a binary anyway.
08:35:04 <dmwit> No building on the package receiver at all.
08:35:13 <juhp> You lost me
08:35:15 <juhp> indeed
08:35:30 <juhp> I am talking about building the binary package
08:35:32 <c_wraith> what if you're arch and want to break ghc on every installation instead?
08:35:40 <juhp> haha
08:35:43 <dmwit> So then it's not important that building happen without Setup or without cabal-install. Because it's happening on *your* machine, not the package receiver's machine.
08:35:55 <juhp> indeed
08:36:06 <dmwit> So... problem solved?
08:36:19 <juhp> erm
08:36:50 <juhp> nvm - I was asking if there is something better than just injecting a Setup.hs file
08:37:16 <dmwit> No. cabal init will generate the standard Setup.hs for you.
08:37:24 <dmwit> Then the rest of cabal will proceed to ignore it.
08:37:29 <juhp> I think currently about 99% of packages on Hackage have Setup file...
08:37:31 <dmwit> It is the way of legacy systems.
08:37:34 <juhp> okay
08:37:51 <sclv> the Setup.hs only matters if you have a custom build type
08:43:43 <juhp> I know
08:44:07 <juhp> But some are appearing now without Setup.*hs
08:44:24 <juhp> Anyway thanks guys - I will make about it
08:44:41 <juhp> will *think* more *
08:49:02 <juhp> Still need to build cabal-install anyway
08:50:02 <mimi_vx> dmwit: no this is way of sane systems
08:50:17 <juhp> I am tempted to make a cabal-simple package...
08:52:06 <sclv> i don't understand what's wrong with just using cabal-install
08:52:37 <sclv> or a raw Setup.hs file, and for those with a standard build type using the default file
08:52:39 * hackage yesod-auth-oauth2 0.5.1.0 - OAuth 2.0 authentication plugins  http://hackage.haskell.org/package/yesod-auth-oauth2-0.5.1.0 (PatrickBrisbin)
08:53:19 <sclv> (I guess that's what cabal-simple would do? wrap up the "all dependencies explicitly provided" path in a standard way? some of the existing distro-packaging tools might already do similar things...)
08:57:01 <ph88> i have X possible states .. how can i count how often one state transition to another state? I'm thinking of a matrix of Int, but i'm not sure if that is a good idea
08:58:22 <juhp> sclv: nothing wrong perhaps - well I haven't tried...
08:58:36 <c_wraith> ph88, like for gathering statistics from a run of a state machine?
08:59:15 <juhp> compiling Setup or runghc'ing it each time is kind of wasteful I suppose
08:59:29 <drbrule> ok, so my solution is: `nix-shell --command "runhaskell Setup.hs configure --enable-tests; runhaskell Setup.hs build; runhaskell Setup.hs test"`
08:59:30 <c_wraith> ph88, my first impulse would be something like Map (State, State) Int
09:00:19 <c_wraith> ph88, especially since the actual set of state transitions on a machine with a lot of states is probably sparse, so a matrix would waste a lot of space.
09:00:29 <ph88> c_wraith, yes .. i want to do calculate markov chain
09:00:59 <Solonarv> yeah, Map (State, State) Int or something similar would be the solution
09:01:10 <c_wraith> ph88, yeah, that's an example of sparse transition data.
09:01:32 <Solonarv> or maybe Map State (Map State Int), same thing; or replace Map with HashMap or some other variant
09:02:18 <ph88> example of counting transition frequency:  https://bpaste.net/show/b60cf4e2bd28
09:02:30 <ab9rf> is there any real advantage to using nested maps as opposed to a map with a tuple key?
09:02:55 <c_wraith> just mind strictness. folding over a Map is an easy way to get unevaluated thunks if you aren't careful.
09:03:06 <ph88> i heard HashMap sweeps the floor with Map when it comes to performance .. is this true ?
09:03:17 <cocreature> ab9rf: a nested map allows you for a given x to get all y where there is an entry (x,y)
09:03:26 <ab9rf> cocreature: ah, good point
09:03:37 <cocreature> whether that is an important operation depends on your application
09:03:47 <c_wraith> for a Markov chain, that probably is important
09:05:20 <Solonarv> I'm not sure how they compare on small key sets, but for large maps HashMap does blow Map out of the water
09:05:50 <ab9rf> also, if your keys are ints, you can use IntMap, which is much faster than Map
09:05:53 <ph88> c_wraith, what's "sparse transition data" ?
09:06:19 <Solonarv> "sparse" simply means there isn't an entry in every possible spot
09:06:26 <ph88> ah ok
09:06:37 <c_wraith> it also implies that most entries are empty.
09:06:53 <ab9rf> if most entries are not empty, you may be better off using vectors
09:07:34 <ab9rf> but such transition matrices tend to be quite sparse in practice
09:08:38 <c_wraith> most graphs are sparse in practice. which is why Dijkstra's shortest path algorithm is usually better than Kruskall's
09:09:45 <c_wraith> and why you get crazy heap types that are designed with a bunch of operations specifically to make Dijkstra's algorithm as efficient as possible.
09:11:32 <c_wraith> like the "decreaseKey" operation. I've never wanted that in a general purpose heap, but it's critical for Dijkstra's algorithm.
09:13:10 <ph88> i'm thinking after i have the table to do R squared analyses on the state variables to see which one is significant
09:13:39 * hackage hmatrix-svdlibc 0.5.0 - SVDLIBC bindings for HMatrix  http://hackage.haskell.org/package/hmatrix-svdlibc-0.5.0 (BenGamari)
09:14:50 <ph88> some part of the state are lists .. and i'm also trying to decide how much of the possible variables i should include in the state
09:15:14 <ph88> if i make the state too much unique i might miss opportunity to compact several states into one (simplifying the probabilities)
09:15:34 <ph88> maybe i capture everything and later try to cluster ?
09:19:55 * ph88 thinking out loud
09:27:40 * hackage bit-protocol 0.2.3.0 - Encode binary protocols with some odd bit numbers into a bytestring  http://hackage.haskell.org/package/bit-protocol-0.2.3.0 (k_bx)
09:35:05 <mbwgh> I just noticed that `System.IO.doesDirectoryExist ""` yields True. Is this to be expected?
09:35:36 <mbwgh> Sorry, I meant `System.Directory`, not `System.IO`.
09:36:37 <ph88> i'm not sure if i should choose a lazy or strict hashmap .. advice ?
09:39:09 * hackage ats-pkg 3.1.0.6 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-3.1.0.6 (vmchale)
09:39:17 <ChaiTRex> Is it possible to get the optimization level GHC is compiling code with in Template Haskell?
09:40:09 * hackage brick 0.39 - A declarative terminal user interface library  http://hackage.haskell.org/package/brick-0.39 (JonathanDaugherty)
09:44:25 <bjobjo> have anyone here tried Obelisk?
09:45:21 <ph88> when i want to update or write things to a hashmap can i use WriterT or should i use StateT ?
09:46:09 <glguy> StateT, hashmaps don't stream well and aren't a good candidate for use with Writer
09:46:40 * hackage simple-stacked-vm 0.1.2 - Simple stacked virtual machine: assembler, disassembler, bytecode interpreter  http://hackage.haskell.org/package/simple-stacked-vm-0.1.2 (IlyaPortnov)
09:49:05 <ph88> oki
09:51:08 <mbwgh> How can I load some package with lambdabot?
09:53:21 <glguy> mbwgh: You can't add packages to lambdabot, unless you're asking about your own local lambdabot instance.
09:54:49 <blair__> Hey folks, silly question. I'm getting started writing haskell after not spending much time with it for a few years, and it seems like there are different emacs tools these days. Does anyone know what's recommended for an emacs user these days? I more or less have to rewrite my haskell config
09:55:09 <ph88> is there a data type like a list but where the order does not matter? I need this to test for equality (order doesn't matter). So ABC should be the same as CBA
09:55:36 <mbwgh> glguy: I thought I saw people do this. But there is also some other bot around here, which I assume I am confusing it with.
09:56:08 <mbwgh> ph88: Like a Set?
09:56:13 <ClaudiusMaximus> ph88: you could use   Ord a => Map a Int  where each Int > 0 is the count
09:56:46 <agentultra> blair__: I've been having great success with Intero
09:57:09 <ph88> mbwgh, isn't a set unique in values ? so AABC is not possible ?
09:57:33 <dmwit> ?hackage multiset ph88
09:57:33 <lambdabot> http://hackage.haskell.org/package/multiset ph88
09:57:37 <ph88> or maybe it's better to implement my own function to test the equality ?
09:57:40 <dmwit> Or just call `sort` on your list first.
09:57:48 <dmwit> :t \xs ys -> sort xs == sort ys
09:57:49 <lambdabot> Ord a => [a] -> [a] -> Bool
09:57:50 <ph88> ah ye maybe that is the best
09:58:04 <ph88> then it would be nice to have some traverser to sort all the lists for me
09:58:12 <ph88> because it's a nested structure
09:58:17 <blair__> agentultra: Thanks. Any idea what the difference is between that and dante?
09:58:20 <cocreature> mbwgh: there is the yahb bot but you can‚Äôt add packages to that either
09:58:22 <dmwit> :t fmap sort
09:58:23 <lambdabot> (Ord a, Functor f) => f [a] -> f [a]
09:58:36 <ph88> fmap is only for the top level right ?
09:58:43 <dmwit> mbwgh: Was your question precise? If you just meant import a module of a package it already has, you can use ?let for that.
09:58:53 <dmwit> ph88: No idea what "top level" means.
09:59:14 <agentultra> blair__: the auto completion is a tiny bit slow and you have to restart the intero instance when module export lists change; but those are pretty minor things.
09:59:36 <ph88> data Top = Top Other     data Other = Other B C     data A = A List List   data B = B List List
09:59:39 <ddellacosta> blair__: intero is definitely nice, otherwise if you don't want to be attached to stack for some reason I've been using Dante with some success, although I had to fiddle around with it more than when I started with Intero
09:59:46 <ph88> dmwit,  ^
10:00:03 <agentultra> blair__: combined with everything in emacs-prelude I get a really nice IDE experience.
10:00:28 <mbwgh> I just wanted to try `doesDirectoryExist mempty` and see if it evaluated to true here as well. On the off chance that the directory package was available here, despite possible security issues :)
10:00:46 <blair__> agentultra, ddellacosta: Sweet deal. Thanks, will try that out!
10:00:48 <dmwit> ph88: With a slight modification, you could write `data Top a = Top (Other a); data Other a = Other (B a) (C a); data B = B [a] [a]; data C = C [a] [a]` and derive `Functor` for all of them. Then `fmap :: (a -> b) -> (Top a -> Top b)` will change all contained `a`s.
10:01:03 <dmwit> % import Data.Directory
10:01:03 <yahb> dmwit: ; <no location info>: error:; Could not find module `Data.Directory'; Perhaps you meant Data.Vector (from vector-0.12.0.1)
10:01:09 <agentultra> flycheck works wonderfully, jump to definition, type and information all work, integration with the repl is tight.
10:01:17 <dmwit> % import System.Directory
10:01:18 <yahb> dmwit: 
10:01:22 <dmwit> % doesDirectoryExist "foo"
10:01:22 <yahb> dmwit: False
10:01:30 <geekosaur> mbwgh, on POSIX it's required to. (mempty on a list is [], empty path is illegal on POSIX and tested in the spec)
10:01:35 <ph88> dmwit, i don't think i want to allow to paramartize that type
10:01:41 <dmwit> mbwgh: lambdabot also has System.Directory, but does not execute IO actions.
10:01:59 * dmwit shrugs in ph88's general direction
10:02:05 <ph88> :P
10:02:39 * hackage semirings 0.2.0.1 - two monoids as one, in holy haskimony  http://hackage.haskell.org/package/semirings-0.2.0.1 (chessai)
10:02:57 <cocreature> ph88: if your type is not parametrized then fmap doesn‚Äôt work anyway
10:02:58 <dmwit> % doesDirectoryExist mempty
10:02:58 <yahb> dmwit: True
10:03:18 <geekosaur> interesting
10:03:52 <geekosaur> empty string was made illegal so nbonunix could pass (namei() historically treats as ".")
10:05:29 <mbwgh> Ok I am not sure I am following. First of all, it seems platform dependent. I can live with that. But if the empty path is illegal, I wouldn't expect this function to return True.
10:06:00 <dmwit> % System.Posix.Files.fileExist mempty
10:06:01 <yahb> dmwit: False
10:06:25 <dmwit> I don't think System.Directory is intended to be related to POSIX in any special way.
10:06:57 <cocreature> the directory package is cross-platform so enforcing posix semantics everywhere would be fairly hard
10:08:05 <mbwgh> Yeah I always confuse the directory and filepath packages. filepath has a Posix module that gets CPP'ed in.
10:09:22 <mbwgh> For me personally, if there is no Posix compliancy necessary, returning true does not seem like a sensible default here. I'll just have to wrap this function.
10:10:59 <cocreature> % getFileStatus ""
10:10:59 <yahb> cocreature: ; <interactive>:84:1: error: Variable not in scope: getFileStatus :: [Char] -> t
10:11:08 <cocreature> % import System.Posix.Files (getFileStatus)
10:11:09 <yahb> cocreature: 
10:11:10 <cocreature> % getFileStatus ""
10:11:11 <yahb> cocreature: *** Exception: : getFileStatus: does not exist (No such file or directory)
10:11:50 <dmwit> % "" </> "foo"
10:11:50 <yahb> dmwit: ; <interactive>:87:4: error:; * Variable not in scope: (</>) :: [Char] -> [Char] -> t; * Perhaps you meant one of these: `Text.PrettyPrint.HughesPJ.<>' (imported from Text.PrettyPrint.HughesPJ), `<>' (imported from Prelude), `<*>' (imported from Prelude)
10:11:53 <cocreature> % getFileMetadata ""
10:11:53 <yahb> cocreature: ; <interactive>:88:1: error: Variable not in scope: getFileMetadata :: [Char] -> t
10:12:00 <cocreature> % import System.Director.Internal
10:12:00 <geekosaur> huh. was wondering. so is that a compat thing?
10:12:00 <yahb> cocreature: ; <no location info>: error:; Could not find module `System.Director.Internal'; Perhaps you meant; System.Directory.Internal (from directory-1.3.2.3); System.IO.Echo.Internal (from echo-0.1.3)
10:12:02 <cocreature> % getFileMetadata ""
10:12:02 <yahb> cocreature: ; <interactive>:90:1: error: Variable not in scope: getFileMetadata :: [Char] -> t
10:12:04 <geekosaur> (I can see that)
10:12:12 <cocreature> % import System.Directory.Internal
10:12:12 <yahb> cocreature: 
10:12:14 <cocreature> % getFileMetadata ""
10:12:14 <yahb> cocreature: 
10:12:24 <dmwit> % import System.FilePath
10:12:24 <yahb> dmwit: 
10:12:35 <dmwit> % "" </> "foo"
10:12:35 <yahb> dmwit: "foo"
10:12:58 <dmwit> mbwgh: I believe this explains why `doesDirectoryExist ""` -> `True` is sensible.
10:13:03 <dmwit> "" is just an alias for ".", basically.
10:13:22 <geekosaur> right, which is pre-posix unix behavior
10:13:29 <geekosaur> which is why I wonder if it's compat
10:15:09 <cocreature> ah it‚Äôs the "normalise" function in the "filepath" package that causes this behavior for "directory"
10:16:12 <mbwgh> I just know that if I actually call it with the empty path in my program, I will have screwed up somewhere.
10:16:54 <dmwit> Ah, so you want it to throw an exception instead? =)
10:17:57 <kwalekko> hi
10:18:29 * dmwit waves
10:18:57 <kwalekko> am new to the IRC community
10:19:12 <kwalekko> so kind of confused how things work here
10:19:13 <mbwgh> dmwit: True, from this kind of view, returning False wouldn't really make sense either of course.
10:20:48 <cocreature> kwalekko: channels usually have a topic. the topic of this channel is the Haskell programming language so if that‚Äôs not what you‚Äôre looking for, you‚Äôll havet o find a different channel :)
10:21:33 <kwalekko> yes actually this is the channel I am looking for
10:22:26 <cocreature> great! in that case just ask your question or stick around and try to answer other people‚Äôs questions :)
10:23:37 <kwalekko> Okay, Thanks you. I am looking to evaluate my Haskell knowledge
10:24:10 <Ariakenom> > 1+1 -- evaluate haha
10:24:12 <lambdabot>  2
10:24:26 <kwalekko> haha 
10:25:17 <kwalekko> is this place suitable for asking about code review?
10:25:28 <Cale> Hey dmwit, was nice to meet you in person unexpectedly :D
10:25:40 <dmwit> Same! I learned my Haskell elevator pitch is lousy. =)
10:25:44 <Cale> haha
10:26:38 <dmwit> kwalekko: Have courage. If you break the rules, we'll tell you. =)
10:27:04 <Cale> (Just don't paste large amounts of code into the channel)
10:27:22 <dmwit> Right. Pastebins are the way to go for large pastes.
10:27:23 <kwalekko> what about pointing to GitHub page?
10:27:30 <dmwit> That's fine.
10:28:13 <kwalekko> https://github.com/kwaleko/Payroll/blob/master/src/Core/Leaves.hs
10:28:43 <revskill> > (0.1 + 0.02) + 0.3 == 0.1 + (0.02 + 0.3)
10:28:45 <lambdabot>  False
10:28:58 <revskill> lambdabot: You're wrong about Math
10:29:34 <Ariakenom> > (0.1 + 0.02 :: Rational) + 0.3 == 0.1 + (0.02 + 0.3)
10:29:36 <lambdabot>  True
10:29:44 <Ariakenom> just be Rational about it
10:29:50 <cocreature> revskill: you‚Äôre wrong about ieee754 :)
10:29:52 <revskill> Ariakenom: Thanks
10:30:22 <mnoonan> kwalekko: the isJust / fromJust is a bit of a smell. do you know of mapMaybe?
10:30:34 <mnoonan> :t mapMaybe
10:30:35 <lambdabot> (a -> Maybe b) -> [a] -> [b]
10:31:30 <revskill> cocreature: Thanks for the name for that standard :)
10:32:58 <kwalekko> I did not like fromJust as well, but I thought it would be ok cz I was filtering the isjust value. you are right
10:33:16 <dmwit> revskill: If this is your first time observing this kind of thing, you may enjoy https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
10:34:31 <revskill> dmwit: Yes, i never got serious about it. This is a nice chance to dig deeper on the subject. Huge thanks everyone
10:36:48 <kwalekko> mnoonan: thanks for pointing to mapMaybe
10:36:59 <kwalekko> I did not know about it before
10:37:16 <mnoonan> it's a handy one.. I think the name makes it un-obvious that it can replace some filters
10:38:45 <cocreature> kwalekko: you could consider using "guard" around line 50
10:39:14 <Zemyla> I kind of wish this function existed in Prelude:
10:39:45 <Zemyla> @let maybeBounded :: forall a. (Integral a, Bounded a) => Integer -> Maybe a; maybeBounded = let { minb = toInteger (minBound :: a); maxb = toInteger (maxBound :: a); go i | i >= minb && i <= maxb = Just $! fromInteger i; go _ = Nothing } in go
10:39:46 <lambdabot>  Defined.
10:43:09 <Zipheir> There's nothing wrong with writing a parametric type synonym, is there? e.g. type Queue a = ([a],[a])
10:43:34 <kwalekko> cocreature: Thanks for the suggestion 
10:43:41 <kwalekko> I will replace it
10:44:28 <quicksilver> kwalekko: as another interesting option you can use a pattern in a list comprehension
10:44:35 <cocreature> Zipheir: no that‚Äôs fine although sometimes (and your example appears to be one of those cases) creating a separate datatype using data/newtype might be a better idea
10:45:00 <kwalekko> may I share my test as well to get some feedback?
10:45:02 <quicksilver> abs = [ x | Just x <- absPayCode .... ]
10:45:57 <dmwit> Zemyla: Yes, me too.
10:47:18 <Zipheir> cocreature: Thanks. IIUC, data/newtype might be better for a Queue type because one might want to provide some useful instances for it--or am I way off?
10:48:46 <cocreature> Zipheir: there‚Äôs that but I‚Äôd say the bigger advantage is that a separate datatype actually enforces a certain level of abstraction whereas a type synonym just provides a different name for the same type. unless you intend to actually use these types interchangably (e.g. pass the queue to some function that expects an arbitrary tuple) there is little advantage tou sing a type synonym
10:48:58 <dmwit> Zipheir: instances, yes; also: if you make it a record, you can give the two fields descriptive names that may help readers/writers; you can attach documentation to it with Haddock; you can have the typechecker verify that you're using the approved API for it instead of the tuple API; and a few others.
10:50:46 <Zipheir> Ah, that makes perfect sense.
10:50:49 <Ariakenom> kwalekko: (,) fdate $ lstMDay fdate      at line 66 is pretty strange
10:50:58 <Zipheir> Thanks very much, dmwit & cocreature.
10:51:07 <dmwit> Zipheir: https://stackoverflow.com/a/19073039/791604
10:51:43 <cocreature> as a rule of thumb, I generally default to using a separate type unless I have a specific reason to use a type synonym instead of the other way around
10:52:52 <Zipheir> dmwit: That's quite helpful.
10:53:17 <kwalekko>   <Ariakenom> : you think this better?   (fdate , lstMDay fdate)
10:53:32 <Zipheir> Yeah, the abstraction offered by creating a new type is a win over whatever convenience 'type' provides, it seems.
10:54:15 <Ariakenom> kwalekko: exactly
10:54:15 <c_wraith> type is useful if you want to do something that would otherwise require an obfuscation number of tokens
10:54:36 <c_wraith> that's about the only time I've found it useful
10:54:58 <kwalekko> <Ariakenom> Noted thanks a lot
10:55:31 <kwalekko> what do you think about my test? https://github.com/kwaleko/Payroll/blob/master/test/LeaveSpec.hs
10:57:19 <dmwit> kwalekko: You might want to look into QuickCheck (or hedgehog I guess is an alternative) for testing.
10:58:20 <dmwit> kwalekko: This would let you say things like, say, "in the output of split, all start days except the first one should be day 1 of their month", and "in the output of split, all pairs should have the same month", and similar such high-level properties. Then the library would generate hundreds of random test cases for you and verify that the property holds in all of them.
10:58:30 <kwalekko> <dmwit> line 43 and 50 I have used quick check property with hspec
10:58:49 <cocreature> the first two tests should also be translatable to property tests fairly easily
11:01:22 <dmwit> sure
11:01:33 <monochrom> BogoCheck = you write a test case, e.g., "f(2) should be 3". The computer picks a random number until it's 2...
11:01:46 <ph88> is there any reason for the main module to have an export list ?
11:02:02 <kwalekko> <dmwit>  thanks a lot for examplifying, it makes it easier for me to write property now
11:02:51 <monochrom> Yes if you write "module X(main)", no if you don't write a module header at all.
11:03:37 <dmwit> ph88: Sure, the Main module can be imported by other modules (!).
11:04:01 <dmwit> I don't think I've seen this done very often, but nothing in the spec prevents it.
11:04:35 <geekosaur> it would requie sane handling of circular imports, which ghc lacks
11:05:04 <dmwit> Or Main could be a module in the library, either hidden or otherwise.
11:05:14 <dmwit> If otherwise, you should be banned from Hackage. ;-)
11:06:21 <dmwit> It would have to be a pretty weird library architecture to make importing Main in other exposed library modules both non-circular and useful, though.
11:08:34 <monochrom> Suppose you have "main = do { r :: Integer <- read <$> getLine; print (f r)};  f x = x + x"
11:09:41 <monochrom> With "module X(main)" or no module header at all, the code contains just one copy of f, and it's specialized to Integer, and most likely so-called "one copy of f" manifests as inlined code.
11:10:29 <monochrom> But with "module X", you get a second copy of generalized f :: Num a => a -> a.  And it is unused so it's dead weight.
11:11:19 <monochrom> Therefore, there is always a reason to write a meticulous export list, and there is always a reason to not write anything.
11:11:29 <glguy> Putting an explicit export list on the Main module is helpful for getting warnings about unused code
11:11:34 <monochrom> But there is never a reason to write a module header without an export list.
11:12:13 <glguy> It's useful to write a module header without an export list if you want to be able to compile a module that doesn't have main defined and aren't ready to list all the things you want to export
11:12:46 <monochrom> Oh I do that all the time too.  But it's laziness not reasonness.
11:13:00 <monochrom> "I will fix it when it's out of beta."
11:14:13 <monochrom> Guess what? The ESR bazaar-not-cathedral philosophy implies that you're never out of beta. >:)
11:17:05 <monochrom> Next, let's argue over import lists. >:)
11:17:16 <ph88> can i have an import list together with hidden list ?
11:17:31 <monochrom> I think no. But IANAL.
11:18:05 <ph88> i get strange characters with this error (there are actually more strange characters which arent displayed)  https://bpaste.net/show/de4916a10f4a
11:18:06 <dmwit> Why would you want that?
11:18:13 <glguy> Either explicit import lists, or qualified imports are useful if you want to have upper bounds that only guard up to a major version
11:18:23 <dmwit> Like, why wouldn't you just delete the things you plan to hide from your explicit import list?
11:18:23 <monochrom> The grammar says no. Too bad. Would be fun to have.
11:18:53 <revskill> I have a question about Monad Transformer stack: i have a Metrics Monad to collect metrics in production, but i don't want to use it in test, what's a good way to enable/disable that metrics for specific environment ?
11:18:54 <geekosaur> ph88, that's utf8 characters being used in an iso8859 context. check locale
11:19:09 <revskill> Currently i have to use type Maybe Metrics for that, and use Nothing for test
11:19:12 <dmwit> ph88: Those are probably fancy curved backquotes and frontquotes.
11:19:23 <ph88> ok
11:19:57 <madnight> https://news.ycombinator.com/item?id=17645277
11:21:10 <revskill> My stack is simply a ReaderT AppConfig IO
11:21:39 * hackage vinyl 0.9.0 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.9.0 (AnthonyCowley)
11:23:03 <revskill> madnight: hey, is it an answer ? 
11:23:45 <nitrix> It's the full thread.
11:24:22 <koala_man> ph88: is this in screen or tmux? if so, those add a layer of conversion that could explain why it's being double-encoded
11:24:39 <dmwit> % T.decodeUtf8 (BS.pack [226,128,152])
11:24:39 <yahb> dmwit: "\8216"
11:24:41 <dmwit> > text "\8216"
11:24:43 <lambdabot>  ‚Äò
11:24:47 <dmwit> Yes, fancy quote. =)
11:25:24 <nitrix> I read the blog and it saddens me. The quoted definition of Monad is very rich in information and the author discarded what he didn't understand with it instead of trying to find its meaning. Therefore, his whole article is already misguided. "Monads in Haskell are used as a mechanism for scheduling evaluation". It isn't.
11:26:36 <nitrix> What follows goes even more off-track :(
11:26:41 <revskill> I'm comfortable with Monad without understanding what it really is. I just want to know what's the recommended way to change the ReaderT env between environments
11:26:49 <revskill> My way of using Maybe seems hacky
11:27:20 <nitrix> revskill: Just to be clear, I'm responding to a different conversation also happening in the channel :)
11:27:46 <selfsymmetric-pa> revskill: You mean like the `local` function?
11:28:23 <cocreature> revskill: it might be helpful if you can produce some minimal example to demonstrate what you are trying to do.
11:28:52 <revskill> i'm using EKG metrics to collect metrics in code
11:28:59 <revskill> But in test, i don't want it
11:29:19 <revskill> Currently, i have to use Maybe Metrics type in the AppConfig
11:29:39 <revskill> so in test, i put Nothing to keep type-checked.
11:29:43 <revskill> Is there better way ?
11:31:01 <cocreature> you could add a type parameter to AppConfig and if you set that to Production the field will resolve to Metrics, and if you set it to Test it will resolve to something like ()
11:31:03 <revskill> selfsymmetric-pa: No. The code is using the getMetrics function
11:31:08 <nitrix> madnight: The blog and the thread is bogus. IO does not depend on monads, monads are not used solely for sequencing things, and the evaluation strategy Haskell chose is mostly unrelated as well. They are all orthogonal concepts that happens to be combined together because it's convenient to do so.
11:31:53 <selfsymmetric-pa> Or just do it on the value level. Add a `IsTest` parameter to your `AppConfig` and have your metrics-recording code read it.
11:32:02 <ph88> why does state need 2 type variables? why not just get the same type out and put it back in ?
11:32:32 <nitrix> ph88: `State` or `state` ?
11:32:50 <ph88> State
11:33:03 <selfsymmetric-pa> ph88: You could certainly write a state like that. It's just less flexible. `PhState a = State a a`.
11:33:15 <selfsymmetric-pa> But sometimes you want your state type to be different from your result type.
11:33:22 <nitrix> ph88: The second type variable isn't the state :P
11:34:19 <madnight> nitrix: the discussions on HN are usually of good quality
11:34:25 <nitrix> ph88: Given `State s a`, `s` will be the type of the state that's maintained by the computation, `a` will be the type of the result of that computation.
11:34:27 <cocreature> the idea behind State s a is that it represents a way of producing an "a" while being able to modify a variable of type "s". if you restrict it you just get functions a -> a
11:34:28 <ph88> well it's a hashmap .. at the finish of the state i need to filter it and then merge with another hashmap
11:35:04 <cocreature> if you just want to return the new state instead of a separate value, just use a regular function instead of State
11:35:27 <ph88> ok
11:35:57 <revskill> selfsymmetric-pa: The problem with value level is that, in test, your code still needs Metrics type
11:36:24 <selfsymmetric-pa> revskill: Ah, I see.
11:36:56 <nitrix> ph88: The distinction is that, if you view `State s a` as a serie of mutations, each mutation has the form (s -> (s, a)) where each mutation receives the previous state and produces a new state, but it doesn't receive the previous result; it may only decide of a newer result.
11:37:05 <nitrix> ph88: The `s` is stateful, not the `a`.
11:39:03 <nitrix> e.g. (\s -> ((+1), "Hello!")) >>= (\s -> ((*2), "Bye!")), both (+1) and (*2) are applied on the state, yet only "Bye!" is kept for the final result.
11:42:10 * hackage http-link-header 1.0.3.1 - A parser and writer for the HTTP Link header as specified in RFC 5988 "Web Linking".  http://hackage.haskell.org/package/http-link-header-1.0.3.1 (myfreeweb)
11:48:35 <gobby> getting `Not in scope: type constructor or class ‚ÄòGeneric‚Äô` even after adding `DeriveGeneric` as a language pragma
11:48:44 <glguy> import GHC.Generic
11:48:53 <glguy> import GHC.Generics
11:48:57 <gobby> strange, I never had to with other modules
11:48:57 <ph88> thx nitrix 
11:49:17 <glguy> gobby: this is the normal behavior
11:51:54 <nitrix> ph88: I meant s+1 and s*@ in those lambda, but I think you get the point :P
11:51:57 <nitrix> s*2
11:54:01 <gobby> thanks glguy 
11:54:03 <orion> Does Lens have a monadic version of "over"? I need to pluck out a Foo value deep within a nested structure, run an IO action Foo -> IO Foo, and set the aforementioned value to the resultr.
11:54:48 <selfsymmetric-pa> orion: `traverseOf`, maybe?
11:55:21 <cocreature> orion: id
11:55:31 <cocreature> or yeah traverseOf but that‚Äôs literally just id :)
11:56:13 <noidedsuper> How do you use that?
11:57:00 <noidedsuper> IE, if l is a Lens' a b, f is a (a -> IO a), and b is a value of type b
11:57:06 <orion> Oh, cool.
11:57:50 <ph88> was there an extension to allow the same name record fields in different records ?
11:58:11 <nitrix> traverseOf :: LensLike f s t a b -> (a -> f b) -> (s -> f t), a ~ b, s ~ t for simple lenses, I believe?
11:59:34 <nitrix> Everytime I jump from Lens to LensLike I get confused.
12:00:11 <cocreature> type Lens s t a b = forall f. Functor f => LensLike f s t ab
12:02:17 <nitrix> The getter is (s -> a), the setter is (s -> b -> t) ?
12:03:13 <cocreature> yep
12:03:15 <cocreature> :t lens
12:03:16 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
12:04:56 <nitrix> I know what angers me then, it's that "stab" :P
12:05:10 <kwalekko> dimwit : what do you think ?   describe "split" $ do    it "all start date except the first one should be day 1 of their month" $ do      property $        \date1 date2 -> map (\(d1,_) ->  (fst3 .toGregorian) d1 == 01)  (tail (split date1 date2)) `shouldNotContain` [False]
12:06:12 <nitrix> kwalekko: lpaste.net, your do-blocks are unreadable.
12:07:48 <kwalekko> nitric : thank for pointing . https://lpaste.net/8832878820097785856
12:10:53 <nitrix> kwalekko: Checking your code :) Btw, you can autocomplete my name by writing the first few characters and pressing the <tab> key!
12:11:52 <kwalekko> nitrix: Thanks. sorry for inconveniece.
12:14:21 <ben> is haskell a good lang for writing games in that are then compiled to webassembly
12:14:48 <anon_> is there static code analysis written in haskell?
12:15:02 <nitrix> kwalekko: I don't like the `map`, you're using pointfree, then not, then doing some grouping manually when the precedence of function application already would take care of it.
12:15:12 <anon_> tool*
12:15:52 <nitrix> kwalekko: You could probably rewrite it as `map convertGregorian` and have a where clause for `convertGregorian = ((== 01) . fst3 . toGregorian . fst)`
12:17:39 <shapr> anon_: bluespec does ASIC design analysis, but it costs money
12:17:57 <shapr> anon_: there are tools like corrode (in Haskell) that turn C into Rust
12:17:59 <mnoonan> anon_: I wrote some stuff when I was at GrammaTech, but it was for contract work that (probably) hasn't made it into a product.
12:18:33 <shapr> anon_: I've found language-c language-go and several other libraries for parsing a source language into a Haskell datatype
12:18:36 <mnoonan> Galois has SAW
12:18:40 <shapr> some of those are used for static analysis
12:18:54 <shapr> https://saw.galois.com/
12:19:20 <shapr> galois also has reopt, it decompiles a binary into LLVM intermediate representation, and then recompiles using LLVM
12:19:29 <shapr> lots of nifty tools like that in the Haskell world
12:19:37 <shapr> anon_: do you have a particular language in mind?
12:19:38 <nitrix> kwalekko: Something that conveys the intention a little more than juggling lambda, like https://lpaste.net/8808597179540176896
12:20:21 <nitrix> Or modify toGregorian if you can.
12:20:33 <nitrix> lambda/tuples.
12:22:50 <kwalekko> nitrix: Thank, more elegant and readable
12:23:22 <nitrix> kwalekko: I'd personally use `or`/`any` and check that against my assertion with `shouldBe`/`shouldNotBe`, it could avoid doing [False] just for the sake of matching types, but up to you :P
12:23:29 <nitrix> I don't know what else I could nitpick :P
12:24:16 <kwalekko> nitrix: I think I should come up with better design, since when it fails it show unreadable message
12:24:17 <kwalekko>  [False] does contain [False] (after 22 tests):        1858-11-13        1858-12-02
12:25:12 <nitrix> It's supposed to tell you the message given by "it", then which values triggered it.
12:27:44 <nitrix> =/
12:29:18 <kwalekko> nitrix: it displays the value in the order given to the function right?
12:31:44 <anon_> shapr: i'd like to build one for fun and profit and no i dont think a specific lang
12:32:19 <anon_> shapr: i'll check them, ty
12:55:52 <tieTYT> I‚Äôve got a web server that‚Äôs connecting to a database to list all the rows, but if I insert a new row, it doesn‚Äôt show it when I refresh the page.  I‚Äôm pretty new to haskell.  Is this a haskell issue or a feature with the postgresql client?  https://gist.github.com/dkaplan-pivotal/db5faaeeca42f6d2aeaf1223052aa670
12:58:44 <tieTYT> I think it might be because of line 10.  I get the text on startup, but I should be getting it whenever someone calls the endpoint?
13:00:06 <tieTYT> but I don‚Äôt know how to call getList :: Connection -> IO [Text] inside a function that is of listResource :: [Text] -> ScottyM ()
13:00:11 <tieTYT> can anyone help me with that?
13:00:16 <hexagoxel> tieTYT: yes, exactly that is very likely to be the reason
13:02:15 <hexagoxel> tieTYT: due to the MonadIO instance you should be able to use liftIO inside `listResource` to run `getList`
13:02:39 * hackage streaming-bracketed 0.1.0.0 - A resource management decorator for "streaming".  http://hackage.haskell.org/package/streaming-bracketed-0.1.0.0 (DanielDiazCarrete)
13:02:41 <tieTYT> never heard of that function, I‚Äôll look it up
13:02:51 <hexagoxel> and of course you don't need the [Text] arg anymore
13:03:20 <tieTYT> I‚Äôd need a connection instead, I imagine
13:03:31 <hexagoxel> right
13:03:32 <tieTYT> I‚Äôve never heard of MonadIO actually.  I‚Äôve only just finished LYAH
13:05:21 <tieTYT> so this turns the IO a into a MonadIO a ?  What would I do after that?  
13:05:35 <hexagoxel> tieTYT: perhaps somewhat like this: https://lpaste.net/679732489316466688
13:05:38 <monochrom> No, MonadIO is a class, not a type.
13:07:03 <geekosaur> the poin of MonadIO is that if you have a monad stack with IO at the bottom and everything in the stack derives MonadIO (all the standard MTL classes do) then you can use liftIO to relay an IO action to the IO at the bottom
13:07:43 <tieTYT> geekosaur: hm, I didn‚Äôt understand that.  Where do I have a monad stack?
13:07:51 <monochrom> ScottyM
13:07:55 <hexagoxel> and ActionM
13:08:10 * hackage opaleye-trans 0.4.3 - A monad transformer for Opaleye  http://hackage.haskell.org/package/opaleye-trans-0.4.3 (wraithm)
13:08:18 <tieTYT> how can you tell those are monad stacks?
13:08:43 <monochrom> LYAH does not prepare you for this. You have a long way to go before it is meaningful to do a "webapp project".
13:09:50 <tieTYT> ah well the problem is, I don‚Äôt know what I don‚Äôt know.  What should I learn instead of this?
13:09:57 <monochrom> The problem with everyone's misguided advice of "the best way to learn is to do a dive-in project"
13:10:22 <monochrom> Get your hands on any Haskell textbook that includes a chapter on "monad transformers".
13:11:16 <monochrom> If you can't do books, it may or may not be sufficient to study Typeclassopedia.
13:11:21 <tieTYT> what I liked about LYAH is it was easy to understand.  Can you recommend a more advance book that emphasizes that?
13:12:11 <backes> hey, what is wrong with this small piece of code? https://gist.github.com/lyinch/0b18bb7ecfad505d472dd804dd1c358f I simply zip a list and map a lambda function that pattern matches a tuple 
13:12:58 <monochrom> Yeah, what's wrong?
13:13:18 <monochrom> Explain to me like I'm too lazy to test this code myself.
13:13:50 <glguy> (missing ``)
13:14:15 <monochrom> Oh yeah you need a `xor` b
13:14:47 <backes> damn that's a dumb mistake... Why was one of the errors "In the second argument of ‚Äòmap‚Äô, namely ‚Äò(zip a b)‚Äô" 
13:15:35 <monochrom> Because it's tricky business for the computer to guess who to blame.
13:16:38 <mnoonan> in other words,  (\(a,b) -> a xor b) is perfectly valid on its own, so it isn't obvious that the error is there
13:17:20 <monochrom> From an economic self-interest point of view, you actually don't want the computer to know how to place the correct blame.
13:17:30 <monochrom> Because if it could, then why would any company hire you?!
13:18:40 <mnoonan> (also, you can just do "zipWith xor a b")
13:18:47 <mnoonan> also also, xor is in Data.Bits
13:19:00 <monochrom> Does that work for Bool?
13:19:01 <backes> because the computer still can't generate the spaghetti code that I do 
13:19:19 <backes> oh thank you, zipWith seems like a better way :) 
13:19:22 <mnoonan> monochrom, as of base 4.7 apparently, but I can never remember which base version goes to which ghc version
13:19:39 <monochrom> Neato.
13:19:49 <backes> and I think that "a /= b" works as xor as well
13:19:55 <monochrom> Yes.
13:20:13 <mnoonan> backes: good point :)
13:21:27 <mnoonan> I was abused by years of a C++ codebase that had special boolean types where the overloads for ^ and != were not the same :|
13:24:55 <ggVGc> did you redefine them before you left
13:25:08 <ggVGc> to be inverses of eachother and of whatever they were previously
13:25:21 <mnoonan> heh
13:25:56 <mnoonan> no, there were good reasons for it being like that
13:27:20 <mnoonan> (the type represented an abstraction of concrete bools, so it could be any of {T}, {F}, {T,F}, {}. != checked for inequality as sets, xor lifted the concrete xor operation.
13:27:27 <mnoonan> )
13:28:35 <ph88> i used parMap before to parallelize things before .. but now i like to run some things parallel but once a thing is done the resulting hashmap should be merged (combine-union) into a bigger hashmap, i like to do prevent doing this at the very end. How can i do this so all threads merge their results back into a single hashmap ?
13:34:27 <orion> cocreature: https://gist.github.com/centromere/0943d9c3b3a739bbe7094c6a2cded305 <-- This is what I'm trying to do in a more idiomatic way.
13:35:18 <kwalekko> can I write a where block after lambda expression?
13:37:02 <Eduard_Munteanu> kwalekko, yes, but the "where" block applies to the entire declaration, not just the lambda.
13:37:26 <kwalekko> Eduard_Munteanu: https://lpaste.net/7907621905375428608
13:37:49 <kwalekko> the compiler is not accepting to write a where after \date1 date2 ...
13:38:06 <phadej> kwalekko: use do/and let
13:39:16 <Eduard_Munteanu> kwalekko, like I said, "where" applies to the entire function, not just a "do" block or a lambda
13:39:57 <Eduard_Munteanu> > let f = map $ \n -> n + a where a = 2 in f [1,2,3]
13:39:59 <lambdabot>  [3,4,5]
13:40:49 <phadej> is thd typo of trd
13:41:01 <Eduard_Munteanu> The above "where" applies to "f".
13:41:58 <kwalekko> phadej: http://hackage.haskell.org/package/extra-1.6.9/docs/Data-Tuple-Extra.html
13:42:47 <phadej> i name that function trd :S
13:43:33 <phadej> 1st=fst, 2nd=snd, 3rd=trd
13:43:41 <phadej> maybe i'm weird here
13:45:31 <Eduard_Munteanu> Kinda makes sense.
13:46:37 <kwalekko> Eduard_Munteanu: do you think adding let in would make the function more readable?
13:47:42 <Eduard_Munteanu> kwalekko, yeah, possibly.
13:51:09 * hackage prometheus 2.0.2 - Prometheus Haskell Client  http://hackage.haskell.org/package/prometheus-2.0.2 (LukeHoersten)
13:51:48 <kwalekko> Eduard_Munteanu: https://lpaste.net/6110628582529171456 
13:52:00 <kwalekko> better one yeah!
13:56:36 <bk4ck3lk> INFO
13:59:57 <bk4ck3lk> Dr√∂lf !
14:00:20 <monochrom> Are you OK?
14:00:49 <ph88> is there some ghc compiler settings that can tell me if i'm putting unnecessary constraints ?
14:01:25 <pgiarrusso> ph88: that‚Äôs one of the unused warnings iirc?
14:02:15 <geekosaur> -Wredundant-constraints ?
14:03:10 <pgiarrusso> geekosaur++
14:03:21 <pgiarrusso> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wredundant-constraints
14:06:12 <ph88> -Wredundant-constraints does not work in the situation where i have   type App m = (MonadReader Env m, MonadIO m, MonadRandom m, RandomSource m (Gen RealWorld))
14:06:41 <ph88> i can take   MonadIO m out of there and of about 8 of the functions only 2 need   (App m, MonadIO m)
14:07:08 <ph88> bug ?
14:07:15 <geekosaur> that seems like asking too much
14:07:29 <geekosaur> it's not analyzing to see if you can refactor your "type"s
14:08:04 <geekosaur> by using "type" you basically told it that you are duplicating for a reason that it can't know (e.g. it is an API)
14:08:45 <ph88> i'm not exporting this type
14:16:24 <phadej> still
14:17:13 <geekosaur> if you give something a name, the compiler is free to assume you did so for a reason and not second-guess you.
14:17:55 <ph88> here some ticket says type synonym Getter is expanded and check for redundancy https://ghc.haskell.org/trac/ghc/ticket/12142
14:18:07 <EvanR> "it may do nothing" is an interesting piece of info
14:18:15 <phadej> ph88: Getter is type synonym, not constraint
14:18:15 <ph88> with expanded i mean    l :: Getter [a] Int    turns into     l :: (Contravariant f, Functor f) => (Int -> f Int) -> [a] -> f [a]
14:18:40 <geekosaur> there are some specific cases where it's a mistake often enough to be worth noting (e.g. unused parameters)
14:18:42 <ph88> what is it called what i'm using ?   constraint synonym ?
14:18:53 <geekosaur> yes
14:24:24 <ph88> geekosaur, are you sure it's not called constraint kind ?  i'm just asking because i have to turn on the ConstraintKinds extension for this to even work
14:24:43 <geekosaur> constraint kinds enables this usage, it does not defin e it
14:25:16 <geekosaur> it lets you work with constraints as if they were types. making synonyms of them is *one* use
14:25:20 <geekosaur> wrapping in a Proxy is another
14:25:26 <ph88> ah ok thank you
14:26:19 <tombusby> hey
14:26:33 <tombusby> I'm wondering if there's a better way to express this pattern, I suspect there is:
14:26:41 <tombusby> keyAdd key block = [k `xor` b | (k, b) <- zip key block]
14:27:12 <tombusby> is there some sort of zipMap xor key block
14:28:23 <geekosaur> well, asif they were kinds, instead of their own thing like they sued to be
14:30:14 <dmwit> tombusby: Yes, `keyAdd = zipWith xor`.
14:30:32 <tombusby> awesome thanks
14:36:45 <ph88> will the functions of Control.Concurrent.Async automatically run as many threads as there are cores? or will they try to start a thread for every computation that is given immediately ?
14:37:04 <ph88> i have this function    playGame :: IO TransitionFrequency    i want to run it in parallel
14:38:03 <ddavidd[m]> there is a simple github script that i am trying to run but i cant figure out how to use it
14:39:58 <ph88> which one ?
14:40:36 <geekosaur> ph88, the latter. there are wrappers over async to get e.g. thread pools
14:40:37 <ddavidd[m]> https://github.com/mtolly/vagante-extract
14:41:20 <ddavidd[m]> It's a tool to extract assets from a game. I have no experience whatsoever with haskell but I want the files so I can update the wiki a bit
14:41:39 <ph88> ddavidd[m], ok let me try it for you
14:42:20 <ph88> ddavidd[m], download this tool it will build the software for you  https://docs.haskellstack.org/en/stable/install_and_upgrade/ 
14:42:57 <ddavidd[m]> I already downloaded it
14:43:04 <ph88> then git clone that repo
14:43:07 <ph88> cd into the directory
14:43:11 <ph88> type:   stack build
14:44:00 <ph88> type:  stack exec -- vagante-extract
14:44:06 <ddavidd[m]> into the directory of the haskell file or the file i am trying to extract?
14:44:25 <ph88> i will pastebin it for you
14:44:50 <ddavidd[m]> Thank you!
14:45:05 <ph88> ddavidd[m], https://bpaste.net/show/d57c4e04fcb4
14:46:38 <ddavidd[m]> Thank you again!
14:46:56 <ph88> since it's missing a readme you have to read the source code to see what valid arguments you can pass to the program  https://github.com/mtolly/vagante-extract/blob/master/Main.hs#L53-L58 
15:24:39 * hackage prometheus 2.1.0 - Prometheus Haskell Client  http://hackage.haskell.org/package/prometheus-2.1.0 (LukeHoersten)
15:32:54 <lukelau> Is there a way to declare in your .cabal file that cabal shouldn‚Äôt install an executable with cabal install?
15:34:02 <hpc> don't have a section that installs an executable
15:34:07 <dmwit> I don't think so. You can enable or disable the executable with a flag, perhaps.
15:34:45 <dmwit> But uh... even with the flag route, the disabled executable will probably produce an error during the build rather than a clean install with one less executable.
15:35:04 <dmwit> On the other hand, benchmarks and test suites aren't installed under normal circumstances, and are probably what you want this for anyway.
15:35:23 <dmwit> Or, if you want it for a demo program, make a separate cabal file for the demo that declares your library as a dependency.
15:35:49 <lukelau> My case is the latter, I‚Äôll give that a shot
15:35:52 <lukelau> Thanks
15:57:31 <epta> how to filter keys of json using lens-aeson? Something like "{ \"a\": 1, \"_b\": 2, \"c\": 3 }" -> "{  
15:57:58 <epta> -> "{ \"a\": 1, \"c\": 3 }"
16:06:58 <Gurkenglas> Aw man too bad "foo ?x = bar" doesn't desugar to "foo x0 = let ?x = x0 in bar"
16:07:57 <Gurkenglas> epta: members . indices (allOf head (/='_'))
16:08:39 <Gurkenglas> *_head
16:08:53 <Gurkenglas> Also the index is text, don't know if that one has a _head traversal
16:09:23 <Gurkenglas> 'members . indices (not . isPrefixOf "_")', I suppose.
16:11:08 <endojelly> Gurkenglas, what's ?x, is that implicit parameters or something?
16:13:34 <Gurkenglas> endojelly: yep
16:14:20 <endojelly> Ah, have to look into those.
16:14:35 <endojelly> Never did. I did use implicit parameters in Agda though, might be similar.
16:15:06 <endojelly> Hmm. Now that I think of it... I might use them quite a lot, actually, indirectly, because Clash might use them?
16:15:49 <madnight> epta: you can decode the json like so "{\"foo\":1,\"bar\":2}" :: Maybe (Map String Int) and then use the usual filter methods
16:16:15 <epta> madnight: and encode to JSON back?
16:17:05 <madnight> epta: yup
16:18:49 <epta> Gurkenglas: `"{ \"id\": 1, \"_a\": 2 }" ^.. members . indices (not . isPrefixOf "_")` return just values without keys
16:19:06 <Gurkenglas> epta, ^@..
16:19:37 <endojelly> by the way, since I mentioned Agda... in Haskell, I sometimes have to write constraints like "KnownNat n, KnownNat M, 1 <= (n*m)..."
16:19:45 <epta> Gurkenglas: nice, great
16:20:04 <endojelly> in that case, writing something like "2 <= (n*m)" doesn't work to satisfy 1 <= (n*m)"
16:20:09 <endojelly> any way Haskell can deduce that?
16:20:26 <mahsa> Could someone help me with a haskell code?
16:20:36 <endojelly> I feel it makes my constraints relatively verbose otherwise
16:20:51 <Gurkenglas> mahsa, etiquette around here has it to say enough that people can start answering immediately
16:21:57 <mahsa> Is there any way to convert Haskell code to Matlab code?
16:22:16 <geekosaur> endojelly, there are ghc plugins that can build those constraints for you, like natnormalise
16:22:26 <geekosaur> ghc is not curently smart enough to do it itself
16:22:56 <endojelly> geekosaur, interesting... so I'd have to load some kind of plugin into ghc?
16:23:10 <endojelly> geekosaur, and then I can write 2 <= n*m for example and it deduces the rest?
16:23:13 <epta> Gurkenglas: is there a way to get Value back, not a [(Text, Value)]?
16:23:21 <endojelly> Hmm, not sure having a ghc plugin is a dependency is worth it.
16:23:34 <Gurkenglas> epta, which Value? Do you mean [(Value, Value)]?
16:23:45 <endojelly> this is probably going too far into dependent types, I guess?
16:23:50 <geekosaur> endojelly, http://hackage.haskell.org/package/ghc-typelits-natnormalise
16:24:13 <endojelly> geekosaur, oh hang on, I think Clash uses that plugin already! I'm pretty sure I saw it during compilation!
16:24:13 <geekosaur> I don't know if getting this into ghc is planned, but I think there's still experimentation going on
16:24:17 <dmwit> mahsa: Only the old-fashioned way: lots of manpower.
16:24:20 <geekosaur> I think theres another plugin that uses svd
16:24:37 <geekosaur> so you may just have to enable it in your module(s)
16:24:51 <madnight> mahsa: there is a https://hackage.haskell.org/package/matlab library which allows you to use matlab functions in Haskell
16:24:52 <endojelly> I will look into it, thanks
16:25:46 <endojelly> oh, so implicit parameters are essentially dynamically bound variables? That's pretty
16:29:28 <Gurkenglas> madnight, he wants the other way round I think, write Haskell code in a situation where he's told to use matlab
16:30:54 <nan`> i am trying to understand the squeal sql library talk and having some trouble. can anyone recommend some prerequisite reading? https://www.youtube.com/watch?v=rWfEQfAaNc4
16:33:25 <madnight> Gurkenglas: hmm matlab can load compiled libs like so loadlibrary('test.so'), maybe it's possible to load a compiled haskell lib
16:33:48 <endojelly> "An implicit-parameter binding group must be a collection of simple bindings to implicit-style variables (no function-style bindings, and no type signatures); these bindings are neither polymorphic or recursive."
16:33:55 <Gurkenglas> epta, if as I'd think you didn't mean "Can I have something of type Value rather than something of type [(Text, Value)]?", what did you mean? 
16:34:01 <endojelly> What would a function-style binding be here, something like ?x a = b?
16:34:06 <nan`> interested in data kinds and polykinds etc, a general intro
16:36:03 <nan`> are there any good advanced haskell books that cover newish extensions and stuff
16:37:28 <epta> Gurkenglas: I was under impression that original thing is a Value, not a Text, thus I was looking for some Value -> Value filter
16:38:19 <hololeap> i'm looking for some deeper insights into representable functors. i see that you can make a Vector representable if you have the size set somewhere globally. that begs the question of whether you can have a representable within a reader monad or something even more general. a representable functor from a kleisli category maybe?
16:40:54 <Gurkenglas> epta, a Value is usually something you can break down further, that's not afaik the case for key names
16:41:27 <Gurkenglas> But if you want to break a key down further, Text has an AsValue instance so you can just keep going anyway
16:42:01 <hololeap> nan`: you might want to look into type theory, because i'm pretty sure that's what those extensions are inspired by
16:42:08 <Gurkenglas> epta, why do you want [(Value, Value)] rather than [(Text, Value)]? (Do you?) How do you plan to use it?
16:42:34 <c_wraith> epta, keys in dictionaries in json are text, not arbitrary values...
16:42:40 * hackage Persistence 1.1.3 - Quickly detect clusters and holes in data.  http://hackage.haskell.org/package/Persistence-1.1.3 (Ebanflo)
16:44:23 <epta> Gurkenglas: it's a unit test, I have a 'Value' returned from a function, I want to assert only some keys of this JSON. Thus I'm filtering only keys that needed
16:44:35 <hololeap> nan`: there's also the ghc manual, and this site which might help as a guide for some extensions in general: https://ocharles.org.uk/blog/pages/2014-12-01-24-days-of-ghc-extensions.html 
16:45:01 <epta> so, atm it's actual ^@.. members . indices (not . isPrefixOf "_") `shouldBe` expected ^@.. members
16:45:48 <epta> but it'd great to assert Values, not [(Text,Value)]
16:46:05 <Gurkenglas> Ah, I see
16:46:20 <Gurkenglas> You want to pack them back up in an Object Value
16:46:24 <epta> yeah
16:46:53 <epta> oh, sorry for confusion, it's Object, right
16:47:38 <endojelly> oh, 7.8.2 turns off the dreaded monomorphism restriction in ghci
16:48:09 <endojelly> makes sense I guess, you're usually not looking for performance when typing things into the interactive prompt.
16:50:04 <Gurkenglas> epta, one way would be '(_Object %~ M.filterWithKey (\k _ -> not $ isPrefixOf "_" k)) actual `shouldBe` expected'
16:52:37 <Gurkenglas> (Why doesn't Value have an At instance?)
16:53:05 <glguy> same reason as why [a] doesn't, you can't set a value at every index
16:53:40 * hackage viewprof 0.0.0.21 - Text-based interactive GHC .prof viewer  http://hackage.haskell.org/package/viewprof-0.0.0.21 (MitsutoshiAoe)
16:54:13 <glguy> Gurkenglas: Object has an instance, however
16:54:22 <Gurkenglas> Why not? Is it that attempting to insert a value at a new index would leave ambiguous where to put it in relation to its bretheren?
16:55:02 <glguy> Gurkenglas: What would this do?    Null & at "key" .~ Just (Bool True)
16:55:28 <Gurkenglas> Ah, you mean that some lens law says that we must actually save that bool to return it when asked for
16:55:37 <glguy> yeah
17:04:15 <endojelly> May be a FAQ, but what other Haskell systems beside GHC are there right now? I remember Hugs, but that has been discontinued.
17:08:25 <exio4> endojelly: would GHCJS count as GHC? :P
17:08:32 <endojelly> heheh
17:12:42 <madnight> endojelly: it's actually a little bit sad that we no real alternatives to ghc, don't get me wrong ghc is great, but "competition" in general is a good thing
17:12:55 <Cale> endojelly: There's also Eta, which is basically GHC with a JVM backend...
17:13:20 <madnight> i also remember hugs, we used it at university
17:14:22 <ggVGc> I still both give and receive hugs
17:14:46 <madnight> ggVGc: :)
17:15:02 <ggVGc> endojelly: UHC
17:15:08 <ggVGc> utrecht haskell compiler
17:15:38 <madnight> ggVGc: heard of it .. is it any good?
17:15:52 <ggVGc> it's basically only for research afaik
17:16:02 <ggVGc> I don't know much about it
17:17:25 <ab9rf> uhc has a JS backend that some poeople prefer to ghcjs
17:23:44 <ph88> is it possible to derive Generic when having   type Foo = ..    ?
17:25:00 <ab9rf> ph88: yuou have to enable it as a compiler option
17:25:43 <ab9rf> oh, wait
17:27:03 <geekosaur> more information?
17:27:22 <ab9rf> you cannot derive on a type synonym
17:27:29 <geekosaur> a "type" is not a distinct type, only an alias. you can tell it to let you use the alias, but it's defined on the thing you aliased, the "type" is not its own thing
17:27:42 <ab9rf> sorry, i got distracted there by a squirrel
17:28:26 <ab9rf> you can derive on a newtype though
17:29:48 <ab9rf> read chapter four of the haskell report :)
17:31:30 <ph88> how to tell it to let it use the alias ?
17:31:59 <ab9rf> ph88: i do not understand your question
17:32:11 <ab9rf> who is 'it'
17:32:22 <ph88> im tired sorry :/
17:32:47 <geekosaur> define it on the underlying type
17:32:51 <ph88> by geekosaur "you can tell it to let you use the alias"
17:32:59 <ab9rf> a type synonym created with type has all the same characteristics as the underlying type that it's a synonym of
17:35:04 <geekosaur> define it on the actual type, not your alias. otherwise you're just being confusing
17:35:25 <ab9rf> if you want different class instances for two types with the same representation, you'll have to use newtype for one of them
17:35:27 <geekosaur> no, your type alias cannot have a different instance from the actual type
17:35:47 <ab9rf> ytou cannot declare separate class instances for a type synonym created with type
17:36:07 <ab9rf> whether with 'deriving' or using 'instance'
17:36:46 <ab9rf> admittedly, the differences between data, type, and newtype can be confusing
17:56:40 <djtyml> hi all, I would like to ask a question about ScopedTypeVariables. I try to implement a function typeclass that can get field names and types. But when I use it, I get the error "can not deducing ...type variable a is ambiugous"..
17:58:32 <hololeap> the (Monad m) constraint on (DistKleisli m Vector) seems redundant, but GHC complains if i remove it. why is this? http://dpaste.com/0YPEM1J
17:58:39 <djtyml> here is my code https://gist.github.com/2a0ba4b7f8597ae9b98d37554ca00a62 and error https://gist.github.com/ba7a7f054236944b2642c50b2187f115
18:00:08 <Cale> djtyml: In order to use ScopedTypeVariables, you must explicitly quantify your type variables with forall
18:00:25 <Cale> Make the signature  table :: forall a t m. ...
18:00:44 <ab9rf> yeah, that needs a forall
18:01:19 <ab9rf> the scope of an implicit forall cannot be extended
18:03:47 <djtyml> cale: I see. It compiles now! Thank you for the insight!
18:04:49 <djtyml> ab9rf: No wonder... Thank you!
18:15:42 <blonkhart> apart from cloud haskell and eve, what haskell libraries use existential types with a Typeable constraint to store data of different types and then allow clients to retrieve them in a typesafe way?
18:17:54 <yarnspinner> Hello, does anyone know how hard is it to follow "Write Yourself A Scheme in 48 Hours" for someone with no haskell experience but knows a little scheme and scala?
18:22:02 <Axman6> yarnspinner: I doubt anyone knows, but you should give it a go and tell us how it is, so we can know for the future :)
18:22:22 <blonkhart> are you a cats/scalaZ kind of person or a var kind of scala person
18:24:26 <dibblego> haha
18:24:45 <blonkhart> because if you are the cats kind i would say good luck and if you are the var kind i would say best of luck
18:24:51 <ab9rf> haha
18:24:54 <yarnspinner> That's reassuring
18:25:32 <dibblego> forget everything you know about scala, go forth and learn
18:25:58 <ab9rf> i've never looked at write yourself a scheme
18:26:49 <ab9rf> i don't think scala experience would be of much benefit though
18:27:26 <dibblego> an impediment
18:27:31 <ab9rf> it will help to have at least a passing familiarity with scheme, or at least some other lisp dialect
18:28:11 <ab9rf> dibblego: possibly. in genreal, i find that the only prior language experience that helps with haskell is prolog
18:29:19 <ab9rf> i am not proficient enough at scala to really comment on scala's benefit though
18:29:19 <yarnspinner> is haskell really that different from other FP languages?
18:29:26 <dibblego> yarnspinner: Yes.
18:29:33 <ab9rf> yarnspinner: it's much more pure fp 
18:29:37 <blonkhart> yes. i came to haskell after reading fp in scala. it is not a bad way in. i am not a real programmer so had no attachments to the jvm.
18:29:47 <dibblego> Note that I am a "Scalaz" kind of person (I wrote it) and definitely not a cats kind of person
18:30:20 <dibblego> fp in scala is a great book, because of the authors' ability to teach, despite scala
18:30:57 <ab9rf> i have written a small bit of code in scala, but most of that has not been particularly functional in form
18:31:38 <ab9rf> i don't think scala is a good language to learn functional programming as a concept
18:31:43 <yarnspinner> dibblego: Oh cool, im actually following that book now. Seems pretty clear and has good exercises
18:31:43 <blonkhart> right, not any form. i liked scala.  "i can write anything with this!" then i realized that i was my own enemy, what i wanted was more of a batter my heart three personed god, lest you enthrall me i never shall be free
18:31:48 <ab9rf> it can be a good languge to solve certain types of problems, though
18:32:03 <dibblego> yarnspinner: my wife designed the cover :) enjoy
18:33:11 <d34df00d> Hi!
18:33:40 <Axman6> o/
18:33:43 <koz_> Hihi!
18:34:24 <d34df00d> Is it possible to write a class instance like this: `instance Purify pure impure => Purify [pure] (ImpureVector impure)`, but without introducing the type synonym `type ImpureVector t s = DVS.Vector (t s)`?
18:35:08 <d34df00d> Like, somehow having a _type_ akin to `\s -> DVS.Vector (impure s)`?
18:38:29 <d34df00d> Ah, I cannot write this one too.
18:38:52 <d34df00d> > The type synonym ‚ÄòImpureVector‚Äô should have 2 arguments, but has been given 1
18:38:54 <lambdabot>  <hint>:1:5: error: parse error on input ‚Äòtype‚Äô
18:39:01 <d34df00d> Why can't I have partially applied type synonyms?
18:39:24 <dibblego> you can
18:40:11 <d34df00d> How?
18:41:02 <ab9rf> you can?
18:41:16 <ab9rf> i thought partially applied type synonyms were prohibited to keep type checking computable
18:41:25 <olligobber> you can do stuff like Fix (Either ())
18:41:38 <dibblego> Œª> type M = []
18:41:41 <dibblego> wfm ^^
18:42:08 <geekosaur> there has to be a way to apply it, though. this doesn't give you a way to slot something inside the parens
18:42:27 <nshepperd> you can have fully applied type synonyms whose kind is k1 -> k2
18:42:39 <d34df00d> It's not immediately obvious to me why partially applying type synonyms makes typechecking undecidable while partially applying newtypes doesn't.
18:42:40 <d34df00d> Why?
18:42:48 <nshepperd> such as type M = []
18:43:06 <olligobber> > type List = []; [1] :: List Int
18:43:08 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äòtype‚Äô
18:43:56 <dibblego> Œª> type E = Either; type F = E Int; type G = F String; x :: G; x = Left 99 -- wfm
18:44:31 <d34df00d> dibblego: will you be able to mention F in an instance head?
18:45:09 <ab9rf> d34df00d: you can't use type synonyms in instance declarations
18:45:25 <dmj`> merijn around?
18:45:26 <nshepperd> you can if you enable -XTypeSynonymInstances
18:45:28 <d34df00d> I can with TypeSynonymInstances.
18:45:30 <d34df00d> Yea.
18:45:31 <ab9rf> well, yes
18:45:50 <nshepperd> but then using F in an instance head is synonymous with using Either Int in the same instance
18:45:53 <geekosaur> just remember that it's actually on the underlying type, not the instance as such
18:46:06 <dibblego> Œª> :set -XTypeSynonymInstances -XFlexibleInstances
18:46:14 <dibblego> Œª> type E = Either; type F = E Int; class C f where hai :: f a -> f a
18:46:18 <dibblego> Œª> instance C F where hai = id
18:46:23 <nshepperd> it's not defining a separate instance for F, just adding an instance for (Either Int)
18:46:57 <d34df00d> nshepperd: things get more interesting if `type E t s = C (t s)`
18:47:14 <d34df00d> Then E Int isn't easily expressed merely via C stuff.
18:47:34 <nshepperd> then you can only write an instance when E is fully applied
18:47:46 <d34df00d> Yep, and this is what I don't like.
18:47:53 <d34df00d> Looks like I'll have to go the newtype route.
18:48:04 <blonkhart> this paper discusses at 7.1 why unsaturated type families are not allowed by GHC https://repository.brynmawr.edu/cgi/viewcontent.cgi?article=1000&context=compsci_pubs
18:48:06 <d34df00d> (but I still don't understand why it's allowed there)
18:48:31 <d34df00d> Are all papers written by Eisenberg?
18:49:08 <nshepperd> it's because type synonyms don't introduce a new type, so when inferring the instance you don't know which type synonym it 'came from'
18:49:24 <nshepperd> type Foo a = Int; type Bar a = Int
18:49:59 <nshepperd> if I use a class method at type Int, do I use the instance for Foo, or the instance for Bar?
18:50:06 <ab9rf> more generally, you force the compiler to have to be able to find out if two types are "the same", which may be undecidable if either or both types are the result of the application of a type function.
18:50:06 <nshepperd> it doesn't make sense
18:51:02 <nshepperd> the type checker assumes that when you have f a ~ x, you can reverse that to identify f and a, given x
18:51:19 <d34df00d> nshepperd: but I don't think I really care. A type synonym in this case is merely a function on types. `type E t s = C (t s)` means "give me a t and an s, and I'll give you a type".  `E Maybe` means "give me an s and I'll give you a C (Maybe s)`
18:51:29 <nshepperd> which totally goes out the window if those type variables are allowed to be partially applied type synonyms
18:52:42 <d34df00d> So if I now stick a partially applied E like that into an instance head (like `instance Class (E Maybe)`, then it just means the obvious thing.
18:52:47 <d34df00d> Which quite makes sense to me.
18:52:51 <nshepperd> being a function on types isn't enough, that function also has to be reversible
18:54:34 <d34df00d> Why? You're perfectly happy with `type E t s = Either t s` and having partially applied E in an instance head, aren't you?
18:54:37 <d34df00d> In theory, at least.
18:54:49 <nshepperd> no
18:54:55 <d34df00d> Since you can just write `instance Class (Either Type)`, as you wrote before.
18:55:00 <nshepperd> nope
18:55:45 <d34df00d> Why nope?
18:56:04 <nshepperd> I mean, yes, you can write 'instance Class (Either Type)'
18:56:27 <nshepperd> but what if it was 'type E t s = Either s t'?
18:56:58 <d34df00d> Does the order of parameters really matter for typechecking?
18:57:00 <nshepperd> writing the Either instance with the type arguments the other way around is impossible
18:57:16 <d34df00d> Is it impossible fundamentally or just because there is no syntax?
18:57:49 <d34df00d> Personally, my mental model of stuff like `instance Class (Either Type)` is that it's actually eta-reduced `instance Class (\t -> Either Type t)` in a sense.
18:58:15 <d34df00d> So, if you actually had such syntax, why couldn't you just `instance Class (\t -> Either t Type)`?
18:58:22 <blonkhart> i asked a similar but dumber question when i started learning this language and the point was made, What if you had a synonym type F a = Bool and then tried to make a functor instance for F a (Functor Bool)
18:59:10 <blonkhart> http://tunes.org/~nef//logs/haskell/18.04.01
18:59:38 <glguy> d34df00d: It's worth getting used to thinking of (Either Type) as a proper type and not synonymous with a type-level lambda notion that doesn't exist in the language
19:01:12 <d34df00d> glguy: ok, let's put it this way: what'd break if the lambda notion was introduced? That is, if you could actually write an analogous type of the form `\t -> Either t Type`?
19:01:30 <d34df00d> Having kind * -> *, all that stuff.
19:02:20 <glguy> it would make inference weird,   in the current situation if we try to unify:   f a    and Either Int Bool,   we know that   f ~ Either Int,   and a ~ Bool
19:02:47 <glguy> but under your model maybe f should have been (\t -> Either t Bool)   and a could have been Int
19:02:48 <d34df00d> So, you kinda fix the unification order.
19:02:54 <glguy> it's no longer unambiguous what's going on
19:03:03 <d34df00d> Got it, thanks!
19:03:04 <glguy> now typeclass resolution doesn't make sense
19:03:14 <d34df00d> That's just the answer I was looking for, awesome! :)
19:03:36 <d34df00d> And this explains why it works with newtype.
19:03:46 <d34df00d> And why type doesn't make sense in this context.
19:03:49 <d34df00d> Yea, awesome!
19:04:26 <fishythefish> did we cover the standard "deciding equality of partially applied type synonyms requires the typechecker to decide equality of functions" bit already?
19:04:43 <d34df00d> Yep, but it wasn't obvious to me why it actually plays a role in this context.
19:05:07 <fishythefish> the context being an instance head, right?
19:05:19 <ab9rf> fishythefish: i hinted at it
19:05:29 <d34df00d> Yep. I thought "just substitute it, stupid typechecker!"
19:05:56 <fishythefish> right, and with `type`, unlike `newtype`, you may have to keep substituting with that approach
19:06:42 <d34df00d> At this point I"m still not sure why.
19:07:00 <d34df00d> glguy's explanation seems to be of slightly different nature and reasons.
19:07:30 <nshepperd> type F a = Bool; type G a = Bool; instance Functor F; instance Functor G
19:07:47 <fishythefish> because newtype doesn't just introduce an alias
19:07:59 <nshepperd> if I try to use fmap on a Bool, do I get the instance for F, or the instance for G?
19:08:05 <nshepperd> the compiler has no way to decide
19:08:50 <d34df00d> fishythefish: so you're kinda not reducing (syntactically) your term, or something like that, unlike with newtype?
19:11:14 <fishythefish> with `type Foo = Either Bool`, to decide if a type is equal to `Foo Char`, you're saying "just expand to `Either Bool Char` and compare with that". how does this work with `newtype Foo = Foo (Either Bool)`?
19:11:58 <c_wraith> fishythefish, that newtype is invalid
19:12:16 <c_wraith> fishythefish, the argument to a newtype constructor must have kind *
19:12:21 <fishythefish> c_wraith: yeah, i'm aware, just not sure what a good substitute is here
19:12:27 <fishythefish> hence the probing question :P
19:12:35 <nshepperd> newtype Foo a = Foo (Either Bool a)
19:12:56 <d34df00d> I'm not sure how shall this work since I fail to parse the intent. Obviously it's different from what nshepperd suggested.
19:12:59 <fishythefish> well, that loses the partial application, but I guess
19:13:47 <fishythefish> we can still try to partially apply in the instance head and see what happens
19:13:50 <d34df00d> Anyway, umm, why can't it work the same way in this case? Just with a shorter chain of expansions and substitutions.
19:13:53 <nshepperd> deciding that a type is equal to Foo Char with the newtype is easy: you just check that it's f a, where f ~ Foo and a ~ Char
19:14:32 <fishythefish> d34df00d: because there's nothing to substitute, really - Foo Char doesn't expand to Either Bool Char
19:14:37 <d34df00d> Yep.
19:14:56 <d34df00d> But the same applies to checking a fully applied type synonym, isn't it?
19:15:51 <d34df00d> So if I have a partially applied type synonym in an instance head, that just means some type variables are free (in a sense, or universally quantified), so I compare against that "pattern".
19:16:38 <d34df00d> That requires all of the type variables to be used on the RHS, which rules out nshepperd's example.
19:17:26 <d34df00d> Hmm.
19:17:34 <fishythefish> but it's an alias, so a type doesn't have to match that "pattern" to be equal to it
19:17:40 <d34df00d> glguy: what does unification have to do with finding a class instance?
19:18:09 <d34df00d> I know nothing about the formal definition of Haskell type system, but from what I know, at this point it's not necessary.
19:18:32 <d34df00d> fishythefish: even if you're talking about the "pattern" after the expansion of an alias?
19:18:33 <nshepperd> fmap :: Functor f => (a -> b) -> f a -> f b
19:18:51 <nshepperd> to find the right Functor instance, you need to unify to find f
19:19:31 <d34df00d> Ah.
19:19:41 <d34df00d> Since the function is defined in terms of f a.
19:19:42 <d34df00d> Right.
19:19:46 <d34df00d> Makes sense.
19:19:47 * d34df00d stupid
19:20:34 <d34df00d> nshepperd: so can't I just say "nope, overlapping instances" in your example with F and G?
19:20:45 <d34df00d> And avoid caring whether they are actually the same.
19:20:53 <d34df00d> They, well, just overlap. In a sense.
19:20:53 <fishythefish> type True x y = x; type False x y = y; type Not b x y = b y x. Now, is `Not True ~ False`?
19:21:51 <nshepperd> d34df00d: well, you can, but now you have to convince me that you can decide the equality of two functions F and G
19:22:01 <nshepperd> in order to establish that they 'overlap'
19:23:26 <nshepperd> or rather, decide whether the image of those two functions overlaps at all
19:26:26 <d34df00d> Yeah, I see what you're saying.
19:26:30 <nshepperd> and even once you've solved that, and forced the programmer to remove the instance for G... you still have the problem of unifying the type of fmap to discover that f ~ F
19:26:47 <nshepperd> knowing only that f a is Bool
19:26:50 <d34df00d> I guess I'm starting to have a better picture now. Thank you folks!
20:22:39 <glguy> In the course of implementing a parser for the rather simple, but variable length encoded SOCKS 5 messages I was hoping that my parser combinators could tell me how many bytes it was safe to try to read from the socket so that I'd never read beyond the end of the message
20:23:02 <glguy> I threw together this module that automates that process, but I'm wondering if anyone knows of some existing parser combinators that do this
20:23:03 <glguy> https://gist.github.com/glguy/1c00336a56c93aa0e7415d4faee25d82
20:32:10 * hackage constraints-extras 0.1.0.0 - Utility package for constraints  http://hackage.haskell.org/package/constraints-extras-0.1.0.0 (abrar)
20:51:39 * hackage serverless-haskell 0.6.6 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.6.6 (AlexeyKotlyarov)
20:53:55 <Eduard_Munteanu> glguy, isn't it simpler to run nested parsers? One pass to break into messages, another that decodes them.
20:54:36 <glguy> It don't want to have to manually factor the parser for one message into the different segments of known length
20:54:49 <glguy> That's what I'm wanting to automate
20:55:36 <glguy> so in the example I have in that paste there's this one message format that always can use 3 bytes, and then depending on that 3rd byte will either need 6 more, 18 more, or 1 more, and then that many + 2 more
20:55:50 <glguy> I'd like to minimize the number of 'read's I would need to do on the socket
21:03:34 <ab9rf> mmm
21:03:53 <ab9rf> lots of fun nasties with this one
21:06:00 <ab9rf> glguy: i would be tempted to simply read as much as you have local buffer for and use a nonblocking read to read more when the buffer runs out
21:06:26 <ab9rf> you can't assume that you'll get well-formed messages anyway, so you can't use blocking reads 
21:07:11 <glguy> It's perfectly fine to have blocking reads, the thread will time out eventually if it doesn't work out
21:07:13 <ab9rf> the problem with that, i suppose, is that you need to use a streaming parser, which is bloody hard to do in parsec. atto supports streaming inputs
21:07:26 <glguy> attoparsec works out, but it can't tell me how much to read, just to read me
21:07:29 <ab9rf> glguy: if you're ok with blocks, then it's somwhat easier
21:07:39 * hackage serverless-haskell 0.7.4 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.7.4 (AlexeyKotlyarov)
21:07:47 <glguy> and I don't want to overread because I don't want to eat anything off the socket that openssl is going to expect to find on it
21:07:48 <ab9rf> glguy: i'd always read "as much as possible" and buffer
21:08:03 <ab9rf> glguy: ah, you plan to pass the socket onto someome else
21:08:37 <ab9rf> hm, that is a challenge
21:12:13 <glguy> The code in the paste seems to handle it, but I'm just wondering if there's other examples of this kind of parser combinator approach to this that I could look over :)
21:13:40 <ab9rf> interesting
21:14:38 <pie_> i need to pass a pointer to a haskell function to this: https://hackage.haskell.org/package/gl-0.8.0/candidate/docs/Graphics-GL-Core43.html#v:glDebugMessageCallback
21:14:51 <pie_> so i need a function with this signature: https://hackage.haskell.org/package/gl-0.8.0/candidate/docs/Graphics-GL-Types.html#t:GLDEBUGPROC
21:14:56 <pie_> how would I go about this?
21:15:18 <ab9rf> glguy: that's fairly clever
21:15:59 <glguy> pie_: You need a "Dynamic wrapper" , see https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1490008
21:16:28 <glguy> at least that's how you turn Haskell values into function pointers that C can call
21:16:59 <pie_> thanks ill try
21:20:03 <ab9rf> glguy: this gives me an idea for a problem i was trying to solve a while ago, that i never got working to my satisfaction
21:20:41 <pie_> glguy, that looks like an import though?
21:20:58 <glguy> Yes, it kind of looks like an import
21:21:14 <pie_> though it does say right under it what it does, so its not that i didnt read that
21:21:25 <mniip> hmm
21:21:27 <pie_> is this mkCallback something I need to implement?
21:21:39 <glguy> pie_: No, that syntax is what you write to implement it
21:21:50 <pie_> ah. yeah so thats also confusing me alittle
21:22:07 <pie_> i skimmed some of the previous parts of the document, looks like something i should read eventually anyway
21:22:26 <pie_> is this "wrapper" thing something provided by the rts or something?
21:22:52 <pie_> ah i should be looking at ' Import Declarations For import declarations, the syntax for the specification of external entities under the ccall calling convention is as follows: '
21:23:03 <pie_> i was mainly looking at the export syntax.
21:24:01 <mniip> I think I now understand, intuitively, why edwardk insisted that in presence of GADTs, parameterized datatypes are really profunctors from a category truncated to only the identity morphisms
21:24:16 <mniip> I'm not sure what reasoning led him to insist on that however
21:24:26 <ab9rf> i don't even understand what that means
21:24:45 <pie_> ab9rf, its probably not as complicated as it sounds
21:24:53 <pie_> category thoery language is just totally alien
21:25:20 <mniip> my reasoning is that we can pretend (a ~ b) has a dictionary of (a -> b, b -> a) where the functions can only be identities, so that the dictionary is computationally irrelevant
21:25:23 <ab9rf> pie_: that's generally true of mathematics
21:25:37 <ab9rf> then again, you likely have no idea what an usufruct is
21:25:50 <ab9rf> we all have our occupational lingo
21:26:05 <pie_> ab9rf, i guess my exposure to a decent amount of mathematics has made me so used to glazing over at gibberish that i forgot haha
21:26:30 <pie_> whats an usufruct from
21:26:39 <ab9rf> pie_: i used to typeset stuff for a math grad student, so i've been exposed to a great heap of math gibberish that i did not understand
21:26:44 <ab9rf> pie_: law
21:26:54 <pie_> wow id not have guessed.
21:27:02 <mniip> pie_, https://en.wikipedia.org/wiki/Mouse_(set_theory)
21:27:13 <pie_> mniip, :D
21:27:32 <pie_> "The exact definition depends on the context" obscurities in obscurities
21:27:45 <mniip> nah, it's understandable
21:27:46 <pie_> " a mouse is then an iterable premouse"
21:27:53 <ab9rf> pie_: oh, you should saee the endless arguments over what "reckless" means
21:28:07 <pie_> ab9rf, i can imagine honestly
21:28:08 <mniip> ab9rf, as opposed to reckful?
21:28:43 <ab9rf> mniip: both of those beg theq eustion of just what "reck" is
21:28:48 <pie_> ab9rf, well, imagine as far as ive bantered pointlessly on irc with people on things anyway.
21:29:28 <mniip> anyway, back to the question
21:29:33 <mniip> ab9rf, are you familiar with free theorems?
21:29:39 <ab9rf> mniip: vaguely
21:29:57 <ab9rf> mniip: i could not define them if pressed, but i have some vague sense of what they're about
21:30:07 <pie_> ab9rf, then again, some of math really *is* that complicated? :D
21:30:53 <mniip> ab9rf, and are you familiar with functors?
21:31:21 <ab9rf> mniip: yes, more or less, although there are many subtleties i fail to grasp
21:31:23 <pie_> glguy, so there are no variations on this, this is literally that one mkCallback construct right?
21:31:35 <glguy> pie_: the name is up to you
21:31:45 <pie_> feels kind of weird.
21:31:56 <glguy> the type is up to you as long as it is of the form: ft -> IO ft    for some foreign type ft
21:32:10 <mniip> ab9rf, okay, well, a profunctor is a functor from C^op x C, for some category C
21:32:25 <mniip> loosely speaking it's a two-argument functor, contravariant in the first argument, covariant in the second
21:32:48 <pie_> glguy, anyway thanks, i think this will work. ^.^
21:33:00 <mniip> lens and lens accessories actually defines a Profunctor typeclass
21:33:02 <mniip> :t dimap
21:33:03 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
21:34:05 <pie_> glguy, ahhhh wait.. but i need a FunPtr ( stuff -> in -> here )
21:34:20 <glguy> Oh, that's what I meant (and what's written in the docs)
21:34:23 <pie_> oh my bad it says right there that i can change it
21:34:27 <fragamus> So profunctor starts with p b c and grows in both directions right
21:34:28 <pie_> yeah ^.^
21:34:43 <pie_> and now it also makes sense that it can have different names
21:34:53 <mniip> fragamus, not sure I understand the question
21:35:16 <fragamus> Grows on input side and output side
21:35:17 <mniip> ab9rf, not every parameterized type is a Functor, but every parameterized type can be made a profunctor if we split the co- and contra-variant occurences of the parameter
21:35:39 <mniip> (F a, G a)  -->  (F a' a, G a' a)
21:35:40 <ab9rf> hm, that's an interesting statement
21:35:47 <ab9rf> which makes sense to me intuitively
21:35:51 <mniip> Either (F a) (G a)  -->  Either (F a' a) (G a' a)
21:36:02 <mniip> F a -> G a  -->  F a a' -> G a' a
21:36:09 <mniip> note how the left side of (->) reverses variance
21:36:32 <mniip> (the primed version of the variable is the contravariant appearance)
21:37:37 <hololeap> what's the verb you would use to say you are "executing" a monad?
21:37:39 <mniip> now, if we made such a "split" profunctor called P, applying it to the same type variable twice (P a a) recovers the original type
21:37:53 <mniip> hololeap, "run"?
21:38:02 <mniip> :t runMaybeT
21:38:03 <lambdabot> error: Variable not in scope: runMaybeT
21:38:07 <mniip> :t runStateT
21:38:08 <lambdabot> StateT s m a -> s -> m (a, s)
21:38:12 <mniip> :t runReaderT
21:38:13 <lambdabot> forall k r (m :: k -> *) (a :: k). ReaderT r m a -> r -> m a
21:39:13 <mniip> ab9rf, it turns out that the type 'forall a. P a a' is in exact correspondence with a thing called "profunctor end", denoted  \int_A P(A, A)
21:39:53 <mniip> it also turns out that wadler's "free theorem" for the type 'forall a. P a a' is the wedge condition of said profunctor end
21:40:08 <hololeap> yeah, but do people really say `mzero :: Maybe a` is being )run_?
21:40:14 <hololeap> _run_
21:40:23 <mniip> there's a commutative diagram you can draw, demonstrating two ways to get from 'forall a. P a a' to  'P x y'
21:40:57 <ab9rf> mniip: this stuff is vaguely familiar, but i haven't spent enough time trying to understand category theory to understand how it's useful
21:41:25 <mniip> CT lets me say one word to mean a lot of stuff
21:41:40 <hololeap> run seems to be the best choice, anyway
21:41:50 <mniip> not in an "overloaded" sense but rather in a "well-defined" sense
21:42:42 <pie_> glguy, woohoo! (33350,33356,5,37190,"GL_INVALID_OPERATION in glDrawArrays(no VAO bound)"
21:42:51 <mniip> anyway, the problem is
21:43:03 <mniip> if we consider a type parameterized over a (* -> *)-kinded parameter
21:44:35 <mniip> one might think that you can just say "oh well, the parameter (f) has to be representable as a profunctor, and hence any value 'forall a. f a' must satisfy its free theorem"
21:44:42 <mniip> but that approach is troublesome
21:45:02 <mniip> most importantly because -XGADTs is not backwards-compatible with such reasoning
22:17:03 <mniip> hmmmmm
22:26:55 <newhoggy> Does anyone know how to avoid threading my environment `e` manually in the following code?
22:27:01 <newhoggy> https://www.irccloud.com/pastebin/oV6t6Lzi/
22:27:38 <newhoggy> I want to be able to keep the type signature the same.
22:28:47 <suzu> if you want to keep the same type sig - no
22:29:57 <pie_> so i just realized i might be violating some compiler assumptions
22:31:08 <pie_> i hve the following code https://bpaste.net/show/40d675e55b3b
22:31:36 <pie_> glGenBuffer is passed a pointer to vbo' , but glGenBuffer needs to be able to modify it
22:31:37 <pie_> what happens?
22:32:51 <pie_> glGenBuffer is an opengl function, i.e. external thing, doesnt care about haskell semantics
22:34:46 <Axman6> pie_: not sure this is the best place to ask (though also not sure that an OpemGL specific channel would be either)
22:35:12 <pie_> Axman6, well its about haskells semantics so i think its probabyl appropriate
22:35:41 <mkoenig> good morning from germany. is it possible to automatically let the whole process exit when there's an uncaught exception/error in a sub-thread?
22:36:59 <pie_> i think i have a hunch whats going on. (glBindBuffer GL_ARRAY_BUFFER vbo') is actually being run as (glBidBuffer GL_ARRAY_BUFFER 0) yes?
22:38:09 <Axman6> pie_: adding some types would help us understand, castPtr is a great way to break invariants
22:42:32 <endojelly> liftA (\x -> x >>= (\(a,d) -> do guard (a == 0); return d)) w
22:42:38 <endojelly> is there a better way to express this?
22:43:18 <endojelly> tried various things using <$>, <**> and >>= or =<<, but it always seems  a little awkward
22:44:08 <min> Hello, I'm trying to use dependent types with Fix types in a catamorphism. I am trying to chain matrix multiplication such that every subsequent nested matrix is a valid multiplication with the current matrix. For example the type 'Matrix n m (Fix (Matrix o n))'. However the type nature of 'Fix f = Fx (f (Fix f))' prevents me from doing so, and forces both Matrices to have the same type i.e. Matrix n m (Fix (Matrix n m)).
22:44:35 <min> Could someone suggest a solution to overcome this please? Thanks very much.
22:46:01 <endojelly> \f w -> liftA (\x -> x >>= f) w
22:46:04 <endojelly> that's what I want
22:46:48 <endojelly> \f w -> (>>= f) <$> w
22:46:51 <endojelly> hmm, this works I guess
22:47:52 <rotaerk> :t \f w -> (>>= f) <$> w
22:47:52 <lambdabot> (Functor f, Monad m) => (a -> m b) -> f (m a) -> f (m b)
22:48:11 <rotaerk> :t fmap . (>>=)
22:48:12 <lambdabot> (Functor f, Monad m) => m a -> f (a -> m b) -> f (m b)
22:48:46 <rotaerk> :t fmap . =<<
22:48:47 <lambdabot> error: parse error on input ‚Äò=<<‚Äô
22:48:52 <rotaerk> :t fmap . (=<<)
22:48:53 <lambdabot> (Functor f, Monad m) => (a -> m b) -> f (m a) -> f (m b)
22:50:04 <pie_> Axman6, well i uhh added anything that looked useful https://bpaste.net/show/4ff9e87ecfb8
22:50:13 <pie_> but mostly its irrelevant things
22:50:54 <pie_> basically, I think the compiler assumes it can substitute 0 for vbo' in glGenBindBuffer, because its a pure value
22:51:25 <pie_> whereas opengl wants to modify the value pointed to by vbo (which would be vbo')
22:57:46 <pie_> so now i ask...if not vbo' what is it that actually got mutated? >_>
23:04:39 * hackage vfr-waypoints 0.1.0.2 - VFR waypoints, as published in the AIP (ERSA)  http://hackage.haskell.org/package/vfr-waypoints-0.1.0.2 (qfpl)
23:05:23 <pie_> so, how to i allocate a mutable variable who's pointer i can pass to an FFI-d function?
23:06:23 <glguy> mkoenig: not directly, but if you're using async you can "link" the subthread to the main one
23:06:37 <pie_> hm, maybe this is a shortcoming of the gl library? perhaps the types for such parameters should be constrained to mutable types
23:10:42 <mkoenig> glguy: thanks!
23:16:25 <pie_> glguy, if you have a moment. do you know how i should do this?: "allocate a mutable variable who's pointer i can pass to an FFI-d function?" an IORef doesnt sound like it would make sense because i dont think i can get a pointer to the inside of the IORef
23:23:15 <suzu> Ptr
23:23:31 <suzu> look at `alloca` in base, Foreign
23:25:05 <pie_> ah i think i figured it out with some hints from a friend
23:25:10 <pie_> suzu, yeah thank you
23:25:28 <pie_> i got pointed to the docs on 'new' which were more helpful in hindsight
23:25:48 <pie_> so instead of using vbo' and vbo both, what i need to to is dereference vbo when appropriate
23:26:03 <pie_> since on creation it basically creates a copy of the data i initialize it with
23:27:35 <pie_> suzu, i.e. ive been using Ptr, I just didnt quite understand it well enough :D
23:39:45 <pie_> great success \o/ triangle says hello :D https://media.discordapp.net/attachments/367415872714833920/473740338213814282/unknown.png
23:40:55 <cocreature> next step: get it to rotate :)
23:40:58 <yushyin> hi triangle!
23:42:43 <pie_> cocreature, "ezpz" :p pass a time uniform (oh god more gl api x) ), implement complex multiplication in glsl, rotate axes \o/
23:43:14 <cocreature> pie_: :)
23:43:26 <pie_> but i think i want to start on drawing a hex grid
23:43:45 <pie_> though a bit of code cleanup would probably be nice
23:44:29 <pie_> though maybe i should work on rotating the vertices. so many directions to branch off.
23:45:01 <cocreature> use the comonad instance to branch off into all of them
23:45:11 <pie_> :P
23:45:35 <pie_> copie_ making cotriangles with comonads
23:49:38 <pie_> Thought about pie too much..now I'm hungry.
23:50:10 <cocreature> maybe you should make a robot that bakes pie for you instead of drawing triangles
23:51:03 <pie_> i heard industrial food machinery is pretty expensive
23:51:08 <pie_> not sure id want to make my own
23:51:29 <pie_> oh no cocreature not helping, you're making me think of pie even more
23:51:43 <ab9rf> try thinking of copie instead
23:51:58 <pie_> will that make me cohungry
23:52:06 <ab9rf> only after you coeat it
23:52:36 <edwardk> I believe the flag you‚Äôre supposed to pass is ‚Äîno-pie actually, except on apple‚Äôs version of clang, which lies about it and confuses cabal
23:52:49 <MarcelineVQ> to bake a copie from scratch first you have to cocreate the universe
23:53:16 <pie_> i just realized this is false because it takes Ptr <pie_> hm, maybe this is a shortcoming of the gl library? perhaps the types for such parameters should be constrained to mutable types
23:53:59 <pie_> edwardk, so you're saying apple pie is inevitable?
23:54:44 <edwardk> that is what i keep telling my doctor whenever he asks me if i plan to lose weight
23:55:11 <pie_> :DD
