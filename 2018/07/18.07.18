00:02:40 <nshepperd_> Maxdamantus: and what will you call kind-level things?
00:03:12 <nshepperd_> Surely not 'kinds', since not all of them classify types
00:03:18 <Maxdamantus> nshepperd_: "kinds" and "kind-level functions"
00:03:29 <dminuoso> nan`: But, for what its worth, let me just give you a few ideas: A) you could use a typeclass. If you also use generics, you can provide a default generic implementation. That might get you quite far.
00:03:30 <Maxdamantus> nshepperd_: those are the two sorts of kind-level things.
00:03:51 <dminuoso> nan`: In the same sense how `FromJSON/ToJSON` could be done with generics.
00:04:03 <Maxdamantus> though I'm pretty sure I wouldn't actually have kind-level functions.
00:04:36 <dminuoso> Also, what is the big issue with `types` referring to `type-level functions`?
00:05:10 <Maxdamantus> dminuoso: because "type" should be something that a term (in the level below) can .. be of.
00:05:37 <Maxdamantus> dminuoso: look at things like intuitionistic type theory, Agda, Idris, ..
00:05:43 <Maxdamantus> dminuoso: they all use the terms fairly consistently.
00:06:03 <Maxdamantus> dminuoso: the thing I would call "type" is exactly what Idris calls "Type"
00:06:19 <Maxdamantus> (and what I think Agda calls "Set" or something, not particularly familiar with Agda)
00:06:26 <Maxdamantus> or did they change it to "Type"? dunno.
00:06:45 <quchen> Idris has Type, Agda has Set.
00:07:22 <Maxdamantus> Okay. I had a feeling that Agda renamed something related to one of those terms at some point.
00:07:25 <nshepperd_> Haskell has Type as well
00:08:00 <nshepperd_> Still, I'm pretty sure idris users call type level things 'types'
00:08:23 <Maxdamantus> Idris doesn't have special type-level things.
00:08:39 <Maxdamantus> IO in Idris is just a function.
00:08:51 <Maxdamantus> it's no more or less a function that `id`.
00:08:59 <Maxdamantus> s/\<that\>/than/
00:09:10 <quchen> Excluding functions from type/value/whatever will give you lots of unnecessary problems if you really want to do that. IO wouldn’t have a kind for example, because * -> * is a function, so you’d have to talk about »the kind or kind-level function of types«.
00:09:19 <Maxdamantus> IO : Type -> Type
00:09:25 <quchen> I still don’t know the point of why calling IO a type is such a problem.
00:09:29 <Maxdamantus> (that's what idris says if you write `:t IO`)
00:10:01 <Maxdamantus> That's also very similar to Haskell, except when Haskell says `IO :: * -> *`, that `(->)` constructor is different to the `(->)` constructor in `Int -> Int`
00:10:15 <Maxdamantus> in Idris it's exactly the same constructor; the constructor of function types.
00:11:25 <Maxdamantus> :i IO
00:11:33 <mniip> idunno about that
00:11:34 <Maxdamantus> > :i IO
00:11:36 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
00:11:43 <Maxdamantus> % :i IO
00:11:44 <yahb> Maxdamantus: newtype IO a = GHC.Types.IO (State# RealWorld -> (# State# RealWorld, a #)) -- Defined in `GHC.Types'; instance Alternative IO -- Defined in `GHC.Base'; instance Applicative IO -- Defined in `GHC.Base'; instance Functor IO -- Defined in `GHC.Base'; instance Monad IO -- Defined in `GHC.Base'; instance MonadPlus IO -- Defined in `GHC.Base'; instance Monoid a => Monoid (IO a) -- Defined in `GHC.Base'; inst
00:12:05 <Maxdamantus> meh
00:12:33 <mniip> % type family ArrowOf (a :: k) :: (n -> l -> k) where ArrowOf (a ~> b) = (~>)
00:12:33 <yahb> mniip: ; <interactive>:44:64: error:; Not in scope: type constructor or class `~>'; Perhaps you meant one of these: `->' (imported from GHC.Prim), `~~' (imported from GHC.Exts); <interactive>:44:72: error:; Not in scope: type constructor or class `~>'; Perhaps you meant one of these: `->' (imported from GHC.Prim), `~~' (imported from GHC.Exts)
00:12:42 <mniip> % type family ArrowOf (a :: k) :: (n -> l -> k) where ArrowOf (p a b) = p
00:12:42 <yahb> mniip:
00:13:05 <mniip> % type family KindOf (a :: k) :: * where KindOf (a :: k) = k
00:13:05 <yahb> mniip:
00:13:10 <nshepperd_> It seems like pointless purism to me
00:13:16 <mniip> % :kind! ArrowOf (KindOf IO)
00:13:17 <yahb> mniip: ArrowOf (KindOf IO) :: n -> l -> *; = ArrowOf (* -> *)
00:13:24 <Maxdamantus> % type OI :: * -> * where OI = IO
00:13:25 <yahb> Maxdamantus: ; <interactive>:48:9: error: parse error on input `::'
00:13:38 <mniip> hmm, not sure why that doesn't reduce
00:13:49 <mniip> % :kind! ArrowOf (KindOf IO) :: (* -> * -> *)
00:13:50 <yahb> mniip: ; <interactive>:1:21: error: parse error on input `::'
00:14:09 <mniip> % :kind! (ArrowOf (KindOf IO) :: (* -> * -> *))
00:14:09 <yahb> mniip: (ArrowOf (KindOf IO) :: (* -> * -> *)) :: * -> * -> *; = (->)
00:14:11 <nshepperd_> Why even call it the 'type level' if you're going to insist that 'type' only refers to a small subset of things on that level
00:14:33 <mniip> % :t undefined :: (ArrowOf (KindOf IO) ~ (->)) => a
00:14:33 <yahb> mniip: a
00:14:43 <mniip> see it's the same arrow
00:14:50 <Maxdamantus> nshepperd_: because it's the level that has types, as opposed to the level that has kinds or the level that has sorts or the level that has "values".
00:14:58 <nshepperd_> Isn't that like calling Earth the america planet
00:15:51 <dminuoso> Maxdamantus: So according to that a function is not a value.
00:16:02 <dminuoso> Maxdamantus: Im really not sure what value this distinction brings.
00:16:08 <dminuoso> Heh. Pun not intended.
00:16:28 <quchen> One of a kind.
00:16:36 <quchen> I’ll show myself out.
00:16:38 <Maxdamantus> dminuoso: what does `IO :: * -> *` mean?
00:17:02 <mniip> quchen, is that a joke of sorts
00:17:19 <quicksilver> I think Maxdamantus has a point. But his point is contrary to the naming conventions we normally use.
00:17:20 <dminuoso> Can we please box the jokes?
00:17:29 <Maxdamantus> quchen: it's kind of a joke of sorts.
00:17:35 <quicksilver> I'm not sure what the value is of arguing about it, though. It's just a subjective naming debate.
00:17:38 <Maxdamantus> er, mniip*
00:18:08 <Maxdamantus> "we" as in the Haskell community.
00:18:24 <Maxdamantus> I don't think such naming conventions are common outside of Haskell.
00:19:00 <quicksilver> "we" as in the programming language theory community
00:19:18 <quicksilver> and its bff the mathematical logic community
00:22:02 <dminuoso> Maxdamantus: Lets flip it to values for a short moment. What is a value? Why is `length` generally considered a value?
00:22:03 <kuribas> Canyou refer to a record field?
00:22:14 <kuribas> In particular to associate it with a doc string?
00:22:15 <Maxdamantus> dminuoso: because it has a type.
00:22:17 <nshepperd_> It's the America planet, but only the inhabitants of * are true Americans. We call the rest of the population America-level functionaries.
00:22:37 <dminuoso> Maxdamantus: So the inhabitants of types are called values?
00:22:46 <Maxdamantus> dminuoso: yes.
00:22:59 <dminuoso> Maxdamantus: Since we have this infinite tower of hierarchies, wouldn't it be consistent to call inhabitants of a kind types?
00:23:31 <quicksilver> kuribas: do you mean, can you write haddock on record fields?
00:23:49 <kuribas> quicksilver: also refer to it from the runtime
00:23:50 <Maxdamantus> dminuoso: no, because you've just broken what you initially said.
00:24:02 <Maxdamantus> dminuoso: it doesn't make sense for "IO" to have inhabitants.
00:24:10 <geekosaur> Kuribas, I think `-- ^` after the field definition works?
00:24:15 <quicksilver> kuribas: you can't refer to haddock strings from runtime as far as I know, no
00:24:27 <dminuoso> Maxdamantus: Barring bottom, is `Void` a type then?
00:24:28 <kuribas> geekosaur: that only works for haddock
00:24:38 <Maxdamantus> dminuoso: sure.
00:24:46 <kuribas> quicksilver, geekosaur: no, I don't mean haddock doc strings
00:24:50 <nshepperd_> IO doesn't have to have inhabitants
00:24:54 <cocreature> Haskeller’s sure love debating terminology
00:25:02 <dminuoso> Maxdamantus: Also Im not sure what I actually broke. I never said it was required for a type to have inhabitants.
00:25:03 <Maxdamantus> dminuoso: it makes sense to think of `Void` as potentially having inhabitants. That's why you can write `let x :: Void` but not `let x :: IO`
00:25:22 <Maxdamantus> dminuoso: "So the inhabitants of types are called values" .. "wouldn't it be consistent to call inhabitants of a kind types"
00:25:28 <nshepperd_> "length inhabits a type" doesn't presuppose that there can't be other types that length doesn't inhabit
00:25:48 <nshepperd_> It doesn't break anything
00:25:51 <kuribas> quicksilver, geekosaur: I mean some kind of doc string which you can access from the runtime, for example a typeclass
00:25:56 <Maxdamantus> dminuoso: you can't have both of those things, since something like `IO` has no inhabitants, and it doesn't even make sense to ask if it does.
00:25:57 <dminuoso> cocreature: What else is there to do when you're waiting 10 minutes on GHC compiling your silly small type machinery program.
00:25:59 <quicksilver> kuribas: ok, what do you mean? Do you mean 'can I make a field name a key in a map'? or 'are field names first class values'?
00:26:11 <kuribas> quicksilver: yeah, a key in a map
00:26:12 <geekosaur> kuribas, the only way I can think of to do that is an ANN… which should work
00:26:27 <kuribas> what's an ANN?
00:26:34 <geekosaur> although collecitng and using such would be something of a pain
00:26:41 <quicksilver> no, field names/labels are not first class values
00:26:41 <quchen> kuribas: A cool GHC thing!
00:26:47 <Maxdamantus> dminuoso: asking for the inhabitants of `IO` is like asking for the length of `4`; it's a category (kind) error.
00:26:57 <dminuoso> Maxdamantus: I think you're mixing up things here. A value is an inhabitant of a type. That does not make every type inhabitated.
00:27:02 <Maxdamantus> er, the former is a kind error, the latter is a type error.
00:27:14 <quchen> kuribas: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html#source-annotations
00:27:15 <geekosaur> kuribas, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html#source-annotations
00:27:17 <geekosaur> heh
00:27:27 <kuribas> geekosaur, quicksilver: of course some higher kinded thing ala beam would work also
00:27:32 <quicksilver> some of the record system libraries on hackage make labels into first class values
00:27:43 <quchen> kuribas: HLint uses annotations to silence warnings about specific parts of the code, for example.
00:27:58 <quicksilver> but I haven't previously considered the approach you're asking for, not sure what to recommned
00:28:19 <Maxdamantus> dminuoso: it still makes sense to ask about inhabitance of uninhabited types like `Void`
00:28:22 <geekosaur> ANNs arer about the only think I can think of to make docstrings
00:28:23 <dminuoso> Maxdamantus: Im just looking at the tower we have. The inhabitants of a sort are called kinds. The inhabitants of a kind are called types. The inhabitants of a type are values. I dont see any necessity why that tower *needs* to always proceed to the value level.
00:28:36 <nshepperd_> Maxdamantus: nobody's asking for the inhabitants of IO
00:29:00 <geekosaur> potentially a source plugin could massage a more tractable representation into ANNs with a specific format, and potentially even provide a catalog of them
00:29:10 <Maxdamantus> nshepperd_: asking for the inhabitants of IO is invalid for the same reasons as `let x :: IO` is invalid in Haskell.
00:29:18 <nshepperd_> Maxdamantus: we started with length, and asked "what does this inhabit"? The answer was "a type"
00:29:20 <dminuoso> Maxdamantus: Nobody is asking for the inhabitants of IO.
00:29:26 <geekosaur> (at least as of the upcoming 8.6? there's some limitations on such plugins before that iirc)
00:29:26 <kuribas> quicksilver: which library?  That would be interesting to look at.
00:29:44 <Maxdamantus> dminuoso: I know, that's why I'm equating that notion to something you can actually try in Haskell.
00:29:52 <Maxdamantus> dminuoso: namely, `let x :: IO`
00:29:55 <dminuoso> Maxdamantus: But for what its worth I do understand your point. You're stating that a type *must* be able to have inhabitants.
00:29:56 <nshepperd_> Maxdamantus: at no step in this process does anybody ask for the inhabitants of IO
00:30:02 <Maxdamantus> dminuoso: you can try that, and Haskell will reject your program.
00:30:21 <Maxdamantus> dminuoso: it won't just go "herp derp okay I'll compile it because the definition will never evaluate anyway"
00:30:34 <dminuoso> Maxdamantus: Just like trying to use a `x :: Void` will _crash_ your program.
00:30:36 <dminuoso> What's yohur point?
00:30:52 <Maxdamantus> dminuoso: this is stronger than `x :: Void` .. `x :: Void` is perfectly valid in Haskell.
00:30:58 <Maxdamantus> `x :: IO` is invalidp.
00:31:07 <Maxdamantus> > let x :: IO; x = x in x
00:31:09 <lambdabot>  error:
00:31:09 <lambdabot>      • Expecting one more argument to ‘IO’
00:31:09 <lambdabot>        Expected a type, but ‘IO’ has kind ‘* -> *’
00:31:10 <Maxdamantus> Haskell won't even compile that.
00:31:21 <Maxdamantus> It doesn't produce some program that crashes.
00:31:24 <nshepperd_> Maxdamantus: why do you keep saying that something we're not doing is invalid?
00:31:37 <Maxdamantus> nshepperd_: because Haskell rejects it.
00:31:43 <Maxdamantus> nshepperd_: as demonstrated above.
00:31:44 <nshepperd_> We know it's invalid, that's why we're not doing it
00:32:06 <quchen> »public static void main« is also invalid in Haskell, but I don’t understand how it proves something about IO being a type.
00:32:13 <dminuoso> Maxdamantus: Haskell has just a limitation that a value must only be of some particular subset of types.
00:32:49 <Maxdamantus> dminuoso: how would you describe this subset?
00:33:01 <quchen> Inhabited types.
00:33:09 <Maxdamantus> Void is not inhabited.
00:33:20 <nshepperd_> Habitable types
00:33:26 <dminuoso> Considering bottom now would be treachery I suppose. :P
00:33:30 <quchen> In Haskell it is. We’re talking about Haskell the entire time.
00:34:04 <quchen> It was said numerous times that we’re talking about Haskell and we should avoid talking about theory and Idris and Agda.
00:34:25 <dminuoso> Maxdamantus: Though you just did it. Earlier you said that "Void" potentially has inhabitants.
00:35:27 <geekosaur> there's a difference between having unrealized potential to have values, and being fnamentally incapble of it
00:35:34 <geekosaur> *fundamentally
00:35:58 <nshepperd_> TYPE r where r :: TypeRep
00:36:23 <dminuoso> *RuntimeRep
00:36:29 <nshepperd_> er, yeah that
00:37:18 <dminuoso> Though it's probably a bit easier if we pretend unboxed/unlifted doesn't exist, since that will reduce clutter a bit - and make it easier to talk in syntax.
00:37:26 <nshepperd_> The logic is: what does 'length' inhabit? A type, so it's a value
00:37:37 <dminuoso> And just use the same naive lie that GHC does and say `all types of kind `*`'
00:38:02 <nshepperd_> What does IO inhabit? A kind, so it's a type
00:38:07 <quicksilver> kuribas: fclabels for example. Maybe also vinyl?
00:38:11 <nowhere_man> dmwit: thx for the SO link
00:38:39 <dminuoso> Maxdamantus: A real fun question however would be... what is TYPE?
00:38:42 <nshepperd_> Nothing about this requires thinking about whether anything inhabits IO
00:38:46 <revskill> 0 is the worst invention of human being
00:38:51 <revskill> 0 is the same as undefined
00:38:59 <quchen> No and no
00:39:01 <revskill> because i have zero thing makes no sense
00:39:21 <quchen> s/zero thing makes//
00:39:24 <quchen> Go troll elsewhere
00:39:24 <dminuoso> Maxdamantus: Because the `TYPE` construct defies some rules.. :P
00:40:46 <ZeuPiark> hello
00:40:56 <quchen> I didn’t like ($) even before the levity discussions, but boy do I hate it now! :-D
00:41:30 <quchen> To be fair, it just made lingering problems more obvious.
00:41:40 <quicksilver> quchen: you mean specifically you don't like the various hacks they've put in to make type inference work around it? Or do you just not like it as an operator at all?
00:41:57 <cocreature> levity is what people use to derail discussions when they are bored of using bottom for that
00:43:32 <quchen> quicksilver: I don’t like $ in general, I think it contributes to soupy code in most cases, and prefer parentheses. I sometimes use it before do-blocks, but very sparingly in general. I’m fine with one or two levels of parentheses instead.
00:43:59 * quicksilver nods
00:44:14 <dminuoso> phadej: Thank you again for the link to your github project yesterday. It had some useful insights - took some inspiration from it. Now using http-client over servant-client =)
00:44:22 <quchen> The hacks just come ontop of that; they wouldn’t have happened if $ wasn’t as common.
00:44:24 <quicksilver> it is genuinely useful in sections and with higher order functions occasionally
00:44:38 <quchen> map ($ x) [f,g,h]?
00:44:45 <quicksilver> yes
00:44:58 <quchen> Agreed, but a lambda isn’t much worse here either.
00:44:59 <quicksilver> zipWith ($) [f,g,h] [x,y,z]
00:45:35 <quicksilver> I certainly think that the haskell community has an irrational dislike of parentheses.
00:45:47 <quchen> (f . g . h) x   vs   f . g . h $ x
00:45:56 <quicksilver> but removing parentheses is a game and everyone likes to play sometimes :)
00:46:19 <joiyfullveski> hy
00:46:19 <quchen> Parentheses I’m trained to pair up in my head (and editor support is better/there). $ is often a searching game.
00:47:19 <quchen> quicksilver: Level 14: $-ify this! https://github.com/quchen/stgi/blob/master/test/Testsuite/Test/Parser/Parser.hs#L114
00:47:20 <quchen> :-D
00:49:18 <dminuoso> Is this lisp?
00:50:04 <dminuoso> quchen: Wew. That project - Ive been looking for something like that. Thanks =o
00:51:01 <quchen> :-)
01:01:42 <Maxdamantus> Had to go make dinner, but ..
01:01:49 <Maxdamantus> 4 :: Int; Int :: Type; Type :: Kind
01:01:55 <Maxdamantus> and Kind :: Sort
01:02:46 <Maxdamantus> This is all fairly logical. Using this notation it is not true that `IO :: Type`
01:03:06 * hackage drinkery 0.4 - Boozy streaming library  http://hackage.haskell.org/package/drinkery-0.4 (FumiakiKinoshita)
01:03:16 <dminuoso> Maxdamantus: And TYPE?
01:03:22 <Maxdamantus> dminuoso: what's TYPE?
01:03:36 <dminuoso> % :i ($)
01:03:37 <yahb> dminuoso: ($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b -- Defined in `GHC.Base'; infixr 0 $
01:04:04 <quchen> I thought we had moved on…
01:04:39 <dminuoso> 10:02     Maxdamantus | This is all fairly logical. Using this notation it is not true that `IO :: Type`
01:04:44 <dminuoso> I do not agree.
01:06:13 <Maxdamantus> dminuoso: if ($) is the ($) in `fix $ id`, then `b` must be a type, so being able to say `b :: TYPE r` means `TYPE` is a function that takes .. something and returns a type.
01:06:39 <dminuoso> It definitely does not return a type. It has to return a kind
01:06:39 <Maxdamantus> dminuoso: ie, it's some kind of the form `k -> *`
01:08:55 <Maxdamantus> dminuoso: sorry, you're right.
01:09:19 <Maxdamantus> dminuoso: so `TYPE` returns a kind (particularly, type)
01:09:34 <dminuoso> Maxdamantus: At any rate, the fact that `a :: IO` is not valid has nothing to do with `IO` not being a type, but rather with `IO` being of the wrong kind.
01:09:36 <Maxdamantus> afk
01:12:37 * hackage deferred-folds 0.6.1 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.6.1 (NikitaVolkov)
01:12:52 <Maxdamantus> So actually, I should have said "returns type", not "returns a type"
01:12:59 <Maxdamantus> otherwise everything else I said was correcty.
01:13:10 <Maxdamantus> (but "type" is a kind, not a type)
01:14:37 <Maxdamantus> er, I used "a type" twice in that first statement; to clarify: only the second use should have been "type"
01:14:45 <dminuoso> you typed too much.
01:14:58 <dminuoso> that's kind of weird!
01:16:42 <Maxdamantus> I think it's sort of okay, as long as there's value to it and it's not just some kind of long-winded type of pun.
01:20:02 <dminuoso> It is quite interesting however how many synonyms we have, for what appear to be very similar ideas.
01:20:07 <dminuoso> box, sort, kind, type, class, set
01:20:22 <frobnicator> it is a beautiful ordering, value type kind sort and it goes on infinitely, only sort has only one member and all his parents as well
01:20:45 <dminuoso> And then TypeInType happened.
01:21:28 <Maxdamantus> And then Girard shaved himself.
01:24:26 <sm> morning all. What's the advantage of TypeApplications, eg read @Int 5, over read (5::Int) ?
01:24:48 <quchen> id @Int
01:25:00 <cocreature> sm: TypeApplications are more useful for cases where there is no argument that determines the type
01:25:18 <sm> ah, thanks
01:25:20 <cocreature> :t show . read
01:25:21 <lambdabot> String -> String
01:25:26 <cocreature> :t show . read @Int
01:25:27 <lambdabot> error:
01:25:27 <lambdabot>     Pattern syntax in expression context: read@Int
01:25:27 <lambdabot>     Did you mean to enable TypeApplications?
01:25:41 <cocreature> % (show . read @Int) "5"
01:25:41 <yahb> cocreature: "5"
01:25:45 <cocreature> % (show . read) "5"
01:25:46 <yahb> cocreature: "*** Exception: Prelude.read: no parse
01:26:15 <cocreature> it can replacet he Proxy arguments that you see fairly often
01:26:20 <cocreature> *replace the
01:26:24 <quicksilver> why does show.read default to String and not () now?
01:26:58 <dramforever> It did
01:27:01 <dramforever> You just don't see it
01:27:24 <dramforever> > (show . read) "3"
01:27:26 <lambdabot>  "*Exception: Prelude.read: no parse
01:27:28 <dramforever> > (show . read) "()"
01:27:30 <lambdabot>  "()"
01:28:11 <dramforever> I mean, if the 'a' ends up in the resulting type there wouldn't be so much of an ambiguity right?
01:28:14 <Taneb> > (show . read) "(())" -- I'm curious
01:28:16 <lambdabot>  "()"
01:28:17 <cocreature> quicksilver: the type of "show . read" is always String -> String. the defaulting is the intermediate type
01:29:02 <dminuoso> sm: Another usecase may be when you have say 6 type arguments but you only want to pin a single type without having to go through the hassle of creating an extra binding with a type signature.
01:29:29 <dramforever> % read @_ "5" :: Int
01:29:29 <yahb> dramforever: 5
01:30:59 <sm> it might be nice if GHC provided some common language pragma groups, that you could enable with one line
01:31:20 <dminuoso> -fglasgow-exts... *shudder*
01:31:33 <cocreature> I just put the stuff that I use over and over in default-extensions
01:31:55 <sm> {-# LANGUAGE Community2018 #-}
01:32:16 <dminuoso> {-# LANGUAGE OneToEnableThemAll #-}
01:32:24 <sm> a step towards racket's #LANG
01:32:26 <cocreature> I can already imagine the bikeshedding that would result from trying to come up with a set of extensions that “the community” approves
01:32:26 <dramforever> {-# LANGUAGE GHC #-}
01:33:09 <dminuoso> cocreature: Well it would be nice if I could create my own groupings.
01:33:24 <dminuoso> When you use servant you tend to always enable the same pragmas..
01:33:29 <sm> a list of modern extensions was shared recently and seemed fairly well accepted
01:33:50 <[exa]> well, {-# LANGUAGE ServantExts #-
01:33:52 <cocreature> there was a GHC proposal for being able to define extension sets iirc
01:33:53 <sm> and it's easy to have multiple groups or to modify groups
01:34:07 <alp> yeah there's a proposal for that
01:34:09 <cocreature> but tbh I kind of don’t care since I started using default-extensions
01:34:16 <alp> and we'd definitely get some mileage out of this, for servant
01:34:43 <quicksilver> cocreature: Oh I was backwards. Thanks :)
01:35:01 <sm> cocreature: default-extensions.. that's in a cabal file right ? I like to declare this in source
01:35:25 <hvr> sm: if you want to declare it in a cabal file, you need other-extensions
01:35:35 <cocreature> sm: right it’s in the cabal file
01:35:43 <hvr> erm, in a .hs file (via LANGUAGE pragmas)
01:36:30 <hvr> the main point being that cabal needs to know which extensions you expect the compiler implementation to provide
01:36:37 <hvr> otherwise it can't solve for it
01:37:24 <sm> hvr: so, if I enable unusual extensions in source files, I might need to redeclare them in .cabal as well ?
01:37:34 <hvr> and any extension for providing language-pragma sets needs to take that into account as well
01:37:41 <cocreature> I still find the idea of other-extensions somewhat silly until we start versioning extensions or something like that
01:37:55 <hvr> cocreature: oh, I'm already thinking about how to version them!
01:38:13 <hvr> cocreature: it's totally silly to have langauge pragmas which change their meaning all the time
01:38:29 <cocreature> great, until we have that I’m going to keep just using a bound on base :)
01:39:30 <hvr> cocreature: yeah, that's a pragmatic approach that currently works out well enough... at some point it won't anymore
01:39:51 * hvr looks at Eta
01:40:34 <cocreature> luckily I didn’t have to care about eta so far :)
01:42:00 <hvr> fwiw, the idea I'm currently investigating is having the pragma versioning be a thing implemented solely in cabal's compiler database
01:42:56 <hvr> and simply extending the other-extensions/default-extensions syntax in .cabal files to allow simple version constraints
01:43:32 <cocreature> what exactly is cabal’s compiler database? the builtin list of compilers that cabal knows about?
01:43:45 <hvr> yes, + some metadata about them
01:44:39 <hvr> for instance for those compilers which don't advertise the supported language pragmas, that registry defines whcih pragmas those compilers support
01:46:56 <cocreature> sounds reasonable although I’m somewhat sceptical that you’ll get people to use other-extensions until there are sufficiently popular compilers for which this matters. (I don’t think eta is near that point yet)
01:48:27 <hvr> well, imho it's easier to use other-extensions than to remember which `base` version corresponds to which ghc version, and whcih ghc versions provided which extension
01:48:38 <hvr> also, if you require e.g. template-haskell
01:48:48 <hvr> then the only way to declare this requirement is via other-extensions
01:48:58 <hvr> there's no other way to specify that you require TH supporrt
01:49:38 <cocreature> that might be true if we were starting from scratch but we already have tons of packages where authors use the base bound for extensions
01:50:12 <hvr> and I've had already to retroactively revise in other-extensions: TemplateHAskell here and there
01:50:16 <hvr> cause it was breaking builds otherwise
01:51:38 <hvr> and it's also more informative to get an error "sorry, you need extensions XY, but your compile didn't provide that" instead of "you need base>=x.y"
01:51:52 <phadej> cocreature: I don't think so. Many bounds are genuine library-bounds, e.g. you want post-AMP base
01:53:13 <cocreature> phadej: I wasn’t suggesting that people use it _exclusively_ for extensions. but I’m pretty sure that getting people to add extensions to other-extensions if their base bound already works for GHC is going to need quite a bit of convincing
01:53:28 <phadej> cocreature: yes, because people are lazy, it's understandable
01:53:40 <phadej> cocreature: but imagine (and hopefully it will true) when `base` becomes reinstallable
01:54:03 <phadej> so you can use base-5 with GHC-9.0 and GHC-9.2
01:54:12 <phadej> even the bundle base-4.123
01:54:26 <cocreature> right once there is a reason that a sufficient amount of people care about, you might have a chance
01:54:58 <phadej> well, as hvr said, there are fair amount of people caring about TH-less GHC
01:55:32 <phadej> but then, some extensions of GHC require changes to base too
01:55:32 <cocreature> I don’t think that number is nowhere near the threshold where it has a chance to impact the wider ecosystem
01:55:36 <quicksilver> phadej: is that a thing (base becoming re-installable?)
01:55:48 <phadej> e.g. TypeInType + Data.Kind module
01:58:38 <phadej> quicksilver: not soon unfortunately
01:58:53 <quicksilver> I thought it was too tightly bound to implementation details for that to be feasible
01:59:05 <quicksilver> although that raises the corollary 'ok is base too big then?'
01:59:21 <phadej> IMO it is too big.
01:59:44 <phadej> GHC.* namespace could (should?) be somewhere else
02:00:03 <hvr> quicksilver: well, there's a portable part of base and a ghc-specific one; first step would be factorise/separate those; also, an easy way would be to rename current base to somethign else, and only reexport the "portable" parts via `base`
02:00:24 <hvr> that 90% of packages use, and which provide a much smaller surface area
02:00:47 <quicksilver> it's hard for people to get that engaged with making things GHC-independent until the community has alernative haskell compilers it wants to support
02:00:53 <hvr> the tricky parts that make reinstallation hard are the parts that are "wired-in" from the compiler
02:01:32 <hvr> that includes unfortunately stuff like the `Monad` class defintions
02:01:52 <cocreature> I feel like most of the GHC.* modules should also be in a different package
02:01:56 <hvr> indeed
02:02:14 <hvr> `base` exposes a lot of internals that are not relevant to normal code
02:02:53 <hvr> and often you're encouraged to use high-level wrapper APIs instead of using GHC.* stuff directly
02:03:03 <merijn> hvr: cabal-plan 0.4 release reminder ;)
02:03:07 <hvr> merijn: thanks!
02:03:25 <merijn> base is somewhat sloppy in which GHC.* things are wrapped and which are not, sadly
02:03:31 <hvr> phadej: was there anything you'd want to get in cabal-plan, or is it ok if I flush it out today?
02:04:02 <hvr> merijn: the one GHC.* module that's probably the most non-internal one is GHC.Generics
02:04:38 <hvr> that's likely the most popularly imported GHC. module accross hackage
02:04:52 <hvr> besides GHC.Prim
02:05:37 * hackage primitive-extras 0.3.0.1 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.3.0.1 (NikitaVolkov)
02:06:16 <phadej> hvr: nope
02:07:16 <phadej> GHC.Generics are kind of ghc-specific, GHC.TypeLits were supposed to be wrapped by libraries, but weren't.
02:07:34 <phadej> and then at work I use GHC.Stats in few places, but that's GHC specific too
02:12:59 <hvr> phadej: I still feel like the GHC.* namespace conflates GHC specific APIs w/ GHC implementation details & primitives
02:14:01 <hvr> and there's also GHC specific things outside the GHC.* namespace
02:14:18 <hvr> Data.Typeable feels GHC specific to me as well
02:14:51 <hvr> or where do you draw the line between something that's GHC specific or not?
02:19:23 <phadej> hvr: fair, Data.Typeable is about as ghc-specific as GHC.Generics
02:19:56 <phadej> library part is quite general, but then you need compiler support (to write instances for you)
02:20:46 <gentauro> :o -> https://lpaste.net/
02:20:53 <gentauro> no more copy/pasta?
02:21:48 <merijn> Chris already removed the archive and half the features of lpaste, I guess this is the next step to get someone to take it over?
02:22:04 <mniip> shameless plug: https://tcpst.net/
02:22:40 <merijn> I'm still sad about the death of ircbrowse. Although at least I won't be confronted by the amount of time on IRC :p
02:23:24 <gentauro> merijn: this reddit post? https://www.reddit.com/r/haskell/comments/862k28/looking_for_new_maintainer_of_lpastenet/
02:24:52 <merijn> gentauro: Chris announced he was looking for people to take over his projects for a while now, due to work load and RSI complaints
02:26:17 <mniip> register source index?
02:26:51 <gentauro> merijn: I wouldn't put this on the internet -> https://www.reddit.com/r/haskell/comments/862k28/looking_for_new_maintainer_of_lpastenet/dw2bmc4/
02:27:08 <merijn> gentauro: Why not?
02:27:16 <gentauro> I've have been posting as "an anonymous coward" but I have seen that people post with their real names and stuff
02:27:25 <gentauro> since the 25th of may
02:27:38 <gentauro> that might not be very smart, at least if it contains European citizens
02:27:42 <merijn> gentauro: But it was already public
02:28:05 <gentauro> (I'm trying to find a link where Coding Pirates removed all user info and left codes snippets available)
02:28:24 <gentauro> merijn: yes, and before it's wasn't ilegal and now it might be ...
02:28:27 <gentauro> I'm just saying
02:28:36 <merijn> gentauro: Also: 1) GDPR applies to anyone living in the EU, not just citizens and 2) lpaste clearly doesn't need consent for lawful base
02:29:03 <gentauro> GDPR applies to EVERYTHING that has personal data
02:29:38 <merijn> gentauro: Yes, but "consent" is only one of 6 lawful bases for processing personal data
02:29:56 <merijn> gentauro: And despite everyone always talking about consent some of the other ones are much more applicable in most cases
02:30:46 <gentauro> merijn: I have read the hole thing
02:30:59 <gentauro> I was even part of a group with lawyers and so
02:31:05 <merijn> "contract" basis is a much more obvious choice for lpaste
02:31:40 <gentauro> merijn: if I would host lpaste, I would only allow people to post as anonymous cowards
02:31:43 <gentauro> that would solve the issue
02:32:00 <gentauro> (unless somebody post "personal data" in the code field)
02:49:25 <gentauro> if I really would like to have this -> https://pastebin.com/TYztUtzs, do I need to move each class instance to it's own file or is there a "LANGUAGE pragma" that can help?
02:49:52 <gentauro> (I really dislike the fooBarFoo / bazQuxFoo notation)
02:50:10 <gentauro> class instance = class def
02:51:03 <cocreature> you need to put them into their own modules
02:51:21 <cocreature> but having two typeclasses that provide the exact same name seems at least somewhat questionable
02:52:17 <gentauro> cocreature: when you model real life scenarios, stuff like this happens ;)
02:52:25 <gentauro> welcome to the "real" world ;)
02:52:58 <gentauro> but thx, I will create a file (synonymous with module) for each
02:53:39 <cocreature> nobody forces you to choose the same names for Haskell identifiers than you might find in the “real world”
02:53:59 <cocreature> if you need two different typeclasses there is obviously something different between the two so reflecting that in the name is not necessarily a bad idea
02:54:11 <tdammers> gentauro: "only allow to post as anonymous cowards" still doesn't automatically get you in the clear
02:54:25 <tdammers> gentauro: what if people put personal data into the paste itself?
02:54:46 <gentauro> tdammers:
02:54:48 <gentauro> 11:31 < gentauro> merijn: if I would host lpaste, I would only allow people to post as anonymous cowards
02:54:54 <gentauro> 11:31 < gentauro> that would solve the issue
02:54:57 <gentauro> 11:31 < gentauro> that would solve the issue
02:55:09 <gentauro> 11:31 < gentauro> (unless somebody post "personal data" in the code field)
02:55:17 <gentauro> tdammers: already stated that ;)
02:55:23 <tdammers> ah... missed that part
02:56:10 <gentauro> tdammers: but we have ways to solve that ;)
02:56:51 <tdammers> although I believe that this is similar to other "communication infrastructure" type services, like e-mail or whatsapp
02:57:08 <tdammers> I doubt whatsapp can be held responsible for people using it to exchange personal information in plain messages
02:57:57 <tdammers> I have no idea what the legal reality is, but I would wager that when you post personal data through such a service, it's you who is responsible for it, not the service
02:58:53 <tdammers> also, laws like these are often misinterpreted to be about technical implementation details, when really they are about social constructs
02:59:36 <tdammers> just like the fact that when your CD player plays a CD, it technically copies the CD into its playback buffers, doesn't create a copy in the legal sense
03:01:51 <gentauro> tdammers: the EU GDPR distinguis between "data controller and data processor"
03:02:22 <gentauro> the "data controller" can never withdraw responsability
03:02:29 <gentauro> to any other part
03:02:49 <gentauro> if something go wrong (fines) they will point in their direction
03:03:25 <gentauro> ofc, they will have some "juicy contracts" with ther "data controllers" that if it's them who fuck up, they will probably take a big part of the fine ...
03:03:33 <gentauro> (that's just law, and here I can't help)
03:04:05 <gentauro> what I can't help with, is to ensure that "data controller" will have "total control" over their "defined process"
03:04:14 <gentauro> this is what I call "uniprocesses"
03:05:11 <gentauro> I have went to so many meetings in Denmark with regard of EU GDPR and it's always some "douches" in suits (D,KPMG, ...) talking so much "hot air" about if they just "take their consulting services" they are home safe
03:05:28 <cocreature> this is moving a bit too far into offtopic territory
03:05:38 <gentauro> people in the audience always seem to ask: "Yeah, that sounds OK, could you please state technical solutions for us? Thanks"
03:05:43 <gentauro> and they go silent
03:05:48 <gentauro> cocreature: roger that
03:06:28 <gentauro> tdammers: just to finish it off, this is why Haskell and it's ecosystem is such a "life safer" ;)
03:12:22 <tdammers> gentauro: harbor of sanity
03:12:32 <tdammers> gentauro: the occasional weirdness nonwithstanding
03:13:30 <gentauro> tdammers: :)
03:16:34 <gentauro> tdammers: this is how I visualize my uniprocesses -> https://i.imgur.com/bOQbqee.png (in the center you can do all effects (IO), while for each ring you can do a reduced set of effects, ending with the leafs where you normally just can do a single side-effect)
03:17:17 <gentauro> tdammers: that's why I state that my uniprocess have isolated and (recursively) granulated effects ;)
03:17:34 <gentauro> that's why it's so important for my only to rely on "safe" packages
03:17:50 <gentauro> and "trustworthy" ofc
03:29:48 <dminuoso> Is there some easy and elegant way to do product record types? Perhaps something along the lines of: data Foo = Foo { a :: Int, b :: Int }; data Bar = Bar (Foo{..} * {c :: Int, d :: Int})
03:30:32 <cocreature> dminuoso: sounds like you are looking for extensible records? or is there something special about “product record types”
03:30:41 <dminuoso> cocreature: Oh I guess yeah.
03:31:42 <cocreature> there are various packages for those, someone made a comparison table recently https://docs.google.com/spreadsheets/d/14MJEjiMVulTVzSU4Bg4cCYZVfkbgANCRlrOiRneNRv8/edit#gid=0
03:31:58 <cocreature> but personally I haven’t found one that is sufficiently nice for me to actually use it
03:32:24 <cocreature> but I think I also just hate boilerplate (or at least some kinds of boilerplate) a lot less than some other parts of the Haskell community
03:34:08 <dminuoso> cocreature: Well Im okay with the boilerplate kind of, so some crazy unergonomic library using whatever deep black singleton type machinery to fake extensible records likely is not going to make things better..
03:34:18 <dminuoso> Especially since I dont have an actual problem to solve
04:40:21 <pally> https://imgur.com/a/BL9XA2s
04:40:48 <pally> tick :: M ()
04:41:01 <pally> tick :: State -> ( (), State)
04:41:28 <pally> tick = \s = ((), s+1)
04:42:26 <pally> question: why does `()` appear in both the type signature
04:42:39 <pally> and in the definition
04:42:45 <frobnicator> the only value of type () is ()
04:42:50 <pally> ?
04:43:39 <frobnicator> The type of tick is State -> ( (), State), it is a function that given a state will return a tuple with in the left side something of type () and in the right side something of type State
04:44:04 <frobnicator> type () only has one inhabitant namely ()
04:44:06 * hackage puzzle-draw 0.3.0.0 - Creating graphics for pencil puzzles.  http://hackage.haskell.org/package/puzzle-draw-0.3.0.0 (vollmert)
04:45:55 <pally> frobnicator, I am kinda confused by this.  Typically I am used to seeing something like:
04:46:09 <cocreature> pally: you know how constructors can have the same names as types?
04:46:10 <pally> tick :: State -> ( Int, State)
04:46:14 <cocreature> e.g. "data X = X"
04:46:31 <cocreature> that creates a type called "X" and a constructor called "X" that takes no arguments
04:46:45 <cocreature> replace X by () and you get ()
04:47:14 <dminuoso> () :: ()
04:47:23 <AfC> cocreature: [nice explanation there]
04:48:18 <pally> cocreature, okay but here's the thing, in his example, "data () = ()" never decarled
04:48:31 <dminuoso> pally: Because its done in Prelude.
04:48:44 <cocreature> pally: () is built into the compiler but its declaration is equivalent to "data () = ()"
04:48:54 <pally> ohhh...
04:49:08 <dminuoso> Oh.. () is actually compiler builtin?
04:49:39 <pally> yea, I didn't know about that ^^;
04:50:01 <hpc> i suppose if you're making it special syntax anyway, you only want to define it in one place
04:50:19 <hpc> instead of making sure every part of the parser treats it properly
04:50:26 <Cale> dminuoso: Yeah, you can't use parentheses as parts of names of stuff usually
04:50:38 <cocreature> I don’t really know how the wired in types work but there is actually a definition in ghc-prim https://hackage.haskell.org/package/ghc-prim-0.5.2.0/docs/GHC-Tuple.html#t:-40--41-
04:50:48 <cocreature> but you can’t define it yourself afaik
04:51:20 <dminuoso> https://hackage.haskell.org/package/ghc-prim-0.5.2.0/docs/src/GHC.Tuple.html#%28%29
04:51:20 <cocreature> and GHC definitely treats it specially, e.g., you don’t get unused warnings for () in do blocks
04:52:14 <marvin2> would you get unused warnings for custom data that has only one possible value?
04:52:43 <dminuoso> marvin2: No, but if you have only one possible value you might want to use () instead.
04:52:59 <cocreature> dminuoso: oh you don’t? I thought GHC emitted warnings in that case
04:53:04 <dminuoso> It did? Huh?
04:53:06 <marvin2> I know. just tried to figure out if gcc was treating () specially
04:53:18 <pally> cocreature, "the only value of type () is ()", yet the presenter of the tutorial says that "() is the actual value that *might* get computed"
04:53:38 <pally> what is the purpose of () really?
04:53:47 <pally> i.e., when do you use it?
04:53:47 <dminuoso> pally: It has the same purpose as `void` in C.
04:53:56 <dminuoso> pally: It's to denote that no useful information is carried in some place.
04:54:21 <cocreature> dminuoso: https://gist.github.com/cocreature/8b5ab0be500aba8fa37fdb8235498ab6 emits a warning
04:54:42 <dminuoso> pally: Let's say you have a list of [IO String] actions and you want to execute them sequentially (i.e. create a single IO action), but you want to discard the result.
04:54:47 <dminuoso> Then the appropriate type would be `IO ()`
04:55:29 <cocreature> pally: can you link us to the tutorial? it’s somewhat hard to comment on a single sentence that probably belongs to a larger context
04:55:53 <dminuoso> :t [getLine, getLine, getLine]
04:55:55 <lambdabot> [IO String]
04:55:57 <dminuoso> :t sequence_ [getLine, getLine, getLine]
04:55:58 <lambdabot> IO ()
04:56:15 <pally> https://www.youtube.com/watch?v=mOs2HCgWyKI&t=324s
04:56:39 <dminuoso> pally: Do you understand why `putStrLn "foo" :: IO ()`
04:57:05 <pally> I don't know about IO string, unfortunately.
04:57:10 <dminuoso> cocreature: I think I may need to use Wall more. =<
04:57:21 <pally> But i am trying to follow ^^
04:57:35 <merijn> dminuoso: You should use -Wall always, tbh
04:57:49 <cocreature> yeah, I just turn on -Wall everywhere
04:57:52 <dminuoso> merijn: I have this nasty habit of generating stack projects and using default a bit too much. :(
04:58:14 <cocreature> make your own template that has -Wall enabled?
04:58:52 <cocreature> pally: sry don’t have time to watch some video right now :/
04:59:34 <dminuoso> pally: getLine is an effect that, when executed, will produce a String as the result.
05:00:42 <dminuoso> pally: For some choice `x`, a value of type `IO x` is an action that, when executed, will produce some result. For some things however we have no meaningful result, but _something_ needs to go there. So how would you characterize an action that has some side effects but no meaningful result?
05:02:02 <pally> dminuoso, is `x` a type variable/
05:02:03 <pally> ?
05:02:27 <dminuoso> pally: In this case no. It's some type that I have not further specified
05:03:00 <dminuoso> you could pretend there exists some `readNumberFromDatabase :: IO Int`
05:03:06 <dminuoso> Or maybe some `getLine :: IO String`
05:03:22 <dminuoso> `launchMissiles :: IO Bool` here the Bool might indicate whether the launch was successful
05:03:38 <dminuoso> So () denotes the lack of any information.
05:03:48 <dminuoso> It's the type that can carry no information.
05:03:50 <cantordust_> Hi , I am a B.Tech in Computer Scince and wanted to explore the domains of functional programming , type theory and category theory. Hence I wanted to know what are the mathematical prerequisites in order to learn type theory and category theory
05:04:48 <hpc> cantordust_: not much
05:04:55 <dminuoso> cantordust_: Some minor algebra and perhaps really rudimentary set theory is enough to dive into category theory
05:04:59 <pally> dminuoso, you say pretend there exists some `getLine :: IO String` but it does exist.  I just tried it.
05:05:07 <hpc> it's more of a "mathematical mind" kind of thing to really do well with the complicated parts
05:05:09 <dminuoso> pally: yes that one actually does exist =)
05:05:40 <cocreature> cantordust_: it’s helpful if you have been exposed to some algebra not because you necessarily need it as a prerequisite but it tends to teach you a certain mindset that’s helpful
05:05:51 <hpc> also fwiw, as much attention as category theory gets here i suggest focusing on type theory if your goal is to be a better programmer
05:06:11 <hpc> it's easier (imo) and applies damn near everywhere
05:07:50 <dminuoso> "Category theory is the mathematics of mathematics"
05:08:15 <cantordust_> thats a nice recursive definition :P
05:09:27 <cantordust_> @channel could you suggest me some good introductory books / courses in order to learn type theory ?
05:09:27 <lambdabot> Unknown command, try @list
05:09:43 <cantordust_> @list could you suggest me some good introductory books / courses in order to learn type theory ?
05:09:43 <lambdabot> No module "could you suggest me some good introductory books / courses in order to learn type theory ?" loaded
05:09:47 <dminuoso> cantordust_: TaPL is worth mentioning, it's one of the traditional and frequently mentioned books.
05:09:48 <hpc> cantordust_: it's true under every permutation of ["category theory", "mathematics", "mathematics"]
05:10:38 <cocreature> I fell into the trap of trying to learn way too much category theory when I learned Haskell. it was fun, so I don’t regret it but in terms of learning Haskell, I definitely could have spent my time better
05:10:52 <dminuoso> But TaPL does require some good comfort with things like inductive proofs.
05:11:02 <dminuoso> Chances are most type theory books will have the same requirements.
05:11:30 <cantordust_> inductive proofs and basic algebra is good to go with me
05:12:10 <dminuoso> cantordust_: Are you more interested in theory or more into applied type systems in programming?
05:13:25 <merijn> tbh, TaPL is the starting point for both of those :p
05:14:18 <la5tl19ht> I found https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/ a good introductory read
05:14:50 <la5tl19ht> for an overview at least
05:18:19 <obiwahn> int-e: i try to get lambdabot running with stack
05:19:00 <obiwahn> After setting the ghc package path i mueval started working.
05:19:21 <obiwahn> s/ i//
05:20:56 <obiwahn> Is lambdabot using the same path to run mueval that it gets provided by the environment for itself?
05:21:12 <cantordust_> @dminuoso I'm first wanna learn about the applications of type theory in programming and implement some projects related to the same while slowly learning the theory part as well
05:21:13 <lambdabot> Unknown command, try @list
05:21:14 <pally> :t putStrLn
05:21:16 <lambdabot> String -> IO ()
05:21:22 <cantordust_> *I first
05:21:33 <readright> what is the right way to interpret the following types, such that the difference in intention is clear: list1 :: forall a. [a -> a] and list2 :: [forall a. a -> a]
05:21:57 <dminuoso> cantordust_: TaPL is definitely a great pick. I think you can get a free copy on several uni websites.
05:22:08 <readright> (this is from Richrd Bird's Thinking Fuctionally  book)
05:22:39 <int-e> obiwahn: yes it does
05:23:48 <dminuoso> cantordust_: I tend to read `forall` as /\ in the System F sense.
05:23:58 <dminuoso> Err sorry, that was supposed to be for readright.
05:24:02 <Cale> readright: Those happen to be isomorphic types, mostly by chance.
05:24:28 <cantordust_> dminuoso: What are some projects that you would suggest one can implement in order to get a hang on haskell ?
05:24:31 <readright> is [id] the only possible value for both (ignoring bottom)?
05:24:49 <Cale> Well, [id, id, id] is as well
05:24:58 <Cale> of course, the empty list
05:25:25 <readright> OK ... but in his book, he says " For example, [sin,cos,tan] is a possible value of list1 with the instantiation Float for a."
05:25:34 <dminuoso> readright: Are you perhaps interested in something like `[forall a. Num a => a]` vs `forall a. Num a => [a]`
05:25:46 <Cale> readright: That wouldn't be sufficiently polymorphic
05:26:14 <readright> right, so is it a typo in the book?
05:26:25 <Cale> readright: I can't see what the book says at the moment
05:26:48 <Cale> > [sin, cos, tan] :: forall a. [a -> a]
05:26:49 <cocreature> that sounds like he is considering something like "forall a. [a -> a] -> b" and "[forall a. a -> a] -> b"
05:26:50 <readright> just going on what I pasted in then :)
05:26:50 <lambdabot>  error:
05:26:50 <lambdabot>      • No instance for (Floating a1) arising from a use of ‘sin’
05:26:50 <lambdabot>        Possible fix:
05:27:01 <Cale> ^^ but as you can see, it's a type error
05:27:39 <readright> list1 :: forall a. [a -> a]
05:27:45 <readright> list2 :: [forall a. a -> a]
05:27:59 <readright> The type of list1 is just what we would have previously written as [a -> a] because in ordinary rank 1 types universal quantification at the outermost level is assumed. For example, [sin,cos,tan] is a possible value of list1 with the instantiation Float for a.
05:28:21 <Cale> Yeah, that's simply false.
05:28:40 <mniip> "with the instantiation of Float for a"
05:28:41 <readright> can that be right, in any circumstances - just got stuck trying to get it to compile
05:28:47 <mniip> not sure that's a useful statement
05:29:01 <dminuoso> readright: If your book has sentences like that, you might want to reconsider the choice of learning materials.
05:29:16 <Cale> Well, usually Richard Bird isn't so bad ;)
05:29:22 <readright> well, I think generally it is very good
05:29:23 <Cale> But this is an error
05:29:24 <dminuoso> cantordust_: Do not worry about cluttering this channel. =)
05:29:31 <readright> But there are only two functions that can be elements of list2, namely id and the undefined function undefined, because these are the only two functions with type forall a. a -> a
05:29:38 <readright> (that is how he follows up)
05:29:45 <dminuoso> cantordust_: Pick a project you like and ideally also use.
05:29:48 <readright> which, seem to make more sense
05:30:03 <Cale> readright: now, if we left the a unquantified...
05:30:08 <mniip> readright, that's a misleading statement
05:30:13 <mniip> it's tehcnically correct
05:30:23 <readright> re list2?
05:30:34 <mniip> no, re the distinction he's trying to draw
05:30:40 <Cale> It's not technically correct to say that [sin, cos, tan] is a possible value of something whose type is forall a. [a -> a]
05:30:43 <readright> so, I am ignoring everything written there re list1 :)
05:30:51 <mniip> the distinction he's trying to demonstrate doesn't exist
05:31:01 <Cale> It is okay if we didn't have that forall though.
05:31:18 <readright> isn't the lsit1 forall implicit anyway?
05:31:21 <Cale> [sin, cos, tan] is a possible value of type [a -> a]
05:31:30 <cantordust_> Coz I have just learned haskell its very fresh I needed to implement something (preferably a mathematical project) so any suggestions ?
05:32:11 <Cale> (but only with further restrictions on a which make it impossible to universally quantify like that)
05:32:23 <Cale> :t [sin, cos, tan]
05:32:24 <dminuoso> cantordust_: What are your interests? What did you focus on in your B.Sc?
05:32:24 <lambdabot> Floating a => [a -> a]
05:32:27 <readright> exactly what I am finding
05:32:35 <Cale> forall a. Floating a => [a -> a]
05:32:47 <Cale> would be the most general polymorphic type for it in Haskell
05:33:06 <readright> I would have said so too.
05:33:21 <readright> OK, so I think I can ignore that paragraph
05:33:44 <Cale> If it weren't for the forall, it might be okay
05:33:54 <readright> FYI, this was all in the context of how the quantifiers are used to ensure STref doesn't leak out of ST
05:34:01 <Cale> I find it odd that he would explicitly mention the forall there.
05:34:12 <Cale> We could have picked a better example
05:34:36 <[exa]> cantordust_: take gloss library and make a decent octonion mandelbrot fractal viewer?
05:34:38 <mniip> readright, do you understand the distinction between  forall a. A a -> B,  and  (forall a. A a) -> B
05:35:04 <[exa]> cantordust_: you've got it working in no time and there's a lot of stuff to improve later on
05:35:52 <readright> mniip - I thought I did, but maybe not any more!
05:36:38 <Cale> readright: Consider a function like this: foo f = (f "hello", f [1,2,3])
05:36:54 <readright> OK
05:37:13 <Cale> If you try to write this, type inference will fail, and you'll get a type error
05:37:19 <readright> yes
05:37:33 <Cale> But for example, reverse should be a perfectly acceptable argument to this function, as should id
05:37:36 <readright> f can't be [Char] and [Int]
05:37:57 <readright> agreed
05:38:24 <readright> s/can't be/can't take
05:38:38 <Cale> right
05:39:02 <Cale> But we can give this function a higher rank type, insisting that f be polymorphic:
05:39:20 <Cale> foo :: (forall a. [a] -> [a]) -> ([Char], [Int])
05:39:24 <marvin2> why can't f take [a] there?
05:40:32 <Cale> Basically because of how type inference proceeds. When f is applied to "hello", it will learn that f :: [Char] -> b for some type b
05:41:20 <merijn> Cale: If you ever get tired of writing out RankN explanations, I wrote one that people can just link ;) https://gist.github.com/merijn/77e3fa9757658e59b01d
05:41:24 <Cale> and when f is applied to [1,2,3], well, it will (kind of) learn that f :: [Int] -> b, and Int doesn't match Char
05:41:44 <Cale> Well, more pedantically, in Haskell, it will learn that f has type [a] -> b where a must be an instance of Num
05:41:58 <Cale> and then it will complain that it can't find an instance Num Char
05:42:32 <Cale> > let foo f = (f "hello", f [1,2,3]) in foo
05:42:34 <lambdabot>  error:
05:42:35 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
05:42:35 <lambdabot>      • In the expression: 1
05:42:50 <mniip> foo f = (f "hello", f [fromInteger 1 :: Char, fromInteger 2 :: Char, fromInteger 3 :: Char])
05:42:53 <mniip> I don't see a problem :P
05:43:25 <jazwzd> is forall a. A a a type? If so, what does it look like?
05:43:50 <Cale> jazwzd: depends on how A looks
05:44:08 <dramforever> :t let foo f = (f "hello", f [False, True]) in foo
05:44:08 <dramforever> :t let foo f = (f "hello", f [False, True]) in foo
05:44:09 <lambdabot> error:
05:44:09 <lambdabot>     • Couldn't match expected type ‘Char’ with actual type ‘Bool’
05:44:09 <lambdabot>     • In the expression: False
05:44:09 <lambdabot> error:
05:44:09 <lambdabot>     • Couldn't match expected type ‘Char’ with actual type ‘Bool’
05:44:10 <Cale> marvin2: GHC will never instantiate a type variable (like the type of the function f) to a polymorphic type on its own
05:44:11 <lambdabot>     • In the expression: False
05:44:14 <merijn> jazwzd: In "regular" Haskell all types have an implicit forall for every type variable
05:44:29 <jazwzd> Cale: so would A be something like Maybe?
05:44:32 <Cale> Right, it might be less confusing to use a list of Bool values
05:44:32 <merijn> jazwzd: i.e. "id :: a -> a" is equivalent to "id :: forall a . a -> a"
05:44:47 <readright> Calle - I'm still - just trying to see if I can paraphrase the difference between your 2 foos
05:44:51 <Cale> jazwzd: perhaps
05:44:57 <c50a326> why does this https://ptpb.pw/kmLh/hs give this error: *** Exception: myfile.txt: hGetBufSome: illegal operation (handle is closed)
05:45:01 <Cale> jazwzd: There's a value of type forall a. Maybe a
05:45:05 <Cale> :t Nothing
05:45:06 <lambdabot> Maybe a
05:45:24 <Cale> ah, lambdabot doesn't quantify :)
05:45:34 <merijn> c50a326: You use lazy bytestring
05:45:43 <dramforever> c50a326: By the time handler returns the file hasn't been read yet
05:45:45 <dramforever> because lazy
05:45:50 <merijn> c50a326: Lazy hGetContents does lazy IO and doesn't actually perform the IO until forced
05:45:58 <merijn> c50a326: However, withFile closes the file when it returns
05:46:17 <merijn> c50a326: So by forcing it (by doing putStr) after returning from withFile you try and access a closed file
05:46:25 <jazwzd> Cale: that makes a lot of sense, thanks!
05:46:35 <merijn> c50a326: Either use a strict ByteString *or* do the print inside handler
05:47:10 <readright> Cale - in words, how would you describe the type of the 2nd foo, compared to the first?
05:47:12 <merijn> c50a326: Alternatively, use one of the streaming libraries (pipes/conduit/machines) that were invented to solve exactly this annoyance with lazy IO :)
05:47:32 <readright> it seems liek a sencond layer of polymorphism?
05:47:46 <dramforever> polymorphic function arguments
05:47:52 <mniip> readright, "rank 2"
05:47:53 <merijn> readright: It's a difference of *who* gets to pick the type 'a', the function caller or the function being called
05:47:56 <revskill> Haskell is not actually like programming, it's more like connecting the dot game :(
05:48:27 <Cale> revskill: hm? :)
05:48:28 <readright> merijn - that's an interesting way to look at it - just need to mull it over
05:48:32 <merijn> readright: In Cale's example, do *you* (the caller of foo) pick what 'a' is, or does 'foo' decide what 'a' is
05:48:45 <tian> How to comprehend this: isAscOrder = sort >>= (==)
05:48:49 <merijn> readright: See also the example I wrote up: https://gist.github.com/merijn/77e3fa9757658e59b01d
05:48:54 <revskill> yes, i mean to achieve some complex processing, i have to search for types to connect together
05:49:00 <c50a326> cool, thanks
05:49:07 <revskill> and sometimes have no idea why it works
05:49:07 <mniip> tian, it uses the Monad ((->) e) isntance
05:49:14 <mniip> does this knowledge help
05:49:17 <merijn> readright: The problem with it is that mangle has to decide what the type 'a' is, instead of *the caller of mangle*
05:50:02 <dramforever> https://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.Base.html#line-804
05:50:28 <dramforever> f >>= k = \r -> k (f r) r
05:50:39 <readright> merijn - that's a nice example too, thanks!
05:50:48 <mniip> dramforever, I tried not to spoil it too much
05:50:49 <dramforever> You will know what this means if you know 'Reader'
05:50:56 <dramforever> mniip: There's no point
05:51:10 <dramforever> I think
05:51:21 <mniip> also that function looks inefficient
05:51:32 <merijn> readright: So having the Rank2 tyes (i.e. the forall inside the first argument) is saying "mangle works if you give it a function that works for all possible values of type 'a' that are Num instance", whereas the "normal" version says "I will work for any function you want as long as the 'a' happens to be Num" so you'd be allowed to pass "Int -> Int -> Int" too
05:51:36 <mniip> I'd optimize it as  all (curry (<=)) . ap zip tail
05:51:39 <dramforever> If you come over to here: https://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Monad.html#t:Monad
05:52:02 <dramforever> And click on the 'Source' link next to 'Monad ((->) r)'
05:52:13 <dramforever> You will see the, well, source
05:52:14 <merijn> readright: It's kinda tricky to "get" what the difference is, until you hit a concrete case like this and you go "ooh!"
05:52:19 <Cale> revskill: Well, that's a lot better than having no idea what could possibly fit together meaningfully :)
05:52:21 <mniip> dramforever, looks like they weren't listening this entire time :)
05:52:31 <dramforever> Maybe already got it
05:52:36 <tian_> mniip: I know that... but i dont know how it works...
05:52:43 <dminuoso> readright: I try to read forall quantification as a type argument. So when you think about it, it gets clear at what point the choice for the type needs to be done.
05:52:51 <dramforever> Want a more 'practical example' of a rank 2 type?
05:52:59 <mniip> tian_, then see dramforever's link for the definition of >>= in this case
05:53:08 <dramforever> @let data Number = IN Integer | DN Double
05:53:09 <lambdabot>  Defined.
05:53:59 <dramforever> It would be helpful to have: liftNum2 :: (forall a. Num a => a -> a -> a) -> Number -> Number -> Maybe Number
05:54:06 <dminuoso> readright: so a `polymorphic value` is a value that is abstracted over a type, that is it's missing a type that has not been decided. If you hold something polymorphic `x` in your hand then you can simply create some (x @Int, x @Float, x @Char)
05:54:29 <dminuoso> readright: TypeApplications is what made it click for me =)
05:54:53 <dramforever> @let liftNum2 :: (forall a. Num a => a -> a -> a) -> Number -> Number -> Maybe Number; liftNum2 f (IN x) (IN y) = f x y; liftNum2 f (DN x) (DN y) = f x y; liftNum2 _ _ _ = Nothing
05:54:54 <lambdabot>  .L.hs:174:28: error:
05:54:54 <lambdabot>      • Couldn't match expected type ‘Maybe Number’
05:54:54 <lambdabot>                    with actual type ‘Integer’
05:55:02 <Cale> readright: Rank 0 types are those which involve no foralls. Rank n+1 types consist of those of rank n, as well as functions from a rank n type to a rank n+1 type, as well as foralls of rank n+1 types.
05:55:11 <dramforever> @let liftNum2 :: (forall a. Num a => a -> a -> a) -> Number -> Number -> Maybe Number; liftNum2 f (IN x) (IN y) = Just (f x y); liftNum2 f (DN x) (DN y) = Just (f x y); liftNum2 _ _ _ = Nothing
05:55:12 <lambdabot>  .L.hs:174:28: error:
05:55:12 <lambdabot>      • Couldn't match type ‘Integer’ with ‘Number’
05:55:13 <lambdabot>        Expected type: Maybe Number
05:55:24 <dramforever> Uhh, the 'lambdabot error syndrome'
05:55:35 <Cale> So for instance, Int -> Bool is rank 0, forall a. a -> a is rank 1, as is Int -> (forall a. a -> a)
05:55:46 <mniip> dramforever, Just (IN ...)
05:55:55 <Cale> but then (forall a. a -> a) -> Int is rank 2
05:56:24 <readright> first I've heard of TypeApplications
05:57:05 <Cale> I really dislike the way that extension works.
05:57:34 <dramforever> @let liftNum2 :: (forall a. Num a => a -> a -> a) -> Number -> Number -> Maybe Number; liftNum2 f (IN x) (IN y) = Just (IN $ f x y); liftNum2 f (DN x) (DN y) = Just (DN $ f x y); liftNum2 _ _ _ = Nothing
05:57:35 <lambdabot>  Defined.
05:57:40 <Cale> It's a good idea, but it doesn't require that things were defined with explicit foralls in order to be able to use it.
05:57:51 <dramforever> > liftNum2 (+) (IN 3) (IN 7)
05:57:52 <lambdabot>  Just (IN 10)
05:58:01 <dramforever> > liftNum2 (+) (DN 4.2) (DN pi)
05:58:03 <lambdabot>  Just (DN 7.341592653589793)
05:58:06 <dminuoso> Cale: Because the order can be quite confusing.. :-|
05:58:20 <dramforever> This one actually requires RankNTypes to work
05:58:27 <Cale> So a library author who doesn't even use TypeApplications who wants to introduce an explicit forall on the type variables now needs to care about the order of the variables in the forall.
05:58:55 <Cale> because other code which uses the library might use TypeApplications
05:59:02 <dramforever> Named parameters :p
05:59:37 * hackage quickcheck-classes 0.4.13 - QuickCheck common typeclasses  http://hackage.haskell.org/package/quickcheck-classes-0.4.13 (andrewthad)
06:00:02 <Cale> (and make sure it matches GHC's arbitrary convention)
06:00:08 <dramforever> Currying :(
06:00:19 <Cale> What about currying?
06:00:46 <dramforever> I mean, named parameters and currying seem kinda conflicting
06:01:18 <dramforever> I don't think there'll be a problem for fmap @f=[]
06:01:59 <Cale> I think we should just require explicit foralls to have been used in the definition.
06:02:01 <dramforever> But apparently that's not how it works for now
06:02:07 <Cale> Similar to ScopedTypeVariables
06:02:35 <Cale> Of course, that will probably break some code by now.
06:03:22 <dminuoso> readright: So I just think about "who gets to apply this function to a type". f :: Num a => a -> a; f x = ...{in here x is not polymorphic. we cannot simply decide to use `x @Float`}...
06:03:55 <readright> Cale - mentioning Rank 0, too, is a nice touch
06:05:22 <dramforever> What do you know, there's a package for named parameters
06:05:26 <dramforever> @hackage named
06:05:26 <lambdabot> http://hackage.haskell.org/package/named
06:08:59 <readright> I will play around with the RankN ideas, and no doubt come back with more concrete questions about how St hides STRefs :)
06:09:08 <readright> thanks
06:10:08 <Cale> readright: Well, I can explain the STRef thing
06:10:12 <Cale> :t runST
06:10:13 <lambdabot> (forall s. ST s a) -> a
06:10:18 <Cale> :t newSTRef
06:10:20 <lambdabot> a -> ST s (STRef s a)
06:10:33 <dminuoso> readright: Give me a function `forall a. Int`, and Ill tell you Int using that "function". Would you believe me that you have absolutely no way of knowing what my choice for the type variable `a` is?
06:12:11 <merijn> readright: The "Lazy Functional State Threads" paper introduces ST and goes rather in-depth to how the RankN stuff works, it's pretty readable
06:12:17 <Cale> readright: The type of each STRef involves this s parameter, and runST will only run actions which are polymorphic in the choice of s. If you were to bring in some STRef from elsewhere and try to read or write it, its choice of s may not match the s for your particular runST, so that would result in a type error.
06:14:34 <Cale> Moreover, simpler attempts to smuggle out STRefs will fail -- if you runST (newSTRef 0) for example, that will complain, because you can't choose an 'a' which would work when 's' isn't in scope yet.
06:14:46 <Cale> :t runST (newSTRef 0)
06:14:48 <lambdabot> error:
06:14:48 <lambdabot>     • Couldn't match type ‘a’ with ‘STRef s Integer’
06:14:48 <lambdabot>         because type variable ‘s’ would escape its scope
06:16:30 <Cale> It is possible by other means to smuggle out STRefs, but it's still not possible to make use of them from other occurrences of runST, even if you do.
06:17:29 <Taneb> Hmm, there hasn't been any release to the vector library in like a year
06:17:30 <obiwahn> int-e: Deng it! I am fighting lambdabot for some time now. Could you help me a bit to get it running?
06:17:39 <gentauro> for fast ht, this is the right option -> http://hackage.haskell.org/package/hashtables (correct?)
06:17:53 <cantordust> i had graph theory, group theory, ML, AI, NLP, social network analysis as my electives and took an additional course on linear algebra and game theory
06:18:10 <cantordust> so i wanted to know some basic mathematical projects i can develop using haskell
06:18:18 <cantordust> as i have learned the language recently
06:18:25 <cantordust> and wanted to get a good hang on it
06:19:15 <dminuoso> `instance FromJSON Instance`
06:19:17 <dminuoso> This looks good.
06:20:35 <obiwahn> "admin + freenode:e-int" do i add multiple lines like that or just a single one with man users?
06:20:49 <obiwahn> s/man/many/
06:22:08 <int-e> obiwahn: you need one line per user
06:23:13 <obiwahn> the bot is hbot if you are tempted to help
06:23:26 <int-e> obiwahn: I can help a little, but as you can see my response times aren't very good
06:25:04 <obiwahn> that is no problem at all - even if this goes over days or weeks. last time i had it working i was a student and playing for several days:)
06:25:10 <readright> Cale " because you can't choose an 'a' which would work when 's' isn't in scope yet" - can you say that some other way?
06:25:11 <int-e> obiwahn: I usually struggle a bit with trusting the right Haskell packages. In any case if you could paste concrete errors somewhere that might help.
06:25:35 <dminuoso> tdammers: What do you think. Troll?
06:25:55 <readright> dminuoso - so you are calling my function?
06:27:27 <obiwahn> at the moment i am at work and can only post when waiting on builds. when i am at home i'll try to give some description about my environment and how i start the bot.
06:28:07 <dminuoso> Cale: Out of curiosity. How would you smuggle out the STRef? Via unsafePerformIO into some global IORef?
06:28:10 <readright> dminuoso I think th tricky bit is that there is no `a`
06:28:25 <obiwahn> [ERROR] Plugin.djinn: Djinn command failed: djinn: readCreateProcess: runInteractiveProcess: exec: does not exist (No such file or directory)
06:28:37 <obiwahn> that is the first error i see
06:28:41 <fabianbergmark> If someone who is experienced with writing parsers would like to contribute to my JavaScript interpreter pls PM me
06:28:44 <obiwahn> most are about packages that can not be found
06:28:52 <dminuoso> readright: Think of `forall a. Int` as a kind of function `Type -> Int` - except you cant write it like that.
06:29:46 <dminuoso> readright: Or more accurately: Think of something `f :: forall a. Int` as a kind of function `f :: Type -> Int` - except you cant write it like that.
06:29:50 <obiwahn> int-e: http://paste.debian.net/1034253/
06:29:56 <obiwahn> that is my setup
06:30:05 <dminuoso> readright: To get an `Int` you have to give it a type.
06:30:16 <tdammers> dminuoso: ?
06:30:19 <readright> I can understand that version
06:30:22 <dminuoso> tdammers: -offtopic
06:30:24 <obiwahn> the package path that is shown by `stack path` is what i set in my env
06:31:30 <readright> but how does f :: Type -> Int relate to f :: forall a. Int
06:31:42 <dminuoso> readright: The first is just some pseudo-haskell code.
06:31:58 <tdammers> dminuoso: probably not-troll, I'd say
06:32:00 <readright> but it takes a value
06:32:12 <dminuoso> readright: Im saying it takes a _type_
06:32:22 <dminuoso> readright: that is, you apply it to say `String`
06:32:25 <dminuoso> Or maybe `IO ()`
06:33:59 <readright> I think I can see that that would be tantamount to saying the caller will use whatever type he wants to
06:34:17 <readright> and that I cannot guess wht it might be
06:34:47 <dminuoso> readright: And even more to the point: He has the freedom to apply it to different things
06:35:05 <dminuoso> He could do shenanigans like: f @(IO ()) + f @Float
06:35:24 <readright> the @ stuff doesn't help at thi soint
06:35:47 <dminuoso> readright: that's just applying the above function to a type. that is, giving it a type
06:36:09 <readright> OK, so in the same call, a could have multiple types
06:36:32 <readright> or, f could act on multiple types of a
06:37:01 <dminuoso> `f :: forall a. Int` is just a function mapping from a type to an integer..
06:37:11 <Cale> dminuoso: If you use unsafePerformIO, you can actually smuggle out a polymorphic STRef, and break the type system
06:37:31 <Cale> dminuoso: but I just mean using something like an existential type
06:37:35 <readright> Cale - that is just what I need to hear! :D
06:51:46 <readright> Cale - anyway, your description is a nice summary of what I picked up from the book. I am just yet to see the idea about the 's' not being in scope yet.
06:52:17 <Cale> readright: So the user of runST is expected to pick the type 'a'
06:52:36 <Cale> runST :: forall a. (forall s. ST s a) -> a
06:53:42 <XtraKrispi> Hi, I have a hopefully easy question about existential types and functions that use them
06:54:23 <Cale> You can think of that forall a as being an argument to the function which happens to be a type. When we provide it, s hasn't been selected yet. Also, it's not our choice to make which type s is, but rather runST's responsibility.
06:54:43 <Cale> (we need to provide an action which would work no matter which type s was instantiated to)
06:54:55 <Cale> XtraKrispi: ask away
06:55:08 <XtraKrispi> I have a type: `type DB a = forall (m :: * -> *).(MonadIO m) => ReaderT SqlBackend m a` and I want to use this in a function like this: `blah :: Bool -> DB Text` but then I get an invalid polymorphic type error
06:55:43 <XtraKrispi> fairly new with this stuff
06:56:13 <Cale> What does the error say exactly?
06:56:36 <XtraKrispi> Illegal polymorphic type: DB Text       Perhaps you intended to use RankNTypes or Rank2Types
06:57:21 <XtraKrispi> I don't have to use the DB type, just wanted to see if it would work
06:57:35 <Cale> Did you try turning on the suggested extension?
06:57:41 <Cale> {-# LANGUAGE RankNTypes #-}
06:58:11 <Cale> You're not ordinarily allowed to explicitly quantify types with forall, without turning on one of the extensions that lets you do so.
06:58:28 <XtraKrispi> it works with the extension, i was just trying to understand why it's failing
06:58:34 <XtraKrispi> ah, I see
06:59:21 <XtraKrispi> okay, didn't know I needed to be explicit about that... knowing that, I'm good! Thanks!
07:00:04 <XtraKrispi> damn, I just checked the file where DB is defined, and the extension is specified there :s
07:00:29 <readright> Cale, dminuoso - seems that "Think of `forall a` as an argument to the function which happens to be a type" is useful to start forming some intuition. Thanks!
07:00:56 <mniip> readright, are you familiar with system F?
07:01:04 <mniip> I thought TaPL should have introduced it
07:02:59 <readright> mniip - not really. But I can see from the Wiki intro that it covers many of the key concepts people have been mentioning.
07:04:43 <mniip> oh I thought you were reading TaPL?
07:05:39 <readright> maybe I should
07:06:36 <dminuoso> readright: f :: Num a => a -> a; f x = ...{in here x is not polymorphic. we cannot simply decide to use `x @Float`}...
07:06:40 <dminuoso> Did this make sense as well?
07:07:41 <readright> yes, we only know it has a Num instance
07:09:54 <dminuoso> readright: What if we had this?   f :: a -> a; f x = ...{what about x from this perspective now?}..
07:10:35 <readright> we know nothing about a - impl must be id (or some bottom)
07:11:04 <dminuoso> readright: So you can't apply `x` to a type right? So from inside the body `x` is not polymorphic/universally quantified.
07:12:18 <readright> So you can't apply `x` to a type right? Is that the same as you can't assigna type to x?
07:13:07 <readright> or am I missing some nuance?
07:16:21 <Guest6227> Do you know of a language that would refuse to evaluate "!" < "a"?
07:16:57 <dminuoso> Brainfuck?
07:17:31 <Guest6227> lol
07:17:52 <Taneb> dminuoso: oh that evalutes it fine, it moves the instruction pointer one to the left
07:17:59 <mniip> the language I wrote over the past 3 days
07:18:05 <mniip> ...it doesn't have string literals
07:18:13 <dminuoso> Taneb: Mmm. Is it specified how brainfuck handles characters outside its alphabet?
07:18:20 <Taneb> dminuoso: yeah, it should ignore them
07:18:26 <dminuoso> Taneb: Oh.. nevermind then!
07:29:13 <cantordust> i had graph theory, group theory, ML, AI, NLP, social network analysis as my electives and took an additional course on linear algebra and game theory , so i wanted to know some basic mathematical projects i can develop using haskell
07:29:31 <cantordust> as I have learned it recently and wanted to get a hang on the language
07:30:41 <cantordust> so i wanted a couple of suggestions on what i can develop
07:37:38 <lin__> Can I specify in .ghci (in a stack projetc) that I want waringn in the ghci and for certain files, but not for other files? (Or even better, not for any changes that are not from the last 3 commits)
07:42:00 <cocreature> lin__: you could put the warning flags in the individual files with {-# OPTIONS_GHC -Wall #-}
07:44:18 <lin__> That would be a change I would like git to ignore then. (I assum that those options would overwrite the local .ghc and .ghci options?). The thing is
07:45:00 <lin__> I'm extending a library and don't want to cause Warnings, but the are a bunch of files that are not supposed to be touched, that cause a lot of Warnings
07:45:22 <cocreature> add {-# OPTIONS_GHC -Wno-all #-} or something like that to those files
07:45:23 <lin__> (I would like to just deal with mine without needing to grep them)
07:45:33 <cocreature> or add
07:45:59 <cocreature> {-# OPTIONS_GHC -Wall #-} to your files and remove it from the cabal file
07:46:51 <lin__> I guess I can somehow tell git to ignore thase very changes and go with that. Thanks cocreature for showing me those options :)
07:47:54 <cocreature> lin__: I wouldn’t try coming up with some fancy git integration for this. just don’t stage those files
07:49:12 <lin__> not that fancy. just a -Wno-all to all files that I'm not changing and have git ignore those changes
07:54:12 <dataN> hmm, lpaste is down... whats the alternative?
07:55:44 <c_wraith> nothing settled upon.  There are lots of options
07:58:23 <dataN> so, just trying to write collections of local constraints, but the order of deceleration seems to matter, i.e. 'using x $ using y $ ... ' is not the same as 'using y $ using x $ ... ' so it looks like applicative or monadic do notation is out of the question...
07:58:41 <dataN> really constraint instantiation should be commutative though...
07:58:52 <c_wraith> lots of monads are non-commutative
07:59:35 <dataN> yes, the problem is it would preserve this non-commutativity and really it shouldnt
07:59:36 * hackage keccak 0.1.3 - haskell keccak functions  http://hackage.haskell.org/package/keccak-0.1.3 (aupiff)
08:00:02 <pally> newtype State s a = StateOf (s -> (s, a))
08:00:33 <pally> are 's' and 'a' type variables?
08:00:45 <pally> or are they value variables?
08:00:51 <c_wraith> pally: type.
08:01:51 <c_wraith> pally: when declaring a data type, variables it uses are type variables.  newtype is one of the ways available to declare a data type
08:02:44 <c_wraith> pally: so State Int String is a wrapper around the function type   Int -> (Int, String)
08:03:42 <c_wraith> pally: with a constructor named StateOf which holds the function, so the compiler can distinguish State values from unwrapped functions at the value level
08:05:24 <c_wraith> dataN: You could probably find a representation that would be commutative behind the scenes
08:05:40 <dataN> perhaps there is something more like let or where, or maybe some way of combining the local scopes, like (p=>x) -> (q=>y) -> (p,q=>?)
08:06:15 <dataN> (\\) ?
08:06:55 <dataN> something like commutative do notation for categories!?
08:07:15 <pally> c_wraith thank you
08:07:46 <infinisil> pally: Just try to insert a value into the definition: `State 10 "foo" = StateOf (10 -> (10, "foo"))`
08:07:58 <infinisil> pally: Doesn't make a lot of sense
08:08:09 <infinisil> So type variables they are
08:12:50 <dataN> could ContT be used for this? to check over the rest of the chain of (>>=) to combine the bindings?
08:13:19 <c_wraith> ContT gives you basically nothing in terms of introspection ability
08:13:43 <dataN> oh?
08:13:49 <c_wraith> On the other hand, it does model nested resource acquisition pretty well.
08:14:07 <c_wraith> Though Codensity is an even better model for nested resource acquisition
08:15:32 <Boarders> isn't contT and codensity basically the same thing?
08:15:43 <c_wraith> they're very close, but definitely not the same
08:16:43 <c_wraith> They have the same structure, but Codensity uses a universally-quantified type where ContT uses a type variable that appears in the type constructor.  That makes a big difference in expressive ability
08:16:52 <Boarders> oh, I guess codensity is when you quantify over r
08:17:03 <dataN> 'forall b. (a -> m b) -> m b' vs. '((a -> r) -> r)'
08:17:27 <c_wraith> ContT is ((a -> m r) -> m r)
08:17:30 <dataN> thats Codensity vs Cont
08:18:01 <Boarders> is there a mathematical way to express that kind of relationship by saying Codensity is the limit of ContT?
08:18:01 <dataN> setting m = Identity
08:18:26 <mniip> Boarders, it's an end of Cont
08:20:00 <c_wraith> Quantifying over that variable makes a huge difference.  You can construct a ContT value that ignores its input function and just returns a value.  That's not possible with Codensity
08:21:27 <dataN> and this makes it a better model of resource acquisition?
08:22:25 <c_wraith> Yeah.  It means you can't ever throw away the portion of the code that's supposed to be doing the resource release afterwards
08:23:04 <Boarders> yeah well a ~ forall r. (a -> r) -> r
08:23:12 <Boarders> by yoneda
08:23:39 <c_wraith> that's true, but Codensity doesn't quite fit that pattern because of the extra m in there.
08:23:59 <Boarders> yeah I was just meaning what universal quantifying does
08:25:17 <Boarders> mniip: probably being stupid but how is it an end? As in that should be something involving a profunctor C x C^op -> D
08:25:39 <mniip> Boarders, parametric types are profunctors
08:26:02 <Boarders> oh I guess the r's are in covariant and contravariant position?
08:26:07 <mniip> yes
08:26:11 <c_wraith> Like, (Codensity $ \f -> putStrLn "I am here" >> f ()) :: Codensity IO ()
08:26:16 <dataN> its difficult to see how the Monad instance for Codensity f namely; 'm >>= k = Codensity (\c -> runCodensity m (\a -> runCodensity (k a) c))', can be used to access bindings later in a do block...
08:27:53 <dataN> or is this the wrong way of thinking about trying to achieve commutative do using Codensity?
08:28:42 <c_wraith> I didn't say it's commutative.  I said it models *nested* resource acquisition.
08:29:56 <dataN> :t (:-)
08:29:57 <lambdabot> error:
08:29:58 <lambdabot>     • Data constructor not in scope: :-
08:29:58 <lambdabot>     • Perhaps you meant one of these:
08:31:32 <dataN> trans :: (b :- c) -> (a :- b) -> a :- c
08:31:36 <drets> I have [-Wname-shadowing] due to record “unpacking” 2 times in https://paste.ofcode.org/ZNFJU4cF8bsBgLLLfr6pYw What would be the easiest fix?
08:32:01 <dataN> oh, so maybe profunctors are not commutative...
08:32:12 <c_wraith> like..   do foo <- Codensity $ withFile "foo.txt" ReadMode ; bar <- Codensity $ withFile "bar.txt" ReadMode ; ... more stuff ..
08:33:04 <c_wraith> It reverses the withX idiom of resource acquisition+release so that you can avoid tons of nesting
08:35:12 <drets> OK, it seems I should just avoid them
08:35:16 <drets> https://www.reddit.com/r/haskell/comments/1mbaw0/recordwildcards_are_evil/cc7n5la :)
08:35:24 <c_wraith> drets: Given that structure of data, I don't think you can do much to avoid shadowing while using that idiom
08:37:00 <c_wraith> drets: it's not evil, really - but it certainly will cause shadowing when used like that.  Maybe you can move the nested use to a definition outside the scope of the outer use?
08:38:56 <quicksilver> I think record wildcards are evil because they cause an impedance mismatch as to what the type of a term is.
08:39:36 <quicksilver> data Circle = Circle { radius :: Double };
08:39:51 <quicksilver> do we have radius :: Circle -> Double or radius :: Double
08:39:54 <drets> c_wraith, yeah, I tried to get rid from inner record wildcard but I have 3 levels of them :(
08:39:58 <c_wraith> I don't use them just because I'd rather have name bindings be explicit.  But I can understand why one wouldn't.
08:40:03 <quicksilver> I don't like reusing the same name at two different types.
08:40:26 <dataN> so maybe the correct thing to do is try and use the Constraints package to somehow combine all of the local contexts of sequenced 'using (x :: Def ...)' functions.
08:41:58 <dataN> which would use Dict to place the constraints in scope where they belong on the LHS of => in the leftmost position, and then GHC's constraint tuples could handle the commutativity...
08:42:54 <dataN> I wonder what that would look like...
08:47:11 <Boarders> you have the same kind of thing in mathematics though, does x refer to a function R^3 -> R, \a b c -> a or does it refer to a "name" of the first variable
08:47:37 * hackage ivory-opts 0.1.0.6 - Ivory compiler optimizations.  http://hackage.haskell.org/package/ivory-opts-0.1.0.6 (EricMertens)
08:53:46 <dataN> so here is an example with the relevant machinery for reference; https://hastebin.com/afagoroyed.coffeescript
08:55:18 <dataN> still prefer lpaste... wonder what happened to it...
08:57:29 <EvanR> bitrot
08:59:47 <quicksilver> Boarders: yeah. I'm ok with it in maths.
08:59:56 <quicksilver> Boarders: but in haskell I like my terms to have consistent denotation.
09:00:00 <quicksilver> maths is not a formal language :)
09:03:46 <pally> newtype State s a = StateOf {deState  :: s -> (s, a)}
09:03:54 <pally> been staring at this thing for 1/2 hour
09:04:13 <shapr> does that help?
09:04:37 <pally> what the braces denote?
09:04:59 <mniip> a record
09:05:09 <mniip> it's like saying
09:05:17 <mniip> newtype State s a = StateOf (s -> (s, a))
09:05:30 <mniip> deState :: State s a -> s -> (s, a); deState (StateOf x) = x
09:10:08 <pally> mniip, where did the x come from? and you are saying "newtype State s a = StateOf {deState  :: s -> (s, a)}" expresses all of what you mentioned right?
09:10:17 <mniip> yes
09:10:28 <mniip> x? that's a pattern match
09:11:01 <pally> can you point me to a webpage that explains newtype in a non-rigorous way?
09:12:06 <mniip> in most aspects newtype is not any different from data
09:12:28 <mniip> the only difference is that it's essentially free at runtime
09:13:54 <dataN> pally, some online documentation uses the state monad transformer which is more complex. deState is a function which returns the value from within the newtype (e.g. 'x' from inside the pattern (StateOf x))
09:14:24 <pally> :t deState
09:14:26 <lambdabot> error: Variable not in scope: deState
09:14:41 <dataN> deState :: State s a -> (s -> (s,a))
09:14:45 <nshepperd_> I prefer *only* reusing the same name at two different types. Because that way you get a type error if you get the shadowed values confused
09:14:59 <mniip> @let newtype State s a = StateOf {deState  :: s -> (s, a)}
09:15:00 <lambdabot>  Defined.
09:15:03 <mniip> :t deState
09:15:04 <lambdabot> L.State s a -> s -> (s, a)
09:18:35 <dataN> so, reading about the concept of "lightweight monadic regions", looks like the conventional approach is to collect the proxies (used in the various applications of reify) in a type level list, but this is not necessary with there reified constraints/local instance definitions, since the constraints can be combined inside of a continuation. correct?
09:31:31 <quicksilver> pally: well maybe you should look first at newtype Num = MkNum { unNum :: Int }
09:31:39 <quicksilver> just to understand what record notation means
09:31:49 <quicksilver> and then try to understand state itself
09:33:07 <dataN> state is easy, its the opposite of the function that is the first argument of foldl;
09:33:15 <dataN> :t fold.curry
09:33:17 <lambdabot> (Monoid c, Foldable ((->) a)) => ((a, b) -> c) -> b -> c
09:33:25 <dataN> :t foldl.curry
09:33:26 <lambdabot> Foldable t => ((b, a) -> b) -> b -> t a -> b
09:33:26 <dataN> sorry
09:34:09 <dataN> so it can be seen as the thing that creates lists, or more general foldable containers.
09:37:37 <pally> quicksilver, is there a good resource for learning newtype declarations?
09:38:24 <pally> quicksilver, I am having trouble understanding the notation.   Even the simple example you showed.
09:41:09 <Boarders> dataN: isn't it more like something that produces streams
09:41:18 <Boarders> :t unfoldr
09:41:19 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
09:41:31 <dataN> right
09:42:31 <quicksilver> pally: there are anumber of good haskell tutorials and books. I'm out of date recommend a good one.
09:42:57 <quicksilver> pally: how about if I remove the record notation part. Are you comfortable with newtype Num = MkNum Int ?
09:45:26 <redpoppies> hello everyone. anyone know how to run stack builds in docker container AND respect custom install paths on the host?
09:49:04 <pally> quicksilver, MkNum is the data constructor, which accepts one argument, an INt.
09:58:00 <fishythe_> pally: if you understand `data`, `newtype` is the same thing (just with certain optimizations available)
09:59:47 <quicksilver> pally: ok, so the record notation just adds a destructor (or field name) to get the inside part out
10:00:23 <quicksilver> so you could do: a = MkNum 1; b = unNum a; -- b is now (1 :: Int)
10:00:35 <quicksilver> unNum is the 'opposite' of MkNum
10:01:34 <mnoonan> this newtype conversation is making me feel pretty vindicated about this: https://pbs.twimg.com/media/DhoEvd1WsAAeSm_.jpg
10:02:33 <monochrom> newtype is one of the best places to use record syntax.
10:02:43 <mnoonan> >:(
10:03:43 <monochrom> Because the only other good place is with "data" but only one constructor, e.g., "data X = C{a::Int, b::Bool}"
10:04:07 <monochrom> Because by the time you have multiple constructors you run into partiality ugliness.
10:04:48 <monochrom> Bascially there are only two self-consistent stances.
10:05:17 <monochrom> Either you reject record syntax across the board, or you accept it over all single-constructor cases.
10:08:06 <mnoonan> imo it only makes sense in the case of types with a single constructor that is a product of more than one field.
10:08:42 <mnoonan> with single-field types, 1/2 of the purpose of using a record field is voided. the update capability is worthless.
10:08:42 <monochrom> On what ground?
10:09:19 <monochrom> But the inverse-of-constructor capability is priceless.
10:09:44 <mnoonan> sure.. so just write an independent function?
10:10:11 <monochrom> Or just use record syntax?
10:11:54 <mnoonan> Nah.
10:13:35 <quicksilver> it's very useful to have a concise syntax to define wrapper and unwrapper simultaneously
10:13:48 <quicksilver> the fact that the syntax we use for that happens to be record syntax is certainly a bit odd
10:13:53 <quicksilver> but you learn to live with it.
10:23:47 <dataN> still having trouble understanding how constraint continuations can be composed...
10:27:07 * hackage glabrous 0.4.0 - A template DSL library  http://hackage.haskell.org/package/glabrous-0.4.0 (MichelBoucey)
10:45:22 <dataN> hmm, cant seem to define f2 here; https://hastebin.com/nulaxupeku.coffeescript
11:01:58 <dataN> this is closer but its not working properly, why would this error occur? https://hastebin.com/azefubicik.coffeescript
11:03:36 <dataN> ghc should be able to resolve that?
11:04:58 <dataN> its something like ScopedTypeVariables not being able to infer the parameter 'f'...
11:06:06 <dmwit> dataN: You forgot to put `forall f.` in front of your type signature.
11:06:14 <dataN> yes! thanks
11:08:28 <dataN> hmm, now it complains about an "Illegal polymorphic type"
11:11:30 <dataN> dmwit: forall f a. or forall f x. dont work...
11:12:31 <dmwit> You know the rules. Show a minimal chunk of code that can be used to reproduce the error, together with the error itself.
11:12:39 <dmwit> SOP for asking technical questions on the Internet.
11:13:21 <dataN> eh?
11:13:48 <Cale> dataN: It's really hard to know what's on your screen ;)
11:15:03 <dmwit> I'd like to point out that it's not just SOP because that's the information that makes it smoothest for other people to help you.
11:15:48 <dmwit> It's also SOP because often the exercise of putting that information together lets you solve the problem yourself without outside help, because once you've made it minimal there's fewer things you could think of blaming for the problem.
11:16:59 <dataN> this version has the exact error and it would not be possible to reproduce the error using less code. https://hastebin.com/mukazoyawu.coffeescript
11:17:15 <cocreature> it took me way too long to figure out that SOP doesn’t stand for sum of products
11:17:24 <Cale> Note that even if you don't make it minimal, providing the source code and the text of the error is pretty much necessary for someone to be able to figure things out.
11:17:59 <dataN> right, but its there
11:19:00 <Cale> where?
11:19:03 <dmwit> This deosn't say "Illegal polymorphic type" anywhere.
11:19:37 <dmwit> (Also I doubt it's minimal.)
11:19:37 <dataN> also, the main exercise is to check the type of composing f1 f2 and general functions of this construction.
11:20:57 <dataN> dmwit: placing forall f. everywhere possible in the definition of f2 and its type signature did not compile.
11:21:33 <dataN> Cale: can you see the paste?
11:21:57 <dmwit> Yes, it shouldn't go everywhere possible, it should only go at the beginning of the type signature.
11:22:31 <dmwit> (Probably should be `forall f x.`, in fact. But the error should be clear about that if you forget the `x`.)
11:22:33 <haasn> who needs record syntax for newtypes when `coerce` does the job
11:22:35 * haasn runs
11:22:38 <dataN> taht would require forall x. aswell, and this does not compile either
11:23:10 <dmwit> Show us the code you believe should work but doesn't, not the code that you don't believe should work and already understand why.
11:23:35 <mnoonan> ++haasn
11:23:55 <dataN> how can that work if the suggested fix does not work!
11:24:49 <dmwit> dataN: You already know why the code you pasted doesn't work. There's another piece of code, which you have not shown us, that doesn't work and you don't know why. We can explain why. But not if we can't see the code.
11:25:04 <c50a326> do you guys all write your own thread management logic, or do you use some package?
11:25:28 <dataN> it does not compile, i dont know why
11:25:57 <dmwit> dataN: It doesn't compile because the type `f` is not in scope in `defaultKliesli :: a -> f a`, and so it picks a different `f` than the one in the signature for `f3`.
11:26:13 <dataN> ok
11:26:48 <geekosaur> c50a326, async and various packages based on it that provide additional strategies and such
11:27:01 <dmwit> > (length "coerce @(StateT MyState AppMonad Ret) @(MyState -> AppMonad (MyState, Ret))", length "runStateT")
11:27:03 <lambdabot>  (75,9)
11:28:22 <dataN> but it still does not compile
11:28:57 <mnoonan> > (length "coerce", length "runStateT")
11:28:59 <lambdabot>  (6,9)
11:29:00 <c50a326> cool, thanks, the stuff it says about exception handling sounds nice
11:29:03 <dataN> where does the forall f. go?
11:29:28 <dmwit> `f3 :: forall f x. (Empty f, Cons f) => ...`
11:30:11 <dmwit> mnoonan: Yes, but `coerce` on its own will just be an ambiguous type error. My experience is that to use `coerce` you almost always need at least some annotation to clear up ambiguities.
11:32:14 <Rustine> Hello everyone :) I'm quite new to Haskell, did lots of tutorial to do "basic" things, now i'm starting doing some challenges on codingame.com. I'm stuck at an easy challenge. It was indeed easy in other languages, but I'm stuck in Haskell. Here is the provided code: https://repl.it/repls/HelplessSupportiveProjects  - My question is, how do I access the list of inputs that were given to the program, so I can calculate the maximum  ?
11:32:22 <dataN> dmwit: that does not work, it gives this error; https://hastebin.com/qakeciheta.coffeescript
11:33:00 <mnoonan> dmwit: maybe true. anyway, I'm really just arguing for this: "newtype StateT s m a = StateT (s -> m (a, s)); runStateT :: StateT s m a -> s -> m (a, s); runStateT = coerce"
11:33:26 <dmwit> dataN: Okay. Then I encourage you to try to minimize your example. I bet you can get it down to just five lines of code with no imports.
11:33:38 <Rustine> I tried to understand how replicateM works, though I still don't have the level to understand it... :)
11:34:07 <dataN> thats completely impossible, it relies on using
11:34:14 <dataN> "using"*
11:35:23 <dataN> its a very involved error!
11:36:50 <c50a326> are Go's channels similar to STM?
11:38:11 <mnoonan> c50a326: I don't know Go, but have you seen this "port" of "Go by Example" to Haskell? https://lotz84.github.io/haskellbyexample/
11:38:24 <c50a326> oh, no, ty!
11:38:40 <c50a326> aha! https://lotz84.github.io/haskellbyexample/ex/channels STM :D
11:39:05 <c50a326> yeah every chans example uses STM
11:39:35 <c50a326> and goroutines are just forkIO
11:41:54 <dataN> the problem seems to be something to do with trying to write a Def2 for use with using2 which demands that some constraints are visible, but it cannot resolve the variable this constraint is defined over.
11:43:28 <dataN> setting 'f' to [] allows it to find the constraints defined over [], but without this, no amount of forall f can direct GHC to find the constraints provided.
11:43:56 <dataN> this possibly motivates using proxy!?
11:47:18 <c50a326> https://ptpb.pw/A7WF/hs at the moment this produces "zzzzzzzzzzzipped!zzzzzzzzzzzz", I was hoping to produce "zzzzzzzzzzzzzzzzzzipped!" and now I'm thinking about using an MVar to achieve this. I guess I have to make the forked thread poll an MVar somehow and then finish when the MVar is either full or empty?
11:47:37 <c50a326> (not trying to do this in the "best" way possible, just a simple/naive way is fine)
11:47:37 * hackage ztar 0.2.0 - Creating and extracting arbitrary archives  http://hackage.haskell.org/package/ztar-0.2.0 (brandonchinn178)
11:49:17 <c50a326> ah maybe I want tryReadMVar
11:50:29 <c50a326> or I guess I could use finally/bracket maybe
11:51:58 <UnkDevE> Hey Is there any way to make this function faster https://github.com/UnkDevE/Sudoku/blob/master/sudoku.hs#L139
11:52:05 <c50a326> in the in between bit I can start compressing and get the ThreadId of the forked `repeat 'z'` and then in the release resource computation I can kill the ThreadId and so on.. I'll try that...
11:53:23 <dataN> its not going to be easy to discuss composing constraint continuations without access to this example.
11:55:07 <mniip> constraint continuations?
11:55:09 <dataN> the code compiles if the definitions are placed on one line, but trying to place them in a where block starts it complaining about not being able to find the correct 'f'
11:55:19 <mniip> I'm imagining CPS with implication constrains...
11:55:26 <dataN> (p=>x)->x
11:55:57 <mniip> ah
11:56:09 <mniip> dictionaries
11:58:17 <dataN> here, this version works with the restriction of 'f' to []; https://hastebin.com/hugajubapo.coffeescript
11:58:42 <dmwit> "It's a very involved error!" Rise to the challenge. I give 99-1 odds you can reduce the line count by a half. 95-5 that you can cut it to a quarter of the code. Say, 60-40 you can get it to five (semicolon-free) lines or fewer.
11:59:37 <dataN> be assured, this is the least code possible for the discussion.
11:59:51 <dmwit> I am not assured. But I also don't care to spend the time to prove you wrong.
12:00:02 <dataN> why would you!?
12:00:16 <c50a326> oh what... my code here kind of works when ran as a binary, but not in ghci... https://ptpb.pw/Z1g6/hs why does ghci keep the main thread running?
12:00:43 <c50a326> oops it's missing the last line
12:01:01 <c50a326> https://ptpb.pw/bVDe/hs I mean
12:01:17 <dmwit> ghci doesn't kill any threads. Compiled binaries kill all threads when `main` finishes.
12:04:21 <dmwit> (Actually I suspect compiled binaries don't kill any threads in the sense that they don't receive any exceptions or anything like that. The process just exits, and the OS reaps the remaining resources. But I'm not super familiar with all the details.)
12:04:43 <dataN> so! referring to working and succinct example given, line 46 defines a global instance of Cons used on line 55 with the local instance given for Empty, to provide a local instance of Kliesli, which is then used on line 49 which composes these constraint continuations.
12:04:53 <mniip> isn't it spelled kleisli
12:05:05 <dataN> oops, thanks
12:06:33 <geekosaur> c50a326, ghci is all one session, any threads you fork are owned by ghci itself, so as long as ghci is running that thread will be running. if you want more control, you need to have your main thread kill the child before exiting
12:06:37 * hackage self-extract 0.3.3 - A Haskell library to make self-extracting executables  http://hackage.haskell.org/package/self-extract-0.3.3 (brandonchinn178)
12:06:40 <mniip> dataN, could you upload all this to a github gist instead of multiple pastes
12:06:52 <dataN> yes ok
12:07:08 <geekosaur> it is not like running something in ghci creates a whole new applicaiton contect; and can't be, because then you couldn't use the result of previous evaluations
12:07:25 <geekosaur> (because they'd belong to an execution context that no longer exists)
12:08:23 <dmj`> anyone else notice base-4.11.10 is broken?
12:08:27 <dmj`> https://gist.github.com/dmjio/cb84946f81bb21157ca1f9353e9aaadb
12:08:35 <geekosaur> nor can it create a new thread for everything you evaluate, because then anything using FFI with thread-local storage wouldn't work in ghci
12:11:01 <djusto> Hey all, is this the right place to ask for coding help?
12:12:32 <c50a326> yeah there's also #haskell-beginners
12:12:32 <shapr> djusto: are you writing Haskell code?
12:12:51 <shapr> if writing Haskell code, this is the right place, and yes, also #haskell-beginners
12:13:22 <mniip> dmj`, looks like your distribution is broken
12:13:30 <mniip> include/ieee-flpt.h is there in the package
12:13:53 <shapr> djusto: what got you excited about Haskell?
12:13:55 <djusto> @shapr yes, but I'm mostly trying to use Hoogle in a specific way. I was told that Hoogle was a way of listing all public-facing functions of an API/hackage. I was hoping to call on that programatically
12:13:56 * lambdabot pulls yes, but I'm mostly trying to use Hoogle in a specific way. I was told that Hoogle was a way of listing all public-facing functions of an API/hackage. I was hoping to call on that programati
12:13:56 <lambdabot> cally through the Evil Mangler
12:15:12 <c50a326> presumably http://hackage.haskell.org/package/hoogle
12:15:44 <shapr> yeah, looks like it should work: http://hackage.haskell.org/package/hoogle-5.0.17.3/docs/Hoogle.html
12:15:49 <djusto> and I got into Haskell because I'm trying to get into PL research! I find it fascinating. Refinement types, synthesis and all that jazz is very exciting
12:15:57 <shapr> yeah! I agree!
12:16:03 * shapr does jazz hands
12:16:20 <lavalike> what does the search box here use? https://www.stackage.org I find it more reliable than hoogle most of the time
12:16:52 <djusto> I'll come back later, first time using IRC and the interface has me a tad confused. See you all later
12:16:59 <lavalike> see ya
12:17:08 <geekosaur> keep in mind there's multiple versions of hoogle
12:17:28 <geekosaur> haskell.org/hoogle is an older one with an older database, but it also has working type search
12:17:51 <dmj`> mniip: weird yea, it was marked as broken in hackage-packages.nix
12:17:51 <geekosaur> hoogle.haskell.org is a newer verison of hoogle and a newer database, but type search is still a bit broken in the newer version
12:17:54 <dmj`> mniip: https://gist.github.com/dmjio/27b6948f14a9177fa2bcbee78294ef26
12:18:38 <dmj`> mniip: it might not have been included in the cabal file, then it wouldn’t have been packaged when cabal sdist was called
12:18:42 <geekosaur> also there is hayoo, which works differently and is probably not something you want for this purpose
12:18:59 <dataN> ok, here; https://gist.github.com/dataN-hs/5517bc5b1062893c8ea0e4a48e0334c0
12:19:01 <geekosaur> (its a full web search engine with plugins, one of which happens to be a haskell search plugin)
12:19:31 <dmj`> mniip: nah, it’s in the cabal file… hrmm
12:19:39 <mniip> why are you building base anyway
12:19:57 <dmj`> mniip: stackage nightly is using latest base
12:19:58 <Berra> There doesn't appear to be lens packages for http-types and http-conduit etc. I'm fine with generating them myself using TH in my own project as I need them. But is there some good reason why there doesn't exist a package that does just that?
12:20:20 <dmj`> mniip: nixpkgs-unstable is on a base one major version prior
12:20:33 <mniip> I'm not familiar with compiling base outside of doing a full compiler build with wired-in packages
12:20:49 <dataN> again, the idea is that f1 and f2 should commute, as constraints can be gathered independently of the order they are provided...
12:20:59 <dmj`> mniip: I agree, base among others are boot packages that should be distributed with your compilers install
12:21:26 <dmj`> mniip: `nix-shell -p haskellPackages.ghc --command 'ghc-pkg list base'`
12:21:33 <dmj`> `base-4.10.1.0`
12:22:05 <geekosaur> Berra, nobody felt like it? it's not like lens interfaces grow on trees
12:22:24 <geekosaur> or that there are maintainers sitting there anticipating that somone might want that at some point so go make it
12:23:03 <dataN> Berra, they use a "cursor" which can be used with the biplate part of lens... maybe...
12:23:37 * hackage ip 1.4.0 - Library for IP and MAC addresses  http://hackage.haskell.org/package/ip-1.4.0 (andrewthad)
12:23:45 <Berra> dataN I didn't comprehend what you said just now
12:24:40 <dataN> oh sorry thats xml...
12:25:59 <dataN> http://hackage.haskell.org/package/xml-lens, got confused by its use of conduit
12:28:27 <Berra> dataN, geekosaur I do get that there is good reason that is someone where to create a lens library for those libraries it should probably be done without depending on lens. But right now they don't exists... so just TH generating them so that they do exist might be worth it?
12:29:15 <mniip> ooh
12:29:33 <cocreature> dmj`: afaik you can’t upgrade base without upgrading ghc
12:30:04 <geekosaur> if evertything that you need can be done via TH, there's little reason to have a library for it. libraries usually include thingss that TH can't do for you, either convenience lenses or faster/more usable versions of things taking advantage of what people, as opposed to the compiler, know about how the lenses will be used
12:30:06 <cocreature> also nix should actually be at lts 12.something now which comes with base 4.11.*
12:31:15 <c50a326> damn I'm feeling a bit overwhelmed with RWH's thread manager code... and then at the end it says that the code is a little unsatisfactory and that STM is safer and easier to use... I think I'd feel cheap just skipping over all this MVar stuff though :S
12:31:16 <Berra> geekosaur: Sure that is a very sane argument. But it also means that people generate them in their own project again and again. Maybe that's ok.
12:31:35 <geekosaur> as far as the programmer is concerned, it's one line: makeLenses [...]
12:32:36 <geekosaur> and they can make only the ones they care about instead of pulling in a bunch of things they might not (including, potentially, dependencies on other libs theyre not using)
12:33:09 <Berra> geekosaur: Yeah but I still split it up correctly under Network.HTTP.Simple/Types/Client/Conduit and import so it's a lest _some_ boilerplate
12:33:13 <geekosaur> and that last part is pretty common with lenses (including with the lens package itself)
12:33:31 <dataN> so, the Constraints package manages to achieve quite a lot just using Sub Dict, which seems to resolve to many useful types, many of which resemble to combination of constraints independent of order, but trying to write a composition for constraint continuations (currently just using $) without really understanding continuation composition, or the many types functions defined using of Sub Dict, is proving difficult
12:33:42 <Berra> geekosaur: Makes sense
12:36:13 <butterthebuddha> Is continuation-passing style used in modern haskell?
12:36:22 <dataN> essentially, the commutativity seems to motivate some kind of 'do' notation which is not dependent on the order of the lines... but just for bringing constraints into scope.
12:37:09 <dataN> butterthebuddha: its sometimes better to avoid it, but here it is essential to give a "local scope for local instances"
12:37:56 <butterthebuddha> dataN: can you give an example?
12:38:02 <butterthebuddha> I'm not sure what that means
12:40:35 <dataN> reify :: a -> (forall s. Reifies s a => Proxy s -> r) -> r
12:41:00 <haasn> withSomething :: (Something -> IO r) -> r  is seen a lot
12:41:05 <haasn> I think that qualifies as CPS?
12:41:16 <haasn> err that should be -> IO r at the end
12:41:33 <cocreature> cps is also sometimes used in the internals of a library since in some cases it cane improve performance
12:41:53 <dataN> yeah sure, so the idea is to extend the style from '((a->b)->b)' to '((a=>b)->b)'
12:42:00 <haasn> (also, a neat trick is to use the ContT r IO monad to wrap stuff with multiple `withSomething` blocks rather than doing the ugly withFoo $ \foo -> withBar $ \bar -> ... nesting
12:42:28 <haasn> yeah CPS can help deforest
12:42:44 <haasn> instead of returning a constructor to a function which will then pattern match on it, you can directly jump into the right continuation
12:43:03 <haasn> edwardk's `machines` is an example of a library that does this for performance reasons
12:44:06 <dataN> yeah, the performance improvements from Kan extensions via the function improve; http://hackage.haskell.org/package/kan-extensions-5.2/docs/Control-Monad-Codensity.html#v:improve
12:44:30 <zipp> ohai #haskell. question: i just tried `cabal install opaleye` and got an ambiguous occurrence error; there's an import which is hiding for the module in question. What do?
12:45:21 <zipp> (running 8.4.3 on OSX)
12:46:36 <haasn> In addition to kan extensions, you can also use scott encoding to turn any ADT into a CPS representation which avoids the need for the data type itself altogether
12:46:45 <dataN> butterthebuddha: the example stems from; https://www.schoolofhaskell.com/user/thoughtpolice/using-reflection
12:55:00 <dataN> eg on line 46 is like; (f1 :: ((e=>x)->x)) $ (f2::(e=>(k=>x)->x)) $ (y :: k => x)
12:56:12 <dataN> here it can be seen how f1 provides the constraint 'e' needed by f2, which then is able to provide the required constraint 'k' to y.
12:56:48 <nomeata> hvr: If I have multiple projects that all import the same dependency via "source-repository-package" in project.cabal, should they be shared?
12:57:51 <wchresta> I want to have type safe vector operations but don't want to choose a specific type; i.e. something like a class SVector (s :: Nat) (e :: *) where I can then instantiate them with different types. I have trouble finding the right way to do this; any hints?
12:58:12 <mniip> dataN, any reason you're using actual rankNtypes over 'constraints' machinery
12:58:18 <mniip> such as Dict and :-
12:58:40 <dataN> this is it
12:58:57 <Boarders> is the foldl package an example of a scott encoding?
12:59:22 <dataN> they might be able to give the way of gathering up all of the provided constraints to make them available to everything which demands some constraints to provide some others
12:59:23 <mniip> are you trying to reflect a dictionary?
12:59:31 <dataN> possibly?
12:59:37 <mniip> just reflect a Dict
12:59:50 <dataN> but it needs the definition?
13:01:02 <c50a326> https://ghc.haskell.org/trac/ghc/ticket/13891 does this mean forkIO and bracket should never be used together?
13:01:22 <dataN> yes, thats the reason, it is the type of using2, which hides some safe-unsafe stuff
13:02:03 <dataN> it seems that after this is done, it gets stuck using continuations
13:02:45 <dataN> but there may be a way to use the Sub Dict method of sending all the constraints to the far left
13:02:59 <cocreature> c50a326: the issue already describes the solution: use the async library instead of the relatively low-level forkIO primitive
13:03:01 <dataN> this is the hope...
13:03:51 <c50a326> cocreature: yeah I see that. I'm wondering if I should just forget about playing with forkIO and MVar then, and just use async and maybe STM
13:04:53 <cocreature> c50a326: MVar + forkIO is pretty much what async does for you
13:05:13 <cocreature> + it gets all the tricky stuff correct that you’ve probably forgotten about :)
13:08:24 <dataN> cant really see how reflecting a dictionary instead of reflecting a definition would work
13:10:01 <c50a326> ah cool, `poll` is provided
13:20:07 * hackage web-inv-route 0.1.2.1 - Composable, reversible, efficient web routing using invertible invariants and bijections  http://hackage.haskell.org/package/web-inv-route-0.1.2.1 (DylanSimon)
13:32:06 * hackage reflex-dom-fragment-shader-canvas 0.1 - A reflex-dom widget to draw on a canvas with a fragment shader program  http://hackage.haskell.org/package/reflex-dom-fragment-shader-canvas-0.1 (JoachimBreitner)
13:38:46 <zincy_> Is there a function a -> [a]  which simply wraps a single item in a list?
13:38:50 <zincy_> :t singleton
13:38:52 <lambdabot> error:
13:38:52 <lambdabot>     • Variable not in scope: singleton
13:38:52 <lambdabot>     • Perhaps you meant one of these:
13:39:55 <Hafydd> zincy_: pure or return.
13:40:04 <zincy_> Im not in the list mona
13:40:05 <zincy_> d
13:40:30 <Hafydd> zincy_: if you're working with lists, you are "in the list monad".
13:41:03 <Hafydd> zincy_: regardless of whether you're using the monadic or applicative properties, pure or return will do what you want.
13:41:14 <zincy_> ah ok thanks!
13:41:17 <Hafydd> zincy_: you can also use the section (:[]).
13:41:24 <Hafydd> > (:[]) 1
13:41:26 <lambdabot>  [1]
13:41:36 <zincy_> Im surprised I dont need to be inside the list monad
13:41:50 <mniip> what do you think it means to be "inside" a monad
13:41:55 <Hafydd> zincy_: as I said, you technically *are* if you are using list values.
13:41:57 <zincy_> I guess ghc infers what I thought would have to be explicit
13:42:29 <Hafydd> zincy_: any list of values can be considered to be a monadic action.
13:42:43 <zincy_> mniip: Inside a do block would be synonymous with inside a monad
13:42:54 <mniip> no
13:43:05 <mniip> a do-block is nothing but syntactic sugar over >>= and >>
13:43:26 <mniip> > [1, 2] >>= (\x -> [3, x])
13:43:28 <lambdabot>  [3,1,3,2]
13:44:17 <mniip> it's not the 'do' that is magical
13:44:24 <mniip> it's the >>= and return
13:44:38 <mniip> and their "magic" is nothing more than that they are methods of a typeclass
13:44:51 <mniip> % :i >>=
13:44:52 <yahb> mniip: class Applicative m => Monad (m :: Type -> Type) where; (>>=) :: m a -> (a -> m b) -> m b; ...; -- Defined in `GHC.Base'; infixl 1 >>=
13:50:27 <EvanR> the idea that you are inside a monad is funny
13:50:51 <EvanR> if you take it seriously and use this analogy to other situations where you have to make types check
13:51:24 <EvanR> if you have a sum of numbers, you cant change one of the numbers to a string because you are inside of numbers
13:51:52 <EvanR> changing one to a string would be escaping numbers
13:51:59 <EvanR> illegal
13:52:03 <mniip> hi, can't talk, I'm inside of numbers
13:52:16 <zincy_> hahaha
13:52:34 <zincy_> A literal and figurative mind prison
13:52:46 <mniip> you can very well be inside a do-block however
13:53:00 <mniip> it shares a monadic type throughout all the statements
13:53:01 <EvanR> i can buy that
13:53:14 <zincy_> I think this is terminological confusion on my part
13:54:12 <zincy_> The do block is just a nesting of functions that return a certain type
13:55:15 <zincy_> Im confused ... the compiler will only allow you to use one monad inside a do block right
13:56:06 <zincy_> So you can be stuck inside a do block right?
13:56:21 <Rembane> Until you return or liftIO or something.
13:56:48 <zincy_> As in I cant do IO inside a Maybe do block
13:57:17 <EvanR> every statement must be an action in the same monad
13:57:27 <EvanR> i dont know how to make that more precise
13:57:37 <mniip> zincy_, no?
13:57:44 <mniip> ah
13:57:46 <mniip> er, yes
13:58:05 <EvanR> you can start a new do block within this one, and it be a different monad
13:58:21 <zincy_> Once you return though you can go into another monad though right
13:58:22 <EvanR> but it wont type check unless you convert it, like with liftIO
13:58:24 <zincy_> yes
13:58:53 <EvanR> if by return you mean use the return function... no thats unrelated
13:59:06 <zincy_> so lift is basically like pure but for ma instead of a
13:59:21 <Rembane> :t liftIO
13:59:23 <lambdabot> MonadIO m => IO a -> m a
13:59:26 <Rembane> :t pure
13:59:28 <lambdabot> Applicative f => a -> f a
13:59:33 <EvanR> lift does conversion between monads that support MonadTrans
13:59:43 <zincy_> :t lift
13:59:44 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
13:59:52 <EvanR> liftIO does conversion for MonadIOs
14:00:56 <mniip> note that all of these concepts are completely orthogonal to using monads inside IO
14:01:01 <mniip> errrrr
14:01:04 <mniip> note that all of these concepts are completely orthogonal to using monads inside do blocks
14:01:06 <typetetris> Is there a monad class for []-Monad?
14:01:46 <mniip> typetetris, you mean mtl-style class for ListT?
14:08:17 <olivia> hey everyone so I am having some trouble trying to get haskell set up on my laptop running linux but I get a unable to locate package cabal-install-1.22
14:08:32 <olivia> running linux mint 18
14:09:28 <mniip> olivia, what command are you running
14:09:35 <geekosaur> don't use 1.22, it's ancient. I would recommend https://launchpad.net/~hvr/+archive/ubuntu/ghc
14:10:09 <butterthebuddha> How does continuation-passing style help model exceptions?
14:10:22 <geekosaur> which is ghc + support packages including Cabal library and cabal-install
14:12:57 <haasn> butterthebuddha: in the same sense that `Either` models exceptions; you can use CPS instead of Either by having your functions be of the form :: forall r. (e -> r) -> (a -> r) -> r  rather than :: Either e a
14:13:12 <butterthebuddha> haasn: can you give me an example?
14:13:29 <olivia> thanks for the help geekosaur it works now
14:13:30 <haasn> you can `catch` something by just passing the thing you're calling a different exception handler
14:13:40 <haasn> (or re-throw by calling the exception handler you got from the parent scope)
14:13:54 <olivia> just had to update the cabal-install version
14:14:24 <haasn> butterthebuddha: divCPS :: Int -> Int -> (String -> r) -> (Int -> r) -> r;  divCPS x y e k = case y of 0 -> e "Divide by zero"; _ -> k (x `div` y)
14:15:03 <haasn> runCPS :: ((String -> r) -> (r -> r) -> r) -> r; runCPS f = f error id
14:16:56 <EvanR> "all you need is lambda"
14:17:14 <butterthebuddha> haasn: I see; instead of passing just one handler, you pass in several
14:17:36 <haasn> Contrast the more usual approach:
14:17:58 <haasn> divEither :: Int -> Int -> Either String Int; divEither x y = case y of 0 -> Left "Divide by zero"; _ -> Right (x `div` y)
14:18:29 <haasn> runEither :: Either String r -> r; runEither f = case f of Left e -> error e; Right r -> r
14:18:41 <haasn> CPS lets you avoid the constructor/data type
14:18:48 <haasn> (usually at the cost of code clarity, imo)
14:18:52 <mniip> haasn, that reminds me of something I was working on just today,
14:19:05 <butterthebuddha> But essentially, CPS-code is equivalent to monadic code?
14:19:29 <haasn> In essence, yes
14:19:35 <mniip> there's no particular reason to disallow data-decls in where/let bindings, but there's also no particular benefit,
14:19:43 <haasn> You can use CPS to do the equivalent of what we use `do` notation for in haskell
14:19:49 <EvanR> cps, church encoding, can emulate any algebraic data type
14:20:00 <mniip> there's nothing in the local scope you can use in the data decl,
14:20:01 <haasn> In some sense, Cont is the “mother of all monads”
14:20:14 <mniip> but I'm thinking maybe you can use local identifiers as constructors?
14:20:23 <haasn> since you can use continuations to abstract out all of the bind operations and then feed them with the implementation later
14:22:36 <haasn> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads
14:23:56 <haasn> https://plus.google.com/+DanPiponi/posts/3Ki2ebghxYd edwardk in the comments explaining how CPS can improve performance of monadic code
14:25:54 <butterthebuddha> Thanks for the links, I'll check them out
14:26:34 <haasn> but really what made Cont click for me in my head is thinking about it in terms of “withFoo”-style functions; each time you write { x <- cont f; ... }; the function `f` gets to decide what to do with the entire rest of the block; sort of like how { x <- cont withSomething; ... } is just like withSomething $ \x -> ...; and withSomething can do whatever it wants with that function
14:26:37 <haasn> including calling it multiple times
14:26:39 <haasn> or with different values of `x`
14:32:29 <mniip> hmm
14:32:44 <mniip> yeah it's probably useless
14:33:22 <haasn> mniip: Oh I missed your message; I'm not entirely sure what you mean by data decls in where/let bindings
14:33:30 <dmrd> quick question: I'm new to stack (and haskell) and have noticed that, after installing a new hackage with `stack install`, I get a warning about the `.cabal` file being modified manually and that some dependency meta-data file is out of sync. Is `stack install` not the right way to go about installing this...or should I also follow that with manually updating the `.yaml` file?
14:33:35 <haasn> you mean like let data Foo = Bat | Baz in ... do something with Foo ... ?
14:34:13 <mniip> haasn, in part
14:34:16 <glguy> dmrd: Some of the stack templates create a package.yaml file that you can delete after the .cabal file is generated
14:34:42 <mniip> having  let data Foo = ... in ...  would definitely be cool, and there's very little preventing GHC from supporting that,
14:34:52 <mniip> but there's not much features this provies
14:34:55 <mniip> provides
14:35:10 <dysfun> haasn: that link introduced me to string diagarams
14:35:10 <haasn> There's also not much reason to not define it at the top level of the module
14:35:18 <mniip> exactly
14:35:29 <mniip> because you can't really capture any locally scoped idenitifer with a data declaration
14:35:40 <haasn> right
14:35:56 <haasn> I mean at best you could maybe do some really weird shenanigans involving scoped type variables and GADTs
14:35:58 <dmrd> glguy, is that good practice though? I figured I would want to keep the .yaml file anyways. I'm just confused as to why stack doesn't keep dependencies up to date in the `yaml` even when you use its proper installation tool
14:36:06 <haasn> but those can also be done by parametrizing a top level GADT
14:36:06 <mniip> so I've thought, what if we capture constructors
14:36:08 <haasn> and feeding it with the type variable
14:36:34 <mniip> and then I figured there's no good way to make it work
14:36:43 <glguy> dmrd: For the package.yaml it's good practice to get rid of them, they make it harder for the rest of the users who aren't using stack, while the .cabal files work everywhere
14:36:55 <haasn> Not sure what "capture constructors" is supposed to mean
14:36:56 <glguy> and that makes it easier to get help when you have questions later
14:37:07 <mniip> \foo -> let data D = foo Int in ...
14:37:20 <dmrd> glguy: ooh, very interesting. Thanks for the insight :)
14:37:37 <haasn> mniip: How would you pattern match on `foo` if `foo` can be any function?
14:38:37 <mniip> well on one hand you could make 'foo x' not really be the result of applying foo to x
14:38:52 <mniip> it could mean \actual_foo -> actual_foo x
14:39:16 <haasn> Yeah, or it could be treated symbolically unless it escapes the scope, or something
14:39:18 <mniip> and then the actual_foo would be substituted whenever the value "leaves" the block
14:39:42 <mniip> yeah
14:39:52 <mniip> but then, the idea was
14:40:07 <haasn> Might make for some interesting possibilities but none I can think of off the top of my head
14:40:25 <mniip> can something like this be used to automatically write analysers like 'maybe' and 'either'
14:41:03 <haasn> I mean you can already automatically write those
14:42:08 <mniip> yes but like
14:42:12 <mniip> more automatically
14:42:35 <haasn> incidentally, that seems like a fun exercise; i'll give it a try
14:42:50 <mniip> like consider the two versions of 'div' you wrote above
14:42:55 <mniip> the idea is to make them look identical
14:43:08 <mniip> sans using locally bound data in one
14:43:26 <mniip> just throwing it out there: maybe a codata declaration?
14:43:38 <mniip> \l r -> let codata Either a b = l a | r b in ...
14:43:49 <mniip> to match an existing datatype against our custom constructors
14:45:05 <mniip> this makes very little sense formally but spiritually there's something
14:45:28 <haasn> do I sense that the gist of it is that you want to write code that looks like `case ... of` but is actually doing CPS under the hood?
14:45:35 <mniip> yes
14:45:38 <haasn> Yeah that makes sense
14:45:45 <haasn> although to be fair it would be easier to teach GHC to implement data types as cps :p
14:45:49 <haasn> which some compilers do, and GHC doesn't for reasons
14:46:07 <haasn> okay maybe not easier implementation-wise, but perhaps easier formally
14:47:04 <mniip> !
14:54:21 <mniip> % pattern L :: a -> forall r. (a -> r) -> (b -> r) -> r; pattern L x <- ((\f -> f Just (const Nothing)) -> Just x) where L x = \l r -> l x
14:54:21 <yahb> mniip:
14:54:40 <mniip> % pattern R :: b -> forall r. (a -> r) -> (b -> r) -> r; pattern R x <- ((\f -> f (const Nothing) Just) -> Just x) where R x = \l r -> r x
14:54:41 <yahb> mniip:
14:55:28 <mniip> % :t L
14:55:28 <yahb> mniip: a -> (a -> r) -> (b -> r) -> r
14:55:51 <mniip> % case L "hello" of L x -> "left " ++ x; R x -> "right " ++ x
14:55:51 <yahb> mniip: ; <interactive>:5:19: error:; * Couldn't match expected type `([Char] -> r0) -> (b1 -> r0) -> r0' with actual type `forall r. ([Char] -> r) -> (b0 -> r) -> r'; * In the pattern: L x; In a case alternative: L x -> "left " ++ x; In the expression:; case L "hello" of; L x -> "left " ++ x; R x -> "right " ++ x; <interactive>:5:40: error:; * Couldn't match exp
14:56:37 <mniip> %% case L "hello" of L x -> "left " ++ x; R x -> "right " ++ x
14:56:37 <yahb> mniip: http://qp.mniip.com/y/85
14:57:03 <mniip> hmm
14:57:42 <mniip> I think this is a typechecker problem
14:58:08 <mniip> it's supposed to telescope the 'forall' out and instantiate the 'r' with a unification variable
15:07:05 <mniip> hmm I could try to be real smart about it
15:08:24 <mniip> damn, defeats the point
15:10:19 <hpc> yes
15:10:21 <hpc> never be smart
15:12:39 <mniip> okay more weirdness
15:12:53 <mniip> % :t \(L x) -> x
15:12:53 <yahb> mniip: (forall r. (a -> r) -> (b -> r) -> r) -> a
15:13:04 <mniip> % :t \w -> let L x = w in x
15:13:04 <yahb> mniip: ; <interactive>:1:17: error:; * Couldn't match expected type `forall r. (a -> r) -> (b -> r) -> r' with actual type `p'; `p' is a rigid type variable bound by; the inferred type of it :: p -> a; at <interactive>:1:1; * In the expression: w; In a pattern binding: L x = w; In the expression: let L x = w in x; * Relevant bindings include; x :: a (bound at <
15:13:34 <mniip> is this really a rank-2 inference issue?
15:13:54 <mniip> % :t (\w -> let L x = w in x) :: (forall r. (a -> r) -> (b -> r) -> r) -> a -- it isn't
15:13:55 <yahb> mniip: ; <interactive>:1:18: error:; * Couldn't match expected type `forall r. (a1 -> r) -> (b0 -> r) -> r' with actual type `(a1 -> r0) -> (b1 -> r0) -> r0'; * In the expression: w; In a pattern binding: L x = w; In the expression: let L x = w in x; * Relevant bindings include; x :: a1 (bound at <interactive>:1:14); w :: forall r. (a1 -> r) -> (b1 -> r) -> r (bound at <in
15:14:15 <hpc> interesting
15:15:12 <mniip> I've never worked with PatternSynonyms before but the way they are declared is just broken
15:15:38 <hpc> is there a type signature you can give to w that fixes it?
15:15:50 <mniip> you write :: P => Q => A -> B -> C -> D  but really you mean (P *> D) <-> (Q *> (A, B, C))
15:15:58 <lin__> I am trying to write a custom way for outputting my data structure, but I am lost with IO. I'm trying to learn by building a minimal example where I print a list with each element in a new line. But   main = map putStrLn ["A".."Z"]   isn't working. Is there something obvious I am missing?
15:16:57 <hpc> :t map putStrLn
15:16:58 <lambdabot> [String] -> [IO ()]
15:17:09 <hpc> lin__: you're making a list of IO actions
15:17:12 <hpc> :t sequence
15:17:13 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
15:17:30 <hpc> sequence-ing that list will give you an IO [()]
15:17:32 <hpc> :t sequence_
15:17:33 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
15:17:43 <hpc> or you can sequence_ to get an IO () like you probably want
15:18:05 <hpc> lin__: once you have that, you might as well use mapM_ which combines them the way you want
15:18:08 <hpc> :t mapM)
15:18:09 <lambdabot> error: parse error on input ‘)’
15:18:09 <hpc> :t mapM_
15:18:10 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
15:18:21 <mniip> sequence_ (map f x) = mapM_ f x
15:18:25 <hpc> :t mapM_ putStrLn ["a", "b"]
15:18:26 <lambdabot> IO ()
15:20:24 <mniip> hpc, I have an even weirder pattern
15:20:38 <mniip> % pattern V :: Void -> (forall r. r); pattern V x <- x where V x = absurd x
15:20:38 <yahb> mniip:
15:20:49 <hpc> i recommend you work out why (map putStrLn) has the type it does as well, it'll help you get things right the first time in the future :D
15:21:33 <mniip> % :t (\w -> let V x = w in x) :: (forall r. r) -> Void
15:21:33 <yahb> mniip: ; <interactive>:1:18: error:; * Cannot instantiate unification variable `r0'; with a type involving foralls: forall r. r; GHC doesn't yet support impredicative polymorphism; * In the expression: w; In a pattern binding: V x = w; In the expression: let V x = w in x
15:21:40 <mniip> % :t (\(V x) -> x) :: (forall r. r) -> Void
15:21:40 <yahb> mniip: (forall r. r) -> Void
15:21:57 <hpc> ah, that's a nice simple example
15:22:10 <lin__> hpc: thanks
15:22:19 <confuzed> Are there any good resources or tips on how to start a new Haskell project? Like how to whiteboard a design and what pieces to design first?
15:22:24 <lin__> now I'm going off to find examples
15:22:51 <hpc> confuzed: nothing haskell-specific, just the usual good api design but moreso
15:25:01 <hpc> confuzed: haskell can be more sensitive to bad designs because your api needs a clear idea of the types it takes/returns, and you can't do circular imports
15:25:16 <mniip> .hs-boot?
15:25:35 <hpc> not worth the effort imo
15:25:58 <hpc> if you have circular imports, fix the design first i think
15:26:17 <hpc> because you have divided something into "modules" that can't actually be separated such that one is independent of the other
15:27:04 <mniip> if you have a ton of identifiers and want to provide a library where importing one module wouldn't shower you with the entire thing
15:27:32 <hpc> each module can import other pieces and not export them
15:27:44 <hpc> so say, A imports B imports C
15:27:45 <mniip> yes but if the code is interdependent
15:27:49 <dmrd> ironic question but, is it bad etiquette if I just ask questions here in the open? Feels like it makes the current convo hard to read. New to IRC so I'm not sure if there's a better way to go about it
15:28:00 <hpc> you only need things exported by B so you import B
15:28:14 <hpc> now you're using B and C, but only B stuff is in scope, and you're not using A
15:28:15 <glguy> dmrd: It's fine to just ask your question
15:28:44 <mniip> hpc, you're suggesting we use the condensation of the dependencey graph as a module layout
15:28:54 <mniip> what if under this scheme one of the modules is just too large to maintain
15:29:02 <dmrd> glguy: good to hear :)
15:29:05 <hpc> i suggest the dependency graph should be a DAG
15:29:18 <hpc> as long as you have that, you can factor out to whatever granularity leads to comfortable imports
15:29:28 <mniip> when did you last see a library simple enought where that's the case
15:29:48 <hpc> OS packages form a DAG
15:30:02 <hpc> i bet ghc doesn't have hs-boot files
15:30:06 <mniip> hahahahaha
15:30:29 <mniip> http://hackage.haskell.org/package/base-4.11.1.0/src/
15:30:33 <mniip> ^F -boot
15:30:36 <glguy> $ find compiler -name "*.hs-boot" | wc -l
15:30:36 <glguy>       49
15:30:43 <hpc> D: D: D:
15:31:09 <mniip> ~/ghc $ find -name "*.hs-boot" | wc -l
15:31:09 <mniip> 138
15:31:32 <mniip> ah, some of them in the testsuite
15:31:38 <dmrd> any of you used the Hoogle Haskell API? As in, I'm trying to import Hoogle from within haskell as `import Development.Hoogle` with no success
15:31:44 <mniip> 66 otherwise
15:31:53 <hpc> dmrd: paste your error?
15:31:54 <hpc> @lpaste
15:31:54 <lambdabot> Haskell pastebin: http://lpaste.net/
15:32:03 <mniip> lpaste is dead
15:32:07 <glguy> lpaste is dead, gist.github.com
15:32:13 <hpc> :(
15:32:20 <hpc> update topic?
15:32:21 <dmrd> sad. Pasting
15:32:39 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Earlier mass kick due to password compromise http://freenode.net/news/security-update-rpa' by ChanServ
15:33:50 <hpc> mniip: imagine the maximally hs-booted package
15:34:05 <hpc> mniip: everything has everything else in scope, the only difference between files is which has what definition
15:34:18 <dmrd> here it goes. glguy and others: https://gist.github.com/davidmrdavid/3636a254e37a8771ce03b284708142e5
15:34:33 <hpc> you basically have one .Internal module with the actual definitions
15:34:41 <hpc> then then some re-exports
15:34:44 <hpc> no modularity
15:34:55 <hpc> mniip: now imagine the maximally modular package
15:35:12 <hpc> every definition is in its own module, and only imports things it needs to complete the definition
15:35:20 <hpc> if two things are mutually dependent, you put them in the same package
15:35:40 <glguy> dmrd: What package are you trying to import Development.Hoogle from?
15:35:54 <mniip> but what if the set of mutually dependent things is so large that the code becomes unmaintainable
15:36:11 <mniip> aka the condensation has unions that are too large
15:36:17 <dmrd> glguy: I'm trying to import this -> https://hackage.haskell.org/package/hoogle-5.0.17.3/docs/Hoogle.html
15:36:19 <hpc> then you have one big module, and your code looks like what it is
15:36:46 <hpc> or you go back and make things less mutually interdependent
15:36:51 <glguy> dmrd: Then you should have: import Hoogle, not import Development.Hoogle
15:37:12 <hpc> make two smaller pieces that can work on their own, and a third smaller glue module that imports them
15:37:29 <hpc> or reframe the problem and write a totally different solution
15:37:36 <mniip> or alternatively if the condensation violates semantic bounds
15:37:56 <mniip> between what topics the code is about
15:37:57 <mniip> hpc, I think there's a limit
15:37:57 <mniip> a point where a hs-boot is worth the trouble
15:38:05 <hpc> it can't violate semantic bounds
15:38:20 <hpc> if one piece of code depends on another piece of code, they're meaningfully related
15:38:36 <hpc> er, s/depends/interdepends
15:38:50 <hpc> if they interdepend and they aren't semantically related, what the fresh hell did you write?
15:38:55 <dataN> so can i use the state monad with constraints to keep adding reified dictionaries to a continuation?
15:39:00 <haasn> Is there any way to do useful inspection of Symbols at type level? I'm missing some sort of type family SplitSymbol :: Symbol -> [Symbol]
15:39:03 <dmrd> glguy: I did try that :/ . Here's a gist with me 're-installing' the package as well as trying to 'stack build' again -> https://gist.github.com/davidmrdavid/91607c59ba78038a4d09f0df18e026a6
15:39:05 <haasn> which splits it into individual characters
15:39:09 <haasn> so that I can do pattern matching on it
15:39:33 <glguy> dmrd: Can you add your hoogle-plus-parser.cabal file to the gist?
15:39:56 <glguy> dmrd: running "stack install hoogle" isn't relevant to building your project
15:40:29 <hpc> i guess to put it anther way, interdependencies between pieces of code come from the design and not just out of nowhere
15:40:40 <hpc> but in between the design and individual lines of code is the file structure
15:40:54 <hpc> so if you can express the interdependencies (and independencies) in the module structure, you should
15:41:15 <hpc> or rather, you have to
15:41:27 <hpc> because the module structure decides what lines of code can interdepend in the first place as well
15:42:01 <hpc> this is hard to describe without a whiteboard
15:42:07 <haasn> Naively I would have guessed that maybe I can have a `type instance Length (AppendSymbol x y) = Length x + Length y` but GHC (of course) rejects this since it has no idea how to split up an arbitrary symbol into components
15:42:13 <dataN> what about folding lists of continuations?
15:42:25 <haasn> Even if AppendSymbol might be injective
15:42:48 <dmrd> glguy: I was trying to use 'stack install' to double check the package was installed...but maybe that's wrong. Anyhow, here's the cabal. I did review it, seems like hoogle is not there. https://gist.github.com/davidmrdavid/ac138b6ff0730e9f94b571194d43503a
15:43:44 <glguy> dmrd: You'll need to add "hoogle 5.0.*" to your build-depends section for any component that wants to import it
15:43:52 <glguy> "hoogle == 5.0.*" *
15:44:24 <glguy> and make sure you delete the package.yaml or it will overwrite that change
15:48:10 <tieTYT> hi
15:49:05 <dmrd> glguy: That worked! I appreciate your help so much :)
15:49:12 <dmrd> learned a couple tricks today
15:49:36 <tieTYT> I need some help with Applicative.  `pure :: a -> f a`. But you’re allowed to do this: `pure (+) <*> Just 3 <*> Just 5`   Isn’t the pure returning an `f (a -> b)`?  Doesn’t seem to match the type signature to me
15:50:00 <hpc> :t (<*>)
15:50:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:50:04 <hpc> yep!
15:50:52 <hpc> pure (+) :: Maybe (Int -> Int -> Int)
15:50:55 <marvin2> it is returning an f (a -> b), but b in this case is (a -> a)
15:50:57 <hpc> a = Int, b = (Int -> Int)
15:51:09 <marvin2> :t pure (+)
15:51:10 <lambdabot> (Num a, Applicative f) => f (a -> a -> a)
15:51:15 <hpc> so you <*> a thing of type Maybe Int
15:51:23 <hpc> and you get a thing of type f b
15:51:30 <hpc> which is Maybe (Int -> Int)
15:51:34 <hpc> do it again, you have a Maybe Int
16:02:12 <dataN> (\ a b c -> a $ b $ c) :: forall e k a b c. ((e=>a)->a) -> (e=>(k=>b)->b) -> (k => b) -> b, makes GHC very upset about not being able to deduce things from the context...
16:09:08 <reactormonk> In which GHC is DerivingVia?
16:13:09 <ddellacosta> reactormonk: pretty sure it's in 8.6.1, which I guess is still alpha? https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.6.1
16:13:34 <fishythefish> per https://ghc.haskell.org/trac/ghc/ticket/15178, the milestone is 8.6.1
16:14:30 <dataN> :t ($) :: ((p->a)->a) -> (p->a) -> a
16:14:31 <lambdabot> ((p -> a) -> a) -> (p -> a) -> a
16:14:41 <dataN> :t ($) :: ((p=>a)->a) -> (p=>a) -> a
16:14:42 <lambdabot> error:
16:14:42 <lambdabot>     • Could not deduce: p
16:14:42 <lambdabot>       from the context: p0
16:17:37 <dataN> why!?
16:19:13 <mniip> dataN, it's an ambiguous type
16:19:29 <pewpdawk> hey bros
16:19:42 <dataN> oh, how so?
16:19:53 <mniip> if you wrote 'dollar f x' for some f, x, it wouldn't be able to infer what 'p' in the type was
16:20:05 <dataN> clearly
16:20:39 <mniip> :t (\_ -> id) :: Proxy p -> ((p => a) -> a) -> (p => a) -> a
16:20:40 <lambdabot> Proxy p -> ((p => a) -> a) -> (p => a) -> a
16:21:00 <dataN> whats happening here?
16:21:07 <mniip> we added a Proxy argument
16:21:36 <dataN> what does that do?
16:21:47 <dataN> how does it make it work?
16:21:50 <mniip> solves the problem of inferring what 'p' is
16:23:04 <mniip> okay consider this example
16:23:08 <mniip> :t fromIntegral
16:23:08 <dataN> ah, so the version without the proxy is trying to get the typechecker to recognise some as yet unspecified constraint, but the version with the proxy specifies this constraint.
16:23:09 <lambdabot> (Num b, Integral a) => a -> b
16:23:16 <mniip> :t realToFrac
16:23:17 <lambdabot> (Fractional b, Real a) => a -> b
16:23:28 <mniip> :t realToFrac . fromIntegral
16:23:30 <lambdabot> (Integral a, Fractional c) => a -> c
16:23:37 <mniip> ugh, defaulting
16:23:48 <mniip> we're going to need a bigger example
16:24:07 <mniip> :t extract
16:24:08 <lambdabot> error: Variable not in scope: extract
16:24:27 <mniip> @let import Control.Comonad
16:24:28 <lambdabot>  Defined.
16:24:30 <mniip> :t extract
16:24:31 <lambdabot> Comonad w => w a -> a
16:24:36 <mniip> :t pure
16:24:38 <lambdabot> Applicative f => a -> f a
16:24:46 <mniip> :t extract . pure
16:24:47 <lambdabot> error:
16:24:47 <lambdabot>     • Ambiguous type variable ‘w0’ arising from a use of ‘extract’
16:24:47 <lambdabot>       prevents the constraint ‘(Comonad w0)’ from being solved.
16:25:05 <mniip> the resulting function is (Comonad w, Applicative w) => a -> a
16:25:13 <mniip> but the 'w' cannot be determined from the type a -> a
16:25:24 <mniip> hence when applying such a function the typechecker wouldn't know what to use for w
16:25:31 <mniip> we can resolve this:
16:26:14 <mniip> @let pureProxy :: Applicative f => Proxy f -> a -> f a; pureProxy _ = pure
16:26:15 <lambdabot>  Defined.
16:26:26 <mniip> :t (\p -> extract . pureProxy p)
16:26:27 <lambdabot> (Applicative w, Comonad w) => Proxy w -> c -> c
16:26:41 <mniip> now the 'w' is apparent from the type Proxy w -> c -> c
16:27:33 <dataN> nice
16:30:35 <dataN> getting errors about the argument to proxy being of kind * rather than Constraint
16:31:11 <dataN> c.f. the version with (\_->id)
16:32:04 <mniip> enable PolyKinds
16:32:09 <mniip> :k Proxy
16:32:10 <lambdabot> k -> *
16:32:23 <mniip> % :k Proxy
16:32:24 <yahb> mniip: Proxy :: k -> *
16:32:29 <mniip> % :set -XNoPolyKinds
16:32:29 <yahb> mniip:
16:32:31 <mniip> % :k Proxy
16:32:31 <yahb> mniip: Proxy :: k -> *
16:32:37 <mniip> or maybe that isn't the problem
16:32:54 <dataN> changes nothing
16:33:18 <mniip> what exactly are you doing?
16:34:14 <dataN> :t (\_ -> id) :: Proxy p -> ((p => a) -> a) -> (p => a) -> a
16:34:16 <lambdabot> Proxy p -> ((p => a) -> a) -> (p => a) -> a
16:34:31 <dataN> Expected a constraint, but `p' has kind `*'
16:35:01 <mniip> that's gotta be some extension
16:35:23 <dataN> ah, ConstraintKinds
16:40:28 <dataN> hmm, no that was a mistake, cant get it to work...
16:42:42 <dataN> doh, it was the definition of Proxy, turning it to lowercase proxy works
16:48:07 * hackage timer-wheel 0.1.0 - A timer wheel  http://hackage.haskell.org/package/timer-wheel-0.1.0 (mitchellwrosen)
16:48:23 <dataN> :t (\_ -> id) :: Proxy p -> ((p => a) -> a) -> (p => b) -> b
16:48:24 <lambdabot> error:
16:48:24 <lambdabot>     • Couldn't match type ‘a1’ with ‘b1’
16:48:24 <lambdabot>       ‘a1’ is a rigid type variable bound by
16:49:02 <dataN> since 'a' is arbitrary (polymorphic), this is surprising...
16:50:37 <hpc> the error is that a1 is a rigid type variable
16:50:38 <monoidal> you can't have (a -> a) -> b -> b either
16:50:57 <hpc> which speaking very loosely, means it's not polymorphic
16:51:35 <monoidal> (forall a. a -> a) -> b -> b works fine
16:52:55 <hpc> :t (id :: a -> b)
16:52:56 <lambdabot> error:
16:52:57 <lambdabot>     • Couldn't match type ‘a1’ with ‘b1’
16:52:57 <lambdabot>       ‘a1’ is a rigid type variable bound by
16:53:04 <hpc> dataN: ^ a simplification of your error
16:53:17 <pie__> yeah why *isnt* this an error? https://www.reddit.com/r/haskell/comments/4zf9n7/why_recordwildcard_with_missing_fields_issue_a/
16:54:48 <dataN> ok, that fixed it thanks...
16:55:08 <dataN> :t \ _ _ a b c = a (b c) :: forall proxy e k a. proxy e -> proxy k -> (forall b. (e=>b)->b) -> (forall c. e=>(k=>c)->c) -> (k => a) -> a
16:55:09 <lambdabot> error:
16:55:09 <lambdabot>     parse error on input ‘=’
16:55:09 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
16:55:20 <dataN> :t \ _ _ a b c -> a (b c) :: forall proxy e k a. proxy e -> proxy k -> (forall b. (e=>b)->b) -> (forall c. e=>(k=>c)->c) -> (k => a) -> a
16:55:22 <lambdabot> error:
16:55:22 <lambdabot>     • Couldn't match expected type ‘proxy1 e1
16:55:22 <lambdabot>                                     -> proxy1 k1
16:55:29 <dataN> sorry...
16:57:21 <jeezy`> hi everyone
16:57:49 <dataN> strange that complies, but only if the type signature defined explicitly...
16:58:10 <dataN> i.e. on the line above the definition
16:58:36 <mniip> of course you have to include the type signature
16:58:59 <mniip> the general rule of thumb is that with RankNTypes the compiler cannot infer anything at all so provide type annotations whenever
16:59:01 <hpc> rank-n types can't be inferred
16:59:11 <dataN> yes, but if the type signature is written as an annotation to the lambda above it fails...
16:59:22 <mniip> there's a difference between
16:59:27 <mniip> foo = bar :: T
16:59:33 <mniip> and  foo :: T; foo = bar
17:00:11 <dataN> apparently so
17:00:34 <dataN> whats the difference?
17:00:36 <mniip> in the former bar's type is unified with T and then tidied/generalized
17:00:52 <mniip> in the latter bar is checked against foo's user-supplied type T
17:00:58 <mniip> no generalization
17:01:02 <mniip> and/or tidying
17:01:19 <mniip> and/or this other thing that causes the difference
17:01:57 <lin__> I am really strugling with wrapping side effects into functions. If I want to use Data.Text.Lazy.IO.readFile and use that lazy text in a parser (which isa a Lazy.Text.Text -> myParsedFormat). How can I do that in a function that is not main?
17:02:03 <mniip> ok so basically it boils down to this
17:02:14 <mniip> consider bar :: S
17:02:42 <mniip> in the former case, bar is instantiated with unification variables, and also foo :: p where p is fresh. Then S ~ T, T ~ p is solved
17:02:51 <lin__> is my function FilePath -> IO() or IO() -> myParsedFormat or what?
17:02:57 <mniip> in the latter, bar is instantiated, and T ~ S is solved
17:03:21 <mniip> if T is a higher rank the former will not work (T ~ p will not solve) but the latter might if S is sufficiently close to T
17:03:44 <glguy> lin__: the composition of these two operations can have the type: FilePath -> IO ParsedFormat
17:03:53 <mniip> of course all of this alters slightly if instead of 'bar :: S' you have a proper expression with unknown type
17:04:50 <lin__> then I have to get "IO myFormat" to "myFormat"
17:05:17 <lin__> but that makes somehow sense, thanks glguy
17:05:24 <geekosaur> which is what >>= is for, as long as you put it back in IO after
17:05:27 <geekosaur> @where iotut
17:05:28 <lambdabot> https://www.vex.net/~trebla/haskell/IO.xhtml
17:06:11 <fishythefish> lin__: don't think of it as turning `IO MyFormat` into `MyFormat`
17:06:30 <fishythefish> you define your functions which operate on `MyFormat` as usual: `MyFormat -> Foo`
17:06:51 <fishythefish> then there are existing combinators which will allow you to apply that to an `IO MyFormat` and get an `IO Foo` out instead
17:07:33 <fishythefish> (or your function could be `MyFormat -> IO Foo` or whatever)
17:08:53 <dataN> hmm, having trouble using the function though... https://hastebin.com/kopadelobu.coffeescript
17:10:20 <dataN> wouldnt giving Proxy a kind of Constraint as it seems to indicate be wrong?
17:26:08 <lin__> now I'm trying it like the following
17:26:23 <lin__> bar <- T.readFile "File"
17:26:42 <lambdoid> hi
17:26:53 <lin__> mapM_ (putStrLn . show) prettyfyMyData . parseMyFormat bar
17:26:53 <lambdoid> how do I learn haskell?
17:27:18 <lin__> lambdoid: learyouahaskell.com is a good start
17:27:30 <lambdoid> I'm using macOS
17:27:56 <lambdoid> does haskell come on macOS
17:28:29 <lin__> but by paresMyFormat does not take IO myFormat, only myFormat, currently I'm lost what to do about that
17:28:52 <dataN> lambdoid: yes
17:30:00 <lin__> lambdoid: https://www.haskell.org/platform/mac.html might be useful? (never touched apple myself)
17:30:51 <mniip> haasn, still there?
17:31:06 <haasn> mniip: yes
17:31:18 <dataN> lin__: why use mapM_?
17:31:35 <mniip> haasn, I've formalized my codata idea
17:32:03 <mniip> it could mean a combination of patterns that are total together
17:32:07 <lin__> my prettyfyMyData creates a [String], and so I thought I'd map (putStrLn . show) on it, isn't Map_ the right thing for that?
17:32:08 <pavonia> lin__: You can use `return`or `pure` to lift pure values to IO actions
17:32:19 <dataN> do you mean (.) instead?
17:33:18 <dataN> pavonia: no, the putStrLn creates the Monad
17:33:44 <monochrom> That sentence is very very wrong wording.
17:33:48 <mniip> haasn, now lemme explain
17:34:28 <mniip> haasn, consider   pattern L :: a -> Either a b; pattern R :: b -> Either a b
17:35:39 <mniip> I would like to say  codata L | R = (case e of Left x -> L x; Right y -> R y) <- e
17:36:46 <mniip> which would really mean: data D a b = L' a | R' b;  pattern L t <- ((\e -> case e of Left x -> L' x; Right y -> R' y) -> L' t)
17:36:50 <mniip> and same for R
17:37:48 <mniip> note how a datum is created for the patterns participating in the codata declaration and then the datum's constructors are actually substituted into the body of the matching function
17:37:59 <mniip> the trick though
17:38:23 <mniip> is that when multiple patterns of the same codata declaration participate in a pattern match the can be fused together
17:38:33 <mniip> eliminating repetitive computation of the matching expression
17:38:58 <mniip> case e of L a -> f; R b -> g
17:39:01 <mniip> can be rewritten
17:39:17 <haasn> what does this gain over case e Left Right of Left a -> f; Right b -> g ?
17:39:18 <mniip> case e of e' -> case e' of Left a -> f; Right b -> g
17:39:37 <mniip> ?
17:39:41 <mniip> e :: Either a b
17:39:57 <dataN> ok, so it works now undefined can have type e.g.  'proxy Empty []'.
17:41:59 <lin__> where should I have meant (.)?
17:42:13 <mniip> consider codata L | R = expr <- e
17:42:18 <dataN> instead of mapM_
17:42:35 <mniip> you could introduce a rigid tyvar r and say expr :: r,  L :: a -> r, R :: b -> r
17:43:28 <dataN> mniip: what is that!?
17:43:32 <lin__> mapM_ (putStrLn . show) $ prettyfyMyData . parseMyFormat bar
17:43:39 <lin__> should be changed to
17:43:42 <mniip> and if e :: s, then the whole statement (\l r e -> expr) :: (a -> r) -> (b -> r) -> s -> r
17:43:43 <lin__> (.) (putStrLn . show) $ prettyfyMyData . parseMyFormat bar
17:43:44 <lin__> ?
17:43:55 <dataN> does it compile?
17:44:03 <lin__> nope
17:44:18 <lin__> Couldn't match expected type ‘IO myFormat’ with actual type ‘myFormat’
17:44:18 <mniip> and then you can transform   case foo of L x -> f; R y -> g;   into (\l r e -> expr) (\x -> f) (\y -> g)
17:44:39 <dataN> what about putting the dot in place of the first $ for a start...
17:46:13 <dataN> ok, so the composing constraints continuation seems to boil down to this type;
17:46:14 <dataN> forall proxy p q. proxy p -> proxy q -> (forall a. (p=>a)->a) -> (forall b. p=>(q=>b)->b) -> (forall c. (q=>c)->c)
17:47:05 <dataN> now, this is not a commutative function, reordering its 3rd and 4th arguments will break it
17:48:04 <dataN> however, the combination of constraints *is* communtative, and so the idea is to reconcile this...
17:49:19 <dataN> it almost looks like it could form a category...
17:50:44 <dataN> noting the return type and 3rd argument can both be decorated with superfluous '() =>' constraints...
17:50:56 <haasn> mniip: I think I follow
17:52:01 <haasn> although I'm not sure if I understand how exactly this `expr` meta-variable is connected to the patterns L, R etc.; what if I don't mention a pattern at all in `expr`? What if I mention it with conflicting types? But I guess that would be much like type-checking \l r -> expr
17:52:26 <haasn> I mean at some point this is just syntactic sugar, right?
17:54:06 <mniip> not really
17:54:14 <mniip> it *can* desugar
17:54:33 <mniip> but the cool part is when it doesn't and it transforms the case-of expression that uses it instead
17:55:03 <haasn> what I mean is that you could have written (\l r e -> expr) (\x -> f) (\y -> g) yourself
17:55:11 <haasn> so in that sense it's syntax sugar to me
17:55:53 <haasn> anyway I need to sleep
17:56:07 <mniip> regarding your typechecking question
17:56:28 <mniip> codata A = 123 <- e
17:56:32 <mniip> wouldn't work
17:56:41 <mniip> can't unify Int with a rigit tyvar r
17:57:23 <mniip> on the contrary, if you say
17:57:34 <mniip> codata A = A 123 e <- e
17:57:51 <mniip> then we can infer A :: Int -> s -> r
17:58:01 <mniip> therefore   pattern A :: Int -> s -> s
18:11:38 <inkbottle> "package.yaml" is a replacement for "packageName.cabal" file? Exact same purpose, am I correct? (when using stack, of course)
18:19:26 <inkbottle> I close my question with "probably yes, since there is `hpack-convert`".
18:24:22 <inkbottle> However `hpack-convert` doesn't build at the present; I think I'll have to do the job by hand [https://github.com/yamadapc/hpack-convert/issues/18]
18:26:46 <inkbottle> https://hpack-convert.herokuapp.com/ -- fixed
18:56:45 <pocucan> Hi Im new to haskell but use functional programming in other languages, ive been struggling with data types and other things, Ive been using "Learn Haskell For Great Good"
18:56:59 <pocucan> does anyone recommend anything else?
19:02:04 <monochrom> What are "other languages"?
19:13:37 * hackage termbox 0.1.0 - termbox bindings  http://hackage.haskell.org/package/termbox-0.1.0 (mitchellwrosen)
19:36:27 <orbisvicis> if I have 'data D = A | D', can I deprecate the last data constructor ?
19:38:03 <ktuhin95> Any suggestions for good mathematical projects to implement for haskell beginners ? P.S - I have completed courses on group theory, graph theory, ML , AI , NLP , Linear algebra and game theory if that helps
19:40:15 <mud> ktuhin95: If you're interested in competitive programming, some of that can be fun in a new language. It uses graph theory and game theory fairly often at least, some lin alg probably too once in a while
19:40:18 <orbisvicis> perhaps contribute to a geometry library? I don't think any are complete.
20:11:45 --- mode: ChanServ set +o glguy
20:11:46 --- mode: glguy set +b selfsymmetric!*@*$##fix_your_connection
20:12:13 <inkbottle> intero -v says 0.1.32; but when I open a file in my stack project which specifies lts-12.1 in the stack.yaml file, emacs complains ans says its version is intero-0.1.24
20:13:59 <inkbottle> I've just updated stack, and amended with the new lts-12.1; and did build; and reinstalled intero (with stack install)
20:18:39 <|Leary> orbisvicis: quoting the 8.4.3 manual section on the DEPRECATED pragma: "A capitalised name, such as T refers to either the type constructor T or the data constructor T, or both if both are in scope. If both are in scope, there is currently no way to specify one without the other [...]."
20:19:17 <glguy> |Leary: I don't think that's really the question
20:21:45 <glguy> No, I just can't read :)
20:21:48 <orbisvicis> yeah I was hoping that was outdated
20:21:56 <glguy> 8.4.3 is pretty current
20:22:27 <orbisvicis> or there was some workaround
20:22:30 <|Leary> I think the simplest way to proceed is to host the non-deprecated constructors in a separate sum type.
20:22:43 <|Leary> Is this about X.L.Spacing?
20:22:48 <mud> inkbottle: I don't know a lot about how intero is installed. Do you recall what steps you followed to install it? Or configure it? I'd assume the one you're updating isn't the one that's actually being run.
20:23:03 <orbisvicis> yep, just about to reply too. I think new type is too bulky for this situation
20:24:38 <inkbottle> mud: it's a discrepancy between the installed version, and the version which emacs would like to use: the installed version is more recent; however, since I use stack, the older version is still present
20:24:53 <orbisvicis> |Leary: replied, ignore the duplicate question
20:35:18 <inkbottle> I'll ask my question again later: for the moment I can't edit a single file anymore due to "intero" not working.
20:41:35 <edmundnoble> Hi all. I have a performance/data structures question. I require a variation on a queue which has: a) constant-time push, and b) linear time foldl/foldr, but c) with no amortization at fold-time. What I mean by this is, I *can* build a list in reverse and reverse it on use, but I'm going to be "using" a lot of these lists, and I'd prefer to amortize the cost at push-time instead. Any way I can do this immutably without
20:41:36 <edmundnoble> bad constant factors?
20:42:13 <edmundnoble> Something as general as a deque I feel will likely sacrifice too much performance to be worth it.
20:42:53 <edmundnoble> Oh to be specific, I'm not just "using a lot of these lists", I'm using a lot of those lists, *and* they share a lot of structure with each other.
20:47:00 <edmundnoble> Oh come to think of it, instead of storing lists, I could just store partial fold results, then link them together using laziness. That should give me the amortization I want.
20:47:06 <edmundnoble> Er, the sharing I mean.
20:50:16 <selfsymmetric-mu> I know this doesn't account for all your desiderata, but I feel I should mention that `Data.Vector` does support non-copy slices.
20:53:42 <edmundnoble> True, thank you
20:53:55 <edmundnoble> Unfortunately as you say, arrays aren't suitable for my performance needs
20:54:05 <edmundnoble> I just don't know ahead of time how many elements I'll have
20:54:22 <edmundnoble> If I did, I'd just use arrays
20:54:47 <edmundnoble> Didn't know `Data.Vector` existed though, seems useful
21:07:00 <buttons840> is there a way to force a GC collection? i'm trying to test a ForeignPtr finalizer
21:10:32 <glguy> http://hackage.haskell.org/package/base-4.11.1.0/docs/System-Mem.html
21:10:55 <buttons840> glguy: ty, i'll take a look
21:11:24 <buttons840> ezpz -- i'm suprised my web searches didn't turn that up
21:29:21 --- mode: glguy set -o glguy
22:09:37 * hackage serverless-haskell 0.7.1 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.7.1 (AlexeyKotlyarov)
22:12:06 * hackage serverless-haskell 0.6.3 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.6.3 (AlexeyKotlyarov)
22:22:54 <quicksilver> edmundnoble: you could use Data.Sequence and pretend the log factors don't exist.
22:23:06 <quicksilver> edmundnoble: you might get away with it in practice, since O(1) is a lie anyway.
22:23:45 <edmundnoble> quicksilver: Sorry, but this is kind of my escape from Scala ;)
22:23:51 <quicksilver> ?
22:24:23 <edmundnoble> It's a Scala meme, there's a collection which allegedly has "effectively constant" performance
22:24:30 <quicksilver> ok
22:24:55 <quicksilver> but the only real way to decide between O(log n) operations and O(1) ones is to benchmark for your actual use case
22:25:03 <edmundnoble> Yeah, for sure, I will do that
22:25:14 <quicksilver> because no real system actually provides O(1) performance for memory access
22:25:24 <quicksilver> (and everything else tends to build on memory access)
22:25:51 <edmundnoble> Sure, I don't know what will work best
22:25:57 <edmundnoble> Maybe sharing is worse than recomputing
22:26:02 <quicksilver> so you have to measure if the implicit issues of cache fetches hiding behind your O(1) are actually better or worse than the O(log n)
22:26:20 <quicksilver> if your O(log n) data structure has better memory locality or cache behaviour you win.
22:26:34 <quicksilver> Data.Sequence is pretty fast.
22:27:06 <dminuoso> 07:24      quicksilver | because no real system actually provides O(1) performance for memory access
22:27:10 <dminuoso> Are you sure about that?
22:27:27 <dminuoso> Even if every memory access is a cache and page miss, it should still be O(1).
22:27:45 <dminuoso> O(1) does not mean instant, it just means constant with respect to size.
22:32:08 <fresheyeball> I just got a "Ratio has zero denominator" error and I have no clue where it is in my code
22:32:10 <fresheyeball> halp!
22:32:25 <fresheyeball> how can that even happen?
22:37:11 <dminuoso> fresheyeball: You could use +RTS -xc
22:37:26 <cocreature> note that this requires that you compile with profiling info
22:37:39 <fresheyeball> dminuoso: what does that do?
22:37:56 <cocreature> it shows a stacktrace for each exception
22:38:31 <fresheyeball> ok
22:39:06 <fresheyeball> how do I turn on profiling?
22:39:36 <cocreature> stack or cabal?
22:39:41 <fresheyeball> cabal
22:39:52 <cocreature> cabal new-build --enable-profiling
22:40:26 <buhman> is cabal related to this cabal: https://en.wikipedia.org/wiki/Cabal ?
22:42:27 <cocreature> buhman: it’s an acronym for Common Architecture for Building Applications and Libraries but as usual for these kind of acronyms the fact that it matches an existing word is probably an intended pun :)
22:43:50 <buhman> the literal build system of the secret order would be so much less boring, anyway
22:44:21 <buhman> "common architecture.." bleh :)
22:45:19 <cocreature> that’s why nobody mentions the expanded version :)
22:45:26 <quicksilver> dminuoso: yes, I'm sure :)
22:45:58 <dminuoso> quicksilver: Can you elaborate why it would not be O(1)?
22:46:13 <quicksilver> dminuoso: if you access small data structures then they're all in cache so your memory access speed is A. Bigger data structures lead to breaking out of that cache and moving into slower memory, B, C, D eventually maybe swap E
22:47:07 <quicksilver> there are also theoretical arguments - decoding an address is obviously an O(log n) operation, as is calculating a hash key, for example
22:48:00 <quicksilver> here is one blog post laying out the arugment in more detail: http://www.ilikebigbits.com/blog/2014/4/21/the-myth-of-ram-part-i
22:48:12 <quicksilver> other people (in this channel!) have said it better than me, though.
22:49:31 <dminuoso> quicksilver: But since big-O is about an upper bound, wouldn't you have to assume the poor cache behavior anyway?
22:50:38 <dminuoso> quicksilver: My issue is not as much with what you are conveying - as it is about the "O(1)" part. :)
22:51:45 <dminuoso> But the articles are a nice read. :)
22:53:58 <cocreature> dminuoso: it sounds like your argument is something like “every access on a given machine is limited by some upper bound and therefore O(1)”. the point the article is making (iirc, it’s been years since I’ve read it) is that this argument doesn’t make sense since if you really want to do asymptotic analysis you have to consider larger machines since otherwise the amount of memory you can allocate
22:54:00 <cocreature> is also limited by a constant. that leads to an ever growing memory hierarchy and therefore you don’t get O(1) accesses
22:57:15 <quicksilver> the reason this matters is that there really are use cases in which a very large array (O(1)) will be outperformed by a fingertree (log or log-log operations)
22:57:30 <quicksilver> consistently / "asymptotically"
22:57:38 <quicksilver> so it's not just a theoretical or pedantic point
22:58:04 <quicksilver> it's really true that distinguishing between log and constant based on an idealised architecture gives you the wrong performance recommendation
23:00:13 <cocreature> though that can be the case even if the asymptotics hold on your given architecture
23:02:08 <cocreature> asymptotics are a nice theoretical tool for the analysis of algorithms. in general, they tell you very little about how something is actually going to perform on a given piece of hardware
23:24:36 * hackage rss-conduit 0.4.2.2 - Streaming parser/renderer for the RSS standard.  http://hackage.haskell.org/package/rss-conduit-0.4.2.2 (koral)
23:34:37 * hackage svfactor 0.1 - Syntax-preserving CSV manipulation  http://hackage.haskell.org/package/svfactor-0.1 (qfpl)
23:38:55 <tolt> what's the name of one of the tools that tries to infer a function from a type?
23:39:31 <dminuoso> tolt: djinn
23:39:48 <dminuoso> @djinn a -> (a -> b) -> b
23:39:48 <lambdabot> f a b = b a
23:39:48 <cocreature> or exference
23:39:55 <cocreature> @exference a -> (a -> b) -> b
23:39:55 <lambdabot> Unknown command, try @list
23:40:01 <cocreature> @exfer a -> (a -> b) -> b
23:40:01 <lambdabot> Unknown command, try @list
23:40:05 <cocreature> hm, I forgot the command
23:40:06 <cocreature> @list
23:40:07 <lambdabot> What module?  Try @listmodules for some ideas.
23:40:55 <tolt> ah! thanks!
23:41:36 <cocreature> :exf a -> (a -> b) -> b
23:41:36 <exferenceBot> parse error: more than one input
23:41:47 <cocreature> :exf "a -> (a -> b) -> b"
23:41:50 <exferenceBot> \ a f2 -> f2 a
23:41:55 <cocreature> ah!
23:56:25 <quicksilver> @remember quicksilver "In particular, Big-O notation is there to abstract constant factors, but RAM accesses is not a constant time operation - not in theory, and not in practice." -- The Myth of RAM
23:56:25 <lambdabot> Done.
