00:09:02 <maybefbi> @djinn a -> a
00:09:02 <lambdabot> f a = a
00:09:47 <maybefbi> @djinn [a] -> a
00:09:47 <lambdabot> Error: Undefined type []
00:09:55 <maybefbi> @djinn Maybe a -> a
00:09:55 <lambdabot> -- f cannot be realized.
00:10:03 <maybefbi> @djinn Maybe a -> Bool
00:10:04 <lambdabot> f a =
00:10:04 <lambdabot>     case a of
00:10:04 <lambdabot>     Nothing -> False
00:10:04 <lambdabot>     Just _ -> True
00:11:19 <maybefbi> @djinn List a -> Bool
00:11:19 <lambdabot> Error: Undefined type List
00:11:25 <maybefbi> @djinn [a] -> Bool
00:11:26 <lambdabot> Error: Undefined type []
00:12:11 <samla> lambdabot knows that arrays are better than lists
00:15:36 * hackage rpmbuild-order 0.1 - Order RPM packages by dependencies  http://hackage.haskell.org/package/rpmbuild-order-0.1 (JensPetersen)
00:18:47 <infinisil> @djinn Functor f => (a -> b) -> f a -> f b
00:18:47 <lambdabot> Error: Class not found: Functor
00:19:23 <infinisil> Boooo
00:25:34 <pavonia> @djinn Maybe a -> Int
00:25:34 <lambdabot> Error: Undefined type Int
01:08:37 * hackage MBot 0.2.4.1 - Haskell interface for controlling the mBot educational robot  http://hackage.haskell.org/package/MBot-0.2.4.1 (cfscholl)
01:29:16 <AndreasK> Can someone explain that cabal error to me?
01:29:19 <AndreasK> [190] rejecting: containers:*bench (dependencies not linked: stanza "bench"
01:29:19 <AndreasK> incompatible; conflict set: containers, code-page:hsc2hs:exe.containers,
01:29:19 <AndreasK> containers:bench, code-page:hsc2hs:exe.containers:bench)
01:29:35 <AndreasK> Trying to build containers with --enable-benchmarks
01:32:34 <phadej> you are trying to build containers' benchmark?
01:33:05 <phadej> that unfortunately don't work with new-build. Search "per component solving" on Cabal issue tracker
01:34:29 <phadej> Ah, you said that, I just stared on the error message. Anyway; unfortunately that doesn't work :/
01:36:32 <AndreasK> phadej: Well at least I know to stop trying now :)
01:38:32 <phadej> AndreasK: I /think/ that if you rename the package to containers-something, you'll be able to proceed
01:39:27 <phadej> (maybe even good idea to avoid compling tooling with `containers` under dev/test/bench)
01:41:57 <phadej> (note: you don't need to rename .cabal file)
01:44:04 <AndreasK> phadej: Shouldn't new-build prevent that anyway? (Building tooling libs with the "wrong" flags?)
01:44:57 <phadej> I mean, that if you test containers, make a bug there, but then your `test-framework` (or whatever) uses same `containers` as under test, what will happen? :)
01:45:51 <AndreasK> Guess so, but the benchmark flag I hope doesn't affect the actually library.
01:46:16 <phadej> no, but if you make non-trivial changes there, you might break it :)
01:46:38 <AndreasK> phadej: Modulo potential breake from using ghc-head renaming seems to work
01:47:14 <phadej> AndreasK: good to know
01:47:24 <AndreasK> I'm testing performance impact of some ghc changes. So not planning to change the library. But good point
01:54:50 <phadej> AndreasK: another 1-2% boosts here and there?
01:55:28 <bwe> GADTs: How can I define an Ord instance such that Range (Cm 1) (Cm 2) > Single (Cm 1)? https://repl.it/repls/AccuratePersonalNotification
01:57:19 <phadej> bwe: do you know how to write Eq/Ord by hand?
01:57:50 <bwe> phadej: Let me check!
01:58:42 <phadej> (writing Show by hand is trickier, but doable too)
01:59:59 <phadej> showsPrec d (Range x y) = showParens (d > 10) $ showString "Range " . showsPrec 11 x . showChar ' ' . showsPrec 11 y
02:00:06 <phadej> and similar for (Single y)
02:02:10 <merijn> Show is only hard if you want it to be what GHC would generate :p
02:03:09 <bwe> phadej: Do I need to write Show by hand?
02:04:03 <phadej> if it works, you don't
02:04:35 <phadej> merijn: there's only one case where I  want something different. To avoid parens for infix constructors.
02:07:26 <bwe> phadej: I've updated the repl: https://repl.it/repls/AccuratePersonalNotification
02:08:01 <bwe> phadej: I would need to pattern match the different variants and tell how to determine which is greater, equal or less.
02:12:39 <bwe> phadej: Now I've implemented it for Cm data type by hand. However, for Measurement GADT GHC raises   Could not deduce: a1 ~ (a1, a1)
02:12:42 <bwe>       from the context: (a ~ (a1, a1), Show a1, Eq a1, Ord a1)
02:12:45 <bwe>         bound by a pattern with constructor
02:18:07 * hackage semirings 0.2.0.0 - two monoids as one, in holy haskimony  http://hackage.haskell.org/package/semirings-0.2.0.0 (chessai)
02:24:44 <osa1> is there a way to make cabal print exact verisons of dependencies when I do something like `cabal configure --with-ghc=... --allow-newer` ?
02:27:54 <phadej> osa1: cabal-plan [topo]
02:28:09 <phadej> ah, configure, not new-build
02:28:10 <phadej> hmm
02:28:28 <phadej> then I don't know
02:28:37 <osa1> phadej: I can use new-build if that helps, I just don't know how to do this with new-build (never used it before)
02:28:47 <phadej> what's "this" :)
02:28:56 <osa1> the installation dance
02:29:14 <osa1> what's equivalent of `cabal configure --with-ghc=... --allow-never && cabal build` in new-build?
02:29:27 <phadej> `cabal new-build --wight-ghc=... --allow-newer`
02:29:29 <merijn> osa1: If you have a new enough cabal-install there's "new-install", but it's still a bit rough
02:29:40 <osa1> I don't want to install so that's fine
02:30:00 <merijn> osa1: With new-build you no longer have to configure ahead of time
02:30:02 <phadej> osa1: i.e. there isn't really a dance
02:30:16 <osa1> great
02:30:50 <merijn> osa1: You can do "new-configure" to create a persistent cabal.project.local so you don't have to pass the flags on the commandline each time, but if you simply pass the flags it Just Works(TM)
02:30:51 <phadej> you can do `--dry` to generate some data, e.g. plan.json which can be read by cabal-plan
02:31:12 <phadej> if you really want a squeeze something between "configuring" and "building"
02:32:37 <phadej> I do new-build --dry; new-build --dep; new-build in "fancier" build-systems as those steps parallelis differently. Good thing that `new-build` reuses stuff already done, so it actually is a split (at least quite close to)
02:35:01 <osa1> umm where did this install cabal-plan? it's not in ~/.cabal/bin or ~/.local/bin
02:35:21 <merijn> osa1: After new-build, you mean?
02:35:35 <osa1> merijn: no, after `cabal install cabal-plan`
02:35:52 <merijn> ah, that should be in ~/.cabal/bin, normally
02:36:08 <osa1> it's not there
02:36:12 <phadej> osa1: try --constraint='cabal-plan +exe'
02:36:42 <phadej> the exe is hidden behind (quite volatile) automatic flag
02:36:48 <osa1> ugh
02:36:51 <phadej> I know
02:37:10 <phadej> need to go ->
02:37:28 <osa1> I also did new-build in the meantime, which file should I be looking at? e.g. which file cabal-plan (once it's installed) will read?
02:37:47 <osa1> ahh great, it seems to work
02:43:28 <dminuoso> Is there a canonical graphics library to do some simple visualization for things?
02:44:33 <merijn> dminuoso: What kinda visualisation?
02:44:43 <cocreature> if you want a general purpose graphics lib, maybe diagrams
02:44:53 <cocreature> if you want something more targetted at plotting datasets there are other libs
02:45:30 <dminuoso> Well Im doing some graph based algorithms at the moment, and was wondering how to visualize these algorithms at the moment. SVG is starting to become awkward and annoying to use
02:46:01 <cocreature> if you want to visualize graphs, maybe graphviz?
02:46:46 <dminuoso> Mmm, I think gloss might be rather what Im after
02:51:20 <phma> Is there a way to set up Cabal so that projects are built out-of-source?
02:53:15 <merijn> phma: You can control the builddir with the, well, --builddir flag
02:53:34 <merijn> Sadly, you can't specify the builddir flag in cabal.project :\
02:57:19 <phma> Would I run cabal in the source directory or the build directory?
02:58:07 <bwe> What's wrong with line 13 in https://repl.it/repls/AccuratePersonalNotification?
02:58:10 <osa1> I want to build a package with the specified versions of deps in the .cabal file, but some of the deps won't build because of the ghc version I'm using. is there a way to do --allow-newer, but only for dependencies and not for the actual package I'm trying to build?
02:59:07 * hackage cryptoids 0.5.1.0 - Reversable and secure encoding of object ids as a bytestring  http://hackage.haskell.org/package/cryptoids-0.5.1.0 (gkleen)
03:00:02 <barrucadu> bwe: Data constructors have to start with a capital letter
03:00:18 <cocreature> suzu: I don’t think there is an option for “apply it to all deps” but you can apply it to only selected packages, see https://cabal.readthedocs.io/en/latest/installing-packages.html?highlight=allow-newer#cmdoption-setup-configure-allow-newer
03:00:27 <barrucadu> Well, some sort of upper case unicode thing.  I don't know what the character class is exactly.
03:00:40 <barrucadu> So 'compare' should be 'Compare'
03:03:04 <bwe> :i compare
03:03:17 <bwe> compare :: a -> a -> Ordering
03:04:26 <bwe> so if I want to implement the instance for the function `compare`, I don't understand, how the requirement for a data constructor arises (I presume, barrucadu, you mean to capitalise `compare`)?
03:05:49 <quicksilver> bwe: you've put it inside "data where..."
03:05:57 <quicksilver> so it is a data constructor?
03:06:11 <quicksilver> looks like you might not have meant to put it inside data where... but I'm not sure what you're going
03:07:47 <bwe> quicksilver: I want to define Ord for the GADT `Measurement`.
03:08:12 <bwe> Single (Cm 1) < Range (Cm 2) (Cm 3)  should return True
03:14:39 <bwe> quicksilver: ‘compare’ is not a (visible) method of class ‘Measurement’ -- how can I make it such?
03:18:57 <cocreature> bwe: that sounds like you are trying to write an instance for a class called Measurement rather than an instance for the Ord class for the Measurement type
03:22:03 <bwe> cocreature: What's the difference? If I write   class Measurement a where ... GHC complains it'd already have such.
03:22:29 <cocreature> bwe: can you show us the code that is causing this error?
03:23:46 <bwe> cocreature: Sure. https://repl.it/repls/AccuratePersonalNotification
03:23:57 <bwe> cocreature: It raises   Multiple declarations of ‘Measurement’
03:24:15 <AndreasK> phadej: We will see :) Looks more like 0.5% so far but that's why I want to run some more benchmarks
03:24:27 <bwe> Maybe I am overlooking something. It's my first encounter with GADTs.
03:24:38 <cocreature> bwe: this has nothing to do with GADTs
03:24:52 <cocreature> step 1. remove the class declaration that you just added. you want to create an instance not a new class
03:24:56 <bwe> cocreature: That's actually good to learn.
03:25:05 <cocreature> bwe: can you explain to me what you think "instance Ord Eq a => (Measurement a) where" means?
03:27:10 <bwe> cocreature: implement typeclass Ord for type constructor Measurement a, of which a must implement typeclass Eq (though the constrained seems to have failed).
03:27:43 <cocreature> bwe: it seems like you have the syntax mixed up. that would be "instance Eq a => Ord (Measurement a)"
03:27:55 <cocreature> the typeclass that you want to create an instance for is always on the right of the arrow
03:28:52 <bwe> cocreature: I agree. But interestingly, even if I remove the constraint, having   instance Ord (Measurement a) where   , lines 18 and 19 raise a Could not deduce: a1 ~ (a1, a1) error.
03:29:01 <cocreature> "instance Ord Eq a => Measurement a" will try to create an instance for a (nonexistent) measurement typeclass for "a" with a constraint "Ord Eq a" (which doesn’t make sense)
03:30:29 <bwe> I've updated the repl: https://repl.it/repls/AccuratePersonalNotification
03:31:23 <cocreature> you need to write an Eq instance for "Measurement a" first
03:32:28 <quicksilver> I don't think he does, he's deriving it
03:32:46 <quicksilver> but I think the Ord instance needs an (Ord a) consrtaint
03:32:53 <quicksilver> nor just an (Eq a)
03:32:56 <quicksilver> *not
03:33:09 <bwe> cocreature: Done. Single (Cm 1) < Single (Cm 2) does now return True (as it should).
03:33:24 <cocreature> quicksilver: it’s not derived in the most recent link
03:33:55 <cocreature> well it wasn’t a few minutes ago. apparently you can update these links :)
03:35:31 <bwe> Now I understand better why line 25 raises   Could not deduce: a1 ~ (a1, a1)
03:35:47 <bwe> instance Eq a => Ord (Measurement a) where
03:36:41 <cocreature> tbh I’m not sure using a GADT for this makes sense
03:37:03 <c50a326> hey I thought I'd try to understand how async works, https://www.stackage.org/haddock/lts-8.20/async-2.1.1.1/src/Control.Concurrent.Async.html#async so I looked at inline http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Exts.html#v:inline seems like some optimisation thing that I don't need to worry about?
03:37:27 <bwe> parametrises the type to either Single or range (one arg or two arg). Which would render the comparison of Single and Range impossible; since it allows for either Single or Range but not both.
03:37:51 <c50a326> then there is rawForkIO https://www.stackage.org/haddock/lts-8.20/async-2.1.1.1/src/Control.Concurrent.Async.html#rawForkIO which calls fork# which I cannot find in this file or using hoogle
03:39:14 <bwe> cocreature: What would make sense to you for comparing single value and range value
03:39:17 <cocreature> bwe: are you sure you don’t want "data Measurement a = Single a | Range a a" instead?
03:39:51 <cocreature> c50a326: https://hoogle.haskell.org/?hoogle=fork%23
03:40:33 <cocreature> c50a326: but I wouldn’t worry about this. async’s internals are pretty optimized but the semantics should be the same as if it was using "forkIO" directly
03:41:31 <c50a326> wtf https://www.haskell.org/hoogle/?hoogle=fork%23
03:41:49 <c50a326> haskell.org is hosting two different hoogles, one of them not working for some things?
03:42:07 * hackage rdf4h 3.1.0 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-3.1.0 (RobStewart)
03:43:55 <cocreature> c50a326: haskell.org/hoogle is hoogle 4 which has a better typesearch but is no longer updated and indexes only a tiny amount of packages. hoogle.haskell.org is hoogle 5 which has worse typesearch but indexes all of stackage and is updated regularly
03:45:14 <bwe> cocreature: You are right. data Measurement a = Single a | Range a a  covers most of the requirements. However Range (Cm 2) (Cm 3) > Single (Cm 5) is evaluated as True which is wrong.
03:46:12 <cocreature> bwe: you can still implement your own Ord instance
03:46:25 <cocreature> my point is you might not need a GADT for this
03:46:27 <merijn> c50a326: fork# (and basically all functions with # in it) are low-level compiler primitives
03:47:13 <merijn> c50a326: fork# and most other # functions can be found in the ghc-prim package, which is generally kinda hidden on Hackage so beginners won't think they're supposed to use it
03:48:42 <cocreature> fork# is reexported from GHC.Exts so it’s not super hard to find :)
03:49:00 <merijn> ah
03:49:25 <merijn> Although GHC.Exts is probably also best avoided until you're a bit more comfortable what you're doing :p
03:49:30 <lin__> I am trying to write a CLI using the following http://hackage.haskell.org/package/cmdargs-0.10.20/docs/System-Console-CmdArgs-Explicit.html
03:49:53 <lin__> but I cannot figure out how to check if an optional argment has been given or not
03:50:27 <lin__> currently I am using default values, which is inefficient and doesn't work for reading optional files
03:50:39 <merijn> lin__: I realise this is not directly helpful, but I've always found CmdArgs to be entirely to magical, making it hard to figure things (like your current question) out, so I wouldn't really recommend it as CLI library
03:51:39 <lin__> Can I mix it with others? I am writing a subcommand to a bigger CLI that already uses CmdArgs
03:51:57 <merijn> ah...that's unfortunate
03:53:47 <merijn> I'd figure that flagOpt would produce a maybe, but it doesn't seem too
03:54:45 <lin__> In other languages I would expect a null or None of some kind of fuction returning False if the arguement is not given
03:55:11 <merijn> A quick scan of the readme also doesn't get me much further, maybe you can find an example in some users of cmdargs?
03:55:18 <[exa]> is there Accelerate backend that would create non-CUDA gpu code? e.g. compute shaders or so
03:55:26 <merijn> lin__: Yeah, I'd expect a "Maybe a" from flagOpt, but I don't see it there
03:55:49 <cocreature> [exa]: there was an opencl backend at some point iirc but afaik it is no longer actively maintained
03:56:04 <merijn> [exa]: Have you looked at Futhark yet?
03:56:08 <lin__> what also confuses me is that flagReq would be for required arguements, but I can call my executable without those arguements without a problem
03:56:09 <[exa]> that makes me a sad panda
03:56:15 <[exa]> merijn: not yet, thanks for tip
03:56:17 <merijn> cocreature: I don't blame them, openCL is an awful language to support :)
03:56:29 <merijn> [exa]: You should ping Athas if you need help with it :p
03:56:52 <lin__> so, even if reqOpt isn't the way to go, what could be a possible way to check if an arguement was given
03:57:37 <[exa]> that looks cool
03:57:37 <merijn> lin__: So, naively I'd say you want a "Flag (Maybe a)" and specify Nothing as default, then fmap Just over whatever parser you want to use for the actual Flag
03:58:21 <merijn> [exa]: tbh, the state of GPU DSLs is still rather abysmal
04:00:25 <merijn> lin__: And for the future (when you're not restricted by existing code) I'd recommend optparse-applicative for CLI stuff. It requires a bit more boilerplate than cmdargs, but it's much more flexible, explicit, and less magical, which I strongly prefer
04:00:53 <cocreature> the boilerplate is also not that bad
04:01:10 <merijn> cocreature: It's not, but it is there when you start out with super minimal/small CLIs
04:01:24 <bwe> cocreature: Thanks for bringing me back on track. I realise this is not only simpler but it also seems more powerful to me: https://repl.it/repls/SaddlebrownShorttermBrackets
04:01:36 <merijn> But as soon as I move past the bare minimum that lack of inscrutable magic is much better than saving 3 lines
04:02:26 <cocreature> tbh making decisions based on whether something saves you 3 lines is usually a bad idea in the long run :)
04:02:53 <merijn> cocreature: Sure, but it might take you a while to learn that lesson ;)
04:03:07 <lin__> thanks merijn
04:03:27 <bwe> cocreature: I wonder how does it happen that   Range (Cm 5) (Cm 5) == Single (Cm 5)   evaluates to False despite I defined the guard on line 19 for exactly that case.
04:03:33 <[exa]> ok futhark looks like the right tool
04:03:52 <[exa]> thanks :]
04:04:56 <cocreature> bwe: (==) comes from the Eq instance which you haven’t defined
04:08:04 <merijn> Athas: I'm going to have to start charging you Futhark marketing fees in the future ;)
04:09:51 <bwe> cocreature: True. Implemented. Works. https://repl.it/repls/SaddlebrownShorttermBrackets
04:09:56 <Athas> merijn: I can send you a hundred Futhark-branded pens you can hand out at conferences (and keep one for yourself as commission).
04:11:00 <cocreature> Athas: I think the cool kids these days want stickers, not pens :)
04:12:24 <Athas> Or cups!
04:13:00 <merijn> Futhark branded booze would work... :p
04:13:43 <cocreature> if you get people sufficiently drunk they might also stop asking hard questions at your conference talk :)
04:14:21 <merijn> If your results are messy and complicated enough you don't ever get accepted in main tracks and won't have to worry about that! :p
04:14:30 * merijn sobs in pile of negative results
04:28:38 <pong> hey guys I'm doing a problem that requires counting recursion depth of (unbalanced) binary tree inserts
04:28:45 <pong> is this form of recursion: let (d, l') = insert a (c+1,l) in (d, Node x l' r) suboptimal?
04:31:00 <pong> honestly I think the most expressive way to do this is with a side effect so nvm
04:38:56 <lin__> what does &= mean or do?
04:39:23 <dminuoso> lin__: That depends on what your library defines that operator to be.
04:48:36 * hackage summoner 1.0.6 - Tool for creating completely configured production Haskell projects.  http://hackage.haskell.org/package/summoner-1.0.6 (shersh)
04:50:21 <merijn> lin__: It's an operator defined in cmdargs
04:55:31 <c50a326> hey I just customized the new-template stack template (added some packages that I usually always need). Where do I put the hsfiles file so that `stack new` will know it?
04:55:47 <c50a326> or maybe `stack new PATH-to-hsfiles-file` is correct...
04:56:02 <c50a326> and with the project name ofc
04:56:29 <c50a326> ah yeah I can use a local template file path it looks like, nvm
05:31:45 <tombusby> hey, I'm refreshing my Haskell skills atm, working through Learn You a Haskell
05:32:00 <tombusby> I'm wondering if there's a more modern tutorial people would recommend instead, or if it's still solid
05:32:24 <tombusby> cos I first learned Haskell nearly 9 years ago now, and haven't written a huge amount of it since about 2014
05:37:00 <merijn> tombusby: tbh, LYAH is mostly obsolete. It's a neat intro, but pedagogically it's not very solid and doesn't really have any exercises
05:37:15 <tombusby> can you recommend anything else?
05:37:56 <merijn> tombusby: Common recommendations are: the CIS194 course, the "Haskell From First Principles" book (it's a bit expensive and I don't 100% agree with the explanation order, but it's the closest thing to "comprehensive" I'm aware off)
05:38:21 <tombusby> hmm ok, thanks
05:38:47 <merijn> tombusby: Then there's the Bird's "Intro to Functional Programming in Haskell" which is a nice intro to FP and Haskell, but doesn't cover as much crucial ecosystem bits, unlike the From First Principles book
05:39:55 <tombusby> could you elaborate on what you mean by "crucial ecosystem bits"? (thx for the responses btW)
05:40:49 <merijn> tombusby: There's a bunch of libraries that aren't part of haskell, but widely used and therefore basically mandatory knowledge for writing "real world" haskell (such as the transformers library)
05:40:49 <__monty__> I've heard at least as many negative as positive comments about HFFP so I suggest you try before you buy.
05:41:13 <tombusby> Yeah, I see there's some free chapters available
05:41:35 <tombusby> __monty__: do you have any opinions about up-to-date learning materials? I'm just having a look over CIS194 atm
05:41:48 <tombusby> I'm assuming this is what's referred to: http://www.seas.upenn.edu/~cis194/fall16/
05:42:14 <merijn> __monty__: My experience is mostly my SO working through it with minimal supervision from me. It has flaws (order of explanation is sometimes illogical, exercises sometimes have somewhat unclear definitions, etc.) but overall it's one of the most comprehensive and least wrong intro's I've seen
05:42:16 <__monty__> tombusby: No, I've resigned to the tried and true method of learning by doing.
05:43:06 <merijn> tombusby: You say you looked into things 9 years ago, so depending on how much you got then, you could try the "Gentle" Introduction too
05:43:25 <merijn> @quote Brend gentle.intro
05:43:25 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
05:43:32 <merijn> @where gentle
05:43:32 <lambdabot> http://www.haskell.org/tutorial/
05:43:34 <tombusby> I wrote a C (subset) Compiler in Haskell for my uni dissertation so I do have a fair bit of experience by doing, I'm hoping to refresh and get a solid thoeretical grounding too
05:43:56 <merijn> tombusby: Okay, the gentle intro might be the best starting point
05:44:16 <merijn> tombusby: It was written as a refresher/intro on Haskell syntax and definitions for people coming from SML or other ML-style functional languages
05:44:39 <merijn> tombusby: So if you've written substantial haskell before, then a "quick and brutal" refresher might be more useful
05:44:40 <tombusby> ok awesome. Does it go over patterns like Functors/Monads etc
05:45:11 <merijn> tombusby: Not entirely sure, Typeclassopedia is good for that, though
05:45:12 <tombusby> ah yes, I see a Monad chapter
05:45:17 <tombusby> ok
05:45:53 <__monty__> My impression of HFFP is that it's too focused on beginners. But then goes pretty deep into the weeds in later chapters. Trying to be too many things but I could just be wrong, I haven't actually read it. And I won't since information should be free in all sense of the word.
05:46:17 <tombusby> __monty__: +!
05:46:21 <tombusby> * +1
05:47:06 <merijn> __monty__: I actually think it's a bit confused about who it's focussed at
05:47:27 <merijn> __monty__: It claims to be accessible to non-programmers, but then spend a lots of time doing fiddly things with lists very early in
05:47:38 <merijn> __monty__: Which, for non-programmers, feels completely useless
05:47:40 <tombusby> merijn: out of curiosity, what is it that makes LYAH obsolete?
05:48:03 <tombusby> cos knowing that might be useful, cos the obsolete stuff is probably currenty in my brain as old knowledge
05:48:40 <__monty__> tombusby: Just the quality of the exposition.
05:48:45 <merijn> tombusby: Some things have changed in the standard library since it was written, it has no exercises, the order of explanation is very logical in terms of pedagogy, and generally it shows cool things, but doesn't provide people with the tools whether they learned the right thing from those examples
05:49:04 <merijn> tombusby: So it's not necessarily *wrong*, it's just not as helpful as it could be as teaching aid
05:49:16 <tombusby> merijn: got it, thanks
05:50:17 <merijn> tombusby: Especially as a refresher it might still be plenty useful, because you see things and go "oh, yeah, now I remember". But if you see them the first time you don't get the "oh yeah"
05:52:46 <tombusby> ok, I'll have a dig around and see which feels like it has the best fit
05:52:59 <tombusby> thanks to both of you for the help
06:04:35 <joehh> In related matters, how do people find the haskell book (http://haskellbook.com)? particularly for teaching
06:04:48 <joehh> someone with prior c/c++ programming skills
06:05:00 <dminuoso> joehh: It depends on your aptitude and general skill really.
06:05:12 <dminuoso> haskellbook is rather entry-level focused, even on a general programming scale
06:08:03 <joehh> I have an student starting later this week and need to get them quickly up to speed with haskell
06:08:31 <joehh> my plan is to give/present them the problems I want them to solve and also get them started with something like
06:09:07 <dminuoso> @where cis194
06:09:07 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
06:09:10 <dminuoso> joehh: This might be a great start.
06:09:15 <joehh> either https://github.com/data61/fp-course or cis194
06:09:40 <joehh> and then keep in touch reflecting on the course progress with the problems I need them to solve
06:09:45 <joehh> is that a sound approach?
06:11:27 <quchen> joehh: Sounds good to me. In my experience, learning Haskell with someone closely helping you is fairly fast and rewarding for both parties.
06:11:57 <quchen> Most time learning Haskell is spent going down the wrong alleys, and a mentor takes that part away.
06:12:07 <joehh> dminuoso: thanks for that - I'll have a good look over it
06:13:35 <ph88> so i wanted show with text, i found this package https://hackage.haskell.org/package/text-show-3.7.4/docs/TextShow.html but is it possible to derive it for my data types ?
06:14:09 <jml> ocharles_: do you have any concrete plans around a prometheus-client release? I've got a bit more time this week so could do the grunt work.
06:16:20 <joehh> thanks quchen, I think/hope you are right. functional approach is natural for me (started learning haskell in 99), hoping to be able to quickly get someone new up to speed
06:17:04 <ocharles_> jml: I think we're all good to go
06:17:09 <ocharles_> jml: unless there's anything you can think of?
06:17:17 <ocharles_> it's just been busy this weekend as it's my birthday today :)
06:17:57 <jml> ocharles_: oh, happy birthday!
06:18:15 <__monty__> Ne gelukkige, ocharles_!
06:18:38 <jml> ocharles_: to be clear, I'm not asking you to get a move on! I'm just on a family vacation this week and have slightly more free time for FOSS stuff.
06:18:47 <ocharles_> haha, that's fine - I *do* need to get a move on!
06:18:55 <ocharles_> would be great if you could take a look at prometheus-proc
06:19:03 <jml> ocharles_: got a url?
06:19:05 <ocharles_> that doesn't need to coincide with a release though, just a nice to have
06:19:11 <jml> oh, actually making it :)
06:19:14 <ocharles_> yea :)
06:19:29 <ocharles_> i found myself wanting process_start_time last week
06:19:31 <jml> I'll see what I can do.
06:19:53 <jml> I'd like to look into reducing the number of `unsafePerformIO` in prometheus-client at some point
06:19:55 <ocharles_> i still can't decide if it should be in the main library or not. The prometheus.io docs kinda suggest it (rfc) should be in the main lib
06:20:07 <ocharles_> yea, that's actually hurting me atm as well - as counters don't get registered at 0
06:20:47 <ph88> is there ++ for text ?
06:20:54 <jml> `(<>)`
06:21:22 <ocharles_> and thanks, __monty__ and jml :)
06:21:23 <ph88> thx jml
06:21:37 * hackage avro 0.3.3.0 - Avro serialization support for Haskell  http://hackage.haskell.org/package/avro-0.3.3.0 (alexeyraga)
06:21:57 <jml> ocharles_: I personally would put it in the main lib. I don't think lack of Windows support will materially affect any sentient creature in this system.
06:22:12 <ocharles_> fair enough. do you want to take a stab at that?
06:22:19 <jml> sure.
06:22:32 <ocharles_> i think it's best too, it's lightweight and start_time at least is a very useful metric you don't want to forget to add
06:27:39 * jml finishes instrumenting this thing
06:29:46 <dminuoso> Does anyone know whether the `ip` interface in Linux has some alternative format that is more machine readable like perhaps JSON?
06:29:59 <unsymbol> found out i'm not going to be able to attend this year's haskell exchange in london and i'm selling my ticket for cheap. pm me if you want to buy it.
06:30:50 <cocreature> dminuoso: grep for json in the manpage :)
06:31:45 <dminuoso> cocreature: That sounds suspiciously like your `ip` tool has something listed there..
06:32:04 <[exa]> dminuoso: which version do you have?
06:32:18 <dminuoso> ipruote2-ss161212
06:32:21 <dminuoso> iproute2-ss161212
06:32:33 <[exa]> iproute2-ss180608 has the -json option
06:32:46 <dminuoso> Ah.. alright. Ill see if I can use an unstable version. Thank you very much :)
06:32:56 <[exa]> you're on debian right? :]
06:32:58 <dminuoso> Yeah
06:33:21 <[exa]> testing versions are perfectly stable
06:35:56 <[exa]> dminuoso: the version from stretch-backports looks like it should have the -json already
06:37:05 <jml> `observeDuration` has its parameters the wrong way around
06:37:11 <[exa]> unwanted side observation: debian `ip` has the moo feature
06:37:30 <ocharles_> jml: I thought that was fixed in HEAD?
06:37:41 <ocharles_> metric first, thing to measure next
06:37:57 <cocreature> [exa]: who needs json output if you can have moo output
06:38:17 <jml> ocharles_: it is! wonderful.
06:38:36 <jml> I guess I should depend on HEAD. /me goes off to figure out the right stack incantation
06:38:46 <[exa]> cocreature: it can't output the moo in json though :(
06:38:59 <cocreature> [exa]: but can it output the json in moos
06:42:31 <jml> hmm, I want to use the return value in a label anyway.
06:43:31 * [exa] suggests using cowsay to teach debian users about pfannkuchen --- https://pastebin.com/raw/tEq0gGMY
07:03:14 <dminuoso> [exa], cocreature: Thank you this is great. :)
07:12:28 <c50a326> hey does anyone know how to go to the bottom of the completion suggestions list provided by intero in emacs?
07:14:42 <c50a326> ah I think I need to look at the company binds
07:15:48 <c50a326> yeah here we go https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Bcompletion/auto-completion#key-bindings-1 nvm
07:16:41 <c50a326> damn, my C-k is buggered though D:
07:19:29 <ph88> what is a good random source here ? https://hackage.haskell.org/package/random-source
07:27:06 <ph88> how can i do  "runRVar (uniform 1 100) DevRandom :: IO Int"  https://hackage.haskell.org/package/random-fu-0.2.7.0/docs/Data-Random-RVar.html   with this random source ?  https://hackage.haskell.org/package/random-source-0.3.0.6/docs/Data-Random-Source-IO.html
07:27:07 <XtraKrispi> hey, I was wondering if anyone can point me in the right direction regarding a custom authLayout for Yesod?  I can't find any examples of one and copying defaultLayout into it as a starting point doesn't work
07:30:04 <lavalike> ph88: I think you simply import the module
07:33:40 <lavalike> ph88: a possible way to figure it out is looking into packages that use it, e.g. http://packdeps.haskellers.com/reverse/random-fu
07:34:36 <pepijndevos> Greetings enlightned beeings. I come to you in search of wisdom regarding the M word, in the hope that its powers may shine down on me and guide me in expressing something in a language with an inferior type system (Go).
07:37:23 <liste> pepijndevos: what's the something?
07:37:38 <pepijndevos> I'm writinga behavior tree, which is basically a bunch of nodes getting executed in turn, returning a status. But these nodes currently do things such as mutate global state and perform IO. So I'm looking for a way to express these nodes as somewhat more pure functions. I figured y'all probably just have a monad for that, saving me some work reinventing wheels and all that.
07:38:35 <liste> pepijndevos: function from state to state and a list of actions
07:41:49 <pepijndevos> Yea, something like that...
07:42:15 <nshepperd1> ph88: normally i just use 'sample rvar' in IO, which is the same as 'runRVar rvar StdRandom'
07:42:54 <nshepperd1> It uses whatever is the default random source in IO
07:43:28 <pepijndevos> I'd also like to have a way to pass values from one node to the next. If everyone just puts their crap in the return state, that's basically your global state now.
07:45:01 <lavalike> pepijndevos: I know there is a neat way to have a container of monads that would make it quite comfortable to express that, I forget the name of the thing hmmm
07:46:01 <pepijndevos> So I'm thinking if your "list of actions" are basically messages to something to do something, you could pass that around to the next node, so they can pop their messages and append more.
07:47:00 <lavalike> pepijndevos: free monad is the contruction I was thinking of
07:47:08 <pepijndevos> Googling...
07:49:32 <lavalike> pepijndevos: if I understand correctly the shape of a free monad is basically the same as an Haskell list where the elements are monadic actions, you were thinking of trees of monadic actions, so what you'll find might not be immediately applicable
07:52:58 <lavalike> pepijndevos: or actually it might map very well, the first paragraphs here make me hopeful: http://clathomasprime.github.io/hask/freeDecision.html
07:53:50 <pepijndevos> lavalike, it actually sounds like exactly what I want. From what I'm reading there is an AST or operations (my tree?) and an "interpreter" to give meaning to it.
07:53:56 <lavalike> exactly
07:54:23 <lavalike> I forgot that the shape of 'f' in 'Free f a' lets one make things that aren't shaped like lists
07:54:31 <luis3m> http://qr.ae/TUIFrE, yes free monad is quite similar to lists
07:55:22 <lavalike> lovely
07:55:28 <pepijndevos> So step 1, try to understand what this is, step 2, hope a (weakedend/concrete) version is somehow possible in Go.
07:55:50 <lavalike> oh I didn't get that you were doing it in Go, I thought you were porting it from Go
08:03:17 <Gurkenglas> So apparently file paths need to be short in order for Windows to build some things using stack. stack appears to be confused after I moved the github repository? https://gist.github.com/Gurkenglas/f8724d232d8e8db7a7a538122cac9a9f
08:03:27 <madknight> what's the recommended way for optional function parameters (with defaults) in 2018?
08:05:13 <tdammers> madknight: depends, but generally I like records best
08:06:06 <ph88> i'm picking one random element from a list .. after i need to element removed from the list. Is there a function for this? Or should i search the element i picked first ?
08:06:07 * hackage hasql 1.3.0.3 - An efficient PostgreSQL driver and a flexible mapping API  http://hackage.haskell.org/package/hasql-1.3.0.3 (NikitaVolkov)
08:06:07 <tdammers> foo :: FooParams -> Blah; foo defFooParams { someParam = value; someOtherParam = othervalue } -- this kind of pattern
08:06:07 <Gurkenglas> madknight, one way I can think of if there's a lot of function parameters is to have a parameter record Params and to have your function have type "(Params -> Params) -> a"
08:07:03 <Gurkenglas> And then supplying id uses the default, and (\s -> s { someParam = value }) changes one parameter, or if they're using lens you can write that (someParam .~ value)
08:07:54 <tdammers> another option is to take a list of params, which are exposed through some opaque data type
08:08:24 <tdammers> foo :: [FooParam] -> Blah; foo [ SomeParam value, SomeOtherParam othervalue ]
08:10:51 <Gurkenglas> "translate :: [FooParam] -> (Param -> Param); translate = foldr (.) id . \case SomeParam value -> someParam .~ value; SomeOtherParam othervalue -> someOtherParam .~ othervalue" but you can't go the other way. Param -> Param makes clear that the function can't possibly care about things like the order of that list
08:11:29 <Gurkenglas> (um, map missing in there)
08:12:23 <Gurkenglas> translate = foldr (.) id . map (fooParam (someParam .~) (someOtherParam .~))
08:12:37 <Gurkenglas> (using that cata deriving library)
08:13:13 <Gurkenglas> And in the end you're gonna have to apply translate anyway to use it, might as well let the user supply it directly
08:14:21 <ph88> what's the function to apply a function X times ?
08:14:33 <Gurkenglas> ph88, foldr (.) id . replicate n
08:14:36 <Gurkenglas> -n+X
08:14:53 <Gurkenglas> (though you're gonna have a bad time with uppercase variables)
08:15:05 <ph88> is there a function in base for this ?
08:15:25 <Gurkenglas> ph88, all of those are in base, and pretty sure it doesn't have an alias
08:15:32 <ph88> wow really
08:15:46 <Gurkenglas> :t until -- that would be the closest one-word thing in base
08:15:47 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
08:15:49 <nshepperd> myfunction (option1 "foo" <> option2 17 <> option3 (\x -> print x))
08:16:39 <Gurkenglas> (I suppose translate is optional after all if you keep doing `elem` on the list to check the parameters...)
08:16:46 <nshepperd> iterate f x !! n
08:17:16 <lavalike> good one
08:18:12 <Gurkenglas> nshepperd, isn't option1 just (Endo . (param1 .~))?
08:20:00 <Gurkenglas> Hmm, you don't need to export a record if myfunction's first argument has implicit parameters
08:20:12 <nshepperd> sure, but with racing stripes
08:20:47 <lavalike> :t ((!!) .) . iterate
08:20:48 <lambdabot> (a -> a) -> a -> Int -> a
08:21:15 <Gurkenglas> I suppose it makes clear that you can only replace the default parameters, not use them in calculating the new one
08:21:21 <Gurkenglas> if that's a thing you want
08:21:30 <Gurkenglas> But that sounds less resilient to api changes
08:22:43 <ph88> would this code be nicer if i made Player a record ?  https://bpaste.net/show/dc7f7b159b48
08:23:42 <Gurkenglas> ph88, at first glance, consider making the [Block] the last argument so you can get rid of the lambda
08:24:29 <ph88> in other parts of the code i have something else to update than blocks
08:25:16 <Gurkenglas> ph88, records allow you to go the lens route
08:25:56 <Gurkenglas> Now why does that >>= have [Block] to the left and P to the right?
08:26:08 <mniip> hmm
08:26:36 <mniip> there's this widely used notion that I don't see specified anywhere
08:26:52 <Gurkenglas> (though with intermediate lens magic you don't even need records)
08:27:00 <mniip> of what it means for inference rules involving judgments to be "syntax directed"
08:32:12 <Gurkenglas> ph88, with lens that would have looked like updatePlayer :: Turn -> Player -> Player; updatePlayer (Play mc@(Upgrade amount)) = (blocks %~ (foldr (.) id $ replicate amount upgrade_blocks)) . (mcards %~ delete mc)
08:32:51 <Gurkenglas> ph88, though presumably wherever you match Play you delete the card, so actually:
08:33:09 <orbisvicis> dmwit: sorry, weird things happen to me on the weekend, got delayed. Anyway I was referring to 'f[k+1](n) = ... f[k](n)' for n only, before the article introduced functionals. Anyway my point/question is that the article's use of next/previous is counter-intuitive to operational semantics. So as an exercise I redid their example given f(n) = f(n+1) but b/c of the use of colloquial next/prev I switched
08:33:15 <orbisvicis> the call order, i.e f[k+1] = f[k](n-1). I assume this is completely wrong - and it isn't a mistake that's possible to make with factorial, I think.
08:34:00 <Gurkenglas> updatePlayer :: Turn -> Player -> Player; updatePlayer (Play mc) = (mcards %~ delete mc) . case mc of Upgrade amount -> blocks %~ foldr (.) id (replicate amount upgrade_blocks)
08:34:47 <Gurkenglas> (and I guess you'll need the IO elsewhere - then you just put another "return ." at the front)
08:36:24 <Gurkenglas> And then there's that blog post on getting rid of the Turn record entirely if you just define it once and consume it here. Is that compatible with JSON stuff for networking?
08:37:32 <Gurkenglas> It all comes back to whether there's some arcane way to get Show (Int -> Int)
08:37:54 <Gurkenglas> which only obeys reflective transparency in that read . show == id
08:38:31 <Gurkenglas> Wait, "reflective transparency" might be a vocalubary misfire.
08:39:13 <Gurkenglas> What was the one that said "if x equals y, then for all f: f x equals f y"?
08:39:58 <mniip> Gurkenglas, I don't think there's such a term
08:41:20 <Gurkenglas> Anyway, ph88: iterate doesn't do IO. You ought to write "= P id (delete mc mcards) scards (iterate upgrade_blocks blocks !! amount) pcards coins"
08:42:12 <ph88> Gurkenglas, upgrade_blocks does IO
08:42:19 <ph88> i still need to make this code compile ..
08:42:43 <Gurkenglas> ph88, iterate takes a function of form (a -> a)
08:43:24 <Gurkenglas> "foldr (>=>) return . replicate amount" will do the monadic version of applying a function amount times
08:44:09 <Gurkenglas> so will "iterate (>>= update_blocks) blocks !! amount"
08:44:51 <Gurkenglas> If it's hard to see how to plug in function and argument in the foldr thing: "foldr (>=>) return (replicate amount update_blocks) blocks"
08:45:04 <Gurkenglas> Oops: "iterate (>>= update_blocks) (return blocks) !! amount"
08:46:37 <ph88> i think i want actually want to extract that into a separate function :P
08:47:04 <Gurkenglas> :(
08:47:33 <ph88> timesIO f a n = iterate (>>= f) (pure a) !! n
08:47:38 <ph88> it's good !
08:47:43 <ph88> i took your code and put it into a function
08:48:52 <Gurkenglas> It's a fix on the other guy's code, I like mine more :x
08:49:48 <ph88> with foldr ?
08:50:16 <Gurkenglas> yep :V "timesM n f x = foldr (>=>) pure (replicate n f) x", or "timesM n = foldr (>=>) pure . replicate n", or if .: existed as I want it to, "timesM = foldr (>=>) pure .: replicate"
08:52:28 <ph88> it's more difficult for me to understand what's going on there by reading the code
08:52:35 <ph88> for example i'm not familiar with >=>
08:53:44 <machined1od> Hi all. I have a question related to category theory, but I'm really looking at it through software dev lenses, so I figure its appropriate to ask here; could someone point me to some resource that could explain to me why is the identity morphism so important?
08:54:04 <ph88> now i need a function where input list is [1,2,3,4,1,2,3] and i give for example [1,2] and i need to know how many times i can take [1,2] out of the input list (which is two times here)
08:56:39 <agentultra> I love teaching people Haskell and seeing their eyes light up when they grok a new concept. Training a co-worker and having a blast. Haskell is the best.
08:56:39 <[exa]> ph88: so "how many subsequences are there that are equal to [1,2]"?
08:56:45 <ph88> machined1od, in my own words: so when you have a morphism (function) and let's say the user can choose to perform an action (this function) or not .. then in the case of not you can use the identify function .. So i would say that it's pretty stupid from one thing to change to itself, but it's very handy in code sometimes to be able to do this
08:56:58 <ph88> [exa], the order of [1,2] doesn't matter
08:57:05 <ph88> [2,1] is also valid here
08:57:28 <[exa]> what is the result with [1,2] taken from list [1,1,2] ?
08:57:35 <ph88> [1]
08:57:47 <[exa]> [1] or 1 ?
08:57:50 <ph88> [1]
08:58:04 <[exa]> why in a list?
08:58:36 <ph88> because the player has 0, 1 or more items .. so a list is good in case there are more items
08:58:53 <quicksilver> [exa]: you mean substring not subsequence
08:58:56 <ph88> [1,2,3,4,5] take [4,3] -> [1,2,5]
08:59:06 <machined1od> ph88: Yeah I've been in situations often where `id` came in handy (eg. using `maybe` instead of `fromMaybe`), but it seems that its so important that its embedded as a property of the category itself. While I understand the need for all other category properties (that ensure composition), I really don't understand how `id` fits in there with the same level of importance.
08:59:21 <quicksilver> if it had been subsequence the answer would be 3
08:59:53 <[exa]> ph88: you wrote in that you'd be interested in how many times you can take that out :]
09:01:51 <ph88> machined1od, i don't think it's important for any other reason than to be able to formally say: we can have a thing, and when we want the same thing we can apply the identity morphism. Maybe think if it that you can not have the thing directly but you MUST apply a morphism (function) to get a result .. in this case identity function is the only one that you can use.
09:02:27 <monoidal> machined1od: one of the most basic things in category theory is isomorphism - when to consider two things as 'similar'. To define isomorphism you need identity
09:02:28 <ph88> [exa], yes first i want to know how many times i can take them out ... then i want to randomly pick a number from 1 to n. then i actually want to take them out so many times
09:03:06 * hackage distribution-opensuse 1.1.1 - Types, functions, and tools to manipulate the openSUSE distribution  http://hackage.haskell.org/package/distribution-opensuse-1.1.1 (PeterSimons)
09:03:34 <ph88> monoidal, are you sure? i thought with isomorphism the type can change but with identity it can not change ?
09:04:14 <monoidal> ph88: an isomorphism between A and B are two functions f,g such that f.g and g.f are identities
09:04:29 <monoidal> ph88: therefore you cannot talk about isomorphisms if you don't have identities
09:04:37 <nshepperd> to write f.g = id && g.f = id you need id
09:06:01 <machined1od> ph88 and monoidal:  thanks, it makes a bit more sense now. At least I know where to look now for deeper explanation (isomorphisms) :-)
09:06:06 * hackage deferred-folds 0.6.4 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.6.4 (NikitaVolkov)
09:07:13 <ph88> machined1od, i find it also confusing sometimes about the practical use of it and just to be able to say that formally something must exist (where practically you are like d00h, it's implicit)
09:07:37 * hackage deferred-folds 0.6.5 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.6.5 (NikitaVolkov)
09:07:53 <machined1od> I actually understood the thing with what nshepperd wrote! If you don't have id, you don't have means to compare compositions!
09:08:19 <ph88> compare ? as in equality ?
09:08:38 <ph88> but   f . g = g . f   don't need id here
09:09:14 <ph88> ups that's not true i think
09:09:18 <ph88> scrap that
09:09:24 <ph88> starting point is different ^____^
09:09:34 <machined1od> Correct, but I am assuming (maybe wrongly) that there might be equalities where you need the presence of id to be able to write it
09:09:34 <monoidal> if f,g : A -> A, that's true
09:10:12 <nshepperd> machined1od: i would say that you need id to make sense of statements like 'f is the inverse of g'
09:10:18 <bwe> Data structures: How do I store data values of differing type to let them form a collection to compare with another such a collection? https://repl.it/repls/SaddlebrownShorttermBrackets
09:10:49 <machined1od> nshepperd: right, great example!
09:11:13 <bwe> In other words: I search for an alternative for list type and record syntax.
09:12:39 <bwe> Which comprehensive showcase collection of data structures in Haskell do you recommend?
09:12:42 <ph88> [exa], that's not such a trivial function actually !
09:12:59 <[exa]> ph88: working on it just out of curiosity
09:14:07 <Gurkenglas> ph88, I think for your [a], Map a Int would be a better fit
09:17:37 <Gurkenglas> ph88, delete would be O(log n) instead of O(n), and the function Map a Int -> [a] -> Int you described would be \m as -> minimum $ map (\a -> findWithDefault 0 a m) as
09:18:33 <ph88> Gurkenglas, thx
09:20:53 <[exa]> ph88: ask if you'd want to see my result
09:21:13 <[exa]> it's a nice list-functions exercise
09:23:01 <ph88> [exa], i have this so far https://bpaste.net/show/8162e6347d56
09:23:27 <ph88> maxTimes = floor $ min frequency
09:23:45 <[exa]> are you targeting optimal time efficiency?
09:23:49 <ph88> no
09:24:04 <ph88> i'm just targeting code that compiles xD
09:24:57 <[exa]> well, first write a function that takes the bag and items, and returns either Just (newbag) if the items can be taken out, or Nothing if not
09:25:00 <albeit> If a thread launches a child thread with forkIO/forkFinally, and the parent thread completes, is the child thread killed immediately or does it keep running?
09:25:16 <[exa]> given that you can easily recurse and produce a full list of all possibilities
09:25:48 <c_wraith> albeit: with forkIO, threads are independent of their parents.  With the exception of the main thread.  If that one ends, the program stops.
09:25:48 <albeit> Actually sorry, should have googled, found answer on stack overflow.
09:25:55 <[exa]> related -- is there some nice shortcut for (map fromJust . takeWhile isJust) ?
09:26:03 <albeit> c_wraith: Perfect, confirms, thanks.
09:26:54 <ph88> [exa], ah you want to take them out once and then try to take them out more times ..
09:27:35 <[exa]> ph88: if you'd represent the bag as pairs (item,count), the counting implementation would probably be better
09:27:57 <[exa]> ph88: but let's try without numbers :]
09:37:10 <ph88> [exa], i came this far https://bpaste.net/show/ffaf57310ecf but i have to go now .. see you later
09:39:32 <[exa]> ph88: ok
09:43:55 <dataN> lavalike: Free cant be used to make List, thats CoFree
09:44:19 <dataN> CoFree Maybe...
09:45:08 <dataN> which does not have Empty...
09:51:08 <lavalike> dataN: luis3m's link exemplifies the parallel with lists quite clearly
09:57:59 <dataN> no. this is not helpful. its misleading to equate the two concepts, as list *cant* be defined using Free.
09:59:54 <dataN> see; https://mail.haskell.org/pipermail/haskell-cafe/2017-January/126026.html
10:03:26 <dataN> which actully does not seem to be very clear.. but anyway, its a confusing notion to perpetuate.
10:06:17 <lavalike> dataN: is the point that you can't make the equivalent shape of a 0 and 1 element list with a Free f a value?
10:08:33 <albeit> If I wait a child thread to automatically cancel when the parent thread dies, does it make sense to use the async package, or just track the child threadId and send a cancel to it when the parent dies?
10:09:10 <albeit> The async package seems to be more focused on waiting for things to complete, but I need both parent and child (and child's children) to run concurrently until any dies.
10:09:40 <cocreature> albeit: have you seen the "concurrently" function in async?
10:09:50 <glguy> Maybe look at http://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html#g:8
10:09:51 <lavalike> dataN: oooh I see, I wasn't saying that it behaves like a list, as in the list monad! Just that the values of type Free f a have the shape of a list.
10:10:25 <cocreature> I definitely wouldn’t recommend reinventing parts of async, it’s fairly easy to get things wrong here
10:12:40 <tieTYT> Just finished LYAH.  if I want to use something on hackage, should I learn how to use cabal?
10:13:46 <zachk> tieTYT, cabal update ; cabal install package_name
10:14:03 <tieTYT> k thanks
10:14:13 <zachk> if you are just starting use the haskell platform it comes with ghc and cabal installed
10:14:14 <glguy> There's a "Quick Start" section: https://www.haskell.org/cabal/users-guide/developing-packages.html
10:14:21 <albeit> I guess I'm struggling with whether I ever use forkIO/forkFinally in async. I have a thread running, and it launches a child thread at some point that should die when the parent dies. Do I use something like "forkIO . wait . async $ childAction"?
10:14:43 <albeit> Because if the parent thread just calls "wait . async $ childAction" it will have to wait for the child to finish
10:15:12 <albeit> And with concurrently, I don't know what the two actions I would be calling are. One would be the child thread, but what is the other?
10:15:18 <glguy> albeit: Look at link/link2 as previously mentioned
10:15:23 <glguy> or at withAsync
10:15:39 <glguy> it'll depend on what you're actually doing
10:16:49 <cocreature> wait . async doesn’t really make sense. why are you spawning a new thread if you are waiting immediately
10:17:36 * hackage quickcheck-classes 0.4.14 - QuickCheck common typeclasses  http://hackage.haskell.org/package/quickcheck-classes-0.4.14 (andrewthad)
10:17:38 <glguy> the only thing that comes to mind is to get the work outside of a bound thread (which probably isn't what's happening here)
10:18:04 <albeit> I don't want to be waiting immediately... I'm basically just launching a socket and reading from it, but the parent thread/actions need to continue to run
10:18:16 <cocreature> maybe you are looking for "withAsync"?
10:18:33 <madknight> > maximum [10..1]
10:18:34 <astronavt> is there a way to add contextual information into a monad? like i have some computation, but instead of returning just Maybe can i also attach a "failure reason" if it returns None?
10:18:35 <lambdabot>  *Exception: Prelude.maximum: empty list
10:18:49 <cocreature> > maximum [10,9..1] -- madknight
10:18:52 <lambdabot>  10
10:18:52 <[exa]> astronavt: ExceptT?
10:19:15 <albeit> Could be... but what does does the second argument need to do in withAsync?
10:19:17 <astronavt> [exa] perfect thank you
10:19:34 <madknight> cocreature, ah thx
10:19:43 <glguy> cocreature: I already suggested link, link2, or withAsync, but albeit doesn't seem interested in those
10:19:55 <zachk> astronavt, if you want a failure reason use Left from Either
10:20:00 <cocreature> albeit: the second argument is the code that should be running concurrently with the new thread
10:20:03 <albeit> glguy: I am! I just don't know hwo to use them
10:20:07 * hackage pipes-async 0.1.3 - A higher-level interface to using concurrency with pipes  http://hackage.haskell.org/package/pipes-async-0.1.3 (JohnWiegley)
10:20:13 <cocreature> then ask specific questions!
10:20:27 <[exa]> astronavt: also, Either works like that if you'd only need applicatives
10:20:32 <albeit> I am trying, let me think of how to rephrase
10:20:36 <Mitsos101> hello everyone! I have a list of size s, and another bigger list, let's call them xs1 and xs2. I want to do (zipWith f xs1 xs2), combining the sublist [start, start + s) of xs2 with xs1, while leaving the remaining elements unchanged. What's the best way to do this?
10:21:03 <[exa]> astronavt: (ok also with monad)
10:21:42 <zachk> Mitsos101, maybe look at the source for zipWith and code your own version of it,
10:21:50 <zachk> :t zipWith
10:21:52 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
10:21:54 <astronavt> [exa] thanks im still wrapping my head around use cases for applicatives
10:22:13 <glguy> Mitsos101: You can write the recursion out manually, or use a package like: https://hackage.haskell.org/package/these-0.7.4/docs/Data-Align.html#v:alignWith
10:22:15 <zachk> Mitsos101, though it would have to be something like (a -> a -> a) -> [a] -> [a] -> [a]
10:22:18 <[exa]> Mitsos101: you can append infinite no-op values to the shorter list, if you don't mind extra calls of 'f'
10:22:36 * hackage pushme 2.1.3 - Tool to synchronize directories with rsync, zfs or git-annex  http://hackage.haskell.org/package/pushme-2.1.3 (JohnWiegley)
10:22:42 <albeit> I am effectively looking to do "forkFinally finalAction runChild" but in a way to make sure that child thread dies when the calling thread dies.
10:23:00 <hth313> Has anyone a cabal sandbox with an updated bytestring library (add-source) using GHC 8.4.3 that can get it to work (on Linux)?
10:23:02 <Mitsos101> [exa]: I thought of this, but it doesn't seem like an attractive solution at all
10:23:46 <Mitsos101> requiring f to have an identity element seems like a pretty bad idea
10:23:51 <albeit> In withAsync, the code to run concurrently is just the continuation of the parent thread, so its not really a specific action.
10:24:30 <albeit> I guess with link, I would do something like "link $ async chidAction"?
10:24:37 * hackage pipes-files 0.1.3 - Fast traversal of directory trees using pipes  http://hackage.haskell.org/package/pipes-files-0.1.3 (JohnWiegley)
10:24:59 <monoidal> Mitsos101: you can map the list to maybes and use Nothing as the identity element
10:25:43 <albeit> But then the link'ed async doesn't have automatic cancellation as far I can tell
10:25:45 <glguy> albeit: That would kill the parent if the child died
10:26:54 <monoidal> > zipWith (\x y -> maybe y (y+) x) (map Just [1,2] ++ repeat Nothing) [10,20,30,40] -- Mitsos101
10:26:55 <[exa]> Mitsos101: if you'd want to avoid having own zipWith then  decorating the shorter list with Just/Nothing could make it a bit cleaner; apply function would be roughly (\a b-> f a <$> b), extraction could be takeWhile isJust
10:26:56 <lambdabot>  [11,22,30,40]
10:27:25 <[exa]> yeah that's it. :]
10:27:40 <albeit> glguy: So I could wrap "link $ async childAction" with an exception handler, but will the chidAction thread also stop if the parent dies?
10:27:46 <glguy> Figuring out which list is shorter ahead of time seems wasteful
10:28:06 <glguy> albeit: no. that would either need link2 or better would be to run the child with withAsync
10:28:07 <Mitsos101> monoidal: hmm, I see. and I just replicate Nothing if I want to do this on a sublist?
10:28:15 <[exa]> glguy: you need to know that for its type needs to match the result
10:28:58 <glguy> [exa]: The type already has to match if we're going to support either of the two lists being shorter
10:29:59 <[exa]> well I wanted to be more general in the other way :] nevermind
10:31:05 <glguy> The alignWith function I linked to above is quite general
10:31:05 <monoidal> Mitsos101: I don't understand the question
10:33:53 <Mitsos101> monoidal: If I wanted to zip the smaller list with the sublist [start, start + (length xs)] of the larger list, I would just do (replicate start Nothing ++ map Just [1, 2] ++ replicate (length xs - start - (length [1, 2])) instead, right?
10:34:59 <albeit> glguy: But how do I run the child with something like "do; withAsync childAction otherAction; restOfParent" if the function to run concurrently (otherAction) is just restOfParent?
10:35:16 <monoidal> Mitsos101: yes, though I would replace the second 'replicate' with 'repeat' to avoid computing length xs
10:35:24 <cocreature> albeit: then you put restOfParent in the place of otherAction?
10:35:28 <albeit> (And restOfParent is a stateful computation that just forever reads messages from a queue and processes them
10:35:56 <albeit> Hmm
10:36:32 <albeit> This seems more cumbersone than just tracking the child's threadId and cancelling it when the parent dies...
10:36:38 <monoidal> Mitsos101: or, maybe you can say (a, b) = splitAt start largerList and operate on b only
10:37:22 <glguy> In my IRC client I use async to manage the network reader and writer threads. Each of those communicates information back to the main client thread through a event channel that the client thread consumes. One of the events on that channel is from when a network thread dies
10:37:58 <lavalike> glguy: what do you use for the event channel?
10:38:54 <glguy> a TQueue
10:39:41 <albeit> glguy: What if the the main client thread dies?
10:39:53 <glguy> then the program is done
10:40:33 <albeit> Ah okay. But what if you were running multiple main clients in non-"main :: IO ()" threads?
10:40:41 <__monty__> Does glirc support ssl auth?
10:40:50 <glguy> __monty__: yeah
10:41:08 <__monty__> Dammit, I'm running out of reasons for not bothering to check it out ; )
10:41:26 <glguy> albeit: then you'd want to wrap things up in withAsync
10:43:34 <glguy> If you can do what you want with just forkIO and killThread go for it, it's just more likely that you'll miss something
10:46:40 <glguy> __monty__: even better, though, is using Freenode's SASL ECDSA support. You get the benefit of a secure authentication, but also nickserv notices it faster and switches on your cloak before you become connected
10:47:19 <glguy> https://github.com/glguy/irc-core/wiki/Automatically-authenticating-to-NickServ#sasl-username-and-ecdsa-key
10:48:29 <__monty__> Hmm, do most servers support Sasl+ecdsa?
10:48:39 <__monty__> Or networks, I guess.
10:49:32 <glguy> I don't know, but you have to configure it per network and other networks might not have Freenode's behavior wrt CERTFP
10:53:13 <albeit> glguy: Would the withAsync method look roughly like processMessages2 in this? https://lpaste.net/3734825186038382592
10:54:17 <__monty__> glguy: Is SASL + ECDSA the same as SASL EXTERNAL?
10:56:30 <glguy> no
10:57:02 <glguy> Instead of the normal "PLAIN" method, you specify "ECDSA-NIST256P-CHALLENGE"
10:57:22 <glguy> "EXTERNAL" is yet another method
11:03:15 <__monty__> With the NIST curve? Isn't there a bunch of critique on that?
11:03:52 <glguy> no
11:06:16 <__monty__> If I'm reading this right, DJB says nist p-256 isn't safe: https://safecurves.cr.yp.to
11:16:35 <gentauro> how do you solve "memory leaks" in HS? :D
11:17:33 <gentauro> I tried to implement SHA-1 from specs using lazy ByteStrings (cos the SHA-1 of an +600 MB ISO would be to overkill to place in mem)
11:17:43 <gentauro> I ended up with this code -> https://pastebin.com/5y64A0Bx
11:18:00 <gentauro> it actually passes all the NIST SHA1 test -> https://pastebin.com/DZuxb7z4
11:18:23 <gentauro> but I can see from "htop" how when sha1sum on an .ISO file, it eats up all the memore
11:18:38 <gentauro> any good place to start when searching for memory leaks?
11:18:42 <gentauro> thx in advance :)
11:20:07 <gentauro> moved the snippets to lpaste for better readability -> https://lpaste.net/6002929670536822784
11:20:14 <gentauro> and https://lpaste.net/6008196627586613248
11:21:19 <gentauro> I tried as much to only use the constant operations from ByteString and then use a lot of `bitwise` calculations
11:21:51 <gentauro> I only store the 512 bits at the time for each rounds message schedule
11:23:03 <gentauro> I use `fromIntegral` a few times, but it's just for Word08 <-> Word32 convertions
11:25:21 <gentauro> my own guess goes to lines 290 - 291 as I point to a chunk of the lazy bytestring and therefore it might not be garbage collected?
11:26:43 <gentauro> but removing 290 (just calling $ ...) doesn't make a diff :(
11:28:08 <tieTYT> this program is giving me an error.  https://gist.github.com/dkaplan-pivotal/db5faaeeca42f6d2aeaf1223052aa670 I thought overloaded strings prevents this error?
11:28:17 <tieTYT> code and error inside
11:29:44 <geekosaur> no, because it only applies ot literals
11:29:46 <geekosaur> :t show
11:29:47 <lambdabot> Show a => a -> String
11:29:54 <geekosaur> this is not magically going to become Text
11:31:14 <geekosaur> there are alternative Preludes which provide more overloaded versions of show etc., but this is at the price of more ambiguity: you often need to specify more concrete types when it can't figure out which one you intended
11:32:43 <cocreature> gentauro: you are probalby going to have to isolate the problem to some minimal example if you want someone to take a look at it. that’s too much code to spot the problem on a quick glance
11:34:36 <gentauro> cocreature: I would rather learn how to find the performance issues than somebody pointing out line XX ;)
11:35:15 <cocreature> gentauro: you could start by throwing GHC’s memory profiler at it
11:36:44 <gentauro> cocreature: thx for the tip (reading) -> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
11:39:37 <cpn-uml> Is there a Haskell equivalent to ghci's :print statement?
11:40:29 <gentauro> cpn-uml: putStrLn?
11:40:34 <gentauro> or just putStr?
11:40:38 <gentauro> :t putStrLn
11:40:39 <lambdabot> String -> IO ()
11:40:44 <gentauro> :t putStr
11:40:45 <lambdabot> String -> IO ()
11:40:50 <gentauro> :t print
11:40:51 <lambdabot> Show a => a -> IO ()
11:41:34 <gentauro> cpn-uml: print requires the type to be `Showable` while putStr expectes a `String`
11:42:46 <tieTYT> geekosaur: so how do I convert a String to Data.Text.Internal.Lazy.Text?
11:42:51 <tieTYT> i guess i can google that
11:43:05 <gentauro> tieTYT: you mean Hoogle right?
11:43:12 <cpn-uml> gentauro: :print ignores the Show instance of the object
11:43:35 <gentauro> tieTYT: -> https://www.haskell.org/hoogle/?hoogle=String+-%3E+Text
11:43:42 <cpn-uml> instead, it gives me the data constructors that an object is constructed from
11:43:51 <geekosaur> "pack" although you may need to import it
11:43:53 <tieTYT> ah, cool
11:44:37 <gentauro> cpn-uml: `print` expects your type to be Showable. Show/Showable isn't pretty print, but the way Haskell can represent a type as a String that can be persisted to an external source
11:44:47 <gentauro> and afterwards be re-imported with Read
11:45:05 <gentauro> therefore many `Showables` add the constructors to their data types
11:45:20 <cocreature> gentauro: ghci’s ":print" command doesn’t have anything to do with "print"
11:45:26 <gentauro> cpn-uml: you should pretty much implement a `pp` (pretty-print)` fun for your type
11:45:46 <gentauro> cocreature: no?
11:46:48 <cocreature> :print will show you the current runtime representation of a value, so which fields are evaluated which aren’t, …
11:48:18 <cpn-uml> cocreature: yes, i was hoping to get that same behavior and log it to a file during execution
11:48:37 <cocreature> I don’t think you can get that behavior
11:48:49 <gentauro> cpn-uml: my bad, I thought you was asking about `print` :\
11:48:57 <cocreature> maybe ghc-heap-view helps?
11:49:02 <glguy> vacuum?
11:49:16 <gentauro> cocreature: I have added the profiling flags. It takes a long time to run but no `prog.prof` file is produced :(
11:49:25 <gentauro> (or at least I can't find it)
11:50:07 <cocreature> gentauro: for memory profiling you should probably get a .hp file not a .prof file. also have you passed the RTS options?
11:50:57 <infinisil> Map's are just safe partial functions, FITE ME
11:51:33 <glguy> They also are able to cache results where normal functions wouldn't
11:52:34 <cocreature> a function doesn’t let you list the elements in the domain for which it is not partial :)
11:55:20 <gentauro> cocreature: yes, the "+RTP -p" as described
11:55:38 <gentauro> but no file(s) are generated ;\
11:55:58 <cocreature> RTS not RTP
11:56:27 <infinisil> Okay I have an actual question regarding Maps now
11:56:33 <cocreature> and you want one of the heap profiling options, not -p
11:57:01 <infinisil> Is the type `Map String (forall m . MonadIO m => String -> m ())` not possible? I enabled RankNTypes
11:57:12 <infinisil> But it throws "GHC doesn't yet support impredicative polymorphism"
11:57:47 <cocreature> infinisil: instantiating a type variable with a quantified type is what is callde impredicate polymorphism and as the error message notes, it’s not supported by GHC
11:58:05 <infinisil> Oh I see
11:58:09 <cocreature> infinisil: you can however make a newtype for forall m . MonadIO m => String -> m ()
11:58:24 <infinisil> Sneaky!
11:59:20 <infinisil> Oh well actually I can just use `MonadIO m => Map String (String -> m ())`
11:59:30 <gentauro> cocreature: that helped
12:00:21 <gentauro> cocreature: I will go for -h (heap) and -p (process)
12:01:07 * hackage deferred-folds 0.6.5.1 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.6.5.1 (NikitaVolkov)
12:09:07 * hackage prometheus 2.0.0 - Prometheus Haskell Client  http://hackage.haskell.org/package/prometheus-2.0.0 (LukeHoersten)
12:13:31 <Berra> When using Vinyl - what strikes me as really nice is being able to defined Rec s with a parametric f such as `Rec f '[...]`. But to be able to do named fields and the tooling that comes with ElField that goes away - is that correct and is there no way to overcome that?
12:14:35 <Berra> What I've done before I tried using vinyl is to use singletons with for example a data + record also with a parametric f but then define types like `D IdSym0` and `D (TyCon1 Maybe)`.
12:15:41 <Berra> And looking at using FieldRec with Vinyl now that also appears to be the kind of solution I have to opt for. But I really think I might be missing something.
12:22:35 <noob-hs> hi
12:27:50 <tombusby> hey, i've installed haskell platform on my mac. I'm trying to use cabal to install hsdev (it's needed for my sublime plugin to work right)
12:28:12 <tombusby> But I'm getting an error every time it tries to install one of its deps: ghc-syb-utils-0.2.3.3..
12:28:19 <tombusby> I'll paste the whole thing into pastebin, one mo
12:30:25 <[exa]> mhm, what is the exact filename thing that is passed to: ghc-pkg register filename ?
12:30:51 <geekosaur> it's a lot like a cabal file
12:31:46 <geekosaur> basically it's a .conf file as you see in a package.conf.d
12:32:09 <geekosaur> which contains metadata and information on how to link a prebuilt package
12:32:56 <geekosaur> the Cabal library has helper routines to build these files iirc
12:33:10 <geekosaur> (and cabal-install can create one from a package's build cabal file)
12:33:27 <[exa]> oh okay, thanks
12:33:44 <[exa]> btw what's the exact file if I build a cabal package manually, in a directory?
12:34:09 <geekosaur> it will be somewhere under dist/build, I don't recall offhand and not sure I have one sitting around
12:34:27 <[exa]> ok thanks
12:35:16 <[exa]> OIS there's package-1.1.1.1-inplace.conf
12:35:23 <tombusby> https://pastebin.com/rTSGvAsg
12:35:24 <[exa]> nice
12:35:27 <geekosaur> yes but that's for using the dist/build stuff as it is
12:35:37 <geekosaur> I have a recollection that it uses that on the fly to generate the instaled one
12:35:45 <geekosaur> from here I suggest you ask over in #hackage
12:35:55 <geekosaur> because that's where the cabal devs hang out
12:36:18 <[exa]> yeah I only wanted to know where the stuff that's fed to ghc-pkg comes from, this answers that, sans some extra path magic
12:36:22 <[exa]> thanks :]
12:36:59 <[exa]> tombusby: did you try cabal new-install ?
12:37:06 <tombusby> no, what's that?
12:37:38 <tombusby> (trying now btw)
12:37:40 <[exa]> tombusby: it looks like a bit of version mismatch (no idea why there'd be the error otherwise), which can be caused either by 1] wrong dependency handling, 2] broken packages 3] weird compiler version
12:37:48 <[exa]> and I guess 2], and 3] is not the case
12:38:11 <[exa]> new-install has better dependency handling, allows multiple versions of the same thing etc.
12:38:15 <geekosaur> not sure it'd help here, this suggests some of the version information is too loose anyway
12:38:24 <tombusby> Mac is totally up to date atm (did a full wipe reinstall and ran all my updates the other day) and the install of Haskell/Cabal is totally fresh
12:38:29 <geekosaur> new-build helps when you have conflicting versions, not when the version information is wrong
12:38:56 <sclv> tombusby: i think that hsdev doesn't support ghc 8.4.3 yet
12:38:58 <geekosaur> (which happens because some devs have this idea that you have to deal with that yourself, it's not their problem)
12:39:10 <sclv> the error is from the ghc-syb-utils dep https://hackage.haskell.org/package/ghc-syb-utils
12:40:02 <tombusby> sclv: yeah, I noitced that, just don't know what to do about it
12:40:20 <tombusby> new-install is running atm, we'll see how it goes
12:42:46 <infinisil> I just created a pretty neat function
12:43:06 <infinisil> Let's see if anybody here wants to have a go at it, was pretty interesting
12:43:23 <tieTYT> the definition of `x >> y` is `x >>= \_ -> y`. I learned this from LYAH.  I can’t figure out how to learn this otherwise.  Does ghci have a way to tell me?
12:43:25 <infinisil> The type is (b -> a -> (c, a)) -> [b] -> a -> ([c], a)
12:43:48 <infinisil> The implementation can be really short
12:44:25 <gentauro> cocreature: I might have misunderstood ByteString. The graph shows that is uses 1.2 GB of mem :| (https://lpaste.net/6002929670536822784)
12:44:57 <gentauro> I mean, I thought that head/tail didn't create a new list (copy) but I guess it's that (or it might be take/drop)
12:45:08 <gentauro> but like 1.2 GB for SHA1 a 2 MB file :|
12:46:38 <adetokunbo> hello!
12:46:46 <geekosaur> tieTYT, not built-in, because it can't turn machine code back into Haskell. there are some packages like GOA that can hook it into hoogle, which will give you links to source code when available
12:47:54 <tieTYT> ok thanks
12:49:16 <tombusby> [exa]: looks like it might have worked, thanks
12:54:36 * hackage st2 0.1.0.0 - shared heap regions between local mutable state threads  http://hackage.haskell.org/package/st2-0.1.0.0 (chessai)
12:54:42 <tombusby> hmm, didn't error, but it looks like hsdev didn't actually get installed
12:56:43 <tombusby> https://pastebin.com/MvXJjm5F
12:56:47 <tombusby> this is what I'm getting now
12:56:59 <tombusby> this at the bottom looks important: cabal: symlink-bindir is not defined. Set it in your cabal config file or use
12:56:59 <tombusby> --symlink-bindir=<path>
12:58:39 <fishythefish> % :t \f xs z -> foldr @[] (\b (cs, z) -> let (c, z') = f b z in (c : cs, z')) ([], z) xs
12:58:40 <yahb> fishythefish: (t1 -> t2 -> (a, t2)) -> [t1] -> t2 -> ([a], t2)
13:03:29 <[exa]> tombusby: just defining some local bin directory in $PATH should work
13:03:58 <[exa]> it needs to place a few executables there, judging from the fact it stopped on happy
13:08:01 <Average-user> Is there something like clojure's reductions https://clojuredocs.org/clojure.core/reductions in Haskell?
13:08:18 <mniip> :t scanl
13:08:19 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
13:08:21 <mniip> :t scanr
13:08:22 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
13:08:43 <mniip> > scanl (+) 0 [1,3,5,9]
13:08:45 <lambdabot>  [0,1,4,9,18]
13:10:26 <mniip> Average-user, is this what you're looking for?
13:11:19 <lavalike> mniip: how did your contest go in the end?
13:11:58 <mniip> lavalike, there were multiple unplanned issues...
13:12:11 <tieTYT> I tried this installation but when I type `hoogle data` it says hoogle: command not found.  http://hackage.haskell.org/package/lambdabot
13:13:08 <tieTYT> I don’t even know if I’m supposed to install lambdabot.  GOA doesn’t explicitly state it
13:13:15 <lavalike> tieTYT: that's not a line break, it's saying install of these modules: lambdabot djinn hoogle data
13:13:45 <selfsymmetric-pa> infinisil: Looks fmappy
13:14:02 <tieTYT> oh
13:14:21 <infinisil> selfsymmetric-pa: Ehhh, not really, but yes something like map is used for the implementation
13:14:21 <tieTYT> “there is no package named ‘data’"
13:14:44 <infinisil> Okay yes it does look fmappy
13:14:56 <lavalike> tieTYT: ha
13:15:07 <tieTYT> also, it says, “The second command fetches the data for Lambdabot’s…” so I think that is a line break
13:15:18 <monochrom> :type mapAccumL
13:15:23 <monochrom> err
13:15:25 <monochrom> @type mapAccumL
13:15:27 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:15:51 <infinisil> Heh
13:15:51 <lavalike> tieTYT: you're right
13:15:55 <monochrom> There is also mapAccumR
13:16:00 <monochrom> @type mapAccumR
13:16:01 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:16:28 <infinisil> Well I'll be damned
13:16:41 <infinisil> Of course there's a function that does that already lol
13:16:51 <selfsymmetric-pa> @djinn (b -> a -> (c, a)) -> [b] -> a -> ([c], a)
13:16:52 <lambdabot> Error: Undefined type []
13:17:12 <selfsymmetric-pa> @djinn Traversable t => (b -> a -> (c, a)) -> t b -> a -> (t c, a)
13:17:12 <lambdabot> Error: Class not found: Traversable
13:17:34 <lavalike> tieTYT: I wonder if it is supposed to install hoogle for you
13:17:47 <tieTYT> maybe, but it didn't
13:17:49 <monochrom> djinn knows very little
13:17:50 <mniip> djinn cannot do recursive types
13:17:59 <selfsymmetric-pa> Ah, I didn't know.
13:18:02 <lavalike> tieTYT: the .cabal file doesn't mention hoogle directly so it won't
13:18:04 <infinisil> Okay the implementation I had was this
13:18:24 <infinisil> :t \fun -> runState . traverse (state . fun)
13:18:25 <lambdabot> Traversable t => (a -> s -> (b, s)) -> t a -> s -> (t b, s)
13:18:43 <tieTYT> I’ll cabal install it explicitly
13:18:50 <tieTYT> still not found as a command
13:19:00 <mniip> one of the core invariants of djinn that makes sure the search terminates in polynomial (?) time is being in simply typed lambda calculus which implies no recursion combinators or datatypes
13:19:04 <infinisil> But I guess I'll use mapAccumL now lol
13:19:23 <lavalike> tieTYT: I mean, it's not *needed* for lambdabot in general, but I guess it is if you want to use hoogle through iit
13:19:39 <glguy> infinisil: That's close to how lens generalizes it: http://hackage.haskell.org/package/lens-4.17/docs/src/Control.Lens.Traversal.html#mapAccumLOf
13:19:41 <tieTYT> I’m just trying to setup goa
13:19:54 <tieTYT> but I can’t figure out if that needs a cabal installed lambdabot or the source of it
13:20:14 <lavalike> tieTYT: it does need lambdabot installed
13:21:46 <lavalike> tieTYT: it forks a lambdabot instance on load, and then communicates with it when you issue commands
13:21:57 <tieTYT> oh it puts executables in ~/Library/Haskell/bin
13:22:01 <tieTYT> and I guess that’s not in my path
13:22:10 <tieTYT> i wonder why haskell doesn’t install with this on the page
13:22:35 <tieTYT> page=path
13:25:40 <infinisil> Turns out my implementation gets a lot simpler when I use mapAccumR
13:30:47 <geekosaur> tieTYT, because it's generally evil to go editing people's dotfiles. (and can cause problems, especially if you pick the wrong one. like, bash will look for multiple sets of dotfiles, and zsh looks for even more, and modifying the wrong one (or trying to modify all of them) can cause problems
13:31:12 <tieTYT> I see
13:31:14 <geekosaur> this is a much more complex problem than most people realize until they've tried to do it and then dealt with all the bug reports
13:31:23 <pie_> are there any "production quality" frp frameworks or is everything experimental?
13:31:37 <geekosaur> (I've been involved with a few projects that have run into that)
13:32:21 <tieTYT> this goa documentation is confusing me.  Am I supposed to install it with cabal?  It has instructions about running Setup.hs. I don’t have that file on my computer after a cabal install
13:33:02 <tieTYT> I can say import GOA and I don’t get an error, but I can’t use any of these commands in ghci.  It doesn’t know :bs for example
13:33:34 <[exa]> pie_: reactive-banana is pretty active
13:34:31 <pie_> ok ill focus my effors there then
13:34:48 <[exa]> I meant as a project, probably not a #channel
13:35:26 <[exa]> the other choice is reflex, and I'm not aware of any other "big" ones
13:35:56 <lavalike> tieTYT: you are supposed to augment your dot ghci file with the commands' definitions
13:36:29 <tieTYT> and I assume this Setup.hs creates a dot-ghci file to do that to?
13:36:43 <lavalike> it's in the distribution http://hackage.haskell.org/package/goa-3.3/src/dot-ghci
13:37:06 <lavalike> @botsnack
13:37:06 <lambdabot> :)
13:37:10 <tieTYT> oh, how was I supposed to know that?
13:37:18 <tieTYT> not being compative, I don’t understand
13:37:29 <tieTYT> compative=combative
13:37:38 <lavalike> tieTYT: idk it is what the page linked at the bottom of the lambdabot page says I'm just reporting https://wiki.haskell.org/GHC/GHCi#GHCi_on_Acid
13:38:04 <lavalike> "2.5.2 How to install"
13:38:20 <lavalike> (I ended up there from the link you gave with the hoogle command that failed you)
13:38:28 <tieTYT> ok so I guess when I see a hackage library, I should look for docs on a wiki instead of the hackage page?
13:38:34 <tieTYT> or is everyone different in this regard?
13:38:55 <lavalike> I find hackage readmes lacking most of the time
13:38:57 <monochrom> Everyone is different.
13:38:59 <geekosaur> often there's a readme somewhere. but everyone differs
13:39:05 <tieTYT> ok
13:39:19 <geekosaur> sometimes the hackage readme points you to a github readme. sometimes you get pointed to the haskell wiki. sometimes none of the above :/
13:39:35 <pie__> [exa], yeah i understood :)
13:39:39 <geekosaur> but then that's not a whole lot different from any other random third arty package
13:39:46 <geekosaur> *third party
13:39:59 <geekosaur> geeks are, as a rule, terrible at useful docs
13:40:17 <monochrom> People who actually have documentation talent can earn more money by becoming lawyers than becoming programmers.  So don't expect programmers to be half-decent in documentation.
13:40:18 <lavalike> geekosaur: what about geekosaurs
13:40:24 <geekosaur> variable
13:41:02 <monochrom> There is a reason why some people prefer to write moar code.
13:41:08 <geekosaur> but I don't release that much because most of what I write is really only useful to me. back when I was doing professional dev, my docs were generally better than what I saw from others… mostly because those docs frustrated me so much
13:41:25 <tieTYT> interesting, this wiki’s instructions are completely different
13:41:26 <lavalike> geekosaur: did you switch from programming to something else professionally?
13:42:04 <geekosaur> programming -> sysadmin -> filesystem support
13:42:21 <lavalike> ooh
13:43:01 <tieTYT> nice, I got it setup
13:43:08 <tieTYT> thanks for the help
13:43:09 <lavalike> tieTYT: \o/
13:44:42 <monochrom> I also have an IRC friend who got a math PhD then went on to law school and is a lawyer now.  This means math loses one more person who has writing skills.
13:46:53 <lavalike> they might end up doing some good math in their spare time, not all is lost necessarily, a lot of discoveries have been achieved that way
13:47:59 <zachk> fermat was a lawyer then I believe a judge
13:51:51 <monochrom> That is very self-comforting, until you find that empirically most of them just want to let their brains rest after a hard week's work.  Just look at dons.  You think after he went to Standard Chartered he would do Haskell in spare time?  All he does is sunset pictures.  Consider the existence of such a thing as "burnout".
13:53:01 <blinkhard> well I am a full-time lawyer who only does Haskell after work
13:53:56 <blinkhard> and no fermat, let me tell you, but may that be a comfort to you
13:54:50 <monochrom> Yeah thank God you aren't going to pull that "I know how to code this up but this margin is too narrow" trick >:)
13:55:59 <lavalike> monochrom: whew that's sad, I was trying to raise hopes! I guess it has to happen organically, it doesn't really happen by chance.
13:56:15 <monochrom> maybe "I know how to code this up but thumbing on this smartphone keyboard sucks"
13:56:23 <fishythefish> "I have discovered a truly marvelous implementation of this function which this 80-column limit is too narrow to contain"
13:57:50 <blinkhard> for a second I thought you were punning on narrow profit margin
13:58:25 <monochrom> heh
14:03:07 <Zipheir> fishythefish: I think that's going in my fortune file.
14:10:18 <pdxleif> > read "-1" :: Word64
14:10:20 <lambdabot>  18446744073709551615
14:11:00 <pdxleif> I feel that seems to be taking the representation of that value a bit too literally - I was expecting a parse error for that.
14:11:18 <Average-user> mniip: Yeah, thanks
14:11:29 <pdxleif> It's more for bytes than "unsigned ints"?
14:14:53 <geekosaur> > -1 :: Word64
14:14:55 <lambdabot>  18446744073709551615
14:15:35 <geekosaur> the machine types (Int, Word, sized variants thereof) are intended for speed; they don't do e.g. range checking
14:15:43 <monochrom> They were too lazy to customize their number parser to various types.  They wrote just one parser that's good for Integer, then applied fromInteger.
14:17:33 <adetokunbo> Is there an easy to use the customize genericToJSON to hide specific fields that are not Maybe values
14:24:45 <lavalike> adetokunbo: doesn't look like it to me
14:29:04 <lavalike> adetokunbo: i.e. the only thing Options let you omit is Nothing values and the default encode implementation of genericToEncoding defaultOptions seems to produce an Encoding which contains a bunch of mappended Builders for which there doesn't seem to be a way to go into and pluck out a particular ones after the deed is done
14:29:13 <lavalike> that's my reading at least
14:30:18 <adetokunbo> lavalike: thanks, thats what I thought
14:38:48 <lavalike> adetokunbo: maybe it is not incredibly hard to adapt this code to add omissible fields http://hackage.haskell.org/package/aeson-smart-0.2.0.0/docs/src/Data-Aeson-TH-Smart.html#mkToJSON
14:41:14 <lavalike> adetokunbo: at a glance I think it would be inside consToJSON where it does a list comprehension over `con <- cons`, there could be `predicate …` with predicate :: … -> Bool to filter omissible ones out
14:45:39 <adetokunbo> lavalike: thanks, I'll give that a try
14:46:01 <lavalike> adetokunbo: ultimately it might be easier to define a different type that only contains the fields that you want encoded to json and marshall to it, I guess, but this is kind of fun too (:
14:47:12 <adetokunbo> lavalike: thank you!
14:47:22 <lavalike> np!
14:49:40 <iqubic> How hard is it to get GHCJS running on NixOS?
15:08:22 <Athas> What's the simplest way to download a file over HTTPS in Haskell?
15:09:18 <monochrom> I just use System.Process to call up curl. >:)
15:09:34 <monochrom> (Too lazy to even use a libcurl binding.)
15:11:54 <pavonia> Is there a package that provides an efficient version of `Map (Range a) b` where the keys are (possibly unbounded) ranges of values? It should also have an Applicative instance for zipping two such maps into a new one by applying a function to all elements that lay in the intersection of both keys
15:12:33 <orbisvicis> In https://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Interpretation_as_Least_Fixed_Point there is "However, there might be multiple fixed points. For instance, there are several f which fulfill the specification: ... I don't know what that means."
15:12:41 <v0d1ch> when using DeriveFoldable and similar extensions is there a way to see the generated code ?
15:13:29 <dmj`> iqubic: nix-shell -p 'haskellPackages.ghcjs.ghcWithPackages (p: with p; [ miso ])'
15:13:37 <monoidal> v0d1ch: -ddump-deriv
15:13:48 <Athas> monochrom: wow, that might very well be the easiest solution.
15:13:52 <Athas> The web is a mess.
15:14:01 <v0d1ch> monoidal: thanks, I'll try it out
15:14:23 <lavalike> pavonia: I'm guessing standard Map would do pretty well the crux of the problem being an efficient Range type
15:14:24 <monochrom> orbisvicis: Let's make it simpler with the Integer type rather than a function space.  "x = x * 0" has two fixed points: bottom, 0.  "x = x + 0" has many many fixed points: bottom, 0, 1, -1, 2, -2, ...
15:15:22 <pavonia> lavalike: But I don't want to implement the Applicative instance myself :p
15:15:24 <monochrom> Athas: IIRC cabal-install also just calls up curl or wget by default. >:)
15:17:07 <monochrom> At some point you will realize that denotational "has multiple fixed points" corresponds to operational "won't terminate".
15:18:06 <monochrom> But denotationally you can't even say "will/won't terminate" so you have to make do with "non-unique fixed points".
15:18:11 <lavalike> pavonia: https://www.stackage.org/haddock/lts-12.2/containers-0.5.11.0/Data-Map-Lazy.html#v:unionWithKey
15:18:43 <monochrom> Why are you reading about denotational semantics?  Very few programmers need it and/or are ready for it.
15:19:07 <johnw> or perhaps they all need it, but are yet unready for it
15:19:19 <lavalike> pavonia: hmm is that enough
15:19:27 <monochrom> Especially since it tells you nothing you care about such as how much time and how much space.
15:20:01 <monochrom> It also fails to tell you about lazy evaluation.
15:20:05 <pavonia> lavalike: I don't think this will work because that is based on same keys. In my version the key set may change completely when zipping
15:20:20 <lavalike> pavonia: I think it might very well be enough, because of the Ord constraint
15:20:54 <lavalike> yeah the function not returning (k,a) but a is a bit of a bummer
15:21:11 <lavalike> maybe that can be arranged tho (:
15:21:30 <orbisvicis> monochrom: I follow the first point, not the second yet. However that 'f' is Int -> Int and has only one fixed point, f(_|_) = _|_ ?
15:21:42 <monochrom> f = ?
15:22:33 <orbisvicis> there are several f which fulfill... f = \n -> if n == 0 then 1 else f(n+1)
15:23:01 <madknight> this https://lpaste.net/5028080533679112192 function does not look haskell-ish how could I improve it?
15:23:30 <monochrom> OK, I'll name two candidates.
15:23:35 <lavalike> pavonia: I wonder if the pretty mechanical changes that would need to be made going from (k->a->a->a) to (k->a->a->(k,a)) to the implementation of unionWithKey simply suffice for your purpose
15:24:04 <monochrom> First candidate: f 0 = 1, f anyone_else = bottom
15:24:21 <monochrom> Second candidate: f 0 = 1, f anyone_else = 3.  Check this.
15:24:27 <pavonia> lavalike: That still wouldn't affect the key set of the result map, would it?
15:24:50 <lavalike> pavonia: that's the point of returning the key, but maybe I'm missing something
15:25:47 <monochrom> No my candidates are all wrong.  Int is annoying.
15:26:01 <monochrom> Can we switch to Natural please?
15:27:06 <monochrom> If you use Int then f is unique, it's f anyone = 1, because Int wraps around.
15:27:12 <orbisvicis> monochrom: sure, but I don't even understand the what they're saying, what specification ?
15:27:20 <lavalike> pavonia: yeah I think it's not as easy as I envisioned
15:27:29 <monochrom> "specification" = "f = \n -> if n == 0 then 1 else f(n+1)"
15:27:59 <monochrom> If you use Natural (or more precisely f :: Natural -> Natural) then my two candidates work.
15:28:11 <pavonia> lavalike: I just saw the range package already has a function for getting the intersection of a list of ranges, so I can probably use that for a wrapper around Map
15:28:23 <orbisvicis> so by candidate they mean fixed points of 'f'? Because once again, f(1) = _|_ which is not a fixed point
15:28:39 <lavalike> pavonia: I didn't know there was a range package, I'll look it up, I thought it was just a type in your question to represent an idea!
15:30:06 <monochrom> OK I don't know how to say it politely. You are imprisoning yourself in "functions can only map numbers to numbers".
15:30:32 <monochrom> You need to be told a more basic story first.
15:31:06 <monochrom> The following two are equivalent:  "solve x=x*0", "find the fixed points of \x -> x*0"
15:31:43 <monochrom> Tell me you agree, with your signature, before I go on to a higher-order example.
15:34:31 <tieTYT> can anyone help me understand why i’m getting these errors? https://gist.github.com/dkaplan-pivotal/db5faaeeca42f6d2aeaf1223052aa670
15:34:51 <tieTYT> compiler seems to care about the types of the intermediate results of my do statement.
15:35:10 <johnw> my guess is that you need to "lift" the connectPostgreSQL call
15:35:32 <johnw> the compiler cares about all types, everywhere :)
15:36:13 <monochrom> In fact so much so that if you write "foo = True where unused = False && ()" the compiler cares about unused.
15:36:37 <tieTYT> :t lift
15:36:38 <orbisvicis> monochrom: I do agree that they're equivalent. I also understand how in the above example, the factorial function f is a fixed point of g(x). And yet the 'f' I'm asking about here is not a higher order function like 'g'
15:36:38 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
15:36:56 <tieTYT> that lift?
15:36:58 <johnw> yep
15:37:03 <johnw> Control.Monad.Trans.Class
15:37:15 <tieTYT> why do I need to do that?
15:37:28 <johnw> to make the type right
15:37:38 <tieTYT> I don’t understand why the type is wrong
15:37:40 <johnw> it lift a base action into an action in your transformer
15:37:54 <johnw> connectPostgreSQL is most like some IO action
15:38:08 <johnw> you can't compose IO actions directly with the Scotty monad transformer
15:38:12 <monochrom> OK, "f = \n -> if n==0 then 1 else f(n+1)" is equivalent to "f is a fixed point of \e -> \n -> if n==0 then 1 else e(n+1)"
15:38:18 <johnw> but you can lift those actions into the Scotty transformer, and then use them
15:38:32 <monochrom> "\e -> \n -> if n==0 then 1 else e(n+1)" is the higher-order function sought.
15:38:46 <monochrom> "f" just plays the same role as "x" in "x = x*0".
15:40:04 <monochrom> So if I say " solve x=x*0" you don't say "I see no function, what fixed point?", you say "ah I see you're using an advanced-math way to ask for the fixed points of \x -> x*0"
15:40:16 <orbisvicis> monochrom: agreed. So that sentence is saying there are multiple 'f's (beside the one shown) that are fixed points of 'e' ?
15:40:31 <monochrom> Please don't say "fixed point of e".
15:40:42 <monochrom> Fixed point of \e -> \n -> if n==0 then 1 else e(n+1)
15:40:57 <orbisvicis> right
15:44:30 <monochrom> So check that my two candidates are both fixed points of \e -> \n -> if n==0 then 1 else e(n+1)
15:45:31 <monochrom> at which point you need to use extensional equality for functions: g = h iff for all x, g x = h x.
15:51:49 <tieTYT> johnw: so in my do notation, does the result of every line have to be the same monad as the return type?
15:52:11 <tieTYT> not the same one, but the same type
15:52:18 <monochrom> Yes.
15:52:20 <johnw> yes
15:52:29 <tieTYT> ah, either LYAH never mentioned that or it slipped by me
15:52:37 <monochrom> "do x <- [4]; y <- Nothing; ..." makes no sense.
15:52:57 <monochrom> But this is much easier to see from the type of >>=
15:53:08 <lavalike> @undo do x <- [1..3]; [4..6]; return (x, "hi")
15:53:08 <lambdabot> [1 .. 3] >>= \ x -> [4 .. 6] >> return (x, "hi")
15:53:40 <monochrom> in which you see 3 m's and therefore they all have to be the same m.
15:54:59 <tieTYT> didn’t know the m locked it down to the same type of class.  That’s good to know
15:55:09 <tieTYT> i mean same instance
15:55:12 <johnw> and it's your guarantee that everything is compatible
15:55:29 <monochrom> This is not specific to >>= or the Monad class.
15:55:39 <tieTYT> right
15:56:07 <monochrom> If you see "g :: t -> t -> t" they're all the same t.
15:56:55 <monochrom> If you see "\x -> x+x" they're the same x.
15:58:31 <monochrom> http://www.vex.net/~trebla/haskell/prerequisite.xhtml#substitution
16:03:39 <shapr> is there a tutorial on using cabal new-build to produce something that can be called from C?
16:04:11 <shapr> this uses ghc directly: https://wiki.haskell.org/Calling_Haskell_from_C
16:07:40 <monochrom> This may help: http://www.vex.net/~trebla/haskell/so.xhtml#cabal
16:08:01 <monochrom> But it's vanilla "cabal install", I haven't tested new-build.
16:10:58 <shapr> monochrom: thanks, I'll try this
16:18:26 <tieTYT> can anyone explain what this error message is saying?  https://gist.github.com/dkaplan-pivotal/3372c1f28d5f5a59162912aad2bb66f3
16:18:59 <tieTYT> is it saying Text isn’t a FromRow?
16:19:39 <lavalike> tieTYT: no it's saying that it's using Text as your String instead of Query, I'm not sure how one works around that
16:19:58 <lavalike> tieTYT: maybe just ("select .." :: Query)
16:20:51 <tieTYT> oh how did you figure that out?  It doesn’t mention Query in the error
16:20:54 <tieTYT> only query_
16:21:11 <lavalike> tieTYT: I might be wrong
16:21:29 <lavalike> I think I'm wrong :)
16:21:40 <shapr> tieTYT: are you following a tutorial?
16:22:00 <monoidal> getList conn should return IO [Text] because of line 1
16:22:24 <monoidal> query_ something something is FromRow r => IO [r]
16:22:25 <tieTYT> I’m reading the docs of Scotty and PostgreSQL.Simple
16:22:51 <lavalike> (I looked at what query_ is, and found the example is using OverloadedStrings for Query, you are also using OverloadedStrings for Text so I guessed that was the mishap)
16:24:13 <tieTYT> monoidal: so query_ returns a different type from my signature?
16:24:35 <abhiroop> tieTYT: the issue is Text or Query are not instances of FromRow
16:24:47 <lavalike> query_ :: FromRow r => Connection -> Query -> IO [r]
16:24:50 <geekosaur> what I see here is that FromRow describes recors, not fields
16:24:53 <abhiroop> the instances are here: https://hackage.haskell.org/package/postgresql-simple-0.5.4.0/docs/Database-PostgreSQL-Simple.html#t:FromRow
16:25:00 <geekosaur> FromField is the class for fields
16:25:25 <lavalike> so the [] in [r] represents rows, and r the shape of the row
16:26:33 <geekosaur> and I think for this case, you want the row to be a http://hackage.haskell.org/package/postgresql-simple-0.5.4.0/docs/Database-PostgreSQL-Simple-Types.html#t:Only
16:26:38 <abhiroop> maybe your function should read getList :: Connection -> IO [(Only Text)] or something like that
16:26:38 <tieTYT> abhiroop: why would it care about Query?  That signature doesn’t say that Query is a FromRow
16:26:41 <geekosaur> (which is a hack to get a "1-tuple")
16:27:02 <tieTYT> oh, I thought Only was for a single row.  I have multiple rows, one column
16:27:22 <geekosaur> "This is useful if you need to supply a single parameter to a SQL query, or extract a single column from a SQL result."
16:27:51 <geekosaur> it needs some kind of "row", and Haskell doesn't have 1-tuples, so it uses Only as the row type in this case
16:28:00 <geekosaur> so your type is Only Text
16:28:12 <geekosaur> for the result of the query
16:29:27 <geekosaur> well, actually it's designed to handle 0 or more rows as result, so [Only Text]
16:30:08 <lavalike> some drivers provide a convenience function for when you expect exacly one result but I can't find it in postgres-simple
16:30:11 <tieTYT> geekosaur: thank you I got it.  But I still don’t know how that error message was trying to tell me that
16:30:32 <geekosaur> what the message told you was that you forgot to account for the rows, you only gave it a column
16:31:07 <geekosaur> thus no FromRow instance (since it produces rows made of columns) given a Text (which is a column/field, not a database row)
16:31:50 <geekosaur> there should be some documentation about this in postgresql-simple
16:32:13 <geekosaur> but everything that comes out of the db is in  terms of rows made up of columns, not simply columns without a row container
16:32:31 <geekosaur> which is why it complains about no FromRow
16:32:39 <orbisvicis> monochrom: heh, I just assumed "f = \n -> ..." was assigning the lambda to the name 'f', and not asserting equality (and that your candidates where weird applications of 'f'). So assuming naturals, f1 {0 -> 1; else -> _|_} is a fixed point. And f2 {0 -> 1; else 3} is also a fixed point. However the process was slightly different than with the factorial example: there I lexically substituted f into
16:32:45 <orbisvicis> g(x) and obtained f (textually) again. Here I obtain different functions that are point-for-point equivalent (I assume this is the extensional equality you mentioned). And in either case, under Int they are not fixed points.
16:35:42 <monochrom> Yeah.
16:36:30 <shapr> monochrom: ifiuc, your example produces something that can be linked, but is not linked against a file.c with a main, is that right?
16:36:34 <shapr> iiuc*
16:45:55 <geekosaur> shapr, yes. it's just the .so file, not the thing you want to use it with
16:48:20 <shapr> geekosaur: thanks
16:50:22 <shapr> geekosaur: so I dig through dist-newstyle and grab the libFoo.so.0.0.1 file and include Lib_stub.h in the C source and it should work?
16:52:07 <geekosaur> I erxpect that's inplace and may have rpath problems
16:52:09 <geekosaur> "Instead, we install foreign libraries in ~/.cabal/lib, much like we install executables in ~/.cabal/bin."
16:52:14 <geekosaur> if you cabal install it
16:52:42 <geekosaur> (I dug through to the cabal manual to find that)
16:54:15 <shapr> looks like new-build doesn't drop things into ~/.cabal/lib
16:55:02 <geekosaur> becuase it's just build, not install
16:55:06 * hackage swish 0.10.0.0 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.10.0.0 (DouglasBurke)
16:55:09 <geekosaur> if you have a recent enough cabal there's a new-install
16:55:27 * shapr tries new-install
16:56:14 <geekosaur> anyway with just (new-)build there is the possibility that it has no runpath information and you would have to use an explicit rpath to use it
16:56:39 <geekosaur> that is, it could be linked in but at runtime ld.so wouldn't know where to find it
16:56:58 <geekosaur> some versions of libtool do this to you, for example
17:01:26 <pally> is there a name I can call () ?
17:01:36 <lavalike> "unit"
17:01:48 <pally> lavalike, thanks.
17:01:58 <lavalike> np!
17:02:08 * shapr hugs lavalike 
17:02:55 <lavalike> ^_^
17:03:02 <shapr> lavalike: what got you started with Haskell?
17:03:30 <lavalike> I have played with it a long time ago and got back into it earlier this year
17:03:55 <shapr> found any interesting insights?
17:04:27 <pally> It seems like everyone's got a "departure-from-Haskell" moment in their life.
17:04:49 <pally> and then returning, eventually
17:04:50 <lavalike> almost every time I end up writing some haskell I find something beautiful I'm happy I was able to write because of how the language is built
17:04:51 <shapr> geekosaur: any idea how I can compile up test.c in the same dir and link it correctly?
17:05:30 <lavalike> shapr: if I understand correctly monochrom does give compilation advice for .c files with a 'main' at the bottom of that page
17:05:43 * shapr reads the page again
17:06:00 <tieTYT> geekosaur: I think I get it
17:24:46 <tieTYT> https://gist.github.com/dkaplan-pivotal/3372c1f28d5f5a59162912aad2bb66f3 Why is this expecting `[Text] -> [Text]`?
17:25:02 <tieTYT> I feel like it should be expecting [Text] -> String
17:28:45 <Gurkenglas> :t intercalate "</h1></h1>"
17:28:46 <lambdabot> [[Char]] -> [Char]
17:29:16 <Gurkenglas> intercalate "</h1></h1>" must take [String] as input.
17:29:30 <tieTYT> :t unpack
17:29:31 <lambdabot> error:
17:29:31 <lambdabot>     • Variable not in scope: unpack
17:29:31 <lambdabot>     • Perhaps you meant one of these:
17:29:46 <tieTYT> :t Data.Text.Lazy.unpack
17:29:47 <lambdabot> Data.Text.Internal.Lazy.Text -> String
17:30:04 <Gurkenglas> http://hackage.haskell.org/package/text-1.2.3.0/docs/Data-Text.html#v:intercalate or rather [Text], since you've hidden Prelude.
17:30:16 <tieTYT> so if I map a list on that function, doesn’t it return [String]?
17:30:28 <Gurkenglas> It does
17:30:39 <Gurkenglas> Then you use Data.Text's intercalate, which wants [Text]
17:30:48 <tieTYT> oh!
17:31:02 <tieTYT> I didn’t know it had one, I should just intentionally use it
17:31:05 <tieTYT> ok thanks for the help
17:31:20 <tieTYT> man I wish that error message told me the namespaces
17:31:28 <tieTYT> I have no idea how I can figure that out next time
17:31:52 <Gurkenglas> tieTYT: by seeing whether the error messages say it expects String or Text
17:32:07 <Gurkenglas> tieTYT: A reasonable IDE will tell you the type of each identifier around there
17:32:16 <tieTYT> well, that helps, but nothing stops a function in that namespace from returning a String, right?
17:32:22 <Gurkenglas>  /expression
17:33:19 <Gurkenglas> tieTYT: I often end up sprinkling type signatures around so it can tell me whether the clash of expectations lies outside or inside the expression I've signed
17:33:35 <tieTYT> I’d have to pull that code outside a where to do that, right?
17:33:41 <Gurkenglas> nope
17:33:46 <Gurkenglas> > 2 + 124 + 4
17:33:48 <lambdabot>  130
17:33:52 <tieTYT> oh I didn’t know you could put type signatures in a where
17:33:52 <Gurkenglas> > 2 + (124 :: Int) + 4
17:33:54 <lambdabot>  130
17:34:02 <tieTYT> oh you just meant ::
17:34:13 <Solonarv> either works
17:34:17 <Gurkenglas> > (+ 4 :: Int -> Int) (2 + 124)
17:34:20 <lambdabot>  <hint>:1:6: error: parse error on input ‘::’
17:34:30 <Gurkenglas> > ((+ 4) :: Int -> Int) (2 + 124) -- whoops
17:34:32 <lambdabot>  130
17:35:32 <Solonarv> let- and where-blocks can contain function declarations, without or with type signatures
17:35:36 <tieTYT> I’m noticing if I insert into my database without restarting my app, it doesn’t see the new row.  But if I restart it does.  Dunno if this is a postgresql driver issue or scotty
17:37:48 <Solonarv> sounds like the write is buffered and you're not flushing the buffer?
17:37:52 <Solonarv> but I'm just guessing
17:38:39 <geekosaur> commit?
17:39:04 <geekosaur> there may be an autocommit if you shut the app down, but it won't be visible outside the app until tht commit happens
17:39:44 <geekosaur> I mean, that's what transactions are for, so other things using the database see only logically complete operations
17:40:35 <Gurkenglas> I sometimes write "x >>= f (\a -> ...)". How can I get rid of those brackets?
17:41:58 <geekosaur> you probably can't, unless you want let go a = ... in x >>= f go
17:42:08 <geekosaur> (or "while" equivalent)
17:42:23 <Gurkenglas> oh, there it is.
17:42:23 <Gurkenglas> @let infix 9 §; a § b = a b
17:42:25 <lambdabot>  Defined.
17:42:31 <Gurkenglas> :t ?x >>= ?f § \a -> a
17:42:32 <lambdabot> (?x::m a, ?f::(p -> p) -> a -> m b, Monad m) => m b
17:49:37 * hackage greskell 0.2.0.3 - Haskell binding for Gremlin graph query language  http://hackage.haskell.org/package/greskell-0.2.0.3 (debugito)
17:49:39 <Gurkenglas> https://gist.github.com/Gurkenglas/cb17b13d101f2b5d8038e6e20f1a3414 what do I even do? :(
17:50:22 <Gurkenglas> surely I can't be the only one who seemingly has more stack installs fail than succeed on him
17:50:37 * hackage greskell-core 0.1.2.2 - Haskell binding for Gremlin graph query language - core data types and tools  http://hackage.haskell.org/package/greskell-core-0.1.2.2 (debugito)
17:52:54 <Gurkenglas> (I previously did Ctrl-Z because it was running so long and i wanted to see whether it was doing anything, it said "Stopped", so I thought that cancelled instead of puttin in background (I only later learned that I also need to incant "bg"), so I tried to rerun, but it said some file is locked, so I thought the accidental abort wasn't clean, so I logged out and back in and reran, and got weird bugs, so I removed the hie directory 
17:52:56 <Gurkenglas> e's this
17:53:02 <Gurkenglas> *)
17:53:44 <Gurkenglas> -weird bugs + weird errors
17:54:56 <Gurkenglas> (and I'm doing this on the university server after stack installing haskell-ide-engine failed on my Windows home machine with weird errors that the dev doesn't know how to help with because he doesn't use Windows)
17:57:21 <edmundnoble> You're not the only one re: stack, just so you know
17:57:32 <Gurkenglas> Oh right I need to git clone with --recursive added, that might cause some of it.
18:02:33 <Gurkenglas> (man tar's taking a long time to unpack that ghc version)
18:04:27 <geekosaur> after that description I have to wonder how many of those issues are self-inflicted >.>
18:05:44 <Gurkenglas> How would I tell :D
18:10:00 <Gurkenglas> Nope, still the gist I last pasted with git --recursive. How should I approach that?
18:11:29 <edmundnoble> I don't know, stack is mostly a black box to me
18:11:30 <Gurkenglas> Ooh going to the directory that names and executing the command that names produces a bunch of logs
18:11:58 <Gurkenglas> Let's see if it says more than ExitFailure 2 at the end
18:13:30 <chreekat> Gurkenglas: there's a lot of verbosity options you could be passing
18:13:32 <Gurkenglas> (I would try a differently OS'd university server, but iirc it took a bunch of effort to get stack installed in the first place at any of the university servers)
18:13:50 <Gurkenglas> (the weird error sort of effort)
18:14:27 <chreekat> Based purely on the location of the error, I would wonder if you're hitting resource limits. Maybe your account (on a shared system, after all) is limited to some ones of gigs
18:15:04 <Gurkenglas> Okay, I can see if I can free something up, thanks
18:15:40 <Gurkenglas> (The ExitFailure 2 does in fact have some more numbers attached https://gist.github.com/Gurkenglas/cb17b13d101f2b5d8038e6e20f1a3414#file-gistfile2-txt )
18:15:54 <chreekat> My ~/.stack is sitting at 1.8GB right now
18:16:41 <Gurkenglas> What command do you recommend to show me what in ~ I should be looking at for space?
18:17:06 <chreekat> ncdu is pretty slick
18:17:18 <geekosaur> all that error says is something went wrong earlier
18:17:23 <jackdk> du -h --max-depth=1 ?
18:17:28 <geekosaur> that said, 127 often means some command was not foun d
18:17:46 <chreekat> But I wouldn't know how to check what disk limits you have, if any
18:18:10 <Gurkenglas> Hmm Ctrl-Z into bg on that ncdu thing lists it both with & and as Stopped
18:18:42 <geekosaur> likely stopped on SIGTTOU, meaning it wants to do output but something else owns the terminal
18:18:49 <geekosaur> you'd have ot fg it to see the output
18:18:59 <Gurkenglas> geekosaur: "undefined symbol: cur_term" might be relevant?
18:19:04 <chreekat> do you just try to background everything? :)
18:19:28 <chreekat> (ncdu is definitely not something you can put in the background, fyi)
18:19:29 <Gurkenglas> when I have reason to do something else while it's running
18:19:29 <geekosaur> Gurkenglas, yes, that would indicate it isn't finding a compatible version of the terminfo lib
18:20:00 <chreekat> If you need more terminals, use tmux!
18:23:13 <Gurkenglas> geekosaur, how would I approach that? Should I try to install a terminfo lib or try to find out why I am asked to do that in the first place?
18:23:28 <Gurkenglas> Is installing a terminfo lib even an option if I don't have root on the machine?
18:23:31 <geekosaur> it wants that because ghci uses haskeline which uses terminfo
18:24:03 <geekosaur> and ghci is ghc --interactive
18:24:04 <Gurkenglas> I have previously been able to install things with stack and that sounds like it would stop anything
18:24:13 <dmj`> glguy: I moved my Lexer from String to Text, but its slower now :/
18:24:34 <Solonarv> "installing a lib" just means putting the binary somewhere ld will find it, you don't need root for that
18:25:07 <Gurkenglas> Can I tell stack to download all those binaries as it needs them?
18:25:54 <shapr> I have a newbie C linking question: https://lpaste.net/6706366316288147456
18:26:10 <Gurkenglas> Less concretely: How should I stop being asked for these binaries?
18:26:11 <Solonarv> stack/cabal doesn't handle non-haskell dependencies, afaik
18:26:20 <shapr> If I understand that error correctly, libffi.so isn't being found, but I've added -lffi, why isn't it being found?
18:27:09 <Gurkenglas> I've previously gone down the rabbit hole of downloading the source for a required binary and building it and it didn't end well...
18:27:24 <Solonarv> download terminfo.so (may be named differently) from somewhere, or build it yourself; then put that in a directory in $LD_LIBRARY_PATH
18:27:59 <Solonarv> usually there are ready-to-download binaries for most common systems
18:28:23 <Gurkenglas> okay, i'll try to google up some terminfo binary for openSUSE
18:29:14 <geekosaur> shapr, linkers usually have order dependencies. so that -lffi at the beginning may be finding a system libffi.so with a different version than the one ghc wants
18:29:29 <geekosaur> (order dependencies on options/libraries.other parameters)
18:30:03 <shapr> geekosaur: huh, any idea how I specify the correct libffi.so ?
18:30:09 <geekosaur> move the -L options to before the -l options
18:30:41 <shapr> I'll try that, thanks!
18:31:28 <shapr> does the same thing :-/
18:32:17 <geekosaur> then I don't know. sometimes there are verbosity options to show you what it's actually using
18:32:36 <geekosaur> tbh I'd use ghc for linking because it knows how to do this already
18:33:16 <geekosaur> the -Wl option would need to change to -optl-Wl,-rpath,'$ORIGIN'
18:38:20 <oak> Gurkenglas: you'd most likely need ncurses-devel package for OpenSUSE
18:38:58 <oak> you could try to get the RPM and extract it into some prefix under your home directory and set the environment variables accordingly
18:40:21 <Gurkenglas> (I see the direction this is going, let's stop trying this on the university servers.)
19:20:42 <siraben> Bartosz Milewski is uploading part three of his category theory series!
19:20:43 <siraben> https://www.youtube.com/watch?v=F5uEpKwHqdk
19:30:28 <monochrom> Hunter gatherers eh?
19:31:59 <siraben> monochrom: We still are, deep inside.
19:34:00 <shapr> geekosaur: the shared object is not libHSrts.so, it's libHSrts-ghc8.4.1.so
19:34:15 <shapr> I was confused by libHSrts.a in the same dir :-(
19:55:24 <selfsymmetric-mu> I have tried to learn Yoneda lemma like three times. I understand the definitions. I can even prove it. I just can't for the life of me get the feel for it. Everyone teaching it seems to imply that there's a spark of insight that happens, so I must be missing something.
19:55:37 * hackage data-standards 0.1.0.2 - A collection of standards representable by simple data types.  http://hackage.haskell.org/package/data-standards-0.1.0.2 (ageitilt)
20:11:18 <wagle> whats it called when a monad generates "code" (source?) instead of just doing the usual computation "normal" monads do?
20:12:31 <dibblego> when does a monad do that?
20:12:32 <Solonarv> I'm not aware of any specific name for that, and the distinction is a bit blurry anyway
20:16:58 <monochrom> I can completely butcher your question beyond recognition and answer it.
20:17:22 <monochrom> Change "code" to "data".  Chanage "generates" to "is defined by".
20:17:36 <monochrom> A free monad is defined by data.
20:17:58 <rain1> staging
20:18:18 <monochrom> Now consider the Ship of Thessus. >:)
20:19:14 <monochrom> Anyway I think it's OK because it fits the bill of "instead of being defined by computation".
20:28:45 <nshepperd> I use an eDSL to generate OpenCL code
20:29:24 <nshepperd> I don't think there's a particular term for this beyond 'eDSL', which is pretty general
21:17:47 <wagle> just have seen people do it, without explanation as to how
21:18:26 <wagle> i might be able to figure it out, but I thought I'd tgry to save time
21:19:21 <wagle> nshepperd: ah, maybe that
21:20:59 <suzu> so for a while at work we built scripts using a haskell edsl
21:21:11 <suzu> this worked for a while until it turned out nobody wants to learn haskell
21:21:12 <suzu> :(
21:21:36 <suzu> so instead i wrote these shiny bindings to a javascript vm
21:21:56 <suzu> and so the scripts are now done in a js env lacking side effects (except some functions haskell provides)
21:22:16 <suzu> this has been working pretty well tbh
21:59:37 <pally> quick terminology question:  is `Maybe 3` called a monadic value or is `Maybe Int`
21:59:40 <pally> ?
22:00:00 <cocreature> pally: "Maybe 3" doesn’t make sense. do you mean "Just 3"?
22:00:09 <pally> oh shoot
22:00:11 <geekosaur> and we'd only calla it monadic if we were using it as one
22:00:14 <pally> yes, `Just 3`
22:00:32 <geekosaur> oif all you're doing is pattern matching or using maybe / fromMaybe then we wouldn;t normally call it monadic
22:00:39 <geekosaur> if you;re using do notationor >>= then we would
22:01:29 <pally> geekosaur, yes, it's referenced in the >>= context
22:01:42 <pally> so, `Just 3` is a monadic value, correct?
22:01:50 <nshepperd> monadic isn't a type of value, it's a state of mind!
22:04:53 <cocreature> pally: when you are working with the Monad instance of "m", values of type "m a" for some choice of "a" are often called monadic values
22:06:19 * wagle idly wonders if 3 could be an instance of the Maybe class
22:06:37 <wagle> there's prolly some extension...
22:06:51 * wagle prepares to run away
22:07:32 <wagle> nah, I'm not thinking clearly
22:10:14 <geekosaur> but if you created a Num instance for Num a => Maybe a, a literal 3 could have type Maybe Int
22:16:41 <dmwit> wagle: You can make a (law-abiding) `instance Num a => Num (F a)` for any "idempotent" Applicative F -- that is, one where `x *> x = x`. `Maybe` is one such.
22:18:40 <cocreature> making a law-abiding instance for a typeclass with no laws is not too hard :)
22:19:04 <dmwit> No. But not completely trivial, either -- you at least have to conform to the types. =)
22:19:27 <dmwit> Also Num has laws.
22:19:37 <dmwit> Well. Num has law.
22:19:55 <wagle> cole's law?
22:20:08 <wagle> sorry, i REALLY need sleep now
22:20:55 <wagle> but thanks for getting into my craziness
22:21:08 <dmwit> abs x * signum x == x; and probably it is intended also that signum x * abs x == x
22:22:42 <cocreature> oh I never noticed that law
22:22:52 <cocreature> probably because I ignore the existence of signum for the most part
22:23:37 <dmwit> > abs minBound * signum minBound :: Int8 -- kind of funny that this is actually minBound
22:23:39 <lambdabot>  -128
22:29:37 * hackage nlopt-haskell 0.1.2.0 - Low-level bindings to the NLOPT optimization library  http://hackage.haskell.org/package/nlopt-haskell-0.1.2.0 (peddie)
22:30:55 <dminuoso> cocreature: Isn't the term "monadic values" a bit of handwaving?
22:31:19 <dminuoso> I mean what does it actually convey?
22:32:39 <cocreature> sure I wasn’t saying it’s a particularly useful term. I was just describing how it is usually used
22:33:39 <dminuoso> Fair enough
22:33:48 <iqubic> I feel like "monadic values" describe values of the form (Monad m) => m a
22:35:39 <JuanDaugherty> compared to common confused thinking it's crystalline in clarity
22:41:07 * hackage hmatrix-nlopt 0.1.2.0 - Interface HMatrix with the NLOPT minimizer  http://hackage.haskell.org/package/hmatrix-nlopt-0.1.2.0 (peddie)
23:06:44 <kuttifunk> hi, anyone got ghc-mod running with stack lts-12.2 and ghc 8.4?
23:14:28 <guessWho> can we lift someyhing yo STM
23:15:12 <geekosaur> not sure what you're asking. can't do IO within STM, no, because that would make it impossible to retry a transaction
23:16:34 <tdammers> well, not impossible, just kind of useless
23:16:44 <guessWho> geekosaur : i'm performing atomic transaction inside a function which is in a abstract monad m and i'm doing liftIO $ atomically .... now i want to run  a function inside atomically function which works in "m" context
23:16:59 <guessWho> block*
23:17:00 <infinisil> :t liftSTM
23:17:01 <geekosaur> you can't call back that data you just sent over the network
23:17:02 <lambdabot> error:
23:17:02 <lambdabot>     • Variable not in scope: liftSTM
23:17:02 <lambdabot>     • Perhaps you meant ‘liftM’ (imported from Control.Monad.Writer)
23:17:15 <aho> how to sort haskell module exports using stylish-haskell or hindent?
23:18:04 <geekosaur> guessWho, not in general, you would need some way to relay state (which could include e.g. a database connection), and there is no reliable way to do that for an arbitrary monad.
23:18:33 <guessWho> geekosaur : what would be good haskell approach to this ?
23:19:05 <jackdk> aho: not answering your exact question, I'm sorry, but in emacs with haskell-mode this is `C-c C-,`, at least on my machine
23:20:01 <aho> jackdk: I am not familiar  with emacs. any command line tool?
23:21:00 <geekosaur> guessWho, there's no general answer for the same reason there's no canned mechanism for it. you'd need to know the specific monad to know what you can do
23:22:44 <jackdk> I believe it is a thing that stylish-haskell can do but I've never gone looking. Does google give you anything useful?
23:23:07 <jackdk> aho^
23:23:30 <jackdk> guessWho: Inside atomically you should only be doing STM actions, not actions in your m, unless I misunderstand you?
23:23:43 <aho> jackdk:  i don't think there is any flag for it in stylish haskell.
23:24:11 <jackdk> the whole point is to isolate and group your fiddling with transactional memory so it's away from your operations that mess with the outside world
23:25:01 <jackdk> aho: the example on the hackage page definitely shows imports being reordered
23:25:22 <jackdk> https://hackage.haskell.org/package/stylish-haskell -- have you run the command to dump a default config?
23:26:33 <aho> jackdk:  not imports , I need for exports.
23:26:49 <jackdk> oh sorry mate, I misread
23:27:11 <jackdk> I do not know
23:27:16 <geekosaur> guessWho, yes, what jackdk said, same as for IO: just as it can't know how to safely carry state across and bring it back out for later use, it can;t know what to do if an STM transaction gets retried
23:27:22 <geekosaur> you need to think about this
23:29:06 <aho> jackdk:  thanks anyway
23:29:25 <aho> jackdk:  may be will modify sourcecode of hindent or stylish haskell
23:30:30 <jackdk> it's not obvious to me that reordering exports is something you want to do in the general case, because haddock uses the export list to lay out docs, do sections, etc.
23:31:49 <aho> jackdk:  i didn't get the last part.
23:34:56 <geekosaur> haddock orders things in generated docuemntation based on the export list. If you have a comment of the form "-- $heading" in the export list, it adds a new section at that point
23:34:58 <jackdk> if you put a `-- * Section` in your export list, haddock will insert a section heading into the documentation, and adjust your table of contents within that module. See https://www.haskell.org/haddock/doc/html/ch03s04.html
23:35:21 <geekosaur> oh right, *. I firget what the $ does but I know we have some -- $usage
23:36:13 <geekosaur> haddock's basic function is api docs for exported functions, so the export list becomes a convenient way to control how that documentation is laid out
23:36:39 <aho> jackdk:  but for sorting imports in stylish-haskell it sorts blockwise .
23:37:05 <aho> jackdk:  so same way may be I can do it.
23:44:52 <butterthebuddha> Do "free theorems" have anything to do with "free constructions" of algebraic structures?
23:46:36 <dminuoso> butterthebuddha: I think not. As far as I know the word `free` in free theorem relates to the fact that you get these theorems without having to look at the function.
23:46:39 <dminuoso> Sort of "cost-free"
23:47:37 <geekosaur> actually, no, although that sense does exist and Wadler's "theorems for free" paper plays on it. but it's roughly the same idea with types
23:48:23 <dminuoso> geekosaur: Oh interesting, just found some *German* articles that hint at them being the same in fact.
23:48:38 <dminuoso> The German wiki entry on free objects does too.
23:48:45 <geekosaur> it's using church-turing (types are propositions, programs are proofs) to do pretty much the same thing, yes
23:48:54 <butterthebuddha> I haven't actually read the paper yet
23:52:38 <quicksilver> "free" is a general mathematical word
23:52:47 <quicksilver> and although it's imprecise
23:53:35 <quicksilver> it means something like "making the most simplistic or general construction which will always obey the laws automatatically without needing to understand what went before"
23:53:57 <geekosaur> yegh, I understand it here more or less as "independent of anything other than the structure of a type"
23:54:14 <geekosaur> and general laws such as e.g. functors
23:54:41 <geekosaur> no other dependencies, so it works for anything that has that structure
23:54:46 * quicksilver nods
23:55:24 <quicksilver> for stronger intuition read the wadler paper :)
23:55:42 <geekosaur> yep, I mentioned it for a reason
23:55:52 <tdammers> I thought it meant roughly "free" as in "not bound to anything specific"
23:56:41 <tdammers> "free monad" = "just the monadic structure, free from any specifics beyond that"
