00:00:22 <liste> (some other languages have union types, but they usually also have subtyping)
00:00:27 <diginet> I see
00:00:30 <diginet> thanks
00:00:35 <liste> no problem
00:01:02 <diginet> second, dumb question: what's the point of records as opposed to (Cons0 a, Cons1 b, ...)
00:02:04 <JuanDaugherty> handy data structure
00:02:45 <diginet> in what sense?
00:03:16 <liste> diginet: convenience and readability mostly. also using (Int, Int) for both Ratio and CoordinatePair can result in mixups
00:05:55 <diginet> I see
00:07:55 <liste> also you can define separate type class instances for real types (as opposed to type aliases)
00:10:16 <dminuoso> diginet: Is it possible to write your function to allow to accept some (Real a)?
00:10:39 <diginet> dminuoso: hmm?
00:11:05 <dminuoso> Oh haha wait. I suck. :)
00:14:19 <quicksilver> everything liste said is true, but still you could do what you said with a typeclass
00:15:22 <quicksilver> class Foo f where foo :: f -> X; instance Foo Float where foo = ....; instance Foo Int where foo = ...; sumFoo :: Sum -> X; sumFoo (SumFloat a) = foo a; sumFoo (SumInt a) = foo a;
00:15:47 <quicksilver> it does rather depend what "I have function foo which is defined for both Float and Int" means.
00:16:04 <quicksilver> because as written it doesn't obviously map to haskell, but the solution I just sketched is certainly one way to map it to haskell.
00:25:47 <diginet> the only way to do ad hoc polymorphism is via typeclasses?
00:26:21 <dminuoso> diginet: No you can also pass a sum type and then pattern match on it.
00:26:27 <dminuoso> diginet: Or you can pass some record manually
00:28:19 <quicksilver> but in a sense the answer to diginet's question is yes.
00:28:40 <quicksilver> typeclasses are *precisely* the answer to "how do we make ad-hoc polymorphism compatible with H-M type inference and system F)
00:29:04 <quicksilver> (I'm not saying they're the only conceivable answer, but that is the problem they were designed to solve)
00:29:12 <[exa]> s/ad-hoc/predicative/
00:30:29 <quicksilver> I don't think that's what predicate polymorphism means to me.
00:30:39 <quicksilver> but, well, I'm rusty and I was never a type theorist.
00:37:48 * hackage conf-json 1.2 - read, parse json config  http://hackage.haskell.org/package/conf-json-1.2 (procione)
00:53:17 <dreamer_> very often in haskell I find myself having huge source files because so many datatypes depend on each other and I can't split the files into separate modules
00:53:37 <dreamer_> is there something that would help with that that I am overlooking
00:54:10 <dminuoso> dreamer_: Without seeing some actual code it may be very hard to say.
00:54:26 <dminuoso> dreamer_: It might be design flaws, or you may just be overly reluctant to use imports.
00:54:29 <[exa]> dreamer_: separate by force!
00:55:13 <dreamer_> lol
00:57:02 <[exa]> dreamer_: also if standard methods fail, you might have a lot of mutual recursion that prevents some layering; I guess this could help ctions that use A
00:57:08 <[exa]> oh wrong paste
00:57:17 <[exa]> https://wiki.haskell.org/Mutually_recursive_modules
00:57:24 <[exa]> especially section 2.1
00:58:16 <dreamer_> this is my problem : mutual recursive types
00:59:50 <[exa]> yeah that's basically what sec.2.1 is about
01:02:13 <dreamer_> ..thats a really ugly solution
01:03:54 <fendor> is there some specific rest client library or should I use something like http-conduit?
01:04:13 <dreamer_> basically I have actors that contain their own behaviors (GameMonad () functions ) as records and I dont want to have the instance for the monad and ALL the different actor types in one single module
01:04:27 <dreamer_> before I didnt have that issue because I was just using IO and managing state using IORef
01:06:59 <[exa]> dreamer_: parametrizing the type can spare you a lot of instance work (you can parametrize the instance too)
01:07:27 <dreamer_> that is true..
01:07:40 <[exa]> dreamer_: otoh I'm just guessing now, if you have a source code sample the people here will probably be able to suggest a lot
01:07:54 <dreamer_> sure
01:12:44 <dreamer_> https://paste.ee/p/Agxu2 basically
01:14:39 <dreamer_> https://paste.ee/p/8pvnM just the monad to understand the instance
01:15:30 <dreamer_> I wish I'd be able to just split a module into two files tho
01:15:40 <[exa]> dreamer_: first thing that strikes me is hashmap usage (although not related to your problem. you do _not_ want hash-based containers. Also read the red line in data.hashmap docs)
01:16:19 <dreamer_> red line ?
01:16:23 <dreamer_> interesting, why not ?
01:16:26 <[exa]> (if someone told you that hash-maps are fast, shoot him without regret)
01:17:13 <[exa]> in Data.HashMap docs there's a deprecation and type-alias note
01:17:42 <dreamer_> someone did a few years back ~
01:17:47 <dreamer_> Thanks a lot then
01:17:55 <[exa]> btw think about how the hash table (basically a vector in a really optimistic situation) behaves in a language with immutable structures
01:19:05 <[exa]> he probably also told you that hashmap find is O(1), which is true only if your hashing is perfect and table never changed; more usually it's O(log n/loglog n) with a relatively large multiplicative constant
01:19:16 <[exa]> OK sorry for the interruption :]
01:20:18 <dreamer_> No thank you I had no idea !
01:20:21 <dreamer_> Im rewriting this game but with a saner codebase and an actual monad instead of the weird stuff I was using before btw : https://gitlab.com/WitchKnight/Arrowhead
01:21:20 <dreamer_> and I used Data.HashTable.IO and it was reasonably fast although the scale was small so I wouldnt notice it
01:22:10 <[exa]> D.HT.IO is cool but you suddenly need IO for everything
01:22:29 <dminuoso> [exa]: Where do you see a deprecation notice?
01:22:36 <[exa]> notice about HT complexity still applies though
01:23:29 <dreamer_> what would you recommend instead ?
01:23:38 <[exa]> dminuoso: oh noes I was looking at old version of docs from 1.3.2
01:23:41 * [exa] slaps google
01:25:44 <[exa]> dreamer_: start with a standard Map, improve only if it's slow. You shouldn't notice performance difference unless 1] your keys are huge and comparison complicated 2] the usecase calls for hashmaps (like, high-throughput bloom filters or so)
01:26:46 <[exa]> dreamer_: anyway about the code, there are generalization possibilities in the data (e.g. everything that has a position can be Positioned x)
01:27:04 <[exa]> same about health&weapon state
01:28:42 <dreamer_> I didnt include the Moving and Actor classes, is that what you mean : (those are old instances from when the fields were IOref) https://paste.ee/p/EWiV9
01:29:25 <dreamer_> I m in the midddle of a rewrite actually and trying to make something that makes sense instead of rushing like I did before
01:29:57 <[exa]> yeah that's reasonable
01:30:26 <[exa]> still /me a fan of type params :D
01:30:59 <[exa]> why does GameState need FontT and Show??
01:31:15 <dreamer_> Show it doesnt
01:31:24 <dreamer_> it's just for me I like it like that
01:31:33 <dreamer_> FontT is because of the way I load fonts
01:33:01 <dreamer_> https://paste.ee/p/SqUIy
01:33:10 <[exa]> oh so it also manages resources
01:35:21 <dreamer_> yeah I didnt post the whole monad module. I should. https://paste.ee/p/Evyrt
01:42:13 <[exa]> dreamer_: for example Animate instance couldn't be moved?
01:43:10 <[exa]> btw (\(_,x) -> destroy x) is destroy.snd
01:43:56 <[exa]> runGame looks a bit like bracket (but without exception handling)
01:44:31 <dreamer_> I could move the instance yes. was just more convenient to put it there. oh thanks for catching that
01:47:31 <[exa]> anyways the monadEverything instances for Game probably don't need to be split, it's all about one topic
01:49:02 <dreamer_> feel free to really dig in and say what's bad I really want to take my time and make something worthwile
01:49:11 <dreamer_> I agree
01:49:28 <dreamer_> but what do you mean split ?
01:50:02 <dreamer_> oh nvm
02:02:59 <c50a326> hey did any of you try drawing category theory graph chart thingies of your haskell programs?
02:03:20 <mniip> commutative diagrams?
02:03:36 <c50a326> ah yes commutative diagrams :D
02:03:57 <c50a326> can you draw a commutative diagram of a full program, or just of type relationships, or what?
02:04:10 <c50a326> but functions are types too aren't they so I guess that's a silly question?
02:12:07 * hackage hadolint 1.10.4 - Dockerfile Linter JavaScript API  http://hackage.haskell.org/package/hadolint-1.10.4 (lorenzo)
02:13:11 <dminuoso> c50a326: Obligatory: https://ro-che.info/ccc/
02:45:48 <c50a326> hey this is all lies https://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Concurrent.html#g:4
02:46:17 <c50a326> I copied the code and ran it and it prints an interleaving of abababababababa and then at the end when terminated by ctrl-c then it ends with aaaaaaaaaa
02:47:02 <dminuoso> c50a326: Read more closely.
02:47:09 <dminuoso> c50a326: It does not say it will never interleave.
02:47:19 <dminuoso> It says "in a co-operative system ..."
02:47:43 <dminuoso> And near the bottom it says that GHC implements pre-emptive multitasking.
02:47:48 <c50a326> oh, implementation dependent stuff...
02:48:19 <dminuoso> c50a326: It's just an explanation of some common basic multitasking terms. :)
02:49:14 <dminuoso> c50a326: The Linux scheduler for example is even a hybrid of these two.
02:49:28 <dminuoso> Most linux systems are primarily cooperative with low frequency preemption by default.
02:49:45 <dminuoso> (Yielding happens via syscalls)
02:51:18 <c50a326> tbh I don't know what pre-empting is
02:51:29 <c50a326> "a thread may be pre-empted..."
02:51:52 <dminuoso> c50a326: It's when the scheduler interrupts you with the intend to check other tasks, possibly giving them some CPU time
02:51:57 <dminuoso> that interruption is called preemption
02:52:25 <dminuoso> (that interrupt is transparent, your task will be put to sleep and resumed at a later point)
02:53:11 <dminuoso> think of it like a "pause button" on each task =)
02:53:18 <c50a326> okay, thanks :)
02:54:25 <dminuoso> c50a326: In the cooperative model the scheduler will not interrupt your task. So it is expected of you to cooperate and regularly "yield" to the scheduler, which can be seen as a voluntary self-pause, giving other tasks a chance to get some CPU time
02:55:00 <dminuoso> iow if you never yield then the other task will never run.
02:55:31 <dminuoso> In such a cooperative multitasking system you would observe the effect as described on hackage
02:56:57 <c50a326> so yield is unnecessary with GHC?
03:00:29 <dminuoso> c50a326: If I read it right it might request a context-switch (this is the act of the scheduler switching from one task to another) even in a preemptive setting.
03:04:53 <barrucadu> `yield` is a hint that your thread is ready to give up control now
03:05:15 <dminuoso> barrucadu: does it yield to the scheduler immediately in GHC?
03:05:22 <dminuoso> Or is it a gimmick?
03:06:21 <barrucadu> I don't actually know, let me see if I can find the source
03:06:45 <c50a326> also what's up with this nestage: children :: MVar [MVar ()] -- why not just [MVar ()] ?
03:06:57 <barrucadu> There are tests which certainly make it look like yield does something: https://github.com/ghc/ghc/blob/ba597c1dd1daf9643b72dc7aeace8d6b3fce84eb/testsuite/tests/rts/T10590.hs#L30
03:10:04 <lavalike> c50a326: the list itself needs synchronization between threads (since its length can vary)
03:12:18 <barrucadu> So, `yield` does return to the scheduler: https://github.com/ghc/ghc/blob/af9b744bbf1c39078e561b19edd3c5234b361b27/rts/PrimOps.cmm#L965-L973 and stg_yield_noregs calls https://github.com/ghc/ghc/blob/598472908ebb08f6811b892f285490554c290ae3/rts/HeapStackCheck.cmm#L141-L143
03:17:56 <c50a326> sorry slightly offtopic but what do you guys use to read postscript? something in-browser? I refuse to install non-floss browser extensions D:
03:18:19 <dminuoso> barrucadu: Neat! I just stumbled over the same files a minute ago too on my own. :)
03:19:19 <c50a326> and what is .cmm :o
03:20:25 <c50a326> I'll try this ghostscript thing
03:20:32 <dminuoso> barrucadu: But it's really tough to figure out how any of this is called. :)
03:20:49 <barrucadu> Yeah
03:24:12 <dminuoso> Is it possible that the missing glue code is generated by utils/genprimopcode ?
03:27:11 <mniip> c50a326, C--
03:27:14 <mniip> a GHC internal language
03:32:28 <mgttlinger> I want to parse content from url-shortened https webpages so I use http-conduit to follow those redirects to the destination page and get the body which works nicely. Is there a way to get the URL of the site after redirects?
03:51:55 <[exa]> mgttlinger: i guess you can set redirectCount to 0 to see the next url (but then you won't have the final site)
03:52:47 <[exa]> maybe getRedirectedRequest will get you the request you can continue with
03:54:12 <mgttlinger> So basically roll my own redirect handling and keep the last redirect url
03:56:03 <[exa]> maybe try to see if there's a way to access the modified request
03:56:26 <mgttlinger> So far I didn't even find a way to get the request url out of a request
03:56:33 <[exa]> btw there's an example around getRedirectedRequest in the docs that I believe does exactly what you want
03:56:41 * [exa] -> afk
03:58:44 <mgttlinger> [exa]: Huh, I missed that part in the documentation. I think I can build upon that. Thanks!
04:10:35 <ZeuPiark> hello
04:13:36 * hackage greenclip 3.0.0 - Simple clipboard manager to be integrated with rofi  http://hackage.haskell.org/package/greenclip-3.0.0 (erebe)
04:15:44 <newhoggy> Hello, I have an emergency, I seem to have taken myself of the maintainer list of the hw-hedgehog package.  Anyway I can get back on?
04:19:46 <hpc> ask in #hackage so someone who can fix it is more likelly to notice?
04:24:01 <newhoggy> Thanks!
04:37:43 <dfordivam> hello .. when cabal says that a package is broken.. what does it mean? that the package does not work with this version of ghc, or with the other libraries
04:45:07 * hackage greenclip 3.0.1 - Simple clipboard manager to be integrated with rofi  http://hackage.haskell.org/package/greenclip-3.0.1 (erebe)
04:46:37 * hackage greenclip 3.0.2 - Simple clipboard manager to be integrated with rofi  http://hackage.haskell.org/package/greenclip-3.0.2 (erebe)
05:13:42 <dminuoso> lemmih: Hiya. When you said that for a mutable schema one might use JSON, is the idea to just dump Text into the store and then parse/encode it with say aeson?
05:13:49 <dminuoso> (this is regarding your acid-state package)
05:31:00 <merijn> hmmm, I'm having a notation blackout. If I have an N x M matrix A, what's the most common math notation for indexing a specific element of A?
05:32:09 <monoidal> merijn: subscript A_{i,j}
05:32:48 <monoidal> or no comma A_{ij} if it's unambiguous
05:34:36 <merijn> monoidal: ah, cheers
05:54:18 <Boarders> does anyone know if it is possible to load a single file in a project with stack ghci?
05:56:45 <Gurkenglas> What (function from what) library turns code with a _ in it into the type inferred for the ?
05:56:48 <Gurkenglas> *for the _
05:58:52 <quchen> Gurkenglas: nomeata’s ghc-infer?
05:58:57 <quchen> Or something along those lines
05:59:31 <mniip> Gurkenglas, I don't understand the question
05:59:32 <quchen> Boarders: stack ghci <file>
05:59:40 <quchen> See --help
06:01:18 <Boarders> quchen: thanks
06:05:26 <Gurkenglas> mniip, it might map "sum :: [Int] -> Int; sum = foldl' _ 0" to "Int -> Int -> Int"
06:05:52 <Gurkenglas> Except that I'm hoping the interface isn't Strings, and this is just an example of the sort of feature I would expect of the library I'm looking for
06:06:11 <mniip> sounds like a thing GHC does
06:07:05 <Gurkenglas> How would I go about finding such things in http://hackage.haskell.org/package/ghc ?
06:14:39 <Gurkenglas> If A* is "(a -> Int) -> (a -> [a]) -> a -> [a]" (and afaic the library for that is SearchT), what library gives me "(a -> Int) -> (a -> a -> [a]) -> a -> [a]"?
06:16:37 <Gurkenglas> In TH terms, the ghc function might be typed "(Type -> [Dec]) -> Type"
06:21:20 <Gurkenglas> http://hackage.haskell.org/package/ghc-8.4.1/docs/TcRnTypes.html#t:TcM says it's historical and just TcRn. That implies there's the question why http://hackage.haskell.org/package/ghc-8.4.1/docs/TcMType.html says TcM everywhere, right?
06:21:59 <Gurkenglas> (encountering these because I'm traversing the google results for "site:hackage.haskell.org/package/ghc infer")
06:23:23 <Gurkenglas> Why isn't the [ExpType] note in the docs proper? http://hackage.haskell.org/package/ghc-8.4.1/docs/TcMType.html#t:ExpType
06:23:56 <mniip> such is GHC
06:25:36 * hackage hw-hedgehog 0.1.0.2 - Extra hedgehog functionality  http://hackage.haskell.org/package/hw-hedgehog-0.1.0.2 (newhoggy)
06:27:21 <Gurkenglas> I'm guessing there are political reasons for stagnation in there, right? Is there some fork project that attempts to exactly fix all the things prevented by politics?
06:27:34 <mniip> what?
06:28:03 <Gurkenglas> I took your "such is GHC" and guessed where you were going combined with murky memories of years past :P
06:29:22 <mniip> I don't understand what you're saying
06:32:40 <Thrush> Hello!  I was on here yesterday asking a question about functions that return linear functions.  That question was:  If I have a function that takes in (x1,y1) and (x2,y2) that calculates m and b (to use in y=m*x+b) and returns a new function, does that new function re-calculate m and b everytime it is applied?
06:33:26 <Gurkenglas> I gave some places in ghc that I would expect would usually go away in a software project. You said "such is GHC", which I understood as "all GHC is like this". I inferred that there must be some reason that makes weird things in GHC not go away. mniip, is there some particular part here that you don't follow?
06:33:50 <mniip> no, "such is GHC" was only referring to the documentation
06:34:01 <Thrush> A helpful reply was to return a lambda function that used the pre-calculated m and b, so that the lambda function could be applied without it re-calculating m and b every time it was called.
06:34:29 <Thrush> And it worked for me.  I wrote this:  linearFunctionCreator (x1,y1) (x2,y2) = do { let deltaX=x2-x1; deltaY=y2-y1; m=deltaY/deltaX; b=y1-m*x1 in \x -> m*x+b }
06:34:52 <mniip> why the 'do'?
06:35:00 <Thrush> So then I could call it like this:  let c2F = linearFunctionCreator (0,32) (-40,-40)
06:35:27 <Thrush> And then apply c2F like this:  print $ c2F 100  -- prints 212
06:36:19 <Thrush> For some reason, I thought a "let" had to be inside a "do" block, particularly when inside a function.  Am I wrong?
06:36:54 <joehh> Thrush: do you know how to use a where clause?
06:37:09 <mnoonan> Thrush: no, the syntax just changes a little: "let x = y in z" rather than just "let x = y"
06:37:09 <Gurkenglas> Thrush, yup, "linearFunctionCreator (x1,y1) (x2,y2) = let deltaX=x2-x1; deltaY=y2-y1; m=deltaY/deltaX; b=y1-m*x1 in \x -> m*x+b" works too
06:37:23 <mniip> is that an answer to "why the do?"
06:37:33 <Gurkenglas> Yes, what else would it be?
06:37:36 <Thrush> So then I thought, what if, instead of returning a lambda function, I just defined a new function in the "let" block, and just return that?
06:37:52 <joehh> that should work too
06:37:56 <mniip> oops lag
06:38:01 <Thrush> So I came up with this new, and very similar, function:  linearFunctionCreator (x1,y1) (x2,y2) = let deltaX=x2-x1; deltaY=y2-y1; m=deltaY/deltaX; b=y1-m*x1; f m b x=m*x+b in f m b
06:38:14 <mnoonan> it's the same, you're just naming or not naming the returned function
06:38:32 <Thrush> My question is:  Does the returned function from this new, very similar function, re-calculate m and b every time it is applied?
06:39:08 <mniip> Gurkenglas, must've looked really stupid in your timeline didn't it
06:39:14 <Thrush> So if I call it 1000 times, does it re-calculate m and b 1000 times, or does it just use the pre-calculated values, so that m and b are only calculated once?
06:40:21 <mnoonan> Thrush: you can use `trace` from `Debug.Trace` to experiment with this. `trace "foo" x` will print "foo" whenever x is evaluated
06:40:22 <Thrush> As for "why the do?", I remember trying to define a function with just one "let" block, and the compiler complaining that there was a "let" without a "do".  So all I added was a "do" and it compiled.
06:41:17 <Gurkenglas> mniip, I try to wait at least a bit before jumping to conclusions after encountering something I didn't predict at all :P
06:41:21 <mniip> that's not exactly what the compiler said
06:41:36 <mniip> > let x = x
06:41:38 <lambdabot>  <no location info>: error: not an expression: ‘let x = x’
06:41:40 <Thrush> mnoonan:  Where do I write the `trace "foo" x` line?  In the main function, or where x is defined?
06:41:48 <joehh> Thrush: my understanding (and please someone correct me if I am wrong) is that the calculations for deltaX etc will be thunks as part of the closure for the function you return. Due to lazyness, the first time they are needed,
06:41:57 <joehh> they will be calculated and replaced with values
06:42:01 <mniip> hmm
06:42:11 <joehh> following that, calls to your resulting function will just use the values
06:42:29 <mnoonan> Thrush: e.g. b = trace "b computed" (y1 - m * x1)
06:43:37 <Gurkenglas> <mniip> no, "such is GHC" was only referring to the documentation <- then what should I use instead of the documentation?
06:44:32 <darveter> Thrush: re let, it's either `let {...} in ...`  or  `do { let {...} ; .... }`.
06:44:38 <mniip> Gurkenglas, the source
06:44:41 <mniip> it has lots of comments
06:44:47 <mniip> most of which aren't haddock
06:44:58 <quchen> The semantics of »let« (in GHC) is to put every binding in it on the heap as a closure. Closures without bound variables whose bodies are not constructors are thunks, and thunks are evaluated at most once. GC is the only thing that cleans the heap up.
06:45:06 <mniip> there's also GHC commentary
06:45:12 <mniip> but that's very hard to navigate I've found
06:45:23 <quchen> In other words, thunks allocated in a »let« will remain evaluated as long as the let is alive.
06:45:41 <quchen> Thrush: ^
06:46:22 <c50a326> https://wiki.haskell.org/Thunk here it says "This function only evaluates the first parameter, because that's all that is needed. Even if the first parameter is true, you don't need to evaluate the second, so don't (so this version effectively is smarter than the explicit truth table). Who knows, the second parameter may get thrown out later as well!" re: the && infix function
06:46:28 <quchen> Thrush: If you have a function »f x = let …«, then the let is created anew for each invocation of f with an argument.
06:46:48 <c50a326> is this true? it doesn't make sense to me... if the first argument is true, then the second needs to be evaluated doesn't it?
06:47:06 <darveter> re recalculation, it depends on whether m and b are polymorphic or not.
06:47:16 <darveter> Thrush: ^
06:48:21 <mnoonan> c50a326, only if the result is demanded. "True && x" is equivalent to "x", and I don't need to evaluate "x" to tell you that
06:48:39 <c50a326> ah yeah I just got it :D
06:48:55 <c50a326> thanks
06:49:27 <quchen> I don’t get it. If »True && x« is evaluated, then so is x.
06:51:56 <c50a326> quchen: why?
06:52:05 <Thrush> I think trace is working.  Is there any way I can put in a trace statement like "I am here"?
06:52:11 <c50a326> quchen: x only need be evaluated when err... well, when need be evaluated :D
06:52:56 <geekosaur> quchen, it's not evaluated *by &&*. it may or may not be evaluated by something else later.
06:52:59 <c50a326> though I suppose `True && x` would only need to be evaluated when it needed to be evaluated, therefore at that time then both would be evaluated?
06:53:24 <quchen> c50a326: Well, something demanded the result of »True && x«, which is why the whole thing is evaluated in the first place. Evaluation will continue until a constructor has been reached, reducing the expression to WHNF. So evaluating True && x will have to look at the x before reducing to a value.
06:53:36 <geekosaur> but && only needs to get as far as the True to do its own job; evaluating x is something else's job
06:53:48 <quchen> Hmm okay if you look at it that way I guess you could say that.
06:53:49 <c50a326> aha
06:55:57 <Thrush> I think trace is working... I have some working code (at https://glot.io/snippets/f32yn6olet ), but the "b computed" part shows up in another text window (separate from the output).  Is there anyway to put them together, or to at least put other "I am here" trace statements?
06:56:36 <c50a326> "Because our implementation of Haskell uses lazy evaluation, forkIO immediately requires that the underlying implementation supports inter-process synchronisation. Why? Because a process might try to evaluate a thunk (or suspension) that is already being evaluated by another process, in which case the former must be blocked until the latter completes the evaluation and overwrites the thunk with its value."
06:56:56 <quchen> Thrush: trace prints to STDERR by default, and that pastebin separates STDERR from STDOUT.
06:56:59 <c50a326> I don't understand this at all... I suppose I first need to understand "inter-process synchronisation"
06:57:37 <c50a326> lots of the docs on this stuff are on Microsoft's website. How much of Windows is written in Haskell, if any?
06:57:53 <quchen> Probably none at all.
06:58:07 <dminuoso> c50a326: SPJ works at Microsoft.
06:58:08 <geekosaur> it's actually worse than that because the current implementation will go ahead and evaluate pure code in multiple threads, because that ends up beingf aster than locking
06:58:11 <quchen> Thrush: If you want to trace to STDOUT you’ll have to write your own implementation.
06:58:24 <dminuoso> c50a326: Microsoft funds a lot of research into programming languages. So..
06:58:44 <quchen> SPJ works for Microsoft Research. That’s faaaar away from Windows.
06:59:04 <agentultra> It would be so cool to work under the MS Research team.
06:59:33 <agentultra> They're funding one of my favourite theorem provers, Lean, and others like Dafny and TLA+
06:59:34 <dminuoso> agentultra: Obligatory https://ro-che.info/ccc/19
06:59:59 <agentultra> Hah
07:00:07 <agentultra> dminuoso: good one
07:00:09 <c50a326> well this explains very little ... https://docs.microsoft.com/en-us/windows/desktop/sync/interprocess-synchronization
07:00:14 <Thrush> Thanks, quchen.  Is there a way to print to STDERR?
07:00:28 <quchen> STDOUT you mean? Not using Debug.Trace.
07:00:55 <quchen> But you can write your own clone of the trace function to do this for you.
07:01:07 <dminuoso> c50a326: Do you understand how the execution model of GHC works?
07:01:29 <mnoonan> Thrush: if you just want to track where you are within main, you can sprinkle some "traceIO"s into main's do block.
07:01:43 <Thrush> No, I mean STDERR.  If Debug.Trace uses STDERR, then can I print to STDERR as well, so that the outputs can mingle.
07:01:56 <quchen> traceTo :: Handle -> String -> a; traceTo h msg x = unsafePerformIO { hPutStr h msg; x } -- NOINLINE
07:02:22 <quchen> s/; x/; pure x/
07:02:24 <mnoonan> Thrush: traceIO will also go to stderr
07:02:52 <c50a326> dminuoso: no D: I mean I understand that there's a main thread and that if the main thread finishes then the forked threads will be terminated
07:03:00 <dminuoso> c50a326: In very rough terms when you write something like `f = factorial 100000` GHC creates a closure. To obtain the value of `f` execution is transferred to the closure, which will compute the value, modify the closure so that the next time it will return the value, and then return the value.
07:03:35 <dminuoso> c50a326: so that thunk/clojure will replace parts of itself during evaluation.
07:03:39 <dminuoso> Heh. *closure
07:04:08 <geekosaur> you can import hPutStrLn and stderr from System.IO
07:04:14 <Thrush> mnoonan:  TraceIO is exactly what I was looking for.  Thanks!
07:04:37 <geekosaur> (and other h* versions of various IO functions, like hPutChar, that take a Handle)
07:07:04 <dminuoso> c50a326: Is this clear so far?
07:08:16 <c50a326> dminuoso: I just had to write `factorial n = n * (factorial (n-1))`
07:08:23 <c50a326> now I can think about this closure
07:08:32 <c50a326> (and factorial 1 = 1 ofc)
07:08:37 <dminuoso> c50a326: great. now write `f = factorial 1000` (or pick any number that is large enough to feel that it takes time, but not too long)
07:08:58 <c_wraith> 1000 shouldn't take noticeable time, even in ghci
07:09:12 <c50a326> ah I need to use Integer :D
07:09:19 <c50a326> 100 is 0 lol
07:09:40 <dminuoso> c50a326: You forgot about the base case. ;-)
07:09:47 <quchen> Use naive Fibonacci. Much more efficient at wasting time.
07:09:57 <quchen> fibo n = fibo (n-2) + fibo (n-1)
07:10:11 <c_wraith> dminuoso: nah, fib 100 :: Int is definitely zero
07:10:25 <dminuoso> Oh hah yeah.
07:10:49 <dminuoso> Prelude> fibo 10 *** Exception: stack overflow
07:10:51 <dminuoso> What the...
07:11:02 <butterthebuddha> quchen: You mean much more efficient at *being inefficient*?
07:11:16 <c50a326> does the answer to `factorial 10000` really end with a lot of 0's?
07:11:24 <quchen> > let fibo 0 = 0; fibo 1 = 1; fibo n = fibo (n-1) + fibo (n-2) in fibo 10
07:11:26 <lambdabot>  55
07:11:31 <c_wraith> c50a326: yes, absolutely
07:11:33 <dminuoso> c50a326: it doesnt matter what the answer is, just that it takes a few seconds to compute.
07:11:47 <c50a326> yeah 10000 is workable... 100000 nearly breaks emacs xD
07:11:59 <dminuoso> c50a326: create a binding `f = factorial 10000` then
07:12:10 <dminuoso> and demand `f` twice in a row. observe the time it takes each time
07:12:19 <quchen> c_wraith: Why is factorial 100 :: Int = 0? You’d have to hit 0 as a factor along the way by coincidence, or am I overlooking something?
07:12:30 <dminuoso> quchen: check the implemntation
07:12:32 <dminuoso> 16:07          c50a326 | dminuoso: I just had to write `factorial n = n * (factorial (n-1))`
07:12:39 <c_wraith> quchen: it has more than 64 2s as factors
07:13:02 <c_wraith> > 2 ^ 64 :: Int
07:13:03 <quchen> Ah right.
07:13:04 <lambdabot>  0
07:13:34 <c50a326> dminuoso: it took about the same I think? :s
07:13:39 <c50a326> brbpee
07:14:39 <quchen> My favorite slow algorithm is slowsort. It’s probably my favorite algorithm in general.
07:15:28 <quchen> Easy to do inplace, easy to parallelize, doesn’t do any comparison twice, all those good things.
07:15:50 <shiona_> quchen: from "simplexity analysis and pessimal algorithms"?
07:15:54 <quchen> Yup.
07:15:58 <c50a326> back
07:16:07 <shiona_> i love the paper
07:16:12 <c50a326> wait no sorry i switched environment to a real shell rather than one in emacs, that was the problem
07:16:19 <quchen> It’s brilliant, but Slowsort is the crown jewel.
07:16:21 <c50a326> with 100000 yeah there was a significant difference between first and second eval
07:17:42 <c50a326> dminuoso: so GHC stores the results of things it has evaluated so they're very quick to evaluate second time around, is the point, presumably?
07:18:02 <c50a326> (this is a GHC thing, not a haskell thing?)
07:18:06 <c_wraith> c50a326: not *everything*.  You should basically only assume it stores named values as long as the name is in scope
07:18:26 <c50a326> ok
07:18:26 <quchen> GHC stores the result of thunks. Functions (»things that take arguments«) have their bodies recomputed every time.
07:18:51 <quchen> And this is a GHC thing, not a Haskell thing. GHC is lazy, which is one way to implement the non-strict semantics that the Report demands.
07:19:04 <dminuoso> c50a326: like I said, when you create something like `f = ...` then f is a *closure* that, when entered, will compute the result, modify itself, and return the value.
07:19:22 <dminuoso> c50a326: during modification it will replace itself with new code that, when entered again, will instantly return the value.
07:19:47 <c50a326> hm so I wonder how fast 99999 would be now
07:19:47 <dminuoso> c50a326: so because the code is kind of self-mutating you will need synchronization primitives because you could have multiple tasks sharing these mutable pieces of code
07:20:16 <c50a326> f = factorial 99999; f -- is then slow :O
07:20:24 <quchen> A bit nitpicky, but the closure doesn’t modify itself, that’s done by the thing that evaluates the closure once it got a result from it. But that’s a minor detail.
07:21:22 <c50a326> synchronization primitives = MVar, or what?
07:21:24 <quchen> When entering an updatable thunk, the STG pushes an update frame onto the stack, and when the thunk is reduced to WHNF and the evaluating surrounding case block wants to see the result, the update frame is in the way, so it has to update the heap entry of the closure before matching on it.
07:22:07 * hackage crackNum 2.1 - Crack various integer, floating-point data formats  http://hackage.haskell.org/package/crackNum-2.1 (LeventErkok)
07:22:35 <dminuoso> c50a326: I think the paper was thinking more like a mutex
07:24:07 <c50a326> oh it means that GHC needs to use C (or C-- or whatever) and these primitives from that?
07:25:04 <c50a326> C IPC is used to ensure a kind of "thunk consistency" across haskell threads?
07:25:56 <c_wraith> No, it's not done with IPC.  It's just done with clever write ordering.  And accepting the occasional double-evaluation as fine because the language is pure anyway.
07:26:19 <dminuoso> c_wraith: Dont conflate IPC with interprocess synchronization.
07:26:27 <c50a326> oh right sorry
07:26:28 <dminuoso> Err sorry . c50a326
07:26:57 <c50a326> so I'm still unclear as to what inter-process synchronization is tbh lol
07:27:10 <c50a326> there's this https://en.wikipedia.org/wiki/Inter-process_communication#Synchronization
07:27:33 <c50a326> it's just this set of primitives?
07:28:30 <dminuoso> c50a326: From the perspective of the paper a mutex was meant.
07:28:55 <dminuoso> c50a326: Pretend they mean a mutex, not using it could be an optimization. :P
07:29:07 * hackage keccak 0.2.0 - cryptographic functions based on the sponge construction  http://hackage.haskell.org/package/keccak-0.2.0 (aupiff)
07:30:34 <c50a326> dminuoso: so GHC applies a mutex to a thunk before it evaluates it and releases after it has evaluated it?
07:30:38 <Thrush> I gotta go now.  Thanks for all your help.  You guys rock!
07:34:37 <dmwit> c50a326: I don't think there's a mutex, no. See also c_wraith's comment above: "It's just done with clever write ordering. And accepting the occasional double-evaluation."
07:35:08 <dmwit> If a capability forces a thunk, it makes a best effort to be the only one to do it by making a note of the fact that it's evaluating it.
07:35:21 <dmwit> But if a race condition happens and another capability tries to make the same mark, well, they might both make it.
07:35:25 <dmwit> NBD
07:37:58 <c50a326> these results of thunk evaluations are called marks? and are these things stored on the "stack" or the "heap" or something?
07:38:44 <c_wraith> the "mark" is an indicator by the runtime that a thunk is being evaluated
07:38:56 <c_wraith> It's part of the thunk data structure
07:39:40 <dminuoso> dmwit: The paper is talking about a primitive that sounds like a mutex though.
07:43:24 <c50a326> the paper also draws a distinction between "stream processing" IO and monadic IO... but in `main :: IO ()` you kind of chain actions together, the output of one action is the input to the next (and you can discard it)... this seems very similar to me to stream/pipe kinda stuff...
07:43:30 <c50a326> so what's with this distinction?
07:44:06 <c50a326> referring to 2.2 and 2.3 of this btw https://www.microsoft.com/en-us/research/wp-content/uploads/1996/01/concurrent-haskell.pdf
07:44:55 <geekosaur> similar concepts at different levels of abstraction?
07:44:59 <c_wraith> that paper is very old
07:45:19 <c_wraith> I think it might have still been discussing non-monadic IO models Haskell used to  have
07:48:07 <haasn> that sort of sounds like “IO as a free monad”
07:54:25 <drbrule> does anyone know why I am getting Couldn't match expected type ‘Text’ with actual type ‘Integer’ - toURL (ExportFromTime time) = show @_ @Integer . floor . toRational $ time
07:54:57 <c_wraith> why are you passing two type arguments to show?  it only has one type variable
07:55:20 <drbrule> I didn't actually write this so I am unsure
07:55:35 <pocucan> Hi everyone
07:56:02 <drbrule> sorry i forgot to mention this is an instance: instance ToURL ExportFromTime where
07:59:08 <c50a326> it says MVar can be seen as a "synchronised version" of the MutVar type introduced above. I'm still unclear on what is meant by "synchronised" tbh. Does it mean that only 1 thread will ever be able to access this type at a time?
07:59:33 <c50a326> "access" meaning "perform an operation on"
08:08:53 <geekosaur> drbrule, you should provide more information, but I will guess that is an alternative Prelude which has a Show class that is polymorphic in the result, and maybe the type variables have become reversed
08:09:27 <geekosaur> but you really do not have enough information there, the only thing that stands out is that show has two type applications and the standard Prelude only supports one
08:09:39 <lavalike> c50a326: it synchronizes threads accessing it because its operation block until they can perform the job
08:10:06 <c50a326> lavalike: yeah I think I get it, thanks
08:10:37 <lavalike> c50a326: np!
08:10:50 <c50a326> Every next sentence is a struggle though >.> "values of type MVar t can only be lambda-bound, and hence must be monomorphic."
08:11:11 <c50a326> monomorphic means morphism only goes one direction, right?
08:11:20 <lavalike> it means the type argument is fixed
08:11:22 <c50a326> not sure about "lambda-bound"
08:11:32 <geekosaur> monomorphic here means "has one specific type"
08:11:47 <c50a326> oh right
08:11:48 <lavalike> T a can take many forms, what that is saying is you can only operate of values where 'a' is fixed
08:11:52 <c_wraith> lambda-bound is a detail of the underlying hindler-milner algorithm
08:12:10 <c_wraith> in HM, you can bind variables in either a let or a lambda
08:12:24 <c_wraith> let-bound variables are generalized, and made polymorphic if possible
08:12:34 <c_wraith> lambda-bound variables are only ever monomorphic
08:13:19 <c_wraith> The paper is expecting you to know a ton of existing theory.  Not knowing it makes it *hard* to follow. :)
08:15:27 <c_wraith> (and the reason it's important that MVars be monomorphic is that they can break they type system if they're polymorphic.  In fact, Haskell has ways to cheat and let you create a polymorphic MVar, which does in fact break the type system.  So those means are all very clearly called out as unsafe things to do)
08:16:45 <c50a326> do you know some good resources for an idiot to learn Hindley Milner?
08:17:34 <c_wraith> I don't actually know it. I just have learned a lot about it from people who do. :)
08:25:16 <tester123> c2hs question: Does anyone have any thoughts about the questions posed here: https://github.com/haskell/c2hs/issues/212
08:27:57 <[exa]> c50a326: wikipedia page is good if you know prolog
08:28:27 <[exa]> c50a326: but well I can explain it here in a few lines if you want
08:28:59 <[exa]> s/prolog/unification/
08:29:28 <geekosaur> tester123, there's some fiddly details involved.
08:30:10 <geekosaur> (1) the difference between Ptr and ForeignPtr is the latter can have a finalizer attached, to release resources or call a C function to free memory or whatever
08:31:02 <geekosaur> (2) passing structured variables to / returning structured values from a ZC function can only be done safely by a C compiler, so that is always done with pointers instead because they can be passed directly
08:31:07 <geekosaur> *C function
08:33:07 * hackage deferred-folds 0.6.3 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.6.3 (NikitaVolkov)
08:36:07 * hackage Win32-errors 0.2.2.3 - Alternative error handling for Win32 foreign calls  http://hackage.haskell.org/package/Win32-errors-0.2.2.3 (gussen)
08:38:45 <tester123> geekosaur: Are my type associations correct (i.e., the statements I made involving the ~ operator)?
08:40:10 <tester123> I understand that ForeignPtr can handle finalizers, but I don't see how that has any impact on the type associations C2HS makes (i.e., which can be written CType ~ HaskellType; see my post).
08:41:14 <tester123> geekosaur: It might be easier to respond directly to my post: https://github.com/haskell/c2hs/issues/212
08:41:25 <tester123> I greatly appreciate your help as I've been very confused by this.
08:43:27 <geekosaur> I would prefer to leave that to someone who knows c2hs specifics (i,e. I don't know the difference between newtype and foreign newtype as c2hs intends it, I'm going by the generated code)
08:44:13 <tester123> Ok
08:47:38 <mreh> is it possible to get GHC to create a dynamic library whilst linking things like the RTS and iconv statically?
08:49:29 <geekosaur> I don't think that's possible in general, because then other libraries wouldn't know those sttaic copies and would find the system ones or etc. instead
08:49:40 <geekosaur> and with iconv in particular that leads to core dumps
08:51:07 <mreh> geekosaur: okay, I'm facing this annoying conundrum where I have to let libSDL be able to discover a callback, and when I compile the static lib with GHC SDL can't find the symbol
08:51:42 <mreh> it's not even GHC actually, I'm just trying a different method
08:52:22 <geekosaur> is this OS X? I think this is a known issue where every symbol to be used as to be known statically or it gets stripped to avoid annoying OS X linker limits
08:52:31 <mreh> geekosaur: android
08:54:00 <mreh> I compile a shared object but now, even after including the libraries and headers in the rts package, the dynamic linker is complaining about missing symbols from Prelude.h
08:54:08 <geekosaur> ARM makes it even more certain that you can't combine shared and static that way, iirc
08:54:37 <mreh> hang on, Prelude isn't in the RTS
08:55:02 <geekosaur> it's in base, it reexports a number of things from the RTS
08:55:54 <mreh> do I have to include all the libs that I've used in my final build then I suppose?
08:58:42 <mreh> when I compile my haskell as a static library and I do the final build of my android binary, the symbols that should be exposed dynamically in my final shared object aren't there
08:59:19 <mreh> if I build a shared object with haskell and include that in my android apk, it can find the symbols but the dynamic linker fails further on
08:59:33 <mreh> geekosaur: is that likely to do with ARM?
08:59:58 <Ke> perhaps it's more an android thing than ARM thing
09:00:07 * hackage hgeometry 0.7.0.0 - Geometric Algorithms, Data structures, and Data types.  http://hackage.haskell.org/package/hgeometry-0.7.0.0 (FrankStaals)
09:00:27 <mreh> Ke: I'm using bazel too, so it could be that too
09:00:48 <mreh> it lets me pass extra copts and lopts
09:01:12 <mreh> I'm a bit out of my depth here though
09:01:33 <geekosaur> ARM was just about mixing shared and static. says nothing about toolchain issues
09:01:50 <mreh> it would also be cool to install iconv in a place where GHC can find it without passing it's location with -L
09:02:06 <mreh> I tried installing it so pkg-config can find it
09:02:25 <lavalike> mniip: gl in the contest!
09:02:31 <mniip> !
09:03:02 <geekosaur> yes, well, welcome to android
09:03:25 <mreh> geekosaur: well, I was trying to mix a static library built with GHC and a shared object
09:03:42 <mreh> rather, compiling it into a shared object
09:03:49 <mreh> with some other c sources
09:04:21 <geekosaur> yes, I got that. and if something else needs that static lib as well, you're going to have duplicate symbols or  worse multiple copies linked in
09:04:53 <geekosaur> meanwhile android doesnt want you to install stuff in common locations that everything can find, you get o jailbreak if you want that
09:22:19 <dmrd> open question: does anyone know how to list all public-facing functions from a library using hoogle? Trying to do some data scraping and can't figure this one out
09:23:07 * hackage distribution-opensuse 1.1.0 - Types, functions, and tools to manipulate the openSUSE distribution  http://hackage.haskell.org/package/distribution-opensuse-1.1.0 (PeterSimons)
09:24:35 <exio4> dmrd: I do not know how to do with hoogle, but wouldn't hackage be a better source?
09:24:37 <c_wraith> dmrd, why hoogle?
09:25:45 <dmrd> exio4 , c_wraith : It doesn't have to be hoogle. I just figured hoogle would be able to do the trick. Also, since hoogle has a programatic API and command-line tools, I thought I could turn the search into an interactive script
09:28:27 <c_wraith> dmrd, to do that, I'd want to use the haddock-generated index. it conveniently lists every exported name in a package along with every module in the package that exports it.
09:29:34 <geekosaur> also worth noting is that a local hoogle generates its databases *from* the haddock data, and since it doesn't itself add anything useful for this it's probably better to avoid the middleman
09:29:56 <geekosaur> (hoogle is more about presentation to humans than about generating the useful information)
09:30:16 <[exa]> well hoogle could have something like is:type or is:function
09:31:11 <c50a326> how can I understand all this L, M, N :: = ... stuff in this "lambda calculus" ?
09:31:16 <c50a326> I'm trying to follow this talk https://www.youtube.com/watch?v=aeRVdYN6fE8&t=6m36s
09:31:34 <dmrd> c_wraith , geekosaur: That sounds promising. What's a good place to go start reading about how to start on this? As in, is this functionality that I can import from somewhere or are you still suggesting that I use a web scraper over Hackage (and look for its haddock data in the html)?
09:31:41 <[exa]> c50a326: large letters are usually combinators, shortcuts for some lambda expression
09:32:26 <c50a326> [exa]: is there a good book for programmers-not-mathematicians? I'm not sure what a lambda expression is, other than like "anonymous function" or "function-on-the-fly"
09:32:49 <[exa]> c50a326: that's what lambda expressions are in C and Java :]
09:32:51 <c50a326> though something quick and dirty would be great because I'd like to watch/follow this talk this evening :D
09:33:07 <tieTYT> OK so this is a default implementation: `m >> n = m >>= \_ -> n` But `guard (1 > 2) >> return "cool" :: [String]` returns [], not [“cool”].   Does this mean the list monad has a different default implementation?
09:33:13 <geekosaur> dmrd, http://hackage.haskell.org/package/haddock-api but it doesn;'t seem to have online documentation
09:33:36 * hackage codeworld-api 0.2.5 - Graphics library for CodeWorld  http://hackage.haskell.org/package/codeworld-api-0.2.5 (ChrisSmith)
09:33:43 <c_wraith> who haddocks the haddock?
09:34:14 <geekosaur> tieTYT, >> is defined in terms of >>=. >>= has a specific implementation for every monad
09:34:26 <[exa]> c50a326: lambda expression is anything in the language of lambda calculus, which is basically: 1] variables 2] lambda-abstractions over variables (\x -> some_lambda_expression) 3] lambda applications: (M N) where both M and N are lambda expressions
09:34:41 <dmrd> o_o who haddocks the haddock? haha. Thanks geekosaur and all you folks, I'll look into this :)
09:35:01 <c_wraith> > guard (1 > 2) :: [()]
09:35:03 <lambdabot>  []
09:36:00 <tieTYT> right but doesn’t this say regardless of this implementation, it’s going to have a function that returns `n`?  My understanding of the list impl of >>= is it applies each element to the function on the right
09:36:20 <geekosaur> tieTYT, (\_ -> n) is a function parameter to (>>=). list's (>>=) ignores it if its first parameter is the empty list
09:36:23 <tieTYT> but the function is hardcoded to `return “cool”`
09:36:29 <glguy> dmrd: http://hackage.haskell.org/package/haddock-api-2.20.0/docs/Documentation-Haddock.html
09:36:43 <c_wraith> tieTYT, return doesn't mean what you think it does
09:37:03 <dmrd> glguy: thank you <3
09:37:05 <[exa]> c50a326: not sure about non-mathematicians, but this is afaik quite digestible: http://www.cse.chalmers.se/research/group/logic/TypesSS05/Extra/geuvers.pdf
09:37:10 <tieTYT> I think it does.  It means take the element and wrap it in a singleton list
09:37:16 <c_wraith> > return "cool" :: [String]
09:37:16 <tieTYT> *I think I do
09:37:18 <lambdabot>  ["cool"]
09:37:36 <geekosaur> (return "cool") is a function parameter. it is not used in this case
09:37:39 <tieTYT> ohhhh I get it
09:37:42 <c_wraith> > [] >>["cool"]
09:37:44 <lambdabot>  []
09:37:49 <tieTYT> the guard may return an empty list
09:37:55 <tieTYT> ok that makes sense now, I get it
09:38:11 <geekosaur> yes. and when it does, >>= doesn't look any farther
09:38:14 <c_wraith> guard only ever returns [] or [()] for lists
09:38:29 <tieTYT> right
09:38:41 <tieTYT> now I get how this works.  And the point is to replace that () on the right side
09:38:48 <tieTYT> with whatever’s on the right of the guard
09:38:51 <geekosaur> basically, >>= in list distributes the function you provide over the elments of the list. if the list provided is empty, there's nothing to do
09:39:03 <geekosaur> so the function isn;t even looked at
09:39:11 <c50a326> thanks [exa]
09:39:23 <tieTYT> I think I was ignoring the >>= in the >> definition
09:39:33 <geekosaur> that was why I tried to focus your attention on it
09:39:42 <tieTYT> yeah :). I’m slow
09:39:51 <vlatkoB> For "f1,f2 :: IO (Maybe Bool)", how to write "f3 = f1 <|> f2", so it fails on Maybe, not IO exception?
09:40:13 <[exa]> c50a326: I guess chapters 1 and 2 will be sufficient for you to get familiar with the notation and so. It gets quite mathematical quickly after that.
09:40:34 <[exa]> chapter 3 is cool if you like programming in brainfuck and similars
09:41:11 <[exa]> and chapter 5 is about simpler type systems, but that's nothing that you couldn't at that point see from the wiki example on H-M system
09:42:30 <[exa]> anyway even chapter 5 is pretty digestible, but if you're seeing STLC for the first time, make sure you read it slowly and check everything before progressing
09:43:01 <tieTYT> ok I have another question.  How is this `[1..50] >>= (\x -> guard ('7' `elem` show x) >> return x)` equivalent to this `x <- [1..50]  ;    guard ('7' `elem` show x)  ;    return x`. The one on the left has a >> but I thought do notation only uses >>=
09:43:20 <glguy> tieTYT: Do notation uses >>
09:43:27 <geekosaur> >> is a semicolon or newline
09:43:40 <geekosaur> @undo do { a; b }
09:43:40 <lambdabot> a >> b
09:43:41 <tieTYT> I thought >>= was a newline
09:43:47 <geekosaur> no, >>= is <-
09:43:53 <tieTYT> oh
09:44:07 <geekosaur> more precisely, something <<- expr is: expr >>= \something ->
09:44:15 <geekosaur> er, something <- expr
09:44:25 <glguy> tieTYT: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
09:44:35 <glguy> tieTYT: For questions like this the place to go is the Haskell Report.
09:44:39 <geekosaur> it[s a little more complicated if "something" is a pattern, but that's the gist
09:44:48 <tieTYT> ok I’ll check it out
09:45:04 <tieTYT> I’m reading LYAH right now.  I really like it but it needs exercises to solidify this
09:45:08 <geekosaur> yeh
09:45:20 <tieTYT> everything I’m asking is something I know but forgot because I’m being overloaded with information
09:45:25 <geekosaur> LYAH's 14 countries in 14 days, no way you remember the whole thing
09:45:43 <geekosaur> or keep it all straight
09:45:54 <Gurkenglas> If I have an idea for an IDE feature and want to try making it, what libraries should I work with? Just GHC? haskell-ide-engine?
09:46:58 <Gurkenglas> Or is hie more the sort of thing you interface with once you have a working prototype, because the interface they provide is not the sort of thing you want to build your tool around?
09:47:07 <dminuoso> Hi. Is there a way to dump stg code inside GHCi?
09:47:14 <dminuoso> -ddump-stg seems to have no effect
09:48:34 <dminuoso> My feeling tells me that GHCi may not even compile to stg...
09:50:18 <ryantrinkle> is there something like `Control.Concurrent.Async.race`, except that it only cancels the slow thread if the fast thread *succeeds*?
09:51:03 <c_wraith> ryantrinkle, not that I know of.. but you could always catch exceptions and go into a long wait in both threads
09:52:13 <ryantrinkle> c_wraith: ah yeah, i suppose that would work
09:52:40 <c_wraith> ryantrinkle, maybe eventually rethrow the exception as a timeout sort of thing.
09:53:49 <glguy> Or you can use the STM catch functions to implement the logic you have in mind without a new thread
09:54:31 <ryantrinkle> glguy: huh, i'll have to look those up
09:54:44 <glguy> http://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html#v:waitCatchSTM
09:57:54 <dminuoso> Mmm okay if I read the commentary right then GHCi compiles from core to BCO
09:58:18 <dminuoso> Or..
09:59:16 <geekosaur> roughly correct
10:06:05 <c50a326> how do you guys say "::=" out loud?
10:06:17 <c50a326> BNF, not haskell, sorry
10:07:07 <geekosaur> I don't. generally. I can write it instead :)
10:07:14 <lavalike> "is"?
10:11:37 <XtraKrispi> hey, I've got a Yesod Authentication issue, I know this isn't the yesod channel but maybe someone can help me?  I'm trying to adapt an older auth plugin to the current version of Yesod and running into issues
10:24:36 <XtraKrispi> hey, I've got a Yesod Authentication issue, I know this isn't the yesod channel but maybe someone can help me?  I'm trying to adapt an older auth plugin to the current version of Yesod and running into issues
10:29:12 <c50a326> XtraKrispi: shit question dude
10:29:23 <c50a326> maybe post some code or some errors or something :D
10:31:40 <Akii> XtraKrispi which auth plugin?
10:32:02 <geekosaur> c50a326, your presentation could do with some improvement
10:35:11 <Akii> XtraKrispi if you could elaborate a bit on what you're trying to do :) maybe post compile errors on lpaste.net and some general context
10:35:30 <c50a326> yes sorry, this is what I meant :p
10:38:55 <Akii> xtra krispi and xtra afk it would seem :D
10:38:56 <XtraKrispi> The auth plugin is called NoPassword and it's for passwordless authentication.  Here's a gist of the file: https://gist.github.com/XtraKrispi/8bbe27ae0985120f1a9f9fd34d595e0d
10:39:06 <Akii> haha
10:39:12 <XtraKrispi> I had to make it
10:39:58 <XtraKrispi> Here's one of the errors: Couldn't match type `SubHandlerSite m0' with `Auth'         arising from a use of `postEmailR'       The type variable `m0' is ambiguous
10:41:16 <XtraKrispi> I think my issue is with the Form type, but I'm not sure
10:42:53 <Berra> Ignoring the lack of necessity in this example - could someone help me understand problems/improvements with this approach I'm trying to achieve with the datatype? https://hastebin.com/raw/fujutidure
10:43:34 <Akii> I haven't used yesod in ages, I'd just bootstrap a minimal yesod thing, include your module and go from there XtraKrispi?
10:43:49 <Berra> It does exactly what I and works - but I just want to crystallize better what alternative approaches I should consider.
10:43:58 <Berra> what I want*
10:45:25 <XtraKrispi> I can try that, but the issue is with the types, I'm not sure why, but it looks like the m for the authPlugin method doesn't match necessarily the m in the postLoginR method... it's definitely weird... I tried posting in #yesod but there's not really anyone there
10:46:36 * hackage fromhtml 0.1.0.4 - Simple adapter for transformation of HTML to other formats  http://hackage.haskell.org/package/fromhtml-0.1.0.4 (MarekSuchanek)
10:47:05 <Akii> XtraKrispi sorry, didn't mean it like that. This is what _I_ will try now to reproduce what you have in order to help
10:47:28 <XtraKrispi> oh, I see :
10:47:30 <XtraKrispi> :P
10:53:33 <Akii> oh well, can't even build the current yesod
10:53:37 <Akii> sorry :/
10:54:19 <Akii> in the meantime emacs is doing stuff.. maybe that's why
10:54:37 <Akii> aha!
10:54:51 <Akii> just 160 things to compile now
10:56:33 <XtraKrispi> lol
10:57:12 <XtraKrispi> I'm using stack resolver lts-11.15 if that helps
10:58:26 <_gatsby_> lovely day, isn't it, old sport?
11:02:18 <revskill> does (sequenceA . sequenceA) = id ?
11:04:46 <mnoonan> > (sequenceA . sequenceA) [[1],[2,3]] -- revskill
11:04:49 <lambdabot>  [[1,1],[1,3],[2,1],[2,3]]
11:05:30 <revskill> mnoonan: ok. what a mess
11:06:02 <revskill> but with [Just 1, Just 2], it's actually id
11:06:45 <revskill> (sequenceA . sequenceA) [Just 1, Just 2]
11:06:49 <revskill> > (sequenceA . sequenceA) [Just 1, Just 2]
11:06:51 <lambdabot>  [Just 1,Just 2]
11:06:56 <geekosaur> it'll depend on the applicative instance, yes
11:07:01 <monoidal> > (sequenceA . sequenceA) [Just 1, Nothing]
11:07:03 <lambdabot>  [Nothing]
11:07:38 <revskill> > (sequenceA . sequenceA . sequenceA) [Just 1, Nothing]
11:07:40 <lambdabot>  Nothing
11:09:02 <Berra> geekosaur: Is this approach crazy? https://hastebin.com/raw/fujutidure
11:09:40 <geekosaur> uh, why are you asking me?
11:09:57 <Berra> geekosaur: Because you've helped me out before. Sorry!
11:10:23 <Akii> XtraKrispi does this look like the errors you're getting? https://gist.github.com/Akii/3146291aed03bb467cd8894788daed1f
11:10:31 <geekosaur> but I don't generally work with either generics or JSON. or TH for that matter, which I recognize there but wouldn't be certain of what it's doing
11:10:53 <XtraKrispi> yeah, exactly
11:10:59 <Berra> geekosaur: I see -thanks anyhow!
11:11:31 <tieTYT> sorry I know I asked this before but it didn’t stick.  `instance (Monoid w) => Monad (Writer w) where`. Can I think of this as, “Writer w is a monad if the w in it is a Monoid"?
11:11:57 <Akii> XtraKrispi nice :) I'll try to figure it out; no guarantees though!
11:12:15 <glguy> Writer w is always a monad, but if you use it as one you'll also need to show that w is a Monoid
11:13:28 <tieTYT> what’s the significance of saying it’s always one?
11:13:47 <glguy> You can't make other instances like: instance SomethingElse w => Monad (Writer w)
11:13:55 <tieTYT> :) That’s what I thought.  OK thanks
11:14:53 <jackhill> Is there any coupling between GHC version and Cabal/cabal-install version?
11:15:22 <glguy> Your Cabal/cabal-install version needs to be new enough to know about the package database format that GHC is using
11:15:39 <glguy> newer versions of GHC tend to require newer versions of Cabal/cabal-install
11:15:39 <jackhill> Ah, I see at https://www.haskell.org/ghc/download_ghc_8_0_1 that I need at least 1.24.
11:15:58 <jackhill> glguy: is there an effective maximum version of cabal?
11:16:15 <jackhill> and thanks for the explanation as to why that is the case
11:16:18 <glguy> You mean the latest version?
11:16:22 <jackhill> yeah
11:16:28 <glguy> Yeah, there's a latest version
11:21:26 <XtraKrispi> Akii would it help to have the original version of the plugin?
11:24:32 <Akii> XtraKrispi pretty sure I can just get that by googling :D this one might be a bit hard to pull off just by following types
11:25:00 <Akii> but it does indeed look like it has something to do with the deprecated form thing
11:26:04 <XtraKrispi> yeah, I figured as much, but I'm not entirely sure what I should replace it with... the idea is that you provide your login page basically, not sure what else you could provide... or the form type is just wrong
11:29:29 <ztf> quit
11:31:49 <Akii> XtraKrispi gtg now, gonna look more at it tomorrow.. kinda tough though :S
11:32:05 <Akii> what you can try is to contact the author of the lib
11:32:32 <XtraKrispi> yeah
11:32:42 <XtraKrispi> he hasn't touched it in a year though
11:33:31 <Akii> that doesn't mean much imo
11:34:28 <dmwit> With cabal sandboxes, I could just decide to toss an extra package into the mix whenever I wanted by, e.g., `cabal install QuickCheck`.
11:35:08 <XtraKrispi> thanks for your help!
11:35:15 <dmwit> Is there a way to do a similar thing with new-*? That is, can I just make QuickCheck available for some quick local testing without changing any .cabal files or my cabal.project? (I'm okay with changing cabal.project.local.)
12:07:38 <tieTYT> I’m confused about the State monad’s >>=:  `(State h) >>= f = State $ \s -> let (a, newState) = h s                                          (State g) = f a                                      in  g newState  `. If you `g newState`, don’t you get a tuple back?  I thought >>= has to return a State g, because `m b` in `(>>=) :: Monad m => m a -> (a -> m b) -> m b`
12:09:10 <tieTYT> oh, I forgot the beginning of the definition is a State $...
12:47:50 <Henson> I've solved this before, but can't remember the answer.  I've got a pure function that returns "Maybe ByteString" and I'm trying to do a computation in the "MaybeT IO ()" monad transformer.  In a "do" block that runMaybeT is operating on, how do I pull the result of my pure function into the "MaybeT IO ()" monad?  Is it with "mayMaybeT"?
12:48:17 <Henson> mapMaybeT, rather
12:49:31 <hexagoxel> :t MaybeT
12:49:32 <lambdabot> m (Maybe a) -> MaybeT m a
12:49:51 <hexagoxel> :t MaybeT . pure
12:49:52 <lambdabot> Applicative m => Maybe a -> MaybeT m a
12:52:53 <Henson> hexagoxel: awesome, thank you!
13:14:41 <Henson> how about this one.  Inside "MaybeT IO ByteString" I have a function of the type "MaybeT IO (Maybe ByteString)".  How do I pull the ByteString from the nested Maybe into the MaybeT?
13:18:27 <Henson> actually, here's the more pertinent question.  I have a function that returns this type "IO (Either Reply (Maybe ByteString))" and I would like to bring the ByteString into a "MaybeT IO ByteString".  I currently have "join . rightToMaybe <$> liftIO" before the function, but I'm stuck trying to get the ByteString out of the inner Maybe.
13:21:45 <Henson> I think I got it...
13:23:13 <c50a326> :t newEmptyMVar
13:23:15 <lambdabot> error: Variable not in scope: newEmptyMVar
13:23:19 <cocreature> :t MaybeT . fmap (join . rightToMaybe)
13:23:20 <lambdabot> error:
13:23:20 <lambdabot>     • Variable not in scope: rightToMaybe :: a -> Maybe (Maybe a1)
13:23:20 <lambdabot>     • Perhaps you meant ‘listToMaybe’ (imported from Data.Maybe)
13:23:33 <cocreature> ^ Henson something like that should work (if rightToMaybe is in scope)
13:24:21 <dataN> :t m f = \k -> m (\a -> (f a) k)
13:24:23 <lambdabot> error:
13:24:23 <lambdabot>     parse error on input ‘=’
13:24:23 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
13:24:31 <dataN> :t \ m f -> \k -> m (\a -> (f a) k)
13:24:33 <lambdabot> ((t1 -> t2) -> t3) -> (t1 -> t4 -> t2) -> t4 -> t3
13:25:08 <dataN> hmm, should be ((a->r)->r) -> (a->(b->r)->r) -> ((b->r)->r)
13:25:51 <Henson> cocreature: awesome, thank you!
13:26:22 <dataN> :t \ _ _ a b -> a b :: forall proxy p q. proxy p -> proxy q -> (forall a.    (p=>a)->a) -> (forall b. p=>(q=>b)->b) -> (forall c.    (q=>c)->c)
13:26:23 <lambdabot> error:
13:26:23 <lambdabot>     • Couldn't match expected type ‘proxy1 p4
13:26:24 <lambdabot>                                     -> proxy1 q1
13:26:40 <endojelly> Hello. So it's been a long time since I had to do any accessing of databases in Haskell. Can't even remember.
13:26:44 <endojelly> What's "good" and up to date?
13:27:28 <endojelly> I have no dependencies at all right now. I do like sqlite, but am open to anything, even things different from SQL. It's single user, too.
13:28:59 <endojelly> HDBC seems abandoned?
13:29:40 <endojelly> so does acid-state, I think.
13:30:36 * hackage data-msgpack-types 0.0.2 - A Haskell implementation of MessagePack.  http://hackage.haskell.org/package/data-msgpack-types-0.0.2 (iphydf)
13:35:51 <cocreature> endojelly: acid-state’s last commit was 12h ago so that can hardly be called abandoned
13:36:06 <endojelly> cocreature, ah, was looking at the wrong repository then
13:36:47 <endojelly> ok, yeah, see a lot of commits now, sorry.
13:37:01 <cocreature> hdbc development definitely has slowed down but I think it has also just stabilized somewhat to the point that unless you want to radically rewrite it, it doesn’t require a lot of maintenance
13:37:08 <endojelly> The latest release to hackage seems to have been a year ago, does not mean the project is abandoned.
13:37:17 <endojelly> cocreature, that also sounds good
13:37:21 <dataN> so why does '(\ m f -> \k -> m (\a -> (f a) k)) :: ((a->r)->r) -> (a->(b->r)->r) -> ((b->r)->r)' compose so unlike 'id :: ((p=>a)->a) -> (p=>(q=>b)->b) -> ((q=>c)->c)' ?
13:37:41 <cocreature> personally I tend to just go with the sqlite/postgresql-simple libs most of the time
13:38:11 <endojelly> cocreature, yeah, I just stumbled upon that, too. I guess that's the straightforward approach.
13:38:32 <endojelly> I'm free to experiment, though. It's a small project for personal use.
13:38:34 <cocreature> if you want something more fancy take a look at opaleye, squeal and beam
13:39:36 <dataN> ok, so the proxies cant actually be omitted, but its easier to read...
13:42:23 <WASD> Can something like this be done without PartialTypeSignatures set? https://hastebin.com/ukamesador . Using StdGen instead of underscore makes compiler angry
13:44:43 <glguy> WASD: You can turn on ScopedTypeVariables and that becomes: random gen :: (Int, g)
13:44:56 <glguy> or you can use a helper function like: helper :: (Int, a) -> (Int, a); helper = id
13:45:07 <glguy> and that becomes: helper (random gen)
13:45:23 <glguy> But in this particular case you can just delete the type signature altogether, it's not necessary
13:45:43 <glguy> myRandomInt gen = random gen ; or better; myRandomInt = random
13:48:10 <WASD> thanks glguy
13:48:20 <WASD> makes sense
13:51:17 <WASD> I encountered it when trying to do this https://hastebin.com/atikivozen
13:51:46 <glguy> :t toEnum
13:51:47 <lambdabot> Enum a => Int -> a
13:52:00 <WASD> I know there are more elegant ways to generate a random enum, but doing it for educational purposes
13:52:01 <glguy> You can drop all the type signatures, they aren't needed here
13:53:06 <WASD> oh, you're right
13:53:15 <WASD> should have tried that before
13:53:54 <WASD> I'm coming from Java, very amazed by haskells abilities to derive types
14:09:37 * hackage data-msgpack 0.0.12 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/data-msgpack-0.0.12 (iphydf)
14:21:07 <dataN> big paste; https://gist.github.com/dataN-hs/f061562582078f1f16bc5da7eb2e9d4b
14:22:48 <dataN> lines 263 and 270 show GHCi returning the type at the prompt, but a definition with this type failing to compile...
14:26:49 <Gurkenglas> How do I request modules to be allowed for "@let import" again? (Is there a public listing for modules allowed, not yet allowed and rejected including reasons?)
14:33:40 <dataN> even adding proxies does not seem to help!
14:37:33 <JuanDaugherty> dmwit pm?
14:39:53 <monoidal> dataN: I'd expect a proxy on f and g to help. Does it compile with AllowAmbiguousTypes?
14:43:53 <dataN> no. then it says (with proxies)  Could not deduce (Empty32 (HasF (MegaProxy p) g0) f0) arising from a use of `haz' from the context: (Empty32 (HasF (MegaProxy p) g) f, InvHoist2 g)
14:44:11 <dataN> and without, it says;  Couldn't match expected type `x' with actual type `(Empty32 g0 f0 => x0) -> x0'
14:55:33 <dataN> why would it not compile while GHCi is able to return; \i->using32 $ Empty32_$ haz (MegaProxy i) :: (Empty32 (HasF (MegaProxy p) g) f, InvHoist2 g) => p -> (Empty32 g f => x) -> x
14:56:38 <monoidal> does it compile if you say decode =  \i->using32 $ Empty32_$ haz (MegaProxy i)?
14:56:42 <monoidal> (without a type sig)
14:58:11 <dataN> no. it complains of ambiguous variables
14:58:31 <dataN> with or without AllowAmbiguousTypes
14:59:31 <dataN> GHC version 8.2.2
15:06:04 <dmwit> ?tell JuanDaugherty You can PM me if you like. If it is about Haskell, I will most likely ask you to continue the chat in public.
15:06:04 <lambdabot> Consider it noted.
15:15:47 <dataN> the idea is that it can take a class of one defining function, and extend it to a class which can return the type of this function. this is then used as a local definition of the original class, so that satisfying the extended constraint gives a local instance of the original class.
15:16:19 <dataN> but it refuses to compile
15:29:07 * hackage cabal-plan 0.4.0.0 - Library and utiltity for processing cabal's plan.json file  http://hackage.haskell.org/package/cabal-plan-0.4.0.0 (HerbertValerioRiedel)
15:33:23 <hololeap> i want to write an Insertable class that gives an interface for turning a sum type into something that can be used by persistent's insert function: https://hackage.haskell.org/package/persistent-2.8.2/docs/Database-Persist-Class.html#v:insert
15:36:49 <Gurkenglas> class Insertable a where lol :: MonadIO m => (forall record. PersistRecordBackend record backend => record -> ReaderT backend m (Key record)) -> ReaderT backend m (Key a)
15:37:19 <Gurkenglas> Unless I understood you wrong?
15:37:57 <hololeap> Gurkenglas: yeah, that makes sense... i was trying to think of how to word my original question...
15:38:21 <Gurkenglas> This doesn't have anything to do with sum types yet though, so keep thinking
15:39:11 <hololeap> basically, if you have a sum type and you have a function that takes it and returns _anything_ from a particular class, do you have to use existential quantification kind of like SomeException does?
15:39:45 <Gurkenglas> hololeap, you may want to put that anything into the parameters of the class
15:46:07 <hololeap> Gurkenglas: here's a general example of what i would like to do: http://dpaste.com/1BYPD4A
15:46:38 <hololeap> i would need to use existential quantification for that, right?
15:47:38 <Gurkenglas> I don't know whether there's sugar for this, but the way I would improvise the solution for this is as follows (man this line sure is a lot of boilerplate huh)
15:48:34 <Gurkenglas> class IsNum a => toNum :: a -> (forall n. Num n => n -> x) -> x
15:48:45 <Gurkenglas> Oops, instead: class IsNum a where toNum :: a -> (forall n. Num n => n -> x) -> x
15:52:20 <hololeap> hmm... that's an interesting take on it. the logic is that since you would need to specify a concrete Num instance at some point, just pass in a way to convert a Num into what you want?
15:56:22 <Gurkenglas> sounds right
15:57:02 <Gurkenglas> Rephrasing: sounds like your take on my logic is right
15:59:35 <hololeap> Gurkenglas: that is actually really cool and opens up a whole new avenue for writing extensible code
16:00:30 <hololeap> i still haven't come to terms with everything that is possible using RankNTypes
16:01:00 <Gurkenglas> I had that cached probably because I read it somewhere.
16:01:10 <Gurkenglas> (The insightful part of that, that is)
16:01:48 <Gurkenglas> ...I suppose the approach must become cached if you keep working with lens combinators
16:02:17 <hololeap> i still haven't really tackled learning the lens library
16:04:17 <hololeap> just that chart on the main page of the docs gives me vertigo
16:04:42 <Gurkenglas> ...I think caching that approach lies on the path of learning not to use that library, but to write it
16:08:42 <hololeap> it actually kinda looks like the Cont monad
16:09:05 <Gurkenglas> Yes, but That Broken Language Extension keeps you from actually expressing that with it
16:09:40 <hololeap> heh, i've never used Cont tbh
16:10:55 <Gurkenglas> What was the name? The one that claims to allow "Maybe (forall a. a)"
16:11:22 <hpc> impredicative types
16:12:28 <dataN> Gurkenglas:it would just be; 'class IsNum a where toNum :: a -> (forall n. Num n => x) -> x', there is no need to explicitly state the n within the scope of the local constraint, just any value which uses that constraint. hmm maybe its actually; a -> (forall x. (forall n. Num n => x) -> x)...
16:13:20 <Gurkenglas> That doesn't sound right
16:13:26 <dataN> which part?
16:13:38 <Gurkenglas> The one where you don't use the n in the brackets
16:14:01 <Gurkenglas> Can you give a value in one but not the other of "forall n. Num n => x" and "x"?
16:15:00 <Gurkenglas> If there is no such, "a -> (forall n. Num n => x) -> x" should be treated like "a -> x -> x", which can only be const id, which makes the class superfluous
16:15:21 <hololeap> how does (forall n. Num n => x) make any sense?
16:15:49 <hololeap> n is never used
16:15:50 <Gurkenglas> Shush, I think your question is my question and less coherent.
16:16:35 <dataN> the code here does something like that, but its for these "Empty32 HasF" functions, which is some way of distributing the 'f' over the type synonyms wrapping a function. e.g. 'f a -> (a,f a)' where the existance of a function of this type (mod newtypes) as a constraint on 'f' defines the class Get.
16:16:57 <johnw> hololeap: to me that reads: x, given a context where anything and everything supports a Num interface
16:17:04 <Gurkenglas> (((You are under no obligation to listen to me. I'm merely placing social bets on such statements, and thus hinting at the force of my conviction.)))
16:18:08 <hololeap> bizarre
16:18:15 <dataN> hololeap: its not that its ((forall n. Num n => x) ->x)... where the constraint Num n must be in scope to return 'x'
16:19:48 <Gurkenglas> dataN, what is "the code here"? Do you what you wrote about 90 minutes ago?
16:20:11 <dataN> https://gist.github.com/dataN-hs/f061562582078f1f16bc5da7eb2e9d4b
16:20:24 <dataN> it has an error on the fundamental type on line 257
16:20:49 <dataN> which for some strange reason GHCi accepts at the prompt but wont compile
16:21:07 <lavalike> how do you define what modules are in scope for `cabal new-repl`? does it just pick the first entry in `exposed-modules` for a library and that's it?
16:21:15 <dmwit> johnw: It parses as `forall n. (Num n => x)`, not as `(forall n. Num n) => x`.
16:22:25 <dataN> this is also relevant https://gist.github.com/dataN-hs/5517bc5b1062893c8ea0e4a48e0334c0
16:24:04 <hololeap> dmwit: GHC is complaining that i need AllowAmbiguousTypes to make that work. is that true?
16:24:10 <hololeap> or did i do it wrong?
16:24:21 <dmwit> > 14 ** (1/3)
16:24:24 <lambdabot>  2.4101422641752297
16:24:42 <dmwit> hololeap: Sounds reasonable. The `n` does seem ambiguous to me.
16:26:18 <dataN> just updated the second paste, check the type of eg on line 48
16:26:27 <Gurkenglas> dataN, do you agree that my wording of the class also works? Do you agree that then instances of one must be transformable into the other? How would you build an instance of my class from an instance of your class?
16:26:34 <hololeap> it's still not compiling... what do i need to change? http://dpaste.com/150QPT3
16:27:08 <dataN> wait, can you clarify the things your referring to?
16:27:11 <shachaf> Is there a page anywhere that explains clearly why things like (exists x. C x => x) make no sense?
16:27:36 <Gurkenglas> hololeap, see if replacing "=> x" with "=> n -> x" works
16:28:06 <dataN> eg :: (Kleisli [] => c) -> c
16:28:37 * hackage network-msgpack-rpc 0.0.5 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/network-msgpack-rpc-0.0.5 (iphydf)
16:28:38 <Gurkenglas> dataN, my wording of the class is "class IsNum a where toNum :: a -> (forall n. Num n => n -> x) -> x", yours is "class IsNum a where toNum :: a -> (forall n. Num n => x) -> x". That's what you just asked for, right?
16:29:01 <dataN> and also the type of "dollars" for how to compose them, something like the monad instance for Cont...
16:30:17 <dataN> ah, that version seems to also hide (implicitly contain) a value of type 'n'
16:30:34 <hololeap> Gurkenglas: yeah, that works. i'm trying to do that weird thing that dataN brought up where it's just (forall n. Num n => x). i don't understand how you would use that
16:30:36 <Gurkenglas> dataN, which version? My version proudly displays it.
16:31:02 <Gurkenglas> Actually I can imagine a way in which (forall n. Num n => x) differs from x
16:31:26 <dataN> no, it requires a function is provided from 'n->x' and then somehow returns a value of type 'x', so it must implicitly contain a value of type 'n'.
16:32:46 <dataN> hololeap, it requires reflection and reification;
16:32:48 <dataN> reify :: forall a r. a -> (forall (s :: *). Reifies s a => Proxy s -> r) -> r
16:33:17 <hololeap> dataN: ok, thanks
16:33:37 <hololeap> thanks, everyone
16:33:54 <Gurkenglas> Nevermind @my last line, all Num class functions end on a, I thought there was toInteger too.
16:34:13 <dataN> also; using :: forall p a b. ReifiableConstraint p => Def p a -> (p a => b) -> b
16:35:56 <Taslem> When using `DeriveAnyClass`, is there a way to specify additional constraints to be placed on type parameters?
16:36:15 <dataN> can 'decode' on the first paste compile? would it be more helpful with a hackage repo for cabal?
16:36:39 <Taslem> Specifically, I've got "data Example (sep :: Symbol) x = Example (Tok sep) deriving (Generic, ParseForest)"
16:36:53 <Taslem> but deriving ParseForest only makes sense if (KnownSymbol sep) holds
16:45:09 <tieTYT> I just finished LYAH (for the 2nd time).  Is it too ambitious to go from this to trying to build a simple webapp?
16:45:21 <dmwit> DO IT
16:45:32 <johnw> tieTYT: I'd do it!
16:45:32 <glguy> tieTYT: Actually writing some Haskell code is the only way you'll learn
16:45:44 <tieTYT> can you recommend a framework to use?  Something with good documentation
16:45:48 <hpc> you can't learn to make webapps without making webapps :D
16:45:54 <c_wraith> you probably will have lots of questions. but that's not a bad thing.
16:46:04 <hpc> is snap still good?
16:47:06 <glguy> I've done some stuff with just snap-server and not fussing with all the snaplets, but I think scotty might a nice place to start in terms of not doing anything fancy
16:48:41 <glguy> But snap-core + snap-server has worked well for me in the past and then you can build up to using more of the "framework" aspects of snap later
16:49:39 <tieTYT> scotty seems easy
16:50:25 <tieTYT> “Snap is a simple web development framework for unix systems, written in the Haskell programming language.” so it won’t work on a mac or pc?
16:50:38 <glguy> mac is unix, so that one's fine
16:51:15 <tieTYT> I dev on a PC usually.  I tried this 3-4 years ago and it was absolute hell to get libraries working
16:51:29 <tieTYT> is it pretty much still like that?
16:51:32 <Taslem> haven't tried it, but if you use bash-for-windows (windows subsystem for linux) it will probably work
16:51:44 <tieTYT> I use cygwin
16:51:47 <hpc> mac is bsd
16:52:01 <glguy> hpc: https://www.opengroup.org/openbrand/register/brand3632.htm
16:52:10 <Taslem> I use WSL Bash + Stack and haven't had problems (never tried snap in particular)
16:52:14 <hpc> it looks like snap uses unix-compat, which wraps windows apis the way it needs
16:53:08 <tieTYT> hpc: suspicious they didn’t say unix/windows on that webpage then.  I’ll give it a try
16:53:44 <dataN> what about web sockets on an emulated environment?
16:53:58 <hpc> it's probably like most windows-compatible things
16:54:08 <hpc> they let it build on windows but don't give it much attention
16:54:22 <hpc> maybe no devs with windows boxes have bothered to contribute or something
16:55:01 <tieTYT> I already feel demotivated by that
16:55:07 <dataN> like, how to run yesod on each node of a graph to model concurrency... maybe something like actors
16:55:11 <tieTYT> isn’t there a steam game written in haskell?
16:55:59 <hpc> tieTYT: if it works well enough to learn from i wouldn't worry
16:56:22 <tieTYT> hpc: I didn’t understand that sentence
16:56:40 <hpc> like, maybe some features don't work but you can use the rest of it?
16:57:59 <tieTYT> Prelude seems to be write once, run anywhere (like java).  How come the community doesn’t care about that for its libraries?
16:58:20 <dataN> ?
16:58:40 <Solonarv> huh? that *is* mostly true
16:58:44 <Solonarv> in fact: snapframework.com/faq#can-i-develop-with-snap-on-windows
16:58:46 <hpc> some things depend on posix apis, some don't
16:58:55 <hpc> for the most part they don't
16:59:16 <dataN> http-simple is a good entry point
16:59:48 <glguy> tieTYT: The open source community mostly isn't on Windows, and the Windows devs mostly aren't contributing
17:01:03 <xenon-> most linux developers aren't contributing either. I am not aware of any proof that windows developers are less likely to contribute
17:01:34 <glguy> xenon-: The proof is apparent from the platforms that people support in the code they make available
17:01:36 <dataN> there is some stuff on embedded systems in ARM via cross compilation.
17:01:48 <tieTYT> the way it works in java is the language designs provide very low level building blocks.  I have access to a Socket class so I don’t have to depend on the OS’s system calls to use sockets
17:01:56 <Solonarv> it's anecdotal, but I'm windows-only and I haven't had any windows-specific trouble with stuff not being available
17:02:02 <glguy> xenon-: Unless you're proposing that there's a wave of Haskell developers on Windows intentionally not supporting the platform they use
17:02:13 <tieTYT> Solonarv: what kind of apps do you build?
17:02:40 <Solonarv> nothing major, I'm working on a game ATM
17:02:50 <tieTYT> does it have networking?
17:02:50 <hpc> "nothing major"
17:02:52 <dataN> sometimes its important not to rely on 3rd party firewalls
17:03:19 <xenon-> glguy no, I'm proposing the opposite. that there are just a lot less windows developers using haskell, not that they are less likely to support what they use. I have no proof though
17:04:00 <dataN> or at least, to keep as much of the program in the type safe haskell environment
17:04:18 <Solonarv> no, but the network package is *exactly* what you're talking about: a low level socket interface
17:04:29 <dataN> type safe networking...
17:04:51 <Solonarv> I was responding to tieTYT
17:05:11 <tieTYT> anyway, I’ll try snap out on my work’s mac on monday
17:05:27 <tieTYT> thanks for the help
17:05:46 <dataN> isnt a kind of virtual environment important for testing for deployment on embedded systems?
17:06:00 <dataN> is there a way to run GHC on every node of a graph?
17:07:12 <dataN> i guess it would need a memory regester and virtual processor... maybe possible
17:07:28 <hpc> this is why i run all of my code in dosbox
17:08:05 <dataN> but a haskell solution...
17:08:44 <dataN> there is halvm for the XEN hypervisor, but thats bare metal, so no good for this kind of virtualisation
17:09:22 <dataN> it does not form a monad...
17:09:26 <hpc> heh
17:13:55 <dataN> easier to use FFI to provide access to android/IOS networking than graphics e.t.c. a lightweight middle layer seems reasonable
17:15:36 * hackage slick 0.1.0.1 -   http://hackage.haskell.org/package/slick-0.1.0.1 (ChrisPenner)
17:19:25 <slaterr> f
17:21:57 <abueide> can I install a wifi driver from source to a live disk so I can run the installation?
17:22:18 <abueide> or does it require a restart which will wipe the driver
17:22:47 <abueide> wrong channel again xd
18:43:02 <rotaerk> Reading the source for easytensor and it's a lot of new stuff for me
18:45:01 <rotaerk> Data kinds, type classes with instances that are, themselves, type level values...
18:56:36 * hackage sbv 7.10 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-7.10 (LeventErkok)
19:12:48 <insiemination> why isn't idris being properly developed, despite being a new and improved haskell without haskell's decades of cruft ?
19:13:35 <glguy> It's not a new improved haskell, it's different
19:13:48 <suzu> it's not a haskell at all
19:13:52 <suzu> is this a joke
19:15:50 <insiemination> it's a new and improved, so obviously it isn't haskell, as haskell isn't new or improved
19:16:33 <suzu> good troll
19:16:35 <suzu> 3/5
19:23:19 <dmwit> http://www.vex.net/~trebla/humour/tautologies.html #2
20:02:12 <mnoonan> :}:}
20:02:23 <mnoonan> hey, you're not ghci!
20:56:36 * hackage slick 0.1.0.2 -   http://hackage.haskell.org/package/slick-0.1.0.2 (ChrisPenner)
21:02:47 <pavolzetor> hello, when writing parser, do you keep all errors in the internal state of the parser?
21:03:47 <pavolzetor> Currently I append to a list inside the state, but it seems quite clunky
21:13:33 <rotaerk> holy crap
21:13:40 <rotaerk> just read through half of https://www.schoolofhaskell.com/user/thoughtpolice/using-reflection
21:13:55 <rotaerk> the way reify works is such a hack
21:14:33 <rotaerk> writing code that exploits knowledge of what the compiler happens to write
21:15:33 <rotaerk> clever but so evil
21:16:15 <iqubic> I don't know what reify is, or what haskell reflection is.
21:16:34 <rotaerk> I didn't either
21:16:56 <Squarism> I want a time based scheduler that can easily be persisted. Also need functionality for modifying and deleting future events.  Anyone got some heads up on that?
21:17:09 <iqubic> Why did you read that rotaerk>
21:18:38 <rotaerk> it was mentioned in the comments for a library I'm trying to use
21:19:11 <rotaerk> as inspiration for something it does, I guess
21:24:03 <iqubic> rotaerk: th implementation of reifies literally uses magic.
21:24:44 <iqubic> newtype Magic a r = Magic (forall (s :: *). Reifies s a => Proxy s -> r)
21:25:04 <rotaerk> yep
21:26:12 <iqubic> I dont understand that yet,
21:28:02 <rotaerk> I don't really understand the need for the Magic type, myself
21:28:41 <rotaerk> I mean, why couldn't they just have done: reify a k = unsafeCoerce k (const a) Proxy
21:28:50 <iqubic> I'm only part way through that article.
21:31:14 <JuanDaugherty> despicable
21:31:17 <iqubic> My favorite part of the article:
21:31:19 <iqubic> We're about 80% of the way to understanding reflection. Only 80% left!
21:31:33 <iqubic> Feels about right to me.
21:35:59 <iqubic> Why would one ever use reflection in haskell ever?
21:39:57 <iqubic> Also, why the heck is Proxy a thing?
21:42:29 <rotaerk> I'll just assume that the need for Magic is tied to the underlying details of the code the compiler generates
21:42:38 <rotaerk> which the article seems to have watered down a bit
21:43:23 <iqubic> I guess it must be that.
21:46:10 <rotaerk> I also still don't quite understand what the "configurations problem" is
21:46:21 <rotaerk> it's described rather abstractly
21:48:14 <iqubic> Yeah. I don't get it.
21:48:27 <rotaerk> it seems like it's a way of doing something like a ReaderT without the ReaderT
21:51:52 <iqubic> why do you say that?
21:53:21 <rotaerk> well a ReaderT c m a is basically an action in monad m that also has access to read something of type c, which could be said to be a configuration
21:53:46 <rotaerk> so it's like a hidden/implicit argument to every action within that monad
21:54:36 * hackage language-bash 0.7.1 - Parsing and pretty-printing Bash shell scripts  http://hackage.haskell.org/package/language-bash-0.7.1 (KyleRaftogianis)
21:54:44 <infinisil> You can pass the argument to every function explicitly
21:54:57 <rotaerk> alternatively, you could say that:  c -> a -> b  is isomorphic to  a -> Reader c b
21:55:11 <rotaerk> well no,  a -> c -> b
21:55:27 <infinisil> Both actually :)
21:57:04 <rotaerk> so yeah, that's what I understand to be a solution to the problem of passing a configuration around throughout your code
21:57:20 <rotaerk> which is what i'm guessing this "configurations problem" is referring to, and somehow reflection is a solution to
21:58:36 <rotaerk> maybe I'll just dive into that pdf (http://okmij.org/ftp/Haskell/tr-15-04.pdf)
21:59:37 * hackage reqcatcher 0.1.1.0 - A local http server to catch the HTTP redirect  http://hackage.haskell.org/package/reqcatcher-0.1.1.0 (hiratara)
22:04:37 * hackage string-random 0.1.1.0 - A library for generating random string from a regular experession  http://hackage.haskell.org/package/string-random-0.1.1.0 (hiratara)
22:05:37 * hackage quickcheck-string-random 0.1.1.0 - Helper to build generators with Text.StringRandom  http://hackage.haskell.org/package/quickcheck-string-random-0.1.1.0 (hiratara)
22:34:07 * hackage email-header 0.4.1 - Parsing and rendering of email and MIME headers  http://hackage.haskell.org/package/email-header-0.4.1 (KyleRaftogianis)
22:47:57 <_gatsby_>  
23:01:19 <Taslem> Is it possible to use GHC Generics in order to derive "Show" for `data Pair a b = Pair a b`?
23:01:33 <Taslem> Specifically, to generate an instance `instance (Show a, Show b) => Show (Pair a b)`
23:02:03 <Taslem> (I want to generalize this, it's just an example - I'm not interested in "Show" in particular per se)
23:15:26 <aarvar> does lens have anything for deriving "Of" versions of functions from functions which use Functor/Foldable/Traversable?
23:20:10 <Zemyla> Is there a way to make calculations that can be interrupted, serialized, and then resumed on another machine?
23:22:04 <pavonia> You could write an AST for those and add a Binary instance
23:46:07 * hackage snaplet-customauth 0.1.1 - Alternate authentication snaplet  http://hackage.haskell.org/package/snaplet-customauth-0.1.1 (kaol)
