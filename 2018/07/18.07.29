00:40:57 <thevishy> what is (x : xs) and [x, xs] in sum (x:xs) = x + sum xs  and product [x, xs] = x * product xs respectively?
00:41:05 <revskill> c_wraith: ahh, thanks you. Thinking in composition is exactly what monad about
00:41:18 <thevishy> when do we prefer the (x : xs) notation over [x, xs]?
00:42:41 <ni638629> slm
00:42:58 <geekosaur> [x,xs] is a list of exactly two elements. (x:xs) is the head of the list, and the rest of it
00:43:30 <geekosaur> as such, I suspect your "product" is wrong
00:44:27 <revskill> thevishy: (x:xs) is used in pattern matching :)
00:44:35 <thevishy> ah it is from a quiz from eric meijer's lecture
00:44:48 <mniip> 'product [x, xs] = x * product xs' would be an occurs check unless * is not the * from Prelude
00:46:08 <thevishy> so [x, xs] is basically meaningful?
00:46:21 <thevishy> if I call it with [1,2,3]?
00:46:32 <geekosaur> that's an error
00:46:41 <thevishy> and how about [1,2]?
00:46:41 <geekosaur> as I said, [x,xs] is exactly two elements
00:46:48 <geekosaur> that one is valid
00:46:56 <thevishy> aha that's intersting
00:47:01 <geekosaur> the other throws an exception unless some othe pattern covers it
00:47:20 <thevishy> so is there a way to make product [x, xs] = x * product xs work?
00:47:30 <geekosaur> not with the standard *
00:47:38 <thevishy> aha
00:47:57 <thevishy> why?!
00:48:30 <geekosaur> because ypu'd be multiplying a scalar by a list, or telling it that a list of some type is "the same as" a value of that type
00:49:13 <pingu_> thevishy: what's wrong with product x:xs = x * product xs?
00:49:20 <geekosaur> need parens
00:49:23 <ab9rf> parens
00:49:28 <pingu_> sure but
00:49:32 <thevishy> pingu_:  I am just checking eric meijers fp101x exercises
00:49:38 <pingu_> oh ok
00:50:02 <c_wraith> I feel like haskell would be a lot easier to learn without the syntactic sugar for list matches
00:50:10 <pingu_> yeah
00:50:12 <pavonia> thevishy: In `product [x, xs] = x * product xs`, what would be the type of product?
00:50:22 <thevishy> yeah i guess sometimes u should just care less about the sugars
00:52:05 <thevishy> pavonia: that is a bounder
00:52:09 <thevishy> bouncer*
00:52:21 <geekosaur> anyway [x,y] is x:y:[] and [x,y,z] is x:y:z:[]. it's convenient but confusing (and especially confusing if you have Prolog experience, because the pattern match there is [x|xs] instead of x:xs
00:52:46 <thevishy> product [a, b] = a * b just works, sweet
00:53:13 <thevishy> but product [a, b] = a * product b just breaks?!
00:53:23 <thevishy> i would like to understand a bit better
00:53:36 <thevishy> i mean this is a func definition even right
00:53:38 <geekosaur> think about what type "product" would need to have
00:54:12 <thevishy> ok now in case I have a product a = a definition
00:54:14 <thevishy> will that help?
00:54:30 <ZeuPiark> hello
00:54:35 <ab9rf> thevishy: no, it won't
00:54:50 <thevishy> okies I will not it down for learning :-)
00:54:55 <ab9rf> you can't have both "product a = a" and "product [a] = a" at the same time
00:55:53 <thevishy> ah
00:55:55 <ab9rf> again, think about what type "product" has to have
00:56:06 <ab9rf> all of the alternatives have to give product the same type
00:56:27 <thevishy> you mean I can have only one type for product
00:56:36 <thevishy> no overloading concept?
00:56:40 <ab9rf> all of the alternatives have to have the same type signature
00:56:45 <ab9rf> that could be a polymorphic type
00:57:00 <ab9rf> but yes, there is no overloading in the sense that C++ or java allow
00:57:15 <thevishy> aha that is probably where my confusion arose
00:58:31 <thevishy> i have noted it down, i will pick it up when i learn more about haskell. now i am just trying to understand fp.
01:00:03 <thevishy> and by the way I just saw that *this* is a multiple choice answer :-) i need to find the right one :-))
01:00:14 <thevishy> there is product (x: xs) definition as well
01:00:41 <thevishy> product [x, xs] is probably just there to show that something like that exists but it won't work!
01:05:27 <thevishy> product [a] = a, product [a, b] = a * product [b] should work right?
01:05:30 <thevishy> but it doesn't?
01:05:48 <thevishy> I am saying if you have empty element just return that
01:06:01 <thevishy> >> single element list return that
01:06:49 <thevishy> >> double element list, multiply first one with a single element list?
01:08:31 <mniip> no
01:08:47 <mniip> hm
01:08:54 <thevishy> it says non-exhausive patterns
01:08:58 <mniip> thevishy, that specifically does work
01:09:05 <mniip> but it doesn't work for multiplying 3 or more numbers
01:09:15 <thevishy> but it doesn't in my ghci
01:09:15 <mniip> [x, y, z] will not match [a] nor [a, b]
01:09:44 <thevishy> yeah I am just trying out, just to see what happens
01:09:57 <thevishy> I am expectiing it to work for 2 elements as well
01:10:18 <thevishy> mul [a] = a, mul [a, b] = a * mul [b], mul [1] throws be a non-exhaustive pattern error?/
01:10:41 <thevishy> aha  brackes?
01:10:54 <thevishy> no
01:11:19 * thevishy is confused
01:12:14 <Lears> Write the definition in a file instead of the repl.
01:13:06 <Lears> As far as ghci is concerned your mul [a, b] case is you overwriting the mul [a] case.
01:13:34 <Lears> Unless you put them both on one line.
01:14:08 <olligobber> > let mul [a] = a; mul [a,b] = a * mul [b] in mul [1]
01:14:10 <lambdabot>  1
01:14:28 <thevishy> ah okay yes the ghci stuff, i remember having bumped into it Lears
01:14:30 <thevishy> thanks
01:14:53 <thevishy> haskell is a nice language actually :)
01:15:00 <olligobber> agreed
01:16:02 <thevishy> but it takes some time, patience and a healthy obsession for perfection
01:18:09 <thevishy> just like all good ideas
01:23:42 * hackage file-embed 0.0.11 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.11 (MichaelSnoyman)
01:37:39 <sohail> Hey
01:38:28 <sohail> first time using IRC. is this the right place to ask questions about Haskell?
01:38:35 <thevishy> yes sohail
01:38:54 <sohail> thank you Nishant
01:40:20 * thevishy will be back later
01:42:07 <sohail> I'm an absolute beginner, I have two options for learning FP and Haskell. the first one is "Learn you a Haskell" and the other one is "Happy learn Haskell tutorials". which one do you suggest for a good start?
01:45:02 <Lears> I recommend against LYaH, and I've never heard of the other one. Why are you constrained to these options?
01:45:07 <Lears> @where cis194
01:45:07 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
01:45:19 <Lears> Personally I like that ^^
01:46:18 <sohail> Actually I'm not limited by those, i just thought those are good for absolute beginners
01:46:59 <butterthebuddha> I also recommend Real World Haskell
01:47:31 <butterthebuddha> LYaH is good, but I hate the patronizing style it's written in
01:48:33 <butterthebuddha> I also second CIS194; it's a good introduction to core functional programming concepts
01:48:53 <Rembane> Real World Haskell is quite old though.
01:49:25 <butterthebuddha> Rembane: (at least) the first ~10 chapters are still fine
01:51:42 * hackage reservoir 0.2.0.0 - Unweighted reservoir sampling  http://hackage.haskell.org/package/reservoir-0.2.0.0 (haym)
01:54:22 <sohail> Let me give you a little info about myself, maybe it helps. my main source of income is not programming, i studied dentistry after 3 semesters of computer science because of some family problems. but I have a deep passion for programming and I've always loved the ideas of functional programming. that's why I'm dedicated to learning Haskell and my goal is to devolop good quality open source projects with it and also maybe help
01:54:22 <sohail> other people learn Haskell someday. that's why I'm looking for a good start to build a solid base in FP and Haskell.
01:56:40 <cocreature> lyah is good for getting people excited about Haskell but it doesn’t really teach you a sufficient amount of Haskell to get anything done
01:58:15 <butterthebuddha> sohail: Do CIS 194, followed by Data61's fp-course
01:58:31 <butterthebuddha> That's what worked for me
01:58:33 <Rembane> butterthebuddha: Ah, cool, then I haven't looked at them in a very long time, only the dated ones. :)
02:00:30 <sohail> Thank you so much guys. so i guess I start with cis 194
02:10:45 <Cheery> just like you have lambda calculus on giving type for '(Just a)'
02:10:59 <Cheery> is it also done on pattern matching?
02:13:43 <dmwit> Cheery: Yes, all expressions are given a type, including `case` expressions.
02:15:19 <Cheery> dmwit: is it such that it treats a in (Just a) as a variable?
02:15:35 <Cheery> then does the type inference as usual, getting Maybe a
02:15:57 <Cheery> unifying that with the argument of the case
02:16:32 <dmwit> That sounds roughly right.
02:18:36 <Cheery> how does it recognize that pattern doesn't have anything that isn't a pattern?
02:19:02 <Cheery> for example. if I use a function that returns 'Maybe a'
02:19:18 <Rembane> You can only pattern match on constructors.
02:20:02 <Rembane> So if you have a function that evaluates to Maybe a, that is not a constructor.
02:20:16 <Rembane> Function: b -> Maybe a
02:20:21 <Rembane> Value: Maybe a
02:23:13 <Rembane> Cheery: Does this explanation make it more or less clear? :)
02:24:20 <Cheery> Rembane: it kind of makes me a bit more confused. because I see that logically makes sense, but haskell still doesn't let me to match on (foo 5) where fo = Just
02:24:34 <dmwit> Cheery: It is a simple syntactic restriction.
02:24:50 <dmwit> Cheery: Anything starting with an upper-case letter is a constructor. Anything starting with a lower-case letter is not.
02:25:33 <Cheery> and I realise that a pattern would be nothing more than a constructor filled with variables.
02:25:48 <dmwit> Cheery: Actually it is a constructor filled with patterns. =)
02:25:56 <dmwit> Cheery: So `Just (Just foo)` is okay.
02:26:17 <dmwit> Cheery: You can also have a bare variable, e.g. `foo` is okay, even though there's no constructor.
02:26:39 <dmwit> And there's a few other kinds of patterns, too, but they're much less important for now.
02:28:26 <maerwald> someone looking for pattern synonyms here?
02:30:02 <Cheery> dmwit: I think I understand, it has to be a different language.
02:30:47 <Cheery> a dual for the language that produces values.
02:40:44 <Cheery> there is a hidden destructor function.
02:41:40 <Cheery> Maybe a -> (a -> b) -> a -> b
02:44:26 <Cheery> sorry, that was wrong. it is actually. Maybe a -> (a -> b) -> b -> b
02:46:38 <Cheery> in fact, you can drop 'Maybe' there.
02:47:56 <Cheery> fnothing f g = g
02:48:17 <Cheery> fjust = a f g = f a
02:49:15 <Cheery> (fjust 5)(\x -> x + 10)0
02:51:07 <Cheery> you just lost the typeclasses though.. so one would have to work those by hand.
02:52:48 <Cheery> pattern matching is logic programming in disguise
02:53:47 <Cheery> and typeclasses somehow settle on that boudnary
02:53:50 <Cheery> 'boundary'
03:01:42 * hackage hopenpgp-tools 0.21.2 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.21.2 (ClintAdams)
03:14:12 * hackage PortMidi 0.2.0.0 - A binding for PortMedia/PortMidi  http://hackage.haskell.org/package/PortMidi-0.2.0.0 (OlivierSohn)
03:45:35 <sohail> Hey, is it right that even an experienced "imperative" programmer learning functional programming for the first time will look like an absolute beginner?
03:46:02 <dstolfa> sohail: that totally depends on the person
03:46:44 <sohail> dstolfa: how so?
03:47:01 <dstolfa> it is true that you won't be able to directly implement a whole bunch of things that you're used to in your previous language of choice, but that is true for any programming language which changes the paradigm a little bit until you get used to it
03:47:17 <dstolfa> sohail: well, i've seen people learn quickly and i've seen people learn slowly depending on their attitude
03:47:33 <liste> sohail: relying on your imperative experience is usually harmful if you learn functional programming
03:48:11 <liste> sohail: some things that carry over from knowing imperative programming is stuff like code editing, compiling, using tools, organizing code
03:48:52 <sohail> dstolfa: I see.
03:49:54 <sohail> liste: well, with a little bit of exaggeration, this is like saying "nothing" carries over.
03:50:38 <dstolfa> sohail: sure it does, it's just a different underlying model of computation. all your algorithmic knowledge carries over which is the most important bit
03:50:43 <dstolfa> it just may look a little different
03:52:14 <hjt> i often hear that learning a functional language 'makes you a better imperative programmer'
03:52:24 <hjt> irrelevant of if that's true or not, do you think the converse is true?
03:52:33 <adjofun> I think, most valuable thing for "imperative" programmer in functional languages is to forget about temporal dependencies between lines of code
03:53:28 <lavalike> good idea, it's less about "do this then this then this" and more about "take this data transform it this way and then this way and then this way" till the result you want
03:55:11 <sohail> I've always had a question about Haskell. if all we do is using functions, then what happens if we don't have a function to use? your answer will be "so make your own function which does the job". ok i understand, so what now? isn't the syntax INSIDE the new function imperative? i can't get my head around it. is everything done with functions?
03:55:41 <p0lyph3m> in fp , you "live" in rhs land ; no lhs assignments ; one huge expression ; no statements
03:55:42 <butterthebuddha> sohail: the fundamental operation in functional programming is the composition of functions
03:55:49 <adjofun> hjt: A -> B <=> -B -> -A, therefore, if we take "learning a funclang -> better imperative programmer" as true/false, then "worse imperative programmer -> not learning a funclang" is also true/false =^)
03:56:03 <butterthebuddha> You compose small functions to build up more complex expressions
03:56:36 <butterthebuddha> This will become more clear when you start writing some code
03:56:38 <liste> sohail: some fundamental functions, like addition of integers for example, are implemented in the runtime
03:56:56 <hjt> adjofun: haha, of course
03:56:59 <liste> sohail: and we build more complex functions from those
03:57:21 <dstolfa> sohail: it might seem that way, but it's not. for example, iteration in an imperative language is about doing something over and over, while in functional languages, i.e. lambda calculus itself it's about a function being continuous and being able to find a fixpoint, so people have derived a fix point combinator or the Y combinator if you will, which lets you implement recursion
03:57:36 <dstolfa> and recursion lets you do something over and over again, but it is still just a function
03:57:51 <hjt> sohail: from my little experience, nearly every function you think of can be expressed in one of a few fundamental ways
03:57:57 <liste> sohail: though you could also write programs without using them, just starting from pattern matching
03:57:59 <hjt> sohail: e.g. as a map over a list
03:58:01 <sohail> Ah i got it, you build complex from VERY simple stuff?
03:58:14 <butterthebuddha> sohail: you do so in imperative programming to
03:58:26 <hjt> if you just look at the things you can build with map, fold, and scan in haskell
03:58:32 <butterthebuddha> too*
03:58:34 <hjt> i think it's pretty impressive
03:58:43 <adjofun_> sohail: to break your head even more, we don't have any variables, or binds here, we have only functions, which may coincedentally have zero arguments =^)
03:58:45 <butterthebuddha> The most basic operations like arithmetic and system libraries are provided by the compiler
03:58:55 <butterthebuddha> You use those to build complex programs
03:59:02 <liste> sohail: if you start from data constructors and pattern matching, you can basically implement any program
03:59:11 <dstolfa> adjofun_: you could have said that in a more convoluted haskellian way, such as functions with arity 0
03:59:23 <dstolfa> or valence perhaps
03:59:33 <liste> sohail: eg. "data MyBoolean = MyTrue | MyFalse; myNot MyTrue = MyFalse; myNot MyFalse = MyTrue"
03:59:47 <liste> sohail: you can go that way to implement and, or etc
04:00:00 <liste> sohail: and do a similar thing for natural numbers
04:00:21 <adjofun_> dstolfa: I am sure if I wanted to, I could describe it with n-category stuff too =:)
04:00:30 <adjofun_> иге ерфеы тще еру зщште
04:00:39 <adjofun_> not the point of it, sorry
04:00:49 <liste> sohail: "data MyNat = Zero | Succ MyNat" -- that way you can construct arithmetic from first principles
04:01:12 <sohail> adjofun_:  interesting LOL, I've always hated keeping track of those variables in imperative langs.
04:01:20 <dstolfa> adjofun_: i'm sure you could. you know, you could also explain simply typed lambda calculus by deriving a cubical interpretation of homotopy type theory, ending up with the calculus of constructions and breaking it down until you only had terms depending on types
04:01:32 <sohail> butterthebuddha: I see
04:01:58 <hjt> lol i like that idea: teach a course on haskell for beginners by starting with cubical homotopy type theory
04:01:59 <butterthebuddha> sohail: What adjofun_ mentioned is a simple trick; if you want to assign a variable to a value, you simply wrap that in a function call
04:02:12 <sohail> liste: i see
04:02:15 <p0lyph3m> in fp , you "live" in rhs land ; no lhs assignments ; one huge expression ; no statements
04:02:19 <lavalike> sohail: a friend had a funny explanation of how the body of a function compares to imperative ones: it's like writing C but the body of your function can ONLY be { return <expression>; } :)
04:02:28 <adjofun_> dstolfa: my math-foo is not strong enough yet for this =)
04:02:52 <maerwald> lavalike: expressions in C can have arbitrary side effects though
04:03:04 <lavalike> maerwald: yeah it only goes so far, but it does give an idea!
04:04:25 <sohail> lavalike: haha, exactly.
04:11:15 <adjofun_> "variables" in Haskell is a misnomer: assigned value doesn't vary. Better term for this would be something like "bind", but that is already taken by (>>=). How would it better be to call those? Assignments?
04:11:38 <hjt> variables are just constant functions, no?
04:11:41 <hjt> of arity 0
04:11:49 <p0lyph3m> named values
04:12:03 <mniip> adjofun_, "binders"
04:12:09 <maerwald> adjofun_: binding
04:12:15 <mniip> "bindings" yes
04:12:18 <ab9rf> bindings would be the term i would prefer
04:12:21 <mniip> also "points" in some literature
04:12:29 <p0lyph3m> value handles
04:12:43 <dstolfa> mniip: wouldn't points be any program? ;)
04:12:51 <ab9rf> i'd also object to referring to values as being "functions of arity 0"
04:13:00 <mniip> dstolfa, some programs are "point-free"
04:13:01 <hjt> ab9rf: why so?
04:13:06 <p0lyph3m> points , like in point free
04:13:09 <dstolfa> mniip: not if you interpret types as spaces
04:13:10 <p0lyph3m> ?
04:13:11 <dstolfa> mniip: :))
04:13:25 <mniip> ???
04:13:33 <ab9rf> because, at some level, all functions in haskell take exactly one argument
04:13:37 * dstolfa 's joke falls flat on its face
04:13:40 <dstolfa> mniip: HoTT
04:13:48 <mniip> your joke is not very mathematically sound
04:13:52 <dstolfa> mniip: it actually is
04:13:54 <mniip> they're points in spaces too
04:14:02 <dstolfa> mniip: in homotopy type theory, every program is a point in a space
04:14:11 <dstolfa> mniip: so there can't be programs that are not points, as you couldn't construct them otherwise
04:14:16 <hjt> depends on if you look at HoTT from a synthetic or an analytic point of view, no?
04:14:30 <maerwald> conversation derailed
04:14:36 <mniip> that's not what points means
04:14:37 <adjofun_> ab9rf: "x :: () -> a" is the same as "x :: a", no?
04:14:43 <dstolfa> hjt: that would depend on how you interpret intuitionistic logic
04:14:49 <mniip> I'm not talking about programs that are/are not points
04:14:57 <dstolfa> mniip: they're still called points, that's why i was joking about it
04:14:59 <mniip> "point-free" refers to a program that doesn't name any points
04:15:12 <mniip> '\x -> x' vs id
04:15:28 <mniip> the former names the point of whatever space you use the function at
04:15:45 <dstolfa> mniip: i'm well aware, i wasn't being serious, hence the * dstolfa 's joke falls flat on its face
04:16:33 <dstolfa> my point (heh) was a different point also called a point
04:16:43 * dstolfa thinks there are too many points
04:16:45 <ab9rf> adjofun_: the void type is not the same as nothing
04:17:09 <adjofun_> ab9rf: That is not a Void, that is Unit
04:17:12 <ahihi> adjofun_: why stop there? isn't it really x :: (() -> ()) -> (() -> a)? ;)
04:18:10 <hsn> is there reliable compilation to something other then binary code? java or nodejs would be great.
04:18:19 <adjofun_> ahihi: they all should be isomorphic =)
04:18:20 <hjt> i thought that x :: a and x :: () -> a were just two points of view, like how a point in a space can be either a point or a map from the terminal space to the space itself
04:18:32 <ab9rf> hsn: ghcjs compiles to javascript
04:18:55 <ab9rf> i don't know if anyone has written a codegen for the jvm but it is in theory possible
04:19:25 <hsn> i need to access to more libraries then haskell has
04:19:47 <adjofun_> hsn: there is also a Frege, Haskell to JVM compiler with functionint interop with Java
04:19:52 * dstolfa prods hsn to make them
04:20:19 <ab9rf> hsn: what libraries do you need that haven't been FFIed yet?
04:20:39 <hsn> i used haskell about 8 years ago, stopped due to lack of libraries.
04:21:14 <hsn> currently working on project which is combination of hadoop and pytorch.
04:21:37 <ab9rf> hjt: () -> Int is not equivalent to Int
04:21:59 <adjofun_> ab9rf: but it is tho
04:22:04 <hjt> ab9rf: why not?
04:22:05 <madnight> hsn: what kind of libraries are you missing?
04:22:14 <ahihi> they are isomorphic (disregarding bottoms)
04:22:33 <readertio> eta is compatible with an older version of GHC and allows you to use both haskell and java libraries
04:22:54 <p0lyph3m> ab9rf: () can always be constucted out of thin air
04:23:10 <ab9rf> i realize that they're conceptually the same
04:23:14 <ab9rf> doesn't mean they're the same
04:23:37 <adjofun_> ab9rf: yeah, they are isomorphic, not equal =)
04:23:55 <hjt> is there any practical difference between them though? in actual haskell
04:24:23 <hjt> sure, equality is 'evil'
04:24:25 <adjofun_> hjt: you would be insane to use something like "f :: () -> a" in real code
04:25:31 <hjt> adjofun_: fair enough, can't really imagine a case when i'd want to...
04:25:55 <ab9rf> adjofun_: and you'd have to actually specify the () when you use it
04:26:40 <ahihi> are  f, g :: () -> a; f () = x; g _ = x  the same?
04:26:53 <ab9rf> ahihi: no
04:26:57 <ab9rf> well, sorry, yes
04:26:59 <ab9rf> maybe
04:27:01 <ab9rf> :)
04:27:03 <ahihi> ;)
04:27:12 <ab9rf> i don't know if the compiler will treat them as the same
04:27:50 <ahihi> > let f () = 1; g _ = 1 in (g undefined, f undefined)
04:27:52 <lambdabot>  (1,*Exception: Prelude.undefined
04:28:10 <ab9rf> interesting
04:28:11 <hjt> ooh interesting
04:28:24 <ab9rf> it has to actually match () against ()
04:28:27 <adjofun_> :t undefined
04:28:28 <lambdabot> a
04:28:28 <ab9rf> bot doesn't match ()
04:29:14 <adjofun_> g doesn't use it's argument, so it is not evaluated
04:29:45 <ab9rf> like i said, () -> a is not the same as a :)
04:29:53 <hjt> can lambdabot do hoogle searches?
04:29:57 <ab9rf> hjt: yes
04:30:11 <ab9rf> i think it does hayoo too, but i might be wrong about that
04:30:42 <ab9rf> hsn: you never said what libraries you were missing
04:30:47 <hjt> :t const
04:30:48 <lambdabot> a -> b -> a
04:30:59 <hjt> :t const 1
04:31:00 <lambdabot> Num a => b -> a
04:31:12 <ab9rf> :t const "hi"
04:31:13 <lambdabot> b -> [Char]
04:31:22 <ab9rf> numbers are almost always a bad example :)
04:31:31 <hjt> yeah, realised that just after doing it
04:31:33 <hjt> woops
04:31:42 <ab9rf> because numeric constants are polymorphic
04:32:09 <hsn> ab9rf: I missed HDFS and CQL libraries.
04:33:17 <ab9rf> hsn: cql is a language, not an api
04:34:22 <ab9rf> amd there are hdfs bindings for haskell
04:34:24 <hsn> its api for cassandra storing data in different format then thrift api does.
04:34:32 <ab9rf> https://github.com/kim/hdfs-haskell
04:34:51 <hjt> hmm, i always think of points in a space X as maps from {*} to X
04:35:05 <hjt> naively assumed that this would be the same point of view in haskell too
04:36:36 <ab9rf> there is a cassandra cql binary package in hackage
04:36:41 <ab9rf> called, oddly enough, cql
04:51:02 <hsn> i suspect that hdfs biding is for very old hdfs version, they broke birary compatibility in API several times, need to do smoke check
04:54:05 <maerwald> man I hate haskell tooling. Trying every weekend if any of hie, ghc-mod or intero is less broken, but no
05:09:12 * hackage qchas 1.1.0.1 - A library for implementing Quantum Algorithms  http://hackage.haskell.org/package/qchas-1.1.0.1 (23ars)
05:13:32 <atchoum> can you help to parse something like this: [Name[Attr1=1][Attr2=2][Attr3=3]] ?
05:13:48 <atchoum> I wonder if there is a builtin way to do that in Haskell ?
05:14:45 <asheshambasta> Has anyone tried using Esqueleto on a more recent GHC version? I'm using stack but it looks like its no longer maintained
05:15:12 <asheshambasta> I'm trying to play with Beam in the meantime but as a beginner, there's just too much type-level stuff going on for me to be comfortable with it
05:15:56 <atchoum> what's the statu quo for regexp in haskell ?
05:16:25 <ab9rf> atchoum: regexps are evil and should not be used
05:16:45 <atchoum> ab9rf yeah but what can you propose me for parsing my string ?
05:16:54 <atchoum> instead of regexps ?
05:16:59 <ab9rf> atchoum: a parser
05:17:13 <atchoum> so I asked the parsing lib to use. Do you have an answer ?
05:17:25 <ab9rf> the usual goto is (mega)parsec
05:17:38 <atchoum> k, I was afraid it could be a little bit overkill
05:17:43 <ab9rf> why?
05:17:55 <atchoum> because it can probably do much more than what I want to do with it.
05:17:58 <ab9rf> so?
05:18:06 <atchoum> and also I am not sure it is in the prelude
05:18:23 <ab9rf> it's not in prelude, but neither are any of the regexp libraries
05:18:41 <atchoum> I thought basically I could write my own microparser
05:18:45 <ab9rf> you can, sure
05:18:49 <atchoum> but I am a relatively new comer to the field
05:18:54 <ab9rf> if you enjoy reinventing the wheel
05:19:46 <ab9rf> i would not hesitate to use megaparsec for that
05:20:06 <ab9rf> it's a really easy parser to characterize, but that's not a reason not to use it
05:21:52 <typetetris> hmm. I build my own ghc from sources and if i want to link something with it, the linker complains about unresolved symbols to pthread from the runtime. Adding `-l pthread` option solves that. Shouldn't it add the option automatically if the runtime needs pthread?
05:25:36 <atchoum> ok I go for parsec
05:36:13 <typetetris> strange can I build ghc in a way it always links in pthread?
05:38:42 * hackage OpenGL 3.0.2.2 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-3.0.2.2 (SvenPanne)
05:39:42 * hackage GLUT 2.7.0.14 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.7.0.14 (SvenPanne)
05:50:10 <Gurkenglas> Looking for a lens oneliner for Applicative f => ([(i,b)] -> c) -> (a -> f [b]) -> [(i,a)] -> f c
05:55:17 <Gurkenglas> In fact the first argument has form map _ if that helps
05:55:26 <juhp> hmm, Setup.hs is optional for Hackage uploads?
06:00:18 <madnight> juhp: jup
06:01:19 <Gurkenglas> so Applicative f => ((i,b) -> c) -> (a -> f [b]) -> [(i,a)] -> f [c]
06:05:45 <cocreature> :t \f g -> traverse (\(i, a) -> map (\b -> f (i, b)) <$> g a)
06:05:47 <lambdabot> (Applicative f, Traversable t1) => ((a, b1) -> b2) -> (t2 -> f [b1]) -> t1 (a, t2) -> f (t1 [b2])
06:05:52 <Gurkenglas> Shouldn't this say it's like a Traversal1? https://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Internal-Bazaar.html#t:Bazaar1
06:07:02 <Gurkenglas> cocreature, that doesn't have that certain lens jenesaispas to it yknow
06:07:36 <Gurkenglas> Currently trying to tweak the type to more clearly ask for that :P
06:07:50 <cocreature> I don’t find it to be particularly useful to try to solve problems using lens if the non-lens solution looks somewhat reasonable
06:12:19 <Gurkenglas> cocreature, I tried to choose the type so that if a solution has the saispas, I can scale it up to what I'm doing
06:13:13 <cocreature> *shrug* that’s too imprecise to give a useful answer. maybe you should tell us what you are actually trying to do?
06:15:11 * adjofun_ smells a XY problem
06:15:42 * hackage greenclip 3.1.0 - Simple clipboard manager to be integrated with rofi  http://hackage.haskell.org/package/greenclip-3.1.0 (erebe)
06:17:45 <nshepperd1> :t \f g -> fmap (map f) . (traverse . _2) (Compose . g)
06:17:46 <lambdabot> error:
06:17:46 <lambdabot>     • Data constructor not in scope: Compose :: b1 -> f b0
06:17:46 <lambdabot>     • Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
06:19:22 <Gurkenglas> Here's something closer to the problem: Take "itoListOf (traverse . selfIndex <. traverse <. f <. traverse)" and add an Applicative side effect to f
06:26:50 <atchoum> is meta programming easy in haskell ?
06:27:10 <Gurkenglas> ((((Maybe I want Bazaar p a b t -> Bazaar (->) a b t?))))
06:29:29 <Gurkenglas> atchoum, the syntax could be better imo, but you can put [| |] brackets around your code and then manipulate it with functions, and use that to calculate code at compile time
06:30:20 <Gurkenglas> The keyword is TemplateHaskell
06:37:54 <reactormonk> Can I use the inferred type of a method in an associated type declaration? I wanna see if I can be lazy and not write a type family declaration
06:49:07 <reactormonk> Anyone happen to have a type family at the hand to convert a function to a list of types where the list are its arguments?
06:52:28 <srid> In 2 weeks I'll be going on a week long vacation to some remote location. No internet; which books or reading materials should I take with me?
06:53:02 <reactormonk> srid, depends on your level
06:53:44 <srid> i'd consider myself intermediate: comfortable with monads, monad transformers, gadts... stuff that you tend to use in general projects
06:54:04 <srid> recently i started looking into TH tutorial. i'm yet to thoroughly read up lens.
06:54:10 <srid> *on lens
06:54:26 <reactormonk> Lens can keep you busy for two weeks.
06:54:50 <srid> I purchased "Conceptual Mathematics: A First Introduction to Categories" - but that's probably not something to open during a week long vacation
06:55:19 <srid> reactormonk: interesting
06:55:35 <srid> ideally i'd be taking this book with me (but it is not released): https://intermediatehaskell.com/
07:23:12 <agnishom> @help
07:23:29 <agnishom> ?wiki monad
07:24:42 <hjt> is there a list of all the things that lambdabot can do somewhere?
07:24:46 <hjt> can't see it on the github page
07:24:57 <agnishom> how about the haskell wikis?
07:25:27 <hjt> ah yeah
07:25:37 <agnishom> @version
07:25:43 <agnishom> How do you use it though?
07:25:47 <hjt> https://wiki.haskell.org/Lambdabot
07:25:58 <Xoryju> Hi, I'm trying to run ag using the Turtle shellStrictWithErr function, but it just returns (ExitFailure 1,"",""). echo and find work, only ag doesn't, any ideas?
07:26:03 <maerwald> pm it, don't use this channel
07:26:18 <hjt> @djinn (a, b) -> c -> (b, c)
07:26:24 <hjt> oh, sorry
07:26:30 <agnishom> why not, maerwald?
07:26:44 <maerwald> because if you are just experimenting it's spam
07:47:40 * hackage structured-cli 0.9.4.1 - Application library for building interactive console CLIs  http://hackage.haskell.org/package/structured-cli-0.9.4.1 (erick)
07:56:07 <Gurkenglas> Ghcmods readme links to the 404ing https://raw.githubusercontent.com/DanielG/ghc-mod/master/Library-API-Redesign.md
08:48:55 <lin__> can I somehow do something like the following:
08:49:37 <lin__> x = if somethingBool then words . readFile "file" else ["myStr"]
08:50:12 <cocreature> lin__: x = if somethingBool then fmap words (readFile "file") else pure ["myStr"]
08:50:42 <cocreature> lin__: but at this point I would recommend that you try to learn a bit about IO in Haskell, e.g., using https://www.vex.net/~trebla/haskell/IO.xhtml
08:51:05 <glguy> lin__: It looks like you're misunderstanding how operators parse with how you used .  (separate from learning about IO)
08:51:22 <glguy> a . b c      means     a . (b c)
08:51:53 <lin__> cocreature: thanks a lot, I will try that and next time I get the chance I will also read the link carefully
08:52:53 <lin__> glguy: yeah, have the time I am not sure if I use it correct or not or ever i should be using $ or just parens, but I am learning and getting the hang of it I hope (reading is no problem, just writing coreectly)
08:53:20 <glguy> lin__: If you're just learning you should stick with ()s and forget about $ or . for a bit
09:04:14 <lin__> I used cocreature help but now x is of IO [String] and that connot be matched with [String] and I am not sure how to handle that, sorry for my overly amateur questions
09:04:56 <lin__> is liftIO the way to go?
09:05:06 <glguy> You'll figure that out reading the link cocreature gave
09:17:54 <ChaiTRex> What is $$( ... ) in Template Haskell syntax?
09:19:54 <cocreature> ChaiTRex: it’s a typed template Haskell splice
09:20:53 <ChaiTRex> cocreature: Thanks. That gives me something better to search for.
09:23:19 <cocreature> ChaiTRex: fwiw https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#th-syntax can be helpful for figuring this out
09:27:03 <lin__> is there a function that takes a FilePath and if the file exists returns the contents otherwise ""? Or is that too uncommon.... (I am still trying to avoid my own conditional IO)
09:27:57 <sm> lin__: that wouldn't be a very idiomatic haskell API, but you could write it easily enough
09:29:07 <ChaiTRex> cocreature: Thanks.
09:32:15 <sm> lin__: doesFileExist f >>= \exists -> if exists then readFile f else return ""
09:33:03 <dmwit> lin__: `try (readFile foo) :: IO (Either IOError String)` would be my preferred way.
09:34:07 <dmwit> You probably already have to have a conditional for whether you see an empty string or not; just replace that with "did I see a Left or not" instead.
09:35:58 <dmwit> My second favorite is `handle (\e -> const (return "") (e :: IOError)) (readFile foo)`.
09:36:39 * hackage haskell-ci 0.1.0.0 - Cabal package script generator for Travis-CI  http://hackage.haskell.org/package/haskell-ci-0.1.0.0 (HerbertValerioRiedel)
09:37:32 <dmwit> But I would use that *only* in case there was no existing conditional checking for empty strings.
09:50:48 <Haskellkitty> Hello all, I learned some Haskell still a noob but can write tiny programs....since I badly need a job anyway can I prepare now only for jobs I just liek Haskell not other languages
09:53:05 <glguy> If your primary goal is to get a job, learning Haskell isn't the best use of time. There are languages with more job opportunities
09:53:44 <Haskellkitty> glguy language just a tool right ?
09:54:54 <Haskellkitty> Why do employers care which language I use ?
09:55:07 <Haskellkitty> I dotn have any experience
09:55:11 <Haskellkitty> Not sure how it works
09:55:39 <koala_man> why employers care which tools you're capable of using?
09:56:20 <Haskellkitty> May be my field little different
09:56:50 <dmwit> If you were programming in a void, your employer likely would not care what tools you used as long as you got the job done. But you aren't: you are programming in the context of a company-full of employees, so a shared tool is important; and likely will be working in the context of an existing codebase, so smooth interoperation with existing code matters.
09:57:39 <Haskellkitty> Ok
09:57:52 <dmwit> "As long as you got the job done" is also an important consideration. Haskell has a growing library base, but it pales in comparison to certain popular languages, and that may be an impediment of its own kind.
09:59:14 <Haskellkitty> If I ask suggestions for applying new jobs ? What you suggest I will learn python or JavaScript I think they are easy
09:59:50 <Haskellkitty> But again learning just programming don't fetch job right
10:00:43 <Haskellkitty> I am college passout without job and not understanding which side should I move web Dev or devops or Linux admin or system programming
10:01:09 <Haskellkitty> I don't know how which is good I just learned some Haskell
10:01:21 <Haskellkitty> Not developed anything
10:01:30 <cocreature> all of those are areas that have a decent number of jobs. find what interests you and look for the requirements for jobs in that area
10:03:18 <Haskellkitty> Thanks
10:13:11 <sohail> I'm wondering why people still use IRC when we have things like quora, whatsapp, stackexchange etc?
10:13:37 <sohail> I'm asking this because this is my first day here.
10:14:57 <glguy> sohail: IRC allows for immediate discussions where something like Quora or StackExchange have a much slower pace are more rigid in the kinds of discussions that can happen on them. IRC has lots of different clients and tooling built around it to it works well across a range of environments
10:15:18 <glguy> and there's an existing active community built here so its easy to find knowledgeable people to communicate with
10:18:44 <sohail> glguy: I see, what's this IRC at its core? some application on top of internet like the web and email?
10:19:54 <sohail> I know this place is for Haskell, it just came to my mind. sorry if it's irrelevant.
10:20:08 <glguy> Yeah, it's like those in that it's a standardized protocol implemented across a range of client and server implementations that all interoperate.
10:33:12 <wz1000> Is there any one single file that uses every haskell/ghc feature known to mankind?
10:33:18 <wz1000> For testing purposes
10:37:27 <madnight> wz1000: i guess that is not possible since some language extensions are mutual exclusive
10:39:22 <wz1000> well, a broad range anyway
10:44:33 <badzergling> is there a cover tree implementation in haskell somewhere?
10:44:43 <badzergling> (or similar)
10:55:52 <madnight> wz1000: not in one file but these 33 folders contain a very common subset https://github.com/sdiehl/wiwinwlh/tree/master/src
11:02:35 <cocreature> badzergling: I vaguely recall seeing one in hlearn. that lib was no longer actively maintained last I checked but you should still be able to steal the code
11:02:44 <mekeor> what's the best resource to learn how to develop haskell projects {with Nix package manager}/{on NixOS}?
11:03:31 <cocreature> mekeor: https://github.com/Gabriel439/haskell-nix should get you started
11:04:15 <monpylon> mekeor: I learned it from gabriel's repository as well, you should really check it out
11:04:38 <mekeor> perfect! thank you both :) – in fact, i was already reading it ;)
11:06:47 <cocreature> I tend to take a slightly different approach that doesn’t consist of generating quite so many files but that’s mostly a matter of taste and if you understand one approach, it’s easy to switch to the other
11:08:05 <madnight> i can also recommend http://funloop.org/post/2015-02-10-using-nix-from-arch.html that's what i used for my first setup
11:09:05 <madnight> it's written for Arch Linux but i think it should work on other distros as well
11:13:43 <greymalkin> If anyone's played with JuicyPixels and JuicyPixels-extra -- do you know why scaleBilinear is coming up for only `Image PixelRGB8` despite specialization
11:14:10 * hackage asciichart 1.0.1 - Line charts in terminal  http://hackage.haskell.org/package/asciichart-1.0.1 (madnight)
11:22:34 <cocreature> greymalkin: what do you by “is coming up for”
11:23:05 <greymalkin> Ah, old version.
11:23:45 <greymalkin> JP-extra has specializations for most integral pixel types; but the earlier versions only have it for PixelRGB8.
11:29:13 <jmcarthur> Is there a way to use () (the constructor, not the type) with DataKinds, or do I just have to define my own type? '() doesn't seem to be accepted.
11:29:44 <jmcarthur> Eh, I may be making a different mistake than I thought I was.
11:29:50 <jmcarthur> I'll just make my own type either way.
11:32:56 <cocreature> jmcarthur: worksforme™
11:34:14 <badzergling> cocreature: hlearn looks pretty promising, thanks!
11:34:37 <zincy_> How do I remove quotes surrounding text when using this library? http://hackage.haskell.org/package/prettyprinter-1.2.1/docs/Data-Text-Prettyprint-Doc.html
11:34:43 <mekeor> cocreature, monpylon: i'm getting a strange error when running `cabal configure` within the nix-shell: https://ptpb.pw/AEcfB-5cti6wosAyrO_Dpj7kI1lC – any ideas?
11:35:31 <mekeor> zincy_: what's the function/action you run?
11:35:44 <geekosaur> zincy_, my guess is you're using Show and shouldn't.
11:37:55 <pikajude> so I know ghc -M generates makefiles
11:38:18 <pikajude> but is there a way to get at the module graph generation step without needing to generate a makefile as an intermediate step
11:38:19 <geekosaur> hm, actually it looks like it should do the right thing with Show, so maybe you're using it twice? can you provide an example of what you're doing??
11:38:34 <cocreature> mekeor: looks like https://github.com/haskell/cabal/issues/3853. maybe try removing both 01-index.tar and 00-index.tar
11:39:05 <madnight> mekeor: have you tried nix-channel --update ?
11:40:01 <cocreature> madnight: this is a cabal error, nix-channel --update is not going to fix that
11:42:13 <zincy_> mekeor : text
11:43:04 <madnight> cocreature: hm thats strange when i convert mekeors cabal file i get a different result https://lpaste.net/1801706422388391936
11:44:08 <cocreature> madnight: read the issue I linked. this is about some existing inconsistent state in ~/.cabal. you won’t be able to easily reproduce this on your system just by using the same cabal file.
11:44:27 <cocreature> zincy_: there is no function called "text" in the module you linked
11:45:13 <mekeor> cocreature: where is 0*-index.tar?
11:45:18 <zincy_> sorry http://hackage.haskell.org/package/pretty-1.1.3.6/docs/Text-PrettyPrint.html
11:46:07 <cocreature> mekeor: ~/.cabal/packages/hackage.haskell.org/00-index.tar
11:46:20 <madnight> mekeor: could you try "cabal2nix . --shell > default.nix" instead of "cabal2nix . > default.nix" ? and then simply type: nix-shell
11:46:26 <cocreature> maybe also remove the tar.gz version and whatever else looks like it belongs to that :)
11:46:33 <lukelau> I want to a have a class function that doesn’t take any arguments, but differs for each type. Is it possible to do this without passing in a dummy value? https://gist.github.com/Bubba/35707b046b2211e35151116440b279e9
11:47:27 <mekeor> cocreature: that fixed it. thank you very much :)
11:48:00 <cocreature> mekeor: yw :)
11:48:04 <geekosaur> lukelau, you either need a parameter or you need to use TypeApplications
11:48:18 <geekosaur> e.g. commandPlugin @Foo
11:48:21 <cocreature> zincy_: text doesn’t add any quotes. are you sure you aren’t misinterpreting the output? what exactly makes you think that it adds quotes?
11:48:43 <cocreature> you also need AllowAmbiguousTypes if you go down the TypeApplications route
11:48:44 <mekeor> madnight: thanks, that wasn't necessary but it's good to know :)
11:48:47 <lukelau> geekosaur: TypeApplications sounds like what I’m after for, thank you!
11:49:04 <cocreature> and at that point I would somewhat question whether you really want to use a typeclass for this
11:49:37 <lukelau> I’m open to other methods of modeling this
11:49:55 <zincy_> could it be this text <AnException>" <+> text (safeHead $ lines $ show myException)
11:50:01 <geekosaur> another way of doing it is a record of e.g. functions, and maybe StateT to carry it around
11:51:22 <cocreature> zincy_: the call to "show" might add quotes
11:51:35 <cocreature> or you look at the final output using show and get quotes that way
11:53:12 <zincy_> thanks a lot Ill try and see if it is that
12:12:20 <zoulock> Hello, I have a beginner question. I want to create a function that takes a string and outputs a list of pairs. For an input "hello", it would output [("","hello"), ("h", "ello"), ("he","llo"), ...]. I tried to define it as f x = map splitAt [0..length x] but I'm not getting what I want.
12:17:19 <verement> zoulock: You might look into some functions like `inits` and `tails` from Data.List
12:18:13 <mekeor> zoulock: f "hi" → map splitAt [0..length "hi"] → map splitAt [0,1,2] → [splitAt 0, splitAt 1, splitAt 2]
12:18:46 <mekeor> > map splitAt [0..length "hi"]
12:18:48 <lambdabot>  error:
12:18:48 <lambdabot>      • No instance for (Typeable a0)
12:18:48 <lambdabot>          arising from a use of ‘show_M223559360252834752620030’
12:18:51 <zoulock> verement: I already know how to work with lists, I'm not new to functional programming, but I wanted to use currying to solve it
12:19:00 <isBEKaml> zoulock: You're close
12:19:07 <isBEKaml> Do you realise where your error is?
12:19:16 <zoulock> No
12:19:38 <mekeor> zoulock: take a look at the evaluation i wrote above
12:20:01 <zoulock> map it again?
12:20:21 <mekeor> you could map again but that would be inefficient
12:20:24 <isBEKaml> zoulock: Right, mekeor showed what happens with your function definition, as it is. What do you see?
12:20:37 <Gurkenglas> Okay I think this could work for my earlier "side effects in an optic" question https://gist.github.com/Gurkenglas/95e81face436bb706af5d197fdd5b98c
12:20:46 <Gurkenglas> glguy, you seem relevant
12:21:22 <mekeor> zoulock: but yes, you need to apply `splitAt` to `x`
12:21:31 <zoulock> yeah
12:21:34 <mekeor> @type splitAt
12:21:35 <lambdabot> Int -> [a] -> ([a], [a])
12:22:01 <Gurkenglas> (I am suspicious of toListOfA needing pure but not liftA2)
12:22:26 <mekeor> zoulock: you might want to use a lambda-function as first argument to `map` instead of just `splitAt`
12:22:47 <isBEKaml> or flip it
12:23:00 <isBEKaml> @type flip splitAt
12:23:01 <lambdabot> [a] -> Int -> ([a], [a])
12:23:09 <zoulock> can't i just create a curried function to do it?
12:23:22 <zoulock> I thougth f = map splitAt [0..]
12:23:31 <zoulock> but I don't know how to apply it
12:23:34 <mekeor> zoulock: yes, with `flip`. but you might first use a lambda-notation to make it work
12:24:01 <isBEKaml> zoulock: Look at the types of splitAt - it takes an Int and an [a]
12:24:46 <isBEKaml> zoulock: you're passing an Int to splitAt, that makes it a partially applied function. So, mapping it, you're only getting a list of partially applied functions.
12:24:52 <isBEKaml> zoulock: complete them :-)
12:25:18 <zoulock> let me try
12:32:56 <zoulock> no idea yet :(
12:33:38 <isBEKaml> Fine - take a look at this type carefully
12:33:45 <isBEKaml> @type splitAt 2
12:33:46 <lambdabot> [a] -> ([a], [a])
12:33:54 <isBEKaml> @type map splitAt 2
12:33:55 <lambdabot> error:
12:33:55 <lambdabot>     • No instance for (Num [Int]) arising from the literal ‘2’
12:33:55 <lambdabot>     • In the second argument of ‘map’, namely ‘2’
12:34:13 <zoulock> @type map splitAt [0..]
12:34:14 <lambdabot> [[a] -> ([a], [a])]
12:34:16 <isBEKaml> @type map splitAt [0..]
12:34:17 <lambdabot> [[a] -> ([a], [a])]
12:34:44 <isBEKaml> When you map, that's the type you get. You don't want a list of functions, but a list of values
12:34:56 <zoulock> true
12:34:58 <isBEKaml> how do you go about fulfilling that?
12:35:10 <fredefox> :t map (splitAt 2)
12:35:11 <lambdabot> [[a]] -> [([a], [a])]
12:35:19 <fredefox> ?
12:35:35 <zoulock> Thats what I'm trying to figure out
12:36:04 <fredefox> > map (splitAt 2) [[1..5], [1..3], [1..2]]
12:36:06 <lambdabot>  [([1,2],[3,4,5]),([1,2],[3]),([1,2],[])]
12:36:08 <isBEKaml> zoulock: mekeor gave you one idea, use lambda expressions. You're only passing 1 argument to splitAt throughout your map. You need 2 per step
12:36:41 <zoulock> but what about making it a partially applied function?
12:37:46 <isBEKaml> you don't want that, right? If you generate a list of partially applied functions, you need another round of iterations - which would be inefficient. Why would you need it when you could do them all in one go?
12:41:40 <LastTalon> I feel like I should join here if I want to learn more about haskell.
12:43:43 <glguy> LastTalon: Yeah, this is a good place to ask questions as you're learning. How far along in learning Haskell are you?
12:44:10 <LastTalon> Not very far.
12:44:10 <c_wraith> It's also a great place to just hang out and watch for answers to interesting questions other people ask
12:48:01 <madnight> c_wraith: btw since when are you hanging around here? must be quite some time : )
12:48:43 <c_wraith> I've been hanging out here since...  oh, 2008?  Most of what I've learned about Haskell has come from paying attention here
12:52:11 <madnight> is there any big txt file irc log of this channel to grep for study purposes?
12:53:11 <c_wraith> the channel subject lists a url for public logging.  You can probably get data from there.
12:55:18 <Gurkenglas> *tinkers around* it worked! >:D https://gist.github.com/Gurkenglas/95e81face436bb706af5d197fdd5b98c
12:56:52 <madnight> hmm maybe one could create a small website with a search interface for these logs, might be useful
12:57:28 <Gurkenglas> But I don't see how this wouldn't just work^tm with monads. Wasn't there something about monadic lenses not working out?
13:04:53 <zoulock> I feel so stupid... f w = map (\x -> splitAt x w) [0..length w]
13:06:33 <isBEKaml> zoulock: well done!
13:06:39 <zoulock> > map (\x -> splitAt x "hey") [0..length "hey"]
13:06:40 <lambdabot>  [("","hey"),("h","ey"),("he","y"),("hey","")]
13:07:03 <zoulock> I feel like I'm overthinking
13:11:34 <madnight> @pl f w = map (\x -> splitAt x w) [0..length w]
13:11:35 <lambdabot> f = ap (map . flip splitAt) (enumFromTo 0 . length)
13:11:58 <hjt> :t ap
13:11:59 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:14:55 <hjt> why is splitAt flipped in that?
13:15:05 <hjt> :t flip splitAt
13:15:05 <lambdabot> [a] -> Int -> ([a], [a])
13:15:14 <Gurkenglas> Where do I get \l f -> iconcatMapOf l (\i a -> [f i a])?
13:15:55 <Gurkenglas> Alternatively written, \l f -> map (uncurry f) . itoListOf l
13:16:42 <glguy> :t ito
13:16:43 <lambdabot> (Contravariant f, Indexable i p) => (s -> (i, a)) -> Over' p f s a
13:16:51 <isBEKaml> hjt: pointfree monsters
13:16:55 <glguy> Not that
13:20:14 <butterthebuddha> Is there any reason to use Int over Integer if I don't particularly care about performance?
13:20:57 <fredefox> Probably not, they are machine integers, 'Integer' is arbitrary size integers.
13:21:15 <butterthebuddha> How much of a performance hit is there?
13:22:19 <fredefox> Depends on what you're doing, but they are significantly different. 'Int' utilizes primitive operations from your architectures instruction set.
13:23:11 <Eduard_Munteanu> @src Integer
13:23:11 <lambdabot> data Integer = S# Int#
13:23:11 <lambdabot>              | J# Int# ByteArray#
13:23:33 <hjt> @src Int
13:23:34 <lambdabot> data Int = I# Int#
13:23:44 <fredefox> I bench-marked a back end I did for the Agda language.  We wrote a back end targetting OCaml.  Agda at the time did not have support for machine integers in the standard back end.  We were essentially comparing apples and pears.
13:23:58 <fredefox> s/I/we/g
13:24:46 <ZeuPiark> bye
13:25:01 <int-e> Eduard_Munteanu: The Integer type is not up-to-date.
13:25:15 <Eduard_Munteanu> Hm.
13:26:53 <int-e> It's basically  S# Int# | Jp# ByteArray# | Jn# ByteArray#  these days.
13:27:25 <fredefox> What's the difference between the 2nd and 3rd constructor?
13:27:31 <int-e> the sign
13:27:35 <fredefox> Ah
13:27:52 <fredefox> ofc :)
13:28:30 <Gurkenglas> What indexed optic from s to a corresponds to "i -> s -> a"?
13:30:47 <c_wraith> as in "get the element at this index"?
13:34:41 <fredefox> When generating haddock for 'haskell-src-exts' I get an error and the message "ignoring (possibly broken) abi-depends field for package.  Sounds familiar to anyone?  I'm using ghc-8.4.3.
13:40:22 <Gurkenglas> c_wraith: As in "We are currently i-index-traversing values of type s. Make us be traversing values of type a instead, where a depends on i and s like so"
13:41:44 <lyxia> fredefox: I've been ignoring that error so far, no idea what it means.
13:42:15 <fredefox> It's just that I can't build the '--hadock-deps' of my package because it breaks in building Haddock for haskell-src-exts
13:42:23 <fredefox> It's a bit annoying
13:42:48 <fredefox> But so I'm not the only one.  That's good to know.
13:43:00 <Gurkenglas> c_wraith: Maybe "IndexedGetter i s a -> Getter s (i, a)"?
13:43:34 <Gurkenglas> (hopefully of form (. _))
13:53:41 <Gurkenglas> How can there be iconcatMapOf but not iMapOf ;_;
13:55:09 * hackage greenclip 3.1.1 - Simple clipboard manager to be integrated with rofi  http://hackage.haskell.org/package/greenclip-3.1.1 (erebe)
14:01:18 <dataN> theorems for free has a powerful converse; that designing programs around theorems known to be true leads to a situation where a chain of reasoning in the form of a class hierarchy built from the bottom up and top down simultaneously is guaranteed to meet in the middle.
14:01:50 <lstdgtfp> In the ghci debugger, is there a good technique for finding out what the input to a function was when it failed in a certain way?
14:05:05 <dataN> usually the most difficult to reason about stage is deferred, in the hope that working from the other side will yield the desired result. this means that if the theorem is known to be true, this most difficult step is given "for free" as a side effect of the haskell type system representing logic. both halfs of the development process are guarantied to converge, and that they do so at the most difficult stage of reasoning is very usefu
14:07:31 <fredefox> lyxia: The issue was addressed in https://github.com/haskell/haddock/issues/837  I've manage to fix it with the ghc-8.4 branch of haddock.
14:12:36 <fredefox> lstdgtfp: Could you print the argument on error?  Sorry if this is a stupid question, maybe I don't understand your question.
14:13:10 <lstdgtfp> I'm not in the IO monad so that's a little harder to do
14:13:21 <fredefox> Just use 'Debug.Trace'
14:14:01 <fredefox> As in 'f x = traceShow x $ problematic x'
14:14:27 <fredefox> Or if you wanna look at the result of 'problematic x': 'f x = traceShowId $ problematic x'
14:15:42 <fredefox> I find that this pattern plays really well with -XViewPatterns as in e.g.: 'f (traceShowId -> x) = problematic x'
14:16:40 <lstdgtfp> I ended up adding a function `traceErr message (Left x) = trace message (Left x)`
14:17:03 <lstdgtfp> chained together with the result of the function, and that worked. Thanks!
14:17:12 <fredefox> No probs!
14:23:31 <revskill> i see that ($) is just infix id
14:23:56 <revskill> what can i understand more about that fact ? function application is just id
14:24:21 <c_wraith> :t ($)
14:24:22 <lambdabot> (a -> b) -> a -> b
14:24:25 <monochrom> Nothing. You're done.
14:24:34 <c_wraith> If you add some parens, (a -> b) -> (a -> b)
14:24:36 <revskill> > (+1) `id` 2
14:24:38 <lambdabot>  3
14:24:41 <c_wraith> same type on both sides of the arrow
14:24:51 <c_wraith> so yeah, it's id
14:25:04 <c_wraith> (that type is too polymorphic to allow other implementations)
14:25:05 <Gurkenglas> "f $ x" = "(f $) x" = "(id f) x" = "f x"
14:26:25 <revskill> Gurkenglas: why (f $) = (id f) ?
14:26:41 <Gurkenglas> (f $) = ($) f
14:27:23 <Gurkenglas> In order for "f $ x" to equal "f x", "($) f" must equal "f", so ($) must equal id
14:28:09 <revskill> from category theory viewpoint, they never say id is function application :|
14:28:31 <geekosaur> because that's a haskellism
14:28:39 <monochrom> category theory isn't all.
14:29:00 <c_wraith> it's function application in a small family of related categories
14:29:07 <pgiarrusso> revskill: in English, you don’t need to “change” the function in any way to apply it to the argument, you just need to apply it, so $ needn’t do anything
14:29:12 <c_wraith> It's certainly not function application in many other categories
14:30:36 <pgiarrusso> revskill: I mean, the point is that f $ x = f x
14:31:19 <revskill> i see, the fun point is that, if you're about to explain what's function application is, you just can't say function application is just id
14:31:33 <pgiarrusso> revskill: that is in fact a valid definition, but it doesn’t do much different
14:31:54 <pgiarrusso> revskill: right, that doesn’t *explain* function application
14:31:57 <revskill> ok, so what is id ?
14:32:10 <c_wraith> depends on the category
14:32:18 <pgiarrusso> revskill: id x = x?
14:32:31 <pgiarrusso> revskill: in which context do you ask about id?
14:32:48 <revskill> in this case you have to define the application of id to x first
14:32:51 <revskill> right ?
14:33:10 <monochrom> Function application requires you to talk about (\x -> foo) y = like foo but put y into x.  You can't just play with "f $ x = f x" and think you understand anything.
14:34:32 <__monty__> @where gentle
14:34:32 <lambdabot> http://www.haskell.org/tutorial/
14:35:00 <pgiarrusso> __monty__: that’s not a very gentle introduction, in fact
14:35:05 <revskill> what i can see from id definition is that, id is a function which never change its type
14:35:12 <pgiarrusso> revskill: if you have questions about function application, I recommend you describe what you already do understand
14:35:13 <revskill> nothing more
14:35:18 <__monty__> pgiarrusso: Yeah, looking for a not-so-gentle intro : )
14:35:33 <pgiarrusso> revskill: it is a function that returns its argument unchanged, full stop
14:35:40 <pgiarrusso> Also called identity function
14:35:47 <__monty__> For someone who's familiar with SML and F#
14:36:07 <pgiarrusso> revskill: “Never change its type” sounds wrong
14:36:13 <geekosaur> revskill, id has nothing to do with function application as such. it just passes its parameter through. the context it passes it into is function application
14:36:16 <revskill> pgiarrusso: ah, i just want to understand function application, which requires me to understand id first
14:36:31 <geekosaur> but it could be some other context instead
14:36:32 <Gurkenglas> Not to be confused with the "identity morphism", which is defined by being the neutral element of "morphism composition".
14:37:15 <pgiarrusso> revskill: geekosaur is right, stop trying to understand function application through id
14:37:46 <dstolfa> i like how every discussion here eventually ends up in category theory
14:37:58 <dstolfa> it's like: "how do i write this simple recursive function in haskell?"
14:38:15 <dstolfa> WELL, IF WE HAVE A K-CATEGORY...
14:38:17 <dstolfa> :)
14:38:24 <pgiarrusso> dstolfa: for once, the person asking brought CT up first, tho I also wonder if that is helpful here
14:38:40 <dstolfa> pgiarrusso: i know, i'm guilty of this quite often
14:38:52 <dstolfa> but it's just an observation, not a critique
14:38:56 <pgiarrusso> That’s why I tried to ask about the background (which IMHO should happen more often)
14:42:16 <Solonarv> You try to understand function application (f x). You insert the "apply" operator: (f $ x). Someone once told you that ($) = id, so you rewrite to (id f x). You add parentheses: ((id f) x). You recall the definition of id, and get (f x). You're back where you started.
14:44:20 <monochrom> CT is never helpful for beginner questions.
14:44:33 <pgiarrusso> monochrom++
14:45:11 <monochrom> Imagine someone learning French and you think you can teach them French by starting with linguistic theory and the Proto-Indo-European language...
14:45:24 <pgiarrusso> monochrom’s hint above was the most helpful
14:45:37 <geekosaur> the only relevance of $ = id here is that it happens to work nicely with Haskell's section syntax, giving us a shorter way to write some things involving partially applied functions. it doesn't define application at all
14:45:44 <pgiarrusso> Is there a FAQ explaining function application and beta-reduction?
14:46:00 <pgiarrusso> Because that’s what we should, ideally, offer
14:46:23 <monochrom> No.  We're generally poor at FAQs.
14:46:39 <monochrom> But it's a one-liner for this particular one anyway.
14:47:36 <buttons840> I want a safe toEnum variant, I am doing IO if that helps (binding to C), any suggestions?
14:47:38 <geekosaur> and if you want to know what's going on with function application in Haskell, it'[s not in category theory, it's in lambda calculus.
14:48:16 <dstolfa> monochrom: what, you mean that teaching people how to program by telling them all about the curry-howard isomorphism and showing them a bunch of logic, followed by category theory and monads to model effects, or perhaps comonads to model coeffects is not the right way to show people hello world?
14:48:21 <dstolfa> hmmmm
14:48:38 <Solonarv> safe toEnum? you mean one that won't have out-of-bounds errors like (toEnum (-24) :: Bool)?
14:50:09 * hackage snap-templates 1.0.0.2 - Scaffolding CLI for the Snap Framework  http://hackage.haskell.org/package/snap-templates-1.0.0.2 (DougBeardsley)
14:51:28 <buttons840> Solonarv: I'm using c2hs to create a type from a bunch of C "#define X 123" macros, c2hs handles this well enough. But there is no guarantee that a related C function I'm binding to (which returns an int) will give me a value that has a related "#define X 123" macro
14:51:56 <Solonarv> okay, that's about what I was imagining
14:52:41 <buttons840> since I'm doing IO, i was thining I could just catch the exception and return Nothing?  (i'm not familiar with the details of haskell exception catching)
14:52:54 <Solonarv> I don't think there's a good way around this issue, you'll just have to assume the return values are valid
14:53:01 <Solonarv> hm. yeah, you could do that
14:53:21 <Solonarv> but you'll end up with things returning Maybe even though they conceptually shouldn't
14:54:07 <Solonarv> you might be better off adding some kind of Unknown or Invalid constructor to your enum, and adding a comment saying that this shouldn't ever be returned
14:54:22 <buttons840> oh, yeah, I'm expecting to return a Maybe x
14:54:22 <Solonarv> that's what the SDL2 binding does for keycodes, for example
14:54:44 <Solonarv> oh if it makes sense for the return value to be Maybe then you can just do that, yeah
14:55:17 <pgiarrusso> revskill: sorry if we failed to help, you might want to look at #haskell-beginners
14:55:48 <buttons840> well, i'm creating the bindings, so I dictate whether maybe make sense or not I guess :)   the "Invalid" suggestion is a good idea though, I'll consider it
14:56:24 <pgiarrusso> dstolfa: how many beginner questions end up in debates about whether this channel is able to answer them (often because we didn't manage)?
14:56:37 <Solonarv> debates, rarely (IME)
14:56:45 <dstolfa> pgiarrusso: :))
14:57:13 <buttons840> Solonarv: heh, the function I'm binding to returns keycodes as well -- do you think using a Maybe or having an "Invalid" data constructor is nicer?  this is pretty much exactly what Maybe is made for, right?
14:58:16 <revskill> pgiarrusso: Hey, i'm researching. And found this helpful: function application is the act of applying a function to an argument from its domain so as to obtain the corresponding value from its range
14:58:17 <Solonarv> in that context, I'd expect Nothing to mean "no key was pressed"
14:59:35 <Solonarv> not "a key was pressed but we don't recognize the key"
14:59:37 <buttons840> Solonarv: another good point, but the function is "get the last key pressed", so the special cases would either be "no key has ever been pressed" or "invalid"
15:00:33 <Solonarv> I would say those should be distinguished, so the return type should be "Maybe Keycode" with "data Keycode = ... | Unknown"
15:00:48 <glguy> Using Maybe is good because you can "validate" a Maybe Key to produce a Key later when you've handle the error case
15:01:19 <pgiarrusso> revskill: that's a better direction
15:03:23 <pgiarrusso> revskill: what monochrom said above also helps. If `f` is defined as `f x = foo`, and you call `f y`, you can replace `f y` by the function body `foo`, but you have to "pass arguments", that is, here, replace in `foo` occurrences of the the formal parameter `x` by the actual argument `y`
15:03:54 <pgiarrusso> revskill: so for instance if you defined `f x = x + 1`, and call `f 5`, you can replace `f 5` by `5 + 1`
15:04:07 <pgiarrusso> and that works for more complicated functions
15:04:20 <pgiarrusso> this is called beta-reduction if you want to search for pointers
15:05:31 <pgiarrusso> I recommend if you google you also mention haskell, otherwise you'll find more theoretical pointers than appropriate...
15:05:35 <pgiarrusso> revskill: does that help?
15:06:01 <revskill> pgiarrusso: yeah, thanks for pointing out. Need more research too
15:07:11 <pgiarrusso> revskill: maybe some beginner book or course will be helpful, https://github.com/bitemyapp/learnhaskell/#how-should-i-learn-haskell can be useful
15:15:25 <piark_> bye
15:56:58 --- mode: ChanServ set +o glguy
15:56:59 --- mode: glguy set -co glguy
16:28:17 <butterthebuddha> Is there a way to get a type that represents integers between m and n, m <= n?
16:30:28 <monochrom> No.
16:30:41 <Solonarv> Nothing built-in, but you can put something together using GADTs
16:33:12 <lavalike> there are built-in types for specific m and ns (=
16:33:55 <butterthebuddha> lavalike: Int8, Int16 and the like?
16:34:27 <lavalike> aye (and Word{8,16,...})
16:34:48 <butterthebuddha> I'm looking for m = 0 and n = 15 :(
16:35:49 <lavalike> is it for modular arithmetic?
16:36:00 <Solonarv> if you're looking for "naturals <= N" that's a bit easier
16:36:10 <Solonarv> I think there's actually a type for that floating around somewhere
16:36:39 * hackage di-core 1.0.1 - Typeful hierarchical structured logging without monad towers.  http://hackage.haskell.org/package/di-core-1.0.1 (RenzoCarbonara)
16:37:40 * hackage di-monad 1.1 - mtl flavoured typeful hierarchical structured logging for di-core.  http://hackage.haskell.org/package/di-monad-1.1 (RenzoCarbonara)
16:38:28 <butterthebuddha> lavalike: nah, it's something really mundane
16:38:40 * hackage di 1.1 - Typeful hierarchical structured logging using di, mtl and df1.  http://hackage.haskell.org/package/di-1.1 (RenzoCarbonara)
16:40:08 <Solonarv> depending on why you need it, it could be as simple as newtype Nibble = MkNibble { unMkNibble :: Word8 }, don't export the constructor, and export a smart constructor instead
16:40:32 <Solonarv> ( a nibble is 4 bits, which is values 0-15 )
16:41:11 <butterthebuddha> A "smart constructor" that only accepts values that fit in 4 bits?
16:42:08 <Solonarv> yes
16:43:20 <butterthebuddha> That doesn't give me type-level guarantees though, does it?
16:44:16 <Solonarv> nope, but if you don't export MkNibble and unMkNibble then nobody can construct an invalid Nibble
16:47:24 <Solonarv> simple example: https://gist.github.com/Solonarv/51e7ab7c4849e0739cd5a4f1b5826922
16:47:43 <Solonarv> pattern synonyms make this sort of abstract data type much easier to use
16:48:41 <hjt> what are pattern synonyms? is that the last three lines?
16:49:38 <butterthebuddha> http://hackage.haskell.org/package/data-fin <- I think this is what I'm looking for
16:50:26 <Solonarv> yep, that's the last three lines
16:50:56 <Solonarv> https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms
16:52:36 <dmwit> Solonarv: gotta write the Num instance by hand
16:53:09 <Solonarv> to conserve the "<= 15" invariant? nah
16:53:26 <Solonarv> as long as you only observe via unNibble you'll get a value in 0-15
16:54:15 <dmwit> Okay, sure. In that case you can skip the mod in mkNibble. =)
16:54:15 <Solonarv> well, I'm assuming the Num Word8 instance does modular arithmetic, which seems reasonable
16:54:26 <Solonarv> also true!
16:55:40 <dmwit> Solonarv: Oh, no, you've derived Eq/Ord.
16:55:44 <dmwit> So that's an observation.
16:56:45 <Solonarv> er, that was just me not thinking
16:57:49 <Solonarv> I've updated the gist if you want to look again
16:58:58 <chessandgo> im using the hedit redis haskell library, and I was wondering how I should deal with deeply nested data types
16:59:20 <chessandgo> any responce from the database will be Right (Just "bytestring")
16:59:37 <chessandgo> where Right/Left is if it error, and Just for what its value
16:59:50 <chessandgo> dealing with anything of this would involve piles of ifs and cases
17:01:09 <Solonarv> if you don't care about the particular error message, you can collapse that into a single Maybe layer using "join . eitherToMaybe"
17:02:01 <chessandgo> im going off the assumption of never getting an error, and if I do, just to quit the program
17:02:55 <chessandgo> im not faimilar with join or eitherToMaybe, can you explain Solonarv ?
17:03:40 <Solonarv> eitherToMaybe :: Either x a -> Maybe a; eitherToMaybe (Left _) = Nothing; eitherToMaybe (Right a) = Just a
17:04:08 <Solonarv> should be in Data.Either; if it's not, just define it yourself
17:04:10 * hackage rollbar-hs 0.3.0.0 - Core Rollbar data types and APIs.  http://hackage.haskell.org/package/rollbar-hs-0.3.0.0 (joneshf)
17:04:35 <chessandgo> thanks! that should work great!
17:04:57 <Solonarv> join :: Maybe (Maybe a) -> Maybe a just "collapses" two layers of Maybe into one
17:05:32 <chessandgo> is that in the maybe module as well?
17:05:57 <Solonarv> that actually has a more general type than the one I gave you
17:06:11 <Solonarv> :i join
17:06:16 <Solonarv> % :i join
17:06:17 <yahb> Solonarv: join :: Monad m => m (m a) -> m a -- Defined in `GHC.Base'
17:06:17 <geekosaur> @src join
17:06:18 <lambdabot> join x = x >>= id
17:07:43 <Solonarv> it's exported from Control.Monad
17:10:03 <chessandgo> ah, thanks, ill have to define my own eitherToMaybe since it seems stack doesnt want to build the extra package 
17:17:36 <dmwit> :t asum . fmap Just
17:17:37 <lambdabot> (Functor t, Foldable t) => t a -> Maybe a
17:17:45 <dmwit> chessandgo: ^
17:18:18 <epta> is there a way to make aeson's encode do not serialize null values?
17:18:19 <dmwit> but...
17:18:31 <dmwit> It would be weird to use that and then `join`.
17:18:45 <dmwit> Just `asum` directly should do for `Either e (Maybe a) -> Maybe a`.
17:19:09 <chessandgo> huh, there really is a function for everything
17:19:26 <chessandgo> dmwit: where is asum defined
17:19:45 <dmwit> Data.Foldable
17:19:59 <dmwit> % :t asum @(Either IOError) @Maybe
17:19:59 <yahb> dmwit: Either IOError (Maybe a) -> Maybe a
17:20:52 <dmwit> epta: What is a null value? Haskell doesn't have them, so "serialize a null value" doesn't make sense to me.
17:21:17 <dmwit> For "deserialize a null", you can just have your Parser throw a `typeError` or similar.
17:22:14 <dmwit> Oh, I know what query I actually wanted.
17:22:20 <dmwit> % :t asum @(Either _) @Maybe
17:22:20 <yahb> dmwit: Either w (Maybe a) -> Maybe a
17:22:24 <dmwit> yes, thank you
17:22:54 <amx> epta: if you mean not serialize Nothing as null, then see http://hackage.haskell.org/package/aeson-1.4.0.0/docs/Data-Aeson.html#v:omitNothingFields
17:22:59 <chessandgo> whats happened with asum . fmap Just, im being tripped up by the fmap part
17:23:17 <Solonarv> % :t fmap Just
17:23:17 <yahb> Solonarv: Functor f => f a -> f (Maybe a)
17:23:23 <Solonarv> % :t Just
17:23:24 <yahb> Solonarv: a -> Maybe a
17:24:03 <hjt> is there any difference between yahb and lambdabot ?
17:24:46 <chessandgo> wont fmap just cause my type to get wrapped in another level of Maybe before calling asum on it?
17:25:08 <dmwit> No, it doesn't add any wrapping. It just "sees through" any existing wrapping.
17:25:34 <dmwit> I was offering an alternative to using an existing `eitherToMaybe`.
17:25:34 <Solonarv> yahb is GHCi + a thin wrapper, and has IO enabled. lambdabot does a bunch of different things, and doesn't have IO enabled
17:25:46 <dmwit> But I don't think it's sensible to do that, for the reasons I suggested above.
17:25:49 <Solonarv> I think yahb also has more stuff imported
17:26:09 <hjt> gotcha
17:26:39 <Solonarv> % :!ls
17:26:39 <yahb> Solonarv: foo; foo2; ghci
17:26:45 <chessandgo> ive have to study this more, ive never seen it used in this way
17:26:50 <Solonarv> ^ works; you can't do that with lambdabot
17:26:52 <chessandgo> but join $ asum . fmap Just $      does do what I need
17:27:13 <dmwit> chessandgo: But don't do that!
17:27:23 <dmwit> chessandgo: Instead just `asum $`.
17:27:27 <chessandgo> (the actual problem I was having was I forgot I mounted /tmp noexec which caused stack to fail)
17:28:34 <dmwit> `join . asum . fmap Just` says: traverse an `Either`, adding a `Just` everywhere; then traverse the `Either` again to turn `Left` into `Nothing` and `Right` into `Just`; then traverse the doubly-nested `Maybe` to turn `Just (Just foo)` into `Just foo`.
17:28:46 <chessandgo> asum . fmap Just $ Right ( Just 1)      is    Just (Just 1)      which is still two layers
17:28:59 <dmwit> Whereas `asum` says: traverse an `Either`, turning a `Left` into `Nothing` and `Right x` into `x`.
17:29:02 <dmwit> Much simpler.
17:29:11 <Welkin> what in the
17:29:15 <dmwit> > asum (Right (Just 1))
17:29:17 <lambdabot>  Just 1
17:29:30 <dmwit> > asum (Right Nothing)
17:29:32 <lambdabot>  Nothing
17:29:36 <dmwit> > asum (Left ())
17:29:38 <lambdabot>  error:
17:29:38 <lambdabot>      • Ambiguous type variables ‘f0’, ‘a0’ arising from a use of ‘show_M76254...
17:29:38 <lambdabot>        prevents the constraint ‘(Show (f0 a0))’ from being solved.
17:29:41 <dmwit> yes, okay
17:29:45 <dmwit> > asum (Left ()) :: Maybe ()
17:29:47 <lambdabot>  Nothing
17:30:36 <chessandgo> > asum (Left (Just 1))
17:30:38 <lambdabot>  error:
17:30:38 <lambdabot>      • Ambiguous type variables ‘f0’, ‘a0’ arising from a use of ‘show_M60719...
17:30:38 <lambdabot>        prevents the constraint ‘(Show (f0 a0))’ from being solved.
17:30:47 <chessandgo> I dont understand why that fails
17:30:53 <dmwit> Because:
17:30:56 <dmwit> :t asum (Left (Just 1))
17:30:57 <lambdabot> Alternative f => f a
17:31:07 <chessandgo> in my GHCI im getting "*** Exception: user error (mzero)"
17:31:24 <dmwit> Yes, because in ghci, the `Alternative` gets chosen to be `IO`.
17:31:39 <dmwit> :t asum @_ @Maybe
17:31:40 <lambdabot> error: parse error on input ‘@’
17:31:46 <dmwit> % :t asum @_ @Maybe
17:31:46 <yahb> dmwit: Foldable w => w (Maybe a) -> Maybe a
17:32:01 <dmwit> % asum @_ @Maybe (Left (Just 1))
17:32:01 <yahb> dmwit: Nothing
17:32:37 <dmwit> chessandgo: Because `Left _` gets turned into `empty`, its type is ambiguous; you have to choose which `Alternative` instance you want.
17:32:52 <dmwit> chessandgo: That is why I added the `Maybe ()` type annotation in my `asum (Left ())` example above.
17:33:21 <dmwit> chessandgo: There are many ways to specify your choice. I've demonstrated two here: using TypeApplications on the `asum`, or using a type signature on the whole expression.
17:33:53 <chessandgo> huh, yeah thats working
17:34:27 <dmwit> > asum (Left ()) :: String
17:34:28 <lambdabot>  ""
17:34:38 <chessandgo> to be honest im really quit lost how all this magic is happening despite knowing Maybe and Either
17:35:05 <dmwit> chessandgo: For Either, `asum (Left _) = empty; asum (Right v) = v`.
17:35:15 <dmwit> There is nothing more to know than that, really.
17:35:23 <chessandgo> so its type class stuff?
17:35:34 <chessandgo> is that how "asum (Left ()) :: String" type checks
17:35:45 <dmwit> > empty :: String
17:35:46 <chessandgo> () being the empty in the monoid just like the empty string
17:35:47 <lambdabot>  ""
17:35:55 <dmwit> No, () is not the empty.
17:36:00 <dmwit> The () is completely ignored.
17:36:19 <dmwit> > asum (Left (\x y z -> x y z z y)) :: String
17:36:21 <lambdabot>  ""
17:36:23 <chessandgo> ah, ah! I see, because it left
17:36:33 <chessandgo> > asum (Right ()) :: String
17:36:34 <lambdabot>  error:
17:36:34 <lambdabot>      • Couldn't match type ‘()’ with ‘[Char]’
17:36:34 <lambdabot>        Expected type: Either a0 [Char]
17:36:40 * hackage rollbar-hs 0.3.0.1 - Core Rollbar data types and APIs.  http://hackage.haskell.org/package/rollbar-hs-0.3.0.1 (joneshf)
17:36:40 <chessandgo> yeah, that fails to check, that makes sence
17:36:47 <dmwit> > asum (Right 'a') :: String
17:36:48 <lambdabot>  error:
17:36:49 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
17:36:49 <lambdabot>        Expected type: Either a0 [Char]
17:36:54 <dmwit> oops =)
17:36:59 <dmwit> > asum (Right "a") :: String
17:37:01 <lambdabot>  "a"
17:37:12 <Welkin> asum is just mconcat for <|>
17:37:22 <dmwit> Roughly, yes.
17:38:01 <chessandgo> so asum works on any monoid, right?
17:38:14 <Welkin> :t asum
17:38:15 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
17:38:52 <Solonarv> % :i Alternative
17:38:53 <yahb> Solonarv: class Applicative f => Alternative (f :: * -> *) where; empty :: f a; (<|>) :: f a -> f a -> f a; some :: f a -> f [a]; many :: f a -> f [a]; {-# MINIMAL empty, (<|>) #-}; -- Defined in `GHC.Base'; instance [safe] (Monoid w, Alternative m) => Alternative (WriterT w m) -- Defined in `Control.Monad.Trans.Writer.Lazy'; instance [safe] (Functor m, MonadPlus m) => Alternative (StateT s m) -- Defin
17:38:53 <Welkin> :t mconcat
17:38:54 <lambdabot> Monoid a => [a] -> a
17:39:17 <monochrom> Maybe you had "mconcat" or "msum" in mind.
17:39:23 <Welkin> yahb is such a spambot
17:39:49 <dmwit> monochrom: I think the intention was asum : <|> :: mconcat : mappend
17:39:57 <Welkin> yes
17:40:10 <epta> amx: it's not Maybe field, it's a custom type that might be serialized as Null
17:40:30 <monochrom> I was replying to "so asum works on any monoid, right?"
17:40:35 <Solonarv> if it's a custom type, you can just write the To-/FromJSON instances yourself
17:41:03 <dmwit> monochrom: Oh, I didn't even see that question!
17:41:14 <dmwit> chessandgo: No, asum doesn't involve itself with Monoid at all.
17:41:26 <dmwit> chessandgo: Only Alternative (which is related to monoids, but not Monoid).
17:41:31 <epta> dmwit: Null in terms of aeson Value - http://hackage.haskell.org/package/aeson-1.4.0.0/docs/Data-Aeson-Types.html
17:41:52 <chessandgo> drat, I was hoping I was seeing monoid theory in practice
17:42:22 <dmwit> epta: So is this a fair phrasing of your question: you have already produced a Value, and now you want to turn it into a ByteString or similar, eliding Nulls?
17:42:55 <epta> dmwit: right
17:43:46 <dmwit> epta: I think the simplest thing is probably to write a `Value -> Value` function which deletes whatever `Null`s you want to elide.
17:44:03 <dmwit> (Or not produce them in the first place, obviously.)
17:44:24 <chessandgo> how is Applicative different than a monoid, given applicative defines a zero element
17:45:06 <dmwit> Do you mean Alternative? Applicative doesn't have a counterpart to mempty.
17:45:07 <epta> dmwit: how to not produce Null in a toJSON implementation of a custom type (not Maybe a)?
17:45:52 <chessandgo> ah, yeah, was misreading the type class decleration
17:47:12 <dmwit> chessandgo: `Alternative f` does indeed say that `f a` is a monoid for any `a`.
17:48:46 <dmwit> epta: I admit I'm a bit lost at this point. Perhaps a minimal code sample showing the wrong behavior (and what you want to happen instead) would be in order.
17:48:56 <chessandgo> so, whats stopping asum to being generalized to monoids, it seems asum works on the premise of anything with a zero or failure element
17:49:10 <dmwit> :t foldMap -- nothing stops it happening, as it has indeed happened
17:49:11 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
17:49:14 <dmwit> Oops.
17:49:18 <dmwit> :t fold -- this one, I mean
17:49:18 <lambdabot> (Monoid m, Foldable t) => t m -> m
17:49:36 <chessandgo> is asum to fold as map is to fmap
17:49:45 <dmwit> No.
17:49:56 <dmwit> Sort of?
17:49:56 <Solonarv> Alternative makes a monoid (as in, the mathematical concept), but not a Monoid (as in, the type class defined in Data.Monoid)
17:50:04 <Welkin> there are a lot of things that looks like mconcat/asum/msum/concat
17:50:05 <dmwit> I don't know. The analogy is definitely not as direct as I would want.
17:50:40 <Welkin> take a collection of things and combine them into a single thing
17:50:50 <chessandgo> ah, Monoid typeclass isnt the mathmatical monoid? so its really just legacy thats prevent a clearer setup
17:51:13 <Welkin> no, haskell typeclasses are not the same as the things of the same name in category theory
17:51:19 <chessandgo> thats a shame
17:51:22 <dmwit> Monoid does represent mathematical monoids well. But `Alternative f` says more!
17:51:33 <dmwit> `Alternative f` says, no matter *which* `a` you choose, `f a` is a monoid.
17:52:04 <monochrom> Not all monoids come from alternatives.
17:52:18 <dmwit> For this reason I object to the phrasing `Alternative makes a monoid`. In `Alternative f`, we do not know that `f` is a monoid, because that's not even a well-kinded thing to say.
17:52:28 <chessandgo> so monoid is not objectively better than alternatives and vice versa?
17:52:37 <dmwit> I can agree with that.
17:52:45 <monochrom> And I need to say "come from" for an actually useful sentence because the simpler sentence "not all monoids are alternatives" is trivially true because "a monoid is not an alternative" is already true.
17:53:08 <chessandgo> so all alternatives are monoids but not all monoids are alternatives?
17:53:12 <monochrom> And the proof of that last sentence is super-easy: kind mismatch.
17:53:22 <dmwit> chessandgo: No, you still haven't got my point.
17:53:48 <dmwit> chessandgo: In `Alternative f`, `f` is a type-former: it requires another argument to become a type. In `Monoid f`, `f` is already a type with no extra arguments needed.
17:53:58 <dmwit> chessandgo: So they are not directly comparable in *either* direction.
17:54:36 <dmwit> chessandgo: e.g. one could write `Alternative Maybe`, and that's sensible; or `Alternative (Maybe ())`, and that's sensible; but `Alternative (Maybe ())` is not sensible nor is `Monoid Maybe`.
17:54:39 <Welkin> too many puns
17:54:48 <chessandgo> so f in Alternative f is one of those 'higher kinded types' then?
17:55:37 <Solonarv> Alternative (Maybe ()) is actually *not* sensible
17:55:56 <chessandgo> so Monoid String makes sence but Alternative String doesnt?
17:56:01 <chessandgo> if im following
17:56:06 <Solonarv> correct
17:56:10 <chessandgo> I see
17:56:52 <chessandgo> so is alternative good for using type contructors that are monoids themselves while Monoid is good for concrete types that are monoids
17:57:24 <monochrom> "type contructors that are monoids themselves" is a kind error.
17:58:02 <Solonarv> "type constructors that form a monoidal structure for every type argument"
17:58:11 <Solonarv> ^ that's what Alternative is
17:58:35 <dmwit> Going a bit meta: the questions you're asking now worry me a little. They sound like "should this fact go into my database" questions, which don't really lead to understanding.
17:59:14 <Welkin> there is such a thing as too much information
17:59:22 <Welkin> irrelevant information
17:59:50 <chessandgo> I havent had to deal with alternative as of yet, and ive been looking into type level programming since It was a recommended solution to a problem. Just trying to connect all of it
17:59:50 <monochrom> Perhaps this is an unhealthy obsession with monoids.
17:59:54 <dmwit> Like, if you were trying to teach an AI arithmetic, and you wanted to do it by first saying, "2+2=4", and then continuing... "2+3=5", "2+4=6", "2+5=7", ... it would never end.
18:00:24 <dmwit> No matter how many facts got in the database eventually you'd come onto a situation where you needed to add together two numbers that weren't yet in the database.
18:00:28 <monochrom> Oh but this ends: 2+2=2, 2*2=2, 2^2=2. >:)
18:00:46 <dmwit> s/=2/=4/g ;-)
18:00:54 <monochrom> Oh oops.
18:01:02 <epta> dmwit: sorry, probably I'm missing some details. Here is a minimal code sample https://lpaste.net/673648380378873856
18:01:55 <dmwit> epta: Probably you will have to write your `instance ToJSON Options` by hand.
18:02:57 <dmwit> epta: But it shouldn't be too bad. As I suggested above, you can write a `Value -> Value` function that just deletes nulls from the top-level HashMap (if there is one) and apply it after `genericToJSON`.
18:03:12 <dmwit> epta: You can write the null-deleter just once, and use it in all instances where you want this behavior.
18:04:10 <epta> yep, this `Value -> Value` might be a solution. But how manual `instance ToJSON Options` would help?
18:04:41 <dmwit> instance ToJSON Options where toJSON = deleteNulls $ genericToJSON defaultOptions { ... } -- ?
18:06:03 <epta> I see
18:08:06 <epta> I guess the easist option would be to refactor DefaultTtl in a Maybe-way
18:08:09 * hackage natural 0.1.0.1 - Natural number  http://hackage.haskell.org/package/natural-0.1.0.1 (qfpl)
18:08:13 <epta> dmwit: ok, thank you anyway
18:10:06 <dmwit> :t mapM
18:10:07 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
18:14:42 <Solonarv> b-but traverse
18:16:29 <glguy> Anyone know a library that could provide some simple voice command building blocks? I don't care what language, I'm willing to write bindings
18:17:42 * glguy checks out CMUSphinx
18:21:56 <dmwit> Last time I looked into that (very briefly) I got frustrated and quite because everything expects you to do your own training.
18:22:17 <dmwit> Which is understandable, but man, I just wanted to play around and my budget was less than ten cents.
18:24:22 <nitrix> glguy: Maybe HTTP calls to IBM's Watson API?
18:24:51 <nitrix> They seem to have an SDK for every language -- except Haskell of course.
18:25:21 <Solonarv> fortunately, haskell is pretty good at writing wrappers for HTTP APIs
18:27:43 <d34df00d> Hi!
18:27:50 <koz_> d34df00d: Sup?
18:28:25 <d34df00d> I'm having a project that uses c2hs. `stack ghci` starts up fine, but when I actually try to run something invoking the c2hs-provided functions, I get
18:28:37 <d34df00d> During interactive linking, GHCi couldn't find the following symbol: __c2hs_wrapped__clang_getCString
18:29:05 <d34df00d> The only ghc-options I pass to stack ghci are --ghc-options -L/usr/lib64/llvm/7/lib64/ for the underlying library.
18:29:11 <d34df00d> What would be the best way to fix this?
18:32:36 <glguy> Is the problem specific to stack?
18:33:05 <d34df00d> glguy: I'm not sure, I haven't even tried to run ghci without stack (the project is somewhat big).
18:33:25 <d34df00d> I will probably fail trying to construct the proper ghci line myself anyway.
18:35:46 <d34df00d> Huh, adding --ghci-options with the full path to the .o produced by c2hs seems to fix this.
18:35:52 <d34df00d> Like, --ghci-options /home/d34df00d/Programming/LibClang/.stack-work/dist/x86_64-linux-tinfo6/Cabal-2.2.0.1/build/.stack-work/dist/x86_64-linux-tinfo6/Cabal-2.2.0.1/build/Clang/Internal/FFI.chs.o
18:36:00 <d34df00d> But that doesn't scale and I feel like I'm doing something terribly wrong.
18:36:06 <glguy> I was mostly wondering if cabal repl or new-repl works.
18:37:07 <d34df00d> That would be painful to check... My system cabal is older than 2.0
18:37:11 <d34df00d> And this stuff requires 2.0.
18:44:38 <jmcarthur> I'm kind of amazed at how much TypeInType seems to be doing for me. I didn't really pay much attention to it, and just turned it on when GHC prompted me to, and now I'm just writing a bunch of code I thought I could only do in Agda. I'm not even sure how much to attribute to TypeInType, except that I am pretty sure I would have had a lot more difficulty before.
18:47:04 <Squarism> I have this database type app. Im curious to adapt the "test-fixture" package for writing IO tests. I see examples like MonadDB, MonadHTTP, MonadLog etc. Im used to unit-testing mocking dependent logic. This approach will sort of force me to mock all used application / system boundries for every test. It doesnt feel ideal.
18:48:19 <Squarism> Anyone have some experiance with this and haskell and if so, how do you like the approach of mocking every low level function for every test?
19:58:40 * hackage viewprof 0.0.0.20 - Text-based interactive GHC .prof viewer  http://hackage.haskell.org/package/viewprof-0.0.0.20 (MitsutoshiAoe)
20:06:24 <fresheyeball> hello
20:07:00 <fresheyeball> hlint if failing to parse, when I use a newtype in an instance associated data family
20:07:11 <fresheyeball> s/if/is
20:07:35 <fresheyeball> is there an extention that conflicts with this usage of newtype?
20:08:31 <fresheyeball> is there a way I can suppress the error?
20:11:08 <glguy> Trying to work with hlint usually results in a lot of CPP guards around the things that hlint doesn't handle yet
20:12:13 <dataN> is this anything? (a -> e -> (b -> m b)) -> (b -> e -> (a -> m a)) -> (e -> ((a,b) -> m (a,b)))
20:17:50 <dataN> \f g e (a,b) -> (? :: (m a,m b) -> m (a,b)) (f a e b,g b e a)
20:18:52 <dataN> whats that constraint on m?
20:21:06 <Solonarv> dataN: https://lpaste.net/7595844005951176704
20:21:29 <dataN> looks like there is some way to define it if 'm' is a monad... but this looks like something else...
20:22:10 <Solonarv> you should only need Applicative, actually
20:22:27 <dataN> :t (&&&)
20:22:28 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
20:23:17 <dataN> hmm...
20:23:18 <glguy> :t \f g e (a,b) -> liftA2 (,) (f a e b) (f b e a)
20:23:19 <lambdabot> Applicative f => (t1 -> t2 -> t1 -> f b) -> p -> t2 -> (t1, t1) -> f (b, b)
20:23:28 <glguy> :t \f g e (a,b) -> liftA2 (,) (f a e b) (g b e a)
20:23:29 <lambdabot> Applicative f => (t1 -> t2 -> t3 -> f a) -> (t3 -> t2 -> t1 -> f b) -> t2 -> (t1, t3) -> f (a, b)
20:23:57 <Solonarv> https://lpaste.net/7864444113817436160
20:24:10 <Solonarv> looks like we had the same idea
20:25:24 <dataN> nice
20:25:31 <juhp> Is it possible to use SPDX license tags now in .cabal files??
20:28:13 <dataN> any comment on the connection with arrows? always feel like there is something deep being missed using Applicative...
20:28:36 <glguy> There's not much reason to think about arrows
20:29:48 <Solonarv>  /\ a b -> (a -> m b) isn't even an Arrow unless m is a Monad
20:30:03 <Solonarv> (pretend that /\ is a type-level lambda)
20:30:35 <Solonarv> and this strange combinator you came up with doesn't require Monad
20:30:38 <Solonarv> so, ehhh
20:31:47 <Solonarv> juhp, looks like a no: the license field must be an identifier, meaning "a letter followed by zero or more alphanumerics-or-underscores"
20:32:15 <Solonarv> this is taken from the cabal docs: https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-license
20:32:44 <dataN> there arn't any ancient abstractions or conventions being forgotten? 
20:33:05 <dataN> some kind of arrow sugar? 
20:33:16 <Solonarv> can't think of any in this case
20:34:03 <Solonarv> this genuinely just looks like liftA2 (,) with some screwy plumbing
20:34:57 <dataN> which, (m a,m b) -> m (a,b) ?
20:36:20 <dataN> i guess its confusing to use the Applicative instance for (,) since it looks more like a constraint on 'm', thats all...
20:36:33 <glguy> This isn't that
20:37:06 <monochrom> This uses just the Applicative instance for m.
20:37:38 <dataN> oh right, thats where the confusion is.
20:38:10 <dataN> thanks... anyway, no name for this use of applicative?
20:38:47 <Solonarv> it might liftA2 (,) might have a name somewhere, but idk where
20:38:50 <dataN> its arising from some mutual state unfolding thing...
20:39:26 <dataN> not that, this thing; a -> e -> (b -> m b)) -> (b -> e -> (a -> m a)) -> (e -> ((a,b) -> m (a,b)))
20:39:46 <dataN> where m = Maybe
20:39:58 <juhp> Solonarv: I see thanks - just wonder why Hackage seems to be using it then?  Or Icbw hm
20:40:05 <Solonarv> oh, that - no idea
20:40:21 <juhp> (as in rendering licenses like SPDX tags)
20:40:26 <juhp> okay thanks
20:43:40 <juhp> Maybe I should file a bug against hackage-server...
20:43:58 <glguy> What would the bug be against Hackage server?
20:45:09 <Solonarv> hackage doesn't display the "license" field verbatim
20:46:19 <Solonarv> this isn't a bug, because hackage doesn't claim to reproduce the field verbatim
20:46:38 <glguy> There's been a bunch of work to support the SPDX license list in Cabal
20:51:45 <glguy> The SPDX license expressions grammar is shown here: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/SPDX/LicenseExpression.hs#L23-L40
20:52:11 <sclv> juhp: pre 2.0 version cabal files use old style licenses, new ones use spdx
21:00:58 <dmwit> :t zoom _1
21:00:59 <lambdabot> (Functor (Zoomed m c), Field1 s s b b, Zoom m n b s) => m c -> n c
21:43:14 <sohail> Hey, can we write the type signature of our functions first and use this approach as a form design before writing the actual code? what about using a mindmap software for visualizing these type signatures? has anyone tried this?
21:44:07 <sohail> *a form of design.
21:44:51 <sohail> [beginner-here]
21:47:39 <charukiewicz> Absolutely. I would take a step back even further and just define data types first, as you probably will have to define many of your own in your domain logic.
21:48:04 <charukiewicz> From there, you can write out functions as only type signatures.
21:55:10 <Axman6> sohail: it's very common to do that once you're used to thinking about applications in terms of types. I very opten write out the types I think I'm going to need and make all the functions = undefined
21:56:16 <Axman6> and what charukiewicz said, defining data types first is often a good starting place, depending on the problem
21:56:49 <nshepperd> i usually start by defining data types
21:58:03 <nshepperd> although i also don't try to avoid writing code as such, because often I don't realize that something won't work until i try to write it and realize something's missing
22:03:39 <phma> https://gist.github.com/phma/18f277d178db97ef353486b374751e4c
22:04:26 <phma> I'm getting type errors, and I don't know what I'm doing wrong. This is my first try at Haskell.
22:16:40 <fragamus> Hi I am trying to go through the cornucopia of category theoretical typclasses and add them to my repertoire of knowledge for writing programs. I’m learning profunctor now and I would like advice as to what next.
22:18:23 <koz_> fragamus: Have you read the Typeclassopedia?
22:18:27 <koz_> If not, I'd do that.
22:18:32 <fragamus> Kinda
22:18:34 <koz_> (and do the exercises too)
22:18:40 <koz_> Yeah, do it cokinda.
22:19:12 <fragamus> It’s so huge
22:19:20 <koz_> fragamus: I didn't say 'in one day'.
22:19:30 <koz_> It's also eminently readable IMHO.
22:19:37 <fragamus> Yes you did
22:20:01 <koz_> fragamus: Well, yeah, OK, _technically_ I did just then, but you know what I mean.
22:20:25 <fragamus> Haha I’m JK
22:20:43 <koz_> My sarcasm detector is perma-broke, lol.
22:22:15 <fragamus> I mean I have been a newb for ten years so I need to up my game on the power of FP
22:22:30 <fragamus> And it’s in those typeclasses
22:23:26 <fragamus> I forced myself to conquer comonad a few years ago
22:23:37 <phma> Can you help me?
22:23:52 <fragamus> Who me
22:23:53 <koz_> phma: To do what? Find yourself? Get wealthy? Solve world hunger? Some other thing?
22:24:14 <phma> https://gist.github.com/phma/18f277d178db97ef353486b374751e4c
22:24:18 <phma> I'm getting type errors, and I don't know what I'm doing wrong. This is my first try at Haskell.
22:24:40 <koz_> phma: Could you paste the error too?
22:24:59 <phma> Hold on, I changed the code a bit
22:26:48 <phma> Okay, I pasted it. Can you see it?
22:26:59 <koz_> Yeah.
22:27:08 <koz_> :t (^)
22:27:09 <lambdabot> (Num a, Integral b) => a -> b -> a
22:27:21 <phma> yes...
22:27:41 <koz_> Basically if you're gonna use ^, you need the exponent to be an integral thing.
22:27:51 <koz_> IN your case, 1 - intpart has this type:
22:27:56 <phma> It's supposed to compute a real number. The only integer in there is the intpart.
22:28:00 <koz_> :t floor
22:28:01 <lambdabot> (Integral b, RealFrac a) => a -> b
22:28:09 <koz_> Hmm.
22:28:29 <koz_> :t (/)
22:28:30 <lambdabot> Fractional a => a -> a -> a
22:29:10 <koz_> :t floor . (\x -> 1 / x)
22:29:11 <lambdabot> (Integral c, RealFrac a) => a -> c
22:29:20 <koz_> OK, that is a bit odd. Hmm.
22:30:13 <phma> :t (?)
22:30:14 <lambdabot> error: Variable not in scope: ?
22:30:51 <phma> Once I get mink' working, can I curry it to get (?)?
22:31:07 <koz_> phma: I don't understand what you mean by that.
22:31:09 <phma> Can I use a question mark as a function name?
22:31:33 <koz_> I actually dunno that - never tried.
22:31:49 <phma> Well, it is the question-mark function...
22:31:49 <koz_> :t (-)
22:31:50 <lambdabot> Num a => a -> a -> a
22:32:35 <koz_> Hmm, I'm actually unsure why this is happening. You might wanna wait for someone more competent than myself.
22:32:43 <koz_> Sorry, but I actually have no idea why this is happening.
22:33:49 <phma> When would be a good time?
22:34:52 <maybefbi> are there any haskell developers here who do not use ghc-mod?
22:35:55 <JuanDaugherty> why would you think most do?
22:36:08 <maybefbi> because it tells the type of complicated expressions
22:36:36 <maybefbi> what else can do it?
22:36:37 <JuanDaugherty> but anything with lambdabot in it can to that, e.g. ghci
22:37:05 <maybefbi> how do i get lamdabot in my editor?
22:37:34 <JuanDaugherty> sfaik, there's no ide 'everybody' uses, in the way 'everybody' uses ghc
22:38:16 <JuanDaugherty> did you look at leksah?
22:38:30 <JuanDaugherty> or yi?
22:39:05 <JuanDaugherty> ftm there's something in code i think
22:39:12 <JuanDaugherty> (vscode)
22:39:13 <maybefbi> what do you use?
22:39:58 <JuanDaugherty> none of the ide's in the way I do in other langs, wouldbe leksah if i did
22:40:36 <JuanDaugherty> maybe code, haven't really had a chance to use it much yet
22:40:55 <maybefbi> ok
22:41:26 <Lears> phma: fracinvx is invx - intpart, but that asserts the two values have the same type, forcing both to be Integral a => a, which your top-level type annotation does not match.
22:42:05 <Lears> phma: you need to coerce intpart there with e.g. fromIntegral.
22:42:58 <JuanDaugherty> yeah code has ghc-mod
22:43:15 <JuanDaugherty> (and a number of other hs pkgs)
22:43:42 <maybefbi> ok
22:44:01 <JuanDaugherty> (roughly 8 fit your bill)
22:52:14 <sohail> charukiewicz: got it.
22:52:34 <sohail> Axman6: thanks.
22:58:00 <Axman6> sohail: it's worth keeping in mind that this is a really useful thing to be able to do, but is often hard when starting to learn Haskell; I wouldn't make it a goal for all code you write to begin with, but do always keep in mind when you think you need to write a function "What should be the type of this function" as well as "what should the function do". The two are highly related and become two sides of the same coin eventually
23:11:25 <sohail> Axman6: thanks I will 🙏
23:12:18 <sohail> Axman6: is there a way I can save your or other members messages here in IRC for later reviews?
23:12:59 <suzu> there is a link to the logs of this channel, in the channel topic
23:15:13 <sohail> suzu: i saw that but i just wanted a way to just save the messages I need.
23:15:50 <suzu> copy+paste?
23:16:06 <suzu> IRC isn't a very sophisticated piece of software
23:16:30 <suzu> it doesn't have any direct solutions for things like that
23:31:41 <glguy> IRC isn't even a piece of software. Things like that would depend on the software you were using
23:36:19 <tdammers> indeed
23:36:32 <tdammers> many IRC clients include a logging feature
23:36:52 <tdammers> that would probably be the easiest way when simply copy-pasting from the client UI isn't enough
23:58:53 <Ariakenom> :t pure . pure
23:58:54 <lambdabot> (Applicative f2, Applicative f1) => a -> f1 (f2 a)
23:59:19 <koz_> Yo dawg, we herd u liek applicative functors...
23:59:41 <Ariakenom> :t fmap pure
23:59:42 <lambdabot> (Functor f2, Applicative f1) => f2 a -> f2 (f1 a)
