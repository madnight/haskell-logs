00:29:10 <bismuth> I'm a haskell noob just starting a project, but I'm stuck when trying to use modular arithmetic. I use the Data.Modular import, but I can't seem to be able to define all my calculations to be modulo n, for some integer variable n. For example I want x :: Mod Integer n, to mean that x should live in Zn
00:29:35 <ZeuPiark> hello
00:30:04 <mniip> bismuth, what exactly is the problem?
00:30:44 <ahri> I wrote some logic that I wanted to be agnostic of implementation details wrt. the data store backing its state, I used a parameterized record set of functions to accomplish this (a `data Tools a`) - because this was early on in my Haskelling and this most obviously approximated an OO "interface". This worked fine for my in-memory implmentation backed by a `Map` but now I need to do IO for another implementation so I need to up
00:30:44 <ahri> my game. What's the proper way to do this in Haskell? The easiest hack I can do is to make it `data Tools ( m a)` and pick a monad to work with my in-memory impl (which one? probably `Either Error` in my case) - but this feels like continuing down the sort-of-OO path I'd prefer to mature away from - I'd be very grateful for some insights!
00:31:12 <bismuth> mniip: When I try to define a data type data Coin = Coin (Mod Integer n), it doesn't work because it won't recognize n as a variable
00:31:45 <mniip> bismuth, that declaration doesn't make sense because when I say 'Coin' what should the n be?
00:31:56 <mniip> either set an explicit 'n' or add a type parameter to Coin
00:33:10 <bismuth> Okay, so if I use a type parameter, then this n will behave like a variable, right?
00:35:31 <mniip> bismuth, in a way, yes
00:37:58 <mniip> you could even have it decided at runtime, in a way
00:38:31 <mniip> % case someNatVal 123 of Just (SomeNat p) -> natVal p
00:38:31 <yahb> mniip: ; <interactive>:15:30: error: Not in scope: data constructor `SomeNat'
00:38:38 <mniip> % import GHC.TypeLits
00:38:38 <yahb> mniip:
00:38:39 <mniip> % case someNatVal 123 of Just (SomeNat p) -> natVal p
00:38:39 <yahb> mniip: 123
00:38:53 <mniip> % :t natVal
00:38:54 <yahb> mniip: forall {n :: Nat} {proxy :: Nat -> *}. KnownNat n => proxy n -> Integer
00:39:14 <mniip> see how a runtime value (123) is fed into the 'n' type argument
00:41:28 * mniip . o O ( I should rewrite my DictRep business to use magicDict instead of unsafeCoerce )
00:47:40 <milesrout> why is the haskell-cafe google group banned lol
01:00:38 <haskellPleb> How do I delete two elements out of a list? Something like using delete twice on the same list, but syntactically I still struggle with haskell so I'm not sure how to approach this problem
01:01:36 <Ariakenom> haskellPleb: Do you name everything using let?
01:01:50 <haskellPleb> I could nest delete but it doesn't look very nice
01:01:59 <haskellPleb> Ariakenom: No I hardly use let at all, was that a jab?
01:02:08 <tdammers> depends how you tell which elements to delete
01:02:16 <haskellPleb> they're parameters
01:02:20 <haskellPleb> of the function
01:02:29 <Ariakenom> no names makes it easier
01:02:48 <Ariakenom> :t delete
01:02:49 <lambdabot> Eq a => a -> [a] -> [a]
01:02:53 <tdammers> no, I mean, is it "delete the nth element", or "delete the first element that's larger than X", or "delete the element that equals A"
01:03:07 <tdammers> oh, OK, actual delete
01:03:34 <tdammers> something like: deleteBoth a b xs = delete a . delete b $ xs -- ?
01:03:51 <liste> > (delete 1 . delete 2) [5,6,7,1,6,7,2]
01:03:52 <tdammers> it's the same as delete a (delete b xs), just written differently
01:03:54 <lambdabot>  [5,6,7,6,7]
01:04:00 <haskellPleb> riiight, I forgot the dot operator. Thanks!
01:04:34 <tdammers> btw you can also write it like this: deleteBoth a b = delete a . delete b
01:04:48 <Ariakenom> :t foldl' (.) id . map delete
01:04:49 <lambdabot> Eq a => [a] -> [a] -> [a]
01:05:31 <liste> > filter (not . (`elem` [1,2])) [2,5,6,7,1,6,1,7,2] -- it deletes all 1's and 2's
01:05:33 <lambdabot>  [5,6,7,6,7]
01:05:36 <haskellPleb> but that doesn't have any list parameter to delete from? Or do you mean for currying it?
01:06:43 <mniip> liste, notElem
01:08:45 <liste> mniip: good point :)
01:09:41 * liste forgot about that
01:09:57 <mniip> notElem x xs = elem (not x) xs
01:09:58 <mniip> haha
01:10:47 <Ariakenom> notElem x xs = elem x (complement xs)
01:12:36 * hackage hyraxAbif 0.2.3.4 - Modules for parsing, generating and manipulating AB1 files.  http://hackage.haskell.org/package/hyraxAbif-0.2.3.4 (andrevdm)
01:14:11 <mniip> notElem x xs = length (union (singleton x) xs) /= length xs
01:36:36 * hackage yesod-form-bootstrap4 1.0.1 - renderBootstrap4  http://hackage.haskell.org/package/yesod-form-bootstrap4-1.0.1 (ncaq)
01:55:17 <vaibhavsagar> hmm, the `patience` package is broken on 8.6
01:55:26 <vaibhavsagar> and I can't see where to submit a PR to
02:00:36 * hackage yesod-auth 1.6.4.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.6.4.1 (MichaelSnoyman)
02:05:32 <`Guest00000> would you cringe at a Haskell-like language where top-level names (functions and constants) must have identifiers starting from a capital letter?
02:06:24 <vaibhavsagar> i'd be confused
02:06:30 <dataN> what is '(forall a. f a -> g a) -> h f a -> h g a' ?
02:07:20 <`Guest00000> i'm trying to make existing-in-scope names distinguishable from introduced variables in constructor fields' type declarations
02:07:25 <`Guest00000> by syntax
02:09:12 <cocreature> dataN: looks like "hoist" from MFunctor
02:10:37 <`Guest00000> this is a more obvious, simple way, but unaccustomed one
02:10:38 <dataN> cocreature: is the Monad constraint required? sometimes superclasses can be trivially defined but it looks unlikely here.
02:12:02 <dataN> also, there seems to be nothing to indicate 'n' of 'hoist :: Monad m => (forall a. m a -> n a) -> t m b -> t n b' is a Monad.
02:13:36 * hackage yesod-form-bootstrap4 1.0.2 - renderBootstrap4  http://hackage.haskell.org/package/yesod-form-bootstrap4-1.0.2 (ncaq)
02:15:23 <dataN> is there a higher kinded generalisation to this? how to fmap over the nth layer?
02:15:55 <mniip> yes
02:16:29 <dataN> somthing like (fmap. fmap . eta ...)
02:16:35 <mniip> no
02:16:40 <mniip> not with Prelude.fmap
02:17:14 <mniip> this is an example of a functor between functor categories
02:17:55 <mniip> NT m n -> NT (t m) (t n)
02:18:47 <mniip> m and n are functors Hask->Hask, and therefore objects in [Hask, Hask]
02:18:54 <mniip> ditto (t m) and (t n)
02:19:04 <mniip> hence t is a functor [Hask, Hask] -> [Hask, Hask]
02:20:08 <mniip> more accurately though it's a functor Mnd(Hask) -> Mnd(Hask)
02:22:20 <dataN> might need e.g. (forall a1 a2 .. an. m a1 a2 .. ai -> n a1 a2 .. ai) -> t x1 x2 .. xj m a1 a2 .. ai -> t x1 x2 .. xj n a1 a2 .. ai
02:22:58 <dataN> forall x1 x2 .. xj. also
02:24:13 <mniip> consider this:
02:24:17 <dataN> possibly the arity could be determined automatically from the input values... or given a specified depth, to generate the corresponding type...
02:25:33 <mniip> class (Category (Dom f), Category (Cod f)) => Functor (f :: k -> l) where type Dom f :: k -> k -> *; type Cod f :: l -> l -> *; fmap :: Dom f a b -> Cod f (f a) (f b)
02:27:00 <mniip> then once you have  data NT f g where NT :: (Functor f, Functor g, Dom f ~ Dom g, Cod f ~ Cod g) => { runNT :: forall a. f a -> g a } -> NT f g
02:27:19 <zincy> Is there any easy way to debug channels?
02:27:22 <mniip> hmm actually that's not good
02:28:13 <mniip> data NT k l f g where NT :: (Functor f, Functor g, Dom f ~ k, Dom g ~ k, Cod f ~ l, Cod g ~ l) => { runNT :: forall a. l (f a) (g a) } -> NT k l f g
02:28:32 <mniip> then  instance (Category k, Category l) => Category (NT k l)
02:28:45 <mniip> then you could start defining higher order functors
02:28:51 <mniip> even to the point of
02:29:01 <mniip> fmap :: (a -> b) -> (x, a) -> (x, b)
02:29:13 <mniip> runNT fmap :: (a -> b) -> (a, x) -> (b, x)
02:29:37 <mniip> correction: runNT . fmap
02:31:33 <dataN> to permute the types of the parameters of higher kinded values.
02:33:09 <dataN> values with higher kinded types*
02:33:17 <mniip> what
02:33:41 <mniip> higher kinded types have no values
02:35:59 <dataN> just higher kinded types then!
02:40:01 <dataN> why is the Category instance required?
02:40:24 <mniip> where
02:40:45 <dataN> for NT
02:41:02 <mniip> otherwise you can't declare  Functor (,)
02:41:14 <mniip> Dom (,) = NT (->) (->)
02:41:36 * hackage bhoogle 0.1.2.9 - Simple terminal GUI for local hoogle.  http://hackage.haskell.org/package/bhoogle-0.1.2.9 (andrevdm)
02:42:56 <dataN> ok, then why must the types 'Dom f' and 'Cod f' instantiate Category?
02:43:21 <mniip> a functor is between categories, right?
02:45:04 <dataN> oh, in that its trivially defined by the existance of an identity morphism and composability...
02:46:32 <dataN> well, trivial for the case where id :: * -> *, so then for id :: k -> k
02:48:00 <mniip> you don't instantiate id :: k -> k
02:48:08 <mniip> er
02:48:13 <mniip> that didn't even make much sense
02:50:05 <dataN> perhaps it would be easier to see a version which compiles, is it part of a library?
02:50:45 <mniip> one moment
02:50:57 <dataN> thanks
02:53:06 <gentauro> btw anybody here from FPComplete?
02:57:54 <mniip> @letlpaste 660872948617314304
02:57:54 <lambdabot>  Parse failed: Parse error: <
02:58:07 <mniip> oh right you don't like GADTs
02:58:21 <mniip> oh and letlpaste broke ever since the new update
02:58:38 <mniip> int-e:
02:58:50 <mniip> dataN, see this anyway https://lpaste.net/660872948617314304
03:00:04 <mniip> why do I keep shift-clicking stuff...
03:00:19 <mniip> dataN, I can load it in yahb I guess
03:00:27 <mniip> % :load http://tcpst.net/dxn5.hs
03:00:28 <yahb> mniip: [1 of 1] Compiling Main ( http:/tcpst.net/dxn5.hs, interpreted ); http:/tcpst.net/dxn5.hs:6:1: warning: [-Wtabs]; Tab character found here, and in 33 further locations.; Please use spaces instead.; |; 6 | type Ob c (a :: k) :: Constraint; | ^^^^^^^^; Ok, one module loaded.
03:00:46 <mniip> % fmap_ (+3) (0, 0)
03:00:46 <yahb> mniip: (0,3)
03:00:51 <mniip> % runNT (fmap_ (+3)) (0, 0)
03:00:51 <yahb> mniip: (3,0)
03:03:18 <mniip> you could declare  newtype Mnd c = Mnd (NT c c)
03:03:37 <mniip> instance Category c => Category (Mnd c) where Ob (Mnd c) m = Monad m
03:04:32 <mniip> then Functor YourMonadTransformer where type Dom YourMonadTransformer = Mnd (->); type Cod YourMonadTransformer = Mnd (->);
03:05:04 <mniip> that would give 'fmap' the same type as 'hoist'
03:05:08 <mniip> barring the NT and Mnd newtypes
03:06:11 <mniip> of course, in this framework you want to upgrade the Monad typeclass to
03:06:20 <mniip> preferably to a monoid in an endofunctor category
03:10:26 <dataN> no monads currently
03:11:06 * hackage fromhtml 0.1.0.3 - Simple adapter for transformation of HTML to other formats  http://hackage.haskell.org/package/fromhtml-0.1.0.3 (MarekSuchanek)
03:11:52 <mniip> gotta update finite-typelits I guess
03:35:19 <milesrout> test
03:37:24 <Taneb> Hey, milesrout, didn't expect to see you in here
03:38:06 * hackage JuicyPixels 3.3 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.3 (VincentBerthoux)
03:46:36 * hackage hyraxAbif 0.2.3.5 - Modules for parsing, generating and manipulating AB1 files.  http://hackage.haskell.org/package/hyraxAbif-0.2.3.5 (andrevdm)
03:50:28 <trcc> So it make any sense to use cabal new-* when using nix? It is introduces as nix-style local builds, so I guess it is not necessary if using nix?
03:51:27 <[exa]> afaik the granularity of the new-* stuff is slightly different than that of nix
03:51:43 <trcc> ok
03:51:44 <trcc> thanks
03:52:18 <[exa]> new-build can e.g. have 2 versions of package used in one build command, shadowing them for various other deps
03:52:30 <[exa]> not sure if nix can do that
03:52:39 <[exa]> but I might be wrong, not a nix user
03:53:07 <cocreature> even if you stick to nix for managing all your deps, new-build can be useful since it supports multi-package projects
03:53:20 <cocreature> (useful in comparison to regular cabal build)
03:58:21 <int-e> mniip: well there is no 'raw' link at all anymore?
03:58:31 <mniip> there is
03:58:49 <mniip> https://lpaste.net/raw/660872948617314304
03:59:41 <mniip> though really whoever the current admin of lpaste is they're not doing a good job
03:59:53 <int-e> sigh, why doesn't the paste page itself mention this...
04:00:36 <mniip> I don't know
04:00:53 <mniip> I found the missing raw link as well one day but quickly realized the /raw/ urls still work
04:03:03 <sclv> Did lpaste even get a new admin or is it just gradually falling apart
04:03:35 <cocreature> it’s kind of confusing. chris said he stopped using lpaste himself and was looking for new maintainers, a couple of people responded to the reddit post and then chris rewrote a “simplified” version from scratch
04:12:06 * hackage finite-typelits 0.1.4.0 - A type inhabited by finitely many values, indexed by type-level naturals.  http://hackage.haskell.org/package/finite-typelits-0.1.4.0 (mniip)
04:13:03 <epta> cocreature: so what is deployed to lpaste.net - the simplified version or some new vision on lpaste by the new maintainers?
04:13:09 <int-e> mniip: so it's forcing https now... and lambdabot's failing to parse the resulting 301 reply.
04:13:37 <mniip> funny
04:13:51 <mniip> yahb is prone to the same issue of being https-illiterate
04:14:36 <cocreature> epta: the simplified version
04:15:08 <cocreature> I’ve just stopped using lpaste and use github gists instead
04:15:31 <int-e> Is there a library that supports a simple interface like HTTP's simpleHTTP function, but also has HTTPS support?
04:15:49 <mniip> execlp("wget")?
04:15:55 <int-e> ...
04:16:48 <int-e> I suppose that works, if you like stabbing people (with forks).
04:18:21 <pavonia> I was looking for that too, but didn't found anything for HTTPS that doesn't require a whole string of packages
04:22:28 <mniip> int-e, Network.Curl.Easy?
04:22:36 <int-e> mniip: I guess it says something when cabal-install uses curl and wget as its primary methods for updating its database.
04:25:00 <int-e> mniip: there's a download-curl built on top of that...
04:25:16 <int-e> @hackage download-curl
04:25:17 <lambdabot> http://hackage.haskell.org/package/download-curl
04:26:43 <int-e> (which for the purpose at hand carries a superfluous 'xml' dependency, but in the context of lambdabot that's not a big deal)
04:27:19 <int-e> oh, 'feed' is the bigger dependency
04:28:43 <haasn> 19:23 <ij> haasn, do you comment out the parts that don't compile because of the dependent functions you're refactoring or you've got something doing that for you, perhaps? <- after a refactor I'll usually go through all of the parts that don't compile, if I don't want to worry myself with some component just now I'll replace the offending code by holes
04:29:06 <haasn> I don't use a tool for this, it's not frequent or bothersome enough to invest time in finding one
04:30:12 <ij> it seems like it could/should exist though
04:53:06 * hackage shake-c 0.4.0.0 - Library for building C code with shake  http://hackage.haskell.org/package/shake-c-0.4.0.0 (vmchale)
04:54:06 * hackage ats-pkg 3.0.0.2, shake-ats 1.9.0.2 (vmchale): https://qbin.io/hobby-horny-w9t1
05:00:04 <haskellPleb> How do I turn a String into a String Tree that I can add to a forest?
05:00:42 <haskellPleb> I don't know if I'm blind but there isn't much info about the tree package and how it works
05:02:21 <[exa]> haskellPleb: do you mean Tree String?
05:02:27 <haskellPleb> yes
05:02:49 <[exa]> well you can create a single-node tree that contains the string
05:03:02 <pavonia> Forest is just a list of Trees
05:03:30 <[exa]> :t [Node "asdasd" []] :: Forest String
05:03:31 <lambdabot> Forest String
05:03:35 <[exa]> check
05:03:56 <haskellPleb> yes, I need to write a simpler version of neighbor joining, so first of all I need a list of trees that I can work with
05:04:00 <haskellPleb> thanks [exa]
05:09:43 <[exa]> haskellPleb: anyway the info about tree package https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Tree.html
05:10:12 <cocreature> *tree module :)
05:13:06 <haskellPleb> [exa] thanks,
05:37:28 <haskellPleb> [exa] How do I create a branch/subtree with the tree module? I can only manage to create nodes.
05:38:12 <lyxia> A Node is a tree
05:39:09 <haskellPleb> lyxia: so how do I create a node with two new nodes in it? I tried (Node (Node a []) (Node b []) :: Tree String) but I'm guessing that's incorrect af
05:40:41 <cocreature> haskellPleb: each Node consists of the node label and a list of children
05:41:24 <haskellPleb> ohhhhhhh
05:54:36 * hackage servant-pagination 2.1.1 - Type-safe pagination for Servant APIs  http://hackage.haskell.org/package/servant-pagination-2.1.1 (KtorZ)
06:07:53 <trcc> Hi. I have this foreign-library project: https://github.com/CThuleHansen/HFMU and this tester, which just invokes cfoo: https://github.com/CThuleHansen/HFMU_C_TESTER/blob/master/hfmu_c_tester.c. My issue is, that the cfoo function does not invoke the haskell foo function. dyld: lazy symbol binding failed: Symbol not found: _foo . Any ideas?
06:13:06 * hackage staversion 0.2.3.0 - What version is the package X in stackage lts-Y.ZZ?  http://hackage.haskell.org/package/staversion-0.2.3.0 (debugito)
06:15:40 <CrackedCracker> Hello. I was wondering, is it possible to apply one type to another with free type variables? (now it complains that type variable `b` isn't in scope, if i do something like ```
06:15:40 <CrackedCracker> > data Func = F{runF :: a} deriving Functor
06:15:40 <CrackedCracker> > :t (flip fmap) @ F b```
06:15:43 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
06:15:43 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
06:17:53 <haasn> CrackedCracker: did you mean data Func a = ?
06:18:26 <CrackedCracker> haasn: yeah, sorry, it was data Func a in ghci, i copy-pasted it poorly
06:19:42 <CrackedCracker> and, obviously, `@ Func b` in application
06:21:49 <haasn> :t flip (fmap @ Identity)
06:21:50 <lambdabot> error:
06:21:51 <lambdabot>     Pattern syntax in expression context: fmap@Identity
06:21:51 <lambdabot>     Did you mean to enable TypeApplications?
06:22:00 <haasn> that works for me in GHCi
06:22:10 <haasn> not sure why (flip fmap) doesn't work but I guess it sort of makes sense when you think about it
06:22:40 <haasn> since the type of `flip fmap` is only inferred, it would be sort of confusing to start applying type annotations when the type signature isn't even visible to the programmer
06:23:42 <haasn> and it would be @ Func not @ (Func b) because you're only instantiating the first type variable, in this case the `f` from the Functor f constraint
06:24:02 <haasn> otoh this works: fmap @ (Const Int)
06:24:13 <haasn> because Const Int :: * -> *
06:26:42 <fendor> i stumbled across TQueue, when should i prefer it over TChan? As i read it, it should have better performance.
06:27:06 <CrackedCracker> haasn: okay, that makes sense, thank you.
06:28:55 <haasn> fendor: from the documentation it seems like you would use TQueue whenever you don't need dupTChan / cloneTChan
06:30:47 <fendor> and when would i need to call cloneTChan? for multiple reads?
06:31:06 * hackage cabal2nix 2.9.3 - Convert Cabal files into Nix build instructions.  http://hackage.haskell.org/package/cabal2nix-2.9.3 (PeterSimons)
06:31:42 <jamec> eww
06:32:07 <haasn> fendor: for broadcast-style stuff
06:32:14 <haasn> like having multiple threads communicate with multiple other threads
06:32:58 <haasn> (or a single thread communicating with multiple other threads)
06:33:30 <fendor> haasn, i see, makes sense.
06:33:33 <fendor> thank you
06:47:10 <Vyse007> Am I using local/ask incorrectly in this simple example? Or maybe I just don't understand the exact error message? https://lpaste.net/4365000693426159616
06:47:31 <trcc> Any takers on assisting with some ffi and shared library generation?
06:48:29 <CrackedCracker> And how would one declare Functor instance for `a` for `data Pair a b = P { rP :: (a,b)}`? I would put a wildcard in here, like `instance Functor (Pair _ b)`, but it says `Wildcard ‘_’ not allowed`.(sorry for such a basic question, just can't find an example for this)
06:49:05 <barrucadu> CrackedCracker: You can't
06:49:42 <CrackedCracker> really? so, I can have a bifunctor instance, but not functor on the first variable?
06:50:12 <Taneb> CrackedCracker: from Haskell's point of view, "Functor" is a typeclass whose parameter is of kind "Type -> Type"
06:50:17 <cocreature> trcc: metaquestions never work, just ask your question directly :)
06:50:42 <CrackedCracker> Taneb: yeah, and doesn't `Func _ b` has kind Type -> Type?
06:50:49 <CrackedCracker> have*
06:50:53 <Taneb> CrackedCracker: Func _ b isn't a thing in Haskell
06:50:57 <Taneb> At least at the type level
06:51:07 <Taneb> We don't (and won't ever, probably) have type-level lambdas
06:51:21 <Taneb> The only thing you can do is use more or fewer parameters
06:51:39 <Taneb> So we can talk about `Func`, `Func a`, and `Func a b` in different contexts
06:51:52 <Taneb> But it's a lot trickier to talk about `Func _ b`
06:51:55 <trcc> cocreature: I already tried, no takers
06:51:57 <trcc> :P
06:53:01 <CrackedCracker> Taneb: thank you. it was, well, unexpected
06:53:10 <Taneb> CrackedCracker: one thing you can do is define "newtype FlippedPair b a = FlippedPair {unflipPair :: Pair a b}"
06:53:33 <maerwald> we should create a crowd funded project for haskell editor tools
06:53:42 <Taneb> And then define a Functor instance for FlippedPair b
06:53:54 <CrackedCracker> yeah, sure, I just thought i could define multiple Functor instances for a Pair if it has Bifunctor. It seemed natural
06:54:10 <Taneb> It is natural in mathematics
06:54:58 <Taneb> One justification of why it wouldn't work in Haskell is, imagine if you had both Functor instances. What's "fmap (+1) (P (2,3))"?
06:57:40 <lyxia> Vyse007: that code compiles for me
06:57:46 <cocreature> trcc: maybe try putting an underscore at the beginning of your foreign export? iirc symbols on windows are usually prefixed with an underscore but I suspect that tho foreign export might not do that
06:58:02 <CrackedCracker> Taneb: um, maybe prefer the first type argument, like Either prefers second. But, yes, I get your point.
06:58:03 <trcc> cocreature: I am on mac. I'll try
06:58:24 <trcc> cocreature: one strange thing is, that even though I make an error in the HFMU.hs file, cabal build still builds without any errors
06:58:43 <Taneb> CrackedCracker: do have a look at the module Data.Bifunctor.Flip in the bifunctors library, though!
06:59:08 <cocreature> trcc: what do you mean by “make an error”? an actual type error?
06:59:20 <trcc> yes. return 5+"h"
06:59:34 <cocreature> trcc: oh it looks like you forgot to specify the module
06:59:43 <CrackedCracker> Taneb: will do, thank you
06:59:49 <trcc> cocreature: could you lead me to where?
06:59:51 <cocreature> trcc: you need to list modules in other-modules
06:59:53 <Vyse007> lyxia: That's strange...it doesn't for me. Thanks anyway!
06:59:57 <lyxia> > let a :: Reader [Int] Int ; a = do local (map (* 2)) ask; return 5 in runReader a [] -- Vyse007
06:59:59 <lambdabot>  5
07:00:26 <maerwald> ghc-mod is eats memory and is incompatible with recent ghc, hie lacks features, eats memory and crashes, intero doesn't build my project at all, ghcid has broken argument parsing and cannot be configured, hscope and hasktags are incomplete and the results are unreliable
07:00:32 <maerwald> did I miss something?
07:00:48 <lyxia> Vyse007: I get the error if I misindent (return 5)
07:01:29 <Vyse007> lyxia: Well I get an error even I remove the 'return' line entirely, so I am not sure what's happening with my ghci.
07:01:53 <trcc> cocreature: I have no inputted HFMU in other-modules, see https://github.com/CThuleHansen/HFMU/blob/master/hfmu.cabal but I still do not get the error: https://github.com/CThuleHansen/HFMU/blob/master/src/HFMU.hs#L10
07:02:12 <lyxia> Vyse007: `ask` returns [Int], so it makes sense that that would be an error
07:02:44 <cocreature> trcc: it looks like this is inside the if os(Windows) block which if you’re on a mac is not going to have any effect
07:02:54 <trcc> yes I just tried removing it
07:02:58 <lyxia> Vyse007: (return 5) hid the return type of ask
07:03:02 <trcc> seems to fix it
07:03:25 <Vyse007> lyxia: I do have another query though - does 'local' modify the environment permanently? As in, after executing 'local' would executing 'ask' return the modified environment?
07:05:26 <lyxia> Vyse007: no it's only within the scope of `local`
07:06:39 <Vyse007> lyxia: Ah, that makes sense. Otherwise it would be very similar to the State monad too. Thanks for the help!
07:07:18 <lyxia> yw!
07:07:25 <trcc> cocreature: thank you soo much
07:07:33 <trcc> I have spent 2 hours on that other-modules issue
07:07:34 <trcc> working now
07:08:26 <maerwald> it seems stack allows a package to build against multiple versions of a dependency, cool
07:08:37 <maerwald> (and then fails)
07:18:20 <c50a326_>  so ghc-mod doesn't work with stack 8.2, great
07:18:27 <c50a326_> oh why am I underscore
07:18:49 <cocreature> trigalero[m]: yw :)
07:18:56 <cocreature> c50a326: afaik there’s a branch for GHC 8.2
07:19:01 <dmwit> whoa, that tab completion
07:19:20 <dmwit> cocreature: He's back, try again
07:19:20 <cocreature> heh that was for trcc :)
07:19:34 <dmwit> whoops
07:19:44 <cocreature> it’s not like it was super important :)
07:19:57 <trcc> cocreature: what was for me?
07:20:19 <dmwit> I'm cracking up.
07:20:20 <cocreature> trcc: I just said “yw :)”
07:20:23 <trcc> hehe
07:20:32 <trcc> lame error ^^
07:20:40 <trcc> see you
07:21:14 <tonyg> is it possible to use stack with the "global project" to install packages globally?
07:21:25 <maerwald> stack 8.2?
07:21:29 <maerwald> what is that
07:22:37 <maerwald> cocreature: that has long been merged to master
07:22:44 <cocreature> tonyg: if you use stack outside of the project it will use ~/.stack/global-project/stack.yaml
07:23:01 <tonyg> cocreature: thanks! so I can put globalish deps in there... I'll give it a go!
07:23:20 <cocreature> to install deps in that project you can just run "stack build libraryname"
07:23:51 <tonyg> cocreature: oh thanks! that's what I was looking for
07:29:21 <tonyg> cocreature: so, it installed the package successfully, and `stack runhaskell x.hs` finds its modules - but - where did it put it??
07:29:49 <cocreature> somewhere in .stack
07:29:54 <cocreature> ~/.stack/snapshots
07:29:56 <cocreature> probably
07:31:25 <tonyg> cocreature: thanks. found it. was looking there, but for just the packagename rather than packagename-version-base64stuff
08:22:48 <tonyg> is there a pattern syntax for lists with a certain prefix? the pattern equivalent of ([1, 2] ++ rest)?
08:23:04 <ahri> I asked earlier but I guess fewer people were around then: I wrote some logic that I wanted to be agnostic of implementation details wrt. the data store backing its state, I used a parameterized record set of functions to accomplish this (a `data Tools a`) - because this was early on in my Haskelling and this most obviously approximated an OO "interface". This worked fine for my in-memory implementation backed by a `Map` but
08:23:05 <ahri> now I need to do IO for another implementation so I need to up my game. What's the proper way to do this in Haskell? The easiest hack I can do is to make it `data Tools (m a)` and pick a monad to work with my in-memory impl (which one? probably `Either Error` in my case) - but this feels like continuing down the sort-of-OO path I'd prefer to mature away from - I'd be very grateful for some insights!
08:23:43 <infinisil> tonyg: 1:2:rest
08:23:57 <tonyg> infinisil: thanks. that's a shame
08:24:09 <infinisil> huh why?
08:24:36 * hackage amqp-utils 0.3.3.1 - Generic Haskell AMQP Consumer  http://hackage.haskell.org/package/amqp-utils-0.3.3.1 (woffs)
08:24:53 <tonyg> infinisil: I had expected there to be the usual raft of shortcut syntaxes for these things. Like in scheme, erlang etc. where you get to have "dotted lists" more or less
08:25:20 <infinisil> How can anything be shorter than 1:2:rest??
08:25:46 <tonyg> more to do with consistency or edit distance perhaps
08:26:00 <tonyg> like, moving from [1, 2, 3] to [1, 2] ++ rest
08:26:11 <tonyg> on the pattern side, you have to rewrite all the commas to :
08:26:12 <Ariakenom> > 1:2:[3,4]
08:26:14 <lambdabot>  [1,2,3,4]
08:26:26 <Ariakenom> > 1:2:[]
08:26:28 <lambdabot>  [1,2]
08:27:48 <Ariakenom> You can write : on the expression side too
08:28:05 <Ariakenom> :t (:)
08:28:06 <lambdabot> a -> [a] -> [a]
08:28:20 <infinisil> tonyg: Haskell pattern matching is based on constructors. Being able to pattern match on [1, 2] ++ rest wouldn't make any sense. Also people then might try to pattern match on `foo ++ bar` which makes even less sense, and wonder why the language is inconsistent
08:28:48 <Ariakenom> mumble mumble n+k patterns mumble
08:28:56 <infinisil> Having a few chars less to edit is worth the consistency
08:29:00 <infinisil> more*
08:29:06 * hackage uu-interleaved 0.2.0.1 - Providing an interleaving combinator for use with applicative style implementations.  http://hackage.haskell.org/package/uu-interleaved-0.2.0.1 (DoaitseSwierstra)
08:31:21 <tonyg> So both erlang and scheme* offer a kind of notation for saying "and then the rest of the list" which is compatible with the ordinary [1,2,3] (non-cons) syntax and is available in both pattern and expression context. It's OK that haskell doesn't, I'll just write my programs with :, but it'd be nice if it had this kind of cosmetic harmony between the pattern and expression languages.
08:33:22 <aqzefluu> I mean here's a notation for "the rest of the list" :  ":rest"
08:34:21 <tdammers> : works for pattern matching and for expressions, I don't think there is a lack of "cosmetic harmony"
08:34:31 <tonyg> aqzefluu: I'm talking about the [1,2,3] syntax
08:34:48 <tonyg> erlang lets you write [1, 2, 3 | rest]; scheme, `(1 2 3 ,@rest)
08:34:51 <tdammers> the "cosmetic disharmony" is between bracket syntax and cons syntax
08:36:13 <tonyg> these days even javascript gives you function (a, b, c, ...rest) {} :-)
08:36:17 <aqzefluu> the problem is that lists are defined using (:). (1:2:rest) isn't just some sugar for anything, it's actually a normal pattern
08:36:40 <aqzefluu> you could create your own list like thing, with something equivelent to (:), and pattern match with it in the exact same way
08:36:43 <tonyg> aqzefluu: there's no problem. i understand what's going on with (:).
08:36:58 <tonyg> aqzefluu: it's just that []-syntax doesn't let you match out (or place in) the tail of a list
08:37:23 <tonyg> i was using [1, 2] ++ rest earlier to get the idea across - as far as i'm aware there's no other notation (outside of using (:)) for this
08:37:32 <aqzefluu> Yeah, it's just that pattern matching requires constructors, not arbitrary functions like (++). If you're doing more complicated pattern matching, use something else
08:37:53 <aqzefluu> Like you can't pattern match with Set's "union". That wouldn't make sense
08:38:00 <tonyg> aqzefluu: don't get hung up on the ++, it's just because there's no other syntax for rest-list using the [] syntax
08:38:27 <tonyg> I thought Ariakenom's point re n+k patterns was apropos earlier
08:39:32 <Ariakenom> aqzefluu: weeeell view patterns
08:40:26 <aqzefluu> Ariakenom: I hadn't heard of those, I'll have to read about them
08:40:44 <glguy> n+k was a special cased pattern that was removed for being a confusing special case. View patterns don't make matching on union any more sensible
08:41:51 <jophish> bgamari: I'm running into this: https://ghc.haskell.org/trac/ghc/ticket/15275
08:41:55 <aqzefluu> Right matching on union was just an example to show that making an exception for ++ is weird. I hope nobody would ever actually do that
08:41:57 <aqzefluu> lol
08:41:59 <jophish> do you have any suggestions?
08:42:14 <jophish> I'm cross compiling form x86 to aarch64 with a nix toolchain
08:42:29 <jophish> I've cross compiled the iserv remote server and iserv-proxy
08:42:33 <tonyg> aqzefluu: you'll enjoy prolog ;-)
08:43:01 <jophish> I get this problem when using qemu to host the server, testing now on the hardware
08:43:53 <aqzefluu> would there be any way to implement a "list prefix pattern" with ViewPatterns?
08:44:11 <Cale> There would
08:44:58 <jophish> bgamari: happens on actual aarch64 hardware too (to no surprise0
08:44:58 <Cale> :t stripPrefix
08:44:59 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
08:45:07 <Ariakenom> I guess it would be prefix :: [a] -> [a] -> Maybe [a] and (prefix [1,2] -> Just rest)
08:45:21 <Ariakenom> oh yeah that thing :p
08:45:54 <aqzefluu> awesome thanks. I'll have to play around with ViewPatterns more, they look super useful
08:46:09 <Cale> > let f (stripPrefix [1,2] -> Just xs) = xs; f xs = xs in f [1,2,3,4,5]
08:46:10 <Ariakenom> func (stripPrefix [1,2] -> Just rest) = ...
08:46:11 <lambdabot>  [3,4,5]
08:46:58 <Cale> That's a rather awkward thing to do compared to just writing something like f (1:2:xs) though
08:47:25 <Cale> You could make a pattern synonym, if you really wanted to, as well.
08:47:28 <aqzefluu> It's awkward, but I like the implications of being able to work with my own data types in the same way
08:47:32 <tonyg> a stackoverflow poster poses roughly my question in context of string prefix matching: https://stackoverflow.com/questions/1602243/pattern-matching-string-prefixes-in-haskell
08:47:49 <tonyg> strings being lists and all
08:48:24 <Cale> tonyg: At a point, you just want to move to using a parser combinator library such as attoparsec
08:48:44 <tonyg> Cale: yes, but this is for "parsing" instances of a data type
08:49:05 <tonyg> . o O ( wouldn't it be nice to have parser combinators for building pattern-matching functions )
08:49:16 <tonyg> (since parsing and pattern matching are so similar)
08:49:25 <Ariakenom> aqzefluu: I remember there being some documentation that was unclear on what features were implemented. The user guide is good though https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#view-patterns
08:49:34 <benzrf> tonyg: i think you may be able to something along those lines using optics
08:49:45 <tonyg> benzrf: cool
08:49:49 <Cale> I mean, we kind of have that
08:50:09 <Cale> But I'm not sure I understand what you mean :)
08:50:28 <Cale> There are pattern guards and view patterns and stuff that you can use to match on the results of arbitrary functions
08:50:47 <aqzefluu> Ariakenom: thanks for the link. Also this one for those interested: https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
08:51:08 <Cale> (not to mention just using a simple case expression, though that won't give you the same fall-through)
08:51:12 <hyperisco> no idea what I am doing wrong with stack…  stack install snap  and the command just prints a newline and exits
08:51:36 <Ariakenom> aqzefluu: that's the one with "further syntactic extensions" that aren't implemented. maybe something else there too
08:51:45 <tonyg> :) I'm not entirely sure what it'd mean either. Just that parsing text and matching on structured data have a lot in common, and the rich pattern language that parsec gives might be usefully extended to parsing structured data too, and then used in place of regular pattern matching on the lhs of functions
08:52:11 <tonyg> or, i guess, not on the lhs
08:52:20 <tonyg> ehh. dsls for pattern matching basically I suppose
08:52:26 <aqzefluu> I mean the page says "This page has been revised to reflect what we've implemented."
08:52:32 <Taneb> tonyg: you can fake that with ViewPatterns
08:52:37 <Ariakenom> aqzefluu: the reflection is not clear :)
08:52:57 <mnoonan_> hyperisco: anything interesting if you say "stack install snap -v"?
08:53:01 <tonyg> Taneb: yeah I've not yet experimented in any depth with ViewPatterns but they do look very powerful
08:53:12 <Ariakenom> aqzefluu: It's a nice read still though. You can just test what works
08:54:06 <hyperisco> no idea… going to use PHP instead now
08:54:17 <tonyg> actually, wait. *is* there something like parsec for matching out of structured data?
08:54:45 <Sparkhim> hello world?
08:54:57 <cocreature> hello Sparkhim!
08:55:04 <Sparkhim> first time here
08:55:07 <Sparkhim> learning haskell
08:55:32 <Sparkhim> i was sent from http://learnyouahaskell.com/introduction#about-this-tutorial
08:55:36 <aqzefluu> Awesome, it's a fun language to learn
08:55:40 <lyxia> tonyg: pattern-matching > parser combinator library
08:55:45 <Cale> tonyg: Well, it's sort of weird, because with strings/lists/text, there's a natural definition for what the "rest of the data" is, as you're matching bits of it. When you try to generalise further, it's less clear how that ought to work.
08:56:44 <Cale> If you can say what you mean by that though, well, something like StateT s [] might be what you're looking for :)
08:57:05 <Cale> (picking s = String gets you a simple parser monad)
08:57:07 <tonyg> Cale: yeah, that's interesting. Tree-shaped - there'd be, in general, multiple "rests", multiple "leftovers" after matching some prefix of the data.
08:57:21 <aqzefluu> I was thinking it would be nice if there was a looser, easier matching style, then I realized there was case of lol
08:59:10 <aqzefluu> Is there any history or reasoning behind Haskell's infix `` syntax? I've always thought it was kind of ugly
08:59:17 <aqzefluu> Does it come from another language or something
08:59:21 <Ariakenom> fgl is a library that does pattern matching on graphs
09:00:05 <Cale> aqzefluu: Most of Haskell's syntax comes from Miranda, but I'm not sure if Miranda had that feature or not.
09:00:26 <tabaqui1> hmm
09:00:28 <tabaqui1> https://wiki.haskell.org/Pairs_of_identifiers
09:00:36 * hackage deferred-folds 0.5 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.5 (NikitaVolkov)
09:00:41 <tabaqui1> I think that "car/cdr" is missing in this list
09:01:05 <rindolf> Hi all! Any idea how to populate a Map of Set-s from a list - https://paste.debian.net/1033126/ ?
09:02:32 <mniip> map of sets?
09:02:35 <mniip> in what way
09:02:37 <glguy> :t M.fromListWith
09:02:39 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
09:02:47 <Cale> rindolf: Usually something like Map.fromListWith Set.union . map (\(x,y) -> (x, Set.singleton y))
09:03:19 <mniip> ah that kind of
09:03:37 <rindolf> Cale: thanks
09:05:41 <Ariakenom> tonyg: in fgl the rest is a new graph. for example with the matched node and its edges removed.
09:07:18 <tonyg> Ariakenom: interesting. might make it tricky to continue the ~parse if it doesn't also hand back info on each removed edge though
09:07:54 <tonyg> actually maybe just plain old view patterns would do here
09:08:00 <tonyg> i'll fiddle around and see.
09:08:28 <Ariakenom> tonyg: I'm sure it does, don't remember. I just considered the graph the rest.
09:09:24 <Ariakenom> tonyg: viewpatterns do great there yes
09:14:17 <rindolf> mniip: further optimisations, but still slower than cpy - https://github.com/shlomif/project-euler/commits/master
09:14:33 <rindolf> cpython
09:14:43 <rindolf> Cale: thanks again
09:15:52 <zincy> When you import a type declaration do the typeclass instances defined in the same file come with it?
09:16:39 <Cale> When you import any module, all instances in scope in that module are imported along with it
09:17:04 <Cale> There's no way to prevent instances from being imported
09:17:48 <mizu_no_oto> zincy: are you trying to avoid importing an instance, or make sure an instance is imported?
09:17:49 <zincy> hmm
09:18:00 <zincy> I am using the pretty library
09:18:32 <zincy> but when I call prettyShow on a value whose type has an instance for Pretty I get an error saying there is no instance for Pretty
09:18:36 * hackage herms 1.9.0.2 - A command-line manager for delicious kitchen recipes  http://hackage.haskell.org/package/herms-1.9.0.2 (JackKiefer)
09:18:54 <Solonarv> I think this is the point where we need to see your code
09:19:04 <Cale> (and/or the error message you're getting)
09:19:14 <mizu_no_oto> Or at least the types & error message involved
09:19:59 <zincy> Not public cant show it :(
09:20:07 <hyperisco> yesod might be nice but it is hardly Haskell oO
09:20:09 <zincy> sorry
09:20:27 <hyperisco> I just want the simplest possible thing to echo the current timestamp over HTTP
09:20:33 <Solonarv> you can change names and paste things into some online pastebin-thingy
09:20:44 <shapr> hyperisco: scotty?
09:20:53 <shapr> is that simple enough?
09:20:55 <Cale> zincy: Read the error message carefully and make sure that the type it's saying it can't find an instance for is exactly what you expected.
09:22:12 <hyperisco> I will check it out
09:22:21 <hyperisco> how come when I install stuff with stack it doesn't update stack.yaml or package.yaml
09:23:13 <Solonarv> because those files aren't "a list of what you've installed
09:23:57 <Solonarv> package.yaml is information about *your* package, which includes a list of the packages it depends on
09:24:06 <Solonarv> stack.yaml essentially tells stack where to look for packages
09:24:26 <maerwald> so extra-deps in stack doesn't actually say "I only want this version to be installed", but "yeah, you might have 3 different versions"?
09:25:45 <Solonarv> it's... kinda both? I've only ever used it for dependencies that aren't in any LTS snapshot
09:26:26 <maerwald> it seems to be the latter
09:26:39 <maerwald> just random global state
09:26:46 <Solonarv> in any case, `stack install` is *not* what you want for installing dependencies, hyperisco
09:27:29 <hyperisco> I checked the stack help and didn't see what else there was
09:27:41 <hyperisco> right now I am just writing the package names in by hand w/o version numbers and that seems to work
09:27:50 <Solonarv> you just add the dependency to the 'dependencies' list in package.yaml
09:28:33 <Solonarv> and yeah you can omit version constraints if you're using stack, it's not best practice but it's fine
09:29:00 <maerwald> try to avoid stack, use cabal sandboxes
09:29:11 <maerwald> keep your package up2date
09:29:30 <maerwald> the more I am exposed to stack, the more I dislike it
09:30:43 <hyperisco> okay… now how about getting the current time in milliseconds
09:30:57 <hyperisco> accuracy to the second is unacceptable
09:32:14 <Solonarv> hyperisco: https://hackage.haskell.org/package/time-1.9.1/docs/Data-Time-Clock.html#v:getCurrentTime
09:32:38 <hyperisco> fine but how do I get milliseconds
09:32:40 <bgamari> jophish, sadly no
09:32:52 <bgamari> jophish, I haven't had time to investigate that
09:33:02 <bgamari> and it's not looking likely that I will any time before 8.6
09:33:15 <bgamari> so any investigation you could offer would be greatly appreciated
09:33:41 <inkbottle> Is there a specific syntax for importing a typeclass and its methods beside `import Control.Applicative ( Alternative, empty, (<|>) )`? (which looks perfectly alright, but, just wondering...)
09:33:49 <Solonarv> the result of that has picosecond precision, I would assume that's good enough...
09:34:05 <Solonarv> inkbottle : import Control.Applicative(Alternative(..))
09:34:16 <Solonarv> same syntax as datatype + constructors
09:34:33 <hyperisco> if I could get the picoseconds out, sure
09:35:45 <hyperisco> ah ha maybe I can use getSystemTime then use the field accessor
09:36:13 <inkbottle> Solonarv: OK, and OK, same syntax then. I haven't found any documentation describing that specific point: "datatype + constructor", I've found; but not "typeclass + methods"...
09:36:22 <Solonarv> utctDayTime gives you the time-of-day, diffTimeToPicoseconds gives you the # of picoseconds
09:36:24 <jophish> Bgamari, I probably won't be able to look at it for at least 3 weeks sadly, and I don't know where to start really
09:36:36 * hackage system-locale 0.3.0.0 - Get system locales  http://hackage.haskell.org/package/system-locale-0.3.0.0 (cocreature)
09:36:44 <jophish> I have a nix expression which reproduces it though
09:37:04 <bgamari> jophish, bisection would be one option
09:37:50 <hyperisco> Solonarv, that gives me the time from midnight on the current day
09:37:51 <bgamari> jophish, another would be to work out what assembly we produce that causes the assembler to produce this sort of relocation
09:38:01 <Solonarv> yes, it does
09:38:06 <hyperisco> never had so much problem getting a timestamp oO
09:38:18 <hyperisco> well that measurement is not useful to me
09:38:31 <Solonarv> do you need the offset from a specific point in time?
09:38:31 <bgamari> the fact that -fPIC doesn't help is quite perplexing
09:38:32 <jophish> Bgamari, I don't have a single working version to. Busect with sadly
09:38:36 <jophish> Bisect*
09:38:38 <johnw> hyperisco: I find that thyme has better accessors
09:38:47 <bgamari> 8.4 worked, no?
09:38:53 <johnw> like: moment ^. milliseconds
09:38:55 <jophish> Nope
09:39:18 <bgamari> oh, rather 8.2
09:39:57 <jophish> Angerman suggested against cross compiling with 8.2
09:40:10 <jophish> I'll give that another try when I get round to it
09:40:24 <bgamari> right
09:40:27 <bgamari> that really ought to work
09:40:48 <jophish> I don't think it should be impossible to get an automated bisection going for this
09:41:31 <hyperisco> I can use getPOSIXTime then convert to a NominalDiffTime… I need a DiffTime though…
09:41:47 <hyperisco> because I have to get to  diffTimeToPicoseconds
09:42:08 <bgamari> jophish, agreed
09:42:47 <jophish> Anyway, sleep now for me. I'll let you know of I make any progress, although it's unlikely before august
09:43:20 <Solonarv> nominalDiffTimeToSeconds gives you the time diff in seconds with 10^-12 precision
09:43:41 <Solonarv> multiply by 1000 and truncate/round to get milliseconds
09:44:18 <pie_> if i have a complex tree like an AST from the following library: https://hackage.haskell.org/package/language-ecmascript-0.17/candidate/docs/Language-ECMAScript3-Syntax.html , is there a way to traverse it, and retrieve (Id _) nodes (well, leaves) without case splitting on the 40 different constructor types?
09:44:30 <pie_> (Profpatsch, ^ :P )
09:44:44 <Profpatsch> pie_: heh
09:45:02 <Profpatsch> pie_: You might want to look into Data.Data.
09:45:49 <hyperisco> whatever version of time I have does not seem to have that function
09:45:50 <Profpatsch> pie_: https://www.microsoft.com/en-us/research/wp-content/uploads/2003/01/hmap.pdf
09:46:41 <hyperisco> if only I could pattern match on MkNominalDiffTime
09:46:50 <hyperisco> such insanity D:
09:46:52 <Solonarv> what version are you using? 1.9 has it
09:47:05 <hyperisco> no idea… have no version in my package.yaml
09:47:10 <Solonarv> https://gist.github.com/Solonarv/66993113f9310b9a2fff29696320a034 here's example code
09:47:28 <Solonarv> ah yeah that'll do it, I don't think 1.9 is in any LTS
09:48:23 <Solonarv> latest in any snapshot is 1.8.0.2
09:49:03 <hyperisco> well if I use show on a POSIX time it gives me something like "1531240976.0689096s"
09:49:08 <hyperisco> which I can then parse...
09:49:16 <Solonarv> I ran into the same issue, just add time >= 1.9.1 to extra-deps in stack.yaml
09:50:06 <Solonarv> you'll need to enable allow-newer as well but it should work
09:52:14 <hyperisco> nope just going to parse it
09:53:36 * hackage dependency 1.2.0.1 - Dependency resolution for package management  http://hackage.haskell.org/package/dependency-1.2.0.1 (vmchale)
09:58:00 <endlessNoobery> is it possible to trace the execution of a function with Debug.Trace?
09:58:48 <lukelau> endlessNoobery: You can trace its result if you call it with traceShowId
09:59:39 <endlessNoobery> so how do I call it on a function result? I keep getting typeset errors lukelau
10:00:02 <lukelau> If you have a function f, then use it like `traceShowId f`
10:00:44 <lukelau> Is it possible to have ghc spit out the name of the type alias instead of the full type in error messages?
10:01:03 <lukelau> I have a really long monad transformer stack and the errors produced are getting pretty ugly
10:03:04 <Solonarv> IIRC ghc tries to match the way the type signature was written (if there is one)
10:03:49 <Solonarv> so if you used a synonym to write the signature you'll probably see it in the error message, but if the signature was written without the synonym you will never see it
10:05:31 <inkbottle> I can't remember what `:set something` in ghci to suppress "warning: [-Wtype-defaults]"
10:05:43 <inkbottle> I can't find it either
10:06:18 <dmwit> -Wno-type-defaults would be my guess
10:06:38 <inkbottle> thanks
10:06:51 <lukelau> Solonarv: Hm the type signature for my function is definitely using the type synonym, but I think somewhere deep within that function calls some generic mtl-style ones
10:07:03 <plugin> What is the cabal new-configure flag to set the output path for compiled executables and libraries?
10:07:15 <dmwit> doesn't (yet) exist
10:07:20 <Solonarv> so one side of the type error uses the synonym and the other side doesn't, right?
10:07:38 <inkbottle> dmwit: it did work
10:07:40 <lukelau> Solonarv: Yes
10:07:44 <plugin> dmwit: derp.  really?
10:07:45 <lukelau> It would seem so
10:08:33 <Solonarv> not much you can do about that then, you'll just need to get used to the errors
10:08:45 <lukelau> “ Couldn't match expected type ‘conduit-parse-0.2.1.0:Data.Conduit.Parser.Internal.ConduitParser … with actual type “Blah MyMonadStack”
10:08:57 <dmwit> plugin: Perhaps it is possible to have a different store, I'm not 100% confident on that. But yes, cabal new-install is AFAIK still a work in progress.
10:09:22 <lukelau> Solonarv: Ok, thanks anyway
10:09:43 <lukelau> Was just wondering how other library authors handle it
10:10:42 <dmwit> plugin: See also https://github.com/haskell/cabal/issues/4558
10:12:22 <plugin> dmwit: Do you happen to know where new-build puts compiled projects?
10:12:40 <dmwit> Sort of. But before we answer that, let's talk about why you want to know.
10:12:53 <dmwit> There may be a better way to do what you want without knowing about cabal's internal directory layout.
10:13:31 <plugin> I want to compile a projet with ghcjs and put the _js in a static directory.
10:15:19 <dmwit> Oh, huh! I don't know much about how new-* and ghcjs get along.
10:15:53 <dmwit> You can poke around in dist-newstyle; all the local build products are in there.
10:16:07 <dmwit> nonlocal build products go in ~/.cabal/store
10:16:14 <plugin> I would have thought fine since cabal new-build --ghcjs does something . . . however, my dist-newstyle is empty
10:17:16 <dmwit> Might be worth asking a bit in #hackage (where all the cabal developers hang out, and where traffic is low enough that your question has a chance of being seen even if the appropriate person isn't around for a few hours).
10:19:51 <cocreature> plugin: I tend to have a script that uses "cabal-plan list-bins" to get the path and symlinks that to some more useful directory
10:21:07 <cocreature> plugin: but you should be able to see where new-build puts your js files from the “Linking …” line at the end
10:22:02 <plugin> cocreature: I must have something botched, there's no "Linking" line
10:22:04 <dmwit> Linking... javascript?
10:22:18 <cocreature> dmwit: yes, ghcjs still calls that linking :)
10:22:45 <cocreature> plugin: hm, even if you specify the executable that you want to built explicitely?
10:23:36 <plugin> You mean via ... Myproj:execName?
10:24:02 <cocreature> yeah or just execName should suffice if it’s not ambiguous
10:24:59 <plugin> Something is wrong: "The project has no package serve." (where serve is the name my executable)
10:25:27 <cocreature> hm, try "cabal new-build exe:serve"
10:25:52 <dmwit> Does your cabal.project file definitely list the location of the package that includes the serve executable?
10:26:01 <plugin> cabal: Unknown build target 'exe:serve’.;There is no executable component 'serve’.;The project has no package 'exe'.
10:26:31 <plugin> There's one .cabal file in the root directory.  my cabal.project says: packages: .
10:27:08 <cocreature> can you show us that cabal file?
10:27:59 <pikajude> is there a channel specifically dedicated to next.hackage?
10:28:10 <pikajude> and ghc 8.2-specific features, backpack, etc
10:28:11 <plugin> https://gist.github.com/o1lo01ol1o/72d31e22c1c340b78555a98a48fe2597
10:28:20 <plugin> lemme know if you want to see anything else
10:29:16 <pie_> Profpatsch, thanks this paper looks useful, i hope i can understand and use it.
10:29:41 <pie_> seems to be my exact problem.
10:31:10 <dmwit> plugin: Weird. I can't reproduce what you're seeing. (Though admittedly I am using `cabal new-build exe:serve` without --ghcjs because I don't have ghcjs installed.)
10:31:20 <cocreature> plugin: hm that looks fine. are you sure it is not something silly like being in the wrong directory?
10:31:31 <dmwit> plugin: Perhaps upgrading cabal-install will help.
10:32:23 <plugin> It might be, I'm doing this through docker and mounting my source directory.  However, printing the path does show the correct root . . .
10:32:58 <5EXABBO0O> Hi all, I've got a small map which takes time to compute and is used often, but (by sprinkling trace around) it seems to be recomputed often - what am I doing wrong?
10:33:00 <pie_> Profpatsch, does this mean i need to patch the library? https://bpaste.net/show/82699e7e1169
10:33:13 <dmwit> Does ls show the .cabal file being there?
10:33:19 <pie_> Profpatsch, or can i just add the stuff in my own source file?
10:33:42 <dmwit> 5EXABBO0O: Kind of hard to say without code, but at a guess: your map is typeclass-polymorphic. Make it monomorphic instead.
10:33:58 <cocreature> might also be some permission error where cabal isn’t allowed to read the *.cabal file?
10:35:52 <plugin> I'm upgrading cabal-install on the docker image, maybe this will lead to something . . .
10:36:46 <plugin> but maybe this is the wrong path, all I want is for ghcjs to build the project with the needed dependancies, is there a way to do that without stack or new-build?
10:37:10 <plugin> "path" meaning, method, not filesystem path . . .
10:38:22 <fresheyeball> edwardk: are you kmett my another name?
10:38:49 <fresheyeball> by another name*
10:38:50 <lyxia> that's him
10:39:34 <cocreature> plugin: I really don’t think new-build is causing problems here (unless you really do have a fairly old version). I’ve used new-build with ghcjs and it has worked just fine
10:39:42 <dmwit> lyxia: But does he smell as sweet?
10:41:51 <plugin> cocreature: I might be stuck with the version on this docker image though, since it looks like it may break things: Continuing even though the plan contains dangerous reinstalls.
10:42:32 <cocreature> plugin: which version are you using atm?
10:43:03 <c50a326> people suggested ghc-mod to me for doing something about imports and the package.yaml, I can't see anything in the docs that covers imports...
10:43:10 <c50a326> can anyone point me to a command or feature or something?
10:45:32 <plugin> cocreature: I'm not sure, it's building from the base image: haskell:7.10.2 and otherwise just does an "cabal update && cabal install cabal-install"
10:47:08 <cocreature> plugin: try "cabal --version"
10:49:13 <plugin> cabal-install version 1.24.0.2
10:49:44 <cocreature> ah yeah, I’m not too surprised new-build is broken in that case
10:52:05 <plugin> Well, at least that is solved.  Do you know if there's a way to compile the project using the vanilla ghcjs command?
10:53:10 <cocreature> well cabal calls that under the hood but piecing the commands together yourself is really annoying. upgrading cabal is probably a lot easier
10:54:33 <Turion> What libraries for parametrised/indexed monads do people actually use? Is there an overview anywhere?
10:54:35 <plugin> kk, i'll see if I can get it building with 2.2.0
10:54:47 <Turion> I quite like https://github.com/dorchard/effect-monad, but it seems unmaintained
10:54:52 <justsomeguy> Hey all I've been learning haskell and have run into an issue resolving overlapping instances. Here's an example similar to what I'm dealing with: https://lpaste.net/28206325838118912
10:55:08 <justsomeguy> not sure how to have calls delegated to the right instance
10:55:11 <plugin> Thanks for the help!
10:55:36 <dstolfa> Turion: hmm, dominic moved to kent (a year ago?) and is probably working on something else now
10:55:37 <edwardk> fresheyeball thats me
10:57:12 <Turion> dstolfa: I'm sure he has some interesting project coming along! But if people need that library it would be good to find a maintainer. If there is interest, I'd fork it.
10:58:16 <lyxia> Turion: indexed seems to work well
10:58:36 <Turion> justsomeguy: How about (Show' a, Show' b) => Show' (Either a b)?
10:59:05 <pikajude> is cabal haddock expected not to work on a package that uses templatehaskell and requires a signature?
10:59:13 <dstolfa> Turion: this seems to have coeffects as well, which is kind of neat indeed
10:59:32 <dstolfa> Turion: this may or may not be based on a paper that he did with Alan Mycroft, let me dig it up
10:59:50 <dstolfa> (not the whole thing, but that part alone)
11:00:05 <harpocrates> pikajude: do you have an example? AFAIK cabal haddock shouldn't be limited by this sort of thing
11:00:09 <dstolfa> Turion: http://tomasp.net/academic/papers/structural/coeffects-icfp.pdf
11:00:26 <Turion> lyxia: indexed seems nice as well. But it's not more active than monad-effect, I think..?
11:00:27 <pikajude> harpocrates: i do indeed
11:00:30 <pikajude> i can push it up to github in a bit
11:00:43 <pikajude> i actually have a meeting now, i'll be back in about a half hour and i can publish an example
11:00:57 <justsomeguy> Turion: I think that would compile but I want my code to delegate to one side of the either even if the other side is not in the class
11:01:18 <pikajude> oh, actually, i spoke too soon
11:01:26 <pikajude> GHC 8.4.3 fixes the issue
11:02:10 <Turion> dstolfa: Yes, I remember Dominic's talk at ICFP 2016 about coeffects, it was great! I mean, the theory is all great. I'm looking for an active project that I can base sort-of production code on.
11:03:14 <Turion> So I'm looking for a popular-ish library supplying indexed/parametrised monads that is maintained (as in, will eventually merge reasonable PRs and respond to an issue within a week or two)
11:04:59 <Turion> Are there other approaches than indexed and parametrised? Indexed is basically type state, and parametrised is sort of a type-level monoid. Phil Wadler said we should index monads by morphisms in a category. Are there even other approaches?
11:05:33 <Turion> justsomeguy: How could that work? Let's say you have instance Show' a => Show' (Either a b). Then I try to execute show' (Right b).
11:05:59 <dstolfa> Turion: not that i'm aware of, but if you find out do let me know :>
11:06:10 <Turion> dstolfa: Haha ok :)
11:06:39 <Turion> Right now the most probable thing is that I'll fork monad-effect or ask to become a maintainer
11:07:43 <Turion> Other places where I could ask?
11:07:53 <dstolfa> Turion: email may be best?
11:08:16 <justsomeguy> Turion: For my application I would want "show' (Right b)" to fail to typecheck
11:08:50 <glguy> justsomeguy: Then don't make an instance of Show' for Either
11:08:50 <Turion> dstolfa: I mean other open places where people would know more libraries going that direction
11:09:27 <dstolfa> Turion: ah! i don't know a better place to ask about haskell libs than #haskell :)
11:09:28 <[exa]> anyways, why is there no Alternative (Either l) ?
11:09:37 <[exa]> (or did I fail searching?)
11:09:58 <Turion> justsomeguy: Yep, agree with glguy. If your show' doesn't work for Right, then it doesn't operate on Either.
11:10:04 <lyxia> [exa]: https://mail.haskell.org/pipermail/libraries/2018-June/028868.html
11:10:19 <Profpatsch> pie_: I think they need to instantiate Data for you.
11:10:38 <[exa]> lyxia: oh thanks!
11:11:18 <Turion> [exa], lyxia: The proposal sounds interesting, but ...why?
11:11:22 <[exa]> any reason why it wasn't implemented a long time ago?
11:11:26 <Turion> What's the use case?
11:11:28 <[exa]> Turion: because people _LOVE_ errors
11:11:48 <Turion> Sure, but is that how you'd expect an Alternative to behave?
11:12:13 <dstolfa> sounds a little bit like a sum type
11:12:14 <[exa]> Either has that kind of behavior for Functor and Applicative, why not Alternative?
11:12:23 <Turion> Not doubting the proposal in the first place, but it seems like I have a bad or different understanding of Alternative
11:12:33 <lyxia> You have two computations, they both fail, we want the error to reflect the two.
11:12:41 <Turion> [exa]: No, it doesn't need Monoid e for Functor or Applicative
11:12:44 <lyxia> reflect the two errors
11:13:01 <[exa]> oh I see
11:13:28 <[exa]> Turion: so the big question is whether to mappend the Left's or not?
11:13:30 <lyxia> [exa]: that would be Validation https://hackage.haskell.org/package/either-5.0.1/docs/Data-Either-Validation.html#t:Validation
11:13:41 <Turion> [exa]: Yes
11:13:49 * dstolfa still doesn't see how this is not just a sum type?
11:13:56 <[exa]> lyxia: ok wow, thanks!
11:13:59 <glguy> You get this Alternative behavior with Except
11:14:06 <Turion> The Applicative just discards the second error
11:14:13 <glguy> http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Except.html#t:Except
11:14:21 <lyxia> Turion: then make the error type (First e)
11:14:55 <justsomeguy> glguy: Regardless of of it's good practice or not (this is a clearly contrived example) is what I described possible at all in the language?
11:15:15 <glguy> justsomeguy: It looks like you're misunderstanding typeclasses in that paste
11:16:02 <Turion> lyxia: Hmm yes... I guess it's just a matter of what the default behaviour should be if we don't add anything
11:16:28 <glguy> When you write: instance (...) => C (Either a b) -- What you're saying is that this is the one true instncae for this type. It doesn't matter what you put in the (...) part
11:16:32 <Turion> justsomeguy: What do you want to achieve? Do you want the line "show' (Left a)" to type check and "show' (Right b)" not to type check? That's not possible in Haskell
11:17:05 <glguy> justsomeguy: Types are the level of static information we have, whether you're using Left or Right at the value level doesn't come into play at the level of instance resolution
11:17:11 <Turion> lyxia: Validation is cool! Why doesn't it have an Applicative that mappends the errors?
11:17:25 <Turion> Oh, it does and I failed to read
11:17:37 <Turion> Why doesn't it have a Monad?
11:17:41 <lyxia> Turion: "First" shows that combining the errors by default results in a more general behavior than dropping one of them
11:17:54 <lyxia> Turion: because there is no monad compatible with that Applicative instance
11:18:21 <Turion> Wow... is that easy to see?
11:19:07 <Turion> I always find it mysterious how statements like this can be proven... is there an additional law that Applicatives from Monads satisfy that is broken here?
11:19:10 <[exa]> glguy: why does Except require (Monoid e) for Alternative?
11:19:20 <lyxia> There should be a simple proof...
11:19:32 <glguy> [exa]: So that empty can be the identity for <|>
11:19:42 <[exa]> oh yes they need mempty
11:19:48 <[exa]> thanks
11:21:00 <Turion> join (Success (Success a)) = Success a
11:21:01 <Turion> join (Success (Failure e)) = Failure e
11:21:01 <Turion> join (Failure e) = Failure e
11:21:30 <Turion> That's the obvious instance..? Why do I never get to combine two errors?
11:21:32 <glguy> Turion: You can show that ap behaves differently from (<*>)
11:21:34 <[exa]> yes and if I want to discard the right-side error, I want to use First.
11:21:41 <[exa]> Thanks everyone!
11:21:54 <plugin> A local build of ghcjs on macos Sierra:  very painful, painful, or not painful?
11:22:08 <glguy> Turion: and if ap behaves differently from (<*>) then your Monad instance is wrong
11:22:44 <Turion> Ok, but maybe I've just written a stupid Monad instance?
11:23:42 <glguy> Not stupid, just wrong
11:24:10 <glguy> or right if you fix the Applicative instance to match
11:24:26 <Turion> glguy: I wanted to refer to that particular instance. How do I know there is *no* Monad instance giving the right ap?
11:25:14 <glguy> :t (>>=)
11:25:15 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:25:27 <glguy> In the error case you won't have any value with type 'a' to pass to the function (a -> m b)
11:25:31 <Turion> Intuitively, a Monad can't mappend it's errors because Failure e >>= f can only ever be Failure e. It needs an a in order to find out whether f a is an error
11:25:37 <glguy> so you'll never be able to get your hands on the potential second error to merge in
11:25:40 <Turion> glguy: Right
11:25:54 <Turion> Ok, this is a satisfying explanation, thanks :)
11:26:04 <Turion> (Still wondering how I'd ever formally prove this...)
11:27:42 <glguy> I did an Agda proof of a related statement that you might be interested: There's no generalized way to write "join" for the composition of two monads: https://glguy.net/composing-monads/Help.html
11:28:02 <Turion> (Ok, but then I think that Alternative instance that was proposed on the mailing list shouldn't be done for Either e. The right thing is Validation e, and that instance already exists)
11:28:15 <Solonarv> there is only one way to write join :: Validation e (Validation e a) -> Validation e a, AIUI
11:28:15 <glguy> (though you can get an applicative out of the composition of two applicatives)
11:28:16 <Turion> glguy Oh wow, going to look at that now :)
11:28:40 <Turion> Solonarv: Maybe there is a kind of Yoneda argument like there is only one id :: a -> a
11:29:10 <dmwit> ?free join :: Either e (Either e a) -> Either e a
11:29:11 <lambdabot> $map_Either f g . join = join . $map_Either f ($map_Either f g)
11:29:35 <lyxia> the argument is parametricity
11:31:11 <Solonarv> so because there is only one join, only one pure, and only one fmap, there is only one Monad (Either e) instance
11:31:45 <Turion> lyxia: It gets harder if we have Monoid e, because then suddenly we could output Failure mempty in unexpected cases
11:31:53 <Solonarv> this Monad instance gives rise to an `ap` that is different from the one in Applicative (Validation e)
11:34:25 <Turion> I guess we can't implement a crazily different Monad instance with Monoid e, because we never get the opportunity to mappend two errors
11:34:42 <Turion> Ok, I guess I get that bit now :) thanks
11:34:44 <lyxia> Turion: by parametetricity you can show that (Failure e >>= _) doesn't depend on the second argument
11:35:02 <Turion> Yes, so it must be Failure e or Failure mempty
11:35:14 <lyxia> but    Failure e >>= \_ -> return () = fmap (const ()) (Failure e) = Failure e
11:35:54 <Turion> Yes
11:35:56 <lyxia> (it could also have been Failure (e <> e) ...)  but ^ this shows Failure e is the only choice
11:36:04 <Turion> Oh right
11:36:36 * hackage brick 0.37.2 - A declarative terminal user interface library  http://hackage.haskell.org/package/brick-0.37.2 (JonathanDaugherty)
11:38:04 <justsomeguy> glguy: I'm building off of https://wiki.haskell.org/GHC/AdvancedOverlap specifically the last solution for resolving overlapping instances using closed type families.
11:38:28 <justsomeguy> regardless I think I've come up with a solution that works for my use case anywa
11:38:50 <pie_> Profpatsch, still on the first skim of the paer, "Trying to understand the type of gfoldl directly can lead to brain damage", inb4 speaaking from experience
11:39:22 <lyxia> Turion: two standard ways to formalize arguments by parametricity are free theorems (the output of the ?free command a few minutes ago) and to enumerate implementations (put in some canonical form).
11:40:39 <glguy> pie_: The syb package offers a higher-level interface to using the Data typeclass. For example listify
11:40:40 <glguy> http://hackage.haskell.org/package/syb-0.7/docs/Data-Generics-Schemes.html#v:listify
11:40:47 <Turion> lyxia: Yes, I must read the free theorems paper properly
11:41:06 <pie_> glguy, thanks ill look \o/
11:41:14 <glguy> pie_: or for your original question "everything" might be the easier entry point
11:41:46 <Turion> We had indexed/parametrised Monads. Now how about indexed/parametrised *Arrow*s? Are there any packages for that?
11:41:52 <Turion> :t Arrow
11:41:53 <lambdabot> error: Data constructor not in scope: Arrow
11:42:15 <Turion> Ah, does lambdabot do type classes or something like this?
11:42:19 <glguy> pie_: I had two occasions to use syb to traverse the Haskell-src-exts and Template-haskell ASTs that might be interesting examples:
11:42:23 <glguy> https://github.com/glguy/AddParens/blob/master/Main.hs https://gist.github.com/glguy/aaee14ee68749de22504412e0bc1951d
11:43:04 <pie_> glguy, i have two goals right now: 1 is to rename identifiers, which this looks like it should cover pretty easily, the other will be to find common subAST between two AST
11:43:07 <gratin> "couldn't match expected type Request with m0 Request
11:43:16 <gratin> how do I get the value from the parseRequest monad
11:43:53 <lyxia> Turion: free theorems are quite powerful but I don't know a layman explanation of the idea.
11:43:54 <glguy> pie_: The "Underscore.hs" example is related to your renaming question, it looks for a placeholder syntax node and replaces that with a variable
11:44:41 <glguy> You can do that using 'everywhere'
11:45:10 <Turion> lyxia: It's ok, I have basic understanding of it, but I'm not up to speed with it
11:45:16 <pie_> glguy, yeah it looks like it (the paper more or less gives a direct example with the increment stuff a tthe beginning)
11:46:02 <pie_> glguy, back when i was doing this with python my amazing horrible alrogithm for finding subtrees was to take the set intersection of all node hashes
11:46:20 <pie_> cant remember how i did the node hashing. probably hashing strings or something.
11:47:59 <pie_> (incrementally hashing course, dont want n^2 or whatever xD. something about merkle/hash trees)
11:49:46 <Turion> If m is an indexed monad, then I could reimplement Kleisli arrows for m, which satisfy some generalisation of Arrow, like described here: https://github.com/dorchard/effect-monad/issues/11. Is there any library for arrows doing something like this?
11:52:38 <butterthebuddha> Given [a], and a -> b, I'd like the [(a, b)]
11:53:10 <lyxia> Turion: what I meant was that free theorems sometimes seem overkill compared to enumerating normal forms, something that I've almost never seen when talking about parametricity.
11:53:17 <fresheyeball> instance Zoom m n x y => Zoom (ResourceT m) (ResourceT n) x y
11:53:24 <fresheyeball> Is this instance possible?
11:53:30 <glguy> :t map . ap (,)
11:53:32 <lambdabot> (a1 -> a2) -> [a1] -> [(a1, a2)]
11:54:11 <butterthebuddha> Sweet, ty
11:54:12 <glguy> fresheyeball: yes
11:54:14 <dmj`> :t \f xs -> (id &&& f) xs
11:54:15 <lambdabot> (t -> c') -> t -> (t, c')
11:54:53 <glguy> butterthebuddha: If I expected that code to stay aorund for long I'd write:  [ (x, f x) | x <- xs ]
11:55:02 <fresheyeball> glguy: is it out there somewhere?
11:55:11 <fresheyeball> implimenting it is intimindating
11:55:11 <glguy> fresheyeball: I don't know
11:55:17 <fresheyeball> ok
11:55:42 <gratin> i'm so confused
11:55:44 <butterthebuddha> Ah of course, I didn't think of that
11:55:53 <gratin> i can't even get the base example to compile
11:55:54 <gratin> https://haskell-lang.org/library/http-client
11:56:02 <lyxia> fresheyeball: you could reuse the implementation for ReaderT
11:56:20 <dmj`> :t \(f :: a -> b) -> map (id &&& f)
11:56:21 <lambdabot> (a -> b) -> [a] -> [(a, b)]
11:56:23 <glguy> fresheyeball: I wrote some code for deriving these instances at one point
11:59:59 <Profpatsch> pie_: Yeah, you don’t really need to understand gfoldl.
12:00:07 <Profpatsch> gmap and stuff is enough for your use-cases.
12:00:43 <glguy> It's worth making a note to come back and understand what gfoldl's type is doing, though. It's pretty cool and worth understanding if you want to advance your Haskell
12:00:43 <Turion> Given two type families t1 and t2, how can I write the constraint "forall a . t1 a ~ t2 a"?
12:00:56 <glguy> like that
12:01:03 <glguy> oh, not with the forall
12:02:13 <Turion> I want to constrain a closed type family in a type class
12:02:42 <Turion> (Of course not exactly like that, that would be silly, but this is the vague idea
12:03:06 <Turion> I'm looking at http://hackage.haskell.org/package/constraints-0.10/docs/Data-Constraint-Forall.html, but doesn't work yet
12:04:53 <lyxia> Well, there's quantified constraints coming up, but even if you could write that there's no way to solve that constraint for any nontrivial type families.
12:05:24 <Turion> If I could define an open type family like this:
12:05:24 <Turion> type family TheyAreEqual t1 t2 :: a -> Constraint where
12:05:24 <Turion>    TheyAreEqual t1 t2 a = t1 a ~ t2 a
12:05:30 <Turion> But this doesn't work (yet)?
12:06:53 <Turion> lyxia: My aim is to restrict the type level monoid in effect-monad to really satisfy the monoid laws
12:07:36 <Turion> E.g. forall a f . Plus m (Unit m) f ~ f
12:07:37 <lyxia> That won't work.
12:08:00 <lyxia> "forall" actually means something stronger than literally "for all"
12:08:41 <Turion> Why wouldn't it work?
12:08:51 <lyxia> A "forall" property has to hold "uniformly" in a way
12:08:59 <Turion> Well, at least I'd like to state the constraint
12:09:19 <Turion> Because it's really cumbersome if ma >>= return doesn't have the same type as ma
12:10:13 <Turion> In all instances I'd use it would have that type, so the type checker would be able to check it after I've applied enough type variables hopefully?
12:10:33 <lyxia> you could add a type class method carrying such a proof
12:11:33 <lyxia> class Thing m where proof :: forall a f. Dict (Plus m (Unit m) f ~ f)
12:11:43 <Turion> lyxia: Wow... ok that's a cool idea. Let me try to make it work.
12:12:39 <Turion> But how can it be a method if its kind isn.t *?
12:12:49 <lyxia> its kind is *
12:12:57 <lyxia> Dict :: Constraint -> *
12:13:00 <Turion> Oh I didn't see the Dict
12:13:12 <Turion> Ok, need to look into how Dict works, thanks!
12:13:55 <Turion> And every time I need the proof I just call the method..?
12:14:12 <Turion> I can't find this Dict thing on hoogle
12:14:26 <dmwit> https://hackage.haskell.org/package/constraints-0.10.1/docs/Data-Constraint.html#t:Dict
12:14:45 <Turion> Thanks!
12:14:48 <dmwit> data Dict a where Dict :: a => Dict a
12:15:55 <lyxia> Turion: use hoogle.haskell.org instead of the other one
12:16:33 <Turion> lyxia: You just improved my life.
12:16:49 <Turion> I gotta hang out here more often, it's helpful and fun (for me at least ;) )
12:17:05 <Ariakenom> #haskell is great fun
12:21:42 <fresheyeball> glguy: type instance Zoomed (ResourceT m) = Zoomed m
12:21:44 <fresheyeball> ?
12:25:06 * hackage haskell-lsp-types 0.4.0.0 - Haskell library for the Microsoft Language Server Protocol, data types  http://hackage.haskell.org/package/haskell-lsp-types-0.4.0.0 (AlanZimmerman)
12:26:06 * hackage haskell-lsp 0.4.0.0 - Haskell library for the Microsoft Language Server Protocol  http://hackage.haskell.org/package/haskell-lsp-0.4.0.0 (AlanZimmerman)
12:40:40 <ZeuPiark> hello
12:47:25 <gratin> is anyone here familiar with servant-client that could help me out?
12:47:35 <gratin> i'm struggling to understand some stuff about it
12:47:43 <gratin> https://haskell-servant.readthedocs.io/en/stable/tutorial/Client.html
12:48:50 <dsal> I've got an API that takes a function that's something like   a -> a  -- what's a good way to provide one of these functions that maintains a bit of state?
12:50:36 * hackage ghc-typelits-natnormalise 0.6.2 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  http://hackage.haskell.org/package/ghc-typelits-natnormalise-0.6.2 (ChristiaanBaaij)
12:51:06 <dsal> More concretely:  I'm currently using mapAccumL to have two concurrent iterators on a list where one of them trails the other by 4s (each record has a time that can be plucked out).
12:52:21 <dmwit> Fix your API, I guess.
12:53:12 <dsal> I guess I could make it foldy
12:55:36 * hackage prospect 0.1.0.0 - Explore continuations with trepidation  http://hackage.haskell.org/package/prospect-0.1.0.0 (isovector)
12:58:36 * hackage ghc-typelits-knownnat 0.5.1 - Derive KnownNat constraints from other KnownNat constraints  http://hackage.haskell.org/package/ghc-typelits-knownnat-0.5.1 (ChristiaanBaaij)
13:02:36 * hackage ghc-typelits-extra 0.2.6 - Additional type-level operations on GHC.TypeLits.Nat  http://hackage.haskell.org/package/ghc-typelits-extra-0.2.6 (ChristiaanBaaij)
13:08:18 <glguy> fresheyeball: did you figure out the instance or do you still need help?
13:11:45 <dsal> Hmm...  I can't think of a type for a fold.  I guess I could do continuations.
13:13:31 <Rembane> dsal: a -> a, and not a -> b?
13:14:01 <dsal> a is in this case, not actual 'a'  Vector Text
13:15:07 * hackage html-charset 0.1.0 - Determine character encoding of HTML documents/fragments  http://hackage.haskell.org/package/html-charset-0.1.0 (hongminhee)
13:16:18 <dmwit> dsal: Why not change your API to take an `a -> m a` for some Monad m?
13:16:54 <dmwit> If you can do this, you can recover your original API using `Identity` for the monad, and you can do your stateful thing using `State Whatever` for the Monad.
13:17:20 <dsal> Yeah.  I think that's the kind of thing I want to do.  I just started doing something like that with continuations and it's kind of gross.
13:17:42 <dsal> Can I have a list of these things at that point?
13:18:18 <dmwit> "these things"?
13:18:38 <Rembane> dsal: [a] ?
13:18:50 <dmwit> ?hoogle (a -> Maybe b) -> Forest a -> Forest b
13:18:51 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
13:18:51 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
13:18:51 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
13:19:17 <dsal> I call this type "Transformer" (it does data manipulation on rows of telemetry logs as well as renaming or adding columns).   I process my data with a list of Transformers
13:19:31 <dmwit> "this type"?
13:19:49 <dmwit> So many dangling antecedents.
13:20:01 <Rembane> dsal: a = Transformer?
13:20:26 <dsal> Transformer does two things.  The interesting one here is     Vector Text -> Vector Text
13:20:36 <dsal> All of the existing ones are stateless, but I have one stateful one.
13:21:28 <Rembane> dsal: What does the Text contain?
13:22:01 <dsal> It's a row of CSV data.    example row:    2018-07-07,17:28:27.640,-33,-33,100,-80,2,10,-20,100,-78,0,39.463955 -121.411174,466,10,15.469860468532229,-4.583662361046586,-24.064227395494576,12.6,0.1,6,-5,-9,339,6,5,9,-1024,236,-903,1,-1,-1,-1,0,1,-1,-1,0x0000000000000002,9.9,0.00000,0.00000
13:22:06 * hackage microformats2-parser 1.0.1.9 - A Microformats 2 parser.  http://hackage.haskell.org/package/microformats2-parser-1.0.1.9 (myfreeweb)
13:22:56 <dsal> That's transformed, but for example, it negated some dB values, translated some radians to degrees, computed a distance and (the one that needs state) computed speed.
13:23:45 <Rembane> dsal: I suppose you have a good reason for not using a richer datatype. So, which reason is it? :)
13:24:49 <dsal> What do you mean richer?  The thing that gives me the log gives me CSV and I've got tools that consume the same data.  My tool just fixes up a few annoyances in it.
13:25:05 <dsal> Or do you mean richer than Vector Text?
13:25:20 <Rembane> dsal: Ah, I see. I thought you wanted to do more processing where the types of data was more important.
13:25:25 <Rembane> dsal: that too. :)
13:25:26 <Rembane> brb
13:26:48 <dsal> The column lists vary.  the CSV header defines what's in the data.  A given Transformer declares its interest in a column named "Ptch(rad)", renames it to "Ptch(deg)" and then parses the numeric value, converts radians to degrees, and prints it back out.
13:27:04 <dsal> If it doesn't find that column, it doesn't do anything interesting.
13:27:43 <Rembane> dsal: Ah. Neat!
13:32:38 <dsal> It's not anything particularly fancy, just a thing I use for some data I accumulate.  I'm trying to figure out a better way to do it.  The  `a -> m a` thing sounds good, I'm just not sure about a consistent type that allows me to have a list of them.
13:33:18 <statusfailed> How can I "pattern match" against a value x :: SomeException?
13:33:36 <statusfailed> do I use fromException?
13:33:56 <Rembane> dsal: There will be different m, so you need to hide the type of m.
13:34:02 <Rembane> dsal: You need a heterogenous list.
13:34:10 <glguy> statusfailed: Why do you have a SomeException?
13:34:45 <statusfailed> glguy: I used async's waitCatch to make sure a transient worker thread didn't kill my main program
13:35:02 <glguy> Yes, fromException will help to cast it to the type you're interested in
13:35:30 <statusfailed> glguy: waitCatch for this purpose is OK, right?
13:36:12 <glguy> Yeah, using waitCatch is fine for finding out how a thread finished
13:36:19 <statusfailed> thanks!
13:41:56 <SrPx> Is there any way to have multi-line strings today that doesn't require putting \s everywhere?
13:42:12 <lyxia> quasiquotes
13:58:31 <SrPx> lyxia how exactly?
13:58:36 <SrPx> have googled and found nothing useful
13:59:02 <glguy> Try googling "haskell quasiquote multiline string"
13:59:18 <SrPx> that is actually exactly what I googled lol
13:59:28 <SrPx> but alright
13:59:29 <SrPx> thanks
14:00:00 <SrPx> I found a solution with imports though
14:00:10 <lyxia> https://hackage.haskell.org/packages/search?terms=multiline
14:00:38 <infinisil> Whoa, Applicative is magical
14:01:10 <hexagoxel> if i have a data-structure containing mutable stuff (e.g. IORefs), is there a clever way of getting the equivalent of normally pure instances (e.g. binary or aeson) for it?
14:01:40 <glguy> You can make a mirror data structure with all the references removed and convert to that first
14:02:36 * hackage vector-sized 1.0.3.1 - Size tagged vectors  http://hackage.haskell.org/package/vector-sized-1.0.3.1 (jle)
14:02:36 <hexagoxel> how about a type class Freezable with associated type Frozen?
14:02:43 <hexagoxel> does this exist?
14:04:53 <hexagoxel> plus TH magic to get instances without the boilerplate, of course.
14:13:40 <lyxia> why no generics D:
14:14:01 <glguy> Generating new datatypes with generics is messy/impossible
14:14:16 <pwestling> if I've written a monoid instance for my type, is there any way to get the required Semigroup instance for free, given that <> should just equal mappend? Or do I have to type it out
14:15:53 <glguy> pwestling: You can write: instance Semigroup T where (<>) = <the actual implementation>; instance Monoid T where mempty = <actual implementation>
14:18:02 <lyxia> fair point.
14:20:06 * hackage expressions 0.1.9 - Expressions and Formulae a la carte  http://hackage.haskell.org/package/expressions-0.1.9 (jakubdaniel)
14:21:30 <glguy> I have an example of how to do it, actually, but the technique is limited
14:24:38 <glguy> https://github.com/glguy/tries/blob/master/src/Data/GenericTrie/Internal.hs#L481-L492
14:26:45 <lyxia> I tried too, https://github.com/Lysxia/generic-recursion-schemes
14:41:06 <Habib> Hey, does anyone know how I can generalise the type signature for a value? I'm having a little trouble with this monadic Stack action that I want to generalise so it works with both Stack a m r as well as State [a] m r.
14:41:24 <Welkin> hello habibi
14:41:28 <Habib> https://github.com/habibalamin/stack-hs/blob/master/spec/StackSpec.hs#L88-L106
14:41:29 <Habib> Hey.
14:42:48 <Habib> It's the exact same code that I have to repeat so that I have one of each with a different type for each.
14:42:52 <UnkDevE> Hey I have a function that returns only Nothing and I don't know why https://github.com/UnkDevE/Sudoku/blob/master/sudoku.hs#L91
14:44:10 <lyxia> Habib: what does the compiler say if you try stackManip :: _ => m ()
14:45:28 <lyxia> UnkDevE: you could use Debug.Trace to print intermediate results
14:46:59 <Solonarv> Habib: you've *already* defined a MonadStack class, use that
14:47:14 <UnkDevE> Thanks I've stepped through it a couple of times too
14:48:07 <Habib> lyxia: interestingly, I can do this:
14:48:15 <Habib> λ import Data.Maybe (fromMaybe)
14:48:16 <Habib> λ stackManip = do { a <- pop; push 1; push 2; push 3; b <- pop; push (fromMaybe 0 a); push (fromMaybe 0 b) }
14:48:17 <Habib> λ :t stackManip
14:48:18 <Habib> stackManip :: (MonadStack m a, Monad m, Num a) => m ()
14:48:51 <Habib> But that's in GHCi. I could have sworn that didn't work even in GHCi last time I tried.
14:48:51 <Solonarv> does that answer your earlier question?
14:49:03 <pikajude> everything works in ghci
14:49:43 <Solonarv> you want stackManip :: MonadStack m Integer => m ()
14:50:07 <Solonarv> can you see why?
14:51:56 <Habib> Well, looks like `(MonadStack m Integer, Monad m) => m ()` requires FlexibleContexts, but `(MonadStack m a, Monad m, Num a) => m ()` works.
14:52:27 <Solonarv> FlexibleContexts is completely harmless
14:53:39 <Habib> I was facing a problem about a week ago where even just defining the value without defining the type signature looked like it was forcing a concrete type because of the usage in the spec example, which I was pretty sure shouldn't have been happening, since GHC uses the most general type by default.
14:53:46 <Habib> Now I feel like i was imagining things.
14:53:58 <Habib> I struggled for quite a bit with that.
14:54:09 <Habib> I guess I just needed a fresh start.
14:54:28 <Solonarv> I honestly have no idea if that's a thing that happens because I never write a top-level binding without a type signature
14:54:28 <Habib> Hell, I couldn't even export or import the MonadStack class. Just basic things.
14:54:35 <Habib> I really must have been off my rocker.
14:54:51 <Habib> Well, I started with the type signature, but when I started having trouble, I decided to let GHC infer it, so I could use whatever it inferred.
14:57:16 <c_wraith> there was a recent change to ghc that makes it reject inferred types that would need an extension which isn't present to write.
14:57:37 <c_wraith> a couple years ago, anyway
14:57:47 <Habib> I started this project a few weeks back.
14:58:10 <Solonarv> c_wraith: which ghc version is that change in?
14:58:26 <c_wraith> but if you used ghc before that, you might be surprised by some things that no longer work.
14:58:49 <c_wraith> Solonarv, I am guessing 8.0, but I'm not sure on that.
14:59:09 <Solonarv> I have -XKitchenSink so it's not like I'd notice such a change
15:02:32 <Solonarv> also, Habib, minor nitpick on your MonadStack class: mtl-style classes are usually of the form MonadBlah x y z m | m -> x y z, with the monad as the last argument
15:02:49 <Habib> What's the advantage?
15:03:25 <Solonarv> the main advantage is just principle of least surprise / convention
15:03:36 * hackage gnss-converters 0.3.52 - GNSS Converters.  http://hackage.haskell.org/package/gnss-converters-0.3.52 (markfine)
15:03:45 <Solonarv> I guess there might be some edge cases where partially applying the type class is useful
15:04:23 <Solonarv> but when I was reading your code I stumbled a bit on the class head; I had to think for a moment to figure out which of 's' and 'a' is the monad
15:05:33 <Habib> I see. I'll keep that in mind. mtl was my inspiration for that class. All of this is written in a naive way.
15:13:41 <Gurkenglas> What's a good abstraction over functions like "parse [] = []; parse (_:x:xs) = map read (words x) : parse xs"? "([s] -> (a, [s])) -> [s] -> [a]" allows more arguments than it seems like this should, "(forall m. Monad m => m s -> m a) -> [s] -> [a]" (or even restricting to applicative there) is kinda fumbly to implement. Did I miss a way?
15:16:39 <Solonarv> "forall m. Monad m => m s -> m a" is equivalent to "s -> a" because you can instantiate m ~ Identity, so that's not it
15:17:47 <Solonarv> you could define some kind of Parser monad and take Parser s a as an argument
15:18:00 <lyxia> uh, that function can consume more than one s so it's not quite s -> a
15:19:03 <Solonarv> oh, good point
15:19:23 <Gurkenglas> You can also observe whether it took any s at all
15:20:14 <Solonarv> huh, it could actually work...
15:22:13 <lyxia> that forall type looks like a free monad of sorts
15:22:43 <lyxia> Free ((->) s) a -> [s] -> [a]  ?
15:22:54 <glguy> Gurkenglas: Did you see that code for doing your do-notation/underscore idea for avoiding naming intermediate values from the other day? (I don't figure you'll want to use it but it works)
15:23:48 <Solonarv> it's basically "MonadParser s m => m a" with "class MonadParser s m | m -> s where popToken :: m s"
15:23:53 <Solonarv> adn passing the instance dictionary
15:24:15 <Solonarv> that actually makes more sense than what I initially thought
15:25:43 <Gurkenglas> lyxia, Free ((->) s) a -> [s] -> [a] looks good, thx
15:26:03 <Gurkenglas> glguy, was there more than the TH oneliner?
15:26:32 <glguy> Oh, that was just an example of using it, the implementation was a few more lines
16:12:20 <valon> Hi all, does the tutorial "Learn you haskell for great good" is still relevant in 2018?
16:12:24 <srk> looking for some feedback on this https://github.com/sorki/network-status/
16:12:27 <srk> valon: yes!
16:13:10 <valon> @srk Ok there is nothing in it deprecated ?
16:13:10 <lambdabot> Source not found. :(
16:13:11 <srk> valon: most of the generic (not library specific) haskell tutorials are still relevant, it doesn't age as fast as for example javascript ecosystem
16:13:14 <hpc> some minor things might be different, depending on the libraries it covers
16:13:23 <hpc> but i don't think it covers anything that's changed majorly?
16:13:35 <tablee> I find this code is very elegant. https://github.com/dag/all-about-monads/blob/master/examples/example24.hs
16:13:41 <valon> srk ok thank you, ill start with it
16:13:44 <tablee> and feel I understand exactly how it runs through all possible vals for each var, checking their combinations against the constraints, dropping non-cosistent partial solutions along the way, and finally eliminating all but the full and consistent solutions.
16:13:56 <tablee> But there is one bit of the impl I can not explain, and that is how the mapN traversal is accumulating all the various combinations of [(Var, Val)] in the NDS a (aka StateT [] PS a). Can anybody give me some intuition about that specific aspect?
16:14:16 <srk> valon: Real World Haskell is quite nice as well
16:15:03 <valon> srk: which one you think is better for a complet beginner?
16:16:03 <srk> pff, the first one I would say
16:16:27 <rotaerk> I didn't like RWH at all
16:16:41 <valon> rotaerk: why?
16:17:01 <hpc> cis194 might be the best introduction right now
16:17:06 <hpc> since it's an actual course
16:17:08 <hpc> @where cis194
16:17:09 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
16:17:24 <rotaerk> because the examples were unnecessarily elaborate; for instance, one chapter I felt like I was learning more about barcodes than about haskell
16:18:00 <rotaerk> it felt like it wasn't as focused on *haskell* as it should have been
16:18:55 <valon> rotaerk: ok, and what about "Learn you haskell"
16:18:57 <valon> ?
16:19:33 <tablee> in particular, I would expect either a tree or list of lists to be required for combining all vars with vals, but can't picture where it's happening.
16:19:40 <rotaerk> LYaH was fine, in comparison
16:19:55 <srk> rotaerk: I've mostly learned parsing, monads and tranformers from it
16:20:06 <srk> typeclasses as well
16:20:41 <rotaerk> LYaH is what I learned from at least, but it only goes so far, at which point you will need to rely not on courses/books but on learning additional things on an ad-hoc basis
16:20:43 <rotaerk> LYaH provides a reasonable foundation
16:20:45 <tablee> the StateT would be s -> [(a,s)]
16:20:55 <rotaerk> though haskellbook.com might be better (but I have no need of it now)
16:22:17 <tablee> so, for each state, there are potentially multiple (a,s)s, but I can't see how there are multiple of those lists pf (a,s)s
16:22:36 <tablee> of*
16:23:40 <valon> ok I think i'll start with LYH and maybe take some chapter from RWH after that
16:25:06 <valon> thanks all, see you
16:26:22 <tablee> does the question make sense, or should I rephrase it?
16:27:27 <tablee> it almost seems like the types are hiding one level of list nestedness
16:41:06 <tablee> I'll try starting from the other end... What is a good use case for  `type NonDetState a b = StateT [b] [] a` ?
16:42:05 <tablee> (in the example I was looking at, b is (Var, Val), both aliases for String
16:49:08 <Cale> tablee: Normally you'd put the arguments the other way around, but parsing strings of tokens of type b, in order to produce results of type a
16:49:08 <fishythefish> tablee: "for each state, there are potentially multiple (a,s)s, but I can't see how there are multiple of those lists pf (a,s)s" - yes, but why do you expect there to be multiple lists (in a single NDS)
16:49:16 <Cale> (with backtracking)
16:50:21 <tablee> fishythefish - well, somehow all the combinations need to be gradually built up, via the traversal (mapM_) and the mplus in tryAllValues
16:51:11 <tablee> @Cale - yes, I think that backtracking might be very relevant
16:51:11 <lambdabot> Unknown command, try @list
16:52:01 <tablee> here's the example https://github.com/dag/all-about-monads/blob/master/examples/example24.hs
16:52:51 <tablee> so, I was imagining the mplus building the breadth and traversal building the depth of something like a tree
16:52:51 <fishythefish> tablee: I don't see a mapM in there, but why do you suppose the mplus and the multiple calls to tryAllValues aren't sufficient?
16:54:20 <tablee> aha, this examples passes in the values one by one, rather than tarversing over a list of values with mapN, but the effect is the same
16:55:23 <glguy> tablee: How about this version? still (basically) uses a monad instance https://gist.github.com/glguy/867b2899a00214e3228145d5c61f8072
16:55:26 <tablee> so, sticking with that impl, the multiple calls to tryAllValues is building what? A list of the StateTs?
16:56:03 <fishythefish> tablee: well, each call to tryAllValues gives you an NDS (), but you have to understand it monadically
16:56:44 <fishythefish> you start with an empty variable state and create a single problem state out of it
16:57:15 <fishythefish> the first tryAllValues performs both possible substitutions for parent1 (eliminating any inconsistent results) and leaves you with a set of possible problem states
16:57:22 <tablee> glguy, that is nice too, but the specific issue I have is just how the StateT [] is being built up
16:57:54 <tablee> fishythefish, so far so good
16:57:58 <fishythefish> the next tryAllValues does the same thing (with parent2), but starts with each state left from the previous step
16:58:04 <fishythefish> likewise for child
16:58:23 <tablee> OK, I get that but...
16:58:48 <fishythefish> the `mplus` for StateT/[] just says it can combine the different lists into one via (++)
16:59:08 <tablee> right, that is what I thought of as the breadth
16:59:29 <tablee> but I can't see how the depth is built up
16:59:37 <fishythefish> the depth of what?
16:59:47 <tablee> (maybe the tree anlogy is what is confuing the issue, and me!)
17:00:21 <fishythefish> if i'm understanding your analogy correctly, the key is that `mplus` does some flattening - you don't care how you traversed to the current state
17:00:30 <fishythefish> you just need a list of the possible states to proceed from
17:00:44 <glguy> ?unmtl StateT s [] a
17:00:45 <lambdabot> s -> [] (a, s)
17:01:09 <tablee> i was reading t as if you gradually get each of  [(parent1,female)]  [(parent1,male)]  [(parent2,male), (parent1,female)]  [(child,female), (parent2,male), (parent1,female)]  [(parent2,female), (parent1,male)]
17:01:42 <glguy> tablee: every line of the do-notation takes you "deepr" if I understand what you're asking
17:02:03 <tablee> glguy - yes, I think that is how I was imagining it
17:02:34 <glguy> and when the backtracking search (interpretation of list monad) backtracks is also reverts to the previous state value
17:02:35 <tablee> and the mplus creating siblings
17:02:43 <fishythefish> the mplus doesn't create siblings
17:02:46 <fishythefish> it collects them
17:03:22 <tablee> what is "collect" in this context? I was thinking in terms of alternatives
17:04:13 <fishythefish> `setVar var "male"` and `setVar var "female"` correspond to proceeding down the two different branches from a given state - this creates the siblings
17:04:25 <fishythefish> mplus just concatenates the lists they produce
17:04:52 <tablee> well that's what I meant - the mplus add the siblings created by setVAr
17:05:01 <tablee> adds*
17:06:16 <tablee> that's why it seems like a tree - with each tryAllValues line of the do adding to the depth (ie children to the aforementioned siblings)
17:06:25 <fishythefish> you can think of it that way, sure
17:06:32 <fishythefish> is your question why the final result isn't presented as a tree?
17:07:31 <tablee> no - I feel like I undertsand everything apart from I would expect [s->[a,s]] somewhere
17:07:41 <tablee> no - I feel like I undertsand everything apart from I would expect [s->[(a,s)]] somewhere
17:07:46 <glguy> A (StateT s [] a) isn't a list of alternatives
17:07:55 <glguy> It's a function:   s -> [(a,s)]
17:08:18 <glguy> give it a "starting state" and you get a list of alternatives composed of a result 'a' and an "ending state" s
17:08:23 <tablee> no but do the multiple calls in the do, to tryAllValues mimc that?
17:08:30 <glguy> mplus and >>= build up more of these things
17:09:08 <glguy> in the end all you have is the final composed function    s -> [(a,s)], all knowledge of the intermediate "tree nodes" is lost
17:10:09 <tablee> so the s param of the lambda is the previous state, and all state before that is lost?
17:11:41 <tablee> and if that is the case, why does he need to filter out partial solutions - they would be none
17:11:50 <tablee> there*
17:12:23 <tablee> at the bottom level, there could only be full solutions, or none at all
17:12:50 <tablee> I suppose it's in case you don't get to the bottom because everything got eliminated before then
17:13:00 <fishythefish> it's a question of efficiency
17:13:24 <fishythefish> if you can determine after only substituting 2 variables that a state cannot be made consistent, better to prune it now than after all possible substitutions of the rest
17:13:42 <tablee> yes, but I am talking about the final pruning
17:13:55 <fishythefish> the getFinalVars?
17:14:09 <tablee> if you get to the bottom, and have lost all intermediate state, then all solutions are full
17:14:47 <fishythefish> only if you didn't screw up as the programmer
17:15:17 <tablee> but ... if you don't get as far as all the vars, then you will of course have only partial solutions and getFinalVars would eliminate them
17:15:19 <fishythefish> if I forgot to type line 153, for example, then child is missing from the substitutions in all my states
17:15:57 <tablee> also true
17:15:58 <fishythefish> getFinalVars also has the extra role of actually retrieving the substitution list from the state
17:16:10 <tablee> good point!
17:17:05 <tablee> this has been helpful - thinking about it as tree building was probably very wrong :)
17:17:41 <tablee> because you only have the most recent state (the input param) and calculate the next leve state from that
17:17:52 <tablee> level states*
17:19:55 <tablee> and the mapM_ I was mentioning comes from `mapM_ tryAllValues family *> getFinalVars`
17:20:32 <tablee> where family = ["parent2","parent1","child"]
17:21:13 <tablee> that traveral would have the same effect as calling tryAllValues 3 times,right?
17:23:13 <tablee> I think calling tryAllValues once for each var might be easier to digest and form the right picture of how the state functions state param evolves, but mapM is more scalable!
17:24:58 <tablee> thanks Cale, glguy and fishythefish - it seems clear now
17:54:11 <vasiliy_san> Hi all. Why people often declare application Monad like this:
17:54:11 <vasiliy_san> ```
17:54:11 <vasiliy_san> newtype AppM a = AppM (ReaderT Context IO a)
17:54:11 <vasiliy_san>     deriving (Functor, Applicative, Monad, MonadIO, MonadReader Context)
17:54:11 <vasiliy_san> ```
17:54:11 <vasiliy_san> Instead of just declaring a type synonym? `type AppM a = ReaderT Context IO a`
17:55:35 <pavonia> vasiliy_san: Type synonyms can't be applied partially, which might be one of the reasons
17:56:59 <pavonia> (not in that spacial case, though, as you could just define `type AppM = ReaderT Context IO`)
17:57:29 <geekosaur> also because sometimes they want to declare other instances, which would either overlap or spread more widely than intended with the type synonym (and need an additional extension as a reminder of that)
18:00:50 <vasiliy_san> Aaah. So instead of using monad transformers, I can create some custom monad like `class DatabaseConnection m where getUser :: m User` and then implement an instance for  `AppM` (which wouldn't work with a type synonym)?
18:02:41 <geekosaur> it will "work" but it would want to apply to any ReaderT, and overlap with a more generic instance that someone might declare (which causes problems because of the open world assumption: something that doesn't know about your instance may misbehave, and sometimes the generic one might be picked instead of the specific one you wanted)
18:08:14 <vasiliy_san> I got it. I also saw an approach when people write code using "Has" constraints like this: `getUser :: (MonadReader c m, HasDatabaseConfig c) => m User`. So instead of defining an application Monad, they build application-specific logic on top of Reader and State monads. I guess the approach which was in my question and that "Has something" are two competing to solve the same problem of defining Application specific logic
18:12:08 <vasiliy_san> thanks for your help!
18:47:39 --- mode: ChanServ set +o glguy
18:47:40 --- mode: glguy set -bo alexdao!*@*$##fix_your_connection glguy
18:56:02 <pavolzetor> hello, I am trying to figure out how to keep track of line number, and offset in Foundation.Parser
18:56:58 <pavolzetor> it is unclear how would I do that. I was thinking maybe unsafePerformIO with some global counter
18:59:12 <glguy> No, the answer is not unsafePerformIO
19:00:19 <glguy> There are better parser combinator libraries to use if you want that functionality
19:00:45 <dibblego> @remember glguy No, the answer is not unsafePerformIO
19:00:45 <lambdabot> It is forever etched in my memory.
19:03:12 <pavolzetor> I know, I just dislike pulling another dependency; I basically need state and parser together
19:03:51 <pavolzetor> and IO preferably so I can print error messages
19:06:09 <monochrom> State and parser and IO together can be easily achieved by "ParsecT IO". parsec has it. Other parser libraries probably do too.
19:06:57 <monochrom> But you shouldn't need IO for merely error messages.
19:07:56 <monochrom> Instead you should have your driver (which can do I/O) call up your parser, find out whether you get "Right answer" or "Left errormessage", and then it's your driver who prints it.
19:08:16 <pavolzetor> I checked parsec, and it uses text so I have to do conversions;
19:08:35 <geekosaur> parsec can use Text, String, or ByteString
19:08:50 <pavolzetor> that is the usual way, but I have this tiny scanner and reporting error instead of just printing them is overengineering
19:08:51 <monochrom> Conversion still doesn''t imply IO.
19:09:23 <monochrom> I am really appalled that now you're degenerating into grasping any straw in sight for excuses.
19:09:33 <pavolzetor> I mean conversions between foundation string and text
19:10:26 <monochrom> No, sprinkling I/O all over all data processing that could otherwise be pure is overengineering.
19:14:40 <glguy> pavolzetor: Getting off of foundation will make a bunch of stuff easier and interoperate better
19:15:38 <pavolzetor> monochrom, I do not get it, if I can create a simple solution why would I bother with reporting errors, I usually just use the 'error' function and it works well
19:16:03 <monochrom> Using the 'error' function still doesn't imply IO.
19:18:06 * hackage ffmpeg-light 0.12.2.0 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.12.2.0 (AnthonyCowley)
19:18:56 <pavolzetor> glguy, I did that in past, foundation is coherent, but I agree it lacks severely on parsing front; I may just use State and avoid the Foundation.Parser altogether
19:20:22 <butterthebuddha> Does megaparsec have a parser that succeeds without consuming any input?
19:20:40 <geekosaur> return () ?
19:20:53 <geekosaur> (or pure () if you prefer)
19:20:55 <butterthebuddha> That makes sense
19:21:38 <monochrom> And people toss around "simple' like they toss around "best".  It becomes an undefined word.  At the end of the day it comes down to the subjective "simple means what I like".
19:21:39 <pavolzetor> monochrom: that's true, I came here to ask how to solve it in Foundation, and you basically tell me use different library; that is not helpful
19:23:29 <monochrom> But here is an actually objective metric.  If you use unsafePerformIO, then the things you want happen under unsafePerformIO will happen at basically unpredictable times (including "never" and "more times than you think"), unless you learn lazy evaluation properly.  (Hint: To date every resource on lazy evaluation is still sketchy, including mine.  You won't be able to learn lazy evaluation properly.)
19:23:37 <geekosaur> you'll find thta many people aren;t find of alternative Preludes — and you're finding out why with this problem
19:23:44 <geekosaur> *aren't fond of
19:23:46 <glguy> pavolzetor: It's helpful. You're using a library that doesn't offer the functionality you want. There are libraries that do
19:24:36 <monochrom> But if you use ParsecT IO, the order of the I/O effects and the IORef state changes are easily predictable --- and this is the objective kind of "easy", because it is code order.
19:25:09 <geekosaur> I mean, base has a parser built in as well: ReadP. which doesn't stop people from using sensible parsers when they find a need.
19:26:00 <monochrom> Oh I showed up late and I didn't catch that your question requires staying in Foundation.
19:26:12 <monochrom> Then my answer is "can't be done".
19:26:23 <monochrom> And that is a helpful answer.
19:26:50 <monochrom> Because if someone asked "I want to solve the halting problem" then the helpful answer is "can't be done".
19:26:56 <geekosaur> I would not be surprised if someone could write a ParsecT instance for Foundation.String. whether it's worth the effort is another question.
19:30:01 <pavolzetor> monochrom:I see, so it will not make the whole call stack strict?
19:30:43 <monochrom> What the hell is that?
19:31:10 <Zipheir> Probably an obvious question, but is it necessary to provide a Semigroup instance when creating a new Monoid instance?
19:31:10 <monochrom> I cannot answer "is the call stack red or blue?" either.
19:31:30 <lyxia> Zipheir: yes
19:31:38 <pavolzetor> geekosaur: I am starting to see the issues, for example foundation just recently added 'peek' function to their parser so you can actually write LL parser with it ;)
19:31:51 <Zipheir> lyxia: Aha. Thanks.
19:33:23 <pavolzetor> I will user Parsec then
19:33:42 <glguy> Zipheir: It's easier to do both now that it was, instance Semigroup T where (<>) = <the actual implementation>; instance Monoid T where mempty = <actual implementation>
19:33:53 <pavolzetor> monochrom: I meant that when an unsafePerformIO is inside call stack, it will not do lazy evaluation in that call stack
19:33:55 <glguy> mappend has a default implementation of (<>) now
19:34:18 <Welkin> is <> no longer an alias for mappend?
19:34:33 <Welkin> is Semigroup now using it for append?
19:34:56 <glguy> Right
19:36:04 <geekosaur> pavolzetor, unsafePerformIO is done lazily. which is a decent part of why it's unsafe: you have no control over when it is evaluated relative to other I/O
19:36:40 <pavolzetor> thanks, make sense now I will avoid it
19:37:34 <glguy> using unsafePerformIO for this is a bit like opening /dev/kmem to get mutable variables in your program :)
19:37:44 <Zipheir> glguy: Right, since mappend defaults to (<>), iirc.
19:38:14 <monochrom> You have a totally wrong model of running Haskell. I can't see how unsafePerformIO can be inside a call stack, even if you correct the terminology and say "evaluation stack" or just "stack".
19:40:56 <monochrom> (Pro-tip: If you stick to "continuation stack" you are always safe regardless of languages and execution+evaluation strategies.)
19:41:05 <mniip> monochrom, depends on whether GHC is able to optimize out the translation between return conventions for a and (# State# s, a #)
19:41:08 <pavolzetor> glguy: :), actually, is there alternative to the Monad transformer stuff if I want mutable variables inside parsec? I dislike the transformers quite strongly
19:41:36 <mniip> if not, unsafePerformIO# will be in the return stack
19:41:56 <mniip> also IIRC there's this noDuplication thing that might stick around in the stack
19:42:11 <monochrom> State# s does not exist in Cmm.  Returning (# State# s, a #) becomes returning a.
19:42:26 <mniip> is it *completely* erased in Cmm
19:42:34 <mniip> or does it have a zero-with argument
19:42:41 <mniip> like Proxy#
19:43:20 <monochrom> Have you read some Cmm lately?
19:44:11 <mniip> frankly no it's been a while
19:44:54 <monochrom> But last time you read it you saw nothing for State# s, not even a zero-width thing, right?
19:45:09 <mniip> don't think I've dug IO *that* deep
19:45:30 <pavolzetor> monochrom: you are right, I have to read about it
19:47:02 <monochrom> It doesn't have to be deep.  A simple "main = getLine >>= putStrLn" will do.
19:47:51 <monochrom> Or for fun, main = getLine >>= \s -> putStrLn (unsafePerformIO (putStrLn s >> return s))
19:50:03 <mniip> %! echo 'import GHC.IO; main = getLine >>= \s -> putStrLn (unsafePerformIO (putStrLn s >> return s))' > a.hs
19:50:03 <yahb> mniip:
19:50:07 <mniip> % :! ../usr/bin/ghc a.hs -tmpdir . -ddump-cmm
19:50:07 <yahb> mniip: [1 of 1] Compiling Main ( a.hs, a.o ); ==================== Output Cmm ====================; []; ==================== Output Cmm ====================; [section ""data" . u1jx_srt" {; u1jx_srt:; const stg_SRT_2_info;; const System.IO.putStrLn_closure;; const GHC.Base.$fMonadIO_closure;; const 0;; },; section ""data" . u1jy_srt" {; u1jy_srt:;
19:50:10 <mniip> %% :! ../usr/bin/ghc a.hs -tmpdir . -ddump-cmm
19:50:10 <yahb> mniip: http://qp.mniip.com/y/75
19:50:24 <Welkin> o.o
19:50:40 * geekosaur keeps misreading that symbol as "ugly_srt"
19:51:14 <monochrom> Oh SRT is actually ugly.  Simon Marlow recently wrote about it and how he found out a better way.
19:51:32 <mniip> frankly I have no idea how to read this
19:51:38 <Welkin> lol, cmm looks almost like assembly
19:51:50 <monochrom> Also there is https://haskell.godbolt.org/ for having someone else's computer show you asm code.
19:52:27 <geekosaur> I'd prefer the assembly, tbh. at least I can read x86 and x86_64 (and several other varieties) of assembler
19:52:57 <Welkin> what is the point of cmm then?
19:53:00 <monochrom> Normally I can't read Cmm cold either.  My trick is to ask for -ddump-simpl -ddump-prep -ddump-opt-cmm -ddump-asm and read them in that order. Core is a good roadmap for reading Cmm.
19:53:03 <Welkin> why not go directly to asm?
19:53:28 <Welkin> it looks like it is already 90% of the way there
19:53:34 <geekosaur> I imagine some optimizations are easier at cmm level than asm
19:53:44 <geekosaur> it's not quite assembler
19:54:47 <monochrom> Probably because it's Cmm -> {x86_32, x86_64, PPC, ARM, llvm, 6502, Z80, Casio FX-3600P}
19:55:14 <geekosaur> also, iirc you're not working directly with machine registers at cmm level. there's some work going on to improve x86_64 register allocation going from cmm to asm
19:55:26 <monochrom> Quite frankly while STG->x86 on its own is OK, no one would want STG -> {x86_32, x86_64, PPC, ARM, llvm, 6502, Z80, Casio FX-3600P}.
19:56:02 <Welkin> ghc compiles to 6502?
19:56:07 <geekosaur> (I wish you luck getting anything useful in terms of ghc onto a 6502 :p )
19:56:20 <geekosaur> or the alculator for that matter
19:56:28 <Welkin> wasn't the Z80 used in the gameboy?
19:56:35 <monochrom> No but I could add it easily, without needing to learn STG.
19:56:43 <monochrom> "easily"
19:56:44 <Welkin> oh, lol
19:56:53 <mniip> x86_32 != x86 mind
19:57:43 <monochrom> Yeah should have thrown in x86, x86_32, x86_64, x64_86, x32_86 for good measure.
19:58:00 <Welkin> you forgot MIPS
19:58:02 <monochrom> If I cover all combinations and permutations I can't be wrong.
19:58:12 <monochrom> Yeah! I knew I was missing one.
19:58:29 <glguy> RISC-V?
19:58:34 <geekosaur> sparc's in there
19:59:09 <monochrom> But you see if you have even 3 different targets, you will want one more layer like Cmm to sit between STG and your targets.
20:03:21 <mniip> morale is: don't have 3 different targets and let specialized software (llvm) do the job
20:03:55 <monochrom> Yeah unfortunately llvm was invented rather much later than ghc.
20:03:59 <geekosaur> well, except it's damn near impossible to tell llvm enough of what's going on that it doesn't degrade to generic low-performance code
20:04:16 <monochrom> Cmm was doing llvm's today role.
20:04:36 <monochrom> And don't tell me "but SUIF existed back then!"
20:04:36 <geekosaur> it's not real happy with receiving pre-CPSed code, for example
20:05:04 <monochrom> And yeah that too.
20:06:08 <monochrom> It is also why the urban-legendary "high level assembly" that is C failed miserably and proved that it is neither high-level nor assembly.
20:06:43 <monochrom> Exactly like the Holy Roman Empire.
20:07:15 <Welkin> since when was c high-level assembly?
20:07:24 <geekosaur> it's something of a meme
20:07:35 <monochrom> Urban legend.  I.e., falsehood.
20:07:44 <Welkin> I learned assembly first, then came to C and felt like it lacked the fine-grained detail of assembly
20:07:56 <monochrom> We are in agreement.
20:07:59 <Welkin> basically, C was too high level
20:08:01 <monochrom> But try voicing that in ##c.
20:08:07 <geekosaur> (I think it started out as a denigration of C as too close to the hardware to count as a high level language)
20:08:17 <mniip> idk I learned C first and assembly later and they seem to complement each other perfectly
20:08:32 <mniip> I've written many things that use both
20:08:36 <Welkin> processing a stream of data one bte at a time is trivial in assmebly
20:08:45 <Welkin> in C it is a huge pain with masks and bit-shifting
20:08:52 <Welkin> on bit*
20:08:53 <geekosaur> e.g. manual memory management, 'register' variables (which were recently removed from the standard iirc), etc.
20:08:55 <Welkin> one bit*
20:08:56 <monochrom> Oh I'm sure C has its historic place.  As did the Holy Roman Empire.
20:10:59 <mniip> monochrom, is C++ the pars orientis or the pars occidentis?
20:11:16 <monochrom> I don't know. What is pars?
20:12:20 <mniip> idk I just quickly browsed some memes and discovered that the roman empire split into two
20:12:25 <geekosaur> c++ is an overgrown macro processor >.>
20:12:52 <geekosaur> (so, who here remembers cfront?)
20:14:01 <Welkin> I thought it was a long-running troll by bjarne
20:14:01 <monochrom> Perhaps I can bet on "C++ is pretty byzantine". :)
20:14:04 <glguy> I feel like you guys are being too hard on both C and C++ :)
20:18:57 <mniip> I wonder if anyone was mad enough to write a haskell compiler in C
20:19:15 <monochrom> Manual memory management is not low-level. Algol before it and Pascal after it (and probably also Modula-3, Ada...) all had manual memory management, and these were considered high-level.
20:19:25 <Welkin> rust has it
20:19:34 <mniip> ah, hugs
20:20:00 <monochrom> The register quantifier is a very little thing, probably added under pressure for "performance tuning".
20:20:34 <glguy> Hugs was written in C (though it's not a compiler)
20:20:44 <monochrom> What make C low-level are pointer arithmetic and bit fields and some guarantee on how structs map to memory layout.
20:21:00 <Zipheir> mniip: Probably pars occidentis, lots of self-described C programmers are probably first-generation C++ barbarians :)
20:21:34 <mniip> hmm
20:21:51 <mniip> ghc-stage1 and ghc-stage2 have different sourcesets, right?
20:21:59 <boinkd> is there a version of guard for MonadError, i.e. something that takes a boolean?
20:22:23 <monochrom> And these are really not for you to play low-level games, but rather (or except?) interfacing with asm modules.  So what mniip said.  A otherwise high level language that opens up a little bit just for asm FFI.
20:23:21 <mniip> C is also stupendously portable
20:23:40 <mniip> well, something like ANSI C at least
20:23:57 <Welkin> ANSI Common Lisp? :D
20:24:12 <mniip> which - some packages still follow C89 to this day
20:24:20 <mniip> declarations before statements
20:24:36 <Welkin> didn't C89 lack lexical scoping?
20:26:08 <geekosaur> huh? some impleentations of pre-ANSI C lacked it
20:26:27 <geekosaur> what C89 didn't have, nor some later instantiations, was mixing declarations with code
20:26:31 <monochrom> Yikes haha.
20:27:00 <mniip> "ISO C90 forbids mixed declarations and code"
20:27:08 <mniip> that's what I was referring to yes
20:27:57 <Welkin> does haskell count as portable since there is basically only one compiler?
20:27:58 <geekosaur> (ans even those pre-ANSI versions had lexical scoping, they just didn't allow declarations in *inner* blocks. the outermost block of a function was still lexically scoped)
20:28:22 <mniip> Welkin, that's not what portable means
20:28:36 <mniip> and no, I guess haskell is on the "least portable" end of spectrum
20:28:52 <mniip> GHC requires so much of its environment
20:29:14 <Welkin> does portability have to do with the compiler or the platform then? Or both?
20:29:38 <monochrom> Platform.
20:29:39 <mniip> it's about "can I run standardized haskell code on device X"
20:29:54 <mniip> which in our case probably means haskell98
20:30:32 <Welkin> so it has more to do with a standard
20:31:19 <mniip> no
20:31:29 <geekosaur> 2010 is a valid standard
20:31:31 <Welkin> o.o
20:31:38 <geekosaur> however ghc doesn;t actually adhere to either
20:31:45 <mniip> it's more about there being a well-known way of writing code that wouldn't be called "weird"
20:31:56 <Welkin> ANSI Common Lisp was last updated in 1994
20:32:02 <Welkin> does that count as portable?
20:32:11 <mniip> such that writing in that style would be a sufficient compromise for your code to be portable
20:32:56 <mniip> I'm not familiar enough with lisp to vouch for it but I hear it's about as portable as C
20:35:13 <blankhart> is there a reason Data.Map shouldn't/can't export empty as a pattern synonym?
20:37:11 <monochrom> It can. How will you use it?
20:38:26 <blankhart> i have some records that contain maps and i wanted to create bidirectional synonyms for easier pattern matching
20:38:46 <blankhart> i am not the first to have the question https://stackoverflow.com/questions/46144610/haskell-pattern-matching-match-map-empty-any-with-any-map-map-k-v
20:38:49 <mniip> foo (M.null -> True)
20:38:57 <mniip> = ...
20:39:33 <monochrom> Oh if it's on StackOverflow I'm sure someone already gave a good answer.
20:40:21 <blankhart> the stack overflow answer is basically what mniip gave but it is unsatisfying because it is not bidirectional
20:41:21 <blankhart> and if i am already creating an empty constant (such as a mempty value) it is annoying that i can't just pattern match on it
20:43:44 <monochrom> You can make a feature request somewhere.
20:45:00 <blankhart> ok thanks, there are greater annoyances i was just wondering
20:45:46 <blankhart> There is a very loud amusement park right in front of my present lodgings.
20:46:08 <mniip> amusing
20:58:06 * hackage typerep-map 0.1.0 - Efficient implementation of a dependent map with types as keys  http://hackage.haskell.org/package/typerep-map-0.1.0 (vrom911)
21:03:33 <pally> :t (<$>)
21:03:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:04:03 <pally> > fmap even [1..3]
21:04:05 <lambdabot>  [False,True,False]
21:04:48 <Welkin> pally want a cracker?
21:09:59 <pally> in the above example, is f a list?
21:10:35 <Welkin> f is a functor
21:10:53 <pally> so, list functor?
21:10:55 <Welkin> a list has an instance for functor defined
21:11:15 <Welkin> the functor typeclass only include the fmap function
21:11:27 <Welkin> so it represents things that you can map over
21:21:41 <glguy> pally: In your example f was [], yes
21:33:36 * hackage yaml 0.9.0 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.9.0 (MichaelSnoyman)
21:39:06 * hackage first-class-families 0.1.0.0 - First class type families  http://hackage.haskell.org/package/first-class-families-0.1.0.0 (lyxia)
21:45:54 <pally> I want to demonstrate: fs <*> xs
21:46:22 <pally> > [odd, abs] <*> [-1, -3]
21:46:24 <lambdabot>  error:
21:46:24 <lambdabot>      • No instance for (Integral Bool) arising from a use of ‘odd’
21:46:24 <lambdabot>      • In the expression: odd
21:46:56 <Welkin> use zip ($)
21:47:20 <Welkin> > zipWith ($) [add, abs] [-1, -3]
21:47:22 <lambdabot>  error:
21:47:22 <lambdabot>      • Variable not in scope: add :: c -> c
21:47:22 <lambdabot>      • Perhaps you meant one of these:
21:47:32 <Welkin> > zipWith ($) [odd, abs] [-1, -3]
21:47:34 <lambdabot>  error:
21:47:34 <lambdabot>      • No instance for (Integral Bool) arising from a use of ‘odd’
21:47:34 <lambdabot>      • In the expression: odd
21:47:36 <cocreature> a) that’s not the same thing and b) it won’t work either
21:47:49 <cocreature> you can’t make a list that contains both Bool and Int
21:47:53 <Welkin> ah yeah
21:47:56 <Welkin> I didn't notice that
21:48:03 <cocreature> (or something that is an instance of Integral if you want to be precise)
21:48:15 <Welkin> > zipWith ($) [**2, abs] [-1, -3]
21:48:17 <lambdabot>  error:
21:48:17 <lambdabot>      A section must be enclosed in parentheses thus: (** 2)
21:48:25 <Welkin> > zipWith ($) [(**2), abs] [-1, -3]
21:48:27 <lambdabot>  [1.0,3.0]
21:48:34 <Welkin> so much spam
21:50:09 <pally> cocreature, yes, came up with a big example, forgetting about that rule where a list must contains elements of the same type.
21:50:23 <pally> but it does work.
21:50:35 <pally> with (**2), for example.
21:50:48 <pally> s/big/bad/
21:50:53 <pally> err..
21:51:19 <Welkin> collection data types are homogenous in haskell (and it is good practice to do so anyway)
21:51:37 <Welkin> there are heterogenous lists, but they are pretty much just fancy tuples
21:51:43 <Welkin> and a pain to use
21:54:41 <cocreature> if all you want is Bool and Int, you could go with [Either Bool Int]
21:56:01 <buttons840> https://lpaste.net/1572937467563081728   can someone with c2hs experience take a look at this? The hooks are not generating the Haskell code I would expect
21:56:40 <buttons840> also, can someone recommend a good c2hs project I could look at for example code?
21:56:43 <cocreature> buttons840: what is the actual C type that is being returned?
21:56:56 <cocreature> is Image a struct?
21:57:25 <buttons840> cocreature: the comment give the C function declaration (i might be a bit shaky on the correct C terms)
21:57:42 <buttons840> cocreature: is that what you're asking, or do you want to see the struct?
21:58:28 <cocreature> buttons840: the comment doesn’t tell me if Image is a struct, a typedef for an int, a typedef for a pointer to a struct, …?
21:58:35 <buttons840> i'd be happy to throw the whole project up on github if it would help
21:58:46 <buttons840> Image is a struct
21:59:01 <cocreature> Haskell’s C FFI does not support passing structs by value
21:59:09 <cocreature> so a pointer is really your only option here
22:01:33 <cocreature> I think c2hs has some option to generate a wrapper that operates on a pointer automatically but it’s been too long since I’ve used c2hs. hopefully it’s documented in the user guide
22:02:11 <cocreature> looks like prefixing with % might do the job
22:02:14 <buttons840> i'll double check; do you prefer to use something other than c2hs? or has it just been awhile since making bindings?
22:02:54 <buttons840> cocreature: yeah, prefixing % allows you to pass a struct to a function by value, but the % cannot be used on function return values
22:03:14 <cocreature> are you sure about that? the docs suggest that the syntax for return types and argument types is the same
22:03:40 <cocreature> otherwise you might have to write your own wrapper
22:04:06 <cocreature> it has mostly just been a while since I wrote bindings (except for llvm-hs which uses hsc2hs but that’s not a decision I made).
22:04:22 <cocreature> c2hs looked somewhat unmaintained for a while but it looks like maintenance has been picked up again
22:08:24 <buttons840> cocreature: yeah, a compile error from c2hs specifically says "  Structure wrapping is not allowed for return parameters.
22:09:15 <buttons840> when I put a % in front :\
22:09:17 <cocreature> then you will probably have to write the wrapper yourself
22:14:28 <buttons840> cocreature: will I have to write a Storable instance for all these structs? i'm thinking so
22:15:33 <buttons840> just wondering if that's common when making bindings, or if there's some solution I'm missing
22:15:43 <cocreature> depends on how you want to work with them. if you want to marshal them to Haskell values, you will have to write Storable instances. if you just want to pass them on to some other C function, you should be able to work with the pointer directly
22:15:55 <cocreature> yeah Storable instances are definitely common when making bindings
22:16:25 <pally> >  (,) <$> [1,2] <*> [3,4]
22:16:27 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
22:16:43 <pally> > [1,2] <*> [3,4]
22:16:45 <lambdabot>  error:
22:16:45 <lambdabot>      • Could not deduce (Num a0)
22:16:45 <lambdabot>        from the context: (Num (a -> b), Num a)
22:16:51 <pally> alone won't work
22:17:00 <cocreature> pally: 1 is not a function
22:17:07 <cocreature> or rather functions are not an instance of Num
22:17:14 <cocreature> so 1 cannot be used as a function
22:17:28 <cocreature> :t (<*>)
22:17:29 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:17:44 <cocreature> if you substitute f = [], you can see that the first argument should be a list of functions
22:21:06 * hackage enclosed-exceptions 1.0.3 - Catching all exceptions from within an enclosed computation  http://hackage.haskell.org/package/enclosed-exceptions-1.0.3 (MichaelSnoyman)
22:23:52 <pally> > ((,) <$> [1,2] <*>) [3,4]
22:23:55 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
22:24:47 <pally> I keep forgetting the number 1 rule in Haskell (as I was told), "functions application has the highest precedence"
22:26:37 <glguy> I've got a tool to add extra parentheses back in if you're having trouble with precedence :)
22:38:08 <rprije> Hi. I have a type like this: "newtype X (s ::Symbol) a". I'd like to somehow run symbolVal on that Symbol. I've been trying something like "f (_ :: X (s :: Symbol) a) = symbolVal (Proxy :: Proxy (s :: Symbol)" but it's not recognising s as an instance of KnownSymbol.
22:39:06 <cocreature> rprije: you need to add a KnownSymbol constraint to the type signature of "f"
22:46:47 <rprije> cocreature: Hmm, thanks. Putting "f (_ :: KnownSymbol s => X (s :: Symbol) a" doesn't seem to help. I suppose I have to make that s an instance of KnownSymbol some other way.
22:46:59 <jackdk> and possibly `{-# LANGUAGE ScopedTypeVariables #-}`?
22:47:34 <jackdk> https://lpaste.net/687411641733611520
22:47:49 <cocreature> rprije: I was thinking of something like f :: KnownSymbol s => X s a -> String
22:48:17 <cocreature> or better "f :: forall s a. KnownSymbol s => X s a -> String" because you are going to need ScopedTypeVariables here
22:48:23 <jackdk> check the paste above.
22:51:47 <rprije> cocreature, jackdk: Thanks a bunch, that seems to typecheck now. I'm a bit fuzzy on why forall is needed.
22:55:24 <cocreature> rprije: if you don’t have the "forall" ScopedTypeVariables does not come into play
22:55:40 <cocreature> so the "s" in your function body will not refer to the "s" in your type signature
22:57:19 <rprije> cocreature, aha, that makes sense, thank you
23:04:30 <vasiliy_san> Hi all.
23:04:30 <vasiliy_san> I want to gain some basic intuition about Extensible Effects before I decided if it worth reading more about them. First of all, I don't sure if that term refers to a particular technique, but it looks like people refer to http://okmij.org/ftp/Haskell/extensible/index.html when they say Extensible Effects.
23:04:30 <vasiliy_san> I skimmed through several blog posts and it looks like Extensible Effects are about building a mapping from "Effects" types to concrete implementations. And effectful functions just declare type constraints like "I want an effect which is cable of some particular thing like Printing". And to define such constraint we actually query a mapping mentioned before by a type of the desired effect. Does such intuition reflect the
23:04:30 <vasiliy_san> real Extensible Effects machinery? And probably someone can comments how it compares to Effects system of PureScript. Thanks in advance!
23:15:12 <jackdk> That sounds about right, but also you're not committing to an implementation of those effects until the end. I've refactored a couple of things I've worked on from mtl to freer-effects and in both instances I ended up dropping the branch because I felt like I could get what I wanted from mtl
23:15:43 <jackdk> I haven't read the oleg stuff in detail, nor do I know anything about purescript's effects
23:21:49 <glguy> Or instead of resorting to extensions:  xSymProxy :: X s a -> Proxy s; xSymProxy = const Proxy
23:26:47 <vasiliy_san> jackdk: alright, thanks!
23:31:17 <jackdk> staying in mtl does mean you get stuck with the n^2 instances problem if you start breaking your applications effects into different decorations
23:31:54 <jackdk> you can get some of that back by passing dictionaries explicitly and using classy lenses
23:31:56 <jackdk> https://www.reddit.com/r/haskell/comments/8p6rjv/guidelines_for_effect_handling_in_cardano_sl/e09l4ee/?context=2
23:33:29 <jackdk> the file that reddit link points to no longer exists, for reasons described in the direct comment. you can read it here: https://github.com/input-output-hk/cardano-sl/pull/3063/files
23:43:13 <pally> > zipWith ($) [(**2), abs] [-1, -3]
23:43:15 <lambdabot>  [1.0,3.0]
23:43:32 <pally> how can I cast it to an Integral?
23:43:39 <pally> so, [1, 3]
23:43:56 <cocreature> > zipWith ($) [(^2),abs] [-1,-3]
23:43:58 <lambdabot>  [1,3]
23:44:04 <cocreature> (^) is for integer exponents
23:48:32 <glguy> Non negative*
23:49:21 <cocreature> good point!
23:49:30 <pally> > [1.3, 3]
23:49:32 <lambdabot>  [1.3,3.0]
23:49:55 <pally> is there a short explanation why/how ghc promoted 3 to a Double?
23:50:06 <cocreature> :t 3
23:50:08 <lambdabot> Num p => p
23:50:19 <cocreature> it didn’t promote 3 to a double, integer literals have type Num a => a
23:50:24 <cocreature> and Double is an instance of Num
23:50:30 <cocreature> :t (**)
23:50:31 <glguy> All the elements of a list have the same type
23:50:31 <lambdabot> Floating a => a -> a -> a
23:50:38 <cocreature> (**) requires Floating
23:50:45 <cocreature> so Integer won’t work
23:50:50 <cocreature> therefore it ends up choosing Double
23:51:25 <glguy> :t 1.3
23:51:26 <lambdabot> Fractional p => p
23:51:53 <glguy> :t [1.3, 3]
23:51:54 <lambdabot> Fractional a => [a]
23:53:15 <vasiliy_san> jackdk: yes, I personally like that style of decomposing Reader's environement into several parts and writing "(MonadReader e m, Has X e) =>" constraints. Recently I've started reading about Finally Tagless EDSLs and it turned out that Finally Tagless in it's core has that idea of specifing only type constraints and "not committing to an implementation until the end". It looks like MTL and Finally Tagless have a lot in
23:53:15 <vasiliy_san> common
23:55:23 <vaibhavsagar> how do I submit a PR to the `patience` package?
23:56:27 <cocreature> vaibhavsagar: not sure that has a public repo. it also seems mostly dead (last update was in 2011)
23:56:44 <cocreature> I would email the maintainer and if they don’t respond you can initial the takeover process if you want
23:56:45 <vaibhavsagar> :(
23:57:12 <glguy> ?hackage patience
23:57:12 <lambdabot> http://hackage.haskell.org/package/patience
23:57:36 <vaibhavsagar> I just want to replace insertWith' with Data.Map.Strict.insertWith :(
23:59:22 <glguy> Why?
23:59:31 <vaibhavsagar> it doesn't build on GHC 8.6
23:59:37 <vaibhavsagar> because of that change
23:59:53 <vaibhavsagar> the lack of that change, I mean
