00:05:07 * hackage dhall 1.16.1 - A configuration language guaranteed to terminate  http://hackage.haskell.org/package/dhall-1.16.1 (GabrielGonzalez)
00:18:43 <sternmull> what is a good way to produce a value for a product (i think) of two lists (or traversals in general)? Like what you would do with nested for loops in an imperative language.
00:22:56 <sternmull> at the moment i do something like "for ((,) <$> "abcd" <*> [11,22]) $ \(a,b) -> [a] ++ show b
00:22:57 <sternmull> " with for = flip map. But that looks more complicated than it should.
00:25:00 <pavonia> You could also use the monadic style: do { a <- "abcd"; b <- [11, 22]; return $ [a] ++ show b }
00:25:32 <xacktm> list comprehensions?
00:25:46 <sternmull> hm, yes. Found those two suggestions on stackoverflow.
00:26:57 <sternmull> I wonder if i could use <&> to write something like "[1,2,3] <*> "abcd" <&> \a b -> foo a b"? Of course this does not work... i don't really get how to use <&>.
00:27:32 <pavonia> Or direct Applicative style:  (\a b -> [a] ++ show b) <$> "abcd" <*> [11,22]
00:27:44 <pavonia> :t (<&>)
00:27:45 <lambdabot> Functor f => f a -> (a -> b) -> f b
00:28:38 <sternmull> pavonia: I want that, but with the the function as last argument.
00:28:46 <pavonia> :t [1,2,3] <*> "abcd" <&> (\a b -> [a] ++ show b)
00:28:47 <lambdabot> error:
00:28:48 <lambdabot>     • Could not deduce (Num (Char -> Char))
00:28:48 <lambdabot>         arising from the literal ‘1’
00:29:05 <pavonia> :t [1,2,3] <*> "abcd" <&> (\a b ->show a ++ [b])
00:29:07 <lambdabot> error:
00:29:07 <lambdabot>     • No instance for (Num (Char -> ())) arising from the literal ‘1’
00:29:07 <lambdabot>         (maybe you haven't applied a function to enough arguments?)
00:29:53 <sternmull> yeah... that's where i decided to ask on irc :)
00:31:43 <pdxleif> @hoogle Maybe (Either e a) -> Either e (Maybe a)
00:31:43 <lambdabot> Codec.ByteString.Parser lookAheadE :: Parser (Either a b) -> Parser (Either a b)
00:31:44 <lambdabot> Agda.Utils.Maybe unzipMaybe :: Maybe (a, b) -> (Maybe a, Maybe b)
00:31:44 <lambdabot> Agda.Utils.Maybe.Strict unzipMaybe :: Maybe (a, b) -> (Maybe a, Maybe b)
00:31:59 <pavonia> Ah right, (<*>) is left associative
00:32:23 <pdxleif> @hoogle e -> Maybe (Either e a) -> Either e (Maybe a)
00:32:23 <lambdabot> Data.Either.Combinators mapLeft :: (a -> c) -> Either a b -> Either c b
00:32:23 <lambdabot> Data.Either.Unwrap mapLeft :: (a -> c) -> Either a b -> Either c b
00:32:23 <lambdabot> Agda.Utils.Either mapLeft :: (a -> c) -> Either a b -> Either c b
00:32:36 <sternmull> there is also a <**> but i am not sure if that can help here...
00:32:42 <pavonia> sternmull: Not sure use can do that with the standard operators, I think you need a flipped version of (<*>)
00:32:50 <marvin2> > liftA2 (\x y -> x : show y) "abcd" [11,22]
00:32:52 <lambdabot>  ["a11","a22","b11","b22","c11","c22","d11","d22"]
00:33:03 <sternmull> pavonia: <**> is a flipped <*>
00:34:02 <sternmull> > (x y -> x: show y) <$> "abcd" [11,22]
00:34:04 <lambdabot>  error:
00:34:04 <lambdabot>      Pattern syntax in expression context: x y -> x : show y
00:34:19 <sternmull> > (\x y -> x: show y) <$> "abcd" [11,22]
00:34:21 <lambdabot>  error:
00:34:21 <lambdabot>      • Couldn't match expected type ‘[Integer] -> f Char’
00:34:21 <lambdabot>                    with actual type ‘[Char]’
00:34:35 <marvin2> missing <*>
00:34:39 <sternmull> > (x y -> x: show y) <$> "abcd" <*> [11,22]
00:34:41 <lambdabot>  error:
00:34:42 <lambdabot>      Pattern syntax in expression context: x y -> x : show y
00:34:57 <sternmull> ah... damn
00:35:06 <sternmull> > (\x y -> x: show y) <$> "abcd" <*> [11,22]
00:35:08 <lambdabot>  ["a11","a22","b11","b22","c11","c22","d11","d22"]
00:35:37 <pavonia> Meh, no idea how to write it backwards
00:35:52 <sternmull> ok, at least i am not the only one
01:16:36 <phma> How would I set up an out-of-source build?
01:21:20 <bss> purify f x = guard (f x) *> pure x -- pure if-y
01:21:47 <bss> Seems to be something I'm using a bit right now.  Does it have a real name?
01:22:36 <bss> (b -> Bool) -> b -> Maybe b is the type I'm mostly using it at.
01:54:36 <reactormonk> I've got the following type family declarations: https://gist.github.com/reactormonk/64348f6ca10bccc8a1f9ccb8aef99c2c - however, I get  Couldn't match type ‘Unlift (Lift n (Head (Code Person)))’ with ‘Head (Code Person)’
01:56:24 <maerwald> anyone has good hoogle/hackage skills? I'm unable to find where the function was that uses ByteString and TextEncoding to produce a String
02:00:03 <lavalike> maerwald: what are you trying to accomplish?
02:00:40 <maerwald> convert bytestring to string using the current locale, obviously
02:00:56 <maerwald> https://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-IO-Encoding.html#v:getFileSystemEncoding
02:01:05 <maerwald> https://hackage.haskell.org/package/text-locale-encoding-0.1.0.2/docs/Data-Text-Encoding-Locale.html
02:01:11 <maerwald> there was something for String though afair in base
02:01:44 <lavalike> I was looking up what I used to do that in the past but I was using Data.Text :/
02:02:14 <lavalike> using this https://www.stackage.org/haddock/lts-12.2/text-icu-0.7.0.1/Data-Text-ICU-Convert.html
02:02:23 <kuribas> maerwald: this? http://hackage.haskell.org/package/encoding
02:03:12 <maerwald> kuribas: that has totally different types
02:07:54 <kuribas> does there exist in haskell a configuration management system, where you can access the configuration from remote?
02:08:14 <kuribas> for example, example the contents of your ADTs using a http API?
02:08:28 <kuribas> s/example/examine/
02:08:41 <lavalike> maerwald: I'm looking around and starting to think the TextEncoding is only used to associate with an handle https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/System-IO.html#v:hSetEncoding
02:09:27 <kuribas> maerwald: https://hackage.haskell.org/package/text-locale-encoding-0.1.0.2/docs/Data-Text-Encoding-Locale.html
02:09:51 <lavalike> kuribas: unfortunately those produce Text not String
02:10:41 <maerwald> kuribas: I just linked that page earlier
02:11:14 <lavalike> maerwald: what do you think? there may be no api that doesn't involve handles that involves TextEncoding
02:12:02 <maerwald> the main reason I want to use TextEncoding is that base has a function to get the current encoding
02:12:31 <maerwald> so: unsafeToString :: ByteString -> IO String is a reasonable function
02:12:42 <maerwald> much more reasonable than Char8
02:15:29 <lavalike> maerwald: the current encoding being the locale or the encoding of the random bytes of a bytestring by some sorcerous process?
02:15:55 <maerwald> locale
02:16:01 <lavalike> ok that makes sense
02:16:06 <maerwald> the naming of the base function is a bit weird
02:16:11 <maerwald> it has nothing to do with "file system"
02:17:11 <maerwald> so, for a bytestring you either know the encoding that was used to create it, you don't need to know it (often the case for filepaths actually) or you assume the best (current locale)
02:17:26 <lavalike> yeah
02:19:08 <maerwald> for semi-compatibility between correct bytestring libraries and all string crap I would go for 'unsafeToString :: ByteString -> IO String' in some cases
02:19:35 <maerwald> that is, mostly filepath handling
02:20:12 <maerwald> @hackage process
02:20:13 <lambdabot> http://hackage.haskell.org/package/process
02:20:19 <maerwald> unfortunately also uses wrong FilePath type
02:21:06 <lavalike> maerwald: how about this https://www.stackage.org/haddock/lts-12.2/unix-2.7.2.2/System-Posix-ByteString.html
02:21:24 <maerwald> I already have a proper filepath library
02:21:27 <lavalike> skipping the need to go down to String altogether
02:21:42 <maerwald> but I won't rewrite the process package
02:22:42 <lavalike> I think this is the set of functions that System.IO uses https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/GHC-IO-Encoding.html
02:22:59 <lavalike> (with which you can write your function I'm thinking)
02:34:01 <maerwald> I guess I could just use text-locale-encoding and convert from text to string
02:34:25 <maerwald> not particularly efficient, but since it's for filepaths, efficiency is not that important
02:38:28 <lavalike> maerwald: dang I was hoping GHC.IO.Encoding would make you happier by avoiding the Text workaround
02:38:49 <maerwald> how would it? there is no decode function
02:39:23 <lavalike> I think the idea is you, say, getLocaleEncoding, then mkTextDecoder out of the resulting TextEncoding, and use it to do the decoding
02:40:13 <maerwald> how do you use the textdecoder?
02:40:30 <lavalike> I cannot exactly devise how you use the `type TextDecoder state = BufferCodec Word8 CharBufElem state` just from the documentation, but I am sure examples of usage are in the source... :D
02:41:12 <maerwald> I'm not sure
02:43:02 <lavalike> stuff like this maybe https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/GHC-Foreign.html
02:43:37 <lavalike> (or of course in the Handles since it uses TextEncoding as we said at the beginning)
02:45:34 <maerwald> well, I could go from ByteString to CString, yes
02:46:06 <lavalike> (:
02:46:25 <lavalike> didn't think of that, then you wouldn't even have to replicate the TextEncoding usage internals of those
02:46:29 <lavalike> reasonable
02:47:45 <lavalike> I guess it'll still involve copying in general, whereas a custom implementation could probably navigate the ByteString internal buffers without copying them into a contiguous CString one
02:47:54 <lavalike> (maybe)
02:48:20 <lavalike> since paths aren't that long maybe going to CString is actually more than fine.
02:48:20 <maerwald> wasn't there an unsafeCString thing with strict bytestrings? (doesn't work with lazy ones afair)
02:49:06 <maerwald> https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Unsafe.html
02:49:10 <lavalike> "unsafeUseAsCString"
02:49:34 <lavalike> lovely
02:50:08 <maerwald> I have to null-terminate the bytestring though, *sigh*
02:50:14 <lavalike> haha
02:50:24 <lavalike> no free lunch!
02:50:47 <lavalike> do you?
02:51:16 <lavalike> peekCStringLen :: TextEncoding -> CStringLen -> IO String doesn't care about terminators
02:52:16 <lavalike> paired with unsafeUseAsCStringLen since CStringLen is (Ptr, Len) not just a number
02:52:33 <maerwald> the question now is whether peekCStringLen modifies the CString buffer
02:52:55 <lavalike> you can look at the source it is veeeeeeeeery unlikely it does
02:53:04 <lavalike> poke would
02:55:31 <maerwald> it's a dangerous world
02:57:37 * hackage extralife 0.1.1.0 - API Client for ExtraLife team and user data  http://hackage.haskell.org/package/extralife-0.1.1.0 (wuest)
03:00:01 <maerwald> lavalike: the only thing is, I can't really create a non-IO decode function, because of unsafeUseAsCStringLen
03:02:11 <dysfun> so er... where does one go to learn how to properly use unsafePerformIO?
03:02:53 <[exa]> with enough unsafeOwnFootShooting
03:03:22 <dysfun> where, not in what state
03:03:44 <liste> dysfun: use it only for functions with no side effects (eg pure ffi functions)
03:03:46 <vilu> Hey, I'm having some issues with a coding kata. I was hoping someone could help me here.
03:03:52 <[exa]> iirc Debug.Trace is a good read on how to do that semi-sanely
03:04:03 <vilu> https://gist.github.com/vilu/754335245789df3b3f95a8f7f3212e0c
03:04:26 <dysfun> liste: no, i'm looking for the deeper dive this time
03:04:33 <vilu> Here's the code, and my problem is that for very high m's it seems I'm not being precise enough and "c" ends up being the same
03:05:05 <vilu> m 10252519345963644753025
03:05:07 <vilu>  m 10252519345963644753026
03:05:13 <vilu> ends up being giving me the same c
03:05:30 <vilu> where only the first should give me a valid result.
03:05:39 <liste> vilu: Double has limited precision
03:05:43 <vilu> I know
03:05:57 <vilu> But how do you get past that in Haskell?
03:06:06 <liste> vilu: try to come up with a solution with only Integers
03:06:33 <liste> eg by multiplying/squaring to get rid of divisions and square roots
03:06:56 <liste> (doing that to both sides of the equation)
03:06:57 <vilu> Actually I don't know how to do that besides brute forcing.
03:08:39 <liste> like you usually don't check Eucleidian distance with sqrt(x^2+y^2) < d, but x^2+y^2 < d^2
03:08:44 <maerwald> lavalike: I wonder if it would be safe to run 'unsafePerformIO $ unsafeUseAsCStringLen bs (peekCStringLen enc)'
03:08:56 <maerwald> afaiu it doesn't modify anything
03:09:05 <liste> see if you can use a similar principlw
03:09:16 <liste> principle*
03:09:49 <vilu> Good idea
03:10:26 <maerwald> and it doesn't really depend on some semi-random state like getFileSystemEncoding
03:10:42 <vilu> That would really quite complicate the issue for me though.
03:11:18 <vilu> Or, am I thinking it completely wrong?
03:11:33 <vilu> I'm thinking that since I'm trying to solve it by using to common solutions
03:12:09 <vilu> sum of n cubes
03:12:13 <vilu> and cuadratic formula
03:12:14 <liste> math first, then coding
03:13:26 <vilu> Wouldn't that mean that I would have to square the first (sum of n cubes) to get rid of the sqrt m?
03:13:50 <vilu> And by raising that to a higher exponential it would render my usage of the cuadratic formula useless no?
03:15:03 <liste> vilu: why would it?
03:15:15 <liste> square afterwards
03:15:31 <liste> square only just after evaluating
03:15:56 <liste> you can still use the formula
03:20:52 <lavalike> maerwald: I think so
03:21:10 <lavalike> maerwald: maybe with some strictness annotations
03:31:09 <vilu> liste: sorry, I'm not getting it. I guess that from the sum of cubes formula I get m = (n(n+1)/2) ^ 2. To be able to plug it in the cuadratic formula I write it as n ^ 2 + n - 2 * sqrt m.
03:32:08 <vilu> Which would give me a = 1, b = 1 and c = 2 * sqrt m
03:32:33 <vilu> or n ^ 2 + n = 2 * sqrt m
03:32:53 <vilu> From your tip I understand that I should at this latest stage do ^ 2 on both sides of equation
03:33:32 <vilu> But then I have raised the left side equation to a ^ 4 no?
03:34:02 <vilu> Or am I already messing it up at the math? :)
03:36:36 <ph88> is there a way to write this type signature shorter?   (Foldable t1, Foldable t2, Eq a) => t1 a -> t2 a -> Bool
03:36:43 <ph88> maybe without the need for 2x Foldable ?
03:38:05 <monoidal> ph88: no, unless you'd like something less polymorphic like (Foldable t, Eq a) => t a -> t a -> Bool
03:40:45 <maerwald> lavalike: http://dpaste.com/31YNY7F
03:47:42 <pie_> do i need to figure out monad transformers if i want to implement any acceptable sort of logging in my program?
03:48:07 <pie_> i was looking at the logging library from the people that made luna-lang
03:48:41 <pie_> http://hackage.haskell.org/package/logger-0.1.0.0
03:55:50 <lavalike> maerwald: I wonder if in the prime function $ needs to be $!, or the (Just <$>) application be strictly evaluated somehow, otherwise it looks as planned
04:01:25 <maerwald> I just make everything strict :P
04:03:13 <[exa]> pie_: transformers aren't that hard; just a nice way of running with more wrappers around
04:03:15 <lavalike> maerwald: ^_^
04:03:53 <pie_> ok
04:04:41 <pie_> this looks easier to start with i guess http://hackage.haskell.org/package/simple-logger-0.0.4/docs/Control-Logger-Simple.html
04:05:23 <maerwald> lavalike: http://urlgone.com/7b91f3/
04:05:52 <maerwald> jesus, that page has ads
04:07:55 <lavalike> maerwald: it's always lovely to see an Haskell library with a README.md that gives you code examples, a rarity!
04:08:40 <maerwald> I have a documentation obsession
04:11:19 <lavalike> maerwald: why do you force !p in the second and not in the first? (I am not quite sure what's right in either case)
04:11:54 <maerwald> I really have no idea. I think for regular IO it doesn't really matter much here.
04:13:04 <maerwald> and I haven't use unsafePerformIO *ever* before, so I don't know what the pitfalls are
04:13:48 <maerwald> but since peekCStringLen makes a copy and nothing ever touches the underlying pointer again, it seems safe
04:14:23 <maerwald> decoding failure is wrapped in Maybe, so no unexpected crashes
04:14:47 <maerwald> (would be nice to add a decoding failure to the doctests, but I don't know how)
04:19:38 <anohigisavay> hi
04:19:41 <Athas> Hm.  There is no full TOML implementation in Haskell?
04:19:49 <Athas> I can find only parsers on Hackage.
04:20:49 <Athas> Oh, wait, tomland.
04:21:04 <anohigisavay> https://pastebin.com/xGQ96ydw
04:22:09 <anohigisavay> TypeFamilyDependencies does not work. am i not understanding its usage correctly?
04:26:35 <lavalike> maerwald: https://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txt :D
04:31:05 <epta> hindent cannot vertically align imports in a stylish-haskell way?
04:56:36 * hackage latex-formulae-image 0.1.1.4 - A library for rendering LaTeX formulae as images using an actual LaTeX installation  http://hackage.haskell.org/package/latex-formulae-image-0.1.1.4 (LiamOConnorDavis)
04:57:37 * hackage latex-formulae-hakyll 0.2.0.4, latex-formulae-pandoc 0.2.0.6 (LiamOConnorDavis): https://qbin.io/bacon-doctor-6k7z
05:00:31 <epta> is it expected behavior of hindent? https://gist.githubusercontent.com/dmalikov/956b67d0e8ff8b5e7e5f6d38d9ea8933/raw/e9eb1a5b19838a652992082feb2893ec72b130e1/hindent
05:18:06 <__monty__> epta: Afaik the hindent author despises alignment.
05:19:46 <lavalike> does it give you a configuration option to choose your own preference at least?
05:20:14 <lavalike> (clang-format is _very_ good on that front for example)
06:17:38 <lseatuary> is it possible for someone to explain Leo's functional programming code here to me? https://stackoverflow.com/questions/23194711/search-a-path-between-two-graph-nodes-in-xquery
06:17:50 <lseatuary> i am a bit confused how it is working, i have a similar issue i am trying to apply it to hence I ask.
06:20:01 <riaqn> Hello, is it possible to hash a IO monad?
06:20:17 <atchoum> what's up
06:20:30 <atchoum> in computer world ?
06:20:41 <infinisil> riaqn: No
06:22:22 <riaqn> ok
06:44:37 * hackage smuggler 0.0.0 - Smuggling  http://hackage.haskell.org/package/smuggler-0.0.0 (shersh)
07:09:53 <marvin3> riaqn what do you mean?
07:13:24 <madknight> hi i want to publish a new package on hackage and need some help :)
07:21:05 <epta> how do you guys use nix in your CI/CD pipeline in gitlab? is there some image with preinstalled nix and ghc?
07:22:14 <[exa]> (my poor man's testing pipeline consists mostly of writing :t in ghci .... :( )
07:42:14 <reactormonk> My functions requires two typeclasses - however, when one is missing (an SOP.Generic) instance, the other one will also fail. However, GHC shows the other one first, which makes for a confusing error message.
07:45:55 <lyxia> madknight: what's the problem
07:47:44 <madknight> lyxia, do you know why i get this warning "ignoring (possibly broken) abi-depends field for packages"
07:53:13 <madknight> and i want to upload a package to hackage.haskell.org/packages/candidates/ and get "No access for this resource."
08:04:14 <lyxia> I don't know what this warning means, I also have it and I ignore it.
08:05:17 <madknight> lyxia, okay and how can i upload a package candidate? I get this "no access" error
08:05:21 <mniip> madknight, http://hackage.haskell.org/upload#candidates
08:05:35 <mniip> at the bottom "Upload a package candidate"
08:10:16 <riaqn> marvin3: I need a bunch of IO (), and I hope to check for duplication.
08:10:28 <riaqn> s/need/have
08:14:07 <madknight> mniip, i think i'm not allowed to upload a candidate
08:14:49 <monoidal> riaqn: There's no equality on IO () because that would allow to compare functions for equality
08:15:10 <mniip> madknight, are you logged in?
08:15:20 <monoidal> riaqn: You might be able to create your own Program datatype, compare Programs, and have a function interpret :: Program -> IO ()
08:16:49 <madknight> mniip, i guess so, where is the login page by the way?
08:18:29 <riaqn> monoidal: ok.
08:18:33 <madknight> mniip, "After your account is created, you cannot upload until you contact the hackage trustees at trustees@hackage.haskell.org and send an email (including your login username) requesting to be added to the uploader group."
08:19:12 <mniip> ah
08:19:15 <mniip> that must be new
08:20:21 <mniip> I guess that's to prevent spamming
08:20:28 <mniip> especially considering uplaods are permanent
08:21:01 <mmaruseacph2> yeah, there was some spam a few months ago and they instated this policy
08:23:01 <madknight> hmm okay i send them an email with a upload request
08:30:20 <madknight> okay they added me :)
08:31:53 <Profpatsch> jb55: cf cmdtree, what I’d like to see is a CmdtreeT in which you can specify now to build a cmdtree. :)
08:31:59 <Profpatsch> s/now/how
08:34:09 <Profpatsch> That lets you combine different kind of menus, some dmenu-like, then some command-like.
08:35:03 <Profpatsch> for example I can think of a nix docs cmdtree, which first gives you a list of nixpkgs arguments, then lets you choose between m (manpage) and h (html) and i (info)
08:35:39 <Profpatsch> And it only shows you the items that actually exist (by searching inside the outputs or an output index)
08:35:57 <Profpatsch> It between it could show a status bar.
08:36:07 * hackage dhall-json 1.2.2 - Compile Dhall to JSON or YAML  http://hackage.haskell.org/package/dhall-json-1.2.2 (GabrielGonzalez)
08:42:07 <Wizek> Hello
08:51:12 <Wizek> Has anyone written some kind of a Haskell simplifier before?
08:52:22 <Wizek> e.g. similar to how `@pl f a = a` returns `f = id` with lambdabot
08:53:38 <Wizek> @pl isGIF file = take 6 file == pack "GIF89a" || take 6 file == pack "GIF87a"
08:53:39 <lambdabot> isGIF = ap ((||) . (pack "GIF89a" ==) . take 6) ((pack "GIF87a" ==) . take 6)
08:54:19 <Wizek> So having a look at the above example, the result is not really simpler. E.g. it doesn't notice (or even look for) duplications in this code
08:54:39 <rain1> you can factor out the duplicaiton yourself
08:55:04 <Wizek> I know
08:55:13 <Wizek> I just wonder if I can do it programmatically
08:58:23 <Wizek> I also know of djinn and MagicHaskeller that go a bit in this direction
08:58:51 <Wizek> also brittany
08:59:18 <Wizek> and hlint
09:00:06 <lavalike> Wizek: there have been written some things on the topic, e.g. https://kar.kent.ac.uk/21455/1/Common_Subexpression_Elimination_in_a_Lazy.pdf
09:01:05 <lavalike> GHC's CSE.hs is also more a paper than actual code hehe https://github.com/ghc/ghc/blob/master/compiler/simplCore/CSE.hs
09:14:05 <Ternary> I'm pretty new to reflex, is there a way I can extend a host to contain another event? I'm using reflex-gloss, and I also want an incoming event from the filesystem. My limited understanding of the cods makes it look like I need to reimplement the playReflex method
09:14:28 <Ternary> docs*
09:23:04 <sternmull> i want to fill a Data.Map that maps some keys to a set of values. In an imperative language i would iterate over all my key-value-tuples and append them to the list of each key. I struggle to find a good approach in Haskell. Any advice on how you typically do such stuff?
09:27:08 <Wizek> Ternary: Are you aware of #reflex-frp?
09:27:19 <lavalike> sternmull: Data.Map comes with functions to create instances from certain values, e.g. fromSet, fromList (and variants)
09:27:23 <Wizek> You might have more people there able to help
09:28:17 <Wizek> lavalike: I've read bits of that paper, and isn't the conclusion there that CSE is not worth doing in a compiler?
09:28:25 <Wizek> at least in GHC at the time
09:28:29 <jb55> Profpatsch: perhaps a way to dynamically create menus at runtime? this could be accomplished by a config file option... then you would just generate the config with some program on the fly
09:28:48 <lavalike> sternmull: they do the same process as you described, fold over the container of keys/values starting from a Data.Map.empty and inserting each pair as it goes, returning the last result
09:28:52 <sternmull> lavalike: I know. But the "problem" is that i don't have the final values to directly build the map. I think my bet bet is to use Data.Map.update to incrementally fill the values (that are sets).
09:29:26 <Ternary> Wizek: I wasn't aware of that, I'll head over there. Thanks
09:30:09 <lavalike> sternmull: one interesting bit is that in Haskell you can use containers such as lists to represent the computation of all the "final values", and feed such list to fromList, say
09:30:42 <lavalike> Wizek: yeah! I was thinking you could pluck out some interesting bits and to implement in a smaller enviroment like those little code transformators
09:33:07 * hackage erlang 0.2.3 - FFI interface to Erlang.  http://hackage.haskell.org/package/erlang-0.2.3 (gombocarti)
09:36:44 <Wizek> lavalike: oh, I see. So no one has packaged up anything like this yet (for helping out with simplifying code as opposed to CSE in a compiler) as far as you are aware?
09:37:31 <lavalike> Wizek: I don't know, I did read through @pl a couple times and that's it
09:42:12 <rotaerk> what is the () => in this:  https://github.com/achirkin/easytensor/blob/master/dimensions/src/Numeric/Dim.hs#L123
09:42:58 <rotaerk> is that an (empty) constraint list at the kind level, or something?
09:43:05 <lavalike> I'd wager an empty constraint
09:43:26 <rotaerk> did you look at the code
09:43:38 <lavalike> yeah
09:43:56 <monoidal> Empty constraint, but note that => syntax in pattern synonyms is special
09:44:22 <rotaerk> oh *looks up pattern synonym syntax again*
09:45:41 <Squarism> anyone got a hint on how to create a job scheduler that doesnt spawn a thread for each event (using threadDelay) ?
09:45:55 <Squarism> should be able to cancel and reschedule events too
09:46:17 <Squarism> time based job scheduler
09:48:03 <Profpatsch> jb55: I’d like it to be a bit more dynamic tbh.
09:48:44 <Squarism> Ive done a hacky version that works but it doesnt feel elegant. Im just trying to trigger on earliest event and reschedule earliest after that. Removals just become re-evaluations
09:49:22 <Profpatsch> jb55: But I mean: what stops it from  Map Key Command -> IO ()
09:49:42 <Profpatsch> And then it execs itself into command and closes.
09:50:26 <Profpatsch> Or is the setup too expensive?
09:51:37 <Profpatsch> Then I can write a wrapper that maps to a new command which generates further tree structure.
09:52:07 <Profpatsch> So instead of closing the recursion yourself in C, why not keep it open and let others apply the fixpoint if they want. ;)
09:57:36 * hackage smuggler 0.0.1 - Smuggling  http://hackage.haskell.org/package/smuggler-0.0.1 (shersh)
09:57:42 <Profpatsch> Then you don’t need to parse SExprs, but just a flat input of Key and Command, deduplicating keys
10:05:37 * hackage opaleye 0.6.7001.0 - An SQL-generating DSL targeting PostgreSQL  http://hackage.haskell.org/package/opaleye-0.6.7001.0 (tomjaguarpaw)
10:06:29 <hpc> what a strange version number
10:11:11 <rotaerk> pattern synonyms are more complicated than I thought
10:24:40 <jb55> Profpatsch: because I'd rather keep it simple, and that does not sound simple. Could make a cmdtree2 that does that though
10:44:15 <bwe> Hi, which way do you recommend me to organise the .hs files to define two executables, both composed of identical building blocks. I tried to factor the blocks out into Blocks.hs and then define the two executables as main in their distinct files Executable1.hs and Executable2.hs. Each imports Blocks. Requesting your kind feedback! I use stack.
10:46:43 <Profpatsch> jb55: Hm, sure it’s not simpler?
10:47:06 <Profpatsch> I might try to pull out the rendering part.
10:47:14 <Profpatsch> PoC
10:54:32 <nicknicknick> hello there
11:19:27 <jb55> Profpatsch: it's not closed, you can write a command that generates the static config and calls cmdtree again with that config. I don't see how that wouldn't do what you're describing?
11:22:12 <jb55> the only confusing thing is that it it's technically a command but semantically a prefix, so you would need a way to mark something as a prefix-command in the config
11:22:14 <jb55> if that makes sense
11:27:42 <jb55> Profpatsch: also probably related to what you're describing, I'm currently using a script like this to prompt input with dmenu from a cmdtree action: https://github.com/jb55/bin/blob/master/dmenup so you could prompt input, then generate a config from this input and relaunch cmdtree. lots of use cases once I make it dynamic.
11:27:59 <Profpatsch> jb55: But right now you need to compile again for a new config, right?
11:28:23 <jb55> Profpatsch: yeah it's temporary until I have a way of configuring it at runtime
11:34:07 * hackage termbox-banana 0.1.0 - reactive-banana + termbox  http://hackage.haskell.org/package/termbox-banana-0.1.0 (mitchellwrosen)
11:48:31 <adamCS> tsahyt: Did you figure out your "choice" function?  It sort of looks like you would need the profunctor to be an Arrow, or at least to be a category and have the equivalent of Arrow's "arr :: Arrow a => (b -> c) -> a b c".  I think it needs to be more "function-like" than a profunctor but maybe not all the way to arrow?
11:48:53 <f-a> I am building ghcjs (8.4 branch) and cabal isn't finding `haddock-api-ghcjs`. Where to grab it?
12:42:52 <WASD> I'm having problems understanding why haskell won't compile this considering Int can be a Num: myNum :: (Num a) => a; myNum = (5::Int)
12:43:53 <[exa]> WASD: by type you said you can give out _any_ type of Num that anyone asks; but by implementation you say you can only do Ints
12:43:56 <lavalike> WASD: the type is more generic than the value
12:45:13 <[exa]> WASD: btw there's no automatic ad-hoc conversion of integer values like in C/C++, the only "invisible" type changing happens exactly at numeric literals (the 5 there is polymorphic)
12:46:18 <WASD> so it's problematic for instance if someone tries to do myNum::Float?
12:47:10 <[exa]> yes, also on myNum::Word or myNum::Integer (which isn't Int)
12:48:31 <[exa]> WASD: if you want polymorphic value 5, just let the 5 there, it will automatically convert itself to any Num class that anyone asks for
12:49:13 <[exa]> (including Float, Integer, Word8, or anything else)
12:49:46 <[exa]> WASD: btw the "magic" is hidden in desugaring, all integer literals (like your 5) in fact desugar to (fromInteger 5), and:
12:49:49 <[exa]> :t fromInteger
12:49:51 <lambdabot> Num a => Integer -> a
12:50:55 <WASD> hmm, I'm coming from java an up until now saw Num as an "interface" and Int as an implementation
12:51:20 <[exa]> which is perfectly right
12:51:32 <geekosaur> a type signature on a function is a contract, here saying that myNum promises to produce any type a for which a Num instance exists
12:51:53 <geekosaur> a type signature on a value is specific, here saying that 5 can *only* be an Int
12:51:58 <geekosaur> these conflict
12:52:57 <geekosaur> because there is no automatic conversion, as said. (and even for numeric literals it's because '5' really means 'fromInteger <an internal representation of 5 as an Integer>'
12:54:23 <geekosaur> but that only happens for literals, and by default only for numeric literals. there are extensions that allow it to be done for String and list literals; but only for literals in any case
12:55:38 <[exa]> WASD: about that "interface" thing --- typeclass is an "interface", but the members of that interface aren't interchangeable like in Java (that's subtyping). For example, type (Num a  => [a]) is either a list of Floats, or a list of Ints, but no mixing.
12:56:26 <WASD> hmm, in that sense it sounds more similar to generics in java
12:56:30 <[exa]> WASD: OTOH "mixing" is simpler in Haskell with ADTs
12:56:44 <[exa]> yes, that would be more precise
12:58:52 <[exa]> I don't know much java but in C++ you can imagine type 'Num a => a' as 'template<typename a> ...'. Except if the thing inside isn't Num, Haskell knows exactly, C++ only produces a type error at first usage of 'a' that doesn't work on the supplied type
12:59:14 <[exa]> If c++17/20 concepts are pretty close
12:59:20 <[exa]> s/If//
13:01:58 <WASD> do you mean it's a runtime error in C++ and a compile error in haskell? Playing with the thought that the examples are equivalent
13:02:20 <WASD> perhaps not entierly correct to say it like that
13:02:54 <[exa]> in C++ it's usually a failure to find overloading for given function (for example running + on strings). Haskell has a dedicated type error for that, which fires quicker and describes the situation more correctly (No instance for (Num String))
13:03:16 <WASD> btw this channel is very helpful :) I've been studying haskell hard for three weeks now and put a few questions in here with great response
13:03:24 <[exa]> in both cases these are compile errors
13:03:51 <lavalike> WASD: awesome (:
13:04:36 <[exa]> the thing with C++ is that this exact failure usually produces the longestest error messages ever, usually pointing into header files you've never seen and so
13:05:07 <[exa]> type 2 fun certainly.
13:06:51 <WASD> I think I understand now, a function producing a Num has to be able to produce anything which is an instance of Num while my example only produced Int
13:07:14 <[exa]> yep.
13:07:19 <pavolzetor> hello, I struggle with implementing closures for my interpreter; I used Environment { values :: Map String Value, parent :: Maybe Environment }, but that seems to be impossible to mutate
13:07:20 <c_wraith> that's one of the toughest things for people coming from OO languages to grasp
13:07:45 <WASD> if the signature was Eq instead, it wouldn't make sense to return either String or Int
13:07:50 <pavolzetor> for example I can return two nested functions sharing parent environment and each modifying shared value
13:07:54 <WASD> with Num it was not as obvious
13:08:38 <pavolzetor> but it is unclear to me how to enforce it as each function holds the closure, but that gets copied when I call the function, and it stops being shared
13:08:51 <[exa]> WASD: the thing with type-style contracts is that if you have contract, you need to deliver equal or better. Which is contrasted with OO-style type descriptions which usually serve only as data-format-descriptors, where you are free to deliver whatever fits
13:09:27 <c_wraith> pavolzetor: if things can modify the environment, they can't just all close over it.  They'll have to pass it around
13:10:13 <pavolzetor> but how to do it? I was thinking to store all closures in my interpreter state and identify them by an integer
13:10:38 <dataN> trying to understand this error; https://gist.github.com/dataN-hs/f061562582078f1f16bc5da7eb2e9d4b
13:10:40 <[exa]> WASD: anyway -- a slightly counter-intuitive fact: The more generic the type is, the less you can actually do with it. For example, if you have 'Num a => a' you can only run it through Num-accepting or completely generic functions. If you have just type 'a', you can't do anything to it except for copying it as is and returning it :]
13:11:52 <pavolzetor> c_wraith, I think I need something like a pointer to the interpreter state
13:11:55 <WASD> I've started to understand that as well [exa]
13:12:28 <[exa]> :]
13:12:59 <c_wraith> pavolzetor: yes, you need to pass around the state (usually called an environment)
13:13:35 <pavolzetor> And then how do you identify subenvironment for each closure?
13:13:55 <pavolzetor> it is basically a tree in which I need to identify and modify pieces
13:14:28 <c_wraith> there's no right.  It depends entirely on what rules your interpreter is using.
13:14:37 <c_wraith> no right *answer*
13:15:24 <pavolzetor> It is a state inside IO, the interpreted language is imperative
13:15:32 <[exa]> pavolzetor: since "holding" a single environment makes it immutable, the usual way is to return a modified environment from subroutines
13:17:01 <[exa]> pavolzetor: if you store that in State, it would probably work even without passing that around... Modifying a value can just rewrite the element in top-most map that contains it
13:17:24 <pavolzetor> that does not work with capture variables
13:17:28 <pavolzetor> for example
13:17:43 <dataN> it seems strange that the local instance definitions can be composed, but the compiler complains if the definition is turned into a constraint, even though the two should be interchangeable. the errors included are unclear.
13:18:32 <pavolzetor> fn x() { let i = 0; fn y() {return ++i;}; fn z() {return --i;}; return (y, z); }
13:19:27 <rborch> hi! Anyone familiar with the Gloss library around here? I've been using Gloss to display a static simulation. However, I'd like to be able to increase / decrease a simulation parameter by pressing a key.
13:19:29 <[exa]> pavolzetor: return (y,z) doesn't call the y and z right?
13:20:06 <pavolzetor> no, just returns them; so the environment is tied to the AST node, but then how do I keep track where in AST is it tied? I need to find all such places
13:20:42 <pavolzetor> I was thinking to just have a Map Int -> Environment in the interpreter and generate new environments from there
13:20:53 <[exa]> hmmm... you might like to see how scheme interpreters handle this thing
13:20:56 <pavolzetor> but that I find quite unappealing
13:21:11 <[exa]> rborch: use interact or interactIO
13:21:16 <[exa]> rborch: https://hackage.haskell.org/package/gloss-1.12.0.0/docs/Graphics-Gloss-Interface-IO-Interact.html
13:21:43 <[exa]> rborch: it gives you a way to react on Events, which are something like EventKey, EventResize, EventMotion, etc.
13:22:45 <dataN> rborch: did you see; http://hackage.haskell.org/package/gloss-1.4.0.1/docs/Graphics-Gloss.html#v:gameInWindow ?
13:23:08 <pavolzetor> [exa], write you a scheme uses IORef
13:23:09 <Gurkenglas> https://gist.github.com/Gurkenglas/442a577d181d4af827c7e087ad108771 wat do
13:23:46 <pavolzetor> I think I will go with it instead of using that Map idea since Interpreter runs in IO anyhow
13:23:53 <dataN> nad, http://hackage.haskell.org/package/gloss-1.4.0.1/docs/Graphics-Gloss-Interface-Game.html#t:Event
13:23:56 <rborch> @[exa]: Thx, turns out, I've been looking at outdated documentation (not 1.12)
13:23:56 <lambdabot> Unknown command, try @list
13:23:58 <pavolzetor> thanks for the tip
13:24:38 <rborch> dataN, no, but I'll check it out, Thank you
13:25:04 <[exa]> pavolzetor: you can avoid a bit of ioref by storing a map of all environments in State for yourself, but that way you also need to garbagecollect them... :]
13:26:06 <dataN> the types become ambiguous for seemingly no reason
13:26:26 <dataN> and nothing seems to fix it!
13:26:29 <[exa]> dataN: do you have a tiny example of that?
13:26:41 <dataN> it relies on a lot of whats defined there
13:27:01 <[exa]> not-as-tiny code slice? :]
13:27:34 <pavolzetor> I will go with IORef, maybe later add GC :)
13:28:31 <dataN> comparing 327 with 341 and understanding the type of using32 should be enough...
13:28:32 <dataN> using32 :: forall p g f a x. ReifiableConstraint32 p g => Def32 p g f -> (p g f => x) -> x
13:28:59 <[exa]> pavolzetor: if you already have IO in there it's probably the way to go
13:29:20 <[exa]> dataN: ◔.◔
13:31:04 <[exa]> well at the first sight, (p g f => x) is an ambiguity by definition
13:31:40 <dataN> the examples on 411 show it working
13:32:22 <[exa]> dataN: btw did you paste a link to code? I can't find it in scrollback
13:32:34 <dataN> https://gist.github.com/dataN-hs/f061562582078f1f16bc5da7eb2e9d4b
13:32:41 <[exa]> oh okay I've got it sry
13:33:09 <WASD> I found another thing I find strange, this accepts "3" but "3.5" gives "no parse" just like "read 3": myRead :: (Num a, Read a) => String -> a; myRead = read
13:33:35 <c_wraith> WASD: that sounds like defaulting
13:33:48 <c_wraith> > read "3.5" :: Integer
13:33:51 <lambdabot>  *Exception: Prelude.read: no parse
13:33:55 <c_wraith> > read "3.5" :: Double
13:33:58 <lambdabot>  3.5
13:34:23 <WASD> > (read :: (Num a, Read a) => String -> a) "3"
13:34:25 <dataN> so, the idea is that instead of providing a definition, a constraint that allows the definition to be recovered from a value which "Encodes" it can be used. the problem is when it is used as a constraint rather than a definition.
13:34:25 <lambdabot>  3
13:34:52 <dataN> (note, definition meaning datatype providing local instance)
13:34:56 <c_wraith> WASD: yeah, the Num constraint causes it to default to Integer
13:35:27 <WASD> defaulting was new to me
13:35:57 <c_wraith> > (read :: (Floating a, Read a) => String -> a) "3.5"
13:35:59 <lambdabot>  3.5
13:36:01 <dataN> i.e. Def32. also, Empty32 is the only class ever used, with everything else being pattern matched as synonyms of it.
13:36:02 <ZeuPiark> hello
13:36:12 <c_wraith> WASD: A Floating constraint defaults to Double
13:36:17 <WASD> I see
13:36:54 <lavalike> WASD: if you run ghci -Wtype-defaults and evaluate the expression it will give you a warning in fact!
13:37:08 <dataN> the 32 suffix indicating that it is a 3 parameter constraint over a 2 parameter type
13:37:14 <lavalike> (and tell you which type it's defaulting to as well)
13:38:32 <WASD> lavalike: yes it did! I think I would want such warnings to be enabled by default
13:38:46 <[exa]> WASD: note that if you don't put any reasonable typeclass there (like Num), it will default to just ()
13:39:19 <lavalike> WASD: defaulting goes even further inside ghci https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#extension-ExtendedDefaultRules
13:40:06 * hackage wsjtx-udp 0.1.3.4 - WSJT-X UDP protocol  http://hackage.haskell.org/package/wsjtx-udp-0.1.3.4 (MarcFontaine)
13:40:43 <WASD> yeah the first example "reverse []" gave such a warning too
13:40:50 <geekosaur> and this only comes into play if it has no other way to determine the type; if you run that and give it an explicit type, it will use that. and you have some control over defaulting: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4
13:41:04 <WASD> thanks :)
13:42:44 <dataN> [exa]: is it legible?
13:42:57 <iqubic> reverse [] is redundant.
13:43:06 <[exa]> dataN: I'm trying to get through the code but not very successfully so far
13:44:00 <lavalike> iqubic: the documentation uses it to make a point
13:49:41 <dataN> [exa]: its definitely worth it!
13:50:37 <[exa]> dataN: how can ReifiableConstrain digest the (Constraint, Constraint) thing?
13:55:18 <[exa]> dataN: ok that was a wild guess
13:58:43 <dataN> how do you mean?
13:59:11 <AndreasK> Does new-build allow to set --enable-benchmarks for a single package?
14:00:33 <[exa]> dataN: I'm kindof failing to comprehend that thing fully yet, sorry :]
14:04:16 <blankhart> i didn't realize you could use GADTs to create containers for different constrained types. this seems to mean they can be used to simulate open unions in other languages (e.g., scala unsealed traits). comments?  ("don't be an idiot, <...>!") is this a common use case?
14:05:04 <blankhart> i am wondering about it because it doesn't seem to be mentioned as a proposed use case in the number of explanations of GADTs i have previously read
14:05:27 <blankhart> and learned that it was possible from reading code https://github.com/ChrisPenner/eve/blob/master/src/Eve/Internal/Listeners.hs (246-250)
14:07:10 <phadej> listener is ExistentialQuantification type, just using GADT syntax
14:08:30 <phadej> https://downloads.haskell.org/~ghc/8.4.3/docs/html/users_guide/glasgow_exts.html#extension-ExistentialQuantification
14:08:34 <lyxia> blankhart: http://okmij.org/ftp/Haskell/extensible/#open-union
14:09:08 <lyxia> blankhart: some of these implementations use a GADT
14:10:01 <phadej> those are differently "open" unions
14:10:07 <phadej> than listener example
14:10:39 <hexagoxel> AndreasK: i would assume this would be: in cabal.project(.local): { benchmarks: false, package mypackage { benchmarks: true }}. hope you can manage to convert that to the proper syntax.
14:11:11 <blankhart> phadej, i see thanks, it makes sense that you would get it from existential quantification
14:11:25 <blankhart> & that GADT usage is incidental.  lyxia also thanks
14:13:33 <blankhart> is it right that existential quantification in this instance is the main sitaution where it is good practice to constrain the data type itself rather than the functionality?
14:24:49 <dataN> line 339 describes the error, ambiguity from reflecting constraints https://gist.github.com/dataN-hs/f061562582078f1f16bc5da7eb2e9d4b
14:27:29 <dataN> trying to establish the foundations for traverse using local inverse instances.
14:29:07 * hackage serverless-haskell 0.6.5 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.6.5 (AlexeyKotlyarov)
14:30:38 <dataN> how can these types be disambiguated?
14:43:03 <yetruin> owo
15:16:07 * hackage serverless-haskell 0.7.3 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.7.3 (AlexeyKotlyarov)
15:30:54 <albeit> Is it possible the get the current size of a TBQueue somehow?
15:33:08 <johnw> albeit: sure: in your transaction, just drain it to a list and take the size
15:33:37 <johnw> put back what you don't want to consume then, or retry to have the drain ignored
15:34:17 <albeit> Wouldn't that be terrible inefficient? I was hoping there was some was using the rsize and wsize capacity TVars
15:35:57 <johnw> i'd test it out and see
15:36:01 <albeit> Such as the sum the remaining capacity, and subtract that from the initial size? It would be an estimate, and rough if there are lot of concurrent read/writes
15:36:02 <johnw> I don't see why it would be
15:36:31 <albeit> If the queue is thousands long, wouldn't that require iterating over the entire list just for a single length reading?
15:36:32 <johnw> a TBQueue can be implemented using a plain list with STM, and nothing else
15:36:42 <johnw> in which case the drain is just "here, here's my list"
15:39:32 <albeit> I shall try the drain! Thanks
15:40:13 <johnw> albeit: you want to use flushTBQueue
15:40:40 <johnw> you might pay a call to 'reverse' on the second part of the queue (the elements not yet seen)
15:40:42 <johnw> but that's all
15:40:51 <johnw> http://hackage.haskell.org/package/stm-2.4.5.0/docs/src/Control.Concurrent.STM.TBQueue.html#flushTBQueue
15:48:06 * hackage streamdeck 0.0.2 - Control library for the Elgato Stream Deck  http://hackage.haskell.org/package/streamdeck-0.0.2 (wuest)
15:55:06 <marxS> I need a build option that provides dynamic link
15:55:10 <marxS> googling isn't returning much
15:55:11 <marxS> any ideas?
15:58:00 <marxS> do you have to list modules in cabal file? even if they are my own modules in the same directory?
15:58:21 <Gurkenglas> Is anyone doing everything on a virtual machine that records everything so heisenberg bugs can be tracked down?
16:03:41 <marxS> the book I'm using doesn't list them in the cabal file, but I think my compiler is telling me to do so
16:11:12 <marxS> I get this error when I try and run "cabal build"
16:11:13 <marxS> https://paste.ofcode.org/Egj9LqkAgzeaPriPP2HBXA
16:12:31 <geekosaur> marxS, older versions of ghc silently included them, which caused other problems if there were duplicate modules elsewhere (say, as part of a different executable target)
16:12:44 <geekosaur> so yes, you must explicitly mention them as part of your executable
16:13:50 <geekosaur> (if ghc decides to go hunting for modules itself, it won't necessarily find the ones cabal intended it to)
16:15:27 <marxS> ok thanks
16:33:14 <suzu> Gurkenglas: lmao
16:39:07 * hackage doctest-discover 0.2.0.0 - Easy way to run doctests via cabal  http://hackage.haskell.org/package/doctest-discover-0.2.0.0 (karun012)
16:55:24 <Zemyla> I wish Rational were a separate type rather than just Ratio specialized to Integer; that way, it could be defined as an Integer over a Natural and perhaps made with an unpacked sum.
16:56:35 <monochrom> Why is it a sum type?
17:00:54 <hpc> product, you mean?
17:01:30 <hpc> or maybe it's a dependent sum!
17:01:30 <hpc> https://www.youtube.com/watch?v=a1Y73sPHKxw
17:12:06 * hackage influxdb 1.6.0.7 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-1.6.0.7 (MitsutoshiAoe)
17:38:14 <orbisvicis>  The wikibook article on denotational semantics regarding the approx. of the recursive factorial function, f(n), shows the relationship between iterations of f(n) but rather than work backwards from f(n), it works forward from _|_ and proves that eventually that sequence converges to the original f(n). What's the point of all this, since that's not how recursive functions actually operate - you would
17:38:20 <orbisvicis> get nothing done if you first had to iterate forever from _|_. Instead you work backwards from n, i.e. for f(10) it is 10*T, 10*(9*T), ..., 10*...*(3*(2*1))
17:41:06 <dmwit> One of the basic operations provided by CPOs is this: given an ascending chain, give me the sup.
17:41:22 <dmwit> This basic building block is the one used when giving the denotation of recursive definitions.
17:42:07 <dmwit> Specifically: the recursive definition is massaged into an application of `fix` to a function; this function defines an ascending chain; and the denotation of `fix f` is the sup of the chain given by _|_, f _|_, f (f _|_), etc.
17:44:54 <dmwit> Anyway I think you've missed something important, because the function being "iterated" isn't one that's applied to numbers at all.
17:44:58 <dmwit> It's applied to functions.
17:45:26 <dmwit> So your comments about f(n) -- where 'n' is typically used as a metavariable for numbers -- makes me think you've missed this subtlety.
17:48:05 <dmwit> (Also I've been slightly imprecise, but in a common way: the chain is given by _|_, ⟦f⟧(_|_), ⟦f⟧(⟦f⟧(_|_)), etc., where ⟦f⟧ is the denotation of f.
17:48:09 <dmwit> )
18:04:38 <rotaerk> learning so much (or perhaps drowning in information overload?) by reading this:  https://github.com/achirkin/easytensor/blob/master/dimensions/src/Numeric/Dim.hs
18:04:51 <justaguest> is there any Linear Algebra/Matrix library in Haskell that is similar to Python's Numpy?
18:04:54 <rotaerk> never seen programming like that before
18:05:03 <justaguest> i'm looking for something practical
18:05:28 <rotaerk> heh, incidentally, what I just linked is such a thing.  however, it's using some really advanced haskell mechanisms
18:06:17 <dataN> here is the error in the least possible code; https://gist.github.com/dataN-hs/18caf53bb6c97ef9a29e663e1e61baf8
18:06:21 <rotaerk> usage may be relatively straightforward, but it doesn't have much documentation or many examples, so I'm trying to understand the code, and it's slowgoing
18:06:48 <lucasem> I have a solution for exercise 2 on this "trivial monad" blog post (referenced in the haskell wiki on typeclasses): http://blog.sigfpe.com/2007/04/trivial-monad.html but I think there must be a better solution. My solution is `h x = bind ((flip g) x)`. Surely there's a better way?
18:08:40 <dataN> Could not deduce (Empty32 g0 f0) arising from an expression type signature from the context: Empty32 g f
18:08:55 <monochrom> orbisvicis: You also have a problem of expectation management.  You correctly discovered that denotational semantics is totally not about how anything operates.  There is a reason why it is called "denotational" not "operationa".  (And yes "operational semantics" exists for computer steps.)
18:11:21 <pavonia> rotaerk: With enough extensions enabled, you can make your code almost look like another programming language
18:13:07 <dmwit> lucasem: What's g?
18:13:21 <dmwit> lucasem: Oh, the solution to exercise 1?
18:13:26 <dmwit> Okay, let me read exercise 1.
18:14:05 <lucasem> dmwit: thanks! fwiw, my g soln is `g n = bind (W . (+n))`
18:14:56 <rotaerk> pavonia, yep
18:14:56 <dmwit> lucasem: Oh, booo, no fair calling W.
18:15:15 <dmwit> lucasem: You can do without. =)
18:15:35 <lucasem> I thought that was only for unwrapping! Dang, so much to learn..
18:16:10 <dataN> actually, this is even easier to read; https://gist.github.com/dataN-hs/18caf53bb6c97ef9a29e663e1e61baf8
18:16:13 <dmwit> Well, aesthetics vary. But here I think it's well worth working out how to do it without mentioning *anything* special about W. But "special" has a specific meaning that you may not know/understand/recognize yet.
18:16:14 <JuanDaugherty> u know about blas, linpack, etc, right?
18:16:24 <dmwit> lucasem: So I will tell you what constraints *I* would pick if
18:16:31 <dmwit> ...I were solving them.
18:16:31 <JuanDaugherty> there's a hs binding for em iirc
18:16:52 <dmwit> lucasem: Namely: besides (+), I'd only allow the use of bind, return, and fmap.
18:17:39 <dmwit> lucasem: Anyway I think your solution for exercise 2 is fine. There's a very standard and idiomatic alternative solution, but it would be very hard to write it with just the combinators you know right now.
18:17:40 <lucasem> ah well then I'd do `g n = bind (return . (+n))` for sure
18:17:54 <dmwit> lucasem: Great!
18:18:08 <lucasem> assuming I knew all the relevant combinators, what would the standard/idiomatic sol'n be?
18:18:13 <dmwit> lucasem: And just for fun: can you do it without bind and return? =)
18:18:58 <dmwit> `h = liftA2 (+)` or `h x y = (+) <$> x <*> y` are idiomatic. `(<$>)` you know as fmap. `(<*>)` is a stranger one.
18:19:17 <lucasem> nice! I've been reading about applicative :)
18:19:44 <lucasem> that makes a lot of sense
18:19:51 <lucasem> thanks!
18:20:03 <dmwit> lucasem: Another idiomatic solution would be, roughly: `h x y = bind (\vx -> bind (\vy -> return (x+y)) y) x`.
18:20:24 <dataN> ((define32 :: Empty32 g f => Def32 Empty32 g f) (using32' :: InvHoist2 g => Def32 Empty32 g f -> (forall x. (Empty32 g f => x) -> x))) :: Empty32 g f => (forall x. (Empty32 g f => x) -> x)
18:20:48 <dataN> apparently g and f are ambiguous
18:22:40 <dataN> sorry! those should be the other way round, its; using32' $ define32
18:22:42 <dmwit> lucasem: (Anyway, spoilers for exercise 1: another solution is `g n = fmap (+n)`. And indeed it is a law that `bind (return . f) = fmap f`.)
18:32:07 * hackage espial 0.0.4 - Espial is an open-source, web-based bookmarking server.  http://hackage.haskell.org/package/espial-0.0.4 (jonschoning)
18:37:44 <tombert> I have a bit of a dumb question; if I have a function that returns a Maybe String, is there a way to automatically convert it into a MaybeT IO String?
18:38:45 <edmundnoble> Automatically?
18:38:54 <tombert> well, let me rephrase
18:39:06 <tombert> is there something like Maybe a -> MaybeT IO a
18:39:18 <edmundnoble> Well, there's a function `f (Maybe a) -> MaybeT f a`
18:39:30 <dataN> hmm, looks like; (p=>x->((q=>y)->y)) -> (q=>x) -> ((p,q)=>((p,q)=>z)->z)
18:39:31 <edmundnoble> And also for `Applicative f`, there's a function `a -> f a`
18:40:02 <edmundnoble> So that would be `MaybeT . pure`
18:40:13 <tombert> Ohh, lemme try that
18:43:03 <tabemann> I've got a question about Megaparsec
18:43:44 <tabemann> I want to use Megaparsec with the Identity monad, but from looking at the API it looks like I cannot do anything with it unless I use a monad that satisfies Alternative and MonadPlus, which Identity does neither of
18:45:04 <tombert> edmundnoble: Hey, that worked, thank you
18:45:13 <edmundnoble> Welcomes!
18:47:23 <dataN> nope, its; (p=>x->((q=>y)->y)) -> (q=>x) -> ((p,q)=>((q)=>z)->z)
18:47:27 <dataN> :t \a b -> a b ::  (p=>x->((q=>y)->y)) -> (q=>x) -> ((p,q)=>((q)=>z)->z)
18:47:28 <lambdabot> error:
18:47:28 <lambdabot>     • Could not deduce: (p0, q0)
18:47:28 <lambdabot>       from the context: (p, q)
18:48:40 <monochrom> tabemann: How do you come to that conclusion?  I saw "runParserT :: Monad m => ParsecT e s m a -> ..." it totally is fine with Identity.
18:49:31 <monochrom> In fact just use "parse :: Parsec e s a -> ..." in which "Parsec" means "type Parsec e s = ParsecT e s Identity"
18:49:40 <tabemann> runParserT does not require a MonadParsec instance
18:50:29 <dataN> how can p and q be made to be the same in each argument?
18:50:39 <tabemann> class (Stream s, Alternative m, MonadPlus m) => MonadParsec e s m | m -> e s whereclass (Stream s, Alternative m, MonadPlus m) => MonadParsec e s m | m -> e s where
18:50:44 <tabemann> whoops
18:50:50 <tabemann> somehow that pasted twice
18:51:23 <tabemann> Identity does not belong to classes Alternative or MonadPlus
18:52:22 <edmundnoble> `ParsecT e s Identity` does
18:52:46 <dataN> Alternative is a superclass of MonadPlus and so its a redundant constraint there
18:52:48 <monochrom> OK, read this: (Ord e, Stream s) => MonadParsec e s (ParsecT e s m)
18:53:57 <tabemann> okay, I got it
18:54:01 <tabemann> I was confused
18:54:21 <tabemann> I didn't realize that the monad referred to by MonadParsec was not the monad referred to by ParsecT
18:54:23 <dataN> actually it could be this; p=> (p=>x->((q=>y)->y)) -> (q=>x) -> ((q=>z)->z)
18:57:09 <dataN> ok no, its definatly this; (p,q) => (p=>x->((q=>y)->y)) -> (q=>x) -> ((q=>z)->z)
18:57:23 <dataN> that looks fine right?
18:57:35 <dataN> but its seemingly impossible to define!
18:58:33 <dataN> see "recode" on line 25 of the last paste; https://gist.github.com/dataN-hs/18caf53bb6c97ef9a29e663e1e61baf8
19:00:36 <dataN> :t \ a b -> a b :: (p,q) => (p=>x->((q=>y)->y)) -> (q=>x) -> ((q=>z)->z)
19:00:38 <lambdabot> error:
19:00:38 <lambdabot>     • Could not deduce: (p0, q0)
19:00:38 <lambdabot>       from the context: (p, q)
19:29:22 <vaibhavsagar> is there a way to generalise `fmap . fmap . fmap` into an `fmapLevel 3` function?
19:30:05 <vaibhavsagar> I'm pretty sure the answer is no, just because I can't think of what the type signature would be
19:32:19 <jackdk> :t \c f -> getCompose (fmap f (Compose c))
19:32:20 <lambdabot> forall k1 (f :: k1 -> *) (g :: * -> k1) a1 a2. Functor (Compose f g) => f (g a1) -> (a1 -> a2) -> f (g a2)
19:33:39 <jackdk> the types get a bit wild but can you stack/unstack Composes?
19:37:45 <vaibhavsagar> yeah, I tried that and it does work
19:38:05 <vaibhavsagar> but I'm just wondering if I can somehow define a recursive fmapLevel function to do it for me
19:38:43 <vaibhavsagar> reminds me a bit of monad transformers
19:58:08 <lyxia> you can do fmapmagic @3
19:58:25 <lyxia> for some value of fmapmagic
19:58:52 <vaibhavsagar> hmm, that's interesting
19:59:14 <vaibhavsagar> my type-level-function-fu is weak but I will have to investigate this further
20:01:12 <jackdk> man I missed the cool bit during a connection drop. Can someone repost the fmapmagic snippet?
20:01:53 <vaibhavsagar> jackdk: fmapmagic @3
20:01:57 <vaibhavsagar> that's it
20:02:08 <lyxia> vaibhavsagar: https://gist.github.com/Lysxia/fcd71ef900ea605a4d6a95bb93c05f1c
20:02:43 <vaibhavsagar> woah
20:02:51 <lyxia> or maybe the last line is   fmap . fmaps @(n-1)
20:02:54 <jackdk> that's sickawesome
20:04:03 <koz_> Is it not possible to autoderive _any_ instances for GADTs? Not even the likes of Eq, Show and Read?
20:04:41 <lyxia> koz_: for some GADTs you can
20:05:22 <koz_> lyxia: Clearly mine are not that. It's unfortunate because the instance for Eq is _super_ mechanical.
20:05:38 <Gurkenglas> lyxia, what do you need the numbers for in there?
20:05:58 <lyxia> Gurkenglas: to know how many times to compose fmap
20:06:19 <vaibhavsagar> which language extension do I need to do @(n-1)?
20:06:23 <Gurkenglas> Can't it know that from how many times it has to apply the instance to get to the s~a,t~b one?
20:06:26 <rotaerk> TypeApplications
20:06:32 <rotaerk> also need DataKinds
20:06:38 <vaibhavsagar> hmm, I tried with both of those
20:06:43 <rotaerk> do you also need TypeOperators?
20:06:48 <vaibhavsagar> that one too
20:07:24 <lyxia> Gurkenglas: it depends, in some contexts it's not inferrable
20:07:41 <koz_> Also, I have a type Foo a, and I need a linear collection of Foo as, but 'a' may be one of _exactly_ six different things. I dunno how long said linear collection will need to be. Is there a typesafe way of doing this?
20:08:06 <koz_> (to be clear, inside said collection, I may need different a for each element)
20:08:41 <Gurkenglas> lyxia, do you mean there's a way to use Functors where the n saves the inference, or one needs to use something other than Functors to illustrate n's usefulness?
20:09:25 <lyxia> Gurkenglas: there's a way to use Functors where the n saves the inference.
20:09:55 <Gurkenglas> lyxia, shouldn't (n-1) -> n be something like n -> S n so you don't need the overlapping annotation?
20:10:35 <lyxia> I prefer being able to write literals
20:11:04 <vaibhavsagar> I'm now getting an error about `n` not being in scope
20:11:12 <lyxia> vaibhavsagar: ScopedTypeVariables
20:11:19 <Gurkenglas> That merely needs a Num instance for data Nat = Z | S Nat, right?
20:11:30 <lyxia> nope
20:11:43 <lyxia> type level literals are not overloaded
20:12:05 <Gurkenglas> Is that a "patches welcome" sort of deal or is there a good story behind it?
20:17:42 <lyxia> I'm not sure. It doesn't seem like an easy feature to implement, and dependent haskell will replace it anyway...
20:37:09 <koz_> Is there a way for me to convert four Word8 arguments into a Word32 by concatenating the arguments left to right, and if so, how do I write this?
20:40:26 <pavonia> koz_: If you want concatenation, you could write a Monoid instance for a wrapper type that folds using shift/or
20:41:40 <pavonia> Hhm no, that doesn't give proper monoid
20:42:26 <koz_> pavonia: I tried this to test an idea, but the parser vomits on it: ((fromIntegral (bit 3 :: Word8) :: Word16) `shiftL` 8
20:42:32 <koz_> What did I not type correctly here?
20:42:56 <geekosaur> too many (s
20:43:08 <pavonia> :t (fromIntegral (bit 3 :: Word8) :: Word16) `shiftL` 8
20:43:09 <lambdabot> Word16
20:43:30 <koz_> geekosaur: Thanks, I must be _really_ out of it.
20:44:06 <nshepperd1> pavonia: you could do that with a monoid type containing a Word32 with the bits and a number saying how many bits it has
20:45:12 <nshepperd1> The identity would be (0,0)
20:46:37 <pavonia> Yeah, that would work
20:47:45 <vaibhavsagar> is haskell supposed to accept GeneralisedNewtypeDeriving instead of GeneralizedNewtypeDeriving?
20:47:59 <vaibhavsagar> I thought so but I did a quick experiment and it doesn't seem to
20:48:25 <vaibhavsagar> (by haskell I mean GHC)
20:53:38 <koz_> What's the extension I need to be able to write 'fromIntegral x :: a' in the body of a function 'foo :: (Num a, FiniteBits a) => Word8 -> Word8 -> a'?
20:53:47 <koz_> (and have it understand that the 'a's are the same)
20:54:38 <vaibhavsagar> koz_: ScopedTypeVariables?
20:54:45 <koz_> vaibhavsagar: That might be it.
20:54:58 <koz_> Yess.
20:55:03 <vaibhavsagar> also it turns out the British spelling is new in 8.6.1, to answer my own questions
20:55:32 <koz_> vaibhavsagar: Is this SPJ's doing I wonder?
20:55:47 <vaibhavsagar> nope, I'm looking at the change and it's by bgamari
20:55:53 <koz_> Who's that?
20:56:08 <vaibhavsagar> Ben Gamari does a lot of work on GHC
20:56:21 <vaibhavsagar> AFAIK he lives in the US
20:58:04 <vaibhavsagar> I'm pretty excited to use 8.6.1 now, not only does it have BlockArguments and DerivingVia but also more British spelling :)
20:58:15 <koz_> Yay!
20:58:29 <koz_> I hope that gets listed on the changelog.
21:07:33 <koz_> Is there a better way of writing \(x,y,z,a) -> foo x y z a
21:07:35 <koz_> ?
21:08:06 <benzrf> :t uncurry4
21:08:07 <lambdabot> error:
21:08:07 <lambdabot>     • Variable not in scope: uncurry4
21:08:07 <lambdabot>     • Perhaps you meant ‘uncurry’ (imported from Data.Tuple)
21:08:09 <benzrf> i guess not
21:08:35 <benzrf> but why are you using 4-tuples to start with?
21:09:06 <koz_> benzrf: A very good point.
21:09:11 <benzrf> heh
21:23:46 <koz_> Is there a reason why Float is not an instance of FiniteBits?
21:25:07 <geekosaur> because it's best not to treat Float as a bucket of bits? what does it do with NaN or Inf?
21:25:21 <koz_> Yeah, point taken.
21:25:25 <geekosaur> and a bit shift is tweaking the exponent, not the mantissa
21:25:39 <koz_> This _kinda_ ruins my plans though, because if you want to compress a bunch of floats you have to munge it into a bytestring.
21:28:37 * hackage digestive-functors 0.8.4.0 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.8.4.0 (JasperVanDerJeugt)
21:34:07 * hackage digestive-functors-heist 0.8.8.1 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.8.8.1 (JasperVanDerJeugt)
21:36:06 * hackage digestive-functors-snap 0.7.0.1 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.7.0.1 (JasperVanDerJeugt)
21:37:01 <pavonia> koz_: What do you need that compression for?
21:38:28 <koz_> It's fine - I can probably do without it. I need to rethink what I'm doing. Again.
21:38:33 <koz_> Haskell is very good at making me do that.
21:42:57 <cocreature> koz_: if you want to convert Float to a ByteString take a look at the binary library
21:44:09 <cocreature> note that the Binary instance is pretty inefficient so you probably want to use putFloatle/be directly
21:56:04 <b4r> hello
22:07:37 * hackage instance-map 0.1.0.0 - Template haskell utilities for helping with deserialization etc. of existential types  http://hackage.haskell.org/package/instance-map-0.1.0.0 (rwarfield)
22:31:07 * hackage async-combinators 0.0.1 - Async combinators  http://hackage.haskell.org/package/async-combinators-0.0.1 (vrom911)
23:50:37 * hackage servius 1.2.2.0 - Warp web server with template rendering  http://hackage.haskell.org/package/servius-1.2.2.0 (MichaelSnoyman)
23:52:37 * hackage life-sync 1.0.1 -   http://hackage.haskell.org/package/life-sync-1.0.1 (shersh)
