00:00:02 <dysfun> they're super useful
00:00:09 <tdammers> ah yes, Read, in all its gore, is also very useful
00:00:25 <mniip> a monoid is just a generalization of monad to non-endofunctor categories
00:00:32 <milesrout> lol
00:00:44 <ab9rf> hah
00:01:03 <dysfun> "a monoid is like a toffee that fell on the floor, it sticks to other monoids"
00:01:27 <mniip> I kid, of course. Ideally a monoid is the first algebraic data structure you ever work with. Long before categories/functors/...
00:01:34 <ab9rf> i really do not want a toffee burrito
00:01:44 <tdammers> ab9rf: it wouldn't typecheck anyway, so you're good
00:02:00 <dminuoso> I never started to appreciate a monoid until I started Haskell. Now I really freaking *enjoy* writing code like `"foo" <> a <> "bar"` *knowing* I dont have to think about precedence because of associativity
00:02:16 <dminuoso> Lawful abstractions are so wonderful
00:02:40 <tdammers> another cool thing about them is that once you make a habit of generalizing your code to reasonable extents, it tends to become simpler and more useful
00:03:10 <Sap4> hi there
00:03:11 <milesrout> why would you care about monoids outside of haskell? they're not a particularly interesting algebraic structure in their own right.
00:03:21 <c50a326> mniip: why do you say that about "Ideally..." ?
00:03:37 <mniip> milesrout, consider a reduce operation
00:03:48 <mniip> a "fold" if you wish
00:03:48 <c50a326> I haven't looked at monoid yet and I've been looking at various haskell stuff for some weeks now lol
00:04:14 <dysfun> monoids are really useful though
00:04:16 <tdammers> c50a326: do look at Monoid. It's a very simple yet useful abstraction.
00:04:19 <mniip> if you want to do it in parallel, or otherwise let the implementation define the exact order/direction of the fold
00:04:24 <mniip> you gotta use a monoid
00:04:48 <mniip> you want to have a neutral element, and you want your combining function to be associative
00:04:58 <mniip> otherwise the result depends on the exact details of the implementation
00:05:11 <ab9rf> milesrout: they seem rather useful to me
00:05:33 <Sap4> I just started learning Haskell. Can someone give me an example of what is it practically used for?
00:05:51 <c_wraith> writing software
00:05:53 <ab9rf> Sap4: writing programs
00:05:56 <mniip> milesrout, a monoid doesn't have to be a typeclass/concept/trait that's explicitly specified in a signature. It is a concept
00:06:05 <ab9rf> it's a programming language, you use it to write programs
00:06:06 <tdammers> a pattern
00:06:11 <dminuoso> ^-
00:06:23 <tdammers> "a type, a binary operator, and a neutral element" - that's monoid
00:06:23 <Sap4> ab9rf: Damn that's specific
00:06:42 <mniip> Sap4, what is C++ practically used for?
00:06:46 <dminuoso> Sap4: Haskell is a general purpose programming language. You can use it to write pretty much any program you write.
00:06:56 <tdammers> in Haskell, we make it explicit by saying, "this type forms a monoid, and these are the operator and neutral element that go with it"
00:07:07 <Sap4> mniip: idk for example game dev (game engines)
00:07:12 <tdammers> but the monoid pattern still pops up if you don't make it explicit
00:07:12 <dminuoso> Sap4: For some things its wonderfully powerful. There's only very few things it't not well suited for. :)
00:07:20 <mniip> Sap4, note how you had to resort to "for example"
00:07:30 <tdammers> string concatenation and integer addition are monoids, whether you admit it or not
00:08:05 <ab9rf> lots amd lots of incredibly common computational operations are monoids
00:08:13 <Sap4> Ty for the answers guys
00:08:16 <tdammers> the advantage of making it explicit as a Haskell typeclass is that you can now write code that says, "I don't care what the type and the binary operation and the neutral element are, as long as they form a monoid, I can do my thing"
00:08:47 <mniip> Sap4, Haskell is a general purpose programming language. It can be used to write all kinds of software, much like C++ or python
00:08:55 <tdammers> and code that you write in terms of the Monoid typeclass rather than any specific monoidal type will work for *all* monoids, not just the one you've been thinking about
00:09:06 * hackage wordexp 0.2.2 - wordexp(3) wrappers  http://hackage.haskell.org/package/wordexp-0.2.2 (MatveyAksenov)
00:09:07 <dminuoso> Sap4: Some things it's particularly good for is: data processing, parsing, building compilers, single machine concurrency, writing correct code
00:09:09 <tdammers> and the explicitly enforced abstraction makes sure you're not doing it wrong
00:09:15 <dminuoso> Sap4: but it is in no way limited to these fields. :)
00:09:18 <tdammers> (mostly)
00:10:20 <dminuoso> In the end I think a Monoid can be best understood by repeated usage.
00:10:27 <Sap4> dminuoso: is Haskell a good first functional language to learn?
00:10:31 <dminuoso> Sap4: Yes.
00:10:34 <iqubic> Yes.
00:10:59 <ab9rf> Sap4: yes; i'd even argue that it's a good first programming language to learn
00:11:16 <mniip> haskell's weak points include: not very dynamic (dynamic interpretation is tricky), has a rather massive and picky runtime and a garbage collector (hard to run barebones and/or use for osdev), hard to reason about performance (very easy to accidentally write glacial code)
00:11:19 <dminuoso> In fact Haskell is probably easier to learn as a first programming language.
00:11:36 <ab9rf> mniip: also, a tetchy ecosystem
00:11:38 <dminuoso> +1 mniip
00:11:43 <Sap4> ab9rf: programmed in several other languages before and I find Haskell's syntax confusing. it's very different from non-functional languages
00:11:55 <dminuoso> Not a bad idea to highlight the bad sides of our beloved language. =)
00:11:59 <ab9rf> Sap4: bah, you obviously have not tried brainfuck yet
00:12:00 <mniip> I'm not saying you can't apply haskell in respective areas, but rather it's going to be a much tougher challenge
00:12:37 <Sap4> ab9rf: I actually have. Done some basic programs in that.
00:12:49 <ab9rf> Sap4: and you think haskell's syntax is confusing?
00:12:55 <dminuoso> Sap4: What language background do you have?
00:12:58 <mniip> Sap4, that's because functional programs look vastly differently from imperative programs
00:13:12 <ab9rf> i will admit that haskell's menagerie of linenoise operators can be confusing
00:13:19 <Sap4> dminuoso: c++, js, some c# and python
00:13:52 <ab9rf> but really the problem that most people who only have experience with other languages have is grokking that haskell isn't procedurally imperative
00:14:01 <Sap4> ab9rf: starting to make sense and come together, but still very different
00:14:08 <ab9rf> it's not a "do this, then do that" language
00:14:28 <mniip> yeah, it's an equational language
00:14:39 <Sap4> ab9rf: yup, it's a completely different way of thinking
00:14:43 <ab9rf> i ran into prolog 30 years ago, so this wasn't quite so difficult to adjust to
00:14:45 <mniip> map (+3) [1, 2, 3] = [4, 5, 6]
00:14:46 <dminuoso> Sap4: Just know that learning Haskell after years of imperative training is not easy, it requires some unlearning. :)
00:14:51 <mniip> nothing is "done". it's just "equal"
00:15:01 <tdammers> Sap4: IMO it's not the syntax that makes Haskell so brain-wreckingly different from mainstream stuff
00:15:15 <tdammers> I mean, if you squint enough, it looks a lot like Python or Ruby
00:15:23 <dminuoso> Sap4: It's not meant to discourage you, just to prepare that - based on observation - it's likely to take a bit longer than it would take for someone learning Haskell as their first language.
00:15:31 <Sap4> tdammers: the syntax + the way things come together
00:15:32 <ab9rf> tdammers: eh, only at a first approximation
00:15:34 <tdammers> the things you need to unlearn aren't syntactic
00:15:49 <tdammers> ab9rf: yeah, I mean just the general superficial aesthetics of it
00:15:49 <dminuoso> Sap4: And this is *not* about syntax. Syntax you will pick up fast :)
00:15:52 <Sap4> dminuoso: I get that
00:16:14 <mniip> you say you have 4 languages behind your back
00:16:17 <c50a326> oh, we use monoids when we write recursive functions I guess?
00:16:20 <mniip> syntax should be merely a nuisance if anything
00:16:27 <c50a326> we need to use the identity to break the recursion?
00:16:33 <dminuoso> c50a326: Monoid has no concrete point.
00:16:34 <mniip> c50a326, what?
00:16:35 <Sap4> mniip: well that's the easy part, usually
00:16:44 <dminuoso> c50a326: Do you know what a software development pattern is?
00:16:48 <mniip> Sap4, "but"?
00:16:56 <ab9rf> c50a326: i'm not following what you're saying at all
00:17:07 <c50a326> dminuoso: like "visitor" or "pub/sub" or something? yeah lol
00:17:13 <dminuoso> c50a326: Yes.
00:17:17 <dminuoso> c50a326: So Monoid is also just a pattern.
00:17:20 <c50a326> ab9rf: well I was just learning what monoids are
00:17:37 <ab9rf> c50a326: i understand now, thanks
00:17:38 <Sap4> mniip: for me the harder part is learning good practices and specific workflows
00:17:49 <dminuoso> c50a326: Whenever you have some thing T, and a function T -> T -> T that is associative, and some special value of type T that acts as an identity wrt to the other function - that is the pattern
00:17:59 <mniip> Sap4, that's a neverending journey
00:18:00 <dminuoso> c50a326: It's really some abstract pattern.
00:18:15 <dminuoso> c50a326: think about this: what does string concatenation and integer multiplication have in common
00:18:27 <dminuoso> c50a326: Monoid tries to capture that thing.
00:18:36 <Sap4> mniip: true
00:18:48 <mniip> dminuoso, "so much fuzz about these arrows - ah, they're just functions!"
00:19:02 <dminuoso> mniip: haha. wasnt that from some ro-che comic? :)
00:19:07 <mniip> yes
00:21:42 <dminuoso> c50a326: If you wanted you could start with a typeclass `class Combinable t where combine :: t -> t -> t` - so `Combinable` captures the notion of being able to *somehow* combine two things into one.
00:21:46 <dminuoso> You dont care how or what it means.
00:23:37 <mniip> dminuoso, I think that's called a Magma
00:23:45 <dminuoso> mniip: Yes. I purposefully avoided that name
00:23:52 <mniip> :(
00:24:17 <dminuoso> mniip: wanted to reveal it once I made it to AssocCombinableWithNull :P
00:24:20 <voicelessdragon> dminuoso: when you say some special identity value of type T wrt the function T -> T -> T, do you mean that for any value v in T, f(i, v) = f(v, i) = v?
00:24:23 <ab9rf> the names from algebra tend not to help understanding for people who aren't already experts in abstract algebra or category theory
00:24:30 <dminuoso> voicelessdragon: Yes!
00:24:48 <mniip> ab9rf, I am neither. Just was wondering if dminuoso was just in need of a concrete name
00:25:03 <ab9rf> mniip: i think that was being deliberately avoided :)
00:25:36 <mniip> yes, now I know that, now that dminuoso said so explicitly
00:26:24 <ab9rf> mniip: giving names to things that don't need them, especially when the names are uninformative, just contributes to cognitive overload of the learner
00:27:06 * hackage githash 0.1.0.1 - Compile git revision info into Haskell projects  http://hackage.haskell.org/package/githash-0.1.0.1 (MichaelSnoyman)
00:27:16 <ab9rf> and the names from abstract algebra are especially... unhelpful.
00:27:43 <ab9rf> "a... magma? what do volcanoes hae to do with this? i'm so confused!"
00:27:58 <ab9rf> and *bam* you just lost a student
00:28:36 * hackage bit-protocol 0.2.0.0 - Encode binary protocols with some odd bit numbers into a bytestring  http://hackage.haskell.org/package/bit-protocol-0.2.0.0 (k_bx)
00:28:40 <mniip> Cosemiendorepresentableoid
00:29:47 <ab9rf> mniip: at least that doesn't evoke images of people's houses being destroyed by lava
00:30:39 <dminuoso> Also.. is there a word for a Monoid without associativity?
00:30:49 <dminuoso> Migma?
00:31:06 <mniip> unital magma
00:32:28 <mniip> not very interesting because every unital magma U factors as U ~ Maybe M for a (general) magma M
00:32:44 <ab9rf> not very interesting things tend not to get named :)
00:33:25 <dminuoso> Heh
00:33:48 <dminuoso> On the road I started, how would you explain why associativity needs to be added?
00:34:09 <dminuoso> What's so good about it, that we fling around Semigroup rather than Magma?
00:34:25 <mniip> c50a326, regarding the "why should monoid come before category" - well for one you should have some intuition about "models" (and maybe "theories") before you can start to tackle something as abstract as a category
00:34:41 <dminuoso> A category is a multi-object monoid.
00:34:44 <dminuoso> So it's a generalization!
00:34:52 <mniip> that's the least useful argument
00:34:52 <ab9rf> i still don't understand categories
00:35:36 <ab9rf> scattergories
00:37:29 <mniip> @src Category
00:37:30 <lambdabot> Source not found. Wrong!  You cheating scum!
00:37:42 <mniip> % :i Category
00:37:42 <yahb> mniip: class Category (cat :: k -> k -> *) where; C.id :: forall (a :: k). cat a a; (C..) :: forall (b :: k) (c :: k) (a :: k). cat b c -> cat a b -> cat a c; {-# MINIMAL id, (.) #-}; -- Defined in `Control.Category'; instance [safe] Comonad w => Category (Cokleisli w) -- Defined in `Control.Comonad'; instance Category (:-) -- Defined in `Data.Constraint'; instance Category (:~~:) -- Defined in `Contro
00:38:15 <mniip> on a second thought haskell's categories aren't the best approach
00:38:22 <dminuoso> class (Category' (Dom f), Category' (Cod f)) => Functor (f :: i -> j) where type Dom f :: i -> i -> *; type Cod f :: j -> j -> *; fmap :: Dom f a b -> Cod f (f a) (f b)
00:38:23 <ab9rf> mniip: haha
00:38:38 <dminuoso> o_o
00:38:48 <mniip> ab9rf, are you familiar with algebra?
00:38:56 <dminuoso> Oh.. Dom and Cod is probably domain and codomain?
00:39:21 <mniip> dom is short for dominic and cod is a type of fish
00:39:40 <mniip> (yes)
00:39:53 <ab9rf> mmm, fish burrito
00:40:04 <ab9rf> mniip: i am, but not very.
00:40:05 <dminuoso> Went to Scotland recently, really had to smile when I read "beer-battered haddock.." somewhere, I never realized that `haddoc` was probably a reference to the fish.
00:40:23 <ab9rf> mniip: i'm not asking you to explain categories to me :)
00:40:37 <mniip> too bad
00:40:55 <mniip> I was about to expand monoids to monoidoids aka categories
00:41:14 <ab9rf> mniip: i'd need more painkillers first
00:41:58 <dminuoso> But yeah.. why is associativity so important for us?
00:43:09 <mniip> frankly no idea
00:45:27 <dminuoso> :t foldMap
00:45:28 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
00:45:38 <dminuoso> This would work with an unital magma too, would it not?
00:46:24 <mniip> ooh til the "group of fractions" is the free functor from semigroups to groups
00:47:25 <mniip> dminuoso, data T a = T a a a
00:47:31 <mniip> now you have two foldable instances
00:48:06 <dminuoso> Is that bad?
00:48:24 <mniip> yes
00:48:28 <ab9rf> why?
00:48:29 <mniip> your user doesn't know which
00:48:35 <dminuoso> But why? I mean the fact that we have one foldable instance is precisely because of associativity.
00:48:49 <dminuoso> mniip: That's not our problem? Integer has multiple Monoid instances too.
00:50:09 <mniip> > (2 :: Integer) <> 3
00:50:12 <lambdabot>  error:
00:50:12 <lambdabot>      • No instance for (Monoid Integer) arising from a use of ‘<>’
00:50:12 <lambdabot>      • In the expression: (2 :: Integer) <> 3
00:50:17 <mniip> it has neither I'm afraid
00:50:22 <dminuoso> You know what I mean. :P
00:50:40 <tdammers> integers form multiple monoids, but none of them is implemented as a Monoid instance of Int in Haskell
00:50:56 <ab9rf> because it's not relaly useful to do so
00:50:58 * [exa] wishes for 2 <> 3 = 23
00:51:13 <tdammers> [exa]: acme-php should have you covered!
00:51:17 <ab9rf> and also because there's no good reason to pick one of those instances as the "natural" instance
00:51:22 <tdammers> [exa]: instance Num String where ...
00:51:44 <[exa]> :D
00:51:44 <mniip> ab9rf, exactly. so writing a type T puts you in the same place
00:51:54 <mniip> you can't choose which instance to provide
00:51:59 <tdammers> ab9rf: that's actually the real reason - neither the sum nor the product monoids are intrinsically better choices
00:52:06 <ab9rf> it's even arguable that 2 <> 3 being 23 is "more natural" than it being 5 or 6
00:52:24 <mniip> Foldable on the other hand
00:52:29 <tdammers> ab9rf: not unless you somehow consider decimal notation special
00:52:32 <mniip> whenever it exists there's only one lawful instance
00:52:40 <ab9rf> tdammers: meh
00:52:44 <mniip> and it's very easy to see when it exists
00:53:35 <ab9rf> integers are too rich
00:54:01 <ab9rf> too much structure
00:54:17 <ab9rf> prone to dancing on a moment's notice
00:54:48 <Sap4> what's with 2<>3=23 I'm confused
00:55:00 <mniip> Sap4, nevermind. Hypothetical discussions
00:55:12 <tdammers> Sap4: you could, in principle, form another monoid over integers, using concatenation of decimal digits
00:55:21 <Sap4> mniip: oh okay, was just looking and noticed so I got curious
00:55:39 <Sap4> tdammers: it's ok I don't know what a monoid is
00:55:53 <mniip> tdammers, that reminds me of our discussion relating monoids to list applicatives
00:56:02 <c50a326> so Int is not a Monoid?
00:56:03 <mniip> and coming up with progressively worse monoids
00:56:09 <mniip> c50a326, why not
00:56:12 <ab9rf> c50a326: Int is a type.
00:56:54 <Gurkenglas-> When installing Haskell Platform without admin privileges on Windows, it asked me more than once if I wouldn't rather run it with them, the times after the first in the name of different subtools. Shouldn't I only be asked once?
00:57:01 <cocreature> Int is not an instance of the Monoid typeclass. it is a monoid in a mathematical sense (even in multiple ways)
00:57:06 <tdammers> Sap4: "monoid" is a concept that says you have a type, a binary operation, and a neutral value, such that the monoid laws hold: a <> zero == a, zero <> a == a, a <> (b <> c) == (a <> b) <> c
00:57:09 <c50a326> god dammit I've basically forgotten how typeclasses work already it seems -.-
00:57:30 <Gurkenglas-> At the end, it said a few times ~"couldn't set the PATH to HLKM" - it should be more clear on whether that's fatal.
00:57:36 <c50a326> but yeah I was looking for an `instance` thingy for Int for Monoid and couldn't find it
00:57:50 <c50a326> I was wondering where the monoids for stuff like addition and multiplication might be defined, if anywhere
00:58:01 <tdammers> Sap4: in Haskell, we implement this as a typeclass, which unfortunately means that when you pick a type, then you can only have one Monoid for it, even if in theory many of them might exist
00:58:37 <tdammers> Sap4: straightforward examples of monoids are (number, addition, 0) and (string, concatenation, "")
00:59:13 <Sap4> tdammers: is <> just a placeholder for a binary operation?
00:59:18 <tdammers> Sap4: yes.
00:59:28 <Sap4> tdammers: that makes more sense now
00:59:45 <ab9rf> Sap4: although <> actually is an operator in haskell
00:59:50 <ab9rf> :t (<>)
00:59:52 <lambdabot> Monoid m => m -> m -> m
00:59:53 <cocreature> c50a326: we have newtypes that have these instances, e.g. Sum for Addition and Product for multiplication
00:59:56 <tdammers> Sap4: (technically it's a typeclass method, or a polymorphic function, but you can think of it as a placeholder if you squint a little)
01:00:22 <dminuoso> c50a326: Did you read my original `class Combinable t where combine :: t -> t -> t`
01:00:27 <ab9rf> the symbol <> was chosen because it superficially resembles the small ring symbol that is often used as a generic operator
01:00:38 <mniip> not diamond?
01:00:39 <tdammers> Sap4: there are also less obvious monoids out there, like for example endofunctors: (a -> a, function composition, identity function)
01:00:54 <dminuoso> tdammers: *endofunctions
01:01:00 <ab9rf> mniip: i've seen the small ring used far more often than a diamond
01:01:03 <tdammers> dminuoso: motor memory, dammit
01:01:06 <dminuoso> heh :)
01:01:16 <mniip> ab9rf, a small ring would be \circ
01:01:19 <tdammers> but yes, endofunctions, not -functors
01:01:27 <mniip> usually means composition, denoted in haskell by "."
01:01:40 <mniip> unless you're in language theory where that's word and/or language concatenation
01:01:54 <Sap4> tdammers: does 'monoid' refer to a whole expression?
01:02:06 <ab9rf> mniip: sadly, there's a lot of inconsistency in symbol use across areas of mathematics
01:02:25 <mniip> Sap4, "a monoid" refers to the triplet (set of things, binary operation, one chosen thing)
01:02:37 <Sap4> mniip: ok
01:02:38 <mniip> however often people are lazy and name only the first
01:02:56 <ab9rf> mniip: at least when i was actually dealing with this stuff on a fairly regular basis (i used to typeset math for a grad student, years ago), \circ was often used for an arbitrary operation
01:03:04 <c50a326> dminuoso: oh no I missed that, got it now, thanks
01:03:15 <tdammers> mniip: I like to write "monoid" when I'm talking about the theoretical triple, and "Monoid" when I'm talking about the Haskell typeclass
01:03:37 <mniip> sure
01:03:38 <dminuoso> c50a326: Right. So Monoid just extends that by adding some `null :: t`, for which `combine null x = x` and `combine x null = x`
01:03:48 <dminuoso> c50a326: And requiring combine to associative
01:04:09 <dminuoso> c50a326: If you are curious, if you leave `null` away you get Semigroup :)
01:04:55 <lavalike> does lambdabot import monoid and semigroup?
01:05:04 <mniip> lavalike, yes
01:05:05 <ab9rf> lavalike: it knows Monoid
01:05:19 <lavalike> > getMin . foldMap Min $ "mniip"
01:05:21 <lambdabot>  error:
01:05:21 <lambdabot>      • Variable not in scope: getMin :: b0 -> c
01:05:21 <lambdabot>      • Perhaps you meant one of these:
01:05:34 <lavalike> :/
01:05:43 <mniip> :k Semigroup
01:05:45 <lambdabot> error:
01:05:45 <lambdabot>     Not in scope: type constructor or class ‘Semigroup’
01:05:54 <mniip> I stand corrected
01:05:57 <dminuoso> > import Data.Semigroup
01:05:59 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
01:06:03 <dminuoso> @let import Data.Semigroup
01:06:04 <lambdabot>  Defined.
01:06:08 <dminuoso> @let import Data.Monoid
01:06:09 <lambdabot>  Defined.
01:06:17 <dminuoso> :k Semigroup
01:06:19 <lambdabot> * -> Constraint
01:06:31 <mniip> :t stimes
01:06:31 <lavalike> > getSum . foldMap Sum $ [1..10]
01:06:32 <lambdabot> (Integral b, Semigroup a) => b -> a -> a
01:06:33 <lambdabot>  55
01:06:35 <lavalike> woo
01:07:05 <Gurkenglas-> > ala Sum foldMap [1..10]
01:07:08 <lambdabot>  55
01:07:10 <Gurkenglas-> (mwahaha)
01:07:10 <dminuoso> :t ala
01:07:12 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
01:07:15 <dminuoso> What is `ala` :o
01:07:19 <lavalike> O_o
01:07:20 <mniip> a-la
01:07:30 <ab9rf> gah, that type signature is brainbending
01:07:39 <dminuoso> Deep. Black. Lens. Magic.
01:07:43 <ab9rf> those are from lens, right?
01:07:54 <mniip> it's not black
01:07:56 <dminuoso> -- The user supplied function is /ignored/, merely its types are used.
01:08:00 <dminuoso> Haha interesting
01:08:15 <Gurkenglas-> dminuoso: It borrows the powers of a newtype wrapper for what it is applied to
01:08:18 <lavalike> kind of a type application?
01:08:20 <mniip> s ~ Sum Int, Unwrapped s ~ Int
01:08:23 <milesrout> knowing that something is a monoid is whatever, it's also a magma, doesn't make magma a particularly useful concept
01:08:28 <ab9rf> ala peanutButterSandwich
01:08:34 <dminuoso> Gurkenglas-: So its actually not much different than foldMap?
01:08:37 <milesrout> outside of programming in haskell, notice I said
01:08:38 <dminuoso> (conceptually)
01:08:50 <Gurkenglas-> dminuoso: ala X foldMap isn't much different from foldMap, yes
01:09:04 <Gurkenglas-> foldMap needs a Monoid, so to ask what ala X foldMap does look at X's Monoid instance
01:09:16 <lavalike> mniip: and f?
01:09:25 <mniip> []
01:09:33 <lavalike> but it didn't return [55]
01:09:35 <mniip> actually no
01:09:38 <ab9rf> why would it?
01:09:46 <ab9rf> the sum of a bunch of integers is not a list
01:10:02 <dminuoso> c50a326: It might be obvious that sometimes there are multiple ways to combine things associatively with a "null" element. Can you think of some ways to combine integers?
01:10:05 <mniip> probably Reader
01:10:09 <mniip> :t foldMap
01:10:09 <ab9rf> it's too bad that there's no alas
01:10:10 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
01:10:14 <dminuoso> ab9rf: alas.
01:10:17 <mniip> yeah, Reader [Int]
01:10:23 <lavalike> :)
01:10:27 <lavalike> now that makes sense
01:10:30 <dminuoso> ab9rf: If only you had written that as: alas, there is no alas.
01:10:36 <ab9rf> dminuoso: alas
01:11:12 <ab9rf> lens makes my head hurt
01:11:33 <dminuoso> ab9rf: I've started a bit on profunctor optics, it helps *a lot*. :)
01:11:41 <dminuoso> But then again I havent gotten particularly far..
01:11:54 <ab9rf> i can use it, but i do not understand how it works
01:11:58 <mniip> @let alas :: b => (b :- a) -> (a => r) -> r; alas (Sub Dict) x = x
01:11:59 <lambdabot>  .L.hs:162:15: error: Not in scope: type constructor or class ‘:-’
01:12:00 <lambdabot>      |
01:12:00 <lambdabot>  162 | alas :: b => (b :- a) -> (a => r) -> r
01:12:17 <dminuoso> @let import Data.Constraint
01:12:18 <lambdabot>  .L.hs:82:1: error:
01:12:18 <lambdabot>      Could not find module ‘Data.Constraint’
01:12:18 <lambdabot>      Use -v to see a list of the files searched for.
01:12:25 <dminuoso> % import Data.Constraint
01:12:25 <yahb> dminuoso:
01:12:27 <mniip> yeah, no constraints in lambdabot
01:12:35 <dminuoso> % alas :: b => (b :- a) -> (a => r) -> r; alas (Sub Dict) x = x
01:12:36 <yahb> dminuoso:
01:14:56 <mniip> woah
01:15:17 <lavalike> what is that
01:15:53 <mniip> nevermind, I just had a particularly bad ghci crash
01:16:40 <dminuoso> lavalike: Something you use to beat GHC into submission.
01:17:51 <Gurkenglas-> alaf is like ala but makes the result take a function again, like foldMap does.
01:18:07 <Gurkenglas-> ala/alaf can work on functions like foldMap, traverse, and alaf results
01:19:03 <sjakobi> I'm trying to use Alex to select certain strings from an input. I have a rule for the strings that I want to pick. Is there a way to tell Alex to ignore all strings that don't match that rule?
01:19:10 <mniip> GHC slang is so... "closed"
01:19:31 <mniip> it takes a lot of searching to decipher what the words mean,
01:19:38 <mniip> but once you know them you can't resist using them
01:19:46 <ab9rf> mniip: that's true of mathematical lingo generally
01:20:43 <dminuoso> Only reason Im learning Haskell is so that, one day, I can decipher the post-doc example of https://www.willamette.edu/~fruehr/haskell/evolution.html without looking at the notes.
01:21:19 <dminuoso> Comonads I already breathe, the type recursion and catamorphisms are not scary either..
01:26:51 <mniip> I might know a worse way
01:31:53 <Gurkenglas-> dminuoso: By notes you mean comments?
01:32:57 <Gurkenglas-> (I hope he has a reason to flip Prod)
01:34:47 <Sap4> can you write multiple lines in ghci?
01:35:07 <Sap4> if so, how
01:35:12 <mniip> use :{ and :}
01:35:18 <mniip> or a semicolon
01:36:26 <Sap4>     parse error (possibly incorrect indentation or mismatched brackets)
01:36:38 <mniip> are you using an ancient GHC
01:37:08 <Sap4> mniip: I installed haskell-platform using dnf (I'm on Fedora)
01:38:20 <Sap4> mniip: it's version 8.2.2
01:38:45 <mniip> weird, it should work. What exactly did you type
01:39:21 <Gurkenglas-> Nope, that flip was useless after all.
01:39:46 <dminuoso> Might have been a typo?
01:39:47 <Sap4> fac n = if n == 0
01:39:59 <Sap4> and I wanted to type 'then 1' on another line
01:40:06 * hackage primitive-extras 0.5.1 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.5.1 (NikitaVolkov)
01:40:17 <Sap4> so I ttried with :{ and with ; after the first line and it gave the parse error
01:40:34 <mniip> % :{
01:40:34 <yahb> mniip:
01:40:39 <mniip> % fac n = if n == 0
01:40:40 <yahb> mniip:
01:40:43 <mniip> %  then 1
01:40:43 <yahb> mniip:
01:40:50 <mniip> %  else n * fac (n - 1)
01:40:50 <yahb> mniip:
01:40:52 <mniip> % :}
01:40:52 <yahb> mniip:
01:41:30 <Sap4> mniip: parse error on input '%'
01:41:40 <mniip> % is input to yahb, our bot here
01:41:40 <yahb> mniip: ; <interactive>:64:17: error: parse error on input `,'
01:42:17 <Sap4> mniip: that wroks
01:42:21 <Sap4> *works
01:42:27 <Sap4> thanks
01:42:36 * hackage stm-hamt 1.1 - STM-specialised Hash Array Mapped Trie  http://hackage.haskell.org/package/stm-hamt-1.1 (NikitaVolkov)
01:43:36 * hackage gi-gtk 3.0.24 - Gtk bindings  http://hackage.haskell.org/package/gi-gtk-3.0.24 (inaki)
01:46:37 * hackage stm-containers 1.0.0.1 - Containers for STM  http://hackage.haskell.org/package/stm-containers-1.0.0.1 (NikitaVolkov)
01:47:20 <mreh> does GHC have colour output? google returns nothing native to GHC
01:47:40 <mniip> hmm
01:47:47 <Saulzar_> mreh, Since 8.2
01:47:48 <ab9rf> color output?
01:47:59 <mniip> mreh, yeah mine's colored
01:48:09 <mreh> ab9rf: coloured error messages etc.
01:48:16 <ab9rf> bleah
01:48:19 <mreh> it's quite noisey, hard to pick out the details
01:48:33 <mreh> some highlighting would make it easier to skim
01:48:57 <ab9rf> i suppose it was inevitable
01:49:13 <dminuoso> Gurkenglas-: Out of curiosity, when you read that - do you understand whats going on?
01:49:14 <mreh> ab9rf: you use syntax hightlighting right?
01:49:16 <ab9rf> i had a vt100 on my desk for a long time, the idea of color anything is still a bit weird
01:49:24 <ab9rf> mreh: no
01:49:32 <ab9rf> mreh: i tend to disable it in IDEs that offer it
01:49:59 <Gurkenglas-> dminuoso: Yes, but I admit I've seen http://hackage.haskell.org/package/recursion-schemes-5.0.3/docs/Data-Functor-Foldable.html before today
01:50:14 <Saulzar_> ab9rf, Punch cards are more effective at input, too..
01:50:17 <ab9rf> mreh: a lot of the time, syntax highlighers make it harder for me to read the code, especially if they choose colors that i have trouble perceiving
01:50:31 <ab9rf> hey, use what you like :)
01:51:22 <Gurkenglas-> https://github.com/wireapp/wire-server/pull/417 <- the CLA says "Wire may publicly disclose your participation in the project", though. Thoughts?
01:54:42 <ab9rf> Gurkenglas-: of course it will publicly disclose your participation, if nothing else by the fact that you will be listed as the contributing author in the published git repository
01:56:14 <ab9rf> Gurkenglas-: in addition, in order to enforce their rights under this agreement, they may need to disclose that you agreed to it to an appropriate tribunal, and such disclosure may be, by law, public
01:56:30 <ab9rf> Gurkenglas-: i suspect that that warning is required to comply with EU privacy laws
01:56:31 <Gurkenglas-> ab9rf: The CLA makes it sound like the Full Name I put in there will be used. raphaelrobert makes it sound like the information won't be used at all. The obviously fine solution is that they just say Gurkenglas, but who is reasonable these days? ...
01:56:57 <ab9rf> Gurkenglas-: they may have to use your legal name in such a disclosure
01:57:21 <ab9rf> Gurkenglas-: specifically in the case of being required to disclose your consent to a regulatory entity or a tribunal
01:58:00 <Gurkenglas-> It is hard to believe that I can't relinquish all rights to what I write while staying pseudonymous.
01:58:35 <ab9rf> Gurkenglas-: i believe France is responsible for that particular aspect of copyright law
01:58:59 <Gurkenglas-> Does this mean they can't use the Bitcoin protocol because Satoshi never said who he is?
01:59:25 <ab9rf> the French insisted on certain aspects of author's rights being inalienable, and that means that there is no such thing as "public domain" under most EU copyright law
02:00:41 <ab9rf> you have certain rights as an author (so-called "moral rights") which you cannot contract away
02:01:32 <ab9rf> since moral rights are inalienable, it is not possible to fully relinquish all of your rights in something you author, even if you want to
02:03:13 <ab9rf> anyhow, you should request a clarification of the meaning of that provision of this agreement, and if you are not satisfied with the clarification, not agree to it
02:06:29 <Gurkenglas-> How does one say that? '"Wire may publicly disclose your participation in the project" sounds worrying in that regard. Can I have a legal gurantee that I will stay pseudonymous?'
02:06:51 <ab9rf> Gurkenglas-: there is no magical way to request a clarification.
02:07:28 <ab9rf> Gurkenglas-: in theory, you could offer them an "agreement with reservations", but they would be entitled to interpret that as nonacceptance
02:07:46 <Gurkenglas-> Yea I was thinking that the CLA should provide an option for that
02:08:01 <ab9rf> Gurkenglas-: i don't really want this to turn into an internet seminar on offer-and-acceptance as it applies to copyright licensing
02:08:17 <ab9rf> it's wildly off-topic for this channel, for one
02:08:29 <tdammers> I wonder whether you could legally grant a license to works you hold the copyright for under a pseudonym
02:09:13 <ab9rf> tdammers: in the US, yes. europe, possibly not.
02:09:33 <Gurkenglas-> (But it would seem to miss the point to say my name and then tell them I agree if they agree not to pass it on - they could just reject and pass it on)
02:09:57 <Gurkenglas-> Do they have to be in America for this to work, or can we just say we're doing this under US rules?
02:10:16 <ab9rf> Gurkenglas-: the agreement explicitly states that it's governed by Swiss law for people who are not in the US
02:10:42 <tdammers> I believe that under GDPR at least, if you tell someone their name under the condition that they do not share it with others, and they end up sharing it anyway, that would be a violation
02:11:24 <ab9rf> tdammers: that seems likely, but i have very little understanding of the GDPR.
02:12:52 <ab9rf> my legal training was US-based :)
02:36:06 <Gurkenglas-> I wonder whether you could write unsafeInterleaveIO for arbitrary monads, so orM would just be fmap or . traverse unsafeInterleaveM
02:43:05 <mniip> Gurkenglas-, Either
02:44:56 <tdammers> ab9rf: AFAICT, the most interesting part about GDPR is how much of it is going to be enforced, and how the details will be interpreted
02:49:44 <ab9rf> tdammers: hehe
02:50:19 <ab9rf> tdammers: most of what i know about GDPR is through my wife, who works for a multinational law firm
02:53:42 <zincy> Is there a lens or prism for getting the value of the nth data constructor say. Lets say I want a terse way to the value of age from msg when   Data Msg = Msg Person Age
02:55:01 <cocreature> zincy: https://github.com/kcsongor/generic-lens#by-position
02:56:20 <zincy> thanks!
02:57:56 <zincy> Quite a lot of extensions required .. feels weird is this the best way?
02:58:16 <cocreature> I would just define the lens myself in most cases
03:00:47 <ab9rf> zincy: lens is weird in most cases :)
03:05:40 <mniip> hmm
03:07:14 <Putonlalla> Did you ever manage to carry out the party trick of changing a thunk from another part of a program, mniip?
03:08:00 <mniip> that ought to be doable with enough GHC.Prim
03:08:13 <Gurkenglas-> Is there some way in which I can improvise blogposts without having to switch tabs/copy queries/answers for ghci/lambdabot queries?
03:09:00 <Putonlalla> @google ihaskell notebook
03:09:01 <lambdabot> https://github.com/gibiansky/IHaskell
03:09:04 <Putonlalla> Like this, Gurkenglas-?
03:11:02 <mniip> oh my
03:11:09 <mniip> there's instance KnownNat n => Typeable n
03:11:13 <mniip> how long has this been around
03:13:56 <ph88> can anyone help me solve this type error? https://bpaste.net/show/a3d82bd3ba64 (error is at the bottom)
03:16:43 <monoidal> mniip: at least since around 7.11 https://ghc.haskell.org/trac/ghc/ticket/10348
03:17:24 <mniip> this is amazing
03:26:07 <Gurkenglas-> ph88: playTurns wants m to have a RandomSource m (Gen RealWorld) instance, ghc complains that it doesn't
03:26:50 <Gurkenglas-> ph88: Did you expect the 517-519 do block to be in the (ReaderT Env IO) monad?
03:29:17 <Gurkenglas-> ph88: Assuming yes.
03:29:34 <Gurkenglas-> http://hackage.haskell.org/package/random-source-0.3.0.6/docs/Data-Random-Internal-Source.html#t:RandomSource does not in fact lift its instances through the common monad transformers
03:31:23 <Gurkenglas-> "instance (MonadTrans t, Monad m) => RandomSource (t m) s" does not find any package that provides such orphan instances. You could write the orphan instances, or swap RandomSource with MonadIO in order to use liftIO each time you want to get something random
03:32:01 <Gurkenglas-> https://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random-Class.html#t:MonadRandom lifts its instances, so you could switch to that library
03:32:22 <mniip> monoidal, that means I can write ingenious stuff like
03:34:08 <ph88> Gurkenglas-, what's "lift it's instances" ?
03:35:00 <Gurkenglas-> ph88: The MonadRandom library has "MonadRandom m => MonadRandom (ReaderT r m)". Want more explanation?
03:35:28 <mniip> hrm
03:35:32 <mniip> maybe it doesn't let me write that
03:35:44 <mniip> but basically
03:35:54 <mniip> you can replace the unsafeCoerce in typelits induction with cast
03:36:38 <Gurkenglas-> Putonlalla: No Windows support :(
03:37:05 <Gurkenglas-> Or did I misread and there's a web interface?
03:37:53 <Gurkenglas-> That "blog improv" didn't go like I expected. https://gist.github.com/Gurkenglas/49e0cddc6d98107471b9f5dfa9e36551
03:40:35 <ph88> Gurkenglas-, what do you think is the better approach? write orphan instances or swap RandomSource with MonadIO and then use liftIO ?
03:42:28 <Gurkenglas-> Both are worse than switching packages, but I'd guess if I had to choose I'd write the ReaderT orphan since you use so many random values
03:42:54 <mniip> Gurkenglas-, come think on this with me instead
03:43:23 <Gurkenglas-> (wait you might not. Ah well just replace the since with if)
03:43:45 <Gurkenglas-> mniip, okay let me try to get into this type-level value nonsense
03:43:45 <mniip> writing typelits induction using Typeable wants a proof that Dict (KnownNat n) -> Dict (KnownNat (n + 1))
03:43:59 <mniip> but that proof might be possible... by induction
03:44:06 <mniip> can we interleave them
03:44:22 <Gurkenglas-> Define interleave, please.
03:44:39 <mniip> mutual recursion in a way that both terminate
03:45:04 <Gurkenglas-> You want to implement "Dict (KnownNat n) -> Dict (KnownNat (n + 1))" and another type (which?) by recursing on each other
03:45:05 <mniip> or a single function fullfilling both functions
03:45:18 <mniip> induction is something like
03:45:35 <mniip> forall n. (forall k. p k -> p (k + 1)) -> p 0 -> p n
03:45:49 <mniip> of course, you want a KnownNat n and KnownNat k
03:46:01 <Gurkenglas-> You are defining induction. Is that an answer to one of my questions?
03:46:12 <mniip> yes
03:46:20 <Gurkenglas-> Which?
03:46:28 <mniip> "which?"
03:47:11 <Gurkenglas-> You want to implement "Dict (KnownNat n) -> Dict (KnownNat (n + 1))" and "forall n. (forall k. p k -> p (k + 1)) -> p 0 -> p n" by recursing on each other. What is p?
03:47:22 <mniip> forall (p :: Nat -> *)
03:47:45 <mniip> "recursing on each other" might be the wrong word
03:48:03 <Gurkenglas-> I think that is weaker in Haskell than in Coq. Does this give us more power over it in Haskell?
03:48:16 <Gurkenglas-> that = Nat -> *
03:48:28 <mniip> "weaker"?
03:48:54 <Gurkenglas-> I can have p map i to, say, i -> [i], right?
03:48:59 <Gurkenglas-> *can't ._.
03:49:12 <mniip> that'd be ill-kinded
03:49:14 <Gurkenglas-> While in Coq that's first-class
03:49:26 <Gurkenglas-> as in first-class citizenship
03:49:40 <mniip> p can't be a type function if that's what you're asking
03:49:50 <mniip> but that doesn't change anything actually
03:49:51 <Gurkenglas-> So does every (p :: Nat -> *) being well-kinded give us some power?
03:50:14 <mniip> ?
03:50:19 <mniip> I don't understand the question
03:50:58 <Gurkenglas-> Among the sets that have a 0 and a sucessor function, knowing we're looking at the smallest would give us the power of induction
03:51:10 <Gurkenglas-> The weaker a system, the better we can talk about it
03:51:37 <mniip> I'm not talking about philosophical mumbo jumbo here
03:52:03 <Gurkenglas-> No matter, I was trying to get you to give me tools I can use to implement the two you want implemented
03:52:27 <mniip> well, the trick is, as discussed
03:52:31 <mniip> is that Nat is now Typeable
03:52:49 <mniip> and you can coerce between different Nat-kinded types with 'cast' or 'gcast'
03:52:51 <mniip> or 'eqT'
03:53:42 <mniip> of course, different means that the typechecker doesn't know they're the same. the same semantics of 'cast' returning Nothing if they are really 2 different types applies
03:53:51 <Gurkenglas-> It appears that if we had both "Dict (KnownNat n) -> Dict (KnownNat (n + 1))" and "forall n. (forall k. p k -> p (k + 1)) -> p 0 -> p n" we would have "forall n. Dict (KnownNat n)"
03:54:13 <mniip> hence the induction principle cannot be so general
03:54:56 <Gurkenglas-> "(forall k. p k -> p (k + 1)) -> p 0 -> (forall n. KnownNat n => p n)" sounds more doable
03:56:25 <mniip> forall k. KnownNat k =>
03:56:39 <Gurkenglas-> Yes, that should be enough
03:56:47 <Gurkenglas-> "[cast, gcast] :: [forall (a :: Nat), (b :: Nat). a -> b]", yes?
03:57:03 <Gurkenglas-> (eqT:)
03:57:10 <mniip> ?
03:57:12 <mniip> :t cast
03:57:14 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
03:57:15 <mniip> :t gcast
03:57:16 <lambdabot> forall k (a :: k) (b :: k) (c :: k -> *). (Typeable b, Typeable a) => c a -> Maybe (c b)
03:57:58 <Gurkenglas-> "<mniip> and you can coerce between different Nat-kinded types with 'cast' or 'gcast' <mniip> or 'eqT'" I am rephrasing things you say with formal terms so you can say whether I did that correctly
03:58:19 <Gurkenglas-> Because if I rephrased it without formal terms you may merely think I understood
03:59:06 <Gurkenglas-> What is a Nat-kinded type, then?
03:59:48 <mniip> anything parameterized by Nat
03:59:56 <Gurkenglas-> Define parametrized.
04:00:42 <mniip> a tycon with Nat in its kind
04:01:25 <Gurkenglas-> Any type whose kind, when printed as a string, contains the "Nat" substring?
04:01:45 <mniip> what is wrong with you today
04:02:07 <ph88> Gurkenglas-, i was using RandomSource because package random-fu needs it. Do you think there is another package that let's me randomly pick an item from a list ?
04:02:09 <Gurkenglas-> The lines you say contain words I do not know.
04:02:17 <Gurkenglas-> I have to keep guessing and verifying.
04:03:03 <mniip> Gurkenglas-, you know how kinds are defined by a grammar, right?
04:03:05 <Gurkenglas-> "eqT :: (KnownNat a, KnownNat b) => a -> b -> Bool" sounds like it gives us all the power of "KnownNat n => Typeable n", right?
04:03:17 <mniip> that's not what eqT is
04:03:26 <mniip> :t eqT
04:03:27 <lambdabot> forall k (a :: k) (b :: k). (Typeable b, Typeable a) => Maybe (a :~: b)
04:03:53 <Gurkenglas-> Ah, that is probably a thing that actually equates a with b once you put it in scope
04:04:08 <mniip> once you pattern match on it
04:04:30 <Gurkenglas-> Which is how we can actually "write more proofs" if we have it. This gives us all the power of "KnownNat n => Typeable n" you were excited about, right?
04:05:24 <Gurkenglas-> ph88: I got that put in there :D https://hackage.haskell.org/package/MonadRandom-0.4.1/docs/Control-Monad-Random.html#v:uniform
04:07:41 <Gurkenglas-> mniip, as a necessary condition for implementing the two by mutual recursion, at least one must be implementable if the other is. Is that so?
04:10:06 * hackage hriemann 0.2.2.0 - Initial project template from stack  http://hackage.haskell.org/package/hriemann-0.2.2.0 (shmish111)
04:10:35 <Gurkenglas-> mniip, 10-minute-ago me doesn't know kinds are defined by a grammar in those words.
04:11:21 <Gurkenglas-> He would guess that they are defined like types.
04:12:00 <Gurkenglas-> Wait, do you mean the concept of kinds or each new kind?
04:13:25 <Gurkenglas-> mniip, feel free to say you want to abort the conversation because I am less helpful than you hoped.
04:14:24 <mniip> sorry I just need to sleep
04:14:41 <Gurkenglas-> 'kay, continue tomorrow
04:29:05 <Gurkenglas-> Could setting one parameter of a duplicate finder to the AST of base produce a linter that produces suggestions like "use traverse_ here"?
04:47:36 * hackage funflow 1.3.0 - Workflows with arrows  http://hackage.haskell.org/package/funflow-1.3.0 (nclarke)
04:54:06 <ocharles> hey jml, any luck with prometheus /proc stuff?
05:07:06 * hackage hi 1.2.0.2 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-1.2.0.2 (DaisukeFujimura)
05:12:36 * hackage url-decoders 0.2.1 - Decoders for URL-encoding (aka Percent-encoding)  http://hackage.haskell.org/package/url-decoders-0.2.1 (NikitaVolkov)
05:41:03 <GnomeX> hello
05:41:08 <GnomeX> suuuuup
05:42:05 <Eduard_Munteanu> Hi.
05:42:24 <GnomeX> yo
05:42:27 <GnomeX> finally
05:42:55 <GnomeX> has just installed bitchx, iedk how to 2use it correctly
05:43:22 <GnomeX> is somebody using bitchx?
05:43:31 <GnomeX> sup mpereira
05:43:38 <cocreature> GnomeX: this channel is about the Haskell programming language, not random conversations :)
05:43:48 <GnomeX> ik, I'm a developer
05:44:03 <Ferdirand> GnomeX: it was a cool client about 20 years ago
05:44:26 <GnomeX> i read that this server is for every developer (any programming language) in news.ycombinator.com
05:45:05 <GnomeX> im Python, php, js, java developer, not haskell
05:45:21 <Eduard_Munteanu> There are channels specifically for those languages.
05:45:22 <xsperry> so what made you join #haskell, and not #otherlanguage?
05:45:30 <cocreature> this server maybe but this channel is specific to Haskell
05:45:37 <GnomeX> cuz i read some post about this channel
05:45:46 <lxpnh98> Have you tried finding a more specialized IRC channel, like #bitchx (although that has very few people in it)?
05:45:47 <GnomeX> it said this channel is for every language
05:45:51 <yushyin> try ##programming
05:45:52 <GnomeX> i got it
05:46:06 <Eduard_Munteanu> No, not really.
05:46:51 * xsperry not sure if he just get trolled
05:47:10 <lxpnh98> How very unwelcoming of us.
05:47:15 <ecmuller> I think it might be something lost in translation
05:48:02 <ecmuller> Likely an article broadly about freenode but using #haskell as an example
05:49:00 <Saulzar_> How did anyone get away with calling their program 'bitchx'?
05:49:20 <Ferdirand> Saulzar_: it was more than 20 years ago
05:49:26 <ecmuller> The early days of the internet were less politically correct
05:49:33 <Saulzar_> Yeah..
05:50:00 <dstolfa> BitchX is not a bad client actually
05:50:11 <ecmuller> It usually wasn't some brand conscious corporation, but rather a group of weird edgy hackers
05:51:04 <ecmuller> Winamp really whips the llamas ass
05:51:08 <ecmuller> for example
05:52:14 <lxpnh98> Hey guys, totally related to Haskell, I'm constructing a new font, it's called n-wordFont!
05:56:24 <neverkas> Hi
06:06:51 <Gurkenglas-> "Progress 194/205: apply-refact-0.5.0.0, brittany-0.11.0.0, cabal-helper-0.8.0.4, haskell-lsp-0.5.0.0, hlint-2.1.8, hoogle-5.0.17.3" means stack is building many packages in parallel, right? This is eating a lot of RAM. Can I limit the RAM available to it without restarting the install?
06:06:58 <dminuoso> I have some text and I want to basically do the equivalent of matching /Using interface (\w+)/ against it to extract the interface name. Is there a simple quick way to do this without regex?
06:07:02 <Gurkenglas-> (or failing that with restarting)
06:07:38 <cocreature> dminuoso: why do you want to do it without regex?
06:07:56 <dminuoso> cocreature: because I dont want to add such a dependency just for a single line of code..
06:08:08 <dminuoso> cocreature: I mean I dont mind doing it if there's no elegant solution without it
06:09:02 <cocreature> depends on what other packages you are already depend on. you could throw a parser combinator lib at it but a) I don’t think it’s prettier and b) it’s probably going to be slower (at least if you take the easy solution)
06:09:38 <dminuoso> Luckily the output is not much and it's only going to run every second..
06:09:45 <cocreature> ah I guess you could use text’s breakOnAll
06:09:59 <cocreature> and then combine that with some takeWhile isAlpha
06:10:15 <cocreature> well I guess isAlpha is probably not equivalent to \w but you get the idea :)
06:10:32 <dminuoso> Oh yeah that works well enough. I can make it work thanks =)
06:11:40 <cocreature> and it should be pretty fast, iirc that uses a boyer-more string search
06:33:06 * hackage funflow 1.3.1 - Workflows with arrows  http://hackage.haskell.org/package/funflow-1.3.1 (nclarke)
06:35:42 <Sap4> part
06:40:32 <dminuoso> cocreature: by the way I noticed something interesting (but annoying) with cabal-plan
06:41:33 <dminuoso> So Im building a docker container in this one project and I use cabal-plan to extract. Sadly cabal-plan needs to be build with the exe flag, a fact that I cant specify in the cabal file..
06:44:15 <dminuoso> Which means that build process is not in my ~/.cabal/store
06:44:26 <dminuoso> Not quite sure whether cacing my entire ~/.cabal directory is safe
06:45:50 <cocreature> I don’t see how caching all of ~/.cabal will help. if it doesn’t end up in ~/.cabal/store it should end up in dist-newstyle not somewhere else in ~/.cabal
06:46:48 <dminuoso> cocreature: oh yeah if I install it locally with new-install, I was thinking about building it with just `cabal install cabal-plan -f exe`
06:48:38 <cocreature> dminuoso: hm are you sure it ends up in dist-newstyle and not in ~/.cabal/store? I don’t recall new-build building packages from hackage inplace just because you change flags
07:07:37 <Gurkenglas-> Trying to use VS Code with haskell-ide-engine. None of the features on https://marketplace.visualstudio.com/items?itemName=alanz.vscode-hie-server seem to work, but I'm getting no errors about haskell-ide-engine. How should I troubleshoot this? The settings relevant to hie seem to exist, so it's probably not that I failed to install everything related to haskell-ide-engine.
07:11:39 <Gurkenglas-> Ooh, https://image.ibb.co/nHmVG8/weirdtypeinfo.png shows something that may help a savvy person find what's wrong.
07:13:53 <Gurkenglas-> Opening a new file and switching it to .hs doesn't even show me the context menu entries hie makes available
07:15:56 <Gurkenglas-> Anyone with Teamviewer and good with this sort of thing wanna take a look?
07:18:53 <bodisiw> Gurkenglas-, sometimes i restart VSCode and then hie works well again
07:19:36 <Gurkenglas-> bodisiw: restarted, no change
07:20:55 <bodisiw> you can also open the output tab (View > Output) then switch from 'Tasks' to 'Haskell HIE' and you'll see any errors it's having
07:21:45 <zincy_> Is <<loop>> an infinite loop?
07:22:42 <bodisiw> zincy_, it is... but i guess it's usually a 'referential' loop
07:23:05 <zincy_> What is a referential loop
07:23:39 <bodisiw> evaluation loop i mean
07:23:43 <dminuoso> zincy_: x = x + 1
07:23:55 <bodisiw> dminuoso helped me through that recently
07:24:43 <zincy_> ah
07:24:50 <dminuoso> zincy_: The RTS has a simple mechanism to detect certain kinds of evaluation loops that can't compute a sensible value. The <<loop>> exception is triggered when the evaluation of some term relies on itself.
07:25:11 <dminuoso> It can't catch all cases however.
07:25:12 <zincy_> Thanks good explanation
07:25:24 <zincy_> Now to find where the self referential expression is
07:25:39 <zincy_> Is there any easy way of doing this?
07:25:41 <dminuoso> zincy_: If you compile with profiling and run with +xc you should get a stack trace
07:25:57 <dminuoso> err +RTS -xc
07:26:09 <ClaudiusMaximus> try -Wall too, maybe you didn't use something that you wanted to
07:29:50 <exarkun> I've got a big algebraic data type with a lot of record fields.  I made a `minimalFoo` instance that sets many default field values and then made a bunch more instances derived from that, overriding some defaults and setting the rest of the fields.  This gives me a compiler warning that `minimalFoo` doesn't have all fields initialized.
07:29:59 <exarkun> Is there a more compiler-friendly pattern for this sort of thing?
07:30:59 <dminuoso> exarkun: data-default?
07:31:47 <dminuoso> exarkun: though.. did you purposefully left some fields to bottom?
07:33:08 <geekosaur> you can explicitly set those fields to undefined, and it won't warn becauseyou did it deliberately
07:33:29 <geekosaur> the warning is for when you extend a record and forget to fix all uses; and that will still work here
07:33:35 <exarkun> data-default's docs are ... limited.  I left the fields to bottom in `minimalFoo` because there's no sensible default value for them.  Everything that's bottom in `minimalFoo` got a real value in some other instance that actually gets used.
07:34:12 <geekosaur> well, ypu still don;t get warned in the "derived" initializers, but you wouldn't in the other case either
07:34:31 <exarkun> oh. just explicitly set them to ... `undefined`?
07:34:47 <geekosaur> yes
07:35:20 <geekosaur> or error "no value for whatever" for a better diagnostic if you do miss
07:36:23 <exarkun> cool, seems like an improvement over what I have, thanks
07:36:24 <geekosaur> (errorWithStackTrace is also a thought here)
07:37:35 <geekosaur> although that probably induces HasCallstack constraints on users
07:55:15 <dminuoso> With cabal new-build, is there a way to depend on a package on github/local directory?
07:56:46 <cocreature> dminuoso: local directory: yes, just add it to the packages section in your cabal.project file. github: yes if you’re using a recent HEAD version, no for the latest release
07:56:52 <cocreature> and I don’t remember the syntax
07:58:34 <chetan> What's the best library that you use for hostname resolution? I need to find all hosts behind a hostname
08:00:13 <dminuoso> chetan: resolv perhaps?
08:02:24 <ZeuPiark> hello
08:04:55 <glguy> dminuoso: there's a section about new-build in the online manual
08:21:27 <infandum> Is it possible to tell stack which g++ version to use?
08:22:14 <infandum> I'm trying to install eigen on Ubuntu 16.04 and I'm getting a lot of C++ errors, so I assume it needs a newer version, but I don't want to change the default system gcc or g++.
08:22:36 <infandum> I tried --with-gcc /usr/bin/gcc-8 but that didn't work, I assume because it wants g++.
08:23:37 <cocreature> infandum: try the -pgmc GHC option, e.g., https://github.com/llvm-hs/llvm-hs/blob/llvm-6/.travis.yml#L76
08:28:19 <zincy_> how to you build one particular executable with profiling but not another
08:28:30 <zincy_> well not all the executables in the pkg
08:59:28 <rkrishnan> I am playing with conduit and saw something interesting that I couldn't explain: runConduitRes $ sourceFile "/tmp/foobar" .| takeC 1024 .| sinkFile "/tmp/foobarnew"
08:59:54 <rkrishnan> this copies foobar to foobarnew entirely. Not just 1024 bytes.
09:00:31 <rkrishnan> whereas runConduit (yieldMany [1..20] .| takeC 5 .| sinkList) is only [1,2,3,4,5]
09:01:01 <rkrishnan> looking at the sources of take in Conduit module, I am unable to explain why it is so..
09:05:25 * geekosaur wonders if that's reads/blocks instead of chars. how big a file did you try?
09:07:28 <rkrishnan> geekosaur: I tried a 1MB file.
09:08:13 <rkrishnan> sourceFile yields defaultChunkSize sized chunks (defaultChunkSize is defined in Data.ByteString.Internal.Lazy to be 32*1024 bytes)
09:08:43 <geekosaur> so try a 33MB file
09:13:54 <infandum> cocreature: That unfortunately did not work (maybe I did it wrong) but using symlinks and the $PATH worked.
09:14:27 <rkrishnan> geekosaur: yes, tried. it gets 32 chunks. Thanks.
09:17:10 <rkrishnan> geekosaur: or rather 1024 chunks, each chunk being 32k bytes.
09:33:45 <dfeuer> edwardk: a rather ambitious Haskell beginner is running into a bit of trouble with `ad`. Perhaps you can help. https://stackoverflow.com/questions/51560542/haskell-ad-module-difficulties-with-mode-typeclass
09:50:46 <Gurkenglas> You can't use $ on the side of an infix operator. How could one attack this?
09:53:49 <Gurkenglas> certainly the solution shouldn't lose the power of seeing "= foo $" and knowing that the value must have form "foo _".
09:56:12 <Gurkenglas> Does some editor highlight explicit recursion?
09:56:28 <geekosaur> Gurkenglas, that's a section, it needs parens
09:57:06 * hackage highlight-versions 0.1.4 - Highlight package versions which differ from the latestversion on Hackage  http://hackage.haskell.org/package/highlight-versions-0.1.4 (BrentYorgey)
09:57:58 <Gurkenglas> geekosaur, you mean (foo $)? no, I meant an expression starting with foo $
10:12:38 <nshepperd> Gurkenglas: you mean you want to be able to do that, but with a different operator than $?
10:14:17 <nshepperd> if you see a line starting with "x = (foo+) $" you know that x is of form 'foo + _'
10:14:19 <Gurkenglas> For example, yes. How hard would it be to get more than 10 precedence levels, or perhaps a more powerful precedence relation?
10:15:36 * hackage hriemann 0.3.0.0 - Initial project template from stack  http://hackage.haskell.org/package/hriemann-0.3.0.0 (shmish111)
10:16:49 <Gurkenglas> One solution I think I would like is a variant on $ which has minimum precedence to the right and maximum to the left
10:21:30 <Gurkenglas> ie a preprocessing step which turns a string "code1 § code2" into "code1 (code2)".
10:23:42 <Gurkenglas> I could write a String -> String that does such preprocessing on .hs files. Is there support for custom language extensions?
10:25:11 <geekosaur> source plugins, as of ghc 8.6. (plugins are a bitmore limited in earlier versions)
10:25:29 <geekosaur> there's also -pgmF which I think things like liquid haskell use?
10:28:06 <Gurkenglas> Nice. Is there a guide to writing them?
10:28:49 <Gurkenglas> Is someone writing ArgumentDo with them!? :DD
10:41:54 <Gurkenglas> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html#compiler-plugins looks right except it's for 8.4.3, what should I use?
10:42:59 <Gurkenglas> Coz I don't see a docs folder for 8.6
10:43:37 <Gurkenglas> Oh there's one for the alpha1
10:44:33 <Gurkenglas> ...no guide tho
10:45:56 <Gurkenglas> https://downloads.haskell.org/~ghc/master/users-guide/8.6.1-notes.html doesn't seem to say anything about no plugins
10:49:20 <Akii> so what about bang patterns.. do I just spam these by default or only after I have a memory leak?
10:50:07 <johnw> never spam them by default
10:50:11 <johnw> they can make some problems worse
10:51:11 <Akii> might need to clarify: the thing people put into their record types
10:51:37 <Akii> it's called "strictness declaration" apparently
10:51:39 <cocreature> even if you have a space leak, you shouldn’t spam them. learn to understand how Haskell evaluation works and place them where they are required
10:52:30 <Akii> I have no actual problem right now, just random question that popped up
10:52:53 <Akii> sometimes I see code that just seem to have them everywhere by default
10:55:05 <cocreature> for records that just bundle up a bunch of primitive values (~ things of pointer size) it can make sense to add strictness annotations
10:55:27 <cocreature> once you start building up more complex, in particular recursive types you want to be cautious with doing that
10:57:02 <Akii> they only evaluate one thunk though, right?
10:57:26 <Akii> recursive would then obviously evaluate all
10:59:06 <Akii> haha I do however have a massive performance problem.. probably totally not related to the 300+ SQL queries I make for each request, nooo never xD
10:59:45 <cocreature> I’d say it’s more helpful to think of them as providing an invariant rather than thinking of them as evaluating something. in particular, if you add a strictness annotation for a field it guarantees that if the value is whnf, the field with the annotation will also be in whnf
11:01:17 <Akii> I'll keep that in mind, thanks!
11:01:59 <Akii> (whoops, did I say 300+ queries? it's 600+ against a sqlite db, what could possibly go wrong lol)
11:02:18 <cocreature> obviously the problem must be a space leak and not those 600 queries :)
11:02:37 <Akii> obviously
11:03:07 <Akii> the fun fact is that I can easily keep the whole db in memory; I just use it for persistence
11:03:21 <Akii> trivial to implement a cache
11:03:37 <Akii> that'll be a fine task for tomorrow
11:08:24 <Akii> but it's fun to see haskell serving 2 requests the second where I'm used to like 3k
11:09:04 <Akii> handmade, artisanal 2 requests mind you!
11:19:11 <Gurkenglas-_> Consider a program and all the n places where we could insert a bang. We get 2^n possible programs, the image of a function 2^n -> Programs. Evaluating time/space usage gives us functions 2^n -> Time and 2^n -> Space. Are both these functions linear in each boolean argument? If so, can we use this to statistically determine where best to place bangs?
11:21:39 * geekosaur smells a halting problem?
11:21:49 <mnoonan_> why would they be linear?
11:22:35 <Gurkenglas-_> Because it only impacts how much you evaluate, not when... oh, laziness. Huh, wtf brain?
11:22:48 <Gurkenglas-_> Also I meant to say when, not how much there
11:22:55 <Gurkenglas-_> wait thats not it either
11:22:59 <Welkin> it's the pickle man!
11:23:52 <Welkin> Solenya! o.o
11:24:25 <Gurkenglas-_> Scaling down my current competence estimation of myself o.O proceeding anyway: What I had cached for some imcomprehensible reason was that they were a time/space tradeoff that is unequally slanted in each case
11:25:29 <cocreature> Gurkenglas-_: sounds like you might be interested in https://dl.acm.org/citation.cfm?id=2976009
11:26:03 <Gurkenglas-_> Welkin, what do you think of the fix (traverse unFix >=>) [ana runService1 initState1, ana runService2 initState2, ana runService3 initState3] I arrived at yesterday? You seemed sceptical of the work-in-progress that came before
11:27:54 <Gurkenglas-_> But it's nothing to do with a halting problem, geekosaur. If it were linear, you just run the program on the test cases with a few selections of bangs and quickly converge to the optimum
11:29:00 <geekosaur> right up until one of them turns out to finish in finite time without a strictness annotation and try to evaluate to the end of an infinite list with
11:30:03 <Gurkenglas-_> That's fine since the long-running finite computations are not interesting when you are looking for the optimum
11:30:41 <__monty__> Gurkenglas-_: Only if you can guarantee it won't happen for all inputs though.
11:30:55 <Welkin> __monty__: python?
11:31:04 <__monty__> <3
11:31:23 <__monty__> Only the second person to get it btw.
11:31:40 <Welkin> the "monty" and the double underscores gave it away
11:32:02 <__monty__> Yeah, but the outer underscores render as just an underline in some clients.
11:32:19 <Gurkenglas-_> Yes, I suppose "Program" in the OP didn't consider that there might be harbringers of uncertainty such as user input :D
11:32:53 <Gurkenglas-_> What guide should I be following for these 8.6 plugins?
11:32:55 <iqubic> __monty__: I love that so much. I love Monty Python
11:32:56 <__monty__> It's harbingers, they *need* their netflix ; )
11:33:19 <Welkin> harbinger of doom
11:33:29 <Welkin> that is the only context I have heard harbinger used
11:34:07 <__monty__> iqubic: Me too, I figured I was being clever. But I was either too clever or just dumb. I prefer too assume the former : )
11:35:08 <edwardk> cancelling the twitch stream i had planned for today. there are a bunch of folks doing construction right outside my office window.
11:35:26 <geekosaur> harbinger of spring
11:35:45 <geekosaur> which knocked me out of the national spelling bee once (well, also about half of those remaining.)
11:36:54 <__monty__> Etymology of harbinger is actually pretty interesting.
11:37:28 <edwardk> i just figured you were a huge fan of the full monty
11:38:26 <__monty__> Oo, didn't know I was in the presence of a comedy connoisseur ; )
11:42:11 <__monty__> Too bad about the construction but 32°C is too much to pay attention to coding streams anyway. (Now I'm shutting up because I have nothing to add to the conversation, #haskell-offtopic can use the extra traffic : )
11:43:04 <Welkin> construction?
11:44:33 <__monty__> Welkin: edwardk's comment up there ^
11:48:21 <Akii> lel I think my cache is working; from 1 req/s to 128 req/s
11:48:43 <cocreature> that’s a nice speedup :)
11:50:17 <Akii> 180*
11:50:24 <Akii> yeah no magic, just all in ram
11:50:44 <__monty__> Big-O says that's no speedup at all : >
11:50:45 <Akii> the really interesting thing is that I made nearly no changes to the code
11:51:20 <Akii> https://github.com/Akii/elescore/commit/2d973070eaf7720a77db4e62e9e6700b38b0d7b4#diff-7c21771eb8283afe12b427d69a1ec7b7R47
11:51:37 <Akii> that kinda worked out nicely
11:55:04 <Welkin> Big O was such a cool tv show
11:55:43 <__monty__> Sounds lewd ^^
11:56:00 <Welkin> it's giant robots and android maids!
11:57:43 <__monty__> I tried to get my mind out of the gutter but that definitely made it worse.
12:20:53 <michaelsdunn1> Has anyone read Haskell Programming From First Principles? I'm trying to determine if I should recommend it to newcomers.
12:21:02 <shapr> It's good
12:21:07 <michaelsdunn1> Or if I should stick with Real World Haskell and learnyou
12:21:13 <shapr> @where cis194
12:21:13 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
12:21:26 <shapr> I also like byorgey's cis194 lesson
12:22:03 <shapr> michaelsdunn1: RWH and learnyou are old, many things have changed. But I know lots of people who have successfully learned from them recently.
12:22:50 <michaelsdunn1> Yeah, I learned from those maybe 3? years ago.
12:22:59 <michaelsdunn1> Thanks for the cis194 link. Looks great!
12:25:14 <shapr> michaelsdunn1: any other questions?
12:25:53 <michaelsdunn1> not atm
12:26:37 * shapr finds michaelsdunn1's github account
12:26:47 <shapr> michaelsdunn1: oh, are you using haskell with docker/kubernetes?
12:27:29 <Welkin> o.o
12:27:39 <michaelsdunn1> no
12:27:42 <Welkin> are you crazy?
12:27:55 <shapr> Welkin: huh?
12:28:08 <shapr> lots of people using haskell with docker/kubernetes
12:28:40 <Welkin> I don't get the whole container fad
12:28:54 <shapr> Welkin: it's a useful convention
12:42:16 <nineonine> greetings haskellers
12:42:20 <nineonine> I have a quick question
12:42:31 <nineonine> suppose I have a do block with the following code
12:42:43 <nineonine> a <- getFromConfig “a” config
12:42:46 <nineonine> b <- getFromConfig “b” config
12:42:51 <nineonine> c <- getFromConfig “c” config
12:43:04 <nineonine> and I have around 15 of those bindings
12:43:41 <nineonine> if I create a partial function getFromC = flip getFromConfig and then use it everywhere
12:43:52 <nineonine> would I benefit from it ?
12:43:55 <dredozubov_> no
12:44:34 <geekosaur> depends. I could see [a,b,c,d] <- mapM (`getFromConfig` config) ["a", "b", "c", "d"] -- or similar. but not clear this is a win
12:44:35 <dredozubov_> Is there a way to get a heap profile from an application that do not respond to SIGINT anymore?
12:44:55 <Welkin> you would be better of doing something like `mapM (flip $ getFromConfig config) ["a", "b", ...]`
12:45:25 <nineonine> it looks like the only thing I am getting from this rewrite is less lines of code, is this correct ?
12:45:34 <geekosaur> pretty much, yes
12:45:43 <geekosaur> not clear what you're looking for, though
12:46:11 <nineonine> I was thinking about sharing
12:46:52 <fishythe_> Welkin: minus the $
12:47:07 <Welkin> yes, you are right
12:47:40 <nineonine> I thought when I create this partually applied getConfig with config applied, other call sites would use this function
12:47:46 <fishythefish> people have different tastes on whether it's better to use infix (via backticks) + section or flip
12:48:11 <nineonine> and I am not creating any extra stack allocations ? I am not an expert here, correct me if I am wrong please
12:48:14 <Welkin> there are no function calls
12:48:17 <Welkin> there is no stack either
12:48:38 <Welkin> it's just expressions, like in algebra
12:48:48 <nineonine> oh ok
12:52:14 <nineonine> so If I think about my program as a graph, when I create this partially applied function, all the call sites will use this one node, does it make the program run faster or does it reduce the amount of work ghc has to do ?
13:07:10 <c_wraith> nineonine, it might be better, it might be worse. it might even be exactly the same. there are a lot of details that affect it.
13:07:57 <nineonine> I was hoping to get to know about these details :)
13:09:20 <c_wraith> evaluation pattern, memory pressure, exact form of the partially-applied function. some of it is ghc specific, some is not.
13:09:47 <c_wraith> there are too many factors to just list them one by one.
13:10:25 <c_wraith> it's much better to start with a concrete example and consider how various modifications will affect it
13:10:32 <Boarders> can creating a funciton as a definition get GHC to improve performance?
13:10:45 <Boarders> I can understand the other way around (i.e. inlining)
13:11:11 <fragamus> In ghci I declare an instance on one line and then the required function after, but it complains after the first line.  What’s a better way?
13:11:23 <fishythefish> multiline input
13:11:32 <fishythefish> or just use semicolons
13:11:41 <Welkin> or just write it in a file
13:11:52 <Welkin> ghci isn't for writing programs
13:12:10 <nineonine> @c_wraith I appreciate!
13:12:10 <lambdabot> Unknown command, try @list
13:12:15 <nineonine> @list
13:12:16 <lambdabot> What module?  Try @listmodules for some ideas.
13:14:39 <dataN> is it not possible to return a value of type (forall a. fa)?
13:14:50 <dataN> (forall a. f a)*
13:15:17 <Boarders> what is f?
13:15:24 <Welkin> Functor most likely
13:15:27 <cocreature> :t Proxy
13:15:28 <lambdabot> forall k (t :: k). Proxy t
13:15:54 <cocreature> f = Proxy and you have forall a. f a
13:15:58 <Boarders> is f a particular functor or quantifying over all funtors
13:16:24 <Boarders> f = Const () then you can write down something of type forall a . f a
13:16:28 <dataN> :t ([] :: forall a. [a])
13:16:29 <johnw> if f can be anything for which 'a' is a phantom type, then it exists
13:16:29 <lambdabot> [a]
13:16:33 <c_wraith> Boarders, I think I could probably construct a case where extracting a function makes it perform better than leaving it inclined, but it would be something weird and unnatural if I managed it.
13:16:56 <Boarders> c_wraith: interesting, what is the intuition there?
13:17:14 <johnw> Boarders: cache locality
13:17:23 <dataN> :t let id' = (id :: (forall a. f a) -> (forall a. f a)) in id'
13:17:24 <lambdabot> forall k (f :: k -> *) (a :: k). (forall (a1 :: k). f a1) -> f a
13:17:26 <cocreature> LLVM even has an outlining pass that tries to do exactly that
13:17:37 <johnw> too much inlining can cause paging in of code blocks to push out other blocks that will be used immediately after
13:17:48 <johnw> whereas having multiple functions might fit all the functions into the cache, and then you just jump aruond
13:17:49 <c_wraith> Boarders, my thought is some expression that selects a function based on a complex calculation, where the complex calculation didn't get floated for some reason.
13:18:17 <c_wraith> also, yeah, code size issues are also a thing.
13:19:17 <Boarders> ah ok, makes sense
13:21:30 <johnw> I wonder if anyone truly understands how modern processors execute code, and so what arrangement will be fastest for a particular program
13:21:34 <fragamus> I still get warnings in ghci declaring instance with semicolon
13:21:58 <iqubic> Can we see the code you are running, and what errors are produced?
13:22:04 <fragamus> I guess multline is the only way
13:22:15 <Boarders> if I write down: (forall a. (Num a) => a -> a) or more sensibly (forall a. (CommRing a) => a -> a) then the latter is a polynomial (I believe) which is to do with the fact that the free CommRing on one var is Z[x]
13:22:31 <geekosaur> if you are doing an instance with a memthod, you'd also need brackets since you can't use layout on a single line
13:22:53 <Boarders> are there any papers which study this sort of thing?
13:22:54 <geekosaur> but I'd have to see what exactly you're trying to do to be certain (likewise everyone else probably)
13:23:48 <nshepperd1> fragamus: instance Foo Bar where { method1 = ...; method2 = ... }
13:24:12 <glguy> You can skip the {} if you want and just go with ;, too
13:24:40 <Boarders> a more exotic example I came across is: forall a b f. (Functor f) => (f a -> f b) ~ forall a b. a -> b
13:25:53 <Boarders> which is again just something about the free functor
13:26:22 <Gurkenglas> In a big github Haskell project (ghc), if it says "import Plugins", how do I find that module's source?
13:29:07 <johnw> do a search for the file Plugins on github?
13:31:37 <dataN> if a class demands a function is defined over forall a => f a, it does not seem possible to return such a type; https://lpaste.net/6299745703493107712
13:33:52 * hackage vty 5.23 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.23 (JonathanDaugherty)
13:34:30 <dataN> is that possible to solve?
13:34:54 <Gurkenglas> Ah, the file must be named Plugins.hs, thanks.
13:35:31 <rotaerk> dataN, `t -> (forall a. f a)` is equivalent to `forall a. t -> f a`
13:36:36 <byorgey> dataN: I think you have t1 and t2 backwards in the type of f
13:36:39 <nshepperd1> dataN: it means that a is a phantom type argument of f
13:37:26 <shapr> johnw: cache oblivious data structures?
13:37:32 <nshepperd1> Unless t is a polymorphic f a wrapped in a newtype or something
13:38:39 <johnw> shapr: well, I was thinking of just overly-aggressive inlining
13:38:41 <byorgey> dataN: f  says it takes a t1, then you would need to be able to convert t1 to type  (forall a. f2 a)  to run 'g' on it, but neither  X f1 t1  nor  Y f2 t2  give you that ability
13:38:46 <shapr> johnw: ok, agreed
13:38:57 <johnw> I know that if I turn on inlining everywhere in my Haskell programs, performance can suffer up to several times
13:39:18 <dataN> heres a paste with those types corrected; https://lpaste.net/5309997677272891392
13:41:05 <dataN> so it cant be solved?
13:42:05 <byorgey> dataN: I think what's happening is that it can't infer polymorphic types for the type arguments of (.)
13:42:24 <byorgey> dataN: if you instead write    f g t1 = toX (g (fromY t1))  ,  it works
13:42:35 <dataN> oh wow, awesome, thanks
13:42:39 <byorgey> you could probably also use (.) if you put some inline type annotations
13:43:27 <dataN> ok, wait until you see it in use, brb
13:46:48 <nshepperd1> Oh yeah, (.) won't work with rank 2 things
13:47:02 <nshepperd1> That requires impredicative polymorphism
13:54:23 <dataN> oh, should it use proxies as well?
14:03:58 <ChaiTRex> Are there any examples of people benchmarking alternative implementations of a function at compile time with Template Haskell to select the faster one?
14:04:37 <c_wraith> I haven't seen anything like that.
14:05:01 <c_wraith> it would be really expensive for something that would change so infrequently.
14:12:52 <ChaiTRex> c_wraith: Ahh, OK. Thanks.
14:14:38 <Lears> I haven't seen it in Haskell, but I know some ML frameworks can do it (e.g. theano) and it is worth it in that context, since the compile-time test is seconds where the training might be hours.
14:16:23 <c_wraith> yeah, part of my assertion related specifically to how slow template haskell is to compile.
14:16:47 <blair__> Hey folks, quick question. I want to read a large text file and basically slide a window over a very small portion of it. What tools should I look at for doing this effieciently? (There are lots of modules like Lazy strings, lazy bytestrings, Data.Text, etc. Not sure which one I aught to be using)
14:17:35 <johnw> blair__: probaby lazy text, it will give you an Xk  * 2 allocation, I think, since your window might span two of its windows
14:18:29 <blair__> Perfect. So this guy? https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Lazy.html
14:18:56 <johnw> yep
14:19:19 <blair__> Sweet deal. Thanks!
14:19:55 <johnw> careful, though, since the wrong use of laziness might cause you to retain past blocks longer than you'd expect; be sure to profile to ensure that you're running in constant space
14:24:04 <blair__> For sure
14:28:23 <ab9rf> heh, ran into that once :)
14:29:10 <ab9rf> blair__: i've had good luck using conduit for applications like that
14:33:48 <deech> Is bumping a GHC Trac ticket that hasn't been looked at for a while frowned upon?
14:41:18 <marxS> hey, so I wrote this. Not entirely sure as to why it doesn't work: https://paste.ofcode.org/edWUpgc3M4mLkRhFUeGBqj
14:41:48 <marxS> if a has an instance of monoid class, then surely mappend x y is defined in each of the definitions
14:44:52 <marxS> hmm https://paste.ofcode.org/36jyHAxgmsetFjzUiqv4CFR maybe this? but still doesn't work
14:47:59 <ab9rf> what errors are you getting?
14:47:59 <ddellacosta> marxS: I was able to get it defined without much trouble but I started with semigroup--what version of GHC are you using?
14:48:14 <ddellacosta> and yeah, what errors...? ^
14:48:44 <marxS> error here: https://paste.ofcode.org/CcEuuA9eLywjGGAqE3bCcj
14:49:00 <marxS> The Glorious Glasgow Haskell Compilation System, version 8.4.3
14:49:24 <ab9rf> ooh, occurs check!
14:49:34 <marxS> I don't actually know what semigroups are yet (the textbook hasn't covered them) so it seems weird that they would be needed for this. Unless it's to do with an update to the compiler?
14:49:37 <ddellacosta> marxS: https://lpaste.net/7948464591934062592
14:50:04 <ddellacosta> yeah, there was a point at which semigroup became a superclass of monoid
14:50:26 <ab9rf> no, it's because you are equivocating
14:50:31 <monoidal> marxS: you cannot pattern match on "mempty" - you can match on constructors (like Just) but not values
14:50:43 <ddellacosta> ah sorry, didn't look at their errors
14:51:03 <monoidal> marxS: it's treated as mappend (Only x) y = Only $ mappend x y which is a type error
14:51:33 <ab9rf> your prior attempt, with pattern matching on Nada, is permissible
14:51:35 <marxS> so i'd have to do what i had initially mappend (Only x) (Nada) = Only $ mappend x mempty ?
14:51:46 <ab9rf> marxS: what errors do you get on that version?
14:52:23 <marxS> https://paste.ofcode.org/LBAUn6B6DYGDtisXNGPdNh
14:52:26 <ab9rf> oh, that's why it occurs-checked.
14:52:27 <marxS> could not deduce semi group
14:52:36 <marxS> arising from superclasses
14:52:49 <monoidal> marxS: in new GHC, the hierarchy is more fine grained and you need to declare that a type is a semigroup if it's a monoid
14:52:59 <ab9rf> it bound mempty to the second argument, and then occurs-checked when that argument was used in a manner inconsistent with its inferred type
14:53:08 <marxS> ah ok, might make sense once I learn semi groups in haskell context lol
14:53:14 <ab9rf> marxS: paste the error, plz
14:53:19 <ab9rf> not here, in a pastebin
14:53:26 <marxS> ab9rf, I did https://paste.ofcode.org/LBAUn6B6DYGDtisXNGPdNh
14:53:34 <ab9rf> ah
14:53:40 <monoidal> marxS: instance Semigroup Yourtype where (<>) = mappend should work
14:53:48 <ddellacosta> yeah, that's the part I jumped ahead to
14:54:22 <marxS> so this is the book I'm using to learn: http://haskellbook.com/
14:54:27 <marxS> was just wondering if much has changed since this?
14:54:38 <marxS> or if it's just small stuff like the semigroup thing here
14:55:35 <ddellacosta> I suspect there isn't a ton like that if you're going through that book
14:55:44 <ddellacosta> I think the semigroup thing was fairly recent?
14:56:50 <marxS> ok cool, thanks for the help
14:56:53 <ab9rf> you can't make something that isn't an instane of Semigroup an instance of Monoid, since base 4.9.0.0 i think
14:57:42 <ab9rf> -- __NOTE__: 'Semigroup' is a superclass of 'Monoid' since /base-4.11.0.0/.
14:57:48 <ab9rf> sorry, 4.11
14:58:53 <ddellacosta> which I guess corresponds to GHC 8.4.1?
14:58:55 <ddellacosta> https://ghc.haskell.org/trac/ghc/blog/ghc-8.4.1-released
14:59:18 <ab9rf> ddellacosta: it would appear
14:59:23 <ddellacosta> phase 2 being the step of making semigroup a superclass of monoid, per https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid
15:13:16 <ZeuPiark> hello
15:13:55 <marxS> this book isn't even great to be honest
15:14:24 <marxS> I mean it's good, but probably for beginners. But it's explaining the properties of these different algebraic structures from fundamentals
15:15:02 <ddellacosta> marxS: haha...there are other books to check out if you don't find it to your liking--I'm a big fan of Graham Hutton's Programming in Haskell http://www.cs.nott.ac.uk/~pszgmh/pih.html
15:15:32 <ddellacosta> but regardless, I think it's good to have a number of resources--I've never found that a single one is enough to help me grasp every concept I've come across in Haskell
15:15:34 <marxS> yeah haha ddellacosta that's what my galois theory prof recommended
15:15:40 <ddellacosta> heh
15:15:42 <marxS> might give it a look
15:16:39 <ddellacosta> ZeuPiark: hello
15:18:49 <marxS> i just want to hit the minimal knowledge level as to where I can start playing with different libraries
15:18:54 <marxS> and then learn from there
15:19:57 <ddellacosta> fwiw I think different libraries have different demands--like containers is relatively easy if you're familiar with data structures in other languages, whereas lens takes some getting used to, or recursion-schemes...and each one can be its own little adventure
15:20:37 <hjt> is there a good tutorial for lenses ? they're not in LYAHFGG
15:21:20 <ddellacosta> I can't speak to that as I don't think I've really grasped them yet myself, and I haven't found any single resource that has helped me...yet
15:21:50 <dataN> ok, not sure if this compiles because of copy paste to the gist, but the example is the use of the function recode to recursively redefine a constraint on line 121 right at the end; https://gist.github.com/dataN-hs/18caf53bb6c97ef9a29e663e1e61baf8
15:22:00 <ddellacosta> all that aside, I do think it's worth digging into this at some point, at least: https://github.com/ekmett/lens/wiki
15:22:35 <ddellacosta> the overview is useful for getting a surface-level grasp of how to use it, but I find it's not enough to really _get_ it
15:22:53 <ddellacosta> the derivation is more useful there
15:23:12 <hjt> hmm will have a read
15:23:17 <hjt> no idea what they even are at the moment
15:24:05 <dataN> most of the definitions are at the end of Lib.Using2.hs
15:24:14 <marxS> kmett's lens library?
15:26:57 <black0range> Hello, using typelits and all that how would i for example retrieve the value of a passed natural number from type?
15:27:55 <glguy> black0range: I don't understand the question. Could you elaborate on what you're trying to do?
15:28:11 <dataN> the idea is that while e.g. list only has one value of type forall a. [a], other "shaped empty containers" such as Free [] can be built by navigating a 'Zipper (Free (Zipper [])) a'  where these navigational arguments would take the place of Int in this example. the theorem is that *all* containers are isomorphic to this
15:29:38 <black0range> glguy: like this psuedo haskell :) https://lpaste.net/3337109706895261696
15:29:54 <zincy_> How do I bimap over a list of tuples?  (join . bimap (show )) <$> [(1,2), (1,2)]
15:30:28 <dataN> the machinery presented here allows a constraint to be edited locally. e.g. Sum could be redefined as Mult.
15:30:32 <glguy> black0range: You'll use 'natVal :: KnownNat n => proxy n -> Integer' with a suitable proxy value
15:30:42 <pavonia> :t bimap
15:30:43 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
15:31:02 <glguy> suitableProxy :: Sometype n a -> Proxy n; suitableProxy _ = Proxy
15:31:09 <hjt> :t join
15:31:11 <lambdabot> Monad m => m (m a) -> m a
15:31:16 <black0range> zincy_: map (bimap show show) [(1,2)]
15:31:17 <black0range>  
15:31:28 <pavonia> > (join bimap show) <$> [(1,2), (1,2)]
15:31:31 <lambdabot>  [("1","2"),("1","2")]
15:32:00 <glguy> > join bimap show <$> [(1,2), (1,2)]
15:32:03 <lambdabot>  [("1","2"),("1","2")]
15:32:09 <glguy> Look at all the savings!
15:32:28 <iqubic> What is the point of the Proxy Datatype?
15:32:30 <glguy> > over each show <$> [(1,2), (1,2)]
15:32:33 <lambdabot>  [("1","2"),("1","2")]
15:32:38 <hjt> :t over
15:32:39 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
15:32:51 <zincy_> Perfect thanks everyone
15:32:56 <glguy> > over each show <$> [(1,2,3), (1,2,4)]
15:32:58 <lambdabot>  [("1","2","3"),("1","2","4")]
15:33:21 <hjt> never seen 'over' before
15:33:31 <hjt> even the type signature looks confusing
15:34:10 <dataN> iqubic: if a type cannot be inferred a proxy type allows it to be specified.
15:34:15 <black0range> glguy: Thanks!
15:34:25 <iqubic> over takes a lens, a function, and a piece of data and applies the function to the targets of the lens.
15:34:42 <hjt> ah, really need to learn about lenses first then
15:35:38 <iqubic> in glguy's example 'over' applied 'show' to every target of the 'each' lens
15:35:50 <hjt> :t each
15:35:51 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
15:36:11 <iqubic> The type signatures of lenses are really confusing at first.
15:36:16 <hjt> yes....
15:36:28 <iqubic> It only really gets better with experience.
15:36:39 <xsperry> > over each (*10) (10,20)
15:36:41 <lambdabot>  (100,200)
15:36:44 <xsperry> > over each (*10) (10,20,30)
15:36:44 <black0range> hjt: https://github.com/ekmett/lens/ That tutorial is descent :)
15:36:46 <lambdabot>  (100,200,300)
15:37:03 <dataN> are there any examples of COnstraints being used as Functors anywhere?
15:38:24 <hjt> black0range: thanks, will have a read
15:38:49 <black0range> hjt: Oh and ignore that first image
15:39:21 <dataN> also, in the gist, there seems to be something like a continuation monad being formed for the constraint continuations... cant quite get it though...
15:40:28 <hjt> are lenses something that exist in category theory?
15:40:32 <hjt> with a different name
15:42:16 <black0range> hjt: I think there are some fancy way to look at it. But from a practial perspective it allows you to "Focus" on datatypes in data using some generic expressions
15:43:03 <black0range> hjt: Or rather focus on what the data contains, Such that set the value nth element of a tuple to x
15:45:45 <dataN> incase its invisible; https://gist.github.com/dataN-hs/18caf53bb6c97ef9a29e663e1e61baf8
15:45:56 <xsperry> > over (each._1) (*10) ((1,2),(3,4))
15:45:58 <lambdabot>  ((10,2),(30,4))
15:46:05 <xsperry> > over (_1.each) (*10) ((1,2),(3,4))
15:46:07 <lambdabot>  ((10,20),(3,4))
15:47:15 <hjt> so they're like an easier way to 'modify' data ?
15:47:54 <xsperry> they are getters and setters on steroids
15:48:18 <xsperry> same lens can both get and set a value
15:48:52 <ZeuPiark> bye
15:49:42 <xsperry> and they are composable with regular . function from Prelude
15:50:03 <hjt> what kind of scenario would you want to use them in?
15:50:13 <Gurkenglas-> git clone --recursive ghc/ghc gets lotsa failed: https://gist.github.com/Gurkenglas/d48dccc939e5f64fa9e87741bab43dec
15:50:37 <xsperry> hjt for easily setting and getting values in deeply nested data structures
15:50:50 <hjt> ok, i see
15:50:56 <hjt> not something i've come across yet
15:51:17 <xsperry> that is what I use them for anyway, but I don't know a fraction of their capabilities
15:51:23 <xsperry> I know*
16:05:29 <ancarda> Can I have a function that has this type: `Num a => a -> Integer`? I have a type, `type Nanoseconds = Integer` and I want a function, seconds that does `seconds sec = (sec * 1000000000) :: Nanoseconds`
16:05:39 <ancarda> I'm having a load of trouble getting this one to work :(
16:06:47 <geekosaur> not generally, and if you could that wouldn't be the way to do it
16:08:04 <ancarda> Why?
16:08:06 <glguy> ancarda: Type synonyms aren't for documentation. If you want Nanoseconds to be distinct to get some type safety you can make a newtype
16:08:13 <ab9rf> osm
16:08:16 <ab9rf> gawrqwqjdpioqj
16:08:23 <glguy> cats are the worst
16:08:24 <ab9rf> ancarda: isn't that just toInteger?
16:08:38 <ab9rf> glguy: finger spasm, i don't even have a cat
16:08:46 <ancarda> I would like to use this for both `seconds 1` and `seconds 0.5`, so I can't use `toInteger` I think
16:09:09 <ancarda> glguy: Sorry, I'm not following...?
16:09:16 <ab9rf> yeah, i'm with glguy here
16:09:21 <ab9rf> this isn't a type synonym
16:09:35 <ab9rf> you need a full-fledged type
16:09:45 <geekosaur> and toInteger is for Integral, not Num
16:09:54 <ab9rf> geekosaur: indeed
16:10:17 <ab9rf> you want something to abstractly represent times
16:10:42 <ab9rf> like, maybe, Data.Time
16:10:59 <Rembane> ancarda: Is it important for you to implement the time types yourself, or can you use a library?
16:11:24 <ab9rf> DiffTime (in Data.Time.Clock) can be used to represent arbitrary time intervals
16:11:33 <glguy> Maybe: nanoseconds x = truncate (1000000000 * x)
16:11:50 <glguy> if we're implementing the original thing and not talking about using newtypes
16:11:57 <ancarda> Rembane: This is a learning exercise, so yeah I need to implement this myself
16:12:03 <Rembane> ancarda: Cool.
16:12:30 <ab9rf> this reminds me about how UTC time calculations cannot be pure
16:12:46 <ab9rf> because you need to check to see if there have been any new leap seconds declared since your program was compiled
16:13:39 <Rembane> Time is so ugly imo
16:13:42 <fredefox> ab9rf: Is that the difference between `DiffTime` and `NominalDiffTime`
16:13:46 <ab9rf> fredefox: i think so
16:13:52 <fredefox> cool
16:14:41 <ab9rf> DiffTime is implemented as pure, but it does so at the risk of being wrong: the leap second table may be incomplete
16:15:55 <ab9rf> and it appears that UTC actually simply ingores leap seconds
16:16:27 <Rembane> The UTC standard or the UTC implementation in Haskell?
16:19:04 <ancarda> geekosaur: When you say it's not possible in general, what do you mean?
16:19:46 <geekosaur> no function that produces an Integer from any Num instance.
16:20:09 <Zipheir> ab9rf: Does that mean it's impossible to do strictly-correct UTC calculations without doing some kind of IO, e.g. contacting a timeserver?
16:20:15 <Wizek> geekosaur: is that because we don't have such a function in the Num class definition?
16:20:16 <fishythefish> (constant functions)
16:20:54 <geekosaur> Wizek, more or less yes. nor anything that could reasonably used to create one
16:20:58 <fredefox> Well, not *any* 'Num' instance, but if you have 'Integral' then you have 'toInteger :: a -> Integer'
16:21:14 <geekosaur> (I am considering undefined or const 0 unreasonable here
16:21:15 <Wizek> geekosaur: but in theory it could exist if we modified the class definition, no?
16:21:19 <ancarda> geekosaur: So, would it be possible to create one? Or perhaps, would it be possible to have a solution -- both `1` and `0.5` as inputs, multiplied by 1 billion
16:21:24 <Wizek> geekosaur: me too
16:21:54 <Rembane> geekosaur: So const 0 isn't a reasonable function? :)
16:22:08 <ancarda> Someone mentioned making a new type, would that be a better direction?
16:22:13 <geekosaur> for the intended purpose...
16:22:24 <geekosaur> ancarda, no, that doesn;t actually help here
16:22:59 <Rembane> ^^
16:27:48 <glguy> ancarda: what I wrote above with truncate was the answer
16:28:18 <Wizek> glguy: I've tried that, doesn't seem to work with Int input
16:28:58 <glguy> Int stops being a valid input
16:29:11 <glguy> If you want to take fractional arguments
16:29:50 <Wizek> glguy: I think ancarda wants a solution that can take e.g. either Float or Int, and gives a back a multiplied Integer
16:31:37 <ancarda> Yeah, so like this:
16:31:40 <ancarda> seconds 1   = 1000000000
16:31:41 <ancarda> seconds 0.5 = 500000000
16:31:51 <glguy> yeah, 1 in that case is fine
16:32:01 <glguy> it'll default to being a Double in this case
16:32:03 <Wizek> glguy: but only because of overloading
16:32:07 <glguy> yup
16:32:10 <hjt> :t negociate
16:32:11 <lambdabot> error: Variable not in scope: negociate
16:32:21 <hjt> :t negotiate
16:32:22 <lambdabot> error: Variable not in scope: negotiate
16:32:45 <Wizek> glguy: ancarda will have very confused why `seconds (1 :: Int)` won't work when the argument is no longer an overloaded constant
16:32:54 <Wizek> will get*
16:32:56 <glguy> nanoseconds x = truncate (realToFrac x * 1e12 :: Double) -- works, too, but it's not necessary
16:33:05 <koz_> How would you use :~: from Data.Typeable? I'm having a bit of trouble understanding what it's for.
16:33:37 <glguy> Wizek: OK, then it will be time to learn how to convert Int's to other types.
16:34:42 <ancarda> glguy: I tried that last function (the one using `realToFrac`), but I'm getting some GHC errors :(
16:34:51 <glguy> ancarda: I can't see your screen
16:34:58 <fredefox> paste  'em
16:35:06 <ancarda> Did that compile for you?
16:36:33 <Wizek> ancarda: it actually works for me: `(\x -> truncate (realToFrac x * 1e12 :: Double)) (1 :: Int)`
16:36:35 <dmwit> :t \x -> truncate (realToFrac x * 1e12 :: Double)
16:36:36 <lambdabot> (Real a, Integral b) => a -> b
16:36:52 <dmwit> ?instances Real
16:36:54 <lambdabot> (Data.Fixed.Fixed a), (Shrink2 a), Blind a, Const a b, Double, Float, Identity a, Int, Int16, Int32, Int64, Int8, Integer, Large a, Ratio a, Small a, Sym a, Word, Word16, Word32, Word64, Word8
16:37:08 <Wizek> huh, that ?instances is nice
16:37:13 <Wizek> ?instances Num
16:37:15 <lambdabot> (Data.Fixed.Fixed a), (Shrink2 a), Blind a, Complex a, Const a b, Double, Float, Identity a, Int, Int16, Int32, Int64, Int8, Integer, Interval a, Large a, Product a, Ratio a, Small a, Sum a, Sym a,
16:37:16 <lambdabot> Word, Word16, Word32, Word64, Word8
16:37:58 <ancarda> :t realToFrac
16:38:00 <lambdabot> (Fractional b, Real a) => a -> b
16:38:21 <fredefox> Does lambdabot remember declarations?
16:40:05 <ancarda> Oh, that's working, thank you glguy!
16:40:52 <dmwit> fredefox: Yes, if they are declared with ?let; and only until the next ?undefine.
16:41:01 <marxS> for the infix operator a :| [a] , it says it guarantees we have one value of type a
16:41:07 <fredefox> Cool
16:41:15 <marxS> i dont understand what this means and google isn't returning much due to bad parsing of non alphanumeric chars
16:41:39 <fredefox> ?let nanoseconds x = truncate (realToFrac x * 1e12 :: Double)
16:41:39 <dmwit> marxS: I suppose the actual definition is `data Foo a = a :| [a]`.
16:41:40 <lambdabot>  Defined.
16:42:07 <marxS> dmwit, i dont know what :| does/means though lol
16:42:18 <fredefox> Does lambdabot evaluate stuff as well
16:42:27 <dmwit> marxS: Then what it means is that, to build a value of type `Foo a`, you must call `(:|)` with a value of type `a` as its first argument, and so there must be at least one value of type `a` inside every `Foo a`.
16:42:38 <glguy> > 'a' NonEmpty.:| []
16:42:40 <lambdabot>  'a' :| ""
16:42:47 <marxS> ah
16:42:50 <marxS> I see, thanks
16:42:52 <fredefox> > nanoseconds 0.000004
16:42:54 <lambdabot>  error:
16:42:55 <lambdabot>      Variable not in scope: nanoseconds :: Double -> t
16:42:56 <dmwit> marxS: It is defined by the declaration `data Foo a = a :| [a]`. It doesn't have any meaning on its own until that data declaration appears.
16:43:06 <marxS> yeah I see
16:43:11 <dmwit> marxS: Then, it is the sole data constructor for `Foo a`.
16:43:19 <marxS> I thought it meant something before that definition lol
17:04:01 <koz_> Do I need to import anything to write 'type MyConstraint = (Eq a, IsFlyingMonster a)'-style aliases?
17:04:54 <geekosaur> no imports but ConstraintKinds extension may be needed (ghc will tell you)
17:05:05 <koz_> geekosaur: Thanks!
17:06:58 <fredefox> ConstraintKinds is the ticket indeed
17:13:33 <dmwit> If for some reason that's a goal, you can do it without extensions by making a new class. This will also allow partial application of the "alias".
17:13:53 <koz_> dmwit: Nah, it's just to save me having to spell it out over and over.
17:14:03 <dmwit> As in `class (Eq a, IFM a) => MyConstraint a; isntance (Eq a, IFM a) => MyConstraint a`.
17:14:38 <dmwit> Oops. `isn'tance`, for when you want to demand that a type *not* conform to a class constraint.
17:16:21 * hackage emd 0.1.2.0 - Empirical Mode Decomposition and Hilbert-Huang Transform  http://hackage.haskell.org/package/emd-0.1.2.0 (jle)
17:25:43 <dedgrant_> Hi all, potentially tricky question: is GHC's DuplicateRecordFields a benign feature to ship with a library?
17:26:03 <dedgrant_> (as in distributing library code that depends on this)
17:27:31 <dedgrant_> Looking at some of the open tickets, I'm inclined to think not
17:27:34 <c_wraith> if you export two record types that use the same field name from the same module, the users of that module might also need to enable drf to work with them.
17:27:54 <dedgrant_> Right
17:28:00 <c_wraith> and it's not the most pleasant extension to use.
17:28:00 <ab9rf> dmwit: what do you get from declaring an isn'tance?
17:28:39 <dedgrant_> c_wraith: OK that's useful! Do you have a story you'd be willing to share? (Or link to blog post, etc. for more info?)
17:28:39 <c_wraith> ab9rf, compile errors is an instance is also declared somewhere in the program.
17:28:41 <dmwit> More type errors! That's why we use Haskell, right?
17:28:55 <ab9rf> hehe
17:29:39 <dmwit> DRF certainly isn't popular in libraries. I don't think I've ever seen a library that used it.
17:29:47 <c_wraith> dedgrant_, nothing noteworthy. I've just experimented with it a bit, and been dismayed by how many annotations I had to add because they can't be inferred across anything.
17:30:05 <ab9rf> it would be amusing to me if what it did was throw an error if the type conformed to the class :)
17:30:08 <dedgrant_> OK thanks for the feedback, that's actually quite useful
17:31:52 <suzu> wait, isn'tance is a real thing?
17:31:57 <suzu> wow
17:32:03 <glguy> It isn't
17:32:06 <glguy> (right?)
17:32:15 <suzu> its not
17:32:20 <suzu> k i knew it couldn't be true
17:32:28 <ab9rf> sadly, no
17:32:31 <suzu> typeclass resolution doesn't work like that!
17:32:32 <suzu> :P
17:32:56 <hjt_> anybody here played around with Idris at all?
17:33:03 <milesrout> glguy: hey remember your little irc client using brick
17:33:15 <ab9rf> why would somoene name a language after the guy who played Heimdall, anyway?
17:33:17 * ab9rf runs
17:33:17 <glguy> milesrout: Yes I remember my client; no I don't use brick.
17:33:19 <milesrout> glguy: update vty to 5.23 and you'll have italics
17:33:25 <milesrout> oh sorry, using vty anyway
17:33:38 <glguy> Oh yeah, I'll hook that in :)
17:34:00 <glguy> I'm working on the client right now, better socks5 support
17:34:21 <milesrout> do you use it for your ircing?
17:34:33 <Gurkenglas-> Couldn't you just do "Disn'ct c = Dict c -> Void"?
17:34:41 <glguy> milesrout: yeah, it's the only client I chat with
17:35:54 <Solonarv> you can do something like "instance (TypeError (Text "some custom error")) => Foo Bar"
17:37:51 <dmwit> Gurkenglas-: Yeesh, these typos are getting worse and worse!
17:38:36 <dmwit> glguy: Does it chat back?
17:38:59 <glguy> dmwit: Yeah, there seem to be all sorts of in the client's AI
17:39:05 <glguy> hundreds in a channel called #haskell
17:39:33 <glguy> But you'd know that, you're inside my client!
17:39:48 <Gurkenglas-> yea "instance Bottom => Foo Bar" seems better, maybe with "class Bottom where bottom :: a", with added "instance Bottom where bottom = undefined" world burning
17:40:31 <glguy> milesrout: Know a client that supports italics I can test with?
17:40:32 <dmwit> HAHA, YES I AM TOTALLY SENTIENT LIKE ALL HUMANS
17:40:59 <ab9rf> i question whether most humans are sentient
17:41:48 <milesrout> i use irssi in a tmux window in a terminal without italics support. triply not supporting italics, lol. no idea sorry
17:41:49 <Gurkenglas-> If everyone but me's bots most of me are sentient. i hope
17:42:14 <ab9rf> doesn't wondering if one is sentient make one sentient?
17:43:21 <dmwit> Is sentience useful?
17:46:36 <ab9rf> it may actually be anti-useful
17:59:31 <koz_> I would prefer it if my laptop didn't say 'You know, I can't be bothered loading that web page, I wanna contemplate Plato's Cave.'
17:59:50 <koz_> Or 'Hey, I think your way of trying to run this C program is stupid, here, let me make some suggestions...'
18:19:49 <revskill> In Servant there're two operators :<|> , one at type level, second at term level. How to import those ?
18:20:23 <revskill> When i use import           Servant.API                ((:<|>)), i think it can only import :<|> at term level
18:22:02 <droplet> revskill: Use import Servant.API( type (:<|>) ) to get the type level one
18:22:03 <pavonia> ((:<|>) ((:<|>)))?
18:22:40 <droplet> see the end of section 7.4.4 here https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/data-type-extensions.html
18:23:14 <revskill> droplet: it doesn't work :(
18:24:29 <glguy> How about: import Servant.API ( (:<|>)( (:<|>) ) ) ?
18:24:53 <revskill> pavonia: Thanks, it seems work !
18:25:05 <ab9rf> that looks disturbingly much like line noise
18:25:07 <revskill> glguy: it seems work
18:25:12 <ab9rf> it's giving me sendmail.cf flashbacks
18:26:04 <glguy> Or you can cut it down a little with: import Servant.API ( (:<|>)(..) )
18:26:07 <ab9rf> is there a name for the "(:<|>)" particle? the "fancy chicken"?
18:26:47 * Clint chuckles.
18:27:07 <revskill> glguy: why (..) for type-level ?
18:27:36 * hackage emd 0.1.2.1 - Empirical Mode Decomposition and Hilbert-Huang Transform  http://hackage.haskell.org/package/emd-0.1.2.1 (jle)
18:28:35 <glguy> revskill: When you import TypeCon(..), you import the type TypeCon, and all of its value constructors
18:29:30 <ab9rf> is it all constructors, or just all of those exported by the module?
18:29:47 <glguy> Oh, just the exported ones
18:33:28 <revskill> Should we use a SQL parser + sql quasi quoting or a ORM library for Database access ?
18:35:25 <glguy> milesrout: The easiest italics supporting terminal emulator I could find was to install Fedora in a VM and use gnome-terminal, but it looks great in IRC there :)
18:45:56 <ab9rf> revskill: yes, those sound like ideas that have potential
18:46:18 <ab9rf> revskill: as a long-term DBA, i will state that i have never found an ORM that i like
18:46:33 <ab9rf> every last one of them seems to create bad SQL
18:48:07 <ab9rf> i have the sneaking suspicion that tjhe people who write those ORMs are not familiar with how SQL query planners work
18:49:44 <revskill> one of the things i don't like about sql, is that they're hard to compose
18:50:08 <revskill> With edsl, it's easier to compose things inside a monad
18:50:45 <ab9rf> revskill: it does surprise me that nobody has come up with a DB query interface that doesn't just wrap SQL
18:51:09 <revskill> you mean like LINQ ?
18:51:28 <ab9rf> there are a few vendor-specific interfaces that aren't just wrappers around SQL, but they're normally incapable of expressing everything you can express in SQL itself
18:51:48 <ab9rf> revskill: LINQ is vendor-specific :)
18:52:16 <revskill> ab9rf: yes, i see. Even with ActiveRecord, i have to write complex query in pure sql itself. The library can't express everything.
18:52:39 <ab9rf> also, i think that under the hood LINQ queries will eventually get transformed into SQL DQL
18:52:50 <revskill> vendor specific is annoying, so i think no ORM could replace sql :(
18:53:06 <ab9rf> although if you use LINQ with Azure, you might actually avoid creating a SQL query statement
18:54:02 <revskill> but we want type-level sql :), like servant for web
18:54:18 <ab9rf> yeah, LINQ has an ADO.NET interface option that can in theory operate directly into an ADO.NET exposed dataset, but you can only query against a table or view already defined in the server
18:54:54 <ab9rf> if you want to use an adhoc dataset, you have to use SQL DDL to create a (temporary) view and then access against that view
18:55:53 <ab9rf> revskill: i'm familiar with the issue. :)
18:56:45 <ab9rf> the problem with most of the attempts that i've seen to do type-level sql  is that selection logic tends to take place in the client, rather than the server
18:57:23 <ab9rf> so you end up with queries that could be done with an index seek being done with a table spool instead
18:57:25 <revskill> ab9rf: any example of such api ?
18:57:52 <ab9rf> revskill: it's been a few yeas since i poked around this issue
18:58:02 <ab9rf> it's possible that people are getting better at it
19:00:05 <ab9rf> i've even seen such apis do synthetic joins--spooling two tables from the server to local storage, computing a cartesian product locally, and then excluding rows from the resulting recordset where the keyfields do not match.
19:00:44 <ab9rf> this is because the client is not smart enought to be able to determine if the server can perform the join or not
19:01:08 <revskill> if we use servant-like interface, it's will be like: Select '["email", "name"] From 'User
19:02:44 <ab9rf> as long as you don't take that recordet and use filter to find the one user you care about
19:03:19 <revskill> the generated client will use: selectUser :: Text -> Text -> m [User]
19:03:44 <ab9rf> cuz then you're doing a table spool on the server just to obtain one record, and if the server has an index on your selector field, it really needs to ask for a server-side selection instead doing the filter on the client
19:04:01 <ab9rf> yhou can compltely kill performance with nonsense like that
19:04:30 <ab9rf> "Why is this app spooling the user table 75 times a minute?"
19:05:01 <revskill> what do you mean by spooling ?
19:05:23 <ab9rf> revskill: a table spool is when the server has to retrieve every row of a tableset in order to service a query
19:05:41 <ab9rf> revskill: you want to avoid spools as much as possible. you'd much rather use seeks
19:06:03 <Squarism> If two different constructors have the same arguments. Is there some automagic isomorphism between them?
19:06:41 <geekosaur> Squarism, haskell doesn't do automagic
19:06:42 <ab9rf> there's full scans, partial scans, and seeks
19:06:49 <c_wraith> ab9rf: what vendor's terminology is that?  I'm used to "sequential scan" from postgres
19:06:52 <ab9rf> a full scan has to spool through the entire table and is very expensive
19:07:16 <ab9rf> c_wraith: i think scan is the official term. spooling is what happens after the rowset is built.
19:07:19 <Squarism> geekosaur, wishful thinking of me
19:08:11 <ab9rf> a partial scan will only hit a portion of a rowset because the query palnner was able to use a query constraint to limit the inquiry to a specific subset of the full recordset
19:08:21 <ab9rf> a seek goes to one specific record only
19:09:18 <ab9rf> c_wraith: i am mainly familiar with MSSQL internals. i've not spent much time optimizing postgreql so i don't know how its query planner works.
19:09:40 <ab9rf> although postgres has a pretty good engine
19:09:49 <c_wraith> ab9rf: in rough terms, you like to see the words "index scan" and "hash join" in your query plan. :)
19:10:10 <ab9rf> mysql's query planner used to have the intelligence of a lobotomized chihuahua, but i understand it's gotten somewhat better in recent releases
19:10:27 <koz_> What's a Text-friendly modern and good pretty-printing library?
19:10:28 <ab9rf> c_wraith: yeah, mssql is the same.
19:10:50 <ab9rf> c_wraith: the basic principles of query planning have been more or less the same for decades
19:11:22 <c_wraith> ab9rf: databases keep adding new index types, just to make it exciting.
19:12:40 <ab9rf> c_wraith: MSFT's ability to execute arbitrary .NET code on the server while selecting records also changed a lot in this area
19:15:08 <ab9rf> anyhow, my point is that most ORMs are "too stupid" to understand how to formulate an efficient query; they don't undersand how the DB engine performs queries
19:17:51 <ab9rf> the most common problem is in retrieving more data than you need, and then filtering it in the client, instead of pushing the filtering to the server
19:18:49 <c_wraith> Or not retrieving enough information and making several queries to get all the data you use
19:19:09 <c_wraith> especially the infamous N+1 query case
19:21:36 <ab9rf> c_wraith: iv'e seen ORMs do local joins in which it will spool one table, and then for each row in that table, spool the other table.
19:21:56 <ab9rf> c_wraith: this resuls in the econd table being rretreived over and over again, once for each row in the first table.
19:23:49 <ab9rf> c_wraith: of course, with older versions of mysql you _had_ to do this because mysql and its clientside APIs had performance issues that often made large joins slower than doing a client join....
19:24:08 <ab9rf> i hate databases
19:24:15 <ab9rf> and i've been working with them since 1985
19:34:07 <glguy> milesrout: The italics support turns out to be wrong as far as I can tell
19:36:13 <koz_> Can I pass constraints as arguments to a function?
19:47:36 <suzu> yes
19:48:06 <suzu> koz_: https://hackage.haskell.org/package/constraints-0.8/docs/Data-Constraint.html#t:Dict
19:48:15 <koz_> suzu: Thanks!
19:48:48 <suzu> though you probably only need this if you're doing some type-level shenanigans
19:48:48 <koz_> ... why am I _not_ surprised this was written by Edward?
19:48:57 <suzu> are you doing some type-level shenanigans?
19:49:17 <koz_> suzu: I realized I could avoid them.
19:49:29 <suzu> avoid them by passing a constraint in?
19:49:45 <suzu> what are you working on?
19:49:50 <koz_> suzu: No, I can write different functions which constrain the input using the constraint.
19:50:13 <koz_> So instead of having a general foo, I have 'fooA', 'fooB' and 'fooC', which have different constraints on what the argument they expect should be.
19:50:19 <rotaerk> any idea what the purpose of this line could be?  https://github.com/achirkin/easytensor/blob/master/dimensions/src/Numeric/Dimensions/Dims.hs#L348
19:50:43 <rotaerk> seems to be the constraint that a list of nats is equal to the list produce by consing its head to its tail
19:50:56 <rotaerk> oh.. nm, it just means it's non-empty
19:52:38 <suzu> koz_: oh then "Dict" isn't correct for you
19:52:44 <koz_> suzu: Yeah, I realized that.
19:52:46 <suzu> Dict is a proof that you have satisfied a constraint
19:52:55 <koz_> But nice to know in case I do need type-level shenanigans later.
19:52:56 <suzu> if you want to pass the _constraint_ around, then put it in a Proxy and pass that around
19:53:01 <koz_> Ah, OK.
19:53:11 <suzu> you may need ConstraintKinds enabled
19:53:30 <suzu> actually you certainly need it enabled
19:53:35 <koz_> I already do for some aliasing because a lazy typer.
19:53:38 <suzu> so that Constraint is a kind
19:53:45 <suzu> and constraints themselves are types
19:54:09 <keegans_> what is the recommended way for me to separate my app configuration from my code ?
19:54:18 <keegans_> i was thinking dotenv like there is in Node.js and Ruby, etc.
19:54:35 <koz_> keegans_: Do you want a config file or something?
19:54:45 <suzu> use a config.. file?
19:54:49 <suzu> separate it from the code?
19:54:51 <suzu> ??
19:55:06 <keegans_> suzu: yes, that is what i want, but i'd rather just use a library for it
19:55:15 <rotaerk> keegans_, perhaps read through this http://okmij.org/ftp/Haskell/tr-15-04.pdf
19:55:22 <koz_> keegans_: Then pick a structured format and go?
19:55:32 <rotaerk> a bit of a tangent I guess
19:55:34 <koz_> You can get JSON, YAML and TOML parsing libraries just fine in Haskell.
19:55:41 <koz_> You can even be super-hipster and use Dhall.
19:56:07 <suzu> there's quite a few out there
19:56:09 <suzu> ConfigFile?
19:56:11 <suzu> configurator?
19:56:14 <suzu> app-settings?
19:56:19 <suzu> dhall hipsterness
19:56:36 <koz_> Dhall hipsterness, lol.
19:56:47 <keegans_> well, locally the configuration would be on disk
19:56:58 <koz_> So a file?
19:56:58 <keegans_> but in a production environment you would not package the production configuration with the application bundle
19:57:16 <suzu> why not?
19:57:28 <rotaerk> keegans_, that talks about a way of getting configuration information accessible throughout your program, though it doesn't talk about the problem of how to store/fetch the configuration from a file or anything
19:57:31 <keegans_> because why would i put production secrets in a file inside of my container ?
19:57:39 <rotaerk> I mostly just misunderstood your question ... still neat though
19:57:42 <suzu> what is your production environment?
19:57:44 <keegans_> i'll just read the docs for how to use environment variables
19:57:56 <suzu> kubernetes..? docker?
19:58:01 <keegans_> kubernetes
19:58:29 <suzu> we use k8s in prod with hs
19:58:43 <koz_> What does Kubernetes actually do, in one sentence?
19:58:46 <suzu> we use envy to work with the environment variables
19:58:46 <keegans_> i'm exploring and learning how to use kubernetes for this project
19:58:51 <koz_> I keep hearing it bandied about but I have no idea what it even.
19:58:59 <suzu> envy is a hs package for env vars. its not bad to use
19:59:07 <suzu> http://hackage.haskell.org/package/envy-1.5.0.0/docs/System-Envy.html
19:59:22 <keegans_> it's just an orchestration tool, you write a yml specification for your infrastructure then it can handle healing and deployments and rolling back etc.
19:59:30 <keegans_> it is powered by containerization , docker specifically
19:59:48 <suzu> make a big appsettings record type, give it a default, and envy will do the heavy lifting with stuffing it with values from the env
19:59:48 <keegans_> suzu: that's exactly what i am looking for. thank you
19:59:51 <suzu> np
20:08:27 <blair__> Hey folks, does anyone have any suggestions as to what might be going wrong here?
20:08:28 <blair__> https://gist.github.com/blairdrummond/664d49445a2af03653b775088c35eada
20:09:09 <lyxia> blair__: what is the error
20:09:35 <blair__> I don't know exactly how much the program aught to use, but it crashes my computer, and when I cap it at 400mb it crashes almost immediately
20:09:48 <blair__> I think the program works, it just doesn't scale
20:10:02 <blair__> On a 4Mb input file
20:13:27 <blair__> I was hoping that the lazy text would keep things under control, but something is going wild. It might be the map that I'm using to store the words that is using too much memory. But I'm not very good at this, so it might just be some thunk that I'm not noticing
20:14:58 <suzu> i dont know precisely what your code does but
20:15:04 <suzu> are you going to look at all the values in this map
20:17:27 <suzu> your "increment" function might be too lazy
20:17:52 <suzu> hm wait no i dont that's it
20:18:14 <c_wraith> substrings could be holding on to the whole thing?
20:19:05 <blair__> What it does is it finds common length k sequences in a big text, but I only want to see if there are a lot of them in a little window (and then I only want ones which occur at least t times)
20:19:39 <suzu> hmm.. i see you compute two tuples
20:19:43 <blair__> I think I prevented that. I think the substrings *aught* to add a character on the end and also drop a character at the front
20:19:44 <suzu> maybe those need to be seq'ed
20:19:49 <blair__> They should always be length k
20:20:08 <blair__> Ah!
20:20:13 <blair__> I'll try that
20:20:18 <suzu> 4-tuples and the 2-tuple
20:22:37 <suzu> there is a simpler way to solve your problem altogether though
20:23:04 <suzu> take windows of length l -> filter out words of less than len k -> sort it -> group them and count for >=t
20:24:17 <blair__> Hmm, wow, I guess that will work if its lazy
20:24:54 <blair__> I just finished writing this in golang (it sucked), and threw my thinking out of wack. Maybe I should just try that
20:25:06 <suzu> i am curious as to what is making the space leak here though
20:26:05 <blair__> I will try to add strictness to the tuples. Though, the Map is strict, so they should get computed there actually
20:26:40 <blair__> *I think
20:26:44 <suzu> somewhat
20:26:51 <suzu> that strictness only goes one-level "deep"
20:26:54 <c_wraith> only to WHNF
20:27:09 <suzu> if i call slideInsert strictly, i get (_,_,_,_)
20:27:38 <suzu> if i call increment strictly, i get (Just _) or Nothing
20:28:09 <c_wraith> well.
20:28:19 <c_wraith> T.foldl should be T.foldl'
20:28:51 <blair__> Oh crap, that makes sense
20:28:54 <suzu> oh man lmao
20:28:58 <suzu> yes make your left fold strict
20:29:10 <blair__> Hahahaha
20:29:11 <suzu> otherwise the accumulator piles up to the moon until you look at the value
20:29:13 <blair__> Wow, I goofed
20:29:22 <suzu> left-folds should be banished
20:29:27 <suzu> lazy ones
20:29:30 <suzu> when does anyone ever want that
20:30:15 <c_wraith> there are times when it at least isn't wrong
20:30:22 <c_wraith> like...  reverse = foldl (flip (:))
20:30:44 <suzu> that hurts my brain
20:31:06 <suzu> okay that one makes sense i suppose
20:31:19 <c_wraith> But it's a rare case
20:31:21 <suzu> wait no it doesn't
20:31:26 <suzu> that will still pile thunks to the moon
20:31:41 <c_wraith> Nah, it'll pile (:) constructors
20:31:48 <c_wraith> but that's what reverse has to do anyway
20:31:53 <suzu> foldl f z xs => (f z (f a (f b (f c (f d..
20:32:23 <c_wraith> But (:) is a constructor, so GHC doesn't create a thunk - it just creates the constructor
20:32:29 <suzu> oh TIL
20:32:41 <suzu> i thought constructors were also functions
20:32:45 <suzu> so they are thunkable
20:33:12 <Maxdamantus> is `flip (:)` still a "constructor"?
20:33:13 <c_wraith> it doesn't force evaluation of its arguments
20:33:27 <suzu> but it doesn't consume memory to hold the constructor?
20:33:30 <c_wraith> Maxdamantus: depends on how well the optimizer does its job
20:33:41 <c_wraith> suzu: yes, but reverse isn't lazy no matter what
20:34:10 <c_wraith> reverse *always* has to traverse the entire input list to produce the outermost (:) constructor
20:34:17 <suzu> right
20:34:22 <suzu> okay so it is always strict in the spine
20:34:28 <suzu> that's fine then
20:34:56 <c_wraith> Maxdamantus: you're right, if the optimizer isn't clever, flip (:) will create a thunk
20:35:12 <c_wraith> Maxdamantus: I believe ghc is that clever
20:35:34 <suzu> ghc has always done me a solid
20:35:53 <Maxdamantus> Presumably the benefit of having a constructor there is that a fairly naive implementation can still use a special structure for incomplete constructor invocations.
20:36:01 <blair__> Hmm. Fixing the fold maybe helped a bit, but still isn't great
20:36:02 <blair__> https://gist.github.com/blairdrummond/f7d238bd1f6408f5817b4473cc0ec526
20:36:02 <Maxdamantus> but that probably doesn't apply to `flip (:) x`
20:36:21 <c_wraith> blair__: I'm still suspicious of slideInsert
20:36:23 <Maxdamantus> (and as you said, you'll need a "clever enough" optimiser)
20:36:24 <suzu> ok blair__ time to start spamming bang patterns
20:36:41 <c_wraith> blair__: I suspect it's allowing thunks to build up inside the tuple
20:36:46 <suzu> i had that same though
20:36:48 <suzu> t
20:36:50 <suzu> deepseq that tuple
20:37:34 <suzu> oh hold up
20:37:41 <suzu> blair__ you are using T.snoc
20:38:01 <suzu> snoc is O(n) and makes a copy of the entire text unless fuesd
20:38:03 <suzu> fused
20:38:15 <blair__> Sorry, this is my first time writing haskell in a while, what's the tl;dr on deepseq?
20:38:17 <c_wraith> suzu: T = Data.Text.Lazy
20:38:24 <suzu> yeah doesn't matter
20:38:27 <suzu> stil clones unless fused
20:38:32 <suzu> still *
20:38:47 <c_wraith> oh, right.  snoc does need to.
20:38:58 <c_wraith> cons can be more clever with .Lazy, but snoc can't
20:38:58 <suzu> @hoogle Data.Text.Lazy.snoc
20:38:59 <lambdabot> Data.Text.Lazy snoc :: Text -> Char -> Text
20:39:02 <suzu> hrm
20:39:08 <suzu> ok well it is true
20:40:37 <blair__> Oh, it shouldn't pile up though no? That string shoulld be length 500 or so
20:41:07 <suzu> so when you add a character you will make a new string of len 501
20:41:14 <suzu> and when you add to that, another string of len 502
20:41:19 <suzu> and gg there goes your ram
20:41:31 <blair__> It also should get uncons'd I think
20:41:53 <blair__> Omg I'm a damn idiot
20:42:04 <suzu> it's running in a fold
20:42:09 <suzu> so it's gonna explode here
20:42:14 <blair__> In the fold it should be (slideDrop . slideFold)
20:42:30 <blair__> Err. (slideDrop . slideInsert)
20:44:49 <blair__> I wrote the function then didn't even use it *facepalm*
20:45:44 <blair__> Reassuringly though, the code is still bad
20:46:12 <suzu> still using all your mem?
20:46:14 <blair__> https://gist.github.com/blairdrummond/b657f383824e825ae6fc4f680adc974a
20:46:24 <blair__> Yep
20:47:01 <suzu> oh very nice, we're profiling now like good programmers
20:47:43 <blair__> https://gist.github.com/blairdrummond/a95d66047247c650bde7b7cf1300d8b7
20:47:47 <suzu> so your leak is slideInsert and it's probably that snoc if i had to guess
20:47:57 <blair__> ^ Just an updated version
20:50:36 <suzu> you are making a lot of strings and stuffing them into this map and i think that is making unhappiness
20:51:01 <suzu> i think this is the point where you rewrite your approach, lol
20:51:23 <blair__> Lol, yeah, happily
20:58:44 <blair__> Alright, well thanks for the help folks! I'll do a rewrite
21:15:42 <nfd9001> I'm having newb problems with Cabal--trying to install some stuff, and i'm missing random files in various packages. As are the packages I need to update cabal-install. I figure the best way to solve this (since the setup is a little old) is to just scorch the earth and get everything running freshly?
21:16:08 <glguy> Missing random files? Are you on Arch?
21:16:14 <nfd9001> yep
21:16:35 <glguy> Arch Linux is broken and requires special care which is documented on its wiki
21:16:56 <nfd9001> Awesome, thanks
21:17:04 <glguy> Here we'll recommend you remove anything GHC related you're getting from the arch linux package manager and install things manually without it
21:17:19 <iqubic> Why is Arch different?
21:17:40 <nfd9001> iqubic: i assume the packages they push are wonky? is that what you mean?
21:18:05 <glguy> Their maintainers wanted to get clever with only providing the dynamic libraries for a language where the standard way to do things is with static linking
21:18:26 <nfd9001> which is a little weird
21:18:43 <nfd9001> i actually installed the static package, and i'm still missing files
21:19:00 <nfd9001> arch people really take the minimalism thing seriously, huh
21:19:13 <suzu> arch is doing it "right" but we do it "wrong"
21:19:44 <suzu> linking haskell dynamically is a hellscape
21:20:07 <nfd9001> ah, i see
21:20:33 <nfd9001> to do this the Arch way correctly, you need to install a third package and reconfigure cabal
21:22:17 <suzu> yeah i didnt bother with that
21:22:18 <suzu> fuck arch
21:22:26 <suzu> i installed stack and i do everything with that
21:22:38 <suzu> except for system things like xmonad
21:25:10 <nfd9001> suzu: this entire adventure was caused by me thinking "hmm maybe i should add a launcher to xmonad", hah
21:25:12 <iqubic> Yeah. That's the way to do it.
21:25:48 <iqubic> nfd9001: A launcher for what? Applications? Might as well use dmenu or rofi for that.
21:26:00 <iqubic> Can't be too hard to configure it properly.
21:26:05 <nfd9001> iqubic: yeah, that's the most that i was planning on using
21:26:22 <nfd9001> i also thought "why not set up a toolbar", since i've been rather spoiled on dwm
21:26:42 <iqubic> nfd9001: If you want a tool bar look into xmobar.
21:27:05 <iqubic> It was designed to integrate into xmonad.
21:27:23 <nfd9001> yep, those were the two i was looking at
21:27:59 <nfd9001> of course, everything on my system's apparently broken as hecc because arch
21:28:58 <Arcaelyx> Is there anyone who's admin of this channel?
21:29:28 <nfd9001> glguy: say I want to try to salvage the install here, since i've now read the wiki page and gee wilikers i like my package manager or whatever
21:29:49 <nfd9001> what's the best way to clean up all of those old packages?
21:30:01 <glguy> Arcaelyx: Yeah, there are admins
21:30:18 <glguy> nfd9001: I haven't gone through the process of getting arch to work
21:30:29 <Arcaelyx> I was wondering if it'd be okay to build an IRC bridge from here to the #haskell Discord
21:30:57 <glguy> as long as the bridge doesn't chat  back into this channel it's fine if you want to bridge message from here to discord
21:31:18 <Arcaelyx> That makes it rather pointless if people ask a question on there and it can't be heard here.
21:31:29 <glguy> Yeah, they should just join IRC in that case
21:31:37 <Arcaelyx> Except not everyone is willing to do that
21:31:54 <glguy> If you have more questions about it chat in #haskell-ops
21:32:35 <davidfg414> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
21:32:35 <davidfg414> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
21:32:35 <davidfg414> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
21:45:22 <iqubic> That was swiftly dealt with. Good to see the freenode staff fixing these spammers.
21:45:31 <iqubic> *stopping
21:48:49 <Cheery> Hi, I just read the paper "Polymorphic type inference and abstract data types".
21:49:23 <Cheery> now I'm trying to understand the inference rules for the existential quantifier.
21:51:12 <Cheery> and the problem is that the notation is hard to track.. I think I would understand it if I would manage to apply these rules on a paper.
21:53:06 <nfd9001> glguy: hmm, it actually wasn't too hard to figure out. arch definitely is making some wonky decisions in there, but someone walking in with my issue in the future should probably be able to fix it with the wiki info fairly easily
21:53:19 <nfd9001> just in case you ever see anyone else asking the same thin
21:53:30 <nfd9001> tyty for the tip bub
21:53:34 <Cheery> the paper describes instantiation of a type in syntax that is quite weird to me.. and  the whole thing would propose that existentials should be generalized when they instantiate.
21:53:46 <glguy> nfd9001: glad you got it working :)
21:58:02 <revskill> any shortcut for this: PG <$> M.lookup "dbname" x <*> M.lookup "host" x <*> M.lookup "user" x <*> M.lookup "password" x
21:59:33 <Solonarv> you could write it using liftA4 instead, I suppose
21:59:35 <suzu> you can use do syntax
21:59:36 <Solonarv> :t liftA4
21:59:37 <lambdabot> error:
21:59:37 <lambdabot>     • Variable not in scope: liftA4
21:59:38 <lambdabot>     • Perhaps you meant one of these:
21:59:58 <glguy> revskill: let f n = M.lookup n x in PG <$> f "dbname" <*> f "host" ...
22:00:07 <glguy> I don't think the liftAs go out to 4
22:00:15 <nfd9001> thought they only went to 3
22:00:18 <revskill> passing every map is annoying :(
22:00:20 <Solonarv> er, or not - the way you've written it is pretty much idiomatic
22:00:59 <Solonarv> you could use an alias like: let l k = M.lookup n x in ...
22:01:06 <suzu> yep glguy suggested that
22:01:11 <suzu> i think that's the most you'll get
22:01:46 <nfd9001> y'all are reminding me how nice the idiom bracket notation is
22:02:05 <suzu> bracket notation?
22:02:16 <revskill> cool, thanks guys
22:02:17 <nfd9001> yeah, gimme a sec, there was a pearl about it
22:02:21 <suzu> kk
22:02:24 <revskill> PG <$> f "dbname" <*> f "host" <*> f "user" <*> f "password"
22:02:24 <suzu> also wtf there's a haskell discord?
22:02:29 <suzu> burn it plz
22:02:55 <nfd9001> suzu: http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf iirc
22:03:25 <nfd9001> a <*> b <*> c becomes [[a b c]]
22:03:29 <nfd9001> roughly
22:03:51 <Solonarv> I think there's a source plugin that steals [( ... )] for idiom brackets
22:04:01 <revskill> what's convenient way to compose ReaderT with different environment types ?
22:04:27 <revskill> i need to do manual lifting: lift (runReaderT anotherComputation anotherEnv)
22:04:37 * hackage typerep-map 0.2.0 - Efficient implementation of a dependent map with types as keys  http://hackage.haskell.org/package/typerep-map-0.2.0 (shersh)
22:05:19 <suzu> if the type is different, then yes
22:05:35 <suzu> i think that's the only way to do it
22:05:41 <Solonarv> if you have nested ReaderT's all the operations will use the outermost env
22:05:45 <suzu> if you are running a sub-reader of a different value, you can use `local`
22:06:06 <revskill> local , or withReaderT needs a pure function between envs :(
22:06:15 <revskill> in this case, multi envs have no relation
22:06:39 <suzu> if the subenv is a different type then yeah you need to lift a new runReaderT
22:07:23 <suzu> if the monad is different then you'll need to compose the monads together and do some ugly lifting of the runReaderT
22:07:33 <suzu> at which point maybe you're doing stuff wrong
22:10:10 <nfd9001> hmmmm, how much ram should i set aside for compiling largish things like cabal-install?
22:10:36 <iqubic> nfd9001: Are you actually planning on compiling from source?
22:10:43 <nfd9001> been doing this on a VM. 512MB didn't cut it, and apparently neither did 2048
22:10:56 <nfd9001> iqubic: well, i did cabal install cabal-install
22:11:09 <suzu> this is a path of self-destruction
22:11:15 <nfd9001> good to know
22:11:22 <suzu> get stack and move on to solving worthwhile problems
22:11:33 <iqubic> this is how you enter cabal dependency hell.
22:11:46 <suzu> this is how you rip all your hair out
22:11:55 <nfd9001> mmmmmmmmmmmkay
22:11:59 <suzu> ok to be fair it will prrrrobably work out
22:12:03 <iqubic> Or you could use Nix.
22:12:09 <suzu> but it's a waste
22:12:25 <iqubic> But you are too far down the cabal rabbit hole to switch to nix.
22:12:28 <nfd9001> i'll leave this system install as it is once i've got this xmonad stuff together and just use stack afterwards
22:13:40 <nfd9001> i'm not really too far down any rabbit holes at this point, since i've never actually tried to build large packages before
22:14:00 <nfd9001> thank you for steering me away from dependency hell, this is very helpful
22:14:29 <iqubic> Use stack.
22:14:39 <iqubic> don't bother with nix. Forget I mentioned nix.
22:15:23 <suzu> i've yet to try the nix bikeshed
22:15:25 <nfd9001> Yeah, don't think i need anything that complicated
22:15:32 <suzu> also this cabal new-install stuff
22:15:43 <iqubic> Why do you call nix a bikeshed?
22:15:46 <suzu> nfd9001: are you on arch?
22:15:51 <iqubic> they are.
22:15:57 <suzu> here's a process that works:
22:15:57 <iqubic> nfd9001 is on arch.
22:15:58 <Lears> Cabal's "dependency hell" is an outdated experience. It really shouldn't happen anymore.
22:15:59 <nfd9001> yep
22:16:02 <suzu> nuke all haskell packages from orbit
22:16:05 <suzu> install xmonad, xmonad-contrib
22:16:09 <suzu> install stack.
22:16:19 <nfd9001> in that order.
22:16:31 <iqubic> Lears: It was happening a few years back when I started learning haskell
22:16:32 <suzu> ah no
22:16:51 <nfd9001> totally different dependency hell now, haha
22:16:55 <Lears> A lot happens in a few years.
22:17:03 <suzu> in order: nuke all haskell packages from pacman. have pacman install xmonad, xmonad-contrib, and stack. use stack to do programming
22:17:04 <nshepperd> xmonad pulls in a bunch of global haskell packages as well
22:17:22 <iqubic> yeah, but that can't be avoided.
22:17:25 <suzu> xmonad and xmonad-contrib will pull in many system haskell packages and link dynamically. thats ok
22:17:36 <suzu> stack will fetch ghc and some hs packages. thats ok
22:17:44 <iqubic> Stack is great.
22:17:46 <suzu> when you work on a project, stack will make a complete sandbox there and that will all be static
22:17:53 <suzu> and fetch a compiler for it too
22:18:14 <nshepperd> i suppose it's fine if you're ok with exclusively using stack and never using cabal
22:18:16 <Lears> You can also build/rebuild xmonad with stack or cabal if you don't want a global ghc.
22:18:19 <suzu> so you'll have a separation of system stuff and your project stuff
22:18:24 <suzu> this is how i have my system on arch set up
22:18:30 <iqubic> Right. So if you need an old compiler because a library hasn't updated stack will fetch the right cmpiler for you.
22:18:39 <iqubic> Stack is awesome like that.
22:18:48 <nfd9001> that's pretty neat
22:18:48 <suzu> furthermore: when you upgrade your system and it upgrades xmonad/haskell things, run `xmonad --recompile` before you reboot
22:19:04 <suzu> or else xmonad may not start on next boot
22:19:10 <nfd9001> right, because system xmonad is going to link dynamically
22:19:13 <suzu> yep
22:19:18 <revskill> lfitEnv :: forall env' env m a. Monad m => ReaderT env' m a -> env' -> ReaderT env m a
22:19:18 <revskill> lfitEnv comp env = lift (runReaderT comp env)
22:19:21 <suzu> and it needs to recompile your xmonad config
22:19:25 <suzu> when the system updates
22:19:47 <suzu> otherwise when you boot it'll give dumb errors like "couldn't find package time-x.y.z"
22:19:47 <revskill> ReaderT library has no such function
22:20:20 <suzu> this is the simplest approach i know to just get shit working on arch and move on
22:20:44 <suzu> leave the system crap in the system and have stack do the heavy lifting for project work
22:20:49 <suzu> works wonderfully imo
22:20:55 <nfd9001> sounds lovely, thank you
22:20:59 <suzu> np, yw
22:21:49 <nfd9001> man, i thought i'd fixed the system cabal with the ghc-pristine kludge
22:22:04 <nfd9001> but every other think i've tried to install through cabal has failed after a Long Time
22:22:11 <nfd9001> and for different reasons
22:22:19 <nfd9001> ...i'm gonna do the stack thing, yes
22:22:52 <suzu> now i've heard that cabal new-install is the new sandbox good shit
22:23:15 <suzu> but i've got everything working with stack, soo...
22:23:17 <geekosaur> the main thing stack gets you here is you only need to install it, it will then manage its own ghc and packages and ignore your package manager. (but you have to go through stack to do anything haskell related)
22:23:25 <suzu> yes ^
22:23:54 <suzu> i personally have found 0 drawbacks to this approach
22:23:58 <suzu> im okay with marrying stack
22:24:00 <geekosaur> personally I've found nix a reasonable way to deal with unreasonable distributions (mine still installs ghc 7.6.3) but nix has its own learning curve
22:24:24 <suzu> i'll get around to trying cabal new-build sometime
22:25:10 <suzu> i have been meaning to stop being lazy and finally start my blog up
22:25:17 <suzu> maybe i'll put this on it
22:25:22 <suzu> probably useful stuff
22:28:25 <Solonarv> stack's biggest downside IME is that the snapshot approach makes it lag behind newer versions of packages
22:30:07 <suzu> use nightly
22:30:39 <suzu> nightly is just a very frequent release of an LTS really
22:31:22 <nshepperd> huh, someone added a stack-static to the aur before i could get to it
22:31:43 <Solonarv> nightly only makes that issue less bad, it doesn't go away
22:33:39 <nshepperd> I have statically linked versions of cabal and stack installed and mostly use cabal sandboxes
22:34:21 <nshepperd> not sure what i'd do if I wanted to use xmonad. probably install it in a sandbox and run it from there
22:35:28 <geekosaur> there's some example build scripts for stack, cabal sandboxes, and cabal new-build in the xmonad-testing repo on github
22:35:47 <geekosaur> would probably need some editijng for use in anon-testing configuration
22:42:02 <Lears> Imo you don't even need examples for build scripts, since they're so simple and flexible. It's just a shell script that takes a target path as $1 and can do whatever the hell it wants so long as it exits successfully and there's an xmonad executable (or symlink to one) at that target path when it's done.
22:43:01 <Lears> So if you know how to use any of cabal, stack or nix you're already there.
22:45:48 <geekosaur> yeh, but "someone give me one that already works" is something of a faq
22:45:51 <geekosaur> people are people
23:11:30 <voicelessdragon> If I wanted a rigorous understanding of Haskell, where should I start? Should I pick up Dummit & Foote and come back in a couple months? To be clear, I've written several programs in Haskell, but I just understand how to use things. I feel uncomfortable hacking through a language that clearly was motivated from concepts in pure math. I am relatively mathematically mature as I studied physics, but I don't have a background in
23:11:30 <voicelessdragon> abstract algebra. I am under no time pressure, but I am looking to be efficient with my learning.
23:13:34 <arahael> voicelessdragon: I'm still learning haskell, and I've yet to write a complete haskell application, however, in general with langauges, I'd look for their history.  Looking at the early papers and following how the languages evolves is always really insightful.
23:15:03 <arahael> voicelessdragon: Particularly http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
23:16:34 <arahael> voicelessdragon: Fun fact - in those early days there was an extension called Haskerl, which combined the best in Haskell with the best in Perl.
23:18:06 <voicelessdragon> arahael: interesting, thank you for the paper
23:18:27 <arahael> voicelessdragon: See section 2.6 for the Haskerl reference. :)
23:32:16 <suzu> hmm
23:33:17 <suzu> voicelessdragon: take a look at this book, perhaps
23:33:19 <suzu> http://www.cis.upenn.edu/~bcpierce/tapl/
23:33:37 <suzu> This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages
23:33:46 <suzu> The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators
23:33:53 <mniip> hmm, I wonder if there's a complete description of RankNTypes somewhere
23:34:01 <suzu> yes, its in this book
23:34:06 <suzu> under system-f i believe
23:34:14 <mniip> suzu, I meant as it appears in haskell
23:34:34 <suzu> oh. yes, i think the ghc manual has that
23:35:06 <mniip> in the GHC manual there's a very brief explanation
23:35:29 <suzu> maybe the tracker then..?
23:35:31 <suzu> hmm
23:35:51 <suzu> i had thought there's a good exploration in the manual
23:36:29 <arahael> Remarkable, the kindle version of tapl is more than twice the cost of the paper version.
23:36:51 <suzu> lmao
23:37:10 <suzu> then something else you should read (in no relevant order to tapl) is https://github.com/hmemcpy/milewski-ctfp-pdf
23:37:15 <suzu> this is the category theory side of things
23:37:38 <arahael> Oh, the paper version tab only listed the "rental" price, kindle is twice the cost of renting the paper version.  Still rediculously expensive, though.
23:38:09 <mniip> suzu, I am pondering on this pecularity
23:38:12 <suzu> and then one other thing you could read is the GHC manual. it goes into quite a bit of depth
23:38:14 <mniip> > case (undefined :: forall a. a) of (x :: forall a. a) -> x
23:38:17 <lambdabot>  error:
23:38:17 <lambdabot>      • Cannot instantiate unification variable ‘a0’
23:38:17 <lambdabot>        with a type involving foralls: forall a. a
23:38:40 <mniip> > (\(x :: forall a. a) -> x) (undefined :: forall a. a)
23:38:42 <lambdabot>  *Exception: Prelude.undefined
23:38:58 <mniip> > (\case (x :: forall a. a) -> x) (undefined :: forall a. a)
23:39:00 <lambdabot>  *Exception: Prelude.undefined
23:39:17 <suzu> arahael: that should give you plenty of material to get the understanding you're looking for
23:39:25 <mniip> seemingly the same expression but types are instantiated differently here
23:39:41 <arahael> suzu: ^^ voicelessdragon  :)
23:40:02 <suzu> oh oops, i meant to highlight voicelessdragon
23:40:22 <suzu> my mistake
23:40:32 <suzu> mniip: you mean \x -> x and \case x of x?
23:40:53 <mniip> no I mean what I said
23:41:17 <mniip> I want a pattern match with a quantified scrutine
23:41:42 <voicelessdragon> suzu: thank you for the resources! I will take a look into these
23:43:25 <suzu> i dont get it
23:43:51 <suzu> oh that line you tried that doesn't compile
23:44:04 <suzu> i see
23:44:51 <suzu> hm
23:45:01 <suzu> > case (undefined :: a) of (x :: a) -> x
23:45:03 <lambdabot>  *Exception: Prelude.undefined
23:45:11 <mniip> now that's different
23:45:14 <suzu> > case (undefined :: forall a. a) of (x :: a) -> x
23:45:16 <lambdabot>  *Exception: Prelude.undefined
23:45:22 <mniip> still diferent
23:45:26 <suzu> > case (undefined) of (x :: forall a. a) -> x
23:45:28 <lambdabot>  error:
23:45:28 <lambdabot>      • Cannot instantiate unification variable ‘a0’
23:45:28 <lambdabot>        with a type involving foralls: forall a. a
23:45:38 <mniip> for a more concrete example,
23:45:48 <mniip> consider a view pattern that expects a polymorphic argument
23:46:22 <mniip> like ((\f -> (f 'a', f ())) -> ('a', ())
23:46:31 <mniip> with the intention that  f :: forall a. a -> a
23:47:09 <suzu> i think you need ImpredicativeTypes for ths
23:47:11 <suzu> this *
23:47:12 <mniip> no
23:47:23 <suzu> then i'm just as puzzled as you are
23:47:26 <mniip> such a view pattern can work in a lambda pattern, a function equation, or a let binding
23:47:30 <mniip> but not a case-of
23:47:34 <suzu> perhaps it is a GHC bug
23:47:39 <mniip> because case-of always instantiates its binding
23:48:06 <mniip> no, see this discussion on the trac https://ghc.haskell.org/trac/ghc/ticket/15416#comment:1
23:48:07 <suzu> and now i am wanting to look at the spec for rankntypes
23:48:48 <suzu> oh you filed this
23:49:05 <mniip> I filed this about a slightly more complicated matter
23:49:12 <mniip> which led to this question/problem
23:49:46 <suzu> does this have to do with the unification inside a case being unleakable?
23:49:56 <mniip> ?
23:50:16 <mniip> you mean unifying under a local equational constraint?
23:50:39 <suzu> i think that might be it but i am not certain
23:50:46 <mniip> doubt it
23:50:52 <mniip> there's no local constraints
23:50:53 <suzu> i don't know what it's called and don't know how to google for it. but its a problem i ran into exactly once
23:51:04 <mniip> "untouchable" tyvars?
23:51:28 <suzu> wherein i had written a case that should've placed greater constraint on what the type of some value within it was, but it was not propogating out to the function body it was is
23:51:45 <suzu> it may have been on the scrutinee even
23:51:48 <suzu> i can't recall
23:51:49 <suzu> :/
23:52:11 <suzu> > The type inference engine never generalises the scrutinee of a case
23:52:13 <lambdabot>  <hint>:1:5: error: parse error on input ‘type’
23:52:13 <suzu> oh maybe this is it
23:52:21 <mniip> @let data T a where D :: T Int
23:52:23 <lambdabot>  Defined.
23:52:37 <mniip> :t \x -> case x of D -> 123
23:52:38 <lambdabot> error:
23:52:38 <lambdabot>     • Could not deduce (Num p) arising from the literal ‘123’
23:52:38 <lambdabot>       from the context: a ~ Int
23:52:48 <mniip> hrm, a better example
23:52:50 <mniip> @undefine
23:52:50 <lambdabot> Undefined.
23:52:54 <mniip> @let data T a where D :: T Bool
23:52:55 <lambdabot>  Defined.
23:52:58 <mniip> :t \x -> case x of D -> False
23:52:59 <lambdabot> error:
23:52:59 <lambdabot>     • Couldn't match expected type ‘p’ with actual type ‘Bool’
23:52:59 <lambdabot>         ‘p’ is untouchable
23:53:09 <suzu> what the fuck
23:53:16 <suzu> now that's new
23:53:25 <mniip> ah, I thought this is what you're referring to
23:53:49 <suzu> what is `p`?
23:53:51 <suzu> the type of `x`?
23:54:41 <suzu> or is it the type of the case statement?
23:54:49 <mniip> it's the type of the case statement
23:55:12 <suzu> it expects a polymorphic type and won't let you return a concrete one, wtf?
23:55:21 <mniip> let (x :: T a), from the branch with D it infers  a ~ Bool => p ~ Bool
23:55:44 <suzu> yes
23:55:52 <mniip> this implicational constraint cannot be solved
23:56:21 <mniip> it has two solutions: a ~ p, and Bool ~ p
23:56:24 <suzu> you cannot test if a ~ Bool?
23:56:26 <mniip> neither of which is more general
23:57:08 <mniip> @let f1 :: T a -> Bool; f1 D = False
23:57:09 <lambdabot>  Defined.
23:57:12 <suzu> i don't understand why this can't be written
23:57:15 <mniip> @let f2 :: T a -> a; f2 D = False
23:57:16 <lambdabot>  Defined.
23:57:25 <mniip> same body, incomparable types
23:57:36 <mniip> incomparable = neither is a specialization of the other
23:57:59 <suzu> i think i understand
23:58:10 <mniip> which means there's no most principal type for the expression \D -> False
23:58:25 <mniip> so the typechecker avoids making any choice at all
23:58:29 <suzu> you mean \(x :: T a) -> False?
23:58:38 <mniip> no, that has a solution
23:58:48 <suzu> that would be :: T a -> Bool
23:58:53 <mniip> T a -> Bool is the only type that can be assigned yes
23:58:57 <suzu> got it
23:59:21 <suzu> but `\D -> False` has no solution for it's type?
23:59:25 <mniip> yes
23:59:31 <mniip> no, it has two
23:59:38 <suzu> it has multiple solutions for it's type.
23:59:39 <mniip> but no *most principal* type
23:59:44 <suzu> but no clear answer
23:59:46 <suzu> okay
23:59:58 <mniip> think of like
23:59:59 <suzu> you can write `\D ->` ?
