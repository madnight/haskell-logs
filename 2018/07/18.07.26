00:00:19 <nshepperd> that's what I ended up doing in my app
00:00:40 <nshepperd> (with a type family that writes out the KnownNat a, KnownNat b, KnownNat c for me)
00:01:03 <cocreature> it’s interesting that GHC doesn’t warn here. In some other cases it recommends that you do something like that
00:01:27 <nshepperd> I guess now that I know that it's the FlexibleContext usage that is the problem, I'm more sure that that's the right thing to do
00:06:37 <dataN> so it cant tell the length of the list?
00:07:45 <cocreature> no, this has nothing to do with the length. the problem is that it could either get the instance from the context of the definition if [a, b, c] ~ [2*a, 2*b, c] or from the top-level instance
00:09:46 <dataN> oh, so its a problem of using classes in type level programming... would a kind of newtype class allow this to be disambiguated? is that what the type family was for?
00:10:50 <cocreature> I have no idea what a newtype class is supposed to be
00:11:27 <dataN> right, just an empty subclass..
00:12:35 <dataN> oh, maybe that wouldnt help... it would still conflict with the top level definition of the superclass?
00:13:58 <cocreature> sry, I’m not following. maybe make some code sample to demonstrate your idea
00:14:51 <u1dzer020> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
00:15:18 <nshepperd> in the end I disambiguated by making the context un-flexible
00:16:23 <nshepperd> which is a really rather mechanical process of replacing the context with the contexts of the top level instance that matches it
00:16:35 <nshepperd> s/matches/overlaps with/
00:17:03 <Saulzar_> How do you make the context un-flexible? (other than turning the extension off?)
00:20:22 <nshepperd> Saulzar_: for instance the context (KnownDims '[a]) is flexible and overlaps with the instance "(KnownNat d, KnownDims ds) => KnownDims (d ': ds)"
00:20:28 <dminuoso> Saulzar_: Haskell requires that the context be of the shape `T a0 a1 a2 ...` where `a0`, `a1`, etc are type variables.
00:20:52 <nshepperd> so I replace the former by the context of the latter, (KnownNat a, KnownDims '[])
00:21:06 <nshepperd> then throw away the KnownDims '[] since that's already global
00:21:55 <cocreature> just to be clear, that’s not something that you can do in general. e.g. you can’t easily replace a "MonadState Int m" constraint by something that does not require FlexibleInstances
00:21:57 <dataN> and that makes it recurse through the rest of the list?
00:23:14 <nshepperd> then the context 'KnownNat a' works and is more or less equivalent (you can get KnownDims '[a] from it)
00:24:23 <dataN> oh right
00:25:09 <Saulzar_> I don't follow - I'm looking at your example and you have one instance for  '[]  and another for (d ': ds) and I don't see they overlap at all..
00:25:24 <Saulzar_> Where does the KnownDims [a] come from?
00:25:48 <dataN> a ': '[]
00:26:05 <Saulzar_> Yeah but that's not part of the example that I can see at all..
00:26:17 <nshepperd> Saulzar_: not part of the example
00:26:27 <dataN> its inferred recursively
00:27:33 <nshepperd> Saulzar_: the problem in the example was that 'KnownDims [a, b, c]' from the context and KnownDims (2*a ': [2*b, c]) from the top level instance overlap
00:28:21 <nshepperd> or rather, ghc thinks they might overlap, depending on the meaning of (*), which ghc knows nothing about
00:28:23 <dataN> oh, so how is a==b?
00:28:56 <Saulzar_> Hmm, maybe I need to understand more about what FlexibleContexts does - I don't quite see why it's an issue
00:29:22 <cocreature> the issue is not really FlexibleContexts, the issue is that there are two potential ways to arrive at an instance
00:29:41 <cocreature> FlexibleContexts just lets you provide one way
00:29:45 <cocreature> but it’s not the issue in itself
00:31:58 <dataN> so what was the use of type families here?
00:32:05 <cocreature> type-level multiplication
00:32:43 <dataN> oh, not to solve this inability to use lists of types in constraints...
00:33:41 <dataN> just trying to get the new GHC to work but it installs without binaries!?
00:34:30 <nshepperd> alright, I've gotta go to bed, thanks cocreature, dataN
00:35:00 <dataN> sweet!
00:36:23 <Saulzar_> Ok, so reading a little about what FlexibleContexts is doing - it seems it's about being able to use concrete types in contexts. e.g.   (Num Int) =>   I don't quite see how this applies to the situation, there are no concrete types in the context..
00:36:25 <dataN> "newclass wrapper" meaning something like; 'class KnownDims ds => KDims where ; ; '
00:38:10 <cocreature> Saulzar_: KnownDims [a,b,c] requires requires FlexibleInstances since [] is not a type variable
00:38:18 <Saulzar_> Ah..
00:49:03 <dminuoso> Is it possible for `bracket` to not run the "release resource" branch (aside from hanging in the main computation that is)?
00:49:18 <dminuoso> Or do I get a proper guarantee from Haskell?
00:50:11 <cocreature> dminuoso: if your process dies, your thread might not have time to run the finalizers
00:50:21 <dataN> no but seriously, no GHCi for windows? whats winghci?
00:50:52 <cocreature> dminuoso: in particular, if your main thread exits (even if it exits normally), finalizers in other threads won’t be run
00:51:14 <cocreature> which is why you should probably be using the async lib instead of using forkIO directly :)
00:52:01 <dminuoso> cocreature: For now it seems impossible to do any of this concurrently anyway, so no desire to use multiple threads.
00:52:06 <dminuoso> But Ill keep that in mind
00:52:58 <cocreature> dminuoso: if your main thread dies “hard” (SIGKILL, segfault, …) then finalizers also won’t be run
00:54:18 <dminuoso> cocreature: Is there a way to install an appropriate handler for SIGKILL at least?
00:55:11 <cocreature> dminuoso: I don’t think linux lets you do anything for SIGKILL
00:55:12 <adjofun> handler for sigkill =D
00:55:19 <cocreature> that’s the whole point of SIGKILL :)
00:55:22 <dminuoso> Oh wait right, POSIX specifies that you cant cleanup a SIGKILL
00:55:38 <dminuoso> Guess that'd be SIGTERM
00:55:59 <cocreature> for SIGTERM finalizers should run
00:56:49 <dminuoso> Im guessing that technically you can actually catch a SIGBUS/SIGSEGV, because the Oracle JVM *has* to do this on a regular basis
00:57:13 <cocreature> yeah but really wtf are you doing at that point :)
00:58:50 <Denis_> Hi guys, the beginner is here. Maybe it's a stupid question, but is there a way to restrict newtype declaration with typeclass?
00:59:14 <Denis_> newtype Something3 a =
00:59:14 <Denis_>    Something3 (a, a)
00:59:14 <Denis_> I wanna this a to implement several typeclasses
00:59:36 <cocreature> Denis_: put the type class restrictions on the functions that use Something3, not on the constructor
00:59:37 <dminuoso> cocreature: In HotSpot they use a page read on a magic memory address to determine whether a deopt has to trigger.
00:59:56 <dminuoso> They do this rather than a simple conditional jmp because that would poison the branch predictors
01:00:22 <milesrout> i just got a pattern match tried more than 2000000 times error on a fairly simple type
01:00:24 <cocreature> dminuoso: I wasn’t suggesting that in general there is no reason to do this but I would be pretty sceptical of Haskell code that catches SIGSEGV :)
01:00:28 <milesrout> is that to be expected
01:00:31 <milesrout> or am i doing something very wrong
01:00:34 <Denis_> cocreature thanks!
01:00:36 <cocreature> milesrout: can you show us the type?
01:00:46 <cocreature> and the pattern match
01:00:46 <milesrout> sure gimme a sec
01:02:31 <milesrout> i'll see if I can create a smaller paste than two separate files in my repo
01:03:27 <7GHABF079> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
01:03:27 <7GHABF079> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
01:03:27 <7GHABF079> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
01:03:42 <HarryCross217> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
01:03:57 <milesrout> um
01:04:00 <milesrout> spam?
01:05:22 <adjofun> hm, this is worrying, happens more often than before
01:07:17 <milesrout> cocreature: https://glot.io/snippets/f39b83zqp4
01:07:22 <milesrout> pastebin that you can run
01:11:38 <milesrout> it was fine until I added the first two
01:12:28 <dminuoso> cocreature: Ah
01:12:36 <milesrout> oh interesting, if I move them down a line (equivalently, move the ESeq one to the top) it goes away
01:12:54 <milesrout> even though those cases cannot interact in any way
01:13:45 <cocreature> just increasing the number of iterations to 5e6 also seems to work
01:14:29 <milesrout> i guess when i put it all in one place, it's not that simple either ha
01:15:19 <cocreature> yeah you have quite a few pattern synonyms here
01:15:31 <milesrout> i like pattern synonyms a lot
01:16:34 <cocreature> I can see that :)
01:16:51 <milesrout> haha :)
01:19:14 <pavonia> What kind of tries does it do there to reach a limit of 2 mio, though?
01:22:06 * hackage haskell-overridez 0.10.3.0 - Manage nix overrides for haskell packages  http://hackage.haskell.org/package/haskell-overridez-0.10.3.0 (adetokunbo)
01:22:51 <milesrout> Debug.Trace is fantastic
01:22:56 <milesrout> haskell is fantastic
01:22:57 <milesrout> christ
01:24:33 <tdammers> Debug.Trace is dirty and nasty, but yes, it's also fantastic
01:24:42 <milesrout> well I mean obviously I remove them before I commit
01:24:50 <pally> @let value = Left "Hello"
01:24:52 <lambdabot>  Defined.
01:25:02 <pally> > fromLeft value
01:25:04 <lambdabot>  error:
01:25:04 <lambdabot>      • No instance for (Typeable b0)
01:25:04 <lambdabot>          arising from a use of ‘show_M56370051936952106134325’
01:25:26 <tdammers> @let value = Left "Hello" :: Either String ()
01:25:28 <lambdabot>  .L.hs:164:1: error:
01:25:29 <lambdabot>      Multiple declarations of ‘value’
01:25:29 <lambdabot>      Declared at: .L.hs:163:1
01:25:29 <tdammers> > fromLeft value
01:25:32 <lambdabot>  error:
01:25:33 <lambdabot>      • No instance for (Typeable b0)
01:25:33 <lambdabot>          arising from a use of ‘show_M11662227363385895674366’
01:25:35 <tdammers> ugh
01:25:54 <tdammers> anyway, the problem is that in an Either a b, you cannot infer the b from a Left
01:26:35 <tdammers> so when you say Left "Hello", without further annotation, the type inference doesn't get any further than Either String b, with the b unresolved
01:26:53 <tdammers> and unfortunately type inference isn't as lazy as evaluation
01:27:18 <pally> tdammers, can you show me how I would use fromLeft?
01:27:29 <tdammers> your use of fromLeft is correct
01:27:40 <tdammers> it's just that Left "Hello" doesn't contain enough information to infer its type
01:27:50 <tdammers> and so the compiler doesn't know what to do with it
01:28:06 <tdammers> @let value' = Left "Hello" :: Either String ()
01:28:08 <lambdabot>  Defined.
01:28:14 <tdammers> > fromLeft value'
01:28:16 <lambdabot>  error:
01:28:17 <lambdabot>      • No instance for (Typeable b0)
01:28:17 <lambdabot>          arising from a use of ‘show_M85540430431901711974441’
01:28:19 <tdammers> oh
01:28:27 <tdammers> :t value'
01:28:28 <lambdabot> Either String ()
01:28:29 <pally> tdammers, I've tried that
01:28:32 <tdammers> hmm
01:28:36 <tdammers> :t fromLeft value'
01:28:37 <lambdabot> Either (Either String ()) b -> Either String ()
01:28:43 <tdammers> oh right
01:28:45 <tdammers> :t fromLeft
01:28:46 <lambdabot> a -> Either a b -> a
01:28:59 <tdammers> fromLeft "Nope" value'
01:29:05 <tdammers> > fromLeft "Nope" value'
01:29:07 <lambdabot>  "Hello"
01:29:22 <tdammers> you have to give it anothe `a` to use in case it's a `Right`
01:29:42 <tdammers> just like `fromMaybe` requires an additional argument to return in case of `Nothing`
01:30:03 <pally> then this document needs update?
01:30:04 <pally> http://hackage.haskell.org/package/either-unwrap-1.1/docs/Data-Either-Unwrap.html
01:30:09 <milesrout> should really be called fromEither then?
01:30:18 <milesrout> given it's more like fromMaybe than it is like fromJust
01:32:02 <tdammers> pally: http://hayoo.fh-wedel.de/?query=fromLeft - unfortunately, there are multiple implementation of fromLeft, and some of them have the extra argument, others don't (and will instead error)
01:32:35 <tdammers> milesrout: but fromEither can be written in two ways: a -> Either a b -> a, and b -> Either a b -> b
01:33:04 <tdammers> although arguably the latter makes more sense than the formerr
01:33:30 <pie__> can i use type variables for ScopedTypeVariables from a functions signature in its body?
01:33:45 <pie__> i need to set a forall variable
01:34:19 <pie__> im just trying to get this to type check (its a mess at the moment) https://bpaste.net/show/c977ea8f8bab , it's using Hint
01:34:24 <tdammers> pie__: yes, as long as you explicitly forall them in the function signature. that's what ScopedTypeVariables are fo.
01:35:14 <pie__> theres probably some kind of ContextT helper function i should be using to make the signature for this less messy...
01:35:21 <tdammers> pie__: so yes, if you use STV and then add `forall m os.` to the type signature, then it should work
01:35:42 <pie__> ok so i guess the issue was that the top signature was missing the forall?
01:35:52 <tdammers> yes, probably
01:36:08 <tdammers> without it, STV doesn't expose the type vars to the body
01:36:27 <tdammers> it's a bit of a dirty solution IMO, but apparently it was necessary to avoid breaking existing code too much
01:36:27 <pie__> s/was/is/
01:37:32 <merijn> Is the whole spam linking campaign still going on?
01:38:01 <koz_> merijn: A few channels are _definitely_ getting a lot of it.
01:38:05 <Taneb> It was half an hour ago in here
01:38:27 <merijn> Script kiddies...*sigh*
01:39:13 <pie__> merijn, for a second i thought you were talking about me xD
01:39:20 <pie__> tdammers, i think i better show you my actual error
01:39:24 <koz_> pie__: You're not a script kiddie AFAIK.
01:39:33 <merijn> koz_: He might be! ;)
01:39:40 <koz_> merijn: WE SHALL NEVER KNOW.
01:39:45 <pie__> koz_, i feel like it most of the time im coding haskell :/
01:39:55 <koz_> pie__: I feel like a monkey trying to ape a human.
01:40:10 <wz1000> #ghc is getting drowned in the spam
01:40:47 <pie__> tdammers, error: https://bpaste.net/show/efd23ab17403 code: https://bpaste.net/show/c8c0a5d8907f
01:40:54 <merijn> wz1000: One of the ops there should set it so that only registered/identified users can talk
01:40:57 <merijn> wz1000: That'd help
01:41:29 <koz_> Is there a reason you're comboing a transformer-based monad stack _with_ mtl-style typeclasses _and_ an explicit Maybe?
01:41:41 <milesrout> ##c++ has that, i've never seen spam there
01:41:48 <pie__> koz_, well the main reason is i have no f***ing idea what im doing :p
01:41:59 <koz_> pie__: I didn't wanna assume.
01:42:15 <pie__> this is the source for the CompiledShader type http://hackage.haskell.org/package/GPipe-2.2.3/docs/Graphics-GPipe-Shader.html
01:42:17 <merijn> milesrout: The problem is that it increases the barrier to entry for newbies
01:42:32 <merijn> milesrout: But it makes sense to do temporarily during active spam campaigns
01:42:35 <milesrout> i guess c++ itself does that enough that it's no big deal for them :)
01:42:43 <koz_> pie__: Yeah, compileShader's using MTL.
01:42:45 <pie__> koz_, ill post the rest of the code just so you can see it i guess
01:42:52 <koz_> I guess you need maybe because the compile can fail?
01:42:56 <pie__> yeah
01:43:11 <koz_> Well, you could just add MonadError to your stack with an appropriate error type?
01:43:16 <merijn> pie__: Dear lord, even OpenCL looks more readable than that :D
01:43:27 <pie__> sorry its so messy, normally i dont even try to show people my wip code xD https://bpaste.net/show/001aa575d2d4
01:43:32 <koz_> merijn: I think this is a first for me seeing _all three_ forms of monad composition in one go.
01:43:44 <milesrout> do { a <- b; a } == do { b }, no?
01:43:47 <pie__> lmao im sorry i try to make real things
01:43:53 <merijn> milesrout: Nope
01:43:59 <milesrout> oh return a
01:43:59 <koz_> pie__: No need to apologise. I've written much worse.
01:44:03 <milesrout> is what I meant when I wrote that
01:44:08 <merijn> milesrout: If you do "return a", then yes :)
01:44:11 <milesrout> right
01:44:14 <milesrout> :) cheers
01:44:18 <pie__> "all i really want to do" is use fsnotify to to watch a file, and when it changes recompile the shader
01:44:21 <merijn> milesrout: "do {a <- b; a}" would be "join b"
01:44:40 <pie__> of course recompilatoin involves Hint...and i dont know if thats even going to work
01:44:56 <pie__> thats the tl;dr
01:45:56 <pie__> koz_, sidenote, can i do anything about this library so that i can actually write freakin type signatures for the functions? without having to copy paste stuff from ghci error output
01:46:15 <koz_> pie__: I'm not familiar with this library, sorry.
01:46:24 <koz_> I'm also very tired, so I'm not sure how much help I can be anyway.
01:46:36 <koz_> Some of the other nice people on the chan might be helpful. merijn is excellent.
01:46:48 <merijn> I think that type is scary, though :p
01:46:58 <koz_> (also how do you pronounce that?)
01:47:00 <merijn> OpenCL shaders look more readable than that xD
01:47:17 <merijn> koz_: Unless you're Dutch (or for some reason, Iranian) the answer is probably "you don't" :p
01:47:27 <koz_> I'm neither of those things.
01:47:42 <koz_> That type sig is only scary because it mixes metaphors like cocktails.
01:47:56 <milesrout> merijn: i can kind of pronounce brouwer!
01:48:11 <merijn> milesrout: That one is comparatively easy
01:48:16 <milesrout> :(
01:48:19 <koz_> O
01:48:31 <pie__> koz_, no problem :) go get some sleep :D
01:48:35 <merijn> Like, just saying "brow" and "er" will get you there ;)
01:48:39 <koz_> I'm a bit confused why this library is going 'I'm gonna define a new transformer, but then write everything else MTL'.
01:48:43 <merijn> "De Bruijn" is trickier :p
01:48:47 <koz_> Like, write MonadContext if you're gonna do that!
01:48:59 <koz_> merijn: Like the sequences?
01:49:07 <pie__> ugh
01:49:33 <pie__> so basically i screwed myself over with a library again :P seemed like a relatively good opengl library though
01:49:41 <merijn> koz_: Of type checking and indexing fame, yes :)
01:49:58 <koz_> pie__: It's a bit hit-and-miss. I might have to make an awesome-haskell list to go with my awesome-c one.
01:50:05 <koz_> (I maintain awesome-c on Github)
01:50:10 <merijn> pie__: What library is this?
01:50:16 <pie__> originally i wanted to use "gl" (which is raw though) but I couldnt find a bunch of things in it even though it should be autogenerated from the XML specs
01:50:21 <koz_> merijn: GPipe.
01:50:22 <pie__> merijn, GPipe
01:50:38 <pie__> theres tutorials for it and everything
01:51:14 <ph88> when i use System.Random.MWC.createSystemRandom i spend a lot of times doing syscalls .. but when i use System.Random.MWC.create i don't get good random numbers.  Anyone advice on this ?
01:51:20 <pie__> or do i just need to go learn MTL or somethign
01:52:26 <merijn> pie__: MTL isn't that hard to learn, it's just "write a million instances by hand to get automagically lifted versions of transformers"
01:52:34 <pie__> oh boy.
01:52:43 <merijn> ph88: What makes you say you don't get good random numbers?
01:52:51 <pie__> ok sorry so, tl;dr: WAT DO
01:53:17 <pie__> what do i learn/do to make it so i can make this work
01:53:21 <ph88> merijn, because my game simulation runs very long .. i think it can not access the cards it needs to progress the game
01:54:27 <merijn> ph88: And is there a reason why you expect it's the quality of the randomness, rather than a flaw in the game logic?
01:54:34 <pie__> (put a man in a fishing course and he'll starve by the time he learns xD)
01:54:50 <ph88> merijn, yes because when i change from create to createSystemRandom i don't get this
01:55:21 <merijn> ph88: Or the default seed from create is just unlucky
01:55:49 <ph88> how can i give it a random seed ?
01:56:13 <merijn> ph88: Initialise lets you provide a seed in the form of a Word32 vector
01:56:38 <ph88> how do i get a truelly random Word32 vector ?
01:56:49 <pie__> ph88, take for bytes from urandom
01:56:54 <pie__> *4
01:56:55 <Lowl3v3l1> ph88: you can't with software alone
01:57:09 <pie__> well yeah what Lowl3v3l1 said honestly
01:58:00 <cocreature> ph88: you could use withSystemRandom to get the initial bytes for the seed
01:58:27 <merijn> pie__: I don't really know what's going on, but I see two suspect things
01:58:59 <milesrout> isn't a 32-bit random number insufficient to cover all possible configurations of a deck of playing cards
01:59:01 <merijn> pie__: Line 46, gridpoints, you're specifying a type signature with "os" in it, and I see Typeable constraints on os not being inferred
01:59:32 <merijn> pie__: The GPipe docs, however, tell me that "os" is a rank2 type variable to implement the usual ST trick to prevent leaking state
01:59:49 <pie__> right
02:00:04 <pie__> (i read that but i could not see :P)
02:00:28 <merijn> So the question is "where tf is that Typeable coming from?"
02:00:38 <trebuh> Geekingfrog: Hey! First step of learning: idling on the IRC channel :-)
02:01:10 <averell0> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
02:01:10 <averell0> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
02:01:10 <averell0> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
02:01:12 <merijn> pie__: I would judiciously add type signatures (on draw' and every let binding, etc.) to nail down where you and GHC disagree
02:01:14 <pie__> merijn, its from the as because interpret needs to give a result of a type?
02:01:44 <merijn> ah!
02:01:50 <pie__> sorry if i didnt make it clear, runinterpreter is from Hint
02:02:03 <merijn> I suspect draw' is the crux here
02:02:09 <merijn> Can you write a type for that?
02:02:57 <pie__> merijn, its really big but i can try i guess
02:03:04 <pie__> re: copy pasting from ghc errors
02:03:15 <pie__> so damn ugly heh
02:03:38 <pie__> is there a way to show top level inferred types? ghc doesnt like _ at top level
02:04:11 <merijn> Actually, I suspect you might be boned
02:04:28 <pie__> when aren't I
02:04:57 <merijn> interpret only works on results which are Typeable
02:05:07 <pie__> makes sense
02:05:14 <ph88>  Vector v Word32   is this a Vector of Word32 ?  or is the size of this vector as big as Word32 ?
02:05:14 <merijn> You are trying to attempt to return a "Maybe (CompiledShader os (PrimitiveArray Triangles (B4 Float, B3 Float) ))"
02:05:31 <merijn> pie__: So, it's inferring that that is only Typeable when os is Typeable
02:05:39 <pie__> im guessing you cant derive a typeable for a forall
02:05:53 <merijn> pie__: But "os" is this rank2 passed in type decided by something else (the withContext thingy)
02:05:54 <pie__> s/derive/infer/whatever/
02:06:03 <merijn> So I don't think this can work as-is?
02:06:33 <pie__> merijn, i can accept that, all i know is rank2-s exist but not much about how they work
02:07:13 <pie__> this stuff seems like it would break down near Hint
02:07:32 <pie__> what i need is for this file to be reloadable at runtime:
02:07:33 <merijn> pie__: The two options would be: 1) try and find a way to use Hint that doesn't require Typeable or 2) make Hint return something else that *later* gets turned into the relevant CompiledShader (after hint has returned)
02:08:21 <pie__> https://bpaste.net/show/9657bdf5e225 no types as usual because they are insane
02:08:32 <pie__> merijn, ahh wait a minute you might be on to something there
02:08:55 <pie__> this is probably what i should be going for http://hackage.haskell.org/package/GPipe-2.2.3/docs/Graphics-GPipe-Shader.html#t:Shader
02:09:18 <pie__> the difference being whether i put compileShader inside or outside that file
02:09:33 <pie__> and i really should probably have it outside
02:09:42 <pie__> ah but this also takes os...
02:10:06 <pie__> so i guess im boned.
02:11:14 <ph88> merijn, am i doing the initialization in the right way this way ?  https://bpaste.net/show/49e7900e1e32
02:13:00 <ph88> do top-level functions with IO get executed again when they are called or is it possible to cache the results ?
02:13:25 <barrucadu> ph88: You've basically just reimplemented `createSystemRandom`: http://hackage.haskell.org/package/mwc-random-0.14.0.0/docs/src/System.Random.MWC.html#createSystemRandom
02:13:36 <Taneb> ph88: they get executed when they are called
02:13:39 <barrucadu> A top-level IO value will be executed every time it is used, yes
02:16:04 <pie__> merijn, drawWindowColor returns a Shader os s () , os and s are forall-ed
02:17:18 <ZeuPiark> hello
02:18:11 <pie__> and this stuff if basically part of the edsl that replaces GLSL in GPipe, so by that logic theres nothing i can do, unless i shell out to raw opengl with a different lib.
02:18:20 <pie__> at least thats my logic.
02:18:27 <merijn> ph88: top level stuff like that is an error outside ghci
02:19:23 <merijn> pie__: The initial attempt was actually buggy, because shaders have to be compiled in relation to an active context, but your hint interpreter is completely unaware of that when compiling the file, so Hint returning a compiled shader is incorrect to begin with
02:19:57 <pie__> merijn, oh, i kind of figured you could compile a shader separately.
02:20:13 <pie__> well thats annoying.
02:20:35 <pie__> so, theres no way to separate the context from the program in this case, so its absolutely ****ed
02:20:44 <merijn> pie__: It doesn't make sense to compile a shader without a context, because how would you know what to compile it *to*?
02:21:30 <pie__> yeah ok that makes sense
02:21:47 <pie__> "pick a gpu. any gpu." :P
02:21:53 <merijn> pie__: I'm not 100% up to date on OpenGL, but with OpenCL it's perfectly possible to 1) have multiple OpenCL versions installed and 2) even use those in the same program. For example, I'd use the Intel OpenCL to run on integrated graphics while using NVIDIA OpenCL to run on the GPU
02:22:08 <pie__> sure
02:22:59 <merijn> I'm not sure to what extend GPipe is suited for doing hot-reloadable shaders, tbh. You'd have to ask the author
02:23:12 <pie__> yeah im about to do that but it seems to zero extent
02:23:37 <pie__> i mean its an edsl, so the ony way to do that is raw glsl (not exposed), or reload the haskell, right?
02:23:38 <holodoc22> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
02:24:06 <merijn> pie__: I'm not familiar enough with GPipe to say
02:24:33 <pie__> merijn, i dont see any other possibilities. but ill ask the author.
02:24:40 <merijn> pie__: Tangentially related, if you just wanna fuck about with shaders, edwardk's gl package is probably the most complete/direct access to OpenGL from Haskell
02:25:05 <pie__> merijn, yeah i was on about that for about a sentence. i couldnt find half the apis i needed...
02:25:27 <pie__> which i dont understand at all, because its supposed to be autogenerated
02:26:35 <pie__> for example i couldnt find glGetString or glEnable ( http://antongerdelan.net/opengl/hellotriangle.html )
02:27:24 <cocreature> pie__: https://hoogle.haskell.org/?hoogle=glgetstring%20package%3Agl
02:27:39 <merijn> pie__: Ah, but that's an easy thing to learn, let me introduce you to the blissful feature that is the [index] link on top of the package's module list
02:27:45 <merijn> pie__: https://hackage.haskell.org/package/gl-0.8.0/docs/doc-index-G.html
02:27:53 <pie__> cocreature, ...but i hoogled that and got no results??? :(
02:28:01 <merijn> pie__: Which includes a complete alphabetical list of all functions
02:28:01 <pie__> i ran the exact same query
02:28:11 <cocreature> pie__: hoogle.haskell.org /= haskell.org/hoogle
02:28:19 <pie__> ...
02:28:21 <pie__> ARGH
02:28:23 <merijn> pie__: There's two hoogle's old, stable, good type search hoogle
02:28:34 <merijn> pie__: And new, beta, less good type search Hoogle
02:28:38 <cocreature> someone should really just kill the old hoogle. it seems to do way more harm then good
02:28:45 <merijn> The latter indexes considerably more packages
02:28:56 <cocreature> and it also indexes recent versions of those packages
02:29:20 <pie__> sidenote, can someone explain to me why half of hackage versions of packages dont have docs generated?
02:29:38 <pie__> so, the hoogle stuff is good to know...
02:29:39 <pally> does `sometext` in a `do` block have any special meaning?
02:29:46 <pally> (backticks)
02:29:53 <pikajude> ok so i need a way to store a bunch of comments annotated with positions in a data structure
02:29:55 <merijn> pally: backticks make functions usable infix
02:29:57 <cocreature> hackage’s doc builder used to be somewhat broken. these days it’s reasonably good
02:30:02 <pikajude> and then find the lists of comments that are within a certain range
02:30:03 <merijn> > mod 3 10
02:30:06 <lambdabot>  3
02:30:10 <pikajude> could i do that efficiently with Data.Map.Lazy.Map?
02:30:10 <merijn> > 3 `mod` 10
02:30:13 <pally> merijn, right, I knew that.  Forgot about it.
02:30:13 <lambdabot>  3
02:30:20 <cocreature> but really I find the idea of building docs on hackage silly. cabal and stack should just upload docs by default when they upload a package
02:30:24 <pally> thanks merijn
02:30:28 <merijn> cocreature: yeah
02:30:37 <merijn> cocreature: Then you can also enable the new incremental search!
02:30:37 <milesrout> glguy: hey are you around? from your glirc package it looks like one can use italics in there, but you use vty which i know doesn't support italics. how?
02:30:57 <cocreature> in general, hackage doesn’t have a sufficient amount of information to build haddocks anyway (e.g. foreign libs)
02:31:15 <cocreature> and it only builds on one GHC version which might not be the one supported by your package
02:31:29 <pie__> huh.
02:31:57 <pie__> merijn, well at least i can use gl 4.x now...
02:32:31 <pikajude> oh I could use Map and Map.split, that might be useful
02:32:45 <milesrout> glguy: oh damn nvm, just found the '-- italic not supported'
02:33:32 <pie__> merijn, im getting kind of tired of only getting to use fully imperative code for everything though :'(
02:33:48 <pie__> merijn, the other thing im messing around a lot with is writing stuff with Qtah
02:34:34 <pie__> i feel like im a masochist for using haskell...
02:34:44 <pie__> maybe i need to take a break today
02:34:44 <merijn> pie__: tbh, I've mostly not done any graphics/GUI stuff, because there's still no "shining beacon of functional design awesomeness" for those things
02:34:55 <merijn> pie__: OTOH, nothing wrong with imperative Haskell :)
02:35:12 <merijn> I write lots of imperative Haskell, it's infinitely nicer than writing imperative C or Python :p
02:35:15 <pie__> eh, idk it seems like im always trying to do painful thngs
02:35:32 <pie__> though there was that one time i did a refactor and id rather not try doing it in python
02:35:52 <pie__> its just...really tiring going nowhere :p
02:36:11 <pie__> and constantly needing to ask other people for help. i need to get better. x)
02:36:15 <merijn> pie__: Invent your own super awesome alternative on top of gl!
02:36:27 <merijn> pie__: That's essentially what GPipe is
02:36:38 <merijn> pie__: So you just have to invent GPipe 2.0 with dynamic loading ;)
02:36:54 <pie__> merijn, give me a few more books of CS knowledge and months of full time haskell experience and maybe.
02:37:16 <pie__> said books are to be in my head and not collecting dust on the shelf :p
02:37:28 <pie__> oh i almost forgot to email the author
02:38:00 <merijn> pie__: Half the stuff I learned was when I was trying to overcomplicately invent something like this :p
02:38:11 <pie__> x)
02:38:30 <pie__> maybe its just the lack of any success getting to me
02:38:51 <pie__> on the plus side, last commit to gpipe-core was 3 days ago, so it seems at least somewhat active
02:50:03 <Saizan> i vaguely remember a quote about how progress is when the current generation can calculate(?) without thinking what took effort to do for the previous one, anyone remembers what it was?
02:50:48 <pie__> i dont know but there's one about perspective being worth 80 iq points
02:58:42 <Phanes> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
02:58:42 <Phanes> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
02:58:42 <Phanes> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
03:00:57 <BlueShark13> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
03:00:57 <BlueShark13> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
03:00:57 <BlueShark13> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
03:03:24 <JuanDaugherty> you mean the thing calculated or the origin of the quote?
03:03:31 <phaazon> hey
03:03:37 <phaazon> anyone here using hie with neovim?
03:03:41 <phaazon> and it seems not to work here
03:03:51 <phaazon> I followed everything in the readme
03:04:40 <JuanDaugherty>  in any case sounds like a constructed memory that confabulates a time when mathematical literacy was general
03:04:55 <JuanDaugherty> up until now, elementary arithmetic is the most that's generally expected
03:05:10 <lavalike> did haskell always support »guards → | guard1, …, guardN (n>=1)« described here? https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-460003.13
03:05:26 <JuanDaugherty> different if it referred to generations of mathematicians ofc, but google didn return anything remotely like that
03:08:50 <pie__> JuanDaugherty, i dont think it would have been applied to the general public
03:09:12 <pie__> at least that doesnt feel like the nature of the quote if calculated is really what was used there
03:09:18 <dminuoso> lavalike: https://www.haskell.org/onlinereport/exps.html
03:10:07 <lavalike> dminuoso: I ended up here https://www.haskell.org/onlinereport/decls.html#pattern-bindings
03:10:09 <dminuoso> lavalike: not quite sure what what `gd -> | exp^0` denotes though
03:10:50 <JuanDaugherty> pie__, well if mathematicians was implicit then it likely preceded the turn to abstraction and thus would likely have been before the early 19th century
03:12:13 <lavalike> dminuoso: in particular under function bindings it says "where each match_i is of the general form [...] or | g_i1 = e_i1 ... | g_{im_i} = e_{im_i} [...]"
03:13:14 <lavalike> this doesn't seem to me to allow a conjunction of guards separated by commas
03:14:00 <dminuoso> lavalike: Yeah it seems not even if you compare 3.13 in both
03:14:36 <lavalike> dminuoso: oh thank you it didn't occur to me that the sections would match so precisely, lovely
03:14:47 <lavalike> wow, stumbling upon some new syntax, fascinating
03:16:47 <dminuoso> lavalike: though Im really curious what the "to the power of" means in that grammar
03:17:00 <monad_cat> Hey, I have a question about UNPACK. Looking at core of https://github.com/mkawalec/raytracer/blob/master/src/Lib.hs#L147-L172, `hit` uses unpacked types but I cannot force GHC to not rewrap parameteres into `V3` when they are passed to `hitSphere`. What am I doing wrong?
03:17:54 <dminuoso> Been going through the chapter 2. for a bit now, and I cant find it
03:20:21 <dminuoso> "However, the phrase Bool -> a is syntactically valid as a type, and parsers with limited lookahead may incorrectly commit to this choice, and hence reject the program. Programmers are advised, therefore, to avoid guards that end with a type signature --- indeed that is why a gd contains an exp0 not an exp."
03:20:36 * hackage yi-frontend-vty 0.18.0 - Vty frontend for Yi editor  http://hackage.haskell.org/package/yi-frontend-vty-0.18.0 (JaroReinders)
03:21:02 <dminuoso> Oh.. I think its precedence
03:23:33 <lavalike> dminuoso: I see
03:23:40 * hackage yi-keymap-emacs 0.18.0, yi-mode-javascript 0.18.0, yi-core 0.18.0, yi-misc-modes 0.18.0, yi-fuzzy-open 0.18.0, yi-keymap-cua 0.18.0, yi-dynamic-configuration 0.18.0, yi-language 0.18.0, yi-mode-haskell 0.18.0, yi-ireader 0.18.0, yi-snippet 0.18.0, yi-frontend-pango 0.18.0, yi 0.18.0, yi-keymap-vim 0.18.0 (JaroReinders)
03:24:02 <pie__> merijn, if youre still around, i might as well ask you about one more (unrelated) thing? http://hackage.haskell.org/package/language-javascript-0.6.0.11/docs/Language-JavaScript-Parser-AST.html#t:JSCommaList
03:24:08 <pie__> whoops, fail paste
03:24:52 <pie__> anyway i'd like to implement something /similar/ to hash consing, for such an ast, but i dont want to write 80 cases by hand for everything
03:24:58 <pie__> do you have any recommendations?
03:25:19 <lavalike> dminuoso: and you can even use them to do things like | Just x <- lookup ..., Just y <- lookup ... = which matches only if both do, that's very cool
03:25:37 <pie__> (basically i need to hash bottom up every node)
03:25:47 <cocreature> monad_cat: what happens if you add an INLINE pragma on hitSphere?
03:28:12 <monad_cat> cocreature: then `hitSphere` gets inlined inside `hit` and it looks like there's no wrapping any more
03:28:22 <cocreature> sounds good :)
03:28:50 <monad_cat> I know, but it still bugs me, why does it insist on packing without inlining for one but not for the other
03:34:13 <cocreature> dunno, but most optimizations are based on heuristics so I’m not particularly surprised by it.
03:35:19 <monad_cat> ok, I'll keep in mind to verify with core in each case :)
03:37:23 <lantti> somebody was proposing a testing framework that would always check core for you for any properties you think should hold
03:37:58 <lantti> http://hackage.haskell.org/package/inspection-testing
03:46:05 <ClaudiusMaximus> anyone know if fgl package has "longest shortest path" algorithm anywhere in it?
03:46:12 <martyn_h> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
03:46:36 * hackage pronounce 1.1.0.3 - A library for interfacing with the CMU Pronouncing Dictionary  http://hackage.haskell.org/package/pronounce-1.1.0.3 (NoahGoodman)
04:04:32 <Ellenor18> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
04:09:20 <ynyounuo12> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
04:18:31 <nhandler8> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
04:18:31 <nhandler8> or maybe this blog by freenode staff member Matthew 'mst' Trout https://MattSTrout.com/
04:18:31 <nhandler8> Read what IRC investigative journalists have uncovered on the freenode pedophilia scandal https://encyclopediadramatica.rs/Freenodegate
04:18:37 <rigel> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
04:19:26 <lorilan> Hi, I'm starting Haskell and try to use in a nix/cabal setup. I'm having a linking problem. Is this the right place to ask for help ?
04:21:33 <cocreature> lorilan: sure :)
04:22:00 <lorilan> cool ^_^
04:22:06 <cocreature> there is also #nixos but if it’s somewhat Haskell specific this channel is definitely the right place
04:22:21 <lorilan> I followed this this tutorial: https://github.com/Gabriel439/haskell-nix/tree/master/project2
04:23:01 <lorilan> and end up with this starting project https://github.com/lgirault/rss-agg
04:24:04 <lorilan> when I go in nix-shell, and run cabal build, I have
04:24:32 <lorilan> *the buil fails on the link step, saying zlib cannot be found
04:24:43 <cocreature> have you run "cabal configure"?
04:25:01 <lorilan> I don't think so
04:25:31 <cocreature> how exactly are you entering the shell? Haskell is slightly weird here compared to other stuff in nix. you need to enter the shell for the .env attribute rather than the attribute itself
04:25:39 <cocreature> *package itself
04:25:59 <cocreature> so for your example it should be something like nix-shell -A rss-agg.env
04:27:04 <lorilan> that's the part I don't really get, (I'm also kind of new to nix dev :p ) I just do nix-shell in the directory where is my shell.nix
04:27:32 <cocreature> try the command I just showed you
04:28:44 <lorilan> still /nix/store/k8b9hqv58dd1z0j4ikak24ykndcm91s6-binutils-2.28.1/bin/ld: cannot find -lzlib
04:29:17 <lorilan> cabal configure says `* Missing (or bad) C library: zlib`
04:30:17 <merijn> lorilan: Well, do you have zlib installed? :p
04:30:46 <lorilan> is `nix-shell -A rss-agg.env` suppose to be the same as nix `nix-shell --attr env`
04:30:47 <lorilan> ?
04:30:55 <lorilan> yes
04:31:34 <cocreature> --attr is the same as -A but I’m not sure "--attr env" works here
04:31:44 <cocreature> you are returning a record from your shell.nix rather than the package itself
04:31:48 <blahhh> cabal install hsdev on Windows gives the error: https://pastebin.com/9kfpYBAJ (I did cabal update). What am I doing wrong?
04:32:20 <blahhh> Haskell Platfrom 8.4.3
04:33:39 <lorilan> anyway I got  `error: attribute 'env' in selection path 'env' not found` with "--attr env" I picked the idea from https://github.com/Gabriel439/haskell-nix/blob/master/project0/README.md#building-with-cabal
04:34:19 <cocreature> lorilan: if you take a look at release0.nix you can see that it returns the package itself whereas you wrap it in a record
04:34:33 <cocreature> that’s why you need to specify the package name as well to select the package from the record
04:34:54 <lorilan> thanks !
04:35:52 <lorilan> (and yes zlib is installed but my understanding was that by declaring it correctly in the derivation even if its not present in my nix-env, it would appear in the nix-shell)
04:40:04 <lorilan> I really need to go. I have a meeting. I'll try to be back ASAP. Thank you already for the insights
04:45:18 <merijn> I forget, for ancient CentOS, which bindist do I want? Just the oldest Debian one?
04:45:38 <merijn> Or can I somehow query my current GHC install to figure it out?
04:47:28 <merijn> Ah, looks like older GHC had a centos bindist, which raises this issue: Why does 8.4 not have one?
04:48:20 <cocreature> lorilan: if you replace "extra-libraries: zlib" with "pkgconfig-depends: zlib" and regenerate default.nix, thinks should work
04:48:52 <zincy> Is there a (:) which appends to the end of list?
04:48:57 <cocreature> lorilan: but I’m also not sure why you are trying to depend on the zlib C library. you don’t seem to do any FFI stuff
04:49:02 <jedai> zincy: (++)
04:49:14 <cocreature> zincy: that’s usually a bad idea. you need to walk the whole list for that
04:49:15 <zincy> :t (++)
04:49:16 <lambdabot> [a] -> [a] -> [a]
04:49:18 <jedai> zincy: though that's concatenate
04:49:19 <zincy> :t (:)
04:49:20 <lambdabot> a -> [a] -> [a]
04:49:26 <merijn> Alternatively, any linux nerds know if any of the Debian/Fedora bindists should work on CentOS?
04:49:39 <cocreature> :t \xs x -> xs ++ [x]
04:49:41 <lambdabot> [a] -> a -> [a]
04:49:46 <cocreature> if you really want to do that but please don’t :)
04:50:06 <merijn> zincy: Do you need to append a lot?
04:50:10 <zincy> whats the alternative?
04:50:19 <lavalike> https://www.stackage.org/haddock/lts-9.17/containers-0.5.7.1/Data-Sequence.html
04:50:23 <zincy> Quite alot
04:50:27 <jedai> zincy: (:) is O(1), (++) is O(n) (where n is the length of the first list)
04:50:27 <merijn> zincy: Well, if you can get away with it, just append to the start then reverse at the end
04:51:13 <lavalike> whereas (<|) and (|>) are both O(1) for Data.Sequence
04:51:17 <merijn> zincy: So if you need to do a million appends, just reverse the list, stuff a million elements in front, then reverse :p
04:52:20 <zincy> (++) is O1 right
04:52:21 <Putonlalla> Possibly even skip the reverse and look at the list in a different way.
04:52:28 <merijn> zincy: No, ++ is O(n)
04:52:47 <zincy> Does it use reverse?
04:52:54 <lavalike> @src (++)
04:52:55 <lambdabot> []     ++ ys = ys
04:52:55 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:52:55 <lambdabot> -- OR
04:52:55 <lambdabot> xs ++ ys = foldr (:) ys xs
04:53:08 <lavalike> it traverses the spine
04:53:11 <merijn> ls
04:53:27 <lavalike> merijn: . ..
04:54:05 <zincy> What does that mean lavalike
04:54:46 <lavalike> zincy: it means that in order to concat [1,2] and [3] it goes through 1:(2:[]) and once it's at [] it substitutes it with (3:[])
04:55:21 <Putonlalla> This makes it linear in the length of the first argument, zincy.
04:55:36 <zincy> Oh thanks
04:56:07 <zincy> Thats surprising why can't it start at the end of the first list because it uses linked lists and not arrays?
04:56:16 <jedai> zincy: so you have to be careful with the order of operation (x1 ++ (x2 ++ x3)) is O(length(x1) + length(x2))  while (((x1 ++ x2) ++ x3) is O(length(x1) + length(x1++x2))
04:56:20 <dminuoso> zincy: Correct. Its a singly linked list.
04:56:30 <merijn> zincy: How would you know where the end is?
04:56:36 <zincy> Why does haskell use singly linked lists for []
04:56:47 <merijn> zincy: Also, note that the list is immutable, so you have to copy the entire left list anyway
04:57:03 <jedai> zincy: because it's perfect for what it does best : encode iteration
04:57:06 <dminuoso> zincy: Because of simplicity and elegance. For performance we have other containers like vector or array at your disposal.
04:57:06 <zincy> The only way to find the end of a linked list is through traversing right
04:57:15 <zincy> which is why (:) is O 1
04:57:17 <lavalike> also Data.Sequence
04:57:46 <jedai> zincy: there are other container which have better performance for some other operations like Sequence, vector, ...
04:58:00 <lavalike> it gives you both x <| xs and xs |> x to append in O(1) on either ends
04:58:05 <dminuoso> zincy: and these containers are also available in mutable flavour as well.
04:58:18 <zincy> Thanks everyone
04:58:20 <zincy> :)
04:58:26 <zincy> What does mutable flavour mean?
04:58:36 <zincy> State monad?
04:58:43 <dminuoso> zincy: if you append to a vector, you essentially copy it over and create a new one that has that additional element
04:58:53 <lavalike> at first it tastes like pistachio, then, all of sudden: strawberry.
04:59:08 <zincy> haha
04:59:46 <dminuoso> zincy: So some algorithms, like quicksort, require mutability in order to be efficient.
05:00:08 <zincy> And union find which I learned the hard way :)
05:00:32 <dminuoso> zincy: And packages like `vector` offer you mutable vectors that you can edit and mutate like you would do in say C++ or Java.
05:00:48 <zincy> So what operations require mutability to be efficient? I guess the swapping of elements?
05:01:25 <[exa]> zincy: basically any array algorithms where the pointer-jumping is unpredictable
05:01:42 <[exa]> say RC4
05:01:55 <zincy> I should really learn basic algorithms and DS
05:02:10 <dmwit> I believe it is an open question whether there is any function which can be computed asymptotically more efficiently with mutability than without.
05:02:20 <merijn> [exa]: You don't need mutability for that
05:02:47 <[exa]> merijn: the question was about efficiency, but please elaborate.
05:02:51 <merijn> dmwit: The upperbound is that immutable is never more than log n slower
05:03:08 <merijn> [exa]: You can have an immutable vector with index jumping just fine
05:03:11 <dmwit> (N.B. I said function, not algorithm: of course you will need a different algorithm for the immutable language.)
05:03:21 <dmwit> merijn: Sure. But what's the lower bound? I believe that is on open question.
05:03:27 <merijn> dmwit: Agreed
05:03:32 <zincy> From what I read most functional programmers just use asymptotic analysis despite it being a wild estimate as amortised analysis is the way to go but too hard to estimate
05:04:06 <[exa]> I thought the lower bound was also established somewhere btw
05:04:19 <Putonlalla> When it matters, you measure it, zincy.
05:04:34 <dmwit> [exa]: I look forward with great anticipation to a link.
05:04:48 <merijn> [exa]: So your comment seemed to imply you need mutability to do index jumping in arrays, but as long as you don't have to mutate arrays you can have perfectly decent immutable arrays
05:04:48 <Putonlalla> There is too much machine for a man to analyze.
05:04:59 <zincy> That is one advantage of imperative languages easier to reason about runtime performance without measurements
05:05:08 <dminuoso> zincy: My point is Haskell offers you these tools too.
05:05:25 <[exa]> there was an old paper that compared purity and unconstrained effects, it was done on scheme and they reached some quite exact numbers
05:05:29 <dminuoso> zincy: So you are not limited by having mutability. It's rather that immutability is the default, and you have to opt-in for mutability.
05:05:47 <dminuoso> *you are not limited by having immutability
05:05:50 <[exa]> merijn: oh I didn't say that the vectors change there. Ok :]
05:05:51 <zincy> Yeah
05:06:10 <dmwit> zincy: I don't think that's an imperative vs. functional thing. e.g. OCaml was designed and implemented in part with performance reasoning in mind; and with experience, you can indeed have a very good idea about how long everything will take.
05:06:22 <merijn> [exa]: To people not too familiar with things you seemed to imply it, hence my clarification :)
05:06:32 <zincy> Maybe a strict vs lazy thing then ?
05:06:39 <dminuoso> zincy: Yes.
05:06:50 <dmwit> Perhaps.
05:06:59 <dminuoso> zincy: lazy is definitely widely recognized as being more difficult to predict space or time performance - but not impossible. :)
05:07:01 <zincy> But the advantage of laziness is perfomance with less effort
05:07:38 <zincy> What is 'normal form'
05:07:58 <dminuoso> zincy: are you familiar with lambda calculus?
05:08:41 <zincy> Lambda calculus is just a system of computation built from anonymous unary functions right?
05:10:54 <dminuoso> zincy: A term is in normal form if you can no longer perform beta reduction.
05:11:24 <dminuoso> Basically "no further reduction steps are possible"
05:12:43 <Soft> Can I have some sort of custom build steps with Stack?
05:13:24 <Soft> In a web project I would like to have Stack invoke npm to build the frontend before the Haskell backend gets compiled
05:13:57 <RustyJ1> Hey, I thought you guys might be interested in this blog by freenode staff member Bryan 'kloeri' Ostergaard https://bryanostergaard.com/
05:14:01 <Soft> Something like Cargo's build.rs
05:14:25 <dminuoso> zincy: And equivalently a term that can still be reduced is called a "redex" (REDucible EXpression). An example of a haskell redex would be: `f x`
05:14:39 <dminuoso> zincy: An example of a term in normal form: 5
05:15:33 <joel135> Hello, I have some cabal issues.
05:16:30 <[exa]> dmwit: can't find the paper, sorry. I thought it's from O.Danvy but it's apparently from someone else
05:16:38 <joel135> Trying to install https://github.com/mtolly/pokemid, I get https://lpaste.net/2366706745952174080.
05:17:06 <joel135> I did `cabal sandbox init` first.
05:17:42 <[exa]> joel135: what version of GHC do you have?
05:18:10 <joel135> On my path i have version 8.0.2.
05:19:37 <[exa]> you can probably see your system-wide base version by using: ghc-pkg list
05:20:17 <[exa]> which probably conflicts with the package requirement for <4.9
05:20:47 <[exa]> btw you can try cabal new-install which has a slightly better dependency handling
05:20:53 <joel135> `cabal info ghc` says 8.0.2 and `ghc-pkg list` does too
05:21:29 <[exa]> joel135: what's the version of 'base' from ghc-pkg (that's what the error message is about)
05:21:40 <joel135> oh
05:21:59 <joel135> 4.9.1.0
05:22:36 <joel135> does it mean the source of the git repo must be updated?
05:24:44 <[exa]> joel135: if there's a newer version of the pokemid, you might want to try it
05:25:21 <joel135> there isn't, so i'm bumping some versions in the cabal file now
05:25:24 <[exa]> also chances are that it will "just work" if you bump the version requirement by hand
05:25:30 <[exa]> yep.
05:26:20 <merijn> [exa]: He likely doesn't have new-install, since I think that's not in any released version of cabal-install?
05:27:02 <[exa]> new-install isn't in 8.0.x ?
05:27:23 <cocreature> new-instal is in 2.2
05:27:38 <[exa]> I've got 2.0.0.1 from deb repos and new-install is there
05:27:41 <cocreature> but it only works for packages on hackage. not for installing executables from a local project
05:27:50 <cocreature> [exa]: afaik the command exists, it just doesn’t work :)
05:28:05 <[exa]> interesting
05:28:19 <[exa]> afaik it does what it should
05:28:29 <[exa]> maybe there's a bright future with a better new-install waiting for me!
05:28:33 <cocreature> hm maybe I’m just misremembering version numbers
05:28:42 <[exa]> (after debian bumps the version...........the wait continues.)
05:28:51 <cocreature> either way, if you use new-* you should at least use the latest version of cabal-install if not HEAD
05:29:01 <[exa]> ok
05:30:06 * hackage clash-prelude 0.99.3 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.99.3 (ChristiaanBaaij)
05:31:14 <joel135> I have installed the package but there is no executable in `~/.cabal/bin`.
05:31:43 <Soft> hmm Setup.hs script with custom hooks seems to be what I am looking for
05:32:03 <merijn> Soft: For what?
05:32:25 <Soft> I am trying to figure out how to invoke npm as a part of stack build
05:32:50 <Soft> I have a web thing where I would like to automatically build the frontend code when I invoke stack
05:33:03 <[exa]> joel135: cabal run?
05:33:23 <cocreature> joel135: how exactly have you installed it?
05:33:30 <joel135> `cabal install`
05:33:33 <[exa]> joel135: btw AFAIK it won't install in ~/.cabal if you have sandboxed it
05:34:20 <Soft> Although stack doesn't seem to invoke Setup.hs at all if the actual haskell sources haven't changed.
05:34:34 <joel135> I think I will just `cabal build` and use the `dist/...` path.
05:34:35 <[exa]> joel135: pkg/.cabal-sandbox/bin/ should work better
05:34:37 * hackage clash-lib 0.99.3 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.99.3 (ChristiaanBaaij)
05:35:12 <joel135> [exa]: yes
05:35:20 <joel135> cd ..
05:35:25 <joel135> oops
05:35:36 * hackage clash-ghc 0.99.3 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.99.3 (ChristiaanBaaij)
05:39:07 <Saulzar_> Hm - does anyone know if there are traversals for operating at multiple points of a data structure - e.g. can I transform over the 1st 3rd and 7th index in a list?
05:41:44 <Saulzar_> (Or if that is indeed possible?)
05:41:50 <dmwit> Should be possible.
05:41:56 <dmwit> Dunno if library support exists.
05:42:10 <dmwit> Are you planning to use lens?
05:42:34 <Saulzar_> Yeah
05:42:56 <cocreature> you could probably use "ifilter"
05:48:29 <Saulzar_> cocreature, thanks, seems to work..
05:48:33 <Saulzar_> > over (traversed . ifiltered (\i _ -> odd i)) (+5) [1,2,3]
05:48:35 <lambdabot>  [1,7,3]
05:57:54 <milesrout> is anyone here familiar with the haskell packages vty and/or brick?
05:58:58 <merijn> milesrout: "I've looked at them once" :p
05:59:44 <quchen> milesrout: My friend Franz (who’s not here) has used them quite a bit, he’s the author of vgrep, maybe get in touch with him? https://github.com/fmthoma/vgrep
06:02:08 <milesrout> cheers. might actually just open an issue on vty's github for now, i don't expect I'll get a very positive response tho :) breaking the abstraction a bit
06:02:32 <merijn> milesrout: What's the problem?
06:03:02 <milesrout> essentially I want to have some italics text in the terminal, but curses doesn't seem to support it, so neither do they. my solution of just inserting the ansi escape codes for italics directly does kind of work
06:03:25 <milesrout> but it has the problem that it makes their calculation of cursor positions and 'widget' width all wrong
06:03:46 <milesrout> because it thinks the string containing the zero-width font-attribute-altering characters is longer than it is
06:04:39 <merijn> milesrout: That's most likely not a bug in vty, but in the terminal
06:04:51 <merijn> milesrout: macOS by any chance?
06:05:10 <milesrout> no st, which is imfamously a bit beligerant. i'll try another terminal just to be sure
06:05:36 <milesrout> i don't even have another terminal installed lol
06:08:06 * hackage bit-protocol 0.1.0.0 - Encode binary protocols with some odd bit numbers into a bytestring  http://hackage.haskell.org/package/bit-protocol-0.1.0.0 (k_bx)
06:10:03 <milesrout> hmm no same in urxvt
06:10:46 <milesrout> https://asciinema.org/a/uOmHDlfcdX2fsa0hsHORoeHOG
06:13:10 <milesrout> back to using bold for variables I guess
06:14:06 * hackage record-dot-preprocessor 0.1.2 - Preprocessor to allow record.field syntax  http://hackage.haskell.org/package/record-dot-preprocessor-0.1.2 (NeilMitchell)
06:16:50 <merijn> I think I asked before, but is there a library that makes is somewhat convenient to call template C++ functions from Haskell?
06:18:01 <Saulzar_> merijn, inline-cpp?
06:18:09 <milesrout> stack haddock --open is FANTASTIC
06:18:12 <merijn> not instantiating the template, assume I've beat the C++ compiler into doing that, I just need to get the right mangled names to call them
06:18:17 <lavalike> milesrout: what does it do?
06:18:33 <merijn> Saulzar_: inline-cpp seems to have tons of stuff for dealing with objects and about 0 for dealing with templates
06:18:36 <milesrout> it opens the documentation for a particular package at the correct version that you are working with, locally
06:18:48 <milesrout> after automatically generating it if you hadn't done so already, as usual with stack
06:20:24 <merijn> Saulzar_: Also, inline-c-cpp seems to have no docs whatsoever
06:20:27 <milesrout> git checkout master
06:20:30 <milesrout> shit sorry
06:21:17 <mnoonan> merijn: it's pretty easy to hack on anyway
06:22:49 <mnoonan> I think the only reasonable options are using inline-c-cpp, or writing unmangled wrappers
06:28:28 <dminuoso> Are there any considerations to take when running a Haskell program as root?
06:28:50 <dminuoso> I mean beyond checking dependencies of course.
06:28:57 <merijn> dminuoso: Exactly the same ones as running any program as root?
06:29:54 <dminuoso> merijn: Alright. Just wanted to double check in case there were any non-obvious "Do not do this because <...>" reasons.
06:31:01 <pally> (>>=) (Foo (\s -> (s, Left EOF)))) f = ...
06:31:24 <pally> will Haskell match the "(Foo .." part?
06:31:37 * hackage ghc-typelits-presburger 0.2.0.1 - Presburger Arithmetic Solver for GHC Type-level natural numbers.  http://hackage.haskell.org/package/ghc-typelits-presburger-0.2.0.1 (HiromiIshii)
06:31:40 <merijn> pally: What do you mean by that?
06:32:54 <pally> pattern matching... another example would be `(>>=) Nothing f = Nothing`
06:33:19 <dminuoso> pally: You can only pattern match against: literals and data constructors
06:34:02 <dminuoso> pally: So `(>>=) (Foo f) g = ...` is the best you can do
06:34:17 <pally> dminuoso, what I need to do is to treat  "Left EOF"
06:34:41 <dminuoso> pally: Then feed `f` some input and pattern match with a case inside the body
06:35:03 <pally> dminuoso, alright
06:35:35 <pally> once in the body I will unFoo and use `case` statement
06:35:52 <dminuoso> pally: If you pattern match like I showed you, then no unFoo would be necessary
06:35:55 <dminuoso> (>>=) (Foo f) g = case f 1 of (_, Left EOF) -> ...
06:36:51 <pally> dminuoso, thanks :-)
06:43:36 * hackage record-dot-preprocessor 0.1.3 - Preprocessor to allow record.field syntax  http://hackage.haskell.org/package/record-dot-preprocessor-0.1.3 (NeilMitchell)
06:47:07 * hackage stackage2nix 0.7.2 - Convert Stack files into Nix build instructions.  http://hackage.haskell.org/package/stackage2nix-0.7.2 (typeable)
06:47:27 <Boarders> in tasty what is the best way to test for errors that functions should throw for certain inputs?
06:49:02 <lyxia> catch the exception, now you have just a function
06:51:17 <merijn> Boarders: I use HUnit (and tasty's wrappers for it) for that: https://github.com/merijn/broadcast-chan/blob/master/broadcast-chan-tests/BroadcastChan/Test.hs#L54
06:52:11 <pally> dminuoso, I guess I can add an `otherwise -> print "Hello world"`
06:52:39 <dminuoso> pally: Just remember that when implementing an instance of Monad that you need to respect its laws.
06:53:12 <dminuoso> pally: Based on the types it's unlikely that your implementation would work because you're implementing for the type of `Foo`, not IO
06:53:19 <dminuoso> So it would not typecheck
06:53:21 <pally> dminuoso, right, right.
06:53:33 <pally> dminuoso, I know about that. I got sloppy
06:53:42 <Boarders> merijn, lyxia: thanks
06:54:14 <pally> dminuoso, what I was asking was, an "otherwise" would match everything else except for `(_, Left EOF)`, right?
06:54:27 <dminuoso> pally: otherwise = True
06:54:29 <pally> sorry about that.
06:54:43 <dminuoso> :t otherwise
06:54:44 <lambdabot> Bool
06:54:46 <dminuoso> pally: Does this answer your question?
06:54:56 <dminuoso> pally: So it would still not typecheck.
06:55:30 <dminuoso> pally: Use an irrefutable pattern `_` if you want to deal with the other cases.
06:55:56 <pally> dminuoso, yep, that's what I was after.
06:56:02 <pally> :-)
07:06:00 <quchen> Nitpick, »_« is an unfailable pattern; »irrefutable pattern« is usually used in the context of tilde-prefixed patterns
07:06:09 <lorilan> cocreature, it works ! thank you
07:06:23 <quchen> > let f (Just x) = "Hello" in f Nothing
07:06:23 <dminuoso> quchen: nitpick back, its called irrefutable pattern in the report :P
07:06:25 <lambdabot>  "*Exception: <interactive>:3:5-24: Non-exhaustive patterns in function f
07:06:30 <quchen> > let f ~(Just x) = "Hello" in f Nothing
07:06:32 <lambdabot>  "Hello"
07:06:48 <dminuoso> quchen: even x in there is called an irrefutable pattern according to the report
07:07:10 <lorilan> to answer your question, if I don't mention zlib at all, I got an error : `Linking dist/build/rss-agg/rss-agg ... /nix/store/k8b9hqv58dd1z0j4ikak24ykndcm91s6-binutils-2.28.1/bin/ld: cannot find -lz`
07:07:43 <lorilan> I figured z must be zlib and tried to make the dependance explicit
07:08:07 <dminuoso> " The irrefutable patterns are as follows: a variable, a wildcard, N apat where N is a constructor defined by newtype and apat is irrefutable (see Section 4.2.3), var@apat where apat is irrefutable, or of the form ~apat (whether or not apat is irrefutable). All other patterns are refutable."
07:08:37 <quchen> dminuoso: Interesting. In the grammar, only ~ is called an irrefutable pattern, and in lots of other places as well.
07:08:44 <quchen> Anyway, nitpick refuted.
07:09:08 <cocreature> lorilan: huh, I don’t get that error if I remove it. from the cabal file and regenerate default.nix
07:09:09 <dminuoso> quchen: But yeah your point is valid, it's a bit inconsistent when you read the other usages of the word.
07:09:18 <quchen> In the GHC source it’s called an unfailable pattern though, and an irrefutable pattern is the tilde special case of it
07:09:42 <dminuoso> Interesting
07:09:56 <quchen> …or at least in the places I’ve looked at.
07:11:16 <dminuoso> quchen: What I find interesting is the choice of word `irrefutable` for what is essentially lazy pattern matching.
07:11:19 <quchen> > let f ~_ = "test" in f
07:11:21 <lambdabot>  error:
07:11:22 <lambdabot>      • No instance for (Typeable p0)
07:11:22 <lambdabot>          arising from a use of ‘show_M38140603021640017512339’
07:11:34 <dminuoso> I mean ~(a:as) is definitely refutable in the true sense of the word.
07:11:48 <quchen> Well, not during the pattern matching phase.
07:12:02 <dminuoso> quchen: What is the "pattern matching phase"?
07:12:22 <quchen> When the pattern is matched, as opposed to when the bindings are used when evaluating the RHS of the definition.
07:13:02 <monochrom> They didn't want to say "lazy" because they wanted to stay denotational. (See also how they went out of their way to say "non-strict".)
07:13:42 <quchen> o/ monochrom
07:14:33 <lorilan> cocreature, maybe it's because which nixpkgs we are using ? I tried to pin the nixpkg but several problem appeared so I dropped it
07:14:36 <monochrom> Don't forget that they also have mathematician tendency, so think of "simple group", "random variable" before you pick on "irrefutable pattern".
07:15:27 <quchen> Or »variable« :-þ
07:15:34 <lorilan> I was just trying to start fooling around with haskell and I ended up with a three days config trip … which has ended thanks to you !
07:15:37 <monochrom> Yeah!
07:15:41 <dminuoso> "variable" at least I can live with :P
07:16:03 <dminuoso> Though I've had to hear that from a coworker who complained about not being able to "vary a variable after its definition.."
07:16:10 <dminuoso> He told me "why call it a variable when its not variable"
07:16:12 <nshepperd1> It's irrefutable because instead of getting evidence that the pattern didn't match you get _|_
07:17:31 <dminuoso> nshepperd1: Oh.. that makes sense to me.. I think
07:20:22 <monochrom> The coworker is likely brainwashed on imperative programming because why don't they also pick on "function" "If rand(4) gives you a different answer every time, why is it a function?"
07:22:46 <quchen> »Why can’t you change a constant?«
07:23:07 <cocreature> lorilan: could be but I would be somewhat surprised by that. are you on linux? have you reconfigured after removing it? which changes did you make to remove it?
07:23:33 <lorilan> I'm on nixos
07:24:22 <lorilan> when I say remove, I just removed it from the cabal file and regenerated the default.nix
07:25:28 <lorilan> I
07:26:21 <lorilan> I'm trying to find the alterntate way you showed me to start nix-shell, something like `nix-shell -iA agg-rss.env`, but the history seems a bit short :(
07:26:35 <lorilan> what was it again ?
07:26:36 <polecat[m]> hello. so I am struggling with aeson, trying to parse a json map into a map. the problem is, the default instance for FromJSONKey does not work. simplified code: https://lpaste.net/29665781495103488 . the default implementation is commented out. i don't want to copypaste code from FromJSON instance in my real case.
07:26:38 <tdammers> quoting Doug Hofstadter: constants are variables too, just on a different scale
07:26:54 <tdammers> or rather, paraphrasing
07:28:03 <cocreature> lorilan: nix-shell -A rss-agg.env
07:28:27 <lorilan> yes thank just found it in my zsh history >_<
07:32:07 <cocreature> lorilan: also it’s not so much an “alternate” way. just running nix-shell is just wrong and I wouldn’t be surprised if that caused your error if you tried that after removing zlib
07:34:19 <lorilan> what do you mean "just running nix-shell is wrong" ? Is it it bad practice to setup a shell.nix to configure the dev env ?
07:35:25 <renzhi> I do stack intall intero, but it got undefined reference to 'ffi_prep_cif', but I do have libffi-dev installed. Any clue? I running ghc 8.4.3. Anyone were able to build intero with ghc 8.4.3?
07:35:48 <cocreature> lorilan: a shell.nix is totally fine. the problem is that you need to use the shell for the .env attribute (for Haskell packages) not for the package itself
07:36:00 <cocreature> you could change that in your shell.nix if you don’t want to pass -A
07:37:21 <noipmups> In mtl, inside ExceptT monad transformer, how can I call `IO (Either e a)` function to extract `a`?
07:38:02 <lyxia> ExceptT :: IO (Either e a) -> ExceptT e IO a
07:38:12 <lorilan> ok, that's the part that's confusing me as I said earlier. The haskell-nix tutorial do mention this point, however given my shell.nix, If I start it with just `nix-shell` or `nix-shell -A rss-agg.env` it works (now) either way …
07:38:55 <lorilan> anyway I haven't finish to read the nix pills, I'll figure it out later
07:39:21 <lorilan> now I'll enjoy the song of ghc type errors report :p
07:39:35 <noipmups> lyxia: How that differ from lift* functions?
07:40:28 <cocreature> lorilan: it works either way if you remove zlib? I thought that failed before?
07:40:51 <lorilan> no it works either way with zlib
07:41:32 <cocreature> my point is the fact that you need zlib suggests that something is broken :)
07:42:50 <noipmups> lyxia: Got it, thanks.
07:44:20 <lorilan> cocreature, so I removed zlib and tried to start the shell using `nix-shell -A rss-agg.env` and I also have the linking error `cannot find -lz`. My guess is that zlib is a dependency of one of my transitive dependencies
07:45:02 <cocreature> lorilan: yep but in that case you shouldn’t need to have to add it to your own deps. have you reconfigured?
07:45:19 <polecat[m]> renzhi (IRC): you should let intero-mode do the install for you
07:45:21 <cocreature> or maybe try a "cabal clean" just to be sure
07:46:08 <lorilan> "have you reconfigured?" = `cabal configure` ? nope, I'll try right away
07:46:37 <cocreature> yeah that’s what I meant by reconfiguring
07:47:42 <lorilan> still a linking error after a "successful" `cabal configure`
07:49:59 <cocreature> lorilan: tried a "cabal clean"?
07:50:06 <renzhi> polecat[m]: I did, it failed with the same error, so I tried to do it manually
07:51:43 <lorilan> cocreature, same …
07:52:09 <cocreature> lorilan: hm, I’m out of ideas. can you push your updated config and give me the exact commands you used here?
07:54:37 <lorilan> I pushed the config on a "no-zlib" branch
07:55:11 <lorilan> in this order I did :
07:55:13 <lorilan> nix-shell -A rss-agg.env
07:55:17 <lorilan> cabal clean
07:55:22 <lorilan> cabal configure
07:55:25 <lorilan> cabal build
07:55:26 <polecat[m]> renzhi (IRC): stack would pull proper ghc version anyways. i've had some problems with intero-mode, ended up with uninstall+install procedure. worked fine since then.
07:56:12 <lorilan> wait, I pushed but I forgot to commit >_<
07:56:33 <cocreature> that explains why the pkgconfig-depends line is still there :)
07:56:50 <lorilan> done
07:57:10 <renzhi> polecat[m]: you mean, uninstall intero-mode then install again?
07:57:16 <lorilan> indeed
07:59:26 <polecat[m]> renzhi (IRC): yes. i could not update it for some reason.
08:00:08 <renzhi> polecat[m]: ok, will try that. thnx
08:05:01 <cocreature> lorilan: very weird, I still can’t reproduce it so it might be a different version of nixpkgs after all.
08:06:52 <lorilan> cocreature, I don't see anything else. Now it works so I want to enjoy it a bit. Once I'm satisfied I'll try to pin the nixpkg
08:07:18 <lorilan> anyway even if it ends with a mystery you helped me a lot ! thank you very much
08:07:33 <cocreature> np
08:08:08 <pally> @let get [] = "it's empty"
08:08:10 <lambdabot>  Defined.
08:08:20 <pally> @let get (c:cs) = "it's not empty"
08:08:22 <lambdabot>  Defined.
08:08:36 <pally> > get []
08:08:39 <lambdabot>  error:
08:08:39 <lambdabot>      Ambiguous occurrence ‘get’
08:08:39 <lambdabot>      It could refer to either ‘Control.Monad.State.get’,
08:08:54 <pally> @let myget [] = "it's empty"
08:08:56 <lambdabot>  Defined.
08:09:01 <pally> @let myget (c:cs) = "it's empty"
08:09:02 <lambdabot>  Defined.
08:09:06 <pally> @let myget (c:cs) = "it's not empty"
08:09:07 <lambdabot>  .L.hs:172:1: warning: [-Woverlapping-patterns]
08:09:07 <lambdabot>      Pattern match is redundant
08:09:07 <lambdabot>      In an equation for ‘myget’: myget (c : cs) = ...
08:09:14 <xsperry> :-D
08:10:58 <pally> My question is, in order to support matching for both patterns [] and (c:cs)
08:11:14 <pally> I must have a function signature right?
08:11:25 <xsperry> you don't
08:11:40 <liste> pally: no, that's just a lambdabot thing
08:11:42 <pally> xsperry can you please show me sir?
08:11:53 <liste> pally: if you write it in a file it'll work
08:12:18 <xsperry> pally yes, what you pasted here should work
08:12:31 <pally> liste, okay, b/c it didn't work in ghci either
08:12:33 <xsperry> this is assuming that double myget (c:cs) definition was a mistake
08:12:44 <xsperry> (wasn't that lambdabot's issue?)
08:13:05 <pally> Prelude> get [] = print "it's empty"
08:13:05 <pally> Prelude> get (c:cs) = print "it's not empty"
08:13:21 <pally> Prelude> get []
08:13:21 <pally> *** Exception: <interactive>:41:1-35: Non-exhaustive patterns in function get
08:13:22 <drets> I think about rewriting some java tool which used by eclipse plugin on Haskell. Which limitations I may face? Will my binary work for all eclipse users? Or I would need to compile my haskell program in some special way, sorry for dumb question xD
08:13:36 <xsperry> pally, ah, you are typing that into ghci?
08:13:52 <pally> yes sir
08:14:17 <pally> lemme start a fresh instance of ghci and try one more time
08:14:33 <xsperry> IIRC multi-lined function definitions work in ghci, the new one just overrwrites the old one. try typing it in a file and then loading that file with ghci
08:14:43 <xsperry> do not work, even
08:14:58 <nshepperd1> Ghci treats declarations on separate lines as separate shadowing declarations
08:15:16 <nshepperd1> Presence of a type signature has nothing to do with it
08:15:39 <nshepperd1> If you put it on one line with a semicolon in between, it will work
08:16:51 <liste> drets: you'd need to bundle a separate binary for each platform your eclipse plugin runs on
08:17:13 <pally> nshepperd, awesome
08:17:31 <liste> pally: you can also use :{ and :} for multi-line blocks in ghci
08:20:01 <drets> liste, thanks, by platform you meant windows, linux, unix, right? :)
08:20:29 <liste> drets: yes, also x86, x86_64, ARM
08:29:31 <dminuoso> How do TH folks learn how code is represented? Is it common to just run an expression quotation containing code you want to build through `runQ` and show it?
08:29:36 <dminuoso> Or is there some good documentation anywhere?
08:32:55 <mniip> dminuoso, I just walk around the docs for the AST datatypes involved
08:38:20 <drets> liste, I've got crazy idea, not sure whether it's doable. Create haskell tool, and then call it using eta lang, so then I can avoid building for all platforms.
08:38:28 <dminuoso> mniip: Fair enough.
08:41:23 <liste> drets: yes, that'd be the solution if eta works well enough for you
08:46:14 <c_wraith> dminuoso, is the combination of the haskell grammar and the data structures in Language.Haskell.TH.Syntax not enough?
08:49:49 <glittershark> Does Coercible not work for phantom type parameters using TypeInType?
08:50:07 <glittershark> I'd expect https://lpaste.net/1928633671036698624 to compile, but it gives a type mismatch error
08:55:24 <cocreature> glittershark: looks like it might be a bug
08:55:36 <glittershark> ok
08:55:42 <c_wraith> glittershark, I think the problem is that with very similar code, coerce would actually be wrong there
08:55:45 <glittershark> that's what I thought too
08:55:57 <c_wraith> if Foo was a GADT, for instance
08:56:13 <glittershark> I opened a ticket on Trac, just figured I'd ask here too to see if I was doing something wrong or misunderstanding
08:56:27 <c_wraith> or even if Foo's type parameter wasn't phantom
08:56:30 <glittershark> c_wraith: it's a GADT in my codebase, actually :)
08:56:48 <glittershark> what I've got is potentially a little hairier
08:56:50 <c_wraith> well then it's definitely not correct to allow coerce to just change it
08:57:07 <c_wraith> because it's a dependent kind
08:57:24 <glittershark> it's phantom on the two Foo constructors I'm coercing though
08:57:33 <glittershark> just not on some of the other constructors
08:57:56 <c_wraith> I think asking coerce to determine that automatically is too much
08:58:10 <glittershark> it's definitely hard, but seems decidable at least
08:58:16 <c_wraith> coerce gets as far as "there are cases this can fail" and stops
08:58:25 <glittershark> maybe it's a feature request rather than a bug then
08:58:40 <c_wraith> I'd categorize it that way
08:59:08 <glittershark> this is closer to what I'm doing: https://lpaste.net/7093038463850643456
08:59:16 <glittershark> still seems sound to me
09:00:06 <c_wraith> it's sound, but I can see why no one wanted to write the code to verify it automatically
09:00:25 <glittershark> sure :P
09:00:51 <glittershark> I can just re-apply the Bar constructor, it's fine
09:00:57 <glittershark> or unsafeCoerce or something
09:01:06 <c_wraith> yeah, both work
09:01:38 <c_wraith> probably best to not unsafeCoerce if you ever envision changing it in the future.
09:02:14 <c_wraith> re-applying the constructor has the benefit of verifying you got it right. :)
09:02:39 <glittershark> oh, yeah, it's definitely gonna change in the future
09:03:12 <glittershark> this is a codebase with 10 people on it, I'm not gonna introduce a segfault :P
09:15:40 <noipmups> Consider function `attemp :: Int -> IO (Maybe a) -> IO (Maybe a)` which tries to evaluate monad N times before it returns Nothing (or returns `Just` as soon as monad succeed). How body of that function could look like?
09:17:23 <cocreature> noipmups: you could just go for a recursive function that counts down the argument until it reaches zero or finds a Just
09:19:02 <noipmups> <cocreature>: And is possible to write at more generally? How should I substitute `Maybe`?
09:19:25 <cocreature> more general in what way?
09:19:34 <cocreature> I don’t understand what you mean by “substitute Maybe”
09:20:29 <noipmups> cocreature: To for example use this function with Either.
09:20:48 <cocreature> you could generalize it to Alternative
09:21:05 <hololeap> noipmups: you might want to look at the Alternative/MonadPlus typeclasses, which generalize failure in monads
09:21:35 <noipmups> Ok, thanks.
09:21:48 <cocreature> @let attempt n a = asum (replicate n a)
09:21:49 <lambdabot>  Defined.
09:21:51 <cocreature> :t attempt
09:21:53 <lambdabot> Alternative f => Int -> f a -> f a
09:22:15 <cocreature> :t \n a -> runExceptT (attempt (ExceptT a))
09:22:17 <lambdabot> error:
09:22:17 <lambdabot>     • Couldn't match expected type ‘ExceptT e1 m1 a1’
09:22:18 <lambdabot>                   with actual type ‘f0 a0 -> f0 a0’
09:22:21 <cocreature> :t \n a -> runExceptT (attempt n (ExceptT a))
09:22:23 <lambdabot> (Monoid e, Monad m) => Int -> m (Either e a) -> m (Either e a)
09:22:33 <cocreature> :t \n a -> runMaybeT (attempt n (MaybeT a))
09:22:34 <lambdabot> Monad m => Int -> m (Maybe a) -> m (Maybe a)
09:23:01 <hololeap> noipmups: Alternative is in Control.Applicative btw
09:23:20 <cocreature> to make things confusing, asum is in Data.Foldable :)
09:31:03 <hololeap> > runExceptT empty :: IO (Either () ())
09:31:05 <lambdabot>  <IO (Either () ())>
09:33:56 <hololeap> > print "Hi"
09:33:59 <lambdabot>  <IO ()>
09:34:20 <hololeap> guess it doesn't like IO?
09:34:30 <mniip> you can use yahb for that
09:42:34 <hololeap> how?
09:43:27 <cocreature> % print "Hi"
09:43:28 <yahb> cocreature: "Hi"
09:47:47 <chiku> Hello
09:48:16 <lambdabot> Hello.
09:49:24 <chiku> Lambada!
09:51:20 <dstolfa> Hello
09:51:27 <dstolfa> lambdabot: screw you!
09:52:20 <chiku> What time is it there rn dstolfa
09:53:00 <blahhh> I have Haskell Platform 8.4.3 64 installed on Windows 10. I did cabal update. cabal install ... gives the following error: https://pastebin.com/n6kdn6bb according to  https://github.com/DanielG/ghc-mod/issues/908 the error should be fixed, but it fails to compile. What can I do?
09:54:11 <glguy> blahhh: Why do you think that that issue URL relates to the error?
09:54:14 <lambdabot> dstolfa: bolt you!
09:54:44 <blahhh> glguy, because it is about ghc-syb-utils-0.2.3.2?
09:54:58 <dstolfa> chiku: where exactly
09:55:12 <dstolfa> chiku: i'm currently not in the UK, but in the UK it's almost 6
09:55:44 <glguy> blahhh: That issue is for a different version of GHC, as far as I know ghc-mod doesn't work with the current version of GHC (which you have)
09:56:02 <chiku> Almost 10:30 here
09:56:26 <blahhh> glguy, and my problem with ghc-syb-utils?
09:56:42 <glguy> also doesn't appear to work with GHC 8.4
09:56:59 <blahhh> ok
09:57:10 <glguy> The author decided not to capture that information in the version constraints
09:57:21 <blahhh> in the first place, I wanted to install hsdev for SublimeHaskell
09:57:34 <blahhh> then this error ocuured
09:59:54 <pally> I really need help figuring out this compiler error message
09:59:55 <pally> https://lpaste.net/3346502379464818688
10:00:19 <pally> Line of interest, 15 and 31
10:01:07 <glguy> pally: (s1, Right a) ->
10:01:09 <blahhh> Is it possible to use hsdev with GHC 8.4.3?
10:02:49 <pally> glguy, wow
10:03:19 <pally> glguy you are a fu*kin genius.
10:03:35 <pally> but i think you already know that.
10:03:51 <blahhh> according to https://github.com/mvoidex/hsdev/blob/master/hsdev.cabal it should be possible?
10:04:19 <glguy> blahhh: chasing after tools like ghc-mod or hsdev is a neverending bit of disappointment, you spend your time trying to get them working and waiting for them to catch up to version changes or from being abandoned
10:04:35 <pally> glguy, I want to ask you about it, because I am destined to run into similar situation and pull my hair out if I don't
10:04:58 <pally> when I did `case  f s0` on line 13
10:05:09 <blahhh> glguy, I see. Which Haskell IDE do you recommend for Windows?
10:05:25 <glguy> I don't recommend an IDE, I recommend a good text editor and ghcid
10:05:38 <pally> and tried pattern-matching it with `(s1, a)`,
10:06:03 <pally> why didn't it match ("pick up") the "Right" as well?
10:06:07 <sclv> note that in general ide-like tools always lag behind versions of ghc, as glguy says
10:06:21 <sclv> so if you want to use the latest version of the compiler and tooling, then you're typically out of luck
10:06:22 <glguy> pally: It did, but you then attempted to apply 'g' to 'a'
10:06:40 <blahhh> glguy, Thanks! I will try ghcid.
10:06:47 <glguy> and "g :: a -> ...", but you were applying it to a value with type "Either Exception a"
10:07:07 <glguy> for that to make sense  'a' and 'Either Exception a' would have to be the same type
10:07:35 <glguy> but that'd be a type like "Either Exception (Either Exception (Either Exception (....
10:07:47 <glguy> and Haskell doesn't allow for infinite types like this
10:35:09 <pally> glguy https://lpaste.net/5649502502580649984
10:35:20 <pally> this one would be easy for you to figure out.
10:35:53 <pally> data Exception = EOF | Other String deriving (Eq, Show)
10:36:33 <droplet> Is there a way to setup a package.yaml file to get stack to build multiple executables?
10:36:41 <pally> the signature for `throw` is     `throw :: Exception -> f a`
10:38:14 <fishythefish> feels like there should be a constraint on that `f`
10:38:48 <droplet> Stack doesn't seem to like when it's not called Main.hs
10:41:32 <pally> fishythefish, ahh... you might be right.  the signature for `get` is ` get :: f Char`
10:41:46 <fishythefish> that should probably also have a constraint on `f`
10:42:16 <fishythefish> e.g. the signature for `fmap` is not `(a -> b) -> f a -> f b`, it's `Functor f => (a -> b) -> f a -> f b`
10:42:24 <cocreature> droplet: you can use different source dirs but afaik stack should work just fine with different file names for the Main module
10:54:06 <fresheyeball> is there a way I can assert that a peice of code does _not_ typecheck?
10:54:20 <fresheyeball> I want to write a test, so that it would fail if a certain expression typechecks
10:54:25 <fresheyeball> IE I want to BAN something
10:54:41 <shapr> err
10:54:54 <shapr> maybe something with defer type checking?
10:54:56 <shapr> golly that sounds exciting
10:55:31 <lyxia> shapr++
10:56:03 <sternmull> you could just call the compiler and assert it fails and tells the expected error message
10:58:02 <fresheyeball> sternmull: how can I do that? Do you mean I can do it in Haskell code? or do I need to spawn a compiler sub process?
10:58:46 <sternmull> fresheyeball: Yes i mean calling GHC as subprocess and evaluating its exit code and stderr/stdout.
10:59:25 <fresheyeball> sternmull: how would that work given cabal file and all?
10:59:53 <fresheyeball> is there a way I can say, "this type may not have X instance"
11:00:02 <cocreature> fresheyeball: https://hackage.haskell.org/package/should-not-typecheck
11:00:05 <fresheyeball> I just want to assert that a typeclass instance cannot exist
11:00:20 <fresheyeball> cocreature: I love you
11:01:47 <sternmull> yes, that is probably the cooler solution :)
11:02:09 <cocreature> fresheyeball: I love you too <3
11:05:30 <nshepperd> you could add a superclass to the typeclass that is actually a type family that resolves to an error for the instance that shouldn't exist
11:06:13 <nshepperd> type family Allowed x where {Allowed Foo = TypeError "blah"; Allowed x = ()}
11:06:28 <nshepperd> class Allowed x => MyClass x where ,,,
11:06:48 <nshepperd> i dunno if that actually works but it would be cool if it does
11:14:22 <Boarders> if I am in the IO monad and I have a function that returns 'error "blah blah"' how can I catch something like that?
11:14:43 <Boarders> or is it just not possible?
11:14:52 <geekosaur> Control.Exception.catch, exception type is ErrorCall
11:15:01 <Boarders> oh ok, thank you
11:15:26 <geekosaur> it suggests a misdesigned API, though; if you intend to catch things like that, ExceptT might be better from the start
11:15:41 <geekosaur> exceptions should be, well, exceptional
11:16:11 <Boarders> yeah, I don't love it
11:25:04 <funrep_> do you guys suggest using attoparsec, megaparsec or parsec? i plan to use it to parse a ML-like language
11:27:06 * hackage cabal-helper 0.8.1.0 - Simple interface to some of Cabal's configuration state, mainly used by ghc-mod  http://hackage.haskell.org/package/cabal-helper-0.8.1.0 (DanielG)
11:29:51 <sayola> sooo ... is haste dead?
11:30:08 <cocreature> funrep_: megaparsec
11:34:34 <droplet> How can I get optparse-applicative to take negative numbers as positional arguments?
11:35:01 <droplet> It's currently misunderstanding them as options
11:46:39 <fishythefish> droplet: are you quoting the number when you pass it in?
11:47:21 <revskill> my haskell web has performance 45000 req/s, is it good enough ?
11:48:25 <int-e> revskill: it depends on how many requests per second you get...
11:48:26 <dysfun> that depends how many req/s you need to handle
11:48:49 <revskill> what do you mean ? I use wrk to bench
11:48:59 <revskill> 12 threads and 400 connections
11:49:14 <dysfun> it's enough if you don't get more than 45k requests/second
11:49:16 <geekosaur> it's not about benchmarks, it's about the load you expect in production
11:49:22 <monochrom> Is a half-full cup of coffee enough or too little? :)
11:49:41 <int-e> monochrom: yes is a good guess in that case
11:49:43 <dysfun> for many businesses, 45 requests per second would be a nice problem to have
11:50:03 <doyougnu> anyone in here ever used the Tasty testing framework?
11:50:06 <revskill> ah, just to surprise my boss, it's real production use case ;)
11:50:16 <chreekat> doyougnu: daily
11:50:41 <doyougnu> chreekat: best practices for monadic quickcheck properties?
11:51:21 <chreekat> sayola: probably dead. See Elm, Purescript, or ghcjs instead. ghcjs is the one we wall want to love, but Elm and Purescript get lots of actual love
11:53:54 <chreekat> doyougnu: dunno. :) Do you need something more than testProperty . ioProperty ?
11:55:33 <sayola> chreekat: thank you. i hope ghcjs will work for me. i saw the ghc 8.x branches. are they stable enough?
11:57:05 <chreekat> sayola: someone else can probably say better than I
12:03:04 <doyougnu> chreekat: that worked. Thanks for the help. Wasn't aware of ioProperty
12:04:01 <tnks> I'm trying to think more deeply about this.  Is there a difference between defining `fix f = f (fix f)` and the let-recursive way it's defined in Data.Function?
12:04:22 <tnks> I mean semantic/least-bounds-wise.
12:04:25 <c_wraith> tnks, in terms of meaning no.
12:04:37 <tnks> c_wraith: what about with respect to least bounds?
12:04:46 <c_wraith> tnks, the definition is just about avoiding recomputation sometimes.
12:04:54 <c_wraith> same least bound.
12:05:11 <c_wraith> it wouldn't be a correct implementation if the least bound wasn't the same.
12:05:44 <tnks> c_wraith: okay, that makes sense.  I think I'm misthinking what "least bound" means, which I think I understand now.
12:06:05 <tnks> What's a nice example of where recomputation happens in one, but not the other?
12:06:22 <c_wraith> > fix (1:)
12:06:25 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:07:38 <c_wraith> with the naive implementation, that creates an extra (:) constructor in memory for each time you pattern match
12:08:16 <c_wraith> the knot-tying implementation reuses the same (:) constructor, creating a circular linked list in memory
12:08:39 <tnks> c_wraith: thanks for the simple example.  I think I follow... just need to do the evaluation in my head or on paper for it to stick.
12:08:58 <c_wraith> yeah, you absolutely need to trace it yourself to really see
12:09:45 <tnks> c_wraith: beyond a piece of paper, is there any tool you use to see this stuff?
12:10:48 <c_wraith> sometimes I use the vacuum library. I think there's a modern replacement for it, but I can't recall the name of it.
12:10:57 <tnks> thanks.
12:11:44 <c_wraith> note that when working with infinite structures and vacuum, you *really* want to use the vacuumLazy function.
12:12:41 <tnks> c_wraith: I can imagine why that would be the case.
12:13:14 <int-e> oh ghci's :print doesn't like circular structures either
12:29:37 * hackage numtype-dk 0.5.0.2 - Type-level integers, using TypeNats, DataKinds, and Closed Type Families.  http://hackage.haskell.org/package/numtype-dk-0.5.0.2 (BjornBuckwalter)
12:33:06 * hackage wordexp 0.2.1 - wordexp(3) wrappers  http://hackage.haskell.org/package/wordexp-0.2.1 (MatveyAksenov)
12:38:23 <Boarders> if I have (f = const $ error "ahh") :: Int -> Int
12:38:41 <Boarders> and I want to catch f 5 in IO how can I do it?
12:38:59 <monochrom> Look for Control.Exception.evaluate
12:39:12 <Boarders> I tried using try but I get back: Right *** Exception: ahh
12:39:41 <Boarders> ah ok, thank you
12:42:27 <geekosaur> you may need to do more to force it as well; this is laziness biting you
12:42:48 <geekosaur> sometimes you want rnf to explode deeply buried bottoms
12:43:14 <geekosaur> (while still running in the exception handler)
12:43:57 <nitrix> What's that trick Haskell has again for fast string concatenation?
12:44:38 <c_wraith> you mean for not going O(n^2) on n concatenation?
12:44:45 <nitrix> It's something akind to building a large thunk of function application.
12:44:52 <nitrix> Yeah.
12:44:52 <liste> nitrix: difference lists are for fast list concatenations, did you mean that?
12:45:00 <geekosaur> they want ShowS
12:45:06 <nitrix> ShowS! Thank you.
12:45:12 <mniip> ShowS is a kind of difference list
12:45:15 <exio4> nitrix: liste's solution is basically using (String -> String) functions, and then composing them
12:45:16 <geekosaur> note that that only works if you build the list in the right order
12:45:35 <nitrix> So the general concept I'm after is named difference list :]
12:45:38 <liste> https://wiki.haskell.org/Difference_list
12:45:53 <nitrix> Mhm. I want to use it outside of Haskell, it was a brilliant idea :)
12:46:14 <monochrom> Every language that supports functions can do it.
12:46:30 <monochrom> (So for example BASIC doesn't.)
12:46:43 <geekosaur> there are versions of BASIC with functions
12:46:55 <shapr> nitrix: rope data structure? https://en.wikipedia.org/wiki/Rope_(data_structure)
12:47:47 <nitrix> shapr: I had already my eyes on ropes but I suddently rememembered ShowS and wanted to compare the time complexity on the operations :P
12:47:57 <shapr> nitrix: ah, I want to hear the results
12:48:20 <nitrix> shapr: It's in C though ;~;
12:48:59 <monochrom> Oh I should put ropes on the exam!
12:50:35 <nitrix> The thing is that ropes have to stay balanced to work, different lists just stays in the thunk form with no penalty.
12:50:57 <nitrix> Assuming no manipulations are done during the "building phase", I wouldn't be surprised to see difference lists do better.
12:51:38 <shapr> nitrix: publish a blog post?
12:51:45 <nitrix> heh :P
12:51:57 <c_wraith> on the other hand, difference lists are bad when you need to inspect the list while building it.
12:52:09 <shapr> nitrix: ok, what about a github repo that gives numbers and source where I could clone it and compare myself?
12:52:20 <shapr> nitrix: I put up something last night: https://github.com/shapr/usehaskellfromc
12:52:23 <shapr> needs to be a blog post
12:53:54 <nitrix> Oh I don't intend to use it with Haskell, I'm just stealing the idea >:3
12:54:16 <nitrix> Muahahahahah......
12:54:18 <shapr> fair enough
12:54:23 <droplet> fishythefish: that works, thanks
13:01:36 * hackage exact-pi 0.4.1.4 - Exact rational multiples of pi (and integer powers of pi)  http://hackage.haskell.org/package/exact-pi-0.4.1.4 (Bodigrim)
13:13:07 <Boarders> is there a function diag :: a -> (a , a) in base?
13:14:25 <glguy> I don't think so
13:15:21 <glguy> You could do 'join (,)' or 'id &&& id' but it would be better to just write it out
13:19:21 <mniip> I wouldn't hesitate to write 'join (,)'
13:19:36 <Boarders> the, square = join (*) trick is funny to me
13:19:52 <Boarders> tbh I have to parse how the pointfree works so I wouldn't write it
13:20:16 <Boarders> can't do type inference in my head 0_o
13:20:38 <glguy> You'll want to learn how to do type inference in your head if you're going to write much Haskell
13:22:09 <Boarders> I have written quite a lot of haskell
13:23:04 <Boarders> given that I know join f $ a = f a a, you would think it would be clear that I can do the type inference and am just using exaggeration ...
13:23:58 <glguy> I don't think that makes it clear, just that you know that one pattern, but it's good that you actually understand how to do type inference
13:24:56 <Boarders> idk on the internet if you use self-deprecation people think it is a good time to treat you like a moron tbh
13:25:16 <glguy> Yeah, it's not a technique that works well when people don't know you well
13:26:23 <selfsymmetric-pa> What's the canonical diagonal functor in Haskell? It can't be `(,)`, right, since that takes two type parameters instead of one?
13:26:33 <selfsymmetric-pa> That is, `(,)` is a Bifunctor, not a Functor.
13:28:48 <phadej> something like data D a = D a a?
13:29:27 <glguy> linear package has V2
13:29:34 <phadej> I use V2 from `linear`, at least when I  need to try something; but that's quite heavy dep for just that
13:29:48 <selfsymmetric-pa> Oh neat. Thanks!
13:30:17 <phadej> I might also end up using Vec Nat2 (from my `vec` and `nat` :)
13:30:59 <phadej> (linear's V2 is data V2 a = V2 !a !a, which might be no go for you)
13:31:47 <phadej> sorry, `fin` - I forget names of my packages :/
13:35:56 <pally> https://lpaste.net/2149244773569921024
13:36:04 <pally> there is a parse problem at the first =
13:37:11 <glguy> line 3 has too many ) and not enough (
13:38:08 <pally> glyguy, same problem persists
13:38:36 <glguy> pally: then you have more than one issue. it'll help if you include any error messages you're asking for help with in the paste, too
13:39:04 <pally> sure, but that's the only emitted error
13:39:47 <pally> https://lpaste.net/3048629290632478720
13:40:29 <pally> glguy ^
13:41:02 <pikajude> is MonadReader a common abstraction to replace passing 8 different function arguments around multiple functions
13:41:11 <glguy> pally: You haven't pasted the code that has the bug, then
13:41:52 <glguy> pikajude: Records are good for that
13:42:06 <pally> glguy  code compiles when I comment out those three lines,
13:42:28 <glguy> pally: That's fine, but the cose you pasted parses, so without the context we can't help
13:42:34 <glguy> the code*
13:42:36 * hackage heartbeat-streams 0.1.0.1 - Heartbeats for io-streams  http://hackage.haskell.org/package/heartbeat-streams-0.1.0.1 (LukeHoersten)
13:42:57 <pikajude> oh, that's right glguy
13:43:00 <pikajude> good point
13:43:04 <pikajude> i don't know how that escaped me
13:45:36 * hackage hgrev 0.2.3 - Compile Mercurial (hg) version info into Haskell code  http://hackage.haskell.org/package/hgrev-0.2.3 (LukeHoersten)
13:48:12 <pally> glguy check pm for link
13:48:31 <glguy> catch and throw should be on the same column
13:49:36 * hackage seqid 0.5.3 - Sequence ID production and consumption  http://hackage.haskell.org/package/seqid-0.5.3 (LukeHoersten)
13:50:51 <pally> glguy I am just trying to convert the commented block immediately above to use the `let in case`
13:51:11 <pally> glguy, the commented out code immediately above works
13:51:31 <orion> http://hackage.haskell.org/package/seqid-0.5.3 (LukeHoersten)
13:51:37 <orion> disregard
13:52:37 <glguy> pally: OK, did you try ensuring that catch was indented 4 spaces like throw above?
13:53:01 <pally> checking
13:53:02 <glguy> pally: That will fix your parse error and give you a type error
13:53:42 <glguy> pally: You're trying to case on 'result' which has a function type with a tuple pattern
13:56:11 <pally> glguy  `(\s0 -> prog1 s0)` evaluated result to be saved in the local variable `result`
13:56:27 <pally> the evaluated result is a tuble
13:56:30 <pally> tuple
13:57:12 <pally> glguy as you can see in the above code (which works) actually matches.
13:57:37 <glguy> Sure, but the code above uses a different syntax that means something different from the syntax below
13:59:03 <pally> glguy, how do I fix it?  ultimately, I want to add separate "case"/pattern which I need to handle
14:00:40 <pally> glguy, the comments -- in words-- actually describes what I want to achieve
14:02:36 * hackage seqid-streams 0.6.3 - Sequence ID IO-Streams  http://hackage.haskell.org/package/seqid-streams-0.6.3 (LukeHoersten)
14:03:54 <pally> glguy, I am hung up on this last method which requires implementation.
14:05:36 * hackage unagi-streams 0.2.4 - Unagi Chan IO-Streams  http://hackage.haskell.org/package/unagi-streams-0.2.4 (LukeHoersten)
14:12:05 <pally> glguy, still stuck
14:20:03 <fishythefish> pally: might help if you post the relevant code in the channel - glguy may be busy and others can help
14:24:10 <pally> fishythefish, sure
14:24:14 <pally> I'll do that
14:25:15 <pally> fishythefish, https://lpaste.net/8499973426788696064
14:26:24 <pally> fishythefish, problem with converting the `catch` on line 17 from the commented out version
14:26:34 <pally> fishythefish, the commented out version works.
14:26:52 <pally> fishythefish, if you read the comments -- in words -- you'll see what I am trying to achieve
14:27:29 <pally> ultimately I need to match another "case", and handle it
14:27:34 <fishythefish> pally: okay, are you just stuck on the implementation, or do you not understand what the error is trying to tell you?
14:27:52 <pally> fishythefish, I am okay with implementation.
14:28:09 <fishythefish> pally: also, what is wrong with the commented version?
14:29:36 <pally> the error messages, read the comments just above the commented out version.
14:30:05 <pally> fishythefish, if you could fix the problem on line 17that'll be great.
14:30:11 <fishythefish> the comments tell me what you intend, they don't tell me what your issue with that version is
14:30:33 <fishythefish> pally: i'd love to, but your intent isn't clear to me
14:31:26 <pally> fishythefish, I need to consider a separate case, currently with the commented out version it' wrapped inside a "FeederOf" and it's also part of a lambda body
14:31:42 <fishythefish> so just add another branch to the case statement?
14:32:12 <fishythefish> I shouldn't say "statement"
14:32:27 <fishythefish> `case` constructs are expressions - hence, it doesn't matter that's it's wrapped inside a constructor and lambda body
14:33:25 <pally> fishythefish, the other case I need to consider is `(_, Left e)`, and then run `handler`
14:33:30 <chreekat> the not-commented code doesn't compile, right? It looks like you have an unevaluated lambda in the case expression
14:33:31 <fishythefish> okay, so write that
14:33:45 <fishythefish> are you confused about where to put it?
14:34:09 <pally> fishythefish, I am having issues with line 17
14:34:30 <fishythefish> pally: you're having issues with line 18 because you're trying to pattern match a function
14:34:33 <fishythefish> i'm trying to get to the heart of your issue
14:34:39 <pally> cheekat, the user will provide the string.
14:34:51 <fishythefish> your old version doesn't prevent you from adding more cases but you seem to think it does
14:35:28 <chreekat> pally: the user can't provide a string to a program that doesn't compile. :)
14:35:51 <pally> chreekat it's a recipe.
14:36:10 <chreekat> But I think fishythefish is right. your problem with line 17 is that you don't need it, or lines 18 or 19 either
14:36:22 <fishythefish> if you must factor out the definition of result, you probably want something like `let result s0 = case prog1 s0 of ...`
14:36:43 <fishythefish> you can't pattern match on `result` itself because it's a function
14:38:58 <pally> fishythefish, yes. I said wanted to convert to a `let` b/c I don't want to work within (wrapped within)  FeederOf
14:41:58 <chreekat> pally: I think I see what you're trying to do. One way of looking at the problem is that the two 's0' you have are completely unrelated except they have the same names
14:42:43 <pally> fishythefish, I believe you mean `(\s0 -> let case prog1 s0 of ... `
14:44:09 <fishythefish> pally: why do you believe I meant that
14:44:24 <fishythefish> (also, what is `let case`?)
14:44:37 <pally> oops
14:45:07 * hackage prometheus 2.0.1 - Prometheus Haskell Client  http://hackage.haskell.org/package/prometheus-2.0.1 (LukeHoersten)
14:45:39 <pally> `(\s0 -> let result s0 = case prog1 s0 of ... `
14:46:08 <fishythefish> I don't know where you think that lambda is supposed to appear
14:46:11 <chreekat> if you want to wait to the end to use FeederOf (which I actually don't really recommend), you could do,     catch (FeederOf prog1) handler  = let prog2 s0 = ...  in FeederOf prog2
14:47:04 <fishythefish> you understand that `let result s0 = ...` doesn't require a lambda to first bind `s0`, right?
14:49:30 <pally> trying that now
14:55:07 <pally>     catch (FeederOf prog1) handler = let result s0 = case prog1 s0 of
14:55:08 <pally>                                        (s1, Right a) -> FeederOf (\s0 -> (s1, Right a))
14:55:29 <pally> parse error on input ?(?
14:55:54 <pally> the first '(s1' occurence
14:58:47 <chreekat> pally: I can see what you're thinking, but I don't know how to explain the issue with it. :) Maybe like this: You need to give a function to FeederOf to make it complete. You are giving it a function on the right side of the last arrow -- the function "(\s0 -> (s1, Right a))"
14:59:58 <chreekat> So right there, you have a complete value of FeederOf. Except there are two things wrong with it: one, s1 isn't defined at all. Two, it is completely unrelated to the rest of the function that you are *trying* to write
15:00:21 <jbetz> does getting source position of runtime errors still require that you build with profiling?
15:00:21 <chreekat> What you need to do is write the whole function first, and then pass *that* to FeederOf
15:00:48 <jbetz> and by "still" I mean, ghc 8+
15:16:13 <pally> catch (FeederOf prog1) handler = let result s0 = case prog1 s0 of
15:16:13 <pally>   (s1, Right a) -> FeederOf (\s -> (s1, Right a))
15:16:20 <pally> what is the parse error though?
15:17:22 <pally> error: parse error on input ?(?  at  (s1, Right a) -> FeederOf (\s -> (s1, Right a))
15:21:43 <fresheyeball> is it possible to write a function
15:21:48 <fresheyeball> Rational -> String
15:22:09 <fresheyeball> so that the result is a lazy string of the decimals, even if there is an infinite number of decimals?
15:22:31 <pally> catch (FeederOf prog1) handler = let result s0 = case prog1 s0 of
15:22:31 <pally>  <pally>   (s1, Right a) -> FeederOf (\s -> (s1, Right a))
15:22:43 <pally> err
15:22:46 <pally> catch (FeederOf prog1) handler = let result s0 = case prog1 s0 of
15:22:50 <monoidal> fresheyeball: yes
15:22:56 <pally> (s1, Right a) -> FeederOf (\s -> (s1, Right a))
15:23:14 <pally> can someone spot why there is a parse error ?
15:23:32 <pally> error: parse error on input ?(?  at  (s1, Right a) -> FeederOf (\s -> (s1, Right a))
15:23:32 <fresheyeball> monoidal: can I get a hint? I don't see how to take (Integer, Integer) and constuct a lazy list of Char
15:24:13 <fresheyeball> pally: can you make a gist or hastebin? with both the error and the code?
15:24:32 <fresheyeball> pally: likely the error is in surrounding code
15:25:03 <fishythefish> I'm guessing it's indentation
15:25:16 <fishythefish> e.g. is the next line indented at least as far as `result` on the line above?
15:25:19 <monoidal> fresheyeball: it'll be a stream of digits representing long division
15:25:21 <pally> https://lpaste.net/6959293508670717952
15:26:30 <monoidal> fresheyeball: there's also a less efficient way that's simpler to explain. You can obtain the N-th decimal digit by getting (10^N*p `div` q) `mod` 10.
15:26:47 <monoidal> fresheyeball: and then you can convert a function Integer -> a to a lazy infinite stream [a]
15:27:04 <monoidal> it's not efficient though, you can consider this as a warmup to the efficient solution
15:27:06 <fresheyeball> pally: you are missing `in` for your `let`
15:28:26 <monoidal> fresheyeball: try dividing 1/7 on paper, and you might get a feel of how the stream of digits 0.142857... is constructed
15:30:44 <fresheyeball> monoidal: really? I should divide into digits?
15:31:02 <chiku> Hey I need help with something, I'm sure it's a simple question, anyone?
15:31:10 <fresheyeball> chiku: just ask
15:31:26 <chiku> So I just discovered IRC
15:31:57 <chiku> Is JH nickname unique in all servers like be it freenode or efnet
15:32:07 <monoidal> fresheyeball: the inefficient solution will be something like [(10^n*p `div` q) `mod` 10 | n <- [1..]]
15:32:21 <monoidal> fresheyeball: but it's slow and long division is much better
15:32:42 <chiku> Or do I have to make a separate and possibly a different one for each server
15:34:44 <chreekat> chiku: yeah, freenode and efnet are separate networks. There are others, too. They're all "IRC" because they use the same protocol - like separate websites that you get to with the same browser
15:36:44 <ph88> if i want to make a function with ReaderT recursive should i put runReader inside that function ?
15:37:53 <chiku> Cheerkat: oh alright then, thanks you :3
15:40:13 <geekosaur> ph88, usually you'd just call it with <- or >>=
15:43:03 <fresheyeball> monoidal: ok, so I think the first step is to convert 10.1223 to ([1,0],[1,2,2,3])
15:46:08 <monoidal> fresheyeball: in other words, split the fraction p/q into integral part and fractional part (that is less than 1)
15:49:17 <fresheyeball> monoidal: let me ask the higher level question
15:49:22 <pie_> so...i have something that runs in ghci but crashes when i run the compiled version....
15:49:27 <pie_> help? >_<
15:49:53 <fresheyeball> I need to do arbitry precision arithmetic, and so I thought Rational would work well. I am representing money, so no rounding errors allowed.
15:50:09 <pie_> main.hs : https://bpaste.net/show/2115cb44e587 , GLFW.hs: https://bpaste.net/show/9db1bd122606
15:50:31 <fresheyeball> I also need a convient way to read and write decimal representations, since all the apis use fixed precision
15:50:47 <fresheyeball> I also need my aritmetic operations to be as fast as possible, given the arbitrary precision contraint
15:50:54 <pie_> it crashes with "fish: “./_build/bin/main” terminated by signal SIGSEGV (Address boundary error)" on createWindow
15:50:57 <monoidal> fresheyeball: for money I would use a decimal type
15:51:11 <fresheyeball> monoidal: Data.Decimal?
15:51:15 <monoidal> fresheyeball: yes
15:51:41 <fresheyeball> monoidal: can i assume that its show instance produces a lazy list of Char?
15:52:11 <monoidal> Decimal has finitely many digits after the dot I believe
15:52:29 <fresheyeball> monoidal: then can't it suffer from rounding errors?
15:52:38 <monoidal> if you divide, yes
15:52:48 <monoidal> but there's a function for lossless division
15:52:55 <monoidal> it's just not the / operator
15:52:58 <fresheyeball> monoidal: then I am confused
15:53:12 <fresheyeball> why make `/` lossy if lossless is possible?
15:53:25 <monoidal> it's a different type
15:55:01 <fresheyeball> monoidal: where do you live? real name? I could use a conversation about this
15:55:12 <stilgart_> > Data.Decimal.divide 10 3
15:55:14 <lambdabot>  error:
15:55:15 <lambdabot>      Not in scope: ‘Data.Decimal.divide’
15:55:15 <lambdabot>      No module named ‘Data.Decimal’ is imported.
15:55:29 <monoidal> I actually don't know Data.Decimal well
15:55:56 <monoidal> but I guess someone else here will know
15:56:48 <pally> fresheyeball, what if I have no use for it ?
15:56:56 <pally> fresheyeball, for `in`
15:57:08 <fresheyeball> pally: then what is the type of `catch`?
15:57:17 <fresheyeball> because you need to have a codomain
15:57:21 <fresheyeball> maybe you don't need let
15:57:33 <fishythefish> pally: what's the point of defining something if you don't use it?
15:57:57 <stilgart_> well, the result is something like [(2, 3.33), (1, 3.34)]
15:58:25 <stilgart_> as 2 * 3.33 + 1 * 3.34 = 10
15:59:07 <chreekat> pally: you *do* need the in. That's part of the problem
15:59:28 <monoidal> it's like writing an "if" without "then" and "else"
15:59:31 <fishythefish> `let ... in` taken together is a single construct
15:59:32 <ph88> how can i say that m is IO while keeping reader ?   setupBoard :: (MonadReader Env m, MonadIO m, MonadRandom m) => Int -> m (Table, Game)
15:59:35 <fishythefish> you can't have just half of it
16:01:09 <fresheyeball> monoidal: any idea who I should ask about this?
16:01:10 <monoidal> perhaps you are thinking about do-notation, where, you don't write "in", but that's because in do blocks 'in' is implicitly given to the next line
16:01:32 <monoidal> no idea
16:02:05 <ph88> oh i found it
16:03:18 <chreekat> fresheyeball: there's also Ratio
16:03:36 <fresheyeball> chreekat: my current plan was to newtype Rational
16:03:46 <chreekat> oh right, it's a Ratio newtype
16:03:58 <monoidal> usually you use decimals for money, unless you'd like to support things like 1/3 usd
16:03:59 <fresheyeball> chreekat: its just an alias for Ratio Integer
16:04:15 <fresheyeball> monoidal: I do want to support that
16:04:16 <chreekat> s/newtype/type synonym
16:04:17 <chreekat> right
16:04:29 <monoidal> fresheyeball: in this case, yes, you need Rational
16:04:36 <fresheyeball> ok
16:04:36 <chreekat> agreed
16:05:05 <fresheyeball> so then the hard part is actually getting a string out of it
16:05:06 <stilgart_> fresheyeball: do you have more than on currency ?
16:05:10 <stilgart_> ine*
16:05:13 <stilgart_> one*
16:05:42 <fresheyeball> stilgart_: yes, but this is the underlying rep I am talking about
16:05:46 <monoidal> fresheyeball: what do you expect for 1/3 as a string? infinite stream of 0.333...?
16:06:00 <monoidal> and you cut it to the desired precision?
16:06:04 <fresheyeball> monoidal: yes, and infinite stream of `0.333...`
16:06:13 <stilgart_> fresheyeball: ok, so simply using Ints is out of question
16:06:20 <fresheyeball> monoidal: yes and no
16:06:27 <fresheyeball> stilgart_: I want to use Rational
16:07:15 <monoidal> fresheyeball: you aren't going to cut the stream after some point?
16:07:25 <chreekat> the hard part is definitely deciding when and how to truncate the precision
16:07:52 <chreekat> and once you do, you'll want to keep a history of it, of course, since you'll have a bear of a time getting back to it later
16:08:03 <fresheyeball> monoidal: sure, but an API that demands I cut it, is no good. I might also want to do something like, ask for the nth digit
16:08:07 <pgiarrusso> fresheyeball: are you sure for money no rounding error is allowed? I’m no expert, but I understand for money rounding is mandatory, and often a specific rounding scheme is mandated by law
16:08:26 <fresheyeball> pgiarrusso: in the aritmetic there must be no rounding
16:08:31 <fresheyeball> results get rounded
16:08:57 <monoidal> fresheyeball: in this case, you can obtain a stream of decimal digits by long division
16:09:06 <stilgart_> what is your arithmetic in this context ?
16:09:14 * chreekat passes around numerican analysis textbooks
16:09:29 <chreekat> numerical*
16:09:30 <stilgart_> and does Data.Ratio cover it all ?
16:09:55 <fresheyeball> stilgart_: I need to do math, and that math must not countain rounding, the result of that math must be roudned to be reported. How to round depends on the consumer of the result.
16:10:41 <stilgart_> so Rational (Ratio Integer) sounds good
16:10:56 <monoidal> fresheyeball: https://gist.github.com/monoidal/80e440fc8b111dc546fa89dd6349cb73
16:11:40 <fresheyeball> monoidal: holy crap that is fantastic!
16:11:42 <monoidal> and I guess there should be a library which does exactly that
16:11:56 <fresheyeball> I was trying to think through it with quotRem
16:12:55 <monoidal> quotRem can give a negative remainder, and you want digits to be positive
16:13:13 <fresheyeball> monoidal: yeah, I was just struggling to reason about this one for whatever reason
16:13:14 <monoidal> as an exercise you can rewrite this code using unfold
16:13:33 <fresheyeball> I feel like sometimes my brain just falls into a well in one area
16:13:41 <fresheyeball> like I can play Chess, and write Haskell
16:13:52 <fresheyeball> but if I try to play Go my brain stops functioning
16:14:09 <fresheyeball> even simple exercises in playing go dont work for me
16:15:04 <fresheyeball> monoidal: I will release a library when this is ready
16:16:22 <monoidal> https://stackoverflow.com/questions/30931369/how-to-convert-a-rational-into-a-pretty-string
16:16:29 <fresheyeball> monoidal: any idea what I should call my library? Its just a newtype of Rational, but with Float like apis.
16:16:35 <fresheyeball> monoidal: I saw that
16:16:47 <fresheyeball> monoidal: what you wrote is what I needed
16:17:20 <fresheyeball> I was actually going to call it `Data.Decimal` before I realized that is already a thing
16:17:22 <monoidal> fresheyeball: the first answer is doing exactly the same thing, and it looks more robust (handles negative numbers and q >= p)
16:17:44 <fresheyeball> I must have misread it...
16:18:45 <fresheyeball> monoidal: oh I guess I can modify it, to not take an Int
16:18:55 <monoidal> right
16:19:53 <fresheyeball> yeah, I stopped reading when I saw that Int
16:19:54 <fresheyeball> my bad
16:20:05 <fresheyeball> monoidal: got any naming ideas?
16:20:42 <fresheyeball> RealFractional?
16:20:58 <monoidal> sounds like RealFrac typeclass
16:21:33 <fresheyeball> monoidal: right, Rational is not a member of RealFrac, but my newtype will be
16:21:58 <fresheyeball> I am trying to find a name that says, arbitrary precision, rational, and decimalish
16:24:04 <Lears> ArbitraryPrecisionRationalDecimalish
16:27:06 * hackage language-ats 1.3.0.0 - Parser and pretty-printer for ATS.  http://hackage.haskell.org/package/language-ats-1.3.0.0 (vmchale)
16:28:07 * hackage ats-pkg 3.1.0.2 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-3.1.0.2 (vmchale)
16:28:21 <pie_> what could cause a crash in compiled code but not in ghci?
16:32:05 <ph88> how can i help the compiler here ?  https://bpaste.net/show/a3ccb6de97d1
16:36:09 <ph88> fresheyeball, can you share you file when you cooked up something ?
16:38:37 <lyxia> ph88: add a RandomSource constraint to pick?
16:39:37 <hpc> pie_: some kinds of foreign code can
16:39:59 <hpc> i don't know the details of it, but i have seen a few bindings packages before that have had ghci-related bugs
16:40:13 <hpc> but not anywhere else
16:45:28 <ph88> lyxia, i added that constraint everywhere .. now on the top function i run into a problem  https://bpaste.net/show/a3d82bd3ba64  (error on the very bottom)
16:50:57 <pie_> i think i figured out that something is wrong with my nix environment...
16:51:06 <pie_> i can run glxgears outside it but not in it
16:54:04 <chreekat> ph88: seems unlikely you need to specify both MonadRandom m and RandomSource m in the type of playTurns
16:57:46 <ph88> chreekat, MonadRandom is used by shuffleM
16:57:51 <ph88> in updatePlayer
16:58:01 <ph88> i have to put this constraint i think
17:00:33 <ph88> No instance for (RandomSource (ReaderT Env IO) (Gen RealWorld))     i think it should be  RandomSource (Gen RealWorld)   .. not sure why ReaderT is stuck there in the middle
17:00:43 <chreekat> I suspect you are mixing different libraries that don't interoperate
17:01:02 <ph88> o_O
17:01:05 <chreekat> The only shuffleM I see is from the random-shuffle package, no?
17:01:22 <chreekat> and the other stuf might(?) be coming from random-fu or something?
17:01:40 <ph88> yes
17:02:35 <chreekat> oh nm, random-fu relies on random-shuffle
17:07:46 <chreekat> so these are probably the same types after all. :) Still thoug,h there is a relation between MonadRandom and RandomSource which, to me, indicates you probably don't need to specify both in a type sig
17:09:42 <ph88> i suspected something like that .. but i don't really know
17:09:44 <chreekat> I'd try to focus on using the Data.Random interface. For example, there is a shuffle :: [a] -> RVar [a] that will play nice with the other utilities there
17:10:10 <ph88> instead of shuffleM ?
17:10:35 <chreekat> yeah, in that one case. I don't know if there are others, and I'm not super familiar with these methods
17:10:48 <chreekat> I just get the feeling that you should find everything you need at the one level of abstraction
17:11:03 <dmwit> With all due respect to chreekat, it sounds like he hasn't really used this library before, and maybe he doesn't know the answer.
17:11:12 <dmwit> (I, too, don't know the answer.)
17:13:25 <dmwit> You might want to look for some sample code that uses this library (perhaps in its documentation!) and inspect the types the sample code uses for inspiration.
17:15:33 <ph88> No instance for (RandomSource (ReaderT Env IO) (Gen RealWorld))    but if ReaderT was not there it would be   RandomSource IO (Gen RealWorld)    and this is implemented  https://hackage.haskell.org/package/random-source-0.3.0.6/docs/Data-Random-Internal-Source.html#t:RandomSource
17:15:33 <Squarism> is there some weaker form of equality that goes around the problem of functions not able to implement Eq?
17:15:41 <ph88> ReaderT is messing things up
17:16:10 <ph88> i feel like it should be ReaderT Env RandomSource IO (Gen RealWorld)
17:16:31 <glguy> kind error
17:16:45 <dmwit> Squarism: The universe package offers an Eq instance for functions with finite domain.
17:16:49 <fishythefish> Squarism: http://hackage.haskell.org/package/universe-1.0/docs/Data-Universe-Instances-Reverse.html
17:17:22 <dmwit> Squarism: You can also use IORef to give an Eq instance to any type, at the cost of putting the programmer in charge of tracking singletons.
17:18:02 <Squarism> dmwit, hmm.. the last proposal sounds scary. =D
17:18:16 <dmwit> Depends on your needs.
17:19:01 <ph88> glguy, are you talking to me ?
17:19:13 <dmwit> Squarism: You might also like https://stackoverflow.com/q/17045941/791604
17:20:07 <Squarism> basically Id be okey with just leaving functions of any comparrison
17:20:13 <dmwit> ph88: Yes, "kind error" was in response to your ReaderT Env RandomSource IO (Gen RealWorld) thing.
17:20:25 <dmwit> Squarism: I don't know what that means.
17:20:33 <glguy> % same map reverse
17:20:34 <yahb> glguy: False
17:20:35 <glguy> % same map map
17:20:35 <yahb> glguy: True
17:21:13 <dmwit> Squarism: Oh, maybe I do; did you mean roughly `instance Eq (a -> b) where _ == _ = True`?
17:21:22 <dmwit> If so, yikes, please don't do that.
17:21:26 <dmwit> :t same
17:21:28 <lambdabot> error:
17:21:28 <lambdabot>     • Variable not in scope: same
17:21:28 <lambdabot>     • Perhaps you meant ‘some’ (imported from Control.Applicative)
17:21:31 <dmwit> % :t same
17:21:31 <yahb> dmwit: a -> b -> IO Bool
17:21:41 <dmwit> StableName?
17:21:44 <chreekat> it's true I don't know the answer, but I stand by my hunch that importing Data.Random, System.Random, *and* Control.Monad.Random is a bad sign
17:21:45 <Squarism> data Foo = Foo { id :: Int , someFkn :: Int -> String -> Int } if two Foo's are compared the functions are not considred
17:21:54 <glguy> dmwit: yeah
17:22:04 <Squarism> that type of SemiEq
17:22:04 <dmwit> Good suggestion.
17:22:25 <glguy> StableNameis pretty brittle for this, though, even if it looks good on IRC
17:22:34 <dmwit> Squarism: See? You are okay with managing the singletons yourself. =)
17:22:40 <dmwit> Squarism: You just aren't calling it that.
17:24:22 <dmwit> Squarism: What goes wrong if you just write `fooID v1 == fooID v2` instead of `v1 == v2`?
17:25:01 <Squarism> Oh ok. In java land I learned singleton is something there exist just one of. Im not sure I can give this guarantee.
17:25:06 <Squarism> (memory wise)
17:25:47 <Squarism> dmwit, its a quite deeply nested sum type with like 16 differents constructor combinations
17:25:52 <dmwit> I just mean this: the programmer is in charge of making sure that if you create the same object two times, they get the same identity. So, that identity is the singleton -- there's just one of them around for that object.
17:26:13 <Rembane> What about referential transparency?
17:26:14 <Squarism> so I dont want to do manual comparisons
17:26:15 <dmwit> (Even if you make that object in a new way, say.)
17:26:22 <dmwit> Rembane: What about it?
17:27:37 <Rembane> dmwit: My tired brain says that with referential transparency, singletons aren't as important anymore. But I might be associating in a weird way.
17:28:12 <dmwit> Perhaps I should not have used the word "singletons". It seems to already have a technical meaning, and not the one I wanted.
17:28:14 <madknight> when possible should i use -XSafe or -XTrustworthy or both (possible?) or neither
17:29:00 <dmwit> Squarism: Another possibility is to store a mapping from IDs to functions on the side, storing just the key into the map in your data structure directly.
17:29:15 <dmwit> Squarism: Or write your Eq instance by hand, of course.
17:29:48 <Rembane> Singleton is a pattern in the pattern book by the gang of four.
17:30:02 <dmwit> Squarism: Anyway, the advantage of having the mapping on the side is that it's more clear what two values not being equal means: it means they have different keys in the map, even if the functions at those keys are the same.
17:32:34 <Squarism> dmwit, ill consider that.
17:34:06 <Squarism> Thought i could see how Eq was implements for constructors. But its all native code it seems
17:34:20 <lyxia> madknight: I haven't ever used either, if you ever need to add that level of safety you can ask to be paid to do it.
17:36:17 <madknight> lyxia, well after some easy changes my lib is indeed compiling with the safe option, e.g it suggested me to use Data.Array.ST.Safe instead of Data.Array.ST
17:36:48 <dmwit> Squarism: (...and the other way: if they compare as equal, you know they behave the same, and don't have to worry that a bug may have caused two objects with the same id to have different functions.)
17:36:53 <madknight> but i don't know the difference between Data.Array.ST and its Safe variant ...
17:44:31 <Squarism> dmwit, all good ideas. Im just not clear on what problem I want to solve yet. So just fishing around.
17:44:36 <ab9rf> madknight: probably none, now that Control.Monad.ST.Safe is the same as Control.Monad.ST
17:44:57 <Squarism> What about ghci's ":t" command. Can that be executed runtime somehow?
17:45:58 <madknight> ab9rf, so it's okay to use {-# LANGUAGE Safe #-}?
17:46:15 <ab9rf> madknight: idk
17:49:34 <dmwit> Squarism: sort of, see typeOf
17:49:39 <geekosaur> Squarism, not as such. with a Typeable constraint there is typeOf, whichis not quite the same thing
17:49:41 <madknight> ab9rf, Stephen Diehl mentioned it in http://dev.stephendiehl.com/hask/ that's how i stumbled upon it
17:50:14 <dmwit> Squarism: but it is rarely useful in the way beginners want it to be when they ask this
17:51:04 <Squarism> dmwit, no im probebly walking in the dark here. Just hit me it will show same type all the time.
17:51:04 <monochrom> This is the price you pay for free theorems.  Free theorems work because there is no "what type did the user choose?"
17:51:48 <dmwit> Squarism: exactly =)
17:52:23 <dmwit> you just got promoted from beginner to... whatever is one step up from beginner
17:52:40 <monochrom> beginner prime
17:52:48 <ab9rf> beginner first class
17:52:51 <Squarism> dmwit, ok.. as im not coming up with anything clever. I want to be able to tell if two "GamePhases" are different in by comparing values of this type https://lpaste.net/7407676785724227584
17:52:53 <dmwit> expert beginner
17:53:18 <monochrom> premium beginner (think airlines' premium economy seats)
17:53:41 <ab9rf> i'm still waiting to be promoted from beginner basic to beginner.
17:53:50 <Squarism> dmwit, basically just if GamePhase constructor is different including the subphases in BattlePhase
17:54:20 <Squarism> values passed constructors otherwise is not important
17:55:05 <nshepperd1> All world-enders get their start as world-beginners
17:55:30 <ab9rf> nshepperd1: that feels like an obscure elder scrolls reference for some reason
17:55:41 <monochrom> heh
17:57:19 <dmwit> Squarism: Let's take just SetupPhase. What's a typical call to SetupPhase look like?
17:59:09 <Squarism> dmwit, its a lite of units per player "placed on the board"
18:00:22 <dmwit> Squarism: I am asking a very literal question: what is some sample code that starts with `SetupPhase`?
18:00:39 <Squarism> ok.. i can paste
18:01:24 <dmwit> A paste has too much.
18:01:35 <dmwit> I just want an example of a single call to `SetupPhase`, with no context.
18:01:37 <ab9rf> hm, ineresting sum type
18:02:46 <ab9rf> you can derive Show for a type containing values that are functions?
18:03:03 <dmwit> Not unless you have a Show instance for functions lying around.
18:03:20 <ab9rf> that's what i though too
18:03:44 <Squarism> dmwit, ok.. here it is for "CardPhase" : CardPhase (handleCardPlayAction b)
18:04:04 <ab9rf> i'm trying to understand how this GamePhase type is used
18:04:07 <dmwit> Right. And is `CardPhase`'s argument *always* a `handleCardPlayAction` call?
18:05:11 <Squarism> dmwit, yes it is.
18:05:32 <dmwit> How about storing `b` in `CardPhase` instead of `handleCardPlayAction b`?
18:05:33 <Squarism> but arguments to handleCardPlayAction varies ofcourse
18:05:47 <dmwit> (This is called "forestation" or something fancy. I forget.)
18:06:31 <Squarism> hmm.. I can take it as input but im not changing all that stuff because of this little problem of determining game phase change.
18:06:33 <Squarism> =D'
18:06:44 <Squarism> The game is already done and in the wild
18:07:50 <Squarism> I got enough stuff on the backlog as it is. These are the clean parts of the code wo any IO at all. =D
18:08:02 <dmwit> It can always be cleaner.
18:08:30 <Squarism> I got 30k lines of code that could be cleaner
18:09:27 <Squarism> its basically a continuation passing thing that big sum type.
18:09:30 <dmwit> How many of them will get cleaner if you refuse to clean them?
18:10:18 <Squarism> I ask, should I clean the real dirty complex ones or the havent had a problem in a long time parts? =D
18:10:30 <dmwit> Never mind. Do as you wish. You have my advice, and I won't compromise on it, but there are other fish in the channel.
18:13:33 <Squarism> dmwit, im very thankful. But believe me. I object changing it because quite fatigued on all bits that need adding fixing. Now i just want to add a timer function for players and determine when turn has changed. It can be read in that datastructure.
19:13:43 <bmjh[m]> @pl \f g x y -> f (x ++ gx) (g y)
19:13:43 <lambdabot> flip . ((.) .) . (. (++ gx))
19:14:43 <Chiku> (oYo)
19:34:46 <dmrd> anyone here comfortable with the aeron hackage for parsing JSONS? struggling to convert the 'Value' result of a decode into a HashMap
19:35:23 <suzu> aeson?
19:35:28 <glguy> dmrd: Always just ask your actual question.
19:35:38 <suzu> pattern match on `Object`
19:36:00 <dmrd> glguy: noted. and suzu: hmm, will try
19:45:28 <ludat> hi everyone, has someone managed to build a haskell exe on archlinux that can be run on ubuntu (I can install whatever library I need on the ubuntu)
19:46:33 <Solonarv> I haven't had reason to try, but I see no reason it should be particularly complicated
19:46:57 <Solonarv> they use the same binary format, so you just need to make sure that whatever you're linking against is present on both systems
19:49:27 <ludat> Solonarv: the issue I have is that arch uses a version of glibc that's higher than the one ubuntu has
19:50:04 <Solonarv> ah, I've heard that it can be difficult to link against an older glibc
19:50:25 <Solonarv> I don't have any expertise on it, but if that's a common problem you should be able to find information online
22:27:26 <_sras_> Why does this snippet, https://lpaste.net/4752979537543823360  fail to compile with 'type variable will escape its scope' error if I uncomment line 14, when it is essentially the same thing that is happening with the pattern match in argument of fun1 function?
22:27:40 <cocreature> Does cabal create CPP macros for cabal flags by default or is it up to me to do use something like cpp-options and test for whether something is defined?
22:29:01 <geekosaur> the latter, I believe
22:29:37 <cocreature> thanks! Then I can at least stop searching :)
22:30:21 <geekosaur> it would have to be some rule like "only iof the flag is all uppercase" because lowercase CPP macros tend to cause obscure bugs
22:31:03 <dminuoso> _sras_: Consider this
22:31:24 <dminuoso> let (Ordable x) = blabla in ... x
22:31:45 <_sras_> dminuoso: yes..
22:36:23 <dminuoso> % :set -XExistentialQuantification
22:36:24 <yahb> dminuoso:
22:36:55 <dminuoso> % data F = forall a. Num a => F a
22:36:55 <yahb> dminuoso:
22:37:12 <dminuoso> _sras_: magic (F a) = a
22:37:17 <dminuoso> _sras_: What is the type of `magic`?
22:37:37 <dminuoso> I challenge you to apply your type inference knowledge and solve this.
22:37:58 <_sras_> dminuoso: forall a. Num a => a ?
22:39:43 <dminuoso> _sras_: You forgot the argument.
22:40:39 <_sras_> dminuoso: forall a. Num a => F -> a ?
22:41:53 <dminuoso> _sras_: But if that was the case, the consumer of `magic f` could decide what `f` was built with
22:42:03 <dminuoso> which is a lie, since it's actually the producer of `f` that already made that decision
22:42:25 <dminuoso> % ex = F (3 :: Double)
22:42:25 <yahb> dminuoso:
22:42:29 <dminuoso> % :t ex
22:42:29 <yahb> dminuoso: F
22:42:36 <dminuoso> _sras_: See how the type is *gone* ?
22:45:27 <dminuoso> % :t F
22:45:27 <yahb> dminuoso: Num a => a -> F
22:45:36 * hackage asif 2.0.0 -   http://hackage.haskell.org/package/asif-2.0.0 (newhoggy)
22:46:11 <dminuoso> _sras_: A SO nicely put it once: What you are doing is similar to this: let f = (\x -> x + 1) in x
22:46:25 <dminuoso> It simply doesn't make sense to try this.
22:47:41 <geekosaur> GADTs can retrieve the type from a pattern match, but it only exists in that scope; you can't return it. You can do something like realToFrac in this case because the existential never leaves the scope, but the type doesn't exist outside the scope of the pattern match alternative
22:50:01 <_sras_> dminuoso: can you explain this bit. "But if that was the case, the consumer of `magic f` could decide what `f` was built with".  Why is it a lie?
22:50:56 <iqubic> what is the type of magic?
22:51:11 <geekosaur> forall a. Num a => F -> a   means that the caller decides what a is and you must accept it
22:51:25 <geekosaur> not what created the F
22:52:33 <geekosaur> so if it let you write that, you'd have a somewhat restricted unsafeCoerce
22:54:52 <pavonia> _sras_: You can't know at compile time what the actual type of x is, but you have to know to decide whether it matches the result type of magic
23:00:34 <_sras_> geekosaur: Ok. So in function's pattern match, it works becasue the type checker knows that the variable who's type is unknown does not escape the confines of the function (from its signature /infered type)?
23:00:51 <iqubic> Should I go ahead and ask for the type of "magic"?
23:01:18 <iqubic> Like "% :t magic"?
23:01:18 <_sras_> geekosaur: But then why wouldn't the expression `c = let Ordable a = (Ordable 10) in realToFrac a` which is essentially the same thing fail to compile?
23:02:13 <iqubic> I think it's the use of multiple equal signs.
23:03:44 <dminuoso> _sras_: For the same reason I just told you.
23:04:06 * hackage terminfo 0.4.1.2 - Haskell bindings to the terminfo library.  http://hackage.haskell.org/package/terminfo-0.4.1.2 (JudahJacobson)
23:04:10 <dminuoso> _sras_: You can't have the type of `a` escape
23:04:43 <_sras_> dminuoso: But in the expression "let Ordable a = (Ordable 10) in (realToFrac a :: Float)" the type is not escaping anywhere. Right?
23:05:02 <dminuoso> _sras_: It escapes the scope of the match.
23:05:08 <dminuoso> _sras_: You are even referring to it
23:05:11 <dminuoso> _sras_: `a :: Float`
23:05:28 <iqubic> % :t magic
23:05:28 <yahb> iqubic: ; <interactive>:1:1: error: Variable not in scope: magic
23:05:30 <_sras_> dminuoso: the whole expression is Float. Not a
23:05:55 <iqubic> % let magic (F a) = a
23:05:56 <yahb> iqubic: ; <interactive>:52:19: error:; * Couldn't match expected type `p' with actual type `a'; `a' is a rigid type variable bound by; a pattern with constructor: F :: forall a. Num a => a -> F, in an equation for `magic'; at <interactive>:52:12-14; `p' is a rigid type variable bound by; the inferred type of magic :: F -> p; at <interactive>:52:5-19; * In the exp
23:06:02 <iqubic> Huh?!?!
23:06:05 <dminuoso> _sras_: What type does `a` have?
23:06:07 <_sras_> dminuoso: Basically what I fail to understand is that how is the let expression different from the pattern match in the function
23:06:20 <dminuoso> _sras_: It's different because you are not escaping its type there.
23:06:57 <dminuoso> _sras_: If you want I can give you a more constrained example that illustrates this
23:07:01 <cocreature> _sras_ does have a point. there is nothing fundamentally different about pattern matching in a let vs pattern matching in a case here. afaik the reason why you can’t pattern match on existentials in a let is to simplify the implementation not because it’s impossible
23:07:02 <glguy> You can't use a let, but you can use a case for this
23:07:44 <cocreature> the type variable in "let Ordable a = Ordable 10 in realToFrac a :: Float" doesn’t escape more than the one in "case Ordable 10 of Ordable a -> realToFrac a :: Float"
23:07:50 <glguy> let introduce (potentially) recursive definitions
23:07:53 <dminuoso> cocreature: oh?
23:08:11 <glguy> But case is always safe
23:08:21 <dminuoso> cocreature: Okay I take it back.
23:08:31 <cocreature> “In general, you can only pattern-match on an existentially-quantified constructor in a case expression or in the patterns of a function definition. The reason for this restriction is really an implementation one. Type-checking binding groups is already a nightmare without existentials complicating the picture.”
23:08:39 <cocreature> source: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#restrictions
23:09:31 <cocreature> in the general case, let is definitely harder but there is no reason why existentials have to be completely forbidden in lets
23:11:20 <_sras_> cocreature, glguy And here I thought I was going mad! Many thanks!
23:27:40 <ZeuPiark> hello
23:27:59 <Chiku> Hello
23:28:03 <Chiku> Hey there
23:28:34 <Chiku> Clarquee
23:28:51 <Clarquee> Yo
23:29:01 <Chiku> Sup mate
23:29:08 <Chiku> What you up to
23:30:41 <Clarquee> Bored
23:30:43 <Clarquee> You?
23:30:53 <Chiku> Laying in bed
23:31:07 <Chiku> Had breakfast a while ago
23:31:10 <johnw_> I'm afraid this channel is really for discussion of Haskell
23:31:22 <Chiku> What's haskell
23:31:30 <johnw_> a computer programming language
23:31:50 <Clarquee> Cool
23:31:51 <Chiku> Oh lol
23:38:41 <c50a326> hey I'm clear on my next undertaking: I want to parse emmet and produce elm html
23:38:57 <c50a326> so this is a "parser" right?
23:39:30 <c50a326> and do I need to worry about "abstract syntax tree"? I mean, what do I need to learn? can someone maybe tell me some order of things I'm going to need to do for such a thing?
23:39:37 <c50a326> I've never messed with this kind of stuff before
23:42:32 <dysfun> you probably just want to look at parsec, attoparsec, or megaparsec
23:42:57 <dysfun> there are some good guides to using them on the intenret
23:46:02 <nshepperd> what's emmet? a kind of templating language?
23:46:24 <c_wraith> a misspelling of ekmett?
23:46:44 <dysfun> it's sort of like templating meets textmate snippets
23:46:50 <nshepperd> parsing ekmett is not for the faint of heart
23:46:58 <c50a326> yeah you can do like div.some-css-class>div#id>h1{some heading}+p{content here}
23:47:02 <dysfun> even ekmett cannot parse himself
23:47:18 <tdammers> dysfun: he can, but it doesn't terminate
23:47:29 <nshepperd> the thing you are writing might end up being a 'compiler' depending how sophisticate the emmett syntax is
23:47:54 <nshepperd> does it have variables, or is it pretty simple?
23:48:04 <tdammers> "abstract syntax tree" is a scary name for a pretty simple concept
23:48:09 <c50a326> I think it doesn't have variables, let me double check
23:48:24 <tdammers> the AST is just a tree-shaped data structure that represents your program
23:48:46 <tdammers> in such a way that the structure follows the logical structure of the program rather than the syntax
23:49:48 <tdammers> you can have ASTs for all sorts of languages - super simple template languages, where it might just look like this: data ASTNode = Literal String | Variable VarName; type AST = [ASTNode]
23:50:04 <tdammers> or complex ones that can represent a full-blown general purpose programming language
23:52:20 <nshepperd> ok this emmett thing looks preeetty simple, so it's probably fine to just write a parser
23:52:52 <c50a326> yeah it doesn't have variables
23:53:04 <milesrout> tdammers: everything seems simple when you already understand it. this sort of comment is the same sort of sentiment that results in monad tutorials
23:53:31 <milesrout> 'monads are simple, they're just like, imagine you have a burrito.... [5 pages of explanation that only makes sense if you already understand it]'
23:53:33 <nshepperd> you don't have to write an AST but it's pretty common to have the output of parsing be some sort of structure that logically represents the input, because that usually makes things easier
23:54:18 <tdammers> milesrout: monads *are* simple, as long as you avoid imagining boxes or burritos or stuff like that
23:54:49 <tdammers> milesrout: the brain-wrecking part about monads is not that they're complex, because they're not; it's that they're a very abstract concept, which makes it hard to form a useful intuition about them
23:54:51 <milesrout> anyway an AST isn't just any syntax tree, it's specifically an abstract one: it doesn't represent any of the details that aren't relevant for your purposes
23:55:15 <tdammers> milesrout: and the monad tutorial fallacy consists of overcomplicating things by trying to give people metaphors that, in the end, aren't helpful
23:55:27 <dysfun> tdammers: but often delicious
23:55:49 <tdammers> dysfun: yes. "A monad is just an ekmett in the category of haskell libraries, what's the problem"
23:56:22 <dysfun> ekmett has many monad instances
23:56:24 <milesrout> i think the problem with monads as they are usually presented (return and (>>=)) is that it involves being comfortable with higher order functions and custom infix operators and an abstraction over type constructors and all of this at once
23:56:52 <milesrout> it's simple if you have an intuitive grasp of what a signature like (a -> m b) -> (m a -> m b) means, but most people do not.
23:56:55 <nshepperd> monads aren't the problem here
23:57:19 <tdammers> milesrout: obviously, in order to understand any particular higher-kinded typeclass, one needs to understand how those work in general
23:57:45 <tdammers> milesrout: there's no way around learning those before diving into monads, or any other comparable abstraction, really
23:58:05 <dminuoso> Monoid, Functor, Monad. That's my preferred road now =)
23:58:08 <milesrout> i wish people agreed that that was obvious
23:58:09 <tdammers> milesrout: that's why I recommend learning from the ground up, starting with simpler typeclasses like Show, Eq, Monoid
23:58:25 <tdammers> and then introduce Functor as one of the simplest * -> * typeclass
23:58:29 <tdammers> typeclasses*
23:59:04 <milesrout> Eq is good because  it's something people are already used to overloading, generally. Then Show & Read means you can introduce the idea that you can overload on *return type*, which is quite new for most.
23:59:19 <dminuoso> Monoid is when things start getting abstract =)
23:59:36 <dminuoso> Also <3 Monoid
