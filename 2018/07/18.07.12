00:17:18 <dataN> ok, so; 'f -> (f -> (forall b. (p => a -> b) -> b))' reads as, "given a function, and a way to return a value from it, (i.e. all of its arguments stored implicitly; 'f -> (f->x) -> x' ) wrap this return type using cps ( 'f -> (f->(forall b. (x->b)->b)' ) and then add a constraint to the returned continuation...
00:21:48 <dataN> to take a function and add an constraint to its return type.
00:27:37 <dataN> hmm, maybe its more like; '(f -> (f->x)) -> (f->(p=>x->b)->b)' "given a function and an encoding of all of its arguments, return a function which encodes its return type using cps whoes scope allows a constraint to be added"
00:32:09 <dataN> probably not the best way to refer to the return type, as if the type were written as e.g. type CoReifyConstraint p f x = (f -> (f->x)) -> (f->(forall b. (p=>x->b)->b)), then there would be no way to tell that 'x' was actually the return type of 'f'... how could that be done?
00:34:24 <JustDoIt> Hi, I have a beginner question. I've been reading up on monads and do notation and wrote this short function, but I don't understand why it doesn't compile. Can anyone help? I expect it to return Nothing when any of its inputs is Nothing. https://hastebin.com/anazecaxav.hs
00:36:06 <dataN> it should be a case expression instead
00:36:59 <dataN> <- in do is like (>>=) in that it gets the value out of the monad, so pattern matching on Just will fail.
00:37:09 <cocreature> JustDoIt: remove the Just on the left of <-
00:38:10 <liste> JustDoIt: <- already "unpacks" the value
00:38:18 <JustDoIt> cocreature: Thanks, works now!
00:38:18 <liste> JustDoIt: so no need to double unpack it
00:38:37 <JustDoIt> I tried to do like "Just x1" in https://en.wikibooks.org/wiki/Haskell/do_notation
00:39:17 <dataN> use case when pattern matching is required, also there is 'maybe'...
00:40:34 <liste> short-circuiting Maybes is a great use case for do notation
00:41:27 <dataN> is it possible to return the return type of a function of type :: (k -> *)
00:42:25 <dataN> not sure if thats how to call a function of abrbitrarily many arguments...
00:59:36 * hackage bench-graph 0.1.1 - Plot and compare benchmarks  http://hackage.haskell.org/package/bench-graph-0.1.1 (harendra)
01:01:43 <vaibhavsagar> does anyone have any thoughts on bootstrapping GHC?
01:02:03 <vaibhavsagar> I'm wondering if anything has changed since https://elephly.net/posts/2017-01-09-bootstrapping-haskell-part-1.html
01:02:45 <cocreature> afaik that’s still the current state
01:05:53 <vaibhavsagar> fair enough
01:06:27 <vaibhavsagar> tangentially related: are there any resources on the architecture of the Hugs interpreter?
01:13:27 <gentauro> can line 7 be replaced with Void or something else? I just don't like having to write "error" in my code -> https://lpaste.net/9184847056382984192
01:13:43 <gentauro> Note: It's mathematically impossible to reach that code branch
01:13:56 <gentauro> given the call above
01:14:08 <gentauro> which always ensure [0 - 255]
01:14:22 <gentauro> i mean [0 - 15]
01:14:25 <quicksilver> just miss out the line entirely
01:15:06 <gentauro> can I just remove it? Will the compiler (-Wall -Werror) not complain?
01:15:26 <quicksilver> I don't remember.
01:15:37 <gentauro> the alternative of replacing  x < 0x10 with otherwise makes to code less readable in my (humble) opinion
01:15:54 <quicksilver> I personally don't think GHC warnings are well enough curated to make -Wall -Werror a workable option
01:16:04 <quicksilver> but I could be out on a limb there
01:16:41 <gentauro> quicksilver: I'm a person who need the best "peer programmer" to help me write code and that is GHC -Wall -Werror :)
01:16:45 <quicksilver> inexhaustive patterns are a fact of life in haskell
01:17:04 <gentauro> I don't think I will be able to create any "decent" code without it telling all the things I'm doing wrong ;)
01:17:08 <quicksilver> and unless you're prepare to embrace enough type extensions to be turing-complete at the type level
01:17:23 <quicksilver> then there is no way to avoid inexhaustive patterns in realistic code
01:19:58 <gentauro> quicksilver: these are usually my GHC flags -> https://lpaste.net/3762466113791721472
01:20:20 <gentauro> I was guessing that -Wincomplete-uni-patterns did the trick ...
01:29:03 <gentauro> btw, where are all the haskellers? I guess they are all hired at IOHK -> https://iohk.io/team/#cardano
01:29:21 <gentauro> is there a company (worldwide) who has more haskellers on the staff than them?
01:30:31 <gentauro> and btw, with my previous hex snippet, what is more readable? -> https://lpaste.net/7233919103465947136
01:30:58 <cocreature> galois and facebook probably also have fairly large Haskell teams but I don’t know any numbers
01:31:19 <gentauro> I'm saying good old ['0' .. '9'] ++ ['A' .. 'F']
01:31:31 <quicksilver> JaffaCake counts as a large Haskell team on his own :)
01:31:40 <cocreature> haha
01:32:51 <gentauro> I'm guessing FPComplete would also have a few right? They appear everwhere when I Google :)
01:33:58 <cocreature> ah yeah
01:34:02 <gentauro> IOKH (Hong Kong), Galois (The States), FB (London Office?), FPComplete (The States), Tweag.IO (France)
01:34:10 <gentauro> anymore takers?
01:35:14 <cocreature> standard chartered probably also has a relatively large team
01:35:43 <cocreature> and ofc there are lots of smaller Haskell teams
01:36:37 <tfc[m]> what haskell team size counts as large? :D
01:36:39 <gentauro> but of the mentioned above, it's probably only FPComplete + Tweag.IO who provide consultancy services (projects based on HS) right?
01:36:52 <gentauro> tfc[m]: anything above 1 :P
01:37:11 <tfc[m]> gentauro: lol then we have a "large" team at my company, too. it's 3 haskellers. :D
01:37:20 <ggVGc> I think I'm the biggest haskell team
01:37:45 <gentauro> ggVGc: hows that?
01:37:46 <cocreature> ggVGc: maybe try exercising a bit more? :)
01:38:10 <gentauro> cocreature: well the only time I run, is to catch the icetruck (I'm not even kiding)
01:39:17 <gentauro> luckily I live in Denmark and we bike (bicycle everywhere, otherwise my pizze + coke diet would have killed me long time ago) :D
01:46:20 <tdammers> gentauro: Well-Typed
01:46:33 <tdammers> http://www.well-typed.com/who_we_are/
01:47:29 <poapoa> Hi, a record related Q: Say there's a record `data Foo = mkFoo { bar :: [Int], baz :: [Int] }`. Is there an option to make a function `f :: Foo -> ??? -> Int -> Foo` such that `f myFoo bar 4` updates `bar`, but `f myFoo baz 4` updates baz?
01:47:50 <Taneb> gentauro: we've got a few Haskellers here at Myrtle (Cambridge UK)
01:49:00 <liste> poapoa: what'd be the type of ???
01:49:12 <poapoa> liste: That is a very good question
01:49:44 <liste> it'd be Foo -> [Int]
01:49:55 <poapoa> sounds right
01:50:10 <liste> and you can't really compare functions for equality
01:50:18 <Taneb> Foo -> [Int] doesn't work in this case for that reason
01:50:40 <liste> poapoa: you might want to look at lens
01:50:43 <liste> @hackage lens
01:50:43 <lambdabot> http://hackage.haskell.org/package/lens
01:50:45 <Taneb> However you can use (Foo -> [Int] -> Foo) or something similar, although then you can't use "bar" and "baz" straight away
01:50:48 <Ariakenom> Bounded a => Enum a => Eq b => (a -> b) -> (a -> b) -> Bool
01:51:09 <quicksilver> I'm think poapoa definitely wants to look at lens
01:51:27 <liste> poapoa: and if it's overwhelming, there's alternatives
01:51:31 <liste> @hackage lens-family
01:51:31 <lambdabot> http://hackage.haskell.org/package/lens-family
01:51:46 <poapoa> I know lens, trying to avoid it because (ghasp) the default records work for me in the meantime
01:52:32 <poapoa> Why does the inability to compare functions means that (Foo -> [Int]) doesn't work?
01:53:45 <quicksilver> the thing about avoiding lens is that lens is precisely the solution to the problem you are trying to solve
01:54:01 <quicksilver> however, here is a different data structure you can consider:
01:54:44 <quicksilver> data BarBaz = Bar | Baz; newtype Foo = MkFoo (Map BarBaz [Int])
01:55:08 <quicksilver> I've used things like that quite happily in the past.
01:55:33 <quicksilver> in some cases even newtype Foo = MkFoo( BarBaz -> [Int] )
01:55:37 <quicksilver> but much less often, that one.
01:56:11 <liste> poapoa: do you know the record update syntax?
01:56:33 <poapoa> I'm fantasizing about `f g fld = \foo -> foo { fld = g $ fld foo }`. I know that the AST repr is different, but it just makes so much sense
01:56:33 <liste> @let data Foo = MkFoo { bar :: [Int], baz :: [Int] }
01:56:35 <lambdabot>  Defined.
01:57:41 <quicksilver> poapoa: yes. That's exactly what lens is.
01:57:50 <quicksilver> honestly, lens is the solution to that problem :)
01:58:34 <quicksilver> it's not the *only* solution - there were a complete rash of them on hackage at one point
01:58:39 <poapoa> Great, thanks! Wanted to be sure that my bases are covered and I'm not missing an option I'm not familiar with
01:59:36 * hackage eventstore 1.1.5 - EventStore TCP Client  http://hackage.haskell.org/package/eventstore-1.1.5 (YorickLaupa)
02:00:37 <quicksilver> other options included: vinyl, data-accessor, labels, has, rawr, fields, reified-records, fieldwise, fclabels
02:00:47 <quicksilver> (those are all the names of packages on hackage)
02:00:56 <quicksilver> some of them have a more 'concrete' notion of field
02:01:14 <quicksilver> as compared to lens in which a field is a function with a surprising type.
02:01:27 <quicksilver> ...but for various reasons my opinion is that lens 'won'.
02:01:54 <quicksilver> (by the way I've missed many many other attempts, this was a very popular solution space)
02:02:14 <dataN> now there is this error; https://lpaste.net/484181009126916096
02:09:05 <gentauro> tdammers: nice, didn't know them :o
02:10:43 <quicksilver> gentauro: there are well-tpyed people on the IOHK list though
02:10:47 <quicksilver> I'm not sure what the relationship is
02:11:11 <quicksilver> dcoutts is one such
02:11:16 <quicksilver> (in fact he's the top left person)
02:11:31 <quicksilver> that black background really makes the mugshots look sinister
02:11:36 <dcoutts> hah
02:11:40 <quicksilver> dcoutts: I do not believe you to be that sinister, in fact.
02:11:46 <dcoutts> thanks :-)
02:12:26 <dcoutts> quicksilver, gentauro: IOHK is one of Well-Typed's major clients, we have several people working with them including me.
02:12:37 <quicksilver> ah!
02:23:36 <tdammers> quicksilver: it's simple - Well-Typed is a Haskell consultancy firm
02:23:45 <tdammers> so yeah
02:30:36 * hackage funcons-simple 0.1.0.3 - A modular interpreter for executing SIMPLE funcons  http://hackage.haskell.org/package/funcons-simple-0.1.0.3 (ltvanbinsbergen)
02:49:40 <revskill> LiquidHaskell proved that Well-Typed can go wrong ?
02:50:36 * hackage primitive-extras 0.1.5 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.1.5 (NikitaVolkov)
02:53:13 <gentauro> dcoutts: are you bigger than Tweag.io? (I guess you are) :)
02:53:28 <Taneb> gentauro: dcoutts personally?
02:53:42 <gentauro> Taneb: yes
02:54:01 <gentauro> I mean Well-Types, the company where he works
03:02:36 * hackage cabal2nix 2.10.0 - Convert Cabal files into Nix build instructions.  http://hackage.haskell.org/package/cabal2nix-2.10.0 (PeterSimons)
03:06:05 <tdammers> you can count, can't you? ;)
03:11:57 <phadej> gentauro: you can stalk the employees from websites of both companies :)
03:12:17 <gentauro> I know the CEO of Tweag.io
03:12:19 <bwe> Is there a sane way to define product classes allowing only a specific subset of attributes with Haskell? https://bpaste.net/show/a91d7e61e0b9 (re-asking the question from tonight)
03:12:41 <gentauro> phadej: we were actually going to do a collaboration. In other words, he would help sponsor a project
03:12:57 <gentauro> but I got money from "other sources" so I declined :)
03:13:24 <gentauro> but now I soon will need to hook up with a few Haskellers, at least in Europe, so I'm looking for options :)
03:13:35 <phadej> gentauro: "we" ?
03:14:12 <gentauro> phadej: me and Tweag.io ;)
03:16:07 <Logio> bwe: if you do not want to make more specific newtypes for the new class, it's easiest to just define a smart constructor explicitly as a separate function
03:17:03 <tdammers> gentauro: if you're looking to hire contractors, feel free to contact Well-Typed
03:17:10 <kosmikus> gentauro: if you want to talk to us (Well-Typed), then email might be a better option :)
03:17:21 <phadej> gentauro: you alone, I see.
03:17:41 <phadej> wow, both duncan and andres on IRC in the same hour (almost)
03:17:42 <bwe> Logio: Do you mean something along the lines of https://wiki.haskell.org/Smart_constructors#Smart.28er.29_constructors ?
03:18:04 <kosmikus> phadej: not so rare these days.
03:18:11 <phadej> kosmikus: good!
03:19:09 <Logio> bwe: yes, exactly
03:20:44 <bwe> Logio: I have at least five options at my disposal: 1) coq (dependent types) 2) idris (dependent types) 3) Liquid Haskell 4) Haskell arbitrary subsets http://hackage.haskell.org/package/hoopl-3.10.2.2/docs/src/Compiler-Hoopl-Pointed.html#Pointed 5) Haskell smart constructors.
03:23:35 <Logio> bwe: sure, the choice of the cannon depends on the kind of bug you're hoping to squash
03:25:12 <Logio> if you're not hoping to generalize much, you could also make the allowed colours etc. their own types and convert between them just using standard Haskell
03:26:06 <Logio> or rather, if you only have a few ProductClassX's
03:29:14 <bwe> Logio: The bug to squash is devising a hierarchy of product categories. One attribute would have a dozen variants (sum type). Roughly 6 product categories in total. There are ≈ 5 tier-1 attributes, plus some tier-2. Also I would have to implement smart constructors, if I opt for them, on the tier-2 level.
03:36:33 <c50a326> hey it's pretty frustrating that hindent can only indent source code that compiles?
03:36:39 <c50a326> or at least it seems that way
03:36:58 <c50a326> it's just indentation, it's for when you're writing code, so surely it should just indent it without worrying about the validity of the code...
03:41:36 * hackage rhine 0.4.0.3 - Functional Reactive Programming with type-level clocks  http://hackage.haskell.org/package/rhine-0.4.0.3 (turion)
03:44:20 <lavalike> c50a326: I see as an instrument, if your editor tries to fix up indentation on every save, you catch mistakes early because you get a visual response
03:48:44 <sm> c50a326: I think to indent haskell correctly you have to parse it
03:49:25 <__monty__> Yeah, significant whitespace.
03:50:07 <c50a326> ah
03:50:47 <pavonia> Shouldn't lexing be enough?
03:51:15 <c50a326> what's the difference
03:51:31 <geekosaur> no; consider a let without in in a do
03:51:40 <phadej> pavonia: to reindent you need to get some structure
03:51:40 <__monty__> No, you need the AST, a sequence of lexemes doesn't tell you where the blocks fit in.
03:51:45 <geekosaur> you need the semantic level to know the structure
03:56:42 <c50a326> is the "Stream" SocketType TCP?
03:56:44 <quicksilver> well it's debatable
03:56:57 <c50a326> presumably SOCK_DGRAM is UDP?
03:57:03 <quicksilver> some people would say the indentation is part of the lexical structure of haskell
03:57:13 <quicksilver> depends how tight your definition of lexical is
03:57:25 <quicksilver> probably the exact definitoin of the word is not that important
03:58:49 <c50a326> ah stream is like tcp or sctp, okay
03:59:34 <Gurkenglas> :t unfoldr . runStateT . ($ StateT uncons) -- Can this be written more lensily?
03:59:35 <lambdabot> (StateT [a1] Maybe a1 -> StateT b Maybe a2) -> b -> [a2]
03:59:55 <__monty__> quicksilver: I agree it's part of the lexical *structure* but I'd still say deciding what the indentation means is the parser's job.
04:01:04 <c50a326> what's addrCanonName?
04:01:11 <geekosaur> I would say that if you are trying to reindent, that is, recover indentation from the program, you need to go beyond the lexical level to do so
04:01:35 <geekosaur> becuase you are asserting up front that that part of the lexical information is wrong/missing
04:01:49 <geekosaur> but as such, this means there will be ambiguity because indentation *is* part of the lexical structure
04:03:39 <Gurkenglas> (The code is intended as implementing (forall m. Monad m => m a -> m b) -> [a] -> [b]).)
04:03:47 <__monty__> I assumed we were talking about going from one valid layout to another. Fixing indentation sounds like a much harder and probably impossible problem to solve. How could you determine someone intended a different layout if the current one has valid semantics?
04:05:59 <vides_> Don't know how's the algorithm, I believe it really depends on the language and I'm not so fluent of haskell (yet, that's why I'm here). In other languages, certain keywords always adscribe themselves as a top-level markers, like namespace in C++/C#. Ea, upon finding this keyword, you could just restart the indention level, regardless of incomplete blocks above. Wouldn't it work in Haskell?
04:11:44 <geekosaur> vides_, there are some, but not enough to do so reliably
04:12:38 <geekosaur> and, well, if whitespace isn't needed to determine meaning, why is it significant to begin with? we already have fairly complex rules for decoding it, if it weren't actually needed then why have such rules?
04:13:01 <__monty__> vides_: I think where clauses are a simple example. If they're on a line by themselves you can choose your indentation of the body. If however you start the body on the where line you have to align the rest of the body.
04:13:29 <__monty__> geekosaur: It's not needed if you use {, } and ; though.
04:14:00 <geekosaur> __monty__, yes, and then you discover why it's needed
04:14:17 <geekosaur> (watch how many people forget let in do needs braces)
04:15:23 <__monty__> How can showing that whitespace is insignificant make you realize it's significant? o.O
04:16:08 <geekosaur> whitespace *is* braces. this is a case where you discover that you need the braces or equivalently whitespace, or you get an invalid parse
04:21:08 <mniip> is it possible to remove/deprecate a specific package version on hackage?
04:23:54 <geekosaur> if you are a maintainer for it, or a hackage trustee
04:24:46 <geekosaur> (under "edit package information" somewhere; try asking on #hackage)
04:26:42 <jiyaomu> hello
04:27:54 <liste> hi jiyaomu
04:28:06 * hackage raketka 1.1.2 - distributed-process node  http://hackage.haskell.org/package/raketka-1.1.2 (procione)
04:35:03 <gentauro> kosmikus: and tdammers roger that. I'm more interested in sending Haskell work to you ;)
04:35:16 <gentauro> (I'll provide details in a month and so) :)
04:35:37 <croben_> in a PLT-class, what could be good reasons to switch to scala from haskell?
04:35:45 <croben_> preferably language reasons
04:36:25 <croben_> there's lazy/eager
04:36:47 <cocreature> you’re coming into a Haskell channel asking for reasons to switch _away_ from Haskell? :)
04:37:12 <croben_> cocreature: haha, yeah
04:37:29 <mniip> i n t e l l i g e n t  d e s i g n  http://tcpst.net/3w_n.png
04:37:44 <Ariakenom> burn the heathen!
04:37:54 <croben_> our professor wants a reason that is not IO, libraries or industry
04:38:09 <cocreature> dunno, Haskell seems pretty well suited for a plt-class
04:38:44 <croben_> yes, but we're also doing scala, so we need a natural switch
04:39:26 <croben_> really struggling to come up with a problem where we can be like "for this reason, we now switch to scala to solve this"
04:39:49 <mniip> flexibility?
04:40:01 <cocreature> teaching students a wider variety of languages seems more useful than making them an expert in a single language. you have the whole rest of your professional life for that
04:40:08 <mniip> considering scala runs on the jvm I assume it's still got the reflection/dynamic loading bits?
04:40:11 <liste> croben_: maybe scala's macro system?
04:40:12 <mniip> that's a PITA to do in haskell
04:40:36 <liste> or does it even have one
04:40:49 <Ariakenom> java reflection is easier than hs generic? I would have thought not
04:41:05 <mniip> Ariakenom, java classloaders are easier than ghc api
04:41:07 <liste> GHC generics is not runtime reflection
04:41:20 <liste> at least to arbitrary objects
04:41:41 <liste> with Java you can get any arbitrary value and discover its members dynamically
04:41:53 <liste> including member functions
04:42:15 <mniip> haskell has no member functions but oh well
04:42:33 <Ariakenom> isn't the same true for like Data a => a? I don't know generics
04:42:45 <mniip> there is a bit of reflection in RTTI
04:42:51 <mniip> used in e.g GHCI's debugger
04:43:06 <croben_> what kind of problems would you solve with java reflections?
04:43:32 <liste> croben_: eg. serializing arbitrary values on disk
04:43:45 <mniip> croben_, humorous example but whenever I write an IRC bot I cannot imagine not having a reload command
04:43:46 <liste> though GHC generics suit that use case too
04:43:58 <mniip> doing something like this in haskell is a *mess*
04:44:13 <mniip> even C is better at it
04:45:49 <quicksilver> well, when they wrote lambdabot over 10 years ago, one of the very first things they did was implement hot reloading for it
04:46:20 <Ariakenom> > "Hello World"
04:46:22 <lambdabot>  "Hello World"
04:46:33 <croben_> that's a great tip, thanks
04:47:19 <zincy> Does anyone else find debugging multithreaded apps with channels hell
04:47:35 <mniip> quicksilver, via serdes or via the ghc api?
04:47:49 <Ariakenom> so is Java reflection stronger|better than hs generics?
04:48:06 * hackage easytensor 1.0.0.1 - Pure, type-indexed haskell vector, matrix, and tensor library.  http://hackage.haskell.org/package/easytensor-1.0.0.1 (achirkin)
04:48:51 <mniip> java's reflection is omnipresent - something we cannot allow in a parametric polymorphism language
04:49:04 <croben_> Ariakenom: that is what we need to argue for our problem
04:49:52 <croben_> we need something we can sort of introduce in haskell, where our students will be "relieved" to be able to solve it in an easier way
04:50:26 <__monty__> Wouldn't the best motivation for switching to scala be having to interact with existing java code?
04:50:54 <croben_> __monty__: yes, but apparently that's not good enough for our prof
04:51:46 <cocreature> well, interacting with existing java code doesn’t seem particularly relevant for a plt class
04:52:18 <croben_> dates might be an argument
04:52:27 <liste> croben_: how about JIT vs AOT compilation?
04:52:38 <liste> JVM languages do JIT, Haskell does AOT
04:52:58 <Ariakenom> croben_: "we need something we can ..." why?
04:53:01 <croben_> liste: also a valid point
04:53:28 <croben_> Ariakenom: i don't know, i think he has this vision of making the students feel the need for scala
04:53:31 <__monty__> In a plt class I think java's more interesting to treat than scala if you're already doing haskell.
04:53:54 <__monty__> How do you show the need for haskell?
04:53:55 <Ariakenom> That sounds super strange croben_
04:55:32 <croben_> Ariakenom: it's not really that strange, you want the students to understand why scala is used
04:56:56 <croben_> why we're using scala at all, is another thing
04:56:57 <Ariakenom> It is though. That type of reason doesn't necessarily exist.
04:57:21 <croben_> lazy/eager is a reason
04:57:31 <croben_> working with dates/IO is a reason
04:57:55 <__monty__> But running on the jvm *is* the actualy reason scala is used. If that's not good enough then any reason you come up with isn't an accurate reflection of reality.
04:58:18 <Ariakenom> exactly __monty__
04:58:28 <croben_> valid point and i agree
04:59:44 <ben> can yall recommend any reading material for how the things haskell is good at enable high-level simplifications in program structure/architecture, or something like that?
04:59:44 <[exa]> everytime people jvm a kitten dies
05:00:07 <dstolfa> hmm, i'm not sure any language in particular fits in a PLT class. in a "concepts of proglang" or something like that, sure, but PLT to me sounds like it should be a course on semantics, type theory and the likes
05:00:22 <ben> (sorry for the very open question :)
05:00:46 <[exa]> ben: by simplifications you mean optimizations by compiler or simplifications of the code?
05:00:50 <ben> of the code
05:01:04 <dstolfa> which is probably why we opt to call courses something more precise than just "PLT"
05:01:19 <[exa]> ben: monads! :]
05:01:52 <__monty__> dstolfa: I think they do fit as a motivating example sort of thing "We just treated call-by-need, Haskell's an actually language that uses it." I agree working with the language past things like fac is out of scope though.
05:02:27 <__monty__> Hmm, need to stop being such a y's guy.
05:02:48 <dstolfa> __monty__: oh yeah, exemplifying is always good. i was just thinking along the lines of not talking about the JVM and the likes, but focusing on the programming language itself and coming up with a very simple one (such as lambda calculus) to explore some of its semantic differences to other models of computation
05:03:18 <dstolfa> i.e. lifting from the syntax into the semantic differences and proving a number of properties about it
05:04:20 <dstolfa> a simple example would be: oh look, in un(i)typed lambda calculus beta-reduction is not normalising, let's add some types to it to make it strongly normalising and show how we can prevent the programmer from constructing ill-formed expressions w.r.t. the problem we're trying to solve
05:04:29 <dstolfa> and then prove that indeed it has prevented it
05:04:53 <__monty__> Yeah, PLT screams TAPL to me.
05:08:20 <croben_> dstolfa: that's what i would do, if i had free rein
05:09:05 <croben_> __monty__: i also wanted to use that, but it's clear from the into that the prerequisites for TAPL equals the curriculum in this class
05:09:49 <__monty__> Then PLT is definitely a misnomer.
05:10:00 <dstolfa> croben_: to me it sounds like it's a "Concepts in Programming Languages" course, where you talk about abstractions programmers use and what the motivation for them is
05:10:24 <dstolfa> and perhaps a small route to semantics, but not in detail
05:11:15 <cocreature> we have a similar course here called “programming paradigms”
05:11:36 <croben_> we do include semantics
05:11:51 <ben> like, what i was looking for is an "introductory" kinda text to haskell/fp but not in the "here's how to fold over the list, isn't it cool" sense, but more of a high-level review of how the architecture of a non-trivial application will differ between a well-designed idiomatic haskell codebase and say a well-designed idiomatic golang codebase
05:12:37 <__monty__> ben: There's not much architecture info on haskell yet afaik.
05:12:45 <tdammers> tbh, the haskell world is still debating what the best overall architecture would look like
05:13:02 <tdammers> there's no one-size-fits-all solution
05:13:02 <__monty__> croben_: Maybe sicp or eopl would be a good text?
05:13:40 <muzzle> hi, is there a way to list all constructors of a type without using template haskell?
05:13:51 <gentauro> tdammers: isn't it the same saying that all other coded stuff should be done the same way?
05:14:06 <gentauro> I mean coding drivers differs very much from coding Macros for Excel
05:14:13 <ben> tdammers: im not looking for concrete guidelines more so than an elaboration on what kind of design is enabled by haskell that wouldn't be convenient in mainstream imperative langs
05:14:52 <[exa]> ben: I said monads :] monadic DSLs are a big selling point
05:14:58 <ben> yeah i don't disagree!
05:15:14 <[exa]> but I'm not aware of any concise document that would classify all the differences
05:15:27 <[exa]> you might want to read the functional pearls from ICFPs
05:15:31 <gentauro> ben: restriction and (sub)granulation of side-effects is what I think no other language can achieve -> http://blog.stermon.com/articles/2018/06/26/haskell-restricted-and-rec-granulated-io-effects.html
05:15:34 <hpc> muzzle: use the Data and Typeable classes
05:15:56 <gentauro> but there are so much other stuff as well
05:16:03 <gentauro> it's just two different worlds
05:16:35 <hpc> muzzle: dataTypeOf @Foo undefined -- gives you a DataType value for your type Foo
05:16:49 <merijn> ben: Honestly, I'm not convinced "good" and maintainable Hasekll architectures differ substantially from those you encounter in other languages
05:17:05 <merijn> Not on the high level, at least
05:17:10 <hpc> dataTypeConstrs (dataTypeOf @Foo undefined) :: [Constr]
05:17:18 <merijn> On the specific implementation/low level, sure there's lots of differences
05:17:33 <croben_> __monty__: we used this one before https://www.amazon.com/Concepts-Techniques-Models-Computer-Programming/dp/0262220695
05:18:26 <c50a326> hindent outputs its errors directly into my files in vim, why on earth would it do that
05:18:34 <c50a326> so annoying
05:19:00 <muzzle> hpc: thanks
05:19:04 <muzzle> hpc: that should work
05:19:07 <ben> merijn: hmm, i'd have thought youd at least end up reaching for patterns like tiny interpreters and combinators and so on a lot more and more eagerly than you would in say C#
05:19:30 <ben> doesnt that affect large-scale architecture?
05:19:36 <ben> (or that sorta thing)
05:20:00 <merijn> ben: Well, you certainly use "more difficult" solutions sooner, because they tend to be easier to implement than in other languages
05:20:55 <c50a326> oh that was that vim-hindent plugin, I should just do the ftplugin file like in the docs, I think I fixed it, nvm
05:21:00 <__monty__> c50a326: Check out vim-hindent, or neoformat, or ale. Currently looking into the latter two.
05:22:46 <dstolfa> croben_: FWIW this is what a colleague of mine uses for a similar course which comes *after* semantics in PL which deals with operational/denotational semantics and a bunch of proofs of L1/L2/L3 and some things regarding proofs in concurrent models of computation: https://www.cl.cam.ac.uk/teaching/1718/ConceptsPL/lectures-4up.pdf
05:22:58 <dstolfa> idk if it's of any help, but the materials are open so might as well
05:24:20 <dmwit> ben: STM is pretty neat and not really sane in other languages.
05:24:51 <ben> hmm yeah
05:25:14 <c50a326> __monty__: vim-hindent was what was doing that, it's not doing that anymore :D
05:25:23 <ben> how widely-used is STM?
05:26:05 <dmwit> A(lgebraic)DTs are pretty great. Sums of products covers a surprisingly large collection of use cases for data types, so A(bstract)DTs are much less common in Haskell than other languages.
05:26:23 <dmwit> Not super wide.
05:26:26 <ben> yeah, maybe what im thinking of boils down to how people define module boundaries in haskell that are not "here's an (OOP) class, you can ask it to do a bunch of things, have fun"
05:27:31 <__monty__> c50a326: Then you probably set it up wrong. It's the entire point of the plugin so I can't imagine them changing it.
05:27:34 <dmwit> Combinator libraries are used like crazy in Haskell compared to other languages. I suspect this is in part because of how clean it can be to have functions/closures as part of your denotation.
05:27:46 <merijn> ben: But I think the logic of defining data structures and how they related is the most important part of any design
05:28:32 <merijn> ben: Honestly I just start with a single module and just split stuff into smaller modules as soon as it gets cluttered and I'll decide what to split off and where based on whatever makes sense at the time. It's usually trivial to refactor and change anyway
05:28:57 <croben_> dstolfa: thank you
05:28:57 <dmwit> (Both clean meaning good design, but also clean meaning syntactically lightweight for both users and library implementors.)
05:29:01 <c50a326> __monty__: the hindent docs say to just do this https://github.com/commercialhaskell/hindent#vim so that's what I'm doing now
05:29:02 <ben> merijn: do you do that the same way in both haskell and oop langs?
05:29:03 <merijn> I don't think there's some magical logic on how to split things up
05:29:04 <croben_> i'll have a look at it
05:29:23 <merijn> ben: When I write OOP languages I mostly try and stick to "dumb" structs anyway
05:29:40 <merijn> ben: And try to keep the logic inside functions, how well that works depends on the language
05:29:41 <c50a326> __monty__: I'll check out neoformat and ale though, I have heard a lot about ale
05:30:28 <__monty__> I might replace syntastic with ale. Still looking at neoformat to get visual range formatting with brittany though.
05:30:44 <ben> like, I tend to find myself frustrated in some langs when I try to split something up and it turns out the lang doesn't let me abstract over the thing that's keeping it together
05:31:11 <ben> so it's "split" but still super coupled because maybe the interface of both sides has to match exactly and mention a common type or something
05:31:54 <merijn> ben: Right, but in Haskell it's not very common to not be able to find some abstraction that makes it work
05:31:59 <ben> yeah
05:32:24 <drets> How to make `data A = B { foo :: !Integer , bar :: !Integer } | C !(Maybe Text)` to be a bit more type-safe? So `foo` never throws runtime error
05:32:44 <ben> so in that sense i feel like haskell having a meaningful type system immediately enables simplifications of large-scale program structure that another lang would resist
05:32:57 <ben> and im wondering what more subtle expressions of that there are
05:33:17 <merijn> drets: "don't use record syntax with fields not share across datatypes", but I suppose that's not the answer you're looking for
05:34:02 <ben> "don't export foo but export a wrapper that matches and returns Maybe Integer?"
05:34:04 <drets> yep, then we loose description that this is “foo” :) if I do B Int Int.
05:34:06 <merijn> ben: I mean, I agree it simplifies things and makes things easier, I'm just saying that I don't think that (on a fundamental level) you're making different design choices. It's just that the cost of abstracting things out is lowered
05:34:29 <dmwit> drets: data A = B Integer Integer | C (Maybe Text); foo (B x _) = x; bar (B _ y) = y
05:34:37 <dmwit> oops
05:34:38 <merijn> drets: You could make a separate record type and have "B ThisNewRecordType | C (Maybe Text)"
05:34:46 <sras> Can someone please give a review of an article I wrote that lists some of my  "Aha!" moments while I was learning Haskell.  https://sras.me/haskell/miscellaneous-enlightenments.html
05:34:51 <dmwit> drets: data A = B Integer Integer | C (Maybe Text); foo (B x _) = Just x; foo _ = Nothing; bar (B _ y) = Just y); bar _ = Nothing
05:35:45 <drets> merijn, interesting....
05:36:13 <hexagoxel> when specifying laws, do underscores imply non-strict matching?
05:36:29 <merijn> hexagoxel: Like where?
05:36:57 <merijn> ben: Fortunately there's some reasonably big codebases you can have a look at to see how things are organised ;) GHC and pandoc are pretty big Haskell projects
05:37:06 <merijn> ben: XMonad isn't very big, but it is rather clean
05:37:39 <dmwit> hexagoxel: I think the general convention in Haskell is that laws ignore the existence of bottom entirely.
05:38:01 <ben> merijn: with how people strive for "minimalism" in some way, my intuition would be that the cost informs what abstractions are made in the first place, and that that'd inform module boundaries and eventually large-scale structure, but maybe I'm overthinking it
05:38:12 <merijn> dmwit: Depends who you talk to, there's some fundamentalists on that topic ;)
05:38:44 <merijn> dmwit: But then you wave you hands and start shouting "fast and loose reasoning is morally correct!"
05:38:55 <gentauro> > data Foo
05:38:57 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
05:38:59 <dmwit> merijn: Opinions on what *should* be done may vary. But the convention is strong, independently of what should be done.
05:39:06 <gentauro> % data Foo
05:39:07 <yahb> gentauro:
05:39:29 <gentauro>  % data Bar = Bar Int
05:39:30 <drets> Thanks for the previous answers. I am going to ask another question if it's OK :)
05:39:49 <ben> thanks for the insights y'all, i'll go read some code :)
05:40:15 <gentauro> why is it even possible to define: data Foo
05:40:16 <merijn> ben: Writing code is usually even better ;)
05:40:17 <__monty__> sras: But type inference *is* only part of the type system. There's no inference at runtime or anything.
05:40:19 <merijn> gentauro: Why not?
05:40:21 <gentauro> what is the usage for that?
05:40:23 <dmwit> gentauro: Why should it be prevented?
05:40:29 <merijn> gentauro: Phantom types, for one
05:40:38 <merijn> To signal non-termination
05:40:49 <merijn> I'm sure someone can invent some other uses
05:40:49 <ben> merijn: i feel like i tend to spend too much time writing code and not enough time reflecting on it :P
05:40:59 <drets> I have everywhere exclamation mark in by datatype constructors like a :: !Integer or b :: !(Maybe Int). Is there ghc extension which may write it instead of me?
05:41:08 <ben> or rather like at the end of the day, i tend to have too much code and not enough insight
05:41:14 <gentauro> merijn: for PT i would guess something like this -> data Bar b
05:41:16 <dmwit> gentauro: The advent of 0 was a great moment in mathematics. `data Foo` is like zero for `Either`.
05:41:18 <Taneb> gentauro: it sometimes gets used for FFI interfaces when you're dealing on the C side with *(hidden structure)
05:41:22 <merijn> ben: Spend more time refactoring and obsessing on how to clean it up
05:41:24 <gentauro> where you could Data Int or Data Char
05:41:35 <merijn> gentauro: No, I meant as argument to a type expecting a phantom
05:41:37 <Taneb> gentauro: so in Haskell you use data Structure and Ptr Structure
05:42:24 <merijn> "data Escaped; data Unescaped; newtype URLString a = URLString String" and now you can use "URLString Escaped" and "URLString Unescaped: to encode things
05:42:27 <gentauro> Taneb: Ptr as in Pointer?
05:42:43 <gentauro> merijn: I get that
05:42:43 <drets> (i.e. I want to make my datatypes stricker)
05:42:47 <hexagoxel> dmwit, merijn thanks, i'll make the strictness expectations explicit then
05:42:52 <merijn> gentauro: Ptr is the FFI for C pointers, yes
05:42:57 <Taneb> gentauro: yeah
05:43:01 <cocreature> drets: StrictData
05:43:03 <gentauro> now that I think about it, it's way more elegang than OCamls -> type foo = Foo
05:43:16 <drets> danke
05:43:43 <merijn> drets: You might also want to use UNPACK if you're going to be strict anyway
05:43:58 <merijn> (although that only works for non-polymorphic data)
05:45:39 <merijn> hexagoxel: Generally, if a proof/law holds in the absence of bottom, then the worst thing that can happen by ignoring strictness in your code is that now slightly less code crashes, which is generally considered an upside anyway
05:45:44 <merijn> hexagoxel: Hence why most people ignore it
05:46:21 <sras> __monty__:  Can you tell me which part you are refering to?
05:48:35 <__monty__> sras: It's in the return type polymorphism section.
05:58:06 <gentauro> merijn: here are some Phantom Types in action -> https://lpaste.net/1981380177283776512
05:58:40 <gentauro> but since I define -> data Foo and not data Foo = Foo, I can't derive Show
05:59:08 <gentauro> is it possible to distinguish the to switch states when persisted to output ?
06:00:06 <gentauro> I wouldn't be able to get "a" even tough I write my own instance of Show for Switch right?
06:03:13 <sras> __monty__: On giving some thought, It is confusing. I think I bettr remove it.
06:03:19 <merijn> gentauro: Well, you can't ever create a value of type Foo
06:03:26 <merijn> gentauro: That's part of it's usefulness
06:04:09 <merijn> The only value of type Foo is bottom
06:06:03 <gentauro> merijn: I once implemented this in F# and cos of .NET it had reflection so I could "fish" the value out -> http://blog.stermon.com/articles/2016/10/06/model-state-machine-with-types.html
06:06:30 <gentauro> but those "nasty tricks" don't really work in Haskell (and thank _ for that)
06:06:52 <merijn> gentauro: Well, yes, that's why reflection is pretty much evil :)
06:07:32 <gentauro> yeah, but it's easier (clearner code) to implement a state machine and it's transitions in Haskell. My only problem is that I don't know the state :)
06:07:51 <gentauro> which makes it kind of useless ... A bit like haskell without the IO layer ;)
06:09:33 <dmwit> gentauro:
06:09:39 <dmwit> % data Void
06:09:39 <yahb> dmwit:
06:09:44 <dmwit> % deriving instance Show Void
06:09:44 <yahb> dmwit:
06:09:59 <cocreature> dmwit: iirc that’s a fairly recent change
06:10:09 <cocreature> or was it Eq that needed to be changed?
06:11:40 <sjakobi> With cabal new-haddock, how do I also build the haddocks for my dependencies, like stack haddock does it?
06:12:04 <cocreature> ah no, the new part is that it works without standalone deriving
06:12:17 <cocreature> if you enable EmptyDataDeriving
06:12:29 <merijn> sjakobi: It should, but it might be a bit broken atm
06:12:30 <dmwit> sjakobi: https://github.com/haskell/cabal/issues/5383
06:12:40 <merijn> sjakobi: Also depends heavily on which cabal-install version you have
06:12:51 <gentauro> dmwit: Void is defined as data Void = Void !Void right?
06:12:59 <gentauro> > data Void = Void !Void
06:13:02 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
06:13:06 <gentauro>  % data Void = Void !Void
06:13:11 <cocreature> gentauro: no it is defined as "data Void"
06:13:14 <cocreature> without any constructors
06:13:24 <gentauro> cocreature: roger
06:13:34 <dmwit> gentauro: No, I defined it in the previous % command as `data Void`.p
06:14:03 <dmwit> (And the standard library that offers `Void` defines it in the same way.
06:14:05 <dmwit> )
06:14:26 <sras> __monty__:  Did you find anything else?
06:14:27 <bwe> How can I constrain a type constructor by specific type? failed approach: https://bpaste.net/show/147deea44bd7
06:14:29 <gentauro> dmwit: λ :set -XStandaloneDeriving
06:14:29 <sjakobi> merijn, dmwit: Thanks, I use the latest cabal-install-head from Herbert's repo.
06:15:00 <sjakobi> Is there a workaround that I can use to build the dependency docs?
06:15:36 <merijn> sjakobi: Specify "documentation: True" in cabal.project before building anything. Which admittedly isn't really helpful now xD
06:16:03 <dmwit> sjakobi: You can make a sandbox, build the documentation in there, then throw away the sandbox. =(
06:16:17 <dmwit> sjakobi: (i.e. with old-haddock)
06:17:27 <dmwit> bwe: I'm not sure I understand the question yet. If you do not just want `data Value = SingleValue Unit | FromTo Unit Unit`, can you say a bit more about what you mean by `Value => Unit a`?
06:17:52 <cocreature> it sounds like bwe might be looking for GADTs
06:18:01 <dmwit> Maybe DataKinds?
06:18:03 <dmwit> Not really clear to me.
06:18:42 <bwe> a should be either be Kilograms or Grams.
06:19:15 <dmwit> Suppose `a` were Kilograms. What would a sample value of type `Value` be in that situation?
06:19:23 <__monty__> sras: I only skimmed. Came across some typos: lets... to create, lets... to refer, haskell functions does, on hindsight, lets you to define, a let expressions, exported out, there's probably others since I only skimmed.
06:19:34 <merijn> Use DataKinds and write "data Value (a :: Unit) = ..."
06:20:19 <dmwit> merijn: Do fill in the `...` and make sure it's sensible. e.g. taking the existing RHS of the `=` would not be a sensible replacement for `...`.
06:20:32 <merijn> oh, right
06:20:43 <merijn> ok, then I dunno what this is supposed to be, tbh
06:20:56 <dmwit> Hence my questions. =)
06:23:51 <bwe> I corrected the definition of Unit to: data Unit = Kilograms Int | Grams Int deriving Show
06:24:42 <bwe> dmwit: What should Value work like? It should either take a single value or describe a range with lower and upper bound.
06:24:56 <bwe> data Value a = SingleValue a | FromTo (a, a) deriving Show -- would work basically
06:25:59 <bwe> dmwit: However, considering   type Measurements = [Value] -- I cannot tell in advance whether it will be of Kilograms or Grams. I want to make it agnostic.
06:27:16 <sjakobi> merijn: "documentation: True" doesn't seem to work for me.
06:27:38 <merijn> sjakobi: If the dependencies have already been build (like in your case) it won't fix things, no
06:28:04 <sras> __monty__:  Thanks.
06:28:04 <sjakobi> merijn: It should work if I nuke my dist-newstyle/ and ~/.cabal, no?
06:28:13 <sjakobi> But it didn't.
06:28:48 <merijn> hmmm
06:29:36 <bwe> dmwit: I've put the current working state together into https://bpaste.net/show/9c9368c55da2
06:30:32 <sjakobi> merijn: At least I can't find any dependency docs in either ~/.cabal/store or the dist-newstyle/
06:31:56 <merijn> sjakobi: Then I dunno, sorry
06:32:32 <sjakobi> merijn: Thx anyway! :)
06:35:09 <dmwit> bwe: I think you want `data Value = SingleValue Unit | FromTo Unit Unit`.
06:35:56 <dmwit> bwe: This will let you freely mix kilograms and grams in your list.
06:36:45 <sjakobi> How do I build dependency haddocks with old-style cabal then? (I don't mind nuking my ~/.cabal every day)
06:36:57 <dmwit> bwe: If instead you want to enable lists of kilograms, and enable lists of grams, but want to prevent them from mixing, then you should use DataKinds. I'll be happy to expand on how if I have misunderstood what you want.
06:38:36 * hackage primitive-extras 0.1.6 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.1.6 (NikitaVolkov)
06:38:54 <dmwit> sjakobi: If you use a sandbox, you don't need to nuke ~/.cabal.
06:39:20 <dmwit> sjakobi: Then the way is just `mkdir s; cd s; cabal sandbox init; cabal install whatever --enable-documentation`.
06:39:32 <exarkun> is there a junit xml formatter for HSpec/HUnit?  I found hspec-jenkins but it's badly out of date, apparently (does not build against remotely recent hspec).
06:40:00 <bwe> dmwit: confirmed. It's exactly what I needed.
06:40:55 <bwe> dmwit: Thanks for your support!
06:47:15 <sjakobi> dmwit: Thanks, that works for me. :)
06:47:31 <pally> I want to talk about precedence vs. execution order
06:47:40 <pally> s/talk/ask/
06:48:28 <Ariakenom> > 1 `const` abs 3
06:48:31 <lambdabot>  1
06:49:22 <pally> > True || False && True
06:49:25 <lambdabot>  True
06:49:33 <merijn> pally: There's basically 0 correlation between the two
06:49:35 <Ariakenom> join :: Ask (Ask x) -> Ask x
06:50:09 <croben_> wondering if maybe a discussion on total fp, heavy usage of partial functions, Maybe monad/Bottom vs null/catching exceptions could be a good transition to scala from haskell
06:50:35 <pally> In Haskell, do we know side of || gets executed first?
06:51:02 <merijn> pally: Yes, but only because the implementation is documented
06:51:24 <merijn> (i.e. like in all languages the boolean operators are left-to-right)
06:51:29 <pally> merijin, _implementation_
06:51:54 <tdammers> pally: the important bit here is that || isn't special in Haskell, it's just another plain old function
06:52:08 <pally> tdammers, yes, I understand that.
06:52:38 <tdammers> however, evaluation order in Haskell works a bit different than it does in a strict language
06:52:49 <Ariakenom> pally: Worth noting that since Haskell is pure the only way you can tell which executed first is exceptions. Also time and memory
06:53:02 <Ariakenom> s/executed/evaluated
06:53:06 <tdammers> in a strict language, evaluation order depends only on the call side - by the time the evaluator steps into the function, all the required values have been evaluated already
06:53:20 <tdammers> Ariakenom: also bottoms
06:53:25 <pally> Ariakenom, that is precisely what I want to verify.
06:53:28 <tdammers> Ariakenom: but those are arguably exceptions too
06:53:34 <pally> My instructor was trying to point that out to me yesterday.
06:53:58 <tdammers> but in Haskell, evaluation happens on a need-to-know basis - things are only evaluated far enough to continue evaluation
06:54:34 <tdammers> so in a function like ||, which argument gets evaluated first depends on which of them the function looks at first
06:54:46 <tdammers> e.g., you could implement it like so:
06:54:54 <tdammers> a || b = if b then True else a
06:55:46 <tdammers> which would evaluate the if expression far enough to decide which branch to use, which in turn requires evaluating b far enough to tell whether it is True or False (which happens to mean it gets evaluated fully)
06:56:00 <tdammers> but it doesn't have to evaluate a in order to make that decision, so a doesn't get evaluated before b
06:56:12 <tdammers> but you can also implement it like so:
06:56:20 <tdammers> a || b = if a then True else b
06:56:32 <tdammers> then the logic is reversed, and a gets evaluated before b
06:56:42 <tdammers> you can't tell from the signature
06:57:50 <pally> tdammers, Thanks.  Precisely, this what I am looking for.  I previously confused precedence with order of execution. :-(
06:58:01 <pally> err.. this *is*
07:01:03 <tdammers> precedence is indeed orthogonal
07:01:13 <tdammers> precedence just tells you how operators combine
07:01:50 <tdammers> foo >%! bar ~!@ baz -- just making up operators here
07:01:53 <pally> speaking of strict (or stricter) languages, I believe even C, there are instances where the order of operations is undefined.
07:02:10 <pally> the order of operations depend on something called sequence points.
07:02:11 <tdammers> is it (foo >%! bar) ~!@ baz or foo >%! (bar ~%! baz)?
07:02:34 <Putonlalla> Yes, the same thing applies there, pally.
07:02:44 <tdammers> pally: yes, and that's in part because all languages have non-strict constructs; a completely strict language wouldn't be very useful
07:03:01 <akyeden> Hi, I got an opportunity to data science, I left programming years back and only once in 2-3 weeks learning Haskell...Should I continue with haskell or move back to python
07:03:35 <nschoe> Hi, is there a working library to send emails using STMPS?
07:03:36 <tdammers> if (condition) { do_one_thing(); } else { do_something_else(); } // how would that work if both branches were evaluated / executed before checking the condition?
07:03:43 <pally> tdammers, you just brought up something else I want to talk about.  Why?
07:03:46 <tdammers> akyeden: both
07:03:55 <nschoe> I have tried "smtp-mail" and entering the same STMP settings that I did in Thunderbird, but it doesn't connect.
07:03:56 <CrunchyChewie> akyeden: a lot to unpack there... but I feel like python is probably a bit easier to pick up and probably more immediately relevant to data science
07:03:57 <pally> tdammers, why wouldn't it be useful?
07:04:04 <tdammers> pally: if C were completely strict, then you couldn't have conditional execution
07:04:13 <merijn> tdammers: Order of execution isn't very well defined in C even when disregarding the boolean operators
07:04:14 <akyeden> tdammers:  but python thinking anf haskell thinking totally different and that can damage my programming isnt it?
07:04:18 <nschoe> Port is 465, so I have the feeling this has to do with SMTPS not being supported.
07:04:34 <merijn> tdammers: In fact, it's completely unspecified in C, beyond the behaviour of sequence points
07:04:41 <akyeden> CrunchyChewie:  that applies same to Machine and deep learning I assume
07:04:44 <tdammers> merijn: well, yes, it's not just due to partial laziness
07:05:11 <tdammers> merijn: it's also for cross-platform performance reasons - C basically says "I'm not defining this, do whatever is faster on your target"
07:05:31 <merijn> akyeden: tbh, I disagree. So far my experience with all these (supposedly) amazing python data science and machine learning libraries has been...decidedly subpar
07:05:46 <merijn> akyeden: Performance is pretty abysmal, and so is usability
07:06:29 <akyeden> merijn: What do you use then ?
07:06:36 <pally> guys, I understand everything y'all explained so far except why is this non-determinism so important?
07:06:39 <akyeden> and are you professional or student ?
07:08:27 <merijn> akyeden: Currently I'm using a mix of Haskell and python. I'm still using scikit-learn (because I didn't want to reimplement the stuff I need from scratch) but I do all the data processing etc. in Haskell. I just write out the data to a python subprocess which runs the library functions I need and then dump the trained model to stdout (I reverse engineered the model implementation so I could implement my
07:08:33 <merijn> own version to be faster)
07:09:05 <merijn> My Haskell reimplementation of their predictor stuff is orders of magnitude faster
07:09:16 <akyeden> merijn:  then tdammers  is right I must need both :)  but I am worried to distubr my thinking
07:09:28 <quicksilver> mniip: the GHC api didn't exist then
07:09:49 <merijn> akyeden: It also depends on how big your dataset is. Despite the fancy talk about "big data", almost no one actually has big data and most of the data science people aren't very good at writing HPC code
07:09:51 <tdammers> akyeden: my reasons for that recommendation were entirely different ones, but this works too
07:09:55 <mniip> quicksilver, I'm having trouble finding that code in lambdabot now
07:10:12 <quicksilver> mniip: it was this http://hackage.haskell.org/package/plugins
07:10:38 <quicksilver> which was part of dons's PhD research I think?
07:10:45 <quicksilver> he used to IRC but no longer :/
07:10:48 <merijn> quicksilver: Yeah
07:10:57 <merijn> quicksilver: He's too busy photographing sunsets and biking! :p
07:10:57 <sras> merijn: Which Haskell library are you using for matrix operations?
07:11:09 <tdammers> it's not big data unless the rate at which you can purchase harddisks becomes a limiting factor ;)
07:11:15 <merijn> sras: None, I'm using Storable Vector
07:11:15 <dmwit> pally: Lazy evaluation order is not non-deterministic. But to answer the question you *meant* to ask, check out https://stackoverflow.com/q/7868507/791604
07:11:53 <akyeden> Thank you merijn , tdammers
07:12:13 <Taneb> merijn: we should make Medium Data a buzzword
07:12:20 <merijn> sras: I'd probably just use whatever BLAS wrapper exists if I need matrix code
07:12:37 <tdammers> Taneb: "slightly awkwardly sized data"
07:12:42 <merijn> Taneb: I talk to model checking people "yes, our models are so huge! truly big data!"
07:12:49 <[exa]> it's not big data unless gyro of your storage changes earth's rotation axis
07:12:50 <sras> merijn: Any reason for not using HMatrix?
07:13:09 <merijn> Taneb: So I ask them how big their graphs are "oh, 10 million vertices and 100s of million edges" 'ah, right, so several 10s of MBs?'
07:13:30 <quicksilver> merijn: his github page says he's at facebook london, I didn't know that
07:13:41 <merijn> sras: The main reason is that, when people say "matrix" and "fast" I hear "BLAS" :p
07:14:57 <nschoe> Any suggestions for sending STMPS?
07:15:28 <[exa]> nschoe: what requirements do you have?
07:15:53 <merijn> quicksilver: I saw he was recruiting people for there on twitter, yeah
07:16:28 <mniip> quicksilver, "the GHC api didn't exist then" - foreign import ccall unsafe "loadObj" - where does that import go then
07:16:46 <[exa]> nschoe: btw unless you're writing a mail client, you _want_ to have a specialized local mailserver doing all the SMTP for you
07:17:03 <quicksilver> mniip: that's not the GHC api, that's the FFI
07:17:21 <quicksilver> you'd have to read the paper
07:18:02 <quicksilver> I think he wrote something which directly used the implementation details of the GHC object loader
07:18:02 <mniip> "The low level interface is the binding to GHC's Linker.c. Therefore,"
07:18:08 * quicksilver nods
07:18:27 <quicksilver> the "ghc api" was something which came along a few years later as an officially supported way to do that
07:18:34 <mniip> are you drawing a line between haskell-importing GHC modules and FFIing with the C ghc code?
07:18:52 <quicksilver> I'm drwaing a line between an officially supported API
07:18:57 <quicksilver> and working under the hood to make things work
07:19:28 <mniip> are you saying the GHC api is in any way fixed?
07:19:34 <sras> merijn: So you use Storable Vector and call the c libraries from Haskell, loading Haskell data to memory?
07:20:34 <merijn> sras: I have the python dump out a "array of structs" representation of the model, abuse ByteString to turn it into a Storable Vector, then use a pure Haskell function to do predictions
07:20:46 <cocreature> the ghc API is more “we compiled ghc as a library rather than as an executable” instead of an officially supported API
07:21:02 <patlv> hi all, I'm having problem understanding the fold_ function in the package mysql-simple, I want to use it to populate a list, anyone has an example handy, couldn't find anything out there
07:21:45 <merijn> sras: Only the safest Haskell for me! https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Utils.hs ;)
07:22:42 <merijn> C is for people who don't use enough -XMagicHash in their Haskell
07:25:43 <mniip> % raise# ()
07:25:43 <yahb> mniip: [Segmentation fault]
07:25:48 <ggVGc> I'm writing haskell, to generate C, to run on atmega
07:25:57 <ggVGc> but there's a fair bit written in actual C :(
07:26:04 <ggVGc> well, actually "c++"
07:26:08 <ggVGc> e.g C with references
07:26:42 <tdammers> "c+=0.5"
07:26:50 <ggVGc> ^
07:27:19 <dmwit> I'm pretty sure c=0, c=1, or c=2 because c<3
07:27:30 <merijn> ggVGc: And template horrors :)
07:27:52 <merijn> ggVGc: RAII and std::shared_ptr and std::unique_ptr are pretty good, though!
07:28:29 <tdammers> my most beloved thing about C++ is how when they decided to use < and > for template syntax, they realized too late that this would clash with operator>>
07:29:06 <mniip> tdammers, what kind of sickened mind would ever try to use a template inside a template duhhh
07:29:06 <dmwit> and so: mandatory whitespace
07:29:09 <tdammers> foo<bar<baz>> cout;
07:29:15 <dmwit> Not that any language we use has mandatory whitespace anywhere.
07:29:37 <mniip> dmwit, reminds me of a language I made where the empty string was a valid identifier
07:29:42 <merijn> Naah, that's mostly solved by having a horrifically complex parser nowadays :)
07:29:54 <Ariakenom> EitherT<IO<a>>
07:30:21 <mniip> =123
07:30:27 <mniip> x = - 5 /
07:30:37 <Taneb> mniip: beautiful
07:30:58 <tdammers> merijn: the fun part is that to disambiguate foo<bar<baz>> quux; you need to know which of foo, bar, baz and quux are known type names in the current scope, i.e., you can't solve it in a purely lexical fashion
07:31:14 <dmwit> mniip: Too bad I already used up my "<3" joke.
07:31:28 <mniip> if <3 then
07:32:03 <merijn> tdammers: It's solved by making you prefix everything with "typename"
07:32:14 <merijn> tdammers: Which makes it really sucky to read/write
07:32:41 <tdammers> merijn: yep; and it makes for super annoying error messages
07:33:00 <merijn> Do you not like 82 page errors?
07:33:44 <mniip> I'm ok with that - my only request is to add some tooling to let me find the 'error' amidst all the 'note's
07:34:09 <tdammers> of course I do, the more the merrier, that's why I adore Clojure so much - they took Java's error messages and made them even better
07:34:45 <Ariakenom> 1GB ... error: forgot semicolon ... 1GB
07:34:57 <quicksilver> C++'s error messages serve a really useful purpose
07:35:03 <sras> merijn: Just want to clarify this. If I am storing a matrix as a Vector (Vector Double), and I am multiplying two of them in Haskell by walking over them, would it be as fast as calling matmul on same matrices in  a lowlevel c library?
07:35:03 <quicksilver> they remind us that things actually could be worse than haskell
07:35:29 <merijn> sras: Probably not, but that's not what I'm doing
07:36:13 <merijn> quicksilver: Actually, all these new "helpful" error messages in GHC are making me get nervous C++ flashbacks with the amount of space they take up...
07:36:21 <mniip> Ariakenom, template<class T>T t(T){t(t<T>);}int p=t(0);
07:37:11 <mniip> nice wallpaper http://tcpst.net/2z7j.png
07:37:40 <Ariakenom> nice
07:37:47 <mniip> if you zoom out a lot you can see the large scale structure of the universe
07:37:52 <sras> merijn: When you said you used pure Haskell functions to do predictions, what sort of functions were you refering to?
07:37:52 <ggVGc> dmwit: I've actually started disliking significant whitespace a lot lately :( After being really into it for most of my programming life
07:38:08 <ggVGc> mainly because you can't make a good autoformatter if you have significant whitespace
07:38:25 <merijn> sras: I'm using binary decision trees, so my predictor is just: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Model.hs#L33-L42
07:39:13 <merijn> I don't believe in auto-formatting. I believe in artisanally hand-formated source code
07:39:38 <dyl> merijn well, actually, uh
07:39:39 <dyl> https://github.com/eslint/eslint-scope/issues/39
07:39:40 <tdammers> each indent crafted with love and dedication
07:39:43 <dstolfa> merijn: you evil evil bastard :)
07:39:46 <zincy> you are joking right
07:39:51 <dyl> Looks like someone hijacked eslint and injected code to steal npm credentials ¯\_(ツ)_/¯
07:39:53 <merijn> dstolfa: hmm?
07:40:12 <dstolfa> merijn: manual formatting. my lazy side is screaming at you now
07:40:20 <[exa]> lol
07:40:36 <tdammers> in all fairness, it seems they compromised the release machinery, not the codebase itself
07:40:39 <merijn> dstolfa: I use auto-indent and stuff, but just barely
07:40:59 <dmj`> @package nyan
07:40:59 <lambdabot> http://hackage.haskell.org/package/nyan
07:41:13 <dstolfa> merijn: i'm just lazy.
07:41:28 <merijn> I spend much more time thinking that writing code, so 1 second extra to decide the formatting myself is irrelevant and much more readable than most auto-formatters
07:41:49 <dmwit> dstolfa: :set ci pi takes care of the vast majority of it.
07:42:02 <dstolfa> dmwit: i just use ghcmod and a few vim keybinds to align things
07:42:08 <dmwit> A handful of :Tab aliases does the vast majority of the rest.
07:42:18 <dstolfa> like, align on =, align on ::, align on , and so on
07:42:42 <dstolfa> merijn: i do too, but i really, really hate doing menial things
07:43:00 <merijn> Artisanal, not menial!
07:43:04 <dstolfa> at times, i even consider programming menial :(
07:43:17 <dstolfa> if i'm doing formal things, i'll be like look, this is how it works, here's a bunch of proofs, go program it!
07:43:27 <dstolfa> and then my supervisor will look at me and be like: no, you go program it
07:43:28 <dstolfa> and i'll say okay :(
07:45:58 <__monty__> tdammers: That's sounds like par for the course for npm. (I know it's not exactly a fair comparison since it's such a juicy target.)
07:46:40 <tdammers> then again, being such a juicy target is at least in part the fault of how they decided to do things
07:47:27 <tdammers> with dependency graphs dozens of levels deep, and thousands of microlibraries in your effective codebase, prudently checking them all becomes impossible
07:51:06 <drets> Is there tool which can remove unused imports automagically for the project?
07:51:24 <dmwit> GHC has a flag to print minimal imports.
07:51:28 <merijn> Yes, but I forgot what it's called
07:51:36 <merijn> I think it was by ndmitchell?
07:51:40 <dmwit> -ddump-minimal-imports, I think?
07:52:07 <Lears> Shouldn't unused imports produce a warning anyway?
07:52:10 <drets> dmwit, automagically :)
07:52:18 <[exa]> Lears: -Wunused-imports :]
07:53:09 <merijn> unused imports doesn't detect minimal imports
07:53:33 <merijn> Because some identifiers might come from multiple imports (due to re-exports), leading GHC to falsely conclude they are not unused
07:53:35 <drets> I have a project with 100-300 unused imports; want to remove them all in once.
07:54:31 <[exa]> drets: you can do some sed/awk magic on the output of ghc (it prints the line and each import is on a separate line)
07:54:43 <tdammers> in my dream language, unused imports are just unused let bindings
07:56:34 <drets> [exa], sometimes there is: import Data.Maybe (fromMaybe, fromJust) and only fromJust is unused for example. so I can't use awk.
07:58:31 <dyl> That npm thing brings up an interesting question: does ghc-pkg/cabal perform any kind of verification?
07:59:00 <dyl> I'm not aware of any machinery for publishing signed packages.
08:00:23 <drets> merijn, > I think it was by ndmitchell? \n https://github.com/ndmitchell/weeder ?
08:00:52 <merijn> That's the one
08:01:05 <merijn> dyl: They are verified, but not signed
08:01:28 <merijn> dyl: i.e. you can't be man-in-the-middled, but you could get a malicious package if someone uploaded it
08:02:25 <drets> merijn, I think it only detects it, so there is no automatic removal.
08:06:22 <revskill> What's the best way to translate this code to Haskell ?
08:06:28 <pally> what is the !! operator in haskell?
08:06:28 <revskill> class PostPolicy
08:06:28 <revskill>   attr_reader :user, :post
08:06:28 <revskill>   def initialize(user, post)
08:06:30 <revskill>     @user = user
08:06:32 <revskill>     @post = post
08:06:34 <revskill>   end
08:06:36 <revskill>   def update?
08:06:37 <merijn> pally: Indexing a list
08:06:38 <revskill>     user.admin? or not post.published?
08:06:40 <drets> heh
08:06:40 <revskill>   end
08:06:42 <revskill> end
08:11:14 <drets> Just 331 warning − can do it manually. :]
08:11:21 <drets> *s
08:11:28 <merijn> Just write a small sed script :p
08:12:32 <drets> you meant haskell sed package?
08:12:38 <drets> :p
08:14:41 <dmwit> revskill: In the future, multi-line pastes should go to a pastebin website. Then you can share a link here.
08:15:05 <revskill> dmwit: Got it, thanks.
08:16:35 <dmwit> revskill: As for the translation, I'd write something like `updateNeeded :: User -> Post -> Bool; updateNeeded u p = admin u || not (published p)`.
08:17:07 <pally> I want to go back and ask a very basic question.
08:17:13 <pally> > f x y = x + y
08:17:15 <dmwit> It would be possible to also create an `data PostPolicy = PostPolicy { user :: User, post :: Post }` but it seems unnecessary.
08:17:15 <lambdabot>  <hint>:1:7: error:
08:17:15 <lambdabot>      parse error on input ‘=’
08:17:15 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
08:17:21 <pally> @let f x y = x + y
08:17:24 <lambdabot>  Defined.
08:17:36 <pally> :t f
08:17:37 <lambdabot> error:
08:17:38 <lambdabot>     Ambiguous occurrence ‘f’
08:17:38 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.f’,
08:18:32 <pally> f :: Num a => a -> a -> a
08:18:44 <dmwit> ?undefine
08:18:45 <lambdabot> Undefined.
08:18:54 <dmwit> ?let plus x y = x + y
08:18:56 <lambdabot>  Defined.
08:18:56 <dmwit> :t plus
08:18:57 <lambdabot> Num a => a -> a -> a
08:19:14 <dmwit> (You could also `plus = (+)`.)
08:19:36 <dmwit> (Although that would be subtly different depending on whether certain extensions are enabled or not.)
08:19:37 <revskill> yeah, simple is better
08:22:27 <pally> nvm, it seems haskell has already figured the types when these "recipes" are put together.
08:26:49 <pally> > f ( 9 -3) ( 7  +1)
08:26:52 <lambdabot>  error:
08:26:52 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M767959766127...
08:26:52 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
08:26:58 <pally> > f ( 9 - 3) ( 7  +1)
08:27:00 <lambdabot>  error:
08:27:00 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M825545459194...
08:27:00 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
08:27:02 <pally> errr.
08:27:13 <pally> > f ( 9 - 3) ( 7  + 1)
08:27:15 <lambdabot>  error:
08:27:15 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M750868256545...
08:27:15 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
08:27:40 <pally> > plus ( 9 - 3) ( 7  + 1)
08:27:42 <lambdabot>  14
08:27:46 <drets> \0/
08:28:14 <drets> pally, I am wondering, what are you doing? =)
08:29:04 <pally> there we go.  So following what I asked about earlier, is it true to say that we don't know whether (9 - 3) or (7 + 1) gets executed evaluated/executed?
08:29:05 <pally> first
08:29:55 <drets> ah, ok, I haven't read your previous msgs, just looked like some complex math calculation :troll:
08:31:20 <pally> drets my earlier question was about execution order, and that I was told that "Lazy evaluation order is not non-deterministic."
08:32:53 <barrucadu> Things are evaluated as they are needed
08:33:14 <barrucadu> (roughly, GHC may do some optimisations where it knows ahead of time that something will be needed)
08:33:28 <glguy> pally: Whether or not the arguments are evaluated and in what order that happens depends on the implementation of the function
08:33:47 <arianvp2> I have a piece of code where I'm surprised Haskell's totality checker doesn't kick in
08:33:56 <arianvp2> Exhaustiveness checker*
08:34:14 <merijn> pally: Haskell is actually not defined to be lazy, it's merely defined to be non-strict
08:34:57 <merijn> pally: That is, there is no guarantee in the language report which order things get evaluated in, just that things like infinite data structures, etc. are supported. So GHC can actually do whatever it likes to the evaluation order
08:35:12 <pally> barrucadu, merijn so let's consider the simple example that I had:  `plus ( 9 - 3) (7 + 1)`
08:36:17 <pally> let foo = (9 - 3 )  and bar = ( 7 + 1)
08:36:31 <arianvp2> Anybody any idea why I can't ommit the  "error "haskell complains"  part of the "client" function in this snippet? https://github.com/haskell-servant/servant/pull/969#issuecomment-404494100
08:36:49 <arianvp2> The exhaustiveness checker says I have to add the pattern, but it shouldn't , as  x inside is ill-typed
08:36:54 <arianvp2> and has no inhabitants
08:38:40 <glguy> TypeError doesn't integrate with the totality checker
08:38:48 <arianvp2> I see
08:38:52 <arianvp2> :(
08:38:55 <arianvp2> that's annoying
08:39:03 <arianvp2> I would've hoped it'd be like Void
08:39:03 <glguy> You're better off having Lkup x '[] = Void so you can handle that case with "absurd"
08:39:42 <arianvp2> But then I'd still have to pattern match all the constructors and do "absurd" everywhere right?
08:39:50 <arianvp2> haskell won't decide "nah you dont have to match the rest"
08:39:51 <pally> glguy: "depends on the implementation of the function", so it depends on the implementation of '+' in this case
08:39:56 <pally> :t plus
08:39:58 <lambdabot> Num a => a -> a -> a
08:45:03 <dmwit> pally: For Int, (+) is strict. I don't know off the top of my head whether it will force the left argument or the right argument first.
08:45:30 <dmwit> Probably the left argument. So 9-3 will be evaluated first; then 7+1; then 6+8.
08:45:59 <dmwit> (For Integer, too, which is probably what this is actually defaulting to.)
08:46:21 <glguy> I don't think it's going to necessarily be consistent that GHC forces the first or second argument with + for Int or Integer
08:46:43 <glguy> It knows that the function is strict in both arguments, it isn't forced to go either way in any particular circumstance
08:47:24 <pally> In the video I am watching, I learned that function applications are left associative
08:47:54 <Taneb> That means that "f g x" = "(f g) x", not "f (g x)"
08:48:00 <glguy> ((plus (9 - 3)) (7 + 1))
08:48:01 <tdammers> pally: do yo understand what that means, and how it doesn't affect evaluation order?
08:48:07 <dmwit> Yes. One must be careful to distinguish between "what Haskell specifies" and "what GHC does" generally; and in this case we should even distinguish a third case, which is "naive lazy evaluation order".
08:48:37 <tdammers> (or rather, how it doesn't *necessarily* affect evaluation order)
08:48:38 <dmwit> I was talking about naive lazy evaluation order.
08:48:56 <pally> https://youtu.be/yqmzRFiQUEY?t=85
08:49:18 <pally> "what that means is that I am now going to evaluate 9 - 3)
08:49:24 <pally> "
08:50:18 <dmwit> s/now/not/
08:50:30 <dmwit> Or at least that's what I hear.
08:51:11 <dmwit> It also meshes with the continuation, "as we don't require this value".
08:51:14 <glguy> And what the speaker is saying is just one way that it could have been evaluated. What he's describing isn't necessarily what happens
08:51:50 <glguy> The important thing is that it doesn't matter which order those arguments are evaluted in
08:52:44 <pally> Class at 12; thanks. I'll return to this.
08:54:54 <dmwit> I also don't think the "that" in "what that means" is referring to "function application is left associative". (Or if it is, the sentence taken at face value is incorrect.) But they're gone.
08:58:12 <mniip> hmm
08:58:16 <mniip> @let import Data.NumInstances.Function
08:58:17 <lambdabot>  Defined.
08:58:25 <mniip> > (do 1 <- 1; 1) 1
08:58:27 <lambdabot>  1
09:00:36 <haasn> > (sin^2 + cos^2) 0.12345
09:00:39 <lambdabot>  1.0
09:07:23 <Ariakenom> > head . filter (/= 1) . map (sin^2 + cos^2) $ [0, 0.0001 ..]
09:07:25 <lambdabot>  1.0000000000000002
09:08:33 <Ariakenom> > head . filter ((/= 1) . (sin^2 + cos^2)) $ [0, 0.0001 ..]
09:08:36 <lambdabot>  2.0e-4
09:09:23 <haasn> head . filter ((/= 1) . (sin^2 + cos^2)) $ [(0 :: CReal), 0.0001 ..]
09:10:03 <haasn> > head . filter ((/= 1) . (sin^2 + cos^2)) $ [(0 :: CReal), 0.0001 ..]
09:10:09 <lambdabot>  mueval-core: Time limit exceeded
09:16:14 <b0llu> Is there some neat way to think of (a -> p, b -> q) ?
09:16:56 <gentauro> I don't know if I promoted here the Meetup for Functional people in Copenhagen (Denmark) :)
09:17:24 <gentauro> this month we will have Lorenzo López fro HaskellMad (Mad = Madrid, Spain) -> https://www.meetup.com/MoedegruppeFunktionelleKoebenhavnere/events/250805099/
09:17:56 <gentauro> if any of you are in the Capital of Denmark and want to give a talk on some topic, please don't hesitate to reach out :)
09:18:19 <gentauro> we are aiming for people beeing here for business or pleasure as we don't have a budget and therefore can't pay you a ticket.
09:18:28 <gentauro> but we can buy you a beer or two (many) :D
09:23:08 <gentauro> btw, I had to "knife" my Qubes OS 3.2 installation and start from scratch.
09:23:59 <c50a326> gah, if I try to `stack install hfmt` it wants haskell-src-exts-1.20.2, but if I want to `stack install hlint` it wants haskell-src-exts-1.19.1
09:24:21 <c50a326> so I guess I have a stack deps catch 22 or something, is there any way forward? :\
09:24:38 <gentauro> I mean, now a days, you just install `Emacs`, as you do, bind to `melpa` and install `intero` and `haskell-mode` + `stack` and you are up and running
09:24:41 <c50a326> oh, allow-newer: true
09:24:54 <byorgey> c50a326: try 'stack install hfmt hlint' ?
09:25:00 <gentauro> c50a326: I always wondered what allow-never means?
09:25:22 <byorgey> c50a326: it shouldn't matter though, it's not a problem to compile hmft with one version of haskell-src-exts and hlint with another
09:25:44 <byorgey> gentauro: it means to ignore any upper bounds on dependency versions and cross your fingers and hope it works
09:26:35 <byorgey> sometimes, packages do in fact work with a newer version of a dependency, and the upper bound just hasn't yet been updated
09:27:48 <c50a326> meh, putting allow-newer: true into the stack.yaml did nothing :s
09:27:52 <c50a326> is it supposed to go elsewhere?
09:27:56 <gentauro> byorgey: I tend to "bind" my stack.yaml to some specific `lts` version
09:28:06 <gentauro> that way, it will never go for newer stuff right?
09:28:21 <c50a326> I don't get why any of this is necessary
09:28:27 <c50a326> I thought this is what stack was supposed to do
09:28:40 <c50a326> you just select an lts and then when you install stuff it knows what version to install
09:28:50 <gentauro> c50a326: I never had a problem with dependencies with `stack`
09:28:55 <gentauro> but I use `lts` as mentioned
09:28:58 <c50a326> this is an annoying pita that I have no understanding of
09:29:15 <c50a326> I'm using lts 9.21
09:30:29 <byorgey> c50a326: when you say "if I try to stack install hfmt it wants haskell-src-exts-1.20.2", do you mean it immediately quits with an error about haskell-src-exts-1.20.2?
09:30:30 <gentauro> well then it should work
09:30:56 <gentauro> try to remove the local .stack folder and re-try
09:31:40 <gentauro> btw, I had some issues installing Elm with their cabal installer. After several hours not beeing able, I just made a script that downloaeded the gits with the following stack.yaml
09:31:45 <byorgey> OK, I see what the problem is.  lts-9.21 has haskell-src-exts-1.18.2.  But hfmt says it requires haskell-src-exts > 1.20.
09:31:52 <gentauro> https://lpaste.net/7046091297324531712 and https://lpaste.net/3204490230715383808
09:31:56 <c50a326> byorgey: these errors https://ptpb.pw/wu92
09:32:34 <c50a326> I did allow-newer true now, it needed to go in .stack/config.yaml
09:32:43 <byorgey> so if you're using lts-9.21 you can't install hfmt.  allow-newer doesn't help because that would solve the opposite problem: if your LTS had a newer version of a dependency than the thing being installed said it needed.
09:32:45 <c50a326> it's in the middle of installing, let's see if it works out...
09:32:57 <c50a326> oh
09:33:04 <gentauro> c50a326: you should have that in your stack.yaml file in the root of your project
09:33:20 <gentauro> that's why I said delete your local .stack folder cos sometimes stuff doesn't get persisted
09:33:29 <c50a326> for this I'm just talking about global stack
09:33:34 <byorgey> c50a326: it looks like hfmt has its own stack.yaml, so you should be using that.
09:33:37 <gentauro> ph
09:33:38 <c50a326> these tools need to be available globally, it's vim/ale stuff
09:33:39 <gentauro> oh
09:33:49 <gentauro> fair enough
09:33:54 <byorgey> get the source of hfmt, cd into its directory, and 'stack install'
09:34:41 <c50a326> where does it say that? here it says `stack install hfmt` https://github.com/danstiner/hfmt
09:35:42 <byorgey> it says that, but that's not great advice because it means you are trying to compile hfmt using your global stack settings, which may or may not be compatible.
09:36:13 <c50a326> what's the best lts to use for global stack to have minimal headaches like this?
09:36:25 <byorgey> I'm advising you to  'cabal get hfmt; cd hfmt-*; stack install'
09:36:56 <byorgey> c50a326: whichever LTS has the packages you want to install =P
09:37:07 <byorgey> there is no globally valid answer to that question
09:37:59 <c50a326> if I change the lts resolver version, is there something I need to do to clean everything up and re-install everything again? `stack clean && stack setup` maybe?
09:38:07 <glguy> no
09:38:08 <byorgey> no
09:38:17 <c50a326> or just rm -rf ~/.stack ?
09:38:21 <nshepperd> there's no lts version that will be compatible with every haskell package that's not in that lts
09:38:22 <byorgey> you don't need to re-install anything.
09:38:34 <c50a326> I was thinking to update to lts 12.0 again
09:38:48 <c50a326> I can't remember why I pushed it back down to 9.x, I think it was to do with ghc-mod :\
09:39:01 <glguy> each lts is just an arbitrary snapshot of packages, you have to pick which ever one happens to have the stuff you wanted
09:40:09 <c50a326> hmm okay I'm doing that cabal stuff then
09:40:13 <byorgey> c50a326: if something you want to build has its own stack.yaml, then that means the author has put effort into specifying which LTS it will build with.
09:40:20 <w1n5t0n> hey friends, I have a "newtype Signal a = Signal {runSig :: Time -> a}" (which is an instance of Num) and a function "fromList :: (RealFrac b) => [Signal a] -> Signal b -> Signal a", which indexes through a list using a signal between 0 and 1. I'm trying to make it work with lists of lists, so I can do something like "fromList [[1, 2], [3, 4], [5, 6]] someSig", but I can't seem to get the hang of it. Can both of these be the same func
09:40:23 <Solonarv> you can remove ~/.stack if you want, but that doesn't accomplish anything besides saving disk space
09:41:10 <byorgey> so you can take advantage of that, and build each package with whatever it wants to be built with.  Building each package/library against a different LTS is no problem at all since stack is designed to sandbox everything.
09:41:16 <c50a326> byorgey: how do you check for that (having its own stack.yaml)?
09:41:32 <byorgey> c50a326: look at its source, either on github or by doing 'cabal get'
09:41:55 <c50a326> okey doke, thanks... I'm just waiting for cabal to update now, it's taking a while
09:42:17 <lyxia> w1n5t0n: what would it do on a list of lists
09:42:55 <c50a326> if haskell is great, why doesn't everything just work
09:43:19 <lyxia> it's not perfect
09:43:22 <mniip> hmm
09:43:29 <c50a326> I mean it's all pure and strongly typed and so on... why do minor changes break everything in deps...
09:43:33 <nshepperd> haskell is great, but it's not the second coming of jesus
09:43:46 <mniip> so I have this program here: https://lpaste.net/3508003973112004608
09:44:07 <mniip> if I change the manual counting to 'length <$> filter id <$> getElems a'
09:44:13 <mniip> the run time grows 10x
09:44:13 <glguy> c50a326: The types mean we find out that things aren't compatible earlier. Other language find out they aren't compatible at runtime
09:44:18 <c50a326> I guess developers update stuff and change apis and so on...
09:44:24 <mniip> due to allocations, I suppose
09:44:36 <Solonarv> that doesn't really have anything to do with the language
09:44:43 <mniip> is there some middle ground? not an explicit loop but something that doesn't reuslt in allocating a list
09:44:53 <c50a326> glguy: ah good point I guess
09:44:54 <revskill> Why not haskell website wrote: Haskell - a typed imperative language ?
09:45:05 <w1n5t0n> lyxia, it would return the list at the index dictated by the input signal, so say if the signal is 0 then it would return [1, 2] and if it's 1 it would return [3, 4]. Ideally I'd want something like "fromList :: (RealFrac b) => [a] -> Signal b -> a" but I don't know if that's possible
09:45:31 <w1n5t0n> sorry, [5, 6] instead of [3, 4]
09:49:20 <nshepperd> mniip: the same thing, but with unsafeFreeze first?
09:50:00 <mniip> length <$> filter id <$> unsafeFreeze a?
09:50:17 <nshepperd> (length . filter id . getElems) <$> unsafeFreeze a
09:51:15 <nshepperd> fusion might work better with that, idk
09:52:03 <mniip> wouldn't that be equivalent to
09:52:12 <mniip> (length . filter id . getElems) $ runSTArray $ do ...
09:52:29 <nshepperd> yeah, i suppose so
09:52:32 <nshepperd> try that, i guess
09:52:33 <mniip> that's still slow
09:52:42 <nshepperd> oh
09:53:01 <nshepperd> well, i'm also not sure if Data.Array even does fusion
09:53:06 <c50a326> byorgey: I did `cabal get hfmt` and cd'd into there and ran `tree` to look at the files... I don't see any stack.yaml but there's a hidden file .stylish-haskell.yaml
09:53:31 <nshepperd> maybe '[a ! i | i <- [2..n]]' would fuse where getElems wouldn't
09:53:36 <handyandy> hello I'm trying to make a type synonym for a Data.Tree.Zipper:
09:53:46 <handyandy> type CharListZipper = Data.Tree.Zipper.PosType t => Data.Tree.Zipper.TreePos t [Char]
09:54:08 <handyandy> But I get a compiler error when I try that.  I'm wondering if anyone has a hint as to what is wrong.
09:56:32 <glguy> type CharListZipper t = ...
09:56:42 <mniip> nshepperd, {ST,IO}{U,}Array needs a fold function...
09:57:16 <glguy> handyandy: You're not really supposed to put contraints in your type synonyms
09:57:51 <handyandy> hi glguy, thanks...
09:58:09 <handyandy> i did not intend to, but I am not sure how to express it without a constraint
09:58:27 <glguy> The constraints go on the functions that use the zipper, not the values of the zipper
10:00:46 <UnkDevE> Hey I have a function that stops recusing early and I don't know why, I've tried debugging but it hasn't helped https://github.com/UnkDevE/Sudoku/blob/master/sudoku.hs#L96
10:02:32 <handyandy> glguy: I had been using this previously (which compiles):
10:02:34 <handyandy> type CharListZipper = Data.Tree.Zipper.TreePos Data.Tree.Zipper.Full [Char]
10:02:51 <handyandy> but I have the "PosType" Full type hardcoded in there.
10:03:32 <glguy> OK, then: type CharListZipper t = Data.Tree.Zipper.TreePos t [Char]
10:11:49 <handyandy> hi glguy, if I have a function like this:
10:11:49 <handyandy> https://lpaste.net/6055147273036234752
10:12:04 <handyandy> I am not sure how to then specify the type variable as an argument
10:12:36 <glguy> handyandy: doZipStuff: Data.Tree.Zipper.PosType t => CharListZipper t -> IO ()
10:14:06 <gratin> can some one help me? I'm reading a chapter about functors and its a bit fuzzy. fmap :: (a -> b) -> f a -> f b
10:14:25 <gratin> i think i understand a -> b represents a function that takes in type a and produces type b
10:14:38 <gratin> but I don't really get f a -> f b
10:14:53 <glguy> same deal, it's a function from values with type (f a) to ones with type (f b)
10:15:20 <glguy> f could be something like   [] or Maybe
10:15:57 <gratin> f is a type or a function?
10:16:01 <glguy> both
10:16:13 <gratin> how?
10:16:16 <glguy> it's a type and a has the kind * -> * which means it can be applied to types with kind *
10:16:25 <glguy> and it has*
10:16:31 <gratin> ah ok
10:16:33 <AndrewAMD> Win32: I want to build 32-bit DLLs in Haskell to be used with 3rd party software, but Windows Platform now seems to only include 64-bit.  Does this mean I need to start from scratch with the GHC compiler?
10:16:44 <handyandy> glguy, if I try that I get the following error (it seems as if the label function requires that type to be "Data.Tree.Zipper.PosType Full"
10:17:07 <glguy> handyandy: If the label function requires that then you can't generalize doZipStuff and the original type is the right one
10:17:09 <handyandy> https://lpaste.net/6500009321152118784
10:17:15 <handyandy> oh
10:17:19 <gratin> glguy, thanks that makes a lot more sense
10:17:50 <handyandy> ok, thanks glguy
10:18:12 <mniip> lol
10:18:17 <mniip> I just realized
10:18:32 <mniip> the functor law is that <$> is associative
10:18:41 <mniip> (a <$> b) <$> c = a <$> (b <$> c)
10:18:59 <dataN> having difficulty implementing a function of type '((p=>(x->b))->(x->b)) -> x -> ((p=>x->b)->b)'
10:20:43 <fishythe_> just partially apply the `(p => (x -> b)) -> x -> b` to `x` (as the second argument)
10:21:42 <AndrewAMD> Windows Platform: How do I compile 32-bit native code?
10:22:18 <dmwit> fishythefish: Did you try it?
10:23:16 <AndrewAMD> I found this (not possible with 64-bit compiler) : https://stackoverflow.com/questions/40017835/ghc-how-to-build-a-32-bit-dll-using-64-bit-ghc-to-call-functions-from-c
10:23:17 <dmwit> Okay. I tried it.
10:23:21 <dmwit> With sufficient extensions, it works.
10:23:25 <fishythefish> :t flip :: ((()=>(x->b))->(x->b)) -> x -> ((()=>x->b)->b)
10:23:27 <lambdabot> ((x -> b) -> x -> b) -> x -> (x -> b) -> b
10:23:36 <dmwit> fishythefish: Yes, but () is not p.
10:23:44 <dataN> exactly
10:23:45 <dmwit> Just to be fair.
10:24:18 <fishythefish> dmwit: yeah, needed to get around the need for adding extensions to the bots
10:24:22 <glguy> f :: proxy p -> ((p=>(x->b))->(x->b)) -> x -> ((p=>x->b)->b); f _ = flip -- Could not deduce: p...
10:24:23 <dmwit> Anyway `f g x h = g h x` does indeed work fine.
10:26:07 <glguy> f :: proxy p -> ((p=>(x->b))->(x->b)) -> x -> ((p=>x->b)->b); f _ g x h = g h x  -- works without needing ambiguous types
10:27:31 <Zvpun> Is it possible to inspect the type (like :t in GHCi) of `y` in `[1..10] >>= \x -> let y = x in return y` somehow? (The expression is only a minimal test case.)
10:28:39 <dmwit> Zvpun: [1..10] >>= \x -> let y :: _; y = x in return y
10:28:56 <dmwit> will print information about its type
10:29:08 <dmwit> If you want to do it without modifying the source, it is still possible but a bit harder.
10:29:25 <dataN> hmm, the first version does not work, https://lpaste.net/6550568366195605504
10:29:35 <Zvpun> I have access to the source
10:29:47 <dmwit> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html?highlight=%3Atype-at#ghci-cmd-:type-at
10:29:58 <glguy> dataN: Yeah, like said above you can't use flip
10:29:59 <Zvpun> it says: Illegal type signature: '_' Type signatures are only allowed in patters with ScopedTypeVariables. I don't understand the error.
10:30:01 <dmwit> But :type-at is pretty fragile still.
10:30:42 <dmwit> Zvpun: Sounds like you tried to write `let (y :: _) = x` instead of the suggested `let y :: _; y = x`.
10:31:46 <gratin> is there a way I can determine the kind of type signatures without having a matching function?
10:31:59 <gratin> such as a -> a = * -> *
10:32:30 <dmwit> ...but that is not the kind of a -> a.
10:32:41 <dmwit> % :k forall a. a -> a
10:32:42 <yahb> dmwit: forall a. a -> a :: *
10:32:59 <gratin> rip thats why i wanted to check
10:33:03 <gratin> i'm doing exercises lol
10:33:32 <dmwit> Anyway, my response gives you the answer. ghci has :k (short for :kind).
10:33:47 <gratin> i just didn't know about forall
10:33:58 <dmwit> Ah, yup. That is a wart of :k, I think.
10:34:19 <nshepperd> % :k _ -> _
10:34:19 <yahb> nshepperd: _ -> _ :: *
10:34:35 <dmwit> % :set -XNoPartialTypeSignatures
10:34:35 <yahb> dmwit:
10:34:38 <dmwit> % :k _ -> _
10:34:39 <yahb> dmwit: _ -> _ :: *
10:34:42 <dmwit> hmm =)
10:34:56 <Solonarv> the kind of a *type* signature is always Type, aka *
10:35:03 <gratin> your command produces this in ghci
10:35:05 <gratin> Illegal symbol '.' in type
10:35:05 <gratin>     Perhaps you intended to use RankNTypes or a similar language
10:35:05 <gratin>     extension to enable explicit-forall syntax: forall <tvs>. <type>
10:35:16 <dmwit> You can turn on RankNTypes with :set -XRankNTypes
10:35:25 <dataN> cant access p to write proxy p, and writing (Proxy :: Set []) complains that a type was expected rather than a Constraint...
10:35:44 <dmwit> dataN: Presumably you meant `Proxy :: Proxy (Set [])`
10:36:11 <dataN> doh! thanks
10:36:17 <dataN> it compiles
10:38:25 <Zvpun> dmwit: thank you!
10:38:35 <gratin> dmwit, wouldn't a -> a be of kind * -> * :: * because when -> is applied you get *
10:39:14 <gratin> like * -> simplifies to * if i'm understanding it correctly
10:39:17 <dmwit> If we had a hypothetical type-level function which took a type, called it `a`, and returned `a -> a`, then that hypothetical function would have kind `* -> *`.
10:39:20 <dmwit> But we don't.
10:39:42 <pdxleif> I'm trying to use Aeson's .= operator to write some JSON a la `object ["foo" .= "bar"]`, but I get ambiguous implicits, because there's an IsString instance for Value, and an IsString instance for Text.
10:39:43 <Solonarv> (->) has kind `* -> * -> *`; `a -> a` is `(->) a a`, which is (->) applied to two arguments and therefore has kind `*`
10:40:03 <pdxleif> Is there anyway to block the import of an instance, or force which instance to pick, like something with TypeApplications, maybe?
10:40:20 <dmwit> Or, to say another way: you claim that when -> is applied you get *. In `a -> a`, -> is applied to `a` and to `a`. So you get *.
10:40:30 <Solonarv> you can just do ("foo" :: Text) or "foo" @Text
10:41:34 <dmwit> I don't think you can do "foo" @Text.
10:42:07 <Solonarv> I haven't actually tried it so you may be right
10:42:49 <pdxleif> If that worked, I could write 5 @Int
10:42:52 <gratin> a -> b a -> T (b a) so how would I do this one?  * -> (* -> *) -> (* -> * -> *) ?
10:43:33 <pdxleif> I guess I'll give up and go with writing stuff like object [("foo", toJson @Int 5)]
10:44:01 <dmwit> You might be able to write `(.=) @_ @Text "foo" "bar"`.
10:44:22 <nshepperd> 'Cannot apply expression of type ‘p0’ to a visible type argument ‘Int’ In the expression: 5 @In' sad
10:44:38 <Solonarv> gratin: no! `b` has kind `* -> *`, but `b a` just has kind `*`
10:44:56 <gratin> oh okay i got it now
10:44:59 <gratin> that makes sense
10:45:07 <gratin> it was asking what the kinds of b and T were
10:45:22 <Solonarv> yeah that makes more sense
10:45:27 <dmwit> gratin: An analogy you may find helpful: in `3 + 4`, we don't say this has type `Int -> Int -> Int`. That's the type of `(+)`, but the type of the whole expression is just `Int`.
10:45:47 <dmwit> gratin: Similarly the kind of `a -> b a -> T (b a)` is just *, even though subcomponents of it have a more interesting kind.
10:45:52 <gratin> thank you guys
10:46:15 <dmwit> gratin: ...but even then, the kind of `T` is not `* -> * -> *`.
10:46:26 <gratin> wait what
10:46:32 <dmwit> (There are no subterms of that kind in what you posted.)
10:47:10 <dmwit> gratin: You know because `T (b a)` is the second argument of `(->)` that we must have `T (b a) :: *`. You know because `b a` is the first argument to a `(->)` that we must have `b a :: *`.
10:47:17 <dmwit> gratin: Therefore, `T :: * -> *`.
10:47:33 <gratin> What are the kinds of b and T ? (The T is capitalized on
10:47:33 <gratin> purpose!)
10:47:34 <gratin> a -> b a -> T (b a)
10:47:37 <gratin> was the whole question
10:47:43 <dmwit> `T :: * {- the kind of b a -} -> * {- the kind of T (b a) -}`
10:48:35 <dataN> works ok now https://lpaste.net/9218173898065969152
10:48:38 <dmwit> (...ignoring polykinds for now)
10:49:23 <gratin> what does the capitalization of T mean?
10:49:33 <Solonarv> well, polykinds aren't relevant here anyway
10:50:02 <dmwit> It means it is a type constructor (not a type variable). Nothing more. It has no real effect on the question, I think.
10:50:10 <gratin> ah ok
10:50:45 <dmwit> Solonarv: I don't see why not. T could also have kind `k -> *` or `k -> k` and still leave this well-kinded.
10:51:07 <Solonarv> oh, you mean it could be more general; true
10:52:01 <pdxleif> dmwit: Wow, that works, thanks
10:52:11 <pdxleif> Not the most aesthetic thing, though: object [(.=) @_ @Text "foo" "bar", (.=) @_ @Int "val" 10]
10:52:37 <dmwit> oh, i have a cunning plan
10:52:43 <dmwit> "foo" .= id @Text "bar"
10:53:20 <pdxleif> Or "foo" .= ("bar" :: Text) ?
10:53:28 <dmwit> Yes, Solonarv suggested that ages ago.
10:54:05 <gratin> kind of b would be * -> * and T is * -> * because T is applied to (b a) :: * right?
10:54:14 <dmwit> I assumed that wasn't suitable for some reason or why would you still be chatting? =P
10:54:30 <pdxleif> Kinda wish I could turn off overloaded strings or something. That (with the IsString instance for Value), and the ToJSON typeclass seem to be tripping each other up.
10:54:52 <dmwit> gratin: "kind of b would be * -> *" yes "T is * -> *" yes "because T is applied to (b a) :: *" that is only part of the answer to why T has the kind it does
10:55:02 <__monty__> pdxleif: What's stopping you from turning off overloadedstrings?
10:55:21 <Solonarv> you mean turn them off locally? turning them off file-wide is as simple as not putting {-# language OverloadedStrings #-} at the top of your file
10:55:25 <dmwit> gratin: "T is applied to (b a) :: *" justifies the fact that `T :: * -> SOMETHING`. But you also have to justify the claim that `SOMETHING` is `*`.
10:55:38 <pdxleif> dmwit: Well... if I have to annotate all the text nodes with that, I'd probably just go back to using tuples for everything and writing toJSON @Int on all the number nodes - cause there's less of them.
10:56:00 <gratin> ah okay
10:56:19 <dmwit> pdxleif: You can make a more monomorphic (.=) if there's just a few types.
10:56:19 <Solonarv> admittedly, aeson is somewhat annoying to use without OverloadedStrings, because keys are Text
10:56:44 <pdxleif> __monty__: The key names are Text, so wouldn't I have to write "pack" before every one, and there's no ToJSON instance for String afaik.
10:57:05 <pdxleif> dmwit: Oh, good idea - thanks
10:57:12 <gratin> does => indicate a partially applied function?
10:57:18 <dmwit> No.
10:57:25 <Solonarv> no, it doesn't indicate any sort of function
10:57:27 <dmwit> => separates constraints from the type they constrain.
10:57:38 <__monty__> pdxleif: Yes, of course you'd have to pack them all.
10:57:48 <gratin> i must have skipped over it
10:58:00 <gratin> where would be a good place to read about => in type signatures
10:58:17 <dmwit> Review your introductory material on typeclasses.
10:58:25 <gratin> thanks
11:00:16 <Solonarv> String does have a ToJSON instance, actually
11:01:36 <pdxleif> > object ["foo" .= "bar", "val" .=  10]
11:01:39 <Solonarv> well, Char does, but ToJSON has toJSONList / toEncodingList methods for (presumably) this exact reason
11:01:39 <lambdabot>  error:
11:01:39 <lambdabot>      Variable not in scope: object :: [m0 ()] -> terror:
11:01:39 <lambdabot>      • Couldn't match type ‘[Char]’
11:05:17 <__monty__> Is this about another license-files field that doesn't parse? http://ix.io/1gZR
11:09:59 <__monty__> Woops, was meant for #nixos.
11:11:43 <pdxleif> I don't understand; object ["foo" .= "bar"] works at the repl, but not in a file.
11:16:30 <mniip> pdxleif, different sets of extensions
11:16:51 <mniip> monomorphism related porbably
11:17:47 <pdxleif> I put up a gist: https://gist.github.com/LeifW/f3e51437f4494eff9d7c23355f268ef7
11:18:03 <pdxleif> The only extension in either case is the OverloadedStrings, afaik
11:18:31 <cocreature> looks like ExtendedDefaultRules
11:18:38 <cocreature> which is enabled by default in ghci but not in ghc
11:20:46 <gratin> concat :: Foldable t => t [a] -> [a] can some one explain this?
11:21:10 <gratin> we take in something that is Foldable and call it t, presumably a list
11:21:31 <gratin> then we apply the list to a type? and return a list of that type?
11:21:38 <mniip> gratin, no, we fix some type 't' that is foldable
11:21:43 <mniip> then we take in   t [a]
11:22:30 <gratin> so if t was a list it would correspond to [[a]]
11:22:40 <gratin> i see
11:22:59 <gratin> what else could T be?
11:23:08 <gratin> t*
11:23:23 <pdxleif> cocreature: Wow, that fixed it. Odd.
11:23:26 <mniip> %% :i Foldable
11:23:27 <yahb> mniip: http://qp.mniip.com/y/76
11:23:33 <mniip> gratin, any of thse things
11:24:08 <gratin> okay thats pretty cool
11:24:22 <gratin> your bot
11:25:38 <cocreature> gratin: note that this is just a ghci command. you can run the same command in your local instance of ghci
11:26:09 <gratin> ah ok
11:29:36 * hackage primitive-extras 0.1.7 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.1.7 (NikitaVolkov)
11:30:43 <cocreature> pdxleif: fwiw I would recommend adding type annotations, not turning on ExtendedDefaultRules
11:31:55 <Gurkenglas> mniip, https://tcpst.net/ <- In what horrible situations does wrapping the tcp in http need boilerplate?
11:36:09 <pdxleif> cocreature: Are there downsides besides not knowing what types its picking? This is in a Main module, with a not a lot of other code besides parsing args, and I also wanted to provide some default values when parsing a config file.
11:36:13 <exarkun> Can I somehow browse the module space as defined by all of some set of packages?  eg all the packages on Hackage or all the packages in stack's lts-...?
11:37:30 <pdxleif> Or maybe I could have this bit of JSON off in its own little module with that turned on. Or just parse it as a string.
11:37:48 <exarkun> I want to get some inspiration for the top-level module name and module hierarchy for my first real Haskell project.
11:37:49 <cocreature> pdxleif: not really but it’s easy to have the defaulting process pick up the wrong type or at least a suboptimal type
11:37:59 <cocreature> GHC will even warn about defaulting if you compile with -Wall
11:38:15 <cocreature> and adding a few type annotations helps whoever tries to read your code as well
11:39:13 <pdxleif> cocreature: Oh yeah, when I use -Wall it warned that it defaulted those to [Char] and Integer.
11:43:14 <pdxleif> I guess I can write that as object ["x" .= String "foo", "y" .= Number 10]
11:43:32 <pdxleif> and then the ToJSON constraint on the RHS of .= is no longer needed.
11:43:58 <pdxleif> I forgot about the fromInteger for Scientific to construct literal values.
12:12:07 * hackage primitive-extras 0.1.7.1 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.1.7.1 (NikitaVolkov)
12:13:17 <gentauro> is it possible with yaml to only parse a subset of values?
12:13:53 <gentauro> let say my yaml file has: foo, bar, baz and qux fields, but for I only care about foo and qux
12:14:10 <gentauro> do I need to explicitely handle bar and baz?
12:14:36 <pdxleif> By parse do you mean parse it to the YAML (aeson) AST, or to convert it to some data type you have defined?
12:14:38 <gentauro> or is there a way to just define "instance FromJSON Package where" for foo and qux
12:14:53 <gentauro> I'm using the "yaml" package
12:15:01 <gentauro> which I guess re-exposes aeson
12:15:52 <pdxleif> Extra fields in your yaml will be fine - they'll be ignored.
12:16:30 <gentauro> https://lpaste.net/5038637271234904064
12:16:55 <pdxleif> e.g. I can parse `Person {name :: String, age :: Int}` from {"name": "Bob", "age": 30, kids:["nancy"], etc...}
12:17:27 <gentauro> pdxleif: yeah, that's what I'm looking to do :)
12:17:49 <pdxleif> The parser you have will already do that - that's the default behaviour.
12:18:20 <gentauro> the problem I'm getting this -> Left (AesonException "Error in $.depends: expected [a], encountered String")
12:18:35 <gentauro> pdxleif: yeah, that's why I'm wondering about the error message ...
12:18:53 <pdxleif> qux is an array of strings, so you would need an array in the yaml at that point
12:19:19 <gentauro> :o
12:19:35 <gentauro> it's because my test instance only have one value in the array :|
12:20:10 <gentauro> the yaml parser should be able to find that out, I mean, I specify it's a [ String ]
12:20:14 <gentauro> what the heck ..
12:21:07 * hackage vty 5.22 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.22 (JonathanDaugherty)
12:21:07 <pdxleif> you would need to write qux: ["blah"] or whatever in the source yaml
12:21:32 <pdxleif> or change the definition of the parser to accomodate either a single string or a list
12:21:42 <gentauro> pdxleif: ehhh, I'm not defining them, I'm just consuming them ;)
12:22:26 <gentauro> pdxleif: I guess I need to define https://lpaste.net/5038637271234904064#line26 another way?
12:22:50 <gentauro> so it knows that qux is a list, even if it only have an item
12:23:53 <gentauro> I will just makea newtype incapsulating the list and that should work
12:24:37 * hackage brick 0.38 - A declarative terminal user interface library  http://hackage.haskell.org/package/brick-0.38 (JonathanDaugherty)
12:24:51 <pdxleif> gentauro: It'll either be an Array or String in the AST at that point? You could pattern match and do the appropriate thing - like construct a singleton list form it if it's a single element. http://hackage.haskell.org/package/yaml-0.9.0/docs/Data-Yaml.html#t:Value
12:25:47 <pdxleif> There's probably a stackoverflow where someone does that.
12:26:01 <gentauro> pdxleif: will look for it
12:26:02 <gentauro> thx
12:26:15 <pdxleif> There's an Alternative instance for the Parsers
12:26:52 <gentauro> https://stackoverflow.com/a/16548666
12:27:07 <gentauro> the extra newtype as I said :)
12:27:20 <pdxleif> So you could maybe do something like withText ... <|> withArray ... - http://hackage.haskell.org/package/aeson-1.4.0.0/docs/Data-Aeson.html#g:18
12:29:29 <gentauro> pdxleif: isn't <|> optional?
12:29:41 <gentauro> I mean, there will always be an array which should be converted to a list
12:29:43 <gentauro> :)
12:31:46 <pdxleif> gentauro: You can see it used in the "(v .: "Value" <|> (showInt <$> v .: "Value"))" here - https://stackoverflow.com/a/38213066/283260
12:32:14 <pdxleif> So that's, either give me the string, OR (if that fails), turn the int into a string.
12:33:50 <pdxleif> So, in your single-value case, you could construct a list from it.
12:34:21 <gentauro> that sounds like the way to do it
12:34:33 <gentauro> I would just have it to infeer it :)
12:34:40 <gentauro> cos I described it in the types ;)
12:34:51 <cocreature> if you want a list, let users write a list
12:35:37 <cocreature> implicit conversions might seem like a great idea at first but they will come back and bite you
12:42:59 <gentauro> the thing that annoys me is that the yaml file actually use the convention of what is an array
12:43:08 <gentauro> like \r\n and then the line (+ tab)
12:47:24 <Zemyla> So question: If I have a proposition in first-order logic to prove, and I can do so by expressing it as a Haskell type and writing a valid implementation of it without using (for instance) fix or undefined, then how do I convert that back to a proof?
12:48:50 <dstolfa> Zemyla: the program is the proof
12:49:22 <Zemyla> Well, yes, but I meant like a step-by-step procedure using modus ponens/tollens like logic teachers like to see.
12:49:38 <dstolfa> Zemyla: type inference gives you that
12:49:42 <pdxleif> gentauro: yaml list items should start with a -, like this list of fruits here: https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html#yaml-basics
12:50:44 <dstolfa> but again, you don't have to do that. the program *is* the proof. you can argue that via the curry-howard isomorphism and demonstrate that the things you use are structurally the same. instead of using non-constructive mathematics, you're using constructive mathematics and it's perfectly fine
12:50:56 <dstolfa> you could try to go back and replace the symbols and then do a step-by-step construction of it
12:51:01 <dstolfa> but i don't see the point of that at all
12:51:20 <dstolfa> it's going backwards -- from something a computer can verify to something that you have to mostly check manually
12:51:29 <dstolfa> or translate into some representation for a computer to verify
12:51:32 <pdxleif> You could think the lambda calculus each bit of code corresponds to, break it apart into introduction and elimination rules for stuff?
12:52:08 <pdxleif> Do you want to end up with something that looks like http://incredible.pm/ ?
12:53:44 <tim____> hello, can somebody please explain to me why it seems so hard to install packages in haskell? I tried to install xmonad on my machine but I am running into dependencie issues with stack and cabal and was simply wondering why using somethin like pip seems so much easier..
12:54:23 <glguy> You'd have to tell us what went wrong, it's not generally that hard to install things
12:54:33 <geekosaur> I'm tempted to ask if you;re on arch
12:54:38 <tim____> ..
12:54:44 <tim____> well, I am on arch
12:54:49 <tim____> :D
12:54:53 <geekosaur> arch's haskell packaging has been screwed up for over a year now
12:55:03 <glguy> Oh, it's hard because you're using arch, it's intentionally broken
12:55:11 <tim____> oh well..
12:55:21 <lyxia> there's a page on the arch wiki about that
12:55:21 <geekosaur> basically they set it up for arch packagers' convenienve, not for users
12:55:32 <tim____> I have been following this part of the help section: https://wiki.archlinux.org/index.php/Haskell#Building_statically_linked_packages_with_Cabal_.28without_using_shared_libraries.29
12:55:43 <glguy> You're getting the full arch experience of having to make things work, it's a feature
12:56:00 <tim____> so i bootstrapped the statically linked cabal version with stack and the static libs from the official repos
12:56:14 <tim____> static libs for ghc
12:56:44 <tim____> ok so you would recommend switching to a different distro? :D
12:57:08 <cocreature> I would recommend that you start by telling us the errors you encountered
12:57:45 <tim____> more than happy to do that
12:57:56 <tim____> I will prepare a pastebin
12:59:17 <cocreature> if you are only trying to install xmonad and don’t want to do any Haskell development yourself, sticking to arch’s packages completely and not touching cabal or stack in any way might also work
12:59:54 <tim____> I would like to do haskell development myself
13:07:06 <tim____> https://pastebin.com/aRgxfmEj
13:07:19 <tim____> this is the paste, please let me know if you need more information
13:08:06 <pdxleif> tim____: If you want to install xmonad, you can just use `pacman -S xmonad` - does that not work for you?
13:08:26 <pdxleif> I do plenty of dev with arch's haskell packages.
13:08:44 <pdxleif> I also cabal-install stuff on top of those packages.
13:09:11 <pdxleif> I'd hardly call dynamic linking "screwed-up" - that's been a feature of GHC for like a decade now.
13:09:15 <tim____> yes, that works but I would like to install ghc-mod for example (and other development tools) and the section in the wiki recommends removing all arch haskell packages and installing everything with cabal/stack
13:09:27 <glguy> Mixing package between the package manager and user package database is a bad and and will break over time, it's not a good idea even if you can get it to work for a short time
13:09:34 <pdxleif> tim____: What section of the wiki?
13:09:45 <tim____> https://wiki.archlinux.org/index.php/Haskell#Building_statically_linked_packages_with_Cabal_.28without_using_shared_libraries.29
13:09:49 <pdxleif> You could also be able to install xmonad with cabal or stack if you wish.
13:09:52 <cocreature> tim____: you didn’t actually do that though. when the wiki says that you should remove everything except for ghc and ghc-static, it really means that
13:10:02 <cocreature> i.e., don’t install xmonad via pacman
13:10:23 <tim____> I did, but then I got the same packages
13:10:29 <tim____> sorry, the same errors
13:10:49 <tim____> I just reinstalled xmonad so I could reboot
13:11:40 <pdxleif> I've been happily doing dev on top of Arch's Haskell packages for a decade now (including using ghc-mod). *shrug*
13:11:42 <cocreature> for xmonad, the problem appears to be that the version of hackage requires X11==1.8.* while your stackage resolver contains 1.9
13:12:14 <cocreature> you can either use an older stackage resolver or add the older version of X11 to extra-deps
13:12:29 <tim____> pdxleif: so you are just using the arch packages for everything you need?
13:13:15 <glguy> building user packages (that pacman doesn't track) on top of pacman managed system packages means your packages break when pacman upgrades not knowing that those packages were being used
13:13:24 <cocreature> pdxleif: I do think it’s fair to call arch’s setup screwed-up: it distributes a GHC that by default is broken since it defaults to static linking while arch distributes dynamic libs
13:13:32 <pdxleif> tim____: Yes, and anything that's missing I cabal-install on top of that (for the short term), and then make arch packages for (PKGBUILDs, that you can upload to AUR) if I'm going to use them long-term.
13:13:39 <glguy> Arch Linux is the primary source of broken build questions we get here
13:14:34 <cocreature> the fun part is that people who only use Haskell packages but don’t do Haskell dev are also unhappy with the new setup since they now have to install 100 packages to get pandoc
13:14:50 <pdxleif> The issue with cabal-installing packages on top of the Arch-provided packages is that they will get broken every time one of the haskell libraries they depend on in the Arch repos gets upgraded. So I frequently have to re cabal-install stuff after running pacman -Syu.
13:16:19 <pdxleif> It's nicer for me in development, since linking is much faster and doesn't use nearly the amount of resources.
13:16:32 <tim____> thats why I wanted to follow the solution suggested in the wiki, I will try adapting the extra-deps according to cocreature
13:18:47 <pdxleif> It's not like those 100 packages + pandoc take up substantially more space than a statically-linked pandoc. And then those libs are available for other use.
13:20:00 <tim____> how are the arch people handling the pip packages? couldn't that approach also be applied to the haskell packages?
13:21:48 <pdxleif> People can add "executable-dynamic: True" to their ~/.cabal/config (and  ghc-options: -dynamic)
13:22:53 <pdxleif> tim____: It looks like they're running `python setup.py build` and then `python setup.py install` in the case of this package: https://git.archlinux.org/svntogit/community.git/tree/trunk/PKGBUILD?h=packages/python-pandas#n45
13:23:43 <pdxleif> The general pattern is ./configure; make; make install, that's pretty much applied to everything (including the Haskell packages).
13:23:56 <pdxleif> I don't see pip involved, but I don't know much about python.
13:24:57 <glguy> The Arch Haskell problem is that they stopped providing the static libraries that are the default for GHC development. Things used to work on Arch and then they got clever
13:25:15 <glguy> Does pip have a static and dynamic library option? is that why you're thinking its relevant?
13:25:35 <pdxleif> A difference from python is that the haskell packages have to be used with the *exact* version of libraries they were compiled against. So breakages (and required reinstalls) are much for frequent than they would be for using distro-provided packages for libraries in other languages.
13:25:58 <__monty__> Main issue with haskell on arch for me was system upgrades started taking hours...
13:26:39 <tim____> cocreature: I get this issue when adapting the extra-deps: https://pastebin.com/h3p3sfUv
13:27:10 <__monty__> Much happier with haskell through nix on arch.
13:28:00 <tim____> cocreature: this is ghc-pkg check: https://pastebin.com/CN8L1gRK
13:28:32 <tim____> __monty__: so you install the nix package manager in arch and manage your haskell packages with that?
13:28:57 <tim____> is there a how to guide that covers the whole process?
13:29:08 <typetetris> Using `hoogle server` locally, I can't click the links, as they are `file://` links, is there an easy solution to this?
13:29:14 <glguy> tim____: Once you start using stack you have to use it for everything, ghc-pkg on its own doesn't look at the stack sandboxed GHC
13:29:22 <__monty__> No, I don't use pacman to handle any of it. You really need to let nix handle itself.
13:30:18 <abueide> so i'm making an app that will be crossplatform (desktop, mobile, web) via reflex and dom. the problem is i need a library to download youtube videos. the obvious choice is youtube-dl written in python. I know I could execute it in a desktop environment and possibly in an android environment but what are my options for ghcjs?
13:30:45 <__monty__> tim____: This describes how to get started with nix. Do note that nix is pretty involved, so if you're only just learning haskell maybe it's not a good idea to learn nix on top of that: https://nixos.org/nix/
13:30:49 <pdxleif> tim____: Are those ones it says are broken installed into $HOME/.ghc/... ? You can use ghc-pkg list to check, and ghc-pkg unregister them if so (or just blow away that whole dir if you want)
13:31:41 <pdxleif> Doesn't cabal new-build do a lot of the same stuff as nix these days?
13:32:33 <geekosaur> pdxleif, except it does nothing about compartmentalizing OS dependencies, or OS-specific packaging annoyances like arch's haskell ecosystem
13:32:56 <geekosaur> you need something like nix to do that
13:33:23 <geekosaur> basically acting like a full, compartmentalized OS userspace, not just a specific language development env
13:33:28 <dmj`> glguy: if I start using states in my lexer, do all my tokens need to be annotated with state 0
13:33:32 <geekosaur> (or docker, etc.)
13:33:56 <glguy> dmj`: the ones that should be only valid in state 0 need that. You can make one big 0 state block, you don't have to repeat 0
13:34:00 <tim____> pdxleif: yes, it seems they reside there but they were installed by stack and I think I need them so I would like to tell my ghc installation where to find them actually
13:34:01 <cocreature> tim____: that looks like you have system-ghc enabled which is going to cause problems if you have installed Haskell packages via Pacman.
13:34:36 <tim____> __monty__: I ditched nixos in favor of arch becaus I had internet connection issues in nix.. but yeah.. maybe I will look into that again
13:34:40 <dmj`> tim____: if you start using nix, you can just use runghc Setup.hs build instead of cabal and stack, and truly live above the community drama
13:34:59 <pdxleif> tim____: They're broken, and stack doesn't need them anyways. It installs stuff into $HOME/.stack, and a .stack-work/ directory per-project.
13:35:33 <dmj`> tim____: nix works terribly on arch
13:35:37 <__monty__> Cabal-install works fine with nix.
13:35:51 <dmj`> __monty__: yea but you should never use cabal install <pkgname> w/ nix
13:36:04 <glguy> dmj`: https://github.com/glguy/config-value/blob/master/src/Config/Lexer.x#L58
13:36:05 <__monty__> Oh agreed.
13:36:22 <dmj`> __monty__: nix gives you a ghc-pkg list which is really all you need. runghc Setup.hs repl can be used with haskell-mode emacs as well
13:38:35 <tim____> oh jeez.. I made really pretty dotfiles for arch now.. and setup the windows dualboot.. but I guess I will move back to nixos and see if the network issues still persist..
13:38:58 <tim____> thanks for your input guys
13:39:07 <tim____> bye :) have a nice evening
13:40:07 * hackage primitive-extras 0.1.8 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.1.8 (NikitaVolkov)
13:40:32 <dmj`> glguy: ah, so startString seems to be exactly what I want. To handle both multiline and single line strings. I assume this is where alex-tools comes in.
13:41:32 <glguy> dmj`: startString is the action I defined for switching to the "string" mode: https://github.com/glguy/config-value/blob/master/src/Config/LexerUtils.hs#L121-L122
13:43:16 <glguy> then I let the lexer go along in string mode until it gets to the end of the string, at which point I figure out how long the string literal was: https://github.com/glguy/config-value/blob/master/src/Config/LexerUtils.hs#L131-L136
13:43:34 <dmj`> glguy: so action is more or less a state machine then, as a state monad
13:44:23 <dmj`> glguy: where does Action get evaluated
13:45:23 <glguy> https://github.com/glguy/config-value/blob/91678f9999d98a56cdbf8e07a2b97e4bf21f74c9/src/Config/Lexer.x#L118
13:46:20 <glguy> You feed characters into alex and it tells you if one of the actions matched
13:46:37 * hackage Spintax 0.3.3 - Random text generation based on spintax  http://hackage.haskell.org/package/Spintax-0.3.3 (MichelBoucey)
13:49:20 <dmj`> glguy: So in the case of an unterminated string it seems this is still returning a list of Tokens to the parser… why not operate in the Either monad, and have the parser do that as well
13:51:04 <glguy> If you use Either then your lexer can't stream, another difference is that you'll get all your lexical errors before any parse errors (which might be OK)
13:53:37 <dmj`> glguy: ah, so you just let the TokenError get raised to the Parser and handle it in Either there. https://github.com/glguy/config-value/blob/448a01c919a01f2e7927aa9dd969360f32d88d63/src/Config/Parser.y#L115-L116
13:53:55 <glguy> yeah
13:54:04 <dmj`> glguy: just curious why not show all tokens in the error case
13:54:18 <glguy> that would show the whole rest of the file
13:54:24 <glguy> but in tokenized format
13:55:26 <dmj`> glguy: yea, guess for something like a REPL or IDE that’s unnecessary
13:55:43 <glguy> It's not necessary in any use-case
13:59:25 <dmj`> I see, interesting, like the idea of an Error Token as well
14:00:43 <abueide> yay monads are no longer magic boxes to me anymore
14:00:49 <abueide> i kind of understand how they work now
14:01:25 <abueide> only took reading several hundred pages of a book
14:07:04 <croben_> abueide: what book was that?
14:07:27 <abueide> Haskell Programming by Chris Allen, Julie Morunuki
14:07:32 <abueide> i'm really liking it
14:07:34 <croben_> oh
14:10:34 <Ariakenom> ah The book
14:10:55 <Ariakenom> Will you write a monad tutorial now abueide?
14:11:48 <abueide> of course, i hear its the rite of passage for everyone who understands monads
14:12:11 <Ariakenom> yes yes good _sinister snicker_
14:12:42 <abueide> lol, what do you mean by "The book" if I may ask
14:12:59 <geekosaur> more of a wrong of passage, arguably >.>
14:13:21 <glguy> Does that make it half of a rite?
14:13:59 <abueide> its simple; monads are like burritos
14:14:07 <abueide> thats all you need to know
14:14:48 <dstolfa> abueide: that's assuming you can add a tortilla under another one
14:15:01 <dstolfa> if the burrito is already wrapped, that is
14:15:12 <Rembane> Mmmmburritos.
14:16:11 * dstolfa thinks the best way to understand monads is to learn category theory.
14:16:25 * dstolfa also thinks he's biased because he likes category theory in the mathematical sense
14:16:43 <Rembane> I think the best way is to use them and not think at all.
14:16:48 * dstolfa would probably not recommend learning category theory to a programmer that just wants to use them though
14:17:06 <dstolfa> Rembane: the easiest way to deal with monads if you're using them (or anything for that matter) is just to look at the types
14:17:07 <typetetris> Which parser library is a good compromise between speed and readable error messages?
14:17:15 <dstolfa> Rembane: things are so much easier when you just think in terms of types
14:18:08 <Rembane> dstolfa: Yup. :D
14:18:14 <Rembane> typetetris: megaparsec! :D
14:18:16 <Tuplanolla> Probably Megaparsec, typetetris.
14:18:29 <typetetris> ok thanks, just needed reassurance :D
14:18:59 <abueide> what are your guys' favorite programming environments? coming from java, I use intellij idea with vim emulation. error highlighting and auto completion seem poor and goto definition doesn't work with libraries imported through stack
14:19:06 <abueide> also i haven't figured out how to auto format
14:19:21 <abueide> maybe i'm just spoiled by the java ides
14:19:35 <dstolfa> abueide: vim + ghcmod for haskell, emacs for agda. whatever is on the box for C
14:19:45 <dmj`> abueide: emacs haskell mode + ghcid
14:20:16 <Solonarv> I use VS Code + haskero (which uses intero in the backend)
14:20:25 <Tuplanolla> I gave up the search after having learned about a dozen languages and now just use stock Vim, abueide.
14:20:43 <glguy> Yeah, ghcid is the most likely to work well
14:21:04 <abueide> allright thanks
14:21:08 <Rembane> abueide: I run neovim, I have some syntax hilighting and indentation, but that's about it.
14:21:09 <abueide> i'll look into them
14:21:15 * dstolfa mostly writes 4 languages at any given time, with C being the most common because he works on kernels but would prefer to replace that with haskell :<
14:21:50 <abueide> i gotta learn more about how to use vim properly like fuzzy file search and multiple files open at once
14:21:57 <abueide> ide takes care of that for me atm
14:22:18 <abueide> also how is refactoring stuff in vim?
14:22:27 <tswett> Hey there. I've got a question about memoization as GHC appears to implement it.
14:22:30 <dstolfa> abueide: subpar compared to intellij
14:22:35 <tswett> See this 12-line snippet here: https://repl.it/repls/LightheartedRealObjectdatabase
14:22:44 <tswett> (That code is taken from https://wiki.haskell.org/Memoization.)
14:23:09 <tswett> There are two implementations of a Fibonacci function, slow_fib and memoized_fib.
14:23:34 <glguy> tswett: That's not so much GHC implemented memoization as it is a poorly choosen lookup table
14:23:47 <tswett> slow_fib runs slowly, presumably in exponential time. memoized_fib is much faster; it presumably runs in quadratic time.
14:24:27 <tswett> Now, I would expect that a naive compiler would compile memoized_fib in such a way that "map fib [0 ..]" is evaluated from scratch for every invocation.
14:25:12 <fishythefish> for every invocation of `memoized_fib`, but not for every invocation of `fib`
14:25:22 <tswett> Wait, I didn't notice that memoized_fib...
14:25:24 <__monty__> abueide: Yes, learn to work with multiple buffers asap. Refactoring is mostly limited to find & replace unless there's cli tools you can shell out to. I haven't seen any haskell refactoring that's better than vim's substitute though.
14:25:25 <tswett> Right.
14:26:06 <fishythefish> tswett: do you see why even this gives you a speedup over slow_fib?
14:26:10 <glguy> tswett: That implementation relies on being implemented as "memoized_fib = (map fib [0 ..] !!)" and not "memoized_fib i = map fib [0 ..] !! i"
14:26:10 <Rembane> __monty__: vim's substitute, is that :%s/.../.../ ?
14:26:18 <__monty__> Rembane: Yes.
14:26:22 <tswett> glguy: right, that's what I didn't notice until a moment ago.
14:26:42 <Rembane> __monty__: Sweet! :D
14:27:00 <tswett> fishythefish: I think so. Presumably "map fib [0 ..]" is only "performed" once, and the resulting value or thunk or whatever is retained.
14:28:00 <fishythefish> right, once `fib` has been applied to an element of the list, it doesn't have to be reapplied, you just perform a lookup (in a list, ugh)
14:29:12 <tswett> Okay, here's what I think a naive implementation would do.
14:29:35 <tswett> In order to evaluate, say, fib 99, it would invoke memoized_fib twice, once to get memoized_fib 98 and once to get memoized_fib 99.
14:30:02 <fishythefish> well
14:30:12 <fishythefish> are you talking about total calls to `memoized_fib`?
14:30:17 <tswett> Each invocation of memoized_fib would involve "map fib [0 ..]" being evaluated, from scratch.
14:30:30 <tswett> Yeah... if I'm understanding the question right.
14:30:37 <fishythefish> then it's called more than that
14:31:02 <tswett> Oh, you mean total *recursive* calls? Yeah, it'd be called no less than about 200 times.
14:31:15 <tswett> But at the highest sub-level of evaluating fib 99, it'd be called twice.
14:31:33 <fishythefish> fib isn't top-level here
14:31:49 <tswett> Right.
14:32:06 <fishythefish> the top-level call to memoized_fib 99 would recursively call both memoized_fib 98 and memoized_fib 97, if that's what you mean
14:32:14 <tswett> Well, yeah, it would.
14:32:31 <fishythefish> either way, I think your counting is a bit off, but continue
14:33:40 <tswett> So it seems like GHC is "smart enough" to only evaluate "map fib [0 ..]" once. Or, at least, no more often than once per top-level invocation of memoized_fib.
14:33:44 <tswett> Is that accurate?
14:37:03 <tswett> Come to think of it, I might totally understand it, here...
14:37:10 <fishythefish> https://stackoverflow.com/questions/11466284/how-is-this-fibonacci-function-memoized
14:37:14 <tswett> The expression (map fib [0 ..] !!) is only evaluated once, ever.
14:37:27 <tswett> Oh, lemme read that.
14:38:23 <fishythefish> there's some stuff in there about monomorphic vs. polymorphic definitions but you have the right idea
14:38:37 * hackage extra 1.6.9 - Extra functions I use.  http://hackage.haskell.org/package/extra-1.6.9 (NeilMitchell)
14:39:39 <fishythefish> if you have `memoized_fib i = ...` instead of just `memoized_fib = ...`, then the local definition of `fib` is different for each `i`, so you don't share the lookups
14:45:26 <tswett> I think reading that cleared some stuff up, thanks.
14:45:42 <tswett> I've still got some questions.
14:46:09 <tswett> Suppose I just declare this at the top level:
14:46:17 <tswett> myInfiniteList = [0..]
14:46:46 <tswett> Is [0..] only going to be evaluated once, and the results cached forevermore?
14:46:49 <glguy> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC/CAFs
14:46:52 <glguy> tswett: ^
14:47:14 <tswett> Ooh.
14:47:26 <glguy> or whatever else you can find to read about "CAF"s
14:51:43 <abueide> whats weaker than a semigroup ?
14:52:32 <fishythefish> a magma, for example
14:52:37 <glguy> There's not a well-known class for it, but there's "magma"
14:52:55 <abueide> i remember it sounded really cool
14:52:59 <abueide> but forgot what it was called
14:53:14 <fishythefish> there are also semigroupoids, depending on how you want to generalize
14:53:32 <dstolfa> fishythefish: or you know, categories
14:54:00 <fishythefish> dstolfa: categories require identity
14:54:03 <glguy> http://hackage.haskell.org/package/semigroupoids-5.3.1/docs/Data-Semigroupoid.html
14:54:15 <dstolfa> fishythefish: so do groupoids
14:54:18 <tswett> I usually don't weaken my algebras by adding additional sorts to them. :D
14:54:24 <fishythefish> i didn't mention groupoids, dstolfa
14:54:50 * dstolfa realises he needs glasses
14:55:11 <fishythefish> oh, let's not bring lenses into this ;)
14:55:14 <dstolfa> fishythefish: i've semiread your semigroupoid :)
15:02:54 <abueide> if >=> and . are similar conceptually why isn't >=> just called . in the context of monads?
15:03:10 <abueide> instead of making a harder to remember operator
15:03:35 <lyxia> because they have different types
15:03:56 <mnoonan_> there is a Category typeclass that you can use for that (I assume)
15:03:59 <abueide> is overloading operators a bad design concept?
15:04:14 <lyxia> well there's good operator overloading
15:04:53 <lyxia> (>>=) works pretty well
15:05:23 <abueide> but then we have like <$> why isn't this just $
15:05:23 <lyxia> but you have to collaborate with the type system
15:05:28 <dstolfa> :t (.)
15:05:29 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:05:33 <dstolfa> :t (>=>)
15:05:34 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:05:49 <abueide> ah that would break :t
15:06:37 <abueide> i dunno i'm just getting frustrated by how many operators haskell has
15:07:22 <Rembane> Eventually you will be frustrated by how few operators other languages have.
15:09:51 <gentauro> :t (.:)
15:09:52 <lambdabot> error:
15:09:52 <lambdabot>     • Variable not in scope: .:
15:09:52 <lambdabot>     • Perhaps you meant one of these:
15:10:03 <gentauro> :t (.:?)
15:10:04 <lambdabot> error: Variable not in scope: .:?
15:10:11 <gentauro>  % (.:?)
15:10:22 <gentauro>  % :t (.:?)
15:13:10 <UnkDevE> Hey Im working on a sudoku solver backtracking function https://github.com/UnkDevE/Sudoku/blob/master/sudoku.hs#L97 is the algorithm correct?
15:14:07 <lyxia> that's a lot to read
15:14:34 <UnkDevE> yeah it is
15:36:18 <infinisil> UnkDevE: Write tests and stuff!
15:36:29 <infinisil> No need to ask people to check your algs correctness
15:37:01 <UnkDevE> okay Thank you!
15:43:57 <hexagoxel> only need to ask people if the test-suite is correct and sufficient :D
15:54:52 <srk> any idea why I'm getting Couldn't match type ‘m’ with ‘m1’ if I uncomment type of go here https://lpaste.net/7696748752127655936#line4 ?
15:55:16 <srk> even with (MonadIO m) =>
15:55:58 <glguy> srk: Because you're not using scoped type variables
15:56:09 <glguy> but you're using getsome in the implementation of go
15:56:19 <srk> aha
15:56:23 <glguy> getsome doesn't have any type 'm' you might want, it only has the type m in the type signature at the top
15:58:37 * hackage digit 0.6 - A data-type representing digits 0-9 and other combinations  http://hackage.haskell.org/package/digit-0.6 (qfpl)
15:58:58 <srk> even with ScopedTypeVariables and  chunk <- (getsome :: MonadIO m => m (Maybe B.ByteString))
15:59:21 <nai> ghci> :kind []
15:59:22 <glguy> Did you remember to add forall in the top signature?
15:59:23 <nai> [] :: * -> *
15:59:28 <srk> yeah, on it
15:59:34 <nai> why does [] have a "kind" ?
15:59:49 <koz_> Is there a way I can have a map of Text to pairs of (Proxy a, a) for different a's in the same map?
15:59:53 <srk> did that previously but I was trying with RankNTypes and ExistentialQuantification iirc
16:00:07 <glguy> [] is how you write the type of lists without being applied to a type argument
16:00:11 <glguy> [] Char   is   [Char]
16:00:33 <nai> i see. isn't that confusing?
16:00:37 <glguy> Nope
16:00:46 <nai> [] is at the same time a value and a type?
16:00:46 <glguy> Now that you know how it works you won't have to be confused
16:01:06 <glguy> The type and value namespaces are separate
16:01:26 <nai> if that is true
16:01:29 <glguy> The value [] is the empty list, the type [] is the type of lists
16:01:33 <nai> then why do we need types to start with a capital
16:01:42 <glguy> We dont'
16:01:43 <geekosaur> to distinguish in patterns
16:01:49 <glguy> constructors start with capitals, variables dont'
16:01:58 <glguy> for types the constructors are the things that are globally in scope
16:02:05 <geekosaur> it's not related to type vs. value level, in both lowercase is a binding/"variable" and titlecase is a constructor
16:02:06 <glguy> and variables are all locally bound at each signature
16:02:20 <srk> glguy: still. guess I'll leave go without type for now
16:02:40 <glguy> At the value level constructors are capitalized and variables are lowercased, when you look at a pattern it is clear what's being matched and what is being named
16:03:00 <nai> ok i think i understand
16:03:02 <nai> thanks
16:03:21 <glguy> there are just a couple of special cases like () and [] that don't have normal identifiers
16:03:51 <nai> ok
16:06:56 <koz_> I _think_ I can use Dynamic, but I was wondering if there was another solution.
16:07:40 <glguy> koz_: You can make a sum-type for all the various 'a's you support and have a map of those
16:07:59 <glguy> and in that case you won't need the proxy (which wasn't going to help with the Dynamic solution, anyway)
16:08:10 <koz_> glguy: That could work. I first have to see how large said Sum is.
16:08:15 <koz_> s/Sum/sum/
16:08:21 <koz_> Thanks!
16:14:59 <butterthebuddha> What's the correct typeclass for ADTs which store elements in some order?
16:15:09 <butterthebuddha> I.e., it makes sense to query for the first element for example
16:15:49 <tswett> butterthebuddha: so, ADTs whose values can be seen as ordered collections?
16:15:58 <butterthebuddha> tswett: Yep
16:17:06 <tswett> Sounds like Foldable to me.
16:39:22 <abueide> it seems whenever i try to add a new library through stack i get this error
16:39:23 <abueide> In the dependencies for hs-ipfs-api-0.1.0.0:
16:39:24 <abueide>     base-4.11.1.0 from stack configuration does not match >=4.7 && <4.10  (latest matching version is 4.9.1.0)
16:39:24 <abueide>     ivory needed, but the stack configuration has no specified version  (latest matching version is 0.1.0.7)
16:39:46 <abueide> how do i deal with these
16:40:26 <glguy> stack is all about you providing the build plan for it, the resolvers like lts-x.y are shortcuts to providing a bunch of packages into your buildplan at once
16:40:57 <glguy> right now your hs-ipfs-api package requires a version of base that isn't in the resolver you're using
16:41:16 <glguy> so either update hs-ipfs-api or pick a different resolver
16:41:35 <abueide> can i have multiple resolvers?
16:41:39 <glguy> nol
16:42:02 <abueide> what do you mean update hs-ipfs-api?
16:42:15 <abueide> hs-ipfs-api is the project i'm currently working on
16:42:20 <abueide> my own unpublished package
16:42:21 <glguy> Update it to work with base-4.11.*
16:42:55 <glguy> Change the bounds in your *cabal file's build-depends: section and run your tests to see if things still work
16:43:11 <abueide> oh the base version constraints were arbitrary, I'm not sure if it will break anything if i just delete them
16:43:15 <abueide> i think they were from stack new
16:43:26 <abueide> i still have an error for ivory though
16:43:48 <glguy> You'll need to find a version of ivory that works with the rest of your packages andput that in the stack.yaml extra-deps: section
16:48:34 <abueide> In the dependencies for ivory-0.1.0.7:
16:48:35 <abueide>     template-haskell-2.13.0.0 from stack configuration does not match >=2.8 && <2.13  (latest matching version is 2.12.0.0)
16:48:35 <abueide> needed due to hs-ipfs-api-0.1.0.0 -> ivory-0.1.0.7
16:48:43 <abueide> even though i have 2.12.0.0 in my extra-deps
16:49:54 <geekosaur> template-haskell is tied to the compiler version
16:51:28 <geekosaur> per https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory template-haskell-2.13.0.0 is ghc 8.4, 2.12 is ghc 8.2
16:51:37 <glguy> https://github.com/GaloisInc/ivory/pull/117
16:52:03 <glguy> Ivory on hackage hasn't been updated lately. I just merged that in on master. I'll prod the maintainer and see what he wants to do
16:52:33 <abueide> oh thank you
16:59:46 <vasiliy_san> Hi all, I need some help with terminology. When I have an overloaded function which was defined in type class and later I give a concrete type to that function is it called "instantiation" or "specialization" or something else?
16:59:46 <vasiliy_san> For example, is `test` function "instantiates" `square` or what?
16:59:46 <vasiliy_san> ```
16:59:46 <vasiliy_san> square :: Num a => a -> a
16:59:46 <vasiliy_san> square x = x * x
16:59:46 <vasiliy_san> test :: Int
16:59:47 <vasiliy_san> test = square (10 :: Int)
16:59:47 <vasiliy_san> ```
17:01:33 <glguy> vasiliy_san: Use pastebins (like gist.github.com) for pasting code
17:03:23 <vasiliy_san> Alright, thanks for correction. I thought pastbin is only for big code pieces but now I will use it for everything.
17:03:37 <geekosaur> generally the cutoff's around 3 lines
17:03:45 <geekosaur> (this is common to many IRC channels)
17:03:57 <glguy> and your ``` count toward that limit
17:05:19 <abueide> is there a linux tool that lets you copy text and upload it putting the link into your clipboard?
17:05:21 <vasiliy_san> Ha. I need to find some emacs plugin to automate pastebin. And probably start using IRC from emacs.
17:05:28 <abueide> kinda like maim for screenshots
17:06:14 <vasiliy_san> Here is my code https://pastebin.com/22YMZJ8U I don't know how to call the process of turning type constraints into concrete type.
17:06:18 <geekosaur> and I would say this is just using the function at a particular type. specialization is more the compiler generating a specifically optimized version of the function at some type (which might not be worth it). (also note that the compiler optimizing away the typeclass lookup is separate)
17:07:16 <Tuplanolla> I think `sprunge` did that at one point, abueide.
17:07:53 <geekosaur> in particular, specialization is useful when you have a polymorphic function but there are benefits to generating code specialized to a type beyond simply calling the appropriate typeclass methods, which is something optimization can often handle
17:07:57 <Tuplanolla> It still might, but I haven't seen it in a while.
17:09:22 <ammar2> type application might be a decent word for it, that's what the system-f calls it
17:10:31 <vasiliy_san> geekosaur: I got it, specialization is something which relates to optimization, inlining, etc. So specialization is definitely the wrong word.
17:10:34 <abueide> glguy, so for now do i just have to downgrade lts to build?
17:10:51 <glguy> abueide: Or use ivory from git
17:11:30 <vasiliy_san> I ha, type application... sounds unfamiliar but can work.
17:11:32 <abueide> how do I use that?
17:11:44 <abueide> how do i do that* can i have stack resolve a dependency from git
17:12:07 <geekosaur> specialization can also refer to providing a type-specific implementation for a method that has a default implementation in a typeclass instance, I think.
17:12:21 <geekosaur> abueide, yes, there's an extra-deps syntax for git repos at a particular commit
17:13:07 <vasiliy_san> What about instantiation? What does it mean in Haskell ? There is `instance Something a` syntax, probably instantiation is the right word? (just guessing)
17:13:14 <abueide> does anyone know if using Uint8 from Ivory will work with Aeson?
17:13:59 <geekosaur> it varies somewhat, but it's closer to what you were describing than specialization is
17:15:19 <ammar2> heh, there's a ghc extension called type application that does what you're talking about https://ghc.haskell.org/trac/ghc/wiki/TypeApplication
17:15:34 <abueide> will this work? https://pastebin.com/mXP5Umg8
17:15:58 <geekosaur> ammar2, yes. and it's almost literally just a projection of Core's type application to the level of language syntax
17:16:18 <geekosaur> before that extension, Core used it but there was no way to access it directly from Haskell
17:16:28 <ammar2> aah
17:19:25 <ammar2> are many haskell features implemented as extensions and then included in the main language?
17:20:59 <geekosaur> generally, yes. although the standard tends to lag quite a bit, since there isn;t a lot of incentive to maintain it when there's only one implementation that anyone uses
17:21:14 <abueide> oh i'm supposed to use Word8
17:21:26 <geekosaur> (and everyone uses so many extensions these days that make it harder for other implementations to be written)
17:21:44 <abueide> why is an unsigned int in haskell called Word?? lol
17:21:57 <ammar2> that's a pretty normal convention in computer architecture
17:22:01 <vasiliy_san> ammar2: hmm, it says that TypeApplication allows instantiating type variables.
17:22:03 <geekosaur> think assembly language: machine word
17:22:06 <ammar2> the smallest addressable unit is called a word
17:22:38 <ammar2> vasiliy_san: heh, I wouldn't fret the exact words too much
17:22:44 <ammar2> as long as you can get the concept across
17:22:44 <geekosaur> vasiliy_san, yes, because that's how things are exposed at Haskell level, you have type variables that you can specify with @
17:23:24 <abueide> huh i've never known that
17:23:58 <c_wraith> abueide, ever wondered why regedit calls the most common key class "DWORD"?
17:24:31 <ammar2> oh god, microsoft's usage of word is disgusting
17:24:49 <abueide> i've never used regedit
17:25:07 <ammar2> abueide: https://en.wikipedia.org/wiki/Word_(computer_architecture)
17:25:26 <c_wraith> ah. hmm. that's the least technical place I've seen the term used, I guess.
17:25:59 <abueide> fascinating though
17:27:27 <c_wraith> abueide, I have to confess - when I was trying to teach myself how to program as a young 'un many years back, I was confused as heck to what all those resources talking about "words" meant. :)
17:28:05 <abueide> i've only ever used JVM languages and very rarely some c for arduino
17:29:16 <ammar2> c_wraith: the usage of the word is in no way consistent any way these days
17:32:34 <Welkin> words existed before bytes
17:33:06 <Welkin> words have never been consistent
17:33:31 <ab9rf> microsoft uses "dword" because most of MSFT's developers were previously VAX programmers
17:34:00 <ab9rf> at least in the late 80s and through the 90s
17:34:20 <ab9rf> it's utterly natural for me, but that's because VAX-11 was my third architecture
17:34:36 <ab9rf> for someone who came up on IBM systems, it'd be confusing as all hell
17:34:44 <geekosaur> lots of early CPUs didn't even have bytes. word sizes varied from 6 to 36 in different DEC lines, for example
17:35:26 <c_wraith> weren't there some cpus with variable-size words?
17:35:44 <ab9rf> geekosaur: i seem to recall one that had 40-bit words
17:36:45 <geekosaur> in some sense PDP10 was variable because of register slicing. but the basic hardware word size was 36
17:36:53 <ab9rf> c_wraith: there have been some architectures that had the ability to do weird stuff like that
18:30:40 <koz_> Which of the *parsecs are we meant to use to write parsers nowadays?
18:33:16 <lyxia> mega
18:34:56 <koz_> lyxia: OK, thanks.
18:35:34 <jchia> webserver question: When I use scotty (http://hackage.haskell.org/package/scotty-0.11.2/docs/Web-Scotty.html#v:scotty), I think I'm basically getting an infinite loop that keeps serving. Is there a way to tell it to stop or to explicitly serve one request at a time?
18:36:22 <jchia> Similar question for Network.Wai.Handler.Warp.run: https://www.stackage.org/haddock/nightly-2018-07-12/warp-3.2.22/Network-Wai-Handler-Warp.html#v:run
18:36:48 <jchia> My main app is not a webserver. It makes a webserver during specific times during its lifetime.
18:39:11 <geekosaur> I'd suspect not, since that's not what most people are looking for. settingsOnClose might be useful to shut the app down after processing a single connection, but it will still fork and I'd guess that replacing settingsFork would not do what you intend
18:51:16 <jchia> geekosaur: Thanks
18:51:43 <geekosaur> tbh you probably want to dig at lower levels; a WAI Application is too high level for what you want.
18:52:14 <geekosaur> for very simple web control I;ve been known to write a mini web server, but I don't think you need to go quite *that* low level here
18:52:34 <Welkin> use a tcp socket
19:19:21 <koz_> For Megaparsec, if I want a parser to parse something, but then discard it, how would I write that?
19:20:36 <c_wraith> koz_, many ways to do it. there are plenty of variants for both monadic and applicative styles
19:21:37 <andrew_> https://pastebin.com/qg444C2X
19:21:43 <andrew_> can anyone help me out with this error?
19:22:00 <glguy> https://pastebin.com/raw/qg444C2X
19:22:22 <koz_> c_wraith: OK. I'm just trying to understand how it all works, so I'm following one of the tutorials the Megaparsec docs link (https://markkarpov.com/megaparsec/parsing-simple-imperative-language.html).
19:22:32 <koz_> It's... a bit of a deep dive and a bit magical.
19:22:48 <c_wraith> > (,) <$> Just 1 <*> Just 2 *> Just 3
19:22:51 <lambdabot>  Just 3
19:23:08 <c_wraith> heh,whoops. got the associaticity wrong.
19:23:09 <koz_> Ah, so *> will do. THank you.
19:23:29 <abueide> :t *>
19:23:31 <lambdabot> error: parse error on input ‘*>’
19:23:40 <abueide> :t (*>)
19:23:41 <lambdabot> Applicative f => f a -> f b -> f b
19:23:42 <c_wraith> but yes, *> and <* will help
19:24:34 <c_wraith> > (,) <$> Just 1 <*> (Just 2 *> Just 3) -- what I meant.
19:24:35 <Welkin> (*>`.`)>*
19:24:37 <lambdabot>  Just (1,3)
19:24:46 <Welkin> *<(`.`<*)
19:24:48 <abueide> so *> is like snd and <* like fst?
19:24:49 <glguy> abueide: If you comment out the broken line, load that module in GHCi and run ":kind! Client ClientM PubSubAPI" what does it say?
19:25:19 <glguy> c_wraith: (,) <$> Just 1 <* Just 2 <*> Just 3
19:26:27 <abueide> its saying Pubsub.hs can't be found
19:26:32 <c_wraith> abueide, it's closer to think of them as const and flip const.
19:26:48 <abueide> do i have to be in same directory as the module when i run ghci
19:27:03 <c_wraith> glguy, I just think better in infixr for some reason.
19:28:44 <glguy> ((((,) <$> (Just 1)) <* (Just 2)) <*> (Just 3))
19:28:49 <abueide> glguy, Client ClientM PubSubAPI :: *
19:28:50 <abueide> = ([[Char]] -> ClientM [Char])
19:28:50 <abueide>   Servant.API.Alternative.:<|> (Maybe [Char]
19:28:50 <abueide>                                 -> ClientM (Servant.API.Stream.ResultStream PubSubMessage_))
19:28:51 * glguy just playing with the tool
19:29:31 <glguy> abueide: OK, so make your type signature on pub and sub match those
19:29:36 <abueide> okay
19:32:13 <abueide> glguy, thanks thats really useful now I know how to solve type errors like that
19:37:00 <koz_> In https://markkarpov.com/megaparsec/parsing-simple-imperative-language.html, what does the 'try' in 'identifier = (lexeme . try) (p >>= check)' refer to?
19:37:31 <c_wraith> koz_, it's a combinators megaparsec provides
19:37:48 <koz_> c_wraith: Which module is it documented in?
19:38:06 <c_wraith> koz_, should be in the main one. it's very important.
19:38:30 <koz_> http://hackage.haskell.org/package/megaparsec-6.5.0/docs/Text-Megaparsec.html#v:try <-- this one?
19:38:35 <c_wraith> (it allows a parser to backtrack if it fails after matching some input)
19:38:38 <c_wraith> yes
19:38:42 <koz_> OK thanks.
19:40:46 <koz_> Also, they give the 'standard' way of parsing a bunch of alphanumerics in UTF-8 as '(:) <$> letterChar <*> many alphaNumChar'. However, I wanna parse Text instead - what should I use to get the same effect?
19:41:12 <koz_> (that is, this parses a non-empty sequence of UTF-8 alphanumeric characters into a String, but I'd like it in a Text instead)
19:42:10 <geekosaur> you'll need to pack it. it's parsing individual characters, it's not going to magically give you a Text
19:42:59 <koz_> geekosaur: So basically '(T.pack . (:)) <$> letterChar <*> many alphaNumChar'?
19:43:06 <geekosaur> pretty much, yes
19:43:11 <koz_> OK, sure thing.
19:43:22 <geekosaur> any per-character assembly mechanism would perform much worse than just packing the result all at once
19:43:30 <koz_> Makes sense.
19:47:12 <koz_> geekosaur: So if I write something like 'symbol "name:" *> sc *> textual <* sc', would I end up with a parser that parses all that, but only gives me the thing 'textual' would parse?
19:47:44 <geekosaur> I think so
19:48:27 <glguy> yeah
19:50:33 <infinisil> :t (*>)
19:50:34 <lambdabot> Applicative f => f a -> f b -> f b
20:05:03 <vaibhavsagar> has anyone been following the Python drama?
20:05:41 <vaibhavsagar> I'm wondering if we have any ideas about what is going to happen to GHC if/when SPJ decides he doesn't want to work on it any more
20:06:19 <geekosaur> SPJ isn't a benevolent dictator; there is a ghc-proposals committee already
20:06:37 <vaibhavsagar> true
20:06:44 <geekosaur> and for several years Simon Marlow has been more of a de-facto leader anyway
20:07:04 <geekosaur> (which of course only moves the question there)
20:07:21 <vaibhavsagar> did SPJ use to be more active?
20:07:33 <koz_> The tutorial writes (for example) ifStmt using do-notation. However, my alternatives are very simple, amounting to effectively 'do t <- symbol "foo"; return Foo'. Can I write that as 'symbol "foo" *> pure Foo'?
20:08:03 <geekosaur> koz_, yes
20:08:03 <glguy> or even:   Foo' <$ symbol "foo"
20:08:18 <koz_> OK, just making sure I understood correctly.
20:08:23 <geekosaur> vaibhavsagar, yes, hstorically. ghc's been around for a while
20:08:56 <vaibhavsagar> fair enough, I haven't been writing Haskell for very long
20:09:19 <koz_> :t (<$)
20:09:20 <lambdabot> Functor f => a -> f b -> f a
20:10:25 <abueide> if I have runQuery :: IO (Either Error String) how can I print the result assuming Error has an instance of show
20:10:50 <geekosaur> runQuery >>= print
20:11:15 <geekosaur> or equivalently: do res <- runQuery; print res
20:11:29 <geekosaur> (but for something that simple it's a bit silly to name the intermediate)
20:11:43 <vaibhavsagar> doesn't this only carry through the (Right _) case?
20:11:59 <abueide> ahhh okay
20:12:05 <glguy> vaibhavsagar: no
20:12:48 <glguy> vaibhavsagar: That code is using IO's Monad instance, not (Either Error)'s
20:12:58 <vaibhavsagar> oh, I see
20:17:27 <koz_> I am again amazed at how sensible Haskell libraries are.
20:18:13 <vaibhavsagar> *slaps roof of `base`* this bad boy can hold so much compositionality in it
20:18:26 <koz_> LOL
20:18:35 <koz_> That meme's sure been doing the rounds lately.
20:18:53 <koz_> Cantor: *slaps roof of N* this bad boy can hold so many copies of N in it
20:20:24 <vaibhavsagar> https://twitter.com/stdlib/status/1016766023477809153
20:20:35 <koz_> LOL
20:20:49 <koz_> Perfection.
20:27:31 <koz_> Is this translatable to applicatives instead of do-notation? https://lpaste.net/2818244268462702592
20:28:17 <glguy> (\ (i1,i2) -> FromTo i1 i2 ) <$> int <* symbol ".." <*> int <* sc
20:28:33 <koz_> :t liftA2
20:28:34 <glguy> and don't write this: return . FromTo i1 $ i2,   when return (FromTo i1 i2) will do
20:28:35 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
20:29:10 <glguy> (\ i1 i2 -> FromTo i1 i2 ) <$> int <* symbol ".." <*> int <* sc
20:29:23 <glguy> oh.. :)
20:29:30 <glguy> FromTo <$> int <* symbol ".." <*> int <* sc
20:30:13 <koz_> Thanks glguy!
20:37:53 <butterthebuddha> What do people think of making heavy use of type declarations (for eg. type Key = Int) for documenting function arguments?
20:38:15 <iqubic> How many of those type synonyms are you planning on making?
20:38:57 <glguy> type synonyms are not appropriate for  documenting arguments
20:40:34 <blankhart> is the preferred pattern passing in a product type with named record fields
20:43:32 <glguy> That and documenting the arguments with haddock comments: https://github.com/glguy/irc-core/blob/v2/lib/src/Irc/RateLimit.hs#L37-L40 (random example)
20:44:57 <blankhart> haddock comments seem precarious for f :: Int -> Int -> Int -> Int -> Int -> Int -> Int
20:46:05 <glguy> That's an extreme case that isn't really going to come up. That should be refactored if possible to use a few higher level arguments
20:46:27 <koz_> I'm having a bit of difficulty writing Megaparsec logic for GADTS here: https://lpaste.net/7394375654260604928 Could someone give me a clue how I do this? I'm following https://markkarpov.com/megaparsec/parsing-simple-imperative-language.html as a guide.
20:51:08 <glguy> Specifically the "Missing" case?
20:51:43 <koz_> glguy: I can't even write optionalType :: SchemaParser Optional a
20:51:51 <koz_> (or rather, I'm not sure how I would)
20:52:09 <koz_> Sorry, should have been 'SchemaParser (Optional a)'
20:52:14 <sampler> Can someone help me out. I'm new to Haskell. Trying to understand, is a data constructor a function?
20:52:29 <glguy> In this case you can use the functions: (Missing . CategoricalWithMissing) and (Missing . RangeWithMissing)
20:52:58 <glguy> Though it's not clear why you need a GADT there in the first place
20:53:24 <glguy> You'd save yourself some headache just not using a GADT there
20:53:27 <koz_> Oh yeah, point taken.
20:53:34 <koz_> What about the Optional?
20:54:31 <glguy> It's not clear why you need either from this file
20:54:44 <koz_> glguy: How would you suggest I write those?
20:54:52 <koz_> It's likely I'm overcomplicating things.
20:55:19 <glguy> Get rid of the Optional type altogether and split Missing into two constructors
20:55:42 <koz_> Oh yeah, that'd work. Thanks!
21:01:48 <jackdk> sampler: You can use a data constructor like a function
21:01:50 <jackdk> :t Just
21:01:52 <lambdabot> a -> Maybe a
21:02:00 <jackdk> :t Just "hello"
21:02:02 <lambdabot> Maybe [Char]
21:02:19 <glguy> sampler: Sometimes a data constructor is a function
21:02:31 <glguy> That'll be the case if the data constructor has 1 or more fields
21:02:52 <jackdk> sampler: but unlike normal functions, you can also use them in patterns. That is, inside case-expressions or in a function definition on the LHS of the `=`
21:02:53 <glguy> True :: Bool -- not a function,   Left :: a -> Either a b -- a function
21:03:44 <sampler> So a nullary constructor is a function with no parameters?
21:03:56 <glguy> no
21:04:02 <glguy> It's not a function at all
21:04:13 <glguy> Functions are things that have the type (a -> b) for some a and b
21:04:28 <shachaf> A function is just a function with no parameters that returns a function with one parameter.
21:05:38 <glguy> sampler: Maybe this will help you http://conal.net/blog/posts/everything-is-a-function-in-haskell
21:07:43 <shachaf> I think the "Operational thinking" section isn't really fair. You don't need operational thinking to get that confusion from nonstrictness.
21:08:23 <shachaf> People are used to things that might nonterminate being functions, because that's how it is in strict languages.
21:08:59 <ab9rf> i recently ha someone express disbelief that [1..] is not a function
21:09:35 <sampler> so if I do like, data A = B a; than wouldn't the type A contain B Int -> A? But isn't that infinitly recursive
21:10:07 <glguy> sampler: You mean: data A a = B a ?
21:10:16 <shachaf> There's nothing wrong with recursion, but also there's no recursion going on there.
21:10:27 <jackdk> It's not infinitely recursive because there's no `A` on the RHS of your `=`
21:10:32 <glguy> the type variable 'a' needs to be bound somewhere
21:10:59 <sampler> I guess I do. Sorry, I just started reading about haskell yesterday.
21:12:16 <sampler> so like if I have data A a = B a, then B is a function that takes an a and returns an A a. But the only value in A a is the function B a?
21:13:33 <koz_> How do I turn OverloadedStrings on in GHCI?
21:13:39 <koz_> s/GHCI/GHCi/
21:13:58 <glguy> No, the values with type (A a)    are of the form  (B x) where x has type a
21:14:12 <ab9rf> if i understand you correctly, the values in A a are the images of the function B, when applied over the values of the type a
21:14:54 <jackdk> koz_: `:set -XOverloadedStrings`
21:15:07 * hackage hpack 0.29.1 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.29.1 (SimonHengel)
21:15:48 <koz_> jackdk: Thanks!
21:16:19 <ab9rf> i need to find time to read more about category theory
21:16:24 <ab9rf> does anyone have a time machine i can borrow?
21:16:45 <koz_> Also, what do I need to import to have Void availabe?
21:16:49 <glguy> ab9rf: I'll come back in time and lend you mine when I'm done with it
21:16:53 <glguy> Data.Void
21:17:09 <shachaf> I have machines that consume time.
21:17:09 <koz_> glguy: Thanks!
21:17:24 <koz_> We need a shachaf co-machine then.
21:18:09 <sampler> But if I have like B Int, what is in the image of B. Ints? so B 5 produces an A 5?
21:19:16 <sampler> or like an A Int version of 5
21:19:18 <jackdk> you're mixing types and values. `B` has this type: `B :: a -> A a`, so `B 'x' :: B Char` because `'x' :: Char`
21:19:19 <shachaf> If the type of "x" is "a" then the type of "B x" is "A a"
21:19:44 <glguy> No, B 5 has type A Int
21:20:10 <sampler> I thought the value of B x is x -> A a where x is of type a.
21:20:28 <glguy> No, it's what we said earlier
21:20:39 <ab9rf> sampler: B is of type x -> A x, for all x.
21:20:51 <glguy> B :: a -> A a
21:20:56 <glguy> B 5 :: A Int
21:21:09 <ab9rf> B x is of type A x.
21:21:21 <glguy> B x is of type A a where x is of type a
21:21:31 <ab9rf> or, rather, of type A a where x is of type a
21:21:46 <ab9rf> which glguy beat me to saying because my left arm is asleep
21:22:11 <glguy> I was playing Lumines, which slowed me down
21:22:35 <ab9rf> i'm allegedly playing the new release of dwarf fortress, but i keep getting distracted
21:24:36 <sampler> Ok, so like in English, if I say data A a = B a, then I will have created many different conrete types, like A Int, A Bool, and B is a function I can use to convert map values in Int, Bool, etc to these concrete types
21:25:50 <ab9rf> sampler: you are creating a type constructor (called A) and a data constructor (called B).
21:26:22 <glguy> sampler: sounds fine
21:26:42 <ab9rf> i'd be wary about using the term "concrete types" though
21:27:28 <ab9rf> data constructors are quite definitely maps, though
21:28:37 <sampler> The only concept of generic I have is a template, which would just generate code that creates A Int, A Bool. Still struggling with understanding the things I have no context for.
21:29:10 <ab9rf> sampler: haskell gives you the genericism that in a language like java or C++ reuqires a whole load of complexity almost completely for free
21:30:47 <ab9rf> at least, until you run into the damned monomorphism restriction
21:34:16 <iqubic> What is the DMR?
21:36:48 <vaibhavsagar> iqubic: inferred types are less general than they could be
21:39:57 <Welkin> dreaded
21:40:00 <Welkin> not damned
21:40:26 <iqubic> Damned is also a good descriptor.
21:41:07 <ab9rf> sorry :)
21:43:55 <jchia> Is there anything special I need to know when using GHC-specific retry (Control.Monad.STM or GHC.Conc)? Why is it GHC-specific? Can I expect reasonable implementation that doesn't spin-loop?
21:44:41 <geekosaur> it is ghc-specific because STM is not specified by the Haskell standard
22:27:53 <abueide> i don't get it why does this not work
22:28:04 <abueide> stream <- runQuery (sub ["topic"])
22:28:05 <abueide>       case stream of
22:28:05 <abueide>         ServantError -> print ServantError
22:28:05 <abueide>         Just x -> x >>= printResultStream
22:28:15 <mniip> iqubic, designated marksman rifle?
22:28:24 <abueide> but this does runQuery :: ClientM a -> IO(Either ServantError a)
22:28:56 <abueide> i'm getting not in scope data constructor ServantError and i have the same import in both files
22:29:22 <mniip> abueide, in the former code you only use the ServantError type constructor
22:29:22 <geekosaur> abueide, it will be Left err | Right x, and x is alreafy pure
22:29:37 <mniip> er
22:29:39 <mniip> in the latter*
22:29:41 <geekosaur> "Just" is only for Maybe, not Either
22:29:47 <abueide> oh i'm tired
22:29:48 <abueide> lol
22:31:21 <abueide> thank you that was silly
22:31:27 <abueide> sorry :c
22:32:07 * hackage hpack 0.29.2 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.29.2 (SimonHengel)
22:49:31 <abueide> hey guys so i'm trying to parse a json object with a variable named "data" but i had to rename it to content in my object because it collides with the data keyword but its not parsing properly, looking for the content word instead
22:49:33 <abueide> how do i fix this
22:50:20 <abueide> data PubSubMessage_ = PubSubMessage_ {
22:50:20 <abueide>   from :: String,
22:50:20 <abueide>   content :: String, -- Data field renamed due keyword collision
22:50:20 <abueide> } deriving (Eq, Ord, Generic, Show)
22:50:20 <abueide> instance FromJSON PubSubMessage_
22:51:10 <pavonia> You probably have to write the instance yourself
22:59:29 <jackdk> IME, automagic json instances are a trap, because you get surprising breakage as a result of a refactor. Unless you're extremely diligent about tests
23:00:22 <cocreature> automatic json instances are fine if you control all clients (both the ones that serialize and the ones that deserialize) and you can guarantee atomic updates
23:02:32 <jackdk> true, but most times when I think I have that, I've been wrong
23:03:40 <cocreature> right, I wasn’t trying to say that’s a particularly common situation. I was just trying to outline the constraints under which an automatic instance might be fine :)
23:13:37 * hackage geodetic-types 0.0.1 - Types for geodetic operations  http://hackage.haskell.org/package/geodetic-types-0.0.1 (qfpl)
23:49:07 * hackage viewprof 0.0.0.19 - Text-based interactive GHC .prof viewer  http://hackage.haskell.org/package/viewprof-0.0.0.19 (MitsutoshiAoe)
23:51:54 <revskill> This is how i think about Functional programming:
23:51:58 <revskill> output = foldl substitution input program
23:51:58 <revskill> where program = [definition]
23:52:03 <revskill> is it correct ?
23:53:22 <mniip> what?
23:59:15 <revskill> given an input, you repeatly substitute input to each definition to get ouput
