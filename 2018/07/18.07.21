00:17:24 <dukedave> I'm reading Learn you a Haskell and just seen `(->)`. Is that a well known function, or just an example? I don't see anything in Hoogle?
00:18:39 <dukedave> It says, "it's just a type constructor that takes two parameters".
00:19:10 <nisstyre> it's the type constructor for functions
00:19:17 <kuribas> The higher kinded approach like in Beam looks really nice.  Are there disadvantages to it?
00:20:10 <dukedave> nisstyre: can you give an example of how I'd use it? (also thanks!)
00:22:00 <dukedave> Oh, wait, sorry, I think I get it now..
00:23:28 <lavalike> every time I run cabal new-repl I get ``Warning: The package list for 'hackage.haskell.org' does not exist. Run 'cabal update' to download it'' but running cabal update does not fix it, why is that?
00:46:44 <koz_> class HasField (x :: k) r a | x r -> a where <-- what's with the :: k there?
00:46:59 <tfc[m]> hey there, does anybody know where i can lookup online "the official" instance-of declaration of standard haskell lists for Fucntor, Applicative, and Monad ?
00:48:40 <koz_> tfc[m]: http://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.Base.html#line-940
00:49:05 <tfc[m]> koz_: thank you!
00:57:07 * hackage uploadtest 0.0.0 - Upload test  http://hackage.haskell.org/package/uploadtest-0.0.0 (AlexeyKotlyarov)
00:57:29 <aarvar> koz_: it's a kind signature
00:57:54 <koz_> aarvar: I've only seen kinds of the form *, * -> *, etc. What's 'k' mean?
00:58:16 <aarvar> says x can have any kind k
00:58:25 <koz_> Oh, OK.
00:58:38 <aarvar> k becomes another class parameter, but it's implicit
00:59:58 <koz_> OK, thanks. I just read about this in the GHC manual, and it seems... very useful.
01:00:40 <aarvar> it is
01:19:09 <raduom> koz_: there is a Haskell extension that lets you name kinds (was it polymorphic kinds) and then you could potentially reuse them in your class definition.
01:22:36 * hackage ipython-kernel 0.9.1.0 - A library for creating kernels for IPython frontends  http://hackage.haskell.org/package/ipython-kernel-0.9.1.0 (VaibhavSagar)
01:23:36 * hackage ihaskell 0.9.1.0 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.9.1.0 (VaibhavSagar)
01:32:28 <kuribas> how would you model inheritance?
01:33:07 <kuribas> For example, you want to add a ID to other types.
01:34:04 <kuribas> I could do data WithID a = {id :: Int, id_data :: a}, but that would require always using id_data to get to the data.
01:37:04 <pavonia> Isn't that what type classes are used for? class HasID a where ...
01:37:53 <pavonia> I think the Haskel gtk bindings use this approach too
01:38:58 <kuribas> right.  I remember the wxHaskell has an interesting object model as well...
01:46:21 <gentauro> what is the time complexity of the following calls to foo, where foo is defined as: foo 1 = "uno"; foo 2 = "dos"; ...; foo n = show n
01:46:52 <gentauro> O(1)?
01:47:29 <kuribas> pavonia: ah, wxHaskell use the nested approach.
01:48:02 <kuribas> gentauro: very likely
01:49:02 <siraben> Is my understanding of the Yoneda lemma correct?  From what I understand:  If you take the hom-set of an object A to itself, and consider a functor F that maps A to F(A) and f to F(f) and X to F(X) where f is a morphism from A to X
01:49:14 <siraben> Hom(A,A) contains the identity morphism A to A
01:49:23 <gentauro> kuribas: is there a limit in the pattern clauses before it becomes slow?
01:50:13 <kuribas> gentauro: I think it will use a jump table, but there shouldn't be holes then
01:50:40 <kuribas> best check the assembly output
01:50:41 <siraben> And thus the natural transformation alpha from Hom(A, A) to F(A) can be represented by an element u in F(a), correct?
01:51:04 <gentauro> kuribas: when you mean holes: foo 1 ... foo 3 (skipping 2 right)?
01:51:14 <gentauro> if that is the case, there will be not
01:51:29 <gentauro> it's a very "small finite set" of values
01:52:28 <kuribas> gentauro: very likely it uses a jump table, but check the assembly for sure.
01:52:47 <kuribas> ghc is actually quite smart
01:54:34 <gentauro> kuribas: thx, will do that :)
02:22:42 <pie_> has anyone read https://www.manning.com/books/functional-reactive-programming ?
02:23:16 <pie_> im writing GUIs as a newb and its not so fun
02:29:12 <pie_> ah wait thats in java and javascript, not that the concepts wouldnt necessarily transfer
02:29:47 <pie_> so anyway im doing GUI programming and I heard FRP might make this less bad, but I have no idea how to begin, haskell has like 20 libraries
02:29:54 <pie_> help im very lost?
02:30:29 <Berra> pie_ I think the _concepts_ transfer quite well with some creative grease. But you might be better off reading a book with examples in Haskell. There are many great papers on FRP that does have examples in Haskell (or earlier similar languages like Gofer or Miranda)
02:31:04 <pie_> if it changes anything, im using Qt
02:31:09 <pie_> and the qtah bindings
02:31:21 <Berra> pie_ I would definitely say that FRP can make UI programming more pleasant and easier to model once the UIs become more complex with interaction.
02:31:41 <pie_> im definitely going for a non-toy application
02:31:46 <Berra> pie_ I have no experience with Qt so it's hard for me to comment on that.
02:32:13 <pie_> well the bottom line is that the bindings are pretty raw and imperative, but i suppose that doesnt change much
02:32:18 <kuribas> pie_: I don't know many libraries, but reactive-banana is quite nice for GUIs
02:32:23 <Berra> pie_ What made you go for Qt instead of Gtk? (just curios not questioning the choice)
02:32:35 <kuribas> pie_: but you'll have to fire the events yourself.
02:33:01 <pie_> im somewhat familiar with the qt api, dont really have any experience with gtk but i have the uninformed imression that qt is probably nicer or has more features or something
02:33:27 <Berra> pie_ If you're still unfamiliar with FRP being the person to wrap and abstract Qt in a FRP UI framework might be a daunting task.
02:33:47 <kuribas> pavonia: I found a way to have inheritance without manually unpealing layers: https://gist.github.com/kuribas/fa0955ee330145fc87c0f57825060c3e
02:33:58 <pie_> i dont think ill have much success but its not like anyone else will do it ;_;
02:34:13 <kuribas> pavonia: would work with a lens as well :)
02:34:24 <Berra> pie_ I haven't used it but just googled http://hackage.haskell.org/package/grapefruit-ui-gtk
02:35:34 <pie_> Berra, does FRP have prereqs like knowing how to use half the type system/etc? :p
02:35:56 <Berra> pie_ No I would not say that it does, no.
02:36:02 <pie_> ok
02:36:31 <Berra> pie_ I think you should read this - I'm reading it now. It hits on the points you're asking about: https://apfelmus.nfshost.com/blog/2012/03/29-frp-three-principles-bidirectional-gui.html#implications-for-haskell-gui-frameworks
02:36:42 <pie_> thanks
02:43:01 <pie_> "Principle. GUI elements generate events only in response to user input, never in response to program output." that seems really restrictive...well i have to read the rest of the article i guess
02:45:14 <pie_> this is a pretty old article though
02:51:49 <Berra> pie_: I would try out Grapefruit
02:56:03 <pie_> ok ill look
03:15:06 * hackage relude 0.1.0 - Custom prelude from Kowainik  http://hackage.haskell.org/package/relude-0.1.0 (shersh)
03:15:48 <srk> I like the idea of http://hackage.haskell.org/package/UISF
03:17:06 <srk> I want to try wrapping https://bitbucket.org/duangle/oui-blendish/ in haskell + some frp lib
03:17:23 <srk> so there's no need for monstrosities like qt/gtk
03:18:21 <pie_> do dear imgui :p
03:19:27 <srk> was poking at that as well
03:57:48 <Adluc> imgui? :D do want
04:17:19 <RyanGlScott> So in the Haddocks for the Applicative class ( https://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#t:Applicative ), it claims that this law:
04:17:21 <RyanGlScott> fmap f x = pure f <*> x
04:17:38 <RyanGlScott> Is a consequence of the laws above it
04:17:51 <RyanGlScott> (i.e., identity, composition, homomorphism, and interchange)
04:18:06 <RyanGlScott> For the life of me, I can't figure out how that's supposed to be a _consequence_, though
04:18:24 <RyanGlScott> Since none of those laws mention fmap at all
04:18:29 <RyanGlScott> Am I missing something?
04:25:46 <verwirrt> hi, i have a bug in a trivial/competitive programming style code that is absolutely driving me crazy. i suppose asking someone here to have a look would be asking too much, but i'll try anyway: http://termbin.com/1rxv . Step-by-stepping in ghci reveals some really confusing execution at one point, as if the top level case in processNeigh function is taking the wrong branch for some reason.
04:26:59 <verwirrt> and the ghci execution: http://termbin.com/w19s
04:27:42 <verwirrt> i suppose i'd have to check the core code that is being generated?
04:52:39 <verwirrt> boy, i don't know how i made that mistake, it was a wrong assumption on my part (i was assuming that a named var in pattern in a case statment doesn't shadow a function argument).
04:56:37 * hackage simple-vec3 0.4.0.8 - Three-dimensional vectors of doubles with basic operations  http://hackage.haskell.org/package/simple-vec3-0.4.0.8 (DmitryDzhus)
05:06:27 <Athas> phadej: the github package is good; thank you for making it.
05:18:25 <ph88> which lib is prefered for randomizing list order shuffle or random-shuffle ?
05:23:37 <dmwit> RyanGlScott: Well, at least liftA2 f x y = f <$> x <*> y mentions it.
05:23:45 <dmwit> I don't know that this answers your question though.
05:23:51 <dmwit> It's possible that parametricity is part of it.
05:23:59 <RyanGlScott> dmwit: Indeed, I can't find a way to contort that fact into the statement of that law.
05:24:10 <ph88> is there a function that combines take and drop into one and gives me back two lists ?
05:24:47 <dmwit> RyanGlScott: Recall from parametricity that proving `pure id <*> x = x` is enough to show that `fmap f x = pure f <*> x`.
05:24:49 <ph88> ah i found it splitAt
05:25:00 <dmwit> RyanGlScott: ...which is indeed a law.
05:25:04 <dmwit> RyanGlScott: So that's probably the trick.
05:26:27 <RyanGlScott> Alright, that's a suitable enough explanation. Thanks.
05:29:08 <lemlen> Hey there, I have a beginner question. Is that appropriate here?
05:29:16 <dmwit> Ask away.
05:29:27 <lemlen> Alright, any recommended paste site?
05:29:44 <dmwit> Not any more. =(
05:29:48 <dmwit> Whichever one is fine.
05:29:51 <lemlen> lpaste is gone huh
05:29:59 <dmwit> yep
05:30:08 <Solonarv> it's gone? since when?
05:30:32 <dmwit> The maintainer asked somebody to step up and take over a few months ago. Nobody did, and in the last few weeks it finally just quietly went offline.
05:31:46 <lemlen> Yeah, shame
05:32:46 <lemlen> As for my question: Just playing around with a simple program to do some food related calculations, and was just wondering how to do this in data types:
05:32:49 <lemlen> https://paste.ofcode.org/vtr8fdGpFN9XaY64SwrdPT
05:34:10 <lemlen> Is there any way to get the pattern matching and constraints on the data type?
05:35:58 <dmwit> Seems like a nice place to use DataKinds.
05:36:04 <dmwit> Let me show you some sample code.
05:41:29 <dmwit> lemlen: https://paste.ofcode.org/TgStdXS3EWc3dz6J4WHvSs
05:41:56 <dmwit> Ouch, something went wrong on line 17. Anyway hopefully the idea is clear.
05:42:02 <lemlen> Cool thanks, let me check it out!
05:42:58 <lemlen> Hmm, some new stuff for me
05:43:12 <arfy> hi all, I've just installed the haskell platform, and i notice that there's .txt files documenting the various libs in the system. How were these generated? I also see corresponding .haddock files, too.
05:43:15 <lemlen> But thanks! I'll try to learn from this :)
05:43:23 <dmwit> Yep. So, taking them from top to bottom, stop me when you get really confused.
05:43:49 <dmwit> DataKinds -- just like `data Foo = Bar` used to define a new type named `Foo` and a new computation named `Bar`, it now also defines a new kind named `Foo` and a new type named `Bar`.
05:44:39 <dmwit> TypeApplications -- for polymorphic things like `forall a. ...`, you can pick what type to instantiate `a` at using the "type application" syntax -- which is an `@` followed by a type.
05:44:48 <lemlen> Ah, so with that it's possible to use Bar as a type?
05:44:56 <dmwit> right
05:45:33 <dmwit> AllowAmbiguousTypes -- this and TypeApplications are two great tastes that taste great together. for polymorphic things like `forall a. ...`, the body of the implementation of the thing of that type can mention the type `a` and have it be in scope
05:45:37 <dmwit> whoops
05:45:43 <dmwit> That's ScopedTypeVariables. Ouch!
05:46:17 <lemlen> Haha, got it
05:46:28 <dmwit> AllowAmbiguousTypes -- normally, in a type like `forall a. ...`, the `...` must mention `a` somewhere for obvious reasons. This extension relaxes that rule, which is handy for our `macro :: Macro a => Double`, which doesn't mention `a` in `Double`
05:46:52 <dmwit> (One then needs `TypeApplications` to be able to use terms of these ambiguous types.)
05:47:53 <dmwit> KindSignatures -- just like `foo :: Bar` can be used to declare that the computation `foo` has type `Bar` in the computation language, you can now write `foo :: Bar` at the type level to mean that type `foo` has kind `Bar`
05:47:56 <ph88> does anyone know some functions for shift elements left/right in a list so they come back at the end ? (rotate) ?
05:48:15 <dmwit> ph88: splitAt and (++) is the way I usually use
05:48:31 <dmwit> lemlen: I think that's all of them.
05:49:02 <lemlen> dmwit: Pretty much, yeah. You really went above and beyond, thank you very much. Now I have some poking around and learning to do.
05:49:05 <dmwit> Some day I'd love a "meta" LANGUAGE pragma that gave us AAT, STV, and TA all at once.
05:49:31 <dmwit> lemlen: Sure. The GHC manual has much more detailed explanations of each extension, and feel free to ask about any particular part of the code I pasted here, too.
05:49:58 <lemlen> dmwit: Definitely checking it out. Thank you very much!
05:56:16 <ph88> is this the right way to pattern match on the non-empty list when i don't care about the contents ?  (_:_)
05:57:25 <dmwit> Looks right to me.
05:59:17 <lavalike> how can one use Data.Binary to write out smaller bit sequences than Word8 at a time?
06:01:31 <dmwit> You're probably going to have to code up something yourself that groups bits together into chunks of 8.
06:01:46 <dmwit> Might not even be worth reusing the Data.Binary machinery at all depending on how pervasive that need is.
06:01:54 <lavalike> sad face
06:03:12 <ph88> what function can i use to check if all the elements of list a are also in list b ?
06:03:54 <dmwit> (\\), perhaps, but converting to Data.Set.Set first and using isSubsetOf or whatever will likely be faster.
06:04:17 <dmwit> If you need to consider multiplicity, too, there is a multiset package on Hackage.
06:04:34 <lemmih> ph88: all . elem ?
06:06:38 <lemmih> @type \a b -> all (`elem` b) a
06:06:39 <lambdabot> (Eq a, Foldable t2, Foldable t1) => t1 a -> t2 a -> Bool
06:07:55 <Athas> I have a Text value that is base64-encoded.  I want to decode it.  What is the easiest way to do this?
06:08:03 <Athas> The decoders I can find all operate on bytestrings (or worse, Strings).
06:08:32 <dmwit> utf8-encode the Text to a ByteString?
06:09:05 <dmwit> Do you want the programmer-efficient thing or the runtime-efficient thing? Is this *really* going to be a bottleneck for your app?
06:09:19 <Athas> No, but it feels ridiculous to have to re-encode it.
06:47:12 <dmwit> ?tell lemlen While in the shower, it occurred to me that you might like to compare a version of the code that doesn't require any extensions at all.
06:47:12 <lambdabot> Consider it noted.
06:47:43 <dmwit> ?tell lemlen In case you forgot, here's the lots-of-extensions version: https://paste.ofcode.org/TgStdXS3EWc3dz6J4WHvSs And here's the extension-free version: https://paste.ofcode.org/DbHUvXpTFkMLagsxc2jdyQ
06:47:43 <lambdabot> Consider it noted.
06:49:04 <dmwit> ?tell lemlen The version with extensions has two main advantages. First, `Energy Int`, which is kind of nonsensical, is fine in the non-extended version but a kind error in the extended version. Second, the non-extended version has proxies floating around at runtime purely to inform the type system of things, whereas the type argument information in the extended version is completely erased at runtime.
06:49:04 <lambdabot> Consider it noted.
06:50:47 <c50a326> does currying happen in a particular direction? e.g. `subtract a b = a - b`, `subtract 1 2` is reduced to `subtract x = x - 2` or `subtract x = 1 - x` or what?
06:51:44 <handyandy> hello
06:51:46 <c50a326> ah the arrows associate to the right
06:52:02 <monoidal> c50a326: If subtract a b = a - b, then "subtract 2" is obtained by substituting a = 2
06:52:07 <handyandy> i am having trouble creating a function that parses a UTC time.  I am able to do the following in ghci:
06:52:33 <handyandy> Data.Time.Format..parseTimeM True F.defaultTimeLocale "%0Y-%m-%dT%H:%M:%S%Q" "2010-03-04T01:07:45.6" :: Maybe Data.Time.UTCTime
06:52:48 <handyandy> Data.TimeFormat..parseTimeM True F.defaultTimeLocale "%0Y-%m-%dT%H:%M:%S%Q" "2010-03-04T01:07:45.6" :: Maybe Data.Time.UTCTime
06:53:17 <handyandy> Data.Time.Format.parseTimeM True F.defaultTimeLocale "%0Y-%m-%dT%H:%M:%S%Q" "2010-03-04T01:07:45.6" :: Maybe Data.Time.UTCTime
06:53:23 <handyandy> there that last one is what I am doing
06:53:53 <handyandy> however I would like to turn it into a function that takes a string and returns a Maybe Data.Time.UTCTime
06:55:45 <handyandy> and I'm not sure how to handle the monad type constraint on it
06:57:41 <handyandy> darn, here is what I am using in ghci:
06:57:45 <handyandy> Data.Time.Format.parseTimeM True Data.Time.Format.defaultTimeLocale "%0Y-%m-%dT%H:%M:%S%Q" "2010-03-04T01:07:45.6" :: Maybe Data.Time.UTCTime
06:58:38 <c50a326> :t Data.Time.Format.parseTimeM
06:58:40 <lambdabot> (time-1.8.0.2:Data.Time.Format.Parse.ParseTime t, Monad m) => Bool -> time-1.8.0.2:Data.Time.Format.Locale.TimeLocale -> String -> String -> m t
06:59:29 <handyandy> hi c50a326, I'm not sure how that type constraint works
06:59:56 <handyandy> I've got the Bool, TimeLocal and format string
07:00:10 <handyandy> but I'm not sure how to force the function to be a Maybe monad, if that is the right way to say it
07:00:53 <iqubic> handyandy: What are you trying to do?
07:01:05 <handyandy> i am trying to parse a UTCTime using parsec
07:01:25 <handyandy> there isn't a standard combinator for it, so I was going to create my own function that takes a string and returns a Maybe UTCTime
07:02:07 <handyandy> i found the parseTimeM function, but the type signature is beyond my limited skills
07:03:40 <monoidal> handyandy: You can define a special case, e.g. myParseTime :: String -> Maybe UTCTime; myParseTime = parseTimeM True F.defaultTimeLocale "%0Y-%m-%dT%H:%M:%S%Q"
07:03:50 <c50a326> I am also a noob but trying to understand the problem :D
07:05:47 <handyandy> hi monoidal, thanks... your suggestion seems to work:
07:06:01 <handyandy> myParseTime :: String -> Maybe Data.Time.UTCTime; myParseTime = Data.Time.Format.parseTimeM True Data.Time.Format.defaultTimeLocale "%0Y-%m-%dT%H:%M:%S%Q"
07:06:15 <handyandy> :t myParseTime
07:06:16 <lambdabot> error: Variable not in scope: myParseTime
07:06:28 <handyandy> myParseTime :: String -> Maybe Data.Time.UTCTime
07:07:01 <handyandy> so just by giving the function a type declaration the compiler is able to resolve that monad constraint?
07:08:17 <c50a326> Maybe is a Monad :D
07:08:34 <c50a326> :i Maybe
07:09:31 <monoidal> If you don't give the type signature, you can use 'myParseTime' on monads other than maybe
07:10:14 <handyandy> oh so for the "m" in the type signature the type constraint is just saying that whatever "m" you put there has to be a monad
07:10:30 <monoidal> yes
07:10:46 <c50a326> Either is also a monad and sounds like it would be an option for error handling either
07:10:51 <monoidal> you can also say myParseTime :: Monad m => String -> m Data.Time.UTCTime
07:11:07 <c50a326> s/either$/also/
07:11:20 <handyandy> ok thanks to both of you
07:11:45 <c50a326> I wonder how it would be to use the IO monad there :o
07:12:13 <lavalike> dmwit: re binary encoding bit by bit, I found this one, pretty happy with it! http://hackage.haskell.org/package/binary-strict-0.4.8.3/docs/Data-Binary-BitBuilder.html
07:12:13 <handyandy> hmm
07:12:53 <lavalike> :t error
07:12:54 <lambdabot> [Char] -> a
07:13:03 <lavalike> hmm now what's it called again
07:13:21 <lavalike> :t fail
07:13:22 <lambdabot> Monad m => String -> m a
07:13:39 <lavalike> c50a326: there it is, if you used m = IO there, the fail method would raise an exception in IO
07:14:11 <lavalike> (instead it returns Nothing for Maybe, and returns Left whatever for Either)
07:15:41 <hololeap> is there any advantage to using the Word8 version of ByteString over the Char8 version?
07:16:15 <lavalike> hololeap: the Char8 version is meant for printable characters I guess, Word8 instead is arbitrary binary data
07:17:11 <hololeap> i guess a better question would be: is there any real difference between Char8 and Word8?
07:18:12 <cocreature> the Char8 version is a lie. it will silently truncate things
07:18:33 <lavalike> rude!
07:18:34 <cocreature> also note that it’s the same type. the difference is the API to operate on that type
07:19:31 <hololeap> cocreature: what do you mean by silently truncate things?
07:19:59 <hololeap> can you give an example?
07:20:03 <cocreature> hololeap: all Char values will be truncated to 8bits
07:20:16 <cocreature> so if you have a non-ascii char somewhere things will break badly
07:20:54 <int-e> > BSC.pack "АБВ"
07:20:56 <lambdabot>  "\DLE\DC1\DC2"
07:21:14 <int-e> > BSC.pack "äöü"
07:21:15 <lambdabot>  "\228\246\252"
07:21:56 <int-e> (iso8859-1 (aka latin1) is covered)
07:24:49 <hololeap> ok, then what's the best way to convert a Word8 ByteString to a String?
07:30:14 <hololeap> got it: decodeUtf8
07:30:15 <c50a326> a Word8 ByteString?
07:31:33 <c50a326> https://www.haskell.org/hoogle/?hoogle=ByteString+-%3E+String there are these
07:38:55 <c50a326> "It can be said that arrows in the types notation associate to the right, so that f :: a -> b -> c is really f :: a -> (b -> c). Functional application though, associates to the left: f x y is really (f x) y." -- https://wiki.haskell.org/Currying
07:39:23 <c50a326> what is the point of type notation associating from the right if function application associates from the left?
07:41:27 <hpc> c50a326: suppose you have f :: a -> b -> c -> d -> e -> f
07:41:36 <hpc> c50a326: you would use it by writing f a b c d e f
07:41:47 <c50a326> only up to e, right?
07:41:54 <hpc> and they have to associate in opposite directions in order for you to do that without parens
07:41:56 <c50a326> f is the output?
07:42:00 <hpc> er, right
07:42:09 <hpc> point is, no parens
07:42:11 <c50a326> also not good to use f twice xD
07:42:17 <hpc> :P
07:42:56 <hpc> this is a good thing to try working out for yourself
07:42:57 <c50a326> it says div 10 5 is actually like `(\x -> 10 `div` x) 5` iiuc
07:43:13 <c50a326> the type sig is like a -> b -> c basically
07:43:42 <c50a326> the actual currying looks to me like... well I guess like b -> (a -> c) if anything
07:43:49 <c50a326> but maybe I'm thinking about that wrong actually
07:43:55 <c50a326> 10 -> 5 -> 2
07:44:08 <c50a326> 5 -> 2
07:44:16 <c50a326> oh hmmm
07:44:26 <hpc> the innermost function application corresponds to the outermost type parameter
07:44:48 <c50a326> oh so type sigs are usually "backwards" compared to they first appear?
07:44:54 <c50a326> :t div
07:44:55 <lambdabot> Integral a => a -> a -> a
07:45:08 <c50a326> so the 2nd a is actually the first argument we would pass to div?
07:45:11 <c50a326> > div 2 1
07:45:13 <lambdabot>  2
07:45:25 <c50a326> 2 is the 2nd a, the first a is 1, here?
07:46:05 <c50a326> there's a kind of mirrory, snakey relationship between the type associativity and the function application associativity?
07:46:21 <infinisil> c50a326: Suppose function types associate from the left:
07:46:40 <infinisil> f :: a -> b -> c -> d    means    f :: ((a -> b) -> c) -> d
07:47:02 <infinisil> So, when you do `f x`, that x needs to be of type `((a -> b) -> c)`
07:47:29 <infinisil> Which is probably not what was intended
07:47:31 <c50a326> oh so then it wouldn't work
07:47:55 <infinisil> To pass multiple args (which is desired most of the time) you'd have to use `f :: a -> (b -> (c -> d))`
07:47:59 <infinisil> Which is very inconvenient
07:48:20 <infinisil> It makes sense for it to be this way
07:49:44 <infinisil> OH also: f = f  ::  a -> b -> c -> d = a -> (b -> (c -> d))
07:49:45 <c50a326> yeah I get it, thanks both :D
07:50:04 <infinisil> f x = f x :: b -> c -> d = b -> (c -> d)
07:50:17 <infinisil> f x y = (f x) y :: c -> d = c -> d
07:50:25 <c50a326> can you write the same things using lambda calculus notation? well not for so many args but for `div` might be nice
07:50:34 <infinisil> f x y z = ((f x) y) z :: d = d
07:50:42 <infinisil> It strips the brackets from left to right if you will :P
07:51:34 <c50a326> ah actually I don't understand your use of the = sign here^^
07:52:07 <c50a326> but actually I have to run, thanks though, bbl!
07:52:17 <infinisil> = means "writing out brackets"
07:52:46 <infinisil> I should've inverted the left sides though, so ((f x) y) z = f x y z :: d = d   in the last one
07:53:13 <infinisil> And f = f :: a -> b -> c -> d = a -> (b -> (c -> d)) in the first
07:53:28 <infinisil> It's symmetrical in a way
07:56:37 * hackage nix-diff 1.0.4 - Explain why two Nix derivations differ  http://hackage.haskell.org/package/nix-diff-1.0.4 (GabrielGonzalez)
08:00:13 <hpc> ooh that's a pretty neat package
08:10:40 <orbisvicis> so according to wikipedia bottom is a type without value but according to https://en.wikibooks.org/wiki/Haskell/Denotational_semantics bottom is a type with an undefined value, but b/c it is still a value it lifts all other values to include bottom, and then shows that by matching against bottom this can be used to solve the halting problem, and introduces additional notation specifying "definedness"
08:12:30 <orbisvicis> so this seems like a very roundabout approach and I'm wondering if it is possible to still lift haskell types to include bottom without actually giving bottom a value
08:12:55 <glguy> There's no literal "bottom value"
08:14:28 <glguy> The language allows us to write values whose evaluation results in nontermination or which throws exceptions. We lump all of these cases into the denotation "bottom"
08:19:46 <monochrom> The wikibook is wrong. There is no bottom type either.
08:21:53 <monochrom> This is what's wrong with "crowd-edited sources". A person "contributes" to it because they are vocal, not because they are right.
08:23:24 <orbisvicis> glguy: I know it means those things, but that article is trying to formalize that concept using bottom values + definedness. I'm wondering if it is (a) wrong (b) right, but possible to do so without involving values, i.e. subtyping
08:23:29 <marvin2> where does wikibook say that bottom is a type?
08:25:07 <orbisvicis> actually only wikipedia says that, the wikibook says bottom is a value of all types, ie type: forall a . a
08:25:26 <monochrom> "bottom values + definedness" is redundant.  It simplifies to "definedness".
08:27:48 <orbisvicis> ok, I'll keep reading
08:28:05 <monochrom> And in Haskell you can have this non-collapsable chain "bottom < bottom:bottom < bottom:bottom:bottom < ..." so it is always more meaningful to compare the relative [un]definedness of two things.
08:29:22 <monochrom> As opposed to most other languages that say "you have a list, or you don't" and could benefit from a simple dichotomy of undefined vs defined.
08:30:36 <monochrom> You cannot get rid of bottoms with a Turing-complete language.
08:32:14 <monochrom> You cannot get rid of values because the question "will you get an answer? what answer will you get?" is about values.
08:32:35 <monochrom> But you can always get rid of subtyping. Good riddance.
08:33:51 <monochrom> (Bonus point for pointing out a commonly committed redundancy in my second last sentence.)
08:34:28 <dstolfa> monochrom: i like that description of wikipedia
08:34:54 <orbisvicis> dstolfa: ironically it also applies to here
08:35:26 <dstolfa> orbisvicis: i mean, it applies almost everywhere right? :)
08:42:46 <orbisvicis> monochrom: commonly committed redundancy? As in 'will you get an answer' is always maybe b/c you can't get rid of bottoms ?
08:43:17 <monochrom> Yes.
08:44:01 <monochrom> "Will you come? If so, when will you come?" can be simplified to "Will you come?" and allow the possibility "never".
08:44:15 <monochrom> Err, no I wrote it wrong.
08:44:27 <monochrom> can be simplified to "when will you come?" and allow "never".
08:44:39 <c50a326> monochrom: the wiki book is awesome and wikipedia is awesome, wtf
08:45:00 <monochrom> And so in denotational semantics you just have to ask "What is the answer?" and allow "undefined".
08:45:17 <c50a326> monochrom: crowd edited sources = you can go edit it if it's wrong... o_o
08:45:39 <monochrom> c50a326 you are selective-biasing on the awesome parts of them. Don't get me wrong, I use their awesome parts all the time too.
08:46:03 <c50a326> monochrom: but your argument is so redundant I'm in shock... "this is the problem with crowd-edited sources..." lol... wtaf...
08:46:03 <monochrom> Also I donate $10 to wikipedia every year.
08:46:24 <c50a326> go edit when you see an error, don't whine about the system, it's the best we have imo
08:46:46 <monochrom> Yes let me up the game a little bit. How many people here donated money to wikipedia, ever?
08:46:56 <c50a326> yeah I did
08:47:11 <c50a326> I don't see what that has to do with it
08:47:22 <c50a326> anyway, no point arguing, you just triggered me, sorry :p
08:48:12 * [exa] does, around $30 yearly
08:48:46 <[exa]> it's worth it just for the feeling of well invested money :D
08:49:13 <lavalike> mniip: how's the tournament going for you?
08:50:12 <[exa]> c50a326: anyway how was the barendregt book?
08:51:05 <mniip> lavalike, everything is on fire?
08:51:09 <lavalike> mniip: indeed!
08:51:54 <monochrom> c50a326: Maybe that's exactly what I should do when I'm finally unemployed. Spend all of my day deleting incorrect things on wiki-anything.
08:52:33 <c50a326> [exa]: well all I've done today so far is set up my compose key so i can type λ and ask questions about λcalc in this way :p
08:52:59 <[exa]> steady progress, yay!
08:53:48 <c50a326> but actually I do have a question, something that's bothering me is the two differing introductions to lambda calculus. Here is one from Wadler in a presentation: https://i.imgur.com/SxhDK3N.png and then the barendregt text starts with reduction...
08:54:50 <c50a326> actually I also made sense of λx.x today... which is just like `\x -> x` right?
08:54:55 <[exa]> yeah
08:55:10 <c50a326> well no, actually, I'm not sure if it's like "this is how to write a function that takes something and returns something"
08:55:15 <monochrom> Does Wadler have slides showing reduction rules after?
08:55:15 <c50a326> I mean, is it saying anything about types, or no?
08:55:32 <monochrom> No.
08:55:48 <infinisil> There ain't no types in lambda calculus :)
08:55:52 <c50a326> natural deduction, is that the same thing?
08:55:58 <monochrom> No.
08:56:01 <c50a326> infinisil: not in "simply typed" lc?
08:56:18 <monochrom> But you are not reading simply-typed lambda calculus.
08:56:22 <infinisil> Okay basic lambda calculus doesn't say anything about types, you can extend it to have them of course
08:56:53 <c50a326> so it's not even good to think of x as "ooo maybe an integer" it's better to just think of it as "thing" ?
08:57:00 <infinisil> Ye
08:57:28 <infinisil> The only thing you could pass to it are lambdas actually :P
08:57:52 <monochrom> At this point you have barebone lambda calculus so x can only be yet another lambda term.
08:58:03 <c50a326> wait what...
08:58:06 <glguy> c50a326: In the slide you show there are only three cases, a variable, a lambda expression, and the appliation of one term to another
08:58:08 <glguy> that's *it*
08:58:14 <[exa]> c50a326: the thing on wadler slides is a language for writing λ-expressions. Reduction is what takes λ-expressions and makes them actually "compute". Natural deduction is the logical system with long horizontal lines that is usually used to describe λ-calculus-related stuff, including type systems.
08:58:25 <c50a326> glguy: I still need to understand L, M, N first
08:58:27 <glguy> there's no integer in the language, just variables, lambdas, and applications
08:58:31 <infinisil> It's a bit mind boggling to understand how lambdas can be any useful and even turing complete
08:59:10 <monochrom> Think of one of those Zotac barebone computers or Intel's NUC, which clearly state "this doesn't come with RAM or disk".  You are reading a lambda calculus that is even more barebone than that.  Batteries and data types not included.
08:59:24 <glguy> c50a326: L M N don't matter, those are just 3 different names for the same prodution in the grammar
08:59:40 <[exa]> c50a326: think of L,M,N as shortcuts for stuff after := (I would say variables but these are not variable)
08:59:42 <c50a326> production? what do you mean production?
09:00:09 <glguy> https://en.wikipedia.org/wiki/Production_(computer_science)
09:00:29 <glguy> The language is defined by those three "productions", rules for substitution that define the grammar
09:00:34 <monochrom> Yeah with real BNF you write <L> ::= <var> | ( lambda <var> . <L>) | ( <L> <L> )
09:00:47 <infinisil> data Term = Variable String | Lambda String Term | App Term Term
09:00:52 <infinisil> c50a326: Like that in Haskell ^^
09:00:56 <[exa]> c50a326: my personal favorite writing of that thing is Λ := a | b | c | ... | ΛΛ | (λx.Λ)     -- it's a grammar that defines how all expressions of the language look like
09:02:47 <monochrom> What you're seeing is a bunch of mathematicians writing down something that makes sense to them but confuses the rest of us.
09:03:52 <monochrom> You need to remember that mathematicians work on the "you know what I mean" basis.
09:05:09 <infinisil> "Left as an exercise to the reader"
09:05:17 <infinisil> "Trivially it follows that.."
09:05:21 <glguy> Fortunately people love exercises
09:05:39 <infinisil> Wait I saw an article about that recently
09:06:49 <infinisil> They don't get any moneys or so from posting solutions, so most just don't do it
09:07:15 <c50a326> well it's nice that #haskell is full of mathematically competent folk at least :) ##math is too busy and without a good IRC channel it's very difficult to self-study such things I think.
09:07:16 <infinisil> And the few that do get praised for doing it, because having the solutions can really help
09:10:30 <kuribas> is it possible to do compile time computation on type level strings (symbols)?
09:10:45 <monochrom> No.
09:11:00 <monochrom> But yes if you modify GHC.
09:11:05 <kuribas> not with template haskell?
09:11:22 <kuribas> there's only append...
09:16:13 <orbisvicis> monochrom: that said (way back), if using subtyping, is it possible to consider bottom a type without any values - or is wikipedia just wrong?
09:19:17 <c_wraith> just be careful not to conflate two different botttoms.  There is a bottom type in a type lattice created by subtyping.  There is also a bottom at the value level used to indicate values that never can be examined.
09:19:42 <Solonarv> kuribas: if you're using TH, you can do whatever you want with Symbol's; TH operates on the syntax tree
09:20:26 <glguy> Whatever you want as long as what you want isn't access to the typechecker
09:22:01 <Solonarv> there might be a ghc plugin somewhere that lets you manipulate Symbol
09:22:04 <c_wraith> you can also use a type checker plugin to work with types while compiling
09:22:16 <c_wraith> ghc is really extensible via plugins these days
09:23:24 <kuribas> glguy: I want to access a field by name, like in generic-lens, but first rewrite it.
09:24:50 <kuribas> The symbol is accessed from Generic, so wouldn't it be possible to rewrite it with TH?
09:25:25 <Solonarv> I don't think so
09:25:33 <Solonarv> I found this: https://github.com/konn/ghc-typelits-symbols
09:25:42 <glguy> It might be worth reconsidering what you're trying to do
09:25:46 <Solonarv> but the last commit was 2yrs ago, and it isn't on hackage
09:26:15 <kuribas> glguy: yeah, it was just an idea, maybe I'll take another approach
09:26:20 <c_wraith> what does singletons do with Strings?  It doesn't use Symbol, does it?
09:27:35 <glguy> GHC has hardcoded magic to related Symbols and Strings for knownSymbol
09:27:43 <c_wraith> Huh.  looks like singletons does use String
09:27:48 <c_wraith> Err, Symbol
09:28:03 <c50a326> [exa]: in the paper it says that the rewrite rules for append and sort can be programmed easily, and I guess this is true to some extent, in haskell I think append is: append a (x:xs) = a : append x xs
09:28:19 <c50a326> [exa]: but in this notation they're using and with lambda calculus, I wouldn't know how to write append
09:28:37 <c50a326> (skipped the exit case for brevity)
09:29:03 <glguy> c50a326: What you wrote isn't the normal "append of two lists" fwiw
09:29:19 <c50a326> well in any case without the two : tools I'd be lost
09:29:59 <c50a326> oh yeah they're appending a list to a list, not an element to a list
09:30:52 <[exa]> c50a326: well in λcalculus you first need a way to create the : pair, which is tricky at best
09:31:23 <[exa]> c50a326: and then you need fixpoint... :]
09:31:38 <[exa]> c50a326: strongly suggest you don't do any serious programming in pure lambda calculus
09:32:22 <c50a326> "The necessary rewrite rules for append and sort can be programmed easily
09:32:24 <c50a326> in a few lines."
09:32:28 <c50a326> D:
09:32:32 <[exa]> where do you read that?
09:32:41 <[exa]> there are many meanings of "rewrite rules"
09:32:47 <c50a326> page 6 of the paper
09:33:00 <kuribas> [exa] use unlambda
09:33:46 <[exa]> c50a326: oh so, that's for symbolic computation with various stuff, that's not pure lambda calculus
09:33:52 <[exa]> c50a326: in that case you basically nailed it
09:34:52 <[exa]> kuribas: oh noes
09:35:22 <c50a326> well is `head` easy to write in λcalc?
09:35:46 <c_wraith> depends on how you are representing lists
09:36:03 <c50a326> how do you represent a list?
09:36:07 <c_wraith> though come to think of it, head is pretty easy with both church and scott encodings.
09:36:27 <[exa]> if you're using the standard pairs to do that then iirc head = (λl.lK)
09:36:50 <c50a326> I guess I can continue reading the paper at this point at least
09:37:01 <[exa]> where K is the usual K = (λxy.x) that you'll probably see soon
09:37:04 <[exa]> yeah
09:40:40 <[exa]> c_wraith: scott encoding is the one with constructors and pattern-cases?
09:42:41 <c50a326> "It is remarkable that although (β) is the only essential axiom of the λ-calculus, the resulting theory is rather involved." what is the ß thing?
09:43:01 <c50a326> ... which is apparently slightly different to the german character I knew how to print
09:43:15 <[exa]> beta
09:43:48 <c50a326> beta is the only essential axiom of lambda calculus... o_o
09:44:01 <[exa]> you'll probably meet more greek as well, this helps for pronouncation: https://en.wikipedia.org/wiki/Greek_alphabet#Letters
09:44:14 <[exa]> yeah well that's the rule that computes most of haskell
09:44:28 <c_wraith> [exa]: scott encoding is the infinite type.  list would be newtype ScottList a = SL (forall r. r -> (a -> ScottList a -> r) -> r)
09:45:47 <c50a326> beta means variable?
09:46:06 * hackage servant-snap 0.8.2 - A family of combinators for defining webservices APIs and serving them  http://hackage.haskell.org/package/servant-snap-0.8.2 (imalsogreg)
09:46:08 <c_wraith> [exa]: the Church encoding requires doing the entire fold at once.  the Scott encoding allows you to control how far you recurse
09:46:10 <c50a326> or just "thing" maybe?
09:46:15 <c_wraith> c50a326: beta means "second"
09:46:25 <[exa]> c50a326: beta is just a letter that's used to mark the reduction rule, in english it would be B-reduction
09:46:28 <c_wraith> as it's the second letter of the greek alphabet
09:46:43 <c_wraith> there's an alpha rule in lambda calculus, too
09:46:48 <c_wraith> But it's a lot less interesting
09:47:05 <c_wraith> It's just "you can rename things to get equivalent things, as long as you do it right"
09:47:19 <c_wraith> The beta rule is the evaluation mechanism
09:47:20 <c50a326> ohhhh beta is: (λx.M)N = M[x := N]
09:47:47 <c50a326> I didn't realise it was making that definition of beta, there's a beta on the far right of this that I didn't see
09:49:25 <[exa]> c50a326: I don't know if they have the substitution notation explained there, M[x:=N] means "M where all free occurrences of variable x are replaced by N"
09:52:12 <runit> hi. is ghcjs still actively "maintained"? how's full stack haskell looking?
09:52:47 <[exa]> github commits say no (sadly)
09:53:00 <runit> well, there's an 8.x branch on the ghcjs github
09:53:12 <runit> but i have no idea, ya
09:53:39 <[exa]> oh yes that looks better
09:54:21 <c_wraith> it is maintained, but not by enough people to really keep up
09:54:57 <runit> i have some old app i want to revive/finish, used ghc 7.10.x & ghcjs
09:55:17 <c50a326> so are lambda calculus and the turing machine two fundamentally different approaches/solutions to the same problem?
09:56:28 <c_wraith> c50a326: yes.
09:56:42 <mjrosenb> was everyone kicked a week or so ago?
09:56:53 <c_wraith> mjrosenb: I think a bit longer than that now, but yes
09:56:55 <mjrosenb> or, june 29th.
09:57:05 <c50a326> and are all computer processors written like turing machines? would it be possible to write a processor that is more like lambda calculus/haskell?
09:57:08 <c_wraith> mjrosenb: the topic still mentions it
09:57:31 <mjrosenb> c_wraith: the topic is very long :-p
09:57:34 <hpc> c50a326: both are just theoretical constructs
09:57:48 <hpc> processors use a totally different model
09:57:53 <c50a326> oh right
09:57:53 <c_wraith> c50a326: computers these days are closest to von neumann machines
09:58:00 <[exa]> c50a326: well cpus are optically closer to turing machines, but not even remotely that close that the difference would be significant from the cpu point of view
09:58:01 <jmcarthur> c50a326: There isn't even such a thing as turing complete hardware.
09:58:09 <hpc> each model translates to each other model
09:58:16 <hpc> so you pick the one that's most useful for what you're doing
09:58:54 <hpc> if you're thinking about something in a more FP kind of way, you use lambda calculus
09:59:04 <mjrosenb> von neumann machines don't really fall into the same category as lambda calculus and turing machines
09:59:06 <hpc> if you're thinking about something in terms of state machines, you use turing machines
09:59:51 <mniip> lavalike, we made our lightning division solver work at '59...
09:59:54 <jmcarthur> hpc: I'm not sure I've ever used a turing machine to help me think about state machines.
10:00:03 <mjrosenb> since von neumann came up with his plan based on physical hardware that already existed, as a method to make it easier to actually use a computer, as opposed to a theoretical model for proving properties of calculations.
10:00:10 <mniip> could only solve so much in the remaining time...
10:00:11 <lavalike> mniip: wee!
10:00:26 <lavalike> it was hard
10:00:45 <jmcarthur> I think of turing machines as sufficient for things one might want to prove about computability, but not as useful for thinking about algorithms and such.
10:00:48 <mjrosenb> oh rihgt, icfp contest is on.  this years actually looked good :-(
10:00:56 <hpc> ah, that's a better way of putting it
10:01:14 <mniip> lavalike, we had a beautiful algorithm and no time to implement it :(
10:01:23 <mniip> sadly it's mostly irrelevant in the full division
10:01:32 <lavalike> mniip: oh man.
10:01:35 <mniip> because you can woosh entire cubouts in an out of existence
10:01:39 <mniip> cuboids*
10:01:45 <hpc> mniip: your margin was too small to contain it
10:02:04 <c_wraith> yeah..  Turing machines are a convenient way to demonstrate that some algorithms are non-computable, and to give an example of one (the busy beaver function)
10:02:14 <c_wraith> They're not a convenient model of actually *doing* computation
10:03:27 <srid> How easy is it to create a version of `embedDir` (from file-embed) that retains files-list but ignores their content?
10:03:45 <mjrosenb> c_wraith: and for showing that a computation system is turing complete.
10:12:34 <sternmull> there is no language extension to allow trailing commas in data definitions (and maybe elsewhere), right?
10:14:27 <mjrosenb> that would almost certainly not play well with tuple sections.
10:14:49 <mjrosenb> which *looks* similar.
10:15:28 <hpc> if it was only for records and arrays maybe
10:15:29 <Berra> I'm using "extensible" for Records - currently I'm also using it with "singletons" Apply IdSym0 / Apply (TyCon1 Maybe). I wonder is there isn't some better preferred way provided by extensible already - to map the types of the Record - seems like that should be possible?
10:15:34 <hpc> er, lists
10:15:52 <srid> not difficult at all it seems https://www.irccloud.com/pastebin/PF6zhDHD/
10:17:33 <mjrosenb> tuple sections on lists would be pretty funny.
10:18:12 <mjrosenb> but I think that having a situation where a trailing comma has a very different meaning depending if it is in a list or in a tuple would be super bad.
10:18:14 <lukelau> Does stack support .cabal files with more than one library?
10:19:11 <mjrosenb> lukelau: you mean with local libraries?
10:19:13 <hpc> lukelau: what would that look like when used?
10:19:22 <lukelau> Yes local libraries sorry
10:19:23 <hpc> one cabal file for multiple packages?
10:19:45 <lukelau> hpc: Yeah, with cabal-version: >= 2.0
10:19:55 <lukelau> So library: … and library my-second-library: ...
10:21:00 <mjrosenb> I've found that even cabal's support of local-libraries is... lacking.
10:21:09 <lukelau> The second library is only used by the tests
10:21:23 <lukelau> But the main library/executable don’t includ eit
10:21:31 <mjrosenb> and by cabal, I think I mean cabal-install but that is probably due to a limitation of the cabal library.
10:22:03 <lukelau> On stack, it tries to register the library with build but doesn’t actually compile it:
10:22:31 <lukelau> https://gist.github.com/Bubba/7658f604979e4da9a9eb68d2c3f4bcfa
10:23:22 <lukelau> However, after running `stack test`, `stack build` is able to register it fine
10:27:29 <mjrosenb> fwiw, my issue with local libraries has been that cabal-install just ignores its dependencies, and only uses the dependencies of the executable that is including that local library
10:28:29 <mjrosenb> and 50% of the reason that I wanted local libraries was to avoid including the same library in every single executable
10:30:23 <glguy> mjrosenb: Is there an issue ticket associated to that behavior?
10:30:57 <mjrosenb> glguy: not yet.  Where should I file one?
10:31:23 <mjrosenb> I'll also try to reproduce it on a system that is more sane than my nutso arch/nix desktop.
10:34:44 <glguy> mjrosenb: What you said doesn't match my experience trying it out just now
10:35:14 <mjrosenb> glguy: interesting.
10:35:20 * mjrosenb tries again
10:39:50 <mjrosenb> glguy: hrmm, I am also not able to reproduce right now.  perhaps cabal has been upgraded recently
10:43:07 * hackage path-io 1.4.0 - Interface to ‘directory’ package for users of ‘path’  http://hackage.haskell.org/package/path-io-1.4.0 (mrkkrp)
11:00:41 <runit> anyone have any idea what's going on here? trying to reboot an old project using yesod, persistent, etc.. something about serversession-backend-persistent keeps breaking: https://hastebin.com/opiwomolel.cpp
11:01:13 <runit> ghc 7.10.3 etc
11:02:58 <runit> updated it to 1.0.4 instead of 1.0.3, might have fixed it
11:29:50 <sternmull> is there a typeclass for things from which i can extract a "key" for comparision/ordering? I have a bunch of data definitions that all have Eq and Ord defined in terms of extracting and comparing some fields. I bet i am not the first one who does this...
11:32:32 <[exa]> sternmull: like a "polymorphic" Ord? anyway, I guess there are multiple possible orderings for your data?
11:32:47 <lyxia> there might be something to do using "Arg" in base.
11:33:31 <sternmull> i only want to define Ord so i can put my values in Data.Set and similar.
11:33:44 <geekosaur> not presently but it's been discussed
11:35:20 <sternmull> For now i create myDataKey x = (fieldA x, fieldB x, ...) and then define Eq and Ord by using the myDataKey functions. But this looks a bit stupid. So i hoped there is a more generic way to do this.
11:36:12 <[exa]> why not just use deriving?
11:36:25 <sternmull> because the ordering depends only on some fields
11:36:56 <[exa]> oh so, AlmostOrd. :]
11:37:24 <[exa]> why not use a newtype wrapper for that? like Sum/Product wrappers for numeric monoids?
11:38:14 <sternmull> I don't think so. Its just that my ordering only depends on a part of the value. For example a value can have a unique name (which i want to use for Ord) and a list of some stuff (which is irrelevant for the ordering).
11:38:17 <[exa]> I'd highly suggest keeping Ord instances surprise-less unless there's the wrapper that visibly marks only partial ordering
11:39:11 <[exa]> also, why not use that unique name as a key?
11:39:41 <sternmull> thats what i do, but sometimes there are two or three fields that make up the key, so i build a tuple from them
11:40:33 <solrize> is there a standard way of writing type signatures involving abstract datatypes in haskell?  i mean like ada package specs, or c++ header files, or some appropriate ML interface spec.  example: you want to write a chess program with a board evaluation function,   evaluate :: BoardPosition -> Float, and you want to write that signature independently of the definition of BoardPosition (which could be any of a lot of different representations, like d
11:40:33 <solrize> ata BoardPosition = ListOfSquares (Maybe (Color, PieceType))  or bitboards or whatever)
11:40:34 <jmcarthur> sternmull: You could use a Map instead of a Set.
11:41:08 <sternmull> jmcarthur: But i want to have the name etc. as part of the value.
11:41:37 <jmcarthur> sternmull: You could just make it like   Map Key Everything
11:41:37 <solrize> hopefully without using type classes or type families which all seem like overkill  (and type families are fairly recent in haskell: i'd hope there has always been a way to do what i'm asking)
11:42:05 <[exa]> solrize: you want overloading, so you need typeclasses
11:42:06 <jmcarthur> sternmull: The Everything could still contain the Key
11:42:40 <[exa]> solrize: evaluate :: UsuableAsBoardPosition b => b -> Float
11:42:47 <solrize> [exa] i don't particularly want overloading (i.e. multiple implementations selected at runtime)
11:43:29 <[exa]> it won't be selected at runtime unless there's something substantial that prevents specialization
11:43:31 <solrize> just want a single implementation, that's written separately from the type signature
11:43:36 <solrize> hmm
11:43:36 <sternmull> jmcarthur: But then i have to build a map when i actually want to express that i have a set of unique values (where uniqueness is defined by my "key"-function)
11:43:37 <jmcarthur> solrize: A type class is a signature and an instance is its implementation.
11:43:44 <adamCS> solrize:  Or you could a record of functions instead of the BoardPosition type.  But that's just what typeclasses do.
11:44:13 <adamCS> but it would impose less cost in required coherence in exchange for less convenience
11:45:24 <[exa]> solrize: you could also make a nice big BoardPosition type that covers all your cases so that overloading is not needed, but that would be brutally inconvenient
11:45:34 <solrize> meh i don't even necessarily want separate types.  e.g. instead of chess say i want InvertMatrix :: [[Float]] -> [[Float]].  but again there can be different implementations of matrix inversion using different algorithms
11:45:43 <tsahyt> is there a Profunctor (Choice?) equivalent to ArrowChoice's (|||)?
11:46:06 <pavolzetor> hello, I am thinking of using Alternative in my parser; I am curious how you handle error reporting? I looked around https://github.com/alexkalderimis/hlox/blob/master/src/Lox/Parser.hs
11:46:11 <solrize> making a big BoardPosition union type would be awful
11:46:17 <pavolzetor> for example it does not handle the errors correctly
11:47:02 <pavolzetor> because the <|> will not distinguish if it failed inside because it was not supposed to match (such as the first token did not match) or there was an error inside
11:47:20 <[exa]> solrize: how would you choose the correct implementation of inversion in your example from code 'invertMatrix m' ?
11:47:28 <[exa]> s/correct/desired/
11:47:44 <adamCS> tsayht: There is a "Choice" typeclass in Profunctor but I am not familiar enough with arrows to know if it covers the same functionality.
11:47:46 <pavolzetor> Would you have the state as Error | NoMatch?
11:47:54 <solrize> there would only be one implementation, no choice needed.  i just want to write the type signature in one place and the implementation in another
11:48:09 <pavolzetor> so then the alternative will return left if has error, but try right if no match?
11:48:11 <tsahyt> adamCS: (|||) is fan-in. it'd look something like Choice p => p a x -> p b x -> p (Either a b) x
11:48:28 <adamCS> tsahyt: yep.  It is like that, I think.
11:48:34 <adamCS> https://hackage.haskell.org/package/profunctors-5.3/docs/Data-Profunctor-Choice.html
11:48:38 <tsahyt> adamCS: Choice only has left' and right'
11:48:50 <adamCS> ah
11:48:52 <pavolzetor> currently I peek current token before branching into the production
11:49:01 <tsahyt> adamCS: although maybe one can rebuild it from those
11:49:21 <[exa]> solrize: oh so. that doesn't have much sense in haskell, but it's common to re-export specialized bindings, like: f :: type ; f = fImplementationFromOtherModule
11:50:49 <[exa]> solrize: the thing with "sharing a type definition in a header file" can be done using C preprocessor just as in C, using {-# LANGUAGE CPP #-}....but it's plain weird.
11:51:01 <solrize> [exa] hmm maybe that's closer to what i want.  but (ok going around in circles, sorry) the type definition should be part of the implementation?
11:51:06 <solrize> yeah using the CPP would be awful
11:52:02 <[exa]> yes, type definition is there for typechecking and resolving ambiguity, other modules automatically see it (or the inferred version) in the .hi file
11:52:07 <solrize> like i want to write a signature  invertMatrix :: Matrix -> Matrix  someplace, and "data Matrix = Matrix [[Float]]   in the place where the implementation is
11:52:51 <solrize> maybe this is what type families are for
11:53:35 <[exa]> no, type families are function on types, usuable e.g. for something like partial specializations in C++
11:54:30 <[exa]> my best guess is that you want a nice listing of what your library interface does in one piece of code?
11:54:36 <solrize> yeah
11:54:50 <solrize> that's a pretty standard thing i think
11:55:12 <[exa]> well, no :]
11:55:34 <[exa]> most haskell code is auto-processed and auto-documented by haddock, which provides this nice list in html
11:55:37 <[exa]> or some other format
11:56:23 <solrize> i don't just mean human readable listing, i mean type signatures that the compiler checks
11:57:11 <[exa]> hm well I get it now, yes
11:57:53 <[exa]> haskell disallows separated type signatures and definitions for some reason, but I don't know why
11:58:37 <[exa]> for your case, re-naming and re-typing the implementation is probably the way to go
11:58:55 <[exa]> btw haddock output here: https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-List.html#g:17
11:59:12 <[exa]> if you click the "source" button on the right there you'll see the implementation in the module
12:00:04 <solrize> yeah that's reasonable, but it seems like a shortcoming in haskell if there's no way to write what i guess would be a module signature in other languages
12:00:49 <[exa]> anyway, the difference from C++ and similars is that user-facing modules aren't usually very big (see the source :] ), so the pressure to "compress" the code to easily auditable block of type information is not that big
12:01:30 <[exa]> it's certainly a design choice that rules out the way you think about that, yes, but I don't know what's the reason it was introduced
12:01:34 <[exa]> maybe someone will :]
12:02:50 <solrize> i really might want to have multiple implementations selected at compile time, i.e. the library client would use import statements to choose what implementation was wanted.
12:03:09 <solrize> although your idea of re-exporting symbols might work for that
12:03:36 <zachk> solrize, why don't you want to use typeclasses for this?
12:03:50 <[exa]> yeah, a bit of re-exporting is also the usual way for dealing with resulting name clashes
12:04:27 <solrize> zachk, i may try to write it with type classes but it seems bogus to have an extra type parameter floating around loose.  i just want an opaque type for Matrix or whatever
12:04:33 <adamCS> solrize:  I guess it's not quite what you want, but using a record of functions might get you some of the way there.  Then your client could choose which record to supply.
12:05:25 <zachk> the extra dictionary parameter to the typeclass functions is internal and you never see them or have access to them
12:05:35 <solrize> adamCS, yeah that's like a type class, again it's more stuff for the client to deal with
12:06:15 <adamCS> solrize:  Sure.  But it's the same code they'd have to write to make an implementation.
12:06:28 <[exa]> solrize: don't fear the typeclasses, the type parameter almost certainly disappears on specialization
12:07:09 <solrize> i'm not worried about runtime overhead but i fear(?) that the extra parameter will clutter up the code.  i can try writing it that way and see
12:07:35 <zachk> solrize, you dont specify the extra parameter yourself
12:07:45 <zachk> :t (+)
12:07:46 <lambdabot> Num a => a -> a -> a
12:07:52 <[exa]> you don't write the extra parameter in code, only in types...otherwise it's either `Matrix -> Matrix` or  `Matrixish m => m->m`
12:08:00 <zachk> where is the extra parameter in that solrize ?
12:09:08 <solrize> ok, so I have    invertMatrix :: Matrixish m  => m-> m;   determinant :: Matrixish m => m -> Float
12:10:33 <solrize> then i can write an implementation that defines two different types of matrix and has an inversion function for one and a determinant function for the other, seems bogus.  that's why i was thinking of type families, i don't remember quite how they work but i remember they're used for associated types
12:11:22 <solrize> well actually hmm i guess the implementation of a type class has to include all the methods so maybe ok
12:11:54 <[exa]> yes, the typeclass will need to have everything you need to manipulate the inner stuff in the matrix
12:12:15 <solrize> ok i'll try to write this with type classes and see how it looks  thanks
12:12:27 <danilo2> Hi guys! I've got a problem. I've got a project which compiles (with all dependencies - almost 200 pkgs total) about 10 minutes with -O2 on a buffy machine. I wanted to do memory profiling so I enabled the stack --profile option, which enables all cabal options.
12:12:28 <[exa]> after that, say, invertMatrx = rightHalf . gaussJordan . addIdentityToRight
12:12:57 <solrize> nice :)
12:13:06 <danilo2> After the last 3 hours of compilation, GHC occupies almost 60GB of my ram and the .hi files are bigger than 30GB on disk
12:13:18 <solrize> danilo2, :O
12:13:20 <[exa]> danilo2: brutal
12:13:29 <danilo2> yep. And it still compiles
12:13:33 <[exa]> danilo2: what's the package?
12:14:04 <[exa]> danilo2: anyways, you might want a bit more hands-on approach than just telling stack to install everything totally unpacked and unoptimized
12:14:48 <danilo2> its luna visual dataflow processing engine - you can find it here: https://github.com/luna/luna-core . Clone it and run `stack build --profile luna-core`
12:14:53 <[exa]> (but I don't know much stack)
12:15:21 <danilo2> [exa]: basically all packages compile fine, the only which does not is our
12:15:42 <danilo2> there are files which compile for an hour, while without profiling they compile fast
12:16:05 <[exa]> is there something specific in the files?
12:17:39 <danilo2> yep, there is template haskell which generates a lot of datatypes and instances (it generates 34 datatypes, 4 instances for each and a single function for each)
12:17:45 <danilo2> [exa]: here is the file: https://github.com/luna/luna-core/blob/master/core/src/Luna/IR/Term/Ast/Class.hs
12:18:33 <danilo2> [exa]: here is documentation what exactly this TH does: https://github.com/luna/luna-core/blob/master/core/src/OCI/IR/Term/Definition.hs
12:18:39 <danilo2> [exa]: starting line 89
12:18:49 <[exa]> solrize: anyway, to sum up my opinion on that -- 'prototype before you polish' dictates you to do it with typeclasses now (these are the simplest tool available for that) and convert those to brutal module-switching compiler-machinery later :]
12:20:08 <dminuoso> danilo2: Wow it sounds like you may be beating simon marlow: https://mail.haskell.org/pipermail/haskell-cafe/2010-June/079332.html
12:21:43 <c50a326> how is this lambda calculus stuff actually useful as a haskell programmer
12:22:05 <[exa]> c50a326: it's the mechanism of composing pure functions together
12:22:36 <dminuoso> c50a326: Sometimes, for various reasons, we also encode things in lambda calculus style.
12:22:54 <dminuoso> c50a326: http://hackage.haskell.org/package/logict-0.6.0.2/docs/Control-Monad-Logic.html this for example might look familiar to you.
12:23:05 <[exa]> c50a326: haskell is basically lambda calculus, only enriched with data definitions and a type system
12:23:11 <dminuoso> logic :: (forall r. (a -> r -> r) -> r -> r) -> Logic a
12:24:16 <danilo2> dminuoso: interesting. Maybe I should write to mailing list aobbut it :(
12:24:18 <[exa]> c50a326: knowing the lambda calculus explains a lot about why something works as it does and what the types actually mean
12:24:30 <c50a326> but what kind of code have you written that you wouldn't have written if you didn't know it
12:24:51 <dminuoso> c50a326: I wouldnt know since I do know lambda calculus.
12:25:00 <danilo2> btw, does anybody have any idea what to do in such way, what can cause such strange compilation times and everything or should I jsut post it on mailing list and see how far we can go with it ? :(
12:25:17 <[exa]> c50a326: well learning haskell implicitly teaches you lambda calculus...so it's difficult to say. I probably wouldn't write haskell.
12:26:55 <[exa]> danilo2: can you rule out that it gets stuck in the TH phase?
12:27:45 <danilo2> [exa]: I doubt it gets stuck there. If it produces .hi file then its after that stage right ?
12:27:46 <[exa]> danilo2: since the possibilities are 1] TH+profiling does something weird 2] TH just generates so much code that compiling it with profiling explodes
12:28:00 <[exa]> yeah
12:28:08 <[exa]> so it's 2]
12:28:54 <danilo2> [exa]: I also doubt its the 2 option. The generated code uses heavily type families to compute types. I suspect this is connected with type families resolution
12:29:08 <[exa]> you could want to see --ddump-core from the file and check it for shenanigans
12:29:39 <ammar2> c50a326: not sure about code but knowing the lambda calculus would give you insight into why `f a b = a + b` desugars into `f = \a -> \b -> a + b` internally
12:30:09 <[exa]> (/me has no idea how type families are implemented)
12:30:19 <solrize> [exa] i already have a working prototype so i'm asking about how to do the "polish" phase
12:30:58 <danilo2> [exa]: what are shenanigans ? I will dump core it, but as I understand you refer to dumping core of -O2 without profiling right?
12:31:24 <[exa]> solrize: oh so :]
12:31:27 <danilo2> [exa]: btw this single file already produced 25Gb .hi file ....
12:31:33 <[exa]> danilo2: something nasty
12:31:42 <danilo2> [exa]: when I started this conversation it was 7Gb
12:31:44 <[exa]> danilo2: core _with_ profiling ofc
12:32:11 <[exa]> ok maybe examining the contents of .hi would be sufficient
12:32:24 <danilo2> [exa]: will I get the core dump before generating .hi file?
12:32:56 <danilo2> [exa]: do you want me to uplaod it somewhere? :D :D :D
12:33:05 <[exa]> certainly not :]
12:33:29 <[exa]> the point is that there will be a lot of something, knowing of what could helo a lot
12:34:17 <[exa]> danilo2:   ghc --show-iface M.hi   could work
12:36:32 <danilo2> [exa]: Ill try doing it in am oment when my mahcine starts living again, my swap is almost over. ill kill it :(
12:37:39 <[exa]> danilo2: unfoldings are in Core so .hi is probably generated after Core is done
12:38:55 <dminuoso> danilo2: What GHC version are you using?
12:39:22 <phadej> Athas, it's not my work though, I'm only a current (of many) maintainers
12:40:07 <[exa]> c50a326: anyway if you struggle with lambda calculus papers you should probably just start coding and ask around, lambda stuff will arrive later by itself
12:42:04 <danilo2> dminuoso: 8.4.3
12:42:49 <danilo2> Ok, Im back, my system has 1% ram usage after killing ghc
12:42:54 <danilo2> ill inspect the .hi now
12:43:28 <Athas> phadej: who originally wrote it?
12:43:42 <[exa]> danilo2: hope it doesn't load the whole thing in ram again :]
12:44:10 <c50a326> is there an official documentation for how to parse http?
12:44:25 <c50a326> I guess the spec
12:44:26 <[exa]> c50a326: W3C standard probably
12:45:20 <[exa]> c50a326: oh, it's RFC. https://www.w3.org/Protocols/rfc2616/rfc2616.html (and the ones linked from deprecation note)
12:46:17 <danilo2> [exa]: Strange, it returns error "magic number mismatch: old/corrupt interface file?" Of ocurse its not strange on theat file because I killed GHc while it was creating it, but I wanted to open smaller file with similar problem (7Gb on disk)
12:46:29 <c50a326> I don't need to read the whole thing do I?
12:46:54 <dminuoso> c50a326: HTTP is fairly straight forward. =)
12:47:03 <[exa]> danilo2: are you using the same ghc as stack did?
12:47:30 <danilo2> [exa]: yes, Im using stack exec -- ghc --show-iface Core.dump-hi
12:47:31 <[exa]> c50a326: just implement a tiny subset that is showed on wikipedia :]
12:47:45 <danilo2> [exa]: stack exec -- ghc --version  is correct , its using the same one
12:47:48 <[exa]> danilo2: weird.
12:48:25 <[exa]> that probably exhausts all advice I can give
12:49:06 <dminuoso> c50a326: Just start reading it. There's a lot of text that is concerned rather with what the intention is (so its relevant for clients and servers), but very little is relevant from a parsers perspective.
12:57:57 <danilo2> [exa]:  :(
13:06:33 <phadej> Athas: https://github.com/phadej/github/graphs/contributors says mike burns, and I inherited it from jwiegley around 2016
13:15:53 <heebo> can anyone tell me why esquelleto is useful?
13:23:57 <alx741> heebo: to write SQL joins that are otherwise not possible with thinks like persistent alone
13:24:12 <alx741> *things
13:49:22 <Zagadra> I have an untrusted module that defines several data types. I want to derive Serialize for those types, but serialize is XUnsafe. Should I use orphan instances in a trusted module?
13:49:37 <c50a326> is there a better way to output data from a socket other than `print` if you're trying to parse network protocols?
14:24:07 * hackage logic-TPTP 0.4.6.0 - Import, export etc. for TPTP, a syntax for first-order logic  http://hackage.haskell.org/package/logic-TPTP-0.4.6.0 (DanielSchuessler)
14:31:09 <f-a> has anyone run fay with cabal new-build/install environment?
14:37:01 <pavonia> c50a326: There are several logging packages, e.g. hslogger, perhaps you want to look into one of these
15:13:44 <epta> I'm trying to apply release.nix approach by Gabriel Gonzalez for referencing local dependency, and got strange error 'liba-0.1.0.0-inplace is unusable due to missing dependencies' https://github.com/Gabriel439/haskell-nix/issues/56
15:44:24 <lavalike> cabal question: why is the compilation of A.* duplicated here when I do cabal new-build? https://pastebin.com/raw/rEVE3weW
15:45:08 <lavalike> triplicated, I should say, but at least the first two times it's creating .o and then .p_o which I guess are different files, the third time it's back at compiling .o objects, didn't it just do that?
15:45:21 <lavalike> is it something wrong with my cabal file or is this normal
15:48:02 <c_wraith> well, the p_o files are profiling versions.  Those are being built because you have library profiling enabled
15:48:20 <c_wraith> ah, I see why the object files are being double-built
15:48:22 <lavalike> I can probably find the configuration to turn that off
15:48:30 <lavalike> oh so it is a bug?
15:48:32 <c_wraith> You use the same src directory
15:48:37 <lavalike> yeah
15:48:45 <lavalike> is that the problem?
15:48:54 <c_wraith> So it's finding the files you're importing locally, instead of looking in the library
15:48:59 <lavalike> haha
15:49:34 <c_wraith> Put the modules for the library in a separate source dir, and it will do better
15:49:38 * hvr points out that -Whome-missing-modules would have exposed the issue
15:49:59 <lavalike> that was it c_wraith !
15:50:41 <lavalike> hvr: maybe I should investigate enabling (more) warnings
15:50:59 <c_wraith> yeah, I don't know that warning either. :)
15:51:54 <hvr> it's available since GHC 8.2
15:52:28 <hvr> and cabal turns it on for you
15:53:33 <lavalike> oh yeah I'm stuck at 8.0.2 on this machine, I should upgrade
15:54:01 <lavalike> between moving the source directory and disabling library profiling now compilation is quite fast, thanks for the help (:
15:58:04 <heebo> yes but i dont understand what esquelleto buys you over just writing the sql in a literal string
15:59:49 <hpc> heebo: the same benefit as typed-anything over stringy-anything
16:00:37 <hpc> (at the same time i quite like sql and probably wouldn't use esqueleto)
16:00:42 <c_wraith> among other things, it makes it *really* hard to be tempted to use ++ to assemble the query
16:10:00 <koz_> :t uniq
16:10:01 <lambdabot> error: Variable not in scope: uniq
16:10:15 <hvr> :t nub
16:10:16 <lambdabot> Eq a => [a] -> [a]
16:10:26 <koz_> hvr: What I need is a test rather than an operation.
16:10:41 <koz_> Something with the sig 'Eq a => [a] -> Bool'.
16:10:57 <hpc> :t \x -> x == nub x
16:10:58 <lambdabot> Eq a => [a] -> Bool
16:11:11 <koz_> That easy huh. OK.
16:14:04 <koz_> :t foldr
16:14:06 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:15:37 <monoidal> Note that nub is O(n^2)
16:16:02 <koz_> monoidal: Yeah, I'm aware. I'm not expecting more than about 10 items.
16:16:33 <koz_> (if I were, I'd be doing some kind of lazy State foldM with a HashSet or something)
16:51:36 <centril> I had a crazy idea just now;  what if we permitted  case (foo :: Maybe t) of j@Just -> ...; ...   and then say that  j :: (t -> r) -> r  ?
16:52:50 <centril> never mind, that doesn't work
16:57:18 <heebo> any new exciting libraries?
16:58:23 <centril> on second thought... j@Just -> j foo ===> Just x -> let j f = f x in j foo
16:58:55 <centril> don't know how useful that is tho
17:04:07 <koz_> Could someone help me understand this error from GHC? https://gist.github.com/kozross/02a24dd27e3c4e79932018bcc1ba9973 I'm using gist.github because lpaste appears dead.
17:06:45 <koz_> I get the distinct feeling I have to enable some kind of extension that lets me 'lower' b from the signature so I can use it as a parameter like that.
17:07:26 <pavonia> Yes, looks like you want ScopedTypeVariables
17:07:35 <koz_> pavonia: Thanks, that was the one.
17:08:06 <pavonia> The b in finiteBitSize (undefined :: b) is not the same as the one in the type signature
17:08:15 <koz_> pavonia: Yeah, it's fresh IIRC.
17:08:32 <koz_> Where in the sig does the explicit forall b have to go?
17:09:03 <koz_> Never mind, figured it out.
17:09:13 <koz_> (it was actually 'forall a b m')
17:14:01 <koz_> Also, it's very annoying to write a constraint like 'MonadError (ColumnTypeError a) m' everywhere. Is there a way I can define a synonym for that?
17:22:38 * hackage language-ats 1.2.0.16 - Parser and pretty-printer for ATS.  http://hackage.haskell.org/package/language-ats-1.2.0.16 (vmchale)
17:35:37 * hackage ats-pkg 3.0.0.10 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-3.0.0.10 (vmchale)
17:43:07 * hackage ats-pkg 3.0.0.11 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-3.0.0.11 (vmchale)
17:50:07 * hackage serverless-haskell 0.6.4 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.6.4 (AlexeyKotlyarov)
18:11:07 * hackage serverless-haskell 0.7.2 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.7.2 (AlexeyKotlyarov)
18:21:21 <dmwit> koz_: Sure, `type Foo a = MonadError (ColumnTypeError a)`. Might need an extension, but it should tell you which one.
18:53:29 <koz_> dmwit: That simple huh. OK, will try.
18:53:58 <Zemyla> Why is there no unsafeThaw operation for ArrayArray#?
19:09:09 <koz_> If I define a closed type family, how do I define an instance of Eq for it?
19:09:18 <aarvar> koz_: you don't
19:10:50 <koz_> aarvar: So are instances of those types incomparable or am I missing something here?
19:11:10 <aarvar> koz_: you can't define instances for type families
19:11:24 <aarvar> or at least, not top level instances
19:11:50 <aarvar> what does the type family look like?
19:13:57 <koz_> aarvar: https://gist.github.com/kozross/980e49559cf2be6866dd2c4e3e92e7bd
19:14:16 <aarvar> koz_: and what would the instance look like?
19:14:41 <koz_> aarvar: In the sense of 'what would it do to check equality' or 'how would I write it'?
19:14:54 <aarvar> how would you write it
19:15:01 <aarvar> what do you want to write that you can't
19:15:17 <aarvar> instance Eq (ColumnData a) where ...  ?
19:15:24 <koz_> I _assume_ it would be something like 'instance (Eq a) => Eq (ColumnData a) where ... '
19:16:03 <koz_> But even that far, I get an error from GHC saying that I have an illegal type synonym family application.
19:16:12 <aarvar> right, it's not allowed
19:16:14 <aarvar> for multiple reasons
19:16:29 <aarvar> for one, the type `a` would be ambiguous, so it could never be inferred
19:16:40 <aarvar> so it's impossible to match the instance
19:16:57 <aarvar> or at least, there would be many different ways to match it
19:17:21 <koz_> Oh, I think I get why now.
19:17:26 <aarvar> second, how would you implement Eq (ColumnData Int)?
19:17:37 <koz_> It's just an alias for a specific set of a's, right?
19:17:47 <aarvar> no
19:19:21 <aarvar> anyway, what you could do (don't ask me if it's a good idea) is define class ColumnDataEq a where columnDataEq :: ColumnType a -> Dict (Eq (ColumnData a))
19:19:41 <koz_> aarvar: It's OK - I suspect a closed type family isn't what I want here.
19:22:28 <aarvar> er, that would be dumb, ignore that
19:39:05 <dmwit> koz_: You can give an Eq instance for a data family...
19:39:16 <koz_> dmwit: It's fine, I've already changed my approach.
19:39:20 <koz_> But I have another question.
19:40:11 <koz_> For Binary instances, when I write a 'get' method, I need to have parsing fail if I end up decoding an empty Text from the input. How would I do that? I see that Get has instances of Alternative and MonadPlus, but I'm not sure how to use them for this, or even if I should.
19:40:56 <suzu> Get is a monad, so you could use `fail :: String -> Get a`
19:40:57 <Zemyla> :t guard -- koz_
19:40:59 <lambdabot> Alternative f => Bool -> f ()
19:41:02 <Gurkenglas> koz_, dunno about should but if you can then surely:
19:41:04 <Gurkenglas> :t mfilter
19:41:05 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
19:41:46 <koz_> Gurkenglas: Could you elaborate on the 'dunno about should' part. Does this mean 'there's a better way to do what you want', or 'I've not used it that way before'?
19:43:03 <aarvar> suzu: fail shouldn't be part of Monad
19:43:11 <suzu> it shouldn't, but the Get monad uses it
19:43:11 <Gurkenglas> I'm not familiar with Binary, but would be appalled if you could use Alternative to get "Parser Text -> Parser Text" to have the parsing fail if the text is empty it have the way you do it not be "mfilter isn'tempty"
19:43:12 <aarvar> is it ever going to go away?
19:43:32 <suzu> unlikely
19:43:48 <Gurkenglas> *"empty but have"
19:43:49 <aarvar> Why? Everyone agrees it's stupid
19:43:50 <koz_> Gurkenglas: So you suggest I use MonadPlus stuff?
19:44:00 <suzu> yeah but String is in base too and it's been hard to get rid of
19:44:09 <suzu> koz_: i think you should be using `fail` in the Get monad
19:44:17 <aarvar> String is different
19:44:19 <suzu> but i also think you shouldn't use the binary package
19:44:59 <Gurkenglas> http://hackage.haskell.org/package/binary-0.9.0.0/docs/src/Data-Binary-Get-Internal.html#line-260 wraps that fail stuff in a nice Alternative interface
19:45:06 <suzu> oh wow they both use `fail`
19:45:21 <suzu> oh err no
19:45:25 <suzu> Gurkenglas: that is a different 'Fail'
19:45:36 <koz_> suzu: So what should I use instead?
19:45:51 <suzu> i suggest using cereal, but it too requires you to use `fail`
19:45:53 <Gurkenglas> suzu, u sure? http://hackage.haskell.org/package/binary-0.9.0.0/docs/src/Data-Binary-Get-Internal.html#line-97
19:46:37 <Gurkenglas> koz_, please provide the type of the function you would like to have
19:46:45 <suzu> Gurkenglas: ye it wraps the monad fail in the `Fail` ADT
19:47:46 <Gurkenglas> suzu, empty is just fail "Data.Binary.Get(Alternative).empty"
19:47:56 <suzu> oh you are right
19:49:56 <koz_> Gurkenglas: It would basically do something like 'try to parse a Text, if you get an empty Text, fail; otherwise, try to parse another Text, if that one's empty, fail as well; otherwise, parse an Int64, if that's 0, fail...'
19:50:23 <koz_> And then at the end of like, 6 or 7 of those, if nothing broke, construct a value of type Foo which is some complex record with those tests as its invariants.
19:54:10 <koz_> If Cereal would be a better way to do this, I'm happy to use it instead, but I really haven't done this before.
19:57:42 <Gurkenglas> koz_, do you already know how to parse a Text without checking whether it's empty?
19:58:04 <koz_> For Binary? Yeah. x <- get :: Get T.Text
20:01:24 <Gurkenglas> koz_, then try "x <- mfilter (not . null :: T.Text -> Bool) get :: Get T.Text"
20:01:40 <koz_> Gurkenglas: Thank you!
20:03:14 <lyxia> aarvar: fail is in the middle of moving to MonadFail
20:09:50 <Zemyla> I've successfully written an Unbox instance for Integer and for Natural.
20:10:34 <Zemyla> And writing one for Ratio is fairly trivial.
20:10:46 <koz_> Zemyla: How did you write the Unbox for Integer?
20:12:10 <Zemyla> It has an UnliftedArray and a ByteArray. If the value in the unlifted array is the null BigNat, then it uses the value of the Integer in the ByteArray; otherwise, it uses the sign of the Integer and the magnitude of the BigNat.
20:13:49 <Zemyla> *Int in the ByteArray, not Integer.
20:32:56 <koz_> suzu: Now I have something where I parse two Int32s, but need to bail if the first turns out bigger than the second. How do I write that?
20:33:03 <koz_> (using Binary)
20:33:14 <koz_> I tried 'unless', but it wasn't terribly pleased with that.
20:38:25 <dmwit> What don't you like about `unless`?
20:39:10 <koz_> dmwit: I have no problem with unless. GHC didn't, because it expected Get Foo, but unless gives back Get ().
20:39:16 <koz_> I assume I have to use fail here?
20:41:36 <dmwit> naturally
20:41:41 <koz_> dmwit: Thanks.
20:41:52 <dmwit> do { i <- get; i' <- get; unless (i < i') (fail "wuh-oh"); return (i,i') }
20:42:39 <dmwit> If you prefer the mfilter way, you can `do { i <- get; i' <- mfilter (<i) get; return (i,i') }`.
20:42:50 <dmwit> I'm not sure I'm on board with mfilter over fail. I like descriptive errors.
20:43:57 <koz_> dmwit: Which is fair enough.
20:52:49 * koz_ goes to rewrite everything with lots of fail.
21:50:37 * hackage substring-parser 0.4.1.0 - Match / replace substrings with a parser combinators.  http://hackage.haskell.org/package/substring-parser-0.4.1.0 (igrep)
21:54:07 * hackage dfinity-radix-tree 0.2.0 - A generic data integrity layer.  http://hackage.haskell.org/package/dfinity-radix-tree-0.2.0 (EnzoHaussecker)
22:07:34 <koz_> What extension(s) do I need to enable to write something like the 'foo' type here: https://downloads.haskell.org/~ghc/8.2.2-rc3/docs/html/users_guide/glasgow_exts.html#record-field-selector-polymorphism ?
22:11:27 <glguy> The error message will tell you when you try
22:12:42 <koz_> DataKinds and TypeApplications apparently.
23:27:36 * hackage dhall 1.16.0 - A configuration language guaranteed to terminate  http://hackage.haskell.org/package/dhall-1.16.0 (GabrielGonzalez)
23:34:11 <diginet> really annoying to me that people use ADT and "Sum Type" interchangeably
23:34:46 <c_wraith> well, every* language has product types.  It's Sum types that are missing from most.  (*almost every)
