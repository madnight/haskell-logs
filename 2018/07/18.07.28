00:00:03 <mniip> \x y -> x
00:00:05 <suzu> that's a legit lambda expression?
00:00:16 <suzu> that's a value
00:00:32 <mniip> this can be assigned multiple types: Int -> Char -> Int,  a -> Bool -> a, a -> a -> a,
00:00:37 <suzu> right
00:00:45 <mniip> but there is a "most principal" type: a -> b -> a
00:00:50 <suzu> but the most general on this ordering is a -> b -> a
00:00:54 <suzu> ok i see
00:01:01 <mniip> and any other is a specialization of that
00:01:04 <suzu> right
00:01:12 <suzu> and ghc attempts to infer the most general type
00:01:18 <mniip> therefore when the typechecker sees \x y -> x, it has the right to infer its type as a -> b -> a
00:01:32 <mniip> because the programmer might only have meant something more specific,
00:01:37 <suzu> yes
00:01:41 <mniip> which the typechecker can always specify later on
00:01:41 <suzu> ok, i follow thus far
00:01:52 <suzu> what is \D -> False?
00:02:12 <mniip> that's just syntax for \x -> let D = x in False
00:02:24 <suzu> you can place values in lambda arguments?
00:02:32 <suzu> \5 -> False is valid?
00:02:35 <mniip> yes
00:02:45 <mniip> you can place patterns in lambda arguments
00:02:51 <mniip> :t \_ -> ()
00:02:52 <lambdabot> p -> ()
00:02:54 <mniip> :t \False -> ()
00:02:55 <lambdabot> Bool -> ()
00:02:58 <mniip> :t \(x, y) -> ()
00:02:59 <lambdabot> (a, b) -> ()
00:03:05 <mniip> :t \(id -> ()) -> ()
00:03:06 <lambdabot> () -> ()
00:03:10 <suzu> is there a point if you're not desugaring a structure?
00:03:15 <mniip> ?
00:03:22 <suzu> e.g. \False -> ..
00:03:36 <suzu> why is that ever useful?
00:03:43 <mniip> that in particular might not be
00:03:48 <suzu> \(x, y) -> ... is useful
00:03:50 <mniip> but \(x, y) -> ... definitely is
00:03:50 <suzu> oh ok
00:03:52 <suzu> i see
00:04:04 <mniip> \(Identity x) -> ...
00:04:05 <suzu> and it is sugar for let-binding to pat match and then evaling the body
00:04:20 <suzu> uh ok so back to \D -> False
00:04:23 <mniip> more specifically it is sugar for an irrefutable pattern match
00:04:36 <suzu> why is the type of this not `T a -> Bool`?
00:04:51 <mniip> T a -> Bool is a possible type
00:04:52 <suzu> err or rather, `T Bool -> Bool`
00:04:59 <Burbly> I've just read a suggestion that functions shouldn't have more than 3 arguments. (Google "functions 3 arguments bob martin".) My immediate reaction was that this was good advice for OO code but that Haskell had many sensible (curried) fns with more arguments. Hoogling 'a -> b -> c -> d -> e' just turns up a bucketload of datatype constructors. Can
00:04:59 <Burbly> anyone think of high-arity functions that 'do-work'?
00:05:01 <mniip> :t (\D -> False) :: T a -> Bool
00:05:03 <lambdabot> T a -> Bool
00:05:04 <suzu> or are those obth possible types
00:05:05 <mniip> :t (\D -> False) :: T a -> a
00:05:06 <lambdabot> T a -> a
00:05:11 <suzu> but cannot be ordered
00:05:35 <mniip> \D -> False  has no "most general" type
00:05:57 <mniip> it doesn't have a type that the typechecker can pick and then that type would fit whenever
00:06:20 <suzu> T a -> a is only assignable because we know that a ~ Bool, correct?
00:06:41 <mniip> suzu, yes
00:06:58 <suzu> however if it were T a -> a, then i could add a case for a different a and then this type would be illegal
00:07:36 <suzu> so that type is .. still circumstantial to the cases i have
00:07:53 <suzu> i think i see what's going on here now
00:07:55 <mniip> Burbly, Data.Map.insertWithKey
00:08:02 <Burbly> thanks!
00:08:16 <suzu> "is untouchable" is a strange error message for this
00:08:38 <mniip> that's the jargon
00:09:00 <suzu> lol
00:09:37 <mniip> when typechecking a pattern match that introduces a local equality constraint, all type variables bound outside of the match are marked "untouchable"
00:10:00 <mniip> while those introducing in the match itself, or inside the branch are "touchable"
00:10:32 <suzu> oh i see
00:11:29 <mniip> Burbly, such functions are sparse in generic code though
00:11:39 <mniip> you might find much more in specialized code
00:13:15 <mniip> consider something like
00:13:18 <mniip> :t GHC.IO.mkFileHandle
00:13:19 <lambdabot> error:
00:13:20 <lambdabot>     Not in scope: ‘GHC.IO.mkFileHandle’
00:13:20 <lambdabot>     No module named ‘GHC.IO’ is imported.
00:13:25 <mniip> :t GHC.IO.Handle.mkFileHandle
00:13:26 <Burbly> From the hoogle searches that sounds right. But I think that they are more convincing counterexamples in generic code.
00:13:27 <lambdabot> (Typeable dev, GHC.IO.BufferedIO.BufferedIO dev, GHC.IO.Device.IODevice dev) => dev -> FilePath -> GHC.IO.IOMode.IOMode -> Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.IO.Handle.Types.NewlineMode
00:13:27 <lambdabot> -> IO GHC.IO.Handle.Types.Handle
00:14:55 <Burbly> That's the kind of exampel where Martin would argue that you shouldn't have to specify the TextEncoding and NewlineMode every time. And you can envisage a refactoring that makes that optional.
00:15:36 <Burbly> (Typeable dev, GHC.IO.BufferedIO.BufferedIO dev, GHC.IO.Device.IODevice dev) => dev -> FilePath -> GHC.IO.IOMode.IOMode -> OpenAction
00:16:08 <Burbly> setEncoding:TextEncoding  -> OpenAction  -> OpenAction
00:16:28 <Burbly> setNewLineMode: IOMode -> OpenAction  -> OpenAction
00:16:41 <Burbly> open: OpenAction  -> IO Handle
00:16:50 <mniip> :t GHC.Event.registerFd
00:16:52 <lambdabot> base-4.10.1.0:GHC.Event.Manager.EventManager -> base-4.10.1.0:GHC.Event.Manager.IOCallback -> System.Posix.Types.Fd -> base-4.10.1.0:GHC.Event.Internal.Event -> base-4.10.1.0:GHC.Event.Internal.
00:16:52 <lambdabot> Lifetime -> IO base-4.10.1.0:GHC.Event.Manager.FdKey
00:17:42 <mniip> Burbly, in haskell that type of refactor is only acceptable when you have, I'd say... 7+ fields
00:18:17 <Burbly> Interesting. Thanks.
00:23:03 <mniip> see e.g the api in http://hackage.haskell.org/package/process-1.6.4.0/docs/System-Process.html
00:36:49 <cocreature> if you’re worried about the duplication, make a local binding that fixes some of the parameters
00:38:46 <Burbly> cocreature was that meant for me? I'm not really worried about this in concrete cases at present – just mulling over that Bob Martin advice. There's definitely something there, but the way it's phrased seems a bit simplistic.
00:41:05 <cocreature> Burbly: yeah, I was thinking of something like "mkUtf8Handle device path ioMode = mkFileHandle device path ioMode (Just yourEncodingHere) yourNewlineMode" here
00:41:13 <cocreature> then you don’t need to specify it every time
00:41:52 <liste> Burbly: in OO code you put some, more "permanent" parameters in the constructor, and "transient" parameters as method arguments
00:41:53 <Burbly> I was actually surprised at the argument order of mkFileHandle ... it would seem to me to make more sense to put ioMode, newlineMode first.
00:42:25 <liste> Burbly: in Haskell you have the choice, you can either make a partially applied function that has the permanent parameters in, or supply all at once
00:42:53 <Burbly> liste that's what I meant by Being surprised by the order of arguments.
00:43:07 <Burbly> It means you can't curry.
00:43:48 <Burbly> It's also why I was particularly looking for generic cases.   Data.Map.insertWithKey is a nice example, where currying doesn't really help.
00:44:32 <plotnus> I'm learning haskell & list comprehensions are pretty magical.
00:44:56 <plotnus> It reminds me of the feeling when I first started learning programming. "like wow this reall works"
00:46:09 * hackage dimensions 1.0.1.1 - Safe type-level dimensionality for multidimensional data.  http://hackage.haskell.org/package/dimensions-1.0.1.1 (achirkin)
00:48:55 <Akii> what's the language extension again that makes it such that the `a` in line 4 is the same as the one in line 1? https://lpaste.net/4486278427992653824
00:49:00 <Akii> something something flexible I think
00:51:17 <liste> Akii: ScopedTypeVariables,  but you need an explicit forall with that
00:52:18 <Akii> thanks!
00:53:28 <Akii> like this? https://lpaste.net/1202932778111336448
00:54:06 <Akii> that doesn't seem to be enough just yet
00:54:19 <Lears> forall binds the a. Since apply is the inner context, presumably you're shadowing the outer a.
00:54:49 <Lears> (put the forall on the top level binding instead)
00:56:09 <Akii> whee, that did the trick (here's the compilable version https://lpaste.net/548766150343786496)
00:56:11 <Akii> thanks :D
01:08:22 <kuribas> hi, let's say I have an attribute type: newtype Attribute (a :: [Symbol]) b c  It associates an type b  with another type c, and is named by the symbol a.
01:09:13 <kuribas> I can now compose them, however I cannot implement any standard classes because of the symbol name.
01:09:42 <kuribas> The symbol name would be used to store attributes in a database.
01:09:50 <kuribas> is there a better way?
01:10:33 <nyingen> Anyone know how I can downgrade the version of cabal-install that Stack uses? I ran "stack install cabal-install" as instructed by the User Guide but it installed a version "newer than Stack has been tested with"
01:11:42 <cocreature> kuribas: what exactly do you mean by “compose” here? what’s the composition of two attributes? and which classes do you want to make instances of?
01:11:54 <kuribas> cocreature: arrow for example
01:12:07 <kuribas> cocreature: composition means getting the attribute of an attribute, like a lens
01:12:58 <cocreature> kuribas: but how do the names compose?
01:13:08 <kuribas> cocreature: list append
01:13:35 <kuribas> so you could for example fetch attributes from remote objects.
01:13:44 <kuribas> by using the attribute names
01:14:18 <kuribas> implemented the classes isn't "necessary", but it would be nice.
01:15:01 <cocreature> I would just make a different combinator
01:15:10 <cocreature> Arrow is not that useful of a typeclass anyway
01:15:31 <kuribas> ah ok :)
01:16:37 <cocreature> ofc you could also just not have the name be represented at the type-level. whether that makes sense or not depends on your application
01:23:09 <Cheery> Confirmed few things on my own and I think I know how to implement existential quantifier now, except for a detail.
01:24:29 <Cheery> how should I implement skolem -function if I have separated the constraint generation and solving?
01:25:54 <dmiles> Cheery, you are imlpementing a infernce engine right?
01:26:53 <dmiles> For existentials, I actualy start them our as regular prolog-like varaibles.. and add a unification hook
01:28:04 <dmiles> oh but, yes, the skolem that operates as their background identity .. it is just standard skolemization
01:29:16 <dmiles> that skolem function is a term like  skFingerOf(bill,7)
01:29:35 <dmiles> that names bills 7th finger
01:30:17 <dmiles> but the nondeterimisitc machine that uses that skolem pretends its a prolog-like variable
01:30:54 <dmiles> on unification i check to see if the value binding is compatible with being able to be bills 7th finger
01:31:58 <Cheery> every variable binding inside the let that did skolemization will be able to unify bills 7th finger
01:32:07 <dmiles> how thye skolem function is durrived is the identity of the rule plus every free var up to that point
01:33:10 <dmiles> oh yes.. also on does an occurs check
01:33:32 <dmiles> to make sure the candidate in not part of the skolem term
01:33:43 <dmiles> oh yes.. also one does an occurs check
01:34:04 <Cheery> occurs check for the skolem variable?
01:34:16 <dmiles> for one of the other vars of the term
01:34:28 <dmiles> occurs check on the skolem
01:35:02 <dmiles> so whenever something whichs to bind to the skolem var.. i have code to make sure it is sane
01:35:03 <Cheery> I had not understood that. Why it needs to be done?
01:35:26 <dmiles> so whenever something wishes to bind to the skolem var.. i have code to make sure it is sane
01:36:04 <dmiles> well you gave one reason, what if one of the forlmula vars like Person=Bill or FingnerNum=7 wanted to being with Bill7thFinger
01:36:41 <dmiles> well you gave one reason, what if one of the forlmula vars like the Person bill or FingerNum 7 wanted to bind with Bill7thFinger?
01:37:23 <Cheery> the type inferencer cannot know what the actual type is for the skolem
01:37:35 <dmiles> also if you make that formula iterate out all of his fingers.. you want to make sure teh 6th and 7th finger are not going to be the same finger
01:37:43 <Cheery> therefore it cannot know whether it can be unified with a type.
01:38:31 <dmiles> oh i thought you were designing an inferncer (prolog-like) in Haskell
01:38:58 <dmiles> yeah my advice is based on that you are desiging the type infernceer :)
01:39:53 <dmiles> i did that for my programming language
01:40:09 <dmiles> the human writes their code in logic
01:40:21 <revskill> In servant, suppose i have two endpoints like that: ReqBody '[JSON] Type1, ReqBody '[JSON] Type2 , how Servant behaves ?
01:40:40 <dmiles> (which i then produce skolem terms for)
01:41:37 <revskill> i mean, you have only one endpoint for POST request: post /api/test, but they're different in reqbody type and response
01:43:50 <Cheery> dmiles: going to implement a type inferencer that supports existential quantification in datatypes. Once I've understood it well enough, I'm going to study that a little bit.
01:44:03 <cocreature> revskill: assuming you’ve combined them with :<|> it will take the first one for which it can parse the input iirc
01:44:26 <Cheery> the relationship of type inferencers and prolog are really interesting.
01:44:54 <revskill> cocreature: i have a bunch of Action type, and i want to parse through servant, so in this case i think Servant will parse all actions till it successs.
01:45:03 <dmiles> Cheery: yeah i wrote my system in prolog .. but i could have started with ATP-Haskell
01:45:36 <revskill> cocreature: so i think, in this case, we can simulate Graphql like that
01:46:25 <dmiles> Cheery: though the funny thing is the whole point of ATP-Haskell though is to sneak arround Haskell busy-body typesystem
01:46:50 <dmiles> and allow one to write Prolog code
01:47:33 <dmiles> then from the prolog code.. one can implement much more powerfull typessystems
01:47:41 <funrep_> hi, anyone else have problems with vs code plugin "Haskell Syntax Highighting", when i write "data X = Foo | Derp" and ident then when i wright something underneath like "bar x = 2" it idents the whole expression which is very annoying
01:49:39 <revskill> ah, VSCode is stupid with its unexpected behaviours when you copy-paste things
01:50:27 <dmiles> Cheery: this might add source of inspiration for you:   https://hackage.haskell.org/package/atp-haskell-1.14/docs/Data-Logic-ATP-Skolem.html
01:52:12 <Cheery> dmiles: thanks
02:04:57 <tombusby> Hey, I just have a really quick q:
02:05:25 <tombusby> if I use something like "let n = 4" in a do block, is that implicitly converted to "n <- return 4"
02:05:47 <tombusby> (which I know is also syntactic sugar for using the >>= operator
02:06:54 <liste> tombusby: no, it's converted to "let x in ..."
02:07:07 <liste> @undo do { let x = 5; pure x; }
02:07:07 <lambdabot> <unknown>.hs:1:23:Parse error: ;
02:07:14 <liste> @undo do { let x = 5; pure x }
02:07:14 <lambdabot> <unknown>.hs:1:24:Parse error: }
02:07:57 <Lears> iirc @undo is incomplete and doesn't handle let.
02:09:29 <liste> anyway, "do { l <- getLine; let s = l ++ "!"; putStrLn s; }" would be sth like "getLine >>= \l -> let s = l ++ "!" in putStrLn s"
02:10:33 <lavalike> i.e. lets are not desugared into anything, they are just standard lets
02:10:58 <liste> lavalike: well in do notation you don't have the "in"
02:12:15 <tombusby> liste: thx for the response :)
02:12:51 <tombusby> how is the scope of the "in" determined then? I suppose it must just be the entire rest of the do block
02:16:00 <liste> tombusby: it is
02:16:07 <tombusby> liste: cheers
02:29:50 <Lears> @undo do { let { x = 5 }; pure x }
02:29:50 <lambdabot> let { x = 5} in pure x
02:30:05 <Lears> Actually the problem was not enough curly brackets.
02:30:07 <lavalike> liste: you're right! so it does get desugared: do { ...; let <bindings>; ... } => ... >> let <bindings> in ...
02:37:51 <kuribas> if you import Control.Cathegory, do you need to hide Prelude.(.)?
02:39:30 <kuribas> is there any use for Control.Category?
02:39:41 <Rembane> <<< and >>>
02:39:46 <Rembane> So you can write things backwards. :)
02:40:04 <kuribas> right :)
02:41:52 <vrom911> kuribas, we use it to implement composition operator for our custom data Prism in tomland https://github.com/kowainik/tomland/blob/efd67b3f1b3af41eb4b57736871173a99112606e/src/Toml/Prism.hs#L47
02:42:58 <kuribas> vrom911: ah, nice
02:46:15 <ocramz> hullo!
02:56:51 <ocramz> once we have a Generic representation of a datatype, what can we do with it?
02:57:24 <ocramz> I mean I know there are a bunch of serialization/deserialization libraries that rely on Generic, but what other uses are there?
02:58:06 <ocramz> for example, if I have two types that are structurally isomorphic (i.e. same # of constructors, and each having same structure of fields), can I convert generically one to the other?
02:58:48 <lavalike> ocramz: recently I discovered you can use Generic to provide `deriving' for your own classes
02:59:16 <ocramz> oh, that's very neat :)
02:59:51 <lavalike> agreed!
03:10:36 * hackage exchangerates 0.0.0.0 - A Haskell client for https://exchangeratesapi.io/  http://hackage.haskell.org/package/exchangerates-0.0.0.0 (Norfair)
03:23:15 * hackage genvalidity-hspec-optics 0.0.0.0 - Standard spec's for optics  http://hackage.haskell.org/package/genvalidity-hspec-optics-0.0.0.0 (Norfair)
03:39:22 <NoEtas> If anyone has a moment, I have a question about -XDataKinds. Is this the right place to ask?
03:41:05 <liste> NoEtas: yes it is
03:41:12 <NoEtas> liste: Thank you.
03:42:23 <NoEtas> So with DataKinds, I can have some type of kind Foo. Does that mean that I can't have a function that uses or produces that type since `(->) :: * -> * -> *` and * is not Foo?
03:44:37 <josser> NoEtas: yes
03:48:42 <NoEtas> Okay, so how can you have a GADT that takes something of kind Foo as a type parameter? Something like this StackOverflow answer does: https://stackoverflow.com/questions/20558648/what-is-the-datakinds-extension-of-haskell#20558716
03:49:10 <NoEtas> Is the `->` at the Kind level different from `->` at the type level?
03:51:10 * hackage servant-stache 0.1.0.0 - Content-Types for rendering Mustache in servant  http://hackage.haskell.org/package/servant-stache-0.1.0.0 (lotz)
03:55:47 <alp> why not servant-mustache? =)
03:57:09 <lyxia> NoEtas: you can have functions that use or produce Foo
03:57:42 <lyxia> NoEtas: (->) :: * -> * -> * and Foo is of kind *, so (Foo -> Foo) is well-kinded
03:58:10 <lyxia> and an example of that is        type family F (x :: Foo) :: Foo
04:04:07 <NoEtas> Oh! I think I get it! You couldn't have a function at the value level (a -> b) where (b :: Foo), because that wouldn't be well-kinded, but you could have a function at the type level (a type family) (a -> Foo) since, as you say Foo is of kind *.
04:04:21 <NoEtas> Thank you, that makes so much more sense.
04:18:48 <Athas> I need to test a command line tool.  It's conceptually simple: run a command, then check its output (which may also involve checking the state of the file system).  I could do this with a shell script, but you know...
04:18:54 <Athas> Is there a nice way to write such tests in Haskell?
04:22:45 <Athas> Hm, test-framework-golden...
04:22:55 <koz_> Athas: http://dev.stephendiehl.com/hask/#silently <-- maybe?
04:23:36 <Athas> Oh, I know how to capture the stdout.  I was just looking for nice combinators to explain the expected results and such.
04:23:43 <Athas> But it looks like tasty might have it.
04:27:42 <Athas> Too bad it doesn't have a function for matching directory trees.  Oh well.
04:28:44 <infinisil> You could abstract the filesystem and use a pure implementation for testing
04:29:28 <Athas> I need to test an actual binary, so that won't fly.
04:29:31 <revskill> cocreature: I tested, servant failed at first failed parse, it can't try next endpoint
04:30:59 <alp> revskill, IIRC we relaxed the behaviour a little bit in a very recent version
04:31:02 <alp> maybe even the latest
04:31:06 <alp> let me dig the PR
04:31:16 <revskill> alp: what do you mean ?
04:31:34 <revskill> this is my test API:
04:31:37 <revskill> type GraphQLAPI1 = ReqBody '[JSON] IntData :> Post '[JSON] IntData
04:31:37 <revskill> type GraphQLAPI2 = ReqBody '[JSON] TextData :> Post '[JSON] TextData
04:31:38 <revskill> type GraphQLAPI = GraphQLAPI1 :<|> GraphQLAPI2
04:32:13 <revskill> when i test with { "textVal": "sometest" }, it told me: Error in $: key "intVal" not present
04:32:21 <alp> revskill, https://github.com/haskell-servant/servant/pull/937
04:32:47 <alp> previously, we'd just try the first one and "abort" if the decoding fails
04:32:56 <alp> since this PR, we try the second one
04:33:06 * hackage ghc-typelits-presburger 0.2.0.2 - Presburger Arithmetic Solver for GHC Type-level natural numbers.  http://hackage.haskell.org/package/ghc-typelits-presburger-0.2.0.2 (HiromiIshii)
04:33:18 <revskill> ah, you mean if we have 3 endpoints, it'll try all 3 options ?
04:33:27 <alp> yes, if they all live under the same path
04:33:48 <revskill> it's super cool. Let me try with latest servant code. Huge thanks.
04:33:52 <alp> oh hang on
04:33:57 <Akii> time is such a fun topic; anyone into leap seconds? https://lpaste.net/683180287198232576
04:33:57 <alp> maybe the content type has to be different
04:33:59 <alp> I'm not sure
04:34:05 <alp> you better try it out
04:34:12 <alp> but yeah you need servant >= 0.14
04:36:06 <alp> also, IIRC, this behaviour is not required to implement the HTTP spec properly
04:37:42 <revskill> in this case, what will client api look like ?
04:38:24 <alp> you'd get two functions, one IntData -> ClientM IntData, one TextData -> ClientM TextData
04:38:46 <alp> (postInt :<|> postText) = client (Proxy :: Proxy GraphQLAPI)
04:39:25 <c_wraith> Akii: yeah, time is fun.  here are some thoughts about that issue.  1) a pure API for that function can't be correct. 2) That issue is why the time package has a NominalDiffTime type
04:39:49 <Akii> c_wraith so it must be using the NominalDiffTime here, right?
04:40:23 <c_wraith> Akii: well, the same idea as NominalDiffTime, but without the type-level indication
04:41:23 <c_wraith> Akii: for what it's worth, POSIX time makes a mess of the topic too, by introducing non-monotonic timestamps after leap seconds
04:41:57 <Akii> in my code I need to calculate the remaining seconds of the day; which I do by subtracting the time from midnight from 86400
04:42:13 <Akii> and I have the feeling that this will fail horribly for leap seconds _if_ they're considered
04:42:41 <Akii> if not it's all fine, it's just that constant 86400 that screams "i'll break"
04:44:27 <c_wraith> There are other cases.  Google runs their system clocks on a policy of "all days have 86400 seconds", and they smear leap seconds over the day in which they happen.  Thus they always have the same number of timestamps (at second granularity) per day, in exchange for seconds sometimes being a tiny bit longer
04:44:45 <c_wraith> which sounds horrifying
04:45:02 <c_wraith> But has a lot of value if you're not doing high-precision timing
04:45:25 <c_wraith> (with the system clocks)
04:45:27 <Akii> all I really want to do is given a UTCTime range to have a Map Day Integer where integer are the number of seconds are in the range
04:45:53 <Akii> sooo I don't think I really want to deal with leap seconds, 1440 as "the whole day" is enough
04:47:44 <Akii> totally not ugly code https://lpaste.net/276991013673762816
04:47:52 <Akii> but I couldn't come up with something smarter
04:49:13 <c_wraith> why is there a Show constraint on a?  Oh, were you using Debug.Trace at one point?
04:49:44 <Akii> ah yes, unsafePerformIO print combo
04:49:52 <Akii> I've been debugging this more than I want to admit
04:50:11 <c_wraith> pff.  Use Debug.Trace.  Let it get the unsafePerformIO right for you. :)
04:50:26 <Akii> yeah didn't think about that
04:50:36 * hackage focus 1.0.1.1 - A general abstraction for manipulating elements of container data structures  http://hackage.haskell.org/package/focus-1.0.1.1 (NikitaVolkov)
04:52:13 <Akii> so worst case secondsUntilNextDay would be -1, I'd add a PIT with 0 minutes and increase the total duration by one second
04:53:01 <c_wraith> if you're exploring theoretical cases, remember that double leap seconds are allowed, though none have ever been issued
04:55:36 * hackage focus 1.0.1.2 - A general abstraction for manipulating elements of container data structures  http://hackage.haskell.org/package/focus-1.0.1.2 (NikitaVolkov)
04:55:54 <Akii> that's good to know
04:56:36 * hackage ghc-typelits-presburger 0.2.0.3 - Presburger Arithmetic Solver for GHC Type-level natural numbers.  http://hackage.haskell.org/package/ghc-typelits-presburger-0.2.0.3 (HiromiIshii)
05:04:48 <revskill> alp: I updated to 0.14.1, but the error is still the same :|
05:07:57 <alp> revskill, can you open an issue with a complete runnable program that we can poke at to see what's going on?
05:08:06 <alp> at https://github.com/haskell-servant/servant/issues
05:08:31 <revskill> alp: If this is an unexpected behaviour, then yes, i'll open an issue
05:09:35 <revskill> alp: This is the api: https://pastebin.com/2HUDHCMg
05:10:10 <alp> revskill, well, like I said, I'll have to look at the code (your program's as well as servant router's) to see what exactly is going on
05:11:44 <alp> I don't really have time for this right now, tonight is more likely to be a good time for me, so yeah, just stick the complete program in a new issue. we don't mind having plenty of those, they're quite easy to close if they turn out to be non-issues :)
05:14:18 <revskill> alp: thanks for you time. This is complete program if you wanna pick: https://github.com/revskill10/circle-haskell/blob/html/core/Lib.hs
05:15:04 <revskill> the route for GraphQL is at Handlers/Json/GraphQL.hs
05:18:58 <alp> revskill, ok I'll open an issue with a link to this
05:21:01 <alp> revskill, https://github.com/haskell-servant/servant/issues/1017 <- you might want to subscribe to it, as giving updates and explanations will likely be easier there than here =)
05:21:57 <revskill> alp: Already subscribed. :)
05:33:24 <hjt> has anybody played around with idris ? wondering how similar it is to haskell
05:33:36 * hackage xmonad-extras 0.13.4 - Third party extensions for xmonad with wacky dependencies  http://hackage.haskell.org/package/xmonad-extras-0.13.4 (psibi)
05:35:36 * hackage type-natural 0.8.2.0 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.8.2.0 (HiromiIshii)
05:36:27 <madknight> is it possible to limit ghci warnings to only show the first error on :r ?
05:37:09 <madknight> s/warnings/errors/g
05:37:15 <sm> madknight: I haven't heard of a way, but ghcid is good for this
05:42:00 <cocreature> the -freverse-errors option might also be helpful if you don’t want to use ghci
05:42:02 <cocreature> *ghcid
05:43:59 <madknight> cocreature, thx that fits the bill
05:44:09 <__monty__> hjt: It's mostly just the syntax that's similar. It's strict, it's dependently typed, it's not haskell : )
05:46:33 <hjt> __monty__: i know about the dependent typing (it's why i'm interested), but i thought that haskell was strict?
05:47:07 <__monty__> hjt: No, laziness is kinda *the* distinguishing feature for haskell.
05:47:20 <hjt> oh it's strict in that sense, i see
05:47:54 <__monty__> Not sure what other sense you expected. I'm talking about call-by-need vs call-by-value.
05:48:14 <hjt> sorry, still learning all the lingo!
05:48:45 <__monty__> It's fine, those are the terms to google : )
05:48:48 <hjt> can you force strictness in haskell? with `seq` or something?
05:49:24 <__monty__> Yes, it's neither easy nor straightforward though.
05:49:39 <c_wraith> hjt: you can, but it's subtle.  You need a good mental model of how strictness works in order to do it so that it's both sufficient and efficient
05:50:13 <c_wraith> Otherwise you end up with either useless seq calls or constantly wasting time evaluating things that have already been evaluated
05:50:21 <hjt> ah ok, i see
05:50:33 <madknight> hjt, https://prime.haskell.org/wiki/BangPatterns
05:51:25 <hjt> madknight: this looks like a nice way of dealing with it
05:53:37 <hjt> what about dependent types in haskell? is there some way of defining them?
05:53:57 <c_wraith> You can do things that simulate them, but they're painful
05:54:06 <__monty__> hjt: Look up hasochism : )
05:54:15 <c_wraith> There's a reason the practice of encoding dependent types in haskell is called...  yeah, hasochism
05:54:20 <__monty__> There's ongoing work to make it less of a pain though.
05:54:37 <mbwgh> Question: Asume that you have some type `data SomeType = A | B | C | ...` and you have some function that treats elements of that type as belonging to different categories. However, the caller should be able to choose what goes where. You could have `f :: Set SomeType -> Set SomeType -> ..` but then you have to do a run-time check to ensure that the sets don't overlap, i.e. that the intersection is empty.
05:54:43 <mbwgh> Also some elements could be missing, while others *should* be missing. An alternative would be to introduce phantom type parameters or a GADT: `data SomeType (c :: SomeTypeCategory) where A :: SomeType c; B :: SomeType c; C :: SomeType 'Reserved` for some `data SomeTypeCategory = Category1 | Category2 | Reserved` and a corresponding f, maybe like `f :: (forall c. SomeType c -> Either (SomeType 'Category1)
05:54:49 <mbwgh> (SomeType 'Category2)) -> ..`. Now I am able to exclude `SomeType 'Reserved` and the user is able to decide how to treat `A` and `B`. Still, the function need not be injective, that is it could collapse `f A -> Left A; f B -> Right A` (maybe injective isn't the right word here, but you can see that cheating is possible). Is there a way to address this without making things overly complicated?
05:55:29 <madknight> hjt, i think if you want to experiment with DT then you should go with Idris, otherwise if you want DT in production, then you better wait until Haskell adds them
05:55:29 <__monty__> hjt: If you're Pi-curious ; ) I recommend trying out Agda, it has some interesting differences from haskell like the mixfix syntax.
05:56:19 <hjt> i've been looking at agda and idris, but from what i read it seems that idris is more suited to 'everyday' programming
05:57:12 <hjt> basically i use haskell at the moment to calculate some abstract algebra things, and i just wanted to be able to ensure that types i constructed satisfied certain axioms automatically
05:57:38 <hjt> but it seems that in haskell the common practice is to just assume that any Functor (for example) satisfies the functor laws
05:58:08 <__monty__> Yes and we frown real hard at people when they make unlawful instances : )
05:58:15 <madknight> hjt, there's also https://ucsd-progsys.github.io/liquidhaskell-blog/
05:58:32 <hjt> __monty__: haha that seems like an effective way of doing it
05:58:55 <__monty__> Tbh, the marketing around idris is very "this is a practical programming language" but neither of idris and agda are really up to the task yet afaik.
05:58:57 <hjt> madknight: i've never seen this before!
05:59:31 <__monty__> Agda is more interesting imo because it's more different but either of them or coq'll do for your use case probably.
05:59:35 <hjt> madknight: how stable/well-used is this?
06:00:00 <hjt> __monty__: yeah, coq seems to be the standard, but i've just really fallen in love with haskell to be honest...
06:00:02 <__monty__> There's also https://github.com/antalsz/hs-to-coq
06:00:15 <hjt> also the big thing putting me off agda is emacs
06:00:45 <hjt> oh hs-to-coq seems interesting
06:01:28 <__monty__> Emacs is great, you should give it a shot. I stuck with vim afterwards but I understand the emacsers better now.
06:02:24 <madknight> hjt, I never used it, I heard about it in a podcast a while ago, I think it's pretty stable (exists since 2012 and actively maintained), it nicely integrates with Haskell
06:02:30 <hjt> __monty__: maybe i will... just spent so long getting used to vim/sublime text that the move to emacs seems like a scary step
06:02:35 <__monty__> Other specification approaches are interesting too btw and usually more user friendly than dependent types, things like TLA⁺.
06:02:44 <hjt> what's TLA?
06:03:32 <__monty__> Temporal Logic of Actions, it's a first order logic you can use to specify your algorithm's behavior in at whatever level of abstraction you want.
06:05:45 <hjt> __monty__: it seems pretty in depth
06:06:06 <hjt> wish i had the time to really get into things like this, but sadly maths comes first!
06:06:18 <__monty__> But it *is* math : p
06:06:39 <hjt> haha true, but i somehow don't think that my supervisor will see it like that :P
06:07:12 <__monty__> Oh, if you have to do dependent types then yeah, don't look at model checkers and the like.
06:07:27 <reactormonk> Given Generics.SOP, I want to convert any function like (a -> b -> c -> ...) into NP I '[a, b, c] -> ... - how would I do that?
06:07:36 <hjt> this LiquidHaskell stuff seems to be really nice
06:07:53 <hjt> you can specify laws about functions (like associativity) at compile time
06:07:58 <hjt> seems like it should be enough for me
06:08:35 <__monty__> There's also SHE, not sure if that's still around but it involved Conor McGregor so it must've been good dependently typed stuff.
06:09:47 <keegans_> do i push my .cabal file if i have a package.yml and stack.yml ?
06:14:42 <lyxia> reactormonk: https://gist.github.com/Lysxia/97fbf2514cfb98878d6a9903acfb9ee3 modulo making it compile
06:16:03 <reactormonk> lyxia, I think I'll have to put you down as a coauthor to my library
06:16:20 <madknight> keegans_, you don't have to, but it is more convenient for people who don't build with stack (e.g. with nix instead)
06:16:50 <lyxia> hahaha
06:18:28 <mbwgh> Can I non-dependently-typedly guarantee that some function is injective in Haskell?
06:18:39 <keegans_> madknight: noted, thanks.
06:20:04 <__monty__> mbwgh: f :: a -> a can only be injective : >
06:21:11 <reactormonk> lyxia, Occurs check: cannot construct the infinite type: x ~ I x on the (f a) in uncurry_
06:22:06 <reactormonk> ah, had to add a (I a) unpacking
06:22:19 <reactormonk> Nice, it compiles. Now to understand it...
06:31:18 <kuribas> If I have "type ReadableAttribute s a = forall r. Attribute (Const r) s a"  Can I make a functor of it?
06:31:56 <c_wraith> I don't see why not
06:32:24 <kuribas> I tried, but I get Expected kind '* -> *' ...
06:32:39 <c_wraith> what does your instance head look like?
06:32:44 <c_wraith> Oh, nevermind
06:32:54 <c_wraith> No, it's a type synonym
06:33:03 <c_wraith> You can't create instances for synonyms
06:33:21 <kuribas> hmm, ok
06:36:04 <keegans_> if anyone can spare any time, i'd hugely appreciate some code review for part of a haskell application i wrote : https://pastebin.com/7kR4mJH1
06:36:26 <keegans_> like, if anything looks dumb, i can make anything more concise, i did anything dangerous, please let me know
06:36:42 <keegans_> it interfaces with a remote site which it scrapes and caches in a Redis database, then serves
06:41:38 <hjt> stack build tells me to add a package to my extra-deps in stack.yaml, but it's already there
06:41:51 <hjt> and if i add it again in a new line it complains that i've listed it twice
06:43:23 <cocreature> hjt: please show us the full error and your stack.yaml file
06:44:44 <hjt> cocreature: what's the easiest way to do that? link to a screenshot?
06:45:01 <cocreature> use some pastebin site, e.g., github gists which is linked in the topic
06:46:21 <dredozubov_> https://image.prntscr.com/image/t1VVVHspRw6ZE2mCyABEMA.png GC sweep happened after half an hour of idling or so. Any ideas how to debug such an issue?
06:47:45 <hjt> https://pastebin.com/5DFNWZFf
06:49:25 <madknight> hjt, have you ever considered a switch to nix builds? https://chris-martin.org/2017/nix-for-stack-users
06:49:39 <hjt> i heard about nix very recently
06:49:47 <hjt> that sounds nice
06:50:19 <hjt> i just switched from using cabal to using stack
06:50:25 <madknight> hjt, nix := no trouble with stack anymore :)
06:50:25 <hjt> is it worth using nix then?
06:51:06 * hackage dhall-to-cabal 1.3.0.0 - Compile Dhall expressions to Cabal files  http://hackage.haskell.org/package/dhall-to-cabal-1.3.0.0 (OliverCharles)
06:52:53 <hjt> madknight: this actually looks really useful, because you can have non-haskell dependencies
06:54:42 <noipmups> How to turn type `IO [Either e1 ()]` into `IO Either e2 ()`?
06:54:44 <madknight> hjt, yup and if you already have a working cabal file, then you can use cabal2nix https://github.com/NixOS/cabal2nix to convert it to a nix build
06:55:12 <lyxia> noipmups: IO Either e2 () doesn't make sense
06:55:30 <hjt> madknight: and how can you ship nix builds? i'm guessing the user needs nix installed etc
06:56:23 <noipmups> lyxia: Then how can I indicate that IO operation failed?
06:57:37 <wuffie[m]> maybe you could raise an ioError
06:57:41 <madknight> hjt, nix integrates with cabal, so other devs might simply use cabal, stack, nix or a custom makefile
06:58:23 <lavalike> noipmups: do you mean IO [Either e2 ()] ? or IO (Either e2 ())
06:58:23 <cocreature> hjt: the version of base is tied to the version of GHC. you cannot upgrade or downgrade it by adding base to extra-deps
06:58:52 <noipmups> lavalike: Oh, sorry, I mean IO (Either e2 ()).
06:59:24 <lavalike> noipmups: sequence would do the former, then I guess fmap msum or something similar
06:59:33 <kuribas> If I have atype (MyType f a), and I want to make (MyType (Const a)) a functor, is that possible?
06:59:50 <cocreature> hjt: you need to choose a resolver that comes with the GHC version corresponding to the version of base
06:59:51 <lavalike> kuribas: yes you need a newtype for it and you're set
07:01:00 <kuribas> lavalike: not quite what I wanted though...
07:01:11 <lavalike> isomorphic to what you wanted :D
07:01:34 <kuribas> just not convenient to have to wrap it in order to use the functor instance
07:02:03 <lavalike> I wonder if there's an extension that would let type synonyms get instances that way
07:02:09 <noipmups> lavalike: Is there a function similar to `either`, but working on list of Either (like if list contains any Left, apply first function, otherwise apply second function)?
07:02:21 <lavalike> noipmups: (<|>)
07:02:32 <lavalike> noipmups: oh sorry misread the question!
07:03:26 <lavalike> > Left "1" <|> Left "2" <|> Right 3 <|> Left "4" :: Either String Int
07:03:28 <lambdabot>  Right 3
07:03:30 <lavalike> I thought you were asking for this
07:03:32 <lyxia> noipmups: what do you want to apply the second function to
07:03:49 <noipmups> lyxia: id
07:04:03 <lavalike> could it simply be something like mapEither
07:04:21 <lavalike> hmm no that's not the name
07:04:40 <hjt> cocreature: ah i think i get it, thanks
07:04:50 <hjt> first time setting up a stack project
07:06:02 <kuribas> it should be possible to curry type synonyms.
07:06:11 <lavalike> > bimap reverse (*100) <$> [Left "spumpion", Right 3]
07:06:12 <lambdabot>  [Left "noipmups",Right 300]
07:06:15 <kuribas> like type level lambdas
07:07:34 <lavalike> noipmups: is that what you're after?
07:10:47 <hjt> oh, you can use nix within stack
07:11:12 <noipmups> lavalike: Not sure... Anyway, thank you for your help. I probably need to rethink my problem.
07:11:31 <__monty__> hjt: I've heard 0 positive comments about stack's nix support.
07:11:40 <hjt> __monty__: ah, i see
07:11:45 <lavalike> noipmups: np! (:
07:13:08 <hjt> __monty__: what about styx?
07:13:24 <hjt> __monty__: there seem to be a bunch of different wrappers for using nix with haskell projects
07:13:33 <__monty__> hjt: Haven't heard anything about it : )
07:14:05 <hjt> __monty__: can i still `stack new ProjectName`, or should i just manually make a new directory etc
07:16:10 <madknight> hjt, i cannot not recommend to use stack + nix, i would either use cabal + nix or cabal + stack
07:16:18 <__monty__> hjt: Depends on the tool you use. Stacks templates would work with nix I guess, I do my own thing though.
07:17:00 <hjt> cabal + nix seems nice enough
07:17:20 <barrucadu> I use stack+nix, it works for my simple use-case (which is just bringing non-Haskell packages from nixpkgs into scope)
07:18:44 <madknight> barrucadu, yes okay, for this use case it might be alright
07:20:01 <hjt> if i want to have a dependency that isn't on nixpkgs then is it worth using nix?
07:20:40 <hjt> ignore that actually, the package is on nixpkgs
07:20:58 <dmj`> hjt: you can fetch source from anywhere w/ nix
07:21:18 <dmj`> hjt: and many builders often times just work out of the box if the build for the package is sane
07:21:46 <__monty__> hjt: If it's not you package it : ) (a joke but that's basically what you need to be willing to do to be a productive nix user, it's the nicest method imo but it also takes the most effort).
07:25:40 <Gurkenglas> How do I get go-to-definition source in VS Code? The one I have only works sometimes.
07:26:06 <Gurkenglas> (um, not the source of a gotodefinition feature, but a gotodefinition feature that leads me to a definition's source)
07:47:10 <fvh> Does anyone have experience working with hs-web3? I'm trying to create raw transaction and stuck with callData field.
07:55:05 <hodapp> hm. Wonder if there is much precedent for turning, say, a specific XML schema into a DSL via templates of some kind
07:55:58 <hodapp> made me think of Go's html/template, in which one just writes HTML with some special directives inserted
07:56:22 <hodapp> but instead tailored to the nuances of the XML in question
08:01:30 <hodapp> there is probably a single short term for this if I look... and it is probably well-studied :P
08:05:36 <dmj`> glguy: ping
08:06:42 <dmj`> glguy: had a question about config-value single line comments, how does this rule https://github.com/glguy/config-value/blob/master/src/Config/Lexer.x#L60 know to terminate on a new line, or does it
08:08:12 <glguy> dmj`: The . doesn't match newlines
08:08:45 <glguy> so,   "--" .*   drops the comment but not the newline and then $white+  above drops the newline
08:11:25 <dmj`> glguy: ah, a spec I have uses ‘#’ to start a single line comment, I had this rule: @comment = \# ($sourceCharacter+)? \\n  , but it would cause lex failures
08:11:46 <dmj`> where $sourceCharacter = [\x0009\x000A\x000D\x0020-\xFFFF]
08:13:41 <glguy> Why two \ before n?
08:13:54 <glguy> and is  ($sourceCharacter+)? different from $sourceCharacter* ?
08:14:18 <glguy> Why does source character cut things off after \xffff ?
08:15:24 <glguy> why are \r and \n in your source character set?
08:16:25 <dmj`> two \ before n is wrong
08:16:31 <dmj`> how is + different from * ?
08:16:44 <glguy> + means one-or-more, * means zero-or-more
08:16:53 <dmj`> ah :)
08:17:21 <dmj`> the source character set is defined as /[\u0009\u000A\u000D\u0020-\uFFFF]/
08:17:27 <dmj`> in the lexical spec
08:17:39 <glguy> that allows your # comment to eat the rest of the file
08:18:24 <dmj`> glguy: I forgot to add the # @lineTerminator
08:18:30 <glguy> What language are you parsing? cutting off the range 0x10000 through 0x10ffff seems like an artifact of an old spec
08:18:49 <dmj`> where @lineTerminator = (\n | \r\n)
08:18:52 <hjt_> can you use LiquidHaskell to do something like enforce class laws? I can't find any examples online
08:21:13 <madnight> hjt_, https://arxiv.org/pdf/1708.02328.pdf "With Liquid Haskell, these type class laws can be encoded as refinement type specifications."
08:21:36 <hjt_> madnight: oh that's perfect, thanks!
08:22:59 <dmj`> glguy: I wish macros could follow # in alex
08:23:52 <revskill> nix actually saves Stack. Stack users are happy for speedy compiling time comparing to nix :(
08:25:29 <madnight> revskill, i think stack and nix builds can peacefully co-exist in the haskell community
08:27:12 <revskill> madnight: i don't know any build system that can be more slower than nix. It's probabily the slowest in the world in building time.
08:27:14 <__monty__> revskill: What? I just use cabal with nix so I get incremental builds that way. How is stack faster?
08:27:40 <revskill> __monty__: how can you get incremental builds ?
08:27:52 <__monty__> Cabal just does so by default.
08:28:00 <hjt> sorry to be off-topic, but could somebody just pm me anything? testing out notifications...
08:28:21 <monochrom> Perhaps nix is slower in building one thing but stack keeps rebuilding more things.
08:29:12 <revskill> the worse things happen when you wait for nix building its things, and in the end, things got broken :)
08:29:12 <monochrom> s/Perhaps/Perhaps it's because/
08:30:07 <hjt> sorry to be off-topic, but could somebody just pm me anything? testing out notificationslas/ut/u
08:30:08 <__monty__> revskill: Sounds like you're talking about upgrading your entire haskell environment? That's definitely not something you do every time you want to compile your package.
08:30:25 <madnight> revskill, with nix you have incremental builds via cabal
08:30:31 <revskill> __monty__: no, i just move files around, no change in deps
08:30:51 <__monty__> revskill: And then how do you build the package?
08:30:56 <revskill> but holy grails, it's trying to do intelligent things by rebuilding deps
08:32:00 <revskill> __monty__: I just use nix-build .
08:32:21 <__monty__> Well yeah, then you don't get anything incremental.
08:32:41 <__monty__> Fwiw, that's not how anyone uses nix for haskell development afaik.
08:32:51 <cocreature> nix rebuilding deps if you don’t change anything sounds wrong
08:33:13 <revskill> __monty__: hm, so how to get things incrementally build then ?
08:33:38 <__monty__> Just cabal new-build.
08:33:53 <__monty__> Or build if you don't like new-fangled things : )
08:34:13 <madnight> revskill, thats a total overkill just use: nix-shell --run 'cabal build'
08:34:24 <revskill> hm, nix-build is stupid. It will download and recompile everything before TYPE checking
08:34:38 <cocreature> enter a shell and use cabal to build your project
08:36:16 <madnight> you could also just simply type `nix-shell` and then you're "inside" the nix env and you can use all the usual cabal commands and other executables
08:36:21 <__monty__> revskill: Read the section in the nixpkgs manual, it's all in there.
08:36:51 <__monty__> Not *all* the usual commands you wouldn't cabal install when using nix.
08:36:55 <cocreature> you can’t just type nix-shell, you need something like nix-shell -A env
08:37:26 <madnight> __monty__, sure you can for testing purposes, why not?
08:38:01 <revskill> cocreature: yes, nix-shell -A env is the correct way to do here
08:38:15 <__monty__> There's alternatives to nix-shells if you don't like those btw.
08:38:36 <__monty__> madnight: Why would you want cabal to be managing part of your deps?
08:38:52 <madnight> cocreature, whats the difference between nix-shell and nix-shell -A env?
08:39:01 <cocreature> one works properly one doesn’t :)
08:39:10 <__monty__> Unless you have a shell.nix.
08:39:31 <madnight> i have a default.nix
08:39:37 <cocreature> whether you put things into your shell.nix or not doesn’t matter. you need to enter the .env attribute. ofc you can hardcode that in your shell.nix
08:40:03 <madnight> __monty__, i use cabal2nix, so i manage my deps via cabal
08:40:32 <madnight> __monty__, i dont even know how to write any nix files, i just use it as a simple build system
08:40:46 <__monty__> madnight: No, you specify deps in a cabal file but you actually use nix to manage them : >
08:41:55 <madnight> __monty__, yes, but "cabal install" makes sens inside of nix-shell if you want to test a new dep, but you are not sure if you want to add it
08:42:40 <__monty__> I guess, haven't had that happen.
08:44:59 <madnight> __monty__, it happens to me in cases where i have different library options (e.g. array, vector, sequence, repa) and i quickly want to try them to find out which one suits best for the use case
08:46:29 <__monty__> Yeah, I can imagine. I usually just try to find comparisons by people more competent than me ; )
08:49:38 <madnight> i can also recommend this tiny shell function (ideal for bashrc/zshrc) https://lpaste.net/5902327479036542976
08:51:31 <mbwgh> Is there some typeclass that encapsulates lifting a rank-2-polymorphic function over an existential wrapper? So if I have some GADT `data MyGADT a b where Inj1 :: .. -> MyGADT 'A1 'B1; ..` and a wrapper SomeGADT where S1 :: MyGADT 'A1 'B1 -> SomeGADT; ..`, I need something like `liftGADT :: Functor f => (forall a b. MyGADT a b -> f (MyGADT a b)) -> SomeGADT -> f SomeGADT`. It kind of looks like a lens now
08:51:37 <mbwgh> that I think about it, but may there is some other established abstraction for this kind of thing?
08:52:05 <mbwgh> *maybe
08:52:47 <madnight> it allows you to run e.g. "ghci-with vector mtl lens" and starts a ghci shell with the packages you want, everything pulled from binary cache
09:11:39 <hjt_> quit
09:11:45 <hjt_> woops...
09:29:36 <dataN> ok, so "implicit parameters" allows both a class and a local instance for it to be defined easily. This means that constraint reification is only useful for making local instances for classes defined at top level.
09:30:15 <dataN> where implicit parameters are declared and used in some subscope
09:37:05 <dataN> both options have the advantage over passing values such as functions as arguments that the order of such arguments is not taken into account, constraint declarations being commutative. This means that the existence of functions which are equivalent upon permutation of arguments can be disambiguated.
09:37:38 <dataN> or, made ambiguous rather...
09:39:24 <dataN> as well as the obvious utility of hiding arguments that are required by constituent functions in the definition of a function which require access to the arguments of the function they are used in defining.
09:40:42 <dataN> i.e. constraints can be inherited, and conversely passed easily to the scope in which the function which demands them is used.
09:41:08 <dataN> scope = function definition*
09:43:56 <dataN> then the question is "why would reified constraints be useful, isn't it that classes are declared at top level precisely because they should be instantiated at top level, meaning only one valid definition should ever exist"
09:45:34 <dataN> the answer to which is no, classes are often declared at top level so that they can be used in defining functions, regardless of how they are to be instantiated, and sometimes there can be many valid implementations of a class, e.g. Monoid via Sum and Product.
09:52:25 <dataN> reasons for using global classes over implicit parameters include; the understanding that laws associated with a class are satisfied by its instances, their use as synonyms for collections of named class functions, and the ability to typecheck for the existence of top level instances.
09:54:52 <dataN> reified constraints go on to provide a useful interface for (among other uses) defining default instances of one class in terms of another, such as implementations of a superclass using the functions defined by its subclasses.
10:02:12 <gentauro> cocreature: hey. I was just introduced today to a "new friend". My new friend is called: {-# LANGUAGE Strict #-}
10:02:36 <cocreature> gentauro: heretic!
10:02:53 <gentauro> well, you aren't expecting me to use `seq` here and there right?
10:03:20 <gentauro> cocreature: at least it keeps my memory consumptions to a minimum
10:03:21 <cocreature> I’m expecting you to use bang patterns :)
10:03:44 <gentauro> I begin to look deeper into space leaks and ended up with a recent blog post from Simon Marlow
10:04:17 <gentauro> https://simonmar.github.io/posts/2018-06-20-Finding-fixing-space-leaks.html
10:12:30 <dataN> what about space leaks and unsafeCoerce?
10:12:59 <dataN> maybe its more difficult for the compiler to reason about?
10:28:06 * hackage cabal-rpm 0.12.5 - RPM packaging tool for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.12.5 (JensPetersen)
10:31:44 <revskill> Anyone using Miso framework here ? When you're using GHCJSi , and at the same time you run server to render html, how to get updated compiled Miso js ?
10:37:15 <gentauro> revskill: nope, but since you are using Haskell to Web. Do you know of anything that will convert Haskell to Raw HTML (without JS)
10:37:45 <gentauro> I'm aiming to create a basic site that could be browsed by wget / curl / links and so
10:37:53 <revskill> I see Lucid is good to convert Haskell to raw html
10:37:53 <madnight> gentauro, https://jaspervdj.be/hakyll/
10:37:57 <gentauro> (HTML client without support for JS)
10:38:21 <revskill> Lucid is a real Monad, you can work with it like every other Haskell type
10:38:30 <Akii> Blaze? If you need templating Sharkespeare?
10:38:34 <Akii> Shakespeare*
10:38:48 <gentauro> madnight: "Integration with pandoc gives us markdown and TeX support, including syntax highlighting and other goodies." I'm sold (take my money !!!)
10:39:13 <Akii> I use pandoc md to blaze as well
10:40:09 <Akii> what is a "HTML client"?
10:42:44 <gentauro> Akii: something that can retrieve HTML
10:42:49 <gentauro> like curl / wget
10:43:05 <gentauro> a browser is still a HTML client, but with a bit more
10:43:14 <Akii> yeah gotcha
10:43:26 <Akii> use wreq, http-client
10:43:32 <cocreature> http client might be a better name
10:43:54 <Akii> and then depending on what you want to do with the html another library such as blaze or tagsoup
10:47:22 <Akii> cocreature only if that HTML is transmitted by the HTTP protocol :P
10:47:49 <Akii> also I don't think curl / wget "retrieves HTML", it retrieves whatever
10:48:37 <cocreature> right, that’s why I said “http client” might be a better name :)
10:49:52 <gentauro> cocreature: I somehow agree ;)
10:49:59 <Akii> convenient that there is a library called just that!
10:54:41 <Akii> gentauro if you can get into more details I can probably help you
10:55:00 <dataN> wow, so many libraries! so which of those was for displaying the html? and which were for getting the html from a url such as http-client?
10:55:47 <Akii> dataN what do you mean by "displaying"?
10:56:46 <dataN> like a web browser
10:57:25 <dataN> not just plaintext html, with all the textboxes whatever else it is, not sure of the standard
10:57:25 <Akii> so you mean a haskell library that renders html into a gui or smth?
10:57:47 <Zemyla> I really wish there were a MutableInteger that used the GMP library to keep a single memory location updated.
10:57:53 <Zemyla> *single block of memory
10:58:20 <Akii> what you normally do is render the HTML and send it to a user agent for interpretation
10:58:56 <dataN> Akii, sure something like that. also there was Web-GL, but thats confusing things, as in, its a way to use a browser as GL whereas GL could be used to write a browser...
10:59:51 <Akii> that reminds me of that horror game where you have to browse the dark net
11:02:30 <dysfun> dataN: you should write a browser in webgl
11:06:02 <dataN_> maybe whats needed it haskell support for html5 or css...
11:06:09 <dataN_> do we have that?
11:08:24 <Akii> what do you mean by that?
11:10:12 <dataN_> dysfun: the point is that browsers are so powerful that haskell programs can be written to target them, so that e.g. WebGL can be used instead of OpenGL to be run in the browser instead of a window, with the advantage of then having all the communication protocall of a web app, but at the expense probably of some of the GL features depending on how good the WebGL porting is
11:11:54 <nullie> you can write purescript
11:12:06 <dataN_> Akii, two questions; how to view a webpage after the htlm has been downloaded from some url, and how to support more sophisticated features such as e.g. WebGL
11:12:32 <Akii> wat
11:13:46 <dataN_> can you clarify that?
11:14:51 <Akii> there are very sophisticated programs that specialise in viewing websites, they're called browsers. I'm not getting where Haskell needs more support
11:15:03 <madnight> If you want to write a web application with Haskell i can recommend miso https://github.com/dmjio/miso
11:15:12 <Akii> maybe you're looking for wasm?
11:15:15 <geekosaur> there are browser widgets, iirc threepenny's standalone mode uses one
11:15:23 <dataN_> the situation arises when e.g. android phones can run webpages but not haskell programs, so the browser is a good place to run apps, but the converse is not possible, always a third party browser must be relied upon, where is the haskell version?
11:15:27 <madnight> For example Snake with Haskell in Browser http://snake.haskell-miso.org/
11:15:34 <geekosaur> but a widget is not a browser, fi you want that, target a browser
11:15:58 <dataN_> what it is this widget?
11:18:07 <dataN_> oh right, no, but thats a good app
11:19:20 <dataN_> but it relies on chrome..
11:19:26 <geekosaur> I think they use gttk's. the qt bindings (there are several) also have them
11:19:44 <geekosaur> or you can use ghcjs and build programs that run in a browser
11:22:10 <madnight> dataN_, miso does not rely on chrome, it works in any browser with javascript, also Android and iOS WebView
11:22:42 <dataN_> geekosaur: this? https://hackage.haskell.org/package/webkit
11:23:23 <madnight> dataN_, miso is one of the easiest choices if you want to support all platforms
11:24:28 <geekosaur> actually I seem to be misremembering, or maybe they changed it; readme talks about using it with Electron
11:24:45 <dataN> sorry, browser crashed, might have missed the recent comments...
11:25:01 <geekosaur> I recall one of the browser targeting packages supporting a standalone mode with a simple binding to an html widget
11:25:13 <madnight> dataN_, the webkit package is a very low level interface, usually you want a framework on top of it
11:25:54 <dataN> its the javascript support thats needed though right?
11:26:39 <dataN> that seems to be the subset of possible browser features thats being used by these haskell approaches to web rendering...
11:28:23 <madnight> dataN, well if you want to write something that a browser cannot do, then i guess you need a game engine
11:28:29 <dataN> right? so compile to js and make a browser that supports js in haskell...
11:28:45 <hololeap> what is a codensity monad?
11:29:37 <madnight> dataN, you dont need to "make" a browser, most browsers support js
11:29:53 <dataN> hololeap, essentially its e.g.  (((a->b)->b) -> (a->b)) -> b
11:30:16 <madnight> dataN, you can also consider electron with you want a "native" desktop app
11:32:32 <hololeap> dataN: are you sure that isn't a density comonad?
11:34:14 <hololeap> ugh, i'm confused
11:38:20 <dataN> hololeap: right maybe its more like (forall r. (a -> r) -> r) -> (a->(forall r. ((b->r)->r))) -> (forall r. (b -> r) -> r)
11:39:23 <dataN> madnight: so Electron is like a browser? it can run things that a browser could run, such as the output of ghcjs?
11:40:01 <dataN> maybe the confusion is about running the jvm in haskell...
11:43:45 <madnight> dataN, yup electron is like a browser, but i behaves like a installed app
11:44:58 <madnight> dataN, do you know the editor Visual Studio Code? well that's an electron app
11:45:55 <dataN> just trying to understand why at some point all the bindings are to foreign languages
11:47:09 <dataN> is it something to do with bytecode? as in how OpenGL produces its own and supports many chipsets...
11:47:16 <madnight> dataN, well that is what all the other languages also do "nowadays" they target html + js, because it runs on every platform
11:47:54 <dataN> yeah, but haskell runs on every platform...
11:49:10 <madnight> dataN, true but as soon as you compile haskell to assembly and links against libs, then you are not platform independent anymore
11:49:37 <dataN> whats the issue with linking libraries?
11:50:14 <__monty__>  dataN: It's more about the inconsistency of all the native gui apis imo.
11:52:07 <dataN> so the browser maintainer ensures this is done correctly so everything ends up targeting browsers... doesnt seem right
11:52:11 <madnight> dataN, well that's a very big topic, but as you know a linux executable does not work on windows and a windows executable does not run on linux (without wine)
11:52:29 <__monty__> CSS is probably the most widespread "designer language" so if you have to design your own buttons and stuff it's the choice that's easiest to recruit for. The same with JS, there's so many "web devs" to hire from. It sounds pretty attractive to web 2.0 based companies that already have skilled workers for those languages in house.
11:53:06 <min> I have a functor 'Layer a', of which i have used a tuple (Fix (Layer), [[Double]]) as the parameter 'a'.  I'm using a function 'coalg :: (Fix Layer, [[Double]]) -> Layer (Fix Layer, [Inputs])' as a coalgebra to an anamorphism.  However I am unable to infer the type 'a' of Layer a - the compiler is insisting that the type must be 'Fix Layer', as opposed to my intended type '(Fix Layer, [[Double]])'.
11:53:17 <min> Could someone help provide a solution to make the compiler correctly infer the type of 'a', please?
11:54:30 <madnight> but maybe we have a "fix" soon called "WebAssembly", that would allow us to compile haskell (and other languages) to portable assembly
11:55:22 <lavalike> @type coalg
11:55:23 <lambdabot> error: Variable not in scope: coalg
11:57:06 * hackage concurrent-batch 0.1.0.0 - Concurrent batching queue based on STM with timeout.  http://hackage.haskell.org/package/concurrent-batch-0.1.0.0 (HarpoRoeder)
11:57:45 <madnight> coalg :: (s -> a) -> CoAlg f s -> f a
11:58:05 <dataN> madnight: whats that? some kind of standard for the various platforms to adhere to? to be used by e.g.  Andriod instead of demainding java or c++?
11:59:31 <madnight> dataN, its intention is to replace js, so that you can write web apps (portable apps) in all languages without compiling to js
12:00:02 <dataN> min: how is that tuple supposed to have its first element of kind * -> * ?
12:01:35 <dataN> madnight: but that just means it is still the responsibility of the browser maintainer to support this for each chipset, instead of the compiler!
12:01:56 <min> dataN: Layer has kind * -> *, and Fix has kind (* -> *) -> *
12:02:06 <droplet> I'm trying to use parsec to parse a list of space separated numbers, with a newline at the end, but sepBy1 number space isn't working
12:02:22 <droplet> (where number = read <$> many1 digit)
12:02:39 <dataN> min: oh, nvm
12:03:06 <madnight> min, could you provide a example that we can put into ghci to test it? maybe make a https://lpaste.net/
12:03:31 <min> madnight: of course, one moment
12:04:25 <dataN> it seems reasonable to compile to both bytecode and e.g. js, but not *just* a language supported by the browser, as is the case now for haskell targeting android using the browser to achive portability. anyway, the browser still has to be written in some language...
12:05:47 <madnight> dataN, yup but i think its better that huge teams behind firefox, chrome and safari solve the problem of platform portability, and we "the casual" dev can simple write code that works everywhere without compiling 20 different binarys
12:06:58 <dataN> for android at least the issue seems to be that the hardware interface for the sensors on the phone requires the native development toolkit so that despite being able to target ARM, haskell ports for the FFI to android java/c++ need to be maintained to access the hardware functionality.
12:08:35 <dataN> madnight: not at all! the companies behind the browser do not have the responsibility for what platforms a compiler can target.
12:08:51 <lavalike> droplet: the code seems correct, maybe it's the data?
12:10:10 <madnight> dataN, what i mean by that is, that the companies have the responsibility that their browser works on e.g. Windows / Mac and Linux like Firefox
12:10:54 <madnight> dataN, and if the add WebAssembly then they have to make sure, that these platforms execute WebAssembly correctly (according to the specification)
12:11:29 <droplet> lavalike: I wondered that too, but parse (sepBy1 number space) "" "1 2 3\n" fails
12:11:53 <droplet> lavalike: as does parse (do {x <- sepBy1 number space; newline; return x}) "" "1 2 3\n"
12:12:02 <dataN> the point is that we are forced to target chrome because by providing the NDK to compile android java/c++, the workload of forcing the compiler engineers to handle not only the various chipsets, but the continually changing versions of the android FFI, they add a task beyond the remit of the compiler team.#
12:13:38 <lavalike> droplet: ah I see, it fails on the "\n"
12:14:35 <droplet> lavalike: but shouldn't the sepBy parser fail and move on to the next one? in this case the newline?
12:14:53 <lavalike> droplet: you need to account for those either in the parser (`newline`) or by filtering the input (`lines`)
12:15:19 <droplet> lavalike: does my second example above not take care of that?
12:15:34 <lavalike> nope
12:16:53 <dataN> madnight: so then the WebAssembly spec would keep up to date with the various hardware IO that an app could use?
12:17:06 <droplet> what would a correct parser look like? i'd like the output to be [1,2,3] in that example
12:18:14 <madnight> dataN, on android there is WebView that works out of the box with js right now and in the future it will work with webassembly
12:18:39 <min> madnight: https://github.com/min-nguyen/haskexperiments/blob/master/hnnx.hs
12:18:54 <lavalike> droplet: sorry the problem is that '\n' is a `space` not that it is not!
12:19:16 <ab9rf> lavalike: so?
12:19:38 <lavalike> so sepBy1 fails, try: parse (sepBy1 number (char ' ')) "" "1 2 3\n"
12:20:16 <ab9rf> sepBy1 should still consume tokens and generate output in that situation
12:20:22 <lavalike> or even better sepEndBy1 number space
12:20:23 <droplet> oh! i see
12:20:58 <ab9rf> the overall parser fails because there is unconsumed input remaining
12:20:59 <dataN_> madnight: seems to be in haskells webkit bindings...
12:21:17 <lavalike> ab9rf: I was thinking so too but "newline" should have covered that case, no?
12:21:21 <droplet> the next line is of the same form, so I think the sepEndBy1 version wouldn't apply, but the earlier one works
12:21:46 <droplet> ab9rf: parse doesn't necessarily need to consume all its input, does it?
12:22:02 <ab9rf> droplet: i don't remember, i almost never use parse
12:22:20 <droplet> > parse (char 'a') "" "ab"
12:22:22 <lambdabot>  error:
12:22:22 <lambdabot>      Variable not in scope: parse :: Doc -> [Char] -> [Char] -> t
12:22:23 <ab9rf> much more likely to use runParser
12:22:49 <droplet> fair, i was just using it to test
12:22:50 <ab9rf> also, which parser combinator are we talking about here? parsec, megaparsec, attoparsec?
12:22:52 <lavalike> runParser is the same thing
12:22:57 <droplet> parsec
12:23:14 <ab9rf> they have slightly different semantics in some cases
12:23:57 <dataN_> is an alternative that haskell apps could be pushed to the play store without need for crosscompilation or ffi?
12:24:01 <lavalike> droplet: here you can see sepBy1 and sepEndBy1 side by side https://www.stackage.org/haddock/lts-12.2/parsec-3.1.13.0/src/Text-Parsec-Combinator.html#sepBy1
12:24:39 <ab9rf> my recollection is that parsec only reports parser success if the entire input is consumed, but it has been a while since i used parsec
12:24:52 <ab9rf> attoparsec (which i use more often) has different semantics
12:25:11 <lavalike> ab9rf: that is not the case
12:25:26 <dataN_> probably not going to be able to use all the libraries or language extensions if a DSL is used...
12:26:46 <ab9rf> lavalike: shrug, it's been years since i actually used parsec. i tend to use either megaparsec or attoparsec
12:27:10 <dataN_> so then anyway, OpenGL for example which *does* run on ARM, is a library that can be used portably. so then it makes something like device specific libraries!? is that the same as how e.g. network requires a unix toolchain?
12:27:38 <droplet> are there significant benefits to mega/atto over parsec?
12:28:22 <lavalike> droplet: do you see where it is going wrong now?
12:28:35 <ab9rf> droplet: attoparsec is designed for higher speed when parsing at the byte level
12:29:29 <ab9rf> megaparsec is, as i recall, pretty much drop-in for parsec, but should be faster
12:30:01 <ab9rf> attoparsec has different semantics (for example, you don't need explicit 'try' with atto in many contexts that you do need it with parsec)
12:30:48 <droplet> lavalike: yeah, fixed, thanks!
12:30:55 <lavalike> droplet: yay!
12:31:03 <ab9rf> in parsec you have to request backtracking, atto you get it for "free"
12:31:38 <ab9rf> it occurs to me that your situation may have been due to parsec's backtracking rules.
12:31:52 <droplet> is atto monadic as well? i've seen arrows popularised as being better at parsing but the main parsing libraries i've seen seem monadic
12:32:06 <ab9rf> droplet: atto is not monadic
12:32:18 <ab9rf> if i recall correctly
12:32:22 <droplet> no, it was exactly as lavalike said earlier, '\n' was being parsed as a space when i didn't want it to be
12:32:29 <cocreature> huh? it totally is
12:32:36 <ab9rf> maybe i misremember :)
12:33:06 <cocreature> there’s a monad instance listed here https://hackage.haskell.org/package/attoparsec-0.13.2.2/docs/Data-Attoparsec-Internal-Types.html#t:Parser
12:33:07 <ab9rf> maybe it's just that there's no monadic transformer for atto
12:34:10 <cocreature> droplet: as for a comparison between megaparsec and parsec, take a look at https://github.com/mrkkrp/megaparsec#megaparsec-vs-parsec
12:34:29 <cocreature> I’d say for new projects you should pretty much always choose megaparsec
12:35:14 <ab9rf> i would agree with cocreature, although it's been a while since i did a parsing product
12:35:21 <ab9rf> s/product/project
12:35:31 <ab9rf> the stuff i find myself doing is usually more suited for atto
12:35:46 <droplet> i see, thanks
12:36:36 <dataN_> maybe someone should write a version of the play store for an operating system written in haskell for arm to allow haskell devs to sell their apps.
12:37:01 <ab9rf> cocreature: it was the lack of a monad transformer in atto that i misrememebered
12:37:43 <madnight> min, Layer has 3 params as far as i can see and you try to pattern match it with: a b (c, d)
12:37:46 <cocreature> megaparsec can get pretty close to the performance of attoparsec and iirc in some cases it even manages to beat it, so the usecases for attoparsec are somewhat shrinking these days
12:38:20 <madnight> min, the third param k can be another Layer, but why should you be able to match it as tuple?
12:39:58 <min> madnight, what would be required for me to match it as a tuple?
12:40:38 <droplet> are there any serious arrow parsing libraries around?
12:41:50 <madnight> min, you can't because data Layer is a recursive data structure https://github.com/min-nguyen/haskexperiments/blob/master/hnnx.hs#L45 the third param is just another layer
12:42:20 <madnight> min, you should question yourself what you want todo, why tuple?
12:43:12 <min> I think i got confused with how fix works, thank you for your help
12:49:59 <cocreature> droplet: for xml parsing there is hxt but iirc it could just as well use Monad and at some point there was even a branch that rewrote it
12:55:18 <droplet> fair enough, thanks
12:58:37 <geekosaur> the stock hxt has arrow and applicative interfaces, probably also a monadic one
12:59:27 <geekosaur> applicative in haskell more or less fell out of trying to use arrow for parsing and relizing that the interface could be cut down quite a bit to gain more flexibility while keeping the intended advantages of arrow for parsing
13:00:39 <geekosaur> (and the other thread of that, which was parsec for monadic parsing --- which more or less invented its own applicative in the process)
13:32:21 <Gurkenglas> How impossible would it be to make template' such that "template' %~ tail $ ("asd",[1..3])" comes out to ("sd",[2,3])?
13:34:28 <c_wraith> > each %~ tail $ ("asd", [1..3])
13:34:31 <lambdabot>  error:
13:34:31 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
13:34:31 <lambdabot>      • In the expression: 1
13:34:41 <c_wraith> Oh, right.
13:38:00 <c_wraith> Gurkenglas: so, the obvious issue is that you need tail to be instantiated at two different types.  Nothing I'm aware of in lens is built for that kind of polymorphism
13:41:24 <geekosaur> iirc you have to do it manually by wrapping an existential and then unwrapping it at each use
13:41:27 <geekosaur> ?
13:42:42 <c_wraith> It's not an existential.  it'd be a polymorphic wrapper.  (The wrapped value works for all types, not just some unknown type)
14:10:06 * hackage shake-cabal 0.1.0.2 - Shake library for use with cabal  http://hackage.haskell.org/package/shake-cabal-0.1.0.2 (vmchale)
14:12:18 <lavalike> c_wraith: how do these two things look like in haskell? working for all types vs working for an unknown type
14:30:46 <Zemyla> So is there a way to tell what the most common arithmetic operation on Integers across all currently-running Haskell programs is?
14:31:44 <Zemyla> I want to say it's addition/subtraction, particularly increment/decrement.
14:33:43 <Zemyla> Because I thought of a thing that might help reduce allocations as well as make those small addition functions faster and make Integer unpackable.
14:38:40 <c_wraith> lavalike: You can't ever directly specify an existential type in Haskell.  What you can do is create a wrapper that throws away type information about its arguments, such that when you unpack it, you get a value of an unknown type.
14:40:15 <c_wraith> lavalike: an example of that is the Coyoneda data type, which looks like this (written as a GADT): data Coyoneda f a where f b -> (b -> a) -> Coyoneda f a
14:40:21 <c_wraith> err
14:40:33 <c_wraith> data Coyoneda f a where Coyoneda :: f b -> (b -> a) -> Coyoneda f a
14:40:37 <lavalike> c_wraith: how do you get values inside a value of your type without the type showing it
14:40:39 <c_wraith> forgot the constructor
14:40:59 <c_wraith> So the Coyoneda constructor throws away the type b
14:41:12 <lavalike> hah!
14:41:15 * hackage shake-cabal 0.1.0.4, shake-cabal 0.1.0.3, shake-cabal 0.1.0.4, shake-cabal 0.1.0.3, shake-cabal 0.1.0.4, shake-cabal 0.1.0.3, shake-cabal 0.1.0.4, shake-cabal 0.1.0.3 (vmchale)
14:41:21 <c_wraith> You don't know what it is.  You just there is *some* type.
14:41:38 <lavalike> you can't do this without a GADT can you
14:42:57 <c_wraith> You can with the ExistentialQuantification extension
14:43:22 <c_wraith> It enables syntax like:  data Coyoneda f a = forall b. Coyoneda (f b) (b -> a)
14:44:01 <c_wraith> GADTs provide a rather more clear way of writing the same thing, so most people prefer using them
14:44:07 <Zemyla> It's a shame you can't fetch them lazily.
14:45:02 <lavalike> c_wraith: this is cool! do all cases of existential qualification boil down to having both the value and the way to operate on it, or can you have just one of the two pieces of information?
14:45:26 <lavalike> I'm guessing HList is an example of having just the value
14:45:27 <c_wraith> lavalike: there's no restriction.  It's just more useful that way.
14:45:36 <c_wraith> HList is something else entirely.  It keeps the types around
14:46:03 <c_wraith> data Useless where Useless a -> a -> Useless
14:46:19 <c_wraith> That's perfectly fine to do, it's just as useless as the name suggests.
14:46:40 <c_wraith> You have two values of an entirely unknown type.  You can't do anything with them at all
14:47:09 <lavalike> ah so you can't make a useful heterogenous list out of Useless things
14:47:26 <c_wraith> Correct.  HList actually remembers all the types it stores
14:48:00 <c_wraith> Existentials can also pack in constraints.  On very rare occasions that's useful, but..  It's usually not.
14:48:45 <c_wraith> data BasicallyTheSameAsBool where BasicallyTheSameAsBool :: Eq a => a -> a -> BasicallyTheSameAsBool
14:49:06 <lavalike> you could with something like data LessUseless where LessUseless :: a -> (a -> TypeRep) -> LessUseless (sorry if TypeRep is not the strictly correct version, I mean something that lifts a type into a value of some sort)
14:49:20 <c_wraith> You could actually pack the Typeable constraint in
14:49:27 <c_wraith> Which is roughly what Data.Dynamic does
14:50:04 <lavalike> what is something that ends up being natural to do with this scheme of existentially quantified types?
14:51:01 <c_wraith> Existentials at all, or ones that also pack up constraints?
14:51:26 <lavalike> you didn't get a chance to show off what packing constraints does, so I don't know, I was thinking generally
14:51:44 <c_wraith> I did above, data BasicallyTheSameAsBool ...
14:51:56 <lavalike> oops missed it!
14:52:00 <c_wraith> no worries
14:52:05 <c_wraith> Think about why I named it that
14:52:36 <lavalike> if you are given a value of type BasicallyTheSameAsBool what can you do hmm
14:52:37 <monochrom> Did you know: The most popular toy example for existential types uses the Show class.  data Foo = forall a. Show a => a
14:52:54 <monochrom> I say this because it puns with your "show off".
14:53:04 * lavalike slaps forehead
14:53:32 <monochrom> err I missed a data constructor.  data Foo = forall a. Show a => Ctor a
14:53:38 <Gurkenglas> Do you have a toy example for which I can't say something like "Just use type Foo = String"?
14:54:07 <monochrom> No. There are real examples but they are not toys.
14:54:18 <monochrom> But I have a joke for Show.
14:54:25 <monochrom> @quote monochrom river
14:54:25 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they
14:54:25 <lambdabot> must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How many trips do you need? Solution: one trip, [
14:54:25 <lambdabot> show the_boolean, show the_character, show the_integer]
14:54:36 <lavalike> c_wraith: I feel like the fact that the value is constructed from 2 instances of an Eq-able type should in some way help carry the information on whether the two values passed were equal or not but I don't see how that mechanically happens
14:55:59 <c_wraith> lavalike: well, technically, it actually can contain a lot of information, if you use it with something with a wonky Eq instance.  But if your Eq instance is an equivalence class (reflexive, commutative), the useful amount of information stored there boils down to a Bool
14:56:44 <c_wraith> lavalike: f (BasicallyTheSameAsBool x y) = ...  how many bodies are interesting there?
14:57:11 <lavalike> ooh the GADT syntax threw me off, the values are still in there, that's something
14:57:42 <lavalike> in my mind data Foo = Foo a b contains 2 values, data Foo where Foo a -> b -> Foo doesn't immediately read the same
14:58:06 <lavalike> forgot the ::
14:58:08 <c_wraith> lavalike: if your Eq instance forms an equivalence class, bodies like x == x, y == y, x /= x, etc.. are all boring.
14:58:37 <c_wraith> lavalike: the only interesting bodies are x == y  and x /= y, and those are related to each other by not
14:58:54 <lavalike> sure thing, I see it now, being in Eq is the only thing you know about those values
14:58:59 <c_wraith> exactly
14:59:04 <lavalike> I was missing that you still had access to the values
14:59:27 <lavalike> that's interesting, I can imagine applications of this
14:59:29 <c_wraith> Of course, a wonky Eq instance could allow way more.  But you shouldn't expect that.  You should expect instances to be well-behaved
14:59:35 <Gurkenglas> Is there an alias for "to f . _Just"?
15:00:09 <Gurkenglas> (For shame that hoogle can't answer this. Do we have a web interface yet for that new type hole filler ghc plugin?)
15:00:42 <c_wraith> lavalike: due to laziness it ends up not being all that useful.  In almost all cases, you could just use a lazy computation instead of an existential + class wrapper
15:01:06 <c_wraith> lavalike: without laziness, it would be a lot more useful, as you could defer expensive or potentially divergent computations
15:04:12 <lavalike> c_wraith: hm so you're saying there isn't much difference between   f (BasicallyTheSameAsBool x y) ..   and   g :: Eq a => a -> a -> ..
15:05:01 <c_wraith> lavalike: more specifically, g :: Eq a => a -> a -> Bool
15:05:15 <lavalike> I was thinking there could be value in having a type that packs subtly or wildly different constraint on the values it carries on different constructors defined that way
15:06:17 <c_wraith> lavalike: alternatively,  it's roughly equivalent to data AlmostTheSameAsBool2 where AlmostTheSameAsBool2 :: Bool -> AlmostTheSameAsBool2
15:07:28 <lavalike> data T where T1 :: (Integral a, Integral b) => a -> b -> T; T2 :: (Integral a, Integral b, Bounded a) => ..; T3 Bounded a Bounded b ..; you get the picture
15:07:38 <lavalike> as an example
15:08:06 <lavalike> then when you're working with Ts you sometimes have the additional information that one or both of your numbers is a bounded type which might lead to different computations or something
15:10:05 <c_wraith> lavalike: what could you do with that type that you couldn't do with data T = T1 Integer Integer | T2 Integer Integer Integer Integer | T3        (I can't see anything useful you can do with your T3 constructor)
15:10:29 <lavalike> c_wraith: let me try again and be more precise
15:10:43 <lavalike> (or discover that my idea doesn't work while trying to!)
15:11:10 <c_wraith> sure thing :)
15:11:25 <eto_> Control.Arrow.Kleisli aka ReaderT is missing Functor/Applicative/Monad instances
15:12:27 <c_wraith> I suppose Kleisli could have those instances, but no one has ever really needed them because unwrapping gives you them.
15:13:31 <c_wraith> Still, it's probably worth submitting to the libraries mailing list as a change request.
15:16:17 <Gurkenglas> (I want unsound setter combination dammit)
15:17:22 <lavalike> c_wraith: https://pastebin.com/raw/2aidjFeQ
15:21:24 <c_wraith> lavalike: I assert that type contains the exact same amount of information as https://pastebin.com/raw/bMZTjwX8 does.
15:21:59 <c_wraith> lavalike: the exact same information, too.  Not just the same amount. :)
15:22:06 <lavalike> c_wraith: that might certainly be true, I was thinking it would at least be handy from a programmatic perspective
15:22:41 <lavalike> but maybe I'm wrong
15:22:47 <c_wraith> Eh.  It's kind of awkward to use, as the only things you can do with a type that's an unknown Integral is call toInteger on it.
15:23:16 <c_wraith> And when you add being an unknown instance of Bounded, you can call maxBound and minBound, but those are just a couple extra values
15:23:54 <Mitsos101> Hello everyone! How can I pass the values of adjacent elements in a list to map? (e.g. do something like [(xs !! (i - 1)) + (xs !! i) + (xs !! (i+1)), i <- [0..(length xs) - 2]])
15:24:22 <c_wraith> Mitsos101: you should really try not to use !! ever
15:25:01 <c_wraith> Mitsos101: in this case, it's made your code take O(n^2) time when it could run in O(n)
15:25:44 <Mitsos101> c_wraith: I am aware of that. I'm trying to find the most elegant way to rewrite this.
15:25:48 <c_wraith> Mitsos101: you could use pattern-matching and direct recursion
15:26:15 <c_wraith> Mitsos101: there's no | in your comprehension, so I'm not sure what you're actually doing. :)
15:26:30 <lavalike> c_wraith: so as long as the classes only give you a finite amount of information you can always encode it statically in the constructors, and there doesn't seem to be a benefit in having the information in the constraint space
15:26:43 <Mitsos101> c_wraith: Oh, I missed that, right. "," -> "|"
15:27:06 <c_wraith> lavalike: indeed.  that's the caveat and why packing constraints with existentials isn't used all that commonly
15:27:15 <lavalike> sad!
15:28:02 <lavalike> unwinding the stack, what do we do with those without regard to this constraints aside
15:28:53 <c_wraith> Mitsos101: something like foo (x:y:z:rest) = x + y + z : foo (z:rest) ; foo _ = []
15:30:15 <sushi__> What would type 'forall m n a b . (Monad m, Monad n) => (m a -> n b) -> m (Maybe a) -> n (Maybe b)` mean? I think it should be impossible to construct but I'm not sure if I have enough insight. I would say that it's impossible to extract `Maybe a` from `m (Maybe a)` (for some monad `m`) and I think that is what's happening according to the type.
15:32:17 <Mitsos101> c_wraith: How about this (where l and r are the identity elements for f on each end): mapAdj f l xs r = zipWith f (zipWith f (l:xs) xs) (xs:r)
15:32:40 <Mitsos101> *(xs ++ (return r))
15:33:05 <c_wraith> Mitsos101: with that correction, yes, that would also work
15:33:24 <c_wraith> Mitsos101: should be roughly equivalent performance between them, too
15:34:03 <c_wraith> Mitsos101: oh wait - that's a bit different - it hits every set of three elements, instead of advancing by 2 at a time
15:35:12 <Mitsos101> wouldn't (mapAdj (+) 0 xs 0) be (almost, the list comprehension discards the elements at each end) the same thing as the list comprehension?
15:36:37 <c_wraith> Mitsos101: no, the comprehension bumped the index by two at a time.  So with the input list being [1..10], it would give [1+2+3, 3+4+5, ...
15:37:03 <c_wraith> Mitsos101: mapAdj moves ahead one element at a time:  [1+2+3, 2+3+4, etc
15:37:52 <Mitsos101> I see, okay, thanks
15:38:25 <c_wraith> lavalike: so there are several cases where you might want to store values without knowing or caring what type they are.
15:40:10 <c_wraith> lavalike: One example is a worker pool sort of thing, in a concurrent environment.  data Job where Job :: IO a -> MVar a -> Job
15:41:05 <sushi__> c_wraith: I don't see how `i <- [0..(length xs) - 2]` would bump `i` by two at a time
15:41:44 <c_wraith> sushi__: err, you're right.  I got that totally wrong.  shoot, he left
15:43:44 <c_wraith> lavalike: the most trivial use of that job type, where you did something like  process (Job action mvar) = action >>= putMVar mvar
15:44:12 <c_wraith> lavalike: in that case, there's no advantage to having the existential, because you could just pass IO () values that correspond to process around
15:44:22 <lavalike> right
15:45:06 <c_wraith> lavalike: but if you make it a bit more interesting, like   data Job where Job :: IO a -> MVar (Either Error a) -> Job
15:45:42 <c_wraith> lavalike: then the process function can do a lot more interesting things.  It can retry if it gets certain errors, report others, cause timeouts and report them, and so on
15:46:00 <c_wraith> lavalike: and at that point, you need the ability to separate the job from reporting its result
15:46:21 <c_wraith> lavalike: and *then* you get value out of the existential
15:48:02 <lavalike> c_wraith: nice example!
15:48:38 <lavalike> leveraging b in your Coyoneda
15:49:32 <c_wraith> lavalike: not mine - stolen from edwardk!  https://hackage.haskell.org/package/kan-extensions-5.2/docs/Data-Functor-Coyoneda.html
15:50:14 <c_wraith> lavalike: I have seen a couple uses of that type.  One is that it has a Functor instance that works regardless of what f is.
15:50:43 <c_wraith> lavalike: which is sometimes useful.  Like...  with Coyoneda IORef you can use fmap to "modify" the IORef
15:52:14 <c_wraith> lavalike: and then once you're back in IO, you can extract the modified version with something like  updateIORef (Coyoneda f ref) = modifyIORef ref f
15:52:14 <lavalike> fun
15:52:54 <c_wraith> lavalike: there's also the fact that the "freer" monad Freer f a is roughly equivalent to Free (Coyoneda f) a
15:53:15 <lavalike> haha I have never heard of Free_r_ before
15:54:09 <c_wraith> lavalike: Free requires you to provide a Functor to work with.  Freer lets you work with any type of kind * -> *
15:54:25 <lavalike> this makes sense as I'm reading
15:54:31 <c_wraith> lavalike: so it is making use of the fact that (Coyoneda f) always has a Functor instance
15:56:56 <Gurkenglas> Did someone just restrict lambdabot to those logged into nickserv?
15:57:18 * Clint squints.
15:57:28 <d34df00d> Hi!
15:57:42 <d34df00d> Dumb question perhaps, but how do I check if my Setup.hs runs under cabal < 2.2.0.0?
15:57:45 <c_wraith> I guess lambdabot was getting spammed in privmessages a bit too much?
15:58:13 <d34df00d> Will `#if not MIN_VERSION_cabal(2,2,0)` work?
15:59:15 <d34df00d> > #if MIN_VERSION_bytestring(0,10,4)
15:59:23 <lambdabot>  <hint>:1:1: error: parse error on input ‘#’
15:59:23 <d34df00d> > missing binary operator before token "("
15:59:25 <d34df00d> apparently nope
15:59:35 <lambdabot>  error:
15:59:45 <lambdabot>          missing
15:59:49 <d34df00d> lambdabot: sorry mate.
16:00:32 <lavalike> c_wraith: finally to come back around to your comment that lit the fire for this discussion: this is existential quantification and you were contrasting it to polymorphic wrappers, what does that look like?
16:01:42 <c_wraith> lavalike: so, to go all the way back, Gurkenglas wanted to do something that was failing for the same reason this fails:
16:02:02 <c_wraith> > (\f -> (f "hello", f [1..10])) tail
16:02:03 <lambdabot>  error:
16:02:04 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
16:02:04 <lambdabot>      • In the expression: 1
16:02:32 <geekosaur> d34df00d, lambdabot doesn't do CPP. that should work with the CPP extension enabled
16:02:42 <c_wraith> lavalike: are you familiar with the problem there?
16:02:53 <d34df00d> geekosaur: ah, I was just quoting smth from what I wrote in the code :)
16:03:04 <d34df00d> Anyway, looks like Cabal should start with uppercase in the macro.
16:03:08 <lavalike> c_wraith: I see that it would need to have 2 different instantiation of the type of tail there
16:03:26 <geekosaur> yes because the library name is Cabal, not cabal
16:03:37 <c_wraith> lavalike: indeed.
16:04:17 <lavalike> that explodes because f can only have 1 type in the body of the lambda
16:04:17 <c_wraith> lavalike: You'd need to preserve the polymorphism somehow.
16:04:44 <c_wraith> lavalike: you can preserve the polymorphism by using a universally qualified type variable in a data type.  I wonder if lambdabot has this enabled
16:05:17 <c_wraith> @let newtype ListProcessor = ListProcessor (forall a. [a] -> [a])
16:05:18 <lambdabot>  Defined.
16:05:21 <c_wraith> it does.  nice
16:05:41 <c_wraith> Except it's more convenient with record syntax.
16:05:43 <c_wraith> @undefine
16:05:43 <lambdabot> Undefined.
16:05:55 <c_wraith> @let newtype ListProcessor = ListProcessor { run :: forall a. [a] -> [a] }
16:05:56 <lambdabot>  Defined.
16:06:23 <c_wraith> > (\lp -> (run lp "hello", run lp [1..10])) $ ListProcessor tail
16:06:25 <lambdabot>  ("ello",[2,3,4,5,6,7,8,9,10])
16:07:16 <c_wraith> ListProcessor doesn't contain a value with some unknown type variable, it contains a polymorphic value.
16:07:25 <c_wraith> :t ListProcessor
16:07:26 <lambdabot> (forall a. [a] -> [a]) -> ListProcessor
16:07:35 <c_wraith> Notably, the constructor has Rank-2 type
16:07:40 <lavalike> nice
16:07:45 <c_wraith> It only works with polymorphic values
16:07:52 <c_wraith> :t ListProcessor (1:)
16:07:53 <lambdabot> error:
16:07:53 <lambdabot>     • No instance for (Num a) arising from the literal ‘1’
16:07:53 <lambdabot>       Possible fix:
16:08:00 <lavalike> I was trying locally taill :: forall a . [a] -> [a] but it also explodes
16:08:39 --- mode: ChanServ set +o glguy
16:08:39 --- mode: glguy set +b *!*@2001:ee0:4101:a16:*
16:08:44 <lavalike> Couldn't match type ‘Char’ with ‘Int’ In the expression:(\ f -> (f "Hello", f [1 .. 10])) taill :: (String, [Int])
16:08:45 <c_wraith> yeah, that requires impredicative instantiation - instantiating a type variable at a polymorphic type.  GHC doesn't support that.  Even though it has an extension that claims it does, it's buggy
16:10:07 <lavalike> I see!
16:10:59 <c_wraith> Like, sometimes the extension works, then you make what you think should be a trivial change, and there's no way to make things type check again.
16:11:29 <c_wraith> It's known to be a problem, but it's not removed because there's hope that maybe someday it can be made to function well.
16:12:09 <lavalike> reasonable
16:12:11 <c_wraith> Until then, you can always use the newtype wrapper trick to get the same effect in a more verbose manner
16:12:57 <c_wraith> But it isn't something you can trivially integrate with things like the lens combinators, as it requires support at the use site, not just the declaration site
16:13:22 <lavalike> clear as crystal
16:15:04 <c_wraith> one last note - these can both be declared with a forall in the declaration, so it's reasonable to ask what the difference in the syntaxes is.
16:15:24 <lavalike> I was just trying to write down exactly that question (:
16:15:37 <c_wraith> The difference is the scoping of the forall
16:15:59 <c_wraith> When it's an existential, the forall scopes over the type of the entire constructor
16:16:17 <c_wraith> When it's wrapping a polymorphic value, the forall scopes only over the type of one argument to the constructor
16:16:56 <c_wraith> So it comes down to whether the constructor's type is rank-1, or higher-rank
16:17:00 <lavalike> so this difference only matters when the type variable appears more than once?
16:17:23 <c_wraith> No, it's more general
16:17:52 <c_wraith> for instance, one way to define the Void type is  newtype Void = Void { absurd :: forall a. a }
16:18:40 <c_wraith> there are no (defined) values with that type, so you can't create a value of type Void with any value that can be evaluated successfully
16:18:40 <lavalike> here I would say there are no arguments for the constructor, so it can't be polymorphic wrapping
16:18:58 <c_wraith> let's see if it's in scope
16:19:00 <c_wraith> :t Void
16:19:01 <lambdabot> error:
16:19:01 <lambdabot>     • Data constructor not in scope: Void
16:19:02 <lambdabot>     • Perhaps you meant one of these:
16:19:17 <c_wraith> @let newtype Void = Void { absurd :: forall a. a }
16:19:19 <lambdabot>  Defined.
16:19:21 <c_wraith> :t Void
16:19:22 <lambdabot> (forall a. a) -> L.Void
16:19:32 <lavalike> uhm
16:19:41 <lavalike> it is in the argument of the constructor, my bad
16:19:53 <c_wraith> @undefine
16:19:53 <lambdabot> Undefined.
16:20:11 <lavalike> it's a variation on newtype Foo = Foo a with the 'forall a.' (and the record syntax)
16:20:17 <c_wraith> @let data Useless where Useless :: a -> Useless
16:20:18 <lambdabot>  Defined.
16:20:21 <c_wraith> :t Useless
16:20:22 <lambdabot> a -> Useless
16:20:35 <c_wraith> The existential has a rank-1 constructor
16:20:53 <c_wraith> The polymorphic wrapper has a rank-2 constructor
16:21:01 <c_wraith> That's the easiest way to determine the difference
16:21:37 <lavalike> I thought rank had to do with kinds, if you take parameters of kind * you are of rank 1, if you take parameters of more complex kinds like * -> * you are of rank 2, and so forth
16:22:15 <c_wraith> That's higher-kinded types, not higher-rank types.  Lots of people confuse them when writing about them, which causes lots of further confusion. :)
16:22:42 <lavalike> haha, darnit
16:22:55 <lavalike> then I don't know what ranks are
16:23:35 <c_wraith> It has to do with polymorphism, specifically.
16:23:46 <c_wraith> :t ($)
16:23:47 <lambdabot> (a -> b) -> a -> b
16:23:54 <c_wraith> That's rank-1 polymorphism
16:24:28 <c_wraith> The types a and b could be any type, but exactly what they are is fixed at call time
16:24:35 <lavalike> your run-of-the-mill polymorphism
16:24:46 <c_wraith> yep.
16:25:09 <c_wraith> When you go to higher-rank polymorphism, you declare that certain arguments of the function need to still be polymorphic
16:25:40 <c_wraith> Going back to the pair example helps here.
16:25:47 <lavalike> I see
16:26:48 <c_wraith> :t let foo f x y = (f x, f y) in foo
16:26:49 <lambdabot> (t -> b) -> t -> t -> (b, b)
16:27:04 <c_wraith> That's a regular rank-1 type
16:27:25 <c_wraith> So the second and third arguments need to have the same type, as the first argument isn't polymorphic
16:27:41 <c_wraith> Note that in haskell, all inferred types are rank-1
16:27:47 * lavalike nods
16:27:59 <c_wraith> But sometimes the same expression can have a higher-rank type that will be checked, even if won't be inferred
16:28:58 <c_wraith> :t let foo :: (forall a. Show a => a -> String) -> a -> b -> (String, String) ; foo f x y = (f x, f y) in foo
16:28:59 <lambdabot> error:
16:28:59 <lambdabot>     • No instance for (Show a1) arising from a use of ‘f’
16:28:59 <lambdabot>       Possible fix:
16:29:09 <lavalike> (the ghc wiki page on impredicativity tries to make it very clear that the problem is *just* with inference)
16:29:27 <c_wraith> Oh, right
16:29:28 <Gurkenglas> What can I do when I have a single monadic side effect in a long optic composition chain?
16:29:48 <c_wraith> :t let foo :: (Show a, Show b) => (forall c. Show c => c -> String) -> a -> b -> (String, String) ; foo f x y = (f x, f y) in foo
16:29:49 <glguy> Gurkenglas: mapped?
16:29:50 <lambdabot> (Show b, Show a) => (forall c. Show c => c -> String) -> a -> b -> (String, String)
16:30:11 <glguy> err, nevermind
16:30:19 <lavalike> cool
16:31:30 <c_wraith> lavalike: so when you look at the type of a constructor, if it has rank-1 polymorphism and the type variable doesn't appear in the data type, you know that the constructed value has to just forget the type.
16:31:45 <c_wraith> lavalike: But if it has higher-rank polymorphism, it means it is storing a polymorphic value
16:32:41 <lavalike> c_wraith: why do you restrict the rule to constructors but have examples with general functions?
16:33:40 <c_wraith> lavalike: oh.  Because it's easier to write examples with general functions, but only constructors matter for my original case - what it means to throw a forall into a type definition
16:35:23 <lavalike> c_wraith: I kept thinking you were going for the classification of the syntax in general and got derailed by the mention of constructors every time (:
16:35:50 <Gurkenglas> (side note: the heck is timing out http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Traversal.html#v:elementOf )
16:35:55 <Gurkenglas> *timingOut
16:36:54 <heebo> whats hot in haskell at the moment.. what libraries are cool
16:36:58 <lavalike> Gurkenglas: must be an easter egg, if you search for timingOut on stackage the request... times out!!
16:37:23 <heebo> i wonder when the next state of haskell blog will be published
16:37:30 <c_wraith> Gurkenglas: I think the goal was to demonstrate that it works in finite time even on infinite folds
16:37:45 <lavalike> c_wraith: my bad, in the context of the conversation I see what you mean now, explaining the original comment
16:37:48 <c_wraith> Gurkenglas: but I have no idea what it was meant to say
16:38:07 <Gurkenglas> He thought if he didnt write that there and we see that input we conclude he must be using a hypercomputer? o.o
16:38:12 <Gurkenglas> *that output
16:38:24 <c_wraith> well, lots of the lens "examples" aren't real code
16:38:40 <c_wraith> That one is just non-real in a different way
16:40:16 <lavalike> c_wraith: thanks for the discussion this was very interesting!
16:40:53 <lavalike> the phrase "existential quantification" doesn't really bring up images on its own it was very good to work through some examples and see what it actually is and does
16:40:55 <Gurkenglas> What I have is like "itraverseOf (traverse . selfIndex . traverse . f . traverse)" except f has a monadic side effect so I can't write it like that, what do? :(
16:41:07 <Gurkenglas> (f is not indexed)
16:41:22 <c_wraith> lavalike: happy to help. :)
16:41:44 <Gurkenglas> (oh so it should be "itraverseOf (traverse . selfIndex <. traverse <. f <. traverse)" but still)
16:43:31 <glguy> Gurkenglas: You might need to break it up into two uses of traverseOf
16:44:23 <heebo> hmmm i think i'll dick around with pipes and wreq and aeson and free
16:46:14 <Gurkenglas> glguy, does it help if the itraverseOf does not introduce any further side effects?
16:47:02 <Gurkenglas> (ie itoListOf and then map, pretty much)
16:50:42 <bananabrick> hi
16:51:29 <bananabrick> Can I have a recursive definition of an ADT where one of the parameters for one of the data constructors is a *specific* data constructor of the same type?
16:51:38 <Gurkenglas> This looks like it's annoying for some of the same reasons as "fmap concat . traverse f". Does lens have a solution for that one?
16:52:31 <Gurkenglas> bananabrick: No, you could turn those two "duplicate code" lines into two uses of an extra type
16:53:08 <Maxdamantus> bananabrick: sounds like something that would require dependent typing. Constructors don't have particular types.
16:53:12 <glguy> bananabrick: You can kind of hack that with a GADT, too
16:53:58 <Solonarv> (but you probably shouldn't)
16:54:24 <bananabrick> So, i'm trying to represent the lambda calc grammar as an adt. In an expr like \x.y, the x is defined as a variable, while the y can be anything(other lambdas / application)
16:54:32 <Maxdamantus> (particular as in individual types; types that don't contain any other values)
16:54:57 <glguy> bananabrick: That's fine: data AST = ... | Lambda Variable AST | ...
16:54:59 <bananabrick> so y can be all other expressions in my grammar
16:55:46 <Maxdamantus> bananabrick: the general expression type will usually be a sum including a tagged version of whatever type a "variable" has.
16:55:51 <bananabrick> umm, in that definition, is `Variable` also defined in the AST
16:56:01 <glguy> bananabrick: No, Variable is a different type
16:56:02 <Maxdamantus> bananabrick: right, and it shouldn't.
16:56:17 <Maxdamantus> data AST = ... | Lambda Variable AST | VariableExpr Variable
16:56:34 <bananabrick> but `Variable` is defined as part of the grammar theoretically, right
16:56:50 <Solonarv> no, it's a separate type
16:56:54 <bananabrick> i tried data AST = ... | Lambda Variable AST | VariableExpr Variable
16:57:07 <bananabrick> but, now I can't type-check a lambda anymore
16:57:17 <bananabrick> oh wait
16:57:18 <bananabrick> nvm
16:57:19 <bananabrick> i'm dumb
16:57:43 <bananabrick> my context was Expr -> Type, but my context should be Variable -> Type
16:57:49 <bananabrick> thanks for the help
16:58:06 <Solonarv> sometimes it's a type argument as well: data LC v = App LC LC | Lam v LC | Var v
16:58:37 <bananabrick> kk thanks guys
17:02:50 --- mode: glguy set -o glguy
17:23:04 <joshsh> Any recommendations out there for an HTML writer in Haskell? I want to generate a collection of static HTML pages for browsing a schema, and would like to translate the schema elements into pages in a nice declarative way. No need for JS or client/server interaction.
17:25:25 <Solonarv> hakyll is a static site generator, maybe that?
17:25:49 <Solonarv> or if you're just looking for a more low-level library, blaze-html (it's a template engine)
17:26:33 <joshsh> Solanarv: thanks, looking. I did see blaze-html, which claims to be "blazingly fast". I don't particularly care about that, but will compare with hakyll
17:27:01 <Solonarv> they do different things
17:27:08 <Solonarv> in fact hakyll uses blaze under the hood
17:29:09 <joshsh> blaze-html seems like a winner. Will tinker with hakyll. Thanks again
17:36:35 <joshsh> for anyone else reading, this looks like a good overview of Web tooling in Haskell (possibly a little dated): https://www.youtube.com/watch?v=GobPiGL9jJ4
17:37:56 <systemfault> Thanks!
17:47:55 <Gurkenglas> Building this project took a long time. How do I tell stack to only typecheck this time around so the editor will show me where to refactor further?
17:49:33 <Solonarv> the ghc option is "-fno-code" IIRC
17:50:00 <Solonarv> if you're using intero (or HIE as well?) it'll do that by default
17:50:50 <Gurkenglas> The project to rebuild is hie and I only got new errors for the current file x)
17:52:30 <Solonarv> if you pass "-j4" to stack and "-fno-code" to ghc (via stack) you should get as many errors in parallel as possible
17:53:36 <Solonarv> (replace 4 with however many CPU cores you're willing to throw at the build process)
17:55:42 * hackage vty 5.23.1 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.23.1 (JonathanDaugherty)
18:05:12 * hackage irc-core 2.4.0 - IRC core library for glirc  http://hackage.haskell.org/package/irc-core-2.4.0 (EricMertens)
18:06:12 * hackage hookup 0.2.2 - Abstraction over creating network connections with SOCKS5 and TLS  http://hackage.haskell.org/package/hookup-0.2.2 (EricMertens)
18:07:12 * hackage glirc 2.27 - Console IRC client  http://hackage.haskell.org/package/glirc-2.27 (EricMertens)
18:12:08 <badzergling_> does InverseSemigroup exist as a class somewhere?
18:13:01 <Solonarv> I recall ed kmett writing that on stream a bit ago, so presumably it didn't already exist anywhere else
18:13:26 <Solonarv> you should be able to find the library by looking through his github
18:14:58 <badzergling> does `InverseSemigroup` exist somewhere?
18:15:19 <Gurkenglas> Am I stupid or does trying to use pattern synonyms throw wrong "non-exhaustive pattern match"es at me?
18:17:54 <Solonarv> badzergling, I answered your question 5 minutes ago but you seem to have disconnected:  I recall ed kmett writing that on stream a bit ago, so presumably it didn't already exist anywhere else. You should be able to find the library by looking through his github
18:19:42 <Solonarv> Gurkenglas: yeah, I've heard that the exhaustiveness checker is finicky with pattern synonyms
18:20:01 <Gurkenglas> *holds Ctrl-Z*
18:20:03 <Solonarv> there might have been talk of a {-# COMPLETE #-} pragma
18:26:00 <glguy> Solonarv: Something like this? http://hackage.haskell.org/package/contravariant-1.5/docs/Data-Functor-Contravariant-Divisible.html
18:26:35 <Solonarv> I'm not sure why you pinged me?
18:26:55 <glguy> Because you said you recalled a library
18:27:04 <glguy> and I wonder if that was what you recalled
18:27:18 <glguy> 6 minutes ago
18:27:53 <Solonarv> oh. no, I meant one with InvertibleSemigroup in it, which I recalled ed kmett writing on stream
18:28:08 <Solonarv> let me see if I can find it
18:29:15 <badzergling> (uh... actually it seems i really do need a full group anyway ^^p
18:31:08 <Solonarv> in that case:
18:31:14 <Solonarv> @hackage groups
18:31:15 <lambdabot> http://hackage.haskell.org/package/groups
18:31:23 <Solonarv> surprisingly *not* written by ed ;)
18:39:52 <nfd9001> Haha, so I started nuking my arch-installed haskell to try to resolve dependency hell. Removed all of the appropriate packages, reinstalled, and now ghc only seems to be able to find base in some cases and not in others?
18:39:58 <badzergling> already found that.
18:40:14 <nfd9001> i'm thiiiiiiiis close to just installing xmonad through stack, pacman be damned
18:45:18 <rotaerk> nfd9001, considered nix and nixos?
18:45:42 <glguy> Or Python?
18:46:02 <rotaerk> I don't get it
18:46:11 <Solonarv> python xmonad? *scratching head*
18:46:40 <Clint> does that work with wayland?
18:46:57 <nfd9001> glguy: funny enough, trying to get this system updated, i coincidentally managed to break pip
18:47:02 <nfd9001> i've been on a roll :D
18:47:09 <nfd9001> rotaerk: not really, no
18:47:48 <Madkiss20> Interested in reasonably priced GLOBAL IRC ADVERTISING? Contact me on twitter https://twitter.com/nenolod or linkedin https://www.linkedin.com/in/nenolod
18:47:52 <nfd9001> rotaerk: i'm on bedrock so i guess i could just install it, haha
18:48:00 <rotaerk> nfd9001, oh k, they address some of the problems you described
18:48:12 * hackage hOpenPGP 2.7.2 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-2.7.2 (ClintAdams)
18:48:17 <rotaerk> you could just use nix, on arch, or you could go a step further and just switch to nixos instead of arch
18:48:39 <nfd9001> or nixos and arch; https://bedrocklinux.org/
18:51:32 <nfd9001> hmm, it's the darndest thing...
18:51:55 <nfd9001> it looks like sometimes base shows up, and sometimes it doesn't
18:53:08 <jared> hello
18:53:20 <rotaerk> hi
19:48:12 <rotaerk> hmm bothers me a little that Storable has a sizeOf :: a -> Int method rather than just a size :: Int
19:48:36 <rotaerk> the latter would work well with just:  size @Type
19:49:18 <rotaerk> well, I guess sizeOf is still useful, in case you have a value rather than a type, on hand
19:50:30 <rotaerk> heh, there's some library called "proxied" that tries to remedy this... though it calls it "theSizeOf" rather than "size"
19:51:04 <mniip> rotaerk, the @Type syntax is very new
19:51:19 <rotaerk> ah
19:51:49 <glguy> More exact than: proxy a -> Int   would be   Tagged a Int
19:51:57 <glguy> http://hackage.haskell.org/package/tagged-0.8.6/docs/Data-Tagged.html
19:53:36 <mniip> yeah, you can recover the old representation with 'witness'
20:00:52 <gbd_628> Hi, quick question, not even about Haskell really, just haddock. I'm getting the error "-h/--html cannot be used with --gen-index or --gen-contents" from haddock when running "stack install". I don't understand why, since the "--gen-*" options seem to assume it's all in HTML, so if anything shouldn't they make the "--html" flag mandatory?
20:03:40 <gbd_628> I can fix it by altering my .stack/config file and getting rid of the "--html" option and other problematic options (e.g., "--latex"). The --gen-* ones appear to be added by `stack`. Can I customize stack to behave how I want w/ respect to haddock when installing my own packages?
20:19:31 <mniip> I've had an interesting idea
20:20:10 <mniip> class Truncated f where noinvmap :: (forall a b. (a -> b) -> (b -> a) -> f a -> f b) -> Void
20:20:34 <glguy> Now that vty updated to support italics, I can handle all the mIRC formatting modes: https://imgur.com/a/nLN67pf
20:26:16 <mniip> glguy, hmm?
20:27:19 <nshepperd1> mniip: what kind of things would have an instance of that?
20:27:39 <glguy> mniip: what?
20:28:33 <mniip> ah, #haskell is +C
20:29:01 <glguy> mniip: I didn't send that to chat, that's just how it's rendered when you're composing a message
20:29:10 <mniip> nshepperd1, any datatype that captures an equational constraint
20:29:17 <glguy> once in chat it stops showing the explicit control characters
20:29:28 <mniip> data T a where D :: T Int
20:29:59 <mniip> instance Truncated T where noinvmap invmap = case invmap Identity runIdentity D of {}
20:47:44 <mniip> hmm
20:47:52 <mniip> I wonder how to classify :~:
20:48:14 <mniip> (a :~:) is a functor from a truncated category
20:48:17 <mniip> so is (:~: b)
20:48:49 <mniip> but (a :~: b) is kind of phantom on the diagonal
20:51:19 <mniip> how many morphisms can you add to |Set x Set| so that :~: remains a functor
20:56:43 <mniip> hmm, maybe this can be inferred from the type
20:57:18 <mniip> (a ~ b) => a :~: b, hence any morphism has to preserve the satisfiedness or unsatisfiedness of the ~
21:20:48 <pikajude> ok so my memory may be completely off, but isn't there a ghc command that produces a topo-sorted list of dependencies for a specific module
21:29:42 <mmaruseacph2> `ghc -M
21:39:26 <pikajude> oh, that actually generates a makefile
21:39:27 <pikajude> i see
21:53:04 <plotnus> haskell feels like magic
21:54:35 <lin__> how can I(in main) have a variable bar, check, weaater bar==foo and do nothing or read a file and change a variable
21:56:03 <ab9rf> that sounds a bit underspecified
21:56:32 <geekosaur> change a variable is not a thing.
21:57:39 <geekosaur> newv <- if foo == bar then return Nothing else Just <$> readFile "blerg" -- ? or similar
21:59:29 <lin__> why would the Just <$> be needed?
22:00:23 <ab9rf> to make the types cohere
22:05:47 <pavonia> lin__: Perhaps you want `when (bar == foo) $ readFile ...`?
22:08:47 <cocreature> pavonia: that doesn’t typecheck. the second argument of "when" must be of type f () not f String
22:08:59 <ab9rf> hehe
22:09:33 <ab9rf> void is your fiend
22:09:53 <cocreature> no it isn’t. you don’t read a file justu to throw away the result
22:10:07 <ab9rf> cocreature: well, maybe _you_ don't :)
22:10:41 <ab9rf> cocreature: the specified problem is way too ambiguous to actually solve, so we shouldn't assume that it actually does something useful
22:11:35 <pavonia> Err yes, I meant doing the whole file handling in the when branch
22:12:03 <cocreature> *shrug* I think it’s fair to assume that the goal here is not to read a file and throw away the result
22:12:08 <lin__> it is a workaround for the fact, that I cannot find out how to check weather or not a flag was given with System.Console.CmdArgs
22:12:33 <lin__> if the flag was given I want to read the file and build a predicate from it
22:13:26 <ab9rf> which API from system.console are you using?
22:13:51 <ab9rf> explicit, implicit, or getopt?
22:15:57 <lin__> Explicit
22:16:02 <hololeap> how can a Representable be used to memoize data? i see this is a thing in Control.Comonad.Representable.Store (adjunctions), but looking at the instances of Representable, the only thing i see that could be useful for this would be (Cofree Identity a)... am i missing something?
22:22:16 <ab9rf> ah, the hard one :)
22:34:01 <cocreature> lin__: how about something like https://gist.github.com/cocreature/5b219df93dc9292ff9660afa54dcfef9? it won’t let you differentiate between no argument being passed and an empty argument but maybe that doesn’t matter for your usecase
22:35:58 <cocreature> also wow, the cmdargs API is painful
22:36:09 <ab9rf> cocreature: yeah, that was my conclusion too
22:36:42 <ab9rf> cocreature: not sure that it's really an improvement on getopt
22:37:14 <cocreature> I just keep using optparse-applicative :)
22:38:25 <ab9rf> there must be a better way to implement this API
22:41:11 <ab9rf> cocreature: optparse-applicative does seem rather more less insanity-inducing
22:41:33 <cocreature> how so? I’ve used it quite a bit and so far I’ve been really happy with it.
22:41:51 <ab9rf> cocreature: strike "more" from my last utterance
22:41:58 <cocreature> ah :)
22:42:22 <ab9rf> i've used optparse-applicative a few times, it's quite straightforward
22:42:50 <ab9rf> and better documented as well :)
23:21:38 <Guest26225> hey guys, im trying to implement k-means with a monad (to get a better understanding of haskell and the algorithm). I cant get my monad instance to work, I think there is some fundamental error.
23:21:39 <Guest26225> https://pastebin.com/0tMKw5NP
23:21:50 <Guest26225> if someone could take  quick look at it I'd be grateful
23:26:18 <mniip> Guest26225, sounds like you have the wrong idea of what a monad means
23:28:40 <Guest26225> ok, my understanding is, that this is a pretty way to experess computations with side effects. can you tell me where I'm wrong?
23:31:52 <mniip> Guest26225, it is a very specific way to express computations with side effects
23:32:02 <mniip> what kind of side effect do you plan to use here?
23:32:09 <mniip> (sorry, I'm not familiar with k-menas)
23:32:12 <mniip> means*
23:32:27 <c_wraith> too specific.  It's a way of expression composition of values of particular forms.  Those values may represent side effects, they may not.
23:32:53 <Guest26225> it's a clustering algorithm, which assigns points to the closest center and then averages over all assigned points to find the new center.
23:33:23 <Guest26225> thus the side effects should be the assignement and the centers
23:33:56 <mniip> doesn't sound like it
23:33:58 <c_wraith> those sound like values, not effects
23:34:30 <mniip> you could use State for the assignment but I feel that might be a bad idea
23:34:36 <mniip> this is better expressed as a pure function
23:34:49 <mniip> as you really only have one input state and one output state
23:34:55 <mniip> you don't modify it piece-by-piece
23:35:37 <Guest26225> fair enough
23:35:46 <Guest26225> makes sense
23:37:09 <Guest26225> so when is it a side effect? isn't it always a mapping from state to state?
23:38:34 <mniip> monads are generally only necessary when you have many interacting pieces, or possibly a piece interacting recursively with itself
23:38:42 <mniip> and manually threading the data between them gets tedious
23:39:04 <c_wraith> That's a super state-centric view of monads.
23:39:17 <mniip> RWS-centric I'd say
23:39:26 <c_wraith> A monad has no intrinsic meaning.  None.  It's just an abstract pattern.
23:39:42 <HaskellLord69> There is no monad
23:39:43 <c_wraith> It happens that you can model effects using a type that fits the pattern.
23:39:49 <Saulzar_> You could use a State monad to implement k-means, e.g.  State PointsAndCentres
23:40:11 <c_wraith> But the important part is that there is a type representing effects, not that it is a monad.
23:40:19 <Saulzar_> But in the simple case I'm not sure you gain much advantage rather than implementing it directly with recursion
23:43:29 <Guest26225> okay, i'm getting closer (I think). for the maybe monad, we abstract away the handling of the side effects with the monad pattern, so we may focus on the actual computation we'd like to perform?
23:44:33 <Saulzar_> Guest26225, Yeah, so any error (Nothing) shortcuts the rest of the computation and it means you don't have to keep checking for it
23:44:58 <liste> I wouldn't call them side effects
23:45:23 <liste> it's just a way to combine a -> Maybe b functions
23:46:00 <revskill> in Haskell there's no semicolon or assignment operator, because you have to define yourself using Monad
23:46:22 <c_wraith> I wish people wouldn't say things like that.  They're a very misleading model.
23:46:28 <liste> it's not the Maybe monad, it's the Maybe type and the implementation of >>= and pure (which form the Monad instance)
23:46:37 <mniip> dose base export a type family :: k -> k -> Bool anywhere
23:47:25 <Guest26225> c_wraith what things?
23:47:53 <Saulzar_> 'maybe monad'
23:48:01 <mniip> liste, so a category instance for Kleisli m
23:48:36 <c_wraith> Guest26225: things like monad being about semicolons or assignment.
23:48:37 <liste> :t (>=>)
23:48:38 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
23:48:47 <acertain> mniip: Data.Type.Equality (==) ?
23:49:32 <mniip> ah yes
23:49:34 <Guest26225> should I dig into category theory to get this? or does anyone have a ressource for me?
23:49:51 <Guest26225> I don't think I get the point
23:49:55 <liste> Guest26225: I don't think category theory is very fruitful here
23:49:55 <mniip> that's an interesting set of equations
23:50:11 <liste> Guest26225: this is only relevant to a tiny corner of category theory
23:50:35 <liste> and it'd take a long time to get there when starting category theory from the beginning
23:50:38 <liste> that said...
23:50:53 <liste> https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
23:52:05 <c_wraith> monads are about composition.  That viewpoint has the advantage of being a usable guide in both math and programming
23:52:08 <Guest26225> sounds like something I'd like to dig in, but probably overkill for my upcoming formal methods functional programing exam
23:52:09 <liste> Guest26225: but maybe you're trying too hard to "get" it. it's just about a few functions and rules that they must follow so abstractions can be built on them
23:52:25 <Guest26225> will look into it afterwards
23:52:47 <Guest26225> that may just be the right way to look at it
23:53:19 <liste> do you know Functor and Applicative?
23:53:24 <Guest26225> the pattern can probably be used for many things and trying to get an intuitive understanding by narrowing it down to a certain mode of computation is maybe just wrong
23:53:35 <Guest26225> not really
23:53:44 <liste> start with them, they're simpler
23:53:49 <Guest26225> ok cool
23:54:03 <Guest26225> thanks guys!
23:56:42 * hackage termonad 0.1.0.0 - Terminal emulator configurable in Haskell  http://hackage.haskell.org/package/termonad-0.1.0.0 (cdepillabout)
