00:04:33 <xandaros> Maybe not your exact case, but I got fairly annoyed about some default instances which didn't match my intention. (Binary instances, in particular) So many newtypes just to hide those...
00:05:00 <xandaros> I do have a "converter class", though, which defines an Iso (from lens) to convert back and forth
00:37:23 <ertes-w> hell
00:37:58 <tdammers> what happened to helo?
00:40:22 <xacktm> it went helio, now it burns bright and hot like hell
01:16:26 * hackage yaml 0.8.29 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.29 (MichaelSnoyman)
01:16:43 <kaol> Suggest me some nicer way to write \(a,b) -> (f a, f b). I feel like I'm repeating myself.
01:17:09 <merijn> kaol: Depends how often you're writing that
01:17:31 <merijn> You could go with "bimap f f" or "join bimap f" if "f" is a longname and you like being cryptic
01:18:02 <osa1> > over both f
01:18:05 <lambdabot>  error:
01:18:05 <lambdabot>      • No instance for (Typeable r0)
01:18:05 <lambdabot>          arising from a use of ‘show_M544484679659597489314867’
01:18:06 <lemmih> @pl \(a, b) -> (f a, f b)
01:18:07 <lambdabot> f *** f
01:18:53 <merijn> both requires lens, though and I'd rather steer people away from Arrow now that we have Bifunctor in base
01:22:04 <kaol> Thank you. I'll use bimap.
01:23:10 <kaol> It doesn't save me all that much typing in my case but I think it makes my code clearer.
01:26:06 <kaol> Still, I wish they had included some \f -> bimap f f in Data.Bifunctor.
01:28:56 <merijn> Me too
01:29:16 <merijn> On a completely unrelated note, anyone ever try mixing Pipes and ResourceT? How did that work out?
01:29:27 <Gundala> hi!
01:31:50 <ertes-w> note: (join bimap f) and 'both' don't work in every case
01:31:56 <ertes-w> sometimes you have to write (bimap f f)
01:32:44 <Gundala> anyone here playing with blockchain? or can refers to a blockchain discussion channel?
01:32:47 <ertes-w> merijn: i have, and it worked well enough, if you don't do "pipes exception handling"
01:33:50 <merijn> ertes-w: What do you mean by that?
01:34:37 <ertes-w> merijn: pipes really wants you to use pipes-safe, if you want to do brackets that include proxy actions
01:35:08 <merijn> ertes-w: I know, but SafeT is lacking instances I'd need to make code portable between pipes and conduit >.>
01:35:25 <merijn> ertes-w: I already complained to Tekmo about that, but he's being all principled about it
01:35:28 <ertes-w> merijn: if you can live without those, ResourceT is perfectly fine
01:35:54 <ertes-w> merijn: and if you do need them, you can probably write the necessary MonadResource instances
01:36:36 <ertes-w> merijn: yeah, Tekmo will always value soundness/simplicity over features
01:37:14 <merijn> "simplicity", lol
01:37:37 <merijn> I like pipes, it's elegant, but dear god can it be a PITA to use compared to conduit
01:37:42 <ertes-w> well, simple ≠ easy =)
01:37:53 <merijn> ertes-w: It's also definitely not simple
01:38:23 <ertes-w> yeah, that's why i moved away from pipes…  it's a great library to explain stream processing, but not necessarily to *do* stream processing in
01:38:26 <merijn> ertes-w: Took me like a week of staring at types to figure out how the hell parsers worked
01:39:31 <ertes-w> oh, i found those fairly easy to understand:  StateT (Producer a m) m  -- operate on a producer, ask for values, etc.
01:39:39 <ertes-w> but they are painful to work with
01:39:44 <merijn> ertes-w: I mean, I'm reaching the point where I wonder why I even bother trying to accomodate pipes. Yeah, I like it's conceptual elegance and it's the first library I used. But it's making my twist my API in convoluted ways and isn't actually all that useful in the real world since like >50% of libraries seem to want conduit anyway
01:40:38 <ertes-w> merijn: same observation, except i moved to a library that has even fewer libraries available =)
01:41:37 <ertes-w> i found myself just converting between conduits and machines, so that i can keep using machines and not deal with the API of conduit
01:41:41 <merijn> ertes-w: The annoying thing is, that all I'd need is an UnliftIO instance for SafeT, which, given it's similarity to ResourceT should be easy enough to add and would incur an absolutely minimal extra dependency
01:42:38 <kinboy> HLEP
01:42:57 <ertes-w> merijn: there are monad-control instances for SafeT, but Tekmo rejects UnliftIO?
01:43:33 <cocreature> ertes-w: that seems like an … interesting choice
01:43:40 <merijn> ertes-w: Yup
01:43:46 <ertes-w> that's kinda weird
01:43:57 <merijn> ertes-w: And I really don't want to a monad-control dependency because I hope that package dies
01:45:34 <ertes-w> i don't mind monad-control, but it's UnliftIO on steroids…  why would one accept monad-control, but reject UnliftIO?
01:46:02 <merijn> ertes-w: I mind it in that, literally every time I encounter it, the API confuses the fuck outta me
01:46:54 <cocreature> the “steroids” it provides also tend to be somewhat quirky at best, e.g., you end up silently discarding state and things like that
01:47:36 <ertes-w> merijn: just pretend that MonadTransControl doesn't exist and that MonadBaseControl is like MonadUnliftIO with state
01:47:54 <ertes-w> yeah, MonadUnliftIO is definitely cleaner
01:48:11 <merijn> ertes-w: Still sounds like more work than just avoiding it :p
01:50:51 <ertes-w> i wouldn't blame you for moving away from pipes…  the only feature i really like about it is pipes-group
01:51:43 <cocreature> "streaming" seems to make the grouping aspect more convenient than "pipes-group"
01:51:55 <cocreature> but I’ve admittedly not used it in anger
01:57:51 <ertes-w> yeah, 'streaming' is basically 'fuse', a library i started writing in 2014 but never finished (https://hub.darcs.net/ertes/fuse), but i disagree with most of its design decisions, and from today's perspective i'd also implement 'fuse' slightly differently
01:58:19 <merijn> ertes-w: Well, I've made a 2nd plea to add the instance, but yeah, I'm seriously considering just getting rid of my support for pipes on account of it being too much of a PITA
01:59:17 <ertes-w> but then machines does everything in a much better way than both of them…  that's why i abandoned the project
01:59:58 <ertes-w> it's also truly compatible with conduit, unlike pipes
02:00:25 <ertes-w> so i can use most conduit libraries at the cost of using a conversion function
02:01:00 <merijn> On a *completely* different note: I wish StateT had a modify function that was like modifyMVar
02:01:26 * hackage monad-control-aligned 0.0.1.1 - Just like monad-control, except less efficient, and the monadic state terms are all * -> *  https://hackage.haskell.org/package/monad-control-aligned-0.0.1.1 (athanclark)
02:01:45 <merijn> That's...an interesting synopsis :p
02:01:51 <cocreature> “just like monad-control except less efficient” doesn’t sound like a great sales pitch ;)
02:02:51 <ertes-w> oh come on, ByteString is just like Vector Word8 but less efficient, and we buy it all the time =)
02:03:44 <cocreature> ertes-w: if that’s how the bytestring lib described itself, I doubt we would use it all the time ;)
02:04:34 <xandaros> "whos' state types are"...
02:04:56 <xandaros> That is wrong on so many levels. I don't even...
02:08:19 <ertes-w> merijn: StateT?
02:11:11 <Aravindh> Hello, Can someone tell me if the base package in haskell can be used to send out network requests? If not, what is the basic networking library provided in haskell
02:11:43 <cocreature> Aravindh: depends on the kind of network requests that you want to use. if you want something low-level take a look at the "network" library
02:11:45 <merijn> Aravindh: You'll want the network package
02:12:01 <ertes-w> merijn: or what feature from modifyMVar do you need?
02:12:26 <merijn> ertes-w: I guess I want "state"
02:12:37 <tdammers> Aravindh: http://hackage.haskell.org/package/base <- this is all of base, there is nothing about networking in there
02:12:47 <merijn> (from mtl that is)
02:13:02 <ertes-w> merijn: either that or StateT itself, if you need effects
02:13:18 <merijn> Or I should just suck it up and use lens
02:13:33 <tdammers> Aravindh: https://hackage.haskell.org/package/network for low-level networking, otherwise, you'll need to be more specific about your needs
02:13:51 <Aravindh> Is network package part of the standard distribution or it is some open source project that is not part of haskell distribution?
02:14:19 <merijn> Aravindh: What do you mean by "haskell distribution"?
02:14:38 <tdammers> which standard distribution? the base library is built into the compiler itself, everything else is open source packages on hackage, but there are distributions like haskell-platform that come with popular packages preinstalled
02:14:54 <tdammers> but there is no "standard distribution" really
02:15:12 <merijn> ertes-w: Just feels wasteful to incur all of lens' dependencies just for zoom and (%%=)
02:15:32 <Aravindh> Ah ok. I just wanted to know if I can do network requests (TCP & HTTP) just by installing the base package
02:15:48 <Gurkenglas> merijn, you mean state literally fulfills your purpose, or you want a monadic version of state?
02:15:53 <Aravindh> I assume I cannot do it and https://hackage.haskell.org/package/network  is the most basic low level network imlementation
02:16:24 <merijn> Gurkenglas: No, I have a transformer stack and I want to apply pure updates within it
02:16:58 <Gurkenglas> merijn, "modify $ microlensaccessor %~ update"?
02:17:49 <merijn> Gurkenglas: Nope, that's just modify
02:18:01 <guessWHo> is there any lib or framework which support event driven programming in haskell ??
02:18:10 <Gurkenglas> merijn, give me a type signature dammit :D
02:18:13 <merijn> Gurkenglas: "modify :: (s -> s) -> StateT s m ()" I want "(s -> (a, s)) -> StateT s m a"
02:18:30 <merijn> Gurkenglas: I already went over microlens, it doesn't have the right operator afaict
02:18:36 <Gurkenglas> so how is that different from state
02:19:16 <tdammers> clearly, we need an abstraction layer to iron out the API differences between all the lens implementations out there
02:19:18 <merijn> Gurkenglas: It isn't, I just said "I guess state", but then if I use a record as state it becomes annoying so I'd want "zoom", but microlens doesn't have the right operator
02:19:33 <merijn> tdammers: microlens is just lens without the dependencies and less functionality
02:19:35 <cocreature> microlens is a great way of making everyone depend on two different lens libraries rather than actually reducing dependency footprints
02:20:28 <tdammers> the elephant in the room is adding lenses to either GHC or base
02:21:05 <merijn> cocreature: Well, I'm writing an executable so it'd only be one for me :p
02:21:21 <merijn> Actually, I suppose I could just run "state" inside "zoom"
02:21:26 <cocreature> merijn: fair enough, I’ve just seen projects that transitively depend on multiple lens libraries way too often
02:21:33 <tdammers> hmm, or you could implement zoom yourself
02:21:38 <lemmih> guessWHo: In what way? Event driven programming is pretty much the default in Haskell.
02:21:43 <tdammers> accidentally did that once
02:21:52 <robstr> Is there a general way to "unwrap a newtype", like `m a -> a` - hope this makes sense :P ?
02:22:11 <merijn> cocreature: See also the problem with "parser", etc.
02:22:12 <lemmih> robstr: There is not.
02:22:13 <cocreature> robstr: it doesn’t because a newtype is not of the form "m a" in general
02:22:27 <tdammers> :t coerce
02:22:28 <lambdabot> error:
02:22:29 <lambdabot>     • Variable not in scope: coerce
02:22:29 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
02:22:35 <merijn> tdammers: That sounds both like work AND annoying
02:22:55 <guessWHo> lemmih : you say that because functions in haskell can be passed just like values ??
02:23:01 <tdammers> merijn: yes, but right now you cannot win either way
02:23:09 <cocreature> oh yeah good point, coerce should work
02:23:14 <cocreature> lens also has a Wrapped typeclass
02:23:18 <merijn> guessWHo: No, because GHC has support for lightweight threading
02:23:33 <lemmih> guessWHo: No, I say it because the IO model in GHC is event driven.
02:23:34 <merijn> tdammers: Sure I can, microlens does have "zoom"
02:23:39 <tdammers> robstr: coerce... although, ugh
02:23:40 <Gurkenglas> :t state . _1 :: Monad m => (a -> (x, a)) -> StateT (a,b) m x -- merijn
02:23:41 <lambdabot> Monad m => (a -> (x, a)) -> StateT (a, b) m x
02:23:57 <guessWHo> merijn : didn't really get that can you please expand a bit on that ??
02:24:04 <tdammers> merijn: I thought you said it didn't
02:24:09 <robstr> tdammers: sounds like coerce is not the recommented way :D
02:24:12 <merijn> tdammers: It didn't have %%=
02:24:44 <cocreature> merijn: iirc hledger manages to depend on attoparsec, parsec, megaparsec and at some point it also had a dependency on trifecta ;)
02:24:53 <merijn> tdammers: Which applies "a -> (r, b)" through a "Lens s t a b" inside state
02:24:59 <tdammers> robstr: the "clean" way is to use Control.Newtype, but unlike Coercible, instances aren't automatic
02:25:04 <merijn> tdammers: So it does what I want in one step
02:25:08 <tdammers> robstr: http://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html
02:25:18 <lemmih> guessWHo: I think this documentation can help you: https://hackage.haskell.org/package/base-4.11.0.0/docs/Control-Concurrent.html
02:25:23 <Gurkenglas> merijn, that :t query does what you wanted, right?
02:25:50 <merijn> tdammers: But "state" does what I want if my state is what I wanna apply my function to and zoom can minimise my state to what I need
02:26:19 <tdammers> merijn: well, problem solved then, right?
02:26:40 <guessWHo> lemmih : i'm familiar with this module any particular topic you want to point me towards ?
02:26:41 <Gurkenglas> no zoom in microlens, he wanted to do without
02:26:41 <merijn> tdammers: Well yes, that's what i said before your remark :p
02:26:51 <merijn> Gurkenglas: microlens-mtl has zoom
02:26:54 <tdammers> merijn: oh, missed that. sorry for the noise then.
02:27:28 <lemmih> guessWHo: Well, that is an event driven programming library which is what you asked for.
02:28:31 <guessWHo> lemmih : in what sense do you say it's an event driven lib ?? it's a lib for concurrency
02:28:47 <lemmih> guessWHo: Yep. Event driven concurrency.
02:28:49 <merijn> guessWHo: You haven't said what you even mean by "event driven lib"
02:29:34 <robstr> tdammers: ty, coerce works
02:30:45 <tdammers> robstr: fwiw, personally I prefer to do the unwrapping explicitly and per-newtype
02:30:51 <guessWHo> merijn : suppose i have a lib  which runs a udp server and then i want to provide user of this lib to be able to process incoming request so in node.Js we have event Handler which will be triggered when a particular event is fired in this case message is received at UDP server and then lister can do its job
02:30:58 <tdammers> robstr: that, or derive the instances I need and use the methods on the newtype directly
02:31:26 <merijn> guessWHo: Yeah, that's the silly and hard way of doing things
02:31:38 <robstr> tdammers: with explicit you mean by pattern matching, right ?
02:32:01 <guessWHo> merijn : alright so what's the efficient way ??
02:32:01 <merijn> guessWHo: GHC's concurrency model just uses 1 thread per connection with blocking calls. The runtime automatically unschedules/reschedules threads when they block/unblock
02:32:12 <tdammers> robstr: pattern matching or record field, yes. newtype Foo = Foo { unFoo :: Something }; and then explicitly use Foo and unFoo to wrap and unwrap
02:32:24 <merijn> guessWHo: So the efficient way is "just write blocking code, because the runtime automatically makes run in an event-driven way"
02:33:00 <robstr> tdammers: cool, ty
02:33:56 * hackage doctest-driver-gen 0.2.0.2 - Generate driver file for doctest's cabal integration  https://hackage.haskell.org/package/doctest-driver-gen-0.2.0.2 (Hexirp)
02:34:03 <guessWHo> merijn : and i can let user of lib to provide a message Handler function as input when they call the run server >?
02:34:33 <cocreature> robstr: the main advantage of "coerce" is that you can use it to convert from [a] to [b] if a is a newtype of b. with explicit unwrapping you still pay the cost of traversing the list and doing a noop at each step
02:34:50 <merijn> guessWHo: sure
02:34:54 <cocreature> apart from those cases explicit unwrapping/wrapping is usually easier to read ime
02:35:33 <guessWHo> merijn : what exactly do you mean when you say "The runtime automatically unschedules/reschedules threads when they block/unblock"
02:35:52 <guessWHo> merijn : not this
02:35:55 <robstr> cocreature: haha great, exactly my use-case
02:36:17 <merijn> I'm not sure what to add to that description?
02:36:18 <guessWHo> merijn : yeah so what do you mean when you say this "because the runtime automatically makes run in an event-driven way""
02:36:59 <cocreature> robstr: note that this does not work for every type. e.g. you can’t convert "Map a v" to "Map b v"
02:37:09 <merijn> guessWHo: Because it uses epoll/kqueue/etc. to check which threads are blocked on IO and only ever schedules unblocked threads, so blocking a thread doesn't stop you from computing
02:37:26 <xandaros> cocreature: So THAT is why people say unsafeCoerce is more efficient. I never quite understood this :D (I feel like the compiler should be able to optimise this, though. Maybe in the future it will become a non-issue)
02:38:57 <merijn> xandaros: Also, coerce is actually semantically safe IFF people have proper role annotations on their datatypes
02:38:59 <cocreature> xandaros: optimizations always tend to be heuristic. one of the nice things about newtypes is that we’re actually guaranteed that they’re “free” so it’s nice to not rely on compiler heuristics for this kind of optimization.
02:39:34 <guessWHo> merijn : no i'm asking about the part where you say runtime make run in an event driven way ? how are the event and when they are fired ?? and also that's happening under the hood what if i want event driven abstraction at top level why is that inefficient ??
02:40:12 <guessWHo> any thoughts on this lib anyone ? https://github.com/ChrisPenner/eve >
02:40:42 <xandaros> cocreature: On the other hand, it's nice to have the compiler do this for you, so you don't have to think about it. I only optimise if I really need to. I use Haskell very much as a high-level language and I don't want to be concerned with these things. If I care about efficiency, I use rust instead
02:41:22 <cocreature> sure there’s always a tradeoff
02:42:03 <cocreature> but mapping over a list fo explicitly wrap/unwrap is also more work for me as a programmer than just using coerce so in this case I’m more than happy to help the compiler out :)
02:43:34 <lemmih> guessWHo: You don't have to worry about blocking calls in Haskell. Just write the code any way you like and GHC will make sure it runs efficiently.
02:43:57 <xandaros> There is some truth to that. But I feel like mapping over the list is more readable, so I'd probably still opt for that
02:44:08 <cocreature> to each their own :)
02:46:12 <guessWHo> lemmih : i'm not worried about blocking calls i'm worried about how to call a function each time a blocking calls done doing its processing and pass the result to another function , i understand functions are first class value and can be paased around but what i don't understand as merijn says that an abstraction like events is really not efficient ??
02:47:25 <merijn> you...just use the result of blocking call?
02:47:37 <merijn> I don't understand the problem?
02:47:59 <lemmih> guessWHo: Don't worry about it. First call the blocking function and then call the other function. GHC will automatically make sure it works.
02:48:12 <merijn> Like, you just do a receive and then write code that uses the result?
02:49:02 <guessWHo> merijn : is this is what you guys are suggesting ? http://lpaste.net/364056
02:49:50 <guessWHo> merijn : sorry this one http://lpaste.net/364057
02:50:29 <merijn> Just do: http://lpaste.net/364056 ?
02:51:32 * hackage buffon 0.1.0.1 - An implementation of Buffon machines.  https://hackage.haskell.org/package/buffon-0.1.0.1 (DerekElkins)
02:52:01 <guessWHo> guessWHo : that's okay but why are abstraction like events are not efficient or this is this lib redundant https://github.com/ChrisPenner/eve ?
02:52:22 <lemmih> guessWHo: We didn't tell you that events are not efficient.
02:52:43 <guessWHo> lemmih : actually merijn did so..
02:53:17 <lemmih> guessWHo: That library is for implementing dispatches/listeners which is a different thing altogether.
02:53:35 <lemmih> guessWHo: No, it's what you understood but it's not what he said.
02:55:11 <lemmih> guessWHo: But don't worry about it. Just call the blocking functions as merijn showed you and everything will work just fine.
02:56:13 <guessWHo> lemmih : listeners are for event, listeners are listening for events and once the event triggers the listeners will fire so it has to do with event infact what else are listeners if not in context of events ??
02:59:09 <lemmih> guessWHo: I promise you that you do not need to use the eve library for writing a server. The eve library is for managing state which is different from managing non-blocking IO.
03:02:37 <guessWHo> lemmih : uhh. i'm confused. so you are saying eve is not for event driven programming while it says so on its github and hackage
03:03:26 <guessWHo> lemmih : what do you mean by it's for managing states ?? and also running a server is blocking IO isn't it ??
03:04:42 <lemmih> guessWHo: eve is a red herring. Focus on your immediate problem (if you have one).
03:06:03 <lemmih> guessWHo: Try actually writing a server in Haskell. Perhaps an echo server that just repeats what you send it. That will teach you about how blocking IO works in Haskell.
03:08:16 <ertes-w> merijn: you could use microlens-mtl
03:08:31 <ertes-w> merijn: that one has 'zoom', 'magnify', etc.
03:08:32 <guessWHo> lemmih : i have already written a server in haskell with Network.Socket but what that has to do with my question ??
03:09:26 <lemmih> guessWHo: And your server uses blocking IO while at the same time handling multiple clients at the same time without blocking, right?
03:09:58 <guessWHo> lemmih : yeah
03:10:24 <lemmih> guessWHo: That's possible because the underlying implementation uses events. You just don't have to deal with them directly in the code.
03:10:35 <lemmih> guessWHo: GHC takes care of it for you.
03:11:21 <lemmih> Which is much nicer than dealing with it manually like you do in nodejs.
03:14:10 <guessWHo> lemmih : okay now it makes sense what merijn said (GHC handles one connection per thread )
03:27:56 <marvin3> ghc threads are very lightweight, creating thousands of them is nothing
03:36:03 <fr33domlover> lyxia, side note about yesterday: TH qq does capture variables from the scope, e.g. let f x = [| x ++ " world" |] in $(f "hello")
03:36:32 <fr33domlover> (well there GHC stage restriction but if you write them separately)
03:43:24 <humanoyd> bikeshedding, but why did `Data.Functor.Coproduct` (comonad) get removed in favor of `Data.Functor.Sum` (transformers)? Is the term `Sum` more accurate in this case?
03:55:07 <ertes-w> humanoyd: "coproduct" and "sum" are basically the same concept, except that the former term highlights its duality with products
03:59:54 <ertes-w> @where pcph
03:59:54 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>,<https://web.archive.
03:59:54 <lambdabot> org/web/20180117194842/http://chimera.labs.oreilly.com/books/1230000000929>
04:00:13 <ertes-w> guessWHo: ^ read The Book
04:01:26 * hackage uniprot-kb 0.1.0.1 - UniProt-KB format parser  https://hackage.haskell.org/package/uniprot-kb-0.1.0.1 (zmactep)
04:07:48 <merijn> hmmm, I keep remembering that some transformers had issues with recursive loops, that required using fix, but I keep forgetting which ones that affects
04:15:42 <lyxia> fr33domlover: I think the difference is that x was in the type before [| Proxy :: Proxy x |] so x was not looked up in the same namespace.
04:16:27 <fr33domlover> lyxia, yes absolutely
04:16:48 <fr33domlover> just side-noting that at least values are inserted fine
04:17:06 <fr33domlover> I did it with ConT $ mkName x
04:17:09 <fr33domlover> So, untyped TH
04:25:09 <fr33domlover> Hmm anyone knows if there's a TH Lift instance for Text somewhere?
04:25:35 <fr33domlover> (Actually I guess maybe there shouldn't be, not sure)
04:27:18 <merijn> fr33domlover: Standalone derive it?
04:27:20 <merijn> fr33domlover: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-lift-instances
04:27:38 <fr33domlover> merijn, yeah sure it's a trivial instance
04:27:55 <lyxia> https://hackage.haskell.org/package/th-lift-instances
04:27:56 <fr33domlover> Hmm looks like persistent uses one but just internally
04:31:00 <fr33domlover> Thanks lyxia
04:38:21 <merijn> @hoogle Monad m => (a -> m (Maybe a)) -> m ()
04:38:22 <lambdabot> Data.GI.Base.Utils whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
04:38:22 <lambdabot> Language.C.Analysis.TravMonad maybeM :: (Monad m) => (Maybe a) -> (a -> m ()) -> m ()
04:38:22 <lambdabot> Control.Monad.IfElse awhen :: Monad m => Maybe a -> (a -> m ()) -> m ()
04:38:30 <cocreature> does text have a stateful version of "span" somewhere?
04:39:14 <merijn> hmmm, "foo f = f >=> maybe (return ()) (foo f)" isn't implemented anywhere?
04:49:08 <infinity0> hey guys, in emacs+haskell-mode when i run (haskell-mode-jump-to-def) for symbols in the local project it performs the jump, but for stuff like "return" it simply prints out "Defined in 'GHC.Base'"
04:49:31 <infinity0> how do i get it to perform the jump to the actual Base.hs file in the system GHC package?
04:49:49 <pagnol_> infinity0, how did you get the first part to work at all?
04:50:15 <infinity0> pagnol_: you have to set up "interactive commands" as in here https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md#interactive-commands
04:50:36 <infinity0> then (add-hook 'haskell-mode-hook (lambda () (define-key haskell-mode-map (kbd "M-.") 'haskell-mode-jump-to-def)))
04:55:48 <infinity0> so one issue maybe is that ghc-prim is installed into /usr/lib/ghc/ghc-prim-0.5.0.0 and not ~/.cabal
04:56:07 <infinity0> not sure which tool i am supposed to tell about this path...
04:59:28 <cocreature> ahrg megaparsec doesn’t expose its internals
04:59:46 <cocreature> why do people keep doing this … :/
05:00:35 <fakenullie> Incapsulation
05:02:46 <cocreature> I can’t recall a single instance where problems have been caused by someone exposing the internals in some .Internal module
05:03:00 <merijn> bleh
05:03:32 <merijn> I wish there was a nicer way to write "foo >>= fix (\loop -> ...)" the parenthesis are horrific, but can't use $ :\
05:03:56 <fakenullie> Because internals which could cause problems were not exposed
05:05:00 <cocreature> that’s not true, e.g., if you mess with the internals of the text package you can certainly screw up
05:07:20 <barrucadu> Exposing internal modules increases the range of incorrect *and* correct code people can write, while not compromising the correctness of the non-internal interface
05:10:55 <tdammers> the biggest problem with using internal modules is that you now depend on code that may change on any package update, so you essentially have to pin your dependency on an exact, existing upper bound
05:11:33 <lyxia> well the alternative is that you can't write the code in the first place
05:12:19 <tdammers> sure
05:12:27 <tdammers> or that you have to find other ways of writing it
05:12:38 <tdammers> so it's a matter of priorities
05:13:22 <cocreature> it’s not like anyone is stopping you from finding other ways of writing it if the internal modules are exposed
05:13:31 <tdammers> true
05:13:37 <cocreature> you’re just removing that choice from users if you don’t expose the modules
05:13:50 <tdammers> I didn't mean it as a reason to not *expose* internal modules, but rather as one against *using* them
05:13:56 * hackage keysafe 0.20180326 - back up a secret key securely to the cloud  https://hackage.haskell.org/package/keysafe-0.20180326 (JoeyHess)
05:14:10 <tdammers> so yeah, as long as it's perfectly clear that they're internal, it's probably better to expose them
05:14:22 <cocreature> sure I’m certainly not arguing for using Internal modules if it can be avoided
05:14:43 <tdammers> it's just a bit of a conundrum that there is no explicit tool-supported way of doing that
05:14:57 <tdammers> you can't say "OK, I'm exposing this module, but it's an internal module"
05:15:14 <tdammers> and you can't say "look, I know it's an internal module, but I know what I'm doing, so import it anyway"
05:15:27 <tdammers> all we have is the convention that internal modules should be named .Internal
05:15:30 <cocreature> dunno, I haven’t seen that being a problem in practise
05:15:50 <ertes-w> seconded…  expose the internals
05:15:53 <tdammers> well, yeah, I'm complaining at a very high level of sophistication here
05:16:57 <ertes-w> i avoid libraries that don't do it…  not exposing internals is not a matter of priorities, but a matter of the author patronising you
05:17:02 <ertes-w> it's annoying and useless
05:17:31 <merijn> ertes-w: So you avoid base? ;)
05:17:59 <cocreature> at least in this case it looks like it’s planned for the next version of megaparsec
05:18:02 <ertes-w> merijn: i'm not aware of any base APIs that don't expose internals
05:18:10 <merijn> ertes-w: Lots of parts of Control.Concurrent
05:18:19 <filwisher> I'm trying to upload a package to hackage but receiving a `Forbidden. No access for this resource` error. Does anyone know a workaround for this?
05:18:21 <barrucadu> With the number of alternative preludes, it seems a lot of people do want to avoid base :p
05:18:30 <merijn> filwisher: Did you just register your account?
05:18:40 <filwisher> merijn: yes
05:18:48 <ertes-w> merijn: like what?
05:19:04 <cocreature> apparently my change to add a red box around the note and move it above the register button wasn’t sufficient :(
05:19:14 <merijn> filwisher: Due to spammers new account are by default not allowed to upload right now, you need to mail the admins to be added
05:19:26 <merijn> filwisher: Presumably the address is somewhere on the signup page
05:19:28 <filwisher> Ah OK, thank you!
05:19:54 <filwisher> I was clicking through pretty quickly so I didn't read this properly. I will go back, thanks for the help
05:19:56 <merijn> ertes-w: The internals of Chan
05:21:27 <ertes-w> merijn: right…  well, so far i was happy considering Chan a primitive
05:22:13 <ertes-w> merijn: also not exposing Chan internals is very different from a parser library not exposing internals
05:22:40 <merijn> ertes-w: Why? (I mean, I somewhat agree, but can't articulate why)
05:25:18 <ertes-w> merijn: me neither, but i think Chan and Parser are very different kinds of abstractions
05:25:32 <ertes-w> but then i would very much mind if ByteString didn't expose its internals
05:26:09 <cocreature> I guess concurrency feels more like a primitive build into the language than parsers
05:26:12 <cocreature> *built
05:26:22 <cocreature> and Chan falls under the “concurrency” umbrella
05:26:41 <ertes-w> well, maybe it's just a case of "i've never needed this, so i never noticed"
05:26:48 <cocreature> that too :)
05:27:18 <ertes-w> i'd certainly vote for exposing
05:27:25 <merijn> ertes-w: I ask because I'm working on my own Chan library and like Chan I'm not exposing internals because it's way to easy for fucking things up subtly
05:27:43 <ertes-w> merijn: i'd still expose them
05:28:02 <ertes-w> merijn: it's way too easy to fuck things up with ByteString, too =)
05:28:13 <merijn> ertes-w: Usually more obvious, though
05:28:41 <ertes-w> merijn: it's fine, ".Internal" comes with a contract
05:32:20 <Ariakenom> ertes-w, with the only content "Here be dragons"?
05:36:44 <ertes-w> "in here there is only doom"
05:42:38 <exio4> "Once you import and use this module, don't complain about the exploding silicon"
05:44:52 <merijn> ok...someone help me refactor this mess to not suck: http://lpaste.net/5470670715894104064
05:49:56 * hackage staversion 0.2.1.4 - What version is the package X in stackage lts-Y.ZZ?  https://hackage.haskell.org/package/staversion-0.2.1.4 (debugito)
05:52:56 * hackage bindynamic 1.0.0.1 - A variation of Data.Dynamic.Dynamic with a Binary instance  https://hackage.haskell.org/package/bindynamic-1.0.0.1 (lspitzner)
05:56:57 * hackage basen-bytestring 0.1.0.0 -   https://hackage.haskell.org/package/basen-bytestring-0.1.0.0 (filwisher)
05:57:34 <chisui> Is there a strict version of foldr1?
06:04:29 <ertes-w> merijn: what don't you like about it?
06:05:13 <merijn> ertes-w: I dunno, feels like there should be a cleaner way to describe the logic...
06:05:23 <merijn> I don't find it particularly readable
06:05:58 <ertes-w> merijn: i had no trouble at all reading it
06:07:14 <ertes-w> merijn: it's more or less the way i would have written it
06:07:31 <ertes-w> except perhaps with a bit more verticality
06:07:50 <merijn> ertes-w: I'm not sure how to nicely linewrap this either >.>
06:08:40 <lyxia> merijn: http://lpaste.net/5470670715894104064#a364067 ?
06:09:14 <lyxia> putting report first so you don't need to carry the filepath to the next iteration
06:09:15 <ertes-w> merijn: i've annotated how i would have written it
06:09:25 <ertes-w> (the latter annotation)
06:10:02 <lyxia> :)
06:11:30 <ertes-w> ironically i found lyxia's version slightly harder to understand…  the fix-based version was immediately obvious to me
06:11:52 <lyxia> yeah looking back mine is not so readable
06:12:21 <lyxia> maybe there's a better way to lay it out
06:14:28 <merijn> It's a shame I can move Ghci as the last argument of innerLoop without ruining the sharing
06:14:33 <merijn> s/can/can't
06:14:43 <Botebo> Hi, y'all.
06:14:54 <lemmih> Hi Botebo.
06:14:59 <Botebo> I have a simple data structures' quesiotn I need some advice on.
06:15:17 <Botebo> How do I do time-series data?
06:15:31 <ertes-w> Botebo: depends…  what's the application?
06:15:44 <Botebo> Is there anything fancy to try, or is it merely (Seq UTCTime, Seq a) ?
06:15:58 <Botebo> The application? @ertes-w
06:16:33 <ertes-w> Botebo: Seq is very flexible, but it has a constant factor to be aware of, because it needs to do allocations for pretty much everything
06:17:00 <ertes-w> Botebo: a traditional ring buffer is very fast, but also much less flexible and annoying to use (needs effects)
06:17:01 <Botebo> I'm basically tryint to cache data from a database, and avoid having to do SELECT * FROM thing WHERE timestamp <= some_time
06:17:25 <ertes-w> Botebo: why do you want to avoid that?
06:17:27 <Botebo> Oh. Thanks, ertes-w. Hmm...
06:19:36 <Botebo> ertes-w: This query will be run frequenctly against the database, whereas the actual data itself will be mutated very infrequently. I'd rather cache it, and only access the database to write any changes (never run the SELECT against the DB).
06:19:47 <Botebo> It's a simple attempt at time efficiency.
06:20:48 <ertes-w> Botebo: i'm asking because for example if you're using sqlite doing the query every time will be much more efficient, and even with a nearby database server it may be better to do the query
06:21:10 <Botebo> ertes-w: PG, on AWS.
06:21:28 <ertes-w> Botebo: and you're not concerned about consistency?
06:21:33 <Botebo> ertes-w: Maybe I should do some benchmarks, then.
06:22:12 <Botebo> ertes-w: Consistency? Nah. This table is literally only read by one thread in one process.
06:33:26 * hackage frp-arduino 0.1.1.0 - Arduino programming without the hassle of C.  https://hackage.haskell.org/package/frp-arduino-0.1.1.0 (JeremyWright)
06:37:18 <tjg> If someon could show me how to fix this please:    http://lpaste.net/364070
06:37:37 <humanoyd> ertes-w: thanks, I was just wondering -- since `Sum` is already used in `Data.Monoid` -- why the non-taken name `Coproduct` wasn't kept
06:38:57 * hackage json-autotype 1.1.1 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-1.1.1 (MichalGajda)
06:40:11 <tjg> If someon could please help me fix this:  http://lpaste.net/364070
06:41:46 <tjg> Help!!!   http://lpaste.net/364070
06:42:27 * hackage json-autotype 1.1.2 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-1.1.2 (MichalGajda)
06:42:28 <cocreature> tjg: you have to be a a bit more patient :)
06:43:40 <tjg> cocreature: Ok just a little frustrated, I am trying to get everything up and running to start building websites.
06:44:00 <cocreature> tjg: you don’t install GHC using "stack build". stack will install GHC automatically
06:44:02 <lemmih> tjg: Why are you trying to build ghc?
06:45:33 <tjg> lemmih: do I install it instead, here is one of the startup instructions for: yesod using stack:          stack install yesod-bin --install-ghc
06:45:40 <tjg> stack install yesod-bin --install-ghc
06:45:54 <tjg> sorry, I pasted it all messed up.
06:52:15 <byorgey> does parametricity allow one to prove   first f . second g = second g . first f  for a Bifunctor ?
06:52:33 <byorgey> or can you prove it from the other laws?
06:53:14 <merijn> byorgey: "first id = id" and same for "second id", combined with parametricity that should be enough
06:53:30 <merijn> byorgey: Similar to how you only need "fmap id = id" for functor
06:54:51 <cocreature> tjg: yeah that commend should work
06:54:52 <byorgey> merijn: fmap id = id + parametriciy for Functor lets you prove   fmap (f . g) = fmap f . fmap g
06:55:19 <byorgey> the analogue for Bifunctor is that those id laws + parametricity lets you prove  first (f . g) = first f . first g  and  second (f . g) = second f . second g
06:55:31 <byorgey> does it also let you prove the thing I said about the interaction of first + second ?
06:55:53 <merijn> byorgey: The logic of why parametricity and fmap id are enough is that "fmap id" proves structure can't be changed and parametricity guarantees all 'a's must be touched
06:56:23 <tjg> cocreature: yeah and when I try to go to the indice file: sudo gedit ~/.stack/indices  , it shows me a blank window?
06:56:25 <merijn> And obviously, also due to parametricity, nothing but the 'a's can be touched
06:56:43 <cocreature> tjg: why are you trying to edit the index file? that should never be necessary
06:56:53 <byorgey> OK, intuitively I believe that.  But I'd like to figure out specifically what parametricity says in this case.  Janis Voigtlander's "Free Theorem Generator" seems to be down =(
06:56:57 <cocreature> tjg: also .stack/indices is a directory not a file
06:57:01 <merijn> byorgey: So if first can't modify the "structure" and can only touch 'a's, logically it's unobservable if you first modify all a's, then all b's or vice versa
06:57:38 <merijn> I'm too lazy to figure out the formal formulation of the intuition, though :)
06:57:56 * hackage hakyll 4.12.1.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.12.1.0 (JasperVanDerJeugt)
06:58:23 <tjg> cocreature: ok, am just trying different things to see how to fix it, I googled it and couldn't find an answer.
06:58:40 <cocreature> tjg: what exactly are you trying to fix?
06:59:41 <hexagoxel> merijn: added another annotation for your ghciLoop
07:00:20 <lemmih> tjg: I'm pretty sure it'll work if you just follow the instructions.
07:00:49 <hexagoxel> merijn: hope you like monad-loops and extra :D
07:02:05 <tjg> lemmih: Ok, I'll keep going, thank you guys for your input    ;)
07:03:07 <merijn> hexagoxel: not really, but maybe I'll just steal the code for those
07:13:21 <tjg> do I need to change one of my files in my Yesod project or is it a problem with my postgres database and server???    http://lpaste.net/364072
07:13:51 <cocreature> you need to create a role called web-proj in your postgres db
07:15:39 <carbolymer> has anyone tried to create distroless Docker image for haskell?
07:16:15 <tjg> cocreature: Ok, and do I need to create a postgres database for my Yesod project or will that be done for me automatically by Yesod ???
07:18:09 <cocreature> dunno, I’ve never used yesod
07:20:00 <mmaruseacph2> just sent out the call for contributions to the next edition of Haskell Community and Activities Report (HCAR34)
07:20:12 <mmaruseacph2> https://mail.haskell.org/pipermail/haskell-cafe/2018-March/128829.html
07:24:31 <infinisil> Will I ever be able to program in an imperative language again without wanting to make everything immutable and functional now that I've seen Haskell?
07:25:03 <ventonegro> Stay tuned for the answer after the commercials
07:30:30 <risciii> Infinisil: no.
07:30:56 * hackage quickcheck-classes 0.4.5 - QuickCheck common typeclasses  https://hackage.haskell.org/package/quickcheck-classes-0.4.5 (andrewthad)
07:31:41 <carbolymer> infinisil, that's your new bane of your existence
07:35:39 <infinisil> Well I guess I'll either have to find a Haskell job or convince others that immutability is superior
07:37:20 <lemmih> infinisil: I think the rest of the world is turning to our point of view. ReactJS is basically a breeze if you already know about frp and immutability.
07:37:35 <merijn> Is there a way I can get the non-fancy errors from pre-8.4 back?
07:37:56 <ddellacosta> infinisil: not that I'm recommending this path, but Clojure/Script also uses immutable data structures by default
07:38:13 <ddellacosta> if you want imperative + immutable
07:38:49 <bitemyapp> infinisil: PureScript's a pretty nice way to tidy up your frontend experience if you like Haskell.
07:39:00 <TMA> infinisil: the first option is easier; humans have evolved not to change their mind easily. [changing = losing an argument = political suicide]
07:39:20 <infinisil> Nobody *really* wants imperative code, the only ones that do are those that don't know anything else
07:39:39 <tdammers> No True Scotsman much?
07:39:57 <infinisil> (Am somewhat joking :))
07:46:05 <merijn> ertes-w: Actually, I think I've figured out what I disliked about my code. The fact that I'm repeatedly passing some values in and out of the inner most loop, because I have no other way to keep them across loops
07:48:03 <merijn> Maybe it'd be much simpler to just dump that into an IORef/MVar, that'd avoid the entire need to pass things across loops
07:48:32 <fakenullie> State?
07:50:53 <kaleo_> how can'i to cracked a android apk
07:51:24 <pd2000> '0.
07:51:34 <lemmih> kaleo_: Think you're in the wrong channel, buddy.
07:51:37 <byorgey> hi kaleo_ , do you have a question about Haskell? this is a channel for discussing the programming language Haskell.
07:53:10 <kaleo_> oh i'm sorry
07:53:17 <kaleo_> lemmih, thank you
07:58:15 <ertes-w> merijn: sounds more like StateT than IORef/MVar
08:00:10 <AWizzArd> What is the most (runtime-)efficient way to detect a URL in a ByteString/Text?  Regexp?
08:02:26 <kuribas> AWizzArd: Depends on the engine.  Parsec will be cleaner, and still performant.
08:04:51 <AWizzArd> kuribas: engine doesn’t matter, just pure efficiency
08:05:23 <kuribas> AWizzArd: then handwritten C
08:05:56 <c_wraith> I'm not sure about handwritten.  Most people don't write efficient state machines well by hand.  Maybe Ragel-written C. :P
08:07:11 <kuribas> with SIMD instructions...
08:07:51 <kuribas> for a large volume of text even using the GPU...
08:09:17 <merijn> Not sure the GPU would help you there much
08:10:21 <kuribas> AWizzArd: any reason to believe a simple Parsec parser wouldn't be good enough?
08:10:43 <thebnq> or attoparsec :)
08:11:44 <AWizzArd> I am just seeking input about what you guys think could be most efficient.
08:12:15 <AWizzArd> For C regexps there’s always Hyperscan: https://rust-leipzig.github.io/regex/2017/03/28/comparison-of-regex-engines/
08:12:30 <merijn> Most efficient given which constraints/circumstances?
08:27:22 <Ferdirand> hmmmm
08:28:23 <Ferdirand> anyone investigated text (or graphics) rendering as a monad ?
08:28:58 <Ferdirand> like, a (WriterT (coordinates) [] object) ?
08:31:28 <mclark1129_> is ghc-mod the only option for language support in text editors?
08:34:56 <shafox> I know the value of a field is "true" which is a Text, how do I convert to bool ?
08:35:22 <lemmih> shafox: How about 'field == "true"' ?
08:35:43 <shafox> lemmih: yep just got it after I posted.
08:39:46 <ocharles> Can anyone see why this coercion is failing?
08:39:48 <ocharles> :t coerce (Pair (Const True) (Compose (ReaderT (\n -> Identity (Just ( ord n )))))) :: (Bool, Char -> Maybe Int)
08:39:49 <lambdabot> error:
08:39:50 <lambdabot>     • Variable not in scope: coerce :: t0 -> (Bool, Char -> Maybe Int)
08:39:50 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
08:39:55 <ocharles> This is Data.Coerce.coerce
08:40:16 <Botebo> Here's a common question, which seems impossible to Google for:
08:40:20 <ocharles> With Data.Functor.Product.Pair, Control.Applicative.Const, Data.Functor.Compose.Compose, Control.Monad.Trans.Reader.ReaderT, Data.Functor.Identity.Identity
08:40:43 <Botebo> How do I generate an emacs TAGS file, including tags for symbols in libraries?
08:40:45 <ocharles> GHC says: Couldn't match representation of type ‘Product  (Const Bool) (Compose (ReaderT Char Identity) Maybe) Int’ with that of ‘(Bool, Char -> Maybe Int)’
08:41:03 <johnw> Botebo: for Haskell, you usually use hasktags
08:41:35 <johnw> although if you're adventurous, there are other ways (e.g., GNU global + pygments)
08:43:36 <ocharles> oh wait, I'm being stupid - of course I can't coerce Pair
08:43:46 <Botebo> johnw: Yes. But that produces a TAGS file only for my project, not the libraries I depend upon. "No jump handler was able to find this symbol" it says in SpaceMacs, when I try to jump to the definition of Int, for example.
08:44:48 <johnw> Botebo: ah, I see, you want to include the base libraries also
08:45:07 <johnw> Botebo: I've never tried to set it up to that extent
08:45:21 <johnw> instead, I use Hoogle when I'm curious about symbols from libraries
08:47:38 <ertes-w> Botebo: use haskell-mode and forget about TAGS
08:48:29 <ertes-w> Botebo: use the built-in haskell-interactive-mode, which uses a much better method to resolve symbols: it asks GHC directly
08:50:38 <Botebo> ertes-w: I'm using Intero. Are they not incompatible? Note that I'm not an emacs ninja: I know enough just to get my job done, so I'm not sure if I'm even asking the right questions.
08:52:26 <kuribas> What is the advantage of intero over playin haskell-mode?
08:52:29 <ertes-w> Botebo: intero should have that as well
08:52:35 <kuribas> plain
08:53:04 <ertes-w> kuribas: you get to experience the pleasures of being locked into stack
08:54:06 <kuribas> ertes-w: not for me then...
09:07:55 <jle`> i use lushtags
09:10:34 <johnw> jle`: nice, thanks for the pointer; I'd never heard of lushtags
09:10:51 <jle`> i mostly found it because hasktags wouldn't interact with tagbar for some reason
09:13:02 <jle`> oh i didn't notice that the question was asking about emacs
09:13:34 <cocreature> jle`: any ideas how it compares to codex? that’s what I’ve been using in the past
09:14:57 <jle`> hm, i'm not sure, i think lushtags only generates tags for your current file. i actually haven't heard of codex
09:15:17 <jle`> s/haven't/hadn't
09:15:23 <cocreature> ah ok
09:15:36 <cocreature> that reminds me I should setup codex again
09:15:48 <jle`> i'm not sure if codex integrates with tagbar
09:15:56 <jle`> tagbar integration was more or less the main goal of lushbar
09:15:59 <jle`> er, lushtags, heh
09:16:09 <cocreature> makes sense, no idea if codex does that
09:16:41 <jle`> i am sure they could probably coexist peacefully
09:17:06 <jle`> it would be neat of ^] jumps to the 'first' match from multiple tag files
09:30:33 <RaminHAL9001> ls
09:30:42 <vilu> I've noticed quite a bit of negative sentiment towards stack. As a Haskell beginner I don't really understand why that is? It seems like a reasonable solution to me and I fail to find a convincing argument when googling. What am I missing?
09:31:06 <vilu> (on the topic intero vs haskell-mode
09:31:08 <vilu> )
09:32:06 <lyxia> you're not missing anything
09:34:04 <kuribas> vilu: I am not against stack, but I don't want to be locked into it either...
09:34:06 <lseactuary> hi can someone help me solve the step3 command here: http://lpaste.net/2880842897110859776 i understand the error but im unsure how to fix it.
09:34:15 <vilu> Ok
09:34:36 <RaminHAL9001> @vilu as for me, I just don't like trying to figure out how to configure stack to do stuff. I have used Cabal for a long time, and I know it works, I don't have much need for Stack.
09:34:37 <lambdabot> Unknown command, try @list
09:34:51 <RaminHAL9001> @list
09:34:51 <lambdabot> What module?  Try @listmodules for some ideas.
09:35:02 <lemmih> lseactuary: Can you explain to me what the error message means?
09:35:14 <johnw> lseactuary: it wants a TurtleState, you're giving it a TurtleCmd
09:35:37 <johnw> because: type TurtleState3 = (TurtleState2, [TurtleState2])
09:35:45 <AWizzArd> kuribas: what level of being locked-in is fine? Locked into Haskell? GHC? Cabal? Nix?
09:35:48 <johnw> list of turtle state, not list of turtle command
09:36:04 <kuribas> AWizzArd: no level :)
09:36:05 <lseactuary> lemmih ye it wants (Position, Direction)
09:36:12 <vilu> Ok, good to know I thought I was missing something but I can certainly understand that. I personally went in to stack because of my fear of the infamous Cabal hell without ever having experienced it or properly understood that problem. It seemed like a small overhead over regular Cabal.
09:36:12 <lseactuary> but i dont get where i get this from
09:36:20 <kuribas> AWizzArd: there's not one tool which solves all problems.
09:36:26 <AWizzArd> True.
09:36:41 <johnw> kuribas: the One Ring
09:38:25 <lseactuary> oh wait
09:38:48 <lemmih> lseactuary: It feels to me that you're trying to write the function without understand what it should do. This is a very hard thing to do.
09:38:49 <lyxia> vilu: stack has some problems when it does not catch up to Cabal updates, and revisions break snapshots. But as a beginner if you can work with recent versions of GHC it's quite minor.
09:38:58 <lemmih> *understanding
09:39:29 <lseactuary> lemmih - i overlooked the original dis dir
09:39:30 <lseactuary> my mistake
09:39:32 <lseactuary> writing now
09:39:51 <kuribas> I think ghc error messages are actually quite clear
09:40:00 <vilu> lyxia Ok thanks for the input. I have yet to have any issues with Haskell and compilation so far.
09:40:47 <kuribas> much better than python :)
09:41:30 <thebnq> vilu: you can use cabal sandboxes for package issues
09:41:47 <AWizzArd> If I am in a company environment and can't push my libs to hackage – how do I best handle this? Using https://github.com/haskell/hackage-server ?
09:43:27 <lseactuary> lemmih this compiled but not sure it is right: http://lpaste.net/2880842897110859776
09:44:22 <vilu> okay, so would you say that Cabal has already solved the issue that Stack was created to solve?
09:45:30 <lemmih> lseactuary: It's a problem that you don't know what 'step3' should do. You're unlikely to implement it correctly until you figure this out.
09:45:50 <lseactuary> lemmih - 2 mins - i check the book and try to understand
09:48:46 <lyxia> vilu: yes
09:49:15 <vilu> Ok, I will give it a go to just run cabal then on my next project.
09:50:10 <kuribas> vilu: I had a few times a problem, which deleting .ghc and .cabal always solved.
09:50:34 <kuribas> vilu: and I always say yes to dangerous reinstalls.
09:50:50 <kuribas> vilu: but new-build will make even that not necessary anymore.
09:51:15 <vilu> When you say dangerous reinstalls, what do you mean exactly?
09:51:50 <kuribas> reinstalling is supposed to be dangerous, but I never had a problem.
09:52:13 <kuribas> it might mess things up
09:52:53 <glguy> "forced" reinstalls are dangerous. These are the ones where you're replacing the version of an installed package that something else was depending on where that package isn't going to be rebuilt, so you're breaking other installed packages
09:53:05 <lseactuary> lemmih: this makes more sense to me:  step3 dis dir (Left []) ((p,d), []) = (((p,d), []), Just [(p,d)])
09:53:19 <lseactuary> can i confirm my understanding then i can try the other case
09:53:44 <glguy> Instead of leaving broken packages installed you could have uninstalled them. Leaving them installed just leads to future failed builds later. new-build works today and avoids that concern
09:54:07 <lemmih> lseactuary: I have no idea what 'step3' should do. I can't confirm if what you wrote is correct or not.
09:54:29 <lseactuary> it is the same as what i have in the paste, i just replaced ts2 with (p,d) which is (position, direction)
09:55:03 <lemmih> lseactuary: Yup. You didn't change the code at all. I still have no clue what 'step3' is supposed to do.
09:55:19 <lseactuary> ah sorrry it should be refreshed now
09:55:51 <lemmih> lseactuary: That change doesn't change anything. The code literally means exactly the same as before.
09:56:00 <lemmih> lseactuary: It's like changing 4 into 2+2.
09:56:09 <lseactuary> yup i am trying to understand what is happening for now
09:56:13 <lseactuary> then later i can clean it up
09:56:51 <lseactuary> so what i am seeing is we start at (p,d) and append any additional points to it, applying the Left [] to each of the points in the list
09:57:35 <lseactuary> and then the right hand side of the bracket, the just (p,d) is just the compile3 of (p,d)?
09:58:38 <lemmih> You've completely lost me.
09:59:14 <lseactuary> im trying to understand what is happening step3 dis dir (Left []) ((p,d), []) = (((p,d), []), Just [(p,d)])
09:59:27 <lseactuary> so it looks like we have 2 components on the right
09:59:39 <lemmih> lseactuary: Right, it's called a tuple.
09:59:48 <lseactuary> ((p,d), []) and Just [(p,d)]
09:59:49 <lseactuary> yup
10:00:05 <lseactuary> so the Just [(p,d)] is just the Maybe of the first element of the tuple
10:00:29 <lseactuary> the (p,d), [] is basically the last argument of the left hand side
10:00:33 <lemmih> No, that's the second part of the tuple.
10:00:49 <lseactuary> ah you mean the overall tuple
10:00:50 <lseactuary> ye
10:01:00 <lemmih> What overall tuple?
10:01:06 <lseactuary> (((p,d), []), Just [(p,d)])
10:01:19 <lemmih> Right, that's a tuple.
10:01:27 <lseactuary> == (x,y) where x = ((p,d), []) and y = Just [(p,d)]
10:01:45 <lseactuary> y = Maybe fst x
10:02:01 <lseactuary> and x is the last part of step3 dis dir (Left []) ((p,d), [])
10:02:03 <lemmih> Now you've lost me again.
10:02:24 <lseactuary> hmm ok lets go left to right
10:02:35 <lemmih> Is there an overflow channel for these discussions? #haskell-teaching ?
10:02:47 <lseactuary> the first (p,d) in the right hand side comes from the last argument on the left hand side
10:02:55 <lseactuary> correct/
10:03:17 <lemmih> lseactuary: Mind moving to #haskell-overflow? I feel we're spamming the rest of the channel.
10:03:22 <lseactuary> sure
10:03:23 <amalloy> lemmih: #haskell-beginners exists, but there's nothing terribly wrong about doing it here
10:25:04 <anks> Are custom unary operator supported in GHC ?
10:27:06 <anks> I guess they are not.
10:27:22 <Ferdirand> you can use sections
10:28:27 <guest____> any suggestion for text based irc client ??
10:28:35 <Ferdirand> you may need to enable PostfixOperators if you want more leeway with the type
10:29:37 <amalloy> Ferdirand: what do you mean by "use sections"? i tried   let (=:) x = not x    and expected one of (True =:) or (=: True) to work, but neither does
10:30:01 <amalloy> of course (=:) True works, but that doesn't seem like a section to me
10:34:33 <cocreature> amalloy: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#postfix-operators
10:35:16 <MacSlow> Greetings everybody!
10:40:04 <ospa> Hi! I've connected a C function to create C std intset. I would like to ask you if it would be unsafe if I unse unsafePerformIO to evaluate this C function. I think it should be safe, because it only creates an empty set, so nothing should go wrong, right ?
10:47:12 <cocreature> ospa: sounds like it should be safe but without seeing the code it’s hard to say :)
10:48:11 <amalloy> i imagine it depends what "creates an empty set" means. if it allocates memory and returns a pointer to a set, then i wouldn't be surprised to see issues
10:49:40 <amalloy> if you write: let {x = mkSet; y = mkSet} in {do {modify x; read y}} you might be surprised to see that y has changed
10:51:50 <anks> Ferdirand: thanks
10:53:23 <xplat> no idea what a C std intset is.  is that some new C11 thing?
10:56:12 <MacSlow> xplat: std::set<int> if that helps
10:56:13 <[exa]> maybe std::set<int> ?
10:56:36 <xplat> that's not C, it's C++.  though it could be what was meant for all i know
10:56:51 <MacSlow> xplat: no duplicate elements and and underlying tree iirc
10:58:43 <jle`> nah just a bitvector the size of int
10:58:52 <MacSlow> xplat: I cannot recall something like intset being part of ANSI C's standard library
10:59:30 <xplat> if it's that one, then you can't safely create a new one with unsafePerformIO unless you use it with a very restricted (and slow) subset of the interface
10:59:47 <jle`> well
10:59:55 <jle`> if all you do is create one, and you can't manipulate it at all, it should be safe
11:00:29 <jle`> so what opsa is asking is safe from the information they gave
11:00:58 <xplat> that's just a special case of what i said.  the most restricted, and slowest (because inserts literally never finish) interface subset
11:01:06 <jle`> yes, we are agreeing :)
11:02:07 <jle`> if you do anything with the result, it's most likely not going to be safe
11:02:17 <jle`> but if you don't do anything with the result, it is safe.  you might leak memory.
11:02:40 <amalloy> i would love to see a project that depends on an intset library but only works with empty sets
11:03:26 <amalloy> type IntSet = ()
11:03:27 <jle`> type IntSet = ()
11:03:31 <jle`> lol
11:04:10 <jle`> type IntSet = (), only every time you seq it, you leak memory
11:04:28 <cocreature> 10/10 would use
11:15:42 <dyl> Hello all, who should I speak to about regaining access to my hackage account?
11:15:57 <dyl> I've forgotten the password, but because it is unmigrated to the new system, I can't send a password reset...
11:18:50 <ospa> Guys, do you know why Haskell Int doesnt match the C Int? I was sure the corresspondence is 1:1 here, isnt it ?
11:21:33 <cocreature> ospa: on 64bit systems haskell’s Int (or rather GHC’s Int) will be a 64bit Int while C compilers will often still use a 32bit
11:22:29 <ospa> cocreature: I was sure C compiler will follow the same desing here! oh
11:29:59 <amalloy> in general "Haskell Int" merely guarantees to be at least 30 bits. apparently in GHC it is larger but i don't know where that guarantee is made
11:39:33 <sclv> dyl: email admin@hackage dot haskell dot org
11:44:23 <crobbins> is there a type class for tupling effects? e.g. (f a, f b) -> f (a, b)
11:44:32 <crobbins> would be nice for arbitrary arity tuples
11:44:38 <Tuplanolla> That's `Applicative`, crobbins.
11:44:43 <crobbins> right
11:45:07 <crobbins> and it's not a big deal to do (,) <$> fa <.> fb
11:45:18 <Tuplanolla> :t let zipA = uncurry (liftA2 (,)) in zipA
11:45:20 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
11:45:55 <crobbins> right, but mostly wondering if someone already made an arbitrary-arity tuple sequence function
11:46:13 <Tuplanolla> What would its type be?
11:46:13 <iron_houzi> What does "TH" mean? (Source: https://www.reddit.com/r/haskell/comments/87ancw/haskell_starts_to_drive_me_nuts/)
11:46:24 <crobbins> iron_houzi: template haskell
11:46:33 <iron_houzi> what is template haskell?
11:46:45 <iron_houzi> Is it a templating language?
11:47:03 <iron_houzi> like jinja, handlebars, etc..?
11:47:31 <amalloy> iron_houzi: it's more like a macro language. templates for generating haskell, not for generating html
11:47:40 <iron_houzi> ..and do you agree that template haskell should be avoided?
11:47:50 <iron_houzi> amalloy: Ah, ... Really!!?
11:48:15 <iron_houzi> that sure sounds like a foot gun tho..
11:48:40 <crobbins> Tuplanolla: it would be a type class, via fundeps/type families
11:49:11 <Tuplanolla> There's such a thing in `lens`, crobbins.
11:51:04 <crobbins> Tuplanolla: do you know what function?
11:51:15 <pagnol> I'm trying to understand how to create and use custom expressions in Beam: http://lpaste.net/364091
11:51:51 <Tuplanolla> > concatOf each ("whoa", "arbitrary", "length", "tuples")
11:51:54 <lambdabot>  "whoaarbitrarylengthtuples"
11:52:14 <pagnol> my goal is to wrap a postgres function that I defined
12:01:02 <crobbins> Tuplanolla: i was thinking of something more like this
12:01:02 <crobbins> https://gist.github.com/carymrobbins/553970d53f186e2eb82adfb4a8d19ae3
12:02:54 <Tuplanolla> Funny you should bring that up, because I just recently tried to do it in Idris with poor results: http://tuplanolla.no-ip.org/tmp/Indexed.idr
12:03:13 <Tuplanolla> The commented sections do not pass the type checker.
12:12:38 <merijn> With new-repl how do I pass flags to ghci?
12:12:56 <merijn> Or just "cabal repl" I suppose
12:20:16 <crobbins> Tuplanolla: not quite able to read idris atm, but interesting coincidence :D
12:20:42 <merijn> Ok, so the answer is apparently: "not with --ghc-option"
12:21:06 <lyxia> crobbins: use generics
12:21:55 <lyxia> crobbins: this is gtraverse in one-liner https://hackage.haskell.org/package/one-liner-1.0/docs/Generics-OneLiner-Binary.html#v:gtraverse
12:24:10 <pagnol> it never ceases to amaze me how quickly I find a solution to a problem after asking people on irc or elsewhere even when nobody answers
12:26:20 <shapr> cardboard programmer aka rubber ducking
12:26:52 <merijn> pagnol: Wanna trade? I mostly have obscure questions which get no answers :p
12:26:53 <shapr> pagnol: related trick is, if you have two options and can't decide which, flip a coin.. when the coin reaches the top of the arc, you usually know which one you want
12:27:29 <pagnol> shapr, I was thinking that... I really should do rubber ducking more often
12:27:46 <shapr> I think it forces brain thunks
12:29:09 <pagnol> brain thunks... yes
12:33:56 <dyl> I'm still using the usual cabal/ghc stack, am I doing this right.
12:34:16 <dyl> I've been out of the loop for a while now.
12:34:29 <cocreature> merijn: for cabal repl, --ghc-options used to work. no idea about new-repl
12:35:19 <lyxia> crobbins: http://lpaste.net/364093
12:36:42 <merijn> cocreature: Well, it doesn't appear to for me. I have an issue where an option in my .ghci is breaking things, but passing "--ghc-option=-ignore-dot-files" doesn't disable reading .ghci
12:37:42 <merijn> Guess I'll fiddle around a bit more
12:38:05 <dyl> shapr This has been bugging me for a while: is it "shap-er", or "shaper"?
12:38:42 <shapr> dyl: shaper without the e
12:38:48 <dyl> So... yes.
12:38:49 <shapr> shay-per
12:38:50 <cocreature> the next round of merijn vs Haskell tooling
12:38:58 <dyl> shea-per
12:39:02 <merijn> cocreature: I'm getting somewhere!
12:39:09 <dyl> Sounds like an expensive moisturizer :p.
12:39:10 <shapr> dyl: well, my first name is Shae
12:39:16 <dyl> That I knew.
12:39:25 <dyl> I was leaning towards the latter.
12:39:40 <dyl> I suspected it might be intentionally ambiguous.
12:39:41 <cocreature> merijn: sometimes I wonder if you find the time to actually write code or if you’re just busy fighting one tooling issue after another :P
12:39:58 <dyl> cocreature Use JavaScript and you'll never have to wonder about that question. It'll always be the latter!
12:40:04 <merijn> cocreature: My ghcid based ghc-mod replacement has a working core by now!
12:40:17 <cocreature> dyl: there is a reason I don’t write js ;)
12:40:28 <shapr> dyl: funny thing, I don't wonder how to say a name from IRC until I meet the person. I also don't verbalise when reading, so pronunciation is done non-strictly
12:40:46 <dyl> Usually I don't either, but sometimes it just happens and then I wonder about it.
12:41:04 <dyl> It's akin to when you type the same word too many times and you start questioning whether it's actually spelled "correctly".
12:41:06 <merijn> cocreature: A bunch of the issues I had with cabal got fixed, the only issue that's in my way right now is the fact the new-build is being stupid about which flags it considers for it's dependency hash
12:41:19 <merijn> cocreature: Meaning it is WAAAY to paranoid and rebuilds too much too often
12:41:42 <cocreature> merijn: yeah I remember the cabal issue for that, it’s really annoying
12:42:11 <merijn> cocreature: as in, literally every ghc flag triggers a complete rebuild of all dependencies
12:42:42 <dyl> Every time, or just when changed?
12:43:03 <merijn> cocreature: Well, that's not even that big a deal, but the fact that it basically means ALL in-place packages have to be rebuild when you toggle a flag which my tool is causing a lot
12:43:22 <shapr> oh, new version of cabal released? does new-run work now?
12:43:35 <merijn> shapr: I dunno, I'm using HEAD for new-build :p
12:43:44 <dyl> If you had deterministic compilation and could break a program down into canonicalized subunits, could you crowdsource memoization of compilation?
12:43:47 <merijn> shapr: Pretty sure new-run has worked for a while in HEAD
12:44:00 <shapr> oh cool, I wish the release version of cabal had new-run
12:44:09 <exio4> cocreature: crap, did I lose the new season? did merijn win his fight against cabal and GHC?
12:44:09 <shapr> dyl: bazel
12:44:11 <merijn> dyl: Could you? Sure. Sounds like a terrible idea, though
12:44:15 <infinisil> merijn: That's also how Nix works, but Nix has something to not make you do that
12:44:18 <dyl> Oh, absolutely a terrible idea.
12:44:22 <merijn> exio4: No, but I'm winning :p
12:44:23 <dyl> But it could probably secure funding.
12:44:24 <shapr> dyl: have you seen https://www.tweag.io/posts/2018-03-15-bazel-nix.html ?
12:44:32 <exio4> merijn: :D
12:44:34 <merijn> exio4: At least, building up a lead :p
12:44:35 <cocreature> exio4: nah that counts as Haskell tooling :)
12:44:40 <dyl> I had a feeling if anything similar existed, it was probably in the nix area.
12:45:01 <merijn> cocreature: Clearly the solution is to annoy everyone in #hackage until they fix that issue ;)
12:45:03 <infinisil> Well new-build took inspiration from Nix
12:45:05 <cocreature> merijn: don’t worry I’m sure you’ll make the mistake of upgrading to the next release at some point and everything will break again
12:45:11 <merijn> shapr: What's stopping you from just running HEAD? :)
12:45:30 <shapr> merijn: I teach Haskell to newbies two or three times a week
12:45:37 <shapr> they're not gonna install cabal from HEAD
12:45:46 <shapr> I often suggest they use stack to install GHC
12:45:56 <merijn> cocreature: Speakinig of which, I don't suppose you know how I can turn 8.4's errors/warnings to ditch the fancy colours and new layout? :p
12:45:58 <shapr> not my preference, but often the easiest way to get the right GHC
12:46:31 <cocreature> merijn: -fdiagnostics-color=never for the colors. not sure about the layout
12:46:39 <merijn> hmmm
12:46:49 <cocreature> merijn: maybe -fno-error-spans?
12:47:28 <merijn> cocreature: *twiddles thumbs while _everything_ rebuilds*
12:47:42 <cocreature> merijn: sounds like you’re having fun!
12:48:24 <JuanDaugherty> is there a best hs gui pkg these days?
12:48:39 <JuanDaugherty> (desktop)
12:49:42 <cocreature> merijn: ah I think it’s -fno-diagnostics-show-caret
12:53:10 <merijn> cocreature: Kinda slow to test if it rebuilds all my dependencies each time >.>
12:54:15 <merijn> cocreature: Do you remember the ticket number for this issue?
12:57:55 <kakashiAL> in haskell and other functional programming languages, they always use the prefix "to"
12:57:59 <kakashiAL> what does it means?
12:58:04 <kakashiAL> how how can you read it?
12:58:16 <merijn> kakashiAL: as in toList?
12:58:46 <cocreature> merijn: https://github.com/haskell/cabal/issues/4247 is the one about cabal considering flags part of the hash. https://github.com/haskell/cabal/issues/3883 is the one for --ghc-options applying to all packages and not just local packages
12:58:56 <merijn> kakashiAL: That's literally just the English word "to". As in "(convert) to list"
12:59:13 <kakashiAL> merijn: yes, but I also saw javascript implementations like to(myFunctionThatCanHaveAnErrorOrSuccess)
12:59:54 <kakashiAL> merijn: something like [err, succes] = to(myFunction);
13:00:03 <merijn> no clue about the JS stuff
13:00:31 <merijn> cocreature: -fno-diagnostics-show-caret seems to work!
13:00:50 <cocreature> merijn: better try rebuilding another time just to be sure!
13:01:26 * hackage graphite 0.9.8.0 - Graphs and networks library  https://hackage.haskell.org/package/graphite-0.9.8.0 (DanielCampoverde)
13:21:28 <jle`> would be nice if we could have view patterns for type families heh
13:33:05 <johnw> view famileis!
13:33:27 <jle`> PatternFamilies
13:33:31 <johnw> theer yuo go
13:33:39 <jle`> hm, is there a good word for 'not stochastic'
13:33:45 <jle`> besides nonstochastic
13:33:54 <johnw> instrumented?
13:33:56 <jle`> i'm describing something that has two modes: stochastic and non-stochastic
13:34:02 <jle`> i was using 'fixed' but that's kind of loaded
13:34:04 <tjg> if one of you guys could help me out please, I am stuck.   http://lpaste.net/364095
13:34:10 <johnw> Cale: ping
13:34:21 <jle`> johnw: hm, context?
13:34:29 <johnw> jle`: profilers
13:34:49 <johnw> stochastic vs. instrumented is basically external vs. internal in that context
13:35:44 <tjg> Help please!!!   http://lpaste.net/364095
13:35:57 <johnw> we heard you tjg :)
13:36:13 <EvanR> heard who?
13:36:16 <johnw> I don't use Atom, and your paste doesn't give enough information to assist
13:36:35 <johnw> it sounds like you need to build  a hoogle database
13:36:59 <tjg> johnw:   ok  ;)     https://github.com/haskell/haskell-ide-engine
13:37:25 <jle`> 'deterministic' maybe?
13:37:48 <tjg> those are the instructions, everything seemed to install but hoogle is unable to find the database that has the documentation.
13:38:05 <jle`> also i totally just misspelled 'RunMode' as 'RunMoad' for an hour and didn't even realize it
13:38:20 <johnw> I don't use haskell-ide-engine yet
13:38:36 <lyxia> I vote for keeping the misspelling for backwards compatibility and the lulz
13:38:37 <MarcelineVQ> tjg:  the instructions tell how to make the google db properly, they did for me anyway, but it didn't make hie work for me in atom
13:39:03 <MarcelineVQ> so far linting/errorchecking on save doesn't work for me with hie and atom, though it works when loading up a file for the first time
13:39:20 <MarcelineVQ> *hoogl db
13:41:15 <tjg> MarcelineVQ, thanks for the feedback! I am not sure why hoogle is not able to locat the database.
13:42:01 <barrucadu> jle`: "systematic", perhaps?  What sort of thing are you describing?
13:42:37 <MarcelineVQ> barrucadu: probably in the context of stochastic gradient descent
13:42:41 <jle`> hm, i think i might actually end up going with deterministic
13:42:53 <EvanR> what is up with stochastic anyway... is this a nose breathing way to say "random"
13:43:04 <EvanR> the opposite of which is deterministic
13:44:46 <jle`> i guess when i think of stochastic, i mean more of aggregated emergent behavior of individual random things
13:45:09 <jle`> re: the difference between the connotations of stochastic vs random
14:04:27 <redrapscallion> if I wanted to use Scotty (which uses Warp and WAI) to deploy a website, would I need anything aside from nginx?
14:05:44 <redrapscallion> I know that when I wanted to deploy in Django, I needed nginx + gunicorn because nginx isn't able to run any python code, but I'm not sure if that pattern applies to Scotty / Haskell in general.
14:08:05 <redrapscallion> According to this : https://wiki.haskell.org/Web/Deploy it seems very likely, but I don't really have enough knowledge to be sure.
14:18:32 <zachk> redrapscallion, iirc you can just run scotty compiled with haskell and you don't need nginx, scotty uses the warp web server engine internally
14:20:36 <Welkin> you can use nginx as a reverse proxy if you wish
14:20:50 <Welkin> if you want advanced features from nginx, that is recommended
14:41:40 <fr33domlover> Given f :: a -> TExpQ b, g :: b -> TExpQ c   can I write h :: a -> TExpQ c  ?
14:41:57 <fr33domlover> (or it can just be plain untyped Exp)
14:44:04 * fr33domlover thinks maybe the Lift instance could help
14:44:55 <zachk> @type (>=>)
14:44:57 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:45:19 <zachk> fr33domlover, (>=>) might be what you want to make h
14:51:35 <dmj`> redrapscallion: nginx is useful for terminating your SSL, nicer to not have to deal with this in the haskell code
14:52:05 <Welkin> terminating?
14:54:38 <EvanR> as in terminating the end of a cat5 cable
14:54:50 <fr33domlover> zachk, but Q is a monad where the value returned from $(f x) is (TExp b)?
14:54:56 <Welkin> as in, Arnold Governator?
14:55:04 <fr33domlover> How do I feed it to g which takes a 'b' value
14:55:11 <fr33domlover> not TExp b
14:56:13 <zachk> h = f >=> g ? -- fr33domlover
14:56:20 <zachk> or is the Monad different?
14:57:03 <fr33domlover> zachk, look at the sig of >=>
14:57:49 <fr33domlover> zachk, can't feed (TExp b) where b is expected
14:59:58 <zachk> @type (>=>)
15:00:00 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:00:22 <zachk> you want to feed in a TExp now? use >>=
15:00:53 <Tuplanolla> I think he's saying that the `Monad` is `Q`, not `Compose Q TExp`, zachk.
15:01:31 <zachk> so its TexP Q a ?
15:01:51 <fr33domlover> zachk, look at the signature of >=>
15:01:55 <fr33domlover> it doesn't match
15:02:28 <zachk> the m can be any monad
15:04:17 <mdim> Hi all
15:05:03 <MarcelineVQ> fr33domlover: what happened when you tried f >=> g ?
15:05:12 <fr33domlover> zachk, f need to return (m b) and then g need to take b
15:05:27 <fr33domlover> but here we have m Exp vervus b
15:05:28 <mdim> I'm using the distributed-process library and I'd need to print messages to the stdout when in a process. My guess is that I need a monad transformer combining IO and Process. How do I put them together?
15:05:40 <fr33domlover> and b is not Exp is some other type
15:05:50 <zachk> mdim liftIO works
15:05:53 <fr33domlover> or (TExp b) versus b
15:06:00 <fr33domlover> which are *not* the same type
15:06:33 <mdim> zachk: for now I have a process task with this signature: task :: (Int, SendFor, WaitFor) -> Process ()
15:06:37 <zachk> thought it was f : a -> TExp b and g : b -> TExp c
15:06:39 <mdim> What would I need to change it to?
15:07:07 <fishythefish> f :: a -> TExpQ b, and type TExpQ a = Q (TExp a)
15:07:13 <zachk> mdim what or where do you want the liftIO . print $ value to be
15:07:51 <mdim> I want to print a numeric value within this function
15:08:32 <zachk> make it a do block and put the liftIO . print $ value in it
15:09:41 <fr33domlover> MarcelineVQ, hmmm the signature seems to be good in GHCi
15:09:55 <MarcelineVQ> it's really going to bother you when you try  g <$> f
15:11:28 <mdim> sorry, but before that, I want to get the current time (with getPOSIXTime :: IO POSIXTime) and send this timestamp to another process
15:12:32 <fr33domlover> zachk, why does it work though?
15:12:34 <zachk> mdim, do val <- liftIO $ getPOSIXTIME ; send otherPid val
15:12:40 <fr33domlover> I mean it seems not to match
15:13:04 <fr33domlover> f :: a -> m (TExp b)
15:13:12 <zachk> fr33domlover, >=> is kleisi compostion, it lets you compose two monad "actions" into a new one
15:13:15 <fr33domlover> g :: b -> m (TExp c)
15:13:41 <zachk> I think (>=>) and return form a category or a monoid or something over monads
15:13:43 <fr33domlover> zachk, yeah but the 1st needs to return the same type as what the 2nd takes right?
15:13:53 <fr33domlover> and in this case
15:13:56 <zachk> yea the m's have to be the same
15:14:09 <zachk> there is probably a constraint ont he m being Monad m
15:14:16 <fr33domlover> zachk, no I mean if 'f' returns 'm b' then g needs to take 'b'
15:14:19 <zachk> then it can be any monad as long as they all match
15:14:48 <zachk> @src (>=>)
15:14:48 <lambdabot> Source not found. Sorry.
15:14:53 <zachk> ugh
15:15:00 <kderme> mdim Can`t you just use Control.Distributed.Process.say to log stuff?
15:15:05 <zachk> it chains them together sort of like (.)
15:15:19 <fr33domlover> zachk, I'm just confused about why there's no type mismatch :p
15:15:37 <fr33domlover> it's like, f :: Int -> m Bool and g :: Float -> m String
15:15:38 <zachk> on the m b to the b part?
15:15:45 <fishythefish> zachk: the objection is that f is not producing `m b`, it's producing `m (TExp b)` (where m is `Q` in this case)
15:15:58 <fr33domlover> yeah exactly
15:16:18 <mdim> kderme: I am using it. However, I also need to use getPOSIXTime to get the time of sending. Just have to figure out how to get a Binary instance for NominalDiffTime or to convert it to Double so it can be serialized and sent across the network
15:16:25 <fr33domlover> GHCi doesn't given a type error when I do :type f >=> g
15:16:26 <zachk> fr33domlover, your last example the b's don't match so it wouldnt type check
15:16:33 <fr33domlover> I'm just confused why it doesn't
15:17:09 <fr33domlover> zachk, what if you replace Bool with (TExp b) and Float with b?
15:17:16 <fr33domlover> The types still don't match
15:17:47 <zachk> the b's match
15:17:53 <zachk> and the m's match
15:18:01 <fr33domlover> zachk, TExp b and b are not the same type
15:18:08 <zachk> yea I know that
15:18:13 <fr33domlover> It's like, (Maybe b) versus b
15:18:21 <fr33domlover> how do they match
15:18:37 <zachk> but you want to compose them together, right?
15:18:49 <zachk> and you want to know internally how the composing works?
15:19:10 <zachk> btw (>=>) lives in Control.Monad along with other nice functions to use with monads
15:19:25 <fr33domlover> zachk, I know the function >=> very well ^_^
15:19:35 <fr33domlover> I'm just missing something here
15:19:53 <fr33domlover> f returns a (TExp b) inside monad m
15:20:10 <fr33domlover> g takes 'b' and returns doesn't-matter-what-right-now
15:20:17 <fr33domlover> so how to they compose
15:20:20 <fishythefish> zachk: the point is that f :: a -> Q (TExp b). Using the Monad instance for Q, you'd expect g :: TExp b -> Q c for f >=> g to work
15:20:31 <zachk> no TExp gets bound to the m
15:20:43 <zachk> here is the source for >=> (>=>)       :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
15:20:43 <zachk> f >=> g     = \x -> f x >>= g
15:20:46 <zachk> (>=>)       :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
15:20:47 <zachk> f >=> g     = \x -> f x >>= g
15:21:03 <fr33domlover> zachk, what is m in my example then?
15:21:18 <zachk> TExp or the orginal TExpQ or what have you
15:21:27 <mdim> Is there a way to get an instance Binary NominalDiffTime?
15:21:48 <zachk> mdim, auto deriving, hold on let me check my source
15:21:50 <mdim> I have to send a timestamp to another process
15:22:05 <fr33domlover> zachk, read what fishythefish said
15:22:12 <fr33domlover> that's what I mean :p
15:22:13 <fishythefish> type TExpQ a = Q (TExp a). Q has the Monad instance
15:22:43 <zachk> not sure then
15:22:53 <zachk> mdim try these at the top of your source
15:22:54 <zachk> {-# LANGUAGE DeriveDataTypeable #-}
15:22:54 <zachk> {-# LANGUAGE DeriveGeneric #-}
15:23:05 <zachk> and importing these
15:23:16 <zachk> import Data.Binary
15:23:16 <zachk> import Data.Typeable
15:23:16 <zachk> import GHC.Generics
15:23:17 <mdim> I have these extensions already
15:24:09 <zachk> might need standalone deriving to derive typeable for nominaldifftime
15:24:25 <mdim> hm
15:24:28 <zachk> then : instance (Binary nominalDiffTime)
15:24:37 <mdim> I had all but "import Data.Typeable"
15:24:47 <zachk> does it work now?
15:25:32 <mdim> still not
15:25:35 <mdim> trying with FlexibleInstances...
15:26:07 <fr33domlover> fishythefish, hmm I made a mistke in GHCi now I get the expected mismatch
15:26:30 <fishythefish> fr33domlover: important to realize that b need not be the same across declarations :)
15:26:47 <zachk> mdim you might want flexibleContexts as well
15:26:57 * hackage s3-signer 0.4.0.0 - Pre-signed Amazon S3 URLs  https://hackage.haskell.org/package/s3-signer-0.4.0.0 (DavidJohnson)
15:27:02 <fr33domlover> fishythefish, yeah that's why it worked lol
15:27:09 <mdim> zachk: but then this messes up some stuff later. Looking at it...
15:27:17 <mdim> I get overlapping instances
15:27:30 <fishythefish> I think both MarcelineVQ and I wanted to see how this would play out, fr33domlover :P
15:27:35 <mdim> zachk: Overlapping instances for Binary (Int, SendFor, WaitFor)
15:28:12 <fr33domlover> fishythefish, the only way I know to get from TExp b to b is using $$()
15:28:24 <zachk> :(
15:28:42 <mdim> hm...
15:29:02 <zachk> maybe try making a data type for Int SendFor waitfor deriving typeable and then an instance of binary for it
15:29:41 <MarcelineVQ> fr33domlover: to b or to Exp?
15:30:04 <fr33domlover> MarcelineVQ, yeah lol it seems impossible
15:30:18 <MarcelineVQ> to which are you wanting
15:30:20 <fr33domlover> because of the stage restriction
15:30:29 <pikajude> why does :i TYPE print out a whole bunch of apparently random class instances?
15:32:08 <mdim> hm, I guess it'd be a lot easier if I just somehow convert this NominalDiffTime to a double before sending it
15:32:32 <fishythefish> pikajude: I get "Not in scope: 'TYPE'" - which type were you using?
15:32:56 <pikajude> it's in GHC.Exts
15:33:40 <fishythefish> oh, you were genuinely using "TYPE"; I thought that was a placeholder
15:34:17 <fishythefish> pikajude: which instances are you seeing and which modules do you have loaded?
15:34:31 <pikajude> as far as i can determine, every instance in the transformers package
15:34:37 <pikajude> and i'm not sure what modules are loaded
15:35:06 <fishythefish> :show modules
15:36:50 <pikajude> oh yeah, just modules in the library i'm working on
15:37:12 <fishythefish> actually :show imports would probably be more appropriate
15:38:36 <fishythefish> pikajude: hmm, I can't repro.
15:38:48 <pikajude> oh neat
15:41:11 <joncfoo> is there a way to tell haddock to inline all re-exported modules?
15:45:43 <fishythefish> joncfoo: use the `hide` attribute on the re-exported module
15:47:52 <fishythefish> pikajude: ah, are you seeing these instance by any chance? https://hackage.haskell.org/package/base-4.11.0.0/docs/GHC-Exts.html#g:11
15:47:59 <fishythefish> e.g. importing GHC.Generics will add a lot of them
15:48:29 <pikajude> no, i thought that initially
15:48:36 <pikajude> but i'm seeing MonadReader and MonadState instances
15:48:49 <joncfoo> hide?  that sounds like it'll exclude the exported modules from being documented?
15:49:02 <pikajude> oh i do see the GHC.Generics ones now
15:49:07 <pikajude> maybe Prelude is blacklisted somehow
15:49:55 <fishythefish> joncfoo: `hide` will omit that module from the generated docs, but the definitions will be propagated to modules that re-export it
15:49:57 <delYsid> gah, older stack not being able to parse newer indexes is a real pita
15:50:21 <joncfoo> fishythefish: ah ok, thanks!  the option name is a tad bit confusing
15:54:28 <mdim> thanks zachk for your help! I found a workaround by manually converting a POSIXTime value to a Double value
15:58:43 <zachk> mdim you are welcome, no problem :D
16:14:46 <hexagoxel> pikajude: the instances that i see on `:i TYPE` seem to have to do with -XPolyKinds usage. Can't repro any MonadReader/MonadState stuff.
16:15:33 <pikajude> okay
16:15:35 <pikajude> weird
16:17:42 <lyxia> pikajude: I see the instances too if I import Control.Monad.Reader, etc.
16:20:03 <lyxia> It's related to why it has so many instances here https://hackage.haskell.org/package/base-4.11.0.0/docs/GHC-Exts.html#t:TYPE because * is defined in terms of TYPE and everything uses it.
16:26:52 <hexagoxel> (ah right, ReaderT is polykinded)
16:34:27 <fishythefish> ah, yeah, should have mentioned I was able to repro once I imported the right modules from transformers, but I couldn't figure out why TYPE behaves that way
16:35:02 <fishythefish> like, I understand generally what it does based on GHC.Exts, but it's hard to find more details because googling "TYPE" has so many false positives
16:41:16 <EvanR> man rationals are slow
16:41:23 <EvanR> in general
16:42:26 <danilo2> Hi! Can I safely use unsafeCoerce to coerce `Foreign.Ptr ()` (pointer address) to Int and back? ( I need to store it in C structure - just as a short background)
16:42:52 <danilo2> I suspect so. GHC Int is 64 bit on 64 bit platform and 32 on 32 bit platform, so it sohuld be safe, right ?
16:43:57 <nek0> hi
16:44:08 <lyxia> danilo2: I don't think so.
16:44:08 <koala_man> danilo2: sounds like you want IntPtr, the intptr_t equivalent
16:44:17 <nek0> does anyone here develop with nixos?
16:44:37 <EvanR> since, in C, you are not guaranteed to be able to store a pointer in an int
16:45:00 <EvanR> practically, this fails for popular implementations of C on 64 bit machines
16:46:08 <danilo2> koala_man: oh, yeah, its exaclty for this purpose! lyxia , koala_man : btw, why we cannot jsut coerce Prt to Int, should they occupy exactly the same amount of memory ? Im wondering why IntPtr uses some utils to do it
16:46:53 <EvanR> int is 32 bits on most of my OSes and Cs, while pointer is 64 bits
16:47:08 <EvanR> (PC computers)
16:47:20 <danilo2> EvanR: Im talking about Haskell Int, which is 64 bit on 64 bit systems
16:47:42 <EvanR> how do you store a haskell Int in a C int
16:48:08 <EvanR> sorry i thought we were talking about C FFI
16:48:53 <danilo2> EvanR: im not storing Haskell Int in a C int. Im storing it in a long in 64 bit platforms.
16:49:14 <pikajude> that's actually pretty funny
16:49:19 <pikajude> that :i TYPE shows everywhere that * is used
16:49:37 <danilo2> btw, lyxia , koala_man , EvanR : the IntPtr uses addr2Int under the hood, which according to GHC.Prim is "strongly deprecated" hmm
16:52:10 <koala_man> danilo2: I'm not aware of any such guarantees about native addresses and Int. Maybe it works on your target system, maybe it doesn't. \
16:52:49 <koala_man> seems like it would be better to use the mechanisms that are guaranteed to work
16:54:13 <danilo2> so it seems that the primop addr2Int would be just no-op on 32 and 64 bit systems by default. I'll use the IntPrt
16:54:39 <danilo2> koala_man: of course I woul d use the mehcnaisms guaranteed to work, I jsut want to knoww how it works under the hood :P
16:56:00 <lyxia> danilo2: unsafeCoerce is about mapping between types of the same representation but as far as I know, GHC makes no guarantee about different 'data' types such as Int and Ptr
16:57:11 <lyxia> danilo2: according to this https://hackage.haskell.org/package/base-4.11.0.0/docs/GHC-Exts.html#v:unsafeCoerce-35- you could perhaps destruct to unboxed values and then coerce
16:57:54 <davean> danilo2, EvanR : I tihnk its long thats supposed to be able to store a pointer in C?
16:59:14 <jle`> it'd be neat if we can define record fields using blahblah x y = ... syntax
16:59:26 * hackage roku-api 0.1.0.0 - Bindings to Roku's External Control API  https://hackage.haskell.org/package/roku-api-0.1.0.0 (puffnfresh)
17:00:59 <danilo2> Hmm, so what is the safest method if I want to create C structure to keep Haskell Ptrs? Is there any proven way to coerce Ptr to anything without any runtime overhead?
17:01:46 <danilo2> I have currently a structure in C that contains longs, they are able to keep ptr addresses. I jsut want to "cast" Haskell Ptrs there without any overhead for maximum performance
17:02:03 <davean> danilo2: I mean, it should be "void *"
17:02:09 <davean> thats the correct C type to store an unknown pointer
17:02:36 <davean> Conversion via integer is VERY hairy - thought definated in a number of cases
17:02:52 <danilo2> davean: hah, actually I see that someone already implemented it as long here, but right, Ill leave a note to write it as void* - it better shows the intention
17:03:19 <davean> danilo2: I mean, this is all covered at the VERY top of the section on pointers in the C standard
17:05:28 <davean> danilo2: if you assign to *any* pointer type other then void * or the correct type, it may become corrupted
17:05:32 <danilo2> davean: I know its hairy. And thats why I was asking just a moment ago what way would you recommend to just "cast" Haskell Addr# to C memory adresses without runtime overhead.
17:06:48 <davean> danilo2: well http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf
17:06:53 <danilo2> I was thinking about rather storing it in std::set<long>
17:06:54 <EvanR> davean: no long isnt guaranteed to store a pointer either
17:07:32 <EvanR> yeah use void*
17:07:34 <pagnol> boj, did you ever use beam for a query like `select * from your_function(...)`?
17:08:55 <danilo2> ok, I'll use it. What types then should I use when making C FFI in Haskell to tell Haskell that I can safely coerce HAskell Foreign.Ptr to this type (which will be void* in C) ?
17:09:52 <EvanR> if your target struct has longs somewhere, and you believe that you can store a pointer there, then express that field as a pointer in the haskell FFI
17:10:08 <EvanR> then you may believe that it will work
17:10:29 <EvanR> modal logic?
17:11:04 <EvanR> danilo2: void* is like, Ptr a
17:11:26 <EvanR> in the FFI
17:11:41 <EvanR> and instead of coercing, unsafely, use cast
17:11:52 <EvanR> castPtr
17:12:18 <EvanR> which is still unsafe, but isnt called unsafe so youre good :)
17:13:31 <danilo2_> EvanR oh right, I can just express it as Ptr in the FFI. Ok, great, ill try it. Thank you! And thank you davean, lyxia and koala_man!
17:22:36 <nek0> hi. does anyone of you develop on nixos?
17:27:02 <dmj`> nek0: yes
17:28:09 <nek0> dmj`: I am still in transition towards nixos and I can't find, how to add a local dependency to a shell.nix file
17:28:45 <nek0> dmj`: With local dependency I mean something, one would "normally" add with a 'cabal sandbox add-source'
17:31:54 <dmj`> nek0: sure, I guess a normal workflow would be calling `cabal2nix . > package.nix` and then `echo ‘{ pkgs ? import <nixpkgs> {} }: pkgs.haskellPackages.callPackage ./package.nix’ > default.nix`, then call `nix-build`. To add an additional dep you could do (in `default.nix`) `with pkgs.haskell.lib; let p = pkgs.haskellPackages.callPackage ./package.nix {}; in addBuildDepend p pkgs.haskellPackages.aeson` You can think of `with`
17:31:54 <dmj`> as similar to `RecordWildCards` unpacking. Gabriel Gonzalez has a good guide on this.
17:33:13 <dmj`> `shell.nix` isn’t necessary, you can simply call `nix-shell -A env` (`default.nix` will automatically be used), but if you just want to call `nix-shell`, then `echo "(import ./default.nix {}).env” > shell.nix` would work as well
17:33:46 <dmj`> nek0: https://github.com/Gabriel439/haskell-nix
17:36:00 <dmj`> nek0: if you want to hop in #nixos we can look at your file
17:43:57 <boj> pagnol: nope, not yet at least
17:44:26 * hackage hpp 0.5.2 - A Haskell pre-processor  https://hackage.haskell.org/package/hpp-0.5.2 (AnthonyCowley)
17:45:16 <EvanR> how that we have Haskell pre-processor we can claim that haskell is a purely functional language
18:29:26 * hackage postgresql-typed 0.5.3.0 - PostgreSQL interface with compile-time SQL type checking, optional HDBC backend  https://hackage.haskell.org/package/postgresql-typed-0.5.3.0 (DylanSimon)
18:35:10 <deepfire> kosmikus: regarding the variety of generics-sop examples -- I could never really find a good, type-safe solution to represent reconstruction of choice of a sum's element -- and I'm not even sure what invariants are worth preserving with type safety
18:37:00 <lyxia> "reconstruction of choice"?
18:39:09 <deepfire> lyxia: suppose we have a sum type, and we want to reconstruct values from some data.  At some point we need to decide on the particular NS we'll return -- to choose a constructor.
18:40:23 <deepfire> lyxia, does that make sense?
18:40:38 <lyxia> I think so, thanks.
18:41:08 <lyxia> There are generic parsers in binary and aeson for instance, would those be good examples?
18:41:18 <lyxia> or are you looking for something specifically using generics-sop
18:42:06 <deepfire> the latter, yes -- I want something that ties in nicely into the overall philosophy of generics-sop
18:42:51 <redrapscallion> So looking at this wiki article "Haskell IO for Imperative Programmers", there's this snippet here that is bad because it uses "imperative thinking" : http://lpaste.net/6524045916645621760
18:42:52 <deepfire> (which I only have a very slight grasp of, but still)
18:43:07 <redrapscallion> so what exactly does it mean when someone says "think imperatively" v.s. "think functionally"?
18:43:29 <redrapscallion> all I can find is "think of data" vs "think of procedures", but that's still not too clear for me.
18:45:45 <redrapscallion> or to phrase the question more specifically, since you *can* write imperative code in Haskell, what are the signs that the code I'm writing is imperative and not functional?
18:46:15 <deepfire> redrapscallion: one sub-skill that relates to application of functional programming is this stream of thought, where you try to lift as much as possible of your program into IO-free transformation
18:48:04 <deepfire> redrapscallion: the goal is to make the IO-ful part as simple as possible, so it has the least chances possible to trip you over
18:48:51 <lyxia> even if you're doing IO it can be useful to shift the point of view from *doing things* to *composing computations*
18:49:27 <Zipheir> redrapscallion: Generally 'imperative thinking' involves something of the form 'I'll do this, then this.'
18:49:32 <redrapscallion> deepfire: but isn't reading from a file and printing out the result of an operation done on a line 100% IO?
18:50:57 <fishythefish> not necessarily
18:51:03 <fishythefish> the operation itself may be done purely
18:51:07 <deepfire> redrapscallion: note how your `processIt` function has IO in its type
18:51:31 <fishythefish> and even in the IO parts, you have choices. must I read each line one at a time via IO, or can I get all the input, and then manipulate it purely?
18:52:54 <redrapscallion> lyxia: I can see how "composing computations" will work when doing something like math, but how does that apply to IO?
18:52:55 <deepfire> redrapscallion: you could have left all IO in `main`, and retain only the essential computation in `processIt` -- which could be (show . length)
18:53:45 <redrapscallion> fishythefish: so the correct functional way to do it would be to stick all the lines into a list, map an operation over the list, and then print the list?
18:54:14 <fishythefish> redrapscallion: I hesitate to say that there is one correct way, but that certainly seems like a good start
18:54:32 <lyxia> redrapscallion: viewing computations as value allows you to put them in lists and other structures, maybe inside other computations
18:54:41 <redrapscallion> fishythefish: so it's not an ideal solution then?
18:54:55 <fishythefish> redrapscallion: that really depends on the nature of your computation
18:55:40 <fishythefish> redrapscallion: that's a good general approach, but you could always find situations where there's a better way to do it
18:56:09 <woodson> Hey guys, I understand the definition of the functor, applicative and monad. However, I do not have the intuition to know when I need to creating one is needed. So, I was looking at the typeclassopedia and notice that this word comes up a lot “computational context”.
18:56:21 <woodson> Can anyone further add to this or better explain.
18:56:35 <woodson> by the way thats from the https://wiki.haskell.org/Typeclassopedia
18:56:45 <OmegaDoug> Quick quesion on some code - http://lpaste.net/364106
18:56:46 <OmegaDoug> I'm not sure why one branch of an if statement terminates a loop while another does not since they both return strings. The branches in question are clearly marked in the code sample. Also, the code does work as expected. I'm just not quite sure why.
18:57:13 <OmegaDoug> Any insights would be appreciated
18:57:26 * hackage squeal-postgresql 0.2 - Squeal PostgreSQL Library  https://hackage.haskell.org/package/squeal-postgresql-0.2 (echatav)
18:57:30 <woodson> again I am not asking what they are rather how to know when creating one is need or not.
18:57:33 <fishythefish> woodson: while you're getting used to them, one option is to avoid using them as long as possible, until you think "man, I wish I had a function with this type signature..." and then realize that it's functorial/applicative/monadic in nature
18:57:46 <redrapscallion> fishythefish: could you give an example of a situation of that?
18:59:12 <lyxia> OmegaDoug: the else branch contains everything below it
18:59:48 <OmegaDoug> lyxia: so the >>= is considered to be part of the else branch then?
18:59:52 <deepfire> redrapscallion: an example of how your paste could have been restructured:
18:59:57 <deepfire> main = (>> main) $ putStrLn =<< (show . length) <$> getLine
18:59:58 <lyxia> OmegaDoug: putStrLn (...) >>= \_ -> putStrLn "..."  means print this, then print that, etc
19:00:14 <OmegaDoug> Ahh,
19:00:19 <OmegaDoug> that makes sense now
19:00:22 <OmegaDoug> thanks
19:00:47 <deepfire> redrapscallion: the "(>> main) $" can be ignored, it just establishes iteration
19:00:52 <infinisil> deepfire: refactoring haskell code in as small space as possible is nice, until you need to change something
19:01:16 <deepfire> redrapscallion: but the rest can be seen as a batch computation pipeline now
19:01:54 <deepfire> redrapscallion: so you have IO at the "entry" and "exit" boundaries, with a pure (show . length) computation left as essence
19:02:58 <woodson> fishythefish: hmm..., I would like to give you a example and would you be able to help understand this thought process of "man, I wish I had a function with this type signature..."?
19:03:16 <deepfire> infinisil: sure, but our case is about illustration, and boiling down to essence is actually useful here
19:03:25 <lyxia> OmegaDoug: using parentheses, what you wrote gets parsed as "if ... then ... else (putStrLn (...) >>= \_ -> ...)"
19:03:42 <Zipheir> deepfire: I take it that =<< means the right hand side is evaluated first and 'bound-into' putStrLn on the left? (In your example)
19:04:16 <deepfire> Zipheir: yes, due to the monadic sequencing
19:04:26 * hackage squeal-postgresql 0.2.0.1 - Squeal PostgreSQL Library  https://hackage.haskell.org/package/squeal-postgresql-0.2.0.1 (echatav)
19:04:28 <OmegaDoug> lyxia: I see that now. Indenting the code under the else branch also makes it clear
19:04:34 <lyxia> OmegaDoug: if you explicitly used parentheses to limit the else branch, "(if ... then ... else putStrLn(...)) >>= \_ -> ...)", both branches would be followed by the continuation on the right
19:04:37 <fishythefish> woodson: sure
19:04:48 <Zipheir> deepfire: Right, thanks.
19:05:00 <redrapscallion> deepfire: so if I understand correctly, for problems where you're doing IO, the goal is to just read everything at the start, do some fancy operations (without using IO), and then output  IO, like a sort of IO, no IO, then IO sandwich?
19:05:31 <redrapscallion> deepfire: and if IO is required, we try to isolate it to so that there's as little IO as possible?
19:05:44 <deepfire> redrapscallion: what you just described is one pattern -- batch computation
19:06:00 <fishythefish> redrapscallion: well, for a start, any situation in which you're not trying to perform the same computation for each line
19:06:34 <deepfire> redrapscallion: batch computation is the simplest model, but it certainly doesn't cover all our needs
19:06:53 <EvanR> IO is interleaved
19:07:05 <EvanR> do IO, do computation which results in more IO, etc
19:07:05 <OmegaDoug> lyxia:  yes, that's how I was thinking it worked originally,
19:07:31 <woodson> fishythefish: So, for example right now I am building a library that allows users to interact with salesforce API. But, I am strictly using just function that allows the user to login via oauth2 to get an access token. And the rest of the other functions are just a bunch of functions that allows the user to query Object on salesforce with their defined data types.
19:07:37 <woodson> here is a link https://github.com/Woody88/Haskforce/blob/new_types/src/Haskforce/Client.hs
19:07:50 <redrapscallion> deepfire: is there some place where I can find a list of these patterns?
19:07:53 <deepfire> redrapscallion: at the other end of the spectrum, we have Functional Reactive Programming (FRP)
19:08:04 <redrapscallion> deepfire: I really doubt I'd be able to figure these out on the spot on my own lol.
19:08:33 <deepfire> redrapscallion: it's an ongoing research problem on how to structure interaction with the world in the most functional way : -)
19:08:41 <woodson> Now, there are just simple function but I am wondering in such situation what is the thought process in making the decision yes I need maybe functor, applicative or monad
19:08:47 <deepfire> people keep coming up with ideas..
19:09:30 <fishythefish> woodson: say you have a type `Foo a`. If you've ever thought "I have a function a -> b but I want a Foo a -> Foo b", then you take a look at Functor
19:09:34 <woodson> I know how to use them but I am not sure if I have the intuition to know what I should even be saying hey man I need one now
19:10:54 <fishythefish> similarly, thinking "I have a Foo (a -> b) and a Foo a, but I need a Foo b" means you might want an Applicative and "I have a Foo a and an a -> Foo b and I want a Foo b" means you should look at Monad
19:11:15 <fishythefish> (or any type signature corresponding to a function you get from an Applicative/Monad)
19:14:13 <redrapscallion> deepfire: so are there any common code smells in Haskell that a beginner can just immediately see and say "yeah, this code is terrible/bad"?
19:14:20 <deepfire> redrapscallion: in a sense, FRP is the most "interactive" kind of functional programming, so it's worth having a sense of what can it do: https://begriffs.com/posts/2016-07-27-tikhon-on-frp.html
19:16:10 <deepfire> redrapscallion: there is a good post by Edward Yang on this: http://blog.ezyang.com/2010/05/refactoring-haskell-code/
19:17:03 <redrapscallion> deepfire: btw, do you also have any suggestions on how to practice writing idiomatic Haskell code?
19:17:36 <deepfire> redrapscallion: I would suggest _reading_ code written by other people
19:17:42 <woodson> fishythefish: hmm... I think that the I am starting to understanding of the meaning "computational context"
19:18:20 <deepfire> redrapscallion: that can be problematic, because some of the libraries use fairly advanced Haskell features, which can take quite a while to understand
19:18:28 <woodson> so instead of making a specific function for it we just generalize it with a functor
19:18:31 <redrapscallion> deepfire: yeah, that's another thing :(
19:18:39 <redrapscallion> deepfire: reading Haskell code is super painful
19:19:00 <fishythefish> reading well-written code shouldn't be
19:19:04 <redrapscallion> deepfire: I feel like I'm reading at like 2 lines every 5 minutes
19:19:30 <fishythefish> but it also depends on how well you understand the problem domain as well as operators/syntax/etc.
19:22:26 <deepfire> redrapscallion: that's not the worst of it.. sometimes you can beat your head against things for quite a while longer..
19:23:43 <redrapscallion> deepfire: so for example, this snippet : http://lpaste.net/7077762162826936320 -- how would you begin to read this?
19:24:45 <redrapscallion> well, in specific, I'm already lost on line 5 with the fact that "Redirect url" is in parentheses
19:25:19 <qmm> thoughts from a haskell developer on https://news.ycombinator.com/item?id=16678209 ?
19:25:27 <qmm> Avoi Else, Return Early
19:26:16 <redrapscallion> is that a type or...? And on line 11, I've never seen an @ used in Haskell before for any reason.
19:26:57 <deepfire> redrapscallion: 1. it's a multi-clause function, that 2. returns a value in the ActionT monad (which I don't know about, so I'd go and read about it, but is probably Scotty's event handling actions)
19:27:44 <deepfire> redrapscallion: 3. I see that it dispatches over error types (the second argument), 4. I see that it sets response headers and emits HTML in some of the error cases
19:27:53 <blonkhart> redrapscallion, the points that confused you both are part of haskell's pattern matching syntax
19:30:38 <geekosaur> redrapscallion, defH advertises itself as wanting two parameters. without the parentheses in (Redirect url), you'd be telling it to take three there. so instead, you use the parenthses so it sees two... then that second is deconstructed as a constructor "Redirect" and its single parameter, which is bound to "url"
19:31:42 <deepfire> redrapscallion: as blonkhart says, the dispatch is driven by pattern-matching -- if you look up the definition of the ActionError type, you'll see the a sum type
19:31:57 <geekosaur> the @ lets you do that same kind of deconstruction, but also give a name to the un-deconstructed parameter. you could normally ask for "h" or for "(Just f)".. if you want both, you combine then with @. this is called an as-pattern
19:34:04 <redrapscallion> geekosaur: but that line has an ActionError parameter too. If you took both h and (Just f), wouldn't you end up with three parameters instead of two?
19:34:23 <geekosaur> no, that's what the @ means
19:34:45 <geekosaur> "parameter 'h' as '(Just f)'"
19:35:05 <geekosaur> so you get both the whole value, *and* require that it be (Just something), *and* extract that something as "f"
19:36:15 <geekosaur> othgerwse you'd have to ask for "h" and then use a separate case expression to pull out the "f"
19:40:05 <redrapscallion> geekosaur: so "h" is the "f" value pulled out of "Just f", so @ just pulls the value out of a monad?
19:40:17 <geekosaur> ...wat
19:40:19 <geekosaur> no
19:40:21 <geekosaur> f is the f value
19:40:33 <geekosaur> h is the *whole* value (Just ...)
19:40:37 <geekosaur> f is the ...
19:40:46 <geekosaur> @ has nothing to do with monads
19:42:18 <geekosaur> I pass that function a parameter (Just foo). the function ends up with h = Just foo, f = foo
19:42:53 <geekosaur> if I passed it Nothing instead, the previous definition (defH Nothing ...) intercepts it instead
19:43:39 <redrapscallion> geekosaur: ah, okay, I got it lol.
19:45:52 <blonkhart> "Just" in "(Just foo)" and "Redirect" in "(Redirect url)" are referred to as data constructors.  the Maybe type happens to be a monad with Just as a data constructor, but pattern matching has to do with data constructors.
19:50:21 <deepfire> redrapscallion: I guess the most immediate lesson is that understanding the types needs to go before understanding the function that uses them
19:51:34 <deepfire> you can try to intuit some of that, of course, but it's a gamble if you'll speed up or end up confused
19:54:06 <blonkhart> the most efficient way to learn to read haskell is to write a lot of it
19:54:55 <Axman6> "just pulls the value out of a monad" redrapscallion this is not something we have a general name for - if all you know about something is that it is a monad, then you cannot escape the monadic context - this is how IO works as well as it does
19:55:29 <Axman6> > let h@(left x) = Left 7 in (h,x)
19:55:32 <lambdabot>  <hint>:1:8: error: Parse error in pattern: left
19:55:42 <Axman6> > let h@(Left x) = Left 7 in (h,x)
19:55:44 <lambdabot>  (Left 7,7)
19:56:09 <Axman6> "at patters" just let you give a name to another pattern
19:58:01 <lyxia> Monads, it's like journalism, you're not supposed to take things out of context.
19:58:15 <deepfire> : -)
19:59:20 <deepfire> lyxia, (unsafePerformIO $) all around..
20:02:21 <lyxia> outOfContext :: IO a -> a; fakeNews :: a
20:25:44 <aka> Hi there, I hope it's ok to ask very simple question. I want to find use cases of http://hackage.haskell.org/package/free. How do find packages that depends on free? Thanks in advance.
20:28:54 <lyxia> aka: look at operational and freer-simple, they're mostly the same idea
20:29:01 <lyxia> with examples
20:29:43 <aka> thanks for the advice! I will have a look at the packages you mention.
20:30:38 <aka> but is there a general way to find packages that depends on a package?
20:31:17 <lyxia> http://packdeps.haskellers.com/reverse
20:32:50 <aka> lyxia: awesome! exactly what i am looking for
20:33:21 <aka> i'm gonna read some code. have a good one~
20:33:31 <lyxia> you too
20:34:26 * hackage dbus 1.0.0 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-1.0.0 (blaze)
20:40:06 <lyxia> aka: another place to look for code usage is Github
20:43:48 <lyxia> if you pick your keywords well and wade through a sea of reimplementations, you may find a few legitimate uses https://github.com/search?utf8=✓&q=foldfree+language%3Ahaskell&type=Code
20:47:12 <blonkhart> what is the definition of a free algebra in the sense used in this article?  https://bartoszmilewski.com/2017/03/14/algebras-for-monads/
20:48:09 <lyxia> blonkhart: an object a together with a morphism (m a -> a) is an m-algebra.
20:50:27 <aka> lyxia: good idea. I will try it next time.
20:50:42 <blonkhart> thanks, my question i guess is what is a haskell example of a free m-algebra, as opposed to one that is not free
20:51:15 <lyxia> ah sorry I misread
20:53:58 <lyxia> blonkhart: I think "free algebra" just refers to something that's in the image of the left adjoint functor in an adjunction.
20:54:56 <dsal> How does one do extra-deps in package.yaml ?
21:03:16 <dsal> Argh.  Trying this gogol stuff.  It doesn't compile.  That seems like a thing stuff should do.
21:04:54 <blonkhart> oh i guess the article has an example of a free algebra - (T a, join)
21:05:43 <dsal> apparently gogol's got 99 problems.  mine's this one: https://github.com/brendanhay/gogol/issues/99
21:06:49 <blonkhart> the free-ness of it derives i suppose from the fact that the algebraic evaluation (join) doesn't actually touch a, it only joins T, so it's not lossy
21:18:04 <EvanR> uhm
21:18:35 <EvanR> > let x = 5 in (+) 2x
21:18:37 <lambdabot>  7
21:19:38 <dsal> weird
21:21:35 <EvanR> > letx=5in(+)2x
21:21:37 <lambdabot>  <hint>:1:5: error:
21:21:38 <lambdabot>      parse error on input ‘=’
21:21:38 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
21:27:26 * hackage composition-prelude 1.3.0.8 - Higher-order function combinators  https://hackage.haskell.org/package/composition-prelude-1.3.0.8 (vmchale)
21:40:56 * hackage GLUtil 0.10.1 - Miscellaneous OpenGL utilities.  https://hackage.haskell.org/package/GLUtil-0.10.1 (AnthonyCowley)
22:25:47 <onion> ummmmm http://lpaste.net/364109
22:26:04 <cocreature> onion: run "stack upgrade"
22:26:19 <onion> aside from the mysterious error, why on earth different versions of this 'lts' build plan for the almost same command ..
22:26:20 <onion> ohh
22:26:59 <robstr> onion are u using nix ?
22:28:16 <onion> hmm nope, debian. its trying to install in ~/.local/bin but my stack is in /usr/bin
22:28:32 <cocreature> just put .local/bin before /usr/bin in your PATH
22:29:11 <onion> well now i have three versions of slack floating around
22:29:16 <onion> stack
22:29:29 <cocreature> once you have the one in ~/.local/bin you should be able to remove the others
22:31:18 <onion> nah its cool i moved it to global
22:31:52 <onion> wait why is it downloading ghc-8.2.2 when i have already compiled and installed ghc-8.2.2
22:31:56 <onion> hrrrrmm
22:56:14 <kosmikus> deepfire: ping?
22:58:25 <cocreature> onion: by default stack will not use GHC installations it hasn’t installed itself
23:00:15 <cocreature> onion: there is a system-ghc option that you can use to change that behavior
23:00:19 <onion> just got it now -- "stack config set system-ghc --global true"
23:00:24 <onion> cool =)
23:00:29 <onion> thanks
23:01:17 <guest__> what are the sizes of Int and Integer in haskell?
23:01:35 <cocreature> onion: note that stack will still install GHC if your resolver specifies a different version of GHC
23:01:54 <lemmih> guest__: Int is between 31 and 64 bits, I think. Integer is unbound.
23:02:20 <Lowl3v3l> guest__: -2^29... 2^29-1 is Int's minimal range
23:02:25 <cocreature> for GHC, Int is 32bit on 32bit systems and 64bits on 64bit systems
23:02:57 <guest__> lemmi: like in C, char is 1byte, short is 2 byte
23:04:02 <cocreature> short is _at least_ 2 bytes in C
23:04:40 <aasronStone> if i serialize Maybe type and recieves it with a client say written in python what do i recieve ?? since maybe in not supported there ??
23:04:44 <lemmih> guest__: You can use Int8, Int16, Int32 and Int64 if you need specific sizes.
23:04:59 <guest__> cocreature: ya depends on processor bits
23:04:59 <cocreature> aasronStone: that depends on how you serialize it?
23:05:38 <aasronStone> cocreature : say i'm using cborg format using serialise lib
23:06:00 <onion> ok stack eats all my ram my hdd is swapping and system locking up
23:07:14 <cocreature> aasronStone: here’s how the Haskell side serializes Maybe values https://hackage.haskell.org/package/serialise-0.2.0.0/docs/src/Codec-Serialise-Class.html#line-825. what you get back on the python side depends on the python lib you’re using but in this case probably a list of length 0 or 1
23:07:35 <lemmih> aasronStone: CBOR has support for null so it should just work on the python side.
23:08:39 <aasronStone> lemmih : how cross platform is cborg format, I was considering using protocol buffers but i was told it doens't have good support for haskell
23:08:39 <woodson> is there a common library used that converts haskell types to XML?
23:09:26 * hackage filecache 0.3.2 - A cache system associating values to files.  https://hackage.haskell.org/package/filecache-0.3.2 (SimonMarechal)
23:09:52 <lemmih> aasronStone: CBOR is completely stable across all platforms. See cbor.io
23:10:45 <aasronStone> lemmih : does it have good libs for C++,GO,Python,Node and ofcourse haskell >>??
23:12:01 <lemmih> aasronStone: Yeah, I think so.
23:12:13 <aasronStone> lemmih : you're not sure ??
23:12:30 <lemmih> aasronStone: I don't really do a lot of C++ and GO programming.
23:15:21 <aasronStone> lemmih : so what format do you use for haskell ?? because protocol buffers has pretty good support for all other languages but as i told you i was told it doesn't have good support for haskell ????
23:16:01 <lemmih> aasronStone: It completely depends on the situation. Is there any reason you cannot use JSON?
23:16:47 <liste> what's the difference between cbor and msgpack? are they compatible?
23:22:02 <aasronStone> lemmih : i'm looking for a binary format
23:22:38 <lemmih> aasronStone: Alright, CBOR is binary. Any reason you can't use CBOR?
23:23:24 <EvanR> CBOR. It's so hot right now
23:25:42 <EvanR> i heard they want to replace binary's current format with CBOR
23:25:57 <cocreature> EvanR: afaik those plans have been abandoned
23:26:47 <EvanR> hmm. well at least the renamed lib is hilarious https://hackage.haskell.org/package/cborg
23:27:19 <aasronStone> lemmih : i told you i'm not sure how good support it has for other languages
23:28:22 <EvanR> ignorance is no excuse
23:28:28 <piyush-kurur> Is there any tool to print out the dependency graph of functions in a package ?
23:28:29 <lemmih> aasronStone: Well, figure out which other languages you want to use and then go look up the information.
23:28:36 <liste> aasronStone: http://cbor.io/impls.html
23:28:40 <piyush-kurur> I find myself needing such a thing during refactoring
23:29:22 <liste> aasronStone: also https://msgpack.org/index.html is very similar, so if it supports the languages you want (it probably will), check it out
23:29:41 <piyush-kurur> the use case is the following. I have an internal Utils module which exposes some functions that are used by modules exposed by the package
23:29:59 <piyush-kurur> I would like to trim the Utils module as in when I update the package
23:30:18 <cocreature> aasronStone: fwiw afaik there are Haskell libs for protobuf so I’m not sure what makes you say that the Haskell support isn’t good
23:30:20 <jle`> any ghc plugins i can use to help me convince ghc that '[] ~ (as ++ bs) => (as ~ '[], bs ~ '[]) ?
23:30:29 <jle`> i can do it using singletons but it'd be nice if i can typechecker this
23:30:37 <xandaros> I like cbor, but I'm biased
23:31:52 <aasronStone> cocreature : even i don't few weeks ago someone told me on freenode it's not stable or not actively maintained or something
23:32:33 <aasronStone> anyway from all of your responses it seems cbor is preety good. i'm using serialise lib
23:32:58 <cocreature> aasronStone: https://github.com/k-bx/protocol-buffers has been updated 22days ago, https://github.com/google/proto-lens 5 days ago and https://github.com/awakesecurity/proto3-suite 13h ago so those packages very much seem to be actively maintained
23:34:02 <aasronStone> cocreature : my bad i didn't check it someone told me here and i took the words for final
23:34:44 <aasronStone> cocreature : so what would you prefer protocol buffers or cbor given you want cross language support
23:35:14 <cocreature> dunno, I’m not really familiar with serialization libs in other languages
23:35:25 <cocreature> in the end it probably doesn’t matter a whole lot
23:35:27 <robstr> Morning, I struggle parsing https://gist.github.com/rsoeldner/6c6d70c80af3de3d4d595b4bb0d7c7ab with `Aeson`, I need to access the field `minPrice` and `maxPrice` from the `filters` list where `"filterType" == "PRICE_FILTER"`. Is there a way to lookup a neasted value in a list, like `filters.minPrice` ?
23:36:13 <aasronStone> cocreature : yeah i guess you're right i'm thinking way too much on this
23:37:36 <aasronStone> cocreture : also i have just learnt functors, applicatives, monoids and monads (basics) any guid or resource to step up ???
23:37:42 <aasronStone> guide*
23:39:19 <RaminHAL9001> robstr: list comprehension notation is good for filtering lists
23:41:44 <RaminHAL9001> robstr: for example [(min, max) | t <- lookup "filterType", t == "PRICE_FILTER", min <- lookup minPrice, max <- lookup maxPrice]
23:42:16 <RaminHAL9001> robster: but you must define your "lookup" function to be the correct type
23:44:56 <robstr> RaminHAL9001: thank you, but shouldnt this be possible with the aeson functions like `.:?` ?
23:46:24 <robstr> RaminHAL9001: let me check, i found `.!=` too :P
23:53:26 <RaminHAL9001> robstr: yes, if you prefer "do" notation you can use those as well
23:53:51 <RaminHAL9001> robstr: just remember that if the fields doesn't exist, the expression may evaluate to "empty" and the parser will fail.
23:55:04 <RaminHAL9001> robstr: well, not (.:?), it will only return "Nothing".
