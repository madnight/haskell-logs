01:03:15 <robstr> I struggle using the `aws` package, For example, If I want to receive the s3 bucket location, I can load my creds and generate a Aws.Configuration, but how to i finally execute my request ?
01:05:19 <ij> I've never used the aws library, but have you seen the copypastable example in the package's README on github?
01:06:19 <robstr> ij: yes I saw them, but is this a common pattern in hs ? , I dont know conduit
01:06:50 <ij> What pattern?
01:07:02 <ij> I don't know conduit, no.
01:51:20 <Boarders_> robstr: something like this should work: http://lpaste.net/363831
01:51:33 <Boarders_> I'm not super familiar with the library so I don't know if this is the best solution
01:56:17 <merijn> Boarders_: FYI, you should avoid repeated use of $ on a single line and prefer using .
01:56:47 <Boarders_> good point
02:09:16 <piyush-kurur> for binary distributions of GHC is there a fixed pattern for the url (something like ghc-$version-$arch) ?
02:10:18 <piyush-kurur> The problem is that in 8.4.1 there is a deb8 where as in 8.2.1 there is a deb7 in the url name
02:10:38 <piyush-kurur> if this were uniform it would be easier for scripting
02:11:35 <merijn> piyush-kurur: I think that's because 8.4 requires a newer debian version?
02:12:01 <piyush-kurur> I thought they were standalone binaries
02:12:28 <merijn> piyush-kurur: They still link against some system libs, specifically libc, libgmp, etc.
02:13:24 <piyush-kurur> merijn: so how are others (say distribution-foo) supposed to use it ?
02:13:47 <ertes-w> helo
02:14:34 <merijn> piyush-kurur: Depends if distribution foo happens to have a compatible library version. Usually debian is so archaic everyone is already supporting newer than that
02:15:34 <piyush-kurur> merijn: I was thinking more along the lines of statically compiled ghc
02:15:55 <piyush-kurur> because then as long as the system calls do not change (which I think rarely happens)
02:16:01 <piyush-kurur> it should be fine
02:16:07 <merijn> piyush-kurur: Statically linking everything is rather painful in itself
02:16:34 <merijn> piyush-kurur: Like in many situations I expect the answer to "why doesn't this exist" is "nobody cared enough to make it easy/possible"
02:17:19 <merijn> piyush-kurur: I think it'd be neat to have, but unless you're planning to volunteer I don't think anyone will bother any time soon :)
02:17:19 <piyush-kurur> merijn: yes I agree that is the reason one would not want it normally. But things like autobuild bots would not mind a bit of tedium ;-)
02:18:00 <piyush-kurur> merijn: I always thought that the binary was a statically linked one
02:18:14 <piyush-kurur> only now did I realise it is not actually
02:39:35 <merijn> hmmm, we can have named library components in cabal files now? :o
02:49:49 <Myrl-saki> merijn: Why wasn't it there from the start anyway?
02:50:19 <ZeuPiark> hello
02:50:32 <merijn> Myrl-saki: 1 library per package means it's simpler to track dependencies
02:50:48 <Myrl-saki> merijn: True.
02:54:48 <phadej> named library components are internal (at least for now)
02:55:10 <phadej> so you can share code between library and test-suite, but not expose it externally, e.g.
02:57:38 <merijn> phadej: btw, where is this new ^>= bound documented?
02:58:14 <dminuoso> ^>=
02:58:17 * dminuoso :|
03:05:52 <cocreature> merijn: https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-build-depends
03:45:53 <jollygood2> is there a library for pretty printing data to stdout? I mostly need tables
03:46:29 <merijn> @hackage boxes -- jollygood2
03:46:30 <lambdabot> http://hackage.haskell.org/package/boxes -- jollygood2
03:46:55 <merijn> jollygood2: If that doesn't work I'd hack together something yourself using prettyprinter
03:47:42 <jollygood2> merijn thanks
03:58:06 <jollygood2> why am I getting a warning for defining Num instance for Char? Orphan instance: instance Num Char
03:58:29 <jollygood2> "To avoid this move the instance declaration to the module of the class or of the type, or wrap the type with a newtype and declare the instance on the new type."
03:58:41 <merijn> jollygood2: Typeclass instances are global, so you are only ever allowed to have one. However, GHC has no real way of actually guaranteeing that
03:58:57 <jollygood2> no way of guaranteeing there is only one?
03:59:08 <merijn> jollygood2: Orphan instances are instances that are not declared in either 1) the module defining the datatype or 2) the module defining the class
03:59:26 <merijn> jollygood2: If there are no orphan instances, it's trivial to prove that there is only ever one instance
03:59:44 <jollygood2> what if I include two modules that both define same instance, won't that result in an error?
03:59:58 <merijn> jollygood2: Yes. If you happen to do so directly
04:00:26 <merijn> jollygood2: But what if library Foo uses some instance and so does library Bar but they're not linked together? They're compiled independently, so GHC doesn't know they conflict
04:00:41 <merijn> jollygood2: Then your executable links against Foo and Bar and misery ensues
04:00:55 <jollygood2> hmm, what happens then?
04:01:29 <merijn> jollygood2: Depends on the class. Nothing that you will enjoy debugging, though
04:01:56 <ertes-w> jollygood2: apart from all of that a (Num Char) instance sounds questionable at best
04:02:03 <merijn> jollygood2: Consider two clashing Ord instances and both libraries using "Set Foo". Now the Ord instance used for set manipulations is different in each library subtly screwing you over
04:02:17 <jollygood2> ertes-w it is just a fun instance, allowing one to write 'A' + 1 => 'B'
04:02:37 <merijn> jollygood2: So best practice is just to not ever write orphan instances
04:02:57 <ertes-w> > (enum +~ 1) 'A'
04:03:00 <lambdabot>  error:
04:03:00 <lambdabot>      • Couldn't match type ‘Int’ with ‘Char’
04:03:00 <lambdabot>        Expected type: ASetter Char Int Integer Integer
04:03:10 <ertes-w> > (from enum +~ 1) 'A'
04:03:14 <lambdabot>  'B'
04:03:31 <jollygood2> merijn but it seems that this defeats some of the benefits of the typeclasses over OOP classes, namely the fact that you can create an instance after the fact, for classes you didn't write
04:03:40 <tabaqui1> :t from
04:03:42 <lambdabot> (Functor f, Profunctor p) => AnIso s t a b -> p t (f s) -> p b (f a)
04:03:54 <merijn> jollygood2: Only if you want to do so in a library other than the one defining the type
04:04:09 <merijn> jollygood2: And yes, it's not ideal. But it's unclear how to better solve the issue
04:04:24 <merijn> jollygood2: The good news is, you can just newtype and instance for the newtype without issue
04:04:59 <merijn> Or ignore the orphan instance warning
04:05:58 <jollygood2> not the warning one should silence through in any case, which is something I considered
04:06:05 <jollygood2> though*
04:07:27 <ertes-w> jollygood2: if you think you need an orphan instance, chances are you don't need an instance at all…  type classes solve a very specific engineering problem: implicit abstraction/instantiation…  what you need in this case is a mapping from Char to Int, and one option to get that is to use lens
04:07:43 <ertes-w> :t over (from enum) :: (Int -> Int) -> Char -> Char
04:07:46 <lambdabot> (Int -> Int) -> Char -> Char
04:08:20 <ertes-w> > over (from enum) (+ 1) 'A'
04:08:22 <jollygood2> Num Char isn't a serious class, or something that I would write in production code. I was just curious about this warning
04:08:24 <lambdabot>  'B'
04:10:13 <LudvikGalois> Is anyone particularly familar with TH? If I have some functor F, is there a function "F Name -> Q (F T)" (assuming that all Names refer to variables of type T)?
04:10:53 <ertes-w> LudvikGalois: is F a Traversable?
04:15:35 <LudvikGalois> ertes-w: It is in my case, so I suppose my real question is can I write a function "Name -> T", but I get the impression that I can't. I'd also settle for a "F Name -> Q Exp" where Exp splices to be my value of type (F T)
04:15:50 <LudvikGalois> sorry, "Name -> Q T"
04:17:41 <ertes-w> LudvikGalois: if you can write (Name -> Q T), it's a matter of using 'traverse'
04:17:54 <LudvikGalois> I'm abusing quasiquotes to embed a language that isn't Haskell inside of Haskell. The problem is that I want to be able to call arbitrary Haskell functions from within this language (although all of these Haskell functions will have the same type)
04:18:32 <ertes-w> LudvikGalois: why not a regular EDSL?
04:19:53 <tdammers> LudvikGalois: if you can't make it an EDSL, then you will have to support some sort of "unquoting" syntax in your DSL, and your QQ implementation will have to parse the contents of such unquotes back into Haskell AST
04:20:46 <tdammers> there are libraries around for parsing haskell source code, the situation isn't ideal, but it's good enough
04:21:03 <tdammers> I'm not sure whether it is possible to hook into GHC itself to use the "real" parser
04:24:48 <beginner> anyone here?
04:25:04 <LudvikGalois> tdammers: that's not the issue, the problem is that all I get in my quasiquote itself is the name of the Haskell function, and I want to be able to get the definition based on the name, and judging by the documentation for the Info type, this can't be done by just calling reify
04:26:07 <beginner> let's assume there is a function multiply a b = (a+b,  if  even b  then Just b else Nothing)
04:26:59 <beginner> so the type will be  multiply :: a -> b ->  (b, Maybe c)
04:27:21 <opqdonut> not quite
04:27:23 <tdammers> LudvikGalois: you mean the function body? You can't get that, I think; think about it, it might be in a different compilation unit, so the body might not be accessible at all for anything other than evaluating the fn
04:27:40 <beginner> but what if I don't know what 'a' is
04:27:56 <tdammers> beginner: it helps to pick different names for your type variables and term variables
04:28:05 <opqdonut> that's a good point
04:28:13 <beginner> and only interested in the second part of the tuple? (if even b then Just b else Nothing)
04:28:19 <opqdonut> beginner: have you tried defining that function in GHCi and asking GHCi what the type is?
04:28:30 <tdammers> so let's say you use multiply x y = (x + y, if even y then Just y else Nothing)
04:28:43 <tdammers> :t (+)
04:28:46 <lambdabot> Num a => a -> a -> a
04:28:58 <tdammers> this is your first piece of the puzzle
04:29:17 <tdammers> the type of (+) is a -> a -> a, such that an instance Num a exists
04:29:31 <tdammers> (or rather, for any type a that has a Num instance)
04:29:50 <tdammers> so we know that the types of both operands of the + operator must be the same, and that the return type must also be the same
04:30:11 <tdammers> so if you have multiply :: a -> b -> ..., then the usage of (+) tells us that a and be must be the same type
04:30:23 <beginner> let's ignore the (+)
04:30:31 <beginner> because I am interested in the second part of the tuple
04:30:34 <LudvikGalois> tdammers: the function body is an instance of Data and in scope for the splice, which is why I'm hoping someone knows of an easier solution than just calling liftData on my F Name, and traversing it and updating the leaves by hand
04:30:54 <beginner> and want to know if there's anyway to get the result without evaluating the first one
04:31:08 <tdammers> LudvikGalois: idk, it might be possible, I've never needed to do that, and it seems like the kind of thing that should not be possible, morally speaking
04:31:38 <tdammers> beginner: so you want to get the value of the second tuple element without evaluating the first tuple element?
04:31:45 <beginner> yeah
04:31:48 <beginner> is that possible?
04:31:48 <tdammers> beginner: this has little to do with the types, mind you
04:31:55 <tdammers> and yes, it is possible, trivial even
04:32:15 <tdammers> you just don't use the first element for anything, then only the second element will ever be evaluated
04:32:51 <beginner> how do I do it in the multiply example above?
04:32:53 <tdammers> Haskell has non-strict evaluation, which means that only those expressions are evaluated whose results are demanded
04:32:55 <tdammers> so
04:33:28 <tdammers> > let multiply a b = (a + b, if even b then Just b else Nothing) in snd (multiply undefined 2)
04:33:31 <lambdabot>  Just 2
04:33:34 <tdammers> see that?
04:33:49 <tdammers> I used undefined there, which would throw an exception when evaluated
04:33:59 <tdammers> but it doesn't get evaluated, and no exception is thrown
04:34:29 <beginner> brilliant!!
04:34:33 <beginner> thank you so much!
04:34:54 <beginner> I didn't know that trick! Is there anywhere I can read more about it?
04:36:17 <beginner> I know about lazy evaluation, just wasn't aware of something like this.
04:37:04 <frerich> beginner: I think https://www.schoolofhaskell.com/school/starting-with-haskell/introduction-to-haskell/6-laziness is quite good and easily accessible.
04:37:52 <frerich> beginner: The book 'Programming in Haskell' also has a length chapter on it which discusses all kinds of consequences of different 'evaluation strategies', in case you want to know more.
04:38:42 <beginner> frerich: alright, thanks!
04:38:51 <tdammers> beginner: it's not really a trick, but a rather fundamental property of Haskell
04:49:21 <ventonegro> How do we make intero aware of the language extensions defined in package.yml?
04:58:53 <cocreature> ventonegro: it should automatically pick them up. you might need to run "stack build" and restart intero after you’ve modified them
04:59:17 <ventonegro> cocreature: Ok, thanks!
05:02:30 <guessWho> how to write do within where >?
05:04:38 <fakenullie> guessWho: varName = do; ...
05:13:21 <guessWho> fakenullie : can u elaborate a bit
05:13:35 <dminuoso> guessWho: `do { stmts }` is an expression that is syntactically valid in every (?) position you can use an expression.
05:14:28 <dminuoso> > let x = do { a <- [1,2]; b <- [3,4]; return (a, b) } in x
05:14:31 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
05:14:41 <fakenullie> I think it's only valid in last position
05:14:48 <fakenullie> Hm
05:14:57 <fakenullie> In an expression
05:15:19 <dminuoso> fakenullie: Nope. exp -> infixexp, infixexp -> lexp; lexp -> do { stmts }
05:15:40 <fakenullie> dminuoso: you can't add arguments after do
05:16:15 <fakenullie> Do is not a value
05:16:21 <fakenullie> Currently
05:17:07 <merijn> fakenullie: That has nothing to do with whether do is an expression or not, though
05:17:17 <merijn> fakenullie: That's just an accident of how layout rules are interpreted
05:17:21 <guessWho> dminuoso : how about in this case ? http://lpaste.net/363840
05:18:12 <fakenullie> Yeah
05:20:26 <dminuoso> > (do { a <- (*2); b <- (*3); return (a+b) }) 10
05:20:29 <lambdabot>  50
05:20:30 <dminuoso> fakenullie: ^-
05:20:50 <Taneb> dminuoso: you can't do that without the brackets
05:21:05 <Taneb> > do {a <- (*2); b <- (*3); return (a+b)} 10
05:21:08 <lambdabot>  <hint>:1:41: error: parse error on input ‘10’
05:22:00 <dminuoso> Taneb: That does not invalidate my point though.
05:22:13 <jollygood2> > liftA2 (+2) (*2) (*3) 10
05:22:16 <lambdabot>  error:
05:22:16 <lambdabot>      • Couldn't match type ‘Integer’ with ‘Integer -> t’
05:22:16 <lambdabot>        Expected type: (Integer -> t) -> Integer
05:22:18 <jollygood2> ^^ why didn't that work?
05:22:22 <dminuoso> Taneb: my point is the construct `do { stmts }` itself _is_ a statement
05:22:31 <jollygood2> oh
05:22:36 <jollygood2> > liftA2 (+) (*2) (*3) 10
05:22:38 <lambdabot>  50
05:22:42 <Taneb> dminuoso: oh, I thought you were responding to a different point
05:23:05 <dminuoso> Oh and when I say statement I mean expression. :-)
05:23:17 <hc> hi, any users or devs of the "saltine" package here?
05:23:19 <dminuoso> Such a weird moment for my brain to stop.
05:23:22 <Taneb> "<fakenullie> dminuoso: you can't add arguments after do" is what I thought you were responding to
05:23:35 <Psybur__> :t (*2)
05:23:37 <lambdabot> Num a => a -> a
05:23:43 <dminuoso> Taneb: Well I think I have just demonstrated that I can.
05:24:44 <dminuoso> Taneb: If your point is merely that it requires parens, well then what you are saying equates to "lambda expressions cant be applied to arguments" because it requires parens. `\x -> x 10`
05:24:52 <Taneb> dminuoso: I get your point
05:25:06 <Taneb> I'm gonna step out of this one now
05:27:14 <guessWho> dminuoso : i did what you said but something is still wrong here http://lpaste.net/363841
05:27:56 * dminuoso is confused that he knows what monads are category theoretically, but he has no clue what a TChan is
05:35:20 <guessWho> guys how to do inside where >?
05:39:38 <Axman6> guessWho: I cannot parse that question
05:40:11 <Axman6> hc: if you have an issue, it's best to just ask. first rule of IRC: don't ask to ask, just ask
05:40:40 <Axman6> we might be users of the package but might be able to help nonetheless
05:42:13 <guessWho> Axman6 : yeah so i want to use `do` inside a where statement
05:42:46 <Axman6> and what's stopping you?
05:43:00 <Ariakenom> TChan: it's a queue, it's in STM. Has new, read, write. Also dup::chan->m chan -- the new queue starts empty but writing either goes to both
05:43:22 <hc> Axman6: Thanks for the advice :-)
05:43:48 <Axman6> gyour definition for msg is exactly the same as atomically $ readTChan pendingResChan
05:43:56 <Axman6> guessWho: ^
05:44:28 <guessWho> Axman6 : okay i tried but i don't know what's wrong with this http://lpaste.net/363842
05:44:38 <Axman6> guessWho: what you need to do is move your let inside your definition of msg
05:44:51 <hc> Axman6: well, my question is, how difficult would it be to implement a streaming or conduit interface to the box functions
05:45:27 <LudvikGalois> guessWho: let statements don't work like that...
05:45:28 <guessWho> what do you mean by "move your let inside your definition of msg"
05:45:54 <guessWho> LudvikGalois : please tell me how it does i'm here to learn :)
05:46:48 <Axman6> guessWho: you're rushing ahead before learning the fundamentals of Haskell, you should follow some tutorials
05:47:27 <guessWho> Axman6 : doing is the best way of learning i believe
05:47:49 <Axman6> hc: hmm, using the .Box interface it doesn't look easy to define streaming implmentations
05:48:02 <Axman6> guessWho: if you have _some_ idea what you're doing, sure :)
05:48:24 <hc> Axman6: TBH I don't think the library is too useful without streaming implementations
05:48:45 <hc> Axman6: because what do you do if you need to encrypt large files, or serve many files in parallel, for example
05:48:54 <merijn> hc: saltine uses NaCl
05:48:59 <hc> yeah I know :-)
05:49:04 <hc> hence my choosing the library in the first place ;)
05:49:13 <merijn> hc: NaCl is explicitly designed around encrypting fixed size blobs
05:49:30 <hc> Oh is it? I thought saltine used libsodium, which does support streaming
05:49:32 <merijn> hc: So expecting streaming encryption is rather anti-thetical to NaCl's design
05:49:52 <hc> merijn: no wait... nacl has salsa, which is a stream cipher
05:50:01 <DavidLopez> Hey guys
05:50:01 <hc> and chacha20
05:50:02 <guessWho> Axman6 : i can achieve what i'm doing with case but i thought this would be a better and neat approach
05:50:05 <DavidLopez> if i have this
05:50:11 <Axman6> so is AES, doesn't mean it supports streaming
05:50:32 <merijn> hc: Perhaps, but the API design of NaCl explicitly does not last I looked at it
05:50:32 <LudvikGalois> guessWho: let statements work something like http://lpaste.net/363841 (the thing after "in" is the value to return, everything before is a local binding)
05:50:40 <DavidLopez> sequence :: Applicative f => List (f a) -> f (List a)
05:50:40 <DavidLopez> sequence = foldRight (lift2 (:.)) (pure Nil)
05:50:40 <merijn> hc: Anyway, that's a trivial problem
05:50:49 <DavidLopez> how does pure know which applicative to use???
05:50:59 <merijn> hc: Because the simple solution is just "cut your huge file into fixed size chunks"
05:51:12 <merijn> hc: You can even use existing streaming library to do that
05:51:13 <Axman6> DavidLopez:  because it can only use the one you asked it to in the type, f! =)
05:51:41 <hc> merijn: hmm, I thought of that, too... didn't feel right
05:51:45 <merijn> hc: Instead of trying to find a streaming API for saltine, just use pipes/conduit to stream your big file in, e.g. 4kb chunks and use saltine to encrypt each chunk
05:51:49 <hc> merijn: but I agree it may be the easiest way
05:52:03 <hc> jup, thanks for the suggestion, I think I will do it that way!
05:52:07 <hc> :-)
05:52:07 <Axman6> I don't agree that's the best solution, but it is a solution
05:52:27 <cocreature> fwiw it looks like nacl does support streaming encryption https://nacl.cr.yp.to/stream.html
05:52:28 <pagnol> does anyone happen to have some snippets that show how beam can be used with postgres?
05:52:46 <pagnol> the official tutorials only discuss sqlite unfortunately
05:53:08 <merijn> hc: Are you doing public key or symmetric key crypto?
05:53:16 <hc> public
05:53:23 <Axman6> pagnol: there are examples in the repo, also there's #haskell-beam
05:53:32 <hc> but it wouldn't be a problem to use symmetric crypto and store the symmetrical key using box
05:53:52 <hc> in my specific case, anyway
05:53:54 <merijn> hc: You should probably not use public key crypto for large streams anyway
05:54:12 <Axman6> that I can agree with
05:54:16 <jakob1> can someone help me? i need to "run" a parser in the IO monad: parseDocument ( from https://hackage.haskell.org/package/orgmode-parse-0.2.0/docs/Data-OrgMode-Parse-Attoparsec-Document.html )
05:54:16 <jakob1> i have this code so far but i have problems with the the 3rd line:
05:54:16 <jakob1>     stringLines <- fmap lines getContents
05:54:16 <jakob1>     let textLines = map T.pack stringLines
05:54:16 <jakob1>     Document _ headlines <- parseDocument textLines
05:54:18 <hc> well, box does actually just use public key crypto to generate an ecdsa symmetrical key afaict
05:54:20 <merijn> hc: public key crypto leaks info over repeated use
05:54:55 <merijn> hc: Well yes, the NaCl boxes only use public key crypto to establish a symmetric key for exactly that reason
05:55:31 <merijn> hc: Anyway, saltine seems to have a .Stream modules with functions to produce a lazy infinite key ByteString and a lazy xor for encryption
05:55:47 <merijn> hc: Which follows the API cocreature linked
05:55:50 <hc> merijn: yeah, seen that. Not sure if I want to use these as a non-cryptographer, though :-)
05:56:04 <nshepperd1> That's weird, why does nacl not have stream ciphering built in? They expect you to implement gcm yourself without messing it up?
05:56:08 <hc> I might, though. Lemme think about it ;)
05:56:10 <Axman6> jakob1: you need to run the parser using one of the functions from the attoparsec package: http://hackage.haskell.org/package/attoparsec-0.13.2.2/docs/Data-Attoparsec-Text.html#g:5
05:56:32 <merijn> hc: They're fine. The advantage of the box API is that it does authentication too
05:56:42 <guessWho> LudvikGalois : what if i don't want any local values how then i use do inside a where or let like in this case i'm just passing function parameters to things inside do block so no local bindings required , "do { temp <- atomically $ readTChan pendingResChan; return (temp) }"
05:56:47 <merijn> hc: i.e. it not only encrypts, but also signs so you can detect in transit tampering
05:57:11 <Axman6> " how then i use do inside a where" you don't guessWho
05:58:37 <guessWho> Axman6 : so you mean do can't be used inside where >? and can be used inside let >?
05:59:13 <Axman6> guessWho: you need to go and learn about monads and do notation - there are a million tutorials
05:59:18 <fryguybob> guessWho: "do" doesn't cause execution, it is just syntax.
06:01:10 <guessWho> Axman6 : oh really didn't know that thanks :P
06:01:16 <LudvikGalois> guessWho: "do" can be used anywhere that's an expression (which means pretty much anywhere but the left hand side of "=")
06:01:31 <Axman6> > do { [1..10] }
06:01:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
06:03:18 <Ariakenom> > let list = do {x <- [1..3]; [x..3]} in head list
06:03:21 <lambdabot>  1
06:03:41 <LudvikGalois> > map (*2) (do {x <- [1..5]; y <- [x+1..5]; return (x+y)})
06:03:44 <lambdabot>  [6,8,10,12,10,12,14,14,16,18]
06:04:37 <nshepperd1> > do do do do do "inspector gadget"
06:04:41 <lambdabot>  "inspector gadget"
06:04:53 <dminuoso> guessWho: all `do { stmt }` is, is syntax sugar for >>= and >>
06:05:10 <dminuoso> guessWho: `do { stmt }` in fact gets desugared to code using >>= and >>
06:09:17 <guessWho> dminuoso : http://lpaste.net/363844 i'm almost there
06:09:54 <guessWho> dminusos : how do i bind the value to seqList
06:13:31 <jakob1> Thank you Axman6!
06:13:31 <jakob1>     text <- fmap T.pack getContents
06:13:31 <jakob1>     let Right (Document _ headlines) = parseOnly (parseDocument [text]) text
06:13:31 <jakob1> but then, what is the [Text] argument of parseDocument?
06:15:14 <ij> Let's say I live in a "newtype Mine a = ReaderT State IO a" kind of world. How should I use "MonadBaseControl IO m => m a" actions in it? Not liftIO, right?
06:16:48 <merijn> ij: Honestly, my advise would be to ditch MonadBaseControl as it's confusing as fuck and overcomplicates stuff
06:17:41 <ij> So I just cast it to an IO and liftIO it into my newtype?
06:18:04 <ab9rf> "cast"?
06:18:15 <ij> Monomorphize?
06:19:27 <merijn> Unrelatedly: Has someone already written a nice accept loop for accepting connections and forking them off into separate threads yet?
06:19:31 <nshepperd1> You can use liftIO, sure
06:19:45 <ij> I'm not sure about the terminology, help me out here. (Gotta continue reading the book about types, I guess.)
06:19:50 <merijn> I was looking at async, but that doesn't quite capture things
06:19:56 <nshepperd1> Or you could write a MonadBaseControl instance for your newtype
06:20:18 <nshepperd1> Or GND derive one
06:22:01 <merijn> async's link seems to do the exact opposite of what I'd like :\
06:22:42 <nshepperd1> I'm confused by why you would have such an action in the first place though
06:23:00 <ij> nshepperd1, That's the type of groundhog's actions.
06:23:51 <nshepperd1> Normally that class is used to write things like withFoo :: MonadBaseControl IO m => (Foo -> m a) -> m a
06:24:01 <ij> Yeah, withSqlConn
06:24:08 <ij> Sql → Sqlite
06:24:15 <nshepperd1> In which case you want to pass your own argument, that constrains m
06:24:52 <nshepperd1> So you can't just use it at IO type
06:25:23 <ij> I can't put IO in m? Why?
06:25:47 <nshepperd1> What is the type of the argument you are passing?
06:27:54 <ij> My newtype action.
06:28:40 <ab9rf> i
06:28:49 <ab9rf> i'm now totally lost at what you're trying to do, ij
06:29:16 <nshepperd1> Right, so m = Mine, which is different from IO
06:29:18 <merijn> Is there an alternative to async for controlling jobs/threads?
06:29:30 <merijn> Because async doesn't seem to accommodate what I want
06:29:55 <nshepperd1> ij: write a MonadBaseControl instance for your newtype
06:30:09 <ij> nshepperd1, Right, otherwise it can't = m.
06:30:17 <nshepperd1> It should be really simple, involving only unwrapping the newtype constructor
06:30:23 <ab9rf> ij: if you want to use your newtype as an instance for something that requires a particular typeclass, you need to make your newtype an instance of that typeclass
06:30:58 <Ariakenom> merijn, what's wrong with async?
06:31:00 <merijn> I want, like, a erlang like supervisor hierarchy
06:31:14 <merijn> Ariakenom: I can only link tasks in one direction
06:31:33 <merijn> Ariakenom: Also, withAsync makes it hard to spawn jobs of unknown duration
06:31:41 <ab9rf> (you could just enable GeneralizedNewtypeDeriving and let ghc derive it, but down that road live a few snarks and boojums....)
06:32:16 <nshepperd1> Not sure GND would work in this case actually, since there is an associated type family iirc
06:32:21 <Ariakenom> merijn, linking in both directions doesnt sound like a hierarchy or like accepting connections though
06:32:28 <ab9rf> mmm. good point.
06:32:36 <nshepperd1> That weird StM thing
06:32:55 <ab9rf> nshepperd1: i haven't messed with MonadBaseControl much, and yeah
06:32:56 <merijn> Ariakenom: I have one thread accepting connections, which forks of handlers for each connection
06:33:00 <ij> ab9rf, I'm trying that, but it doesn't work.
06:33:06 <ij> paste in a sec
06:33:13 <merijn> Ariakenom: When a child dies/throws an exception I wanna kill the acceptloop and vice versa
06:34:07 <ab9rf> merijn: everyone dies<tm>?
06:34:15 <ij> ab9rf, nshepperd1, https://clbin.com/se2AH
06:34:31 <ab9rf> oi!
06:34:47 <hc> merijn: thanks; I don't need authentication atm anyway
06:34:52 <merijn> ab9rf: hmm, actually I just realised I wrote something similar to this a year ago. Maybe I should just package that up
06:35:06 <merijn> hc: That sounds...suspicious
06:35:20 <ab9rf> ij: GND cannot automatically derive an instance for that typeclass
06:35:23 <Ariakenom> merijn, and Async.link2 doesnt work?
06:35:46 <merijn> Ariakenom: Only if I have to asyncs, but the thread running the acceptloop doesn't have it's own async
06:36:13 <merijn> hc: What if a MITM corrupts your stream and injects data that way?
06:36:23 <merijn> hc: That's not something you want to detect?
06:36:25 <hc> merijn: well you need to define the attack vector properly ;-)
06:36:42 <nshepperd1> ij: needs MonadBase IO as well, which is the superclass of MonadBaseControl. Also I'd be really surprised if deriving MonadBaseControl works
06:36:46 <hc> merijn: it's not to protect network communication, but to protect files against a hdd/machine that gets compromised
06:36:55 <Ariakenom> merijn, that's an unexpected complication. And you cant make it an Async?
06:37:08 <merijn> hc: authentication in the sense used by saltine is just "tamper detection"
06:37:13 <hc> merijn: by the way, the "streaming" functions return strict bytestrings... am I missing something? :)
06:37:16 <hc> merijn: jup
06:37:22 <hc> merijn: that's what I meant by "authentication"
06:37:54 <hc> merijn: if the machine is compromised and the data can still be decrypted, then it doesn't matter if it is authenticated or not anymore :)
06:38:42 <hc> merijn: so the use case is this: user wants to download a file from server; user sends filename+passphrase to server; server derives key using argon2 and decrypts the file on the fly and sends it to the client
06:39:47 <merijn> Didn't johnw have a task management library at some point?
06:41:25 <hc> merijn: what do you think? authentication (integrity) necessary (possible) in this case?
06:41:39 <hc> if the server gets compromised, i mean
06:41:43 <merijn> hc: I mean, my personal opinion would be: why not?
06:41:55 <merijn> hc: Should be near 0 effort to add with saltine
06:42:31 <hc> Yeah, but if the server is compromised, eve gets the private key when a user sends the passphrase, so the integrity guarantee is gone in this case anyway
06:43:42 <hc> merijn: the problem is that the stream function is not lazy: 14:37 < hc> merijn: if the machine is compromised and the data can still be decrypted, then it doesn't matter if it is authenticated or not anymore :)
06:43:51 <hc> sorry, meant to paste https://hackage.haskell.org/package/saltine-0.1.0.0/docs/Crypto-Saltine-Core-Stream.html#v:stream
06:44:51 <merijn> hc: Right, so you might wanna go the earlier repeated box way, and the boxes *do* do authentication :)
06:45:09 <hc> yeah I guess that's what I'm going to do
06:45:21 <hc> thank you very much for your help! :-)
06:47:57 <Axman6> jakob1: according to the source, it's "other keywords"
06:48:05 <Axman6> https://hackage.haskell.org/package/orgmode-parse-0.2.0/docs/src/Data-OrgMode-Parse-Attoparsec-Document.html#parseDocument
06:53:55 <ij> nshepperd1, Yeah, it worked, but with BaseControl in a newline. -- newtype IRC s a = IRC { ReaderT … } deriving (Functor, …, MonadBase IO) \n\n instance MonadBaseControl IO (IRC s)
06:54:24 <Boarders_> Hi, I am trying to install hlint but get this: http://lpaste.net/363846
06:54:37 <Boarders_> any ideas on what to do?
06:58:45 <Boarders_> oh just needed sudo, nvmd
06:59:01 <ij> nshepperd1, Oh, but it needs an implementation, ha. I figured it derived something and wouldn't compile without an implementation.
07:01:22 <SN> can someone please tell me how to go about the " offline mode for stack" project in GSoC
07:12:03 <jakob1> Thanks Axman6. I forgot to look in the source!
07:18:31 <merijn> So, what's people's opinion on UnliftIO and transformers that are basically newtype's around ReaderT?
07:31:27 <xandaros> Don't know what UnliftIO is (I'll have a look later!), but I love my ReaderT newtypes
07:32:15 <merijn> xandaros: UnliftIO is Snoyman's new library for dealing with bracketing and monad stacks. i.e. competing with MonadBaseControl and exceptions
07:32:36 <merijn> However, unlike MonadBaseControl the interface isn't completely ununderstandable
07:32:51 <xandaros> Sometimes you really need access to some data in just about anything you call and ReaderT comes in handy here. However, using an exposed monad stack is... eh, not a fan
07:32:53 <merijn> Plus, it has a really small dependency footprint (i.e. just base and transformers)
07:33:01 <pagnol> boj, do you use the SqlSerial type in beam?
07:33:29 <hc> merijn: what do you think? :) http://lpaste.net/363848
07:34:14 <xandaros> I usually use a transformer stack to do the actual work, hide it all under a newtype and define my own functions using it, only exposing what I actually need. (And no lift . lift . lift . lift nonsense)
07:35:55 <xandaros> merijn: I guess that answers what you think of unliftio :P
07:36:28 <hc> ah well I should probably encode the length of a particular chunk as well ;/
07:36:48 <merijn> hc: Personally I'd use something like conduit/pipes to deal with the streaming, but other than that looks reasonable
07:37:06 <merijn> xandaros: Well, I'm cautiously optimistic, just wondering if I'm missing something, hence curious what others think
07:37:35 <xandaros> Reading through the readme, it seems to solve a problem I have never come across
07:37:55 <merijn> xandaros: You never find yourself needing bracket in transformer stacks?
07:39:04 <hc> ah well I should probably encode the length of a particular chunk as well ;/
07:39:14 <xandaros> Maybe I'm misunderstanding, but I don't think so
07:39:15 <hc> merijn: thanks
07:39:37 <Peaker> hey, how come scanl is for lists and not for any traversable?
07:39:52 <merijn> xandaros: bracket and co are for ensuring resources get freed upon (async) exceptions
07:40:12 <Peaker> oh, it's the extra element
07:40:13 <xandaros> Oh, I see. That bracket
07:40:38 <xandaros> But, err... no. Never been an issue :P
07:40:56 <xandaros> I can see how this could be a problem, though
07:42:20 <dminuoso> Is hackage timing out for anyone else?
07:43:32 <xandaros> No, but it is very slow
07:43:52 <xandaros> seems to be better now
07:54:13 <cppxor2arr> I came on Freenode just to share my excitement from finding out there are SFML bindings for Haskell!
07:56:12 <Boarders_> does anyone know if there is a good reason why the shake library defines a platform specific exe for if you are on windows but does not define similar construct for static or shared libraries?
07:56:30 <Boarders_> it is not hard to write, I just wonder if there is a design reason why you wouldn't want it
08:00:04 <slowpoke> hey all, I want to make a function that takes a string and a series of statements in a do-block, and those statements have access to the string behind the scenes. Is this the reader monad?
08:03:24 <Ariakenom> slowpoke, yup sounds correct.
08:07:52 <slowpoke> Ariakenom: great, I'm just a bit confused on how to actually implement it. Atm I have a function "f :: String -> (a -> b) -> IO()", which I want to be able to access the string. What would the type of the enclosing function be?
08:11:15 <ij> nshepperd1, I can't write my own liftBaseWith.
08:11:28 <slowpoke> to be clear, I'm looking for something like this: enclosingFunc "context" $ do f "first" (some a->b); f "second" (some other a->b); etc., and the f's can read the context string
08:14:57 <lyxia> be more concrete, what is f supposed to do with that context string?
08:15:34 <ij> nshepperd1, I'm not sure such a type can even exist.
08:16:02 <marvin3> slowpoke would this word for you? enclosingFunc "context" (\x -> do f x "first" (some a->b); f x "second" (some other a->b))
08:16:04 <slowpoke> lyxia: prepend it to its own string argument before sending an OSC message, so something like "context_first", "context_second" etc
08:16:05 <marvin3> work*
08:16:56 <slowpoke> marvin3: it could, but the goal is to reduce necessary typing as much as possible because it's meant to be used for live coding performances
08:17:05 <lyxia> slowpoke: with the ReaderT transformer, maybe f should be of type  String -> (a -> b) -> ReaderT String IO ()  where "ReaderT String" is the part that captures the context
08:17:49 <lyxia> slowpoke: so that block would look like (flip runReaderT "context" $ do f "first" (...) ; f "second" (...))
08:18:52 <fakenullie> why do lookups have key as a first argument?
08:19:50 <lyxia> they just do
08:20:10 <merijn> fakenullie: So you can partially apply them and reuse them on different containers
08:21:12 <fakenullie> merijn: I find myself flipping them to look up several keys from one container
08:22:05 <slowpoke> lyxia: thanks, I'll work on it and I'll be back if I have more questions!
08:23:17 <thebnq> look up x in xs flows nicer than lookup in xs, x
08:23:18 <ij> "liftBaseWith :: (RunInBase m b -> b a) -> m a" <-- if RunInBase is also a function, how can such a type exist, given that there's no input?
08:24:20 <lyxia> ij: the argument of liftBaseWith is a function that can apply the RunInBase
08:25:23 <lyxia> liftBaseWith (\run -> run m)
08:25:32 <haskellNewb> Hi, I am following the servant cookbook example of doing JWT
08:25:49 <ij> lyxia, I'll try to digest that now.
08:25:50 <reactormonk> I've got a `data Module r = <uses r>`, is it possible to write a `class HasModule r where hasModule :: Lens' r (Module r)`, and then `instance HasModule (Module s) where hasModule = identity` somehow? The recursiveness of the type makes it hard.
08:26:06 <haskellNewb> trying to add a (Pool Connection) to the server I run into this problem:
08:26:38 <haskellNewb> Overlapping instances for HasContextEntry                                   '[JWTSettings, CookieSettings,                                     BasicAuthData -> IO (AuthResult AuthenticatedUser)]                                   SAS.BasicAuthCfg         arising from a use of ‘serveWithContext’       Matching instances:         two instances involving out-of-scope types           instance [overlappable] [safe] HasContextEntry
08:26:42 <haskellNewb> oops
08:26:43 <haskellNewb> sorry
08:27:09 <haskellNewb> http://lpaste.net/363851
08:27:11 <ij> lyxia, Right, but I need to implement it the liftBaseWith. It gets a function for which I've no input to give, so I can't produce any output.
08:27:13 <lyxia> reactormonk: id would make r ~ Module r, so that's not possible
08:27:33 <haskellNewb> if the error is not obvious, I will paste more source
08:27:35 <reactormonk> lyxia, yeah, exactly. Is there a solution around this?
08:28:00 <lyxia> ij: the input is the RunInBase function. You're not supposed to provide the input to the input.
08:28:05 <haskellNewb> cookbook link: http://haskell-servant.readthedocs.io/en/stable/cookbook/jwt-and-basic-auth/JWTAndBasicAuth.html
08:28:27 <lyxia> reactormonk: Can you say more about what you're doing here
08:28:32 <slowpoke> do I have to install Control.Monad.Reader before I can import it? Intero can't find it
08:29:14 <haskellNewb> slowpoke you need "mtl" package I think
08:29:44 <reactormonk> lyxia, sure. got an RIO r a (ReaderT IO r a) and `data Module r = Module { foo :: RIO r () }` And I'd like to build a lens from r to Module r.
08:30:27 <lyxia> slowpoke: install mtl.
08:30:39 <lyxia> haskellNewb++
08:30:48 <slowpoke> lyxia: hmm cabal says it's already installed, is it a stack problem?
08:31:18 <lyxia> slowpoke: this is a strange question as you're not supposed to use both
08:32:30 <Welkin> I have rcently found that people new to haskell get very confused about stack and cabal
08:32:37 <Welkin> they should just use cabal and avoid stack
08:33:04 <Welkin> stack hides cabal from you, and some people that use stack don't even know that cabal exists or what it is
08:33:06 <slowpoke> lyxia: I thought stack used cabal under the hood. Either way, restarting emacs fixed it
08:33:23 <merijn> slowpoke: stack uses Cabal (note: capital C) the library
08:33:31 <lyxia> reactormonk: I don't understand the significance of such a lens.
08:33:33 <merijn> slowpoke: "cabal" the executable is cabal-install
08:33:58 <merijn> slowpoke: stack uses Cabal, but not cabal-install and, thus, not the cabal executable
08:34:06 <ij> lyxia, finally I got it
08:34:23 <lyxia> reactormonk: do you have another less trivial instance for the HasModule class?
08:34:30 <slowpoke> merijn: I see, so how should I be installing all packages and dependencies in the future?
08:34:48 <reactormonk> lyxia, sure, from another data type pointing to the Module itself, e.g. Env would point to Module Env
08:35:04 <merijn> slowpoke: That's up to whatever you prefer
08:36:40 <Welkin> slowpoke: you have to choose one
08:37:01 <Welkin> the main options are use cabal with sandboxes, use cabal new* with nix-style builds, use cabal with nix package manager, or use stack
08:37:37 <merijn> tbh, new* pretty much obsoletes sandboxes, I'd never recommend sandboxes now that that's an option
08:37:39 <Welkin> the most advanced set up uses nix package manager with cabal
08:38:27 <Welkin> sandboxes are a fine choice still
08:38:40 <Welkin> especially since the new* api is not fully implemented yet
08:39:06 <lyxia> reactormonk: how about  class Has e r where has :: Lens' r e;  instance Has (Module Env) Env where has = ...;  instance Has (Module r) (Module r) where has = id
08:41:02 <reactormonk> lyxia, that compiles in that module, lemme see how it works out with using it
08:46:26 <haskellNewb> any solution to my query, please?
08:47:24 <guessWho> I have two very simple functions here http://lpaste.net/363852 what's the best way of writing these two functions in haskell >?
08:47:40 <Welkin> guessWho: whatever way works
08:48:10 <ab9rf> guessWho: there is no "best way"
08:48:13 <glguy> (0==) <$> readChan x -- is pretty short
08:48:44 <glguy> You don't need all the ()s in your definition of dummyF
08:49:08 <glguy> do msg <- readChan x; return (0 == x)
08:49:22 <Welkin> guessWho: just read a lot of code and you will pick up a style for writing your programs
08:49:40 <Welkin> also, everyone write a bit differently
08:49:54 <Welkin> some people love using certain libraries in everything, others like to overuse features
08:50:10 <glguy> Welkin The trouble with the code as pasted is that both examples are wrong
08:50:10 <glguy> so it's not just about picking a style but figuring out how to do this IO stuff
08:50:13 <Welkin> some like to use lots of parentheses
08:50:44 <Welkin> I didn't take a look at the code, but I did say "whatever way that works"
08:51:19 <Welkin> in the case of the code being incorrect, that is a different matter
08:51:23 <Welkin> but that was not the question
08:52:45 <guessWho> Welkin : parenthesis are not an issue here they are more about preferences and when i asked about best way i meant best practices which actually follows the philosophy of haskell
08:53:02 <ab9rf> aw, blow that nonsense. just write code.
08:53:28 <Welkin> guessWho: there is no philosophy of haskell
08:53:33 <Welkin> we aren't a cult
08:53:43 <guessWho> glguy : how do i actually use do inside a let because at the end i can return but to bind it to a value i again need do ???? it's recursively confusing  :p
08:53:45 <merijn> Welkin: Well....
08:53:49 <Welkin> as long as the type all match up and it works, go ahead
08:53:52 <Welkin> types*
08:54:28 <Welkin> "best practices" are for people who can't think for themselves
08:54:37 <ab9rf> guessWho: you can use do anywhere you could use any other expression
08:54:50 <guessWho> Welkin : well i'm working with someone who cannot tolerate me misusing haskell
08:54:56 <Welkin> or who don't want to take the blame for something going wrong. they can point to "best practices" to alleviate themselves of blame
08:54:56 <ab9rf> guessWho: do is just syntatic sugar
08:55:21 <ab9rf> guessWho: how does one "misuse haskell"? it's not like it's a prescription medication
08:55:25 <ab9rf> it's a programming language.
08:55:39 <Welkin> it sounds like the person you are working with might be an asshole
08:56:15 <guessWho> ab9rf : got it but the problem is suppose say i want to read from a chan in let and then want to use the content read from it in function , then how do u bind the value i read from chan ??
08:56:51 <ab9rf> guessWho: there are three or four ways to do that, off the top of my head
08:56:56 <ab9rf> guessWho: any of them are fine
08:57:26 <vivu> ciao
08:57:29 <guessWho> ab9rf : for now one would suffice
08:57:30 <vivu> !list
08:57:59 <Welkin> lol
08:58:08 <Welkin> vivu was looking for file servers
08:58:21 <guessWho> ab9rf : i'm confused about how to bind it i know do can be used anywhere like other expression but that just passes IO something around how to actually bind the result to a value
08:58:36 <Welkin> guessWho: learn what do-syntax actually is
08:58:41 <ab9rf> guessWho: since you're reading from a chan, i'm going to guess that you're dealing with something living in IO
08:58:44 <Welkin> it is bind (>>=) and lambdas
08:59:02 <ab9rf> guessWho: in most cases, that argues for using do syntax. you could use bind (>>=) but most people find do syntax easier to understand
08:59:06 <guessWho> Welkin : so having multiple IO operations in haskell and having multiple do inside a function is not a sin in haskell ??
08:59:34 <Welkin> guessWho: that might be pretty ugly and hard to read (and there are gotchas with do-syntax)
08:59:43 <Welkin> I would stick with explicit bind and lambdas for now
08:59:47 <Welkin> avoid do syntax completely
08:59:59 <Welkin> you need to understand how it works before you can use do-syntax
09:00:02 <glguy> guessWho: You might be misunderstanding what writing do actually does, it isn't magically making some IO happen
09:00:12 <Welkin> otherwise, it will forever be "magic"
09:00:56 <Welkin> @undo do { x <- [1,2,3], y <- [4,5,6], return (x,y)}
09:00:57 <lambdabot> <unknown>.hs:1:18:Parse error: ,
09:01:04 <Welkin> @undo do { x <- [1,2,3]; y <- [4,5,6]; return (x,y)}
09:01:05 <lambdabot> [1, 2, 3] >>= \ x -> [4, 5, 6] >>= \ y -> return (x, y)
09:01:13 <ab9rf> guessWho: "do" isn't about "passing IO around"
09:01:24 <Welkin> you can never escape IO. Never
09:01:39 <Welkin> IO is at the top level of your program (the entry point, `main`)
09:01:47 <Welkin> the majority of your program is not in IO
09:02:04 <ab9rf> Welkin: well, at least we hope that the majority of one's program is not in IO
09:02:49 <guessWho> ab9rf : what if majority of functions in my program are performing one or another form of IO , how bad is that .?
09:03:00 <Welkin> guessWho: look into refactoring
09:03:05 <Welkin> that pretty much defeats the purpose of haskell
09:03:19 <Welkin> the cool thing about haskell is that it lets you encode effects in your types
09:03:19 <ab9rf> guessWho: you still need to separate the IO from the computation of what to output
09:03:34 <Welkin> and separate the effectful parts from the non-effectful parts
09:03:36 <ab9rf> like, say you're writing a disk defragmenter
09:03:46 <ab9rf> the code that decides what to move where doesn't do IO
09:04:02 <Welkin> if everything is in IO, you are bascially writing any imperative language
09:04:03 <jared-w> I recently thought up a good heuristic for separating out IO from non-IO for myself. It goes "IO code should 'get data' and then your non-IO code should transform the data"
09:04:11 <ab9rf> it takes in a list of where things are, and returns a list of where to move things to
09:04:15 <ab9rf> (or something like that)
09:04:33 <ab9rf> the app will do a fuckton of IO, but there are still significant parts of the code that are non-effectful
09:05:20 <Welkin> for a video game, for example, the only IO will be the initialization, sending data to the renderer, and capturing input from the user. 99% of the program does not need to be in IO
09:06:09 <ab9rf> jared-w: a lot of the code i write is one-time ETL stuff. all ETL is "read data in, transform data, write data out"
09:06:21 <dyl> More or less, you can model the game itself as an integrator (state-loop): (prevState, inputs, ...) -> newState
09:06:28 <ab9rf> jared-w: sometimes there will be multiple iterations or something in there but the basic model is always the same
09:06:31 <dyl> e.g. each step is pure, even though the provision of new inputs isn't.
09:10:04 <jared-w> right
09:10:06 <ab9rf> aw, we lost him
09:11:00 <jared-w> That's a mistake I made when I wrote out the first version of a "404 checker" (scrapes all urls in a website and sees if any of them return 404). I tried to decompose it along one axis and ended up making lots of "do one thing" functions but they all returned IO
09:12:04 <jared-w> I also wanted to keep the Maybe in the type the whole way through so I ended up threading "Maybe IO"s all over the place and flipping the structures repeated, and doing a lot of traversing/sequencing/fmapping to hop through all the hoops I made for myself :p
09:13:47 <jared-w> I also made the mistake of using req instead of wreq before I had solidified on a design and locked myself into types that were a bit too restrictive for how I had things setup. Good learning experience, though :)
09:14:08 <lsund> quit
09:30:26 <johnw> merijn: async-pool?
09:30:40 <merijn> johnw: maybe?
09:33:31 <hc> merijn: I took your advice and rewrote the code using conduits. Awesome suggestion; I can even still use lazy bytestrigns using the sourzeLazy and sinkLazy combinators \o/
09:35:49 <albeit> If I have a nested state like FooBarState :: StateT Foo (StateT Bar IO), in a computation of FooBarState, is it possible to access the Bar state with lens' "use"?
09:38:03 <hc> merijn: I wrote a function "atLeast" for the decryption part ( http://lpaste.net/363855 ) Any better way to do this?
09:38:16 <glguy> Yes, use lift
09:38:18 <Ferdirand> albeit: you could lift the entire stateful op ?
09:39:28 <merijn> hc: Not sure of the top of my head
09:39:48 <slowpoke> if I have a function of type IO() and I want to turn it into a ReaderT a IO(), what should the function return? An IO() action as before?
09:40:17 <glguy> slowpoke: A function can't have type IO (), functions have types a -> b, for some a and b
09:40:42 <glguy> You can use (lift :: IO () -> ReaderT r IO ())
09:42:16 <slowpoke> glguy: yeah sorry, I meant String -> IO(). So modifying the function to return a readerT only requires asking for the context in the body of the function and lifting what used to be its output?
09:57:49 <agentultra> http://lpaste.net/7736979616300007424 given those definitions in graphql-api, I'm not sure how to resolve the ambiguity of the expression `toValue Nothing`; anyone know what annotation would be required?
10:04:12 <cocreature> agentultra: it would be helpful if you show us the actual error
10:04:39 <cocreature> agentultra: you probably need something like "toValue (Nothing :: Maybe Int)"
10:05:34 <cocreature> agentultra: the problem is that GHC doesn’t know if you want "Nothing" to have type "Maybe Int", "Maybe Bool", …. in this case it doesn’t matter but GHC doesn’t know that
10:06:06 <nut>  data System = System
10:06:06 <nut>   { _machine1, _machine2, _machine3 :: Machine } deriving (Show),  how to access field if it's System {_machines :: [Machine]}
10:06:26 <nut> using the Lens library
10:07:00 <cocreature> nut: I’m not sure I understand, are you using the first or the second definition of System?
10:07:17 <cocreature> and which field do you want to access?
10:07:30 <agentultra> cocreature: added the error msg, thanks. Oh right, there needs to be a type fo `a`; is this a bit of a code smell? am I barking up the wrong tree?
10:08:18 <cocreature> agentultra: I don’t think it’s a code smell. sometimes you just need to add a type annotation. there is nothing wrong with that
10:08:35 <nut> cocreature:I want to use the second
10:09:05 <nut> In in haskell there is no array[1].field
10:09:16 <nut> My question is how to access the list
10:09:23 <nut> by using !! ?
10:09:26 <mtjmullen> > [1,2,3] !! 0
10:09:28 <cocreature> nut: if you’ve generated lenses using "makeLenses". you can use "view machines :: System -> [Machine]"
10:09:30 <lambdabot>  1
10:09:59 <nut> cocreature:you are right, i did use makeLenses
10:10:32 <nut> I want to modify the status of say the second in the list
10:10:47 <nut> How to access the second of [Machine]
10:10:58 <agentultra> cocreature: thanks again.
10:11:17 <mtjmullen> There's an index lens, is that what you want?
10:11:19 <nut> (machines !! 1).field += 3, for example?
10:11:21 <cocreature> nut: given "f :: Machine -> Machine" you can use something like "over (machines . ix 1) f"
10:11:42 <mtjmullen> ^
10:11:43 <nut> i see
10:11:48 <cocreature> > over (ix 1) (+1) [1,2,3]
10:11:52 <lambdabot>  [1,3,3]
10:12:17 <nut> it works
10:12:18 <nut> thanks
10:13:15 <mtjmullen> BTW, if you want to ensure that you always have at least one machine in your system, you may want to look at Data.List.NonEmpty
10:13:57 <mtjmullen> It also works with the `ix` lens
10:14:05 <nut> that field in machine happens to be an Int, so I can use machine . ix 1 . intField += 1 to update
10:14:12 <nut> what is it's a tuple?
10:14:41 <nut> How to update individual field inside that tuple?
10:14:52 <mtjmullen> what IF it's a tuple?  Then you can use Control.Lens.Tuple
10:14:55 <cocreature> you can use _1 or _2 to index into the tuple
10:15:03 <mtjmullen> > (1,2)^._1
10:15:04 <nut> wow
10:15:06 <lambdabot>  1
10:15:11 <nut> cool
10:15:23 <nut> cocreature:thanks man
10:15:30 <mtjmullen> > ("machine1",2)^._2
10:15:33 <lambdabot>  2
10:16:12 <mtjmullen> They go all the way up to _19, so you should be good :)
10:21:00 <nut> I feel this way of programming is imitating imperative style or OO style
10:21:03 <nut> am i right?
10:21:10 <nut> with the Lenses stuff
10:23:35 <thebnq> sure, but its got some major differences
10:24:33 <AWizzArd> When using the DuplicateRecordFields extension – how can I access (i.e. read) from a value of type T1 a certain field? For example When two types T1 and T2 both have the field `foo`. I have a T1 value and want to read its `foo` field.
10:25:03 <agentultra> AWizzArd: I know this one, sometimes if it's ambiguous you just need to give a type annotation
10:25:26 <mtjmullen> nut: the creator of the lens library did a talk titled 'Lenses: A Functional Imperative' :)
10:25:27 <agentultra> foo (bar :: BarType)
10:25:56 <agentultra> foo (bar :: QuxType)
10:26:33 <agentultra> but it can often figure out which foo to use by inference.
10:28:37 <AWizzArd> Ok cool, this works.
10:28:53 <AWizzArd> I was surprised that it couldn’t infer the type for my `foo` call.
10:29:17 <AWizzArd> That is probably simply the price for using this extension.
10:29:28 <bleepbloop> hey, does anyone know any online Haskell tutors?
10:29:36 <nut>  
10:29:36 <nut>   units . ix 1 . position^._1 += 1
10:29:50 <nut> to update a tuple with lenses, this doesnt work
10:30:16 <glguy> ^. is for reading from a lens, so that doesn't belong in this case
10:30:52 <nut> it does work for another field
10:31:04 <nut> units. ix 1. health += 1
10:31:15 <glguy> that worked because you didn't try to use ^.
10:33:32 <nut> what's a quick fix here?
10:34:19 <agentultra> bleepbloop: https://dirtcheaphaskell.io/ maybe
10:34:20 <eacameron> Is there a way to map `Down` onto the keys of a Map? I want to use forM over it but with reverse ord
10:35:46 <bleepbloop> agentultra: awesome, thanks!
10:37:08 <agentultra> bleepbloop: hth :)
10:38:08 <amalloy> eacameron: fold over the result of toDescList instead?
10:38:56 <eacameron> amalloy: Yeah that would work. Although I'm still curious if there's a way to capture it in the type somehow `Map (Down Int) Thing`
10:39:11 <amalloy> sure, if you build the map backwards to begin with
10:39:29 <cocreature> eacameron: you can use mapKeys Down but that’s expensive
10:39:45 <amalloy> Map (Down Int) Thing would be a plausible type
10:40:02 <eacameron> cocreature: I wondered if it would be expensive. Thanks that's what I was looking for, but I won't use it.
10:40:30 <cocreature> eacameron: it can’t do better than rebuilding the entire map in general
10:40:42 <eacameron> So somethign like `fromAscList . first Down . Map.toDescList`
10:41:56 <amalloy> :t first
10:41:58 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
10:42:12 <cocreature> yeah that’s what I would use
10:42:26 <eacameron> need a `map (first Down)` but yeah
10:42:41 <eacameron> Heh...first down; that's kinda funny
10:43:16 <amalloy> fromAscList . (coerce :: [(Int, Thing)] -> [(Down Int, Thing)]) . toDescList?
10:43:34 <cocreature> even better
10:43:37 <eacameron> Yeah nice
10:44:18 <amalloy> actually i guess you can move the type signature to avoid making it so long
10:44:30 <eacameron> Maybe I'll pitch that function to containers
10:44:45 <amalloy> annotate the type of the resulting map instead of the type of the coercion function, and let inference handle it
10:45:04 <eacameron> Yeah than it could be `Down (Down Int))`
10:45:05 <eacameron> :P
10:45:08 <amalloy> eacameron: i am not the maintainer of containers, but that seems like an awfully specific thing to put into the library
10:45:56 <eacameron> Maybe so.
10:49:03 <Ferdirand> is there anything in the standard lib that would have a type close to this one:  (MonadIO m) => IORef s -> (StateT s m t) -> m t
10:49:09 <Ferdirand> hoogle doesn't find anything
10:49:13 <Ferdirand> or is this a terrible idea ?
10:49:47 <merijn> Ferdirand: Why even bother with StateT if you're gonna use IORef?
10:49:52 <merijn> Ferdirand: Just use ReaderT?
10:50:23 <Ferdirand> because i don't want to use ioref all the time
10:50:39 <Ferdirand> i just want a convenient way to lift this into IO for interactive use in ghci
10:51:55 <merijn> Ferdirand: Yeah, but what's StateT doing there?
10:53:35 <Ferdirand> i tried to write it with just State first
10:54:14 <Ferdirand> and I had IORef s -> (State s t) -> IO t
10:55:09 <Ferdirand> then i thought i might as well use StateT, though i didn't think at all about performance
10:55:43 <Ferdirand> it's not super important, it's a little toy cli lib for managing player character sheets and dice rolls
10:57:49 <noughtmare> :t (\s r -> execState s <$> readIORef r)
10:57:52 <lambdabot> error:
10:57:52 <lambdabot>     • Variable not in scope: readIORef :: t -> f b
10:57:52 <lambdabot>     • Perhaps you meant ‘readSTRef’ (imported from Data.STRef)
10:58:05 <noughtmare> Oh
10:58:43 <noughtmare> :t (\s r -> Control.Monad.State.execState s <$> readIORef r)
10:58:46 <lambdabot> error:
10:58:46 <lambdabot>     • Variable not in scope: readIORef :: t -> f b
10:58:46 <lambdabot>     • Perhaps you meant ‘readSTRef’ (imported from Data.STRef)
10:58:56 <noughtmare> :t (\s r -> Control.Monad.State.execState s <$> Data.IORef.readIORef r)
10:58:59 <lambdabot> State b a -> GHC.IORef.IORef b -> IO b
10:59:01 <noughtmare> :)
10:59:46 <noughtmare> Ferdirand, is that what you mean?
11:00:26 <Ferdirand> almost, i need to write back the final state to the ioref too, but that is pretty much what i have
11:00:59 <Ferdirand> i was just wondering why such a seemingly basic construct was not somewhere in the standard lib, and if it was a horribly flawed idea
11:01:34 <hololeap> :t cata
11:01:36 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
11:05:30 <hololeap> is there a name for this function? \f g -> ana f . cata g :: (Functor f, Functor g) => (a -> f a) -> (g a -> a) -> Fix f -> Fix g
11:05:59 <hololeap> it's sort of an inside-out hylomorphism
11:06:49 <noughtmare> Ferdirand, I guess State and IORef's are often seen as alternatives to eachother, so it is not that common to mix them. Also there are multiple types of references like IORef STRef MVar TVar that could all be used for storing the state, so it would add bloat to the mtl library if it were added there.
11:07:23 <mtjmullen> hololeap: Wikipedia claims it's called a 'metamorphism'
11:07:41 <mtjmullen> "A related type of function is a metamorphism, which is a catamorphism followed by an anamorphism."
11:07:57 <hololeap> oops, i had that page open but overlooked that :)
11:08:15 <mtjmullen> It was kinda hidden :)
11:08:20 <mtjmullen> https://hackage.haskell.org/package/metamorphic
11:08:59 <hololeap> sweet, thanks
11:18:04 <qeyoa> I had a few days off from learning haskell and i seem to forgot about `instance` implementations. Is anything in this implementation recursive?: http://lpaste.net/363861.
11:18:45 <glguy> qeyoa Show isn't for writing pretty printers
11:19:21 <qeyoa> the book says: "..We now declare a type for numeric expressions, which can either be an integer value or the
11:19:27 <qeyoa> application of an operator to two argument expressions, together with a simple pretty-printer
11:19:30 <qeyoa> "
11:19:37 <glguy> It's probably recursive, but we can't know that without knowing the definition of Expr
11:20:01 <qeyoa> Expr is recursive: data Expr = Val Int | App Op Expr Expr
11:20:06 <dminuoso> qeyoa: Show is still not for pretty printing.
11:20:19 <qeyoa> so should i not read this chapter?
11:20:22 <ab9rf> show is supposed to genreate a representation that could be read back in
11:20:39 <dminuoso> qeyoa: The main purpose of Show is to produce a syntactically correct Haskell expression, that would produce the value back that you just Showd
11:20:52 <qeyoa> like in lisp?
11:21:23 <amalloy> so like, the Show instance you're looking at is not a good Show instance for the reasons these guys are giving, but if you ignore what Show is "supposed" to do you can still study its definition and learn useful things
11:22:00 <qeyoa> so if this is recursive, where is the break point, every case seems to call `show`?
11:22:22 <qeyoa> or am i confusing something here
11:22:26 <qeyoa> probably so
11:22:32 <ab9rf> qeyoa: the definition for brak (Va n) calls a different instance of show
11:22:51 <ab9rf> also the one for show (Val n)
11:22:55 <qeyoa> ah, ok
11:23:05 <ab9rf> both of those chain to the instance of show for n, whatever n is
11:23:33 <hyperisco> ideally  read . show :: (Show a, Read a) => a -> a = id
11:23:41 <qeyoa> thanks
11:23:46 <ab9rf> i don't know what the definition of Expr is so i can't say, but unless Expr = Val Expr (which would be problematic)
11:23:52 <qeyoa> data Expr = Val Int | App Op Expr Expr
11:24:39 <dminuoso> qeyoa: You might be interested in this by the way:
11:24:43 <dminuoso> :t showsPrec
11:24:45 <lambdabot> Show a => Int -> a -> ShowS
11:24:47 <dminuoso> :t showParen
11:24:49 <lambdabot> Bool -> ShowS -> ShowS
11:25:15 <hyperisco> the eval property of show is sort of weird because it can't account for definitions in scope
11:25:39 <hyperisco> it is moreso a moral thing
11:25:52 <Myrl-saki> hyperisco: The `Read a` constriant there is really important. IIRC, Show by itself has no invariants.
11:26:45 <hyperisco> yeah it is ad-hoc because there is no ReadShow class
11:28:02 <hyperisco> and hence "ideally" rather than it being a law
11:29:11 <ab9rf> it's not required that a type with a Show instance have a Read instance (or, for that matter, vice versa)
11:29:33 <ab9rf> so it's not "required" that a show implementation genreate a readable string, but that is the idea
11:29:58 <agentultra> Haskell is so awesome. I can't believe it took me so long to start learning and using it. Thank you to any contributors, library authors, and helpful folks here. :)
11:30:04 <dminuoso> It's just assumed that `Show` produces something syntactically valid to copy paste into GHCi afaik
11:30:23 <hyperisco> show = ":quit"
11:30:28 <ab9rf> haha
11:30:47 <dminuoso> Does that imply that Read assumes to be able to parse something just like GHC/GHCi would?
11:32:00 <kuribas> is there a convention that read . show = id ?
11:32:06 <ab9rf> no, read parses a subset of what ghc/ghci do
11:32:21 <ab9rf> we don't expect a read instance to be able to handle arbitrary code
11:32:26 <ab9rf> or to be able to infer types
11:32:41 <hyperisco> kuribas, yes
11:32:57 <kuribas> hm, I never did that in my code...
11:33:55 <kuribas> ab9rf: show shouldn't output arbitrary code, AFAIK...
11:33:55 <ab9rf> > read "[1,2,3,4]" :: [Int]
11:34:00 <lambdabot>  [1,2,3,4]
11:34:00 <ab9rf> > read "[1..]" :: [Int]
11:34:04 <lambdabot>  *Exception: Prelude.read: no parse
11:34:39 <kuribas> > show "[1..]"
11:34:40 <cocreature> ab9rf: show won’t output [1..]
11:34:40 <Myrl-saki> ab9rf: [1..] is not a list, but rather syntactic sugar for..
11:34:43 <lambdabot>  "\"[1..]\""
11:34:45 <ab9rf> cocreature: i know
11:34:57 <Myrl-saki> I forgot what.
11:35:01 <ab9rf> my point is that it won't parse things ghc will
11:35:13 <kuribas> > read . show $ [1..]
11:35:17 <lambdabot>  *Exception: Prelude.read: no parse
11:35:23 <ab9rf> kuribas: you forgot to provide a type
11:35:33 <kuribas> > read . show $ [(1::Int)..]
11:35:37 <lambdabot>  *Exception: Prelude.read: no parse
11:35:46 <Myrl-saki> kuribas: That's actually interesting.
11:35:53 <kuribas> > read . show $ [(1::Int)..] :: [Int]
11:35:58 <ab9rf> you have to tell read what type it's reading
11:36:00 <lambdabot>  mueval-core: Time limit exceeded
11:36:02 <ab9rf> :t read . show
11:36:04 <Myrl-saki> kuribas: Yeah, that one works.
11:36:04 <lambdabot> (Show a, Read c) => a -> c
11:36:15 <ab9rf> it can't infer the result from the input
11:36:39 <kuribas> read isn't lazy...
11:36:44 <Myrl-saki> OTOH, why can't `read`, read that?
11:36:51 <mdim> Greetings everyone. Here's a Haskell rookie. I'm trying to set up a project with Stack that depends on distributed-process. GHC reports this error: cabal: Encountered missing dependencies: distributed-process -any, network-transport-tcp -any
11:36:53 <ab9rf> read is lazy, the problem is that show [1..] is bottom
11:37:11 <Myrl-saki> ab9rf: It's not.
11:37:18 <ab9rf> well, ueah
11:37:21 <Myrl-saki> > show [1..]
11:37:21 <ab9rf> it has to accept the parse
11:37:25 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:37:26 <mdim> Do I have to make it a very specific dependency version in package.yaml?
11:37:31 <ab9rf> which cannot be determined until the string terminates
11:37:33 <robstr> I have a Heap (from the heap package) and a special type as item, I want to modify one value inside this item (finding the item by the order value) is there a way of doing this ?
11:37:40 <ab9rf> and show [1..] is nonterminating
11:38:02 <Myrl-saki> ab9rf: kuribas: I think the answer is that `]` is required from `read`.
11:38:06 <Myrl-saki> s/from/by/
11:38:15 <kuribas> Myrl-saki: yes
11:38:18 <ab9rf> Myrl-saki: for the [Int] instance of read at least
11:38:19 <cocreature> mdim: no you need to add a specific version to the extra-deps section in your stack.yaml
11:38:19 <hyperisco> what I did not state, but assumed, is the equality used to say that  read . show = id
11:38:35 <Myrl-saki> ab9rf: `:: Read a => [a]` to be more general. :P
11:38:42 <ab9rf> Myrl-saki: i would imagine
11:38:46 <dminuoso> robstr: Im guessing that you want this as a mutable operation, right?
11:39:18 <hyperisco> which is  ∀x. (read . show) x == id x
11:39:26 <hyperisco> so now you are using the decidable list equality
11:39:40 <hyperisco> which is going to dislike your infinite lists
11:39:50 <kuribas> Myrl-saki: it must read it to the end to validate it.
11:39:57 <robstr> dminuoso: yea or replacing this (i think there is structure sharing, righ ? - I'm new to haskell)
11:40:15 <hyperisco> it is important to use this equality so that types like  Set a  have a chance
11:40:23 <hyperisco> or Rational
11:40:25 <cocreature> mdim: or use a stackage snapshot that contains the packages. it looks like lts 11.1 should probably have both of those
11:41:15 <mdim> cocreature: thanks, but I don't know what lts is, though in my stack.yaml I do have "resolver: lts-11.1"
11:41:36 <cocreature> mdim: huh weird, what exactly is the command that you’re running and what is the full error message?
11:42:50 <woodson> can anyone explain to me the difference between withText and withObject when defining FromJSON's parseJSON function
11:42:53 <cocreature> mdim: the resolver field specifies a snapshot of a subset of the packages on hackage and specific versions of those that are known together. lts stands for long term support. but it looks like I misinterpreted your error
11:43:18 <woodson> I think that i am not understanding how to use it properly
11:43:25 <cocreature> woodson: withText assumes that you’re parsing a string while withObject assumes that you’re parsing an object
11:44:04 <dyl> Man... when is Epic Rap Battles of History finally going to do Harper vs Wadler?
11:44:07 <mdim> Maybe it'd be easier this way: I'm trying to follow this tutorial - https://haskell-distributed.github.io/tutorials/1ch.html . How exactly do I achieve the following? "You’ll want to add distributed-process and network-transport-tcp to the build-depends stanza of the executable section."
11:44:24 <ab9rf> withObject means that you're going to deserialize something represented in JSON as an object
11:44:35 <ab9rf> withString means that you're going to deserialize something repersented in JSON as a strong
11:44:38 <ab9rf> string
11:44:53 <cocreature> mdim: just show us the command you ran and the full error message. It’s probably something trivial
11:44:55 <ab9rf> withText, sorry
11:45:19 <mdim> cocreature: hm, it's from within Emacs. Let me try to figure out what C-c C-l corresponds to...
11:45:48 <cocreature> mdim: try running "stack build" in a terminal instead
11:46:16 <MarcelineVQ> mdim: ^ in your project's directory
11:46:18 <cocreature> no idea what emacs does these days but it sounds like your emacs is trying to use raw ghci or cabal repl instead of stack ghci
11:46:29 <mdim> cocreature: MarcelineVQ: https://paste.debian.net/1015732/
11:46:59 <mdim> yeah, could be. I never finished setting up a Haskell IDE in Emacs so I believe this is a half-baked setup
11:46:59 <cocreature> mdim: do you have a package.yaml file?
11:47:44 <mdim> cocreature: here is my package.yaml: https://paste.debian.net/1015733/
11:48:16 <cocreature> mdim: alright, you need to add network-transport-tcp and distributed-process to the dependencies section of that file
11:48:49 <mdim> I had them there before :)
11:55:50 <mdim> thanks, cocreature
12:09:11 <dminuoso> Perhaps someone can give me a clue what I might be doing wrong. Im trying to build a project with a dependency on LDAP, but the dependency is failing to build: https://gist.github.com/dminuoso/c29d92f2c1ed74b63aab83d9f9469544
12:09:30 <dminuoso> Im a bit confused about what the cause might be here, especially since I managed to build another project against LDAP some weeks ago on the same machine.
12:10:35 <dminuoso> Even just a hint how to debug this would be helpful. =)
12:13:00 <simendsjo> It's a bit tedious to search Hayoo each time I need to look up documentation for some library function/type. Is there a better way of looking up the type from within the editor? I'm using emacs + intero.
12:13:50 <cocreature> dminuoso: the definitions should come from ldap.h afaict so I’d start looking there and see if there is a difference in that file on the two machines
12:14:14 <dminuoso> cocreature: A difference in that file on the same machine?
12:14:31 <cocreature> dminuoso: oh I somehow read “on the same machine” as “on another machine”
12:14:33 <cocreature> :)
12:14:50 <cocreature> well then check that you didn’t perform any upgrade affecting this
12:15:29 <guessWho> i'm stuck with this simple problem http://lpaste.net/363864
12:17:03 <guessWho> cocreature : u there ? stuck with a tiny problem
12:17:04 <dminuoso> cocreature: Thank you for the tip that was helpful. I deleted the .stack-work on the other project, rebuild it and it blew up the same way. Based on the fact that cabal-install is also failing to build this, Im guessing this might have been a cabal (the library) upgrade
12:19:13 <cocreature> guessWho: fwiw randomly pinging people to help you is slightly rude
12:19:34 <guessWho> cocreature : i'm sorry :(
12:20:04 <cocreature> unless your question requires some specific expertise that this person is likely to have but that doesn’t seem to be the case for your questions :)
12:20:26 <dminuoso> guessWho: And no you cannot. As this channel has been trying to tell you for two days, what you are trying to do conceptually does not work.
12:20:32 <cocreature> guessWho: also haven’t you asked that same question earlier today and have gotten quite a few answers?
12:21:04 <dminuoso> guessWho: I think you might want to get a introductory book on haskell that covers IO.
12:21:40 <dminuoso> Based on the history of the discussions and that your question indicates you didn't understand a bit of it.
12:22:08 <guessWho> cocreature : but i remember someone telling me it can be done and i thought i couldn't understand it , Okay now i guess it's clear it cant be done
12:22:33 <dminuoso> guessWho: _you_ cant perform IO actions. The runtime can.
12:22:50 <cocreature> guessWho: you can define an IO action in a where clause but you can’t turn an IO a into an a in a where clause just like you can’t do it anywhere else
12:23:00 <guessWho> dminuoso : yeah i do, i'm actually reading two books , learn you a haskell and real life haskell and guess what next chapter is about monoids and monads :)
12:23:43 <guessWho> cocreature : okay i think i got confused there , i wanted to bind the result to a var
12:23:52 <cocreature> @where io
12:23:52 <lambdabot> Raphael L. Levien's language with continuations as fundamental structure, described in his paper "Io: a new programming notation" (1989-09-10) at <http://dl.acm.org/citation.cfm?id=70931.70934> and
12:23:53 <lambdabot> in chapter 2 of Raphael A. Finkel's book `APLD', implementations `Amalthea',`Ganymede' - (perhaps you were looking for `@wiki Introduction to IO' ?)
12:23:56 <cocreature> meh
12:24:17 <cocreature> guessWho: if you’re trying to understand IO in Haskell, I recommend taking a look at https://www.vex.net/~trebla/haskell/IO.xhtml
12:26:22 <guessWho> cocreature : "you can’t turn an IO a into an a in a where clause just like you can’t do it anywhere else" what do mean by anywhere else i can do that with do right ?  like  do (a <- IO a) ??
12:26:35 <hololeap> is it possible to define an instance of Monoid for Fix? Monoid (f a) => instance Monoid (Fix f) where ...
12:27:11 <dminuoso> guessWho: I recommend you follow cocreature's recommendation.
12:27:22 <dminuoso> guessWho: It is expected of you, to take the time and study learning material you have been given.
12:27:26 <cocreature> guessWho: yeah read the link I send you. that explains it
12:28:34 <dminuoso> cocreature: Wow that link is actually really good =)
12:29:06 <cocreature> dminuoso: a significant portion of the questions here could be answered by just linking to one of monochrome’s articles :)
12:30:19 <guessWho> dminuoso : sorry if you feel like i'm just here for quick help and not going through material. Okay i'll go through the link
12:32:47 <cocreature> hololeap: Monoid (f a) doesn’t work, you need Monoid (f (Fix f))
12:33:30 <cocreature> hololeap: you can also make an implementation that typechecks using Applicative f => Monoid (Fix f) but I’m not sure if that actually does anything useful :)
12:33:55 <cocreature> at least mempty seems fishy for that
12:35:35 <jared-w> oh, monochrome wrote the "you could've invented fix" article? I love that one
12:36:30 <hololeap> cocreature: i had to turn on UndecidableInstances to get your first idea to work. anything wrong with that?
12:38:05 <cocreature> hololeap: UndecidableInstances turns off GHC’s termination checker for instances. the termination checker is quite dumb so it rejects a lot of cases that actually do terminate and in those cases turning on UndecidableInstances is perfectly reasonable. in the worst case, GHC will run into an infinite loop but you’ll notice that rather quickly :)
12:38:25 <cocreature> for this specific case it should probably be fine for most choices of "f"
12:38:35 <hololeap> cocreature: thank you
12:38:41 <jared-w> Yeah it's a pretty harmless pragma; needed for just about anything non-trivial in the type level world :p
12:38:53 <dminuoso> Worst case the type checker just loops.
12:38:53 <hololeap> it sounds scary
12:39:00 <dminuoso> Best case it doesn't.
12:40:20 <merijn> cocreature: GHC should still bail if typechecking cycles too long
12:41:30 <hololeap> i'm a little disappointed Fix doesn't come with more instances out of the box
12:41:53 <dminuoso> merijn: At the very least it should run out of stack space right?
12:42:01 <dminuoso> (And crash?)
12:42:13 <jared-w> That's the bailing part, iirc :)
12:42:25 <merijn> dminuoso: Well, undecidableinstances just says it will try to typecheck potentially non-terminating types
12:42:38 <merijn> dminuoso: But GHC still has a timeout/limit on how long it keeps checking
12:42:48 <dminuoso> Ah I see.
12:42:50 <merijn> dminuoso: So it shouldn't crash
12:42:55 <ab9rf> is running out of stack space like running out of snack space?
12:42:57 * ab9rf runs
12:43:47 <jared-w> hololeap: apparently there's a lot more instances for MonadFix
12:43:56 <hololeap> ab9rf: you have to enable UncontrollableDiarrhea for that to work
12:44:44 <guessWho> cocreature : thanks for the link it was good read :)
12:44:54 <ab9rf> hololeap: that's been my life the last few days, but that's probably TMI
12:45:36 <hololeap> ab9rf: stay hydrated :)
12:46:57 <cocreature> jared-w: MonadFix is a typeclass and Fix is a type and the two don’t have a lot to do with each other
12:48:54 <ab9rf> hololeap: nearly always sound advice :)
12:48:58 <jared-w> oh, doh, reading comprehension... *sigh*
12:50:07 <dx25> https://pastebin.com/LKeNXgA3
12:50:29 <dx25> one of these fib functions is supposed to be memoizing, and therefore much faster
12:50:39 <dx25> but they seem to take the same amount of time
12:50:58 <hololeap> actually, i could use Free in this case and get Alternative for free... i think that would make more sense
12:51:13 <dx25> i've run under ghci, and also compiled with ghc using -O, same behavior
12:51:40 <dx25> what am i missing here?
12:51:42 <jared-w> It looks like you accidentally pasted identical implementations of slowFib?
12:51:44 <sclv> dx25: neither of those memoizes as far as i can tell
12:51:46 <Tuplanolla> It's the same code, dx25.
12:51:50 <sclv> one of those is just eta expanded
12:52:52 <dx25> i was using this: https://stackoverflow.com/questions/11466284/how-is-this-fibonacci-function-memoized
12:52:59 <hololeap> it says in the docs that the Alternative instance for Free "violates the Alternative laws"... is that just referring to the laws for some and more?
12:56:52 <dx25> maybe i need to try his suggested rewrites half way down
12:57:06 <merijn> hololeap: There's also the law that empty is left and right identity for <|>
12:58:21 <dx25> hmm and maybe i need -O2
12:59:59 <dx25> -O2 didn't matter.
13:00:29 <hyperisco> a <*> b <|> a <*> c = a <*> (b <|> c)  is a nice distributive property but we don't have a class for it afaik
13:01:05 <cocreature> dx25: take a closer look at the definitions. fib' calls fib not fib' in the recursive case
13:01:10 <ab9rf> i don't understand Free
13:01:24 <hyperisco> Free as in freedom
13:01:49 <jared-w> dx25: take out the type signatures and benchmark again :)
13:02:29 <jared-w> ab9rf: Free the datatype or Free the concept?
13:03:14 <dx25> cocreature, shit thanks.
13:05:14 <dx25> huh.  now they're both screaming fast.
13:05:18 <ab9rf> jared-w: i'm not sure :)
13:05:29 <ab9rf> jared-w: i think i need more coffee, though
13:05:44 <cocreature> ab9rf: coffee or cofree
13:06:04 <jared-w> ab9rf: Free is a datatype in Haskell, however it's modeled after the category theory concept of that something can be a 'free x'
13:06:14 <spades> Is this also the channel to get beginner help in? Or is there a more suitable channel for that?
13:06:28 <dminuoso> spades: This channel is fine, but we also have #haskell-beginners
13:06:46 <jared-w> However most of us frequent both channels so you'll get about the same amount of help either way :p
13:07:10 <dx25> ah, i should probably head over there too
13:07:52 <spades> Great, thanks :)
13:08:27 <merijn> I don't suppose anyone knows how I can tell new-build to only build docs for library parts?
13:09:08 <jared-w> `echo "hey new-build can you do me a solid and only build docs for, like, the library stuff?" | cabal new-build` didn't work?
13:09:10 <cocreature> merijn: iirc you can pass it a component. does that not work?
13:09:17 <Psybur__> Which patterns can I match on with "runFree $ liftF (+1)" ?
13:09:20 <hololeap> ab9rf: it's for building free monads, which is basically a way to "hack" a Monad together using just a Functor
13:09:27 <Psybur__> :t runFree $ liftF(+1)
13:09:30 <lambdabot> error:
13:09:30 <lambdabot>     Variable not in scope: runFree :: m0 Integer -> t
13:09:37 <merijn> cocreature: When I do "cabal new-haddock mypackage" it tries to build both test and library docs
13:09:39 <Psybur__> :t runFreeT $ liftF(+1)
13:09:41 <lambdabot> error:
13:09:41 <lambdabot>     Variable not in scope: runFreeT :: m0 Integer -> t
13:09:46 <merijn> cocreature: mypackage:lib also seems to not work
13:09:58 <jared-w> Psybur__: lambdabot probably doesn't have the Free library in scope
13:10:04 <cocreature> hm I thought the second worked, apparently I’m wrong :/
13:10:09 <Psybur__> @let import Control.Monad.Trans.Free
13:10:13 <lambdabot>  Defined.
13:10:15 <Psybur__> :t runFree $ liftF(+1)
13:10:17 <lambdabot> Num a => FreeF ((->) a) a (Control.Monad.Trans.Free.Free ((->) a) a)
13:10:17 <merijn> cocreature: Just produces unknown target
13:10:18 <hololeap> ab9rf: the Free constructor wraps around the functor, and the Pure constructor gives a way to simulate `return`
13:10:23 <hyperisco> I once made a monad with just a dirty needle and some rope
13:10:30 <merijn> cocreature: And I can't figure out whether it's Cabal crashing or haddock :\
13:10:46 <Psybur__> Im just at a loss for how I would run that through a pattern matcher
13:10:47 <merijn> I seem to have ruled out cabal-install
13:11:31 <hyperisco> Psybur__, well first you pattern match on FreeF and go from there
13:11:44 <jared-w> Psybur__: try writing out the arrows in infix notation and see if that helps?
13:12:00 <Psybur__> Lets say I want to create an interpreter that just composes the functions.  So if I passed it liftF(+1) >> liftF(*2), I would want it to give me (+1) . (*2)
13:13:04 <Psybur__> Actually I dont even know if >> will "wrap" them up like that because the type doesnt help :D
13:13:08 <phadej> Psybur__: Free can be used for that, but not directly
13:15:09 <phadej> > appEndo (getDual $ execWriter $ tell (Dual $ Endo (+1)) >> tell (Dual $ Endo (*2))) 5
13:15:13 <lambdabot>  12
13:15:15 <jared-w> merijn: just out of curiosity, would making a blank cabal project with that one library dependency and then building all the docs for that narrow the issue down any?
13:15:52 <phadej> > appEndo (execWriter $ tell (Endo (+1)) >> tell (Endo (*2))) 5
13:15:55 <lambdabot>  11
13:15:58 <phadej> works too, but is different
13:16:21 <phadej> Free needs auxiliary Functor to do something like that
13:17:18 <merijn> jared-w: It's already it's own project?
13:17:51 <merijn> jared-w: I'm trying to build the docs for this 1 project, it's just that Cabal and/or cabal-install keeps barfing on the tests of the project for some weird reason
13:18:39 <jared-w> Oh, I see. I suppose commenting out all of the tests and then seeing if that works; then commenting everything else and trying out only the tests... Unless I'm totally missing what exactly is breaking :p
13:18:55 <merijn> jared-w: cabal is crashing
13:19:55 <jared-w> Does it crash even on a hello-world project? o.O
13:20:21 <merijn> No, it's barfing on some broken invariant, but I can't figure out where in the code it barfs
13:21:05 <jared-w> ah, I see, that sucks. I haven't had to deal with that sort of thing very often since I started using stack tbh; I guess binary search commenting out of stuff would work, but that's still a pain
13:21:25 <lavalike> what is the combinator that does this:
13:21:27 <Psybur__> So yeah Im guessing Im way off base? At the very least I cant get past the pattern match for the Free case heh https://glot.io/snippets/ezcqx8qp4x
13:21:28 <lavalike> :t \f g h -> do { x <- g; y <- h; f x y }
13:21:31 <lambdabot> Monad m => (t1 -> t2 -> m b) -> m t1 -> m t2 -> m b
13:21:42 <lavalike> :t liftM2 -- this is almost it
13:21:42 <merijn> jared-w: Well, the problem is probably related to using HEAD, but someone has to take one for the team
13:21:45 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:22:02 <jared-w> lavalike: is that not just <*> ?
13:22:14 <Tuplanolla> I wrote that in Idris just today, lavalike.
13:22:20 <lavalike> :t \f g h -> f <*> g <*> h
13:22:22 <lambdabot> Applicative f => f (a1 -> a2 -> b) -> f a1 -> f a2 -> f b
13:22:23 <lavalike> not exactly
13:22:24 <dminuoso> cocreature: In case you are curious, I followed the compilation process. With -v3 I noticed a pecularity, apparently there was was a local library that provided its own (weird) ldap.h which masked my /usr/include/ldap.h - thank you again for the help. :)
13:22:30 <lavalike> or I'm missing something
13:22:37 <Tuplanolla> :t (fmap . fmap) join . liftA2
13:22:39 <lambdabot> Monad m => (a1 -> b -> m a2) -> m a1 -> m b -> m a2
13:22:44 <jared-w> oh right, you're wanting the -> m b thing
13:22:57 <lavalike> yes!
13:23:05 <jared-w> :t fmap <$> join <*>
13:23:07 <lambdabot> error:
13:23:07 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
13:23:14 <jared-w> I didn't really expect that to work...
13:23:29 <lavalike> hehe, joining at the end kind of does it
13:23:31 <Tuplanolla> With indexed families we would have `bindN n = fmapN n join . liftAN n`.
13:23:41 <dminuoso> :t fmap fmap fmap join . liftA2
13:23:43 <lambdabot> Monad m => (a1 -> b -> m a2) -> m a1 -> m b -> m a2
13:23:52 <jared-w> lol
13:23:56 <lavalike> beautiful
13:24:09 <jared-w> fmap; the haskell equivalent of buffalo
13:24:31 <dminuoso> I guess ideally this would be:
13:24:32 <lavalike> dminuoso uses every part of the fmap
13:24:34 <dminuoso> :t fmap fmap fmap join `fmap` liftA2
13:24:36 <lambdabot> Monad m => (a1 -> b -> m a2) -> m a1 -> m b -> m a2
13:25:33 <dminuoso> lambdabot: I think this was one of my best early revelations. It helped me understand `(.) . (.)` :)
13:25:44 <lavalike> so fmap travels into the two arguments and then the monad and squishes with join
13:25:46 <jared-w> and liftA2 f a b = f <$> a <*> b yes?
13:25:58 <dminuoso> lavalike: No Im just abusing the fact that `fmap` for functions is just (.)
13:26:28 <lavalike> yeah that's how you're getting to the end result I mean, by "travels into the arguments"
13:27:08 <Welkin> travels through space-time?
13:27:11 <hyperisco> :t fmap `id` fmap fmap fmap join `id` liftA2
13:27:13 <lambdabot> Monad m => (a1 -> b -> m a2) -> m a1 -> m b -> m a2
13:27:29 <hyperisco> using the no-paren style
13:27:35 <lavalike> :t \f -> join (\g h -> liftM2 f g h)
13:27:38 <lambdabot> Monad m => (a2 -> a2 -> r) -> m a2 -> m r
13:27:43 <lavalike> hmmm not quite
13:27:43 <Tuplanolla> I can go deeper. Give me a minute.
13:27:45 <Welkin> what are you up to this time hyperisco ?
13:28:02 <dminuoso> lambdabot: at the core is just the `(.) . (.)` combinator, which is functional composition but into the second argument
13:28:02 <lavalike> :t \f g h -> join $ liftM2 f g h
13:28:05 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
13:28:24 <dminuoso> err lavalike ^-
13:28:37 <lavalike> that's what the fmap fmap fmap is doing, right
13:28:39 <jared-w> :t \f g h -> join $ f <$> g <*> h
13:28:41 <lambdabot> Monad m => (a1 -> a2 -> m a3) -> m a1 -> m a2 -> m a3
13:28:44 <jared-w> aww yiss
13:28:49 <dminuoso> lambdabot: even the (fmap . fmap)
13:29:00 <lavalike> sure, as you said fmap and (.) are interchangeable
13:29:01 <Welkin> dminuoso: I think you mean lavalike
13:29:06 <dminuoso> :t ((.) . (.)) join . liftA2
13:29:08 <lambdabot> Monad m => (a1 -> b -> m a2) -> m a1 -> m b -> m a2
13:29:21 <Tuplanolla> :t fmap `id` fmap fmap fmap join `id` fmap ap `fmap` fmap ap pure
13:29:21 <Welkin> lavalike: they are only interchangeable for function type ((->) a)
13:29:23 <lambdabot> Monad m => (a1 -> a2 -> m a3) -> m a1 -> m a2 -> m a3
13:29:35 <jared-w> Tuplanolla: noice
13:29:37 <Tuplanolla> We could stop here.
13:29:54 <lavalike> Welkin: I understand
13:30:02 <jared-w> needs more ascii symbols
13:30:20 <hyperisco> we should have a bot converter for parens
13:30:40 <hyperisco> by @lisp and @delisp
13:31:40 <pmade> What tools are people using to help them maintain packages? (e.g., automatic bounds updating, compiling with all compilers in the tested-with cabal field, etc.)
13:32:01 <jared-w> pmade: heh, I don't think a lot of people do much of any of that tbh
13:32:25 <merijn> pmade: Travis CI for testing compilers
13:32:28 <pmade> jared-w: that's not the answer I was looking for ;)
13:32:55 <merijn> pmade: Have a lookt at https://github.com/haskell-CI/haskell-ci
13:33:02 <pmade> Okay, well, I guess I will next extend my nix-hs tool for this.
13:33:09 <pmade> merijn: thanks.
13:33:21 <merijn> pmade: That's a script for generating travis CI tests from your tested-with field
13:33:58 <jared-w> But the general answer is going to be: bounds updating involves grid testing and being either conservative but computationally expensive or heuristically sound and saving computation time; compiling with compilers would be done with an army of CI bots, etc
13:34:03 <dminuoso> Cool. So people really do write their "scripts" in Haskell too =)
13:34:14 <dminuoso> merijn: Thanks, been waiting for examples like this.
13:34:14 <Psybur__> So in the case of Pure r | Free (f b), in the Free case, how do I get the (->) and the "next" value?
13:34:24 <jared-w> of course; haskell is the best imperative language :p
13:34:24 <merijn> dminuoso: tbh, I still use cabal to build that
13:35:44 <merijn> dminuoso: dminuoso But it's very nice if you wanna test stuff based on your cabal file without figuring out how Travis CI works :)
13:51:54 <hololeap> > \f g h -> f <$> g <*> h
13:51:57 <lambdabot>  error:
13:51:57 <lambdabot>      • No instance for (Typeable f0)
13:51:58 <lambdabot>          arising from a use of ‘show_M790605616885265260629203’
13:52:20 <hololeap> :t \f g h -> f <$> g <*> h
13:52:23 <lambdabot> Applicative f => (a1 -> a2 -> b) -> f a1 -> f a2 -> f b
14:00:55 <w1n5t0n> why can't intero seem to find Control.Monad.Reader even though I've run "stack install mtl"?
14:01:33 <jared-w> stack has no equivalent command to 'npm add x', unfortunately
14:01:47 <jared-w> Essentially, stack install didn't do what you think it did :p
14:02:07 <jared-w> I'd run `stack uninstall mtl` and then edit your package.yaml file and add in `mtl` to the dependencies list near the top of the file
14:02:16 <jared-w> then a simple `stack build` should work fine
14:03:57 <w1n5t0n> jared-w: thanks, when I add dependencies to the package.yaml file do they have to be added under executable and install dependencies as well?
14:04:28 <jared-w> not if they're in the common block (the first 'dependencies' list)
14:05:15 <jared-w> stack really needs a `stack add X` command, honestly...
14:05:28 <Psybur__> So If I do liftF (*1) >> liftF(+2), I cant really use the standard way of pattern matching on Free/Pure to compose them since (->) has no way of capturing the "next" step?
14:05:29 <Welkin> or you could just not use stack
14:05:45 <MarcelineVQ> "<jared-w> stack really needs a `stack add X` command, honestly..." what does it do?
14:05:57 <jared-w> Does cabal have a 'cabal add x' command that automatically does the correct thing to your cabal-file?
14:06:25 <Welkin> jared-w: no, you just add it to your cabal file as a dependency and type `cabal install`
14:06:35 <jared-w> MarcelineVQ: I wouldn't mind if it ripped the semantics straight from yarn's 'add' command. That is, add a dependency to the global dependency list in your package.yaml file
14:06:40 <Psybur__> Theres no way to get from (*1) to (+2) is there in the "Free ((->) a)" pattern is there
14:06:56 <Welkin> you can add local sources using `cabal add-source` (for local packages not on hackage)
14:07:13 <jared-w> Welkin: the lack of a way to add a dependency straight from the CLI is the entire feature I'm bemoaning the lack of :p
14:07:19 <MarcelineVQ> imo stack already does way too many jobs at once <_<
14:07:45 <MarcelineVQ> but a utility to modify cabal files from cli would be interesting
14:07:47 <Welkin> I don't think anyone should take lessons from the javascript ecosystem
14:07:53 <Welkin> it is messed up enough as it is
14:08:15 <jared-w> It wouldn't be adding any new jobs. "depndency management" is essentially what stack is; doing that from the CLI isn't really any horrendous amount of feature-creep...
14:08:40 <MarcelineVQ> no feature on its own is feature creep :> it's when you start to tally them up
14:08:59 <jared-w> Welkin: In general, I agree; however, web-dev package mangaers are generally very well designed (due to how god awful their package ecosystem tends to be)
14:09:38 <Welkin> jared-w: npm is an abomination
14:10:01 <jared-w> That being said, I also wouldn't mind if stack was a bit more clear about what 'stack install' does... It's far too easy to think it'll do the same thing that 'npm install --save' does
14:10:09 <Welkin> one person can break millions of people's projects
14:10:11 <Welkin> and this has happened
14:10:14 <Welkin> remember left-pad?
14:10:28 <jared-w> Of course
14:10:41 <Welkin> stack install is an alias for `stack build --copy-executable`
14:10:41 <jared-w> Not sure how this has to do with 'stack add x' being a terrible idea, though :p
14:10:44 <Welkin> or whatever the flag is
14:11:02 <MarcelineVQ> all you have to do to find out what stackk install does is ask stack. stack install --help
14:12:09 <MarcelineVQ> more probably the issue is how does stack manage packages and what is a snapshot, these are the questions you need the answer to to understand stack install
14:12:17 <jared-w> MarcelineVQ: right, but there's zero indication if you don't specifically type --help. Given that stack is specifically beginner friendly and that this is a very common beginner tripup, it makes sense to at least print a message along the lines of "x has been put into your local path. This does not automatically make the library available to a stack project" or something along those lines
14:12:35 <MarcelineVQ> all you can do as someone on the outside is link the relevant docs to people that haven't bothered to look at them first
14:12:57 <jared-w> but eh, I'm probably bikeshedding a problem that doesn't really need a solution here, tbh
14:13:30 <MarcelineVQ> I don't consider stack especially begginner friendly, but cabal isn't really either, there's lots of parts to a haskell project, and docs are made to be read :X
14:14:03 <lavalike> Welkin: I understand
14:14:10 <lavalike> oops wrong window, sorry
14:14:42 <jared-w> True. Although, in all honesty, I don't even think stack install needs to be a thing at all. It's just an alias and the people that understand what it does know how to use the right command and those that don't are the ones that will use `stack install` wrong ¯\_(ツ)_/¯
14:16:27 <MarcelineVQ> That's right, and they've already skipped the part where they do the research on their own. Is bloating stack to handle those people the better solution compared to educating them? Not to me
14:16:28 <Welkin> yarn is hardly better than npm. It uses npm, but has a file that specifies version numbers
14:17:16 <Welkin> stack was made by a company for their own use case, and it worked for them, so they released it
14:17:24 <Welkin> it is not meant for everyone and every project
14:18:16 <Welkin> jared-w: stack is not beginner friendly and I have stopped recommending it to beginners
14:18:26 <fakenullie> Welkin: what happens if someone decides to remove all her packages from stackage/hackage?
14:18:36 <Welkin> because they get very confused about what it is actually doing. It is just magic to them. They need to start with understanding cabal
14:18:42 <fendor> Morning, when using criterion on nixos and stack and try to benchmark via `stack bench` it fails with `ffp-reloaded-benchmarks: <stdout>: commitBuffer: invalid argument (invalid character)`. did i miss some libraries that I have to add to stack.yaml?
14:18:55 <Welkin> fakenullie: stackage, no idea. That is closed. You cannot, afaik remove packages from hackage
14:24:20 <sm> fendor: that's often caused by processing non-ascii data without having a locale configured
14:25:09 <Tuplanolla> Are the package sets on Stackage tested to see if they build together?
14:25:44 <fendor> sm, i wouldnt expect non-ascii data so far, however, how can i check if the locale is set?
14:26:23 <sm> echo $LANG, see if it's set to something other than C
14:26:25 <comerijn> fendor: run "locale" in your shell
14:27:00 <MarcelineVQ> Tuplanolla: mostly and ideally, but there's still errors that crop up from time to time
14:28:03 <Tuplanolla> I was wondering if it's my fault that Hakyll hasn't worked since LTS 10 was first released.
14:28:15 <fendor> merijn, dont think that would be helpful, the execution will be in a nix-shell. However, in my shell the output is:https://hastebin.com/ulagezunup.makefile
14:29:01 <merijn> fendor: LC_ALL not being set is a bad sign
14:29:15 <fendor> :(
14:29:18 <merijn> fendor: set it to en_US.UTF-8
14:30:10 <sm> merijn: my locale output looks like fendor's (LC_ALL blank), and works ok
14:30:39 <sm> but yes, you need to check the environment in which this error is actually occuring
14:31:15 <ddellacosta> is there formal language to talk about a fold/computation where a left fold will yield different results than a right fold? Vs. computations that produce identical results no matter the direction?
14:31:38 <Tuplanolla> Associativity comes to mind, ddellacosta.
14:31:53 <ddellacosta> Tuplanolla: that seems like a good thread for me to pull, definitely, thank you
14:32:05 <Tuplanolla> That's why monoids have only one canonical fold.
14:32:07 <fendor> merijn, sm, when executing in a nix-shell, the output is the same
14:32:23 <fendor> maybe i am going to ask in the nixos channel, too
14:32:55 <sm> ok, perhaps not the cause then
14:33:15 <sm> try to reproduce it by hand
14:33:22 <sm> good luck
14:33:25 <fendor> hehe :D
14:33:49 <ddellacosta> Tuplanolla: thanks, that's super helpful. I've been spending so much time reading about recursion schemes lately that I wasn't thinking about this in simpler terms
14:33:53 <fendor> people on the lenovo forum told me the same when i asked them for help with the bios update :D
14:33:59 <fendor> just good luck
14:34:03 <fendor> lovely people
14:34:12 <fendor> without sarcasm
14:34:31 <sm> Tuplanolla: what's wrong with your hakyll ?
14:35:13 <Tuplanolla> Linking errors and memory usage problems, sm.
14:35:40 <sm> ouch
14:35:52 <merijn> hmmm, what's the best way to deal with Semigroup in base 4.11? conditional dependency on semigroups?
14:36:09 <sm> tried the latest, 4.12.01 ?
14:36:10 <fendor> sm, hm, when executing the binary directly, it seems to work
14:43:00 <merijn> PVP question: Does adding a non-orphan instance for an unexported datatype mean I have to bump C in A.B.C or can I only bump to A.B.C.1
14:47:17 <glguy> merijn: I think it depends what you're doing with that type. If you expose values of that type but not the type itself then it's the case that your new instance won't conflict with other people's orphans, but someone else could access this new instance and would therefore want to express that dependency in their version bounds
14:47:19 <MarcelineVQ> that's a really interesting question after looking at the pvp
14:47:34 <merijn> glguy: I don't ever expose the type at all
14:47:37 <glguy> and in that case you'd want to bump C
14:47:38 <merijn> glguy: Or it's values
14:47:50 <glguy> but if no one can observe the type or any values of it then it wouldn't matter
14:47:52 <Tuplanolla> I'd bump the smallest of the values, merijn.
14:48:09 <Tuplanolla> It's not observable, as you say.
14:48:36 <Welkin> player-vs-player?
14:48:47 <merijn> Welkin: Package Versioning Policy
14:48:50 <glguy> programmer vs programmer
14:49:03 <jared-w> PvP is Sem-Ver but more confusing
14:49:23 <Welkin> oh, the one listed in the cabal templates
14:49:39 <glguy> https://pvp.haskell.org
14:50:38 <merijn> jared-w: I think you mean SemVer, but with actual semantics
14:51:14 <jared-w> with SVP all potential ambiguities are checked at run-time; it's far superior in that you can just do what you want and it works /s
14:53:31 <merijn> :\
14:53:36 <merijn> haddock and cabal are lying to my face
14:54:28 <Tuplanolla> I don't understand why it has to be done in such a complicated fashion. Would the following not suffice? "When a change is made, bump the major version number if backwards compatibility breaks, bump the minor version number if forwards compatibility breaks or bump the revision number otherwise."
14:55:16 <merijn> Tuplanolla: Except that leaves ambiguous what "backwards compatibility breaks" means
14:56:23 <Ferdirand> what happens when breaking backwards compatibility is a consequence of fixing a security issue ?
14:56:33 <w1n5t0n> if I want all computations in a block to be able to read a context (without modifying it) and then log themselves (in separate context?), should I use state monad or a combination of reader/writer?
14:56:33 <lyxia> If you fix a performance bug you break compatibility for those who relied on your program being slow.
14:56:49 <Tuplanolla> Here's a simple definition, merijn. "Any existing code depending on the package will not be able to observe the change."
14:56:57 <merijn> Ferdirand: You still bump
14:57:14 <merijn> Tuplanolla: That's false in a huge number of cases currently not requiring a bump, though
14:57:28 <merijn> Tuplanolla: i.e. lyxia's joke about performance improvements being breaking
14:58:03 <Tuplanolla> You just need a suitable model for observation, which is what physicists have been working on for centuries.
14:58:30 <merijn> The current PVP however is perfectly unambiguous in "that's not a breaking change"
14:58:43 <Welkin> https://xkcd.com/1172/
14:59:44 <lyxia> w1n5t0n: reader + writer, but use state instead of writer because writer's performance sucks.
15:00:25 <lyxia> Hahaha Welkin
15:01:40 <Tuplanolla> Although I'm half-joking, I do like Wirth's compiler construction philosophy, which can be crudely summarized as "simple is better than good".
15:01:42 <w1n5t0n> lyxia: so if I have a function that returns a ReaderT now, and I want the same function to log one of its arguments in the overal log, what should it return?
15:03:22 <centril> Does anyone know which paper introduced the concept of 'associated type' ?
15:03:43 <Welkin> centril: the one on type families?
15:03:43 <lyxia> w1n5t0n: if you're stacking more than one effect, consider using mtl's classes. So functions would look like ((MonadReader r m, MonadState s m) => X -> Y -> m Z)
15:03:53 <centril> Welkin: got a link per any chance?
15:03:54 <Welkin> I found a paper on that by searching for "haskell associated type"
15:04:02 <Welkin> I don't have the link
15:04:13 <fresheyeball> hey there
15:04:18 <merijn> hmmm
15:04:29 <fresheyeball> so the applicative instance for list
15:04:38 <merijn> If I build new docs locally they don't seem to match the new Hackage CSS? What gives?
15:04:48 <fresheyeball> > (,) <$> [0..5] ['a'..'f']
15:04:51 <lambdabot>  error:
15:04:51 <lambdabot>      • Couldn't match expected type ‘[Char] -> f a’
15:04:51 <lambdabot>                    with actual type ‘[Integer]’
15:05:05 <fresheyeball> > (,) <$> [0..5] <*> ['a'..'f']
15:05:07 <lambdabot>  [(0,'a'),(0,'b'),(0,'c'),(0,'d'),(0,'e'),(0,'f'),(1,'a'),(1,'b'),(1,'c'),(1,...
15:05:22 <fresheyeball> it gives every permutation so the results we get are
15:05:32 <fresheyeball> length firstList * length secondList
15:05:47 <fresheyeball> what if I want addition?
15:06:09 <merijn> fresheyeball: You mean pairwise combination?
15:06:20 <fresheyeball> > (,) <$> ZipList [0..5] <*> ZipList ['a'..'f']
15:06:23 <lambdabot>  ZipList {getZipList = [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f')]}
15:07:04 <jared-w> That's not length firstList + length secondList, though
15:07:07 <fresheyeball> that gives a result with the length of the shorter list
15:07:11 <fresheyeball> > (,) <$> ZipList [0..5] <*> ZipList ['a'..'c']
15:07:14 <lambdabot>  ZipList {getZipList = [(0,'a'),(1,'b'),(2,'c')]}
15:07:57 <jared-w> What cannonical construction can you think of that would combine two lists in a way that the length was always list a + list b?
15:07:59 <fresheyeball> so with regular list we get `length x * length y`, and with ZipList we get `if length x < length y then length x else length y`
15:08:13 <fresheyeball> I would like this
15:09:48 <fresheyeball> (,) <$> Magic [0..5] <*> Magic ['a'..'c'] = Magic [(0, 'a'), (0, 'b'), (0, 'c'), (1, 'a'), (2, 'a'), (3, 'a'), (4, 'a'), (5, 'a')]
15:10:24 <fresheyeball> Maybe applicative is the wrong way to get this
15:10:39 <merijn> fresheyeball: Well, that definitely does not follow the laws, so yes
15:10:42 <fresheyeball> but I am curious if everyone has information on the right way to do such a combination
15:10:48 <jared-w> > (,) <$> [0,1] <*> ['a'..'c']
15:10:51 <lambdabot>  [(0,'a'),(0,'b'),(0,'c'),(1,'a'),(1,'b'),(1,'c')]
15:11:09 <jared-w> ooh I see what you want now
15:11:27 <fresheyeball> yeah... I can write it by hand, but I suspect there is a cool Haskelly way to do it
15:12:46 <jared-w> fmap f x xs ++ fmap f y ys would be the cool Haskelly way to do it (where f a = (,) a )
15:13:30 <mtjmullen> or just (,) with TupleSections
15:13:30 <jared-w> > fmap ((,) 0) ['a'..'f']
15:13:33 <lambdabot>  [(0,'a'),(0,'b'),(0,'c'),(0,'d'),(0,'e'),(0,'f')]
15:13:34 <etalecohomology> hi
15:14:06 <mtjmullen> hello
15:14:37 <jared-w> > fmap (flip (,) 'a') [0..5]
15:14:40 <lambdabot>  [(0,'a'),(1,'a'),(2,'a'),(3,'a'),(4,'a'),(5,'a')]
15:14:42 <fresheyeball> jared-w: that doesnt work, what if one of the lists is empty?
15:15:19 <jared-w> > fmap ((,) 0) [] -- hmm
15:15:23 <lambdabot>  []
15:15:32 <jared-w> Does that not work?
15:15:53 <fresheyeball> we should have a function `g :: (a -> b -> c) -> [a] -> [b] -> [c]` where `length xs + lenght ys = length (g xs ys)`
15:16:15 <fresheyeball> hard coding a combination value is not what I am after
15:17:07 <fresheyeball> sorry I should say `length xs + length ys = length (g (,) xs ys)`
15:17:25 <fresheyeball> for `g :: (a -> b -> c) -> [a] -> [b] -> [c]`
15:17:54 <jle`> can you wrte it from scratch so i know what it is exatly?
15:18:02 <jared-w> right, I'm just saying that  g a b = fmap ((,) head a) b ++ fmap (flip (,) head b) a is probably not going to do what you want for all cases and that's basically by necessity
15:19:09 <jared-w> for one, you won't have a single f that'll do `(,) head a` and `flip (,) head b` and you won't have a total function
15:19:31 <etalecohomology> I try to use GHC.Generics and Data.Binary to automatically get an instance declaration of Data.Binary for a structure, whose first element is an UArray (Int, Int) Foo, where Foo ist some enum;
15:20:07 <fresheyeball> sec
15:20:10 <jared-w> You'll need to either hardcode the behavior to some extent and even then you'll still wind up needing a fairly long and manually written out function that'll pattern match on empty lists to have "sensible" total behavior
15:23:16 <etalecohomology> I already did derive(Generic) and "instance Binary TheEnum" for the enum, but the "instance Binary" for the structure fails with some funny error I don't understand
15:23:32 <Tuplanolla> The problem is that, while ordinary zips are intersection-like, union-like zips require some kind of ambient space.
15:23:42 <Tuplanolla> > on zip cycle "abcdef" "xyz" -- Here is one choice.
15:23:46 <lambdabot>  [('a','x'),('b','y'),('c','z'),('d','x'),('e','y'),('f','z'),('a','x'),('b',...
15:23:53 <jle`> etalecohomology: what is the error?
15:23:55 <etalecohomology> No instance for (Data.Array.Base.IArray UArray BoxState)
15:23:57 <Tuplanolla> > on zip (++ repeat '-') "abcdef" "xyz" -- Here is another.
15:24:00 <lambdabot>  [('a','x'),('b','y'),('c','z'),('d','-'),('e','-'),('f','-'),('-','-'),('-',...
15:24:04 <etalecohomology>           arising from a use of ‘binary-0.8.3.0:Data.Binary.Class.$dmput’
15:24:24 <etalecohomology> but BoxState is already Binary + Generic
15:24:36 <jle`> yes, it's not complaining about binary or generic
15:24:41 <fresheyeball> > let h f (x:xs) (y:ys) = fmap (f x) (y:ys) ++ fmap (flip f y) (x:xs); h _ _ _ = []
15:24:42 <jle`> it's complaining about an IArray instance
15:24:44 <lambdabot>  <no location info>: error:
15:24:44 <lambdabot>      not an expression: ‘let h f (x:xs) (y:ys) = fmap (f x) (y:ys) ++ fmap (f...
15:25:22 <fresheyeball> jared-w: there it is, but I don't know how to record it in lambdabot
15:25:33 <etalecohomology> jle`: what do you mean by that? how does IArray comes into play?
15:26:07 <jle`> that's what the error says
15:26:15 <jle`> "No Instance for IArray UArray BoxState"
15:26:19 <fresheyeball> @let h f (x:xs) (y:ys) = fmap (f x) (y:ys) ++ fmap (flip f y) (x:xs); h _ _ _ = []
15:26:22 <lambdabot>  Defined.
15:26:26 <Tuplanolla> That'll break.
15:26:33 <jle`> etalecohomology: for example, "No instance for Show Foo" means that Foo does not have a Show instance
15:26:40 <fresheyeball> > h (,) [1..5] ['a'..'c']
15:26:43 <lambdabot>  error:
15:26:43 <lambdabot>      Ambiguous occurrence ‘h’
15:26:43 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.h’,
15:27:03 <Tuplanolla> > let h f (x : xs) (y : ys) = fmap (f x) (y : ys) ++ fmap (flip f y) (x : xs); h _ _ _ = [] in h (,) "abcdef" "xyz"
15:27:05 <lambdabot>  [('a','x'),('a','y'),('a','z'),('a','x'),('b','x'),('c','x'),('d','x'),('e',...
15:27:18 <jle`> etalecohomology: the generics-based instance uses the binary instance of all of the type's contents
15:27:21 <Welkin> WHAT HAPPENED TO HACKAGE!?!?!
15:27:28 <Welkin> WHY IS EVERYTHING A SHADE OF PURPLE?
15:27:38 <jle`> etalecohomology: but UArray (Int, Int) Foo does not have a Binary instance
15:27:39 <Welkin> ah!!!!
15:27:43 <Welkin> the new layout is terrible
15:27:58 <Welkin> why is all the important information squashed into a tiny column on the right?
15:28:18 <jle`> etalecohomology: check out the instances listed in http://hackage.haskell.org/package/binary-0.8.5.1/docs/Data-Binary.html#t:Binary
15:28:20 <Welkin> and what the FUCK is with the terrible super-thin font?
15:28:27 <Welkin> that is nearly unreadable
15:28:29 <Welkin> god damn it
15:28:31 <Welkin> change it back
15:28:32 <jle`> etalecohomology: and you can see why UArray (Int, Int) Foo does not have a Binary instance
15:28:59 <Welkin> WHO MESSED UP HACKAGE?
15:29:11 <CodeKiwi> if you shrink your browser it's at the top
15:29:12 <Welkin> with this god-awful hipster design?
15:29:20 <etalecohomology> jle`:  (Binary i, Ix i, Binary e, IArray UArray e) => Binary (UArray i e)
15:29:50 <ggVGc> Welkin: looks fine to me? https://i.imgur.com/j6UyNHR.png
15:29:54 <etalecohomology> jle`: can I make my own type an instance of IArray UArray e?
15:30:08 <etalecohomology> jle`: I don't want to write any code ;-)
15:30:09 <Welkin> ggVGc: that is the problem
15:30:13 <Welkin> terrible layout, unreadable font
15:30:14 <Welkin> wtf
15:30:22 <ggVGc> I mean, the font is very readable for me
15:30:26 <ggVGc> is it showing you the same font?
15:30:30 <Welkin> whoever designed that has no clue what they are doing
15:30:35 <Welkin> ggVGc: yes
15:30:49 <Welkin> the old layout was perfectly fine
15:30:54 <Welkin> this is a huge step backwards
15:31:01 <ggVGc> isn't it the same font as in the documentation pages? (which haven't changed)
15:31:24 <Welkin> who did this?
15:31:26 <Tuplanolla> At least the site still passes WCAG AAA, Welkin.
15:31:39 <jle`> etalecohomology: you do have to, because it's kinda how we handle unboxed types
15:31:48 <fresheyeball> jared-w: I really want that behavior in an applicative instance so I can use it with traverse.
15:31:58 <Welkin> Tuplanolla: well it fails the msot basic usability and accessibility standards
15:32:02 <Welkin> most basic*
15:32:18 <Tuplanolla> What would those be?
15:32:25 <CodeKiwi> not purple
15:32:29 <Welkin> readable!
15:32:49 <etalecohomology> jle`: so ally problems go away, when using Array instead of UArray? can you explain your last sentence?
15:33:01 <Welkin> don't experiment with hackage!
15:33:12 <Welkin> I need to talk with who did this
15:33:14 <Welkin> does anyone know?
15:34:01 <merijn> Welkin: https://github.com/haskell/hackage-server
15:34:25 <CodeKiwi> I think it's better now lol...
15:34:28 <ggVGc> Welkin: maybe I'm blind, but it really looks like the same font to me, https://i.imgur.com/w5grWAQ.png
15:35:02 <CodeKiwi> BUT IT'S PURPLE
15:35:35 <etalecohomology> jle`: it compiles with Array; you're right, but strange!
15:36:04 <jle`> etalecohomology: yeah, it's because the array library doesn't really give a real generic interface for unboxed arrays
15:36:17 <jle`> you basically have to define each unboxed array's operations on a per-type basis
15:36:32 <Welkin> this was done by someone who is NOT a designer
15:36:43 <mtjmullen> Welkin: there's also a #hackage channel
15:36:52 <jle`> etalecohomology: and the library defines instances for common types one might run into
15:37:25 <jle`> etalecohomology: however, 'boxed' arrays (Array) can be worked with universally because all boxed types have the same 'representation' (a pointer) at runtime
15:37:42 <ggVGc> Welkin: if you make the window smaller, you get the old design
15:37:47 <etalecohomology> jle`++
15:37:53 <etalecohomology> jle`: thanks!
15:38:12 <jle`> no problem :)
15:38:13 <Tuplanolla> If it was done by a designer, you could tell, because it wouldn't display text without JavaScript...
15:38:23 <jle`> i don think, interface-wise, vector has a more sensible design
15:38:31 <jle`> for its unboxed variants
15:39:25 <Welkin> Tuplanolla: I mean a real designer, not a hipster dipshit
15:45:20 <merijn> Welkin: tbh, you're being quite rude and aggressive about this. If you want the design to improve you'll have a lot more success with constructive comments than calling people dipshits
15:45:43 <Welkin> merijn: sorry, but it is very upsetting to see such a destructive change implemented without any thought
15:46:05 <Welkin> if I need to be rudeto get my point across, I will be
15:47:35 <merijn> In other news, with the release of 8.4 I can finally switch to the new Haddock with it's amazing features :D
15:47:50 <exio4> what amazing features?
15:48:02 <exio4> haven't been following Haskell lately
15:48:15 <Welkin> what new features?
15:48:24 <merijn> exio4: Try hitting 's' on this page https://hackage.haskell.org/package/tasty-travis-0.2.0.1/docs/Test-Tasty-Travis.html
15:48:27 <jle`> that quick search thing
15:48:37 <fresheyeball> is there a way to do a similar thing to what I wrote before with Maps?
15:48:59 <fresheyeball> Map k [v] -> [Map k v]
15:49:04 <Welkin> the css is still god awful
15:49:11 <Welkin> that is my complaint
15:49:15 <ggVGc> merijn: why is there no way to clear the search box :(
15:49:19 <fresheyeball> f :: Map k [v] -> [Map k v]
15:49:48 <exio4> merijn: that's pretty neat
15:49:51 <Tuplanolla> I type in an identifier I see on the page and it's not found, merijn.
15:50:08 <ggVGc> Tuplanolla: it's case sensitive
15:50:14 <fresheyeball> where sum $ length . snd <$> toList xs = length $ f xs
15:50:17 <Tuplanolla> Oh!
15:50:32 <ggVGc> (which I think is bad fwiw)
15:50:39 <merijn> ggVGc, Tuplanolla: Although case insensitivity and a shortcut for clearing sound look good improvements
15:50:43 <ggVGc> case sensitive search is almost never what i want in any circumstance
15:50:58 <merijn> ggVGc: smartcase is the best solution
15:51:01 <ggVGc> yep
15:51:18 <ggVGc> merijn: but the times I use the case sensitive version of smartcase are few
15:51:23 <ggVGc> but good when available
15:51:29 <merijn> exio4: Also, as of this haddock version it should allow better control over documentation for re-exports and not badger you about hidden modules
15:51:45 <merijn> exio4: But I haven't tried that yet
15:51:53 <ggVGc> anyway, I think it's great
15:52:00 <Tuplanolla> The search box steals the focus cycle when it closes too.
15:52:05 <ggVGc> but on the other hand browsers already have search
15:52:12 <exio4> merijn: what's "smartcase"?
15:52:16 <merijn> ggVGc: Not across modules
15:52:25 <ggVGc> fair
15:52:33 <merijn> ggVGc: That's usually my biggest problem "what module is this in?"
15:52:45 <Tuplanolla> Try hitting S Esc Page Down.
15:52:58 <merijn> exio4: in vim smartcase makes all searches case insensitive UNLESS you write at least one capital letter
15:53:24 <merijn> exio4: i.e. searching "foo" turns up "foo", "FOO", "fOo", etc. but searching "FOO" only turns up "FOO"
15:53:41 <Tuplanolla> I'm going to side with Welkin in that this was designed incompetently.
15:53:48 <Tuplanolla> I like the purple though.
15:53:52 <merijn> Tuplanolla: File an issue on the haddock page
15:54:11 <exio4> merijn: ah
15:54:13 <merijn> Tuplanolla: The stylesheet redesign and the quick search are utterly unrelated, though?
15:54:32 <Tuplanolla> They are?
15:54:36 <merijn> Tuplanolla: as in, quick jump/search is a feature implemented in Haddock
15:54:44 <merijn> Tuplanolla: The stylesheet overhaul is part of Hackage
15:54:48 <masaeedu[m]> Maybe the old hackage used the system default sans-serif font, which means there's going to be a bigger change than for others
15:54:58 <masaeedu[m]> *bigger change for some people
15:55:10 <Tuplanolla> Oh, so it won't all be consistently colored in the future?
15:55:40 <merijn> Tuplanolla: It should be, the post says CSS for package pages hasn;t been deployed
15:56:05 <exio4> what redesign?
15:56:12 <merijn> Tuplanolla: It's just that the quick jump (and thus it's focus stealing?) is implemented in haddock, so can be fixed independently of the redesign
15:56:31 <merijn> exio4: Force refresh a package page
15:56:41 <merijn> exio4: Your browser is probably caching the stylesheet
15:57:02 <masaeedu[m]> exio4: You can see a style change if you go to a package page (as opposed to a haddock page)
15:57:02 <exio4> oh, I see
15:57:11 <masaeedu[m]> https://hackage.haskell.org/package/mtl
15:57:17 <exio4> I like it
15:57:36 <exio4> feels a bit too light though
15:57:40 <Welkin> it looks like shit
15:57:45 <Welkin> almost as bad as stackage
15:57:47 <exio4> nah, it's pretty nifty
15:58:44 <Welkin> it is unusable
15:59:33 <merijn> Tuplanolla: Anyway, if the search box is breaking focus in some way you should file a ticket at https://github.com/haskell/haddock/ to describe the issue
15:59:53 <Welkin> I will be submitting an issue regarding the broken layout
16:00:01 <masaeedu[m]> Welkin: I don't know what you'd really use those package pages for
16:00:15 <masaeedu[m]> but they display the same information they used to
16:00:28 <masaeedu[m]> here's base before: https://web.archive.org/web/20180203181656/https://hackage.haskell.org/package/base
16:00:34 <masaeedu[m]> here's base after: https://hackage.haskell.org/package/base
16:01:04 <masaeedu[m]> The "Properties" section got moved into a sidebar
16:01:06 <masaeedu[m]> but that's about it
16:01:11 <Welkin> that is terrible
16:01:12 <Welkin> yes
16:01:15 <masaeedu[m]> other than the color scheme
16:01:15 <Welkin> that is a horrible change
16:01:19 <Welkin> the font is unreadable
16:01:32 <Welkin> the colors are nonsense
16:01:39 <masaeedu[m]> what exactly were you using the Properties section for?
16:01:39 <Welkin> visited links are nearly the same color as non-visited links
16:01:46 <Welkin> fails to follow basic standards of usuability
16:01:48 <masaeedu[m]> the only time i land on that page is to look at what modules are inside
16:01:55 <ggVGc> Welkin: isn't it the same font?
16:01:58 <masaeedu[m]> and now that information is further up
16:01:59 <ggVGc> I really can't see a difference
16:02:01 <Welkin> I always look at information about who wrote the library
16:02:09 <Welkin> who maintains it, what versions there are
16:02:11 <Welkin> when it was updated
16:02:20 <Welkin> I need all the information in that sidebar
16:02:23 <Welkin> it is very important
16:02:38 <Welkin> no the font is not the same
16:02:44 <Welkin> it used to use you system sans-serif font
16:02:45 <masaeedu[m]> I think the old Hackage used to use `sans-serif` as the font
16:02:48 <masaeedu[m]> which probably depends on the system
16:02:49 <Welkin> now it is light open sans
16:03:08 <exio4> I don't see much of a difference
16:03:09 <masaeedu[m]> now it uses `Open Sans`
16:03:12 <exio4> if anything, I like the newer one
16:03:18 <Welkin> it is too thin!
16:03:37 <ggVGc> Welkin: can you post a screenshot of how it renders for you?
16:03:40 <Welkin> anyway
16:03:45 <Welkin> these changes were not done by a designer
16:03:46 <Tuplanolla> I'll do that tomorrow, merijn.
16:03:50 <Welkin> they were done by an amateur
16:04:17 <Welkin> and now I feel like I need to have it fixed before the damage spreads
16:04:39 * ggVGc watches Welkin fork hackage
16:04:39 <masaeedu[m]> lol
16:04:40 <masaeedu[m]> alright
16:04:43 <masaeedu[m]> i expect a PR by midnight
16:04:49 <Welkin> masaeedu[m]: who are you?
16:04:58 <ggVGc> masaeedu[m]: does he get to chose which midnight?
16:05:22 <masaeedu[m]> well hackage is actually burning to the ground now
16:05:27 <masaeedu[m]> so it would be nice to have it tonight
16:08:20 <Welkin> you are a matrix user even
16:08:24 <Welkin> how despicable
16:08:55 <masaeedu[m]> hang on, let me grab my leather flail
16:09:02 <masaeedu[m]> the better to flog myself with
16:09:29 <masaeedu[m]> anywho
16:09:45 <masaeedu[m]> is there a good way to generalize `zip`ping over various things?
16:09:57 <masaeedu[m]> e.g. `Map String`?
16:20:22 <MarcelineVQ> I feel like I​ saw a generalized zip recently, though if you just need one for Map for now Map has zipping operations in addition to union/difference/etc they're just sequestered away  https://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Map-Merge-Lazy.html
16:21:38 <masaeedu[m]> Ah, ok. I'm mostly trying to understand if there's some combination of existing, common typeclasses that can give you "zip for free"
16:21:50 <masaeedu[m]> e.g. what characteristics of `List` make them zippable
16:22:46 <masaeedu[m]> it's being added to a JS library, might be useful to have a general form if it doesn't incur the need to define an explicit typeclass instance
16:22:57 <c_wraith> in  hand-wavey manner, lists are zippable because they can be terminated at any point.
16:23:39 <c_wraith> no data structure conditions are violated by ending a list at any point.
16:23:49 <masaeedu[m]> hmm
16:23:56 <masaeedu[m]> how would you express "terminability" in a class
16:24:01 <Tuplanolla> Are you familiar with `Traversable`, masaeedu[m]? It's quite similar to what `Zippable` would be.
16:24:17 <masaeedu[m]> yes Tuplanolla
16:24:25 <masaeedu[m]> how would I use it for zipping?
16:26:27 <Tuplanolla> :t bitraverse -- This looks a bit like zipping some structures containing `a` and `b` together.
16:26:29 <lambdabot> (Applicative f, Bitraversable t) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
16:26:30 <masaeedu[m]> I can `traverse (,) myThing`, but I'm not really sure how to apply the second traversable so I end up with `(Traversable m) => m a -> m b -> m (a, b)`
16:29:34 <masaeedu[m]> i guess the sequence version might be a bit easier to think about
16:29:52 <masaeedu[m]> but the problem is getting that first `t a b` in the first place it seems
16:29:54 <Tuplanolla> You can merge `(a -> f c) -> (b -> f d)` into `a -> b -> (f c, f d)` and then you just need some way to separate `t a b` into `s a` and `s b`.
16:30:13 <masaeedu[m]> because instead of a bitraversable I have two regular traversables
16:30:19 <c_wraith> Tuplanolla, I can't follow that explanation at all.
16:30:39 <masaeedu[m]> e.g. two `Map String _`s
16:30:40 <Tuplanolla> I'm not sure I can either. It's just where I'd start from.
16:30:50 <c_wraith> Tuplanolla, how do you possibly merge those function arguments?
16:31:07 <fresheyeball> If anyone is curious, this is the result of my earilier questions. Its a funky new function
16:31:09 <fresheyeball> http://lpaste.net/363869
16:31:15 <masaeedu[m]> i did see a post by edward kmett earlier this morning when I was googling stuff
16:31:27 <masaeedu[m]> that mentioned bitraversable several times
16:31:31 <fresheyeball> keywiseTraverse :: (a -> [b]) -> Map k a -> [Map k b]
16:31:36 <masaeedu[m]> so you're probably on the right track
16:31:38 <Tuplanolla> I'm not suggesting `Bitraversable` already is the solution, c_wraith.
16:31:41 <fresheyeball> apparently this one is not out there already
16:31:43 <masaeedu[m]> i couldn't work out all the costuff and cothings in there though
16:32:02 <c_wraith> fresheyeball, looks like traverse to me
16:32:14 <masaeedu[m]> http://comonad.com/reader/2008/zipping-and-unzipping-functors/
16:32:20 <fresheyeball> c_wraith: it has the same signature, but check the implimentation
16:33:50 <fresheyeball> c_wraith: the result is an addition of the sizes of the inputs, rather than a multiplication which would occur with traverse
16:35:07 <masaeedu[m]> fresheyeball: Have you tried out what happens if you use the zip applicative instance for lists?
16:35:35 <fresheyeball> masaeedu[m]: you get a result that is the length of the smaller input
16:35:53 <masaeedu[m]> over traverse
16:36:11 <fresheyeball> masaeedu[m]: that is still the intuition
17:49:52 <pagnol> any beam user here who happens to know how a primary key can be renamed to override the default?
18:02:52 <pavonia> pagnol: You need to define a new table type for this, I think
18:04:28 <pagnol> pavonia, I just realized what I want to rename is not a primary key, but a foreign key column with type `Beam.PrimaryKey OtherTableT f`
18:20:35 <boj> pagnol: you override the defaults https://tathougies.github.io/beam/user-guide/databases/#modifying-the-defaults
18:21:06 <pagnol> boj, I used this for normal columns, but it appears to be different for foreign keys
18:21:57 <boj> for some reason they added the convention `table__id`, so i've found that we had to override foreign keys
18:23:25 <pagnol> boj,  { ...  , _myForeignKey :: Beam.PrimaryKey ReferencedTableT f, ... } <-- we are talking about columns that are defined like this, right?
18:23:34 <boj> pagnol: yeah
18:24:05 <pagnol> boj, I tried to rename them with the namedField function but that didn't work for me... am I doing something wrong?
18:24:37 <boj> _myForeignKey = MyPrimaryKey (fieldNamed "table_id")
18:24:52 <pagnol> boj, I meant `fieldNamed`
18:24:55 <pagnol> ah
18:25:03 <pagnol> oh... right
18:25:05 <pagnol> thank you!
18:25:12 <boj> yep!
18:25:18 <pagnol> rather obvious now that I see it ;-)
18:26:07 <pagnol> I have been using haskell in earnest only for about a week... It still takes me ages to figure out things like this
18:26:30 <boj> sounds like you are picking it up quickly :)
18:27:24 <pagnol> oftentimes I feel like a complete idiot though
18:27:44 <boj> took me 3 months to stop feeling like an idiot
18:28:11 <pagnol> you mentioned the other day you develop a web app with this reflex library?
18:28:19 <boj> yep
18:28:24 <pagnol> and share code between the backend and frontend
18:28:46 <boj> that is correct
18:29:02 <pagnol> may I ask would the app is about?
18:29:15 <boj> a very boring billing system for a telecom :)
18:30:10 <pagnol> how satisfied are you with the setup?
18:30:32 <boj> my team is pretty happy with how we have things
18:30:58 <pagnol> are you a contractor or working directly within the telecom company?
18:31:23 <boj> i am an employee
18:31:34 <pagnol> of the telecom?
18:32:05 <boj> i run the development group for their company, and our company (the telecom is our parent, we are a Managed Service Provider doing data center and development work)
18:32:36 <pagnol> was it hard to get to use haskell for this app?
18:33:48 <boj> as far as "what language/ecosystem do we use?", no, but i've had a long relationship with my company and they trusted me. in regards to "convincing other developers to adopt it", it took some work - a dash of patience and diplomacy
18:34:13 <boj> haskell is now our core competency
18:34:15 <pagnol> wow
18:34:34 <pagnol> did the other programmers have to learn haskell from scratch?
18:34:47 <boj> yep
18:35:05 <pagnol> were they rather eager or rather annoyed?
18:35:08 <pagnol> initially
18:36:09 <boj> half were eager, the half from the parent company semi-annoyed. they had C# forced on them, so were very skeptical at first. i had to spend some time building the core code infrastructure and showing them the benefits before they really caught on
18:41:42 <boj> the refactoring story was pretty obvious. being able to build a full JS frontend in haskell wasn't so obvious. however, we've had so many bugs in the past crop up from duplication between different frontend/backend code bases that it quickly became obvious that sharing types/errors/servant routes between both ends cut down on a lot of debug time
18:44:25 <pagnol> ah, you were replacing some existing software
18:45:36 <boj> i was using an example of past pain points with other projects we have all separately had to help justify a shared haskell ecosystem :)
19:29:09 <dsal> ugh. wreq does the exception thing.  That's unpleasant.
19:50:11 <shapr> this evening's quick hack converts the past year of netflix viewing activity into a csv: https://github.com/shapr/nitflixx
19:50:50 <shapr> We're doing a Wednesday lunchtime class at work on product recommendation engines, and real data is more fun than fake data.
20:05:27 <jchia1> Question about DuplicateRecordFields: It seems than intra-module, you can define two records that each define a field using the same name. However, if the records are each defined in a different module, and in a third module, I reexport the two modules, I get an error "Conflicting exports for 'fieldName'". It doesn't help to turn on DuplicateRecordFields in the reexporting module. Any ideas how to fix this nicely?
20:12:08 <pavonia> jchia1: Maybe try the workaround mentioned here: https://stackoverflow.com/questions/42501113/exporting-duplicate-record-fields
20:13:21 <shachaf> Is "loop ((x *** y) <<< arr swap) = x <<< y" an ArrowLoop law?
20:13:41 <jchia1> pavonia: Thanks
20:13:51 <jchia1> It seems to works]
20:53:06 <audoban> hello
20:56:14 <audoban> I want to understood which is the difference between a Int, Num and a Integer type
20:56:30 <Clint> Num is a typeclass
20:57:42 <audoban> then Int and Integer are instances of Num?
20:58:08 <jle`> yes
20:58:34 <jle`> audoban: Int is supposed to represent a bounded machine integer; Integer is an unbounded integer
20:58:54 <audoban> I see it
20:59:06 <audoban> thanks a lot
20:59:11 <audoban> :)
20:59:22 <jle`> np!
21:00:49 <dsal> Is there an easy way to get wreq to just like, not throw exceptions?
21:02:16 <dmj`> dsal: can you paste your code? I’m pretty sure it uses http-client under the hood, in which case you should just be able to call catch
21:02:30 <Axman6> > 3^1024 :: Integer
21:02:33 <lambdabot>  3733918487410200435329597541848665882254097767837340077506369317220790406172...
21:02:39 <Axman6> > 3^1024 :: Int
21:02:42 <lambdabot>  -7087363323575676927
21:02:49 <Axman6> :t (^)
21:02:51 <lambdabot> (Num a, Integral b) => a -> b -> a
21:02:59 <Axman6> audoban: does that help?
21:03:12 <EvanR> dsal: if youre using library async... then when a task crashes due to exception, you will be given the exception as part of the Either result, wherever you are awaiting the results
21:03:14 <jle`> dsal: you can use a function IO a -> IO (Either SomeException a), which transforms an IO action that throws exceptions into one that doesn't
21:04:07 <audoban> Axman: Yes
21:04:24 <EvanR> SomeException can then be manipulated to find out what it was, log it, ignore it, convert it...
21:05:16 <dsal> I don't have anything doing anything with exceptions at this point.  I've played with try and catch a bit, but I couldn't get something that compiled.    I mainly just want get as IO (Either String a)
21:05:50 <EvanR> :t try
21:05:53 <lambdabot> Exception e => IO a -> IO (Either e a)
21:06:09 <EvanR> IO a -> IO (Either SomeException a) will be an instance of that
21:06:31 <EvanR> you can show a SomeException
21:10:25 <dsal> this doesn't seem to work: https://www.irccloud.com/pastebin/lNsysAoy/crap.hs
21:10:47 <EvanR> let me guess
21:10:52 <EvanR> it says e is ambiguous
21:10:55 <dsal> heh. yes
21:11:16 <EvanR> right, try returns whatever exception type you want, but as written the compiler doesnt know what you want
21:11:19 <jle`> so make it not ambiguous :)
21:11:32 <jle`> dsal: it's the same thing as, say, 'read'
21:11:55 <jle`> there isn't enough for type inference to say what instance of Exception you want to 'read' things as
21:12:20 <jle`> note that 'try' is essentially 'read'
21:12:27 <EvanR> i remember getting tripped up by something almost exactly like this
21:12:38 <EvanR> when i started haskell
21:12:47 <EvanR> they told me to put some wacky type annotation
21:15:27 <jle`> dsal: try Left (show (x :: WhateverExceptionTypeYouAreExpecting))
21:15:51 <dsal> Yeah, I've got something like this.  It's fumbly, but almost working.
21:16:08 <jle`> if you're just prototyping/debugging, then you can use (x :: SomeException)
21:16:20 <EvanR> (the way IO exceptions work is a bit weird... its out of the ordinary for haskell. talking about the hierarchy and the dynamic typing stuff)
21:16:35 <jle`> the issue here isn't really anything to do with dynamic typing or the exception hiearchy
21:16:41 <EvanR> no
21:16:42 <dsal> This works, but it's ugly. https://www.irccloud.com/pastebin/Jv1ws87X/ugly.hs
21:16:42 <jle`> it's just basically the same thing as read :: Read a => String -> a
21:16:48 <EvanR> that part is ordinary
21:17:05 <jle`> it's just that 'read' has some nice built in defaulting rules
21:17:39 <jle`> dsal: yeah, try Left (show (x :: SomeException)) instead
21:17:48 <jle`> and processURL is just two fmaps
21:17:49 <EvanR> dsal: you can also write a function with top level signature String -> IO (Either SomeException (Response ByteString))
21:18:09 <EvanR> f u = try (get u)
21:18:30 <jle`> processUrl = (fmap . fmap) (processStream . view responseBody) .  tryget
21:18:35 <EvanR> when you look at the Either in ghci, it will just show the exception. if you really need a string later, you can use show
21:19:41 <EvanR> when you want to map a function over the Lefts of an other like you are doing, in so many words, you can use a reusable combinator for that
21:20:07 <EvanR> (though i think the only standardish thing for that is lens)
21:20:16 <EvanR> of an Either*
21:21:15 <dsal> jle`: That gives me an IO (Either .. (Either ..))
21:21:28 <dsal> EvanR: Yeah, I could just pass the Exception through, but I want to deny the existence of exceptions.
21:22:36 <jle`> dsal: oh, oops
21:23:01 <jle`> processUrl = fmap ((processStream =<<) . view responseBody) . tryget
21:23:32 <EvanR> dsal: i am saying if you write the wrapper at the top level, it wont be as ugly
21:23:34 <MarcelineVQ> EvanR: Bifunctor is in base now if it matters to that point
21:23:37 <jle`> or you can do it pointfully maybe
21:23:41 <EvanR> oh nice
21:24:06 <dsal> EvanR: Yeah, I think I see that.
21:24:57 <jle`> processUrl u = ((processStream . view responseBody) =<<) <$> tryget u
21:24:59 <jle`> hm
21:25:31 <EvanR> jle`: however part of this is annoying, if all you want is to show the exception to get a string, which they all do, you none the less cant use try polymorphically
21:26:04 <jle`> yeah, i think in this case, there's no reason to catch/turn to a string
21:26:05 <EvanR> it wants you to decide the instance
21:26:08 <jle`> unless you're at the consumption site
21:26:20 <jle`> the problem is trying to Either String too soon
21:27:02 <EvanR> the exception system is on the edge of wartness
21:27:31 <jle`> dsal: 'get' probably returns a specific type of exception
21:27:40 <jle`> and there's no point in catching it early in tryget
21:27:56 <jle`> and there might not even be a point in catching it in processUrl
21:28:05 <dsal> Yeah, it returns http exceptions.
21:28:11 <jle`> but processUrl could even be IO (Either IOException ...)
21:28:16 <jle`> not IO (Either String ...)
21:28:29 <jle`> returning Either String is probably an antipattern/stringly typed code
21:28:33 <dsal> Yeah, I think that'd be less code at least.
21:28:47 <EvanR> if your http task in within its own Async, then you can ignore exceptions entirely, except at the task manager/monitor which deals with the SomeException
21:29:04 <EvanR> which can report it
21:29:22 <EvanR> exceptions are at their best when youre not dealing with them
21:29:26 <jle`> there aren't many situations where 'Either String' is what you actually want
21:29:26 <dsal> I'm going to need to do something with async, but I hadn't planned on doing this.
21:30:14 <jle`> 'tryget' itself is a little questionable for actually working with exceptions
21:30:34 <jle`> it doesn't really serve any purpose
21:30:41 <jle`> you just need to 'catch' at the point where you expect to handle it
21:31:02 <jle`> so probably even processUrl could return IO [(EventType, Repo)]
21:31:04 <EvanR> Either String is itself a form of exception, only its now in your fae
21:31:05 <EvanR> face
21:31:45 <jle`> EvanR: i'm aying Either String vs. Either SomeDescriptiveType
21:31:53 <jle`> it's basically stringly typed code
21:31:56 <EvanR> Either e
21:31:59 <jle`> like using String when you really want Int
21:32:05 <EvanR> sure
21:32:07 <jle`> (+) :: String -> String -> String
21:32:13 <jle`> x + y = show (read x + read y)
21:32:24 <EvanR> (+) :: String
21:32:28 <dsal> Yeah.  I've eventually got a parser involved which is Either String.  That simplifies things.
21:32:45 <EvanR> main :: String
21:32:54 <jle`> dsal: yeah, the main point of ugliness here was Either String
21:33:04 <jle`> if you used any more descriptive type than String, type inference would help you
21:33:29 <jle`> well, String and 'show'
21:33:47 <EvanR> parser returning Either is good, IO returning Either E, which may even still crash in another way, is probably messed up
21:34:01 <dsal> processStream :: B.ByteString -> Either String [(EventType, Repo)]
21:34:01 <dsal> processStream b = A.parseOnly (A.many1 parseThing) $ (B.toStrict . GZip.decompress) b
21:35:52 <EvanR> when doing actual I/O, you really should embrace the IO exceptions (such as letting them happen, perhaps throwing your own in response to parse error). itll simplify the code
21:36:39 <dibblego> ew
21:37:06 <dsal> This function I'm writing is just combining the HTTP thingy with the parser.  So it's effectively the boundary.
21:37:17 <EvanR> whatever stops the IO action from returning a typical answer
21:37:49 <dsal> I'm pretty happy with Left doing that.
21:38:24 <dsal> I got rid of tryget and processURL doesn't look too terrible.
21:38:33 <EvanR> so you have the action returning Left "parse error", Left "cat unplugged the internet", or *unforsee other I/O exception*
21:39:05 <jchia1> Question about Monoid: Under GHC 8.4, where Monoid is a subclass of Semigroup, everytime I want to make something an instance of Monoid I also have to make it an instance of Semigroup, correct? So, I define the Semigroup instance with (<>) and the Monoid instance with mempty. Is there a less verbose way? Under GHC 8.2, it's just the Monoid instance with mempty and mappend, which is less verbose in terms of LOC.
21:39:14 <dsal> That's what I'm hoping for.  That means it either is Left String, or I do something fancier in the IO exception case.
21:40:03 <EvanR> instance Semigroup A where (<>) = f
21:40:12 <EvanR> instance Monoid A where mempty = e
21:40:22 <EvanR> one line each, even less lines than traditional Monoid instance :)
21:40:26 <jchia1> EvanR: OK, I suppose the part with 'where' can go on the same line
21:44:46 <jchia1> If I want to write code that's compatible with both 8.2 and 8.4, without using CPP, I'll need to define Semigroup.(<>), Monoid.mempty and Monoid.mappend, right? (Defining Monoid.mappend as (<>), needed for 8.2 but redundant for 8.4).
21:49:30 <dysfigured> so i have this weird thing where when i learn things, i try to write a blog post about what i've learned as if i'm trying to explain it to someone else. this is what i've put together so far in my intro to categories, and i'd appreciate any/all feedback https://gist.github.com/DanielFGray/5b3f743c96c8d3d0dc6ad7ee1890ea79
21:57:48 <EvanR> > sqrt 2
21:57:52 <lambdabot>  1.4142135623730951
21:58:20 <x200> > sqrt 4
21:58:23 <lambdabot>  2.0
21:58:48 <EvanR> better value is 1.4142135623730950488016887242
21:58:57 <x200> better value is 2
21:59:18 <EvanR> shouldnt the number lambda is giving have a 0 in the last place, due to rounding down
22:00:40 <byorgey> dysfigured: well, it seems you haven't said what categories are.
22:01:02 <Disavowed> dysfigured: I really like this. It's terse, which I appreciate but you contextualise well. You don't really assume any knowledge, which really helps. I think you've got something here - I'll be watching to see if you do any more of these because I think this is better than certain books on Haskell.
22:01:18 <Disavowed> byorgey: Sure he does - things that exhibit the same traits or have the same properties
22:01:30 <Disavowed> Well that's how I read it. Not saying I'm right
22:03:21 <byorgey> Disavowed: that's just a vague idea though, it should be possible to give a precise definition without getting too technical
22:03:53 <byorgey> dysfigured: the "structure preserving" thing is not actually a law for functors.  It's just an intuition about what it means if you satisfy the other two laws.
22:21:08 <dysfigured> Disavowed: i really appreciate that a lot, thank you
22:21:41 <dysfigured> This is just an hour or so into writing, I'm still updating the gist as I go
22:22:01 <EvanR> a monoid is a category?
22:22:13 <EvanR> at dysfigured
22:22:35 <dysfigured> from what i understand
22:22:54 <EvanR> like, with exactly 1 object/type ?
22:23:09 <dysfigured> i'm still new to all this, so maybe i'm wrong
22:28:28 <felixphew> Hi! I've got a bit of a problem and I'm trying to use this as an opportunity to learn Template Haskell (because why not?)
22:28:52 <felixphew> Basically, mapping one algebraic type to another type, with predictable names
22:28:55 <felixphew> http://lpaste.net/363872
22:29:58 <felixphew> I've managed to get the info I want with reify, but I'm not sure how to transform these names into an expression I can use
22:31:10 <felixphew> can anyone give me any pointers?
22:42:52 <Disavowed> dysfigured: You're most welcome. You've a very accessible writing style and if there are things that aren't accurate, they'll come with a little time. I think stick with it and see where this goes; I would probably pay money for content once you've worked out any kinks. Feel free to PM me anytime you want feedback on anything - I'm not amazing at Haskell yet, but I'd cheerfully help wherever I could.
22:50:33 <lizzie> hi, I'm trying to do a fizzbuzz shorter than one my friend did in python.  probably impossible, but anyways, anyone have ideas on making it shorter?  https://gist.github.com/alexbobp/9bb49509ffa33a29a0afab2e26518044
22:54:19 <Disavowed> lizzie: Here's Fizzbuzz in Python with Pattern Matching - not sure if it'd be shorter if you did it in Haskell, but it might be worth a shot (or fun to try!): https://hastebin.com/ipusavacex.py
22:56:56 <dminuoso> Disavowed: That's not pattern matching.
23:00:54 <Disavowed> dminuoso: Well Python doens't really have Pattern Matching, but you're not going to get much closer considering the constraints
23:01:30 <dminuoso> Being visually similar in only the most primitive ways is a long way from being comparable.
23:01:57 <dminuoso> It's "data matching" but not "pattern matching"
23:02:15 <dminuoso> You cant express ideas such as "(0, x) -> x" with dict access
23:02:26 <Disavowed> dminuoso: Well I don't know about that particularly but I don't want to continue down this avenue any further than is strictly necessary.
23:02:37 <Disavowed> No I'd agree with that last statement
23:05:04 <dminuoso> You are right, lets treat this argument lazily.
23:06:03 <dminuoso> lizzie: you can replace `foldr (++) []` with `concat`
23:06:32 <Disavowed> dminuoso: This sounds perfect! It's like you've known me all my life <3 - in all seriousness though, I think you've helped me a couple of times in here and I really appreciate it. I've definitely found it much harder to pick up Haskell than I have any other language.
23:06:35 <dminuoso> lizzie: Also Im not sure whether destroying readability for the sake of being shorter is that beneficial.
23:07:00 <dminuoso> Disavowed: Whats just hard is unlearning other languages. Haskell itself is not that hard to learn.
23:07:21 <lizzie> dminuoso: it's totally not beneficial, code golf is just for fun
23:07:28 <lizzie> Disavowed: thanks, I think I can work with this
23:07:40 <lizzie> it will be shorter in haskell since it has *actual* pattern matching
23:08:07 <dminuoso> lizzie: https://wiki.haskell.org/Fizzbuzz
23:08:16 <dminuoso> lizzie: I think this is already very short and concise =)
23:08:26 <dminuoso> And its idiomatic.
23:08:36 <Lears> Imo if you want to have fun golfing in haskell, you should not count whitespace, and should treat all function names as if they were the same length.
23:08:41 <Lears> Otherwise it's just awful.
23:12:13 <Lears> Also I don't really like that the fizz in that article separately checks the mod 15 case. Part of the point of the exercise is to write nice code that could easily/cleanly generalise in certain ways, like the addition of another number.
23:12:52 <Disavowed> dminuoso: I thought I'd pick it up easily - FP isn't new to me but I'm really being taken to task. I've been doing things like implementing map and filter with fold which has helped a lot. Do you have any favourite learning resources?
23:12:53 <Lears> It wouldn't be short, but I'd probably write something in the ZipList Applicative instance.
23:13:11 <Disavowed> lizzie: Really glad there's something there for you. Hope it goes well!
23:13:13 <Lears> Dinner's ready though, bbl.
23:13:24 <dminuoso> Disavowed: Please direct that question to the channel in general.
23:13:30 <dminuoso> They are far better equipped to guide you.
23:13:57 <Disavowed> I do apologise. Any favoured resources appreciated, channel!
23:16:33 <mjrosenb> (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d) infixr 8
23:16:34 <mjrosenb> Source
23:16:50 <mjrosenb> why is the only definition of this function in fgl :-(
23:17:20 <fakenullie> :t bimap
23:17:22 * ackpacket wonders how useful that is
23:17:23 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
23:17:34 <EvanR> this is cool... let x = (1+sqrt 5)/2, then iterate \y -> 1/(y-1) on it
23:17:40 <EvanR> (with floats)
23:18:09 <MarcelineVQ> mjrosenb: it's more commonly called *** or bimap
23:18:28 <MarcelineVQ> from Control.Arrow and Data.Bifunctor respectively
23:18:31 <mjrosenb> ahhh, right, Control.Arrow's functions look different
23:40:22 <jle`> i wonder why this package that i stopped working on a month ago depended on a custom git commit for 'vector'
23:41:02 <jle`> on HEAD instead of the current one on hackage
23:42:32 <vaibhavsagar> jle`: It looks like there's a new version as of a week ago
23:43:05 <vaibhavsagar> oh no, my mistake
23:43:11 <vaibhavsagar> I got the year wrong
23:43:22 <cocreature> jle`: maybe 8.4 compatibility?
23:43:30 <jle`> heh, that's depressing
23:43:51 <jle`> oh it looks like i needed the Mutable type family to be injective, with TypeFamilyDependencies
23:44:05 <jle`> latest version on hackage doesn't specify it to be injective, even though it technically could have
23:45:08 <jle`> it has been injective in HEAD since august, i guess they're just waiting to aggregate the small changes together before pushing to hackage
23:45:52 * jle` is happy for the opportunity to use git blame
23:46:54 <sl2c> <EvanR> this is cool... let x = (1+sqrt 5)/2, then iterate \y -> 1/(y-1) on it <--- unstable fixed point, yeah?
23:47:12 <cocreature> jle`: git blame on repos that you’re only working yourself tends to be rather frustrating ime :)
23:48:05 <jle`> heh, yeah. and i don't exactly have the best commit hygiene either when working alone
23:51:03 <cocreature> my worst commit messages are in the repo that I use to track my finances
23:53:44 <jle`> i use dropbox for that, which may or may not be a good idea
23:54:40 <jle`> with its built-in 'version control'
