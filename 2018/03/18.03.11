00:04:31 <tsahyt> there really ought to be a paths :: Tree a -> [[a]] in Data.Tree
00:05:00 * EvanR presses speed dial for library committee
00:05:32 <tsahyt> there's levels but that does the "opposite" of what I want
00:07:04 <tsahyt> what I'd need is each path from the root to a leaf
00:08:30 * EvanR wonders how to compute that efficiently
00:09:16 <EvanR> would be cool to begin traversing from all leaves
00:09:37 <EvanR> and go backwards
00:09:38 <tsahyt> hm I've got something that typechecks and passes a quick sanity check in ghci
00:09:58 <tsahyt> but I'm too undercaffeinated to understand why it works
00:10:09 <EvanR> thats the beauty of it
00:11:46 <cocreature> > let paths = foldTree (\x xs -> if null xs then [[x]] else map (x:) (concat xs)) in paths (Node 1 [Node 2 [Node 3 [], Node 4 []], Node 5 []])
00:11:49 <lambdabot>  [[1,2,3],[1,2,4],[1,5]]
00:12:45 <tsahyt> that seems to do very much the same as what I've written
00:12:51 <EvanR> does it work on infinite
00:12:54 <tsahyt> mine is explicitly recursive though, and abuses the list monad
00:13:28 <cocreature> EvanR: no, the "null xs" screws that up
00:14:31 <tsahyt> how about this? paths (Node x []) = [[x]]; paths (Node x xs) = [ x : xs' | next <- xs, xs' <- paths next ]
00:14:38 <cocreature> hm actually no, I think it does
00:14:49 <EvanR> good
00:15:01 <EvanR> hopefully you just enumerated the reals
00:15:40 <cocreature> hm no it doesn’t
00:15:45 <EvanR> haha
00:15:49 <cocreature> it’s too early
00:17:46 <EvanR> let reals = [Node 0 reals, Node 1 reals] in Node 7 reals
00:24:09 <boobayh> disconnected
00:25:58 <EvanR> cool i just recompiled "everything" in order to get sdl2 to use the newer version of vector i installed
00:26:14 <EvanR> but now its using the old version of text that i have installed
00:26:23 <EvanR> and removing it breaks everything
00:26:31 <EvanR> why do i bother using cabal install
00:27:22 <EvanR> why is it that, rather how even is it that i can import Data.Text and its a different library version from the one sdl2 is depending on ?
00:27:46 <EvanR> how is it deciding what to import in my module
00:31:15 <cocreature> just use sandboxes/new build and lead a happy life
00:33:18 <tsahyt> is this a safe assumption? not (null xs) ==> all (not . null) (groupBy f xs)
00:33:35 <tsahyt> for all f and xs that is
00:35:49 <boobayh> cocreature:  What is any other hot topic for Haskellers other than DS and ML
00:36:17 <tsahyt> @help
00:36:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:36:21 <boobayh> whole world running beehind them isnt it ?
00:37:13 <tsahyt> how did lambdabot's quickcheck work again?
00:41:10 <cocreature> @help check
00:41:10 <lambdabot> check <expr>
00:41:10 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
00:41:29 <tsahyt> @check \f xs -> all (not . null) (groupBy f xs)
00:41:32 <lambdabot>  +++ OK, passed 100 tests.
00:41:34 <tsahyt> nice
00:41:42 <cocreature> tsahyt: you probably want to add some type annotations
00:41:52 <cocreature> otherwise it’ll default to ()
00:42:02 <tsahyt> @check \f (xs :: [Int]) -> all (not . null) (groupBy f xs)
00:42:02 <lambdabot>  <unknown>.hs:1:18:ScopedTypeVariables language extension is not enabled. Ple...
00:42:05 <tsahyt> ...
00:42:19 <tsahyt> @check \f xs -> all (not . null) (groupBy f (xs :: [Int]))
00:42:22 <lambdabot>  +++ OK, passed 100 tests.
00:42:45 <tsahyt> I need to read into how quickcheck generates functions
00:42:48 <cocreature> boobayh: not sure if there is any one topic that is popular among all haskellers. I suppose compilers might be more popular than they are in other languages
00:42:51 <tsahyt> seems kinda magical
00:44:28 <boobayh> cocreature:  why do we need nore compilers ? There are plenty of them
00:45:14 <enterprisey> boobayh: compilers are what makes the world go 'round
00:45:18 <tsahyt> why do we need more machine learning frameworks? there are plenty of them
00:45:27 <nshepperd> > group []
00:45:30 <lambdabot>  []
00:45:49 <tsahyt> > [] `elem` []
00:45:51 <lambdabot>  False
00:45:53 <ideasman42> Is it common that using: Data.List.reverse would cause a simple script to hang and run out of memory?
00:46:09 <enterprisey> ideasman42: the immediate answer is that the list is quite large
00:46:16 <tsahyt> perhaps even infinite
00:46:33 <ideasman42> I just ran into this bug where using reverse call caused hanging with 14gig mem use
00:46:36 <tsahyt> reversing infinite lists is not advisable
00:46:37 <ideasman42> before I have to kill
00:46:42 <ideasman42> list is tiny
00:46:51 <ideasman42> hs file is also small - https://github.com/xmonad/xmonad-contrib/pull/233/commits/0d6b250a96fb3c9b60c9e75cd1ee387832172b0f#diff-48048c9fb826c3dc1f7464660d69f906R124
00:48:00 <cppxor2arr> "haskell + smart programming practices guarantee a crash-free experience."
00:49:22 <ideasman42> Was surprised this caused inf loop with ~5 items
00:49:32 <ideasman42> getting indices fixed
00:54:41 <ideasman42> tsahyt: thing is it's not inf, if I dont reverse it
00:55:12 <ideasman42> if I could force evaluate the whole thing. There would be no issues
00:55:39 <EvanR> the finite list that becomes infinite upon reversal, very popular at parties
00:56:06 <ideasman42> eeh. I mis-spoke... I mean I can use it as fixed size list with zip for eg
00:56:11 <EvanR> quite a pain in the wild
00:57:01 <ideasman42> Assuming it is an inf list, How to bound its size?
00:57:33 <ideasman42> eg: (take 5 mylist)  to get a list with 5 items
00:57:34 <EvanR> i asked this in #haskell-game but no answer... what is up with the sdl2 audio callbacks audio format witness extractor Dict thing not being exported
00:57:47 <EvanR> how else can you implement the polymorphic audio callback
00:58:46 <EvanR> i vaguely remember doing it without Dict but no idea how
01:04:09 <EvanR> oh pattern match on format
01:08:02 <ideasman42> is there a cleaner way to optionally reverse a list? https://hastebin.com/epapaxikuh.hs
01:09:06 <ideasman42> eg: (if (foo) then reverse else nop) my_list
01:09:33 <tsahyt> you could do that too, yes
01:09:45 <ideasman42> What is nop in haskell?
01:09:53 <tsahyt> heights = (if scale < 0.0 then reverse . take n else id) heights_noflip
01:10:03 <ideasman42> id hah. thx
01:10:12 <ideasman42> noticing Rust similarities all over :)
01:10:27 <ideasman42> well, a few
01:10:29 <tsahyt> rust was somewhat influenced by haskell after all
01:10:30 * EvanR wonders about this "style"
01:10:55 <tsahyt> ideasman42: I'd leave it the way you wrote it though
01:11:01 <tsahyt> it's just easier to see at a glance what's going on
01:12:00 <ideasman42> that way allows me not to use an intermediate assignment
01:33:17 <boobayh> so can we write our own programming language in Haskell ?
01:42:48 <srk> boobayh: http://dev.stephendiehl.com/fun/
01:43:32 <Athas> boobayh: that's what I did!  Great fun.
01:44:12 <boobayh> Athas:  I am not understanding what you did ?
01:44:16 <boobayh> srk:  thats another book ?
01:44:58 <boobayh> language called fun
01:45:00 <boobayh> ok
01:54:52 <boobayh> haskell a complete language and the only language hich is complete ? or any other ;anguages like haskell
01:58:06 <thebnq> What do you mean by complete?
01:59:27 <boobayh> i can write web app desktop app and even a compiler
03:01:00 <thebnq> A lot of languages can do both of those.
03:16:45 <i-am-the-slime> Can anybody here help me with setting up spacemacs for Haskell dev?
03:34:34 <olligobber> > putChar $ [minBound..] !! 12644
03:34:37 <lambdabot>  <IO ()>
03:34:53 <olligobber> I see
03:35:04 <olligobber> > [minBound..] !! 12644 :: Char
03:35:06 <lambdabot>  '\12644'
03:35:13 <olligobber> I give up
03:39:48 <Darwin226> If I have a "class C a b | a -> b", is there a way to define a type family that takes an "a" and gets the corresponding "b"?
03:42:00 <cocreature> Darwin226: nope, you don’t get type families from functional deps
03:54:31 <i-am-the-slime> If I say: nix: enable in a stack.yaml does that mean that this whole project ONLY works with nix?
03:55:44 <cocreature> i-am-the-slime: stack --no-nix should override that afaik. not sure if stack automatically switches it off if nix is not available on that system
03:56:40 <i-am-the-slime> cocreature: My problem is that I think stuff works when I do stack --nix from the command line
03:57:10 <i-am-the-slime> cocreature: But when spacemacs does its stuff I don't think it runs stack --nix
03:57:31 <cocreature> yeah I would be surprised if it did
03:59:54 <i-am-the-slime> I wonder now I can make it.
04:00:34 <i-am-the-slime> Now how
04:01:06 <cocreature> it seems like nix: enable is exactly what you’re looking for. you could try setting it in ~/.stack/config.yaml if you want to use it for all projects but don’t want to bother other people that work on the same projects
04:01:30 <i-am-the-slime> yes, that bothering is what I'm worried about
04:01:39 <i-am-the-slime> ah cool
04:01:41 <i-am-the-slime> a local one
04:02:30 <i-am-the-slime> I will try that!
04:04:41 <i-am-the-slime> cocreature: So I guess I have to remove the enable: false from the actual project
04:05:39 <cocreature> right that will take precedence
04:05:52 <i-am-the-slime> Let's see then!
04:08:12 <etalecohomology> hi
04:09:23 <etalecohomology> i tried for the first time to use a monad transformer MaybeT
04:09:47 <etalecohomology> actually my code got much more complicated by that :-(
04:10:32 <etalecohomology> less "case" statements, but lots more of code like "MaybeT $ liftIO $ atomically $ runMaybeT"
04:11:32 <etalecohomology> is this somehow "idiomatic" or should I use it very rarely?
04:12:16 <etalecohomology> especially when changing from, say "MaybeT STM a" to "MaybeT IO a", I always have to unpack and repack the MaybeT
04:12:37 <cocreature> etalecohomology: you can use "hoist atomically" for that https://hackage.haskell.org/package/mmorph-1.1.1/docs/Control-Monad-Morph.html#v:hoist
04:12:40 <i-am-the-slime> Now I get "Suspicious state from syntax checker haskell-stack-ghc: Flycheck checker haskell-stack-ghc returned non-zero exit code 1, but its output containe dno errors: cannot satisfy -package checkers
04:14:54 <etalecohomology> cocreature: thanks! I will try that
04:27:34 <JihadJeep> hey guys. scrublord here. what are the benefits of the jvm to, say, gcc when it comes to portability? it's said a virtual machine allows for code to operate independent of platform, but how is the jvm any different than gcc or gch in that regard?
04:27:58 <cocreature> JihadJeep: what does that question have to do with Haskell?
04:29:23 <veverak> JihadJeep: A. does not relate to haskell B. With JVM you have to distribute only one version of the code in theory, and let the virtual machine translate it. With gcc you have to  distribute binary for each platform
04:30:00 <veverak> JihadJeep: I am not Java programator, but afaik the par "You only have to distribute only version of the code/binary" has practical problems and you end up with different "binaries" anyway
04:30:20 <JihadJeep> cocreature: i'm wondering how the jvm's lauded portability is any different than gcc's or ghc's (which i mentioned, typo-aside)
04:31:05 <JihadJeep> veverak: ah, okay. so it's a bit of an overstated facet of the jvm i take it
04:31:19 <barrucadu> In principle, you only have to compile your java code once and it will run on anything that has a jvm implementation
04:31:35 <barrucadu> Whereas you need to compile your C or your Haskell once for each platform
04:31:35 <veverak> JihadJeep: depends on use case I suppose
04:31:50 <cocreature> if you compile Haskell code on different platforms "Int" will have a different size which can change the behavior of code in various ways
04:32:01 <geekosaur> except for th whole "write once, debug everywhere" thing
04:32:07 <cocreature> and similar things apply to other platform dependent things
04:32:18 <cocreature> java/the jvm try a lot harder to avoid those
04:32:47 <veverak> yeah, it should be easier, but not for free or without any "platform dependent stuff"
04:33:47 <cocreature> FFI (which often causes problems when it comes to portability) is also a lot less common in JVM land than it is in Haskell land but that’s mostly a cultural thing
04:40:31 <i-am-the-slime> Maybe I should try VSCode or something.
04:48:00 <kuribas> fmap getConst . getCompose doesn't alter the structure of the data, can ghc infer that?
04:48:04 <kuribas> If so how?
04:50:44 <[exa]> kuribas: it can be derived from the definitions with a bit of inlining
04:51:26 <[exa]> ofc it will probably depend on the knowledge of the functor
04:51:29 <kuribas> And if it doesn't get inlined?
04:51:50 <kuribas> Perhaps it has a rewrite rule fmap getConst = id
04:52:17 <kuribas> no, unsafeCoerce
04:53:29 <kuribas> now that I think of it, it may do that automatically for newtypes...
04:53:37 <[exa]> yup
04:54:12 <[exa]> btw newtypes get completely erased somewhere in the middle of compilation, I guess there's at least one round of partial evaluation after that
04:54:51 <kuribas> so fmap coerce = coerce
04:54:58 <[exa]> i-am-the-slime: why vscode? :D
04:55:18 <cocreature> kuribas: no at least not without rewrite rules, that’s the whole reason why we got "coerce" in the first place.
04:57:39 <kuribas> "We want the RULEs "map" and "map/coerce" to fire first. map is recursive, so won't inline anyway, but saying so is more explicit, and silences warnings"
04:58:47 <kuribas> there's a rule for map but not for fmap
04:59:59 <i-am-the-slime> [exa]: I'm just getting frustrated
05:04:01 <i-am-the-slime> How do I find out which ghc version some stackage lts thing uses?
05:07:30 <Rembane> i-am-the-slime: It usually says on stackage.org. Do you have an exotic snapshot?
05:08:19 <i-am-the-slime> I'm just trying to get into a nix-shell so I can launch spacemacs from within there
05:08:44 <i-am-the-slime> but it seems like all of the guides set up nix-shells which inherit the ghc version from stack
05:08:56 <i-am-the-slime> but I don't know how to get into the shell then
05:09:00 <Rembane> i-am-the-slime: How far do you get before it goes boom?
05:13:12 <i-am-the-slime> let me see what the latest is
05:13:35 <i-am-the-slime> Suspicious state from syntax checker haskell-stack-ghc: Flycheck checker haskell-stack-ghc returned non-zero exit code 1, but its output contained no errors: <command line>: cannot satisfy -package doctest
05:14:23 <Rembane> Hm... interesting. Do you have a stack ghc installed?
05:15:00 <i-am-the-slime> I think so.
05:15:07 <i-am-the-slime> How do I find out?
05:15:42 <Rembane> Run stack setup and then try again. :)
05:15:59 <i-am-the-slime> ok
05:17:55 <i-am-the-slime> It says stack will use the GHC on your PATh
05:18:48 <Rembane> Check.
05:18:55 <Rembane> What does which ghc give you?
05:19:22 <i-am-the-slime> gives /run/current-system/sw/bin/ghc
05:19:55 <Rembane> Run ghc --version just for the heck of it. :)
05:20:16 <i-am-the-slime> 8.2.2
05:20:28 <Rembane> nothing strange so far
05:21:04 <Rembane> if you have a cabal-file you can run cabal2nix to generate a shell.nix
05:21:52 <i-am-the-slime> I think I did this originally
05:22:37 <i-am-the-slime> for some reason now I can actually say nix-shell
05:22:38 <i-am-the-slime> which excites me
05:23:44 <Rembane> Sweet!
05:24:43 <i-am-the-slime> But the error is the same in emacs.
05:24:45 <i-am-the-slime> Okay, so one second now.
05:24:51 <i-am-the-slime> I show you my shell.nix
05:25:35 <i-am-the-slime> http://pastebin.ca/4000009
05:26:12 <i-am-the-slime> I suppose the second ghc is a bad idea
05:26:38 <Rembane> TRy to remove it and see what happens
05:27:04 <i-am-the-slime> I removed it. nix-shell still does not error out
05:27:32 <i-am-the-slime> I'm worried emacs does not have the context of the nix-shell when I start it.
05:28:24 <Rembane> Now I'm at a loss since I don't use emacs, so I hope some emacs user in the channel can take over. :)
05:29:00 <i-am-the-slime> Rembane: What do you use instead?
05:31:44 <Rembane> i-am-the-slime: vim. :)
05:31:54 <Rembane> i-am-the-slime: Neovim to be 100% correct
05:32:02 <i-am-the-slime> I could try that.
05:32:49 <i-am-the-slime> Anything with vim keybindings should fit the bill. I heard that vim has a pretty good vim-mode :D
05:33:29 <Rembane> It does indeed.
05:34:53 <i-am-the-slime> Rembane: and you use nix?
05:37:10 <Rembane> i-am-the-slime: Yes. But I don't really integrate things with each other.
05:37:15 <Rembane> i-am-the-slime: I'm way too lazy for that.
05:37:36 <i-am-the-slime> what do you mean by that?
05:37:41 <i-am-the-slime> You have syntax highlighting and that's it?
05:38:19 <Rembane> Yup
05:38:38 <Rembane> And hoogle.haskell.org in another window
05:38:48 <i-am-the-slime> I feel like I'm too lazy to do the computer's job for me :D
05:39:04 <Rembane> to each their own. :)
05:39:11 <i-am-the-slime> the other way around I meant
05:39:12 <i-am-the-slime> whatever
05:39:23 <i-am-the-slime> I'm just suspecting that it's a path problem on emacs
05:40:04 <Rembane> Hopefully
05:51:54 <i-am-the-slime> The path is right now. Still get cannot satisfy package doctest
06:03:21 <saksham> i-am-the-slime: I'm using Emacs on Nix. Reading through your issue now. Although have you tried intero? It worked like a charm, 1 line configuration, and works for everything.
06:04:51 <saksham> And you should **NOT** put 'nix: enable: true' in your project's stack.yaml file. If you are using NixOS, you should put 'nix: enable: true' in ~/.stack/config.yaml . This will let you use stack everywhere normally, like you would on any other OS.
06:06:42 <saksham> I too spent a while trying this "get into a nix shell and launch emacs from there". Just use "https://github.com/commercialhaskell/intero" on your emacs and everything will work just fine.
06:08:34 <w1n5t0n> speaking of intero, I'm using it as a live coding environment but whenever I write a top level expression (I think that's the right term, something like "(+) 2 3" for example which isn't a function definition) I get a syntax error highlighting, is there any way I can disable it?
06:11:15 <saksham> Wait, why would you want to write top level expressions anyway? There's "intero-repl" which will let you open a GHCi buffer. If you want to load your haskell file into that GHCi REPL, you can use C-c C-l.
06:11:24 <i-am-the-slime> saksham: I put it there now
06:11:48 <i-am-the-slime> saksham: I was hoping to use ghc-mod actually because it can import things.
06:11:56 <i-am-the-slime> If I can get anything to work now, I'll be happy.
06:12:50 <saksham> So as long as you're on the recent few GHCs (I think >7.10), intero will do (I think) everything that ghc-mod did. I have been using intero on some really complicated projects, and it works much better than ghc-mod IMHO.
06:14:14 <i-am-the-slime> Good to know.
06:14:23 <saksham> I'm actually curious to find something that ghc-mod can do and intero cannot.
06:15:01 <i-am-the-slime> So you can type some function name that is currently not imported and then intero will be able to add the import to the import list?
06:16:23 <saksham> Oh, you mean that thing. In case of intero, it will show an error on that line. If you put your keyboard cursor there, it shows an error: "Did you mean to add ... to your imports..." and it tells you to press C-c C-r (I think) to automatically add it.
06:17:15 <saksham> It is not perfect (obviously), but I have found it to work nice enough. It even suggests LANGUAGE pragmas which may need to be enabled (RankN-Types, OverloadedStrings etc).
06:19:37 <i-am-the-slime> It's good enough for me
06:19:44 <i-am-the-slime> if it can do that, I'll be happy
06:19:55 <i-am-the-slime> cannot satisfy package checkers
06:20:00 <i-am-the-slime> why not? What is it even?
06:21:30 <saksham> That's probably a spacemacs issue. See this: https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Blang/haskell#intero
06:25:41 <i-am-the-slime> Hmm.
06:27:00 <i-am-the-slime> saksham: I'm not sure which part you mean here.
06:27:03 <w1n5t0n> saksham: because I'm using the source file as an environment for live coding music, very similar to how TidalCycles works (https://tidalcycles.org/functions.html). From my understanding the way it's done in Tidal is by sending the lines as strings to the interpreter, can I not do that through intero?
06:27:09 <i-am-the-slime> Do you think I should install intero explicitly?
06:28:54 <saksham> w1n5t0n: I don't think I understand your usecase here. Not aware of such a functionality in intero, since the code you're writing would not be considered valid .hs files.
06:29:53 <saksham> i-am-the-slime: It is not on my PATH at least. That error sounds like a spacemacs error, upon googling. I use plain Emacs, so am not familiar with Spacemacs issues.
06:31:26 <i-am-the-slime> Okay.
06:32:28 <saksham> i-am-the-slime: I found a **possible** way to use ghc-mod on Nix. This is basically doing manually, what intero automates. https://github.com/DanielG/ghc-mod/wiki/Installing#per-project-installation
06:32:31 <w1n5t0n> saksham: I basically want to use the files as a REPL so that I can keep going back and editing the function calls. For example: "playSound someSound", execute it, and then go back to it later and change it to "playSound someOtherSound" and execute it again
06:33:16 <saksham> w1n5t0n: Why not try those things in the REPL itself? As long as your functions are in the file, you can use the REPL to try the things.
06:33:22 <w1n5t0n> basically what this guy is doing here: https://www.youtube.com/watch?v=8y_47ExSLRE&t=481s
06:35:09 <saksham> w1n5t0n: yeah really don't think a tool would let you evaluate such a code. Although this is a cool concept!
06:36:08 <w1n5t0n> saksham: intero does evaluate it, so for example if I write "2 + 5" on a new line and execute it it prints out 7, but it still highlights it as an error
06:36:22 <w1n5t0n> (execute it by C-c C-c)
06:36:27 <i-am-the-slime> Maybe some hdevtools.
06:38:06 <saksham> w1n5t0n: right, that's the thing. Intero is made for haskell files. The file you're talking of will not even get loaded by ghc/ghci/runhaskell, let alone a tool (intero) which uses ghci.
06:42:19 <w1n5t0n> saksham: I don't care for using a non-haskell file, at the moment I have a .hs with some function definitions at the top (with all the features from intero like highlighting and indentation) and then I can write function calls underneath that and use them with "C-c C-c" just fine, which basically is the functionality I want, I was just wondering if I can disable the syntax error highlighting in intero.
06:42:51 <w1n5t0n> I know it's invalid code for a Haskell source file but it really is crucial to have that functionality for live-coding music
06:43:57 <saksham> w1n5t0n: there's no such way I know of right now, although there might exist some.
06:44:33 <saksham> w1n5t0n: one way I can think of, for your case. Write the functions in a separate file, and import it using the file with the top level function calls. And enable intero only in the file with the functions.
06:44:47 <saksham> s/import it using/import it from
06:57:56 <i-am-the-slime> saksham: I'm not set on using ghc-mod actually.
07:10:11 <i-am-the-slime> Hrmkpf
07:34:49 <i-am-the-slime> stupid checkers
07:42:53 <w1n5t0n> is there a way to keep track of state in a REPL? For example: addString "someString"; addString "someOtherString"; and then run getStrings and get ["someString", "someOtherString"]
07:43:31 <Ariakenom> w1n5t0n, you mean like with IORef?
07:45:41 <w1n5t0n> Ariakenom: I'm not familiar with it but at a quick glance it seems promising
07:46:17 <Ariakenom> great
07:47:35 <w1n5t0n> Ariakenom: how are they different from MVars?
07:48:25 <Ariakenom> You could use that too. MVars can be empty and have some blocking semantics.
07:48:28 <cocreature> w1n5t0n: 1. they always contain a value, 2. they are quite limited when it comes to the atomic operations that you can perform on them
08:05:51 <bwe> Hi, I want to check out building blocks for e-commerce sites. Something like http://docs.satchless.com/en/latest/index.html False positive: I do not want a full fledged web shop.
08:07:58 <Myrl-saki> This will probably rank up high on "stupid questions asked today"
08:08:07 <Myrl-saki> How do I mentally not mix up `Functor f => f a` and `a`?
08:08:35 <Myrl-saki> I was stuck at the definition of hylomorphisms until I realized that an `Functor f => f a` doesn't necessarily hold an `a`
08:09:15 <Cooler> hey
08:09:23 <Cooler> what is the relation between ssa and cps?
08:09:26 <Cooler> https://en.wikipedia.org/wiki/Static_single_assignment_form
08:09:37 <Myrl-saki> hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b; hylo f g = h where h = f . fmap h . g
08:09:45 <Myrl-saki> I may have remembered wrong.
08:09:55 <Myrl-saki> But yeah, question doesn't change.
08:10:03 <Cooler> this mentions static single assignment form isn't used by functional languages, rather continuation passing style is used?
08:10:12 <Cooler> how are they related?
08:10:16 <Tuplanolla> Using engineer's induction, Myrl-saki: if it works for `Identity` and `Const c`, it works for all `a`.
08:10:31 <Myrl-saki> Tuplanolla: lol
08:10:39 <Myrl-saki> Tuplanolla: Wait, really?
08:11:02 <Tuplanolla> It's a helpful guideline for intuition.
08:11:11 <Myrl-saki> Tuplanolla: I'm trying to head-valuate it, and that doesn't seem wrong.
08:12:05 <Myrl-saki> Tuplanolla: Thanks.
08:13:02 <Tuplanolla> The motivation comes from them being the extrema of information conservation in the space of functors.
08:13:15 <Tuplanolla> Identity remembers all information while constant forgets all information.
08:13:16 <Myrl-saki> Tuplanolla: What does that mean?
08:13:53 <Myrl-saki> Tuplanolla: How about :: [a]?
08:14:18 <Tuplanolla> Everything else is either isomorphic to them or somewhere in between, lists included.
08:14:32 <Myrl-saki> Tuplanolla: Right, that's also what I was thinking.
08:15:03 <Myrl-saki> Tuplanolla: Wait, wouldn't it be, `Identity`, `Const c` and `Maybe`?
08:15:08 <Myrl-saki> Rather
08:15:28 <Tuplanolla> Consider the same in terms of ordinary functions.
08:15:44 <Myrl-saki> {Identity | Maybe, Either} {Const c}
08:16:07 <Myrl-saki> Ugh, wait. I don't think that's what I wanted to say.
08:16:17 <Myrl-saki> Tuplanolla: I'm listening.
08:16:22 <Tuplanolla> Let's assume that I have a data structure `x`.
08:16:29 <Myrl-saki> Okay.
08:16:46 <Tuplanolla> If I give you `id x`, I cannot keep any part of `x` secret.
08:17:11 <Tuplanolla> If I give you `const () x`, I can keep every part of `x` secret.
08:17:39 <Myrl-saki> Tuplanolla: Right.
08:17:54 <Myrl-saki> Tuplanolla: I was wondering more on the "compound" part. Though, that's not as important.
08:19:27 <Tuplanolla> If I had the option to give you either `Just x` or `Nothing`, I could provide you some knowledge of `x`.
08:21:08 <Tuplanolla> This is true in the `Just` case though. If it was never `Just`, the arrangement would be isomorphic to the `const ()` case.
08:21:53 <Unhammer> anyone know of a haskell library that does (html) boilerplate removal / main context extraction like http://www.l3s.de/~kohlschuetter/boilerplate/ / https://github.com/miso-belica/jusText#justext / readability / goose?
08:25:04 <Myrl-saki> Tuplanolla: Right.
08:25:22 <Myrl-saki> Tuplanolla: Hence why I included `Either` in the idea.
08:26:00 <Myrl-saki> Tuplanolla: By Either, I'm also including (
08:26:02 <Myrl-saki> Tuplanolla: By Either, I'm also including (|), FWIW.
08:28:35 <Tuplanolla> Even with `Maybe` or `Either` you wouldn't gain any more information about `x` than `Identity` would give you, just some other information about the sum.
08:28:59 <Myrl-saki> Tuplanolla: Yeah, I was more concerned with "What about even more xs"
08:29:14 <Myrl-saki> Wait, what's the kind of `Const`
08:29:34 <Myrl-saki> `:: a -> * -> a`?
08:29:41 <Myrl-saki> :k Const
08:29:43 <lambdabot> * -> k -> *
08:29:47 <Myrl-saki> Awww
08:29:51 <Myrl-saki> Boring
08:30:06 <Myrl-saki> I was thinking you can do something with Const and Fix. Not sure what I was thinking of though.
08:31:13 <Myrl-saki> Tuplanolla: Once again, thansk.
08:35:35 <i-am-the-slime> It just refuses to work.
08:36:08 <Myrl-saki> i-am-the-slime: What does?
08:36:25 <i-am-the-slime> spacemacs and intero
08:40:53 <i-am-the-slime> I don't believe it.
08:41:00 <i-am-the-slime> I've been trying this for an entire day.
08:41:10 <i-am-the-slime> And I just had to start it.
08:41:14 <i-am-the-slime> intero-mode
08:43:24 <i-am-the-slime> Fucking hell.
08:48:11 <APic> Fucking Hell, yeah.
08:49:57 <Ariakenom> I feel like I accomplished something. tmp2.hs:186:16:ghc.exe: panic! (the 'impossible' happened)
08:52:03 <Tuplanolla> You can now join the hall of fame, here, Ariakenom: https://ghc.haskell.org/trac/ghc/query?description=~impossible
08:52:29 <ski> @quote impossible.just
08:52:29 <lambdabot> autrijus says: Perl: "Easy things are easy, hard things are possible" <autrijus> Haskell: "Hard things are easy, the impossible just happened"
08:52:45 <Ariakenom> I'm pretty sure the advanced fix is to upgrade ghc for once :)
08:58:28 <i-am-the-slime> So now, I guess I should be able to navigate through code go to definitions and stuff with intero.
08:59:06 <i-am-the-slime> But I can't. It says "visit tags table".
09:00:47 <Ariakenom> So I have a {fixMemo :: ((Integer -> a) -> Integer -> a) -> Integer -> a} that memoizes the {Integer->a} mapping. But I can't figure out how to compose this to a 2 Integer argument function.
09:01:30 <Big_G> I was curious how many of you have had Haskell interviews? I have one lined up in a couple of weeks and I'm not sure how to prepare since online resources are sparse.
09:01:52 <Ariakenom> I got sniped by a reddit link to https://stackoverflow.com/questions/3208258/memoization-in-haskell/3209189#3209189 . Can anyone help?
09:20:53 <the_2nd> I'd like to make a quite simply multi-platform GUI, any frameworks / libs you'd suggest?
09:21:32 <MacSlow> Greetings everyone!
09:34:51 <fendor> the_2nd, it really depends on you use case, here you can find an overview https://wiki.haskell.org/Applications_and_libraries/GUI_libraries
09:35:52 <monochrom> Ariakenom: Perhaps a = Integer->b.  And perhaps the function stored is obtained by another use of fixMemo.
09:37:14 <nullie> where does the colored haskell logo originates from (https://ih1.redbubble.net/image.426834160.5575/flat,800x800,075,f.jpg)?
09:37:18 <Ariakenom> monochrom: Yes, I'm on the same track. It's the details that elude me.
09:39:11 <Ariakenom> I can't wrap my head around the implementation.
09:44:41 <lyxia> nullie: https://wiki.haskell.org/Haskell_logos/New_logo_ideas
09:51:15 <Ariakenom> monochrom, I have ssometihn that seems to work afaik. But shouldn't I have to use f'? http://lpaste.net/8039799283391660032
09:53:06 <Ariakenom> Well hard for you to tell maybe :p.
09:58:27 <sternmull> Holy crap, using haskell ide engine to look at pandoc exhausts my 16G RAM...
10:03:51 <ski> Ariakenom : i think you could use it instead of your two calls to `f m'
10:04:53 <Ariakenom> ski, Yes I could. But it seemed strange. Seemed like only calls that stay within the same m get to use the second memoisation?
10:05:26 <saksham> i-am-the-slime: Did you enable intero mode? There's M-x intero-global-mode, or M-x intero-mode if you don't want to use intero in all buffers. It should not ask you to visit TAGS table when the mode is enabled.
10:06:12 <ski> Ariakenom : hm, i think if you call  f'  then that will use the memoization on `inner'
10:06:14 <saksham> i-am-the-slime: If the issue still persists, I'd suggest you do "M-x describe-key <return> M-." and see what it is mapped to. It should be mapped to intero-goto-definition.
10:06:52 <ski> Ariakenom : you have one memoization "table" for `outer', then for every input `m' to that, you have a separate "table" for `inner f m'
10:06:52 <Ariakenom> I tried with trace and I get unique m,n pairs. But does the trace thing work as I think it does?
10:07:43 <ski> Ariakenom : but since you return the memoized function for `inner', from the `outer f m' call, that should mean that if you later call `outer' with the same `m', you get back the same table for `inner', which is good
10:08:34 <ski> i think the performance should be about the same, if you replaced the  f m  calls with  f
10:08:47 <Ariakenom> In {fixMemo (\f n -> ...)} Then the lambda is mapped over the table and f is lookup in the table.
10:09:06 <ski> Ariakenom : also, fwiw, you could define `inner f m' locally to `outer', inside a (nested) `where'. then you wouldn't need to pass `f' and `m' as parameters to `inner'
10:10:10 <Ariakenom> But if I don't use f'. Then I won't do a lookup in the second table?
10:10:43 <asdfer> how can I refer to the same IORef from different do blocks? I want something like "state :: IORef String" which can then be read and modified by other functions, but obviously using newIORef returns an "IO (IORef String)" instead of an IORef String
10:12:02 <ski> Ariakenom : iiuc, it doesn't matter whether you use  f'  or  f m  .. they should amount to looking up the result in the same table, regardless
10:16:45 <platz> can you control the order in which yesods julius scripts are emitted when it composes widgets?
10:18:02 <platz> i have julius script in thr layout widget but it renders last, id like the layout julius to render first sovots variablesnarenin scope for the rest of the widgets
10:18:25 <lyxia> asdfer: you can pass the reference as an argument to functions
10:22:16 <Ariakenom> ski, yes I suppose f m should return the lookup function. Hm tricky. Even though this works it's quite strange. There's many small definitions and an unused f' argument. Can you help me find a prettier way to go about it?
10:22:53 <ski> Ariakenom : "I suppose f m should return the lookup function" -- my understanding is that it already does
10:23:03 <asdfer> lyxia: I tried this but it doesn't seem to work: https://pastebin.com/LJqSVFcw
10:23:26 <ski> Ariakenom : (a) make an inner `where' as i suggested; (b) use  f'  instead of  f a  ?
10:23:28 <Ariakenom> Yes it does. I expressed myself poorly.
10:24:04 <ski> Ariakenom : also, instead of naming `outer' and `inner', you could use function abstractions (aka lambda expressions)
10:24:12 <Ariakenom> Closing over the variables is nice. I don't want f' though. It's unnecessary.
10:24:35 <ski> then use `_' ?
10:24:58 <ski> or use some `memo :: (Integer -> a) -> (Integer -> a)' instead of `fixMemo', if you want to use explicit recursion
10:28:51 <Ariakenom> Ah right. That memo version was helpful. I think I get it now.
10:28:52 <n1k0m1z3> ciaooo
10:29:11 <n1k0m1z3> !list
10:30:59 * ski notes monochrom appears to have removed the auto-reply to that
10:31:14 <nicknight> Hey all
10:31:49 <monochrom> heh
10:35:54 <Zemyla> Hmm, I find myself what goes wrong if you try to define a monad composition with the codensity transformation on the normal composition.
10:36:38 <Zemyla> @let newtype CompMonad n m a = CompMonad { runCompMonad :: forall r. (a -> m (n r)) -> m (n r) }
10:36:40 <lambdabot>  Defined.
10:39:33 <Ariakenom> ski, So this {test = memo $ \m -> memo $ \n -> ...} looks quite reasonable. Thanks a lot.
10:39:50 <ski>   CompMonad n m  =  Codensity (Compose m n)
10:39:55 <Zemyla> @let instance MonadTrans (CompMonad n) where lift m = CompMonad $ (>>=) m -- why n and m are reversed in the newtype definition
10:39:57 <lambdabot>  Defined.
10:40:22 <ski> oh
10:40:29 <ski> Ariakenom : yw
10:40:43 <Zemyla> @let liftN :: (Applicative m, Traversable n, Monad n) => n a -> CompMonad n m a; liftN n = CompMonad $ \c -> fmap (>>= id) $ traverse c n
10:40:45 <lambdabot>  Defined.
10:41:12 <Zemyla> The second lift requires a lot more from it.
10:41:17 <ski> Ariakenom : `fixMemo' can be useful if you want to try out different memoizing options (including no memoizing at all, say), for the same operation
10:41:48 <ski> `Traversable' in fact does sound quite onerous
10:41:56 <Zemyla> :t (>>= liftN) . lift
10:41:57 <lambdabot> (Monad m, Monad n, Traversable n) => m (n b) -> CompMonad n m b
10:42:18 <Ariakenom> Yes, indeed it was. But composed strangely to my eyes. But in contrast with the direct style it makes sense.
10:44:09 <epta> if '(%~) :: ASetter s t a b -> (a -> b) -> s -> t', is there smth like '... -> (a -> f b) -> s -> f t'?
10:44:42 <Zemyla> Using Codensity means it automatically satisfies the monad laws.
10:45:36 <Zemyla> And yeah, it's composed that way so it can be a MonadTrans.
10:46:47 <Ariakenom> ski, here's full code with fancy trees if you want http://lpaste.net/8039799283391660032
10:46:59 <ski> > ("False",True) & _1 %~ reverse
10:47:02 <lambdabot>  ("eslaF",True)
10:47:03 <ski> > _1 (pure . reverse) ("False",True)  :: Identity (String,Bool)  -- epta ?
10:47:06 <lambdabot>  Identity ("eslaF",True)
10:50:56 <Zemyla> Hmm, what should the prerequisites for Alternative (CompMonad n m) be? Alternative m or (Applicative m, Alternative n)?
10:52:27 <ski> @type (<|>) :: ContT o m a -> ContT o m a -> ContT o m a
10:52:28 <lambdabot> error:
10:52:28 <lambdabot>     • No instance for (Alternative (ContT o1 m1))
10:52:28 <lambdabot>         arising from a use of ‘<|>’
10:53:46 <ski> i'm not sure `Alternative' or `MonadPlus' is possible on `Cont o',`ContT o m',`Codensity m'
10:57:34 <saksham> Does anyone know why a thread (forkIO) which is running a pipes package computation, would not get killed with killThread or throwTo?
10:58:13 <Zemyla> :t \(CompMonad ma) (CompMonad mb) -> CompMonad $ \c -> ma c <|> mb c -- ski
10:58:15 <lambdabot> forall k (m :: * -> *) (n :: k -> *) a. Alternative m => CompMonad n m a -> CompMonad n m a -> CompMonad n m a
10:59:06 <ski> Zemyla : that will duplicate `c'. i'm not sure that's desirable
11:03:10 <Zemyla> ski: I've seen it done in things like parsers which are codensity encoded, like (Atto|Mega)?Parsec.
11:04:10 <ski> hm, ok
11:04:23 <ski> perhaps it wouldn't be as much of an issue as i imagined, then
11:07:07 <nicknight> Zemyla:  are you that cs50 lady ?
11:13:43 <fendor> saksham, thread is probably masked so it can't be interrupted by an async exception
11:14:04 <saksham> fendor: I see. Workaround?
11:15:35 <Zemyla> nicknight: The what?
11:15:39 <fendor> saksham, hm, maybe use pipes-safe?
11:16:08 <exio4> guys i love you
11:16:28 <fendor> @hackage pipes-safe
11:16:29 <lambdabot> http://hackage.haskell.org/package/pipes-safe
11:16:48 <cocreature> pipes-safe won’t remove masking
11:16:54 <cocreature> you need to figure out what is masking exceptions
11:17:34 <fendor> saksham, listen to cocreature ^^
11:18:04 <saksham> fendor: cocreature: Usecase: I wrote a library on top of pipes, and was writing a test to see whether some IO computation (after processing a message from a channel) was happening lazily.
11:18:22 <Zemyla> Who is that cs50 lady?
11:18:35 <cocreature> saksham: can you show us the code?
11:19:17 <cocreature> saksham: pipes itself doesn’t mask exceptions afaik so either you’re doing it yourself or some other library that you’re calling
11:19:39 <cocreature> or the forkIO never reaches the other thread for some reason although I’m not sure what could cause that
11:20:36 <cocreature> s/forkIO/throwTo/
11:22:18 <saksham> cocreature: https://github.com/sakshamsharma/indexed-queue/blob/master/test/Spec.hs#L51
11:23:52 <saksham> There's a FIFO channel (UnagiChan), which has a lot of messages of different types. This library's function timeFilterAction would run action when a message is received matching a particular type.
11:25:15 <saksham> And during this time, if some non-matching messages were received, it would store them in memory, for later use.
11:25:40 <saksham> Here's the pipes computation: https://github.com/sakshamsharma/indexed-queue/blob/master/src/IndexedQueue.hs#L123
11:27:04 <cocreature> what makes you think the thread doesn’t get killed?
11:28:30 <saksham> I set the timeout (of the pipes computation) to 4 seconds, and then killed it directly after the forkIO. The test run blocks after processing all the messages, and terminates after 4 seconds.
11:30:45 <cocreature> alright, "killThread" only returns after those 4 seconds so it looks like something is blocking the exception from being raised until then. I’m taking a closer look
11:32:28 <saksham> cocreature: Thanks! Meanwhile, I'm adding some comments to the main file (should've done it in advance)
11:33:53 <ski> hmm, i wonder whether there is a parallel operation, on the level of `par',`Eval',strategies or `Par', that tries two (or more) computations in parallel, aborting all the others when one of them succeeds (or fails, if preferred), not aborting on failure (or success, as the case may be)
11:34:12 <ski> (the idea would be to not have to use the `race' concurrency primitive at PCPH <https://web.archive.org/web/20170816074532/http://chimera.labs.oreilly.com:80/books/1230000000929/ch11.html#sec_conc-symmetric>, when we only want failure/success indication, rather then actually compute some more complicated result in the subcomputations)
11:34:32 <Zemyla> ski: unamb?
11:35:10 <ski> Zemyla : isn't it bad to use that, when the two values don't agree with each other ?
11:38:57 <ski> hm, looks like `asyncAnd',`asyncOr',`andMap',`orMap' in `lvish' <https://hackage.haskell.org/package/lvish-1.1.4/docs/Control-LVish.html> may be what i'm looking for
11:46:24 <saksham> cocreature: I just pushed a commit with (hopefully) informative comments on the functions, and a description of the use case in the README.md file.
11:48:51 <ski> @where Vital
11:48:51 <lambdabot> http://www.cs.kent.ac.uk/projects/vital/
11:48:55 <ski> @where+ Vital "Vital is a document-centered implementation of Haskell","The Vital project (acronym: Visual Interactive Typed Applicative Language) is investigating a /document-centered/ approach to functional programming with an emphasis on the display and /direct manipulation/ of complex data structures." (cf. spreadsheets) <http://www.cs.kent.ac.uk/projects/vital/>,<https://web.archive.org/web/20090529010107/http://www.cs.kent.ac.uk:80/projects/vital/>
11:48:55 <lambdabot> Okay.
11:50:16 <cocreature> saksham: so the problem is that your main thread has async exceptions masked for some reason and forkIO inherits the masking state from the parent. you can use "forkIOWithUnmask $ \unmask -> unmask myT" and it works
11:50:42 <cocreature> saksham: I’m not entirely sure why exceptions are masked in the parent thread. might be hspec
11:51:44 <saksham> cocreature: This is interesting. Yes, perhaps hspec. I'll read up on it. Thanks a lot!
11:52:51 <cocreature> saksham: at the very least hspec should document this, so it might be worth opening an issue. maybe it’s even unintentional, i.e., a bug
11:54:43 <ski> @where TV
11:54:43 <lambdabot> http://www.haskell.org/haskellwiki/TV
11:54:50 <ski> @where+ TV "TV is a library for composing /tangible values/, i.e., values that carry along external interfaces. In particular, TVs can be composed to create new TVs, /and/ they can be directly executed with a friendly GUI, a process that reads and writes character streams, or many other kinds interfaces. Values and interfaces are /combined/ for direct use, and /separable/ for composition." <http://www.haskell.org/haskellwiki/TV>
11:54:50 <lambdabot> Done.
11:55:07 <saksham> cocreature: Right. I'll open one in some time if I don't find it documented anywhere.
12:33:50 <saksham> cocreature: if I replace the runStateT $ runEffect computation with a threadDelay, the killThread works fine. Does this mean that this is not an hspec issue?
12:38:58 <cocreature> saksham: I doubt it, threadDelay is kind of weird since it’s built into the RTS. the fact thaf forkIOWithUnmask works but forkIO doesn’t hints pretty clearly that it’s a masking problem
12:43:00 <saksham> cocreature: So what would be a conclusive minimal test case to prove this is an hspec issue?
12:46:50 <saksham> I tried executing a long computation in the thread. I could kill it as well.
12:49:10 <cocreature> saksham: http://lpaste.net/363428
12:49:28 <cocreature> Unmasked outside of the test, MaskedInterruptible in the test
12:49:48 <cocreature> the Interruptible part is probably why threadDelay still works
12:50:22 <saksham> Nice. That's definitely a minimal test case :)
12:51:29 <ggVGc> error seems to be "Redundant do"
12:51:33 <saksham> I suppose you should create the issue, since I'm not 100% clear on this yet.
12:51:35 <ggVGc> ^ solved it
12:51:45 <ggVGc> (sorry)
12:52:18 <saksham> cocreature: ^ Do link if you create one. Else I'll create.
12:52:41 <cocreature> saksham: apparently my plan to offload the task to you didn’t work :)
12:53:15 <saksham> cocreature: Aah, I don't really mind. I'm doing it now.
12:53:32 <cocreature> saksham: nah, let me do it. it’ll only take 2 minutes :)
12:53:32 <saksham> Lemme know if you want a mention on Github.
12:53:44 <saksham> Hehe okay. Please share the link afterwards.
12:55:02 <heptahedron> I'm toying around making a unification framework, and am trying to obviate the need for separate "constant" and "functor" (a la prolog) types. After some brief thought, it seemed like the answer was to have the constant type be of kind `(* -> *)` and slap a Functor constraint on it, which led to a type isomorphic to the free monad. Now, however, I'm a bit stuck, because I want a way to enforce that two in
12:55:03 <heptahedron> this constant functor type have the same structure at the highest level--the same constructor arity--in order for unification to succeed. However, I can't really think of a typeclass that encapsulates, if one even exists
12:55:58 <heptahedron> It feels like it would sound something like "bitraversable", but that doesn't really make sense I don't think
12:58:16 <heptahedron> Okay apparently Bitraversable exists but I don't think it really captures the functionality I'm looking for, but I could be wrong
12:59:05 <cocreature> saksham: https://github.com/hspec/hspec/issues/349
13:00:25 <parsnip> someone did some wild fizzbuzz with some haskell thing in recent months?
13:01:41 <cocreature> parsnip: not quite fizzbuzz but your question made me think of https://aphyr.com/posts/342-typing-the-technical-interview
13:36:22 <asdfer> Hey all, I'm a bit confused about using IORefs, when i want a function to modify 8t am i supposed to pass the IO (IORef a) that "newIORef" returns or do i have to extract the IORef in a do block?
13:37:21 <jle`> asdfer: newIORef returns an IO action that produces an IO Ref
13:37:27 <jle`> so you have to execute it
13:37:30 <jle`> to get the IORef
13:37:38 <jle`> asdfer: just like how we have getLine :: IO String
13:37:50 <jle`> getLine doesn't contain a String, it is an IO action that produces a String
13:40:39 <sepakorayl> hello everyone
13:41:02 <sepakorayl> since the Errors form monoids, is it perhaps possible to get rid of the boilerplate? https://gist.github.com/liarokapisv/71b833cb5606c778812598a74b2ee50e
13:41:32 <sepakorayl> writing tD is very tedious
13:42:27 <jle`> you can use ExceptT to clean up some boilerplate
13:42:36 <jle`> but it doesn't take advantage of any monoid instances
13:43:31 <jle`> also, what is 'Monad m -> m (Either DError D')' supposed to mean?
13:43:33 <asdfer> jle`: I understand how it works within the same block, but im trying to do something like "strings :: IORef String" which i can then pass around to different functions in a repl that modify it, however the only way i know to create one is newIORef and that returns the action. I can pass the action to the function, execute it, modify it and print it just fine, but when i use it in another function later it's still the un
13:43:56 <jle`> asdfer: your message might have gotten cut off
13:44:05 <sepakorayl> just an example in reallity it may be something like MonadState _ m
13:44:23 <jle`> sepakorayl: do you mean => instead of -> ?
13:44:30 <sepakorayl> ah yes typo
13:44:33 <jle`> sepakorayl: also, line 41 doesn't quite typecheck; i'm not sure waht you mean
13:44:36 <jle`> do you mean to use 'let' instead of <- ?
13:44:41 <jle`> or are you actually in Maybe ?
13:44:43 <asdfer> 1) I understand how it works within the same block, but im trying to do something like "strings :: IORef String" which i can then pass around to different functions in a repl that modify it
13:44:52 <asdfer> 2) however the only way i know to create one is newIORef and that returns the action. I can pass the action to the function, execute it, modify it and print it just fine, but when i use it in another function later it's still the unmodified version.
13:45:02 <asdfer> Sorry, I'm on a phone
13:45:05 <sepakorayl> jle: this is mostly pseudocode, sorry for posting it like that
13:45:16 <jle`> sepakorayl: no need to be sorry; just need to be able to understand it enough to be able to help
13:45:17 <dgpratt> one of the things I appreciate about stack, at least in theory, is the "stack new" command one can use to start a new project based on a template; but these days I'm trying to see how things go using nix and now I'm wondering if there's a more general tool or solution to starting a fresh Haskell project based on a template?
13:45:43 <jle`> asdfer: you wouldn't pass an IO (IORef a) to a function
13:45:50 <jle`> asdfer: you would pass an IORef a to a function
13:45:59 <jle`> mything :: IORef Int -> IO ...
13:46:02 <jle`> etc.
13:46:38 <jle`> think of 'IORef Int' as a pointer; passing an `IORef Int` is basically like passing a pointer to some mutable container storing Int's
13:46:41 <sepakorayl> I am writing a compiler and I want a good way to handle the errors.
13:47:01 <sepakorayl> the thing is I don't quite want short circuiting since I want to collect as many error info as possible
13:48:10 <jle`> sepakorayl: you can use the 'Erorrs' Applicative that merges all errors encountered together
13:48:19 <jle`> so you can sequence multiple actions together and collect their results
13:48:25 <jle`> or else collect all of the errors monoidally
13:49:20 <sepakorayl> I was looking at Errors specifically
13:49:26 <sepakorayl> hence the monoids
13:49:38 <sepakorayl> not sure if the transformations are worth it
13:50:06 <jle`> if you post some actual code that works that demonstrates what you want, we might be able to simplify some boilerplate
13:50:10 <asdfer> jle`: Exactly, but I can't seem to get how to get a function of type :: IORef String, for example i cant do "myRef = do {ref <- newIORef "someString"; return ref}"
13:50:31 <jle`> sepakorayl: a lot of problems happen too when you try to ask for something 'that works for all monads', but really you only carea bout a specific monad
13:50:46 <jle`> so a lot of time is wasted trying to find an answer that is polymorphic for all monads
13:50:56 <jle`> but really the answer is very simple for a specific monad
13:51:07 <jle`> so posting your actual problem can be helpful :)
13:51:27 <jle`> asdfer: why would you want a function to return an IORef String ?
13:51:29 <delYsid> I am running into several walls while trying to fork the diagrams rasterific backend to render text differently (not via Rasterific).  Trying to change the RenderM type from using ReaderT to something that provides a tell (RWST), I run into the monad channeling problem around mapReaderT which refuses to be changed to mapRWST for a case relevant to the existing code.  OK, trying to get fancy.  Why not walk/modify the Rasterific free
13:51:30 <delYsid> monad before rendering it?  Oh no, Graphics.Rasterific.Command.DrawCommand is not exported!  With my limited haskell fu, I feel like I lost and have been *bound* by functional programming, unable to do what I need.  Any further ideas?  Why is it that, whatever simple thing I seem to do, I end up hitting esoteric corner cases all the time?!
13:52:11 <jle`> asdfer: really working with IORefs, you're going to be writing things that consume them more often than create them
13:52:15 <jle`> foo :: IORef a -> ...
13:52:31 <jle`> the act of creating an IORef has to be done in IO, of course, but once you create it, you can pass it to functions like foo
13:52:46 <sepakorayl> jle: I am open to adding another Constraint if I have to
13:53:07 <jle`> sepakorayl: yes, but what monad are you actually using this on?
13:53:21 <jle`> what if i told you that it's really simple with the constraint (m ~ Identity)? :p
13:53:27 <jle`> or even simpler with constraint (m ~ Proxy)
13:53:50 <asdfer> I dont understand how to pass the same IORef to functions in different blocks, i get how it gets created and passed around in the same block
13:54:20 <jle`> asdfer: you pass the same IORef by providing it as an argument
13:54:23 <jle`> 'foo myRef'
13:54:31 <sepakorayl> jle: I will get back to this later thanks for the help
13:54:58 <jle`> asdfer: can you give a specific situation where you are having issues using IORefs?
13:55:04 <jle`> it sounds like you might be stuck on an A/B problem
13:55:09 <jle`> er sorry, X/Y problem
13:55:26 <jle`> http://xyproblem.info/
14:05:03 <asdfer_> jle`: sorry it's hard typing on a phone. I basically want to be able to add or remove strings to a list in runtime, to keep track of parameter names while live coding. So something like: "addString "param1"; addString "param2"; getStrings == ["param1", "param2"]"
14:05:51 <jle`> you'd probably have to define addString in terms of an IORef
14:05:55 <jle`> so if you're in ghci, you can do
14:06:09 <jle`> r <- newIORef ([] :: [String])
14:06:23 <jle`> addString s = modifyIORef r (++[s])
14:06:31 <jle`> getString = readIORef r
14:07:05 <jle`> it should work in modern ghci's; you might need to write `let addString s = modifyIORef r (++[s])` if you're in an older version of ghci
14:07:41 <jle`> getStrings wouldn't be equal to ["param1","param2"] in that case; but if youe xecute the IO action, you'll get that as a result
14:08:06 <jle`> this will work if you define 'r' and 'addString' within ghci
14:09:00 <asdfer_> and how do I define r to be a reference and not an action to create one?
14:11:03 <jle`> that's what `r <- newIORef ([] :: [String])` does
14:11:27 <jle`> if you have an action 'myAction :: IO X', then for `a <- myAction`, `a :: X`
14:12:55 <asdfer_> yes, but isn't that a in the scope of the do block with the action-bind statement only?
14:13:06 <jle`> yes
14:13:15 <jle`> in ghci though, it is in the global scope
14:13:19 <jle`> since ghci has special syntax/scoping rules
14:13:55 <asdfer_> ah ok, that's what I couldn't understand
14:14:50 <asdfer_> jle`: thanks a lot, that was very helpful :)
14:15:05 <jle`> no problem :) yeah, anything you bind in ghci can be used after the binding site
14:19:59 <asdfer_> jle`: is it possible to predefine a function that only adds/removes/reads a specific IORef and does not expect it as an argument?
14:20:42 <jle`> yes, but very carefully
14:21:04 <jle`> yes, but very carefully
14:21:37 <jle`> https://wiki.haskell.org/Top_level_mutable_state
14:21:54 <jle`> note that there are only a few situations where this makes sense
14:22:07 <jle`> yours in particular (interactive usage, in ghci) is probably one of them
14:23:01 <jle`> that article offers some solutions as well as some alternatives
14:24:45 <jle`> asdfer_: general guidelines are to *never* export the actual IORef to the user
14:25:18 <asdfer_> jle`: thanks, that's exactly what I have been looking for all day!
14:25:39 <jle`> no problem :) yeah, and understand that this is hacky and definitely *not* normal usage of IOREfs
14:26:02 <jle`> which only makes sense in very specific situations
14:26:51 <jle`> asdfer_: this is essentially how the 'random' library handles getting random values in IO
14:27:26 <jle`> the user isn't ever meant to directly manipulate the global seed, but rather use functions that the library carefully exports to provide a pure api
14:44:11 <Tuplanolla> This is about as hacky as serializing data into a temporary file.
14:57:14 <ircvit184580> text
14:57:36 <geekosaur> bytestring
14:57:37 <geekosaur> >.>
15:29:55 <ertes> any recommendations for TH tutorials?
15:30:33 <ertes> i need to generate code (instances) from ADTs
15:35:21 <fendor> ertes, just the usual, the documentation is pretty good as well
15:39:40 <ertes> what is "just the usual"
15:39:41 <ertes> ?
15:40:39 <catern> hey #haskell, is there a list of useful monads somewhere? I want a list of example monads
15:41:06 <fendor> https://wiki.haskell.org/Template_Haskell
15:41:24 <fendor> that example was imo accetpable, i think slightly outdated
15:42:15 <geekosaur> ^ which is the problem with tutorials. potentially TH can change incompatibly with every ghc major release
15:43:05 <geekosaur> there was at one point a TH preprocessor for use on archs that didn't support TH (e.g. arm for a long time). zeroth on hackage
15:43:28 <geekosaur> it died when two successive ghc releases changed TH enough that it was incompatible, and they couldn't afford the time to keep up
15:44:02 <fendor> yeah, main resource is the documentation
15:46:39 <ertes> by "the documentation" you mean the GHC manual?
15:47:49 <woodson> is it possible to get the fields of a record by with a Proxy?
15:48:06 <woodson> so, Proxy :: Proxy MyRecord
15:54:26 <fendor> no, hackage documentation
15:57:14 <ertes> ok, thanks…  nevermind though, i think i can use generics here
15:57:26 <ertes> which i much prefer over TH
16:03:25 <fendor> understandable. same
16:03:40 <fendor> but they are cool anyways
16:09:12 <doomrobo> hey, is it possible to run stack test on a module without having to build the whole thing? I'm making some incremental changes to the module and there are some tests that don't require the whole thing to compile. Currently, stack will build the whole module even when my Test module is completely empty
16:12:54 <ertes> ok, new question:  according to the base docs, i shouldn't rely on a specific association of (:*:), but i'm trying to target a specific field, which means i'd need to write two instances:  instance (Blah f) => Blah (f :*: g);  instance (Blah g) => Blah (f :*: g)
16:12:58 <ertes> but these are overlapping
16:13:09 <ertes> what's the proper way to approach this?
16:17:22 <lyxia> index the class by a path to the field that you can compute with a type family
16:18:30 <ertes> thanks
16:23:21 <doomrobo> hmm, so it looks like stack test will do a stack build with tests included, so I assume there's no way to get it to build a subset like that
16:26:42 <lyxia> doomrobo: What do you call a "module"?
16:27:06 <lyxia> you mean the package?
16:27:13 <doomrobo> yes I do, sorry
16:28:21 <lyxia> well, there's the package that consists of a library, executables and tests, and stack will always build the whole library and executable
16:29:05 <lyxia> For development you could just comment out the library modules you don't need if they depend on stuff you are changing
16:30:53 <doomrobo> lyxia, yeah, that's one way to go. I think I'd have to modify a few files to do that. I'm gonna try to see if I can run the tests within ghci
16:31:56 <pavonia> lyxia: Do you have an example for your response to the previous question? How would such a type family look like?
16:48:44 <lyxia> pavonia: something like this http://lpaste.net/363435
16:51:57 <pavonia> Oh wow, that looks complicted
16:55:12 <lyxia> there's a lot of noise because the type-level language is kind of awkward
16:56:42 <pavonia> In line 25, why do you use "a' ~ a"? instead "a" twice?
16:58:37 <lyxia> pavonia: it makes type inference easier. If you use "a" twice, then the instance will only be selected if the result type can already be determined from the context
16:59:19 <lyxia> With a type equality, the instance will match even if the result type is still unknown, and then the type equality will unify it with the field type
16:59:33 <lyxia> which means that in getField, b can be inferred from a
17:00:50 <lyxia> or conversely, if the record has a field of unknown type, then it can be inferred if you know b.
17:01:46 <lyxia> pavonia: also, if you refresh you'll see an annotation at the bottom with a more readable version of the type families
17:01:54 <lyxia> only it's not actually haskell
17:04:07 <pavonia> Ah, thank you
17:49:28 <progfunhere> hello
17:50:03 <lyxia> hi
17:53:27 <progfunhere> hi lyxia
17:54:11 <progfunhere> I want to write a quickCheck test for a partition function
17:55:36 <progfunhere> can I use the property of conjugate partitions for the test?
17:56:14 <progfunhere> Reference: https://brilliant.org/wiki/partition-of-an-integer/
17:58:02 <lyxia> why couldn't you use it?
17:58:31 <progfunhere> yes, I could use it
17:59:19 <progfunhere> I mean, what are the kinds of properties best suited to use with quickCheck?
17:59:43 <progfunhere> it this a good one to use?
18:01:40 <progfunhere> any thoughts?
18:05:18 <c_wraith> quickcheck is good in a number of situations.  When you have two implementations and want to be sure they produce the same results.  When you have well-known postconditions (a sort algorithm produces sorted data).  When you have relationships between operations that you want to verify (read . show = id).  Probably a lot more.
18:06:54 <c_wraith> One time I used quickcheck to do postcondition testing on a data structure by having it generate a sequence of operations to perform and verifying all the data structure invariants after each operation.
18:08:33 <progfunhere> Thanks. Ok, so conjugate partitions would qualify as a known post-condition of partitioning
18:08:38 <c_wraith> indeed
18:24:57 <pavonia> lyxia: Re that trick you explained earlier, using a' ~ a instead of duplicate a's, is there a situation where you don't want to use this instead of the standard version?
18:26:07 <c_wraith> pavonia: it's most commonly used when writing instances or constraints, because it helps the compiler resolve them by deferring the equality
18:26:13 <pavonia> I just tried that type equality on something I'm working on and it looks like it helps to remove some annoying type arameter I had to use to satisfy the type checker
18:28:15 <pavonia> c_wraith: But are there cases where you actually don't want it?
18:29:30 <c_wraith> Well, when the polymorphism is strictly parametric, it only makes things more complicated.
18:30:57 <pavonia> What is strictly parametric polymorphism?
18:31:05 <c_wraith> :t map
18:31:07 <lambdabot> (a -> b) -> [a] -> [b]
18:31:18 <c_wraith> No bounds on the type variables.
18:32:03 <c_wraith> You could write that type as (a ~ c, b ~ d) => (a -> b) -> [c] -> [d]
18:33:00 <c_wraith> But there's no benefit, because without a class constraint, the type variables never get confusing to the compiler anyway.
18:33:01 <orzo> The xmonad source has an operator (-->) which vim confuses with a comment.  How does ghc's lexer not become confused by it?  The lexer treats it as a comment if there's no operator in scope?
18:33:29 <c_wraith> orzo: the lexer doesn't know what's in scope
18:33:37 <orzo> then how does it compile
18:33:54 <c_wraith> orzo: the rule is that any sequence of two or more dashes followed by whitespace initiates a comment
18:37:50 <pavonia> c_wraith: Just to see if I got that right, with that type equality the compiler first uses the seemingly general instance it finds and afterwards tries to match the two types; without it, it doesn't find the right instance in the first place because it doesn't know yet that the types are the same?
18:38:55 <c_wraith> pavonia: that's correct
18:39:29 <pavonia> Okay, thanks
18:40:03 <orzo> c_wraith: you must have the rule not quite right, --foo is a comment
18:40:28 <c_wraith> orzo: must be the up until it reaches a non-operator character.
18:40:37 <orzo> ya probably
18:41:00 <c_wraith> Hmm, I think that's not quite right either, because haddock can use --!
18:41:15 <orzo> ghci doesn't like --!
18:41:46 <c_wraith> I must not remember what haddock does properly
18:42:13 <glguy> orzo: https://glguy.net/haskell.vim
18:42:28 <glguy> The default Haskell source file highlighter for vim is buggy in a bunch of ways
18:46:20 <orzo> thanks, glguy. I'm not using the default though, i have my own hacks to it.  I'm not sure how to merge now
18:46:49 <glguy> If you have a a fix I'm missing I will just add it to mine
18:47:36 <orzo> i mainly added quasiquote hilight and _todo hilight
18:51:35 <orzo> glguy, my version: http://lpaste.net/363437
18:52:54 <orzo> i'm not sure if one obsoletes the other but yours doesn't have changelog entries missing from mine
18:54:26 <glguy> I made a bunch of manual fixes, didn't bother editing the changelog
18:54:31 <orzo> ah
18:56:46 <koz_> I just installed Stack on Gentoo, and I get this error every time I try to do something with it: AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
18:56:53 <koz_> What does this mean exactly and why does it keep happening?
18:56:56 * Wizek Hello. Has anyone here ever profiled reload times with ghci{,d}? Some modules take 5-10 seconds after save to reload while others take less than a second, and I'd to get an idea what contributes to the slowness.
18:57:06 <glguy> koz_: That error happens because your stack is too old
18:58:16 <koz_> glguy: OK, that's kind of an issue.
18:58:43 <koz_> Gentoo's Stack version is 1.3.2
18:59:53 <koz_> I might just chime in on #gentoo about it then.
19:04:33 <sepaorayl> hello guys
19:05:52 <sepaorayl> is there some way to have f :: (AsDiskBad e) => r, g :: (AsTopLevel e) => r, and define f = g? https://gist.github.com/nkpart/c3bcb48c97c5ded6e277
19:06:03 <sepaorayl> sorry that's g = f
19:40:12 <w1n5t0n> Hey all, is it possible to make the tilde a function of one argument for a DSL? I would like to be able to do something like "~ myArgument"
19:40:57 <w1n5t0n> or any other operator that's mappable for that matter!
19:42:08 <lyxia> (~) myArgument
19:59:18 <w1n5t0n> lyxia: Is there any way to remove the parentheses? When live coding there is a big difference between typing "~" and "(~)", especially if you use that function a lot!
20:06:35 <parsnip> w1n5t0n: operator symbols are always infix
20:07:39 <parsnip> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
20:09:44 <parsnip> w1n5t0n: i think you can set to a letter though, like `z = (~)`
20:09:58 <parsnip> or maybe `op = (~)` is better?
20:11:18 <lyxia> sepakorayl: http://lpaste.net/363440
20:22:50 <preyalone> what's that lil helper functor that loops over input, does an action, and repeats forever? like a REPL-style convenience function?
20:23:24 <preyalone> ah, interact
20:24:00 <w1n5t0n> parsnip: hmm the idea was to use the ~ as a visual mark of code that represents waves, but I'll see if I can have Emacs replace it with a normal function call before sending the string to the interpreter! thanks :)
20:26:22 <parsnip> i think emacs has some prettify thing
20:26:53 <parsnip> maybe it can replace `~` with `wave`
20:30:29 <woodson> hi guys, I am trying to use generics-eot library https://github.com/soenkehahn/generics-eot/blob/master/docs/tutorial.md. I followed the first example which works in ghci
20:31:09 <woodson> however, when I try to integrate in a function that I defined I am getting this error Couldn't match type ‘Rep a’ with ‘M1 D c1 f1’
20:32:34 <parsnip> w1n5t0n: (info "(emacs) Misc for Programs")
20:32:43 <woodson> her is part of the code http://lpaste.net/363441
20:32:53 <woodson> can anyone assist?
20:33:04 <parsnip> w1n5t0n: C-h f prettify-symbols-mode
20:33:43 <lyxia> woodson: paste your full code
20:35:29 <woodson> lyxia: I think that most of the needed parts are in there. The code is connect to other Modules
20:35:35 <w1n5t0n> parsnip: yeah that's what I was looking for! thanks!
20:35:49 <woodson> ill add a bit more
20:35:55 <parsnip> :)
20:36:47 <lyxia> woodson: where is the error
20:37:35 <woodson> just noticed that I didnt added it
20:37:38 <woodson> adding it now
20:38:22 <woodson> lyxia: done
20:39:11 <`Guest00000> foo 0 = []
20:39:16 <`Guest00000> foo (S n) = foo n : foo n
20:41:41 <orzo> glguy: I've merged your fixes with my changes along with changes from upstream vim.git
20:42:59 <lyxia> woodson: namesOfFields has a HasEot constraint but in getSObject'' you only have a Generic
20:43:05 <lyxia> woodson: replace Generic with HasEot
20:44:03 <sepakorayl> lyxia: thanks! how would I go about writing something like foo :: (Monad m, AsTopLevel e, Monoid e) => m (AccValidation e ()) etc?
20:44:52 <woodson> lyxia: Still getting the same error, I would expect the compiler to be able to tell me this too
20:45:08 <woodson> or it wouldnt be able to recognize this mistake?
20:46:02 <orzo> glguy: https://github.com/joecrayne/haskell.vim
20:46:23 <orzo> branch "joe" has it all, "glguy" has your changes isolated, and master tracks upstream
20:53:51 <lyxia> woodson: Unfortunately GHC just doesn't produce good messages with the way HasEot is defined
20:57:49 <lyxia> sepakorayl: what is AccValidation
20:58:36 <lyxia> Ah is it renamed to validation now?
20:58:59 <lyxia> sepakorayl: I'm not sure what you are trying to do now
20:59:21 <lyxia> It's not a Monad
21:00:35 <`Guest00000> is there an existing language where "foo (S n) = foo n : foo n" is possible EXACTLY, without wrappers?
21:02:09 <sepakorayl> ideally I would like to have a conversion class hierarchy for errors so fromA implies fromB which implies fromC etc so I would like to express that "this function can create any error constructed via X"
21:02:22 <sepakorayl> not sure if it's possible
21:02:45 <sepakorayl> currently I just constantly first my errors
21:06:36 <c_wraith> `Guest00000: you can do that in Haskell, if you set things up precisely right.  But...  Why?
21:06:57 <`Guest00000> c_wraith: without wrappers?
21:07:02 <`Guest00000> how?
21:07:16 <c_wraith> `Guest00000: it requires making foo part of a class.
21:07:38 <c_wraith> class Foo a where foo :: Nat -> a
21:11:41 <c_wraith> instance Foo Int where foo = fromIntegral ; instance Foo [a] where { foo = (S n) = foo n : foo n ; foo Z = [] }
21:11:45 <c_wraith> give or take
21:14:01 <blankhart> anyone know why the typechecker doesn't terminate on this, or how i'd go about fixing it? http://lpaste.net/363444 - it's looping on line 17
21:14:12 <c_wraith> You know, fixing my syntax errors and such
21:14:31 <`Guest00000> c_wraith: that wouldn't have intended meaning
21:14:40 <`Guest00000> foo 0 = []
21:14:43 <`Guest00000> foo 1 = [[]]
21:14:45 <c_wraith> you didn't specify an intended meeaning
21:14:47 <c_wraith> *meaning
21:14:52 <`Guest00000> foo 2 = [[[]], []]
21:15:21 <`Guest00000> foo 3 = [[[[]], []], [[]], []]
21:15:23 <`Guest00000> and so on
21:15:50 <c_wraith> I doubt you'll find any existing language with a type system that allows values like those with the syntax you provided.
21:16:01 <`Guest00000> foo infinity = foo infinity : foo infinity
21:17:17 <c_wraith> blankhart: GHC's type checker doesn't really know anything about Nat.  In particular the (-) type operator is purely symbolic to it.
21:17:39 <blankhart> oh.
21:19:27 <blankhart> thanks.
21:20:15 <c_wraith> blankhart: yeah..  For now, doing something like that at the type level requires a lot of pain.  So much so that there's a series of papers about it that mention "hasochism"
21:20:39 <`Guest00000> foo :: (n :: N) -> f n = case n of 0 -> [a]; S n' -> [f n']
21:21:19 <`Guest00000> "pat = expr" here meaning "let pat = expr in pat"
21:21:22 <c_wraith> blankhart: there are plans to improve it!  Maybe by 2022 you will be able to apply the standard value-level modulus operator at the type level.
21:22:39 <c_wraith> ...  man, "maybe by 2022" used to mean "unbelievably far in the future".  In this case it actually means "There's a plan in place, and it's reasonable to think it might have been completed by then."
21:22:42 <blankhart> hrm. the type-level lib on hackage implemented a typelevel modulus, but the source looked very involved
21:22:50 <blankhart> probably the kind of pain you mean
21:22:54 <c_wraith> yeah
21:24:00 <blankhart> the typechecker doesn't know about Nat because the TypeLits import is an internal compiler implementtion?
21:24:58 <blankhart> or just because it sees the type as the construct and can't reduce it
21:25:04 <c_wraith> It's more that it's far beyond what Haskell's type system was originally designed to handle.
21:25:25 <c_wraith> So it's really just treated as an opaque type internally.
21:26:43 <c_wraith> You might be interested in ghc type checker plugins.
21:27:22 <c_wraith> There are a few that extend Nat with real arithmetic.
21:28:40 <c_wraith> For instance, https://github.com/yav/type-nat-solver is quite capable - but also rather involved to use.
21:29:06 <blankhart> interesting.  i am content for now thinking about the interaction of the types and kinds themselves, but will plan to take that repo to the beach this summer
21:29:48 <c_wraith> the main reason it's involved to use is that it requires setting up an SMT solver on your system.  Once you've done that, it's fine.  But it's an extra configuration step
21:30:14 <blankhart> oh there is a whole paper, that will make it more digestible
21:30:59 <c_wraith> On the plus side, SMT solvers are really cool and can handle all sorts of arithmetic proofs.
22:12:47 <woodson> anyone familiar with generic-eot library??
22:40:26 <blankhart> c_wraith: this small revision seems to work. http://lpaste.net/363446
22:42:30 <pikajude> why is IO a Quasi instance?
22:42:52 <pikajude> what would you be able to do in IO?
22:48:27 <guessWho> what's the best logging library for haskell which is more suitable for multithreaded programming >?
22:49:02 <c_wraith> pikajude: mostly I use it to run splices in ghci to make sure they produce the code I expect
22:55:43 <c_wraith> pikajude: try this in ghci - runQ [| f $(listE [ [| x + 1 |] | x <- [1..5] ]) |]
22:55:58 <pikajude> whoa
22:56:01 <pikajude> that's awesome
22:56:17 <c_wraith> that's what *I* use the Quasi instance of IO for. :)
22:59:31 <guessWho> cocreature : what's the best logging library for haskell which is more suitable for multithreaded programming >?
23:03:36 <mjrosenb> ugh.  I Had a function solve :: a -> [a] which takes a *long* time to return a single value, and can return thousands of values
23:04:23 <mjrosenb> I wanted it to print a progress report, so I re-wrote it a bit so it is now solve :: a -> IO [a]
23:04:38 <mjrosenb> but I can no longer just grab the first element that it returns
23:04:50 <mjrosenb> I now need to wait for the *whole* list to finish
23:05:24 <c_wraith> mjrosenb: a -> [Either StatusUpdate a]
23:07:41 <mjrosenb> that is an interesting idea, unfortunately, unless there's a fairly mechanical way to do that, I think I'm going to modify it to take as an argument the number of results to return.
23:08:44 <peteretep>  I have a 5-tuple, and a function that takes 5 arguments. Is there a graceful way to basically do an uncurry5?
23:09:13 <c_wraith> You can actually use a free monad to create a Progress monad, then write the algorithm in do notation a lot like it would be written for IO, except you can then run it to get a list like that back
23:09:56 <mjrosenb> "free monad", you say?
23:10:43 <c_wraith> Oh.  If you aren't familiar with them, ignore that part.  It's a kind of generic monad for some uses, but if it's something you don't already know about, you can just skip
23:11:23 <`Guest00000> how is it called when you put an @ in front of the function name in its definition?
23:11:31 <c_wraith> `Guest00000: as-pattern
23:12:02 <c_wraith> `Guest00000: assuming you meant "in front of a pattern match", anyway
23:13:38 <`Guest00000> no, there was a special variety
23:15:07 <`Guest00000> @let fib@(_:fibt) = 0 : 1 : zipWith (+) fib fibt
23:15:09 <lambdabot>  Defined.
23:15:15 <`Guest00000> > fib
23:15:17 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:15:35 <vaibhavsagar> that's a pattern match
23:15:46 <mjrosenb> that's special notation for lambdabot.
23:15:50 <geekosaur> that's an as-pattern in a pattern match
23:16:06 <geekosaur> you may be thinking of it wrong; fib is not a function, its just an expression that takes advantage of laziness
23:16:08 <`Guest00000> that can also be top-level
23:16:24 <`Guest00000> this doesn't support function arguments, right?
23:16:25 <c_wraith> mjrosenb: there's nothing lambdabot-specific in there
23:16:30 <`Guest00000> i somehow thought it did
23:16:43 <mjrosenb> c_wraith: I was looking at the @ before the let, not the @ after the fib.
23:17:01 <c_wraith> mjrosenb: oh.  well, ok.  I was wrong, that is lambdabot-specific
23:17:27 <`Guest00000> geekosaur: function with 0 args :p
23:17:45 <geekosaur> in haskell there isn't really such a thing
23:18:04 <geekosaur> and this situation is why we say that; trying toc onstrue fib there as "fucntion" will just confuse you
23:18:11 <geekosaur> guh, typiong
23:18:26 <geekosaur> fib is a name for a lazy list, not a function
23:18:58 <geekosaur> you are both naming the list itself (fib) and deconstructing it into its head and tail, then extracting the tail (fibt)
23:20:32 <geekosaur> 'fib@' - as-pattern naming the list
23:20:49 <`Guest00000> i was hoping to have something like   (funcName arg1 arg2 arg3)@result = expr arg1 arg2 arg3 result   , but my memory upset me
23:20:54 <geekosaur> '(_:fibt)' - list as head:tail, ignoring the head and binding the tail as 'fibt'
23:21:07 <geekosaur> no, functions are not patterns
23:21:39 <`Guest00000> well, that's just   funcName arg1 arg2 arg3 = let result = expr arg1 arg2 arg3 result in result
23:22:11 <`Guest00000> hm, meanwhile, really, a good idea for an extension; let's add it to the big list
23:23:17 <guessWho> glguy : when we put something in extra dependencies in stack.yaml what does really happen behind the scene
23:25:36 <`Guest00000> haskell must be terse
23:27:26 <geekosaur> just remember that "terse" can mean "concise"  or it can mean "unreadable". an as-pattern in the right place can get you the first, but abuse of them can turn quickly into the second
23:27:59 <geekosaur> (or worse, "incomprehensible" instead of merely unreadable)
23:28:26 <`Guest00000> "let result = result in result" is just fluff
23:28:30 <geekosaur> I mean, if brevity is all you care about, there's APL.
23:28:45 <`Guest00000> which can be avoided with this simple sugar rule
23:28:58 <`Guest00000> not all
23:29:04 <`Guest00000> but i think this is quite fine
23:30:09 <`Guest00000> why have all those combinators then, if ones can be expressed in terms of others
23:31:16 <cocreature> combinators are at least not an extension to the syntax of the language
23:31:22 <guest__> hi guys, I am trying to use https://hackage.haskell.org/package/cryptonite-0.25/docs/src/Crypto-PubKey-ECIES.html library that uses ` curveGenerateKeyPair` funtion from https://hackage.haskell.org/package/cryptonite-0.21/docs/src/Crypto-ECC.html this library and Crypto-ECC uses Crypto.PubKey.ECC.P256 for  `scalarGenerate` function, how can i modify  this `scalarGenerate` function without modifying all those libraries?
23:31:51 <`Guest00000> cocreature: what do you mean?
23:33:32 <cocreature> `Guest00000: for operators defined in libraries, I can just type them in hoogle or whatever, find the definition, look at the type signature, look at the source and understand them. that’s a lot harder for builtin syntax like your extension to @-patterns
23:34:15 <`Guest00000> open compiler's manual's section for extensions
23:34:37 <`Guest00000> but does it look unintuitive?
23:35:30 <geekosaur> ...the matrix had you
23:35:32 <cocreature> if anything it should be result@(funcName arg1 arg2 arg3) to match the existing @-patterns and even then I don’t think we should add syntax extensions to save 10 characters
23:35:48 <`Guest00000> not only 10 characters in the source file
23:36:07 <`Guest00000> the 10 characters also in the mind of the human reader
23:36:24 <`Guest00000> and also all associated parsing structures
23:36:32 <`Guest00000> (in the mind)
23:36:38 <cocreature> I don’t think so. as a human I want the @-pattern and the let statement to be represented pretty much identically in my mind
23:37:03 <guest__>  hi guys, I am trying to use https://hackage.haskell.org/package/cryptonite-0.25/docs/src/Crypto-PubKey-ECIES.html library that uses ` curveGenerateKeyPair` funtion from https://hackage.haskell.org/package/cryptonite-0.21/docs/src/Crypto-ECC.html this library and Crypto-ECC uses Crypto.PubKey.ECC.P256 for  `scalarGenerate` function, how can i modify  this `scalarGenerate` function without modifying all those libraries?
23:37:14 <cocreature> anyway, you can always try making a ghc-proposal but I’m quite sure it won’t go anywhere :)
23:37:25 <`Guest00000> cocreature: no. result is a pattern. "funcName arg1 arg2 arg3" is almost like "valueName"
23:37:40 <`Guest00000> result is bound to function's returned value
23:38:09 <`Guest00000> but could be any pattern
23:38:18 <`Guest00000> (f x)@(h : t) = ...
23:38:46 <`Guest00000> ghc-proposals are hopeless
23:40:03 <cocreature> *shrug*
23:55:29 <c_wraith> mjrosenb: http://lpaste.net/6834401773873004544
23:55:51 <c_wraith> mjrosenb: If you're curious how to implement/use a monad like I was talking about
23:57:25 <c_wraith> mjrosenb: the whole thing could be done without any sort of free monad, but it was easier to use a library to write the instances for me
