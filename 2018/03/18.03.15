00:03:33 <shafox> srk: yeah not a vim user. anyone using sublime/vscode ?
01:33:38 <guessWHo> how to generate a 8 digit random number in haskell >?
01:35:26 <cocreature> guessWHo: Word8 is an instance of Random, so you can just use something like "randomIO"
01:35:58 <joncol> Hi, I'm trying to send an error that is generated in a Yesod application to Honeybadger by using the Ratel library. My problem is that I don't know how to get the exception object with the callstack of where the error occured. I'm doing the error handling/reporting in `handleError`, which is in a different place then my handler that caused the error. Does anyone here know something about this?
01:36:47 <joncol> Ratel expects the exception as an argument, so that it can show the stack trace on the honeybadger.io page.
01:37:17 <guessWHo> cocreature :: "m <- randomIO :: Word8" like this ??
01:38:21 <cocreature> guessWHo: no, look at the type signature of randomIO: it has type "Random a => IO a", so you need to use "randomIO :: IO Word8"
01:39:50 <dminuoso> With ScopedTypeVariables you could do: a :: Word8 <- randomIO
02:06:14 <guest_> I was reading some haskell code came across this symbol `=<<` what it means and when this is used, I am new to haskell
02:06:45 <dminuoso> guest_: It's just a flipped >>=
02:06:48 <dminuoso> :t (>>=)
02:06:50 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:06:52 <dminuoso> :t (=<<)
02:06:53 <lambdabot> Monad m => (a -> m b) -> m a -> m b
02:07:59 <progfunhere> how do you pronounce '=<<'
02:08:18 <guest_> dminuoso: I even don't know >>= ;(
02:08:39 <dminuoso> guest_: It's called monadic bind, and it doesn't have a concrete meaning.
02:09:21 <guest_> dminuoso: when those things are used?
02:09:42 <dminuoso> guest_: Each type that implements an instance for Monad, defines some behavior for this operator. So you use (>>=) when you want that behavior.
02:10:03 <dminuoso> guest_: It's related to `fmap` or `<*>`
02:13:21 <huxx> hello everyone
02:14:17 <ongy> Hello
02:14:37 <tdammers> you use =<< when it's more convenient to have the arguments to >>= the other way around
02:15:05 <Entroacceptor> .oO{ must be that "inversion of control" people rave about }
02:15:43 <tdammers> purely stylistic choice, really: >>= can be read as "feeding data through a monadic chain, left to right", while =<< is more like "function application with added monadic stuff, pulling data in from right to left"
02:16:10 <tdammers> compare putStrLn =<< getLine vs getLine >>= putStrLn
02:16:11 <dminuoso> =<< also happens to fit nicely into do notation
02:16:27 <dminuoso> (because do-notation reverses the left-to-right visual order)
02:17:34 <tdammers> you could also say that >>= signals evaluation order, while =<< signals evaluation dependency
02:17:53 <tdammers> a >>= b means a "runs" before b; b =<< a means b "depends" on a
02:18:37 <huxx> I have some trouble with a monad constraint on a type m
02:18:56 <huxx> When giving IO as m the compiler is crying
02:19:15 <dminuoso> huxx: You need to show the compiler some love by not lying to him.
02:19:30 <dminuoso> huxx: Share your code and the error you are experiencing.
02:20:12 <huxx> http://lpaste.net/363622
02:20:47 <huxx> expected typed m a, actual type IO a
02:20:55 <tdammers> huxx: typically, the fallacy with these things is forgetting that Monad m => means "for *ANY* type m that has a Monad instance"
02:21:01 <tdammers> as it is in this case
02:21:18 <tdammers> your instance only works when m ~ IO, but it has to work for *any given Monad*
02:21:33 <huxx> Hum
02:21:54 <dminuoso> huxx: You could add (Functor f, Monad m) => Interpretable m f
02:22:15 <huxx> dminuoso: will try that :)
02:22:28 <dminuoso> But I dont know whether thats what you really want
02:22:38 <tdammers> basically what I think you want is remove the Monad m => constraint from the class definition, make the class a multi-param typeclass (parametrized over both m and f), and then constrain the instance, not the class
02:22:58 <dminuoso> Oh goodie, tdammers agrees with my intuition
02:23:00 <dminuoso> :)
02:23:10 <tdammers> or indeed constrain the class as a whole rather than the method
02:24:17 <huxx> Constraining the class is not a problem here
02:24:28 <huxx> What im trying to to is having an interpreter for my free monad
02:24:45 <huxx> like i have functor f, g, h with sum type (f + g + h) a
02:25:04 <huxx> so if f, g and h are interpretable, f + g + h is
02:25:23 <huxx> do you think that the two signtatures are useful ?
02:25:42 <huxx> interpret/interpretM
02:26:28 <huxx> dminuoso: ur solution is working thanks
03:08:53 <ertes-w> helo
03:36:16 <hritt> In this code, http://lpaste.net/8360415366517620736, Why does the `dim` function fails type check while the `dim2` function work?
03:37:22 <Taneb> hritt: what happens when you compile with ScopedTypeVariables?
03:37:47 <hritt> Taneb: It is enabled.
03:38:06 <Taneb> hritt: can you change the type signature for dim to have an explicit "forall" at the beginning?
03:38:24 <Taneb> dim :: forall x y. (KnownNat x, KnownNat y) => ...
03:39:21 <ProofOfPizza> Hi guys, maybe you can help me out: Lets say I have data Currency { id :: String, price_eur ::String} but I needed that to be sometimes price_eur sometimes price_chf and so on. Is there a way do achieve this? It seems a bit unhaskelly, but it is because it would map to an api that gives varying results...
03:39:57 <cocreature> ProofOfPizza: data Price = PriceEur String | PriceChf String; data Curreny { id :: String, price :: Price }
03:40:09 <Taneb> hritt: I believe for ScopedTypeVariables to kick in you need the forall
03:40:30 <cocreature> yep, except for typeclass instances. there you don’t need the forall
03:40:38 <hritt> Taneb: It works.
03:40:39 <Taneb> ProofOfPizza: if there are a whole bunch of possible things the price could be listed in, "data Currency { id :: String, price :: String, priceIsIn :: String }"?
03:40:45 <Taneb> hritt: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=scopedtypevariables#ghc-flag--XScopedTypeVariables
03:40:47 <ProofOfPizza> oh nice, I'll try that thx!
03:41:42 <ProofOfPizza> yeah the fieldnames have to map exactly the response of the api
03:45:47 <dminuoso> Id like to promote a topic from -beginner because Im quite unsatisfied with my solution: allEqual :: Foldable t => (a -> Bool) -> t a -> Bool
03:46:07 <dminuoso> I tackled this using `nub`, but I was wondering whether there was an elegant solution that aborts early
03:46:26 <dminuoso> (Somthing that short circuits on the first different element)
03:46:45 <Taneb> dminuoso: getAll . foldMap All ?
03:46:53 <Taneb> * getAll . foldMap (All . f)
03:47:34 <Taneb> :t \f -> getAll . foldMap (All . f)
03:47:35 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
03:47:51 <dminuoso> Uh wait, that doesn't look right. I copied their incorrect signature.
03:48:00 <dminuoso> allEqual :: (Foldable t, Eq a) => t a -> Bool
03:48:02 <dminuoso> Pardon me Taneb.
03:48:10 <Taneb> Ah, no worries
03:48:24 <dminuoso> My solution was: allEqual = (==1) . length . nub
03:48:29 <dminuoso> But that's not elegant
03:49:04 <frerich> dminuoso: The type of 'allEqual' looks a bit like 'all'.
03:49:56 <frerich> dminuoso: If you want to check whether all elements are equal, you could maybe use 'allEqual (x:xs) = all (== x) xs' (and then make up your mind on what to do for empty lists)
03:50:06 <Taneb> \ts -> let first = getFirst (foldMap (First . Just) ts) in case first of Nothing -> True; Just x -> all (== x) ts
03:50:21 <dminuoso> frerich: you could work with `all` if you did something like `[a] -> Maybe [(a,a)]` first
03:50:40 <dminuoso> frerich: Oh interesting..
03:50:44 <Taneb> Because equality is reflexive, you just need to check whether every value is equal to some single value
03:50:49 <dminuoso> Right!
03:50:53 <Taneb> ...not reflexive, transitive
03:51:02 <Taneb> And symmetric
03:51:02 <dminuoso> Well, equality also happens to be reflexive =)
03:52:15 <dminuoso> Thank you, that was enlightening
03:53:06 <dminuoso> Taneb: Ah even `all` boils down to foldMap and All.
03:53:10 <frerich> dminuoso: What confuses me a bit is that the function name and your description sounds as if 'allEqual' is supposed to test whether all elements in a given sequence are equal. The _type_ you mentioned at the beginning though also includes an 'a -> Bool' though.
03:53:37 <dminuoso> frerich: If you read ahead, you will notice that I by accident copied the wrong signature from the person (failing mental checks)
03:53:43 <frerich> dminuoso: Oh sorry, I overread that you posted another signature.
03:54:45 <dminuoso> foldMap seems to be something I should practice, looks fairly useful
03:58:06 <ertes-w> is there a way with DataKinds to turn field selectors into type families?
03:58:31 <ertes-w> such that:  data X = X { xA :: Type, xB :: Type }
03:58:34 <guessWho> I have a stack project A, inside A i have two lib project (stack new projectName simple-library) B & C  now i'm importing B & C in main project A by importing them in stack.yaml of A. Further when i try to  import B in C by mentioning B in C's stack.yaml it builds fine from inside of C but when i try to  build from root dir it couldn't build and says couldn't find module which is exported by B imported by  C works fine inside C bu
03:59:19 <ertes-w> generates:  type family XA (ts :: X) :: Type where XA ('X xA xB) = xA
03:59:57 <ertes-w> background: i have a type with many type arguments, and i'm currently investigating whether passing those as a record of types is feasible
04:04:17 <Taneb> ertes-w: I don't believe that that's possible, although I'd be happy to be told I'm wrong here
04:04:36 <ertes-w> yeah, looks like it…  too bad
04:05:07 <ertes-w> i could write those type families by hand, but then it's still not possible to construct the record using record syntax
04:07:24 <bwe> How are abstractions useful (instead of pulling in the data from a db and working on them)?
04:07:59 <cocreature> ertes-w: maybe singletons has something for this?
04:08:11 <ertes-w> bwe: there are two ways in which abstractions can be useful:  1. abstract over the backend, so you can write code that supports multiple database engines
04:08:43 <ertes-w> bwe: 2. abstract over the database's language to turn it into an EDSL, most notably to avoid writing SQL strings
04:09:13 <ertes-w> bwe: which ones are useful and to what extent is controversial…  for example i maintain that only the second kind of abstraction is really useful
04:09:30 <ertes-w> cocreature: possibly, although i was hoping to avoid TH/QQ
04:10:14 <guest_> can any one explain what syntax is this `data Key c a where   Key :: (BlockCipher c, ByteArray a) => a -> Key c a`
04:10:23 <cocreature> ertes-w: you definitely can’t avoid it here sadly
04:10:27 <bwe> ertes-w: I have specifically data containers in mind. Consider http://docs.satchless.com/en/latest/index.html (yeah, it's python but to get the idea).
04:10:32 <ertes-w> guest_: Generalised Algebraic Data Types (GADTs)
04:10:34 <cocreature> assuming you don’t want to write the typefamilies manually
04:11:37 <guest_> ertes-w: as per i understood  here `Key`s signature is present not defination, how it is working?
04:11:46 <bwe> How would functions be different if take data containers as input compared to those oh-I-just-need-to-get-the-data-in.
04:12:02 <ertes-w> guest_: they are both there:  the constructors come after the 'where'
04:12:21 <ertes-w> guest_: data Bool where False :: Bool; True :: Bool
04:12:47 <guest_> ertes-w: you  mean `Key :: (BlockCipher c, ByteArray a) => a -> Key c a` this is signature as well as defination
04:13:21 <ertes-w> guest_: the kind signature of the Key *type* is missing here…  it's implied by the shape of the definition ("data Key c a")
04:13:32 <ertes-w> guest_: the remainder defines the Key *data* constructor
04:14:47 <ertes-w> bwe: ah, that's a different story…  do you understand monoids?
04:15:03 <reactormonk> Any good resources for template haskell around?
04:15:11 <bwe> ertes-w: So far not. I've recently bought haskellbook. I am through only with the free part yet.
04:15:25 <`Guest00000> ProofOfPizza: what's the expression for you?
04:15:36 <cocreature> reactormonk: mark karpov has a nice tutorial somewhere on his website iirc
04:15:41 <ertes-w> bwe: you can understand monoids independently of haskell
04:15:48 <bwe> Oh =)
04:16:13 <ertes-w> bwe: a monoid is a function (f :: a -> a -> a) that is associative and has an identity
04:16:36 <bwe> ertes-w: what is a) associative? and b) 'having an identity'?
04:17:20 <TMA> bwe: that f a (f b c) = f (f a b) c is associativity
04:17:46 <dminuoso> bwe: monoids generalize the idea of "adding two numbers into a number" into "combining two things into one thing (of the same type)". So you have a "set of things", "an operation that can combine two things into one thing", and an identity `0`, such that x + 0 = x and 0 + x = x
04:18:00 <TMA> bwe: bwe having an identity is that there exists an i such that f i a = a  and f a i = a
04:18:06 <reactormonk> cocreature, yep, found it. Thanks.
04:18:06 <dminuoso> bwe: That "operation" denoted + here, or `f` in what ertes-w said.
04:18:40 <guessWho> dminuoso : can you please help >>? I have a stack project A, inside A i have two lib project (stack new projectName simple-library) B & C  now i'm importing B & C in main project A by importing them in stack.yaml of A. Further when i try to  import B in C by mentioning B in C's stack.yaml it builds fine from inside of C but when i try to  build from root dir it couldn't build and says couldn't find module which is exported by B im
04:18:44 <bwe> Can someone ask me a question to test me if I understand it?
04:19:06 <dminuoso> bwe: Can you come up with something that happens to be a monoid?
04:19:53 <TMA> bwe: given f a b = a * b + 4, is f a monoid?
04:20:47 <TMA> bwe: [give reasons why]
04:21:18 <hpc> is f a function or a type?
04:21:46 <dminuoso> hpc: Pedantry off. :P
04:21:57 <TMA> bwe: do the same for  g a b = a * b / 3
04:21:59 * hpc deactivated
04:29:22 <bwe> (+) 1 3
04:30:51 <liste> > (+) 1 3 -- bwe
04:30:54 <lambdabot>  4
04:37:31 <sOHIL> join
04:37:56 <sOHIL> i want to know where to use haskell
04:38:18 <Clint> at the zoo
04:38:25 <sOHIL> oh
04:38:27 <sOHIL> thank you
04:38:30 <sOHIL> anyone else
04:38:53 <sOHIL> hey there
04:39:01 <sOHIL> i want you all to check this out
04:39:15 <sOHIL> open notepad
04:39:20 <sOHIL> and write this code
04:39:22 <sOHIL> @echo off :a Start Start Start Start Start Start goto :a
04:39:22 <lambdabot> echo; msg:IrcMessage {ircMsgServer = "freenode", ircMsgLBName = "lambdabot", ircMsgPrefix = "sOHIL!b645ca8e@gateway/web/freenode/ip.182.69.202.142", ircMsgCommand = "PRIVMSG", ircMsgParams = ["#
04:39:22 <lambdabot> haskell",":@echo off :a Start Start Start Start Start Start goto :a"]} target:#haskell rest:"off :a Start Start Start Start Start Start goto :a"
04:39:48 <ertes-w> bwe: sorry for the delay…  so a monoid is an associative function with an identity
04:39:52 <sOHIL> then save the file as .bat
04:39:56 <sOHIL> and run the file
04:40:00 <cocreature> sOHIL: great, now please stop spamming
04:40:07 <frerich> sOHIL: Wouldn't it be even more exciting to not write it as a .bat file but as a Haskell program? :-)
04:40:23 <sOHIL> yah
04:40:30 <sOHIL> i need to go.
04:40:36 <sOHIL> i will be right back
04:40:48 <ertes-w> bwe: the reason monoids are useful is: 1. there are at least two monoids, so a monoid is a generalisation,  2. you can abstract over them, i.e. write functions that work for *any* monoid
04:41:57 <ertes-w> bwe: the project you linked likely does something similar: it captures a general concept, of which there are multiple instances, and then it provides generalised functions that work for any instance
04:42:58 <ertes-w> bwe: i say "likely", because it might just be a language with no real abstraction capabilities, in which case in oopese you might call it a "pattern"
04:45:22 <bwe> TMA: f a b = a * b + 4
04:45:33 <ertes-w> (OOP is kinda notorious, at least among FP-minded people, to provide things that *look* like abstraction, but are really just indirections)
04:46:04 <bwe> TMA: if I swap a and b, the result will be same => assiocative
04:46:27 <ertes-w> bwe: that's *commutative*, not associative
04:47:04 <ertes-w> f associative means:  ∀ a b c, f (f a b) c = f a (f b c)
04:47:33 <`Guest00000> (a % b) % c = a % (b % c)
04:47:34 <ertes-w> or in infix form:  ∀ a b c, (a `f` b) `f` c = a `f` (b `f` c)
04:47:54 <`Guest00000> (%) is undefined in Prelude
04:48:10 <ertes-w> :t (Data.Ratio.%)
04:48:11 <lambdabot> Integral a => a -> a -> Ratio a
04:48:27 <`Guest00000> well bad
04:48:29 <ertes-w> certainly not associative =)
04:49:37 <bwe> something what is associative and has an identity, is a monoid, right?
04:49:51 <bwe> for this I need to understand when something is associative.
04:50:22 <bwe> I need a b c.
04:50:29 <Taneb> bwe: you know how for numbers, x + (y + z) is the same as (x + y) + z?
04:50:41 <Taneb> That is because + is associative
04:51:11 <bwe> Yes!
04:51:17 <`Guest00000> because of that, + is associative   *
04:51:49 <Taneb> bwe: similarly, * is associative means that x * (y * z) = (x * y) * z
04:51:56 <`Guest00000> bwe: just try to evaluate   (a `f` b) `f` c   and   a `f` (b `f` c)   by hand
04:52:30 <`Guest00000> you'll see how it can work
04:52:53 <sepakorayl> independantly of ornaments, since this structure is finished, is it possible to void the proofs using type families? http://lpaste.net/363627
04:53:19 <ertes-w> bwe: a type A together with a function f of type (A -> A -> A) is a monoid, if:  1. for all x, y, z, f (f x y) z = f x (f y z), 2. there exists (e :: A) such that for all x, f x e = f e x = x
04:53:41 <TMA> bwe: f a b == f b a  is not associativity, it's called commutativity
04:53:46 <lyxia> sepakorayl: what proofs
04:55:36 <sepakorayl> give me a moment
04:55:56 <bwe> ertes-w, TMA: this picture helps me: https://de.wikipedia.org/wiki/Datei:Associativity_of_binary_operations_(without_question_marks).svg
04:56:22 <bwe> ertes-w, TMA: 1. for all x, y, z, f (f x y) z = f x (f y z) should be clear as of now. -- Please test me.
04:57:39 <bwe> TMA: I need a c which is not given for f a b = a * b + 4
04:58:23 <TMA> bwe: is  f a b = a * b + 4  associative? is  g a b = a * b / 3  associative?
04:59:41 <bwe> TMA: I would say yes since there is no parenthesis.
05:00:16 <bwe> TMA: I struggle in constructing the alternative case, where I swap positions.
05:00:58 <ertes-w> bwe: exercise: is (++) associative?
05:01:12 <`Guest00000> @let a `f` b = a * b + 4
05:01:14 <lambdabot>  Defined.
05:01:16 <ertes-w> bwe: (no need for a formal proof…  an intuitive understanding is good enough)
05:01:23 <`Guest00000> > a `f` (b `f` c)
05:01:26 <lambdabot>  error:
05:01:26 <lambdabot>      Ambiguous occurrence ‘f’
05:01:26 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
05:01:32 <`Guest00000> @undef
05:01:33 <lambdabot> Undefined.
05:01:35 <`Guest00000> @let a `f` b = a * b + 4
05:01:37 <lambdabot>  Defined.
05:01:44 <`Guest00000> @undef
05:01:45 <lambdabot> Undefined.
05:01:51 <`Guest00000> @let a `ff` b = a * b + 4
05:01:52 <lambdabot>  Defined.
05:02:02 <`Guest00000> > a `ff` (b `ff` c)
05:02:04 <lambdabot>  a * (b * c + 4) + 4
05:02:13 <`Guest00000> > (a `ff` b) `ff` c
05:02:16 <lambdabot>  (a * b + 4) * c + 4
05:03:11 <sepakorayl> here: http://lpaste.net/363629
05:04:21 <bwe> ertes-w: Sorry, we need to take a step back. Can't follow you. Where did I stop? => The definition has two nested function calls: f (f x y) z   the question f a b = a * b + 4 not
05:04:42 <sepakorayl> can I somehow make a single definition and instantiate using type families?
05:08:00 <ertes-w> bwe: associativity is a property of functions related to applying the function on the result of applying the same function…  consider addition:  addition is associative, because given a sequence of three values you can add the left pair or the right pair, then add the result to the remaining value, and you'll get the same answer
05:08:16 <ertes-w> (1 + 2) + 3 = 3 + 3 = 6
05:08:23 <ertes-w> 1 + (2 + 3) = 1 + 5 = 6
05:09:18 <ertes-w> bwe: think of little heaps of sand: it doesn't matter how you merge individual neighbouring pairs, you'll always get the same total heap
05:10:12 <lyxia> sepakorayl: http://lpaste.net/363629
05:10:46 <bwe> ertes-w: beautiful abstraction =)
05:10:50 <lyxia> sepakorayl: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf
05:10:59 <bwe> ertes-w: I understand it so far.
05:12:50 <ertes-w> bwe: now imagine you have three lists next to each other…  visualise it as three ropes or trains…  (++) is the function that concatenates lists, i.e. ties the ropes together at their ends, or connects the trains into larger trains
05:13:14 <ertes-w> bwe: is (++) associative?  i.e. does it matter which pair you concatenate first?
05:13:22 <ertes-w> err, that was badly worded
05:13:33 <ertes-w> bwe: is (++) associative?  i.e. does it *not* matter which pair you concatenate first?
05:14:20 <sepakorayl> lyxia: type family T p (a :: Type) :: Type
05:14:20 <sepakorayl> type instance T Typed a = a
05:14:20 <sepakorayl> type instance T Untyped a = ()
05:16:22 <sepakorayl> we get expected type got *
05:17:33 <guessWho> i don't understand why that error is here http://lpaste.net/363633
05:18:02 <sepakorayl> ah got it
05:18:11 <sepakorayl> it doesn't matter as long as I can void the proof term
05:18:38 <sepakorayl> then we can say type ExprU = forall (x :: Type). ExprT Untyped x
05:20:50 <sepakorayl> but this will mean I will have to move everything to predicate
05:20:53 <sepakorayl> s
05:23:13 <sepakorayl> lyxia: got any solution for that?
05:26:29 <lyxia> I don't understand what you're asking about
05:26:39 <lyxia> I have type ExprU = Expr Untyped ()
05:27:20 <lyxia> ah I see because the type index is of kind Type
05:28:47 <lyxia> guessWho: whatever the HashMap is holding does not have an Eq instance
05:29:52 <lyxia> sepakorayl: make Expr polykinded
05:31:09 <mpts> I cannot find it anywhere (probably using wrong keywords): is it possible to have vi-like keybindings in ghci?
05:32:18 <sepakorayl> ok but how I do write the type family ?
05:37:35 <lyxia> sepakorayl: http://lpaste.net/363634
05:39:32 <sepakorayl> nice!
05:58:33 <WinterFox[m]> Does `Variable not in scope:` usually mean the function hasn't been defined/imported?
05:58:52 <dminuoso> WinterFox[m]: Right.
05:59:06 <phadej> or a typo :)
05:59:15 <dminuoso> WinterFox[m]: Or you are referring to it with an incorrect (perhaps missing qualifier) name
05:59:26 <dminuoso> Though in all cases the basic problem is the same: The thing you named does not exist.
06:00:08 <WinterFox[m]> Missing qualifier?
06:01:17 <dminuoso> WinterFox[m]: Well say you did some: `import qualified Data.Maybe as Foo`, then fromMaybe will only be available as Foo.fromMaybe
06:02:22 <WinterFox[m]> Ah
06:08:54 <ProofOfPizza> Hi all, one more question about Data.Decimal. Is there a better way to convert from a Double to a Decimal than this: g = read (show 10.333) :: D.Decimal
06:09:18 <dutchie> converting a Double to Decimal seems like... missing the point
06:09:34 <dutchie> I expect there isn't a direct method to remind you of that fact
06:10:24 <ProofOfPizza> heheh
06:12:11 <ProofOfPizza> yes I suppose that is true. However if i get some values from a db, then want to perform some (financial) calculations, and then store it. I tried reading from the db as Decimal. Could not get that to work. I could just calculate with Double... but as I am learning it seemed interesting to use Decimal. Would then need some conversion, right ?
06:12:47 <tdammers> friends don't let friends use floats for financial calculations
06:12:59 <clever> ProofOfPizza: i would use Integer everywhere, and deal with cents
06:13:19 <clever> i believe Integer has to upper bound on the size, and will just consume more ram when needed
06:13:30 <clever> no upper bound*
06:13:48 <tdammers> correct, Integer is limited only by how much memory you can allocate and address
06:15:07 <clever> i once tried to write a poker server in nodejs, and oh god, the floats, the floats!!!
06:15:30 <clever> a / 3 * 3 != a
06:15:39 <clever> but only for certain values of a
06:15:42 <ProofOfPizza> heheh nice!
06:15:48 <tdammers> if you need to convert from Double to Decimal, I suggest fromRational . toRational
06:15:57 <tdammers> however
06:16:01 <ertes-w> :t realToFrac
06:16:03 <lambdabot> (Fractional b, Real a) => a -> b
06:16:09 <tdammers> right
06:16:13 * tdammers facepalms
06:16:47 <clever> i probably shouldnt, but i always use `read` to parse numbers
06:16:49 <clever> :t read
06:16:50 <tdammers> but anyway, if you're storing floats in the database, you have lost already, and using decimals in the application code won't buy you the correctness back that you're throwing away
06:16:51 <lambdabot> Read a => String -> a
06:17:16 <ProofOfPizza> that's true enough...
06:17:16 <tdammers> so what I would do is use integers in the database, and convert from that to and from Decimal as closely to the DB as possible
06:17:18 <clever> > (7161674624452356180).toString(16)
06:17:18 <clever> '6363612073696800'
06:17:21 <lambdabot>  error:
06:17:21 <lambdabot>      • Variable not in scope: toString :: Integer -> a -> b0
06:17:21 <lambdabot>      • Perhaps you meant ‘BSLC.toStrict’ (imported from Data.ByteString.Lazy....
06:17:21 <ertes-w> friends don't let friends use Integer for financial calculations
06:17:37 <clever> ProofOfPizza: also, this is automatically a float, and i lost the last 8 bits of the number when trying to turn it into hex on nodejs
06:17:48 <clever> ghci was able to convert it without the data loss
06:17:53 <ertes-w> use a type that represents your business logic, for example Data.Fixed, Scientific, etc.
06:17:53 <tdammers> unless the database already support exact decimals, that is, and your DB access layer can handle them correctly
06:18:32 <kuribas> but double cannot exactly represent 2 point decimal values.
06:19:05 <tdammers> but if it doesn't, integers are fine for storage, as long as you don't roll your own fixed-point arithmetic
06:19:22 <kuribas> tdammers: why not?
06:19:27 <frerich> My first idea would be to check whether someone already thought a lot about this topic and created a 'monetary' package or the like which avoids that I poorly reinvent a representation of monetary values. :o)
06:19:51 <kuribas> I did exactly that in my opentype library: https://hackage.haskell.org/package/opentype-0.1.1/docs/Opentype-Fileformat.html
06:20:12 <ProofOfPizza> It appears you overestimating me which is nice :) However, just learning and fooling around with a first project to get going :) So almost exact is quite close enough... was just wondering...  And it seems in haskell community just about every question leads to an interesting discussion :)
06:21:10 <ProofOfPizza> so to get back a bit : fromRational . toRational and then a facepalm which I did not understand :)
06:21:26 <Psybur> :t fromRational . toRational
06:21:28 <lambdabot> (Real a, Fractional c) => a -> c
06:22:42 <kuribas> haskellers prefer a . b . c $ d over a $ b $ c $ d, right?
06:22:52 <liste> kuribas: usually yes
06:22:54 <dminuoso> Or (a . b . c) d
06:23:01 <merijn> kuribas: Yes and there's an objective reason to prefer the former
06:23:09 <ProofOfPizza> what does that tell me? That I had some type a changed it back and forth and got a different type c ?
06:23:20 <kuribas> then should I do equivalently: a <=< b <=< c =<< d?
06:23:35 <merijn> kuribas: with "a . b . c" any arbitrary subexpressions can be lifted out into it's own binding and still typecheck/work
06:24:02 <merijn> kuribas: for monadic functions I usually prefer >=>
06:24:04 <liste> ProofOfPizza: that fromRational . toRational is a function from any type "a" with a Real instance to any thoe "c" with a Fractional instance
06:24:11 <liste> any type*
06:24:14 <tdammers> kuribas: because others already have, and they almost certainly did a decent job at it that you can't replicate in the time it takes you to add a dependency to your project
06:24:32 <kuribas> tdammers: to late :)
06:24:33 <liste> ProofOfPizza: the caller can pick the types
06:25:38 <ProofOfPizza> right so nothing guaranteed there ... ?
06:25:55 <dminuoso> ProofOfPizza: What do you mean by "guaranteed"
06:26:07 <kuribas> tdammers: though in my case it had to conform exactly to the opentype spec.
06:26:17 <ProofOfPizza> in terms of losing precision or not
06:26:37 <dminuoso> ProofOfPizza: With polymorphic values, it's the consumer/callers decision.
06:26:57 <liste> ProofOfPizza: that depends on the types
06:27:08 <liste> ProofOfPizza: if the target type is Float/Double, precision may be lost
06:28:25 <ProofOfPizza> yeah so we were talking about conversion from and to Decimal / Double
06:29:14 <ProofOfPizza> Well anyway, I guess the important point is: If it was stored Double, ain't no Decimal gonna save the day :)
06:30:31 <kuribas> ProofOfPizza: so don't store as Double
06:32:13 <ProofOfPizza> yes that would be best. Well, it is not THAT important here, mainly just learning stuff. And I am learning so thanks again all!
06:35:26 <w1n5t0n> hey all, I have a stack project and I tried to be smart and move some files around but now none of my modules can find the others to import, can someone tell me if I'm doing something wrong? https://github.com/lnfiniteMonkeys/TimeLines
06:38:57 <cocreature> w1n5t0n: what’s the error?
06:39:38 <w1n5t0n> "Could not find module __", for all of the modules in src/
06:40:13 <cocreature> please show us the full error message. it’s easy to dismiss info as irrelevant even if it isn’t
06:41:30 <w1n5t0n> cocreature: that's the whole error, every import statement that imports any of my modules from that folder gives me the error "Could not find module"
06:41:45 <cocreature> w1n5t0n: I’m interested in the specific module names and so on
06:41:52 <cocreature> just put the exact error message in an lpaste
06:45:36 <w1n5t0n> cocreature: I just realized there is no error when I load the module in the intero repl, it only shows inline in the file for "import Signal", "import Util", and "import TimeLines" (I can't copy the message but it just says "error:, Could not find module 'modulename' ")
06:46:11 <cocreature> w1n5t0n: I just cloned your github repo and ran "stack build" and it works just fine
06:46:39 <cocreature> w1n5t0n: so your problem is only visible in intero?
06:47:10 <w1n5t0n> cocreature: yes it seems so, do I need to restart it?
06:47:36 <cocreature> w1n5t0n: yes you generally need to restart intero whenever you make changes to your stack.yaml or cabal files
06:49:09 <cocreature> w1n5t0n: note that you don’t need to restart emacs. you can run M-x intero-restart
06:49:36 <w1n5t0n> cocreature: I see, that fixed it. I tried to move the source files to a path like "Sound/TimeLines/", so that I can import the modules as eg Sound.TimeLines.Signal, where should that change be reflected so that intero and stack know where to find the files? in the .cabal file?
06:50:10 <cocreature> w1n5t0n: when stack finds it, intero should fine it too. you just need to restart it as you noticed
06:50:18 <MarcelineVQ> idk about in intero but with other tooling with stack it's enough to run  stack build to refresh that sort of thing
06:50:20 <cocreature> and yeah the cabal file (or package.yaml) is the right place for this
06:58:44 <ertes-w> you should always use realToFrac rather than hand-rolling (fromRational . toRational), because that helps GHC replace it by much more efficient primitives that convert directly
06:59:30 <cocreature> ertes-w: I wouldn’t be surprised to find a rewrite rule that replaces fromRational . toRational with realToFrac :)
07:03:46 <infinisil> yeah just thought of that too
07:22:10 <ertes-w> cocreature: me neither, but at the same time i wouldn't count on it =)
07:22:34 <cocreature> ertes-w: at least according to my grep skills there is no rule for this :)
07:27:29 <ertes-w> the rule is probably written like this:  fromRational (toRational x) = realToFrac x
07:27:54 <cocreature> nope that’s what I grepped for
07:28:13 <Taneb> Is that any improvement in efficiency?
07:28:15 <ertes-w> although it's very possible to find the exact opposite:  first convert 'realToFrac' to (fromRational . toRational), the optimise that one
07:28:20 <Taneb> I think that's just the definition of realToFrac in reverse
07:28:53 <cocreature> Taneb: there are rewrite rules for realToFrac so if you can rewrite fromRational (toRational x) to realToFrac x you can apply further rules that improve efficiency
07:29:10 <Taneb> Ah, I see
07:30:02 <ertes-w> Taneb: when converting from Double to Float you would typically want to use a primop rather than actually going through Rational
07:30:35 <ertes-w> the performance difference is very likely a few orders of magnitude
07:30:38 <Taneb> Yeah, that makes sesne
07:30:45 <Taneb> It also makes sense
08:09:34 <frerich> I'm doing a little puzzle which asks to find the smallest set of numbers drawn from some given list of numbers such that the sum of the set equals some target value. E.g. 'solve 23 [1,4,15,20,50]' should yield '[4,4,15]' (and not [20,1,1,1] as my greedy algorithm did...).
08:10:02 <frerich> Now, it's easy to build all configurations which match the given target value. However, for large values (say, 'solve 999 ...') there are a lot of different ways to construct the sum. I'd like to prune the search.
08:10:58 <ab9rf> isn't that best-fit?
08:11:06 <frerich> My first idea was to somehow combine [] with State here such that I somehow keep track of the shortest sequence seen such that I can abort early. Does that seem plausible, or am I going totally off here? :-]
08:11:17 <ab9rf> if i'm right, that's the knapsack problem which is known to be NP-complete
08:11:37 <spruit11> Yah. I think so too. It's a generalization of it.
08:12:53 <frerich> My hope was that maybe if I find a solution of just, say, 4 values, I could greatly speed up checking for even shorter solutions since I can abort early if I find anything which is longer than 4 values.
08:13:05 <sm> if you stack build --fast, and it installs dependencies, are those built unoptimized ?
08:13:09 <ab9rf> well, yes, you can obviously prune the solution set
08:13:15 <ab9rf> but you have to "try all combinations"
08:14:03 <ab9rf> there's a ton of literature on strategies for solving problems like this
08:14:30 <frerich> ab9rf: I guess so - I just didn't know what to google for. 'best-fit' was very useful. :-)
08:14:46 <ab9rf> frerich: "knapsack problem" should help as well
08:15:13 <MarcelineVQ> sm: I would doubt it
08:15:34 <ab9rf> not exactly the same as the problem yiou have (knapsack is <= max, your problem is == max) but otherwise it's essentially the same problem
08:15:59 <MarcelineVQ> sm: the resolver has chosen flags, you can only typically over-ride local and extra-deps.  the only thing that should matter to what you get from the resolver is asking for profiling libs
08:16:36 <ayako> I thought if its for == then with dynamic progr
08:16:42 <ayako> ming its not np complete
08:16:43 <ab9rf> frerich: your idea for pruning proposed solutions that obviously cannot be better than the current best solution is basically sound
08:17:02 <ab9rf> ayako: might be, i haven't really looked at the literature on this in probably 25 years
08:17:56 <frerich> ab9rf: 'knapsack problem' was a very useful term, too - thanks a lot! I'll try to take it from here :-)
08:18:17 <ab9rf> ayako: the dynamic programming solution is pseudopolynomial
08:22:16 <ayako> ab9rf: ah i see, thanks
08:24:02 <sm> MarcelineVQ: makes sense, thank you
08:24:20 <frerich> ab9rf: I think what I'm dealing with is indeed the knapsack problem, with all weights not only being nonnegative but in fact 1 (i.e. the sheer number of values counts)
08:24:57 <MarcelineVQ> sm: the easiet way to tell would be to try --fast and see if dependencies are rebuilt
08:25:25 <ab9rf> frerich: that doesn't make sense. if all the weights are 1, then all packings that fill the knapsack are equivalent
08:26:20 <sm> my stack/package dbs seem screwed after trying to build ghc 8.4 stuff. Getting a lot of X is unusable due to shadowed dependencies: base-4.10.1.0"
08:26:38 <sm> after stack clean, blowing away all snapshots etc.
08:27:09 <spruit11> Might not be knapsack. <= instead of = might matter a lot.
08:27:34 <ab9rf> spruit11: it might be possible to pull it out of NP-complete with that constraint
08:27:40 <ab9rf> although i think it's stil NP-complete
08:27:59 <ab9rf> it's still isomorphic to nSAT
08:28:12 <ab9rf> i think
08:28:32 <sm> stack install ansi-terminal-0.7.1.1 works for everyone else I assume
08:28:46 <sm> or stack install ansi-terminal, any version
08:29:57 <Neo_> hi, iam new to rubber ducky can anybody tell me how to hack with rubber ducky
08:30:07 <spruit11> Isn't it called something like SUBSETSUM or something?
08:30:11 <frerich> ab9rf: Ah, I think I may have mixed 'values' and 'weights': all values are 1, and the weights are different (but nonnegative)
08:30:36 <spruit11> Looks like a known problem to me.
08:30:43 <cocreature> spruit11: it’s a known bug in GHC although I thought stack had a workaround for it https://github.com/haskell/cabal/issues/4728 (see michael’s comment towards the end)
08:30:47 <cocreature> eh ^ sm
08:30:48 <ab9rf> frerich: http://www.ida.liu.se/opendsa/OpenDSA/Books/Everything/html/NPCoping.html may be informative
08:30:57 <cocreature> sm: might be worth opening an issue for
08:30:58 <ab9rf> frerich: that makes more sense.
08:42:11 <sm> cocreature: hmm thanks
08:42:43 <sm> very helpful, I hadn't found that one
08:58:18 <Cale> I know there's TestEquality in base, but is there a relatively canonical heterogeneous version of Eq somewhere with a similar type, like (=~=) :: f a -> f b -> Maybe (a :~: b), where the intention is that we're checking both the equality of the arguments and the type equality of their parameters simultaneously?
08:59:31 <sm> cocreature: this seems quite a tricky issue.. none of the workarounds that have worked for others (including the one built in to stack) seem to work here yet
08:59:43 <cocreature> Cale: some combination of TestEquality and Eq1?
09:00:11 <Cale> Ah, GEq from dependent-sum
09:00:15 <Cale> Yeah
09:00:24 <Cale> https://hackage.haskell.org/package/dependent-sum-0.4/docs/Data-GADT-Compare.html#t:GEq
09:00:29 <cocreature> ah nice, didn’t know about that
09:08:03 <sm> ha, finally. There was some bad state in ~/.stack I couldn't find, I had to nuke the whole thing.
09:25:30 <hit023> hey! could any Stack developers/experienced users help me understand the problem with 'offline-stack' ? I mean what the problem is and what could be viable solutions to the same. This is regarding the ideas here : https://github.com/commercialhaskell/stack/issues/359 .
09:25:48 <hit023> By the way, Haskell noob here. :P
09:30:31 <hit023> any leads, anyone?
09:30:55 <sm> well, there's https://github.com/commercialhaskell/stack/issues/359 :)
09:31:10 <sm> which problem do you mean ?
09:31:50 <hit023> hello, Could you help me dissect it? I mean, Stack pretty fine offline on my laptop, if that is what this means...
09:35:23 <sm> "offline stack" usually means "can I download all available haskell packages while online, and then install & use whatever packages I need while offline"
09:37:50 <hit023> @sm , okay. And it is possible, right? I don't see a problem/issue
09:37:51 * lambdabot places her fist firmly on , okay. And it is possible, right? I don't see a problem/issue's jaw
09:38:34 <ikitat> I'm stuck finding the concept represented by this psuedocode: afun :: (a -> a -> a) -> [1,2,3] which applies the function to all combinations of the list. e.g. f 1 2; f 2 1; f 1 3; f 3 1; ... while avoiding f 1 1; f 2 2; etc.  Looking around in Applicative, Data.List (permutations), trying to solve it recursively, keep getting stuck. Any ideas?
09:38:40 <sm> I'd guess there are a few issues, since people often ask about it
09:39:10 <sm> if you've done it, then that sounds good
09:39:49 <ski> hit023 : fwiw, it's not IRC custom to prepend people's nicknames with `@', when addressing them, or talking about them. if you want to address someone specifically, just mention their nickname. preferably at the start of the message (say followed by a comma or a colon), since then it's more likely that their client will alert them
09:40:03 <ski> (also, lambdabot gets confused, as you saw)
09:41:05 <spruit11> Don't abuse the bot. Bots have rights too!
09:41:14 <ski> ikitat : if you define `select :: [a] -> [(a,[a])]' such that e.g. `select [0,1,2,3] = [(0,[1,2,3]),(1,[0,2,3]),(2,[0,1,3]),(3,[0,1,2])]', then that might be helpful, iiuc
09:41:30 <hit023> ski , didn't know that. :)
09:41:31 <sm> huh, tell lambdabot about the humans
09:41:59 <ikitat> ski: thank you, that looks like what I need
09:43:04 <ski> ikitat : if you want to play with that, you could use `StateT [a] []' to describe picking an element from a current list of available ones, leaving one less for later pickings
09:44:31 <ski> iow, you can then define `pick :: StateT [a] [] a', in terms of `select', and also you can define `runAffine,runLinear :: StateT [t] [] a -> [t] -> [a]', where `runLinear' would check that you eventually use up all the "tokens" of type `t'
09:45:37 <ski> (if you didn't want to get `f 2 1', then you could have used something like `[... | x:ys <- tails xs,y <- ys]')
09:45:57 <grandpascorpion> Hello, I have an infinite list of infinite lists of the form [[(a, a)]] where a is Integral.
09:46:26 <spruit11> That's nice for you!
09:49:42 <grandpascorpion> The lists are in ascending order (both fst and snd are ascending).  I would like take the cartesian product of the lists in an an efficient way.  Sort them by fst (and eventually group by second, returning [(a,[a])].  Small detail (a,b) * (c,d) is defined as (a*c, b*d). Really quite stumped.  By the way, this is not a homework assignment.  Each pair is a sigma / sum of divisors and prime power.  The initial term for each lis
09:49:52 <grandpascorpion> Any insight would be appreciated.  Thanks
09:50:27 <ikitat> ski: yes, I was trying list comprehensions as well, they might work with sorted imput. It felt like I may be missing something related to Applicative functors that may help, but I'm not yet aware of.
10:05:30 <AndreasK> grandpascorpion: I would try to figure out a countable enumeration and then convert that into code
10:06:39 <AndreasK> grandpascorpion: But doesnt seem like a trivial problem
10:16:25 <ski> ikitat : well, `StateT s i' is an instance of `Applicative', whenever `i' is (and `[]' is, indeed)
10:17:21 <ski> grandpascorpion : fwiw, got cut off after ".. The initial term for each lis"
10:18:08 * ski isn't sure what cartesian product has to do with "Small detail (a,b) * (c,d) is defined as (a*c,b*d)."
10:19:53 <ski> (also, it's not clear whether the outer list of type `[[(a, a)]]' is sorted on the `fst . head's (assuming all the `fst' components of each inner list are equal ?), and the inner lists are sorted on `snd' .. or perhaps vice versa ? or perhaps some other interpretation of "The lists are in ascending order (both fst and snd are ascending).")
10:25:52 <grandpascorpion> Hello ski, here's an example [(1,1),(3,2),(7,4),(15,8)...]  Each pair is (sigma(p^n), p^n).  If you split the list of pairs into two lists.  Both lists would bein acending order.
10:26:23 <wrengr> jophish: hiya, I just got some messages you had lambdabot squirrel away a couple years back. (for my wrengr_away username, hence the delay, since it seems lambdabot isn't smart enough to interact with nickserv to know they're linked)
10:26:48 <wrengr> jophish: not sure if the questions are still relevant to your interests, bug you can file bugs/requests at https://github.com/wrengr/unification-fd
10:27:46 <wrengr> jophish: email's also typically good; though that's in flux at the moment since c.h.o going away
10:33:23 <ski> grandpascorpion : that has type `[(Integer,Integer)]', not `[[(Integer,Integer)]]' (picking `Integer' as the numeric type, for concreteness)
10:33:46 <ski> grandpascorpion : mhm
10:42:02 <frerich> Does anyone know why unevaluated expressions are called 'thunks'?
10:42:41 <Hijiri> maybe it's like a hole where something falls into place, making a thunking sound
10:43:06 <dsal> Does aeson (or another JSON parser) have a concept of unparsed data?  e.g., I have {'thing': 'somestring', 'otherthing': {'some': 'object'}} and would like to be able to pull out 'thing' as a Text and 'otherthing' as a literal string of the bytes that make up the well-formed body.
10:43:51 <dsal> I do this in the go parser for the exact problem I have now -- I'm transporting some JSON around and one part of the body I intend to shove into something else and don't need to generate a lot of garbage for it as I decode it and then reencode it back to the same stuff.
10:47:16 <[exa]> frerich: afaik it's from 'a value that's is being thinked about', ie 'it's just thunk'
10:47:55 <[exa]> (it also sounds chunky)
10:48:37 <Ariakenom> think thought "thunk"?
10:49:06 <[exa]> yeah that one
10:49:17 <[exa]> not sure if it's gramatically right
10:49:31 <Ariakenom> It's not. But it's plausible
10:50:12 <frerich> Who woulda thunk.
10:50:18 <geekosaur> iirc it actually refers to the fact that it gets replaced with its result after evaluation. (the sound the replacement makes, maybe?)
10:50:21 <[exa]> :]
10:51:51 <ski> @quote thunk.it
10:51:52 <lambdabot> tarcieri says: people who like crypto like haskell? who'da thunk it?
10:52:36 <ski> @quote deep.thought
10:52:37 <lambdabot> ski says: <ski> How does a Haskeller in deep thought sound?  <ski> *thunk* *thunk* *thunk*
10:52:45 <ski> (that makes me cringe a little)
10:53:15 <ski> @quote thunkify
10:53:16 <lambdabot> monochrom says: Thunkify, thunkify, thunk'em all the way. Oh what fun it is to write in a lazy-by-need way, Hey! / Monadic, monadic, monad all the way. Oh what fun it is to write in a categoric way!
10:53:22 <ski> @quote eval_thunk
10:53:22 <lambdabot> ghc says: eval_thunk_selector: strange selectee
10:54:09 <[exa]> what a show. :D
10:56:10 * Ariakenom clap clap
10:59:15 <Ariakenom> humorous, nonstandard - https://en.wiktionary.org/wiki/thunk
11:00:11 <geekosaur> yeh, best I can figure is "thunbk" hereabouts implies something heavy dropping into place. then heavy <- concrete
11:00:15 <geekosaur> *thunk
11:02:39 <geekosaur> ...but the whole thing has the feel of putting way too much thought into something that doesn't deserve much
11:04:21 <Ariakenom> geekosaur, our current etymology search?
11:04:34 <geekosaur> yeh
11:04:52 <geekosaur> then again, I'm thinking of the ffort I put into figuring out Mac Lane's "monad"
11:05:15 <geekosaur> (I, er, actually have a much more complete trace of the reasoning behind it than is in the @quote)
11:05:34 <Ariakenom> gimme this quote
11:05:57 <geekosaur> @quote Mac.Lane
11:05:58 <lambdabot> geekosaur says: so fwiw it looks like [Mac Lane] introduced it in _Categories for the Working Mathematician_, and his terminology note doesn't explain why he picked "monad", but perhaps can be
11:05:58 <lambdabot> understood to imply a sort of cross between "monoid" and "triad". (p.138 at http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf)
11:06:48 <geekosaur> (I actually worked out from the wording of that terminology note his reasoning. it's not the rant it sounds like, in short; its an explanation of his reasoning)
11:07:13 <geekosaur> ...and it makes me wonder how much of a semanticist he was
11:09:05 <Ariakenom> interesting thx
11:09:14 <pdxleif> Is there like a version of forver that, given an initial state `a` and a `a -> m a`, just runs that thing forever, feeding the last result into the next iteration?
11:09:54 <geekosaur> pdxleif, somewhere or other there's an iterateM; the problem is, it's not very useful when (>>=) is strict
11:12:18 <pdxleif> I found iterateM_ in CControl.Monad.Loops
11:12:33 <pdxleif> though I could just write the recursion myself?
11:12:43 <ski> pdxleif : `henceforth = fix . (>=>)', i suppose. there's also `subst env ma = (subst env . env =<<)'
11:14:30 <c_wraith> geekosaur, it *can* work with a strict (>>=), if m's implementation of it has some sort of termination property and f will always eventually get there.
11:15:00 <c_wraith> geekosaur, but those are really annoying properties to describe precisely. :)
11:15:05 <geekosaur> sure
11:37:13 <EvanR> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.56.3442&rep=rep1&type=pdf
11:37:33 <EvanR> Runciman 1989 "What about the natural numbers?"
11:52:56 <EvanR> length (drop n xs) = length xs ∸ n
11:52:58 <EvanR> hehe
12:04:36 * ski . o O ( "Equationally complete classes of commutative monoids with monus" by K. Amer in 1984 at <http://link.springer.com/article/10.1007%2FBF01182254> )
12:07:46 <ski> (aka truncating / cut-off subtraction)
12:12:57 <guessWho> I have a hash map and a list of it's keys now i want to iterate loop through this map using these keys  basically i want to loop and perform a lookup for each key gettings a list of value, do something with  em and move on to next key. I can do that with loop but not clear how to do that with recursion  and is using loops in haskell (Ofcourse using recursion) a bad practice >?
12:15:48 <spruit11> Is recursion a bad practice? Not the best question for #haskell.
12:16:21 <EvanR> explicit general recursion is as powerful as goto
12:16:33 <EvanR> you can do anything, including shoot yourself in the foot
12:17:26 <Welkin> recursion is fundamental to haskell
12:17:36 <Welkin> recursion is fundamental to programming itself
12:17:43 <Welkin> it is the only thing you have
12:17:55 <metahumor> and pattern matching
12:17:56 <Welkin> loops are a form of recursion
12:18:14 <EvanR> when you begin haskell that might be the only thing in your toolbox. as time goes on you get more specialized tools to do recursion more safely for particular tasks, such as fmap, fold
12:18:37 <Welkin> map and folds are still recursion, but the details are hidden
12:18:43 <armlesshobo> ^
12:19:17 <armlesshobo> guessWho: using folds might be your best bet
12:19:17 <EvanR> pliers and scissors are both tools
12:19:46 <Welkin> if you don't understand folds yet, just use explicit recursion
12:19:51 <guessWho> armlesshobo : can you be a bit more specific please
12:19:54 <Welkin> also, folds are more limited than general recursion
12:20:03 <elpfen> getting pedantic but are asm jmp loops really recursion though?
12:20:03 <armlesshobo> you have a list of keys
12:20:03 <spruit11> I had a colleague once who thought that recursion is bad for novice programmers.
12:20:17 <armlesshobo> and you have starting value (your hash map)
12:20:28 <Welkin> elpfen: yes, why not?
12:20:35 <ski> @hoogle (r -> k -> v -> r) -> r -> HashMap k v -> r  -- guessWho, are these what you mean by "loops in Haskell", here ?
12:20:36 <lambdabot> Data.HashMap.Lazy foldlWithKey' :: (a -> k -> v -> a) -> a -> HashMap k v -> a
12:20:36 <lambdabot> Data.HashMap.Strict foldlWithKey' :: (a -> k -> v -> a) -> a -> HashMap k v -> a
12:20:37 <lambdabot> Data.HashMap.Lazy foldrWithKey :: (k -> v -> a -> a) -> a -> HashMap k v -> a
12:20:50 <EvanR> ^
12:20:58 <EvanR> better tools for the job
12:21:28 <Welkin> spruit11: that is what people who learning imperative languages in school think. They think recursion is bad because languages like C or java do not have proper support for it, so they blow their memory
12:21:28 <EvanR> explicit recursion is like, the stem cells of better tools
12:21:57 <armlesshobo> spruit11: I have coworkers who think that still
12:22:09 * ski . o O ( <https://xkcd.com/297/> )
12:22:09 <armlesshobo> who've been in the industry for decades
12:22:32 <armlesshobo> hah
12:22:45 <exarkun> unchecked pointer arithmetic is a much better concept to introduce to new programmers.
12:22:47 <elpfen> Welkin: that is exactly how it was explained to me in school, it pushes a new frame onto the call stack. I was told recursion is good to solve problems but to always flatten it out if possible
12:23:05 <Welkin> elpfen: that is the C runtime model. Haskell does not have a call stack
12:23:30 <armlesshobo> does Scala?
12:23:32 <EvanR> exarkun was joking
12:23:38 <exarkun> :)
12:23:48 <ski> conceptually, calls don't push stack, setting aside work, to do later, pushes stack
12:23:58 <ski> (a call can be just a `jmp')
12:24:33 <EvanR> call with a continuation...
12:24:38 <EvanR> brilliant
12:24:45 <ski> if you are defining a labelled snippet of asm, using that label within the snippet of code, then yes, that's recursion
12:25:14 <guessWho> can someone please walk me through folds quickly >?
12:25:21 <Welkin> guessWho: not quickly
12:25:26 <ski> (aka cyclic data-structures. a recursive function is also a cyclic data-structure)
12:25:38 <Welkin> guessWho: understand recursion first and use it a lot before you take on folds
12:26:02 <ski> > foldl (+) 100 [0,1,2,3,4]
12:26:04 <lambdabot>  110
12:26:06 <ski> > foldl (+) 100 [0,1,2,3,4]  :: Expr
12:26:08 <lambdabot>  100 + 0 + 1 + 2 + 3 + 4
12:26:16 <ski> > foldl f 100 [0,1,2,3,4]
12:26:19 <lambdabot>  error:
12:26:20 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M401934918349...
12:26:20 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
12:26:24 <ski> er
12:26:26 <ski> > foldl f 100 [0,1,2,3,4]  :: Expr
12:26:29 <lambdabot>  f (f (f (f (f 100 0) 1) 2) 3) 4
12:26:49 <ski> > foldr (+) 100 [0,1,2,3,4]
12:26:52 <lambdabot>  110
12:26:55 <ski> > foldr (+) 100 [0,1,2,3,4]  :: Expr
12:26:58 <lambdabot>  0 + (1 + (2 + (3 + (4 + 100))))
12:27:04 <ski> > foldr f 100 [0,1,2,3,4]  :: Expr
12:27:06 <lambdabot>  f 0 (f 1 (f 2 (f 3 (f 4 100))))
12:27:29 <Welkin> folds are less powerful than general recursion and will take a while to understand, so I say skip folds until you are extremely comfortable with using recursion in haskell
12:27:41 <ski> guessWho : that's a very quick overview of the kind of think you can do with fold. you need more time to understand the details
12:27:58 <Welkin> folds are by no means necessary or fundamental
12:28:04 * ski seconds getting comfortable with explicit recursion
12:28:04 <EvanR> ahem
12:28:07 <elpfen> Welkin: Really? Don't folds cover a huge problem space?
12:28:16 <dsal> It took me a bit of time to get intuition about foldr
12:28:17 <ski> folds are "just" a convenience over explicit recursion
12:28:19 <EvanR> origami programming
12:28:21 <spruit11> I think they're just as powerful probably.
12:28:32 <spruit11> Depends on what you call a fold.
12:28:45 <guessWho> Welkin : i have been using recursion in haskell for quite a few weeks now and can't wait to master them before jumping on to new topics :)
12:28:57 <EvanR> generally folds allow you to define any function from a data type
12:29:22 <spruit11> Yah. It folds any data into different data. Should be general.
12:29:35 <Welkin> spruit11: if you look at the type it is not
12:29:54 <ski> (there are two notions of fold. (a) as in the `Foldable' class, for combining a sequence of elements, as accessed through some traversal order of a data structure; (b) catamorphisms, a generic way of tearing down an inductive data type. these happen to coincide in the case of `foldr', hence the confusion)
12:30:23 <spruit11> What ski says. It depends on what you call a fold.
12:31:04 <ski> @src foldr
12:31:04 <lambdabot> foldr f z []     = z
12:31:04 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:31:09 <ski> @src foldl
12:31:09 <lambdabot> foldl f z []     = z
12:31:10 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:31:12 <ski> @src foldl'
12:31:12 <lambdabot> foldl' f a []     = a
12:31:12 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:31:27 <ski> guessWho : then perhaps you're ready to tackle and understand those definitions ^ ?
12:31:35 <ski> would would reformulate the last line as
12:31:54 <ski>   foldl' f a (x:xs) = (foldl' f $! f a x) xs
12:31:58 <ski> @src ($!)
12:31:59 <lambdabot> f $! x = x `seq` f x
12:33:51 <Welkin> even foldr will feed one element at a time to your combining function, so you can't pattern match on the whole list/foldable structure at once to do something like only operate on every second or third, or take two at a time
12:34:17 <Welkin> I think I have seen some tricks to do something like that before, but it's not simple
12:34:33 <EvanR> it might not be simple to do, but folds are as general
12:35:11 <EvanR> anyway when its clearly a folding task, you want a fold
12:35:18 <EvanR> hammer -> nail
12:35:22 <ski> Welkin : i'm pretty sure you can encode those, given that you can even encode `zip', using `foldr'
12:36:01 <ski> sure, it's not completely obvious (easier when you've seen it, though)
12:36:51 <ski> one obvious approach would be to feed an auxilary "state" argument, that says whether we're at an even or an odd index
12:37:19 <Psybur> > foldr (\a b -> b + (head a)) 0 $ chunksOf 3 [1,2,3,4]
12:37:22 <lambdabot>  5
12:37:23 <Welkin> at that point I wouldn't even bother and just write it myself o.o
12:38:07 <ski> > foldr (\a b_as b -> (if b then (a :) else id) (b_as (not b))) (\b -> []) [0 ..] True
12:38:10 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
12:40:20 <Psybur> > foldr (\a b -> (last a) : b) [] $ chunksOf 2 [1,2,3,4,5]
12:40:23 <lambdabot>  [2,4,5]
12:40:31 <Psybur> > foldr (\a b -> (last a) : b) [] $ chunksOf 2 [0..]
12:40:35 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
12:40:42 <Psybur> > foldr (\a b -> (head a) : b) [] $ chunksOf 2 [0..]
12:40:44 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
12:41:14 <Psybur> Can lambdabot do micro benchmarks? :D
12:41:20 <Welkin> it won't work on a non-foldable value
12:41:57 <Welkin> I see that as a limitation
12:42:02 <ski> > foldr (\a ias_as (i,as) -> if i < 3 then ias_as (i+1,a:as) else reverse as : ias_as (1,[a])) ((: []) . reverse . snd) [0 .. 9] (0,[])
12:42:05 <lambdabot>  [[0,1,2],[3,4,5],[6,7,8],[9]]
12:42:20 <Welkin> I am not convinced that foldr is equivalent to general recursion
12:42:22 <Psybur> >.>
12:42:24 <Welkin> it has too many restrictions
12:42:27 <spruit11> Didn't they generalize that yet?
12:42:34 <ski> `foldr' is not equivalent to general recursion
12:42:45 <Ariakenom> I don't think anyone claimed that?
12:42:59 <ski> "I am not convinced that foldr is equivalent to general recursion"
12:43:19 <Welkin> okay
12:43:27 <Welkin> I thought that was the point that was trying to be made
12:43:36 <Ariakenom> yeah i meant at welin not at ski
12:43:48 <EvanR> i was talking about catamorphisms to define functions on a data structure
12:44:49 <EvanR> we know that ackermann cant be defined with 1 fold over naturals, however you can still define ackermann using a nested primitive recursion
12:44:51 * ski ponders whether there's a nice way to avoid the off-by-one
12:45:22 <EvanR> this gives me evidence that catamorphisms can define any computable function
12:46:11 <EvanR> even if its more complicated
12:46:12 <Psybur> You can use catamorphisms for anamorphisms? :D
12:47:11 <Tuplanolla> That's kind of a silly statement since you can fold any computable function over `Identity` and claim that the fold is somehow helping.
12:47:29 <Welkin> lol
12:48:04 <Psybur> Tuplanolla, thats a homomorphism though isnt it
12:48:05 <EvanR> assuming this is a function A -> X and you only have A's fold and construction rules for X
12:48:34 <EvanR> and not "any computable function" already available
12:52:07 <MarcelineVQ> why have I​ never actually read this... everyone in this room who hasn't should read https://en.wikipedia.org/wiki/Curry–Howard_correspondence (message mostly intended for the silent majority)
12:53:35 <metahumor> and then there's the Lambert part, right?
12:53:45 <Welkin> MarcelineVQ: what about it?
12:53:49 <metahumor> Lambek i mean
12:54:00 <MarcelineVQ> Welkin: all about it
12:55:14 <Welkin> math articles on wikipedia are impenetrable
12:56:16 <spruit11> Didn't used to be that way.
12:56:52 <spruit11> I actually think there are a lot of people working now to make wikipedia math pages worse, not better.
12:58:55 <elpfen> I think that's related to this? https://www.youtube.com/watch?v=qT8NyyRgLDQ
13:00:40 <EvanR> MarcelineVQ: yeah a lot of stuff like this hasnt been emphasized in this channel in a while
13:00:41 <MarcelineVQ> it's related, he seems to be talking about proof assistants like agda or coq or isabelle
13:00:52 <MarcelineVQ> ah he mentions it just after I say that hehe
13:06:40 <MarcelineVQ> elpfen neat link, it even goes into homotopy type theory
13:07:19 <elpfen> They have a couple other videos in the same vein
13:17:58 <grandpascorpion> ski, sorry for the delay.  That was an example for one prime.  The input is an (infinite) list of an (infinite) list of pairs of Integers.
13:21:05 <Myrl-saki> :t traverse (f :: Monad m => a -> m b)
13:21:07 <lambdabot> error:
13:21:07 <lambdabot>     • Could not deduce (Show a1) arising from a use of ‘f’
13:21:07 <lambdabot>       from the context: (Monad f, Traversable t)
13:21:20 <Myrl-saki> :t traverse return
13:21:21 <lambdabot> (Monad f, Traversable t) => t b -> f (t b)
13:21:35 <Myrl-saki> :t return . head
13:21:36 <lambdabot> Monad m => [a] -> m a
13:21:41 <Myrl-saki> ...oh
13:21:49 <Myrl-saki> I'm fucking stupid. Lol.
13:22:04 <spruit11> That's not noteworthy.
13:22:09 <spruit11> Most people are.
13:22:12 <spruit11> Me too.
13:22:27 <ski> grandpascorpion : mhm .. we're still missing the cut off part after the "The initial term for each lis" part, in your original message
13:22:29 <Myrl-saki> spruit11: I was about to break down and cry and shout that my traverse is broken.
13:23:46 <spruit11> Can I interest people in blowing up my tiny untyped functional language? https://egel-lang.github.io/ (Shamelessly trying to pick of #haskell)
13:24:39 <spruit11> Is there are proglang channel? Maybe try there.
13:25:08 <Myrl-saki> spruit11: ##programming
13:25:24 <spruit11> I'll try that.
13:25:28 <spruit11> See what gives.
13:27:24 <ski> MarcelineVQ : read it
13:27:41 * ski . o O ( #proglangdesign )
13:39:02 <pdxleif> Is there some newer default-language to put in the .cabal file than Haskell2010? I get a parse error from "cabal build" but not running ghc directly if I don't indent the body past the variable name in "let foo = do ..."
13:39:42 <glguy> Maybe you want {-# Language NondecreasingIndentation #-} ?
13:46:26 <geekosaur> what glguy said. there possibly should be a default-language that actually does the default, instead of explicit Haskell2010 turning off default-on extensions like NondecreasingIndentation
13:47:04 <geekosaur> which is Cabal not realizing that ghc is up to shenanigans
13:54:50 <grandpascorpion> Hi ski, here is my code: http://lpaste.net/1512921694807785472 .  Painfully slow.  The idea is to lazily generate (sigma(n), n) sorted by sigma(n) then n (for each n).  There's a formula to determine sigma(n) based on n's factorization but I wanted to avoid doing that as it's expensive.
14:21:54 <jcowan> I have a question about catching exceptions
14:22:25 <jcowan> I understand why ordinary exception-catching can only be done in the I/O monad: because it is non-deterministic which exception has been raised.
14:23:17 <jcowan> But shouldn't it be possible to have a pureCatch function of type a -> Either Exception a, where all we know is whether the result is normal or exceptional?
14:23:29 <johnw> yes, that exists
14:23:30 <jcowan> Then there is no non-determinism
14:23:41 <johnw> see the pure instances of MonadCatch
14:23:41 <jcowan> oh, what is it called?
14:23:55 <johnw> http://127.0.0.1:8687/file/nix/store/jiglybxrks3bsyj20y7k8cxwgmvxwisv-exceptions-0.8.3-doc/share/doc/html/Control-Monad-Catch.html#t:MonadCatch
14:23:59 <johnw> oops, wrong link
14:24:08 <johnw> https://hackage.haskell.org/package/exceptions-0.10.0/docs/Control-Monad-Catch.html
14:24:45 <c_wraith> @hac spoon <-- jcowan
14:24:45 <lambdabot> http://hackage.haskell.org/package/spoon <-- jcowan
14:25:10 <c_wraith> jcowan, note that spoon violates haskell semantics in some ways, and can cause bugs.
14:25:19 <ski> hm, i think what johnw pointed to isn't what jcowan had in mind
14:25:30 <johnw> yes, quite possibly
14:25:31 <jle`> jcowan: there isn't really any way to write such a function that doesn't break the semantics of haskell values
14:25:44 * jcowan scratches head
14:25:49 <jcowan> can you explain that further?
14:26:07 <jle`> but spoon does give you exactly that
14:26:19 <jle`> it could also give Either too, i wonde rwhy it doesn't
14:26:32 <jle`> maybe because it was last updated in 2013
14:26:33 <ski> well, the problem with that ("a pureCatch function of type a -> Either Exception a") is that that precludes the compiler rearranging the order (or more aggresive "transposition"/"convolution" of them, including loop fusion, e.g.) in which it evaluates expressions which is bound to get evaluated anyway
14:27:05 <c_wraith> jle`, also, if you don't report what the error was, the non-determinism can't bite nearly as hard.
14:27:11 <jle`> jcowan: semantically, things like 'undefined' and 'error "hi"' are treated as bottom
14:27:28 <jle`> that's how we reason with them, in the denotational semantics
14:27:29 <c_wraith> jle`, really, you can only get bitten by throwTo with spoon
14:27:31 <ski> in `error "foo" + error "bar"', the semantics allows us to get either of the two exceptions. and in the I/O case, we attribute this to the general indeterminacy of I/O, which is already there (due to e.g. concurrency scheduling, race conditions)
14:27:49 <jle`> semantically they are treated the same way as nonterminating computation
14:27:54 <ab9rf> ugh, i hate exceptions
14:28:00 <ski> if we allowed a `pureCatch' (as `spoon' does), then suddenly we'd have to fix an evaluation order
14:28:11 <jle`> so being able to detect if a value of type X is 'actually X, or bottom' is not supposed to be possible, semantically
14:28:26 <c_wraith> ski, and throwTo exists!
14:28:28 <jcowan> ski: Right, but if we blur the difference between the two into a single niladic constructor, then there is no actual indeterminacy, no?
14:28:36 <jle`> ab9rf: exceptions are a pretty useful runtime feature of ghc; abuse of exceptions is pretty bad, though
14:28:50 <ab9rf> jle`: it's more that i hate them in a theoretical way :)
14:28:56 * jcowan chuckles
14:29:02 <c_wraith> jcowan, there's *always* throwTo waiting to break your assumptions
14:29:10 <jle`> they make a lot of sense in  the runtime, with clear denotational semantics
14:29:16 <ski> jcowan : if one can't determine the actual identity of the exception in an `Exception' value, apart from say using an I/O operation, then that may be more acceptable, hmm
14:29:16 <jle`> it's just working with them outside of IO that is bad bad
14:29:25 <ab9rf> exceptions irritate my sense of determinancy
14:29:50 <jle`> there are situatinos where nondeterminancy is a key part of your algorithm
14:29:51 <jcowan> a single blurred exception seems to be analogous to NaN
14:29:58 <jcowan> s/seems/seems to me
14:30:06 <ab9rf> NaN is another thing i am not terribly fond of
14:30:13 <jle`> jcowan: NaN is more like an actual defined constructor of Double
14:30:35 <jle`> _|_ means an implicit extra contstructor for every type in haskell
14:30:58 <jcowan> ab9rf: But NaN has pretty clear semantics:  either the range [-inf..+inf] or the range []
14:31:05 <ski> well, consider `error "foo" + let x = x in x', should this raise an exception, or should it hang indefinitely ?
14:31:47 <jle`> denotational semantics of haskell are meant to treat 'undefined' etc. as indistinguishable from nonterminating computation
14:31:59 <ski> the current semantics says "either, since we don't distinguish those cases, denotationally"
14:32:01 <jcowan> that is, on an understanding of floats as ranges of real numbers
14:32:08 <jcowan> ski: Works for me
14:32:11 <jle`> so being able to detect 'undefined' vs. actual nonterminating computation breaks the semantics
14:32:28 <jcowan> ah, I begin to approach enlightenment, I think
14:32:30 <jle`> jcowan: that's the problem, your function is no longer deterministic/pure, then
14:32:34 <jle`> if either are denotationally valid
14:32:44 <jle`> so it might return Left on some days
14:32:44 <ski> however, with `pureCatch', with a "purely undistinguishable" `Exception', we'd still have to fix evaluation order
14:32:48 <jle`> and Right _|_ on others
14:33:37 <jle`> you can then use this function to detect things like GHC optimization level
14:33:37 <ski> generally, people are usually (...) fine with the compiler "optimizing" a program so that it hangs more seldom than otherwise
14:33:42 <jle`> (purely)
14:33:45 <ski> but they're not fine with the reverse situation
14:34:09 <ab9rf> reminds me of the obscure TCP protocol option "FAILRANDOMLY"
14:34:10 <jle`> as in, the level of ghc optimization will determine if you return Left or Right
14:34:30 <jle`> which changes the denotational result of your program
14:34:36 <ski> and, one can argue that the former is also bad, since then you can have a program which *appears* to work fine, under a particular implementation, on a particular architecture, with particular optimizations, but in a different circumstance will cause a hanging program
14:34:40 <ski> which isn't nice
14:36:17 <jcowan> What if the argument to pureCatch is made strict?  Then if the argument never returns, neither does pureCatch (fate-sharing).
14:36:36 <jle`> how do you detect if the argument never returns?
14:36:43 <jle`> wait infinitely long?
14:36:46 <ski> well, if you made `pureCatch' never return (iow go into a loop), when the argument raised an exception, then that'd be ok
14:36:49 <ab9rf> use an oracle
14:36:53 <ski> but that'd defeat the point of it
14:37:02 <Myrl-saki> jle`: Parse HTML with regex.
14:37:25 <jle`> maybe GHC can analyze the code and detect if it will return a value in finite time
14:37:25 * Myrl-saki hopes the reference is not lost
14:37:30 <jle`> Myrl-saki: it was not lost :)
14:37:46 <ab9rf> Myrl-saki: isn't that prohibited by the geneva convention?
14:38:22 <jcowan> Yes, the CERN sub-convention.
14:38:53 <jle`> sounds delicious
14:39:03 * ski . o O ( "RegEx match open tags except XHTML self-contained tags" <https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/#1732454> )
14:39:29 <ab9rf> that is a fine answer
14:41:48 <loli> allsprk.tv
14:41:50 <loli> whoops
14:41:54 <loli> my bad, wrong buffer
14:44:08 <jcowan> So in summary a safe pureCatch has type a -> a; it transforms exceptions into infinite loops
14:44:19 <jcowan> which indeed is not really a very useful thing to do
14:47:37 <ski> sometimes we say that Haskell has no *side*-effects. but strictly speaking, partiality (like `cdr' on an empty list, running off the tail end of a `cond'/`case'/`match' with no catch-all clause (like an `else'), but also including exception raising/signalling), and also nontermination, are still side-effects in Haskell, although they are more benign than other kinds of side-effects, doesn't cause as much damage to reasoning
14:50:21 <ski> (to avoid even these, one'd have to go to a total functional programming language. such a language could still allow optional partiality and optional (potential for) nontermination, e.g. by using a monad ..
14:50:37 <ski>  also, "total" doesn't preclude servers that run until further notice, one just has to include the concept of "productivity" together with "totality", while distinguishing between "inductive data types", and "coinductive data types" (cf. streams, OO objects))
14:51:21 <jcowan> I've read some discussions of total FP; it actually looks quite appealing
14:51:30 <jcowan> it is not Turing-complete, but then hardware is not Turing-complete either
14:51:54 <ski> (also, apart from the built-in "imprecise exceptions" (see the three papers mentioned at <https://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Exception.html>). there's also encodings of exceptions in Haskell, based on the `Either' data type)
14:52:06 * ski nods
14:52:30 <jcowan> I've read the first paper
14:52:35 <jcowan> will queue up the other two
14:53:04 * ski idly wonders whether there's a nice package for restartable conditions in Haskell
14:53:42 <jcowan> Riastradh's Scheme package is quite portable and might be worth looking at
14:54:30 <jcowan> http://mumble.net/~campbell/proposals/restart.text
14:54:35 * ski nods
14:54:54 <jcowan> s/text/scm for the code
14:57:39 <ab9rf> jcowan: how dare hardware fail to be turing complete! we must demand better hardware!
14:58:10 * ski idly recalls something about compiling Haskell code to FPGA
14:58:29 <jcowan> sorry, no room, but "there's a hell of a universe next door, let's go" (E.E. Cummings)
15:00:09 <jcowan> It looks to me like throwTo is a Bad Thing
15:03:19 <erisco> say you have a tree A, and a second tree B, such that if X → Y is an edge in B then X is a descendant of Y in A, and if X → Y and X → Z are edges in B then neither Y is a descendant of Z or Z is a descendant of Y (assuming descendancy is non-reflexive)… what is such a tree B called?
15:05:13 <erisco> another way to say it is B is formed by removing nodes from A, where the parent of a removed node adopts the removed node's children
15:06:34 <erisco> otherwise I am just going to call B and extract of A
15:07:49 <Tuplanolla> In your description B is inverted wrt A, erisco.
15:08:22 <ackthet> so, is GHC written in haskell, but the runtime is C?
15:08:27 <erisco> inverted? that is an odd word to use
15:08:55 <erisco> what about it is inverted?
15:09:23 <Tuplanolla> I got that if X → Y is in B then Y → X is in A.
15:09:35 <ski> you said "X is a descendant of Y in A" rather than "Y is a descendant of X in A"
15:10:21 <erisco> oh, sorry, I guess that is just due to how directionality makes sense to me with trees :P
15:10:47 <ackthet> okay, seems like the type checker and lexer are Haskell, the runtime is C?
15:11:21 <erisco> I think the second is consequence of the first, so lets say this differently
15:13:39 <EvanR> what do i have to enable to get unboxed tuple syntax to work ?
15:14:03 <EvanR> in ghci i keep getting Parse error in pattern: # z1
15:14:35 <erisco> well, a formalisation is not difficult but it is noisy… lets just try the English again
15:14:50 <erisco> if X → Y is an edge in B, then X is an ancestor of Y in A
15:15:59 <jcowan> some people are so political they demand better amniotic fluid
15:16:06 <jcowan> (for themselves)
15:16:16 <EvanR> ah, UnboxedTuples
15:16:21 <erisco> my knowledge of term rewriting is drawing a blank here too
15:17:06 <Tuplanolla> The transitive arrow symbol →⁺ would help, erisco.
15:17:23 <erisco> okay, we can bust out that notation
15:17:53 <erisco> if x →* y in B then x →* y in A
15:18:59 <ski> hm, one relation is contained in the transitive closure of the other
15:19:31 <erisco> yeah, in other words the transitive closure of one is a subset of the other
15:19:44 <Tuplanolla> I can understand this, but now I feel that you don't actually mean what you wrote.
15:20:00 <erisco> why not?
15:20:05 <ski> yea, i think you meant the other way around
15:20:16 <erisco> why? :s
15:20:42 <ab9rf> this entire discussion has left me confused
15:20:56 <ab9rf> i don't understand why we are having it
15:21:22 <ski> "the transitive closure of one is a subset of the other" would mean (at least if we're talking finite sets of nodes), in a nontrivial case, that the "other" already contains `A -> B',`B -> C' as well as `A -> C', for distinct `A',`B',`C'
15:21:34 <ski> so the "other" relation is not a "direct subtree" relation, then
15:21:45 <erisco> the transitive closure of the other
15:21:57 <erisco> that was an English problem
15:22:02 <ski> ah, i see
15:22:12 <Tuplanolla> There's also a difference between "if X →⁺ Y is in B then X →⁺ Y is in A" and "let E = X →⁺ Y in if E is in B then E is in A".
15:24:04 <erisco> the ascii is painful
15:24:32 * ski isn't really sure the latter makes any sense at all (as opposed to being relevant, say)
15:25:05 <erisco> A = -> and B = ~>  then  ∀xy. x ~>+ y ⇒ x ->+ y
15:25:11 <erisco> gr, I meant *
15:25:16 <erisco> A = -> and B = ~>  then  ∀xy. x ~>* y ⇒ x ->* y
15:26:20 <erisco> at any rate, I figured this kind of relation would be useful for working with DOM
15:27:01 <APic> Okay.
15:27:02 <ski> reflexive-transitive closure ?
15:27:31 <erisco> that's right
15:27:57 <ski> i suppose merging states in a state graph (e.g. a clique) is a somewhat similar thing
15:28:23 <erisco> that is just a shorter way to say if the node is in one tree then it must be in another
15:28:23 <ski> except that there we have a surjection, but you have an injection
15:28:27 <erisco> as opposed to just talking about the edges
15:29:00 * ski idly wonders whether uniform spaces, or topological spaces, could be relevant to what erisco wants to think about
15:29:26 <erisco> the importance of this relation to me is that the smaller tree retains the same (transitive) structure as the other
15:30:44 <erisco> so, in relation to DOM, this means you can coalesce many elements into a smaller, well-typed structure which retains the same logical structure
15:31:15 <erisco> part of a theory for widgets, if you will :)
15:31:24 <APic> ,o0(PuTTY)
15:33:49 <erisco> I began to realise the problem is moreso the awkwardness of working with a weakly typed and overly verbose DOM than anything else
15:34:44 <ski> (anyway, ⌜∀ x y. x ⇝⃰ y ⇒ x →⃰ y⌝ should be equivalent to ⌜∀ x y. x ⇝ y ⇒ x →⃰ y⌝)
15:35:11 <ski> erisco : hm, now this reminds me of ornaments
15:35:14 <erisco> there should be several equivalences, yes
15:35:26 <APic> lol
15:48:11 <ospa> Hi! What would be the easiest way to transform list of list of numbers like [[1,2,3], [4,5,6], [7,8,9]] to list containing first elements, list containting second etc: [[1,4,7], [2,5,8], [3,6,9]] ?
15:48:33 <ospa> can we use some ocmbinators ot I have to write jsut function for it ?
15:48:43 <ospa> id reallyl ike some fancy combinators if thats possible
15:48:47 <erisco> ospa, transpose
15:48:51 <Myrl-saki> :t t
15:48:53 <lambdabot> Expr
15:48:56 <Myrl-saki> erisco: whyyy
15:49:06 <Myrl-saki> Someone always gets it earlier than me. :(
15:49:20 <Myrl-saki> > sequence [[1,2], [3,4]]
15:49:21 <ospa> erisco: oh, hahah
15:49:23 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
15:49:26 <ospa> erisco: thank yo uso much!!!
15:49:28 <Myrl-saki> Oh, that's different.
15:49:48 <Myrl-saki> Sequence is like Cartesian product for lists?
15:50:06 <erisco> the n-ary Cartesian product, yeah
15:50:06 <hpc> :t sequence
15:50:08 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
15:51:13 <hpc> oh yeah, it's more polymorphic now
15:51:25 <erisco> Myrl-saki, my skills were forged in the fires of Stackoverflow, where points are awarded to speed over quality
15:51:29 <hpc> i wonder if there are any particularly interesting new traversibles for it
15:51:56 <erisco> good enough now > better later
15:52:05 <Myrl-saki> erisco: Haha
15:52:10 <hpc> the ultimate programming simulator
15:52:23 <Myrl-saki> erisco: Don't forget the -5 points, but accepted answer.
15:52:42 <hpc> the best part of stackoverflow is the answers don't have to be correct
15:52:49 <hpc> they just have to seem correct to someone who doesn't know better
15:53:51 <Myrl-saki> hpc: Woah, they even got management correct.
15:54:17 <erisco> it was annoying at first, because my prior Q&A experience taught me to carefully understand each aspect of a question before trying to answer
15:54:42 <ab9rf> hpc: heh
15:54:51 <ab9rf> hpc: all Q&A sites have that problem
15:54:57 <erisco> because in a one-on-one discussion it wastes a lot of time and energy to wait for them to realise you have misunderstood
15:55:25 <ab9rf> hpc: as does wikipedia, of course
15:55:51 <Tuplanolla> Are your conditions actually just the functor laws for a tree-shaped category indexed by another tree-shaped category, erisco?
15:55:52 <erisco> but with many people competing to give answers at once, it is just a contest to get chosen by the questioner
15:56:22 <ab9rf> erisco: that particular aspect of SO's community is a large part of why i never got involved there
15:56:47 <ab9rf> i tend to write long, well-researched, often discursive answers to questions, and SO hates that. they want short, quick, simple
15:56:51 <hpc> what keeps me away from stackoverflow is how much of it is gated behind that karma
15:57:09 <erisco> yeah I have done that several times ab9rf, and a low number of them are ever recognised
15:57:11 <ab9rf> and if you didn't get into the in crowd early on at SO you are forever locked out
15:57:19 <erisco> some answers I put more than an hour of work into
15:58:32 <erisco> it is also harder to participate over time, kind of like mining cryptocurrency :P
15:58:39 <ab9rf> so i just ignore SO :)
15:59:18 <APic> ☺
15:59:19 <erisco> when a new topic is invented, any question is new, but after some time all the obvious stuff has been asked, and over a long time all you are left with is purely niche problems
15:59:20 <hpc> erisco: heh, the mechanics of them are remarkably similar
15:59:24 <erisco> like "here is my code it doesn't work help"
16:00:38 <ab9rf> the lowhanging fruit problem
16:00:51 <Rembane> It's very good for all the googlers out there though
16:00:57 <hpc> eh, sort of
16:00:57 <erisco> and the traffic to a question is proportional to how generic or simple it is… i.e. the people there in the beginning soak up a magnitude more points than the people at the end
16:01:09 <ab9rf> Rembane: well, those who can tell good answers from bad one that happen to be highly upvoted, at least
16:01:34 <hpc> SO is so hostile to nuance that when you have a problem that can't be solved with documentation, it's probably been closed for some contrived reason
16:01:56 <hpc> it happens to me all the time
16:02:09 <Rembane> ab9rf: Indeed. It hasn't bitten me too hard yet. It probably will now because of jinx.
16:02:11 <hpc> you search for some error, SO comes up, but the error isn't the same as what you're having
16:02:12 <erisco> closed as a duplicate?
16:02:20 <hpc> and it's the only question that's even close, with activity
16:02:48 <ab9rf> SO has occasionally been helpful for me in solving problems, but honestly i usually get more mileage out of other sites
16:02:52 <hpc> you usually don't find the other questions at all, because search engines put you in such a hard popularity bubble
16:03:41 <hpc> strangely, SO used to be really reliable for solving niche issues
16:04:06 <hpc> and i guess either technology changed and it didn't keep up with new questions
16:04:14 <hpc> or the good questions got pushed out somehow
16:05:21 <f-a> I have a library with one module exposed, which reexports a bunch of other modules
16:05:27 <hpc> perhaps it started going downhill when they decided to subdivide the technical stackexchanges
16:05:36 <f-a> which is the way to go to have haddock build the relevant documentation?
16:05:46 <hpc> so you have stackoverflow, but also cs, math, and i forget the others
16:05:46 * ski . o O ( "Why I no longer contribute to StackOverflow" by ttmrichter in 2013 at <https://web.archive.org/web/20151113155810/http://michael.richter.name:80/blogs/awhy-i-no-longer-contribute-to-stackoverflow> )
16:06:09 <f-a> as now, (I use the (module All)) trick, I see nothing
16:06:37 <Tuplanolla> There is also Interpersonal Skills Stack Exchange, where experts provide correct solutions to social situations, hpc.
16:07:09 <hpc> haha
16:07:59 <hpc> when i ended up giving up on getting information from SO, i remember the niche subdomains being significantly better than the main site
16:08:22 <hpc> photography and scifi iirc were the best i found
16:08:26 <f-a> hpc: that's unfortunately true for most (all?) upvote/downvote sites
16:09:29 <f-a> disqus, reddit, all have niche communities which are significantly nicer
16:10:11 <hpc> i have only ever seen "disqus" in noscript's domain list lol
16:13:21 <ab9rf> ski: his point on java quesitons is meritorious. i used to write extensive answers to java questions on quora, even though i've never written anything larger than a toy program in java and have no real experience in the language. but i can read :)
16:14:22 <hpc> the nice thing about java for those things is that you can answer a question in a few sentances that takes 1000 lines to implement
16:14:52 <Welkin> Tuplanolla: interpersonal skills stack exchange? o.o
16:15:46 * ski . o O ( <http://blog.functorial.com/posts/2018-03-12-You-Might-Not-Need-The-Virtual-DOM.html> )
16:15:59 <Welkin> you don't if you use reflex
16:16:05 <ab9rf> the thing is, you don't have to be a technical expert to write articles explaining a thing. you just have to be able to analyze sources and synthesize them into a single summary. this is a skill that anybody who does any sort of serious academic program will learn to some degree. humanities majors tend to be better at it than technical majors, of course.
16:16:35 <Welkin> communicating is a very valuable skill
16:17:18 <Welkin> often it seems that the person who is most skilled/knowledgeable in a particular topic is not the best at explaining it for a number of reasons
16:17:38 <amalloy> ab9rf: most of the stuff in that article matters a lot less if you realize that the points don't matter. it's just a good place to ask and answer technical questions
16:17:49 <koz_> What Welkin said times a hundred.
16:17:52 <Welkin> one of those reasons being, they simply don't care to do it, and so they don't
16:17:53 <ab9rf> amalloy: except points do matter, because your ability to do things is tied to points
16:18:26 <koz_> Welkin generally says very sensible things and everyone should listen.
16:18:31 <dbousamra> How do i lift a function with type Applicative f => f a -> f b, to work on ExceptT's?
16:18:41 <amalloy> you can easily get enough points to do anything you want to do by posting good answers to questions even in low-traffic tags
16:19:05 <amalloy> if you want the 20k moderation tools then, okay, it will either take a while or you can speed it up by answering python questions
16:19:25 <Welkin> lol, python questions
16:19:44 <Welkin> python is the hottest language these days (deep learning)
16:19:47 <ab9rf> i'd rather go on irc and interact with people trying to learn the language
16:20:01 <ackthet> go to #haskell-beginners
16:20:14 <ackthet> theres one for most langs on freenode tbh
16:20:14 <amalloy> good idea, ab9rf. please, i would love it if you talked about haskell in irc
16:20:19 <f-a> (to answer my own question, don't use the `as All` trick to reexport modules)
16:20:21 <ab9rf> ackthet: i'm often in there. not today, because i had to restart  my irc client recently
16:20:25 <ackthet> savage
16:20:33 <lyxia> dbousamra: what does it mean to work on ExceptT's
16:20:40 <ab9rf> amalloy: i was earlier, but somehow this nonsense came up
16:21:04 <lyxia> dbousamra: there's an instance of Applicative for ExceptT
16:22:17 * ski suspects dbousamra wants something like `forall i e a b. Applicative i => (i a -> i b) -> (ExceptT e i a -> ExceptT e i b)'
16:22:31 <dbousamra> lyxia: Basically, i have an operation ExceptT e IO a, that I want to repeat forever using the forever function, until an error
16:22:55 <dbousamra> ski, yeah that looks about right
16:22:56 <ski> @type \f -> ExceptT . f . runExceptT
16:22:58 <lambdabot> (m1 (Either e1 a1) -> m2 (Either e2 a2)) -> ExceptT e1 m1 a1 -> ExceptT e2 m2 a2
16:23:24 <ab9rf> applicative is a functor and exceptT hsa a functor instance
16:24:02 <ski> dbousamra : would `forall i j e. (Applicative i,Applicative j) => (forall a. i a -> j a) -> (forall a. ExceptT e i a -> ExceptT e j a)' work, instead ?
16:24:29 <ski> ab9rf : that's not the problem
16:24:54 <ski> dbousamra is running into a "monad tunneling problem" kind of thing, i think
16:25:01 <ab9rf> mmm, could be
16:25:04 <dbousamra> yeah, i tried that (ExceptT $ f $ runExceptT op) - it type checks, but my errors seem swallowed.
16:25:34 <ski> yea, `\f -> ExceptT . f . runExceptT' is (presumably) not what you were looking for. just showing it, to compare what you can easily get
16:26:42 <ski> @type let hoistExceptT :: (forall a. i a -> j a) -> (forall a. ExceptT e i a -> ExceptT e j a); hoistExceptT f = ExceptT . f . runExceptT in hoistExceptT
16:26:44 <lambdabot> (forall a1. i a1 -> j a1) -> ExceptT e i a -> ExceptT e j a
16:27:00 <ski> this rank-2 version of it, could perhaps work, though, depending on what you're doing
16:27:12 <dbousamra> i'll try
16:27:59 <ab9rf> oh i get it
16:28:04 <ski> (compare with <https://hackage.haskell.org/package/mmorph-1.1.1/docs/Control-Monad-Morph.html#v:hoist>)
16:28:09 <ab9rf> although not why the errors disappear
16:28:17 * ski neither
16:28:18 <ab9rf> at least not exctly
16:31:40 <lyxia> dbousamra: If you want to stop on error, isn't that just what forever does with ExceptT
16:33:19 <frerich> ab9rf: Remember the 'Find smallest set of numbers drawn (with repetition) from a list of numbers such that their sum equals a given value' issue I asked about earlier today? You mentioned that this sounds like a knapsack problem.
16:34:58 <frerich> ab9rf: I now noticed that I don't even need any dynamic programming by exploiting the fact for drawing n from m numbers, I don't want 'replicateM n xs' because that will yield a lot of lists with equal elements (just in a different order, but their sum is of course the same). Instead, I do something slightly more involved based on 'tails' such that I only get sets drawn with different arrangements of elements.
16:35:40 <ab9rf> frerich: ok. sounds like that reduces the solution space you have to search
16:36:39 <frerich> ab9rf: My solution (this was a little exercise for some online programming puzzle thing) is now just http://lpaste.net/5269884533859155968 -- and yes, the key insight was that 'draw' can be a lot more clever than just replicateM
16:37:14 <frerich> ab9rf: The only other complication was that it's possible that there is no way to form the desired target value, i.e. I have to determine an upper bound (that was easy enough though).
16:37:21 <wz1000> is there any way to write a pure function a -> a -> a that evaluates its arguments in parallel and returns the one that evaluates first, treating undefined/exceptions as a loop?
16:37:23 <ab9rf> frerich: i suspect that this porlbme is likely pseudopolynomial, but the solution space is "small enough" for small n that it's solvable.
16:37:38 <ab9rf> frerich: if you did it for N of 1 billion, it would take forever :)
16:38:11 <ski> wz1000 : i'd say no to that. `unamb' or `lub' might perhaps be useful alternatives
16:38:48 <frerich> ab9rf: Since this function is described as finding the smallest set of coins to use for giving some change back, I imagine that values in the range of 1 billion would pose other issues (e.g. the volume needed to accomodate 1 billion cents), but yeah. :-)
16:39:36 <ab9rf> frerich: that makes it pseudopolynomial, but a lot of pseudopolynomial algorithsm run in reasonable time for realistic problem sets
16:39:45 <ski> wz1000 : or perhaps you're looking for somethingl like `waitEither' at <https://web.archive.org/web/20170816074532/http://chimera.labs.oreilly.com:80/books/1230000000929/ch11.html> ?
16:40:29 <ski> @hackage unamb
16:40:30 <lambdabot> http://hackage.haskell.org/package/unamb
16:40:49 <frerich> ab9rf: Anyway, thanks for your pointer to knapsack. I read up on it and learned a good bit on the way (including that my problem is probably simpler, and that lazy evaluation helps with not having to figure out the right order to populate cells in a table when doing dynamic programming). So it was a good ride. :-)
16:41:11 <ab9rf> frerich: i'm glad i was able to be of some assistance. i'm really rusty on a lot of this stuf
16:41:18 <ski> @hackage lub
16:41:19 <lambdabot> http://hackage.haskell.org/package/lub
16:41:22 <ab9rf> my partial CS degree was abandoned in 1991 :)
16:41:34 <ski> @hackage lvish
16:41:35 <lambdabot> http://hackage.haskell.org/package/lvish
16:41:42 <ab9rf> i ended up graduating with a political science degree :)
16:42:52 <frerich> ab9rf: For me, it's really just evening time amusement once the wife & kids are in bed (or otherwise busy ;-). I unfortunately never got around to building something real in Haskell (other than some boring things like IRC clients or such).
16:43:22 <frerich> ab9rf: The last project I started ended with me noticing that it's actually 30% SQL, 5% Haskell and 65% JavaScript...
16:43:39 <Welkin> frerich: make a video game
16:43:59 <conal> wz1000: what you're describing is not a (pure) function, so fortunately Haskell doesn't let write it as a pure function. lub is a closely related pure function with a side condition that cannot be verified in Haskell's type system, namely that the two arguments contain consistent information.
16:45:17 <conal> wz1000: however, lub cannot be implemented _in_ Haskell without cheating (unsafePerformIO).
16:45:33 <ab9rf> i do not understand what unamb does
16:45:48 <conal> ab9rf: do you mean how it works or what it means?
16:45:58 <dbousamra> hmm. Thanks all. I realised I was a bonehead and lyxia was right all along. I can just call forever on an ExceptT.
16:46:00 <ab9rf> conal: either, really
16:46:15 <ski> dbousamra : ah, ok
16:46:33 <erisco> if it compiles then it is Haskell :P
16:46:37 <wz1000> I want the disjunctive operator on data S = T, S = {_|_, T}, T \/ T = T; T \/ _|_ = T; _|_ \/ T = T; _|_ \/ _|_ = _|_
16:46:51 <ab9rf> conal: i see that it uses unsafePerformIO internally so obviously dark magic is involved
16:47:07 <wz1000> if we had some kind of parallel pattern matching this would be a pure function
16:47:13 <ski> oh, you want parallel "or" on Sierpinski !
16:47:21 <wz1000> yes
16:47:25 <conal> ab9rf: it's a special case of lub, so let's talk about lub instead. The meaning of 'lub a b' is independent of its implementation. and it's the heart of the mathematical meaning of programming languages. ...
16:47:29 <erisco> his triangle?
16:47:55 <Welkin> erisco: no longer at work?
16:48:04 <Welkin> did you exit hyperspace?
16:48:04 * erisco <--- check the nick
16:48:06 <wz1000> no, his topology
16:48:28 <conal> ab9rf: The meaning of 'lub a b' is the least upper bound (hence the name) of the information contained in a and b. The side condition is that the l.u.b. exists. ...
16:48:49 * ski idly wonders whether `gustave' or `majority' can be defined using `lub'
16:48:51 <lyxia> conal: BTW have you seen my PR on unamb https://github.com/conal/unamb/pull/1
16:48:57 <conal> ab9rf: The (partial) ordering in question is on information, where "bottom" (misleadingly written "undefined" in Haskell) is the bottom of the ordering and fully defined values are at the tops.
16:50:06 <conal> ab9rf: you can find out more about info orderings and their (central) role in meanings of programming languages here: https://en.wikibooks.org/wiki/Haskell/Denotational_semantics
16:50:26 <ab9rf> conal: i have some reading material now, and will have a look
16:50:30 <erisco> to unpack that read "Denotational Semantics: The Scott-Stratchey Approach to Programming Language Theory"
16:50:31 <ab9rf> do not feel obliged to explain here and now :)
16:50:40 <conal> ab9rf: keep in mind, that the math meaning is independent of various implementation possibilities.
16:50:52 <erisco> where you will learn about lattices
16:50:53 <wz1000> ah, looks like unamb works
16:52:02 <conal> wz1000: and as i mentioned, use lub, not unamb. unamb correctly implements lub only for "flat" types like (), Bool, and Int, while lub is correct for fancier types like sums, products, and functions.
16:52:10 <erisco> and how to give precise meaning to "my program crashed/hung"
16:52:28 <conal> (as well as for flat types)
16:53:21 <ski> conal : wouldn't `S' (aka `Sierpinski') above be a flat domain ?
16:53:24 <wz1000> conal: ah. really I only want it for ()
16:53:26 <conal> these information orderings were invented (by Dana Scott) in order to explain what recursion means.
16:53:35 <conal> wz1000: probably not.
16:53:53 <ab9rf> conal: i actually do better when the discussion moves outside of implementations. :)
16:54:03 <ski> (`T' stands for `Terminated' aka `True', while `_|_', non-termination, would be a kind of `False'.)
16:54:28 <ski> (s/recursion/general recursion/)
16:54:31 <conal> ab9rf: good. to me, implementations are neither correct nor incorrect without a spec.
16:54:42 <conal> ski: yeah.
16:54:55 <erisco> ab9rf, well that's good. Some people prefer to hold themselves an inch from the TV and complain they can't see the picture.
16:55:23 <ab9rf> erisco: the bulk of my formal training in is law. it's all squishy.
16:55:24 <conal> erisco: :)
16:56:00 <ab9rf> broad abstract concepts are easier to deal with than concrete instances, which are always full of stupid exceptions.
16:57:00 <ab9rf> i really should go look to see what the deontic logic people have done in the past five years oro so
16:58:27 <conal> erisco: about your Joe Stoy reference, it's the text I learned from, but it's also rather out of date. we no longer use top, so we don't have lattices anymore. i don't know when or why this change happened.
16:59:35 <ski> hmm .. i think some of the papers with abstract interpretation of values, and demands on values, uses/used top ?
16:59:36 <conal> erisco: the math of general recursion (least fixed point) depends on bottom, but not top.
16:59:59 <conal> ski: sure. some domains can have top, but the domain theory doesn't need it.
17:00:13 <Axman6> ab9rf: well, this for one: http://www.data61.csiro.au/en/Our-Work/Future-Cities/Optimising-service-delivery/RaaP
17:00:17 <wz1000> I'm really enjoying "Synthetic topology of data types and classical spaces"
17:00:27 <conal> whereas bottom is what gets recursion started.
17:00:29 <Axman6> (I sit next to that team at work)
17:00:43 <Axman6> ((also that team is not the people in the picture))
17:01:00 <Axman6> (((9/11 was an inside job)))
17:01:09 <erisco> if you know of a more modern resource conal then I'd be pleased to give it a read
17:01:12 <Axman6> pretty sure that's how brackets work
17:02:55 <conal> erisco: i can't vouch for them, but there's David Schmidt's book and Carl Gunter's book.
17:03:32 <orion> Boston Haskell meetup Wednesday, 3/21 for thsoe interested.
17:05:09 <erisco> hm, they do not make themselves easily found on the book sites I order from
17:15:07 <dbousamra> alright, i have another question - I have a function: IO () -> IO (). How do I lift this to an ExceptT context?
17:15:28 <ski> wz1000 : i take it you have checked out the "impossible" posts ?
17:18:47 <zachk> is it normal for a haskell database library to throw an exception when the query is invalid? what to do...
17:19:22 <zachk> of course it is inside a cloud haskell "actor" so it just fails silently and the program keeps running
17:22:47 <wz1000> ski, conal: foldr1 unamb [1..] in ghci returns 1 but then continues to use 100% of one core for the rest of the ghci session
17:24:31 <boj> wz1000: you are trying to left fold over an infite list. it will never end
17:24:50 <wz1000> boj: its a right fold
17:24:50 <conal> wz1000: bummer. it's a tricky beast to implement correctly. it has surfaced at least three different bugs in GHC's run-time system that required more GHC RTS expertise than I have.
17:25:21 <boj> wz1000: huh, sorry. apparently i need to change my font size
17:25:56 <conal> wz1000: could be that threads are getting spawned faster than they can be killed.
17:26:15 <wz1000> yeah
17:26:35 <erisco> zachk, probably many libraries will design queries such they they will not compile if invalid, modulo what you consider "invalid"
17:26:45 <conal> i'd love to see lub (with or without unamb) have a solid implementation. i think it's as powerful a modularity tool as non-strictness ("laziness").
17:26:48 <wz1000> I have a case where the function returned but memory usage continued to grow until I killed ghc
17:27:16 <erisco> for example, they cannot guarantee the query is valid wrt the schema a particular database is using
17:28:40 <conal> may be a chicken-or-egg situation, though. without a solid implementation, people won't use it; and without demonstrated uses, GHC hackers may not want to implement it solidly.
17:34:02 <ab9rf> so what you need is a red jungle fowl
17:34:03 <lyxia> dbousamra: there isn't a general function for that
17:34:23 <lyxia> dbousamra: what do you want it to do exactly
17:38:14 <lyxia> wz1000, conal: I'm pretty sure that's the bug my PR fixes https://github.com/conal/unamb/pull/1
17:39:15 <lyxia> https://stackoverflow.com/questions/43091885/least-upper-bound-of-an-infinite-chain-of-values-in-a-flat-domain/43103210#43103210
17:42:36 <conal> lyxia: sorry i forgot about the PR. have you tried the infinite right fold example with your change? i'm tweaking my icfp submission (due tomorrow night), so i won't get to it right away.
17:43:03 <zachk> erisco , I am using hasbolt to connect to neo4j , and the queries are just Data.Text so they are not typesafe, works great other then that and the exceptions being thrown
17:43:59 <wz1000> lyxia, conal: here is my test case: http://lpaste.net/363656
17:44:52 <wz1000> running apart_B (const 0) (const 1) in ghci returns () but continues gobbling up memory
17:45:09 <wz1000> until you kill ghci
17:50:05 <Broli> Hello!!!
17:50:43 <Broli> please can someone explain me the following error https://pastebin.com/XPyxApvr . thanks :)
17:51:29 <koz_> Broli: To define a Monad instance, you have to define a Functor and Applicative instance too nowadays.
17:52:49 <Broli> koz_: i don't understand, can you explain more please? :)
17:53:09 <koz_> Broli: You define a Monad instance for Writer, but there's no Functor or Applicative instance for it.
17:53:25 <koz_> So you need to define those too.
17:54:00 <Broli> koz_: okay thanks
18:01:38 <lyxia> conal: yeah, I just checked it stops properly now.
18:02:15 <EvanR> i played around with the implementation of Nat in that 1989 paper ... and realized it resulted in the number 2^128 - 1 being many zillion times too big to fit in memory
18:02:51 <EvanR> while "infinity" takes up less space than 1 xD
18:07:24 <conal> lyxia: merged and released to hackage. thanks! if you're interested, i could use some help with testing and fixing unamb, which hasn't gotten any of my attention for a good while.
18:07:39 <conal> lyxia: (after tomorrow's icfp deadline)
18:08:46 <conal> lyxia: btw, i hastily committed & released even though GHC 8.0.2 gave me two warnings. usually i like to eliminate all warnings.
18:09:16 <lyxia> sure!
18:09:56 <conal> :)
18:20:40 <zachk> erisco , looks like I am gonna use try from Control.Exception , eitherToMaybe from Data.Either.Extra and a hand rolled function to print out exceptions if they exist in the returned either, then turning the either into a maybe, not much of a problem cause most of data is already wrapped in Maybe
18:21:56 <ski> EvanR : "The Arithmetic of Recursively Run-length Compressed Natural Numbers" (slides) by Paul Tarau in 2014 at <https://www.cse.unt.edu/~tarau/research/slides/slides_ictac14.pdf>
18:22:35 * ski . o O ( "A Functional Hitchhiker's Guide to Hereditarily Finite Sets, Ackermann Encodings and Pairing Functions" (draft) by Paul Tarau in 2008 at <https://www.cse.unt.edu/~tarau/research/2008/tarau_hfs.pdf> )
18:25:44 <EvanR> yeah i went from ... this is just unary + 1, to this is one machine word plus unary, to runciman's idea, sum of a collection of machine words, to place-value notation each machine word is weighted by 2^(64*(2^i)), to...
18:26:27 <EvanR> n0 + 2^(n1) +... something... which then doesnt have the ability to represent certain numbers in the gaps, like floating point
18:26:33 * EvanR looks at these slides
18:27:15 <EvanR> some numbers have more complexity than others it seems (counterintuitively)
18:35:14 <YellowOnion> Is there functional difference between .. where .. and let .. in ..? I've noticed the later being used in certian high performance libraries.
18:36:26 <eacameron> When working with GADTs is common to use CPS and RankNTypes to actually do anything useful with them?
18:36:43 <f-a> YellowOnion: I think where scopes over many guards
18:36:46 <f-a> let doesn't
18:37:09 <f-a> I am not sure how much this would impact performance
18:38:37 <YellowOnion> f-a, it was being used in projects using accelerate, and massiv
18:39:51 <ski> eacameron : hm .. i don't see why that would need to be the case
18:40:23 <ski> eacameron : i can see how using existentials (e.g. in GADT form) could lead one to rank-2 CPS, though
18:40:38 <f-a> can I ask a good soul to compile a small executable for me? i am on 32bit and cross compiling to 64 seems way more than I can chew
18:41:39 <eacameron> ski: well I'm not too familiar with them in practical use but let's say I've constructed `SomeGADT a` with a few different constructors that pick different values for `a`
18:41:53 <eacameron> If I want to pass that GADT around and use it, the thing that consumes it has to work for all `a`
18:42:53 <EvanR> heh, tsize :: T -> T, measuring how big a number is... in terms of itself
18:43:30 <EvanR> is tsize increasing? decreasing? neither?
18:43:43 <eacameron> ski: Actually I think my confusion is that I know how to *consume* a GADT `SomeGADT a` but I don't how to produce one because the `a` is not the same
18:43:55 <ski> eacameron : it doesn't have to work for all `a' .. though that would be pretty common
18:44:15 <eacameron> Writing `SomeGADT a -> String` is easy...case match. But how to go the other way? `String -> SomeGADT a`
18:45:17 <ski> ah
18:45:24 <ski> there you'd want an existential
18:45:34 <eacameron> I think this is why I am getting pulled toward CPS because I instead end up doing `String -> (forall a. SomeGADT a -> b)`
18:46:06 <ski> `forall a. (SomeGADT a -> String)', which is the same as `(exists a. SomeGADT a) -> String', vs. `String -> (exists a. SomeGADT a)'
18:46:32 <ski> btw, can we rename `SomeGADT' to `GADT' ?
18:46:52 <eacameron> lol yes. But `exists` is not a real keyword
18:47:00 <ski> doesn't matter
18:47:47 <eacameron> Ah I see what you're saying a bit
18:48:00 * ski would like to introduce `data SomeGADT = forall a. WrapGADT (GADT a)' (aka `data SomeGADT where WrapGADT :: GADT a -> SomeGADT' (with an implicit `forall a.' on the signature of `WrapGADT', if you're wondering))
18:48:09 <ski> `SomeGADT' encodes `exists a. GADT a'
18:48:13 <jle`> so your original question really wasn't 'when working with gadts...', you meant to ask 'when working with existentials', right?
18:48:38 <jle`> in that case, there are two ways to encode existentials haskell; the datatype wrapper, or the cps/rankn form
18:48:42 <ski> so, we can encode `String -> (exists a. GADT a)' as `String -> SomeGADT' -- this is the "existential data type" (more properly "existential data constructor") encoding of `exists'
18:49:06 <jle`> the dependent-sum library (and type-combinators) have useful general-purpose data types/combinators like this
18:49:22 <eacameron> jle`: Well I happen to be working with GADTs so I'm likely inexperienced enough to conflate issues
18:49:29 <ski> the other encoding would encode `String -> (exists a. GADT a)' as the rank-2 `String -> (forall a. GADT a -> o) -> o'
18:50:01 <f-a> YellowOnion: probably looking at Core output will give an answer
18:50:41 <ski> (i suspect that this encoding is what you were aiming for with `String -> (forall a. SomeGADT a -> b)' above, though it wasn't quite right)
18:51:35 <YellowOnion> f-a, oh yes, Sadly I couldn't get ghc-core working properly on windows, and the default output is ugly.
18:53:28 <eacameron> ski: Yes I meant `String -> (forall a. GADT a -> o) -> o`
18:54:39 <eacameron> jle`: dependent-sum. I've looked at it a bit. I should look more closely then.
18:55:06 <eacameron> jle`: ski: I'm not crazy about defining existential wrappers every time I want to work with this pattern
18:58:08 <jle`> yeah, dependent-sum gives nice generic anonymous combinators
18:58:21 <jle`> i use the one from type-combinators a lot too, which are just as powerful, but it's a bigger library
18:59:32 <ski> hmm .. there should be something like `class Read1 f where readsPrec1 :: Int -> ReadS1 f' where `type ReadS f = String -> [(Exists f,String)]', perhaps, hmm
18:59:57 <ski> perhaps it would be nice if one could recover some constraints as well
19:00:23 <ski> (in some cases. for `f' a GADT, it probably wouldn't be that useful)
19:01:05 <ski> eacameron : by "existential wrappers", you mean the encoding in terms of `data' ?
19:15:02 <eacameron> ski: I guess I mean using `Exists f` wrapper
19:16:59 <eacameron> jle`: Is there a tutorial or blog about dependent-sum anywhere?
19:17:04 <eacameron> that you can recommend?
19:54:21 <jle`> eacameron: you might find some help in a tutorial for dependent-map
19:54:36 <jle`> since it uses dependent-sum heavily
19:54:49 <jle`> but honestly dependent-sum is a pretty small library
19:56:21 <eacameron> jle`: Yeah I keep struggling to *grok* it in a practical example
19:56:53 <jle`> the main type is just DSum
19:57:51 <jle`> data DSum p f = forall a. p a :=> f a
19:58:12 <jle`> if you just want a plain ol existential type, you can use Proxy for p
19:58:19 <jle`> type Sum = DSum Proxy
19:58:25 <jle`> er, type Some = DSum Proxy
19:58:52 <jle`> `DSum Proxy f` is essentially (exists a. f a)
19:59:16 <jle`> but also Some is in Data.Some so i guess it's kind of duplicated
19:59:40 <jle`> data Some f = forall a. This (f a)
19:59:59 <eacameron> jle`: Yeah I did see that. and withSome looks exactly like the CPS/rankn thing I was talking about
20:00:12 <jle`> withSome is basically the conversion function
20:00:21 <jle`> between the data type encoding and the cps encoding
20:00:51 <eacameron> I see.
20:02:03 <jle`> if you have the `(forall a. f a -> r) -> r` form and the `Some f` form, then witSome is the conversion
20:02:11 <jle`> Some f ->  ((forall a. f a -> r) -> r)
20:03:17 <jle`> you could write it backwards too
20:03:28 <jle`> * Some f ->  (forall r. (forall a. f a -> r) -> r)
20:03:37 <eacameron> This `tag` parameter. Must it be a GADT specifically for tagging each type? My GADT has more interesting constructors that the tag in dependent-sum's example `AString`/`AnInt`
20:03:40 <jle`> and the bcakwards is (forall r. (forall a. f a -> r) -> r) -> Some f
20:04:02 <jle`> well, the library is pretty general, so it can be whatever you want
20:04:25 <jle`> it's just basically there to prevent code duplication, so you don't have to write your own existential wrappers all the time
20:05:00 <eacameron> so as a motivating example, how would I use this to do `String -> GADT a`?
20:05:11 <jle`> do you mean String -> (exists a. GADT a) ?
20:05:16 <jle`> you'd just write String -> Some GADT
20:05:41 <eacameron> Yeah that's what I mean. Ah this is pretty sweet.
20:06:08 <jle`> yeah, it's nothing you couldn't just write yourself with a manual wrapping type
20:06:24 <jle`> it's just a polymorphic version
20:06:29 <eacameron> I see.
20:06:53 <jle`> you could write data SomeGADT = forall a. SG (GADT a)
20:07:01 <jle`> but now you just have type SomeGADT = Some GADT
20:08:04 <jle`> DSum is pretty general actually but there's an 'intended' way to use it
20:09:10 <eacameron> gread uses CPS heh. Could it not return `Some` instead?
20:09:10 <jle`> neat trick with DSum though, it integrates well with the 'constraint' library
20:09:21 <jle`> eacameron: the two are isomorphic
20:09:28 <jle`> so you can just convert back and forth pretty easily
20:09:41 <eacameron> Is one generally preferred in any way?
20:09:49 <jle`> both have pro's and con's
20:10:13 <jle`> "in general" it's easier to 'ask' for Some, and 'give' CPS
20:12:14 <eacameron> jle`: The give part makes sense. But the ask part: is `GADT a -> IO ()` different than `Some GADT -> IO ()`?
20:13:19 <EvanR> ski: is the paper for that slideshow behind a paywall only
20:19:07 <jle`> eacameron: i want to say yes, but just trying to think of a convincing example
20:21:00 <jle`> eacameron: actually another big difference between the cps and the Some version is that the Some version can be put in other constructors
20:21:30 <jle`> so you can have [Some GADT], but you can't have [(forall a. GADT a -> r) -> r]
20:21:57 <eacameron> Is that because we don't have impredicative types?
20:22:05 <jle`> yes
20:22:16 <jle`> and also, the Some version can be instances of typeclasses
20:23:00 <jle`> but to be fair, that's mostly because it's a data type in general
20:23:07 <jle`> you can write a typeclass instance that wraps the CPS version too
20:24:49 <eacameron> jle`:  This is very helpful!
20:24:50 <EvanR> ski: actually found it second link on google https://pdfs.semanticscholar.org/dff2/80422571a66ff461fbf1697947c9a253bb92.pdf
20:25:14 <jle`> eacameron: i actually have a section in a blog post from last year about cps vs. wrapper
20:25:24 <EvanR> (why do papers never include the current year on their cover page)
20:25:28 <EvanR> or first page
20:25:35 <eacameron> jle`: Oh I'd be interested to read it
20:25:47 <jle`> eacameron: https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html#a-tale-of-two-styles
20:29:52 <eacameron> jle`: Excellent! Thank you.
20:31:02 <jle`> no problem!  i'll continue to ponder about your question earlier
21:20:58 <eacameron> I'd like to take to Traversals and build a single traversal that uses both of them
21:21:20 <eacameron> E.g. Traversal a -> Traversal b -> Traversal (a, b)
21:21:47 <eacameron> Or rather: Traversal a x -> Traversal a y -> Traversal a (x, y)
21:26:40 <jle`> does liftA2 (,) and varieties work?
21:26:54 <ab9rf> i'm not really sure what that would do
21:27:34 <jle`> hm yeah, it doesn't sound like a sensible operation, since the two traversals might have different numbers of targets
21:28:45 <c_wraith> Just tell me how it would work if my two traversals are (filtered even) and (filtered odd)
21:30:43 <ab9rf> that was the problem i was running into
21:31:00 <ab9rf> i also couldn't make any sense of the types
21:33:07 <ab9rf> or (replicated 3) and (replicated 5)
21:33:10 <nshepperd> that would result in an unlawful traversal at least, same as product of lenses
21:34:50 <ab9rf> i supose you could zip the two traversals together; as i recall zip drops the longer of the two
21:34:52 <eacameron> Well I think I morally have a lens since there will only ever be one target, but as it happens, the types are Traversals. Perhaps I need to figure out a way to get lenses out of this instead
21:35:20 <nshepperd> for instance, what is the value of 'set (_Just × _Just) (3, 4) (Just 0)'
21:35:26 <ab9rf> i suppose that might even be useful under some weird situation
21:35:31 <ab9rf> probabyl ust a liftA2 zip
21:35:46 <nshepperd> assuming (×) is your combining function
21:35:56 <eacameron> What I want to do is allow both setting/getting from the same type
21:36:08 <eacameron> Tuple is an example, but in my case I have username/password
21:36:18 <eacameron> I want to use a single type to set/get those in this XML document
21:37:24 <eacameron> jle` c_wraith nshepperd ab9rf ^
21:38:11 <jle`> yeah, this is definitely a situation where looking for a general solution is much more complicated than just finding a solution to your specific situation
21:38:11 <ab9rf> so you want a single value that provides setter/getter for two different fields in an xml document?
21:38:13 <nshepperd> ab9rf: yeah, it would have to be a Traversal' that acts sort of like zip in that it acts only on the first part of the longer traversal
21:38:18 <eacameron> The fact that it's XML is why it's a traversal. There's no way to be *certain* there is only one target
21:38:33 <ab9rf> nshepperd: that's the only way i can come up with a coherent type
21:38:55 <eacameron> Unless you could somehow do "first" or something
21:39:04 <eacameron> But even then it'd be a prism
21:39:05 <jle`> eacameron: can you write your traversal by hand, without using the two input traversals?
21:39:13 <jle`> if you can't, there's a good chance that it might not make sense
21:39:34 <eacameron> jle`: No I can't (not easily). I'm traversing a deeply nested xml document type
21:39:35 <jle`> if you can, then we will know exactly what it is you are talking about
21:39:39 <ab9rf> there's a firstOf traversal
21:39:51 <ab9rf> well firstOf fold, but same diff
21:40:33 <jle`> if it's a traversal, how do you expect toListOf to behave?
21:40:57 <jle`> what would a list of all the 'targets' look like?
21:41:12 <eacameron> Good question...
21:41:23 <eacameron> Yeah I suppose the "pairing" would be ambiguous
21:41:48 <ab9rf> what if there are two username and two password fields?
21:42:09 <eacameron> Right...which there won't be..but it's XML so I can't prove it :P
21:42:32 <jle`> i mean, if there are, how would you handle it?
21:42:59 <jle`> sounds like you might just be better parsing your xml into a specific data type
21:43:03 <jle`> instead of working directly with it
21:43:16 <eacameron> I'm beginning to think the same.
21:43:21 <ab9rf> or find a containing element that is guaranteed to contain only one username and password field
21:43:30 <ab9rf> and then parse that entire xml element
21:43:51 <eacameron> ab9rf: How would you "guarantee" this?
21:44:09 <ab9rf> eacameron: if the schema specifies "exactly 1" or "at most 1"
21:44:16 <ab9rf> do you ahve a schema?
21:44:32 <eacameron> ab9rf: Well I mean how would I prove it *to GHC* :P
21:44:41 <ab9rf> ghc doesn't care :)
21:45:05 <eacameron> Sounds like I'd have to write a law breaking traversal and just *know* in my heart that it's ok or something.
21:45:34 <ab9rf> if you really care abot ths case i would count the user name and password fields, fail if either is present a number of times other than 1, and only return success if yuou have exactly one of each
21:45:51 <eacameron> ab9rf: Right that's exactly what I'll do.
21:45:53 <eacameron> But
21:46:13 <eacameron> What I'm hearing is that I can't do that with traversal
21:46:50 <ab9rf> i'm not sure what traversals are available for xml values, but i should think it would be possible
21:48:15 <ab9rf> if you can form a traversal for username fields and a traversal for password fields, then applying lengthOf will let you determine how many there are of each
21:49:17 <ab9rf> although you might just want to pattern match on listOf since that avoids traversing past the second element
21:49:20 <eacameron> ab9rf: Right I do have that part already. What I was hoping to do was build a traversal that worked with both username and password simultaneously.
21:49:28 <ab9rf> eacameron: why? what does that gain you?
21:50:06 <eacameron> ab9rf: Oh just that the API can ensure you set both values, for example, and not forget one.
21:50:56 <eacameron> Of course I can write `setCreds :: Creds -> Xml.Document` but now I need to write `getCreds :: Xml.Document -> Creds`
21:51:03 <eacameron> Which looks a lot like a lens:P
21:51:18 <ab9rf> yeah
21:51:29 <ab9rf> i think that's where you are
21:51:44 <eacameron> LOL
21:51:54 <eacameron> Well at least I'm not crazy.
21:52:09 <eacameron> I couldn't figure out anything that resembled what I wanted. Turns out there's a reason.
21:54:33 <ab9rf> i think it might be possible to do what yuou want as a traversal, but it would be complicated.
21:54:43 <ab9rf> and probably not worth it
21:55:04 <eacameron> ab9rf: Ok yeah if it's complex then definitely not worth it
21:55:31 <ab9rf> i suspect a straight-up lens will be easier to write and easier to understand
21:57:41 <eacameron> ab9rf: I'm not sure how to use lens here
22:04:31 <ab9rf> neither am i :)
22:15:14 <halogenandtoast> I always forget, there probably isn't but is there an easy way to see what is generated by quasiquotes/templatehaskell ?
22:16:26 <halogenandtoast> I might actually be understanding templatehaskell incorrectly and this might not be possible.
22:16:52 <MarcelineVQ> there's probably a -ddump-splices
22:17:00 <woodson> $(deriveGeneric ''SObjectId
22:17:09 <woodson> ^ isnt' this the format to derive Generic using template haskell?
22:17:45 <jle`> usually you just let ghc derive generic for you
22:17:48 <halogenandtoast> MarcelineVQ: iirc I believe those are unreadable by humans like me, but I'll try
22:18:15 <woodson> I am getting variable not in scope
22:18:23 <jle`> what is your code?
22:18:31 <jle`> are you deriving it using ghc?
22:18:57 <halogenandtoast> MarcelineVQ: You are correct though, I think that is as close as I'm going to get.
22:19:36 <MarcelineVQ> halogenandtoast: I don't recall but if it's core you can also specify -dsuppress-all to get a little more readable
22:19:49 <woodson> jle`: wait I thought that it would add the derive Generic for me using GHC
22:20:00 <woodson> http://lpaste.net/363674
22:20:09 <jle`> @let data MyData = MD Int Bool deriving (Show, Read, Eq, Ord, Generic)
22:20:12 <lambdabot>  Defined.
22:20:30 <jle`> ^ that's how you derive generic
22:21:31 <woodson> Ya, I knew that I just thought that you could use the template haskell annotation but I get that there is something that I'm misunderstanding
22:21:37 <woodson> about that extension
22:21:40 <halogenandtoast> MarcelineVQ: Thanks again, it is enough to give me what I was looking for
22:21:44 <jle`> woodson: what extension?
22:21:54 <Axman6> template haskell isn;t annotations, it's functions that run at compile time
22:21:55 <jle`> woodson: and why do you think that that template haskell thing would work?
22:22:06 <jle`> woodson: do you think $(deriveShow ''Foo) would derive Show for Foo ?
22:22:16 <woodson> TemplateHaskell
22:22:35 <Axman6> the deriveLenses/deriveJSON stuff you've probably seen are functions from those packages
22:22:36 <woodson> no I would think that, but I know that aeson has a format similar
22:22:47 <woodson> and I remember reading or watching a video tutorial
22:22:49 <jle`> woodson: what format do you mean?
22:22:51 <jle`> or video?
22:23:04 <woodson> and seeing someone use the $(genericDeriv <SomeType>)
22:23:29 <jle`> stuff in $(...) is just normal haskell functions, defined by users
22:23:31 <jle`> it's not ghc syntax
22:23:32 <Axman6> IIRC can't Generic only be instantiated by GHC?
22:23:50 <jle`> woodson: so if you see $(foo bar baz), it's foo, bar, baz, etc. that a user defined
22:23:51 <jle`> not ghc syntax
22:24:20 <jle`> so deriveXYZ stuff you might see is someone defining a function deriveXYZ, and exporting it from their model
22:24:23 <jle`> *module
22:26:27 <woodson> jle`: ok got it
22:26:36 <jle`> so if you see 'genericDeriv' somewhere, it's because they imported a module that exported a function genericDeriv
22:26:49 <jle`> not because it's GHC/haskell syntax
22:29:37 <woodson> the video was demonstrating how to use generic-sop
22:29:51 <woodson> so I guess there is a module for it somewhere
22:30:33 <EvanR> ski: dang... this recursively run length encoded thing i blowing my mind, after playing with it in ghci, and writing a parser
22:30:49 <woodson> jle`: found it https://github.com/well-typed/generics-sop/blob/master/src/Generics/SOP/TH.hs
22:30:51 <EvanR> who needs machine words anymore lol
22:31:20 <woodson> jle, thanks for explaining. I also noticed this module import Language.Haskell.TH
22:31:39 <jle`> no problem :)
22:31:42 <woodson> I guess thats how they define their own template haskell syntax?
22:31:50 <jle`> it's not quite syntax
22:31:53 <jle`> it's just normal functions
22:32:04 <jle`> notice that it's just normal user defined functions using normal haskell syntax
22:32:14 <woodson> its just a functions
22:32:18 <woodson> ya, just noticed
22:32:20 <woodson> lol
22:32:39 <jle`> yeah, not quite magic :)
22:32:45 <jle`> it's basically a function that outputs haskell code
22:33:06 <jle`> and when ghc tries to compile your file, it'll run the function and stick in the code that it returns
22:33:53 <woodson> jle`: hmmm, I see. Sounds like you can abuse this..lol
22:34:02 <MacSlow> Greetings everyone!
22:34:28 <jle`> woodson: indeed, that's why people usually look at template haskell with a mix of caution and disgust, heh
22:34:42 <jle`> it has its purpose, but usually it's a last resort
22:35:08 <jle`> MacSlow: greetings!
22:35:19 <woodson> haha, got it.
22:35:27 <woodson> MacSlow, Hi
22:37:52 <jle`> woodson: we used to use TH for deriving instances, but nowadays, GHC.Generics can be used to derive instances for most classes and data types without needing TH
22:39:06 <jle`> but TH is still need to derive typeclasses
22:39:17 <jle`> and also to dynamically generate identifiers
22:39:21 <MacSlow> just wondering... being at home on the Linux-platform, I tried to also compile some of my haskell example under Windows... but only managed to get static binaries, thus a 20 kBytes Linux-binary became a 25 MBytes behemoth under Windows.
22:40:24 <MacSlow> all attempts to compile a dynamically linked version on Windows failed with ghc telling me "-dyn" versions of prelude/base are missing.
22:41:24 <MacSlow> How does one get a shared library variant of ghc for windows (without compiling it myself)
22:42:03 <jackdk> I don't know the details of dynamic linking under win's, but is that 25MB before or after stripping?
22:42:38 <MacSlow> ehm... I think I forgot to stip it
22:43:13 <MacSlow> but then... non-stripped binaries under linux are about 50 KBytes... certainly not in the MBytes
22:45:55 <jackdk> even static unstripped binaries?
22:46:06 <cocreature> MacSlow: https://ghc.haskell.org/trac/ghc/wiki/WindowsDynamicLinking suggests that dynamic linking is not supported on windows but I’m not sure how up2date that is. maybe try asking Phyx- in the #ghc channel. he does most of the windows work these days and has been trying to improve the situation.
22:48:08 <MacSlow> jackdk: on Linux binaries are orders of magnitude small indeed
22:48:31 <MacSlow> jackdk: I'll try stipping the binaries on Windows once I'm back at a Windows box.
22:48:39 <MacSlow> cocreature: ah... ok thanks
22:48:56 <nshepperd> why would you want dynamic linking in haskell?
22:49:10 <nshepperd> it just means your 25 MB are split among different files
22:51:14 <MacSlow> nshepperd: well static linking is (for personal use) wasting resources
22:52:15 <cocreature> nshepperd: because you’re the arch maintainer and you want everyone to hate you
22:53:11 <MacSlow> nshepperd: it's a different story when on plans to ship binaries to non-developer people of course
22:53:13 <nshepperd> MacSlow: only if you have multiple binaries compiled against the exact same build of libraries that they depend on
22:53:17 <Cale> Haskell programs are a little too rare for dynamic linking to really make sense.
22:53:55 <Cale> Maybe at some point it'll make more sense, if people are running mostly Haskell software
22:54:02 <Cale> and we need the memory sharing
22:54:31 <EvanR> non-developer people either dont appreciate dynamic linking, or are misunderstanding it (pile of dlls)
22:54:49 <MacSlow> Cale: for shipping/distribution for sure... I'm just a beginner and will certainly not spread my "entanglements" with the world :)
22:55:20 <nshepperd> actually, I guess I wouldn't mind the distribution packages with haskell binaries being dynamically linked, if it didn't interfere with the global ghc
22:56:06 <Cale> I only use ghc out of nix shells now anyway.
22:56:38 <Cale> Even though I'm not running nixos :)
22:57:02 <nshepperd> but, meh. the complexity is definite not worth the 0.1% performance increase from git-annex starting up faster when i'm simultaneously using alex/happy
22:57:57 <guessWho> how do i write type signature for a function which accepts a STM Chan a 3-Tuple and forks a new thread read from STM Chan atomically , mess around with msg read from chan and returns a bool ????
23:00:05 <nshepperd> MacSlow: i would only ever use static linking for personal projects
23:00:39 <nshepperd> having the output be just one binary executable seems way easier than wrangling dlls imo
23:01:26 <nshepperd> and i get no benefit from shared linking because i'm always building in a sandbox so there is 0 sharing
23:01:31 <cocreature> guessWho: you’re forking a thread and you want to return a Bool, so your return type will be "IO Bool". now just add the arguments in front of that
23:02:35 <cocreature> and even if you use stack or new-build, you are very likely to pick slightly different versions of your dependencies and thereby prevent all sharing
23:05:06 <guessWho> cocreature : i thought return type should also contain ThreadId because of this "forkIO :: IO () -> IO ThreadId"
23:05:43 <cocreature> guessWho: you can always ignore the ThreadId if you don’t need it. it’s a little hard to parse what you actually want to do. can you show us the code?
23:06:44 <guessWho> cocreature : http://lpaste.net/1751293672520941568
23:07:21 <cocreature> guessWho: it seems like you already have a type signature? does the current type signature not typecheck?
23:07:45 <guessWho> cocreature : it's throwing error
23:08:22 <cocreature> guessWho: then show us the error :) one problem is that forkIO expects something of type "IO ()" while you’re passing it an IO Bool
23:08:54 <guessWho> cocreature : http://lpaste.net/363676
23:09:17 <cocreature> guessWho: what exactly do you hope to achieve by returning a Bool from the newly created Thread? i.e. where should the Bool be returned to? the original thread will continue immediately and not wait for the new thread to terminate so you can’t just return it directly
23:10:18 <guessWho> cocreature : got it i messed up
23:11:15 <cocreature> guessWho: you might be interested in the "async" library. this allows you to return a value from a thread and then at some later point wait for it to terminate and read the return value using "wait". https://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html
23:13:09 <guessWho> cocreature : now i have removed forkIO from there because anyway this function will be called from within another thread . But can you tell me the way i have written code inside the function is a right approach or there is some better of writing the same thign >?
23:15:34 <cocreature> guessWho: 1. instead of using fromMaybe in the "otherwise" case, just pattern match on the "Just" and use the value directly. you already know that it can’t be nothing here. 2. it looks like you don’t actually need to pattern match on seqList. you can just use "let peerSeqList = fromMaybe [] seqList" even in the Nothing case since "elem" will always fail in that case so you return False anyway
23:15:49 <cocreature> apart from that it looks pretty good!
23:19:20 <guessWho> cocreature : cool thanks for going through the code , i really appreciate it :)
23:37:34 <guest_> I am trying to use `SharedSecret` generated by https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-ECIES.html library in https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-Cipher-AES.html for `AES256`, how can i convert `SharedSecret` type to `Key` type, I was referring to the last example at https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-Tutorial.html page for AES256
23:40:24 <cocreature> guest_: I don’t see a type called "Key" in the pages you linked
23:41:06 <guest_>  cocreature: https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-Tutorial.html in this example they are using
23:41:10 <guest_> at last example
23:41:55 <cocreature> guest_: they’re defining their own type called Key there. that’s not part of cryptonite’s API
23:42:18 <guessWho> cocreatutre : -- | i want to map Map.lookup over a list of keys but the problem is it's first parameter is key and second is map so how can i do this ? is there another function which will allow me to do this
23:44:01 <cocreature> guessWho: anyway, you can use "convert" to get from "SharedSecret" to "Bytes",  use "cipherInit" to go from "Bytes" to "CryptoFailable AES256". then you can pattern match on that and extract a "AES256" on success. if you really want to you can then use the "Key" constructor to get a "Key" from that
23:44:46 <cocreature> ah no, apply Key first, the API calles cipherInit internally
23:44:52 <guessWho> cocreature : ehh That was not my question
23:45:01 <cocreature> ^ guest_
23:45:18 <cocreature> guessWho: forcing me to type 5 characters to disambigute names is just too hard :)
23:45:40 <cocreature> guessWho: I don’t understand your question. can you provide an example?
23:47:07 <jle`> the Category instance of (:~:) looks a lot like the definition of equivalence classes, except that it doesn't include reflexivity
23:47:29 <jle`> *definition of equivalence relationships
23:47:50 <jle`> is there a notion of equivalence relationships that don't include reflexivity? and is it related to categories?
23:48:38 <sl2c> are you sure there's no reflexivity
23:48:49 <sl2c> ?hoogle :~:
23:48:49 <lambdabot> Data.Vinyl.Lens type (:~:) rs ss = rs ? ss
23:48:50 <lambdabot> Data.Vinyl.Notation type (:~:) rs ss = rs ? ss
23:48:50 <lambdabot> Darcs.Patch.Named.Wrapped data (:~:) (a :: * -> * -> *) b
23:49:03 <jle`> there is reflexivity for (:~:), but it's not a part of its Category instance
23:49:17 <jle`> instance Category (:~:) where id = Refl; Refl . Refl = Refl
23:49:39 <jle`> which is just forall a. a :~: a, and forall a b c. (b :~: c) -> (a :~: b) -> (a :~: c)
23:49:56 <guessWho> cocreature : here take a look http://lpaste.net/363677
23:50:06 <sl2c> looks like id is refl?
23:50:13 <jle`> oh sorry
23:50:28 <jle`> yes that's why it's called Refl, heh
23:50:33 <jle`> i mean symmetric :)
23:50:38 <sl2c> anyways yeah the existence of an identity morphism in a category is linked to reflexivity in an equivalence relation
23:51:02 <jle`> is there a notion of equivalence-without-symmetricity, and is that linked to categories?
23:51:13 <sl2c> partially ordered sets
23:51:19 <cocreature> guessWho: so your problem is that the parameters of Map.lookup are in the wrong order for partial application? you can use "flip" to swap the first two parameters of a function or just use an explicit lambda, like "\key -> Map.lookup key c"
23:51:54 <sl2c> basically if you have reflexivity and transitivity, you can derive an equivalence relation by a~b if aSb and bSa
23:52:04 <sl2c> and then the set of equivalence classes forms a partial order
23:52:56 <jle`> oh hey neat
23:53:35 <sl2c> so usually you don't see those studied without either symmetry (equivalence relation) or antisymmetry (partially ordered sets; very closely related to categories)
23:53:39 <guest_> cocreature: bytes = Data.ByteArray.convert ssk ; ci = cipherInit bytes;            gives error http://lpaste.net/363678
23:53:41 <sl2c> since you can always split into those two cases
23:53:56 <cocreature> guest_: you need to add a type annotation to bytes
23:54:09 <jle`> but posets require some forall a b c. F a b -> F b a -> F a a
23:55:00 <jle`> i guess that's a 'weaker' thing to add to Category
23:55:32 <sl2c> yeah that's antisymmetry
23:56:04 <jle`> if we just added sym or antsym to Category, what might its laws be?
23:56:25 <sl2c> well, the thing to note about Category is that (a -> b) and the like are usually sets
23:56:31 <guessWho> cocreature : i never thought there could be a flip function , amazing
23:57:02 <sl2c> so symmetry can be extended to various sorts of dualities between (a->b) and (b->a) in some categories
23:57:08 <sl2c> like vector spaces
23:57:30 <cocreature> guessWho: you can also use sections and infix notation to apply it partially to the second argument, e.g., (`Map.lookup` c)
23:57:36 <sl2c> but at this point i don't think we're in particularly Haskellish territory?  unless I'm wrong and someone has done abelian cat stuff in Haskell
23:57:43 <cocreature> guessWho: which is probably the nicest solution here
23:57:49 <jle`> so it's probably only meaningful on a case-by-case basis?
23:58:18 <sl2c> jle`: it's hard to properly generalize
23:58:21 <jle`> no real way to link all of the interesting duality relationships you might see on categories
23:58:32 <jle`> makes sense
23:59:09 <jle`> thanks :)
