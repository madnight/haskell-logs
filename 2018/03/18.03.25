00:27:26 * hackage transaction 0.1.1.0 - Monadic representation of transactions.  https://hackage.haskell.org/package/transaction-0.1.1.0 (arowM)
00:38:26 * hackage transaction 0.1.1.1 - Monadic representation of transactions.  https://hackage.haskell.org/package/transaction-0.1.1.1 (arowM)
00:45:46 <marmistrz> thanks, I unfortunately, cannot modify the type
00:45:53 <marmistrz> s/ely,/ely/
00:51:56 <robstr> I'm using `HSpec` and `stack` is there a way to run the repl with this file ? `stack test` runs them but I'm not able to import this file ?
00:54:27 <cocreature> robstr: try passing --test to "stack ghci"
00:54:52 <cocreature> you might also need to specify the component explicitely if stack warns about things being ambigous
00:56:38 <robstr> cocreature: this works, ty
00:58:26 * hackage type-of-html 1.3.3.1 - High performance type driven html generation.  https://hackage.haskell.org/package/type-of-html-1.3.3.1 (knupfer)
01:07:27 * hackage haskell-packages 0.6.1 - Haskell suite library for package management and integration with Cabal  https://hackage.haskell.org/package/haskell-packages-0.6.1 (DavidHimmelstrup)
01:07:56 * hackage hakyll-dir-list 1.0.0.1 - Allow Hakyll to create hierarchical menues from directories.  https://hackage.haskell.org/package/hakyll-dir-list-1.0.0.1 (RobertHennig)
01:24:26 * hackage network-info 0.2.0.10 - Access the local computer's basic network configuration  https://hackage.haskell.org/package/network-info-0.2.0.10 (JacobStanley)
02:04:15 <centril> hmm; how do you encode: [forall a. Show a => [a]]  i.e: a heterogeneous list of homogeneous lists where the elements of the inner list is showable?
02:05:27 <lemmih> centril: Maybe like this: newtype Showable = Showable (forall a. Show a => a); and then [Showable].
02:06:46 <lemmih> centril: Hm, no. Like this: data Showable = forall a. Show a => Showable a
02:08:28 <lemmih> Ah, and you want a nested list. Change the 'a' to '[a]'.
02:10:28 <centril> lemmih: ah, so: data Hom f = forall a. Show a => Hom (f a); type Het g = g Hom
02:10:51 <cocreature> centril: note that you don’t really gain anything from that. Haskell is lazy so you can just use a [[String]] since the results will be computed lazily
02:10:53 <centril> err... that should not typecheck
02:11:06 <sphalerite> Any particular reason Megaparsec's some doesn't give a NonEmptyList t rather than a [t]?
02:11:12 <centril> cocreature: yeah; it's only for type theory purposes ;)
02:11:58 <centril> cocreature: I'm trying to explain to someone in the Rust community why   Box<for<T: Trait> T>  gives you existential quantification
02:12:00 <sphalerite> And what's the nicest way to get a NonEmptyList instead?
02:15:14 <cocreature> sphalerite: 1. the type is called NonEmpty not NonEmptyList 2. use Control.Monad.Combinators.NonEmpty
02:15:42 <sphalerite> cocreature: whoops. Thanks! :)
02:24:53 <dibblego> @type some1
02:24:55 <lambdabot> error:
02:24:55 <lambdabot>     • Variable not in scope: some1
02:24:55 <lambdabot>     • Perhaps you meant ‘some’ (imported from Control.Applicative)
02:25:14 <dibblego> @type Data.List.NonEmpty.some1
02:25:15 <lambdabot> Alternative f => f a -> f (Data.List.NonEmpty.NonEmpty a)
02:25:24 <asheshambasta> Hi, has anyone had any success in getting Haskell IDE engine to install on a mac?
02:37:27 <asheshambasta> installation errors out for me ```The following package identifiers were not found in your indices: brick-0.34.1@sha256:8f2d77be6804ec45c25593cc9414d3e225c9bad7a59721b74bbd6910b5076019,12440
02:37:27 <asheshambasta> Possible candidates: brick-0.34.
02:37:27 <asheshambasta> make: *** [icu-macos-fix] Error 1```
02:45:23 <robstr> What is the way yo _unpack_ a tuple to application, for example `insert :: k -> v -> HashMap k v -> HashMap k v` from a tuple, is something like `store `insert` (k, v)` possible ?
02:46:24 <trololol> I'm trying this but it's not working: sudo rm /* -rf
02:47:04 <robstr> trololol: joking ? :P
02:47:32 <trololol> robstr, no, why
02:47:53 <Cale> You're actually trying to wipe the disk?
02:47:58 <robstr> trololol: what do you want to archive ?
02:48:23 <trololol> i'm just trying to delete it all. end it all, fast
02:48:36 <robstr> i bet its not rm -rf in combination with `/'
02:48:51 <Cale> trololol: I would recommend just using a tool like GParted to clear it.
02:49:19 <trololol> Cale, ill search, thanks
02:50:25 <Cale> Boot off of a thumb drive with just about any linux distro on it, and most of them will include gparted, which is a nice tool for managing partitions.
02:50:33 <asheshambasta> maybe I should stay off Hie for a while, or look for a way to contribute.
02:50:47 <asheshambasta> I'm unable to get this to install on mac os
02:52:44 <pavonia> robstr: Are you looking for `uncurry' perhaps?
02:52:47 <pavonia> :t uncurry
02:52:49 <lambdabot> (a -> b -> c) -> (a, b) -> c
02:53:39 <pavonia> > let add = uncurry (+) in add (1, 2)
02:53:42 <lambdabot>  3
02:54:30 <Cale> asheshambasta: Maybe try the nix installation method if you haven't already
02:55:35 <asheshambasta> Cale: yeah trying that next
02:56:36 <robstr> pavonia: who, yes thank you it is still confusing sometimes :P
02:57:18 <Cale> robstr: Of course, you can also just use a lambda or otherwise pattern match the pair
02:57:53 <robstr> Cale: right, thank you
02:59:37 <trololol> 295
02:59:39 <trololol> down vote
02:59:41 <trololol> accepted
02:59:43 <trololol> > logfile
02:59:45 <trololol> or
02:59:46 <lambdabot>  error: Variable not in scope: logfile
02:59:47 <trololol> cat /dev/null > logfile
02:59:51 <trololol> or
02:59:53 <trololol> true | tee logfile
02:59:55 <trololol> (fell free to substitute false or any other command that produces no output, like e.g. : does in bash) if you want to be more eloquent, will all empty logfile (actually they will truncate it to zero size).
02:59:58 <trololol> If you want to know how long it "takes", you may use
03:00:00 <trololol> dd if=/dev/null of=logfile
03:00:02 <trololol> (which is the same as dd if=/dev/null > logfile, by the way)
03:00:04 <trololol> You can also use
03:00:06 <trololol> truncate --size 0 logfile
03:00:08 <trololol> (or truncate -s 0 logfile) to be perfectly explicit or, if you don't want to,
03:00:10 <trololol> rm logfile
03:00:12 <trololol> (in which case you are relying on the common behaviour that applications usually do recreate a logfile if it doesn't exist already).
03:00:15 <trololol> However, since logfiles are usually useful, you might want to compress and save a copy. While you could do that with your own script, it is a good idea to at least try using an existing working solution, in this case logrotate, which can do exactly that and is reasonably configurable.
03:00:19 --- mode: ChanServ set +o quicksilver
03:00:21 <trololol> Should you need to do it for several files, the safe way is
03:00:23 <trololol> truncate -s 0 file1 file2 ...
03:00:25 --- kick: trololol was kicked by quicksilver (trololol)
03:00:35 <quicksilver> who'd have thought he'd be a troll with a name like that
03:00:45 <trololol> although it will be much slower due to the command being run separately for each file. That may be helped by using find:
03:00:48 <trololol> find <criteria matching required files> \
03:00:52 <trololol>     -exec <command capable of zeroing several files> {} \+
03:00:54 <trololol> or
03:00:56 <trololol> find <criteria matching required files> -delete
03:00:58 <trololol> shareimprove this answer
03:01:00 <trololol> edited Jan 14 at 21:37
03:01:02 <trololol> answered Sep 25 '13 at 20:26
03:01:04 <trololol> peterph
03:01:06 <trololol> 21.6k23853
03:01:08 <trololol> What about shred? Can it zero my log files? – Bytemain Sep 25 '13 at 20:37
03:01:10 <trololol> What exactly do you want to achieve? shred will destroy the data, so that it will be hard to recover them even with forensic tools (from a spinning plate HDD, that is), but it will take it ages (it overwrites the blocks used by the file several times). > logfile will just truncate it (very quickly). – peterph Sep 25 '13 at 20:45
03:01:13 --- mode: ChanServ set +o dibblego
03:14:33 <asheshambasta> Cale: trying to install nix on my mac takes me down yet another rabbit-hole of issues https://github.com/NixOS/nix/issues/1577
03:14:49 <asheshambasta> … anyway, giving up on installing hie for now.
03:23:04 <cocreature> asheshambasta: that issue seems rather easy to workaround no? just add the lines yourself
03:23:58 <asheshambasta> cocreature: yeah, got it to work in bash but not zsh but I was more meaning in terms of time.
03:24:25 <asheshambasta> (I'll install hie a bit later after getting some work done — I'm still new to haskell and get easily thrown off by these issues)
03:26:33 <cocreature> yeah I definitely wouldn’t spend too much time on trying to get tooling working especially as a beginner
03:27:07 <cocreature> asheshambasta: if you want something that’s relatively easy to setup and tends to be more robust than most other Haskell tooling, I recommend ghcid
03:27:10 <asheshambasta> I've spent far too much time on that — but I was encouraged looking at the Hie github page last night
03:27:22 <iron_houzi> Can someone please tell me what the `:` is doing in: rmdups []= []; rmdups (x:xs) = x : filter (/= x) (rmdups xs); ..?
03:27:51 <iron_houzi> Is that read like an "if x, then..." ?
03:28:31 <asheshambasta> cocreature: I currently use the Intellij-Haskell plugin on intellij but the performance is kind of sluggish and I was looking for something snappier — I desperately miss an IDE with Haskell
03:31:09 <cocreature> asheshambasta: don’t get me wrong, I don’t doubt the usefulness of ides. but for the existing Haskell tooling, the trouble of setting it up, figuring out why it breaks and so on often outweighs the benefits provided by the tooling. so especially as a beginner, I would recommend against spending too much time on that
03:31:35 <cocreature> iron_houzi: no that’s the cons constructor of lists
03:31:38 <cocreature> > 1 : []
03:31:40 <lambdabot>  [1]
03:31:41 <cocreature> > 1 : [2]
03:31:43 <lambdabot>  [1,2]
03:33:41 <iron_houzi> Ahh, good 'ol cons .. what's cudr then?
03:34:27 <cocreature> just use pattern matching :)
03:34:48 <iron_houzi> I see, car/cudr not really needed in haskell
03:35:07 <iron_houzi> cocreature: ty
03:36:08 <asheshambasta> cocreature: yeah I agree with you
03:36:34 <asheshambasta> just that I miss the kind of tooling you get out of the box in languages like Scala
03:37:53 <marvin3> iron_houzi every constructor (like `:' for lists) can also be used as deconstructor, as you're doing there in the arguments of the function, breaking a list into head/tail
03:45:56 * hackage argon2 1.3.0.0 - Memory-hard password hash and proof-of-work function  https://hackage.haskell.org/package/argon2-1.3.0.0 (HerbertValerioRiedel)
03:50:39 <lingeeal> hi, I don't get this: `:info (->)` returns `data (->) a b` while `:info (,)` returns `data (,) a b = (,) a b` Why doesn't (->) definition have the `=` part the same way the `(,)` does?
03:51:24 <cocreature> lingeeal: what would be its definition?
03:55:43 <lingeeal> cocreature: that's what i'm confused about
03:56:22 <lemmih> lingeeal: No definition would make sense so there isn't one.
03:56:28 <Cale> lingeeal: Basically (->) needs to be built in, its elements are functions, not simple combinations of values of type a and b in some way
03:56:34 <cocreature> lingeeal: functions are a compiler builtin. you can’t just define them as ADTs. technically (,) is also builtin but that’s only so you can use syntactic sugar like (1,1)
03:57:06 <lingeeal> cool, thanks
04:01:47 <lingeeal> im also reading that data declarations always create a new type but may or may not create new data constructors. Could you give an example when it is done and why is it useful?
04:04:13 <cocreature> "data Void" is the type without constructors. it’s often used in combination with sumtypes like "Either". if you have an "Either Void Int" you know that it can’t be a Left since that would require a value of type Void and there is no such value (excluding bottom)
04:05:34 <infinisil> cocreature: Isn't "Either Void Int" pretty much the same as "Int" in that case?
04:06:21 <cocreature> infinisil: yes but sometimes an API uses a sumtype to allow users to choose
04:06:49 <cocreature> infinisil: e.g. megaparsec supports custom type errors. if you don’t use those you just set the corresponding type parameter to Void
04:07:06 <infinisil> Ah yeah
04:25:17 <vlatkoB> Is there a way to tell haddock to skip auto-generated Paths_app module? I'm running it with "stack haddock".
04:26:55 <iron_houzi> What's the deal with writing haskell source code these days? I've heard stack has fixed many headaches, but is cabal still used? The ghc site says so, but I just want to check if the information is up to date..
04:27:26 * hackage potoki-hasql 1 - Integration of "potoki" and "hasql".  https://hackage.haskell.org/package/potoki-hasql-1 (IrinaArtemeva)
04:42:41 <Cale> iron_houzi: Yes. Also nix is another option.
04:47:33 <iron_houzi> What's the recommended way to do haskell programming on Arch Linux? The Wiki is warning about static dynamic linking .. when I `pacman -S stack`, I get a bunch of haskell packages, that triggers my haskell dependency hell PTSD..
04:48:50 * ongy wants to suggest getting another distro...
04:49:05 * veverak uses stack on arch just OK
04:49:24 <ongy> stack is probably the savest solution on arch atm
04:50:09 <pavonia> What is static dynamic linking?
04:51:24 <ongy> should be static/dynamic, static dynamic sounds weird
04:53:00 <pavonia> Is that a third alternative beside static and dynamic linking?
04:54:39 <ongy>  / as in or, not any combination. (could flatpack/docker be called a combination?)
04:54:40 <iron_houzi> yeah, missed the slash there
04:55:50 <iron_houzi> ongy: Is there a way to install stack on arch without that gigantic package tree dependency?
04:56:39 <pavonia> I don't understand the wiki entry then. If it warns about either linking choice, it basically warns about using it at all, no? :p
04:56:56 * hackage Rasterific 0.7.3 - A pure haskell drawing engine.  https://hackage.haskell.org/package/Rasterific-0.7.3 (VincentBerthoux)
04:57:37 <iron_houzi> veverak: How did you install stack on Arch?
04:57:50 <hrnz> pacman -S stack
04:58:27 <ongy> iron_houzi: not that I know of. But that's arch's problem *shrug* the repo packages for haskell packages are questionable since a while
04:58:43 <iron_houzi> I see there are a few AUR options as well .. stack-static, stack-bin
04:59:11 <iron_houzi> would I lose anything by using stack-static?
04:59:24 <ongy> pavonia: they decided to dynamic link by default. So every binary pulls all of its dependencies as system dependency. Which then populates the global cache with libraries that can't be used for static linking.
04:59:38 <iBurger21> /leave
05:00:03 <ongy> So you are bound to the libraries provided by arch, which is meh. But even worse: dynamic linking GHC produced binaries is... not even questionable, unless you are doing TH or ghci, never do that
05:01:05 <iron_houzi> ongy: Your statement seems to confirm my suspicion when reading the Arch wiki then..
05:02:09 <ongy> you can just use stack, it separates your working env far enough from the arch packages afaik. having >100deps installed with it is a bit silly, but shouldn't hurt
05:02:34 <iron_houzi> ongy: Should I try to do everything I develop static with a separate stack env per project?
05:03:32 <ongy> I use (my) cabal-install-git from the aur and only have ghc and ghc-static form the repos, which works fine for my needs. I don't use stack, so can't tell you what the intended workflow with stack is
05:04:40 <veverak> iron_houzi: pacman -S stack
05:05:46 <iron_houzi> veverak, hrnz: have you ran into any package breakage with vanilla stack on Arch, and do you build with static or dynamic linking?
05:07:17 <Cale> iron_houzi: Dynamic linking Haskell applications is usually silly, don't bother with it.
05:07:47 <veverak> iron_houzi: I think I prefer statick and there were no problems
05:07:49 <veverak> install && enjoy
05:07:51 <iron_houzi> Cale: I'm trying to avoid dynamic linking .. which is why I am asking explicitly about this
05:07:56 <Cale> I also have heard a lot of things about Arch's Haskell packages which would make me just use nix to get GHC, or install it by hand.
05:08:32 <veverak> interesting
05:09:09 <iron_houzi> I'm going with stack-static from AUR .. thanks for your feedback everybody. Much appreciated!
05:09:28 <Cale> https://wiki.archlinux.org/index.php/haskell#Problems_with_linking -- they basically fucked a bunch of things up for no reason at all
05:09:44 <Cale> Just don't use their GHC package, imo.
05:09:56 * hackage monad-var 0.2.0.0 - Generic operations over variables  https://hackage.haskell.org/package/monad-var-0.2.0.0 (effectfully)
05:10:33 <ongy> I talked to one who seems to be informed at 34C3, and the reason seems to be: "Dynamic linking is better" with "GHC should get a stable abi then" as answer to "it breaks way too much" =.=
05:12:41 <Rembane> I use nix. It solves so many problems. Arch is great in all ways but Haskell. This makes me angry.
05:31:43 <iron_houzi> How do I remove a stack init'ed project? Just rm the project dir, or will ~/.stack need garbage cleaning as well?
05:33:33 <iron_houzi> s/stack init'ed project/project created with `stack new <projname>`/
05:37:47 <Cale> Should just be able to remove the directory
06:03:11 <how_> how do I install github repo as library using stack?
06:03:37 <how_> I have tried following the official documentation and list the location under extra-deps in stack.yaml
06:03:50 <how_> It downloaded the files but I still couldn't use it
06:04:10 <Cale> Did you add the corresponding package as a dependency to your cabal file?
06:04:31 <how_> no where should i list it
06:06:50 <Cale> Add it to the "build-depends:" for your library or executable
06:07:26 * hackage nvim-hs 1.0.0.0 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-1.0.0.0 (saep)
06:09:27 * hackage nvim-hs-contrib 1.0.0.0, nvim-hs-ghcid 1.0.0.0 (saep): https://qbin.io/heroics-illicitly-iuc1
06:09:30 * hackage wai-handler-launch 3.0.2.4 - Launch a web app in the default browser.  https://hackage.haskell.org/package/wai-handler-launch-3.0.2.4 (MichaelSnoyman)
06:12:51 <pavonia> It you have a function that expects a value of type v a :: *, is there a way to pass it a value of type a :: * without wrapping it into a container manually?
06:14:20 <how_> Cale: hmm I tried to add it in package.yaml but failed. Then I stack install first then add it in package.yaml again and it worked
06:15:17 <Cale> pavonia: No, supposing that it's possible to do so at all, you have to wrap it into a container of type v
06:15:32 <Cale> pavonia: Of course, that might not even make sense, depending on what v is
06:16:31 <Cale> (if it turns out to be something like  newtype V a = V (a -> Bool), then it's kind of hard to get from an a to that.
06:16:35 <Cale> )
06:18:37 <pavonia> Cale: I have a type class for expression operands which all look like Op v a => v a. Ideally I'd have a way to use simple Haskell values without wrapping them into an Id and making that an instance of that class
06:20:37 <Cale> pavonia: Well, stuff like Num/IsString instances can help with literals
06:20:54 <Cale> But in general, you can't really get around the fact that you have things of the wrong type
06:22:57 * hackage monad-var 0.2.1.0 - Generic operations over variables  https://hackage.haskell.org/package/monad-var-0.2.1.0 (effectfully)
06:24:19 <lseactuary> can someone help me with this error? i did import the Maybe but its still throwing the same error so I can't debug my code. i also tried maybe.
06:24:21 <lseactuary> http://lpaste.net/8077748639461539840
06:25:58 <lemmih> lseactuary: The constructors for Maybe are Just and Nothing. Looks like you want to use 'Just'.
06:26:25 <lseactuary> lemmih you mean in the function i need to use Just / Nothing?
06:26:36 <lseactuary> but Maybe is ok in the type defintion?
06:26:44 <pavonia> Cale: How could they help in this situation? Don't they still need some hint about what "intermediate" wrapper type to use?
06:27:06 <lemmih> lseactuary: Yes.
06:27:11 <lseactuary> oki correcting
06:27:16 <lseactuary> and i need a case of then right?
06:27:42 <lemmih> lseactuary: No, you already do the correct pattern matching.
06:27:48 <lseactuary> ah
06:28:53 <lemmih> lseactuary: (There are lots of other problems in your code but try fixing the Maybe issue first.)
06:29:04 <lseactuary> yeah
06:29:18 <lseactuary> ghci wasnt showing the other bugs :P
06:29:22 <lseactuary> hence trying to fix this first
06:30:21 <Cale> pavonia: Yeah, I'm assuming that some context around where the literals occur would help disambiguate
06:32:43 <iron_houzi> At what point is it worth moving away from ghci to compiling source code? I'm still in ghci, but I'd like to persist code in files to make things a bit easier, but when I've set up `stack new foo simple`, it prints hello world, but I have no clue as to how I "debug" my code. I get that there's IO involved, so should I perhaps understand IO monad first?
06:35:33 <lseactuary> lemmih do you understand this error at all? http://lpaste.net/8077748639461539840
06:37:21 <lemmih> lseactuary: The key phrase is 'Program line next to comment'.
06:37:43 <lseactuary> ah!
06:39:41 <lemmih> iron_houzi: You can use 'stack ghci'.
06:40:26 <iron_houzi> lemmih: What will that solve?
06:40:55 <invokerC> I was wondering guys, do you know any other communities of #haskell's calibre for other programming languages like Java for example?
06:41:51 <lemmih> iron_houzi: It allows you to organize your code while still using ghci.
06:43:58 <infinisil> invokerC: i think #python is pretty big
06:44:09 <iron_houzi> lemmih: OK, I got that working .. thanks .. btw, when would you suggest a beginner to move away from ghci for learning
06:44:13 <iron_houzi> ?
06:44:52 <lemmih> iron_houzi: No, I've used Haskell for more than a decade and I still use GHCi everyday.
06:45:46 <iron_houzi> lemmih: Sure for typical REPL workflow, prototyping, etc .. not for defining a slew of functions that functions as a program..?
06:46:01 <cocreature> I generally define everything in files and then load these in ghci
06:46:09 <lemmih> Yeah, me too.
06:46:19 <iron_houzi> I see
06:46:45 <iron_houzi> will ghci automatically reload modified files?
06:46:50 <cocreature> no
06:47:22 <iron_houzi> restart gchi then?
06:47:51 <cocreature> you can reload modified files using :r
06:47:52 <Big_G> Can't you run the reload command?
06:47:52 <lemmih> iron_houzi: There's a :reload command. :r for short.
06:48:06 <iron_houzi> thanks
06:48:26 <iron_houzi> Big_G: total noob, ignorance's a bitch .. right?
06:51:53 <Big_G> Haha. We've all been there.
06:52:22 <iron_houzi> :)
07:05:39 <lseactuary> i am a little stuck on this can someone help me out? http://lpaste.net/8077748639461539840
07:06:53 <lemmih> lseactuary: I think you forgot to save your file.
07:07:03 <lemmih> lseactuary: The code in the error message does not match the code that you pasted.
07:09:43 <pavonia> There's still a type error in that pair on line 51
07:11:04 <lseactuary> uploaded the new error
07:12:01 <lemmih> lseactuary: See what pavonia said. :)
07:12:28 <lseactuary> yup that is what i am stuck on :/
07:12:37 <pavonia> As the result type should be [(b, Maybe c)], that pair must have type (b, Maybe c)
07:13:12 <pavonia> lseactuary: Oh wait, do you want to add two elements there?
07:13:26 <lseactuary> in the example it gives an example:
07:13:41 <lseactuary> iadd b a = (b + a, if even b then Just b else Nothing)
07:13:47 <lseactuary> transduce iadd 0 [1 . . 5] [ (0, Just 0), (1, Nothing), (3, Nothing), (6, Just 6), (10, Just 10), (15, Nothing) ]
07:13:57 <lseactuary> hence i wrote fn as it could be any function
07:14:13 <lseactuary> multiply or mod or something else for example
07:14:36 <lemmih> lseactuary: How about starting with the simplest cases first?
07:14:50 <lseactuary> yeah lemmih the base case doesnt throw an error
07:14:51 <lemmih> lseactuary: transduce iadd 0 [] = ?
07:15:14 <lseactuary> transduce fn b [] = [(b, Just b)] that will give us [(0, Just 0)]
07:15:24 <lemmih> lseactuary: That can't be right.
07:15:27 <lseactuary> hmm hecking
07:15:51 <lseactuary> hmm you are right
07:17:21 <lemmih> lseactuary: So what do you think 'transduce iadd 0 []' should be?
07:17:38 <lseactuary> [ (0, Just 0)]
07:17:52 <lemmih> lseactuary: No, that's not right. Do you see why it's not right?
07:18:10 <lseactuary> its of type [(b, Maybe c)]
07:18:12 <lseactuary> so not sure
07:18:42 <lemmih> Ok, that's a starting point. We need a return value of type [(b, Maybe c)].
07:18:53 <lseactuary> but you mentioned I cant use Maybe
07:19:00 <lseactuary> I have to use Just or Nothing
07:19:12 <lemmih> lseactuary: Maybe is a type constructor.
07:19:25 <lseactuary> i see
07:19:37 <lemmih> lseactuary: The relationship between Maybe and Just/Nothing is the same as the relationship between Int and 1/2/...
07:19:38 <lseactuary> but originally i was typing Maybe and getting a tonne of errors
07:20:08 <lseactuary> e.g. if i wrote transduce fn b [] = [(b, Maybe b)]
07:20:19 <lseactuary>     • Data constructor not in scope: Maybe :: b -> Maybe c     • Perhaps you meant variable ‘maybe’ (imported from Prelude)
07:20:24 <lemmih> lseactuary: That doesn't make sense. Just like '10 + Int' doesn't make sense.
07:20:24 <lseactuary> that was where we started :)
07:20:48 <lseactuary> oh
07:21:15 <lemmih> lseactuary: '10' is an 'Int'. 'Just False' is a 'Maybe Bool'.
07:21:26 <lseactuary> yeah
07:21:41 <lseactuary> transduce fn b [] = [(b, fn b)]
07:21:43 <lemmih> lseactuary: If we need something of type 'Maybe c' then we need to use 'Just' or 'Nothing'.
07:21:45 <lseactuary> something like this?
07:22:09 <lemmih> lseactuary: What's the type of 'fn'?
07:22:20 <lseactuary> b -> a -> (b, Maybe c)
07:22:30 <lemmih> lseactuary: Good. So what's the type of 'fn b'?
07:22:42 <lseactuary> thinking
07:23:10 <lseactuary> (b, Maybe b)?
07:23:24 <lemmih> lseactuary: Almost.
07:23:42 <lemmih> lseactuary: 'fn b :: a -> (b, Maybe c)'
07:24:08 <lemmih> lseactuary: So 'fn b' takes yet another argument and then gives us a tuple of 'b' and 'Maybe c'.
07:24:33 <lseactuary> right
07:24:36 <lemmih> lseactuary: But we need a value of type 'Maybe c', right?
07:24:51 <lseactuary> we need [(b, Maybe c)] no?
07:25:05 <lemmih> lseactuary: So 'transduce fn b [] = [(b, fn b)]' is not well-typed.
07:25:11 <lseactuary> ye
07:25:35 <lseactuary> we need to take the snd?
07:25:43 <lseactuary> of fn b
07:25:55 <lemmih> lseactuary: Does 'fn b' give us a tuple?
07:26:00 <lemmih> lseactuary: What's the type of 'fn b' again?
07:26:00 <lseactuary> ye
07:26:11 <lseactuary> (b, Maybe c)
07:26:14 <lemmih> Nope.
07:26:25 <lseactuary> oh sorry fn b
07:26:29 <lseactuary> b -> a -> (b, Maybe c)
07:26:35 <lemmih> That's the type of 'fn'.
07:26:39 <lemmih> What's the type of 'fn b'?
07:26:44 <lseactuary> (b, Maybe c)
07:26:46 <lemmih> Nope.
07:26:53 <lseactuary> (b, Maybe b)?
07:27:09 <lemmih> Still no. 'fn' is a function that takes two arguments, right?
07:27:14 <lseactuary> ye
07:27:18 <lseactuary> b and some list
07:27:24 <lemmih> So if you give it one arguments, how many arguments are left?
07:27:29 <lseactuary> one
07:27:57 <lemmih> Exactly. So 'fn b' is not a tuple. It needs one more argument before we get the tuple.
07:28:17 <lseactuary> yeah but i wrote that on the left no?
07:28:23 <lseactuary> transduce fn b []
07:28:56 <lemmih> lseactuary: What do you mean?
07:29:04 <lseactuary> i dont think im understanding the problem still
07:29:13 <lseactuary> transduce fn b [] = something is wrong?
07:29:23 <lseactuary> for the intial case of the recursion?
07:29:40 <lemmih> lseactuary: The code you have on the left-hand side of the '=' is perfect.
07:29:50 <lemmih> lseactuary: The code on the right-hand side is wrong.
07:29:52 <lseactuary> ok so on the right we are saying
07:30:01 <lseactuary> fn b [] will give the list of tuples
07:30:07 <lseactuary> of type [(b, Maybe c)]
07:30:07 <lseactuary> ?
07:30:10 <lemmih> lseactuary: No.
07:30:35 <lemmih> The type of 'fn' is 'b -> a -> (b, Maybe c)', right?
07:30:39 <lseactuary> ye
07:31:05 <lemmih> Meaning that it takes a value of type 'b', then it takes a value of type 'a' and then it gives us a tuple.
07:31:11 <lseactuary> ye
07:31:38 <lemmih> So if we give it 'b' and nothing else, then we don't get a tuple.
07:31:50 <lseactuary> but we are giving it []
07:32:14 <lemmih> lseactuary: No, that's a pattern match.
07:32:31 <lemmih> lseactuary: The things on the left-hand side of the '=' are pattern matches.
07:32:40 <lseactuary> yeah
07:33:05 <lemmih> lseactuary: So you see that we don't call 'fn' with [] as an argument?
07:33:16 <lseactuary> yup
07:33:32 <lseactuary> but transduce fn b [] = [] is wrong also
07:33:37 <lemmih> How so?
07:33:40 <lseactuary> as we should get a tuple
07:33:42 <lseactuary> no
07:33:43 <lseactuary> ?
07:33:47 <lemmih> Why should we get a tuple?
07:33:54 <lseactuary> oh
07:34:02 <lseactuary> sorry you are right
07:34:22 <lemmih> lseactuary: [] is the only value we can give that has the right type.
07:34:30 <lseactuary> ye
07:34:46 <APic> Yo.
07:34:52 <lseactuary> but transduce iadd 0 [1] should result in [ (0, Just 0)]
07:34:55 <lseactuary> pr just []
07:34:56 <lseactuary> ?
07:35:02 <lseactuary> i think that is what is confusing me
07:36:01 <lseactuary> sorry i mean transduce iadd 0 []
07:36:14 <lemmih> lseactuary: It's impossible to write a function if you don't know what it should do.
07:36:45 <lseactuary> it should give [(0, Just 0)] in my opinion
07:36:59 <lemmih> lseactuary: Your opinion is wrong. :)
07:37:02 <lseactuary> as if i look at the example: iadd b a = (b + a, if even b then Just b else Nothing)
07:37:26 <lseactuary> iadd 0 [] = (0 + [], if even 0 then Just 0 else Nothing)
07:38:42 <lseactuary> hmm i guess you cant really do that
07:38:47 <lseactuary> so it should just be empty
07:39:21 <lemmih> Yep.
07:39:22 <lseactuary> but then the recursion wont work right?
07:39:28 <lemmih> Why won't it work?
07:39:38 <lseactuary>  (fn b cmd, fn cmd) this part is wrong
07:39:40 <lseactuary> i need to rewrite
07:40:00 <lemmih> lseactuary: Yes, that part is also wrong.
07:40:21 <lseactuary> left hand side is all wrong?
07:40:26 <lseactuary> or whole line is wrong?
07:40:36 <lemmih> lseactuary: We've solved the simplest case. Let's look at the next simplest one: transduce iadd 0 [1] = ?
07:40:50 <lseactuary> oki
07:41:09 <lseactuary> should output [ (0, Just 0), (1, Nothing)]
07:42:09 <lemmih> lseactuary: I'm not so sure about that.
07:42:34 <lemmih> But let's try it.
07:43:07 <lemmih> How do we get the first part, '(0, Just 0)' ?
07:43:41 <lseactuary> (b, function applied to b)?
07:44:10 <lemmih> lseactuary: We really need to be on the same page when it comes to the type of 'fn b'.
07:44:54 <lseactuary> oh
07:45:24 <lemmih> Oh, hm, maybe I don't understand what 'transduce' should actually do.
07:45:50 <lseactuary> it is a kind of generalization of scanl. Instead of taking a binary operator of type b → a → b, it takes one of type b → a → (b, Maybe c) which yields optional c-outputs as well as new b-states.
07:45:52 <lemmih> Maybe 'transduce fn b [] = [ (b, Nothing) ]' is the base case you're looking for.
07:45:56 * hackage hasmin 1.0.2 - CSS Minifier  https://hackage.haskell.org/package/hasmin-1.0.2 (contivero)
07:47:42 <lseactuary> we can test :)
07:47:57 <lseactuary> transduce fn b (cmd:cmds) = (cmd, Just cmd) : transduce fn b cmds
07:48:04 <lseactuary> is that wrong for the recursion as it throws errrors
07:48:13 <lemmih> Yeah, that won't work.
07:48:18 <lseactuary> oki
07:48:22 <lemmih> lseactuary: You know how to use case expressions, right?
07:48:26 <lseactuary> ye
07:48:34 <lseactuary> like in compile3?
07:48:39 <lemmih> Yeah.
07:48:43 <lseactuary> yup
07:49:39 <lemmih> In the recursion case for 'transduce', we need to get the update accumulator from the 'fn' function.
07:49:51 <lseactuary> yeah
07:50:21 <lseactuary> so we probably need base case + first value + iterate from the second
07:50:24 <lemmih> lseactuary: We can do that with a case expression or a let expression.
07:50:30 <lseactuary> ok sure
07:51:21 <lemmih> lseactuary: Try updating the code such that we extract the tuple members from the 'fn' function call.
07:51:31 <lseactuary> oki trying
07:52:34 <lseactuary> we can use iterate?
07:52:48 <lemmih> lseactuary: We shouldn't use 'iterate'.
07:52:54 <lseactuary> mm k
07:53:54 <lseactuary> fst?
07:54:03 <ProofOfPizza> Hi folks, I have a question about Hakyll. I am trying to make a picture galley. I have this code:
07:54:04 <ProofOfPizza>     match "photos.html" $ do
07:54:04 <ProofOfPizza>         route idRoute
07:54:04 <ProofOfPizza>         compile $ do
07:54:04 <ProofOfPizza>             photosId <- getMatches "images/gallery/*" :: Compiler [Identifier]
07:54:04 <ProofOfPizza>             photosR <-  (mapM getRouteFor photosId)
07:54:05 <ProofOfPizza>             let photos = mapM (makeItem . toUrl . fromMaybe "") photosR
07:54:05 <ProofOfPizza>             let  photosCtx =
07:54:06 <ProofOfPizza>                     listField "photos" galleryCtx (photos) `mappend`
07:54:06 <ProofOfPizza>                     constField "title" "Photos"                `mappend`
07:54:07 <ProofOfPizza>                     defaultContext
07:54:24 <lemmih> lseactuary: Well, try using pattern matching.
07:54:32 <lseactuary> kk
07:54:58 <ProofOfPizza> but when i reference it it $for(photos)$ using $url$ it always returns "./photos.html" instead of the url to the specific photo
07:58:49 <pavonia> ProofOfPizza: That do-block doesn't return a value. Please paste the full example
07:58:53 <pavonia> @lpaste
07:58:54 <lambdabot> Haskell pastebin: http://lpaste.net/
08:00:03 <lseactuary> lemmih im stuck will upload what i tried
08:00:27 * hackage brittany 0.10.0.0 - Haskell source code formatter  https://hackage.haskell.org/package/brittany-0.10.0.0 (lspitzner)
08:00:40 <lseactuary> http://lpaste.net/8077748639461539840
08:01:28 <lemmih> lseactuary: Isn't that the same as before?
08:01:34 <lseactuary> hmm
08:01:48 <lseactuary> im not sure how to save the previous value and varry it forward
08:01:54 <ProofOfPizza> yes, pavonia: http://lpaste.net/364033
08:02:30 <lemmih> > let (a,b) = (10,20) in a+b       -- Does this code make sense to you, lseactuary?
08:02:33 <lambdabot>  30
08:06:45 <lseactuary> lemmih yeah
08:07:13 <lemmih> lseactuary: So imagine we did something like: let (b', maybeC) = fn b cmd in ...
08:07:48 <lseactuary> yeah
08:08:09 <lemmih> lseactuary: Can you then finish the rest of the code?
08:08:29 <lseactuary> like i get we need b and b'
08:08:34 <lseactuary> just not sure how to write the syntax
08:09:00 <lemmih> lseactuary: We have both b and b' with the code I showed you.
08:09:07 <lseactuary> oh you mean in the let
08:10:17 <lseactuary> let (b', maybeC) = (b+b', maybeC) in fn b cmd?
08:10:31 <lseactuary> wait thats wrong
08:10:33 <lseactuary> thinking
08:10:38 <kuribas> is :type-at in ghci-8.2 broken?
08:10:55 <lseactuary> let (b', maybeC) = (b, b+b') in fn b cmd?
08:10:59 <lemmih> lseactuary: No no, use the code as I showed you. Just fill in the '...'.
08:11:27 <lseactuary> but that is different to the ab example?
08:11:40 <kuribas> it doesn't show me the type of the source span, just of the last expression...
08:11:51 <lseactuary> but ill try
08:11:55 <lemmih> lseactuary: transducer fn b (cmd:cmds) = let (b', maybeC) = fn b cmd in ...
08:12:10 <lseactuary> oh you are using let instead of case
08:12:19 <lseactuary> got it
08:12:53 <ProofOfPizza> oh pavonia: there was a mistake in that paste. I removed it and cleaned it up a bit. Xcusa
08:12:56 * hackage giphy-api 0.6.0.1 - Giphy HTTP API wrapper and CLI search tool.  https://hackage.haskell.org/package/giphy-api-0.6.0.1 (passy)
08:13:42 <Squarism> The function "runSqlPool" takes 2 arguments in  https://hackage.haskell.org/package/persistent-2.8.1/docs/Database-Persist-Sql.html#v:runSqlPool  - the first one beeing very dymaic in how its typically passed (thing different kind of queries / expressions). The second one "pool" beeing the same always. I wonder about the rationally putting the static argument last as it makes it harder to do "runSqlPool pool $ ... $ ... ". It makes it harder to avoid
08:13:45 <Squarism> parantheses so to speak.
08:13:46 <pavonia> ProofOfPizza: Oh well, I don't think I can help with it though
08:14:01 <lseactuary> lemmih not sure tbh
08:14:06 <ProofOfPizza> ah ok too bad! Thx though!
08:14:27 <lemmih> lseactuary: I'm not sure how to help you without giving you the answer.
08:14:29 <lseactuary> are we trying to get the first of a list or something
08:14:37 <lseactuary> like what syntax is on the ....
08:14:40 <lseactuary> a tuple, a list?
08:14:53 <lseactuary> sorry i didnt use let before
08:14:56 <lseactuary> hence not sure
08:15:06 <lemmih> lseactuary: ... : transducer fn ... cmds
08:15:23 <lseactuary> ok now super confused
08:15:41 <lemmih> lseactuary: transducer fn b (cmd:cmds) = let (b', maybeC) = fn b cmd in ... : transducer fn ... cmds
08:15:50 <lemmih> lseactuary: You need to fill in the '...'s.
08:16:01 <lseactuary> oki trying
08:17:29 <lseactuary> transducer fn b (cmd:cmds) = let (b', maybeC) = fn b cmd in [(b,Nothing)] : transducer fn b' cmds
08:18:00 <lemmih> lseactuary: Well, that's a good guess. I think that is well typed.
08:18:04 <lseactuary> testing
08:18:49 <ProofOfPizza> Anyone else for a hakyll question? See http://lpaste.net/364033
08:19:15 <lseactuary> Non-exhaustive patterns in function transduce
08:19:38 <lemmih> lseactuary: Did you remember to add the base case?
08:20:16 <pavonia> Squarism: Incidentally, ReaderT does the same in its runReaderT function
08:20:29 <lseactuary> yup: http://lpaste.net/8077748639461539840
08:20:53 <lemmih> lseactuary: s/transducer/transduce/
08:21:04 <lseactuary> ah :P
08:21:28 <lseactuary> ok doesnt compile. debbgging
08:21:59 <lemmih> lseactuary: [(b, Nothing)] is not the same as (b, Nothing), btw.
08:22:08 <lseactuary> ye
08:22:19 <lemmih> > 1 : [2,3,4]  -- this is good.
08:22:21 <lambdabot>  [1,2,3,4]
08:22:27 <lemmih> > [1] : [2,3,4]  -- this is wrong.
08:22:29 <lambdabot>  error:
08:22:29 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_11234’
08:22:29 <lambdabot>      • In the expression: e_11234
08:22:33 <lseactuary> ah
08:22:36 <lseactuary> no [] needed
08:23:20 <lseactuary> ook works but
08:23:25 <lseactuary> [(0,Nothing),(1,Nothing),(3,Nothing),(6,Nothing),(10,Nothing),(15,Nothing)]
08:23:28 <lseactuary> so i need to fix the nothing
08:23:34 <lemmih> lseactuary: Yeah. Do you see that you're not using 'maybeC'?
08:23:55 <lseactuary> yup
08:24:04 <lemmih> lseactuary: Do you see where it can be used?
08:24:11 <lseactuary> yup
08:24:13 <lseactuary> testing
08:24:51 <lseactuary> got it :)
08:24:53 <lseactuary> uploading
08:25:27 <lseactuary> lemmih can you explain a bit also so i can take some notes and go back later and review?
08:25:42 <lseactuary> as it works now and gives the same result as in the book
08:26:35 <lemmih> lseactuary: I would suggest reading Learn You A Haskell For Great Good. It is a really fun (and free) book that introduces all the basic concepts of Haskell.
08:27:02 <lseactuary> nice :)
08:27:23 <lseactuary> qq can you help me with the compile3 function? it doesnt compile but i dont see the issue.
08:28:15 <lseactuary> this part is the error TurtleCmd1 TurtleCmd1 but ive tried various things with no luck :/
08:29:01 <lemmih> lseactuary: Why did you think that code would be correct?
08:29:33 <lemmih> lseactuary: What was your thought process when you wrote it?
08:30:00 <lseactuary> compile3 takes type TurtleProg3 and outputs type TurtleBranches3
08:30:34 <lseactuary> TurtleProg3 is type TurtleCmd3 which is type TurtleCmd1 TurtleCmd1 | Push3 | Pop3 | Skip3
08:30:44 <lseactuary> in each case something different happens so case statement made sense here i think
08:31:02 <lseactuary> The idea is that contiguous sequences of plain commands (moving and turning) get wrapped up as whole plain programs, in the Left case of the Either; Skip3 commands get discarded; and stack commands Push3 and Pop3 are represented in the Right case.
08:31:27 * hackage hasktags 0.69.5 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  https://hackage.haskell.org/package/hasktags-0.69.5 (jhenahan)
08:32:06 <lseactuary> i think initial3 = ((0,pi/2),[]) should be used here somewhere but i was just trying to figure out the cases first
08:32:06 <lemmih> lseactuary: Let's look at some simple cases. compile3 [TurtleCmd1 Forward1] = ?
08:32:10 <lseactuary> oki
08:33:14 <lseactuary> that would take the left case ie TurrtleCmd1
08:33:33 <lemmih> lseactuary: What would the result be?
08:33:52 <lseactuary> [TurtleCmd1]
08:34:18 <lemmih> lseactuary: No, that doesn't seem right.
08:34:35 <lseactuary> thinking
08:34:48 <lemmih> lseactuary: I think you've being confused by having both types and data constructors with the same name.
08:35:03 <lseactuary> sounds like it tbh
08:35:14 <lseactuary> oh
08:35:19 <lseactuary> it should just be [Forward1]?
08:35:23 <lemmih> Yes.
08:35:29 <lseactuary> interesting
08:36:01 <lemmih> We can actually add that case to the code. Try adding 'compile3 [TurtleCmd1 Forward1] = [Forward1]' after the initial base case.
08:36:53 <lseactuary> Couldn't match type ‘TurtleCmd1’                      with ‘Either TurtleProg1 TurtleCmd3’
08:37:33 <lemmih> lseactuary: Oh right, should be [Left Forward1]. We're returning a list of eithers.
08:37:56 * hackage persistable-record 0.5.2.2 - Binding between SQL database values and haskell records.  https://hackage.haskell.org/package/persistable-record-0.5.2.2 (KeiHibino)
08:38:17 <lemmih> lseactuary: Ah, it should actually be [Left [Forward1]].
08:38:35 <lseactuary> yup
08:38:50 <lseactuary> noob question but i thought Left / Right meant the left hand side / right hand side
08:38:59 <lseactuary> that is not what it means right?
08:39:22 <lemmih> lseactuary: The left-hand side and right-hand side of a function is something completely different.
08:39:29 <lseactuary> oki
08:39:41 <lemmih> lseactuary: Left and Right are used to tell values apart.
08:39:45 <lseactuary> ah
08:40:53 <lemmih> lseactuary: Now, what about this case: compile3 [TurtleCmd1 x] = ?
08:40:56 * hackage persistable-record 0.6.0.3 - Binding between SQL database values and haskell records.  https://hackage.haskell.org/package/persistable-record-0.6.0.3 (KeiHibino)
08:41:01 <Squarism> pavonia, so you think its more tradition than having some practical advantage?
08:41:31 <lseactuary> lemmih  compile3 [TurtleCmd1 x] = [Left [x]]
08:41:49 <lemmih> lseactuary: That looks good. Add it to the code.
08:42:01 <lseactuary> yup added and compiled before i pasted here :)
08:42:29 <lemmih> lseactuary: Now what about: compile3 (TurtleCmd1 x : cmds) = ?
08:42:39 <statusfailed> What are the objects and arrows of "Hask"? Types and functions?
08:42:40 <lseactuary> trying
08:43:58 <lseactuary> compile3 (TurtleCmd1 x : cmds) = [Left [x]] : compile3 cmds
08:44:14 <pavonia> Squarism: I don't know the reasons. In the case of Reader I presume it resembles some mathematical/categorical structures behind it
08:44:39 <lemmih> lseactuary: Remember the thing about '[1] : [2,3,4]' being wrong?
08:44:49 <lseactuary> oh ye
08:45:03 <lseactuary> compile3 (TurtleCmd1 x : cmds) = Left [x] : compile3 cmds
08:46:27 <lemmih> lseactuary: Great. Now what about: compile3 [Push3] = ?
08:46:38 <meck> Im having some problems trying out nix on macos, i've installed nix (single user) and i am trying to install ghc cabal and cabal2nix into the user env https://gist.github.com/meck/5be713fa2d08b448c919dd71d2d8f871
08:48:26 <meck> Shouldent nix solve this kind of conflict. i've tried diffrent channels including the new Darwin specific ones
08:48:34 <lseactuary> lemmih cannot be defined?
08:48:50 <lemmih> lseactuary: Oh? How come?
08:49:01 <lseactuary> dont we need 2 things to apply left/right to?
08:49:26 <lemmih> lseactuary: I don't understand what you mean.
08:49:36 <lseactuary> compile3 [TurtleCmd1 x] = [Left [x]]
08:49:45 <lseactuary> but now we only have compile3 [Push3]
08:50:00 <lseactuary> which wont just be Push3 or [Push3] or [[Push3]]
08:50:03 <lseactuary> right?
08:50:16 <lemmih> I still don't understand.
08:50:30 <lemmih> What should 'compile3 [Push3]' give?
08:50:43 <lseactuary> stack commands Push3 and Pop3 are represented in the Right case
08:51:00 <lseactuary> oh
08:51:01 <lemmih> lseactuary: Ok, so what should it give?
08:51:34 <lseactuary> Right [Push3]?
08:51:51 <lemmih> lseactuary: Check the types again.
08:52:24 <lemmih> Should it be a list of TurtleCmd3s (ie [Push3]) or just a single TurtleCmd3 (ie Push3)?
08:52:42 <lseactuary> single i think
08:52:45 <lseactuary> testing
08:53:14 <lseactuary> hm
08:53:31 <lseactuary> Couldn't match type ‘Either a0 TurtleCmd3’ with ‘[TurtleBranch3]’       Expected type: TurtleBranches3         Actual type: Either a0 TurtleCmd3
08:53:40 <lseactuary> when i do compile3 [Push3] = Right Push3
08:53:42 <lseactuary> seems the right type to me
08:54:01 <WhatisRT> hi! I was messing with my haskell installation, and now I'm missing ghc-pkg and stack doesn't seem to have it. How do I get it back?
08:54:06 <lemmih> lseactuary: Now you removed both the lists. We should only remove one of them.
08:54:23 <lseactuary> ooh
08:54:23 <lseactuary>  compile3 [Push3] = [Right Push3]
08:54:25 <cocreature> WhatisRT: try "stack exec -- ghc-pkg"
08:54:26 <lseactuary> got it
08:54:42 <cocreature> WhatisRT: although you should rarely need to call ghc-pkg directly
08:54:47 <lemmih> lseactuary: Great. Now what about: compile3 (Push3 : cmds) = ?
08:55:00 <WhatisRT> it says missing command
08:55:06 <WhatisRT> stack build requires it
08:55:31 <lseactuary> lemmih compile3 (Push3 : cmds) = Right Push3 : compile3 cmds
08:55:55 <lemmih> lseactuary: Looks good. Can you define the cases for Pop3 and Skip3?
08:55:59 <cocreature> WhatisRT: so running "stack build" complains about ghc-pkg not existing?
08:56:10 <lseactuary> Pop3 is the same as Push3 basically
08:56:13 <WhatisRT> cocreature: yes
08:56:13 <lseactuary> Skip3 i can try
08:56:29 <cocreature> WhatisRT: that’s weird. have you set system-ghc: true?
08:56:50 <WhatisRT> cocreature: yes
08:57:02 <lseactuary> lemmih - uploaded - this compiles
08:57:13 <cocreature> WhatisRT: then you need to make sure that ghc-pkg is in your PATH. it should be bundled with GHC
08:58:39 <Squarism> anyone have any heads up regarding Yesod/Persistent. Im trying to adopt it but find documentation sparse and/or inconsistent
08:59:25 <knup> For large builders, does increasing the chunksize increase performance?
08:59:54 <ZeuPiark> hello
09:00:10 <WhatisRT> cocreature: ok, seems like my system ghc is broken
09:00:10 <WhatisRT>  
09:00:21 <lseactuary> lemmih - this means my step3 is wrong right?
09:00:40 <cocreature> WhatisRT: how have you installed your system ghc?
09:00:52 <WhatisRT> cocreature: and stack install ghc wants to install ghc-8.2.2 but can only find ghc-8.2.1
09:01:38 <WhatisRT> cocreature: originally via download from the website, but I wanted to switch to stack
09:01:40 <cocreature> WhatisRT: you’re going to need to provide more information. which system are you on? what’s the full error message?
09:02:39 <WhatisRT> cocreature: the error message is The following package identifiers were not found in your indices: ghc-8.2.2
09:02:39 <WhatisRT> Possible candidates: ghc-8.2.1.
09:02:58 <WhatisRT> cocreature: and I'm on a mac
09:03:19 <cocreature> WhatisRT: you can’t install GHC using "stack install ghc", stack will automatically install GHC or you can tell it to using "stack setup" (once you disable system-ghc)
09:03:34 <cocreature> WhatisRT: "stack install" is for installing executables of packages on hackage
09:04:36 <WhatisRT> cocreature: so I can't use stack to install a system ghc?
09:05:20 <cocreature> WhatisRT: depends on what you mean by “system ghc”. the “system-ghc” option tells stack to use the GHC that’s already installed on your system instead of trying to install GHC itself.
09:05:33 <cocreature> WhatisRT: as long as you run all commands through stack you don’t need a system ghc
09:05:54 <cocreature> WhatisRT: if you do want a regular GHC, you can always add the directory that stack installs GHC into to your PATH
09:09:25 <WhatisRT> cocreature: ok, so I tried disabling system-ghc and run stack setup in my project, but it didn't do anything
09:09:26 * hackage grammatical-parsers 0.3 - parsers that can combine into grammars  https://hackage.haskell.org/package/grammatical-parsers-0.3 (MarioBlazevic)
09:09:36 <cocreature> WhatisRT: try running "stack build"
09:09:51 <WhatisRT> cocreature: still the same error message
09:10:17 <cocreature> WhatisRT: and that error message is? you’ve only shown us the error message from when you tried running "stack install ghc" afaict
09:10:40 <WhatisRT> cocreature: /usr/local/bin/ghc-pkg: createProcess: runInteractiveProcess: exec: does not exist (No such file or directory)
09:10:51 <cocreature> sounds like you still have system-ghc enabled
09:11:02 <cocreature> try "stack --no-system-ghc build"
09:11:04 <w1n5t0n> how can I define an infix function that multiplies the LHS with everything that comes after?
09:11:32 <WhatisRT> cocreature: still the same message
09:11:50 <lemmih> w1n5t0n: You can't.
09:11:56 <cocreature> WhatisRT: huh something is seriously wrong with your setup. how did you install stack? and are you on the latest version?
09:12:40 <WhatisRT> cocreature: I think stack came with the download from the website
09:12:54 <cocreature> which download from which website?
09:12:59 <WhatisRT> cocreature: version 1.6.1
09:13:28 <cocreature> try "stack upgrade", 1.6.5 is the latest. I doubt that will help but it’s worth a try at least
09:13:29 <WhatisRT> cocreature: https://www.haskell.org/downloads#platform
09:14:56 <cocreature> WhatisRT: maybe try removing that (don’t ask me how, I haven’t used the Haskell platform) and follow the installation instructions on https://docs.haskellstack.org/en/stable/install_and_upgrade/#macos
09:16:21 <WhatisRT> cocreature: yeah, updgrading didn't help. Then I'll try the reinstall
09:17:25 <cocreature> I’m neither on macOS nor have I used the Haskell platform, so I’m afraid apart from that I’m out of ideas :/
09:17:37 <WhatisRT> cocreature: but thanks anyways!
09:17:43 <WhatisRT> shouldn't be too much work
09:18:29 <cocreature> WhatisRT: oh maybe try "stack --no-system-ghc setup --reinstall"
09:19:33 <WhatisRT> cocreature: this seems to work! at least it's installing ghc
09:20:20 <lseactuary> i have a type issue, i understand what it is but aa bit stuck on how to correct: http://lpaste.net/8077748639461539840
09:20:26 <lseactuary> can someone help me. last question for today :)
09:21:14 <lemmih> lseactuary: Start with the base case.
09:21:17 <lseactuary> oki
09:22:23 <lseactuary> oh i need to use compile3
09:22:45 <dmj`> lseactuary: you need to go from Turtletate3 -> TurtleState2
09:23:14 <lseactuary> type TurtleState3 = (TurtleState2, [TurtleState2])
09:24:11 <dmj`> In the base case you’re going from TurtleState3 -> [TurtleState3]
09:24:36 <dmj`> line 56, ts3 = [ts3]
09:24:43 <lseactuary> ah
09:25:04 <dmj`> are turtles allow to go to previous states
09:25:09 <dmj`> Allowed*
09:25:17 <lseactuary> i dont think so
09:25:25 <WhatisRT> cocreature: ok, it did something, but sadly not fix the problem
09:25:40 <lseactuary> well actually, yes
09:26:03 <lseactuary> which is why i think my step3 function is wrong also
09:27:00 <WhatisRT> cocreature: I decided to try and reinstall the haskell platform, and that worked
09:27:50 <dmj`> lseactuary: so what are you trying to accomplish
09:28:09 <lseactuary> in step3 or run3?
09:28:32 <dmj`> run3
09:28:50 <lseactuary> to run a turtle program, extracting each polyline’s-worth of points separately
09:28:59 <lseactuary> once i have this, i can compile the code and draw trees
09:31:44 <lseactuary> if we start with the base case we get initial3 = ((0,pi/2),[]) so the base case i think would just be the (0,pi/2) point
09:32:00 <lseactuary> Just (0,pi/2)
09:37:17 <lseactuary> lemmih or dmj` any ideas please?
09:37:36 <lemmih> lseactuary: I think you can solve it if you think about it.
09:37:45 <lseactuary> oki but is step3 ok?
09:37:48 <lseactuary> or wrong also
09:37:53 <lemmih> lseactuary: step3 is also wrong.
09:37:58 <lseactuary> oki let me start there
09:39:13 <EvanR> https://twitter.com/Iceland_jack/status/977287494264868867
09:43:51 <EvanR> so lets talk about sum
09:43:55 <EvanR> @src sum
09:43:55 <lambdabot> sum = foldl (+) 0
09:44:10 <EvanR> ignore the missing '
09:44:24 <EvanR> i am finding that in many situations this is the worst possible way to do a sum
09:45:24 <EvanR> like, for floating point there is kahan summation. for exact real numbers, doing a sum sequentially like this will result in getting exponentially more precision than necessary
09:45:34 <EvanR> when you only need linear more
09:45:35 <w1n5t0n> I have a "newtype Mytype a = Mytype a deriving (Eq, Ord, Enum, RealFrac)" and a "type Value = Mytype Double" but I get the following error "no instance for (RealFrac Value)" when I try to use floor (same with Enum). Do the derivations not transfer to the Value type?
09:45:52 <EvanR> even for adding a bunch of naturals, theres is probably shortcut
09:46:56 <EvanR> maybe the underlying operation should be sum, and + is defined in terms of it?
09:47:08 <EvanR> (is lisp laughing at us all)
09:47:20 <lemmih> w1n5t0n: Works for me when you add the missing type classes.
09:48:21 <EvanR> dont you need Real, Fractional too
09:49:11 <lseactuary> lemmih - i am sturggling with step3
09:49:20 <lseactuary> i have broken out the types and am trying to understand how to go from one ot the next
09:49:25 <lseactuary> but its becoming complicated
09:49:54 <lemmih> lseactuary: What's the smallest case we can work on?
09:50:08 <lseactuary> step3 dis dir _ []
09:50:30 <lemmih> lseactuary: That doesn't look right.
09:50:54 <lseactuary> step3 dis dir _ (p,[])
09:51:07 <lemmih> lseactuary: Better but pick a value for '_'.
09:51:17 <lemmih> lseactuary: Do you know what '_' means?
09:51:18 <lseactuary> it is of type Either [TurtleCmd1] TurtleCmd3
09:51:28 <lseactuary> im not sure how to choose a value in this case
09:51:32 <lseactuary> can just call it tc or something?
09:51:35 <lemmih> lseactuary: Pick the simplest value.
09:51:43 <lseactuary> []?
09:52:10 <lemmih> lseactuary: Good.
09:52:43 <lemmih> lseactuary: Now, step3 dis dir [] (ts2, []) = ?
09:53:26 * hackage potoki-hasql 1.1 - Integration of "potoki" and "hasql".  https://hackage.haskell.org/package/potoki-hasql-1.1 (IrinaArtemeva)
09:53:46 <lseactuary> Couldn't match type ‘[a0]’ with ‘Either TurtleProg1 TurtleCmd3’       Expected type: TurtleBranch3         Actual type: [a0]
09:53:55 <lseactuary> when i try to compile step3 dis dir [] (ts2, []) = undefined
09:55:03 <lemmih> lseactuary: Ah, the third argument is a TurtleBranches3, not a TurtleBranch3.
09:55:21 <lseactuary> yeah hence got confused
09:55:33 <lemmih> lseactuary: So what's the simplest TurtleBranch3 you can imagine?
09:56:18 <lseactuary> Either TurtleProg1 TurtleCmd3 is the type so Either [] then maybe Skip3
09:57:04 <lseactuary> e.g. Either [] Skip3
09:57:33 <lemmih> lseactuary: We want something like 'Left ...' or 'Right ...'.
09:58:01 <test64> hi in Data.Matrix inverse m return to me an Either String (Matrix ) how can I convert to a Matrix (in the aim to multiply) ?
09:58:43 <EvanR> Either String (Matrix ...) might not be a Matrix, what do you want to happen if it isnt
09:59:12 <test64> I don't understand EvanR
09:59:19 <lseactuary> lemmih should we use compule
09:59:24 <lseactuary> *compile3
09:59:35 <lemmih> lseactuary: Let's find the simplest case first.
09:59:45 <EvanR> the result is either a String or a Matrix
09:59:57 <lseactuary> ok then just Left []
10:00:07 <lseactuary> wait sorry
10:00:11 <lseactuary> [Left []]
10:00:18 <test64> because it's return to me Right (-0.7777 .... )
10:00:34 <lemmih> lseactuary: You sure about that last part?
10:00:36 <EvanR> what do you want it to do if it returns Left "no inverse"
10:01:40 <test64> Ok but I can't multiply after
10:01:57 <lseactuary> step3 dis dir [Left [Forward1]] (ts2, []) = undefined
10:02:34 <lseactuary> hmm nope
10:02:43 <EvanR> test64: what do you want it to do if it returns Left "no inverse"?
10:02:51 <lseactuary> not sure
10:03:11 <pavonia> In this small example http://lpaste.net/364040 why aren't those instances overlapping?
10:03:21 <lemmih> lseactuary: Why not 'Left []' like you said before?
10:03:39 <test64> I don't know Evan for the moment is a test and I suppose that it's ok
10:03:44 <lseactuary> oh
10:03:48 <lseactuary> yeah sorry
10:03:54 <lseactuary> step3 dis dir (Left []) (ts2, []) = undefined
10:03:59 <EvanR> test64: but, you can't multiply a string and a matrix...
10:04:09 <test64> I know that
10:04:09 <EvanR> you have to pick something
10:04:20 <EvanR> test64: http://lpaste.net/364041
10:04:44 <lemmih> lseactuary: Now just replace 'undefined' with the correct answer.
10:04:56 <test64> inverse :: (Fractional a, Eq a) => Matrix a -> Either String (Matrix a)     it's return me a Strin + Matrix , something like this
10:05:09 <EvanR> did you see my paste
10:05:13 <EvanR> ?
10:05:32 <test64> Yes
10:05:41 <test64> but how can I continue
10:05:42 <test64> ?
10:05:51 <EvanR> you fill in the ...s
10:06:07 <EvanR> case analysis is how you convert sum types
10:06:13 <EvanR> like Either
10:06:17 <lseactuary> lemmih oki
10:06:32 <test64> yes but how can I multiple    inverse m  with another matrix
10:06:33 <test64> ?
10:06:47 <EvanR> if you know what you wanted to do in case of String, there might be a nicer way
10:06:54 <EvanR> but you haven't answered
10:07:32 <EvanR> test64: you can't. the Either must be handled somehow
10:07:41 <EvanR> inverse m is not a matrix
10:07:43 <lseactuary> lemmih  step3 dis dir (Left []) (ts2, []) = ((ts2, []), Just [ts2])
10:08:41 <EvanR> > liftA2 (+) (Right 5) (Right 6)
10:08:44 <lambdabot>  Right 11
10:08:53 <EvanR> > liftA2 (+) (Left "wronnnggg") (Right 6)
10:08:56 <lambdabot>  Left "wronnnggg"
10:09:11 <EvanR> is another way
10:09:37 <test64> Ok EvanR I have a matrix x and y  I want to do    xinv = inverse x     and after   multStd xinv y
10:09:45 <EvanR> you cant
10:09:50 <lemmih> lseactuary: Ok, now: step3 dis dir (Left [Forward1]) (ts2, []) = ?
10:09:51 <EvanR> wrong types
10:10:02 <test64> how can i do this ?
10:10:10 <EvanR> liftA2 multStd xinv (pure y) is possible
10:10:19 <w1n5t0n> lemmih: I've now changed it to "newtype Value = Value Double", as all I really wanted is to hijack the (*) operator to have doubles multiplied lazily when the left argument is 0. Now I get errors from functions that expect Doubles, like Foreign.Storable.newArray. I thought that "newtype" still treats the types the same under the hood, am I missing something?
10:11:16 <EvanR> newtype makes a new type, distinct from the wrapped type. so MyValue 3.14 will not be accepted as a Double
10:11:30 <EvanR> youre thinking of a type synonym
10:11:39 <EvanR> type Cool = Double
10:12:02 <w1n5t0n> EvanR: so how would I transform it back to a double while keeping the custom behavior I defined for (*) in the Num instance?
10:12:18 <EvanR> you cant, Double has its own * you can redefine
10:12:22 <EvanR> cannot*
10:12:34 <EvanR> are you trying to monkeypatch haskell?
10:12:35 <lemmih> test64: You keep asking for the answer but we really want you to understand why your code doesn't work.
10:13:24 <EvanR> w1n5t0n: is the issue that newArray doesnt work with your newtype because its not Storable?
10:13:31 <test64> Ok thanks it works
10:15:40 <matchray> In which version can we use -XBlockArguments ?
10:15:46 <lseactuary> lemmih its not right but i am stuck : step3 dis dir (Left [Forward1]) ((p,d), []) = ((p,d), Left (Forward1 p,d))
10:16:45 <lyxia> matchray: it's not out yet
10:16:53 <w1n5t0n> EvanR: I'm trying to customize it to fit a live coding workflow for music, which involves having a lot of equations that I don't want evaluated if the LHS argument of (*) evaluates to 0, basically acting like a sequencer that short-circuits when not in use. My problem is that I eventually want Values to be plugged to functions that expect Doubles, like newArray or others.
10:17:22 <EvanR> well Values arent going into any functions that expect Doubles
10:17:35 <matchray> ghc 8.6 https://ghc.haskell.org/trac/ghc/wiki/LanguagePragmaHistory
10:17:41 <EvanR> one way is to make versions of all the functions that accept Values
10:17:54 <lseactuary> sec
10:17:57 <EvanR> but it sounds like youre trying to do something in a weird way
10:18:01 <pavonia> Ah interesting, overlapping instances erros only occur at the point when you actually want to use them :S
10:18:36 <lseactuary> lemmih i am not sure, also tried this step3 dis dir (Left [Forward1]) (ts2, []) = ((ts2, [Forward1]), Just[ts2])
10:19:31 <EvanR> > foldr (*) 1 (0 : repeat 1)
10:19:38 <lambdabot>  mueval-core: Time limit exceeded
10:19:38 <lambdabot>  mueval: ExitFailure 1
10:19:41 <EvanR> > foldr (*) 1 (0 : repeat 1) :: Double
10:19:49 <lambdabot>  mueval-core: Time limit exceeded
10:19:49 <lambdabot>  mueval: ExitFailure 1
10:19:51 <EvanR> yeah ok
10:19:56 <lemmih> lseactuary: Keep thinking about the types.
10:20:04 <w1n5t0n> EvanR: It's for a uni project and I want to see how far I can push the language to fit around a specific workflow I have in mind, so definitely weird! That being said, could I possibly still use Double but hide (*) from Prelude and define my own?
10:20:22 <EvanR> no, you can't monkeypatch haskell
10:20:24 <lseactuary> Forward1 needs to be applied to the ts2 no?
10:21:14 <EvanR> it wants you to define your own valid number type that does what you want, and supports what you want
10:21:22 <EvanR> properly, no corner cutting
10:22:44 <cocreature> hiding (*) from the Prelude should work
10:22:49 <w1n5t0n> EvanR: I have but I can't redefine the library functions I'm using that expect Doubles. Can I at least have a Value -> Double function I plug in at the very end of the chain, when I want to get the array?
10:22:51 <EvanR> and all this to modify how (0*) works on doubles seems like a case of premature optimization
10:23:29 <EvanR> you can make a wrapper for the library function that does take a Value, are you asking how to unwrap the newtype?
10:23:51 <EvanR> idiom is newtype Value = MkValue { getDouble :: Double }
10:23:51 <lemmih> lseactuary: I'm leaving now but you have everything you need to solve your problems.
10:23:55 <w1n5t0n> yes, I'm not sure how to do it
10:24:05 <EvanR> or getDouble (MkValue x) = x
10:24:06 <lseactuary> lemmih - many thanks for the help!
10:24:32 <EvanR> or deValue (MkValue x) = x :)
10:25:16 <w1n5t0n> EvanR: of course, I feel stupid now! Thanks for the help :)
10:50:33 <AWizzArd> I am looking for some kind of hashmap backed by a tree where my lookup is not using == but < or >= and such, and where the returnd values is a list/set of values. My keys are Ints (or Scientific) and the value are nodes.
10:50:37 <AWizzArd> When I store node1 to node10 under the keys 1-10 then looking up (<3.7) will give me node1, node2 and node3.
10:55:51 <cocreature> AWizzArd: Data.Map + a bunch of convenience wrappers?
10:56:51 <cocreature> e.g. split + elems should do the job for that query
10:59:22 <AWizzArd> In Clojure this would be a sorted-map-by instance which is backed by a red-black tree under the hood.
10:59:51 <cocreature> Data.Map is already backed by some tree
11:01:07 <AWizzArd> Ah, and it does not return a value but instead a list/set of values for which a certain condition is true?
11:01:27 <cocreature> take a look at the functions I’ve mentioned
11:01:52 <cocreature> split will split a map into two maps based on whether the key is great or smaller, elems will give you all values in a map
11:02:05 <cocreature> so if you combine those two you get all keys that are greater
11:02:31 <cocreature> there are also funktions like lookupGT which might be helpful
11:03:04 <cocreature> you could even just do a toAscList and throw a dropWhile at that
11:03:16 <AWizzArd> Yes that could work. I am looking at the split functions now.
11:04:42 <AWizzArd> Tho it seems to use a stric < lookup. I can’t have <=
11:05:27 <cocreature> in that case toAscList + dropWhile might be easier
11:05:48 <cocreature> although that has worse asympotics :/
11:06:37 <cocreature> if you care about performance, you’ll probably have to look at the maximum of the other map to check if you also want to include it
11:07:19 <AWizzArd> Yes I care for performance because I want to use this as one of the elements to create a generalized tree for a RETE network.
11:08:14 <AWizzArd> Maybe I’ll have to implement that part then myself if no very well-suited tree type already exists.
11:08:29 <cocreature> containers also exports its internals in an .Internal module these days so you can just access the underlying tree directly
11:08:52 <exio4> in this case I'd simply create a module which implements this with Data.Map, kinda naively
11:09:08 <exio4> and later on maybe implement this in a faster/more performant/etc way
11:09:20 <AWizzArd> maybe  partitionWithKey
11:10:23 <cocreature> partitionWithKey doesn’t give you better asymptotics than the toAscList + dropWhile solution
11:10:40 <AWizzArd> Ooh yes I just see this.
11:10:48 <cocreature> ah splitLookup looks useful
11:10:59 <cocreature> you can easily combine that to <=
11:11:41 <jollygood2> is there a fastnub :: Ord a => [a] -> [a]?
11:11:53 <johnw> jollygood2: it's been proposed a few times over the years
11:12:17 <johnw> an easy way to do it is basically Data.Set.toList . Data.Set.fromList
11:12:19 <cocreature> https://hackage.haskell.org/package/extra-1.6.5/docs/Data-List-Extra.html#v:nubOrd
11:12:32 <jollygood2> johnw I agree it is easy to write. not that easy though :)
11:14:15 <hudler> I am thinking to spend 2 hours daily for haskell apart from my day job
11:14:45 <jollygood2> (Data.Set.toList . Data.Set.fromList won't keep elements order, unlike original numb)
11:14:46 <jollygood2> nub*
11:15:08 <hudler> haskell worth enough for my time?
11:16:16 <johnw> hudler: if you were me, yes; but I don't know what you value in life
11:16:52 <hudler> johnw:  I value most to money then to ladies then education
11:17:10 <johnw> ok, maybe not the best thing then :)
11:17:41 <hudler> why ?
11:17:50 <hudler> we need to spend a lot of time on computers ?
11:18:01 <pikajude> if i wanted to build a value representing the structure of a nested datatype
11:18:03 <pikajude> should i use a graph or a tree for that
11:18:19 <johnw> I mean, you can make a lot more money faster in other languages, since there aren't all that many Haskell jobs right now in comparison
11:19:54 <hudler> johnw: for me languahe just tools and money is based on product than tools right ? I already have a day job ...I dont want yo earn a new job i just said I calue for them but not through haskell
11:21:16 <AWizzArd> There are not many jobs, and the few that there are – they are also not too well paid: https://insights.stackoverflow.com/survey/2018
11:21:23 <hudler> if I spend daily 2 hours would I need 1 year time or more to write my own compiler in haskell
11:21:33 <hudler> or become haskell bro
11:22:02 <v0d1ch> bro? :) you are already a bro if you are here
11:22:14 <hudler> bro ?
11:22:23 <hudler> pro*
11:22:24 <Tuplanolla> That sounds like a reasonable goal, hudler.
11:22:26 <hudler> not bro
11:22:36 <jollygood2> you're not a haskell bro until you buy a monad tshirt
11:22:39 <pikajude> haskell bruh
11:22:48 <v0d1ch> haha right
11:23:02 <hudler> monad is all because of safety>
11:23:16 <hudler> I am sideeffected'so far
11:23:42 <hudler> Tuplanolla:  ok then I will start
11:23:52 <hudler> I also wish I become pro in a day
11:23:59 <hudler> which will never happen
11:24:27 <v0d1ch> it is the journey that matters and all that
11:24:52 <Tuplanolla> All you need to do to become a professional is to convince someone to pay you.
11:25:38 <hudler> AWizzArd:  https://insights.stackoverflow.com/survey/2018  from this devops 2nd highest paid
11:25:44 <hudler> its not correct
11:26:01 <hudler> not right results resukts it seems
11:26:23 * happyente[m] sent a long message: happyente[m]_2018-03-25_18:26:01.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/OHpLDcGeoLKOMcnxGkGmsJyI>
11:26:47 <happyente[m]> Woops the formatting sorry 🙂
11:26:55 <AWizzArd> hudler: I had this in mind: https://insights.stackoverflow.com/survey/2018#top-paying-technologies
11:27:59 <hudler> but all functional programmings are highest paid
11:28:01 <hudler> awesome
11:28:33 <AWizzArd> Groovy on par with Clojure though.
11:29:26 <hudler> groovy is almost java ?
11:29:40 <AWizzArd> Yeah, just untyped and with nicer syntax.
11:29:50 <AWizzArd> Interesting also how only 53% of Haskell programmers love Haskell and would like to continue using it.
11:31:18 <hudler> I assume after learning haskell its very easy to picf f#, clojure, rust which are high paid right or am I wrong ?
11:31:50 <AWizzArd> Yes, easy to pick them up, but the first days can be difficult because of the non-lazyness and non-purity.
11:32:19 <AWizzArd> I still wonder why this is so. I came from Clojure and like Haskell a good bit more.
11:33:07 <jollygood2> AWizzArd where did you find 53% stats?
11:33:48 <hudler> and AWizzArd did you find java dpnt even have a place in it
11:33:54 <hudler> which cannot be real
11:35:17 <AWizzArd> jollygood2: https://insights.stackoverflow.com/survey/2018#most-loved-dreaded-and-wanted
11:35:43 <AWizzArd> In the „Loved” section under the stats it says: „% of developers who are developing with the language or technology and have expressed interest in continuing to develop with it”
11:35:44 <ddellacosta> the 53% is from the list of "most loved," and presumably it's out of all developers responding to the SO survey. I'd take it with a bucket of salt
11:36:01 <AWizzArd> ddellacosta: no it’s the percentage of those who develop with that lang.
11:36:23 <AWizzArd> I also first thought that, but under the stats it says they’ve asked the right set of people.
11:37:26 <ddellacosta> and out of people responding to a SO survey and identifying as Haskell developers, do we know how many of them are hobbyists or tinkerers? How well does this represent the actual Haskell community?
11:37:26 <hudler> but I am worried I will be learning haskell for 1 year and then I need to learn languages like f#, clojure etc
11:37:45 <hudler> 1 year is a lot of time isnt it ?
11:37:51 <MarcelineVQ> If you're worried about learning new things software dev isn't for you.
11:38:11 <hudler> MarcelineVQ:  I am not at all worried to learn new things
11:38:21 <ddellacosta> AWizzArd: regardless of whether it's all developers on SO or just those identifying as Haskell devs, still should be taken with a bucket of salt
11:38:25 <hudler> I said 1 year is worried factor
11:38:30 <MarcelineVQ> then be not concerned
11:38:49 <ddellacosta> relevant: https://www.reddit.com/r/haskell/comments/85lghz/developers_who_work_with_languages_like_matlab/
11:38:58 <hudler> MarcelineVQ:  Even f#, clojure need 1 year ?
11:39:31 <jollygood2> if "haskell developer" includes people who tried haskell out of curiosity and never reaching the point where they'd be productive in it then 53% is pretty high number
11:39:39 <jollygood2> reached*
11:39:51 <MarcelineVQ> I doubt there's any lanuage you can be proficient with all on your own in under a year
11:40:14 <ddellacosta> yeah this survey is close to useless, it's marketing for SO
11:40:54 <hudler> MarcelineVQ:  hmmm and what is F# irc channel I want to know why its highest paid ? how it is useful ?
11:40:56 <shapr> Is murmur hash currently the best choice for a bloom filter?
11:41:05 <MarcelineVQ> I've no idea
11:42:26 * hackage type-of-html 1.3.3.2 - High performance type driven html generation.  https://hackage.haskell.org/package/type-of-html-1.3.3.2 (knupfer)
11:42:38 <hudler> its shitty microsoft product I am against it then
11:43:56 <hudler> ok I am Haskell master by December 2018 and hope haskell comunity keep same spirit as now and dont die by then
11:44:06 <johnw> hudler: you do realize Haskell was mainly funded by Microsoft Research?
11:44:18 <hudler> really ?
11:44:21 <hudler> i dont know
11:44:31 <hudler> shit '
11:44:36 <hudler> i feel so bad
11:44:40 <johnw> yep, that's where Simon Peyton Jones still works, and Simon Marlow did until a few years ago
11:47:44 <hudler> I am thinking peter norwig and simon jones same and they are different
11:49:10 <ddellacosta> johnw: I don't think it's fair to give MS credit for "mainly funding" Haskell. A lot of different organizations and individuals have been involved with it's creation and continued development.
11:49:18 <ddellacosta> *its
11:55:16 <johnw> ddellacosta: fair enough, I'll delete that thought
12:00:40 <hudler> ok bye friends and geeks
12:02:03 <monochrom> Wait, people in F# irc channel are highest paid?  Then I need to join that channel to get higher pay. :)
12:02:28 <AWizzArd> I wish it were that easy (-:
12:03:47 <monochrom> More seriously, some MS products are shitty, but the people involved are completely disjoint from MSR people.
12:04:22 <hudler> monochrom:  but i dont find F# irc
12:04:42 <hudler> and I think many here are more into academics
12:05:06 <monochrom> At some point you need to realize that MS is so big you can't just think of MS as one single entity.
12:05:25 <hudler> MS  == microsoft ?
12:05:28 <monochrom> Yeah.
12:05:49 <hudler> but its ceo sucks so I hate MS
12:05:52 <monochrom> As with every big organization, it always contains two groups that exhibit completely opposite behaviour.
12:06:38 <hudler> monochrom:  true I work for another big company and here Managers just want to showcase the things than creating usefull stuff
12:15:05 <fendor> I am trying to implement a game in haskell, I want it to be done in Haskell and I need websockets, any recommendations for a graphics library or game library?
12:16:54 <[exa]> websockets?
12:17:15 <[exa]> that doesn't go quite right with a game unless it's in-browser
12:17:41 <AWizzArd> fendor: possibly https://hackage.haskell.org/package/yesod-websockets
12:18:21 <fendor> [exa], it should be a multiplayer game and we are thinking about adding a client implmentation in the browser
12:19:12 <fendor> AWizzArd, there are plenty of websocket implementations, but some game libraries do not go well with them, for example Helm, which makes it a non-trivial problem and provides no documentation for it
12:19:40 <fendor> [exa], after implementing it for the desktop, as far as this is possible
12:20:44 <AWizzArd> fendor: what software would provide the websocket client if not the browser?
12:21:04 <[exa]> fendor: oh so you want to have websockets as primary communication protocol, ok
12:21:50 <fendor> [exa] such a terrible idea? i sense sarcasm :D
12:22:16 <AWizzArd> fendor: I wonder why you wouldn’t want to go with ZeroMQ for example.
12:22:28 <fendor> AWizzArd, what is ZeroMQ?
12:22:56 <[exa]> not really, but people usually target a completely different stuff with websockets than with game communication protocols. If the game is fast, you'll want UDP, if not, you'll realize that you want it as well
12:23:08 <AWizzArd> Sockets. Communication. Very easy to use, very efficient.  http://zeromq.org/
12:23:16 <[exa]> zeroMQ is a great library, +1
12:23:40 <AWizzArd> Pretty lightweight. I used in in Haskell just in this week and implemented a load balancing remote call server with it.
12:23:43 <fendor> AWizzArd, is this commmunication library suitable for browsers?
12:24:56 <AWizzArd> fendor: the thing is: you can use it with a websocket transport. So the server is zmq and the client is  https://github.com/zeromq/JSMQ  + websocket transport.
12:25:37 <AWizzArd> It just allows you to build exactly the server backend that you like. With or without broker. With queueing or not, etc.
12:26:02 <fendor> AWizzArd, so i can still use UDP and send it to the web?
12:26:27 <fendor> *not web but webbrowser
12:26:56 * hackage dhall-lex 0.2.0.0 - Lexer for the Dhall language  https://hackage.haskell.org/package/dhall-lex-0.2.0.0 (vmchale)
12:29:38 <AWizzArd> fendor: it uses TCP and works very well between all systems that use zmq.
12:30:00 <fendor> however, still interested in a game engine library where I can integrate some way of internet communication
12:30:12 <fendor> AWizzArd, I thought TCP is terrible for game development?
12:30:27 * hackage hackage-repo-tool 0.1.1.1 - Utility to manage secure file-based package repositories  https://hackage.haskell.org/package/hackage-repo-tool-0.1.1.1 (HerbertValerioRiedel)
12:31:28 <AWizzArd> fendor: you can implicitly have udp I think, with a certain socket type.
12:32:19 <kashmir> just want to say, haskell is amazing (i love the recursion), but very hard at the same time but it's beatiful how (again) the recursion works. i know a little of it (so i think) but so far its very exciting when (sometimes after a time of thinking) i succeed to do a recursive function that do a little thing.
12:32:23 <AWizzArd> fendor: when you use the epgm protocoll instead of tcp. For some sockets that’s fine, I think pub/sub. If you want to have tens of thousands of clients, or hundreds of thousands and don’t mind to lose messages.
12:32:52 <fendor> AWizzArd, it should be a fast paced game so theoretically it should be fine
12:33:44 <AWizzArd> fendor: I suggest you read the ZMQ guide. It has tons of Haskell code examples. You basically need only the first 3-4 chapters to understand it well. Will take just a couple of hours. It’s a very nice networking technology.
12:34:02 <fendor> AWizzArd, nice, thx!
12:36:52 <fendor> however, still interested in a game engine library where I can integrate some way of internet communication
12:36:54 <sternmull> is there a way to make this work: http://lpaste.net/364045 I want to have a "fallback" in my fmap implementation that just returns the original element for a bunch of constructors.
12:38:06 <sternmull> i think i would need the type parameter of the Functor instance to get rid of the error... but i don't know how to get it.
12:38:23 <Dynasty> fendor: How serious is your game project? Is it just a toy? Because imo Haskell is not a suitable language for most game projects
12:38:46 <fendor> Dynasty, toy project for university
12:40:01 <lyxia> sternmull: how about refactoring the constant constructors into a separate type
12:42:12 <sternmull> lyxia: I thought about that. But i hoped i could make it work without changing my types just to make this fmap implementation shorter.
12:43:27 <sternmull> i could just add all the constructors... but this just feels like unnecessary repetition. Is there no way to use type constraints or something to capture the type parameter of Functor?
12:48:16 <lyxia> I don't think so.
12:49:21 <lyxia> sternmull: do you know you can derive Functor?
12:49:22 <sternmull> ok, i give up and use your suggestion.
12:49:46 <sternmull> i can? And can i still handle some of the constructors?
12:50:22 <lyxia> why do you want to handle some of the constructors?
12:51:41 <sternmull> i would use automagical generated functor implementation. But will it also work when some of my fields are lists and other types (indirect recursive AST nodes).
12:52:00 <lyxia> There is only one lawful instance when it exists, and it can be derived with the DeriveFunctor extension.
12:52:14 <knup> So, a new release of type-of-html. Thanks to weigh it's now ~25% faster, about 10x faster than blaze.
12:52:22 <lyxia> If your type is weird enough that GHC can't handle it, I'd like to see it.
12:54:48 <sternmull> there are constructors like "data ExprF expr = Let [Def expr] expr | ..."
12:56:09 <lyxia> that's no problem as far as I can tell.
12:58:00 <sternmull> yes, i found the wiki page that explains the algorithm. At first sight it looks like it will work the way i need it.
12:59:24 <jle`> sternmull: if youre unsure, you can just try it
12:59:30 <jle`> by adding it to your code
12:59:48 <sternmull> i am doing it right now.
13:03:26 * hackage easytest 0.1.1 - Simple, expressive testing library  https://hackage.haskell.org/package/easytest-0.1.1 (joelb)
13:03:56 * hackage uniprot-kb 0.1.0.0 - UniProt-KB format parser  https://hackage.haskell.org/package/uniprot-kb-0.1.0.0 (zmactep)
13:09:36 <jle`> is there a good reason why 'show' for () should be strict?
13:09:50 <sternmull> hm, next problem: I use megaparsec and want to remember the position range of my tokens. At the moment i use Lexer.Symbol and others that consume the whitespace that comes after them. So i don't have the end-position before the trailing whitespace. Is there an easy way to get sensible end positions?
13:09:59 <mniip> it is strict for pretty much everything else
13:10:41 <mniip> I guess you could pull a funny and make  show x = '(':(x `seq` ")")
13:10:45 <jle`> is that behavior that people rely on?
13:11:01 <jle`> right now show () = "()"
13:11:06 <jle`> but it could be show _ = "()"
13:11:24 <jle`> mniip: that's cute
13:11:53 <mniip> actually no
13:11:55 <jle`> only asking because i'm making a type that is isomorphic to () and was wondering how its instances should behavve w.r.t. strictness
13:12:05 <mniip> show (undefined :: (a, b)) doesn't produce any output
13:12:34 <jle`> > show (undefined :: (Int, Bool))
13:12:37 <lambdabot>  "*Exception: Prelude.undefined
13:12:43 <jle`> > show (undefined :: Int, undefined :: Bool)
13:12:45 <lambdabot>  "(*Exception: Prelude.undefined
13:13:16 <jle`> this just shows that show for (,) is also strict?
13:13:35 <jle`> but in this case it has to be
13:13:40 <jle`> there is no alternative
13:13:52 <jle`> oh, i see what you mean
13:13:56 * hackage lz4-conduit 0.3 - LZ4 compression for conduits  https://hackage.haskell.org/package/lz4-conduit-0.3 (scm)
13:13:58 <lyxia> I don't think there's a good reason.
13:14:15 <jle`> it could be show xy = concat ["(", show (fst x), ",", show (snd x), ")"], or something similar
13:14:44 <jle`> @let showTup xy = concat ["(", show (fst xy), ",", show (snd xy), ")"]
13:14:46 <lambdabot>  Defined.
13:14:53 <jle`> > showTup (undefined :: (Int, Bool))
13:14:56 <lambdabot>  "(*Exception: Prelude.undefined
13:27:56 * hackage hlrdb-core 0.1.1.0 - High-level Redis Database Core API  https://hackage.haskell.org/package/hlrdb-core-0.1.1.0 (identicalsnowflake)
13:39:19 <AWizzArd> I am looking at the docstring of Data.Map’s `splitLookup` function. It specifies it runtime complexity as: O(min(n,W)) – what do `n` and `W` stand for?
13:41:15 <hexagoxel> AWizzArd: see the IntMap docs: "Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of W -- the number of bits in an Int (32 or 64)."
13:41:52 <hexagoxel> (that note also belongs in the Map modules, i assume)
13:42:21 <AWizzArd> hexagoxel: well-spotted, thx.
13:44:08 <hexagoxel> AWizzArd: although i am a bit surprised if this complexity really applies to non-Int Map
13:45:24 <hexagoxel> where exactly did your "O(min(n,W))" come from?
13:45:44 <lyxia> The general Map just has log(n)
13:45:59 <hexagoxel> exactly, and that makes sense.
13:49:26 * hackage hlrdb 0.2.0.0 - High-level Redis Database  https://hackage.haskell.org/package/hlrdb-0.2.0.0 (identicalsnowflake)
13:56:56 * hackage dhall-to-cabal 1.0.0 - Compile Dhall expressions to Cabal files  https://hackage.haskell.org/package/dhall-to-cabal-1.0.0 (OliverCharles)
14:09:56 * hackage dhall-to-cabal 1.0.0.1 - Compile Dhall expressions to Cabal files  https://hackage.haskell.org/package/dhall-to-cabal-1.0.0.1 (OliverCharles)
14:14:26 * hackage backprop 0.1.4.0 - Heterogeneous automatic differentation (backpropagation)  https://hackage.haskell.org/package/backprop-0.1.4.0 (jle)
14:31:26 <mdim> Hi everyone! Can someone tell me what is wrong with the definition of the inner function runSlaves? http://paste.debian.net/1016624/ I keep on getting this error message: Variable not in scope: runSlaves :: Backend -> [NodeId] -> Process ()
14:37:56 * hackage shake-ext 2.7.0.5 - Helper functions for linting with shake  https://hackage.haskell.org/package/shake-ext-2.7.0.5 (vmchale)
14:39:27 <sphalerite> I'm using Control.Applicative.Combinators.NonEmpty.sepBy1 to parse multiple instances of a thing, but would like for the parser to still succeed if the string ends with a separator but that separator is not followed by the thing
14:40:33 <sphalerite> so for example I have `((NE.sepBy1 (P.char '!') (P.char ' ')) :: Parser (NonEmpty Char))`, which rejects "! ! a", but I'd like it to accept it, consuming only "! !"
14:41:04 <sphalerite> Any suggestions?
14:41:44 <sphalerite> do I need to write my own alternative sepBy which does backtracking on the separator?
14:42:38 <mdim> got it
14:46:35 <sphalerite> I've done this now, `sepBy2 p sep = (:|) <$> p <*> many (P.try (sep *> p))`; if there's an existing thing like this I'd be glad if someone could tell me where it is :)
14:47:09 <hexagoxel> sphalerite: maybe as reference, parsec has sepEndBy1
14:47:47 <sphalerite> hexagoxel: that's not what I'm looking for though — because it consumes the space before the a
14:50:53 <hexagoxel> ah, right.
14:53:26 * hackage shake-ats 1.5.0.11 - Utilities for building ATS projects with shake  https://hackage.haskell.org/package/shake-ats-1.5.0.11 (vmchale)
14:56:26 * hackage ats-pkg 2.8.0.0 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-2.8.0.0 (vmchale)
15:06:22 <medchawkicheikh> help
15:21:56 * hackage tinylog 0.14.1 - Simplistic logging using fast-logger.  https://hackage.haskell.org/package/tinylog-0.14.1 (ToralfWittner)
15:26:44 <dfeuer> carter: what do you think of https://github.com/haskell/primitive/pull/109 ? Any intuition regarding my question?
15:34:23 <Average-user> I need to do a parser from strings to this  http://lpaste.net/364046, con someone give me a hand?
15:43:34 <sm> Average-user: megaparsec has helpers and a tutorial on parsing boolean expressions
15:43:41 <sm> s/boolean//
15:44:07 <c9c3> Average-user: You could use Text.Parsec.Expr as well..
15:46:46 <Profpatsch> Is there documentation on what the BlockArguments extension does?
15:46:59 <Profpatsch> Apart from appearing in the Pragma History page? https://ghc.haskell.org/trac/ghc/wiki/LanguagePragmaHistory
15:47:41 <Average-user> c9c3: Looks interesting, do you know where can I find  an example?
15:47:57 <Average-user> c9c3: Someone that has implemented that in something similar
15:49:56 * hackage fast-arithmetic 0.3.3.3 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.3.3.3 (vmchale)
15:50:56 * hackage graphite 0.9.7.0 - Graphs and networks library  https://hackage.haskell.org/package/graphite-0.9.7.0 (DanielCampoverde)
15:51:46 <c9c3> Average-user: The docs on hackage have an example which seems pretty explanatory, you basically just need to define an operator table and provide that one with an expression-parser.
16:00:22 <Average-user> c9c3: I can't get it compiling
16:04:22 <c9c3> Average-user: I have no idea why it won't compile. Do you have parsec installed?
16:05:39 <c9c3> Here's a simple example, seems to be doing what's expected: http://lpaste.net/4722382504059731968
16:06:10 <c9c3> Though probably you want to do some more work like ignoring spaces, parentheses etc.
16:10:49 <Average-user> c9c3: Ok, thanks
16:11:17 <c9c3> No worries, is it working now?
16:12:55 <Average-user> c9c3: yes
16:13:29 <Average-user> c9c3: another question, if you dont mind. The recursive work with the parentheses Is up to me right?
16:14:33 <c9c3> It seems like it ;)
16:17:34 <Average-user> fair enough
16:18:25 <dfeuer> dolio: ping
16:19:35 <carter> dfeuer: I’ll look this evening or sometime tomorrow.  Thx for the heads up!
16:20:25 <dfeuer> carter: OK.
16:22:32 <AWizzArd> A Data.Sequence seems to be very similar to Clojure’s vectors.
16:23:11 <Average-user> AWizzArd: not really
16:23:28 <AWizzArd> Average-user: can you point out a few differences?
16:23:58 <AWizzArd> Both seem to be tree-based and have comparable lookup complexity. The Data.Sequence seems to support some more useful functions.
16:26:47 <lyxia> Profpatsch: https://github.com/ghc-proposals/ghc-proposals/pull/90
16:26:57 <c9c3> Uuh, why does Data.Sequence use (><) instead of (<>)?
16:28:17 <AWizzArd> c9c3: it even seems that it does also support (<>) because it is a Semigroup.
16:29:15 <Average-user> AWizzArd: Sequences are implemented with fingertrees, thats not the case with clojure vectors
16:30:26 <AWizzArd> c9c3: I see in the code that:   (<>) = (><)
16:31:32 <c9c3> AWizzArd: Yeah indeed, same with mappend..
16:31:37 <AWizzArd> Average-user: yes okay that is an implementation detail. From a semantical point of view it seems very similar though, and also the complexity often seems comparable.
16:41:25 <Profpatsch> lyxia: thx for link
16:41:52 <Profpatsch> Ah, it’s that syntax extension that allows to remove one whopping $?
16:42:29 <Profpatsch> The most progressive thing GHC has done since time immemorial.
16:42:56 * hackage hackage-security 0.5.3.0 - Hackage security library  https://hackage.haskell.org/package/hackage-security-0.5.3.0 (HerbertValerioRiedel)
16:43:01 <hpc> my favorite extension is MagicHash
16:43:09 <Profpatsch> Next we know subclass definition turns the arrow around.
16:43:11 <hpc> it changes the character '#' from being something you can use in identifier
16:43:14 <hpc> s
16:43:18 <hpc> to something you can use in identifiers
16:43:37 <Profpatsch> That would be truly bold! Adventurous!
16:46:24 <sm> has anyone got an example of a conditional test suite in a package.yaml ?
16:48:06 <sm> I've tried https://hastebin.com/hajofoxupi.bash
16:50:57 <sm> https://hastebin.com/otuhuhozet.bash I guess
16:51:44 <sm> no, that did not disable it
16:58:53 <Average-user> since when Data.Either does not export fromRight?
17:00:34 <lyxia> until 4.10
17:00:45 <lyxia> https://hackage.haskell.org/package/base-4.11.0.0/docs/Data-Either.html#v:fromRight
17:01:54 <Average-user> λ> :m Data.Either
17:01:55 <Average-user> λ> :t fromRight
17:01:55 <Average-user> <interactive>:1:1: error: Variable not in scope: fromRight
17:01:55 <Average-user> λ>
17:02:33 <lyxia> your GHC is probably too old
17:06:09 <Average-user> 8.0.1
17:07:00 <lyxia> that's base 4.9
17:13:22 <jle`> is there any particular reason why there's no Storable instance for tuples in base
17:13:55 <davean> jle`: what would that be?
17:14:47 <jle`> are these sound? https://hackage.haskell.org/package/storable-tuple-0.0.3.3/docs/Foreign-Storable-Tuple.html
17:14:50 <lyxia> jle`: https://mail.haskell.org/pipermail/libraries/2017-December/028352.html I knew I had seen that question recently
17:15:14 <jle`> i guess that is built on https://hackage.haskell.org/package/storable-record-0.0.3.1
17:15:33 <davean> jle`: well, I mean, storable is about marshelling - it doesn't seem to me there is one clear, unique, correct marshelling for a tuple
17:15:34 <jle`> hm, i see
17:15:52 <jle`> you can define an instance that 'works', but it might not make sense to have one in the first place
17:16:37 <jackdk> this argument, applied to classes FromJSON and ToJSON has made me more sympathetic to just writing encode/decode functions instead of using typeclasses
17:16:48 <davean> and "correct" might vary based on what it contains
17:17:07 <davean> due to alignment
17:17:10 <davean> etc
17:19:02 <jle`> i need the instance to use this function http://hackage.haskell.org/package/hmatrix-0.18.2.0/docs/Numeric-LinearAlgebra-Devel.html#v:unzipVector
17:19:10 <jle`> but now that i realize this, i'm not sure why this function even exists
17:19:30 <jle`> it's actually never used anywhere in the library's source
17:20:06 <dibblego> @type (^? _Right)
17:20:07 <lambdabot> Either c b -> Maybe b
17:20:11 --- mode: dibblego set -o dibblego
17:21:07 <jle`> :t preview _Right
17:21:09 <lambdabot> MonadReader (Either c b) m => m (Maybe b)
17:21:26 <jle`> :t (preview _Right $)
17:21:28 <lambdabot> Either c b -> Maybe b
17:22:21 <jle`> yeah i wonder what is up with unzipVector from hmatrix, it's defined but the type signature appears kind of shady, and it is never used in the library internally
17:22:31 <jle`> it might be a mistake or just there for backwards compatibility
17:23:38 <fr33domlover> Given f :: Text -> TExpQ; and [||Proxy :: Proxy ?||] how do I make `f x` insert 'x' in place of the '?' to choose the type there?
17:24:06 <fr33domlover> I tried [||Proxy :: Proxy x||] but then x alwals ends up as GHC.Types.Any
17:24:32 <fr33domlover> Rather than the actual type named by the value of x, e.g. "Int"
17:25:36 <fr33domlover> > $$((\x -> [[| Proxy :: Proxy x |]]) "Int")
17:25:40 <lambdabot>  <hint>:1:1: error: parse error on input ‘$$’
17:25:56 <fr33domlover> > $((\x -> [| Proxy :: Proxy x |]) "Int")
17:25:58 <lambdabot>  <hint>:1:1: error:
17:25:58 <lambdabot>      parse error on input ‘$’
17:25:58 <lambdabot>      Perhaps you intended to use TemplateHaskell
17:26:05 <fr33domlover> Yes I did ^_^
17:29:31 <fr33domlover> When I try this in GHCI, I get: (Proxy :: Proxy GHC.Types.Any)
17:29:51 <fr33domlover> How do I get (Proxy :: Proxy Int) there when I pass "Int" as x?
17:34:17 <lyxia> Note that the x in the quote is not at all the x bound by the lambda.
17:34:53 <lyxia> do you have to take text?
17:35:14 <lyxia> and is it always a single type constructor?
17:35:28 <lyxia> As opposed to, say, "Maybe Int"
17:36:54 <fr33domlover> lyxia, yes it's always single constructor, how do I insert it in there?
17:38:49 <lyxia> Given a String you can construct a Name and then a Type from that, but I'm still not convinced passing a String or a Text is what you actually want
17:39:36 <lyxia> How does this look  $((\x -> [| Proxy :: Proxy $x |]) [t|Int|])
17:39:51 <fr33domlover> lyxia, the string comes from EDSL parsed at TH time
17:40:01 <fr33domlover> that's why it comes as Text (or String)
17:40:12 <lyxia> ok
17:40:53 <fr33domlover> lyxia, is this possible with typed TH?
17:41:14 <xandaros> I've tried $something in the past and was unable to bind actual values. Is this new? :O
17:41:17 <fr33domlover> (also, do I have a good reason to prefer typed TH?)
17:41:32 <xandaros> fr33domlover: mkName is probably your friend here
17:41:35 <lyxia> No since the type comes from the string and we don't have dependent types
17:41:54 <lyxia> xandaros++
17:42:07 <xandaros> ?
17:42:54 <lyxia> xandaros: I agree wth you.  I think it's always been possible to refer to metavariables in quotes.
17:43:17 <xandaros> Hmm, I must have been doing it wrong, then... this would significantly clean up my TH code
17:43:47 <xandaros> I'm not using any quasi-quotes at all. I use the AST constructors directly - it's a giant pain to work with
17:44:50 <lyxia> I also did that for a while.
17:45:18 <lyxia> quotes are so confusing at the beginning
17:46:01 <lyxia> Now I try to use GHC Generics for everything. Much more fun.
17:46:46 <xandaros> Hehe, yeah, Generics are great. I don't think I can use those, though - my TH stuff is very special-purpose
17:48:36 <lyxia> What kind of purpose, if you don't mind talking about it?
17:49:27 <xandaros> https://github.com/Xandaros/MinecraftCLI/blob/master/src/Network/Protocol/Minecraft/Packet.hs
17:49:30 <xandaros> This quasi-quoter
17:50:14 <xandaros> Creates the types, makes instances and generates at least one function. I forgot what exactly it does and I can't read my own TH code :P
17:50:18 <xandaros> https://github.com/Xandaros/MinecraftCLI/blob/master/src/Network/Protocol/Minecraft/Packet/TH.hs
17:58:35 <xandaros> lyxia: any comments?
17:59:02 <lyxia> xandaros: Could you paste the splices it generates for those types?
17:59:46 <lyxia> I was about to build it myself but it looks like there are dependencies only you have :)
18:00:56 <xandaros> lyxia: http://tcpst.net/2vmw
18:00:57 * hackage json-autotype 1.1.0 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-1.1.0 (MichalGajda)
18:01:20 <xandaros> lyxia: Oh yes! I need to commit my fix for that. Sorry :D
18:03:01 <xandaros> lyxia: If you wish - you should be able to build it now
18:06:09 <lyxia> thanks!
18:06:34 <lyxia> xandaros: I'll take a look and see if I can do something similar with generics
18:10:37 <xandaros> lol, knock yourself out. I don't think it's worth it, though. Especially since I see no way of creating CBPacket and SBPacket. And I really want to avoid any boilerplate there.
18:19:29 <lyxia> I see, you're generating lots of types from this, so the alternative would be more about dependently typed programming than generics.
18:21:55 <xandaros> lyxia: If you can find a way to condense all those types into 2 (CBPacket and SBPacket), I'd be very grateful. I've wanted to get rid of them, but kept them for type safety. (Well, and because the lenses would turn into prisms and become annoying :P)
18:26:17 <xandaros> I suppose you could have an enum-like type encoding which packet it is and use a type like "SBPacket Handshake". You could also have lenses for this, with instances like "HasProtocolVersion (SBPacket Handshake) VarInt". Hmm... might be worth thinking about
19:02:02 <koz_> Would someone be able to explain the purpose of the monad in gana here? https://www.stackage.org/haddock/lts-11.2/recursion-schemes-5.0.2/Data-Functor-Foldable.html#v:gana
19:02:23 <koz_> It seems to 'disappear' somewhere in the guts of gana, as the return type doesn't contain it.
19:02:32 <koz_> And thus, I'm a little unclear of what it's meant to do.
19:05:27 * hackage miso 0.16.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-0.16.0.0 (DavidJohnson)
19:06:38 <koz_> Oh, wait, I think I see it.
19:06:53 <koz_> It's to do with the distributive laws described below.
19:07:07 <koz_> However, that just changes the question to 'what's the deal with those distributive laws'?
19:29:56 * hackage classy-miso 0.0.0.2 - Typeclass based support for Miso, the Tasty Web Framework for Haskell.  https://hackage.haskell.org/package/classy-miso-0.0.0.2 (RobertFischer)
19:42:18 <koz_> Could anyone help me figure out this recursion scheme? My brain is just not making sense of what the typechecker is saying: http://lpaste.net/364051
19:43:58 <koz_> I _know_ traverse or sequence has to factor into this somewhere, but I'm not clear where, or exactly why.
20:22:37 <koz_> Never mind, I have it, but I still need to figure out _precisely_ why it typechecks.
20:44:05 <pikajude> why is the first field of GadtC a list of Names rather than a Name?
20:46:56 <MarcelineVQ> possibly   data Foo a where Gib, Geb, Gob :: Foo Int
20:47:28 <MarcelineVQ> Not tested this theory
20:47:54 <glguy> That's correct, though reify doesn't use that even when you originally wrote the datatype that way
21:02:26 * hackage hmatrix-backprop 0.1.1.0 - hmatrix operations lifted for backprop  https://hackage.haskell.org/package/hmatrix-backprop-0.1.1.0 (jle)
21:10:26 * hackage miso 0.17.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-0.17.0.0 (DavidJohnson)
21:20:09 <dfeuer> glguy: should I bolt anything else onto https://github.com/haskell/primitive/pull/109 ? Or take anything away?
21:20:19 <ghasshee> hi
21:27:38 <ghasshee> Hi, what I should do is ...
21:27:55 <ghasshee> 1. finish reading TaPL
21:28:45 <ghasshee> 2. finish reading AoP
21:29:11 <ghasshee> 3. write Haskell in the way what Haskell has in its power.
21:29:30 <rotaerk> why're you telling the channel what you should do? o_O
21:29:46 <ghasshee> Oh, sorry.
21:30:01 <ghasshee> I am just self motivating
21:30:16 <ghasshee> Always I did my study alone.
21:30:19 <ghasshee> quite alone
21:30:51 <ghasshee> But it was enough for me.
21:32:41 <xandaros> We finally have a readMaybe in base? Mind blown
21:32:42 <ghasshee> I should also say using haskell cannot be alone.
21:33:48 <xandaros> Looks like it's been around for ages, actually. How have I never seen this?
21:35:53 <texasmynsted> what is TaPL and AoP?
21:36:34 <ghasshee> TaPL is 'Types and Programming Languages'
21:36:51 <ghasshee> AoP is 'Algebra of Programming'
21:37:10 <ghasshee> Both are written by Great Professors.
21:37:45 <texasmynsted> oh nice
21:37:51 <texasmynsted> I do not think I have read them.
21:38:02 <texasmynsted> They sound like text books heh
21:38:18 <ghasshee> I did not finish reading both of them .. it is quite basical readings.
21:38:21 <ghasshee> yes
21:39:36 <ghasshee> I have entered this internet world just 4 years ago.
21:39:53 <ghasshee> I am just a 4 years old child.
21:41:04 <ghasshee> There was a plenty of technologies, tons of papers I should read .. especially , algebra, category theory, groups, cryptography, algorithms, codes ,, you know well.
21:41:54 <ghasshee> blockchain, deeplearning, quantum algorithms, quantum annealings...
21:42:07 <texasmynsted> Looks like you might be a bit older than 4 by the time you finish both of these.
21:43:14 <ghasshee> I hope so :)
21:44:19 <MarcelineVQ> texasmynsted: it's pretty worthwhile to read tapl
21:46:15 <texasmynsted> hm ok
21:47:45 <texasmynsted> Not to sound like a dunce but what will it do for me?
21:50:38 <jchia> How do I convert Double to Float? I couldn't find any built-in way.
21:51:00 <ghasshee> texasmynsted: it will gives you how functional programming works and how simple compiler works
21:51:20 <MarcelineVQ> texasmynsted: you can read a synopsis online but it's likely to teach you the things about types no one has told you yet
21:52:10 <MarcelineVQ> what those things are for you in particular I can't say
21:53:10 <MarcelineVQ> jchia: realToFrac
21:56:01 <texasmynsted> ok this has my interest
21:56:06 <texasmynsted> :-)
21:58:27 <jchia> MarcelineVQ: OK. Somehow Double and Float have no Num instance in my local haddock
22:02:38 <texasmynsted> Nice thank you
22:13:17 --- mode: quicksilver set -o quicksilver
22:31:48 <koz_> There's a Bifunctor, and a Biapplicative; is there a Bimonad to go with them?
22:36:56 * hackage hw-fingertree-strict 0.1.0.3 - Generic strict finger-tree structure  https://hackage.haskell.org/package/hw-fingertree-strict-0.1.0.3 (newhoggy)
22:43:56 * hackage drinkery 0.3 - Boozy streaming library  https://hackage.haskell.org/package/drinkery-0.3 (FumiakiKinoshita)
22:53:32 <vaibhavsagar> koz_: https://stackoverflow.com/a/13568897/2896874
22:54:27 <koz_> vaibhavsagar: Thanks - and thanks for drawing my attention to relative monads.
22:54:55 <vaibhavsagar> my pleasure!
22:55:27 <vaibhavsagar> I'd also never heard of relative monads before
22:56:37 <johnw> neat, I'll have to read up on those too
23:30:17 <mjrosenb> well, today I got to write "zipWith uncurry"
23:30:21 <mjrosenb> it felt unorthodox.
23:30:36 <mjrosenb> err, not unorthodox
23:30:38 <mjrosenb> uncouth
23:30:51 <mjrosenb> possibly also unorthodox, that isn't really for me to decide.
23:42:05 <Axman6> :t zipWith uncurry
23:42:07 <lambdabot> [a -> b -> c] -> [(a, b)] -> [c]
23:47:43 <robstr> is it possible to import a type without it's instances ?
23:48:49 <cocreature> robstr: no, you should think of instances as being global things that you can’t explicitely hide
23:49:04 <cocreature> (which holds if you don’t consider orphan instances)
23:49:48 <robstr> cocreature: hm i see, ty
23:50:25 <cocreature> robstr: if you don’t want an instance for some type or want to change an existing instance, make a newtype
23:52:25 <robstr> I'm fetching data from few different api's as json, I have one database representation type and now i need two FromJSON instances because the format is fundamentally different. I bet i should have create a special type and a converter class, right ? :P
23:54:58 <cocreature> no need for a separate converter class. just make two newtypes for your type that implement the different FromJSON instances
23:57:20 <robstr> cocreature: right
