00:03:17 <`Guest00000> also, another idea, which is admittedly more cryptic, but:   fix f = x = f x
00:03:47 <`Guest00000> generally "letPattern = expr" in the place of an expression stands for "let letPattern = expr in letPattern"
00:04:39 <`Guest00000> maybe this one indeed won't get many followers
00:05:45 <mjrosenb> c_wraith: danke.
00:46:08 <pepegar> Hello! is there a function already defined that converts between two Monoid types by mapping mempty s and using a lambda function in case of non empty?
00:46:31 <pepegar> I mean something with this signature `(Monoid a, Monoid b) => a -> (a -> b) -> b`
00:46:39 <pepegar> (or similar, of course)
00:47:09 <pepegar> My hoogle skills are not good enough to find it, in case it exists :)
00:48:52 <cocreature> pepegar: it seems like that would at least require an "Eq" constraint on "a"
00:49:22 <pepegar> You're right!
00:49:39 <cocreature> that said I don’t know of any existing function for this
00:50:06 <pepegar> OK, thank you cocreature !
00:51:13 <`Guest00000> i think pepegar's request is imprecise
00:51:32 <cocreature> it also seems kind of weird, assuming your a -> b function is not partial it needs to be defined for a = mempty anyway, so why not just use the lambda directly
00:52:57 <`Guest00000> pepegar: can you explain better what you want this function to do?
00:53:16 <`Guest00000> it's not clear how can such function map "mempty"
00:53:27 <pepegar> Yep, sorry!
00:54:15 <cocreature> sounds like "foobar x f = if x == mempty then mempty else f x"
00:54:15 <`Guest00000> mempty is just mempty and abstract
00:54:28 <`Guest00000> maybe you need Traversable?
00:54:32 <`Guest00000> or at least Alternative
00:54:43 <`Guest00000> cocreature: it vaguely sounds like Traversable
00:54:44 <pepegar> cocreature: that's exactly it
00:55:13 <cocreature> pepegar: do you have some example of what you want to use this for?
00:55:42 <pepegar> yes, i'll try to haskellify it! (I was using Scala for it)
00:57:55 <Cale> pepegar: Are you sure that one of your monoids is not really something more specific? While it's not totally unreasonable to send mempty to mempty and then apply some arbitrary function otherwise, it sounds like the wrong thing to do in a lot of cases.
00:58:26 <`Guest00000> wait, no, maybe i mean Foldable
00:58:51 <pepegar> I have this datatype Uri
00:58:52 <pepegar>  
00:58:52 <pepegar> data Uri = Uri {
00:58:52 <pepegar> path :: Maybe String,
00:58:55 <pepegar> host :: Maybe Host
00:58:59 <pepegar> ... -- more Maybe x parts
00:59:00 <pepegar> } deriving Show, Eq
00:59:03 <pepegar>  
00:59:06 <pepegar> And, I want to render it as a String, so I've end up implementing a lot of functions Maybe a -> String,
00:59:08 <cocreature> please use some pastebin for multiline code
00:59:15 <pepegar> Ah sorry
00:59:28 <cocreature> :t maybe
00:59:29 <lambdabot> b -> (a -> b) -> Maybe a -> b
00:59:34 <cocreature> is this what you’re looking for?
00:59:41 <pepegar> hm...
00:59:47 <cocreature> or rather "maybe mempty"
00:59:50 <cocreature> :t maybe mempty
00:59:51 <Cale> :t fromMaybe ""
00:59:52 <lambdabot> Maybe [Char] -> [Char]
00:59:53 <lambdabot> Monoid b => (a -> b) -> Maybe a -> b
01:00:25 <`Guest00000> which is foldMap
01:00:36 <pepegar> Cale: I think that's what I think...
01:00:42 <`Guest00000> - fromMaybe ""
01:01:02 <cocreature> right, foldMap is even better
01:01:16 <pepegar> awesome! thank you all!
01:01:20 <Cale> tbh I would usually just pattern match
01:01:21 <Cale> :P
01:01:33 <pepegar> :D
01:01:44 <Cale> But yeah, if you're doing it a lot, it's annoying
01:01:45 <cocreature> pattern matching is severly underrated :)
01:05:22 <dminuoso> When is the composition of two monads a monad itself?
01:06:08 <dminuoso> (And is every monad composed with itself necessarily a monad?)
01:06:09 <Cale> The composite N . M is a monad when there exists a distributive law M . N -> N . M
01:06:22 <Cale> which must satisfy some conditions
01:06:44 <Cale> https://en.wikipedia.org/wiki/Distributive_law_between_monads
01:07:03 <dminuoso> Cale: Ah that looks approachable. Thank you.
01:07:54 <Cale> The idea is that in order to define join, you need a way to straighten out the middle MN so you can go NMNM -> NNMM and then use join for N and M individually
01:08:14 <cocreature> iirc Traversable and its laws are sufficient for that
01:10:41 <dminuoso> Cale: Judging from the diagrams in that article, it seems that every monad composed with itself yields a monad in return.
01:11:12 <Cale> sure
01:11:51 <Cale> er, hmm
01:12:21 <Cale> need to be careful
01:12:31 <Cale> Consider, say, the list monad for concreteness
01:12:48 <Cale> If we're thinking that the distributive law is just the identity
01:13:05 <Cale> then the triangle in the upper right won't hold
01:13:09 <dminuoso> Heh, yeah I just realized that the identity natural transformation is definitely not enough.
01:13:28 <dminuoso> So I guess a monad composed with itself might not produce a monad after all.
01:13:55 <Cale> because T η_T [1,2,3] = [[1],[2],[3]], but η_T T [1,2,3] = [[1,2,3]]
01:14:01 <Cale> yeah
01:14:23 <Cale> btw, the rationale for this name comes from a very special case
01:14:45 <Cale> If we have the monad whose algebras are commutative monoids, that is the monoid of "bags" or "unordered lists"
01:15:15 <Cale> and we compose it with the monad whose algebras are monoids, that is, the list monad
01:15:34 <Cale> we might hope to somehow obtain the monad whose algebras are rings
01:16:01 <Cale> but in order to define how the multiplication works, we need to say something extra
01:16:37 <Cale> in particular, we need to say how a "product" (monoid) of "sums" (commutative monoid) becomes a sum of products
01:16:41 <Cale> i.e. distributivity
01:18:32 <Cale> We don't often think about the algebras of our monads in Haskell though, so that doesn't tend to be all that helpful of an intuition :)
01:19:34 <Cale> also, usually the solution to composing together functionality to obtain monads has just been to instead work with functions (at the type level) which send monads to other monads, and then compose those
01:19:52 <Cale> So we just sidestep the entire question
01:21:19 <Cale> In a funny way, it is similar to the "shows" trick :D
01:21:56 <dminuoso> Cale: ^- when Im not responding, it's because Im silently taking note of this conversation, preparing to reread it in more depth once I know what an algebra actually is.
01:22:01 <Cale> Where rather than trying to concatenate lists (in O(n)), we instead work with functions [a] -> [a] which add elements to the beginning of any list, and compose those together (in constant time)
01:22:31 <`Guest00000> need bookmarks in IRC logs
01:24:01 <Cale> I've been thinking about making a new chat service which would be fundamentally different from most things which exist because all the chat which has happened immediately becomes a wiki
01:24:20 <`Guest00000> yay
01:24:22 <Cale> and then we can organise it into separate pages
01:24:44 <`Guest00000> is it tree-like?
01:24:56 <Cale> Graph-like, I guess
01:25:06 <`Guest00000> DAG-like
01:25:14 <`Guest00000> heh
01:25:22 <Cale> Hard to prevent cycles
01:25:41 <`Guest00000> unless someone answers their future message or that answer
01:25:57 <Cale> Basically just a wiki except that it has a convenient way to append to any page
01:26:07 <`Guest00000> damn
01:26:16 <`Guest00000> i have some similar ideas too
01:26:17 <Cale> and things live-update
01:26:46 <Cale> This is how we used to use hawiki, before it became a mediawiki
01:26:56 <Cale> As soon as it became a mediawiki, it was dead
01:27:01 <Cale> People stopped using it to chat
01:27:40 <Cale> (not that it was all that great a UI for chatting, given that you have to refresh and check back)
01:28:10 <Cale> But it was one of the most effective forms of communication I've experienced
01:28:58 <`Guest00000> in the future we will have wonderful, fabulous everything
01:42:13 <ertes-w> hell
01:44:54 <`Guest00000> :t hell
01:44:55 <lambdabot> error:
01:44:56 <lambdabot>     • Variable not in scope: hell
01:44:56 <lambdabot>     • Perhaps you meant ‘tell’ (imported from Control.Monad.Writer)
01:46:27 <kuribas> is there a better way for 'join $ f <$> a <*> b' ?
01:48:09 <phadej> kuribas: ApplicativeDo ;)
01:48:17 <ertes-w> kuribas: liftA2 can sometimes help
01:48:19 <Cale> No need for ApplicativeDo
01:48:29 <Cale> that's a monad if join is being used
01:48:30 <ertes-w> join (liftA2 f a b)
01:48:35 <dminuoso> kuribas: (join . liftA2) f a b
01:48:39 <dminuoso> Or.. ah.
01:48:41 <kuribas> But I want to get rid of the join...
01:48:49 <Cale> You could just use do-notation
01:48:52 <phadej> Cale: it is, but it would desugar to the same code
01:48:53 <Cale> I would.
01:48:59 <ertes-w> kuribas: you need either 'join' or (>>=)
01:49:05 <ertes-w> this is monadic
01:49:33 <kuribas> I suppose not then...
01:49:34 <kuribas> thanks
01:49:54 <ertes-w> kuribas: of course you could just use do-notation
01:50:05 <ertes-w> > do x <- a; y <- b; f x y
01:50:07 <lambdabot>  error:
01:50:07 <lambdabot>      • Couldn't match expected type ‘m ()’ with actual type ‘Expr’
01:50:07 <lambdabot>      • In a stmt of a 'do' block: x <- a
01:50:21 <kuribas> is that cleaner?
01:50:39 <dminuoso> Why does GHC use this weird do notation, where every line starts with ; ?
01:50:45 <ertes-w> kuribas: depends…  is there any benefit in naming 'x' and 'y'?
01:50:46 <Cale> Of course, you could also write  (f =<< a) =<< b
01:50:49 <Cale> if you prefer that
01:51:09 <Cale> Though it's different
01:51:18 <Cale> because b will execute first
01:51:43 <kuribas> ertes-w: nope
01:51:53 <ertes-w> Cale: that looks like a type error to me
01:52:03 <Cale> er, no, it's very different, I'm being silly
01:52:07 <Cale> yeah
01:52:09 <`Guest00000> :t \f a b -> (f =<< a) =<< b
01:52:11 <lambdabot> Monad m => (a1 -> a2 -> m b) -> (a2 -> a1) -> m a2 -> m b
01:52:14 <Cale> yeah
01:52:18 <`Guest00000> ertes-w: that is not a type error.
01:52:35 <Cale> It's not a type error on its own, but it's a type error relative to the problem
01:52:37 <Cale> :)
01:52:51 <kuribas> I thought there would be neater expression, but there isn't apparently...
01:52:57 <ertes-w> `Guest00000: it will most likely be one given actual 'f', 'a' and 'b', because the (>>=)s are for different monads
01:53:07 <Cale> I would basically always use do-notation for this
01:54:04 <ertes-w> kuribas: i think using 'join' is totally fine there
01:54:12 <`Guest00000> do y <- b; (do x <- a; f x) y
01:54:15 <Cale> There's no point figuring out some fiddly shenanigans and just annoying the next person to have to read the code.
01:54:40 <ertes-w> kuribas: it's a fairly transparent case of 'join'
01:54:51 <kuribas> ertes-w, Cale: yeah
01:54:54 <Cale> Even so, the do-syntax is clearer
01:55:07 <Cale> and makes it more obvious what order the effects occur in
01:55:44 <kuribas> Cale: it looks pretty obvious with <*> also...
01:56:05 <ertes-w> i think both are clear, and i have used that style before, because i didn't want to name the intermediates
02:00:10 <ertes-w> ultimately it depends on your values:  how much do you value consistency relative to conciseness?  i have a slight bias towards the latter…  if you lean more towards the former, you'll prefer the more verbose 'do' version
02:04:13 <MarcelineVQ> f !a !b     :(
02:07:05 <Cale> I usually care more about what I'll have to do when editing the code later.
02:08:20 <Cale> That's the same reason I usually prefer a case expression to using maybe
02:08:48 <Cale> unless it's really obvious that I'm never going to have to unfold it
02:14:20 <guest__> I am new to haskell, came across this symbol when reading some codes, what is  >>=  and <$> this symbol means in haskell?
02:15:21 <dminuoso> guest__: they are just infix functions
02:15:58 <dminuoso> guest__: <$> is infix for fmap, and (>>=) is monadic bind
02:16:00 <guest__> dminuoso: which one  >>= or <$>?
02:16:07 <dminuoso> guest__: Both.
02:16:09 <dminuoso> :t (<$>)
02:16:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:16:12 <dminuoso> :t (>>=)
02:16:13 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:16:28 <guest__> dminuoso : what are there use ?
02:16:49 <dminuoso> guest__: <$> is just infix `fmap`, and >>= is.. well.
02:17:14 <dminuoso> >>= lets you construct monadic computations
02:18:46 * Hyni ne chat me djem te bukur KLIKONI http://beratilive.com
02:31:45 <sepakorayl> is there any trick that makes it possible to write inductive typeclass instances like: instance (AsA e) => instance (AsC e). instance (AsB e) => instance (AsC e)
02:32:01 <sepakorayl> say with type witnesses or something?
02:32:34 <ertes-w> sepakorayl: instance (AsA e) => AsC e  -- this works *technically*, but in most cases it's not a good idea
02:33:05 <kuribas> is it possible to create a lens with generics?  Or do you require template haskell?
02:33:37 <ertes-w> sepakorayl: if you have both, then it generally doesn't work…  you should use newtype wrappers in this case (and really also in the former case)
02:33:48 <Gurkenglas> kuribas, https://hackage.haskell.org/package/generic-lens
02:33:56 <dminuoso> Mmm, doesn't constraints allow this?
02:34:21 <ertes-w> dminuoso: instance resolution only uses the RHS shape
02:34:38 <kuribas> Gurkenglas: lens-sop looks more like what I'm after...
02:34:43 <ertes-w> dminuoso: instance (C a) => D a  -- this is an instance for *all* types
02:35:15 <ertes-w> therefore (instance (C2 a) => D a) is overlapping with it
02:42:47 <guessWho> how to run ghc-pkg check with stack
02:43:50 <tsahyt> try stack exec ghc-pkg -- check
02:48:21 <BernhardPosselt> lets say you have a nested map operation (e.g. convert a user and his address to a new record)
02:48:53 <BernhardPosselt> is there a neat way to keep the mapping operation pure if i have to ask the database in between for the users address
02:52:04 <sepakorayl> ertes-w: I am trying to reduce the first boilerplate http://lpaste.net/363450
02:53:03 <sepakorayl> it would be awesome if i could somehow specify the error hierarchy seperately so I don't have to transform the errors in the transformations
02:53:35 <BernhardPosselt> or a better example: you've got a list of products and some images for each product, but I've only got the image ids and i need to query an Index for the actual URL andn resolution
02:55:31 <cocreature> BernhardPosselt: maybe make your function take something of type (ImageID -> m URL) and the return your result in "m"?
02:55:45 <ertes-w> BernhardPosselt: in general 'traverse' is "fmap with effects"
02:56:38 <BernhardPosselt> right, but that will make my stuff impure, wont it?
02:56:55 <ertes-w> BernhardPosselt: what does "impure" mean?
02:57:19 <BernhardPosselt> monads all the way down
02:57:35 <dminuoso> BernhardPosselt: no.
02:57:38 <tdammers> depends on your frame of reference, but for most reasonable definitions of "pure", no, it will not make your code impure
02:57:41 <tdammers> monads aren't impure
02:57:44 <dminuoso> BernhardPosselt: The notion of "purity" does not mean you cant have effects in your program.
02:57:51 <dminuoso> BernhardPosselt: It just means that the way you represent effects is pure.
02:57:52 <BernhardPosselt> right my bad :)
02:58:24 <cocreature> BernhardPosselt: it might be helpful if you show us an example of what you’re trying to do.
02:58:57 <cocreature> in general, if your function does some kind of IO, then there is no way to avoid this but you can restrict the IO that it can do by being polymorphic in the monad
02:59:25 <dminuoso> @quote not.the.cake
02:59:25 <lambdabot> ski says: <ski> `getLine :: IO String' is a recipe for how to interact with the world to acquire a `String'  <ski> the recipe is not the cake
02:59:43 <BernhardPosselt> thank you :)
02:59:43 <dminuoso> BernhardPosselt: ^- in that sense a IO is a pure description of something effectful.
02:59:56 <ertes-w> BernhardPosselt: in any case 'traverse' and friends are the answer
03:00:12 <ertes-w> BernhardPosselt: (or a streaming framework in some cases)
03:00:26 <dminuoso> BernhardPosselt: (Since a recipe is just pure, it doesn't do anything on its own. The effect comes from doing something with the recipe)
03:00:34 <ertes-w> regardless, you will have some IO in there, if you want to fetch images
03:00:40 <ocramz> hullo all!
03:02:41 <dminuoso> What's the ascii approximation for "[type] X is isomorphic to [type] Y" ?
03:03:16 <cocreature> dminuoso: get yourself a unicode font
03:03:24 <dminuoso> Heh.
03:05:34 <dminuoso> cocreature: For the purpose of an IRC discussion, would you use ≅ in `Either () ≅ Maybe`, or some ASCII approximation or just english?
03:05:52 <cocreature> just english
03:06:13 <ertes-w> dminuoso: "U+2245"
03:07:43 <mniip> dminuoso, ~~?
03:08:17 <dminuoso> mniip: I've been using ~~~ based on someone who used it in here before, but haven't seen it frequently, so I wasn't sure.
03:10:25 <ertes-w> dminuoso: if you insist on ASCII, use whatever…  context is much more likely to reveal that you mean "isomorphic to" than the symbol itself
03:47:17 <kuribas> what happens when two modules export different instances for the same objects?
03:48:15 <lyxia> you'll get an error message when you use them
03:50:49 <kuribas> should I use Generics or template haskell to create instances?  Or is there a way to let the user choose?
03:51:11 <kuribas> Generics are portable, but TH is more performant.
03:51:51 <lyxia> The user can always choose to implement the instances themselves
03:52:53 <lyxia> ah I thought you meant the choice between automated instances and manual ones, not between Generics and TH
03:53:32 <lyxia> Generics can be as performant as TH
03:54:47 <lyxia> especially if the instance only just traverses the type once
03:55:01 <kuribas> lyxia: the ones I provide myself
03:56:35 <kuribas> indexing into a generic seems linear over the number of products, while it's constant with TH.
03:58:07 <lyxia> inlining takes care of that
04:00:54 <kuribas> I am not sure...
04:01:06 <kuribas> TH fromJSON is twice as fast.
04:06:58 <lyxia> Right, aeson needs to be optimized
04:08:09 <sepakorayl_> is there any way to automatically derive Monoid instance for a record of monoids?
04:08:14 <kuribas> lyxia: so you are saying it's just bad code?
04:08:34 <sepakorayl_> using a tuple wrapper only works for tuples of lte 5 elements
04:09:00 <sepakorayl_> and Semigroup isntances *
04:09:01 <lyxia> kuribas: I wouldn't say that since I wrote some of it :P
04:09:15 <kuribas> lyxia: ah :)
04:09:24 <sepakorayl_> the derive package does not provide deriving semigroups only monoids
04:10:01 <kuribas> lyxia: I am writing a library to perform json-patches on arbitrary datatypes.
04:10:08 <lyxia> sepakorayl_: there are generic instances in semigroups and in one-liner-instances
04:10:09 <kuribas> lyxia: I want to autogenerate the instances.
04:12:37 <kuribas> lyxia: so I need to map a string (for a record) or an int (for a non-record product type), into some sort of lens.
04:13:59 <sepakorayl_> GSemigroups are not applicatives are they ?
04:14:03 <kuribas> lyxia: in template haskell I can just do "case index of 0 -> ..; 1 -> ..."
04:14:20 <kuribas> lyxia: but that doesn't work with generics
04:14:54 <progfunhere> hello
04:15:08 <lyxia> sepakorayl_: nope but it's true that they are close
04:15:53 <lyxia> sepakorayl_: in fact if there were Monoid or Applicative instances in GHC.Generics, we could also use that to derive Monoid
04:17:25 <lyxia> kuribas: right you have to jump through some hoops to work with Generics
04:17:50 <sepakorayl_> I really like The semigroup applicative though
04:18:21 <kuribas> lyxia: I can recurse down the product type list, but that means converting to and from the intermediate representaion.
04:18:31 <sepakorayl_> I guess I can stick to nested tuples?
04:18:52 <kuribas> lyxia: I don't see how ghc could inline/optimize that.
04:20:53 <lyxia> sepakorayl_: that's one way, yes
04:21:26 <sepakorayl_> with pattern synonyms perhaps
04:21:34 <lyxia> kuribas: it's not the same kind of recursion as going through a list, because the generic product is has a statically known size
04:23:17 <kuribas> lyxia: I could create a getter and a setter, and hope ghc will turn it into a vectorlike operation.
04:23:19 <lyxia> sepakorayl_: I'm not sure that's worth the boilerplate of pattern synonyms. By then you might as well define a proper record and handwrite the monoid instance...
04:25:20 <cocreature> sepakorayl_: I’m not sure I understand your question but the generic-deriving package has generic implementations of both Monoid and Semigroup
04:27:38 <lyxia> not quite, generic-deriving defines its own Monoid and Semigroup classes as a toy example.
04:28:10 <sepakorayl_> and the GSemigroups that generic-deriving provides is not applicative which I need
04:28:54 <cocreature> I’m not sure what it means for a typeclass to be Applicative
04:34:20 <sepakorayl_> sorry
04:34:43 <sepakorayl_> AccValidation is an applicative if the error is a semigroup
04:35:20 <sepakorayl_> which is why I need semigroup instances
04:36:42 <lyxia> sepakorayl_: well GSemigroups from semigroups and whatever one-liner-instances does do give you Semigroup instances
04:37:13 <cocreature> can’t you derive GSemigroup and then use instance Semigroup Foobar where (<>) = gsappend?
04:37:36 <cocreature> I’m not sure why generic-deriving has GSemigroup in the first place, that seems pretty weird
04:37:57 <cocreature> eh nvm, I’m stupid
04:38:13 <cocreature> I missed the gsappenddefault
04:39:49 <sepakorayl_> one-liner-instances should do it
04:40:08 <sepakorayl_> I don't thin GSemigroups from semigoups give semigroup instances
04:40:52 <lyxia> that's the whole point of it...
04:41:49 <lyxia> instance Semigroup MyType where (<>) = gmappend  <- uses GSemigroup
04:42:18 <kuribas> lyxia: do you think ghc will turn getting the nth element of a product type into a constant operation?
04:42:34 <sepakorayl_> ah my bad
04:42:48 <sepakorayl_> okay so I use those to make the instances
04:42:50 <sepakorayl_> okay cool
04:43:18 <sepakorayl_> I am very tired, it's like 5 am here, thans for the help
04:43:35 <cppxor2arr> kuribas: this
04:45:35 <lyxia> kuribas: Now that I think about it I'm not sure actually whether it can easily optimize that, or you would need to write the instance carefully to make it fast.
04:48:16 <kuribas> anyway, so my original question was if it is possible to let the user choose between instances generated by generic, or by TH.
04:49:15 <kuribas> or if I could detect when crosscompiling...
04:50:18 <kuribas> or if template haskell is available...
04:51:24 <`Guest00000> what's the most *mindless* way of writing parsers?
04:51:29 <`Guest00000> currently
04:51:39 <`Guest00000>  i want to mind it as less as possible
04:51:51 <`Guest00000> minimize distraction to it
04:51:53 <kuribas> `Guest00000: depends on the thing you are parsing
04:52:02 <`Guest00000> a simple language
04:52:09 <`Guest00000> Haskell-like
04:52:09 <lyxia> kuribas: if you want to let the user choose you can just give them both like aeson does
04:52:32 <kuribas> lyxia: I mean for pregenerated instances.
04:52:47 <kuribas> lyxia: that I don't want to write myself
04:53:17 <chisui> `Guest00000: Haskell is not that easy to parse. What aspects of Haskell does your language have?
04:53:22 <kuribas> lyxia: I suppose I could make it a preprocessor flag.
04:53:30 <lyxia> right
04:53:57 <Cale> `Guest00000: I dunno, something like Attoparsec?
04:54:10 <Cale> I'm not sure I'd call it mindless either, it's just good.
04:54:16 <`Guest00000> Cale: thanks, will check
04:54:35 <`Guest00000> just need to prototype
04:54:40 <cocreature> for parsing things produced by humans, e.g. programming languages, megaparsec seems more appropriate
05:07:44 <locallycompact> is there a way to curl json directly into a dhall type translation without going via haskell?
05:09:01 <simon> is Data.List.sort neat enough for sorting three elements? I can see that it isn't a hybrid linear sort for smaller lists like e.g. Java's.
05:14:28 <cocreature> simon: depends on whether you expect that to be your bottleneck. if you do then maybe it’s worth trying to test something else like eliminate the lists alltogether and handwrite the comparisons or something like that. I’d say for most applications it’s simply irrelevant
05:15:01 <simon> cocreature, so it's an early optimization to think about it. thanks.
05:17:20 <hpc> unless you're sorting millions or billions of triples, it doesn't really matter
05:18:50 <cocreature> and if you are sorting millions or billions of triples, chances are you’re better off trying to find a solution that avoids this instead of optimizing the sorting
05:34:00 <sepakorayl> okay here is the usual pattern: http://lpaste.net/363455
05:34:13 <sepakorayl> Is there any way to make the conversion implicit using typeclasses or something?
05:34:16 <sepakorayl> conversions*
05:36:45 <lyxia> sepakorayl: (I thought we were talking about this semigroup https://hackage.haskell.org/package/semigroups-0.18.4/docs/Data-Semigroup-Generic.html)
05:36:52 <lyxia> (GSemigroup)
05:40:17 <cocreature> tdammers: I’m not sure what exactly you want to make implicit. are you trying to eliminate tA, tB, and tC?
05:40:59 <sepakorayl> no I am trying to eliminate the withXtoDErr
05:41:15 <sepakorayl> I thought I could make a transformation hierrchy
05:41:36 <lyxia> sepakorayl: How about "tA :: (Monad m, HasAErr e) => A -> m (AccValidation e A')"
05:47:49 <sepakorayl> lyxia: Is that lens? I am not very familiar with it yet, do I use makeClassy and then derive the instances?
05:47:56 <sepakorayl> and then implement the instances8
05:47:59 <sepakorayl> **
05:48:50 <lyxia> sepakorayl: HasAErr is meant to be a typeclass that represents how to convert between e and AErr, it could be defined by lens, but it could also be something more customized.
05:49:25 <cocreature> e.g. "class HasAErr a where f :: AErr -> a"
05:50:01 <sepakorayl> will that work with type inferance? let me give this a try
05:50:08 <lyxia> Actually if you want something prism-like, I don't know if lens defines type classes for that...
05:50:45 <sepakorayl> lens apparently has makeClassyPrism
05:51:02 <cocreature> it looks like you have a lens here not a prism
05:51:59 <lyxia> your record also has "Last AErr", that may be another obstacle in finding some already built solution.
05:53:26 <sepakorayl> I am open to defining a custom typeclass if I have to I just couldn't make type inferance work yesterday
05:54:28 <lyxia> sepakorayl: in your case there is nothing to help inference because you're not using the errors.
05:54:34 <frerich> Can anyone recommend a Haskell package for doing constraint programming? I found monadiccp but it appears a bit opaque...
05:57:39 <tdammers> cocreature: what?
05:57:55 <cocreature> tdammers: huh?
05:58:07 <tdammers> cocreature: I don't want to make anything implicit IIRC
05:58:35 <cocreature> tdammers: oh sorry, I inteded to send that to sepakorayl
05:59:13 <sepakorayl> lyxia: Could you perhaps give a small example with data E1Err = Er1Err, data E2Err = E2Err E1Err? I would like t1 :: (AsE1Err e) => AccValidation e () to be compatible with  t2 :: (AsE2Err e) => AccValidation e () I think
06:01:54 <lyxia> sepakorayl: This kind of "constraint transitivity" seems troublesome to encode, it seems simpler to have whatever error type you want to use to implement AsE1Err and use t1 directly
06:02:52 <sepakorayl> yes but then I won't be able to use t1 inside t2
06:02:56 <sepakorayl> I think
06:03:25 <lyxia> my point is to not have to write t2 in the first place
06:04:55 <lyxia> hmmm, in this case you can do t2 = first fromE2Err t1  -- assuming there is an instsance (AsE1Err E2Err) and there is a function fromE2Err :: AsE2Err e => E2Err -> e
06:05:47 <cocreature> https://github.com/gwils/next-level-mtl-with-classy-optics/blob/master/Slides.pdf and the corresponding video might be worth a look
06:06:12 <sepakorayl> this is what I found a few days ago
06:07:32 <sepakorayl> but I couldn't make it work for my case
06:07:38 <sepakorayl> perhaps I am doing something wrong
06:07:50 <cocreature> I think you’ll have to show us the actual problems you’re running into
06:07:52 <lyxia> sepakorayl: I wonder whether your example is too simplified, it's hard to tell what exactly you would accept as a solution
06:09:26 <sepakorayl> cocreature: http://lpaste.net/363455 ideally I would like to have tA :: (Monad m, AsAErr e) => A -> m (AccValidation e A'), tB :: (Monad m, AsBErr e) => B -> m (AccValidation e B'), tD :: (MOnad m, AsDErr e) => D -> m (AccValidation e D') etc
06:09:52 <sepakorayl> and not have to use withAErrToDErr, withBErrToDErr etc in tD's body
06:11:21 <sepakorayl> basically I don't want to remember the error hierarchy when writing the transformations, I would prefer to write the error hierarchy seperately
06:13:25 <cocreature> maybe I’m stupid but I’m not sure why "class AsAErr e => f :: A -> e" (and similar for the other classes) isn’t sufficient for this
06:15:02 <woodson> can anyone help me or explain to me why I am getting this error.. its really annoying .. http://lpaste.net/363459
06:15:19 <woodson> I followed the tutorial https://hackage.haskell.org/package/generics-eot-0.1/docs/Generics-Eot-Tutorial.html
06:15:33 <sepakorayl> cocreature: shouldn't that be class AsAErr e => f :: e -> A ?
06:15:55 <cocreature> sepakorayl: no, you want to be able to lift the smaller error types into the larger error type
06:15:56 <woodson> which clearly state to not forget to derive Generic instance or else I will be getting the same error that I am not facing
06:16:02 <woodson> now*
06:16:20 <woodson> However, I did derive the generic instance
06:16:46 <woodson> so Why I am getting Couldn't match type ‘GHC.Generics.Rep a’
06:16:47 <woodson>                      with ‘GHC.Generics.M1 GHC.Generics.D c0 f0’
06:20:44 <sepakorayl> cocreature: thanks for helping, yes I don't know what I was thinking
06:23:49 <cocreature> woodson: if you paste complete files instead of omitting the file header you make life a lot easier for people trying to help you
06:24:30 <lyxia> woodson: does namesOfFields alone compile?
06:26:28 <woodson> cocreature: I updated it
06:26:36 <woodson> lyxia: Yes, it does.
06:26:52 <woodson> but when I try to call it from another function
06:27:10 <woodson> it get the Couldn't match type ‘GHC.Generics.Rep a’
06:27:10 <woodson>                      with ‘GHC.Generics.M1 GHC.Generics.D c0 f0’
06:27:12 <woodson> error message
06:28:20 <woodson> and you know whats funny it just decided to create a function that will accept the DataType instead of the proxy
06:28:29 <woodson> and it seems to work
06:29:21 <woodson> however, If I pass just the proxy down to function without getting the Datatype from the proxy
06:29:31 <woodson> i get the error message again
06:29:51 <sepakorayl> cocreature: wouldn't I get could not deduce context errors that way ?
06:30:37 <woodson> and its the exact same error message from the warning of the tutorial , which says that it will happen if the generic instance is not derived
06:30:54 <sepakorayl> I mean take tD :: (Monad m, AsDErr e) => D -> m (AccValidation e D'). How could it derive the AsAErr e from AsDErr e without getting into overlapping instance problems?
06:32:22 <cocreature> sepakorayl: usually you would just use tD :: (Monad m, AsAErr e, AsBErr e, AsCErr e) => D -> m (AccValidation e D')
06:32:40 <cocreature> so accumulate the constraints to the top-level instead of trying to subsume them by other constraints along the way
06:32:54 <sepakorayl> ah this might just work
06:34:10 <dminuoso> Is haxl just a word play on haskell, where "k" and "s" got swapped because of.. concurrency?
06:35:21 <cocreature> woodson: if you follow GHC’s suggestion in the warning and enable MonoLocalBinds, the code compiles
06:36:47 <woodson> cocreature: Where does it say that? and what is MonoLocaBinds?
06:37:27 <cocreature> woodson: at least GHC 8.2 has -Wsimplifiable-class-constraints enabled and suggests enabling MonoLocalBinds in the warning
06:37:35 <simbon> Discovered this channel on haskell.org/irc
06:37:42 <cocreature> MonoLocalBinds is a GHC extension, I’d have to lookup the details of it myself
06:38:00 <cocreature> https://ghc.haskell.org/trac/ghc/ticket/11948 is the corresponding GHC issue iirc
06:39:35 <woodson> cocreature: I had to switch my lts to 8.2 because of some package that was updated with to the latest ghc
06:39:43 <woodson> but I ended up not using
06:39:45 <woodson> it
06:40:02 <woodson> so I will revert it to ghc 8.2 and see it what it says
06:40:04 <cocreature> basically the problem is that GHC tries to solve "HasEot a" again instead of just reusing the constraint on myfunc and the "HasEot a" instance has a "ImpliedByGeneric a c f" superclass constraint. but GHC doesn’t know that the c, f in the one HasEot a constraint are the same as in the other constraint
06:40:21 <cocreature> it’s really a rather nasty error
06:43:33 <woodson> cocreature: Just for future reference, how did you understand that ghc was trying to reuse HasEot a again? So, how do you know that ghc is trying to reuse a constraint that already defined?
06:43:57 <woodson> Just so I know how to go about it for next the time
06:44:41 <cocreature> woodson: I saw the warning 8.2 produces and remembered the reason behind this warning. so nothing particularly clever
06:46:17 <cocreature> also note that you only get the warning if there is not a compile error. so I got it when I uncommented myfunc to see if namesOfFields compiles on its own
06:46:20 <sepakorayl> cocreate: http://lpaste.net/363455
06:53:10 <sepakorayl> but I have a lot of levels
06:53:51 <sepakorayl> and without transistive instances this will get pretty messy
06:54:06 <woodson> cocreature: Wow, I did not get that warning with 8.0
06:54:17 <cocreature> woodson: yeah it’s new in 8.2
06:54:56 <Boarders_> I am trying to use read a yaml file into a very simple data structure and was wondering which library people recommend?
06:55:09 <Boarders_> I won't need anything really fancy at all
06:55:46 <woodson> cocreature: Oh my god.. thanks I've been fighting with it for a while now. Such a relief now
06:57:15 <sepakorayl> maybe if I add a default signature
06:58:15 <nut>  
06:58:15 <nut> head :: NonEmpty a -> a
06:58:15 <nut> head ~(a :| _) = a
06:58:22 <nut> what does that tilt mean?
06:58:32 <nut> ~
06:58:37 <Philonous> It's a lazy pattern match
06:58:55 <cocreature> sepakorayl: I’d just choose a few strategic points where you lift from (AErrConstraint e, BErrConstraint e, CErrConstraint e) to (DErrConstraint e) using something like "fmap (first asDErr)" (untested)
06:59:18 <nut> Philonous:thx
06:59:42 <cocreature> sepakorayl: I don’t think there is a silver bullet here. you could ofc try playing with OverlappingInstances but I wouldn’t be suprised if that leads to other problems along the way
07:02:48 <c_wraith> nut: is that the library definition?  That ~ is entirely useless
07:03:19 <nut> c_wraith: yes, it's in the base
07:03:30 <c_wraith> weird.  Wonder why.
07:03:41 <nut> Data.List.Nontempty
07:03:48 <nut> NonEmpty
07:04:09 <c_wraith> yeah, I recognized the constructor.  Just had trouble believing that would be in base, because as far as I can tell it's useless to do that.
07:05:48 <c_wraith> like, a bit further down in the definition of map, it actually does something.  but for head/tail/last..  it does nothing.
07:05:51 <nut> I'm surprise to hear that from you too
07:05:59 <Zemyla> I really wish there was a NonEmpty Seq.
07:08:30 <c_wraith> edwardk: Why the lazy pattern matches on things like head/tail/last in Data.List.NonEmpty?  They seem useless to me.
07:09:26 <joncol> I'm using Emacs and Intero. Is there some nice way of being able to go to definitions of functions that are from stack libraries (for instance Yesod)? When I do `intero-goto-definition`, nothing happens.
07:10:02 <geekosaur> probably not, unless you actually have the yesod source in your project
07:10:10 <c_wraith> joncol: for better or worse, there's no guarantee the code is still around after installing a package.
07:10:49 <geekosaur> ^ so intero can't assume that it can find a definition. since if it looks elsewhere it might get one for a different version than you have installed
07:11:20 <joncol> OK, too bad :/
07:11:49 <phadej> c_wraith: it's not useless
07:11:56 <c_wraith> Well, intero depends on stack.  It could try to be smart about things from stackage.
07:12:19 <phadej> the same as you may want to do foo ~(a, b) = something with a and b
07:12:19 <c_wraith> That's probably a decent feature request.  But it's also probably a big feature
07:12:48 <c_wraith> phadej: those aren't the same.
07:13:04 <phadej> c_wraith: why not, both are irrefutable pattern matches
07:13:46 <sepakorayl> what are these Wrapper classe used in Base?
07:13:56 <ertes-w> phadej: it doesn't matter whether you use an irrefutable match on 'fst', because it's a strict function
07:14:00 <c_wraith> phadej: because the function call is only evaluated when its result is required anyway.  And for each of the things I listed, getting the top-level constructor out of the function requires doing the pattern match anyway
07:14:03 <sepakorayl> Monoid e => Monoid (MonoidWrapper e) ?
07:14:04 <sepakorayl> etc
07:14:12 <Philonous> Isn't the point of »f ~(a,b) = g a b« that pattern matching is delayed until g forces a or b? So it wouldn't make a difference for strict g, and id is strict.
07:14:35 <ertes-w> Philonous: correct
07:15:23 <Philonous> Or const, rather (still strict in the first argument)
07:15:28 <ertes-w> in my experience edwardk pays extra attention to keep functions as non-strict as possible, so some useless irrefutables may be just a side effect of that
07:15:34 <c_wraith> This is why I dislike heuristics for handling laziness, and strongly recommend doing the correct thing in each case instead of using rules of thumb. :)
07:15:39 <ertes-w> it's not useful, but it doesn't hurt either
07:16:06 <c_wraith> I suppose in all those cases, ghc will recognize that deferring the match doesn't do anything, and just.. won't.
07:16:18 <ertes-w> if it really bothers you, i'm pretty sure he'll merge a PR to fix that =)
07:17:09 <ertes-w> i'm sure it's just a copy/paste artifact or something like that
07:17:20 <phadej> c_wraith: I see
07:17:53 <c_wraith> Well, there are a bunch of definitions where the irrefutable match does do useful things.  Looks like it was just mechanically applied to every match on (:|)
07:18:21 <ertes-w> yeah, that's what i'm assuming
07:20:59 <Zemyla> You know, I really wish that the Semigroup a dictionary had a Maybe (Monoid a) dictionary, because there are times when I need to know whether stimes with n=0 is valid or not.
07:22:19 <lyxia> What's stopping you from requiring a Monoid constraint instead
07:23:32 <Zemyla> For instance, a newtype wrapper around (m a) where (<>) = liftA2 (<>) and stimes 0 whatever is either pure mempty or error "something" depending on whether it's also a Monoid.
07:26:37 <Zemyla> It's also like how I want Bits a to have a Maybe (FiniteBits a) dictionary.
07:41:53 <ertes-w> Zemyla: if you don't mind some additional boilerplate: (Semigroup a) => Maybe (Dict (Monoid a)) -> …
07:42:11 <ertes-w> for monoids you can just pass (Just Dict), otherwise pass Nothing
07:43:21 <Zemyla> Yeah, but it always seems kind of wasteful to have an entire wrapper around the dictionary, when at the level of Core, Constraint ~ *.
07:44:01 <ertes-w> Zemyla: you're going to have that wrapper anyway
07:45:14 <ertes-w> class Semigroup a where (<>) :: a -> a -> a; maybeMonoid :: Maybe (Dict (Monoid a))
07:45:37 <ertes-w> alternatively:
07:45:51 <Zemyla> There should honestly be a semi-wired-in newtype for directly converting them.
07:46:00 <ertes-w> class Semigroup a where (<>) :: a -> a -> a; withMaybeMonoid :: ((Monoid a) => r) -> r -> r
07:46:33 <Zemyla> Yeah, I was thinking about that form.
07:47:23 <Zemyla> It saves unwrapping.
07:47:32 <ertes-w> you can pass that form around, too
07:48:30 <ertes-w> (Semigroup a) => (forall r. Maybe ((Monoid a) => r)) -> …  -- i think this should work
07:48:35 <ertes-w> but now instead of a Dict you have a function
07:49:10 <ertes-w> err, that's wrong
07:50:03 <ertes-w> newtype WithDict c = WithDict { runWithDict :: forall r. (c => r) -> r }
07:50:18 <ertes-w> (Semigroup a) => Maybe (WithDict (Monoid a)) -> …
07:50:51 <ertes-w> the Dict variant is most likely cheaper
07:51:18 <ertes-w> in fact you can probably use Proxy# and make it completely free
07:51:59 <ertes-w> no, that doesn't work
08:37:10 <qmm> is template haskell necessary to create an equivalent of servant?
08:37:27 <Taneb> I don't think servant uses TH
08:37:37 <Taneb> Although I could be wrong
08:38:13 <qmm> Taneb: it does: https://github.com/haskell-servant/servant/blob/bcca6351515f2b6683b8ed89cd3b7423e008ce55/servant/servant.cabal
08:39:13 <qmm> Taneb: but maybe you are saying the core functionality doesn't rely on TH
08:40:01 <Taneb> qmm: hmm, it's only used in servant-foreign and servant-docs, not in servant, servant-client, or servant-server
08:41:56 <EvanR> it uses makeLenses
08:42:02 <EvanR> in servant-foreign
08:42:06 <alp> yeah servant doesn't use TH for anything important
08:42:21 <Taneb> qmm: so yeah, you can totally do without TH
08:42:43 <alp> we used to have a quasiquote for specifying API types in a saner syntax, but that was too much work and hardly extensible (so unlike everything else in servant)
08:48:19 <sepakorayl> can you gusy think of any way to avoid the n^2 instances? http://lpaste.net/363467
08:49:16 <EvanR> use Dynamic ?
08:50:11 <EvanR> or vinyl CoRec
08:50:47 <EvanR> or normal Rec since the underlying thing is a product
08:53:57 <sepakorayl> cab you elaborate? I am not very familiar with Vinyl
08:53:58 <cocreature> sepakorayl: fwiw those are not lawful prisms
08:54:32 <sepakorayl> yea thought so
08:54:47 <sepakorayl> not very familiar with lens either
08:54:59 <cocreature> prisms require that you can roundtrip using preview and review
08:55:07 <cocreature> in your case this will set all other fields to mempty
08:56:07 <cocreature> you can make a lawful lens
08:56:21 <cocreature> and then instead of using "review" use mempty and "set"
08:57:42 <sepakorayl> I could even use my own type classes
08:57:53 <EvanR> sepakorayl: say if you have a bunch of errors in a Rec f us, and you want to dump some more (Rec f vs) into it, you could use rappend :: Rec f us -> Rec f vs -> Rec f (us ++ vs)
08:57:53 <sepakorayl> the problem is I can't seem to be able to get rid of the n^2 instances
08:58:34 <EvanR> where f effectively defines the type of each kind of error in the bag
08:59:28 <EvanR> its a form of hlist
09:00:44 <`Guest00000> damn, language theory is interesting https://www.cs.indiana.edu/~sabry/papers/rational.pdf
09:02:29 <`Guest00000> > Intuitively, values of negative types are values that flow ■backwards■ to satisfy demands and values of fractional types are values that impose constraints on their context.
09:02:31 <lambdabot>  <hint>:1:12: error: parse error on input ‘,’
09:08:17 <Mittwoch> http://degoes.net/articles/modern-fp shows a signature `blahblah :: Boolean -> Boolean -> Boolean -> IO ()` and says:
09:08:20 <Mittwoch> the function returns a value representing an IO effect, which inverts the control: now the caller has explicit control over the effect (in imperative programming, it’s the callee that has control, which makes reasoning harder).
09:08:35 <Mittwoch> What is meant by this? That the caller can decide to throw away the IO value?
09:09:01 <EvanR> they can throw it away, put it in a data structure, etc
09:09:08 <EvanR> use it like a callback
09:09:33 <EvanR> IO actions are first class values
09:09:40 <Ariakenom> use it twice
09:10:05 <EvanR> doItTwice :: IO () -> IO (); doItTwice act = act >> act
09:10:26 <EvanR> doItTwice :: IO () -> IO (); doItTwice act = do{act; act}
09:10:40 <Mittwoch> The thing is: we can’t inspect what’s inside this IO value.
09:10:56 <Mittwoch> So on what basis could we decide to throw it away?
09:10:56 <EvanR> the internals happen to be hidden
09:11:21 <Mittwoch> We can’t see that it wanted to print something to the screen, let’s better not do it.
09:11:22 <EvanR> you could attach extra data to it to later decide to throw it away, hypothetically
09:11:46 <EvanR> or make something like IO that is inspectable, that gets interpreted as IO
09:12:07 <Mittwoch> Okay thanks for your inputs guys.
09:12:58 <tnks> Mittwoch: you could make a tuple with that information, and then decide whether to keep it or not.
09:14:16 <tnks> filter notAGoodAction [(Metadata, IO ())]
09:14:48 <EvanR> illegal mixing of values and types
09:14:56 <EvanR> 5 yard penalty 1st down
09:15:59 <tnks> filter notAGoodAction (forThePedants :: [(Metadata, IO ())])
09:18:22 <Boarders_> I am trying to adapt this example but I have a list as one of my fields: https://stackoverflow.com/questions/21292428/reading-yaml-lists-of-objects-in-haskell
09:18:40 <Boarders_> what do I have to do differently?
09:19:04 <sepakorayl> EvanR : I want to return a tree of errors for later retrieval through my ast
09:19:44 <EvanR> you want to attach errors to ast nodes?
09:20:29 <EvanR> Boarders_: you would just need to make sure its a list of type-that-has-FromJSON-instance
09:20:40 <EvanR> then it ought to just work without changes
09:21:00 <sepakorayl> not really, I want to either get a complete error-free tree or a tree of errors
09:21:28 <`Guest00000> is there a kind of big web-portal dedicated to distribution/browsing of functional language theory materials?
09:22:25 <EvanR> and all the errors have different types?
09:26:07 <sepakorayl> yes pretty much. This is how I handle this currently: http://lpaste.net/363455 but this requires n^2 instances. I could simply have error converting functions and convert the transformers explicitely but I would liek to avoid that
09:30:38 <sepakorayl> hmm maybe I don't need all these instances
09:31:56 <Boarders_> EvanR: say I have: Data MyUser = MyUser {name :: String, faves :: [String]}
09:32:32 <Boarders_> what is the fromJSON instance I would need to write here?
09:34:25 <EvanR> you might not need one
09:34:36 <EvanR> is it a list of custom type, or like list of Int
09:34:51 <EvanR> [Int] is already FromJSON
09:35:06 <sepakorayl> perhaps I can do this with generics?
09:35:47 <lyxia> sepakorayl: Are your "asXErr" always going to be some composition of record constructors where you set one nested field to some x, and everything else to mempty
09:36:03 <lyxia> because, indeed, you could do that with generics
09:36:21 <sepakorayl> lyxia: yes
09:36:55 <Boarders_> EvanR: it is just a list of ordinary types for now
09:37:06 <Boarders_> but I don't think it is parsing it correctly
09:37:43 <EvanR> no?
09:37:59 <Boarders_> probably I am doing something stupid
09:38:16 <Boarders_> let me link to the code and the yaml file I have
09:44:17 <sepakorayl> lyxia: do you have anything in mind? I have spent the past 10 hours reading on new to me features and I have just learned about generics.
09:46:23 <EvanR> are you sure you need many errors types, and not 1 error sum type
09:47:19 <Boarders_> EvanR: code: http://lpaste.net/363470   yaml: http://lpaste.net/363471
09:47:30 <Boarders_> probably doing something very silly, any ideas?
09:48:11 <cocreature> Boarders_: libs is a list of strings in your code but a single string in the yaml file
09:49:03 <Boarders_> fml
09:49:50 <Boarders_> thanks cocreature
09:50:02 <Boarders_> my brain's endless ability to do this amazes me
09:50:10 <EvanR> problem between chair and parser
09:51:03 <cocreature> Boarders_: protip: binary search by uncommenting half of your code might be annoying but at least it usually points you to the problem quite quickly
09:54:21 <whoman> =p
09:59:20 <EvanR> internal error: resurrectThreads: thread blocked in a strange way: 10
09:59:48 <lyxia> sepakorayl: I have something in mind but it's not as trivial than it seemed at first
10:00:24 <AWizzArd> Does Control.Concurrent.Async allow me to wait for a result but also specify a timeout? The call will block only for the specified number of msecs.
10:00:51 <cocreature> AWizzArd: just wrap "wait" in "timeout"
10:01:33 <sepakorayl> it is kind of sad that I have to wrap my whole code in error converters
10:01:45 <sepakorayl> I hoped to do this seperately via typeclasses
10:01:53 <cocreature> sepakorayl: maybe you shouldn’t produce so many errors ;)
10:02:02 * EvanR walks to the other room to get help with segfaulting SDL2 bindings
10:02:12 <jluttine> anyone using spacemacs on nixos? if i use haskell-ghc checker, it complains about an import that the module couldn't be found, although it is installed. if i use haskell-hlint checker, it doesn't complain. what could cause this issue for haskell-ghc checker?
10:02:20 <AWizzArd> cocreature: Is the `timeout` function the one from System.Timeout?
10:02:23 <sepakorayl> I am writing a compiler and I ahve things like proof terms
10:02:39 <cocreature> AWizzArd: yes
10:02:50 <sepakorayl> I don't want to sacrifice error quality
10:03:43 <EvanR> so your errors are all mutually exclusive, you might want to check out corecords after all
10:04:49 <sepakorayl> no the errors are not mutually exclusive they form a tree
10:05:12 <sepakorayl> then I can use that tree along with my ast to report what went wrong
10:05:24 <EvanR> guess i am misinterpreting "one field is x and the rest are mempty"
10:08:32 <lyxia> This is how an individual error is represented, and there is an operation to collect them together
10:08:33 <MacSlow> Greetings everybody!
10:09:43 <lyxia> sepakorayl: does it have to be a tree, instead of putting the errors in a list and using something like partitionEither to access some subset of errors?
10:11:43 <AWizzArd> When I make an `async` call (from the Control.Concurrent.Async module) – is there then some kind of threadpool used under the hood? Or am I creating a fresh thread for every single call?
10:12:57 <EvanR> `async` uses a single forkIO
10:13:03 <EvanR> very carefully
10:13:11 <EvanR> but forkIO is fast
10:13:16 <barrucadu> AWizzArd: You're creating a fresh thread for every single call, but Haskell threads are incredibly cheap
10:14:05 <sepakorayl> tae for instance newtype AssignmentError = AssignmentError {lv :: Last ExprError, e :: Last ExprError, plv :: Last LeftExpressionNotAnLvalueError, pfe :: Last RightExpressionNotIntegralError}
10:14:52 <sepakorayl> in typechecking we can either fail to typecheck the sub expressions of Expr
10:15:15 <sepakorayl> or after typechecking them we may fail to produce the proof terms because they don't have the appropriate types
10:16:02 <sepakorayl> eachhc onstructor may have different requirements so I need different error types for each constructor
10:16:18 <sepakorayl> then ExprError is a sum type of the ExprConstructorErrors
10:17:01 <AWizzArd> barrucadu: why you say they are cheap? Are those green threads (and _not_ OS threads)?
10:17:47 <barrucadu> Yes, they are green threads
10:17:50 <sepakorayl> using converters for the errors is not THAT bad as is, the only poblem is that it's a bit distructing to have to convert errors in the typechecking stage for example
10:17:53 <dminuoso> Is there some ugly hack that gives me a Show instance for lambdas enough to play lambda calculus in raw Haskell?
10:18:03 <AWizzArd> barrucadu: the thing is that when I get external requests from users (could be software too) I would not want to run a new thread for each request.
10:18:18 <sepakorayl> is there not any trick for transistive instances?
10:18:31 <EvanR> AWizzArd: yes you would
10:18:32 <sepakorayl> using type level witnesses perhaps?
10:18:40 <AWizzArd> But: is there then a way to create a pool of, say, 5 threads and send tasks to them and let them work of, with a similar API as async?
10:19:03 <barrucadu> That's exactly what the GHC runtime does with its green threads
10:19:05 <EvanR> thats how you do it in java, not haskell
10:19:09 <AWizzArd> EvanR: why is that? Well okay, with green threads that’s fine, but not with OS threads. Some OSes may feel bad if I try to run 80k OS threads.
10:19:12 <lyxia> dminuoso: you could have a type of expressions, and write an instance (Show (Expr -> Expr)) that passes a variable to the lambda
10:19:15 <barrucadu> It distributes them across a much smaller number os OF threads
10:19:18 <barrucadu> *of OS threads
10:19:31 <EvanR> yeah you can run 80k forkIO threads, not forkOS threads
10:20:12 <AWizzArd> Okay, green threads yes – I can start thousands of them. But will they be distributed among a few true OS threads under the hood? Or will the system try to compute all 80k results on a single core?
10:20:22 <barrucadu> You can control the number of OS threads your Haskell program gets with `my-program +RTS -Nnumber_of_os_threads`
10:20:34 <barrucadu> Or just `+RTS -N` to use one OS thread for each core
10:20:46 <EvanR> it distributes them among "capabilities", the number of which you configure with that RTS option ^
10:21:01 <barrucadu> Note that you need to use the `-threaded` option when compiling for this
10:21:25 <AWizzArd> Okay good. So if I start my binary with maybe 4 threads then possibly those 80k tasks will get evenly distributed (20k per OS thread).
10:21:36 * EvanR nod
10:21:40 <AWizzArd> Sounds nice. So I don’t have to take care about this.
10:22:05 <AWizzArd> I can easily start thousands of green threads, which is fine, and ghc will see how it can distribute those guys amongst my threads.
10:22:08 <EvanR> one of haskells "killer features"
10:22:09 <AWizzArd> Sounds really good.
10:22:25 <AWizzArd> Indeed, that means I don’t need to think about this at all then.
10:22:53 <EvanR> unless you want to delve into asynchronous exceptions ...
10:23:09 <EvanR> something the async lib helps you with
10:24:13 <guessWho> i have a project say A and then inside A i have two modules which are complete stack project say B & C how do i import B& C inside A and say B inside C with stack ?
10:25:32 <dminuoso> lyxia: Is there a generic way to find out the arity of a function then?
10:26:01 <dminuoso> lyxia: And some reflection that lets me know the binding names of the variables?
10:31:37 <lyxia> dminuoso: for the arity of a function there are tricks with type classes or type families. There's no way to get the binding names AFAIK.
10:32:55 <EvanR> if the function has the proper type you could use quoting to introduce your own binding names and compute a lambda term from haskell functions
10:34:48 <sepakorayl> should I give up trying to make the conversions implicit ?
10:34:50 <EvanR> this is exploited to show terms that use higher order abstract syntax, heres a paper https://www.andres-loeh.de/LambdaPi/LambdaPi.pdf
10:35:58 <tmciver> Hey folks. I'm looking for a little help with a type error around using `cast` from Data.Typeable. This code: http://lpaste.net/363472 compiles fine (note call to `cast` on last line), but *this* file: http://lpaste.net/363473 is similar but has the type error shown due to the call to `cast` on line 39. The problem is a mystery to me.
10:36:09 <EvanR> dminuoso: in the first part of this paper they implement lambda calculus using raw functions as functions, and are shown using "quoting"
10:36:41 <EvanR> ignore the dependent types
10:41:16 <lyxia> tmciver: e1 in the error message is part of the type of ev
10:41:39 <lyxia> tmciver: there is nothing that says that ev is typeable
10:42:08 <dminuoso> EvanR: Oh goodie.. this looks like I could almost read it. Maybe 1-2 more TaPL chapters =)
10:42:46 <EvanR> dminuoso: of course this is very advanced... you could simply implement lambda calculus as a normal ADT
10:43:02 <MarcelineVQ> EvanR: thanks for the link
10:43:03 <tmciver> lyxia: Isn't that also true for fv in the first file?
10:43:06 <EvanR> with its own pretty printer and parser
10:43:48 <kuribas> How do I get an "a" from "CoerceText a"?  https://hackage.haskell.org/package/aeson-1.2.4.0/docs/Data-Aeson.html#t:FromJSONKeyFunction
10:44:18 <tmciver> lyxia: OMG, I think I see the problem! :(
10:44:59 <kuribas> Problem is CoerceText is hidden
10:46:28 <tmciver> lyxia: in the first file, I'm casting el, a `FooValueElement` to a `FooValue a`; in the second, I'm attempting to cast an `Event e` to . . . `Event e`.
10:50:22 <tmciver> lyxia: Thanks for the help. My first link had an error in it but still type checked but I think I see the problem now.
10:51:19 <pikajude> i think the past tense of typecheck is "typechook"
10:53:20 <EvanR> typechunk
10:54:09 <EvanR> should be what "cast" is called in C
10:55:49 <kuribas> is there an unsafe version of coerce?
10:56:01 <Rembane> :t unsafeCoerce
10:56:03 <lambdabot> error: Variable not in scope: unsafeCoerce
10:56:05 <Rembane> :D
10:56:12 <Tuplanolla> @index unsafeCoerce
10:56:12 <lambdabot> Unsafe.Coerce
10:56:23 <EvanR> dang i need @index locally
10:56:25 <pikajude> is there a safe version of unsafeCoerce
10:56:35 <dminuoso> EvanR: Are you the maintainer of lambdabot?
10:56:39 <EvanR> :t coerce
10:56:40 <lambdabot> error:
10:56:40 <lambdabot>     • Variable not in scope: coerce
10:56:40 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
10:56:44 <EvanR> dminuoso: no
10:56:57 <EvanR> @index coerce
10:56:58 <lambdabot> Data.Coerce, GHC.Exts, GHC.Prim
10:57:32 <dminuoso> Ah, I guess int-e is responsible for lambdabot then, given the commit history.
10:58:20 <EvanR> unsafeCoerce is the unsafe version of the safe version of unsafeCoerce
10:59:18 <kuribas> EvanR: thanks!
10:59:21 <dminuoso> And coerce is the safe version of the unsafe unsafeCoerce.
10:59:37 * dminuoso is mildly confused
11:03:49 <EvanR> coerobos
11:03:56 <EvanR> coeroboros
11:11:49 <EvanR> do ghc type checker plugins allow you to rewrite the whole type system? or just extend it
11:13:56 <cocreature> EvanR: iirc they can only affect constraint solving
11:14:01 <EvanR> ah
11:23:50 <Myrl-saki> How to use the new hoogle to look for n-functions that return a certain type?
11:25:48 <jle`> what is an n-function?
11:25:56 <Myrl-saki> jle`: I wasn't sure how to say it.
11:26:07 <Myrl-saki> Basically, functions that have "n arguments"
11:26:13 <Myrl-saki> I know that that's not exactly the correct thing to say.
11:26:24 <sepakorayl> perhaps I will write some template haskell I guess
11:26:43 * Myrl-saki finger cross that I won't be killed by people
11:26:53 <jle`> Myrl-saki: do you have a specific search you had in mind
11:27:06 <Myrl-saki> :: MonadDOM m => a -> b -> ... -> m HTMLElement
11:27:17 <cocreature> if you only care about the return type, I don’t see how the number of arguments matters
11:27:46 <Myrl-saki> cocreature: Yeah, I only care about the return type.
11:27:51 <cocreature> but the type search in hoogle 5 is fairly limited so I thin k the answer is just “you don’t use hoogle 5 for that”
11:28:07 <jle`> Myrl-saki: oh, you mean 'any amount of arguments, only care about the return type'
11:28:12 <jle`> not like, a specific n
11:28:12 <Myrl-saki> jle`: Yep.
11:28:24 <Myrl-saki> Sorry, that was a bit confusing.
11:28:32 <jle`> it's cool
11:29:05 <Myrl-saki> If anyone does use jsaddle-dom, and can help me find the answer, that's also just as well.
11:29:23 <Myrl-saki> Basically, I need something that finds the element with an ID.
11:30:27 <Myrl-saki> Lmao. "getElementById"
11:30:34 <Myrl-saki> That should have been fucking obvious. Thanks.
11:31:02 * Myrl-saki should take a few more minutes to google before asking
11:31:58 <sepakorayl> since I am not familiar with generics or template haskell, whic do you guys think can help me generate those n^2 instances ?
11:32:42 <cocreature> sepakorayl: you can’t generate instances with generics, you can only “generate” the implementation of instances
11:32:53 <cocreature> so if you want to generate instances, you are going to have to go for TH
11:38:08 <sepakorayl> what do you suggest for learning TH ?
11:39:13 <cocreature> iirc mark karpov has a nice tutorial
11:39:44 <cocreature> although at this point, I would really consider if you aren’t creating way more work by trying to avoid a bit of boilerplate than writing this boilerplate would cause
11:42:45 <cocreature> boilerplate might not be pretty but it’s usually easy to understand and rarely the kind of code that causes bugs
11:42:46 <jle`> sepakorayl: what instances are you talking about?
11:43:17 <sepakorayl> jle`: http://lpaste.net/363455 the FromX ones
11:44:35 <jle`> fwiw, a bunch of FromX classes like that is commonly considered bad/anti-pattern
11:45:12 <cocreature> jle`: depends on who you ask. the classy lens/prism crowd will probably disagree :)
11:45:51 <jle`> oh, yeah, good point
11:46:00 <sepakorayl> I a open to suggestions
11:46:50 <jle`> sepakorayl: why don't you try the error hierarchy technique in Control.Exception ?
11:47:09 <jle`> it was made for Control.Exception exceptions, but it's actually a good general-purpose subtyping system
11:48:12 <jle`> but also in this case you're probably better off just writing functions instead of typeclasses
11:49:32 <sepakorayl> jle` this is what I am doing currently, I was ooking for a solution to convert my errors implicitely
11:49:44 <jle`> and your reasoning is that implicit is better than explicit?
11:50:43 <sepakorayl> no, I would like write my transformation functions without dealing with the small details of the conversions ideally I would like to define the error hierarchy seperately
11:51:36 <jle`> if you have an error heiarchy, maybe see if the hiearchy tools in Control.Exception are suitable
11:52:08 <sepakorayl> I will check it out thanks for the suggestion
11:54:05 <jle`> haskell exceptions are a runtime mechanism in IO that GHC offers, but the hiearchy tools in Control.Exception are actually pure combinators that are in general useful for manipulating exception subtypes in a pure way
11:54:22 <jle`> manipulating subtypes of pure 'exception values'
11:55:15 <jle`> you can just ignore everything that isn't in the 'The Exception Type' header
11:55:21 <jle`> (that is, Throwing exceptions and onwards)
11:55:39 <cocreature> it might be worth noting that the techniques in Control.Exception model an open hierarchy not a closed one
12:06:06 <sepakorayl> not sure how the Exceptions model fits with my compiler's
12:07:26 <sepakorayl> my errors are not exceptions
12:07:38 <sepakorayl> they are monoids that are ment to be combined
12:10:19 <akr> Hi! Is there a package with an *indexed* state monad transformer?
12:10:35 <jle`> sepakorayl: they can be converted to an from each other
12:11:49 <cocreature> akr: https://hackage.haskell.org/package/indexed-extras-0.2/docs/Control-Monad-Indexed-State.html#t:IxStateT maybe?
12:13:40 <akr> cocreature: nice, thanks
12:14:00 <cocreature> akr: fwiw that’s literally the first google hit when you search for “haskell indexed state monad” ;)
12:14:31 <akr> oh
12:14:33 <akr> hmm
12:14:36 <akr> not for me
12:14:39 <akr> weird
12:14:57 <cocreature> ah apparently google knows me better :)
12:15:08 <akr> heh :)
12:15:21 <akr> how embarrassing for me
12:15:27 <cocreature> no worries
12:15:49 <akr> though I'm using this "Ecosia" search, but I thought they use google search under-the-hood
12:16:23 <sepakorayl> jle`: I am very tired and the example on the page throws me off, how would that work?
12:17:40 <cocreature> akr: wikipedia claims it’s based on bing
12:18:33 <akr> oh, okay
12:24:28 <akr> ah, dammit https://github.com/reinerp/indexed-extras/issues/5
12:24:39 <akr> always annoying
12:25:30 <cocreature> --allow-newer is your friend
12:30:02 <pavonia> What's the point of indexed state monads? Is that a combination of reader and writer monads?
12:31:12 <akr> cocreature: thanks
12:31:42 <akr> pavonia: no, it's a state monad where the type of the state can change… or rather, is indexed by another type
12:31:50 <akr> (possibly also value, with dependent types)
12:32:21 <akr> (not sure if indexed-extras supports that, though)
12:32:37 <cocreature> https://stackoverflow.com/questions/28690448/what-is-indexed-monad has some useful answers
12:40:09 <akr> cocreature: oddly enough, it seems like that indexed-state package doesn't have function to run or eval a computation in that monad
12:40:45 <akr> not sure why they'd make people implement it themselves
12:41:14 <cocreature> akr: did you mean “indexed-extras”?
12:41:25 <akr> oh yeah sorry
12:41:47 <cocreature> it has runIxState but I guess you’re looking for the eval/exec variations?
12:41:58 <akr> yup
12:42:16 <akr> sorry I seem to be a bit scatterbrained at the moment
12:42:53 <cocreature> I’d say make a PR but that package doesn’t seem to be getting a lot of love lately so that probably won’t go anywhere
12:43:01 <akr> yeah :(
12:44:14 <akr> well I guess I can at least try
12:45:17 <pavonia> cocreature: But the bind version of that package is different from the one mentioned in the article, no? Because the standard (>>=) must have the same types for i and j
12:46:08 <cocreature> pavonia: IxState is an instance of IxMonad which has the bind in the stackoverflow answer
12:46:42 <pavonia> Oh, I see
12:47:00 <piark_> hello
12:47:51 <metahumor> hi
12:57:41 <armlesshobo> what do y'all use to get system time?
12:57:49 <armlesshobo> just 'time'?
12:57:49 <dminuoso> armlesshobo: For what purpose?
12:57:56 <roconnor> Is there a recommended article for reading about the new nix 2.0 and how to take advantage of it?
12:58:13 <metahumor> armlesshobo: getUTCTime
12:58:14 <cocreature> roconnor: seems like a question that is better suited for #nixos
12:58:19 <armlesshobo> dminuoso: to generate the time that a user was created in a system
12:58:22 <roconnor> oops, wrong chan
12:59:21 <dminuoso> armlesshobo: Do you ever need to do calculations with that time? And if so, do you care about leap seconds?
12:59:22 <armlesshobo> metahumor: what package is that part of?
12:59:30 <armlesshobo> dminuoso: not at all
13:01:49 <metahumor> @hoogle getUTCTime
13:01:49 <lambdabot> Database.PostgreSQL.Simple.Time.Internal getUTCTime :: Parser UTCTime
13:01:49 <lambdabot> Database.PostgreSQL.Simple.Time.Internal getUTCTimestamp :: Parser UTCTimestamp
13:01:52 <metahumor> ew
13:02:08 <armlesshobo> I'd like to generate a string in ISO 8601 format
13:02:20 <metahumor> armlesshobo: https://hackage.haskell.org/package/time-1.9.1/docs/Data-Time.html
13:02:36 <dminuoso> armlesshobo: `time` then =)
13:02:37 <pikajude> @hoogle iso8601DateFormat
13:02:37 <lambdabot> Data.Time.Format iso8601DateFormat :: Maybe String -> String
13:02:37 <lambdabot> System.Locale iso8601DateFormat :: Maybe String -> String
13:02:37 <lambdabot> Network.AWS.Compat.Locale iso8601DateFormat :: Maybe String -> String
13:03:23 <armlesshobo> great, thank you dminuoso & metahumor
13:58:20 <akr> hmm, is there any way to selectively re-export? `module A (module B(x))` doesn't seem to be supported
14:01:39 <akr> ah I can list the things from B I want re-exported explicitly in A's exports
14:03:16 <hexagoxel> also, `module A (B.x)`
14:04:07 <akr> oh, nice
14:04:10 <akr> thank you
14:04:58 <ski> dminuoso : "What's the ascii approximation for \"[type] X is isomorphic to [type] Y\" ?","For the purpose of an IRC discussion, would you use ≅ in `Either () ≅ Maybe`, or some ASCII approximation or just english?" -- i have used `~=' (iirc),`~', but also `=', when making it clear than i'm not just talking about "on the nose"-equality of types. also "isomorphic to"/"iso to"
14:07:03 <akr> alternatively, set up XCompose and then you can be 𝖑𝖎𝖙 on IRC
14:07:37 <dminuoso> akr: Well I have something custom set up, I guess I could include an `iso` combination =)
14:08:00 <dminuoso> ski: Thanks, yeah I think ~= might actually be a better approximation than ~~~, since it kind of combines ≅.
14:08:31 <Tuplanolla> Better spend more time setting up your keys than using them.
14:09:11 <dminuoso> Tuplanolla: Actually it just takes a quick `"iso" => "≅"` in a file that automatically generated the necessary magic. =)
14:09:40 <sdrodge> Anyone willing to explain the type signature of ($) to me?
14:10:00 <dminuoso> :t ($)
14:10:00 <akr> Tuplanolla: noted. I shall use fracture more often on here ;)
14:10:01 <lambdabot> (a -> b) -> a -> b
14:10:02 <sdrodge> (I understand what it does, am not new to Haskell, but the type signature is a bit opaque to me)
14:10:13 <sdrodge> dminuoso: That's not what it gives in my ghci...
14:10:16 <Tuplanolla> Fraktur, akr.
14:10:23 <dminuoso> sdrodge: Ah. You're probably seeing this
14:10:34 <Tuplanolla> It's nice how those letters are four times smaller than everything else.
14:10:49 <akr> depends on your font I guess
14:11:00 <dminuoso> sdrodge: ($) :: forall (r :: GHC.Types.RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
14:11:02 <dminuoso> sdrodge: right?
14:11:05 <sdrodge> yep
14:11:11 <dminuoso> sdrodge: That's levity polymorphism
14:11:18 <dminuoso> sdrodge: Do you know about unlifted kinds?
14:11:28 <sdrodge> I do.
14:11:41 <dminuoso> sdrodge: So imagine you tried ($) on a function that had * -> * -> #
14:12:08 <dminuoso> sdrodge: Err, that is * -> #
14:12:38 <sdrodge> I'm not seeing what the problem would be, honestly.
14:13:07 <sdrodge> Maybe I don't understand unlifted kinds as well as I thought I did.
14:13:44 <dminuoso> sdrodge: polymorphic types normally have kind *
14:14:32 <dminuoso> sdrodge: Let me give you the rundown on the initial (less convuluted) version:
14:14:35 <dminuoso> Assume some: data Levity = Lifted | Unlifted
14:15:05 <dminuoso> Then you get ($) :: forall (w :: Levity) a (b :: TYPE w). (a -> b) -> a -> b
14:16:45 <dminuoso> sdrodge: Without this, lets assume you had some function unwrap :: Int -> Int#
14:17:21 <dminuoso> sdrodge: That requires something of an lifted type (that is some type t0 :: *) and returns something of an unlifted type (that is some type t1 :: #)
14:17:45 <sdrodge> With you so far.
14:18:20 <sdrodge> Oh is the problem simply that a fully polymorphic type is just kind *.
14:18:27 <dminuoso> sdrodge: Yes.
14:18:30 <sdrodge> So if you want different behavior you need to ask for it.
14:18:35 <sdrodge> Oh. I feel a little silly now.
14:18:38 <sdrodge> Thank you for the help.
14:18:46 <Myrl-saki> I need help structuring my GHC+GHCJS project.
14:18:50 <Myrl-saki> root dir has subdirs a, b, c. Root dir updates like, I don't know. Every 6 months or something. Root dir just has a build script to compile a, b, c together and produce a single output.
14:18:56 <Myrl-saki> How do I make that make sense with Git?
14:19:35 <dminuoso> sdrodge: And RuntimeRep is basically just a little more elaborate version of Levity.
14:20:14 <dminuoso> (i.e. that represents any inhabitable type)
14:44:53 <mtjmullen> sdrodge: Don't feel silly, it's kinda complicated :)
14:45:29 <mtjmullen> quite a few moving parts going on there.
14:45:41 <pikajude> can i define a function with levity polymorphism?
14:45:46 <mtjmullen> I thought by default ghci hid that type signature by default?
14:46:05 <pikajude> it does
14:46:44 <pikajude> weird flag you've got
14:47:36 <akr> say I have a type `data IndexedUnit a = Unit`, i.e. where the parameter is ignored. How do I transform values of `IndexedUnit Int` to `IndexedUnit String` without pattern matching?
14:48:54 <akr> or hmm, maybe there's a better way to do what I want
14:50:17 <akr> I have a data type by which I use to index a mutable storage to signify whether I am allowed to write or only read: `data Access = ARead | AWrite`
14:50:41 <akr> can I somehow express that I can at any time change AWrite to ARead?
14:50:52 <akr> (but not the other way around)
14:51:55 <dminuoso> akr: You could use GADTs to enable pattern matching
14:53:28 <akr> hmm, how would that work? here's my current code http://lpaste.net/363476
14:55:31 <akr> seems like I can only make a specific function for my IORefHashMap
14:55:40 <akr> but not a general one for SharedState
14:57:47 <akr> I guess I could make this function part of the SharedState class and then implement it for every instance
15:03:05 <mtjmullen> pikajude: I believe you can define a function, but I don't recall offhand the syntax.  I think it looks pretty close to what dminuso had for the expanded sig of ($)
15:03:34 <mtjmullen> might require some Language Extension though
15:10:12 <kuribas> Can I force ghc to specialize more agressively?
15:10:20 <dminuoso> akr: I wonder, why not simply make IORefHashMap a coproduct type?
15:10:46 <dminuoso> akr: Then you could have a simple `promote :: IORefHashMap ... -> IORefHashMap ...`
15:11:33 <akr> dminuoso: I would still need to do that for every instance
15:24:29 <kuribas> I need to specialise all the intermediate functions in order for ghc to do the optimization.
15:24:40 <kuribas> Isn't there a way to signal ghc to try harder?
15:24:52 <akr> ok I can't do this in general because SharedState doesn't know that the parameter doesn't really change anything
15:25:03 <akr> so I wonder if there is a better way to do what I'm doing
15:25:07 <akr> however, this will do for now
15:25:24 <Tuplanolla> There are pragmas for specialization and flags for unfolding keenness, kuribas.
15:25:55 <kuribas> Tuplanolla: yes, but they should be already on because I use -O2 now.
15:26:12 <Tuplanolla> I think you're wrong on both accounts.
15:28:01 <kuribas> Tuplanolla: fspecialise: "Turn on specialisation of overloaded functions. Implied by -O."
15:29:00 <kuribas> Tuplanolla: or do you mean -fspec-constr-threshold?
15:29:41 <Tuplanolla> @google ghc user guide "specialize inline"
15:29:42 <lambdabot> https://www.haskell.org/ghc/docs/latest/html/users_guide/
15:30:36 <Tuplanolla> Section 10.31.10.1.
15:31:59 <Tuplanolla> Also all the `funfolding` things in section 7.3.
15:36:45 <kuribas> Tuplanolla: I'd like it to be more eager to specialize, not necessarily inline.
15:37:31 <kuribas> Tuplanolla: in particular, I specialize a top level function, I'd like it to specialise the helper functions.
15:39:42 <Tuplanolla> Well, that I'm not sure can be forced as easily.
15:43:15 <kuribas> Ok, I'll manualy specialize them then...
15:53:12 <larnabell> is there a special syntax for sending a do block to an interpreter process as a string in Emacs?
18:04:04 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | cabal update stuck? http://mail.haskell.org/pipermail/haskell/2018-January/025325.html'
18:04:04 --- topic: set by geekosaur on [Sat Feb 03 00:04:44 2018]
18:04:16 <pikajude> hSeek is pretty high level as it is, lol
18:04:27 <pikajude> "Handle", "SeekMode" and "Integer" rather than a bunch of CInts
18:08:51 <erikd> is there a way to enable HasCallstack everywhere when building my project?
18:09:40 <Myrl-saki> How do I use persistent without the templateHaskell?
18:09:54 <Myrl-saki> The templateHaskell fails on ghcjs, which i assume makes sense.
18:18:23 <Axman6> erikd: not that I know of (I've thought about the same thing). I assume you're running with -prof?
18:18:56 <erikd> Axman6: about to recompile with -prof
18:19:48 <mtjmullen> What's the overhead of `HasCallStack`?
18:19:53 <Axman6> the docs on https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Stack.html#v:currentCallStack explain more
18:21:22 <Axman6> hmm, it's unclear to me if you need to run your app woth profiling turnd on or if just compiling it is enough
18:21:47 <Axman6> I have a feeling it's not necessary
18:23:26 <khouli> hello haskellers
18:23:48 <Axman6> erikd: there's some good info in the GHC guide too: http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=callstack#hascallstack
18:25:34 <Axman6> huh, the very last comment there is confusing when read in context of the GHC.Stack docs
18:26:24 <dmj`> khouli: hey
18:26:26 <erikd> i do already understanf HasCallStack, i jsut have a big hairy project i wannt use it on and hope i don't have to annotate the whole thing.
18:28:36 <khouli> how can/should I learn more about how GHC executes IO actions? I get to unsafePerformIO and hit deep magic that I can't find documented anywhere
18:29:03 <Axman6> erikd: I was thinking that if you have an app that uses mtl style, and you have a common constraint like type AppC m = (MonadReader DBConn m, MonadIO m, ...) it would be trivial to add that to the type alias and get the constaint everywhere, though it's not exactly great to use that sort of alias if you want to clearly document the effects any particular action uses
18:29:25 <khouli> below that, it seems like there are magic built-in types that the GHC compiler knows to treat in special ways
18:29:37 <Axman6> khouli: really you shouldn;'t care how GHC executes IO, anything below the IO type is an implementation detail
18:29:48 <Axman6> yes, that's exactly what happens
18:30:03 <Axman6> those details aren't really part of the public API
18:30:12 <erikd> Axman6: yeah, that will be my next step if the profiling buiild doesn't provide answers
18:30:26 <khouli> right, I get that it's not public API, but it still seems interesting
18:31:03 <khouli> there are academic papers on IO managers in GHC, is that maybe a good way to get a sense of what's going on under the covers without digging through every line of code?
18:31:23 <khouli> (I'm not sure if any of those papers reflect current GHC though)
18:31:24 <erikd> khouli: my understanding is that the code explicitly passess arounf a RealWorld token
18:33:58 <erikd> profiles compiles are *significantly* slower than regular ones :/
18:34:55 <how> nkaretnikov: I think the theorem you're trying to prove is not true.
18:35:36 <erikd> i think that makes it harder
18:49:11 <ab9rf> brunocad: i wrote some cheesy haskell to read minecraft world save files a while back that has to read from arbitrary places in files
18:49:41 <brunocad> ab9rf what did you use?
18:51:16 <ab9rf> hSeek, it appears
18:51:18 <ab9rf> had by both parties
18:51:20 <ab9rf> erf
18:51:24 <EvanR> mmap does have the benefit of not requiring the whole file to really be in memory, but it seems like it is
18:51:24 <ab9rf> https://github.com/ab9rf/mcareader/blob/master/src/Minecraft.hs#L239-L256
18:51:35 <ab9rf> if you want to see my (terribly bad) code
18:52:10 <ab9rf> i'd probably use mmap to do it now
18:53:25 <EvanR> where seems like it is means... you can access it via a Ptr :S
18:53:36 <EvanR> guess its not that great by itself, in haskell
18:54:59 <EvanR> you could hide an mmapped pointer inside a side-effecting, carefully locked function which does FFI when accessed
18:55:13 <EvanR> and pray?
18:55:42 <ab9rf> EvanR: i looked at using mmap for another program i was writing and ended up getting lost in twisty little passages
18:56:30 <ab9rf> i could not wrap muy head around the semantics
18:56:47 <ab9rf> the problem is that you can't unmap the file while anything has a live pointer into the mmap buffer
18:57:03 <ab9rf> and it's _very_ hard to manage object lifetimes in haskell
18:57:32 <EvanR> well, in this mad science experiment, youd only have 1 reference and its hidden in this function
18:57:49 <EvanR> unmap finalizer can be attached to that
18:57:53 <ab9rf> EvanR: even then you're still relying on the garbage collector to wrap up the reference and unmap the file
18:59:43 <brunocad> thanks for the example :)
19:00:00 <EvanR> all explicit managment plans ive seen look like a bracket and do something like phantom rank 2 types to enforce no smuggling...
19:00:13 <EvanR> at which point, you might be better off just using IO
19:01:01 <ab9rf> EvanR: that was the conclusion i came to
19:01:43 * EvanR looks at all the nice greener abstractions on the other side
19:01:55 * EvanR keeps working on the IO chain gang
19:02:00 <Rembane> Effects!
19:02:07 <metahumor> IOFx
19:05:41 <ab9rf> EvanR: i could probably make it work for the minecraft example because minecraft chunk data is LZW-compressed and so the only thing you do with the actual file data is throw it into the uncompressor. there's not going to be any dangling subsequence references after that. but there just wasn't enough benefit to mucking with mmap
19:08:08 <f-a> hello. I am writing a small program. I would like, once compiled (with, say, cabal new-build) to have the binary moved in a specific folder.
19:08:34 <f-a> I usually do it quick and dirty with a .sh script, but this time the program needs to run on different platforms
19:09:17 <f-a> how can I achieve that? I don't even know what libraries to check. Maybe shake/
19:09:17 <f-a> *?
19:11:04 <lyxia> f-a: cabal has a --bindir option and stack has --local-bin-path
19:11:33 <ab9rf> i knew there was an option just couldn't remember what it was
19:13:52 <f-a> thanks lyxia , do you also know if this is something I can put in my .cabal file?
19:17:22 <lyxia> I don't think so.
19:17:33 <EvanR> Setup.hs ?
19:19:29 <f-a> thanks EvanR
20:15:03 <crysikrend> Hey, is anyone here? Really need some help (pretty new to Haskell). Been doing some refactoring as my original modules was really awkward to use so I'm trying to slim things down a bit. I pass the filepath into a function that will retrieve some data in the form of JSONFile -> IO (Maybe [AnimationSetData]). I need to map a function onto the data and remove the Maybe to return IO [AnimationSet]. I had this
20:15:05 <crysikrend> function working previously, but trying to remove the Maybe is a little difficult for me. I previously did it all in one line, but now as I'm working through the problem I've seperated it up as I couldn't find a way to do it with >>= yet.
20:15:25 <crysikrend> http://lpaste.net/363484
20:15:51 <dminuoso> crysikrend: Lets step back for a second and think about why you are doing this.
20:16:14 <crysikrend> okay :)
20:16:24 <dminuoso> crysikrend: Let's pretend for a second a `Nothing` is produced by the IO action. What do you want to happen?
20:18:25 <crysikrend> I won't need it, I just want to produce a list of working animations. The reason that the thing produced is a maybe, is that I have other functions I can use to debug it, but this function is for the game itself and I have no need for nothings. If I keep it, it just makes my code really complicated, I'd prefer to just remove the maybes if I can
20:19:22 <crysikrend> I don't know if that makes sense, but, lets say in my game I load all the animations from a file. In ghci I can call some things that aren't in Main to work out whats gone wrong etc, but the game itself will simply spit something to the console and continue
20:20:09 <metahumor> crysikrend: what if the JSONFile is parsed in a way that it can't generate [AnimationSetData]?
20:21:18 <dminuoso> crysikrend: Remember that `Maybe` models exceptions. My having a `Maybe` in there, you acknowledge the possibility of failure - you can't make it safe again by pretending it's not possible to fail.
20:22:09 <dminuoso> crysikrend: However, the second you layer monads the possibility of monad transformers arise, so thats something you could take a look into.
20:23:04 <dmj`>  fmap (fromMaybe []) $ fmap (fmap convertToAnimationSet) <$> getAnimationDataFromJSON (JSONFile jsonFile)
20:23:28 <crysikrend> Maybe you're right, but as a beginner I'm really struggling with the amount of monads
20:23:56 <dminuoso> crysikrend: Look into monad transformers then. Tossing Maybes away to make things pleasent might not be a good idea.
20:24:32 <dminuoso> crysikrend: Especially with MTL you can seamlessly combine monad effects, you only need to lift IO actions.
20:24:52 <metahumor> i'd also suggest breaking the body of "getSDLAnimationSetsFromJSON" into simpler blocks
20:25:23 <metahumor> there's a TON going on on that "pure (foldr ...) line
20:25:40 <crysikrend> Yeah, I probably shouldn't be trying to oneline everything
20:25:43 <crysikrend> http://lpaste.net/363485
20:25:43 <dmj`> I’d suggest the first parameter of getSDLAnimationSetsFromJSON be the newtype JSONFile, as opposed to FilePath
20:25:56 <crysikrend> that was how it was before
20:26:25 <metahumor> why not write a couple of top level functions?
20:26:32 <crysikrend> and i'm trying to refactor it. This is my first ever module, after reading all of haskellbook I'm trying to put it into practice, but I'm struggling with the whole monads thing as you can probably tell with the code
20:26:56 <crysikrend> I hope that as soon as I've finished with all the monad stuff I can start writing the nice pure functions for the game, but without things appearing on screen it's annoying
20:27:17 <dminuoso> crysikrend: Use monad transformers.
20:28:35 <crysikrend> I think I'm just a bit frustrated, sorry for probably being pretty bad at all this.
20:28:39 <metahumor> crysikrend: more specifically, if you are dealing with IO (Maybe a), you could transform it to "MaybeT IO a"
20:28:47 <metahumor> crysikrend: but i'd break apart the functions first
20:29:06 <metahumor> just turn all those 'where' functions into toplevel functions
20:29:24 <crysikrend> I don't know where I got it into my head that having multiple lines is a bad thing, I guess I got 'simplifying' mixed up
20:30:05 <crysikrend> So you all reccomend that I actually leave in the maybes?
20:30:13 <metahumor> yeah, that was my style when i was first learning haskell: "oh the language lets me put all on one line with these operators"
20:30:35 <metahumor> crysikrend: well if you separate it out, it'll be clearer where the Maybe is being generated
20:30:48 <dminuoso> crysikrend: Make `AnimationData` a Functor.
20:31:07 <dminuoso> crysikrend: So you dont have to manually unpack, map on internal things, and pack back up again
20:31:14 <metahumor> and then you can decide whether to figure out how to deal with the Maybe, or lift the Maybe to wrap your entire animation code
20:31:15 <crysikrend> The thing I dislike is not being able to probe at things because it's in a do block, like I can't query things easily with ghc and my errors are really hard for me to read
20:31:42 <dminuoso> crysikrend: That's the point of making small functions that dont do IO :)
20:31:47 <dminuoso> Makes it easier to test those things,
20:31:49 <metahumor> crysikrend: right, so if you have the functions as top level, you can run IO actions in ghci, and then try things out
20:34:07 <dminuoso> crysikrend: convertToAnimationSet for example smells like `AnimationSet` (Sorry I shouldnt have said AnimationData) might be a Functor?\
20:34:36 <crysikrend> Yeah, I think I got carried away when writing this. I learned a lot about fmap and >>= etc, but it's a little taxing on my head to keep it up
20:35:13 <dminuoso> crysikrend: a Functor is basically just something you can "(f)map over its contents" in a meaningful way. =)
20:35:28 <crysikrend> dminuoso: Yeah, that's probably a good shout. As I said I've read about functors and monads but I never put it into practice so this is tough
20:36:49 <crysikrend> Thank you. Literally the only difference between data and my own animation class, is that AnimationSet contains SDL rectangles which I can't serialise into JSON, whereas the data class is made just with ints, and then I convert the data into useful SDL stuff in runtime
20:38:29 <crysikrend> it really sucks not really having a teacher
20:38:44 <crysikrend> I struggle to learn like this
21:01:09 <progfunhere> hey guys
21:01:12 <progfunhere> good morning
21:01:14 <crysikrend> Hey
21:01:17 <crysikrend> Hows it going
21:01:26 <progfunhere> Good
21:01:47 <crysikrend> Good :) I'm kinda stressed
21:01:50 <progfunhere> I'm also a Haskell padawan
21:02:10 <crysikrend> how far in are you?
21:02:21 <crysikrend> I'm rubbish :'D
21:02:27 <progfunhere> Haha
21:02:41 <dminuoso> Axman6: Functions taking multiple arguments behave somewhat differently, in that strict pattern matching doesn't kick in until all arguments have been applied
21:02:58 <progfunhere> I'm learning functors, applicatives, etc
21:03:06 <dminuoso> In that sense they are rather partially applied than fully curried.
21:03:30 <Axman6> __never__ :P
21:03:43 <progfunhere> so not as far along as you are, crysikrend
21:04:03 <crysikrend> I read about those things, but i found it hard to visualise, we're at the same level probably
21:04:13 <crysikrend> im doing it practically now and sucking at it
21:04:29 <progfunhere> I know it's hard going
21:04:47 <progfunhere> but the joy of getting it in the end is well worth the effort!
21:05:13 <dminuoso> > let f = \[] a -> a in f undefined `seq` 1
21:05:15 <lambdabot>  1
21:05:16 <dminuoso> > let f = \[] -> a -> a in f undefined `seq` 1
21:05:19 <lambdabot>  <hint>:1:18: error: parse error on input ‘->’
21:05:22 <progfunhere> Follow KISS
21:05:24 <dminuoso> > let f = \[] -> \a -> a in f undefined `seq` 1
21:05:28 <lambdabot>  *Exception: Prelude.undefined
21:05:33 <dminuoso> Axman6: Id say they are clearly different. :P
21:05:35 <progfunhere> Rather just KISS
21:06:04 <Axman6> implementation detail!
21:06:27 <dminuoso> Im fairly sure the standard says this..
21:06:34 <Axman6> but anyway, when learning Haskell, many, many problems are solved by remembering functions only take one argument
21:06:44 <dminuoso> I guess you are right :)
21:06:44 <Axman6> yeah you might be right
21:06:44 <progfunhere> OK
21:07:03 <Axman6> but it's the stance we take on the Data61 course and it works very well
21:07:30 <Axman6> it's particularly when people are trying to learn about Applicative and they see things like fmap <function of "two" arguments>
21:07:31 <dminuoso> Axman6: I suppose that lie is kind of fine. It will be taken down the second they meet this problem and run off to Stackoverflow.
21:07:48 <Axman6> particularly useful*
21:07:49 <crysikrend> The hardest thing for me is the compiler. It's always 'expected vs actual' and it's up to me to figure out why this is the case. It's better than having errors occur ingame, but it takes a lot of time to get used to
21:08:57 <dminuoso> crysikrend: Once you wrap your head around the compiler diagnostics, usually they are pretty fine. Though due to how type inference works (trying to always find the most general type), frequently type errors dont happen at the site where they are caused, but rather at the site where the type checker cant make sense of it anymore
21:09:32 <dminuoso> crysikrend: One thing that can help, is adding more type annotations as a kind of mental check, to see whether your expectations are correct.
21:09:33 <progfunhere> Makes sense
21:10:19 <crysikrend> Yeah, I have tried that tactic before but the one lining method I was attempting wasn't for ne
21:12:45 <progfunhere> :t seq
21:12:46 <lambdabot> a -> b -> b
21:16:19 <progfunhere> I'm starting to implement a function to calculate the partitions of numbers
21:16:23 <progfunhere> https://brilliant.org/wiki/partition-of-an-integer/
21:16:32 <crysikrend> sounds smart
21:16:32 <progfunhere> and need some help
21:16:34 <crysikrend> Im making games :p
21:16:49 <progfunhere> Sound like more fun :-)
21:17:06 <progfunhere> I know that partitions are recursive
21:17:22 <progfunhere> but just can't wrap my head around where to begin
21:17:29 <progfunhere> any pointers?
21:17:39 <progfunhere> I'm not looking for a full solution
21:17:51 <progfunhere> just someone to point me in the right direction
21:18:11 <crysikrend> have you actually done anything yet?
21:18:14 <crysikrend> Or are you at square one?
21:18:34 <progfunhere> I've written the quickcheck test cases
21:18:38 <progfunhere> 2 of them
21:18:55 <progfunhere> now going to implement the function itself
21:19:27 <progfunhere> so pretty much at square one regarding the function
21:19:29 <crysikrend> So one important thing about this problem is the idea that you need to represent the answer as a 'picture'
21:19:49 <progfunhere> how so?
21:19:49 <crysikrend> Unless you're looking for calculating the 7 bit?
21:20:08 <crysikrend> Are you trying to draw the picture as they've done, or are you simply trying to get the partition?
21:20:48 <progfunhere> Just the numbers
21:20:52 <progfunhere> Eg: partitions 4 = [[1,1,1,1],[1,1,2],[1,3],[2,2],[4]]
21:20:53 <crysikrend> Okay, a bit easier
21:21:24 <progfunhere> Partitioning is recursive
21:21:43 <progfunhere> so to partition a number you need to partition each part also in turn
21:22:58 <crysikrend> I need to read up on it myself firstly so I understand the methods
21:23:03 <crysikrend> and then I'll tell you where I'd start
21:23:38 <crysikrend> Okay I get it
21:23:46 <progfunhere> should I use a list comprehension?
21:24:10 <progfunhere> or pattern matching?
21:24:14 <boj> you probably want a function to recurse through
21:24:18 <crysikrend> yeah
21:25:10 <progfunhere> what should that function do?
21:25:24 <progfunhere> partition 0 = 1
21:25:30 <progfunhere> partition 1 = 1
21:25:35 <progfunhere> the base cases
21:26:00 <boj> what would you do >1 ?
21:26:58 <progfunhere> I would try to keep partitioning >1 until I hit the base case for 1
21:27:10 <boj> what does that look like?
21:27:36 <progfunhere> Having a hard time visualising it
21:28:13 <progfunhere> How to get that as a nested list of lists ?
21:28:33 <crysikrend> I would have a 'master function' which recursively checks if the operation is done, and if not call itself again. You start with a list containing your target number. It asks if all the ints in the list are 1, and if not, it will call the shift function and then check again, passing in the list to itself to reavaluate. By that logic, you will return 'yourFunction yourList', and your base cases will stop the
21:28:34 <crysikrend> recursion.
21:28:55 <dminuoso> progfunhere: The general idea is that while you recurse, you just produce a single item.
21:29:02 <dminuoso> :t (:)
21:29:04 <lambdabot> a -> [a] -> [a]
21:29:21 <progfunhere> OK
21:29:30 <dminuoso> progfunhere: Start by figuring out the type of `partition`
21:30:04 <progfunhere> partition :: Int -> [Int]
21:30:28 <boj> there you go
21:30:31 <dminuoso> progfunhere: So it takes a number, and makes a list of numbers?
21:30:35 <dminuoso> progfunhere: Are you sure about that? =)
21:31:13 <progfunhere> yes, in it's most basic form
21:31:53 <progfunhere>  partitions :: Int -> [[Int]]
21:32:07 <progfunhere> would call partition above
21:32:11 <progfunhere> am I right?
21:36:41 <progfunhere> any thoughts?
21:38:13 <dminuoso> progfunhere: You dont need a helper function
21:38:22 <progfunhere> OK
21:39:28 <dminuoso> progfunhere: You can trivially do this with a list comprehension and recursion
21:39:50 <dminuoso> Well. Maybe not trivially.
21:53:26 <crysikrend> Does anyone have experience with Foreign.C.Types? How would you go about converting an Int to a CInt?
21:53:41 <EvanR> with fromIntegral
21:53:47 <crysikrend> that easy? Okay :)
21:54:16 <dmj`> :t fromIntegral :: Int -> Foreign.C.CInt
21:54:18 <lambdabot> Int -> Foreign.C.Types.CInt
21:54:39 <crysikrend> Did the  trick, thank you :)
21:54:46 <EvanR> and hope there is a special rule somewhere which makes that sort of no-op
21:55:11 <EvanR> if CInt is 64 bits
22:12:59 <dminuoso> F :: * -> TYPE 'GHC.Types.IntRep
22:13:04 <dminuoso> What's that tick ' doing there?
22:13:27 <dminuoso> https://hackage.haskell.org/package/ghc-prim-0.5.1.1/docs/src/GHC.Types.html#RuntimeRep
22:13:58 <EvanR> sometimes with DataKinds the usage is ambiguous
22:15:08 <EvanR> is your link supposed to have the example?
22:15:40 <dminuoso> EvanR: No I just linked it to denote where IntRep comes from.
22:15:50 <dminuoso> EvanR: Im getting that type annotation from my type family
22:15:54 <EvanR> IntRep could be a value or a type, prime means its the type
22:16:40 <dminuoso> EvanR: Ahh, gotcha.
22:17:41 <dminuoso> EvanR: The hint with DataKinds was helpful. The GHC manual calls that type a "promoted constructor" :)
22:17:57 <dminuoso> Or Kind rather I guess.
22:18:15 <EvanR> its not a kind, RuntimeRep would be the kind
22:19:27 <dminuoso> EvanR: I dont follow. Im inspecting the kind of a type family, and Im getting `* -> TYPE 'GHC.Types.IntRep`
22:19:40 <dminuoso> Are the `*` and `TYPE 'GHC.Types.IntRep` not both kinds?
22:20:05 <EvanR> :k TYPE
22:20:07 <lambdabot> error:
22:20:07 <lambdabot>     Not in scope: type constructor or class ‘TYPE’
22:20:29 <dminuoso> Does DataKinds imply TypeInType
22:20:37 <EvanR> no
22:21:13 <EvanR> TYPE Foo is a kind, but i cant seem to remember what nonsense it is specifically
22:21:30 <EvanR> it takes a type argument
22:22:20 <EvanR> ok
22:22:34 <EvanR> TYPE whatever is from LevityPolymorphism
22:24:07 <EvanR> TYPE takes a RuntimeRep and gives a kind, the kind of things with that runtime rep
22:25:21 <EvanR> now you can write polymorphic functions that work not only on lifted types (kind *) but unlifted (like unboxed)
22:25:55 <EvanR> im not sure to what extent it entirely to formalize the $ hack
22:26:04 <EvanR> it exists entirely to*
22:27:59 <dminuoso> EvanR: I understand levity
22:28:19 <dminuoso> EvanR: There's something fishy going on
22:28:26 <dminuoso> TYPE :: RuntimeRep -> *
22:28:56 <dminuoso> So if RuntimeRep is a (promoted) kind, that is inhabited by some type 'IntRep
22:29:18 <EvanR> Type IntRep = *, i would believe
22:30:16 <jasperh> @free fmap :: (a -> b) -> (F a -> F b)
22:30:16 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
22:30:26 <jasperh> *clap* *clap* *clap*
22:30:38 <EvanR> but Twait
22:30:52 <dminuoso> EvanR: Well I would have expected TYPE to be something of BOX -> BOX
22:30:57 <EvanR> if it has an IntRep then its not lifted, so it cant be *
22:31:20 <EvanR> if BOX even still exists, TYPE :: RuntimeRep -> BOX
22:31:32 <jasperh> @free cps :: (a -> b) -> b
22:31:32 <lambdabot> g . h = k . f => g (cps h) = cps k
22:31:36 <dminuoso> EvanR: There's so much universe confusion going on.
22:31:46 <dminuoso> Can type families also produce kinds?
22:31:57 <EvanR> i think so
22:32:04 <sl2c> @free ap :: F (a -> b) -> (F a -> F b)
22:32:04 <lambdabot> (forall h. (forall k p. g . k = p . f                        =>                         h k = p)           =>            $map_F h x = y) => $map_F g . ap x = ap y . $map_F f
22:32:21 <jasperh> @free cps :: (int -> a) -> a
22:32:21 <lambdabot> g . h = k . f => g (cps h) = cps k
22:33:28 <EvanR> its universes all the way up
22:34:58 <dminuoso> type family F a where F Int = RuntimeRep
22:35:00 <dminuoso> F :: * -> *
22:35:32 <EvanR> you have to specify F's kind first
22:35:38 <EvanR> or else itll default to * -> *
22:36:09 <dminuoso> EvanR: Yeah but if RuntimeRep itself is a kind, how does this typecheck?
22:36:21 <EvanR> RuntimeRep in that situation is a type not a kind
22:36:40 <dminuoso> This is `data` confusion all over again :D
22:37:07 <EvanR> specify a kind signature for F that sends types to kinds and try again
22:37:42 <woodson> how would one go about making sure that any data type that is created must define a certain field function?
22:38:10 <woodson> so for example every record must have a name field ?
22:38:14 <Axman6> field function?
22:38:27 <Axman6> sounds like a classy lens to me
22:38:48 <EvanR> f :: HasName a => a -> Whatever
22:39:23 <dminuoso> Is there a way to observe the `sort` of a kind?
22:39:24 <woodson> so, Account { name :: Text} , Book { name :: Text}
22:39:49 <EvanR> they are all BOX right
22:40:14 <EvanR> * :: BOX
22:40:15 <dminuoso> EvanR: Right, I just want to be able to.. "look at things" and be sure Im in the right universe
22:41:27 <woodson> Axman6: haven't really used lens, How would it look like ?
22:45:19 <Axman6> class HasName s where name :: Lens' s Text, and then you can have instances of that class and use it as a constraint on functions you're expecting to be able to handle all things with a name
22:46:12 <Axman6> then you can have data Book { _bookName :: Text, ...}; $(deriveLenses ''Book); instance HasName Book where name = bookName
22:46:46 <dminuoso> EvanR: Think I may be understanding it. Does kind promotion mean that the whole thing from `data` is "copied" into the next universe, so that my data constructors have equivalent type constructors, and my type constructor has become an equivalent kind constructor?
22:46:54 <EvanR> yes
22:47:07 <EvanR> it makes a new kind
22:47:31 <EvanR> confusingly, with all the same names as the original entities which are still available
22:47:35 <dminuoso> EvanR: I see, so basically ' lets me access the "promoted" (copied into the next universe) version.
22:47:47 <EvanR> yes
22:47:58 <EvanR> hence, '[] and ':
22:48:08 <dminuoso> EvanR: That makes even more sense now. :)
22:48:21 <dminuoso> Curious, that would suggest ths sort of '[] is actually BOX -> BOX -> BOX
22:48:40 <dminuoso> Err, the sort of [*] mmm
22:48:46 <dminuoso> No, []!
22:48:48 <EvanR> '[] :: [*]
22:48:59 <dminuoso> EvanR: This is quite confusing indeed.
22:49:00 <EvanR> or maybe its polymorphic
22:49:13 <EvanR> '[] :: forall k :: [k]
22:49:18 <EvanR> '[] :: forall k . [k]
22:49:32 <EvanR> yes i welcome out new dependently typed overlords
22:49:48 <dminuoso> EvanR: Ive tried to even think about TypeInType.. I got soooo confused.
22:50:25 <EvanR> TypeInType potentially makes all this a lot easier
22:50:49 <dminuoso> Alright, with that knowledge in mind
22:51:06 <dminuoso> Haha
22:51:10 <dminuoso>  Note that promoted datatypes give rise to named kinds. Since these can never be ambiguous, we do not allow quotes in kind names.
22:51:21 <EvanR> ah
22:51:37 <EvanR> ' is for data constructors only
22:51:42 <dminuoso> Yeah. Even more confusing.
22:52:00 <dminuoso> For a second I thought I could use ' as a clue to "see the promoted kind/type"
22:52:27 <EvanR> that would be a natural thing to expect... but...
22:53:46 <crysikrend> Is using case statements a sign of doing something wrong?
22:53:50 <dminuoso> TYPE :: RuntimeRep -> *
22:54:08 <EvanR> with TypeInType, sure
22:54:13 <dminuoso> Okay so this makes sense then, gotta pass some type of kind RuntimeRep such as 'IntRep or 'LiftedRep
22:54:31 <dminuoso> (Because they are the types that inhabit the kind RuntimeRep)
22:54:43 <dminuoso> Consistently that should have read: TYPE :: 'RuntimeRep -> *
22:55:48 <EvanR> if you dont have * :: *, then TYPE sends RuntimeReps to kinds
22:55:52 <EvanR> not *
22:57:52 <woodson> Axman6: This means that the user will always have to setup the constrain and also derive lens when making a data record?
22:58:38 <woodson> is there some way to automate or set some sort of default?
23:01:31 <jackdk> last time I had a problem like that I wrote some TH to generate the instances, but it was a bit gnarly and project-specific
23:02:39 <dminuoso> EvanR: Alright I still dont get how this can typecheck. There's a weird mixing of the kind and type universe going on. If `TYPE :: RuntimeRep -> *` , then TYPE produces something that lives in the type universe. How does this work with:  F :: * -> TYPE 'GHC.Types.IntRep
23:02:50 <dminuoso> EvanR: The latter implies that whatever TYPE produces is a kind.
23:03:05 <dminuoso> Am I making any sense?
23:05:08 <EvanR> i do not see where TYPE :: RuntimeRep -> * is coming from
23:05:19 <EvanR> yes, TYPE myRep is a kind
23:05:24 <dminuoso> data TYPE (a :: RuntimeRep) :: RuntimeRep -> *
23:05:26 <dminuoso> as per https://hackage.haskell.org/package/ghc-prim-0.5.1.1/docs/GHC-Types.html
23:05:35 <EvanR> thats why its used in a kind ->
23:05:40 <dminuoso> Though Im beginning to wonder whether that was just a haddoc hack for something really internal
23:05:59 <EvanR> haddock does have some issues rendering polykind stuff
23:06:24 <dminuoso> The only way `TYPE` makes sense, if it's a cross universe `* -> BOX` thing
23:06:58 <crysikrend> I really hate to interrupt but could someone quickly look to see where I'm going wrong? Error message included in paste, it'll be something silly
23:07:00 * EvanR still looking for what you quoted
23:07:00 <crysikrend> http://lpaste.net/363488
23:07:25 <dminuoso> EvanR: Just hit `:t TYPE` in ghci after importing GHC.Types
23:07:34 <dminuoso> Or just search for it on the link I gave you
23:07:34 <crysikrend> I feel like I'm doing something wrong using case statements but i'm not really sure how else to think about it
23:07:40 <EvanR> trying
23:07:44 <dminuoso> Err, `:k TYPE` I guess
23:07:49 <EvanR> its reexporting from somewhere
23:08:21 <EvanR> i dont see data TYPE anywhere
23:08:50 <dminuoso> I mean.. lets try..
23:09:05 <dminuoso> > a :: TYPE Int
23:09:08 <lambdabot>  error:
23:09:08 <lambdabot>      Not in scope: type constructor or class ‘TYPE’
23:09:10 <EvanR> so, * = TYPE LiftedRep
23:09:31 <dminuoso> > a :: TYPE 'IntRep
23:09:34 <lambdabot>  error:
23:09:34 <lambdabot>      Not in scope: type constructor or class ‘TYPE’
23:09:34 <EvanR> as i understood it TYPE doesnt have a real kind of its own
23:09:35 <dminuoso> That works.. uh
23:09:56 <EvanR> it is simply a way to talking about various types with reified names for reps
23:10:24 <dminuoso> EvanR: And it seems to have the ability to implicitly promote into a kind.
23:10:31 <EvanR> you are correct it would be crossing universes and that makes no sense
23:10:39 <EvanR> it does
23:11:44 <EvanR> its a magic part of LevityPolymorphism
23:11:59 <dminuoso> Yeah I guess. This thing is truly magic.
23:12:28 <dminuoso> For now Ill just imagine `TYPE :: RuntimeRep -> BOX` =)
23:12:41 <EvanR> its ok for stuff to not fit literally into the type system, they just would rather not have to have more special cases in the compiler
23:13:14 <EvanR> informally sure but that type has nowhere to live :)
23:13:54 <guest_> hi guys i have a , b, c and d modules under direcory f, a contains some fuctions that should be used in b, c and d how to import a in b,c and d please help
23:15:45 <EvanR> type (★) = TYPE LiftedRep , heh... combining legacy support with unicode support
23:15:51 <EvanR> kaboom
23:16:19 <EvanR> guest_: just import a in them
23:16:53 <guest_> EvanR: it gives error a is not  in scope
23:17:08 <EvanR> lpaste code and the error message
23:17:13 <EvanR> @where lpaste
23:17:13 <lambdabot> http://lpaste.net/
23:19:12 <EvanR> dminuoso: i think you have your answer over there under KindRep
23:19:41 <EvanR> one of the kinds (reps) is KindRepTYPE !RuntimeRep
23:22:19 <kahlil29> when using record-syntax, what does an exclamation (bang) before the type signify?
23:22:48 <EvanR> its a strict field
23:23:00 <kahlil29> EvanR: thanks
23:23:15 <EvanR> was that your homework or
23:28:07 <Lears> crysikrend: (x:_) is a list and [y] is too, so [x:_] is a list of lists, which I gather from the error message is not what you want there. You may also be interested in the function `listToMaybe` from Data.Maybe. It should probably just be called "head" but that would conflict with prelude.
23:49:01 <crysikrend> Lears: sorry yeah I already found that! I didn't realise anyone had noticed me, but thank you! Now I'm just trying to debug my code now that it compiles, first time i've ever run it :p
23:49:45 <cocreature> crysikrend: you’re saying your code compiles and it’s still not correct? didn’t you know that this is impossible? ;)
23:50:20 <crysikrend> Well, its possible if you define a rectangle as xyxy rather than xywh ;)
23:50:29 <crysikrend> wasn't a difficult one :P Lets hope round two works!
23:50:51 <crysikrend> I think I'll chill in this IRC more often, the FP discord server is fun but there's a lot of chatter in hear that's not just me all the time
23:51:13 <crysikrend> WE GOT IT
23:51:18 <crysikrend> SHIIIET
23:51:41 <crysikrend> despite all the problems I had, that was easier than it would have been if it was the first time I had used SDL and C++ together
23:52:42 <crysikrend> Although, my filtering doesn't work, so i need to have a look still
23:54:02 <Lears> Oh, a followup to my point about listToMaybe -- actually it would be better to just skip it and go straight to `find`.
23:55:14 <crysikrend> never knew about that
23:55:19 <crysikrend> cute function
23:57:15 <sl2c> ?hoogle find
23:57:15 <lambdabot> Data.List find :: Foldable t => (a -> Bool) -> t a -> Maybe a
23:57:15 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
23:57:15 <lambdabot> GHC.OldList find :: (a -> Bool) -> [a] -> Maybe a
