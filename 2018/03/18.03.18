00:46:52 <sternmull> I read that Data.Fix (https://hackage.haskell.org/package/data-fix-0.2.0/docs/Data-Fix.html) can be useful when adding annotations to an AST. But i don't understand the type. How do i even construct a List in the example that is given?
00:52:58 <EvanR> data ExprF f = I (f Int) | Plus (f (ExprF f)) (f (ExprF f))
00:53:00 <EvanR> hmm
00:53:24 <EvanR> ExprF Identity, no extra info
00:53:40 <EvanR> ExprF (String,), each node now has a String too
00:53:47 <EvanR> something like this
00:55:57 <EvanR> if it were... data ExprFF f a = I (f Int) | Plus (f a) (f a)
00:56:14 <EvanR> then you could do ExprF f = Fix ExprFF
00:56:26 <EvanR> which would compute to the above
00:56:39 <EvanR> then you could do ExprF f = Fix (ExprFF f)
00:57:27 <EvanR> the F version of a recursive data type takes a new 'a' parameter and uses that wherever there would have been a recursive occurrence of itself, then Fix puts it back
00:57:28 <sternmull> i understand the concept. But i don't see how to create a value of that type (see the list example in the documentation).
00:58:00 <EvanR> ok
00:59:03 <sternmull> I can't just use the constructors of L to create a List. So how do you do it?
00:59:40 <EvanR> to create a concrete version of List a, you would do Fix Nil
01:00:02 <EvanR> or Fix (Cons 'z' (Fix Nil))
01:00:28 <EvanR> is a List Char
01:01:18 <EvanR> the Fix library lets you factor out the recursion, but it means you have to write these Fix ctors everywhere
01:01:54 <sternmull> thank you! That was the missing peace of the puzzle.
01:02:57 <EvanR> i saw a blog post claiming doing this increases performance... "by letting ghc unroll loops" or something
01:03:00 <EvanR> but i am skeptical
01:03:33 <sternmull> s/peace/piece/ :)
01:04:04 <EvanR> the peace puzzle
01:04:48 <sternmull> At the moment i absolutely don't care about performance. I want to maximize convenience/readability/maintainability while playing with a toy parser/compiler.
01:06:14 <sternmull> Would you recommend using Fix at all? I am trying to get stuff done... but spend 99% of my time learning about Haskell features for which i can't say if they be actually be helpful for me now.
01:08:04 <ongy> get stuff done, worry about these things later. Tehre's *a lot* of things in Haskell and the ecosystem. It's certainly not easy for people new to all of it to see which ones are worth their time
01:08:37 <EvanR> sternmull: in my first example i included an annotation functor, the structure is explicitly recursive and doesnt need Fix
01:08:58 <EvanR> you wont have to put Fix ctors, of course you will have to put annotations
01:09:19 <EvanR> like Identity
01:09:25 <EvanR> but thats not for the same purpose
01:10:10 <EvanR> however!!! by using Fix i believe you will get the benefit of ready made recursion schemes
01:10:25 <EvanR> which is probably handy when doing compiler stuff
01:10:31 <sternmull> Your annotation functor is a type constructor with the "node data type" as argument, right?
01:11:01 <EvanR> yes instead of just being there, the node data is wrapped in an annotation
01:11:05 <sternmull> yes handy... but i have learn what a catamorphism and whatever is... i think.
01:11:17 <EvanR> catamorphism = fold
01:11:53 <sternmull> it probably sounds stupid... but why not just calling it "fold" then? :)
01:12:31 <EvanR> well, its fold when you are talking about something thats Foldable
01:13:39 <EvanR> cata works on anything implemented as Fix, so not necessarily foldable, but yeah
01:14:04 * EvanR stops read about this because its at distraction nesting depth 9 and 3 AM
01:14:36 <sternmull> so it is a generalized fold... wikipedia explains it in terms of homomorphism... down the rabit hole i go again.
01:14:57 <srk> :D
01:16:13 <EvanR> just start writing your compiler without it, then become angry each time you manually write a catamorphism :)
01:16:14 <sternmull> is there a practical introduction or overview to the basics of category theory that are helpful to know when using Haskell?
01:16:16 <ongy> sternmull: didn't you say something about getting things done?
01:16:24 <EvanR> otherwise you wont appreciate it
01:17:26 <EvanR> this might be a good guide at this point https://www.willamette.edu/~fruehr/haskell/evolution.html
01:17:37 <ongy> mhe, I need to change a few `mapM (liftIO . act)` to `(liftIO . mapM act` and look at the compiler output
01:17:50 <sternmull> ongy: Yes... but i struggle all the time between "use what you know and just do the shit" and "learn how to do it in a reasonable way".
01:18:10 <srk> sternmull: I've just opened https://www.youtube.com/watch?v=I8LbkfSSR58 https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
01:18:44 <ongy> we don't have N+K patterns anymore though
01:18:49 <srk> today feels like a good day for some categories :D
01:19:13 <sternmull> maybe, thanks for the links.
01:19:44 <EvanR> "today is a good day to di"--agram chase
01:21:37 <ongy> can someone explain the "but does it commute" joke to me btw? I've been around here for 3 years now, and I still have no idea what it's about
01:24:48 <JoshS> Sounds like a mathematician's version of "does it blend?"
01:28:19 <EvanR> when a diagram commutes, it could represent any number of familiar mathematical laws
01:28:56 <EvanR> as i understand it, category theorists like to rewrite everything as diagrams
02:17:18 <robstr_> what is the way to invoke a function every x hour's ? threadDelay or is it better to use something different ?
02:23:50 <Younder> Create a thread and put it to sleep. The OS will then put  the thread to sleep until the function need to kick in.
02:25:34 <robstr_> Younder: with threadDelay right ?
02:26:49 <Younder> Maybe, The problem isn't Haskell specific. The last time I did this was in C.
02:27:42 <robstr_> Younder: +1
02:42:51 <robstr_> I'm using stack, I tought the lts version specifies which versions to take, now I added `rotating-log` to my cabal file and receive `rotating-log must match -any, but the stack configuration has no specified version (latest matching version is 0.4.3)` Did i missunderstood the setup ?
02:43:38 <cocreature> robstr_: the error message means that rotating-log is not part of the packages in the lts snapshot that you’ve specified. you need to add it to extra-deps
02:44:17 <robstr_> cocreature: Ok, is there a way to see this on the hackage page ? Or is it always try ?
02:47:24 <reactormonk> https://github.com/commercialhaskell/intero doesn't export any libraries, but I wanna use the code as a library - how do I hack that?
02:48:56 <cocreature> robstr_: hackage has a "Distributions" section that shows the latest version of a package in stackage lts and nightly. you can also take a look at the package list for a specific snapshot, e.g., https://www.stackage.org/lts-11.1
02:49:22 <cocreature> robstr_: although just trying it out is usually easier
02:54:29 <robstr_> cocreature: thank you :+1
03:07:44 <[exa]> what's the easiest/simplest/most recommended way to modify an official cabal package and use the modified version on my system?
03:09:46 <srk> [exa]: via stack.yaml if you're using stack
03:10:33 <srk> nix is another option :)
03:11:02 <[exa]> I was hoping for not going that brutal
03:11:30 <[exa]> with stack, I guess I just tell it to take the package from somewhere else than stackage and it will work?
03:12:31 <kosmikus> [exa]: yes, with stack, I'd probably make a local or remote copy, apply the patch and point to that; with cabal new-build, I'd make a local copy, apply the patch, and point to that; with nix, one can also specify an actual patch to be applied to the package on-the-fly during the build
03:13:57 <srk> [exa]: stack unpack <packagename> then add the directory to packages: section in stack.yaml
03:14:20 <[exa]> ok gonna try
03:16:58 <asheshambasta> Whats the best way to debug things in Haskell?
03:17:11 <[exa]> asheshambasta: Debug.Trace if you like the unixy way
03:17:17 <asheshambasta> I'd like to be able to set breakpoints, inspect values etc.
03:17:40 <cocreature> asheshambasta: there is a debugger in ghci but it’s a bit akward to use
03:17:48 <cocreature> Debug.Trace is usually easier ime
03:18:02 <[exa]> asheshambasta: that works much better in imperative languages. Breakpoints don't make much sense in haskell
03:18:10 <asheshambasta> cocreature, [exa]: yeah, I'm a beginner in Haskell and tbh the debugging could be better
03:18:20 <asheshambasta> (I come from Scala where tooling is pretty amazing)
03:18:21 <[exa]> asheshambasta: still you can run parts of code in ghci manually to check why they fail
03:19:09 <kosmikus> for the Semigroups->Monoid superclass change in GHC 8.4, is there are documented backwards-compatible migration path that avoids depending on the semigroups package?
03:19:25 <asheshambasta> its quite a stateful application in by case (requires configs for encrypting/decrypting stuff, so its a bit of a pain to use that in GHCi
03:19:28 <asheshambasta> but I'm going to try
03:19:31 <robstr_> could not match `Data.ByteString.Lazy.Internal.ByteString' with actual type `Data.ByteString.Internal.ByteString' - so my current bytestring is strict and i need it lazt ?
03:20:01 <[exa]> asheshambasta: oh crypto. :] I highly suggest Debug.Trace for that
03:20:45 <phadej> kosmikus: "drop support for GHC <8.0"
03:20:57 <[exa]> esp. if you're trying to find a bug in actual crypto values you'll need to be able to scroll through the log a lot
03:20:59 <cocreature> asheshambasta: yeah Haskell tooling is sadly not particularly good. you’ll see a lot of Haskellers claim that tooling is just not necessary in Haskell but I don’t agree with that
03:21:08 <cocreature> robstr_: yep
03:21:09 <kosmikus> phadej: that's a very specific interpretation of "backwards-compatible"
03:21:21 <phadej> kosmikus: I know :)
03:21:27 <robstr_> cocreature: yt
03:21:30 <asheshambasta> cocreature: I can vouch for the fact that tooling is of paramount importance for adoption
03:21:33 <[exa]> kosmikus: very practical one.
03:21:45 <kosmikus> phadej: I know we've had this discussion before. I was hoping there's a better story by now.
03:22:26 <kosmikus> I wish people could just leave the class hierarchy alone :)
03:22:39 <asheshambasta> cocreature: and yes I've noticed the "hand-waving" in the Haskell community when it comes to tooling — although I think most people agree that there's room for improvment.
03:22:50 <[exa]> asheshambasta: you may compare haskell tooling with unix development tooling; the debugging is usually frowned upon for similar reasons
03:22:55 <phadej> kosmikus: well, I still think providing inconsitent API (with newer GHC you provide Semigroup, with older you don't) isn't much better than dropping support for GHC<8, as pre-GHC-8 will be "second-class citizens"
03:23:18 <cocreature> asheshambasta: yeah and there are people actively working on improving the situation, e.g., alanz and others has beeing doing some great work on haskell-ide-engine
03:23:36 <asheshambasta> Scala is a much inferior language, imo, but the tooling (SBT, IDE's like IntelliJ) make it much more easy to get started with
03:24:49 <asheshambasta> anyway I'll see how I can combine things with Debug.Trace and some GHCi-foo to overcome this issue
03:24:55 <kosmikus> phadej: sure, among these two solutions, I agree. I guess I was hoping for something like semigroups-compat.
03:25:01 <asheshambasta> thanks for all the help cocreature, [exa]
03:25:04 <cocreature> isn’t sbt just a build tool? Haskell build tools are actually quite good
03:25:34 <asheshambasta> cocreature: yeah it is — but it is very extensible and you can almost program it to your liking
03:25:39 <asheshambasta> makes some common things a breeze
03:25:44 <phadej> kosmikus: you mean that we'd have a package which only provides a class, but not instances for `text` etc?
03:26:06 <asheshambasta> + its plugin ecosystem is filled with things that work towards automating stuff
03:26:08 <phadej> that might work, but there aren't such :/
03:27:14 <asheshambasta> cocreature: for example, I can write SBT-code to build multiple docker images, tag them based on my current branch and push these images to docker-hub
03:27:49 <[exa]> asheshambasta: shell scripting?
03:27:58 <cocreature> asheshambasta: fair enough, fwiw you can build docker images using stack but it doesn’t do the tagging based on your current branch
03:28:03 <phadej> or e.g. `shake`
03:28:07 <kosmikus> phadej: right, a package that introduces the class but ideally has no dependencies except base
03:28:10 <asheshambasta> maybe thats also possible with one of Haskell's build tools — (stack has some support for Docker) but AFAIK its not as flexible
03:28:51 <asheshambasta> [exa]: what if I'm not good at shell scripting? Doing slightly more complex stuff in another language becomes yet another overhead
03:29:15 <asheshambasta> SBT's syntax is _very_ Scala like
03:29:47 <phadej> kosmikus: yeah, I agree, having such compat package would make some people happier, it's however non-trivial engineering effort :/
03:31:17 <phadej> kosmikus: behold, `Contravariant` will be in `base-4.12`! Luckily it won't shuffle hierarchy, but there will be more pressure to add instances...
03:31:18 <kosmikus> phadej: ok, I think in this case I'll actually go with your suggestion and drop ghc-7 compatibility. it's not as if the old version would stop working right now. (talking about ixset-typed, not generics-sop in this case)
03:31:43 <kosmikus> phadej: whatever happened to the idea of base getting smaller :)
03:32:13 <phadej> kosmikus: some people don't want to add instances, if they have to add dependencies...
03:32:38 <phadej> I don't really know why otherwise
03:33:07 <kosmikus> phadej: well, yeah, depends on what kind of dependencies
03:33:30 <kosmikus> phadej: the dependency footprint of "contravariant" is not trivial, and also includes "semigroups", which I already find problematic. so I can see that.
03:33:50 <Eduard_Munteanu> Cool.
03:33:58 <kosmikus> phadej: if contravariant was a package just depending on "base", I'd see no problem.
03:34:25 <phadej> kosmikus: most deps are just shims: http://hackage.haskell.org/package/contravariant-1.4.1/dependencies (tagged, void, semigroups)
03:34:55 <kosmikus> semigroups depends on binary, bytestring, bytestring-builder, containers, hashable, text, unordered-containers
03:35:01 <kosmikus> phadej: that's really a lot
03:35:08 <[exa]> btw anyone has an idea of how long does it take to build the GHC API package from source?
03:35:25 <phadej> kosmikus: it is, but contravariant pulls semigroups again, only for GHC<8
03:35:46 <kosmikus> phadej: aha, ok, I didn't see that that's the case only for GHC<8.
03:35:56 <kosmikus> phadej: yes, then contravariant looks mostly harmless to me :)
03:36:07 <cocreature> [exa]: you can’t build ghc api package like any other package. you have to build ghc itself
03:36:19 <cocreature> [exa]: which can take a while depending on your build flavor
03:36:22 <kosmikus> phadej: StateVar is perhaps a bit surprising.
03:36:35 <phadej> kosmikus: it is, but I don't remember why it's there
03:37:21 <phadej> StateVar-1.0.0.0 Uploaded Tue Jul 14 17:08:34 UTC 2009
03:37:42 <phadej> contravariant-0.1.0 Fri Jan 14 22:13:46 UTC 2011
03:37:51 <[exa]> cocreature: is it in minutes, hours or days? :]
03:38:22 <[exa]> cocreature: also, any hints about how to start? I need a modified GHC-API with different handling of FFI imports/exports
03:38:48 <phadej> kosmikus: probably no-one really cares about reversing that dependency
03:39:16 <phadej> kosmikus: especialy as StateVar depends on `stm` only outside of boot-libs
03:39:29 <cocreature> [exa]: the fastest build flavor should be less than 30 minutes, a released build probably takes a bit over an hour
03:39:43 <cocreature> [exa]: clone the ghc repo and follow the build instructions
03:42:38 <[exa]> cocreature: which will get me a full bootstrapped GHC, which I don't require as a whole-- I can strip off all code generation etc; only need the desugaring/typechecking (with that slight FFI modification)
03:43:49 <cocreature> [exa]: I don’t think there is a way to disable things like code generation. maybe try asking in #ghc
03:44:28 <cocreature> although ffi without code generation seems kind of useless?
03:44:42 <[exa]> cocreature: the point was 'why to build the compiler if I want a package' mostly. maybe I'm missing the connection there
03:44:49 <[exa]> cocreature: I'll supply the codegen myself
03:45:13 <cocreature> ah ok
03:45:45 <cocreature> I see your point, I just don’t think GHC’s build system is set up for that
03:46:24 <[exa]> btw the GHC API package is a byproduct of the full compiler build?
03:46:25 <cocreature> maybe take a look at the recent proposal for providing an extended interface for GHC plugins. that might be a better solution that modifying ghc itself
03:47:13 <joel135> An interesting mistake I made: http://lpaste.net/363742 (commented out). Is there a deeper understanding for this?
03:48:28 <[exa]> I was eyeing that, yes. The problem is that I _have_ to modify GHC because I need ffi imports and exports. At this point they are solved during desugaring, rewritten into something that the optimizer is going to chew out and which will have the side effect of FFI working as intedned... :]
03:49:01 <[exa]> for example the module-stub.h files are produced during desugaring (whew!)
03:49:32 <[exa]> maybe I could just use the ghc-api as is and run desugaring manually with this step implemented by myself
03:49:50 <[exa]> which will add some maintenance cost when ghc changes but I guess I can live with that
03:51:34 <kosmikus> joel135: I don't know what you're looking for. In your commented version, the "first" thing cata does is to immediately call itself again. there's no way this can terminate except if f ignores its input completely.
03:54:48 <joel135> I was thinking (very vaguely) maybe the first version is like sum -(1/2)^i over i < 0 and the second one is like sum (1/2)^i over i >= 0. Some 18th century mathematician saw them as equal even though one diverges.
03:58:51 <joel135> At least in the trivial case where both terminate - as you say f has to be constant - the implementations agree.
04:00:02 <kosmikus> joel135: well, yes, but they'd even for f . undefined
04:00:05 <cocreature> I think you are trying to interpret more meaning into this meaning than there is.
04:00:23 <joel135> ok
04:04:06 <joel135> `cata f = f . cata (fmap f)` is a true identity though.
04:04:45 <lseactuary> qq - i have a function and input some values into the function. i get the correct output. is there a way to see the 'steps' used to get to that value in haskell (ghci)?
04:14:30 <fr33domlover> lseactuary, not sure I understand, but one thing that is maybe relevant is to use breakpoints in GHCi
04:14:35 <fr33domlover> (I never tried that)
04:14:58 <kosmikus> joel135: yes, true
04:20:02 <Axman6> lseactuary: GHCi has a debugger which can be used for that, you'll have to check the ghci manual to find out how to do that though
04:20:42 <lseactuary> nice
04:20:44 <lseactuary> thanks!
05:07:40 <ongy> sometimes I wonder if the things I do are wrong
05:16:39 <SovietBeer> ongy: why
05:18:17 <cocreature> ongy: if you need to wonder, they probably are wrong :)
05:18:57 <ongy> yea, I am wrong. But it works, so I don't care
05:19:09 <ongy> SovietBeer: breaking types, then trying to fix that, only to realise it's still horribly broken :(
05:19:36 <ongy> I have to mess with FFI and callbacks through C, so I'm not quite at the liberty to do things in nice ways
05:20:15 <SovietBeer> ongy: yea, that sucks. i'm also having a type issue atm https://github.com/slamdata/purescript-halogen-echarts/issues/35
05:20:21 <ambro718> Hi, how would one make a monad where "m x >>= f" does not evaluate f but stores it in the result? I don't know how to "erase the types".
05:21:11 <cocreature> ambro718: that sounds like it breaks the monad laws
05:21:26 <ambro718> Imagine I would like to do something like manually evaluate one step of a do block at a time.
05:22:36 <cocreature> maybe you’re looking for something like free monads?
05:23:28 <ambro718> cocreature: I wonder how the IO monad works then? Surely it does not evaluate those f's at the time a do block is defined, so it must store them?
05:24:46 <cocreature> ambro718: I’m not really sure what you mean by “store” here. e.g. take the state monad. that also doesn’t evaluate "f" immediately but it just returns a new function that evaluates f when you give it a state at the end
05:25:01 <cocreature> if you could be a bit more specific about what you’re trying to do, it might be easier to suggest as olution
05:25:58 <ambro718> cocreature: I'm trying to think if monads could encode a sequence of asynchronous operations
05:28:32 <cocreature> haxl?
05:30:04 <[exa]> cocreature: aaah I finally understood why ghc library must be compiled with ghc...it's a fake library. Explains so much. :]
05:30:45 <[exa]> anyways I got it working with just pulling the relevant changed source to my project, thanks for the pointers. :]
05:33:27 <Ariakenom> ambro718, something like a usage example would probably be clearer.
05:35:07 <lseactuary> hi - my code is working well and giving the right result. only one problem. it is not storing the first co-ordinate in the list of strings. this means my recursion isn't working as well as i thought it was. is it possible for someone to check?
05:35:40 <cocreature> lseactuary: you’re going to have to show us the code if you want someone to take a look
05:36:34 <lseactuary> yup uploading
05:38:56 <lseactuary> http://lpaste.net/6555507376722542592
05:39:19 <lseactuary> ive tested each line of code, it is all correct, there is just something missing from the run1 function causing the small bug.
05:40:33 <chisui> lseactuary: is your code only in ghci?
05:41:05 <cocreature> this code is missing some stuff, Word and Grammar are never defined
05:41:24 <lseactuary> ah sorry i copied/pasted from .lhs file i made
05:41:25 <lseactuary> 2 min
05:41:54 <lseactuary> updated
05:42:37 <ambro718> cocreature: Ariakenom: sure but it's very... unusual. I had made a programming language based on asynchronous execution and backtracking. Here's an example program with explanation what it does: https://paste.ubuntu.com/p/2ykJnmN7Fn/ My question is if monads could be used to represent such a "process" and if an implementation of this concept is possibe in Haskell
05:43:17 <cocreature> lseactuary: that’s still missing the interpret1 and evolve functions that you’re using in your example
05:43:22 <lseactuary> i originally had run1 [] (p,cp) = [(p,cp)] but that doesnt seem to make a difference
05:43:45 <ambro718> should be noted that the statements in my program might produce values that may be passed as arguments to subsequent statements
05:44:56 <lseactuary> sorry updated
05:46:07 <Ariakenom> ambro718, consider "fmap toUpper print" does this fit what you mean by "storing" toUpper?
05:47:04 <lseactuary> also in the book they seem to have (7 :+ 1, E) for example but in ghci its showing to 1 decimal. not sure if this is expected?
05:47:11 <lseactuary> the numbers are correct though
05:47:46 <cocreature> lseactuary: you can change run1 as follows http://lpaste.net/363747
05:48:41 <Ariakenom> :t (.)
05:48:43 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:48:53 <lseactuary> cocreature aha! yes it works :)
05:50:01 <cocreature> lseactuary: you can also simplfy this using "scanl": run1 cmds initialState = scanl (flip step1) initialState cmds
05:50:50 <lseactuary> aha let me try :)
05:51:20 <lseactuary> by "this" you mean the function run1 or something else?
05:51:30 <cocreature> the run1 function
05:53:09 <lseactuary> aha!
05:53:13 <lseactuary> testing :)
05:54:27 <lseactuary> nice
05:54:53 <ambro718> Ariakenom: I wouldn't say so. But consider "getLine >>= (\x -> putStrLn (x++"a"))". The result has type IO(), but it clearly must encode the action of appending "a" to x in some hidden obscure way.
05:55:01 <cppxor2arr> @src zipWith7
05:55:01 <lambdabot> Source not found. That's something I cannot allow to happen.
05:55:10 <cppxor2arr> why does that happen? ^
05:55:23 <ambro718> How is this action stored in IO? What the heck is IO, it is magic?
05:56:03 <Ariakenom> There is nothing interesting about IO there ambro718.
05:56:10 <Ariakenom> Consider just (.)
05:56:16 <noipmups> Hello, is there someone willing to help me with https://stackoverflow.com/questions/49348103/haskell-recursion-from-leafs-to-root?
05:56:17 <Ariakenom> :t (.)
05:56:19 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:57:15 <ambro718> function composition? don't see your point.
05:57:16 <Ariakenom> > let f = ("c++").("b"++).("a"++) in f "0"
05:57:19 <lambdabot>  error:
05:57:19 <lambdabot>      • Couldn't match expected type ‘[Char] -> c1’
05:57:19 <lambdabot>                    with actual type ‘[Char]’
05:57:32 <lseactuary> thanks cocreatrue
05:58:43 <Ariakenom> > let f = ("c"++).("b"++).("a"++) in f "0"
05:58:47 <lambdabot>  "cba0"
05:59:23 <Ariakenom> This is all the the same type now. But it doesn't have to be right? The entire chain get's hidden. Only final input and output matters.
06:02:09 <lseactuary> cocreature seeing 1.0+:1.0 for example is the same as 1+:1 right?
06:02:16 <lseactuary> in the book they have 1+:1 hence asking
06:02:18 <cocreature> lseactuary: yes
06:02:25 <lseactuary> nice
06:02:30 <lseactuary> btw your function worked nicely :)
06:02:38 <cocreature> I know I tested it ;)
06:02:41 <lseactuary> hehe
06:02:48 <lseactuary> i am trying to compile the pic now :)
06:03:10 <Ariakenom> :t (1.0+:1.0, 1+:1)
06:03:12 <lambdabot> error:
06:03:13 <lambdabot>     • Variable not in scope: (+:) :: Double -> Double -> a
06:03:13 <lambdabot>     • Perhaps you meant one of these:
06:03:37 <lseactuary> type Position = Complex Double
06:03:50 <lseactuary> ah sorry i mean 1.0+:0 etc
06:04:04 <Ariakenom> Well I apparently can't code today. I'm off, bye.
06:05:23 <ambro718> Ariakenom: sure, but I don't see how this helps me with my problem. What I need is to be able to represent a sequence of actions in a monad that some imperative (IO) code will know how to execute. See: https://paste.ubuntu.com/p/pst2k7fWDY/
06:05:53 <ambro718> Is it possible to define a monad that will allow this to parse and that will allow making an interpreter for the sequence of actions?
06:07:13 <ambro718> in this very simple model, each action is represented by a string naming the action type, a number of arguments (all strings) and a result (a single string).
06:07:59 <cocreature> ambro718: maybe something like this is helpful? http://lpaste.net/363749
06:08:19 <cocreature> IO is magic in GHC but you can build your own IO-like like that
06:08:41 <cocreature> the generalized version of that pattern is the free monad
06:08:43 <ambro718> that sounds good, need some time to go through it, thanks
06:09:28 <anieuwland> Hello everyone! I an getting a "Floating point exception (made memory dump)" error while running my Haskell program. It probably occurs somewhere in bindings to C-libraries I use, but I don't know how to find out where. Does anyone have suggestions?
06:09:35 <thblt> Hi!  If anybody here has access to the haskell github org or commit access to the haskell-mode repo, could you please have a quick look at an important security PR I sent a few days ago?  Really sorry to ask, but the repo seems in (very) low maintainance mode and the issue worries me quite a bit.
06:09:39 <thblt> Thanks!
06:10:30 <cocreature> anieuwland: probably something like 1/0
06:11:00 <cocreature> anieuwland: which throws a floating point “exception” if 1 and 0 are integers but doesn’t throw one if they are floats because C is so great
06:11:13 <fakenullie> > sqrt (-1)
06:11:16 <lambdabot>  NaN
06:11:25 <anieuwland> cocreature: strange thing is, I have nowhere in my code where I expect those numbers to occur
06:11:54 <anieuwland> cocreature: I even delete a few of the integer calculations I did - the only calculations in my code - to see if that was it. But it isn't
06:12:04 <cocreature> anieuwland: throw gdb at it?
06:13:00 <anieuwland> cocreature: So I have gdb installed and already compiled my program with -debug and -dcore-lint, but how do I go about actually using gdb? Never did that before
06:14:37 <cocreature> anieuwland: you want -g not -debug. you don’t need a lot of gdb knowledge for this, basically just start your executable in gdb and run "bt" to get a backtrace once it crashed. I’m sure you can find a few gdb tutorials online
06:19:18 <anieuwland> cocreature: thanks, I'm trying stuff
06:20:04 <ambro718> cocreature: what did you do with the fmap there?
06:20:18 <jaseemabid> I've this tiny implementation of map which is giving me a funny type error. When I compile `m :: _` with a type hole, GHC suggests a type, but when I explicitly annotate it, GHC fails with a type error. What's really going on here?  http://lpaste.net/363750
06:20:40 <cocreature> ambro718: nothing but a Monad instance requires Functor and Applicative instances
06:21:39 <ambro718> cocreature: I understand correctly that in the GetLine and PutStrLn, you store the continuation of the program inside?
06:22:00 <cocreature> yep
06:25:42 <gazanga> can someone please give me a hint how to solve this problem? i want to make all the lists i can from a given list (that can be in a different size), including the empty list. for example if i get this list [1,2,3], i want to get this [[],[1],[2],[3],[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]. i dont want a solution. just advice.
06:26:21 <lyxia> jaseemabid: you need the extension ScopedTypeVariables to refer to the types a and b from line 1
06:26:45 <lyxia> jaseemabid: otherwise GHC thinks every type annotation is binding fresh variables.
06:28:12 <lyxia> jaseemabid: it's an extension because it's not part of the current Haskell standard.
06:30:15 <cppxor2arr> gazanga: what about `permutations` from Data.List?
06:30:40 <cppxor2arr> oh diff sizes
06:31:42 <fakenullie> there's subsequences function
06:32:21 <jaseemabid> @lyxia, Thanks for the hint, I could make it work with an explicit `forall a b .` at the top. Now that I know what to read, I'll go figure out the rest. Thanks again. You are awesome!
06:32:21 <lambdabot> Unknown command, try @list
06:32:37 <gazanga> i want to do it in my own code without library functions that deal exactly with that. can it be done?
06:33:10 <gazanga> and i'm very noob :-)
06:33:23 <Tuplanolla> It can be done, gazanga.
06:33:34 <cppxor2arr> gazanga: you could use permutations (permutations doesn't do exactly that)
06:34:56 <Tuplanolla> The usual way to approach problems like this is to assume you have solved it for a list of some length and use that solution to build it for a list of greater length.
06:35:18 <Tuplanolla> build/solve
06:35:42 <gazanga> OK Tuplanolla so let assume it's for a fixed size list, for example this list [1,2]
06:36:23 <gazanga> so i need to have at the end [[],[1],[2][1,2],[2,1]]
06:36:50 <gazanga> and maybe not in this order if it's more easier
06:37:31 <Tuplanolla> Very well. Now ask yourself how to modify this solution to get the solution for `[1, 2, 3]`.
06:38:24 <gazanga> Tuplanolla: i understand but i still don't know how to solve it for 2 item's list :-)
06:38:40 <Tuplanolla> How about `[1]` then?
06:38:45 <gazanga> need some guiding
06:39:09 <gazanga> well [1] is also good :-). i need to think about it.
06:41:28 <gazanga> Tuplanolla: well its just one line because it is very easy: lists (x:[]) = [[],[x]]
06:41:49 <ambro718> how does this parse:  GetLine (fmap f . g)
06:41:57 <ambro718> with respect to fmap and .
06:42:08 <Tuplanolla> Even easier starting point would be `[]`, which is just `[[]]`.
06:42:17 <gazanga> Tuplanolla: yes :-)
06:42:38 <Tuplanolla> Either way, you now have two cases. How to modify the previous one to get the next one?
06:43:47 <gazanga> i don't understand what is the previous and the next in your sentese (not very fluent in english)
06:44:51 <Tuplanolla> To go from `lists [1] == [[], [1]]` to `lists [1, 2] == [[], [1], [2], [1, 2], [2, 1]]`, you add the new element in a list `[2]` and the shuffled lists `[1, 2]` and `[2, 1]`.
06:45:35 <gazanga> understand OK
06:45:36 <Tuplanolla> Does this pattern continue or do you need to make some adjustments?
06:45:37 <jaseemabid> lyxia, Thanks for the hint, I could make it work with an explicit `forall a b .` at the top. Now that I know what to read, I'll go figure out the rest. Thanks again. You are awesome!
06:46:26 <gazanga> i thing i need adjusment because the list is starting to fet bigger with one more element
06:46:33 <gazanga> fet = get
06:46:50 <gazanga> (the list of lists of course)
06:47:27 <Tuplanolla> Indeed, with this rule we would get `lists [1, 2, 3] == [[], [1], [2], [3], [1, 2], [2, 1], [1, 2, 3], [3, 2, 1]]`, which is wrong.
06:48:23 <Tuplanolla> Figuring out the required adjustment here is all you really need, because then you can recursively solve any case.
06:49:06 <gazanga> Tuplanolla: do you see the answer?
06:49:13 <gazanga> (don't tell me :-))
06:49:24 <Tuplanolla> I happen to know it already.
06:49:30 <gazanga> :-)
06:50:28 <Tuplanolla> Still, this principle of reasoning is universal and goes by the name of induction.
06:51:11 <gazanga> mathematical induction?
06:52:16 <Tuplanolla> It's the same thing.
06:52:23 <gazanga> OK
06:56:18 <ambro718> cocreature: but the fmap you wrote seems to me like it is equivalent to >>= ?
06:58:08 <ambro718> as in,   "fmap f m"   is the same as  "m >>=  f"  ?
07:00:13 <ambro718> hm except the Return case. I don't get this, what is the point of this fmap?
07:00:40 <fakenullie> > [1, 2, 3] >>= ((+1) . return)
07:00:43 <lambdabot>  error:
07:00:43 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_11231’
07:00:44 <lambdabot>      • In the expression: e_11231
07:02:45 <fakenullie> > [1, 2, 3] >>= (return . (+1) )
07:02:48 <lambdabot>  [2,3,4]
07:03:23 <fakenullie> fmap f m is the same as m >>= (return . f)
07:11:49 <ambro718> given that Monad must implement Functor, when in real use would fmap be called on a Monad?
07:12:43 <Tuplanolla> When convenient, ambro718.
07:14:34 <fakenullie> ambro718: x <- read <$> getLine
07:22:48 <lseactuary> my code is working for the single line case, but im unsure how to check its working for the multi-line case. can someone provide an example?
07:23:46 <lseactuary> http://lpaste.net/7714768944548020224
07:28:22 <lyxia> lseactuary: what is currently not working in the multiline case
07:29:33 <lseactuary> it may be working, im just unsure what to type after element to get the "if it has children, it is shown on multiple lines, with opening and closing tags" line
07:29:54 <lseactuary> i.e. what it means for an element to have children
07:30:06 <lseactuary> i may have only solved the first use case :/
07:34:52 <lseactuary> lyxia - do you happen to understand it?
07:36:09 <lseactuary> lyxia i guess it would be something like this right? [("attr1","val1"),("attr1","val3"),("attr2","val2")]
07:36:22 <lseactuary> *Main> element "name" [("attr1","val1"),("attr1","val3"),("attr2","val2")] "<name attr1='val1' attr1='val3' attr2='val2'/>"
07:40:58 <mytotoro> hi, I'm a haskell beginner, having some trouble getting basic libraries to work, can anyone help
07:42:38 <lseactuary> mytotoro did you try import for the library? e.g. > import Data.Complex
07:43:29 <mytotoro> it's a 3rd party lib, I've downloaded the source from github, and did 'stack ghci' in it's root
07:43:34 <mytotoro> so all the modules are loaded already
07:43:43 <lseactuary> ah
07:44:16 <lseactuary> maybe upload your error and someone can help?
07:44:31 <mytotoro> to stackoverflow?
07:45:29 <lseactuary> http://lpaste.net/new/haskell
07:45:37 <cocreature> and then post the link here
07:47:20 <lseactuary> ah i need to use show ... and ghci will only show in 1 line right? so how will i know its correctly formatting?
07:49:56 <mytotoro> http://lpaste.net/363756
07:50:42 <mytotoro> I went through the book Learn You a Haskell, and I do other imperative languages
07:50:48 <cocreature> mytotoro: the problem is that to show the value, GHC has to figure out which "m" it should chose
07:50:53 <lseactuary> updated this : http://lpaste.net/7714768944548020224
07:50:55 <cocreature> so you need to provide an explicit type annotation
07:52:21 <mytotoro> I thought 'm' was just a type
07:52:27 <mytotoro> monadic type
07:52:34 <mytotoro> here being MonadIO
07:53:00 <mytotoro> and MonadThrow
07:53:01 <cocreature> mytotoro: "m" is a type variable. for resolving the Show (m Book), constraint. GHC needs to find a concrete instantiation of "m"
07:53:14 <mytotoro> am I supposed to create an instance of that myself?
07:53:28 <mytotoro> define a typeclass that satisfies both requirements*
07:54:02 <cocreature> you don’t need a typeclass. you need a type that is an instance of the typeclasses mentioned in the type signature
07:54:45 <cocreature> e.g. "ReaderT Gdax IO" should probably work
07:55:03 <mytotoro> sorry yea, a type that is an instance of both requirements
07:55:17 <cocreature> although you can’t show something of that type
07:55:34 <cocreature> do you really want to show the ReaderT Gdax IO Book or do you want to print the Book?
07:55:39 <mytotoro> the latter
07:55:48 <mytotoro> the Book constructor itself derives Show
07:56:07 <cocreature> are you familiar with how IO works in Haskell?
07:56:14 <mytotoro> yea
07:56:22 <mytotoro> I think so - read through Learn You a Haskell
07:57:18 <cocreature> alright, then you can use something like "do book <- getProductOrderBook; print book" to get something of type "ReaderT Gadx IO ()". if you call runReaderT on that and pass it a Gdax you get back an IO () which when executed will print the book
07:59:21 <cocreature> eh that should be "liftIO (print book)". otherwise you’ll get a type error
08:00:30 <mytotoro> hmm
08:01:48 <lseactuary> anyone can help with this please? http://lpaste.net/7714768944548020224
08:02:49 <cocreature> lseactuary: have you looked at the error message? I can’t tell you much more than repeat what GHC already told you :)
08:03:55 <ab9rf> what did you expect "x1 x1 :: XML" to mean?
08:04:05 <lseactuary> :t
08:04:32 <ab9rf> ":t" just asks the REPL to report the type of an expression
08:04:34 <lseactuary> just was trying to understand the problm
08:04:35 <lseactuary> ye
08:05:01 <ab9rf> the problem is that the expression you asked it to determine the type of was "x1 x1 :: XML"
08:05:35 <lseactuary> you can ignore this line
08:05:40 <lseactuary> i was just trying to build something to test
08:05:50 <ab9rf> you need to tell the compiler that
08:05:52 <cocreature> well that’s the line producing the error
08:05:53 <ab9rf> it's not going to
08:06:29 <lseactuary> updated
08:06:30 <mytotoro> @cocreature I don't follow on wrapping it in a do block
08:06:30 <lambdabot> Unknown command, try @list
08:06:47 <ab9rf> mytotoro: don't use @ to refer to people in here, ths isn't twitter :)
08:07:01 <lseactuary> oh wait it doesnt work
08:07:07 <ab9rf> lseactuary: it appears to do what you want
08:07:13 <mytotoro> ahh sorry
08:07:29 <lseactuary> ye
08:07:34 <lseactuary> i just realised my mistake :P
08:07:38 <ab9rf> except that it uses single quotes on the attrivbuate values instead of double quotes
08:07:42 <lseactuary> right
08:07:58 <lseactuary> easy to change
08:08:38 <lseactuary> hmm
08:08:48 <lseactuary> i cant change ' to " right
08:08:58 <ab9rf> backslashes are your friend
08:09:02 <ab9rf> > "\""
08:09:05 <lambdabot>  "\""
08:09:15 <ab9rf> > head "\""
08:09:17 <lambdabot>  '"'
08:09:53 <ab9rf> > map ord "\"hello world\""
08:09:56 <lambdabot>  [34,104,101,108,108,111,32,119,111,114,108,100,34]
08:10:36 <lseactuary> http://lpaste.net/7714768944548020224
08:10:48 <lseactuary> we seem to have extra \
08:11:30 <frerich> lseactuary: Try 'print x1'.
08:11:44 <ab9rf> ^^^
08:12:11 <frerich> lseactuary: 'show x1' gets you a string, i.e. something enclosed in quotation marks. If the string happens to contain quotation marks itself, then those get printed as expected (i.e. escaped).
08:12:32 <lseactuary> fretich prime x1 is nice :)
08:13:21 <lseactuary> oh
08:13:24 <lseactuary> now it is correct
08:13:52 <lseactuary> same result when i just type x1
08:13:54 <lseactuary> this is expected?
08:14:40 <frerich> lseactuary: Yes, that's expected - ghci will 'print' the given expression for you automatically.
08:14:58 <lseactuary> aha
08:15:03 <lseactuary> only issue left is there is a blank line at the end
08:15:20 <lseactuary> uploaded
08:18:24 <lseactuary> or it doesnt really matter?
08:18:28 <lseactuary> works for the single line now also :
08:18:30 <lseactuary> :)
08:18:39 <frerich> lseactuary: 'print' prints the string representation of the given value. However, you also use 'unlines', which already adds a terminating newline.
08:18:59 <lseactuary> yeah i think unlines is already in the defintiion :)
08:19:24 <frerich> lseactuary: Sorry, I meant to write that 'prints' prints the string representation and then adds a newline.
08:19:39 <frerich> I.e. if the string representation of the given value already ends in a newline, then you end up printing two.
08:19:48 <lseactuary> yeah i only used print
08:19:56 <lseactuary> but actually typing just x1 gives the same answer
08:20:03 <lseactuary> there is a new line at the end
08:20:10 <lseactuary> does it matter?
08:20:33 <frerich> lseactuary: I suspect it will look a bit differently if you use 'putStr (show x1)'
08:21:17 <ab9rf> :t print
08:21:19 <lambdabot> Show a => a -> IO ()
08:21:30 <lseactuary> frerich yes it looses the last line
08:21:33 <mytotoro1> updated http://lpaste.net/363756
08:21:34 <lseactuary> means i did this correctly?
08:22:12 <frerich> lseactuary: If you want the string representation of the XML element to end in a newline, then you did it correctly, yes..
08:22:24 <lseactuary> is there a way for it not to have a new line
08:22:26 <lseactuary> but within the function
08:22:33 <lseactuary> rather than when i see the output only
08:22:44 <ab9rf> you want the string to end with a newline, but for it not to be printed?
08:22:52 <lseactuary> i dont want the new line :)
08:23:01 <ab9rf> you'll have to use something other than unlines
08:23:04 <lseactuary> ah
08:23:10 <lseactuary> so be default unlines adds a new line?
08:23:16 <frerich> lseactuary: You could use 'intercalate' instead of 'unlines', yes.
08:23:21 <lseactuary> got ya
08:23:24 <ab9rf> yeah, intercalate would be my choice
08:23:29 <lseactuary> makes sense
08:23:29 <lseactuary>  :)
08:23:31 <ab9rf> unlines adds a terminal newlin, yes
08:23:36 <lseactuary> interesting
08:23:40 <ab9rf> > unlines ["a","b","c"]
08:23:43 <lambdabot>  "a\nb\nc\n"
08:23:45 <lseactuary> ahah
08:23:48 <ab9rf> see the "\n" at the end?
08:23:56 <ab9rf> > intercalate "\n" ["a","b","c"]
08:23:59 <lambdabot>  "a\nb\nc"
08:24:05 <ab9rf> no "\n" at end
08:24:19 <lseactuary> yes
08:24:59 <lseactuary> many thanks :)
08:29:49 <mytotoro1> can anyone share wisdom on http://lpaste.net/363756
08:34:45 <lyxia> mytotoro1: getProductOrderBook is not a Book, it's a computation that produces a book, and you have to run it.
08:35:46 <mytotoro1> I thought '-> m Book' would be a Book with a special type
08:35:56 <mytotoro1> namely MonadIO and MonadThrow
08:36:39 <lyxia> well it depends on how you look at it, but if your goal is to print the book, that distinction is important to make here.
08:37:05 <mytotoro1> ok - I can accept that
08:37:26 <mytotoro1> how do I take it out of the context / run the computation
08:37:30 <lyxia> So to run this computation there are three effects to handle: MonadIO, MonadThrow, MonadReader
08:37:52 <lyxia> MonadIO and MonadThrow will be taken care of by running in IO at the end.
08:38:05 <lyxia> MonadReader is implemented by the ReaderT transformer.
08:38:36 <lyxia> You first need to get a value  gdax :: Gdax  somehow
08:39:14 <lyxia> and then you can pass it to the computation by writing "runReaderT getProductOrderBook gdax"
08:40:03 <lyxia> And that can be specialized to IO, to handle MonadIO and MonadThrow:  runReaderT getProductOrderBook gdax :: IO Book
08:40:13 <mytotoro1> ahh
08:40:17 <mytotoro1> this makes much more sense
08:40:37 <lyxia> Oh, I forgot the ProductId argument   runReaderT (getProductOrderBook prodId) gdax :: IO Book
08:40:43 <mytotoro1> I didn't read up on monad transforms so I'll go back to reading before fiddling around
08:40:52 <mytotoro1> that part I figured out yea
08:40:53 <lseactuary> it works :)
08:41:03 <lseactuary>  i made some nice pictures :)
08:41:05 <lseactuary> yay
09:03:27 <ambro718> cocreature: I am trying to figure out how to make your idea work in such a way that new actions can be added without having to write too much boilerplate and without modifying the interpreter. I've come to this:  http://lpaste.net/1400312634468728832
09:03:55 <ambro718> but I don't know how to prevent having to enumerate alll supported types in IoAction
09:04:16 <ambro718> I want the interpreter to be generic and for actions with any result type to be implementable
09:11:09 <lseactuary> my code works for when i use a compass point and gives the curve. now i am using radians and trying to get a more complex curve and im getting a straight line. i think my final recursion function is not quite right as the other functions seem to do what they are supposed to. can someone help?
09:11:09 <lseactuary> http://lpaste.net/9193139667568951296
09:22:14 <elpfen> Is there something like (f a, f b) -> f (a, b)?
09:23:02 <ambro718> How would one represent the concept of having a value of unknown type a and a function that maps a to some specific type, as a non-parametrized type?
09:26:25 <lyxia> elpfen: liftA2 (,)
09:32:32 <jmcarthur> ambro718: I think your question needs more context. Why shouldn't it be parameterized?
09:32:45 <jmcarthur> ambro718: Oh, nevermind, I understand now
09:33:40 <jmcarthur> ambro718: I think you want an existential type. For example, with -XExistentialQuantification:  data MyType = forall a. MyTypeCons a (a -> MyOtherType)
09:35:43 <ambro718> jmcarthur: yes, thanks
09:35:59 <cocreature> that’s not particularly useful. you might as well store MyOtherType
09:36:21 <cocreature> in a lazy language there is no reason to delay function application
09:38:01 <ambro718> cocreature: I cannot figure out how to generalize your IOOp thing to be able to implement additional actions without adding an option to the IOOp type and implementing >>= for every new action one would like to implement
09:38:32 <cocreature> ambro718: you can use the free monad to avoid having to implement >>= manually
09:38:35 <ambro718> say I want to be able to execute any "IO a" via the interpreter
09:39:02 <ambro718> and the interpreter may additionally do smart things, like printing "I am about to do an action" just before it executes it
09:39:10 <cocreature> ambro718: take a look at http://www.parsonsmatt.org/2017/09/22/what_does_free_buy_us.html
09:39:11 <ambro718> free monad, I will have to look that up
09:43:07 <lseactuary> anyone can help me real quick with this? http://lpaste.net/9193139667568951296 not sure at all why i am getting a straight line.
09:46:24 <mpickering> When making a source tarball does cabal include files generated by alex/happy?
09:46:53 <cocreature> mpickering: afaik it doesn’t. they are generated when you build the package not on "cabal sdist"
09:48:47 <hpc> i wouldn't expect it to, anyway
09:48:55 <mpickering> ok
09:49:01 <mpickering> when I run cabal sdist it does run happy
09:49:06 <mpickering> but then the file isn't in the tarball
09:49:20 <hpc> i wouldn't expect a source distributable to be anything more than tar cvf or whatever
09:50:43 <mpickering> It seems that I had some dirty files from debugging which it picked up
09:50:44 <mpickering> thanks
09:57:12 <lseactuary> anyone please can help me on this bug?
09:57:17 <lseactuary> cant spot the issue
09:57:28 <lseactuary> http://lpaste.net/9193139667568951296 -- getting a straight line instead of a curve
09:57:36 <lseactuary> i think my recursion may be wrong?
10:10:52 <jmcarthur> Funny that I've never run into this before. I have a function that gets a value out of some larger container, like getValue :: T a -> a, and I want to evaluate it strictly enough to be sure I've extracted it from the container (so the container can be GCed) without evaluating the value I'm extracting.
10:11:20 <jmcarthur> The only way I can think of is to put a box around the values in the container, so I can evaluate the box strictly without evaluating the value it contains.
10:30:03 <lavalike> lseactuary: Direction = Double is an angle?
10:32:22 <lseactuary> lavalike yup
10:32:28 <lseactuary> i think i know the erro i am trying to fix :)
10:32:34 <lavalike> alright (:
10:33:17 <ffledgli1g> Hello, I'm extremely new to haskell; I was hooking for key-value stores and webservers written in haskell; I was wondering if there's anything close to de-facto out there, and thought I'd ask here :)
10:33:34 <Ariakenom> jmcarthur, would that make any difference? WHNF on Foo x y would evaluate foo but not x or y.
10:38:00 <lseactuary> lavalike - seems i didnt solve it :(
10:47:25 <lseactuary> lavalike updated the code so you can see the other functions :)
11:09:04 <jmcarthur> Ariakenom: The idea is instead of a (T a), I'd have a (T (Box a)). Then I can force the result of getValue safely.
11:11:21 <Ariakenom> jmcarthur, I think I see the problem. But im not that experienced in laziness. Would "getValue :: T a -> Box a" work?
11:13:00 <jmcarthur> Ariakenom: I guess it would, but in this case I don't have access to the implementation of getValue, and I don't think I can just define a wrapper that would have the correct behavior.
11:13:23 <jmcarthur> Ariakenom: I would still need to be able to box the values inside of T, I think.
11:16:23 <Ariakenom> jmcarthur: Interesting, so is the only evaluation something getting to WHNF? Or is there some other way?
11:18:05 <jmcarthur> I think WHNF is all we can do, and the only way to stop it "early" is to insert a head where you want it to stop, hence Box.
11:19:06 <jmcarthur> And annoyingly, Box has to be inserted before all the stuff you are going to want to be evaluted away. Once you have a thunk in hand, it's too late to insert a Box somewhere in the middle of it.
11:20:34 <ddellacosta> relatively basic syntax question here: why can't I use `where` in this way here? I get "parse error on input 'where'" when using a where in this way, but I'm not understanding why this is distinct from other uses of where:
11:20:35 <ddellacosta> foo = (\a -> if (even a) then a else b where { b = a * 2 })
11:21:32 <ddellacosta> doesn't matter if I indent to the line below either
11:21:59 <jmcarthur> ddellacosta: where can only be attached to bindings (such as top-level, let bindings, or other where bindings), not to arbitrary expressions.
11:22:21 <Gurkenglas> What would break if you allowed where in expressions?
11:22:24 <jmcarthur> I don't know how literally true what I just said is, but it's the mental shortcut I keep in mind.
11:22:52 <ddellacosta> jmcarthur: any idea where I can find this in official docs?
11:23:06 <jmcarthur> Gurkenglas: Not clear. I think parsing might become ambiguous without often requiring some parens.
11:23:20 <ab9rf> Gurkenglas: you'd have problems with ambiguity of scope, i think
11:24:47 <jmcarthur> ddellacosta: I think "where" is scattered around the Haskell Report with each syntax it works with.
11:25:50 <ddellacosta> jmcarthur: okay, thanks in any case, that was still helpful
11:26:24 <frerich> ddellacosta: I think in your case, the 'topdecl' production in https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-18000010.5 would be relevant.
11:27:21 <ddellacosta> frerich: thanks! BNF is as much as I could have hoped for
11:27:28 <ddellacosta> or whatever variation on it this is
11:27:37 <jmcarthur> I guess ddellacosta's example might make sense to work, though, if you imagine the where is attached to the lambda.
11:27:58 <ddellacosta> jmcarthur: yeah, I guess the point about not being at the top-level is what distinguishes it here--I was simply ignorant of that
11:28:13 <ddellacosta> and what you said seems to be echoed by what frerich linked me to
11:28:14 <jmcarthur> Ah, but then  foo = \a -> ... where blah = ...  might be ambiguous or require layout to disambiguate somehow
11:28:19 <ddellacosta> right
11:28:28 <ddellacosta> I can see that better now
11:29:13 <glguy> You might have to have: \x -> x where {} where outer = stuff
11:29:15 <glguy> :t \x -> x :: Int :: Int -> Int
11:29:17 <lambdabot> Int -> Int
11:29:54 <ddellacosta> actually I think maybe the `rhs` is what is relevant for me? In any case, this gives me a place to start
11:32:10 <Tuplanolla> Wait, what is this heresy, glguy? I thought that would be parsed `\ x -> ((x :: Int) :: Int -> Int)`.
11:33:07 <glguy> Tuplanolla: You can't put a type signature directly on an expression with a type signature
11:33:28 <glguy> so then the rule that lambda reaches as far to the right it can triggers and finishes parsing the lambda
11:33:28 <Tuplanolla> The more you know...
11:33:43 <glguy> and then you're allowed to have another type signature :)
11:34:01 <glguy> :t \x -> if True then x else x :: Int :: Int :: Int -> Int
11:34:03 <lambdabot> Int -> Int
11:34:15 <Eduard_Munteanu> :t ((x :: Int) :: Int)
11:34:17 <lambdabot> error:
11:34:17 <lambdabot>     • Couldn't match expected type ‘Int’ with actual type ‘Expr’
11:34:17 <lambdabot>     • In the expression: ((x :: Int) :: Int)
11:34:19 <Tuplanolla> I don't see why that would be disallowed though.
11:35:16 <Tuplanolla> The expression `f :: a -> _ :: _ -> b` is completely reasonable with `PartialTypeSignatures`.
11:35:38 <ab9rf> heh
11:35:39 <Eduard_Munteanu> Er.
11:35:43 <Eduard_Munteanu> :t ((5 :: Int) :: Int)
11:35:45 <lambdabot> Int
11:35:57 <glguy> Tuplanolla: That's fine, you'll just need ()s
11:36:20 <ab9rf> the problem is that 'x' has a binding in lamdbabot
11:36:22 <ab9rf> :t x
11:36:25 <lambdabot> Expr
11:37:17 <ab9rf> (also, i cannot spell)
11:40:45 <ddellacosta> anyways, seems like this is the way to do what I intended:
11:40:46 <ddellacosta> > foo' = (\a -> if (even a) then a else let { b = a * 2 } in b)
11:40:49 <lambdabot>  <hint>:1:6: error:
11:40:49 <lambdabot>      parse error on input ‘=’
11:40:49 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
11:41:09 <ddellacosta> er, whoops, didn't mean to feed that to lambdabot
11:41:27 <ddellacosta> and it seems the relevant clause is the `lexp` clause, which specifies `let` but no `where`
11:41:40 <ddellacosta> (in the doc frerich linked me to)
11:42:13 <ddellacosta> relatively trivial, I know, but I don't think I'd ever really understood the specifics there so quite helpful
11:57:37 <Ariakenom> ddellacosta, let is part of an expression. where is part of a declaration
11:58:55 <ddellacosta> Ariakenom: thanks, that seems like a good summary of what the spec is telling me. Did you development that understanding yourself or find that documented something when you were learning Haskell?
11:59:05 <ddellacosta> documented *somewhere
12:00:54 <Ariakenom> ddellacosta, to behonest no idea :). Probably thanks to some helpful material though.
12:02:09 <ddellacosta> Ariakenom: gotcha, was just curious--it definitely seems like there is a lot of stuff that is "common knowledge" for folks with a certain amount of experience in Haskell, but it's not always clear where the authoritative documentation for any given feature or fact is (if it even exists!)
12:02:27 <ddellacosta> authoritative source I should say, more generally
12:05:11 <kuribas> ddellacosta: the spec and the ghc documentation
12:06:16 <ddellacosta> kuribas: sure--but even knowing that, figuring out where to look within those sources can be challenging sometimes.
12:06:30 <ddellacosta> and sometimes it requires reading between the line--this is case in point
12:06:34 <ddellacosta> *lines
12:13:11 <Ariakenom> ddellacosta, internet search got me https://wiki.haskell.org/Let_vs._Where which seems fine
12:13:44 <Ariakenom> not trying to tell you your experience is wrong or anything. just investigating
12:15:56 <Peaker> is the only way to change a hackage password to reset it / "forgot password"?
12:16:07 <ddellacosta> Ariakenom: yeah, I found that only after I stumbled around for a bit. Fair point though; that does state pretty clearly what I was confused about in the third paragraph. I guess the problem is, based on the syntax error I was experiencing, it wouldn't have been clear what to search on to get this link as a result.
12:17:55 <Ariakenom> ok ok
12:21:45 <hpc> Peaker: http://hackage.haskell.org/accounts
12:23:26 <Peaker> hpc, that sounds like a yes, I guess it's OK to reset pw
12:23:50 <hpc> oh, i misread your question
12:23:55 <hpc> i read "is the only way" as "is there a way"
12:24:14 <hpc> i don't think there's another way
12:24:25 <hpc> at least, given how passwords are meant to work i hope there isn't another way
12:26:41 <hpc> /maybe/ if you're a haskell celebrity, you could do something like put "reset my hackage account and send details to blah" on https://cs.whatever.edu/~peaker
12:26:45 <hpc> then ask an admin
12:27:08 <hpc> if you lost access to your email
12:27:14 <Peaker> well, the description of the action suggests its the appropriate course of action when you forget your password, not when you just want to change it
12:27:34 <Peaker> if they just change the text to make it clear it's how you're supposed to change your password too, that'd be fine
12:27:49 <hpc> oh
12:29:13 <hpc> yeah, looks like that's the only way
12:35:11 <gazanga> Tuplanolla: are you here? i'm stuck.
12:35:17 <gazanga> :)
12:36:50 <gazanga> don't understand how to move from the list of int's [[1],[2] that i can have to to an item with a list of the two elements
12:37:10 <EvanR> > transpose [[1],[2]]
12:37:13 <lambdabot>  [[1,2]]
12:37:33 <EvanR> > zip [1] [2]
12:37:35 <gazanga> EvanR: i want to do it without library function
12:37:36 <lambdabot>  [(1,2)]
12:37:46 <EvanR> > unzip [(1,2)]
12:37:49 <lambdabot>  ([1],[2])
12:38:09 <EvanR> follow the types luke
12:38:41 <gazanga> EvanR: wait i need to give you the question itself :-)
12:39:17 <gazanga> EvanR: make all
12:39:17 <gazanga>                 the lists i can from a given list (that can be in a different size), including
12:39:17 <gazanga>                 the empty list. for example if i get this list [1,2,3], i want to get this
12:39:17 <gazanga>                 [[],[1],[2],[3],[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]. i dont want a
12:39:25 <ab9rf> gazanga: you want to get [1,2] from [[1],[2]]?
12:39:37 <ddellacosta> sounds like the opposite
12:39:40 <ab9rf> oh, you want the permutation list?
12:39:58 <ab9rf> no, not perms
12:40:10 <gazanga> to make all the list i can from a given number's list which can be in any size. including the empty list
12:40:17 <ab9rf> all-slices, i guess
12:40:19 <ddellacosta> there's the classic
12:40:21 <ddellacosta> > filterM (\x -> [True,False]) [1,2,3]
12:40:23 <EvanR> all sublists ?
12:40:25 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:40:38 <ab9rf> no, it's not all sublists
12:40:44 <ab9rf> it's broader than that
12:40:53 <ab9rf> the example inclulded reorderings
12:40:57 <EvanR> thats odd
12:40:58 <ddellacosta> ah right
12:41:15 <EvanR> so how many results should [2,2,2] give
12:41:15 <ab9rf> [3,1] isn't a sublist of [1,2,3]
12:41:22 <gazanga> EvanR from this list [1,2,3] i want to get this list  [[],[1],[2],[3],[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
12:41:36 <gazanga> and i want to di it to any length of list.
12:41:49 <EvanR> wacky
12:41:50 <ab9rf> gazanga: can we assume that the lists are of a type that is an instance of Eq?
12:42:03 <ddellacosta> cartesian product I guess
12:42:13 <gazanga> i dont know. ab9rf :-)
12:42:29 <ab9rf> ddellacosta: i'm not aware of a cartesian product definition for lists
12:42:45 <ab9rf> i think it's "all subsets", treating the list as if it were a set
12:42:56 <ab9rf> no, that's not it either
12:43:05 <ddellacosta> yeah, that's not right either is it
12:43:33 <gazanga> it is coming from here: https://youtu.be/rlwSBNI9bXE?t=17m4s
12:43:34 <EvanR> except [1,3] and [3,1] are the same set
12:43:34 <ab9rf> EvanR's question about [2,2,2] is very relevant
12:43:37 <sternmull> srk: Thank you for giving me the links to Bartosz Milewski earlier today! This is very good stuff for me to use my C++ background while learning Haskell.
12:43:45 <ddellacosta> it subsumes the cartesian product
12:43:57 <EvanR> this sounds like "every question at the same time"
12:44:31 <ab9rf> i mean, i feel like [2,2,2] ought to yield [[],[2],[2,2],[2,2,2]]
12:44:46 <Tuplanolla> Oh, gazanga's problem is very simple.
12:44:58 <gazanga> het Tuplanolla i searched for you :)
12:45:02 <gazanga> *hey
12:45:07 <Tuplanolla> > (concatMap permutations . subsequences) [1, 2, 3]
12:45:10 <lambdabot>  [[],[1],[2],[1,2],[2,1],[3],[1,3],[3,1],[2,3],[3,2],[1,2,3],[2,1,3],[3,2,1],...
12:45:10 <EvanR> and not [[],[2],[2],[2],[2,2],[2,2],[2,2],[2,2],[2,2] ...
12:45:12 <gazanga> i'm stuck :)
12:45:16 <hc> hi all, quick question, I need to exclude a specific package (cryptonite) when compiling one particular .hs file. Any way to do this in .cabal? (OPTIONS_GHC pragma doesn't work unfortunately)
12:45:31 <ab9rf> Tuplanolla: hee
12:45:55 <ab9rf> Tuplanolla: he doesn't want the subsequences of length 3, i think
12:46:13 <cocreature> hc: what do you mean by “exclude a package”?
12:46:20 <cocreature> hc: can’t you just not import it?
12:46:30 <Tuplanolla> Well, he did earlier today, ab9rf.
12:46:35 <hc> cocreature: I need to use both cryptonite and crypto-public, but they export overlapping stuff
12:46:51 <ab9rf> Tuplanolla: maybe the requirements document has been amended :)
12:47:00 <hpc> hc: try the package imports language extension
12:47:28 <gazanga> yes i want it to be for every length of a list (i i understood you well ab9rf)
12:47:35 <gazanga> *if i
12:47:38 <ddellacosta> yeah, based on that slide in the youtube link it includes all possible lengths
12:47:42 <hpc> you don't need to "exclude" any packages at all, all you need here is unambiguous importing
12:47:43 <hc> hpc: thanks! will try that
12:47:59 <ddellacosta> right, binomial coefficient, duh
12:48:57 <hc> jup indeed... didn't
12:49:08 <hc> sry, disregard the last line
12:49:14 <hc> hpc: just what i needed :-)
12:49:34 <Peaker> gazanga, http://lpaste.net/363767 <-- the direct recursive solution
12:50:10 <Tuplanolla> Might as well inline `concatMap`, Peaker.
12:50:20 <gazanga> thanks Peaker but i want a hint. i want to do it my self (i saved you solution though :-)
12:52:13 <Peaker> Tuplanolla, and map and ++ :)
12:52:20 <gazanga> i know that if i get lists [x] i return [[x]]. and for lists (x:xs) i:  lists [x] ++ lists xs. and that give me all the numbers in a list of therir own seperatley. what i don't know is how to start recirsivley build the list with more items then one.
12:52:47 <Peaker> gazanga, for [x] you want [[x], []] no?
12:52:57 <gazanga> rYes Peaker you are right!
12:54:03 <pikajude> Is it possible to link to the [] data constructor in haddocks?
12:55:11 <pikajude> i guess probably not huh
12:55:38 <EvanR> a very exciting piece of data with much to say
12:56:36 <ddellacosta> gazanga: another one to file away and look at once you figure it out, uses the filterM trick above http://lpaste.net/363768
12:58:44 <gazanga> thanks ddellacosta. does it uses monad?
12:58:58 <ddellacosta> pretty similar to Tuplanolla's solution
12:58:58 <Tuplanolla> That's the `M` in `filterM`.
12:59:01 <gazanga> because i don't know what it is. i'm very noob :-)
12:59:04 <ddellacosta> gazanga: yeah
12:59:06 <gazanga> thanks Tuplanolla
12:59:09 <gazanga> :)
12:59:35 <gazanga> i just know it exist and everybody afraid from it :-D
13:01:50 <gazanga> was it hard to you in the beginning to solve such a questions or is just me?
13:02:15 <ddellacosta> definitely hard before you get familiar! And there are still solutions that wouldn't occur to me that come to others with ease
13:02:39 <gazanga> is is very frustrting...
13:02:42 <ddellacosta> but that's also why Haskell is so appealing
13:02:42 <gazanga> *it is
13:02:56 <EvanR> manually building lists is the hard way
13:02:56 <ddellacosta> be patient with yourself and fight through it--you'll get it
13:03:00 <gazanga> *frustrating (sorry for the mistakes)
13:03:23 <EvanR> you want to think about building the answer from easy-to-understand previous-solved problems, like "sublist" "permutations" "concat" etc
13:03:31 <EvanR> "map"
13:03:53 <EvanR> the simpler problems also have a simpler solution
13:04:01 <EvanR> then you put them together
13:04:05 <EvanR> thats FP
13:04:05 <c_wraith> gazanga: don't worry about "monads".  They're less a lot less important than most sources would lead you to believe.  Just worry about expressions and types.
13:04:14 <dminuoso> EvanR: conquer and divide! :-)
13:04:29 <ab9rf> monad is just a funny word for some trypes with interesting laws. you can ignore the funny word.
13:04:49 <gazanga> concat and map i know. i think i also write them by myself.
13:04:52 <EvanR> trypeclasses
13:04:59 <ab9rf> also, i can't tyrpe
13:05:08 <ab9rf> and i'm not even drunk yet
13:05:25 <c_wraith> I dunno, that looks like a perfect example of "tyrpe"ing
13:05:58 <Ariakenom> ab9rf, "yet" lol
13:07:37 <ddellacosta> at one point I was using too many trypeclasses and my code really started to smell
13:07:40 <ab9rf> Ariakenom: it's sunday, i'm bound to have a drink sometime today
13:07:45 <ddellacosta> I'll see myself out
13:08:13 <Ariakenom> ddellacosta, how do I IP ban someone!?
13:08:24 <ddellacosta> Ariakenom: hahaha
13:12:13 <ambro718> I'm following this http://www.parsonsmatt.org/2017/09/22/what_does_free_buy_us.html but I get an error at this line:  => (forall a. f a -> m a)
13:12:35 <ambro718> Illegal symbol '.' in type   Perhaps you intended to use RankNTypes or a similar language extension to enable explicit-forall syntax: forall <tvs>. <type>
13:13:04 <EvanR> enable RankNTypes
13:13:08 <ab9rf> you need RankNType (or a similar extension) enabled to use explicit forall
13:13:16 <ab9rf> which is what the error message said
13:13:30 <ab9rf> er, RankNTypes, excuse my tired old fingers
13:13:30 <EvanR> yeah, or a similar language extension
13:13:50 <ambro718> I guess that's another magic thing I need to understand..
13:13:51 <Ariakenom> EvanR, to use explicit forall
13:14:14 <EvanR> as much as you see "forall" spelled out in haskell blogs, its not allowed in "standard" haskell
13:14:25 <EvanR> hence the extension
13:14:37 <ab9rf> RankNTypes is one of those extensions that a lot of people assume will be on for some reason
13:15:11 <Ariakenom> ab9rf, probably because they always have it on and forget it's an extension
13:15:35 <ab9rf> Ariakenom: most probably
13:15:48 <ambro718> https://wiki.haskell.org/Rank-N_types   I don't understand a word of that. Rank-1 types, "universally quantified", "forall".
13:16:28 <ab9rf> ambro718: type inference is undecidable in the presence of higher-rank types, so standard haskell prohibits them
13:20:28 <d34df00d> Hi!
13:20:37 <Ariakenom> d34df00d, Hello!
13:20:40 <d34df00d> Does peekCString free the source memory?
13:21:55 <geekosaur> no
13:22:44 <d34df00d> What's the best way to free it? Does it copy the source char* into String and it's OK to free immediately?
13:22:47 <geekosaur> it can't know if the source memory was allocated by Haskell or by the C program or possibly even using a non-reentrant static buffer as used to be common in C
13:22:58 <geekosaur> yes
13:23:20 <d34df00d> Yea, I guess you also just explained the reason for copying.
13:23:21 <d34df00d> Thanks!
13:23:23 <geekosaur> String isn't anything like C strings; using the original string is not an option
13:24:14 <d34df00d> Yeah, I guess trying to mimick the list behaviour on top of a contiguous C char array is not worth the effort.
13:24:14 <Ariakenom> type String = [Char]
13:24:37 <geekosaur> it wouldn't work anyway. C chars are 8 bits, Haskell Char-s are Unicode codepoints
13:24:58 <d34df00d> Hm, true.
13:24:59 <cocreature> and for extra fun peekCString’s decoding behavior depends on your locale
13:25:10 <geekosaur> (and ghc stores them in machine words, meaning a 64-bit value on a 64-bit architecture)
13:25:27 <d34df00d> Well, luckily I'm in ASCII world here.
13:25:42 <d34df00d> (building a wrapper around C++ demangling utilities)
13:25:49 * cocreature starts trying to find an encoding that isn’t compatible with ascii
13:26:12 * geekosaur points to ebcdic >.>
13:26:32 <geekosaur> (well, it's more a family of encodings)
13:32:23 <Younder> all encodings accept ASCII values, in Unicode the first 128 characters as ASCII and the 128 next iso-latin one. The other encodings have ASCII and then the rest to some region specific characters. So yes, ASCII always works.
13:32:54 <EvanR> if something expects utf-16 ascii will not work
13:33:42 <Ariakenom> EvanR, that was a good example. isnt that used on windows a bunch?
13:33:57 <Younder> EvanR, Not true. The first VALUES are ASCII. Of course because of the encoding yo need to read 2 bytes instead of one.
13:35:19 <Ariakenom> Younder, but encodings talk about the bytes not "values".
13:47:33 <d34df00d> Hmm, how do I call a function from a static library, and particularly how do I do this in a ghci session?
13:47:35 <catern> yeah, UTF-8 has to be specifically designed to be compatible with ASCII, in contrast with other Unicode encodings such as UTF-16
13:49:30 <c_wraith> d34df00d: what do you mean by "static library"?
13:49:57 <d34df00d> c_wraith: a .a library with the definitions of some C functions I'd like to call.
13:51:37 <c_wraith> d34df00d: in general, you create a foreign import for it.  I'm not sure that can be done in ghci, but ghci can certainly load a module that has a foreign import in it
13:52:30 <d34df00d> c_wraith: yeah, I've created a foreign import, and now I'm trying to test it, but obviously getting the "During interactive linking, GHCi couldn't find the following symbol:" error, since ghci indeed doesn't know where to look for it.
13:53:57 <c_wraith> ah.  ghci is a bit funny about that.  It's changed recently, and I don't know the details of what it was before or what it does now.
13:54:21 <c_wraith> I suspect you can pass some flag to it that tells it where to search for the symbol, but...  I have no idea what
13:56:39 <danilo2> Hi guys! Is there any Criterion util which will allow me to set assertion that if some of the benchmarks are bigger than others an warning sohuld be raised? I just want to automate checking that nobody broke code performance
13:57:28 <d34df00d> Yeah, it suggests using -L and -l, but I guess that only works for dynamic libraries.
13:57:56 <cocreature> d34df00d: which OS are you using? I thought it should work at least on linux these days
13:58:06 <d34df00d> cocreature: yea, linux.
13:58:26 <cocreature> d34df00d: cabal has extra-libraries and extra-ghci-libraries. maybe try playing with both
14:02:03 <d34df00d> http://bpaste.net/show/1dadebb8ef39
14:02:05 <hc> how do i convert a bytearray/bytearrayaccess instance to a bytestring? :)
14:02:06 <d34df00d> Meh, not gonna work.
14:06:16 <cocreature> d34df00d: what do you get in ghci if you run ":set -package ghc" followed by "import DynFlags" and "print dynamicGhc"?
14:07:07 <d34df00d> cocreature: True
14:07:28 <d34df00d> But, anyway, I just realized I have an alternative API in a shared lib.
14:07:31 <d34df00d> I'm just going to use that.
14:08:05 <cocreature> it looks like if that is False then it should work but I’ve no idea how you achieve that :(
14:08:09 <hc> ok, found it. Data.ByteArray.convert it is so generic you can't really find it by looking for the type signature :-)
14:26:15 <w1n5t0n> hey all, I have a stack project which has some dependencies, but when I try to load it in GHCi it loads my source files but can't find the dependency (the GHCi is launched as an Emacs comint process). I get the following error: http://lpaste.net/363773. Thanks!
14:27:08 <lyxia> w1n5t0n: invoke ghci with 'stack ghci'.
14:31:35 <w1n5t0n> lyxia: it has to be launched by Emacs and I don't know if I can set that, isn't there another way I can let ghci know where to find it?
14:32:32 <lyxia> I don't know
14:35:41 <typedrat> I'm trying to decide if my problem is a GHC bug, and what the correct behavior should be. When using TH to generate a bunch of code that includes type family instances (with TypeInType on), GHC will correctly find the declaration of a type family being used to specify kind when it is checking the type of a type argument, but not when it is being used on its own.
14:36:13 <gazanga> c_wraith: are you here?
14:36:32 <gazanga> c_wraith: when you say expressions, what do you mean by that?
14:37:04 <typedrat> That is, I can declare an instance with "type EventType' mach = (out :: EventIdKind mach -> Type)" in it fine, but I can't make an instance of "class FSMValidTransition mach (from :: StateIdKind mach) (via :: EventIdKind mach) (to :: StateIdKind mach)", because GHC isn't unifying StateIdKind mach with the definition it was given
14:39:33 <ambro718> I'm trying to figure out free monads; can someone show me how to be able to show the program (myProgram)? http://lpaste.net/363774
14:40:07 <lyxia> You can't always show a program even with free monads
14:40:33 <EvanR> especially with free monads
14:41:02 <EvanR> because of the functions contained in there
14:41:21 <lyxia> right
14:42:18 <ambro718> another question: would it be possible to make an interpreter that prints line numbers of the program being interpreted?
14:42:46 <ambro718> e.g. if it encounters an error at one point, it should print out clearly where in the program the error was
14:43:46 <EvanR> if by line numbers you mean wrapper sequence number
14:44:13 <EvanR> yes. you can also print out the wrapper tag
14:45:07 <ambro718> but I couldn't get line number and file name in the haskell file?
14:45:40 <EvanR> oh
14:45:49 <EvanR> sure? with template haskell
14:46:05 <EvanR> or the C preprocessor
14:46:47 <ambro718> as in, do some magic preprocessing so that each action is called together with the relevant diagnostic info?
14:47:04 <d34df00d> Is it safe to unsafePerformIO a function like this?
14:47:15 <d34df00d> http://bpaste.net/show/70c2ec43e023
14:47:22 <d34df00d> (assuming the underlying C function is pure)
14:47:41 <EvanR> ambro718: you can embed the source line number into whatever piece of data you are constructing there
14:47:50 <EvanR> yes
14:47:53 <ambro718> right
14:48:51 <EvanR> something like https://hackage.haskell.org/package/pseudomacros-0.0.2/docs/PseudoMacros.html
14:49:35 <ambro718> thanks, it was just a hypothetical question, don't need it right now
14:50:14 <c_wraith> gazanga: expressions, at the language level.  The basic building blocks - literals, value names defined in declarations somewhere, operators, function applications, etc.  The things that have types.  Understanding how types and expressions fit together is the most important part of learning haskell.
14:52:35 <gazanga> thanks c_wraith
14:55:18 <ambro718> if I do this:   data MyFunctor next = GetLine (String -> next) deriving Functor;   is it true that fmap is defined as:  fmap f (GetLine g) = GetLine (f . g)  ?
14:56:01 <EvanR> "does it type-check"
15:00:53 <ambro718> EvanR: seems to, did I say something stupid?
15:03:54 <MarcelineVQ> not stupid. iiuc there's only one right way for each datatype to create a Functor instance that typechecks, so if it does (and you didn't use undefined) it's correct
15:14:42 <lyxia> I think the principle works even in the presence of undefined in the language
15:15:07 <d34df00d> MarcelineVQ: depends.
15:15:22 <lyxia> the condition "typechecks" is not sufficient, it also needs "fmap id = id"
15:15:22 <d34df00d> Consider list. You can surely write fmap f xs = [], which typechecks but is incorrect.
15:27:41 <MarcelineVQ> d34df00d: yeah :(
15:27:59 <exio4> MarcelineVQ: if by typecheck means "obeys functor's laws", yeah, sure
15:36:28 <heptahedron> acowley_: Hi! I'm the one who was looking into allowing type-changing lenses in vinyl, had a few questions about the library
15:38:29 <dminuoso> d34df00d: Is your cxa_demangle referentially transparent?
15:40:33 <d34df00d> dminuoso: yep.
15:54:03 <dminuoso> d34df00d: This is probably a silly question.. but doesn't that function allocate storage?
15:54:32 <d34df00d> dminuoso: it does, but semantically that doesn't matter given that I always free it.
15:54:39 <d34df00d> Does it?
15:56:11 <heptahedron> acowley_: For instance, vinyl seems to only support ghc versions above 8.0, but many of the functions in the library still accept a Proxy argument where TypeApplications seems like it would suffice. Is there a reason for this?
15:59:03 <dminuoso> d34df00d: Im convinced that this has to be IO CString.
15:59:25 <d34df00d> dminuoso: why? Now I'm curious about your reasoning :)
16:04:19 <dminuoso> d34df00d: Referentially transparent means you could turn it into a lookup table.
16:04:49 <dminuoso> And you are calling `free` on the return..
16:05:18 <dminuoso> But what do I know. Perhaps its legit if you know exactly how GHC will treat your code.
16:05:53 <dminuoso> (but something that causes side effects you need to triage sounds like IO to me)
16:10:06 <dminuoso> But a function `a0 -> CString` for some monomorphic `a0` does seem unsound.
16:19:02 <d34df00d> dminuoso: that's why the `free` is part of what is gonna be fed to unsafePerformIO.
16:19:25 <d34df00d> If you turn the whole function in the lookup table, there should be no observable difference.
16:19:52 <d34df00d> (arguably even free can be considered as unimportant modulo memory consumption)
16:20:23 <dminuoso> d34df00d: There would be an observable difference when it _crashes_ due to free trying to free an already freed string.
16:20:33 <dminuoso> So clearly the function is not referentially transparent
16:21:28 <dminuoso> d34df00d: Just be honest and state that it produces IO CString, run it inside your small function - and then unsafePerformIO the whole thing.
16:22:06 * shkupi free btc https://getcryptotab.com/362330
16:23:34 <d34df00d> dminuoso: yes, I totally agree free is not referentially transparent, but I"m talking about the whole top-level demangle function, not the underlying cxa_demangle.
16:24:04 * dminuoso is not an expert ¯\_(ツ)_/¯
16:24:21 <d34df00d> Also, I just realized another point — cxa_demangle isn't referentially transparent either! It indeed returns the same string for the same parameters set, but that string resides at a different address every time, so the actual returned value is different!
16:24:28 <d34df00d> So indeed, cxa_demangle must be -> IO CString
16:24:46 <d34df00d> You were probably talking about this too :)
16:24:51 <dminuoso> d34df00d: Oh I was just talking about cxa_demangle ;)
16:24:59 <dminuoso> Sorry if that was not clear
16:25:19 <d34df00d> Ah, glad it got figured out!
16:26:00 <Ariakenom> (The value can be the same if the address is different)
16:27:50 <dminuoso> d34df00d: With that change your function seems safe to unsafePerformIO
16:28:31 * Ariakenom likes the choice of words safe.
16:28:50 <d34df00d> dminuoso: great, thanks for confirming! And for spotting a bug too :)
16:30:52 * shkupi free btc https://getcryptotab.com/362330
16:31:28 <Ariakenom> spam is off-topic
16:32:37 --- mode: ChanServ set +o dibblego
16:32:43 --- mode: dibblego set +b *!*@212.110.89.62
16:32:47 --- kick: shkupi was kicked by dibblego (shkupi)
16:33:03 --- mode: ChanServ set -o dibblego
16:33:45 <Ariakenom> That is an interesting series of events for someone not familiar with IRC dibblego.
16:34:13 <Ariakenom> btw "not familiar with IRC" is me
16:36:04 <CodeKiwi> stick around and it will become all too common
16:53:59 <heptahedron> Is there a term I can look up to better understand the point and use of typeclasses suffixed with 1? I see them everywhere but have yet to grok what they are exactly
16:54:56 <jmcarthur> heptahedron: I see that the most when there is some type class   Foo :: * -> Constraint  , then there might be a  Foo1 :: (* -> *) -> Constraint
16:55:13 <jmcarthur> Or perhaps even a  Foo1 :: (k -> *) -> Constraint
16:55:44 <heptahedron> jmcarthur: interesting. So for something like `Eq1`, for instance, you could define a boolean equality between types like `Const a`?
16:55:51 <jmcarthur> I don't know how much you know. If you are a beginner or perhaps even intermediate, then my syntax might not be helping.
16:56:12 <jmcarthur> Okay, it sounds like you understand.
16:56:23 <heptahedron> I'm on friendly terms with types and kinds, haha
16:58:32 <catern> PL theory question: is there any difference at all between algebraic effects/effect handlers, and delimited continuations?
16:59:09 <catern> I keep seeing these things about effect handlers and they seem to be precisely identical to multiprompt delimited continuations, so why the new term?
16:59:29 <heptahedron> catern: IANACT but I believe they are effectively isomorphic
17:00:02 <heptahedron> the new term is probably just an instance of the same concept being spoken about in different contexts
17:00:04 <catern> they're definitely isomorphic, but that doesn't mean much in this area since a ton of things are isomorphic to other things
17:00:26 <catern> but they're more than isomorphic, they're identical
17:00:51 <jmcarthur> Also interested in the answer to that question. I have not seen anything one can express that the other can't express exactly the same way, except for some versions of algebraic effects that have some (apparently needless or implementation-driven) limitations.
17:01:19 <jmcarthur> e.g. I've seen some with only one-shot continuations
17:01:51 --- mode: ChanServ set +o dibblego
17:01:53 --- mode: dibblego set +b *!*@185.2.188.17
17:01:58 --- kick: shkupi was kicked by dibblego (shkupi)
17:02:01 --- mode: ChanServ set -o dibblego
17:02:43 <jmcarthur> My impression is that some people are intimidated by delimited continuations and the new presentation seems more approachable.
17:03:21 <catern> jmcarthur: that's what I was kind of guessing :) "effect handlers" is certainly vastly better terminology than "shift/reset", that's for sure :)
17:12:20 <dminuoso> heptahedron: class Eq1 f where eq1 :: Eq a => f a -> f a -> Bool
17:12:34 <dminuoso> heptahedron: The purpose is to do tricks like: instance (Eq1 f) => Eq1 (T f) where eq1 = (==)
17:13:26 <dminuoso> (Avoiding UndecideableInstances)
17:13:37 <dminuoso> *UndecidableInstances
17:17:59 <heptahedron> dminuoso: Ah, thanks!
17:18:48 <lyxia> heptahedron: a common example that needs this is newtype Fix f = Fix { unFix :: f (Fix f) }, just try do write an Eq instance for it.
17:19:22 <lyxia> Now Eq1 is going to be mostly replaced by a quantified constraint (forall a. Eq a => Eq (f a))
17:19:41 <lyxia> "now" being the near future of course.
17:20:27 <heptahedron> lyxia: Oh that's a good motivating example, thanks. Both for `Eq1` and quantified constraints, which until now I hadn't really looked into
17:20:40 <heptahedron> you wouldn't happen to be lysxia on github would you?
17:20:47 <lyxia> that's me
17:21:04 <lyxia> what did I do
17:21:19 <heptahedron> Oh cool! and nothing haha, I just happened to see your username while browsing `vinyl` issues
17:30:40 <texasmynsted_> wow, last edited 2013 https://github.com/fpco/haskell-ide/wiki
17:32:02 <texasmynsted> is there not an ensime type solution for haskell?
17:33:03 <jmcarthur> Intero is kind of sort of that.
17:33:12 <jmcarthur> There's also Dante, which I've never tried
17:33:23 <jmcarthur> These aren't *really* like ensime
17:37:14 <texasmynsted> ok.  Thanks, I will check them out.
17:37:28 <texasmynsted> ohh.  I see why I have not tried them, they are emacs ..
17:45:18 <texasmynsted> I like the idea of separating the features from a particular editor.
17:45:21 <le_frogballs> is there any open ticket/milestone for exporting qualified modules https://wiki.haskell.org/GHC/QualifiedModuleExport ?
17:45:24 <texasmynsted> ... since I use vim
17:47:04 <elpfen> I'm doing some image manip with JuicyPixels and just copying an image gives these weird glitches. Anyone have any idea why this would be? https://imgur.com/a/GyhnP
17:47:20 <elpfen> using `writePng path $ generateImage (pixelAt img) x y`
17:55:56 <pacak> http://lpaste.net/363776 - suppose I have a class with constraint (Category with constraints on elements) and I want to add a notion of Cartesian Category by adding one of the projections - it works in simple cases (foo1) but as soon as you compose it with anything ghc starts demanding more constraints. Is there a way to tell ghc something like "k is a Cartesian as long as k is a category and  given Ok k a and Ok k b we have Ok k (a, b)"?
18:20:23 <Broli> Hallo! :)
18:20:54 <Broli> can someone explain me what's type family? thanks :)
18:21:23 <EvanR> like a function from types to types
18:21:41 <EvanR> F Int = Bool
18:21:45 <EvanR> F Char = Bool
18:21:54 <Broli> EvanR: can you take some real example please :)
18:21:57 <EvanR> F Bool = Integer
18:22:09 <EvanR> later you can use F in a type signature
18:22:27 <EvanR> a -> Either Char (F a)
18:23:04 <EvanR> type level programming
18:24:24 <Broli> EvanR: that mean when you say F a. F a is a Integer?
18:24:34 <EvanR> no F a is a type
18:26:11 <Broli> EvanR: i don't check this very well
18:26:31 <Broli> can you take please another example?
18:27:09 <EvanR> another example, lets say you want to define a VectorSpace class
18:28:04 <EvanR> for any type A you implement VectorSpace, you may also want to define the type of scalars, Scalar A
18:28:43 <EvanR> so if you define VectorSpace (V4 Double), you could define Scalar (V4 Double) = Double
18:28:52 <EvanR> but the general type of scaling a vector would be
18:29:07 <EvanR> scale :: VectorSpace a => Scalar a -> a -> a
18:29:40 <EvanR> that is also possible with TypeFamilies
18:29:53 <EvanR> Scalar is a type family
18:33:03 <Broli> EvanR: okay thanks, i think, i get this :)
19:57:46 <et09> so i've been working with react/redux about 2 years - it's getting on my nerves - my question is, in haskell FRP, are there higher order ways to abstract away the difficulties like, if you're using redux just as a setter?
19:57:53 <et09> setter/getter
19:58:11 <et09> because i've noticed it's a ton of conceptual overhead for cases where you often want just simple global state
20:04:31 <vaibhavsagar> et09: if you want 'simple global state' you're going to have a bad time
20:13:23 <kenndel> Guys I'm so close! my issue is quite general. MY expected type for this is `UniqMonad0 b` and my actual type is `a -> UniqMonad0 b`. I feel like I'm blowing it but how can i shave that a off? Thanks!
20:15:04 <kenndel> I basically need to do a beta reduction in my definition to get rid of this thing
20:19:23 <pavonia> Is `a -> UniqMonad0 b' the actual type of that function?
20:20:25 <kenndel> No. The type is `UniqMonad0 a -> (a -> UniqMonad0 b) -> UniqMonad0 b`
20:20:39 <kenndel> So I've basically gotten to step 2 and am trying to get to step 3
20:21:27 <pavonia> So you need to get the a out of the first action and apply it to the function to get the result
20:22:28 <kenndel> Essentially, ya. This is in building an abstraction onto a state monad
20:23:03 <unyu> Out of curiosity, is there any reason why there is no implementation of exponentiation by squaring in Data.Semigroup? The algorithm can be used to compute k*x^n in any semigroup (multiplicative notation, but no relation whatsoever to Num).
20:23:06 <kenndel> So I'm trying to write my bind abstraction
20:24:46 <pavonia> kenndel: How is UniqMonad0 defined?
20:25:41 <dfeuer> dolio: what do you think about https://github.com/haskell/primitive/pull/87 and https://github.com/haskell/primitive/pull/88?
20:39:38 <kenndel> pavonia, sorry had to be away for a second. `type UniqMonad0 a = Int -> (a, Int)
20:42:45 <pavonia> And what do you have so far for your bind implementation?
20:56:19 <kenndel> pavonia, sorry, last distraction. dog was acting up.
20:57:35 <kenndel> right now based off guides that I've been reading i have `bindU a = \x -> let (a, y) = return bindU x in x`
20:57:53 <kenndel> but i can't really defend any portion of this. It's just what i've been able to throw together that has been getting me closer and closer
20:59:18 <pavonia> `return bindU x' doesn't look correct
20:59:51 <kenndel> Right, i shouldn't be calling this function itself
21:00:22 <kenndel> ok so just dripping bindU from it gets me basically the same thing
21:00:34 <kenndel> expected UniqMonad b actual a-> UniqMonad b
21:02:21 <pavonia> Think about what you have: a function `Int -> (a, Int)' from the first action, and a function `a -> (Int -> (b, Int))`. What you want is to compose these functions t get a `Int -> (b, Int)`
21:03:39 <pavonia> `x' is you input state, that already gives you the `(a, Int)' part from which you then can get the `Int -> (b, Int)' function
21:05:39 <pavonia> First of all, bindU should get two parameters: `bindU fa g = \x -> ...'
21:06:55 <pavonia> with `fa :: UniqMonad0 a' and `g :: a -> UniqMonad0 b'
21:09:28 <kenndel> ok im following
21:09:33 <kenndel> just had a vim swap file crisis haha
21:12:52 <pavonia> Oh well, I don't want to give away the answer, it's your turn. Just follow the types :p
21:13:13 <kenndel> Ok! Thank you!
21:29:29 <texasmynsted> anybody know what happened to _The Haskell Cast_?
21:47:58 <kenndel> pavonia, I
21:50:01 <kenndel> pavonia, I'm still not sure what I'm doing wrong here. Currently have `bindU a b = \x let (a, b) = a x in return a` which gives me (b, Int -> t0).. I've been trying to figure out these types but I'm not sure what the let in block is supposed to be accomplishing and how to apply it :(
21:51:14 <pavonia> Don't use duplicate variable names, the second `a' shadows the first one
21:52:42 <kenndel> You mean in (a, b) = a x? This is the part where I'm not sure what the purpose of the let in is
21:54:10 <pavonia> A `let' brings in new bindings. In that case it brings two new variables `a' and `b' into scope
21:54:58 <kenndel> Oh! ok so (c, d)
21:55:00 <pavonia> The problem is that you lose your first function parameter by that, because it's also named `a'
21:55:59 <kenndel> `bindU a b = \x -> let (c, d) = a x in c`
21:56:09 <kenndel> so c = 'a' for me now
21:56:13 <kenndel> so i've extracted a
22:00:50 <pavonia> Yup, looks good so far
22:04:09 <kenndel> So now how do i use a to get out UniqMonad b?
22:04:12 <kenndel> Any hints?
22:06:46 <pavonia> Again, the types help you to find the next step. You've got a value of type `a' and a function `a -> UniqMonad b'. There's only one thing that you can do with these things
22:09:08 <EvanR> is this a valid haskell hack. you want a data type which... if youre holding a value of it, you can use it, which causes lazy evaluation of it to begin. but also you want to hold onto "the beginning of it" (the original thing, unevaluated), with the possibilities of not leaking memory if you forget all the work
22:09:32 <EvanR> so you implement it as () -> T instead of T
22:10:29 <EvanR> scenario, you decide while analyzing it you want to evaluate it another way and start over, so you for get the T
22:12:06 <kenndel> pavonia, I have `bindU a b = \x -> let (c, d) = a x in return (b c)` which gives me expected type: (b, Int) and actual type (b, UniqMonad b)
22:13:28 <pavonia> Yes, you're not finished yet. Note tht you still have a value `d' that you haven't used anywhere
22:14:06 <pavonia> kenndel: What's the type of `b c'?
22:15:06 <kenndel> InuqMonad b
22:15:08 <kenndel> Uniq*
22:15:30 <pavonia> And in `bindU a b = \x -> let (c, d) = a x in ...', what should the type of `...' be?
22:15:58 <kenndel> UniqMonad b
22:16:24 <pavonia> No, that's the result type of the whole thing on the right-hand side of `='
22:16:24 <kenndel> but when i run this it says `expected type: (b, Int), actual type: UniqMonad b`
22:18:31 <pavonia> You have `bindU a b :: UniqMonad b' which is the same as `Int -> (b, Int)'
22:19:29 <pavonia> `\x -> ...' is a function, which means that the result of that function `...' cannot have type `UniqMonad b'
22:20:03 <pavonia> The type checker gives you a hint what type is expected there
22:21:09 <kenndel> So i just want (b, Int) in the end, right?
22:21:32 <kenndel> How do i drop the Int from Int -> (b, Int) ?
22:22:10 <kenndel> i know d is an Int
22:22:29 <kenndel> omg i think i just got it
22:22:42 <kenndel> `bindU a b = `x -> let (c, d) = a x in (b c) d`
22:24:13 <pavonia> Yep, that looks good :)
22:24:30 <kenndel> thank you so much!
22:24:43 <kenndel> I dunno why after this whole quarter basic function application took me down
22:24:48 <kenndel> i kept doing d (b c) haha
22:24:57 <kenndel> haskell is a cruel mistress
23:16:32 <cocreature> texasmynsted: https://www.reddit.com/r/haskell/comments/7u38u6/haskellcast/ they’re just busy atm
23:37:36 <dminuoso> After searching for a while, this seems to be something the GHC manual does not like to talk about. What exactly does IncoherentInstances do?
23:38:41 <cocreature> dminuoso: it’s explained fairly well in the GHC manual https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#instance-overlap
23:40:09 <dminuoso> cocreature: Okay maybe I should rephrase then.. how arbitrary is arbitrary? Does GHC simply roll a dice?
23:41:53 <cocreature> dminuoso: I suspect that it’s deterministic but can easily change (e.g. by adding imports, new compiler versions, …). “arbitrary” basically means “if you care about which one it choses, incoherent instances are not the thing you want to use”
23:47:43 <unyu> cocreature: In other words, “if you don't want GHC's choice to matter, it's your responsibility to ensure all choices are equivalent”?
23:47:53 <cocreature> yep
23:51:55 <unyu> Can this choice vary from one function call to the next?
23:53:02 <dminuoso> cocreature: Interesting. This seems to imply that you have some reason to know that resolution with either choice will lead to the same result.
