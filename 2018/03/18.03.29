00:00:05 <johnw> you take a Map, map over it to turn it into a map of functions taking maps, and then loeb it to work out all the cross references
00:00:09 <enterprisey> I've been messing around with some pattern matching, but haven't gotten anything to work yet
00:00:11 <enterprisey> Any ideas?
00:00:49 <vaibhavsagar> johnw: reminds me of unpacking a Git packfile
00:01:27 <johnw> yep, this should work well for doing evaluation over any DAG
00:01:50 <johnw> it's using Haskell's laziness to deal with the references and what has already been evaluated or not yet
00:02:03 <vaibhavsagar> so it's a build system like the recent paper by Andrey Mokhov, SPJ, and Neil Mitchell?
00:02:14 <vaibhavsagar> or you could use it as one
00:02:18 <johnw> what, Nix?
00:02:32 <vaibhavsagar> no, I know what Nix is :)
00:02:36 <vaibhavsagar> I meant loeb
00:02:53 <johnw> oh, it's simply a resolver for self-referential structures
00:03:07 <johnw> it turns a "container full of evaluators from containers to results", into a "container of results"
00:03:08 <vaibhavsagar> https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf
00:03:16 <johnw> https://github.com/quchen/articles/blob/master/loeb-moeb.md
00:03:31 <vaibhavsagar> yeah, I just opened that in a tab earlier
00:03:44 <vaibhavsagar> I've read the Dan Piponi blog post but it made no sense to me at the time
00:04:14 <johnw> I think I have another use for that paper you mentioned, though
00:04:14 <xandaros> enterprisey: You probably shouldn't ever do this, but you can probably create a new class with a new show function and make derived instances (instance (Show a) => Show2 A where ...). Then make a specific instance for Char. This will require OverlappingInstances (bad idea)
00:04:36 <enterprisey> xandaros: my current approach is Data.Typeable and making typeof comparisons, which is also a very bad idea
00:04:48 <enterprisey> it's for a meme, not anything that will ever be seriously used
00:04:57 <xandaros> good :D
00:05:00 <johnw> enterprisey: if it's just for display, and performance is no option, then what's the problem with that?
00:05:39 <enterprisey> johnw: I think xandaros's approach is also good
00:05:52 <johnw> yeah, that should work too
00:08:14 <enterprisey> hmm - so right now I have show' x = if typeOf x == typeOf a then [x] else show x
00:08:17 <enterprisey> sadly, that only takes Chars
00:16:57 <nshepperd> enterprisey: use the typesafe cast in Data.Typeable: case cast x of { Just c -> [c]; Nothing -> show x }
00:17:45 <enterprisey> nshepperd: thank you for saving me from the triple threat of UndecidableInstances, OverlappingInstances, and FlexibleInstances
00:21:50 <nshepperd> comparing TypeReps with (==) works, but since it's a plain old Bool it doesn't get that equality information into the type level for you, requiring you to unsafeCoerce it yourself
00:22:59 <orzo> Does ghc do any memoizing for expensive type-level functions?  Is it possible to make that happen for specific functions?
00:26:27 <xandaros> enterprisey: Add IncoherentInstances for extra fun
00:26:54 <xandaros> I actually use UndecidableInstances... hmm
00:29:14 <xandaros> Looking at some of my file headers, I feel like there aren't many extensions I don't use xD
00:29:27 <enterprisey> thanks everyone for their help, the meme is deployed @ hmastodon.technology/@danielhglus/99766011961598083
00:29:41 <enterprisey> (I typo'd the link mastodon.technology/@danielhglus/99766011961598083)
00:55:00 <pingu-> There was a haskell project released between six months to a year ago that, iirc, gave docker containers types for data processing and provided a mechanism for composing and running them.
00:55:10 <pingu-> Does anyone know what I'm talking about, and/or remember the name?
00:55:16 <pingu-> I can't seem to google.
01:31:54 <risciii> Hi
01:32:11 <risciii> Can a transaction system be made purely functional
01:32:23 <infinisil> risciii: Like STM?
01:32:27 <risciii> How do we store the state of accounts, balances etc
01:33:21 <infinisil> risciii: Yeah STM sounds like a good candidate, or a database. Both of which support atomic transactions
01:35:09 <halogenandtoast> Probably a long shot, but I can't seem to get Persistent to detect my db, libpq: failed (could not connect to server: Connection refused...), but I'm pretty sure my database is running as I can connect to it with the same details as in my config
01:35:22 <halogenandtoast> Does anyone know if persistent doesn't work with postgres 10.3
01:35:49 <infinisil> risciii: If you missed it: STM sounds like a good candidate, or a database. Both of which support atomic transactions
01:36:02 <infinisil> risciii: https://hackage.haskell.org/package/stm
01:38:11 <risciii> thanks infinisil
01:39:57 <risciii> I should probably google first then hit the IRC :)
01:40:04 <halogenandtoast> I just unregistered postgresql-libpq and tried reinstalling it, still the same result
01:40:19 <lemmih> halogenandtoast: Are you connecting on the right port?
01:40:35 <lemmih> herzmeister[m]: "connection refused" means it didn't even get to try to login.
01:40:38 <halogenandtoast> I think I just found my problem
01:40:57 <halogenandtoast> stack.yaml -> docker: enable: true auto-pull: true
01:41:57 <halogenandtoast> that was it
01:42:01 <halogenandtoast> *sigh*
01:42:45 <merijn> risciii: Well, are you looking for something database like or just "doing some random code transactionally"?
01:46:39 <risciii> It's for satisfying my curiosity
01:47:03 <halogenandtoast> Does anyone know how to turn this into an "or" so I can specify two different ids to search for?
01:47:06 <halogenandtoast> html . allAttributed(ix "id" . only "newsarticle")
01:47:11 <merijn> risciii: Then yes, STM. The docs for the stm package should have references to some papers on the design/implementtation
01:47:22 <halogenandtoast> Using taggy lens
01:47:31 <risciii> Is there something database like too? Merlin?
01:47:42 <risciii> Eyes gleam
01:47:57 <vaibhavsagar> risciii: are you thinking of OCaml's Irmin?
01:48:03 <risciii> Merijn *
01:48:38 <merijn> Oh, I suppose the other functional + transactional thing would be would be acid-state
01:48:49 <halogenandtoast> No sure what to even google to find the answer, is there a name for a lens that behaves like an or?
01:48:52 <merijn> Which provides the ability to store Haskell data with ACID guarantees
01:49:04 <risciii> Thanks vaibhavsagar, no I didn't think of that. Nice find
01:49:06 <Gurkenglas_> halogenandtoast, are you looking for failing?
01:49:25 <merijn> risciii: Most database interaction tends to go via IO, but there's no inherent reason why it couldn't be tied into STM with some work
01:49:46 <risciii> Haskell darcs?
01:49:49 <halogenandtoast> Gurkenglas_: do you mean failover? maybe
01:49:53 <risciii> cool
01:50:12 <Gurkenglas_> halogenandtoast, no, failin
01:50:15 <Gurkenglas_> *failing
01:50:53 <risciii> Thanks merijn
01:51:55 <Gurkenglas_> halogenandtoast, what do you mean by or? You want to combine two "lenses" that don't always match into one that uses the first of the two that match something?
01:52:30 <halogenandtoast> Basically I want something like this 5 ^? any [4, 5] => 5
01:52:41 <halogenandtoast> as apposed to 5 ^? only 4 => Nothing
01:53:02 <Gurkenglas_> > 5 ^? filtered (`elem` [4,5])
01:53:05 <lambdabot>  Just 5
01:53:16 <halogenandtoast> I'll try that
01:53:27 <Gurkenglas_> > 5 ^? (only 4 <> only 5)
01:53:30 <lambdabot>  Just ()
01:54:17 <halogenandtoast> Gurkenglas_: high five! It did what I was looking for
02:03:23 <Profpatsch> johnw: pong
02:26:25 <robstr> Hey, I struggle with the `aeson` library, I have a instance of `FromJSON` for `Bla` but I cant find a way to align the types, my `[Bla]` list is neasted under `data` https://gist.github.com/rsoeldner/3f06eca021bea68c808aac87a0ecdb56 can someone help out here ?
02:37:45 <tdammers> robstr: could you boil it down to a test case that has a hard-coded JSON input instead of making an HTTP request, and describe the errors you are getting?
02:38:06 <tdammers> robstr: also, adding the definition of Bla itself would be super helpful
02:38:53 <robstr> tdammers: sure
02:38:59 <tdammers> robstr: if you're getting type errors, a good first step is to add type annotations and see where exactly your expectations aren't met
02:40:38 <robstr> tdammers: • Couldn't match type ‘Parser (Parser a0)’ with ‘[Bla] - its the way i try to parse the list of [Bla]
02:41:20 <robstr> tdammers: because I already have an instance of FromJSON Bla, let me try to add a working example
02:41:22 <dminuoso> robstr: Can you edit your gist to have a .hs extension to enable syntax highlighting, as well as including the full error message?
02:43:34 <robstr> dminuoso: check again, updated the gist
02:44:01 <brynedwards> robstr: If you're trying to parse an array of `Bla`s, I'd use a newtype for Vector and write the Bla FromJSON instance to parse a single Bla
02:44:38 <robstr> brynedwards: the FromJSON Bla instance just parses one bla
02:44:58 <brynedwards> robstr: And inside the "data" JSON object is a single object?
02:45:15 <brynedwards> Or a JSON array?
02:46:10 <robstr> brynedwards: a JSON array
02:46:47 <brynedwards> OK, well I usually something like this http://lpaste.net/364128 then IO (ApiList Bla)
02:46:49 <kosmikus> robstr: you cannot apply a parser using (<$>). you'll have to call parse or parseMaybe. also, "returning" a call to parseJSON leads to the Parser (Parser ...) type which is most certainly not what you want.
02:48:33 <robstr> kosmikus: Ah i see, makes sense
02:48:51 <robstr> brynedwards: this could be an easy fix, thank you
02:49:47 <iron_houzi> Is it possible to define a string class where a must match any string in a list?
02:50:18 <iron_houzi> ..and if possible, is it even idiomatic?
02:51:37 <Axman6> iron_houzi: I'm not sure I understand the question, can you give an example?
02:52:51 <iron_houzi> OK, let's say I'd like to have a class Vowel defined as a string matching any of ["a", "e", "i", "o", "u", "ae"]
02:57:35 <Axman6> what would you ike to do with that class?
03:02:07 <iron_houzi> Axman6: I'm doing language parsing, converting latin character representation of non-latin language to native language unicode .. for this, I need to break down a word and do a bunch of analysis and validation. The first part of this process is to locate the vowel. I'm trying to learn by doing, so I really don't know if I'm going about this the correct way. I thought that defining types would be a good
03:02:09 <iron_houzi> start.
03:03:06 <iron_houzi> The first thing I'd need to do is to check if a string contains a vowel and at what position ..
03:03:37 <Axman6> that sounds a lot like a regular expression to me
03:05:24 <iron_houzi> Axman6: .. what are you implying?
03:05:42 <Axman6> that you could use regexes :\
03:06:10 <Axman6> the above class would be represented by "(ae|a|e|i|o|u)"
03:07:22 <iron_houzi> Axman6: Can you define a class based on a regex?
03:07:35 <Axman6> do you mean a Haskell class?
03:07:38 <iron_houzi> yes
03:09:05 <Axman6> I guess you could, but I'm not sure classes are the right ool for this, but I still don't understand what you're trying to do. you should have a look at facebook's duckling library, it might be relevant to you
03:10:00 <iron_houzi> Axman6: Do you know what pinyin is?
03:10:06 <dminuoso> iron_houzi: What kind of parser are you building?
03:10:06 <Axman6> no
03:10:11 <dminuoso> iron_houzi: Are you using parser combinators?
03:11:18 <iron_houzi> dminuoso: I think that would be the direction I'm taking yes .. but as a beginner I have to start somewhere and I'm trying to figure out where that is.
03:17:34 <Axman6> aare you intending to use several of these classes?
03:17:56 <dminuoso> iron_houzi: I think you may not understand what a Haskell class exactly is for.
03:18:20 <dminuoso> It really sounds like you're trying to think of a Java-style class.
03:19:10 <iron_houzi> It's really hard to explain what I'm trying to solve without understanding the domain .. I'm parsing latin strings and converting to Asian native unicode strings. These languages are not one dimensional, i.e left to right, but in addition top to bottom .. what determines if a combination of letters should be vertical or horizontal depends on the combinations .. all these combinations are classified with
03:19:13 <iron_houzi> specific names.. I thought it would be nice to start out by defining these classes, and the first one would be vowels..
03:19:40 <dminuoso> iron_houzi: Do you know what a haskell typeclass is?
03:20:23 <iron_houzi> dminuoso: I'm a complete beginner, so I'm getting the feeling that my initial idea about what classes are for is incorrect.
03:20:38 <dminuoso> iron_houzi: What language background do you have?
03:20:52 <Axman6> "finding all the vowels" is what regular expressions would give you (one of the rare cases where I would recommend their use in fact), but what you need to do next will determine if that's a sensible approach or not
03:21:31 <dminuoso> iron_houzi: Haskell typeclasses are similar to Java interfaces or C++ concepts. A typeclass contains some interface (defined by some methods) - then a type can have an instance of that typeclass (i.e. it implements that interface).
03:21:40 <iron_houzi> What I thought was that a Haskell class is for is to define a type subset where the value meets some criteria
03:22:29 <iron_houzi> The languages I know are Java, C, Python, asm and racket
03:22:33 <dminuoso> iron_houzi: This allows some piece of code to allow for some polymorphic `(Foo a) => a -> a -> Bool` for example. It's not decided what `a` exactly is, just that it must an instance for Foo.
03:22:48 <dminuoso> iron_houzi: Eq is a good example of what a typeclass is about.
03:22:58 <dminuoso> It's merely the interface to compare two objects
03:23:19 <Axman6> if you read (Eq a) => ... as "a implements the interface Eq" then that will give you some idea
03:24:11 <dminuoso> iron_houzi: Racket typeclasses are the same thing afaik, and Java interfaces are also very similar to Haskell typeclasses.
03:24:33 <TMA> iron_houzi: in other terminology a haskell typeclass is a protocol - a set of methods/functions ; if a type a is an instance of class Cls a, then there are functions operating on a that match the 'prototypes' in Cls
03:25:02 <iron_houzi> dminuoso: OK, what do you think about my initial understanding of Haskell classes ^^ ?
03:25:34 <dminuoso> iron_houzi: Typeclasses are not about values. They are about types.
03:25:42 <iron_houzi> OK
03:26:20 <TMA> iron_houzi: java's Comparable would be a typeclass
03:26:28 <iron_houzi> But Eq is bound by the == operator, no?
03:26:34 <dminuoso> iron_houzi: "bound" ?
03:26:50 <dminuoso> iron_houzi: (==) and (/=) are methods of the typeclas Eq.
03:27:21 <merijn> iron_houzi: My favourite way to try and clarify things is to explain types with constraints as having an implicit "if/then" in them. i.e. "foo :: Eq a => a -> a -> a" can be read as "IF the type 'a' has an instance of 'Eq' THEN 'foo' has type 'a -> a -> a' ELSE type error"
03:27:43 <iron_houzi> .. my teacher talked about this in terms of a set being "bound" or "closed" by an operator ..
03:28:52 <iron_houzi> But, yes .. I see my flawed understanding though, so thanks for clearing that up for me
03:48:59 * hackage cabal-rpm 0.12.2 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-0.12.2 (JensPetersen)
03:49:59 <heinrich5991> how do I index a list by an integer in haskell?
03:50:06 <heinrich5991> I want Int -> [a] -> Maybe a
03:50:10 <merijn> heinrich5991: !! but you really shouldn't
03:50:17 <merijn> heinrich5991: Oh, there's no safe index
03:50:23 <heinrich5991> wat. wow
03:50:24 <merijn> You could do:
03:50:36 <merijn> :t \n -> listToMaybe . drop n
03:50:38 <lambdabot> Int -> [a] -> Maybe a
03:50:55 <merijn> heinrich5991: Lists are terrible for random access and really shouldn't be used for that
03:51:46 <heinrich5991> yes. but there's !!, so it seemed to me that there should be the same for getting a Maybe a. *shrug*
03:51:52 <hc> Hi all, I've got another cryptonite question: I've looked at the Crypto.KDF.Argon2 implementation and it seems the C call is made unsafely. Shouldn't it be made in "safe" mode, as the C call takes some time (~some seconds) to finish?
03:52:50 <athan> heinrich5991: there's the `safe` package iirc
03:52:59 * hackage websockets-snap 0.10.2.5 - Snap integration for the websockets library  https://hackage.haskell.org/package/websockets-snap-0.10.2.5 (JasperVanDerJeugt)
03:55:00 <Axman6> @hoogle Int -> [a] -> Maybe a
03:55:01 <lambdabot> Safe atMay :: [a] -> Int -> Maybe a
03:55:01 <lambdabot> Agda.Utils.List (!!!) :: [a] -> Int -> Maybe a
03:55:01 <lambdabot> CLaSH.Util indexMaybe :: [a] -> Int -> Maybe a
03:55:19 <Axman6> @more
03:55:30 <Axman6> @hoogle+
03:55:31 <lambdabot> ShellCheck.AnalyzerLib (!!!) :: [a] -> Int -> Maybe a
03:55:31 <lambdabot> XMonad.Util.Stack getI :: Int -> [a] -> Maybe a
03:55:31 <lambdabot> Safe.Exact takeExactMay :: Int -> [a] -> Maybe [a]
03:56:00 <heinrich5991> Axman6: why don't I find it with https://www.haskell.org/hoogle/?hoogle=%5Ba%5D+-%3E+Int+-%3E+Maybe+a ?
03:56:37 <Axman6> not sure
03:57:51 <iron_houzi> @hoogle data Vowel = "a" | "e" | "i" | "u" | "o"
03:57:52 <lambdabot> package base
03:57:52 <lambdabot> package bytestring
03:57:52 <lambdabot> package containers
03:58:17 <Axman6> iron_houzi: that's not how data declarations work
03:59:01 <Axman6> you could have: data Vowel = A | E | I | O | U | AE and write functions using that type, but Haskell has no notion of subtyping
03:59:25 <iron_houzi> Axman6: Thanks. In the book I'm reading, I see `data Bool = False | True`. Are True/False actual values here?
03:59:54 <dminuoso> iron_houzi: More.
04:00:01 <Axman6> yes, that is _the_ definion of Bool in Hakell, bools aren't special
04:00:02 <dminuoso> iron_houzi: They are data constructors.
04:00:24 <dminuoso> iron_houzi: The weight of that difference is, you can pattern match on data constructors, but not on (any) values
04:00:32 <Boomerang> iron_houzi: You can think of True and False as constructors that take no parameters.
04:00:41 <Axman6> (apart from the few places where Bools are treated specially in the language, if statements and guards)
04:01:10 <dminuoso> Axman6: Even that is mostly sugar, since you could (which GHC does) write everything in terms of case and pattern matching =)
04:01:15 <Boomerang> both if statements and guards desugar to case statements in core, no?
04:01:52 <Axman6> @define data SadBool = NULL | True' | False' deriving (Show, Eq, Ord)
04:01:55 <lambdabot>  Defined.
04:01:58 <Axman6> :t True'
04:02:00 <lambdabot> SadBool
04:02:05 <Axman6> :t NULL
04:02:07 <lambdabot> SadBool
04:02:17 <dminuoso> Boomerang: More than that even. The standard demands the following identity holds: if e1 then e2 else e3 = case e1 of { True -> e2 ; False -> e3 }
04:06:06 <dminuoso> Axman6: I wonder, where is the definition of Bool then?
04:06:38 <Axman6> what do you mean?
04:06:50 <dminuoso> Oh! Nevermind.
04:07:07 <dminuoso> https://hackage.haskell.org/package/ghc-prim-0.5.1.1/docs/src/GHC.Types.html#Bool :)
04:09:13 <absence> is anyone familiar with the streaming library? i have a Stream (Of Word8) m r, but need to interpret parts of it as bits, i.e. Stream (Of Bool) m r. problem is that i don't know how many bytes' worth of bits i need up front, so i can't use splitAt
04:10:32 <ertes-w> hell
04:14:47 <ertes-w> heinrich5991: drop n, then fold
04:15:48 <ertes-w> > foldr (const . show) "none" (drop 5 [0..9])
04:15:51 <lambdabot>  "5"
04:15:54 <ertes-w> > foldr (const . show) "none" (drop 5 [0..2])
04:15:57 <lambdabot>  "none"
04:16:12 <ertes-w> or if you insist on going through Maybe…
04:16:23 <ertes-w> > foldr (const . Just) Nothing (drop 5 [0..5])
04:16:26 <lambdabot>  Just 5
04:17:49 <ertes-w> heinrich5991: alternatively use a suitable traversal
04:18:02 <ertes-w> > "hello world" ^. ix 3
04:18:05 <lambdabot>  error:
04:18:05 <lambdabot>      • No instance for (Monoid Char) arising from a use of ‘ix’
04:18:05 <lambdabot>      • In the second argument of ‘(^.)’, namely ‘ix 3’
04:18:07 <ertes-w> err
04:18:11 <ertes-w> > "hello world" ^? ix 3
04:18:14 <lambdabot>  Just 'l'
04:18:25 <dminuoso> :t fixIO
04:18:25 <ertes-w> > (ix 3 .~ 'X') "hello world"
04:18:28 <lambdabot> error: Variable not in scope: fixIO
04:18:29 <lambdabot>  "helXo world"
04:18:35 <dminuoso> :type System.IO.fixIO
04:19:14 <ertes-w> :t mfix
04:19:16 <lambdabot> MonadFix m => (a -> m a) -> m a
04:19:16 <ertes-w> dminuoso: ^
04:19:41 <dminuoso> ertes-w: Wew. What black magic.
04:20:04 <iron_houzi> In my book, I read the following: `data Nat = Zero | Succ Nat`. I get the recursiv aspect of the definition, but I don't understand `Succ` .. the book states that `Succ` represents (1+), but I don't see *how* this representation is defined..
04:20:27 <dminuoso> iron_houzi: It's a way of _encoding_
04:20:36 <dminuoso> iron_houzi: So you encode 0 with Zero, you encode 1 with (Succ Zero)
04:20:39 <Boarders> interpret :: Nat -> Int
04:20:44 <dminuoso> 2 with (Succ (Succ Zero))
04:20:44 <Boarders> interpret Zero = 0
04:21:07 <ertes-w> iron_houzi: "+ 1" is just a metaphor
04:21:09 <Boarders> interpret (Succ n) = (+1) (interpret n)
04:21:09 <dminuoso> iron_houzi: So the representation is a contract, not a definition.
04:21:11 <iron_houzi> dminuoso: Where is this encoding being defined though?
04:21:15 <dminuoso> iron_houzi: Nowhere.
04:21:17 <dminuoso> iron_houzi: its just a contract.
04:21:22 <iron_houzi> hmmm
04:21:40 <ertes-w> iron_houzi: every value of type Nat is either of the shape Zero, or of the shape (Succ x), where x is another Nat…  that way there is a Nat for every natural number
04:22:02 <ertes-w> iron_houzi: Zero represents 0, Succ Zero represents 1, Succ (Succ Zero) represents 2, etc.
04:22:02 <dminuoso> iron_houzi: Or actually it _is_ defined in the Peano axioms. ;-)
04:22:25 <ertes-w> iron_houzi: that's why you can interpret (Succ x) as "x + 1"
04:22:32 <iron_houzi> Thanks for the help though, it is clearer to me .. though no Eureka just yet.
04:22:35 <dminuoso> iron_houzi: Which is why you might call that representation "peano numbers"
04:23:21 <ertes-w> iron_houzi: do you see how (data Bloo = Red | Green) is just Bool, i.e. a type that can hold "truth values"?
04:23:25 <mniip> the curious fact here is that this inductively defined "Nat" set equals the set of natural numbers from naive set theory
04:23:28 <tomsen> iron_houzi: cool thing about using a structure like Succ instead of numbers is, that you can use it for every type.
04:23:50 <dminuoso> iron_houzi: Think about 3. You could think of 3 as `1 + 1 + 1 + 0`
04:24:47 <dminuoso> iron_houzi: Which if you bracket it, could look like (1 + (1 + (1 + 0))), so from that you can see there's a way to define a number recursively in terms of "increment by one" and "zero"
04:24:47 <ertes-w> iron_houzi: there is no intrinsic meaning to "Red" and "Green" here, and neither is there an intrinsic meaning to "False" and "True"…  you're literally just defining a way to build values of a certain type from basic building blocks…  you're defining what a value of type Nat has to look like, nothing else
04:25:27 <ertes-w> iron_houzi: the semantics that makes True be a representation of "truth" comes in the form of *functions* defined using Bool
04:26:51 <iron_houzi> I must say this the most abstract form of typing I have ever witnessed, I can see the power in it. Pretty mind blowing actually.
04:27:03 <ertes-w> iron_houzi: True && x = x; False && _ = False  -- this is why we consider True to represent truth – we use (&&) and it just happens to satisfy (True && True = True)
04:27:08 <dminuoso> iron_houzi: Its actually not typing, it just data constructors.
04:27:42 <ertes-w> iron_houzi: we could just as well define (blah False x = x; blah True _ = True), but in that case we would have to interpret False as truth
04:27:48 <ertes-w> iron_houzi: i hope that makes sense
04:27:59 <iron_houzi> Yeah, actually it does. Thanks!
04:28:05 <Axman6> data BitString = Nil | Hi BitString | Lo BitString - 0 = Lo Nil, 10 (or 0b1010) = Hi (Lo (Hi (Lo Nil))). There's nothing in this definition that makes the connection between a BitString and some actual bits somewhere, but we humans can give it those semantics
04:28:15 <Ariakenom> repeat :: Peano -> a -> []; repeat Zero _ = []; repeat (Succ n) a = a : repeat n a;
04:28:49 <Axman6> [a]*
04:29:21 <habeeb> ayo
04:29:30 <ertes-w> iron_houzi: it's the same with Nat…  the moment you define 'plus' (and use it in your code) you can see how (plus (Succ Zero) x = Succ x)…  now consider that (Succ Zero) represents 1, then you can read that as:  plus 1 x = Succ x
04:29:41 <Ariakenom> Yes, let's not return a (Type -> Type). Good point
04:29:52 <ertes-w> iron_houzi: and that's where the interpretation of Succ being "1 +" comes from
04:30:08 <habeeb> yeah
04:30:48 <ertes-w> iron_houzi: like False and True Succ has no intrinsic semantics…  it gets its meaning from the functions defined on Nat
04:32:31 <iron_houzi> Uhm .. this is *amazing* .. as someone who's studied philosophy and epistemology and ontology..
04:33:11 <ertes-w> iron_houzi: oh, i think you're going to love haskell =)
04:33:12 <dminuoso> iron_houzi: You might be interested in studying some lambda calculus perhaps.
04:33:13 <iron_houzi> the fact that a formal programming language has encapsulated this is pretty mind bogling to me
04:33:29 <habeeb> wtf?
04:33:57 <dminuoso> iron_houzi: The core of lambda calculus revolves around this principle. "How do I encode truth values". "How do I encode boolean operators". "How do I encode numbers"
04:34:01 <dminuoso> It's very enlightening.
04:34:17 <dminuoso> iron_houzi: And it does so in a manner that lets you prove properties.
04:34:23 <ertes-w> you can even do lambda calculus in haskell
04:34:25 <tabaqui1> !oleg
04:34:34 <ertes-w> @let type Bool' = forall r. r -> r -> r
04:34:36 <lambdabot>  Defined.
04:34:48 <ertes-w> @let false = const; true = const id
04:34:50 <lambdabot>  Defined.
04:35:16 <habeeb> wtf is going on
04:35:18 <Axman6> (aka, true = \t f -> t, false = \t f -> f
04:35:21 <Axman6> )
04:35:33 <ertes-w> Axman6: except the other way around =)
04:35:39 <Axman6> uh, yeah
04:35:46 <Axman6> true = not true
04:35:46 <habeeb> wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wt
04:35:47 <Axman6> >_>
04:35:57 <habeeb> wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wt
04:35:58 <Axman6> habeeb: do you have a question about Haskell?
04:35:59 <habeeb> wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wt
04:36:02 <Axman6> @where ops
04:36:02 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver shachaf shapr ski
04:36:04 <habeeb> yes
04:36:14 <habeeb> i have many question
04:36:14 <Axman6> too late
04:36:17 --- mode: ChanServ set +o dibblego
04:36:17 <habeeb> sorry
04:36:38 <habeeb> wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wt
04:36:39 <habeeb> wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wtf? wt
04:36:42 --- mode: dibblego set +b *!*@gateway/web/freenode/ip.5.150.112.164
04:36:43 * Clint sighs.
04:36:45 <tomsen> : )
04:36:49 <Axman6> thanks mate
04:37:29 --- mode: dibblego set +b *!*@*.5.150.112.164
04:37:51 --- kick: habeeb was kicked by dibblego (habeeb)
04:38:25 <ertes-w> @let and' x y f t = x f (y f t)
04:38:27 <lambdabot>  Defined.
04:38:56 <dminuoso> iron_houzi: So ultimately that's the same reason for encoding natural numbers this way. It gives you a framework from which you can suddenly prove properties.
04:39:03 <ertes-w> > (and' true true) False True
04:39:06 <lambdabot>  True
04:39:10 <ertes-w> > (and' true false) False True
04:39:13 <lambdabot>  False
04:39:19 <Axman6> magic!
04:39:50 <dminuoso> iron_houzi: But really do take a peek into lambda calculus, even if it's just some rudimentary stuff. :)
04:41:26 <tabaqui1> @quote oleg
04:41:27 <lambdabot> oleg says: I submit that a type-checker that accepts ill-typed terms, loops and causes segmentation faults is not correct.
04:42:05 <ertes-w> iron_houzi: BTW, haskell gets you really close to studying the very concept of truth, if you choose to go there: type theory is not just a convenient safety feature for programming, but an actual foundation for mathematics – an alternative to set theory
04:43:03 <iron_houzi> Unfortunately, I'm not able to follow the examples here. But I'm at least starting to scratch the surface of realising the power of haskell and more broadly lambda calculus
04:43:31 <ertes-w> iron_houzi: and the fun part is: you can use all of this for actual application development – again, if you choose to do so
04:45:20 <ertes-w> iron_houzi: using type algebra or church encoding to optimise programs, curry-howard to prove properties of your programs, parametricity to document your APIs…  or go as far as to have the compiler derive function implementations from your types
04:45:46 <mniip> yeah, might be hard to believe but costate comonad coalgebras are very often used in real world code
04:45:55 <mniip> because that's how you emulate field references in lambda calculus
04:47:54 <ertes-w> iron_houzi: and of course mathematical structures for abstraction…  if you haven't done that before, you'll see how far the DRY principle can be taken =)
04:48:18 <v0d1ch> @type Just 0
04:48:20 <lambdabot> Num a => Maybe a
04:48:27 <v0d1ch> just playin'
04:48:58 <v0d1ch> what does @ + where do ?
04:49:26 <dminuoso> v0d1ch: You can play with lambdabot in a private message/query
04:49:27 <ertes-w> v0d1ch: it makes GHC yell at you =)
04:51:23 <lyxia> v0d1ch: it looks up a database of useful phrases
04:52:33 <v0d1ch> ah ok
05:16:53 <jchia_1> TH question. I would like to write a ExpQ function that takes a Name and does different things depending on the type of the variable being named. I think I need to use reify. As a first step I try to reify the Name to inspect the type, but I'm getting an error: ‘foo’ is not in the type environment at a reify
05:16:54 <jchia_1> https://gist.github.com/jchia/2db6c70c7afe22a6aa2c1a91ddfdcc59
05:17:05 <jchia_1> What am I missing. Does it mean I can't reify a name passed in from outside?
05:19:53 <lyxia> jchia_1: try adding "return ()" between the two declarations
05:20:28 <lyxia> this "flushes" the declarations above it so they can be looked up below
05:20:48 <jchia_1> lyxia: Which two declarations? Which line?
05:20:56 <lyxia> line 10 of Lib4.hs
05:22:47 <jchia_1> You mean literally insert a line "return ()" at line 10? that can't compile
05:22:57 <lyxia> return [] actually
05:23:07 <lyxia> it's a naked expression that will be parsed as a TH splice
05:23:29 <lyxia> $(return []) if you prefer
05:26:39 <jchia_1> lyxia: OK, added "return []" worked. How does that work, though? What does return [] do? Isn't it broken grammar? Also, does this mean I have to do this trick everytime I want to splice something that tries to reify the name of a recently-declared variable like this?
05:27:43 <xandaros> It's a splice that does nothing... huh
05:28:13 <jchia_1> Splices usually are [||] or [t||]. This one has no vertical bars.
05:28:23 <jchia_1> How do I read this splice?
05:28:29 * hackage basen-bytestring 0.1.0.1 -   https://hackage.haskell.org/package/basen-bytestring-0.1.0.1 (filwisher)
05:28:44 <lyxia> [||] is a quote
05:28:52 <lyxia> $() is a splice
05:29:41 <lyxia> jchia_1: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#template-haskell explains stuff
05:29:48 <lyxia> "Note that since an expression splice is unable to refer to declarations in the same declaration group, we can introduce a top-level (empty) splice to break up the declaration group"
05:30:42 <lyxia> it's just a workaround for the way declarations get grouped
05:33:12 <jchia_1> lyxia: thanks
05:33:35 <lyxia> jchia_1: you can create declarations at the toplevel with splices of type Q [Dec], and "return []" is a splice that creates nothing.
05:51:24 <jchia_1> lyxia: What about this variant: https://gist.github.com/jchia/2db6c70c7afe22a6aa2c1a91ddfdcc59
05:51:40 <jchia_1> Now it involves a splice using the name of a local variable
05:51:57 <jchia_1> So, I suppose we are no longer talking about top-level splices
06:04:43 <jchia_1> Maybe local (non-top-level) variables cannot be Named?
06:36:30 <dminuoso> I have the need to reconstruct various records from a generic type like [(String, [String])]. Are there any tricks to avoid the boilerplate?
06:37:25 <dminuoso> i.e. I may have some [("name", ["Newton"]), ("age", ["30"])] that needs to fit into some `data User = User { name :: String, age :: Int }`
06:48:29 * hackage quickcheck-classes 0.4.6 - QuickCheck common typeclasses  https://hackage.haskell.org/package/quickcheck-classes-0.4.6 (andrewthad)
06:57:39 <lyxia> jchia_1: they can be named but not reified
07:02:05 <lseactuary> hi lyxia
07:02:23 <jchia_1> lyxia: I'm trying to write a function that produces ExpQ that operates on different types of values (e.g. tuples of different sizes). I suppose there isn't a function to query the type of an Exp, either, so there's no way to to make my ExpQ-returning function to cleverly adapt to the type of the 'input'.
07:03:34 <jchia_1> And that's why, for example, mapTuple from tuple-th (http://hackage.haskell.org/package/tuple-th-0.2.5/docs/TupleTH.html) isn't less verbose and requires the user to specify the size of the input tuple.
07:05:16 <tabaqui1> is there some function in base with signature (Monad m) => m a -> (a -> (b, c)) -> (m b, m c)
07:05:17 <tabaqui1> ?
07:06:35 <tabaqui1> I dunno, if this type has at least point
07:06:46 <tabaqui1> *at least one point
07:07:37 <lavalike> dminuoso: parsec?
07:08:18 <dminuoso> lavalike: It's potentially unsorted.. I _think_ generics is what Im after, but this looks too complicated for now.
07:08:39 <dminuoso> lavalike: Basically the same idea that drives FromJSON.
07:10:08 <dminuoso> :T liftA2 (,)
07:10:11 <dminuoso> :t liftA2 (,)
07:10:13 <lambdabot> Applicative f => f a -> f b -> f (a, b)
07:11:26 <dminuoso> :t unzip
07:11:28 <lambdabot> [(a, b)] -> ([a], [b])
07:12:34 <dminuoso> :t Data.List.NonEmpty.unzip
07:12:36 <lambdabot> Functor f => f (a, b) -> (f a, f b)
07:12:40 <dminuoso> tabaqui1: ^- there's that
07:12:51 <lavalike> dminuoso: might even be easier to regexp it out to name age\nname age\n ... :D
07:13:30 <dminuoso> tabaqui1: But you could write this combinator yourself trivially
07:13:51 <dminuoso> unzipT t = (fst <$> t, snd <$> t)
07:14:10 <tabaqui1> dminuoso: right, thanks :)
07:14:11 <lavalike> dminuoso: oh sorry I completely misunderstood, I thought it was a non-haskell expression
07:15:31 <dminuoso> Well for now Im gonna write the necessary boilerplate. Seems easier than to learn generics for now.
07:15:33 <lavalike> you're looking for a way to use some typeclass that provides an automated way to write f (n,[a]) = User n a and map it over?
07:16:23 <lavalike> or some system I should say
07:16:59 <dminuoso> lavalike: Let me explain
07:17:20 <lavalike> no, still wrong, you have the various attributes splatted onto a ([attr,[val])]
07:17:26 <dminuoso> Right!
07:17:30 <dminuoso> Well.
07:17:32 <lavalike> modulo the typo
07:17:51 <dminuoso> [(Attr, [Val])]
07:18:08 <dminuoso> And the array encodes the possibility that some attributes may have a list of values, or that they may be non-existant.
07:18:21 <lavalike> and there's a mechanism to go from [(Attr, [Val])] to Type Val Val ?
07:18:45 <dminuoso> Well it's [(String, [String])], and no
07:18:49 <dminuoso> That mechanism is what Im building.
07:19:28 <lavalike> right, I mean, you say there's a framework that helps building such a thing, which is generics?
07:22:08 <dminuoso> Fairly sure that GHC.Generics or Data.Generics are the key, since all FromJSON - which kind of needs to use the same machinery - use it too.
07:25:29 * hackage boomerang 1.4.5.5 - Library for invertible parsing and printing  https://hackage.haskell.org/package/boomerang-1.4.5.5 (JeremyShaw)
07:25:42 <lyxia> jchia_1: Would you not rather try using generics and dependent types instead of TH
07:26:33 <lyxia> dminuoso: indeed you can do that kind of thing with generics
07:26:56 <jchia_1> lyxia: I tried type-level programming. The build time was devastating. 10 minutes with stack build --fast and 20-30 minutes with stack build, Almost 30GB resident memory.
07:27:23 <jchia_1> lyxia: Imagine what that does to productivity
07:28:11 <jchia_1> I think when your types get complicated the compilation gets exponentially expensive
07:28:56 <jchia_1> Because of the crazy build issue, I want to switch to TH.
07:29:10 <lyxia> that's too bad
07:29:31 <lyxia> And there was no way to make the types simpler>
07:29:32 <lyxia> ?
07:33:11 <jchia_1> lyxia: I'm no expert but I doubt it. I'm trying to have named unordered tuples and manipulate them, mainly 1) reading fields 2) projecting a subset of fields into another named tuple (of another type) and 3) cartesian product of the fields (originally all the fields are Vector of something, I will get a list of named tuples with the same fields of just 'something' (no Vector). So, type families that let me express the types of these nam
07:33:12 <jchia_1> ed unordered tuples without explicitly declaring record types. A bit like what you would do with SQL tables.
07:33:51 <reactormonk> I have some where I inserted some print statements, but they don't get executed, only when I press Ctrl-C to interrupt the application. I assume that's fixed by line buffering? Also next part, the application is hanging somewhere. I'd use profiling to get that information, is there another way?
07:33:55 <jchia_1> Do you think GHC's type-level machinery can be used to do this sort of thing effectively?
07:34:03 <reactormonk> Aka how to debug hanging haskell applications.
07:36:40 <lseactuary> can someone help me complete the step3 code here: https://codeshare.io/GAmLZk i have an idea of what it should do, having trouble getting the syntax.
07:36:42 <dminuoso> reactormonk: You possibly have BlockBuffering enabled. Try flushing after print
07:36:54 <reactormonk> dminuoso, or setting to line buffering.
07:36:58 <jchia_1> lyxia: So I can say 'Subpoint ["fieldName1", "fieldName2", "fieldName5"]' to express a type that has those three fields, and the field name determines the field type in my application.
07:37:41 <dminuoso> reactormonk: If that works for you, sure. Block buffering can perform a bit better if there's a high frequency of short newlines.
07:45:17 <merijn> cocreature: Rats, looks like -Werror mind end up scuppering everything
07:45:41 <merijn> Or, well, not everything, but at least the warning related bits
07:47:20 <lavalike> dminuoso: I wonder if there's a less hands-on way to achieve it http://lpaste.net/364139 (and this supposes a particular order but it's easily changed)
07:47:41 <lavalike> I mean if I type it out by hand it's not really scrapping the boilerplate :D
07:48:58 <dminuoso> lavalike: Well I have many things that will come out of this interface.. in reality I have like 10 attributes on the record `User` - some need to fit into Maybe types, others actually need to work with arrays..
07:49:22 <dminuoso> lavalike: But thank you, I think I can figure this out. There's just not a lot of documentation on the topic, so I think Ill have to crunch through it.
07:49:34 <lavalike> dminuoso: I guess one writes such conversions in some typeclass, and then to . from does the trick
07:49:47 <dminuoso> lavalike: The point is to not write it out at all.
07:50:05 <lavalike> that'd be pretty awesome
07:50:37 <dminuoso> lavalike: With generics I could just make some typeclass `LDAPMappable`, and then go: `instance LDAPMappable User` and gain a generically defined toLdap and fromLdap for free.
07:50:45 <dminuoso> I just dont know how (yet) :-)
07:50:47 <lavalike> but how can it figure out that the names of the record fields are the first element of the tuples (and the values are inside the list inside the second element) without *any* nudge
07:51:45 <lavalike> or that sometimes you want to carry the string, like with   name  , and some other times you might want the number like   read age
07:51:55 <lyxia> jchia_1: I would expect that type-level programming is not a solution if your records are large enough for the asymptotic gains of sorting lists/maintaining sets at the type-level to outweigh their constant-factor overhead
07:52:13 <dminuoso> lavalike: The only nudge is `deriving Generic` for GHC.Generics
07:52:29 * hackage happstack-authenticate 2.3.4.11 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.3.4.11 (JeremyShaw)
07:52:41 <lyxia> jchia_1: but I can't tell for sure without seeing the actual code, so I'm not going to press the issue further :/
07:53:03 <lavalike> dminuoso: I don't believe you :D haha (but I'd love to see how that can be the case)
07:53:09 <dminuoso> lavalike: Ever used aeson?
07:53:13 <lavalike> nope
07:54:26 <dminuoso> lavalike: Well it does just that. You'd do `instance FromJSON User` (assuming your User had deriving Generic), and then use a generic way of serializing User into a JSON String.
07:54:58 <dminuoso> lavalike: Ive stumbled over a miniature library that could be studiable https://hackage.haskell.org/package/json-0.9.2/docs/src/Text-JSON-Generic.html#fromJSON
07:56:10 <lseactuary> anyone who can take a quick look please?
07:56:58 <lavalike> dminuoso: but Aeson is not *just* import GHC.Generics, it must implement the algorithm that uses json object keys as haskell record names and json object values as haskell record values. In your example [(String,[String])] might as well be [(Val,[AttrName])] is what I'm saying, how can GHC.Generics on its own know it's [(AttrName,[Val])]
07:58:14 <madsj> I'm trying to work with fgl; it's easy to get the flow graph of a cut, but can someone point me in direction how to split it between the cut set? I'm reasonably new with Haskell, and find the type signatures bit tricky to read.
07:58:34 <dminuoso> lavalike: Ill work through it on my own and let you know if you're still around :)
07:58:51 <lavalike> dminuoso: that'd be lovely! appreciate it
08:01:21 <shapr> I'd love to see a good fgl tutorial, I never could figure it out.
08:04:16 <plugin> I have a single source file in subdirectory of my library, is there a way to tell stack to compile it using ghc-options='-O2 -threaded'?
08:05:21 <madsj> shapr: Yes. I peak at Haskell, and I think a general complaint is the difficulty of the type signatures as the only documentation/tutorial. There's a bunch of functions, such as gsel, efilter etc., but no examples.
08:07:18 <shapr> madsj: do you have some example code? I wanted to get SCCs from a graph for a recent project
08:08:04 <sm> plugin: you're compiling that file along with others, I think you'll have to set those options for all of them
08:08:06 <sm> if
08:08:38 <Adluc> anyone building something with happstack that you can show?
08:09:02 <lyxia> dminuoso: https://dpaste.de/iMCQ is how you'd do it with Generics
08:09:05 <plugin> sm: it's just a script that imports the library and the library itself can't have -O2
08:09:10 <madsj> shapr: No.
08:09:26 <shapr> madsj: ah well, worth asking
08:13:10 <lseactuary> anyone who can help me real quick?
08:13:38 <madsj> shapr: https://hackage.haskell.org/package/GraphSCC-1.0.4/docs/Data-Graph-SCC.html <- I suppose you already had a look at this.
08:15:12 <shapr> madsj: yeh, I should probably suck it up and just use that.
08:15:29 <shapr> I wanted to use all the cool tools in fgl, since my problem is entirely graph algorithms
08:16:59 * hackage protolude 0.2.2 - A small prelude.  https://hackage.haskell.org/package/protolude-0.2.2 (sdiehl)
08:24:42 <lseactuary> i am trying to apply a function from a list to an element, save that element, apply the second to the new element
08:24:48 <lseactuary> how may i write this in haskell
08:25:08 <exarkun> lseactuary: what have you tried
08:25:46 <lseactuary> exarkun - https://codeshare.io/GAmLZk
08:25:53 <lseactuary> see the step3 part
08:26:18 <lseactuary> i nthe left case, x is a TurtleProg1 so just a list of commands
08:26:30 <lseactuary> i need to apply it to ts2
08:26:34 <infandum> dmwit: I don't understand -- there is no IO at all in argument though!
08:26:35 <lseactuary> store the result ts2'
08:26:40 <lseactuary> apply the second command to ts2'
08:26:40 <reactormonk> Is there a way to sample ghc applications? Aka ask it which line it is at, for flamegraphs. I have a --profile build
08:26:41 <lseactuary> and so on
08:27:46 <lyxia> reactormonk: compile with -fprof-auto -rtsopts, run with +RTS -xc, kill your program and look at the trace
08:29:47 <lyxia> reactormonk: about -xc: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-for-hackers-debuggers-and-over-interested-souls
08:30:29 * hackage language-puppet 1.3.17 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.3.17 (SimonMarechal)
08:31:03 <Akii> having a small composition problem: I've `fn1 :: m (Maybe a)` and `fn2 :: a -> m (Maybe b)` and I'd like to bind this.. sounds like MaybeT but I can't get it to work
08:31:36 <lyxia> MaybeT fn1 >>= MaybeT . fn2
08:31:53 <Akii> right, I forgot about that
08:31:56 <Akii> thanks!
08:33:08 <ZZzzz> need advice. i want to make a function (lets call her inter) that takes en element and a list of this kind of elements and return a list of list for the input list with the element in all the posibble places, for example if i do that: inter 0 [1,2], i'll get this back: [[0,1,2],[1,0,2],[1,2,0]]. i don't know how to do it so any hint?
08:34:59 <lseactuary> exarkun any ideas?
08:35:17 <exarkun> sorry my network died before I got your reply
08:35:56 <lemmih> ZZzzz: Have you tried breaking the problem down into smaller pieces?
08:36:34 <lseactuary> exarkun no worries. https://codeshare.io/GAmLZk
08:36:38 <ZZzzz> lemmih: no. i dont understand how to get into this problem.
08:36:39 <lseactuary> i am stuck on the step3 part
08:37:16 <lseactuary> Left x basically is TurtleProg1 which is just a list of movement commands. i want to apply the first from the list to ts2. store it as ts2'. then apply the second command to ts2' and so on.
08:37:48 <lemmih> ZZzzz: Can you see if your task contains any smaller problems?
08:38:13 <ZZzzz> lemmih: yes. if there is no list at all, and if there is just one element
08:38:28 <ZZzzz> no elements in the list at all (this is what i meant)
08:38:39 <lemmih> ZZzzz: Would your task be easier if you had a function that inserted an element into a list at the nth position?
08:39:38 <ZZzzz> maybe. i need to see if i can do that lemmih
08:40:00 <ZZzzz> please wait :-)
08:40:20 <lseactuary> exarkun does the link work for you?
08:40:43 <lemmih> ZZzzz: Oops, didn't mean to send that twice.
08:41:36 <ZZzzz> lemmih: i don't see anything you send twice :-)
08:41:54 <lemmih> (Bah, I thought I sent the same message twice. I'm going blind in my old age.)
08:42:10 <ZZzzz> :-)
08:43:15 <exarkun> lseactuary: yea... on the phone now :/  but lots of other folks here know more than I do :)
08:43:23 <lseactuary> no problems :)
08:44:09 <lseactuary> exarkun - really qq - i have a function and it compiles but i wanted to test it works. can you provide an example i can try. im having trouble finding an example.
08:44:14 <lseactuary> maybeLookup :: Eq k => (k->v) -> [(k,v)] -> k -> v
08:44:22 <lseactuary> maybeLookup def dict k = case lookup k dict of Just k -> k
08:44:22 <lseactuary> Nothing -> def k
08:44:35 <lseactuary> the idea is that maybeLookup def dict k looks up a value k in a dictionary dict of key–value pairs and returns a result of type v—either the first matching value in the dictionary, or the default function def applied to k if there is no matching value
08:44:43 <lseactuary> i want to check my function is doing this
08:44:52 <lseactuary> as i have a feeling im missing something
08:45:44 <absence> is there a more concise way to express "fmap join . traverse f"?
08:47:59 * hackage reform 0.2.7.2 - reform is a type-safe HTML form generation and validation library  https://hackage.haskell.org/package/reform-0.2.7.2 (JeremyShaw)
08:49:48 <lseactuary> anyone knows?
08:49:54 <ZZzzz> lemmih: insert e nth list = take (nth-1) list ++ [e] ++ drop (nth-1) list
08:50:04 <infandum> lyxia, dmwit: I probably wasn't clear when I was explaining the problem: graphicalUI :: Text -> Updatable (Diagram Cairo) -> IO (), and Updatable is applicative. I have a function f :: Config -> IO (Diagram Cairo). According to the documentation, I create the Config inside the Updatable applicative instance by getting various paramters from gui components, then I return a Diagram Cairo. But unfortunately I need IO to make the Diagram
08:50:04 <infandum> based on how I make it, so I end up with a type error where graphicalUI expects Updatable (Diagram Cairo) but I have IO (Diagram Cairo).
08:50:22 <lemmih> ZZzzz: Great. Can you use that function to solve your original problem?
08:50:57 <ZZzzz> need to think lemmih :-D
09:01:59 * hackage clckwrks 0.24.0.7 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.24.0.7 (JeremyShaw)
09:12:02 <Ariakenom> ZZzzz, I can see from the "-1"s that you're doing something 1-indexed. How profane!
09:14:03 <ab9rf> oof
09:16:38 <lseactuary> anyone can help me out? :)
09:16:51 <ab9rf> out of what?
09:17:26 <lemmih> lseactuary: You would learn much more if you tried to tackle easier problems.
09:18:08 <lseactuary> i just wanted to finish this one part and then i was planning to go back and try the chapter again
09:18:20 <lseactuary> if you can help me with it it is much appreciated. only 2 functions left.
09:19:20 <lemmih> lseactuary: Why do you want to finish this code?
09:19:33 <lseactuary> so that i can compile the image and see if it works
09:19:44 <lemmih> lseactuary: Why do you care if it works?
09:19:54 <lemmih> If your goal is to learn Haskell, there are much better ways.
09:19:57 <lseactuary> because i got this far :P
09:20:11 <lseactuary> also because it plugs into another piece of code i am working on
09:20:38 <lemmih> Why do you care about that other code?
09:22:23 <lseactuary> because it took me ages to build so wanted to compile it
09:23:27 <lemmih> Why not put it on hold, learn a bit of Haskell, and then come back to it in a few weeks?
09:23:32 <lseactuary> with step3 i am almost there
09:23:42 <lseactuary> like i know what to do just stuck on syntax
09:23:58 <lemmih> lseactuary: You're not just stuck on syntax.
09:24:25 <lseactuary> hmm
09:28:22 <lseactuary> how so?
09:30:54 <lemmih> You struggle with some Haskell basics that you would be able to learn really quickly if you tried. But it requires you to put this project on hold and follow a Haskell tutorial.
09:31:29 <ab9rf> yeah, you're trying to run before you;ve leraned how to stand
09:31:40 <ab9rf> you can do tht but you'll have a lot of bruised knees that way
09:32:28 <Clint> sometimes that's the right way to learn
09:33:29 * hackage pandoc-crossref 0.3.1.0 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.1.0 (lierdakil)
09:33:55 <dyl> Clint tutorials are like worked proofs in mathematics.
09:34:05 <dyl> Start with worked examples, then pick bite-sized problems, work your way up...
09:34:10 <dyl> I'm so rusty with Haskell haha.
09:34:14 <dyl> I may have to run through something myself.
09:34:26 <fishythefish> how haskelly are you with rust though?
09:34:33 <dyl> I get jiggy wit it.
09:34:46 <dyl> I actually don't use rust much.
09:34:56 <dyl> Haskell is way more plish.
09:35:08 <ab9rf> hm, now i'm envisioning some sort of crossover between rust and haskell
09:35:14 <ab9rf> don't see how that works
09:35:33 <fishythefish> ocaml?
09:35:45 <Clint> raskell
09:36:27 <ab9rf> "rusty haskell" sounds like a beat-up old baseball player
09:36:55 <byorgey> infandum: is Updatable  Traversable?
09:37:23 <byorgey> infandum: and do I understand correctly that you have an   Updatable Config?
09:39:27 <infandum> byorgey: According to the documentation, it says to use ApplicativeDo. I get each variable, like x <- TS.radioButton "Button" 1 [2,3,4], and the like, then return $ getDia x, where getDia :: Int -> IO (Diagram Cairo), for instance.
09:39:50 <infandum> So the diagram is drawn based on the Updatable values
09:40:07 <danilo2_> Hi guys! Are there any technics to benchmark programs on a "virtual CPU". I know the results would be different between such CPU and real CPU (depending of models, cache, etc), but Im just looking for a way to make a lot of benchmarks and automatic regression checking. If I could do it on some "virtual CPU" to get the same results over different machines, for example counting virual cycles, it would be awesome
09:40:39 <infandum> byorgey: It does not have Traversable or Monad instances, and I can't define them
09:40:49 <infandum> I don't think it's all exposed
09:42:36 <lemmih> danilo2_: You could use a real CPU and use 'perf'.
09:54:53 <orbisvicis> why is Codecs.Binary.UTF8.String.decodeString marked as unsafe ?
09:55:21 <danilo2_> lemmih: hmm, what is perf ?
09:55:51 <lemmih> danilo2_: It's a tool that can count cycles and other interesting things.
09:56:36 <lemmih> orbisvicis: I think it fails if the String contains unicode.
09:56:43 <lemmih> (Fails badly, that is)
09:56:55 <glguy> orbisvicis: It's easy to try and utf-8 decode something that isn't utf-8 decode, or double decode something just because of the input and output types matching
09:57:06 <danilo2_> lemmih: ok, I'll take a look at it, but (not strangely) writing "perf" in google doesnt give me anything sensible. I was trying with other words too but without a success. Is there any description of it ?
09:57:19 <dyl> Question: I have a stack based project depending on llvm-hs, which requires llvm-config to be in PATH.
09:57:25 <lemmih> danilo2_: Search for 'linux perf'.
09:57:32 <dyl> However, on macOS with brew, this is a keg-only formula (not linked, for various reasons).
09:57:39 <danilo2_> oh ok! lemmih thanks!
09:57:48 <dyl> Is there any way to extend PATH at the *stack project level*?
09:57:58 <dyl> e.g. like extra-include-dirs or extra-lib-dirs.
09:58:12 <dyl> I'd also like to use my own build of llvm.
09:58:17 <danilo2_> by the way, are there any haskell libraries that can automatically use perf under the hood that you know about ?
09:59:05 <orbisvicis> I see, thanks
10:01:38 <byorgey> infandum: what library is Updatable from?
10:02:17 <danilo2_> oh it seems there is something very interesting indeed here
10:02:17 <danilo2_> https://hackage.haskell.org/package/perf-0.3.1.1/docs/Perf-Cycle.html
10:03:03 <dyl> Ohey, extra-path
10:03:10 <dyl> I should have found that haha.
10:04:30 * hackage type-tree 0.1.0.1 - Tree representations of datatypes  https://hackage.haskell.org/package/type-tree-0.1.0.1 (JudeTaylor)
10:08:59 <sm> plugin: if it's just a script, can't you set those command line options in a shebang line (or stack script header)
10:10:39 <plugin> sm: I tried to do that but it requires explicitly listing every used package in the header and I couldn't get the plan to build (maybe had something to do with trying to add the project root package as a depenancy)
10:12:55 <sm> if you use stack's script support, you only need to specify a resolver plus packages not in the resolver
10:14:36 <sm> ***** periodic txn's end date should be exclusive - a "from A to B" budget should not be included in a "-b B" report
10:14:49 <sm> oops, sorry
10:15:19 <mnoonan> seems like good advice
10:15:29 * hackage escoger 0.1.0.0 - Terminal fuzzy selector  https://hackage.haskell.org/package/escoger-0.1.0.0 (tstat)
10:15:52 * EvanR steals fractions of a penny from sm
10:16:27 * sm increases precision on EvanR's transactions
10:16:46 <EvanR> so i get more ?
10:19:10 <sm> sure, we can afford it
10:20:05 * sm sets a very very small budget for EvanR theft
10:24:44 <dyl> EvanR so like the plot of Superman II?
10:40:46 <ZZzzz> lemmih: i'm still thinking :-D
10:43:01 <Rodenbach> https://hackage.haskell.org/package/freer-effects   => readme includes this type sig:   runConsole :: Eff '[Console] w -> IO w
10:43:10 <Rodenbach> What is the single quote in front of [Console]?
10:44:22 <cocreature> Rodenbach: it’s a data constructor promoted to the type-level using DataKinds, see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=datakind#distinguishing-between-types-and-constructors
10:44:47 <cocreature> well I guess it’s not strictly a data constructor but rather the syntactic sugar for list literals but the same thing applies
10:45:15 <Rodenbach> Okay that’s then a bit too advanced for me (yet).
10:55:39 <dyl> Hm.
10:55:46 <dyl> I'm a bit confused by stack and some of the newer stuff.
10:55:58 <dyl> I started with a cabal project (one exec, one lib)
10:56:10 <dyl> But now stack ghci only loads the execs main module :(
10:56:29 * hackage clckwrks-plugin-page 0.4.3.12 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.3.12 (JeremyShaw)
10:57:28 <Welkin> dyl: just use cabal instead of stack
10:57:35 <dyl> That's what I was going to go with haha.
10:57:57 <Welkin> https://www.haskell.org/cabal/users-guide/index.html
10:58:12 <Welkin> it has everything you might want to know
10:58:34 <dyl> Cabal I know how to use.
10:58:48 <dyl> I was more interested in using stack for isolation because I still have PTSD from dependency hell and nuking .cabal.
10:58:53 <Welkin> I'm always learning something new about cabal
10:59:06 <Welkin> yeah, you don't need to worry about that with cabal new*
10:59:08 <dyl> you mean... being initiated into the higher levels of cabal?
10:59:10 <Welkin> or just use nix with cabal
10:59:34 <Welkin> sandboxes with cabal freeze wasn't that bad though
11:00:00 <Welkin> https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
11:00:07 <dyl> I was no longer actively Haskelling right about when sandboxes happened.
11:00:14 <Welkin> cabal new-configure && cabal new-build
11:00:22 <Welkin> then run the executable from your build directory
11:00:51 <Welkin> .dist-newstyle/build/...
11:01:24 <dyl> For now I don't need to run the executable.
11:01:29 <dyl> I just want to ghci with the library.
11:01:46 <Welkin> cabal new-repl
11:02:03 <Welkin> and there is also new-freeze
11:03:57 <dyl> I'm just working on lexing/parsing currently
11:04:04 <dyl> So, repl is ideal :p.
11:04:16 <dyl> Welkin any suggestions on what to use for reformatting/type-lookup/etc?
11:04:21 <dyl> I kind of miss the scala language server :(
11:04:43 <dyl> I hope GHC gets something similar. I'm not sure external tools can really fill that niche as well as something baked into the compiler.
11:04:50 * dyl [compilers are databases intensifies]
11:05:21 <dyl> Welkin where should I toss the extra-paths?
11:05:27 <dyl> cabal.project.local?
11:08:37 <dyl> Can't find any config option..
11:08:43 <dyl> Hoping to avoid having to include it in the build line.
11:08:46 <dyl> Or in my wrapper script.
11:10:59 * hackage alex 3.2.4 - Alex is a tool for generating lexical analysers in Haskell  https://hackage.haskell.org/package/alex-3.2.4 (SimonMarlow)
11:11:37 <dyl> abal new-build --extra-prog-path=/usr/local/opt/llvm/bin does the trick.
11:12:35 <dyl> Seems like dumping `extra-prog-path: /usr/local/opt/llvm/bin` into cabal.project.local works!
11:13:38 <Welkin> nice
11:17:30 <absence> was there an applicative version of replicateM before AMP?
11:17:39 <absence> :t replicateM
11:17:41 <lambdabot> Applicative m => Int -> m a -> m [a]
11:21:46 <jollygood2> wat
11:21:52 <EvanR> does that make sense
11:21:56 <jollygood2> changed the signature but kept the name?
11:22:59 <absence> jollygood2: for compatibility i guess. but i wonder what people used before AMP, as i can't find a replicateA
11:23:43 <orbisvicis> Aren't these equivalent, why doesnt the 1st work: (let f a = do let { a = (a + 1) } ; print a)   (let f a = (return (a+1)) >>= (\a -> print a)
11:23:45 <Welkin> it's easy to implement Applicative if you have Monad
11:23:49 <Welkin> pure = return
11:23:53 <Welkin> <*> = ap
11:24:31 <Welkin> orbisvicis: neither of those should work
11:24:33 <Welkin> the syntax is invalid
11:24:39 <Welkin> where is your `in`?
11:24:50 <Welkin> let ... in ...
11:25:23 <orbisvicis> Welkin: I am testing in ghci
11:26:02 <cocreature> ghci is kind of weird
11:27:16 <EvanR> ah yeah
11:27:22 <absence> :r
11:27:28 <absence> oops
11:27:51 <parsnip> :3
11:28:55 <EvanR> foldr (liftA2 (:)) (pure []) (replicate n action)
11:29:29 <EvanR> @pl \n action -> foldr (liftA2 (:)) (pure []) (replicate n action)
11:29:29 <lambdabot> (foldr (liftA2 (:)) (pure []) .) . replicate
11:29:36 <EvanR> :thumbsup:
11:29:55 <Welkin> not :thumbsup-skin-color-2:?
11:31:23 <orbisvicis> anyway the 1st just version just hangs, if I reuse the name 'a'
11:32:12 <Welkin> > let a = a + 1
11:32:15 <lambdabot>  <no location info>: error: not an expression: ‘let a = a + 1’
11:32:26 <Welkin> > let a = a + 1 in a
11:32:29 <lambdabot>  *Exception: <<loop>>
11:32:32 <fishythefish> orbisvicis: of course it does, what would a evaluate to?
11:32:34 <Welkin> that is why
11:32:41 <fishythefish> it's got nothing to do with monads
11:32:58 <EvanR> a = infinity
11:33:15 * EvanR suddenly gets an F in math
11:33:47 <orbisvicis> I assumed the let inside the monad would unsugar as per the 2nd version, which wouldn't have that problem
11:33:49 <Welkin> > 0/0
11:33:53 <lambdabot>  NaN
11:33:57 <fishythefish> orbisvicis: you might be reading "=" as an assignment; you should read it more like a rewrite rule
11:33:58 <Welkin> > 1/0
11:34:01 <lambdabot>  Infinity
11:34:08 <Welkin> > 1/0 - 1/0
11:34:12 <lambdabot>  NaN
11:34:35 <Welkin> there are no assignments in haskell
11:35:21 <EvanR> (if data N = Z | S N, and (+1) = S, and infinity = S infinity, then let a = a + 1 in a ... is literally infinity
11:35:23 <Welkin> you can even think of the left-hand side of the `=` as being a pattern match on a variable
11:35:31 <Welkin> which then temporarily binds it to that name
11:36:24 <EvanR> i have heard the = in haskell referred to as "executable equations" hehe
11:38:17 <orbisvicis> I'm reading 'let a = a+1' as 'return (a+1) >>= \a -> ...'. Clearly wrong, so how does 'let' inside 'do' unsugar ?
11:38:47 <Welkin> to let ... in ...
11:39:10 <EvanR> let a = a + 1 in ...
11:39:16 <orbisvicis> oh
11:39:19 <fishythefish> f a = do { let a = a + 1; print a } desugars to f a = let a = a + 1 in print a (note the shadowing)
11:39:55 <Welkin> you are thinking of `a <- ma` which becomes `ma >>= \a ->`
11:40:12 * dyl ma >>= ma (Just "killed a man")
11:40:14 <Welkin> do-notation is not always the right solution
11:40:23 <Welkin> sometimes you should stick to plain bind
11:40:23 <EvanR> lol
11:41:32 <EvanR> let a = a + 1 in ... isnt automatically fatal in haskell for several reasons
11:41:36 <abcd> I trying to install 'ghc-mod' getting this error http://lpaste.net/364150
11:41:46 <EvanR> but its probably not what you were trying to do
11:42:25 <EvanR> after enough brainwashing you will see that equation as talking about infinity, not incrementing something once
11:43:26 <orbisvicis> wait, if that's the case, what does (let f a = do b <- getLine; let { a = (a ++ b) } ; print a) desugar to ?
11:43:44 <fishythefish> let f a = getLine >>= \b -> let a = a ++ b in print a
11:44:16 <EvanR> where are the parentheses :(
11:44:23 <fishythefish> do i look like a lisper to you
11:44:27 <EvanR> lol
11:44:32 <EvanR> i honestly cant tell
11:44:40 <fishythefish> i'm not fithythefith
11:44:54 <Welkin> what about a schemer?
11:45:16 <EvanR> @undo let f a = do b <- getLine; let { a = (a ++ b) } ; print a
11:45:17 <lambdabot> <unknown>.hs:1:58:Parse error: EOF
11:45:19 <abcd> I trying to install 'ghc-mod' getting this error http://lpaste.net/364150, can anyone help?
11:45:35 <fishythefish> EvanR: anyway, I don't think I need parens there
11:45:48 <EvanR> im sure you dont
11:46:03 <EvanR> im having a hard time seeing the nesting in the desugared version
11:46:27 <fishythefish> let f a = getLine >>= (\b -> (let a = a ++ b in print a)) -- is this better?
11:46:45 <EvanR> no, now its missing an in
11:46:56 <EvanR> let f a = (getLine >>= \b -> let a = a ++ b) in print a, now a doesnt refer to anything
11:47:01 <EvanR> and missing an in
11:47:12 <fishythefish> no the first let is from orbisvicis's ghci session
11:47:23 <EvanR> oh
11:47:32 <EvanR> @undo do b <- getLine; let { a = (a ++ b) } ; print a
11:47:33 <lambdabot> getLine >>= \ b -> let { a = (a ++ b)} in print a
11:47:41 <EvanR> ghci strikes again
11:47:47 <orbisvicis> ftr I've got the point :), thanks
11:48:26 <fishythefish> anyway after more brainwashing, you'll also become opposed to describing "a = a + 1" as infinity and you'll start talking about fixed points instead
11:48:45 <orbisvicis> yeah I read an intro to fixed points... I'll come back to that
11:50:53 <infandum> byorgey: https://hackage.haskell.org/package/typed-spreadsheet-1.1.2/docs/Typed-Spreadsheet.html
11:51:38 <EvanR> this is awesome
11:54:16 <dyl> The heck.
11:54:23 <abcd> I trying to install 'ghc-mod' getting this error http://lpaste.net/364150, can anyone help?
11:54:28 <dyl> How am I supposed to specify that an executable in my .cabal depends on the library?
11:54:28 <dyl> :/
11:54:32 <dyl> It was working I swore...
11:55:00 <dyl> cabal: Failed to build ayypl-0.1.0.0 (which is required by exe:ayypl from ayypl-0.1.0.0).
11:55:02 <dyl> Hmmm.
11:55:46 <orbisvicis> so eventuall both fix (2+) and a=a+1 (on eval.) experience stack overflow? Before reading the fix intro, I saw "x = 2 + x" as an equation with no solution, but the article makes it clear that fix (2+) expands to infinity ?
11:56:20 <dyl> Ah, I got it now.
11:56:25 <Welkin> dyl: add it to your build-depends
11:56:29 <dyl> It was.
11:56:32 <dyl> It was something else.
11:56:36 <Welkin> what was it?
11:56:50 <orbisvicis> point is, why not consider a = a + 1 as infinity ?
11:57:19 <EvanR> in general its, bottom
11:57:27 <EvanR> its only infinity if you set it up right
11:57:45 <EvanR> > let a = a + 1 in a
11:57:48 <lambdabot>  *Exception: <<loop>>
11:57:54 <EvanR> ah we just did that
11:58:10 <EvanR> bottom works in more places than infinity
11:59:11 <nut> How to compare a Int record field value to a number? Using Lens
12:00:18 <nut> (1,3) ^. _1 > 2
12:00:48 <infandum> So, I have no idea how to use docker. Is this correct: I have a haskell program that has inline-r as a dependency. inline-r is finnicky with the system R libraries, so any other location will make it run into shared library errors. Is it possible, using docker, to have a container with a standard ghc (with stack) installation, R installation with some libraries I install, and deploy that to different computers?
12:05:05 <Welkin> infandum: why not try nix instead?
12:06:04 <fishythefish> orbisvicis, EvanR: not only that, but it depends on what you mean by infinity and how you're modeling the corresponding mathematical domain. Is it a genuine constructor of your type (data ExtendedN = Z | S N | Infinity) or is it really just a bottom value (data N = Z | S N; infinity = S infinity)? And what mathematical domain are you modeling? Negative infinity also satisfies that equation.
12:06:15 <Welkin> all infinities are not equal :D
12:06:27 <EvanR> fix S is not a bottom value
12:06:40 <fishythefish> sorry, meant to write "bottom" value
12:06:48 <fishythefish> obviously it's productive in a lazy context
12:07:14 <infandum> Welkin: I'm not sure if I can convince co-workers to use nix over docker
12:07:19 <EvanR> its observably different from bottom. yeah negative infinity is a possibility
12:07:26 <EvanR> theres all kinds of domains
12:08:08 <EvanR> though im confused about modeling a domain vs... "being" a domain by virtue of being a programming language data type
12:08:10 <infandum> And nix isn't a container, right, so it's not in it's own ecosystem
12:08:36 <fishythefish> in this case, I mean "domain" as in "domain knowledge", not "domain theory"
12:08:54 <EvanR> data R = AllReals | IV Q Q
12:08:57 <dyl> infandum isn't nix an OS/ecosystem, and docker a containerization tool?
12:09:01 <fishythefish> I also don't care too much about laziness vs. strictness here; this isn't particular to haskell
12:09:05 <dyl> Or does nix have its own containers now?
12:09:17 <Welkin> dyl: nixOps
12:09:35 <dyl> Oh man... the NixOS logo...
12:09:43 <dyl> it looks way too much like the HIV capsid protein.
12:09:58 <EvanR> D20 ?
12:10:13 <Welkin> it looks like a snowflake to me
12:10:17 <dyl> http://blog.targethealth.com/wp-content/uploads/2007/11/image0027.jpg
12:10:20 <dyl> Yeah, so does the capsid protein.
12:10:26 <Welkin> https://nixos.org/nixops/
12:10:35 <dyl> I've been working with models of this, hence my association. :p
12:10:39 <dyl> I don't think most people would make that association.
12:10:57 <Welkin> you work in a biochem lab?
12:11:23 <iron_houzi> Does anybody know why this course is advicing the reader to avoid stack: https://github.com/data61/fp-course#tips-after-having-started (point 6) ..?
12:13:19 <dyl> Welkin yup.
12:13:26 <dyl> crystallography and structural biology.
12:13:39 <dyl> But I'm going to start my PhD later this year.
12:13:42 <dyl> (in CS)
12:13:59 <Welkin> do you get to experiment in the lab with live viruses and diseases?
12:14:03 <dyl> No.
12:14:14 <dyl> You really don't want to be involved in that hahaha.
12:14:19 <EvanR> live viruses huhuhh
12:14:39 <dyl> Also, if you have the sequence for a protein, you just splice it into yeast or pikia.
12:14:46 <dyl> And then culture it.
12:14:48 <Welkin> EvanR: what is life? Baby don't hurt me
12:15:08 <dyl> You can use added protein tags to lyse/purify the proteins you want.
12:15:19 <dyl> It's amazing how expensive ordering pure reference samples of some of them are...
12:15:31 <dyl> It seems like many labs only order samples to nail their own production process.
12:15:50 <dyl> It's a lot cheaper to hack some yeast, purify, and freeze.
12:15:57 <dyl> I like referring to this process as
12:16:02 <dyl> *"yeast-hacking", or such.
12:16:41 <EvanR> the way god intended
12:17:03 <Rembane> :D
12:17:19 <dyl> HIV is especially weird though... it only 8-9 proteins.
12:17:24 <dyl> It gets the rest from us.
12:17:45 <dyl> gag, pol, env, tat, rev, nef, vpr, vif, vpu and I think there's one more?
12:17:55 <dyl> It's stupidly simple, dare I say... "elegant".
12:18:03 <ddellacosta> well this was an interesting moment to see what's happening on #haskell
12:18:11 <dyl> It's also really deadly, so the structural beauty is depressing.
12:18:16 <dyl> ddellacosta *waves*
12:18:20 <EvanR> i am trying to figure out how to use haskell on it
12:18:26 * ddellacosta waves back at dyl 
12:19:03 <EvanR> can you render free algebras in chemical chains
12:19:25 <dyl> You could *encode* whatever you want in DNA.
12:19:32 <EvanR> then reduce them... with... reduction reactions
12:19:46 <dyl> No, there's no natural transformation :p
12:19:46 <Rembane> I think there's a talk about this somewhere...
12:19:49 <EvanR> fold some proteins with a fold
12:19:57 <dyl> You'd just need to put together an RNA sequence and then use reverse transcriptase.
12:20:40 <EvanR> humans are the best virus
12:20:44 <dyl> So, in other words, you'd use a retrovirus to transform RNA ⇒ DNA.
12:20:52 <Rembane> Isomorphism?
12:21:07 <EvanR> using other viruses to do viral things
12:21:17 <dyl> I'm just waiting for the bioformalists.
12:21:20 <dyl> "everything is a string... of base pairs!"
12:21:35 <Rembane> Chemical computing! https://www.youtube.com/watch?v=cHoYNStQOEc
12:22:03 <dyl> Proteins are pretty cool. Little machines powered by entropy.
12:22:24 <dyl> You start wondering "yeah but how does the correct nucleotide-triphosphate get in that channel?"
12:22:29 <dyl> "oh, it's just there, eventually"
12:22:52 <Rembane> So when t -> inf, everything just works?
12:23:10 <dyl> I kind of want to design an esolang that works like this, where the "driver" of the program is some kind of fuzzing.
12:23:28 <dyl> So instead of calling a function with a parameter, you declare a unit with a site compatible with some type
12:23:33 <dyl> and it just gets fuzzed.
12:23:43 <Welkin> the driver is a gig economy contractor whose native language is not english, and their vehicle is unsuitable for the road
12:23:45 <dyl> and somehow you could use this to write useful programs.
12:23:50 <Welkin> and they can't drive
12:23:56 <dyl> "gig economy contractor"
12:24:02 <Welkin> so you want to build an uber language?
12:24:29 <infandum> dyl: No I don't think it does have containers which is why I was thinking of docker
12:24:45 <dyl> Welkin https://www.theonion.com/pros-and-cons-of-the-gig-economy-1819594160
12:25:12 <dyl> Pro: Fairly efficient way to compartmentalize human beings based on market value.
12:25:13 <dyl> Con: Still more costly than slavery.
12:25:29 <dyl> "Terror-fueled exhilaration that stems from not knowing how much you’ll be paid next week gets old after a while"
12:26:12 <Welkin> dyl: LOL https://www.theonion.com/police-repeatedly-shoot-tim-cook-after-mistaking-iphone-1824184361
12:27:02 <Welkin> "Sources reported that surveillance footage from the event also shows officers stepping over Cook’s dead body and firing multiple rounds at an image of the iPhone 11 on a video screen, believing it to be a large gun."
12:27:32 <Welkin> was there another recent police incident?
12:28:25 <Welkin> damn, the onion is nailing it with these
12:28:28 <Welkin> https://www.theonion.com/mark-zuckerberg-prepares-for-congressional-testimony-by-1824149833
12:36:48 <dyl> Welkin https://www.youtube.com/watch?v=kLQLS93ba3I
12:36:50 <dyl> this one is a gem.
12:36:58 <dyl> The little details are what make it.
12:54:42 <dyl> Trying to work out how to map the left/right stack or pairwise reduction parsing methods for APL and/or Dictionary APL into parser combinators :/. Doesn't quite work the way you'd expect haha.
12:55:15 <dyl> Extant APL-family implementations also tend to interleave parsing and execution.
12:56:21 <dyl> There is a reference implementation but...
12:56:22 <dyl> is:1⊣r ←t f ⍵⊣st ←((1↑s⌽q,¯1↑(s←'1'=q←r[0])⌽names),t←r[2]),st
12:56:22 <dyl>   f:(k↑r),⍺,((k←u⍳1)↓(~u←⍵='↓')/4↑r),4↓r⊣⎕←((1+⍴l)⍴' '),⍵
12:56:23 <dyl> Yeah.
12:56:26 <Rembane> Oldschool and fun!
12:56:34 <Welkin> what the hell
12:56:45 <Welkin> that looks like a konami cheat code
12:57:00 * hackage quickcheck-classes 0.4.7 - QuickCheck common typeclasses  https://hackage.haskell.org/package/quickcheck-classes-0.4.7 (andrewthad)
12:57:02 <Welkin> or special attacks in street fighter
12:57:44 <dyl> APL + Street Fighter. Player 1's IBM Selectric READY!
12:58:23 <k> wtf
12:58:50 <johnw> that's a good name for the language perhaps
12:58:51 <johnw> wtf
12:59:04 <k> i need to install fonts.
13:00:08 <Welkin> k: Josef K?
13:00:14 <dyl> http://www.jsoftware.com/papers/APLDictionary.htm see: "Table 2: Parsing Process" ⇒ "It may be read by anyone conversant with APL"
13:00:18 <dyl> Yeah, ok.
13:00:28 <k> Welkin: yes!
13:00:46 <abcd> \quit
13:00:56 <k> i think you're the first to recognize it.
13:01:20 <Welkin> k: not enough people read kafka
13:05:36 <dyl> One of the best parts of working with this APL project,
13:05:49 <dyl> is that *all* of the relevant papers are from forever ago.
13:05:52 <dyl> None of them have OCR.
13:05:55 <dyl> They're all bad scans.
13:06:01 <Rembane> :D
13:06:08 <Rembane> dyl: How did you end up working on an APL project?
13:06:08 <dyl> And they reference techniques we know and love as theoretical.
13:06:20 <dyl> Rembane I had the brilliant idea to implement an APL that uses emoji.
13:06:28 <Rembane> dyl: Oh
13:06:31 <dyl> And I've sunk so much time into researching, now I have to carry it out.
13:06:34 <Rembane> dyl: Amazing!
13:06:44 <dyl> It's a surprisingly neat project.
13:06:44 <dyl> Is it useful? No.
13:07:02 <dyl> But it's exposing me to a huge amount of research and a whole "dead branch" of the CS family tree I wouldn't have seen otherwise.
13:07:22 <dyl> It's like exploring a timeline that branched apart from ours 40 years ago.
13:07:39 <dyl> Even just finding a paper that discusses APL using such concepts as "BNF" is actually decently difficult.
13:07:46 <Rembane> That sounds really fun.
13:09:25 <dyl> Rembane here's a paper on parsing APL
13:09:28 <dyl> note the first section
13:09:31 <dyl> http://delivery.acm.org/10.1145/30000/28371/p441-girardot.pdf?ip=150.212.127.80&id=28371&acc=ACTIVE%20SERVICE&key=AA86BE8B6928DDC7%2E3F18A282B75518AA%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&__acm__=1522354182_5576e6fd4f302b2525b9c5e9f70bde02
13:09:47 <dyl> "Since our analysis of the problem uses traditional results of the ‘mainstream’ of computer science, we found useful to remind the reader with some of the notions relative to grammars."
13:09:52 <dyl> "2.1. WHAT IS A GRAMMAR ?"
13:09:55 <dyl> It's just great.
13:10:22 <Rembane> Awesome! :D
13:10:43 <dyl> "The problem with yacc is that it doesn’t allow backtracking. What was really needed was just a similar tool. offering an additional facility to reject temporarily some tokens until the c-omxt rule is found. We decided to build a generator, similar to yacc, but allowing backtracking. For the sole purpose of this exposition, this parser was named yaaa."
13:11:07 <dyl> "yaaa"
13:11:10 <Welkin> how do you pronounce "yaaa"?
13:11:13 <dyl> I have no idea.
13:11:18 <Welkin> like a surfer dude?
13:11:23 <dyl> I assume it sounds like the noise a yak makes?
13:11:42 <mnoonan> Imagine you were reading that paper with no context, so you'd go "uh, yeaahhh..."
13:11:59 <dyl> Also, the bits about performance are so quaint.
13:12:04 <dyl> "Results of these tests an shown in the following table, where a value such as 2.35 represents a duration of 2 minutes and 35 seconds for 10000 executions of the expression."
13:13:01 <dyl> https://imgur.com/a/d3vl3
13:13:02 <dyl> this is just great
13:13:07 <dyl> From before the days of code blocks...
13:13:23 <dyl> It's not even aligned!!
13:13:33 <dyl> It's skewed down the page.
13:14:22 <dyl> It's kind of cool to do silly projects like this. There's so much to learn, and you get a much better feel for the history of the field.
13:14:33 <dyl> It seems to me like we reinvent the same wheels every few decades, with different words.
13:14:39 <dyl> (some of the same wheels)
13:15:36 <Rembane> dyl: Tha link didn't work. What's the name of the paper?
13:15:50 <zachk> the wheels fell off a long time ago :(
13:16:11 <Rembane> One of my favourite aspects of ancient APL is that it predates structural programming
13:16:23 <dyl> Rembane "The syntax of APL, an old approach revisited"
13:16:32 <dyl> By Girardot and Rollin, 1987
13:16:33 <Rembane> dyl: Thank you!
13:16:43 <mnoonan> dyl: have you seen this? http://www.sacrideo.us/paper-is-dead-long-live-paper-programming/
13:16:45 <dyl> 10.1145/28315.28371
13:17:08 <dyl> Huh, neat.
13:17:45 <dyl> Rembane and yes, that is one very cool aspect.
13:17:51 <dyl> mnoonan I have not, but saved it.
13:17:58 <dyl> I don't even remember why I started doing this.
13:18:14 <dyl> I think I was originally doing a emoji befunge dialect but realized it would just be a pain and APL was more interesting.
13:19:02 <dyl> I plan to set up the initial working versions as twitter bots/SMS.
13:19:07 <dyl> SMS is the REPL.
13:19:13 <dyl> It's so bad it's good.
13:21:19 <dyl> Rembane also I realized that I'm familiar with the LISP, SIMULA, FORTRAN, ALGOL etc families and thought
13:21:24 <dyl> "why not explore the other one...?"
13:22:03 <Rembane> dyl: Was APL the only one left?
13:22:10 <dyl> No, just the most interesting one left.
13:22:38 <dyl> It feels so alien, hence my project's name of  "👽" (AyyPL)
13:22:51 <dyl> At the same time, coming from a math background it also feels very nice.
13:23:09 <dyl> If I could quasiquote APL into a Mathematica session I'd be quite happy.
13:24:31 <zachk> dyl, are you coding ayypl in haskell?
13:24:38 <dyl> I am!
13:24:50 <dyl> I haven’t used Haskell heavily in 4-5 years though.
13:24:58 <dyl> So there’s a lot to catch up on or shake the rust off of.
13:25:17 <brunocad> Hello! is there any disavantage of using STM TMVar and TChan over Control.Concurrent.Chan and Control.Concurrent.MVar?
13:25:42 <dyl> ayypl will be available on hackage.
13:25:47 <dyl> And potentially as a TH quasi quieter
13:25:47 <Rembane> brunocad: AFAIK: TVars are slower but have better ergonomics than MVars.
13:25:58 <Peaker> hi, do bound threads migrate between HECs that belong to the same OS thread?  I am confused about what HECs/capabilities actually mean w.r.t forkOS
13:26:11 <dyl> Though I’m not sure how quasiquoting would work when it’s an LLVM frontend
13:26:20 <Peaker> Is there a way to know whether 2 different Haskell threads are bound to the same OS thread?
13:26:35 <Rembane> dyl: It would produce loads and loads and loads of Haskell?
13:26:48 <dyl> Is there an LLVM ⇒ Haskell compiler?
13:26:50 <dyl> :p
13:27:02 <dyl> LLVM IR*
13:27:06 <Rembane> :D
13:27:07 <dyl> Emhaskellen?
13:27:31 <Rembane> "In this paper we prove that LLVM is equivalent to Haskell..."
13:27:38 <dyl> Yo dawg... “APL on LLVM on Haskell on Haskell on LLM.”
13:28:09 <Rembane> Running in the browser
13:28:19 <dyl> Via emscripten.
13:28:45 <dyl> AyyPL will run in a browser via emscripten.
13:29:01 <dyl> It’s also a chance for me to write some JIT.
13:29:33 <dyl> I believe Emscripten can itself be Emscriptened.
13:30:32 <dyl> Rembane I’m also thinking it would be pretty amusing to use afl-fuzz to generate AyyPL programs.
13:30:43 <brunocad> Rembane perfect thanks
13:31:58 <Rembane> dyl: That sounds like an amazing idea! :D
13:32:01 <Rembane> brunocad: no worries.
13:32:43 <dyl> The thing is before I can have any fun with this I have to actually implement it :)
13:33:20 <Rembane> I knew there was something!
13:34:48 <dyl> Rembane but again it’s a cool project to implement because it comes from so far before many of the more modern/nice techniques.
13:35:46 <Rembane> dyl: It is indeed. :D
13:35:55 <Rembane> dyl: It's all counterintuitive coolness!
13:36:01 <Peaker> if different HECs/capabilities can be on different OS threads -- and the main thread is bound, how come it can jump between HECs? :-(
13:36:02 <dyl> Pretty much
13:36:10 <dyl> I’m not sure if this project is cool, insane, or performance art.
13:36:37 <dyl> I just want to see it go live on Twitter.
13:36:49 <dyl> And watch the horrified reactions of the active PL Twitter people.
13:40:29 * hackage quickcheck-classes 0.4.8 - QuickCheck common typeclasses  https://hackage.haskell.org/package/quickcheck-classes-0.4.8 (andrewthad)
13:41:22 <Rembane> Peaker: Try +RTS -qm and see if that works
13:41:58 <Peaker> Rembane, but I don't want to prevent migration - I want to understand
13:42:19 <Rembane> Peaker: Then, we'll have to wait for someone that knows why it happens. :D
13:42:33 <Peaker> Rembane, I am using OpenGL, and stuff is happening from random threads. I want to add an assertion that it's used from the right OS threads. I don't think GHC gives me any tool to do that :(
13:43:08 <orzo> Does core have explicit rules for memory allocation?  Such as "only on let binding" ?  And if it does, is there anywhere I can read the details of these rules other than ghc source code?
13:43:37 <Tehnix1> Can cabal 2.2 be used with GHC 8.0 and GHCJS?
13:46:49 <dyl> Rembane: stretch goal, add MIDI output support to AyyPL.
13:46:58 <dyl> It’ll be so horrifically great.
13:48:28 <dyl> 🎺🎺🎺
13:48:53 <c_wraith> orzo, let bindings and function call arguments that aren't matched on. modulo whatever changes optimization makes
13:49:05 <tomsen> dyl: i only see squares, will ayypl have ascii smiley support?
13:49:31 <Rembane> dyl: :D
13:50:16 <c_wraith> orzo, oh. right. and things that reduce to constructor calls, as long as the allocation of the constructor isn't optimized out.
13:51:31 <dyl> tomsen: no, Unicode only
13:52:00 <dyl> The only allowed ascii is parentheses and numbers (though those can also be entered using numeric emoji...)
13:52:46 <dyl> How is it that so many people use IRC clients that don’t even handle UTF-8?
13:53:18 <Rembane> Old school. The encoding of IRC is Latin-15.
13:53:58 <TMA> dyl: even if it does, the font might be missing the [][][]
13:54:20 <dyl> IRC doesn’t have a specified encoding
13:54:24 <dyl> Let alone a formal specification
13:54:39 <dyl> The closest you’ll get is that it’s supposed to use 8-bit units.
13:54:43 <Rembane> That's true, but the de facto encoding...
13:55:14 <dyl> Should be UTF-8 because that’s what the simplest client is most likely to use
13:55:14 <tomsen> i dont use irc anymore these days. only this channel brought me here, and i used irssi, first hit on search. didnt even configure it to autoconnect. if u release ayypl ill invest in upgrade ;P
13:55:19 <dyl> Telnet obviously ;)
13:55:38 <dyl> When I release AyyPL I expect it to be integrated into lambdabot.
13:55:43 <dyl> :-p
14:02:56 <tomsen> i expect it to be used to run malicious code over telegram etc. without ppl noticing :D
14:07:45 <dyl> Rembane: I just decided what the token funny image in the github description should be.
14:07:50 <Peaker> is there a way to know if we're currently running in the threaded runtime (i.e: linked with -threaded)?
14:07:52 <dyl> Readme*
14:08:12 <dyl> The Fellow Kids image but with Kenneth Iverson’s face instead of Buscemi’s, and AyyPL on the shirt.
14:08:13 <Peaker> oh, rtsSupportsBoundThreads, nm :)
14:09:30 <Rembane> dyl: ^__________________^
14:09:38 <dyl> No, no whales.
14:10:04 <Rembane> dyl: Whales are the ultimate internet creatures
14:10:15 <dyl> That’s just in Star Trek II
14:16:47 <dyl> Btw anyone interested in AyyPL is welcome to join the #ayypl channel, though until I release the first alpha it’ll be pretty dull.
14:16:57 <dyl> It is a Haskell project, so this is on topic..?
14:17:08 * dyl shamelessly self-promotes his horrible idea.
14:19:06 <jared-w> oh AyyPl was a real thing?
14:19:29 <Adluc> dyl: whats ayypl?
14:19:36 <dyl> It’s not yet
14:19:41 <dyl> But I’m working b making it a real thing.
14:19:45 <dyl> On*
14:19:46 <Adluc> what it will be then?
14:19:53 <dyl> APL written with emoji.
14:19:59 <dyl> With an SMS based REPL.
14:20:30 <dyl> I will need help crowdsourcing ideas for the symbol set, I may put up a poll shortly.
14:20:42 <dyl> I have about 20% of them worked out.
14:20:42 <jared-w> nice
14:20:50 <dyl> No, it’s not. It’s horrible.
14:20:53 <dyl> I am birthing a monster.
14:21:10 <jared-w> Are you just going to straight up translate APL's character set to emojis and then compile to APL by symbol translation?
14:21:30 <dyl> No, I’m writing a brand new LLVM frontend in Haskell for it.
14:21:38 <dyl> It will be JIT compiled, not interpreted.
14:21:51 <dyl> C-linkage is a stretch goal.
14:22:03 <dyl> As soon as it even has definitions and isn’t just expressions.
14:22:05 <jared-w> nice nice. Dumb projects are the best projects
14:22:17 <dyl> It’s an interesting project.
14:22:32 <dyl> It’s really dumb superficially but there’s a lot of interesting stuff to study and apply.
14:25:16 <ystael> dyl: you are a sick monster and deserve to be punished by uncontrollable runaway success :D
14:28:40 <ystael> dyl: also I really want APL + Street Fighter
14:28:52 <dyl> How would that even work..?
14:29:51 <ystael> every special move corresponds to an APL symbol or operator. when you execute the "enter" move the damage your attack does if it connects is the value of the expression.
14:32:20 <jared-w> Be sure to do it in a freer monad so you can interpret the entire thing for maximum haskell swank /s
14:45:05 <rihards> hey, could anyone give me any tips on how to debug code that's using hmatrix-static in ghci? when i stop at a breakpoint and try to use :print on any of the hmatrix static variables all I get are some weird-looking type signatues (not sure what they are though)
14:46:07 <rihards> e.g. hmatrix-0.18.2.0:Internal.Static.R (hmatrix-0.18.2.0:Internal.Static.Dim (Data.Vector.Storable.Vector  1 0x000000420939cde0 (GHC.ForeignPtr.PlainPtr (_t5::GHC.Prim.MutableByteArray# GHC.Prim.RealWorld))))
14:47:44 <rihards> but when I try to manipulate any of the vectors in ghci, I always get something like "No instance for (KnownNat n1) arising from a use of ‘norm_0’"
14:50:41 <rihards> I've also tried messing around with giving some explicit types to the local variables at breakpoitns - let a = w :: R 2 -- and similar
14:51:05 <rihards> but this leads to "panic! (the 'impossible' happened)" :D
14:52:37 <rihards> so I guess my problem is that I don't really know what I'm doing and what's happening when I'm interacting with dependently typed stuff in ghci at breakpoints
14:58:20 <rihards> all I want is something representing the values in the vector
15:00:47 <jared-w> Do you have any code you can put in a gist or paste somewhere?
15:01:08 <amalloy> @pl \c -> isDigit c || c == 'X'
15:01:08 <lambdabot> liftM2 (||) isDigit ('X' ==)
15:01:08 <rihards> I could come up with some in a few minutes
15:01:22 <amalloy> why does it choose ('X' ==)? i would have expected (== 'X')
15:01:29 <jared-w> dependent typed stuff is a bit more painful in Haskell than in languages like Idris so the type errors are going to be a bit trickier :)
15:02:04 <jared-w> amalloy: (== 'X') and ('X' ==) are the same if equality is reflexive
15:02:10 <jared-w> :t (== 'X')
15:02:12 <lambdabot> Char -> Bool
15:02:16 <jared-w> :t ('X' ==)
15:02:17 <lambdabot> Char -> Bool
15:02:27 <amalloy> yes, clearly. but why does pl assume that, instead of just doing the "easy" thing that is also guaranteed correct
15:03:29 <jared-w> It's probably an implementation detail of some sort; the pl algorithm works for some trickier stuff with operator slices as well so it probably defaults to always putting the operator on the right ¯\_(ツ)_/¯
15:03:35 <RamZess> hello there
15:03:43 <amalloy> @pl \c -> c < 'X'
15:03:43 <lambdabot> (< 'X')
15:03:54 <amalloy> in this case it knows the operator has to stay on the correct side
15:06:39 <RamZess> i have a question about Kleisli example on https://wiki.haskell.org/Arrow_tutorial
15:07:07 <RamZess> i looks like the line "liftA2 (+) plusminus double" has a problem
15:07:27 <RamZess> the final expression "runKleisli h2 8" does not work
15:07:38 <RamZess> tried in GHCi
15:08:20 <RamZess> could smb explain me is it en error or I'm doing something wrong
15:10:00 <jared-w> amalloy: the source code for @pl is here: http://hackage.haskell.org/package/pointfree
15:10:04 <amalloy> i see. https://github.com/bmillwood/pointfree/blob/master/Plugin/Pl/Rules.hs#L732 - (==) is in a list of operators that @pl considers commutative
15:10:21 <jared-w> too slow :p
15:16:45 <RamZess> any suggestions so far?
15:21:08 <RamZess> :q
15:21:12 <RamZess> \quit
15:21:13 <jared-w> Unfortunately half the stuff on HaskellWiki doesn't compile anymore, if it ever did
15:21:23 <jared-w> Let's see if this is the case...
15:21:24 <isd> Hey all. I'm hitting build failures for the h-gpgme package. cabal seems to be deciding to build the package against `either` 5.x, even though there's an explicit `<5.0` bound in the gpgme cabal file. I'm able to get it to build by specyfing the exact version ==4.4.1.1 for `either`, either by patching the gpgme cabal file or by setting the constraint in my own project (which depends on gpgme). I'm not sure what the underlying problem i
15:21:24 <isd>  though. Can anyone else reproduce this/does anyone have any hunches?
15:21:39 <jared-w> (or not since RamZess got impatient :)
15:22:17 <jared-w> Is there a cabal revision somewhere, isd?
15:23:39 <isd> jared-w: not sure what you mean?
15:24:14 <glguy> isd: either 5 is actually < 5.0
15:24:22 <glguy> > [5] < [5,0]
15:24:25 <lambdabot>  True
15:24:52 <isd> Ah, that's non-intuitive. But would explain the issue.
15:24:55 <glguy> One of the unfortunate consequences of edwardk insisting on droping all trailing zeros :)
15:25:03 * deepfire notes that apInjs'_NP is semantically close to count/enumerate
15:25:08 <jared-w> ahh, yeah, I always forget about that
15:25:42 <jared-w> anyway h-gpgme doesn't have any hackage revisions so it should actually build nicely once that is fixed :p
15:27:14 <isd> Yeah, dropping the .0 in h-gpgme.cabal fixes the problem.
15:27:23 <isd> I will submit a patch to h-gpgme
15:28:22 <jared-w> Now the funny thing is, if I understand correctly, this will mean that a newer build creates less wrong build plans than the older cabal file :p
15:32:04 <rihards> jared-w: here's a gist for the hmatrix-static stuff I'm trying to debug https://gist.github.com/rihardsk/5afd42ebbb37a8488d6630742de82146 I'm not sure how helpful it is, but at least it's self-contained
15:32:33 <jared-w> neat :)  let me squint at it for a second or two. glguy would probably be more help though
15:35:25 <rihards> what I would like to be able to do is, e.g., to add a breakpint at line 38 to debug err. the problem is I can't force ghci to print anyhing meaningful when try to output w or x
15:36:53 <jared-w> hmm
15:37:09 <jared-w> try writing out the type signature you think err should have and then see what ghci says?
15:39:54 <zachk> @hoogle trace
15:39:55 <lambdabot> Debug.Trace trace :: String -> a -> a
15:39:55 <lambdabot> Linear.Matrix trace :: (Trace m, Num a) => m (m a) -> a
15:39:55 <lambdabot> Linear.Matrix trace :: (Trace m, Foldable m, Num a) => m (m a) -> a
15:40:10 <zachk> maybe Debug.Trace and use ghc
15:45:38 <rihards> jared-w: the type for err is just Double. adding it doesn't change anything
15:46:02 <rihards> here's a screenshot of what i'm trying to do with ghci. maybe it makes things clearer https://drive.google.com/open?id=1D96J4uHnknP5RtY8u1FC9BW6REQ5thei
15:46:08 <jared-w> oh right yeah I see what err is doing now. Forgot what <.> did for a second :)
15:47:15 <jared-w> I've always found Debug.Trace much more helpful than breakpoints for me but I've also always been a printf debug kinda guy
15:47:16 <rihards> :print w gives something that's not really using (I want values). and norm_0 w doesn't work
15:47:53 <rihards> ok, I might try that
15:50:11 <jared-w> hmm, what's the type of w?
15:50:41 <silver1> hey, I'm second year CS, just picked up Haskell a bit on the side, but my friend told me that Haskell is an impractical toy language, and real programmers learn C++ to build stuff that actually works -- how much of it is true, if you were objective?
15:51:07 <jared-w> silver1: whenever someone says "real programmers do X" they're either ignorant, lying, or selling something :p
15:51:29 <ddellacosta> silver1: don't listen to your friend. Haskell may not be used as broadly as C++ in the industry, but it's very far from a toy.
15:51:37 <hpc> silver1: how much C++ out there actually works? :P
15:51:42 <rihards> w is R n. when running foundws from the gist (and in my screenshot) it is R 1
15:51:46 <jared-w> Or trolling, which it sounds like he was doing, especially since he mentioned that C++ is used to build stuff that works
15:51:50 <Rembane> silver1, jared-w: Unless it's about EMACS.
15:52:40 <hpc> the sad truth is that on average, real programmers spend more time writing css than c++
15:52:45 <silver1> jared-w: he said that C++ is used to build anything from Google Search to World of Warcraft
15:52:49 <silver1> I don't think he was trolling
15:52:52 <silver1> he's an actual friend
15:52:53 <jared-w> rihards: Do you have typelits enabled in GHCi?
15:53:27 <jared-w> That known nat n1 sounds like to me when you're passing in a type of `R 1` to the norm_0 function that it's saying your '1' isn't the right type
15:53:46 <ddellacosta> silver1: the fact that C++ is used extensively says less about Haskell than it does about how the software industry works
15:54:23 <hpc> silver1: i don't use haskell at my current job, but am fairly confident that if i didn't learn it we would probably be at least a month or two behind
15:54:26 <hpc> as a company as a whole
15:55:50 <tjg> Hey there guys, I was wondering if you could help me with an issue?
15:56:29 <hpc> depends, is it haskell-related?
15:58:07 <jared-w> relationship advice goes in #haskell-offtopic :p
15:58:11 <rihards> jared-w: no I haven't enabled typelits explicitly in ghci. the module does get imported on line 12 though
15:58:53 <jared-w> oh right, typelits is the library and datakinds is the extension, durr
15:58:58 <hpc> jared-w: that goes in -blah, only the good random topics belong in -offtopic ;)
15:59:17 <jared-w> (☞ﾟヮﾟ)☞
15:59:55 <jared-w> rihards: try norm_0 w with -XDataKinds in GHCi then :p  It shouldn't matter... but I'm just not sure what else would cause that KnownNat issue
15:59:59 <tjg> Sorry I took so long here is my issue:   http://lpaste.net/364156
16:01:39 <tjg> I am trying to get a hoogle db up and running on ghc 8.0.2 but I am having problems
16:01:58 <rihards> tried it. enabling -XDataKinds doesn't help
16:02:21 <hpc> tjg: Perhaps you need to run 'stack init'?
16:03:36 <ZZzzz> i need to make function that give me a list of lists of all the options from the original list for example: if i have: function [1,2,3] i need to get in return: [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]. i ask for a hint. is there a smaller problem that i can solve that would help me solve the problem itself?
16:04:06 <tjg> for some reason when  I try to exec:   stack-hoogle -- generate --download in the dir: haskell-ide-engine it tries to install hoogle for 8.2.2(I have 8.0.2), but when I try exec that command on any other dir it tells me "no hoogle db yet"
16:04:45 <svet0> hey, is there anybody who would like to work on a small game task in exchange to some coins? Please PM.
16:06:08 <tjg> anybody have any idea how I can get around this???
16:07:09 <rihards> jared-w: oh well, I guess I'll continue to try to solve it tomorow (prabably will bug sombody here again :D ). thanks for the help anyway :)
16:07:23 <jared-w> sorry I couldn't help more. Hope you figure it out!
16:10:11 <tjg> hpc: I tried stack init, it gave me a lot of dependency errors.
16:10:40 <jchia_> ZZzzz: What do you mean by 'options'? Do you mean permutations?
16:12:16 <jchia_> ZZzzz: If you mean permutations, then you can find the namesake function in Data.List doing just that
16:13:00 <ZZzzz> jchia_: i want to do it myself :-)
16:13:11 <ZZzzz> without library function
16:13:45 <jchia_> ZZzzz: you can try a recursive definition
16:14:11 <jchia_> how do you get permutations of a list of N things if you already can get permutations of a list of N-1 things
16:14:40 <ZZzzz> yes i know :-). but i need a hint i'm stuck. so maybe there is a smaller problem to solve that would help me to solver the problem itself?
16:14:48 <tjg> The one thing that I miss about java is that there is all the versions of java are compatible. It sucks that Haskell versions arent compatible.
16:15:05 <ZZzzz> jchia_: that is a good question :)
16:15:24 <jchia_> ZZzzz: The base case is the empty list
16:16:07 <zachk> ZZzzz, I've done that before myself using do notation with the list monad, but it's recursive
16:16:28 <ZZzzz> it's OK it's recursive. all haskell is recursive' no?
16:17:03 <jared-w> Haskell makes recursion very very convenient, but it's not an inherently recursive language
16:17:46 <ZZzzz> jared-w: can you elaborate? or do you have aan example of "inerently recursive language"?
16:18:28 <MarcelineVQ> % :t (=<<) @[]
16:18:29 <yahb> MarcelineVQ: (a -> [b]) -> [a] -> [b]
16:18:44 <jared-w> is yahb a bot you wrote?
16:19:12 <MarcelineVQ> merijin's or mniip's, I can't recall
16:19:20 <jared-w> nifty
16:20:45 <jchia_> tjg: I have a ~/hs/doc directory stack-initalized to the resolver I want to use (e.g. lts-10.2, which is based on GHC 8.2). I "stack haddock" and "stack hoogle generate --rebuild --local" from that directory. That gives me local haddock and hoogle for lts-10.2. If I want those for GHC 8.0, it should work if the ~/hs/doc is stack-initialized to an earlier resolver with GHC 8.0.
16:21:21 <jchia_> tjg: I can't tell what exactly you did or what problems you saw exactly, but the above works for me.
16:21:43 <jchia_> When it's all done, I run "stack hoogle server -- --local --port 8000"
16:21:51 <jchia_> Then I have a local hoogle server on port 8000
16:23:16 <jchia_> I didn't mention that in the ~/hs/doc directory there's a minimal project specified to depend on packages whose documentation I want to see.
16:23:49 <jchia_> You said you used "stack init", not "stack new". Without any constraints on your existing cabal project, all sorts of errors can show up when you try "stack init".
16:24:03 <svet0> hey, is there anybody who would like to work on a small game task in exchange to some coins? Please PM.
16:36:29 <jchia_> Is there a package that allows permutating a mutable vector in-place given a permutation vector (of indexes) describing the permutation?
16:42:25 <jared-w> hmm... my vague intuition is that the structs package miiight be what you want, but I'm not sure on the permutation part
16:42:54 <jared-w> Does the vector package not have a function that does that sort of thing already?
16:49:45 <dmj`> V.modify (\vec -> forM_ [(1,2)] $ \(ix,iy) -> MV.swap vec ix iy) $ V.fromList [1,2,3]
16:51:28 <dmj`> jchia_: assuming the list of tuples represent indices to swap at
16:53:06 <jchia_> dmj: I suppose that means I have to compute the swap vector from the permutation vector first.
16:55:59 <jchia_> The basic idea is that you can think a permutation as a number of loops. Each loop is a (circular) sequence of indexes. Within each loop, you shift the indexed elements by one position, hence the swap operation. I don't think I can get it right the first time I write it, though.
16:58:16 <dmj`> jchia_: so you could represent the swaps in a separate vector based on the index and value
16:58:55 <dmj`> let permuteVector = V.fromList [1,3,0,2] in V.modify (\vec -> V.imapM_ (\ix e -> MV.swap vec e ix) permuteVector) (V.fromList [1,2,3,4])
17:14:59 --- mode: card.freenode.net set +o dibblego
17:14:59 --- mode: card.freenode.net set +o shapr
17:17:48 <jared-w> probably a server went down because of a DDOS attack somewhere
17:21:06 <zachk> jchia_, it's called a netsplit
17:21:21 <zachk> it's when irc servers on a network lose connection to each other
17:29:56 <mclark1129> has anyone used eventstore with haskell y et?
17:30:00 * hackage hdf5-lite 0.1.0.0 - Bindings to the HDF5 "lite" interface  https://hackage.haskell.org/package/hdf5-lite-0.1.0.0 (ocramz)
17:35:52 <woodson> Question, anyone has ever used Haste?
17:36:14 <woodson> haste-compiler, transpiler to javascript
17:43:22 <deepfire> stuck type families are really counter-intuitive
17:43:46 <deepfire> what can I read to understand them better?
17:44:14 <jared-w> type families or stuck type families?
17:44:15 <deepfire> I've got a case, where adding a clause that reduces to a TypeError, causes the type family to get stuck
17:44:29 <jared-w> oh nvm, no idea how to help then :p
18:05:13 <lyxia> deepfire: what does it look like
18:15:52 <jared-w> my fiancee found a shirt that says "It's just a moniod in the category of endofunctors. What's the problem?" I knew I was marring the right woman
18:25:00 * hackage hdf5-lite 0.1.1.0 - High-level bindings to the HDF5 "lite" interface  https://hackage.haskell.org/package/hdf5-lite-0.1.1.0 (ocramz)
18:25:58 <deepfire> lyxia: https://gist.github.com/deepfire/1dd56cf9ddcb1438996f70702f8a6d24
18:28:24 <deepfire> seems like it gets stuck once it meets a clause it cannot either prove or disprove
18:28:45 <deepfire> ..instead of proceeding further
18:32:28 <lyxia> oh I see, yes that is right
18:34:55 <lyxia> it can't decide which branch to take without knowing xs2
18:40:34 <Clint> is there something that'll compare two exported APIs?
18:41:49 <jared-w> Reading about the loeb function right now and it's just like wat
18:45:46 <mclark1129> How am I supposed to actually consume a GADT?  I don't have much experience with them, but since trying to pattern match on one to get out the values requires a language extension, I can't help butt feel like I'm using them the wrong way.
18:46:21 <EvanR> GADTs ... ARE a language extension
18:46:32 <EvanR> literally -XGADTs
18:46:47 <EvanR> you probably have to enable that to do anything with them
18:47:15 <EvanR> the only way you wouldnt is if the library youre using hides them entirely from you
18:48:04 <EvanR> pattern matching to decompose a GADTs is special in that it causes new type information to be in scope within the body of that case alternative
18:49:31 <deepfire> lyxia: thank you!
18:56:30 * hackage rest-client 0.5.2.2 - Utility library for use in generated API client libraries.  https://hackage.haskell.org/package/rest-client-0.5.2.2 (AdamBergmark)
18:57:00 * hackage rest-core 0.39.0.1 - Rest API library.  https://hackage.haskell.org/package/rest-core-0.39.0.1 (AdamBergmark)
18:57:33 * hackage rest-types 1.14.1.2, rest-stringmap 0.2.0.7, rest-gen 0.20.0.2 (AdamBergmark)
18:58:15 <mclark1129> EvanR: I guess I just don't even get GADTs at all.  On the face of it, I don't understand how this type I'm trying to use is different from any other type I'd define using data.
18:58:34 <mclark1129> e.g data SomeType = SomeType SomeOtherType SomeOtherOthertype
18:59:21 <mclark1129> Ugh, I hate having to read and learn things! I thought using haskell thought I get a) less code b) less bugs c) more cool.
18:59:28 <mclark1129> for free!
18:59:42 <jared-w> That's Haskell 98 ;)
19:00:04 <jared-w> Haskell + fancy magic requires a little bit of reading :)
19:00:40 <mclark1129> oh man, I can't even imagine the hipster cred I could gain by going "Haskell 2010?  Yeah I dunno man, I really preferred their old stuff.  I used to code 98 on vinyl"
19:02:43 <lyxia> there are gadts in vinyl :P
19:05:15 * mclark1129 just had his mind blown.
19:07:23 <jle`> mclark1129: GADTs are essentially sugar for types that might potententially have existentially qualified constraints
19:07:32 <jle`> mclark1129: so there isn't really a "big deal", it just makes it a bit more conveninet
19:07:51 <jle`> if you view them as just normal data types, i don't think you'd be too far off
19:08:14 <jle`> you can use GADT *syntax* to define normal haskell data types, and the user of those data types would have no idea they were defined using gadt syntax
19:08:24 <jle`> like data Maybe :: Type -> Type where Nothing :: Maybe a; Just :: a -> Maybe a
19:08:42 <jle`> the user of Maybe there would not be able to tell if it was made using GADT syntax or normal syntax
19:09:02 <jle`> so you can think of GADT as just sugar for declaring data types in an alterantive way, that might be more insightful
19:09:32 <jle`> once you declare the data type, if it's just a normal type using gadt syntax, the user uses it like any other data type
19:10:36 <deepfire> jle`: existentially qualified constraints?  Not just equality constraints?
19:10:47 <mniip> not just
19:11:16 <jle`> there isn't anything you can do with GADTs that you can't do with normal types + ExistentialQuantification, i believe
19:11:24 <jle`> but it makes it a whole lot more convenient
19:11:29 * hackage hs2ats 0.2.1.9 - Create ATS types from Haskell types  https://hackage.haskell.org/package/hs2ats-0.2.1.9 (vmchale)
19:12:00 * hackage openpgp-asciiarmor 0.1.1 - OpenPGP (RFC4880) ASCII Armor codec  https://hackage.haskell.org/package/openpgp-asciiarmor-0.1.1 (ClintAdams)
19:12:18 <mniip> jle`, normal types + ExistentialQuantification + TypeFamilies
19:12:30 <mniip> equational constraints require TypeFamilies or GADTs
19:13:18 <jared-w> GADTs require type families?
19:13:31 <mniip> no
19:13:33 <deepfire> no, can be simulated by
19:13:37 <mniip> but equational constraints do
19:13:56 <mniip> "simulated" is not a good word because internally it's the same
19:13:58 <jared-w> ah gotcha
19:15:26 * deepfire get a Pyrric victory over the type checker and goes to sleep..
19:15:36 <mniip> in core you just pass a coercion to a constructor
19:15:45 <mniip> type families are just coercion axioms
19:22:36 <jared-w> They're just coercion axioms? Having a hard time reconciling my current intuition of 'type level functions' with coercion axioms
19:30:44 <Average-user> Is there a way of doing pattern matching like "f a a" so that the program matches with that only if the two arguments are equal?
19:32:53 <jared-w> That works out of the box in the Curry language, but that's very unhelpful for you, unfortunately :)
19:33:13 <jared-w> f a b | a == b =   -- this is probably what you want
19:38:46 <blonkhart> what notion of equality does Curry use when integrating it with the pattern match?
19:39:55 <jared-w> magic
19:41:07 <jared-w> I say that with only a touch of sarcasm :p curry's Eq is built-in and automatically derived for all data-types. However, it's generally structural equality in the same sense that haskell's auto-derived Eq type is. (Curry is essentially Haskell 98, minus type classes, plus non-determinism)
19:41:41 <jared-w> pattern matching in curry is wicked powerful, though. It's desugared differently and you can do things such as functional patterns in the pattern matching
19:42:16 <jared-w> For instance:  `last :: [a] -> a; last (_++[x]) = x` is a valid and correct definition of a function which gets the last element of a list
19:42:25 <mniip> jared-w, is it built in to the point where it's an inhabitant of forall a. a -> a - Bool?
19:42:37 <koala_man> hey, I have a hackage project that triggers some kind of optimization bug in GHC 7.6.3 as found in Ubuntu 14.04. Other GHC versions are fine, and 7.6.3 works when compiled without optimization. Is there anything clever I can do?
19:42:56 <koala_man> can I blacklist a GHC version or something?
19:43:37 <jared-w> mniip: not quite sure. I haven't looked at the definition of how Eq is built in a while and there aren't really foralls in Curry types
19:45:15 <jared-w> (Unless I'm misunderstanding what you're asking somehow)
19:46:27 <mniip> jared-w, well in haskell the only two inhabitants of 'a -> a -> Bool' are '\_ _ -> False' and '\_ _ -> True'
19:47:03 <jared-w> ah right, okay. Yeah that's true of Curry as well
19:48:11 <jared-w> What I meant by builtin is that == works as if you wrote `deriving (Eq)` at the end of every datatype declaration and it also works on primitive types
19:49:17 <jared-w> But since there are no typeclasses in Curry equality derivation was built into the compiler for convenience; when typeclasses are added, it'll work exactly as Haskell does its Eq typeclass and it'll stop being a one-off special case in Curry compilers
19:52:15 <byorgey> infandum: oh, I see. Hmm, that looks tricky.  If I were you I would try sending an email to the author of that library, Gabriel Gonzalez, to see if he has any ideas.
19:52:53 <jared-w> The really fun part about Curry is that nondeterminism is a value just like computation is a value in Haskell
19:54:33 <jared-w> The choice operator ? allows you to write out functions that nondeterminstically choose between things. `coin = 0 ? 1 ` is the same as `coin :: Int; coin = 0; coin = 1` (pattern matching is always maximally overlapping in curry)
19:57:14 <mniip> uuhhh
19:57:19 <mniip> that sounds like a job for a monad
19:58:22 <mniip> this to haskell's [], is what C is to haskell's IO
19:59:33 <Average-user> jared-w: Everything else is done by pattern matching, I hope I don't be forced to use guards
19:59:33 <Average-user> jared-w: will be annoying
20:00:36 <jared-w> Well, the functional patterns are really really nice. And I haven't seen the non-determinsm be nearly as nice to do in Haskell as it is in Curry. The language itself is mostly for research in functional logical programming so the modeling of non-determinism itself is really about enabling logical programming to be done more conveniently
20:01:15 <jared-w> Average-user: you could also do `f a b = if a == b then ... else error "blah"` but that's what guards do anyway :)
20:04:12 <Average-user> jared-w: I do not want an error, cause I have  other patterns after
20:05:01 <jared-w> You'll need the guard then; I don't really know of any other ways to do it without the guard
20:05:57 <Average-user> jared-w: A long time ago, I heard about guards on the left definition of the function, like more complex patterns
20:06:09 <Average-user> don't know if it really exist
20:06:18 <Average-user> like guard patterns ore something like that
20:06:31 <jared-w> all guards have to be on the left side of the equal side?
20:06:48 <jared-w> `foo a b | predicate = ...`
20:07:36 <Average-user> I know
20:07:50 <Average-user> thats not what I meant, but I dont know how to explain it
20:08:36 <Average-user> I'll have to make something like f a b = if a == b then wtv else f' a b
20:09:37 <jared-w> You are probably thinking of ViewPatterns
20:10:38 <jared-w> (which is pretty similar to Curry's Functional Patterns)
20:13:08 <Average-user> http://lpaste.net/6839987915712364544
20:13:15 <Average-user> line 20, thats what I want
20:13:18 <Average-user> the ideal
20:14:26 <Average-user> I've been using haskell for a while, and I notes today that was impossible ,  thats one of the things that I miss of Prolog
20:14:51 <jared-w> ooh prolog, now I understand. You would like Curry then
20:16:15 <mniip> jared-w, maybe once we prove P = NP
20:16:49 <jared-w> One way to do that would be to have only one line for a :|: b and have an if a == b then f a else f a :|: f b
20:16:58 <mnoonan> Average-user: how would it work in prolog? deep equality comparison, or only if the lhs and rhs of :|: are literally the same thing in memory?
20:17:44 <Average-user> mniip: good1
20:17:54 <jared-w> mnoonan: same way it works in curry, so essentially structural equality
20:18:14 <mnoonan> I don't know curry or prolog, so.. :)
20:18:50 <Average-user> jared-w: Will be tedious to do it in all possible redundant clauses
20:19:07 <jared-w> mnoonan: `f a a = a` in curry will (insert mild handwaving) desugar to `f a b | a == b = a` (same semantics as haskell)
20:19:16 <Average-user> jared-w: And uglier , I'll try with view patterns
20:19:17 * mnoonan nods
20:19:46 <mnoonan> makes sense. do either do any hash-consing or anything? otherwise, that seems like a potential performance minefield.
20:19:53 <Average-user> jared-w: That sounds like a clojure macro
20:19:57 <jared-w> Prolog is a different beast but that's vaguely how it would work too, aside from the whole totally alien syntax thing
20:20:29 <mniip> jared-w, but what type does 'f' have then
20:20:32 <Average-user> jared-w: It is not that alien
20:20:40 <jared-w> Average-user: nah it's just normal pattern matching and pattern guards that Haskell uses
20:20:55 <mnoonan> in this particular case, you can also just have a normalizing smart constructor for (:|:)
20:21:18 <Average-user> jared-w: I ment the insertion of coude replacing another, is what macros do
20:22:10 <jared-w> mniip: f has the type a -> a -> a like you'd normally expect. `f a a` where both arguments are completely unrestrained is a bit uninteresting but saves on typing :)
20:22:18 <mniip> but then
20:22:27 <mniip> f a a = True
20:22:30 <mniip> f a b = False
20:23:08 <jared-w> Normally you'd do that with something like `f :: Expr -> Expr -> Expr; f a a = a` where if f is the identity function only if both arguments are the same and bottom otherwise
20:24:17 <jared-w> which sounds dumb but in a non-deterministic language, partial pattern matching is often desirable and otherwise totally fine. You only really need to consider the happy path (more or less)
20:24:44 <jared-w> http://lpaste.net/6839987915712364544 so in this example (which would compile as is in curry if you took out the 'deriving Eq' bit)
20:25:09 <mniip> is bottom here the empty nondeterminism?
20:25:23 <mniip> NTM that splits into 0 paths?
20:25:38 <jared-w> on line 20 if the two arguments were equivalent, it'll return `f a`; otherwise it'll fail and go on to the second pattern match on line 21
20:26:23 <jared-w> bottom here is the same bottom we talk about in Haskell
20:26:43 <mniip> can you have bottom ? bottom
20:27:31 <jared-w> sure, both paths will just fail so it'll be pointless
20:27:50 <jared-w> it'd be like saying `if (thing) then bottom else bottom`
20:28:15 <mniip> but it's two different bottoms
20:28:46 <jared-w> right, but they're undistinguishable by convention in Haskell
20:29:02 <jared-w> same is true in Curry from what I remember
20:29:37 <Average-user> mnoonan: whats that?
20:29:37 <jared-w> (Keeping track of theory and "this is what the pakcs compiler does" is slightly tricky every now and then; especially when the person that taught you Curry wrote the pakcs compiler)
20:29:38 <mniip> well in haskell it's explicitly stated that 'bottom `seq` bottom' can be either
20:30:43 <jared-w> right. ? will eventually explore both paths, so in a way the difference between the two doesn't matter
20:30:51 <jared-w> (which is the odd part)
20:31:06 <mnoonan> Average-user: e.g. (.|.) :: Expr -> Expr -> Expr, lhs .|. rhs = if lhs == rhs then lhs else lhs :|: rhs
20:31:19 <jared-w> (also why almost no IO is done with any non-determinism in Curry lol)
20:31:25 <mnoonan> and replace uses of :|: with .|. in your code, except for pattern matching
20:31:56 <Average-user> ahh
20:33:02 <mnoonan> you can sneak in other normalizations too, like defining lhs .|. (rhs1 :|: rhs2) = (lhs .|. rhs1) .|. rhs2
20:34:43 <mnoonan> I had some code that manipulated regular expressions, and doing this kind of thing carefully turned out to be critical for getting good performance
20:38:27 <Average-user> mnooman: that will probably help me. I have to make a converter to Conjuctive normal form, and I have that and the parser done, but I have to eliminate redundant clauses to finish it
20:39:23 <jared-w> mniip: so Curry has a tiny bit of special casing in it for its `undefined` apparently, after a bit of testing. `undefined ? undefined` will optimize down to just undefined even though `1 ? 1` doesn't (and shouldn't). But that's not really a big thing just due to how you program with non-determinism, it's more of a convenience than anything and certainly not a correctness issue
20:42:01 * jared-w is curious why (a `op`) /= \x -> a `op` x in the presence of seq
20:42:17 <jared-w> Like, I get the strictness differences, I'm just curious as to why nobody's fixed that in GHC yet
20:43:43 <Average-user> make an issue
20:43:54 <jared-w> it's a known thing and has been for ages
20:44:29 <jared-w> I'm guessing there's some subtle thing where it's been around for long enough that edwardk now relies on that for ugly abuse of haskell's typesystem or some other similarly horrible-yet-admirable reason :p
20:44:47 <jared-w> (or maybe people are lazy and fixing it requires fixing some other huge thing ¯\_(ツ)_/¯)
20:45:33 <mniip> reminds me of that integral constant expression test constant expression macro I've seen on LKML recently
20:46:02 <jared-w> link? I love me some dirty macro love
20:46:34 <mniip> https://lkml.org/lkml/2018/3/20/805
20:46:59 <jared-w> For my OS class last quarter I implemented a variadic macro that expanded to iterate over x linked lists (each different length, one list was an array of lists) and execute a common code block over every common element in the list)
20:47:31 <mniip> with deferred expansion?
20:47:43 <jared-w> It was glorious. My STM, state-list code was cleaner and shorter than the original code when I was done even though it was doing 10x the work lol
20:48:19 <jared-w> What is deferred expansion? I probably know the concept, just not the name for it
20:48:20 <Average-user> jared-w: what key did you use for this ¯\_(ツ)_/¯?
20:48:35 <jared-w> Average-user: The compose key along with linux magic
20:48:38 <mniip> jared-w, well it's the only "way" you can have "loops" in macros
20:49:26 <mniip> a friend of mine showed me that a while ago
20:49:30 <jared-w> ooh no it was just a variadic macro with the "n args trick" that takes how many arguments you pass into the macro, rolls that into a number and calls yourMacroN where N is the number of args you passed in
20:49:31 <mniip> strangely, for an OS class as well
20:49:40 <Average-user> -
20:49:43 <Average-user> -
20:49:50 <mniip> ah
20:49:52 <mniip> nah
20:49:55 <mniip> I've done that
20:50:06 <mniip> https://github.com/mniip/dlng/blob/master/syscall.h
20:50:33 <jared-w> From there I could do multiple layers of expansion to get my correct scoping of a variable in ansi-C over multiple loops and chain macros together to reduce typing
20:51:12 <mniip> tbh in that context I'd rather use stripped down C++
20:51:45 <jared-w> and then finally once I had all of the loops expanded out, the final expansion would call the correct looping macro for whichever state list I was iterating over so that the one state list which was actually an array of lists didn't need to be special cased
20:51:59 <Average-user> ¯\_(ツ)_/¯ this is not ASCII right?
20:52:09 <jared-w> no, definitely not
20:52:23 <Average-user> but just because of the face right?
20:52:29 <mniip> I only remember the codepoint for ಠ_ી
20:52:47 <jared-w> It uses a character from an asian alphabet somewhere for the smiley face and the two hands and the shoulders aren't really ascii either.
20:52:58 <Average-user> ¯\_(``/)_/¯
20:53:10 <Average-user> close enough
20:53:18 <mniip> ¯ is not ascii
20:53:38 <mniip> > ord "¯"
20:53:41 <lambdabot>  error:
20:53:41 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[Char]’
20:53:41 <lambdabot>      • In the first argument of ‘ord’, namely ‘"¯"’
20:53:42 <mniip> > ord '¯'
20:53:45 <lambdabot>  175
20:54:01 <Average-user> damn
20:54:05 <jared-w> mniip: why didn't you just call syscall(n-1 underscores) with n-1 arguments in the syscall(n underscores) macro?
20:54:50 <mniip> jared-w, hmmm?
20:55:09 <jared-w> oh wait, nvm, I was reading the code backwards
20:55:28 <mniip> the issue here is that syscall6r is kind of expensive
20:55:30 <mniip> due to ABI
20:55:40 <mniip> you have go pass data on the stack
20:56:12 <Average-user> bye
20:56:29 <jared-w> right. In my case it was just text expansion so my with_lists8 was just "withlist1 withlist7" and withlist7 was just withlist1 withlist6 and so on
20:56:51 <mniip> see how nicely the kernel ABI interacts with the userspace ABI: https://github.com/mniip/dlng/blob/master/syscall.S
20:57:05 <jared-w> yeah it's super nice
20:57:35 <jared-w> I always felt like a little bit of ugly in your headers went a long waywhen writing low level code
20:57:52 <mniip> in anothe rproject I've done something different
20:58:06 <mniip> https://github.com/mniip/rualloc/blob/master/syscalls_x86_64.h
20:58:55 <jared-w> "terrible things were sometimes required to create beautiful abstractions" - Roger, trailblazing implementer of /sys/proc
20:59:04 <jared-w> I've always loved that quote
20:59:20 <jared-w> well, more of a philosophy than a quote, but still
20:59:46 <mniip> my dark humorous mind wants to attribute that quote to hitler or somehting like that
20:59:54 <jared-w> ಠ_ಠ
21:00:44 <mniip> hmm
21:00:47 <jared-w> So you just wrote out the raw asm in the syscalls here rather than the extra layer? That works. Any particular reason you picked that approach?
21:01:13 <mniip> I don't think so
21:01:24 <mniip> the whole project is a few hundred lines, not much thought went into it
21:01:29 <jared-w> that's fair
21:01:50 <mniip> 140 lines
21:02:04 <jared-w> I didn't get nearly as good of a grade on my OS class as I could have. Spent too much time on macros, not enough on documentation and forgot to study for the final :)
21:02:14 <jared-w> but god_damn_ was that code /beautiful/
21:04:19 <mniip> suddenly want to finish all my projects
21:04:22 <jared-w> I'm saving that ICE_P macro somewhere to pull out whenever I want to terrorize future graders
21:04:37 <mniip> hold on I'll pull out the deferred macros...
21:04:43 <jared-w> aww yiss
21:04:45 <mniip> it must be somewhere in my irc logs
21:05:06 <jared-w> Have you seen the implementation of lisp in C macros?
21:06:19 <mniip> I've implemented "lisp" in C once myself
21:06:42 <mniip> in quotes because it was based on lambda calc and not S-exps
21:09:16 <jared-w> heh, nice
21:09:51 <jared-w> https://github.com/eudoxia0/cmacro
21:12:13 <mniip> hmm can't find it
21:12:27 <jared-w> Darn, was hoping for more black magic
21:14:15 <jared-w> heh just realized I already implemented something even trickier than ICE_P for my OS class, just using a builtin instead
21:15:37 <mniip> I once implemented a C++ macro that implemented conditional catch
21:15:46 <mniip> it desugared into, wait for it,
21:15:55 <jared-w> I wanted to expand LIST(foo) to &ptable.pList.foo but LIST(ready) to &ptable.pList.ready[0] since the ready list was an array of lists and the rest were just normal linked lists, so I did a builtin comparison with a pointer and the argument and if it failed I assumed it was the pointer to a list :p
21:16:09 <mniip> inline assembly with directives for GAS to replace CFI information with a hook to my own SEH handler
21:16:47 <jared-w> damn
21:17:19 <mniip> I wonder where that file is...
21:17:25 <jared-w> gonna have to hang up my macro creds; that's way niftier than the bullshit I've done lol
21:22:14 <rayediaz> :D
21:29:32 <jared-w> haaah, they ran into the issue I ran into as well. I had to use builtin_choose_expr to get around potential side-effecting actions with ?
21:48:51 <Teiko> list
21:50:08 <sl2c> Teiko: [] or a:as
21:58:00 * hackage ochintin-daicho 0.3.1.1 - A module to manage payroll books for Japanese companies.  https://hackage.haskell.org/package/ochintin-daicho-0.3.1.1 (arowM)
22:07:30 <woodson> lets say I am parsing a yaml file and there are about 30 fields and 10 of them are required the other 20 can be optional. is there a better approach then making them all Maybe fields?
22:08:52 <rotaerk> seems like the most appropriate way, to me
22:12:36 <MarcelineVQ> I've heard of using a Map for your optional fields
22:14:14 <woodson> MarcelineVQ: But then I would still have to specify which field I want to parse when defining the FromJSON no?
22:14:33 <MarcelineVQ> dunno anything about that myself
22:15:17 <woodson> oh no, I remember I have to extract the required fields and then I can remove them from the Object type of aeson
22:15:31 <woodson> because the Object is technically a hashMap
22:17:13 <woodson> I think that I will just add a bunch of Maybe's because I need to produce a specific xml based on each field
23:06:51 <aasronStone> what does this syntax imply ?? type Something :: * ??
23:07:02 <tdammers> that's a kind signature
23:07:07 <tdammers> it means Something should be of kind *
23:07:16 <tdammers> (as opposed to * -> * or something else)
23:08:03 <aasronStone> tdammers : so it says `something` the type should be of `kind` * ??
23:08:14 <tdammers> yes
23:08:48 <tdammers> in a type family context, what concrete type Something is depends on, well, the concrete type family
23:08:59 <aasronStone> and what about this one type Bound m   :: Nat
23:11:15 <tdammers> https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/type-level-literals.html <- aasronStone
23:11:53 <aasronStone> tdammers : also how could something be of kind * when it clearly accepts a type paramter ?? isn't its of kind * -> *
23:13:18 <tdammers> it doesn't accept a type parameter though, does it?
23:13:32 <tdammers> note that the type family context itself doesn't count as a type argument
23:44:29 <robstr> morning
