00:00:04 <halogenandtoast> first guess is --resolver
00:00:17 <cocreature> yeah that should work afaik
00:00:20 <cocreature> or just update the bounds
00:01:31 <halogenandtoast> How would one update the bounds?
00:01:58 <krakrjak> halogenandtoast, in the cabal or hpack file
00:02:11 <halogenandtoast> --resolver did indeed allow me to pick a different lts, which worked
00:02:47 <halogenandtoast> ah right, the issue was happening when I ran `stack new BoardGameGarden yesod-postgres` but it's still basing that off a cabal or hpack file
00:05:07 <krakrjak> yup
00:06:12 <krakrjak> well, I guess the bitrot on the program I'm working on still needs work.... The gl package is fine it seems.
00:06:23 <krakrjak> I've got bigger issues :(
00:42:54 <ZeuPiark> hello
00:44:35 <halogenandtoast> Hello
00:51:56 <dminuoso> With spacemacs and intero, is there a way to build a stack target?
01:09:54 <EvanR> the key to the halting problem is, any program or computer that supposedly solves it for all inputs has to be wrong. you could go as far to say this proves there are things computers cant be applied to and be right
01:10:40 <EvanR> but in that movie with HAL 9000, a plot point was how infallible computers are
01:11:02 <EvanR> maybe by 2001 they had lost track of turing's result
01:13:03 <dminuoso> EvanR: The way I like to think about it, a claim that the halting problem can be solved is either wrong or computability theory is inconsistent. :P
01:13:58 <EvanR> a lot of other things would be inconsistent in the process
01:16:39 <tdammers> we only know it cannot be solved using formal methods; problem is, we don't have any other methods that actually work
01:17:01 <[exa]> EvanR: HAL9000's conception of halting was quite more related to humans than algorithms btw. :]
01:17:03 <tdammers> and I believe proving that no other methods exists amounts to the halting problem :x
01:17:15 <dminuoso> tdammers: What do you mean?
01:18:18 <[exa]> tdammers: by "other methods" you mean methods that can't be computed using a turing machine?
01:18:19 <tdammers> dminuoso: we can have formal methods that describe other formal methods, that is the key to Gödel's work, but it only works for, well, formal methods, systems of axioms and rules
01:19:11 <tdammers> so in order to prove the validity of some other method, one that would be able to solve the halting problem, we would have to describe it in a formal system
01:19:21 <tdammers> and then prove, in the formal system, that it is valid
01:20:00 <tdammers> but if we can do that, then we can also express the hypothetical system's way of solving the halting problem in terms of our formal system
01:20:13 <tdammers> which essentially amounts to solving the halting problem itself in the formal system we already had
01:20:20 <tdammers> but that's not possible
01:20:43 <tdammers> ergo, either no such "more powerful than a formal system" method exists, or it exists but we cannot prove that it is valid
01:21:07 <tdammers> [exa]: yes, pretty much
01:21:17 <[exa]> if a more powerful formal system exists, will you be able to reason about it?
01:21:27 <tdammers> well, no, that's the point
01:21:40 <geekosaur> only in a still more powerful formal system
01:21:45 <tdammers> exactly
01:21:58 <EvanR> thats fine, formal systems all the way up
01:22:01 <[exa]> btw there are existing systems for this thing
01:23:09 <[exa]> you just assume that the set ø' is recursive, aaaaaaaaaaand done
01:24:39 <[exa]> getting the reasoning down to actual numbers there is undecidable, but there are useful results
01:24:45 <sepakorayl> in the end I think all those implicit error conversions perhaps are not a good idea
01:27:47 <[exa]> tdammers: btw, halting isn't _extremely_ opaque. There's even an established probability that a randomly picked program will halt
01:29:18 <Ariakenom> obviously anything called program needs a type system proving totality. so just use const True for halting
01:30:58 <tdammers> [exa]: of course; if the halting problem were more pervasive, writing computer programs would be highly problematic, and only a handful of experts would be able to write bug-free code
01:31:00 <tdammers> oh wait, hmm.
01:31:31 <EvanR> ... and what is this probability
01:31:52 <EvanR> i think references to that in here previous ended up in frustration and confusion
01:32:06 <dminuoso> Ariakenom: Yes, clearly a type system solves all problems
01:32:06 <[exa]> tdammers: lol :]
01:32:12 * dminuoso .oO( UndecideableInstances )
01:32:37 <cocreature> dminuoso: let’s hope, the DecidableInstances proposal comes through ;)
01:32:59 <[exa]> EvanR: it's interestingly high number, I'm looking for the paper
01:34:20 <Ariakenom> dminuoso, of course. As long as we've proven halting then proving halting is easy. I got this.
01:37:18 <tdammers> I'd think that it's not easy to come up with a "fair" definition of "randomly picked" though
01:37:43 <tdammers> depending on your "instruction set", certain types of programs could be over- or underrepresented
01:38:39 <[exa]> tdammers: instructions were abstracted out, it was from all recursively enumerable sets
01:38:53 <dminuoso> cocreature: Will it come alongside of DecidableHalting?
01:38:54 <swatnet> swatnet
01:39:02 <swatnet> botnet
01:39:08 <swatnet> redshield 5
01:39:10 <tdammers> [exa]: well, what I'm hinting at is that "are these two things the same program" is kind of hard to decide or even define, isn't it
01:39:13 <swatnet> alpha sector
01:39:43 <swatnet> <tdammers> [exa]: well, what I'm hinting at is that "I'm scared omg help me" is kind of hard to decide or even define, isn't it
01:39:45 <cocreature> dminuoso: I was only partly joking here, ed did actually make a proposal with that name https://github.com/ghc-proposals/ghc-proposals/pull/114 ):
01:39:47 <cocreature> *:)
01:39:57 <swatnet> swatner
01:40:00 <swatnet> swatnor
01:40:03 <swatnet> botnor
01:40:06 <swatnet> botnort
01:40:06 <tdammers> @where ops
01:40:07 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver shachaf shapr ski
01:40:08 <swatnet> torn
01:40:11 <swatnet> pornet
01:40:13 <[exa]> the point was that there's not very much recursively enumerable sets so the probability that something halts (of obvious type infinity/infinity) gets quite high
01:40:15 <swatnet> penis pump exe
01:40:18 <swatnet> file crump
01:40:20 <swatnet> decrypt penis
01:40:27 <swatnet> redshield 7 sector penis
01:40:42 <swatnet> Topic for #haskell is: https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | cabal update stuck? http://mail.haskell.org/pipermail/haskell/2018-January/025325.html
01:40:42 <swatnet> * Topic for #haskell set by geekosaur (Sat Feb  3 03:04:44 2018)
01:40:42 <swatnet> * Channel #haskell url: http://www.haskell.org/
01:40:42 <swatnet> <tdammers> I'd think that it's not easy to come up with a "fair" definition of "randomly picked" though
01:40:44 <swatnet> <tdammers> depending on your "instruction set", certain types of programs could be over- or underrepresented
01:40:47 <swatnet> * connrs (~connrs@mercury.meantime.co.uk) has joined
01:40:49 <swatnet> <[exa]> tdammers: instructions were abstracted out, it was from all recursively enumerable sets
01:42:10 <tdammers> [exa]: just saying, the exact number may or may not be meaningful beyond "it's surprisingly high"
01:42:22 <haskell> Yo check me out
01:42:31 <[exa]> tdammers: it didn't converge to zero
01:42:56 <haskell> Been a dev for a year now and still don't know what a pull request is
01:43:03 <[exa]> tdammers: it's a paper that should be authored by Antonin Kucerea here, can't find it sadly (it's like from 1985)
01:43:25 <[exa]> *Kucera
01:44:05 <tdammers> haskell: look it up if you want to know... but really, it's literally that, a request to pull
01:44:22 <haskell> Pull what?
01:44:43 <tdammers> haskell: are you familiar with basic source control terminology? committing, pushing, pulling?
01:45:01 <haskell> Exceptfor pulling
01:45:12 <tdammers> oh, OK
01:45:23 <tdammers> a pull is basically the same as a push, but the other way around
01:45:34 <tdammers> seriously though I recommend reading the git book
01:45:35 <tdammers> https://git-scm.com/book/en/v2
01:45:42 <dminuoso> cocreature: Mmm, I think its time I learned about fundeps. Going through edwards proposal, it seems that it's rather simple conceptually.
01:45:43 <EvanR> first of all, what in the world is a randomly chosen turing machine
01:46:04 <tdammers> EvanR: exactly, that was my point
01:46:06 <haskell> Thx
01:46:11 <ertes-w> helo
01:47:11 <[exa]> EvanR: you can generate all different recursively enumerable sets, which 1:1 correspond with all non-isomorphic turing machines
01:47:32 <ertes-w> (technically a "pull request" is really a merge request)
01:47:58 <ertes-w> but then a "pull" is really a fetch-and-merge anyway =)
01:48:08 <EvanR> are we talking about the usual unconstructive platonic-like math entities
01:48:46 <EvanR> where "there exists probability p such that" has no chance of being a particular number
01:49:12 <[exa]> ofc not
01:49:21 <EvanR> it simply exists due to axiom or choice or similar
01:49:49 <tdammers> well, you can say that "no matter which exact numbering / representation / encoding we pick, there exists a probability P such that..."
01:50:02 <tdammers> and the "such that" would still give us useful information
01:50:25 <tdammers> such as that it doesn't converge to zero, which is interesting in its own right
01:50:38 <EvanR> establishing a particular set of details, and still not having a number would be annoying
01:51:09 <EvanR> not zero and not greater than zero would be interesting too
01:52:33 <EvanR> what i was saying was, lets say you have an infinite number of turing machines, how is "choosing a random one" to be possibly meaningful. weighting them exponentially?
01:53:21 <EvanR> flip a coin, head first one, tails discard and repeat
01:53:42 <tdammers> something like that, I guess
01:54:16 <[exa]> yeah that works with RE sets. Turing machines are weird for that (but otherwise they model the same computations)
01:54:57 <tdammers> you can also say that you enumerate *all* of them, and then figure out what the distribution converges to
01:55:28 <EvanR> wouldnt that be the chaitin constant
01:56:55 <tdammers> lim n→∞ Σ(0..n) halting(program[n]) / n
01:56:58 <tdammers> sth like that
01:57:59 <EvanR> uncomputable, obviously. but what, someone claims that converges to something
01:59:58 <tdammers> well
02:00:55 <tdammers> lim n→∞ Σ(0..n) definitely_halting(program[n]) / n *is* something we can calculate, I think
02:01:54 <tdammers> we'd still miss some programs that halt in ways our definitely_halting property doesn't capture, but it establishes a lower bound
02:02:11 <tdammers> so if that lower bound doesn't converge to zero, then neither will the real thing
02:03:35 <tdammers> or, put differently, if we can come up with a definitely_halting function that we can evaluate in finite time, and that gives us a distribution that doesn't converge to zero, then we can say that the actual distribution also doesn't converge to zero
02:03:43 <tdammers> dammit, now I want to read the paper
02:04:19 <[exa]> tdammers: I've got to go AFK, I guess if you google Chaiting together with Kucera and Kolmogorov complexity, something should show up
02:04:57 <tdammers> will do, thanks
02:05:09 <[exa]> tdammers: anyway, the trick was that you can run halting and non-halting program in parallel and discover a newly halting program for free with some probability
02:05:30 <[exa]> which generates tremendous amounts of programs that each do something different
02:06:22 <tdammers> oh, cool
02:06:23 <[exa]> which raises the probability a bit against the overwhelming number of all programs
02:06:29 <tdammers> that is cleve
02:06:42 <[exa]> I took the course like 5 years ago so the details are gone, sorry. :D
02:08:54 <AWizzArd> In https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-List-NonEmpty.html the constructor (:|) is listed. How can I know from this doc page that (:|) is _not_ exported and I can’t call it?
02:09:27 <AWizzArd> Just trying to understand better how to parse those docs. I was under the impression that if the constructors are listed then it means they are exported.
02:09:32 <AWizzArd> (and public API)
02:09:44 <barrucadu> It is exported
02:10:13 <AWizzArd> barrucadu: how can I import it? I tried `import Data.List.NonEmpty (fromList, (<|), (:|))`
02:11:00 <barrucadu> import Data.List.NonEmpty (NonEmpty(:|))
02:11:44 <barrucadu> For constructors, the syntax is Type(Constructor1, Constructor2, ...)
02:12:57 <phadej> NonEmpty((:|))
02:13:13 <barrucadu> Ah, yes, that
02:13:29 <barrucadu> If it doubt add more parentheses
02:19:04 <AWizzArd> Okay good thanks. Yes, a double layer of parens solved it.
02:26:53 <halogenandtoast> Is there a way good way to integrate webpack into Yesod, or will I just have to compile the files manually?
02:27:05 <halogenandtoast> Just checking if anyone has already done thig
02:27:07 <halogenandtoast> *this
02:36:30 <tdammers> not sure, but I'd just do the webpack thing as a separate build step
02:36:48 <tdammers> I don't use Yesod, but when I do web dev, I usually have a similar thing set up
02:37:19 <tdammers> e.g., sass compilation produces css files, and then a file-watching job on the /static/css dir triggers a rebuild of the main app
02:37:37 <tdammers> you could do a similar thing for webpack
02:37:51 <tdammers> (assuming that you're compiling static resources into the application, that is)
03:07:00 <halogenandtoast> tdammers: Thanks, I'll try some things out.
03:07:04 <halogenandtoast> or give up
03:07:56 <tdammers> halogenandtoast: in case of doubt, using inotifywait and your own script should always work
03:08:07 <tdammers> takes a bit of fiddling though
03:08:23 <tdammers> I usually write a run-devel.sh that kicks off all those jobs
03:10:26 <ventonegro> There is also the steel overseer
03:11:03 <ventonegro> https://github.com/schell/steeloverseer
03:22:45 <kuribas> Isn't there a good link between functional programming and microservices?  Just like a pure function, a microservice doesn't share state, and communicates with pure messages.
03:28:06 <Taneb> kuribas: that's the philosophy of Erlang, to my understanding
03:32:18 <kuribas> yes, the actor model, which is what OO should have been.
03:33:57 <kuribas> and cloud haskell, a typed version of erlang style concurrency.
03:34:31 <Hijiri> how do I import a pattern synonym?
03:34:33 <Hijiri> actually I mean, how do I specify it in an import list
03:34:35 <Hijiri> nevermind, I just had to put pattern before it
03:34:37 <Hijiri> I swear I didn't know before I asked though, I just vaguely remembered seeing something like this after I asked the question
03:35:04 <Taneb> Hijiri: glad we could help ;P
03:35:16 <kuribas> buy a rubber duck?
03:35:48 <Taneb> kuribas: I think the more you get embarassed by suddenly realising the answer, the more likely your brain will just give it to you
03:35:57 <Taneb> An IRC channel with a few thousand people works pretty well
03:36:19 <tdammers> brains are jerks that way
03:36:49 <kuribas> there are a few thousand people here?
03:37:20 <kuribas> so haskell has failed avoiding popularity...
03:38:25 <Taneb> kuribas: you should see how many people are in the Python IRC channel;s
03:41:09 <barrucadu> The motto is avoid success at all costs, not avoid success at all costs. (use creative bracketing to derive whatever meaning you want)
03:42:52 <Ariakenom> The "motto is avoid success at all" costs
03:43:33 <tdammers> The motto is "avoid"; success at all costs.
03:43:44 <Ariakenom> avoid "success at all" costs?
03:44:19 <tdammers> the possibilities are endless
03:47:57 <dminuoso> tdammers: With a finite number of words the possibilities are not endless.
03:48:01 * dminuoso smiles
03:49:46 <Taneb> The motto is "avoid success at all costs, not avoid success at all costs"
03:50:49 <tdammers> dminuoso: I know. I resisted from adding "...but not literally"
04:02:06 <frerich> dminuoso: The possibilities are "endless", he meant.
04:02:39 <dminuoso> frerich: Haha touche.
04:28:00 <guessWho> hey guys how can i solve this http://lpaste.net/363553 , because another available constructor is not exported by the module ??
04:29:03 <dminuoso> guessWho: The error message is quite explicit and simple. Which part are you confused about?
04:29:17 <dminuoso> Well, more specifically its just a deprecation warning.
04:29:48 <guessWho> dminuoso : this part "Use the Num instance"
04:30:21 <dminuoso> :t 5
04:30:23 <lambdabot> Num p => p
04:32:24 <dminuoso> guessWho: Do you know how to make an `Int` out of that?
04:33:32 <dminuoso> guessWho: Also you should really take a read at the documentation of your library. It even tells you how.
04:36:43 <guessWho> dminuoso : i know that but i cannot do the same when i'm writing the serialise instance
04:37:26 <dminuoso> guessWho: What do you mean?
04:37:43 <guessWho> dminuoso : take a look at this http://lpaste.net/363555
04:38:22 <cocreature> guessWho: you can use "fromIntegral"
04:38:27 <cocreature> eh fromInteger
04:38:34 <cocreature> :t fromInteger
04:38:36 <lambdabot> Num a => Integer -> a
04:39:24 <guessWho> cocreature : in palce of PortNum >>?
04:39:27 <cocreature> or I guess fromIntegral might be better after all
04:39:44 <cocreature> guessWho: yes, something like "fromIntegral <$> decode"
04:39:57 <cocreature> probably need a type annotation to specify that it should decode as a Word16
04:56:14 <frerich> Is there anyone around who has some experience with constraing programming in Haskell in general (or using the 'csp' package in particular)? To get my feet wet with CSP, I'm trying to write a program to solve the 'Zebra Puzzle' (https://en.wikipedia.org/wiki/Zebra_Puzzle).
04:56:43 <frerich> My current solution is at http://lpaste.net/4096544793381830656 -- what's not clear to me yet is how to model rules like 'The man who smokes Chesterfields lives in the house next to the man with the fox.' -- I believe these correspond to constraints spanning three variables, right?
04:58:01 <frerich> I don't quite understand how to restrict the domain of a variable such that given a triplet like (a,b,c) I can express 'b == 2 is equivalent to either a == 1 or c == 1'.
05:04:51 <haskell> Nice code man
05:09:36 <newhoggy> When I attempt to upload my package to hackage, I get this error:
05:09:37 <newhoggy> Instead of 'ghc-options: -DBMI2_ENABLED' use 'cpp-options: -DBMI2_ENABLED'
05:10:19 <newhoggy> Problem is when I follow the instruction pragmas test doesn't work anymore.
05:10:35 <newhoggy> Anyone know what's going on here?
05:11:24 <newhoggy> My project is here: https://github.com/haskell-works/bits-extra
05:12:48 <cocreature> newhoggy: what’s the error that you’re seeing after switching to cpp-options?
05:22:19 <guessWho> is it possible to search a Hash Map by it's value ??
05:22:52 <cocreature> guessWho: how about Data.HashMap.lookup?
05:23:48 <guessWho> cocreature : it is only useful for searching with keys right ?? can we also search by values >?
05:24:04 <cocreature> oh should have read more closely
05:24:31 <cocreature> not efficiently, if you need to perform this operation somewhat regularly you are better off keeping an inverse mapping from values to keys
05:25:21 <cocreature> if you don’t care about performance, you can always use Data.HashMap.toList and then use Data.Foldable.find on the resulting list
05:25:46 <guessWho> cocreature : ok , any suggestion for another data structure which would allow this task efficiently >?\
05:26:09 <newhoggy> @cocreature: Instead of 'ghc-options: -DBMI2_ENABLED' use 'cpp-options: -DBMI2_ENABLED'
05:26:09 <lambdabot> Unknown command, try @list
05:26:10 <cocreature> I already mentioned one: just keep another Data.HashMap that maps from values to keys
05:26:14 <newhoggy> Uploading bits-extra-0.0.0.1.tar.gz... unhandled status code: 400
05:26:20 <newhoggy> Error: Invalid package
05:26:33 <cocreature> newhoggy: I was asking for the build error that you get after switching to cpp-options not the one you get from hackage
05:26:41 <newhoggy> Oh sorry.
05:26:57 <newhoggy> It's not a build error issue.  It's a runtime behaviour issue.
05:27:07 <newhoggy> I can point to the code
05:27:34 <newhoggy> Here: https://github.com/haskell-works/bits-extra/blob/c0d69c488b65dc49a52534bedc066aace9b26aef/src/Data/Bits/Pext.hs#L49
05:27:39 <guessWho> cocreature : okay thanks .
05:27:45 <sepakorayl> any updates on llvm-hs-typed ?
05:28:40 <newhoggy> I'm trying to get GHC to build the case where BMI2_ENABLED is defined, ie. fastPextEnabled = True
05:29:30 <newhoggy> It works when I use ghc-options: -D BMI2_ENABLED, but wrongly uses the False case when I specify cpp-options: -DBMI2_ENABLED
05:29:46 <cocreature> sepakorayl: what kind of updates are you looking for? the current state is on github. PRs that add missing features or fix bugs are always welcome, if you don’t want/can’t do that, make an issue and maybe somebody else gets around to it
05:30:12 <newhoggy> Somehow defined(BMI2_ENABLED) is false even if I specify cpp-options: -DBMI2_ENABLED
05:30:34 <cocreature> newhoggy: hm weird, I’ll try it out locally
05:31:08 <newhoggy> Thanks!
05:32:08 <sepakorayl> I mean how close to completion is it?
05:33:05 <cocreature> should be reasonably complete but I haven’t taken a closer look at it recently
05:36:21 <newhoggy> Oops.  I think I found a typo
05:36:42 <newhoggy> I had     cc-options instead of cpp-options
05:36:49 <newhoggy> Sorry for the mistake.
05:36:51 <cocreature> ah yeah the former only applies to c source files
05:37:43 <newhoggy> Ah.
05:37:49 <newhoggy> Thanks so much!
05:40:59 <newhoggy> Hmmm ... I'm now getting a different upload error
05:41:07 <newhoggy> Uploading bits-extra-0.0.0.1.tar.gz... forbidden upload
05:41:12 <newhoggy> Usually means: you've already uploaded this package/version combination
05:41:51 <Axman6> mcspud: https://www.youtube.com/watch?v=vGVJYoKIzjU
05:41:54 <newhoggy> I can't find it in hackage though.  Not even on the candidates list: http://hackage.haskell.org/packages/candidates/
05:41:57 <cocreature> newhoggy: is this a new hackage account?
05:42:26 <newhoggy> Oh actually.
05:42:52 <newhoggy> I think my CI account "haskellworks" attempted an upload a few days ago.
05:43:01 <newhoggy> And I deleted the candidate.
05:43:07 <newhoggy> But my local account is "newhoggy"
05:46:41 <newhoggy> It's a candidate now: http://hackage.haskell.org/package/bits-extra-0.0.0.1/candidate
05:48:49 <newhoggy> Woohoo! http://hackage.haskell.org/package/bits-extra
05:48:54 <newhoggy> Thanks @cocreature!
05:49:43 <newhoggy> @Axman6 This is the library exposing the GHC primops you helped me with earlier in the year.
05:49:44 <lambdabot> Unknown command, try @list
05:49:55 <newhoggy> Axman6 This is the library exposing the GHC primops you helped me with earlier in the year.
05:53:09 <fourroot> hola
05:53:23 <fourroot> i hate python
05:56:17 <cocreature> newhoggy: fwiw the docs builder failed because it uses GHC 8.2 with base 4.10. you can upload docs yourself if you want to ease life for your users
05:56:42 <newhoggy> That would be nice.
05:57:15 <cocreature> although it also looks like your base lower bound is unnecessary since you explicitely have CPP in your package to deal with older versions of base
05:57:32 <newhoggy> Ah ofcourse.
05:57:59 <newhoggy> I only made it work for older versions of GHC just now and already forgot about it. :D
05:58:03 <cocreature> sorry for being pedantic, I was mostly just curious about the package and noticed this while looking at the hackage page and the source :)
05:58:26 <newhoggy> I guess I have to publish a new version.
05:58:43 <cocreature> or make a revision depending on whether you’re in the “revisions are evil” camp or not :)
05:58:51 <newhoggy> Haha
05:59:09 <newhoggy> Is the revision the last number?
05:59:23 <cocreature> the revision is not reflected in the version number
05:59:28 <newhoggy> Oh.
05:59:49 <newhoggy> I didn't know of such a thing.
06:00:03 <cocreature> there is an “edit package information” button somewhere on the hackage page
06:00:12 <cocreature> there you can edit a limited amount of metadata (mostly bounds)
06:00:47 <cocreature> depending on who you ask that’s either a useful feature or the worst thing ever
06:01:12 <newhoggy> Cool!  That was easy.
06:01:23 <newhoggy> Probably both :D
06:01:44 <newhoggy> Anyway probably nobody has downloaded my package yet, so it should be fine right?  :D
06:01:53 <cocreature> sure
06:02:43 <Axman6> newhoggy: hooray!
06:02:53 <newhoggy> Yay!
06:03:15 <newhoggy> This is the GHC patch if you're curious.  https://phabricator.haskell.org/D4236
06:03:49 <cocreature> looks neat, I’ve definitely wanted something like that before
06:04:39 <newhoggy> Next up I need to change my rank-select library to use it.
06:06:46 <cocreature> newhoggy: btw if you don’t mind me asking, what exactly is haskellworks? a company or just some people that do open source together?
06:07:17 <newhoggy> Just some people :D
06:07:28 <cocreature> nice
06:07:31 <newhoggy> Myself and Alexey Raga mainly.
06:12:56 <fourroot> madarchod
06:13:06 <fourroot> :)
06:13:11 <fourroot> madarchod haskellers
06:13:20 <fourroot> madarchod = hello in indian language
06:14:11 <sm> madarchod good sir!
06:16:59 <newhoggy> Thanks again cocreature.  I'm calling it a night.  See ya!
06:17:06 <cocreature> sleep tight!
06:40:07 <ertes-w> i have a hard time imagining what a non-computable real number even looks like…  wouldn't it be impossible to compute its digits?
06:40:43 <pagnol> I keep running into the following problem and haven't found a solution I'm satisfied with yet: say, I defined some type like `data Foo = Foo { bar :: a }` and now I need to model something like `data EnrichedFoo = EnrichedFoo { bar :: a, baz :: b }`
06:42:16 <[exa]> ertes-w: ever seen a limit of type e.g. infinity/infinity where you know it will be certainly in [0,1], but can't say for sure?
06:42:37 <[exa]> *can't say any closer approximation for sure
06:43:22 <ertes-w> [exa]: something like the limit of sin(x)?
06:43:51 <ertes-w> or do you mean something that actually has a concrete limit?
06:44:06 <TMA> [exa]: can you prove it converges?
06:44:24 <[exa]> sin(x) is kindof transparent but similar
06:45:30 <frerich> pagnol: I guess 'data EnrichedFoo a b = EnrichedFoo { foo :: Foo a, baz :: b}' was already discarded?
06:45:41 <[exa]> if you were referring to the above discussion about probability, the problem there is that it is known to converge, but the size of sample that is required for the approximation to stabilize is unknown because the deeper you reach to the program space, the bigger noise it adds to your approximation
06:46:06 <pagnol> frerich, no, I'm still considering it
06:46:24 <ertes-w> [exa]: i see
06:47:15 <ertes-w> [exa]: the above discussion inspired my question, but i'm not referring to it directly
06:47:53 <[exa]> basically, if you ask 'is the limit under 0.5' then you need to take infinite input to verify it
06:47:53 <ertes-w> pagnol: are you familiar with "data types a la carte"?
06:48:00 <[exa]> which is, well, frustrating
06:48:11 <pagnol> ertes-w, no, but I'll look it up
06:48:37 <ertes-w> pagnol: the gist is: types can be composed using sums, products and functions
06:48:58 <ertes-w> pagnol: so "x enriched with y" is really just (x, y)
06:50:18 <pagnol> I found the essay, going to read it
06:50:21 <ertes-w> [exa]: i guess i can just sidestep the issue by rejecting classical mathematics =)
06:50:25 <pagnol> sounds like what I want though
06:50:41 <[Leary]> ertes-w: real numbers are can just be considered infinite sequences of 1s and 0s. Computable numbers are the super special weird case where that sequence does not actually contain infinite information, and happens to be finitely representable.
06:50:45 <frerich> ertes-w: You don't happen to have some experience with constraint programming in Haskell (or the 'csp' package in particular), do you? :-]
06:51:21 <ertes-w> frerich: nothing that goes beyond LogicT
06:51:48 <frerich> ertes-w: Huh! Never heard of that, looks interesting! Let me see...
06:52:05 <[Leary]> So a non-computable real number is just any such sequence that's "random enough".
06:52:30 <ertes-w> [Leary]: yeah, i already understand what computable numbers are…  it's just that i found myself asking: "well, these properties are sane…  what does a number that lacks them even look like?"
06:52:57 <ertes-w> frerich: it's just ListT really
06:53:18 <ertes-w> frerich: a correct and efficient lazy ListT
06:53:42 <ertes-w> (lazy in the sense that if you never search deeply enough, you won't cause the effects)
06:54:19 <frerich> ertes-w: For what it's worth, I'm making some baby-steps with constraint programming and my first self-set task is to write a Haskell program to solve the 'Zebra Puzzle' (https://en.wikipedia.org/wiki/Zebra_Puzzle) (assuming that this is a good use-case for constraint programming...)
06:54:51 <frerich> ertes-w: I found the 'csp' package which seems relevant, and my first shot (http://lpaste.net/4096544793381830656) works somewhat but I think it looks a bit messy and I have trouble expressing some of the constraints using this package, so I'm wondering if there are maybe alternatives to 'csp'.
06:54:58 <c_wraith> [Leary]: by definition, a non-computable real number would require infinite information to determine to arbitrary accuracy.  That ties in nicely with the concept of Kolmogorov complexity
06:56:23 <ertes-w> frerich: so far i've done all my searches using [], LogicT or NonEmpty
06:56:58 <ertes-w> frerich: sometimes Stream
06:57:36 <kuribas> frerich: there's this: https://hackage.haskell.org/package/monadiccp
06:57:49 <frerich> ertes-w: So have I, but for this problem I seem to have done a poor job at pruning the search space - i .e. my self-made backtracking solutions were so slow, I couldn't be bothered to wait for them to terminate. :-] So I'm looking around for whether there's a nice package which lets me just nicely encode my constraints and it'll then figure things out.
06:58:32 <frerich> kuribas: Yeah, I foudn that too (In fact, I first found the blog article on which this is apparently based, http://overtond.blogspot.de/2008/07/pre.html ). I didn't even know where to start with that package though :-(
06:59:22 <ertes-w> frerich: i don't have any experience with CP…  my approach has always been: "search everything, eliminate branches early"
06:59:57 <kuribas> ertes-w: like richard birds sudoku solver.
07:00:38 <kuribas> https://www.cs.tufts.edu/~nr/cs257/archive/richard-bird/sudoku.pdf
07:00:49 <kuribas> it also performs quite well
07:01:08 <ertes-w> frerich: and "eliminate early" is a matter of increasing the depth for the sake of bringing guards as close as possible to the root
07:02:29 <ertes-w> i.e. try to turn (do x <- c; y <- d x; guard (p x y); …) into (do x <- c; y1 <- d1 x; guard (p x y1); y2 <- d2 x y1; …)
07:03:17 <frerich> ertes-w: I think the first is what I call 'generate all, filter valid' in my mind and the second is 'prune, then search'. :-)
07:03:38 <ertes-w> frerich: note the "…"
07:03:58 <ertes-w> both might do pruning, the latter just does it better =)
07:07:25 <frerich> ertes-w: So, I'm sitting here and squinting, but I'm not sure I get the improvement which the second version brings; what's the difference between 'd1' and 'd' here? The former yields just a subset of the values returned by the latter, so the guard comes in 'earlier'?
07:10:17 <ertes-w> frerich: let's say 'd' generates 15 cases…  if you can decompose it into d1, which generates 3, and d2, which generates 5, then you will improve the performance of the guard by a factor of 5
07:11:02 <QSoftDev> Hi guys. Could you please have a look at my last question here, I need your help :
07:11:03 <ertes-w> frerich: because it basically means that the rejection patterns of the guard always looked like this:  AAAAArrrrrAAAAA (accept 5, reject 5, accept 5)
07:11:03 <QSoftDev> https://gitter.im/haskell-chat/beginners?source=orgpage
07:11:44 <ertes-w> frerich: after the decomposition it can reject whole groups without ever generating the individual members
07:12:04 <ertes-w> frerich: it also performs better for the groups it accepts, because the pattern now looks like this:  ArA
07:12:38 <ertes-w> frerich: in reality you might more likely turn something like AAAAAAArrrrrAAA into ArA
07:17:59 <metahumor> QSoftDev: regarding the "open source projects" to study these things, since it looks like you're already familiar with syntax
07:18:17 <metahumor> QSoftDev: i'd suggest "data61/fp-course"
07:19:09 <metahumor> QSoftDev: which will have you write all the instances for Functor, Applicative, Monad for lots of important things like State, StateT, Writer
07:19:12 <saksham> QSoftDev: For funcPure1, how about: Monad m => ExceptT Text m Int ? This is similar to your funcPure2 thing.
07:19:14 <dminuoso> QSoftDev: You can gain some flexibility by using MonadTrans
07:19:30 <metahumor> QSoftDev: that'll give you a lot of experience sensing how to work with monad transformers
07:20:56 <metahumor> QSoftDev: regarding question 2, what would the type sig of that pure function be? something like "pureFuncWoIO :: Monad m => ExceptT Text (KatipContextT m Int)"?
07:21:07 <QSoftDev> metahumor: thanks, I will look it up!
07:22:32 <QSoftDev> saksham: ok, but how do I call funcPure1 from myFunction and short circuit on error without branching with "case of" ?
07:24:09 <QSoftDev> metahumour: funcPure2:: Monad m => T.Text -> ExceptT a (ReaderT b (StateT c (KatipContextT m))) d
07:24:30 <QSoftDev> metahumour: basically I don't understand how to compose monad transformers in different shapes
07:25:36 <QSoftDev> dminuoso: Could you elaborate, please?
07:26:51 <dminuoso> QSoftDev: I recommend implementing monad transformers yourself (do the whole range of them: ReaderT, StateT, ContT, WriterT, ExceptT, LogicT)
07:26:57 <dminuoso> QSoftDev: Like metahumor suggested.
07:27:12 <QSoftDev> dminuoso: ok
07:27:40 <dminuoso> Try to avoid ListT, because that one is actually rather tricky to do right since the naive implementation is incorrect
07:28:41 <saksham> QSoftDev: Here's a simple example. http://lpaste.net/363560
07:28:58 <saksham> Basically, there are two cases.
07:29:10 <saksham> QSoftDev: First case: If funcPure1's monad (in this case, ExceptT) is your top monad in your monad transformer stack (think of monads like layers, when using Monad Transformers). In this case, you can directly use it. Like the example I pasted above.
07:29:57 <saksham> In the other case, if funcPure1's monad is buried under 'n' layers of other monads, you will need to write 'lift $ lift $ lift ...', n such lifts.
07:30:24 <saksham> If funcPure1's monad is IO though, you can use liftIO, which can handle variable number of lifts automatically.
07:31:38 <saksham> QSoftDev: Had a typo in the example. Please refresh.
07:32:12 <QSoftDev> saksham: thanks! I am going to try it out now :)
07:33:12 <QSoftDev> thanks guys
07:33:41 <saksham> QSoftDev: Added a few more things to the example to illustrate liftIO.
07:38:04 <metahumor> woah this new "quick jump" in hackage is great
07:38:49 <dminuoso> metahumor: What's that?
07:39:04 * geekosaur mutters at HAL 9000 ref... plot point was specifically common misconception vs. reality that if a computer is complex enough, it has all the problems humans have. including psychoses.
07:39:05 <metahumor> QSoftDev: a caveat -- "liftIO" is only available if you are using "mtl" style transformers
07:39:46 <geekosaur> (and, psychoses don;t require sentience, just sufficient complexity to lead to mismatches between internal maps/programming and reality)
07:40:04 <dminuoso> geekosaur: Does that mean, the computer will have an existential crisis when it ponders about the morality of creating computers with a conscience?
07:40:17 <metahumor> dminuoso: check out https://hackage.haskell.org/package/mtl, it has a "Quick Jump" js applet for quick in-package search
07:40:22 <saksham> metahumor: https://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-IO-Class.html
07:40:36 <saksham> Transformers also seems to have it.
07:40:37 <geekosaur> hal9000's specific problem was programming conflict between military and scientific mission goals, iirc.
07:41:09 <geekosaur> but that's hard to show in movie form; it was clearer in the novelization
07:41:40 <QSoftDev> saksham: yes, I use "transformers" and liftIO works
07:42:07 <metahumor> saksham: the most recent versions of transformers don't export MonadIO or liftIO in the index
07:43:51 <saksham> metahumor: Indeed ! I did not notice this, and somehow a MonadIO google search always brought the transformers one up. Guess I'll migrate some of my code now :)
07:44:38 <saksham> metahumor: would you happen to know the reason for this change?
07:45:36 <metahumor> saksham: afaict the typeclass based approach is now all in mtl
07:45:44 <metahumor> saksham: while transformers is all about explicit "lift"
07:46:19 <saksham> interesting. good to know.
07:46:23 <metahumor> specifically, "mtl" is typeclasses+fundeps
07:46:34 <geekosaur> or more specificlly to make it compatible with a type families approach instead of fundeps
07:46:44 <metahumor> there were attempts at making "mtl-typefamilies" but that petered out i think
07:47:21 <geekosaur> monads-tf is still actively maintained, I think. or was until fairly recently
07:47:49 <geekosaur> there is still some hope that a type families-based mtl will be done, but there are backward compatibility issues iirc
07:48:08 <geekosaur> (and there was an abortive mtl-tf but I think it died over those compat issues)
07:48:16 <metahumor> "monads-tf": UploadedWed Jun 8 16:55:01 UTC 2016
07:48:41 <dolio> Why would you make another package instead of monads-tf?
07:48:47 <metahumor> "mtl-tf": UploadedTue Jan 23 17:19:19 UTC 2018
07:48:47 <geekosaur> hm, thought it was more recently updated than that (like last year)
07:48:53 <Psybur> Anybody recommend a good article on test driven haskell development?
07:49:45 <geekosaur> ok, so maybe that got reversed. which would be good for eventual migration
07:49:57 <dolio> I think the main problem is that everything depends on mtl, and getting everyone to switch is hard.
07:50:07 <geekosaur> in general the type theory folks want type families to replace fundeps
07:50:16 <dolio> And if not everyone switches,  you end up with multiple sets of classes with the same name and stuff.
07:51:19 <QSoftDev> which do you prefer: 1. "IO (Except T.Text ClientHooks)" or 2. "ExceptT T.Text IO ClientHooks" if my monad stack is "ExceptT a IO b" ?
07:52:26 <Psybur> Is tasty the 'in' testing framework at the moment?
07:53:09 <cocreature> Psybur: tasty or hspec
07:53:20 <cocreature> usage seems to be split somewhat equally
07:53:55 <dminuoso> QSoftDev: Writer monad transformers. =)
07:54:00 <dminuoso> *Write! :|
07:57:53 <freeman42x> is there some HSpec setting to show the parameters for which the test failed? eg. http://lpaste.net/363569 is just showing: expected False but got True, with no details of which test failed
07:58:45 <dminuoso> freeman42x: Use it blocks and include some string representation in the title for it
08:00:55 <dminuoso> freeman42x: Is it possible to use a property instead?
08:02:45 <ertes-w> honestly i prefer the fundep-based mtl over TF-based ones
08:02:46 <cocreature> you could probably use "shouldSatisfy" instead but really just separate tests using "it" are the better solution
08:03:51 <freeman42x]NixOS> dminuoso, cocreature so, something like: it "\"abba\" `shouldBe` False" $ do ?
08:04:01 <ertes-w> the only issue with the fundep-based mtl is that for whatever reason FlexibleContexts, FlexibleInstances, MultiParamTypeClasses and FunctionalDependencies are still not standard in 2018
08:05:09 <cocreature> freeman42x]NixOS: "it "abba" $ "abba" `shouldBe` False
08:05:13 <dminuoso> freeman42x]NixOS: More like `let a = "abba" in it "with: " ++ quote a $ ...`
08:06:06 * freeman42x]NixOS gets sweat drops.
08:06:20 <ertes-w> i remember how disappointed i was about how h2010 turned out…  the differences to h98 are hardly worth mentioning for the average user
08:06:56 <cocreature> ertes-w: TF are not standard either, so …
08:06:56 <w1n5t0n> hi all, is it possible to force Haskell/GHCi to an expression like "2 + 0.5 * sin t" as "2 + (0.5 * (sin t))"?
08:07:14 <ertes-w> cocreature: yes, and they should be standard, too
08:07:14 <w1n5t0n> ..to interpret* an expression
08:07:25 <Tuplanolla> That's what it already does, w1n5t0n.
08:09:51 <dminuoso> freeman42x]NixOS: ideally each `it` represents a single case you are testing
08:11:35 <w1n5t0n> Tuplanolla: hmm strange, I had some trouble getting it to work with slightly more complex equations. Can I separate them on multiple lines so that I can then do something like: 2 + 0.5 \n * sin $ t + 10 \n * sin $ 2*t?
08:12:17 <Tuplanolla> Yes, but you need the indentation to increase.
08:12:32 <freeman42x]NixOS> dminuoso, getting some weird stuff here, on the test it says should be True but on the right it says expected False https://i.imgur.com/SnBOK2F.png
08:13:21 <dminuoso> freeman42x]NixOS: so each `shouldBe` is an expectation.
08:13:23 <freeman42x]NixOS> dminuoso, I got that, 1 it per test case, but the let, quote, etc. didn't, quote is not in scope and not sure which it is or what it does
08:13:25 <dminuoso> freeman42x]NixOS: each `it` is an actual test.
08:13:32 <dminuoso> freeman42x]NixOS: the entire test fails, because _some_ expectation failed.
08:13:44 <dminuoso> freeman42x]NixOS: but hspec only describes up to your "it"
08:14:34 <Tuplanolla> % :seti -XTemplateHaskell
08:14:34 <Tuplanolla> % import Language.Haskell.TH
08:14:34 <Tuplanolla> % runQ [| 2 + 0.5 * sin t |] -- You can inspect how expressions are parsed by doing this, w1n5t0n.
08:14:35 <yahb> Tuplanolla:
08:14:35 <yahb> Tuplanolla:
08:14:35 <yahb> Tuplanolla: InfixE (Just (LitE (IntegerL 2))) (VarE GHC.Num.+) (Just (InfixE (Just (LitE (RationalL (1 % 2)))) (VarE GHC.Num.*) (Just (AppE (VarE GHC.Float.sin) (UnboundVarE t)))))
08:14:37 <freeman42x]NixOS> dminuoso, ah, sorry, it is obvious now. Thank you! I should mention to who wrote these cases to update them, the exercise was pretty hard in itself, made even harder but not knowing what failed
08:14:40 <dminuoso> freeman42x]NixOS: wrap each expectation inside a single `it`
08:15:15 <dminuoso> freeman42x]NixOS: the idea of "let" is just to ensure that whatever you are feeding into the expectation is also what you are testing. It's easier to screw up if you duplicate strings.
08:15:53 <dminuoso> freeman42x]NixOS: perhaps its more helpful if you rename the descriptions
08:16:47 <dminuoso> freeman42x]NixOS: describe "solve" $ do ... it "should work for abba" $ solve "abba" `shouldBe` False
08:18:04 <w1n5t0n> Tuplanolla: that's exactly what I was looking for, thanks!
08:18:40 <dminuoso> freeman42x]NixOS: you can then use "context" to group things semantically together
08:19:11 <dminuoso> freeman42x]NixOS: for example: describe "solve" $ do ... context "with strings" $ it "should do the right thing" $ ...
08:19:19 <freeman42x]NixOS> dminuoso, I understand, thank you
08:20:35 <dminuoso> (though context is just describe, but that's the convention from rspec)
08:20:40 <frerich> ertes-w: Thanks a ton for bringing up that [] often just works. I don't know why I gave up so quickly on it, I just re-did my solution but this time took some care to arrange the generators such that I can 'guard' as early as possible - and now it was really easy to figure out the solution (and it's less code, and very fast, too). :-)
08:21:39 <frerich> ertes-w: FWIW, my final submission (this is part of some puzzle posed by the 'exercism.io' page) is http://exercism.io/submissions/775df9179cc94ec09ba18543c2613b8c :-)
08:21:58 <frerich> ertes-w: (The task was to implement the 'solve' function, the type 'Solution' was given already)
08:23:11 <ertes-w> frerich: the only issue i have with [] is that you can't display progress…  that's why i lean more towards LogicT and friends for expensive searches
08:23:45 <ertes-w> frerich: and of course the only reason i'm bringing this up is to shamelessly promote my 'progress-meter' package =)
08:23:54 <frerich> ertes-w: HA! :-)
08:24:12 <ertes-w> it's really cool, you should try it ;)
08:26:32 <frerich> ertes-w: If only I had a good use-case :-)
08:29:36 <ertes-w> frerich: just make the search space larger and perhaps do multiple searches concurrently =P
08:32:15 <frerich> ertes-w: I guess I could use `async` to search concurrently, just in case I may have missed a solution the first time around, yeah. :-)
08:33:22 <ertes-w> =)
08:34:26 <ertes-w> oh, and do you know what's a great dev helper package for writing concurrent stuff?  rapid =P
08:34:29 <ertes-w> ok, i'll stop =)
08:45:04 <dminuoso> Is there a way to have lower case type families?
08:47:20 <lyxia> no
08:48:00 <elpfen> dminuoso: rewrite the syntax rules :)
08:48:17 <Tuplanolla> You could do that with the `CPP` extension or by switching to Idris, dminuoso.
08:49:19 <Tuplanolla> By the time you get them, you will have forgotten why you wanted them in the first place.
08:52:03 <dminuoso> Heh.
08:52:38 <dminuoso> Tuplanolla: Oh it was just a random thought. It occured to me, that in the value system I had lower case variables, and with ExplicitForAll it seems almost reasonable to be able to differentiate
08:55:14 <Welkin> it seems that there is no way to load/use fonts with gloss
08:55:26 <Welkin> nor is there a way to add music or sound
09:00:08 <dminuoso> Is there some typical framework one would pick if he needed a simplistic miniature web framework to make a simple API for a microservice?
09:01:30 <Welkin> dminuoso: servant
09:01:51 <Welkin> dminuoso: this is a buzzword free zone! I don
09:02:00 <Welkin> dminuoso: this is a buzzword free zone! I don't want to see you mention "microservice" again!
09:02:14 <pavonia> I also liked Happstack, not sure if this is still a thing
09:02:33 <Welkin> servant is specifically made for implementing web APIs
09:04:13 <dminuoso> pavonia: thats way too thick for my taste
09:04:31 <dminuoso> Scotty might fit my bill
09:04:58 <Welkin> scotty is not really made for that
09:05:09 <Welkin> scotty works better for small/simple websites
09:05:17 <Welkin> servant is special-made for apis, like I said
09:07:04 <alp> scotty/spock are the most lightweight options indeed. if you need to talk to the applications from JS or some other haskell code and what not, servant offers some advantages. if you just want to toy around for now or write a small web app to solve a problem and call it a day, spock/scotty are much simpler to approach and would seem better suited :)
09:07:34 <alp> servant isn't really "thick" though. it uses fancy techniques, but it's only a rather small/thin layer on top of wai
09:07:47 <alp> well, servant-server, that is.
09:19:16 <tdammers> fwiw, scotty doesn't really add much on top of plain WAI, so you might also consider just programming against that
09:20:06 <tdammers> I did that quite a bit, and it's not uncomfortable at all once you have a small handful of utility functions in place and know your way around
09:22:58 <dminuoso> Well my requirements are rather simplistic. It's going to be be 4-5 endpoints total.
09:31:04 <oak-> Yesod might also be something to consider, it feels slightly more mature than servant. Although I think the approach servant has taken is slightly cleaner.
09:31:29 <Welkin> yesod is not suitable for a web api
09:31:42 <Welkin> it is great if you want to build a content management system or a huge member-based website
09:31:52 <tdammers> -ish
09:31:53 <Welkin> I used it in many projects
09:32:24 <tdammers> yesod suffers from many of the problems you typically encounter in monolithic "everything and the kitchen sink" style frameworks
09:32:51 <Welkin> I have also grown to dislike the TH-based html/css/js template languages
09:32:54 <Welkin> I prefer combinators
09:33:08 <tdammers> as long as you use the framework the way it was intended, all is peachy, but when you run into things that the creators didn't anticipate, you find yourself in a world of pain
09:33:25 <tdammers> and yes, it's very heavy on the TH
09:33:28 <tdammers> too heavy if you ask me
09:33:29 <alp> tdammers, for the record, we were using scotty at Zalora until we came up with servant =) it was working okay, but deriving client functions became a necessity given the huge number of endpoints we had to hit. constructing requests by hand was not an option =)
09:33:36 <Welkin> and I found myself trying to work around the built-in helpers for prcoessing forms, because they were too restrictive
09:33:56 <tdammers> alp: yeah, once you hit that level of complexity, or even just size, scotty isn't powerful enough
09:34:08 <Welkin> I ended up writing a huge amount of boilerplate to use the form helpers in a custom way, when I should have just thrown it out altogether and processed the forms myself
09:34:17 <Welkin> so yes, it gets in the way if you want to do anything nontrivial
09:34:37 <tdammers> alp: particularly, not really lifting routes and endpoints and resources into first-class data structures or types becomes problematic
09:38:15 <bas080> scotty doesn't know that form and me do it every workday in the office
09:38:58 <alp> tdammers, yeah. the 'rest' libraries by Silk (IIRC) were the closest we had, but not quite good enough, so we went ahead and tried something else
09:39:00 <Welkin> if you have never used any of these web libraries, start with wai/warp, then use scotty, then use servant
09:39:17 <Welkin> if you start with servant right away, you will be confused
09:40:07 <tdammers> alp: I started writing one of my own at one point, but got distracted... but it did serve as a prototype for a python library that ended up working really well (for python standards, that is)
09:40:54 <tdammers> alp: idk, type-level programming feels a bit awkward and crippled compared to term-level, at least in Haskell, and servant does quite a lot of type-level stuff
09:41:59 <alp> yeah it does, but going type level was the result of considering a few hard requirements that we had
09:42:24 <sl2c> alp: what requirements?
09:44:34 <alp> so we needed a description of APIs (webservice or web application in general), because without that you cannot "compute" client functions (and do all the other things servant does) to hit such an API without it. we also wanted the description "DSL" to be extensible, so that we could experiment with new constructs in our projects and have them bubble up in the core packages or separate packages if useful enough. also to allow people to make
09:44:34 <alp> different choices than us.
09:45:20 <gammastorm02> hey
09:45:25 <alp> we also wanted the description to affect the types of the client functions and "expected types for the handlers". if you change the response type from String to (), but don't change your handler implementation, the code should not compile.
09:45:31 <gammastorm02> need review for a fractal generator
09:45:47 <gammastorm02> willing ?
09:45:48 <gammastorm02> anyone ?
09:45:51 <alp> extensibility + description affects types led us to give a shot at having descriptions at the type level
09:46:25 <alp> as you can't just have a GADT with all the constructs, carrying some extra information for deriving client functions etc
09:47:25 <cocreature> gammastorm02: just post your code and stick around for a bit
09:47:39 <gammastorm02> https://gammastorm.github.io/
09:47:46 <cocreature> gammastorm02: if you have some specific questions you are probably more likely to get answers than asking for a general review
09:47:47 * alp doesn't remember if we covered this in http://alpmestan.com/servant/servant-wgp.pdf
09:48:20 <gammastorm02> cocreature, don't know, not experienced with asking
09:48:21 <cocreature> gammastorm02: do you want people to review the UX instead of the code or why are you not linking to the code?
09:48:36 <gammastorm02> cocreature, both cases
09:49:02 <alp> hmm looks like we briefly mention it in section 7.1
09:49:26 <cocreature> gammastorm02: is this even implemented in Haskell? this looks like javascript
09:50:34 <gammastorm02> cocreature, I must applogize for the incident, but haskellers are the only intelligent ones for me, and the only ones who answer
09:51:05 <cocreature> gammastorm02: I’m sorry but this channel is about the Haskell programming language. asking for a review of a javascript codebase is clearly offtopic
09:51:42 <gammastorm02> cocreature, okay sorry sorry sorry
09:52:14 <Tuplanolla> We do have #haskell-offtopic, but JavaScript isn't a crowd favorite there either.
09:52:36 <sepakorayl> how do I approach digging into ghc internals?
09:53:11 <cocreature> sepakorayl: take a look at https://ghc.haskell.org/trac/ghc/wiki/Newcomers and the links there
09:53:17 <cocreature> in partiuclarly the commentary can be quite helpful
09:53:30 <cocreature> #ghc is also a helpful channel if you have questions
09:53:40 <alp> sepakorayl, there are a bunch of papers (https://ghc.haskell.org/trac/ghc/wiki/ReadingList), there's the commentary (https://ghc.haskell.org/trac/ghc/wiki/Commentary), comments in the source code and #ghc
09:54:06 <alp> oh well, cocreature beat me to it
09:54:08 <alp> =)
09:54:15 <Welkin> sepakorayl: there is also https://github.com/quchen/stgi
09:54:26 <sepakorayl> nice!
09:56:32 <Welkin> what is a good book for learning compilers?
09:56:45 <Welkin> (not the dragon book)
09:57:26 <tdammers> alp: bit of a different philosophy, I guess - I'm leaning towards "hard components, soft interfaces", but there's also "hard components, hard interfaces"
09:58:12 <tdammers> (and for completeness, "soft components, soft interfaces", which is kind of bad and stupid, but the whole web dev crowd loves it, and "soft components and uselessly hard interfaces", which you sometimes see in PHP land)
09:58:18 <benzrf> lool
09:58:24 <Welkin> what does that even mean?
09:58:31 <Welkin> "hard" and "soft"
09:58:37 <tdammers> "soft" means "untyped / semityped, forgiving, lenient"
09:58:51 <tdammers> "hard" means typed in some sense
10:00:17 <alp> tdammers, well keep in mind that we want to derive client functions, wanted to from day 0. ideally, you let the client deal with the very same types that the server-side handler is going to deal with. the fact that this all gets encoded in the HTTP request while the data travels is mostly irrelevant to us, we really wanted something that would _prevent_ us from getting any client request wrong
10:00:34 <alp> it's a lot harder to achieve with soft interfaces no?
10:00:39 <alp> if I understand your definitions correctly.
10:01:38 <sepakorayl> I am also interested in a good compiler book following modern principles
10:03:59 <tdammers> alp: well, yes; with soft interfaces, you need to take an entirely different route
10:04:16 <merijn> Sadly, despite TAing compiler construction for the 5th year in a row, I don't really know a good modern compiler book >.>
10:04:27 <tdammers> the idea there is to make both ends lenient enough to allow for a reasonable degree of drift / slack in the interface
10:04:42 <merijn> We have a list of several books on the course website, but in all honesty we don't actually use any of them for the course
10:04:51 <Welkin> merijn: people seem to recommend the book by Appel that uses ML
10:04:58 <Welkin> that is now 14 years old though
10:05:03 <merijn> Welkin: Yeah, I've heard that it's good
10:05:23 <Welkin> there are so many terrible textbooks that it is hard to find a good one on any subject
10:05:37 <merijn> Welkin: Well, one question to ask yourself is what sorta compiler are you interested in? Highly optimising machine code, or high level abstract code and DSLs?
10:05:57 <Welkin> I have never studied compilers yet
10:06:07 <Welkin> I never took the course in uni (it used the dragon book)
10:06:14 <MacSlow> Greetings everybody!
10:06:35 <Welkin> I am definitely more interested in writing my own language
10:06:47 <Welkin> less than the low level details of optimising machine code
10:06:50 <Welkin> at least right now
10:06:59 <Psybur> >>= is pronounced giggity change my mind
10:07:07 <Welkin> if I really wanted to write my own language, I would probably start by writing one using racket
10:07:34 <merijn> Welkin: If the course used the dragon book it's probably wasting way too much time on parsing anyway
10:07:50 <cocreature> depending on your interests, something like tapl might be way more relevant and interesting than a classic compiler book
10:07:59 <benzrf> i rly need to read tapl
10:07:59 <merijn> ^^ that too
10:07:59 <Welkin> I have TaPL
10:08:00 <benzrf> or maybe pfpl
10:08:16 <Welkin> but I haven't brought myself to read past chapter 1
10:08:44 <Welkin> chapter 2*
10:10:01 <ggVGc> "making a language" has a very broad spectrum of meanings, imo. The tool to use, for me, depends highly on what the main added value for this new language is. It could be heavily syntax-focused. E.g the main point being to create a syntax that perfectly matches a specific domain, e.g maybe using some kind of ascii art to describe a certain domain much better
10:10:14 <ggVGc> or it could be focused heavily on types, in which case maybe the syntax doesn't matter so much
10:10:35 <cocreature> merijn: I never got the obsession with parsing. it’s just so incredibly boring
10:10:50 <ggVGc> or it could be to target a specific type of target, e.g some specialised hardware, in which case maybe the language itself doesn't matter as much as the compiler and runtime library
10:10:53 <Welkin> if you use lisp, you don't have to do any parsing at all :D
10:10:57 <Welkin> it's already an AST
10:11:00 <ggVGc> all of these would make me pick vastly different tools
10:12:12 <sepakorayl> merijn: btw I am interested in ensuring compiler correctness, are you aware of anything relevant? I am currently trying to make use of dependent types to encode contexts in eg renaming and type rules.
10:12:15 <ggVGc> I would say desigining a language, and making a compiler are fairly separate tasks
10:13:32 <alp> sepakorayl, Graham Hutton has done some research about "calculating" correct compilers, this might be of interest even though it's not exactly the kind of thing you're alluding to here.
10:13:53 <ggVGc> if you want a strong type system and enforcing certain constraints for your compiler, that can all be implemented in whatever already existing language by essentially writing an embedded DSL and running your program to get the output
10:14:02 <ggVGc> no need to make a lexer and parser
10:15:41 <ggVGc> If I was making a new stronly typed language, I would probably just write ASTs manually for a long time before I ever created any language-specific syntax
10:16:56 <sepakorayl> aren't lexers and parsers trivial with modern parser combinators?
10:17:27 <ggVGc> sepakorayl: that's not the point, in my opinion. I think it's better to figure out the core parts of what you're making before you start inventing shorthand ways of writing it
10:17:50 <CodeKiwi> there's a lot of cool stuff by graham hutton here http://www.cs.nott.ac.uk/~pszgmh/bib.html
10:20:39 <Welkin> I haven't read this yet, but it's probably where I will start https://beautifulracket.com/
10:29:43 * virgin
10:30:16 <dolio> cocreature: When you write everything in C, parsing seems like a much more difficult problem. :)
10:31:10 <sternmull> is there something like a "default bracket"? I mean a bracket function that uses a default cleanup action. Like the "with" statement in python.
10:31:44 <shapr> Showing off Haskell parsers to C coders feels almost unfair
10:32:05 <cocreature> dolio: heh fair point although even in C it becomes boring rather quickly imho.
10:32:21 <dminuoso> shapr: I dont know, I can respond with showing you a f.yy file!
10:32:40 <shapr> what's that?
10:32:45 <shapr> show me!
10:32:46 <dminuoso> A bison file.
10:32:56 <virgin> please advice how to solve this. please do not give me a solution. just a hint. this is the question: »» Define a function balance :: [a] -> Tree a that converts a non-empty list into a
10:32:57 <virgin> balanced tree. Hint: first define a function that splits a list into two halves whose
10:32:57 <virgin> length differs by at most one. i did this function and it is working. i don't know how to solve the main task
10:33:17 <jle`> virgin: what is your tree data type?
10:33:29 <virgin> ah second
10:33:38 <cocreature> dminuoso: don’t worry, happy files are almost as pretty as bison files
10:33:40 <virgin> data Tree a = Leaf a | Node (Tree a) (Tree a)
10:34:01 <geekosaur> @hoogle withFile
10:34:02 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
10:34:02 <lambdabot> Filesystem withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a
10:34:02 <lambdabot> Pipes.Safe.Prelude withFile :: (MonadSafe m) => FilePath -> IOMode -> (Handle -> m r) -> m r
10:34:05 <shapr> dminuoso: looks rather verbose: https://www.gnu.org/software/bison/manual/html_node/A-Complete-C_002b_002b-Example.html
10:34:55 <jle`> virgin: try handling the cases where your two halves are empty, one has one item, or if they both have many items
10:34:57 <dminuoso> shapr: Bison grammar is just raw pseudo BNF.
10:34:57 <jle`> virgin: using pattern matching
10:35:10 <jle`> sort of like how you'd implement map
10:35:13 <jle`> or zip
10:35:22 <dminuoso> cocreature: Ah cool. Happy is what GHC uses, no?
10:35:23 <virgin> jle`: thanks!
10:35:28 <cocreature> dminuoso: yep
10:35:37 <jle`> virgin: yeah, look at the syntax and pattern of the source of 'zip', it might be helpful here
10:35:39 <cocreature> dminuoso: alex/happy is Haskell’s flex/bison equivalent
10:35:50 <jle`> virgin: or if you don't want to be spoiled, try to implement 'zip'
10:35:57 <jle`> and see if you can use that to implement your tree-ing function
10:36:03 <jle`> er, if you can use the same techniques, i mean
10:36:34 <virgin> jle`: i think in the past i implement it :-)
10:36:36 <sternmull> geekosaur: I am looking for a more general version, something that could be used like this "with (myFileOpeningFunction myFilename) \h -> doSomethingWithThatHandle h". And the same for a process-handle, manually allocated memory block and so on.
10:36:47 <virgin> a long ago
10:36:54 <cocreature> although I very rarely bother using those. the ergonomics of parser combinators are just so much better that I’m usually willing to pay the costs of having to left-factor my grammar
10:37:28 <dminuoso> shapr: https://gist.github.com/codebrainz/2933703#file-c99-y this is an example of a bison file to parse C itself with.
10:37:39 <geekosaur> sternmull, when you hve an interpreter that keeps track fo that automagically behind the scenes, or some mechanism to force all of those to be "the same thing" (the more you do this, the less you can do *with* it), you can have such a generic function
10:38:38 <sternmull> geekosaur: So i think i am looking for a typeclass "class HasCleanup a; cleanup a -> IO ()" and a "with"-function that uses it.
10:38:55 <cocreature> dminuoso: https://github.com/visq/language-c/blob/master/src/Language/C/Parser/Parser.y and here’s the happy version :)
10:39:37 <geekosaur> there is ResourceT. butI suspect you are still expecting magic, or at least "someone already built this for me for every use case I care about so I don't have to know what I'm doing"
10:39:45 <barrucadu> @type \acquireRelease use -> bracket acquireRelease fst (use . snd) -- this could be a building block for a 'with'
10:39:46 <lambdabot> IO (IO b1, b2) -> (b2 -> IO c) -> IO c
10:39:47 <dminuoso> cocreature: Oh that doesn't look much differently, though it seems that semantic rules are way easier to manage than with bison
10:40:26 <geekosaur> it only works that way when an interpreter is involved and managing all the resources for you behind your back anyway, and your only influence is giving it hints as to when it can free stuff early
10:41:06 <dminuoso> cocreature: How is this implemented? Is there a preprocessor involved, or is this some deep TH magic?
10:41:23 <cocreature> dminuoso: just a preprocessor so quite similar to bison
10:41:35 <cocreature> with all the usual problems that come with that ;)
10:41:48 <Welkin> you sure love that word "magic"
10:41:51 <Welkin> nothing is magic
10:42:11 <dminuoso> Welkin: magic is my universal term for "Boy I have no explanation for this"
10:42:14 <Welkin> the only thing that even comes close is quantum physics
10:42:36 <Welkin> yeah, I understand what you mean
10:42:41 <Welkin> but don't call it that
10:42:58 <Welkin> it is the god of the gaps
10:43:02 <dminuoso> Very well, I will adopt the word wizardry instead.
10:44:10 <virgin> jle`: the problem is that in zip i have two lists to the function. here in "balance" function i just have one list. i don't know how i managed this list as two lists (even though i have the function that splits a list into tuple of two lists)
10:46:00 <MacSlow> I have an Int value, which I want to use in a floating-point division... how can I create a temp. local float-value based on that Int-value?
10:46:00 <MacSlow> I thought I could use fromInteger for that, but somehow don't seem to recall how to correctly use that.
10:46:00 <MacSlow> Thanks in advance!
10:46:35 <lyxia> fromIntegral
10:48:15 <sepakorayl> intuitively, do invariants expressed in the type system inhibit reusability?
10:49:59 <Myrl-saki> @pl flip fmap
10:49:59 <lambdabot> flip fmap
10:50:02 <Myrl-saki> eh
10:52:30 <dminuoso> sepakorayl: The type systems entire existence is justified by expressing invariants.
10:52:32 <metahumor> % :t (<&>)
10:52:32 <yahb> metahumor: Functor f => f a -> (a -> b) -> f b
10:52:38 <Myrl-saki> metahumor: Lmao.
10:52:38 <metahumor> ^^ Myrl-saki
10:52:47 <Myrl-saki> metahumor: Thanks. I find that funny.
10:52:48 <mnoonan_> sepakorayl: they inhibit incorrect reuse..
10:52:56 <Myrl-saki> metahumor: $ is to &, huh. :P
10:53:01 <Myrl-saki> Err
10:53:10 <Myrl-saki> <$> is to <&>, as $ is to &
10:53:26 <Myrl-saki> :i (<&>)
10:53:50 <metahumor> Myrl-saki: it's from Control.Lens
10:53:53 <dminuoso> :t (&)
10:53:55 <lambdabot> a -> (a -> b) -> b
10:54:03 <sepakorayl> more specifically if we have an Ast family of mostly similar shape
10:54:46 <sepakorayl> but different kind parameters on the type constructors used to express invariants
10:55:14 <sepakorayl> and some extra constructor arguments carrying proofs
10:55:35 <sepakorayl> is there any way to abstract over the asts' shape ?
10:55:53 <sepakorayl> not sure if I make sense
10:56:02 <sepakorayl> I most likely don't
10:57:00 <sepakorayl> say Expr = IntExpr | BoolExpr | Add Expr Expr and data Expr a where IntExpr :: Expr Int, BoolExpr :: Expr Bool, Add :: Expr a -> Expr a -> Expr a
10:57:58 <sepakorayl> can we write a type that can describe both untyped and typed variants without "duplication" ?
10:58:10 <sepakorayl> although I suspect this doesn't count as duplication
10:58:34 <AWizzArd> https://news.ycombinator.com/item?id=16567062
10:58:51 <dminuoso> sepakorayl: datakinds
10:59:30 <sepakorayl> dminuoso: can you elaborate?
11:06:14 <lyxia> sepakorayl: http://lpaste.net/363583
11:07:15 <sepakorayl> thanks!
11:07:25 <sepakorayl> this is pretty good
11:08:11 <sepakorayl> I think I can now create just the final typed ast and then add the constraints as I go
11:18:03 <sepakorayl> still not sure how to encode proof terms
11:18:17 <sepakorayl> turn them to Void ?
11:18:41 <infandum> In https://github.com/ocramz/sparse-linear-algebra/blob/master/src/Data/Sparse/SpMatrix.hs for matMatUnsafeWith in dott, when compiled is that "sum" optimized to not take up space / lots of time?
11:26:43 <lyxia> sepakorayl: what are you talking about
11:28:53 <metahumor> Refl?
11:30:17 <sepakorayl> lyxia: in the end asts there are some constructors similar to the previous ones that also contain proofs
11:30:37 <sepakorayl> I was thinking how to erase them in the previous stages
11:30:42 <sepakorayl> but the same should apply
11:33:36 <lyxia> you can define more type families on the phase index
11:33:56 <lyxia> sepakorayl: that's basically what's in the Trees that grow paper
11:36:48 <jle`> virgin: name the two lists
11:36:50 <jle`> and work on those
11:37:12 <jle`> mkTree xs = mkTreeFromTwoLists ys zs
11:37:14 <jle`>   where
11:37:21 <jle`>     (ys, zs) = splitListIntoTwoLists xs
11:40:22 <virgin> jle`: i think i succededd :-)
11:40:36 <jle`> congrats :D
11:41:52 <virgin> but it is very strange. i manage to solve some problems without understanding them fully. it is just a feeling it maybe will work and it is very strange
11:42:21 <jle`> that cna be the case in haskell sometimes, where often "if it compiles, it works"
11:43:09 <virgin> can i take a screen shot for you to look at my solution? :-)
11:44:02 <cocreature> @where lpaste
11:44:02 <lambdabot> http://lpaste.net/
11:44:11 <cocreature> virgin: use that instead of taking a screenshot
11:44:27 <virgin> ah ok
11:45:15 <Welkin> take a snapshot with your phone's camera
11:45:20 <Welkin> and fax it over
11:45:27 <Welkin> print it out, and fax it over
11:45:30 <EvanR> write a GUI in visual basic
11:48:33 <catern> hmmm
11:49:30 <catern> i'm a haskell novice, but here is a question about type classes
11:49:47 <virgin> jle`: i did it in paste bin :-)
11:49:50 <virgin> https://pastebin.com/ACCJMEdv
11:51:53 <catern> are there any papers about "runtime" type classes? for example: perhaps I have some typeclass C, and I only can actually create C typeclasses at runtime (perhaps using runtime information, or connecting to some remote server)
11:52:31 <catern> (and I'd create the typeclass as a local typeclass)
11:52:59 <catern> the main interesting thing is the idea of a typeclass that can only be created at runtime, other than that it's mostly the same idea as local typeclasses
11:53:21 <geekosaur> types don't exist at runtime, therefore typeclasses likewise don;'t exist (except as dictionaries of functions)
11:53:44 <EvanR> https://www.schoolofhaskell.com/user/thoughtpolice/using-reflection
11:53:45 <geekosaur> and if you're doing tat, just pass around records of functions at runtime
11:54:34 <EvanR> "reflection" does this, the difference from record-of-functions being the way typeclasses pass the dict around invisibly
11:54:42 <jle`> reflection doesn't let you create typeclasses at runtime
11:54:46 <EvanR> oh
11:54:47 <jle`> it only lets you create *instances* at runtime
11:54:53 * EvanR misread the question
11:55:03 <catern> sorry, I meant C instances
11:55:09 <catern> not creating typeclasses at runtime
11:55:27 <jle`> oh. then yeah, that's possible
11:56:07 <jle`> creating typeclasses at runtime can sort of make sense if you deconstruct a typeclass into some sort of generic data type
11:56:21 <catern> eh... but "reflection" requires crazy serialization hacks, doesn't it?
11:56:24 <jle`> similarly to how you can simulate ADT's using anonyms sums and products
11:56:37 <jle`> catern: maybe? but we're talking about API/interfaces, right?
11:56:42 <jle`> or are you asking about implementations?
11:57:00 <catern> interfaces, certainly
11:57:14 <jle`> reflection gives you typesafe api/tool to create instances at runtime
11:57:21 <cocreature> reflection is mostly useful if you need to work with an existing API based on typeclasses. if you can build your own API, just accept a record instead of a typeclass
11:57:23 <jle`> without requiring you to do any crazy serialization hacks directly
11:57:27 <catern> I forgot about Oleg's implicit configuration hack when I asked the question
11:57:36 <catern> so I should actually go ahead and read that paper
11:57:54 <catern> because I was thinking that Haskell can't handle this at the moment, due to it violating, uh
11:58:06 <catern> that one-typeclass-instance-per-type rule
11:58:21 <catern> global uniqueness of instances
11:58:23 <jle`> yes; reflection handles that by giving you a closure where a type has a specific instance
11:58:37 <jle`> the instance doesn't escape that closure
11:58:52 <catern> oho, neat hack
11:59:03 <ggVGc> I always use records of functions..
11:59:06 <jle`> and so all the actual computation you do is in that closure, and within it, the type has a unique instance
11:59:23 <ggVGc> I feel like I learnt basic haskell, and then I've kind of stayed at that level, and keep writing stuff
11:59:32 <catern> seems a little inflexible though
11:59:34 <jle`> records of functions are great, but it doesn't guarantee coherence like typeclasses do
11:59:51 <plugin> Nix users:  Can anyone point me to a succinct example of adding a github repository as a (cabal) project dependency in a `default.nix` file?
11:59:52 <ggVGc> I think I tried making one typeclass once, and fairly soon ended upo making it in to a record of functions
11:59:59 <cocreature> making up typeclass instances at runtime is usually not the case where you care about coherence
12:00:13 <ggVGc> jle`: yeah, I'm just saying, I don't think I've ever actuallyneeded what type classes give, and records have always filled my needs
12:00:16 <ggVGc> and are simpler
12:00:19 <jle`> indeed
12:00:38 <jle`> the only time coherence probably matters is when using types like Set and Map
12:00:52 <jle`> unless we're talking about type-level programming stuff
12:01:01 <EvanR> in other languages you see stuff like... numberFunctions.add(myNum1, myNum2) ...
12:01:30 <catern> you can still 100% have coherence if you're making typeclass instances at runtime
12:01:40 <pikajude> for example, jquery's $.add function
12:02:00 <EvanR> i havent seen a better way to do arithmetic
12:02:05 <EvanR> than type classes
12:02:07 <catern> you just do it by having a compiler error if the typeclass instance is ambiguous (i.e. there are multiple in scope), and require the programmer to specify which of the ones they want to use
12:02:35 <jle`> that sounds like compiletime to me
12:02:46 <jle`> if you're talking about compile errors
12:02:49 <catern> yes?
12:02:51 <cocreature> catern: my point was not that you can’t have it but that the cases where you need to build instances at runtime are usually not the ones where you care about coherence
12:03:00 <jle`> so that's not at runtime; that's at compiletime
12:03:42 <catern> cocreature: hmm... that's a little debatable, because I definitely would want an ambiguity warning when building instances at runtime. I wouldn't want it to just pick one arbitrarily (which would violate coherence)
12:05:09 <catern> jle`: typeclass instances can be contained within a local scope, and thereby allow you to detect whenever there are multiple of the same instance in that scope at compile time
12:06:22 <catern> cocreature: so yeah, I actually definitely feel that you strongly care about coherence even when building instances at runtime - without coherence, your program would change behavior silently depending on which typeclass instance was picked
12:06:36 <EvanR> or computed?
12:06:43 <EvanR> possibly due to user input hehe
12:07:02 <EvanR> or literally phase of the moon
12:10:31 <catern> anyway, I think it would be really cool to use runtime typeclass instances to statically constrain when you can use certain behaviors of whatever types (i.e. you can only do so-and-so thing with so-and-so type once you've actually connected to some server and pulled down the requisite information) without the annoying overhead of having to manually pass those things around
12:13:46 <qeyoa> Since i have only been writing haskell as far as the book exercises go, i wonder how does one divide the code up between the files. Does the "one class does one thing" from OOP still hold here in some similar fashion?
12:13:50 <thoughtpolice> If you use reflection, your instances are generally coherent since you generally have to tag a type with the quantified 's' variable, so you often need a new type ('s' also prevents two instances for the same type from being mistaken for one another, much like STRef). So I wouldn't say you necessarily don't care about coherence -- reflection is precisely when you *do* care about coherence but want a runtime dictionary.
12:14:49 <sternmull> geekosaur: I wrote an example that implements "with" of Python: http://lpaste.net/363587 The idea is that you have default cleanup function for a resource and can acquire it in many different ways but can always use "with" for cleanup.
12:15:23 <thoughtpolice> Now, you can gear it up to 11 and make it extremely automagical, providing nearly zero syntactic overhead, while making it very unsafe (violating coherence) if you throw in some extra stuff, but the basic idea is fairly sound. The more annoying part of using reflection is that you then have to deal with 's' all of the time in the continuation of 'reify'
12:17:00 <`Guest00000> > let { } in 5
12:17:03 <lambdabot>  5
12:17:24 <`Guest00000> in my language, should i set a minimum number of let bindings in a let-expr to 1?
12:17:32 <jle`> sounds arbitrary
12:17:53 <EvanR> set it to 2 to make programmers even more productive, like taxes
12:18:11 <jle`> catern: yes, reflection lets you do that; it's basically the implementation of instances-at-runtime that you are thinking of
12:19:21 <`Guest00000> lol
12:19:49 <`Guest00000> > let in 6
12:19:53 <lambdabot>  6
12:20:03 <`Guest00000> > let in let in let in let in let in let in let in 6
12:20:06 <lambdabot>  6
12:20:10 <EvanR> let out dogs
12:20:28 <virgin> cocreature: i just now see you gave me the link. i thought it was jle` and because of the i mentioned him in my response :-)
12:21:10 <virgin> maybe it's because i'm virgin. virgins are full of problems :-D
12:29:03 <jle`> virgin: does it work when you test it?
12:29:21 <jle`> virgin: only thing i can see is that you might want to try naming the results of sl, so you only have to compute it once
12:29:34 <jle`> let (r,l) = sl xs
12:29:40 <jle`>     a = balance r, etc.
12:30:56 <virgin> yes jle` it is working, and thanks for the tip :-)`
12:32:17 <virgin> jle`: for example if i command it:  balance [2,4,6,8,10,0,1], i get the result:
12:32:21 <virgin> jle`: Nod (Nod (Lef 2) (Nod (Lef 4) (Lef 6))) (Nod (Nod (Lef 8) (Lef 10)) (Nod (Lef 0) (Lef 1)))
12:32:39 <jle`> looks balanced to me :O
12:32:52 <virgin> :-)
12:33:16 <jle`> if you want, you can write a quickcheck test to verify all inputs are balanced
12:33:34 <jle`> er i mean, all inputs produce balanced trees
12:33:39 <jle`> fsvo 'all'
12:33:42 <johnw> or at least, verify that it's not trivial to find a counter-example ;)
12:35:09 <virgin> how can i do that jle`?
12:35:25 <jle`> you might be able to find a nice quickcheck tutorial somewhere
12:35:45 <jle`> basically you'd write a function Tre a -> Bool, to check if a tree is balanced
12:35:55 <jle`> and then check the property (\xs -> balanced (balance xs))
12:36:31 <metahumor> the simplest way i've found to write quickcheck tests is to use doctest
12:36:47 <metahumor> -- prop> \xs -> sort xs == (sort . sort) (xs :: [Int])
12:37:01 <virgin> ah jle` it was the previous question :-)
12:37:14 <int-e> > (do (\(Left xs) -> (# xs #) -> (# xs #)) <- return (Left undefined); return ()) :: Identity () -- musing about the MonadFailDesugaring future...
12:37:16 <virgin> someone helped me yesterday here :)
12:37:17 <lambdabot>  Identity ()
12:38:32 <virgin> jle`: http://lpaste.net/363588
12:39:24 <virgin> jle`: wait i did not insert all the code
12:40:55 <virgin> http://lpaste.net/363588
12:41:30 <virgin> it's assume i have a tree (a Node) and not just a Leaf :-)
12:42:34 <joel135> Is a monad always a pair (0, +) where 0 is a natural transformation id => F for some F and + is a natural transformation F . F => F, where . denotes functor composition, or may . be replaced by something more abstract?
12:42:47 <joel135> It seems like it is always . .
12:44:28 <joel135> I guess I should be able to trust wikipedia which uses only . but still.
12:45:58 <virgin> i'm sort of newb in haskell. i started learning it couple of years ago and then stoped (RWH) and then a year or two ago, i started again. in my journy i have a lot of frastration. every function that has a little more recurssion in it i need a lot of time to understand what is going on in it. and of course it is very annoying. will it over and i eventually understand every function more fast then today? is it happen
12:45:58 <virgin> d to you when you start learning haskell?
12:46:40 <virgin> *started
12:47:15 <virgin> i think i'm miles away from fully control this language
12:47:26 <metahumor> joel135: something something kleisli category
12:48:15 <elpfen> IME it can be frustrating because I know how to use imperative languages. It's like relearning programming. That's also why it's fun!
12:49:05 <jle`> joel135: yes that's pretty much it, although i wouldn't use +
12:49:12 <jle`> since + is usually reserved for binary operations
12:49:21 <Welkin> (0, +) looks like monoid to me
12:49:33 <virgin> elpfen: it's also fun because of the recurssion i loved and also  small code do a lot
12:49:39 <jle`> joel135: there are also some laws to follow
12:49:48 <Welkin> virgin: what exactly are you having trouble with?
12:50:01 <loli> Welkin: that is a monoid, just need to add in ℝ
12:50:11 <Welkin> if it is recursion, then I recommend this book http://www.htdp.org/2018-01-06/Book/
12:50:16 <Welkin> virgin: ^
12:50:27 <Welkin> that is hte best book I have found for learning functional programming
12:50:48 <Welkin> it uses racket as the language (not haskell) but it teaches you the fundamentals you need for haskell
12:50:53 <Welkin> even types to some degrees
12:51:12 <virgin> Welkin: it is not apecific. it's just happens that i come across a function that do something and i need to take my time to understand what is going on. and it is a lot of time. the last time it was the primes function. eventually i think i understood it.
12:51:35 <Welkin> virgin: sometimes people try to golf haskell code. I do not appreciate that
12:52:17 <jle`> joel135: essentially your mu has to be associative with respect to .'s
12:52:42 <jle`> sorry, your nu
12:52:56 <virgin> Welkin: what is "golf"? i'm not fluent in english.
12:53:00 <jle`> joel135: basically your (F . F) . F => F . F => F, where you smoosh the first thing first
12:53:10 <jle`> joel135: and your F . (F . F) => F . F => F, where you smoosh the second thing first
12:53:13 <jle`> has to give the same result
12:53:19 <virgin> Welkin: thanks for the book recommendation
12:53:23 <Welkin> virgin: they try to be too clever and write their code in as few characters as they possibly can, making it hard to read and understand by others
12:53:39 <virgin> Ah thanks Welkin :)
12:53:49 <jle`> virgin: golfing is when you prioritize short code over readable/understandable/maintainable/clear code
12:54:06 <jle`> sort of like how golfers prioritize number of strokes, vs. style and journey
12:54:31 <virgin> understood :-)
12:54:38 <joel135> Ok thanks!
12:56:58 <EvanR> (N, (0, +)) maybe
12:57:51 <virgin> Welkin: i'm reading now graham hutton book that learn me haskell. do you recommend me to leave it and read this book instead?
12:58:12 <EvanR> (N,(0,(+,(proof1,proof2))))
12:59:18 <Welkin> virgin: hutton's book will only teach you syntax for haskell (mostly) while How To Design Programs will teach you the fundamentals of functional programming
13:00:05 <Welkin> I recommend you read HtDP regardless of what else you read
13:00:22 <virgin> OK Welkin thanks!
13:01:21 <virgin> is this book usefull for other languages? mayby C++ or Python? will i benefit from it even though it is for functional programming?
13:02:07 <Welkin> it will help you with any and all programming
13:02:26 <virgin> great
13:04:47 <`Guest00000> syntax candies
13:05:27 <qeyoa> I find that Huttons book teaches a bit more than syntax. Some of the exercises are pretty hard. There was already one where i had to add some functionality to a Tautology checker and an then an abstract machine that does arithmetic computations.
13:15:22 <ski> virgin : "every function that has a little more recurssion in it i need a lot of time to understand what is going on in it","will it over and i eventually understand every function more fast then today? is it happend to you when you started learning haskell?" -- yes, with practice, it will become easier
13:17:16 <ski> virgin : learning a new programming paradigm (in this case functional programming) is a bit more like learning to programming from scratch all over, than to learn yet another more or less (conceptually) similar language, in the same paradigm. of course some things do carry over, but you have to also learn new approaches to things, unlearning, which is hard. so coming at it with a fresh frame of mind, not comparing overly much to what you already know, is us
13:17:32 <ski> (er, cut off near "so coming at it with a fresh frame of mind, not comparing overly much to what you already know, is useful")
13:18:26 <ski> virgin : i've heard some people appreciate Hutton here. you could try a little of HtDP as well, and see what you think ? also, SICP should probably be mentioned here as well
13:18:29 <ski> @where SICP
13:18:30 <lambdabot> "Structure and Interpretation of Computer Programs" <http://mitpress.mit.edu/sicp/>,<http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/>,<https://github.com/sarabander/sicp-pdf> | "
13:18:30 <lambdabot> Storage and Identification of Cabalized Packages" <http://www.vex.net/~trebla/haskell/sicp.xhtml>
13:18:42 <ski> (ignore the last part, that's something else)
13:19:04 <Welkin> ski: I linked them to How To Design Programs
13:19:10 * ski nods
13:19:11 <Welkin> which is often recommended over SICP
13:19:12 <Tuplanolla> People have also noticed that certain kinds of recursion schemes come up all the time and given them names. That helps you recognize and talk about them.
13:19:20 <ski> i'm not saying HtDP is bad
13:19:41 <qeyoa> SICP is pretty hard book
13:19:51 <ski> not all people appreciate the style of SICP. among those that do, they tend to like it quite a lot, though
13:19:55 * ski nods
13:20:24 <ski> (the SICP lecture videos are pretty fun to watch)
13:20:33 <qeyoa> i made it to the big O notation chapters and had to tap out
13:20:43 <qeyoa> will try to crack it again some time in the future
13:20:53 <ski> then there's also CTM
13:20:56 <ski> @where CTM
13:20:56 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
13:21:44 <ski> which in some ways resembles SICP. though it some other paradigms more, like logic programming, and declarative concurrency with dataflow variables
13:21:57 <ski> s/though it/though it teaches/
13:23:11 <ski> (i think the `Par' monad (there's a chapter in PCPH) comes closest to the declarative concurrency part)
13:24:46 <qeyoa> i enjoyed this book https://www.cs.cmu.edu/~dst/LispBook/book.pdf
13:24:56 <qeyoa> has a lot of friendly pictures
13:28:18 <`Guest00000> are dep-typed langs in which, in the type `(x :: T) -> f x`, x can occur in T?
13:29:17 <EvanR> heh, recursive binding
13:29:55 <joel135> `Guest00000: no, they are ones where x can occur in f x
13:30:09 <qeyoa> if a list comprehension is a function, is it possible to map it over a list?
13:30:28 <EvanR> a list comprehension is a list not a function
13:31:38 <ski> qeyoa : nice
13:31:46 <qeyoa> how does a list do computation?
13:31:50 <geekosaur> so many things wrong wit that question that I have no idea what it's trying to ask
13:31:57 <qeyoa> if it is not a function
13:32:04 <`Guest00000> qeyoa: do you mean a list of functions?
13:32:29 <ski> how does `1 + 2' do computation, if it's not a function ?
13:32:47 <`Guest00000> 1+2 doesn't do computation
13:32:50 <`Guest00000> is is computed
13:33:19 <geekosaur> a list comprehension is an expression describing how to create a new list from one or more specified lists
13:33:20 * `Guest00000 didn't notice it's ski.
13:33:33 <EvanR> [[1 + 2]] = [[1]] + [[2]]
13:33:35 <geekosaur> if you meant whether it is possiblke to pass one of the seed lists in as a parameter, then yes
13:33:39 <ski> both `1+2' and list comprehensions expresses some (non-trivial) computation to be done
13:34:03 <ski> you could make a function whose body involves a list comprehension, though. perhaps that's what you're looking for, qeyoa ?
13:34:15 <geekosaur> foo y = [x | x <- y] or similar. the comprenbesion doesn;t care where "y" or etc. came from, just that it is a list and the types match up
13:34:18 <mnoonan> EvanR: hella confusing notation given all the list chat :)
13:34:35 <EvanR> = [[12]], thanks javascript
13:34:41 <qeyoa> yes i know that, but i wondered it was possible to do something like this: map [n | n > 0] [1,2,3]
13:34:48 <qeyoa> seems not
13:34:59 <`Guest00000> qeyoa: use:  map (\n -> n > 0) [1,2,3]
13:35:00 <Welkin> you are looking for filter
13:35:03 <ski> > map (\xs -> [x^2 | x <- xs,odd x]) [[0,1,2,3],[4,5,6],[7,8],[9],[]]
13:35:06 <lambdabot>  [[1,9],[25],[49],[81],[]]
13:35:16 <qeyoa> yeah, i understand that
13:35:23 <geekosaur> this sounds like considerable confusion as to what a list comprehension is
13:35:35 <mnoonan> > map (\n -> [n | n > 0]) [-5..5])
13:35:39 <lambdabot>  <hint>:1:32: error: parse error on input ‘)’
13:35:39 <qeyoa> i was curious about the way list comprehensions work
13:35:46 <Welkin> a  list comprehension is syntactic sugar
13:35:47 <`Guest00000> maybe qeyoa thinks it's just a syntax
13:35:56 <`Guest00000> but it's also just a list
13:36:06 <ski> > concatMap (\n -> [n | n > 0]) [-5 .. 5]
13:36:09 <lambdabot>  [1,2,3,4,5]
13:36:17 <Welkin> > [(x,y) | x <- [1,2,3], y <- [4,5,6]]
13:36:20 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
13:36:25 <ski> > [n | n <- [-5 .. 5],n > 0]
13:36:28 <lambdabot>  [1,2,3,4,5]
13:36:29 <ski> @undo [n | n <- [-5 .. 5],n > 0]
13:36:29 <lambdabot> concatMap (\ n -> if n > 0 then [n] else []) [-5 .. 5]
13:36:36 <Welkin> > do {x <- [1,2,3]; y <- [4,5,6]; return (x,y)}
13:36:39 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
13:36:45 <Welkin> these are the same
13:36:48 <qeyoa> yeah i know i can use it in a lambda
13:37:01 <qeyoa> was just asking out of curiosity
13:37:06 <ski> list comprehensions desugar to calls to `concatMap',to `if'-`then'-`else's, and to `let'-`in's
13:37:22 <Welkin> > [1,2,3] >>= \x -> [4,5,6] >>= \y -> return (x,y)
13:37:24 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
13:37:28 <Welkin> all the same thing
13:37:28 <ski> @undo [m | n <- [-5 .. 5],let m = m^3,m > 0]
13:37:29 <lambdabot> concatMap (\ n -> let { m = m ^ 3} in if m > 0 then [m] else []) [-5 .. 5]
13:37:33 <Welkin> that is what a list comprehension becomes
13:37:45 <qeyoa> what is >>=?
13:37:45 <ski> @do [1,2,3] >>= \x -> [4,5,6] >>= \y -> return (x,y)
13:37:45 <lambdabot> do { x <- [1, 2, 3]; y <- [4, 5, 6]; return (x, y)}
13:37:53 <Welkin> qeyoa: bind from Monad
13:37:59 <ski> @src [] (>>=)
13:38:00 <lambdabot> xs >>= f = concatMap f xs
13:38:00 <EvanR> mnoonan: wait until we start talking about the denotation of lists
13:38:13 <ski>   (>>=) :: [a] -> (a -> [b]) -> [b]  -- in this case
13:38:34 <ski>   concatMap f xs = concat (map f xs)
13:40:20 <qeyoa> also, a question i asked before: how does one break up the code in haskell. I only did things with the ghci interpreter
13:40:30 <qeyoa> is it similar to oop?
13:40:37 <Welkin> qeyoa: no
13:40:39 <Welkin> you use functions
13:40:40 <qeyoa> where one class does one thing
13:40:43 <Welkin> and modules
13:40:52 <Welkin> that's all you need
13:41:18 <EvanR> one function does one thing, perhaps one big complex thing
13:41:36 <EvanR> this is functional programming, not oop
13:41:41 <Welkin> functions are composed of smaller functions
13:41:46 <qeyoa> what is the responsibility of a module?
13:41:50 <Welkin> you compose a pipeline of functions
13:41:56 <dminuoso> qeyoa: If Im unsure, I start with top-to-bottom, where I start with the largest function, and then I start making smaller functions that provide dependencies.
13:42:01 <Welkin> qeyoa: a file is a module, and it contains many functions and definitions
13:42:25 <sternmull> geekosaur: Have you seen my Haskell implementation of Pythons "with" http://lpaste.net/363587? This is what i meant.
13:43:03 <qeyoa> so how large should a module be
13:43:05 <qeyoa> ?
13:43:16 <Welkin> qeyoa: up to you
13:43:18 * ski would sometimes like the ability to define submodules, inside other modules
13:43:31 <Welkin> ski: have you see backpack?
13:43:35 <qeyoa> what is the prefered size?
13:43:41 <dminuoso> qeyoa: I like to have a main rule: Write small functions that do one thing, and do it well.
13:43:43 <ski> Welkin : i keep meaning to look into it :)
13:43:52 <Welkin> qeyoa: logical grouping based on what the functions do
13:44:03 <c_wraith> modules should be big enough to contain what they need to, but small enough to not get lost navigating. yes, that rule is ambiguous.
13:44:04 <ski> qeyoa : it depends, but not "too large"
13:44:08 <Welkin> for example, many people put all of the types for their program into a module called Types
13:44:25 <Welkin> you could also have one for database operations, called DataBase
13:44:32 <ski> "separation of concerns" is a good ideal to have in mind (together with other constraining factors)
13:44:34 <Welkin> and one for rendering, called Graphics
13:44:35 <EvanR> short enough to maintain interest but long enough to cover the essentials
13:44:57 <Welkin> but you need to keep in mind that you want to avoid circular dependencies/imports
13:45:19 <Welkin> if that happens, pull out the dependency into a third module and import that into both
13:45:35 <qeyoa> that does not sound so much different from oop implemented with clean code rules in mind?
13:46:02 <EvanR> you will find the organization of functions sometimes 90 degrees out of phase with OOP
13:46:10 <Welkin> qeyoa: there is no inheritance, no mutable state, no classes
13:46:10 <qeyoa> how so?
13:46:27 <Welkin> the primary unit of your program is the function
13:46:31 <ski> qeyoa : unfortunately, many OOP languages tend to conflate modules with classes, which imho, leads to problems
13:46:34 <Welkin> functions do everything
13:46:55 <tdammers> Haskell modules sit in the same spot as the modularity aspect of objects in OOP
13:46:55 <Welkin> functions operate on data to transform it
13:46:56 <EvanR> they arent grouped necessarily by the data type, but by functionality which might cross many types
13:47:05 <ski> some things which are easy to do with abstract data types, implemented via modules, are hard to do with an OOP approach
13:47:05 <tdammers> but unlike OOP objects, that's the *only* thing they do
13:47:09 <Welkin> so you construct a pipeline of functions to transform the inputs of your program into the desired outputs
13:47:33 <ski> (e.g. a "merge"-like operation on a collection data type, say, where the operation needs to access the implementation details of both collections)
13:47:35 <tdammers> grouping related things, and encapsulating by exposing things selectively
13:47:50 <ski> qeyoa : let's take one specific example of "how does one break up the code in haskell", namely let us consider an "FP" vs. an "OO" approach
13:48:06 <qeyoa> ski: exciting!
13:48:39 <ski> qeyoa : let's say we want a type of "shapes". we want some ways of forming alternative shapes, like triangles, rectangles, circles. and we want some operations, for computing say perimeter, area, perhaps rendering the shape on some kind of canvas
13:50:06 <ski> qeyoa : so, for each alternative shape, we need an implementation of each operation. we could conceptually organize this in a rectangle, with one row for each alternative shape, and one row for each operation. now in the "OO" approach, we divide this table along the rows. each row becomes a class (implementing a common shape interface, or subclassing an abstract shape subclass). and the operations become methods
13:51:01 <ski> qeyoa : now, it's easy to add another alternative shape, we just add another class. but it's harder to add another operation, since we need to modify all the existing classes (and perhaps there's interactions between the methods, open recursion, invariants to uphold, &c.)
13:51:18 <tdammers> that's actually a very naive OOP approach
13:51:30 <ski> yes, this is a very simplified picture
13:51:43 <tdammers> but you are right, the general concerns apply
13:51:55 <Welkin> this is java oop, not alan kay oop
13:52:22 <`Guest00000> with (x % y) being for ((%) x y), (%)'s type is at least: (x :: X) -> (y :: f x) -> g x y; it means that y's type can depend on x's type, but not conversely. how this problem should be solved simply?
13:52:39 <ski> qeyoa : now, in the "FP" approach, we instead divide the table into columns. each alternative shape becomes a data constructor of a variant/sum type, an algebraic data type. each operation becomes a *pattern-matching* function that checks which data constructor the input was constructed with
13:52:49 <`Guest00000> sorry. maybe i'm flooding too much about just language building
13:52:49 <EvanR> Guest19594: you want recursive dependent types?
13:52:52 <tdammers> Welkin: doesn't actually matter all that much in this case - separating the "representation" part from the "rendering" part is something you'd also do in OOP design
13:53:03 <`Guest00000> yeeeess
13:53:14 <ski> qeyoa : now, it's easy to add another operation, we just add another pattern-matching function. but it's harder to add another alternative shape, since now we need to change all the existing pattern-matching functions
13:53:14 * EvanR subscribes to your newsletter
13:53:50 <ski> qeyoa : so, this is really a trade-off between variant types (which tends to be more commonly used in FP languages), and record types (which is more or less what object types in OO amounts to)
13:54:19 <`Guest00000> seriously?
13:54:24 <ski> qeyoa : which alternative you want to go for depends on whether you think it's more likely that you'll want to add or change the alternative side, or the operations side
13:54:25 <`Guest00000> hehe
13:55:31 <ski> qeyoa : now, as said, this is a simplified picture. e.g. pattern-matching tends to allow one to also do deep pattern-matching. and in OO, you also have implementation inheritance. &c.
13:56:39 <ski> Welkin : can you elaborate on how Alan Kay OOP would differ, in relation to this example ?
13:57:13 <ski> `Guest00000 : "this problem" being ?
13:57:56 <qeyoa> what is a variant/sum type?
13:58:13 * ski has idly pondered the idea of imposing a well-order on dependency, in order to allow other than plain "left-to-right" dependency, but still require it to "bottom-out" at some point
13:58:17 <`Guest00000> ski: this problem being being unable to define infix funcs where 1st arg's type depends on 2nd's value
13:58:19 <Welkin> data Bool = True | False -- qeyoa
13:58:27 <`Guest00000> heheh
13:58:31 <Welkin> qeyoa: it is a type that has more than one constructor
13:58:38 <Welkin> Bool can be True OR False
13:58:40 <qeyoa> ah, ok
13:58:45 <Welkin> the OR is the part that makes it a "sum"
13:59:14 <Welkin> a product type is a type with a constructor that has parameters
13:59:26 <ski> qeyoa : a type whose values can be one of a number of alternative shapes. `data Either a b = Left a | Right b' is the classic example. in C, one'd encode these as a `struct' containing an `enum' tag which describes which part of a `union' is valid
13:59:29 <Welkin> data Pair = Pair Int Int
13:59:36 <`Guest00000> data Perf :: [*] -> * where PerfNil :: Perf []; PerfCons :: t -> Perf ts -> Perf (t : ts)
13:59:36 <ski> in Pascal and Ada, these are called "variant record types"
13:59:42 <Welkin> you can't use only one of the Int values
13:59:45 <Welkin> you need to have both
13:59:48 <Welkin> so, AND
13:59:52 <ski> in math, this is called disjoint union, or discriminated union
13:59:53 <EvanR> `Guest00000: you might need to decouple the restraining bar that precludes infinite types
14:00:13 <`Guest00000> from what
14:00:33 <EvanR> from the chassis
14:00:39 <`Guest00000> heh
14:00:46 <sepakorayl> am I correct to think that maybeNatNe :: SNat n -> SNat -> So (OrderingNE (CmpNat n m)) won't work ?
14:00:52 <`Guest00000> actually i'm trying to
14:00:52 <ski> qeyoa : while a record/product type requires each value to contain one component of *each* of a number of given types. like `(Bool,String,Integer)', or `data Person = MkPerson {name :: Name,age :: Integer,address :: String}'
14:01:38 <ski> qeyoa : note that you can do a kind of OO in Haskell, by using record types, many of the components/fields of which will commonly be functions
14:02:05 <ski> sometimes this is an appropriate way to structure one's program
14:02:29 <ski> @where on-understanding-revisited
14:02:29 <lambdabot> "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf>
14:02:39 <ski> is relevant to this
14:02:56 <sepakorayl> what's the best way to wring a GADT NatsNE ?
14:03:05 <ski> (TaPL also has a chapter on two about this)
14:03:12 <sepakorayl> using Nat from TypeLits ?
14:03:36 <qeyoa> ski: is this a hard read?
14:03:40 <qeyoa> should i read it now?
14:03:50 <`Guest00000> type SpreadsheetlyTypedList spreadsheetDepFunc = (list :: Perf (spreadsheetDepFunc list));  type SpreadsheetDepFunc = (list :: SpreadsheetlyTypedList) -> Perf list
14:03:52 <ski> qeyoa : perhaps you should try reading
14:03:57 <qeyoa> ok
14:03:59 <ski> @where on-understanding
14:03:59 <lambdabot> "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
14:04:00 <`Guest00000> ski EvanR
14:04:07 <ski> @where polymorphic-type-inference
14:04:07 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
14:04:42 <ski> qeyoa : first. (parts of) the former of those two is the paper which the previous paper was a response to
14:05:06 <sepakorayl> since Nats do not have an inductive definition
14:05:59 <ski> qeyoa : note that there's no requirement to understanding everything in a paper. if one can step away from a paper, having learned something, that's not bad. one could always skip parts which one's eyes glaze over, and perhaps revisit them later, possibly after following up more accessible sources/tutorials to some of the material (e.g. checking the bibliography)
14:06:16 <ski> (that's how i learned to read papers : by attempting to read them, failing, trying again)
14:06:40 <qeyoa> ski: it is also possible to get the wrong conclusions if one has not the right base to parse the information
14:06:44 <delYsid> Is there something like repeat for function composition?
14:06:56 <ski> qeyoa : i hope at least the initial sections of those two later papers should not be that hard to grasp
14:07:06 <qeyoa> ok will try it now
14:07:06 <ski> qeyoa : *nod*
14:07:14 <Welkin> delYsid: foldr (.)
14:08:15 <`Guest00000> delYsid: maybe you mean fix?
14:08:16 <delYsid> Welkin: no, I mean something that composes f with itself n times.
14:08:35 <Welkin> fix
14:08:37 <`Guest00000> that's like replicate...
14:08:40 <ski> qeyoa : if you want some more suggestions on papers which may be somewhat easier, i suggest looking up some of Philip Wadlers papers, e.g. the earlier ones about monads (being the first papers to actually use monads for programming)
14:09:00 <delYsid> `Guest00000: right, sorry, I keep confusing those two.
14:09:07 <`Guest00000> iterate (.) f !! n
14:09:34 <`Guest00000> > (\n -> iterate (.) (+ 1) !! n) <$> [0..]
14:09:37 <lambdabot>  error:
14:09:38 <lambdabot>      • Occurs check: cannot construct the infinite type: c ~ a -> c
14:09:38 <lambdabot>        Expected type: ((a -> c) -> a -> c) -> (a -> c) -> a -> c
14:09:40 <`Guest00000> damnn
14:09:43 <ski> qeyoa : start e.g. at the bottom of <http://homepages.inf.ed.ac.uk/wadler/topics/monads.html>, with "The essence of functional programming"
14:10:01 <jbetz> is there a function for grouping elements in a list by some predicate? similar to groupBy, except without the restriction that the output is equal to the concatenation of the input
14:10:07 <`Guest00000> > (\n -> iterate (. (+ 1)) id !! n) <$> [0..]
14:10:10 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
14:10:14 <`Guest00000> again
14:10:25 <ski> jbetz : you want to `sort' first ?
14:10:34 <ClaudiusMaximus> iterate f x !! n  sometimes suffers from lack of strictness ; don't know if  foldr (.) id (replicate f n)  is better
14:10:51 <ClaudiusMaximus> iterate f x !! n  sometimes suffers from lack of strictness ; don't know if  foldr (.) id (replicate n f)  is better  -- fix typo
14:10:55 <`Guest00000> > (iterate (. (+ 1)) id !! 0) 1000
14:10:58 <lambdabot>  1000
14:10:59 <`Guest00000> > (iterate (. (+ 1)) id !! 0) 1001
14:11:02 <lambdabot>  1001
14:11:05 <`Guest00000> > (iterate (. (+ 1)) id !! 123) 1000
14:11:07 <ski> ClaudiusMaximus : how about  \x -> foldl' ($) x (replicate n f)
14:11:08 <lambdabot>  1123
14:11:18 <`Guest00000> > (iterate (. (* 2)) id !! 4) 1
14:11:21 <lambdabot>  16
14:11:22 <ClaudiusMaximus> ski: thanks
14:11:32 <ski> ClaudiusMaximus : er, actually, that should not use `($)', but `flip ($)'
14:11:46 <`Guest00000> delYsid: yourFunc f n = iterate (. f) id !! n
14:12:27 <`Guest00000> maybe for n there will be n thunks for the function
14:12:39 <ski> hm, should there be an `.!' operator, defined as `(f .! g) x = (f . g) $! x' ?
14:13:03 <`Guest00000> in which case may want to optimize to log(n) thunks instead
14:14:01 <ski> sepakorayl : `NatsNE' ?
14:14:07 <delYsid> `Guest00000: Thanks.
14:14:50 <jbetz> ski: exatcly. so, a sortBy followed by a groupBy. thanks.
14:16:49 <sepakorayl> NatsNE :: Nat -> Nat -> *
14:16:53 <sepakorayl> nonempty when the nats are not equal
14:17:09 <sepakorayl> found it, I have to use CmpNat as a constraint on the constructors
14:18:51 <sepakorayl> data NatsNe n m where NatsGT :: (CmpNat n m :~: 'GT) => NatsNe n m ; NatsLT :: (CmpNat n m :~: 'LT) => NatsNe n m
14:19:48 <ski> jbetz : but not with an `Ord' constraint, i take it ?
14:20:20 <ski> sepakorayl : ok
14:20:38 * ski might call that `NatsApart'
14:23:14 <EvanR> ski: last night i noticed a property "_ not in context" defined purely positively. but i couldnt figure out a positive word for "not in"
14:23:17 <ski> @type let groupBy :: (a -> a -> Bool) -> [a] -> [[a]]; groupBy _ [] = []; groupBy (==) (x:xs) = (x:ys) : groupBy (==) zs where (ys,zs) = partition (==) xs in groupBy
14:23:19 <lambdabot> error:
14:23:20 <lambdabot>     • Couldn't match type ‘a1 -> Bool’ with ‘Bool’
14:23:20 <lambdabot>       Expected type: a1 -> Bool
14:23:38 <qeyoa> ski
14:23:42 <`Guest00000> which is a shame that there isn't a standard function
14:23:53 <EvanR> ∉
14:24:03 <`Guest00000> but if there was at least a mpower :: Monoid m => Int -> m -> m,
14:24:12 <qeyoa> how do i write someone a message in irssi?
14:24:30 <`Guest00000> qeyoa: /query NICKNAME
14:24:33 <Welkin> qeyoa: /msg <name>
14:24:36 <`Guest00000> will open a tab
14:24:36 <qeyoa> thanks
14:24:42 <`Guest00000> with private dialogue
14:24:51 <ski> @let groupDistantBy :: (a -> a -> Bool) -> [a] -> [[a]]; groupDistantBy _ [] = []; groupDistantBy (==) (x:xs) = (x:ys) : groupDistantBy (==) zs where (ys,zs) = partition (x ==) xs
14:24:53 <lambdabot>  Defined.
14:25:11 <`Guest00000> "/unquery" closes
14:25:17 <Welkin> or /wc
14:25:17 <Welkin> :P
14:25:27 <Welkin> bring it on `Guest00000
14:25:35 <ski> @let equating :: (a -> b) -> (a -> a -> Bool); equating f = f `on` (==)
14:25:36 <lambdabot>  .L.hs:169:14: error:
14:25:37 <lambdabot>      • Couldn't match type ‘b’ with ‘a -> Bool’
14:25:37 <lambdabot>        ‘b’ is a rigid type variable bound by
14:25:52 <ski> @let equating :: (a -> b) -> (a -> a -> Bool); equating f = (==) `on` f
14:25:53 <lambdabot>  .L.hs:169:14: error:
14:25:53 <lambdabot>      • No instance for (Eq b) arising from a use of ‘==’
14:25:54 <lambdabot>        Possible fix:
14:25:59 * ski sighs
14:26:30 <ski> > groupDistantBy (equating fst) (zip "mississippi" [0 ..])
14:26:32 <lambdabot>  [[('m',0)],[('i',1),('i',4),('i',7),('i',10)],[('s',2),('s',3),('s',5),('s',...
14:26:44 <ski> jbetz : something like that ^ ?
14:26:48 <`Guest00000> Welkin: or "" (to the left you see a string with such microscopic characters they're usually invisible; in normal strings' terms, this string's length is approximately 0.034)
14:26:54 <ski> (`groupDistantBy' is probably not a very good name)
14:27:49 <ski> EvanR : hm, perhaps "is out of" ?
14:28:10 <ski> EvanR : istr Brouwer had a couple of words along these lines ..
14:28:52 <Welkin> out of africa?
14:29:33 <EvanR> whatever you want is not in the empty context
14:30:10 <EvanR> if x is not in G, then x is not in G,y where y is anything other than x
14:30:22 <EvanR> haha
14:31:52 <dminuoso> Uh.. is there a way this package could have any less useful diagnostics?  connectODBC "Driver=OracleDriver;UID=APAX"; .... *** Exception: SqlError {seState = "[\"*** Exception: Prelude.chr: bad argument: 3670066
14:32:15 <EvanR> exceptions are like burritos
14:32:29 <jbetz> ski: works for me. I was thinking of something like `globalGroupBy'.
14:34:10 <Hijiri> when you accidentally change profiling options and stack unregisters lens, Cabal, linear, gl, ...
14:35:36 <ski> jbetz : it might have been better if the existing `groupBy' was called `groupAdjacentBy', and the above one then just `groupBy'
14:37:25 <jbetz> ski: agreed
15:03:56 <dminuoso> Let's say you have a database query that selects rows from a database table: IO [Int]
15:04:16 <dminuoso> Is there a way to make this somehow lazy, that it will cause side effects while you read from the list?
15:04:32 <jle`> that's what unsafeInterleaveIO does
15:04:45 <EvanR> in *sql-simple you would not get a list back, you would get a thing that can be foldM'd over
15:05:08 <EvanR> rather it has a library function to fold over the results with an IO action
15:05:25 <jle`> dminuoso: it's what unsafeInterleaveIO/lazy IO does, but lazy IO is already considered something that is potentially very bad already
15:05:39 <jle`> i would recommend not introducing lazy io if possible
15:06:09 <EvanR> https://hackage.haskell.org/package/sqlite-simple-0.4.14.0/docs/Database-SQLite-Simple.html#v:fold
15:07:18 <EvanR> from here you can produce a lazy-io-like list (hopefully behaving better than default lazy IO), or plug into conduit, or ...
15:07:36 <dminuoso> Ah interesting, I guess that has the behavior Im looking for.
15:08:01 <dminuoso> jle`: Interesting, I should have asked this question the second I read about lazily reading files. In retrospect this should have raised an eyebrow.
15:08:24 <jle`> dminuoso: yes, this is exactly what readFile does
15:08:43 <jle`> it returns a [Char] and causes side effects as you evaluate sequential chars
15:08:45 <EvanR> lazy reading of files can get your job done if its like a one-off script
15:08:55 <jle`> the IO is triggered by evaluation of thunks
15:09:10 <jle`> (some buffering is done)
15:10:01 <jle`> yeah, the main problem with lazy IO is you can easily write yourself into a situation where it is non-trivial when side effects happen and when finalizers are executed
15:10:09 <dminuoso> EvanR: from that it seems that this needs to be supported by the library that implements said IO directly.
15:10:41 <ski> `unsafeInterleaveIO' can be thought of as akin to concurrency, where you think of the I/O as happening some time between this invokation, and the consumption of the parts of the list
15:10:41 <jle`> if when side effects happens is not important to you, and reasoning about finalizers and handlers and when they get closed (or if they ever do get closed), then lazy io can be classified as 'benign'
15:11:00 <EvanR> dminuoso: are you questioning the modularity of sql fold?
15:11:06 <dminuoso> jle`: Well all of this would be completely read-only access to a database.
15:11:29 <ski> if that I/O raises an exception, then you'll get an exception when the value is forced, which may be quite a bit later. this can be problematic
15:11:43 <jle`> if the user of your function doesn't need to care about when IO happens, or when connections are opened or closed, or if a connection is or is not open, then it isn't too bad
15:11:48 <jle`> oh yeah, errors/exceptions, forgot about that.
15:12:04 <EvanR> dminuoso: read-only doesnt satisfy "purity"
15:13:01 <EvanR> dminuoso: check out the FoldM type here https://hackage.haskell.org/package/foldl-1.3.7/docs/Control-Foldl.html
15:13:19 <ski> (in any case, i think one shouldn't think of the "unsafe" in `unsafeInterleaveIO' as of the same level of severity as the one in `unsafePerformIO' or `unsafeCoerce' .. in fact, i don't think using "unsafe" here is really that informative terminology more than "there may be something weird/bad here, watch out !")
15:13:35 <jle`> pipes/conduit are tools that suit this type of pipeline pretty well, and make this really disciplined/easy to reason with
15:14:21 <jle`> the fold library is a lightweight way to handle this too
15:14:31 <ski> (i would perhaps prefer e.g. `unsafePerformIO' to be called `promisePureIO', which tells you the proof obligation to use it safely)
15:15:01 <jle`> my local church would endorse promisePure
15:16:39 <EvanR> promisePure sounds directly contradictory to accursedUnutterable :)
15:17:18 <dminuoso> EvanR: Ah well I guess I could work with that
15:17:29 <johnw> I wonder if anyone can think of a clever way to make this algorithm more efficient: https://github.com/jwiegley/notes/blob/master/haskell/Rewrites.hs
15:17:49 <johnw> right now there is an awful lot of consing and comparing
15:18:18 <johnw> note that this as a prototype for a decision procedure in Coq, so it can't use crazy tricks
15:18:25 <EvanR> dminuoso: yeah... you can lift the fold from -simple into a thing that composes with other (monadic) fold operations
15:18:28 <`Guest00000> foldM'd
15:21:42 <lyxia> johnw: why [0,2] and not [0,1]
15:21:53 <johnw> sorry, that example should be fixed
15:21:57 <johnw> it's 0,1
15:22:26 <lyxia> is that problem decidable
15:22:44 <johnw> by keeping track of the past states it should be
15:22:52 <johnw> it could take a very long time/memory
15:24:31 <johnw> fortunately, for the problem I'll be using is on, the number of terms and the number of rewrites to apply, should always be <10
15:28:04 <`Guest00000> that's a group
15:29:54 <lyxia> johnw: you are appending map swap hyps, does that mean the rewrite rules can be applied both ways
15:29:59 <johnw> yes
15:30:28 <johnw> the (X,Y) rewrite rules should be considered as statements of equivalence
15:30:58 <lyxia> ah, maybe "only" on line 22 should be "also"
15:31:06 <int-e> dminuoso: Oh my, you have stumbled upon a bug in base... Foreign.C.String.peekCWString (which is used inside HDBC-odbc) reads characters as 4 byte words (because it uses the Storable instance for Int32...). So that 3670066 is actually two characters: a 8 followed by a 2.
15:31:14 <johnw> oops, thanks!
15:32:48 <johnw> this algorithm is so much easier to write in a lazy language with monadic syntax and Alternative. It won't look as pretty in Coq.
15:33:14 <int-e> dminuoso: at least that's my theory... need to write some code to confirm, but I'm fairly confident that it's right.
15:35:15 <frerich> johnw: Would it maybe be useful to take advantage of the transitivty and build a 'tree' of substitutions up front given the given list of XS,YS pairs?
15:35:34 <johnw> frerich: that's an interesting thought
15:37:06 <frerich> johnw: Using that , maybe you could build a 'bigger' dictionary which allows taking more than one step, e.g. you could maybe build a tree and from that deduce that you can go straight from [2,3] to [3,5,5] via 0,2 (or [2,3] to [9,5] via 0,1.
15:38:48 <johnw> so if I have ([1],[2]),([2],[4]),([2,3],[5]), it would become ([1],[4]),([4,3],[5])?
15:39:28 <johnw> except, I might have 2 in the goal
15:39:39 <EvanR> hmm i really want IntMap to be a category
15:39:49 <johnw> EvanR: yeah, tell me about it
15:40:07 <`Guest00000> that's not a group. that's a category
15:40:21 <`Guest00000> (talking about that exercise)
15:42:08 * ggVGc groups all the categories
15:42:16 <lyxia> johnw: do you have some idea of how large you expect the search space to be
15:43:00 <johnw> lyxia: the LHS will have size <10, there might be 20 rewrite rules, but each rewrite rule will have size <5 on either side
15:47:45 <johnw> lyxia: I'm hoping for a search space in the thousands of candidates
15:48:56 <lyxia> thousands seems quite small
15:49:09 <johnw> if it takes longer than a few seconds, then it's not better than what I have now
15:49:32 <johnw> also, it would be nice if, should it fail to find a rewrite, it offers a way to find the smallest LHS
15:50:05 <johnw> I feel like SMT should help with this problem, but I can't think of how to frame it
15:50:59 <johnw> because I don't actually need the automation to happen within Coq.  If I simply know which rewrite rules to apply and in what order, I can write an external problem that generates the proof script
15:51:13 <johnw> s/problem/program
15:51:37 <Tuplanolla> Usually indistinguishable, johnw.
15:51:55 <johnw> Tuplanolla: what from what?
15:52:21 <Tuplanolla> Programs and problems.
15:52:29 <johnw> oh, haha
15:52:33 <johnw> philosophical typos
15:52:48 <EvanR> > map sort ["problem","program"]
15:52:51 <lambdabot>  ["belmopr","agmoprr"]
15:53:18 <EvanR> cool almost pronouncable time to write a fantasy novel
15:53:34 <`Guest00000> > sort "problem program"
15:53:37 <lambdabot>  " abeglmmoopprrr"
15:54:17 <EvanR> > "problem" \\ "program"
15:54:20 <lambdabot>  "ble"
15:54:47 <`Guest00000> \\ only works on a pair
15:54:49 <int-e> dminuoso: Okay, I'm wrong... base is probably fine, since wchar_t is actually 32 bits (here). But ODBC isn't necessarily using wchar_t for SQLWCHAR, and in fact the latter seems to be a 16 bit type in your case... problems ensue. Fun :(
15:54:57 <phadej> johnw: do you have an example input which takes long, but bearable time? so we can golf it?
15:56:33 <johnw> that's a great idea, maybe later tonight I can translate one
15:57:02 <johnw> also, I forgot that this needs to apply to trees, not lists
15:57:07 <EvanR> i remember bitness bugs in HDBC a long time ago
15:57:25 <johnw> where the rewrite rules and the LHS are rose trees, and you might rewrite at any level
15:57:36 <phadej> johnw: hah :)
15:58:08 <phadej> johnw: is "auto rewrite" too slow :)
15:58:14 <phadej> (or what it is in Coq)
15:58:14 <johnw> it doesn't work
15:58:17 <phadej> :)
15:58:25 <johnw> too big a state space, and too slow at each attempt
15:58:31 <johnw> plus it doesn't avoid recurring states
15:58:39 <phadej> yeah, it's somewhat dumb :/
15:59:56 <phadej> johnw: but you really have concrete terms and not "forall a, .. " rewrite rules?
16:00:17 <int-e> dminuoso: and of course this is a known problem. https://github.com/hdbc/hdbc-odbc/issues/25 even has a workaround (using the non-wide-character version of the diagnostic function).
16:00:48 <freeman42x> is there a trick for running something just on first call of a recursion function (needed for purpose of argument and return value logging)? for example: http://lpaste.net/3629238723645800448 for usage with traceShow
16:01:33 <c_wraith> no trick, just the obvious "wrap the recursive function"
16:02:54 <johnw> phadej: for example, I take a statement like this: (f △ g) ▽ (h △ i) ≈ (f ▽ h) △ (g ▽ i), and I replace each uninterpreted function with an integer, flatten out identities and associativity, and end up with ([[5, [[6, [[1, []], [2, []]]]]],[[5, [[6, [[3, []], [4, []]]]]]]],[[6, [[5, [[1, []], [3, []]]]]],[[5, [[5, [[2, []], [4, []]]]]]]]), and I want to apply the known laws about cartesian categories, where the statement of the laws
16:02:55 <johnw> have be similarly reified so that it's just about substitution
16:03:31 <johnw> but the original problem statement is of the forall variety
16:03:42 <johnw> such as this: https://github.com/jwiegley/category-theory/blob/master/Structure/Bicartesian.v#L18
16:03:55 <johnw> there's nothing intelligent about this proof, it's just finding the right order of substitution
16:05:41 <phadej> johnw: I cannot think anything super clever, only a) trying f_equal to divide&conqueer, and b) coming up with some heuristic to guide A* into right direction, hopefully improving on dfs or bfs
16:06:05 <phadej> but without getting hands dirty, I don't know what that distance function would be
16:06:25 <phadej> (for list I'd try with edit-distance, as it's easy to try, with trees, I don't know)
16:06:55 <freeman42x> c_wraith: I assume something like this http://lpaste.net/7653374577485021184 cheers!
16:07:33 <`Guest00000> johnw: does every operation (fst_i, snd_i) rewrite all occurences of fst_i to snd_i simultaneously?
16:07:51 <johnw> `Guest00000: no, it can't do that
16:08:01 <johnw> since rewriting some but not all may open up new avenues
16:08:09 <`Guest00000> then
16:08:24 <`Guest00000> returning a sequence of indexes of operations is not enough to specify a transformation.
16:08:52 <johnw> oh, right; indexes plus locations
16:09:03 <johnw> you can tell I only just started coding this up :)
16:09:08 <rub1k> hello folks, I'm new to Haskell and just wanted to join the community :)
16:09:17 <phadej> rub1k: welcome
16:09:24 <johnw> rub1k: hello!
16:09:41 <phadej> johnw: hopefully you aren't writing your ICFP submission :)
16:09:46 * frerich waves to rub1k 
16:09:53 <rub1k> johnw: didn't want to interrupt your conversation
16:10:06 <johnw> phadej: hah, just proofreading :)
16:10:07 <rub1k> thanks frerich
16:10:32 <c_wraith> freeman42x, looks right to me
16:10:44 <johnw> rub1k: no worries!
16:11:36 <rub1k> johnw: good to here. I'm living in Germany and where do you come from?
16:12:01 <johnw> rub1k: I'm in the western US, in California
16:12:15 <rub1k> just heard about Haskell recently, tried it today and think it's a cool language for me like Fortran or Mathematica :)
16:12:51 <rub1k> alright, it's cool some people still using IRC
16:13:20 <ski> johnw : ooc, what is ⌜△⌝,⌜▽⌝,⌜≈⌝ in there ?
16:14:03 <johnw> ski: (&&&), (|||),(==), in Haskell terms
16:14:23 <johnw> with Eq taken to be equivalence, not definitional equality
16:14:32 <ski> johnw : "tupling" of categorical product vs. "cotupling" of categorical coproduct ? aka `<f,g>' vs. `[f,g]' ?
16:14:35 <johnw> (so really, not categories, but quotient categories)
16:14:43 <johnw> yes
16:14:53 <ski> johnw : ok. i've seen such a law being called a "mix" law, fwiw
16:15:08 <ski> quotient categories ?
16:15:24 <johnw> in a quotient categories, the laws hold up to a defined equivalence on morphisms
16:15:28 <phadej> github's default font's ~> is quite hard to distinguish :S
16:15:52 <ski> johnw : oh, you just mean you present the hom-classes as setoids ?
16:15:58 <johnw> ski: I usually name my theorems after the sequence of functions that appear on the left-hand side, so that I can recall them easily by identifying what I want to rewrite in the goal
16:16:02 <johnw> ski: yes
16:16:07 <ski> ok, and ok
16:16:54 * ski sometimes names the theorems after the (sequence in the) main result
16:17:29 * ski was for a moment thinking johnw was thinking about quotient objects in `Cat' or something ..
16:17:43 <johnw> no, not yet at least ;)
16:19:01 <AWizzArd> Is there an advantage of `FlexibleContexts` being switched off by default? To me it seems that it won’t do any harm and could in principle always be available.
16:19:01 <ski> rub1k : <https://xkcd.com/1782/>
16:20:00 <ski> rub1k : welcome to the channel ! do you have access to any reading material (or video lectures, i suppose), for learning Haskell ?
16:20:08 <rub1k> ski: yeah. for you this could be satifying https://www.youtube.com/watch?v=DI5_sQ8O-7Y
16:20:46 <ski> AWizzArd : probably not, apart from discouraging people from using stuff that might perhaps not work in some other Haskell implementation
16:20:50 <phadej> AWizzArd: you don't really have use for FlexibleContexts without MPTC
16:20:56 <rub1k> ski: i have found a cool basics tutorial with an online shell, but installed it also for my linux terminal :)
16:20:58 <phadej> AWizzArd: though you may define the class in different module
16:21:17 <rub1k> it's nice that you ask
16:21:47 <AWizzArd> phadej: this would be my followup question – why should MPTC not be activated by default?
16:22:24 <AWizzArd> ski: is this really just a historical thing because there is no Haskell 2020 yet? Could this possibly become standard Haskell in some years (instead of an extension)?
16:23:20 <ski> rub1k : heh, not quite my cup of tea (that song), i suppose one could say :)
16:23:53 <ski> rub1k : ooc, what is that cool basics tutorial ?
16:24:05 <ski> AWizzArd : quite possibly, i think
16:24:17 <johnw> AWizzArd: you can submit a proposal here: https://github.com/haskell/rfcs/pulls
16:24:34 <Tuplanolla> I hope they don't forget any of the small extensions like `BinaryLiterals`.
16:24:37 <rub1k> ski: but maybe the asdf movies are fun for you. but strictly speaking I don't even know how old you are
16:25:31 <ski> AWizzArd : re MPTC (with FDs, say), some people are more proponents of associated types (and then type families). however i think the former can still have their uses. in any case it's not as obvious what the appropriate way to proceed here is
16:25:39 <rub1k> that is: https://tryhaskell.org/
16:25:54 <ski> rub1k : a bit over thirty, if you must know
16:25:58 <rub1k> it's a bit like the "swirl" library for learning R
16:26:31 <rub1k> no you need not to tell me. but to be fair: I'm 23
16:26:32 <AWizzArd> ski: are you aware of some online resource that contrasts these two?
16:26:37 <ski> @where tryhaskell
16:26:37 <lambdabot> http://tryhaskell.org/
16:26:45 <johnw> rub1k: i'm exactly twice that now
16:27:12 <ski> AWizzArd : hm, i don't think so. maybe some paper introducing/talking about ATs and TFs
16:27:20 <rub1k> johnw: so you're a wise man :)
16:28:15 <johnw> maybe people twice me are
16:28:22 <ski> rub1k : you should probably try to find some tutorial, or even a textbook, for learning Haskell
16:28:59 <rub1k> Donald Knuth just turned 80 in January, I have met him almost :(
16:29:10 <rub1k> he is a genius
16:29:34 <rub1k> ski: I have found a book from O'Reilly
16:29:34 <ski> how does one almost meet someone ?
16:29:42 <ski> ooc, which book ?
16:29:46 <ski> RWH ?
16:29:48 <rub1k> but if you have a cool tip you can tell me
16:30:03 <rub1k> "Real world Haskell"
16:30:08 <ski> i learned from "Haskell: The Craft of Functional Programming", by Simon Thompson
16:30:31 <`Guest00000> hmm
16:30:34 <rub1k> okay i search it
16:30:35 <frerich> rub1k: I very much like 'Programming Haskell, Second Edition' by Graham Hutton. I regret not having found it earlier.
16:30:51 <rub1k> you heard today that Stephen hawking died?
16:30:56 <ski> nowadays, many people seem to like
16:30:57 <ski> @where HPFFP
16:30:58 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
16:31:03 <rub1k> frerich: thx!
16:31:12 <ski> however, also people have praised e.g.
16:31:14 <ski> @where PIH
16:31:15 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
16:32:19 <dminuoso> ski: Is any of these books fun for someone at an intermediate beginner level, who knows how to build monad transformers?
16:32:22 <ski> or "The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak in 2000 at <http://www.cs.yale.edu/homes/hudak/SOE/>
16:32:32 <ski> @where SOE
16:32:32 <lambdabot> http://haskell.org/soe/
16:32:33 <`Guest00000> johnw: have you noticed that your problem is a category? did you try to apply category theory? did you get something interesting? if so, please tell me what you got
16:33:17 <`Guest00000> strings are objects, and all possible sequences of operations are arrows
16:33:21 <johnw> `Guest00000: mainly I'm interested in functors from lambda calculus to other BiCCCs
16:34:26 <rub1k> another question just for curiosity: does someone here speaks COBOL fluently?
16:34:52 <hpc> 10 PRINT "does basic count?"
16:35:06 <rub1k> hmm I'm not sure :D
16:35:13 <hpc> well i don't know basic either :D
16:35:14 <`Guest00000> everyone knows basic
16:35:30 <rub1k> it's not that I really want to learn it just asking
16:35:52 <ski> @where+ SOE "The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak in 2000 at <http://www.cs.yale.edu/homes/hudak/SOE/>,<http://haskell.org/soe/> [broken]
16:35:52 <lambdabot> Done.
16:36:14 <`Guest00000> johnw: does this problem encode that?
16:36:43 <rub1k> a friend of mine had the idea to code a transpiler for COBOL to Java
16:36:56 <johnw> `Guest00000: no, the problem I stated earlier was about making it easier to solves the proofs along the way
16:37:00 <rub1k> but this would be a hercules task
16:37:23 <ski> dminuoso : i haven't read the other three, but i suspect at least a large part of them goes through beginner stuff that such a person would already be expected to know
16:37:34 <`Guest00000> rub1k: why did they choose Java as target?
16:38:25 <rub1k> `Guest00000: just random. you could even use Python, C++, or something else...
16:38:33 * ski isn't sure why some people feel the need of inventing/using a new word "transpiler", when the established word "compiler" would do just as well ..
16:38:53 <`Guest00000> compiler is sweeter
16:38:59 <rub1k> ski: didn't know it's a neologism
16:39:00 <`Guest00000> because it compiles to machine code
16:39:09 <`Guest00000> more frequently
16:39:12 <`Guest00000> used as
16:39:17 <ski> GHC used to compile to C
16:39:29 <rub1k> a transpiler is a compiler to translate code from one to another
16:39:37 <ski> @quote mangler
16:39:38 <lambdabot> Pseudonym says: All hail the Evil Mangler!
16:39:45 <rub1k> mangler?
16:39:57 <Hijiri> is it still a compiler if the target is the same as the source?
16:40:01 <`Guest00000> maybe a transpiler is a compiler that preserves something in code?
16:40:03 <Hijiri> then you could have a category of compilers
16:40:06 <`Guest00000> something high-level
16:40:09 <rub1k> how late is it in your time zone?
16:40:18 <hpc> rub1k: an artifact of older ghc versions, that turns identifier names into something the... linker? ... can handle
16:40:29 <ski> an evil Perl script which was used by GHC to mangle the assembler output from GCC, before passing it on to the assembler, yielding object code (machine code)
16:40:33 <rub1k> `Guest00000: that's it
16:40:35 <dminuoso> ski: I blame the JavaScript community. With a great influx of career changers and other people that have little to no interesst in reading books like the Dragon Book, a compiler is quickly learned as "something that produces executable code", rather than a translation machine.
16:40:37 <hpc> ah, gcc
16:40:43 <hpc> iirc it's gone now
16:40:59 <dminuoso> ski: THe first time I've ever heard the word "transpiler" was in the JavaScript community, and boy do they like that word.
16:41:00 <ski> Hijiri : "is it still a compiler if the target is the same as the source?" -- imho, yes
16:41:03 <`Guest00000> and a compiler is more general and may not do that, so a compiler may be into native code
16:41:30 <hpc> ski: if the target language is the same as the source, i would call it a reformatter
16:41:35 <dminuoso> Hijiri: Formally a compiler is a piece of software that translates from a source language to a target language. That is the definition from Aho et al.
16:41:41 <hpc> and if it generates code that looks like it came from a compiler, i would call it a bad reformatter
16:41:59 <hpc> er, Hijiri i guess
16:42:02 <rub1k> ski: uii, seems cool. a few weeks ago I found a Perl script that emaulates an ASCIIquarium in your terminal :)
16:42:03 <dminuoso> And I consider Aho et al to be the authorative textbook on compilers.
16:42:27 * frerich isn't sure why people felt the need to introduce the term "compiler", when the established word "interpreter" would ahve done just as well. Heck, why bother with "interpreter" -- it's programs, all the way to the bottom! =)
16:42:53 <rub1k> dminuoso: then it must be because my friend works and codes primarily in JavaScript :P
16:43:02 <`Guest00000> hpc: [P : program in haskell] -> [an x86_64 emulator in Haskell which emulates P compiled to native x86_64 code]
16:43:13 <`Guest00000> deptypes again.
16:43:23 <rub1k> frerich: you have a point!
16:43:40 <`Guest00000> interpreter is a compiler
16:43:42 <`Guest00000> only lazy one
16:44:18 <`Guest00000> suspiciously, in this case lazy ones tend to be less efficient than eager ones... hehe
16:44:44 <Hijiri> what about JIT compilers?
16:45:27 <`Guest00000> it's the best intersection of compilers and interpreters
16:45:46 <Hijiri> would the worst union be an ahead-of-time interpreter?
16:45:52 <frerich> One man's data is another man's code.
16:46:00 <`Guest00000> so the worst intersection would be a usual interpreter bundled with a fixed program...
16:46:06 <`Guest00000> although
16:46:43 <`Guest00000> having an interpreter available, it's most simple to write
16:47:24 <rub1k> if anyone is coding a new programming language, is then the need to write your own compiler from scratch?
16:48:05 <Hijiri> depends what you consider a new programming language
16:48:13 <Hijiri> what if I embed my language in a lisp?
16:48:14 <Rembane> rub1k: It's usually a nice idea to start with an embedded language and an interpreter.
16:49:03 <Welkin> Hijiri: you could use racket to write your language
16:49:20 <rub1k> Rembane: okay. but as usually just asking ;)
16:49:25 <Welkin> Hijiri: have you read https://beautifulracket.com/
16:49:29 <Hijiri> nope
16:50:08 <Rembane> Racket, the language of languages.
16:50:16 <Rembane> rub1k: No worries. :)
16:50:16 <rub1k> Welkin: saw Racket on rosetta code some time ago
16:52:03 <ski> dminuoso : ok
16:52:53 <ski> hpc : well, it could be more than a reformatter, or even a meta-circular implementation
16:53:05 <ski> rub1k : hm, i think i've heard about "ASCIIquarium" before
16:53:34 <rub1k> moment i'll look up the instruction site for you
16:54:05 <rub1k> https://www.cyberciti.biz/tips/linux-unix-apple-osx-terminal-ascii-aquarium.html
16:54:20 <Welkin> lol
16:54:31 <Welkin> like the fish aquarium screensaver?
16:54:52 <rub1k> yees. live and in color
16:55:01 <ski> @tell frerich perhaps see the 2007-07-14 entry "Summarizing several issues with compilation and interpretation" in Riastradh's blag at <http://mumble.net/~campbell/blag.txt>
16:55:02 <lambdabot> Consider it noted.
16:56:55 <rub1k> Welkin: or try in terminal "sl" instead of "ls"
16:57:36 <Welkin> that does nothing
16:58:22 <rub1k> then install "sudo apt-get install sl" or whatever package manager you use
16:58:42 <rub1k> yum or pacman maybe on Fedora and Arch
17:01:30 <rub1k> I have to say I like this channel and will join it from now on when I can
17:01:56 <`Guest00000> i drew my first ever diagram, based on johnw's problem, and i feel so smart
17:03:19 <`Guest00000> 1. Non-overlapping operations are commutative
17:03:31 <`Guest00000> or are commuting?
17:04:18 <rub1k> i think you can say both
17:04:30 <`Guest00000> in the same meaning, too?
17:05:10 <rub1k> for better syntax i would say "commutative". in german "kommutieren"
17:06:03 <`Guest00000> 1.  <A| i |B+fst_j+C> .. <A+snd_i+B| j |C> = <A+fst_i+B| j |C> .. <A| i |B+snd_j+C>
17:06:55 <rub1k> `Guest00000: alien hieroglyphs? :D
17:07:57 <rub1k> Welkin: does it work now?
17:08:24 <`Guest00000> rub1k: it's a diagram, for a category which encodes johnw's problem https://github.com/jwiegley/notes/blob/master/haskell/Rewrites.hs
17:08:55 <rub1k> you can even watch the hole (real first) star wars movie in ASCII via telnet
17:09:05 <Welkin> rub1k: I am using mac
17:09:35 <rub1k> `Guest00000: ahh i see
17:09:49 <`Guest00000> for a i'th input,   <PR| i |PS> : PR+fst_i+PS -> PR+snd_i+PS   is a morphism
17:09:53 <`Guest00000> all strings are objects
17:10:02 <`Guest00000> i'th input is (fst_i, snd_i)
17:10:16 <`Guest00000> S+T - strings S and T concatted
17:11:51 <`Guest00000> (to my minus 4th message: prepend "for any strings PR, PS")
17:12:39 <rub1k> okay
17:13:17 <johnw> `Guest00000: here's the type of morphisms for such a category: https://github.com/jwiegley/category-theory/blob/master/Solver/Arrows.v#L17
17:13:21 <johnw> it's trivial to prove that the laws hold
17:16:28 <rub1k> Welkin: you are lucky it is UNIX based. maybe via brew? there is also a cool emulator a friend showed me that makes your terminal look like a kathode screen on an apple II
17:17:37 <rub1k> and who wants watching star wars in ascii try "telnet towel.blinkenlights.nl" in terminal
17:17:39 <johnw> rub1k: one thing to note is that we generally keep this channel to Haskell-related discussion, with another channel for playful banter
17:17:52 <rub1k> johnw: sorry
17:17:56 <johnw> whose name at the moment escapes me...
17:18:01 <rub1k> it's noted
17:18:02 <`Guest00000> #haskell-blah ?
17:18:04 <johnw> yes!
17:18:08 <johnw> rub1k: thanks!
17:18:32 <rub1k> I'll try to learn to follow the discussions
17:19:50 <johnw> your understanding is most appreciated
17:22:18 <rub1k> I realize now that Haskell is younger than Mathematica
17:28:05 <ski> there's also #haskell-offtopic, which is sortof its rival
17:28:58 <sepakorayl> uh guys?
17:30:03 <Rembane> Hi sepakorayl !
17:30:07 <sepakorayl> http://lpaste.net/363604
17:30:21 <sepakorayl> any idea how I can reuse this for untyped representation ?
17:30:35 <sepakorayl> basically make the kinds useless and void proof terms
17:30:51 <EvanR> .oO( ornamental algebra )
17:31:04 <`Guest00000> rival...
17:31:07 <`Guest00000> wtf
17:35:05 <sepakorayl> perhaps using type families?
17:35:18 <sepakorayl> I think ski was it that showed something similar ?
17:42:18 <EvanR> you could write a type checker that spits out "yes" or "no". but it might have a bug. so you write a function that spits out a proof that the types check, and a proof checker. now you have two problems ?
17:42:22 <EvanR> are we just screwed
17:43:10 * ski . o O ( "Ornamental Algebras, Algebraic Ornaments" by Conor McBride at <http://personal.cis.strath.ac.uk/~conor/pub/OAAO/Ornament.pdf>,<https://personal.cis.strath.ac.uk/conor.mcbride/pub/OAAO/Ornament.agda> in 2010-08-09,<http://personal.cis.strath.ac.uk/~conor/pub/OAAO/LitOrn.pdf>,<http://personal.cis.strath.ac.uk/~conor/pub/OAAO/LitOrn.lagda> in 2011-01-23 )
17:43:34 <EvanR> thanks for dredging up the links
17:44:10 <sepakorayl> this looks interesting thanks!
17:44:24 <`Guest00000> that's quite a sized thought bubble
17:44:59 <johnw> ski doesn't think small
17:45:08 <sepakorayl> btw EvanR, what do you mean now we have two problems ?
17:46:43 <EvanR> both programs may now have bugs
17:47:34 <EvanR> instead of 1
17:47:35 * ski . o O ( "The Battered Ornaments" by ibid in 2010-05-24,<https://gist.github.com/CodaFi/225e189f5c255a1bf8790f66bcf0b8ae> by ibid in 2016-04-01 ; "Ornaments in Practice" by Thomas Williams,Pierre-Évariste Dagand,Didier Rémy in 2014-05-21 at <http://morphis.me/link/ornaments-practice.pdf> )
17:48:46 <sepakorayl> well as long as the proofs are correct at least we won't accept an incorrect program
17:49:39 <sepakorayl> (although it is possible to not accept a valid one I guess)
17:51:24 <EvanR> as long as no bugs in the checker
17:51:27 <ski> (er, the battered thing was missing the link, <https://mazzo.li/epilogue/index.html%3Fp=577.html>)
17:55:39 <sepakorayl> how can the checker have bugs? I mean for instance in isTopIdentifier :: SIdentifier i -> SContext c -> Maybe (TopIdentifier i c) it is not possible to construct an invalid proof except by cheating with underfine or something.
17:55:59 <sepakorayl> undefined*
17:57:27 <EvanR> not haskell
17:58:45 <sepakorayl> what do you mean ?
17:59:38 <EvanR> my original post was about writing three programs
18:03:01 <sepakorayl> I am sorry I am confused was the original post a reply on the lpaste?
18:03:09 <EvanR> no
18:04:08 <sepakorayl> uh okay got it
18:04:12 <brunocad> Hi, I'm having a weird megaparsec issue regarding bytestrings.
18:04:12 <brunocad> http://lpaste.net/363606
18:04:53 <brunocad> I don't get why `char ':'` return a Char
18:05:20 <EvanR> do :t char
18:05:25 <EvanR> in ghci
18:06:09 <brunocad> char :: MonadParsec e s m => Token s -> m (Token s)
18:06:39 <sepakorayl> do Ornaments work when the refined type has added proof arguments for the constructors?
18:07:09 <EvanR> ah
18:07:14 <EvanR> branweb: ':' is a Char
18:07:41 <EvanR> try... char (fromIntegral (ord ':'))
18:08:16 <EvanR> in cases like these i defined w8 :: Char -> Word8, for using char constants as bytes
18:09:30 <`Guest00000> cripplingly
18:09:44 <`Guest00000> discarding higher bits in the code point
18:09:57 <`Guest00000> ewww
18:09:59 <EvanR> and only use constants < 128
18:10:00 <`Guest00000> god
18:10:03 <brunocad> yayyyy it's working thanks! But is there an automatic way of doing this? like OverloadedStrings but for char?
18:10:08 <EvanR> no
18:10:10 <`Guest00000> most mindless
18:11:15 * ski . o O ( "least mindful" )
18:11:38 <EvanR> "Char8" really is a confluence of unsound datatype combine with clumsy ergonomics
18:11:53 <EvanR> its broken and syntactically noisy
18:12:14 <EvanR> at least we dont have trigraphs anymore!
18:15:35 <`Guest00000> please kick me in the face for answering mindlessly
18:17:09 <`Guest00000> each time
18:17:18 <c_wraith> the biggest problem with .Char8 is that despite all its problems, there are cases where it is useful and not incorrect.
18:17:23 <ab9rf> heh
18:17:41 <dgpratt> I had this idea for a Haskell project today and I was thinking over how I might code it up. To be very vague, I imagine it to have a concept of a Source from which data can be obtained in at least a couple different ways, and I imagine that there would be at least a couple different types of Sources. Well this had me thinking that a Source should perhaps be defined in terms of a typeclass, but there is so much out
18:17:41 <dgpratt> there about how typeclasses tend to be overused that I'm very much second guessing myself. The other way I can imagine doing it is to define Source via an ADT and just have the operation functions case match and handle as appropriate.
18:19:29 <EvanR> c:Char c<='\DEL' |- c IsAscii
18:20:38 <EvanR> theres something like that floating around as a typeclass somewhere
18:21:13 <enterprisey> What's the actual name for the notation where you have a type constructor and then a {} immediately afterwards?
18:22:23 <sepakorayl> thanks for the Ornaments guys, I was wondering how we can abstract over indexed types that are similar to non-indexed ones
18:22:33 <sepakorayl> this is very interesting
18:23:04 <ski> enterprisey : itym s/type constructor/data constructor/. if so, then that's record notation
18:23:36 <enterprisey> ski: oh yeah, you're right. And if this were in a pattern-match, where could I find some docs about it?
18:23:51 <enterprisey> Looking for basically something like https://caml.inria.fr/pub/docs/manual-ocaml/expr.html, where I get a grammar
18:24:48 <sepakorayl> I think this may give rise to more Sized libraries in dependent languages
18:25:04 <sepakorayl> If I am thinking correctly
18:27:51 <ski> enterprisey : <https://www.haskell.org/onlinereport/haskell2010/haskellch3.html> ?
18:28:02 <enterprisey> !!!!
18:28:03 <enterprisey> tysm
18:28:15 <enterprisey> immediately bookmarked and wrote the URL on my hand
18:28:20 <ski> see the last section of that for pattern-matching
18:28:27 <ski> @where report
18:28:28 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
18:29:30 <ski> enterprisey : GHC also has some extensions, see <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extensions-to-the-record-system>
18:46:44 <lyxia> dgpratt: the best way to know is to do it and you'll know why it's a bad idea if it is or maybe it isn't that bad
19:00:37 <chloe__> hello
19:02:37 <dmj`> hey
19:04:19 <ab9rf> yo
19:07:12 <hhh> hallo
19:07:34 <sepakorayl> reaing these Ornaments resources at 4 am is not a very good idea
19:07:36 <sepakorayl> reading
19:08:28 <hhh> Solving Project Euler with Haskell, is it a good idea? It is. Thanks.
19:12:51 <ski> hhh : you're not the first one ..
19:15:48 <Welkin> hhh: no
19:16:20 <hhh> Welkin, continue please
19:16:33 <Welkin> that was all
19:16:50 <Welkin> solving math problems won't help you learn programming
19:17:45 <Welkin> additionally, many project euler exercises are not solvable using brute force
19:17:55 <Welkin> you solve them on paper using math
19:18:07 <hhh> Well, I never said I'm doing it to "learn programming" :)
19:18:19 <Welkin> well it will be a waste of your time
19:20:34 <endojelly> Welkin, what if he's just doing it for the challenge?
19:20:59 <Welkin> that misses the point of project euler
19:21:09 <Welkin> there is no challenge if you are brute forcing a solution
19:21:17 <Welkin> there is no understanding or learning happening
19:21:23 <Welkin> but whatever, it's your life
19:21:31 <endojelly> Welkin, oh, I missed that it was involving brute force
19:21:31 <EvanR> no true learning paradox
19:23:25 <endojelly> EvanR, what's that?
19:23:40 <EvanR> er, fallacy
19:23:47 <Welkin> phallacy?
19:23:56 <EvanR> https://en.wikipedia.org/wiki/No_true_Scotsman
19:24:04 <hhh> Welkin, what's the point of project euler?
19:24:09 <Welkin> hhh: math
19:24:15 <hhh> >  Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems.
19:24:17 <lambdabot>  <hint>:1:75: error: parse error on input ‘,’
19:25:43 <EvanR> and the point of math?
19:25:49 <EvanR> journal papers of course
19:27:33 <hhh> :D
19:27:49 <hhh> the point of math is to be confused :)
19:28:30 <EvanR> we can use computers to access a mathematical world
19:28:46 <EvanR> dont let math people tell you otherwise
19:31:54 <hhh> Solving math problems was the purpose of the computers.
19:32:24 <hhh> And still is :)
19:41:03 <sepakorayl> btw this is interesting
19:41:04 <sepakorayl> https://pages.lip6.fr/Pierre-Evariste.Dagand/stuffs/journal-2013-catorn-jfp/paper.pdf
19:46:51 <`Guest00000> johnw: you online?
19:47:11 <ski> sepakorayl : cool :)
19:48:12 <`Guest00000> purpose of computers = solving math problems
19:48:29 <`Guest00000> math problems = solving of problems by computers
19:52:20 <EvanR> ouroboric
19:58:26 <`Guest00000> @let data MangledWord = Mangled { reversed :: String, sorted :: String, nubbed :: String }
19:58:28 <lambdabot>  Defined.
19:58:43 <`Guest00000> @let mangle = Mangled <$> reverse <*> sort <*> nub
19:58:45 <lambdabot>  Defined.
19:58:49 <`Guest00000> > mangle "ouroboric"
19:58:52 <lambdabot>  error:
19:58:52 <lambdabot>      • No instance for (Show MangledWord)
19:58:52 <lambdabot>          arising from a use of ‘show_M715488170374333903222692’
19:58:53 <`Guest00000> daang
19:59:01 <`Guest00000> @let deriving instance Show Mangled
19:59:03 <lambdabot>  .L.hs:162:24: error:
19:59:03 <lambdabot>      • Expecting three more arguments to ‘'Mangled’
19:59:03 <lambdabot>        Expected a type, but
19:59:15 <`Guest00000> @let deriving instance Show MangledWord
19:59:16 <lambdabot>  Defined.
19:59:24 <`Guest00000> > mangle "ouroboric"
19:59:27 <lambdabot>  Mangled {reversed = "ciroboruo", sorted = "bciooorru", nubbed = "ourbic"}
20:00:13 <jchia> "f :: Text -> Text" for taking the last 2 characters instead of the first two, effectively "reverse . (take 2) . reverse": Is it better to write it as "f x = drop (length x - 2) x?
20:00:43 <EvanR> Text allows operating from the end efficiently so...
20:01:32 <EvanR> takeEnd 2
20:03:15 * EvanR attempts to understand takeEnd's code
20:03:19 <jchia> EvanR: Thanks, didn't think to look for something like that in the haddock. Data.List doesn't have something like that.
20:04:40 <EvanR> takeEnd 2 will step backwards through the text until it crosses that many characters, and return a Text slice
20:05:04 <EvanR> stepping backwards through a list is potentially much more strenuous
20:15:10 <EvanR> is there a Monoid wrapper for (>>) :: m () -> m () -> m ()
20:15:26 <EvanR> lying around somewhere
20:18:14 <jchia> :i appEndo
20:22:00 <EvanR> not that
20:24:14 <`Guest00000> EvanR https://hackage.haskell.org/package/monoids-0.3.2/docs/Data-Monoid-Monad.html
20:24:23 <`Guest00000> but it's not base
20:24:36 <EvanR> bingo
20:24:36 <`Guest00000> hence, you are discouraged
20:24:45 <`Guest00000> instead, just copy-paste into your code
20:25:32 <EvanR> or install monoids
20:27:46 <`Guest00000> yes, or copy-paste.
20:28:07 <`Guest00000> just once, just having a few new lines of code in your code,
20:28:24 <`Guest00000> or force all users to depend on a package
20:30:24 <EvanR> `Guest00000 is not what we call a "team player"
20:34:13 <`Guest00000> in which sense?
20:39:35 <pikajude> how do you install a monoid?
20:39:47 <pikajude> oh, that's a package name
20:39:49 <pikajude> got it
20:52:54 <shafox> Can someone provide simple configuration for text editor such as sublime/vscode so that I can get the type info when I hover. I have vscode with LSP HIE but it doesnt work after a few mins, It gets stuck after that. Is there any simple set up for any text editor that does "work" ?
21:46:26 <eacameron> Design question: Let's say you have some tree-like set of structures (think Table of Contents as a type). So you might have data Doc = Intro IntroDetails | Preface PrefaceDetails | Conclusion ConclusionDetails and each of those "Details" is another type, which may have more levels inside, etc.
21:48:24 <eacameron> I want to construct a way to create a "cursor" into this tree
21:49:43 <eacameron> Such that a Cursor doesn't actually carry any information about the document itself, other than some sort of indexing into the various layers
21:50:47 <eacameron> My first idea is to use some parameter on `Doc` like `Doc f` and use the `f` create a version of Doc that mirrors the path into the actual document
21:51:40 <eacameron> like `Preface (PrefaceDetails (Acknowledgements ())` (with f = ())
21:51:45 <eacameron> elvishjerricco: ^
21:53:10 <eacameron> I think this would allow me to follow the cursor into the original document and see the content there.
21:54:54 <elvishjerricco> Not sure I see what you mean by a cursor. The fact that Doc is a sum type acts kind of like a cursor on its own, in that a Doc value will only be one of those constructors
21:55:48 <eacameron> I'm not sure what I mean either. lol
21:56:03 <`Guest00000> is there an algorithm to sort a big lazy list in a way as to not load it fully in memory, yet still efficiently?
21:56:11 <`Guest00000> < O(n^2)
21:57:23 <ab9rf> canonically, that's mergesort.
21:57:49 <ab9rf> which, of course, requires that you shuffle data between files, repeatedly
21:58:00 <`Guest00000> omg
21:58:04 <ab9rf> you can't sort a list without realizing every element of the list
21:58:06 <`Guest00000> no IO...
21:58:31 <ab9rf> how are you going to sort something that isn't "loaded into memory" without doing IO?
21:58:50 <`Guest00000> ab9rf: yet, "to not load it fully in memory" isn't equivalent to "without realizing every element"
21:59:08 <ab9rf> i don't know what you mean by "load it fully into memory"
21:59:24 <`Guest00000> are you on #haskell?
22:00:42 <`Guest00000> "load it fully into memory" means force it fully before the first element of the sorted list is available
22:00:42 <ab9rf> your question doesn't make sense.
22:00:47 <`Guest00000> why
22:00:55 <ab9rf> forcing isn't the same as loading into memory
22:01:24 <`Guest00000> what's loading?
22:02:56 <hari__> hello
22:05:00 <hari__> I am wondering why this is happening ; (pure 4) 2 ---------------> 4
22:05:26 <hari__> can someone explain why ghci is behaving this way
22:05:56 <`Guest00000> hari__: 'pure' here is for the functor (e ->)
22:06:17 <ski> @src (->) return
22:06:17 <lambdabot> return = const
22:07:08 <hari__> i didn't got can you elaborate please
22:07:16 <ab9rf> > (pure 4) 10000000
22:07:19 <lambdabot>  4
22:07:23 <ab9rf> > (pure 4) error
22:07:26 <lambdabot>  4
22:07:44 <hari__> ab9rf: so why it is discarding any argument
22:07:48 <ab9rf> necaise tjat
22:07:54 <ab9rf> gaj
22:08:15 <ab9rf> because that's what pure does for that particular instance of pure
22:08:25 <ab9rf> :t pure
22:08:26 <lambdabot> Applicative f => a -> f a
22:08:30 <ab9rf> :t (pure 4)
22:08:31 <`Guest00000> of Applicative *
22:08:32 <lambdabot> (Num a, Applicative f) => f a
22:10:04 <hari__> `Guest00000: still confused, actually which instance of aplicative is used here for (pure 4)
22:10:15 <hari__> :t 4
22:10:17 <lambdabot> Num p => p
22:10:17 <ski>   pure :: a -> (rho -> a)  -- in this case, being the `Applicative (rho ->)' instance
22:10:46 <ski> `(rho ->)' is basically the same as `Reader rho'
22:10:54 <ski> @unmtl Reader rho a
22:10:54 <hari__> ski: what's rho
22:10:55 <lambdabot> rho -> a
22:11:00 <ski> any type
22:11:02 <ab9rf> hari__: just a name
22:11:11 <ski> it's a type variable, just like `a'
22:11:27 <hari__> but
22:11:31 <hari__> :t pure
22:11:33 <lambdabot> Applicative f => a -> f a
22:11:45 <ski> @type pure :: a -> (rho -> a)
22:11:46 <lambdabot> a -> rho -> a
22:12:02 <ski>   (<*>) :: (rho -> (a -> b)) -> (rho -> a) -> (rho -> b)
22:12:11 <hari__> how it becomes @type pure :: a -> (rho -> a)
22:12:24 <ski>   (f <*> g) r = f r (g r)
22:12:48 <ski> hari__ : `f' becomes `(rho ->)', so `f a' becomes `(rho ->) a', which is `rho -> a'
22:12:56 <ski> (just like `(2 *) x' is `2 * x')
22:12:58 <ab9rf> i think what hari__ is digging at is why did it choose that particular instance of applicative
22:13:33 <ab9rf> as opposed to some other instance
22:13:34 <hari__> ab9rf: yes you got it right
22:13:44 <ski> because in `(pure 4) 2', we're calling `pure 4' as a function, and so the type `f Integer' gets unified with `Integer -> a' (making `a = Integer')
22:13:55 <ski> (assuming those literals are `Integer's, for simplicity)
22:14:28 <ab9rf> basically, it's because you used (pure 4) as a function
22:14:42 <ab9rf> if you'd used it as something else, it would hve inferred a different instance.
22:15:03 <ab9rf> or failed to infer any instance at all, if there was ambiguity
22:15:14 <ski> if you used `fromJust (pure 4)', then it'd use the `Applicative Maybe' instance, since `fromJust' takes a `Maybe a' as argument
22:15:25 <hari__> yes it fails whenever I fix a type
22:15:44 <ski> if you used `reverse (pure 4)', then it'd select the `Applicative []' instance, because ...
22:15:48 <ab9rf> > (pure 4) :: [Integer]
22:15:51 <lambdabot>  [4]
22:16:07 <ski> > pure 4 :: Either Bool Integer
22:16:07 <hari__> > [4] 2
22:16:09 <lambdabot>  Right 4
22:16:10 <lambdabot>  error:
22:16:10 <lambdabot>      • Couldn't match expected type ‘Integer -> t’
22:16:10 <lambdabot>                    with actual type ‘[Integer]’
22:16:21 <ski> `[4]' is a list, is not a function, can't be applied to an argument
22:16:36 <hari__> > (pure 4) 33
22:16:36 <ski> (list type doesn't match function type)
22:16:38 <lambdabot>  4
22:17:00 <hari__> :ski yes that is okay
22:17:10 <ab9rf> does that make sense?
22:17:55 <ski> if you write `(...) (...)', then the former expression has to evaluate to a function, and the latter to a value of the argument type of that function (and the whole application is of the result type of that function)
22:18:43 <hari__> ab9rf: yes this is fine
22:19:07 <hari__> so you mean to say (pure 4) is being evaluated to a function
22:19:22 <hari__> of @type
22:19:32 <ab9rf> it's a bit hard to get used to functions as values, especially for people coming from environments
22:19:45 <ab9rf> hari__: `pure 4' by itself is ambiguous
22:19:45 <ski> it is being forced to be of a function type, because of how the context, of how the result of that expression is being used by the surrounding programing
22:19:53 <ski> s/programing/program/
22:19:58 <hari__>  pure :: a -> (rho -> a)
22:20:14 <ski> ab9rf : environments ?
22:20:17 <ski> > (if 2 > 3 then (* 2) else (^ 2)) 4
22:20:19 <lambdabot>  16
22:20:41 <ab9rf> sorry, i didn't finish that utterance :)
22:20:56 <ski> > [f 4 | f <- [(+ 2),(* 2),(^ 3)]]  -- list comprehension with list of functions
22:20:59 <lambdabot>  [6,8,64]
22:21:02 <ab9rf> environments in which functions cannot be, or rarely are, used as values
22:21:38 <ski> > let applyToFour f = f 4 in map applyToFour [(+ 2),(* 2),(^ 3)]]  -- without list comprehension, using instead `map'
22:21:40 <lambdabot>  <hint>:1:63: error: parse error on input ‘]’
22:21:47 <ski> er
22:21:50 <ab9rf> too many ]
22:21:50 <ski> > let applyToFour f = f 4 in map applyToFour [(+ 2),(* 2),(^ 3)]  -- without list comprehension, using instead `map'
22:21:53 <lambdabot>  [6,8,64]
22:22:02 <hari__> ya that's true but Haskell is my only programming language I don't have any problem to see function as values
22:22:12 <ab9rf> hari__: ah, good for you
22:22:18 <hari__> I was confused about which instance pure is using
22:22:25 <ski> > map (\f -> f 4) [(+ 2),(* 2),(^ 3)]  -- using a function abstraction / lambda expression
22:22:28 <lambdabot>  [6,8,64]
22:22:42 <ski> > map ($ 4) [(+ 2),(* 2),(^ 3)]  -- using a right section of `$'
22:22:45 <lambdabot>  [6,8,64]
22:22:50 <ski> ok
22:23:02 <hari__> well where can I find the instance pure is using in > pure 4 3
22:23:16 <ab9rf> hari__: there are a remarkably large number of instances of some typeclasses
22:23:25 <hari__> ab9rf: I feel lucky for that
22:23:38 <ski>   instance Applicative ((->) a) -- Defined in ‘GHC.Base’
22:23:49 <ski> (is what `:info Applicative' says in GHCi)
22:23:52 <hari__> ab9rf: but is the instance of function
22:24:11 <hari__> i.e. ((->) e)
22:24:16 * ski would call it the "environment instance", not the "function instance", fwiw
22:24:39 <hari__> okay environment instance
22:25:48 <hari__> > :t pure (4::Int)
22:25:51 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
22:25:58 <hari__> :t pure (4::Int)
22:26:00 <lambdabot> Applicative f => f Int
22:26:28 <hari__> :t (pure (4::Int) error)
22:26:30 <lambdabot> Int
22:26:54 <hari__> confusing~~~
22:26:59 <ski> @type pure (4 :: Int) `asAppliedTo` error
22:27:01 <lambdabot> ([Char] -> a) -> Int
22:27:15 <ski> that's the type of `pure (4 :: Int)', in `pure (4 :: Int) error'
22:27:22 <ski> @type error
22:27:23 <lambdabot> [Char] -> a
22:28:17 <ab9rf> you can apply (pure 4) to anything, because what you apply it to is never evaluate
22:28:27 <ab9rf> > (pure 4) (1 / 0)
22:28:30 <lambdabot>  4
22:28:47 <ab9rf> > (pure 4) (/0)
22:28:50 <lambdabot>  4
22:28:52 <ab9rf> > (pure 4) (/)
22:28:55 <lambdabot>  4
22:29:01 <ab9rf> > (pure 4) (pure 4)
22:29:03 <lambdabot>  error:
22:29:03 <lambdabot>      • Could not deduce (Applicative f0) arising from a use of ‘pure’
22:29:04 <lambdabot>        from the context: Num t
22:29:16 <ab9rf> > (pure 4) pure
22:29:19 <lambdabot>  error:
22:29:19 <lambdabot>      • Could not deduce (Applicative f0) arising from a use of ‘pure’
22:29:19 <lambdabot>        from the context: Num t
22:29:25 <ski> @type confusing  -- this is confusing
22:29:25 <ski> @quote a.stab
22:29:27 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
22:29:27 <lambdabot> byorgey says: <edwardk> @type (^.) <lambdabot> s -> Getting a s t a b -> a <byorgey> I would not like to be getting a stab, thank you
22:29:32 <ab9rf> but you have to have something that can be resolved to a type
22:29:49 <ski> > (pure 4) (pure :: Bool -> Maybe Bool)
22:29:51 <lambdabot>  4
22:30:27 <ski> (it didn't know which version of `pure' to use for the latter occurance)
22:30:57 <hari__> yes
22:31:16 <ab9rf> this is because the (-> a) instance of pure is const
22:31:20 <ski> > (pure 4) (fromJust . pure)
22:31:23 <lambdabot>  4
22:31:28 <ab9rf> and const does not evaluate its second argument
22:31:28 <ski> (the `(->) a' instance)
22:31:36 <ski> @src (->) return
22:31:36 <lambdabot> return = const
22:31:40 <ab9rf> yeah thanks
22:31:42 <ski> (and `pure' should be the same as `return')
22:32:27 <hari__> then why this is woking  pure :: a -> (rho -> a)
22:32:40 <hari__> (pure 4) (pure::Bool->Maybe Bool)'
22:32:49 <ab9rf> what does the type  a -> (rho -> a) represent?
22:32:49 <hari__> sorry I meant the later one
22:32:51 <ski> because there you force the return type `f a' to be equal to `rho -> a', by that type ascription
22:33:06 <ski> and so `f' becomes `(rho ->)', and it now knows which instance to use
22:33:23 <ski> ok, ditto for the latter one, except that now `f' is `Maybe'
22:34:06 <hari__> this has given me a shake in my mind .... I need to think deeper
22:34:13 <ski> (that is for the second `pure'. the first `pure' is still using the `(rho ->)' instance, with `rho' in this case being equal to `Bool -> Maybe Bool')
22:34:39 <ab9rf> hari__: think of it is as a sort of "base case" for functions
22:34:56 <hari__> ab9rf: yes
22:35:41 <hari__> maybe I would recommend you guys to write a blog explaining this behaviour .... It would be helpful for a lot of Haskell newbies
22:36:07 <ab9rf> i'm sure someone has
22:36:13 <mjrosenb> I have a 5-tuple, of Trits (data Trit = A | B | C).  I want to match a 5-tuple where the first element is A, and the next four are not A.  Is there a reasoanble way to do this?
22:36:15 <ab9rf> but that won't be me
22:36:22 <ab9rf> i write about immigration law, not haskell programming :)
22:36:35 <ab9rf> mjrosenb: ugh
22:36:56 <hari__> well Thanks a lot for clearing my doubt ...both of You ski ab9rf
22:37:27 <hari__> I will try to get what's happening here
22:38:03 <ski>   foo (A,b,c,d,e) | all (not . (A ==)) [b,c,d,e] = ...  -- perhaps ?
22:38:09 <dmj`> case x of (A,b,c,d,e) | all (/=A) [b,c,d,e]
22:38:19 <dmj`> ski: beat me to it
22:38:23 <ab9rf> probably the best you can do
22:38:25 <ski> yea, `/=' would be more reasonable, of course
22:38:29 * ski isn't thinking
22:39:12 <mjrosenb> I wonder how difficult it would be to add disjunctive patterns into GHC.
22:39:18 <mjrosenb> it already sort of has them
22:39:24 <ski> yea .. i've been missing them
22:39:26 <mjrosenb> just stupidly.
22:40:24 <ski> if one could define a pattern synonym `BC' to be such a disjunctive pattern `B | C' (or with whatever syntax, grmbl), that would do it
22:41:20 <mjrosenb> so it already has @-patterns, I think we just need to change the rule that the LHS needs to be a variable into the LHS can be an arbitrary pattern.
22:42:30 <ski> no, that would be conjunctive patterns (which would also be useful, in the presence of pattern synonyms, and view patterns)
22:42:42 <mjrosenb> err, dang, you're right.
22:43:41 <ski> (existential patterns, or variables bound only in one alternative of a disjunctive pattern, could be useful in the presence of local guards, or view patterns)
22:43:42 <`Guest00000> more sugar for the god of sugar
22:45:06 <ski> who wouldn't want to be able to factor together the first four cases of `balance' in the O'Caml code at <https://rosettacode.org/wiki/Pattern_matching#OCaml> ?
23:37:02 <shafox> Question: What text editor you use and what plugins ?
23:37:03 <cocreature> mjrosenb: there is a GHC proposal for disjunctive patterns and there is already a branch with an in-progress implementation.
23:38:37 <srk> shafox: vim :)
23:39:06 <srk> no plugins but bunch of config tweaks
23:39:29 <srk> https://github.com/begriffs/haskell-vim-now looks cool though
23:39:51 <Axman6> mjrosenb: your tuple question was so close to being just allOf each (/=A) from lens, but the requirement for the firs telement to be different form the others makes it hard...
23:40:25 <Axman6> actually, allOf (_2 <> _3 <> _4 <> _5) (/=A) works...
