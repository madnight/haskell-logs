00:06:43 <piyush-kurur> cabal-install 2.0.0.1 is giving me a curl error for cabal update. Can anyone confirm whether it is a PEBCAK?
00:07:01 <piyush-kurur> everything else is fine including new-* commands
00:08:05 <cocreature> piyush-kurur: seems to work for me™
00:10:12 <piyush-kurur> cocreature: cabal-install version 1.24 working but cabal-install 2.0.0.1, only on update giving me curl: (52) Empty reply from server
00:10:12 <piyush-kurur>  
00:11:02 <cocreature> piyush-kurur: I’ve tried 2.0.0.1 and HEAD from two weeks ago or so
00:11:45 <piyush-kurur> cocreature: I was never able to update with cabal 2.0.0.1 (same problem) and had to rely on the debian cabal (1.24) for update
00:12:06 <piyush-kurur> In fact everything else works beautifully (new-* commands I mean)
00:15:34 <cocreature> piyush-kurur: very weird, maybe try HEAD?
00:16:23 <cocreature> piyush-kurur: or maybe try playing around with https://cabal.readthedocs.io/en/latest/nix-local-build.html?highlight=curl#advanced-global-configuration-options
00:16:37 <cocreature> debian sounds like you might have a fairly old version of curl, maybe that’s causing problems
00:16:58 <piyush-kurur> cocreature: thanks here is the error message <https://pastebin.com/Qwd1mDBd>
00:19:44 <piyush-kurur> Okey made it work with --http-transport=wget but cabal gave a piece of its mind to me
00:19:51 <piyush-kurur> looks like a curl problem
00:53:05 <ZeuPiark> hello
01:07:46 <thetransformerr[> hi everybody
01:08:03 <thetransformerr[> is this the right place for gsoc discussion
01:11:00 <[exa]> thetransformerr[: there was same gsoc discussion at #ghc
01:22:47 <wz1000> thetransformerr[: #haskell-gsoc
01:23:57 <thetransformerr[> thanks very much
01:45:23 <Guest59292> hello
01:48:35 <Guest59292> hello
01:48:39 <cocreature> hey Guest59292
01:48:43 <cocreature> …
01:49:29 <kinboy_> hello
01:56:25 <merijn> What's the "warning clean" way to deal with imports of Applicative across GHC versions?
02:01:25 <foldr> Is it possible to make GHCi immediately quit on the first error?
02:02:01 <Guest59292> hello
02:05:34 <Guest59292> help
02:05:40 <cocreature> Guest59292: you need to stick around for a bit
02:05:46 <cocreature> I give up …
02:07:25 <merijn> Me: "I only use the most battle-tested old releases of GHC to avoid problems." also me: "Fuck it, let's just apply an unmerged patch on cabal HEAD and run that, what could possibly go wrong..."
02:07:50 <foldr> Similarly, is it possible to make GHCi print back all entered commands? I'd like to write my sessions in a text file and pipe them into ghci.
02:08:16 <merijn> foldr: Not really, tbh. there might be a history file somewhere
02:08:16 <[exa]> foldr: it's in  .ghc/ghci_history
02:08:21 <kinboy_> hello
02:08:35 <[exa]> cocreature: resist
02:09:46 <foldr> merijn: bummer. Guess I'll do some bash-foo :P
02:10:13 <merijn> foldr: honestly, I'd just recommend writing in a file and loading that instead
02:10:18 <cocreature> is there a way to get source spans with megaparsec when using makeExprParser? I can only figure out how to get the source span of the whole expression but not for sub expressions
02:10:18 <merijn> Depending on what you're trying to do
02:10:24 <cocreature> here’s an example to illustrate what I mean https://gist.github.com/cocreature/845109729b10e4b734d675ccc24e2a16
02:11:08 <foldr> merijn: the main problem I have is that if I do a GHCi session with the interactive readline mode, then if I make typos and other mistakes, I need to manually ignore this every time I want to read back what I did right.
02:11:20 <foldr> With a file that contains all the commands, I can just remove the mistakes I made.
02:11:49 <foldr> Sort of like Jupyter. Maybe I should just bite the bullet and try to get IHaskell to work with multiple Stack projects.
02:13:57 <cocreature> hm I suppose I can just scrape the SrcSpan of the arguments and merge them
02:18:03 <foldr> Ah, I think I can use the expect package
02:47:16 <Olgierd> hi. I try to run this example https://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec-Expr.html#buildExpressionParser, but it does not typecheck: https://pastebin.com/r2XAbcdU
02:47:19 <Olgierd> what am i doing wrong?
02:48:25 <Olgierd> i have no other code in the module but this snippet
03:04:05 <merijn> phadej: The testing settings you picked for multi-ghc-travis are driving me bonkers!
03:07:23 <brynedwards> Olgierd: https://github.com/haskell/parsec/issues/38
03:10:10 <stiell> In acid-state, is there any reasonable way to do a conditional update depending on the result of a query, such that the query and update are in one atomical operation and nothing is logged if the update is not run?
03:10:59 <jollygood2> hi
03:11:09 <brynedwards> hi
03:11:17 <jollygood2> is ioRef = unsafePerformIO $ ... still the only way to get top-level IORef?
03:12:58 <tdammers> I think so, yes, and you probably shouldn't be using it
03:16:08 <jollygood2> can you recommend me an alternative then. I want to write a thread synced putStrLn that doesn't scramble the lines from different threads. I thought about using global IORef or maybe global MVar
03:17:42 <tdammers> the clean way is to explicitly pass the required state around
03:17:44 <jollygood2> s/global/top-level (and private to my module)
03:18:08 <tdammers> well, you're essentially falling into the singleton trap here
03:18:28 <tdammers> you want a singleton instance of an IORef, such that only one can ever exist
03:18:31 <merijn> stiell: I don't think you can do that, no
03:18:44 <jollygood2> clean from whose POV? passing state around isn't very clean from library user's POV, who wants to just replace putStrLn with syncPutStrLn
03:19:25 <tdammers> the problem with that singleton instance is that it's not easy to make sure that it really is a singleton, and even then, the question is, only one instance per *what*? thread? process? computer? cluster?
03:19:55 <jollygood2> having one instance per thread wouldn't be very useful in this case
03:20:15 <tdammers> exactly, but if you implement / use this naively, you can easily end up with that
03:21:03 <tdammers> I haven't looked at it in detail, but IIRC, one of the caveats with unsafePerformIO is that it does not give you any guarantees as to the number of times it gets executed
03:21:06 <jollygood2> stdoutMvar = unsafePerformIO $ ... <- that would be one instance per process, yes? which is what I believe I want
03:21:30 <merijn> jollygood2: You *have* to NOINLINE that
03:21:41 <jollygood2> and then wrap printing in withMVar stdoutMvar
03:21:42 <tdammers> ^ this
03:21:46 <merijn> jollygood2: unsafePerformIO doesn't guarantee things are only run once
03:21:54 <jollygood2> yeah I know
03:21:59 <merijn> jollygood2: unsafePerformIO is you promising "I don't care how many times this runs"
03:22:06 <tdammers> so you can still end up with one instance per invocation, or one instance per call site, instead of one per process
03:22:08 <jollygood2> {-# NOINLINE stdoutMvar #-}
03:22:15 <jollygood2> I have that
03:22:42 <jollygood2> so no issues? and no better alternatives? I would rather avoid unsafePerformIO if I can
03:22:42 <barrucadu> Passing satte around is less clean than invisible global state?
03:22:49 <barrucadu> *state
03:23:20 <tdammers> hidden complexity is superficially cleaner
03:23:52 <jollygood2> barrucadu from the callers perspective, yes. syncPutStrLn state ... is less clean than syncPutStrLn "...".
03:24:01 <tdammers> It's like throwing all the crap that's littered on your bedroom floor into a big bag and then locking that in the closet. There, now the room is perfectly tidy.
03:24:16 <jollygood2> allowing user to handle the crap is better?
03:24:34 <jollygood2> and possibly handle it wrong. as opposed to hiding it away in my library, ensuring it is used correctly
03:25:07 <tdammers> the user doesn't really get to handle it in a way that they can fuck it up
03:25:22 <tdammers> you hide the IORef or MVar or whatever behind an opaque API
03:25:27 <jollygood2> how can they fuck it up if stdoutMVar isn't exported
03:25:47 <jollygood2> they can fuck it up if i force them to handle state in several ways
03:25:51 <merijn> jollygood2: One example: Suppose two different dependencies both use your library?
03:26:12 <jollygood2> what is the problem there?
03:26:24 <barrucadu> Why not provide both ways?  MyLibrary.Internal which exposes the explicit state-passing approach, and MyLibrary which uses unsafe tricks to hide that.
03:26:39 <barrucadu> Then you get the advantages of both
03:26:48 <pavonia> When you have that unsafePerformIO in an extra function, say `createVar', do you also have to NOINLINE each function that makes use of `createVar'?
03:26:58 <tdammers> safePutStrLn :: SafeContext -> String -> IO ()
03:26:58 <jollygood2> I don't see any advantages of requiring user to pass state around though
03:27:18 <tdammers> withSafeContext :: (SafeContext -> IO a) -> IO a
03:27:27 <tdammers> and then you don't export any constructors for SafeContext
03:27:38 <tdammers> there, impossible to fuck up for users unless they really really want to
03:27:42 <jollygood2> tdammers what does that give me over putStrLn with global mvar?
03:28:03 <tdammers> it gives you the ability to enforce that users are passing a properly initialized mvar
03:28:09 <jollygood2> tdammers very possible.. like creating state in a function. people do it with random seed all the time, for example
03:28:37 <tdammers> users cannot call your function unless they have a SafeContext value
03:28:52 <tdammers> and since you haven't imported any other way to construct one, they have to go through withSafeContext
03:29:19 <jollygood2> if they are creating SafeContext in a function then it becomes useless, because different threads will use different Context
03:30:03 <jollygood2> that is one bug that can happen with user supplied state that can't happen with non-exported global state
03:31:10 <tdammers> yes, but it will be obvious
03:32:57 <tsjoaquim> Hello everyone, everything good?
03:33:01 <tdammers> in fact, if you use the global, users could also accidentally trigger the unsafePerformIO from multiple threads, creating multiple mvars
03:33:12 <tsjoaquim> I would like to promote my work, I am a developer and I created a portal for web mining that is available at http://www.supermine.club.
03:33:20 <jollygood2> tdammers how?
03:33:26 <tsjoaquim> Anyone who can at least give feedback will already be helping a lot !!!
03:33:40 <tsjoaquim> Thank you guys!!!
03:33:49 <ertes-w> helo
03:35:22 <tdammers> jollygood2: as stated before, unsafePerformIO doesn't guarantee that it gets executed exactly once, so if users write code that causes it to be evaluated multiple times, from different threads, then you get multiple copies of your MVar - or at least, that would be correct behavior, so even if you test your code and that doesn't happen, doesn't mean a future GHC release won't change it such that it can happen
03:35:41 <tdammers> because, again, the contract for unsafePerformIO is "it's OK for this to run more than once"
03:36:08 <jollygood2> tdammers doesn't {-# NOINLINE stdoutLock #-} ensured unsafePerformIO will be performed only once?
03:36:24 <tdammers> no, not necessarily
03:36:36 <tdammers> it just means that stdoutLock won't be inlined
03:36:55 <lyxia> withSafeContext :: ReaderT SafeContext IO a -> IO a    then only use that once at the top:   main = withSafeContext $ ...   no way to get it wrong unless you mean it.
03:37:03 <tdammers> that is, the compiler won't substitute the definition for the variable anywhere at compile time
03:37:34 <tdammers> lyxia: yeah, that's pretty much exactly what I intended, except I wrote it without ReaderT
03:37:47 <lyxia> indeed
03:38:04 <tdammers> but there's another problem here, namely that you also need to spawn a thread to do the actual printing
03:38:13 <jollygood2> tdammers, what could user write that could cause top-level, NOINLINE variable initialized with unsafePerformIO to be executed more than once?
03:38:17 <lyxia> ah
03:38:32 <tdammers> which isn't actually a problem, because it reveals another design flaw
03:39:08 <tdammers> so I guess what you really want is withLogger :: (String -> IO ()) -> (LoggingContext -> IO a) -> IO a
03:40:22 <tdammers> or maybe even a monad transformer such that runLogger :: Monad m => (String -> m ()) -> LoggerT m a -> m a
03:40:23 <dminuoso> Do you folks have a recommendation what mechanism to use for exceptions? Is there some less opinionated article that goes into when (and how wrt to program composability) to use Control.Exception, ExceptT, MonadThrow, Maybe, etc?
03:40:45 <jollygood2> lyxia, would this work? main = withSafeContext $ do line <- getLine; syncPutStrLn line
03:41:10 <jollygood2> I'm guessing it wouldn't
03:41:16 <tdammers> jollygood2: why would it not?
03:41:25 <tdammers> jollygood2: or actually, it would have to be:
03:41:42 <lyxia> you will need to use the lifted versions of these functions indeed
03:41:46 <jollygood2> I don't know. I assumed everything in do would need to include ReaderT SafeContext
03:41:51 <tdammers> main = withSafeContext $ \context -> do { line <- getLine; syncPutStrLn context line }
03:42:15 <tdammers> or with the ReaderT, you'd have to say something like:
03:42:52 <tdammers> main = withSafeContext . runReaderT $ do { line <- liftIO getLine; syncPutStrLn context line }
03:42:59 <jollygood2> lyxia so it complicates things. it introduces bugs that can't happen with encapsulated top-level context hidden in library. for no functional gain that I can see
03:43:16 <tdammers> which bugs would it introduce?
03:43:23 <jollygood2> I already mentioned one
03:43:45 <tdammers> which one was that?
03:43:55 <jollygood2> another: user gets bored lifting things, and creates it's own top-level context, but forgets to NOINLINE it
03:43:59 <lyxia> the gain is to not use unsafePerformIO because there are no guarantees about it
03:45:53 <tdammers> jollygood2: you can't prevent the user from unsafePerformIO-related trouble if they introduce it themselves
03:46:30 <jollygood2> what do you mean there are no guarantees about it? I've never heard that top-level IORef created with unsafePerformIO is problematic. I recall even Simon listing that as one of the valid uses of unsafePerformIO
03:47:32 <tdammers> under certain conditions
03:48:19 <jollygood2> are those conditions met in my example?
03:57:28 <lyxia> Is it not possible that two threads evaluate the ioRef for the first time at the same time and get two copies of it?
04:00:24 <jollygood2> lyxia https://hackage.haskell.org/package/base-4.11.0.0/docs/System-IO-Unsafe.html
04:01:14 <lyxia> OK
04:01:14 <jollygood2> I believe this is only possible with unsafeDupablePerformIO, not unsafePerformIO
04:17:56 <lyxia> Maybe it's actually fine for global variables, as one of the semi-officially supported uses of unsafePerformIO.
04:32:03 <fendor> can i benchmark a function in criterion that utilises memoization?
04:34:42 <mcgroas> What are the big differences between wreq and req? Ive been using wreq in my latest project and its pretty smooth, but should I be using req? Or even servant-client?
04:45:43 <brynedwards> mcgroas: req author's motivation https://github.com/mrkkrp/req#motivation-and-req-vs-other-libraries
04:47:03 <lyxia> fendor: I can't see any problem with that
04:59:56 <cemerick> Good morning, friends. I opened a topic, RFC re: how and why the haskell language and community have grown so positively over the last ~10 years. https://www.reddit.com/r/haskell/comments/867dq2/haskell_has_grown_and_changed_in_amazing_ways/
05:04:16 <cocreature> phadej: I’ve probably said that before but thanks again for tree-diff!
05:15:37 <phadej> cocreature: cheers
05:53:11 <oo_miguel> while with "(,) Int" I can get a tuple type of kind (* -> *) With the left parameter fixed to Int, Is there a way to fix the second parameter?
05:53:45 <dminuoso> oo_miguel: You could use a Flip newtype
05:54:08 <oo_miguel> dminuoso: I will have to define this Flip newtype myself right?
05:54:12 <dminuoso> (or a Flip type family)
05:54:17 <dminuoso> Which might be easier to use.
05:54:32 <dminuoso> Or.. no that wont work easily.
05:54:43 <cocreature> oo_miguel: https://hackage.haskell.org/package/bifunctors-5.5.2/docs/Data-Bifunctor-Flip.html#t:Flip
05:54:58 <cocreature> dminuoso: you can’t make instances for that and you can’t partially apply it so it’s mostly useless
05:55:25 <dminuoso> cocreature: Yeah I immediately realized that. Though the partial application you could solve with defunctionalization.
05:57:11 <oo_miguel> ok I will have a look at the Bifunctors, thanks
05:57:44 <dminuoso> oo_miguel: Well if you just want flip, you can create it on the spot
05:57:55 <dminuoso> newtype Flip f a b = Flip { unFlip :: f b a }
06:01:04 <oo_miguel> but this will force me to use the Flip as type everywhere right?
06:01:53 <oo_miguel> I will not be able to write a Functor for the (_,a) type but for a "Flip (_,a)" type only
06:04:02 <cocreature> oo_miguel: imagine you could write a Functor for (_, a), what would "fmap (+1) (1,1)" do?
06:04:16 <cocreature> now you have two Functor instances and no way to decide which one to use
06:04:37 <oo_miguel> apply +1 to the first part of the tuple
06:04:40 <oo_miguel> (2,1)
06:04:49 <cocreature> but there is also a Functor instance for (a,_)
06:04:55 <cocreature> how should GHC know which one it should use?
06:04:58 <kuribas> how do you represent a CONS in template haskell?
06:05:03 <kuribas> (list CONST)
06:05:53 <oo_miguel> cocreature: I am aware there already is a functor for tuples. We can take (,,) as an example then
06:06:31 <oo_miguel> I can only wirte a functor that will fmap over the last part of it right?
06:06:35 <cocreature> yes
06:06:38 <oo_miguel> ok
06:06:59 <oo_miguel> just wanted to make sure, If I understand it correctly. I can live with this limitation :P
06:07:26 <oo_miguel> thank you
06:07:44 <cocreature> if you find yourself wanting to map over the first element of a tuple, Bifunctor is probably a better solution than Flip
06:08:50 <oo_miguel> allright, will have a look at them (probably later). My question was more of theoretical nature since I am learning haskell.
06:09:04 <Olgierd> brynedwards: thank you!
06:11:50 <fendor> lyxia, well, after the first execution, the remaining benchmarks finish within 0.001 second, ultimately changing the outcome
06:12:52 <kuribas> why does TH have a list pattern, but not a cons patterN
06:12:53 <kuribas> ?
06:13:53 <Psybur> God dammit, what do we call this, the Haskell version of the rickroll? A (co)monad is just a (co)monoid in the category of endofunctors. lmao right when The non co version of that clicks, I google comonad and get rolled.
06:15:12 <kuribas> perhaps "ConP listCons [x,xs]", but what is listCons then?
06:19:52 <lyxia> fendor: Yes you have to separate the memoization so you can reset it.
06:20:51 <fendor> lyxia, can i do that in criterion or do i have to change the code?
06:21:17 <dminuoso> Psybur: For hilarity, Applicatives too are monoids in the category of endofunctors.
06:21:46 <lyxia> fendor: you have to change your memoization implementation to be modular
06:21:56 <dminuoso> Although it's better to say "... in _a_ monoidial category of endofunctors"
06:22:12 <dminuoso> The common joke implies that there is only one monoidial category..
06:22:21 * kuribas found it, it's '(:)
06:22:32 <Psybur> dminuoso, isnt there only one though? Its called Hask? :D
06:22:52 <Psybur> Well, in Haskell code anyway
06:23:04 <dminuoso> Psybur: Monidial category implies you have some bifunctor and an identity.
06:23:34 <dminuoso> Psybur: It's like there is not just _one_ monoid on integers. There are at least 2 - probably even more.
06:23:36 <mnoonan> this is some high-quality joke-killing :)
06:24:23 <dminuoso> Psybur: iow a monoidial category is not just Hask, it's (Hask, :.:, Identity)
06:24:36 <dminuoso> Or wait.. not Hask..
06:24:44 * dminuoso steps back
06:28:00 <dminuoso> I guess its (Endo, :.:, Identity)?
06:28:12 <dminuoso> Or (Endo, Day, Identity) for Applicatives
06:28:22 <dminuoso> Or am I confusing things?
06:28:30 <ertes-w> mnoonan: nothing kills the joke more than actually getting it
06:28:34 <Psybur> Dayy lmao. Whats Day? Thats a new one!
06:28:46 <dminuoso> Psybur: The Day convolution operator.
06:29:06 <Psybur> That sounds like a joke heh.
06:29:18 <Psybur> As if things need to be more convoluted :D
06:29:29 <dminuoso> Psybur: Basically Monad allows you to do (M :.: M) a ~~> (M a)
06:29:45 <dminuoso> Psybur: Applicative allows you to do (F `Day` F) a ~~> (F a)
06:29:47 <Psybur> https://hackage.haskell.org/package/contravariant-0.6.1/docs/Data-Functor-Day.html
06:30:14 <Psybur> Dude, theres a dap function hell yeah I love exchanging daps with my FP homies
06:31:03 <Psybur> Is there a package that ISNT maintained by edwardk ? heh
06:31:11 <dminuoso> "Applicatives are monoids in the monoidal category of endofunctors, with the Day convolution operator as the Bifunctor"
06:31:16 <dminuoso> See, you can retell that joke for Applicative.
06:32:40 <Psybur> Ah, the ncatlab hole. Hold my beer, Im going in!
06:33:46 <merijn> <3 new haddock
06:35:52 <fendor> lyxia, how can i write the memoization function to be modular?
06:35:55 <merijn> On a slightly related note: I need some help naming things, currently I have a "Handler" datatype for specifying how to handle certain errors in my library, but sadly that of course clashes with Handler in Control.Exception. Any suggestions for alternative names?
06:36:50 <cocreature> merijn: the qiuckjump feature or is there anything else that’s new that I don’t know? :)
06:37:05 <merijn> cocreature: You can now have it document reexported modules inline!
06:37:17 <cocreature> merijn: woah!
06:37:35 <merijn> cocreature: Especially nice when you only import SOME things from a module and it will correctly limit the reexport
06:37:59 <Psybur> merijn, ErrorHandler? :D
06:39:00 <merijn> cocreature: I was harrying people about adding that only to be told "we're adding that in the 8.4 release", so I've been playing with it now and it's pretty sweet
06:39:43 <cocreature> yeah sounds pretty nice
06:40:28 <fendor> lyxia, furthermore, is that a more meaningful way to measure the performance? part of the performance advantage is that further usage will take a lot less time...
06:40:30 <merijn> cocreature: The nice thing is that you can do "module Xyzzy (bar, baz, module Foo) where import Foo hiding (bar, baz)" and define a local bar/baz
06:41:08 <fendor> i think i refine my question, can i benchmark a memoization function against a function that does no memoization in a meaningful way? intuitvely, i'd say no
06:41:13 <merijn> cocreature: So you can have a module shadow some parts of your API without ending up with a module that just has 1 line of "module reexport" at the bottom
06:43:41 <merijn> In other news (this might be an old feature), but I also just discovered the -P option on "cabal upload" which, rather than prompting you for a password will run an external process and read it from stdout, so I can have it read my hackage password from my keychain and not have to remember it :)
06:44:39 <lyxia> fendor: Making it modular would allow you to reset memoization to easily benchmark different usage patterns in the same execution.
06:44:55 <lyxia> fendor: you could also restart the benchmark to do that
06:45:40 <merijn> I swear, naming things is the hardest thing about programming :\
06:47:35 <cocreature> merijn: you can also put password-command in ~/.cabal/config
06:47:40 <Psybur> Do you guys ever use Comonads? Im reading that its basically object oriented programming when youre using them
06:47:47 <dminuoso> Psybur: Yes.
06:47:56 <merijn> cocreature: hmm, I didn't see that documented anywhere?
06:48:02 <merijn> cocreature: What's the option name?
06:48:09 <dminuoso> Psybur: Cellular automata and certain types of image/video filters are comonadic.
06:48:17 <cocreature> merijn: I just told you: “password-command”
06:48:21 <cocreature> :)
06:48:27 <fendor> lyxia, ok, but how can I improve the modularization? https://pastebin.com/K30Qb6an
06:48:31 <dminuoso> Psybur: And it's not really object oriented programming as far as I can tell.
06:49:08 <Psybur> Guess Ive got another article to read http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
06:49:13 <lyxia> fendor: there are many things to benchmark, and not all of them require the level of control over memoization I was talking about, for example if you're just benchmarking the cost of lookups.
06:49:41 <dminuoso> :t extend
06:49:43 <lambdabot> error: Variable not in scope: extend
06:49:56 <merijn> cocreature: Now I just need a way to have OS dependent flags in ~/.cabal/config and I'll be happy :>
06:50:32 <dminuoso> Psybur: Do you know Store?
06:50:37 <Psybur> no
06:50:39 <fendor> lyxia, hm i wanted to benchmark some function binom :: (Integer, Integer) -> Integer, but maybe criterion is not the best fit for this task
06:50:48 <dminuoso> Psybur: Do you know how a function is the generalization of a container?
06:51:16 <cocreature> nice, I managed to get my megaparsec parser into an infinite loop by adding an eof <|> somewhere
06:51:21 <Psybur> I can see how its like a container until its evaluated
06:51:26 <dminuoso> Psybur: A container - losely speaking - is basically something you can read at a certain position (the argument), and you get a value back (the return value)
06:51:47 <dminuoso> Psybur: So `Store` is just that, except it also tags a "current position in the container" along side.
06:52:35 <robstr> is there a function that catch the exception and return a default value ? I want to use this with `getEnv` ?
06:52:45 <dminuoso> Psybur: And no, its not like a container until its evaluated. The function _itself_ is the container.
06:53:02 <merijn> robstr: use lookupEnv and fromMaybe?
06:53:25 <robstr> merijn: perfect , ty
06:54:08 <dminuoso> Psybur: The generalization of `list` is something like: `List a = List { runList :: Int -> a }` where information is indexed by an Int
06:54:56 <Psybur> dminuoso, I mean the function is "containing" a value until its evaluated. Yes, the function is a container theoretically, and can be seen acting as one when you define a function (putting the value in) and evaluating it (taking it out)?
06:55:13 <lyxia> fendor: http://lpaste.net/363951 maybe, I'm not sure whether GHC is going to float out the local definitions here.
06:55:28 <dminuoso> Psybur: well by definining it, you are putting a lot of values in. and you dont evaluate functions, you apply them to arguments.
06:55:36 <dminuoso> and "applying to arguments" means "accessing the container"
06:55:53 <dminuoso> Psybur: So with that aside, a `Store` is a container with some "current" position
06:56:59 <lyxia> fendor: In any case I don't think the problem lies with criterion, but more that it's not clear what you want to benchmark exactly.
06:57:44 <cocreature> hm "manyTill anyChar eof" just seems to run into an infinite loop in megaparsec
06:58:27 <tdammers> how about many anyChar <* eof?
06:59:05 <cocreature> tdammers: that doesn’t work in my case, I actually have something like "manyTill anyChar (eof <|> …)"
06:59:18 <cocreature> I’m trying to do error recovery so I either want to sync up on the next declaration or on eof
06:59:20 <tdammers> I see
06:59:31 <cocreature> but I’m not sure how to get the “or on eof” part
06:59:50 <robstr> How could I write something like `fromMaybe 5432 $ read <> (lookupEnv "PORT")` with two levels ?
07:00:20 <tdammers> idk, wouldn't manyTill stop on eof anyway?
07:00:42 <dminuoso> Psybur: Now try defining the `Comonad` instance for `newtype Store s a = Store (s -> a) s`
07:00:52 <tdammers> robstr: what do you mean, two levels? like try multiple env vars before giving up and defaulting?
07:01:05 <fendor> lyxia, i want to benchmark to different implementations of the function binom :: (Integer, Integer) -> Integer. But yes, i dont think criterion is the problem either, the different implementations are also different in their fundamentals, maybe that is just not automatically quantifyable
07:01:13 <dminuoso> Psybur: I think this is impossible to implement incorrectly without failing to typecheck.
07:01:27 <Psybur> dminuoso, I was just about to look in Control.Comonad.Store heh
07:01:32 <robstr> tdammers: my example doesnt compile because its IO (Maybe String) ... the read should move two levels if this makes sense
07:01:37 <dminuoso> Psybur: Roll it yourself, its much more fun and enlightening.
07:01:41 <cocreature> tdammers: it does stop but it stops with a failure, I’d like it to succeed. maybe seeing the parser is helpful: http://lpaste.net/363952
07:01:48 <dminuoso> (Its also simple, because there's only one way to implement it)
07:02:19 <tdammers> robstr: follow the types
07:02:24 <tdammers> :t lookupEnv
07:02:26 <lambdabot> error: Variable not in scope: lookupEnv
07:02:35 <tdammers> @let import System.Environment
07:02:37 <lambdabot>  Defined.
07:02:38 <tdammers> :t lookupEnv
07:02:39 <lambdabot> String -> IO (Maybe String)
07:02:40 <dminuoso> Psybur: (Store will give a good intuition, because most Comonad instances behave the same - so unlike Monad there's a very domain specific pattern to it)
07:03:19 <tdammers> robstr: so you need to fmap through two applicatives, IO and Maybe
07:03:33 <dminuoso> i.e. NonEmpty, Tree and Store at least are rather similar. So understanding any will make the others click too
07:04:18 <ertes-w> and perhaps try implementing it for (data Store s a = Store (s -> a) s) instead
07:04:22 <tdammers> robstr: i.e., fmap twice
07:04:27 <merijn> cocreature: Are you using enough "try" to allow backtracking?
07:05:02 <Psybur> ertes-w, why data instead of newtype?
07:05:16 <tdammers> cocreature: right, yes, what merijn said - the problem is probably not eof itself, but rather one of the other stop conditions
07:05:27 <ertes-w> Psybur: ask GHC =)
07:05:41 <cocreature> if I remove all other conditions and only have "manyTill anyChar eof" it still seems to loop
07:05:42 <tdammers> robstr: http://hackage.haskell.org/package/functor-infix-0.0.5/docs/Data-Functor-Infix.html could be useful if that's your taste
07:06:10 <ertes-w> Traced is also similar to Store…  it's a variant that always points at mempty
07:06:43 <ertes-w> newtype Traced s a = Traced (s -> a);  instance (Monoid s) => Comonad (Traced s)
07:06:59 <ertes-w> but Store is almost always the better choice
07:07:24 <dminuoso> ertes-w: Oh right. I just typed that from my head without thinking that newtype has this arbitrary restriction.
07:07:31 <dminuoso> from the top off my head even!
07:07:33 <ertes-w> in fact for a similar reason to why State is almost always better than Writer
07:07:41 <ertes-w> dminuoso: it's not arbitrary =)
07:08:06 <dminuoso> ertes-w: Whats the reason?
07:08:49 <ertes-w> dminuoso: for Store being better?
07:09:06 <dminuoso> ertes-w: No, for it not being arbitrary
07:09:38 <ertes-w> dminuoso: a newtype is run-time-identical to the type it wraps
07:10:29 <dminuoso> ertes-w: Ah so `newtype Store s a = Store (s -> a) s)` wouldn't be a newtype "alias", since there's no single type to be mapped.
07:10:54 <cocreature> ah got it, the spaceNewline was the problem.
07:10:58 <ertes-w> the point of newtype is to provide a wrapper without run-time cost that you can use for safety or for alternative instances
07:12:18 <ertes-w> dminuoso: you can newtype-wrap tuple types, if you want products, although in that case there is no real point in using newtype in the first place
07:12:38 <ertes-w> newtype V3 a = V3 (a, a, a)
07:12:43 <ertes-w> data V3 a = V3 a a a
07:13:20 <dminuoso> ertes-w: well you couldn't make an instance for `(,) s (s -> a)` in Haskell 98/2010
07:13:36 <dminuoso> or uhh
07:13:59 <dminuoso> My brain is melting Im gonna go back to work.
07:14:08 <ertes-w> dminuoso: you should use 'data' for sums and products
07:14:41 <ertes-w> dminuoso: the premise for using newtype is that you have a specific type you want to wrap for safety, or you want to use alternative instance semantics
07:15:31 <ertes-w> (s, s -> a) would be such a type, and (data Store s a = Store (s -> a) s) is another one…  so you need to pick between these two *first*
07:15:58 <ertes-w> and you will most likely pick 'data', in which case using 'newtype' becomes pointless, because you can just write the instance for Store directly
07:16:23 <ertes-w> if you pick the tuple all your pattern-matches will look like this:  f (Store (p, g)) = …
07:23:16 <robstr> tdammers: thank you
07:26:18 <Arguggi> I'm trying out beam, following this tutorial: http://travis.athougies.net/posts/2016-01-21-beam-tutorial-1.html , but instance Database ShoppingCartDb gives me a type error: http://lpaste.net/363956 , any ideas?
07:27:56 <merijn> Well, ShoppingCartDb seems to have the wrong kind...but since you didn't show what ShoppingCartDb is it's hard to say?
07:29:20 <Arguggi> sorry, I copied the tutorial verbatim, code:  http://lpaste.net/363957
07:30:21 <merijn> Arguggi: That tutorial is 2 years old, are you sure it's still accurate?
07:31:37 <merijn> Alternatively, without looking at stuff too much it looks like it's expecting "UserT f" rather than "f UserT"
07:32:06 <Arguggi> merijn, this was updated a couple of months ago, https://github.com/tathougies/beam/blob/master/Doc/01-BasicTutorial.lhs , seems to be the same
07:34:53 <jchia_1> How do I go about understanding megaparsec error messages, e.g.: "TrivialError (SourcePos {sourceName = \"\", sourceLine = Pos 1, sourceColumn = Pos 1} :| []) (Just (Tokens ('H' :| \"bSeparateCancel,A\")))...
07:37:34 <jchia_1> How do I at least tell the input text that it's puking on?
07:43:58 <xandaros> Do we not have a split function for strings? I can only find them for text and bytestring. (Basically, I want words, but where "word " returns ["word",""] instead of ["word"]
07:47:17 <Taneb> xandaros: sadly it does not seem like there's something of that sort in base.
07:47:25 <Taneb> xandaros: but have you seen the split library?
07:47:28 <dminuoso> > splitOn "." "foo."
07:47:30 <lambdabot>  ["foo",""]
07:47:35 <dminuoso> > splitOn "." "foo.bar"
07:47:37 <lambdabot>  ["foo","bar"]
07:47:47 <Taneb> http://hackage.haskell.org/package/split-0.2.3.3/docs/Data-List-Split.html
07:48:12 <xandaros> I have not. Guess I'll just use that, than
07:48:24 <xandaros> I feel like this should be in base, though :P
07:48:33 <the_2nd> I use megaparsec's parse parseFile "foo" input   where input is a String delimited with "\n" . Yet all error messages of megaparsec only refer line 1 as if all input was a single line. Any way to fix this?
07:48:38 <Taneb> Oh, certainly, xandaros
07:49:11 <dminuoso> Wow.. hackage is again slow as slime..
07:50:48 <xandaros> > splitOn " " ""
07:50:51 <lambdabot>  [""]
07:50:53 <Taneb> dminuoso: it's not too bad for me?
07:51:01 <xandaros> This is even better than I thought. It's exactly what I need :D
07:51:32 <dminuoso> Taneb: Its responding again. Over the past few days there are moments when hackage seems to hang for a few minutes.
07:51:38 <Psybur> @let import Control.Comonad.Store
07:51:40 <xandaros> (Though, admittedly, I'd expect `splitOn " " ""` to be []... I do need exactly this, but I feel like that's a bit surprising)
07:51:40 <lambdabot>  <no location info>: error:
07:51:41 <lambdabot>      The package (distributive-0.5.3) is required to be trusted but it isn't!
07:52:11 <edwardk> there are many many days when safe haskell makes me sad
07:52:46 <Psybur> dminuoso, I had to cheat :D Does that mean I fail?!
07:52:53 <dminuoso> Psybur: Yes.
07:53:47 <Psybur> My brain falls apart with duplicate and extend. So if I duplicate a store, instead of passing in an s, I have to pass in a Store s?
07:53:52 <Psybur> For extract
07:54:11 <Psybur> If I duplicate a Store, the new indexes are Stores themselves?
07:54:17 <dminuoso> Psybur: The thing is, since you dont know _anything_ about the types involved, there's nothing you can use.
07:54:28 <dminuoso> All you have is the ability to make stores, pattern match to peek inside
07:54:30 <dminuoso> And that's it.
07:54:40 <dminuoso> Psybur: Not the new indices.
07:54:43 <dminuoso> Psybur: The new _values_
07:54:52 <Psybur> Oh right
07:54:56 <dminuoso> Psybur: so each value is replaced with a store that has its position set to that position.
07:56:07 <Psybur> So how come this fails, when I try to get the Store at index 2? extract (duplicate (Store (*1) 2)) 2
07:56:34 <dminuoso> Psybur: check the type signature of extract.
07:56:42 <dminuoso> Psybur: tell me with your own words, what extract does for Store
07:57:04 <Psybur> Oh woops, I forgot that extract doesnt take an index
07:57:15 <Psybur> The current store contains the index
07:57:22 <dminuoso> extract :: w a -> a
07:57:58 <Psybur> Yes removing 2 gave me the store
07:58:28 <dminuoso> Psybur: Have you also written the Functor instance?
07:58:38 <Psybur> I had to cheat on that one too :D
07:58:54 <Psybur> Store (f . g) x
07:59:10 <merijn> hmmm, if I have an "Internal" module for exposing details to users and another actual internal module that's not exported, what should I name each? >.>
08:00:04 <dminuoso> Psybur: You could have come up with both implementations on your own really.
08:00:43 <barrucadu> ReallyInternal
08:00:56 <dminuoso> Psybur: The next time you can't make it type check you might want to step back and analyze the situation. There's very little value in "cheating" in situations like these, because the goal is not to end up with a working implementation - but figuring out how and why it works. =)
08:01:03 <Psybur> dminuoso, well I was reading more about what a Store is and how theyre used, and of course you get the instances all shoved in your face up front :D
08:01:17 <the_2nd> is there something similar to words and unwords, which preserves the exact spacing?
08:01:39 <the_2nd> > unwords . words $ "this is     a        test"
08:01:42 <lambdabot>  "this is a test"
08:01:53 <merijn> barrucadu: :p Yeah, right now I have the exposed Internal module listed as "Utils", but I don't think that has a sufficiently "Don't touch, danger!" vibe
08:03:06 <av> Hi everyone, quick question: I need to read very large files (tens of GB each) of ASCII data, consisting of a constant number of floating-point numbers in each line, plus a blank line every now and then.  Currently I use words and read for parsing each line, but I'm wondering if that ruins my performance.  Would attoparsec or parsec be noticeably faster?
08:03:24 <merijn> av: Oh god yes
08:03:31 <merijn> av: read is *stupid* slow
08:03:32 <Psybur> Lets see how this article works for me https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/cellular-automata
08:03:37 <merijn> av: String is *also* stupid slow
08:03:41 <xandaros> the_2nd: I like how I had a very similar question earlier :D There is a "split" library that can do that
08:03:55 <xandaros> > (split . onSublist) " " "this is      a        test"
08:03:58 <lambdabot>  error:
08:03:59 <lambdabot>      Ambiguous occurrence ‘split’
08:03:59 <lambdabot>      It could refer to either ‘Data.List.Split.split’,
08:04:04 <merijn> av: I wouldn't not be surprised if switching to attoparsec + a streaming library like conduit/pipes wouldn't speed up your code 100x and use less memory
08:04:05 <xandaros> > (Data.List.Split.split . onSublist) " " "this is      a        test"
08:04:07 <dminuoso> Psybur: The Functor instance is so trivial, since I told you that the "input" is the index, the "output" is the value - so obviously the Functor instance would simply feed the output through another function
08:04:08 <lambdabot>  ["this"," ","is"," ",""," ",""," ",""," ",""," ",""," ","a"," ",""," ",""," ...
08:04:08 <Psybur> I see that I'm at the mercy of some more edwardk with that article heh
08:04:16 <niko> :23
08:04:31 <av> merijn: wonderful, then I'll go and switch to that... Thanks!
08:04:41 <xandaros> Hmm, that does not quite do the right thing, does it. Ah well
08:04:49 <merijn> av: I'm assuming you only really wanna process one line at a time?
08:04:50 <dminuoso> Psybur: At any rate. If you want to know more about comonads, others are better equipped to explain the finer details. I know that ertes-w knows them rather well =)
08:05:21 <av> merijn: that's right
08:05:33 <merijn> av: conduit, pipes, and machines are all libraries for stream processing (i.e. processing huge files like that line by line in fairly constant memory) and all have support for major parser libraries like attoparsec
08:06:04 <merijn> av: So you'd just write a parser for a single line and use conduit to stream your file through that parser outputting a line as soon as it successfully parses
08:06:27 <merijn> av: So if you plan to do this sorta thing more learning one or more of those streaming libraries will help you a lot
08:07:11 <the_2nd> > unwords . (Data.List.Split.split . onSublist) " " $ "this is      a        test"
08:07:14 <ertes-w> av: you don't really need a streaming library if you use attoparsec…  it supports incremental input by itself
08:07:14 <lambdabot>  "this   is                  a                        test"
08:07:40 <the_2nd> xandaros, this could work, just have to ignore splits with whitespace then
08:07:47 <merijn> ertes-w: That doesn't help too much, though
08:07:53 <av> merijn: that was my plan.  Currently I use withFile and hGetLine, I guess it'll be a good idea to get rid of that too?
08:08:13 <merijn> ertes-w: Because attoparsec incremental input doesn't deal with outputting successful parses earlier
08:08:30 <ertes-w> ah, if that's a requirement, then yes, go streaming =)
08:08:35 <the_2nd> xandaros, (trying to apply a function to each word without loosing spaces)
08:08:45 <merijn> ertes-w: if he says "multi GB files processed line by line" I assume that's what he wants :)
08:08:56 <dminuoso> ertes-w: By the way, did you ever finish writing your own GoL implementation?
08:09:11 <merijn> av: Yeah, all streaming libraries have wrappers for reading files too
08:09:22 <ertes-w> dminuoso: no, i lost focus, because i was trying to represent the infinite grid too cleverly =)
08:09:29 <dminuoso> Heh.
08:09:35 <ertes-w> dminuoso: using Cofree
08:09:47 <merijn> av: For example: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/ingest-src/Main.hs#L67-L72
08:10:44 <dminuoso> ertes-w: Well, my mental stack capacity was exceeded when someone tried to explain `free monads` the other day
08:10:59 <dminuoso> But my mind is focused on formal semantics of programming languages and type theory currently anyway.
08:11:02 <merijn> av: C.sourceFile from conduit streams the file in chunks, decodes to text (utf8), then streams that into the parser which basically repeatedly tries to parse a line and then it streams the result parse to other functions
08:11:08 <dminuoso> So Im not in the CT mindset.
08:12:45 <av> merijn: thanks again, will check those libraries out, bye for now
08:13:49 * ertes-w wants machines to become more popular…  and conduit to go away =)
08:14:12 <cocreature> ertes-w: you’re going to have to work harder to accomplish that :)
08:14:31 <merijn> ertes-w: Implement a machines backend for SQLite and I'll consider it
08:14:47 <ertes-w> cocreature: yeah, a good first step would be actually releasing my code
08:14:50 <jchia_1> Does <*> applied to IO as an Applicative respect any order, e.g. left-to-right?
08:14:59 <merijn> jchia_1: left to right
08:15:18 <merijn> jchia_1: In fact, that's part of Applicative's laws :)
08:15:40 <dminuoso> merijn: which law?
08:16:22 <cocreature> the number of streaming libs is getting slightly annoying. someone needs to make a new lib to unify all of them! <insert xkcd about standars here>
08:16:37 <dminuoso> Im staring at the laws right now, and the only one that seems relevant is: pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
08:17:15 <dminuoso> But Im unsure how that guarantees order of effects
08:17:25 <xandaros> cocreature: https://xkcd.com/927/
08:17:28 <xandaros> There you go :P
08:17:32 <cocreature> :)
08:17:47 <ertes-w> well, i was about to write my own library when i learned about machines…  that one implements exactly the API i wanted to reinvent
08:18:08 <ertes-w> (and does it better than i would have done it)
08:18:27 <merijn> dminuoso: I have to look up how it follows from the laws again
08:20:35 <merijn> dminuoso: ok, it follows from the monad law
08:20:44 <Psybur> % (pure (.)) <*> (pure (*3)) <*> (pure (`div` 2)) <*> (pure 5 :: IO Int)
08:20:44 <yahb> Psybur: 6
08:20:51 <merijn> dminuoso: Because <*> should be equivalent to ap if the Applicative is a monad
08:20:54 <Psybur> Why is that 6? >.>
08:20:57 <merijn> dminuoso: And 'ap' has a specified order
08:21:44 <merijn> dminuoso: Also the fact that "*> = >>"
08:21:52 <the_2nd> xandaros, I think your solution will not work with mixed tabs and spaces
08:22:03 <Psybur> % (*3) . (`div`2) $ 5
08:22:03 <yahb> Psybur: 6
08:22:10 <Psybur> Oh
08:22:16 <Psybur> Wait
08:22:23 <Psybur> Ah right
08:22:34 <merijn> jchia_1: IOW, Applicative it's not guaranteed to be left-to-right, but it is guaranteed to follow the ordering of monad, so that nails down the behaviour of IO
08:22:42 <Psybur> It ends up going right to left after having gone left to right doing the compose
08:22:53 <jchia_1> merijn: Thanks, but it doesn't seem to short-circuit. Should I expect <&&> to short-circuit? pure True <&&> (error "abc") :: IO Bool
08:22:58 <jchia_1> <&&> is from classy-prelude
08:23:02 <dminuoso> merijn: So >>= is guaranteed to preserve order only through dependencies right?
08:23:07 <merijn> jchia_1: I don't know classy-prelude, so no clue
08:23:10 <merijn> dminuoso: Yes
08:23:56 <jchia_1> https://www.stackage.org/haddock/lts-10.2/classy-prelude-1.3.1/ClassyPrelude.html#v:-60--38--38--62-
08:24:29 <dminuoso> Psybur: Just consider the law I stated above. It says this basically.
08:24:42 <jchia_1> % pure True <&&> (error "abc") :: IO Bool
08:24:42 <yahb> jchia_1: ; <interactive>:15:11: error:; * Variable not in scope: (<&&>) :: f0 Bool -> t0 -> IO Bool; * Perhaps you meant one of these: `<&>' (imported from Control.Lens), `<&&=' (imported from Control.Lens), `<&&~' (imported from Control.Lens)
08:26:53 <dminuoso> merijn: So it just follows from "Sequentially compose two actions" in the standard?
08:27:14 <merijn> yeah
08:27:57 <jchia_1> Can I expect 'liftA2 (&&)' to short-circuit, then?
08:28:19 <merijn> No, that will run both effects
08:28:49 <jchia_1> This gives an exception: liftA2 (&&) (pure False) (error "abc") :: IO Bool
08:29:18 <merijn> Well, yes
08:29:34 <merijn> It tries to run the IO action on the right and triggers the error
08:29:35 <marvin3> > liftA2 (||) (pure False) (error "abc") :: IO Bool
08:29:38 <lambdabot>  <IO Bool>
08:30:30 <marvin3> > liftA2 (||) (pure True) (error "abc") :: [Bool]
08:30:31 <jchia_1> > liftA2 (&&) (pure False) (error "abc") :: IO Bool
08:30:33 <lambdabot>  *Exception: abc
08:30:34 <lambdabot>  <IO Bool>
08:30:37 <glguy> liftA2 (&&) (pure False) (pure undefined) -- this one will still work
08:30:41 <marvin3> ^^ perhaps you wanted that
08:30:47 <glguy> liftA2 doesn't know or care about the behavior of &&
08:30:57 <marvin3> or that
08:31:24 <jchia_1> In reality, the left term is checking that a file exists and the right term is checking the file content, and it's not shortcircuiting
08:31:45 <jchia_1> I mean that's the context of my question about liftA2 (&&) short-ciruiting
08:32:32 <merijn> ertes-w: btw, what's your opinion on MonadUnliftIO?
08:32:38 <glguy> In IO liftA2 f x y always means, create an action that runs x, runs, y, and returns the result of running x and y combined with f
08:33:32 <maerwald> people should just use the <$> ... <*> idiom
08:33:42 <maerwald> lift is a terrible name
08:35:22 <kuribas> maerwald: yeah, elevator is better
08:35:53 <ertes-w> merijn: not sure…  it reminds me of monad-control, but i haven't seen it being used for anything that isn't exception-related
08:36:13 <ertes-w> merijn: so my first impression is that MonadCatch, MonadMask and MonadThrow should probably just be in base
08:36:32 <merijn> ertes-w: Well, it's monad-control, but without complexity and confusion or the huge dependency footprint
08:37:08 <ertes-w> merijn: i tend to avoid trapping myself in that "i need monad-control" corner
08:37:36 <ertes-w> that's one of the reasons i generally favour IO over application monads
08:37:36 <merijn> ertes-w: I think I actually like the MonadUnliftIO corner more than MonadCatch/MonadThrow/MonadMask
08:38:10 <merijn> ertes-w: I know, hence why I was curious on your opinion :p
08:38:18 <cocreature> given that ertes-w isn’t a fan of ReaderT iirc and MonadUnliftIO basically only works for ReaderT like things I doubt he’? going to like it :)
08:39:42 <merijn> cocreature: I appreciate the fact that the class itself only has a dependency on base and transformers, so I don't feel to bad adding it as a dependency
08:39:57 <ertes-w> actually i might like that one
08:40:27 <ertes-w> at least i could understand it the first time i looked, whereas with monad-control i only got it when i implemented my own instances =)
08:40:37 <ertes-w> however, i did have prior monad-control exposure
08:40:46 <cocreature> merijn: oh I completely agree. I personally quite like MonadUnliftIO
08:41:06 <ertes-w> how does MonadUnliftIO interact with async exceptions and masking?
08:41:29 <merijn> cocreature: My channel library was initially only depending on base (and transformers for older base versions), but that led to horrific types since I needed the user to manually pass in a bracket function
08:41:44 <ertes-w> one of the advantage of MonadMask is that its interaction with exceptions is immediately obvious
08:41:58 <merijn> cocreature: I think it'll be much nicer to just depend on unliftio-core and lift bracketOnError to any MonadUnliftIO
08:42:03 <the_2nd> xandaros, this does exactly what I wanted, in case you might wanna use it http://lpaste.net/3971454871613210624
08:42:37 <merijn> ertes-w: Basically "it doesn't interact with async exception at all", you can just lift mask and co over any MonadUnliftIO
08:42:55 <merijn> ertes-w: Since they it only works for ReaderT style things with a static environment
08:44:00 <ertes-w> are StateT and MaybeT "ReaderT-style"?
08:44:07 <merijn> StateT definitely is not
08:44:33 <merijn> ertes-w: basically "can you trivially move "runFooT" into the callback?" if the answer is "no" it doesn't work
08:44:55 <dsf> :t
08:44:57 <dsf> :t hello
08:44:59 <lambdabot> error: Variable not in scope: hello
08:45:05 <ertes-w> hmm, i see…  so that's where monad-control and MonadUnliftIO differ
08:45:21 <merijn> yes
08:45:21 <jchia_1> Given that (&&) <$> (x :: IO Bool) <*> (y :: IO Bool) doesn't short-circuit, is there something else I can use that succinct? Is there an idiom for this? It probably involves Monad instead of Applicative.
08:45:29 <ertes-w> MonadUnliftIO seems like monad-control without StT/StM
08:45:54 <ryantrinkle> Obsidian is hiring Haskell devs: https://www.reddit.com/r/haskell/comments/86cg1u/jobs_obsidian_systems_is_hiring/  Ping me if you have any questions :)
08:46:23 <xandaros> the_2nd: Nah, I just needed splitOn. I was fine with losing whitespace, I just cared about the last space causing an empty string at the end :)
08:47:15 <dsf> anyone use GHCJS here
08:47:17 <dsf> and for what purpose
08:48:34 <lyxia> jchia_1: Two ideas are that the short-circuiting operation also forms a monoid, and that it is basically a simplified version of MaybeT
08:49:01 <xandaros> dsf: I've used it briefly to make a website with reflex. If I were to do it again, I'd probably use purescript instead, though
08:49:14 <lyxia> jchia_1: but without more context we can't tell whether trying to use those ideas is better than simply doing it by hand.
08:49:32 <jchia_1> I was able to do this, but it's verbose: pure False >>= bool (pure False) (error "abc")
08:50:02 <dsf> xandaros: I ssee
08:50:04 <dsf> see
08:50:30 <jchia_1> lyxia: in reality: pathIsGood :: Text -> IO Bool. pathIsGood path = fileExists path >>= bool (pure False) (fileContentIsGood path)
08:51:05 <jchia_1> i wonder if there's a more idiomatic way
08:51:24 <dminuoso> :t guard
08:51:26 <lambdabot> Alternative f => Bool -> f ()
08:52:00 <jchia_1> fileContentIsGood will crash if the file doesn't exist, so I need to check with fileExists first
08:53:00 <lyxia> I believe the common practice with file systems is to just catch the exceptions when the operation you actually want to do fails.
08:53:13 <EvanR> jchia_1: checking first doesnt prove anything...
08:53:21 <EvanR> ^ catch the exception
08:53:27 * dminuoso deletes the file after the check is done, but before its opened
08:53:30 <dminuoso> and voila, crash happens.
08:53:39 <EvanR> delete or move
08:54:50 <dminuoso> On that note.. Im doing a lot with LDAP, and the different failure cases of my operations begin to accumulate.
08:55:06 <dminuoso> What's the usual way of expressing exceptions? ExceptT with some sum exception type?
08:55:11 <lyxia> jchia_1: and on a more general note, I don't see a more interesting abstraction than an ad-hoc short-circuiting monadic (&&).
08:57:49 <EvanR> dminuoso: for IO exceptions? use Exception
08:57:58 <EvanR> make new Exception types
08:57:59 <glguy> jchia_1: If fileContentIsGood crashes if the file doesn't exist you should just fix it to not crash
08:58:16 <glguy> there's no promise that the file will still be there after the fileExists runs but before the check runs
08:58:25 <jchia_1> Which exception is for missing file? I want to crash if there are other errors.
08:59:01 <dminuoso> EvanR: No, it's rather for semantic issues. Say you're trying to edit a resource that is marked immutable.
08:59:09 <dminuoso> That operation needs to fail somehow.
08:59:17 <EvanR> throw an exception?
08:59:22 <dminuoso> EvanR: IO exception?
08:59:30 <EvanR> this is LDAP right... so... yeah
08:59:58 <EvanR> throw an LDAPException (to be invented by you)
09:00:05 <dminuoso> EvanR: Its got nothing to do with LDAP itself. It's just when a record has an attribute that says "you cant edit me", then my library needs to respect that
09:00:15 <dminuoso> It's a semantic exception
09:00:27 <EvanR> and you cant stop that with a type?
09:00:52 <EvanR> by exception you mean an error?
09:01:05 <dminuoso> EvanR: No I mean an exception. It's not a program error.
09:01:12 <xandaros> I'm feel like you are looking for something like "IO (Either LDAPError _)"
09:01:28 <EvanR> why... not just throw it
09:01:32 <xandaros> Or as a transformer stack
09:01:35 <EvanR> :(
09:01:46 <dminuoso> EvanR: Im just wondering whether forcing all my exceptions through IO is considered good style..
09:01:48 <dminuoso> Even though they are not errors.
09:01:56 <EvanR> dminuoso: its funny becuse youre calling *something* an "exception" but not wanting to use the thing known as exceptions which are for exceptions
09:02:07 <EvanR> so language error
09:02:22 <EvanR> dminuoso: IO exceptions arent errors....
09:02:28 <EvanR> see
09:02:47 <xandaros> dminuoso: What's wrong with Either/ExceptT?
09:02:55 <EvanR> i feel like you are using the words exactly backwards
09:03:06 <dminuoso> EvanR: It's not clear cut for me whether MonadThrow, ExceptT or Control.Exception are the best strategies..
09:03:20 <dminuoso> It's like I have three knifes, but I dont know which is for which.
09:03:25 <EvanR> it really depends on what other stuff in your framework is thinking
09:03:35 <EvanR> if i invented it all, this case would be an Exception
09:03:46 <EvanR> because screw transformers
09:03:55 <dminuoso> EvanR: as in IO exceptions?
09:04:03 <EvanR> thats the only Exception there is
09:04:07 <jchia_1> lyxia, glguy, EvanR: In my use case, I want return False if 1) the file doesn't exist or 2) the file exists but content is ill-formatted, True if the file exists and the content is properly formated. If I encounter an IOException other than for a missing file, I want to terminate (crash) because it's time for human intervention and the program can't handle the situation anyway. How do I do this?
09:04:08 <xandaros> I personally try to avoid actual exceptions, since the type doesn't reveal they exist. The caller might not even know such an exception is a possibility
09:04:12 <dminuoso> Just making sure =)
09:04:13 <dsf> Anyone hear of Stephanie Weirich
09:04:16 <merijn> dminuoso: MonadThrow is just for lifting Control.Exception
09:04:23 <dminuoso> xandaros: IO itself says "this thing can fail"
09:04:36 <merijn> dminuoso: So it's not "either MonadThrow or Control.Exception"
09:04:47 <merijn> dminuoso: It's just Control.Exception used in various ways
09:04:56 <EvanR> jchia_1: there is a specific check for that case, look through Control.Exception
09:05:31 <lyxia> dsf: why you ask
09:06:28 <xandaros> dminuoso: The bis question is: Do you want it to be a "checked exception" or an "unchecked exception"? If the former, use Either or ExceptT. If the latter, throw an actual exception
09:07:14 <EvanR> dminuoso: this is how many I/O libs work, the IO type is pretty simple and you might think it means it cant fail. if you didnt know IO better. of course, it usually doesnt fail, making it an exception. which gets thrown, because there is no other way when you have simple types
09:07:51 <EvanR> if you want to make all your IO stuff return Either FooError A, then you are making your life difficult and not really avoiding exceptions anyway
09:08:15 <EvanR> Either for IO stuff is the exception hair shirt
09:08:45 <xandaros> It depends. If you do this everywhere, ExceptT is probably better. Unless it really is exceptional and not just a somewhat uncommon case, in which case a real exception makes sense
09:09:29 <EvanR> it really sounds like an exception, you usually go to make changes you already think will work
09:09:39 <EvanR> dminuoso even called it that
09:09:40 <EvanR> lol
09:09:50 <rotaerk> Exception hair shirt?
09:11:03 <glguy> ExceptT is slower, you still have exceptions from the IO layer you have to handle anyway, and it awkwardly requires a bunch of extra uses of lfit
09:11:54 <robstr> Hey, I have a a function returning `IO Bool` and I want to run another function is it is false, otherwise nothing is there a cool way to do this ? Or should i go with fmap and caseof ?
09:12:14 <EvanR> :t when
09:12:16 <lambdabot> Applicative f => Bool -> f () -> f ()
09:12:21 <EvanR> er, whenM
09:13:39 <robstr> EvanR: whenM ? can not find it
09:13:53 <EvanR> you have to write it yourself
09:14:03 <xandaros> https://hackage.haskell.org/package/extra-1.6.4/docs/Control-Monad-Extra.html#v:whenM
09:14:17 <EvanR> unless you want an entire package for a 2 line function
09:14:36 <robstr> thank you, xandaros how did you find it ? I tried hoogle too
09:14:49 <xandaros> stackage seems better at finding things
09:15:04 <EvanR> i see it on hoogle.haskell.org
09:15:26 <xandaros> I never use that one; no type search
09:15:39 <robstr> I was on haskell.org/hoogle
09:15:58 <robstr> lol
09:16:19 <xandaros> Yeah. I use haskell.org/hoogle first. If that can't find it, I go to stackage
09:16:19 <cocreature> no type search, is not really correct, e.g., you can find when easily https://hoogle.haskell.org/?hoogle=Applicative%20f%20%3D%3E%20Bool%20-%3E%20f%20()%20-%3E%20f%20()
09:16:41 <cocreature> the type search is not great but if you set the constraints right it usually works
09:17:36 <xandaros> I don't really understand why this second hoogle is necessary. We have the other one which is amazing at finding things... if it knows about them
09:17:43 <EvanR> cocreature: no type search?
09:18:10 <xandaros> Especially since hoogle.haskell.org has existed for ages and still has the disclaimer that type search doesn't work
09:18:24 <EvanR> what is this second hoogle?
09:18:36 <xandaros> hoogle.haskell.org
09:18:46 <EvanR> whats the first?
09:18:51 <xandaros> haskell.org/hoogle
09:18:57 <EvanR> well type search seems to work
09:19:07 <rotaerk> Determining whether to throw or return a value indicating failure is a design decision, not a categorization problem.  Any failure could be reported in either way.  It's just a matter of deciding what you want your interface to look like.  You can build an interface that lets the caller decide how each possible failure condition should be reported, but it's also the least simple interface
09:19:46 <sclv> xandaros: hoogle.haskell.og is supposed to eventually get type search. its the "in progress" hoogle
09:19:52 <sclv> the "in progress" has just been taking forever and a day
09:20:26 <xandaros> I understand that, but why do we need a new hoogle in the first place?
09:20:28 <cocreature> if I understood neil correctly in his Haskellcast interview, I don’t think he has any plans on improving the type search
09:21:00 <cocreature> it’s a tradeoff between the more complex db of the old hoogle which apparently took ages for generating docs for all of stackage and the one used by the new hoogle which can do that in minutes
09:21:28 <sclv> cocreature: that can't be right. i communicated with him recently on this
09:21:30 <sclv> its stalled
09:21:35 <sclv> because of lack of time on his part
09:21:39 <sclv> but idk why he'd drop it!?
09:21:55 <cocreature> ah then I misunderstood him
09:21:57 <xandaros> Ok, sounds reasonable. So we create a new hoogle and before it has parity with the one it is replacing, we stop indexing for the old one? ...
09:21:57 <EvanR> rotaerk: (this is for I/O libs) if you use Either E where E isnt an exception, then your code will either have to deal with it now, use a transformer, rewrite the section to use all Either and rearrange, or implement Exception for E and throw it. If its just IO no Either E, the user can convert it to either using try at will, or ignore it
09:21:59 <sclv> (i suggested he put in a gsoc idea for finishing it off)
09:22:12 <sclv> xandaros: yeah if the new one becomes feature complete it'll replace the old
09:22:22 <EvanR> rotaerk: so Either will cause more code on both ends necessarily
09:22:26 <sclv> (and he said he would, if he had time. obviously he didn't have time for that either :-P)
09:23:03 <sclv> so if some enterprising person wanted to come along, roll up their sleeves, and offer to take up the cudgel, i think he'd be very happy
09:23:41 <xandaros> I'm just going to use stackage for the time being. I disagree with stackage, but it seems the best search right now
09:24:05 <EvanR> meanwhile whenM was on "new" hoogle heh
09:24:25 <rotaerk> Causing more code is not necessarily bad.  The point of Either is to make the failure condition explicit in the type sig
09:24:43 <EvanR> true we do not have exceptions in the types
09:25:28 <EvanR> but, the point of exceptions is to not be in the code, due to relative importance
09:26:01 <EvanR> its always been a code reduction technology
09:26:02 <rotaerk> Not all failure conditions should be in the signature... For instance out of memory
09:27:10 <metalrain_> So how costly computationally it is to interpret types for one package? How many packages there are? Rest is ”just” search and indexing.
09:27:19 <rotaerk> But the function author should decide which kinds of failures to report explicitly in the signature, and which not to
09:27:25 <EvanR> agreed, because out of memory should end the world instantly
09:28:11 <EvanR> youre arguing against getting good advice from others? :)
09:29:40 <rotaerk> You can design in such a way that you can describe failure conditions in the signature without deciding on how exactly the failure is reported
09:30:03 <EvanR> how
09:30:35 <[exa]> we're handling OOM in GC-ed language?
09:34:07 <rotaerk> E.g. divide :: (Fractional n) => r -> (n -> r) -> n -> n -> r
09:35:01 <EvanR> this is equivalent to Either
09:35:12 <rotaerk> Where the first param is the value to return on divide-by-zero.  The second takes the result of division and converts to an r
09:35:37 <[exa]> :t maybe
09:35:39 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:35:40 <EvanR> it requires the client to think about a case that should have been precluded by previous considerations, i.e. an error
09:36:09 <EvanR> if its impossible, they are writing code that will never run
09:36:35 <rotaerk> In this case they should've avoided passing 0, because it violates a precondition of division
09:36:50 <rotaerk> But not all failure are violations of preconditions
09:36:59 <EvanR> i was really only talking about I/O
09:37:03 <EvanR> and how Either sucks
09:37:09 * EvanR leaves
09:37:16 <rotaerk> Heh
09:48:50 <mcgroas> :q
09:49:27 <[exa]> I kindof realized I used Either more times for saying that the computation procedure has "Left" the loop with a finally obtained result than saying that it didn't go just "Right"
09:58:34 <maerwald> Just Right
09:58:37 <maerwald> wat :D
09:59:00 <maerwald> :t Just . Right
09:59:01 <lambdabot> b -> Maybe (Either a b)
09:59:07 <[exa]> the "just" in that sentence was english, not haskell :D
09:59:27 <maerwald> :t Just Right
09:59:29 <lambdabot> Maybe (b -> Either a b)
10:06:25 <xandaros> It doesn't really matter which part of the Either you use, but using the "Right" one has the benefit that functions like fmap work on it. You more often want to map over Right than over Left. (Though there is the bifunctors package, which allows mapping over either[hah!])
10:07:09 <robstr> I'm inside `stack repl` and `lookupEnv` returns nothing while in `ghci` it finds my env, whats the problem
10:10:10 <hrk> I have a bunch of newtypes wrapping Text. I'd like to derive ToJSON (Aeson) instance for that, but I'd like the encoded json look like json String (not as Object with one filed). Is that possible?
10:11:04 <sm> robstr: compare "env" and "stack exec env"
10:13:18 <sm> seems like stack just adds a few more vars, so don't know
10:13:44 <robstr> sm: its not there -.-
10:16:22 <robstr> sm: ohno, maybe this is because I'm inside the nix-shell which sets the env var and stack came from my current system ?
10:16:31 <sm> could be, could be
10:17:06 <lyxia> hrk: https://hackage.haskell.org/package/aeson-1.3.0.0/docs/Data-Aeson.html#v:unwrapUnaryRecords
10:19:22 <reactormonk> I have a MonadReader r m. Is it possible to write a Lens' (m r) r ?
10:21:28 <reactormonk> ... nope
10:21:46 <cocreature> reactormonk: note that you can use "view" directly in MonadReader
10:22:08 <hrk> lyxia: I just found GeneralizedNewtypeDeriving to do what I need. But thanks, I wasn't aware the encoding could be configured like that.
10:22:25 <reactormonk> cocreature, microlens documentation tells me as much, thanks for the hint.
10:36:18 <hololeap> so, i would like for (mzero :: ListT Maybe ()) to return `ListT Nothing` instead of `ListT (Just [])` ... the current instance is `instance Monad m => MonadPlus (ListT m)` ... is it possible to "overload" this with a `instance MonadPlus m => ...` which would take precedence?
10:41:18 <xandaros> "lift mzero" is "ListT Nothing". Anything you can do with that?
10:43:08 <xandaros> Otherwise, you'll probably have to wrap it in a newtype
11:02:40 <amalloy> is (until :: (a -> Bool) -> (a -> a) -> a -> a) a recent addition to Prelude? it seems like a function i've wanted a few times but didn't realize was already written
11:04:22 <cocreature> robstr: are you using stack’s nix integration?
11:04:32 <kw> What's the standard way to deal with class constraints that would naturally be expressed like 'forall a b. Functor (bi a), Functor (Flip bi b) => Bifunctor bi'?
11:05:41 <kw> (or equivalently, 'forall a b. Functor (a `bi`), Functor (`bi` b) => Bifunctor bi')
11:05:56 <cocreature> amalloy: git blame points to at least 2004 for the doc string of until and 2012 for the last modification to the source, so definitely not recent :)
11:12:11 <agentultra> Anyone have experience with getting haxl + persistent to work together? Not sure if it's possible to lift the connection out of persistent to give to my state key instance...
11:13:19 <lyxia> kw: Bifunctor is the most common way to encode these two constraints
11:13:21 <agentultra> Closest I could find is https://gist.github.com/jamesdabbs/ba0d798b4022cf4cb64b but I don't know where Handler is coming from or see where it's getting the connection
11:15:36 <robstr> cocreature: yes
11:15:47 <kw> lyxia: Right, but how do you tell Haskell that those constraints define a Bifunctor?
11:16:45 <cocreature> robstr: iirc by default stack uses a pure nix shell which will clear all environment variables. you can add "pure: false" to disable this, see https://docs.haskellstack.org/en/stable/nix_integration/#the-nix-shell
11:18:02 <chocopuff> Can I think of monads as the FP equivalent of OOP classes?
11:18:08 <tdammers> chocopuff: no.
11:18:23 <chocopuff> hmmm aight thanks tdammers, will keep reading then
11:18:26 <robstr> cocreature: you are right, works perfect :+1 ty
11:18:34 <tdammers> that is, you can, but it is not going to be helpful in any way
11:18:52 <chocopuff> tdammers: I mean, as in, like it is where you have unique behaviors for diff monads / classes
11:19:00 <chocopuff> is it analogous in this sense?
11:19:13 <tdammers> if you squint a lot
11:19:25 <tdammers> but it's not the kind of analogy that will help you understand anything
11:19:47 <cocreature> you need to squint up to the point where you drop most properties commonly associated with oop classes
11:19:59 <McGroarty> Hello Haskellers! Whats a good library for transferring files(/folders) of data between nodes?
11:20:31 <wz1000> typeclasses are kind of similar to abtract classes/interfaces
11:20:43 <wz1000> *abstract
11:20:44 <chocopuff> tdammers: can I think of monads as a box that contains "side effects"?
11:20:56 <chocopuff> sorry if i'm not making that much sense
11:21:22 <wz1000> some monads, sure
11:21:33 <agentultra> nm, think I've managed to win type tetris again.
11:21:42 <glguy> No, that's not what monads are in general,
11:21:54 <chocopuff> glguy: that's the wrong way IO makes you think about it?
11:22:00 <chocopuff> I think I've heard cautions about that part
11:22:19 <wz1000> monads are just monoids in the category of endofunctors, whats the problem?
11:22:30 <cocreature> chocopuff: tbh I’d recommend to suppress the urge to find an analogy to something that you already know. they tend to be more confusing than helpful and lead you to false conclusions
11:23:44 <lyxia> kw: use the constraints package, it has a module of `Forall` constraints, or wait 6 months for a version of GHC with quantified constraints to come out.
11:24:04 <chocopuff> you have to know how >>= and return are defined to use each monad right?
11:24:50 <chocopuff> i'm assuming understanding monads is a rite of passage everyone here goes through :D
11:25:04 <kw> lyxia: Thanks, will check it out. But not sure whether you're being sarcastic about the next GHC having quantified constraints.
11:26:34 <Entroacceptor> it's just a scary name for a pretty core concept
11:26:56 <xandaros> chocopuff: My recommendation is usually to look at functor and applicative first, then look at monad. Especially functor is a great deal simpler and it will give you an intuition about how to interpret the types
11:26:57 <Entroacceptor> like git's directed acyclic graph
11:27:04 <xandaros> Plus, every monad is a functor :P
11:28:31 <xandaros> And once you play around with fmap, pure and (<*>), you will notice you are lacking once thing. (>>=) follows pretty naturally in my opinion
11:28:51 <chocopuff> aight, thanks for the advice xandaros
11:29:00 <chocopuff> for some reason, no one brings up functors and applicative first though
11:29:07 <chocopuff> always trying to jump over the monad mental hurdle first
11:29:23 <Entroacceptor> LYAH does it that way, IIRC?
11:29:55 <mnoonan> I forget where I found it, but there is some set of questions out there that gives a bunch of weird type signatures and has you find the implementations
11:30:12 <mnoonan> and at the end, it turns out you built up Monad and a bunch of variations.
11:30:28 <chocopuff> Entroacceptor: nevermind, that is true
11:30:29 <mnoonan> it probably isn't for everybody, but I actually found it really useful to work through.
11:31:26 <ddellacosta> mnoonan: the typeclassopedia may not be what you were talking about, but has some similar exercises: https://wiki.haskell.org/Typeclassopedia
11:31:35 <xandaros> I implemented Functor, Applicative and Monad for Maybe myself. That was very enlightening :)
11:31:47 <xandaros> And then did the same with State. That took a while...
11:32:18 <cocreature> there are also the monad challenges https://mightybyte.github.io/monad-challenges/
11:34:08 <mnoonan> I think it was this one: http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
11:34:40 <ddellacosta> ah, that guy...that's why I don't know about it...haha
11:36:42 <chocopuff> mnoonan, cocreature: thanks, those look like fun resources
11:36:45 <chocopuff> i'll start with monad-challenges
11:37:53 <Squarism> Anyone using persistent? Still considering myself a beginner i wonder what is a practical approach to importing the Persistent types that is needed everywhere one uses the entity types ive created? Should i import persistent everywhere i import those types or reexport persistent from my Types.hs?
11:39:29 <chocopuff> have to go for now, thanks all
12:08:54 <kuribas> @hoogle [a] -> [([a], a, [a])]
12:08:55 <lambdabot> Data.List.HT splitEverywhere :: [a] -> [([a], a, [a])]
12:08:55 <lambdabot> Prelude unzip3 :: [(a, b, c)] -> ([a], [b], [c])
12:08:55 <lambdabot> Data.List unzip3 :: [(a, b, c)] -> ([a], [b], [c])
12:12:14 <kuribas> > inits [1..10]
12:12:18 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
12:12:31 <kuribas> is inits O(n^2) ?
12:13:20 <[exa]> if you materialize the whole result then yes
12:14:00 <kuribas> O(n^2) space as well...
12:14:19 <[exa]> only if you need it whole at once
12:14:35 <kuribas> right
12:29:48 <jle`> the real quesiton is is (inits xs !! i) it O(n^2) perf on the length of xs, or O(i)
12:32:42 <kuribas> > let select l = zip3 (inits l) l (tail $ tails l) in select [a, b, c, d]
12:32:46 <lambdabot>  [([],a,[b,c,d]),([a],b,[c,d]),([a,b],c,[d]),([a,b,c],d,[])]
12:32:54 <kuribas> jle`: this :)
12:33:57 <kuribas> @src inits
12:33:58 <lambdabot> inits []     = [[]]
12:33:58 <lambdabot> inits (x:xs) = [[]] ++ map (x:) (inits xs)
12:34:09 <cocreature> @src is a lie
12:34:09 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:34:48 <EvanR> > cake
12:34:51 <lambdabot>  error:
12:34:52 <lambdabot>      • Variable not in scope: cake
12:34:52 <lambdabot>      • Perhaps you meant one of these:
12:34:55 <EvanR> dangit
12:35:17 <EvanR>  @restore cake
12:35:37 <cocreature> > cake
12:35:40 <lambdabot>  "is a lie"
12:36:06 <EvanR> it used to be a list of 42 ingredients
12:37:18 <kuribas> jle`: that looks like O(n)
12:54:44 <c_wraith> EvanR, that's back when Cale ran lambdabot. it's changed hands since, so the default definitions have fewer portal references
13:02:49 <EvanR> seems like just yesterday
13:02:53 <EvanR> (tm)
13:29:37 <robstr> quit
13:51:06 <chessandgo> I've researched my problem and apparenlty I need maybeT, but I dont understand why I need to use an even high level obstraction to do what I want
13:51:39 <chessandgo> I have multiple functions that return IO (Maybe BS.ByteString), and I'd like to chain them together with =<<,but It seems I cant
13:56:55 <EvanR> chessandgo: and what is the type of these functions
13:58:03 <chessandgo> EvanR: They take in a plain Bytestring or a mvar
13:58:24 <EvanR> then yeah, MaybeT would do it
13:59:20 <chessandgo> thanks, is there there a smarter way to do what i'm doing? It feels like im doing an anti pattern
13:59:30 <chessandgo> I have multiple IO actions that can fail that I want to chain together
13:59:48 <chessandgo> (getting some input from an mvar, chained into checking a database, etc)
13:59:57 <EvanR> is their failure an exception? or regular old failure
14:00:22 <EvanR> you might want to throw exceptions instead
14:00:33 <chessandgo> regular failure, I think. If the mvar returns a Nothing it just means theres no input
14:00:44 <chessandgo> if the database returns a Nothing it means the value wasnt found in it
14:01:04 <EvanR> i am skeptical of the mvar part
14:01:31 <EvanR> if there is no input why are we doing this procedure
14:01:57 <chessandgo> its an eventloop for a game
14:02:07 <chessandgo> the mvar is a line of input from a user connection
14:02:35 <EvanR> youre polling an MVar, like using it as a chan of size 1
14:02:48 <chessandgo> yeah, basically
14:02:53 <EvanR> and not just waiting for it to become populated
14:02:56 <EvanR> with a thread
14:03:17 <EvanR> polling sucks!
14:03:36 <chessandgo> is there a better method?
14:03:51 <EvanR> yes they are designed to be waited on
14:04:11 <chessandgo> doesnt that make my loop block?
14:04:14 <EvanR> then the handler will react to something inserting into the mvar
14:04:30 <zq> :t (#)
14:04:32 <lambdabot> error: parse error on input ‘)’
14:04:41 <EvanR> what is the loop doing?
14:05:12 <chessandgo> mapping over a channel of connected clients (which are just MVars with some book keep information in a truple)
14:05:35 <EvanR> youre polling all of them too?
14:05:37 <chessandgo> the look checks if theres any new connection, any dead connections, and check for input
14:05:40 <chessandgo> yeah, all of them
14:05:45 <EvanR> all of those things are threads man
14:05:52 <chessandgo> yeah
14:05:52 <EvanR> rather, thats the better way to do it haskell
14:06:22 <chessandgo> The mvars are connected to threads that were created by another function that checks for incomming connections
14:06:26 <EvanR> so far i havent heard something in your program that needs to be polled
14:06:37 <zq> oh
14:06:39 <zq> stupid me
14:07:27 <chessandgo> so, you're saying I should let each thread handle the input blockingly, instead of polling them in another loop?
14:07:35 <EvanR> definitely
14:07:48 <chessandgo> i considered that but It felt like I wasnt keeping track of my threads then
14:08:01 <EvanR> youre not?
14:08:39 <chessandgo> well, the channel im mapping over also contains the ThreadIDs, so I could check if a thread died or not
14:08:53 <chessandgo> should I remove the mvars but keep the ThreadID section
14:09:25 <chessandgo> I'm mapping over a channel of this
14:09:26 <EvanR> it is still possible to react to threads dying
14:09:26 <chessandgo> (ThreadId, MVar BS.ByteString, (Socket, SockAddr))
14:09:56 <EvanR> one way is, fork them with a finalizer, another is to use async
14:10:57 <chessandgo> with async, do I just check to see if the threads still alive? I looked at async but couldnt find information on why i'd use it over forkIO for my usecase
14:11:28 <EvanR> the work to interpret the bytestring and stuff can happen concurrently, only when you need to make these commands interact with each other do you need to access some synchronization, like MVar World or set of TVars
14:11:45 <EvanR> no, with async, you block until one of a group of threads ends
14:11:54 <EvanR> thats one of the things it does
14:12:16 <EvanR> checking in a loop wastes time and adds complexity
14:12:58 <chessandgo> so I can block until it dies and then use that to alert my eventloop that it died (I want to be able to keep track of the connections, as each one is a user)
14:13:21 <chessandgo> amount of connections*
14:13:25 <EvanR> but you could also use async to spawn a wrapper thread for each thread that handles a client, which dumps the death result into a central MVar, handled by yet another thread which is waiting, not looping
14:13:41 <EvanR> then ends normally
14:14:05 <chessandgo> so I should switch most of my mvar usage to blocking
14:15:00 <EvanR> yes. but the bigger picture is, for each task you should use dedicated threads which are blocking, so not *everything* is blocked on one thing
14:15:42 <EvanR> if the task gets somewhat complex or iffy, put more async threads around it that decide what to do on error
14:16:04 <EvanR> poor man's erlang
14:17:29 <chessandgo> so with all that, do I put all input into a single channel? Now that each thread is blocking for input, how does the eventloop process input without polling
14:17:56 <EvanR> you mean, the person at the console?
14:18:13 <chessandgo> mutliple people
14:18:20 <chessandgo> multiplayer
14:19:01 <EvanR> you could do it like that, have one thread blocking on the command mvar, and is solely responsible for executing the commands serially
14:19:13 <EvanR> clients are dumping their commands into it
14:20:21 <EvanR> another way is for the client thread to take the resouce from a central MVar, do something, put it back. (this last bit must be done with a bracket to ensure the resouces are replaced on crash)
14:20:41 <EvanR> another way is for the client thread to do its thing completely in STM, which handles all this for you
14:21:41 <EvanR> you treat all STM variables as globals, you act in a transaction, and it all "just works"
14:22:27 <chessandgo> doesn't mapping over an empty channel block however?
14:22:56 <EvanR> you mean folding? yes that command executer thread is mostly sleeping
14:23:01 <chessandgo> if I get all my input pushed instead of polled, if theres no userinput at all doesnt the eventloop block
14:23:01 <EvanR> hopefully
14:23:16 <chessandgo> isn't that a problem because I need time to pass even when theres no input
14:23:49 <EvanR> what event loop
14:24:06 <chessandgo> the loop that runs gamelogic etc
14:24:11 <EvanR> ok
14:24:21 <EvanR> so this isnt a server program, someone is at the keyboard
14:24:45 <chessandgo> (keyboards, multiplayer)
14:24:48 <EvanR> you have N threads waiting on your sockets right
14:24:52 <chessandgo> yeah
14:25:12 <EvanR> well, as i recall from multiplayer game design... people love to implement the local player as one of the network players :)
14:25:30 <chessandgo> each thread is getting userinput and attempting to put it into an mvar
14:25:31 <EvanR> but either way, have a thread dedicated to the local events, and process them similarly to the sockets
14:26:10 <EvanR> i interpret your story as 1 local GUI input thread, N socket threads, all producing commands
14:26:30 <chessandgo> technically theres no GUI because this is a multiplayer text adventure ;)
14:26:48 <EvanR> even better
14:26:57 <EvanR> 1 thread blocking on getLine
14:27:31 <EvanR> you see, its blocking all the way down
14:28:06 <chessandgo> but doesn't that mean time stops when theres no input? all eventloops in games are nonblocking
14:28:33 <chessandgo> I'll switch my threads to blocking, but doesnt the main event loop still need to be nonblocking
14:28:55 <EvanR> most game loops are implemented without much real thought, in languages that dont really like concurrency
14:29:51 <EvanR> chessandgo: do you have a schedule of events that must occur spontaneously, as part of the game simulation?
14:30:07 <EvanR> which commands, and other events, modify?
14:30:08 <chessandgo> yeah
14:30:14 <chessandgo> time ticks, physics simulate, etc
14:30:14 <EvanR> so that is its own thread
14:30:54 <EvanR> and its blocking waiting for something to happen (or for the schedule to change)
14:31:09 <EvanR> that part will need a form of timed sleep... threadDelay
14:31:31 <EvanR> thats basically a cron
14:31:59 <chessandgo> so I should have two threads, one for gamelogic and one for userinput processing?
14:32:46 <EvanR> so far, we discussed at least 2 threads for each multiplayer connection, 1 for local player input, 1 for spontaneous other events, and 1 which is monitoring connection deaths
14:33:05 <EvanR> and 1 for handling commands
14:33:30 <EvanR> you could have many more
14:33:43 <EvanR> actually i expect you to need more than 1 to implement a cron
14:33:59 <EvanR> and once you find that logging is jumbled, a thread to consume logs or text output
14:34:38 <chessandgo> I dont anticipate too much log jumbling because most output is going to the users, but, i see
14:34:43 <EvanR> if you want any of these threads to be restored on crash, youll want a monitor wrapper thread for each one
14:35:10 <chessandgo> I everything a thread now
14:36:45 <EvanR> oh and 1 thread for accepting new connections
14:37:13 <chessandgo> yeah
14:37:14 <EvanR> i tend to make written maps at this point :)
14:37:35 <chessandgo> Ive got a lot of pictures of this, but not after these revisions!
14:39:01 <chessandgo> doesnt every thing have to do through my cron thread eventually. Once userinput it parsed into commands, it eventually gets pushed into cron to be exacuted after the physics
14:39:41 <EvanR> i dont think so
14:39:49 <EvanR> but its up to you
14:40:02 <EvanR> in some old mud servers did do everything literally thread a single event queue
14:40:16 <EvanR> but they generally didnt use advanced concurrency
14:40:46 <EvanR> i would think a user command must be executed as soon as possible
14:40:54 <EvanR> no point in putting it in a queue
14:40:55 <chessandgo> Well i'm just thinking of how im supposed to make sure I dont get race conditions between userinput commands impacting the world and the game physics
14:41:12 <chessandgo> But that might already be avoided because the world is stored in an actual database
14:41:21 <EvanR> way 1: put the world in an MVar, to update it, a thread must modifyMVar it, which serializes access
14:41:39 <EvanR> way 2: access the world with STM, transactions will only occur in a sane way
14:42:01 <EvanR> if its in a database, only access the world using transactions
14:43:41 <chessandgo> is way 1 better than way 2, I've been thinking of the impact of every world change having to be written to a database
14:44:07 <chessandgo> I was planning on only writting the world every couple ticks but thats an even worst problem with caches
14:44:15 <EvanR> way 1 and 2 both dont involve an external database
14:44:37 <EvanR> you want performance? :)
14:44:46 * EvanR gives chessandgo acid-state
14:45:11 <chessandgo> is there no way to get consistancy AND performance
14:45:18 <EvanR> acid-state
14:45:32 <chessandgo> is that a library or what have you
14:45:36 <EvanR> yeah
14:45:46 <chessandgo> I am but just a novice databaser
14:46:42 <EvanR> its a form of "turn your program into a database engine, with updates being logged and the local view of the world updated atomically. periodically checkpoint the log to save space"
14:47:02 <monochrom> For performance the answer is "it depends". You now need to reveal how big the "world" is, what kind of updates you make, how small they are, what's your data structure, is there much data dependency between two updates or not, etc etc etc.
14:47:34 <monochrom> Do not expect one recipe. Except the one that says "it depends".
14:48:23 <chessandgo> not much data dependency between updates, and the world is a "decent" size. im more surprized that something like acid-state even exists
14:49:20 <chessandgo> initially I wanted to use a database so that the game server would have as little state as possible, but.....
14:49:20 <EvanR> the limiting factor is, the latest world is kept in memory. if that is 4G, then i wouldnt trust acid-state
14:49:51 <EvanR> if all your state is acid-state, then now you have only 1 state to worry about instead of 2 (local and database)
14:49:58 <chessandgo> does acid-state break down at 4GB or does performance degrade
14:50:09 <EvanR> couldn't tell you
14:50:19 <EvanR> if you run out of memory in haskell, monkeys fly out of your nose
14:50:45 <monochrom> Your computer jumps out of the window.
14:50:46 <chessandgo> I've preemptively make some of the important functions strict, but...
14:50:51 <EvanR> in any case, the log should be ok
14:51:25 <EvanR> (if you trust that acid-state has done as much diligence as sqlite etc)
14:52:28 <EvanR> solution, buy 8G?
14:52:41 <chessandgo> my laptops got 16GB, and my server 32GB
14:52:44 <chessandgo> so im not too worried
14:52:52 * EvanR is old now
14:53:20 * chessandgo thinks that if he tells people his text adventure game needs 16GB of ram theyll laugh at him
14:53:54 <EvanR> or they are the guy who wrote dwarf fortress and wonders why so little
14:53:57 <chessandgo> its tinyMUD but the world crashes at 32GB of ram instead dof 32MB
14:54:59 <chessandgo> I wanted to do water simulation using openCL on a GPU, becuase, you know, if you're already being absurd by writing a MUD in haskell with a database..
14:55:16 <EvanR> the last part is far from absurd
14:55:26 <EvanR> disclaimer this is #haskell
14:55:59 <chessandgo> theres a MUD server in python, but I need my type safty and threads
14:56:32 <EvanR> theres probably more MUD servers in more languages than any other kind of server program
14:56:40 <monochrom> Simulate cloud too. And compute the simulation on the cloud, for the sake of the pun. :)
14:57:11 <chessandgo> `wel you see, i'm using 4 dimensional simplex noise for cloud simulation.....`
14:57:24 <EvanR> i am somewhat offended at the idea of a MUD that is simulating crepuscular rays and ocean reflections etc
14:57:25 <chessandgo> `you just cant tell because I gave very little descriptions when examining clouds in game`
14:58:09 <chessandgo> Dwarf Fortresses uses cellular Autonama to simulate water, so I thought that'd be a cool thing to simulate too
14:59:00 <EvanR> stick a comonad on it
15:00:42 <chessandgo> indeed
15:00:50 <chessandgo> how fast is *too* fast to be updating a database
15:01:00 <chessandgo> 30 times a second?
15:01:20 <EvanR> how would that answer help?
15:01:46 <chessandgo> to decide if I can live with the performance of writing the world out every tick or choosing to use acid-state
15:02:27 <EvanR> in the old days, people would only commit their world to disk 3 times a day!
15:02:35 <EvanR> and everyone would have to wait
15:02:47 <Tuplanolla> "If you need the database to be fast, we recommend not putting too much data in it." --- QuineDB developers
15:03:09 <chessandgo> *this hurts the database's feelings*
15:03:51 <EvanR> if youre not going to be acid about it, might as well not even use a database. just dump backup files periodically
15:04:28 <EvanR> access the world value and dont worry about SQL
15:04:40 <chessandgo> thats true, from what ive read most games DONT use databases for the world at all
15:05:09 <chessandgo> I just wanted SQL so I had a neat and nicely relational way of accessing data. But it seems to be a hinderance now
15:05:13 <EvanR> yes, the classic "sorry your character has reverted back to the day before yesterday"
15:06:07 <chessandgo> now I'm wondering how games like minecraft deal with this
15:06:16 <chessandgo> I suppose you could get inconsistancies at the chunk level if you crashed
15:08:04 <EvanR> worlds become corrupt in minecraft
15:09:06 <EvanR> they use tools to save a bunch of backups and restore them as contingency
15:09:14 <EvanR> not a good role model
15:10:01 <EvanR> good role model, MOO (lambdaMOO), which is itself a database. everything that happens is saved
15:11:31 <chessandgo> EvanR: and lamdaMOO's performance is ok?
15:11:45 <EvanR> almost unbelievable its still running
15:11:49 <chessandgo> you can do anything if you dont care about performance!
15:12:03 <EvanR> ive never experienced it lagging
15:12:25 <chessandgo> heres how to increase performance, plz dont hate me
15:12:26 <EvanR> i mean, if a task takes too long, it is cancelled, its also an OS :)
15:12:30 <chessandgo> you store your database in a ramdisk
15:12:33 <chessandgo> and buy a UPS
15:12:56 <EvanR> i am skeptical about the gains over SSD
15:13:05 <ibrahims> hello people, if i have an expression tree known at compile time, like (Add (Mult a b) x) what would you do to turn it into (\a b x -> a * b + x)? so the overhead of the expression tree is minimal at runtime? i am trying to see if i can optimize the tree evaluation if i were the get a list of (a, b, c) and just evaluate the expression tree just once. maybe i have gotten myself into a rather awkward
15:13:11 <ibrahims> situation, any direction is appreciated.
15:13:15 <Tuplanolla> I think you overestimate the amount of data a player is capable of generating.
15:13:25 <chessandgo> probably
15:13:26 <RedNifre> When using do-notation, why do you need "pure" at the end? Why isn't that implied by the notation?
15:13:40 <chessandgo> also, what do you mean by an OS
15:13:41 <jle`> RedNifre: you don't need pure at the end
15:13:49 <chessandgo> youre giving me a sinking feeling in my soul
15:13:51 <RedNifre> Okay, guess I imagined it.
15:13:55 <chessandgo> `did they write emacs in it`
15:14:03 <RedNifre> (or was it return? Hm)
15:14:03 <Tuplanolla> Consider the implementation of `join`, RedNifre.
15:14:04 <EvanR> do {sendEmail} would turn into do {pure sendEmail} ?
15:14:07 <jle`> RedNifre: the notation requires that all lines are of the same 'type constructor'
15:14:13 <jle`> the same Applicative/Monad
15:14:26 <jle`> so sometimes 'pure' is useful as a function
15:14:32 <davean1> RedNifre: pure = return
15:14:35 <EvanR> chessandgo: the event queue which causes a dispatcher to wake up at some time? thats the beginning of an OS
15:14:42 <jle`> RedNifre: if you're in an IO do block, for example, you have pure :: a -> IO a
15:14:50 <EvanR> (kernel)
15:14:53 <jle`> RedNifre: so if you watn the result to be '5', you can do 'pure 5 :: IO Int'
15:15:07 <chessandgo> my mud is going to be an exokernel
15:15:10 <Tuplanolla> :t \ m -> do {n <- m; n} -- This, that is, RedNifre.
15:15:12 <lambdabot> Monad m => m (m b) -> m b
15:15:17 <chessandgo> the jokes on you! monolithic/microkernels!
15:15:17 <EvanR> as long as it can read my email
15:15:24 <jle`> RedNifre: but if your last action is already IO, you don't need 'return' or 'pure', it already fits
15:15:45 <jle`> ibrahims: you can use TH
15:15:55 <davean1> RedNifre: and "pure" might come in the middle - it has exactly the same meaning everywhere
15:16:26 <RedNifre> Sounds good. I didn't consider the case where you don't use it because your last line is already an Applicative.
15:16:46 <jle`> ibrahims: but really id' only do it if you profile and see that your expressoin tree conversion is a bottleneck
15:16:48 <chessandgo> well, seems like all things have been solved. Looks like I dont have to stray from the light of the datbase gods (yet)
15:17:01 <EvanR> yes you may legitimately want to do{sendEmail} and do{...; pure sendEmail}
15:17:21 <chessandgo> and will probably just rewrite the code from scratch instead of trying to refactor and mangle a measily 300LOC
15:18:02 <chessandgo> EvanR: one last thing, why is there no good SSH server libraries for Haskell >:
15:18:20 <EvanR> theres TLS
15:18:22 <chessandgo> I have to use telnet for my mud like an unencrypted heathen
15:18:46 <EvanR> huh https://hackage.haskell.org/package/ssh
15:19:01 <chessandgo> theyre both unmaintained from what ive read
15:19:12 <EvanR> if it works.... it works
15:19:57 <chessandgo> telnet works too...
15:20:19 <EvanR> barely
15:20:34 <chessandgo> barely working is the proper text adventure feel
15:20:46 <EvanR> i have been using websockets for everything
15:20:53 <EvanR> gaming wise
15:21:00 <chessandgo> hows that working out for you
15:21:02 <chessandgo> I read about them
15:21:05 <chessandgo> they seem nice
15:21:05 <ibrahims> jle`: i have tried to look if i won't need TH. but thanks. i'll try that.
15:21:14 <EvanR> well, it has encryption :)
15:21:27 <chessandgo> and I was thinking I might as well just make a web front end for my MUD if im doing dumb stuff like water simulation
15:21:34 <spruit11> Twitter is trying to sell me `Magnetotherapy Boxers` for less money.
15:21:44 <spruit11> Put magnets on your dick.
15:21:51 <spruit11> Maybe it'll grow.
15:21:58 <spruit11> W.T.F.
15:22:00 --- mode: ChanServ set +o monochrom
15:22:22 <jle`> ibrahims: TH here is essentially compile-time evaluation
15:22:28 --- mode: monochrom set +q *!*@ip56522cc1.speed.planet.nl
15:22:43 <chessandgo> EvanR: I'll look into websocks (theres got to be a way to interface with from CLI, right?!, perhaps netcat)
15:22:51 <jle`> ibrahims: so you can compile your expression tree's result to haskell code, the literal (\a b x -> (*) a ((+) b x))
15:22:56 <jle`> and have that be compiled instead
15:23:01 <EvanR> chessandgo: sure, write a websocket client in haskell
15:23:08 --- mode: monochrom set -q *!*@ip56522cc1.speed.planet.nl
15:23:11 <EvanR> and not nodejs
15:23:12 --- mode: monochrom set -o monochrom
15:23:17 <chessandgo> welp, see you guys on the flip side, i have to go to my database class in 20 minutes
15:23:34 <chessandgo> no im going to use a haskell to js transpiler and wrap it up ontop of an electron app
15:24:32 <RedNifre> chessandgo can you put that in a docker container so I can run it on kubernetes on aws on a vm on a hypervisor on a machine somewhere?
15:25:18 <EvanR> on qemu on linux on a toaster
15:25:45 <hpc> it needs more serverless ansible unikernels
15:27:28 <RedNifre> try more design thinking.
15:28:03 <RedNifre> How could I even trust that MUD to not corrupt my character data if it doesn't use a blockchain?
15:32:10 <RedNifre> chessando is the MUD usable yet?
15:32:21 <RedNifre> *chessandgo
15:35:16 <jle`> chessandgo is gone :(
15:36:50 <RedNifre> Let's hope we did not miss the greatest MUD ever.
15:43:48 <typedrat> I know it's pretty damn late to start, but I unfortunately had some family stuff happen that prevented me from being able to really work on doing a GSoC proposal, and I think I'll still try and put in at least one proposal.
15:45:10 <typedrat> I'm not sure if it's a good use of my time, though, because on paper I'm pretty much a nothing, so I don't know if there's much reason to think I'd get accepted. I'm a community college student who's about to transfer to a four year but doesn't have official documentation to show on that yet...
15:46:06 <typedrat> I've done a ton of stuff with Haskell in my personal time, although there's not that much really amazing stuff on my Github either.
15:46:34 <danilo2> Hi guys! I've got a strange program that compiles but I was thinking it will not. Basically according to the instance resolution mechanism form ghc manual: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overlapping-overlappable-overlaps-and-incoherent-pragmas
15:47:03 <danilo2> This should not compile, or should it? http://lpaste.net/363968
15:47:37 <danilo2> It compiles fine, but I was thinkign that GHC would not choose the incoherent instance, because 2 other instance matches are there
15:47:44 <danilo2> what am I missing here?
15:49:51 <RedNifre> What's a good word for turning a Java String into a List<Character>? Haskellfy? Haskellize? (Don't worry, it's not for serious code).
15:50:12 <MarcelineVQ> unpack
15:50:13 <jle`> unpack
15:50:39 <jle`> that's what it's called in haskell, ghcjs base, idris, etc.
15:51:19 <RedNifre> Huh? I thought Strings are just a type synonym for [Char] so it's already a List of Char?
15:51:30 <jle`> the closest haskell equivalent to Java String is Text
15:51:41 <jle`> so we're talking abotu the haskell equivalent of Java String
15:52:08 <jle`> the only thing haskell's String and Java String have in common is their name, but they arne't really comparable data types
15:52:21 <RedNifre> Yeah, but the joke is that I want something that is like Haskell's String, not like Haskell's Text. But maybe the haskellize joke is lame anyway so unpack it is...?
15:52:37 <RedNifre> jle` I know, that's why i want to haskellfy them ;)
15:53:08 <jle`> maybe c-ify? :p
15:53:10 <RedNifre> Never mind, unpack is way easier to understand anyway.
15:53:28 <jle`> although c-ify would probably be Array<Char>
15:54:12 <jle`> yeah, unpack is the universal name for that in haskell and related ecosystems
16:20:54 <lyxia> danilo2: the incoherent instance is the most specific
16:21:12 <lyxia> danilo2: (src, ()) doesn't match (a, a)
16:21:44 <lyxia> danilo2: and (src, tgt) matches (a, a) (the required constraint), but is less specific than (a, a) (the incoherent instance)
16:25:41 <danilo2> lyxia: why (src, ()) doesnt match (a,a) ? It could
16:26:23 <danilo2> lyxia: if you remove the incoherent instance from the code, then GHC tells it cannot choose between (src,tgt) and (src,()) - bot hare candidates
16:27:03 <lyxia> danilo2: There is no substitution of the variables in (src, ()) that gives (a, a)
16:27:54 <danilo2> lyxia: so it will be taken in consideration in point 5, right ?
16:28:33 <lyxia> danilo2: yes, point 5 looks at instances that *unify*, and (src, ()) unifies with (a, a), with the pair of substitutions (src = ()), (a = ())
16:28:51 <danilo2> lyxia: ok, thank you, that makes sense now!
16:28:57 <danilo2> lyxia: thank you!
16:29:10 <lyxia> yw
17:43:31 <shachaf> Is there a name for the sort-of fixed point function :: (Either e a -> Either e b) -> a -> b?
17:48:36 <ReinH> shachaf: is that function partial?
17:48:52 <ReinH> Oh, no, it can't produce an e
17:50:24 <shachaf> Yes, it's partial if the function never returns Right.
17:50:46 <shachaf> But I found my answer, kind of: This is the Cochoice instance for (->)
17:52:29 <ReinH> shachaf: Right. I was thinking of \(Right a) -> Left ? but you can't.
17:57:05 <shachaf> I mean, you can certainly write _|_ with this.
18:54:24 <kinboy> hello
18:55:40 <andreabedini> kinboy: :wave:
18:57:42 <oo_miguel> can I somehow construct a lazy selfreferencing data structure as : "data P = Child P | Parent P"   where Child references Parent and vice versa?
18:58:39 <Wizek> oo_miguel: I believe you can by 'tying the knot'
18:59:01 <Wizek> oo_miguel: https://wiki.haskell.org/Tying_the_Knot
18:59:37 <Maxdamantus> fix (Child . Parent)
19:00:01 <oo_miguel> I am not familiar with this concept. will have a look thank you
19:00:17 <Maxdamantus> or let x = Child (Parent x) in x
19:03:38 <oo_miguel> nice thank you
19:05:09 <Wizek> By the way, I have a question. Are there people here who are open to pair programming on Haskell projects? E.g. I have some interest in contributing to the reflex-frp libraries in some ways, but find it a bit daunting to undertake such a task by myself at the moment. Could be nice to do screen sharing (e.g. with teamviewer) to spend 30-120 minutes towards a pre-agreed-upon goal. If time-symmetry and reciprocity is important for
19:05:09 <Wizek> either party, I could also imagine having fixed time frames focusing on one project that person A cares for more, then another project that person B cares for more. Maybe it would be most ideal if both parties equally care about the projects they pair on, but I wouldn't want to limit the net I'm throwing in that way.
19:16:48 <Wizek> Is that more of a no, or am I asking this at a time of lull? :)
19:17:12 <ab9rf> i have never cared for pair programming
19:17:27 <oo_miguel> and I still suck in haskell :P
19:17:28 <ab9rf> i don't learn well by watching
19:17:34 <ab9rf> and yeah, i suck at haskell, too
19:17:54 <ab9rf> i don't even begin to understand frp-reflex, for example
19:19:34 <Wizek> ab9rf: and what's your experience of being the 'driver', the person who is doing the coding instead of the watching? Have you tried pair programming in that direction before?
19:20:21 <ab9rf> Wizek: my only real experience with such environments woud have been in the mid-1980s for a couple of programming contests when i was in high school, and those did not go well.
19:20:44 <ab9rf> my best collaborative experiences have been when i've paired off with a tester
19:21:25 <ab9rf> we me writing the code and someone else breaking it
19:21:52 <ab9rf> but that was 20 years ago in C
19:22:50 <Wizek> ab9rf: how unwell did they go, if you don't mind me asking?
19:22:59 <ab9rf> Wizek: we didn't win :)
19:25:28 <ab9rf> i don't remember specifics. we are talking about stuff that happened in 1985 or 1986, after all
19:27:03 <Wizek> oo_miguel: What level would you place that suckiness at? :) I thought I would have some chance of finding some here who at least care for Haskell; as the friends of mine whom I already know don't even have much of an interest in the language.
19:28:43 <ab9rf> there's plenty of highly skilled haskellers in here, but i wouldn't guarantee that you'll get a taker on your proposal
19:30:42 <Wizek> I'm interested in engaging a bit with others too, even if they aren't jumping up with a "yes"; so far we have 2 people saying they don't know as much haskell (As they'd like? As they imagine this would require?) and one who doesn't very particularly like pair programming. Is that representative perhaps? Or are there others here who like pairing but something else keeps them from saying yes?
19:31:53 <ab9rf> well it's also possible that some people are asleep
19:32:02 <Wizek> ab9rf: No, I didn't imagine any guarantees either. :) But even if there are no takers, I hope to understand what's holding folks back.
19:32:14 <ab9rf> it is early in the morning in yurp
19:32:39 <Wizek> ab9rf: very possible. These may have been the least busy hours I could have asked at.
19:33:02 <ab9rf> and i'm multitasking between this and watching hockey
19:33:11 <Wizek> I guess I could also ask on reddit, that way its less timing-sensitive
19:38:26 <ab9rf> i honestly do not know what development models are popular in haskell shops
19:38:29 <ab9rf> there are not many of them
19:38:45 <oo_miguel> It's 3:30 in yurp :P I am going to bed now.
19:39:06 <Wizek> good night oo_miguel
19:39:25 <Wizek> I might sleep soon too
19:40:10 <oo_miguel> Never tried remote pair programming, also I am starting my haskell adventure now (read one and a half book and played around a bit). I imagine I would be not much of help :P
19:40:39 <oo_miguel> good night too
19:41:00 <ab9rf> i have a little project that i should just sit down and write
19:41:08 <ab9rf> there's nothing really intersting about it, though
19:45:50 <Wizek> oo_miguel: Maybe that would be a bit different, but that might interest me too. To help out someone quite early on in their learning where they are the 'driver'. They could ask me questions,  ask for suggestions, to explain concepts, to get them unstuck, etc. I've done this a few times with friends, usually had fun.
19:57:23 <Wizek> Either way, I'll be afk for about 8 hours or so, but feel free to mention or pm me about the topics above, I'll see them when I wake up.
19:57:32 <ab9rf> i'm not good enough at haskell to act as a mentor
19:57:56 <ab9rf> there are some things i understand, but far more that i either do not understand or, worse, misunderstand
20:27:37 <dysfigured> "a monad is a monoid in the category of endofunctors"  don't monads 'inherit" from applicatives as well?
20:28:43 <ab9rf> mmm
20:29:00 <xandaros> That, I believe, is actually coincidental
20:29:05 <ab9rf> i think so as well
20:30:06 <dysfigured> attempting to write yet another monad explanation
20:30:15 <xandaros> don't
20:30:20 <dysfigured> i enjoy writing
20:31:10 <dysfigured> and in the process of writing about what i learned, i often want to fact-check myself, which leads to fun and interesting coversations, and usually more knowledge acquired
20:34:03 <jle`> i wonder if there's a reason that vector doesn't have generateA, and just generateM
20:34:21 <jle`> other than historical ones, since i'm presuming that the vector library predates Applicative
20:36:00 <ab9rf> jle`: probably
20:36:07 <jle`> well it's 2018
20:36:19 <ab9rf> lots of historical warts like that
20:36:51 <jle`> time for change :)
20:37:54 <Guest59292> hello
20:38:19 <Axman6> goodbye :(
20:45:24 <Guest59292> hello
20:47:33 <ab9rf> jle`: change is good, except when it's not
20:50:15 <rotaerk> anyone here successfully used vulkan in haskell?
20:51:00 <rotaerk> GLFW is a popular library to handle the windowing for vulkan, but GLFW-b and bindings-GLFW target a pretty old version of GLFW, which doesn't seem to support vulkan
20:58:23 <rotaerk> hah, I see... the guy who did vulkan-api made a fork of GLFW-b where he made some tweaks to add some vulkan support
20:58:41 <rotaerk> it's like a hacked partial upgrade to GLFW 3.2
21:05:24 <Guest59292> hello
21:05:57 <ab9rf> yello
21:10:34 <unyu> Sorry for the dumb question, but how would you compile xmonad on 8.4.1? GHC is complaining about Monoids without Semigroup instances. :-|
21:12:05 <glguy> You'd either fix the compile errors or use an older GHC
21:15:18 <unyu> It's nice that in the name of intellectual purity it was decided to make Semigroup a superclass of Monoid, but apparently some people haven't had enough time to update their programs to have Semigroup instances...
21:16:19 <glguy> 8.4.1 only just came out, it will take time for everyone to update
21:21:37 <xandaros> I mean... it's not like we knew this would happen when 8.0 came out or anything...
21:24:14 <Lears> unyu: xmonad and xmonad-contrib already have 8.4 compatibility patches going/gone through. But your distro's repos are unlikely to see those for some time, so you'd need to install from git manually.
21:36:47 <unyu> Lears: I was actually trying to install from Hackage, but I'll try to install from git as you say. Thanks.
21:46:09 <unyu> Is there anything like “cabal install --dependencies-only --but-please-exclude-this-one-dependency-too foo”?
21:48:24 <jle`> unyu: Semigroup being a superclass of Monoid is also for engineering/practical benefits, too
21:48:34 <unyu> jle`: I'm aware.
21:48:37 <jle`> if it was just intellectural purity, i doubt it would have ever happened :)
21:49:06 <unyu> I'm just saying “it could have been made *after* people have updated their libraries to include Semigroup instances”.
21:49:34 <jle`> do you mean every library on hackage?
21:49:39 <jle`> or just most of them?
21:49:47 <jle`> if 'most of them', then, yeah, most of them already did :)
21:50:21 <jle`> especially the ones that have been compiling with -Wcompat
21:51:08 <unyu> Really, the ideal situation would be to have ML modules, so that SEMIGROUP is a supersignature of MONOID without anyone having to do anything, like breathe or lift a finger, but let's now get to solving actual problems.
21:51:21 <jle`> but i don't think it would be practical to wait until 100% of hackage updates before every release.  usually we wait 2 or more ghc cycles of warnings
21:51:39 <unyu> I created a common sandbox for xmonad and xmonad-contrib.
21:51:50 <unyu> And I successfully compiled xmonad inside of it.
21:52:09 <unyu> Now I need to compile xmonad-contrib using the sandbox's xmonad, rather than Hackage's.
21:52:19 <unyu> How would I do that?
21:52:43 <jle`> what build tool are you using?
21:52:50 <unyu> cabal
21:52:53 <unyu> Or should I use stack?
21:53:13 <unyu> If using stack will make things easier, I'm switching right now.
21:53:48 <jle`> not sure if it is easier or not, but just asking because any answer you get will probably depend on which one you are using
21:54:01 <unyu> Ah...
21:54:09 <dibblego> unyu: No.
21:54:11 <jle`> i don't quite have any experience with cabal sandboxes, but others here might :)
21:54:48 <unyu> dibblego: No to what specifically?
21:55:06 <dibblego> unyu: "should I use stack?" It is always no
21:55:52 <dibblego> FWIW, cabal sandbox works reasonably well, and more recently, cabal new-build
21:57:25 <unyu> Ah.
22:03:51 <Myrl-saki> Hewwo. :3
22:04:15 <Myrl-saki> :t catMaybes
22:04:16 <lambdabot> [Maybe a] -> [a]
22:04:28 <unyu> Ah, “cabal sandbox add-source” was what I was looking for.
22:04:36 <Myrl-saki> unyu: Hallyu~
22:04:39 <unyu> Myrl-saki: Hello.
22:05:01 <Myrl-saki> unyu: I started reading Lang.
22:05:10 <unyu> Myrl-saki: Which specific book?
22:05:27 <Myrl-saki> unyu: Graduate Texts in Mathematics
22:05:41 <unyu> Myrl-saki: No, I mean, which specific book by Lang.
22:05:48 <unyu> Myrl-saki: Lang is a very prolific author.
22:06:02 <unyu> GTM is a collection, not a single book, btw.
22:06:06 <Myrl-saki> Ohh
22:06:11 <Myrl-saki> unyu: Ah, I see. Lang.
22:06:13 <Myrl-saki> Err
22:06:15 <Myrl-saki> Algebra
22:06:27 <Myrl-saki> unyu: Ffs. Without coffee, I'm dull. With coffee, I'm still dull.
22:07:12 <unyu> Ah...
22:08:01 <Myrl-saki> unyu: Also experimented with the interleave package for Emacs.
22:09:02 <unyu> Let's talk about this over PM. This is probably not on topic here.
22:33:38 <dsjackins> Hi guys, was hoping someone would be able to help me figure out why my program isn't working. http://lpaste.net/1344764838882050048
22:34:36 <pavonia> A bit more information would be helpful
22:34:40 <dsjackins> It takes in a list of polyominos and sees if they can fit on a board, and it does work for some smaller test data i've given it, but when I give it a 3x30 board and 12 polyonimos that its supposed to pass, it seems to just run forever
22:34:47 <unyu> Is there anything like “cabal sandbox add-source”, but which works outside of a sandbox?
22:36:16 <dsjackins> i'm wondering if its overflowing the stack or something, but it doesn't give errors and it never terminates. i've let it run for a couple days at one point.
22:38:13 <pavonia> dsjackins: Is the implementation of countdown correct in myInsert? Looks like it runs forever if n = 0
22:40:44 <unyu> Alternatively, I have built some stuff in a sandbox. Is there some convenient way to install the resulting executables and libraries globally?
22:51:24 <woodson> Can anyone assist me with this? http://lpaste.net/363972
22:51:51 <woodson> getting a     • Could not deduce (SFObject a0)
22:51:51 <woodson>         arising from a use of ‘sfObjectName’
22:51:51 <woodson>       from the context: (ToJSON a, FromJSON a, SFObject a)
22:52:24 <woodson> error message... I am not sure why it represent my generic variable as a different ?? a0
22:53:21 <woodson> why does the doesnt the compiler see the single generic type a as the same throughout my function??
22:53:54 <phadej> woodson: {-# LANGUAGE ScopedTypeVariables #-}
22:54:19 <phadej> postSObjectRow :: forall a. (ToJSON a...
22:54:32 <dsjackins> pavonia: yeah you were right, thanks. fixed that. i don't think that was the problem though because it was never being called with a 0
22:54:58 <phadej> woodson: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#lexically-scoped-type-variables
22:56:28 <woodson> phadej: Thanks, it worked! but I really appreciate the link that you gave me. I hate not knowing what these extensions do
22:56:34 <woodson> thanks again.
22:56:48 <phadej> +1
23:02:43 <unyu> So, if I build xmonad in a sandbox, how exactly should I compile my xmonad.hs file?
23:17:10 <cocreature> unyu: take a look at https://github.com/xmonad/xmonad-testing in particular https://github.com/xmonad/xmonad-testing/blob/master/build-scripts/build-with-cabal-sandbox.sh
23:54:16 <pingu\-> Is everything registered these days?!
23:54:17 <manuel-uberti> hi everybody. Haskell beginner here, so I'll hang out mostly on #haskell-beginners so not to bother you guys here :-)
23:54:29 <pingu\-> manuel-uberti: you're not bothering anyone here
23:54:33 <manuel-uberti> still, I heard so many good things about this channel I wanted to check it out
