00:03:43 <nshepperd1> "git commit -am .." <- 90% of the commits in my finances repo
00:09:29 <dminuoso> Servant question. How do I specify something like: type API = "users" :> ...  :<|> "users" :> Capture "name" String :> ....
00:09:44 <dminuoso> Or do I have to use the latter and just check on the length of the string?
00:10:33 <cocreature> dminuoso: just like you suggested?
00:10:54 <dminuoso> cocreature: Requests are fed just into the first
00:11:24 <cocreature> you might need some parenthesis. I don’t recall the precedence
00:12:08 <dminuoso> cocreature: Okay this is bizarre. I think that must have been some typo, yeah it works now.
00:15:47 <dminuoso> cocreature: Ohh! Heh, I know what went wrong. I just saved in my editor, expecting everything to recompile and restart.. silly Rails people trying Haskell. :-)
00:16:44 <cocreature> heh
00:23:48 <robstr> Is there a library that allows conversion for time units ? I want to write `threadDelat 1 second`
00:24:52 <phadej> there's unbounded-delay which you might wanna use
00:26:08 <phadej> but dunno about simple time library, I just * secs (where secs = 1000000 -- microsecond are the base unit)
00:26:39 <robstr> phadej: thank you
00:29:00 <osa1> in a newtype `newtype T = T { unT :: A }` is there a name given to `unT`? in other words, what do you call functions that unwrap newtypes?
00:29:21 <jle`> accessors ?
00:29:33 <jle`> record accessors, maybe
00:29:48 <jle`> since it's not just newtypes
00:29:57 <osa1> but this is not a record. I'd like to emphasize that the function is just a coercion rather than an accessor
00:30:04 <jle`> this is a record
00:30:09 <osa1> wat
00:30:12 <jle`> that's what { unT :: A } syntax is
00:30:14 <osa1> it says "newtype"
00:30:16 <jle`> it's record syntax
00:30:34 <jle`> yes, newtype-or-not-newtype is unrelated to record-or-not-record
00:30:45 <jle`> you can have newtype records, newtype non-records, data records, data non-records
00:30:51 <jle`> it's like two independent axes :)
00:31:12 <osa1> to me a record is a tuple with named fields but OK
00:31:35 <jle`> yeah, record is a technical word in haskell
00:32:28 <jle`> it's a specific syntactic construct
00:33:19 <cocreature> osa1: fwiw Haskell2010 seems to call it “field-naming syntax” and calls "unAge" the de-constructor.
00:33:54 <osa1> cocreature: thanks. which section?
00:34:16 <cocreature> osa1: the end of 4.2.3.
00:34:59 <jle`> interesting, it does refer to it as 'the record syntax' later on too in the same chapter
00:35:00 <robstr> Is there a recommended library for postgres ? I need the array type too
00:35:22 <cocreature> the haskell report really needs an easier way to link to a specific section
00:36:00 <jle`> i don't think i've heard people call it the 'de-constructor' very often, but i hear record accessor pretty often
00:36:17 <cocreature> jle`: afaict it only uses that name for data declaration not newtypes
00:36:30 <jle`> cocreature: yeah, you can sort of cheat by looking at anchors in the source
00:36:35 <jle`> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-740004.2.3
00:36:51 <cocreature> yeah but I just can’t be bothered to do that. there should just be links next to section headers
00:37:57 <jle`> it uses 'record syntax' to refer to both newtypes and data in chapter 11
00:38:32 <cocreature> ah I’ve only looked in chapter 4
00:38:35 <cocreature> *shrug*
00:38:57 <jle`> yeah, not that it's super important heh
00:39:01 <jle`> i just ctrl+f the pdf these days
00:40:15 <Lears> lizzie: dminuoso: Followup to what I was saying before about fizzbuzz and the ZipList Applicative. If you pull out all the type signatures and empty lines it's probably reasonably concise. https://gist.github.com/LSLeary/7df9c04829ba3aa69d7099ce2e00eb7d
00:41:55 <Lears> I guess you can also strip the import if you just use zipWith as liftA2..
00:56:08 <frerich> Interesting - in 'Programming in Haskell', I read that if it's possible for a type to define a law-abiding Functor instance, then there's exactly one way to do it (i.e. there's at most one law-abiding Functor instance for a type). I have no reason to believe that Graham Hutotn is wrong, but it's still hard to believe that there's really just one possible Functor instance!
00:57:17 <vaibhavsagar> frerich: That's the basis of the DerivingFunctor language extension
00:57:44 <cocreature> the fact that you can implement automatic deriving of some instance doesn’t really tell you that there is only one
00:57:44 <vaibhavsagar> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/DeriveFunctor
00:58:01 <dminuoso> Lears: I think the implementation on the article I linked is the cleanest variant.
00:58:02 <cocreature> we can derive Ord as well but there is certainly more than one way to implement it
00:58:03 <frerich> vaibhavsagar: Yeah, I guess so - I always thought that language extension simply chooses any valid definition (though there may be more than one).
00:59:51 <dminuoso> Lears: I mean compare yours with https://gist.github.com/dminuoso/489e07c682f67d94a010ae2c7abf1339
01:00:06 <vaibhavsagar> cocreature: you're right that the extension doesn't imply the truth of one functor instance, but that's also not what I said :)
01:00:43 <vaibhavsagar> frerich: the Typeclassopedia has more info: https://wiki.haskell.org/Typeclassopedia#Functor
01:01:05 <vaibhavsagar> specifically a link to http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384
01:04:17 <Lears> It won't get much simpler than the one you linked, dminuoso -- and that's a kind of cleanliness, which is nice. But like I said earlier, I think part of the point of the fizzbuzz exercise is writing something than enables extension or generalisation in a clean way. If you tried to write fizzbuzzjazz or fizzbuzzjazzpezz in that manner it wouldn't go well.
01:33:35 <ertes-w> hllo
01:33:57 <dminuoso> hllo rts-w
01:34:25 <dminuoso> ertes-w: If you want, I have some spare e keys from my IBM Model M collection
01:35:12 * ertes-w thinks really hard
01:37:30 <ertes-w> frerich: you can easily prove this for yourself, because all algebraic types can be expressed in terms of sums, products and functions
01:37:46 <ij> Could anyone implement a liftBaseWith for a ReaderT newtype for me? I've been stuck for so long already.
01:40:29 <ij> Note: I won't be paid for it and it's not homework. :)
01:42:48 <sayola> i do sometimes homework for others, because i think there is no point in forcing people to learn things they don't want. lol
01:43:09 <osa1> ij: it should be implemented already. is this as an exercise?
01:43:37 <osa1> ah, you said newtype
01:49:25 <ij> So I need to write a liftBaseWith using the unwrapped value with another liftBaseWith that's for a ReaderT, then wrap it back, but I keep staring at it like an idiot and I just can't.
01:51:07 <vaibhavsagar> ij: would typed holes help you here?
01:52:54 <ij> I think finally I found an answer on SO that answers this very question. Let me try it.
01:53:48 <clamchowder> Hi I'm trying to use hakyll. After a clean install of stack and `stack setup`, `stack install hakyll` installs version 4.12 of hakyll. Then I executed `hakyll-init my-site` and cd'd into my-site. Following the tutorial of hakyll I `stack init`, but stack complained it can't find version 4.12 of hakyll in stackage. I wonder if anyone could help?
01:54:53 <vaibhavsagar> clamchowder: which resolver is in your stack.yaml?
01:55:06 <ertes-w> > let r s n = cycle (Just s : replicate n Nothing) in tail $ zipWith3 (\i m3 m5 -> maybe (show i) id (m3 <> m5)) [0..] (r "Fizz" 2) (r "Buzz" 4)
01:55:09 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
01:55:26 <ertes-w> > let r s n = cycle (Just s : replicate n Nothing) in drop 10 $ zipWith3 (\i m3 m5 -> maybe (show i) id (m3 <> m5)) [0..] (r "Fizz" 2) (r "Buzz" 4)
01:55:30 <lambdabot>  ["Buzz","11","Fizz","13","14","FizzBuzz","16","17","Fizz","19","Buzz","Fizz"...
01:56:01 <clamchowder> vaibhavsagar: there is no stack.yaml in `my-site`
01:56:33 <clamchowder> vaibhavsagar: I may have deleted it. Let me redo the hakyll-init
01:56:49 <vaibhavsagar> clamchowder: no, I don't think hakyll-init creates a stack.yaml
01:57:41 <vaibhavsagar> one solution is to change your my-site.cabal file to use hakyll-4.10 and create a stack.yaml with lts-10.10
01:58:09 <vaibhavsagar> I don't think hakyll-4.12 is on stackage in any resolver, so I'm mystified as to how stack installed that for you
01:58:23 <vaibhavsagar> unless you explicitly specified that version
01:58:27 <dminuoso> ertes-w: That's pretty sleek :)
01:59:02 <clamchowder> vaibhavsagar: ok I found the resolver in ~/.stack/global-project/stack.yaml which is lts-11.1
01:59:48 <vaibhavsagar> clamchowder: that doesn't have hakyll at all though, so maybe stack gets the latest version off Hackage in that case?
02:00:07 <vaibhavsagar> with every stack question that gets asked here I like it less and less
02:00:07 <ertes-w> dminuoso: i consider that the standard approach if one understands prime sieves =)
02:00:09 <clamchowder> vaibhavsagar: thanks I'll try that. By the way why does stack install from hackage and build from stackage? Isn't this inevitably going to cause the same problem very often?
02:00:39 <vaibhavsagar> clamchowder: Stack is supposed to use stackage, unless you explicitly specify otherwise
02:01:07 <merijn> Anyone that can remind me which IRC nick is used by the guy working on Haddock?
02:01:36 <clamchowder> vaibhavsagar: I didn't specify anything, but stack install hakyll installed 4.12 which is only on hackage
02:01:50 <clamchowder> vaibhavsagar: see https://www.stackage.org/package/hakyll
02:01:53 <vaibhavsagar> clamchowder: I did say 'supposed to'
02:01:55 <ertes-w> dminuoso: (that's why i'm not much of a fan of these kinds of challenges…  it's not a *programming* challenge)
02:02:35 <dminuoso> ertes-w: I'd argue that it is a *programming* challenge, in that you frequently need to approach problems mathematically to find good solutions.
02:03:03 <clamchowder> Is there anyway to config stack to only install from stackage?
02:03:45 <dminuoso> clamchowder: If you dont specify extra-deps, then stack will only select packages from your resolver
02:03:59 <vaibhavsagar> clamchowder: don't ever use `stack install`
02:04:49 <ertes-w> dminuoso: let me put it this way: the actual programming is not challenging, neither for naive nor for good solutions
02:05:06 <ertes-w> so that makes it a math puzzle much more than a *programming challenge*
02:05:12 <tdammers> indeed
02:05:30 <tdammers> a programming challenge would be one where the most challenging part is program design
02:05:32 <MarcelineVQ> ever is a bit heavy. install is intended for building and copying executable files to the ~/.local/bin directory, not for making libraries available. it just happens to make libraries available for the current resolver while satisfying dependencies
02:05:39 <clamchowder> dminuoso: there is no extra-deps in my stack.yaml
02:05:56 <tdammers> how do you set up your data structures, what are your abstractions, how do you make it manageable, how do you gain certainty
02:06:08 <clamchowder> vaibhavsagar: ok, then how do I use stack to install packages?
02:06:20 <vaibhavsagar> clamchowder: you don't, stack is a build tool
02:06:42 <tdammers> clamchowder: you add the desired packages to your .cabal file, and then rebuild
02:07:34 <tdammers> clamchowder: stack is intended for a project-centric workflow, not an environment-centric one
02:08:49 <tdammers> clamchowder: the premise is that you are composing a "project", and that stack's job is to parse that project and turn it into a build artifact. There isn't really a concept of a "current environment" that you can install packages into - stack does maintain one, but this is conceptually just an implementation detail, and being able to do things in that environment at all is kind of an afterthought
02:09:18 <vaibhavsagar> notice the complete absence of any `stack uninstall`
02:09:25 <vaibhavsagar> this is telling
02:11:52 <clamchowder> vaibhavsagar, tdammers: OK thanks I get what you mean
02:12:12 <sayola> cant even cabal uninstall ..
02:13:05 <vaibhavsagar> sayola: sure, but cabal isn't a package manager either
02:13:15 <vaibhavsagar> clamchowder: https://github.com/commercialhaskell/stack/pull/602/files#diff-f6aef6f8551ef69c947357fb3387ad22R513
02:13:32 <dminuoso> sayola: ghc-pkg unregister
02:13:45 <sm> alias stack-uninstall='stack exec -- ghc-pkg unregister'
02:13:50 <clamchowder> but in my case it is different: the "project" is not built by hand, but generated with hakyll-init. There might be a problem if I make the .cabal to take a different version of hakyll for the project from the one that initiated the project.
02:14:12 <vaibhavsagar> clamchowder: what kind of problem?
02:14:22 <sayola> vaibhavsagar: wikipedia classifies cabal as package manager.
02:14:39 <vaibhavsagar> sayola: I misspoke, it is not an OS package manager
02:14:49 <sayola> :D
02:15:04 <vaibhavsagar> there is a difference between OS package managers and language package managers
02:15:14 <sm> it's a package manager which does not support uninstall very well :)
02:15:30 <clamchowder> vaibhavsagar: I don't know, if you start with something built with one version and work on it with a different version there might be a problem in general
02:15:44 <vaibhavsagar> clamchowder: what kind of problem?
02:15:57 <vaibhavsagar> I use Hakyll for my blog too
02:16:32 <clamchowder> vaibhavsagar: like 4.12 has some new features which 4.10 does not support. I haven't used hakyll but this is a possibility to me
02:16:40 <tdammers> cabal became a package manager by accident
02:16:59 <tdammers> its main purpose is to be a build tool
02:17:00 <vaibhavsagar> clamchowder: in that case, install hakyll-4.10 and use that to regenerate your my-site
02:17:28 <tdammers> but some package management is required for that, and since things you build end up being used, people started using it as a package manager too
02:17:47 <tdammers> also because there isn't anything else that could fill that particular gap, or at least there wasn't at the time
02:18:04 <clamchowder> vaibhavsagar: then it goes back to the question: how do I install hakyll-4.10? :)
02:18:30 <vaibhavsagar> clamchowder: if you ignore my advice to never use `stack install`, it's easy: `stack install hakyll-4.10`
02:18:45 <sayola> tdammers: could have used the OS package manager ..
02:18:48 <vaibhavsagar> I don't remember you asking this question, or I would have answered it earlier :)
02:19:09 <clamchowder> vaibhavsagar: haha thanks
02:19:28 <tdammers> sayola: not practical on a fast-moving ecosystem like this
02:19:40 <clamchowder> vaibhavsagar: oh I mean the general question of how to use stack to install
02:19:47 <tdammers> sayola: and definitely not practical when you need to resolve dependencies on a per-project basis
02:19:48 <sayola> tdammers: afaik it wasn't fast-moving back then.
02:20:11 <vaibhavsagar> clamchowder: the correct answer to that question is 'No.', as I mentioned above :)
02:20:18 <clamchowder> haskell package management is such a mess
02:20:26 <vaibhavsagar> clamchowder: that's false
02:20:30 <sm> not at all
02:20:37 <vaibhavsagar> clamchowder: your usage of Stack is a mess
02:20:47 <tdammers> it is kind of a mess currently, but not as bad of a mess as you think
02:21:35 <sm> well, I guess it's all relative
02:22:08 <clamchowder> If I shouldn't use stack to install packages in general, what should I use?
02:22:39 <vaibhavsagar> clamchowder: it depends on what you mean by `install`
02:23:06 <vaibhavsagar> and which operating system you run
02:23:37 <tdammers> it actually depends on which build tool you want to use
02:23:43 <tdammers> for haskell dependencies, that is
02:23:58 <sm> clamchowder: there's nothing wrong with that approach. I think you got some bad advice
02:24:08 <vaibhavsagar> sm: oh, really
02:24:17 <sm> oh boy :)
02:24:20 <tdammers> the important thing to remember is that there are two separate notions of "installing" here
02:24:31 <tdammers> one is "make a Haskell package available to the compiler"
02:24:43 <vaibhavsagar> sm: I'd love to hear how my advice is bad
02:24:44 <tdammers> the other one is "make a program or system library available to everything"
02:24:58 <clamchowder> vaibhavsagar: by install a package I mean an activity to achieve: 1. I can import it whenever I want to edit and compile an hs file; 2. have the binary ready to use, like hakyll-init;
02:25:21 <tdammers> clamchowder: yes, and those are two separate kinds of "installing"
02:25:25 <vaibhavsagar> clamchowder: as tdammers astutely pointed out, those are two different things
02:25:49 <clamchowder> My os is arch linux
02:26:04 <tdammers> stack install would get you the second one, but the first one is done differently with stack - you just add the Haskell dependency to your project (.cabal and possibly stack.yaml), and then you rebuild (but not necessarily install) the project
02:27:03 <tdammers> by contrast, cabal install does both, depending on what kind of artifact a project produces - for libraries, it just does 1., for binaries, it just does 2., and for projects that have both, it does both
02:27:10 <sm> vaibhavsagar: I refer to your "don't ever use `stack install`". I expect we don't need to argue about that. No offense intended. tdammers++
02:28:07 <tdammers> and depending on whether or not you are using a sandbox, cabal install will do both of these relative to the user-global package DB or the one in the sandbox
02:28:14 <vaibhavsagar> sm: I stand by that advice, see https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/#understanding-stacks-model-and-avoiding-its-biggest-gotcha
02:28:19 <sm> tdammers: your second case is really two, also. Some folks are only interested in installing binaries
02:28:28 <vaibhavsagar> but you're right, it's not worth arguing about
02:28:47 <vaibhavsagar> clamchowder: do you have experience with other programming languages, and if so, which ones?
02:28:49 <tdammers> sm: hence, "or"
02:29:32 * sm likes to make the lib/program distinction really clear, I think it's a common source of confusion
02:29:47 <vaibhavsagar> > While it might sometimes appear to work, it’s almost always wrong. The only situation in which stack install is the right answer is when you want to install an executable for a use unrelated to Haskell development (that is, something like pandoc) that just so happens to be provided by a Haskell package.
02:29:50 <lambdabot>  <hint>:1:40: error: parse error on input ‘,’
02:29:57 <vaibhavsagar> sorry lambdabot
02:30:51 <rc202402> Hi everyone. What does lamdabot do?
02:30:51 <clamchowder> tdammers: OK correct me if I am wrong: this approach adds a lot of overhead when I just want to something out in a single .hs file
02:31:07 <vaibhavsagar> clamchowder: look at `stack script`
02:31:27 <vaibhavsagar> clamchowder: https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter
02:31:53 <vaibhavsagar> this is something they get very right :)
02:32:42 <clamchowder> tdammers: I used cabal install before, but had problems which I forgot, and everyone recommended using stack instead :)
02:33:14 <merijn> clamchowder: Whether people recommend stack depends very much on who/where/when you ask
02:33:31 <clamchowder> vaibhavsagar: I do python quite often these days
02:33:44 <vaibhavsagar> clamchowder: do you use virtualenvs?
02:34:05 <clamchowder> vaibhavsagar: no
02:34:10 <merijn> vaibhavsagar: Trigger warning :(
02:34:10 <vaibhavsagar> this explains a lot
02:34:23 <sayola> very triggered :D
02:34:46 <merijn> The more I use python packages, the more I love cabal-install
02:35:55 <vaibhavsagar> merijn: pip without virtualenvs is very much like cabal-install without sandboxes IMHO
02:36:08 <merijn> vaibhavsagar: I use new-build :p
02:36:15 <vaibhavsagar> :thumbsup:
02:36:27 <tdammers> vaibhavsagar: conceptually, yes, but cabal's dependency resolution is a lot more sophisticated
02:36:44 <merijn> Also, cabal-install is much easier to get working without root
02:36:48 <tdammers> basically the reason cabal hell exists at all is because cabal attempts to solve problems that other package managers simply ignore
02:37:25 <vaibhavsagar> tdammers: I didn't even want to bring cabal hell up
02:37:32 <Ariakenom> rc202402, lambdabot can evaluate code!
02:37:35 <merijn> cabal hell doesn't exist anymore >.<
02:37:37 <Ariakenom> > head [1,2,3]
02:37:40 <lambdabot>  1
02:38:23 <tdammers> vaibhavsagar: even without cabal hell, cabal will refuse to install things because of incompatible version bounds more often than most others
02:38:50 <tdammers> that doesn't mean the others do a better job, on the contrary, it's just cabal failing earlier and more loudly, which is good
02:38:57 <tdammers> still annoying to the end user though
02:39:11 <vaibhavsagar> tdammers: I only wanted to discuss the downsides of installing packages into a global mutable environment vs in a sealed environment
02:39:26 <vaibhavsagar> this is a concern both pip and (old-style) cabal share
02:39:38 <vaibhavsagar> (at a high level)
02:40:09 <clamchowder> Anyway, is there any book that has a good explanation of cabal-install / stack / virtualenv kind of things?
02:40:43 <sm> clamchowder: how about cabal's and stack's user guides ?
02:40:59 <marvin3> vaibhavsagar, I've read the link you posted. as far as I understand, `stack install' is the same as `stack build' for libraries, and for programs it also copies the resulting binary to some location that is pressumably in PATH (with exact location being configurable). so what is the problem, exactly? apart from him not liking that they used the word "install"
02:41:30 <vaibhavsagar> marvin3: did you read the other link I posted? https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/#understanding-stacks-model-and-avoiding-its-biggest-gotcha
02:41:53 <marvin3> that is exactly what I've read
02:42:44 <vaibhavsagar> as Alexis points out, 99% of the time `stack install` is the wrong command to issue
02:43:11 <sm> vaibhavsagar: you have to qualify that with. As a general statement it's rubbish
02:43:28 <guessWHo> when we read a value from a Chan with readChan does it empties the chan ??
02:43:34 <marvin3> copying resulting executables to ~/.local/bin (exact path is adjustable) is wrong? why?
02:44:16 <clamchowder> sm: sure, if the guides are the best educational resource
02:45:05 <vaibhavsagar> sm: `stack build --copy-bins` is the right solution in the other 1% of cases
02:45:16 <vaibhavsagar> therefore `stack install` is always wrong
02:45:34 <marvin3> stack install is alias stack build --copy-bins. how can one be wrong and other not when they do exactly the same thing
02:45:38 <marvin3> +for
02:45:47 <vaibhavsagar> the difference is that with `stack install --copy-bins` you know what you're doing
02:45:57 <vaibhavsagar> you're not aping some other language's workflow
02:46:21 <vaibhavsagar> it's like saying, "yes, I read the docs, this is what I want"
02:46:38 <vaibhavsagar> look, I'll agree to disagree but I stand by what I'm saying
02:46:42 <barrucadu> I don't see why `stack install` means you don't know what you're doing
02:48:23 <vaibhavsagar> barracudu: I'm not going to link lexi-lambda's blog post again
02:48:41 <tdammers> vaibhavsagar: I would say that this is between you, stack, and your keyboard
02:48:55 <barrucadu> Ok, fine, I know what the arguments are but I don't consider them valid
02:49:13 <merijn> In other news: This discussion is profoundly boring >.>
02:50:48 <barrucadu> As the blog post says, `stack install` is more like `make install` than `npm install`.  So it's not like `stack` (or `cabal`) is doing something totally bizarre and unique here.  It's a fairly well-established thing.
02:50:52 <clamchowder> merijn: sorry about that - i started it
02:51:28 <barrucadu> There's also the `install` command, which copies files and directories.  Is that bad because there's no `uninstall`?
02:54:01 <tdammers> barrucadu: there is, it's called `rm`
02:54:45 <tdammers> barrucadu: the only reason that `install` exists is because the way `cp` handles file attributes isn't what you want in this particular case
02:55:07 <barrucadu> Sure, but `install` isn't installing in the same sense as a package manager, so I guess if `stack install` and `cabal install` are confusing then so must be `install`
02:55:38 <tdammers> indeed, the word "install" has multiple meanings
02:55:51 <vaibhavsagar> barracudu: I use NixOS, which is one of the few OSs which doesn't have this problem
02:56:04 <barrucadu> It just seems odd to me that people complain `stack install` or `cabal install` are confusing, when they're just re-using an existing use of "install" which has been used by build systems for a long time
02:56:20 <tdammers> agree
02:56:23 <humanoyd> tdammers: in what way are file attributes handled differently by `install`?
02:56:26 <barrucadu> If stack/cabal had coined a new use of "install" than would be one thing
02:57:57 <boj> haskell library management in confused anger
02:58:53 <tdammers> humanoyd: install can (and usually does) modify owner, group, and attributes, typically you'd use it to copy, mark executable, and put in the right owner & group, all in one go
03:01:50 <humanoyd> tdammers: thx
03:02:54 <sm> "anger" should be a new haskell package-manager. That does everything anybody wants, but.. angrily.
03:03:31 <boj> sm: i would fund this effort
03:03:41 <tdammers> boj: angrily.
03:03:45 <sm> boj++, inventor
03:03:49 <boj> haha
03:03:50 <tdammers> "rage funding"
03:04:48 <barrucadu> `anger install` does install... but also messes up some other unrelated files as it does so.
03:05:00 <frerich> 'change-1.2.0.5: unregistering this obnoxious troublemaker (local file changes: test/Tests.hs)', 'Registering yet another bloody library for change-1.2.0.5, you don't know what you're getting yourself into'
03:06:22 <sm> "confusion" should also exist, as a competing tool that might do some things better. (Or does it ?)
03:06:54 <sm> boj I really think you have something here
03:08:11 <boj> nawwww
03:08:12 <frerich> 'Building library for change-1.2.0.5.. but only parts of it, to check whether your tests are worth their money.'
03:09:34 <sm> "installing some package.. what even is a package.. woah I'm asking myself so many questions right now.."
03:12:03 <clamchowder> perhaps the hakyll problem is an edge case
03:12:44 <boj> what is the hakyll "problem"?
03:14:33 <clamchowder> boj: `stack install hakyll` installs hakyll 4.12 (from hackage), `hakyll-init my-site` requires hakyll 4.12, `stack build` in my-site can not find hakyll 4.12 in stackage
03:15:07 <clamchowder> boj: `stack install hakyll` installs hakyll 4.12 (from hackage), `hakyll-init my-site` creates `my-site.cabal` that requires hakyll 4.12, `stack build` in my-site can not find hakyll 4.12 in stackage
03:15:17 <boj> clamchowder: huh, i wonder what other packages suffer from this problem?
03:15:54 <clamchowder> boj: yep, that's what i mean by edge case
03:15:59 <boj> i have no stake in stack so it is hard to care, but it sucks that something would break so easily
03:17:05 <sm> clamchowder: sounds like your install and build commands are using different resolvers ? why ?
03:17:23 <Myrl-saki> https://github.com/adrianparvino/reflex-bulma/commit/d26effc145070bb2009e2a2f773fb96349aae228
03:17:29 <clamchowder> sm: I don't know
03:17:38 <sm> do you run them from the same directory ?
03:17:40 <Myrl-saki> Ugh, that requires more context.
03:17:48 <clamchowder> sm: it's a clean install of stack
03:18:23 <boj> Myrl-saki: yeah, a random link unclicked :)
03:19:04 <clamchowder> i ran stack install in an arbitrary dir, and stack build in `my-site` dir
03:19:24 <sm> try them both in the site dir
03:19:40 <sm> a stack.yaml file in current dir or above could change the resolver
03:20:27 <sm> also I don't see how "stack install hakyll" would install hakyll 4.12.0.1. I would expect it to install one of the older versions in the stackage snapshots.
03:20:29 <sm> https://www.stackage.org/package/hakyll
03:20:32 <clamchowder> sm: that makes no sense to me: `my-site` is only created after running `hakyll-init`, which is after `stack install hakyll`
03:20:57 <clamchowder> sm: so I can't run `stack install hakyll` in `my-site`
03:21:50 <sm> sorry, I'll retry
03:21:56 <clamchowder> sm: I don't know either. It seems by default `stack install` searches hackage not stackage
03:22:49 <sm> if you specify a package without a version number, I believe it will install that from hackage only if it doesn't exist in any stackage snapshot
03:23:52 <clamchowder> sm: ok. I am increasingly convinced this is an edge case and not worth the time though
03:24:18 <clamchowder> sm: thanks for helping
03:24:24 <sm> I'm having trouble getting into this headspace, but what I do with hakyll scripts is make them stack scripts to specify the resolver
03:26:22 <sm> (np, good luck)
03:26:52 <clamchowder> thanks
03:42:49 <robstr> I'm using `postgresql-simple` what is the way to handle migrations (create tables / types) ? running one function upfront ? Or is there a better way ?
03:54:48 <ertes-w> robstr: you can go for a versioned approach: keep the current schema version in the database and run small SQL scripts for migrations
03:55:09 <liste> @hackage dbmigrations -- robstr
03:55:09 <lambdabot> http://hackage.haskell.org/package/dbmigrations -- robstr
03:55:26 <ertes-w> robstr: alternatively you can go for an auto-detect approach, for which there exist a couple of solutions on hackage
03:55:43 <liste> that includes a command line program for running migrations ↑
03:56:39 <robstr> thank you, dbmigrations was what i was looking for :+1
04:01:29 <ertes-w> is there an example for dbmigrations?
04:01:41 <ertes-w> i sort of see how it works, but only sort of
04:03:42 <robstr> ertes-w: ^^ i see it the first time too and struggle
04:06:15 <ertes-w> as far as i can tell this is the versioned approach, except it uses dependencies instead of versions
04:07:05 <robstr> I receive `dbmigrations/: getDirectoryContents:openDirStream: does not exist (No such file or directory)`
04:08:51 <ertes-w> i found this: https://github.com/nrskt/haskell-servant-example/blob/master/migrations/createUserTable.txt
04:09:04 <ertes-w> but it's not even a full example with code
04:11:05 <ertes-w> you can more or less piece together the code from the types – can't tell if this is better than just maintaining a small migrations table yourself
04:11:29 <robstr> ertes-w: yea maybe you are right in the first step
04:12:12 <ertes-w> having a command line tool is certainly handy
04:12:43 <ertes-w> but then you can just as well pipe your migration statements into psql =)
04:13:17 <merijn> Is it me or does every single program throw  a million exceptions when you run with -xc?
04:15:32 <huxx> Hello everyone
04:15:44 <huxx> Can anyone help me with haskell+nix integration via cabal
04:15:58 <huxx> I'm experiencing an issue since nix 2.0
04:16:06 <huxx> Whenever I try to run a cabal command inside a nix-shell, I'm getting this error: syntax error, unexpected ',', expecting ')', at /nix/store/snwfy87kzzx4iwlnpl1jfhz2mk61i03y-interactive-freeinmonads-0.1.0.0-environment.drv:1:15
04:16:51 <ertes-w> huxx: with nix 2.0 i had to turn off nix integration and go back to giving nix-shell control
04:17:28 <ertes-w> huxx: this is the wrapper script i use, if it helps: https://github.com/esoeylemez/config/blob/master/bin/nix-cabal
04:17:34 <huxx> ertes-w: So I just turn off nix: True in my cabal config and run usual cabal commands inside my nix-shell ?
04:17:48 <ertes-w> huxx: yeah, or you use the wrapper script ^
04:18:16 <huxx> ertes-w: will try this, thanks :)
04:19:06 <huxx> ertes-w: working like a charm ^^ !
04:21:18 <anqur> Hello folks, I wanna use `Just (1, 2) >>= \x y -> return (1 + 2) >>= Just', which is incorrect in types, to extract the tuple and perform their sum, and how could I achieve this by using the intermediate anonymous function? (I’m a Haskell beginner and new here :S)
04:21:22 <ZeuPiark> hello
04:22:21 <merijn> anqur: Pattern match the tuple in the lambda?
04:22:39 <merijn> > (\(x,y) -> x + y) (1,2)
04:22:43 <lambdabot>  3
04:25:21 <anqur> Ahhh thanks merijn! I got wrong about the destructuring syntax and `Just (1, 2) >>= \(x, y) -> return (x + y) >>= Just' just works! thx so much ;D
04:38:32 <dminuoso> anqur: "destructuring syntax" ?
04:39:53 <tdammers> dminuoso: probably a clojurism... there's this poor man's pattern matching in clojure called argument destructuring
04:42:01 <cocreature> js has it as well these days
04:43:43 <marvin3> anqur you can leave out the `>>= Just' part
04:44:53 <quchen> You can leave out all parts except »return (1+2)« :-þ
04:46:11 <fakenullie> You can fmap over maybe
04:47:51 <fakenullie> > uncurry (+) <$> Just (1, 2)
04:47:54 <lambdabot>  Just 3
04:48:14 <anqur> Extract, destructure, pattern matching... well I really need to distinguish them by language convention
04:49:23 <anqur> I’m writing a toy language which maps | and ; in shell to Haskell’s bind and then... while practicing my DSL skill...
04:52:21 <tdammers> there are subtle functional differences too
04:52:26 <anqur> So I’m designing the syntax that splits the string into multiple args from previous cmd and a lambda in shell... for example: `echo 4 2 >>= \x y -> return (x + y)' into `echo 4 2 | (_() { # splits the “4 2” to two variables and do the sum }; _)'
04:52:37 <quchen> Is there a commutative monoid on ℕ with 0 as identity that is *not* addition?4
04:52:41 <ertes-w> huxx: great…  you may want to customise it a bit – i generally tell cabal to use ./files as the datadir, so i can use data files during development, and i enable -fdevel and -fexamples
04:53:08 <ertes-w> the latter two aren't in the script yet
04:57:36 <sqzlh> hi, why cant I reuse the type variable a in lines 4 and 5? http://lpaste.net/363882
04:58:24 <cocreature> sqzlh: you need to enable ScopedTypeVariables and add an explicit forall
04:58:46 <sqzlh> (This is the error which has been thrown at me: "Could not deduce (Eq a1) arising from a use of ‘==’")
04:59:16 <sqzlh> cocreature: So using language extensions is the only possible solution?
04:59:24 <liste> sqzlh: by default, test and test2 both have their own `a'
04:59:27 <liste> it's not shared
04:59:33 <liste> ScopedTypeVariables changes that
04:59:52 <liste> (and the explicit forall)
05:00:14 <cocreature> sqzlh: it’s the only option to refer to the same variable. if you’re just looking for a solution to make it typecheck, you can add an Eq a constraint to test2
05:00:51 <Lears> quchen: Max?
05:01:07 <sqzlh> cocreature, ok thank you. It has to be the same type variable for my actual problem
05:01:28 <quchen> Lears: Right, arrr.
05:12:23 <sphalerite> Is there a way to turn specific warnings into errors? I want incomplete-patterns to be an error but not unused-matches
05:13:11 <cocreature> sphalerite: starting from 8.2 you can use -Werror=incomplete-patterns
05:13:31 <sphalerite> shame I'm still on 8.0.2 then :(
05:13:41 <cocreature> upgrade? :)
05:14:26 <sphalerite> ghc-mod isn't building on nixos-unstable :/
05:14:40 <cppxor2arr> i wonder when fedora will have an update for ghc
05:14:51 <cocreature> there is a PR for 8.2 support that a lot of people are using afaik
06:17:58 <infinisil> sphalerite: I have had too many problems with ghc-mod, I don't wanna deal with its problems anymore
06:18:34 <sphalerit> infinisil: I think I'm not *actually* using it but I have it in my shell.nix anyway :p
06:19:21 <infinisil> My haskell-ide-engine setup still isn't working either :/
06:22:05 <cocreature> sadly my productivity seems to have improved when I turned off intero and haskell-ide-engine a few days ago :/
06:22:42 <merijn> cocreature: Mine is still recovering from losing hdevtools and the temporary ghc-mod replacement :\
06:22:57 <merijn> cocreature: So much so that most of my work has been fixing an alternative to work for me >.>
06:24:40 <[exa]> interactive development tools, the weird relics of 1990s
06:25:14 <cocreature> merijn: I don’t doubt the usefulness of tooling, I’m just not willing to spend my time atm on getting it to the point where it helps more than it hinders me
06:26:24 <merijn> cocreature: I know that's why I keep alternating between hacking on it and being frustrated
06:26:29 <merijn> [exa]: huh?
06:26:58 <merijn> [exa]: The ability to higlight errors in my source file on save and querying types is very useful (and honestly the only functionality I really care about)
06:28:11 <merijn> ghc-mod imo tries to do way more complex stuff I don't care about
06:32:33 <exio4> that's one thing I have found with the tooling, it tries to do too much
06:32:47 <exio4> so you have a super-slow workflow, even on my desktop :/
06:35:51 <merijn> exio4: hdevtools was superfast before I broke it by using new-build
06:36:08 <exio4> I have only tried ghc-mod
06:36:20 <merijn> ghc-mod is super slow, yes
06:55:19 <robstr> I'm using the `postgresql-simple` package but struggle to generate `create table` statements with a variable table name. I want a function like mkTableStmt :: String -> Query , I tried it with `mkTableStmt name = "create .." <> name` which fails because of the String
06:56:24 <cocreature> robstr: "create .." <> fromString name
06:56:46 <cocreature> obviously make sure you don’t introduce sql injections that way
06:57:06 <robstr> cocreature: where is fromString from ?
06:58:03 <cocreature> robstr: hoogle is pretty good at answering this kind of question, in this case the first hit has the answer you’re looking for :) https://hoogle.haskell.org/?hoogle=fromString
06:59:20 <robstr> cocreature: whoo, it compile :+1 thank you
06:59:27 <bbear> how can you write DSL in Haskell ?
07:00:39 <robstr> cocreature: can you explain where `sql|` from the documentation https://hackage.haskell.org/package/postgresql-simple-0.5.3.0/docs/Database-PostgreSQL-Simple.html came from
07:01:08 <cocreature> robstr: https://hackage.haskell.org/package/postgresql-simple-0.5.0.0/candidate/docs/Database-PostgreSQL-Simple-SqlQQ.html
07:01:22 <robstr> cocreature: whup sry .. next time
07:09:48 <sphalerite> I need to use pandoc on an ubuntu machine, but don't have root access. stack and cabal are installed though. What's sthe easiest way to get pandoc? stack install pandoc gives me AesonException "Invalid flag name: \"bytestring--lt-0_10_4\""  and cabal install pandoc fails to resolve the dependency constraints
07:11:48 <phadej> I guess you have old versions of both cabal and stack
07:12:30 <phadej> e.g. stack upgrade
07:14:10 <ij> Can I have restraints in type synonyms
07:15:02 <phadej> try ;)
07:16:05 <ij> Seems like I can't.
07:16:54 <phadej> with RankNTypes you can
07:17:05 <phadej> > type NumList a = Num a => [a]
07:17:08 <lambdabot>  <hint>:1:1: error: parse error on input ‘type’
07:17:24 <phadej> lambdabot isn't good with those :/
07:17:49 <phadej> @let type NumList a = Num a => [a]
07:17:51 <lambdabot>  .L.hs:184:1: error:
07:17:51 <lambdabot>      Multiple declarations of ‘NumList’
07:17:51 <lambdabot>      Declared at: .L.hs:182:1
07:17:56 <phadej> @let type NumList' a = Num a => [a]
07:17:59 <lambdabot>  Defined.
07:18:02 <ij> Yup, I see it now. I screwed something up, because I thought partial application / "type M m = Monad m => m" would work.
07:18:57 <phadej> nope, you need to have something of kind * on the right of =>
07:19:06 <phadej> @let type M m a = Monad m => m a
07:19:09 <agentultra> well... I've won over my team and just pitched the founders/management today and we're officially going to adopt Haskell in our production systems.
07:19:09 <lambdabot>  Defined.
07:19:23 <phadej> agentultra: congrats!
07:19:30 <phadej> agentultra: are you hiring? :)
07:19:48 <ij> Aha! I can do "type WithDb a => forall m. PersistBackend m => m a"!
07:20:15 <phadej> ij: you can, but those don't compose well
07:20:28 <phadej> e.g. if you have WithSomethingElse a
07:21:11 <agentultra> phadej: soon. pm me. :)
07:21:29 <phadej> agentultra: oh, I'm not seeking for a job, but someone else here might!
07:21:52 <agentultra> indeed. I'll make a more official posting somewhere when I actually have a budget n such. :)
07:21:56 * dminuoso should start looking for Haskell junior jobs
07:22:11 <clamchowder> Hi I have a memory problem: running `stack ghci` shows `Populating index cache... Killed`. Any suggestions? I am running on a VPS with 1GB RAM
07:23:08 <phadej> clamchowder: try to run `stack  .... +RTS -M800M`
07:25:05 <clamchowder> phadej: Thanks. Output: stack: Most RTS options are disabled. Link with -rtsopts to enable them. I'll have to reinstall stack.
07:25:36 <clamchowder> what does +RTS -M800M do? use at most 800MB RAM?
07:26:03 <phadej> hmm, stack is build without -rtsopts by default, I wonder why it's so
07:26:36 <phadej> clamchowder: yes, it would limited max heap to 800M, then GC would do more work
07:26:48 <phadej> but there are chances that it would be enough memory anyway
07:27:40 <clamchowder> phadej: OK. My VPS only has about 500M left for free... so I'll have to do M500M
07:35:38 <spades> Would you guys recommend learning Haskell as a second language after JavaScript? I really want to learn more about FP, but am unsure if I should go with something like Elm first to ease the transition, or just dive straight into Haskell.
07:35:57 <exarkun> I take it you learned JavaScript already and it's too late to skip that step?
07:37:13 <foolswood> I've been working with a mixture of Haskell and Elm lately, and can attest to Elm being simpler to get going with. However it is missing some kinds of polymorphism which cause it to become boilerplatey.
07:37:14 <infinisil> @pl \f g h -> f.g.h
07:37:14 <lambdabot> (. (.)) . (.) . (.)
07:37:26 <infinisil> ^^ very nice
07:37:40 <spades> Haha :'), yes I did. I'm going through the EdX Software Development courses, which will introduce me to Java and TypeScript too. Want to do something which is more focused on FP besides that, though.
07:39:12 <ventonegro> spades: Haskell is not really difficult, you can get a lot going in a reasonable timeframe. Just don't assume that the type hackery you usually see in blog posts and here is the baseline
07:39:44 <ventonegro> spades: You can get fancier as you go
07:39:47 <cppxor2arr> "Just don't assume that the type hackery you usually see in blog posts and here is the baseline" | phew!
07:39:48 <clamchowder> Is there any way to speed up hakyll site rebuild after modifying site.hs? In the tutorial it says I need to `stack build` followed by `stack exec site rebuild`. But `stack build` takes > 10 minutes even with `--fast --file-watch` flags
07:41:08 <spades> ventonegro: Haha, good to know! I picked up the Haskell from First Principles book. I'll just focus on going through that step by step.
07:41:54 <phadej> clamchowder: 10 minutes sounds long :O, but editing site.hs should be quite rare operation when it's set up
07:41:55 <clamchowder> During this process stack would `configure`, `build` and `copy/register` 5 packages, including pandoc, even though I make small changes to site.hs
07:42:03 <spades> foolswood: Did you start out with Haskell or Elm, though?
07:42:26 <ventonegro> spades: It's a good resource, if you don't skip the exercices (and type them instead of copying them) you will be writing Haskell in no time
07:42:29 <foolswood> spades: Haskell before Elm.
07:42:29 <phadej> clamchowder: weird, why it's rebuilding `pandoc`, that sounds like a bug / missconfiguration
07:43:21 <phadej> clamchowder: or are you experiencing https://github.com/commercialhaskell/stack/issues/3899
07:43:34 <spades> Good stuff. Thanks for the advice.
07:43:41 <clamchowder> phadej: I guess. For now I am just playing with site.hs to learn hakyll
07:44:39 <clamchowder> phadej: thanks I'm reading that link
07:45:53 <phadej> it's a bug in stack :/
07:45:59 <phadej> there's a workaround though
07:47:55 <clamchowder> phadej: is it in that post?
07:49:26 <clamchowder> phadej: this one? https://github.com/commercialhaskell/stack/issues/3899#issuecomment-374909289
07:57:36 <hyperisco> has anyone stumbled across a concept you might call Monad grammars?
07:57:49 <mnoonan_> explain?
07:58:03 <hyperisco> pipes and conduit are examples
07:58:35 <hyperisco> if you take the general notion, you can represent any grammar of actions
07:59:04 <systemfault> Something like the Free monad?
07:59:08 <earthy> hyperisco: applicative and monadic parser combinator libraries are known...
07:59:14 <hyperisco> no, not parsing
07:59:29 <earthy> hyperisco: and those work precisely because they allow you to describe a grammar...
07:59:38 <hyperisco> newtype X m = X (m Y); newtype Y m = Y (m Z); newtype Z m = Z (m ());  would correspond to a grammar like  S -> X Y Z
08:00:17 <hyperisco> or another visualisation is a graph, so you can label edges and vertices
08:00:59 <Psybur_> Is there a way to take an arbitrary functor that has no concept of a "next" step and lift it into some context that does?
08:01:11 <hyperisco> using this approach you can splice actions, such as logging, in a way similar to pipes/conduit
08:01:20 <Psybur_> Well I should say is there an existing construct for that
08:01:42 <hyperisco> Psybur_, what is a "next step"?
08:02:07 <hyperisco> there is Traversable which is a Foldable Functor
08:02:21 <hyperisco> and gives you folds, which might be like a "next step"
08:02:37 <ventonegro> Is there printf for Data.Text?
08:04:19 <hyperisco> I forgot a few type args in that prior example, whoops
08:04:23 <Psybur_> hyperisco, Im wondering if I could do something like this but with Free: foldr (.) id [(+1),(*2)] 2
08:04:47 <Psybur_> Basically instead of using [], use Free. And the interpreter would compose them together.
08:05:13 <Psybur_> Its probably useless since I already have the "better" way to do it
08:05:21 <Psybur_> Just playing around with Free
08:05:36 <hyperisco> newtype X m = X (m (Either (X m) (Y m))); newtype Y m = Y (m ());  corresponds to  S -> X S | Y
08:06:22 <hyperisco> this is essentially a design pattern (I don't see any obvious abstraction)
08:08:23 <phadej> hyperisco: aren't you reinventing `Free`?
08:09:02 <hyperisco> I don't know. I don't see the significance of Free here
08:09:11 <phadej> hyperisco: http://hackage.haskell.org/package/free-5.0.1/docs/Control-Monad-Trans-Free.html
08:10:23 <hyperisco> phadej, well if you can demonstrate either example back to me using FreeF that would help me see what you mean
08:11:26 <ij> Getting the object id in groundhog via project looks so magical.
08:12:16 <hexagoxel> is there any clever method to diagnosing why i don't get proper (more than one-element) callstacks when I already add HasCallStack constraints at every type signature i find?
08:12:50 <hyperisco> what I am showing here is a general way to create splice points in an effectful computation
08:13:30 <ij> Will groundhog destroy data if I run an executable that expected an older version of the schema?
08:13:36 <hyperisco> so long as you can devise some grammar (or labeled graph) to represent that computation
08:16:51 <hexagoxel> nevermind, i traced down which code raised the exception and it lacked the constraint -.-
08:21:33 <phadej> hyperisco: https://gist.github.com/phadej/bcd3bf7e07a115488f1b8e7b9cc54971
08:22:01 <phadej> the SF functor is a functor for your S
08:22:16 <phadej> and FreeT is the `Fix`
08:23:00 <hyperisco> I have not used Free for anything. What advantage is there defining it this way?
08:23:12 <hyperisco> I would not be inclined to use Fix/Mu for example to define a recursive type
08:23:51 <hyperisco> I'd have to be motivated by there being an existing type that fits the bill that I need merely fix with Fix/Mu
08:24:04 <phadej> depends, e.g. streaming docs say "
08:24:05 <phadej> The Stream data type is equivalent to Free"
08:24:08 <hyperisco> but if I am defining a new type anyhow, why use the extra wrapper?
08:24:08 <phadej> http://hackage.haskell.org/package/streaming-0.2.1.0/docs/Streaming-Internal.html
08:24:37 <phadej> hyperisco: you undestood me wrong, it's not that you _have_ to use Free, it's the insight that you have (specialised) variant of it
08:25:03 <hyperisco> well no, I don't think s
08:25:33 <hyperisco> otherwise you'd say every type which could be reconstructed with Mu was merely a specialisation of Mu
08:25:36 <hyperisco> but that isn't the case
08:25:47 <hyperisco> nor would you say that every recursive function is a specialisation of fix
08:26:35 <hyperisco> and the difference is that I still need some other definition to have what I want. I am not merely specialising a type
08:26:51 <phadej> and you asked "has anyone stumbled across a concept you might call Monad grammars?", my answer is "it looks like FreeT with f specifying the grammar" (thus might not have a name)
08:27:17 <hyperisco> or applying trivialities to a function
08:27:30 <phadej> if you want to talk about them generally, `f` argument gives you that vocabulary; if you don't, then you have a monad transformer
08:29:06 <hexagoxel> (and now i notice that if you heavily use data structures with functions as members, the callstacks are pretty much useless anyways. hum)
08:29:08 <hyperisco> a monad transformer? I don't see that
08:29:39 <hyperisco> I see what you're saying but I don't think that is a usual way to define a grammar either
08:30:05 <hyperisco> if a baseline is how you'd define an AST for use with parser combinators, for example
08:31:55 <phadej> hyperisco: newtype X m a = ...
08:32:06 <hyperisco> but that wasn't the type
08:32:14 <hyperisco> newtype X m = ..
08:32:23 <hexagoxel> hyperisco: as for motivation, there are several functions working with Free f a, which you'd have to write manually if you use a custom datatype.
08:32:27 <phadej> hmm
08:33:35 <hyperisco> yeah I'll take a look
08:33:42 <phadej> hyperisco: but if you don't have `a` there, then your X Y is not monad things, but Fix stuff. Same applies though
08:33:54 <hyperisco> it might be a good piece to implement the concept with
08:34:24 <hyperisco> it depends on what the free stuff is worth :P
08:35:32 <Myrl-saki> Is there an inline variant of Map.singleton?
08:36:01 <hyperisco> you wouldn't be enthralled about using  Fix (Compose Maybe ((,)a))  instead of  [a]  is all I'm saying
08:36:55 <phadej> hyperisco: as I said, *if* you want to talk about this constructs *generically*, then it pays off
08:37:16 <phadej> if you talk about specific instances only, then yes, it's unnecessary overhead
08:38:00 <hyperisco> it is the mutual recursion which concerns me
08:38:10 <hyperisco> you usually want that in grammars for sake of clarity
08:38:22 <phadej> hyperisco: you can have pair of functors too
08:38:37 <hyperisco> okay but now you have to Compose
08:40:09 <phadej> I'd say now it's good time to go offline and write some code, or notes, to clarify ideas (and the problem too)
08:40:54 <hyperisco> I have several hundred lines written and the concept well understood… I am just wondering if anyone else recognises it
08:41:14 <hyperisco> I get what you're saying with Free
08:41:22 <phadej> hyperisco: why didn't you start with pasting the code!
08:41:29 <phadej> (or link to it)
08:41:34 <hyperisco> because it isn't an abstraction
08:41:50 <phadej> still, I think I miss something, so I'll go to do something else ->
08:41:51 <hyperisco> any more than I could paste to you an AST for all languages
08:50:56 <ij> Can you autoderive lenses without underscore prefixes?
08:51:36 <cocreature> if someone has some free time, it looks like lpaste (which is used a lot here) needs new maintainer: https://www.reddit.com/r/haskell/comments/862k28/looking_for_new_maintainer_of_lpastenet/
08:58:42 <ertes-w> ij: use makeXWith instead of makeX, and pick one of the predefined lens rules
08:59:53 <ertes-w> ij: makeLensesWith camelCaseFields ''MyType
09:00:28 <ertes-w> ij: https://hackage.haskell.org/package/lens-4.16/docs/Control-Lens-TH.html#g:11
09:03:34 <ij> oooh cool
09:08:56 <nut> I've seen code using generic types such as:
09:08:56 <nut> loadAndInsert :: CanApp c e m => FilePath -> m [Int]
09:09:12 <nut> here m has many constraints
09:09:31 <nut> My question is when do people use such style instead of a concrete m?
09:10:08 <tdammers> nut: there are different schools of thought on this matter
09:10:37 <nut> tdammers:any blog post that explains this?
09:10:46 <tdammers> nut: not that I know of
09:10:55 <tdammers> nut: speaking from personal experience here
09:10:57 <nut> It seems like the 'generic' way is easier to compose
09:11:06 <tdammers> yes
09:11:30 <tdammers> or rather, the generic way is maximally reusable, in the sense that you can make *any* type work with your API, as long as you can write the required instances
09:11:56 <tdammers> on the extreme end of that, you have stuff like the HasXXX classes, things like that
09:12:07 <tdammers> or the MonadSomething classes found in mtl / transformers
09:12:22 <nut> It's pretty cool and convenient to write code like this. Perhaps the discussion is on the performance impact?
09:12:33 <tdammers> performance is one factor
09:12:42 <tdammers> but there is more
09:12:54 <tdammers> one problem is that highly generic code like this comes with a mental overhead
09:14:10 <tdammers> basically, String -> Int -> String is somewhat easier to intuit than, say, (Monoid s, Integral i) => s -> i -> s
09:14:19 <nut> I'm writing a small game that manages multiple states. It seems like using the above approach with lenses is the most natural way to manage multi states machines
09:15:05 <tdammers> and the other problem is that when you make things polymorphic on both the consumer and the producer side of things (in "positive" and "negative" positions), then you often end up in situations where you have to add type annotation to disambiguate your code
09:15:39 <nut> or the type checker will give errors?
09:15:55 <tdammers> specifically, if you have two functions, f :: SomeConstraint b => a -> b, and g :: SomeConstraint b => b -> c, then composing the two leaves b ambiguous
09:16:16 <tdammers> so yes, then the type checker will tell you that in the form of an error message
09:16:29 <tdammers> > show . read $ "1" -- is a popular example
09:16:33 <lambdabot>  "*Exception: Prelude.read: no parse
09:16:57 <marvin3> :)
09:17:13 <tdammers> except that in this case the extended defaulting rules setting gives us a completely different error
09:17:18 <nut> Why in your specific example b is ambiugous?
09:17:43 <tdammers> nut: because the constraint may be met by an arbitrary number of types
09:17:49 <nut> as long as b satisfies the constraints, it's composable ,no?
09:18:12 <nut> tdammers:isn't that what you want the code to behave?
09:18:17 <tdammers> nut: yes, but the constraint is the only thing that we have to figure out the type, and there can be arbitrarily many types that meet the constraint
09:18:50 <nut> tdammers:there can be, but if we don't instance them, there are none
09:19:09 <tdammers> there can be, and we don't control them
09:19:28 <tdammers> we cannot prohibit users of our code from making more instances
09:19:38 <tdammers> this is called the "open typeclass universe" design decision
09:19:40 <marvin3> :t show . read
09:19:42 <lambdabot> String -> String
09:19:56 <tdammers> marvin3: lambdabot uses extended defaulting
09:19:57 <marvin3> any type that has instances of Show and Read would qualify
09:20:44 <tdammers> exactly, and neither the definition sites of show, read, or show . read can constrain that in any way
09:20:54 <marvin3> tdammers, I realize that, wasn't talking about lambdabot. what did it pick btw? Integer?
09:20:57 <tdammers> > read "()"
09:21:01 <lambdabot>  ()
09:21:02 <marvin3> oh right
09:21:17 <tdammers> if it had picked Integer, my initial code would have run successfully
09:21:30 <marvin3> indeed
09:21:32 <tdammers> > read "1"
09:21:35 <lambdabot>  *Exception: Prelude.read: no parse
09:21:40 <tdammers> but it doesn't
09:23:44 <nut> tdammers: thank you. I will keep using this style for a while to get a better feel of it
09:44:14 <ertes-w> nut: ideally you define with maximum abstraction and use with maximum instantiation…  lenses are a great example of this
09:44:43 <ertes-w> nut: that makes your code extremely reusable while at the same time inferring as much as possible
09:48:57 <akfp> anyone knows how to get from a ProcessHandle to any process-ish thing from the unix package, like PID?
10:07:10 <guessWHo> when i fork a thread with forkIO and print something everything jumbles up, how can avoid that ?? i remember reading somewhere that  MVar can be used to avoid that is that true ?? if not is there another solution >?
10:09:26 <MarcelineVQ> that (concurrency) is quite a neat topic, with a well written haskell-specific book on the subject that you should read when you have the time   https://pdfs.semanticscholar.org/a87c/89e722e3636a632d41adbdec0e2f71586176.pdf
10:10:54 <guessWHo> MarcelineVQ : sure thanks for the suggestion , can you help me fore now ?
10:11:37 <MarcelineVQ> the book would eventually answer your question but help is also only a google search away https://www.google.ca/search?q=concurrent+printing+in+haskell  ->  https://github.com/crabmusket/haskell-simple-concurrency/blob/master/src/tutorial.md
10:23:21 <guessWHo> can someone please explain this behaviour ??
10:25:28 <chocopuff> when should I worry about understanding what a monad is?
10:26:05 <qu1j0t3> never?
10:26:06 <Clint> when you're writing an instance of Monad
10:26:08 <qu1j0t3> just use them
10:26:09 <EvanR> guessWHo: threads are running concurrently, taking turns accessing handles. so they are both writing to the output handle at the same time, hence jumble
10:26:26 <chocopuff> I've been just working through Haskell, practicing a bit of code, but I have stopped reading the textbook at the Monad section
10:26:37 <chocopuff> I guess it is a very abstract / mental hurdle?
10:26:42 <EvanR> not really
10:26:46 <chocopuff> hard to comprehend, what should I do first
10:26:58 <guessWHo> EvanR : sorry not that this one http://lpaste.net/363906
10:26:59 <EvanR> read that section of the book
10:27:02 <EvanR> instead of stopping
10:27:07 <qu1j0t3> ^
10:27:22 <chocopuff> EvanR: I mean I've tried, it's just I've gotten stuck
10:27:32 <chocopuff> so I was thinking maybe more background exp. elsewhere might help
10:27:40 <brynedwards> chocopuff: what book are you reading through?
10:27:42 <EvanR> guessWHo: what is the actual question, or problem
10:27:50 <EvanR> "works" "doesnt work" isnt informative
10:27:50 <chocopuff> brynedwards: Learn You a Haskell
10:28:18 <Taneb> chocopuff: what worked for me way back when when I was at this point was reading the Typeclassopedia
10:28:22 <Taneb> @where typeclassopedia
10:28:22 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
10:28:25 <guessWHo> EvanR : in case where it works forever is working as expected it's printing that string infinitely but not in the second case
10:28:38 <chocopuff> rn, I took a detour and started reading write yourself a scheme in 48 hrs brynedwards
10:28:40 <Taneb> chocopuff: that said, monads are really over-hyped
10:28:42 <chocopuff> but it goes headfirst even more
10:28:54 <lts> How do I make a statemonad an instance of Show (http://lpaste.net/363907#line24) ?
10:29:20 <EvanR> guessWHo: in the first case, () is never actually inserted into the MVar
10:29:36 <EvanR> the program is waiting forever to get the () and end
10:29:41 <Taneb> chocopuff: "monad" is just a term for things that can be combined with themselves in a certain way
10:29:53 <EvanR> in the second case, when it gets the first (), program ends
10:30:32 <hit023> hey! any channel for Haskell GSOC ?
10:30:41 <EvanR> or, since nothing takes the second (), the printer gets stuck waiting forever for something to take it
10:31:51 <hololeap> there's a random, useful function that's in Data.List.NonEmpty for some reason: unzip ... does anyone else find that to be an odd place for such a function?
10:32:09 <guessWHo> EvanR : ohk got it thanks :0
10:32:11 <guessWHo> :)
10:33:40 <chocopuff> should I actively try to understand what a monad is for now?
10:33:44 <chocopuff> I shouldnt skip that section right
10:33:57 <shapr> it's useful
10:34:17 <dminuoso> chocopuff: You dont need to worry about it.
10:35:05 <dminuoso> chocopuff: The intuition about monads comes on its own when you practice using them and writing instances for them. After a couple you should see the pattern emerge,
10:36:34 <EvanR> re evaluate the problem... which i see as 1. because its "well known" that monads are hard, they are hard. 2. they are something you have to fully understand at a deep level to accomplish anything
10:36:50 <EvanR> thus, conundrum
10:37:02 <EvanR> but all that is wrong
10:37:07 <dminuoso> chocopuff: In the end it's just a particular programming pattern that has some basic laws. Some pieces of code have the same "shape" (even though they do very different things), following the same laws (even though they mean different things).
10:38:59 <EvanR> better, study Functor instead because, 1. no one knows its hard, 2. understanding it at a level to accomplish anything is easy 3. its essentially in the same bucket of "weird stuff" monad is
10:38:59 <hololeap> if i wanted to suggest to the base maintainers that they should move that function to another module, where would i do that?
10:39:16 <EvanR> chocopuff: ^
10:39:37 <elpfen> I get the sense that understanding/using/writing monads is much easier than explaining them
10:39:50 <dminuoso> elpfen: Indeed.
10:40:01 <dminuoso> elpfen: We usually try to seek meaning by looking at concrete examples.
10:40:11 <dminuoso> Sadly a concrete example defies the notion of generalization.
10:40:22 <chocopuff> thanks guys, dminuoso, elpfen, that part is reassuring to here then
10:40:25 <chocopuff> I won't worry for now then
10:40:25 <dminuoso> And since Monad tries to capture a generalization of a pattern..
10:40:27 <EvanR> the entire industry of monads being hard and "what they are" can be transferred to Functor, where people dont have visceral primordial anxiety about it
10:41:15 <hololeap> the biggest piece of "machinary" behind a monad is just taking a double application of a functor and bringing it back down to a single application, e.g. f (f a) -> f a ... the other piece, return, isn't very hard to understand
10:41:19 <guessWHo> how do we deal with situation like these : http://lpaste.net/6593761795729522688 is it a reoccurring pattern ?? even i don't think so but that's why i'm asking :p
10:41:43 <EvanR> then when you "get" functors, and can say "whats the big deal" and see Monad just has a really bad reputation
10:42:17 <EvanR> guessWHo: step 1, understand the question
10:42:43 <dminuoso> hololeap: `join` is actually much more nasty in practice. (>>=) is simpler to think of in terms of actual programming problems.
10:42:44 <Putonlalla> Does this generalize? Vote now on your phones: http://lpaste.net/363911
10:42:51 <dminuoso> hololeap: I mean how often do you think of `join` when sequencing IO ?
10:43:06 <EvanR> i think join is simpler is some cases
10:43:15 <dminuoso> For [] maybe yeah
10:43:26 <EvanR> or other "containers" with the [] diagonal falvor
10:43:28 <EvanR> flavor
10:43:31 <guessWHo> EvanR : i think i understand it where did i go wrong ?
10:43:48 <hololeap> it can be helpful to see the different angles of the concept
10:43:56 <mlehmk> return is a lift of a -> f a, isn't it?
10:44:01 <mlehmk> actually just pure
10:44:06 <dminuoso> mlehmk: not just.
10:44:08 <hololeap> return == pure
10:44:10 <EvanR> guessWHo: i actually misread your question... i should take my own advice. i dont get your question
10:44:11 <dminuoso> mlehmk: + coherence laws.
10:44:17 <dminuoso> those coherence laws are rather important.
10:44:29 <dminuoso> i.e. its not just the ability to do `a -> f a`
10:44:32 <mlehmk> so pure in a context of Maybe gives a Just value
10:44:59 <dminuoso> `a -> f a` must be an identity for >=>
10:45:15 <EvanR> pure x injects x into the monad type in a way that "has no effect"
10:45:29 <hololeap> > pure True :: Maybe Bool
10:45:33 <lambdabot>  Just True
10:45:50 <mlehmk> > pure True :: Either Bool
10:45:53 <lambdabot>  error:
10:45:53 <lambdabot>      • Expecting one more argument to ‘Either Bool’
10:45:53 <lambdabot>        Expected a type, but ‘Either Bool’ has kind ‘* -> *’
10:45:58 <dminuoso> i.e. `(a >=> return) = a` and `(return >=> a) = a`
10:46:01 <mlehmk> ohh
10:46:09 <hololeap> Either takes two types as arguments
10:46:11 <EvanR> uhg kleisli
10:46:21 <dminuoso> EvanR: the law is metric tons cleaner than with bind.
10:46:40 <EvanR> monad laws in terms of monoid laws are even clearer :)
10:46:48 <dminuoso> EvanR: can you elaborate?
10:46:53 * dminuoso is interested
10:47:01 <mlehmk> > pure True :: Either [Char] Bool
10:47:03 <lambdabot>  Right True
10:47:05 <EvanR> ... a monad is a monoid ...
10:47:05 <mlehmk> so, like that
10:47:15 <EvanR> ... in the you know where ...
10:48:10 * Clint winks.
10:48:13 <EvanR> mlehmk: right... in your examples, Nothing will cause an effect, Left will cause an effect, pure x dont
10:48:42 <EvanR> in a list, lists with length /= 1, causes an effect
10:48:46 <dminuoso> EvanR: Im gonna have to draw some diagrams again. It's been a while since looked at it from CT.
10:48:48 <mlehmk> so like fmap id, not causing an effect. But when causing an effect, it's like fmap (const a)
10:49:08 <EvanR> functor isnt about effects
10:49:23 <mlehmk> no, just looking for an analogy
10:49:32 <EvanR> are you looking at the function monad?
10:49:34 <dminuoso> mlehmk: well the fmap is a bit confusing.
10:49:42 <dminuoso> mlehmk: so the way that id is an identity for (.)
10:49:49 <dminuoso> mlehmk: the same way return is an identity for (>=>)
10:49:55 <dminuoso> mlehmk: both are function composition.
10:50:13 <dminuoso> mlehmk: (.) composes "normal" functions. (>=>) composes (a -> m b) functions
10:50:43 <mlehmk> ahh, is that kleisli?
10:50:47 <dminuoso> mlehmk: `id :: a -> a`, while `return :: a -> m b` (context ignored for brevity)
10:50:49 <dminuoso> mlehmk: yes.
10:50:53 <dminuoso> err
10:50:57 <mlehmk> uhm?
10:50:57 <dminuoso> `return :: a -> m a`
10:51:08 <mlehmk> ahh, okay. Finally something I can understand
10:51:15 <dminuoso> mlehmk: `return` is the `id` in the kleisli category.
10:51:20 <hololeap> mlehmk: if you have `Just "blah"`, no matter what you do with fmap, you cannot change the Just to a Nothing... the change from `Just "blah"` to `Nothing` is the essence of Maybe's effect
10:52:45 <EvanR> ok, so were talking about using fmap while building a monadic computation
10:52:58 <dminuoso> mlehmk: so from the perspective that `return` is the identity for kleisli composition, it should be obvious that the `Monad` has to be effect free, _because_ its a monad.
10:52:59 <EvanR> in which case, fmap causes no extra effects
10:53:08 <mlehmk> no, I just needed that to create an analogy, even if unfit
10:53:34 <EvanR> should we have an unfit analogy contest? :)
10:53:51 <hololeap> a monad is like a burrito wrapped in an astronaut
10:54:16 <EvanR> a comonad is like a nightclub
10:54:26 <dminuoso> mlehmk: and of course just like `id` is both a left and right identity, that is `f . id = f` and `id . f = f`, return is also a left and right identity: `return >=> f = f` and `f >=> return = f`
10:54:32 <elpfen> hololeap: it finally makes sense
10:54:40 <elpfen> i see everything now
10:55:05 <dminuoso> EvanR: where's the nightclub joke from?
10:55:07 <dminuoso> Ive seen it a few times
10:55:22 <EvanR> its a standard "comonad tutorial" at this point
10:56:38 <[exa]> comonads are nightclubs?
10:56:39 <hololeap> elpfen: lol
10:57:05 <EvanR> in so far as monads are burritos, yes
10:57:07 <hpc> [exa]: some nightclubs are also burritos
10:57:08 <robstr> Is it possible to use `?` frim postgresql-simple package to create a table query ? Currenlty it quotes the table name :-/
10:57:32 <hololeap> EvanR: is it some nonsense like "everybody at the nightclub has a unique perspective"
10:57:34 <dyl> If monads are burritos, what are monad transformer stacks?
10:57:37 <dyl> Burritopedes?
10:57:48 <hololeap> n-dimensional burritos
10:57:54 <[exa]> anyways I wanted to ask which one is the "standard" comonad tutorial, EvanR
10:58:11 <EvanR> sorry if i attempt to explain it, i will probably disrespect the spirit of the post
10:58:16 <dyl> You know, if we had a 4D burrito, it would in theory be much easier to uniformly distribute the fillings.
10:58:31 <dyl> So you don't have that awful thing where all of the rice or beans are on one side, and it becomes unevenly wet.
10:58:33 <hololeap> klein burritos
10:58:47 <[exa]> you need to lift standard 2D tortilla to 3D to wrap 4D contents of the burrito, ofc.
10:58:53 <EvanR> http://gelisam.blogspot.com/2007/04/of-comonads-and-nightclubs.html
10:59:00 <[exa]> EvanR: thanks
10:59:13 <dyl> I don't remember when, but at a certain point all of the analogies and metaphors stopped being helpful.
10:59:26 <dyl> Someone once asked me what monads were and I just wrote out the definition of the typeclass and they got upset.
10:59:27 <EvanR> you mean, instantly?
10:59:41 <dyl> I mean, the box metaphor is helpful for functors *initially*
10:59:45 <dyl> It falls apart for applicatives.
10:59:53 <hpc> dyl: obviously they wanted extensional equality ;)
11:00:15 <EvanR> i find the challenge to explain "what _ is" interesting in general, monads have turned that into a reflection of humanities expectations of communication
11:00:30 <EvanR> being ridiculous
11:00:32 <rotaerk> heh, why does this exist https://hackage.haskell.org/package/Vulkan
11:00:44 <dyl> I enjoy that at this point people seem to be competing for more absurd but weirdly useful analogies.
11:00:45 <rotaerk> uploaded in 2016, and basically empty
11:00:51 <dyl> Monads are just one of those things that *are what they are*.
11:01:06 <EvanR> does new hackage have no docs?
11:01:12 <EvanR> oh wait that was old hackage
11:01:28 <dyl> Man, I feel old.
11:01:32 <dyl> I only have the 5th edition superbible.
11:01:38 <dyl> They're at 7 already?
11:01:47 <guessWHo> dyl : i have just finished chapters on functors, applicatives, monoids and Monads and that box analogy keep popping although they'll mention in a side note that's not appropriate and think of it as context but never expanding on context
11:02:06 <dyl> "context" is kind of the best word though.
11:02:11 <dyl> It's sufficiently general.
11:02:16 <hololeap> a monad is just a R . L composition of adjoint functors, what's the problem?
11:02:21 <dminuoso>  dyl It just requires an actual explanation
11:02:28 <EvanR> context is sufficiently vague to not be wrong
11:02:40 <dyl> ^ exactly
11:02:56 <guessWHo> dyl : it helps coz its quite intuitive
11:03:20 <dyl> Monads can be thought of decently generally as a "metaphor of computation".
11:03:35 <dyl> I'm surprised "a monad is just _____, what's the problem?" hasn't become a popular mainstream meme yet.
11:03:57 <EvanR> without any preparation, "what monads is" can be answered. because they dont know what a typeclass is, or what <whatever that requires> is
11:04:10 <dyl> "it's a thing that does these things"
11:04:27 <dyl> can or can't?
11:04:32 <EvanR> people *know* that its a thing that you supposed to ask, what it is, then be confused, regardless
11:04:40 <EvanR> cant*
11:04:42 <dyl> I think in the end you don't really need to know "what it is" though.
11:04:48 <dyl> Once you use them enough, you'll have an intuition for it.
11:04:58 <hololeap> it's hopeless unless they have an understanding of functors and higher-level functions, which a lot of programmers have never dealt with
11:05:09 <EvanR> if you want a categorical answer, you tell them its a typeclass
11:05:29 <EvanR> they cant be mad, but they will feel justified in concluding in confusion
11:05:37 <dyl> I feel like for these sorts of things, "how it works in practice" is more fruitful than "what it is" (for some definition of 'is')
11:05:46 <EvanR> if they were series, theyd then ask what a typeclass is, but they probably dont care
11:05:55 <EvanR> monad is the cool thing to ask, then be confused about
11:06:06 <dyl> No man, that's confluence.
11:06:11 <dyl> No one really understands what confluence is.
11:06:17 <hololeap> honestly, wondering what a monad was, was a big reason why i tried haskell
11:06:20 <EvanR> like, rivers?
11:06:38 <hololeap> so its a good advertising scheme :p
11:06:49 <dyl> <scheme is not a lisp joke>
11:06:57 <dyl> (but it is)
11:07:07 <EvanR> peoples reactions to your answering what a monad is... is a good facebook personality quiz
11:07:54 <dyl> "burrito" ⇒ hungry, "monoid in the category of endofunctors" ⇒ pretentious, "spacesuit" ⇒ ???
11:08:12 <EvanR> do they become confused and change teh subject, ask penetrating further questions, immediately enroll in a PhD program
11:08:56 <guessWHo> here i think this is more clear now http://lpaste.net/363913
11:09:26 <EvanR> guessWHo: return "Damnnn" doesnt do anything, we were just talking about that
11:09:55 <dyl> "return" is definitely one of the worst naming choices in the stdlib.
11:10:27 <EvanR> guessWHo: what are you expecting the program to do
11:10:32 <delYsid> AMP!
11:12:06 <[exa]> dyl: pureM? :]
11:12:52 <[exa]> btw I might have already asked, but is there already some post about 'comonads are caches' or am I going to write one?
11:13:30 <hololeap> guessWHo: when you say it "doesn't work", do you mean it prints ()?
11:15:52 <rotaerk> what's it mean for @ to precede a string literal, like @"blah"
11:16:09 <guessWHo> hololeap : it doesn't print anything
11:16:23 <EvanR> guessWHo: does runSomeFunction (action) ever end?
11:16:37 <jle`> rotaerk: if it's a pattern, it's an as pattern
11:16:42 <EvanR> are you compiling with -threaded
11:16:48 <jle`> rotaerk: if it's a part of an expression, it's TypeApplications
11:16:57 <jle`> rotaerk: it lets you fill in type variables explicitly
11:16:58 <guessWHo> EvanR : no what does that do ?
11:17:06 <jle`>  :t fmap @Maybe
11:17:09 <EvanR> makes concurrency work better
11:17:11 <rotaerk> ah thanks
11:17:12 <jle`>     (a -> b) -> Maybe a -> Maybe b
11:17:22 <jle`> rotaerk: in this case it's filling in a type variable with the type "blah"
11:17:33 <EvanR> but if runSomeFunction never ends, () is never written to the MVar
11:17:34 <jle`> (given using a type symbol literal)
11:17:39 <EvanR> either way
11:18:17 <jle`> > case "blah" of @"blah" -> True
11:18:20 <lambdabot>  <hint>:1:16: error: parse error on input ‘@’
11:18:30 <jle`> i guess you need the underscore at least
11:18:34 <jle`> > case "blah" of _@"blah" -> True
11:18:37 <lambdabot>  <hint>:1:17: error: parse error on input ‘@’
11:19:23 <jle`> i guess you can't have as patterns with wildcards?
11:19:29 <jle`> makes sense actually, but it feels kinda arbitrary
11:19:43 <guessWHo> EvanR : if i have forkIO $ forever $ someFunc >> putMVar demo()  will it ever jump to putMVar ?
11:20:07 <cocreature> guessWHo: depends on whether someFunc terminates
11:20:08 <EvanR> maybe not, depends on what someFunc (not a function, an action) does
11:21:34 <guessWHo> but it's just a regular function but shouldn't with forever it should just run forever ??
11:22:01 <hololeap> not if someFunc never terminates. in that case it would get stuck on the first iteration
11:22:12 <EvanR> forever (someAction >> putMVar x y) = someAction >> putMVar x y >> someAction >> putMVar x y >> ...
11:22:37 <cocreature> guessWHo: you’re running forever (someFunc >> putMVar demo ()) not (forever someFunc) >> putMVar demo ()
11:22:38 <EvanR> it cant magically make the first someAction finish if it didnt before
11:23:04 <EvanR> and (forever someFunc) even more obviously so
11:23:47 <EvanR> forever x will never finish, regardless of what x is
11:24:10 <hololeap> this would work: forkIO $ forever $ putMVar demo () >> someFunc
11:24:30 <EvanR> depending on the answer to my question, what youre expecting the program to do
11:24:34 <hololeap> at least the mvar would get set even if someFunc never terminates
11:24:42 <EvanR> its not going to print "Daamnnnn"
11:25:09 <guessWHo> Ahh got it
11:25:12 <EvanR> we still dont even know what "doesnt work" means
11:25:18 <AWizzArd> data Foo a = ...   What is the syntax to add a Show constraint on `a`?
11:25:46 <guessWHo> EvanR : give me a minute i'll come up with the complete question and neat example
11:25:56 <hololeap> AWizzArd: don't set type constraints when defining data types, do it in a function that uses the data type
11:26:34 <AWizzArd> hololeap: ok
11:26:38 <EvanR> unless youre trying to box up a dictionary in a GADT
11:28:01 <nut>  
11:28:01 <nut> -- Renamed tuple lenses for enhanced clarity with points/vectors
11:28:01 <nut> _x = _1
11:28:18 <nut> what does it mean? it's in a Lens example with a gloss game
11:28:36 <EvanR> its renaming _1 to _x
11:28:37 <nut> _1 is a function?
11:28:52 <EvanR> :t _1 would answer this
11:28:54 <lambdabot> error:
11:28:54 <lambdabot>     Variable not in scope: would :: a0 -> t0 -> b0
11:28:54 <lambdabot> error: Variable not in scope: answer
11:29:01 <EvanR> :t _1
11:29:03 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
11:29:08 <EvanR> yes its a function
11:29:21 <nut> thanks
11:29:32 <nut> how can i find where it is defined?
11:29:42 <EvanR> @index _1
11:29:42 <lambdabot> bzzt
11:29:49 <hololeap> hoogle.haskell.org
11:30:08 <nut> what does @index _1 mean?
11:30:18 <sl2c> nut: anything starting with @ here is a lambdabot command
11:30:21 <EvanR> lambdbot sometimes knows where its defined
11:30:26 <nut> ok
11:30:40 <sl2c> anyways _1 will likely be defined in whatever lens library the code you're reading is using
11:31:24 <EvanR> dang hoogle.haskell.org is slick
11:31:35 <EvanR> "hoogle" on google, isnt
11:32:03 <sl2c> stackage.org has a hoogle search that is sometimes more complete i think?
11:32:29 <hololeap> there's also www.haskell.org/hoogle/ ... i never know which one is the most up-to-date :(
11:33:09 <amalloy> EvanR: hoogle.haskell.org claims "Warning: Alpha version, type search doesn't work!" which is like the opposite of slick to me, as it's the one feature i care about
11:33:09 <EvanR> > ('a',9) ^. _1
11:33:12 <lambdabot>  'a'
11:33:33 <EvanR> > [3,2,1] ^. _1
11:33:36 <lambdabot>  error:
11:33:36 <lambdabot>      • Could not deduce (Field1 [a0] [a0] b b)
11:33:36 <lambdabot>        from the context: (Field1 [a] [a] b b, Num a)
11:33:39 <EvanR> aw
11:33:43 <amalloy> although i must say it seems to work despite the warning
11:33:48 <EvanR> amalloy: well... it knew were _1 was
11:34:00 <sl2c> > [3,2,1] ^. ix 1
11:34:04 <lambdabot>  error:
11:34:05 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M484841301837...
11:34:05 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
11:34:14 <sl2c> :t ix
11:34:16 <lambdabot> (Applicative f, Ixed m) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
11:34:18 <guessWHo> now i think this question is quite understandable http://lpaste.net/363916
11:34:51 <sl2c> > ([3,2,1] ^. ix 1)::Int
11:34:54 <lambdabot>  error:
11:34:54 <lambdabot>      • No instance for (Monoid Int) arising from a use of ‘ix’
11:34:54 <lambdabot>      • In the second argument of ‘(^.)’, namely ‘ix 1’
11:35:05 <EvanR> guessWHo: compile with -threaded and try again
11:35:18 <sl2c> okay i don't understand the ix lens, clearly
11:35:32 <glguy> ix isn't a Lens
11:35:46 <sl2c> oh, right, applicative
11:35:49 <glguy> rather it doesn't return Lenses
11:35:51 <EvanR> guessWHo: er... clearly, dummyFx never returns, () is never written to the MVar
11:36:00 <hololeap> guessWHo: dummyFx never terminates because it uses `forever`
11:36:03 <sl2c> > ([3,2,1] ^? ix 1)
11:36:06 <lambdabot>  Just 2
11:36:23 <sl2c> > ([3,2,1] ^.. ix 1)
11:36:26 <lambdabot>  [2]
11:36:27 <sl2c> > ([3,2,1] ^.. ix 42)
11:36:29 <guessWHo> EvanR : stack ghc -threaded ??
11:36:30 <lambdabot>  []
11:36:43 <EvanR> sorry -threaded is not your issue
11:37:02 <sl2c> glguy: thanks.  forgot that indices can sometimes fail to actually produce values
11:37:35 <hololeap> this would set the MVar and *then* cause the fork to spit out "hello" indefinitely: forkIO $ putMVar demo () >> dummyFx
11:37:54 <EvanR> no because the program would end
11:38:07 <hololeap> oh, right
11:38:57 <hololeap> the program isn't ending because in your example, the MVar returned by dummyFx2 is still waiting for a value
11:39:19 <sl2c> :t sumOf
11:39:20 <lambdabot> Num a => Getting (Endo (Endo a)) s a -> s -> a
11:39:32 <guessWHo> in that case shouldn't this work ??
11:39:34 <guessWHo> http://lpaste.net/363917
11:40:29 <EvanR> guessWHo: return "Damnnn" doesnt do anything there
11:40:34 <jle`> oh hey, == is a closed type family in new ghc
11:40:35 <jle`> i wonder why
11:40:54 <jle`> it looks like it's a completely different thing now
11:41:02 <jle`> just happens to have the same name
11:41:05 <EvanR> > return "Damnn" >> return () :: Maybe ()
11:41:08 <lambdabot>  Just ()
11:41:26 <EvanR> is the same as
11:41:36 <EvanR> > pure "Damnn" >> pure () :: Maybe ()
11:41:39 <lambdabot>  Just ()
11:43:07 <hololeap> guessWHo: are you trying to get it to print out "Damnnn" at some point? if so, at which point in the program?
11:43:25 <guessWHo> but dummyFx is running on a seperate thread shouldn't the parent thread be able to return ?? also isn't it true that do also provide sequencing ?
11:44:11 <EvanR> *return doesnt do control flow*
11:44:11 <hololeap> yeah, but `return whatever` followed by another action doesn't actually do anything
11:44:23 <guessWHo> hololeap : as soon as i do temp <- dummyFx2
11:44:36 <the_2nd> I pass a string to Megaparsec for parsing and its error reporting always refers to line 1:COLUMN. My string is delimited via '\n' but it seems like megaparsec doesn't see that as single lines internally. Any way to fix this?
11:44:38 <hololeap> return is completely without effect (and it is poorly named)
11:44:41 <EvanR> > return 'c' :: Maybe Char
11:44:44 <lambdabot>  Just 'c'
11:44:50 <EvanR> > return 'c' :: [Char]
11:44:53 <lambdabot>  "c"
11:44:58 <EvanR> > return 'c' :: Identity Char
11:45:00 <lambdabot>  Identity 'c'
11:45:02 <EvanR> thas all it does
11:45:21 <sl2c> the fact that people think return should do control flow is why people don't like that name, right?
11:45:27 <sl2c> > pure 'c' :: Const String Char
11:45:30 <lambdabot>  Const ""
11:45:35 <hololeap> guessWHo: if that's the case, then change `return "Damnnn"` to `print "Damnnn"`
11:45:42 <EvanR> ime it doesnt come up that much
11:45:42 <hololeap> print actually has an effect
11:45:54 <Sonolin> sl2c personally, its just mental baggage from too much use of procedural languages
11:46:04 <Sonolin> if I jumped right into haskell I doubt it'd be such an issue
11:46:43 <sl2c> > Left 4 >> Right 2 -- this lets you do imperative-style 'return' in a sense though, yeah?
11:46:46 <lambdabot>  Left 4
11:47:06 <EvanR> in the sense of an exception yeah
11:47:09 <hololeap> guessWHo: in many cases, there is no reason to use "return", and if you need to, use "pure" instead since it is the exact same function and the name fits what it does so much better
11:47:20 <EvanR> but not a 1-function early return
11:47:43 <guessWHo> hololeap : naa that's a hack i want to print temp which should print it what if i'm returning something like this data type ?? return (DummyCons v1 v2 v3 v4)
11:47:59 <EvanR> that doesn *return* anything
11:48:05 <EvanR> *return doesn do control flow*
11:49:38 <guessWHo> EvanR : i got it its just a function defined in Moand Type class , but how do i do what i want to do
11:49:40 <hololeap> just use "pure" instead of "return" ... and remember that both of them are essentially "lifting" a value without doing anything else
11:50:02 <EvanR> guessWHo: what do you want it to do
11:51:38 <AWizzArd> I have   data Value n = StrVal String | NumVal n | Vals [Value n] deriving (Show)   and want foo (StrVal s) = NumVal $ length s     <- this works. But when I try to give an explicit signature it doesn't:    foo :: (Num n) => Value n -> Value n
11:52:34 <barrucadu> @type length
11:52:36 <lambdabot> Foldable t => t a -> Int
11:52:40 <guessWHo> EvanR :  forget about this function say i want to do something meaningful with it say i want it to be of type dummyFx2 :: Int -> String -> IO (Int,String)
11:52:59 <guessWHo> and other than that i want to perfrom the print action i'm already doing
11:53:14 <EvanR> you want to return data, and also print forever
11:53:28 <EvanR> then what
11:54:02 <AWizzArd> barrucadu: uh okay, that’s unexpected. It talks about rigid type variables and doesn’t tell me that the Foldable is an issue here.
11:54:05 <EvanR> dummyFx2 x y = forkIO (forever (print "damnnn")) >> return (x,y)
11:54:38 <barrucadu> AWizzArd: The problem isn't foldable, the problem is that length returns an int but your type is more general than that
11:55:29 <AWizzArd> barrucadu: I see.
11:56:02 <AWizzArd> barrucadu: what should an explicit signature look like?
11:56:41 <barrucadu> foo :: Value Int -> Value Int
11:56:51 <barrucadu> Or use genericLength
11:56:56 <barrucadu> @type genericLength
11:56:57 <lambdabot> Num i => [a] -> i
11:57:52 <AWizzArd> barrucadu: the thing is that I want to allow also   foo (NumVal x) = NumVal $ x + 2.5
11:58:02 <AWizzArd> So it should also support Doubles or any other number that supports (+).
11:58:38 <Naughtmare[m]> @type fromIntegral . length
11:58:40 <lambdabot> (Foldable t, Num c) => t a -> c
12:00:02 <guessWHo> EvanR : now here's how dummyFx2 looks like is it possible to do what's defined in it's type signature http://lpaste.net/363918 (it compiled fine though)
12:00:08 <amalloy> AWizzArd: if foo (NumVal x) = NumVal $ x + 2.5, you are not supporting any type that has (+): the type must also support fractions
12:01:00 <EvanR> guessWHo: this is pretty much the same program as before, it fails to continue because you inserted an MVar which blocks everything
12:01:07 <EvanR> not different
12:01:25 <AWizzArd> okay makes sense
12:01:30 <EvanR> you should read a guide on MVars
12:02:07 <hololeap> guessWHo: in that example, dummyFx never terminates because of the `forever`. because of that, putMVar will never be called. thus, dummyFx2 will hang on takeMVar, because takeMVar blocks when there is no value set
12:03:03 <hololeap> also, the takeMVar line is pointless
12:03:38 <hololeap> (and you need a space between "demo" and "()")
12:03:52 <EvanR> yeah we analyzed this program already
12:03:59 <guessWHo> okay got it so it can't be done without modifying ?
12:04:13 <hololeap> it's still super unclear what "it" is that you want to be done
12:04:22 <EvanR> guessWHo: did you look at my suggestion
12:04:58 <EvanR> hololeap: many moons ago, guessWHo asked how to print stuff out from multiple threads without it jumbling up
12:05:08 <hololeap> oh
12:05:22 <EvanR> but we got stuck on return doesn't do control flow
12:05:40 <guessWHo> hololeap : "also, the takeMVar line is pointless" no its not pointless actually it's what make it go forever since its blocking in nature and hold on to the main thread otherwise main thread will exit and it won't run forever even with forever
12:06:15 <dminuoso> guessWHo: If by "we wont run forever even with forever" you mean the fact that there's a point where the sun will stop burning, giving us energy.. then sure..
12:06:37 <EvanR> yes when the main thread exits, everything exits
12:06:58 <guessWHo> EvanR : ah yeah i did read your suggestion and i think i have red enough of MVar for now and anything more on that not goanna solve the problem
12:07:07 <EvanR> which problem
12:08:16 <hololeap> guessWHo: this is the book you need: https://www.amazon.com/Parallel-Concurrent-Programming-Haskell-Multithreaded/dp/1449335942
12:08:38 <guessWHo> hololeap : ??
12:09:15 <dminuoso> I do think, that based on the fact that guessWHo was tasked to read an introductory article on how IO works, and that you cant have `IO a -> a` it's a rather brave thing to do full blown STM just a day after (hopefully) understanding how to sequence effects in IO.
12:09:25 <dminuoso> *he was tasked to do so yesterday.
12:09:33 <hololeap> there's a whole section on building interesting, thread safe data structures using MVars linked together in different ways
12:09:52 <guessWHo> dminuoso : i did read that article yesterday
12:10:22 <guessWHo> dminuoso : and yeah in an ideal world it would run forever
12:11:10 <EvanR> forkIO (fix forever) >> return ()
12:11:28 <dminuoso> :t fix forever
12:11:30 <lambdabot> Applicative f => f a
12:11:58 <EvanR> bwahahaha
12:11:58 <hololeap> lolwut
12:13:01 <EvanR> forever (forever (forever (forever (... forever
12:13:04 <dminuoso> That's what makes Haskell so brilliant. If you ever have a function that doesn't recurse (or work) properly, you can just `fix` it.
12:13:24 <hyperisco> I'd normally use a regex for this… how do I excise a substring using some grammar rules about what to look for?
12:13:42 <hyperisco> it isn't clear to me how to skip over arbitrary text using Parsec w/o also skipping over what I am looking for
12:14:19 <EvanR> you kind of posed the regex problem
12:14:33 <EvanR> how do i do regex without regex
12:14:58 <hyperisco> oh of course I just have it consume a single character and try again
12:15:07 <Rembane> Shouldn't a grammar be more powerful than a regex?
12:15:18 <EvanR> assuming the grammar is the grammar of a regular language
12:15:33 <EvanR> if not, lets not discuss regex
12:15:35 <hyperisco> actually they have manyTill which is just this
12:16:14 <hyperisco> well Parsec is not a general parser so I have to also twist my brain to play in its bounds
12:17:04 <EvanR> not general?
12:17:10 <hyperisco> CFG
12:17:49 <hyperisco> if it was then I could just use  .*x.*  where x is whatever thing I am looking for
12:18:27 <guessWHo> what am i supposed to do with fix >?
12:18:48 <EvanR> our poor brains which want trees or graphs to be serialized
12:19:13 <masaeedu[m]> dminuoso: That's pretty interesting
12:19:29 <masaeedu[m]> I guess `forever` is like taking an infinite list, running it through `fmap (const youraction)`, and folding over it with bind (pure being the starting point)
12:20:09 <hololeap> guessWHo: don't worry, it was a joke
12:20:10 <EvanR> @src forever
12:20:11 <lambdabot> forever a = let a' = a >> a' in a'
12:20:14 <masaeedu[m]> uh, a bind that throws away its input
12:20:15 <masaeedu[m]> `>>`
12:20:30 <EvanR> it produces a list, doesnt take a list
12:20:37 <EvanR> a >>-list
12:20:46 <dyl> masaeedu[m] I think you mean like a *smooshMap* that throws away its input.
12:20:57 <koala_man> hyperisco: it's not good parser design, but you can read character by character until a parser matches ahead
12:21:02 <EvanR> forever is an unfold
12:21:11 <masaeedu[m]> it produces a list of what?
12:21:18 <EvanR> actions
12:21:38 <EvanR> like repeat 'a' but with (:) replaced with >>
12:21:41 <masaeedu[m]> right, i'm not saying "takes" as a parameter
12:21:53 <EvanR> @src repeat
12:21:53 <lambdabot> repeat x = xs where xs = x : xs
12:22:07 <guessWHo> hololeap : Wow so funny
12:22:08 <masaeedu[m]> I'm saying that's part of this rube goldberg's implementation i'm coming up with to explain it to myself
12:22:09 <EvanR> aw the source is not precisely analogous, due to style :)
12:22:36 <EvanR> repeat x = let xs = x : xs in xs
12:22:47 <EvanR> forever a = let a' = a >> a' in a'
12:23:43 <masaeedu[m]> Like `forever a = foldr (\x y -> x >> y) a (repeat a)`
12:23:43 <masaeedu[m]> something like that
12:24:07 <EvanR> yep
12:24:19 <guessWHo> dminuoso : well unsafeLocalState :: IO a -> a
12:24:29 <dminuoso> guessWHo: Ignore the existence of such functions.
12:24:36 <EvanR> foldr (>>) undefined (repeat a)
12:24:49 <EvanR> masaeedu[m]: the second param to foldr is teh *end* point not the beginning
12:24:54 <dminuoso> guessWHo: There's a couple with such signatures, they exist as backdoors for people that really know what they are doing (and understand the consequences and implications)
12:25:07 <dminuoso> guessWHo: As a regular haskell user (that is not doing ffi) - pretend they dont exist.
12:25:16 <masaeedu[m]> oh, whoops
12:25:27 <masaeedu[m]> maybe foldl?
12:25:28 <guessWHo> dminuoso : should have said that instead
12:25:32 <rotaerk> how can I determine what is meant by "type-level symbols" under the documentation for Symbol, here: https://hackage.haskell.org/package/base-4.11.0.0/docs/GHC-TypeLits.html#t:Symbol
12:25:46 <rotaerk> as in, what exactly are the type-level values I can use when the kind is Symbol
12:25:47 <masaeedu[m]> the JS has rotted my mind
12:25:48 <dminuoso> guessWHo: To understand IO, it's best to ignore that they exist.
12:25:49 <EvanR> masaeedu[m]: no foldr is right, it replaces each (:) with `f`
12:26:04 <EvanR> and [] with z, which we dont have to worry about since its infinite
12:26:13 <dminuoso> guessWHo: Because the purpose of those functions is not to circumvent IO really. It's rather when you have something that is `IO a` - but you somehow _know_ it's pure.
12:26:44 <masaeedu[m]> EvanR:  are you saying my `x y` are backwards
12:26:51 <EvanR> no
12:26:52 <dminuoso> guessWHo: or well rather - it _is_ for circumventing IO.
12:26:59 <dminuoso> guessWHo: (not using it)
12:27:10 <EvanR> (\x y -> x >> y) = (>>)
12:27:10 <guessWHo> dminuoso : ohk cool
12:27:34 <masaeedu[m]> lol
12:27:40 <masaeedu[m]> how to erase IRC chat history
12:27:44 <EvanR> dminuoso: somehow i dont think we should be explaining unsafePerformIO to guessWHo
12:27:53 <dminuoso> EvanR: no but he specifically asked about it.
12:28:07 <EvanR> oh i see
12:28:45 <rotaerk> some examples seem to use string literals where Symbol-kinded types are expected, but I don't see anything actually in the definition of that kind *saying* that
12:28:49 <guessWHo> EvanR : what do you mean by shouldn't be explaining to guessWHo
12:29:01 <rotaerk> so how would I know if it weren't for those examples? and is that ALL that can be used in that kind?
12:29:55 <hololeap> guessWHo: one of the main reasons to even use haskell in the first place is seperating pure functions from actions, hence why a value shouldn't be allowed to be extracted from IO... IO marks it as "impure"
12:30:18 <cocreature> rotaerk: you can only use string literals and afaik you can use all of them, i.e, I’m not aware of any restrictions
12:31:01 <rotaerk> okay thanks; I'm also wondering if there's some official documentation I'm failing to find that says this
12:31:05 <masaeedu[m]> `ntimes n a = foldr (>>) a (take n . repeat $ a)`
12:31:22 <masaeedu[m]> is there an `n` such that I could express `forever` as `ntimes n`
12:31:32 <rotaerk> hell, that GHC.TypeLits documentation says it's not supposed to be used by programmers, that it's internal, yet it seems to be used by programmers
12:32:13 <cocreature> rotaerk: maybe take a look at the docs for DataKinds
12:32:19 <cocreature> not sure if those are better
12:32:37 <cocreature> that note that it shouldn’t be used by programmers should probably be removed tbh
12:32:39 <wp> is haskell used at any major corporations? like Google, Ericsson etc?
12:32:42 <guessWHo> hololeap : but we do extract values from IO right i mean it's called binding to the value but same thing no ? ( temp <- (a -> IO a))
12:33:08 <wp> > (+1  . *3) 5
12:33:09 <guessWHo> wp : facebook uses it
12:33:12 <lambdabot>  <hint>:1:8: error: parse error on input ‘*’
12:33:23 <hololeap> guessWHo: binding two actions together makes a single larger action, but the whole thing never leaves IO once it enters it
12:33:24 <wp> > ((+1)  . (*3)) 5
12:33:27 <lambdabot>  16
12:33:30 <rotaerk> think I found it:  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#type-level-literals
12:33:47 <wp> guessWHo, how?
12:34:05 <cocreature> wp: for their antispam system
12:34:40 <masaeedu[m]> guessWHo: It seems `do` notation is confusing you; it helps if you only stick with simple things like `>>=`
12:34:46 <masaeedu[m]> or learn how to do the desugaring mentally
12:34:48 <wp> cocreature, seems data intensive. machine learning?
12:34:57 <guessWHo> wp : https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/ , i'm not sure weather they themselves use it or not
12:34:58 <cocreature> no idea, I don’t know the internals
12:35:16 <sl2c> There's a talk about it. It's a rule based system called sigma
12:35:24 <dminuoso> guessWHo: no "we" dont do it.
12:35:27 <masaeedu[m]> when you're doing `x <- whatever`, that `x` may assume several different values. The do notation is unrolled in a somewhat abstract way into applys and binds
12:35:59 <dminuoso> guessWHo: It's not as much "extraction". It's rather that the runtime handles the "carrying data" from one (internal) IO to the next computation.
12:36:25 <hololeap> guessWHo: there really isn't "supposed" to be a function of type (IO a -> a), hence why the functions that can do that are usually called unsafe*
12:36:39 <masaeedu[m]> i'm familiar with haxl in passing, it exploits "applicative do" to write things as if they were sequential but actually do them in parallel
12:36:59 <masaeedu[m]> because the contextual aspect of `ap` can be done in parallel
12:37:44 <hololeap> it has more to do with the ideology behind the language than it being impossible to achieve. pretty much *all* the other languages don't differentiate between pure and impure functions. it really is a feature of haskell
12:38:01 <dminuoso> guessWHo: Consider an unsafe function to be something like
12:38:12 <AWizzArd> A for Aeson –   A.decodeStrict (pack "{\"a\":10}") :: Maybe A.Value    works  but why doesn’t it work with single quotes?    A.decodeStrict (pack "{'a':10}") :: Maybe A.Value
12:38:18 <cemerick> I'm running a long quickcheck as part of my `stack test` suite. The QC process seems to stall occasionally (i.e. trial count progress stops), and only resumes again if I put some input into the terminal (e.g. hit return).
12:38:19 <dminuoso> guessWHo: (RealWorld, Int) -> (RealWorld, Int)
12:38:22 <AWizzArd> „Working” in the sense of not resulting in Nothing.
12:38:29 <cemerick> Has this ever happened to anyone? Seems really bizarre.
12:38:52 <masaeedu[m]> Basically, when you're doing something like `do x <- [1, 2, 3]; y <- [4, 5, 6]; return [f x y]`, you have to remember in your head that this desugars to something like `f <$> x <*> y`
12:39:10 <dminuoso> guessWHo: You can't make the fact that it changes the world just "disappear" by stripping it off. That would change the semantics.
12:39:16 <cocreature> cemerick: are you sure it’s actually progressing because you hit return or is it just taking a long time to generate new candidates?
12:39:21 <masaeedu[m]> and that `f x y` is evaluated 9 times
12:39:55 <cemerick> cocreature: the trial counter starts moving again? ¯\_(ツ)_/
12:40:01 <masaeedu[m]> whoops, that should be `f <$> [1, 2, 3] <*> [4, 5, 6]`
12:40:13 <EvanR> what applicative do? :)
12:40:19 <cocreature> cemerick: do you have any recursive generators?
12:40:52 <EvanR> > f <$> [1,2,3] <*> [4,5,6] :: Expr
12:40:55 <lambdabot>  error:
12:40:55 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘[b0]’
12:40:55 <lambdabot>      • In the expression: f <$> [1, 2, 3] <*> [4, 5, 6] :: Expr
12:40:57 <cemerick> cocreature: oh, and CPU goes idle, so that's other good evidence. Only generating ints
12:41:04 <EvanR> > f <$> [1,2,3] <*> [4,5,6] :: [Expr]
12:41:07 <lambdabot>  [f 1 4,f 1 5,f 1 6,f 2 4,f 2 5,f 2 6,f 3 4,f 3 5,f 3 6]
12:41:10 <EvanR> wow
12:41:41 <EvanR> > f <$> [a,b,c] <*> [x,y,z] :: [Expr]
12:41:44 <lambdabot>  [f a x,f a y,f a z,f b x,f b y,f b z,f c x,f c y,f c z]
12:42:00 <[exa]> what trickery is behind it?
12:42:06 <masaeedu[m]> it's going to do all the permutations
12:42:11 <EvanR> i never understood Expr
12:42:12 <masaeedu[m]> but that's just one possible applicative instance
12:42:41 <hololeap> > f <$> Just x <*> Just y :: Maybe Expr
12:42:44 <lambdabot>  Just (f x y)
12:42:50 <hololeap> > f <$> Just x <*> Nothing :: Maybe Expr
12:42:54 <lambdabot>  Nothing
12:42:54 <guessWHo> dminuoso : but loosely speaking it's doing the same thing i have a function a -> b -> IO c and and i can get c but whatever i got it it's not the same thing
12:43:01 <Myrl-saki> Which API do you guys prefer? https://github.com/adrianparvino/mysc-client/commit/c683605acacad8c3fe00ab84043ce9b6683da129
12:43:30 <Myrl-saki> On the second one, I used RankNTypes, and basically pass wrapper functions.
12:43:53 <Myrl-saki> It's cleaner to write, but the type is abyssmal.
12:44:08 <EvanR> type synonyms?
12:44:11 <masaeedu[m]> > do x <- [1, 2, 3]; y <- [4, 5, 6]; return [f x y] :: Expr
12:44:15 <masaeedu[m]> whoops
12:44:15 <lambdabot>  error:
12:44:15 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘m0 [a0]’
12:44:15 <lambdabot>      • In a stmt of a 'do' block: return [f x y] :: Expr
12:44:16 <masaeedu[m]> lol, how do you do the thing
12:44:19 <Myrl-saki> card :: forall t m a. MonadWidget t m => [T.Text] -> ((forall b. ((T.Text -> m ()) -> (FontAwesome -> m ()) -> m b) -> m b) -> (forall b. m b -> m b) -> (forall b. ((forall c. c -> T.Text -> m (Event t c)) -> m b)  -> m b) -> m a) -> m a
12:44:40 <masaeedu[m]> > do x <- [1, 2, 3]; y <- [4, 5, 6]; return [f x y] :: Expr
12:44:43 <lambdabot>  error:
12:44:43 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘m0 [a0]’
12:44:44 <lambdabot>      • In a stmt of a 'do' block: return [f x y] :: Expr
12:45:09 <Myrl-saki> http://ix.io/10BK
12:45:21 <masaeedu[m]> > (do x <- [1, 2, 3]; y <- [4, 5, 6]; return [f x y]) :: [Expr]
12:45:24 <lambdabot>  error:
12:45:24 <lambdabot>      • Couldn't match type ‘[a0]’ with ‘Expr’
12:45:24 <lambdabot>        Expected type: [Expr]
12:45:53 <[exa]> > (((1+1)::Int) + 1) :: Expr
12:45:56 <lambdabot>  error:
12:45:56 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘Int’
12:45:56 <lambdabot>      • In the expression: (((1 + 1) :: Int) + 1) :: Expr
12:46:00 <masaeedu[m]> http://i0.kym-cdn.com/entries/icons/original/000/008/342/ihave.jpg
12:46:04 <Myrl-saki> https://github.com/adrianparvino/reflex-bulma/commit/d26effc145070bb2009e2a2f773fb96349aae228
12:46:12 <[exa]> :(
12:46:26 <Myrl-saki> Before/After API type definition.
12:46:52 <EvanR> Myrl-saki: some of these can be given interestingly named parameterized type synonyms
12:46:59 <EvanR> like when doing function pointer types in C
12:47:02 <Myrl-saki> EvanR: True.
12:47:10 <guessWHo> can this be done http://lpaste.net/363921 ?
12:47:14 <rotaerk> what's this construct called:  #{offset VkSamplerCreateInfo, addressModeU}
12:47:33 <Myrl-saki> EvanR: IIRC, you can't existential type on a type synonym though?
12:47:41 <EvanR> its not existential types
12:47:52 <EvanR> type Cool m = forall b . m b -> m b
12:47:57 <EvanR> its just RankN
12:47:58 <rotaerk> e.g. in https://github.com/achirkin/vulkan/blob/f6926c898490aae022b092e5fbc6edce7baf8019/vulkan-api/src-gen/Graphics/Vulkan/Types/Struct/VkSamplerCreateInfo.hsc
12:48:03 <Myrl-saki> EvanR: Oh mkay. Thanks.
12:48:48 <Myrl-saki> EvanR: `HeaderHandler`?
12:48:54 <rotaerk> oh wait, I just noticed it's hsc ... wonder if it has to do with thatt
12:49:12 <EvanR> m a -> m a.... is more general than just Headers heh
12:49:34 <Myrl-saki> EvanR: True.
12:49:38 <EvanR> ActionMap
12:49:51 <EvanR> EndoNad
12:49:53 <EvanR> lol
12:50:04 <dminuoso> guessWHo: No loosely speaking its not the same.
12:50:27 <EvanR> f a -> f a, really...
12:50:43 <guessWHo> dminuoso : i did say at last that's it not same
12:50:57 <EvanR> but yeah these all look like "Handlers"
12:51:11 <Myrl-saki> EvanR: Thanks.
12:51:54 <guessWHo> dminuoso : last question of the day, http://lpaste.net/363921
12:52:21 <dminuoso> EvanR: Oh my. Look at what you did with your `fix forever` joke.
12:52:23 <guessWHo> dminuoso : oh sorry i forgot i'm not supposed to tag sorry
12:52:42 <dyl> Does anyone know who I should talk to about recovering a hackage account?
12:52:51 <dyl> I don't have the password, but it's not upgraded so I can't reset it.
12:53:06 <EvanR> hahahaha
12:53:12 <dyl> "Sorry, the self-service password reset system cannot be used for this account at this time."
12:53:23 <EvanR> dminuoso: was it a joke?
12:53:37 <hololeap> guessWHo: `fix` does the opposite of what its name implies
12:53:38 <EvanR> i think guessWHo has been messing with us
12:53:54 <hpc> > fix error
12:53:57 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
12:54:03 <dyl> hahahahaha
12:54:24 <sl2c> > fix show
12:54:28 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
12:54:35 <dyl> what is the pattern...?
12:54:38 <hpc> > map length . group $ fix show
12:54:38 <guessWHo> EvanR : no messing that was before i checked fix on hoogle forgot to change it
12:54:41 <dminuoso> @src fix
12:54:42 <lambdabot> fix f = let x = f x in x
12:54:43 <dminuoso> dyl: ^-
12:54:45 <lambdabot>  mueval-core: Time limit exceeded
12:54:51 <dyl> I know what fix is.
12:54:56 <dyl> I mean, why is fix show irregular?
12:55:08 <hpc> a string is "whatever"
12:55:14 <hpc> a string in a string is \"whatever\"
12:55:19 <sl2c> Because it repeatedly escapes a quote mark
12:55:24 <dyl> Oh it is regular.
12:55:24 <hpc> a string in a string in a string is \\\"whatever\\\"
12:55:27 <EvanR> fix show is the string that shows itself
12:55:30 <hpc> you have to escape the backslashes, remember
12:55:34 <dyl> \ \\\ \\\\\\\
12:55:35 <Myrl-saki> EvanR: Thanks, I like it a bit better.
12:55:40 <dyl> 1, 3, 7, etc
12:55:48 <dyl> It's 2n + 1
12:55:59 <wp> HOW CAN HASKELL PLATFORM TAKE UP SEVERAL GIGABYTES? sriously?
12:56:03 <hololeap> :t fix fix
12:56:04 <lambdabot> error:
12:56:05 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ a -> a
12:56:05 <lambdabot>       Expected type: a -> a
12:56:09 <dyl> :t fix error
12:56:10 <lambdabot> [Char]
12:56:24 <EvanR> the type of fix fix is a function that takes itself
12:56:26 <wp> how much is just the compiler? dont you get the standar dibs witht hat?
12:56:30 <hpc> wp: base, built in a bunch of configurations
12:57:00 <hpc> such as profiling
12:57:13 <dminuoso> wp: static/dynamic/profile for the runtime itself, tons of libraries..
12:57:16 <Myrl-saki> :t fix fix
12:57:18 <lambdabot> error:
12:57:18 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ a -> a
12:57:18 <lambdabot>       Expected type: a -> a
12:57:23 <hololeap> > fix (const 1)
12:57:23 <dyl> wp about 80% of the gigabytes are all of the research papers GHC sends to mturk when you compile .hs files.
12:57:26 <lambdabot>  1
12:57:30 <hololeap> yay
12:57:36 <dminuoso> on a different note..
12:57:37 <EvanR> let tau = tau -> tau in tau
12:57:49 <EvanR> cool type
12:58:01 <mnoonan> :t splitOn
12:58:02 <EvanR> its an infinite complete binary tree
12:58:03 <dminuoso> > foldr (.) id $ replicate 4 (.)
12:58:03 <lambdabot> Eq a => [a] -> [a] -> [[a]]
12:58:06 <lambdabot>  error:
12:58:06 <lambdabot>      • Occurs check: cannot construct the infinite type: b ~ a0 -> b
12:58:06 <lambdabot>        Expected type: [(b -> c) -> b -> c]
12:58:09 <dminuoso> Is there a way to make this typecheck?
12:58:16 <mnoonan> > map length (splitOn "\"" (fix show))
12:58:16 <Myrl-saki> EvanR: I don't get it.
12:58:22 <lambdabot>  mueval-core: Time limit exceeded
12:58:23 <Myrl-saki> EvanR: It literally says (a -> a) ~ a
12:58:29 <EvanR> right
12:58:29 <mnoonan> > take 10 $ map length (splitOn "\"" (fix show))
12:58:32 <lambdabot>  [0,1,3,7,15,31,63,127,255,511]
12:58:32 <EvanR> same thing
12:58:36 <Myrl-saki> EvanR: Is there any way for that to type check?
12:58:46 <EvanR> no, its specificaly disallowed by ghc
12:58:48 <dyl> Out of curiosity, does anyone else use fira code for .hs?
12:58:50 <EvanR> with a cycle check
12:58:52 <Myrl-saki> EvanR: In other type systems.
12:58:55 <dyl> The ligatures can be nice.
12:58:56 <EvanR> sure why not!
12:59:06 <EvanR> for example, untyped lambda calculus
12:59:38 <hololeap> :t foldr (.) id
12:59:40 <lambdabot> Foldable t => t (b -> b) -> b -> b
12:59:43 <guessWHo> so it's a no again it can't be done ? http://lpaste.net/363922
12:59:46 <hololeap> :t (.)
12:59:48 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:00:00 <EvanR> Myrl-saki: the error message should say "shall not construct the infinite type: "
13:00:16 <hololeap> dminuoso: (b -> c) -> (a -> b) -> (a -> c) /= (b -> b)
13:00:51 <dyl> I just get error: parse error on input ‘->’, EvanR :p
13:01:08 <Myrl-saki> EvanR: I think I get what you mean.
13:01:27 <Myrl-saki> EvanR: You can do (a -> a) ~ a by literally subsituting the a's by the function type?
13:01:42 <EvanR> and repeat
13:01:47 <Myrl-saki> Right.
13:01:51 <Myrl-saki> Pretty cool. Thanks.
13:01:55 <dminuoso> hololeap: Ah.. I guess without some kind of dependent typing the mere attempt is flawed, right?
13:01:55 <EvanR> or making an expression graph in memory
13:02:34 <AWizzArd> How can I unset Wall in ghci?
13:02:58 <hololeap> dminuoso: you would need a Foldable that could hold [(e -> d), (d -> c), (c -> b), (b -> a)]
13:03:08 <hololeap> somehow ...
13:03:21 <cocreature> hololeap: that’s not that hard to build
13:04:37 <hololeap> eh, i think what i said is wrong somehow, but i think i got the point across
13:04:49 <hololeap> cocreature: never messed with anything that exotic
13:05:03 <dminuoso> hololeap: well Im just wondering whether the generalization of (.), (.) . (.), (.) . (.) . (.), etc. could be encoded somehow
13:05:25 <dminuoso> I mean its becoming obvious that this cant work on the type value
13:05:32 <dminuoso> *value level
13:06:05 <EvanR> hololeap: it would like, arrows is some sort of category...
13:06:16 <EvanR> i mean, exactly like
13:06:53 <EvanR> be
13:08:20 <cocreature> hololeap: http://lpaste.net/363923
13:09:49 <EvanR> thats a rube goldberg way to just do (.) ?
13:10:11 <Myrl-saki> Hmmm
13:10:17 <cocreature> I probably should have read the backlog more closely :)
13:10:32 <EvanR> still cool
13:10:40 <Myrl-saki> `instance (Monoid m) => Monoid (Monad m)`
13:10:45 <Myrl-saki> Doesn't that make sense?
13:10:47 <cocreature> you can track the intermediate types as well if you want
13:10:49 <EvanR> nope
13:10:51 <Myrl-saki> Err
13:11:00 <Myrl-saki> `instance (Monoid a, Monad m) => Monoid (m a)`
13:11:19 <Myrl-saki> `(<>) = (>>); mempty = pure`
13:11:23 <Myrl-saki> `(<>) = (>>); mempty = pure mempty`
13:11:29 <EvanR> yes
13:11:55 <Myrl-saki> I'm guessing it's because there are a lot of more useful Monoid instances for `m a`, where m is Maybe/List/etc.?
13:12:25 <EvanR> actually i use essentially that alot
13:12:31 <dminuoso> cocreature: let's consider some function zing, for which: zing 1 = (.) . (.); zing 2 = (.) . (.) . (.); zing 3 = (.) . (.) . (.) . (.)
13:12:35 <EvanR> but i have to use newtype wrapper
13:12:57 <masaeedu[m]> is that mzero and mplus?
13:12:58 <dminuoso> cocreature: I mean at times Im a bit surprised that things like liftM2, liftM3, liftM4 have to be specified separately, it's almost as if the necessary machinery to have some generalized form is missing
13:13:22 <EvanR> the machinery is likely terrifying to look at
13:13:31 <dminuoso> EvanR: Smells like TH!
13:13:37 <Rembane> dminuoso: I think it is there for clarity.
13:13:40 <EvanR> i mean, non TH
13:13:49 <EvanR> honestly type systematic
13:14:41 <ab9rf> dminuoso: that does kinda bother me on some level that that obvious generalization isn't supported
13:14:43 <EvanR> the types of liftA* can be given in terms of a length-indexed type list
13:14:58 <Myrl-saki> dminuoso: I think it's possible using pseudo-dependent types.
13:15:10 <hololeap> :t (.) . (.)
13:15:12 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
13:15:22 <hololeap> :t fmap `fmap` fmap :: (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
13:15:25 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
13:15:33 <hololeap> :t (.) . (.) . (.)
13:15:34 <lambdabot> (b -> c) -> (a1 -> a2 -> a3 -> b) -> a1 -> a2 -> a3 -> c
13:15:46 <hololeap> :t fmap `fmap` fmap `fmap` fmap :: (b -> c) -> (a1 -> a2 -> a3 -> b) -> a1 -> a2 -> a3 -> c
13:15:47 <lambdabot> (b -> c) -> (a1 -> a2 -> a3 -> b) -> a1 -> a2 -> a3 -> c
13:15:53 <Myrl-saki> On that topic.
13:16:07 <masaeedu[m]> maybe you could do it with a type family indexed by a type-level church numeral
13:16:22 <hololeap> something like Fix maybe?
13:16:26 <Myrl-saki> How would you make a compound data type with the elements `a -> b, b -> c, c -> d, ..., g -> h, h -> j`?
13:16:42 <EvanR> cocreature just did that
13:17:06 <Myrl-saki> EvanR: My statement?
13:17:10 <EvanR> yeah
13:17:19 <Myrl-saki> Aww, dammit. I thought it'd have been an interesting topic. :(
13:17:30 <EvanR> but in a way that doesnt put all intermediate types in the type visible to the user
13:17:37 <EvanR> which would require a kind of type list
13:18:00 <wp> isnt GHC installed automatically? it seems i had to run stack ghc to install it?
13:18:06 <Myrl-saki> EvanR: HVect?
13:18:15 <Myrl-saki> wp: For stack? No.
13:18:32 <wp> the compiler ghc isnt it installed when you instal the platform?
13:18:42 <wp> it says installing ghc now...
13:19:14 <Myrl-saki> wp: I'm confused. When is this happening?
13:20:34 <lyxia> wp: stack manages its own ghc by default
13:20:51 <ab9rf> stack may install a different version of GHC if your environment calls for a version that isn't already installed
13:20:54 <lyxia> it's strange that you're using both HP and stack
13:22:48 <cocreature> meh my attempts at an composeN are failing
13:23:14 <cocreature> I was hoping to get http://lpaste.net/363925 to work but no luck
13:23:28 <EvanR> the whole (.) . (.) and (.) . (.) . (.) thing is haskells version of other language features for customizing and rearranging the "open slot" in a multi argument function
13:23:37 <EvanR> which is confusing as hell
13:24:03 <EvanR> in the end... why not (\x y z -> f z x y) or something :)
13:24:35 <cocreature> EvanR: oh nobody said it was a good idea to do this :)
13:24:52 <EvanR> i think somebody did, because it made me think of those other languages, where they did it
13:25:18 <wp> why is the bin folder empty?
13:25:18 <ab9rf> because using a long sequence of what appears to be random noise always improves readibility of code.
13:25:37 <hyperisco> oh damn manyTill does not do what I want D:
13:25:42 <EvanR> lets replace the (.) . (.) . (.) chains with audible morse code
13:25:47 <hololeap> also (.) . (.) kinda looks like boobz
13:26:04 <ab9rf> hololeap: with what, a sternal zit?
13:26:19 <hololeap> i think of them as low hanging and the middle is the belly button
13:26:31 <ab9rf> hololeap: geez, who are you dating?
13:26:42 <EvanR> even better reasons not to bring up (.) . chains
13:27:29 <ab9rf> sadly, (.)(.) isn't all that useful
13:27:34 <hololeap> lol
13:27:38 <wp> it says installing ghc but ghc is not to be found
13:27:38 <cocreature> oh my type signature is just wrong, no wonder this won’t work
13:28:11 <cocreature> wp: stack doesn’t install GHC globally. it installs it so that it can be used by stack itself through its various commands such as "stack ghc"
13:28:29 <wp> but the haskll platform installer says it installed ghc
13:28:35 <wp> this is a bunch of crap
13:28:38 <wp> megainstaller
13:28:40 <wp> s
13:28:43 <wp> and confusing
13:28:50 <ab9rf> what are you trying to do?
13:29:00 <wp> a progrmaming language is not allowed to take up GIGABYTES of space
13:29:15 <wp> it used to be easy to install haskell
13:29:36 <ddellacosta> wp: are you using stack _and_ the Haskell platform? I'd pick one or the other. And the Haskell platform has a lot of stuff packaged in, although I'm surprised it's taking up gigs
13:30:03 <ab9rf> it has never been easy to install haskell
13:30:34 <wp> it used to be supereasy
13:30:56 <doyougnu> I haven't had a problem on arch linux, although I avoid cabal and the pacman libraries like the plague
13:30:57 <ddellacosta> I dunno, I've had a pretty easy time with stack, but YMMV
13:31:14 <hololeap> GHC on Gentoo is ~700MB by itself
13:31:19 <ab9rf> ddellacosta: but stackj doesn't install a global instance of ghc anywhere :)
13:31:31 <ab9rf> ghc is not a small compiler
13:31:41 <ddellacosta> ab9rf: that's true, I guess it wasn't clear to me that's what wp was trying to do
13:32:01 <ddellacosta> in that case I'd try a system package manager next I guess
13:32:09 <ddellacosta> or just download the sucker
13:32:54 <ab9rf> ddellacosta: i can't figure out what wp is trying to do
13:33:05 <ab9rf> ddellacosta: and wp won't tell us despite being asked
13:33:05 <hololeap> i wonder if the haskell platform has things compiled with the -dynamic flag
13:33:12 <ddellacosta> haha
13:33:25 <hololeap> that would reduce the size
13:34:56 <ddellacosta> oh, I'm out of the loop, I guess the Haskell platform now includes stack huh
13:35:09 <ab9rf> it does?
13:35:14 <wp> what the hell, all i want is GHC to be available frm the command prompt
13:35:18 <ab9rf> hm, it might, i uninstalled it a while ago
13:35:22 <wp> not some stupid stack installer crap
13:35:37 <ddellacosta> apparently ab9rf: https://www.haskell.org/platform/
13:35:42 <ab9rf> (platform, that is)
13:35:50 <ab9rf> i have stack installed on my notebook
13:36:53 <ddellacosta> wp: and so what have you tried, and what isn't working?
13:45:23 <wp> https://www.haskell.org/platform/windows.html
13:45:29 <wp> i tried both core and full
13:47:04 <ddellacosta> hmm I'm not familiar with GHC on Windows and I've only heard...bad things, I'm afraid. But maybe someone else around here knows more about using it on Windows...
13:47:22 <ddellacosta> but
13:47:30 <ddellacosta> alternatively, if you just want GHC, then you could try: https://www.haskell.org/ghc/download_ghc_8_4_1.html#windows
13:48:22 <Myrl-saki> ddellacosta: Or hugs. :P
13:48:29 <Myrl-saki> That's just like, I don't know. 20 MB?
13:48:35 <tdammers> I've had the questionable honor of using GHC on Windows recently
13:48:51 <Myrl-saki> tdammers: How depressed are you
13:48:54 <tdammers> as long as you stick with pure Haskell, things tend to work well
13:49:31 <tdammers> unfortunately, the project I was working on did not stick with pure Haskell, there were several dependencies on C libraries
13:49:36 <tdammers> that's where the fun started
13:49:47 <c_wraith> tdammers, doesn't that fall apart as soon as you need the internet?
13:50:24 <Myrl-saki> c_wraith: IIRC, Windows and UNIX's socket API are more compatible than any other system API.
13:50:43 <tdammers> c_wraith: no, the real challenge was to figure out how to make all parts of the tool chain as well as the final binary look for their dependencies in the same locations
13:55:54 <tdammers> so, it's like, you have your code that depends on a C library, so you need to point cabal and GHC at the right headers
13:56:01 <tdammers> but you also need to compile it with GCC
13:56:06 <tdammers> the library, that is
13:56:14 <tdammers> and for that, you need MSYS
13:56:43 <Myrl-saki> tdammers: msys is meant to be UNIX-on-Windows though, IIRC?
13:56:43 <tdammers> but the MSYS you use to compile your library must be the same one that GHC runs in
13:56:53 * ddellacosta eyes glaze over considering how that would all fit together
13:56:57 <hololeap> or, just run linux in a virtual machine -_-
13:57:08 <tdammers> hololeap: that won't give you a native Windows binary though
13:57:27 <tdammers> hololeap: in fact, I ran Windows in a VM
13:57:31 <Myrl-saki> tdammers: Just wrap it in Qemu.
13:57:46 <tdammers> bwahah, in hindsight that would have been easier
14:01:06 <hololeap> i *really* tried to compile GHC in cygwin, and it was *more* frustrating than expected
14:03:14 <hololeap> i actually don't think i got past ./configure :/
14:03:50 <hololeap> it was yelling at me about how cygwin wasn't a valid OS
14:03:56 <zachk> hololeap, try msys2 maybe, should be more modern then cygwin
14:04:12 <koala_man> I use Windows GHC+cabal in Wine on Linux. It actually works pretty well ^^
14:04:36 <hololeap> koala_man: hm...
14:06:17 <koala_man> not that it helps in this case, this is for compiling .exe files on Linux
14:06:58 <hololeap> koala_man: it's still good to know... i don't know how it would stand up to using FFIs that depend on libraries compiled for windows, though
14:07:28 <tdammers> yeah, that's exactly where it got hairy
14:07:41 <tdammers> just building pure haskell code works pretty well these days
14:09:42 <cocreature> dminuoso: http://lpaste.net/363929
14:13:08 <hololeap> cocreature: is that using Peano numbers?
14:15:01 <hololeap> cocreature: it's actually really impressive
14:24:04 <cocreature> hololeap: yeah it’s peano numbers tagged with a type-level list of function arguments of the length that the number represents + 1
14:31:47 <kuznero> Hi All! Did anybody have any good recipe for building statically linked binaries against musl instead of glibc?
14:43:04 <chessai> cocreature: that looks pretty cool
14:43:24 <chessai> cocreature: would that be useful for anything with -XPolyKinds
14:45:55 <jle`> i am going to start calling Z/12 "piano numbers"
14:46:50 <byorgey> hehe
14:56:33 <alsoStevenXL> hi everyone. I am having some trouble installing ghc-mod. I am trying to run this command "stack build --copy-compiler-tool ghc-mod" so that ghc-mod is installed on a per-compiler-version basis.
14:56:47 <alsoStevenXL> (I got this from: https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/)
14:57:57 <alsoStevenXL> But I get this error: http://lpaste.net/363934
14:58:10 <alsoStevenXL> and that continues when I add those dependencies to the extra-deps stanza.
14:59:25 <MarcelineVQ> ghc-mod doens't work for the newer ghc's, I've been told, have you tried bumping down your resolver a release or two?
14:59:46 <MarcelineVQ> that's a pretty newe article though, would guess sucha  thing would be covered
15:00:02 <dminuoso> cocreature: Interesting. There's a few bits Ill have to work out, but it's really cool to look at. :)
15:00:34 <alsoStevenXL> MarcelineVQ: I'll take a look at that. I am looking at the official ghc-mod docs, and using the recommended installation: cabal install ghc-mod
15:01:34 <MarcelineVQ> if you use stack that article is the way to go, but you might need to use an older lts major version to get ghc-mod working
15:02:03 <dminuoso> alsoStevenXL: lts-9.21 is the latest version that ghc-mod works for right now.
15:02:06 <MarcelineVQ> cabal works mostly under the assumption there's one ghc present so cabal install makes sense in that case to a degree, but this isn't the case with stack
15:02:42 <dminuoso> alsoStevenXL: Check out this tracker: https://github.com/DanielG/ghc-mod/issues/900 - there are ways to make it work with 8.2.2 though with some minor tweaks in stack.
15:02:43 <alsoStevenXL> hm.. OK. so I have to use a project where the resolve is set to lts-9.21?
15:04:08 <dminuoso> alsoStevenXL: Either that, or add some extra-deps as specified in the issue tracker.
15:04:25 <alsoStevenXL> MarcelineVQ / dminuoso ok so I opened up the stack.yaml and changed the resolver to 9.21, ran stack build --copy-compiler-tool ghc-mod and it is downloading / installing ghc 8.0.2 in an isolated location.
15:04:54 <dminuoso> alsoStevenXL: You could also use intero instead! =P
15:04:58 <alsoStevenXL> what is intero?
15:05:04 <alsoStevenXL> and does it vim?
15:05:27 <dminuoso> well emacs has evil, which kind of feels like vim...
15:05:38 * dminuoso smiles
15:05:44 <MarcelineVQ> it neovims https://github.com/parsonsmatt/intero-neovim
15:06:09 <alsoStevenXL> Hm.. that's cool; I'm using neovim.
15:06:26 <alsoStevenXL> ok i'll try that
15:06:27 <alsoStevenXL> ;-)
15:07:06 <tomsen> unfortunately intero doesnt give you autocompletion
15:07:33 <alsoStevenXL> i'm cool with that
15:07:38 <alsoStevenXL> i think vim does that by itself?
15:07:40 <dminuoso> tomsen: huh? I get autocompletion in spacemacs with intero as the backend
15:07:57 <tomsen> but the neovim version doesnt implement it
15:08:16 <fresheyeball> hey out there
15:08:19 <tomsen> they state it on their github page and refer to another plugin called neco-ghc tho
15:08:36 <fresheyeball> can someone tell me the difference between MonadPlus and Alternative?
15:08:54 <fresheyeball> They both are Monoids over a Functor
15:10:26 <lyxia> Alternative is the new MonadPlus
15:11:02 <lyxia> I think they had to be separate before Applicative became a superclass of Monad
15:11:15 <pagnol> this here discusses the difference https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus
15:12:21 <fresheyeball> lyxia: are there any types that are MonadPlus BUT NOT Alternative?
15:13:52 <lyxia> I don't think so. The wiki mentions that MonadPlus might signal some more laws holding but there isn't any consensus as far as I can tell.
15:14:02 <lyxia> I just don't use MonadPlus.
15:15:48 <chessai> alsoStevenXL: ghc-mod works with GHC-8.2.2 using nix, I believe
15:16:18 <chessai> they override the version from hackage with the branch on github
15:16:47 <chessai> there is a branch of ghc-mod on github that works with ghc-8.2.2, for the most part
15:16:56 <chessai> i and a coworker are currently using it
15:18:14 <alsoStevenXL> chessai: thank you. I think I'm going to try intero first. I am suffering from too many options and also I don't know what these tools are for. (For example, trying to get intero-vim to work, and I don't know if it is in addition to or replacement for some of the other stuff I have going on).
15:18:59 <lyxia> fresheyeball: also the m >> mzero = mzero law is broken by IO and MaybeT
15:19:36 <chessai> alsoStevenXL: I heard intero works beautifull with emacs, though I have not experienced this first-hand
15:20:45 <pagnol> I've been using ghc-mod and only now found out about intero... it looks gorgeous
15:20:56 <pagnol> going to give it a try later
15:21:12 <alsoStevenXL> ok gotta go check on what i broke
15:21:13 <alsoStevenXL> ;)
15:31:33 <jle`> fresheyeball: MonadPlus is like Alternative + Monad
15:31:43 <jle`> fresheyeball: it's essentially an empty typeclass, that just has laws only
15:32:06 <jle`> except the laws aren't even agreed upon, so
15:32:31 <jle`> fresheyeball: you can basically think of it effectively as type MonadPlus m = (Alternative m, Monad m)
15:32:47 <fresheyeball> jle`: mzero = empty in all cases?
15:33:01 <jle`> yes, mzero = empty and mplus = (<|>)
15:33:09 <amalloy> m >> mzero = mzero is an interesting law for IO. you can't exactly disprove it from inside of a haskell program, right? only by externally observing its behavior
15:33:19 <fresheyeball> there is a newtype MonadSum
15:33:40 <jle`> amalloy: you can if you catch
15:33:44 <fresheyeball> is there an Alternative version?
15:33:50 <amalloy> ah
15:33:51 <fresheyeball> AlternativeSum?
15:34:04 <jle`> fresheyeball: where is MonadSum ?
15:34:41 <fresheyeball> https://hackage.haskell.org/package/monoids-0.3.2/docs/Data-Monoid-Monad.html
15:34:57 <jle`> yes, it's caled Alt
15:35:04 <jle`> and it's in base
15:35:33 <jle`> it should work for MonadPlus's too, so MonadSum is obsolete
15:36:10 <jle`> fresheyeball: the monoids library is also been deprecated since 2012, so
15:37:00 <jle`> but yeah, if you think of MonadPlus as type MonadPlus m = (Alternative m, Monad m), it effectively just exists to make type signatures cleaner
15:37:17 <jle`> so you don't have to write (Alternative m, Monad m) => ... all the time, and can just write MonadPlus m => ...
15:37:54 <jle`> http://hackage.haskell.org/package/base-4.11.0.0/docs/Data-Monoid.html#t:Alt (for Alt)
15:38:10 <fresheyeball> jle`: I am trying to find it. That is not the right one, but it is the same thing
15:38:43 <wp> i have my haskell files in /src/
15:38:50 <wp> how do i list other.modules?
15:39:06 <jle`> list like, in a README?
15:39:14 <wp>   main-is:             src/main.hs
15:39:14 <wp>   -- other-modules:    PasswordGenerator
15:39:14 <wp>   -- other-extensions:
15:39:14 <wp>   build-depends:       base >=4.10 && <4.11
15:39:14 <wp>   -- hs-source-dirs:   src
15:39:15 <wp>   default-language:    Haskell2010
15:39:16 <jle`> if it's markdown, you can write it with * syntax
15:39:24 <wp> whats wrong with that+
15:39:26 <wp> ?
15:39:30 <jle`> other-modules is commented out
15:39:34 <jle`> with --
15:39:53 <jle`> and you should uncomment hs-source-dirs too
15:40:46 <dyl> Whatever you do, make sure it’s plish.
15:40:57 <wp> ah thanks
15:41:43 <jle`> wp: main-is might have to be just main.hs, in that case, too
15:43:12 <maerwald> is orphan instances part of haskell 2010?
15:48:04 <EvanR> https://gist.github.com/evanrinehart/9b05d8f38130d51feeb209c47b8eed9d
15:48:18 <EvanR> "What something is is what you can do with it"
15:48:21 <jle`> maerwald: i believe they are allowed in 98 too
15:49:24 <jle`> maerwald: https://www.haskell.org/onlinereport/decls.html doesn't seem to prohibit them
15:50:08 <maerwald> jle`: well, that doesn't mean they are a language feature you can expect
15:50:16 <jle`> yeah, it might be undefined behavior
15:50:59 <jle`> but i feel like any reasonable reading of the report would allow oprhan instances
15:51:12 <maerwald> I prefer *correct* reading
15:51:30 <jle`> correct in what sense?  the intent of the original authors?
15:51:31 <maerwald> so, it's a GHCism, afais
15:51:48 <maerwald> which is fine, but important to know
15:52:57 <jle`> A class declaration (Section 4.3.1) introduces a new type class and the overloaded operations that must
15:52:59 <jle`> be supported by any type that is an instance of that class. An instance declaration (Section 4.3.2)
15:53:01 <jle`> declares that a type is an instance of a class and includes the definitions of the overloaded
15:53:03 <jle`> operations---called class methods---instantiated on the named type.
15:53:10 <jle`> sorry, didn't realize the lines would break that way
15:54:16 <jle`> i don't think there is any way to read that and conclude that the types have to be from the same module as the class or type declaration
15:54:58 <jle`> "orphan instance" is probably just a human concept for organizing thoughts, and the report doesn't distinguish orphan instances from non-orphan ones
15:55:20 <jle`> so the ghc-ism, if anything, is probably that it can classify some instances as orphans, and emit a warning
15:59:02 <Tuplanolla> You are given two functions, `\ f x0 x1 x2 y -> f y x0 x1 x2` and `\ f y x0 x1 x2 -> f x0 x1 x2 y`, and two names, `flip3` and `unflip3`. Which one is which?
16:05:39 <maerwald> jle`: maybe we are looking at the wrong chapter
16:05:43 <Wizek> hello
16:06:20 <maerwald> maybe it's implicit somewhere in scoping or whatever
16:06:44 <Wizek> Anyone knows if/how I can specify local paths for cabal to use to override building one or two dependencies? Similar to how I can in a stack.yaml `packages: \n- location: ./packages/lens \n  extra-dep: true`?
16:14:01 <pagnol> what's a more readable way to pattern match on a record that does not rely on RecordWildcards? I mean something like `f (Foo {a = .., b  ..., ... })`
16:14:39 <hpc> NamedFieldPuns perhaps
16:14:52 <hpc> it gives you rust-like pattern matching
16:14:56 <pagnol> I'm using it actually
16:15:16 <pagnol> but in some cases I need to assign a new name to avoid name collisions
16:15:59 <geekosaur> what's the problem then?
16:16:17 <hpc> f (Foo {a, b, c = nonOverlappingName}) = ...
16:16:20 <geekosaur> you do know you can say Foo {b = x, ..}
16:16:33 <pagnol> oh really, no I didn't
16:16:36 <geekosaur> which renames that field but puns the rest
16:16:41 <pagnol> I always assumed ghc complains
16:17:24 <geekosaur> it might have a warning, but it should do what you expect
16:17:46 <glguy> Wizek: You can add them to your cabal.project file for new-build
16:18:09 <Wizek> glguy: that may be what I am looking for. Checking.
16:18:51 <pagnol> ah, previously I put the dots at the beginning, and that does result in an error
16:26:11 <lts> Via the do block I'm able to write valid functions like this -
16:26:12 <lts>   splitChild node i = do
16:26:14 <lts>     let y = (child node) !! i
16:26:16 <lts>     let leftKeys = drop (degree node) (keys y)
16:26:18 <lts>     ...
16:26:20 <lts> However, I am using assignments above, and afaiu the state of the program is different before and after the assignement. How come such state changes are valid in Haskell ?
16:26:38 <wp> is this unsafe? ie using the same passphrase for each website would create a pattern in all results that an be used to break the hash? def generate_password(passphrase, site):
16:26:38 <wp>     return hashlib.md5(passphrase + site).hexdigest()
16:27:27 <glguy> lts: No state is changing in the code you've pasted, so please use a pastebin when pasting code
16:28:00 <lts> glguy: my apologies
16:29:29 <glguy> s/so/also
16:44:31 <xterm_18> Hello
16:46:51 <xterm_18> Join
16:46:57 <xterm_18> We
16:47:03 <xterm_18> Wp
16:47:08 <xterm_18> wp
16:47:38 <glguy> stop please
16:54:39 * xterm_18 ‘hello’
17:14:59 <jmcarthur> I remember seeing something quite a while ago that given some Haskell functions could guess properties relating them to each other. Does anybody know what it's called?
17:16:56 <lyxia> jmcarthur: https://hackage.haskell.org/package/quickspec
17:18:02 <jmcarthur> Thanks!
17:27:23 <MarcelineVQ> oh wow haskell-ide-engine is very responsive in atom
17:45:04 <MarcelineVQ> except lint/error check on save isn't work, hmm
17:48:02 <jchia1> cassava question: How can I parse a CSV to records where a certain column is optional? Define two record types differing by that one optional field and make two parsing attempts?
17:48:48 <jchia1> I prefer to have one record type with the optional field as a Maybe
17:53:24 <dibblego> I only know how to do that with the sv library.
17:53:59 <elpfen> Parse it in line by line and split it into a list of strings on commas. Depending on the length of those lists, give it a maybe or nothing
17:54:40 <georgew> elpfen: That won't always work. Commas are allowed in quoted fields
17:55:13 <georgew> 1,2,"hello,goodbye"
17:55:27 <jchia1> dibblego: I haven't heard of the sv library. How's it different than cassava?
17:56:04 <georgew> jchia1: http://hackage.haskell.org/package/sv
17:56:06 <dibblego> jchia1: better parser, encoding/decoding, better error handling and additional library support
17:58:22 <georgew> This can often be used to do what you want depending on the structure of your fields http://hackage.haskell.org/package/sv-0.1/docs/Data-Sv-Decode.html#v:optionalField
17:59:25 <bitemyapp> georgew: does it have streaming yet?
17:59:37 <georgew> bitemyapp: Not yet.
17:59:41 <bitemyapp> seems like an important caveat to mention when recommending a library
17:59:51 <bitemyapp> that said, if they don't need streaming, sv is a pretty good upgrade from cassava.
18:03:05 <georgew> jchia1: `optionalField` won't work in all cases, but the worst case is something like https://github.com/qfpl/sv/blob/master/examples/src/Data/Sv/Example/Ragged.hs
18:07:34 <jchia1> georgew: Looks interesting, I'm going to study the docs some time.
18:08:06 <georgew> Cool :)
18:10:02 <georgew> By the way, I think the way I would do it in cassava is to define my FromRow instance to take in a vector, then case analyse on the size of the vector. That should tell you whether the optional row is there. Then do the appropriate thing.
18:11:37 <jchia1> georgew: I was going to define my own FromNamedRecord and my own parseNamedRecord, if making the record field a Maybe alone and deriving the FromNamedRecord instance is not enough
18:11:38 <georgew> Something sort of like this https://github.com/qfpl/sv/blob/master/benchmarks/src/Data/Sv/Random.hs#L74-L91
18:12:31 <georgew> Ok, that sounds like it would probably work alright.
18:13:30 <georgew> Another thing sv is currently missing is support for column-name based decoding rather than positional.
18:14:00 <jchia1> georgew: That's quite important
18:14:13 <georgew> Certainly
18:19:12 <progfunhere> hello Haskellers
18:59:44 <texasmynsted> howdy
19:00:05 <vaibhavsagar> hi there
19:19:27 <pikajude> Is there a version of Distribution.Compat.Graph in its own library?
19:29:57 <elpfen> quit
19:38:17 <howsiwei[m]> gsoc
19:53:31 <shafox> I am trying to install https://github.com/haskell/haskell-ide-engine#installation, I have cloned the repo and building it via "make", but it gives an error for * Missing C libraries: icuuc, icui18n, icudata, but the Makefile has the icu-macos-fix which has the values for the icu4c, but it never gets triggered.
19:58:50 <Guest81099> Hi, quick (hopefully) question. I am using the SBV library, and I am running code that generates a variety of potential models (e.g. for a given input, I want to solve both x^2 == 25 and x^2 == 36, though the code that generates the formulas is recursive, taking an SInteger and returning an array of SBools).
19:59:20 <hayesgm> At the end of the day, I end up with code that looks like this: `do x <- ( sInteger "x" ); return [x^2 .== (25 :: SInteger), x^2 .== (36 :: SInteger)]`
20:00:16 <hayesgm> The type of that `Symbolic [SBool]`, and I'm basically stuck trying to understand how I work this so I end up with (in any form) `[Symbolic SBool]`
20:01:14 <hayesgm> At the end of the day, I simply want to apply the models and end up with: result :: [Maybe Integer], "result = [Just 5, Just 6]" as a satisfying condition for each formula.
20:02:21 <hayesgm> My question is: is it possible to (or is there a better way) to convert a `Symbolic [SBool]` to a `[Symbolic SBool]` such that I can solve each formula (represented as an SBool) separately.
20:14:35 <lyxia> Symbolic [SBool] -> [Symbolic SBool]   doesn't seem right
20:14:53 <byorgey> hayesgm: no, it isn't possible to convert Symbolic [SBool] -> [Symbolic SBool]
20:16:07 <byorgey> hayesgm: if you reuse the same variable x in multiple things, they are necessarily connected and have to be processed together.
20:17:04 <byorgey> hayesgm: I think you may have to restructure your code so it generates a completely separate set of constraints (with freshly generated variables) for each potential model.
20:18:50 <hayesgm> @byorgey, thank you, I think that makes sense. I think I'm getting a bit confused on the best way to have a function recursively call itself building up a list of possible formulae, but I guess therein lies the fun of the project.
20:18:50 <lambdabot> Unknown command, try @list
20:19:28 <byorgey> yes, that does sound tricky
20:33:51 <dfeuer> Ping carter
20:35:42 <dfeuer> Anyone here really good at RULES?
20:39:41 <codygman> Given the subcommands example on https://haskell-lang.org/library/optparse-applicative, how would I extend it to support different types of "create" subcommands enabling commands like "create createType1 value"? In short, I think I want to know how to create subcommands of subcommands. For instance "aws s3 ls s3://address" would be multiple levels of subcommands.
20:49:31 <tsani> codygman: just keep nesting `command` with `subparser`
20:49:45 <tsani> I have a (ugly) example here: https://github.com/tsani/tpb/blob/master/src/tpb/Main.hs#L66
20:49:59 <lyxia> codygman: IMO it's easier to figure out from the types. subparser :: Mod CommandFields a -> Parser a, command :: _ -> ParserInfo a -> Mod CommandFields a, info :: Parser a -> _ -> ParserInfo a
20:50:37 <codygman> tsani: Thanks for the example. I'll take a look
20:50:55 <codygman> lyxia: That's what I tried to do first
20:51:56 <codygman> oh so any parser can eventually be turned into a Mod CommandFields a which can be turned into a Parser a
20:55:06 <codygman> lyxia: So if I want to make 2 types of create commands "createType1" and "createType2" I see that createCommand expects Mod CommandFields Command
20:57:00 <codygman> bottom down I can create a separate parser for each "createType1" and "createType2".  Then I can use info to turn each of those into "ParserInfo. Then I can use command to turn each into Mod CommandFields a. Then I can put those results in a block like "subcommand $ thing1 <> thing2"
20:57:07 <codygman> bottom up*
20:57:30 <codygman> http://lpaste.net/363936#line37
21:15:14 <mjrosenb> Is there a paper on writing both a parser and a pretty printer from a single specification?
21:15:55 <vaibhavsagar> mjrosenb: yes
21:16:38 <vaibhavsagar> I'm tempted to leave it at that :), but here is a link: http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf
21:16:52 <vaibhavsagar> there's also invertible-syntax on Hackage
21:16:56 <mjrosenb> danke.
21:17:19 <vaibhavsagar> you're very welcome, this is a topic that is extremely relevant to my interests
21:37:02 <woodson> can anyone help me with this http://lpaste.net/363937
21:37:22 <woodson> I am trying to define the FromJSON instance for my SObjectId type
21:37:54 <woodson> however, I keep on getting this *** Exception: /home/woodson/Code/Haskell/Haskforce/src/Haskforce/SForce/Common.hs:(55,5)-(58,35): Non-exhaustive patterns in function parseJSON
21:38:51 <woodson> it was working perfectly with the withText function, but I added another field to the data type SObject so I dont think that I can use withText unless it can accept multiple values
21:39:53 <lyxia> Use withObject instead of pattern matching on Objects
21:40:07 <woodson> I tried that too
21:41:05 <woodson> but I think that there is something that I am doing wrong with that function
21:41:24 <woodson> when one uses the withObject you must provide a string
21:41:52 <woodson> does that String represent the key of that nested object in the json?
21:42:23 <lyxia> woodson: you're looking up "attributes" twice
21:42:41 <lyxia> lines 57 and 85
21:43:12 <woodson> line 85 is not being used anymore
21:43:18 <woodson> thats why I am passing it x
21:43:32 <woodson> parseJSON x@(Object v)
21:44:15 <woodson> I want line 84 to have the whole json structure
21:44:36 <woodson> thats why I am not passing it the value from line 85 anymore but x
21:45:40 <Jack__> has anyone here tried installing diagrams using stack? Is it not on stackage?
21:46:15 <woodson> lyxia: man, I am getting confused with my own code
21:46:31 <woodson> I was referring to line 86
21:46:49 <woodson> but how is 85 affecting line 57?
21:58:24 <byorgey> Jack__: it is not currently in LTS-11. You can use LTS-10 for now.
22:15:11 <sl2c> Jack__: I think it's not in because of lens upper dependencies that will be resolved soon?
22:25:39 <woodson> when you have nested data type are we supposed to use withText in the definition of the parseJSON?
23:03:11 <robstr> Morning, I want to split my program in different modules, I create a directory `A` inside my stack project, did a `cabal init` told its a library, I added the package name to my stack file, but when trying to import stack complains that it cant find the package ..
23:07:32 <mjrosenb> is there a function like alter, but it will also return the value that was set?
23:07:45 <mjrosenb> (Data.Map.alter, that is)
23:10:32 <sclv> mjrosenb: alterF
23:10:35 <EvanR> isnt alterF... yeah
23:10:40 <EvanR> the thing everything else is based on
23:11:14 <mjrosenb> oh, so I just need to make my functor be (v,)
23:11:33 <EvanR> yeah
23:11:53 <mjrosenb> Maybe  (v,); I guess.
23:12:21 <mjrosenb> err, no... (Maybe v,)
23:12:23 <mjrosenb> there we go.
23:12:38 <EvanR> lambdabot should have a random functor generator
