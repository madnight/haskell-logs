00:00:34 <jle`> hey, F a b -> F b a -> F a a exists for vector spaces
00:01:11 <jle`> oh, i was just thinking of (.)
00:02:39 <jle`> oh, F a b -> F b a -> F a a is not actually antisymmetry
00:03:16 <jle`> not sure where i pulled that from
00:04:39 <jle`> vector spaces have sym :: F a b -> F b a, at least.
00:06:27 <ski> eacameron : "But the ask part: is `GADT a -> IO ()` different than `Some GADT -> IO ()`?" -- those are basically the same thing, because `(exists a. ..a..) -> ...' amounts to the same thing as `forall a. (..a.. -> ...)'
00:07:15 <jle`> üéø thanks, i was having trouble making a convincing argument
00:07:23 <jle`> ski ^
00:07:43 <ski> ok
00:08:12 * ski sometimes uses `length :: forall a. ([a] -> Int)' vs. `length :: (exists a. [a]) -> Int'
00:38:55 <MacSlow> bbl
01:10:22 <dminuoso> Is GHC development backed by major companies? I mean I know that Simon Marlow for example works for fb, but does he get paid to work on GHC?
01:13:11 <ongy> Microsoft Research invests (or invested?) in GHC, a few papers (with patches) about the features are from there
01:15:20 <dminuoso> ongy: What's their interest? Gaining insights for their development of F#?
01:16:44 <dminuoso> ongy: Ah are you talking about the work of Simon Peyton Jones?
01:16:51 <ongy> Probably. I have no insight into their company strategies.
01:17:16 <ongy> Not sure if all of them have been SPJ, but at least some, yes
01:17:33 <Ariakenom> Hasn't spj been at microsoft for a long time? He's written lots
01:19:01 <dminuoso> ongy: Oh interesting! https://www.microsoft.com/en-us/research/group/programming-principles-and-tools/
01:19:31 <dminuoso> ongy: Their contributions to Haskell are officially part of their work even. :)
01:20:29 <ongy> some of the things are hosted on the microsoft websites and they have the company name on some papers^^
01:22:14 <guest_> what is mean by this `Cipher a => a` ?
01:22:29 <dminuoso> guest_: It means `a` is a polymorphic value.
01:22:38 <dminuoso> guest_: Or rather, the thing that has that type.
01:22:45 <dminuoso> guest_: It's similar to this
01:22:47 <dminuoso> :t 5
01:22:49 <lambdabot> Num p => p
01:23:10 <dminuoso> The type has not been decided yet, the consumer can pick one (any type that has an instance of Cipher is valid)
01:23:16 <Ariakenom> Yeah SPJ has been there since '98 so that's like 100 papers, maybe
01:24:23 <dminuoso> > 5 :: Int
01:24:25 <dminuoso> > 5 :: Float
01:24:28 <lambdabot>  5
01:24:29 <lambdabot>  5.0
01:25:18 <Ariakenom> or
01:25:21 <Ariakenom> :t maxBound
01:25:23 <lambdabot> Bounded a => a
01:25:25 <cocreature> dminuoso: simon marlow also used to work for msr
01:25:32 <Ariakenom> > maxBound :: Float
01:25:35 <lambdabot>  error:
01:25:35 <lambdabot>      ‚Ä¢ No instance for (Bounded Float) arising from a use of ‚ÄòmaxBound‚Äô
01:25:35 <lambdabot>      ‚Ä¢ In the expression: maxBound :: Float
01:25:39 <Ariakenom> > maxBound :: Int
01:25:42 <lambdabot>  9223372036854775807
01:25:47 <Ariakenom> > maxBound :: Word8
01:25:50 <lambdabot>  255
01:26:11 <dminuoso> Or even..
01:26:12 <dminuoso> :t flip
01:26:14 <lambdabot> (a -> b -> c) -> b -> a -> c
01:26:36 <Ariakenom> Hm Float has Ord but not Bounded?
01:27:18 <dminuoso> Ariakenom: What would that produce?
01:27:20 <liste> Ariakenom: Float has infinities
01:27:37 <liste> technically an infinite number of them
01:27:48 <liste> > (1/0) == (1/0)
01:27:51 <lambdabot>  True
01:28:05 <liste> oh, so all +inf's are equal
01:28:06 <Ariakenom> infinities as values, though. larger|smaller than all others except Nan?
01:29:19 <dminuoso> Ariakenom: Also another problem is Float cannot represent all natural numbers accurately.
01:29:30 <Ariakenom> Why would that be a problem?
01:29:34 <guest_> how do i convert   Cipher cipher => CryptoFailable cipher  to  ` AES256` I am using  this library https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-Cipher-AES.html
01:29:50 <guest_> how to do this type convertion?
01:30:09 <dminuoso> Ariakenom: Ah nevermind.
01:30:43 <dminuoso> guest_: Since you have been dabbling with similar questions for weeks now, dont you think its time to pick up a haskell book and learn the language?
01:31:37 <Ariakenom> Float's are dumb. Haskell's take on Floats is dumb. At first glance changing nan to bottom would fix Ord and Bounded though
01:31:50 <dminuoso> Ariakenom: I was super confused when I learned that Float/Double had an Eq instance.
01:31:57 <dminuoso> I really did not expect that.
01:32:20 <dminuoso> (I mean not that its impossible to implement, just that it doesn't seem very useful)
01:32:58 <dminuoso> Ariakenom: also you couldnt change nan to bottom, since then it becomes impossible to test for `nan`
01:33:37 <Ariakenom> Is that a problem? Also what about catch?
01:34:05 <cocreature> catch requires that you‚Äôre in IO
01:34:16 <cocreature> you don‚Äôt really want to require IO just for a nan test
01:34:45 <guest_> dminuoso: is this book is fine http://learnyouahaskell.com/learnyouahaskell.pdf
01:35:18 <dminuoso> Ill defer that question to the channel.
01:37:20 <vaibhavsagar> guest_: I would recommend against it
01:38:02 <Ariakenom> Oh i actually thought there was some pure catch. I feel dirty :p
01:38:25 <cocreature> lyah is nice for a ‚Äúlook Haskell is pretty cool, you should check it out‚Äù introduction. it‚Äôs not particularly good for actually learning to write nontrivial Haskell programs
01:38:59 <[exa]> there should also be 'engineer yourself a haskell'
01:39:09 <Ariakenom> I'd say giving up nan tests would be worth it. Are they useful?
01:39:10 <dminuoso> [exa]: That exists..
01:39:15 <dminuoso> [exa]: http://dev.stephendiehl.com/fun/
01:39:17 <dminuoso> ;)
01:39:18 <cocreature> [exa]: stephen diehl started a ‚Äúwrite yourself a Haskell‚Äù but never finished it
01:39:45 <[exa]> oh I meant it the other way
01:39:58 <[exa]> like 'learn yourself a haskell' but for actual software engineering
01:40:01 <[exa]> bad name, sorry. :D
01:40:29 <dminuoso> [exa]: Oh I know what you meant, but given what you said I just couldnt resist.
01:40:36 <[exa]> yeah
01:41:16 <Ariakenom> Would it be super evil to turn nan into bottom but and have a nan test that's basically catch?
01:41:21 <[exa]> maybe 'haskell yourself an engineer'
01:41:57 <[exa]> Ariakenom: if you don't like NaNs, why not use Maybe?
01:42:06 <dminuoso> Ariakenom: `a = a` - please test whether this is NaN.
01:42:16 <dminuoso> In a pure fashion ontop.
01:42:57 <[exa]> btw I dislike treating NaN as a special value, it's a normal thing that you didn't completely want and should have avoided earlier
01:43:40 <Ariakenom> I want to avoid it because it means you cant have lawful Eq Ord Bounded
01:44:04 <Ariakenom> dminuoso, what do you mean?
01:44:09 <dminuoso> Ariakenom: Bottom is not just failure, it's also the value for non-halting programs. Without solving the halting problem you cannot possibly determine whether you have a `NaN` or a never halting computation
01:45:32 <[exa]> Ariakenom: well, many people have failed trying to solve that problem on many different programming levels
01:45:37 <Ariakenom> dminuoso, well I meant nan = throw NanException
01:45:39 <[exa]> Ariakenom: it's like with null
01:46:11 <dminuoso> Ariakenom: So now you need IO?
01:46:11 <[exa]> Ariakenom: btw NaNs _do_ throw exceptions, these are just silenced by most modern systems by default
01:46:51 <Ariakenom> :t throw
01:46:53 <lambdabot> Exception e => e -> a
01:47:57 <Ariakenom> [exa], what do you mean? This seems to cause no issue wrt language implementation
01:48:51 <dminuoso> Ariakenom: You couldnt use Float without IO anymore, since any computation could potentially crash your program.
01:50:27 <dminuoso> Though I guess... IEEE 754 allows for signalling NaNs..
01:50:52 <Ariakenom> dminuoso, ofc. im going for IEEE compatible nans
01:51:43 <dminuoso> Ariakenom: I wonder whether there is some `IO ()` to enable this in fact.
01:52:08 <[exa]> Ariakenom: it's similar as with integer division by zero, on some platforms it simply does interrupt by default
01:52:17 <Ariakenom> dminuoso, what about "you cant use Float instances because any usage could potentially corrupt any invariants"
01:53:03 <[exa]> ...you can safely state that with approximate numbers your program will run approximately right
01:53:27 <Ariakenom> [exa], yes but I can install a handler that continues. or if no interrupt, insert a test that throws.
01:54:19 <Ariakenom> you can safely state with approximate numbers that your program wont crash (and always be correct if not)
01:55:00 <kuribas> Is it correct that generic works well when the algorithm is inductive, but not when it's random access?
01:55:36 <kuribas> random access like a lens
02:01:17 <ertes-w> ello
02:03:10 <ertes-w> Ariakenom: don't take my pure NaNs away from me, please
02:03:19 <ertes-w> i don't want to use IO just to catch NaNs
02:03:47 <dminuoso> ertes-w: Doesn't IEEE 754 require both non-signalling as well as signalling NaN?
02:04:01 <ertes-w> dminuoso: i don't know what NaN signalling is
02:04:52 <dminuoso> ertes-w: quiet NaNs dont produce traps/exceptions (like in Haskell), while signalling NaNs produce traps/exceptions
02:05:08 <ertes-w> kuribas: i was trying to auto-generate lens labels earlier this week, and yes, their random-access nature made it quite complicated
02:05:45 <kuribas> ertes-w: and inefficient I presume?
02:05:48 <ertes-w> kuribas: i gave up when lyxia told me that i need to encode the path to the element in the type of my label
02:06:00 <kuribas> yeah
02:06:15 <ertes-w> kuribas: actually it was complicated *because* it wants to be efficient:  you can't count on any particular association of (:*:), because GHC will choose a tree-like shape
02:06:34 <ertes-w> if i could just use (:*:), say, right-recursively, it would have been very simple
02:06:38 <kuribas> ertes-w: generic-sop would help with that...
02:06:47 <ertes-w> dminuoso: i'm not sure how it's related
02:06:52 <Ariakenom> let nan = 0/0 in M.fromList [(nan,0),(nan,1)]
02:06:56 <Ariakenom> > let nan = 0/0 in M.fromList [(nan,0),(nan,1)]
02:06:59 <lambdabot>  fromList [(NaN,0),(NaN,1)]
02:07:09 <ertes-w> kuribas: i don't have any experience with that, and in the end i just gave up‚Ä¶  it wasn't worth the trouble
02:07:26 <ertes-w> kuribas: hand-written labels are much more efficient anyway, because there is no tree traversal
02:07:29 <kuribas> ertes-w: it translates it to a heterogenous list.
02:07:35 <ertes-w> ah
02:07:37 <Ariakenom> Gimme a crash over that pls
02:07:54 <kuribas> ertes-w: which makes it less complex, but doesn't solve the efficiency.
02:08:18 <ertes-w> kuribas: i would actually expect it to be even less efficient
02:08:40 <kuribas> ertes-w: yeah, because it has to flatten the tree first.
02:08:42 <ertes-w> if the field is at position 15, you'll have 15 levels of recursion
02:08:56 <kuribas> ah, also that
02:09:00 <ertes-w> with Generic you only have ~4
02:09:47 <ertes-w> i think Generic is a nice middle ground at the expense of making random access more complicated
02:10:10 <kuribas> it seems to be made more for the usecase of reductions (folds)
02:10:24 <kuribas> where it works fine, and is probably efficient.
02:11:00 <kuribas> like binary, hashable, ...
02:11:45 <ertes-w> reductions and construction
02:12:07 <kuribas> right
02:12:40 <ertes-w> but it's not really that‚Ä¶  indexing is also a reduction, but it wants to follow a certain path through the tree, and that path needs to be encoded
02:13:16 <ertes-w> otherwise you'll have to use dynamic information to decide where to stop
02:13:40 <ertes-w> the position of the field for a lens label is static information‚Ä¶  that's what makes it complicated
02:15:12 <ertes-w> example:  imagine you're writing a generic function to check whether a certain element exists in a product type, assuming that the fields are sorted
02:15:28 <ertes-w> elemOf 5 (Blah 1 2 4 5 7 9 11 12) = True
02:15:55 <ertes-w> this can be done easily with Generic, because the branch choice is dynamic
02:17:17 <kuribas> if they have the same type
02:17:35 <lseactuary> anyone used FDR4 before? is there a help channel for this tool? https://www.cs.ox.ac.uk/projects/fdr/manual/cspm/definitions.html
02:18:11 <kuribas> ertes-w: but what about elemOf 5 (Blah "2" 4 (Just 2))
02:18:45 <ertes-w> kuribas: "No instance for ‚Ä¶"
02:19:10 <kuribas> :t elemOf
02:19:12 <lambdabot> Eq a => Getting Any s a -> a -> s -> Bool
02:19:35 <phadej> :(
02:19:36 <phadej> :)
02:19:38 <ertes-w> it's hard to come up with names that aren't used somewhere in lens =)
02:20:07 <phadej> _Of is a convention in lens
02:20:21 <ertes-w> avoid any symbols‚Ä¶  even if you monkey-type on your keyboard, the result is probably somewhere in lens‚Ä¶  then avoid base names with suffixes‚Ä¶
02:20:40 <Gurkenglas> @let data Blah = Blah Int Int Int Int Int Int Int Int
02:20:42 <lambdabot>  Defined.
02:20:52 <Gurkenglas> > elemOf template 5 (Blah 1 2 4 5 7 9 11 12)
02:20:55 <kuribas> ertes-w: well take a function ElemOf' which maches only matching types.
02:20:56 <lambdabot>  error:
02:20:56 <lambdabot>      ‚Ä¢ No instance for (Data Blah) arising from a use of ‚Äòtemplate‚Äô
02:20:56 <lambdabot>      ‚Ä¢ In the first argument of ‚ÄòelemOf‚Äô, namely ‚Äòtemplate‚Äô
02:21:13 <Gurkenglas> Huh, I thought Data instances are derived automatically.
02:21:57 <Gurkenglas> > elemOf template (5 :: Int) (Blah2 1 2 4 5 7 9 11 12)
02:22:00 <lambdabot>  True
02:22:11 <ertes-w> Gurkenglas: Typeable is derived automatically
02:22:51 <TMA> ertes-w: concatenating s with a seven digit prime number shall be reasonably safe bet
02:24:09 <ertes-w> :t s7543049
02:24:11 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
02:25:03 <TMA> ertes-w: well, I have to be mistaken then :)
02:25:09 <ij> Is there a "stack ghci" equivalent for cabal? I'm in a nix shell now, so I don't want stack to download everything for me.
02:25:18 <dminuoso> ij: `ghci` ?
02:25:28 <ertes-w> ij: in a nix-shell all you need is ghci
02:25:54 <ertes-w> ij: (if the environment is generated from cabal2nix)
02:25:57 <ij> Hm, but it can't import my modules. (I even `cd'd to the `src' directory.)
02:26:02 <ij> ertes-w, It is.
02:26:14 <ertes-w> ij: did you use 'cabal2nix --shell'?
02:26:55 <ij> I modified its output, but yeah.
02:27:47 <ertes-w> ij: for cabal operations you should use your Setup.hs, but unfortunately cabal has no 'cabal repl' equivalent, so you'll have to set up the search path yourself
02:28:17 <vaibhavsagar> ij: runhaskell Setup.hs repl
02:28:24 <ertes-w> ij: however, note that cabal-install 2.0 has nix integration, which inverts the roles of cabal and nix:  if you enable it, cabal will do the plumbing for you
02:28:55 <ij> cabal-install version 2.0.0.1 ‚Üê‚Üê‚Üê
02:29:04 <ertes-w> ij: https://www.haskell.org/cabal/users-guide/nix-integration.html
02:29:34 <ertes-w> oh, cabal has 'repl' now
02:29:37 <ertes-w> i didn't even notice =)
02:29:44 <hmm322> how do you add development only dependencies on a stack project?
02:29:45 <ij> BOYYY! It works!
02:29:52 <ij> Amazing.
02:33:47 <dminuoso> hmm322: What are you trying to accomplish?
02:36:27 <kuribas> anyone know why I cannot install haddock-api on my laptop?  (ghc-8.2.2)
02:36:50 <kuribas> it checks only older versions.
02:37:27 <phadej> 2.19.0.1 has base >=4.11
02:37:53 <kuribas> but 2.18 should work?
02:38:03 <phadej> yeah
02:38:04 <phadej> https://matrix.hackage.haskell.org/package/haddock-api
02:38:46 <hmm322> Sorry a beginner here. I am under the impression that stack install packages based on package.yaml, if so, let's say I want to use a certain version of ghc to install ghcjs for that project and I only needed ghcjs to compile
02:38:47 <kuribas> phadej: that gives me: could not resolve dependencies
02:38:57 <kuribas> phadej: I did update cabal
02:39:26 <hmm322> To do compilation*
02:39:59 <cocreature> kuribas: what‚Äôs the full error?
02:40:56 <kuribas> cabal version 1.24...  oh I see the problem
02:40:59 <ij> Can you redo constructors for "data DataTypes"? I want to add another field, but I don't want to change other code that uses the old simple constructor.
02:41:56 <ertes-w> ij: you can use a wrapper type with more fields
02:42:32 <kuribas> phadej, cocreature seems I am using an old version of cabal...
02:42:48 <ertes-w> ij: data WithName a = WithName { name :: Text, value :: a }  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
02:47:05 * Digit sits pondering, on a whim, a list of primes, and wonders what ways Haskell might acheive creation of such a list, imagining Haskell enthusiasts would likely either have insights, or know of this being well trodden ground
02:47:21 * Digit skims https://wiki.haskell.org/Prime_numbers
02:48:20 <Ariakenom> > [2,7,13]
02:48:22 <lambdabot>  [2,7,13]
02:48:35 <ij> ertes-w, I can probably make a "type Old = New; New a b = Old a b 3
02:50:49 <hmm322> [1..4]
02:51:40 <ertes-w> ij: yeah, you could do that using pattern synonyms‚Ä¶  however, that sounds like the kind of patch-work ADTs are good at avoiding
02:51:50 <ertes-w> ij: doing that will make your code much less transparent
02:52:13 <dminuoso> ertes-w: Is deriving Traversable safe?
02:52:21 <ij> I've no idea how ADTs could help me here.
02:52:24 <dminuoso> By that I mean, will it necessarily produce a correct implementation
02:52:29 <Ariakenom> hmm322, did you mean to add a ">" for lambdabot?
02:52:51 <ertes-w> dminuoso: yes (if it doesn't know how, you'll get an error)
02:52:59 <ertes-w> ij: i showed you
02:53:00 <ski> > sieve [2,3 ..]  -- Digit, like this ?
02:53:04 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
02:53:19 <ertes-w> ij: for a deeper understanding of the idea, check out the paper "data types a la carte"
02:54:03 <ertes-w> someone who knows will surely tell you the author‚Ä¶  sorry for being disrespectful
02:54:17 <ij> Ok, got it now. I just didn't see what I wanted to see the first time I read it.
02:54:30 <ij> So I didn't read it right.
02:54:44 <hmm322> Ariakenom, you're right!
02:55:42 <Digit> ski: oh that's very cool.  just the type of stunning impressive less-verbose-than-imagined-possible i've come to expect from Haskell.
02:56:04 <ski> Digit : how to define `sieve' is an exercise
02:57:03 <ij> ertes-w, But then I've to drag WithName everywhere I used "value :: a".
02:57:15 <ski> Digit : another way would be to define `primes = filter isPrime [2 ..]', and then define `isPrime' in terms of `primes'
02:58:15 <ski> Digit : yet another way is to define `composites' as all the possible products of `primes' and `[2 ..]', and then define `primes' as the difference between `composites' and `[2 ..]'
02:58:35 <ertes-w> ij: i'd say just go with it
02:58:40 * Digit starts wondering about twin primes now too
02:58:52 <ski> there's probably more ways
02:58:56 <ertes-w> ij: note that WithName is a Functor, Foldable and Traversable, which makes many things easier
03:09:48 <ventonegro> Does anybody have a link to SPJ giving an introduction to lenses on YouTube?
03:16:39 <ocramz> hullo!
03:17:25 <ocramz> I was doing a little survey on benchmarking libraries
03:18:13 <ocramz> I like tasty-golden, and I was wondering whether anyone knows of a criterion-golden mashup
03:18:42 <ocramz> as in, criterion measurements would be stored as references to track regressions in subsequent version
03:19:05 <ocramz> does anyone here know whether this has been done already? can't find anything like this on hackage
03:25:13 <Ariakenom> > nan
03:25:16 <lambdabot>  error:
03:25:16 <lambdabot>      ‚Ä¢ Variable not in scope: nan
03:25:16 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
03:27:25 <muesli4> Hi, in the examples of optparse-applicative I see that printing help for sub commands is possible but I fail to find the option to enable it. Any idea what I'm doing wrong? (https://ideone.com/eH2nxI)
03:27:59 <muesli4> And by printing help I mean printing all subcommands (at least an overview) in the default help.
03:28:25 <phadej> muesli4: info (pure Update <**> helper)
03:28:42 <phadej> then `your-prog update --help` will work
03:29:25 <phadej> same for top-level, info (progArgsP <**> helper) (progDesc desc)
03:29:35 <muesli4> phadej: What's the deal with that helper?
03:30:10 <phadej> muesli4: http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:helper
03:30:36 <muesli4> phadej: I read that but I fail to understand it. :)
03:31:08 <phadej> muesli4: it's somewhat the same as (parser <|> option ... (long "--help" ...)0
03:31:28 <phadej> the "--help" is not magic in any sense
03:31:46 <phadej> you can make similar flags using the library your self
03:33:03 <phadej> (e.g. using http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:infoOption)
03:33:42 <muesli4> phadej: It still doesn't display the overview instead it says at the top of the help page: "Missing: CMD"
03:34:12 <phadej> muesli4: you have to add helper to the progArgsP too
03:35:00 <phadej> I don't remember how to make optparse-applicative print out help if parse fails (and not because of --help)
03:35:12 <ij> Does nixos have a haskell-ide-engine package?
03:35:37 <phadej> so `my-prog` outputs short parse error, where `my-prog --help` would output help message
03:35:41 <Peter_Storm> what's the best library to use, if I want to write a webapp?
03:36:01 <phadej> I'd say that reasonable, as dumping help all the time could be annoying, YMMV
03:36:05 <muesli4> phadej: Well it does print help if parse fails with `execParser`. But still it doesn't print documentation about my subcommands. :/
03:36:26 <muesli4> phadej: https://ideone.com/0qSojz
03:37:02 <muesli4> phadej: I just put it everywhere since I don't understand what it does (which is usually very bad).
03:37:19 <phadej> muesli4: `progDesc "..." <> fullDesc`
03:38:45 <muesli4> phadej: Nope.
03:40:01 <maheryhaja> I everyone I am new to Haskell, I am an Android Programmer, where should I start to learn haskell?
03:41:07 <dminuoso> maheryhaja: Hello. A book frequently recommended these days is http://haskellbook.com/
03:41:35 <Cale> http://www.cs.nott.ac.uk/~pszgmh/pih.html is a good book
03:41:46 <dminuoso> maheryhaja: A different and shorter resource is the gentle introduction: https://www.haskell.org/tutorial/ - that's how I learned Haskell.
03:41:57 <Cale> if you want an online course, there's http://www.cis.upenn.edu/~cis194/spring13/
03:42:06 <Cale> which has lectures and exercises
03:44:02 <phadej> muesli4: https://gist.github.com/phadej/fc6a44adabe6c3e41ae05f032521c009
03:44:07 <phadej> what works wrong there?
03:44:54 <ski> dminuoso : had you looked at any other functional language, before looking at the "Gentle" tutorial ?
03:49:40 <maheryhaja> I am familiar with Rx library and I use some functionnal side of Java8 but I am clearly a noob in functionnal programming since there are so much different concepts
03:50:36 <Cale> maheryhaja: Also, you should feel free to ask questions here about anything you find confusing.
03:50:41 <ski> maheryhaja : if you want exercises to try, you could look at CIS194
03:50:45 <ski> @where CIS194
03:50:46 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
03:51:03 <Cale> (I already got that one ;)
03:51:08 <dminuoso> ski: Well I did start out with React a year earlier, which led me on the functional path. After a while I learned about ramda. Im not sure whether that really counts.
03:51:32 <ski> (don't get me wrong, i liked it. but it's perhaps not the best resource if you're new to functional programming)
03:51:44 * ski doesn't know about React or ramda
03:52:20 <dminuoso> ski: React is a pseudo-discrete-FRP library for JavaScript, and ramda is basically Prelude ported to JavaScript if you want.
03:53:45 <ski> maheryhaja : if you're new to functional programming, but have done some imperative programming before, perhaps several languages, then you should be aware of that learning a new programming paradigm, like functional programming, is not like learning yet another language being a variation of the same
03:53:50 <ski> maheryhaja : it's more like learning to program all over from scratch again. of course some things do carry over, but it's better to not compare too much to what you know (you'll have to unlearn stuff), until you have more under your belt
03:53:58 <ski> ok, dminuoso
03:55:22 * ski idly wonders whether maheryhaja has seen functional stuff in Java mentioned in the book "Java Precisely", by Peter Sestoft
03:55:38 <ventonegro> Ah, it was not on YouTube
03:55:39 <maheryhaja> sky : I have heard things like learning basketball with left hand, hihi. However, I really want to learn it
03:55:44 <ventonegro> https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
03:55:44 <ski> (Peter Sestoft happens to be one of the implementors of Moscow ML, fwiw)
03:55:47 <dminuoso> maheryhaja: How extensive is your Rx experience?
03:56:21 <ski> Cale, sorry, missed that
03:58:09 <ski> @quote brickbat
03:58:09 <lambdabot> shapr says: [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
03:58:13 <ski> @quote piranha
03:58:13 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
03:58:35 <ski> maheryhaja : then go ahead ! :)
03:59:11 <dminuoso> ski: I just loved the gentle introduction for it's sharp and accurate terminology. I didn't want a book that used phrases such as "you could think of this as ...", but instead assumed I had the Haskell 98 report printed out on my disk while reading the introduction.
03:59:26 * ski nods
03:59:49 <ski> (just be aware that not all people like that style)
04:02:10 <phadej> "gentle" is relative to the audience
04:02:57 <ski> @quote gentlemen
04:02:57 <lambdabot> PenguinOfDoom says: Being enlightened gentlemen, we split all programming languages into two groups, sucks and doesn't-suck and put all of them into the first group.
04:03:17 <phadej> it even starts with
04:03:17 <phadej> > Our purpose in writing this tutorial is not to teach programming, nor even to teach functional
04:03:21 <phadej> programming
04:03:21 <lambdabot>  <hint>:1:13: error: parse error on input ‚Äòin‚Äô
04:03:27 <phadej> lambdabot: silly you
04:03:55 <phadej> Our goal is to provide a gentle introduction to Haskell
04:03:55 <phadej> for someone who has experience with at least one other language, preferably a functional language
04:03:59 <lambdabot> no, you
04:04:22 <phadej> and I'm 100% sure, Hudak et. al didn't consider JS as a functional language ;)
04:04:46 <dysfun> i heard js was practically lisp ;)
04:04:48 <dminuoso> phadej: Well, I've written purely functional JS code before I hopped into Haskell - so I had a pretty good idea.
04:04:56 <dminuoso> (And I was hooked on the idea already)
04:05:20 <dminuoso> (Well almost purely)
04:05:55 <dminuoso> And I have to admit, I never bothered to read the introduction - felt that was a waste of time, since I wanted to learn Haskell. :P
04:05:55 <dysfun> whatever you do, it's like having ExceptT * on all your code
04:05:57 <phadej> dminuoso: yes, I argue that people have to adjust their expectations when they say that introduction isn't gentle. Tutorial mentions as the first sentences of introduction the expected level for the audience
04:07:07 <phadej> even gives a pointers to bridge the gap of knowledge
04:07:09 <dminuoso> phadej: What can I say - I personally couldn't bear haskellbook based on the sample.
04:07:16 <dminuoso> It felt so.. watery.
04:07:38 <phadej> dminuoso: different target group
04:07:48 <phadej> if you try to make everyone happy, you won't make anyone :)
04:07:58 <dminuoso> phadej: That explains why Im having such a difficult time with TaPL.
04:08:02 <dminuoso> ;)
04:08:19 <ski> dminuoso : too slow ?
04:08:54 <phadej> (teaching haskell and teaching fp at the same time is difficult task, but it's chicken-egg problem)
04:09:46 <dminuoso> ski: My mind is not properly shaped into this deductive/inductive thinking that the book assumes. For example Im having some real problems fully understanding all the proofs revolving around evaluation relations.
04:09:57 <dminuoso> The book seems to assume the reader has a good foundation already.
04:10:27 * ski nods
04:11:04 <dminuoso> ski: You wouldn't happen to know some adequate reading material that could prepare me for TaPL, would you? :)
04:11:06 <ski> it does assume some kind of basic math experience with proofs, i suppose
04:11:25 <dminuoso> Yeah, and I do not have any mathematical background.
04:11:28 <ski> well .. i like to point people to
04:11:36 <ski> @where polymorphic-type-inference
04:11:36 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
04:11:40 <ski> @where on-understanding
04:11:40 <lambdabot> "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
04:11:53 <phadej> dminuoso: if you have time, watch OPLSS lectures
04:12:13 <phadej> on proof/type/category theories
04:12:16 <ski> at least some parts of those should hopefully be accessible
04:12:35 * ski started learning from those, amongst other papers
04:12:35 <phadej> they will somewhat hammer enough mathematics into you
04:12:47 <phadej> especially if you are a listener, not a reader
04:14:14 <phadej> I personally recommend https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html versions
04:14:17 <dminuoso> ski: Oh I was rather talking about reading material on the mathematical background that TaPL requires.
04:16:33 <phadej> (awodey, harper and pfenning lectures)
04:16:59 <phadej> IIRC they'll show you enough of lambda-calculus that beginning of TaPL would feel easy :)
04:17:12 <ski> dminuoso : oh. anything which teaches proofs should help, i think. like simple combinatorics (like factorials, permutations and combinations, &c.), simple number theory (divisibility,primes,factorization), linear algebra (vectors and matrices, linear transformations, vector spaces, bases), basic "abstract algebra" (like groups and perhaps rings)
04:18:30 <ski> even analysis (although imho many intros to that aren't that good) (limits, continuity, derivatives, integrals)
04:18:41 <DavidLopez> Hi guys, can someone explain to me what this means: (<$>) ::
04:18:42 <DavidLopez>     (a -> b)
04:18:42 <DavidLopez>     -> ((->) t a)
04:18:42 <DavidLopez>     -> ((->) t b)
04:18:54 <DavidLopez> what its the ((->) t a)
04:19:02 <cocreature> DavidLopez: ((->) t a) is just another notation for t -> a
04:19:02 <ski> DavidLopez : that's the same as `(<$>) :: (a -> b) -> (t -> a) -> (t -> b)'
04:19:05 <dminuoso> ski: Alright.. next week my book "The Formal Semantics of Programming Languages: An Introduction" should arrive, Im hoping that will be a good buy :)
04:19:09 <cocreature> just like (+) 1 2 is the same as 1 + 2
04:19:21 <dminuoso> ski: Supposedly it covers induction proofs rather well.
04:19:22 <ski> dminuoso : haven't seen it
04:19:34 <ski> dminuoso : yea, induction is something what you want covered
04:19:48 <DavidLopez> hmm so what is (->) supposed to be in haskell
04:20:04 <DavidLopez> is it called "reader"
04:20:06 <dminuoso> DavidLopez: a type (constructor)
04:20:06 <ski> `(->)' is the type constructor for function types
04:20:13 <cocreature> DavidLopez: "a -> b" is the type of functions that take an argument of type "a" and return something of type "b"
04:20:21 <DavidLopez> ohhhh
04:20:21 <dminuoso> DavidLopez: Reader is just a type synonym (so to speak) for ->
04:20:36 <ski> `(->) Integer Bool', which is sugared into `Integer -> Bool', using the infix operator notation for `->', is the type of functions from `Integer's to `Bool'eans
04:21:20 * ski prefers referring to `Reader rho' (and `(rho ->)') as "environment", when talking about it colloquially
04:21:47 <dminuoso> DavidLopez: And just for a future reference, `Arrow` generalizes (->)
04:22:19 <ski> (many people would prefer referring to `Category' rather than `Arrow', i think)
04:22:22 <reactormonk1> We've got a bug where sharing between two variables (generated by hedgehog) happens, where it should not - if we make the generation in the do-block strict, the bug goes away. How do we debug that / submit a compiler bug?
04:23:58 <dminuoso> :k (->)
04:24:01 <lambdabot> TYPE q -> TYPE r -> *
04:24:08 <reactormonk> Hedgehog shows the two values to be different, but the SQL layer reports them to be the same.
04:24:33 <DavidLopez> okay i understand that it is a type constructor now... except i'm so confused about the reader thing
04:24:34 <dminuoso> DavidLopez: ^- for the sake of simplicity lets assume this reads `* -> * -> *`
04:24:44 <dminuoso> DavidLopez: So it's a type constructor that takes two types, and the result is a type.
04:25:15 <cocreature> reactormonk: that sounds more like the SQL layer and the Haskell layer don‚Äôt agree on equality than a compiler bug tbh
04:25:17 <DavidLopez> dminuoso yep! thanks i get that :)
04:25:40 <reactormonk> cocreature, No, the haskell struct passed to the sql layer is the same both times.
04:26:03 <ski> (levity strikes again)
04:26:18 <dminuoso> DavidLopez: Think of `Reader` as just a newtype for (->)
04:26:29 <dminuoso> DavidLopez: Which should tell you why `Reader` on its own is fairly silly.
04:27:49 <cocreature> reactormonk: maybe start by turning off optimizations to see if the bug is also present at -O0. if it is present at -O0, then I‚Äôd start searching the bug in your code since I don‚Äôt think I‚Äôve ever seen a misscompilation at O0 in ghc. otherwise try to isolate it. if you want to submit a bugreport, you usually have to try to eliminate all dependencies for someone to take a look at it
04:28:08 <DavidLopez> ohh only reason why i mentioned reader is because that exercise i'm doing says "Maps a function on the reader ((->) t) functor."
04:28:58 <phadej> @src Reader
04:28:59 <lambdabot> type Reader r = ReaderT r Identity
04:28:59 <lambdabot> --OR
04:28:59 <lambdabot> data Reader r a = Reader { runReader :: r -> a }
04:29:25 <dminuoso> data Reader r a = Reader { runReader :: (->) r a }
04:29:39 <dminuoso> Really is just a newtype wrapper =)
04:29:53 <DavidLopez> lol i see thanks!
04:30:19 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
04:30:22 <lambdabot>  ("hello","olleh","HELLO")
04:30:42 <Cale> DavidLopez: ^^ I find it helps to have an example of what it does :)
04:30:57 * ski would call it "environment functor", if anything
04:31:22 <rogerson> Have a question
04:31:28 <ski> Have an answer
04:31:38 <dminuoso> DavidLopez: Oh and by the way: That notion that `(->) a` is a functor, where fmap = (.)
04:31:40 <rogerson> Can shared server on hostgator run red5 and Java
04:31:50 <dminuoso> DavidLopez: That's the easiest way to understand combinators such as `(.) . (.)`
04:31:53 <cocreature> rogerson: that doesn‚Äôt sound like a Haskell question
04:32:05 <Cale> rogerson: This is #haskell btw, you might have wanted a different channel?
04:32:11 <ski> (or Haskell-related question)
04:32:14 <rogerson> What's haskell
04:32:18 <robstr_> ¬≤:S
04:32:21 <ski> a programming language
04:33:04 <rogerson> Is their a channel anyone would know to ask a  question like mine? I'm new to irc
04:33:20 <ski> depends on the general topic of your question
04:33:39 <rogerson> Red5 if it can run on a hostgator shared server
04:34:01 <ski> perhaps you could try joining the channel ##java, since you mentioned Java ?
04:34:11 <rogerson> Ok cool
04:34:13 <rogerson> Ty
04:34:29 <Cale> Or maybe try hostgator customer support?
04:34:33 <dminuoso> DavidLopez: There's also a different notion of `(->) a` being a Functor - namely you can think of functions as containers indexed by `a`, where `fmap` allows you to change the contents of that container.
04:34:34 <ski> rogerson : there appears to be a channel #red5 as well
04:35:04 <rogerson> (ski) you da man
04:35:19 <alowaniak> I'm relatively sure ##java isn't going to like such a question, it's mainly for the programming language not infrastructure kind of things. But depends on who's on
04:35:20 <rogerson> How do you pm lol
04:35:32 <ski> /msg rogerson like this
04:36:00 <ski> alowaniak : well, perhaps they could suggest a more appropriate channel, at least ..
04:36:07 <dminuoso> DavidLopez: The Store Functor/Comonad for example uses that idea, and imbues that Functor with a "current position"
04:36:27 <rogerson> Keeps saying security system breaches when I type /msg ski message
04:36:35 <ski> dminuoso : how's that different ?
04:36:49 <ski> rogerson : that's normal
04:39:13 <geekosaur> rogerson, if you're not registered with nickserv, /msg will be restricted (an antispam measure). and by default most users's umodes reject /msg from unregistered users
04:39:13 <dminuoso> ski: Well its only differences in the perspective. Reader seems to have its focus on "a value thats merely missing an argument", where the Monad instance tries to talk about dependency injection. Store otoh rather models highly generalized containers.
04:39:17 <DavidLopez> thanks dminuoso!
04:39:31 <ski> (geekosaur : not mine, though)
04:40:16 <DavidLopez> im confused about the example you gave me Cale
04:40:35 <Cale> It uses the monad instance for (->) String
04:40:35 <ski> hm, "dependency injection" ?
04:40:36 <DavidLopez> is <- the same as ->
04:40:38 <DavidLopez> huuh
04:40:40 <Cale> no
04:40:45 <Cale> <- is part of the do-notation
04:40:46 * ski . o O ( "dependency inversion" )
04:40:54 <Cale> I'm assuming here that you've used a couple of other monads
04:40:59 <dminuoso> ski: Heh. That's interesting.
04:41:05 <Cale> If not, this isn't the best example to start with, probably
04:41:28 <ski> i suppose by "dependency injection" you mean what i mean by "environment" ?
04:41:35 <dminuoso> ski: Yeah.
04:41:50 <ski> (as in "environment variables", e.g.)
04:41:59 <DavidLopez> ohhhh
04:42:13 <DavidLopez> yeah i have used some monads
04:42:14 <DavidLopez> cool
04:42:49 <dminuoso> ski: Functionally there's no real difference between `(->) a` as an `indexable container` or `a value dependent on an environment` - it's just looking at the same thing from different use cases.
04:43:47 <ski> granted
04:44:51 <dminuoso> ski: But I was fairly stunned by your remark, calling this dependency inversion rather than dependency injection.
04:45:27 <dminuoso> I was looking for a term that captured a thought that was lingering in my head for a while, an you have just nailed it.
04:45:55 <maheryhaja> #madagascar
04:47:24 <DavidLopez> in an unrelated question, anyone knows of an open source project where i can see haskell being used for frontend dev?
04:47:44 <muesli4> phadej: It works now (and it seems I only have to use the helper at the top-most parser. Thanks for your help!
04:48:19 <ski> dminuoso : nah, that's just a random association
04:48:33 <ski> dminuoso : dependency inversion would be more like CPS
04:49:13 <ski> (it's just that i'm not really familiar with the term "dependency injection", so "dependency inversion" was what it made me think of)
04:50:36 <Cale> dependency injection is just a weird term that OO people use for functions
04:50:51 <ski> i see
04:50:53 <Cale> among all the others that they use for functions
04:50:56 <Cale> lol
04:51:39 <Ariakenom> Cale:  :burn:
04:52:02 * ski . o O ( "Oh my, functions again!" <https://fsharpforfunandprofit.com/fppatterns/> )
04:55:14 <Ariakenom> a lot of stuff in that talk but maybe this https://image.slidesharecdn.com/4dtde3kcsjauxwehn5is-signature-f7b7b1205140b150582d7167997d2edb6513b4debf4e71a12579bc4e1d04d273-poli-141204181200-conversion-gate01/95/functional-programming-patterns-ndc-london-2014-15-638.jpg?cb=1421779299
04:55:38 <dminuoso> Cale: Yeah. I stumbled over an SO post by ertes-w who pointed out the same exact thing. That revelation was the beginning of understanding how "design patterns" are mostly just shoehorning abstractions into OOP.
05:00:40 <rogerson> Anyone in a Java channel they could recommend or invite me to
05:01:03 <dminuoso> rogerson: No, but we would be happy to recommend a Haskell book to you.
05:03:38 * ski . o O ( <https://stackoverflow.com/questions/327955/does-functional-programming-replace-gof-design-patterns> )
05:04:42 <liste> rogerson: ##java is open for all registered users
05:04:55 <ertes-w> dminuoso: by me?  that must have been years ago
05:05:37 <ertes-w> dminuoso: but yeah, that sounds like me =)
05:09:01 <dminuoso> ertes-w: https://stackoverflow.com/a/14329487 ;)
05:13:28 <ertes-w> "See how easy this is? At some point this makes you realize how much easier your life will be, when you just forget all the nonsense that OO has taught you."
05:13:46 <ertes-w> oh yeah, that's definitely me =)
05:14:52 <dminuoso> ertes-w: When I read that, I didn't even notice that it was you. It wasn't until I showed that article to a friend that the name appeared, and I thought to myself "Well.. that name looks familiar"
05:15:55 <liste> hackage down for others too?
05:15:59 * liste gets 503 in https://hackage.haskell.org/package/hedgehog
05:16:20 <dadabidet> what's the most popular webserver for haskell?
05:16:36 <phenoble> Yes, hackage down for me too
05:17:26 <ski> liste : that link worked a couple of minutes ago, for me
05:17:42 <ertes-w> dadabidet: i know of three:  happstack, snap-server, wai
05:17:54 <liste> dadabidet: warp
05:17:56 <ertes-w> dadabidet: many web frameworks are built on top of wai
05:18:03 <liste> dadabidet: warp is a web server for wai
05:18:11 <ertes-w> err, yes‚Ä¶  wai is a web server model, and warp is an implementation
05:18:26 <dadabidet> whats wai?
05:18:28 <reactormonk> cocreature, ... the bug disappeared after a full recompilation. Whut.
05:18:40 <ertes-w> dadabidet: Web Application Interface‚Ä¶  an abstraction over web servers
05:18:55 <ertes-w> dadabidet: wai lets you write an application that will work with warp, FastCGI, etc.
05:19:13 <ocramz_> Hackage is down ?!
05:19:30 <ocramz_> I get a 503
05:19:40 <ertes-w> isn't hackage hosted on a CDN these days?
05:22:04 <Boarders_> I need to start building documentation locally :(
05:23:31 <infinisil> that's why i like my man pages..
05:24:22 <Axman6> liste: yeah hackage seems to be having problems at the moment
05:25:30 <ertes-w> actually i believe haddock has quite a few targets
05:25:59 <ertes-w> hmm, no, i seem to be wrong
05:26:03 <Axman6> dadabidet: wai is roughly equivalent to python's WSGI or Ruby's Rack. Warp is a (very fast) web server which provides a server for applications which use wai
05:26:13 <ertes-w> it would be nice, if haddock had a texinfo target
05:26:29 <ertes-w> then i could easily integrate haskell docs into emacs
05:26:42 <yushyin> ertes-w: yes texinfo would be so nice
05:27:49 <Axman6> ertes-w: re CDN, sort of, by the looks of it - if the backend server is returning bad responses then it can't do much if it doesn't have the data cached, and it probably doesn't make much sense to cache all of hackage on a CDN all the time (many CDNs will remove infrequently accessed resources)
05:29:24 <saksham> What do people think of stackage? I find it to be faster than hackage (also looks better).
05:29:42 <saksham> I never see it mentioned here though, which is why I'm asking.
05:30:31 <cocreature> saksham: stackage only mirrors a subset of the packages on hackage
05:31:24 <saksham> Oh. I've actually found different packages on them, under the same name. Are you sure of that?
05:31:37 <dminuoso> Axman6: Is WAI anything like Elixirs Plug?
05:31:47 <saksham> For instance, the concurrent-extra packages are different on hackage and stackage.
05:32:13 <liste> saksham: different how? are you sure you're comparing the same version?
05:32:34 <cocreature> yeah you‚Äôre probably looking at different versions
05:33:19 <ertes-w> saksham: stackage aims to provide curated package sets that are known to work well together‚Ä¶  that's why you might find version differences
05:33:19 <saksham> I thought so too. But the packages didn't even have the same description.
05:33:46 <cocreature> descriptions can change with versions too
05:33:53 <ertes-w> saksham: descriptions can change between versions‚Ä¶  a "version" is really just a completely different package
05:34:09 <Axman6> dminuoso: maybe, Plug looks a little more high level. Wai is basically functions that look like Request -> IO Response (it's a smidge more complicated than that but not much more)
05:34:43 <ertes-w> WAI is basically:  Request -> Codensity IO Response
05:34:44 <ertes-w> =)
05:34:58 <saksham> I understand that. It's just, they were no way similar. But right, it may have changed at some point in time.
05:35:02 <ertes-w> (that allows you to do cleanup work *after* the response is sent)
05:35:07 <Axman6> where Request is a pre-parsed HTTP request (everything before the body) and a way to read the rest of the request body
05:35:29 <cocreature> saksham: they might also be presented slightly differently. e.g. hackage shows README.md files at the bottom while stackage shows them at the top iirc
05:35:32 <dminuoso> Axman6: Ah actually the other way around then, since plugs are highly composable.
05:36:16 <ertes-w> dminuoso: composition is not something WAI deals with‚Ä¶  that's the web framework's job
05:36:43 <Axman6> Requests have things like the URL included, so you can do routing
05:36:51 <ertes-w> dminuoso: check out scotty, a simple "sinatra-like" (if that helps) framework built on top of WAI
05:37:18 <dminuoso> ertes-w: Hah I will when hackage works again.
05:37:26 <Axman6> dminuoso: you should try Data61's intermediate FP course, it introduces wai and then some abstractions over it
05:37:31 <ertes-w> dminuoso: nix works =)
05:46:11 <DavidLopez> Hey guys, I am doing this exercise in which i'm supposed to implement this "Anonymous map. Maps a constant value on a functor." I got it working with this (<$) a functor = (<$>) (const a) functor. However, the solution does it this way: (<$) = <$> . const. I don't understand how this works ?????
05:46:20 <Boarders_> does anyone know if there is a standard function containsList :: forall a. (Eq a) => [a] -> [a] -> Bool, which is true in case each of the elements in the first list is contained in the second list
05:46:41 <ski> DavidLopez : that's the same thing
05:46:46 <ski> @src (.)
05:46:47 <lambdabot> (f . g) x = f (g x)
05:47:03 <ski>   (<$) = (<$>) . const
05:47:12 <ski> by function extensionality, is the same as
05:47:23 <ski>   (<$) a = ((<$>) . const) a
05:47:25 <srk> Boarders_: set difference might work
05:47:33 <ski> which, by the definition of `(.)', is the same as
05:47:42 <ski>   (<$) a = (<$>) (const a)
05:48:45 <ski> srk : only if there's no duplicates
05:49:35 <srk> ski: yeah, that's why I've added 'might' :)
05:49:57 <cocreature> :t \xs ys -> all (`elem` ys) xs -- Boarders_
05:50:00 <lambdabot> (Eq a, Foldable t2, Foldable t1) => t1 a -> t2 a -> Bool
05:50:59 <ski> srk : *nod*
05:52:07 <dexterfoo> is hackage down?
05:52:11 <dminuoso> DavidLopez: Generally you can remember: f a = g (h x) = (g . h) x
05:52:13 <cocreature> dexterfoo: yes
05:52:53 <dminuoso> DavidLopez: Oops, I slipped a typo in there: f x = g (h x) = (g . h) x; and by eta reduction: f = g . h
05:53:27 <ski> (s/eta reduction/function extensionality/)
05:54:18 <DavidLopez> i might be more confused about how the parameters are "given" to those functions? like which function get what parameters in "<$> . const" hahaha
05:54:33 <dminuoso> DavidLopez: you dont have to "give"
05:54:55 <dminuoso> ski: Can you elaborate on that? I mean this is an Œ∑-conversion, no?
05:55:13 <ski> dminuoso : no, eta-conversion is `f = \x -> f x'
05:55:28 <ski> function extensionality is `(forall x. f x = g x) => f = g'
05:55:36 <ski> they're closely related, but not the same property
05:56:03 <guessWho> any recommendations for a logging library for haskell which is more geared towards multi threaded programming ??
05:56:16 <dminuoso> ski: Uhh.. what is the distinction?
05:56:38 <ski> one is about introducing/eliminating a lambda expression
05:57:12 <ski> the other is about having a universally quantified equation, both sides ending with the quantified variable (which shouldn't otherwise occur in the equation)
05:57:40 <ski> you can prove one property, by using the other, and vice versa
05:57:49 <dminuoso> so what's the difference between `f x = T` and `f = \x -> T` ?
05:57:51 <ski> (also using beta-conversion)
05:58:05 <dminuoso> (I mean any subtle Haskell semantics aside)
05:58:18 <ski> dminuoso : the equivalence of those could sometimes be known as "(function) comprehension"
05:59:10 <ski> similar to how in set theory, (set) comprehension says that if, for all `x', `x in S' is equivalent to `..x..', then `S = {x | ..x..}', and vice versa
05:59:56 <ski> dminuoso : as i said, eta-conversion and function extensionality are closely related. but formally, they are distinct properties
06:00:27 <dminuoso> ski: Yes but I don't see how `removing x from: f x = T` is not eta-conversion.
06:00:32 <ski> (as an exercise, you could go about proving they are equivalent)
06:00:55 <ski> there is no lambda expression in that `f x = T'
06:01:04 <ski> eta-conversion involves a lambda expression
06:02:25 <ski> (eta-conversion is about equivalence (equality) of expressions. function extensionality is about an implication (which turns out to be an equivalence) of equations (the assumed equation being universally quantified))
06:04:41 <dminuoso> ski: So given `g = \x -> T` and `f x = T`, you would not think of them as the same? (The subtle difference in pattern matching semantics aside)
06:05:16 <ski> they're clearly not the same, syntactically speaking
06:05:40 <ski> they being the same, semantically speaking, is expressed by "(function) comprehension" (if you want to give it a name)
06:06:10 <ski> (i think this is also equivalent to eta-conversion, and to function extensionality)
06:06:34 <dminuoso> ski: Im really unsure what the point of this pedantry is. You kind of lost me.
06:07:03 <dminuoso> I mean I do understand _what_ you are saying, but not what the value of this distinction is.
06:07:25 <ski> just that these things are syntactically different, and have different names
06:07:50 <ski> if you were working in a refactoring editor, these would be distinct refactorings you could apply to your code
06:09:37 <ski> (proofs are entirely built of small steps like these. many small, individually obvious steps, hardly worth mentioning, makes up a whole chain (or tree) of nonobvious reasoning)
06:09:52 <reactormonk> Is there something like tut from scala for haskell, where you can pass through a markdown file and get back a markdown file with output from the haskell code blocks?
06:10:04 <ski> (anyway, i have to leave, presently)
06:10:44 <frerich> reactormonk: I hope there isn't, because that sounds like a little program I'd love to write! :-)
06:11:24 <Ferdirand> hackage is back \o/
06:14:15 * dminuoso is still confused about how f
06:15:09 <sm> reactormonk: just the output ? sounds interesting, what would you use that for ?
06:16:05 * sm reads http://tpolecat.github.io/tut
06:16:18 <hyperisco> dminuoso, unfortunately in some languages those are not the same D:
06:17:20 <dminuoso> hyperisco: But in Haskell they are the same.. no?
06:17:20 <reactormonk> sm, I'm currently using doobie + remark for scala presentations
06:17:25 <dminuoso> hyperisco: What languages would that be for example?
06:17:42 <hyperisco> hm‚Ä¶ I feel like I can turn on monomorphism restriction and get something interesting
06:17:44 <sm> I'm still confused about how you'd make use of ti
06:18:12 <sm> anyway, re your q, a pandoc filter might be an easy way
06:18:43 <hyperisco> dminuoso, dependently typed languages
06:21:18 <dminuoso> hyperisco: Is that because a lambda expression would not be allowed to cross universes?
06:21:45 <reactormonk> sm, I'm basically compiling my presentation.
06:22:20 <dminuoso> hyperisco: Or.. no. I really dont understand the distinction. :(
06:23:05 <hyperisco> dminuoso,  \x -> m :: (_:A) -> B  usually
06:23:46 <hyperisco> whereas if you take Idris, for example, with a function clause you can do dependent pattern matching
06:25:11 <dminuoso> hyperisco: Well fine, but how does that relate to Œ∑-conversion? In what sense would be rewriting some `f x = ...` into `f = ...` not be Œ∑-conversion?
06:26:26 <dminuoso> Or I guess it boils down to (\x -> f x) not being considered a universally quantified eqation
06:26:35 <hyperisco> I want to say it right because it has been about a year since I've done any of this
06:26:44 <hyperisco> f x = m; f :: (x:A) -> P x
06:27:13 <dminuoso> hyperisco: what syntax is that using?
06:27:31 <Boarders_> cocreature: nice
06:27:31 <lseactuary> can someone help me with one quick haskell question. i have made the code but i am a bit stuck on the logic. it is short. i am having trouble using lpaste though it seems to be blocked on this server.
06:27:43 <hyperisco> f x = m; f : (x:A) -> P x  how about then
06:27:46 <dminuoso> lseactuary: Feel free to use say gist.github.com
06:28:00 <hyperisco> I dunno, some crazy people are arguing whether to use : or :: heh
06:28:15 <dminuoso> hyperisco: Ah all good now. Just making sure there's no confusion due to unclear usage of vocabulary.
06:30:39 <lseactuary> oki
06:34:26 <hyperisco> dminuoso, also in some languages  \x -> f x  is not the same as  f
06:34:48 <infandum> How can I use the foldl library to divide each element of a list by the maximum of a list? Like: L.fold f [1,2] == [0.5,1]
06:35:01 <lseactuary> i am stuck on the rewrite function in this code please: https://gist.github.com/anonymous/b2619a109df284b5d02ae99c235ba514
06:35:13 <ertes-w> @let blah :: a -> a; blah = undefined
06:35:16 <lambdabot>  Defined.
06:35:21 <ertes-w> > blah `seq` ()
06:35:23 <infandum> Actually, it would be (Just [0.5, 1])
06:35:25 <lambdabot>  *Exception: Prelude.undefined
06:35:27 <ertes-w> > (\x -> blah) `seq` ()
06:35:30 <lambdabot>  ()
06:35:33 <ertes-w> > (\x -> blah x) `seq` ()
06:35:37 <lambdabot>  ()
06:35:44 <ertes-w> haskell is one of those languages =)
06:36:16 <dminuoso> ertes-w: I specifically excluded that subtle difference in the discussion, because Im fairly sure that the distinction ski is making be about something different
06:36:19 <hyperisco> seq is a bit of a cheat but okay
06:36:47 <ertes-w> i'm not aware of other distinctions
06:37:09 <hyperisco> other reasons those can be different‚Ä¶ say this is a language with function overloading, then f may refer to functions of different arities
06:37:15 <dminuoso> ertes-w: well the point does not seem to be about haskell, but rather wrt to the usage of the terms.
06:37:31 <hyperisco> so this would be a language where we use uncurried functions normally
06:37:49 <ertes-w> hyperisco: no, seq is not a cheat‚Ä¶  there is substance to this difference
06:37:58 <ertes-w> i will often write a function like this:  "f x = \y -> ‚Ä¶"
06:38:03 <ertes-w> for this very reason
06:38:10 <hyperisco> ertes-w, but how else is that observable?
06:38:50 <hyperisco> another distinction is if this is a language with strict semantics, as  f  must be evaluated, but  \x -> f x  must only evaluate f after being applied to something
06:38:54 <ertes-w> hyperisco: isn't this good enough as a semantic difference?
06:39:30 <ertes-w> there is of course also a performance difference, because you can bind the evaluation of certain values to a particular currying stage
06:39:46 <ertes-w> like: "after two arguments, depend on this value, even before the third is applied"
06:39:55 <ertes-w> this can make "map (f x y)" go much faster
06:40:07 <ertes-w> at the expense of making bottom semantically significant
06:40:31 <ertes-w> that's why i write functions like "f x = \y -> ‚Ä¶"
06:40:38 <ertes-w> because:  map (f x)
06:41:29 <frerich> lseactuary: How do those fibs examples come to be? I understand that 'A' is an axiom from which you can get 'AB' using the first rule. From there you could either get 'ABB' by applying the first rule once more, or 'AA' by appliying the second rule, right?
06:41:39 <frerich> lseactuary: It's not clear to me how you arrive at 'ABA' as the step after 'AB'.
06:43:25 <lseactuary> frerich - rewrite (rules fib) "ABA". so we take A first. if we look at fib A -> AB. so now the string is AB. then we take B (from the original ABA). we see it maps to A. so we append this A to the string AB we created. So now we have ABA. the final character in the original ABA is A which maps to AB. so finally we have ABAAB.
06:44:04 <Ferdirand> pipes define its MonadTrans instance as "lift m = M (m >>= \r -> return (Pure r))". Any reason why you would not want to define this as "lift = M . fmap Pure" instead ?
06:44:16 <lseactuary> frerich - hence we also have the maybelookup function. i think if we passed a strong "ABCA" there is no mapping for C to anything so this would be ignored.
06:44:48 <hyperisco> ertes-w, in Core there are no function clauses
06:44:49 <lseactuary> does it make sense?
06:45:00 <dminuoso> Ferdirand: rit's not the same thing?
06:45:00 <lseactuary> my maybelookup function may be wrong btw
06:45:51 <ertes-w> Ferdirand: i'm guessing it's because of a semantic subtlety in the implementation of Proxy‚Ä¶  see the docs for the 'observe' function
06:46:04 <Ferdirand> dminuoso: isn't it supposed to be the same thing by monad laws ?
06:46:10 <Ferdirand> ertes-w: ah, looking, thanks
06:46:51 <ertes-w> Ferdirand: it's in Pipes.Internal
06:47:10 <Ferdirand> tbh this is going a bit over my head
06:47:22 <Ferdirand> i'm rewriting pipes from scratch an as exercise in understanding
06:47:26 <dminuoso> Ferdirand: Ahh! https://hackage.haskell.org/package/pipes-4.3.9/docs/src/Pipes-Internal.html#Proxy
06:47:35 <Ferdirand> and then comparing with the official implementation
06:47:35 <dminuoso> Ferdirand: Its documented right at the top =)
06:49:19 <lseactuary> frerich The idea is that the system can evolve, starting with the axiom, by application of the rewrite rules: they may can act in parallel, replacing each symbol in the current with another word and then concatenating the results.
06:53:35 <ertes-w> Ferdirand: in that case you shouldn't use the official (optimised) implementation‚Ä¶  in older releases of pipes there was a "safe" variant of Proxy, which didn't make that trade-off
07:10:01 <Ferdirand> ertes-w: well, i'm not, but in this specific case, i really don't understand the relationship between the lift implementation, the one i propose, and possible pipes optimizations
07:10:23 <Ferdirand> i'm claiming these are equivalent because of monad laws of the underlying monad, not of the pipes transformer itself
07:10:47 <AWizzArd> Intero ‚Äì my Emacs is reacting very slow. For example moving the cursor can sometimes take half a second before I see a reaction. I reckon that some kind of even is being fired on each key press and analyzed first.
07:10:54 <AWizzArd> Can this be configured somehow?
07:14:54 <hyperisco> andriusbartulis, https://wiki.haskell.org/Haskell_in_industry https://github.com/erkmos/haskell-companies
07:15:30 <andriusbartulis> hyperisco: I wonder how up to date that is
07:15:57 <hyperisco> fancy that they post that information
07:17:08 <andriusbartulis> hyperisco: you are right :)
07:17:14 <andriusbartulis> my bad
07:55:32 <MacSlow> Greetings everybody!
07:56:45 <metahumor> Hi!
08:09:49 <joncol> How can I mock a third party web service in Haskell? I'm trying to learn how to use Yesod.
08:10:00 <joncol> (For unit tests.)
08:12:29 <Axman6> imo this is best done with servant
08:12:36 <Axman6> really there is no better tool imo
08:13:08 <Axman6> joncol: you might like http://www.parsonsmatt.org/2016/06/24/take_over_an_api_with_servant.html
08:14:37 <alp> joncol, servant-mock would let you do that, if you're fine with just generating random responses of the right type
08:14:59 <joncol> OK, so using servant for that won't in any way conflict with using Yesod for the application?
08:15:09 <joncol> Axman6: Thanks, I'll read it.
08:15:20 <alp> exactly joncol
08:15:41 <alp> you'd just describe the third party webservice's API/routes using servant's "DSL"
08:16:04 <joncol> alp: OK, sounds very cool :).
08:16:35 <Axman6> personally I would just use servant and forget yesod, but they each have their place.
08:16:39 <alp> and then use the servant-mock package to get an implementation of that API, that you can serve with 'warp'
08:16:52 <Axman6> I have a few servant based web services in production
08:17:31 <alp> I suppose we could do something similar that doesn't even requires you to spin up a server, and just hands you one function per endpoint, that simply generates a random response of the right type. that would be doable. but it doesn't exist yet.
08:18:08 <alp> (as far as I know)
08:18:48 <alp> joncol, here's a little demo: https://haskell-servant.github.io/posts/2015-07-24-pulling-mock-servers-out-of-thin-air.html
08:21:06 <alp> joncol, note however that in the past, for mocking external services I'd just introduce a GADT at the boundary between my program and the service, a GADT that describes all the requests that I can make to the service, one constructor per "request", constructor fields for request parameters, return type tagged with the response type. and then switching between mock and real service is about passing a different function of type 'forall a.
08:21:06 <alp> ServiceRequest a -> SomeMonad a'.
08:22:11 <Axman6> alp: do you have a good reference for that?
08:22:40 <joncol> alp: OK, cool. You say in the past you did. Now you use servant as described in the above links instead?
08:23:43 <alp> joncol, I use servant-mock when there's a point in having a server, and the GADT + "interpreter" approach when there isn't
08:25:06 <alp> Axman6, hmm not really. I'm not saying there isn't any but more that I haven't looked. but really something as simple as: data UserRequest a where { GetUser :: UserId -> UserRequest (Maybe UserDetails) ; ListUsers :: UserRequest [UserSummary] ; AddUser :: UserDetails -> UserRequest Bool }
08:25:07 <Boarders_> say I am writing a parser for a config file that only has some of the fields filled in and I want to fill the rest of the fields with some default values, what approaches are there to doing it?
08:25:37 <alp> and then my server function takes as argument an interpreter for those requests and uses it whenever I need to issue those requests.
08:25:41 <Axman6> Boarders_: oo, one sec, I have a good link for that
08:28:19 <Axman6> Boarders_: it's a little long, and possibly a little overkill, but but there's a nice solution you get for exactly your problem by adding a type parameter as described here: https://www.benjamin.pizza/posts/2017-12-15-functor-functors.html
08:28:19 <Boarders_> atm my idea is just to add <|> to my parser with the default values or something like that
08:28:19 <Boarders_> cool, I'll take a look
08:28:32 <humanoyd> Is there a difference between `mzipWith` defined on page 31 of https://themonadreader.files.wordpress.com/2011/10/issue19.pdf and `liftA2`?
08:30:42 <Axman6> long story short, you get: data Config f = Conf {hostname :: f Text, port :: f Int16, logFile :: f FilePath}; type Partialconf = Conf Maybe; type CompleteConf = Conf Identity; and using something which looks like: updateConf :: CompleteConf -> PartialConf -> CompleteConf by providing a function of type (forall a. Maybe a -> Identity a -> Identity a)
08:31:34 <frerich> The worst effect Haskell has on me is that I start to try writing Haskell'ish code even in languages where it doesn't really work so well; I had colleagues complaining about recent Python programs because 'lambda' was everywhere. :-(
08:31:40 <metahumor> Boarders_: or make a Config and partialConfig, and make the partialConfig a monoid
08:31:53 <metahumor> Boarders_: and a finalize :: partialConfig -> Config
08:32:33 <Axman6> metahumor: that's basically what the technique in that srticle gives you, but you get those things basically for free
08:32:37 <metahumor> Boarders_: finalize will be easy to write, you just provide your default partialConfigs on the left side of the "msum"
08:32:49 <metahumor> ah nice
08:33:21 <Boarders_> what is the standard way to do the partialConfig, with Maybe for fields or something like that?
08:33:26 <Boarders_> probably that is a horrible idea
08:33:48 <Axman6> yes, that's exactly the idea
08:34:00 <Axman6> read the article :)
08:34:09 <Boarders_> will do, at work at the moment :p
08:34:42 <Axman6> this is more important than work! (or, it is work, assuming you code for work, this is important personal development)
08:34:48 <metahumor> Boarders_: you might want to use "Last"
08:34:55 <joncol> Will doing the mocks using Servant force me to use randomly generated responses (with types according to the API definitions)? Or can I somehow do generic stuff when my mock gets called? I basically want to verify that the third-party service was called with certain parameters...
08:35:00 <metahumor> Boarders_: which is a Monoid on top of Maybe
08:35:41 <Boarders_> cool, thanks for the help
08:35:45 <metahumor> Boarders_: here's an example of combining that Last thing with parsing: https://github.com/qfpl/applied-fp-course/blob/master/level06/src/FirstApp/Types.hs#L204
08:37:12 <alp> joncol, yes, all servant-mock does is scan the API type and give you a request handler for each endpoint, whose implementation just uses quickcheck's Arbitrary class to generate a response of the right type, nothing more.
08:38:02 <alp> for what it's worth, I recently came up with something a little more general, which allows you to specify what you want the handlers to do up to a point. It has to be somewhat uniform. See https://gist.github.com/alpmestan/3cfb9a05f41c08ba111a9bfadcd75ec1
08:41:35 <joncol> alp: Thanks, I'll start experimenting with it.
08:42:11 <athan> Has anyone here gotten strange concurrency bugs with the new ghc 8.4? Like two different threads seeing a different image of the same TVar, for instance
08:42:21 <alp> but really the simplest option is a GADT + several functions to interpret it, one to return silly data without talking to anything, one that actually calls the service.
08:42:40 <alp> it's dead simple and flexible
08:42:42 <barrucadu> athan: Could you give a small example?
08:44:41 <athan> barrucadu: that's pretty much it, except more elaborate - I've got a http server and websocket server that see two different pictures of the same references - I know I'm only running my transformer once / creating the reference once, and passing them around
08:44:56 <athan> ...it's a hashmap of sessionID stuff :x
08:45:49 <barrucadu> So you're having two threads see different content in the same TVar, even though you're only writing to the TVar at the beginning?
08:46:02 <athan> oh jeez, I'm not even using ghc 8.4 - I'm on lts 11.0, 8.2.2
08:46:21 <athan> that's correct barrucadu; I've been verifying with logging all around
08:46:34 <athan> and verifying I'm not deleting or adjusting the variable elsewhere
08:47:02 <barrucadu> Is this something open source?
08:47:29 <cocreature> maybe try replacing it by an IORef? it doesn‚Äôt sound like you gain anything by using a TVar if you‚Äôre only initializing it once
08:48:04 <athan> cocreature: in my experience, TVars actually avoid this better than IORefs, but it looks like I'm footgunning myself
08:48:20 <athan> I'm using more sophisticated structures, too, actually - tmapchan and tmapmvar
08:48:47 <athan> barrucadu: yeah, it's like a sreaming dependency / resource allocator / manager thingy protocol doodad for web apps
08:49:15 <cocreature> athan: neither should exhibit this behavior so if you‚Äôre assuming it‚Äôs a bug in GHC, checking if it is reproducible with an IORef is a good way to make sure that it is actually GHC‚Äôs failt. if it also happens with an IORef, I‚Äôd start looking in your own code
08:49:42 <athan> aie aie, thank you for the advice
08:49:50 <barrucadu> Or an MVar
09:36:58 <ski> dminuoso : the distinction i was making was a syntactic (or pedantic, if you prefer) distinctions, not a distinction in the reasoning force of the two principles. that said, there might be languages in which they are not equivalent, so that there's also a semantic distinction
09:39:57 <ski> (if you're assuming commutativity of multiplication, then `(x * y) * z = x * (y * z)' (associativity) is equivalent to `(x * y) * z = y * (x * z)'. that doesn't make the latter law "associativity". the names refer to specific syntactic situations, that are different, even if they allow the same reasoning in the end (or not, depending on the rest of the language, like in this case whether we also have commutativity)
10:39:47 <kuribas> How do I apply a constraint in TH?
10:39:59 <kuribas> AppT (ConT ''MyClass) var ?
10:40:08 <lyxia> yes
10:40:23 <kuribas> ok, it seemed to easy :)
10:41:19 <EvanR> haskell, making things that are too easy... easy
10:55:45 <agentultra> Are there any users of the graphql-api package here? If talking about libraries is OT, pm/channel is good. :)
10:57:44 <Unode> hi all, while compiling a project using ghc 8.2 one of the files causes ghc to use almost 5GB of RAM. Is there any way to tell ghc not to exceed a fixed limit? Also how can I understand what is causing this memory peak?
10:58:45 <lyxia> you can pass RTS options to GHC.  ghc +RTS -M1G  # use 1G of heap
11:00:58 <bash0r> Hi, do you think it's possible to encode arbitrary semantics in as EDSL with help of dependent typing? Something complex like a module system.
11:02:23 <EvanR> I am confused by the interaction of levels in that question
11:02:42 <Unode> lyxia: won't that simply cause GHC to crash if more than 1G is requested?
11:03:04 <bash0r> EvanR: referring to my question?
11:03:07 <Unode> I mean, I don't really understand why that file in particular causes such considerable memory usage
11:03:24 <EvanR> yea
11:05:16 <bash0r> EvanR: it's not useful to reimplement a module system for an EDSL in Haskell. I agree with that. But I need a module system in a dependently typed language where no module system exists.
11:06:14 <bash0r> So my approach would be to implement a module system with dependent typing in that language.
11:06:57 <lyxia> that seems possible
11:08:25 <bash0r> Other complex semantics like type classes and such stuff, too? I know that Coq supports some form of type classes. But I never used them and I have no idea how they implemented it in CoC.
11:09:23 <lyxia> once you have full dependent types you can encode arbitrary rules at the type level
11:12:41 <cocreature> agentultra: generally you are going to get better answers if you just ask your actual question instead of asking if there are people who might know something about the topic of your question first. talking about libraries is certainly fine here!
11:13:11 <agentultra> cocreature: thanks, wasn't sure if libraries were OT is all. Cheers!
11:13:28 <cocreature> agentultra: we wouldn‚Äôt have a lot to talk about if we excluded libraries :)
11:13:39 <bash0r> I know about dynamic languages that they can represent all correct (but also a whole lot (all?) of incorrect programs, too). How much of the correct programs can a dependently typed language represent then? All correct ones or is this unknown / current field of research / son provable?
11:15:03 <lyxia> bash0r: define "correct"
11:15:19 <Ariakenom> if __name__ == "__main__":
11:15:57 <bash0r> lyxia: those that don't crash.
11:17:50 <barrucadu> bash0r: What's an example of a language which can represent all correct programs?  Python?
11:18:14 <fakenullie> Can't any Turing complete language represent all programs?
11:18:22 <barrucadu> So if you implement a Python interpreter in a dependently typed language, can that dependently typed language now represent all correct programs?
11:18:41 <cocreature> ‚Äútyped languages exclude a lot of bad programs but also some good ones‚Äù is more folclore that you put in ven diagrams than a formal statement that you can reason about
11:18:45 <EvanR> bash0r: recursive modules might be an interesting exercise though
11:19:15 <bash0r> barrucadu: interesting question.
11:19:24 <EvanR> fakenullie: they are probably alluding to the conflation of dependent types with total programming, which cant be turing complete
11:20:17 <EvanR> also crashing is not always involved in specification of correctness
11:20:20 <bash0r> EvanR: I'll try that. Thanks.
11:20:26 <agentultra> Does anyone have an example of how to deal with GraphQL variables using graphql-api?
11:20:47 <EvanR> e.g. part of correctness is to crash early and retry, or even if it doesnt crash, does it get the job done
11:21:37 <agentultra> It seems tools like GraphiQL always send the variables and the parser returns an error in such a case. From what I've read in some of the open issues it doesn't seem like there's a "blessed," supported way to do it.
11:23:01 <fakenullie> There maybe language which just doesn't produce errors
11:23:32 <bash0r_> Thanks everyone. Gotta go. :/
11:23:52 <Ariakenom> EvanR, well crashing is basically wrapping the program in Either, right? It's termination that's tricky.
11:25:02 <fakenullie> So total language by definition can't encode non terminating programs?
11:25:26 <EvanR> i was putting freezing and crashing in the same bucket
11:25:38 <EvanR> fakenullie: they can, see partiality monad
11:26:02 <EvanR> fakenullie: r.e. doesnt produce errors, like PHP most of the time
11:27:35 <EvanR> bash0r: another thing that type classes get you that basic dependent types do not is... type classes let you specify rules that the compiler then use to generate proofs automatically. you dont have to manually construct terms of a given type, though sometimes i think that would be interesting to allow in haskell
11:27:50 <Ariakenom> fakenullie, afaik yes. Termination can be replaced by progress and still make sense. Like for a web server.
11:28:40 <EvanR> Ariakenom: but if you want to simulate partiality itself, you can still do that too
11:28:43 <EvanR> for what its worth
11:29:00 <EvanR> i.e. something that is not necessarily terminating or productive
11:30:53 <Ariakenom> EvanR, yeah it's why I included "still make sense". More types just allow you to prove more things, right? You're welcome to throw it away.
11:31:30 <cocreature> interestingly, blum‚Äôs size theorem tells you that even when you only consider terminating programs, there are always programs for which you need exponentially more code in a total language
11:41:47 <Ariakenom> That is interesting.
11:44:00 <Ariakenom> To bring up an old thought: Would 0/0=throw NanException be worse than
11:44:04 <Ariakenom> >let nan=0/0 in S.member 0 $ S.fromList [0,nan,1]
11:44:18 <Ariakenom> > let nan=0/0 in S.member 0 $ S.fromList [0,nan,1]
11:44:22 <lambdabot>  False
11:44:56 <cocreature> didn‚Äôt we have this exact discussion a few hours ago?
11:45:09 <a____> hello
11:46:03 <Ariakenom> Yes. I tried to say that at the start. I wanted some more input.
11:46:41 <fakenullie> is there a nan for integers?
11:48:16 <cocreature> no
11:49:26 <fakenullie> is having sets of floating point numbers a good idea?
11:51:33 <Ariakenom> no. at least that's my view
12:01:36 <fakenullie> > 0 / 0 :: Scientific
12:01:39 <lambdabot>  error:
12:01:39 <lambdabot>      Not in scope: type constructor or class ‚ÄòScientific‚Äô
12:04:12 <guessWho> i have a function getRandomSequence :: IO GHC.Word.Word32 i want a list with 5 random numbers without defining a new function and also compactly
12:04:19 <guessWho> how can i do so
12:04:29 <dminuoso> :t replicateM
12:04:32 <lambdabot> Applicative m => Int -> m a -> m [a]
12:07:57 <guessWho> dminuoso : its part of base but i couldn't find it >?
12:08:20 <dminuoso> guessWho: It's in Control.Monad
12:09:01 <guessWho> dminuoso : thanks a ton
12:10:01 <cocreature> guessWho: protip: https://hoogle.haskell.org/?hoogle=replicateM
12:23:39 <guessWho> cocreature : if i have a value m of type say X then under right circumstances i can do this m :: Y but if i have [X] then how do i make it [Y]
12:26:18 <cocreature> guessWho: use "map"?
12:28:44 <guessWho> cocreature : i thought so but i'm not entirely sure about syntax
12:29:38 <cocreature> guessWho: assuming you have f :: X -> Y and xs :: [X], you can use map f xs
12:30:43 <guessWho> cocreature : i don't i just have a type synonym
12:31:10 <cocreature> guessWho: it might be easier if you show us the code you have
12:31:10 <guessWho> cocreature : i have m = [X] and type Y = X
12:32:19 <cocreature> guessWho: oh you don‚Äôt need to do anything to ‚Äúmake‚Äù it [Y], type synonyms don‚Äôt create new types. it‚Äôs just a different name for the same type
12:32:24 <cocreature> so no conversion is necessary
12:34:35 <guessWho> cocreature : ohk thanks, you guys makes haskell so easy
12:48:49 <agentultra> Haskell is awesome. Starting a greenfield project in it. Quite pleased so far.
12:56:59 <agentultra> s/project/project for work/
12:59:21 <Sonolin> nice!
12:59:29 <Sonolin> I wish I could use haskell for work, so far I haven't found a niche
13:02:31 <agentultra> one low-key way I've heard people use is to start writing shell scripts and tooling in it. ;)
13:10:13 <albeit> Is it possible to lift an inner monad transformer in a stack? For example, I want to run a "ExceptT e m2 ()" computation from within a "ExcepT e m1 ()" computation.
13:12:09 <cocreature> albeit: you can use "hoist" https://hackage.haskell.org/package/mmorph-1.1.1/docs/Control-Monad-Morph.html#v:hoist
13:48:33 <Tony__> Hello.  I was if anyone had heard of the lastest Windows Update breaking ghci 8.2.2.    Everytime I try to us it now i get: Access violation in generated code when reading 000000000465d0f6
13:48:45 <Tony__> Even deleting everything and getting a clean install
13:49:36 <Sonolin> from what I understand, windows releases with GHC are a little delayed, since windows likes to break things suddenly without notice
13:49:52 <Sonolin> I don't run on windows, though, so not 100% sure
13:50:15 <Tony__> I'm pretty sure its the update.. it started immediately after i rebooted after the patch
13:55:47 <Sonolin> yea I've heard 1 other user with the same issue, and the GHC release shortly after fixed the issue
13:56:03 <Sonolin> I'd say the devs are already working on it, but you could try reporting to GHC directly
14:28:10 <armlesshobo> I want to establish a connection to a DB, and I want it to be accessible to my request handling functions; but I don't want to "carry" it throughout all my request handlers. I feel like I should incorporate the State monad but I'm not quite sure how to go about that
14:30:43 <armlesshobo> this is what I currently have for establishing endpoints: http://lpaste.net/363707
14:30:52 <armlesshobo> but I'm unsure of where to put what
14:31:51 <armlesshobo> The database stuff is currently done in the handler
14:37:00 <kvuser3_> Hello Guys and Girls :)
14:37:46 <kvuser3_> how can i buil a matrix with haskell, i have wrote this function https://pastebin.com/vfeF9yZV thanks for the help :)
14:37:51 <kvuser3_> build*
14:39:40 <kvuser3_> with Matrix, i mean like a array but with 2 Dimensions. Thanks for the help! :)
14:39:56 <Ariakenom> kvuser3_, interesting, could you tell me some of the background to this question? What makes you turn to Haskell?
14:41:56 <nisstyre> you can use a Map with tuples as keys for a matrix
14:41:57 <armlesshobo> kvuser3_: a matrix would be a list of rows
14:41:58 <kvuser3_> Ariakenom: please let's talk for first about my question. thanks to answer me :)
14:41:59 <nisstyre> no need to use an array
14:42:41 <nisstyre> Map (Int, Int) a
14:42:43 <kvuser3_> nisstyre: can you tell more please. i don't know, what you means with row
14:43:02 <nisstyre> kvuser3_: you represent the matrix as a Map with tuples as keys, the tuples represent x and y values
14:43:10 <nisstyre> for a 2d array (matrix)
14:43:17 <armlesshobo> that's a neat idea
14:43:25 <nisstyre> you can do n-dimensions by just having n-tuples
14:43:37 <kvuser3_> nisstyre: i have to use array to build my matrix
14:43:47 <nisstyre> that is how people do it, e.g. for things like the game of life
14:43:55 <nisstyre> much more flexible than using arrays
14:44:01 <armlesshobo> sounds like homework
14:44:03 <pk6vx0x2> alternatively if this is a toy implementation you could represent it as a list of lists.
14:44:05 <nisstyre> kvuser3_: you can generate an array from a Map if need be
14:44:10 <nisstyre> why do you need arrays?
14:44:17 <armlesshobo> homework constraint
14:44:20 <nisstyre> ok
14:44:21 <armlesshobo> my guess
14:45:14 <ongy> I wonder if Map (Int, Int) a or IntMap (IntMap a) would perform better
14:45:18 <kvuser3_> armlesshobo: that is not a homework constraint
14:45:52 <bendo> armlesshobo: did you try spock?
14:45:57 <lijero> I want to use "type Id a = a" and "type Const a b = a" to produce a type of kind (* -> *), but even with LiberalTypeSynonyms enabled I'm still getting told e.g. "the type synonym Id should have 1 argument, but has been given none". Is there a way around this?
14:46:08 <nisstyre> ongy: I think IntMap might perform better if your keys are Ints yeah
14:46:14 <nisstyre> it uses patricia trees
14:46:24 <kvuser3_> nisstyre: i think, i have to possess the Data.array modul and i think, it's a good way to get this :)
14:46:29 <nisstyre> if you need arbitrary sized keys then something else would be better
14:46:43 <nisstyre> kvuser3_: so this is just a learning experience?
14:46:48 <bendo> armlesshobo: https://www.spock.li/
14:47:33 <kvuser3_> nisstyre: yess kind of
14:48:15 <nisstyre> kvuser3_: I would start by defining what kind of functions you want and what they should take and return
14:48:27 <bendo> armlesshobo: https://github.com/bendo/hs/blob/master/spock-rest/app/Main.hs
14:48:32 <nisstyre> like if you want a function that simply gives you the value at a certain coordinate
14:48:41 <nisstyre> then what would that take as a parameter?
14:48:50 <kvuser3_> nisstyre: i get my answer, thanks all :)
14:49:25 <nisstyre> ok, in the future I'd avoid using arrays if you don't have to ;)
14:49:29 <nisstyre> and especially avoid lists
14:49:36 <nisstyre> unless it makes sense to do so
14:50:53 <dmj`> this a ghc bug? https://gist.github.com/dmjio/542d8b48ea50509793dd67a818fcc379
14:51:37 <kvuser3_> nisstyre: okay I remember that. thanks :)
14:54:04 <Ternary> Does anyone know why I can run a detailed-0.9 test suite just fine with "cabal test" but if I run "stack test" it crashes with "Prelude: no parse"?
14:55:00 <MacSlow> Greetings everybody!
14:55:07 <Sonolin> hai!
14:58:12 <Ariakenom> Yo! Mac wazzuuup!?
15:01:06 <MacSlow> wondering where/if there's a list of Haskell's default infixr setting for the prelude
15:01:51 <nisstyre> MacSlow: should be in the Haskell Report https://www.haskell.org/onlinereport/haskell2010/
15:03:31 <MacSlow> nisstyre: doh... silly me... forgot about that thx!
15:05:02 <nisstyre> MacSlow: is this what you're after? /https://github.com/haskell/haskell-report/blob/master/report/Prelude.hs
15:05:06 <nisstyre> https://github.com/haskell/haskell-report/blob/master/report/Prelude.hs
15:07:17 <MacSlow>  nisstyre: ah... great thx
15:07:41 * MacSlow continues to be impressed by Haskell
15:08:53 --- mode: niven.freenode.net set +o ChanServ
15:17:00 <EvanR> ski: I wrote a division algorithm using the runlength encoded natural numbers https://github.com/evanrinehart/recursively-run-length-encoded-natural-numbers/blob/master/T.hs#L201
15:19:56 <EvanR> i am guessing the performance is not such that all encryption is now broken
15:22:26 <jmcarthur> How much can I rely on threads being killed for blocking on an mvar or tvar that isn't referenced anywhere else? I have some memory that BlockedIndefinitelyOnMVar doesn't work with -threaded, but it was a long time ago, and I hadn't even fully verified it then.
15:23:43 <jmcarthur> I also in the documentation for forkIO "The newly created thread has an exception handler that discards the exceptions BlockedIndefinitelyOnMVar, BlockedIndefinitelyOnSTM, and ThreadKilled, and passes all other exceptions to the uncaught exception handler." so maybe this means I shouldn't be trying to do this anyway.
15:24:18 <jmcarthur> It's not clear to me from the wording if that's exactly the behavior I want or exactly the opposite.
15:24:37 <jmcarthur> I guess it's what I want.
15:31:17 <ospa> Hi! I have problems with hspec-discover. I dont know why, but when Im defining the hspec main function manually like in this example (http://hspec.github.io/hspec-discover.html) it works (shows errors on not-passed specs)
15:31:34 <ospa> but when I use hspec-discover I got output "test suite passed"
15:31:48 <ospa> which is not true. It seems like hspec-discover didnt discover my files
15:32:47 <ospa> oh ok I got it. I didnt suffixed the file name with "Spec" ... I was sarching for it 30 mins
15:32:54 <ospa> writing about it here helped
15:32:57 <ospa> thank you guys! :)
15:32:58 <ospa> :D
15:37:58 <`Guest00000> imagine you can specify expressions in patterns. which syntax would you rather like for that?
15:38:22 <`Guest00000> case n of SYNTAX?( 2 + 2 ) -> "this is four"; _ -> "this is NOT four"
15:38:49 <ski> oh, you mean quasiquoted expressions in patterns ?
15:39:03 <`Guest00000> except not quasiquoted
15:39:12 <`Guest00000> just exprs in pats
15:39:35 <ski> but `n' is a concrete syntax / parse tree, or an abstract syntax tree, of some kind ?
15:39:49 <`Guest00000> n is a variable of type Int
15:39:51 <`Guest00000> !!!
15:40:01 <ski> ok, then i'm not following what semantics you intend
15:40:26 <`Guest00000> semantics is that that line is equivalent to: case n of 4 -> "this is four"; _ -> "this is NOT four"
15:41:15 <ski> > let n = 4 in case n of ((2 + 2 ==) -> True) -> "this is four"; _ -> "this is NOT four"  -- do you mean something like this ?
15:41:17 <lambdabot>  "this is four"
15:41:38 <`Guest00000> if (==) is absolutely faithful, yes
15:42:04 <`Guest00000> um
15:42:04 <`Guest00000> no
15:42:05 <ski> well, what would you use else, for matching, instead of `(==)', if it's deemed not appropriate ?
15:42:06 <`Guest00000> sorry
15:42:22 <`Guest00000> just treat it like magic
15:42:32 <ski> (btw, note that matching on numeric literals already uses `(==)' under the covers)
15:42:40 <ski> i'm not sure what you mean by that
15:43:57 <ski> let's say that instead of `2 + 2', we have an expression that computes a `Set Blah', or a `Map Bleh Blah'. such an ideal, conceptual value, could internally be represented in many different ways. i think we'd like to use the exported, semantic, equality, rather than some kind of internal, structural equality, if you perhaps had the latter in mind
15:45:22 <ski> (as it stands, Haskell doesn't have a way to give a user-defined semantic equality (unlike Mercury, say). if we had that, then that could be used in such a situation)
15:45:52 <EvanR> user defined equality to be used in the type checker?
15:46:15 <ski> to be used by the compiler, when reasoning about (optimizing) the program
15:46:22 <EvanR> ah
15:46:53 <ski> in Haskell, `(==)' (disregarding the syntactic sugar of using it for numeric literals), is just a convention
15:47:17 <`Guest00000> it's just that  that case expression is inside a type...
15:47:22 <ski> in Mercury, when you make a user-defined equality, you promise (proof obligation) that it's an equivalence relation, and the compiler is allowed to rely on that
15:47:29 <ski> UB if it turns out it isn't
15:47:45 <EvanR> it checks your proof?
15:48:13 <ski> it doesn't, it trusts it blindly, that's why it's a(n informal) proof obligation on the part of the programmer
15:48:35 <ski> (it's allowed to call your bluff, if it can. but i don't think the implementation ever does)
15:49:15 <ski> (having a formal proof, that is checked, could be nicer, if it could be done in a not too painful way)
15:50:16 <ski> `Guest00000 : you're using `case' in type expressions ?
15:50:31 <`Guest00000> note that it's not haskell
15:50:42 <ski> ok
15:50:51 <ski> tell us more ?
15:50:56 <`Guest00000> more of what?
15:52:06 <ski> of the situation, of what you want to achieve, of whatever you think could be interesting/relevant ?
15:52:19 <ski> (perhaps you already have, that would be ok)
15:52:38 <`Guest00000> i'm just exploring language ideas
15:52:42 * ski nods
15:53:19 <`Guest00000> i wanted to know what would be a good syntax for what i described, for many people
15:53:45 <ski> i recall toying with the ideas of being able to use variable identifiers which were identified not by a plain name, but by an expression
15:54:35 <`Guest00000> that's more of syntax sugar, right?
15:54:45 <ski> so you could say something like :  let '(reverse xs)' = reverse xs in ..'(reverse xs)'..
15:54:56 <ski> or even just :  let '(reverse xs)' in ..'(reverse xs)'..
15:55:24 <ski> yes
15:55:24 <Tuplanolla> That sounds like languages based on term rewriting.
15:56:21 <`Guest00000> but isn't haskell term-rewriting lang too? ;)
15:56:22 <ski> the idea being that it's sometimes a bother to invent a new name for something, but you'd still like to name it, for sharing (or precomputation, with call-by-value)
15:56:42 <siiky> anyone familiar with http://wiki.di.uminho.pt/twiki/bin/view/Education/CP/Bibliografia ? (especially the notes next to 'segundo' and 'terceiro')
15:56:54 <athan_> would it be possible to use universal quantification in constraints, or instance headers or something? Like "Given I have a constraint /forall/ some parameter, I can use it in blah blah blah, because the compiler can apply it to more than just the variables I've declared, due to the instance defined being universal itself" or something wacky like that?
15:57:16 <`Guest00000> ski: what if i use '(reverse (head xs : tail xs))', how would this be interpreted?
15:57:30 <athan_> I'm not sure if it's related, but I'm also trying to make a Generic instance for an existentially quantified type... but https://ghc.haskell.org/trac/ghc/ticket/10514 kinda leads me to believe there isn't much hope
15:57:43 <ski> `Guest00000 : that would be an out-of-scope variable, unless you also introduced that one
15:57:49 <ski> another example would be :  foldr (\x '(\acc -> res)' acc -> ..'(\acc -> res)'..)
15:58:31 <`Guest00000> so there isn't semantics for the expressions in those identifiers
15:58:36 <ski> where i want to emphasize that the second argument of the callback is intended to accept an accumulator (possibly `acc', possibly something built from it), and computes some result after that
15:59:30 <ski> `Guest00000 : right .. except that in the "even just" case, the value should be equal to the value of the "quoted" expression in the "structured identifier"
15:59:53 <`Guest00000> this feels like quite an esoteric syntactic sugar idea
16:00:00 <ski> yea :)
16:01:15 <ski> athan : hm, istr hearing talk about rank-2 constraints being considered for implementation
16:02:07 <c_wraith> ski, quantified constraints?
16:02:10 <ski> yes
16:02:17 <ski> (universally)
16:02:44 <c_wraith> https://ryanglscott.github.io/2018/03/04/how-quantifiedconstraints-can-let-us-put-join-back-in-monad/
16:02:51 <c_wraith> etc
16:02:59 <ski> ty
16:04:21 <ski> `Guest00000 : fwiw, i've also been considering how one can allow `let' in patterns (in addition to conjunctive and disjunctive patterns, guards in patterns, existential coordination in patterns), lambda patterns, `if' and `case' to the left of `=' ..
16:06:10 <ski> (including some not-so-obvious extensions of disjunctive patterns, and something that's akin to a "fallthrough" in C `switch')
16:12:09 <`Guest00000> ski: you mean "lambda patterns" as in pattern matching on lambdas?
16:12:17 <ski> yes
16:12:58 <`Guest00000> please describe all of that in a text file and put it online
16:13:03 <ski> matching on `\<expr> -> <pat>' could be explained in terms of the view pattern `($ <expr>) -> <pat>'
16:13:23 <`Guest00000> oh, cool
16:14:37 <ski>   map f ((\($ f) -> y):(\($ map f) -> ys)) = y:ys  -- for fun, the recursive case of `map'
16:15:05 <ski>   map f ((f -> y):(map f) -> ys) = y:ys  -- this case is actually more clearly expressed with plain view patterns, though
16:15:35 <ski> (er, `(map f) -> ys' should be `(map f -> ys)', there)
16:16:33 <ski> (i'm not completely satisfied by view patterns, though. i want a declarative (axiomatic, say) semantics of them)
16:18:12 <`Guest00000> :t \f -> ($ ($ f))
16:18:14 <lambdabot> a -> (((a -> b1) -> b1) -> b2) -> b2
16:21:05 <ski> hmm .. actually, i now realize that my first example was garbage (sorry about that, i'm tired)
16:21:25 <`Guest00000> ok, i suspected that
16:22:10 <ski>   map (\x -> y)@(map -> (\xs -> ys)) (x:xs) = y:ys  -- this is actually what i had in mind
16:22:53 <ski> `<id>@<pat>' is generalized to `<pat>@<pat>' (conjunctive pattern, which already with view patterns and pattern synonyms, would be useful)
16:23:10 <`Guest00000> mm, this generalization is good
16:23:50 <`Guest00000> wow
16:23:51 <ski> so, we pass the element `x' to the first argument (the function callback), getting `y' back. and we transform the callback (recursively), with `map', using a view pattern, and then pass `xs' to it, getting `ys' back
16:23:55 <`Guest00000> that's somewhat convoluted
16:24:44 <ski> matching a function on `\<expr> -> <pat>' amounts to making an observation on how the function behaves, passing `<expr>' as input, and matching the corresponding output with `<pat>'
16:24:48 <`Guest00000> > (\(f -> x) f -> x) 5 (+ 100)
16:24:51 <lambdabot>  error:
16:24:51 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòa0‚Äô arising from a use of ‚Äòshow_M377119343448...
16:24:51 <lambdabot>        prevents the constraint ‚Äò(Show a0)‚Äô from being solved.
16:24:57 <`Guest00000> > (\(f -> x) f -> x) 5 (+ 100) :: Int
16:25:00 <lambdabot>  error:
16:25:00 <lambdabot>      ‚Ä¢ No instance for (FromExpr Int) arising from a use of ‚Äòf‚Äô
16:25:00 <lambdabot>      ‚Ä¢ In the pattern: f -> x
16:25:10 <`Guest00000> > (\(fff -> xxx) fff -> xxx) 5 (+ 100) :: Int
16:25:14 <lambdabot>  error:
16:25:14 <lambdabot>      ‚Ä¢ Variable not in scope: fff :: Integer -> Int
16:25:14 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
16:25:25 <`Guest00000> > (\fff (fff -> xxx) -> xxx) (+ 100) 5 :: Int
16:25:29 <lambdabot>  105
16:25:33 <`Guest00000> hmm
16:25:51 <`Guest00000> will need to extend pattern-bound vars scoping
16:26:03 <ski> @type let foo f (f -> x) = x in foo (^2) 3
16:26:06 <lambdabot> Num t => t
16:26:06 <ski> @type let foo (f -> x) f = x in foo 3 (^2)
16:26:08 <lambdabot> FromExpr t => t
16:26:35 <ski> so currently, variables from later formal parameter patterns aren't brought in scope over earlier ones
16:27:23 <`Guest00000> hhmm
16:27:23 <ski> @type let foo x x = () in foo () ()  -- still, in some sense, they are "simultaneous", in that we can't shadow
16:27:25 <lambdabot> error:
16:27:25 <lambdabot>     ‚Ä¢ Conflicting definitions for ‚Äòx‚Äô
16:27:26 <lambdabot>       Bound at: <interactive>:1:9
16:27:59 <ski> @type \x x -> ()
16:28:01 <lambdabot> error:
16:28:02 <lambdabot>     ‚Ä¢ Conflicting definitions for ‚Äòx‚Äô
16:28:02 <lambdabot>       Bound at: <interactive>:1:2
16:28:03 <ski> @type \x -> \x -> ()
16:28:05 <lambdabot> p1 -> p2 -> ()
16:28:28 <`Guest00000> how does a view pattern react to an error thrown by its function?
16:28:44 <`Guest00000> > (\(undefined -> x) -> x) 5
16:28:47 <lambdabot>  *Exception: Prelude.undefined
16:28:56 <ski> > case "foo" of (error -> ()) -> True; _ -> False
16:29:00 <lambdabot>  *Exception: foo
16:29:40 <ski> so it doesn't interact with pattern-matching in any nontrivial way
16:30:59 <ski> (.. iow, i want rules that explain how i can rewrite the call `f 3' into `f (even -> even 3)', and then to `f (even -> False)', in order to select the appropriate defining equation of `f (even -> True) = ...; f (even -> False) = ...')
16:31:56 <ski> (the question of factoring the transforming function expression in view patterns is also relevant here)
16:32:46 <`Guest00000> instead of passing on the exception, the view pattern could just fail; if that was true, we could interrogate functions about whether, for some input, they return a value which contains error somewhere in it, which would require two types of bottom
16:32:56 <`Guest00000> a non-terminating bottom and an aborting bottom
16:33:29 <ski> i believe that would be bad for the denotational semantics
16:34:45 <ski> (however, if one had a distinct partial function type, then one could imagine such a thing, for a call to it failing (as opposed to giving an exception))
16:35:09 <EvanR> i had two function types in a project once, it was cool
16:35:29 <ski> (however, such partial functions would still be problematic, from the POV of reasoning, even if not as problematic as "multiple-solution functions" would be)
16:35:33 <EvanR> total normal function and possibly nothinging functions
16:35:51 <ski> (Mercury allows such partial functions, fwiw)
16:36:34 <EvanR> ah but there was never possibility of bottom
16:36:57 <ski> well, that's not the problem i was talking about, anyway
16:37:58 <ski> you get problems with removing "dead" code, and lifting a computation out of an inner scope, in case the code in question can (silently, in the syntax) fail in this way
16:39:08 <ski> an alternative might be to allow adorning function calls with an `?', which means effectively a `fromJust' is inserted, which fails in the above sense if passed `Nothing'
16:39:11 <`Guest00000> instance Monad id where return = id; f =<< x = f x
16:39:46 <ski> this would be special case of my notion of "reflective syntax" (for functors,idioms,monads)
16:40:03 <`Guest00000> instance Monad Id where return = Id; f =<< x = Id (runId (f (runId x))
16:40:34 <`Guest00000> you either have newtypes and newtype constructors and destructors everywhere in code
16:40:43 <`Guest00000> or you have types and no constructors, destructors
16:40:57 <ski> (iiuc, Rust people have been talking about such things, for `?'. also "Plasma", a language aimed for efficient parallel execution, by a former Mercury developer, which i've heard a little about)
16:41:42 <ski>   instance Monad Id where return = Id; runId (f =<< x) = runId (f (runId x))
16:41:52 <`Guest00000> heh
16:42:02 <`Guest00000> runId (f =<< Id x) = runId (f x)
16:42:10 <ski> (using "message-dispatching" syntax, aka "copattern" syntax)
16:44:35 <ski> anyway, with `let', patterns would look like `let <expr> = <pat> in <pat>', where you start by matching your value with the last `<pat>', then, using the extended value environment, evaluate `<expr>', match its value to the former `<pat>'
16:45:42 <ski> presumably, variables that are bound by the latter `<pat>', and mentioned in `<expr>', would be dropped from the exported bindings from the matching of the whole pattern, for more consistency with the corresponding `let' expression form
16:46:56 <`Guest00000> so, what if we had "two levels", in first of which there would be Id, runId, and code in this level had to be wrapper-wary; then when referring the code from the first level in the second level, the types from first level would have erased Id, and the values erased Id and runId
16:47:17 <ski> i suppose for `if', a pattern could look like `if <expr> then <pat> else <pat>', so we still have `<expr>' here, to select which pattern to use. ditto for `case'
16:48:20 <`Guest00000> i hate wrappers
16:48:32 <`Guest00000> want to abolish them from everywhere possible
16:48:50 <ski> (if we're aiming for `if <pat> then <pat> else <pat>', then it would seem that we'd have to try matching the value to both branch patterns, and then try matching the condition pattern to either `True' or `False', depending on which of the previous matches succeeded. but it's not clear what to do if both, or neither, of them matches (perhaps there should be exhaustiveness and disjointness checking ?))
16:49:09 <`Guest00000> also, those pairs of levels would be defined for each newtype wrapped independently
16:49:39 <ski> `Guest00000 : i think "restricted type synonyms" in Hugs may do something like what you're talking about ?
16:50:43 <ski> also, on the above topic, `let',`id',`case' ought to be allowed on the declaration level. one ought be able to say `if ... then {x = ...; y = ...} else {x = ...; y = ...}' as a declaration
16:51:03 <`Guest00000> ski: oh that's cool
16:51:12 <ski> the `let' case is allowed in SML (where it's called `local'-`in'-`end')
16:51:20 <ski>   local
16:51:26 <ski>     <decl>
16:51:28 <ski>     ...
16:51:30 <ski>   in
16:51:33 <ski>     <decl>
16:51:35 <ski>     ...
16:51:36 <ski>   end
16:51:58 * ski has several times wanted this in Haskell, in concrete code situations
16:52:33 <Welkin> what does that do?
16:52:43 <Welkin> that normal `let ... in` doesn't?
16:52:58 <`Guest00000> but it's all sugar
16:53:13 <ski> the bindings made by the former declarations are in scope over the latter declarations (only). the bindings made by the latter are exported from the whole compound declaration
16:53:35 <ski> Welkin : no, the part after `in' in a normal `let'-`in' is an expression. here it is a (sequence of) declaration(s)
16:53:38 <Welkin> that sounds strange
16:53:46 <`Guest00000> implementable by inserting desugaring functionality at some level of code transformation
16:54:12 <ski> if you're defining one operation, which needs a couple of local declarations, you can use `where' (even if they don't depend on the parameters)
16:54:26 <ski> if you're defining multiple operations, you're stuck with something like the ugly
16:54:26 <athan> thank you ski and c_wraith!
16:54:38 <ski>   (foo,bar) = ...
16:54:39 <ski>     where
16:54:41 <ski>     ...
16:55:21 <ski> (where the first `...' would typically just be `(\x -> ..x..,\y -> ..y..)' or `(realFoo,realBar)', with `realFoo' and `realBar' defined in the `where')
16:56:51 <ski> `Guest00000 : sure
16:57:23 <ski> (actually, in SML, you can also declare local data types in a `local'. but you can already do that in `let' as well, so ..)
17:21:20 <anwar> Hi everyone, I'm trying to understand monad transformers by reading the haskell book and I'm really having a hard time to understand it. What other resources would you recommend to read for beginners struggling with the concept?
17:23:14 <ski> @where AAM
17:23:15 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
17:23:17 <ski> perhaps ?
17:39:24 <parsnip> what was that grunge song that went "la la lalalala la la lalalala"
17:40:29 <parsnip> oh, wrong channel
17:40:47 <parsnip> offspring -- self esteem
17:48:30 <`Guest00000> ski: "ought to be allowed on the declaration level"  can already simulate that with:  (x, y) = if ... then (..., ...) else (..., ...)
17:55:21 <ski> `Guest00000 : yes, but that becomes more awkward when you want to declare functions
17:58:48 <EvanR> this doesnt seem right
18:00:01 <EvanR> in ghci, let z = 2^7420728 :: Integer
18:00:14 <EvanR> in ghci, let z = 2^7420728 - 1 :: Integer
18:00:23 <EvanR> even z... gives False
18:00:40 <EvanR> accidentally type let z = 2^74207281 :: Integer
18:00:49 <EvanR> even z will various segfault, bus error 10, etc
18:00:54 <Welkin> > 2^7420728 - 1 :: Integer
18:00:57 <lambdabot>  5219916835913591697624186265090752987979760180105187638742320134185206035435...
18:01:13 <Welkin> > 2^74207281 :: Integer
18:01:19 <lambdabot>  3003764180846061820529860983591660500568758630303014848439416933455477232190...
18:01:39 <EvanR> this lambdabot must be taking performance enhancing substances
18:01:45 <Ariakenom> parsnip, what channel did you intend that for? I need to widen my irc
18:02:56 <EvanR> the gmp backend :(
18:05:48 <parsnip> Ariakenom: the one for off-topic chatter, #emacs
18:07:51 <Welkin> there are many channels that are almost never on topic
18:07:55 <`Guest00000> the only types possible for constructors for a type are that type and functions to that type. can we meaningfully extend that to other types?
18:08:52 <malice> I want to write a function that will return function that returns True if passed value is 0 modulo the some other value, False otherwise. I'm new to Haskell. I wanted to try something like (== 0 $ flip mod value) but it doesn't work.
18:08:54 <malice> What am I doing wrong?
18:09:20 <Welkin> malice: avoid using $
18:09:41 <Welkin> write out the whole thing with the inputs
18:09:59 <ski> `Guest00000 : GADTs ?
18:10:03 <Ariakenom> makes sense? eh thanks, parsnip.
18:10:14 <`Guest00000> ski: what would be the meaning of "data N where Z :: N; S :: N -> N; Wtf :: (N, N)"
18:10:18 <Welkin> $ is function application and is a nasty hack used to avoid using parentheses and should be used sparingly
18:10:43 <`Guest00000> $ is a wonderful operator, which nevertheless should be used sparingly
18:10:47 <malice> I thought haskell people loved their $, >, <, =, | and others
18:10:56 <`Guest00000> Welkin is not haskell people
18:11:07 <Welkin> I used to like it because it made me feel celver
18:11:10 <ski> `Guest00000 : i dunno, but `data Vec a :: Nat -> * where Nil :: Vec a Zero; Cons :: a -> Vec a n -> Vec a (Succ n)' works
18:11:10 <Welkin> clever*
18:11:11 <Rembane> malice: Use a . instead.
18:11:14 <Welkin> but now I avoid using it
18:11:23 <Welkin> I limit it to specific use cases
18:11:44 <geekosaur> it has its place. but like anything else, it can be used for clarity or it can be used to obscure.
18:12:12 <`Guest00000> malice: a rephrasing is "func value = (== 0) $ (`mod` value)"
18:12:18 <`Guest00000> ooops
18:12:23 <`Guest00000> "func value = (== 0) . (`mod` value)"
18:12:36 <Welkin> now write it with points
18:13:18 <`Guest00000> need to hide exactly as many points as is best for focusing on how it functions
18:13:43 <Welkin> point-free is not good for anyone new to haskell
18:14:06 <Welkin> write with points and then perform eta reduction
18:14:17 <Welkin> and then eta substitution to get back tp ointful form
18:14:46 <`Guest00000> malice: anyway, a section (%%% something) always considers 'something' to be the second argument to %%%
18:15:16 <`Guest00000> so if you intend (== 0), then always write it inside parens
18:15:51 <malice> Second argument?
18:16:20 <`Guest00000> in (== 0), 0 is second argument to (==)
18:16:22 <malice> So (mod 5) is equvialent to flip mod 5 ?
18:16:26 <`Guest00000> no
18:16:29 <`Guest00000> (`mod` 5) is
18:16:38 <geekosaur> x %%% y    --> (%%%) x y
18:16:43 <`Guest00000> in (mod 5), mod isn't infix;  in (== 0), == is
18:16:57 <`Guest00000> in (`mod` 5), `mod` is infix;  in ((==) 0), == isn't
18:17:07 <malice> So (%%% something) considers something to be second argument only if %%% is an infix operator?
18:17:11 <`Guest00000> right
18:17:19 <`Guest00000> well
18:17:29 <`Guest00000> just "if %%% is an operator"
18:17:43 <`Guest00000> "infix" and "operator" are rather synonymous
18:18:03 <`Guest00000> can make an ordinary alphanumeric name an operator by enclosing it in ` `
18:18:14 <geekosaur> symbols = operators = inbfix; words = functions = prefix
18:18:34 <`Guest00000> can use an operator as a usual expression by enclosing in ( )
18:18:40 <`Guest00000> :t (+)
18:18:42 <lambdabot> Num a => a -> a -> a
18:18:45 <`Guest00000> :t (`mod`)
18:18:47 <lambdabot> error: parse error on input ‚Äò)‚Äô
18:18:49 <`Guest00000> hmm
18:18:59 <`Guest00000> doesn't work on `word`, but that's esoteric
18:19:12 <geekosaur> yeh, they're not nestable
18:19:24 <`Guest00000> (btw, that's BAD)
18:20:04 <`Guest00000> languages are immutable... the only way to change a language is to construct a new one...
18:20:16 <geekosaur> I think parens are a bit overloaded and there are a few corner cases
18:21:05 <ProofOfPizza> So I was reading along just now folks, about .'s and $'s. Why Would I prefer (nub . map (\(WalletEntry _ c _ _ _ _) -> c)) ws over nub $ map (\(WalletEntry _ c _ _ _ _) -> c) ws (just a random example in my code somewhere)
18:21:06 <centril> whoever said $ should be used sparingly is making me sad
18:21:11 <`Guest00000> i never could make sense of (flip smth) expressions, this always overloads my attention
18:21:14 <centril> I use $ everywhere, and it is lovely
18:21:27 <`Guest00000> Welkin you made centril sad
18:21:32 <ProofOfPizza> hehe
18:21:39 <centril> `Guest00000: you shall not 'flip'.
18:21:59 <zachk> i use func1 . func2 . .... $ arg pattern alot
18:22:11 <malice> so flips is bad too?
18:22:20 <malice> flip
18:22:26 <centril> malice: it's rude to flip something off.
18:22:41 <malice> useful though
18:22:42 <`Guest00000> i think it is good if it's clear, and bad if it isn't
18:22:59 <centril> zachk: I tend to make a new function  a = b . c . d  and then use  'a'
18:23:05 <`Guest00000> ProofOfPizza: you wouldn't prefer one of those; they are not equivalent
18:23:07 <Rembane> malice: You'll eventually develop a style that you can read. That's a good thing.
18:23:12 <c_wraith> ProofOfPizza, often when you use composition, it simplifies things. (and if it doesn't, you probably shouldn't use it)
18:23:59 <`Guest00000> oh wait
18:24:11 <`Guest00000> ProofOfPizza: they are equivalent, i was transiently blind.
18:24:31 <ProofOfPizza> ah phew... :)
18:24:40 <c_wraith> ProofOfPizza, the most common example is something of the form "foo x = bar (baz (quux x))" -> "foo = bar . baz . quux"
18:24:53 <centril> c_wraith: you can also expand your compositional toolkit with things such as kleisli composition (>=>), and the owl operator (.:) = (.) . (.)
18:25:08 <`Guest00000> btw you would probably prefer to them the following: (nub . map walletEntryC) ws
18:25:10 <ProofOfPizza> So if they are... which one to prefer and especially WHY ?
18:25:11 <`Guest00000> where WalletEntry is declared with a field walledEntryC
18:25:26 * centril 's nick on reddit is etareduce
18:25:28 <`Guest00000> ProofOfPizza: from those, i would choose just by personal tase
18:25:45 <`Guest00000> i like    nub $ map (...) $ ws   more
18:26:06 <zachk> you can replace the first n-1 $'s with a . usually `Guest00000
18:26:15 <zachk> well with .'s
18:26:19 <centril> using &&&, ***, first, second  is also fun
18:26:51 <ProofOfPizza> yeah, .'s but the there are arguments and () come in :)
18:27:09 <`Guest00000> i think . emphasizes the resulting function, and $ emphasizes data
18:27:21 <centril> `Guest00000: nub . fmap walletEntryC   is perfectly readable
18:27:32 <c_wraith> centril, that's not really convincing to me. I have written code with those kinds of things. eventually, they just were more hassle than they were worth. if the pipeline isn't simple composition, I'm happier being more verbose over years of maintenance.
18:28:02 <malice> lame questions incoming... not (x == y) ; how to write it in a shorter way?
18:28:14 <zachk> night
18:28:22 <c_wraith> malice, /= operator
18:28:46 <`Guest00000> @pl \x y -> not (x == y)
18:28:47 <lambdabot> (/=)
18:29:03 <`Guest00000> d'oh, pl knows about not ==...
18:29:11 <`Guest00000> @pl \x y -> not' (x == y)
18:29:12 <lambdabot> (not' .) . (==)
18:29:23 <centril> c_wraith: well yes, the trick is to separate the parts of the pipeline that are not simple composition and therein use do notation, etc.
18:29:34 <centril> Balance all the things.
18:30:21 <centril> @pl let (.:) = (.) . (.) in not .: (==)
18:30:21 <lambdabot> (line 1, column 5):
18:30:22 <lambdabot> unexpected "("
18:30:22 <lambdabot> expecting "()", natural, identifier or "in"
18:33:30 <malice> Time to call it a night. Thanks for help!
18:34:11 <centril> If I say: 'constraint-parametric polymorphism', what you infer this to mean?
18:35:05 <ProofOfPizza> hmm still thinking about this "where WalletEntry is declared with a field walledEntryC" ... found it thx! (nub . map currency) ws is much nicer!
18:35:22 <ProofOfPizza> (took some time to process :) )
18:36:06 <`Guest00000> centril: when there's a point ws, i usually disprefer that to "nub $ fmap walletEntryC $ ws"
18:36:47 <centril> `Guest00000: then you have to make up a 'ws' name, and I hate naming shit
18:37:02 <`Guest00000> i mean when it's already named
18:37:17 <centril> `Guest00000: I try hard not to name things
18:37:40 <centril> `Guest00000:  \case  {-# LANGUAGE LambdaCase #-}  helps a lot
18:37:48 <`Guest00000> if it's not named, then you're writing an expression for a function instead of expression for its result
18:37:57 <`Guest00000> yes, LambdaCase is good
18:38:18 <centril> I really hope LambdaCase makes it to the next report
18:39:16 <ProofOfPizza> yeah about names: I turned on -Wall today and it complains everywhere about shadowing stuff. I understand that, but  usually don't mind. In fact, (coming from Java?) it seems logical in many cases.... is it considere bad practice in haskell ?
18:39:44 <MarcelineVQ> it's bad practise if you didn't do it on purpose hehe
18:40:01 <centril> `Guest00000: my preferred programming style is to use ghci and define small functions mostly with LambdaCase and composition, and then use  :r :t  in ghci to infer the type, put the type in the editor, and then continue
18:40:25 <centril> so I take advantage of global type inference, but just temporarily
18:41:46 <centril> ProofOfPizza: coming from Java, you need to unlearn (a lot) of what you have learned
18:42:05 <centril> like all the design patterns nonsense and stuff
18:44:08 <ProofOfPizza> yeah, which is nice. I really prefer haskell. Makes much more sense. More thinking, less writing. And the topics of discussion are much more interesting I think. So, I just keep at it !
18:45:20 <ProofOfPizza> Ususally when someone recommends a topic in java it's about something I don't know. In haskell many times it's about something I don't understand. Much more fun!
18:45:49 <dexterfoo> has name shadowing ever caused a problem for anyone in haskell? i know it can cause nasty bugs in other languages, but with haskell you have very strong types and short functions, i think name shadowing bugs wouldn't happen
18:45:56 <centril> ProofOfPizza: actually, sometimes Haskell helps a lot with thinking and helping you think less wrong... you can get the type system to "generate code" for you even
18:46:16 <centril> the type system is a powerful ally
18:47:14 <centril> ProofOfPizza: this talk is excellent: https://www.youtube.com/watch?v=3U3lV5VPmOU
18:47:23 <ProofOfPizza> We're slowly becoming friends, it's a bit cryptic in the way it throws me exceptions sometimes... getting used to it..
18:48:13 <ProofOfPizza> thx! saved it, check it out later
18:48:37 <centril> =)
18:48:51 <MarcelineVQ> > (\x -> (\x -> "if this isn't 8 someone will die: " ++ show x ++ ". doh") 6) 8  -- type system won't save you from yourself, or using the wrong value of the right type
18:48:54 <lambdabot>  "if this isn't 8 someone will die: 6. doh"
18:49:24 <centril> MarcelineVQ: dependent types might?
18:49:33 <MarcelineVQ> it depends
18:49:41 <centril> MarcelineVQ: ^,- it always does
18:53:34 <centril> MarcelineVQ: btw... if I say  "constraint-parametric polymorphism", what do you think the term means?
18:54:59 <MarcelineVQ> hmm, idk,     (f a) => Foo a
18:55:45 <centril> MarcelineVQ: yeah, more or less =) --  'trait-parametric polymorphism' seems to work less well in #rust
18:55:52 <centril> I'm trying to find a better name for ConstraintKinds
18:56:39 <MarcelineVQ> like ConstraintAlias ? :>
19:00:38 <centril> MarcelineVQ: well... in Rust you'd be allowed to write:  trait Map { trait KeyBound; .. }   (associated trait),   struct BoxedFoo<trait C>(Box<Foo + C>);    fn foo<trait C, T: C>(x: T) {..}    type HeapExist<trait C> = Box<C>;
19:01:25 <centril> so it's not just about aliases, but rather allowing shit to be parameterized by traits/typeclasses/bounds/constraints in general
19:50:04 <elpfen> Any good libs I could use to get image dimensions? Tried JuicyPixels and HIP but they both load the entire image instead of just grabbing the metadata
19:50:55 <Welkin> elpfen: you can write your own parser for the header
19:51:21 <Welkin> it should be easy using bytestring and bit manipulations
19:53:59 <`Guest00000> heh
19:54:06 <`Guest00000> with Haskell
19:54:11 <`Guest00000> libraries
19:54:16 <cppxor2arr> how do you uninstall packages installed with cabal? is there a better tool for managing packages?
19:54:41 <Welkin> cabal is not a package manager
19:54:49 <Profpatsch> Is Any the dual of Void?
19:54:49 <Welkin> you can use ghc-pkg to uinstall a package
19:54:53 <Welkin> or to hide it
19:54:59 <Welkin> Profpatsch: () ?
19:55:07 <Profpatsch> Unit is the dual?
19:55:11 <Welkin> no idea
19:55:17 <Profpatsch> Probably depends on the category you are in.
19:55:24 <cppxor2arr> i tried `ghc-pkg unregister --force <package>` with still left the files from the package behind
19:55:41 <Profpatsch> I have a toy type system where the check function for the void scalar type is const True
19:55:46 <Profpatsch> err, const False
19:55:58 <Profpatsch> And any is const True correspondingly.
19:56:29 <Welkin> cppxor2arr: unregistering is all it does
19:56:31 <Welkin> it does not delete them
19:57:04 <Welkin> you can look at the cabal new* commands for a nix-like setup
19:57:10 <Welkin> where it *is* more like a package manager
19:57:22 <Welkin> or even use full-on nix with cabal
19:57:53 <Welkin> when the package is unregistered, it is treated as though it doesn't exist any more
19:58:07 <Welkin> but if you later want to "reinstall" it, all it does it register it again
19:58:42 <cppxor2arr> what do you mean by "cabal new* commands"?
19:58:59 <Welkin> https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
19:59:39 <Welkin> it is the new version of cabal that will replace the current one
20:00:34 <Welkin> I still need to try it out
20:00:36 <Welkin> it looks very nice
20:01:05 <boj> 8.2 ships with it, and it is apparently backwards compatible with the prior version
20:01:15 <boj> or so i learned today
20:01:28 <Welkin> yeah I noticed it with 8.2.2 that I installed today
20:01:33 <`Guest00000> Unit is the dual of Void because Unit, Void are the terminal, the initial objects
20:02:30 <Welkin> having not used haskell platform in a while, I installed it today, and I was surprised at how fast it was
20:02:35 <Welkin> it was done in a couple seconds
20:07:46 <Profpatsch> Welkin: I already asked you that I think, but do you know the game Valkyria Chronicles?
20:08:24 <Welkin> Profpatsch: yes, I have it
20:10:27 <Welkin> I have never actually read the whole cabal guide, or the whole haskell report, or the whole ghc user's guide
20:10:30 <Welkin> I think I should
20:10:33 <Welkin> it might take a while
20:11:17 <monochrom> I quickly glanced through the whole cabal guide.
20:11:34 <Welkin> cabal has a lot of cool features
20:11:36 <monochrom> Haskell Report is more like lazy on-demand reading.
20:11:39 <Welkin> even branching logic
20:12:01 <Welkin> I've been referencing the haskell 2010 report while writing my book to make sure I get the names of things right
20:13:54 <Welkin> that is usually how I learn things, lazily
20:14:12 <Welkin> I learn the minimum that is needed to accomplish something I am trying to do, then move on
20:14:22 <Welkin> but learning something for the sake of learning it is also satisfying
20:14:44 <Welkin> and I have a lot of gaps in my haskell knowledge that I want to fill
20:18:57 <bontaq> aight I'm definitely doing something goofy.
20:19:07 <bontaq> I have data Path = Path String
20:19:33 <bontaq> then later I'm doing cleanPaths = fmap (\(Path p) -> Path $ cleanPath p) ps'
20:19:39 <Welkin> type FilePath = String
20:19:47 <Welkin> that already exists (but is just a synonym)
20:20:18 <Welkin> you are using $ wrong
20:20:33 <Axman6> huh? looks fine to me
20:20:49 <Axman6> oh, you're missing the argument ps' to cleanpaths
20:20:58 <monochrom> Not even wrong until and unless the code for cleanPath is revealed.
20:21:10 <Axman6> (you should just delete ps' from the end of the line)
20:21:27 <Axman6> assuming you're intending cleanPaths to be a function :: [Path] -> [Path]
20:21:31 <bontaq> cleanPath p = foldr (\a b -> if a == '.' then b else a : b) "" p -- It's just filtering out '.'
20:21:53 <Welkin> bontaq: you can use filter instead
20:22:03 <Welkin> filter (== '.')
20:22:12 <Axman6> filter (/= '.')
20:22:25 <Welkin> yeah
20:23:25 <bontaq> that's much nice, ty welkin.  for some reason I thought fmap would just magically work so I could skip the unwrap/rewrap step in cleanPaths
20:26:23 <Welkin> > fmap (filter (\= '.')) ["/usr/bin/hello.bin","/dev/null"]
20:26:26 <lambdabot>  error:
20:26:26 <lambdabot>      ‚Ä¢ Variable not in scope: (\=) :: Char -> Char -> Bool
20:26:26 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
20:26:39 <Welkin> bontaq: fmap should just work if you define a Functor instance for your data type
20:26:47 <Welkin> > fmap (filter (/= '.')) ["/usr/bin/hello.bin","/dev/null"]
20:26:51 <lambdabot>  ["/usr/bin/hellobin","/dev/null"]
20:27:24 <Welkin> you can fmap twice then
20:27:29 <Welkin> if `ps` is a list of paths
20:28:06 <Welkin> > fmap (fmap (filter (/= '.'))) [Just "/usr/bin/hello.bin",Just "/dev/null"]
20:28:09 <lambdabot>  [Just "/usr/bin/hellobin",Just "/dev/null"]
20:28:47 <Welkin> > (fmap . fmap) (filter (/= '.')) [Just "/usr/bin/hello.bin",Just "/dev/null"]
20:28:50 <lambdabot>  [Just "/usr/bin/hellobin",Just "/dev/null"]
20:29:47 <bontaq> I tried out defining a functor, but since it's just data Path = Path String it complains when I try out instance Functor Path where ...
20:30:02 <Welkin> oh yeah
20:30:16 <Welkin> Functor must have kind * -> *
20:30:28 <Welkin> so it would need to be `data Path a = Path a`
20:30:31 <Welkin> but you don't want that
20:30:32 <Welkin> I see
20:38:23 <Axman6> bontaq: you might find defining a function onPath :: (String -> String) -> Path -> Path is useful if you you're doing several things like this. then your program would be fmap (onPath cleanPath)
20:39:35 <bontaq> ooh, that's nice!  thanks Axman6
21:08:00 <EvanR> Enum is a super class of Integral...really...
21:09:28 <EvanR> and Real ?
21:09:37 <EvanR> guess i knew that
21:56:46 <EvanR> on the subject of whether primitive recursion on Nat, or similar folds over inductive types allows you to write "any" total function... i found some blurb that says... since we have higher order functions, you at least have all functions that can be proven total in first order logic. page 9 of Turner "Total functional programming"
21:59:41 * EvanR gets scared by references to *-order logic
22:02:08 <EvanR> man (^) isnt a class method
22:07:49 <nanoz> hi
22:08:10 <nanoz> i got into issue with arabic characters+english mixed
22:08:57 <nanoz> on copy from excel to any other editor it gets jumbled
22:13:45 <parsnip> which editor?
22:14:13 <parsnip> doesn't excel use encoding iso-latin or something?
22:15:18 <parsnip> maybe you can convince excel to use utf-8?
22:15:32 <EvanR> i have no heard of excel supporting utf-8
22:15:59 <EvanR> is it the dawning of the age of aquarius?
22:35:07 <ab9rf> excel supports utf-8
22:35:10 <ab9rf> has for years
22:35:58 <EvanR> o_O
22:36:25 <ab9rf> at least since 2007
22:37:05 * EvanR uses "offtopic" to win the argument
22:37:35 <ab9rf> hehe
22:39:04 * EvanR turns a crappy chair backwards and sits down
22:39:09 <EvanR> so exponentiation by squaring
22:39:22 <EvanR> seems really slow
22:40:08 <EvanR> if the power has like 100 bits, you do like 100 multiplications
22:42:20 <EvanR> wait thats a ridiculous big power
22:46:03 <ab9rf> heh
22:56:30 <nanoz> i converted .xlsx file to .zip , on viewing `sharedstrings` , in IE the strings aka arabic+latin works fine but on other browser it doesnt -FF/chrome
22:57:25 <EvanR> I have experienced the .xlsx format reporting the wrong encoding of itself
22:57:47 <EvanR> which doesnt bother I.E. maybe
23:01:56 <nanoz> i wonder how to get these sequence of characters on correct order :/
23:02:33 <EvanR> are they the wrong characters, or in the wrong order?
23:02:57 <nanoz> the excel has the correct values
23:03:02 <nanoz> ill give a screen shot
23:03:20 <EvanR> the way they are displayed depends on the presentation, which may confuse you about the order they are in in the data
23:03:38 <ab9rf> rtl/ltr issue?
23:03:47 <EvanR> many programs will not properly show a mix of arabic and english
23:03:53 <EvanR> orderingwise
23:04:02 <EvanR> but the data can still be correct
23:04:10 <ab9rf> rendering text with mixed direction is difficult
23:04:20 <ab9rf> many apps do not handle mixed-direction text correctly
23:05:37 <nanoz> to my note
23:05:49 <nanoz> its sequence of characters
23:05:58 <nanoz> why it cant display
23:06:18 <EvanR> still not sure what the specific issue is, or what it has to do with haskell
23:07:02 <nanoz> ŸÇŸÖŸÜÿß ÿ®ÿßÿ±ÿ≥ÿßŸÑ {0} ÿ±ÿ≥ÿßŸÑÿ© ÿØÿπŸàÿ© ŸÑŸÑÿ•ŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸâ ÿÆÿØŸÖÿ© ŸÅŸÑŸàÿ≥ŸÉ.
23:07:17 <nanoz> this is text
23:07:17 <EvanR> this is essentially "help, something offtopic 'doesnt work'"
23:07:42 <EvanR> IRC clients probably dont display it right
23:07:53 <nanoz> sorry!
23:07:56 <EvanR> thats entirely backwards to me
23:08:51 <nanoz> ŸÑŸÇÿØ ÿ™ŸÖ ÿπŸÉÿ≥ ÿßŸÑŸÖÿ®ŸÑÿ∫ {0} ŸÑŸÑÿπŸÖŸÑŸäÿ© ÿ±ŸÇŸÖ  {1}ÿå ÿ±ÿµŸäÿØŸÉ {2}
23:09:24 <nanoz> on irc client it  works fine oO
23:09:34 <EvanR> like hell
23:09:45 <ab9rf> from here it looks like a cat sat on your keyboard
23:11:14 <nanoz> if i paste this on any editor
23:11:21 <nanoz> the words gets jumbled
23:11:43 <EvanR> programming editors cant handle stuff like arabic
23:12:25 <nanoz> isnt programming means solving?
23:12:34 <ab9rf> it's fairly rare for programing editors to have fully functional support for RTL text
23:13:03 <EvanR> or variable width, ligature... (unless you are programming in MS word)
23:13:07 <ab9rf> which means that languages that are normally RTL (such as hebrew and arabic) are unlikely to render well in the editor.
23:13:35 <ab9rf> languages that heavily rely on combining forms are also likely to render poorly
23:13:40 <EvanR> so in any case you can type it in, and be unable to read it
23:13:45 <nanoz> mix of arabic+english leads to hell!
23:13:47 <ab9rf> devangari has this problem iirc
23:14:22 <EvanR> the best you can hope for is that the text data is correct in your string literals, when it finally finds its way to a browser it will show properly
23:14:41 <EvanR> you cant expect to be able to read it in the source code in an editor
23:14:54 <nanoz> i want to disable rtl on editor :) and read it as sequence of character
23:15:08 <EvanR> i dont think thats going to happen
23:15:35 <nanoz> how it works on browser?
23:15:38 <cppxor2arr> the arabic shows up fine on my terminal in weechat
23:15:39 <EvanR> er.. what editor is doing rtl
23:15:39 <huy> I think it's just font's matter
23:15:55 <nanoz> particularly IE :/
23:19:43 <nanoz> iwant to disable RTL :) on vscode/sublimetext/notepad
23:19:54 <nanoz> even on notepad :'(
23:20:10 <EvanR> try asking in a channel for those programs
23:20:47 <nanoz> EvanR, thanks for you help , should i join any excel community to figure out?
23:31:48 <nanoz> was trying to convert string to hexa and store on db and later retrieve hex and convert back that seems to work , only if the file dont interupt arabic and interupt and jumble the words
23:52:02 <EvanR> cool google has absolutely no info on "natural numbers" because apparently someone has SEOd the "debate" about whether 0 is a natural number for the first 10 pages
23:53:13 <ab9rf> anything to make a buck
23:53:32 <EvanR> c2wiki...
23:54:24 <EvanR> this is like pluto being a planet
23:55:17 <Disavowed> EvanR: I disagreed with the deplanetisation until I saw it was smaller than Australia.
23:55:56 <MacSlow> companies specializing in seo should burn for eternity ;)
23:56:33 <EvanR> at least you have criteria
