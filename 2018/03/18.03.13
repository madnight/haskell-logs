00:22:56 <crysikrend> where can I learn about mtl style? :)
00:23:16 <crysikrend> People have guided me to look at that for making games in haskell
00:28:40 <cocreature> crysikrend: I don’t know of a good introduction but I don’t think mtl is a prerequisite for making games
00:29:23 <cocreature> crysikrend: generally, try to get familiar with monad transformers then at some point you’ll probably reinvent something like the mtl or at least you see the problems it aims to solve
00:29:58 <crysikrend> Its not, but I was kind of inspired by this blog http://jxv.io/blog/2018-02-28-A-Game-in-Haskell.html
00:30:57 <sl2c> Is there anything you recommend for monad transformers?
00:31:30 <crysikrend> I get what you're saying cocreature :) I'll look them up
00:32:48 <cocreature> sl2c: never really searched for anything. I’ve found that most people end up discovering the concept themselves at some point when they end up having to make a bunch of nested case statements to deal with something like Maybe while being in a different monad and at that point you start to grasp monad transformers very quickly
00:33:32 <crysikrend> sounds like my past 6 hours in a nutshell
00:48:07 <simbon> Is there some function of Monad is "m a -> (a -> b) -> m b"?
00:48:41 <simbon> I just find that >>= is "m a -> (a -> m b) -> m b"
00:48:53 <phadej> :t flip fmap
00:48:55 <lambdabot> Functor f => f a -> (a -> b) -> f b
00:49:09 <phadej> :t (<&>)
00:49:09 <crysikrend> no you just fmap it
00:49:10 <lambdabot> Functor f => f a -> (a -> b) -> f b
00:49:15 <crysikrend> ah damn someone beat me
00:49:45 <simbon> Thanks, very much
00:50:21 <crysikrend> phadej: didn't realise <&> was the opposite of <$>
00:50:26 <simbon> I'm a new hand, very glad to study haskell and join this channel
00:51:14 <phadej> crysikrend: it is, and IIRC even in base-4.11 (GHC-8.4.1)
00:51:38 <simbon> :t (<&>)
00:51:38 <akr> what is going on here? http://lpaste.net/1462471703278911488
00:51:39 <crysikrend> good to now
00:51:40 <lambdabot> Functor f => f a -> (a -> b) -> f b
00:51:51 <simbon> Wow, That's so cool
00:52:09 <cocreature> akr: try "cabal install --only-dependencies"
00:53:09 <akr> cocreature: that did it, thanks… cabal is still a huge mystery to me
00:53:35 <crysikrend> akr: you'll get there!
00:53:35 <cocreature> akr: fwiw "cabal new-build" automatically installs missing deps
00:54:44 <akr> ah, okay
00:55:13 <cocreature> akr: also if you’re confused about why "cabal info pointed" works, note that it says “Versions installed: [ Not installed ]”
00:55:23 <cocreature> cabal info does not only show you info about installed packages
00:55:41 <jchia> Question about cassava (Data.Csv). If I have two CSV schemas (column names and how to process each column) A and B, where the set of columns in A is a proper subset of that of B, how do I express the record types for A and B while still deriving the FromRecord instances considering name collision of the field names if I explicitly make two record types for A and B?
00:55:42 <akr> yeah I just assumed that cabal build would get the missing dependencies… I mean, that's how it usually works with other package managers
00:55:50 <akr> cocreature: ^
00:56:06 <cocreature> the "cabal build" interface is not particularly good about the “just do what I mean” part
00:56:13 <akr> heh
00:56:15 <cocreature> luckily new-build is a significant improvement in that regard
00:57:36 <tdammers> "do what I mean" is dangerous, because programs usually implement "do what you think I mean" instead
00:58:43 <cocreature> jchia: 1. define the record types in different modules 2. use DuplicateRecordFields (requires ghc >= 8.0) 3. implement at least one of the instances yourself
00:59:29 <tdammers> I'd go with 1.
00:59:46 <tdammers> just because two columns have the same name and type doesn't mean they're the same thing
01:00:18 <tdammers> and even if they are, I'd still consider the types that you directly convert to and from CSV an intermediate representation
01:00:47 <tdammers> in general, it's often better to do serialization format <-> intermediate types <-> domain types, than serialization format <-> domain types
01:01:07 <tdammers> goes for anything, not just CSV: JSON, SQL, etc.
01:01:29 <jchia> In my case, I'm using A and B records to do something. For B, it's the same as A plus some extra things based on field specific to B.
01:02:05 <tdammers> so the question is how do you model your domain types
01:02:28 <tdammers> data Thing = ThingA A | ThingB A B -- is one way
01:02:48 <tdammers> don't think derived CSV instances would work out for that though
01:03:41 <tdammers> could also use the same type for both A and B, and make the B fields optional (using Maybe)
01:04:21 <tdammers> either way, I think letting go of the automatically-derived instance is probably the way to go here, at least partially
01:05:25 <jchia> tdammers, I'm going to derive A  and (B - A) and put them together manually in B
01:06:25 <tdammers> sounds reasonable
01:08:05 <jchia> I'm so hoping that haskell will get row polymorphism.
01:11:01 <tdammers> it would be really helpful to see an example in a real programming language that actually works well
01:11:28 <tdammers> I had big hopes for purescript, but its extensible records sacrifice quite a lot compared to Haskell's records
01:13:58 <cocreature> tdammers: could you elaborate on that? I’ve never used purescript so I’m curious about the downsides there of having added extensible records
01:14:55 <tdammers> cocreature: one particularly annoying thing is that given data Foo = Foo { bar :: Baz }, Foo { bar = baz } is still valid, but Foo baz is not
01:15:25 <tdammers> cocreature: so when you design your types, you have to decide whether it should be a record type or not, and if it is, you can *only* access fields with record syntax
01:17:02 <cocreature> ah I can see that being annoying
01:17:49 <tdammers> in practice, there are also some subtleties that can be annoying, like when you need to combine effects in a somewhat generic fashion
01:18:10 <tdammers> e.g., adding the Console effect to something that already has the Console effect doesn't work
01:19:02 <tdammers> although one could argue that the problem there is using extensible records to represent effects, and the choice of effects to represent and how they are structured, not the extensible records feature itself
01:21:03 <jchia> tdammers: Why is Foo baz invalid?
01:21:23 <akr> argh, what's wrong now http://lpaste.net/363491
01:21:24 <tdammers> jchia: because in Purescript, record types can only be accessed with record syntax
01:21:55 <tdammers> jchia: you can have Foo baz, but then you have to declare it as data Foo = Foo Baz, and you can't use record syntax on it at all
01:21:58 <jchia> tdammers: Is there any ambiguity with "Foo baz" that makes it not understandable?
01:22:33 <tdammers> jchia: honestly, I don't know, my guess would be that they designed (extensible) records and algebraic data types as completely separate things
01:23:37 <tdammers> point in case, when you consider that being "close to JavaScript" was an important design goal, it makes a little bit more sense, since extensible records are basically JS objects, while product types can be modelled as arrays
01:31:26 <guessWho> i have a list m of type [(a,b)] i want to do a lookup with a as key and the tuple which matches i wan't to remove it from the list
01:34:02 <dibblego> guessWho: have a look at the filter and fst functions
01:34:29 <dminuoso> EvanR: Not sure in what dimension KindRepTYPE is useful. Are you talking about the un-promoted KindRep or the promoted one?
01:34:55 <Ariakenom> guessWho, dibblego: Seems more reasonable to use lookup and remove
01:35:07 <Ariakenom> not remove delete, sry
01:35:12 <dminuoso> guessWho: that's foremost a `filter`
01:35:18 <dibblego> Ariakenom: I disagree, unless you mean zipper functions
01:35:23 <dminuoso> guessWho: so you just need some predicate that can do (a, b) -> Bool
01:36:01 <Ariakenom> dibblego, oh yeah filter makes sense
01:36:41 <dminuoso> > filter (odd . fst) [(1,'a'), (2,'b'), (3,'c'), (4, 'd')]
01:36:44 <lambdabot>  [(1,'a'),(3,'c')]
01:36:47 <guessWho> dminuoso : how to use filter here >?
01:37:46 <guessWho> dminuoso : i mean first parameter for filter is (a -> Bool) and for lookup is a -> [(a, b)]
01:37:58 <dminuoso> guessWho: "for lookup" ?
01:38:33 <guessWho> dminuoso : i meant type signature for lookup *
01:38:56 <dminuoso> guessWho: What?
01:39:03 <Ariakenom> guessWho, you dont need lookup. what's the type "a" in filter?
01:40:18 <guessWho> Ariakenom : its a type variable
01:40:30 <Ariakenom> yes but when applied to your list
01:40:32 <dminuoso> guessWho: I just showed you how.
01:40:51 <dminuoso> guessWho: If you have a more specific question, then you need to share your code or type signature.
01:41:14 <guessWho> dminuoso : oh i didn't see your code let em try that out
01:42:09 <Rukako> how good and easy is haskell with dependant types? I tried Idris and it seemed quite nice and simple but I had some bad experiences with it after using it for a while, mostly due to the immature toolchain and so I was wondering how ghc was doing on that front.
01:42:15 <Rukako> a-also hi
01:42:26 <dminuoso> Rukako: https://www.youtube.com/watch?v=wNa3MMbhwS4
01:43:12 <Rukako> thank you, I will make sure to check it
01:43:37 <guessWho> dminuoso : i think that won't work for me because i have a list of type [(a,b)] now i want to remove an element from the list by searching the a in all tuples within the list
01:43:58 <dminuoso> Rukako: That's mostly a "kind of dependent typing". It's gradually coming into Haskell, you can track the progress at https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell/Phase1 and its parent https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell
01:44:39 <guessWho> dminuoso : so for eg say i have a = [(1,"one"),(2,"two"),(3,"three")] now i want a new list from a where i can say search for 2 and delete the resulting entry
01:45:10 <dminuoso> guessWho: You might be interested in Data.Map :-)
01:45:19 <opqdonut> > deleteBy ((==2).fst) [(1,"one"),(2,"two"),(3,"three")]
01:45:21 <lambdabot>  error:
01:45:22 <lambdabot>      • Couldn't match type ‘Bool’ with ‘(a, b) -> Bool’
01:45:22 <lambdabot>        Expected type: (a, b) -> (a, b) -> Bool
01:45:32 <opqdonut> argh
01:46:01 <opqdonut> > deleteBy (\(x,y) (a,b) -> a==x) (2,"whatever") [(1,"one"),(2,"two"),(3,"three")]
01:46:04 <lambdabot>  [(1,"one"),(3,"three")]
01:46:22 <opqdonut> > deleteBy ((==)`on`fst) (2,"whatever") [(1,"one"),(2,"two"),(3,"three")] -- more succinctly
01:46:25 <lambdabot>  [(1,"one"),(3,"three")]
01:46:27 <dminuoso> Though it's not a real "lookup", since you could have duplicate entries. It really does sound like you want Data.Map semantics though.
01:46:56 <opqdonut> > deleteBy ((==)`on`fst) (2,"whatever") [(1,"one"),(2,"two"),(3,"three"),(2,"seven")] -- note the behaviour here
01:46:59 <lambdabot>  [(1,"one"),(3,"three"),(2,"seven")]
01:47:00 <dminuoso> opqdonut: Ah `on` is a cool combinator.
01:47:06 <opqdonut> I love it
01:47:13 <Rukako> I fail to see how filter would not work in this case
01:47:23 <ZeuPiark> hello
01:47:24 <opqdonut> filter is fine too
01:47:44 <dminuoso> Except if you have the guarantee that a key will occur only once, then `filter` will force the entire list
01:47:49 <dminuoso> Unnecessarily
01:48:31 <Rukako> ah, I did not know that deleteBy halted on the first result
01:48:33 <opqdonut> I guess if your alists are so long that you bump into performance issues like that, you should be using something else
01:48:44 <opqdonut> like Map Int [String]
01:54:21 <Ariakenom> @type filter
01:54:22 <lambdabot> (a -> Bool) -> [a] -> [a]
01:54:57 <Ariakenom> @type filter undefined (undefined::[(a,b)])
01:54:59 <lambdabot> [(a, b)]
02:08:05 <ertes-w> ello
02:27:08 <dminuoso> So TypeRep is a type of reified types?
02:32:16 <dminuoso> > let a = KindRepTYPE UnliftedRep in 1
02:32:18 <lambdabot>  error:
02:32:18 <lambdabot>      Data constructor not in scope: KindRepTYPE :: t0 -> terror:
02:32:18 <lambdabot>      Data constructor not in scope: UnliftedRep
02:32:24 <dminuoso> % let a = KindRepTYPE UnliftedRep in 1
02:32:25 <yahb> dminuoso: ; <interactive>:1:9: error: Data constructor not in scope: KindRepTYPE :: RuntimeRep -> t
02:42:17 <dminuoso> EvanR: Well it's certainly interesting to play around with this http://lpaste.net/363493 - was your reference to KindRepTYPE that it allowed me to "touch" kinds like I wanted to?
02:42:55 <dminuoso> This kind of reflection is rather horrid to look at sadly. :(
02:44:35 <sdrodge> dminuoso: Is all this playing around with TypeRep stuff by any chance somehow inspired by my question from earlier?
02:45:25 <dminuoso> sdrodge: Not exactly, though I answered your question because I am playing with this. :)
02:46:46 <sdrodge> Ah :)
02:47:48 <al314> Hi all, how can I mimic the next Ocaml code in Haskell? http://lpaste.net/363495  (just to defined the object/structure Lamp with a given set of properties). Should I use classes or just a `data' keyword?
02:47:49 <dminuoso> sdrodge: I recently amused myself with writing a little GHC patch - and that caused me to see some bits and parts of the type checker.
02:48:16 <sdrodge> Sounds scary but exciting.
02:48:51 <merijn> sdrodge: GHC (except for the type checker) is a surprisingly accessible/hackable codebase
02:49:14 <dminuoso> And merijn is guilty!
02:49:15 <sdrodge> I have actually peeked before and was pleasantly surprised (having also peeked at Idris and gcc)
02:49:16 <dminuoso> :-)
02:49:18 <merijn> sdrodge: I think 2 of my 3 or 4 first open source Haskell contributions were minor GHC patches :p
02:49:29 <sdrodge> (no offense to Edwin Brady and those wonderful folks)
02:49:44 <dminuoso> sdrodge: gcc is the largest horrid construct Ive ever seen in open source.
02:50:00 <merijn> dminuoso: gcc is (or at least was) partially obfuscated on purpose
02:50:10 <dminuoso> merijn: Why?
02:50:12 <merijn> To make wrapping it with proprietary tools harder
02:50:23 <dminuoso> Interesting, that's the first I've heard of this
02:50:25 <sdrodge> RMS didn't want the AST to be accessible by external tools.
02:50:52 <sdrodge> https://lwn.net/Articles/629259/
02:51:41 <Athas> al314: that does not have a nice analogue in Haskell.
02:52:15 <Athas> You can do something like declare an (immutable) record which you then manipulate in a state monad, but it is not going to be very nice.
02:52:45 <merijn> Athas: Well, if you don't mind your operations being IO you could mimic it fairly directly as a record and an IORef captured in a closure
02:53:18 <dminuoso> merijn: Fair enough, that seems to be just the AST though.
02:53:44 <Athas> merijn: that is certainly not nice!
02:53:55 <merijn> dminuoso: Well, the AST/IR is a pretty fundamental and big part of the compiler :p
02:54:10 <merijn> Athas: Pfft, you just gotta tweak your sense of aesthetics to match :p
02:54:25 <dminuoso> merijn: But it still drastically reduce hackability. And then GCC is plagued by hacks like FIXINCLUDES, which if it for bizarre reasons affect you, cause you to debug for weeks until you understand what the heck is going on.
02:55:40 <joncol> Is anyone else getting problems with Emacs/Intero, lts-11.0? I get "Could not install Intero" error when I try to open a .hs file in Emacs, after having done "stack new". It also says: AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
03:02:00 <barrucadu> joncol: Update to stack 1.6
03:07:30 <joncol> barrucadu: Yes, I just realized I had another old 1.5 stack laying around in /usr/local/bin. Deleting this solved the problem.
03:08:29 <dminuoso> merijn: What is the real purpose behind TypeRep and all the reflection machinery that goes along with it?
03:08:53 <dminuoso> I mean it's cool to play with types and kinds on the value system, but it escapes me what cool and productive things I could do with it
03:09:54 <merijn> dminuoso: Because the compiler knows about TypeReps and thus can optimise things based on that
03:10:10 <barrucadu> dminuoso: I've used TypeRep to generate well-typed monadic expressions so I could try to discover properties of a collection of functions.  I expect QuickSpec / Speculate also use TypeRep/Typeable for that.
03:10:20 <merijn> dminuoso: You know how excessive thunking in, e.g. foldl can leak memory?
03:10:24 <barrucadu> But beyond code generation like that I'm not really sure what I'd use it for
03:10:24 <dminuoso> Yes
03:10:42 <merijn> dminuoso: It's "obvious" that, e.g. summing an Int lazily is pointless
03:10:54 <merijn> dminuoso: i.e. it's basically always faster to do that strict
03:11:20 <merijn> dminuoso: GHC has a rather complicated strictness analyzer that tries to detect cases like that and convert them into strict additions in machine code
03:11:55 <merijn> dminuoso: But if you write code directly working with Int# it can skip the complicated analysis and just generate said strict code because Int# is wired into the compiler/codegen
03:12:27 <dminuoso> So far so good
03:12:33 <merijn> dminuoso: TypeRep exists to make writing code with, e.g. Int# more firstclass
03:12:45 <merijn> dminuoso: Like the example of ($) being TypeRep polymorphic
03:12:59 <merijn> dminuoso: So you're not limited to a bunch of ugly built-in primitives
03:13:23 <dminuoso> merijn: but the ($) polymorphism is in the promoted universe
03:13:40 <dminuoso> merijn: I mean how can a TypeRep value propagate back into the type world (if at all)
03:13:59 <merijn> dminuoso: I'm not sure I understand that question?
03:14:31 <dminuoso> merijn: well the ($) polymorphism is not around TypeRep, but around the promoted RuntimeRep kind
03:14:48 <cocreature> I think merijn is confusing RuntimeRep with TypeRep from Type.Reflection
03:14:58 <merijn> Yeah, I think I got mixed up
03:15:32 <merijn> dminuoso: TypeRep is just for beating the compiler into doing what you want when (you think) you know better :p
03:17:57 <cocreature> dminuoso: the advantage of the type-indexed version of TypeRep is that you can have things like eqTypeRep
03:17:57 <dminuoso> merijn: By means of cast/gcast?
03:18:17 <merijn> dminuoso: For example
03:19:17 <cocreature> and you can safely do things like get the TypeRep of the return type of a function
03:22:15 <veritas> hello everyone
03:22:17 <dminuoso> cocreature: Ah.. I guess reflection could become interesting for things like GHC or GHCi.
03:22:53 <dminuoso> Had this idea and searched through the code base, there seems to be some good usage of these reflection tools.
03:23:39 <merijn> dminuoso: Mostly I've used it where I've had GADTs capturing existentials so I *knew* a conversion would work and then just use Typeable to get GHC to actually do it
03:24:40 <dminuoso> Data.Typeable was a scary beast some months ago, now it just looks rather "boring" and just "overly verbose"
03:25:57 <merijn> dminuoso: It basically allows you to convert a type to "itself" at runtime. Which is only ever useful if you somehow LOST it's type in the first place
03:26:17 <dminuoso> cocreature: What's the concrete meaning of "type-indexed" in that? Just that its parametrized over a type?
03:26:19 <merijn> via existentials, GADTs, and similar messes
03:26:22 <merijn> dminuoso: Yes
03:27:37 <dminuoso> merijn: Ah cool. So data hiding with existentials is not that permanent after all.
03:27:55 <merijn> dminuoso: Well it is if you don't explicitly require a Typeable constraint ;)
03:28:44 <dminuoso> merijn: What does the `Typeable` constraint actually do? What's the runtime overhead for this?
03:28:48 <merijn> dminuoso: The existential can capture (1 or more) dictionaries anyway.
03:29:18 <dminuoso> Mmm, just plain dictionary passing still?
03:29:48 <merijn> dminuoso: Typeable dictionary has functions (or just one function?) that returns a value as "Maybe otherType" which happens to return the value if otherType is the same as the initial value or Nothing otherwise
03:29:55 <merijn> :t cast
03:29:56 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
03:30:41 <merijn> if a ~ b then it's just "Just" else it's "const Nothing"
03:31:36 <dminuoso> merijn: Well I dont see any instances for Typeable
03:32:02 <merijn> dminuoso: Typeable was changed and no longer allows user implemented instances in recent GHCs, it's only derivable
03:32:02 <kuribas> So it makes all types into a gigantic sum type...
03:32:05 <dminuoso> Im guessing I crossed into the magical unicorn land of GHC wizardry.
03:32:23 <merijn> dminuoso: Well Typeable used to just be a regular class you could implement yourself
03:32:34 <merijn> dminuoso: Which is obviously asking for trouble and segfaults if you mess it up
03:32:45 <kuribas> dminuoso: you probably already did.  standard haskell is pretty plain
03:36:32 <cocreature> dminuoso: yep before the type-indexed representation we just had "data TypeRep", now we have "data TypeRep a"
03:37:00 <cocreature> dminuoso: this allows you to safely write things like "TypeRep (a -> b) -> TypeRep b" instead of "TypeRep -> Maybe TypeRep"
03:37:24 <cocreature> dminuoso: the hierarchy Control.Exception is a pretty good usecase for Typeable
03:37:47 <cocreature> dminuoso: a common example is also implementing a shitty version of ST as State (Map Identifier Dynamic)
04:09:04 <lyxia> Is there a generic implementation of recursion-schemes somewhere already
04:14:31 <veritas> is there some way to make this valid? http://lpaste.net/363496. The hierarchy will be a closed one, the instances won't escape from the module.
04:14:43 <veritas> the type classes*
04:25:26 <noan> sorry kind of a silly stupid question is (->) a b equal to a -> b or b -> a
04:25:29 <noan> I think the first right?
04:25:45 <olligobber> a -> b
04:25:49 <noan> cheers
04:28:09 <dminuoso> noan: It's just like with infix operators in the value world. The first argument goes left, the second argument goes right =)
04:53:00 <sepakorayl> wy do I get an ambiguity error when there is one one possible instance?
04:53:57 <merijn> sepakorayl: How do you know there is only one possible instance?
04:55:50 <cocreature> this would probably be easier to answer if you show us the code and the error
04:59:15 <sepakorayl> http://lpaste.net/363498
04:59:32 <sepakorayl> I was following the https://wiki.haskell.org/GHC/AdvancedOverlap example
05:00:17 <cocreature> you need ScopedTypeVariables
05:00:31 <cocreature> "flag" in the instance body is not "flag" in the instance head
05:01:00 <sepakorayl> ha!
05:03:08 <clever> how do i turn an aeson Value into a Text as json?
05:04:01 <kuribas> clever: encode?
05:04:28 <clever> * Couldn't match expected type `Text' with actual type `f0 BL.ByteString'
05:04:49 <cocreature> encodeToLazyText
05:05:07 <ongy> what happens when I malloc in TH and then expose that ptr as toplevel binding?
05:05:10 <clever>  15 import           Data.Text (Text)
05:05:14 <clever> cocreature: but Text is strict
05:05:31 <merijn> ongy: You get a one-way trip to segfault town
05:05:33 <cocreature> clever: then add a conversion from lazy to strict text
05:05:35 <kuribas> clever: you can convert them
05:05:35 <merijn> ongy: If you're lucky
05:05:47 <ongy> mhh, sounds like my expectations
05:05:57 <merijn> ongy: Else you get multiple trips to "Silent memory corruption"-ville
05:06:20 <sepakorayl> hmm I don't think this will help me with my hierarchy
05:06:31 <ongy> probably a trip to segfault town over memory corruption valley
05:07:35 <ongy> How can I statically allocate a struct that will be used by a C library at compile time? Do I need to go over a C object file that's compiled in?
05:08:05 <clever> cocreature: * Couldn't match expected type `LT.Text' with actual type `f0 LT.Text'
05:08:07 <merijn> ongy: Easiest way would be to link in space for said struct, yes
05:08:36 <cocreature> clever: it’s rather hard to help you with an error without seeing the code producing that error
05:08:46 <clever> cocreature: ah, the :: LT.Text wasnt scoped right
05:08:55 <clever> and now that encodeToLazyText has a fairly strict type, i dont need it
05:09:47 <ongy> mhh that's no fun. Then I can't TH this and have to pre-generate :/
05:10:28 <clever> ongy: there is something in TH where it can generate a data and then forward it over
05:10:30 <cocreature> ongy: you can generate C files in TH, no? iirc that’s what inline-c does
05:10:53 <merijn> ongy: What do you need this statically allocated struct for?
05:11:02 <ongy> hm, I could go that way
05:11:49 <ongy> to hand it to a stupid api. I could in theory `with` my entire real main, but I don't like that approach either, since it requires me to do it upfront for every instance
05:12:21 <merijn> ongy: Why can't you just malloc and pass that to your API?
05:12:39 <merijn> ongy: If the lifetime is "entire run of program" anyway, then you don't even have to bother freeing anyway
05:12:57 <ongy> because the lifetime is icky, and I don't want to leak malloced structs
05:13:29 <merijn> ongy: If you want static allocations you seem to plan to keep them alive the entire program anyway?
05:13:30 <ongy> the problem is that I may need it multiple times, and malloc+"leak" with globals is just a weird hack. I'd prefer something that looks nicer
05:13:32 <merijn> So who cares?
05:15:06 <ongy> I do. And I'm not 100% sure if I may need the data to be available as symbol in the future, so I'd rather do it properly now
05:18:08 <sepakorayl> ha success!
05:18:45 <sepakorayl> http://lpaste.net/363502
05:21:31 <kuribas> is (const $ const $ x) obfuscation?
05:21:39 <sepakorayl> this way I can define my error conversions implicitely
05:21:46 <kuribas> @pl (\_ _ -> a)
05:21:46 <lambdabot> const (const a)
05:22:09 <Putonlalla> I'd prefer the parenthesized form or `(const . const) x`, kuribas.
05:22:48 <Putonlalla> It follows the same logic as `(fmap . fmap) f`, which is easy to recognize.
05:22:49 <dminuoso> const . const $ x
05:22:52 <lyxia> I prefer the lambda.
05:23:43 <kuribas> I'll stick with the lambda
05:23:46 <cocreature> lyxia++
05:24:02 <Ariakenom> @type const . const . flip . const
05:24:04 <lambdabot> (b1 -> c) -> b2 -> b3 -> b1 -> a -> c
05:37:45 <guessWho> i have a function which accepts 3 inputs and have 3 guards and uses one argument in each guard how to make this work as compiler would give me applied to too few error ??
05:38:44 <cocreature> guessWho: this would be significantly easier to answer if you show us the code and the error
05:41:10 <cocreature> at some point I need to write a bot that responds like this to every question that doesn’t contain an lpaste link :)
05:41:33 <mniip> that's useless
05:41:45 <mniip> 90% of the question don't need lpaste
05:42:01 <cocreature> I wasn’t being serious in case that wasn’t completely obvious :)
05:42:06 <mniip> you're experiencing survivorship bias
05:42:40 <sepakorayl> cocreature: http://lpaste.net/363502
05:42:51 <guessWho> cocreature : http://lpaste.net/363506
05:43:19 <cocreature> guessWho: alright now show us the error
05:44:18 <opqdonut> guessWho: if some arguments are optional, the usual way is to use a Maybe type for them
05:49:02 <guessWho> cocreature : couldn't match type b with a -> b probable cause applied to too few arguments
05:50:52 <cocreature> guessWho: I am pretty sure that this error does not orriginate purely from the code that you showed us, please just show us the full error next time and the code that’s responsible. anyway, the problem is that a and b have type "(Num a, Ord a) => a -> IO ()" while you are probably trying to use them as things of type "IO ()"
06:14:17 <guessWho_> how to achieve function overloading in haskell
06:15:11 <kuribas> guessWho_: typeclasses
06:15:14 <dminuoso> guessWho_: adhoc polymorphism cant be done with typeclasses
06:15:26 <dminuoso> *can even!
06:15:43 <dminuoso> guessWho_: https://wiki.haskell.org/Performance/Overloading =)
06:15:47 <guessWho_> dminuoso : so how it's done ?
06:15:58 <dminuoso> guessWho_: How does a typeclass work?
06:17:15 <regina_> I’ve been through too much cabal hell before so now I’m trying to just run everything off of stack. Is this wrong?
06:17:46 <regina_> working through tutorials I am just doing stack ghci with no stack init, because I’m not making the files; they’re already made.
06:17:50 <regina_> Doing this on a mac.
06:18:05 <Battle> hello all, am I able to obtain advice on security of a website? and how far a hacker may go after certain types of exploits?
06:18:30 <Battle> or is this not really the place for that kinda thing? (found this channel on google and it said it was good for security advice)
06:18:50 <MarcelineVQ> it's not :> this channel is for programming with the haskell language
06:18:53 <regina_> Battle: #yesod is Haskell’s web side
06:19:36 <Battle> ohhh
06:19:53 <saksham> regina_: I have been actively working on Haskell code since 2 years, and have only been using stack (no cabal, no system installation of packages). Works awesome.
06:19:55 <Battle> any suggestions on where I might be able to find such advice?
06:20:05 <dminuoso> Battle: Though as a general programming advice: Assume that maligious attackers will go all the way.
06:20:43 <Battle> by that do you mean someone could gain full root from sql injection for example?
06:20:43 <eschnett> i'm getting a segfault when stack builds this "distributive" package after upgrading to lts-11.0 on macos. is there a particular place where i should/could report this?
06:21:22 <dminuoso> eschnett: Check hackage, it contains a link to the project site (and if empty, usually a mail address for the maintainer)
06:21:36 <mizu_no_oto> regina_: When were you using cabal?  Pre 'new-buid'?  Pre sandboxes?
06:22:19 <regina_> mizu_no_oto: couple times over the last several years (let’s say 5)
06:22:42 <saksham> Battle: I don't understand your rationale. Why would you worry about what all can be done with an sql injection? Just fix it, it can lead to super serious issues.
06:22:47 <eschnett> dminuoso: so you suggest to contact the package maintainer? ok, will do.
06:23:01 <regina_> mizu_no_oto: I think I did try again after some improvements were made, and I’ve heard of cabal sandboxes but not "new-build"
06:23:17 <regina_> saksham: thanks
06:23:28 <dminuoso> eschnett: No I suggest you check hackage to see if the project has a website (say on github or gitlab)
06:23:32 <saksham> Cabal sandboxes are decent, but what does someone gain with that? stack does all that automatically.
06:23:37 <dminuoso> eschnett: If it has one, use that website to report an issue.
06:23:43 <MarcelineVQ> "<regina_> ... Is this wrong?" not if it's working
06:23:57 <regina_> saksham: do you just stack ghci every time? I have no system ghci (don’t want conflicts)
06:24:03 <merijn> saksham: new-build replaces sandboxes and also works automatically
06:24:16 <regina_> MarcelineVQ: ok thx
06:24:34 <dminuoso> saksham: from what Ive heard new-build is far more deterministic than stack
06:24:41 <saksham> It might be a good idea to use **ONLY ONE** package manager for everything. I used to have xmonad, taffybar etc from Gentoo, some stuff from cabal. Was. Not. Pretty.
06:24:52 <Battle> saksham the reason im questioning this is because a user posted on my website that my website contains "holes". few moments later he posted a filename specifically, and said he would do not harm as he "doesnt enjoy ruining others fun". I've checked the specific file and i'm going through all the other files on the website to check for errors and so on, but I see nothing that would suggest any holes....
06:25:32 <saksham> dminuoso: I haven't tried new-build, good to know. I'll test it. Although stack has awesome NixOS integration :) (my daily driver).
06:25:58 <merijn> saksham: new-build is inspired by the Nix approach to dependencies
06:26:17 <Battle> saksham from time to time we do get the odd "elite hacker" that turns out to be a 8 year old kid that thinks he knows everything and actually doesn't know antyhign at all... so whilst this may be just an empty threat of some kind... I see no obvious intrusions...and i wanted to know what I could do to further enhance my seucrity.
06:26:26 <mizu_no_oto> regina_: cabal sandboxes went a long way to improving cabal hell, and new-build is really nice.  Haven't run into any cabal hell issues with it.
06:26:28 <saksham> regina_: Yes, I do stack ghci everywhere :) There's a global configuration (~/.stack/global-project/config.yaml) which you can use to install packages, for usage inside ghci.
06:26:44 <dminuoso> Battle: Well if an 8 year old should be able to penetrate our security, that would be even more worrying.
06:26:51 <Battle> saksham I was going to move the whole website itself onto a VPS and have it connect remotely to the SQL server, but logic tells me this would be pointless? if they SQL injected (for example)
06:26:53 <merijn> Honestly cabal sandboxes are entirely unrelated to cabal hell
06:27:05 <cocreature> can you please take this security discussion somewhere else? this is offtopic
06:27:12 <regina_> saksham: thank you
06:27:14 <merijn> But somehow cabal hell has somehow changed meaning to "my dependencies don't just work"
06:27:57 <eschnett> dminuoso: i understand. the alternative would have been to file a report with stackage.
06:27:57 <saksham> Definitely need to try new-build. Although I don't remember seeing anyone use cabal on NixOS.
06:28:17 <mizu_no_oto> merijn: wasn't cabal-hell issues around installing new packages because of the versions of old ones you had previously installed?
06:28:35 <mizu_no_oto> or do I misunderstand the historical issues
06:29:09 <merijn> mizu_no_oto: "cabal hell" was that, for a time, cabal would silently replace an installed package with one compiled with different dependencies, silently breaking everything that transitively dependend on that package
06:29:26 <merijn> With no way of fixing it beyond nuking your entire package DB
06:29:37 <mizu_no_oto> oh, wow.
06:29:41 <regina_> merk, I’m probably using the term improperly.
06:29:55 <regina_> merijn: ok, I’m probably using the term improperly.
06:30:23 <merijn> That was fixed a long time ago, the result of the fix being that cabal would just refuse to install already installed packages. Which means that anyone not careful about their dependency bounds could end up specifying bounds that refuse to compile
06:31:05 <merijn> And people somehow adopted "cabal hell" to just mean "my dependencies are poorly/under specified and now things don't compile"
06:31:31 <merijn> But the solution to that problem is much more obvious, i.e. "fix your dependencies" which, admittedly, isn't fun. But not cabal's fault
06:32:16 <saksham> Battle: if someone says your website has an sql injection issue, you should take it very seriously. I have seen (and done in a controlled environment in security classes) a lot of harm done through sql injection. It would not be a bad idea to get someone to review your code, or spend some time studying basic web security issues. Try this to at least know what the major topics are:
06:32:17 <saksham> https://www.owasp.org/images/7/72/OWASP_Top_10-2017_%28en%29.pdf.pdf . Anyway, this discussion is off topic here, so perhaps you should try some other channels (I am not aware of any though).
06:34:42 <saksham> merijn: I use "cabal hell" for the above mentioned issue too. I understand how "fix your dependencies" is the best solution. But sometimes, some of your project's dependencies have conflicting requirements. The user of those packages should not have to worry about these things. Stack allows you to forget about this "hell".
06:35:25 <mizu_no_oto> '--allow-newer' is pretty nice, in 50% of those cases
06:35:30 <saksham> Also, not to mention, global packages. I used to have xmonad, taffybar, ghc-mod, pandoc installed globally. Was. Not. Pretty. Although I do not know if new-build would've fixed this.
06:35:48 <merijn> saksham: Sure, I'm just saying that "cabal hell", undeservedly, puts a lot of blame on cabal for problems which are not caused by cabal
06:36:20 <saksham> merijn: That's true :) How about, "not-stack hell" ?
06:37:03 <saksham> mizu_no_oto: Right. But stack will just build the dependencies separately, with the optimal versions of the deps of the deps. Anyhow, I guess, to each his/her own. If cabal works for you, why bother? :)
06:37:19 <cocreature> how about just naming the actual problems you’re facing instead of calling it “x hell”? for some choice of x?
06:38:49 <mizu_no_oto> saksham: what I had done for things like xmonad was built them in a sandbox and put the executable in my path, rather than installing them with the global cabal package index.
06:39:35 <mizu_no_oto> And new-build, I believe, fixes that.
06:40:17 <merijn> mizu_no_oto: basically, new-build follows the Nix approach of tagging all dependencies with a hash of their (transitive) dependencies so having the same package installed multiple times with different transitive dependencies/configs don't conflict
06:40:30 <mizu_no_oto> right
06:42:03 <saksham> mizu_no_oto: merijn: Good to know about the new-build thing. It sounds really cool. I'd be curious to talk to people who are using cabal on Nix. At the moment, I see this: https://github.com/haskell/cabal/issues/4646
06:42:31 <cocreature> saksham: you don’t need special nix integration, just run cabal in a nix-shell
06:43:42 <merijn> When using "cabal (new-)repl" there's not way to change the component it has loaded without relaunching, is there?
06:45:09 <saksham> cocreature: nix integration was nice because I didn't have to use a nix-shell with stack. I simply do `stack build`, and stack uses my nix packages to source the dependencies. Dependency versions don't get re-built across projects as well. Anyhow, this is just a minor nit. Other than that, it sounds pretty good.
07:03:29 <ertes-w> saksham: i use nix and cabal (not cabal-install) with emacs and haskell-mode…  it requires a bit of a setup, and some things are rather hacky, but otherwise it's a very smooth development experience, including cloning others' repos and just starting to hack on them
07:04:10 <ertes-w> saksham: however, cabal-install now has nix integration by itself, so technically my setup has become redundant…  i'm still hesitating to switch though
07:04:30 <ertes-w> something tells me to wait a few months =)
07:05:55 <ertes-w> saksham: however, if you aren't using nix for deployment or other non-dev purposes you have little to gain from using nix at all…  i'd recommend using new-build in that case
07:14:54 <saksham> ertes-w: I use nix for dev purposes. I used to be on Gentoo, and appreciate freedom of package versions / being able to hack with builds / having a declarative system. Or maybe I just like to make life difficult for myself? :laugh:
07:15:50 <saksham> ertes-w: As for the cabal thing, good to know. Oh, right, I forgot. One good thing about stack is that it lets you use intero with emacs, which is simply bliss. Especially during development of complicated haskell projects.
07:16:31 <saksham> That doesn't mean you have to use stack for everything. But intero uses stack.
07:16:54 <ertes-w> i believe there is a variant of intero that doesn't require stack
07:17:39 <ertes-w> what's the advantage of intero over haskell-mode?
07:20:06 <ski> @where Backus
07:20:07 <lambdabot> I know nothing about backus.
07:20:34 <ski> @where Backus "Can Programming Be Liberated from the von Neumann Style?: A Functional Style and Its Algebra of Programs" (Turing Award lecture) by John Warner Backus in 1977-10-17 at <https://amturing.acm.org/award_winners/backus_0703524.cfm>,<http://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf>
07:20:34 <lambdabot> I know nothing about backus.
07:20:39 <ski> @where+ Backus "Can Programming Be Liberated from the von Neumann Style?: A Functional Style and Its Algebra of Programs" (Turing Award lecture) by John Warner Backus in 1977-10-17 at <https://amturing.acm.org/award_winners/backus_0703524.cfm>,<http://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf>
07:20:39 <lambdabot> It is forever etched in my memory.
07:21:28 <catern> is there a good channel to ask generically about advanced programming language concepts that aren't really relevant to Haskell?
07:21:53 <saksham> ertes-w: intero shows types of items, is quite fast (and non-intrusive usually) and just works. I use intero along with haskell mode though.
07:23:52 <ertes-w> saksham: what you're describing is haskell-mode
07:25:11 <`Guest00000> is there a language which allows pattern matching on functions?
07:25:59 <`Guest00000> somewhat bad phrase, "pattern matching on function" can't mean the same as pattern matching on data
07:26:16 <saksham> ertes-w: http://commercialhaskell.github.io/intero/ . On-the-fly type information, automatic suggestions, jump to definitions (without a static tags table)..
07:26:37 <`Guest00000> but i mean something like function deconstruction
07:26:37 <ski> @where whyfp
07:26:37 <lambdabot> http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
07:26:42 <ski> @where+ whyfp "Why Functional Programming Matters" by John Hughes in 1984 at <http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html>
07:26:42 <lambdabot> Good to know.
07:27:02 <ertes-w> saksham: still just haskell-mode
07:27:22 <Cale> `Guest00000: The usual way to deconstruct a function is to apply it.
07:28:01 <Cale> `Guest00000: But presumably you mean something like pattern matching on code for a function?
07:28:10 <`Guest00000> and not exactly either
07:28:11 <Cale> (before it has been interpreted/compiled)
07:29:01 <ertes-w> saksham: i've heard all of these things before; people just assume that haskell-mode doesn't have all that – so far intero only seems to be better at one thing: marketing
07:29:33 <`Guest00000> i want to deconstruct functions in the sense of understanding for what they are defined without inserting try/catch in IO
07:29:51 <saksham> ertes-w: Quite possible. I don't remember ever not-having ghc-mod or intero.
07:29:56 <`Guest00000> and also which values they care about
07:30:13 <Cale> `Guest00000: I mean, usually functions are thought of as caring about their entire domain.
07:30:26 <Cale> Which is part of their type
07:30:40 <`Guest00000> yeah
07:30:48 <`Guest00000> so strongly that they throw errors
07:30:56 <`Guest00000> if they don't see a favorable value
07:31:06 <`Guest00000> fromJust doesn't care about Just's contained value; isn't defined for Nothing.
07:31:07 <Cale> Well, they don't throw errors, the code doesn't even compile in the first place.
07:31:21 <`Guest00000> > fromJust Nothing
07:31:22 <Cale> Well, okay, fromJust and the like are a bit different
07:31:25 <lambdabot>  *Exception: Maybe.fromJust: Nothing
07:31:29 <`Guest00000> did compile, see
07:31:33 <Cale> yeah
07:31:58 <`Guest00000> so i want to be able to get that info from a function
07:32:03 <`Guest00000> without blowing up
07:32:18 <Cale> That's effectively the halting problem
07:32:49 <ski> @where type-intersection
07:32:50 <lambdabot> I know nothing about type-intersection.
07:32:51 <Cale> Consider that fromJust could just go into an infinite loop rather than throwing that error -- which semantically we consider as the same thing.
07:32:53 <ski> @where+ type-intersection Euler diagram of intersections between "Proponents of static typing","Propoents of dynamic typing","People familiar with type theory" by Roman Cheplyaka,Maria Kovalyovain 2012-11-05 at <https://ro-che.info/ccc/17>
07:32:53 <lambdabot> Good to know.
07:33:03 <`Guest00000> okay
07:33:05 <`Guest00000> what if
07:33:09 <`Guest00000> they're not the same thing
07:33:12 <`Guest00000> two bottoms:
07:33:23 <`Guest00000> one for undefinedness, one for non-termination
07:34:03 <tdammers> the problem is that you can't always tell
07:34:46 <tdammers> if it fails with undefined in finite time, then you can tell within that time, but if it doesn't, you can't tell whether it's looping forever, or just taking really long to eventually come up with 'undefined'
07:34:59 <`Guest00000> whatever
07:35:01 <`Guest00000> i don't care
07:35:12 <Cale> Okay, so consider two functions of type Integer -> () -- one that always succeeds and produces (), and another which runs a Turing machine for the given number of steps (0 if negative), and produces () if it hasn't halted by that point, and throws an exception if it halts.
07:36:01 <`Guest00000> so?
07:36:38 <Cale> So if we can tell that the second function throws an exception, we'll be able to decide that the Turing machine halts.
07:36:39 <`Guest00000> (tellIfUndefined (thatFunction infinity)) would diverge
07:36:58 <`Guest00000> throws an exception OR diverges
07:37:05 <`Guest00000> doesn't throw an exception OR diverges
07:37:17 <Cale> (in fact, if we can determine which values it succeeds on, we know how long it takes the Turing machine to halt)
07:38:01 <[exa]> Computers are finite.
07:40:48 <Cale> But you might be interested in type systems that don't allow this kind of nontermination, and which give you types that let you express more precisely what is required.
07:42:27 <Cale> For example, Coq and Agda (and Idris if you turn on checking) insist on termination, but then give you more expressive types with which you can statically restrict what's allowed as an argument.
07:43:06 <maqbool> What book should i read to improve my recursive thinking?
07:43:41 <Cale> I don't know. You could read Okasaki's book on functional data structures, I suppose.
07:44:54 <Cale> But it's sort of advanced. If you're struggling with more basic things, I would say the right approach isn't so much to read a book, but to just play around with implementing recursive functions on lists and trees (in Haskell or another functional language with pattern matching, ideally)
07:45:26 <`Guest00000> hmm
07:45:55 <`Guest00000> maybe i could construct such kind of destructurable functions
07:45:59 <monochrom> Bird's Thinking Functionally.
07:46:00 <`Guest00000> in dep. types
07:46:23 <monochrom> Although, even that may be too advanced.
07:46:58 <monochrom> Basically the prerequisite is solid skill in induction proofs.  And not just induction on the natural numbers.
07:48:48 <EvilMachine> Hi. Can anyone explain the relationship between GHC and haddock-api to me?
07:48:52 <EvilMachine> I got GHC 8.4.1_rc1 installed, to test it out, and I got all haskell libraries to install fine, with just adapting a few to the Monoid Semigroup proposal and loosening changing a few dependencies.
07:48:59 <monochrom> Two major causes of why students suck at recursive programming:  Failing to trust the recursive call, therefore micromanaging your algorithm.  The base case is not small enough, e.g., neglecting 0 and empty lists and empty trees.
07:49:37 <EvilMachine> But I want to get Leksah going aswell, and it wants haddock-api-2.18.1, which fails with this bug: http://lpaste.net/363514
07:50:17 <eschnett> i'm getting a weird error message "ExitFailure (-11)" when building a package (see https://gist.github.com/eschnett/fdf6293c862d3511c1d302aee87a6882). how can i tell stack to keep the temporary directories mentioned in the error message? (this is macos.)
07:50:29 <EvilMachine> monochrom: Luckily, GHC usually warns when your forget a case. :)
07:50:37 <eschnett> (trying to build "distributive")
07:50:38 <merijn> eschnett: That looks like something is segfaulting
07:51:11 <eschnett> merijn: yes. is there a way to have stack not delete the temporary directories, so that i can inspect things?
07:51:24 <merijn> I don't use stack, so no clue :)
07:51:56 <monochrom> Naw it is not that simple.  I mean first of all yes the student will eventually be forced to do full coverage.  But the code quality will be poor because of the following reason.
07:52:24 <monochrom> Imagine a student who sums up a list by this:  sum [] = 0; sum [x] = x; sum (x:xs) = x + sum xs.
07:53:02 <monochrom> See how they arrived at that kind of code?  Because they didn't have sum[]=0 until GHC or my test cases force them.
07:53:47 <monochrom> Now imagine the homework is something much less toy than sum.  This is going to result in much more redundant code.
07:55:10 <EvilMachine> monochrom: Yes, I agree. I’m still comparatively new, and caught myself doing exactly what you said: Making the base case too big. I just couldn’t put my finger on it, until you said it.
07:55:49 <ertes-w> maqbool: you should probably just write more code
07:59:14 <ski> `Guest00000 : "damn, language theory is interesting https://www.cs.indiana.edu/~sabry/papers/rational.pdf" -- yea, that's an interesting paper :)
08:00:13 <w1n5t0n> hi all, I'm using Emacs and trying to send a do block to the interpreter via the intero-repl-eval-region command (C-c C-c) but I'm getting an "empty 'do' block" error. More details here: https://pastebin.com/dPZhfPBG
08:04:48 <w1n5t0n> (should also mention that the same "s" function works fine if I evaluate it on its own line, but I want to be able to run a whole block of these at the same time)
08:04:59 <eschnett> w1n5t0n: not enough indentation? maybe you need one more space?
08:06:11 <w1n5t0n> eschnett: still get the same error. is there a special syntax to how do blocks have to be sent to the interpreter? like, do I have to add curly braces around the statements before I send the string?
08:06:29 <merijn> w1n5t0n: Unrelated to the error, but the lambdas on line 2 and 3 of that paste are redundant
08:06:40 <merijn> w1n5t0n: "\t -> sin t" is just "sin"
08:07:00 <ski> @remember monochrom Two major causes of why students suck at recursive programming:  Failing to trust the recursive call, therefore micromanaging your algorithm. The base case is not small enough, e.g., neglecting 0 and empty lists and empty trees.
08:07:00 <lambdabot> It is forever etched in my memory.
08:07:03 <merijn> w1n5t0n: Also, is this being passed to ghci in some way?
08:07:27 <merijn> w1n5t0n: Because ghci doesn't support multiline syntax without putting in some effort
08:07:38 <w1n5t0n> merijn: yes I know, but I want to have the input variable bound to t so that I can do stuff like "sin (2*pi*t + t/3) etc. Is there any way I can achieve this behind the scenes without having to type the lambda?
08:08:00 <merijn> So you'd need to enable multiline syntax before that gets pasted into ghci
08:08:41 <DavidLopez> could someone explain to me what is the purpose of the `seq` function in this foldl definition
08:08:44 <DavidLopez> foldLeft f b (h :. t) = let b' = f b h in b' `seq` foldLeft f b' t
08:09:02 <DavidLopez> i deleted it and it still works
08:09:12 <merijn> DavidLopez: seq enforces strictness
08:09:30 <merijn> DavidLopez: i.e. you probably inserted a memory leak by deleting it ;)
08:09:52 <catern> ski: a - b seems like it would correspond to the function type b -> a
08:09:54 <DavidLopez> haha could you elaborate? what do you mean strictness
08:10:15 <ski> DavidLopez : not leaking memory during the accumulation, assuming the accumulated result is a "small summary" which one'd do best to evaluate strictly, as we go along, rather than only evaluating all the small build-ups at the end
08:10:20 <merijn> DavidLopez: I'm about to head to the gym, but I'm sure someone else here is bored and can explain in more detail :)
08:10:25 <catern> is that what it works out to in the paper?
08:10:25 <w1n5t0n> merijn: is that achieved with ":set +m"? seems to have done the trick
08:11:47 <ski> catern : hm, i'm not so sure about that
08:12:04 <Cale> DavidLopez: seq a b evaluates to the same thing as b so long as a's evaluation completes, and fails in the same way as a otherwise. This basically instructs the compiler that it is free to evaluate a whenever it wants, since its value will eventually be needed.
08:12:21 <Cale> DavidLopez: and in particular, GHC will usually decide to evaluate that first.
08:13:04 <Cale> (though it is allowed to still evaluate it second, just so long as it does it before seq a b's evaluation completes)
08:13:24 <ski> catern : in "Dual-Intuitionistic Logic" (papers by Igor Urbas,Rajeev Gore) and "Subtractive logic", they have a type which i write as `A >- B', which consists of a pair of a value of type `A', and a contination which accepts a value of type `B'. one can think of this as the context (argument expression, and context around the function call, expecting the function result) around a call to a function of type `A -> B'
08:15:44 <ski> DavidLopez : btw, note that in `seq a b', it is not guaranteed that `a' is evaluated before `b'. (iiuc) it is not even guaranteed that `a' is evaluated before the `seq a b' returns the value of `b'. but (iiuc) it is guaranteed that `a' will be evaluated then (at some later point) so that if that evaluation doesn't terminate normally, the result is the same as if `a' was evaluated before `b'
08:16:57 <ski> (of course, note that if you have several calls to `error', or partial pattern-matching (including guards), and possibly nontermination mixed in with that, you are not guaranteed to get any specific one of these errors or partialities or nontermination)
08:17:21 <cocreature> “it is not even guaranteed that `a' is evaluated before the `seq a b' returns the value of `b'” this sounds wrong or confusing. seq guarantees that both a and b will be evaluated before seq returns a value
08:17:32 <catern> ski: -a sounds a lot like ¬a, which is the type of a continuation taking b and not returning; and in a CPS transform, a -> b becomes, ¬(a x ¬b). and if I perform some gratuitous over-application of logic, we can de Morgan that to (¬a x b). and that's -a + b. so -a + b is a lot like a -> b
08:17:48 <catern> by this crazy intuitive argument :)
08:18:55 <catern> er, we de morgan it to (¬a + b)
08:20:20 <catern> er, and I meant ¬a is the type of a continuation taking a and not returning :)
08:20:26 <catern> typos...
08:20:40 <sepakorayl> anyone interested in implementation of compiler errors?
08:21:36 <DavidLopez> ski I am not sure if i understand what you mean with "so that if that evaluation doesn't terminate normally, the result is the same as if `a' was evaluated before `b' "
08:22:08 <DavidLopez> what do you mean with that evaluation not terminating normally
08:27:09 <sepakorayl> what do you guys think of this?http://lpaste.net/363520
08:30:09 <sepakorayl> Ts create an error hierarchy for deep inspection
08:30:20 <ski> DavidLopez : "what do you mean with that evaluation not terminating normally" -- i mean anything apart from normal termination (only). in Haskell, this amounts to partiality (like `head []'), in which one can also include calls to `error', as well as nontermination, like `last [0 ..]'
08:30:38 <sepakorayl> and the transformations in general don't have to deal with them
08:30:54 <DavidLopez> ohhhhh
08:31:06 <DavidLopez> thanks for the answer!
08:32:26 <sepakorayl> now if the transformation D4 -> D4' fails we can inspect the error tree to find out what's wrong and no errors are lost in the process
08:33:58 <`Guest00000> ski:  (A -> B, A -< B) ~ ()  ?
08:34:06 <`Guest00000> annihilating types
08:34:08 <`Guest00000> anti-types
08:34:12 <`Guest00000> Big Bang
08:34:22 <`Guest00000> hmmm
08:34:25 <`Guest00000> what if...
08:34:30 <`Guest00000> negative types actually exist
08:34:36 <`Guest00000> just that we don't see them
08:34:43 <ski> DavidLopez : in a language like say C or Java or Python, one could also include side-effects, like the obvious input/output interaction, changing the state of a mutable thing, raising/throwing and handling/catching exceptions, jumps (`goto',`longjmp'), ..
08:34:46 <Hijiri> time to found particle physics on type theory?
08:34:50 <ski> .. but also *depending* on the current state of a mutable thing (or of some dynamic context that may not be mutable per se, but which can vary in local contexts), indeterminacy resulting from unpredictability of concurrency, randomness, partially specified library procedures, "angelic nondeterminism" like with generators/iterators that return multiple times
08:35:22 <`Guest00000> Hijiri: Type Theory as a new foundation for Theory of Everything
08:35:42 <ski> DavidLopez : anyway. strictly speaking, one could say that Haskell actually *have* side-effects, namely partiality and nontermination. but these tend to be more "benign" than the others i've mentioned, not causing as much trouble, and so we tend to sweep them a bit under the rug
08:36:07 <Cale> DavidLopez: So some things which are true about seq is that seq x (seq x y) = seq x y, and that seq x (seq y z) = seq y (seq x z), and that seq x x = x
08:36:30 <ski> `Guest00000 : from `(A -> B) /\ (A >- B)' we arrive at `False'
08:37:12 <DavidLopez> wait what Cale
08:37:22 <DavidLopez> seq x (seq y z) = seq y (seq x z)
08:37:26 <DavidLopez> ??
08:37:28 <sepakorayl> does this seem any useful from a compiler writer's point of view?
08:37:43 <frerich> Is anyone here Andrei Barbu? :-)
08:38:10 <Psybur> :t seq
08:38:11 <lambdabot> a -> b -> b
08:38:28 <Cale> DavidLopez: Yeah, because seq _|_ y = _|_, and seq x y = y otherwise
08:38:52 <Cale> DavidLopez: so seq x (seq y z) is _|_ if either x or y is _|_, and z otherwise
08:39:28 <Psybur> > seq 1 (seq 2 3)
08:39:30 <Cale> If you have seq x y, the compiler is allowed to evaluate y first, and then x, and finally return the result of evaluating y
08:39:31 <lambdabot>  3
08:39:40 <Psybur> > seq 2 3
08:39:41 <`Guest00000> "diverge if x is bottom" >> "diverge if y is bottom"   is commutative
08:39:43 <lambdabot>  3
08:39:52 <Cale> It usually doesn't do that, but it may.
08:39:58 <Cale> (and sometimes does)
08:40:58 <Psybur> % seq (unsafePerformIO (println "omg"))
08:40:58 <yahb> Psybur: ; <interactive>:2:23: error:; * Variable not in scope: println :: [Char] -> IO a0; * Perhaps you meant one of these: `print' (imported from Prelude), `printf' (imported from Text.Printf)
08:41:07 <Psybur> % seq (unsafePerformIO (putStrLn "omg"))
08:41:08 <yahb> Psybur: ; <interactive>:3:1: error:; * No instance for (Show (b0 -> b0)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
08:42:05 <titusg> Hiay
08:42:07 <ski> Hijiri : "Physics, Topology, Logic and Computation: A Rosetta Stone" by John C. Baez,Mike Stay in 2009-03-02 at <https://math.ucr.edu/home/baez/rosetta.pdf>
08:42:24 <DavidLopez> does _|_ mean an undefined value Cale
08:42:28 <Cale> yeah
08:42:47 <Cale> either an infinite loop, or some other way that the evaluation doesn't finish normally, like an exception
08:42:57 <shapr> bonjour titusg, comment ca va?
08:43:04 <titusg> do I need to do something special to use START_FILE? Getting a parse error on a file that uses it.
08:43:15 <shapr> what's that?
08:43:17 <ski> Cale : i suppose one could add `seq (seq x y) z = seq x (seq y z)' to those ?
08:43:53 <titusg> this pragma {-# START_FILE myfile #-}
08:44:31 <Cale> yeah
08:45:11 <shapr> titusg: that's new to me
08:45:22 <ski> @where seq-laws
08:45:22 <lambdabot> I know nothing about seq-laws.
08:45:23 <shapr> what does it do?
08:45:25 <ski> @where+ seq-laws `forall x. seq x x = x',`forall x y. seq x (seq x y) = seq x y',`forall x y z. seq x (seq y z) = seq y (seq x z)',`forall x y z. seq (seq x y) z = seq x (seq y z)'
08:45:25 <lambdabot> Done.
08:45:31 <w1n5t0n> I have a "data Signal = Signal {sig :: Time -> Value}", and I've made it an instance of num where (*) is defined as "(*) 0 _ = 0; (*) a b = a * b". In other words, I want the second argument to not be evaluated if the first one is equal to 0. How can I be sure that it's working the way I want to when I'm passing a (a -> b) to a function to turn it into a signal?
08:45:37 <`Guest00000> ski: thanks for link ;)
08:45:46 <ski> (any more relevant law we should mention ?)
08:46:06 <`Guest00000> ski: "We assume no prior knowledge of category theory, proof theory or computer science."  noooo
08:46:08 <geekosaur> afaik START_FILE is not a thing in ghc.
08:46:11 <geekosaur> ...oh
08:46:11 <Cale> and in fact, that associativity law lets us get rid of seq x (seq x y) = seq x y
08:46:29 <Cale> because we can just  seq x (seq x y) = seq (seq x x) y = seq x y
08:46:41 <geekosaur> it's part of how yesod scaffolding packs multiple source files into a single file
08:46:42 <DavidLopez> Cale remember you said "seq a b evaluates to the same thing as b so long as a's evaluation completes, and fails in the same way as a otherwise. This basically instructs the compiler that it is free to evaluate a whenever it wants, since its value will eventually be needed."
08:46:46 <geekosaur> ghc never sees it normally
08:46:47 <DavidLopez> but this works?
08:46:53 <DavidLopez> seq [1..] 2
08:47:06 <Cale> Right, because the evaluation of [1..] terminates :)
08:47:11 <titusg> shapr: hmm strange, was following a tutorial at schoolofhaskell
08:47:18 <DavidLopez> mind = blown
08:47:19 <metahumor> DavidLopez: because it doesn't fully seq all the values in [1..].
08:47:23 <Cale> haha
08:47:33 <metahumor> DavidLopez: normal form vs weak-head-normal-form
08:47:43 <geekosaur> seq only goes one level, so it gets forced to the first (:) in the result and no farther
08:47:46 <Cale> Yeah, we only ever evaluate things up to determining the top level data constructor
08:48:03 <metahumor> there is also deepseq
08:48:06 <Cale> because that's what's needed for pattern matching
08:48:21 <shapr> titusg: are you learning school of haskell? or just haskell in general?
08:48:32 <Cale> Yeah, deepseq is a thing that's defined using type classes to recursively seq everything throughout a data structure.
08:48:32 <DavidLopez> thanks guys this has been enlightening !
08:48:44 * shapr zaps DavidLopez 
08:48:58 <shapr> oh wait, you didn't say en-lightning
08:49:00 <ski> Cale : yeah, but i figured it can be good to include it, for emphasis
08:49:34 <titusg> shapr: Haskell in general but I'm looking at their chapter on parsing/attoparsec
08:49:48 <geekosaur> titusg, either the tutorial is out of date or you skipped a step where "yesod devel" should be unpacking the file and removing the START_FILE pragma in the process
08:49:54 <shapr> titusg: oh, have you already got applicatives down?
08:50:18 <titusg> geekosaur: makes sense, thanks
08:51:00 <DavidLopez> shapr ba dum tss
08:51:27 <shapr> ok, time to teach Haskell class, yay! We're doing applicative parsing again today!
08:53:35 <`Guest00000> > seq (last [1..]) 2
08:53:41 <lambdabot>  mueval-core: Time limit exceeded
08:54:24 <`Guest00000> > (\x y -> y) (last [1..]) 2
08:54:27 <lambdabot>  2
09:00:53 <ski> @where expressive-power
09:00:53 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.4656
09:00:56 <ski> @where+ expressive-power "On the Expressive Power of Programming Languages" by Matthias Felleisen in 1990 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.4656>
09:00:56 <lambdabot> Done.
09:02:50 <aaronStone> i have a haskell project created using "Stack new projectName" now inside this project i want multiple modules with simple lib template "stack new projName simple-library" how do i configure these modules with main project ??
09:03:18 <`Guest00000> damn so many cool papers
09:03:33 <`Guest00000> need a web-page, or a repository, or a wiki, or a web-portal listing them
09:03:45 <`Guest00000> and
09:03:55 <`Guest00000> arranged by topic and interlinked
09:04:06 <`Guest00000> so at least a wiki
09:04:22 <Putonlalla> Looks like Hakyll has not built since LTS 10 and we're already at LTS 11.
09:04:27 <delYsid> When talking about a function that takes a Functor, Monad, or any other * -> * thingy, how do you call the "a" in SomeType a or SomeType ()?  Value sounds wrong.  Non-native speaker here.
09:04:42 <Putonlalla> Good shit.
09:04:42 <`Guest00000> web-page < repo < wiki < portal
09:04:48 <cocreature> aaronStone: you can add modules to the exposed-modules or other-modules section in your cabal file
09:05:21 <`Guest00000> an ordering defining expressiveness of web-media forms
09:05:27 <ski> delYsid : "idiomatic/applicative / monadic result type", for the two latter. "element type" is often used for the former
09:05:39 <`Guest00000> does category theory apply to Internet?
09:05:45 <aaronStone_> i have a haskell project created using "Stack new projectName" now inside this project i want multiple modules with simple lib template "stack new projName simple-library" how do i configure these modules with main project ??
09:05:55 <aaronStone_> sorry for posting again i got disconnected
09:06:02 * ski idly wonders whether delYsid meant non-native Haskell speaker, or non-native english speaker
09:06:07 <cocreature> aaronStone_: you can see my answer in the logs linked in the topic
09:06:23 <ski> `Guest00000 : by "portal", you mean ?
09:06:29 <pavonia> delYsid: I think "return value" is quite common, though not technically correct for every monad
09:06:49 <ski> pavonia : example ?
09:06:51 <`Guest00000> ski: https://en.wikipedia.org/wiki/Web_portal
09:07:02 <aaronStone_> cocreature : i'm not sure how to do that
09:07:09 <`Guest00000> <s>duh, it's all computers and connections</s>
09:07:23 <cocreature> armlesshobo: open your cabal file in a text editor and edit it?
09:07:29 <ski> `Guest00000 : why is it better than a wiki (for this purpose) ?
09:07:32 <pavonia> ski: I recall types that have `a' as input paramter for a function
09:07:38 <delYsid> ski: Thanks.  Non-native english I ment :-)   So result type or element type.  So something like "a monad with a non-polymorphic element type" would be fine?
09:07:40 <armlesshobo> cocreature: what?
09:07:47 <`Guest00000> ski: maybe not better specifically for this purpose
09:08:04 <ski> pavonia : well, that doesn't yield a `Functor', and even less `Applicative' or `Monad'
09:08:10 <cocreature> armlesshobo: sorry I’m too stupid for autocomplete
09:08:13 <`Guest00000> certainly not better, if what better is a least complex, expressive enough for a purpose thing
09:08:19 <armlesshobo> cocreature: np
09:08:21 <`Guest00000> but a portal is more expressive
09:08:23 <`Guest00000> than a wiki
09:08:35 <cocreature> aaronStone_: open your cabal file, find the “exposed-modules” field and add the modules that you want
09:08:42 <`Guest00000> On the Expressiveness of Internet Media Forms
09:08:46 <`Guest00000> dang
09:08:48 <pavonia> ski: Okay, I correct that to "or any other * -> * thingy" then :p
09:09:00 <`Guest00000> a theory which will let us build new forms of internet media
09:09:15 <`Guest00000> some hybrids of internet-forums, chats, wikis,
09:09:22 <ski> delYsid : depends on what you want to express. i'm suspecting that your use of "polymorphic" there is confused (if you mean not having a type variable in it, rather than not having a `forall' it. even in the latter case, it would be confused, in another way)
09:10:00 <ski> pavonia : one could say parameter/argument type, of a parametric type / type function, i think
09:10:14 <aaronStone_> cocreature : which cabal file main project or modules ?? also i was told we are not supposed to touch cabal file ??
09:10:35 <cocreature> aaronStone_: ah do you have a package.yaml file?
09:11:02 <aaronStone_> cocreature : yeah in main project since its a regular stack project
09:11:11 <dminuoso> ski: Interesting, Im trying with an analogy that considers `a` to be the kind of "focus" of the functor/monad
09:11:35 <aaronStone_> cocreature : but not inside module only stack.yaml and cabal there as they are lib template
09:11:59 <dminuoso> Given say (Either b a), it lets me express the idea that all such instances focus on the second type parameter.
09:11:59 <cocreature> aaronStone_: what exactly do you mean by “module” here? I feel like we are talking about different things
09:12:32 <delYsid> ski: OK, I see (sort of).
09:12:33 <`Guest00000> s/if what better/is what's better/
09:12:47 <aaronStone_> cocreature : by module i mean a lib, i know i can keep it inside src but i have multiple libs which i want to maintain as seperate projects
09:13:16 <aaronStone_> cocreature : independent of projects they are used in, so that anyone can use them
09:13:19 <cocreature> aaronStone_: alright, in a haskell context “module” usually refers to a single file
09:13:37 <cocreature> aaronStone_: you can create multiple cabal projects within a single stack project
09:13:54 <cocreature> aaronStone_: and then specify all of them in the "packages" section in your stack.yaml file
09:13:56 <dminuoso> ski: Oh and by the way, I took your critique about my gist the other day (the type unification of `const id`), and started being more explicit about introducing fresh metavariables, replacing universal quantification with metavariables, etc.
09:14:41 <cocreature> aaronStone_: take a look at https://docs.haskellstack.org/en/stable/GUIDE/#multi-package-projects
09:23:34 <`Guest00000> ski: that last link (to "Rosetta store") is such a simple, clear explanation of concepts in category theory as i've never seen before
09:24:27 <`Guest00000> wait, maybe i have...
09:29:09 <ski> @where polymorphic-type-inference
09:29:09 <lambdabot> I know nothing about polymorphic-type-inference.
09:29:11 <ski> @where+ polymorphic-type-inference "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
09:29:11 <lambdabot> Good to know.
09:29:22 <Welkin> lambdabot: these are not the monads you are looking for
09:29:40 <`Guest00000> there was one pdf, i've seen it here, but i can't find it
09:30:01 <ski> @where on-understanding
09:30:02 <lambdabot> I know nothing about on-understanding.
09:30:03 <ski> @where+ on-understanding "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
09:30:04 <lambdabot> Nice!
09:30:56 <ski> @where on-understanding-revisited
09:30:56 <lambdabot> I know nothing about on-understanding-revisited.
09:31:17 <ski> @where+ on-understanding-revisited "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf>
09:31:17 <lambdabot> It is stored.
09:31:21 <Welkin> what is going on?
09:31:49 <ski> (i figured i refer to these papers that often that it might be handy to have them in lambdabot)
09:32:06 <`Guest00000> it's very critical that @where supports listing operation
09:32:27 <catern> hmmm
09:32:30 <`Guest00000> now @where only responds to specified keys
09:32:59 <`Guest00000> but adding it  would be backwards-incompatible; past users could have depended on it
09:33:09 <`Guest00000> so the key is secret
09:33:15 <`Guest00000> :/
09:33:18 <catern> the configuration problem: can't it be solved by just having your module defined as a function which takes the configuration?
09:33:23 <frerich> Is anyone familiar with constraint satisfaction programming in Haskell in general, or using the 'csp' package in particular? I wonder how to express a constraint on three variables a,b,c like 'b should be 2 if either a or c is 1'.
09:33:24 <catern> then you close over the configuration
09:33:41 <Welkin> ski: that last one has the worst filename ever: essay.pdf
09:33:45 <catern> IIRC there was a page on the Haskell wiki that talked about solutions to the configuration problem, anyone know it?
09:34:36 <ski> dminuoso : yea .. i'm not saying your gist was bad at all. i'm just saying that at some point, one might want to get that extra bit of detail
09:35:07 <Welkin> catern: just use ReaderT
09:36:38 <ski> delYsid : values like `[]',`Nothing',`length' are polymorphic. their types, here `forall a. [a]',`forall a. Maybe a',`forall a. [a] -> Int' all have a `forall' at the start/top, can be called `forall'-types, or perhaps "universal types". it's the presence of `forall' (not the presence of type variables) in the type that makes the corresponding value/inhabitant of that type polymorphic
09:37:36 <`Guest00000> but just results of grepping \.pdf this channel's logs are quite valuable enough
09:38:04 <catern> Welkin: there are a number of alternatives, ReaderT is not necessarily the best :)
09:38:18 <catern> (and probably is not the best, since it forces everything to be monadic)
09:38:18 <`Guest00000> grep won't find that thing with "p(s|df)" though :/
09:38:45 <ski> delYsid : note that these types themselves are *not* polymorpic. a polymorphic type would be `Flip', defined like `newtype Flip f b a = MkFlip (f a b)', where you can say both `Flip Either Int Bool', and `Flip (StateT Integer) Bool Maybe', where the kind of the last argument is different (just like the type of the argument of `length' in `length [False,True]' vs. `length "blah"' differs)
09:39:45 <ski> (delYsid : the kind of `Flip' here is `forall k0 k1. (k0 -> k1 -> *) -> k1 -> k0 -> *'. again the `forall'. in my two examples, `k1' became `*'. while `k0' became `*' in one case, but `* -> *' in the other)
09:41:38 <ski> `Guest00000 : well, some keys become used enough (like e.g. `existential-antipattern', `boolean-blindness'), that enough people are aware of them to keep referring to them ..
09:41:54 <ski> @where burrito
09:41:55 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
09:42:10 <leshow> I've been experimenting with Parsec, and wrote a parser that does that I want. The only problem is that it only does it once. I want to collect all the matches over the total input: http://lpaste.net/4416477813498970112 any ideas?
09:42:17 <MarcelineVQ> @where liberated
09:42:18 <lambdabot> http://www.stanford.edu/class/cs242/readings/backus.pdf
09:42:18 <leshow> I've been stuck for hours on this haha
09:44:02 <cocreature> leshow: so you want to do some kind of grep-style matching where you find all matches of your parser?
09:44:16 <`Guest00000> ski: what about people who want to directly examine the whole list of keys
09:44:21 <ski> @where applicative-vs-monadic
09:44:21 <lambdabot> I know nothing about applicative-vs-monadic.
09:44:23 <ski> @where+ applicative-vs-monadic "Applicative vs Monadic build systems" by ndm in 2014-07-23 at <https://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html>. (cf. "static sequencing" vs. "dynamic sequencing")
09:44:23 <lambdabot> It is forever etched in my memory.
09:45:00 <leshow> cocreature: yes exactly, if I could just collect all the matching results of this function over a file that would be perfect
09:45:21 <`Guest00000> oh god
09:45:23 <leshow> I've tried different forms of looping and always seem to end up with a parse error
09:45:27 <`Guest00000> @where is unsafe!!!
09:45:27 <lambdabot> I know nothing about is.
09:45:37 <leshow> where running it once doesnt produce any error
09:45:55 <`Guest00000> except
09:47:41 <`Guest00000> confirmed
09:47:55 <`Guest00000> lambdabot direly needs to be fixed
09:50:03 <ski> `Guest00000 ?
09:50:04 <cocreature> leshow: sadly parsec-style libraries are not particularly good at this task. if you want to use parsec, your best choice is usually to skip ahead over everything that’s not the first character of your parser (a 'u' in your case), then try to apply your parser once you’ve found a 'u' and repeat that
09:50:05 <MarcelineVQ> what is confirmed?
09:50:30 <`Guest00000> people can overwrite @where.....
09:50:39 <ski> sure they can
09:50:55 <cocreature> leshow: if your parser is really this simple then a regex library might be a better choice. regex-applicative allows you to write regexes in a style very similar to parsec
09:50:56 <MarcelineVQ> yes that's a potential problem, most people fix it with limiting who can add things, but that's overly limiting in a setting full of reasonable people
09:51:05 <ski> (that's why i check everytime, before using `where+')
09:51:05 <Welkin> `Guest00000: it seems that every time I see you talk in here, you are trying to convince whoever will listen that there is some kind of show-stopping bug with something related to haskell
09:51:10 <Welkin> o.o
09:51:12 <Welkin> weird
09:51:14 <Welkin> seems kinda weid
09:51:41 <Welkin> are you chicken little?
09:51:44 <ocramz> hullo
09:52:14 * ski didn't read it as attempting to convince there's a show-stopping bug, fwiw ..
09:52:24 <`Guest00000> i'm sorry
09:52:26 <leshow> cocreature: Okay I can try that, I thought that since I have something that works on splitting properly from any chunk of text once, it would be easy to have it run multiple times and collect the results...
09:52:39 <ocramz> how long can it take from uploading a new version to hackage to being able to use it?
09:52:47 <ocramz> minutes, hours?
09:52:52 <cocreature> minutes
09:52:57 <cocreature> if anything
09:53:18 <ocramz> yep, worked now. Something like 5 mins
09:53:55 <`Guest00000> does that offend or distract someone or otherwise interfere
09:54:22 <cocreature> leshow: the problem is making it efficient. you can ofc just try to apply your parser at every character but that will be fairly slow in general. skipping efficiently over the non-matching parts is not trivial
09:55:30 <leshow> It already does that, it just only matches up to the first x url( y ), and nothing after
09:56:18 <cocreature> leshow: oh so what happens if you just wrap it in "many"?
09:56:54 <leshow> I have the function in an lpaste, http://lpaste.net/4416477813498970112 the result shown is what I get when run on that text joined together
09:57:28 <cocreature> leshow: and what’s the result that you’d like to get?
09:58:09 <leshow> Yes, I'd just like to have it run multiple times and collect the results, unfortunately many throws a parse erro 'expecting url('
09:58:18 <leshow> I'm not sure why it works when run only once
09:58:19 <ski> `Guest00000 : "that" being ?
09:58:28 <cocreature> leshow: can you provide a concrete input that causes an error?
09:58:33 <leshow> sure
09:59:29 <`Guest00000> ski: what Welkin said about me
10:00:00 <leshow> http://lpaste.net/4416477813498970112
10:00:23 <cocreature> leshow: thanks, taking a look
10:00:38 <leshow> Thank you
10:00:45 <ski> `Guest00000 : speaking for myself, it didn't offend or distract or otherwise interfere. and i'm not sure why someone would react that way to what you said
10:02:03 <cocreature> leshow: the problem is the part after the final ')'
10:02:40 <leshow> the final try (string ")")?
10:02:51 <ski> @where next-700
10:02:51 <lambdabot> I know nothing about next-700.
10:02:55 <ski> @where+ next-700 "The Next 700 Programming Languages" by Peter J. Landin in 1965-08 at <http://thecorememory.com/Next_700.pdf>,<https://dl.acm.org/citation.cfm?id=365257>
10:02:55 <lambdabot> Okay.
10:03:36 <cocreature> leshow: you’re parser runs two times successfully and then it gets started a third time on input " }" and fails
10:04:00 <cocreature> leshow: an easy solution is to use many (try parseUrl)
10:04:44 <leshow> Ah, wow! thanks!
10:04:51 <leshow> I tried the inverse of that some time ago
10:04:57 <leshow> try $ many parseUrl
10:06:07 <cocreature> leshow: btw you might want to check out "megaparsec" which is an actively developed decendent of parsec with better performance, more features and better error messages
10:06:36 <virgin> i'm reading graham hutton haskell's book. in it there is this question that i don't understand very well: Let us say that such a tree is balanced if the number of leaves in the left and right subtree of every node differs by at most one, with leaves themselves being trivially balanced. the tree he refer to is this: data Tree a = Leaf a | Node (Tree a) (Tree a) -- what does it mean that: ""with leaves themselves bein
10:06:36 <virgin> g trivially balanced"?
10:06:51 <merijn> leshow: Might wanna have a look at: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
10:06:53 <leshow> cocreature: alright I'll give it a look, I may just end up switching to regex anyway. But I didn't want to give up quite yet on this
10:07:21 <Cale> virgin: You can ignore the word "trivially"
10:07:27 <Cale> virgin: if that helps
10:07:32 <leshow> merijn: okay thanks for the article
10:07:37 <virgin> it don't :-)
10:07:54 <Cale> virgin: Leaves don't have left and right subtrees, so the definition wouldn't work for them without saying something more.
10:07:59 <ertes-w> virgin: leafs are just defined to be balanced
10:08:00 <virgin> Cale: can i ignore the whole sentense?
10:08:07 <merijn> leshow: And yes, for new codebases you might want to prefer megaparsec over parsec
10:08:15 <Cale> You need to know that leaves are considered balanced.
10:08:56 <leshow> merijn: you prefer that over like attoparsec?
10:09:11 <ertes-w> virgin: it's just badly worded…  he should have written: "since leaves have no branches we assume that leaves are balanced"
10:09:21 <Cale> Well, okay, it says that the tree is balanced if (some condition) holds of every node. Leaves don't have any nodes.
10:09:48 <cocreature> leshow: attoparsec is mostly useful if you a) need streaming support b) your input is not produced by humans so you don’t care error messages and c) you care a lot about performance
10:09:56 <merijn> leshow: attoparsec is designed for something different
10:10:03 <Cale> So that's why they're "trivially" balanced, because it's a "for all" condition on an empty set.
10:10:22 <merijn> leshow: attoparsec is designed for fastest possible parsing, but shitty errors (i.e. when parsing computer generated output)
10:10:26 <virgin> i don't understand how leaves can not be balanced? i understand hot left tree is not balanced with the right one for example the left has just a leaf and the right has many trees in it
10:10:29 <ertes-w> virgin: it's similar to how you define evenness of natural numbers:  x + 2 is even, if x is even…  and we define 0 to be even
10:10:39 <merijn> leshow: megaparsec and parsec are designed for human produced input and giving useful parse errors
10:10:45 <Cale> virgin: Well, we could have defined them to not be balanced if we wanted.
10:11:18 <Cale> virgin: He's just pointing out that the definition he gave actually does imply that they are balanced
10:11:21 <shapr> today in Haskell class we parsed 6.1 million lines of text in thirteen seconds with attoparsec!
10:11:22 <ertes-w> virgin: in the same way you can define oddness:  x + 2 is odd, iff x is odd, and we define 1 to be odd
10:11:26 <shapr> oh, I should push today's changes
10:12:24 <ertes-w> virgin: (Branch xs ys) is balanced, if xs and ys are balanced and their height differs by at most 1…  we define (Leaf x) to be balanced for all x
10:13:21 <Cale> ertes: Not their height -- their leaf count
10:13:34 <virgin> ertes-w i dont understand your ending.
10:13:35 <Cale> (according to this definition)
10:13:40 <ertes-w> oh, sorry
10:13:59 <virgin> the (Leaf x) etc'
10:14:14 <Cale> virgin: What don't you understand about it?
10:14:20 <ertes-w> virgin: we're defining a property for trees, so we can determine if any particular tree has that property, right?
10:14:29 <virgin> yes
10:14:35 <Cale> virgin: We're defining what the word "balanced" means. In order to do so, we have to say what it means for any tree.
10:14:49 <Cale> Leaf x is a tree, so we'd better say what it means for that tree.
10:14:49 <ertes-w> virgin: so we define when that property holds…  but trees come in two forms
10:15:09 <ertes-w> virgin: a tree is either of the shape (Branch xs ys) for some xs and ys, or of the shape (Leaf x) for some x
10:15:27 <Cale> Actually, the text gives a definition which works for any tree at all, but it's perhaps not obvious to everyone that it does.
10:15:40 <Cale> So he just clarifies what happens in the edge case.
10:15:56 <Cale> (when you have no 'Node' constructors)
10:16:05 <ertes-w> virgin: we have to define this property for both of them…  so we simply define that any leaf is balanced…  it's an outright declaration
10:16:20 <ertes-w> virgin: much like we *declare* 0 to be an even number
10:19:13 <virgin> ertes-w: wait a second. maybe i understand :-). the leaf's is balanced mean that in every branch of the tree(left and right), it ends with both left and right as Leafs and not in (for example) left is a Leaf and the right is (Tree a)?
10:19:48 <ertes-w> virgin: no…  imagine you're writing a function that takes a tree and returns a Bool, whether it's balanced
10:19:54 <ertes-w> isBalanced :: Tree a -> Bool
10:20:18 <ertes-w> virgin: this function has two cases, one Branch case and one Leaf case
10:20:31 <virgin> OK
10:20:51 <ertes-w> we know how to write the Branch case:  isBalanced (Branch xs ys) = abs (leafCount xs - leafCount ys) <= 1
10:21:36 <virgin> OK
10:21:53 <ertes-w> virgin: but what about the Leaf case?  remember, just a leaf is also a tree by our definition of Tree
10:22:19 <ertes-w> isBalanced (Leaf x) = _  -- what do we return here?  True or False?  we have to decide!
10:24:30 <virgin> ertes-w but Leaf is a Leaf. i'ts just one thing and nothing recursive in it. i don't understand how can the Leaf's being not balanced. it is the Tree that i understand how he can be not balanced or balanced...
10:25:03 <ertes-w> virgin: there is nothing to understand here…  *you decide*, because you are defining what "balanced" means
10:26:37 <Taneb> virgin: it is possible to have a tree which is just a single leaf
10:27:28 <virgin> ertes-w OK thank you. by the way you had a nice solution for the branch thing :-)
10:27:49 <virgin> Taneb: thanks
10:28:24 <virgin> maybe i need to have sex :-D
10:28:44 <virgin> thank you all for the answers. you are (again) very kind!
10:28:45 <EvanR> not until you can implement trees in haskell
10:28:58 <virgin> hahahaha
10:29:42 <virgin> EvanR: i mean by hahahaha to LOL :-D
10:29:54 <virgin> if it was not understood.
10:30:22 <EvanR> people in #scala are going to wonder what all the laughing in here is about
10:35:08 <EvanR> it is said that in haskell you can't implement the natural numbers data type because data N = Z | S !N still allows a bottom value
10:36:16 <EvanR> i saw this in a proposal to allow boxed but unlifted runtime objects, which would ensure that the value would always be evaluated even if users did not use strict patterns
10:36:38 <EvanR> but, would THAT be a faithful natural number type?
10:36:46 <EvanR> still unclear
10:38:44 <edwardk> c_wraith: show the result has the same strictness properties in all situations with/without and send a patch
10:39:08 <edwardk> a lot of the NonEmpty code is glued together from 2-3 sources
10:39:23 <armlesshobo> EvanR: trees are the first thing you learn to implement lol
10:39:31 <c_wraith> edwardk, hmm. not sure what such a proof (or sketch of one) would look like
10:40:26 <c_wraith> edwardk, I have unfortunately created a mental model of non-strict evaluation which seems to get me correct results but is difficult to communicate. :)
10:40:37 <armlesshobo> EvanR: http://learnyouahaskell.com/zippers
10:40:47 <EvanR> i have some education and i recall munging some trees in class, but im not so sure about the tree capabilities of most of my peers
10:41:38 <EvanR> in the web you have assoc arrays and database tables, fairly rectangular looking things
10:42:19 <c_wraith> EvanR, "in the web"?
10:43:13 <EvanR> web trade
10:44:01 <c_wraith> here's a secret: you can cram a tree into a relational table. :P
10:44:09 <armlesshobo> lol
10:44:11 <EvanR> ive never actually used Data.Tree for something
10:44:27 <armlesshobo> must be useless then :P
10:44:28 <EvanR> c_wraith: yeah that always comes up and somebody comes screaming into the room to stop you
10:44:33 <Cale> c_wraith: But can you prevent it from becoming a graph due to bugs? :)
10:45:38 <c_wraith> Cale, no. those are "fun" bugs, why deprive someone of the "joy" of fixing them?
10:46:04 <Welkin> I've never used a tree outside of educational exercises o.o
10:46:16 <c_wraith> I use trees all the time...
10:46:20 <EvanR> well you use Data.Map
10:46:28 <Welkin> it's mostly tables, arrays, lists
10:46:33 <Welkin> sure, but that is an implementation detail
10:46:38 <Welkin> I treat it like a table
10:46:46 <EvanR> ^
10:47:19 <Welkin> oh yeah, and then graphs of course for anything like pathfinding
10:47:45 <Welkin> which is really just an array anyway o.o
10:47:58 <EvanR> its really just zeros and ones, whats the problem
11:08:13 <edwardk> c_wraith for head and tail showing how both behave on foo _|_ , foo (_|_ :| []) and foo (():| _|_) would completely suffice
11:16:54 <ospa> Hi! Is there any standard haskell function which would allow me to fold the NonEmpty list without requiring its elements to be Monoids? I only want them to be Semigroups
11:17:29 <cocreature> :t fold1
11:17:32 <lambdabot> error:
11:17:32 <lambdabot>     • Variable not in scope: fold1
11:17:32 <lambdabot>     • Perhaps you meant one of these:
11:17:41 <cocreature> :t Data.Semigroup.Foldable.fold1
11:17:41 <glguy> http://hackage.haskell.org/package/semigroupoids-5.2.2/docs/Data-Semigroup-Foldable.html
11:17:42 <lambdabot> (Data.Semigroup.Semigroup m, Data.Semigroup.Foldable.Class.Foldable1 t) => t m -> m
11:18:22 <ospa> oh oh !
11:18:27 <ospa> thats what I was looking for!
11:18:30 <ospa> thank you so much!
11:23:05 <mtjmullen> semigroupoids is a cool package
11:31:53 <w1n5t0n_> hey everyone, long story short I'm making an eDSL in Haskell for live coding, so I'm looking to see how much I can bend the syntax for convenience. I'm trying to achieve something a workflow like this: "    "amp" <>< 10 + sin t    ", which takes a name on the left, a "Signal Value" on the right, and evaluates the Signal for a certain time window and saving it to a file with that name.
11:32:36 <w1n5t0n_> My question is: is it even possible to automatically bind t to the time value passed into the signal when it's rendered/evaluated?
11:33:18 <w1n5t0n_> so that "sin t*2" translates to "Signal \t -> sin $ 2*t"
11:34:12 <ClaudiusMaximus> you could maybe define a Num instance for functions, and write  10 + sin  (without the explicit t) ?
11:34:23 <Tuplanolla> You can go absolutely nuts with syntax if you don't mind using TH, w1n5t0n_.
11:34:34 <Tuplanolla> @google haskell needle arrows
11:34:35 <lambdabot> https://hackage.haskell.org/package/needle
11:35:36 <spruit11> Invitation to join #egel and help me blow up a small untyped functional language/find some bugs.
11:35:58 <w1n5t0n_> ClaudiusMaximus: I can, the problem is I want to be able to manipulate t as it's passed into the function. in other words, I want to be able to do stuff like "sin t + sin (2*t + t/3)" so that, whenever passed the same argument of time, they treat it differently
11:36:01 <EvanR> ClaudiusMaximus: Applicative instance please
11:36:12 <sl2c> ClaudiusMaximus: well, if w1n5t0n_ is using a Signal type, the num instance would work pretty well I think
11:36:48 <w1n5t0n_> I have "Signal a = Signal {sigFunc :: Time -> a}"
11:36:52 <EvanR> :t liftA2 (+) sin (\t -> sin (2*t + t/3))
11:36:53 <w1n5t0n_> data Signal a *
11:36:53 <lambdabot> Floating c => c -> c
11:37:22 <sl2c> actually yeah num and applicative would work
11:37:36 <EvanR> you dont actually need Num
11:37:36 <sl2c> sin <$> (2*t)
11:38:23 <sl2c> EvanR: yeah but I think it'd make the syntax a little nicer
11:39:02 <EvanR> something theoretical annoys me about Num instance for functions
11:39:37 <EvanR> syntax abuse aside
11:40:28 <ClaudiusMaximus> another approach might be to have an expression ADT, with a special value for t?  then <>< could interpret the right hand side
11:40:34 <ClaudiusMaximus> > sin (2 * t + t / 3) :: Expr
11:40:37 <lambdabot>  sin (2 * t + t / 3)
11:41:05 <ClaudiusMaximus> or JIT it using LLVM, whatever
11:44:06 <Welkin> what is <><? a jesus fish combinator?
11:44:32 <EvanR> :t (<><)
11:44:33 <lambdabot> error:
11:44:33 <lambdabot>     • Variable not in scope: <><
11:44:33 <lambdabot>     • Perhaps you meant one of these:
11:46:02 <w1n5t0n_> Welkin: it's a visual hook for the assignment of a Signal Value to a synthesizer parameter, looks a bit like an audio jack and also yes like a fish :D
11:46:47 <Welkin> <== looks more like an audio connector
11:53:52 <`Guest00000> <user> Hi! Is there any standard haskell function which would allow me to add two numbers without requiring them to be Nums? I only want them to be Addable <helpfulOne> user: take a look at http://hackage.haskell.org/package/BIG-REDUNDANT-PACKAGE-5.2.2/docs/Data-Numbers-Addable.html <user> helpfulOne: Oh, that's exactly what I need! Thank you! <person2> BIG-REDUNDANT-PACKAGE is really cool
12:01:24 <MarcelineVQ> it is nice to have the exact thing you need
12:02:23 <`Guest00000> at the cost of pulling gigabyte dependencies
12:02:36 <MarcelineVQ> hyperbole is cheap luckily
12:02:53 <MarcelineVQ> Num is a bit monolithic, this is actually a package that would find use
12:03:29 <MarcelineVQ> some people might want negative numbers to be seperate for example
12:04:50 <`Guest00000> i didn't intend to address this situation specifically, i just tried to reference many such cases happening
12:05:44 <MarcelineVQ> I imagine that each case tends to be a similar story, the search for a better fit to a problem
12:07:14 <anks> Is it possible to somehow automatically derive instance of my Serializable class for a type with Binary class? Wrt this paste: https://gist.github.com/12c9d632c381d5e974cec1d3966749c8
12:07:55 <jle`> you can use default instance sigs
12:08:13 <jle`> actually soon you'll be able to use DerivingVia
12:08:35 <jle`> but for now there's some TH to simulate it until it lands
12:08:46 <anks> Ok, gotta google for it
12:08:48 <jle`> http://hackage.haskell.org/package/deriving-compat-0.4.1/docs/Data-Deriving-Via.html
12:09:27 <jle`> but that's only useful if there are multiple 'default insatnces' possible
12:09:40 <jle`> in your case, if Binary is the canonical default, you can use default instance sigs
12:10:03 <jle`> default serialize :: Binary a => a -> LByteString
12:10:07 <jle`> serialize = encode
12:10:37 <jle`> then if someone just writes 'instance Serializable MyType', the instances will be filled out automatically if MyType is an instance of Binary
12:11:18 <anks> that's good enough, thank you!
12:11:34 <Welkin> any relation to the VIA microprocessor?
12:12:05 <nitrix> Hi, how does GHC implements partial application?
12:12:05 <nitrix> Is it essentially a function pointer to the function and a struct containing all the arguments that have been fixed (captured from the environment)?
12:12:23 <Welkin> nitrix: there is no partial application
12:12:37 <nitrix> Welkin: What's the trick?
12:12:45 <Welkin> currying
12:15:34 <nitrix> Welkin: So you're suggesting foo :: a -> b -> c -> d, is actually implemented as `some_func_ptr_type foo_1(value_type a)`, `some_func_ptr_type foo_2(value_type b)` and so forth?
12:15:40 <athan_> nitrix: check out the paper on the implementation of miranda, it's a good intro to STG and supercombinator comilation techniques
12:15:51 <nitrix> Welkin: (If I was going C code generation)
12:16:03 <nitrix> *doing
12:16:29 <nitrix> Somehow the arguments must be retained along the way :X
12:20:49 <nitrix> athan_: Welkin Here's why I'm confused. Even if I were to generate multiple functions in C for each argument application (which you refer to as currying, but currying to me is more related to tuples, but anyway), assuming I do that, the function takes one argument and yields a function pointer, but that's not enough to capture the argument it received.
12:21:13 <nitrix> athan_: Welkin It seems to me like there needs to be an additional mechanism for doing closures.
12:23:09 <cocreature> nitrix: sounds like https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects might be helpful.
12:24:09 <nitrix> cocreature: Oh that seems on the right track! :]
12:24:47 <cocreature> the stg paper also has something on this iirc but I’m not sure how closely it matches today’s ghc
12:27:13 <nitrix> cocreature: Whao that seems to confirm my thoughts. There's probably tricks used for {-# UNPACK #-} and friends, but it's encouraging :]
12:27:28 <nitrix> cocreature: I'll read and ask #ghc if I have questions. Very much appreciated.
12:28:52 <spruit11> If people are interested in implementation of combinator machines or graph rewriting there is https://egel-lang.github.io/
12:29:03 <spruit11> And the #egel channel.
12:29:35 <spruit11> I just did this for a simplistic language so any questions you have, I'll gladly answer.
12:34:24 <tathougies> How do you make lenses for an associated data type? Like 'class Class1 a where { data V a :: *;}' and 'instance Class1 Int where { data V Int = IntV { _intvField1 :: Int, _intvField2 :: Int } ]'?
12:34:41 <tathougies> (with template haskell; i know how to write them by hand)
12:39:51 <[exa]> Hm guys, is there a zipper-like structure for matrices?
12:40:11 <nitrix> I have a strange thought now, reading wikipedia; does Haskell fall into the category of having rank-n polymorphism now that we have unified it all with the TypeInType?
12:41:11 <Cale> Uh, what is "Haskell"? The RankNTypes extension is way older than TypeInType
12:41:38 <nitrix> My question was more aimed at the implications of TypeInType.
12:43:27 <nitrix> Cale: Yeah but RankNTypes had the problem of sometimes not being decideable, right? With TypeInType, it should behave as Rank-2, which is decideable.
12:50:50 <Welkin> Cale: Haskell is a collection of dialects
12:50:51 <Welkin> :D
13:00:01 <subeff> hi guys! same noobie question keeps coming back to me, I wonder how do you write a square function using the (*) multiply function. Basically I what are those utility functions that turn a function that accepts two arguments to return a function that accepts one and feed the same parameter to both the underlying basically it should be smth like "fork f a = f a a" and use it like "square = fork (*)" any ideas of a built in function lik
13:04:06 <toby1851> subeff: you can search hoogle by type, so if you can work out the type of 'fork' you can see if anything like it already exists
13:04:26 <tathougies> [exa] you can derive a zipper for any data type mechanically
13:06:45 <subeff> toby1851: yea I already looked there but only some folding stuff seems to be getting out that do not really accept a regular argument but more like a functor
13:06:59 <`Guest00000> subeff: join
13:07:03 <`Guest00000> > join (*) 5
13:07:06 <lambdabot>  25
13:07:32 <subeff> that's it! `Guest00000`
13:07:54 <`Guest00000> join flattens two levels of a monad into one, a function (a -> b) is a value of monad (a ->)
13:08:09 <`Guest00000> :t join :: (a -> a -> b) -> (a -> b)
13:08:11 <lambdabot> (a -> a -> b) -> a -> b
13:08:32 * toby1851 is gobsmacked
13:08:57 <MarcelineVQ> You'll want to ice that
13:09:17 <toby1851> i came across join just recently (it's handy when you want to fmap readMay over a Maybe x)
13:09:24 <[exa]> tathougies: yeah but using derivation on a list-based matrix causes a bit of complexity explosion
13:10:56 <tathougies> [exa]: how so? If you have 'ListZipper a', then just do 'ListZipper (ListZipper a)', no?
13:11:50 <tathougies> [exa]: You can also use delimited continuations to implement zippers with more 'arbitrary' shapes, although you'll still have to do work to figure out the best representations for your use case. The advantage is that you can 'swap out' strategies
13:12:49 <`Guest00000> subeff: a function (a -> b) is a value of the functor (a ->)
13:13:37 <[exa]> tathougies: ListZipper (ListZipper a) keeps all matrix rows focused on their individual columns
13:13:59 <[exa]> tathougies: but yes that's probably the easiest way around, lazily catch up with the row zipper when something changes
13:14:08 <`Guest00000> you could have found join but not recognize it.
13:14:17 <tathougies> [exa] Oh I see what you want
13:14:19 <toby1851> i've got something in an IO-based monad that returns a Maybe type; if it returns a value, i want to pass it on to another function: clientIP >>= maybe (return ()) ssoSetIP
13:14:20 <`Guest00000> as what you want
13:14:41 <tathougies> [exa] I would explore the use of delimited continuations, personally
13:14:46 <subeff> `Guest00000` :D damn I knew it but I my mind got twisted at this very moment, I will try harder next time
13:14:52 <toby1851> that works, but there's a lot of noise to handle the Nothing case - is there something more succinct?
13:14:59 <[exa]> tathougies: will try, thanks :]
13:17:07 <doublescale> toby1851, I think clientIP >>= mapM_ ssoSetIP might work
13:17:23 <`Guest00000> toby1851: maybe you want a MaybeT IO, a combined Maybe + IO monad which is acquired using the monad transformer MaybeT
13:17:49 <`Guest00000> > lift :: IO a -> MaybeT IO a
13:17:51 <lambdabot>  error:
13:17:52 <lambdabot>      Not in scope: type constructor or class ‘MaybeT’
13:17:52 <lambdabot>      Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
13:17:52 <`Guest00000> :t lift :: IO a -> MaybeT IO a
13:17:53 <lambdabot> error:
13:17:53 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
13:17:54 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
13:20:25 <toby1851> hmm... people are always telling me that what really want is a monad transformer
13:20:38 <toby1851> sometimes i even manage to convince myself i've understood them for a day or two
13:20:48 <Cale> Only use MaybeT if you have a lot of things of the same sort
13:20:56 <Cale> If it's just one line, that's a bit silly
13:22:24 <toby1851> mapM_ looks good, thanks doublescale
13:22:34 <doublescale> :t \x f -> x >>= mapM_ f
13:22:35 <lambdabot> (Foldable t, Monad m) => m (t a) -> (a -> m b) -> m ()
13:22:48 <`Guest00000> MaybeT :: IO (Maybe a) -> MaybeT IO a
13:23:14 <doublescale> toby1851, I've just realized that handy Foldable instance for Maybe myself :)
13:46:03 <benharri> hi
13:49:09 <`Guest00000>  hi
13:49:31 <jle`> hi
13:49:39 <mtjmullen> hello
13:51:39 <jle`> > text . map chr . take 2 $ [104..]
13:51:42 <lambdabot>  hi
13:52:33 <benharri> Ha nice
13:52:34 <infinisil> Wow, didn't ever think about this, but that's really neat
14:07:50 <EvanR> what is the "right" unicode character for |-
14:08:34 <Welkin> a turnstile?
14:08:45 <EvanR> that
14:08:51 <Welkin> https://cs.au.dk/~mis/typeinf.p(s|df)
14:08:54 <Welkin> er
14:08:58 <Welkin> https://en.wikipedia.org/wiki/List_of_mathematical_symbols
14:09:10 <EvanR> :|
14:10:07 <Welkin> here https://en.wikipedia.org/wiki/List_of_logic_symbols
14:10:13 <Welkin> ⊢
14:10:14 <doublescale> My Unicode table suggests ⊢, U+22A2, "Right Tack"
14:10:24 <Welkin> https://en.wikipedia.org/wiki/Turnstile_(symbol)
14:10:26 <EvanR> it looks nice
14:10:39 <EvanR> from here
14:10:58 <EvanR> wikipedia is using images and also refers to another "assertion sign"
14:11:14 <spruit11> ⊢
14:11:35 <spruit11> In the left column of wikipedia it just shows the Unicode turnstile.
14:12:13 <Welkin> double turnstile! ⊨
14:12:43 <infinisil> aka "models", used in logic
14:13:01 <EvanR> the fact that there seems to be no unique "unicode turnstyle" hences my question
14:13:26 <EvanR> assertion sign looks crappy in all my fonts :(
14:13:38 <Welkin> get better fonts
14:13:53 <Welkin> use firacode or another ligature font
14:14:29 <EvanR> true we should just switch to images of text like twitter has
14:14:43 <EvanR> full designer control
14:16:36 <`Guest00000> no
14:16:47 <`Guest00000> need to have a language
14:16:58 <`Guest00000> for text.
14:17:10 * EvanR brain explode
14:18:07 <texasmynsted> anybody read this book?  https://www.manning.com/books/get-programming-with-haskell
14:19:33 <Welkin> texasmynsted: it says it is not released yet
14:19:35 <Welkin> never heard of it
14:23:40 <trulsa> Does anyone know how to make a haskell shared library built as a foreign-library using cabal link against the threaded rts?
14:27:45 <jle`> "Get programming with haskell introduces you to haskell without drowning you in academic jargon and heavy functional programming theory"
14:28:06 <jle`> is there any introduction to Haskell that *does* use a lot of academic jargon and heavy functional programming theory?
14:28:21 <jle`> i haven't read or heard of any actual haskell introduction for beginners that does so
14:28:51 <Welkin> lol
14:28:54 <johnw> if I have a function that SEGVs even when compiled with -O0, but runs just fine in ghci, what sort of problem might that point to?
14:29:02 <Welkin> it's like joe the plumber
14:29:03 <Welkin> common myth
14:29:28 <Welkin> I find that most programming books are absolutely terrible, and I don't understand how they get published
14:29:32 <geekosaur> johnw, try -O0 -threaded ?
14:29:38 <Welkin> the best one I have found it Land of Lisp
14:29:44 <EvanR> jle`: sounds like a cool project though
14:29:46 <infinisil> jle`: well in my university we started with haskell along with formal modelling
14:29:47 <johnw> geekosaur: rying
14:29:54 <bulters> Welkin: that IS A nice book...
14:29:56 <Welkin> many are mediocre, but you have to fight to get your way through them
14:30:07 <johnw> doesn't help :(
14:30:12 <geekosaur> but that doesn;t cover all the differences; ghci generally doesn;t let you use the POSIX main thread directly, ghc usually doesn;t let you avoid it
14:30:13 <jle`> infinisil: ah, so the book is contrasting itself to university haskell courses
14:30:19 <jle`> and not with other haskell introduction books?
14:33:25 <texasmynsted> Welkin: is it possible to get it pre-release
14:33:27 <Welkin> if I really think about it, I never learned how to program from a book, nor have I ever learned a programming language from a book
14:33:53 <Welkin> I learned haskell almost entirely from this IRC channel, reading blog posts, papers, and doing projects o.o
14:34:38 <texasmynsted> I think I must just really like books
14:34:40 <Welkin> and reading *tons* of code
14:34:46 <Welkin> I like books too
14:34:46 <infinisil> jle`: honestly the haskell i learned in that course was pathetic
14:34:55 <zachk> programming in haskell by graham hutton cleared up alot of my newbie questions about haskell when I was beginning
14:34:57 <jle`> i would expect so ;)
14:35:05 <infinisil> Okay it's called "Introduction to Functional Programming and Formal Models", but still
14:35:16 <Welkin> zachk: I have a copy of that and it seems decent
14:35:20 <infinisil> We barely touched the IO monad
14:35:46 <jle`> to be fair, IO sounds out of scope for a 1st semester formal models course
14:35:47 <EvanR> sounds awesome
14:36:05 <Welkin> no "Hellow World!" for you!
14:36:28 <EvanR> > "Hello World"
14:36:30 <lambdabot>  "Hello World"
14:36:38 <infinisil> jle`: Hmm, it's the 4th semester of a computer science bachelor in ETH in switzerland, considered one of the best universities in the world
14:36:53 <texasmynsted> I like _Haskell Programming from First Principles_ and also _Haskell High Performance Programming_
14:36:56 <Welkin> what is with universities in europe teaching haskell?
14:37:02 <jle`> i mean, an 'introducton to formal models', instead of 'going in depth into formal models'
14:37:09 <infinisil> Welkin: What is with ones that don't you mean?
14:37:15 <EvanR> haskell is the lisp of europe
14:37:16 <Welkin> and unforunately it seems like the stupid don't give a *fuck*
14:37:20 <infinisil> jle`: yeah i guess
14:37:21 <Welkin> haha
14:37:31 <spruit11> Lisp is the Haskell of the US.
14:37:31 <Welkin> the stupid -> the students*
14:37:44 <EvanR> freudian slip
14:37:46 <Welkin> I don't know any unis that teach lisp in the US
14:37:53 <Welkin> MIT switched to python from scheme
14:38:43 <spruit11> Yah, I heard that. Not the worst decision.
14:38:52 <Welkin> it is a poor decision
14:38:59 <Welkin> python is nothing at all like scheme
14:39:05 <spruit11> Depends on what you want.
14:39:08 <Welkin> it doesn't even have proper support for recursion
14:39:10 <EvanR> america -> alonzo church -> ? -> lisp
14:39:19 <Welkin> how do you do recursion when you blow the stack in a couple seconds?
14:39:26 <EvanR> britain -> turing -> ??? -> haskell
14:39:44 <Welkin> no first class functions either
14:39:45 <EvanR> best historiographic dumbing down ever
14:39:53 <Welkin> very poor decision
14:39:59 <spruit11> my bed -> godel -> ??? -> *more confusion* -> ??? -> Egel!
14:39:59 <EvanR> python doesnt do recursion
14:40:19 <saksham> Welkin: you can pass functions around etc, in Python.
14:40:26 <infinisil> Lol the Introduction to Programming course at ETH was done in...
14:40:30 <infinisil> Wait for it..
14:40:30 <Welkin> saksham: they are not first class though
14:40:35 <infinisil> EIFFEL
14:40:41 <EvanR> nice
14:40:46 <infinisil> You don't wanna program in eiffel i tell you
14:40:57 <CodeKiwi> I had a FORTRAN course around 2009...
14:40:57 <EvanR> eiffel is very principled
14:40:57 <mnoonan> Welkin: in what sense are they not first class?
14:41:13 <texasmynsted> Haskell would have been a better choice than python
14:41:15 <EvanR> like cake PHP
14:41:23 <saksham> Indeed. I usually assume passing around / assigning to variables is a good enough definition of first class.
14:41:40 <infinisil> But they did switch from Eiffel to Java now, because the only professor in the whole world that teaches Eiffel retired
14:41:42 <texasmynsted> shceme would have been a better choice than python
14:41:47 <Welkin> python lacks lexical scoping
14:41:53 <infinisil> Hint: It was the creator of Eiffel
14:41:58 <infinisil> He was the only one teaching it
14:42:18 <EvanR> so eiffel took the long "one person uses it, the creator" route
14:44:03 <saksham> Anyway, here in India (IIT Kanpur), we have a FP course in Haskell which covers a decent amount.
14:44:32 <saksham> Slightly unrelated, but there's another uni here (IIT Delhi) which actually had their intro to programming course in OCaml.
14:44:45 <spruit11> Both are okay choices.
14:44:56 <Welkin> universities seem to ruin a lot of things
14:45:02 <infinisil> At least I can say "I've been there, I've programmed in Eiffel" as one of the last person ever
14:45:08 <Welkin> even if they choose a good language, they will make the stupid think it is lame and hate it
14:45:16 <Welkin> haha
14:45:18 <Welkin> I did it again
14:45:21 <koala_man> wow
14:45:22 <Welkin> the stupid -> the students*
14:45:23 <texasmynsted> Not sure why a university would not use Idris
14:45:28 <infinisil> Welkin: yeah..
14:45:53 <Welkin> Haskell is a very good language for a 2nd or 3rd year course on functional programming
14:46:04 <spruit11> I used it.
14:46:11 <infinisil> I think with this stupid simple haskell introduction in our university they bolted a lot of students into thinking haskell can only be used for useless mathematical stuff
14:46:13 <Welkin> I would probably start with scheme or racket (with contracts -> typed racket)
14:46:17 <texasmynsted> The idea would be to teach concepts rather than teach a language that the students could run out and build business apps with.
14:46:52 <texasmynsted> racket would be good
14:46:57 <infinisil> texasmynsted: Hmm not sure about that, dependent typing is a heavy beast
14:47:25 <infinisil> texasmynsted: a lot of people take a while to even get non-dependent typing
14:47:29 <spruit11> The advantage of Haskell over other languages is that it teaches students to think algebraically.
14:47:49 <infinisil> spruit11: define other languages
14:47:50 <Welkin> How To Design Programs is a good book (which uses a dialect of racket)
14:48:00 <spruit11> Just getting them there is okay enough for me for an introductionary course.
14:48:04 <Welkin> the core of the book is basically to write racket like it is haskell
14:48:07 <Welkin> haha
14:48:27 <Welkin> they tell you to write down a type signature for every function in the comments along with other information for your function
14:48:43 <texasmynsted> Hmm.  I wonder what book would be great for teaching how to model algebraic data types for FP?
14:48:48 <Welkin> and later on they introduce contracts (runtime "type" checking kind of like dependent types)
14:49:27 <saksham> Well, somewhat like blasphemy here, but I enjoy writing Scala a huge lot. Although it should definitely not be exposed to a newbie, too many ways to write bad code (coupled with too many ways to write good code). The focus is more on subtyping in place of algebraic data types there.
14:49:37 <Welkin> I have not read the whole book as it is quite long, but so far it is the best, most thorough book I have found on programming fundamentals
14:50:13 <texasmynsted> I like scala, but not sure it is a great choice for Uni.
14:50:49 <Welkin> How To Design Programs + some book/course on machine level programming with assembly would be the ideal intro to software
14:51:25 <infinisil> Fun fact, Nix can do some stuff dependent languages only can
14:51:40 <infinisil> E.g. a printf that takes a variable number of arguments depending on the first one
14:51:52 <Welkin> my first-year C programming course was terrible
14:51:59 <spruit11> Anyway. I still need people to help me blow up/debug my language. https://egel-lang.github.io/ . If anyone is interested join me on #egel.
14:52:18 <saksham> infinisil: Isn't Nix interpreted? Correct me if I'm wrong, but compile time and runtime checks are the same in Nix.
14:52:22 <Welkin> I had to take 2 semesters of C programming classes, haha
14:52:26 <Welkin> the second was the only useful one
14:52:35 <infinisil> saksham: yeah it's interpreted :P
14:53:08 <saksham> So in that case, they're probably just checking the types of the later arguments after actually evaluating the first argument (format string).
14:53:18 <infinisil> But functional, with space as function application and
14:53:41 <spruit11> I got two hours introduction into C. After that, it was expected you could program in it.
14:53:44 <infinisil> saksham: it's just partial evaluation
14:54:03 <saksham> Yeah, well. Python is untyped functional too. It makes no sense to talk about dependent types in interpreted functional languages (or I'm very badly mistaken).
14:54:28 <saksham> ^ Making lot of strong statements here, definitely not fully sure of this.
14:54:32 <johnw> if Python is "untyped functional", then what exactly does functional mean?
14:54:39 <infinisil> I'm honestly not sure how much it makes sense to do that, because there are still types, just not at compile-time
14:54:47 <spruit11> Types and interpretation are orthogonal.
14:54:48 <Welkin> python is anything but functional
14:55:01 <Welkin> you cannot do anything resembling functional programming with it
14:55:19 <infinisil> spruit11: but types still need to be checked at runtime, you can't add strings to numbers after all
14:55:23 <saksham> Uh, I could write any untyped lambda calculus program in Python and run it just fine. I tried to, once.
14:55:44 <sternmull> What do I have to do to use Data.ByteString.empty like this: case bs of; empty -> foo; _ -> bar;"? I thought ViewPatterns extension would help... but it doesn't.
14:55:45 <infinisil> (let's ignore javascript here)
14:55:57 <saksham> infinisil: definitely a good idea :)
14:56:10 <spruit11> infinisil: That depends on the type system. And then it's still orthogonal to interpretation/compilation.
14:56:44 <Welkin> sternmull: case BS.empty bs of ...
14:57:07 <jle`> :t BS.empty
14:57:09 <lambdabot> BSC.ByteString
14:57:09 <saksham> Here's a working lambda calculus function for odd numeral check in Python: https://pastebin.com/b3zQ1pCg
14:57:21 <jle`> :t BS.null
14:57:22 <lambdabot> BSC.ByteString -> Bool
14:57:29 <Welkin> lol
14:57:33 <Welkin> yeah, use null instead
14:57:35 <jle`> sternmull: you might be confusing ViewPatterns and PatternSynonyms
14:57:39 <Welkin> empty constructs a new bytestring
14:58:15 <jle`> i confuse them too a lot when enabing extensions heh
14:58:40 <sternmull> jle`: I feel very confused right now... to be clear: I want to branch on the value of a ByteString and handle the empty value. Then i have to write case BS.empty myValue of ...?
14:58:56 <johnw> sternmull: you could just say if BS.null bs then ... else ...
14:59:29 <jle`> > if null [1,2,3] then "hi" else "bye"
14:59:32 <lambdabot>  "bye"
14:59:38 <jle`> > if null [] then "hi" else "bye"
14:59:41 <lambdabot>  "hi"
14:59:45 <jle`> alternatively you can use guards
14:59:52 <jle`> if you are defining a function
14:59:56 <sternmull> johnw: Of course! That would help to get it done. But I still wonder what is wrong with using BS.empty as "test-value" in a case expression...
14:59:59 <Welkin> boolean guards*
15:00:10 <jle`> sternmull: do you know what 'empty -> ...' is parsed as?
15:00:13 <Welkin> there are also pattern guards
15:00:25 <johnw> well, empty is the name of a value, it's not a constructor
15:00:29 <jle`> sternmull: it's a wildcard pattern that matches anything
15:00:37 <jle`> > case [1,2,3] of empty -> "hi"
15:00:39 <sternmull> jle': No. I thought it would be just evaluate to its value.
15:00:40 <lambdabot>  "hi"
15:00:50 <jle`> > case [1,2,3] of someidentifierthatisnotemptybutisstillavalidpattern -> "hi"
15:00:52 <lambdabot>  "hi"
15:01:00 <jle`> > case [1,2,3] of xs -> "hi"
15:01:01 <johnw> BS.empty unfolds to: BS.Internal.PS nullPtr 0 0
15:01:02 <lambdabot>  "hi"
15:01:05 <johnw> or something like that
15:01:17 <sternmull> johnw: Thanks! That value/constructor distinction got lost in my head!
15:01:27 <jle`> sternmull: doing 'case bs of empty -> ...' is the same as 'case bs of xs -> ...'
15:01:35 <jle`> it's just a pattern match on a wildcard pattern
15:01:40 <Welkin> let f xs | null xs = "Ach-jah!" | otherwise = "Neesh-neesh" in f []
15:01:43 <Welkin> > let f xs | null xs = "Ach-jah!" | otherwise = "Neesh-neesh" in f []
15:01:45 <lambdabot>  "Ach-jah!"
15:01:48 <Welkin> > let f xs | null xs = "Ach-jah!" | otherwise = "Neesh-neesh" in f [1]
15:01:51 <lambdabot>  "Neesh-neesh"
15:01:54 <jle`> a lot of people run into this actually when using 'otherwise' as a pattern
15:02:05 <jle`> > case [1,2,3] of [] -> "hi"; otherwise -> "bye"
15:02:07 <lambdabot>  "bye"
15:02:08 <Welkin> otherwise = True
15:02:17 <jle`> "oh hey you can use otherwise in cases??"
15:02:20 <Welkin> it's a synonym
15:03:07 <Welkin> wait what?
15:03:21 <Welkin> is otherwise replaced with _ there?
15:03:25 <jle`> > case [1,2,3] of [] -> "hi"; xs -> "bye"
15:03:27 <jle`> Welkin: it's being shadowed
15:03:28 <lambdabot>  "bye"
15:03:38 <Welkin> oh
15:03:40 <Welkin> I see
15:03:40 <Welkin> yeah
15:03:48 <jle`> it's a wildcard pattern; 'otherwise' is not a language keyword
15:04:07 <jle`> but yeah it's a funny thing that people often accidentally stumble upon
15:04:09 <johnw> otherwise = True
15:04:16 <infinisil> > :t otherwise
15:04:19 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
15:04:20 <sternmull> That helped. Thank you all. It is more painful than expected to come back to Haskell after a few months...
15:04:23 <johnw> @src otherwise
15:04:24 <lambdabot> otherwise = True
15:04:30 <sl2c> :t otherwise
15:04:32 <lambdabot> Bool
15:04:40 <parsnip> > otherwise == True
15:04:43 <lambdabot>  True
15:04:54 <sl2c> > otherwise
15:04:54 <jle`> sternmull: no problem!  for what it's worth, haskell's distinction in pattern matching bindings vs. 'constructors' is basically if the identifier starts with an uppercase letter or not
15:04:56 <lambdabot>  True
15:05:07 <parsnip> > pred otherwise
15:05:09 <lambdabot>  False
15:05:17 <sl2c> parsnip: == True is indistinguishable from :: Bool when you think about it
15:05:18 <jle`> sternmull: if it's a lowercase letter, it's the same as 'xs' etc., a wildcard pattern match
15:05:18 <infinisil> lambdabot is so attempting to play with eh
15:05:47 <Welkin> using racket recently, I have had trouble distinguishing between constructors and regular functions, since the convention is for everything to be lowercase
15:06:04 <Welkin> so I capitalised all of my constructors, but that also means that all of the accessors are also capitalized
15:06:11 <jle`> sternmull: but, you can emulate the behavior you want with PatternSynonyms
15:06:18 <sternmull> jle`: I think i understand that. Pattern matches only work on "structure" not on "value". Just completely lost the two concepts for a moment...
15:06:31 <jle`> @let pattern NullList <- (null->True) where NullList = []
15:06:31 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
15:06:34 <Welkin> it shares a similar kind of accessor code generation with haskell
15:06:40 <jle`> hm
15:06:48 <jle`> no pattern synonyms in lambdabot?
15:06:51 <Welkin> sternmull: pattern matches work on anything that is a value
15:07:14 <sternmull> oh... then i have have to take a closer look.
15:07:53 <Welkin> > case "4" of "4" -> "wubba-lubba-dub-dub!" _ -> "aw geez"
15:07:56 <lambdabot>  <hint>:1:45: error: parse error on input ‘->’
15:08:01 <Welkin> > case "4" of "4" -> "wubba-lubba-dub-dub!"; _ -> "aw geez"
15:08:04 <lambdabot>  "wubba-lubba-dub-dub!"
15:08:12 <bulters> Welkin: what would you suggest as "the way" to learn haskell; having learned it (a.o.) from this channel? (sorry a bit late to read up)
15:08:22 <jle`> Welkin: that's just bcause '4' is a constructor
15:08:36 <jle`> or at least it's treated as one in pattern match syntax
15:08:46 <jle`> it's um. sugar
15:09:02 <Welkin> > case 4 of 4 -> "wubba-lubba-dub-dub!"; _ -> "aw geez"
15:09:05 <lambdabot>  "wubba-lubba-dub-dub!"
15:09:12 <Welkin> what is the constructor then?
15:09:21 <jle`> integer literals are also treated as constructors
15:09:25 <jle`> sugarly
15:09:27 <Welkin> it is Num a => a
15:09:33 <Welkin> it is not specifically an integer
15:09:43 <jle`> it's the literal
15:10:10 <Welkin> I suppose that makes sense
15:10:17 <Welkin> but that is all hidden from us
15:10:23 <Welkin> numbers in haskell are a lie
15:10:24 <jle`> the literal is a syntactic construct, the sugar lets us treat it syntactically like any other constructor syntax
15:10:39 <nitrix> Of all places, I never thought I'd see wubba-lubba-dub-dub on #haskell, haha.
15:10:42 <nitrix> Oh my.
15:10:58 <nitrix> We have a such a young crowd :3
15:11:15 <Welkin> bulters: I am not sure about any specific path
15:11:37 <Welkin> bulters: but if you stick around in this channel, you will learn far more than you will from any single book, and have a lot more fun too
15:11:53 <Welkin> bulters: read a ton of code and do some projects that are fun
15:11:57 <hpc> nitrix: we're programmers, not victorian-era thespians ;)
15:13:32 <bulters> Welkin: consider me a new regular; tried learning haskell two times before; got me a copy of hffp last time and got up to monads; and although I got my formal education in computer science and mathematics I'm just too pragmatic these days to deal with 700 pages of theory before "getting anything done"
15:14:14 <bulters> So I'll just lurk around here for a while and soak up stuff like "numbers in haskell are a lie" ;-)
15:14:20 <Welkin> bulters: I have heard/read so many people say "I tried to learn haskell 3 times and failed every time!" and I don't understand how or why that could happen
15:14:41 <Tuplanolla> It sounds like you could've skipped those first principles, bulters.
15:14:42 <johnw> I tried 3 times and failed twice
15:14:57 <Welkin> I really struggled a lot trying to learn from LYAH, but I joined this channel very early on and have never considered giving up
15:15:25 <Welkin> the thought of giving up on haskell never crossed my mind because I was too busy having my mind blown by how amazing it is
15:15:29 <Welkin> thanks to the people in this channel
15:16:26 <hpc> yeah
15:16:32 <Welkin> it will be tough for the first few months most likely
15:16:37 <hpc> haskell is definitely a case of something difficult being worth the effort
15:16:46 <Welkin> but after my first big project (which was a yesod website) I had a breakthrough
15:16:59 <Welkin> I do not recommend using yesod starting off though
15:17:24 <Welkin> but I spent many long nights reading the source code
15:17:46 <Welkin> reading the source from the base libraries is a very good idea
15:17:54 <Welkin> they are packed with insightful comments
15:18:00 <Welkin> and it is pretty clean
15:18:17 <Welkin> and of course, re-implementing the base library functions yourself
15:18:37 <Welkin> but most of all, have a project which you actually care about
15:18:49 <Welkin> not some stupid toy
15:18:54 <bulters> Tuplanolla: might have I guess...
15:19:11 <jle`> yeah i only learned haskell through working on projects i cared about/were interesting to me
15:19:16 <bulters> Welkin: It's a motivation/time thing (for me at least)
15:19:16 <jle`> in my normal life
15:19:28 <jle`> not just 'this is a project for learning haskell', but 'this is a project i need to get done'
15:19:49 <jle`> to be honest, if you don't have any use for programming, you probably won't get any meaningful benefit from learning haskell
15:20:03 <jle`> unless it's non-programming benefits
15:20:24 <jle`> but if programming is something you have use for, then you can just do your programming in haskell instead of whatever language you were already doing it in
15:20:45 <infinisil> I should finally create a bot for #nixos that evaluates nix code..
15:20:50 <infinisil> Wanna use haskell for it
15:21:03 <infinisil> And i have a simple bot running, but i think it leaks memory
15:21:03 <Welkin> even if you don't use haskell after you learn it (which is unlikely) it will forever change the way you program and make you a significantly better programmer
15:21:04 <bulters> Welkin: "failing" two times is of course not true; It's not like I learned nothing, which makes it more difficult to pick up again
15:21:20 <jle`> at this point i wouldn't set out to 'learn haskell'
15:21:24 <jle`> i'd set out to just do my normal programming
15:21:34 <jle`> but just use haskell instead of another language
15:21:41 <jle`> if you've really gotten that far in hffp
15:21:53 <Welkin> I don't think anyone ever stops learning haskell, because the language is massive and constantly changing
15:22:06 <Welkin> you just learn what you need to know to get things done, and then pick up more along the way
15:22:31 <bulters> "learning" for me would be to be able to use it "commercially"
15:22:59 <Welkin> bulters: I started using it in a professional project (where I was paid) about 1 year after I started learning it
15:23:16 <Welkin> it doesn't take much to use it professionally
15:23:58 <bulters> true...
15:24:15 <bulters> I might sneak it in a poc I'm creating right now... to heck with it...
15:25:18 <Welkin> one thing I think people get caught up with is all the extensions and all the crazy abstractions that some people obsess over
15:25:23 <Welkin> you don't need any of it though
15:25:43 <Welkin> the basics of pattern matching, simple ADTs, and good old functions are al lyou really need
15:25:53 <Welkin> you don't even need type classes
15:26:18 <infinisil> Oh god
15:26:47 <spruit11> Yes. Egel. https://egel-lang.github.io/ . Still looking for people who feel like giving it a run. Join me on #egel. And after this message, I will shut up for a few hours.
15:26:51 <infinisil> For my current class we need to finish their given compiler backend..
15:27:03 <infinisil> And Trees in Java are absolutely disgusting
15:27:09 <Welkin> infinisil: fill-in-the-blanks programming is the worst kind
15:27:30 <infinisil> I'll pay money to code it in haskell instead
15:28:11 <infinisil> It's just a huge play of "let's hope we covered every class that could be such a node in the tree" and returning null as default
15:28:44 <infinisil> Actually I might just rewrite it in Haskell to show everybody how the implementation is about 1/10th of the size
15:28:50 <infinisil> And safe
15:28:53 <bulters> infinisil: Frege and just throw a jar over the fence?
15:29:04 <Welkin> infinisil: just do it to get it done and move on to something actually useful/meaningful to you
15:29:24 <Welkin> school is dumb
15:29:37 <infinisil> Welkin: I don't have the time.. university takes up too much. And the next assignment where we implement part of the frontend is already waiting
15:29:51 <newhoggy> Hello, I'm after some help with how to write my cabal file for my particular situation.
15:30:00 <newhoggy> My cabal file is here: https://gist.github.com/newhoggy/2ad746bcd00f3fb63559fd2a23485c30
15:30:11 <Welkin> newhoggy: https://www.haskell.org/cabal/users-guide/
15:30:11 <newhoggy> It is for a library, bits-extra, which wraps two new primops in ghc-8.4.1
15:30:12 <infinisil> of course with their given compiler framework and skeleton
15:30:14 <bulters> Welkin: perhaps taking classes is dump, the social aspects of school are not to be underestimated ;-)
15:30:21 <Welkin> bulters: true
15:30:26 <infinisil> bulters: yeah
15:30:52 <bulters> I still talk to the guys from my year 12 years after getting my degree
15:31:01 <newhoggy> They rely on GHC compiler flags -msse4.2 -mbmi2 to run fast on relatively new Intel CPUs.  In all other instances it uses emulated code, which is very slow.
15:31:05 <bulters> (all 7 of them :P)
15:31:07 <newhoggy> But if I compile with -msse4.2 -mbmi2, but run on a CPU that doesn't support it, the program fails.
15:31:10 <newhoggy> What's the best way to write my cabal file to have the best user experience?
15:31:23 <infinisil> bulters: whoa, that's a lot
15:31:30 <infinisil> I'm actually impressed
15:32:03 <CodeKiwi> TIL 7 is a lot
15:32:35 <[exa]> CodeKiwi: any number above 0 is dangerous
15:33:03 <Welkin> newhoggy: did you check if you can use CPP in cabal files?
15:33:10 <Welkin> I don't think you can, but I am searching the user guide
15:33:12 <bulters> infinisil: started out with 35 in year 1, down to 22 after the first semester, 18 remaining after the first year, it was "brutal" ;-)
15:33:38 <infinisil> CodeKiwi: When 7 is a lot, then there are 3 lots in 28
15:33:50 <infinisil> bulters: what
15:33:56 <infinisil> bulters: it's the inverse for me
15:34:09 <infinisil> started with 0, then like 4, 10, and more
15:34:26 <bulters> you actually gained classmates? that doesn't usually happen here in nl
15:34:30 <newhoggy> I guess I should at minimum test for ghc version: if impl(ghc >= 8.4.1)
15:34:46 <infinisil> bulters: well i kinda changed the group of friends i hang around with like 4 times, soo..
15:35:34 <newhoggy> Still need a good way for users to be able to compile my code anywhere but be able to turn on the optimisations for particular CPUs.
15:35:37 <CodeKiwi> 7 goes into 28 4 times...
15:35:39 <infinisil> to find the "true friends", but i think i finally found them :)
15:35:49 <bulters> if you do a lecture with 8 guys it's hard to not hang around...
15:35:50 <infinisil> CodeKiwi: Lol
15:36:01 <infinisil> bulters: 8? Damn
15:36:11 <CodeKiwi> I think you might want to ask for a refund on that degree
15:36:16 <infinisil> There were like 400 here when it started (computer science)
15:36:27 <_d0t> ohai
15:36:46 <infinisil> ALright I'll shut up now, a bit offtopic
15:36:56 <_d0t> I'm curious. Is there a reason why Map.unionWith requires maps' values have the same type?
15:37:13 <bulters> I'm waiting for stack setup to finish
15:38:15 <newhoggy> Should I defined "Flag bmi2" in my cabal file?
15:38:27 <bulters> CodeKiwi: Nah, wasn't that expensive, total degree costs are a typical SV programmer monthly salary here...
15:39:10 <CodeKiwi> bulters oh I was teasing infinisil for his maths
15:39:28 <bulters> :')
15:39:39 <newhoggy> Welkin: Thanks for the link to the user-guide
15:39:46 <sl2c> _d0t: if a key is in one map but not the other it goes in unchanged
15:40:34 <bulters> CodeKiwi: 28 would actually be more like a lot :P since it was somewhere between 10 and 50 grams... once upon a time
15:40:46 <_d0t> sl2c: oh... yeah. I didn't think about this one. Thanks!
15:41:04 <sl2c> _d0t: 👍
15:41:25 <CodeKiwi> 28 grams is an ounce!
15:42:26 <newhoggy> I'm not able to find a good example of cabal file that deals with something similar to my situation.  I thought maybe there is was a standard way to do it it, like using the same names for the same kind of features.  I guess I'll do a best effort and let users raise tickets if they have particular issues.
15:42:57 <bulters> CodeKiwi: an ounce is a lot!
15:43:29 <bulters> ontopic: any stack pointers?
15:43:35 <CodeKiwi> don't use stack
15:43:56 <bulters> CodeKiwi: please elaborate.
15:44:01 <bulters> :P
15:44:09 <CodeKiwi> that's the only one I know
15:44:22 <Welkin> alternatively, there is cabal new-build https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
15:44:29 <Welkin> or you can use nix + cabal
15:45:17 <parsnip> on nixos?
15:45:43 <Welkin> you don't need nixos
15:45:54 <parsnip> but, you use nixos?
15:45:57 <Welkin> you can run nix package manager on any linux or macos
15:46:19 <bulters> hmm, more stuff to explore :P
15:46:33 <parsnip> i don't see a big problem with stack
15:46:33 <Welkin> bulters: in the past we used something called cabal sandboxes
15:46:37 <Welkin> some people still use these today
15:46:45 <Welkin> I would prefer nix-style builds though
15:46:58 <Welkin> I still use stack for some projects too
15:47:39 <parsnip> i can't wait for new-build to be well-established and the default, and for nix to accrue more ease of use and tutorials.
15:47:54 <parsnip> till then, i'm using stack cuz momentum
15:50:57 <bulters> Welkin: realistically, what would be the effort (time-wise) to get started with nix/cabal instead of stack
15:51:10 <bulters> (Just completed my stack setup :P)
15:52:01 <Welkin> bulters: well, you need to understand cabal (stack just hides it from you)
15:52:17 <Welkin> cabal is the build system. Stack uses cabal underneath, and you still need a .cabal file anyway
15:52:49 <Welkin> you can use cabal by itself without nix (or stack)
16:03:33 <bulters> Welkin: that I knew, thought that stack was somewhat considered a defacto standard build mgmt tool
16:04:48 <Welkin> bulters: it is not standard by any means
16:04:58 <Welkin> it came up just recently a few years ago
16:05:08 <Welkin> came out*
17:05:28 <lyxia> Is there a function coerceb :: ((a == b) ~ 'True) => a -> b
17:05:39 <tathougies> lyxia: id?
17:05:46 <lyxia> With (==) from Data.Type.Equality
17:06:11 <lyxia> tathougies: nope, GHC can't deduce a ~ b from (a == b) ~ 'True
17:06:39 <jle`> lyxia: the problem is that (==) is not structural
17:06:45 <jle`> you can define it however you want
17:06:49 <lyxia> oh right...
17:06:55 <jle`> so just because (a == b) ~ 'True, doesn't mean that (a ~ b)
17:06:58 * lyxia imports Unsafe.Coerce
17:07:00 <mtjmullen> unsafeCoerce? :P
17:07:22 <Welkin> jle`: you are in san diego, right?
17:07:24 <lyxia> jle`: Thanks!
17:07:41 <jle`> lyxia: one can define a silly instance where a == b is always True for all inputs
17:07:55 <jle`> Welkin: i was, but i'm in Orange County now!
17:08:12 <Welkin> who was it that is at Indiana University?
17:08:26 <Welkin> it was someone in here who went there for a PhD
17:08:39 <tathougies> lyxia: how are you getting (a == b) to begin with?
17:08:42 <jle`> any luck at https://www.haskellers.com/ ?
17:08:51 <Welkin> I wonder if they know Daniel Friedman and the other scheme people there
17:08:54 <lyxia> But (==) is already defined for types, so maybe it's safe if base defined that coerceb?
17:09:03 <jle`> it's an open type family
17:09:10 <jle`> so you could make your own instance for your own kinds
17:09:16 <jle`> that would break it
17:09:35 <lyxia> jle`: coerceb :: ((a == b) ~ 'True) => a -> b  <- Aren't a and b of kind * necessarily
17:09:58 <jle`> oh yeah, you're right
17:10:20 <tathougies> jle` you can't extend it anyway, without making overlapping instances, since it's defined for 'forall a b. (==) * a b'
17:10:31 <jle`> yeah, i didn't notice that it was only *
17:10:36 <jle`> hm, in that case, it should exist
17:10:39 <lyxia> tathougies: I'm doing Generic programming and I'm comparing types with (==)
17:10:44 <jle`> although it's weird that you would have it in the first place
17:10:49 <tathougies> Why?
17:11:06 <tathougies> Isn't it better to just use Maybe (a :~: b) instead of (==)?
17:11:43 <jle`> yeah, with testEquality
17:11:54 <jle`> (==) is the wrong tool for type level stuff like this
17:12:44 <lyxia> testEquality doesn't live at the type level
17:13:17 <jle`> at the type level, it corresponds to (~)
17:13:34 <tathougies> lyxia: Just do a simple type family 'type family MyEq (a :: *) (b :: *) :: Maybe (a ~ b) where { MyEq a a = Just (a ~ a); MyEq a b = Nothing }'?
17:13:42 <jle`> so coerceb :: (a ~ b) => a -> b
17:14:09 <jle`> testEquality is the singleton function for (~)
17:15:56 <jle`> lyxia: instead of ((a == b) ~ 'True), you can just use (a ~ b)
17:17:01 <lyxia> jle`: I'm using the boolean in a type family
17:17:26 <jle`> what type family?
17:17:28 <lyxia> I'm implementing a generic version of recursive-schemes
17:17:37 <lyxia> and I need to match on recursive occurences of my type
17:18:02 <lyxia> To define the base functor
17:19:34 <lyxia> I know it's not going to be quite as general as what we can get with TH, I'm just doing it for fun.
17:25:48 <lyxia> Thanks for the help!
17:52:35 <MacSlow> Greetings everybody!
18:12:15 <jle`> lyxia: had to step out for a bit, but there is probably a way to rephrase your type families in terms of ~ rather than a Boolean :)
18:18:56 <EvanR> the need for "fresh" (globally unique??) free variables in this algorithm are driving me insane
18:19:09 <EvanR> what does that even mean in a purely functional setting
18:25:52 <geekosaur> depends on the algo. it can mean locally unique
18:25:55 <Patternmaster> 4
18:28:58 <jle`> in situations like hindley milner, they just draw from a pool
18:29:29 <EvanR> what is fresh about whatever comes out of that pool
18:30:17 <EvanR> doesnt already occur (whre)
18:30:42 <EvanR> has not already occurred, even if occurrences disappaered
18:31:29 <EvanR> is it supposed to be in an entirely different variable universe
18:33:00 <blonkhart> we're talking like when the compiler has a unification error and we see "couldn't match type a0..."?
18:33:02 <jle`> the fundamental thing is that all ctions are sequential
18:33:06 <jle`> *sequential
18:35:51 <spruit11> You can either use a global pool or if you have scoping 'draw' the next variable not in scope.
18:36:08 <jle`> if you impose a sequential order to things than things sort of make sense
18:36:24 <spruit11> The latter is slow but possibly less annoying in a pure language.
18:36:27 <jle`> imperative algorithms are neat
18:36:56 * EvanR heard about supposed imperative algorithms beyond the dark haskell cave walls
18:37:08 * EvanR is still skeptical
18:39:12 <EvanR> so its fresh if its not already in scope
18:39:33 <EvanR> is that plausible
18:39:55 <spruit11> I made something mixed. Still looking for people who are experts in blowing up functional languages. So join me on #egel if you're that expert.
18:40:12 <jle`> when i learned haskell, we implemented hindley-milner imperatively
18:40:16 <spruit11> EvanR: Yah, it needs to be unique within a scope, right.
18:40:19 <jle`> now that i think of it, that was as really meta assignment
18:40:21 <blonkhart> isn't this analogous to random number generation? except for optionally reseeding in a local scope?
18:42:03 <EvanR> in the sense that "choose a random number" and "choose a fresh name" are both simple sounding but not necessarily operationally clear? :)
18:43:02 <spruit11> It's all just SKI anyway.
18:46:23 <blonkhart> yeah and in either case, requiring a representation of state, and so some sequencing
18:50:37 <EvanR> this is my rule, replacing fresh with "not in stuff" http://lpaste.net/363538
18:50:44 <EvanR> maybe its not wrong
18:51:35 <geekosaur> in ghc, what would matter is "not in the environment"
18:51:40 <geekosaur> (tc environment)
18:52:15 <geekosaur> (but ghc has a way to generate fresh names, iirc)
19:14:51 <EvanR> is "functor fusion" a thing ghc does
19:15:08 <EvanR> fmap f . fmap g . fmap h = fmap (f . g . h)
19:22:11 <blonkhart> more generally does ghc assume any (all) "standard" type classes are lawful? i have seen law-abiding transformations proposed in lints in an editor, but assumed that was the end of it
19:24:17 <lyxia> jle`: http://lpaste.net/363539 if you care to take a look
19:26:28 <blonkhart> EvanR, i need fresh names in a project i'm working on where i just restrict the set of allowable names, and then generate new names composed of a prefix (that would be disallowed) and a serial number suffix (to ensure uniqueness).  maybe this is what you meant by a different universe?
19:26:43 <EvanR> yeah
19:27:17 <EvanR> equivalent to ... NormalVar String | FreshVar Int
19:27:43 <blonkhart> right
19:28:38 <EvanR> and in the rule i posted... x' is a metavariable that refers to a free variable about which the containment condition refers to directly, not to whatever the free variable itself refers to...
19:28:42 * EvanR goes insane
19:29:47 <EvanR> PHP $$ variables ahead of their time
19:29:50 <blonkhart> like macro hygiene
19:33:32 <jle`> lyxia: it looks like the main place you use (==) is on line 89
19:33:52 <jle`> lyxia: in that case you can just give two different type family instances i think
19:34:09 <jle`> hm actually i'm not sure
20:16:16 <jchia> Is there a safe alternative to Text.Printf that won't crash because of invalid format specification?
20:18:01 <EvanR> :(
20:18:12 <EvanR> are you computing format strings?
20:18:31 <EvanR> i remember that being a way to get root access in C
20:19:33 <geekosaur> jchia, I'd do it under a "try" if needed. Except that I usually void printf in haskell
20:19:34 <jchia> EvanR: No, but it'll be better if the compiler can check my format specification at compile-time
20:19:36 <geekosaur> there are better ways
20:19:45 <geekosaur> this is not C
20:19:52 <jchia> the format specification is fixed at compile-time
20:19:55 <geekosaur> nobody is building printf support into the compiler
20:23:17 <pavonia> jchia: what about https://hackage.haskell.org/package/th-printf ?
20:25:13 <Cale> jchia: you could use my category-printf :D
20:25:36 <Cale> http://hackage.haskell.org/package/category-printf
20:25:49 <Cale> It's super cute, and type safe
20:25:59 <Cale> but tbh, it's kind of silly
20:30:45 <pavonia> I've got a lot of functions with types ``(Monad m, Var v1 m A1, ..., Var vn m An) => v1 A1 -> ... -> vn An -> Res m B''. Is there a way to have a wrapper around that (without TH) so that I don't have to type all the constraints all the time and just specify the A's and B?
20:31:41 <Cale> Maybe you can build them out of smaller pieces like how <*> works?
20:31:48 <Cale> vs. liftA2
20:33:43 <pavonia> Cale: I've got something like this but it's still a lot of typing when combining them
20:34:23 <pavonia> Maybe I should paste some code ...
20:36:24 <geekosaur> pavonia, if you can parameterize it then you can turn on ConstraintKinds and then make a 'type' out of the constraint
20:36:42 <geekosaur> this is assuming the '...' is not variable in usage
20:37:03 <geekosaur> (or you break it into pieces so you can parameterize each piece)
20:39:08 <pavonia> This is the general idea: http://lpaste.net/8712963230114250752 The problem comes in when the different parameters can have varying constraints. Ideally I'd have a general ``function'' where I just have to specify what constraint the parameter has and the rest is built automagically
20:39:39 <geekosaur> that will require TH
20:40:10 <geekosaur> the closest you get to arbitrary type functions in ghc is type families, and they're not very close
20:40:49 <pavonia> Can't it be done with something similar to what printf does, building up the final function just from the type of the result?
20:41:06 <geekosaur> you are working with a constraint, which means at type level
20:41:25 <geekosaur> you are hoping that someone will wave a magic wand and make ghc capable of arbitrary type functions.
20:42:05 <geekosaur> printf operates at *value* level
20:42:55 <EvanR> arbitrary type functions you say
20:43:23 * EvanR takes out ghc's partially applied type synonym governor
20:43:40 <pavonia> geekosaur: Well, I don't know where the limits of type-level programming are in Haskell :p
20:44:12 <geekosaur> linited enough that type level programming is a major PITA
20:44:18 <geekosaur> *limited
21:02:53 <dmj`> beam or hasql?
21:08:49 <nshepperd> ah, category-printf! i was looking for that way back when but forgot what it was called
21:10:10 <nshepperd> i was writing a variadic function using a typeclass and getting horribly confused. hopefully this will help
21:15:20 <Cale> nshepperd: It takes a really different approach
21:15:51 <Cale> nshepperd: The idea is that the type of the format specifiers tells you how they change the type of printf
21:19:14 <nshepperd> yeah
21:20:18 <nshepperd> i'm hoping i can do something similar to keep straight the changing types as my function is applied to different arguments
21:21:51 <nshepperd> the function I was writing is something that will take an arbitrary function in an eDSL and compile and convert it into a function in haskell
21:22:03 <nshepperd> taking care of marshalling and so forth
21:39:16 <lyxia> jle`: What we can do here with two instances is precisely encapsulated by (==) and If. I'm trying to avoid the proliferation of nonlinear type family instances.
21:55:52 <EvanR> well... i appear to have written a theorem prover... all hope is probably lost
22:01:37 <`Guest00000> i feel like thinking about type theory, higher-level things, dependent types  may have improved my general thinking about everything
22:04:25 <EvanR> R.I.P. Stephen Hawking
22:06:55 <guessWHo> hey guys can you please help me with this "Deprecated: "Do not use the PortNum constructor. Use the Num instance. PortNum will be removed in the next release.""
22:07:07 <woodson> why do every time people talk about haskell one of their top arguments is "Haskell is slower than C/C++" ?
22:07:24 <woodson> or haskell is slow
22:11:50 <Adeon> (<<) is not a thing?
22:12:01 <Adeon> for the first time I tried writing code in form: a << b
22:12:08 <Adeon> but apparently << is not in Control.Monad, can only do it right >>
22:17:21 <boj> :t (<*)
22:17:23 <lambdabot> Applicative f => f a -> f b -> f a
22:18:51 <Adeon> I think that's slightly different
22:18:59 <Adeon> the actions are still sequenced from left to right, but the value from left is used
22:19:10 <Adeon> whereas (<<) I'd think sequences from right to left and keeps left value
22:19:20 <boj> applicative is now a super class of monad, that does what you want
22:19:53 <boj> compose from right to left and ignore the result of the prior action
22:21:15 <Adeon> yeah, applicative is enough
22:22:50 <Adeon> but (<*) is not the correct function for my use even though it has exact same type signature
22:22:58 <Adeon> i.e. print 1 <* print 2 outputs "1" and "2"
22:23:25 <Adeon> a little surprised I can't find a ready-made function for this, I defined it trivially in my code as <<
22:23:39 <Adeon> i.e. print 1 << print 2 that outputs "2" and then "1"
22:24:31 <boj> right, printing is a side effect
22:25:16 <amalloy> Adeon: i'm having trouble imagining a scenario in which this is more readable than print 2 >> print 1
22:25:28 <Adeon> the pattern I was writing looked like this
22:25:31 <Adeon> doThing << do
22:25:33 <Adeon>   moreThings
22:25:48 <Adeon> it makes more sense in the context...
22:25:51 <amalloy> but you want to do doThing last
22:25:54 <Adeon> yup
22:28:04 <Adeon> well actually it's a recursive function where doThing calls itself with some arguments
22:28:16 <Adeon> no matter what I write in moreThings I don't have to bother writing the tail thing at the end properly with all the arguments
22:28:40 <Adeon> noticed that this is one type of pattern that can slightly make the code clearer in this particular case
22:30:22 <boj> > "a" <* "b"
22:30:27 <lambdabot>  "a"
22:30:45 <amalloy> doThing x y = doThing a b << do more. i don't really agree that this is more readable than do {more; doThing a b} but i guess it's not crazy
22:31:06 * boj shrugs
22:31:11 <amalloy> boj: we're looking for one that applies the effects of b before a
22:31:25 <boj> oh, i missed that. sorry
22:32:07 <amalloy> fwiw the fact that boj missed that while reading the code samples is an argument that your << is not making things more readable: people expect the first item to still be sequenced first
22:32:41 <Adeon> I'm not sure about that; it looks like =<< which sequences second thing first
22:32:50 <Adeon> but I think that's fair
22:32:55 <amalloy> =<< has to
22:32:59 <amalloy> it only has one m
22:33:32 <amalloy> you can't look at =<< and wonder which order things happen in, because only one order is possible
22:34:05 <guessWho_> when i try to add build dependencies to my cabal i get the following error "Unable to parse cabal file NoParse "build-depends" 23"
22:34:12 <`Guest00000> ahh, flip (>>) vs (<*) ...
22:34:21 <boj> well, i learned something new today
22:34:40 <EvanR> <* seems weird now
22:34:46 <jchia> pavonia: th-printf works for me. I'm going to see if I can add it to a stack resolver some time.
22:34:58 <amalloy> what's that, boj?
22:35:06 <`Guest00000> (i see it as) the consensus is that neither of (flip (>>)), (<*) is 'more canonical' than other to be defined << as and not the other
22:35:07 <sl2c> :t >>
22:35:09 <lambdabot> error: parse error on input ‘>>’
22:35:16 <sl2c> :t (>>)
22:35:17 <lambdabot> Monad m => m a -> m b -> m b
22:35:22 <`Guest00000> but just write "where (<<) = flip (>>)" in your code
22:35:26 <sl2c> :t (*>)
22:35:28 <lambdabot> Applicative f => f a -> f b -> f b
22:35:30 <boj> amalloy: it never occured to me that the left side of <* got applied first
22:35:43 <Adeon> yeah for me I would definitely expect << does effects from right to left but looks like it's not obvious to everyone
22:35:47 <sl2c> or do (<**) in analogy with (<**>)
22:35:48 <Adeon> gonna not use that pattern in my code
22:35:51 <Adeon> even though I thought it was interesteing
22:36:12 <sl2c> unless i'm getting what <**> doe sbackwards
22:36:36 <Adeon> yeah (<*) does effects of left thing first
22:36:39 <Adeon> I guess that's also sort of weird
22:36:46 <amalloy> oh yeah, i forgot <**> exists
22:36:58 <amalloy> :t (<**>)
22:36:59 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
22:37:23 <`Guest00000> because of that consensus, defining (<<) locally could be more understandable / "digestible"
22:37:35 <`Guest00000> Adeon: but very useful
22:38:07 <`Guest00000> effect1 *> effect2 *> thatEffectWhoseResultWeNeed <* effect3 <* effect4 <* effect5 <* effect6
22:38:14 <sl2c> okay no <**> is the opposite of what you want
22:38:30 <sl2c> it's also ltr
22:38:32 <`Guest00000> when writing parsers for example
23:02:32 <`Guest00000> do you know of languages with type systems with extremely loose rules, but at the same time with features from TSs regarded as "powerful", e.g. deptypes?
23:13:35 <guessWho_> is it possible to export a data constructor form another library ??
23:13:41 <guessWho_> from*
23:16:56 <guessWho> is it possible to export a data constructor from another library ??
23:17:24 <dysfun> you mean to reexport it?
23:18:18 <jle`> yeah
23:18:20 <jle`> if you import it
23:18:26 <jle`> you can just add it in the export list
23:18:33 <jle`> module MyModule where (
23:18:41 <jle`>   TheOtherLibrarysConstructor
23:18:43 <jle`>   )
23:18:51 <jle`> oh did i mix up where the 'where' is supposed to be
23:20:32 <mcspud> Axman6 - you posted a talk up for me to watch yesterday but I lost it, could you be so kind and repost it please?
23:29:18 <Hijiri> will ghc precompute constant subsexpressions like (2/3)
23:29:20 <Hijiri> as in f x = (2/3) * x or something like that
23:29:22 <Hijiri> inb4 the answer is "look at the core"
23:40:24 <krakrjak> I've been dusting off some code and I'm running into a particular error and I'm not sure how to proceed. any ideas?
23:40:47 <krakrjak> Could not find module ‘Text.XML.HXT.Core’
23:42:09 <krakrjak> This seems to be an issue in the gl package... would an upgrade help?
23:42:20 <krakrjak> The error does not seem to be in user code.
23:54:43 <halogenandtoast> Anyone experiencing something like this with stack (and lts-11.0) https://gist.github.com/halogenandtoast/a33dc866967378d63603046ab2ea5da3
23:55:25 <halogenandtoast> ftr, the package.yaml (aka cabal-lite) doesn't have persistent-sqlite in it, but it might be a depedency
23:55:59 <cocreature> halogenandtoast: looks like the default constraints in the yesod-postgres project are too strict for lts 11
23:58:45 <krakrjak> looks like I might have licked my issue by sticking to LTS-11 and adding some extra-deps to the stack.yaml
23:58:52 <krakrjak> haskell dev has gotten so easy.
23:59:15 <krakrjak> even bitrot is no issue.
23:59:48 <halogenandtoast> cocreature: thanks, now to figure out how to specify a different lts
