00:10:32 <dminuoso> mcspud: You should kick the addiction and dump it all on someone else.
00:10:39 <dminuoso> Someone like me.
00:28:44 <dragdrog> hey
00:54:37 <dminuoso> Im seeing code in the style of `fix \loop -> ... when again loop` - what's the point of using fix here?
00:55:24 <dminuoso> Or is that just done to avoid a let/where binding for the loop?
01:15:23 <jle`> dminuoso: basically to avoid naming the function, yes
01:15:34 <jle`> fix is a way to create a recursive function anonymously
01:16:15 <jle`> note, not necessarily let/where
01:16:49 <jle`> instead of defining factorial = ..., then map factorial [1..10]
01:17:10 <jle`> i can write map (fix (\fac n -> if n == 0 then 1 else n * fac (n - 1))) [1..10]
01:17:27 <jle`> > map (fix (\fac n -> if n == 0 then 1 else n * fac (n - 1))) [1..10]
01:17:30 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800]
01:22:31 <dminuoso> jle`: Yeah Im familiar with fix - just didn't quite clearly see that it's the anonymity that was the point of it.
01:22:36 <dminuoso> Thank you. :)
01:23:04 <dminuoso> Also https://en.wikibooks.org/wiki/Haskell/Denotational_semantics is a really interesting read =)
01:24:07 <iron_houzi> How's the ['a' .. 'z'] range defined? I'm trying to do the same for my own alphabet (https://gist.github.com/ironhouzi/1e458ccaa7af1beed31caa3cb79f2cd7), which is possible to do with [Ka .. O], but it would be more natural to be able to do ["k" .. "o"]. The letters needs to be strings though, so I'm not sure that can prevent
01:25:01 <cocreature> > enumFromTo 'a' 'z' -- iron_houzi
01:25:02 <dminuoso> iron_houzi: That's syntax sugar for enumFromTo 'a' 'z'
01:25:04 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
01:25:30 <jle`> dminuoso: no problem!
01:26:02 <jle`> i don't think it's a common style, but it has its adherents
01:26:22 <jle`> in some cases it might be more performant
01:26:32 <dminuoso> jle`: It was instantly readable, just surprised I havent seen it before.
01:26:49 <dminuoso> jle`: https://github.com/supki/ldap-client/blob/master/example/login.hs#L56-L82 is where I got that from.
01:26:58 <jle`> sometimes it can help ghc's optimizer
01:27:25 <dminuoso> Interesting, how is that?
01:27:47 <iron_houzi> OK.. how does one specifiy `enumFromTo` for different types?
01:27:48 <mcspud> dminuoso ;D
01:28:03 <jle`> it's not something you can really always rely on, but ghc can optimize non-recursive functions through inlining and stuff in ways that it can't do for recursive functions
01:28:03 <dminuoso> iron_houzi: You make that type an instance of Enum
01:28:08 <jle`> iron_houzi: how familiar are you with typeclasses?
01:28:16 <iron_houzi> jle`: Just starting out
01:28:30 <jle`> ah.  are you familiar with the Eq typeclass?
01:28:41 <jle`> it lets you provide your own definition for (==) for your custom types
01:28:58 <jle`> enumFromTo is the same thing, but it's attached to the Enum typeclass
01:29:12 <jle`> instance Eq MyType where
01:29:19 <jle`>   x == y = ... (custom definition of (==))
01:29:23 <jle`> and for Enum you have:
01:29:27 <jle`> instance Enum MyType where
01:29:40 <jle`>   enumFromTo x y = ... (custom definition of enumFromTo for MyType)
01:29:55 <iron_houzi> ahh. Thanks jle` !
01:30:34 <dminuoso> Isn't the minimal definition toEnum, fromEnum?
01:30:44 <jle`> yeah, there are some other things you have to define heh
01:31:45 <dminuoso> iron_houzi: Basically you would look up the typeclass in hoogle/hackage or GHCi using :i - there you can see the "minimal" definition. If you supply these methods, GHC can figure out the rest.
01:32:10 <dminuoso> iron_houzi: Alternatively you could also supply the other methods if you have some tricks that are faster than the generic default implementations.
01:33:02 <dminuoso> For example for Eq you only need to supply (==) _or_ (/=), denoted by the pragma {-# MINIMAL (==) | (/=) #-} that you can see if you check `:i Eq`
01:33:51 <dminuoso> Supply either one, get the other for free. =)
01:34:09 <iron_houzi> OK. Should I remove Enum from derived, if I make an explicit instance of it?
01:35:09 <dminuoso> iron_houzi: If you already have deriving Enum, then GHC generates the instance for you. That's the meaning of `deriving`
01:35:28 <kuribas> How do I match on Text?  Is there a more efficient way than (case T.unpack txt of "myString" -> ...)?
01:37:01 <dminuoso> iron_houzi: Replacing the compiler generated instance with a hand written one is useful as an excercise, as well as when you have some trick to write a faster implementation.
01:37:26 <jle`> kuribas: | txt == "myString" = ...
01:37:59 <kuribas> jle`: with overloadedstrings?
01:37:59 <dminuoso> iron_houzi: I recommend writing out all deriviong instances by hand, until you can do them in your sleep - at which point switch to `deriving` to avoid the boilerplate.
01:38:09 <jle`> yes
01:38:15 <kuribas> jle`: I can't, because I am using TH...
01:38:33 <jle`> TH disables overloaded strings?
01:38:52 <iron_houzi> dminuoso: I understand the sentiment. Not sure I can commit to that just yet though.
01:39:13 <dminuoso> iron_houzi: It will likely take only 2-3 instances before you understand it.
01:39:14 <kuribas> jle`: no, but it doesn't enable it either...
01:39:20 <dminuoso> iron_houzi: (For each typeclass)
01:39:27 <jle`> can you enable it with {-# LANGUAGE OverloadedStrings #-} ?
01:39:44 <jle`> do you mean that you are using TH in the same file/module where you want to match on a Text ?
01:39:48 <jle`> if so, it shouldn't interfere
01:39:59 <dminuoso> iron_houzi: Maybe even a single one in case of Enum and Eq. =)
01:40:15 <jle`> or do you mean you're trying to generate splice/code that tests a Text
01:40:22 <kuribas> jle`: yeah, the last
01:40:58 <jle`> you can just do txt == T.pack "myString" then right?
01:41:04 <jle`> if code being pretty is not a priority
01:41:28 <kuribas> Does the T.pack get optimized into a constant?
01:41:29 <jle`> not sure which direction is more efficient
01:41:33 <jle`> kuribas: no
01:41:49 <jle`> TH generates haskell code
01:42:16 <kuribas> so it will run T.pack for every pattern match?
01:42:45 <jle`> do you mean every time you call the function that has the pattern match?
01:42:51 <jle`> or every pattern
01:42:51 <kuribas> yes
01:42:59 <jle`> no, it's memoized using thunks
01:43:22 <jle`> it's basically the same as if you literally typed T.pack "myString"
01:43:39 <kuribas> yes, and that isn't a constant...
01:43:59 * hackage miso 0.18.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-0.18.0.0 (DavidJohnson)
01:44:14 <jle`> it's basically the same as if you you typed "myString" and had OverloadedStrings on
01:44:15 <kuribas> jle`: unless ghc makes it into a constant, or thunk...
01:44:22 <jle`> GHC does make it into a thunk
01:44:32 <iron_houzi> Is it easy to inverse a function in Haskell?
01:44:47 <kuribas> jle`: ok, so it should be efficient then...
01:44:57 <jle`> yeah, it's pretty much the same as using OverloadedStrings
01:45:06 <jle`> by pretty much i mean exactly, since they compile to the same thing
01:45:14 <kuribas> iron_houzi: fmap (1/)
01:45:36 <kuribas> jle`: I see...
01:46:23 <dminuoso> iron_houzi: What does "inverse" mean
01:47:40 <kuribas> > \f -> fmap recip (f :: Double -> Double)
01:47:43 <lambdabot>  <(Double -> Double) -> Double -> Double>
01:48:27 <iron_houzi> dminuoso: if function F is the inverse of function G, G(F(x)) == x
01:49:01 <iron_houzi> sorry
01:49:06 <iron_houzi> I mixed it up
01:49:09 <dminuoso> iron_houzi: Are you talking about an isomorphism?
01:49:16 <dminuoso> iron_houzi: But no, generally there is no way to do this.
01:49:23 <iron_houzi> in that example G is the inverse of F
01:49:38 <iron_houzi> OK
01:50:40 <iron_houzi> .. I guess, F and G can be interchangable if they're the inverse of eachother though :)
01:50:53 <kuribas> jle`: what if there is no Eq instance for the overloadedString type?
01:51:07 <dminuoso> iron_houzi: Consider the propertiers a bit differently.
01:54:49 <kuribas> jle`: does ghc give an error message then?
01:55:17 <dminuoso> iron_houzi: `f :: X -> Y` has an inverse if and only if it is bijective. The only generic way to derive it's inverse, is if X is bounded and enumerable.
01:56:46 <iron_houzi> dminuoso: I understand.
01:59:06 <jle`> kuribas: yes, it's pretty much the same as trying to compile the code you generate, as if you had written it by hand
01:59:36 <kuribas> hmm, if I include a language pragma in the TH, does it also get turned on for the surrounding (non TH) code?
02:00:00 <jle`> language pragmas only work if they are at the top of a module file
02:00:18 <iron_houzi> So, is it impossible to derive a typeclass but also specify just one instance of that derived typeclass?
02:00:20 <jle`> if you include a language pragma in your resulting TH splice, it'd just be like typing it in by hand in the middle of your file
02:00:50 <jle`> iron_houzi: what is an instance of a derived typeclass?
02:00:57 <jle`> and what do you mean by derive a typeclass?
02:01:00 * hackage postgresql-query 3.4.0 - Sql interpolating quasiquote plus some kind of primitive ORMusing it  https://hackage.haskell.org/package/postgresql-query-3.4.0 (AlekseyUymanov)
02:01:29 <dminuoso> iron_houzi: You don't derive a typeclass. `deriving Foo` means "Compiler, please generate an instance Foo for my type for me. I dont want to write it"
02:01:35 <dminuoso> Either you write it, or have GHC generate it for you.
02:01:41 <dminuoso> Can't have it both ways.
02:01:43 <jle`> iron_houzi: do you mean, derive an *instance* of a typeclass?
02:01:52 <kuribas> jle`: nvm, the LANGUAGE pragma isn't even available...
02:02:07 <jle`> kuribas: syntactically, language pragmas are just normal comments
02:02:14 <iron_houzi> So if I do `data Foo = ... deriving (Enum)` and then later on do `instance enumFromTo x y = ..` .. that's what I'm trying to ask about
02:02:25 <dminuoso> iron_houzi: enumFromTo is not a typeclass.
02:02:32 <jle`> iron_houzi: ah okay, there is some vocab mismatch here
02:02:36 <jle`> enumFromTo is a *method*
02:02:42 <iron_houzi> Oh!
02:02:44 <jle`> Enum Foo is the *instance*
02:02:48 <jle`> Enum is the *typeclass*
02:02:48 <kuribas> jle`: https://hackage.haskell.org/package/template-haskell-2.12.0.0/docs/Language-Haskell-TH.html#t:Pragma
02:03:03 * dminuoso considers `Enum Foo` to be a constraint...
02:03:14 <iron_houzi> Yeah, I must admit I am struggling with learning/remembering all the new terms
02:03:20 <jle`> kuribas: oh hey, i stand corrected :)
02:03:30 <jle`> dminuoso: it depends on the context in which it is written
02:03:36 <iron_houzi> jle`: Thanks.
02:03:55 <dminuoso> jle`: Well stating that `Enum Foo` to be an instance could be confusing when they talk about contexts.. :P
02:03:59 <jle`> 'Enum Foo' is how it's typed out in error messages
02:04:05 <dminuoso> Mmm.
02:04:06 <jle`> but yeah it's not literal haskell source
02:04:42 <jle`> but yeah, 'Enum Foo' is probably not the clearest way to specify the instance :)
02:05:02 <jle`> an instance of a typeclass is the type and all of the method definitions you define for that type
02:05:09 <jle`> hm
02:06:29 <iron_houzi> So is the correct phrasing of my question then: "Is it possible to both derive a typeclass for a type instance and overwrite a single method in the derived typeclass" ..... ????
02:06:37 <dminuoso> iron_houzi: No you dont derive typeclasses.
02:06:43 <dminuoso> iron_houzi: You derive *instances* for typeclasses.
02:06:43 <iron_houzi> FML
02:06:53 <dminuoso> iron_houzi: maybe an example might help
02:07:11 <dminuoso> @let data Coin = Head | Show deriving Eq
02:07:11 <jle`> iron_houzi: i think the answer to the question you are trying to ask is, no, not using the default deriving mechanisms in vanilla haskell
02:07:13 <lambdabot>  Defined.
02:07:20 <dminuoso> > Head == Show
02:07:23 <lambdabot>  False
02:07:26 <dminuoso> Uhh
02:07:28 <dminuoso> @undef
02:07:29 <lambdabot> Undefined.
02:07:32 <dminuoso> @let data Coin = Head | Tails deriving Eq
02:07:34 <lambdabot>  Defined.
02:07:37 <dminuoso> > Head == Tails
02:07:39 <lambdabot>  False
02:07:53 <jle`> there are some ways you can define "deriving" mechanisms for your typeclasses that can auto-generate instances, but also allow some customization and overloading of method definitions
02:07:58 <dminuoso> iron_houzi: ^- There `deriving` has generate an *instance* for the *typeclass* Eq.
02:08:11 <jle`> but those are all things in user-space
02:08:22 <jle`> as in, mechanisms that people write in haskell
02:08:34 <jle`> the actual built-in 'deriving' system provided by GHC is pretty rudimentary
02:08:36 <dminuoso> iron_houzi: This is equivalent to writing: instance Eq Coin where (==) Head Head = True; (==) Tails Tails = True; (==) _ _ = False
02:08:56 <dminuoso> iron_houzi: Both ways generate an _instance_ Eq for your type.
02:11:17 <dminuoso> iron_houzi: Typeclasses can be considered interfaces/templates. Instances provide an implementation of such an interface/template for a given type.
02:11:26 <iron_houzi> dminuoso: Thanks, I'll try to let this sink in.
02:11:38 <jle`> 'deriving' is a feature built into ghc/haskell for deriving instances of typeclasses for data types that's pretty inflexible, but for modern haskell, we've implemented other "first-class" ways of deriving instances that are pretty flexible.  it's just different than GHC's built-in deriving
02:11:59 <jle`> GHC's built-in deriving isn't flexible enough to derive 'all but one' method
02:12:19 <iron_houzi> jle`: Thanks for bridging the gap between my flawed understanding while trying to pose a question. It can be really frustrating to not even know how to phrase questions correctly. Thank you
02:12:33 <jle`> no problem :)  i feel your pain, it's something that i run into a lot too
02:12:47 <dminuoso> What's the reasoning behind naming typeclasses "classes" anyway?
02:13:04 <dminuoso> Is that a hint at classes in mathematics? Can I see a class as a "set of types"?
02:13:43 <dminuoso> (i.e. if a type if a set of values, then a bag with sets inside it would be a class)
02:17:01 <TMA> dminuoso: I guess so. there is limited number of words for general collections: list, set, class, kind; there are some specialized: herd, flock, school, ... but these are too loaded to be the first naming choice
02:19:42 <iron_houzi> OK, seems like custom Enum methods is a bit more involved than I was hoping for. I'm going to leave this for another day, when my fundamentals are a bit more solid.
02:20:48 <kuribas> following OO terminology type instances are type objects?
02:21:14 <TMA> dminuoso: I think that "typeclass" is unique enough no to cause confusion. But it feels too long, so it is abridged to just "class", like "robot" is shortened to "bot".
02:21:47 <dminuoso> TMA: Mmm right. I just pondered about the English meaning of the word typeclass and realized it actually means "class of types"
02:22:59 <TMA> I don't know why 'Glish 'kers hate long words so much.
02:23:16 <dminuoso> kuribas: Following TMA's line of reasoning, the "bag" to consider is called a family, so `type instance` just declares objects inside that bag of types. I wonder whether that holds true actually.
02:24:17 <kuribas> dminuoso: in standard haskell, but with extension it can be a subset.
02:25:04 <dminuoso> kuribas: a subset of what?
02:25:14 <kuribas> dminuoso: erm, I mean just set
02:25:17 <kuribas> dminuoso: of types
02:25:45 <kuribas> dminuoso: like (Map a), which is also a set of types.
02:28:30 * hackage uniprot-kb 0.1.1.0 - UniProt-KB format parser  https://hackage.haskell.org/package/uniprot-kb-0.1.1.0 (zmactep)
02:29:01 <kuribas> dminuoso: or does a type variable count as a type, not a set of types?
02:29:05 <Maxdamantus> or maybe more accurately, `forall a. Map a`, or `(a: *) -> Map a`, which look like functions
02:29:21 <kuribas> right
02:29:27 <dminuoso> kuribas: Ive been pondering about exactly that.. :)
02:29:43 <Maxdamantus> I think they're sometimes called "polytypes"
02:30:03 <Maxdamantus> type terms with free variables
02:30:32 <dminuoso> Could then a typeclass constraint be considered just a lookup in that "bag of types", as in (Eq `Elem` a) - for some choice of a?
02:37:15 <kuribas> dminuoso: you mean a `elem` Eq?
02:38:21 <dminuoso> kuribas: Oh heh. Yeah.
02:38:48 <kuribas> I think so
02:40:00 <Maxdamantus> imo the way to think about the constraints is as implicit arguments.
02:41:18 <Maxdamantus> so if you see something like `Num a => Integer -> a`, just think of it as `Num a -> Integer -> a`, but where the first argument is inferred by the instances you have in scope.
02:41:50 <dminuoso> Maxdamantus: Do you mean as in dict passing?
02:42:00 <dminuoso> or "instance passing" perhaps in a more abstract sense
02:42:02 <Maxdamantus> (the value of that argument would be something created by an instance)
02:42:11 <Maxdamantus> dminuoso: sure.
02:42:41 <dminuoso> Maxdamantus: That turned out to be the only way to make sense of edwards `constraints` for me..
02:43:14 <dminuoso> (\\) :: a => (b => r) -> (a :- b) -> r
02:43:53 <dminuoso> Though Im still not sure what this is used for.. =)
02:45:24 <Maxdamantus> `a` doesn't look like a constraint you'd find in Haskell.
02:45:48 <dminuoso> What do you mean?
02:47:43 <Maxdamantus> They usually look like statically resolvable classes with arguments applied.
02:47:47 <Maxdamantus> eg, `Show a`
02:48:45 <dminuoso> Maxdamantus: Well you could state (Ord a :- Eq a)
02:48:55 <dminuoso> Maxdamantus: Remember this is with constraint kinds enabled.
02:54:20 <Akii> anyone got an idea? I feel like I'm overlooking something... https://github.com/scotty-web/scotty/issues/217
02:58:09 <Akii> Can't even find the code that does the file reading. I suspect this is passed to WAI.
03:00:06 <dminuoso> Akii: Try with `raw`
03:00:11 <Akii> https://github.com/yesodweb/wai/issues/644
03:00:13 <Akii> there it is
03:05:01 <Akii> well at least now it's documented for the next person to find
03:05:29 * hackage push-notify-apn 0.1.0.7 - Send push notifications to mobile iOS devices  https://hackage.haskell.org/package/push-notify-apn-0.1.0.7 (hc)
04:03:21 <lemmih> owlscientist: You realized that there weren't that many segfaults to hunt in Haskell, eh?
04:33:02 <dminuoso> lemmih: I dont know about that! During my first weeks I had a seg fault.. it started like this..
04:33:18 <dminuoso> "How do I tell the type checker to shut up and trust me", "unsafeCoerce", "Great, thanks!"
04:33:29 <lemmih> :D
04:34:43 <kuribas> why, if I make a new name with newName, does ghc complain about multiple declarations?  Shouldn't it make a fresh nmae?
04:36:11 <kuribas> Does the uniqueness not apply at toplevel?
04:36:42 <kuribas> I need to generate a helper function for my TH instance declaration
04:40:33 <kuribas> seems I'm correct: https://ghc.haskell.org/trac/ghc/ticket/13054
04:50:41 <kuribas> now if I could do let helper = ... in instance MyClass MyType where f = fWithHelper helper ...
04:50:45 <kuribas> but that doesn't work...
04:57:00 <kuribas> I can make a lambda of the helper, but that may give bloat in some cases.
04:57:30 <kuribas> Seems like to only option now, or generating a fresh name myself.
05:20:44 <kuribas> Both options aren't very satisfactory...
05:31:27 <andriusbartulis> So. Damn. Quiet.
05:35:27 <risciii> Hi
05:39:53 <chisui> hey
06:48:23 <kuttifunk> hi there out in the world, any recommended, usual, common practice way to have default record values with the wonderful optparse-generic? I do not want to update the records 'by hand'.
06:51:31 <kuribas> kuttifunk: normally you just create a value with the defaults.
06:51:46 <kuribas> kuttifunk: then you can update it with record accessors, or lensses...
06:51:49 <lyxia> kuttifunk: this discussion seems relevant https://github.com/Gabriel439/Haskell-Optparse-Generic-Library/issues/11
06:54:44 <kuttifunk> kuribas: thanks. that i do now. just wondering if i did not see any more convenient way. Like 'input' the defaults to getRecord.
06:58:23 <kuttifunk> lyxia: yes. thank you. Saw that discussion. Ended up in black magic (to me).. So I will read on and try that (LamdaCase + ViewPatterns).
07:40:24 <pimlu> does ghc auto flush buffers when a program terminates?
07:40:41 <pimlu> er, output streams
07:42:04 <pimlu> I guess it must, since I've never had problems with it before
07:42:25 <pimlu> probably calls hClose
07:52:02 <Entroacceptor> probably the OS does it to clean up?
07:53:19 <Tuplanolla> The operating system certainly doesn't do it for you.
07:59:29 * hackage path-extra 0.1.0 - Some extensions to Chris Done's path library, for use with urlpath and attoparsec-uri.  https://hackage.haskell.org/package/path-extra-0.1.0 (athanclark)
08:05:29 * hackage arrows 0.4.4.2 - Arrow classes and transformers  https://hackage.haskell.org/package/arrows-0.4.4.2 (RossPaterson)
08:22:19 <kuribas> how do you represent a nil pattern ([]) in TH?
08:23:07 <lemmih> kuribas: As in 'listP []' ?
08:23:19 <kuribas> lemmih: yeah, thanks :)
08:39:18 <bobby> can someone give me an example for the function apply?
08:42:51 <kuribas> :t apply
08:42:53 <lambdabot> error: Variable not in scope: apply
08:43:00 <kuribas> bobby: which function apply?
08:44:23 <bobby> i saw this on a haskell course slide https://imgur.com/a/d0vNy
08:45:16 <bobby> oh ... sorry ... my mistake. I see it's userdefined function
08:45:22 <kuribas> bobby: yes :)
08:45:37 <bobby> shame on my :[
08:45:43 <Tuplanolla> The equivalent of Scheme's `apply` is just `id`.
08:46:05 <bobby> thx
08:46:23 <kuribas> or ($) ?
08:51:25 <nut> what is the use of enum ?
08:51:44 <nut> when do people use the enum type class?
08:51:58 <kuribas> enumerating
08:52:11 <kuribas> turning a sum type into a number
08:52:23 <nut> how will turn it into a number help?
08:52:25 <kuribas> > fromEnum True
08:52:28 <lambdabot>  1
08:52:42 <Ferdirand> nut: if you want to use it with ranges, for instance
08:52:51 <kuribas> nut: serialisation
08:53:16 <nut> serialisation, you mean numbers are easier to serialize?
08:53:22 <kuribas> yes
08:54:13 <kuribas> they are also the most space efficient
08:54:24 <nut> i am building a lookup table, with assosiation list. the key is a string, im thinking whether it helps to type class it to enum
08:54:55 <nut> and lookup just a number
08:55:11 <srid> grr, cassava pins bytestring, and there is no git repo for that version to use from nix.
08:55:21 <kuribas> nut: there is Data.Map (with Ord), and Data.HashMap (with hashable)
08:55:31 * srid wonders if there is a csv parser alternative to cassava
08:55:53 <nut> kuribas: i know, it will use them as a later implementation
08:56:14 <kuribas> nut: they are probably better than anything homebrew...
08:56:47 <kuribas> nut: Enum doesn't give you anything useful for lookup.
08:57:16 <nut> i am thinking ,during lookup, comparing number is faster than comparing strings
08:57:42 <kuribas> nut: yes, but you have an ADT, not a string?
08:57:46 <Tuplanolla> It sounds like you're about to rediscover what hashing is, nut.
08:58:11 <nut> i dont have ADT
08:58:42 <nut> i have a [("someting", ()), ...]
08:59:22 <nut> in a 'global variable'
08:59:33 <nut> or top level 'lookup table'
09:00:27 <kuribas> nut: then HashMap is better
09:01:07 <nut> oki, let me try them all
09:01:57 <nut> it's jsut im wondering if for the 'key' part in association list, people usually use enum or not
09:02:43 <kuribas> nut: if you can model it with a ADT, that would be better yes.
09:24:50 <EvanR> mounty: oh yeah, regular ByteString attoparsec also gives you the unconsumed output in Done
09:26:05 <simony> hm, maybe i'm missing something, but i just set up a hakyll project and every time i do stack build, it seems to rebuild pandoc, haddock-library, pandoc-citeproc, and hakyll every single time
09:31:13 <Tuplanolla> This is known, simony: https://github.com/commercialhaskell/stack/issues/3899
09:32:22 <simony> thanks a bunch! thought i was going crazy haha
09:32:25 <Tuplanolla> The workaround is to run `stack build` once, copy the GHC invocation it used and apply that directly to the forehead until the issue is resolved.
09:33:46 <Tuplanolla> Probably `/home/simony/.stack/setup-exe-cache/x86_64-linux/Cabal-simple_nonsense_2.0.1.0_ghc-8.2.2 --builddir=.stack-work/dist/x86_64-linux/Cabal-2.0.1.0 build exe:project --ghc-options "-ddump-hi -ddump-to-file -fdiagnostics-color=always"`.
09:34:30 * hackage ats-pkg 2.8.0.8 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-2.8.0.8 (vmchale)
09:34:41 <Tuplanolla> The same goes for `stack exec project`.
09:35:01 <Tuplanolla> Probably `.stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/project/project`.
09:36:27 <EvanR> simony: you don't have to be crazy to use haskell, we'll train you
09:37:07 <fr33domlover> (to be crazy)
09:37:13 <fr33domlover> ;)
09:41:00 * hackage transformers-base 0.4.5 - Lift computations from the bottom of a transformer stack  https://hackage.haskell.org/package/transformers-base-0.4.5 (MikhailVorozhtsov)
09:41:29 * hackage shake-ats 1.6.0.1 - Utilities for building ATS projects with shake  https://hackage.haskell.org/package/shake-ats-1.6.0.1 (vmchale)
09:44:06 <simony> whelp that's gonna put a damper on moving my site to hakyll this weekend :'D
09:45:41 <hvr> Tuplanolla: ...a simpler workaround may be to use cabal 2.2
09:46:28 <hvr> I've been using Hakyll w/o any issues there
09:47:32 <nut> n <- if numDice (ps !! i) == 1 then rollDie else rollDice
09:47:39 <nut> can i use bar notation on <-
09:47:40 <nut> ?
09:49:11 <hvr> nut: what's "bar notation"?
09:49:34 <EvanR> > do {n <- if True then [1,2,3] else [4,5,6]; return (n+1)}
09:49:37 <lambdabot>  [2,3,4]
09:50:09 <nut> let n | if numDice .== 1 = rollDie
09:50:28 <nut> rollDie is wrapped in IO
09:50:33 <hvr> nut: ah; no, but you can help yourself to something similiar via lambdacase:
09:51:13 <EvanR> i hope you meant, rollDie is an IO action
09:51:17 <hvr> or wait; no, this is about the pure computation
09:51:38 <nut> yes Evanr, rollDie is IO action
09:52:05 <nut> I want n to be the dice number without IO
09:52:26 <EvanR> heh
09:52:55 <nut> I just feel the bar notation is more pleasant to read
09:53:01 <EvanR> i still havent come to grok the idea that IO A is some actual A that happens to be inaccessible becaues its wrapped in an IO
09:53:02 <hvr> nut: you could use MultiWayIf
09:53:11 <hvr> nut: n <- if | ...
09:53:23 <EvanR> and the only way to get at it is the unwrap it
09:53:24 <EvanR> wacky
09:53:41 <Vulfe> well it's not some actual A wrapped up, it's just that using it feels that way because of the signature of bind
09:54:19 <EvanR> because of too many burrito tuts
09:55:04 <EvanR> type params can mean many things, getting stuck on wrappers can be bad
09:55:12 <orzo> I notice that with DataKinds, I can make data constructors with Nat arguments.  Do such things have a meaning when used as run-time values rather than kinds?
09:55:27 <OmegaDoug> Wondering if anyone has any experience with "https://hackage.haskell.org/package/typed-process-0.2.1.0/docs/System-Process-Typed.html"? I'm having some trouble understanding how to create a ProcessConfig
09:57:34 <orzo> OmegaDoug: use functions shell or proc
09:57:36 <EvanR> orzo: nope
09:58:05 <OmegaDoug> orzo: Are those functions suitable for dynamic interaction with a process?
09:58:10 <EvanR> in GHC.Types you will find the definition of Nat. data Nat
09:58:38 <EvanR> it has no constructors and is only used at the type level. type literals of kind Nat are magic
09:58:59 * hackage clash-prelude 0.99 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.99 (ChristiaanBaaij)
09:59:32 <EvanR> but you can convert such things to Integer during runtime using type classes
10:00:44 <OmegaDoug> orzo: Thanks for the suggetion, I'll have a look
10:01:31 <orzo> Why is it this way instead of a lifted Nat type?
10:01:59 * hackage clash-lib 0.99 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.99 (ChristiaanBaaij)
10:02:07 <EvanR> you will find some libraries that do it that way, and then 3 will have to be written S (S (S Z))
10:02:31 <EvanR> this is ok when the user isnt expected to be messing directly with the numbers
10:02:56 <woodson> can anyone please give me a hand, I am trying to parse and generate xml an xml file using HaXml but I am not too sure how to look for a certain element in the scheme
10:03:03 <EvanR> the magic Nat you are asking about is only a thing when using TypeLits
10:03:07 <woodson> http://lpaste.net/2338601553708974080
10:03:21 <orzo> i know, but I'm asking about TypeLits
10:03:29 * hackage clash-ghc 0.99 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.99 (ChristiaanBaaij)
10:03:30 <orzo> why a magic nat there
10:03:36 <woodson> Also since some of my data are maybe values i am not too sure how to handle this too
10:03:40 <EvanR> performance and convenience i guess
10:04:36 <EvanR> ideally it wouldnt even be a lifted unary Nat, it would be literally a Nat type, like in dependently typed systems, but...
10:08:42 <EvanR> orzo: you have a better idea for number sugar?
10:17:02 <orzo> In GHC.Types, the declaration of Symbol is justified because "class IP needs it".  Do you know this class IP?
10:18:23 <EvanR> heh
10:18:57 <EvanR> i believe it stands for Implicit Params
10:19:06 <EvanR> http://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IP.html
10:19:28 <EvanR> i dont know what it has to do with Symbol
10:19:51 <EvanR> ah
10:20:01 <EvanR> in the source for that class, class IP (x :: Symbol) a | x -> a where
10:20:25 <EvanR> hacks upon hacks
10:21:03 <orzo> oh
10:22:21 <[exa]> what's it good for btw?
10:22:31 <hpc> absolutely nothing, HUH
10:23:17 <EvanR> its a conversation starter
10:23:45 <[exa]> whoa
10:24:35 <cyberon> would hackscell be a good language to learn if I want to look like a hacker
10:25:13 <[exa]> cyberon: I'd prefer something less comprehensible, like perl
10:27:14 <lyxia> I have yet to see a movie feature Haskell, but I've seen HTML...
10:34:11 <orzo> i don't think i've ever used implicit parameters
10:34:23 <orzo> other than to try it out
10:36:00 <orzo> i supose some haskeller out there lives by them
10:38:13 <MattAtStarbucks> Is there a category of types? Is a type class a category of types, with extra structure, admitting a forgetful functor to the category of types? My google search for "category of types" didn't turn up much...
10:38:34 <[exa]> they usually call it Hask
10:39:07 <edmundnoble_> You can pretend to call types and functions a category, and though there is no rigorous definition of "the category of Haskell types" it can help in thinking about things
10:39:24 <edmundnoble_> A type class is not exactly a category of types admitting a forgetful functor to the category of types
10:39:33 <edmundnoble_> It kind of is
10:39:51 <MattAtStarbucks> Is there a rigorous definition outside the haskell world, among the category theory folks?
10:40:07 <edmundnoble_> You need to do it for Haskell specifically
10:40:26 <EvanR> a type class is a proposition parameterized by types
10:41:04 <edmundnoble_> You can say there's a CPO of Haskell types if you want to learn and say things about nontermination, you can say there's a category of Haskell types if you want to learn and say things about the usual kind of Functor, Monad, etc.
10:41:23 <EvanR> when the compiler is asked to check Num XYZ it will either prove it true, prove it false, or say "uh dunno"
10:41:43 <edmundnoble_> Afaik it's more like prove it true or say it's false
10:41:53 <edmundnoble_> If you have a type class with one parameter (or more generally, a type-level function from kind * to Constraint), then you can talk about the "subcategory" of Haskell types for which that type class has an instance
10:41:58 <[exa]> it can prove it false by any other way than "lol dunno"?
10:41:59 <EvanR> "could not deduce ...."
10:42:16 <edmundnoble_> Right, false and couldn't deduce are the same from the compiler's perspective
10:42:28 <EvanR> well, philosophically
10:42:37 <edmundnoble_> That subcategory of Haskell types with a particular type class instance certainly *does* admit a forgetful functor to the "underlying category"
10:42:45 <EvanR> especially if you enable undecidable instances, "dunno" is a valid result
10:42:58 <edmundnoble_> See https://hackage.haskell.org/package/subhask-0.1.1.0/docs/SubHask-Category.html
10:43:19 <MattAtStarbucks> @edmundnoble_ That's where I'm coming from, I'm trying to understand how to compose functors, monads in Haskell.
10:43:19 <lambdabot> Unknown command, try @list
10:43:38 <edmundnoble_> If you want to know how to compose monads, there's a couple of ways like products
10:44:01 <edmundnoble_> Or look up extensible effects
10:45:06 <edmundnoble_> Functors compose straightforwardly; look at the `Compose` newtype
10:45:17 <dncr> In the linear package, why is constructor V1 a not strict but V2 !a !a is?
10:45:21 <MattAtStarbucks> There is no canonical way to compose monads? They're functors, and the composition of two functors is unambiguous, isn't it?
10:45:41 <edmundnoble_> dncr: Because V1 is a newtype
10:45:45 <edmundnoble_> So it is always strict
10:45:47 <dncr> aha
10:45:53 <edmundnoble_> MattAtStarbucks: The composition of two monads is not a monad in general
10:45:59 <edmundnoble_> The composition of two functors is a functor
10:46:43 <EvanR> so really there is no composition of two monads
10:46:43 <MattAtStarbucks> edmundnoble_ Explains why I was having trouble proving this...
10:48:53 <MattAtStarbucks> Can one prove that the composition of Maybe and IO, as functors, is a monad?
10:50:06 <EvanR> first question, can you prove IO is a monad
10:51:15 <EvanR> (serious question)
10:51:21 <MattAtStarbucks> Do you mean verify the axioms for the ostensible monad structure making IO an instance of the Monad type class? They yes...
10:51:30 <[exa]> MattAtStarbucks: after figuring out that thing with IO you can at least state that IO+Maybe doesn't get any worse than IO
10:51:32 <EvanR> yes
10:52:00 <EvanR> haha
10:52:27 <MattAtStarbucks> Perhaps I didn't give this computation its due. Is there subtlety there that's not present in the analgous computation for, say Maybe?
10:53:06 <EvanR> theres subtly not present in combining Maybe and say ->
10:53:24 <EvanR> just because IO doesnt have definite semantics
10:54:08 <Ferdirand> MattAtStarbucks: try writing join in terms of join for a composed monad
10:56:45 <akr> Hello, has there been any work on proving functor laws and such for your instance directly in Haskell with dependent types?
10:58:47 <edmundnoble_> What do you mean, as functors?
10:59:15 <edmundnoble_> You can't use `fmap` in order to compose two functors into a monad, in general
10:59:30 <edmundnoble_> You can compose Maybe and IO, but the operations you use need to go beyond even the monad operations
11:00:10 <akr> (that wasn't a reply to me, right?)
11:00:14 <edmundnoble_> Oh no
11:00:19 <edmundnoble_> I've seen people do that in Idris, though
11:00:50 <EvanR> maybe akr is talking about dependent haskell
11:00:55 <akr> too bad… I'll see if I can come up with something… I mean, we can define propositional equality, right?
11:01:15 <akr> EvanR: well, yeah, can't prove much without dependent types :)
11:01:25 <edmundnoble_> Yeah, sorry don't know much about dependent Haskell, I didn't know it was usable
11:01:48 <MattAtStarbucks_> Thanks for the insight, folks. Having connectivity issues and kids are getting impatient...
11:01:51 <EvanR> i do dependent haskell up here *poke head*
11:04:22 <akr> that's great, but does "up there" perform type-checking? ;)
11:04:31 <EvanR> yes
11:04:57 <EvanR> its especially useful when your language at hand does not
11:14:00 * hackage hledger-lib 1.9 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-1.9 (SimonMichael)
11:14:16 <kuribas> is it not possible to use helper functions in TH without exporting them?
11:14:33 * hackage hledger-api 1.9, hledger-web 1.9, hledger-ui 1.9, hledger 1.9 (SimonMichael)
11:17:17 <kuribas> I have [d| instance MyClass MyData where method1 = ...; method2 = ... |]
11:17:33 <kuribas> it seems these methods don't refer to the class methods of MyClass
11:17:51 <kuribas> splice output shows: getAtPointer_apIT
11:19:18 <haskellbook> Hello everyone, I’m working through Haskell Book and I’m stuck on an exercise
11:19:32 <haskellbook> I need to write a Semigroup instance for this data type:
11:19:45 <haskellbook> newtype Combine a b =
11:19:45 <haskellbook>     Combine { unCombine :: (a -> b) }
11:19:46 <haskellbook>     deriving (Show, Eq)
11:20:03 <haskellbook> I need to write an arbitrary instance that generates (a -> b) for quickcheck
11:20:07 <haskellbook> Here’s what I’ve got.
11:20:11 <haskellbook> But it’s not working
11:20:19 <haskellbook> instance (CoArbitrary a, Arbitrary b) => (Arbitrary) (Combine a b) where
11:20:20 <haskellbook>     arbitrary = do
11:20:21 <haskellbook>         (\a -> f $ a) <- arbitrary
11:20:22 <haskellbook>         return $ Combine (a) (f $ a)
11:20:26 <lyxia> haskellbook: stop pasting code here
11:20:51 <mavo> Bonsoir à tous
11:20:56 <mavo> Vous allez bien ?
11:21:06 <lyxia> haskellbook: http://lpaste.net
11:21:10 <mavo> Oui ya quelqu'un qui parle français ici ?
11:21:10 <haskellbook> Sorry, is it not permitted?
11:21:16 <haskellbook> Oh, I see
11:21:18 <haskellbook> Sorry
11:21:21 <lyxia> mavo: come to #haskell-fr
11:21:47 <mavo> lykrysh merci à toi :)
11:22:06 <python476> merci boku aussi
11:22:13 <edmundnoble_> `(\a -> f $ a) <- arbitrary` doesn't make sense to me, is that correct syntax?
11:22:22 <haskellbook> No I don’t think so
11:22:37 <haskellbook> But, I’m not sure how to express how to return a function of type (a -> b)
11:22:42 <haskellbook> I’m a relative newcomer also
11:23:40 <edmundnoble_> So what's your understanding of `CoArbitrary`?
11:24:48 <EvanR> I am looking at the implementation of lazy text Builder... and am a bit confused at how its working. There seems to be exactly 1 ST mutable array being threaded through the building process. It gets unsafeFrozen and stuffed into a Text chunk and outputted. ... then used as is for the next loop
11:26:29 * hackage brick 0.36 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.36 (JonathanDaugherty)
11:28:17 <kuribas> weird that methods inside [d| instance Class Data where ... |], don't refer to the actuall methods of the class
11:32:35 <jle`> is there any way to export pattern synonym records alongside the patterns?
11:33:25 <jle`> hm i guess not https://ghc.haskell.org/trac/ghc/ticket/13307
11:34:46 <cyberon> haskell is so sexy
11:34:53 <cyberon> if he was a girl I would date him
11:35:11 <akr> damn, is there any way I can actually get actual dependent types in Haskell? I want to write: fmap_id ∷ (t ∷ Tree a) → (fmap id t) `PropEq` t
11:35:28 <akr> it complains that t should be a type
11:36:07 <akr> can't it lift automatically or something
11:37:59 * hackage hs-java 0.4.1 - Java .class files assembler/disassembler  https://hackage.haskell.org/package/hs-java-0.4.1 (IlyaPortnov)
11:38:34 <EvanR> akr: haskell has never had actual dependent types
11:38:54 <EvanR> it has had fake dependent types
11:39:09 <akr> is this going to change in the foreseeable future?
11:39:20 <EvanR> maybe
11:39:42 <EvanR> but i am not sure its going to extend into the theorem prover world like youre saying
11:40:02 <akr> well it's not like you can have without the other
11:40:09 <akr> have one without the other*
11:40:19 <EvanR> according to the dependent haskell paper, that is about to be challenged
11:40:45 <akr> huh
11:40:54 <EvanR> for one thing, dependent haskell will still be partial because haskell, so you still wont have totality
11:41:09 <EvanR> which i hear is important for theorem proving
11:41:40 <akr> you really only need totality for the stuff you use in types
11:41:56 <EvanR> need, or would be nice :)
11:42:56 <EvanR> you should always strive to write total code, whatever that means, at whatever level. But haskell is not going to be checking that for you
11:43:16 <akr> sure, that's fine
11:43:35 <akr> being forced to write everything in a way that is provably total is pain
11:43:54 <akr> something something Blum size theorem
11:44:07 <EvanR> esp when provably means, provable in the 1 or 2 ways the compile knows
11:44:50 <akr> yeah
11:45:40 <akr> ok anyway I'll just prove this stuff by hand then
11:45:44 <akr> thanks for the info!
11:51:24 <kuribas> hmm, warnings for TH is pretty annoying...
11:52:09 <kuribas> especially "defined but not used".  I don't want to track every variable in TH.
11:55:55 <akr> yeah that's annoying
11:56:03 <akr> too bad bad you can't disable warnings selectively with GHC
11:56:50 <kuribas> yeah
12:03:58 <aarvar> akr: you can probably write that proof at the type level, though the compiler won't ensure that the proof is total
12:05:32 <EvanR> er, isnt usual haskell stuff at the type level total?
12:07:47 <[exa]> Looking at core expressions: what is the (@ t) thing at the beginning at each lambda?
12:08:49 <EvanR> that is a type argument
12:09:24 <EvanR> forall a b . (a -> b) -> [a] -> [b] really has 4 args
12:09:49 <[exa]> oic, I thought these are materialized later.
12:09:58 <aarvar> not if you need UndecidableInstances
12:10:05 <aarvar> though maybe you don't actually
12:12:47 <Arul> --ERROR: Variable "b" occurs more often than in the constraint than in the instance head.
12:13:17 <Arul> Hello Everyone,
12:13:43 <Arul> I am trying to write Foldable instance for a higher kinded type and I get this error - "--ERROR: Variable "b" occurs more often than in the constraint than in the instance head."
12:13:52 <Arul> Here is the sample code - http://lpaste.net/364227
12:13:58 <EvanR> the restriction ensures type checking terminates
12:14:06 <EvanR> and can be disabled with UndecidableInstances
12:14:12 <Arul> Can someone help me figure out if why what I am trying to do is wrong ?
12:14:48 <alp> Arul, you're putting a constraint on 'b' but 'b' doesn't occur in 'Foldable (Tree' a)'
12:15:08 <EvanR> oh
12:15:10 <Arul> @evanR When I enable UndecidableInstances it causes lot of other problems
12:15:20 <EvanR> nevermind me, listen to alp
12:15:41 <davean> Arul: they're Undecidable for that reason :)
12:16:15 <alp> Arul, you presumably want to say that you want the 'b' in 'Three' a b' to be a Monoid
12:16:18 <Arul> :alp Yes. I agree. Is there any way to get around that? It feels like a legitimate to use case to want to combine two values in a fold
12:16:43 <alp> however, you cannot do that
12:16:55 <Arul> <alp> Yes that's right. I want to mention that "b" is a Monoid
12:17:11 <alp> Foldable precisely asks you to provide an implementation that can work for any choice of 'b'
12:17:17 <EvanR> this is the same thing as, i want Set to be a Functor
12:17:28 <alp> just like you don't get to constrain things in Functor/Monad instances
12:17:45 <alp> well, not the 'a' that you're fmapping over
12:18:01 <EvanR> but you cant because Functor doesnt let you have the Ord constraint on the variable
12:18:20 <alp> Arul, there is however a perfectly sensible definition of Foldable for your type
12:19:15 <alp> for example we could define foldMap to be: foldMap f (Three' a b1 b2) = f b1 <> f b2
12:20:05 <EvanR> nevermind, Foldable does let you have the Monoid constraint :)
12:20:17 <EvanR> in foldMap
12:20:21 <alp> it's on the `m` though, yes
12:20:41 <alp> Foldable wants a way to compute things from the 'b's, with foldMap you can see it easily: we only care about the 'b's, get a monoidal value out of each with 'f' and collapse them.
12:23:56 <Arul> alp Thanks for your suggestion to use foldMap. I was trying to derive a Monoid instance to be used with my foldr. I guess that's not possible
12:24:23 <EvanR> part of a larger narrative of not putting constraints on the types themselves, but on the operations
12:24:38 <EvanR> which is more flexible
12:27:17 <Arul> Thanks EvanR and alp
12:27:37 <alp> Arul, you could write a suitable foldr too. something like: foldr f c (Three' a b1 b2) = f b1 (f b2 c)
12:27:42 <alp> again, we only care about the 'b's.
12:28:11 <alp> and we're basically doing the same as foldr f c [b1, b2] by the way :)
12:29:16 <equwal> As someone who has never used Haskell (and wants to get started) this is really neat right here. You have a built in theorem prover in your language! That is seriously cool.
12:30:07 <EvanR> who did
12:34:29 * hackage transformers-base 0.4.5.1 - Lift computations from the bottom of a transformer stack  https://hackage.haskell.org/package/transformers-base-0.4.5.1 (MikhailVorozhtsov)
12:35:42 <[exa]> there's paper from the last IFL that proves that all reasonably complicated languages must have a theorem prover hidden somewhere
12:37:59 * hackage rando 0.0.0.3 - Easy-to-use randomness for livecoding  https://hackage.haskell.org/package/rando-0.0.0.3 (TomMurphy)
12:47:33 <redrapscallion> is there no way for me to change a part of an HTML page using Lucid or blazehtml without reloading the page?
12:48:12 <redrapscallion> it looks like even if I wanted to do something as simple as having a button increment a number inside a text area, I have to completely reload the page to do it (or I could just JS, but I don't want to use JS)
12:50:39 <[exa]> btw aren't there Show instances for GHC API stuff hidden somewhere?
12:53:59 * hackage base-encoding 0.1.0.0 - Binary-to-text encodings (e.g. base64)  https://hackage.haskell.org/package/base-encoding-0.1.0.0 (HerbertValerioRiedel)
12:56:10 <EvanR> reductum: to do that, something must use JS at some level
12:57:43 <redrapscallion> EvanR: I've kind of been babied by Django when working with Python, so I don't actually know how the low-level connection would work between JS and Scotty
12:58:34 <EvanR> lucid and blaze are both for essentially writing a A -> Html function
12:58:56 <EvanR> when A changes, you can rerender the HTML
12:59:07 <EvanR> youll need something else for this part
13:00:01 <redrapscallion> EvanR: ah, I figured. so I'll likely have to use something like AngularJS or something and integrate it with Haskell?
13:00:13 <EvanR> :(
13:00:57 <EvanR> i am not too familiar with whats out there, but i have heard people experimenting with reflex-dom
13:01:02 <Xal> AngularHS
13:01:32 <redrapscallion> EvanR: but then how exactly am I going to connect Haskell with a JS framework? :(
13:01:47 <EvanR> you dont want "a js framework"
13:02:07 <EvanR> you want a haskell framework, which will be using js at some level
13:03:06 <redrapscallion> what I'm thinking of is that I should be able to just create the HTML in Blaze/Lucid, and then pass that HTML to Angular so that it can refresh the HTML without reloading the page
13:03:18 <redrapscallion> is that too far-fetched? or is there some easier way?
13:03:38 <EvanR> is that how angular even works, i am skeptical
13:04:23 <EvanR> if so, then sure
13:04:40 <redrapscallion> EvanR: well, not really, because I would have to use Angular for the frontend entirely
13:05:16 <EvanR> having flashbacks to web tech nightmares right now
13:05:22 <redrapscallion> nvm, I realized it's a stupid idea
13:05:35 <dstolfa> EvanR: at least they're flashbacks
13:05:37 <EvanR> reflex-dom is a thing
13:05:50 * dstolfa avoided doing any web development in his life other than 3 months at one point
13:06:04 <redrapscallion> jesus
13:06:46 <xacktm> reflex-dom is good for SPAs
13:06:54 <EvanR> also, i hear elm has a thing which easily lets you do exactly what you said you wanted, click a button and it updates a box
13:07:09 <EvanR> whether that scales, dunno
13:07:16 <Rembane> redrapscallion: If you really want to shave some yaks: Learn Purescript.
13:08:03 <EvanR> FRP-zoo also has "click a button, update a box" as the litmus test example app
13:09:25 <[exa]> Are there Show instances for stuff in ghc api package?
13:09:56 <redrapscallion> this is already giving me nightmares lol
13:10:13 <EvanR> redrapscallion: if it wasnt clear... haskell can run in your browser to serve as a front end. because ghcjs. theres also elm and purescript
13:10:25 <[exa]> (there's only the Outputable stuff, which isn't very useful if someone's trying to hack through the stuff that comes from desugaring)
13:13:50 <redrapscallion> EvanR: hmm, I'm looking to explicitly only use Haskell, so ghcjs looks like it might be a viable solution
13:14:26 <EvanR> i hear its good
13:15:28 <Rembane> redrapscallion: Try Haste! It should fit your problem description perfectly!
13:16:37 <EvanR> ah i forgot about that one
13:16:42 <blonkhart> or miso
13:16:44 <EvanR> it sort of runs on both sides at the same time
13:17:05 <redrapscallion> Rembane: oh snap, that's cool
13:17:55 <Rembane> redrapscallion: Isn't it? :D
13:21:09 <redrapscallion> Rembane: it has real documentation too outside of just haddock pages. I'm sold.
13:22:07 <Rembane> redrapscallion: It's a unique! :)
13:23:49 <blonkhart> redrapscallion, haven't used haste but FWIW i would also take a look at miso. it is basically elm in ghcjs, and elm documentation carries over without much brain damage.  i find it beginner friendly
13:31:00 * hackage rando 0.0.0.4 - Easy-to-use randomness for livecoding  https://hackage.haskell.org/package/rando-0.0.0.4 (TomMurphy)
14:00:06 <jle`> any pre-built reservoir sampling conduit/pipe?  it's easy enough to make my own but was onwdering if there was one already out tehre
14:02:57 <ab9rf> reservoir sampling?
14:04:16 <ab9rf> ah
14:05:11 <ab9rf> hm
14:09:51 <ab9rf> doesn't appear that anyone has done that
14:10:39 <nut> any easy way to turn a sum type into a list of each ? data MyNum = One | Two   -->  [One, Two]
14:11:33 <AWizzArd> nut: is your type enumerable?
14:11:45 <nut> yes
14:11:55 <ab9rf> [ minBound .. maxBound ] :: t
14:12:01 <ab9rf> for any t that has a Bounded instance
14:12:26 <nut> cool
14:12:57 <ab9rf> iirc, Enums are not Bounded by default, but Bounded is derivable
14:13:31 <nut> so i have to derive my data from enum and bounded?
14:13:40 <nut> or just Bounded is enough
14:13:51 <deepfire> is it still impossible to have associated types that overlap?
14:14:12 <ab9rf> nut: that i don't know
14:14:38 <lyxia> deepfire: yes
14:14:46 <nut> deepfire: overlap in the key? I mean same key with different values?
14:14:59 * hackage transformers-compat 0.6.1.6 - A small compatibility shim for the transformers library  https://hackage.haskell.org/package/transformers-compat-0.6.1.6 (ryanglscott)
14:15:19 <deepfire> nut, I have a closed type family, that resolves the overlap due to ordering
14:15:39 <deepfire> nut, the first clause is more specific than the second -- otherwise the clauses are structurally similar
14:15:59 * hackage transformers-compat 0.6.1.5 - A small compatibility shim for the transformers library  https://hackage.haskell.org/package/transformers-compat-0.6.1.5 (ryanglscott)
14:16:05 <nut> sorry i misunderstood deepfire
14:16:08 <deepfire> nut, when I convert that type family to associated TF clauses, they don't have an explicit order anymore
14:16:29 * hackage transformers-compat 0.6.1.4 - A small compatibility shim for the transformers library  https://hackage.haskell.org/package/transformers-compat-0.6.1.4 (ryanglscott)
14:16:37 <deepfire> but I hoped that {-# OVERLAPPABLE #-} would help..
14:16:42 <deepfire> it doesnt : -)
14:17:00 * hackage transformers-compat 0.6.1.3 - A small compatibility shim for the transformers library  https://hackage.haskell.org/package/transformers-compat-0.6.1.3 (ryanglscott)
14:17:24 <lyxia> deepfire: you could use a type-level boolean to resolve the overlap
14:17:29 * hackage transformers-compat 0.6.1.2 - A small compatibility shim for the transformers library  https://hackage.haskell.org/package/transformers-compat-0.6.1.2 (ryanglscott)
14:18:06 <deepfire> lyxia, that sounds like a fine plan, thank you!  Let me try it..
14:18:40 <ian5v> hiya. I'm trying to be clever with list comprehensions and not succeeding:
14:18:42 <ian5v> https://hastebin.com/zusikacuve.swift
14:21:38 <deepfire> lyxia, problem is, of course, now I need to compute that type-level boolean for the case that matters : -)
14:21:48 <lyxia> ian5v: it seems easier to pick two indices as numbers, so you can get and put back elements in the list
14:22:58 <lyxia> deepfire: Yes, there is probably no way around type equality as a closed type family
14:51:30 * hackage transformers-base 0.4.5.2 - Lift computations from the bottom of a transformer stack  https://hackage.haskell.org/package/transformers-base-0.4.5.2 (MikhailVorozhtsov)
15:13:16 <deepfire> lyxia: my problem is that I want to tear-down two inductively constructed HList-like structures of different lengths, using the length of one of them as an index of another
15:13:30 <deepfire> *into another
15:13:59 <cyberon> haskell hurts my brain
15:14:18 <cyberon> someone tell me The Zen of Haskell
15:14:30 <deepfire> cyberon: there is no royal road to geometry
15:15:51 <deepfire> lyxia, essentially, I need the type in HList A, that is implicitly specified by a HList B
15:16:14 <deepfire> maybe I just need to read more Oleg
15:17:39 <deepfire> cyberon: that is something that Euclid said, some time ago
15:19:23 <ambro718> I'm thinking about something related to monads and I can't figure out how to define a specific data which represents "action that when executed produces a value of type a", and appropriate constructors for for such a type
15:20:31 <ambro718> For example, an example of such a type would be: 1) GetLine is an action that produces a String 2) GetInt is an action that produces an Integer (that is all)
15:20:45 <lyxia> deepfire: type family Ix xs ys ; type instance Ix (x ': xs) (y ': ys) = Ix xs ys ; type instance Ix '[] (y ': ys) = y  something like that?
15:22:41 <ambro718> I am thinking in the direction:  data return_type = GetLine | GetInteger;  but how to say that GetLine is only for String and GetInteger is only for Integer?
15:22:48 <deepfire> lyxia: exactly -- that's extremely close to what I have
15:22:53 <lyxia> ambro718: data Action a where GetLine :: Action String ; GetInt :: Action Integer
15:23:31 <ambro718> lyxia: thank you. Never seen that syntax before.
15:24:08 <lyxia> ambro718: This is called a GADT https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-algebraic-data-types-gadts
15:25:23 <lyxia> ambro718: there is another representation that doesn't require extensions:   data Action a = GetLine (String -> a) | GetInteger (Integer -> a)
15:25:55 <lyxia> you can do similar things with both of those.
15:26:50 <deepfire> lyxia: I have a function that tears down a couple of singletons indexed by those type-level HLists
15:27:47 <deepfire> lyxia: but I don't know how to define the return type of this function -- which I expect would yield an element indexed by a memeber of the HList being indexed into
15:28:18 <deepfire> I have tried to use this Ix-like type-level function -- but it gets stuck
15:28:52 <lyxia> deepfire: do you have a snippet of code available somewhere
15:29:29 <deepfire> give me a bit of time, please..
15:30:31 <lyxia> Sure, no problem.
15:42:30 * hackage monad-abort-fd 0.6.2 - A better error monad transformer  https://hackage.haskell.org/package/monad-abort-fd-0.6.2 (MikhailVorozhtsov)
15:46:31 <deepfire> lyxia: https://gist.github.com/deepfire/b2f7128615d33afdb32b475375f4ca5e is one way I've been attacking this in the past
15:47:13 <ambro718> Here's what I came up as a general approach to interpreters: http://lpaste.net/364234 without any actual monads. Can someone comment? Is the Program thing less powerful than monads?
15:47:51 <deepfire> that's the base case, where I still had a misguided hope the TF would be invoked per function clause, when discharging the GADT
15:47:58 <unyu> Is there a NaN constant in base that I can just use?
15:48:27 <lyxia> unyu: nope
15:49:26 <lyxia> ambro718: that's a well-known monad
15:49:46 <ambro718> lyxia: monad? there's no >>= or anything like that
15:49:55 <lyxia> ambro718: the fact that you didn't define (>>=) doesn't make it not a monad
15:50:11 <ambro718> lyxia: so what is it then?
15:51:01 <lyxia> ambro718: it's also called operational monad, or freer monad
15:51:46 <lyxia> It's like using (++) for lists and saying that's not using monoids.
15:51:56 <ambro718> lyxia: can you tell if my Program can be used to build equivalents to the list monad and such or if it is a strictly more restricted thing than monads?
15:54:45 <lyxia> Sure you can write Program with nondeterministic actions and interpret them as lists.
15:55:59 <lyxia> there are monads in Haskell you can't encode that way because it doesn't allow infinite left-recursion
15:56:13 <ambro718> I am asking because this definitions seems much more understandable/approachable to me than how monads are defined
15:56:44 <ambro718> lyxia: where would you encounter infinite left-recursion?
16:00:52 <lyxia> One example I have in mind is to generate infinite values with QuickCheck.
16:01:50 <lyxia> It also happens with reader and lazy state/writer.
16:01:51 <ambro718> and the issue would be where? recursion in interpret?
16:03:40 <lyxia> ambro718: An infinitely long Program m never Returns.
16:04:38 <ambro718> I guess so. Anyway I don't think I understand stuff enough to think about this yet :)
16:05:50 <lyxia> ambro718: there are a lot of discussions about Program to be found online. The keywords are free/freer/operational monads.
16:06:23 <ambro718> lyxia: indeed, I read stuff about free monads but the reason I came to this definition is that it is much simpler
16:06:35 <unyu> Are there any easy-to-use, please-don't-make-me-think libraries for plotting functions? Think something like matplotlib, except I don't want to reimplement these pesky numerical methods in Python.
16:07:11 <lyxia> ambro718: https://apfelmus.nfshost.com/articles/operational-monad.html is probably a good starting point (the first formulation of Program is attributed to Apfelmus)
16:07:13 * deepfire joins unyu's question
16:07:55 <unyu> THe result doesn't have to be super polished. My goal in using Haskell is simply to not use Python or MATLAB.
16:08:36 <deepfire> lyxia: but wasn't the entire concept of monadic interpretation elucidated by Oleg Kiselyov before Heinrich Apfelmus?
16:12:30 <deepfire> Citing Olen: > The definitional effect interpreter we have just described is the Operational Monad by Heinrich Apfelmus.
16:12:36 <deepfire> *Oleg
16:12:54 <deepfire> http://okmij.org/ftp/Computation/free-monad.html
16:13:09 <int-e> ambro718: connections to operational, free monads, and earlier MonadPrompt and a think called Unimo aside, here's some musings on your exact type: http://lpaste.net/364236
16:15:01 <ambro718> int-e: I was just trying to write >>= to let me use do notation, I understand you did just that already?
16:15:46 <int-e> ambro718: yes
16:17:09 <int-e> ambro718: though my main goal was to get to the point where one can see that this is just as powerful as any other monads.
16:17:14 <ambro718> int-e: so you could run it with a list monad to achieve list comprehensions?
16:19:26 <int-e> ambro718: yes.
16:23:38 <lyxia> deepfire: Index is really pattern matching on the tail of the second list, so the function clauses need to reflect that.
16:27:09 <ambro718> int-e: I get an error trying to use do with your Monad definition, with this code:   testProgram1 = do line <- GetLine; int <- GetInt; Return (line ++ show int);
16:27:11 <ambro718> Couldn't match type ‘Program f0’ with ‘MyAction’
16:28:42 <deepfire> lyxia, I would have thought that they do -- matching on Z and S..
16:29:01 <int-e> ambro718: Ah, I didn't provide the  f x -> Program f x   operation: op f = Step f Return  (well I did, but "fromUniversal" isn't an obvious name for that)
16:30:57 <int-e> ambro718: https://hackage.haskell.org/package/MonadPrompt-1.0.0.5/docs/Control-Monad-Prompt.html is based on the same kind of interface btw: what I just called "op" is called "prompt" there and it has runPrompt and runPromptM for execution.  So you could write  `testProgram1 = do line <- prompt GetLine; in <- prompt GetInt; return (line ++ show int)`.
16:31:03 <lyxia> deepfire: (Z _) and (S ss) on lines 25-26 tell you that ys ~ (y ': ys2), but the type family doesn't reduce until you know whether ys2 is empty or not
16:32:11 <int-e> ambro718: (It's probably a good idea to define operations like  getLine' = prompt GetLine, getInt = prompt GetInt, etc.)
16:32:37 <deepfire> lyxia: indeed, I would have thought that the TF would use the GADT-provided information during reduction and wouldn't get stuck -- but alas it doesn't know if ys2 is empty or not
16:33:18 <ambro718> int-e: thanks that works. Yeah I figured the second part
16:33:20 <lyxia> deepfire: why isn't the type of Z :: x -> Ix (x ': '[])
16:34:21 <lyxia> deepfire: and S :: Ix (x2 ': xs) -> Ix (x ': x2 ': xs)
16:34:24 <deepfire> lyxia, I don't control the type -- Ix and Ixee are actualy NS and NP from generics-sop
16:34:51 <deepfire> I'm trying to use NS as an index into NP -- full disclosure
16:36:08 <deepfire> the real NS and NP carry an extra argument, but that's largely irrelevant to the problem
16:36:14 <lyxia> deepfire: okay in that case it's not possible to define that as a function because the GADT just doesn't reflect enough information about the type index
16:37:19 <deepfire> kosmikus: I think the problem you gave me had no easy solution -- I've banged my head against it for a couple of days, before turning to lyxia..
16:39:46 <deepfire> lyxia, thank you a great lot!
16:40:10 <int-e> ambro718: in any case thanks for proving that "you could have invented free monads" (even though free monads are defined a bit differently: data Free f a = Free (f (Free f a)) | Pure a ... it's an interesting little exercise to figure out how to convert between the different flavours of this idea.)
16:41:01 <deepfire> I've tried to attack this one from several angles -- the type classes were kind of promising, since they provided a modicum of information about the type structure, but associated types can't be overlapped..
16:41:34 <deepfire> The function-level dispatch doesn't appear to reuse the information provided by GADTs in the return type
16:42:06 <ambro718> int-e: hah, as I said I had already read about free monads and then after some weeks came to this construction not being impressed by all the monad theory :)
16:45:03 <ambro718> int-e: my thinking was to write what I need in the clearest possible way, and my thing basically reads: "a program returning a is either one that just returns a, or a computation step that returns b together with a function that gives you the rest of the program given the b result of that step".
16:45:19 <int-e> ambro718: I really think that the idea of encoding an interface in a GADT is quite valuable... and sadly lost (well, obscured) in the "free" approach.
16:45:22 <ambro718> on the other hand, I have no idea how I am supposed to read the Free thing :S
16:48:43 <deepfire> lyxia, I was wondering if the reuse of GADT-provided information about the Ix type constructors (Z/S) -- and effectively allowing the Index TF to be reduced -- would have been unsound
16:49:08 <deepfire> lyxia: ..meaning this in the context of the example
16:50:36 <deepfire> that sounds like a non-trivial question to me -- whether to allow the return types to be arbitrary computations on argument types?
16:51:11 <int-e> ambro718: You *can* use the funky functor `data ActionF action a = forall x. ActionF (action x, x -> a)` to encode `Program act` as `Free (ActionF act)`
16:54:06 <int-e> ambro718: But that doesn't feel natural to me :) (That functor was not my idea... unfortunately I forgot where I learned that.)
16:56:47 <ambro718> I'm gonna have to look at the Free monad a bit more to figure out how it compares to Program
17:02:59 * hackage usb 1.3.0.6 - Communicate with USB devices  https://hackage.haskell.org/package/usb-1.3.0.6 (BasVanDijk)
17:03:23 <ambro718> ah now I remember. The Free monad requires your functor to stuff in the "next", but Program does not.
17:03:36 <ambro718> from this respect, Program seems more appropriately abstracted?
17:14:31 <koz_> byorgey: Does uniform from MonadRandom have to materialize the entire list it's sampling from? From reading the source, it _appears_ to be 'yes', but I'd rather check to make sure I'm not missing something.
17:22:10 <int-e> ambro718: Yeah I do prefer the Prompt monad formulation over Free, as a programmer. For a theoretician, especially with a category theory background, I guess the free monad is more natural. Btw, I found https://www.reddit.com/r/haskell/comments/unpaz/explaining_the_prompt_monad_with_a_clearer/ which describes the "funky functor" idea; it's basically the same as the "Step" constructor, abstracting...
17:22:16 <int-e> ...from the recursive "Program action_functor ret_type".
17:23:18 <ambro718> int-e: this "left recursion problem", is it just about applying >>= ?
17:24:08 <ambro718> int-e: could monads be avoided entirely and do notation be syntax sugar for stuff like this: Step GetLine (\line -> Step GetInt (\int -> Return (line ++ show int)))
17:24:40 <sl2c> koz_: it has to for the simple reason that you need to know the length to get the probability of pulling the front
17:27:35 <ambro718> I just can't help but think most of this category theory is not really necessary
17:27:35 <koz_> sl2c: Yeah, I thought so.
17:28:07 <koz_> Even the various samplers that are meant to be 'smart' still use the total size as a parameter.
17:29:54 <sl2c> ambro718: i mean, doing the desugaring polymorphically is pretty much equivalent to desugaring to >>= and the like
17:31:48 <int-e> ambro718: I suspect the compiler will actually produce such code for a  do  block, by inlining and statically evaluating the bind operation. But even so that would not help recursively defined functions, f 0 = retun (); f n = f (n-1) >>= some_action.
17:36:33 <ambro718> It is trivial to translate "do x <- Action1; y <- Action2; Return (x + y)" into "Step Action1 (\x -> Step Action2 (\y -> Return (x + y)))". But what happens due to monads is that it is desugared into "(Step Action1 Return) >>= (\x -> (Step Action2 Return) >>= Return (x + y))". Which involves those nontrivial fmap stuff to turn it into the first thing.
17:36:56 <ambro718> (hope I got that right. Not sure why it actually works since that Return has no argument...)
17:37:33 <ambro718> due to use of monad threory the expression must be turned inside out
17:38:46 <ambro718> or maybe I'm wrong, let me think a bit about it...
17:41:07 <koz_> :t fromIntegral
17:41:09 <lambdabot> (Num b, Integral a) => a -> b
17:41:47 <koz_> :t (/)
17:41:49 <lambdabot> Fractional a => a -> a -> a
17:42:48 <koz_> :t log2
17:42:50 <lambdabot> error:
17:42:50 <lambdabot>     • Variable not in scope: log2
17:42:50 <lambdabot>     • Perhaps you meant ‘log’ (imported from Numeric)
17:42:53 <koz_> :t log
17:42:55 <lambdabot> Floating a => a -> a
17:43:39 <int-e> ambro718: what I mean is that because the compiler can see that the first argument of the first >>= is a Step, it can inline it at simplify to get Step Action1 (\x -> Return x >>= (\x -> (Step Action2 Return) >>= Return (x + y))), and continuing in the same vain, it will end up with Step Action1 (\x -> Step Action2 (\y -> Return (x + y))) after a few more steps.
17:44:15 <int-e> ambro718: I have not tested this, but I really expect ghc to accomplish this if optimizations aren't switched off.
17:45:17 <int-e> ambro718: But that's for do blocks with a statically known structure, and actual recursion is a different matter.
17:45:30 <ambro718> I imagine. But it doesn't change that the construction is needlessly complicated.
17:46:26 <ambro718> int-e: you mean like the program calling itself?
17:48:17 <ambro718> int-e: do you know if do notation acually required definition of Monad class? Couldn't one just define >>=?
17:49:19 <ambro718> I'm thinking if it is possible to avoid those "Step X Return" which then get transformed into the right thing
17:49:56 <ambro718> I mean, could we define >>= such that the Steps returned by that are the only Steps involved in the construction, not temporary ones that are deconstructed
17:52:56 <ambro718> my thinking is that the need for the Monad to also be a Functor and Applicative is just because the definition is suboptimal. My Program construction doesn't seem to need these operations to work.
17:53:34 <int-e> ambro718: Yes, the notation is tied to the Monad class.
17:54:17 <ambro718> that seems unreasonably restrictive :(
17:56:13 <int-e> ambro718: there's a ghc extension, RebindableSyntax ... but you'd still have to define >>= and return with basically the same type signature.
17:58:16 <Tuplanolla> There's also `ApplicativeDo`, but it's broken.
18:02:12 <int-e> ambro718: "you mean like the program calling itself?" I meant this to be an example: f 0  = return (); f n = f (n-1) >>= some_action ... f nests >>= on the left, with a depth that depends on n. And that will cause the definition of >>= (this one: Step a c >>= g = Step a (\x -> c x >>= g)) to be used quadratically (in n) often.
18:05:49 <int-e> > let f 0 = []; f n = f (n-1) ++ [()] in f 42 -- this is quite analogous; here the equation  (x : xs) ++ ys = x : (xs ++ ys)  of the definition of (++) will be used quadratically often. Note that the shape of the equation is the same if you ignore the lambda abstraction in Step a c >>= g = Step a (\x -> c x >>= g), and replace Step by (:) and (>>=) by (++).
18:05:53 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
18:09:04 <ambro718> int-e: would that be solved by just writing it as f n = Step (f (n - 1)) (\x -> some_action)
18:11:25 <ambro718> oh wait that's not possible, Step cannot take Program
18:35:10 <unyu> Can anonymous functions have where clauses?
18:35:43 <Vulfe> you can use where clauses inside lambda expressions if that's what you mean
18:36:14 <lyxia> > \x -> y where y = x + 1
18:36:17 <lambdabot>  <hint>:1:9: error: parse error on input ‘where’
18:36:23 <lyxia> nope?
18:37:11 <Vulfe> interesting; i have code sitting in front of me that has a where clause inside a lambda expression
18:37:15 <Vulfe> (and it works)
18:38:09 <lyxia> Vulfe: can you show it
18:38:11 <Vulfe> how about like...
18:38:13 <MarcelineVQ> you can attach where to case expressions anywhere you like
18:38:25 <Vulfe> that's what I did
18:38:27 <MarcelineVQ> > (\x -> case x of _ -> h where h = 3) 12
18:38:29 <Vulfe> thus the source of the confusion
18:38:29 <lambdabot>  3
18:38:30 <zachk> use a let blah in f blah in the lambda
18:38:46 <EvanR> unyu: where is attached to clauses not expressions
18:38:48 <lyxia> > (\case x -> y where y = x + 1) 11
18:38:50 <lambdabot>  12
18:39:01 <EvanR> like case cases and function definition equations
18:39:54 <EvanR> though i see, "half a lambda" would not be mistaken for an expression anyway
18:42:11 <danilo2> Hi! If I want to use State in my TH then I have to lift the Q monad to some `m` (justl ike liftIO). Should I use `runQ` for that?
18:44:20 <lyxia> I don't see how runQ is related to liftIO. Are you perhaps looking for MonadBase?
18:45:38 <unyu> EvanR: Oh, dang.
18:45:50 <lyxia> danilo2: Or, use  StateT s Q  and lift explicitly
18:49:38 <danilo2> lyxia: oh, MonadBase could do the trick
18:49:47 <danilo2> lyxia: Im super against using explicite lift
18:49:56 <danilo2> lyxia: in any situation
18:52:17 <danilo2> lyxia: hmm, as far as I see the Q monad is nto instance of either MonadBase nor MonadPrim :/
18:54:14 <danilo2> lyxia: `runQ :: Quasi m => Q a -> m a` , runQ could theoretically do the trick, becasue you could `runQ :: Q a -> StateT s Q a`, but ugh, id like something implemented rather than reinventing it
18:58:10 <exio4> EvanR: "case cases" makes it sound like a case expression would have where clauses
19:01:36 <lyxia> danilo2: it's easy enough to just write   instance MonadBase Q Q
19:03:58 <danilo2> lyxia: I rather need lifting from stateT to base (Q), but yeah its possible. Im just wondering why anyone didnt wanted it earlier, hmm
19:08:59 <lyxia> It's quite a strange thing to want
19:09:57 <lyxia> 99% of the time you can get away by querying the environment once and do the rest of the computation purely.
19:14:23 <danilo2> lyxia: right, thats a good reason. In fact im using this state in a simple, small function - traversing types and gathering some data , while needing Q to generate new names. Cool, thank you!
19:15:17 <lyxia> you're welcome!
19:19:05 <byorgey> koz_: yes, it does.  Otherwise there would be no way to pick uniformly; you have to know the length to know with what probability to pick each element
19:20:46 <koz_> byorgey: OK, thanks. Figured as much, but figured it best to check.
20:25:58 <EvanR> http://lpaste.net/124571
20:35:07 <EvanR> so when i search google for haskell cocoa, and thing 4 or 5 is my shitty youtube video which isnt really that, that seems bad
20:48:31 <EvanR> it seems that between 2011 and now, people distributed consensed that GUIs should be browsers
20:48:53 <EvanR> and tried to forget about "native" desktop
20:49:09 <EvanR> at least in haskell
20:50:34 <ertes> can you blame them?
20:50:51 <systemfault> The alternative is what... Qt?
20:51:04 <systemfault> Way easier to find web devs than Qt devs.
20:52:18 <ertes> well, GUIs are really easy in haskell…  as long as you ignore windows
20:54:07 <EvanR> they are?
20:54:40 <ertes> more seriously there are a number of advantages of web UIs:  they are simpler to program, responsive by default, cross-platform, multi-user, etc.
20:54:59 <EvanR> i am not really complaining
20:55:23 <EvanR> but i went to see what the state of cocoa support is, and its not great
20:55:51 <systemfault> ertes: Yup, while a bunch of people complain about Electron apps taking a lot of memory... companies save a lot of time by using web techs to write their app UI.
20:55:52 <EvanR> why would you want cocoa support? because you want a mac front end that the browser platforms dont exactly match
20:56:02 <ertes> in fact they are probably the most realistic way to get haskell programs onto phones and tablets
20:56:19 <EvanR> native phone programs is another story
20:56:28 <EvanR> they are going to work better than a browser
20:57:53 <EvanR> then i become frustrated, see "who needs a GUI anyway" as a way out, and the cycle is complete
20:58:31 * EvanR sinks back into the inert haskell enthusiast blob
20:58:43 <ertes> my last UI job was about two years ago, and i considered two choices:  1. make a native UI and hope i can somehow compile it for windows, and it will work on a real windows as opposed to my WINE
20:58:52 <ertes> 2. use snap
20:58:55 <ertes> i chose the latter
20:59:42 <EvanR> when theres a deadline and pointy haired boss, that probably makes sense. it might also make sense in that scenario to do something just really bad, because look at everything else
21:00:04 <ertes> even as an enthusiast i would have chosen the latter
21:00:08 <EvanR> i am more concerned when its a personal program where you care about the user experience on each platform, from their perspective
21:00:29 <EvanR> where you know that "GTK is god" will not fly
21:00:42 <EvanR> also, phones
21:02:14 <ertes> i think the last GUI i wrote for myself was in QBASIC…  to help with my homework, when i was fascinated by the very idea of interacting with my own program =)
21:04:02 <EvanR> theres a schism going on, UI/UX people are all working in a browser. other people are working in an ssh session
21:04:29 <EvanR> a priestly cast are reinventing opengl again
21:04:32 <ertes> and then there is SAP
21:04:50 <EvanR> nothing to fill the gap
21:05:22 <EvanR> SAP?
21:06:54 <ertes> EvanR: if you have to ask what that is, i envy you
21:07:13 <EvanR> ive been under a rock for a while
21:07:37 <ertes> it might be a german thing, but in any case it's the worst disaster that has happened to companies since enterprise bullshit became a thing
21:09:10 <EvanR> ah one of those, of course
21:09:24 <ertes> yeah, the java of ERP
21:10:25 <koz_> What's the difference between Hedgehog and QuickCheck?
21:12:48 <ertes> koz_: if you're already familiar with QuickCheck the README of hedgehog should make sense to you
21:13:07 <ertes> koz_: and if not, flip a coin
21:13:16 <koz_> ertes: It looks really similar, which is why I'm asking.
21:15:02 <ertes> koz_: again, the README has a feature list
21:15:57 <EvanR> > random (mkStdGen 7) :: (Bool, StdGen) -- this is probably going to be True...
21:16:00 <lambdabot>  (True,320112 40692)
21:16:03 <EvanR> yeah...
21:16:15 <EvanR> > random (mkStdGen 41) :: (Bool, StdGen) -- this is probably going to be True...
21:16:17 <lambdabot>  (True,1680588 40692)
21:16:20 <EvanR> stupid coin :)
21:17:17 <EvanR> dont use that command for superbowl overtime
21:22:33 <koz_> Does Edward like, generate libraries in his sleep or something?
21:22:43 <koz_> Every second thing I find on Stackage seems to be by him.
21:26:31 <EvanR> he spend 12 years in the himalayas using C++. when explorers found him, brought him to the land of haskell it was like losing 1000 lb weights
21:27:25 <koz_> Does he now run extremely-unorthodox training programs for 14 year olds seeking to be the best Haskellers in the world?
21:28:07 <EvanR> i hear theres a hyperbolic time chamber involved
21:28:14 <koz_> Or does he just pretend to own a shop as a cover for being a secret mentor to 14 year olds seeking to save the world with Haskell powers?
21:29:00 <EvanR> lets just say its the plot of black panther, whatever it may be
21:29:02 * koz_ now has a mental image of paper talismans with things like the type of confusing written on them.
21:29:11 <systemfault> Did he manage to master Ultra Instinct?
21:29:27 <koz_> :t confusing
21:29:29 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
21:30:22 <ertes> if haskell and go had their names flipped, edward would be a 9-dan pro
21:31:11 <ertes> also haskell would be a terrible language
21:31:28 <koz_> ertes: I see what you did there.
21:39:02 <EvanR> the StdGen implementation is quite mysterious
21:39:50 <ertes> EvanR: what do you find mysterious about it?
21:40:03 <EvanR> besides the word all caps MYSTERY in the comments...
21:41:02 <EvanR> the Int seed is heavily wrapped to a Int32, then number less than like 53668 result in a generator that spends a lot of time with even output
21:41:37 <EvanR> and the claim is that its splittable... proof?
21:42:53 <EvanR> "If we cannot unravel the StdGen from a string, create one based on the string given." eh?
21:43:48 <EvanR> pertaining to the Read instance... that seems a bit wacky
21:46:32 <ertes> well, the obvious answer is: don't use StdGen =)
21:46:40 <ertes> it's almost never a good PRNG
21:47:49 <EvanR> this is the great thing about standard generators?
21:48:42 <EvanR> are linear congruential generators standard in languages to scare you into researching other ones, and then to use them at your own risk
21:49:57 <ertes> yeah, somehow the state of PRNGs in haskell is as bad as in most other languages
21:50:04 <ertes> in certain ways it's even worse
21:50:23 <ertes> the most common crypto library in hackage exclusively seeds from RDRAND
21:50:39 <ertes> yes, exclusively…  it doesn't use /dev/*random, getrandom or any other OS facility
21:51:06 <redrapscallion> what's the deal with Haskell's empty lists? they don't seem to be working as I would expect.
21:51:12 <ertes> (you can change it, but that requires changing client code)
21:51:29 <redrapscallion> 2 : [] gives me [2], but [2] : [] gives me [[2]] which is bizarre
21:51:29 <ertes> redrapscallion: what's the issue?
21:51:32 <redrapscallion> > :t (:)
21:51:34 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
21:51:49 <ertes> redrapscallion: (x : xs) is the list with the element 'x' prepended to the list 'xs'
21:51:58 <redrapscallion> well, (:) :: a -> [a] -> [a]
21:51:59 <ertes> redrapscallion: in your case x = [2], which is a list
21:52:17 <ertes> so xs must be a list of lists, and therefore the result must be a list of lists
21:52:37 <EvanR> [2] is sugar for 2:[]
21:52:56 <EvanR> so [[2]] is sugar for [2]:[] is sugar for (2:[]):[]
21:53:03 <ab9rf> mmm, sugary
21:53:09 <EvanR> you just discovered all this backwards
21:54:50 <ertes> :t (:)
21:54:51 <lambdabot> a -> [a] -> [a]
21:54:55 <ertes> :t (:) [2]
21:54:57 <lambdabot> Num a => [[a]] -> [[a]]
21:55:08 <ab9rf> i suppose the behavior of : was obvious to me because i know lisp :)
21:55:51 <ertes> @let asAppliedTo :: (a -> b) -> a -> a -> b; asAppliedTo f _ = f
21:55:52 <EvanR> but isnt cons symmetric in lisp
21:55:53 <lambdabot>  .L.hs:171:1: error:
21:55:53 <lambdabot>      Duplicate type signatures for ‘asAppliedTo’
21:55:53 <lambdabot>      at .L.hs:154:1-11
21:56:00 <ab9rf> EvanR: no
21:56:02 <ertes> oh, that one exists?!
21:56:09 <MarcelineVQ> ertes: yas
21:56:11 <EvanR> i thought a cons cell was just a pair
21:56:16 <ertes> :t (:) `asAppliedTo` [2]
21:56:17 <lambdabot> Num a => [a] -> [[a]] -> [[a]]
21:56:31 <ertes> redrapscallion: ^
21:56:54 <ab9rf> EvanR: (cons '(1) '(2)) is ((1) 2)
21:57:15 <EvanR> what is (cons 'x 'y)
21:57:21 <ertes> EvanR: in haskell a cons is also just a pair
21:57:21 <ab9rf> EvanR: (x . y)
21:57:33 <ertes> EvanR: the same way it is in lisp, except we don't have special syntax for it
21:57:41 <EvanR> i dont understand (x . y)
21:57:48 <ab9rf> EvanR: it's a "dotted pair"
21:57:50 <ertes> EvanR: read "." as ":"
21:57:57 <EvanR> heh...
21:57:57 <redrapscallion> I'm still not sure about how the sugaring makes the (:) arguments match up properly
21:58:02 <ab9rf> EvanR: for the case when the second pair is not a cons cell
21:58:15 <EvanR> what :(
21:58:19 <EvanR> too magic
21:58:32 <ertes> EvanR: it's just tuples…  lisp is not statically typed
21:58:39 <redrapscallion> EvanR: I can see that when you apply it, it's true, but the logic isn't clicking
21:58:42 <ab9rf> EvanR: lisp allows for the cdr of a cons cell to be any sexp
21:58:46 <ertes> EvanR: so they use tuples as lists
21:58:59 <EvanR> all this is consistent with what i said
21:59:02 <ertes> with a special end marker (nil)
21:59:26 <ertes> redrapscallion: do you understand partial application?
21:59:33 <redrapscallion> ertes: yeah
21:59:53 <ertes> redrapscallion: ok, when you apply (:) to the first argument, you make a specific choice for the type 'a'
21:59:57 <ertes> redrapscallion:
22:00:00 <ertes> :t (:)
22:00:02 <lambdabot> a -> [a] -> [a]
22:00:09 <ertes> redrapscallion: what choice do you make for 'a'?
22:00:18 <ertes> …  given the first argument [2]
22:00:39 <ertes> redrapscallion: (feel free to assume (2 :: Integer))
22:00:52 <redrapscallion> ertes: a list of integers, then
22:01:02 <ertes> redrapscallion: so (a = [Integer])?
22:01:23 <redrapscallion> ertes: that should be right
22:01:31 <ertes> redrapscallion: so you use (:) at its instantiation ([Integer] -> [[Integer]] -> [[Integer]])?
22:01:53 <redrapscallion> ertes: that looks correct based on the type signature
22:02:07 <ertes> redrapscallion: so the expected result is a list of lists?
22:02:12 <V4> Could someone explain how this code (https://stackoverflow.com/a/20569505) works? It looks as if foldr is called with too many arguments.
22:02:19 <ggVGc> I feel Int should be what Integer is, and the current Int should be renamed to RawInt or something
22:02:20 <redrapscallion> ertes: yes, it has to be a list of list of integers
22:02:39 <ggVGc> I've had to train myself to never really use Int
22:02:52 <ggVGc> because it's practically never what I want
22:02:54 <ertes> V4: http://ertes.eu/tutorial/foldr.html#stateful-folds
22:03:01 <ab9rf> :t foldr --V4
22:03:02 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
22:03:04 <EvanR> ggVGc: agreed
22:03:10 <ggVGc> I think most people never really want Int in haskell
22:03:36 <EvanR> to appease the rest, tell them Integer is implemented as a sum of Int and GMP
22:03:42 <ertes> redrapscallion: so now if you reconsider that (:) prepends an element to a list of elements, and in this case an element is a list…
22:04:13 <ertes> redrapscallion: [2] : []  -- this is the element [2] prepended to the empty list of lists
22:04:29 <EvanR> V4: it looks like this is folding over a list of functions
22:04:32 <ertes> redrapscallion: so you get a one-element list-of-lists, namely containing the element [2]
22:04:46 <EvanR> so the result can be applied, thats your extra arg
22:04:48 <redrapscallion> ertes: but that's exactly where my understanding breaks down
22:04:59 <redrapscallion> ertes: which is how [] is a list of lists
22:05:01 <V4> oh wow, that's awesome
22:05:17 <ab9rf> V4: functions that return functions are very useful, but not always intuitive
22:05:27 <ertes> redrapscallion: [] is the empty list…  it can be a list of integers, a list of lists of integers, a list of functions, …
22:05:42 <V4> yea, I definitely agreed with what the guy said, explicit recursion is a lot more clear imo
22:05:45 <V4> for this problem anyway
22:06:04 <ertes> V4: the article i linked gives you a tutorial on stateful folds (a.k.a. folds that return functions)
22:06:39 <V4> It seemed like a useful resource, I'll be sure to read over it
22:06:42 <EvanR> this fold is atrocious
22:06:44 <redrapscallion> ertes: so if I understand correctly, then an empty list is coerced into a specific type when you use it in a function?
22:07:05 <EvanR> using a sentry Bool, in a confusing way
22:07:09 <ab9rf> V4: it's more useful when the state function is more transformative n some way
22:07:22 <ab9rf> redrapscallion: it's not a coercion
22:07:59 <ertes> redrapscallion: one way to think about it is that [] is not *the* empty list…  it's a family of empty lists, one for each element type
22:08:02 <EvanR> [] is a polymorphic "constant". it can have the type [A], [[A]], [[[A]]], ...
22:08:09 <ertes> redrapscallion: which one it is depends on the context
22:08:13 <ab9rf> the empty list has polymorphic type; the compiler will choose the type instance that matches in the context
22:08:32 <ertes> redrapscallion: much like 'id' is not *the* identity function, but an infinite family of identity functions, one for each argument type
22:08:33 <ertes> :t id
22:08:35 <lambdabot> a -> a
22:08:58 <EvanR> of course, all id and all the [] are really the same thing
22:09:32 <ab9rf> but you can have polymorphic vales that are "more complicated" than id or []
22:09:34 <ab9rf> values
22:09:43 <EvanR> polymorphic whales
22:09:56 <ab9rf> (may also be a bowl of petunias)
22:13:02 <redrapscallion> ah okay, I see now.
22:14:11 <redrapscallion> ertes: do you know where I might find the source code for that implementation? I'm curious to see how it's implemented
22:14:27 <ertes> redrapscallion: implementation of what?
22:14:55 <ertes> redrapscallion: the list type is defined like this:  data [a] = [] | a : [a]
22:15:24 <EvanR> kind of amazing
22:15:32 <redrapscallion> ertes: what. it's really just that short?
22:15:36 <ertes> redrapscallion: it uses some special built-in syntax, but is otherwise just a regular type definition…  here is an equivalent way to define it (you can do it in your own module to experiment with it):
22:15:46 <ertes> redrapscallion: data List a = Nil | Cons a (List a)
22:15:54 <ertes> redrapscallion: yeah
22:16:08 <koz_> Algebraic data types are magic. Like friendship.
22:16:18 <ertes> redrapscallion: with List lists look like this:  Cons 1 (Cons 2 (Cons 3 Nil))
22:16:34 <ertes> which corresponds to (1 : (2 : (3 : []))), or [1,2,3]
22:16:58 <ertes> and your [[2]] list looks like this:  Cons (Cons 2 Nil) Nil
22:17:06 <EvanR> constructors that begin with : are infix
22:17:20 <EvanR> > sqrt (1 :+ 1)
22:17:22 <lambdabot>  1.09868411346781 :+ 0.45508986056222733
22:17:40 <EvanR> the list type trolls us by being only a :
22:18:28 <EvanR> the Rational type trolls us by not exporting :%
22:19:56 <ertes> redrapscallion: BTW, many types you would normally consider primitive are actually defined in the base library
22:20:02 <ertes> data Bool = False | True
22:21:00 <redrapscallion> ertes: hmm so if I got this correctly
22:21:09 <EvanR> data Int = I# Int#
22:21:17 <redrapscallion> ertes: you need a list to define a list, and because of that requirement, every list needs to have Nil in it?
22:21:38 <ertes> redrapscallion: almost…  haskell actually doesn't mind infinite lists
22:21:47 <ertes> @let ones = 1 : ones
22:21:49 <lambdabot>  Defined.
22:21:50 <ertes> > ones
22:21:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:22:00 <EvanR> > 1:1:1:1:ones
22:22:02 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:22:06 <EvanR> mines longer
22:22:15 <koz_> EvanR: Hurr hurr.
22:22:37 <ertes> EvanR: nah, same order type…  you should have appended at the end
22:22:48 * EvanR demands to see the heap
22:24:25 <EvanR> redrapscallion: in a language with controlled recursion, yeah you could see that as a way to require your list end with a Nil
22:24:32 <redrapscallion> ertes: well, the natural follow up question is how does Haskell even make an infinite list?
22:24:39 <EvanR> i.e. it would be an inductive type
22:24:45 <koz_> redrapscallion: You don't ever materialize the whole thing.
22:25:04 <koz_> Or you do what ertes did, which is called 'tying the knot'.
22:25:14 <redrapscallion> if I were to go from [1..1000], I'd have to start with Nil and then do Cons ... (Cons 1000 Nil) Nil
22:25:27 <ertes> redrapscallion: you see the definition of 'ones' above…  if you pattern-match on 'ones':  case ones of (x : xs) -> _c;  [] -> _n
22:25:29 <koz_> redrapscallion: Haskell's lazy.
22:25:35 <ertes> redrapscallion: do you get the (:) case or the [] case?
22:25:45 <koz_> You don't do the whole of [1..1000] all at once - you do it on demand.
22:25:47 <EvanR> no, you start with a (1 : ...)
22:26:09 <redrapscallion> oh wait, EvanR is right
22:26:17 <redrapscallion> I have my order inverted
22:26:29 <EvanR> ... = 2 : ....
22:26:55 <EvanR> if you do it right, only one list element may exist at a time
22:27:20 <EvanR> and you impress your friends and family with the memory your program doesnt use
22:27:45 <redrapscallion> ertes: I got it. It's just that recursive algebraic data types are a bit mind-bending to me.
22:28:17 <ertes> redrapscallion: ^ answer the question anyway…  it will become a lot clearer
22:28:17 <koz_> redrapscallion: It's quite fun once you get adjusted, but not many languages have them, so people tend to be a bit confused at first.
22:28:53 <ertes> redrapscallion: given (ones = 1 : ones), if you pattern-match on 'ones' do you get (x : xs) or []?
22:28:59 <EvanR> many languages have 1 algebraic data type
22:29:31 <EvanR> data V = N Double | S String | A [V] | O (HashMap String V) | Null | ...
22:29:38 <koz_> Oh, the Dynamic type.
22:29:47 <koz_> Except you can't really pattern match on it.
22:29:58 <EvanR> i try my darndest...
22:29:59 <redrapscallion> ertes: huh. it should be (x:xs)
22:30:08 <ertes> redrapscallion: correct, and x = ?
22:30:27 <EvanR> koz_: i wrote an eliminator in js at least
22:30:28 <redrapscallion> ertes: x would be 1. xs would be the rest of the infinite chains of 1's
22:30:39 <ertes> redrapscallion: stop using the word "infinite"
22:30:46 <ertes> redrapscallion: just read the definition of 'ones' literally
22:30:49 <ertes> x = 1, xs = ?
22:31:03 <redrapscallion> ertes: xs = ones
22:31:20 <EvanR> yes it prefers to be called "finitly-challenged"
22:31:26 <ertes> redrapscallion: exactly…  your brain didn't go into an infinite loop to do that, and neither does GHC =)
22:31:51 <ertes> redrapscallion: "infinite list" is just an interpretation…  this is really just definitions and pattern-matching interacting in a natural way
22:33:03 <EvanR> in some cases the infiniteness does cause problems when you mishandle it, and it consumes all memory
22:33:03 <redrapscallion> ertes: that'll definitely take some rewiring for me to get used to
22:34:06 <redrapscallion> ertes: wait a second, now I've got another problem
22:34:15 <redrapscallion> ertes: when you define ones = 1 : ones
22:34:21 <EvanR> haskell programmers must pass a 6 hour hazardous carnalities training course before be allowed to touch production code
22:34:22 <redrapscallion> ertes: what the hell does "ones" equal on the first pass?
22:34:37 <redrapscallion> ertes: since it doesn't exist until you define it, but you're calling ones in the definition of ones
22:34:49 <EvanR> er, cardinalities
22:35:22 <ertes> redrapscallion: (ones = 1 : ones) is just a definition…  definitions are only relevant when paired with (direct or indirect) pattern-matching
22:35:39 <ertes> redrapscallion: in other words: if you never pattern-match on something, it's meaningless/irrelevant
22:36:17 <EvanR> its a recursive equation, which you can comprehend using domains. "on the first pass"... ones = ⊥. then ones = 1 : ⊥. then ones = 1 : 1 : ⊥
22:37:05 <EvanR> whoever invented this did not consider it to be entirely obvious either
22:37:27 <EvanR> for another take on it, look at the recursive let in scheme, which does something different
22:37:42 <ertes> redrapscallion: the moment you ask for a specific part of a definition by pattern-matching on it, evaluation occurs, and the value actually manifests in memory – but only as far as you pattern-matched
22:38:46 <EvanR> x = x + 1 would go... x = ⊥, then x = ⊥ + 1 = ⊥, so ⊥ is the final answer
22:39:03 <EvanR> since + is too strict to be useful
22:39:35 <redrapscallion> ertes: so GHC sees that "ones" is being called, and because it has to be a list (and its value is nothing), it just knows it should be an empty list?
22:39:50 <redrapscallion> ertes: at least, it's value is nothing on the first pass
22:39:51 <EvanR> ones has nothing to do with empty list
22:40:03 <EvanR> its 1 : ones on the first pass
22:40:04 <ertes> redrapscallion: 'ones' is not empty
22:40:15 <ertes> redrapscallion: empty lists are of the form [], but 'ones' is of the form (x : xs)
22:40:29 <ertes> with x = 1 and xs = ones
22:41:13 <ertes> redrapscallion: 'ones' is not a function or procedure…  it's a mathematical definition – an equation
22:41:29 <EvanR> ones... is... 1 : ones :)
22:41:41 <redrapscallion> ertes: ah, wait, so "ones" isn't actually evaluated? it's just passed as an expression then?
22:42:10 <ertes> redrapscallion: your thinking is highly operational…  step back from that a bit and try to think mathemtically/symbolically
22:42:15 <EvanR> > let ones = 1 : ones in "cool"
22:42:17 <lambdabot>  "cool"
22:42:27 <EvanR> not evaluated there... no
22:42:33 <ertes> redrapscallion: again, if you pattern-match on 'ones', do you get (x : xs) or []?
22:43:14 <ertes> redrapscallion: you went through a logical, symbolical process to get to this conclusion, and GHC does exactly the same thing, except using CPU instructions instead of neural activity
22:43:49 <EvanR> redrapscallion: at the level you were just discussing, ones is not an expression. its a list
22:44:03 <EvanR> a non-empty one, by definition
22:44:30 <EvanR> it may or may not be evaluated depending on how you use it
22:45:40 <EvanR> and the only way anything could evaluate it is a pattern matching somewhere, and you know how that will work
22:46:06 <redrapscallion> oh, I see, so GHC will just keep replacing "ones" with the definition of "ones", which means (1 : ones) turns into (1 : (1 : ones)) and then (1 : (1 : (1 : ones))) and so on
22:46:30 <EvanR> if something asked to see the first three elements, then yes
22:46:38 <V4> I also don't quite understand how recursive list definitions like that work, for example, why does "a = 1 : map (+1) a" evaluate to 1, 2, 3 ... and not 1, 2, 2, 3, 2, 3, 3, 4... etc.
22:46:39 <ertes> redrapscallion: it's actually you doing that by writing definitions that do it
22:46:45 <EvanR> like let (a:b:c:_) = ones in ....
22:47:33 <EvanR> > let a = 1 : map (+1) a in a
22:47:35 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:47:50 <EvanR> V4: you could try my ⊥ analysis here and see
22:48:06 <V4> alright, what exactly is the procedure?
22:48:16 <EvanR> begin with the worst approximation of what a is
22:48:19 <EvanR> a = ⊥
22:48:26 <redrapscallion> ertes: huh. it's so painfully obvious now, I'm not sure how I didn't see it before
22:48:42 <EvanR> then improve the approximation by using the RHS and fill in the previous approximation of a
22:48:47 <EvanR> then repeat
22:49:32 <ertes> redrapscallion: you might have stepped into a metaphorical infinite metaphor hole, and we managed to pull you out of it =)
22:50:06 <V4> alright, so then a = 1:⊥, a = 1:map (+1) [1:⊥], so a = 1:2:⊥, a = 1:2: map (+1) [1:2:⊥]
22:50:10 <V4> but that last part is wrong
22:50:42 <V4> or maybe all of it haha
22:51:10 <ertes> V4: 1 : map (+1) a = 1 : map (+1) (1 : map (+1) a) = 1 : 2 : map (+1) (map (+1) a)
22:51:17 <ertes> V4: you see how the maps cascade
22:51:29 <EvanR> yes you need to keep the maps in the picture
22:51:39 <ertes> map (+1) (map (+1) a) = map ((+1) . (+1)) a  -- functor law
22:52:20 <V4> keep in mind I'm pretty fresh to haskell, I haven't gone over functors yet
22:52:24 <jchia_> Does anyone know the status of OverloadedRecordFields? Is anybody working on it?
22:52:38 <koz_> V4: I recommend you read the Typeclassopedia, then.
22:52:42 <koz_> And then read it again.
22:52:44 <koz_> And then one more time.
22:52:47 <ertes> V4: then ignore the "functor" part…  this is just a really simple way to rewrite cascading maps to non-cascading ones
22:52:58 <koz_> And then just keep reading it until you reach the fixed point of understanding the Typeclassopedia. :P
22:53:08 <ertes> V4: map f (map g xs) = map (f . g) xs  -- this is a law
22:53:14 <ertes> for all f, g, xs
22:53:23 <EvanR> haha
22:53:33 <EvanR> on the first read of typeclassopedia it will look like ⊥
22:53:35 <V4> oh yea, that makes sense
22:53:46 <koz_> EvanR: LOL
22:54:09 <EvanR> then itll be just the section titles and each body is ⊥
22:54:32 <ertes> and then your brain overflows
22:54:50 <V4> just glancing over some of it, yea
22:54:54 <redrapscallion> honestly, the typeclassopedia article is stupidly long
22:55:02 <koz_> redrapscallion: It's worth every word.
22:55:23 <koz_> You don't need to read the whole thing - some of the sections are fairly specific - but the functor, applicative and monad sections are _very_ helpful.
22:55:27 <koz_> The exercises too.
22:55:53 <EvanR> when you get to profunctors, you have to watch that video by that guy
22:56:09 <koz_> EvanR: Did Edward do a profunctor vid?
22:56:14 <koz_> Or was it the Australian guy?
22:56:25 <EvanR> the not ed guy
22:56:26 <koz_> (George I think his name was)
22:56:33 <koz_> Lol, there are lots of not Ed guys.
22:56:42 <koz_> There are also lots of not Edd guys, and lots of not Eddy guys.
22:57:07 <EvanR> The Extended Functor Family
22:57:31 <EvanR> George Wilson
22:57:50 <redrapscallion> tbh, functors and monads made 0 sense to me until I started doing exercises and problems with them
22:57:59 <EvanR> me too
22:58:00 <redrapscallion> it feels like one of those things that you can't really learn by just reading
22:58:08 <koz_> I would agree with that.
22:58:26 <redrapscallion> like the only way I even remotely learned how monads worked was by doing this nifty github challenge thing : http://mightybyte.github.io/monad-challenges/
22:58:33 <redrapscallion> and that took forever and a half
22:58:45 <EvanR> stupid monad tricks
22:59:04 <ertes> stupid monad tricks?
22:59:12 <EvanR> should be the name of a challenge
22:59:18 <ertes> > filterM (const [False, True]) "abc"
22:59:21 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
22:59:32 <EvanR> heh
22:59:35 <koz_> ertes: Wait, powerset?
22:59:42 <redrapscallion> I don't even want to know why that works.
22:59:56 <ertes> koz_: yeah
22:59:56 <EvanR> dont lie
23:00:05 <koz_> > filterM (const [False, True]) [1,2,3]
23:00:07 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
23:00:11 <ertes> redrapscallion: it's surprisingly simple
23:00:12 <koz_> Whoo powerset!
23:00:16 <EvanR> redrapscallion: list monad is one of the best monads
23:00:24 <koz_> It is pretty magical, yes.
23:00:32 <EvanR> best monads of the 80s, 90s
23:00:42 <koz_> I _think_ I see why that works, although I wouldn't have thought of it in a million years.
23:01:10 <redrapscallion> ertes: so how does it work?
23:02:29 <ertes> redrapscallion: you can interpret lists as non-deterministic values, right?
23:03:39 <ertes> as in: a list of integers is not one specific integer, but zero or more integers
23:04:05 <redrapscallion> ertes: how does that make it non-deterministic?
23:04:14 <koz_> redrapscallion: Consider a function a -> b.
23:04:19 <koz_> We know that it'll always '
23:04:24 <koz_> give back' exactly one b.
23:04:26 <ertes> redrapscallion: "non-deterministic" just means "not one specific value" in this context
23:04:41 <koz_> Whereas a function a -> [b] can give back any number of b's, including zero.
23:04:49 <koz_> So in a way, we're 'unsure' what the 'real' answer is.
23:04:55 <koz_> (in that it's equally any of them)
23:05:09 <redrapscallion> ertes: oh, then yes, okay. I always thought non-deterministic meant that if you had a function and passed in an argument "a", you'd always get the exact same "b" back.
23:05:25 <koz_> redrapscallion: That's 'deterministic'.
23:05:26 <EvanR> youll get exactly 1 answer, deterministic
23:05:32 <ertes> redrapscallion: now look at the instantiation of 'filterM' for lists:
23:05:33 <redrapscallion> opps, typo. *deterministic
23:05:44 <ertes> filterM :: (a -> [Bool]) -> [a] -> [[a]]
23:05:52 <EvanR> youll get a range of possible answers (perhaps empty), non deterministic
23:06:09 <ertes> redrapscallion: this is similar to 'filter', except you're allowed to choose a non-deterministic *predicate*
23:06:33 <ertes> redrapscallion: and as such you get a whole list of result lists, one for each possible outcome
23:06:50 <ertes> redrapscallion: if your predicate is deterministic, you get a single result:
23:07:00 <koz_> ertes: So in a manner of speaking, you're choosing to _simultaneously_ filter _and_ not filter every possible element?
23:07:04 <koz_> And collect all possibilities together?
23:07:05 <ertes> > filterM (\x -> [x > 3]) [1,2,3,4,5,6]
23:07:08 <lambdabot>  [[4,5,6]]
23:07:15 <ertes> > filter (\x -> x > 3) [1,2,3,4,5,6]
23:07:18 <lambdabot>  [4,5,6]
23:07:34 <ertes> but you can choose to make your predicate non-deterministic for *some* values:
23:07:53 <ertes> > filterM (\x -> if x == 3 then [False, True] else [True]) [1,2,3,4,5]
23:07:56 <lambdabot>  [[1,2,4,5],[1,2,3,4,5]]
23:08:19 <EvanR> every step in the filter process, the universe splits into the one where you kept this value, or dropped it, and continues (then repeat this split in both splits, and so on)
23:08:22 <ertes> now whenever the element is 3, the result contains it in one outcome, and doesn't contain it in the other
23:08:43 <ertes> or you can choose a non-deterministic predicate for all values:
23:08:54 <ertes> > filterM (\_ -> [False, True]) [1,2,3,4,5]
23:08:57 <lambdabot>  [[],[5],[4],[4,5],[3],[3,5],[3,4],[3,4,5],[2],[2,5],[2,4],[2,4,5],[2,3],[2,3...
23:09:18 <koz_> ertes: Thanks - that was actually really clever and instructive.
23:09:19 <ertes> now there is a branch for every single element, where it exists in one branch and doesn't exist in the other
23:09:26 <ertes> and that's exactly powerset
23:09:35 <ertes> (or really power-sequence)
23:09:45 <ertes> koz_: yeah
23:09:48 <koz_> ertes: Yeah, because it doesn't filter out duplicates in the original.
23:09:56 <koz_> Ideally, we'd have a Set monad, but unfortunately we don't.
23:10:06 <ertes> we do – through a detour =)
23:10:10 <EvanR> exercise for the reader... what happens if you ask for the set of all subsequences of an infinite sequence
23:10:16 <koz_> ertes: Is that the Oleg Kiselyov trick?
23:10:25 <koz_> Or something else I'm not aware of?
23:10:50 <ertes> @let newtype Collect a = Collect { runCollect :: forall b. (Monoid b) => (a -> b) -> b }
23:10:52 <lambdabot>  Defined.
23:11:01 <systemfault> @src filterM
23:11:01 <lambdabot> Source not found. My brain just exploded
23:12:28 <EvanR> filterM p        = foldr (\ x -> liftA2 (\ flg -> if flg then (x:) else id) (p x)) (pure [])
23:12:32 <ertes> :t \p -> foldr (\x xs -> do b <- p x; (if b then fmap (x :) else id) xs) (pure [])
23:12:34 <lambdabot> (Monad f, Foldable t) => (a -> f Bool) -> t a -> f [a]
23:13:00 <ertes> :t filterM
23:13:02 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
23:13:12 <ertes> oh, of course
23:13:44 <ertes> why is it still specialised to lists?
23:14:04 <EvanR> hysterical raisins?
23:14:06 <koz_> It can work over any Foldable?
23:14:19 <koz_> s/Foldable/Traversable/
23:14:35 <EvanR> oh
23:14:51 <EvanR> filtering is a thing that Foldable and Traversible cant handle
23:15:00 <koz_> That's what I suspected.
23:15:11 <EvanR> though, you could accept a foldable and output a list
23:15:17 <EvanR> but no one does that
23:15:19 <koz_> Also, is there a library that provides a Set monad (in the sense of non-determinism without duplicates) using some kind of hack?
23:16:08 <ertes> koz_: you can use Collect above, but you'll get list performance regardless
23:16:36 <koz_> ertes: Is there a way to _not_ get list performance for things which can be put into sets without having to hack it up manually each time?
23:17:01 <EvanR> this whole thing can be coded specially for Set
23:17:14 <koz_> EvanR: Has someone already done this and put it on Hackage?
23:17:16 <EvanR> then specially for HashSet
23:17:24 <EvanR> boring though :)
23:17:57 <cocreature> :t Data.Witherable.filterA
23:17:59 <lambdabot> error:
23:17:59 <lambdabot>     Not in scope: ‘Data.Witherable.filterA’
23:17:59 <lambdabot>     No module named ‘Data.Witherable’ is imported.
23:18:00 * hackage extensible-effects 2.5.1.2 - An Alternative to Monad Transformers  https://hackage.haskell.org/package/extensible-effects-2.5.1.2 (shergill)
23:18:02 <cocreature> meh
23:18:09 <cocreature> https://hackage.haskell.org/package/witherable-0.2/docs/Data-Witherable.html#v:filterA
23:18:22 <ertes> koz_: just use the Set API
23:18:23 <koz_> EvanR: You say it's boring, but I'd be quite interested to see that written up somewhere.
23:18:41 <EvanR> me too, i wonder if theres any performance improvement
23:19:01 <ertes> koz_: it offers an almost-monadic interface:  singleton, map, union
23:19:34 <koz_> ertes: Yeah, I know it has all the pieces, but the lack of things like do-notation and the inability to use all the stuff written for monads kinda sucks.
23:20:03 <EvanR> all the stuff is in Data.Set really
23:20:14 <ertes> koz_: you can probably make it monadic using some kan extension approach
23:20:26 <koz_> ertes: I would have already written it if I understood how.
23:20:27 <ertes> without losing performance that is
23:20:38 <koz_> I guess you hack up a free monad then interpret it in the context of something that can be stuffed into a Set.
23:20:44 <koz_> (with appropriate constraints)
23:20:46 <ertes> but you kinda have to do the opposite of what a kan-extension normally does…  you have to associate to the left
23:21:40 <EvanR> at some point there was talk of generalizing Category so you could do stuff like this
23:22:10 <ertes> in any case Monad is not a natural interface to do this
23:22:19 <koz_> What makes you say that?
23:22:51 <ertes> the fact that Set is not a monad and Collect is really just lists in disguise =)
23:23:10 <ertes> Monad is natural for lists
23:23:50 <koz_> Isn't Set not a monad purely because of the (implementation-driven) constraints on the types of what they can hold?
23:24:20 <EvanR> removing duplicates is really a thing that causes you to pass from intentional type theory to homotopy type theory, jump the shark a bit
23:25:33 <EvanR> koz_: yeah, thats the deal with Data.Set, i think youre thinking there is some other kind of Set
23:25:41 <EvanR> a magic kind
23:25:51 <koz_> I'm not thinking that - I'm fully aware you need that constraint.
23:25:59 <koz_> (whether it's Ord, or a combo of Eq and Hashable)
23:26:11 <koz_> (at the _very_ least you need Eq to even make uniqueness mean anything)
23:26:23 <EvanR> well, only because bishop said so
23:26:57 <koz_> I guess I'd just really like nondeterminism with duplicate filtering and all the nice monadic goodies.
23:27:03 <koz_> I guess a man can dream.
23:27:32 <EvanR> i like this one... the existence of a listing of a finite set without duplicates implies law of excluded middle :)
23:27:53 <koz_> EvanR: Wait what?
23:27:56 <EvanR> http://math.andrej.com/2009/09/07/constructive-stone-finite-sets/
23:29:22 <koz_> Oh that's really clever.
23:29:34 <dgryski> Bit of an odd question, but is this still the case https://news.ycombinator.com/item?id=9071965 ?
23:30:10 <koz_> dgryski: I don't understand what your question is.
23:30:15 <koz_> Is what still the case?
23:31:07 <dgryski> koz_: The description of the maintainer of https://github.com/bitemyapp/learnhaskell
23:31:26 <dgryski> Is that accurate or just some random HN complaint?
23:31:44 <EvanR> koz_: i think the post is supposed to be read in entirety, where you conclude "well duh, we need decidable equality". however i read it lazily and conclude, set theory simply just must have these duplicates lying around :)
23:31:49 <EvanR> like the list monad does
23:32:04 <koz_> EvanR: To be honest, set theory doesn't really care.
23:32:35 <koz_> It's not like they have to bother with things like 'is this actually doable on a computer at all' and 'can this be done before the world ends due to sun exploding'.
23:32:37 <EvanR> well... especially for finite sets, youd think theres some intuition you can use to not see duplicates
23:32:55 <EvanR> so now i see duplicate elements everywhere
23:33:50 <EvanR> on a computer, on paper whatever
23:33:57 <EvanR> chalk board
23:34:13 <koz_> EvanR: Uhhh, good five you I guess?
23:35:47 <EvanR> to not see duplicates, you have to assert something metaphysical... like... i guess the sort of idea that statements just are true or false by the virtue of being statements
23:35:58 <koz_> I have no issue with LEM.
23:36:00 <EvanR> where truth is an obvious thing
23:36:12 <EvanR> im just talking about truth now
23:36:16 <EvanR> heh
23:36:54 <koz_> I mean, it's easy to go off on philosophical tangents with regard to truth, but for me, my main goal is 'does this help me do something' or 'does this tell me something interesting'.
23:37:01 <EvanR> after doing enough formal stuff everything else sounds suspicious heh
23:37:02 <koz_> Amusingly, my current work leans on 3VL a bit.
23:37:23 <koz_> But I'm mostly in Kleene 3VL, where 'unknown' just swallows most things.
23:37:49 <EvanR> is that like true, false, file not found
23:38:02 <koz_> True, False, Unknown.
23:38:06 <EvanR> haha
23:38:11 <koz_> I like to think of it as true = 1, false = -1, unknown = 0.
23:38:18 <koz_> Not is arithmetic negation.
23:38:22 <koz_> And is min.
23:38:24 <koz_> Or is max.
23:38:42 <woodson> why do library documentation sucks so bad ?? I find myself always having a hard time trying to figure out how to use a library because one there arent any tutorial, two the tutorial is just not covering enough to get started ...
23:38:53 <koz_> You can define the others based on their propositional definitions (if a then b is 'not a or b' etc).
23:39:00 <koz_> woodson: Do you have a specific library in mind here?
23:39:10 <woodson> most xml libraries
23:39:13 <EvanR> so truth tables with an extra column
23:39:24 <woodson> execept for hxt
23:39:32 <woodson> which is a bit too large
23:39:32 <koz_> EvanR: I don't quite follow.
23:39:50 <EvanR> i expect most xml libs in haskell to be very unpopular, not really maintained
23:39:59 <EvanR> hxt is the only one i heard of being used
23:40:08 <koz_> Yeah - I think for structured data, people love the JSON round here.
23:40:12 <woodson> Well I trying to built a new project here
23:40:15 <koz_> Which is why Aeson is supposedly Very Good.
23:40:25 <woodson> just trying to find the info was a hassle
23:40:35 <woodson> cuz most libs dont give enough detail
23:40:40 <woodson> to gauge if i need it or not
23:40:43 <EvanR> koz_: like, boolean logic is defined through specifying the result for every combination of the two-valued args
23:40:49 <EvanR> in a "truth table"
23:40:51 <woodson> and now xml is killing me
23:41:13 <koz_> EvanR: Yeah, I get it, that wasn't my issue.
23:41:14 <EvanR> to get troolean logic you just need a third possibility, expanding tables
23:41:24 <koz_> Yeah, but that doesn't add 'one column'.
23:41:28 <koz_> Or 'an extra column'.
23:41:30 <EvanR> no?
23:41:39 <koz_> THink about the truth table for 'not a'.
23:41:44 <koz_> You don't have an extra column.
23:41:49 <EvanR> i maybe have meant, extra rows
23:41:51 <koz_> You just have 3 values, not 2.
23:41:55 <koz_> Yeah, extra rows, sure.
23:42:01 <koz_> That's what I was thrown by. :P
23:42:15 <koz_> (also, lol@'troolean')
23:42:21 <koz_> tr00 l0gik
23:42:36 <woodson> great.
23:42:37 <EvanR> falsean logic
23:42:47 <EvanR> just 1 value, false
23:42:59 <koz_> A 1VL would be... kind of strange.
23:43:04 <EvanR> lol
23:43:19 <koz_> woodson: It can be a bit hard to tell what libraries are useful or not.
23:43:39 <koz_> Almost makes me wanna make an awesome-haskell list full of things people actually use, but maintaining awesome-c is already enough work.
23:43:40 <EvanR> woodson: xml... why
23:43:48 <koz_> I too wish to know.
23:43:58 * koz_ plays X-Files theme.
23:44:08 <woodson> I mean.. its not my choice
23:44:20 <woodson> that what the platform uses to push metadata
23:44:34 <koz_> Then use HXT.
23:44:35 <EvanR> the truth is out there, relevant
23:45:04 <woodson> but I noticed now the more I get comfortable with haskell tackling tougher project is just much more harder due to lack of docs and more
23:45:11 <woodson> well I tried HXT
23:45:22 <woodson> but I could find info
23:45:29 <woodson> on how to use generics with it
23:45:49 <koz_> I'm not sure what you mean by 'use generics with it'. It might help if you told us what you were trying to do.
23:46:09 <woodson> since I am parsing a yaml file
23:46:26 <woodson> to by ADT I am already using generics to that
23:46:41 <koz_> And then you wanna dump that to XML?
23:46:42 <woodson> isnt there some kind of way to utilize that with any of these lib?
23:46:48 <woodson> yes
23:46:53 <woodson> and the other way around
23:46:56 <koz_> Then I'm not sure what you need HXT for.
23:47:09 <koz_> Just use one of the innumerable 'turn tree of stuff into other stuff' libraries Haskell has floating around.
23:47:13 <EvanR> im not sure what the generics is doing with the yaml. you have many ADTs ?
23:47:26 <woodson> because I still need to adjust it before dumping it to xml
23:47:31 <woodson> i cant just dump like that
23:47:38 <koz_> Then why not adjust the ADT directly?
23:47:52 <koz_> I'm not sure why you have to work with XML as anything but a back-end to dump stuff to.
23:48:02 <EvanR> yaml loads into haskell as json (...?), modify the json, then dump that to XML
23:48:18 <koz_> EvanR: s/json/ADT of whatever kind/
23:48:21 <koz_> g
23:48:33 <EvanR> well, which is by default aeson Value
23:49:06 <woodson> what about the other way around
23:49:13 <woodson> I need to parse the xml to yaml
23:49:16 <EvanR> normally id say wtf, but in this case we get to use json yaml and xml all at once
23:49:19 <EvanR> in haskell
23:49:23 <EvanR> drops the mic
23:49:48 <woodson> and some of the field are not all matching I add to override them using the fieldLabelModifier from aeson
23:49:57 <koz_> woodson: At that point HXT might be what you need, but if you're just writing a compiler (which is essentially what you're doing) you're gonna need to go 'in format -> ADT -> out format', and I'm not sure in how far HXT will help there.
23:50:31 <woodson> koz_ this is exactly what I trying to do
23:50:40 <woodson> I already got the yaml -> ADT part
23:50:50 <koz_> So are you trying to do ADT -> XML now?
23:50:59 <woodson> exactly
23:50:59 <EvanR> just 1 ADT
23:51:00 <koz_> Or ADT -> twiddled ADT?
23:51:14 <koz_> Because you mentioned you need to make some adjustments to the ADT before you emit XML.
23:51:15 <EvanR> then why are generics even involved
23:51:21 <koz_> I was also going to ask.
23:51:48 <woodson> yes, because the when I am going to read in xml to adt
23:51:57 <woodson> I dont want to have to parse
23:52:04 <woodson> why not make use of aeson?
23:52:10 <woodson> that uses generics ?
23:52:14 <koz_> Uhhh....
23:52:19 <woodson> or I am asking the question wrong?
23:52:25 <koz_> I'm not sure why you drew that conclusion, but generics != parsing.
23:52:37 <koz_> The fact that the YAML library you're using _happens_ to do it that way is coincidental.
23:52:41 <EvanR> generics is when you have many ADTs and operations that work on them all
23:53:24 <koz_> It lets you, for example, easily define hashing for arbitrary ADTs.
23:53:43 <koz_> Derive Generic, and hey-presto, your thing of hashable things is now itself hashable without you having to lift a tentacle.
23:54:03 <woodson> is that what aeson does under the hood?
23:54:12 <koz_> I believe it does that yes.
23:54:19 <koz_> Although I dunno exactly.
23:54:24 <EvanR> aeson can do stuff with generics
23:54:34 <woodson> well this is what I want to make use of with the xml library
23:54:40 <EvanR> but the basic API is FromJSON, ToJSON
23:54:48 <koz_> woodson: It's not written with that.
23:54:49 <woodson> and just use the fieldLabelModfier
23:54:53 <koz_> HXT predates GHC generics.
23:54:55 <woodson> to make adjustment
23:55:30 <EvanR> well i still dont get why generics is involved
23:55:36 <woodson> right now Im looking at this https://hackage.haskell.org/package/hexpat-pickle-generic-0.1.2/docs/Text-XML-Expat-Pickle-Generic.html
23:55:50 <koz_> woodson: What's the intermediate ADT you're working with?
23:55:50 <woodson> but its not even at version 1.0
23:56:13 <koz_> woodson: That's a serializer. What you're doing is not serialization.
23:56:28 <koz_> At least based on everything you've told us so far.
23:57:28 <woodson> hold putting an lpaste together
23:57:36 <EvanR> i thought task 1 was serializing to xml to post to a service
23:57:56 <woodson> EvanR: yes
23:58:12 <EvanR> then hypothetically just implement IsXML there
23:58:18 <EvanR> dont need generics
23:58:47 <EvanR> or the equivalent in HXT
