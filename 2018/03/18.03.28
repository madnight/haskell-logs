00:03:51 <xandaros> They feel like functions that should be in base to me... but I think that about a lot of things
00:07:55 <jchia> aeson encoding question: What is Encoding, on a high level, and when do I need to use it for making a JSON string? It seems that it's enough to just use Value. It seems that using Encoding (defining toEncoding instead of toJSON) directly is faster, according to the haddock. Otherwise, aeson converts to Value and then to Encoding using toEncoding.
00:08:42 <jchia> So, does that mean that if I want speed, I should avoid producing Value values, e.g. by using functions like object, which produce Value?
00:11:29 * hackage hierarchy 0.3.1.3 - Pipes-based library for predicated traversal of generated trees  https://hackage.haskell.org/package/hierarchy-0.3.1.3 (dnadales)
00:17:11 <geekosaur> with Encoding you're creating the JSON representation of a value of your type directly (conversely, decoding JSON directly to a value of your type) instead of using aeson's built-in mechanisms
00:18:06 <geekosaur> so yes, it's "faster" but you have to do all the work yourself. and you'd want to do most of it by calling aeson functions anyway unless you really want to rewrite large chunks of aeson in your own code, so not clear you;d gain that much aside from maybe avoiding a little overhead
00:20:19 <jchia> geekosaur: well, if I call 'helper' functions like 'object' (http://hackage.haskell.org/package/aeson-1.3.0.0/docs/Data-Aeson.html#v:object), instead of encoding directly with nested 'pairs', 'pair', will I take a performance hit?
00:21:19 <geekosaur> some, yes. how much, I don;t know offhand. if it's using generics internally, it might matter some; otherwise I'd prefer readable using the standard mechanisms over premature optimization
00:25:58 <jchia> E.g. 'object [ "abc" .= object [...]]' vs something like 'pairs (pair "abc" (pairs ...'. The former uses Value and the latter uses Encoding directly but is hard to read.
01:13:19 <laudecay> i think i'm being stupid https://hastebin.com/onikaboxim.pl
01:13:27 <laudecay> where's the syntax error?
01:14:38 <opqdonut> laudecay: I guess "n =" needs to be indented to the same column as "cmds ="
01:14:54 <laudecay> yep im an idiot thank you
01:28:04 <phadej> jchia: you can use pairs $ mconcat [ "abc" .= pairs ..., "foo" .= True ] -- I'd guess that mconcat is even unrolled! so there shouldn't be performance hit (hmm, maybe I should add a inspection-testing test to aeson!)
01:28:37 <phadej> oh wait, "abc" .= value, cannot have Encodign on the right, I  see.
01:28:58 <phadej> jchia: you could bikeshed an operator name for `pair`
01:47:04 <jchia> aeson encoding question: I already have [Series] or [Encoding]. How can I encode that as a JSON array (produce an Encoding)? 'pairs' operates on Series and foldable operates on ToJSON a but there is no ToJSON instance of Encoding or Series.
01:47:40 <jchia> maybe list?
01:48:15 <phadej> http://hackage.haskell.org/package/aeson-1.3.0.0/docs/Data-Aeson-Encoding.html#v:list
01:48:30 <phadej> (and now I parsed `maybe list?` :)
01:48:49 <jchia> phadej: Thanks. I mean maybe use 'list' :)
01:55:29 * hackage log-elasticsearch 0.10.0.0 - Structured logging solution (Elasticsearch back end)  https://hackage.haskell.org/package/log-elasticsearch-0.10.0.0 (MikhailGlushenkov)
01:55:48 <robstr> cocreature: regarding pqueues, I think i have the same problem, I'm only able to update the maximum/minimum proprity but not a specific one
01:56:08 <laudecay> wait how do i putStrLn a list
01:56:14 <laudecay> oh no i hate computers
01:57:04 <cocreature> robstr: huh? alter takes the key that you want to update
01:57:17 <cocreature> laudecay: putStrLn (show xs)
01:57:23 <cocreature> laudecay: or just "print xs"
01:57:29 <laudecay> cocreature: oh but i want each one on its own line
01:57:39 <robstr> cocreature: hm, do i look on the wrong place https://hackage.haskell.org/package/pqueue-1.4.1.1/docs/Data-PQueue-Prio-Max.html
01:57:41 <laudecay> i tried folding it with \n but they all disappeared when i actually ran it
01:57:42 <xandaros> sequence_ (fmap putStrLn list)
01:57:49 <cocreature> laudecay: traverse_ putStrLn
01:57:52 <marvin3> mapM_ putStrLn xs
01:57:58 <xandaros> So many options :D
01:58:03 <cocreature> robstr: I was recommending the psqueues package not pqueue
01:58:09 <cocreature> robstr: https://hackage.haskell.org/package/psqueues-0.2.6.0/docs/Data-HashPSQ.html#v:alter
01:58:30 <robstr> cocreature: hm sry for that
01:58:47 <Ariakenom> putStr (unlines xs)
02:12:18 <vaibhavsagar> silly Stack question: how do people use it in Dockerfiles? Mine seems to be downloading the universe each time I build
02:13:00 <vaibhavsagar> specifically the package index download seems to take forever each time, but I think it should only happen once
02:13:13 <robstr> what is the way to benchmark code ? Criterion ?
02:18:36 <cocreature> robstr: yep
02:31:53 <Wuzzy> where do i find documentation on GHC's exit code?
02:32:20 <Wuzzy> i want to figure out whether running GHC succeeded or not in  a shell script
02:34:17 <vaibhavsagar> Wuzzy: do you mean running something in GHCi or compiling a program with GHC?
02:34:41 <Wuzzy> GHC
02:35:16 <Wuzzy> actually. i just want to check in shell whether a package XYZ exists and scan it from the program's exit code
02:38:09 <tsahyt> so for fun I experimented with folding heterogeneous lists, the idea being to use categories instead of monoids as a building block to deal with the lists being heterogeneous. this is the result https://gist.github.com/tsahyt/ec5a7435866063240aab94e40478e5ce, and I was wondering whether something like this has been explored further already?
02:38:18 <vaibhavsagar> Wuzzy: do you need to use exit codes and GHC?
02:38:28 <vaibhavsagar> what if you used ghc-pkg instead?
02:39:03 <Wuzzy> hmm yeah that might actually work
02:39:30 <vaibhavsagar> I can see that if I do `ghc-pkg describe Cabal` it gives me a description and an exit code of 0
02:39:51 <vaibhavsagar> but if I do `ghc-pkg describe hlint` it gives me an error message and an exit code of 1
02:40:03 <Wuzzy> yes!!!
02:40:43 <Wuzzy> ok thanks
02:41:46 <vaibhavsagar> :thumbsup:
02:59:28 <merijn> tsahyt: Well, I did something like this: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
02:59:45 <merijn> tsahyt: And there's a bunch of other heterogeneous list libraries on hackage
03:02:29 * hackage odbc 0.0.2 - Haskell binding to the ODBC API, aimed at SQL Server driver  https://hackage.haskell.org/package/odbc-0.0.2 (ChrisDone)
03:08:41 <tsahyt> merijn: I suppose apply is a bit like a fold here? The HList package seems to do something related from what I can tell.
03:10:36 <merijn> tsahyt: Yes, it's kinda like a fold
03:11:46 <merijn> It just says that if I have "HList '[Char, Bool]" and a function "Char -> Bool -> b" then I can obviously apply that function using each argumnet in my HList
03:12:23 <merijn> tsahyt: Which is what the 'Fun' type family does, convert a [*] into a * (which happesn to be a function type)
03:18:11 <tsahyt> mhm, the Category based approach just needs to know how to compose two elements. Though I suppose at the end they're equally restrictive anyhow, since all the types need to be known statically regardless
03:18:57 <cocreature> tsahyt: it kind of reminds me of the category-printf package
03:20:04 <tsahyt> oh another attempt at typesafe printf. interesting, I'll have to look at that
03:20:48 <cocreature> it doesnâ€™t use hlists but if you fuse the creation of the hlist and the folding in your code sample into one step they look somewhat similar
03:22:24 <tabaqui1> Language.Haskell.TH has some inconsitency, as I think
03:22:29 <tabaqui1> data Exp
03:22:35 <tabaqui1>   ConE Name
03:22:39 <tabaqui1>   AppE Exp Exp
03:22:49 <tabaqui1>   RecConE Name [FieldExp]
03:23:21 <merijn> tabaqui1: How so?
03:23:35 <tabaqui1> so if you want to build 'Foo x y z', you have to ConE foo `AppE` VarE x `AppE` VarE y `AppE` VarE z
03:23:52 <tabaqui1> but if you want to build record, you can use List
03:23:56 <tabaqui1> in other way
03:24:20 <tabaqui1> "reify" method returns constructor arguments as a List
03:25:16 <merijn> tabaqui1: You can just fold the AppE over a list?
03:25:28 <tabaqui1> *Dec type has constructor of a type with arguments composed with a List
03:25:58 <tabaqui1> merijn: how?
03:26:57 <tabaqui1> for now I think that I'll have to add new class for multiple arguments function
03:27:27 <tabaqui1> merijn: ah, sorry
03:27:34 <tabaqui1> damn, you're right
03:27:41 <tabaqui1> but it is still unconsistency
03:28:07 <cocreature> well you need to be able to handle partial application of constructors but not when theyâ€™re used as records
03:35:28 <sphinxo> given 'data A = A B' when B has a ToJSONKey/FromJSONKey instances ( and I can't use generalised newtype deriving on A) what should the implementations of ToJSONKey/FromJSONKey be?
03:35:38 <sphinxo> ( aeson )
03:37:31 <sphinxo> ( I can't make A a newtype since it has existential quantifiers )
03:37:55 <cocreature> sphinxo: just do the wrapping/unwrapping manually in the instance?
03:38:54 <sphinxo> writing:   toJSONKey (A b)= toJSONKey b
03:39:24 <cocreature> no take a look at the type of toJSONKEy
03:39:27 <cocreature> *toJSONKEy
03:39:33 <cocreature> ahrg, Iâ€™m too stupid for capitalization
03:39:52 <cocreature> anyway you need to convert ToJSONKeyFunction B to ToJSONKeyFunction A
03:42:01 <sphinxo> how can I do that? deconstruct the ToJSONKeyFunctions and add A constructor and deconstructor?
03:42:17 <cocreature> yep
03:42:17 <sphinxo> ToJSONKeyFunction Constructors
03:43:15 <cocreature> you should be able to write (b -> a) -> ToJSONKeyFunction a -> ToJSONKeyFunction b
03:43:45 <cocreature> for FromJSONKeyFunction you can just use the Functor instance
03:45:55 <sphinxo> how should I get the FromJSONKeyFunction for B in the A instance?
03:46:55 <cocreature> just use fromJSONKey. either let type inference take care of choosing the right type or provide an explicit type annotation
03:47:51 <sphinxo> something like: fromJSONKey = fmap (A.) fromJSONKey
03:48:15 <cocreature> remove the dot
03:51:12 <sphinxo> wonderful thanks cocreature :)
03:55:03 <robstr> Is criterion able to count number of function evaluations in a specific time interval, like 5 minutes ?
03:55:42 <cocreature> robstr: that sounds like youâ€™re looking for a profiler rather than a benchmarking tool like criterion
03:55:56 <cocreature> you can ofc profile your benchmark execution
03:57:00 <cocreature> GHC has profiling facilities built in. take a look at the GHC user guide and the stack/cabal docs for how to enable it
03:57:52 <robstr> great, ty
04:47:21 <merijn> cabal/GHC don't support parallel compilation within the same package yet, right?
04:50:37 <phadej> it does, `ghc-options=-j2`
04:51:09 <phadej> also cabal new-build at least supports compiling multiple components of single package (e.g. test-suites or executables) in parallel
04:51:29 <phadej> given they are build-type: Simple + some other conditions, IIRC
04:53:55 <merijn> Well, in hindsight that might not actually speed things up >.>
04:57:11 <merijn> I swear, at this point fixing this issue is just going deserve an ecological merit batch on account of how much compute power and storage I'm going to save...
04:58:49 <hpc> lol
04:58:55 <merijn> phadej: -j2 doesn't really seem to really impact the build of modules in parallel?
04:59:43 <phadej> if your module graph is linear, there is no way to parallelise it :)
04:59:58 <merijn> phadej: How do you people develop Cabal? >.> Do you just have like a monster machine or what?
05:00:24 <merijn> Takes me like 10 minutes rebuilding 50+ modules every change
05:00:29 <jchia_1> phadej: When I do -j2, I still seem to see two modules compiled one after another that are not related directly or indirectly by 'import'
05:01:14 <phadej> merijn: when I was working on the parser the incremental builds touched only handful of modules, so it was quite fast.
05:01:18 <phadej> also ghci + :r
05:01:23 <merijn> hpc: You laught, but "--ghc-option=-j2" just rebuild Cabal's transitive dependencies, so...
05:01:48 <merijn> phadej: The modules I'm changing seem to transitively impact basically everything
05:04:18 <phadej> than it's tough luck :/
05:04:21 <ShalokShalom> what is the difference between let in Haskell and other ML influenced language?s
05:04:40 <phadej> merijn: try doing the same with GHC :)
05:04:43 <merijn> ShalokShalom: ML generally require "let rec" for recursive bindings
05:04:48 <phadej> it's not that bad
05:04:51 <merijn> ShalokShalom: In haskell all bindings are recursive
05:05:59 * hackage hierarchy 0.3.1.4 - Pipes-based library for predicated traversal of generated trees  https://hackage.haskell.org/package/hierarchy-0.3.1.4 (dnadales)
05:13:36 <xandaros> I wish Haskell also required "let rec" ...
05:14:52 <phadej> runIdentity $ do ...  :)
05:15:08 <phadej> for non-rec lets
05:15:38 <xandaros> lol
05:17:26 <xandaros> With RecursiveDo, you could even have recursive bindings, too. Still, this is a rather odd way of doing things
05:18:26 <dmwit> Not all bindings in Haskell are recursive... if you call `<-` a binding as many do. ;-)
05:18:43 <merijn> dmwit: Don't forget pattern guards!
05:18:47 <xandaros> I'd really appreciate an extension that requires you to use "let rec", though. It doesn't happen that often, but it does happen that I accidentally make a self-recursive binding without intending to
05:19:04 <xandaros> And it's a pain to debug
05:20:47 <ShalokShalom> merijin: oh, thy
05:20:54 <ShalokShalom> and how to do non rec stuff?
05:21:12 <ShalokShalom> oh do
05:21:15 <ShalokShalom> ok, fine
05:21:16 <merijn> ShalokShalom: "Don't reuse names"?
05:21:16 <ShalokShalom> thanks
05:21:36 <ShalokShalom> huh?
05:21:50 <merijn> "how to do non rec stuff" <- you can't
05:21:52 <ShalokShalom> I mean to opt out
05:21:55 <ShalokShalom> ok
05:21:56 <ShalokShalom> thanks
05:22:05 <xandaros> You can't. That's what I'm complaining about :P
05:22:06 <ShalokShalom> all is recursive in Haskell?
05:22:11 <ShalokShalom> I see :)
05:22:13 <merijn> Most of the above suggestions should be taken as jests
05:22:19 <ShalokShalom> a friend complained about it also
05:22:45 <merijn> phadej: On the brightside, I'm getting a shitton of reddit browsing done today :p
05:33:42 <tdammers> "opt out of recursion"? what would that even mean?
05:33:52 <tdammers> you can of course just not use any recursion
05:34:30 <merijn> tdammers: It'd mean that "let foo = ... foo" has the right hand foo refer to an earlier declared foo
05:34:32 <xandaros> Something that either makes "let a = a" invalid or a no-op (shadows an a binding and assigns it the same value)
05:35:00 <tdammers> merijn: oh, I see.
05:35:19 <tdammers> that would make some things impossible to express though
05:35:28 <merijn> tdammers: Which in ML is often used to shadow/refine values
05:35:39 <tdammers> merijn: yeah, I get the appeal
05:35:40 <merijn> tdammers: Well, that's why ML has an explicit "let rec" to enable that :)
05:35:45 <tdammers> right, yes
05:35:57 <tdammers> (also why most lisps have multiple flavors of let)
05:44:49 * dmwit channels Marvin and mumbles under his breath: countable infinity of names, and they want to avoid using one or two extras
05:50:08 <Ariakenom> let a = a & \a ->
05:51:28 <Ariakenom> no, not at all
05:57:10 <jchia_1> megaparsec questions. I'm trying to parse a file where only lines that start with a certain pattern are meaningful. The other lines are just dropped. 1) How can I get megaparsec to process input on a line-by-line basis? I don't want it to read and try to process and consume a '\n' character like a regular character, fail to parse and then fail to backtrack, messing up the next line. 2) Is there a way to say 'skip till the end of the lin
05:57:10 <jchia_1> e'?
05:57:41 <jchia_1> Previously I have only broken up the input into lines myself before giving the input line-by-line to megaparsec.
05:57:48 <tdammers> manyTill anyChar eol?
05:58:46 <jchia_1> tdammers: Will anyChar match a '\n' so that eol never gets matched?
05:58:57 <ertes-w> helo
05:59:06 <dmwit> That is not how manyTill behaves, no.
05:59:26 <tdammers> anyChar matches '\n', but eol will be tried first
05:59:28 <dmwit> I mean, the question is muddled. Yes anyChar will match a '\n', no the eol will not never get matched.
05:59:34 <jchia_1> dmwit: The documentation says "This parser succeeds for any character. Returns the parsed character." Is it documented somewhere that '\n' is special?
05:59:42 <tdammers> it's not
05:59:44 <dmwit> '\n' is not special.
05:59:50 <tdammers> anyChar will capture '\n'
05:59:56 <dmwit> manyTill is special, not '\n'.
06:00:07 <tdammers> but manyTill will try the end condition first, before each attempt to parse the "payload"
06:00:42 <jchia_1> tdammers: OK, I misunderstood your "manyTill anyChar eol"
06:00:54 <jchia_1> It looks for eol but if there's no eol, it consumes the character with anyChar
06:01:00 <tdammers> manyTill a b means "try to parse b; if it succeeds, exit, if it fails, parse an a, accumulate it, and recurse"
06:01:04 <tdammers> yes
06:01:16 <jchia_1> tdammers
06:01:25 <jchia_1> tdammers: What about part 1?
06:01:50 <tdammers> jchia_1: what do you mean exactly by "line by line"?
06:01:58 <tdammers> you can just parse things, and demand eol in the right place
06:02:23 <dmwit> (...or allow but not demand it, as the case may be.)
06:02:26 <tdammers> you can do something like meaningfulLine <|> ignoreLine
06:02:46 <tdammers> where meaningfulLine = do { try theSpecialThing; more things }
06:03:01 <tdammers> and also eol in strategic places
06:03:03 <dmwit> But perhaps the whole process would be easier if you implemented a lexer pre-pass.
06:07:59 * hackage hasbolt-extras 0.0.0.1 - Extras for hasbolt library  https://hackage.haskell.org/package/hasbolt-extras-0.0.0.1 (ozzzzz)
06:14:31 <merijn> hmmm, github doesn't have a way to have a PR depend on another, does it?
06:15:15 <merijn> i.e., if I have a base change I create a PR for and then some changes building on top of that I wanna PR separately to keep the code review clean. Am I stuck just waiting for the first one to get merged?
06:15:35 <Sali> I have an external (non-Haskell) dependency: libzmq.so.  Is there a way how I can link this into a binary via ghc? So that it will be available and used on systems that do _not_ have that dep installed?
06:16:03 <merijn> Sali: You'll have to statically link it in
06:16:14 <Sali> merijn: yes sounds good. So this IS possible yes?
06:16:16 <merijn> Sali: Which is possible, but not all that well documented
06:16:25 <merijn> Sali: You'll probably want libzmq.a
06:16:32 <merijn> Sali: Rather than .so which is a dynamic library
06:16:39 <jchia_1> tdammers: I want to parse x with one call of the parse function and get the same parsed result as if I'm doing doing it on each element of 'lines x'. Then if there is an error, the line number in the error is meaningful.
06:16:40 <Sali> I can get it, thatâ€™s fine.
06:17:00 <Sali> merijn: do you have any pointers about this? A piece of documentation?
06:17:15 <merijn> Sali: Well, the GHC manual itself is very in-depth and oft overlooked, so I'd start there
06:17:40 <Sali> Good, thank you merijn!
06:17:43 <tdammers> jchia_1: OK, but that just means that you have to make sure that whenever you call the X parser, you're at the beginning of a line, no?
06:17:53 <tdammers> (and that X doesn't skip past the end of a line)
06:17:55 <merijn> Sali: GHC, in the end, just uses the system linker, so if you know how to tackle this in C the approach with GHC should be the same and just be a matter of "how to get GHC to call the linker the way you want"
06:18:48 <jchia_1> Previously, I give it one line at a time, so it's already at the beginning of the file. Now, I want to give it the whole file, so I'm at the beginning of the first line.
06:19:06 <merijn> Sali: Don't forget to ldd the final executable to check you're not missing any libraries
06:19:34 <merijn> Sali: cabal-install can use pkgconfig for figuring out linking flags for stuff like libzmq too
06:20:42 <Sali> merijn: I will test the result in an environment where libzmq was not installed.
06:22:47 <Sali> Opinions please:  a) tasty vs b) hspec  (vs c) both are amazing)
06:23:36 <merijn> I don't like hspec's "friendly" DSL
06:24:15 <jchia_1> dmwit: By lexer pre-pass, do you mean something like using 'lexeme (void newline) lineParser', where lineParser is the parser I write for parsing one line? And then, in lineParser, I have to make sure I never consume an newline character, so things like anyChar cannot be used?
06:24:18 <merijn> And some dependencies were already using tasty, so I'm kinda biased to tasty
06:25:03 <merijn> Sali: So I think it boils down to "do you like hspec's DSL approach"
06:25:30 <jchia_1> Actually, I don't understand the purpose of Lexer in megaparsec. Is it just to skip spaces after each token?
06:25:30 <dmwit> I don't know what `lexeme` is. I mean something like writing a separate function that is of a type like `String -> String` or `String -> [String]` that does your "erase uninteresting lines and eliminate newlines" pass.
06:25:32 <Sali> merijn: feature-wise they are both comparable? One of them is not lacking anything that would be considered important?
06:25:42 <merijn> A plus of tasty is that I wrote some nice boilerplate code to get pretty coloured and folded test output on Travis CI with tasty
06:25:48 <merijn> Sali: I think they're fairly comparable?
06:34:59 <sm> Sali: d) easytest is easier
06:37:56 <Sali> sm: Canâ€™t find it on stackage and startpage is sending me to unison.
06:41:59 * hackage hasbolt-extras 0.0.0.2 - Extras for hasbolt library  https://hackage.haskell.org/package/hasbolt-extras-0.0.0.2 (ozzzzz)
06:44:27 <sm> Sali: it's new, http://hackage.haskell.org/package/easytest
06:44:43 <sm> just another option
06:53:49 <merijn> -W warnings were introduced in 8.2, right?
07:11:29 * hackage ochintin-daicho 0.2.0.0 - A module to manage payroll books for Japanese companies.  https://hackage.haskell.org/package/ochintin-daicho-0.2.0.0 (arowM)
07:12:48 <merijn> cocreature: Do you need more excitement and breakage in your life? :)
07:14:38 <vaibhavsagar> hi, how do I prevent Stack from updating the index each time I do a `docker build`?
07:14:46 <cocreature> merijn: I already saw your PR if youâ€™re referring to that ;)
07:15:03 <merijn> cocreature: I'm about to push a follow-up patch that actually does some filter on GHC
07:15:20 <merijn> cocreature: Which flags were you having issue with again?
07:15:34 <cocreature> mostly warning flags
07:15:39 <vaibhavsagar> I'm trying to get IHaskell working on mybinder.org, so I need to fiddle with docker: https://github.com/vaibhavsagar/ihaskell-mybinder
07:15:42 <merijn> (for now just simple flags, i.e. nothing that has arguments, because that requires more complicated detection)
07:16:03 <merijn> cocreature: Yeah, I'm going to start with filtering (almost) all warning flags, ghci flags and anything -ddump related
07:16:09 <cocreature> sounds good!
07:16:32 <vaibhavsagar> jchia_1: it sometimes makes more sense to lex separately than lex+parse in one pass
07:16:38 <cocreature> vaibhavsagar: is using stackâ€™s builtin docker support not an option?
07:17:01 <vaibhavsagar> cocreature: mybinder.org does its own `docker build` so I assumed not
07:17:22 <cocreature> I donâ€™t even know what mybinder.org is so Iâ€™m probably not going to be of much help :)
07:17:30 <vaibhavsagar> that's okay, it's pretty new
07:17:36 <vaibhavsagar> basically it hosts Jupyter notebooks for you
07:18:00 <vaibhavsagar> but in theory it works with any Docker image that has Jupyter installed
07:18:25 <vaibhavsagar> so we could have free interactive Haskell notebooks for everyone if I could get this sorted
07:19:38 <cocreature> jchia_1: megaparsecâ€™s lexer modules are basically a bunch of convenice functions that automatically skip spaces and comments and it has some utilities for parsing things like numbers.
07:20:02 <cocreature> jchia_1: https://markkarpov.com/megaparsec/parsing-simple-imperative-language.html might be helpful as an example
07:21:51 <cocreature> vaibhavsagar: maybe make a separate "stack update" step in your Dockerfile? caching with docker is really painful. either it is overzealous in caching things or it constantly rebuilds everything
07:23:10 <vaibhavsagar> cocreature: if it's not already obvious, I would love to use nix for this instead :)
07:23:19 <vaibhavsagar> but I can't see how
07:23:36 <cocreature> yeah I feel your pain :)
07:23:36 <vaibhavsagar> `stack update` is a great suggestion though, I will look into it.
07:24:05 <jchia_1> cocreature. How is using the lexer different than manually reading and skipping the space characters yourself with (<* space) after each token you parse? Is there more to it than that?
07:24:34 <cocreature> jchia_1: itâ€™s not any different. as I said, itâ€™s just a convenience module that encapsulates some common patterns
07:27:25 <jchia_1> cocreature: I'm looking for a way to break the input by '\n' and then parse each line, so '\n' is special and should not match anything in my Parser (even if my Parser uses something like anyChar). I'm trying to parse an entire text file with one call to parse instead of one call for each line. Looks like lexer cannot help here? The motivation is for the line number in the error message to be meaningful.
07:27:57 <jchia_1> If I 'lines' the input and then parse each line, every error will be about Line 1.
07:28:28 <jchia_1> So unless there's a way to parse an entire file, I don't quite see the point of the line number in the error message.
07:28:48 <cocreature> jchia_1: use setPosition
07:28:59 * hackage transaction 0.1.1.3 - Monadic representation of transactions.  https://hackage.haskell.org/package/transaction-0.1.1.3 (arowM)
07:29:17 <jchia_1> cocreature: Thanks. I didn't know there was such a thing
07:29:53 <cocreature> or just donâ€™t use anyChar in your parsers and instead use satisfy (/= '\n') or something like that
07:30:13 <jchia_1> cocreature: That would impact readability. I think I'll just setPosition.
07:30:33 <cocreature> well you can define your own version of anyChar that does this
07:30:39 <cocreature> then itâ€™s just as readable
07:30:40 <mnoonan> vaibhavsagar: since you're here.. is there a good setup for using IHaskell with multiple stack projects (say, with different resolvers)?
07:30:47 <cocreature> hide the one from megaparsec
07:31:56 <jchia_1> cocreature: I think I also have to worry about the '\n' being consumed and then not backtracking.
07:33:49 <jchia_1> not sure if that's a real issue
07:34:38 <jchia_1> at least i also have to define my own notChar, noneOf, satisfy that normally could match '\n'.
07:36:27 <vaibhavsagar> mnoonan: IMO Nix is the best way to have multiple IHaskells
07:37:22 <vaibhavsagar> mnoonan: although if your different resolvers use the same version of GHC then `stack exec -- jupyter notebook` should work without any issues
07:37:25 <vaibhavsagar> I used to do that a lot
07:40:40 <vaibhavsagar> actually it should be possible to have multiple IHaskells with multiple GHCs running side by side
07:41:14 <vaibhavsagar> the issue is that `ihaskell install` puts the kernel specification in the same place every time and it's not overridable IIRC
07:41:29 * hackage bookkeeping 0.4.0.1 - A module for bookkeeping by double entry.  https://hackage.haskell.org/package/bookkeeping-0.4.0.1 (arowM)
07:42:21 <vaibhavsagar> so if you manually copy the kernel.json from `~/.local/share/jupyter/kernels/haskell` to a different folder then (I think) you can have as many IHaskells as you want
07:43:19 <mnoonan> vaibhavsagar: ok, that's about what I figured. thanks!
07:45:25 <vaibhavsagar> my pleasure!
07:45:29 * hackage marihana 0.1.0.0 -   https://hackage.haskell.org/package/marihana-0.1.0.0 (suzukeno)
07:45:43 <vaibhavsagar> it looks like there's also a `--prefix` option but I'm not sure it does what you want
07:47:08 <vaibhavsagar> I would happily accept a PR if you'd like to contribute one
07:47:47 <vaibhavsagar> but I'm not comfortable enough with the codebase/willing to put in the time to try to tackle it myself
07:47:50 <merijn> cocreature: https://github.com/merijn/cabal/commit/b3e55d956226bf60b523986830989ce442ae31f2
07:48:16 <merijn> Could use some testing to see if it actually does what it's supposed to :p
07:49:02 <static_h> how can I iterate on list without using any list functions?
07:49:29 * hackage proof-combinators 0.1.0.0 - Proof Combinators used in Liquid Haskell for Theorem Proving  https://hackage.haskell.org/package/proof-combinators-0.1.0.0 (nikivazou)
07:49:31 <Rembane> static_h: You can pattern match on it.
07:49:40 <merijn> cocreature: I've limited to GHC 8.2 and newer so I don't have to worry about flag compatibility and right now all flags I consider came from the 8.2 docs so some 8.4 ones might be missing
07:49:44 <alexbiehl> merijn: Great stuff!
07:49:58 <Rembane> static_h: f g (x:xs) = g x : f g xs
07:50:12 <Rembane> static_h: You need another equation, but it is trivial and you will soon find out why. :)
07:50:22 <merijn> alexbiehl: Gets the fully general "[String] -> [String]" and manages to touch surprisingly little code, so I'm fairly happy with it
07:50:25 <vaibhavsagar> static_h: do list comprehensions count as list functions?
07:50:32 <merijn> alexbiehl: Now I just gotta dogfood to check it works :p
07:50:49 <static_h> only Data.List ones i guess
07:50:57 <merijn> I figure I'd start with the simple stuff of just ignore "simple" flags with no arguments
07:53:29 * hackage ochintin-daicho 0.2.0.1 - A module to manage payroll books for Japanese companies.  https://hackage.haskell.org/package/ochintin-daicho-0.2.0.1 (arowM)
07:53:31 <Sali> sm: Thanks for the link.
07:53:45 <merijn> cocreature: Well, --ghc-option=-Wall no longer starts recompiling all my dependencies, so looks promising :)
07:55:32 <vaibhavsagar> mnoonan: if you're curious, it looks like the hardcoding is in `kernelName` in `src/IHaskell/IPython.hs`
07:58:29 * hackage Cabal 2.2.0.1 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-2.2.0.1 (MikhailGlushenkov)
08:00:53 <vaibhavsagar> ooh new cabal
08:01:29 <merijn> vaibhavsagar: Every day has a new Cabal if you run HEAD ;)
08:02:24 <vaibhavsagar> heh
08:03:13 <vaibhavsagar> I can't see any reason to run HEAD unless I need to be angerman for some time\
08:03:36 <merijn> I'm running HEAD right now to test my own patches and make use of the new-haddock fixes :p
08:03:47 <vaibhavsagar> nice
08:04:00 <vaibhavsagar> I like that they're so open with commit bits
08:04:08 <vaibhavsagar> I got one for fixing a typo
08:04:16 <vaibhavsagar> story of my life
08:04:24 <merijn> I've only managed to completely break my entire Cabal setup once so far :p
08:04:48 <merijn> vaibhavsagar: Probably inspired by edwardk's handling of commit bits. You try and submit one PR and suddenly you're a maintainer :p
08:04:52 <vaibhavsagar> tangentially related: is there a way to `cabal update` to a specific point in time?
08:05:10 <merijn> vaibhavsagar: new-build supports something like that
08:05:16 <vaibhavsagar> I feel like Nix does this somehow using some commercialhaskell magic
08:05:28 <vaibhavsagar> merijn: really, how does that work?
08:05:36 <merijn> vaibhavsagar: It always tells me how when I update, lemme check
08:05:46 <merijn> To revert to previous state run:
08:05:46 <merijn>     cabal update --index-state='2018-03-23T12:39:53Z'
08:06:08 <vaibhavsagar> fantastic, this is exactly what I'm looking for with my Dockerfile!
08:06:11 <merijn> I think you can add that in a cabal.project file somehow and it'll use that
08:16:29 * hackage cabal-install 2.2.0.0 - The command-line interface for Cabal and Hackage.  https://hackage.haskell.org/package/cabal-install-2.2.0.0 (MikhailGlushenkov)
08:20:01 <jchia_1> Can I get a diagnosis of this TH compilation error? https://gist.github.com/jchia/6e32401d5afde951f0159c5ecca7fd9b
08:20:46 <albeit> I'm using GeneralizedNewtypeDeriving with "newtype Val = Val Int deriving (Num)", but I get a runtime error when trying to do "Foo 1 + Foo 2". Specifically, "No instance nor default method for class operation +". What is happening?
08:21:33 <jchia_1> albeit: Foo or Val?
08:22:12 <lyxia> albeit: are you also using DeriveAnyClass
08:22:31 <albeit> @lyxia: Yes I am
08:22:32 <lambdabot> Unknown command, try @list
08:22:55 <albeit> lyxia: I am. And that is the issue. Why do they conflict?
08:23:48 <merijn> alexbiehl: DeriveAnyClass adds deriving strategies iirc
08:23:55 <merijn> s/alexbiehl/albeit
08:24:12 <merijn> albeit: So you need to say it should derive via GND rather than one of the others
08:24:26 <lyxia> albeit: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-any-other-class "In case you try to derive some class on a newtype, and -XGeneralizedNewtypeDeriving is also on, -XDeriveAnyClass takes precedence."
08:24:49 <lyxia> albeit: to avoid that see the next section on deriving strategies
08:27:17 <albeit> lyxia: Ah perfect! Thanks!
08:33:13 <cocreature> merijn: nice!
08:34:46 <jchia_1> TH question, can I get a value of Type from a type variable a (or Proxy a) where the Type is the type of a?
08:34:49 <lyxia> jchia_1: pass a String as an argument. It seems type-level scoping in type quasiquotes is just not a thing
08:35:55 <jchia_1> lyxia: Do you mean pass a String instead of a Proxy (a :: Symbol), and forget about the IsGridFieldName typeclass?
08:36:59 <jchia_1> lyxia: If I don't use quasiquotes and try to define partQ the verbose way:
08:36:59 <jchia_1> pure (AppT (AppT (ConT ''(:=)) (LitT (StrTyLit . symbolVal $ proxy))) (GridFieldType s))
08:37:11 <jchia_1> The "(GridType s)" part hits a wall
08:37:34 <jchia_1> I think I fundamentally need to get a Type from a type.
08:40:45 <lyxia> why does this need TH?
08:41:36 <lyxia> type Part s = s := GridFieldType s   -- does this not work
08:50:55 <jchia_1> lyxia: You are right, it works.
08:55:42 <lyxia> jchia_1: okay good! If you actually needed to pass a type to a splice, you could pass it in a quote: partQ :: TypeQ -> TypeQ ; partQ s = [t| $s := GridFieldType $s |]  and then you call it like type Foo = ($(partQ [t|"x"|]), $(partQ [t|"y"|]))
09:13:31 <jchia_1> lyxia: OK. Thanks.
09:23:57 <redrapscallion> is lpaste permanently shut down now?
09:28:34 <lyxia> redrapscallion: https://www.reddit.com/r/haskell/comments/862k28/looking_for_new_maintainer_of_lpastenet/
09:29:47 <lyxia> Something probably crashed and the maintainer hasn't got time to fix it.
09:44:29 * hackage ochintin-daicho 0.3.0.0 - A module to manage payroll books for Japanese companies.  https://hackage.haskell.org/package/ochintin-daicho-0.3.0.0 (arowM)
09:45:01 <lseactuary> hi lyxia
09:47:04 <lyxia> lseactuary: Hi
09:47:20 <lseactuary> i tried many times yesterday to solve what we were working on, but still have not made progress
09:47:23 <lseactuary> would you mind assisting?
09:48:39 <lyxia> Sorry not right now, but perhaps if you just ask the channel someone else will speak up.
09:48:45 <lseactuary> sure thing!
09:49:10 <fishythefish> lseactuary: what were you working on?
09:49:39 <lseactuary> fishythefish - 2 min uploading :)
09:50:59 <lseactuary> fishythefish - https://pastebin.com/Ynn7Sm2e
09:51:12 <lseactuary> i am stuck on just step3 and run3 functions the rest is working well.
09:52:28 <fishythefish> I don't know the semantics of those functions - what are you stuck on?
09:52:59 <lseactuary> fishythefish - the step3 function
09:53:06 <lseactuary> i can explain what it should do
09:53:08 <lseactuary> if it helps
09:53:11 <lseactuary> or what i have done?
09:53:16 <lseactuary> or the output expected?
09:53:35 <fishythefish> what should step3 do? when you try to implement that logic, which part do you get stuck on?
09:54:16 <redrapscallion> so this is from Lucid's source code -- https://paste.pound-python.org/show/YcbdnvysrqZQn0IuMxyg/ and I can't understand what line 3 is even doing
09:54:35 <redrapscallion> usually, I expect the first line of a class definition to look something like : class (Num a, Ord a) => Real a where .....
09:54:47 <lseactuary> so step3 is parameterised by the forwards step length and a turn angle. it should return an optional list of states. Just a list of states for a branch of drawing instructions and Nothing for a stakc instruction.
09:54:50 <fishythefish> redrapscallion: are you familiar with FunctionalDependencies?
09:54:56 <redrapscallion> fishythefish: not at all
09:55:09 <lseactuary> i think im close but i just tried cases to understand the syntax
09:55:14 <lseactuary> not really sure how to write the actual function
09:55:35 <fishythefish> redrapscallion: the tl;dr is that Term is a typeclass where `result` determines what `arg` is
09:57:19 <fishythefish> lseactuary: what does the type TurtleState3 encode?
09:57:36 <lseactuary> type TurtleState3 = (TurtleState2, [TurtleState2])
09:57:57 <fishythefish> I can read the code; what does that mean?
09:58:47 <EvanR> so many turtlestates
09:58:47 <fishythefish> What does each of those TurtleState2s represent?
09:58:53 <redrapscallion> fishythefish: ahh, okay, that makes sense. now that I know the name of it, I can just read more about it
09:58:59 <EvanR> turtlestates all the way down?
10:00:55 <lseactuary> fishythrfish TurtleState2 is basically (Position,Direction) so like x:+y co-ordinate, and a Direction e.g. pi/2 (polar co-ordinates)
10:01:11 <lseactuary> so (0:+0, pi/2) would be sitting at the origin, facing north
10:01:23 <fishythefish> I understand TurtleState2; I don't understand TurtleState3
10:02:06 <lseactuary> it is a starting point i think, and then a list of other points the turtle can travel to
10:02:23 <EvanR> one complex number and one angle to represent 2 2D vectors ;_;
10:02:24 <fishythefish> Can you be sure? It's awfully hard to write code when you don't know what it's supposed to do.
10:03:41 <lseactuary> fishythefish - maybe it will help to show you the picture i made before / what i am trying to do
10:03:47 <lseactuary> this may explain the use of maybe / just
10:04:01 <fishythefish> TurtleState3 doesn't have Maybe/Just in it
10:05:45 <ShalokShalom> http://www.clash-lang.org/
10:07:21 <lseactuary> yes i mean more generally
10:07:32 <lseactuary> im happy to explain please let me know
10:08:16 <fishythefish> I'm still just trying to get you to tell me with certainty what TurtleState3 represents
10:08:23 <fishythefish> Right now, I don't care about anything else in the code
10:08:49 <lseactuary> oki
10:09:22 <lseactuary> so it contains the original point and then a list of potential points / directions it can go to
10:09:32 <lseactuary> does it make sense?
10:09:42 <lseactuary> so if we look at initial3 (which is of this type)
10:09:47 <lseactuary> it specifies a starting point
10:09:54 <lseactuary> and then [] which means no other point
10:10:06 <lseactuary> before when i drew a picture i had list a list of tuples
10:10:15 <fishythefish> So from the initial state, the turtle cannot move?
10:10:20 <fishythefish> Are you sure those semantics are correct?
10:10:23 <lseactuary> wheras now i guess we are 'splitting' the journey
10:10:34 <lseactuary> so a tutrtle may move forward then go right and left
10:10:38 <lseactuary> hence a tree
10:11:06 <fishythefish> Then your description of TurtleState3 is misleading or incorrect
10:11:06 <lseactuary> maybe if i show you the pictures it will put things into more perspective?
10:11:33 <lseactuary> go on
10:11:45 <infandum> I'm trying to make a "Colour a" instance for NFData and am running into difficulties: https://pastebin.com/j6wcC0fJ
10:12:07 <fishythefish> You're saying that the [TurtleState2] in the second component of TurtleState3 represents the potential future states of the turtle
10:12:10 <infandum> From Data.Colour
10:12:23 <fishythefish> However, your initial state contains an empty list
10:12:36 <fishythefish> Which would indicate that the turtle cannot move from its initial state if your description is correct
10:13:00 <lseactuary> hmm maybe i am not articulating this well
10:13:24 <fishythefish> Did you design these datatypes or did a source provide them?
10:13:45 <lseactuary> no no im following a book
10:13:57 <fishythefish> so what does the book say TurtleState3 represents?
10:14:01 <lseactuary> checking
10:14:10 <lseactuary> When running the program, the current state of the turtle must also include a stack of saved states: type TurtleState3 = (TurtleState2, [TurtleState2 ])
10:14:17 <lseactuary> For these branching programs, we will start the turtle facing upwards (so that the trees grow up rather than sideways), and with an empty stack:
10:14:20 <lseactuary> initial3 :: TurtleState3 initial3 = ((0, pi / 2), [ ])
10:14:29 <fishythefish> So that's the stack of all the previous states of the turtle?
10:14:33 <lseactuary> ye
10:14:43 <fishythefish> Do you see how that's completely different than what you described?
10:14:48 <lseactuary> sorry yes
10:15:19 <fishythefish> Okay, so now let's move on to the (TurtleState3, Maybe [TurtleState2]) that step3 outputs
10:15:34 <fishythefish> The TurtleState3 will be the resulting turtle state; what does the Maybe [TurtleState2] represent?
10:15:43 <Psybur> Whats a good minimal linux distro to do haskell dev in?
10:16:22 <fishythefish> Psybur: as in you're trying to install linux purely for haskell dev, or you want a minimal distro that also supports haskell dev
10:16:27 <fishythefish> ?
10:16:49 <Psybur> Id primarily be doing haskell dev on it
10:16:58 <lseactuary> fishythefish they didnt explain this but they do explain type TurtleBranch3 = Either TurtleProg1 TurtleCmd3 if it helps?
10:17:10 <Psybur> Some native lib Im working with needs linux
10:17:11 <fishythefish> lseactuary: no, that doesn't help
10:17:23 <tomsen> Pysbur: haskell people like nixos a lot, but otherwise every distro should be pretty much the same since you probably will use stack.
10:17:26 <dstolfa> Psybur: the smallest linux distro i've seen is alpine. another good option is FreeBSD (not linux), but easy to get a quick installation and an easy setup of a haskell dev environment
10:17:40 <fishythefish> Psybur: but you don't care if the distro is minimal then? pretty much any linux distro should be adequate for haskell dev
10:17:40 <dstolfa> another good option is probably nixos as tomsen said
10:17:46 <fishythefish> there are some specialized ones like nixos
10:18:00 <Psybur> Well I want the distro to be minimal. Need a small image :D
10:18:13 <Psybur> And blargh I remember stack's package cache gets really huge
10:18:18 <lseactuary> fishythefish it explains step3 maybe this will help:
10:18:25 <lseactuary> execute one turtle branch, parametrized by the forwards step length and turn angle. It should return an optional list of states from which to construct a polylineâ€”Just a list of states for a branch of drawing instructions, and Nothing for a stack instruction.
10:18:41 <redrapscallion> Psybur: arch linux is pretty lightweight and has a small image
10:18:59 <redrapscallion> Psybur: i don't know if the learning curve will be worth it though
10:19:01 * dstolfa personally prefers FreeBSD but is biased there :)
10:19:03 <fishythefish> Psybur: I use arch myself, but you can go more minimal, and it's not really haskell-specialized
10:19:13 <etalecohomology> hi
10:19:33 <dstolfa> i think the easiest to install linux will likely be Alpine, at least IMO
10:19:39 <dstolfa> i use it for docker environments if i ever need it
10:20:09 <etalecohomology> how to use a simple algebraic "enum" like "data foo = A | B | C" with serialization, e.g. Cereal or safeCopy?
10:20:09 <dyl> I have an important survey for the haskell community:
10:20:13 <fishythefish> lseactuary: does your book contain examples of evaluating step3? That description still isn't very clear to me
10:20:30 <dyl> One question survey: https://goo.gl/forms/Z5tkMfR9PEDlEbEH2
10:20:32 <dyl> Please reply, tyvm.
10:20:37 <lseactuary> fishythefish - it has an example of evaluating run3 which i am sure requires step3
10:20:56 <lseactuary> i can provide it
10:21:03 <dyl> To the wizard, your powers are naught before a mathemagician.
10:21:05 <fishythefish> lseactuary: ah, never mind, I got it
10:21:17 <lseactuary> :)
10:21:32 <fishythefish> dyl: excellent set of choices
10:21:43 <Psybur> Is it possible to avoid stack? nixos + nix + cabal ? :D
10:21:46 <dyl> I just tried to come up with some in the past couple minutes.
10:21:52 <dyl> It was originally Haskeller vs Haskellographer.
10:21:57 <dyl> I'm proud of Haskquire (Hsq.) though.
10:22:16 <redrapscallion> dyl: Haskellsmith just sounds pretentious lol
10:22:31 <dyl> I was working off of existing professions!
10:22:34 <fishythefish> Haskquire and Haskelldasher were my favorites
10:22:36 <dyl> ____smith, haberdasher...
10:22:48 <dyl> I just think Haskeller isn't plish.
10:22:50 <fishythefish> Haskquire is a title, though
10:22:51 <dyl> We need a more plish demonym.
10:22:55 <dyl> (or title)
10:23:05 <fishythefish> so you'd be a Haskelldasher, and you'd introduce yourself as dyl, Haskquire
10:23:26 <dyl> Also, I'm trying to spread usage of my neologism "plish".
10:23:31 <dyl> It's like "keen", or "fetch".
10:23:38 <fishythefish> lseactuary: you should make your pattern matches for the lists in TurtleBranch3 and TurtleState3 more general
10:23:42 <dyl> But tailored for the FP community.
10:23:46 <fishythefish> stop trying to make plish happen
10:23:49 <fishythefish> it's not gonna happen
10:24:08 <redrapscallion> am I out of the loop? wtf is "plish"?
10:24:11 <LKoen> can you get promoted from Haskquire to Hasknight?
10:24:18 <dyl> plish is from pl-ish.
10:24:20 * dstolfa slaps fishythefish with floaty mcfloatface
10:24:25 <dyl> If something is plish, it's satisfying, cool, and good.
10:24:38 <dyl> Gabriel Gonzales' pipes library is plish for example.
10:24:44 <dyl> Haskell is plish.
10:24:46 <dstolfa> dyl: is pldi plish?
10:25:01 <lseactuary> fishythefish - how so?
10:25:06 <lseactuary> you mean the functions step3/run3?
10:25:08 <dyl> dstolfa sort of by definition, yes.
10:25:21 <dyl> If it's PL-ish, then it is (almost) de-facto plish.
10:25:27 <redrapscallion> Psybur: you could, but stack is just so convenient
10:25:43 <dstolfa> dyl: i'm not sure i understand. you should write it out in terms of hoare logic
10:25:44 <dyl> I'm going to make plish happen. Say it out loud, isn't that satisfying?
10:25:48 <fishythefish> lseactuary: you're only matching on patterns for 0 or 1 elements. what will you do for long lists?
10:25:56 <dstolfa> dyl: alternatively, i will allow you to use rule-based notation
10:26:10 <dyl> It's like "swish", but instead of saying it after a great basket, you'd say it after a function finally typechecks.
10:26:26 <redrapscallion> dyl: ????
10:26:35 <lseactuary> fishythefish that is that the push/pop/skip stuff is for no?
10:26:52 <dyl> redrapscallion if you want to be cool, you have to add "plish" to your lexicon.
10:27:02 <dyl> It's the law.
10:27:08 <fishythefish> lseactuary: huh?
10:27:15 <dstolfa> is this an equivalence of simply implication
10:27:20 <dstolfa> dyl: BE MORE PLISH PLEASE
10:27:24 <lseactuary> fishythefish - sorry ignore - was thinking of something else
10:27:35 <lseactuary> fishythefish - you have something i can try?
10:27:53 <fishythefish> lseactuary: I have a solution, yes, but presumably the goal is for you to write code yourself
10:28:09 <lseactuary> can you guide me :)
10:28:13 <lseactuary> i can try to write
10:28:22 <redrapscallion> dyl: idk, I was thinking we could have something more Haskell-specific, something only Haskellers/Haskellsmiths would know
10:28:32 <dyl> Currently "wizard" is winning...
10:28:38 <dyl> I love/hate you guys.
10:28:42 <fishythefish> lseactuary: let's start with the TurtleBranch3 argument. Your patterns are not exhaustive
10:29:02 <dyl> Then again n=7 is a small sample size.
10:29:04 <lseactuary> what are we defining please?
10:29:07 <fishythefish> step3
10:29:18 <lseactuary> kk
10:29:30 <dyl> Whoever responded Hasketeer,
10:29:34 <dyl> I've added it as a named option.
10:29:42 <tomsen> dyl: thanks :-D
10:29:52 <lseactuary> fishythefish so call it ts3 or something instead?
10:29:56 <lseactuary> as an argument
10:30:23 <lseactuary> step3 dis dir tb3 ts3 = something
10:30:45 <dyl> Ok, whoever you two people are who just said Wizard.
10:30:46 <fishythefish> that's too general; you'll want to do some pattern matching in order to deconstruct the arguments
10:30:48 <dyl> Come on, really?
10:30:53 <dyl> It's now almost 50% "wizard".
10:31:13 <fishythefish> dyl: you should know better than to ask the internet to vote
10:31:24 <redrapscallion> dyl: you've messed up by allowing infinite votes btw
10:31:25 <lseactuary> step3 dis dir (Left cs) (ts2, []) = something?
10:31:34 <dyl> Hasky McHaskellface added to the options.
10:31:41 <robin_> what's wrong with this simple Eq instance https://bpaste.net/show/4bdc69a0714e
10:31:45 <fishythefish> lseactuary: that's a good start. you'll also want a case to handle Right
10:32:03 <dyl> redrapscallion I messed up by allowing poll-options I don't like.
10:32:11 <fishythefish> lseactuary: now, in your TurtleState3 argument, you assume that the list is always []
10:32:20 <dyl> I should have made it have options like "how good of a poll do you think this is?" â‡’ "okay, good, great, fantastic"
10:32:37 <dyl> Just like the ones put out by the white house ðŸ™ƒ
10:32:38 <lseactuary> like step3 dis dir (Left cs) (ts2, []) = ([], ....)
10:32:51 <dyl> Ok, whoever keeps saying Wizard...
10:32:53 <fishythefish> lseactuary: no, you can't assume the list is always empty
10:32:55 <dyl> I'm going to just filter out wizards.
10:33:02 <dyl> I'm now a wizardist.
10:33:13 <lseactuary> oh you meant step3 dis dir (Right cs) (ts2, []) = ([something], ....)
10:33:19 <lseactuary> *same for Left
10:33:49 <fishythefish> lseactuary: no, I mean that (ts2, []) will fail to match (someState, anyNonEmptyList)
10:34:02 <lseactuary> right
10:34:24 <lseactuary> step3 dis dir (Left cs) (ts2, [ts2']) = something
10:34:29 <dyl> Whoever just replied Lisp, your data point is being thrown out.
10:34:35 <dyl> I know you're here.
10:34:41 <fishythefish> lseactuary: this will all go much smoother if you put the code changes in the paste rather than in irc btw
10:34:51 <lseactuary> lpaste is broken :/
10:34:52 <lseactuary> lemme try
10:34:52 <dyl> ...both of you.
10:34:59 <dyl> ...all four of you...
10:35:07 <dyl> redrapscallion are you just screwing with my poll :<
10:35:09 <lseactuary> is there another tool i can upload
10:35:17 <fishythefish> dyl: you can't spell plish without list
10:35:20 <fishythefish> lisp*
10:35:28 <redrapscallion> lseactuary: I just use https://paste.pound-python.org/
10:35:29 <dyl> ðŸ¤­
10:35:34 <dyl> fishythefish well damn.
10:35:39 <dyl> That means I can sell it to them too!
10:35:40 <redrapscallion> it's technically for #python but... it's whatever
10:36:01 <redrapscallion> just select "Haskell" as language and it's the same as lpaste
10:36:02 <dyl> My goal is "plish" on a title card at a major FP conference by 2022.
10:36:10 <lseactuary> https://paste.pound-python.org/show/BS4ImkH80Y20npTJ3xku/
10:36:57 <lseactuary> thanks redrapscallion
10:37:00 <redrapscallion> dyl: I would never do something as terrible as that. :(
10:37:46 <fishythefish> lseactuary: you're now only matching lists of length 1
10:38:41 <lseactuary> https://paste.pound-python.org/show/6PBiH5OySsHFNqVwLAkv/
10:39:14 <fishythefish> lseactuary: now you're matching a list of length 1 whose member is a nonempty list
10:39:22 <fishythefish> btw this might be easier with editable code rather than static pastes
10:39:56 <lseactuary> fishythefish lpaste doesnt work :(
10:40:09 <lseactuary> you know something else?
10:40:21 <dyl> lseactuary you could use gist.
10:40:25 <lseactuary> oh ye
10:40:27 <dyl> It's editable and has versions.
10:40:45 <dyl> Doesn't have hipster appeal though.
10:41:05 <fishythefish> lseactuary: codeshare or anything similar would work well
10:41:18 <zachk> is lpaste down finally?
10:41:19 <dyl> So, perhaps a broad question but I've been out of the Haskelloop since GHC 7.12 ish.
10:41:25 <dyl> What's the new hotness in 8.x?
10:41:29 * hackage etc 0.3.0.0 - Declarative configuration spec for Haskell projects  https://hackage.haskell.org/package/etc-0.3.0.0 (RomanGonzalez)
10:41:47 <zachk> in the future we are supposed to get linear types and maybe even dependent types, but it's a way off
10:41:54 <fishythefish> dyl: gross, Haskell OOP?
10:42:14 <lseactuary> hmm i swear you could just create a gist without an account
10:42:15 <lseactuary> weird
10:42:17 <dyl> Linear typing would be nice.
10:42:30 <dyl> I'm amazed at just how much the *single special case* of linear typing in Swift improves quality of life.
10:42:45 <dyl> (bound optionals in if/guard statements become non-optional)
10:42:47 <zachk> whats the single special case in swift?
10:42:53 <dstolfa> dyl: adding dependent types makes it trivial to have linear types :)
10:43:21 <dyl> zachk if you have `let x: T? = ...` and then `if let y = x { ... }` then y is non-optional inside the if.
10:43:22 <EvanR> it does?
10:43:22 <lseactuary> fishythefish - i dont have codehsare :(
10:43:24 <dyl> Conversely,
10:43:30 <[exa]> dstolfa: /me interested
10:43:34 <fishythefish> lseactuary: what? it's a website
10:43:38 <dyl> if you have `guard let y = x else { ... }` then y is non-optional for the rest of the scope.
10:43:41 <lseactuary> ye
10:43:45 <lseactuary> its just showing me other gists
10:43:51 <dyl> guard is just a negated-if where the else clause *must* return/break/throw/continue/etc.
10:44:02 <lseactuary> rather than letting me upload
10:44:12 <fishythefish> lseactuary: are you looking at the same codeshare.io that i am?
10:44:15 <dyl> But you can pattern match in any control-statement, so that's nice.
10:44:15 <EvanR> how do you get linear types from dependent types
10:44:30 <lseactuary> oh
10:44:39 <dyl> lseactuary https://gist.github.com you don't need to be logged in.
10:44:46 <lseactuary> https://codeshare.io/G6YQ6p
10:44:46 <zachk> evanr, they are seperate concepts
10:44:53 <EvanR> i was asking dstolfa
10:44:59 <dyl> I'm not seeing how dependent types get you linear types either.
10:45:02 <lseactuary> gist link is taking me to /discover
10:45:07 <lseactuary> anyhow codeshare.io is working
10:45:15 <fishythefish> lseactuary: okay, step 1 is to fix your pattern matches
10:45:16 <dstolfa> [exa]: EvanR as you do with every other type, you construct one. Idris has something like linear types, but not really linear types. they define Unique type as those that must be used at most once, not exactly once, but you can go about and define a type that has to be used exactly once and it won't typecheck if it doesn't: http://docs.idris-lang.org/en/latest/reference/uniqueness-types.html
10:45:20 <dyl> Linear types are substructural.
10:45:20 <[exa]> EvanR: on the second thought having dependent types makes it super easy to just let the compiler check the Nat counts everywhere
10:45:26 <dstolfa> it's not really trivial to use, but you can implement them
10:45:35 <EvanR> idris's unique is not linear types
10:45:40 <dstolfa> EvanR: please read the full thing
10:45:45 <EvanR> i have
10:45:48 <zachk> idris may be adding linear types in the future
10:45:48 <lseactuary> fishythefish do you see the changes or i need to click something?
10:45:55 <fishythefish> lseactuary: I see them
10:45:57 <dyl> Also, affine types might be more useful, really.
10:45:58 <lseactuary> cool
10:46:01 <dstolfa> EvanR: if you have, then you wouldn't have lectured me about it because i've said it already ;)
10:46:02 <EvanR> yes you can implement an entirely new programming language in idris
10:46:03 <dyl> For a very increase in complexity.
10:46:14 <lseactuary> is it ok
10:46:16 <EvanR> or haskell
10:46:18 <zachk> doesn't rust kind of have affine types?
10:46:24 <EvanR> no
10:46:33 <zachk> :( read that somewhere
10:46:40 <fishythefish> lseactuary: no. can you include the rest of the code as well?
10:46:43 <lseactuary> sure
10:46:45 <[exa]> I like that "KIND OF" way rust people are using
10:46:47 <EvanR> rust has an ownership system
10:46:56 <EvanR> with borrowing
10:47:22 <dyl> Isn't Rust kind of common lisp?
10:47:24 <EvanR> which is like dual to linear types
10:47:41 <dstolfa> rust is ownership + lifetimes for the most part
10:48:18 <EvanR> uniqueness is like dual to linear types
10:48:29 <zachk> dyl how is rust kind of common lisp? rust is statically type and lisp isn't
10:48:37 <lseactuary> kk
10:48:44 <dyl> zachk (it isn't)
10:48:48 <dyl> zachk I was making a joke.
10:48:54 <dyl> Rust is clearly dual to Common Lisp.
10:48:55 <dyl> Or at least adjoint.
10:49:44 <lseactuary> fishythefish- is it ok?
10:49:56 <fishythefish> lseactuary: i'll just leave comments in the paste
10:50:03 <lseactuary> kk
10:50:16 <[exa]> I should make a thing that adds unique_ptrs everywhere to corporate-grade badly-messed C++ source and call it CRust
10:50:50 <EvanR> MS-TRust
10:51:03 <[exa]> ok we have a name
10:51:18 <zachk> dyl, :(
10:51:23 <EvanR> visual rust++
10:51:24 <dyl> std::string s = x.toString(); if (s[0] == 'N' || s[0] == 'n' || s[1] == 'U' || ...) { ... }
10:51:33 <dyl> Glasgow Visual Rust++*
10:51:44 <dyl> Glasgow Visual Rust++.NET*
10:52:01 <dyl> [exa] the best thing to do is just s/struct/union/
10:52:11 <[exa]> ...now with pointers!
10:52:33 <dyl> Instead of non-nullable types, there are types that are always null, to help you write safe code.
10:52:45 <dyl> The other types are duck-nulled.
10:53:01 <ddellacosta> EvanR: I'm confused, I thought affine types were exactly what Rust had?
10:53:17 <EvanR> affine types are similar to linear types
10:53:33 <EvanR> but you arent required to use the argument to a linear function
10:53:59 <[exa]> ddellacosta: Rust prevents sharing writeable references. Affine types prevent unrestricted copying of values. That's a bit different
10:54:11 <ddellacosta> EvanR: I'm responding to where zachk asked, "doesn't rust kind of have affine types?" and I thought you were responding to that when you wrote "no"
10:54:18 <ddellacosta> [exa]: ah okay
10:54:36 <EvanR> right, its common to call all of these different things the same thing
10:54:47 <EvanR> i am going by the linear haskell paper which sorts it out i think
10:54:48 <[exa]> the source analysis for the implementation is mostly similar, but that's true with most compiler stuff :D
10:54:56 <bitemyapp> you aren't required to use a value with an affine type
10:55:04 <bitemyapp> you are with linear
10:55:06 <ddellacosta> it seems like there is confusion even within the Rust community then, not that I'm super familiar with the language or community--just what I was trying to figure out googling
10:55:13 <dyl> [exa] so wait, if every sufficiently complex program contains a compiler... and compiles are databases...
10:55:18 <dyl> compliers*
10:55:20 <bitemyapp> The last time I talked to Rusties they were pretty clear on linear vs. affine
10:55:22 <dyl> compilers*
10:55:25 <EvanR> i have a hard time understanding rust publications
10:55:26 <bitemyapp> and corrected my use of the terminology
10:55:32 <dyl> ddellacosta Rust seems to be importing a lot of the js-hipster types unfortunately.
10:55:53 <[exa]> EvanR: if you're reading the paper, do you have any idea why Morris' and other's approach to linearity is called "linearity by kinds" ?
10:55:55 <dyl> The core team have been very cool in my interactions with them, but the community seems to be drifting lately.
10:56:04 <[exa]> EvanR: e.g. in the Morris paper there are no extra kinds
10:56:27 <[exa]> EvanR: (Morris: Best of both worlds, linear functional programming without compromise, ICFP'16 iirc)
10:56:47 <dyl> bitemyapp they don't really exist materially in Rust
10:56:50 <dyl> but they're a useful mental model.
10:56:54 <dyl> Linear/affine/relevant/etc.
10:57:06 <ddellacosta> this seems like a reasonable explication of how it all fits together in Rust, and the confusion around it (?): https://gankro.github.io/blah/linear-rust/
10:57:13 <EvanR> [exa]: i havent read this one, but ill take a look
10:57:31 <dyl> > The Rust Evangelism Strikeforce
10:57:35 <lambdabot>  error:
10:57:35 <lambdabot>      Data constructor not in scope: The :: t0 -> t1 -> t2 -> terror:
10:57:35 <lambdabot>      â€¢ Data constructor not in scope: Rust
10:57:42 <dyl> Terror D:
10:57:55 <EvanR> @dyl memes screw up lambdabot
10:57:55 <lambdabot> Maybe you meant: url pl do
10:58:04 <dyl> EvanR I know, I just like when it uses "terror".
10:58:52 <[exa]> EvanR: he's got a very nice model for auto-dodging some problems with too much linear stuff in the program, also kindof parallel to Haskell linearity by Bernardy
10:59:01 <dyl> So why do Rust programmers have so much trouble with reduction?
10:59:17 <zachk> reduction?...is this another joke
10:59:23 <dyl> ...what do you think?
10:59:36 <zachk> Maybe Bool
10:59:50 <[exa]> :]
11:01:22 <dyl> So we have all of these can-only-be-used-once, must-be-used-once, etc types.
11:01:42 <dyl> What about types that have to balance reaction rates and stoichiometry?
11:01:44 <dyl> Redox types?
11:02:01 <dyl> e.g. 4Int <-> Vector4
11:02:24 <dyl> What's the type of the one hole contexts of ions?
11:06:24 <zachk> Ion Integer perhaps
11:06:25 <fishythefish> dyl: only a +1 cation is a one-hole context
11:06:42 <fishythefish> a -N anion is an N-electron context
11:06:49 <fishythefish> a +N cation is an N-hole context
11:07:23 <dyl> Ah yes, plasmonic types.
11:08:23 <dyl> The best kind of ION: https://selectbakery.ca/201-large_default/ion-hazelnut-200g.jpg
11:09:52 <whatsatype> I have a question about something that's not specifically about Haskell
11:10:11 <whatsatype> Is there a way to prove that there cannot be a total function of type a -> b?
11:10:28 <whatsatype> I'm aware you can do it using Void, but I was wondering if there was some other way to do so
11:11:08 <EvanR> a -> b means forall a b . a -> b
11:11:20 <EvanR> so you have to prove it for all pairs of types, not just Void
11:11:37 <whatsatype> I thought you could do something like
11:11:44 <whatsatype> AFSOC there exists such a function
11:11:46 <EvanR> i mean, to disprove it, you only have to disprove it for one pair of types
11:11:54 <whatsatype> Yes
11:12:08 <whatsatype> So, for example you could prove that int -> Void is impossible, right?
11:12:12 <EvanR> so... let a=Char, b=Void
11:12:17 <dyl> AFSOC = assuming for sake of contradiction?
11:12:28 <whatsatype> yeah
11:12:45 <codedmart> Anyone familiar with http-client-conduit? I am streaming a file to s3 and want to process a function on each chunk. But I have not done much with conduit.
11:12:57 <codedmart> Is there some examples that anyone could point me to.
11:12:59 <EvanR> oh youre trying a formal proof like, (forall a b . a -> b) -> Void
11:13:01 <whatsatype> But I was wondering if there was some way to disprove it _without_ using Void
11:13:59 <EvanR> is the statement youre trying to prove written using Void as the definition of False ?
11:14:02 <EvanR> then no :)
11:14:10 <whatsatype> Hm
11:15:58 <EvanR> you could use an alternative form of absurdity like, if you had this, you could have a value of any type
11:16:10 <EvanR> forall c . (forall a b . a -> b) -> c
11:16:17 <whatsatype> Yeah
11:16:19 <EvanR> then implement that function
11:17:14 <whatsatype> The thing is, showing that you can obtain a value of a type isn't absurd unless that type is Void
11:17:24 <EvanR> not true
11:17:42 <whatsatype> How else might you do it?
11:17:59 <EvanR> we defined this as being absurd, its not up for debate
11:18:29 <EvanR> otherwise, lets debate whether unsafeCoerce is absurd or not
11:19:26 <whatsatype> I agree it's absurd, but I'm not sure that's the same as proving it can't exist
11:19:39 <EvanR> if thats up for debate, the answer is it does exist
11:19:49 <EvanR> so what are we proving
11:19:55 <whatsatype> So
11:20:23 <whatsatype> I guess it might be worth noting that this question was originally posed in SML
11:20:43 <whatsatype> But the question is essentially "How do you prove that there is no total function with most general type a -> b"
11:20:48 <EvanR> did they establish what it means to prove something doesnt/cant exist, formally
11:21:30 <whatsatype> No
11:21:51 <whatsatype> This was just an ad-hoc question, it's not from a homework assignment or anything
11:22:16 <EvanR> once you do that, you can begin to answer it formally
11:23:07 <EvanR> harder might be to define what total means
11:23:25 <woodson> what xml generator package is mostly recommended?
11:24:33 <dmwit> ?free forall a. a
11:24:34 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
11:24:42 <dmwit> ?free foo :: a
11:24:42 <lambdabot> f foo = foo
11:26:09 <dmwit> Ah, this gives the lie to your question. `a -> b` is inhabited by `undefined` and other such nonsense.
11:27:28 <dmwit> ?free unsafeCoerce :: a -> b
11:27:28 <lambdabot> g . unsafeCoerce = unsafeCoerce . f
11:27:29 * hackage tree-traversals 0.1.0.0 - Functions and newtype wrappers for traversing Trees  https://hackage.haskell.org/package/tree-traversals-0.1.0.0 (NoahEasterly)
11:27:30 <EvanR> whatsatype: a -> b, where a is inhabited, could be considered the statement that all types b are inhabited. besides Void which is defined as being uninhabited, and isomorphic types, you could conjure up types that are not known to be inhabited. then the argument would be, we just magically came to know the unknown without justification
11:27:33 <MarcelineVQ> woodson: If no one ends up having an answer for you I'd reccomend looking at the ones that were updated most recently and see if any of them are good fits for you  https://hackage.haskell.org/packages/search?terms=xml   you can sort them by which were last updated
11:27:45 <mniip> ah is that the free theorem generator
11:28:13 <mniip> ?free map :: (a -> b) -> [a] -> [b]
11:28:13 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
11:28:44 <mniip> that's an interesting take
11:29:08 <woodson> MarcelineVQ: thats what I am doing now, I just wanted to have a bit more insight in general based on more experienced people. Since, I am not too sure how to gauge each packages ..
11:29:11 <EvanR> let b be the list of numbers for which the collatz sequence does NOT terminate
11:29:19 <EvanR> the type of numbers*
11:29:20 <MarcelineVQ> alrighty :>
11:29:44 <woodson> I'm having the same issue with command line tool package
11:29:46 <EvanR> and a be (). then unsafeCoerce (:: a -> b) computes some for you
11:29:58 <MarcelineVQ> which issue is that?
11:30:12 <mniip> % unsafeCoerce () :: [Integer]
11:30:13 <yahb> mniip: []
11:30:22 <EvanR> not list, thats was a mistake
11:30:30 <mniip> where do I collect my $1kk
11:30:30 <woodson> trying to understand if a package will probably be to complex based on the project that I am trying to do
11:30:33 <MarcelineVQ> or what are you wanting to do on the command line you need a tool for
11:30:34 <EvanR> (n:Integer, ...)
11:30:47 <dmwit> whatsatype: From the free theorem above, if `bar :: a -> b`, then `not (bar x) = bar x` for all `x`. There is no defined value for which `not y = y`. Therefore `bar x` cannot return any value -- that is, `bar` cannot be total.
11:30:57 <EvanR> mniip: it was like only $50 or something
11:31:06 <woodson> I am not too sure whether X package is good for Y or Z
11:31:29 <dmwit> whatsatype: Done. No need to appeal to contradiction, I think.
11:31:36 <whatsatype> Hm
11:31:40 <EvanR> % unsafeCoerce () :: (Integer, ())
11:31:41 <yahb> EvanR: ([Segmentation fault]
11:32:16 <MarcelineVQ> woodson: What is your X Y Z for the command line in case a suggestion can be made :>
11:32:18 <woodson> I am trying to build a command line tool that will parse some file from xml to yaml
11:32:22 <woodson> or yaml to xml
11:32:30 <woodson> and execute some ant migration caommand
11:33:10 <whatsatype> dmwit: I'm not sure why you invoke `not (bar x)`.
11:33:13 <EvanR> i am impressed that coercing () to a pair causes segfault
11:33:16 <MarcelineVQ> woodson: neato, in terms of taking commands and options on cli optparse-applicative is the easy starting choice for that
11:33:17 <whatsatype> wouldnt' that constrain b to be Bool?
11:33:19 <woodson> and I need some optionals arguments to determine how i should
11:33:27 <woodson> parse a certain yaml file
11:33:40 <EvanR> whatsatype: you only have to show it for two types a and b, like Bool Bool
11:33:42 <dmwit> whatsatype: Sure it would. But that's allowed -- `bar` has to work for any `a` and `b` the caller chooses. I, the caller, chose `Bool`.
11:33:56 <woodson> Thats what I came to conclusion I looked at cmdArgs and some other but...
11:34:10 <woodson> thats why I wanted advice from people with experience
11:34:17 <woodson> lost noob here
11:34:42 <EvanR> informally... to disprove a forall statement, you just need to find a single counterexample
11:34:51 <whatsatype> Yeah, that makes sense
11:35:08 <whatsatype> However, I'm also not sure I understand how you conclude that `not (bar x) = bar x`
11:35:11 <EvanR> and when you do, your coworkers say youre overanalyzing the situation
11:35:14 <EvanR> nevermind
11:35:35 <dmwit> whatsatype: Here's the free theorem again:
11:35:39 <dmwit> ?free bar :: a -> b
11:35:39 <lambdabot> g . bar = bar . f
11:35:51 <dmwit> whatsatype: I choose `g=not` and `f=id`.
11:36:23 <EvanR> dang how does the free theorem generator work
11:36:25 <mdim> What's the reason for unsafePerformIO to exist in Haskell?
11:36:30 <dyl> What is a free theorem :/?
11:36:35 <EvanR> that too
11:36:42 <whatsatype> Yeah, I was just about to ask what a free theorem is
11:36:46 <dmwit> EvanR: http://www.cs.sfu.ca/CourseCentral/831/burton/Notes/July14/free.pdf
11:36:48 <dyl> Are these GPLâ€™d?
11:37:20 <dyl> Whatâ€™s going on with Wadler? Last I heard he was doing blockchain stuff?
11:37:24 <dyl> Seems like a bit of - left turn.
11:37:28 <dyl> a*
11:37:32 <dmwit> Let's stay on topic.
11:37:34 <MarcelineVQ> a free theorem is when you take parametricity and you use it to squeeze the juice out of a brain
11:37:39 <dyl> Apologies.
11:37:59 <dmwit> (When there's no on-topic discussion, it's okay to wander a bit, but let's avoid noise when there are folks who do actually have Haskell topics to discuss.)
11:39:04 <EvanR> mdim: if you consider unsafePerformIO to be promisePureIO, then its useful to implement purely functional things which nonetheless use the IO type for something
11:39:20 <EvanR> of course youre on your own verifying you did this correctly
11:39:34 <mdim> EvanR: what is promisePureIO?
11:40:07 <EvanR> it has type IO a -> a, and when the result is evaluated, the IO is executed the to get the value, under the assumption that it will have no observable side effects
11:40:15 <EvanR> or otherwise violate whatever thing i care about usually
11:41:00 <EvanR> none of this is obvious or even implied by unsafePerformIO's name
11:41:02 <mdim> hm, I'd say you didn't answer my question
11:41:08 <mdim> EvanR: ^^
11:41:19 <EvanR> oh, why is it called unsafePerformIO ?
11:41:24 <mdim> I'm not concerned with the name
11:41:28 <EvanR> :|
11:41:29 <mdim> rather the type: IO a -> a
11:41:54 <MarcelineVQ> EvanR: partly because you can evaluate pure things as often as you like and get the same result, but doing that with any old IO a can be an issue
11:41:55 <dmwit> mdim: The definition of the FFI spec is conservative: all functions imported via FFI have IO type.
11:41:55 <EvanR> its useful for implementing purely functional stuff that secretly uses IO behind the scenes to accomplish stuff
11:42:05 <mdim> I thought that the IO monad is a one-way monad, i.e., you can't get rid of it once you're in it
11:42:08 <dmwit> mdim: This is sometimes unfortunate, as we can sometimes write pure functions even in other languages.
11:42:15 <dmwit> mdim: unsafePerformIO bridges that gap.
11:42:54 <EvanR> yes math.h foreign functions is an example of where you want it
11:42:56 <mdim> so why would you have to drop to 'a' instead of staying in IO a?
11:43:05 <dmwit> You never have to.
11:43:15 <dmwit> But it is often convenient and sometimes correct to.
11:43:20 <EvanR> you want to
11:43:32 <fishythefish> lseactuary: I gotta go. Good luck!
11:43:40 <lseactuary> oki
11:43:41 <lseactuary> cu
11:43:50 <mdim> what guarantees do I automatically lose by using unsafePerformIO?
11:43:54 <EvanR> you dont want fmod :: Double -> IO Double
11:44:02 <EvanR> you dont want fmod :: Double -> Double -> IO Double
11:44:19 <dmwit> mdim: If you do not use it carefully, you lose referential transparency (and therefore equational reasoning).
11:44:46 <dmwit> (referential transparency: you can always replace a thing by its definition -- its referent)
11:44:49 <mdim> isn't that the whole point of Haskell being pure, i.e., having referential transparency in the whole language?
11:45:07 <dmwit> Yes. That is why "unsafe" is part of the name of "unsafePerformIO".
11:45:23 <dmwit> It is not to be used lightly.
11:45:51 <whatsatype> dmwit: the paper you linked seems to indicate that the type you choose needs to be `List Bool`, not `Bool`
11:45:56 <infinisil> Couldn't you just put the FFI functions in a typeclass over a generic Monad or so? Then you avoid the IO and you can integrate it with your other Monady things
11:45:57 <whatsatype> Or did I misunderstand it?
11:45:58 <EvanR> you lose the guarantee but it doesnt mean its automatically wrong either
11:46:10 <dmwit> whatsatype: You misunderstood it. Can you say why you think I need to choose a particular type?
11:46:14 <marvin3> mdim unsafePerformIO is a backdoor provided by ghc. it is seldom needed, and not something you would use in day to day programming
11:46:15 <int-e> mdim: No, we also want code to be reasonably fast. And we want to use external libraries (unsafePerformIO is part of the FFI specification), as pure functions if the computation is pure. And we do not want to replicate all existing pure functionality in the IO monad.
11:46:31 <EvanR> infinisil: would be pretty inconvenient since math.h stuff is actually pure
11:46:33 <dmwit> infinisil: No. Many FFI imports do actual IO.
11:46:41 <mdim> I'm a Haskell rookie and only today I learned about unsafePerformIO. I believed that absolutely every program you write in Haskell is referentially transparent, but it turns out that's not true
11:46:42 <whatsatype> So, you chose to instantiate b to Bool, since you're providing a counterexample to the claim that bar is total
11:46:51 <EvanR> Integer is implemented with GMP, but we dont have to use IO literally everywhere because of it
11:47:04 <infinisil> dmwit: Ah MonadIO then?
11:47:13 <EvanR> mdim: every program... *you* write? :)
11:47:34 <dmwit> infinisil: That would be safe, but would not address the problem that unsafePerformIO addresses.
11:47:55 <whatsatype> I suppose you also instantiated a to Bool. And the free theorem seems to indicate that (g . bar) = (bar . f) for all (g :: Bool -> Bool) and (f :: Bool -> Bool)
11:47:58 <infinisil> mdim: There's Safe Haskell https://ghc.haskell.org/trac/ghc/wiki/SafeHaskell which disallows things like unsafePerformIO and other weird things
11:48:00 <mdim> EvanR: s/you write/one writes/g
11:48:15 <dmwit> whatsatype: I did not instantiate a to Bool, but I'm not upset if you choose to do so.
11:48:30 <whatsatype> Oh, did you not?
11:48:32 <EvanR> mdim: yes, you have important libraries out there which are using unsafePerformIO for stuff, you hope they did their job correctly
11:48:38 <dmwit> I did not.
11:48:50 <int-e> mdim: The basic rule is not to use unsafePerformIO. But we make exceptions for FFI (as just mentioned) and performance (e.g., Data.ByteString heavily uses unsafePerformIO)
11:48:51 <whatsatype> then how can you do not (bar x)?
11:48:53 <infinisil> mdim: So if you truly want to be sure none of your dependencies or your program does anything the the type doesn't specify, use Safe Haskell
11:48:55 <EvanR> at least we have a benchmark to know if they did
11:49:07 <dmwit> whatsatype: What about the term `not (bar x)` makes you think `x :: Bool`?
11:49:19 <whatsatype> Oh, that's true
11:49:44 <whatsatype> But b is in fact Bool, correct?
11:49:50 <dmwit> yes
11:50:12 <mdim> infinisil: int-e: yeah, thanks for the clarification. I assumed one can prove Haskell programs correct. Now I see one has to use Safe Haskell or an equivalent.
11:50:27 <whatsatype> But in the paper, they say that r must have type `List a -> List a`
11:50:39 <int-e> mdim: And very occasionally for convenience (for example, Debug.Trace uses unsafePerformIO in a way that is actually unsafe, but it saves you from rewriting your pure code in IO just to see a value (say) passed to a function.)
11:50:50 <EvanR> mdim: to further frighten you, haskell programs can also run out of memory and enter an infinite loop that freezes up
11:50:52 <whatsatype> Similarly, a* must have type (List a -> List b), if I understand correctly
11:50:59 <dmwit> whatsatype: No, they give an example about the free theorem you get if `r :: List a -> List a`.
11:51:06 <infinisil> mdim: Correct is a stronger statement though, for correctness you need dependent types or some other sort of formal proofs
11:51:12 <dmwit> whatsatype: The later sections describe the free theorems you get for arbitrary types.
11:51:20 <mdim> EvanR: I know stuff isn't total in Haskell, but at least I was hoping there was no such thing as unsafePerformIO
11:51:43 <mdim> infinisil: I know. Idris is a good step in the right direction.
11:51:44 <whatsatype> Oh, I see. My mistake, sorry.
11:51:51 <EvanR> idris has the same stuff
11:51:56 <EvanR> believe_me
11:51:58 <infinisil> mdim: Idris ftw \o/
11:52:03 <int-e> mdim: (Debug.Trace is "unsafe" in a fairly mild way that is usually okay for debugging: there are few guarantees about how often or in what order the corresponding trace messages are produced)
11:52:19 <whatsatype> I'll take some more time to read through it more carefully
11:52:22 <whatsatype> Thank you!
11:52:34 <infinisil> EvanR: Sure, but idris has a totality checker and very nice dependent types that allow you to do formal proofs in the language itself
11:52:47 <EvanR> ive used idris a lot
11:53:31 <EvanR> i dont want to do formal proofs in it anymore
11:53:34 <mdim> I'm interest in software correctness so that's why I asked that opening question about unsafePerformIO
11:53:45 <dstolfa> mdim: you might have to define "correctness" here
11:53:46 <infinisil> EvanR: Why that?
11:53:46 <mdim> EvanR: what have you switched to from Idris?
11:53:56 <EvanR> its a pain in the ass
11:54:04 <dstolfa> proofs in idris are tedious
11:54:06 <EvanR> and performance suffers once things get too complex
11:54:12 <dstolfa> especially compared to coq/isabelle
11:54:17 <dstolfa> also what EvanR said
11:54:19 <EvanR> and the implicit record thing often doesnt work
11:54:25 <EvanR> and TDNR doesnt really work
11:54:28 <mdim> dstolfa: correct programs are those that meet their specification in such a way that this can be proved
11:54:32 <dstolfa> idris is cool, but has some way to go
11:54:38 <EvanR> and proving totality is too hard
11:54:48 <dstolfa> mdim: right, but what is "program" here?
11:54:55 <dstolfa> you have to constraint what you're proving
11:55:03 <dstolfa> you're making many, many assumptions when doing refinement
11:55:14 <dstolfa> one of them is a memory model, the other is the machine that is executing it and so on
11:55:19 <infinisil> EvanR: Fair enough, when's the last time you used Idris?
11:55:21 <dstolfa> what are you assuming here, and how do you define "correct"
11:55:38 <mdim> dstolfa: of course you make some assumptions and then prove under those
11:55:42 <EvanR> months ago
11:55:56 <dstolfa> right, my question is what assumptions are you willing to make for your definition of "correct"
11:56:31 <absence> Data.Semigroup.Option is redundant in 8.4?
11:56:36 <infinisil> Assuming my program is correct, my program is correct :P
11:56:59 <dstolfa> infinisil: :))
11:57:06 <hodapp> dstolfa: said assumptions usually relate to the soundness of the underlying system of proofs, the correctness of any compilers that are in use, and that hardware behaves according to the abstractions it claims to uphold
11:57:14 <mdim> dstolfa: that's another topic and I believe we're digressing too much from my original question
11:57:32 <dstolfa> hodapp: you can take the compiler out of the equation
11:57:36 <hodapp> dstolfa: which is probably why one refers to the *program* being correct, not literally the entire system including its hardware and including generated binaries
11:57:59 <dmwit> mdim: There is a very, very cheap and complete static analysis for "does this code call unsafePerformIO?". Compared to the rest of your proof effort, that step is going to be nothing.
11:58:13 <dstolfa> hodapp: right, then you should define what you mean by program
11:58:23 <EvanR> mdim: its an interesting exercise to come up with formal systems which accomplish the same stuff as unsafePerformIO but being more verifiable, and usable by a human being
11:58:26 <mdim> dmwit: can you tell me what is the analysis you have in mind?
11:58:34 <dmwit> grep unsafePerformIO
11:58:46 <hodapp> dstolfa: that's almost always up to the language that one is working within
11:58:48 <mdim> dmwit: what about libs my program depends on?
11:58:54 <dmwit> Maybe download your dependencies first, and if you're really paranoid run CPP first.
11:58:57 <dstolfa> hodapp: a program for me is the runnable binary on a given executable format such as ELF, COFF or Mach-O. it uses some instructions, it works under some memory model and so on
11:59:03 * hackage tasty-dejafu 1.2.0.0, hunit-dejafu 1.2.0.0, dejafu 1.5.0.0, concurrency 1.5.0.0 (barrucadu)
11:59:18 <int-e> dmwit: do you trust base?
11:59:22 <hodapp> dstolfa: pretty sure you just defined a "binary"
11:59:30 <barrucadu> If you're proving the correctness of a program, you have to prove the correctness of its dependencies as well.  If you assume they're correct, then regular old Haskell bugs not requiring any unsafe IO will undermine you.
11:59:31 <dstolfa> hodapp: right, from an operating system that's exactly what a program is ;)
11:59:40 <dstolfa> hodapp: but, you can look at "instructions" and "runnable format" as anything
11:59:40 <EvanR> assumption, base is infallible
11:59:48 <hodapp> dstolfa: not really, but it is what a binary is to the OS
11:59:54 <dstolfa> for Erlang, this is BEAM. for Java, this may be JVM, Dalvik, ART, ...
12:00:21 <dstolfa> hodapp: my point is that you have to strictly define what you mean by "program" and "correct" here
12:00:30 <dstolfa> a program means different things to different people
12:00:34 <dmwit> int-e: Deciding on your TCB is indeed an important part of any verification.
12:00:47 <dmwit> Not sure how it's relevant to mdim's concerns, though.
12:01:01 <int-e> dmwit: well grep will find unsafePerformIO in base
12:01:10 <dstolfa> i do most of my work on operating systems and compilers. a program for me is the result of what a linker spits out (that linker can be in any format, wasm, BEAM, JVM, ...) and the thing that is going to be run on top of something
12:01:16 <EvanR> if it doesnt contain unsafePerformIO, that doesnt mean its correct. if it does, it doesnt mean its incorrect
12:01:33 <hodapp> dstolfa: yes, it should come as no shock that if you're going to make up definitions freely, then definitions have a way of acting as if they are made up freely
12:01:39 <EvanR> its really a cultural thing, get the job done thing
12:01:42 <hodapp> this doesn't really relate to formal verification in any way
12:01:51 <dstolfa> hodapp: it does, because that's how it goes wrong
12:02:00 <dstolfa> hodapp: i've seen plenty of proofs not work because of stupidity like that
12:02:22 <hodapp> dstolfa: such as?
12:02:31 <dstolfa> every distributed algorithm ever
12:02:59 <dstolfa> they used a proof assistant which disregarded the fact that something didn't typecheck. guess what, a lot of things were wrong
12:03:01 <mdim> proving a whole system correct is a challenging task. You can take a look at the seL4 project to see what it takes, yet what assumptions they made.
12:03:31 <dstolfa> mdim: yeah, seL4 assumes that the abstract machine is correct, takes the compiler out of the equation for the version of ARM they do refinement for and assume a flat memory model
12:03:56 <hodapp> dstolfa: interestingly, skipping the entire "formal" and "verification" step still doesn't really relate to formal verification
12:04:06 <mdim> I'm interested in way smaller proving, i.e., way more assumptions
12:04:19 <dstolfa> hodapp: right. you can argue in the abstract or you can look at what's actually happening in the verification community. they're different things
12:04:23 <dstolfa> in the abstract, everything is perfect
12:04:34 <hodapp> dstolfa: skipping formal verification completely isn't an issue "in the abstract"
12:04:35 <dstolfa> the moment you enter the real world, you fail to model ISAs due to lack of well defined semantics, therefore you can't prove things on them
12:05:03 <hodapp> dstolfa: that's probably why we've been speaking of correctness of a program, not an entire system.
12:05:04 <EvanR> mdim: maybe you want to try coq or agda, both of which can produce programs in ocaml or haskell respectively, after you prove their correctness
12:05:05 <dstolfa> the proofs on "programs" if you will don't hold due to microarchitectural effects of CPUs and so on
12:05:13 <dstolfa> hodapp: right but again, what is a program
12:05:16 <EvanR> haskell itself doesnt have this
12:05:37 <hodapp> dstolfa: no one here is arguing that the proof by itself is sufficient
12:06:05 <int-e> dstolfa: and don't ask about multithreading or memory ordering
12:06:05 <mdim> EvanR: in that regard, what is the difference between Coq and Agda on one side and Idris on the other? You mentioned that proving in Idris is tedious
12:06:15 <dstolfa> some people consider it to be source code written according to the specification of the language it's being written in. that won't get you far in the world of C, C++ and Rust. others argue it's the thing that the compiler spits out, others argue that it's the thing that the linker spits out
12:06:20 <dstolfa> which one is it
12:06:23 <dstolfa> they all have different properties
12:06:27 <dstolfa> int-e: oh yes, ofc :)
12:06:30 <EvanR> idris is an experiment in using dependent types within your normal programming language experience
12:06:38 <EvanR> coq and agda are both theorem provers
12:06:48 <orbisvicis> is it bad for functions to handle only a single data constructor if the parent code dispatches the right constructor to the right function ?
12:07:33 <mdim> EvanR: in terms of proving, what is the difference? You can prove stuff in Idris as well.
12:07:39 <fishythefish> orbisvicis: meaning your function is technically partial but expects to be called only on valid inputs?
12:07:40 <int-e> dstolfa: Or, looking at Spectre & co., timing side channels. (For memory ordering I can at least imagine a formal model... for timing I have no clue how to even start.)
12:07:49 <orbisvicis> fishythefish: yes
12:08:00 <fishythefish> orbisvicis: in general, I'd avoid that
12:08:31 <hodapp> dstolfa: yes, it should come as no surprise to you that if you are arbitrarily making up definitions, things based on these arbitrary definitions have a way of being arbitrary.
12:08:45 <EvanR> mdim: coq has an entire language of tactics which supposedly make the proving process more streamlined
12:08:52 <dstolfa> int-e: well, spectre & meltdown have to do with microarchitectural side-effects. this is because a CPU does a topsort of a dependency graph of instructions to avoid stalls, has branch predictions to prevent stalls on conditionals and then combines it with speculative execution based on previous branch predictor state. this is not fun, and AFAIK nobody is even trying to model this part of the CPU. there's
12:08:58 <hodapp> EvanR: and there's the paper insisting that Coq is the world's best macro assembler...
12:08:58 <dstolfa> some work on ISA modelling but even that is difficult
12:09:02 <dstolfa> hodapp: right, which is why i asked :)
12:09:10 <mdim> EvanR: Idris has tactics as well, although not as many as Coq does
12:09:20 <fishythefish> orbisvicis: occasionally there are valid uses, e.g. `map head . group`, but you shift the burden from the type system to the programmer to enforce correctness
12:09:29 <EvanR> it doesnt have tactics as such, idris's replacement for tactics is the elaborate reflection monad
12:09:40 <EvanR> which has promise but ....
12:09:58 <EvanR> you will be writing entire strategies yourself, and dealing with bugs in the system
12:10:13 <EvanR> its only a couple years old
12:10:31 <EvanR> elaborator*
12:10:32 <hodapp> why no love for Lean Theorem Prover? :'(
12:10:35 <[exa]> hodapp: link to the paper?
12:10:46 <mdim> EvanR: do you have recommended reading on elaborate reflection or the underlying theory? I was trying to find something, but without luck because I don't even know what to look for
12:10:57 <EvanR> thats because its undocumented
12:11:06 <EvanR> like most things in idris
12:11:07 <hodapp> [exa]: https://www.microsoft.com/en-us/research/publication/coq-worlds-best-macro-assembler/
12:11:22 <EvanR> most of your information will be from reading idris's source code
12:11:26 <hodapp> ewww
12:12:50 <int-e> hodapp: nobody trusts and ITP with less than 20 years under its belt ;-)
12:12:54 <EvanR> mdim: also... irc channel #idris
12:12:58 <int-e> *an
12:13:48 <EvanR> i shouldnt be so doom and gloom about it, idris is a really good opportunity to contribute to a really cool open source project
12:14:11 <EvanR> but thats usually not what people are expecting to do when asking for tools to "get stuff done"
12:14:14 <dstolfa> EvanR: skepticism is good, as is challenging ideas
12:14:22 <orbisvicis> fishythefish: thanks, I can keep my handlers non-partial without any duplicate code or duplicate pattern matching
12:14:43 <mdim> does Coq have an equivalent to IO a -> a?
12:14:54 <EvanR> coq doesnt even do IO heh
12:14:55 <dstolfa> if nobody challenged my ideas, i'd be reinventing the wheel. poorly. :)
12:14:56 <mdim> how about Agda?
12:15:05 <EvanR> nor agda
12:15:23 <EvanR> so you dont have to worry about IO, unsafe or otherwise
12:15:23 <mdim> is there no IO in Agda?
12:15:28 <sqrt2> of course agda does IO
12:15:55 <dstolfa> https://github.com/agda/agda-stdlib/blob/master/src/IO.agda
12:15:58 <EvanR> like, it outputs fancy html of your source code :)
12:16:25 <dstolfa> EvanR: isabelle does LaTeX. pushing that on github results in... insanity
12:16:37 <dstolfa> it's literally impossible to read in anything other than JEdit
12:17:28 <EvanR> mdim: yeah they both have the ability to output programs in other languages that do I/O, that you carefully proved do something or not
12:17:32 <int-e> dstolfa: it can generate HTML (based on the same markup also used in PIDE)
12:17:50 <dstolfa> int-e: can it? i've always just ended up with messy LaTeX in github
12:18:40 * dstolfa really ought to know this as larry's office is literally 20 seconds away from him
12:19:11 <kalimero> i have a question. it's a bit long so i paste it in pastebin: https://pastebin.com/YbUkzWdy
12:19:14 <mdim> EvanR: I'm asking if one can do IO in Agda itself, like in Haskell with the IO monad. dstolfa's link suggests that is the case.
12:19:54 <EvanR> i have never tried, is it limited to like, reading and writing to stdio ?
12:20:11 <EvanR> ive only proved theorems in it
12:21:38 <EvanR> looks like IO.agda lets you read and write the filesystem
12:23:43 <mdim> ok, I believe the discussion is coming to an end. Thanks everybody for it!
12:26:00 <Ariakenom> kalimero, the "y" in eval's comprehension is not []. It has type Int.
12:26:29 <shapr> SHAZAM!
12:26:34 * shapr turns into a Haskell superhero
12:26:39 <Ariakenom> kalimero, "eval r" is  [] though. what does it mean to "y <- []"?
12:27:10 <kalimero> sorry for that. yes thats what i meant :-)
12:27:28 <kalimero> but still the question is on. it's just a typo :)
12:27:32 <kalimero> i will fix it
12:28:38 <hodapp> shapr: errr, what would a Haskell superhero's name be?
12:28:41 <hodapp> and superpowers?
12:29:51 <Ariakenom> kalimero, "eval r" is  [] though. what does it mean to "y <- []"?
12:30:07 <kalimero> Ariakenom: it reanslates to []
12:30:13 <kalimero> *translates
12:30:23 <EvanR> > do {y <- []; return (y + 1)}
12:30:27 <lambdabot>  []
12:30:50 <kalimero> i think. this is what ghci gave me when i did: [a | a <-[]]
12:31:34 <Ariakenom> kalimero, try some simple list comprehensions in ghc. with and without "<- []". I'm sure it will help.
12:33:03 <shapr> hodapp: probably would be able to turn a Haskell AD binding from Automatic Differentiation to to Active Directory
12:33:53 <kalimero> Ariakenom: with a number in the list i get the number. with empty list i get the empty list
12:34:08 <shapr> hodapp: I think a Haskell superhero's name would start with Simon
12:35:18 <kalimero>  [a | a <-[]] -> give me [], [a | a <- [1]] -> give me 1. i still not understand why i get the empty list in my question though :)
12:35:41 <shapr> hodapp: Haskell superhero: Simon Wadler?
12:35:44 <kalimero> of course it gives me [1] and not 1
12:36:50 <EvanR> read... [a | a <- []] as "for all a in []... a"
12:38:14 <EvanR> or "x, where x comes from []"
12:38:24 <kalimero> EvanR: yes i understand it. i not understand why the 'y' in my question is not the empty list?
12:38:49 <kalimero> or what is 'y' exactly?
12:39:50 <EvanR> it would be an Int, since eval r is a [Int]
12:41:03 <EvanR> but since youre saying eval r is [], you never get as far as that, since theres nothing to draw from []
12:41:59 <kalimero> but if i just do this: eval (App Sub (Val 2) (Val 3)) i get the empty list in return and as i understand (maybe i do not understand :-D) this (the empty list) is returned to the y from the first list comprehension. where is my mistake?
12:42:28 <EvanR> y is not a list
12:42:59 * hackage dde 0.2.0 - Delay differential equations  https://hackage.haskell.org/package/dde-0.2.0 (penkovsky)
12:43:17 <EvanR> it better not be, since apply does not take lists
12:44:05 <EvanR> similar y is not a list here
12:44:12 <EvanR> > map (\y -> y + 1) [1,2,3,4]
12:44:15 <lambdabot>  [2,3,4,5]
12:45:03 <EvanR> and here its not anything!
12:45:07 <EvanR> > map (\y -> y + 1) []
12:45:10 <lambdabot>  []
12:46:16 <kalimero> EvanR: those both examples are clear to me. but i still don't understand what is going on in the function itself.
12:46:29 * hackage network 2.6.3.5 - Low-level networking interface  https://hackage.haskell.org/package/network-2.6.3.5 (dukerutledge)
12:49:26 <Ariakenom> kalimero, try ghci with 2 variables like your example "x<- [...], y<-[...]". And with more than 1 item in the list
12:52:55 <Ariakenom> [(x,y)| x <- [1], y<-[10]]     [(x,y)| x <- [1,2], y<-[10]] [(x,y)| x <- [1], y<-[10,20]]      and also some empty lists
12:57:24 <EvanR> [(x,y) | x <- stuff, y <- otherStuff ]... "the list of all x paired with y, where x is drawn from stuff, and y is drawn from otherStuff" yeah i dont have a compelling way to say it
12:57:46 <EvanR> cartesian product
13:12:17 <kalimero> EvanR: and Ariakenom: i understand all the examples here :-)
13:13:14 <Ariakenom> kalimero, with empty lists?
13:14:14 <kalimero> i didn't try replace your list comprehensions with empty lists.
13:14:33 <Ariakenom>  [(x,y)| x <- [1,2], y<-[10]] [(x,y)| x <- [], y<-[10,20]]
13:14:44 <kalimero> yes i ran this
13:14:49 <kalimero> those 2
13:14:55 <kalimero> ah no
13:14:56 <kalimero> wait :)
13:14:59 <kalimero> i will ran it now
13:15:15 <kalimero> (i thought it's the examples from above)
13:16:06 <kalimero> Ariakenom: well this is interesting.
13:16:15 <kalimero> why is this happening?
13:17:28 <Ariakenom> what happens to the number of elements if you add something to one of the "<-[]" lists?
13:18:08 <kalimero> do you mean likw that?  [(x,y)| x <- [1], y<-[10,20]]
13:18:56 <kalimero> it takes 1 from the x and first argument from the y and tuple them and then again the 1 from the x and tuples with the second argument og y
13:19:12 <kalimero> *of
13:19:16 <Ariakenom> what if you use [1,2] instead of [1]? How many elements more do you think there will be in the result?
13:20:03 <kalimero> it will give me [[1,1],[1,2],[2,1],[2,2]] (i think. didn't check)
13:20:26 <kalimero> ah of course i made y to be [1,2] also
13:20:39 <kalimero> i forgot it's [10,20]
13:20:51 <kalimero> but it will be 4 elements
13:21:27 <kalimero> and of course tuples and not lists inside a list :)
13:21:53 <Ariakenom> ye
13:22:13 <Ariakenom> whats the relation between nr of elems in inners to outer?
13:23:08 <kalimero> so if 1 of the elements in the list comprehension is the empty list, and i need to use this element in the result, i return empty list because it can't use any element from this list because it's empty?
13:23:36 <Ariakenom> indeed, you have no choice
13:24:14 <infandum> https://hackage.haskell.org/package/typed-spreadsheet-1.1.2/docs/Typed-Spreadsheet.html#t:Updatable This library expects a value to return as Diagram B, but I have IO (Diagram B) -- is there anything I can do?
13:24:29 * hackage syb-with-class 0.6.1.9 - Scrap Your Boilerplate With Class  https://hackage.haskell.org/package/syb-with-class-0.6.1.9 (JeremyShaw)
13:24:35 <infandum> For graphicalUI
13:24:52 <kalimero> so in my exxample: eval (App Add (Val 1) (App Sub (Val 2) (Val 3)))
13:25:37 <kalimero> y will be eval (App Sub (Val 2) (Val 3))
13:26:12 <kalimero> and x will eval to 2 and y will eval to 3
13:26:47 <kalimero> but the validate is False (because 2 - 3 is minus) so what will be return?
13:27:14 <kalimero> or from there it exist without returning anything but the empty list?
13:27:19 <kalimero> exist = exit
13:29:49 <lyxia> infandum: use (>>=) ?
13:30:50 <infandum> But I need to return a Diagram B, not an IO (Diagram B)
13:30:56 <Ariakenom> kalimero, yes. probably think of the list as possible answers
13:31:54 <infandum> So I can't call a function in IO in the Updatable type
13:33:11 <infandum> Updatable (Diagram Cairo) is the second argument, not Updatable (IO (Diagram Cairo))
13:34:08 <infandum> I think I can copy and paste the code to make a new function maybe
13:34:44 <infandum> like a graphicalUI', but that's not ideal
13:36:07 <kalimero> Ariakenom: just to see if i understand you: when in the inner list comprehension get the empty list, it exit immediately (with the empty list) and not get out to the outer list compregension?
13:38:01 <Ariakenom> kalimero, yes.
13:38:11 <dmwit> infandum: If `f :: Diagram B -> IO ()`, then `(>>=f) :: IO (Diagram B) -> IO ()`.
13:38:30 <kalimero> thanks Ariakenom
13:38:31 <kalimero> :-)
13:38:40 <Ariakenom> kalimero, if you view lists as several possible answers. And list comprehensions as combining them
13:39:46 <Ariakenom> kalimero, if you want to do all possible divisions and you have no possible dividend. Then you have no possible division. [x / y | x <- [], y <- ys]
13:40:26 <Ariakenom> kalimero, and yw!
13:40:40 <kalimero> what is yw?
13:40:55 <Ariakenom> You're welcome!
13:41:38 <kalimero> ah :-)
13:41:48 <Ariakenom> kalimero, nice format for the question. You listed many of your assumptions and your thought processes.
13:43:17 <kalimero> Ariakenom: :-)
13:43:36 <EvanR> yeah... try to answer [(x,y) | x <- [], y <- [1,2,3]] in any way other than []
13:43:40 <EvanR> you will not get far
13:44:23 <kalimero> do you both programming in haskell profesionally?
13:46:31 <Ariakenom> I don't. C and Python
13:47:45 <kalimero> can you use haskell as you use c or python? do you know it well like those both?
13:48:59 <maerwald> that's an odd question
13:49:05 <EvanR> i eat C for breakfast from 2000-2010, haskell from 2008-2018, so by the law of brain cells being a limited resource, C holds in my mind more
13:49:36 <EvanR> but ill get way more done in haskell
13:49:43 <maerwald> depends on what you do
13:50:02 <Ariakenom> I don't know Haskell as well. It wouldn't work for the C stuff. It's embeddded, high speed and low memory consumption.
13:50:13 <EvanR> except for the funny fact that haskell doesnt run on microcontrollers, so it is disqualified at my day job
13:51:11 <Ariakenom> I could use it instead of python for tools, tests and such. But I have a team that knows Python.
13:51:50 <EvanR> imagine if you had a team that only knew malbolge
13:51:58 <EvanR> what a predicament
13:52:56 <Ariakenom> Not at all. You could convince them to learn anything else. They'd be ecstatic :0
13:53:19 <EvanR> i mean... are you sure
13:54:53 <kalimero> is there a plan to make ghc (or something else) to compile haskell to C which will benefit from both worlds? can it be done?
13:55:36 <EvanR> exactly what benefit are you getting at there
13:55:49 <maerwald> F* is trying to do that to some extent for the everest project, but not in haskell
13:55:56 <kalimero> the speed of C and it vould work with your microcontrillers :)
13:55:59 <EvanR> (ghc used to compile haskell to C and no longer does)
13:56:03 <maerwald> and formal verification
13:56:05 <kalimero> vould = could
13:56:08 <maerwald> which is a big advantage
13:56:39 <Ariakenom> EvanR, can ghc no longer compile to C at all?
13:56:52 <EvanR> kalimero: speed, that does not compute since you would be dealing with the C runtime system which is not tailored to haskell's unusual preferred implementation
13:57:23 <EvanR> work with microcontrollers, that does not compute because haskell uses butt loads of virtual memory
13:58:56 <jackhill> but there are DSLs in Haskell like Atom for writing C with real-time properties that could be useful in a microcontroller scenario
13:59:50 <yushyin> or copilot, ivory
14:01:42 <EvanR> i can imagine a benefit though
14:02:19 <EvanR> if you hypothetically wanted to target a platform which has C implementations but nothing like llvm or a nice architecture
14:02:48 <EvanR> thats hypothetical
14:06:00 <Ariakenom> There is something on ghc commentary, might be outdated. https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/PprC
14:09:40 <AndreasK> Ariakenom: As far as I know compiling to C requires a special build of GHC (unregistered build, https://ghc.haskell.org/trac/ghc/wiki/Building/Unregisterised)
14:15:03 <EvanR> ok... what is the point of (^^) :: (Fractional a, Integral b) => a -> b -> a, when is this a thing and (^) (Num a) is not
14:16:08 <EvanR> is it just a potentially more efficient implementation of the same thing for a Fractional ?
14:18:26 <c_wraith> EvanR, it might get better precision at the cost of performance by working in Rational? not sure.
14:19:05 <fishythefish> (^) requires the power to be nonnegative
14:19:36 <EvanR> > 4 ^^ (-1)
14:19:38 <lambdabot>  0.25
14:19:40 <EvanR> oh
14:20:01 <EvanR> forgot about negatives
14:39:00 <chammill> Hi all, does anyone have experience using Ed Kmett's AD library with any linear algebra libraries? I tried my hand on hooking it up to repa but ran into some difficulties. Ideally I'd like to use it with accelerate or linear-accelerate.
14:39:05 <Welkin> I am getting nothing but type errors using lucid today
14:39:22 <Welkin> I haven't used any html combinator libraries for a while, so this is a terrible experience coming back to them
14:39:52 <Welkin> constant complains about things being ambiguous, but I have no idea what tpy to even give it because the entire API is polymorphic out the ass
14:42:04 <Welkin> maybe I should just throw it out and go back to blaze
14:42:20 <EvanR> is there documentation
14:42:29 <mclark1129> Is there a nicer way to work with union types using aeson, or is my only option to resort to writing all the serialization by hand?
14:43:05 <Welkin> EvanR: if you count autogenerated haddocks as documentation
14:43:08 <Welkin> which I do not
14:43:25 <Welkin> a note on documentation, thank you for reminding me
14:43:26 <EvanR> no
14:43:37 <Welkin> I was browsing the docs for postgresql-simple last night
14:43:38 <Welkin> and holy shit
14:43:49 <Welkin> that has got to be the most thorough documentation I have ever seen in haskell
14:44:13 <EvanR> yeah theres a few libs like that
14:44:17 <Welkin> it got me very excited to use it and get away from persistent
14:50:58 <cyberon> Hello, I'm new to this.
14:51:15 * mclark1129 waves at cyberon
14:52:20 <cyberon> I joined because someone on Hacker News said this IRC was awesome. Are questions unrelated to Haskell allowed?
14:52:20 <Welkin> cyberon: get out while you can
14:52:57 <EvanR> no this channel is only for haskell, despite what haskernews may have said
14:53:10 <EvanR> freenode is in general awesome
14:53:22 <Welkin> except for that whole lilo thing
14:53:25 <Welkin> you know
14:53:33 <EvanR> no i dont, sounds off topic
14:53:38 <Welkin> which is why we should move to OFTC
14:53:43 <cyberon> how is haskell, only language that I was learning close to it is mit-scheme from sicp.
14:54:16 <Welkin> cyberon: it's like scheme on steroids
14:54:17 <EvanR> well it isn't really like scheme at all, but many things you saw in SICP will apply
14:54:28 <EvanR> plus more!
14:54:49 <Welkin> it's like scheme in that you can write it however you want
14:55:16 <Welkin> some people like endless abstractions, others like to keep it simple
14:55:21 <cyberon> how do i message in irssi im an irc noobie..
14:55:58 <shapr> cyberon: I haven't tried irssi, perhaps there's an easy to google tutorial?
14:56:10 <shapr> cyberon: welcome to #haskell ! You can learn a bunch of awesome stuff here!
14:56:26 <Welkin> irssi has a high learning curve
14:56:32 <Welkin> and it kind of sucks, but I got used to it
14:56:41 <Welkin> it's written in perl
14:56:42 <EvanR> you can write it however you want, unless ghc stops you
14:56:57 <Welkin> most irc clients are about the same when it comes to commands
14:57:03 <Welkin> use /msg for private messages
14:57:08 <sl2c> Welkin: i thought irssi was written mostly in C with perl plugins
14:58:13 <cyberon> What are notable things you can make with a language like Haskell?
14:58:30 <cyberon> How is it powerful?
14:58:39 <shapr> cyberon: same things you can make with other programming languages, but we have awesome abstractions!
14:58:41 <Welkin> that is a poor excuse for a question
14:58:43 <Welkin> o.o
14:58:45 <shapr> Welkin: be nice
14:58:57 --- mode: ChanServ set +o shapr
14:58:58 <sl2c> cyberon: i made some cool mastodon bots with haskell
14:59:01 <Welkin> it's a general purpose programming language, so you can program with it
14:59:06 <shapr> Welkin: or else
14:59:14 <cyberon> I'm def gonna start learning it after I get a good grasp of C, I'm a beginner programmer :P .
14:59:34 <shapr> cyberon: one thing I like about Haskell is that I can describe how to map over anything with Functor
14:59:48 <Welkin> you might like it, you might not
14:59:50 <Welkin> it depends
14:59:52 <Welkin> just try it
14:59:52 <sl2c> cyberon: honestly i might learn haskell first unless you have some really low-level stuff you want to do
15:00:01 <EvanR> yes do haskell first, then C
15:00:05 <shapr> in Python there's no easy way to write code that walks over a bunch of nested lists and dictionaries doing the same operation on each thing
15:00:10 <EvanR> or at the same time
15:00:11 <Welkin> who cares about technical and fake-objective comparisons
15:00:14 <shapr> Welkin: dude
15:00:17 <Welkin> all languages are about the same
15:00:19 <cyberon> I already know python
15:00:33 <shapr> cyberon: I came to haskell from Python, lots of good equivalences
15:00:58 <cyberon> So what is haskell good for, when compared to python
15:01:05 <Welkin> haskell is fun to write and means I spend less time screaming at my computer and flipping over the desk
15:01:13 <Welkin> whereas with python, I could spend all day shouting
15:01:21 <johnw> Profpatsch: ping
15:01:22 <srhb> cyberon: Mostly describing what your program does and does not do, in my experience.
15:01:39 <srhb> cyberon: Especially without observing it run first. :-)
15:01:59 <shapr> cyberon: I've have problems where Python source code worked as long as everything went well, but the other branch of an if statement would kill the program, that's much more difficult to do in Haskell
15:02:06 <mclark1129> As a haskell beginner myself, I just like that it really forces to change how you think.
15:02:26 <shapr> I like that I can substitute in the values for anything at the type or value level in Haskell to understand the final result.
15:02:27 <mclark1129> I can struggle all day on something, end up writing like 5-6 lines of code and still have learned a lot about using haskell
15:02:27 <EvanR> yes its like the difference between night and day, whether you can feel good about the working-ness of your code before you actually run it
15:02:37 <cyberon> is the haskell hype overblown?
15:02:43 <shapr> cyberon: I don't know, what's the hype?
15:02:46 <EvanR> which carries over to other languages once you get used to it
15:02:47 <mclark1129> all hype is overblown
15:02:49 <johnw> cyberon: I don't think so
15:02:49 <Welkin> cyberon: no, it's just that everything else is just so bad
15:02:51 <srhb> I didn't know there was Haskell hype, but it sounds great!
15:02:51 <glguy> Yeah, there's not as much hype as people say
15:02:57 <Welkin> the bar is low
15:03:03 <EvanR> there is haskell hype? cool
15:03:12 <mclark1129> haskell has a phenominal hype system
15:03:17 <shapr> mclark1129: SO PUNNY
15:03:17 <EvanR> lol
15:03:19 <srhb> Software is like *really* horrible.
15:03:25 <shapr> @remember mclark1129 haskell has a phenominal hype system
15:03:25 <lambdabot> Done.
15:03:31 <Welkin> don't let anyone fool you. The type system will drive you insane for the first few months
15:03:31 <mclark1129> lol
15:03:34 <Welkin> you will hate it
15:03:38 <Welkin> but then you get used to it, abd may even learn to like it
15:03:48 <EvanR> you could have fixed the type before enshrining it in quote
15:03:49 <johnw> yeah, it's funny how the brain evolves working with Haskell
15:04:03 <EvanR> typo
15:04:10 <johnw> the other day I was doing some stuff that seemed straightforward, but I realized that earlier me would have spent hours puzzling over the type errors
15:04:14 <Welkin> it's kind of like emacs in that regard
15:04:35 <mclark1129> Yeah I just recently finished an end to end todolist API example
15:04:36 <shapr> EvanR: yeah, could have. Maybe next time
15:04:42 <shapr> mclark1129: ooh, is it on github?
15:05:01 <mclark1129> shapr: tis - https://github.com/mclark1129/haskell-todo-api
15:05:24 <mclark1129> At first I stayed away from todo, thinking it was too basic to be helpful
15:05:38 * shapr tries it
15:05:40 <mclark1129> it actually sent me through a lot of language features, and forced me to get my head around things like monad transformers
15:05:42 <Welkin> what really drives me crazy even today is when I am working with a library that is almost entirely made up of type classes
15:05:47 <Welkin> and then the errors make no sense
15:06:02 <Welkin> then you have to read the source code
15:06:30 <shapr> cyberon: we have lambdabot here for basic demos, interested?
15:06:53 <shapr> I haven't done a quick tour in a few years
15:07:06 <Welkin> I feel like it's still a problem in haskell where people create too many layers of abstraction and try to make everything as generic as possible
15:07:12 <EvanR> "let me introduce you to some basic category theory"
15:07:40 <shapr> I like that I have the option to add layers of abstraction in Haskell.
15:07:44 <srhb> The errors are great, the error messages not quite so...
15:07:49 <shapr> Go lang, Python, not so great at abstracting.
15:07:57 <EvanR> is there such a thing as too many layers of abstraction? :)
15:08:01 <Welkin> sure, but it can be taken too far
15:08:03 <EvanR> (that is, proper abstractions)
15:08:35 <Welkin> it's like lisp macros
15:08:52 <c_wraith> Welkin, I feel like most languages prevent trivial abstractions in bizarre ways. haskell gets in the way of fewer of them.
15:08:56 <shapr> cyberon: any particular demo code you'd like to see?
15:09:01 <MarcelineVQ> :>
15:09:03 <shapr> ah, too bad
15:09:03 <EvanR> if youre 9 levels up, and something is broken at level 2 (but you dont know it) thats bad. but thats not how its supposed to work
15:09:40 <EvanR> and really, youre always at least 9 levels up
15:09:44 <EvanR> regardless of language
15:09:45 <shapr> Welkin: write your own language that's better?
15:10:02 <Welkin> shapr: it's not a problem with the language, it's a problem with the users
15:10:07 <shapr> that could be a good way to focus your anger towards improvement?
15:10:11 <Welkin> who abuse it (in my opinion)
15:10:13 <shapr> oh, you should go fix all the users then?
15:10:16 <Welkin> what anger?
15:10:29 <EvanR> hitler, arguement over
15:10:36 <shapr> ha
15:10:38 <MarcelineVQ> iiuc Go's design goal was to fix the users
15:10:46 <shapr> good point
15:11:03 <maerwald> hm?
15:11:10 <EvanR> fix all the users who didnt rage quit their java job and move to haskell?
15:11:20 <Welkin> I wouldn't waste my time writing my own language unless it was some super specific DSL for me to build a specific thing I needed to build
15:11:38 <EvanR> every data type you define is a language
15:11:42 <maerwald> people do abstraction in go, which is the problem
15:11:44 <Welkin> and then it would probably be in lisp anyway
15:11:51 <EvanR> o_O
15:12:10 <EvanR> somebody replaced Welkin
15:12:22 <shapr> Welkin: maybe you'd create a language you enjoy writing?
15:12:38 <Welkin> shapr: I don't know where you got the impression that I don't enjoy haskell
15:12:50 <Welkin> it's the most enjoyable language I have used so far
15:13:03 <Welkin> why else would I write a book on it?
15:13:37 <maerwald> now you can promote your book, how much will it cost?
15:14:19 <EvanR> i should write a book about a language i really hate, and see how much money i can get
15:14:26 <Welkin> javascript?
15:14:33 <Welkin> that's been done already
15:14:39 <EvanR> thats gotta be a thing people do already
15:15:00 <Welkin> language wars are dumb
15:15:10 <EvanR> if its hard work, you get paid right
15:15:33 <maerwald> people like to feel elitist
15:15:59 <Welkin> I made way more money sitting around pretending to work and chatting with coworkers than I ever made working my ass off 16 hours a day
15:16:17 <mclark1129> Anyone here using haskell in production?
15:16:26 <maerwald> Welkin: I can relate to that and it's fun
15:16:29 <EvanR> if i wanted antisocial opinions on humanity i would go to the bar
15:16:47 <maerwald> lol
15:17:26 <shapr> I like working hard.
15:17:45 <shapr> I also like making enough money to buy food and pay for a place to live. Past that? it's just whuffie.
15:17:51 <maerwald> slave...err, work ethic is what they call it
15:17:59 <EvanR> the life of a free software engineer :)
15:18:05 <Welkin> free-range?
15:18:06 <EvanR> all your tools are free
15:18:13 <EvanR> and materials
15:18:18 <shapr> maerwald: I don't like spending all my hard work *at* work though. I spend most of my hard work on stuff I do for myself.
15:18:21 <Welkin> nothing is free
15:18:33 <maerwald> not even love?
15:18:34 <Welkin> the payment is your eternal soul
15:18:49 <EvanR> cue the patriotic country song
15:19:36 <Welkin> Oh Ka-zahk-stan! The great-est count-ry in --- the wo-rl-d!""
15:20:10 <orbisvicis> is something like "f a b c = doF a b c; f = pointFree'" possible ?
15:20:35 <EvanR> @pl f a b c = g a b c
15:20:36 <lambdabot> f = g
15:20:54 <Welkin> The leading exporter of uranium
15:20:55 <EvanR> f = doF
15:21:22 <maerwald> > "f a b c = doF a b c; f = pointFree'"
15:21:25 <lambdabot>  "f a b c = doF a b c; f = pointFree'"
15:21:26 <maerwald> looks like a valid string
15:22:00 <EvanR> reformulate your question in the form of an answer
15:23:22 <orbisvicis> can I mix pointfree and non-pointfree in different patterns of the same function definition ?
15:23:45 <orbisvicis> btw, non-pointfree is what, "pointfull" ?
15:23:55 <EvanR> yeah
15:24:36 <Welkin> it's called pointless style
15:24:45 <Welkin> and the opposite is just... normal style
15:25:11 <EvanR> though i image questions about normal style would fall flat
15:25:14 <Welkin> and pointless is a good name for it, because it lacks points, but it is also a pointless exercise in frustration, especially for your future self
15:25:37 <Welkin> it should be used sparingly, like anything that is potent
15:25:44 <fvh> hey guys, do anyone have a snippet how to download email attachement via imap with Haskell.Net library? it's pretty low level and going into multipart stuff seems tedious task.
15:25:50 <maerwald> if pointfree is intuitive, then use it, if you need to use @pl or ask here, you're already doing it wrong
15:26:14 <EvanR> every time ive had to compute the pointfree form of something, the result was not something i wanted to use
15:27:10 <maerwald> the time you need to think of a shorter term is probably 3 times the time you need for understanding it when you next look at it
15:27:21 <maerwald> err, 1/3
15:27:47 <Welkin> if you truly want to understand pointless style, watch this https://www.youtube.com/watch?v=seVSlKazsNk
15:28:05 <Welkin> it teaches eta reduction and eta substitution
15:28:14 <maerwald> verbosity is not as bad as people think it is
15:28:26 <Welkin> look at apl
15:28:27 <orbisvicis> anyway, can they be mixed? GHCi gives "different number of parameters" error, when for my default case I would like to try (const . otherFunc)
15:28:45 <maerwald> it's annoying, but your brain gets used to verbosity way easier than to obfuscated code
15:28:45 <Welkin> yes, it is just composition
15:28:59 <EvanR> any minute APL and regex people will disagree with you maerwald
15:29:00 <Welkin> clarity is more important to me than anything else
15:29:04 <maerwald> EvanR: haha
15:29:09 <Welkin> when pointless style makes it more clear, then use it
15:29:14 <Welkin> when it obscures, avoid it
15:29:28 <maerwald> EvanR: then again, perl is the perfect proof of it
15:29:37 <maerwald> a language to write, not to read
15:29:54 <EvanR> that may be the defining line between languages
15:30:15 <EvanR> whether its mostly a guy in a basement getting something done that no one will ever see
15:30:19 <Welkin> you mean like dissertations?
15:30:23 <EvanR> or its a team of people trying to help each other
15:31:02 <EvanR> if you dont expect anyone to ever read or care about your code, you use APL, and the cycle supports itself
15:31:37 <EvanR> now that we have haskell hype, hopefully we arent stuck in the basement
15:31:54 <maerwald> it's the attic
15:31:55 <maerwald> xD
15:32:00 <EvanR> the ivory attic
15:32:05 <Welkin> no, we just get endless media coverage about monads being burritos
15:32:36 <EvanR> the point is... super terse information dense or elaborated wordy
15:32:53 <EvanR> code
15:32:58 <maerwald> I want pictures
15:33:01 <maerwald> text sucks
15:33:01 <Welkin> the codeless code?
15:33:09 <Welkin> hm, that reminds me
15:33:15 <maerwald> but engineers are still stuck with the concepts of writing text
15:33:15 <Welkin> I need to write that chinese programming language
15:33:15 <EvanR> symmetric monoidal category code?
15:33:46 <Welkin> you don't think in pictures, you think in ideas
15:33:54 <maerwald> afair there are some visual-driven things in automotive industry that emit C code and you can switch between both representations
15:34:02 <maerwald> but all proprietary crap
15:34:03 <EvanR> dang
15:34:18 <EvanR> ... sounds kind of weird
15:34:27 <EvanR> i dont want to see the picture of what C code i just wrote
15:34:39 <maerwald> you express the logic in visual stuff
15:34:54 <maerwald> and it throws out embedded C code or something
15:35:07 <Welkin> you mean LabView?
15:35:17 <maerwald> no, it was some certified thing
15:35:18 <maerwald> I forgot
15:35:35 <maerwald> automotive is full of standards and law crap
15:35:40 <EvanR> does it allow mutable objects
15:35:47 <EvanR> whats the picture for that
15:35:53 <Welkin> does it allow singleton factory managers?
15:36:15 <Welkin> and Free Moonads?
15:36:29 <maerwald> moon ads
15:36:30 <Tuplanolla> Have you seen the thing danilo2 is working on?
15:36:37 <Welkin> no
15:36:42 <Tuplanolla> http://www.luna-lang.org/
15:36:54 <Welkin> oh yeah
15:36:57 <Welkin> I remember that
15:37:03 <yushyin> maerwald: Simulink?
15:37:07 <Welkin> unfortunately it makes me think it is based on lua because of the name
15:37:14 <Welkin> then I am disappointed when it is in haskell :(
15:37:30 * hackage hw-xml 0.1.0.3 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-xml-0.1.0.3 (haskellworks)
15:37:36 <maerwald> yushyin: don't make me look it up, I'm playing a visual novel in parallel here :/
15:39:44 <EvanR> turn to page 137, youre dead
15:40:59 <maerwald> imagine programming would be the act of making decisions in a visual novel, such meta
15:41:14 <Welkin> which waifu?
15:41:53 <EvanR> type inference / checking is kind of like choose your own adventure
15:42:33 <EvanR> if two facts contradict at some point, youre dead
15:42:45 <Welkin> the compiler explodes
15:43:02 <EvanR> and you have a choice at various points what to investigate next
15:43:38 <EvanR> if its proof search, the adventure may never end
15:43:39 <Welkin> or to eat the shovel
15:43:42 <Welkin> which I always do
15:43:45 <maerwald> I was once thinking about making a game that relies on git mechanics, in the sense that you can checkout old game states and need to merge states in order to advance in the plot
15:43:45 <Welkin> and then it's game over
15:43:45 <Welkin> dead
15:44:14 <Welkin> remember to use the psychiatrist that comes bundled with emacs
15:44:20 <maerwald> xD
15:45:30 * hackage hsqml 0.3.5.1 - Haskell binding for Qt Quick  https://hackage.haskell.org/package/hsqml-0.3.5.1 (RobinKay)
15:48:46 <cyberon> l
15:52:19 <EvanR> interval analysis: imprecise inputs, even more imprecise outputs, accurate. floats: super precise input, super precise output, accuracy ???. something cool: improving inputs, improving outputs (scott continuous), accurate
15:52:43 * EvanR waits
15:52:59 * hackage turn-loop 0.0.0 - Manage multiple turned-based sessions  https://hackage.haskell.org/package/turn-loop-0.0.0 (jxv)
15:56:51 <EvanR> and if you try to do interval analysis on floats, you run into the wacky rounding behavior
15:57:07 <EvanR> s/on floats/with floats/
16:06:14 <phadej> EvanR: http://www.johngustafson.net/pdfs/BeatingFloatingPoint.pdf
16:07:17 <EvanR> right, posit. this is kind of less interesting than unums because its just floats with some details fixed
16:07:37 <EvanR> and posits have a fixed precision
16:08:20 <EvanR> posits would be cool to have in hardware, but who is going to retool everything for relatively little fundamental gain
16:08:44 <EvanR> i guess brand new silicon for "machine learning"
16:11:22 <EvanR> gustafson is really good at trolling people with horrible example failures of floats
16:14:30 <EvanR> i recall high school insisting that precision and accuracy are different, and here we are with floats which, especially with transcendental functions, merely very precise
16:14:46 <EvanR> \o/
16:15:13 <mcafffe> Hi Haskellers I am supposed to learn groovy in my job, I am in mid way of my haskell. Any Haskeller have experience with groovy
16:17:48 <hpc> EvanR: variably precise
16:18:01 <hpc> (that is in fact, the whole purpose of floats)
16:18:31 <EvanR> its got exactly 52 bits of precision
16:19:15 <EvanR> whose intermediate computations require like 330 bits of precision to get right
16:19:50 <EvanR> if you used rationals to carry out the same stuff, youd end up with even more bits as collatoral damage
16:20:46 <dyl> What if it turns out that machine learning training processes only work because of floating point issues and numeric instability?
16:20:52 <EvanR> haha
16:20:56 <dyl> We â€œfixâ€ those problems, and cars start crashing.
16:21:05 <dyl> The name â€œmachine learningâ€ irks me though.
16:21:17 <dyl> Itâ€™s not learning, itâ€™s more akin to conditioned reflex.
16:21:35 <dyl> Itâ€™s useful, and interesting, but itâ€™s not learning in any meaningful sense.
16:21:37 <dyl> Â¯\_(ãƒ„)_/Â¯
16:21:59 <EvanR> humans = quantum consciousness, machines = mysterious float rounding
16:22:32 <dyl> In the year 2095, 16 bit floating point sentience is perfected.
16:23:55 <dyl> EvanR when the machines win, weâ€™ll have to deal with gloating point consciousness.
16:24:28 <hpc> dyl: in my head i read "machine learning" as "fancy newton's method"
16:24:43 <dyl> I read it as â€œgradient ascent + Bayesian networksâ€.
16:24:58 <dyl> Or expectation maximization + layered Bayesian networks more properly.
16:25:24 <hpc> think more reductionist
16:25:29 * hackage influxdb 1.5.1 - Haskell client library for InfluxDB  https://hackage.haskell.org/package/influxdb-1.5.1 (MitsutoshiAoe)
16:25:37 <hpc> given a few points on an unknown formula, approximate the formula
16:26:00 <dyl> I believe that ANNs are more general approximators though.
16:26:02 <hpc> everything else is implementation details
16:26:40 <dyl> Newtonâ€™s method only really works for real-values functions. And it requires f âˆˆ C0 at least
16:26:48 <dyl> real-valued
16:26:58 <dyl> You canâ€™t use Newtonâ€™s method for classifiers very easily.
16:27:33 <dyl> This is true of all of the Householder methods.
16:27:53 <dyl> (Newtonâ€™s method is just the order 1 Householder method)
16:27:57 <hpc> dyl: not if you don't make it /fancy/!
16:28:12 <dyl> ML = Newton + jazz hands and glitter
16:28:39 <dyl> hpc: relevant reading http://nyus.joshuawise.com/batchnorm.pdf
16:29:28 <dyl> â€œBatch normalization is said to be tolerant to hyperparameters; for instance, the decay hyperparameter is said to reasonably range from 0.999 through 0.99 all the way down to 0.9 and â€œetc.â€, which is apparently one nine fewer than 0.9.â€
16:29:54 <dyl> â€œThe results were utter crap.â€
16:30:47 <hpc> "etc"
16:31:05 <hpc> that's how i am ending all of my proofs now
16:31:27 <dyl> You donâ€™t want to deny yourself the satisfaction of filling in your QED block though...
16:31:34 <dstolfa> hpc: *handwave the rest* q.e.d.
16:31:40 <dyl> Delicately and evenly shading in the little square is the best part.
16:31:55 <dyl> Or drawing three dots.
16:31:57 <dyl> Either way.
16:32:34 <hpc> dyl: what about the trolly satisfaction of knowing that people will forever read your proof and be confused about if it's finished or unfinished
16:32:47 <dyl> â€œin the pathological case, the result is trivial. For the sake of contradiction, proceed by induction. Etc. QED.â€
16:32:57 * dyl just solved the Navier Stokes problem.
16:33:15 <dstolfa> dyl: you forgot to handwave
16:33:18 <dyl> â€œEtcâ€ is basically just a modern form of â€œthe margin isnâ€™t big enoughâ€
16:33:32 <hpc> just enumerate every proof and use the axiom of choice
16:33:48 <dyl> hpc: constructivists are going to find you while you sleep man
16:33:52 <dyl> Careful saying that kind of stuff.
16:34:16 <dyl> Theorem: two pieces of bread make a trivial sandwich.
16:34:22 <dyl> Proof: law of the excluded middle.
16:34:38 <dstolfa> how does one present at a machine learning conference? train something to do something and go in front of a mirror to practice waving your hands a lot
16:34:42 <dstolfa> sorry i couldn't resist
16:36:03 <dyl> I mean, it is an experimental science.
16:36:15 <dyl> The closest thing to a coherent result is the collection
16:36:26 <dyl> coherent results is the collection of no-free-lunch theorems.
16:36:30 <dyl> Itâ€™s a very new area.
16:36:39 <dyl> ML is the new confluence.
16:36:47 <dyl> No one really understands it.
16:37:14 <hpc> lemma: there is no free object in the category of lunches
16:37:24 <hpc> etc
16:38:17 <hpc> dyl: does that make self-driving cars the new jira?
16:39:15 <mcafffe> jira ?? hpc  agile tool ?
16:40:22 <mcafffe> what is machine learning dyl dstolfa  is it haskell thing ?
16:41:38 <mcafffe> ok bye
16:44:50 <jcowan> Can someone explain to me why the definition of join (in Monad) as "x >>= id" works?
16:45:30 <hpc> :t (>>=)
16:45:32 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:45:38 <hpc> jcowan: this takes a thing and a function
16:45:48 <hpc> jcowan: x has type (m a), id has type (a -> m b)
16:45:55 <hpc> but it also has type (c -> c)
16:46:25 <hpc> if you unify those two types, it turns out to be (m b -> m b)
16:46:26 <bender|> Hello everyone
16:46:29 <hpc> which makes a = m b
16:46:48 <hpc> so in this use case, (>>=) :: m (m b) -> (m b -> m b) -> m b
16:47:05 <hpc> we know we're passing in id, so take that out
16:47:09 <hpc> and m (m b) -> m b
16:48:11 <hpc> then the monad laws and parametricity and such ensure that the function behaves the same as join
16:48:46 <hpc> that's as far as you can get generically, i suggest also looking at (>>=) and join for a few specific instances and working out how those things are equal
16:49:05 <jcowan> thanks, I think I see it
16:49:36 <fishythefish> jcowan: perhaps this is somewhat circular, but if you're more comfortable with the behavior of join than the behavior of (>>=), consider x >>= f = join (fmap f x). Then x >>= id = join (fmap id x) = join (id x) = join x
16:50:49 <jcowan> makes sense
16:51:35 <jcowan> I am interested in adding monads to a non-Haskell context, and I think it would be better to define them with fmap, <*>, and join, so that it is obvious how Monad > Applicative > Functor
16:52:27 <fishythefish> don't forget pure/return
16:53:46 <jcowan> right
16:56:24 <hpc> i still find it interesting that Point was briefly factored out, and then it was discovered that all its laws are free theorems
16:56:54 <jcowan> on another tack, I see that Haskell has Semigroup and Monoid.  Is there a practical benefit to going up to Group, Ring, IntegralDomain, Field?
16:57:15 <jcowan> (that is, for things other than abstract algebra?)
16:58:32 <hpc> i can see ring maybe
16:58:41 <hpc> sometimes distributive laws are handy
16:59:10 <jcowan> well, history suggests that to get to Ring you should go through Group
17:00:12 <jcowan> hpc: do you have a reference for the laws of Point being free?
17:01:00 <jcowan>  "point" is a horribly overloaded word :-)
17:01:33 <hpc> only my 100% totally perfect and infallible memory
17:01:36 <hpc> what were we talking about?
17:03:26 <dyl> Does anyone here know much about pointless topology?
17:03:36 <jcowan> <hpc> i still find it interesting that Point was briefly factored out, and then it was discovered that all its laws are free theorems
17:03:46 <dyl> https://en.wikipedia.org/wiki/Pointless_topology
17:04:26 <dyl> ?free burrito
17:04:27 <lambdabot> Extra stuff at end of line in retrieved type "error: Variable not in scope: burrito\n"
17:04:39 <dyl> ?free a -> burrito
17:04:39 <lambdabot> Extra stuff at end of line
17:07:31 <mniip> dyl, is that the topology via neighborhoods?
17:07:44 <mniip> yeah looks like it
17:08:14 <mniip> jcowan, the problem with group is multiplicative inverses
17:08:40 <dyl> This seems like something #haskell would be into: â€œthe category of pointless topological spacesâ€
17:08:48 <jcowan> mniip: how is that a problem?
17:09:04 <dyl> multiplicative inverses arenâ€™t a problem at all?
17:10:14 <dyl> mniip: thatâ€™s just a monoid then?
17:10:15 <mniip> I guess the problem is,
17:10:51 <jcowan> antici           (say it!)                  pation!
17:10:52 <mniip> group has more laws than functor, applicative, monad altogether
17:11:02 <Xal> I've got a bit of a problem with my lexer using alex:
17:11:09 <dyl> Huh?
17:11:22 <dyl> How is that a problem mniip?
17:11:30 <Xal> Everything's working fine, but as soon as I try to makeLenses ''AlexUserState, I get an error
17:11:32 <keegans> :t init
17:11:33 <Xal> (actually several)
17:11:33 <lambdabot> [a] -> [a]
17:11:37 <mniip> it's not a limitation
17:11:43 <mniip> you can make such a class but
17:12:17 <mniip> that's not very "in the spirit of haskell"
17:12:38 <mniip> I guess I have no other argument besides aesthetics
17:12:44 <dyl> Uh... Iâ€™m not sure I see what the issue is?
17:12:45 <Xal> https://hastebin.com/rinowinopa
17:13:00 * hackage extensible-effects 2.5.0.0 - An Alternative to Monad Transformers  https://hackage.haskell.org/package/extensible-effects-2.5.0.0 (shergill)
17:14:49 <jcowan> trhe number of laws should be O(2^n) the number of basis functions
17:17:45 <fishythefish> mniip: i think the question of creating a semigroup/monoid/group/ring/field hierarchy was separate from the question of creating a functor/applicative/monad hierarchy
17:18:07 <jcowan> it was
17:18:15 <mniip> sure I'm just trying to explain this notion of a class with few methods but many laws being unappealing
17:18:31 <jcowan> now I am wondering which instances of Semigroup are not instances of Monoid
17:18:35 <fishythefish> ah, yes
17:19:30 <fishythefish> in general, it's up to the programmer to verify that the laws hold, so if the class itself doesn't add useful operations, you don't get much practical use
17:20:25 <fishythefish> jcowan: any semigroup with no identity (think of nonempty things)
17:20:55 <jcowan> yes, in principle
17:21:13 <fishythefish> okay, how about the type of nonempty lists if you want a concrete example?
17:21:39 <jcowan> but looking at the list of defined instances I don't see any
17:21:58 <fishythefish> well, the list of defined instances depends on what you have in scope
17:22:29 <fishythefish> are you just limiting yourself to Base?
17:23:20 <jcowan> I'm actually looking at the hackage page
17:23:27 <fishythefish> actually, if so, I believe Void has a Semigroup instance and not a Monoid instance
17:23:49 <superusercode> nice
17:23:50 <JordiGH> Is there a name for the notation f : X -> Y where f is a function and X and Y are types?
17:24:14 <lyxia> a type annotation
17:24:14 <fishythefish> Data.List.NonEmpty is also in base, jcowan
17:24:20 <jcowan> oh, okay
17:24:48 <JordiGH> lyxia: I don't mean the lambda calculus type annotation that uses two colons.
17:25:00 <JordiGH> I mean the normal math one.
17:25:29 <JordiGH> The one you learn in high school.
17:25:38 <JordiGH> Or earlier.
17:25:53 <fishythefish> we don't normally name notation like that
17:26:00 <fishythefish> is there a name for the notation "f(x) = x^2"?
17:26:14 <JordiGH> fishythefish: Yeah, I didn't think it had a name.
17:26:30 <JordiGH> Okay then.
17:26:51 <fishythefish> you could call it a function declaration, I suppose, but that has a distinct programming flavor
17:27:09 <jcowan> fishythefish: Void is a pretty degenerate case of a semigroup, though.
17:27:41 <fishythefish> jcowan: didn't say it wasn't. I provided at least one nontrivial example of semigroups-that-are-not-monoids in base and I have others
17:28:27 <jcowan> so: one law, three methods
17:29:28 <fishythefish> jcowan: well, not really
17:29:34 <fishythefish> (<>) is essentially the only method
17:29:49 <fishythefish> but certain other functions that can be built out of it potentially have more efficient implementations than the naive one using (<>)
17:29:55 <fishythefish> so you're allowed to override them as well
17:31:46 <fishythefish> JordiGH: my point still stands, but apparently I was more glib than I should have been :P https://en.wikipedia.org/wiki/Functional_notation
17:33:09 <JordiGH> fishythefish: I don't mean that.
17:33:31 <fishythefish> yeah, I just mean re: my comment about f(x)
17:33:40 <MarcelineVQ> JordiGH: I â€‹never saw f : X -> Y in highschool, what area of math was it?
17:33:48 <fishythefish> algebra?
17:33:59 <JordiGH> MarcelineVQ: Yeah, they called it "algebra".
17:34:08 <fishythefish> precalculus and calculus definitely had that notation, anyway
17:34:08 <JordiGH> It really was a hodgepodge of topics.
17:35:42 <fishythefish> my high school classes didn't really emphasize why the domain and codomain must be part of the definition of a function
17:35:52 <fishythefish> but they did insist that we knew what the domain/range were
17:37:54 <jcowan> https://wiki.haskell.org/Why_not_Pointed%3F <-- seems to be Pointed, not Point
17:39:06 <NextHendrix> getting the "Invalid flag name: \"bytestring--lt-0_10_4\"" problem in stack again
17:39:29 * hackage type-tree 0.1.0.0 - Tree representations of datatypes  https://hackage.haskell.org/package/type-tree-0.1.0.0 (JudeTaylor)
17:39:31 <NextHendrix> did anyone find a solution for it, keep hitting dead ends from months ago
17:42:00 <vivit> Heyy
17:42:07 <vivit> I've got a problem
17:43:53 <vivit> trigRand :: Num a => a -> Int -> [a] -> [a]
17:43:56 <vivit> trigRand x y l = (trigRand (last l) (y - 1) (l ++ [(sinPrimeProduct x)]))
17:44:37 <vivit> It's telling me that it can't match type 'a' with 'Integer'
17:44:55 <vivit> I don't understand. I thought 'Integer' was an instance of the typeclass 'Num'?
17:45:09 <fishythefish> what's the type of sinPrimeProduct?
17:45:15 <vivit> Integer
17:45:21 <vivit> wati whoops
17:45:22 <fishythefish> there you go
17:45:29 <vivit> actuall no
17:47:01 <vivit> It's  Num a => t -> a
17:47:18 <fishythefish> with no constraints on t?
17:47:35 <vivit> I tried putting constraints on t, but it didn't like that
17:47:43 <fishythefish> then it has to be a constant function
17:47:49 <vivit> primeconst = 17011
17:47:52 <vivit> sinPrimeProduct :: (Num a) => a -> a
17:47:54 <vivit> sinPrimeProduct x = primeconst * x
17:48:14 <fishythefish> okay, so that's not Num a => t -> a, that's Num a => a -> a
17:48:20 <vivit> It would be
17:48:30 <vivit> but ghc gives me an error when I try to do what I said I just did
17:48:50 <fishythefish> it gives you an error for sinPrimeProduct in addition to the error for trigRand?
17:49:00 <fishythefish> what's the type of primeconst?
17:50:09 <vivit> It should be Int
17:50:20 <vivit> I declared it as  primeconst = 17011
17:50:25 <vivit> er
17:50:33 <vivit> No, ghci is telling me that it's  Num
17:50:51 <fishythefish> can you provide a paste of your code and the actual error so we can see the error location?
17:50:51 <vivit> s/Num/Num a => a/
17:52:06 <vivit> okay
17:52:09 <vivit> primeconst = 17011
17:52:12 <vivit> sinPrimeProduct :: (Num a) => a -> a
17:52:14 <vivit> sinPrimeProduct x = primeconst * x
17:52:19 <vivit> That's my code, those three lines
17:53:02 <vivit> My error:
17:53:04 <vivit>     Couldn't match expected type â€˜aâ€™ with actual type â€˜Integerâ€™
17:53:07 <vivit>       â€˜aâ€™ is a rigid type variable bound by
17:53:09 <vivit>           the type signature for sinPrimeProduct :: Num a => a -> a
17:53:34 <fishythefish> can you add primeconst :: Num a => a and see if that helps?
17:53:55 <fishythefish> I don't know what your defaulting rules are
17:54:17 <vivit> that does it
18:12:30 * hackage dbus 1.0.1 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-1.0.1 (blaze)
18:17:01 <jchia> It seems that avoiding partial functions is quite important to a lot of people. Is it common for people to think that you should always avoid them as much as possible? I can see how this is helpful for some end-user-facing app, like a webserver or a game. However, do people think that we should ALWAYS avoid them?
18:17:18 <maerwald> no
18:19:59 <jchia> E.g. for data analysis work, especially with unstructured, semi-structured or dirty input, you can make assumptions about the data. If the data is bad, or your assumptions are wrong, the computer is not smart enough to magically fix it for you. So, e.g. I may assume than some input CSV has a header. I get the header from the lines ([ByteString]) using head, which will crash if the file is empty. Then it's time for the human being to take over and investigate. 
18:20:02 <maerwald> I think people just went crazy about it because haskell has no totality checker
18:20:48 <maerwald> well, if you use partial functions on user input, that is very obviously bad
18:22:58 <maerwald> the realistic problem with it is more that you can get things wrong when you refactor your code (e.g. deep internal API)
18:23:18 <maerwald> where you have local guarantees that the partial functions are perfectly safe
18:23:45 <Psybur> A partial function in haskell can be like an incomplete pattern match or throwing exceptions?
18:30:55 <blonkhart> sure, or a nonterminating function
18:32:20 <maerwald> that's tricky, because of laziness
18:36:35 <blonkhart> i am a tricky fellow.
18:36:49 <ab9rf> a fricky tellow?
18:38:10 <xpika> if a semigroup is a (a->a->a) , is there a typeclass for a (a->b->b) ?
18:38:36 <blonkhart> not as tricky as William Archibald Spooner.
18:39:27 <lyxia> xpika: https://hackage.haskell.org/package/semigroups-actions-0.1/docs/Data-Semigroup-Act.html
18:40:06 <uc> Hi, I am struggling understanding monad, I think I understand what it does. But what does it mean when we say IO in Haskell is made possible by monad?
18:40:56 <lyxia> xpika: I don't know whether there is something more up to date
18:41:10 <xpika> lyxia: thanks
18:42:05 <lyxia> uc: it's a pure way of composing impure programs
18:46:11 <uc> lyxia: Yes, this kinda makes sense to me, I know side effects, but it is still too abstract that how do/IO() work in Haskell
18:46:54 <lyxia> uc: in Haskell, we can say that "let y = print x in y >> y" is the same as "print x >> print x", but then it seems strange that in the first one print is applied once, while in the second one print is applied twice
18:47:00 <dibblego> uc: IO in Haskell is not made possible by monad. The IO data type, and its Monad, are distinct structures with no significant relationship.
18:48:54 <uc> dibblego: Maybe it should be stated that side effect is made possible by Monad, right?
18:49:15 <dibblego> uc: no, Monad is an interface and is unrelated to side-effects.
18:49:47 <lyxia> uc: the solution is to view computations as values that you can compose, and the general way to compose them is via the monad interface.
18:51:26 <uc> Oh, this is the hardest part to me, so how monad is related to side effect? To me side effect is like we can have multiple return values from a single function, like multiple print calls.
18:51:28 <crick_> I am getting a parse error on '<-' inside a list comprehension. I think I have written it correctly.
18:52:24 <crick_> It it saying 'perhaps this statement should be within a do block'
18:52:39 <crick_> What could be the error?
18:52:44 <lyxia> crick_: just paste your code
18:52:50 <crick_> Okay
18:53:22 <lyxia> it makes it much easier to help you
18:53:59 * hackage extensible-effects 2.5.1.0 - An Alternative to Monad Transformers  https://hackage.haskell.org/package/extensible-effects-2.5.1.0 (shergill)
18:55:35 <crick_> lyxia: https://paste.ofcode.org/GvsveunDnMW7icb3mMy2Ek
18:55:56 <crick_> In the last function `moves`
18:56:25 <vaibhavsagar> that doesn't look like a list comprehension
18:56:37 <vaibhavsagar> maybe you need a `|` instead of the `,` you have there?
18:57:17 <uc> lyxia: Could you please help me understand how monad is related to side effect? I am still not getting it.
18:57:25 <crick_> Yes..it was |
18:57:28 <dibblego> uc: it's not related, at all
18:57:32 <crick_> I changed it before pasting
18:57:35 <crick_> Still the same
18:57:37 <crick_> error
18:58:56 <uc> dibblego: So how do I achieve IO, like printing something to the terminal?
18:59:12 <vaibhavsagar> uc: use the `print` function
18:59:23 <dibblego> uc: you use values such as print, which have a type String -> IO ()
19:00:21 <lyxia> crick_: you did the same mistake twice
19:00:33 <crick_> uc: 'IO a' are thought of as actions that change the state of the world and return the value of type a
19:00:34 <wtfunctional> What's a good way to start learning about how the GHC works on the inside? Also, how it differs from other compilers?
19:01:09 <crick_> lyxia: No I didn't get you
19:01:11 <vaibhavsagar> wtfunctional: https://takenobu-hs.github.io/downloads/haskell_ghc_illustrated.pdf
19:01:14 <lyxia> crick_: after fixing those comprehensions I don't get syntax errors (but others)
19:01:42 <crick_> Rest everything is must be working fine
19:02:00 <vaibhavsagar> crick_: how do you know that?
19:02:07 <lyxia> crick_: paste your fixed code with the error message
19:02:23 <vaibhavsagar> wtfunctional: also see http://www.stephendiehl.com/posts/ghc_01.html
19:02:28 <wtfunctional> vaibhavsagar: Thanks!
19:02:35 <vaibhavsagar> you are very welcome
19:03:34 <lyxia> crick_: How do you expect us to help with error messages if you give us code that doesn't produce the same errors
19:03:35 <crick_> I don't know why it's showing a parse error in that function. You can remove the last two functions and load it into ghci
19:04:01 <jchia> What exactly does a derived instance of Read do? The record TimeOfDay derives Read. I don't know what I'm supposed to give to 'read'. http://hackage.haskell.org/package/hourglass-0.2.11/docs/src/Time-Types.html#TimeOfDay
19:04:08 <crick_> lyxia: I am really not getting you
19:04:26 <crick_> Doesn't produce the same error meaning?
19:05:17 <lyxia> crick_: meaning that if I rewrite these [gameTree g' (next p), g' <- moves g p]
19:05:23 <wtfunctional> vaibhavsagar: Also, are there any papers I should read for theoretical background?
19:05:27 <lyxia> crick_: meaning that if I rewrite these [gameTree g' (next p) | g' <- moves g p]
19:05:39 <jchia> forget record, what about newtype? I don't even know what the derived Read for the newtype Hours means. http://hackage.haskell.org/package/hourglass-0.2.11/docs/src/Time-Types.html#Hours
19:06:01 <jchia> Hours is a newtype of Int64
19:06:03 <lyxia> crick_: and [move g i p| i <- [0..(size^2 - 1)]] then I don't get errors about these comprehensions anymore
19:06:06 <crick_> lyxia: https://paste.ofcode.org/GwbAGgXnGcUAbqcYSndKWm this works well
19:06:10 <jchia> I can't read "12" into it
19:06:18 <vaibhavsagar> wtfunctional: please enjoy https://ghc.haskell.org/trac/ghc/wiki/ReadingList
19:06:25 <lyxia> crick_: ok fine
19:06:39 <wtfunctional> vaibhavsagar: I'm coming from an imperative programming background
19:06:52 <vaibhavsagar> wtfunctional: most people do
19:06:52 <crick_> as soon as I add the last two functions, it starts showing parse error on '<-'
19:06:54 <wtfunctional> vaibhavsagar: Thanks again
19:07:08 <lyxia> jchia: the format for Read is the same as what Show outputs
19:07:38 <jchia> lyxia: I can't read "12h" into Hours but I can "Hours 12". Not a very helpful read instance.
19:07:49 <lyxia> jchia: "Hours 42", "TimeOfDay {todHour = Hours 42, todMin = ..., ..., }"
19:07:53 <jchia> show produces "12h"
19:07:57 <crick_> lyxia : Got it
19:08:06 <crick_> Sorry, it was a trivial error
19:08:20 <jchia> I don't know when or why I would need to read that format instead of something like "12:13:14"
19:08:34 <lyxia> jchia: okay I see, then that seems like an oversight
19:08:41 <lyxia> nobody uses Read anyway
19:08:50 <vaibhavsagar> jchia: Show and Read are meant to be inverses
19:09:19 <jchia> vaibhavsagar: In this case it's not. That's why I don't understand the presence of the Read instance.
19:09:33 <vaibhavsagar> oh, I see what you're saying
19:09:44 <jchia> not useful for actual parsing and not useful as inverse for show
19:10:08 <lyxia> it was probably done without thinking
19:10:17 <jchia> probably
19:10:22 <vaibhavsagar> it is useful when the property that they are inverses holds
19:10:41 <jchia> i was just trying to find a non-ceremonious way to parse time of day "12:13:14.123456789"
19:11:02 <vaibhavsagar> jchia: https://hackage.haskell.org/package/base-4.11.0.0/docs/Text-ParserCombinators-ReadP.html
19:11:49 <vaibhavsagar> I personally like attoparsec better but ReadP is in base
19:12:43 <jchia> I'd have to make a parser. I'm looking at Data.Time.Format.ParseTime from the time package.
19:13:30 <lyxia> people hijack Show so often, Read is just not reliable for anything serious
19:13:52 <vaibhavsagar> I think the fact that they both rely on String is also a problem
19:18:06 <lyxia> > fix show
19:18:09 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
19:18:15 <lyxia> can't do that with a Text
19:22:19 <vaibhavsagar> :cold_sweat:
19:23:56 <jchia> I think I'll use Data.Time.Format.Parse.parseTimeM from the time package
19:24:01 <vaibhavsagar> curious how the number of `\`s increases, I'm counting 1,3,7,15,
19:24:14 <vaibhavsagar> maybe (2^n)-1?
19:39:16 <lyxia> you double the \ to escape them, and one extra \ to escape "
19:43:17 <vaibhavsagar> @import Data.List
19:43:18 <lambdabot> Unknown command, try @list
19:43:24 <vaibhavsagar> @list
19:43:24 <lambdabot> What module?  Try @listmodules for some ideas.
19:43:54 <vaibhavsagar> > map length $ group $ take 200 $ fix show
19:43:57 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,73]
19:44:42 <vaibhavsagar> 1,3,7,15,31,63
19:44:45 <vaibhavsagar> LGTM
19:48:33 <lyxia> a very sane way of computing powers of two
19:48:59 <Xal> yeah I usually just use opengl to draw a square and then I count the pixels
19:49:11 <Xal> if you do it in an off-screen buffer it's very fast
19:49:14 <vaibhavsagar> > map length $ group $ take 1023 $ fix show
19:49:17 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1]
19:49:32 <vaibhavsagar> I am inordinately happy with this
19:49:44 <Xal> > nub $ map ((+1) . length) $ group $ take 1023 $ fix show
19:49:47 <lambdabot>  [2,4,8,16,32,64,128,256,512]
19:49:56 <vaibhavsagar> very nice
19:50:25 <Xal> this will go into the toolbelt of "put in next release to horrify code reviewer"
19:50:27 <lyxia> let's add a rewrite rule in base to make it efficient
19:50:57 <vaibhavsagar> I think `fix show` is the real star here
19:52:03 <Xal> > sqr n = (!! (n - 1)) $ nub $ map ((+1) . length) $ group  $ fix show
19:52:05 <lambdabot>  <hint>:1:7: error:
19:52:05 <lambdabot>      parse error on input â€˜=â€™
19:52:05 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
19:52:13 <Xal> > let sqr n = (!! (n - 1)) $ nub $ map ((+1) . length) $ group  $ fix show
19:52:15 <lambdabot>  <no location info>: error:
19:52:15 <lambdabot>      not an expression: â€˜let sqr n = (!! (n - 1)) $ nub $ map ((+1) . length)...
19:52:22 <vaibhavsagar> Xal: try @let
19:52:27 <Xal> @let sqr n = (!! (n - 1)) $ nub $ map ((+1) . length) $ group  $ fix show
19:52:29 <lambdabot>  Defined.
19:52:42 <Xal> why it's called sqr I don't know
19:52:46 <Xal> > sqr 8
19:52:46 <vaibhavsagar> >sqr 6
19:52:48 <lambdabot>  256
19:53:04 <vaibhavsagar> > sqr 10
19:53:06 <lambdabot>  1024
19:53:14 <vaibhavsagar> nice
19:55:10 <vaibhavsagar> I'm a little confused about how `fix show` works
19:55:40 <vaibhavsagar> where does the empty string come from?
19:56:21 <Xal> > show ""
19:56:24 <lambdabot>  "\"\""
19:56:57 <vaibhavsagar> > show (show (show (show)))
19:56:59 <lambdabot>  "\"\\\"<() -> [Char]>\\\"\""
19:57:07 <vaibhavsagar> holy shit
19:57:12 <Xal> > show . show . show . show $ ""
19:57:15 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
19:57:31 <Xal> > show . show . show . show . show $ show
19:57:33 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"<() -> [Char]>\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
19:57:36 <Xal> still works!
19:57:42 <vaibhavsagar> that doesn't seem to work in my GHCi
19:58:08 <vaibhavsagar> but `fix show` does
20:00:14 <MarcelineVQ> > show (undefined :: String) -- showing a String will start with \" regardless of what particular String is being considered
20:00:17 <lambdabot>  "\"*Exception: Prelude.undefined
20:00:22 <MarcelineVQ> > show (show (undefined :: String))
20:00:25 <lambdabot>  "\"\\\"*Exception: Prelude.undefined
20:00:38 <lyxia> vaibhavsagar: import Text.Show.Function
20:00:53 <lyxia> s/Function/Functions
20:01:03 <Xal> > let x = show x in x
20:01:06 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
20:01:13 <vaibhavsagar> ah, that's what I was missing
20:01:15 <lyxia> it's not quite the same instance though
20:01:16 <vaibhavsagar> thanks lyxia
20:01:29 <lyxia> :)
20:01:36 <vaibhavsagar> MarcelineVQ: this also makes sense
21:07:54 <primary157> Hey Everyone! I'm trying to learn the functional paradigm. And the first thing that comes to my mind is Haskell. Do you have any book or tutorial recommendation for a complete functional paradigm beginner?
21:08:18 <vaibhavsagar> primary157: haskellbook.com
21:11:19 <primary157> @vaibhavsagar Thank you! I'll try the free sample...
21:11:19 <lambdabot> Unknown command, try @list
21:12:35 <smt`> can't go long before someone reccomends http://learnyouahaskell.com/ - imo it's been a nice gentle and easy to read look into the language, but im still learning too
21:15:34 <primary157> smt:  this one seems to be great! especially for being a free of charge solution.
21:16:55 <stephenmac7> @pl \f -> concat . map f
21:16:55 <lambdabot> (=<<)
21:18:11 <c_wraith> lyah is a bit... shallow.  You can learn stuff from it, and maybe enough to get you into other materials - but it's going to leave you still wondering how to do anything with haskell. :)
21:19:34 <smt> yeah I've been flicking between it, googling what I'm looking for and then looking up the relevent section in real world haskell, which seems pretty long winded but i find lyah helps me sort of, get the base then other stuff can built on top of it
21:25:18 <systemfault> c_wraith: That was exactly my problem with LYAH
21:33:09 <primary157> c_wraith: The thing is I'm learning to program in the functional paradigm by studying haskell. Am I doing it right? Shouldn't a shallow tutorial be the exactly thing i need?
21:35:07 <primary157> c_wraith: Anyway LYAH seems to be really cute and worth trying
21:35:08 <c_wraith> primary157: a shallow tutorial will teach you about expression-based programming, some types, some first-class function stuff.  But it won't cover higher-level things like how to organize a program
21:35:19 <c_wraith> primary157: so it's useful, it's just incomplete
21:35:23 <xandaros> LYAH is great to learn the basics. After that, the best solution I found is to just come up with a project and implement it
21:37:39 <primary157> c_wraith: Got it! I'll start from it and then jump to haskellbook.com and a real project.
21:38:39 <xandaros> primary157: If you have any questions, don't hesitate to ask here :)
21:38:50 <primary157> Thank you for the informations! I really appreciate it.
21:39:31 <c_wraith> yeah, people here are almost always ready to help.  Usually more people are happy to help than are asking questions. :)
21:51:04 <aaronSton> what does this type declaration means newtype Something (bound :: Nat) = Something {name :: String} , by (bound :: Nat) ??
21:51:45 <c_wraith> aaronSton: it's a kind signature.  It specifies that the type variable must have the kind Nat.
21:52:52 <c_wraith> aaronSton: there are a few different types with the kind Nat, so it might mean different things depending on which type is in scope.  One important thing to note is that there are no values of any types with a kind other than *, so it must be a phantom annotation of some sort.
21:53:55 <aaronSton> c_wraith : so if we have a type parameter that we don't use then it become phantom annotation ???
21:54:34 <aaronSton> c_wraith : also why are phantom annotations are used at first place ??
21:55:02 <c_wraith> aaronSton: that's the definition of phantom type.  they're useful for keeping track of properties in the type system, so you can provide an api with fewer ways to misuse it.
21:55:51 <aaronSton> c_wraith : can you please expand a bit on that or point me to a guide which explains this in more details
21:56:47 <c_wraith> aaronSton: maybe https://wiki.haskell.org/Phantom_type will be of some help.  Feel free to ask more questions if it isn't
21:58:39 <aaronSton> c_wraith : ty
21:59:50 <aaronSton> c_wraith : also how you define monad transformers they are they plain simple functions which takes a type of monad and spit other type out ??
22:01:42 <c_wraith> aaronSton: a monad transformer is a type.  It will take a type parameter that is a type of kind (* -> *) and have a Monad instance that delegates to the instance of the type passed in to it in some cases.
22:02:22 <c_wraith> aaronSton: One of the simplest examples is newtype ReaderT r m a = ReaderT (r -> m a)
22:03:12 <c_wraith> aaronSton: then a use of it might be something like ReaderT String IO Int
22:06:58 <c_wraith> aaronSton: there would also be a couple instances for ReaderT.  One like "instance Monad m => Monad (ReaderT r m) where ...", one like "instance MonadTrans (ReaderT r) where ..."
22:07:38 <aaronSton> c_wraith : can you also point me to a guide on kinds
22:09:23 <c_wraith> aaronSton: https://wiki.haskell.org/Phantom_type is a very minimal introduction..  Basically, they're the types of types.
22:09:52 <aaronSton> c_wraith : yeah that's all i knew about them from learn you a haskell
22:10:15 <aaronSton> c_wraith : any book suggestion after learn you a haskell other than real life haskell
22:11:34 <c_wraith> aaronSton: http://haskellbook.com/ seems pretty good.  I haven't gone through it in depth myself (It was written years after I learned Haskell, so I'm no longer the target audience for it), but what I've seen seems good and others really like it.  If you can't afford it, contact the author. He's happy to provide discounts when people ask nicely.
22:45:53 <anwar_> Hi, I'm using stack on windows machine and want to install HDBC for ODBC drivers. In my cabal file, I put `HDBC` and `odbc` as dependencies but it fails to build.
22:45:56 <anwar_>  This error is displayed:  odbc must match -any, but the stack configuration has no specified version (latest matching version is 0.0.2)
22:46:52 <anwar_> I'm not sure if I did something wrong
23:00:10 <sphalerite> is Int guaranteed to be bounded?
23:01:23 <dacto> sphalerite: Int has a Bounded instance
23:01:25 <Xal> I would think it is because it's an instance of Bounded
23:01:29 <Xal> ninja'd again
23:02:44 <sphalerite> oh, of course. Thanks!
23:08:30 <MarcelineVQ> anwar_: that's a catch-all error you'll see when your chosen stack resolver and extra-deps don't provide a package you've depended on. in this case odbc isn't on stackage, you'll have to add it to your extra-deps
23:08:43 <MarcelineVQ> https://docs.haskellstack.org/en/stable/GUIDE/#extra-deps
23:44:29 * hackage hakyll-dir-list 1.0.0.2 - Allow Hakyll to create hierarchical menues from directories.  https://hackage.haskell.org/package/hakyll-dir-list-1.0.0.2 (RobertHennig)
23:50:29 * hackage trackit 0.3 - A command-line tool for live monitoring  https://hackage.haskell.org/package/trackit-0.3 (EmilAxelsson)
23:50:59 * hackage marihana 0.1.1.0 -   https://hackage.haskell.org/package/marihana-0.1.1.0 (suzukeno)
23:57:30 <johnw> I finally found my first honest to goodness use of loeb
23:58:53 <vaibhavsagar> cool, what are you using it for?
23:59:08 <johnw> a Nix evaluator, for the case of recursive attribute sets, and recursive let
23:59:23 <vaibhavsagar> that's trippy
23:59:42 <johnw> yeah, it's pretty odd at first
23:59:46 <enterprisey> I'm trying to do something ridiculous
23:59:58 <enterprisey> I want a show' function that shows Chars without the single quotes, but acts normally for everything else
