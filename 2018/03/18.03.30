00:04:13 <GOATonaBOAT> Hello, I'm very curious what Haskellers think about Elixir? Any noticeable warts for you guys? Is its concurrency and dynamic loading all that? Would one be missing out on much by using Haskell instead? etc.
00:07:58 <jle`> aasronStone: 'type Bound m :: Nat' is syntax for associated types
00:08:06 <jle`> as a part of a typeclass definition
00:08:38 <jle`> it says that all instances 'm' of the typeclass have to define a 'Bound m', which is a natural number (type)
00:09:00 <jle`> so i'd write instance MyClass TheThing where type Bound TheThing = 5
00:09:20 <jle`> oh that was an hour ago
01:25:00 <iron_houzi> Would I be wasting my time to use parsec for parsing natural languages, more specifically parsing romanized Asian languages (i.e Asian languages represented in latin script.. e.g pinyin, romaji, wylie)? parsec seems very customized towards parsing machine languages..
01:25:38 <iron_houzi> *time by using
01:38:34 <reactormonk> iron_houzi, look for "natural language processing", which is a whole domain of compsci / linguistics about that problem
01:40:04 <iron_houzi> reactormonk: Thanks, but I'm not sure NLP is what I need. NLP seems more about semantic analysis, I really am doing pure syntactic analysis
01:40:23 <reactormonk> iron_houzi, NLP is everything concerning analyzing human language.
02:11:11 <Rodenbach> I read about effectful computations. In this context often mtl is mentioned, but also free monads and freer monads. Is the core motivation behind those to create a monad that is similar to IO but limited?
02:16:01 * hackage dual-game 0.1.0.0 - Network multiplayer 2D shooting game  https://hackage.haskell.org/package/dual-game-0.1.0.0 (fgaz)
02:16:31 <[exa]> Rodenbach: DSLs? You can give a guy access to e.g. writing his result to a file descriptor, but not break everything else
02:16:54 <ZZzzz> lemmih: hi again it's me from yesterday. i managed to solve it, and here it is: http://lpaste.net/364162
02:17:18 <ZZzzz> lemmih: thank you very much. i need you help in another question :-)
02:19:34 <`Guest00000> have you seen an OS which implements an analog of Haskell's cont as a system call?
02:20:48 <ZZzzz> now i want to do permutation so for example if i have this: f [1,2,3] i need to get as a result: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
02:21:27 <ZZzzz> and of course it can be a different size of list like [1..100]
02:21:46 <ZZzzz> is there a smaller problem i can solve here that will help me solve the problem itself?
02:24:13 <tdammers> Rodenbach: decoupling usage from implementation, mainly - at least in the free(r) monad case
02:24:47 <ZZzzz> how can i call lambdabot in a private room?
02:24:59 <ZZzzz> what is the command?
02:25:01 <tdammers> Rodenbach: monad stacks are more about *adding* functionality to monads, or combining the semantics of individual monads, e.g., you can combine a State monad with IO by using StateT over IO
02:25:11 <tdammers> ZZzzz: you can't, but you can /msg lambdabot
02:25:44 <ZZzzz> tdammers: i can i did it before but i don't remember the commnad :)
02:25:56 <ZZzzz> someone told me here how...
02:26:23 <ZZzzz> it opened a different window for the lambdabot chat
02:26:38 <ZZzzz> so i'll not spam here :-D
02:26:46 <tdammers> most IRC clients will do that when you /msg
02:27:12 <ZZzzz> when i do it, it doesnt do anything. not opening new window. there is another command
02:27:14 <tdammers> in fact, that's the only notion of a "private room" that IRC has, really
02:28:20 <tdammers> which client are you using? weechat, in any case, won't open a new window until the other side answers, so you need to /msg something that lambdabot will respond to
02:28:32 <ZZzzz> no, i'm using rcirc in emacs
02:37:40 <ZZzzz> i need help in making permutation. can someone give a guidance? i want to do it in my own, and in with library function
02:38:01 <ZZzzz> in = no
02:38:02 <lemmih> ZZzzz: Well, the easiest solution would be to use Data.List.permutations. :)
02:38:19 <ZZzzz> hey lemmih did you see my message yo you before?
02:38:52 <ZZzzz> i succeeded to make the function from yesterday
02:38:59 <lemmih> Great.
02:39:17 <ZZzzz> here it is lemmih http://lpaste.net/364162
02:39:22 <ZZzzz> if you want to look
02:39:34 <lemmih> Nah, I don't need to see it, I trust you. :P
02:39:46 <ZZzzz> so now is there a smaller problem i can solve, that will help me to solve the permutation problem
02:39:47 <ZZzzz> ?
02:39:52 <ZZzzz> OK :)
02:43:36 <lemmih> ZZzzz: First try to get a general sense of what you need to do and then try to figure out to do it in Haskell.
02:45:50 <ZZzzz> lemmih: i need to take the first element and then shufle all the rest of the element (which i think is again take the first of the element of the rest and then shufle all the rest etc'), then move to the next element and again shufle the rest as before.
02:47:30 <ZZzzz> the problem with haskell is that it not what is called imperative :-D
02:47:58 <ZZzzz> it's very tricky
02:49:42 <tdammers> you have to think in terms of recursions, basically
02:49:46 <tdammers> induction
02:50:22 <ZZzzz> tdammers: of course. but it seems that it is very difficult sometimes. it take me hourse to solve little things.
02:50:28 <tdammers> find a base case, and then assume that for any nth case, the (n-1)th case is solved
02:50:34 <ZZzzz> *hours
02:50:41 <tdammers> it takes a while to get used to
02:51:23 <tdammers> so try to think of a list for which the permutations are trivial to calculate
02:51:39 <tdammers> can you write down equations for the permutations of empty lists and singleton lists?
02:51:52 <Rodenbach> Okay, so just as a rule of thumb: monad transformers are about combing monads and via n lifts you can go n levels down and use functionality there. The free/freer monads are about building mini dsls/interpreters to provide a subset of IO, but also to offer a pure implementation for testing for example.
02:52:07 <Rodenbach> Is this roughly the idea?
02:52:10 <ZZzzz> tdammers: i think. please wait :)
02:52:11 <tdammers> Rodenbach: not necessarily subsets of IO
02:52:49 <tdammers> Rodenbach: a very popular application of free monads is, for example, to represent some kind of programming language AST in a free monad algebra, and then provide both an interpreter and a compiler as implementations
02:53:03 <tdammers> Rodenbach: or even multiple writers, to support multiple compilation targets
02:53:45 <Rodenbach> tdammers: is there an example for that, very minimal, possibly just 20-80 LOC that demonstrate this? A tiny DSL, maybe just 1-2 commands, and an interpreter and especially a compiler?
02:54:14 <tdammers> Rodenbach: I don't have anything handy, but I'd expect that you should be able to google something useful
02:58:43 <ZZzzz> tdammers: perm  [] = []
02:58:43 <ZZzzz> perm  [x]= [[x]]
02:59:12 <ZZzzz> i think
02:59:26 <tdammers> alright, yes
02:59:46 <lemmih> > permutations []
02:59:46 <tdammers> so, now let's pretend we already have permutations xs implemented
02:59:49 <lambdabot>  [[]]
02:59:56 <tdammers> ^ right
03:00:11 <lemmih> > permutations [x]
03:00:13 <lambdabot>  [[x]]
03:00:15 <lemmih> > permutations [x,y]
03:00:18 <lambdabot>  [[x,y],[y,x]]
03:01:09 <ZZzzz> is true but haskell not complainit if i do just perm []. i can do [[x]] ++ [] which give me [[x]] again and i can do [x] : [] which give me [[x]] again si the end result is [[x]].
03:01:57 <ZZzzz> if i'll do perm [] = [[]] i can get at the end the empty list inside the permutation
03:02:10 <ZZzzz> if i understand well :)
03:02:21 <tdammers> so, can you write permutations xs' in terms of x and permutations xs, such that x is an element of xs', and xs are the remaining elements
03:02:28 <Lears> If your logic is good then having the correct base case of [[]] will simplify the problem, not make it harder.
03:03:44 <ZZzzz> i again need to think tdammers
03:03:49 <ZZzzz> Lears: OK :)
03:04:29 <tdammers> ZZzzz: that's fine, you're supposed to ;)
03:05:52 <duairc> Data.Vector has a function `modify :: (forall s. MVector s a -> ST s ()) -> Vector a -> Vector a`. I'm wondering looking for something with the type signature `modify :: (forall s. MVector s a -> ST s b) -> Vector a -> (Vector a, b)`. Does this exist?
03:06:29 <olligobber> I should not write parsers
03:06:49 <lemmih> duairc: You can make that function, can't you?
03:09:55 <duairc> lemmih: I'm not sure how I can, at least not without running the computation twice or something
03:10:24 <lemmih> duairc: \fn v -> runST (do m <- thaw v; b <- fn m; v' <- freeze m; return (v', r))
03:11:28 <lemmih> (That code requires an explicit type signature since rank N types can't be inferred.)
03:11:47 <duairc> lemmih: Oh okay, I forgot about freeze and thaw (I haven't used vector much before), I thought everything had to go through modify
03:11:59 <duairc> lemmih: Thanks!
04:23:44 <ocramz> hi all
04:23:45 <rihards> hey, anyone know if there's a way to make ghci break whenever there apears a NaN value somewhere in the computation?
04:23:58 <rihards> or throw an exception or something
04:24:37 <ocramz> rihards : what library are you using?
04:25:05 <ocramz> well in fact prelude doesn't have anything like this
04:25:11 <ocramz> > 0/0
04:25:13 <lambdabot>  NaN
04:25:16 <ocramz> so there
04:25:49 <rihards> ocramz: i'm currently debugging some code that's using hmatrix-static
04:25:57 <ocramz> rihards : it's a good question but it would require instrumenting every partial function with exceptions
04:26:00 <rihards> but does it really matter?
04:26:09 <ocramz> rihards no it doesn't in fact
04:26:26 <ocramz> hmmm
04:27:31 <ocramz> I guess in hmatrix things are complicated by the fact of part of the code being C
04:27:35 <rihards> the problem with NaN values is that they tend to spread and it's quite difficult to track down the source of them. a way to trace the first place they occur would help immensely, imho
04:27:47 <ocramz> I agree completely
04:28:09 <ocramz> a NaN stack trace of sorts
04:28:52 <ocramz> even better, as you suggested, throwing as soon as one occurs
04:29:01 <rihards> yup
04:29:35 <ocramz> unfortunately, I'm not aware of any ready-made package that does this. If you write one, make sure to share it ^_^
04:29:44 <rihards> :D
04:29:53 <wchresta> Hey. I have a key/val list [(a,b)] and want to replace (x,y) with (x,z) if it exists and if some condition cond y z holds. If not, I want to return a message in an Either. I'm sure there is an existing abstraction/function for me to do this without having to implement it fully!?
04:29:59 <ocramz> rihards: also something which tracks the loss of numerical precision would be handy
04:30:18 <ocramz> as in, if it drops below 10^-6, barf
04:30:34 <rihards> not gonna happen any time soon. I'm just starting out with Haskell :)
04:31:07 <ocramz> rihards welcome then! we have a whole channel for data- and numerical- related stuff over at https://gitter.im/dataHaskell/Lobby
04:33:30 <rihards> but I guess this is a feature that would best fit in GHC itself. if NaN acted as undefined It would work the way I want. I'll maybe try to start a discussion at GHC's github, see what people there can say about this.
04:33:48 <rihards> ooh, nice, thanks for the link
04:37:31 <ocramz> rihards there is a GHC plugin that heuristically rewrites your pure-Haskell numerical expressions to increase numerical stability : https://github.com/mikeizbicki/HerbiePlugin
04:45:29 <ocramz> is there an incantation for uploading haddocks to hackage using stack?
04:46:31 <ocramz> I see there are closed PRs for cabal on this so I was wondering whether the same functionality carried over to stack as well
04:51:45 <Ariakenom> If you find or start any interesting NaN discussions please share. I'd be interested.
04:53:47 <Ariakenom> There are probably some hardware state that can be set to signal|trap for stuff like that.
04:59:44 <rihards> ok
05:02:30 * hackage fingertree 0.1.4.0 - Generic finger-tree structure, with example instances  https://hackage.haskell.org/package/fingertree-0.1.4.0 (RossPaterson)
05:05:00 <Boomerang> You could tag where the NaNs come from by giving them different payloads
05:05:45 <Boomerang> A typeclass based solution would be a lot cleaner though :p
05:24:32 <Rodenbach> tdammers: So could one see monad transformers and free monads as kind of complementary? The transformers allow us to combine existing monads and create a new one. The new one allows us to access all the functionality of what has been transformed.
05:24:55 <Rodenbach> The free monads seem to be used in practice to take an existing monad (such as IO) and create an api that makes parts of it available.
05:25:47 <Rodenbach> One could use free monads to have an IO subset that allows to print data to the screen and one that can run DB queries. With a monad transformer then one could create a new monad that has access to the DB _and_ which can print stuff to the screen.
05:25:50 <Rodenbach> Does that make sense?
05:26:53 <lyxia> you can also restrict APIs with transformers and type classes
05:28:04 <Rodenbach> lyxia: so monad transformers offer in principle the same power as free monads and even more because they can also combine existing monads?
05:31:08 <`Guest00000> can i have recursive definitions for exact reals, like: two = 1 + 0.5 * two ?
05:32:43 <maerwald> transformers are the worst of all of them
05:35:20 <lyxia> Rodenbach: for most practical purposes the approaches are equivalent in expressiveness
05:35:54 <maerwald> what?
05:36:11 <lyxia> maerwald: do you disagree
05:36:33 <maerwald> the reason we have mtl, e-e, freer etc. is, because that's exactly not the case
05:36:34 <tdammers> Rodenbach: I suggest you just go and start using them yourself, and see if you can draw your own conclusions and build your own mental model
05:36:59 <maerwald> especially when it comes to *adding* effects to existing API
05:38:34 <maerwald> also, reasoning
05:38:36 <lyxia> You can add an effect to mtl by declaring a new type class
05:38:41 <maerwald> yes
05:38:49 <maerwald> did I say otherwise? :>
05:39:37 <lyxia> okay so what is the difference
05:39:45 <maerwald> of transformers and mtl?
05:40:18 <lyxia> I guess in my mind transformers are just synonymous with mtl
05:40:22 <maerwald> no
05:40:56 <kuribas> How do I check if a type is Maybe in TH?
05:40:57 <lyxia> I admit transformers alone does not work well
05:41:29 <kuribas> ''Maybe doesn't seem to work
05:41:41 <lyxia> maerwald: but what about mtl, e-e, freer?
05:41:45 <tdammers> I thought we were discussing the general approaches here, not the particular implementations
05:41:47 <kuribas> for example: isMaybe (AppT (ConT name) _) = name == ''Maybe
05:42:14 <kuribas> erm, it does... nevermind
05:42:25 <lyxia> maerwald: I'm not even sure why e-e and freer are different items in your list.
05:42:25 <kuribas> just ghci being slow on my ancient laptop
05:42:45 <maerwald> lyxia: they are different
05:43:04 <maerwald> unless e-e is now based on olegs second paper
05:43:09 <maerwald> it wasn't last I checked
05:47:13 <Rodenbach> maerwald: which is the best in your experience?  a) mtl,  b) free,  c) freer
05:47:15 <lyxia> I'm looking at both, they look the same to me https://hackage.haskell.org/package/freer-simple-1.1.0.0/docs/src/Control-Monad-Freer-Internal.html#Eff https://github.com/suhailshergill/extensible-effects/blob/master/src/Control/Eff/Internal.hs#L125
05:48:12 <maerwald> Rodenbach: I have played with freer a bit, while I like it, using it is not that intuitive and mtl definitely is more wide-spread
05:49:04 <maerwald> also notice edk's comments about it, he doesn't seem to like the e-e approach in general: https://www.reddit.com/r/haskell/comments/387ex0/are_extensible_effects_a_complete_replacement_for/
05:49:16 <lyxia> by "second paper" do you mean "freer monads, more extensible effects"
05:49:42 <Rodenbach> So people are experimenting with this still, and for now mtl is a very good starting point for studying.
05:49:58 <maerwald> lyxia: yes
05:53:29 <Rodenbach> I thought that mtl is basically monad transformers. With just some nice tools added to save us from multiple calls to lift.
05:54:52 <lyxia> mtl classes don't only spare us from using lift, they disentangle the interface from the implementation
06:03:41 <the_2nd> I'd like to verifiy and generate (pgp) signatures. Which package do you suggest?
06:04:18 <fr33domlover> Rodenbach, if you write a program you may be happy with plain transformers but when you write a library i think mtl allows you to provide a more generic interface that restricts the user's choice of transformer stack much much less than plain transformers would
06:05:49 <fr33domlover> plain mtl still has this issue when you want to stack more than one transformer of the same type, but that can be abstracted too using typeclasses your specific library can provide
06:06:55 <fr33domlover> (HasWhateverData env, MonadReader env m) => ... etc.
06:11:30 <dminuoso> lyxia: Thank you for the Generic example yesterday. I've been going through it, and apart from the third instance I think Im beginning to understand it.
06:14:41 <lyxia> dminuoso: you're welcome!
06:21:32 <exarkun> Using dns-3.0.2, makeResolvSeed defaultResolvConf fails in some environments "Main: Network.Socket.getAddrInfo: does not exist (Name or service not known)".  What does `makeResolvSeed` do and why is it failing this way?
06:23:00 * hackage snap-auth-cli 0.2 - Command-line tool to manage Snap AuthManager database  https://hackage.haskell.org/package/snap-auth-cli-0.2 (DmitryDzhus)
06:33:47 <Akii> anyone familiar with scotty? It seems to overwrite the status code to 200 if `file` is used (https://hackage.haskell.org/package/scotty-0.11.0/docs/src/Web-Scotty-Action.html#file)
06:37:16 <exarkun> Here's a minimal version of the program that fails, https://gist.github.com/exarkun/54b6e39aefc8a2625c9128d56516bdb6 (but I have no idea what aspect of the environment causes the failure so it's not self-contained)
06:39:29 * hackage fingertree 0.1.4.1 - Generic finger-tree structure, with example instances  https://hackage.haskell.org/package/fingertree-0.1.4.1 (RossPaterson)
06:41:48 <iron_houzi> Is it possible to have a type Foo derving Show, where the string value is lowercased?
06:42:31 <lemmih> iron_houzi: Not when you derive the Show instance but you can write your own instance.
06:42:47 <lemmih> (But you shouldn't do that, btw.)
06:43:47 <iron_houzi> I just want to define my own alphabet where I can get ranges and stuff like that for the characters of the alphabet
06:44:32 <lemmih> iron_houzi: Then use a different function for that or create a new type class.
06:45:17 <mclark1129> I'm still struggling trying to understand how to actually use GADTs.  The example here is readStreamEventsForward for the eventstore library
06:45:18 <mclark1129> https://www.stackage.org/haddock/lts-9.21/eventstore-0.15.0.2/Database-EventStore.html
06:46:01 <mclark1129> Returns an IO (Async (ReadResult REgularStream StreamSlice)), trying to figure out how I can pattern match on that result to handle cases such as ReadNoSTream
06:48:11 <lemmih> mclark1129: Just pretend it's not a GADT. How you do pattern matching doesn't change.
06:48:31 <delYsid> iron_houzi: Things printed with Show should be readable with Read.
06:49:15 <iron_houzi> lemmih: Perhaps the initial question wasn't very well phrased. I have `data Alphabet = Ka | Kha | Ga | Nga` .. if they derive Show, I get the string values for free, but I need the string values to be all lower case. I'm a complete beginner trying to understand how to go from defining the "data type" to getting actual values..
06:49:45 <lemmih> iron_houzi: You can define: prettyprint = map toLower . show
06:50:32 <iron_houzi> perhaps even `data Alphabet = Ka String | Kha String | ...`
06:50:53 <dminuoso> mclark1129: The only thing that changes, is when you pattern match, that the type parameter is known.
06:51:17 <iron_houzi> lemmih: When I've defined that function, will all usage of Show become lower case, or just Show for my Alphabet?
06:51:43 <dminuoso> iron_houzi: Show is not for pretty printing.
06:51:51 <mclark1129> lemmih: I guess I still don't get the recursive nature of this type.. ReadResult :: StreamType -> * -> *, and then ReadNoStream :: ReadResult RegularStream a
06:51:59 <lemmih> iron_houzi: Neither. It defines a new function that you can use. It doesn't change Show at all.
06:52:06 <iron_houzi> I see
06:52:14 <dminuoso> iron_houzi: Read/Show ideally follow the law `read . show = id`, and that Show ideally produces Haskell valid syntax to reconstruct the data type.
06:52:29 <lemmih> mclark1129: How is that recursive?
06:52:31 <iron_houzi> That makes sense really
06:52:58 <iron_houzi> OK, thanks! I'll play around with this and see what happens
06:53:13 <mclark1129> ReadNoStream is a ReadResult constructor and resolves to a ReadResult RegularStream a?
06:53:19 <lemmih> mclark1129: Imagine that ReadResult looks like this: data ReadResult t a = ReadSuccess a | ReadNoStream | ReadStreamDeleted String | ...
06:54:00 <mclark1129> ok so I shoudl just be doing `case result of ReadNoStream`
06:54:12 <lemmih> mclark1129: Yes, 'ReadNoStream' is a constructor of type 'ReadResult RegularStream a'. Just like 'Nothing' is a constructor of type 'Maybe a'.
06:54:18 <fryguybob> Is there a library or way to use optparse-applicative to load some default arguments from a configuration file?
06:54:21 <dminuoso> mclark1129: Consider a much more simplified case: https://gist.github.com/dminuoso/623c866056b8268bb8d65ba0b50a69f4
06:54:22 <lemmih> mclark1129: Yep.
06:54:45 <dminuoso> mclark1129: This in essence encapsulates how GADTs are defined, and how they are used. Without GADTs you can't do this.
06:58:24 <kuribas> is it possible to use extensions in template haskell?
06:59:32 <kuribas> without requiring the TH user to enable them?
06:59:44 <maerwald> I'm still annoyed that haskell tooling is in such bad shape. It seems to take pretty much a full year or more for tools to catch up with the *stable* GHC version
06:59:46 <dminuoso> mclark1129: So as you can see, the only specialty, is that this no longer admits things like `Add (B True) (I 10)`.
07:00:02 <lemmih> kuribas: What does that mean exactly?
07:00:07 <maerwald> In go, the tool update cycle is much faster
07:00:18 <Boomerang> Hello, I am struggling to get deserializeAnns ( https://hackage.haskell.org/package/ghc-8.2.1/docs/Annotations.html#v:deserializeAnns ) to work as I expect it to. I have a list of Annotations, I can manually deserialise the payload, the annotation I expect shows up but not when I use deserializeAnns. Is there anything I should know about this function, mkAnnEnv or eltsUFM that is not obvious from the type
07:00:20 <Boomerang> signatures?
07:00:32 <kuribas> lemmih: that the generated code uses some ghc extensions, like overloaded strings...
07:00:48 <mclark1129> dminuoso: Bout to hop into a meeting but I need to digest this a bit more, is it just that all the data constructors themselves have types too?
07:00:59 <kuribas> maerwald: and who should fix it?  Why not you?
07:01:11 <dminuoso> mclark1129: Well let me give you the non-GADT form but with GADTSyntax.
07:01:14 <dminuoso> Then it will become obvious
07:01:21 <maerwald> kuribas: because I don't know the codebase of those tools
07:01:26 <mclark1129> (you overestimate my haskell ;) )
07:02:06 <lemmih> kuribas: For overloadedStrings, I doubt it. For things like lambda-case, probably.
07:02:40 <dminuoso> mclark1129: https://gist.github.com/dminuoso/d6dcd44306ef1bccae26e479e895d144
07:03:13 <mclark1129> dminuouso: thanks!  will check that out
07:03:15 <dminuoso> err second!
07:03:26 <dminuoso> mclark1129: Updated.
07:03:57 <maerwald> kuribas: naturally, the maintainer is the one who is able to fix it easiest
07:03:59 <dminuoso> mclark1129: The second file containts two equivalent declarations. The GADTSyntax is just easier to read I think. Now compare the GADTSyntax with actual GADTs. =)
07:04:12 <kuribas> maerwald: maintainer of what?
07:04:18 <maerwald> of the tool
07:04:34 <kuribas> lemmih: can I enable an extension in the Q monad?
07:04:41 <kuribas> maerwald: which tool?
07:04:48 <lemmih> kuribas: I hope not. :D
07:04:51 <maerwald> kuribas: hdevtools, ghc-mod, ...
07:05:17 <kuribas> maerwald: send them suggestions, help write features, or better, pay them to do so :-)
07:05:24 <maerwald> aha
07:05:54 <kuribas> lemmih: why not?
07:06:19 <maerwald> it's not about suggestions or features, it's about incompatibility with new ghc versions
07:06:34 <lemmih> kuribas: Some extensions make it possible to write unsound code.
07:07:29 <nut> any requirement on a data type to be the key in a Data.Map?
07:08:20 <kuribas> nut: Ord
07:09:05 <nut> Can we make any Sum type data a Ord ?
07:09:35 <lemmih> nut: You can derive Ord.
07:09:44 <kuribas> nut: if the subtypes have Ord...
07:27:15 <mclark1129> diminuoso: So is it fair to say that the benefit of the real GADT in your example is that it allows you to constrain Add to a function of Expr Int?
07:27:35 <dminuoso> mclark1129: Right. Or for the other types.
07:27:47 <dminuoso> mclark1129: In essence "all" a GADT lets you do, is specify/constrain the return type
07:27:50 <mclark1129> whereas in the standard data syntax, the best I can do is constrain it to an expression, which might be Expr Bool or whatever else
07:28:00 <dminuoso> Right, but you get a polymorphic thing back
07:28:01 <dminuoso> so its useless
07:28:26 <dminuoso> i.e. `I 10 :: Expr Bool` would type check
07:29:08 <dminuoso> mclark1129: And it happens in a particular way, that you can still pattern match in a function say `eval :: Expr a -> a`
07:29:41 <EvanR> mclark1129: this is part of a wider story of having such rich types that you can only possibly construct data or write a program that satisfies your spec
07:30:00 <EvanR> ideally, if it type checks, it is correct
07:30:58 <dminuoso> Like in the Expr example, something like `Add (B True) (I 10)` should not type check. GADTs let you introduce domain specific semantics, that the type checker will validate =)
07:31:21 <infandum> In a do statement, how can I have an IO action run strictly before the next action?
07:31:35 <mclark1129> cool, that will take some time to get my head aroudn fully but I think I'm starting to see the purpose
07:31:36 <dminuoso> infandum: What does `strictly` mean exactly?
07:31:37 <infandum> Like; write a file then read that file?
07:31:51 <EvanR> thats always the case, unless you happen to be using lazy IO
07:32:07 <EvanR> which is only like, getContents and readFile
07:32:11 <infandum> I want to write a diagram to a png file, then read in that file as a raster diagram.
07:32:29 <dminuoso> mclark1129: So it should become obvious that to a consumer there's nothing special - except he's more constrained about what he can do.
07:32:40 <EvanR> infandum: so do that
07:33:03 <EvanR> IO doesnt happen out of order or anything
07:34:19 <EvanR> do{ sendEmail; makeBreakfast; callJim }
07:34:29 <EvanR> 1 then 2 then 3
07:34:37 <dminuoso> `sendEmail >> makeBreakfast >> callJim`
07:35:07 <Rodenbach> fr33domlover: okay, so Iâ€™ll certainly see what else mtl has done besides helping to save stack lift calls.
07:35:27 <infandum> EvanR: I'm doing: https://pastebin.com/XMGSjVAf
07:35:33 <infandum> Resource busy error
07:35:41 <infandum> This is all below a withTempFile
07:36:04 <infandum> D is for diagrams
07:36:19 <EvanR> windows ?
07:36:24 <infandum> linux
07:36:34 <infandum> It makes the file correctly
07:36:42 <infandum> but crashes with that error
07:36:53 <infandum> I want to reiterate that it does render correctly to the file
07:36:54 * EvanR lurches over to the cairo docs
07:37:15 <EvanR> er diagrams
07:37:56 <infandum> That's where I got how to load the file as an image (I have a very complex file, so it slows down everything and I'm checking to see if raster works better).
07:37:59 <dminuoso> infandum: Where does `file` come from?
07:38:06 <infandum> withTempFile
07:38:30 <infandum> withTempFile "." "tmp.png" $ \file _ -> do
07:38:34 <Boomerang> infandum: what happends if instead of `!_ <- ...` you did `func <- ...` and then called `func`?  It looks like some IO function, maybe a way to clean up
07:38:49 <EvanR> the !_ is really unnecessary
07:38:53 <infandum> oh sorry, I didn't have !_ there earlier, I thought that would help but it didn't
07:38:58 <fr33domlover> Rodenbach, surely there are blog posts about mtl and a haskell wiki page :)
07:39:02 <infandum> it was originall just renderCairo...
07:39:10 * EvanR looks for renderDia
07:41:08 <kuwze> what does it mean when I get "FTGL not found" running stack init? it seems to be available here: https://hackage.haskell.org/package/FTGL
07:41:23 <EvanR> still looking for the source code to renderCairo
07:41:37 <EvanR> it seems like renderCairo is not closing the file
07:41:38 <dminuoso> infandum: What package is that from?
07:41:43 <EvanR> diagrams
07:41:59 <infandum> ah
07:43:39 <dminuoso> EvanR: Well none of the diagrams packages have that function...
07:43:59 <EvanR> its in the cairo backend
07:44:33 <EvanR> https://archives.haskell.org/projects.haskell.org/diagrams/haddock/diagrams-cairo/Diagrams-Backend-Cairo.html
07:45:03 <infandum> Testing with hClose
07:45:14 <infandum> That did it
07:45:37 <EvanR> but but
07:46:55 <infandum> Thank you!
07:47:07 <dminuoso> ðŸ˜‚
07:47:20 <infandum> Although I think it should close by default
07:48:06 <lyxia> kuwze: it's not on stackage.
07:48:28 <EvanR> infandum: ... yes, that is what im saying. seems like a bug
07:48:34 <EvanR> which im trying to explain
07:51:45 <EvanR> infandum: hold on... withTempFile takes a file name, and gives you a Handle
07:52:00 <EvanR> which is to an open file
07:52:13 <EvanR> then what, you provide that filename to diagrams cairo?
07:52:18 <EvanR> and not the handle?
07:52:20 <infandum> yeah
07:52:27 <EvanR> that... doesnt sound right
07:52:41 <infandum> So now I also give the handle, then run hClose h before loading the image and it works
07:52:57 <EvanR> it takes a Handle?
07:53:18 <EvanR> it seems to take a String filename
07:53:41 <EvanR> C.surfaceWriteToPNG surface (opts^.cairoFileName)
07:53:45 <kuwze> lyxia: thanks!
07:54:48 * EvanR looking up what that does (in cairo)
07:57:14 <fryguybob> infandum: You should be fine just closing the file immediately.  Alternatively you can use rasterific backend to skip the file step.
07:57:20 <EvanR> https://www.cairographics.org/manual/cairo-PNG-Support.html#cairo-surface-write-to-png
07:57:40 <EvanR> you shouldnt even open the file...
07:58:00 <EvanR> running that creates a new file, which what, clobbers the one you have open, and how does hClosing still work??
07:58:07 <fryguybob> EvanR: The file is opened to ensure that no one else opens a file with the same name.
07:58:07 <EvanR> it doesnt make sense what youre doing
07:58:51 <EvanR> uh you open a file with that name, then ask the library to create one with that name, despite the fact that you tried to stop that? and it works?
07:59:01 * EvanR gives up
07:59:31 <fryguybob> EvanR: withTempFile
07:59:54 <iron_houzi> Which of these two lines looks better: https://gist.github.com/ironhouzi/1e458ccaa7af1beed31caa3cb79f2cd7#file-tib-hs-L46-L47 ?
07:59:54 <EvanR> when you go to open a new file and write to it, there is no need to "first open a file with the same name to stop people to doing that" the initial open is entirely that
08:00:23 <EvanR> fryguybob: cairo_write_surface_to_png takes a name, not a file already created
08:00:28 <fryguybob> EvanR: Right
08:00:29 <EvanR> then it creates that file
08:00:35 <EvanR> what is the point of withTempFile
08:00:44 <fryguybob> EvanR: To clean up the file after use.
08:00:48 <iron_houzi> ..or if there's a better way, I'd be happy to learn..
08:00:56 <EvanR> but at best its creating two files in a row
08:00:59 <fryguybob> EvanR: And to be sure to get a fresh name for a file.
08:01:19 <EvanR> but it opens the file before you... open it
08:01:26 <EvanR> its opening twice
08:01:37 <EvanR> and closing twice
08:01:56 <fryguybob> EvanR: Sure and if Cairo had an interface that used a handle, then it would make sense to use it.
08:02:22 <EvanR> the whole tower is based on this cairo "toy" api that says "dont use this" :(
08:02:33 <fryguybob> EvanR: Yes.
08:02:49 <EvanR> how does it even work though?
08:03:06 <EvanR> like, how does it create a new file on top of the temp file already created
08:03:50 <EvanR> then how does hClose close the right one
08:04:05 <EvanR> and then help
08:04:50 <fryguybob> I don't expect any sanity from non-transactional file systems.
08:07:51 <delYsid> iron_houzi: Well, they are not doing the same thing.  The first removes the last char, and the second removes *any* 'a'.  I'd say the first is less error prone then.
08:09:43 <iron_houzi> delYsid: I see .. but given that the function takes a Letter as input, and the definition of Letter .. the result would be the same though, right? .. is there a more idiomatic way to remove the last element of a list btw?
08:10:23 <EvanR> reverse . drop 1 . reverse
08:11:13 <delYsid> iron_houzi: If you never change the inhabitants of your data type, sure, they are essentially equiv.
08:11:53 <EvanR> f [] = []; f [x] = []; f [x,y] = [x]; f (x:xs) = x : f xs
08:12:16 <dminuoso> lyxia: Regarding your https://dpaste.de/iMCQ#L38 - I just realized this could have been written `gFromAssoc' a = liftA2 (:*:) (gFromAssoc' a) (gFromAssoc' a)` - I was tricked into confusion by this. Is this particular way of using `liftA2` to avoid repeated application common?
08:12:31 <iron_houzi> what about `tail (init xs)` ?
08:13:13 <EvanR> init fails on empty...
08:13:22 <jchia_> Is there a way to delay running an IO until the result is absolutely needed?
08:13:38 <jchia_> A Monad wrapper around the normal IO, perhaps?
08:13:46 <EvanR> you want... lazy IO ?
08:13:51 <jchia_> Really lazy IO
08:13:59 <EvanR> unsafeInterleaveIO literally does that
08:15:13 <delYsid> iron_houzi: In your case, init would work too, as the name of a data type is hopefully never empty.
08:15:42 <EvanR> "is your program solid" "hopefully"
08:16:14 <EvanR> delYsid: it is as soon as you feed in a name 1 character long to this...
08:17:03 <iron_houzi> I see
08:17:56 <delYsid> head :: [a] -> Maybe a
08:18:26 <EvanR> safeFromJust :: Maybe a -> Maybe a
08:19:51 <delYsid> id
08:20:58 <delYsid> init is at least better then /= 'a' :-)
08:21:11 <lyxia> dminuoso: no, what you wrote may actually be much more common
08:24:29 <infinity0> what's the haskell equivalent (or near-equivalent) of lwt from ocaml?
08:24:55 <dminuoso> lyxia: Very well. I think I have fully understood your example - I should be able to tailor this to my needs. Thanks again, it's very enlightening to see this "type driven" machinery.
08:26:32 <dyl> :t :*:
08:26:33 <lambdabot> error: parse error on input â€˜:*:â€™
08:26:37 <dyl> :t (:*:)
08:26:38 <Boomerang> What goes into a TypeRep Fingerprint? I have two TypeRep that are not equal even though they look the same when printed. When looking at the Fingerprint they are indeed different. I am comparing them as SomeRepType, one comes from a haskell ANN pragma and the other is hardcoded. Any idea what I might be doing wrong? :)
08:26:39 <lambdabot> error: Data constructor not in scope: :*:
08:27:54 <dminuoso> dyl: It's from GHC.Generics - you could think of it of a representation of multi argument constructors - which are isomorphic to tuples.
08:29:16 <dzdcnfzd> I'm starting up a new project and I have a difficulty, which is that I need a version of Data.Time.Calendar >= 1.9, but a bunch of deps have the constraint that time < 1.9. Is there any workaround for this sort of thing?
08:29:21 <dzdcnfzd> I suspect there are no breaking changes
08:29:38 <dzdcnfzd> What is the typical thing that one of you guys would do in such a case?
08:30:15 <lyxia> Boomerang: why are you hardcoding fingerprints
08:31:00 <Boomerang> Not the fingerprint, the SomeRepType (SomeRepType (Proxy :: Proxy MyType))
08:32:04 <Boomerang> I am just trying to find the relevant annotations by type as the API usually does but it's failing this time for me so I have been tracking the issue all the way down to TypeRep comparison
08:33:30 <inkbottle> newtype Compose f g a = Compose { getCompose :: f (g a) } deriving (Eq, Show); Compose [Just (1 :: Int), Nothing];
08:33:33 <inkbottle> Is is possible to find an example that doesn't uses two layers of *data constructors*? Like `Compose 1 :: (->) (->) Int`?
08:34:41 <lyxia> Boomerang: maybe there is some kind index that differs
08:35:09 <Boomerang> The usual API uses Serialized. That was failing for my use case so I tried comparing the TypeRep. Would the version of GHC used change the fingerprint of a TypeRep?
08:35:14 <albeit> I have a simple TCP server where I run a new thread for each new connection that adds messages to a Chan, and a main thread that processes the messages sequentially. Is there any benefit to using io-streams/conduit/pipes for this?
08:36:28 <lyxia> inkbottle: What does this even mean "Compose 1 :: (->) (->) Int"
08:36:51 <lyxia> Boomerang: probably yes
08:37:32 <inkbottle> lyxia: trying to understand myself...
08:39:57 <inkbottle> lyxia: Compose 1 :: Compose (->) (->) Int; imitating "Compose [Just (1 :: Int), Nothing] :: Compose [] Maybe Int", two type constructors, and one type constant
08:40:44 <inkbottle> [] Maybe Int = substituted to=> (->) (->) Int
08:41:27 <Boomerang> lyxia: To be more specific I am hacking on the clash-compiler which uses GHC under the hood. If I use cabal to install dependencies (in a sandbox), which version GHC would cabal be using to do that?
08:43:00 <inkbottle> lyxia: Sur my `(->)` construction doesn't fit the bill at all
08:43:33 <inkbottle> but in any case I'm wondering if there would be a solution without *data constructors*
08:44:00 <inkbottle> `(->)` has the wrong arity
08:44:32 <nshepperd1> :t Compose (\_ _ -> 4) -- inkbottle
08:44:34 <lambdabot> Num a => Compose ((->) p1) ((->) p2) a
08:46:22 <lyxia> well without a Compose data constructor, you can define Compose as a type synonym
08:47:21 <inkbottle> nshepperd1: :t Compose id -- but it's not "fully instantiated", like not satisfying
08:48:02 <inkbottle> :t Compose id -- but it's not "fully instantiated", like not satisfying
08:48:04 <lambdabot> forall k1 (g :: k1 -> *) (a :: k1). Compose ((->) (g a)) g a
08:48:28 <nshepperd1> Apart from (->) e you can't really "not have data constructors" though
08:48:58 <inkbottle> nshepperd1: I totally agree
08:49:18 <inkbottle> nshepperd1: at least it was my hypothesis
08:51:56 <inkbottle> lyxia: nshepperd1: tx for the confirmation of the `(->) e` thing; I'll come back to it when it'll be clearer in my mind ;)
08:53:08 <nshepperd1> :t Compose (+)
08:53:10 <lambdabot> Num a => Compose ((->) a) ((->) a) a
08:54:59 * hackage happstack-server 7.5.1 - Web related tools and services.  https://hackage.haskell.org/package/happstack-server-7.5.1 (JeremyShaw)
09:01:25 <Boomerang> lyxia: We figured out the issue. I was compiling clash-compiler in such a way that clash-prelude (a common dependency where MyType is) wasn't compiled with the same environment even though it was the exact same source code. :/
09:02:55 <lyxia> Oh D:
09:05:54 <wonderer111> I have example code in my Haskell project. I noticed recently that they didn't compile due to changes to the library's API. Is there a way I can add those files in automated testing with `cabal test` or `stack test`? I don't want to run the main function in those files during testing, only that the files in examples/ compile.
09:06:14 <wonderer111> I'm using the tasty framework
09:08:11 <lyxia> to not run the main you can name it something other than main
09:18:29 * hackage rdf4h 3.0.2 - A library for RDF processing in Haskell  https://hackage.haskell.org/package/rdf4h-3.0.2 (RobStewart)
09:20:49 <the_2nd> how can I hardcode a ByeString I wrote to a file into my source code?
09:24:49 <OmegaDoug> Any suggestions on using SSH with Haskell? I've found the libssh2 library but it feels more like i'm trying to reverse engineer how it works rather than use it
09:25:00 * hackage dual-game 0.1.0.1 - Network multiplayer 2D shooting game  https://hackage.haskell.org/package/dual-game-0.1.0.1 (fgaz)
09:25:02 <glguy> the_2nd: You can use Template Haskell to read files at compile time and generate source
09:28:16 <kuwze> how do you use a hackage-only project with stack?
09:28:35 <glguy> You add them to the extra-deps section of your stack.yaml
09:29:52 <manbearpig> hello, noob here
09:30:35 <Rodenbach> I found this Oracle oci lib: https://hackage.haskell.org/package/hocilib
09:30:38 <Rodenbach> Itâ€™s very small and basic and I can run string queries against Oracle. Now there are several sql libs out there for Haskell. For which could it be relatively simple to add support so I can use their higher-level interface which under the hood uses direct oci access?
09:31:24 <manbearpig> I have this type defined in a script Lib.hs:  data Some a = Nothing | Some a
09:31:46 <manbearpig> but when I load Lib.hs using ghci, I can't use Some
09:32:02 <manbearpig> it says: error: Data constructor not in scope: Some
09:32:39 <glguy> manbearpig: Put the file you wrote and then the console output showing you trying to use it on a pastebin site like gist.github.com so we can see what you've got going on
09:32:41 <EvanR> did it load without error
09:33:52 <manbearpig> @glguy sure gimme a sec
09:33:52 <lambdabot> Unknown command, try @list
09:34:55 <manbearpig> http://lpaste.net/364168
09:35:10 <manbearpig> EvanR yes loaded without error
09:35:30 * hackage list-transformer 1.0.4 - List monad transformer  https://hackage.haskell.org/package/list-transformer-1.0.4 (GabrielGonzalez)
09:35:39 <manbearpig> when I type Some 3 : Data constructor not in scope: Some :: Integer -> t
09:36:02 <glguy> manbearpig: You didn't export the data constructors
09:36:21 <glguy> You only exported the type constructor. Try:  Some(..)   or   Some(Some, Nothing)
09:37:29 <manbearpig> works now!
09:37:31 <glguy> If you're just playing around you can omit the export list altogether and everything will be exported
09:37:46 <manbearpig> thanks glguy
09:45:40 <mclark1129> what's the right way to unwrap a nested IO value?
09:45:56 <mclark1129> in my case I've got someFunc :: IO (Async SomeType)
09:46:13 <mclark1129> value <- wait <$> someFunc leaves me with IO SomeType
09:46:18 <glguy> You don't unwrap them
09:46:40 <mclark1129> wrong term probably
09:47:02 <mclark1129> but In this case i go `realValue <- value` to go one more IO level in
09:47:11 <glguy> do theAsync <- someFunc; wait theAsync
09:47:49 <EvanR> Async X isnt really another IO level
09:47:59 <EvanR> its a handle to a thread
09:48:27 <dminuoso> mclark1129: Consult the documentation at https://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html - there's an entire section for how to query Async things.
09:48:37 <glguy> No, but wait <$> someFunc :: IO (IO SomeType)
09:48:52 <mclark1129> ^ that's sort of what I meant
09:49:20 <mclark1129> I'll check those docs though, thanks
09:49:39 <dminuoso> mclark1129: What kind of type signature are you looking for by the way?
09:49:59 <glguy> mclark1129: The code I wrote does what you wanted
09:51:06 <mclark1129> yeah it's kind of the same thing to what I'm doing now right?  albeit slightly different in order
09:51:33 <mclark1129> what I've got now isn't really even bad, just wondering if there was a more idiomatic or cleaner way
09:51:39 <monochrom> As a programmer you need to think much more precisely than "kind of the same thing".
09:53:08 <mclark1129> monochrom: Challenge accepted :)
09:54:21 <mclark1129> I like the style of glguy's approach better though, more straightforward in my eyes so I'll go with that.
09:54:22 <EvanR> i am continually provided with evidence to the contrary
09:54:23 <mclark1129> thanks
09:54:29 <dminuoso> mclark1129: Btw you could do `wait =<< someFunc`
09:54:41 <monochrom> "wait <$> someFunc" and "someFunc >>= wait" are not the same thing.  The >>= one is what glguy provided, except in do-notation.
09:54:53 * EvanR still attempting to see how google's official api bindings can even work
09:55:29 * hackage fb 1.2.1 - Bindings to Facebook's API.  https://hackage.haskell.org/package/fb-1.2.1 (psibi)
10:01:38 <mclark1129> so yeah should have thought through the type signatures a bit more on that one
10:05:34 <dminuoso> How can I judge whether UndeciableInstances is safe for this (the second instance) ? http://lpaste.net/364169
10:06:19 <Darwin226> Hey, this post (http://reasonablypolymorphic.com/blog/higher-kinded-data) hints that you can get lenses without template haskell. Anyone know how?
10:07:53 <dminuoso> :t Control.Lens.Lens.lens
10:07:55 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
10:10:04 <Darwin226> Well, I was thinking that maybe it had something to do with the functor-parametrized data types :D
10:10:21 <Darwin226> I know you can obviously make the lenses manually
10:11:47 <woodson> I have trouble with aeson can anyone help please?
10:12:06 <woodson> I have this data ActionName = Accept |  Clone | Delete deriving (Generic, Data, Typeable)
10:12:19 <woodson> instance FromJSONKey ActionName where
10:12:19 <woodson>     fromJSONKey = FromJSONKeyTextParser (parseJSON . String . capitalizeText)
10:12:31 <woodson> however I am still getting this error
10:12:32 <woodson> instance FromJSONKey ActionName where
10:12:32 <woodson>     fromJSONKey = FromJSONKeyTextParser (parseJSON . String . capitalizeText)
10:12:44 <woodson> instance FromJSONKey ActionName where
10:12:44 <woodson>     fromJSONKey = FromJSONKeyTextParser (parseJSON . String . capitalizeText)
10:13:39 <dminuoso> woodson: Please use the paste service linked in the topic.
10:16:17 <woodson> http://lpaste.net/364170 here
10:16:35 <woodson> I am trying to decode my ActionName values
10:16:48 <woodson> but I want to allow the user to passin the values in lowecase
10:23:37 <dminuoso> woodson: Regardless of your issue, you should be able to use Data.Text.toTitle (thus avoiding the unpack/pack) instead of capitalize (unless you use capitalize in other spots as well)
10:24:50 <woodson> dminuoso: Yes, its being used else where but ya I dont think thats the part that needs fixing
10:27:44 <dminuoso> woodson: What does the implementation for capitalize look like?
10:28:20 <woodson> dminuoso: its just a simple recursion
10:28:25 <woodson> strToUpper :: String -> String
10:28:25 <woodson> strToUpper [] = []
10:28:25 <woodson> strToUpper (x:xs) = toUpper x : strToUpper xs
10:28:37 <woodson> sorry
10:28:38 <woodson> capitalize :: String -> String
10:28:38 <woodson> capitalize [] = []
10:28:38 <woodson> capitalize (x:xs) = toUpper x : xs
10:28:57 <woodson> but the issue is that I am parsing a yaml file
10:29:12 <woodson> and when I pass in actionName: "edit"
10:29:21 <woodson> it wont take but its looking for
10:29:25 <woodson> "Edit" instead
10:30:16 <EvanR> ive spent the better part of the morning scraping 5 different mostly autogenerated google documentations to get what amounts to a type signature
10:30:32 <woodson> but I'm thinking about using the read function but i would like to avoid it
10:30:36 <EvanR> 1989 called they want you to use their type system
10:31:30 <EvanR> i should start a twitter "working without haskell"
10:31:54 <dminuoso> EvanR: Heh. Kind of reminds me of the tweet I read this morning: https://twitter.com/ryanbigg/status/979578016127885312
10:32:11 <dminuoso> My thought was "type system", but their reply was "weaken the type system even further"
10:34:07 <EvanR> all i want to do is append a row to a spreadsheet
10:34:32 <EvanR> is that too much to ask
10:36:01 <EvanR> i get the impression from the design of these apis that the lack of strict signature comes from the general belief "meh just do whatever"
10:36:16 <EvanR> but then... for some reason "whatever" just doesnt work for me when i try it
10:37:10 <EvanR> i believe "whatever" is a lie
10:40:21 <buttbutter> Does anyone have a recommendation for good learning materials on monad transformers?
10:44:56 <shapr> buttbutter: there's a section in Haskell from First Principles, but if you already understand monads, what about starting with ReaderT and seeing how it differs from Reader?
10:45:01 --- mode: shapr set -o shapr
10:45:13 <buttbutter> shapr: I've actually read both chapters in HFP on it.
10:45:23 <shapr> oh, what did you think?
10:45:26 <buttbutter> But....I just feel like HFP occludes everything with massive explanations and details.
10:45:45 <buttbutter> I don't really feel like I understand how to use them in practice or anything after having read it or done the exercises.
10:45:45 <shapr> I think that works really well for some styles of learning, but I have heard that said several times.
10:45:52 <dyl> It... it's official.
10:45:53 <dyl> I've made my PhD program decision.
10:45:53 <dyl> \o/
10:45:54 * dyl is very excited.
10:46:06 <shapr> buttbutter: have you looked at the early research papers or one of the short online tutorials for monad transformers?
10:46:09 <lyxia> buttbutter: https://en.wikibooks.org/wiki/Haskell/Monad_transformers ?
10:46:16 <buttbutter> I just opened " Monad Transformers Step by Step" :)
10:46:27 <shapr> dyl: compilers?
10:46:42 <dyl> PL with a UX bent.
10:46:55 <shapr> dyl: oh good, I have so many ideas and questions in that area!
10:46:57 <dyl> But yes, compilers are involved :p.
10:47:10 <shapr> Have I told you about my thoughts on the UX/UI for a spoken programming language?
10:47:39 <dyl> No?
10:47:51 <dyl> Basically what I'm interested in is what I would call a "humanist" approach to PL.
10:48:16 <dyl> But, I'm also not very so interested in natural language or spoken language metaphors as teaching through tooling.
10:48:34 <shapr> sounds neat
10:48:40 <dminuoso> buttbutter: My way of learning was simple: I just took ReaderT, WriterT, ContT, LogicT, StateT, ExceptT, MaybeT and just blindly followed types. But before I wrote their respective Monad implementations as well.
10:48:50 <dminuoso> buttbutter: After 2-3 you will see the pattern emerge.
10:48:52 <dyl> shapr a spoken programming language sounds very interesting.
10:49:05 <shapr> dyl: yeah, I have a bunch of ideas and thoughts, not so much implementation
10:49:11 <dyl> Could be good for people who can't type for some reason.
10:49:17 <dyl> Probably more useful than my attempt at a nontraditional programming language :p.
10:49:25 <dminuoso> buttbutter: If you take that road, be careful of ListT, since that's actually tricky to get right.
10:49:27 <dyl> But, your idea and mine have a lot in common! Programming without letters!
10:49:33 <dyl> You use speech, I use... emoji..?
10:49:33 <shapr> right!
10:49:37 <shapr> uh, sure
10:49:45 <dyl> :p
10:49:53 <dyl> Let's go to -offtopic, tell me more.
10:49:55 <dyl> or -blah.
10:50:40 <dminuoso> In which case is using UndecidableInstances unsound here? http://lpaste.net/364171 - Only if there's some `instance (FromStrings a) => Read a` right?
10:51:49 <lyxia> Read a => FromStrings a  also seems bad
10:52:04 <lyxia> ah that's what you wrote .. *facepalm*
10:52:45 <lyxia> UndecidableInstances is necessary to write that instance.
10:53:00 <dminuoso> lyxia: Why exactly is such an instance bad?
10:53:13 <dminuoso> I mean this was just an attempt at avoiding unnecessary boilerplate.
10:53:48 <lyxia> Well it's not really bad
10:53:55 <lyxia> it's just that it's rejected by the standard
10:54:10 <buttbutter> dminuoso: Okay! Thanks for the advice.
10:54:19 <glguy> UndecidableInstances just means that things might loop at compile time, not that they're particularly unsound
10:55:14 <glguy> Doing these kinds of overlaps will just be annoying if you use it in some cases with values whose types have type variables in them
11:02:50 <lally`> Hello.  I have a question about taste and preference.
11:05:05 <hexagoxel> is there a way to build haddock without any absolute html links?
11:06:34 <dminuoso> glguy: Do you have an example that could be conflicting?
11:06:44 <lyxia> hexagoxel: which links are absolute for you?
11:07:00 <hexagoxel> those to bootlibs, i think
11:07:00 <dminuoso> lyxia: The file has enabled so many extensions already, 2010 compatibility has been tossed out of the window so far already..
11:07:12 <hexagoxel> at least `base`
11:09:00 <lally`> I have a type that's received in essentially a keyframe + deltas.  I was thinking Monoid, but it if you have data Foo = KeyFoo { value :: Int } | DeltaFoo { delta :: Int }, but you have to drop DeltaFoos ahead of a KeyFoo in a list
11:09:13 <lally`> but that's a bit lossy, so I'm not sure that's the best way to do it
11:09:39 <lally`> Although perhaps the point is that you have a resulting KeyFoo at the end.
11:11:05 <mtjmullen> So if bifunctor is covariant in both types and profunctor is covariant in one and contravariant in another, is there a word for something that is contravariant in both types?
11:11:25 <lyxia> "bicofunctor"?
11:12:30 <mtjmullen> hah
11:12:42 <dminuoso> Cobifunctor?
11:12:49 <EvanR> a bifunctor to hask^op
11:13:06 <phadej> I used `Bicontravariant` name
11:13:11 <phadej> (in glassery)
11:14:00 * hackage streaming-attoparsec 1.0.0 - Attoparsec integration for the streaming ecosystem  https://hackage.haskell.org/package/streaming-attoparsec-1.0.0 (fosskers)
11:14:16 <mtjmullen> phadej: that sounds somewhat familiar, maybe that's where I saw it
11:15:04 <lally`> And a list of deltas can't really be combined.
11:15:08 <Ariakenom> lally`, just consider the associativity. Deltas should be replaced by keyframes anyway right?
11:15:33 <lally`> n/m my last comment, different topic.
11:15:40 <lally`> Yes they can
11:16:47 <dminuoso> lally`: why cant a list of deltas be combined?
11:17:09 <lally`> Ah, because there are more than 1 parameter that can have deltas applied to them (not in my overly-simplistic example)
11:17:31 <lally`> Say data Foo = KeyFoo { firstValue :: Int, secondValue :: Int }
11:17:56 <lally`> | DeltaFooA { firstvalueDelta :: Int } | DeltaFooB {secondValueDelta :: Int }
11:18:26 <lally`> so you can't combine [DeltaFooA 3, DeltaFooB 2]
11:18:42 <mtjmullen> phadej: is that bicontravariant defined elsewhere, or is it really just for demonstration there?
11:19:37 <phadej> mtjmullen: I haven't seen it in the wilderness of Hackage, no.
11:20:05 <phadej> mezzolens has something like that, but not quite
11:20:48 <mtjmullen> Alright, cool.  Thanks!
11:20:53 <phadej> i.e. http://hackage.haskell.org/package/mezzolens-0.0.0/docs/Mezzolens-Profunctor.html#t:OutPhantom
11:21:12 <phadej> which is Profunctor + Bifunctor
11:21:23 <lally`> I guess I'd have to duplicate the full values in the Key type in the delta type, like Delta { deltaA :: Int, deltaB :: Int }, but ugh, that's damned unpleasant as the number of individual parameters go up
11:21:31 <phadej> and InPhantom =~ + Bicontravariant (or other way around)
11:25:12 <EvanR> i demand an arbitrary graph of co and contravariant functors combined
11:26:23 <shapr> cocontrachameleon?
11:27:00 <phadej> Binvariant
11:30:53 <Marisa_> Hi, I have a question about FunctionalDependency
11:31:28 <Marisa_> In particular, with undecidable isntance, you can have instance C a b => C a b, where a (funcdep arrow ->) b
11:32:09 <Marisa_> My question is, doesnt this break what funcdep is trying to do(infer output given input)?
11:47:43 <lyxia> yes it does
11:58:00 * hackage arbtt 0.10.0.1 - Automatic Rule-Based Time Tracker  https://hackage.haskell.org/package/arbtt-0.10.0.1 (JoachimBreitner)
12:04:43 <roslavets> halloa
12:06:01 <roslavets> would somebody be able to answer a quick question?
12:06:24 <cocreature> roslavets: just ask your question and stick around for a while :)
12:06:43 <dyl> roslavets No need to ask to ask, just ask!
12:06:59 <roslavets> coolio!
12:07:38 <roslavets> how can I properly call this function?
12:07:39 <roslavets> https://github.com/mstksg/inCode/blob/08879e8bc854541f68e071d47d47f369a8901dc2/code-samples/fixvec-2/VecWrapped.hs#L22
12:08:18 <lyxia> mkVec vector
12:08:48 <roslavets> I need to specialize it to the correct KnownNat
12:09:24 <lyxia> mkVec @correctKnownNat vector  -- with TypeApplications
12:09:25 <jle`> you can give a type annotation, or let type inference do its job
12:09:36 <jle`> > read "3" :: Int
12:09:40 <lambdabot>  3
12:09:48 <jle`> > read "3" + 5
12:09:50 <lambdabot>  8
12:11:00 <jle`> read @Int "3" also works if you want to be explicit but the type signature is inconvenient
12:12:19 <jle`> but usually we let type inference handle this
12:12:44 <roslavets> so you could just mkVec vec
12:12:51 <roslavets> i get an error with that though
12:13:39 <roslavets> you're saying it can be inferred
12:15:15 <lyxia> not always
12:16:09 <lyxia> roslavets: if you paste your code we may tell you what's wrong faster
12:17:19 <roslavets> I'm just calling the function i linked
12:17:22 <roslavets> with a vector
12:17:28 <roslavets> there's no other code
12:18:12 <roslavets> I'm just wondering how the types could be inferred
12:18:18 <lyxia> give it a type annotation then
12:18:26 <Boomerang> roslavets: It can't infer `n` without a type annotation since n is only on the output
12:18:38 <roslavets> okay, so it can't be inferred
12:18:43 <roslavets> that's all I wanted to knwo
12:18:58 <Boomerang> It can be infered if you use it somewhere where you know what `n` is
12:19:37 <roslavets> well we the n is known at the value level, I'm just wondering if it could be lifted to the type level
12:19:55 <Boomerang> For example: `zipVec a (mkVec v)` it will be infered as the same size as `a`
12:20:17 <roslavets> right
12:20:56 <Boomerang> It can be reified from the value level to the type level but it can get messy pretty fast: https://hackage.haskell.org/package/reflection-2.1.3/docs/Data-Reflection.html#v:reifyNat
12:22:14 <roslavets> Thanks! yeah I guess this is what I was looking for
12:24:44 <cocreature> how can I convince cabal to link my executable against a static C library and include all symbols in that lib? I tried "ghc-options: -optl-Wl,--whole-archive -optl-Wl,libmyexternal.a -optl-Wl,--no-whole-archive" but "nm" still doesnâ€™t show the symbols from libmyexternal.a
12:25:48 <lloney436> .-.            .-.
12:36:49 --- mode: ChanServ set +o glguy
12:41:29 * hackage shell-conduit 4.7.0 - Write shell scripts with Conduit  https://hackage.haskell.org/package/shell-conduit-4.7.0 (psibi)
12:44:33 <plugin> doesIExist :: [L.Fold Foo Bar] -> L.Fold Foo [Bar]
12:45:21 <plugin> ^^ from the Foldl library.   I want something like `sequence` but Fold is not a monad.
12:46:22 <cocreature> :t sequenceA
12:46:24 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
12:46:27 <cocreature> ^ plugin
12:47:32 <plugin> doh
12:47:35 <plugin> thanks!
12:49:26 <cocreature> plugin: ftr the fact that sequence requires Monad instead of Applicative is only a historical accident from before Applicative was a superclass of Monad
12:49:57 <plugin> cocreature: I wondered about that but then it's too late here on a friday for me to think any further
13:03:40 <danilo2> Hi guys! Are there any magic quasiquotes in haskell that would not be evaluated ... in the place of creation ? I just want to do something like `myTHFun [d| data Foo = Foo XFoo |]`, but `XFoo` is not yet defined, it will be defined with this TH. Is it possible somehow? It has to be defined basedo n Foo name
13:05:27 <dminuoso> Im doing some repetitive code in the style of https://gist.github.com/dminuoso/64eb6fbccd19bcc78f6792c1adc88a94
13:05:30 <lyxia> danilo2: what you wrote seems exactly right
13:05:38 <dminuoso> What's the idiomatic way to get rid of these nested Maybe shenanigans?
13:05:48 <lyxia> dminuoso: ExceptT
13:07:04 <cocreature> ah I figured it out, I need to use -fwhole-archive-hs-libs to stop GHC from passing -Wl,--gc-sections to the linker!
13:07:05 <danilo2> lyxia: and I want `XFoo` generate inside `myTHFun`
13:07:53 <lyxia> danilo2: yes, it can do that.
13:08:33 <dyl> dminuoso Will no one rid me of this meddlesome Maybe?
13:08:42 <xsperry> hi, a bit offtopic, but you guys are experts in most fields
13:08:46 <xsperry> what is a bluray remux? is it just trimming extras and bonuses from the bluray to reduce, without reencoding the actual film? or can it also be reencoded
13:08:51 <danilo2> lyxia: what do you mean? That it is possible to ask GHC to just parse this syntax and produce splice and defer its type checking until myTHFun returns?
13:10:03 <dyl> xsperry remuxing in general means recontainerizing a video, in your case from a disc.
13:10:13 <lyxia> danilo2: yes, the quote you are giving myTHFun does that.
13:10:40 <dyl> A video consists of a container format, and N video/audio/subtitle/... streams each with some codec (codec = code + decode)
13:10:54 <dyl> Remuxing is just extracting the streams and sticking them in a new container.
13:11:18 <danilo2> lyxia: sorry for not being clear here. My question was what are the ways to make it working. Is the only way here writing custom quasiquoter with hs source parser  ?
13:11:20 <xsperry> dyl I see, got it
13:11:22 <xsperry> thanks!
13:12:15 <lyxia> danilo2: Does the "[d|" quasiquoter not work?
13:14:32 <danilo2> lyxia: Oh, Im reallly sorry for being not clear enough. No, it does NOT work in my case. When I write `[d| data Foo = Foo XFoo |] I get error `XFoo is not defined` before even myTHFun gets fired
13:17:26 <funrep_> hey, I am writing a parser for a ML-like language, would parser combinators or alex/happy be most suitible? im doing it as an exercise, so i dont really have any perfomrance requirements
13:17:49 <Athas> > round (1.0/0.0)
13:17:52 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
13:17:54 <Athas> Dammit.
13:18:02 <Athas> funrep_: parser combinators will be the most fun.
13:19:01 <Athas> How do you round floating-point numbers properly in Haskell?  The ieee package, which is usually my trusty go-to, does not seem to have a function for it.
13:19:07 <lyxia> danilo2: okay I see, that's quite annoying
13:19:13 <funrep_> I was kinda leaning towards that since ive never used parser generators before, but just wondered a bit what the major difference is ( i assume in parser generator i mostly specifiy the grammar then it should generate code for me?)
13:20:02 <Athas> funrep_: the major difference is performance (parser generators can be somewhat faster), and automatic detection of ambiguities (parser generators will tell you about them; parser combinators will just pick whatever it sees first).
13:20:11 <mnoonan> funrep_: fwiw, ghc uses happy (I think)
13:20:11 <Athas> But parser combinators are way less hassle to use.
13:21:43 <lyxia> danilo2: one hack is to declare a dummy "data X (s :: Symbol)" so this parses [d|data Foo = Foo (X "Foo")|]
13:22:30 * hackage exception-transformers 0.4.0.6 - Type classes and monads for unchecked extensible exceptions.  https://hackage.haskell.org/package/exception-transformers-0.4.0.6 (GeoffreyMainland)
13:22:53 <lyxia> danilo2: there is also [d|data XFoo ; data Foo = Foo XFoo|]
13:23:37 <nikivi> Hope this is the right place to ask this. But I've been reading about lambda calculus. And it seems that if lambda calculus represents kind of the essence of computation.
13:24:00 <nikivi> Then it means that in theory, you only have functions. You can't make constants as those are functions too
13:24:04 <lyxia> danilo2: it's bad to spam #ghc
13:24:07 <nikivi> Is that correct?
13:24:15 <Athas> > round (0/0)
13:24:18 <danilo2_> lyxia: I dont know how to thank you. This actually solves my problem in much nicer way. Actually in my use case I would need only something like [d| data Foo = Foo Self |] because `Self` would indicate these places I need, thats pure genious and much less error prone, because you dont need to repeat the name there
13:24:19 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
13:24:27 <Athas> Haskell's handling of floats is really bizarre.
13:24:29 <funrep_> nikivi: exactly, lambda calculus is turing complete, meaning you can express everything computable in a regular computer in lambda calculus
13:24:48 <lyxia> danilo2_: you're welcome!
13:25:15 <danilo2_> lyxia: thank you <3
13:25:45 <nikivi> And category theory is a kind of extension of lambda calculus. In that it tries to talk about relationships and formalise all the kinds of relations you can have between objects.
13:25:56 <nikivi> I haven't actually dug deep into category theory but I will soon
13:26:10 <funrep_> i haven't studied category theory, but i think it's actually a completely different field from lambda calculus
13:26:28 <funrep_> category theory seems to be more the theory of abstraction, or just generality in general
13:26:31 <funrep_> abstract shit
13:26:49 <buttbutter> nikivi: Actually you can formalize the entire lambda calculus inside of category theory via cartesian closed categories :^)
13:27:07 <nikivi> Abstract math does not necessarily mean computable things. I am curious, is there a point in discussing highly abstract things if we can't compute it?
13:27:18 <buttbutter> It's a pretty nice formalism too
13:28:02 <funrep_> a lot of stuff is useful without being computeable, like, information
13:28:30 * hackage cli-setup 0.2.0.2 - Helper setup scripts for packaging command-line tools.  https://hackage.haskell.org/package/cli-setup-0.2.0.2 (vmchale)
13:29:10 <nikivi> What is the relationship between computation and information?
13:31:11 <funrep_> good question, especially since you can express information with computation (ie the lambda calculus)
13:34:30 * hackage srcloc 0.5.1.2 - Data types for managing source code locations.  https://hackage.haskell.org/package/srcloc-0.5.1.2 (GeoffreyMainland)
13:39:05 <aaronstone>  I'm learning about monads and i have a question for a type to be monad it has to be a member of applicative class but applicatives allow functions in some context to be mapped over so does that mean i shouldn't have a applicative and monad instance for a type where in function inside that type doesn't make sense ?? For example i think say type polymorphic userdata shouldn't have instance of
13:39:05 <aaronstone> applicative class as it doesn't make sense to have a function inside such type ?????
13:40:56 <lyxia> function is data
13:41:03 <shapr> data is function
13:41:56 <aaronstone> I understand that but isn't it a bit odd to have a function isnide a type which is meant to store user data ?
13:42:25 <ddellacosta> aaronstone: what does "function inside a type" mean?
13:42:38 <buttbutter> Well, you could just have a type alias that prohibits that, right?
13:42:50 <woodson> what is the standard way to handle cycle import if one doesnt want to put everything definition in the same file?
13:43:51 <aaronstone> buttbutter: yeah but that's specific to application its not inforced by the type definition of the type is polymorphic ?
13:44:00 <aaronstone> If*
13:44:22 <lyxia> woodson: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate_compilation.html#mutual-recursion
13:44:49 <lyxia> woodson: another solution is to break your types in a way that they don't actually depend on each other
13:46:13 <ddellacosta> okay then, good luck figuring it out aaronstone
13:46:27 <aaronstone> lyxia: if i have a project in which I'm using same libs in different files do i import them everywhere or there is some other way to handle it ?
13:47:15 <buttbutter> aaronstone: I just stumbled upon this, but maybe it will help you? https://en.wikibooks.org/wiki/Haskell/GADT
13:47:19 <woodson> lyxia: Thanks, I just figured it. I think that I need a break from working on my project... starting to ask obvious question..
13:47:28 <woodson> thanks for replying!
13:47:43 <lyxia> aaronstone: some people create a big module that imports and reexports what they need, so in the rest of the project it's one import per file
13:48:06 <lyxia> aaronstone: there is no good way if you need qualified import though
13:48:20 <lyxia> woodson: np!
13:48:31 <aaronstone> lyxia: what's the standard practice in Haskell community overall ?
13:50:44 <lyxia> aaronstone: there isn't consensus on that point.
13:51:36 <woodson> my next step in my project will require me to perform some tasks that are already implemented in program written in node. what are the common ways to execute node in haskell?
13:52:06 <woodson> I've found some stuff about ghcjs but also heard alot of people complain it terms of its performance??
13:52:06 <aaronstone> lyxia: importing them everywhere doesn't seem to be  a problem right ?
13:52:14 <woodson> please correct me if I'm wrong
13:52:24 <centril> what's the bot that makes everything pointfree?
13:52:40 <ddellacosta> centril: pl I believe
13:52:52 <centril> @pl \x -> f x
13:52:52 <lambdabot> f
13:53:03 <centril> ddellacosta: thanks
13:53:08 <ddellacosta> centril: sure thing
13:53:30 <lyxia> aaronstone: it gets annoying, there just isn't a good solution
13:54:18 <centril> speaking of formatting; is there some blessed formatting tool?
13:54:48 <aaronstone> lyxia: so what do you prefer ?
13:58:15 <xsperry> hi
13:58:39 <xsperry> can unsafePerformIO be used to "turn off" haskell's purity whenever you don't feel like dealing with it?
13:59:08 <danilo2_> xsperry: no, dont do that
13:59:19 <xsperry> can one use it like that though?
13:59:41 <danilo2_> xsperry: explain better what you mean please. But in any case its bad idea ;)
14:00:52 <xsperry> danilo2_ I've heard an argument from someone that, since haskell has unsafePerformIO, its claimed advantage, ie purity, is not really an advantage, since you can circumvent it whenever you feel like it
14:01:01 <danilo2_> even using NOINLINE pragma
14:01:21 <lemmih> xsperry: Yes, you can do that. Also, unsafeCoerce# can be used to fix type errors. :)
14:01:49 <danilo2_> xsperry: So as lemmih says , you can use it, but it you will have no guarantees how the program would behave.
14:02:03 <ddellacosta> this is why there is stuff like https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/safe-haskell.html
14:02:25 <danilo2_> xsperry: its safe to use unsafePerformIO ONLY if you use pure C bindings OR you want to have a "global" mutable reference created once
14:02:35 <danilo2_> however the later use case is VERY rarely used
14:03:46 <dminuoso> xsperry: unsafePerformIO is basically a promise to the compiler "look I know this looks impure, but this is pure. I wont care if you never call this, or call this one, or numerous times".
14:05:07 <xsperry> what you wrap in unsafePerformIO has to be pure?
14:05:11 <dminuoso> xsperry: Another common usage is sneaking debug statements into (otherwise) pure code.
14:05:18 <dminuoso> xsperry: Yes.
14:05:29 <danilo2_> xsperry: logically pure, like pure C binding
14:05:32 <fishythefish> (but the compiler doesn't enforce this - you have to)
14:05:48 <Zemyla> I've seen unsafePerformIO used for caching.
14:05:53 <fr33domlover> :t foldr1 (>=>)
14:05:55 <lambdabot> (Monad m, Foldable t) => t (a -> m a) -> a -> m a
14:06:09 <xsperry> I'm not sure what logically pure means
14:06:20 <fr33domlover> is there an idiom / existing function for this?
14:06:26 <fr33domlover> like there's sequence etc.
14:06:49 <dminuoso> xsperry: Well it must be referentially transparent, and not care whether it's invoked at all, or numerous times..
14:06:56 <fr33domlover> (also should i use foldr or foldl there? if m is IO)
14:07:12 <fr33domlover> (and if m is Either?)
14:07:25 <fr33domlover> (to avoid holding huge thunks etc.)
14:08:25 <danilo2_> dminuoso: thats actually not true with top level usage of unsafePerformIO with NOINLINE pragma to create mutable ref ptrs
14:08:53 <dminuoso> Fair enough.
14:09:42 <danilo2_> dminuoso: but this is hack. If you just use it this way it will create the mutable ref once and you could access THE SAME ref in multible functions. If you just copy it to different places by hand, youll get mulitiple refs (so the ref transparency is not working here)
14:09:44 <danilo2_> but again, its hack
14:10:11 <cokaina> Hi, is there someone who uses gentoo?
14:10:19 <danilo2_> cokaina: me
14:11:32 <infinisil> cokaina: just ask the question you actually have
14:11:43 <cokaina> well danilo2_ thx for answering. The thing is I have a .hs file which i need to compile, i try it and when linking process start all kind of errors start to show up because PIE objects
14:11:45 <danilo2_> xsperry: logivally puire means ,taht it could be encoded as `IO Int` but you know its really always the same int - its behaves like pure code. Such situration is when yo uvbind to C - if you know this C functiosn behaves purely, you can use unsafePerformIO
14:11:59 <cokaina> i try to compile with --make -fPIC option as the output says
14:12:12 <cokaina> but i still get the same issue
14:12:38 <dminuoso> xsperry: Generally you can understand unsafePerformIO as "you have to prove this is actually pure".
14:14:43 <dminuoso> xsperry: Some things that make code unpure: "The consumer has to free memory.", "The answer might change depending on the position of the moon.", "Using this launches nuclear missiles"
14:14:48 <danilo2_> cokaina: how have you installed GHC?
14:16:12 <xsperry> so you can't use unsafePerformIO to, say, poke around stateful things (like say a GUI) without dealing with IO because you want to use haskell like a "normal" impure language
14:16:35 <dminuoso> xsperry: Well if you want to do impure things, use IO?
14:16:51 <dminuoso> xsperry: But yes, unsafePerformIO can't be used for that.
14:16:59 <xsperry> why not?
14:17:26 <cokaina> danilo2_: emerge ghc
14:17:41 <dminuoso> xsperry: Because GHC will aggressively transform code. Without IO, it does not have to respect sequencing. It can use sharing to avoid reevaluating.
14:17:53 <dminuoso> xsperry: It might optimize expressions away entirely.
14:18:13 <dminuoso> Or perhaps the same expression gets reevaluated
14:18:42 <danilo2> cokaina: try using stack instead. I was never emerging GHC to be honest - stack downlaods GHC to sandboxed env and setups it for you
14:19:31 <cokaina> danilo2: how do i use stack? i've never used it
14:19:57 <fishythefish> cokaina: https://docs.haskellstack.org/en/stable/README/
14:20:01 <redrapscallion> cokaina: stack is super easy to use. https://docs.haskellstack.org/en/stable/README/#quick-start-guide
14:20:12 <redrapscallion> cokaina: it's literally just a couple of commands and poof, you're set up
14:20:45 <EvanR> highly recommend passing the phase of the moon in as argument
14:21:41 <fishythefish> ^ this allows you to separate your logic into a pure function wrt the phase of the moon
14:22:05 <hpc> EvanR: an environment variable is less code
14:22:54 <EvanR> you can make a case that random number generation etc cant sanely do it like this, but the classic "depends on the phase of the moon" is easy because it doesnt change much relative to the duration of your transaction
14:23:34 <dminuoso> xsperry: I mean, inside IO you can basically pretend it's a "normal imperative language": do { putStrLn "Hi"; a <- getLine; launchMissiles; putStrLn ("Missiles already launched for you, " ++ a) }
14:23:59 <xsperry> true that
14:24:33 <xsperry> IO indicates that possibility though
14:24:40 <infinisil> But you can argue that it's still pure because "it just takes the world as an argument lul"
14:24:48 <cokaina> fishythefish: redrapscallion if i install ghc like this it will substitute my actual ghc?
14:24:50 <dminuoso> xsperry: That just lets you reason about which code has effects, and which code does not.
14:25:02 <fishythefish> cokaina: if you already have a ghc installed, stack can use your system ghc
14:25:10 <fishythefish> cokaina: it can also install its own sandboxed ghc if you want
14:25:18 <redrapscallion> cokaina: it uses a separate version of GHC if you want it sandboxed / to use some other version
14:25:26 <EvanR> no, the world as argument is silly
14:25:47 <marvin3> it can also use multiple independent sandboxed versions of ghc
14:25:54 <EvanR> unless the world is a single unchanging pure thing
14:26:48 <fishythefish> i thought the point of #haskell was to turn everything into an argument
14:27:01 <xsperry> dminuoso which you can't do in a "normal" language. any code can have an effect
14:27:17 <MarcelineVQ> fishythefish: I don't agree with that
14:27:29 <fishythefish> MarcelineVQ: +1
14:28:41 <dminuoso> xsperry: Sure, but that's the massive downside. If I tell you to refactor a function consisting of 10 LoC in Python, would you be able to promise me that your new code does exactly the same?
14:29:04 <redrapscallion> I have a super standard concurrency question -- I have this parent thread and it has three child threads. I need the three child threads to complete before the parent thread works its magic. what's the haskell way to do this? (i'm using ForkIO)
14:29:16 <dminuoso> xsperry: And before you say "sure", consider that any line removed might - in it's entire call tree - call some function that has some sneaky side effects, that the correctness of the program relies on.
14:29:18 <xsperry> dminuoso what is a massive downside?
14:29:19 <cokaina> wow 172 packages to install stack T_T
14:29:35 <xsperry> oh, "any code having an effect"
14:30:07 <xsperry> I'm not arguing otherwise. I was just unsure how to think of an argument that same is true with haskell, because of unsafePerformIO
14:30:16 <redrapscallion> usually, in an OOP language, I would toss all the threads into a thread scheduler, but I don't know it'll work in Haskell.
14:33:45 <fishythefish> redrapscallion: you might find https://hackage.haskell.org/package/base-4.11.0.0/docs/Control-Concurrent.html#g:12 useful
14:36:40 <xsperry> dminuoso to be honest when I am refactoring python I worry about other things than introducing side effects.. such as mistyping variable name crashing my program when I least suspect it :)
14:37:23 <xsperry> *mistyped
14:37:44 <reactormonk> redrapscallion, there's the concurrent haskell book, I've found it to be extremely enlightening.
14:37:53 <dminuoso> xsperry: unsafePerformIO is not intended for side-effects. It's a contract you have to trust.
14:38:39 <fishythefish> redrapscallion: also consider using https://hackage.haskell.org/package/async
14:38:44 <xsperry> documentation seems to be saying the same thing. "For this to be safe, the IO computation should be free of side effects and independent of its environment."
14:38:55 <redrapscallion> fishythefish: ah yeah, someone wrote an article about how forkIO was bad and to just always use async
14:39:04 <redrapscallion> fishythefish: but I wasn't sure how valid it was since it looked like clickbait
14:39:20 <fishythefish> redrapscallion: async is written by Simon Marlow; you can trust it :)
14:39:21 <xsperry> dminuoso but that doesn't hold true for, say, Debug.Trace. so I am a bit confused
14:39:50 <dminuoso> xsperry: Right. That's the other usage I mentioned. In some cases it's easier to simply unsafePerformIO for debugging.
14:39:58 <xsperry> it uses unsafePerformIO to introduce side effects, which is its entire poitn
14:40:00 <redrapscallion> fishythefish: a high-level package is always nice :)
14:40:18 <dminuoso> xsperry: But from an operational perspective you could argue that Debug.Trace is mostly harmless. Besides, such code does not belong into production code.
14:40:55 <dminuoso> xsperry: It's meant as a backdoor when you need to circumvent the type system simply because you dont want to fiddle IO through an entire stack of pure calculation just to observe whether the values of some function are calculated correctly
14:41:04 <dminuoso> It's a debugging technique.
14:41:09 <dminuoso> Not a technique to solve problems with.
14:41:16 <redrapscallion> in my experience, Debug.Trace is kind of painful to work with
14:41:36 <EvanR> you have to make a wrapper for it
14:41:47 <fishythefish> xsperry: I think you might also have the wrong end goal in mind. Haskell doesn't totally prevent you from writing pathological code, but relative to other languages, it dramatically reduces how you can introduce insanity
14:41:49 <redrapscallion> it's usually so much easier to just make my functions more atomic and test those functions
14:41:53 <xsperry> is Debug.Trace using unsafePerformIO in a safe way? line I pasted above from unsafePerformIO documentation seems to suggest it isn't
14:42:15 <EvanR> define safe
14:42:31 <dminuoso> xsperry: Well like you pointed out, Debug.Trace lets you pretend some rather impure code is pure.
14:42:47 <xsperry> https://hackage.haskell.org/package/base-4.11.0.0/docs/System-IO-Unsafe.html  "For this to be safe, the IO computation should be free of side effects and independent of its environment."
14:42:56 <EvanR> then no
14:43:08 <EvanR> trace is totally unsafe
14:43:10 <redrapscallion> how does Debug.Trace have anything to do with unsafePerformIO?
14:43:16 <xsperry> EvanR hmm
14:43:19 <dminuoso> redrapscallion: Debug.Trace.trace uses unsafePerformIO under the hood.
14:43:36 <fishythefish> redrapscallion: https://hackage.haskell.org/package/base-4.11.0.0/docs/src/Debug.Trace.html#trace
14:44:02 <dminuoso> redrapscallion: It's basically some trace s v = unsafePerformIO (do {traceIO s; return v})
14:44:03 <EvanR> xsperry: but you could change the answer... its unsafe if the stuff i am relying on becomes invalid
14:44:07 <fishythefish> "The 'trace' function should /only/ be used for debugging, or for monitoring
14:44:08 <fishythefish> execution. The function is not referentially transparent: its type indicates
14:44:08 <fishythefish> that it is a pure function but it has the side effect of outputting the
14:44:08 <fishythefish> trace message."
14:44:52 <EvanR> if youre relying on sanely organized stderr, then trace can mess it up
14:44:59 <EvanR> if youre not, then it doesnt matter
14:45:06 <fishythefish> Note that "safe" in the context of unsafePerformIO includes referential transparency, but the documentation for `trace` specifically acknowledges this
14:45:31 <infinisil> Better just build all your application with some logging monad
14:45:37 <infinisil> You're gonna want logs in the end anyways
14:45:45 <EvanR> you can always include more things in the bucket "stuff i rely on" to make code no longer pure... like runtime, energy cost
14:46:42 <redrapscallion> i've also wondered -- how exactly would logging work without affecting the results?
14:46:58 <redrapscallion> say you were to use logs. wouldn't logging the result make you prematurely evaluate the thunk and therefore erase the laziness?
14:47:36 <EvanR> if you insist on logging stuff at the totally wrong time like that, then you might even make your program no longer actually function
14:47:45 <EvanR> like logging an entire infinite list before you continue
14:48:57 <infinisil> redrapscallion: The gist is that you use something like the Writer monad to build up a string, then output this at the end of the IO action, so the function is still pure, it just outputs an additional string
14:49:33 <infinisil> Think `a -> (b, String)` instead of `a -> b`, but pack that up nicely with a monad
14:50:33 <xsperry> "then output this at the end of the IO action" <- meant to write logging monad action?
14:50:45 <infinisil> Yeah
14:51:12 <infinisil> IO/file output/some message queue/whatever
14:51:30 <infinisil> redrapscallion: https://hackage.haskell.org/package/monad-logger-0.3.26/docs/Control-Monad-Logger.html
14:51:38 <xsperry> so logging monad doesn't actually write things to a file? you have to do it
14:51:40 <xsperry> never used one
14:52:33 <statusbot> Maintenance update: restarting hackage service now... -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5abeafe6f85c7b04f0e79104
14:52:57 <infinisil> xsperry: You'd use one of these: https://hackage.haskell.org/package/monad-logger-0.3.26/docs/Control-Monad-Logger.html#v:runStderrLoggingT
14:53:23 <infinisil> Which log to stderr/stdout/a channel/file
14:55:06 <EvanR> logging is a nontrivial cross cutting concern that monad transformers can only help with if youre already using monad transformers in anger
14:55:26 <EvanR> because your soul is already lost
14:55:33 <infinisil> Note I actually never used any logger monad myself, but looking at the types in haskell and knowing how monad transformers work makes it pretty obvious how to use it
14:55:45 <infinisil> thanks haskell <3
14:55:45 <EvanR> rewrite the whole thing to use transformers in order to add logging is a ... no
14:56:04 <xsperry> EvanR what would you do instead? I never used transformers
14:57:02 <infinisil> EvanR: There was this recent article on how this person likes to structure their applications: https://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html
14:57:05 <EvanR> well, if you have a program consisting of many threads that communicating with STM or such
14:57:15 <infinisil> I liked that approach and I'll try to use it next time
14:57:17 <EvanR> each one has IO, and can log
14:57:26 <EvanR> or has a handle to the thread responsible for logging
14:57:51 <EvanR> the sink for logs can be an STM channel or mvar
14:58:26 <EvanR> essentially, if you dont already have transformers, you still probably have IO or STM
14:58:38 <statusbot> Maintenance update: Hackage service up & operational again. Thanks for your patience! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5abeafe6f85c7b04f0e79104
14:59:16 <infinisil> I only created a decently sized haskell project once, and I hated myself for not knowing monad transformers from the start. Would have made it so much easier for adding logging and other things
14:59:29 <EvanR> ;_;
15:00:07 <infinisil> I ended up with half of it being in IO and the other half hastily using WriterT for logging
15:00:40 <EvanR> just WriterT over IO ?
15:01:14 <infinisil> Nah, pure writerT, log with putStrLn the result in IO where it was called
15:01:29 <EvanR> WriterT Identity ?
15:01:44 <infinisil> I needed STM a lot so it was WriterT STM
15:01:54 <infinisil> iirc
15:02:32 <EvanR> the only resource you needed was a TMVar Log
15:03:22 <infinisil> It was my first haskell project, now I know :)
15:03:33 <EvanR> bad quality version of this meme https://cdn-images-1.medium.com/max/1600/1*gh9POXppzNAgtncJj17K9w.jpeg
15:03:49 <infinisil> Hah
15:04:14 <infinisil> The code is actually online, I could link it if anybody wants to see horrible Haskell code
15:07:50 <infinisil> It's a server for an online game of 2 players (for a university project)
15:08:33 <infinisil> I certainly learned a lot from it
15:15:44 <statusbot> Maintenance update: restarting now... -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5abeb6cbedd0d404ea16b194
15:22:43 <Ariakenom> restarting what?
15:27:11 <mounty> Can I do anything about "cabal: Encountered missing dependencies:" / "aeson-extra -any" ?  The context is that I want to use https://hackage.haskell.org/package/aeson-extra-0.4.1.0/docs/Data-Aeson-Extra-Stream.html so I've added aeson-extra to build-depends in my .cabal file.
15:27:13 <mounty> The complete line is:  build-depends: base, containers, bytestring, unordered-containers, aeson, aeson-extra, utf8-string
15:27:23 <mounty> I just ran "cabal update" but it didn't fix it.
15:27:38 <mounty> The build command is "cabal build"
15:28:12 <glguy> mounty: Put the .cabal file and the console output of running cabal build on lpaste.net please?
15:28:33 <glguy> Oh, if you're just running cabal build you might need: cabal install --deps , first
15:28:55 <glguy> cabal new-build ; handles downloading and building dependencies automatically
15:29:22 <AWizzArd> In one youtube clip someone brought up the question what the kind of t is when looking at an implementation of lift from MonadTrans t:   lift :: Monad m => m a -> t m a
15:29:31 <AWizzArd> The resolution of this was: * -> * -> * -> *
15:29:39 <AWizzArd> I am a bit sceptical about that.
15:30:15 <glguy> AWizzArd: That answer is missing some ()s
15:30:16 <AWizzArd> I would have thought itâ€™s  (* -> *) -> * -> *
15:30:17 <MarcelineVQ> more likely to be (* -> *) -> * -> *
15:30:24 --- mode: glguy set -o glguy
15:30:55 <AWizzArd> Okay good, so then that person in the clip made a tiny mistake.
15:35:03 <dminuoso> Is there some elegant way to do: (Monoid a) => [Either a b] -> Either a [b]
15:35:20 <dminuoso> Or maybe rather..  [Either a b] -> Either [a] [b]
15:36:21 <dminuoso> Ah well, I guess Data.Bitraversable.bisequence does this
15:36:33 <danilo2> Hi guys! Would anyone tell me what happens here? This single line TH code gives strange compilation error to me: http://lpaste.net/364185
15:36:34 <dminuoso> Cool stuff =)
15:40:36 <glguy> danilo2: I put that into a file and it doesn't give the error you said
15:40:43 <glguy> you'll have to give more information for us to be able to reproduce it
15:41:00 <danilo2> glguy: oh, interesting, hmmmm
15:42:37 <danilo2> glguy: does it still work for you if you put this on top of each file? http://lpaste.net/364186
15:43:01 <danilo2> glguy: if so, ill try to create reproducible minimal example
15:43:28 <danilo2> glguy: thank you for checking it, I was sure it is reproducible, this code does not do anything more here
15:46:01 <mounty> glguy: pastebin rather than lpaste but: https://pastebin.com/497be9JZ
15:48:00 <glguy> danilo2: It's DuplicateRecordFields that's the problem
15:48:14 <glguy> It looks like you have a lot of extensions to clean out of your code
15:48:43 <danilo2> glguy: we've got these extensions enabled globally in the project
15:49:01 <dminuoso> intero is giving me garbage errors that dont happen when I build with stack. killing the intero backend has helped, is this a normal thing?
15:50:11 <danilo2> glguy: thank you for helping with it. Im feelign wrong now I didnt do it by myself. I was not thinking that extension causes it and I should have checked it
15:51:40 <glguy> mounty: Did "cabal install --deps" help?
15:57:43 <mounty> glguy:  I didn't know about it.  I'm running it now after it was suggested in #haskell-beginners.  Thanks for your reply.
16:07:43 <equwal> Just discovered this gem https://gist.github.com/quchen/5280339.
16:18:17 <inkbottle> in: https://github.com/dmvianna/haskellbook/blob/master/src/Ch25-Twinplicative.hs, line 25, the `(->)`; is it the one provided by `Applicative f` or by `Applicative g`, or sth else?
16:18:47 <inkbottle> Is there a automatic way to query that sort of thing?
16:19:03 <fishythefish> line 25 doesn't have a (->)
16:19:20 <inkbottle> ,*>
16:19:28 <inkbottle> my <*>
16:19:36 <inkbottle> sorry
16:19:45 <fishythefish> are you asking about one of them in particular?
16:20:15 <inkbottle> I start again, sorry for the mistyping
16:20:45 <inkbottle> in: https://github.com/dmvianna/haskellbook/blob/master/src/Ch25-Twinplicative.hs, line 25, the `(*)`; is it the one provided by `Applicative f` or by `Applicative g`, or sth else?
16:20:59 <inkbottle> the first one I was thinking of
16:21:07 <fishythefish> okay, again, you mean (<*>), not (*)
16:21:13 <inkbottle> yes
16:21:22 <fishythefish> let me just cover each of them
16:22:27 <orbisvicis> can -- ^ comments be multiline ?
16:22:35 <fishythefish> the left (<*>) comes from g; the right (<*>) comes from f
16:22:59 <inkbottle> fishythefish: how would you know that?
16:23:09 <fishythefish> inkbottle: follow the types
16:23:15 <Tuplanolla> Every time I issue `stack build`, it will rebuild half of the dependencies. Any clues why?
16:24:18 <inkbottle> fishythefish: anyway, thanks a lot, I will use that bit of information to try to understand it for myself
16:24:42 <inkbottle> this line looks quite difficult to my
16:25:29 <inkbottle> to me*
16:25:52 <inkbottle> my keyboard is definitely at fault here
16:26:06 <Tuplanolla> Asking for `stack build --dry-run` always gives `haddock-library-1.4.5: database=snapshot, source=package index`.
16:26:10 <fishythefish> inkbottle: well, you can do it manually or use typed holes to make ghc tell you what the types are
16:26:31 <fishythefish> as an example of the former, consider the rightmost (<*>). it's RHS is a :: f (g a), so it must be using the Applicative f instance
16:26:37 <inkbottle> fishythefish: typed holes, looks great
16:26:43 <fishythefish> as an example of the latter, replace the left (<*>) with _ and try to load the module
16:27:00 <fishythefish> you'll get an error which includes the line "Found hole: _ :: g (a -> b) -> g a -> g b", so this is clearly Applicative g at work
16:27:15 <inkbottle> great
16:27:39 <inkbottle> that will be helpful
16:28:52 <fishythefish> however, if you're really trying to grok the instances for Compose, it's most instructive to work out the types/implementations on your own
16:30:03 <Tuplanolla> Looks like there's an issue about it: https://github.com/commercialhaskell/stack/issues/3899
16:31:46 <inkbottle> fishythefish: sure, but the one for Applicative, I failed to find it out by myself /) [not sure if it's a difficult one or if it's I who is dumb]
16:32:37 <fishythefish> it can be tricky, but on the other hand, the types constrain you pretty heavily
16:32:48 <fishythefish> instead of thinking about the semantics, you can just try to find the only way the types fit together
16:33:02 <fishythefish> (this actually turns out to be a useful technique pretty often)
16:33:24 <inkbottle> Yes, that later part I failed to do
16:34:23 <fishythefish> Well, you know that you want something that looks like `Compose f <*> Compose a = Compose _`
16:34:50 <fishythefish> we have f :: f (g (a -> b)) and a :: f (g a), and we want _ :: f (g b))
16:35:17 <inkbottle> so it's the (a->b) part that must apply
16:35:31 <fishythefish> right, only there are a few layers of indirection
16:35:43 <inkbottle> but it is concealed inside
16:35:48 <inkbottle> right
16:35:49 <fishythefish> if we just had f :: a -> b and a :: a, we could just do (f a)
16:35:58 <inkbottle> sure
16:36:00 <fishythefish> now let's add the first layer
16:36:09 <inkbottle> ok
16:36:10 <fishythefish> f :: g (a -> b) and a :: g a
16:36:29 <fishythefish> now how do we apply f to a?
16:36:39 <inkbottle> that is plain <*>
16:36:46 <fishythefish> right, using the Applicative g instance
16:36:52 <inkbottle> yes
16:36:55 <fishythefish> so f <*> a :: g b
16:37:30 <fishythefish> now the second layer: f :: f (g (a -> b)) and a :: f (g a)
16:38:02 <inkbottle> let's use h instead
16:38:14 <fishythefish> sure, h :: f (g (a -> b))
16:38:21 <inkbottle> h :: f (g (a -> b)) and a :: f (g a)
16:38:24 <inkbottle> ok
16:38:57 <inkbottle> thinking...
16:38:59 <fishythefish> actually, forgive me, I should have done the layers in the other order
16:39:01 <inkbottle> hang on
16:39:05 <fishythefish> mind if I go back a step?
16:39:11 <inkbottle> go on
16:39:18 <fishythefish> suppose we ignore the g layer
16:39:23 <fishythefish> h :: f (a -> b) and a :: f a
16:39:32 <fishythefish> (this is identical to what we did before)
16:39:39 <inkbottle> ok
16:39:54 <fishythefish> so we want to do h <*> a
16:40:45 <inkbottle> h <*> a; works out of the box
16:41:16 <inkbottle> it is plain Applicative
16:42:29 * hackage sitepipe 0.3.0.0 - A simple to understand static site generator  https://hackage.haskell.org/package/sitepipe-0.3.0.0 (ChrisPenner)
16:42:31 <fishythefish> let me rewrite that as (<*>) h a
16:42:38 <inkbottle> ok
16:44:28 <fishythefish> we can think of this as `liftA2 ($) h a`
16:45:45 <fishythefish> but now instead of f (a -> b) and f a, we have f (g (a -> b)) and f (g a), so instead of ($) :: (a -> b) -> a -> b, we need some _ :: g (a -> b) -> g a -> g b
16:46:16 <inkbottle> ok
16:46:34 <fishythefish> what fills in the _?
16:46:54 <inkbottle> <*>
16:47:20 <fishythefish> right, so we get Compose h <*> Compose a = Compose $ liftA2 (<*>) h a
16:47:46 <fishythefish> @src liftA2
16:47:47 <lambdabot> liftA2 f a b = f <$> a <*> b
16:48:13 <fishythefish> so we get Compose $ (<*>) <$> h <*> a
16:48:29 <aasronStone> when developing a lib in haskell is it really a good practice to write typeclasses for types just for the sake of keeping it generic or one should write type classes where generality is really required ??
16:50:15 <fishythefish> inkbottle: in fact, this also makes sense if you build it up with g first, then f. We know that we can use h <*> a to put together h :: g (a -> b) and a :: g a, so if we add an Applicative f layer around everything, we just use liftA2 to make it work
16:50:37 <fishythefish> idk which approach is most intuitive for you
16:50:57 <inkbottle> can we not use liftA2
16:51:09 <fishythefish> sure we can - I did
16:51:16 <inkbottle> liftA2 f x y = f <$> x <*> y
16:51:48 <fishythefish> oh, or are you asking to avoid using it?
16:51:53 <inkbottle> yes
16:52:02 <inkbottle> not so comforatable with it
16:52:10 <fishythefish> :t liftA2
16:52:12 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:52:24 <fishythefish> does the type help? it's pretty straightforward
16:52:25 <inkbottle> ok
16:52:31 <EvanR> when it works well, it works well
16:52:43 <fishythefish> compare with
16:52:46 <EvanR> liftA2 (+) signal1 signal2
16:52:47 <fishythefish> :t fmap
16:52:48 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:53:08 <inkbottle> ok
16:53:10 <EvanR> Num instances eat your heart out
16:56:06 <aasronStone> should one write tyeclasses even when they aren't general enough and user would end up using functions directly ??
16:57:06 <fishythefish> aasronStone: not sure I understand the question - even if you have typeclasses, you still use functions directly
16:57:23 <dminuoso> aasronStone: typeclasses are for adhoc polymorphism.
16:57:33 <inkbottle> fishythefish: Got it: it is a good angle indeed.
16:58:13 <fishythefish> inkbottle: you can go one operator at a time and convince yourself e.g. that (<*>) <$> f does typecheck
16:58:19 <aasronStone> dminusos : what's that ??
16:58:36 <fishythefish> but IMO it's not as intuitive as looking at it as liftA2 or as the equivalent f <$> x <*> y pattern as a whole
16:59:08 <aasronStone> fishythefish : exactly but is it really a good practice to still write typeclasses just to make it look more generic ??
16:59:24 <dminuoso> aasronStone: typeclasses dont make things "look more generic"
16:59:34 <inkbottle> fishythefish: yes, the liftA2 solution is very intuitive
17:00:00 <fishythefish> if you're at the point where you think typeclasses just make your code aesthetically more generic, I'd suggest you avoid them until you actually need the polymorphic behavior they enable
17:00:27 <aasronStone> fishythefish : okay
17:00:30 <dminuoso> aasronStone: Why dont you present a specific example of code, so we can discuss it? :-)
17:01:12 <aasronStone> dminusos : have no code was just pndering about it but leme present an example
17:02:56 <aasronStone> dminuso : suppose say i have a data type called UserInfo and then i can either
17:02:56 <aasronStone> go ahead and directly write functions for UserInfo or i can define typeclass
17:03:02 <aasronStone> and then implement an instance for UserInfo
17:03:16 <marvin3> http://play.typeracer.com <- this is fun
17:03:46 <aasronStone> dminusos : and say Userinfo is a polmorphic type
17:03:47 <fishythefish> don't make typeclasses in one-to-one correspondence with your datatypes just to have typeclasses
17:04:31 <aasronStone> fishythefish : okay, whats the criteria then ?
17:04:38 <dminuoso> aasronStone: When you want polymorphism.
17:05:12 <dminuoso> aasronStone: Num is a good example of this.
17:05:13 <fishythefish> aasronStone: in other words, will you have multiple types which all need to implement the interface your typeclass describes?
17:05:56 <dminuoso> aasronStone: Another is Eq. When you have multiple types that all satisfy a common interface, typeclasses let you express polymorphic functions and values that are more general, but more specific than a fully universally quantified type variable.
17:06:46 <fishythefish> aasronStone: on the other hand, if you realize that the functions you're implementing corresponding to an *existing* typeclass (say, Functor), it may be a good idea to just implement that typeclass instance instead
17:06:57 <fishythefish> s/corresponding/correspond/
17:08:04 <edmundnoble_> The question of "when do I abstract over things" is literally what you've been hired for, for any programming job
17:08:22 <dminuoso> The word literally literally does not mean what you think it means.
17:08:28 <edmundnoble_> It literally may not
17:08:46 <fishythefish> inconceivable!
17:08:57 <dminuoso> fishythefish: ;)
17:08:58 <edmundnoble_> I do not think it doesn't mean what I think it means
17:09:21 <Tuplanolla> Is there a Stack command to prevent rebuilding dependencies?
17:10:08 <edmundnoble_> Regardless it's all you need to think about; lambda calculus is composing functions, which is layering abstractions, which is what design *is*
17:10:30 <fishythefish> the STLC, sure
17:10:51 <edmundnoble_> Right, and Haskell isn't STLC and referring to lambda calculus when talking about Haskell is mostly a meme
17:10:54 <edmundnoble_> The point stands ;)
17:11:13 <edmundnoble_> The answer to "when do I abstract" is "when it benefits you"
17:11:31 <fishythefish> yeah, but the other half of the job is actually doing the abstracting (or not), not just answering the question :)
17:11:47 <edmundnoble_> Well yeah, it may turn out that your abstraction didn't help you, or didn't help you in the way you thought
17:12:14 <edmundnoble_> And there will be a tension between your high-level ideas and your low-level ideas, because abstractions aren't meant to be seamless
17:12:28 <edmundnoble_> To abstract is to ignore, and just like in real life you never know what you can or should ignore
17:13:09 <aasronStone> thank you for enlightening us but wait not thank YOU
17:14:19 <edmundnoble_> ?
17:14:27 <edmundnoble_> I can be a little more specific
17:14:53 <aasronStone> ?? don't bother
17:14:53 <lambdabot>  don't bother
17:14:57 <edmundnoble_> Lmao
17:15:02 <edmundnoble_> The answer to what makes type classes different from higher-order functions, in particular, is that type classes tie types to behavior rather than keeping the behavior on its own
17:16:31 <aasronStone> Oh really ? i didn't know that..
17:17:07 <aasronStone> go read question first and then try to be a smart ass
17:17:49 <edmundnoble_> Your question was whether you should write functions specialized to a type, or on a type class, no?
17:18:41 <edmundnoble_> If you will have only a single type with an instance of the type class, then no, do NOT make a type class, that's for sure
17:18:48 <edmundnoble_> The question doesn't always have an easy answer, but in that case it's simple
17:19:20 <infinisil> edmundnoble_: Except if you're sure that you'll need more than one later on
17:19:55 <edmundnoble_> Right yeah, of course, if you know you'll only have one though it's simple
17:20:05 <infinisil> Yeah
17:20:06 <edmundnoble_> Or even if you don't know if you'll need more later on, in most cases
17:20:26 <edmundnoble_> Unless you can see into the future, which a lot of devs think they can in some cases
17:20:34 <aasronStone> yeah that's what i was asking , weather one should write type classes in cases where there would be few instances (probably 1) but the class in itself is more general and allow others to write another instances of it
17:21:25 <edmundnoble_> In the case that you have one instance and know you'll only have one I'd avoid it. In the case that you have more it's not an easy question whether to make a type class or to make higher-order functions that you pass implementations to.
17:22:11 <edmundnoble_> It depends on how "unique" or "canonical" or whatever fancy word they are; if you could conceivably want to implement multiple instances for the same type, perhaps you shouldn't use a type class
17:22:43 <edmundnoble_> (not just in the case that you have more, sorry, in the case that you *probably will* have more)
17:22:53 <edmundnoble_> If you probably won't but might, I'd just bite the bullet and say no, no type class
17:22:58 <edmundnoble_> Until you need it
17:23:00 <aasronStone> but there are cases say i'm writing a lib where i might only need one instance of a particular type class but the type class in itself is more general and may allow user of lib to use it better ??
17:23:34 <fishythefish> aasronStone: then don't write a typeclass
17:23:49 <fishythefish> if the user needs polymorphic behavior, they can write their own typeclass
17:25:02 <aasronStone> so i see there is no hard and fast rule to decide , as in the case of creating an instance for already existing typeclass
17:25:21 <infinisil> aasronStone: But the library won't take an argument of that typeclass then, it would take an argument of a concrete type and your typeclass would only have a single method to convert it to that concrete type
17:25:36 <fishythefish> however, say you have an internal type T and you have a typeclass C supplying functions F and G. If part of your code can be implemented on a type *only* in terms of F and G (and not on any other details of the type), then the typeclass approach allows a user of your lib to supply their own type
17:26:10 <fishythefish> you can implement instance C T internally, and your users can implement other instance of C to "plug in" their own types instead of T
17:27:45 <aasronSt1ne> did someone say something ?? my internet went down for a moment ??
17:27:52 <fishythefish> create a typeclass if you can write code that generically depends only on the interface supplied by the typeclass and not on the details of any particular type implementing such an instance
17:28:07 <fishythefish> aasronSt1ne: you can view the channel logs; see the topic
17:29:56 <edmundnoble_> Users making type classes which convert to a library-supplied type is a pretty good deal for the authors of both, IMO, though it can lead to a bit of (hopefully totally identical) duplicate code
17:32:29 * hackage typelits-witnesses 0.3.0.2 - Existential witnesses, singletons, and classes for operations on GHC TypeLits  https://hackage.haskell.org/package/typelits-witnesses-0.3.0.2 (jle)
17:32:29 <aasronSt1ne> fishythefish : so why is that a problem if they find it fit to plug in their own type isn't it good ??
17:32:47 <jle`> oh hey hackagebot is back
17:33:19 <aasronSt1ne> fishythefish : it's like you're shipping your default implementation but if they wan't something else you're leaving room for that ??
17:33:49 <fishythefish> aasronSt1ne: perhaps I misunderstood your previous question, then. I thought you were saying the user would want to use your typeclass methods. If they want to supply a typeclass implementation, then yes, that's a good use case
17:35:09 <fishythefish> even if you don't have a default implementation, this is a good use case - it may be that you can define a large suite of generic functions whose implementation depends only on a small set of functions being defined on a type
17:35:44 <aasronSt1ne> fishythefish : no i meant the implementation but what did you think i was asking can you please briefly explain that coz it will help me understand the entire picture ??
17:36:26 <aasronSt1ne> so did you think i was talking about user being able to use functions defined in typeClass ??
17:36:29 <fishythefish> yes
17:37:45 <fishythefish> it's useful to define a typeclass if *you* can write generic code which depends only on the interface and not on the details of the implementing types
17:39:51 <aasronSt1ne> fishythefish : alright, thank :)
17:40:03 <aasronSt1ne> thanks* :)
17:40:16 <fishythefish> if you're not the one benefiting from the polymorphism (even if it's just to create a suite of other utilities a la Monad), don't bother - whoever needs the polymorphism can write the typeclass
17:40:44 <fishythefish> and if you're actually dependent on the implementation details of the type, then you shouldn't be using a typeclass
17:42:01 <fishythefish> (er, to clarify, creating that suite of utilities WOULD be considered beneficial)
17:42:38 <aasronSt1ne> ????
17:43:40 <edmundnoble_> If you don't write methods with types like `MyClass a => ...` don't make a type class
17:44:54 <fishythefish> ^ a good summary
17:45:38 <edmundnoble_> When I say "if you don't write" I mean if you don't write them *in this library*
17:45:59 <edmundnoble_> If the user would conceivably want to make a type class so that they can use your library in a particular way, let them do it themselves
17:47:25 <aasronSt1ne> you mean't this "`MyClass a => ...`" for functions other then defined in typeclass right ??
17:48:35 <aasronSt1ne> than*
17:48:48 <edmundnoble_> Yes true, all of the functions declared in the type class itself have that constraint, functions *outside* the type class specifically
17:49:55 <aasronSt1ne> but is that a good criteria then ??
17:50:27 <aasronSt1ne> but anyway thanks :)
17:50:32 <fishythefish> well, that + the expectation that your typeclass may have other instances
17:51:23 <edmundnoble_> Yeah, both criteria I would say are enough
17:57:59 * hackage hmatrix-backprop 0.1.2.0 - hmatrix operations lifted for backprop  https://hackage.haskell.org/package/hmatrix-backprop-0.1.2.0 (jle)
18:04:41 <inkbottle> :t let f :: a -> b; f = undefined; x :: a; x = undefined in (f, x) -- How to have both type variables `a` to designate the same type? Like with a `forall a` in front of the whole line
18:04:43 <lambdabot> (a -> b1, b2)
18:06:30 <jle`> i wonder why vector on hackage is over a year behind vector HEAD
18:06:57 <jle`> inkbottle: you mean, in ghci?
18:07:24 <inkbottle> or elsewhere
18:07:54 <jle`> can you show an example where you are trying to do this?
18:07:59 <fishythefish> inkbottle: why?
18:08:07 <inkbottle> I would have liked lambdabot to answer (a -> b, a)
18:08:18 <jle`> so this is just a lambdabot thing?
18:08:48 <fishythefish> inkbottle: normally when you want this to be the case, there's some context which allows you to enforce this
18:08:50 <jle`> i mean, you can use nested let-ins
18:09:03 <inkbottle> fishythefish: to help me think (I don't see any other reason for now)
18:09:32 <jle`> i feel like having it return (a -> b, a) would be more confusing than anything
18:09:37 <fishythefish> inkbottle: can you give an example of something you're trying to think through?
18:09:42 <jle`> but you can have the definition of 'x' be inside f
18:10:25 <jle`> :t \f x -> const (f x) (f, x)
18:10:28 <lambdabot> (b -> a) -> b -> a
18:10:34 <inkbottle> fishythefish: I'm still playing with variations of what we spoke of previously, no hard reason at all
18:10:46 <jle`> oops
18:10:52 <jle`> :t \f x -> const (f, x) (f x)
18:10:54 <lambdabot> (t -> b) -> t -> (t -> b, t)
18:11:12 <jle`> :t (\f x -> const (f, x) (f x)) undefined undefined
18:11:14 <lambdabot> (t -> b, t)
18:12:02 <fishythefish> inkbottle: when `f` and `x` are independent from each other, you should actually expect the type variables to be different (to avoid the misleading impression that the type of f's input is the same as the type of x)
18:12:18 <inkbottle> yes, sure enough
18:12:22 <fishythefish> inkbottle: in your case, you do actually want this constraint, but there's nothing to indicate that this should be the case
18:12:34 <inkbottle> yes again
18:12:35 <fishythefish> contrast with jle`'s code above, which applies f to x in order to enforce this
18:13:36 <fishythefish> inkbottle: it may also be the case that trying to get lambdabot/ghci to reuse type variables may not be the easiest way to do what you're trying to do
18:13:46 <fishythefish> maybe typed holes or something would be more useful to you, but it's hard to say without more context
18:15:24 <inkbottle> fishythefish: there is no real need at all, so it's probably why there is no way to write it
18:15:39 <jle`> @let consistentWith = const
18:15:41 <lambdabot>  Defined.
18:15:46 <inkbottle> so that's settled
18:15:51 <jle`> :t (\f x -> (f, x) `consistentWith` f x) undefined undefined
18:15:53 <lambdabot> (t -> b, t)
18:16:22 <jle`> :t (\f x -> (f, x) `consistentWith` f x `consistentWith` f (f x)) undefined undefined
18:16:24 <lambdabot> (b -> b, b)
18:16:41 <fishythefish> jle`: just use a list instead of multiple consistenWiths
18:16:43 <jle`> 50/50 chance that associativity would have broken this lol
18:16:45 <fishythefish> :t (\f x y z -> const (f, x, y, z) [f x, f y, f z]) undefined undefined undefined undefined
18:16:47 <lambdabot> (t -> a, t, t, t)
18:22:55 <jle`> only works if they are all the same type
18:23:09 <fishythefish> oh derp
18:28:30 <inkbottle> Actually I was trying this 'hole', and the answer was not as beautiful as I expected:
18:28:32 <inkbottle> :t let h :: f (g (a -> b)); h = undefined; x :: f (g a); x = undefined in (_ <$> h) <*> x
18:28:34 <lambdabot> error:
18:28:34 <lambdabot>     â€¢ Found hole: _ :: g0 (a0 -> b0) -> g1 a1 -> b
18:28:34 <lambdabot>       Where: â€˜g0â€™ is an ambiguous type variable
18:29:20 <inkbottle> g0 = g1; a0 = a1
18:29:37 <inkbottle> but it has no real purpose
18:29:54 <inkbottle> hence no real way to do it
18:30:38 <fishythefish> as before, it doesn't know that just because you said `f` and `g` twice, you do genuinely mean the same type variables
18:31:01 <fishythefish> so it instantiates fresh ones, which is why you see e.g. both g0 and g1
18:31:07 <inkbottle> yes but I meant it to be the same
18:31:21 <inkbottle> yes, sure enough
18:31:24 <crestfallen> fishythefish: << patient, kind individual
18:31:39 <fishythefish> crestfallen: i'm rarely accused of those two traits
18:32:27 <fishythefish> inkbottle: but why are you trying to do this with a ghci one-liner? this is from instance (Applicative f, Applicative g) => Applicative (Compose f g), which carries a lot more context than what you're supplying
18:32:35 <fishythefish> just put the hole in the file and try to load it
18:33:01 <inkbottle> Sure, I'll do that
18:34:50 <crestfallen> << a.k.a crucify_me had to take hiatus from coding
18:39:58 <inkbottle> emacs/Intero gives me the solution of the hole straight away, with only putting the cursor on the hole (I really must curb that "ghci-one liner thing" of mine)
18:40:19 <inkbottle> I also must find a way to use ghci in emacs
18:41:30 <inkbottle> I actually have 'stack ghci' not really ghci
18:43:31 <fishythefish> same thing, it just uses whatever ghci stack is configured to use
18:47:15 <inkbottle> so you use Intero/emacs for typing and some debugging, and when you want to :load the code you do it in a terminal? (with "stack ghci")
18:47:34 <inkbottle> or do you have a way to directly load it in emacs
18:48:03 <fishythefish> i use vim - i've been trying to switch to spacemacs for a while but i keep going back to vim
18:48:36 <fishythefish> i just have one terminal pane with vim open and another with stack ghci
18:48:48 <inkbottle> ok
18:49:00 <edmundnoble_> VS Code + HIE worked better than intero for me, intero was just so *slow*
18:49:06 <fishythefish> not that you shouldn't take advantage of emacs + tool integration
18:49:29 <inkbottle> emacs is great for me
18:49:50 <inkbottle> I use vim too for for shorter editing
18:50:24 <inkbottle> edmundnoble_: yes intero is slow
18:50:53 <inkbottle> what is VS Code + HIE?
18:50:56 <edmundnoble_> Hopefully there's an HIE emacs mode for you soon, because HIE seems to be on the up and up and intero seems to be designed more as a slight upgrade for GHCi
18:51:00 <edmundnoble_> VS Code is an IDE
18:51:01 <crestfallen> inkbottle: could you paste your color choices in vim? I'm trying to use neovim with the haskell plugin but can't get the colors right..do you use a scheme?
18:51:02 <edmundnoble_> A very light one
18:51:18 <edmundnoble_> HIE is haskell ide engine
18:51:23 <edmundnoble_> VS Code comes with a plugin so you can use HIE with it
18:51:30 <EvanR> interesting
18:51:34 <edmundnoble_> HIE is like an intero replacement with way more IDE-focused features
18:51:44 <edmundnoble_> And it's also not slow
18:51:46 <edmundnoble_> Which is a big plus IMO
18:53:00 <edmundnoble_> I also had a lot of issues while using intero, but that seems to vary wildly
18:53:04 <edmundnoble_> Might for HIE too
18:53:28 <inkbottle> crestfallen: I more often use emacs and my color is emacs-color-theme-solarized; it exists for vim too
18:54:11 <inkbottle> edmundnoble_: sounds good
18:54:51 <edmundnoble_> Most importantly, VS Code also has a vim plugin ;)
18:54:55 <inkbottle> you do "stack install HIE"; or sth like that?
18:55:15 <MarcelineVQ> you google hie and see what installation instructions there are
18:55:27 <MarcelineVQ> because jus getting hie is only part of that
18:55:59 <edmundnoble_> Yeah, though I'd go for "hie haskell" because hie is apparently a common acronym
18:56:01 <inkbottle> OK MarcelineVQ
18:56:42 <edmundnoble_> Get HIE, get VS Code, get VS Code plugin for HIE, read and follow HIE and VS Code plugin instructions, and you should be set
18:56:55 <edmundnoble_> Unless it randomly doesn't work for no reason
18:57:14 <MarcelineVQ> that latter part happened with atom for me hehe
18:58:44 <edmundnoble_> It happened for every IDE I used Haskell with that had any features, from Leksah to neovim-intero to atom-intero to vim-ghcmod to sublime-intero
18:59:06 <edmundnoble_> Had no luck at all at first, and it was too slow if it ever did work
18:59:31 <edmundnoble_> Even Scala's IDE tooling is better
18:59:39 <edmundnoble_> Though not by much
19:01:00 <EvanR> are you talking about https://marketplace.visualstudio.com/items?itemName=alanz.vscode-hie-server
19:02:49 <inkbottle> I love the animated gif: https://github.com/haskell/haskell-ide-engine
19:03:23 <EvanR> what are these gifs ... of ?
19:03:29 <EvanR> since HIE is "not an IDE"
19:03:49 <inkbottle> don't ask me
19:04:08 <inkbottle> not an ide then
19:04:39 <crestfallen> thanks I waste more time on getting my editor right inkbottle . vim is brutal but on my 32bit machine I can't use atom or sublime properly
19:04:54 <MarcelineVQ> HIE is a backend for an IDE, and IDE realized by various frontend plugins for various editors
19:05:14 <MarcelineVQ> *an IDE
19:06:15 <inkbottle> EvanR: good question though
19:07:28 <edmundnoble_> No, HIE isn't an IDE
19:07:38 <edmundnoble_> Installing it into an editor makes it an IDE
19:08:22 <EvanR> is that the vscode bridge you were talking about
19:08:32 <EvanR> or is there another one
19:08:37 <inkbottle> What'd that be? https://camo.githubusercontent.com/2aa08d157d92b2953bd86cfd35769fc0c42fb994/68747470733a2f2f692e696d6775722e636f6d2f3176716d3465462e676966
19:09:00 <EvanR> that url is insane
19:09:28 <inkbottle> because the gif is awesome
19:10:39 <crestfallen> what about a good editor for 32bit machine with pretty colors that is not vim?
19:11:23 <EvanR> sounds like a contradiction
19:11:23 <inkbottle> ed?
19:11:41 <inkbottle> not sure for the colors
19:13:18 <crestfallen> inkbottle, this is my init.vim file. the colors look cool but not on my 32bit machine : https://ptpb.pw/91uP
19:14:55 <davean> crestfallen: If the 32 bit machines has PAE, emacs?
19:15:37 <crestfallen> the type signature and func def lines are utterly different colors. that is annoying. no davean no emacs on it
19:18:25 <inkbottle> crestfallen: have you tried that: https://github.com/altercation/vim-colors-solarized?
19:18:37 <inkbottle> or sth solarized?
19:19:03 <inkbottle> EvanR: have you found what ide it was?
19:21:29 <EvanR> no
19:21:44 <EvanR> didnt really try
19:21:53 <crestfallen> inkbottle, thanks looking at that
19:23:33 <Maxdamantus> crestfallen: presumably you could try copying the Haskell syntax plugin from the good system to the bad one.
19:23:46 <Maxdamantus> (since I'm guessing they're probably different for whatever reason)
19:24:35 <crestfallen> Maxdamantus, tried that. inkbottle thing is in neovim there is a .config/nvim/bundle file so I'll try to clone it into there..
19:25:15 <crestfallen> using pathogen
19:25:52 <crestfallen> thanks Maxdamantus
19:29:23 <laudecay> is there an interpreter that takes haskell to C?
19:29:51 <laudecay> i want to turn in my assignment in shakespeare programming language for the memes, but i also want to write it in haskell for the knowledge
19:30:00 <laudecay> and i have a c->SPL interpreter
19:30:15 <laudecay> kick me if you must i know this is heresy
19:31:49 <laudecay> theres like cython but im already really good at python so thats useless
19:32:04 <inkbottle> laudecay: https://stackoverflow.com/questions/1994190/distributing-a-haskell-program-as-c-source
19:32:23 <laudecay> s a d
19:32:38 <laudecay> wait hold upppp http://repetae.net/computer/jhc/
19:32:43 <laudecay> god bless america this is happening
19:32:51 <EvanR> i dont understand what youre wanting
19:33:03 <laudecay> my roommate just said "Jhc Haskell Compiler: Jesus Heckin Christ"
19:34:10 <laudecay> EvanR: I want to fuck with my TA by turning something in in Shakespeare Programming Language
19:34:11 <EvanR> "John's Haskell Compiler"
19:34:22 <laudecay> beacuse this class is easy and i am bored and have a sick sense of humor
19:34:47 <crestfallen> inkbottle, how would one learn to interpret and edit that giant file solarized ?
19:34:54 <laudecay> we're allowed to turn shit in in any language we like, as long as we can provide detailed instructions to compile it on the department servers
19:35:08 <laudecay> i have to implement paxos
19:35:35 <EvanR> JHC bullet points: "No garbage collector. A variant of Region Inference is in the works." o_O
19:35:45 <EvanR> what is this alien tech
19:38:09 <laudecay> yeah okay i'll turn in brainfuck
19:38:17 <laudecay> jhc -> c -> brainfuck
19:47:12 <EvanR> now i feel like writing myself a malbolge
19:47:55 <laudecay> i see you are a man of culture
19:49:25 <inkbottle> edmundnoble_: VScode seems very very nice, but it wont do with my fully open source debian; I like very much the code preview sidebar
20:08:06 <laudecay> so i'm simulating a system with some internal state and a list of events that have to occur to the system. would the state monad, with getNext processing each event, be the right way to structure this code?
20:09:19 <EvanR> if its as simple as an s, and a [s -> s], then its a simple fold
20:09:44 <laudecay> i mean there's the side effect of it's got to print things during the transformations
20:10:00 <EvanR> then its a scanl :)
20:10:48 <laudecay> huh this looks good
20:11:32 <laudecay> wow this type is exactly what i want
20:12:09 <laudecay> wait it may not be. EvanR i don't want a list of states at the end, I want a list of strings
20:12:32 <EvanR> map a function that views the state as a string
20:12:57 <laudecay> oh that'd be awful, i have two lists of ADTs and a queue and 2 ints that have to come with it
20:12:59 <EvanR> and its not really "at the end" right...
20:13:05 <laudecay> that sounds really ugly
20:13:17 <laudecay> yeah i was thinking it would print as it went along? but it doesn't have to
20:13:21 <laudecay> it's simulating paxos
20:13:21 <EvanR> what do you mean
20:13:42 <EvanR> yes it would print each state one after the other
20:13:58 <laudecay> that's not what i need though, the input and the output are very different looking
20:14:08 <EvanR> theres input ?
20:14:22 <EvanR> ah the input is the list of transformations
20:14:23 <laudecay> like it's taking in a list of events and printing messages pertaining to the results of each event
20:14:26 <laudecay> yeah
20:14:34 <EvanR> what is the output?
20:14:39 <laudecay> im not explaining well but i'd feel cheaty if i put the assignment in here
20:15:05 <laudecay> it's dependent on the state and the event after the event happens
20:15:27 <EvanR> if you map over a list of "events" to get a list of S -> S, then scanl it, then map the S -> String, then you have the answer afaict
20:16:08 <laudecay> but it'd be difficult to extract the information i need from the states themselves
20:16:11 <EvanR> but doing it this way may not be flexible to the next time you change your mind about what the problem is
20:16:18 <laudecay> the things i want to print have more to do about the events
20:16:30 <laudecay> i'm not changing my mind i'm just bad at explaining im sorry :(
20:17:12 <EvanR> if the view is S -> E -> String, then you zipWith that on the [E] and the scanl ([S])
20:17:46 <EvanR> its possible to confound any haskelly sensibility, you just havent yet :)
20:18:09 <laudecay> so i guess i can explain a little better. we're simulating a network and some computers attached together in a distributed system. there's a timestamp, lists of different types of computers with some attributes. all of these can be changed by events, which either constitute requests from outside the system or computers failing on their own
20:18:38 <EvanR> nod
20:18:38 <laudecay> the output is like events that depend on what's pending in the network, what nodes are failed, what state the nodes are in, etc
20:18:55 <edmundnoble_> Inkbottle: I get that. Nicely done.
20:19:05 <laudecay> i think it's more like S -> E -> (S, String)
20:19:07 * EvanR waits for you to say that each node in the network has an arbitrary other type of state
20:19:12 <laudecay> which looks sorta statemodey
20:19:30 <EvanR> it sounds like youre conflating stuff together
20:19:34 <laudecay> wdym arbitrary other kind of state
20:19:52 <EvanR> arbitrary state *type*
20:20:21 <EvanR> like, nodes 4 7 and 9 have type Char, 2 has type whatever i want, and ones that are a power of 5 have state type XML
20:20:42 <laudecay> my state was gonna have a list of pnodes :: (Bool, Int), a list of anodes :: (Bool, Int, Int, Int)
20:20:48 <laudecay> no there are only 2 kinds of nodes thankfully
20:20:55 <EvanR> alright
20:20:55 <laudecay> and then there's a queue of events, and two more ints
20:21:06 <EvanR> well part of your state is the queue, and also the network graph
20:21:10 <EvanR> or node set
20:21:26 <laudecay> there's not really a graph, just a node set and a queue that they can put things in
20:21:33 <EvanR> its all still a state, whether its a simple value or a collection
20:21:48 <laudecay> sending a message means putting into the queue, recieving is removal
20:21:57 <laudecay> yeah so idk i think this is the state monad still
20:21:59 <EvanR> the more complex it gets, doesnt reduce the applicability of scanl
20:22:38 <EvanR> state monad doesnt actually get you anything here, wrt state being a detailed collection of things
20:22:44 <laudecay> but the things i need to print out sort of represent state transitions that depend on prior state and event, and would be hard to get from "oh here's the new state versus the last one"
20:23:05 <EvanR> when you want state transitions, from a ss::[S] you do
20:23:13 <EvanR> zip ss (tail ss)
20:23:16 <laudecay> i just don't understand why returning something at each step that describes the transitions that just happened isn't helpful
20:23:27 <EvanR> you can try it
20:23:33 <laudecay> and why i don't need that functionality? i guess
20:23:42 <EvanR> you can get it from the simpler pieces
20:23:52 <laudecay> which simpler pieces though?
20:23:56 <EvanR> otoh if you start with the whole thing clobbered together, it doesnt go back to simple
20:24:34 <laudecay> i pm'd you sorry im just so bad at explaining
20:24:50 <EvanR> 1. the list of input events, just as you said. 2. the view of a state-event pair, or event-state0-state1 triple as a string. 3. the mapping of events to state transition operations
20:25:14 <laudecay> but there's no mapping of events to state transitions
20:25:21 <EvanR> why not
20:25:35 <EvanR> doesnt an even have some action on the state
20:25:43 <laudecay> like multiple things can happen due to some event?
20:25:50 <laudecay> and they all depend on the state
20:26:06 <EvanR> why do you mean by multiple, like, its non deterministic?
20:26:24 <laudecay> no it's deterministic but one event doesn't necessarily correspond to one line of output
20:26:26 <laudecay> oh wait shit
20:26:32 <EvanR> lines?
20:26:41 <laudecay> did you read my PM though
20:26:49 <laudecay> i think i maybe just figured out how to solve this
20:26:51 <EvanR> String may contain several lines of text...
20:27:04 <laudecay> aaaaa one second brb i was thinking about this wrong im sorry
20:27:22 * EvanR throws a rubber duck into the machinery
20:30:12 <laudecay> ok there's a list of events and a queue, and if there's an event from stdin at some timestamp, then we process that and print a line. else, if there is anything in the internal network queue that we can process, we process that and print a line. else, we just print the timestamp on an otherwise empty line. then we move on to the next timestamp.
20:30:17 <EvanR> basically, the problem began sounding pretty functional. then you insisted it would benefit from an imperative implementation for some reason, and described it in imperative terms. and that tends to rile me up :)
20:31:00 <laudecay> things are initially stuck in the queue because of external events, but they can also be queued from internal events.
20:31:27 <EvanR> when that happens, you want an abstraction that treats both kinds of events the same way
20:31:45 <laudecay> yeah, i think that just having runstate do that is the right answer... i don't know
20:31:55 <laudecay> like runstate $(MAX_TIME) number of times
20:32:00 <EvanR> more like, just do the whole thing in IO
20:32:10 <EvanR> the State monad doesnt help you at all here
20:32:28 <laudecay> how would i do the whole thing in IO?
20:32:38 <EvanR> a lot easier than trying to do it half in IO half in State
20:32:52 <EvanR> IO is much better at "state" than State
20:33:07 <laudecay> oh i didn't clarify. we aren't waiting on things from stdin. the program is run like ./paxos < file_with_one_event_per_line.txt
20:33:22 <laudecay> so we get a big ol list of things at the beginning and idk if they're sorted or not
20:33:32 <laudecay> also there can be multiple events per timestamp
20:33:35 <EvanR> then load all the events from stdin and now you have a list of timestamped events
20:33:44 <EvanR> no more IO
20:33:50 <laudecay> that was the plan
20:34:07 <EvanR> now you are in a position to solve it without having "state" in the traditional sense
20:34:53 <EvanR> the timestamped reports are a pure function of that input list
20:34:54 <laudecay> oh hm do you mean like with recursion?
20:35:09 <EvanR> scanl, zipWith, and map do recursion for you
20:35:34 <laudecay> i don't think map is the answer because everything is tied together here
20:35:40 <EvanR> you just have to define what events do, which are functions
20:36:04 <laudecay> scanl is closer, let me look at zipWith
20:36:11 <EvanR> i didnt say map was 'the' answer
20:36:13 <laudecay> btw thank you so much for you patience
20:36:21 <EvanR> or that you will be able to do all this with one function
20:37:20 <EvanR> do the effects of events depend on future states?
20:37:36 <EvanR> if not, even easier :)
20:38:12 <laudecay> well, an event just modifies the state and is over with, but the internal state keeps evolving for several timestamps down the line
20:38:21 <laudecay> if that's what you mean?
20:38:25 <EvanR> no
20:38:39 <EvanR> but thats useful info, states change in response to time, not just events?
20:38:39 <laudecay> and a second event can happen while the internal state is still processing and fuck things up
20:38:48 <laudecay> oh i mentioned the timestamp thing a while ago
20:39:01 <laudecay> like one timestamp, either process one event or one thing from the queue or nothing at all
20:39:04 <EvanR> well, when i hear timestamps, i think... event
20:39:10 <EvanR> not "nothing much happened at this time"
20:39:22 <laudecay> they're just ticks in a simulation
20:39:30 <laudecay> god i am so bad at explanations i am so sorry
20:39:31 <EvanR> the ticks are explicitly provided? o_O
20:39:43 <laudecay> the ticks at which the events occur are, yes
20:39:47 <EvanR> seems a big inefficient
20:39:56 <EvanR> yeah were not on the same page
20:40:06 <laudecay> oh this is a class assignment so we can learn a distributed system consensus algorithm
20:40:12 <EvanR> are you thinking, every time the computer clock pulses, its an event?
20:40:27 <EvanR> or 4 events occur per pulse? or... ?
20:40:30 <laudecay> no, there's like a timestamp in the program state
20:40:36 <laudecay> nothing to do with computer clock
20:40:37 <EvanR> :|
20:40:49 <EvanR> good luck sorting this out, itll be a wild ride!
20:41:06 <laudecay> like "ok we are at timestamp 001, do we need to do any events? no, ok, is there anything in the queue to do? no, ok, advance."
20:41:18 <laudecay> sorryyyyyyyy i know how to in python i just suck at haskell
20:41:39 <EvanR> does anything happen between events, or not
20:42:02 <laudecay> stuff in the queue can happen
20:42:09 <laudecay> events are the things listed on stdin
20:42:11 <EvanR> didnt we agree that that is an event
20:42:27 <laudecay> ok with that definition it's either one or zero events per timestamp
20:42:38 <laudecay> the problem statement doesn't call those events
20:43:12 <EvanR> so you have 3 names, events, timestamps and things in the queue. which are all timestamped
20:43:33 <EvanR> my question is, does anything happen between these timestamped things
20:44:10 <laudecay> nope
20:44:22 <EvanR> great, so you dont have to increment a counter and check if anything is happening
20:44:32 <EvanR> because that is a lot of useless work
20:44:40 <laudecay> uhhhhh wait no the queue is not timestamps
20:44:42 <laudecay> timestamped
20:45:07 <EvanR> what is stuff doing in the queue without a timestamp
20:45:28 <laudecay> you increment the counter and check for events which came of stdin, then if there are none check for stuff in the queue and do that, otherwise continue
20:45:37 <laudecay> events and stuff in the queue can both add to the queue
20:45:48 <laudecay> but only a new timestamp can ever remove from the queue
20:45:58 <EvanR> i dont believe that
20:46:14 <EvanR> because you would continually grow the queue attempting to clear it
20:46:30 <EvanR> i think you dequeue as you service the items
20:46:33 <laudecay> they /can/ add to the queue but they don't have to, and there is not an event every timestamp
20:46:42 <laudecay> a new timestamp is what services the items
20:46:49 <laudecay> only one thing can be done at each timestamp
20:46:58 <EvanR> it sounds like somebody already implemented this for you
20:47:03 <laudecay> but one thing doesn't /have/ to be done at every timestamp
20:47:08 <EvanR> (actually, that is what paxos is... unfortuantely)
20:47:18 <EvanR> youre not thinking how to model it, youre thinking how to type it in
20:47:26 <laudecay> it's a consensus algorithm that exists, we're just implementing it
20:47:59 <EvanR> a lot of these distributed "algorithms" tend to just be fully fleshed out programs
20:48:00 <laudecay> the state evolves in some way and produces an output at each timestamp
20:48:03 <EvanR> without concrete source
20:48:07 <EvanR> rather than just the algorithm
20:49:01 <laudecay> anyway w/e the type i need basically reduces to  S -> [(S,d)]
20:49:05 <EvanR> like, imagine if instead of http being what it is, it was telling you how to write a browser
20:49:12 <EvanR> what data structures to use
20:49:27 <laudecay> maybe possibly (S -> (S,d)) -> S -> [(S,d)]
20:49:30 <EvanR> you can get that goal type from the simpler pieces
20:49:47 <laudecay> i think the latter might be more correct
20:49:49 <EvanR> difference between the ends and the means
20:50:22 <EvanR> one reason for doing what i said was, implementing functions of type S -> S is a lot easier on your hands than S -> (S, String)
20:50:31 <laudecay> i mean they explicitly told us to abstract the network away by using a queue where one thing max can be removed each timestamp
20:50:37 <EvanR> especially if you can zip and scan it all together to get what you said later
20:50:54 <laudecay> umm... I think i'm just really bad at explaining
20:51:02 <laudecay> or maybe i'm not understanding what you're saying
20:51:17 <laudecay> but i think i know exactly how to implement this with the state monad so i'm going to go ahead and do that
20:51:24 <EvanR> well, if everything is on discrete timestamps, then how about modeling that as a list. and nothing happens between timestamps
20:51:44 <EvanR> like i said, try State and see what happens
20:52:24 <laudecay> i'm looking at the game example off haskellwiki and this is basically exactly what i want
20:53:25 <EvanR> after thinking about the thing *behind* paxos for a minute, later you can maybe see how to do it functionally and not imperatively
20:54:11 <laudecay> wdym the thing behind paxos
20:56:12 <EvanR> there are many ways to implement the same function
20:56:38 <EvanR> "the same function" is what i mean by whats behind
20:57:22 <EvanR> the choice of way, thats where you can make it prettier, uglier, more maintainable, more job-secure :)
20:57:56 <EvanR> but aiui stuff like paxos is always described in a very concrete 1 way
20:58:07 <laudecay> :D i will keep that in mind as i learn more about haskell
20:58:16 <laudecay> but right now i'm just getting back into it after over a year hiatus
21:05:45 <laudecay> EvanR: how bad is it to use the state monad for the queue, which is going to be inside my other state
21:05:53 <laudecay> i feel like that's a real bad plan right there
21:22:59 * hackage data-inttrie 0.1.4 - A simple lazy, infinite trie from integers  https://hackage.haskell.org/package/data-inttrie-0.1.4 (LukePalmer)
21:49:25 <EvanR> laudecay: what do you mean use it ?
21:52:19 <EvanR> like i said, literally using State by itself for some is super niche if ever useful
21:52:26 <EvanR> for something*
22:01:08 <laudecay> i swapped to python
22:01:55 <jchia_> I've been quite confused, for a long time, about the difference between ErrorT (mtl package) and EitherT (either package). What's the difference? Which one should I use? What does it mean when the EitherT documentation says that it does not require a spurious Error instance for the Left case"? For one thing, it looks like EitherT is not so convenient to use in a monad transformar stack that involves the reader, writer and state transfor
22:01:56 <jchia_> mers?
22:03:04 <EvanR> laudecay: please turn in your lambda badge and license to use recursion
22:03:12 <EvanR> youre dismissed
22:04:01 <EvanR> *for next 90 action packed minutes laudecay goes renegade and implements paxos in python in a totally functional way, breaking all rules*
22:04:18 <laudecay> i just
22:04:23 <laudecay> ADTs were making me sad
22:04:43 <laudecay> i will come back to it maybe, i python'd out of frustration but then i realized the professor didn't constrain the problem enough
22:04:53 <laudecay> so i might actually be alright and this might be a doable thing
22:05:03 <laudecay> it turned out the state monad was the right decision though
22:05:23 <EvanR> it sounded like you really wanted to use it "somehow"... perhaps on multiple things
22:05:32 <EvanR> of course, you kind of cant use it on more than one thing
22:05:42 <laudecay> yeaahhh
22:05:49 <laudecay> no the state is just the state of the system
22:05:55 <laudecay> im runstate'ing max_time times
22:05:57 <EvanR> i was trying to cure you of that disease
22:06:01 <laudecay> and the output thing is the string
22:06:11 <laudecay> and i figured out sequences for queues
22:06:18 <laudecay> ill come back to it once the professor writes me back?
22:06:48 <EvanR> data Queue a = Queue { front :: [a], back :: [a] } is best Queue <3
22:08:18 <EvanR> also theres this funny thing that happens when you think you need Reader, Writer, and State monads all at the same time
22:08:29 <EvanR> somebody tells you about the RWS monad
22:08:35 <EvanR> which is all three
22:11:16 <EvanR> by anyway, takeaway is that monads are really a famous sideshow to the real wonders of haskell and FP
22:11:45 <laudecay> tru
22:12:03 <laudecay> i just did them in my haskell class last year and i feel like they fit here pretty neatly
22:16:33 <MarcelineVQ> EvanR: and someone else comes along and tries to get you to pass arguments instead and they get funny looks
22:21:38 <mounty> I thought that Data.Aeson.Extra.Stream.streamDecode https://hackage.haskell.org/package/aeson-extra-0.4.1.0/docs/Data-Aeson-Extra-Stream.html would take input comprising multiple expressions, and return a list of JSON objects.  E.g., {"A":"a"}{"B":"b"} would return two objects.  In fact, it seems to take an array, and requires something like [{"A":"a"},{"B":"b"}].  Is there any way of parsing a stream of concatenated JSON
22:21:40 <mounty> expressions?  Something like ByteString -> (Value, ByteString) that will consume some input and return the rest?
22:25:13 <EvanR> mounty: well, the parser `json' in Data.Aeson.Parser is just an attoparsec parser
22:25:53 <EvanR> if you combine that with a "get the rest of the input" parser, that gives you want you want literally
22:26:04 <EvanR> you may also want to try pipes-aeson
22:29:32 <mounty> EvanR:  I'm out of my depth.  Can you easily point to some examples or suggest search terms on how to use Data.Aeson.Parser.json ?
22:30:03 <johnw> with Trifecta, does anyone know how to turn a Span into a simple error message with the underlining of the offending text?
22:30:14 <johnw> I see how to make an ErrInfo, just not how to turn that into a Doc
22:32:17 <johnw> i mean, there's a Rendering, but I don't see how to turn it into text
22:32:22 <johnw> edwardk: ping
22:32:40 <EvanR> mounty: beginning with the goal type, ByteString -> Maybe (Value, ByteString), you can see that parseOnly :: Parser a -> ByteString -> Either String a
22:33:01 <EvanR> and json :: Parser Value
22:34:04 <EvanR> takeByteString :: Parser ByteString, "consume all reamining input and return as a single string"
22:34:28 <EvanR> liftA2 (,) json takeByteString :: Parser (Value, ByteString)
22:34:40 <EvanR> do the puzzle pieces look like they fit now?
22:35:09 <mounty> Sort of, EvanR;  thank you;  this is new to me so let me chew on it for a while.
22:35:33 <EvanR> if liftA2 is an unnecessary distraction... its the same as
22:35:45 <johnw> ah, I see
22:35:50 <EvanR> do{ v <- json; rest <- takeByteString; return (v,rest) }
22:35:53 <johnw> explain + Rendering + Err
22:38:00 * hackage map-classes 0.1.0.0 - A set of classes and instances for working with key/value mappings.  https://hackage.haskell.org/package/map-classes-0.1.0.0 (clinton)
22:38:05 <EvanR> once you have that, you have to decide how youll deal with parse errors
22:41:47 <mounty> EvanR:  this is just an exercise so it doesn't have to be robust.
22:42:24 <EvanR> you will get used to making it really aweomse as an exercise
22:42:52 <EvanR> for example what i told you it was really easy to make it the entire sequence is "error" if anything at any point fails to parse
22:43:14 <EvanR> you get no data if like... the second to last message is invalid json
22:43:21 <EvanR> very boring :)
22:45:48 <mounty> Frankly EvanR I have spent enough time on this and the JSON parsing is a peripheral issue on what is supposed to be a shortest-route problem.  Implementing Dijstra's algorithm was relatively easy but acquiring the map data and enquiries thereon, which arrive in a stream of JSON terms, has been complicated.
22:46:17 <mounty> I almost decided to go with one-term-per-line but thought that there must be a better way.
22:46:17 <EvanR> is it out of the question to just stick '[' and ']' around it
22:46:36 <EvanR> well, one thing on a line is also really easy
22:46:41 <mounty> It is out of question, yes, because the input is prescribed as part of the problem.
22:47:05 <mounty> One thing per line WOULD be easy, yes, but it's not ideal.
22:47:18 <EvanR> no?
22:51:30 <mounty> It's an exercise for a job application and sample input is provlded, some of which is spread over multiple lines.
22:51:44 <EvanR> ew yeah
22:52:17 <mounty> As this is the first job that promises work in Haskell, I don't want to stuff it up.  ;-)
22:52:35 <EvanR> i did one of those, and i put a massive amount of error checking, validation, and shortcircuits for failure
22:52:58 <EvanR> they didnt really appreciate that part
22:53:22 <mounty> I think that's overkill in this situation.  The problem doesn't specify that;  they're more interested in how I go about solving the core route-traversal problem.
22:54:01 <EvanR> yeh so when you get Either back from attoparsec, crash on left
22:54:35 <EvanR> trustMe :: Either String a -> a
22:56:12 <EvanR> > (either error id) (Right "cool")
22:56:15 <lambdabot>  "cool"
22:56:33 <EvanR> > (either error id) (Left "oh no mr bill")
22:56:36 <lambdabot>  *Exception: oh no mr bill
22:58:50 <nshepperd> 'either error id' is one of my favourite combinators
23:01:43 <EvanR> idris is jealous im sure
23:17:17 <bennettbackward_> hi
23:21:58 <johnw> if anyone is looking for some fairly straightforward Haskell fun work, I could use helpers to implement more of the Nix builtin functions for hnix. If your idea of fun is re-implementing 'map', let me know. :)
23:22:23 <johnw> We're currently failing 65 of the 171 Nix language tests, but every day it's getting better
23:23:10 <EvanR> by fun work you mean, unpaid work haha
23:23:18 <johnw> yeah, but it's pretty addictive actually
23:23:30 <mcspud> So is money.
23:23:32 <mcspud> Money is addictive.
23:24:04 <robstr> morning
23:24:23 <EvanR> > either error ($)
23:24:27 <lambdabot>  error:
23:24:27 <lambdabot>      â€¢ No instance for (Typeable a0)
23:24:27 <lambdabot>          arising from a use of â€˜show_M844869193109296402425632â€™
23:24:29 <EvanR> oops
23:47:29 * hackage backprop 0.1.5.0 - Heterogeneous automatic differentation (backpropagation)  https://hackage.haskell.org/package/backprop-0.1.5.0 (jle)
23:53:29 * hackage dbus-th 0.1.3.0 - TemplateHaskell generator of DBus bindings  https://hackage.haskell.org/package/dbus-th-0.1.3.0 (IlyaPortnov)
23:54:29 * hackage dbus-th-introspection 0.1.2.0 - Generate bindings for DBus calls by using DBus introspection and dbus-th  https://hackage.haskell.org/package/dbus-th-introspection-0.1.2.0 (IlyaPortnov)
