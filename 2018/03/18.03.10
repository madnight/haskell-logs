00:01:24 <woodson> kosmikus: Please do so, I already started my webpage I will be writting tuts too. Since I shifted to haskell what I noticed is lack of docs... For one of my open source course, I have to contribute to an open source project and I was thinking about just finding random project and just write docs
00:01:41 <woodson> but I noticed a lot of the projects that requires that a quite complex...
00:02:08 <cocreature> ideasman42: "unfoldr" doesn’t quite fit due to the final "yield" of size (I missed that when I read the python version, sry). I’d probably just write a recursive function
00:02:15 <woodson> I feel a bit lost.. the first one that I look into was reflex
00:02:21 <woodson> oh lord...
00:02:40 <ideasman42> cocreature: so should I use unfoldr at all?
00:02:40 <kosmikus> :)
00:02:46 <cocreature> ideasman42: no
00:03:01 <ideasman42> or any other feature I should check on for creating a flat list from recursion
00:03:41 <woodson> by the way looking to contribute to an open source project for a course so if anyone has anything simple .. ping me please
00:03:50 <cocreature> I mean you could do it with "unfoldr" but I’m not sure you gain a whole lot by doing so
00:04:18 <ideasman42> am real beginner though, so wouldnt know a different way :S
00:04:42 <cocreature> ideasman42: just write a recursive function that creates the list
00:05:42 <kosmikus> woodson: just for completeness, there *is* a tutorial on generics-sop, but it's lengthy and somewhat more oriented towards the language concepts being used than what you actually can do with the library: https://github.com/kosmikus/SSGEP/raw/master/LectureNotes.pdf
00:07:10 <cocreature> > let f 0 size = [size]; f n size = let value = size `div`2 in value : f (n - 1) (size - value) in f 8 1000
00:07:12 <lambdabot>  [500,250,125,62,31,16,8,4,4]
00:08:18 <ideasman42> cocreature: thanks! I'll try understand it now
00:10:56 <kosmikus> cocreature: should it really output the last number twice?
00:11:43 <cocreature> kosmikus: that’s what ideasman42 told us
00:11:52 <kosmikus> hmm, ok then :)
00:12:01 <woodson> kosmikus: Thanks! Well i dont know much about generics except that it does magic. So it would be nice to know what the generic was meant for
00:12:02 <cocreature> kosmikus: iiuc the numbers should sum up to the input number
00:12:23 <ideasman42> right
00:12:30 <kosmikus> ok
00:15:04 <kosmikus> would be a nice unfold / anamorphism for NonEmpty, but I see the library doesn't provide one
00:41:36 <superlinux> hello
00:43:16 <superlinux> it appears that haskell was not accepted for google summer of code. it looks like google has no benefit of haskell.
00:43:40 <superlinux> or it had its share of benefit
00:43:41 <cocreature> superlinux: Haskell _was_ accepted for gsoc this year
00:44:18 <superlinux> my bad. I clicked the wrong article
00:44:40 <superlinux> I want to train myself on haskell through such projects
00:45:51 <duckqlz> deadline is march 11th I think
00:46:33 <superlinux> duckqlz, I am not admitting myself to the program. but I just want to see the projects listed.
00:46:48 <superlinux> it's just to keep me busy
00:47:11 <cocreature> https://summer.haskell.org/ideas.html has a number of project ideas
00:56:27 <qeyoa> does anyone know of an example of a disjunction tautology?
00:56:45 <cocreature> qeyoa: "true \/ true" ?
00:57:00 <qeyoa> what is that symbol in the middle?
00:57:07 <cocreature> logical disjunction
00:57:12 <cocreature> maybe I’m not understanding your question
00:57:54 <qeyoa> i guess that makes sense
01:01:38 <koz_> qeyoa: p \/ ~p also works.
01:01:49 <ZeuPiark> yeaux
01:02:06 <cocreature> koz_: depending on your logic :)
01:02:37 <koz_> cocreature: Yeah, I know in Kleene's 3VL that's not a tautology. Don't remind me. :P
01:02:57 <cocreature> koz_: I was more thinking about something like Coq
01:03:15 <rizraz> ls
01:03:24 <koz_> cocreature: Why are you not named 'coqreature'?
01:03:36 <cocreature> heh
01:03:49 <koz_> Dem multi-layered references.
01:07:24 <Darwin226> With generics, can I be sure that there wont be any :+: types in the parameters of :*:?
01:07:57 <Darwin226> I'm guessing yes for derived instances, but are handwritten instances something that people do?
01:42:23 <ruuns> Good morning :)
01:51:39 <jluttine> Is Edward Kmett here? Or does someone else know if ad package works with repa/hmatrix/accelerate or some other matrix algebra package?
01:52:21 <jluttine> Or if some other automatic differentiation package has such support?
01:56:23 <cocreature> jluttine: afaik "ad" doesn’t support any of those. however, jle` recently recently released a new package called "backprop" https://github.com/mstksg/backprop which does support hmatrix using the "hmatrix-backprop" package https://github.com/mstksg/hmatrix-backprop#readme
01:56:34 <cocreature> not sure if there’s anything that uses repa or accelerate
02:08:53 <vincentcjc> ?
03:34:21 <vaibhavsagar> hi, is there a function like sequenceA but on Functors?
03:35:16 <cocreature> vaibhavsagar: no, Functor is not sufficient to implement sequenceA
03:37:43 <cocreature> vaibhavsagar: do you have some specific type that’s only an instance of Functor but not an instance of Applicative that you want to implement sequenceA for?
03:39:13 <shafox> I am looking for streaming package usage examples however not finding it. Can someone post the links to blogs/codes etc. ?
03:43:03 <cocreature> shafox: have you seen the “Where can I find examples of use?” section ih the README of streaming?
03:45:21 <shafox> cocreature: I did, but it redirects to either a lib or small program. I was more looking for some big projects.
03:47:14 <lseactuary> hi can someone help me with a couple of lines of haskell code so i can finish making my pictures :)? i tried to make the code but im getting an error but when i check hoogle i seem to be using the functions okay. for the last code i am unsure how to define it.
03:47:39 <lseactuary> http://lpaste.net/2170277430281895936 -- line 46 is the error. and line 49/51 i am not sure. the rest of the code compiles.
03:49:16 <cocreature> shafox: fair enough, not sure if there are any public big projects
03:52:16 <dibblego> after creating an executable with "ghc-options: -with-rtsopts=-N", running that executable produces the message: "unknown RTS option: -N" — what is the correct way to build an executable with this option?
03:52:36 <dibblego> vaibhavsagar: there is Distributive, which uses Functor, and is similar in shape to sequence
03:53:09 <cocreature> dibblego: try passing -rtsopts as well
03:53:27 <the_2nd> I use Strings within my program and am wondering whether I should switch over to Text. In my case those strings are often split / recombined and manipulated in many ways. Is Text still the go-to option for this use case?
03:53:31 <dibblego> cocreature: I should mention, I have that already
03:53:58 <dibblego> ghc-options: -threaded -rtsopts -with-rtsopts=-N
03:54:52 <cocreature> weird, that should work
03:55:18 <sternmull> lseactuary: It would be nice if you would tell us the error you get. I suspect that it is trying to use min for Complex Double which is not an instance of Ord.
03:55:26 <lseactuary> sure!
03:56:00 <dibblego> cocreature: I am running 'cabal build' then running the executable
03:56:23 <cocreature> dibblego: can you show us your cabal file?
03:56:55 <lseactuary> sternmull it doesnt seem to let me upload the error in the code file. can i use pastebin?
03:57:01 <dibblego> cocreature: I will make it so, please stand by
03:57:25 <sternmull> lseactuary: I don't care
03:57:40 <lseactuary> https://pastebin.com/fMnfLrnL
03:58:42 <sternmull> lseactuary: Thats what i thought. Why are you using Complex for the positions? I would expect them to be pairs of Double.
04:00:29 <sternmull> lseactuary: Oh wait, its about Position itself.
04:00:33 <lseactuary> yeah
04:00:52 <lseactuary> type Extent = (Position, Position)
04:01:28 <lseactuary> type Position = Complex Double
04:02:20 <lseactuary> you think i need to write it like (a:+bi, c:+di) instead?
04:03:07 <lseactuary> sorry like (a:+b,c:+d) (e:+f,g:+h)
04:03:21 <dibblego> cocreature: I cannot seem to reproduce it on my machine, which is running intel. I have the problem on raspberrypi/arm
04:04:25 <sternmull> lseactuary: I think it will not work at all because you can't define a sensible min for Position the way you need it. I think you want a position with the componentwise minimum/maximum coordinates for the corners. This something different than ordering both positions.
04:04:38 <the_2nd> If I "mutate" / split a string very often, is Text still the best choice or might String perform better?
04:04:46 <ahihi> dibblego: https://ghc.haskell.org/trac/ghc/ticket/13007 seems relevant
04:05:04 <dibblego> ahihi: yes indeed that does seem relevant, thanks
04:06:22 <sternmull> lseactuary: Also i still think that type Position = Complex Double is a bad choice. Complex numbers are a different concept than 2D coordinates (which i think your code is about).
04:07:19 <cocreature> the_2nd: I don’t think there is a reasonable way to answer this question. it really depends on your specific application, so just try both and benchmark.
04:08:54 <the_2nd> cocreature, that's also a good answer. I'll keep going with String then. If things seem 'too slow' I'll try switching over to Text
04:09:11 <kuribas> the_2nd: if you mutate it often, perhaps think of an algorithm that doesn't mutate often?
04:09:36 <the_2nd> kuribas, interpreter for text mutation ;)
04:09:56 <kuribas> the_2nd: not sure what that means...
04:10:18 <the_2nd> only goal of the algorithm / program is to mutate text
04:10:27 <the_2nd> so I guess doing that often is fine in my case
04:11:02 <kuribas> the_2nd: Lazy Text is likely to be as efficient, or more efficient.
04:11:30 <kuribas> the_2nd: String is a bit more convenient
04:12:50 <lseactuary> sorry i didnt realise the internet cut. did i miss anything?
04:12:51 <the_2nd> kuribas, yep. Just wanted to make sure that the usage of String isn't a definite bad idea
04:14:40 <kuribas> the_2nd: String might be fine, it just depends on the case.  Benchmarking is a good idea.
04:15:31 <cocreature> as a rule of thumb, if you end up holding the whole string in memory, Text is more often than not a better choice than String
04:24:03 <lseactuary> anyone understands how to fix line 46 please? im thinking unionExtent (a:+b,c:+d) (e:+f,g:+h) = something. but i am not understanding why there are 2 points in an extent.
04:24:29 <lseactuary> is it a pair of (lower left, upper right)?
04:24:52 <lseactuary> so the rectangle that bounds them is what? the outer one or the inner one?
04:29:30 <sternmull> lseactuary: You can do something like "lowerLeft = min <$> a <*> b" and "upperRight = max <$> a <*> b". This applies min/max componentwise.
04:30:08 <sternmull> where a and b are your positions
04:30:46 <sternmull> and assuming y axis points upwards :)
04:30:54 <lseactuary> lol
04:31:27 <lseactuary> hmm but its complex so y could be negative
04:31:30 <lseactuary> as could x
04:32:46 <lseactuary> or one could be negative, one position could be positive
04:33:27 <sternmull> Complex is an instance of Applicative, "min <$> (100 :+ 2) <*> (11 :+ 22)" is "11 :+ 2". Negative components don't need special treatment.
04:33:37 <lseactuary> interesting
04:37:46 <lseactuary> sternmull i think my definition is still wrong
04:38:04 <lseactuary> Couldn't match type ‘(,) Position’ with ‘Complex’       Expected type: Position         Actual type: (Position, Position)
04:40:40 <sternmull> i think it should look like "unionExtent (t1,b1) (l1,r1) = (min <$> l1 <*> b1, max <$> t1 <*> r1)"
04:41:27 <sternmull> oh wait...
04:41:28 <lseactuary> ooh
04:41:49 <lseactuary> hmm
04:43:51 <sternmull> i am not sure how to understand your Extent. Is it minium coordinte and maximum coordinate? Then your naming t1/b1/l1/r1 does not make sense (assuming it means top, bottom, left and right). Because it is more likely "unionExtent (bl1,tr1) (bl2,tr2) = (min <$> bl1 <*> bl2, max <$> tr1 <*> tr2)"
04:44:13 <lseactuary> this is what the book says:
04:44:18 <lseactuary> An SVG file must specify the extent of its drawing—that it, the bounding box, the smallest rectangle with edges parallel to the axes that contains the drawing.
04:44:22 <the_2nd> is there any way to get a list of all constructors within a sum type for non nullary constructors? I don't care about the constructor parameters and only need the constructor names
04:44:28 <lseactuary> We represent an extent as a pair of positions, the lower left and upper right corners: type Extent = (Position, Position)
04:44:43 <lseactuary> We define a function to compute the union of two extents: unionExtent :: Extent → Extent → Extent
04:44:57 <sternmull> then my last definition should do the job.
04:45:12 <lseactuary> yeah this is why i was a bit confused
04:45:29 <lseactuary> its basically 2 position, each of them containining a bottom left and upper right, right?
04:46:12 <sternmull> each position is a corner. So you have one that is bottom-left and another that is top-right (for y pointing upwards and x pointing to the right).
04:46:23 <lseactuary> ah ye good good
04:46:39 <lseactuary> :)
04:46:46 <the_2nd> lseactuary, note: I used to switch to this notation n == negative, p == positive    x then y   -> nn == bottomleft   pp == topright  etc. makes things especially easy if you'd like to go highter than two dimensions
04:47:06 <lseactuary> nice note!
04:47:08 <sternmull> Calling a position "left" or "right" is an insult to it because you ignore an y coordinate.
04:48:12 <lseactuary> makes sense
04:48:37 <lseactuary> can you kindly help me with the last functions? shapeExtent :: Shape → Extent and drawingExtent :: Drawing → Extent then can assemble the code and im good to go :)
04:49:35 <lseactuary> i think its shapeExtent (Polyline positions) = something of the form (Position, Position)
04:49:47 <lseactuary> but not getting how to do the transform
04:50:21 <the_2nd> lseactuary, fyi : your original pastebin link seems to have expired
04:50:32 <lseactuary> oh
04:50:34 <lseactuary> 2 min
04:51:04 <cocreature> lseactuary: try to figure it out on an abstract level first before you start implementing it. given a set of 2d points, how can you find a minimal bounding rectangle for those points?
04:51:39 <lseactuary> http://lpaste.net/2569097613668253696
04:51:56 <lseactuary> cocreature this is for shapeExtent?
04:52:01 <lseactuary> we solved the other one :)
04:52:16 <cocreature> yes
04:52:20 <Ariakenom> the_2nd: There should be a way to get constructors from a type with Typable https://chrisdone.com/posts/data-typeable
04:52:55 <cocreature> Ariakenom: no Data.Data is the one you need for that, not Data.Typeable
04:53:37 <sternmull> lseactuary: Polyline is a list of positions. So you have to reduce it to one position with the minimum coordinates of all elements and another position with the maximum. You probably can figure out the necessary Haskell code on your own :)
04:53:53 <lseactuary> oki lemme try :)
04:54:21 <lseactuary> can you also explain what i need to do in  drawingExtent then i can try both and show
04:54:57 <the_2nd> lseactuary, maybe the fooBB functions are of help for you https://github.com/I3ck/HGE2D/blob/3a50b57bf51642bc8d44b828620898ee9e31db09/src/HGE2D/Geometry.hs#L123
04:55:40 <lseactuary> nice thanks!
04:55:58 <sternmull> Your Drawing is a list of Shapes. So you basically do the same as with a list of positions: Get the bounds of the individual shapes and then the bounds of all that bounds.
04:56:43 <qeyoa> what are some efficient ways to parse/understand pieces of code? I try to go through the functions with a simple argument example, but if there more than a few functions my mind gets a stackoverflow after i'm half way in the code. I often spend a few hours iterating this process with not much to show for it. For example i tried to extend this exercise code: http://lpaste.net/363370 with disjunction, but
04:56:49 <qeyoa> have difficulty understanding the whole process and am not sure how to check if what i did works.
04:57:42 <the_2nd> qeyoa, it's a problem of unreadable code
04:57:59 <cocreature> qeyoa: start by figuring out some testcases for which you know the correct answer
04:57:59 <the_2nd> except those are function names which are used in that field
04:58:08 <lseactuary> cool ill try and come back with a solution :)
05:12:10 <qeyoa> ok, i think i found a tautology that i could test with my `disjunct`: `(Imply (Disjunct (Var 'A') (Var 'B')) (Disjunct (Var 'A') (Var 'B')))`
05:12:14 <qeyoa> seems to return true
05:15:10 <lseactuary> sternmull am i close? http://lpaste.net/2569097613668253696
05:27:06 <lseactuary> kinda stuck :/
05:29:57 <lseactuary> can someone explain what i am doing wrong (not the answer, so i can learn)
05:32:16 <cocreature> lseactuary: start by telling us the error you’re seeing
05:32:45 <lseactuary> sure
05:33:17 <sternmull> lseactuary: I think the problem is that "x = map fst p" is parsed as "x = map (fst p)".
05:33:43 <lseactuary> ye i also put brackets around (map fst) with similar errors
05:33:44 <sternmull> oops, the other way around
05:34:11 <lseactuary> ive updated my recent code
05:34:26 <lseactuary> Couldn't match expected type ‘[(b, b0)]’ with actual type ‘Shape’     • In the second argument of ‘map’, namely ‘(Polyline positions)’       In the expression: map fst (Polyline positions)       In an equation for ‘x’: x = map fst (Polyline positions)
05:34:30 <lseactuary> same issue for the y
05:35:08 <cocreature> lseactuary: remove the Polyline wrapper around positions
05:35:18 <cocreature> positions is a list, so you can apply "map" to it
05:35:34 <cocreature> "Polyline positions" is of type Shape so you can’t apply "map" to it
05:35:46 <sternmull> and ignore what i said
05:36:00 <lseactuary> oh
05:36:18 <lseactuary> im trying to apply may to the fst function
05:36:21 <lseactuary> its not allowed?
05:36:27 <cocreature> :t map
05:36:29 <lambdabot> (a -> b) -> [a] -> [b]
05:36:30 <lseactuary> im trying to extract all the first values, then take the min
05:36:38 <cocreature> the first argument to "map" is a function of type (a -> b)
05:36:44 <cocreature> that’s "fst" in your case and that’s fine!
05:36:50 <cocreature> but the second argument has to be of type [a]
05:36:58 <cocreature> and "Polyline positions" is of type Shape
05:37:10 <lseactuary> yeah
05:37:19 <lseactuary> but just positions is type [] no?
05:37:36 <cocreature> positions is of type "[Position]"
05:37:40 <lseactuary> ah
05:37:50 <cocreature> so GHC sets "a = Position" and procedes
05:37:56 <lseactuary> i see
05:38:50 <cocreature> I recommend taking a closer look at the error message: “Couldn’t match expected type [(b, b0)] with actual type Shape in the second argument of map” is telling you pretty much exactly what I just told you :)
05:39:11 <lseactuary> yup just thinking how to convert
05:39:21 <lseactuary> we need a double map?
05:39:42 <cocreature> you don’t need to convert anything, just use "positions" directly instead of wrapping it in the "Polyline" constructor
05:39:55 <lseactuary> hmm but that is what i did originally and i get this error
05:39:56 <lseactuary> 2 min
05:40:40 <lseactuary> http://lpaste.net/2569097613668253696
05:41:15 <lseactuary> also isnt it minimum/maximum instead of min/max this time because its from a list
05:42:02 <cocreature> alright, take a look at the error: it’s telling you that it expects something of type "[(b, b0)]" but you’re giving it something of type "[Position]"
05:42:21 <cocreature> the problem is that "fst" can only be applied to a tuple
05:42:25 <cocreature> but Position is not a tuple
05:42:41 <lseactuary> yeah hence i need to iterate the map fst on each tuple in positions right?
05:42:54 <cocreature> so you either need to replace "fst" by something that extracts the first element from Position or you need to convert Position to (Double, Double)
05:43:45 <lseactuary> showPos does this no?
05:44:06 <cocreature> no it doesn’t, the return type of showPos is String not (Double, Double)
05:44:19 <lseactuary> hmm so then probably easier to change fst
05:44:20 <lseactuary> thinking
05:47:08 <lseactuary> hmm i guess easier to change positions
05:47:21 <lseactuary> i need an iteration?
05:47:59 <lseactuary> as the first / second element of a pair in positions could be empty i guess?
05:50:23 <lseactuary> cocreature can you give me a clue?
05:50:51 <lseactuary> i am checking stackexchange and they also do the may fst so i reckon i need to change the positions type but no idea how
05:51:54 <lseactuary> *map fst
05:52:15 <cocreature> fst can only be applied to things of type (a,b) so if you want to change the definition of Position so that you can apply "fst" to it, Position has to be a type synonym for (a, b) for some choice of a and b
05:53:38 <lseactuary> hmm but positions is a list
05:53:46 <lseactuary> of pairs so i guess that is hard?
05:54:02 <lseactuary> but map fst should take fst and apply it to each pair no?
05:54:13 <cocreature> it’s not a list of pairs, that’s the whole problem here! it’s a list of Position and Poyou have definition Position as Complex Double
05:54:23 <cocreature> s/Poyou/you/
05:56:08 <lseactuary> positions = [(x:+y,x2:+y2),(a:+b,c:+d)] or positions = [(x:+y),(x2:+y2),(a:+b)]
05:56:10 <lseactuary> ?
05:57:07 <lseactuary> the second one right? hence fst wont work.
05:57:13 <lseactuary> ok checking hoogle
05:58:52 <EvanR> heh ... why complex numbers dont get as much flak for "it is a pair of reals" as vectors or matrices as being a grid
05:59:41 <EvanR> er not matrices... linear maps, tensors
05:59:56 <EvanR> matrix is by definition a grid
06:00:46 <kuribas> how come this has two methods with the same name? https://hackage.haskell.org/package/aeson-1.2.4.0/docs/Data-Aeson.html#t:FromJSONKey
06:02:37 <lyxia> kuribas: one is the signature of the default implementation
06:02:48 <lseactuary> cocreature even x = map fst (realPart positions) fails :(
06:02:51 <lseactuary> i really dont know
06:03:25 <kuribas> lyxia: I see, thanks
06:04:31 <cocreature> lseactuary: please don’t take this the wrong way but I recommend that you pick up some introductory Haskell book. you seem to have a fair amount of trouble understanding the basics of the language and I don’t think a “learning by doing” approach is particularly well suited for learning those
06:05:20 <lseactuary> this is an intro book lol
06:05:30 <cocreature> then I recommend going back a few pages :)
06:07:31 <lseactuary> cocreature sure but can you confirm which is correct for positions? positions = [(x:+y,x2:+y2),(a:+b,c:+d)] or positions = [(x:+y),(x2:+y2),(a:+b)]
06:08:05 <cocreature> the second has the same type as "positions" in shapeExtent
06:08:17 <lseactuary> ok cool let me read those pages again
06:08:28 <cocreature> also try to learn to interpret the type errors GHC shows you
06:08:32 <cocreature> they are really useful!
06:08:37 <lseactuary> oh
06:08:49 <lseactuary> ok let me check those pages also
06:15:07 <lseactuary> cocreature qq - something i cant see in the book - say i write something and i want to know its type. how do i do this. as :t wont work unless i have a full function.
06:15:19 <lseactuary> for example:  x = minimum (map realPart positions) how do i check the type of x
06:19:00 <infinisil> lseactuary: Um, `:t x`?
06:19:33 <infinisil> Not sure what you mean by ":t won't work unless i have a full function"
06:19:40 <lseactuary> infinisil sec ill show
06:20:33 <lseactuary> infinisil http://lpaste.net/2569097613668253696 this compiles. if i wanted to check the type of a = minimum (map realPart positions) it is possible?
06:21:42 <infinisil> lseactuary: it does not compile, you seem to have stripped all ">" from your paste
06:21:51 <lseactuary> oh
06:22:48 <chisui> Is there a way of using TypeApplications at infix position?
06:23:55 <infinisil> lseactuary: Ah I know what you mean
06:24:18 <infinisil> You mean to check the type of a term that uses local variables of a function
06:24:35 <infinisil> And I don't think that's possible
06:25:06 <chisui> (.) @(Int -> Int) works but (. @(Int -> Int)) doesn't. Am I missing something?
06:25:17 <infinisil> lseactuary: You can however introduce the functions local bindings within ghci, and then check the type
06:25:18 <the_2nd> lseactuary, just type a :: Int above
06:25:31 <the_2nd> and the compiler will complain that Int doesn't match ActualType
06:25:59 <lseactuary> infinisil updated the code with > now
06:26:04 <lseactuary> the_2nd yes
06:26:52 <infinisil> lseactuary: You can do `positions = undefined :: [Position]`
06:27:03 <infinisil> Then `:t minimum (map realPart positions)`
06:27:24 <lseactuary> i guess my worry in general is it may compile
06:27:29 <lseactuary> but then how do i know it is correct
06:27:38 <lseactuary> the book only explains what to do when there are errors :P
06:30:07 <infinisil> lseactuary: 4 ways: Don't make bugs in the first place (very hard), formal modeling (hard), test your stuff (easy), understand your code well and think about it (easy)
06:30:37 <sternmull> lseactuary: I think what you want is a "typed hole". Just replace the expression whose type you want to know with an underscore and try to compile. The error message then tells you what is expected in that place.
06:30:44 <infinisil> (these difficulties will vary with different uses)
06:31:12 <lseactuary> oki
06:31:34 <infinisil> But tests are recommended really
06:31:44 <lseactuary> they have some samples in the book to test :)
06:31:55 <lseactuary> but i needed to finish writing the functions first
06:32:00 <lseactuary> got the last one to do then can test
06:32:13 <lseactuary> the shapeExtent function is good right? it compiles and looks right now to me
06:33:10 <sternmull> lseactuary: What book are you using?
06:33:30 <the_2nd> Java for dummies
06:33:36 <the_2nd> :D
06:33:53 <lseactuary> lol
06:34:20 <lseactuary> http://haskellbook.com/ and Thinking Functionally with Haskell
06:35:35 <lseactuary> my friend passed me over some exercises and solutions to try (but the solutions are very very basic so dont really make sense to learn from)
06:35:57 <lseactuary> but they have steps which helps
06:35:58 <sternmull> lseactuary: I like https://en.wikibooks.org/wiki/Haskell but it seems no one gives it much credit.
06:36:19 <lseactuary> ah yes i use this and hoogle to find functions and see what they are doing :)
06:37:42 <lseactuary> qq - drawing = [[(x:+y),(x2:+y2)],[(a:+b)]] for example - correct?
06:37:56 <lseactuary> then i can try to write the function for drawingExtent
06:44:26 <EvilMachine> Hi. How come >=8.0 versions of GHC eat so much RAM? I only have 4GB here, and installing Cabal, with -j3, basically strangles my system to death. Limiting memory also does not help since then it will just die with a lack of memory. I can’t imagine what would need more than, say, a few megabytes …
06:47:32 <EvilMachine> Even the largest .hs file, with quite a few imports, shouldn’t be more than 1 MB of parse tree, IMHO. Add to that GHC and the RTS itself … Worst case … 16 MB. That is what I would expect and call sane. So the rest is … a huge stack of thunks?
06:49:33 <Tuplanolla> I have the same problem, EvilMachine. The problem is more often the linker than GHC itself.
06:50:30 <EvilMachine> Tuplanolla: Ah, interesting. … And I found, that disabling profiling and haddock documentation generation helps a lot. Especially when compiling GHC itself.
06:51:23 <EvilMachine> Tuplanolla: But just “a lot” in the sense that I can still keep KDE running. Not any browser or any other big program that takes some RAM.
06:51:27 <Tuplanolla> Whether I choose `ld`, `lld` or `gold`, I cannot run Firefox and link Hakyll at the same time, because the linking step will load all of the compiled objects into memory at once.
06:51:46 <EvilMachine> Tuplanolla: Ditto for me an Cabal.
06:52:16 <EvilMachine> Tuplanolla: haddock generating docs during stage 2 of GHC 8.4.1 even makes my system swap >1 GB
07:00:16 <sternmull> i have the impression that Haskell tools simply ignore build times and RAM usage
07:00:54 <sternmull> it is worse than C++
07:06:00 <lseactuary> can someone help me with this final function? i feel super close, i udnerstand the error, but not sure how to debug it
07:06:52 <lseactuary> ive basically used the same function as shapeExtent to extract the real parts, then i want to interate on each list within the list, and then select the min
07:07:02 <lseactuary> so ive tried several variations, all throwing type errors
07:07:14 <lseactuary> im focusing on a = blah for now, then the rest will follow
07:07:46 <lseactuary> iterate wants 2 parameters so a function - map - and then a list which is realPart positions
07:12:32 <EvilMachine> sternmull: Well, build times go up by 20 to 50 times as soon as swapping starts, in my experience. ^^
07:13:27 <EvilMachine> sternmull: It’s mostly a RAM problem due to Haskell being designed in a way that makes it extremely prone to stack or memory overflows. (The laziness.)
07:15:15 <EvilMachine> sternmull: Of course that can be completely avoided with good code. But Haskell is a hard language to master, making this a common scenario anyway. (The difficulty is well worth it though, due to the power it gives one.)
07:17:34 <michi7x7> lseactuary: what are you trying to do?
07:17:36 <EvilMachine> sternmull: I think the geniuses who actually think up up new Haskell papers for breakfast should focus on a general solution to forever get rid of that problem without compromises. (Like: If a person can detect when things go wrong, then there must be a pattern TO detect. That pattern can be defined too. So if it can be defined, one can write code to detect it. And if there is a detector, GHC can detect such cases, and apply the
07:17:36 <EvilMachine> same fixes that people do.)
07:17:37 <dmitrydzhus> Does anybody know if there's a package that contains a similar TH splice: http://lpaste.net/363381? It expands to «compilation time» formatted as a string
07:17:52 <lseactuary> michi7x7 define the function drawingExtent
07:18:12 <lseactuary> and perhaps clean up shapeExtent if there is a cleaner way :)
07:18:43 <lseactuary> michi7x7: at the end: http://lpaste.net/2569097613668253696
07:19:22 <michi7x7> so drawing extends takes a list and tries to find the minimal bounding box?
07:19:45 <lseactuary> yup
07:20:45 <lseactuary> i think drawinf is list of list like this: [[(x:+y),(x2:+y2)],[(a:+b)]]
07:21:02 <michi7x7> well, you give it a List of Shapes which itself are somewhat a List of Points, so you have something similar to http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Position
07:21:06 <lseactuary> because shape is something like this:  [(x:+y),(x2:+y2),(a:+b)
07:21:08 <michi7x7> [[ Position ]]
07:21:19 <lseactuary> yup
07:21:29 <lseactuary> exactly
07:21:36 <michi7x7> if you flatten [[ Position ]] to just [ Position ] you can use your shapeExtent
07:21:44 <lseactuary> oh ye
07:21:47 <lseactuary> lemme try
07:23:55 <the_2nd> is there something similar to splitOn which only splits at the first occurence, instead of all of them?
07:24:00 <sternmull> EvilMachine: It seems your last long massage got cut off after "and applying the". I have the sense that it would be good to optionally specify limits for memory/computational complexity for functions and to have the compiler check if the implementation is guaranteed to stay within that limits. Or some other way to make sure that programs don't use more than a sensible amount of resources in practice.
07:25:37 <michi7x7> lseactuary: of course you can also just do (foldr1 unionExtend . map shapeExtent)
07:27:26 <Tuplanolla> The message was not cut off and he already left, sternmull.
07:32:29 <lseactuary> oh you are right!
07:32:49 <lseactuary> thanks michi7x7
07:33:49 <lseactuary> michi7x7 i have one question from earlier in the book actually i wrote the code but it didn't compile. can you tell me what is wrong and then i try to fix it as it didn't seem obvious to me. the code is a lot shorter.
07:33:51 <lseactuary> 2 min i upload
07:36:48 <Welkin> the_2nd: look at the definition for spiltOn and you will see it is defined recursively using `break`
07:37:01 <Welkin> you could easily write your own break function
07:37:17 <lseactuary> michi7x7 i commented out the bits that didn't compile; http://lpaste.net/6132312802959818752
07:37:25 <the_2nd> splitOnFirst x s = take 1 splits : (intercalate x $ drop 1 splits) where splits = splitOn x s
07:37:41 <Welkin> that is a very backwards way of doing it
07:38:02 <Welkin> just implement break using recursion
07:41:17 <michi7x7> lseactuary: in maybeLookup def :: k->v
07:43:22 <lseactuary> michi7x7 ah i overlooked. trying.
07:43:52 <lseactuary> so its rewrite [(a,[b])] [c] --> [c] basically
07:43:58 <lseactuary> that i need to write a function for
07:44:19 <lseactuary> no sorry  rewrite [(a,[b])] [b] = [b]
07:48:23 <lseactuary> what is happening is its throwing errors when i use []
07:48:27 <lseactuary> that is what i dont really get
07:48:29 <lseactuary> as that is the type
07:48:47 <lseactuary>  rewrite (s,[s]) [s] = maybeLookup s should work
07:49:17 <Welkin> the_2nd: in fact, break already exists in PRelude
07:49:20 <Welkin> :t break
07:49:21 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
07:49:54 <Welkin> > break (== ',') "the panda eats, shoots, and leaves"
07:49:57 <lambdabot>  ("the panda eats",", shoots, and leaves")
07:50:06 <Welkin> it only does it once
07:50:24 <Welkin> this works only with a single character as a separator, but you can write your own version that takes a whole string
07:56:50 <lseactuary> michi7x7 can you please give me a clue on what is wrong?
07:56:58 <the_2nd> Welkin, will take a look at that later, leaving my suboptimal version for now and a todo for later
07:57:07 <lseactuary> do we even need the mayLookup function here?
07:59:26 <DavidLopez> is it possible to define map using foldl ?
08:00:21 <lseactuary> DavidLopex - i think so - https://stackoverflow.com/questions/35662237/first-elements-of-each-pair-from-a-list
08:00:29 <lseactuary> *DavidLopez ^^
08:00:33 <Welkin> DavidLopez: of course
08:00:51 <Welkin> map ccan be seen as a more restriced version of foldl/foldr
08:01:05 <Welkin> folds are a generalized version of recursion with a few restrictions
08:01:13 <Welkin> map has additional restrictions
08:01:48 <Welkin> I would define map in terms of foldr though, not foldl
08:02:07 <Welkin> to take advantage of laziness
08:03:22 <Welkin> > let map f xs = foldr (\ x acc -> f x : acc) [] xs in map (+1) [1,2,3,4,5]
08:03:25 <lambdabot>  [2,3,4,5,6]
08:03:59 <Welkin> DavidLopez: no you try to define it in terms of foldl
08:04:01 <Welkin> now*
08:06:01 <DavidLopez> thanks! i was just asking because in a course i did a few weeks ago the teacher asked us to define map in terms of foldr and i couldnt think of a way of doing it with foldl
08:06:32 <DavidLopez> so what do you mean with
08:06:41 <DavidLopez> "to take advantage of laziness"?
08:10:50 <Welkin> foldr and foldl produce different expressions
08:11:22 <Welkin> foldr can give you a result early for the case in which your combining function is lazy in at least the second parameter, like list cons (:)
08:11:41 <Welkin> > let map f xs = foldr (\ x acc -> f x : acc) [] xs in map (+1) [1..]
08:11:43 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
08:12:00 <`Guest00000> > break (const False) [(),()..]
08:12:02 <lambdabot>  ([(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
08:12:06 <Welkin> > let map f xs = foldr (\ x acc -> f x : acc) [] xs in take 3 (map (+1) [1..])
08:12:08 <lambdabot>  [2,3,4]
08:12:13 <`Guest00000> > snd $ break (const False) [(),()..]
08:12:19 <lambdabot>  mueval-core: Time limit exceeded
08:13:20 <Welkin> > let map f xs = foldl (\ acc x -> f x : acc) [] (reverse xs) in map (+1) [1..]
08:13:26 <lambdabot>  mueval-core: Time limit exceeded
08:13:34 <Welkin> > let map f xs = foldl (\ acc x -> f x : acc) [] (reverse xs) in map (+1) [1,2,3,4,5]
08:13:37 <lambdabot>  [2,3,4,5,6]
08:13:43 <Welkin> foldl will not work on infinite lists
08:13:52 <Welkin> because it never has a result to produce until it gets to the very end
08:13:55 <Welkin> which it never will
08:14:28 <Welkin> if you look at the definitions for foldl and foldr you can see why this is
08:14:57 <Welkin> > foldr f x [a,b,c] :: Expr
08:15:00 <lambdabot>  f a (f b (f c x))
08:15:04 <Welkin> > foldrl f x [a,b,c] :: Expr
08:15:07 <lambdabot>  error:
08:15:07 <lambdabot>      • Variable not in scope: foldrl :: t0 -> Expr -> [Expr] -> Expr
08:15:07 <lambdabot>      • Perhaps you meant one of these:
08:15:11 <Welkin> > foldl f x [a,b,c] :: Expr
08:15:13 <lambdabot>  f (f (f x a) b) c
08:17:14 <Welkin> > let reverseMap f xs = foldl (\ acc x -> f x : acc) [] xs in reverseMap (+1) [1..]
08:17:20 <lambdabot>  mueval-core: Time limit exceeded
08:17:32 <Welkin> > let reverseMap f xs = foldl (\ acc x -> f x : acc) [] xs in reverseMap (+1) [1,2,3,4,5]
08:17:35 <lambdabot>  [6,5,4,3,2]
08:21:23 <michi7x7> > let reverseMap a = reverse . map a in reverseMap (+1) [1,2,3,4,5]
08:21:26 <lambdabot>  [6,5,4,3,2]
08:25:30 <mfiano> Hello.
08:25:59 <mfiano> I just started reading the haskellbook
08:27:08 <lseactuary> my directions are doubles. direction are 0, pi/2, and 2pi is the full circle. but pi is not a double. if i use float2Double i get an error. how do i get the 4 directions (0 = East) in double?
08:29:18 <Ariakenom> @type pi
08:29:20 <lambdabot> Floating a => a
08:29:33 <Ariakenom> > pi :: Double
08:29:35 <lambdabot>  3.141592653589793
08:30:13 <Ariakenom> > pi :: Float
08:30:16 <lambdabot>  3.1415927
08:32:17 <progfunhere> let zap (n:ns) = n : zap $ dropWhile (== n) ns in zap [1,2,1,2,3,1,1,2,2]
08:32:22 <lowryder> mfiano: good!
08:33:00 <mfiano> lowryder: Thanks. I decided to branch out from over a decade of exclusive Common Lisp dev.
08:33:01 <lseactuary> Ariakenom so pi is already a double?
08:33:09 <lseactuary> but then why is pi/2 wrong or 0.5*pi
08:33:22 <Ariakenom> Well what's your error?
08:34:02 <lseactuary> error: Parse error in pattern: pi / 2
08:34:14 <lseactuary> then it highlights (pi/2)
08:34:20 <Ariakenom> pi has type "a" where "a" is Floating. Its polymorphic. Can be float double or even complex
08:34:34 <Ariakenom> > pi :: Complex Double
08:34:37 <lambdabot>  3.141592653589793 :+ 0.0
08:34:51 <lseactuary> so i want 0, pi/2, pi, 3pi/4 all to be double
08:34:56 <lseactuary> how do i do this please?
08:35:17 <Ariakenom> Well a parse error isnt a type error. Why does it say "in pattern"?
08:35:36 <lseactuary> sec i upload
08:35:39 <Ariakenom> Did you place that on the left hand side of a definition or case-expression?
08:36:41 <lseactuary> http://lpaste.net/2571140355948806144
08:37:17 <progfunhere> let zap [] = []; zap (n:ns) = n : zap (dropWhile (== n) ns) in zap [1,2,1,2,3,1,1,2,2]
08:38:06 <progfunhere> Hello fellow Haskellers
08:38:41 <Ariakenom> lseactuary Yes. You can't use pi in a pattern. Only literals.
08:39:19 <Ariakenom> Also can't use division in a pattern.
08:39:21 <lseactuary> i need define a new type or something?
08:40:02 <progfunhere> I am new to Haskell and this is my first visit to #Haskell
08:40:43 <Ariakenom> No. You can write similarly but with a guard. move dis dir (x:+y) | dir==pi/2 = x:+(y+d)
08:40:44 <cppxor2arr> progfunhere: welcome
08:40:49 <lowryder> welcome progfunhere
08:41:08 <lseactuary> ah
08:41:49 <progfunhere> Thanks,<lowryder> I'm wondering: what's the function of <lamdabot> here.
08:42:22 <Ariakenom> Comparing floats for equality is a bit dodgy though. So your idea of a type is good!
08:42:28 <progfunhere> Thanks, <cppxor2arr>
08:42:40 <lseactuary> Ariakenom mine?
08:42:58 <Ariakenom> Yes. You can use a new type for the 4 directions.
08:43:06 <cppxor2arr> > 1+1
08:43:09 <lambdabot>  2
08:43:11 <cppxor2arr> progfunhere ^
08:43:24 <Ariakenom> Since those 4 values are the only allowed directions. The type of move will be more accurate too!
08:43:40 <lseactuary> ye
08:43:44 <lseactuary> oki lemme do
08:43:49 <lseactuary> then i show you
08:44:36 <lowryder> progfunhere: lambdabot is great. You can learn a lot about haskell by looking through the logs for lines starting with >
08:44:46 <lowryder> since these are the lines where people type in haskell goodness
08:45:04 <progfunhere> I see
08:45:17 <Ariakenom> Also haskell evil.
08:45:23 <lowryder> or of course just try out some haskell, or work through with something with someone here
08:46:02 <Ariakenom> [0.5..1] :: [Double]
08:46:06 <Ariakenom> > [0.5..1] :: [Double]
08:46:09 <lambdabot>  [0.5,1.5]
08:46:14 <ab9rf> heh
08:46:33 <ab9rf> the semantics of .. are occasionally freaky
08:47:43 <ab9rf> > [1e25..1e25] :: [Double]
08:47:44 <progfunhere> > let zap (n:ns) = n : zap (dropWhile (== n) ns) in zap [1,2,1,2,3,1,1,2,2]
08:47:46 <lambdabot>  [1.0e25,1.0e25,1.0e25,1.0e25,1.0e25,1.0e25,1.0e25,1.0e25,1.0e25,1.0e25,1.0e2...
08:47:47 <lambdabot>  [1,2,1,2,3,1,2*Exception: <interactive>:3:5-46: Non-exhaustive patterns in f...
08:47:56 <progfunhere> let zap [] = []; zap (n:ns) = n : zap (dropWhile (== n) ns) in zap [1,2,1,2,3,1,1,2,2]
08:48:06 <progfunhere> > let zap [] = []; zap (n:ns) = n : zap (dropWhile (== n) ns) in zap [1,2,1,2,3,1,1,2,2]
08:48:08 <lambdabot>  [1,2,1,2,3,1,2]
08:48:28 <progfunhere> It's cool
08:48:34 <ab9rf> [1e25..1e25] is nonterminating
08:48:49 <progfunhere> I'm working thru Programming in Haskell by Hutton
08:48:55 <ab9rf> because 1e25+1 is equal to 1e25, and so it never reaches the end condition
08:49:04 <jonh> ;o
08:49:19 <progfunhere> 2nd ed.
08:49:40 <lseactuary> Ariakenom a new error :/ http://lpaste.net/2571140355948806144
08:49:45 <michi7x7> > let zap = map head . group in zap [1,2,1,2,3,1,1,2,2]
08:49:48 <lambdabot>  [1,2,1,2,3,1,2]
08:51:43 <Ariakenom> lseactuary: You'd want: data Direction = Right | Up | Left | Down deriving (Show)
08:53:04 <lseactuary> Ariakenom but that is the same as N/S/E/W no? how will they know say 0 maps to East
08:53:56 <lseactuary> Ariakenom i can show you the code for a compass point i did, now trying to expand it to radians
08:54:11 <geekosaur> you can;t defi e it the way you were trying to, is the point
08:54:41 <geekosaur> you can define *new* constructors. you cannot construct a new type out of existing ones... and numeric literals behave as constructors
08:54:53 <lseactuary> yeah
08:55:03 <geekosaur> you can abuse Enum to provide numeric mappings
08:55:14 <lseactuary> but the definition of move takes a Direction which is of type double
08:55:25 <lseactuary> so the user wont type Up they will type pi/2
08:55:38 <geekosaur> (but it is abuse if you want to do things like pi/2. in fact I think that's worse than abuse because Enum expects Integer backing, not Double)
08:55:51 <geekosaur> so you provide conversion functions
08:56:22 <Ariakenom> Should it be double for move's direction? Then is pi/4 a valid choice?
08:56:28 <michi7x7> from Data.Enumerable: data Cardinal = Finite Integer | Aleph Integer -- I can dream
08:57:39 <geekosaur> I was considering mentioninbg that doinbg that suggested an enhancement to resolve non-cardinal angles as lists of moves over some time period
08:57:51 <lseactuary> yeah they could also type pi/3 i guess
08:58:13 <lseactuary> unlike before (where we just had N/S/W/E) they can move the turtle in any angle between 0 and 2 pi
08:58:40 <lseactuary> hence type = Direction instead of a type i think
08:59:00 <lseactuary> i can show you the compass point code, and what i am trying to get to
08:59:05 <lseactuary> maybe it will help?
09:00:03 <geekosaur> I would seriously consider uisng Enum and treating the base unit as pi/2
09:00:16 <lseactuary> sure
09:00:29 <Ariakenom> Sure. link it
09:00:35 <lseactuary> kk 2 min
09:02:26 <Ariakenom> But it seems the function should change to work for any number
09:03:37 <lseactuary> http://lpaste.net/2571140355948806144
09:04:00 <lseactuary> i have put 2 sets of code - one that works for the compass points part, and the new stuff im working towards to make nicer pictures
09:04:40 <lseactuary> the latter should make some snowflakes :P
09:07:52 <MacSlow> Greetings everyone!
09:08:26 <progfunhere> <michi7x7> thanks for "let zap = map head . group in zap [1,2,1,2,3,1,1,2,2]"
09:08:47 <progfunhere> This would be idiomatic Haskell?
09:09:16 <Ariakenom> Hey mac
09:10:17 <Ariakenom> lseactuary: Woo snowflakes. So you'd want to to the complex math (as in complex numbers) to turn any direction then?
09:11:24 <lseactuary> yups
09:11:32 <lseactuary> Position = complex Double
09:12:04 <lseactuary> the book says: It is most convenient to measure the direction in radians: direction 0 faces east, π/2 north, and 2π makes a full circle.
09:12:09 <lseactuary> hence just going with this
09:12:55 <lseactuary> Ariakenom did the upload help?
09:13:25 <MacSlow> hey there Ariakenom
09:14:54 <ab9rf> i dunno, i would likely express direction as a vector rather than an angle
09:15:12 <Ariakenom> Yeah I saw you had already made the nice NESW for another thing.
09:15:19 <lseactuary> yups
09:15:35 <ab9rf> for one, that allows you to extend to 3d or higher dimension more readily
09:15:58 <MacSlow> quaternions ;)
09:16:04 <lseactuary> ab9rf happy to try it
09:16:19 <ab9rf> it also avoids having to do trig math everywhere
09:16:38 <ab9rf> movement is just a vector multiply and add operation
09:16:47 <ab9rf> WAY fewer FLOPS
09:16:52 <lseactuary> lol
09:17:04 <ab9rf> even rotations are just a matrix multiplication
09:18:02 <Ariakenom> So you'd want to figure out how you make it work for any "dir". Going through cases 1-by-1 like NWSE won't work.
09:18:13 <lseactuary> right
09:18:35 <ab9rf> if you need the ability to move in "any" direction, a finite algebraic type for direction will not work well
09:19:00 <lseactuary> ab9rf - would be interested in your way - only problem is the code they have given in the book uses these definitions to test. but i could workaround.
09:19:06 <lseactuary> Ariakenom yeah
09:19:20 <intox8907> hi there! i'm currently using cabal to install pandoc on openbsd. i'm getting a strange error message though: "pandoc-2.1.2-EFIlNTHjA8mAMuUUumxEAG depends on pandoc-2.1.2 which failed to install."
09:19:38 <ab9rf> lseactuary: youshould probablyu do it the way your text recommends for the purpose of your exercise
09:19:43 <intox8907> naturally, this won't work and this shouldn't be happening. i know nothing about haskell, so any tips?
09:19:57 <lseactuary> ab9rf - sure - but would also be interested in your method for curiosity
09:20:02 <ab9rf> lseactuary: the issues i'm raising deal with efficiency and numerical stability
09:20:07 <lseactuary> yup
09:21:26 <intox8907> im using cabal version 2.0.1.0
09:21:34 <intox8907> and ghc 8.2.2
09:23:11 <lseactuary> any ideas how to approach this please?
09:23:32 <Ariakenom> lseactuary: Do you have a trigonometry handbook close by? :)
09:23:45 <lseactuary> lol ye
09:24:16 <Ariakenom> Like all trig. Just draw some unit circles until its obvious :p
09:24:53 <EvanR> memorize all trig identities until obvious
09:26:17 <ab9rf> lseactuary: you just express facing direction as a (unit) vector. movement is handled by multiplying that vector by the distance moved and adding it to position. changing direction is handled by multiplying that vector by a matrix that represents that particular rigid transformation.
09:27:29 <ab9rf> lseactuary: the advantage is that you're only using adds and multiplies, which are fast and are fairly easy to manage stability issues. if you represent facing in angular units, then you have to use trig whenever you mvoe, and trig functions are much slower and much harder to manage for stability.
09:28:02 <EvanR> oh forget what i said, didnt know someone was trying to use angles for vector math
09:28:02 <lseactuary> got ya - this is your method right - not the one i pasted?
09:28:13 <ab9rf> i haven't looked at your paste yet :)
09:28:16 <lseactuary> :)
09:28:37 <Ariakenom> EvanR: no that's just ab9rf
09:29:37 <intox8907> so, any hints?
09:30:23 <ab9rf> lseactuary: the code ion your past appear to involve a quantized grid and movement restricted to the cardinals
09:30:40 <ab9rf> which is fine, nothing wrong with that
09:30:40 <lseactuary> yes the initial case was only N/S/W/E
09:30:49 <lseactuary> oh you mean the new case?
09:31:06 <ab9rf> althjough since the grid is quantized, i'd use Integer instead of Double for locatrions (and not use Complex at all since you gainnothing by using it really)
09:31:34 <lseactuary> ye i think the book is just trying to build you up to more complex stuff ;)
09:31:48 <ab9rf> hm, i suppose if move takes a double, then it's not actually quantized
09:32:51 <mfiano> I'm on Arch Linux which by default uses dynamic linking for ghc. I need to install the ghc-static package for static linking. I'm not sure what that means or which I should be developing with as I follow along in the haskellbook.
09:33:18 <lseactuary> ab9rf we could actually use your method using these definitions stil
09:33:20 <Ariakenom> Actually complex numbers do give some gain for the current task
09:34:09 <Ariakenom> lseactuary: Tip: Consider the polar form of the path you want to move.
09:34:21 <lseactuary> yeah
09:35:27 <lseactuary> trying to write the function 2 min
09:36:27 <concaveirc> Is there a function which is essentially repeat, but monadic like (m a -> m [a])? sequence . repeat may work, but I am not sure it is lazy as I will be working with potentially infinite lists.
09:37:14 <geekosaur> it could only be as lazy as (>>=) in the monad, which severely limits its usefulness
09:37:43 <concaveirc> geekosaur: ok, thanks.
09:38:27 <EvanR> with IO, it would start building an infinite list and then never return, and memory would be gone
09:38:39 <concaveirc> But is >>= really necessary? Considering replicateM only needs applicative, would repeatM require >>=?
09:39:26 <intox8907> ok, i figured out my problem. i wasn't setting the temporary build dir to an executable path. complete solution here: https://deftly.net/posts/2017-10-12-using-cabal-on-openbsd.html
09:39:28 <geekosaur> Applicative doesn;t buy you any extra laziness
09:39:40 <concaveirc> EvanR: Hm, so the list must be completely evaluated before being used.
09:39:42 <geekosaur> it just means more things that are lazy are candidates
09:39:44 <cocreature> concaveirc: it kind of sounds like you might be better off with a streaming library
09:39:52 <EvanR> no the loop must end before being used
09:40:10 <EvanR> so you can get access to the front
09:40:10 <lseactuary> Ariakenom uploaded am i on the right track?
09:40:42 <concaveirc> cocreature: That is probably right.
09:40:48 <Ariakenom> concaveirc: Correct, just applicative.
09:41:18 <EvanR> you can generate a "pure" infinite list in IO using unsafeInterleaveIO, perhaps in a saner way than lazy I/O does
09:41:31 <concaveirc> EvanR: Makes some sense. Streaming it is.
09:41:58 <concaveirc> I hear that unsafeInterleaveIO is quite the demon though.
09:41:59 <cocreature> I’m not sure how unsafeInterleaveIO is saner than lazy I/O given that this is exactly how lazy I/O is implemented :)
09:41:59 <EvanR> but ive never gotten it quite right
09:42:20 <EvanR> cocreature: its all in how you use it!
09:42:43 <EvanR> lazy I/O chose to terminate the list and give no indication of any error, if theres an IO exception
09:43:06 <Ariakenom> lseactuary: the track looks good (y)
09:43:19 <lseactuary> oki ill continue
09:43:25 <dysfun> lazy i/o is great, so long as you never have a failure case
09:43:28 <EvanR> unsafePerformIO is the demon... or is it accursedUnutterableIO
09:44:43 <orzo> Is there a way to run ghc directly (without cabal) so that it uses a cabal new-build environment?
09:46:41 <cocreature> orzo: not with any released version of cabal-install. cabal-install-2.2 has new-exec command and it also generates .ghc.environment.* files which ghc will automatically pick up if you run it in the same directory
09:47:20 <Ariakenom> lseactuary: There were errors, but I assume you work on it and test it.
09:47:29 <lseactuary> yup working on it now :)
09:47:48 <orzo> how hard would it be to manually create the .ghc.environment.* files to do this without cabal-install-2.2?
09:48:01 <rick-sanchez> Do you know if it is possible to prevent recompilation for fobject-code in stack ghci? I always get  "Compiling ...[flags changed]" when I launch the ghci
09:48:16 <cocreature> orzo: probably harder than building cabal-install-2.2 from git :)
09:49:23 <lseactuary> Ariakenom how is this? http://lpaste.net/2571140355948806144
09:49:32 <orzo> i had a lot of dependency issues building from git
09:50:05 <lseactuary> woops 2 min
09:50:26 <lseactuary> updated
09:52:13 <Ariakenom> Eh. Think the update broke it.
09:52:23 <lseactuary> it compiles for me :/
09:53:00 <Ariakenom> Yeah. I meant broke as in wrong answer.
09:53:05 <lseactuary> ah
09:55:01 <lseactuary> updated - that should work no?
09:56:25 <lseactuary> hmm doesnt work
09:56:29 <Ariakenom> I'd suggest trying out the fomrulas in ghci.
09:56:29 <lseactuary> sec testing
09:56:35 <lseactuary> yeah :)
09:56:37 <lseactuary> doing now :)
09:56:44 <lseactuary> move 1 (pi/2) (0:+0)
09:56:49 <lseactuary> NaN :+ NaN
09:56:53 <lseactuary> which is wrong
09:57:31 <Ariakenom> bottom is never wrong. ... wait
09:57:54 <EvanR> not even wrong
09:59:14 <Ariakenom> I'd start thinking from newPos - oldPos = moveVector
09:59:44 <lseactuary> kk
09:59:45 <lseactuary> trying
10:00:17 <Ariakenom> I'm surprised there's no definition of imag = 0+:1 in Complex
10:00:20 <orzo> cocreature: cabal's git log says they intend "boot libraries of GHC 7.4.[12]" to be the lower bounds, but I'm using libraries that come with 8.0.2 (debian buster/sid) and parsec (among other things) do not meet the coded lower bounds
10:01:02 <EvanR> imag = 0:+1 would be an odd name for that
10:01:19 <orzo> did ghc 8.0.2 actually use older boot libraries than 7.4 ?
10:01:29 <orzo> or did debian do this to me
10:02:07 <Ariakenom> I like spaces and equals sign in my names. Makes them more special.
10:02:27 <EvanR> j or i
10:03:19 <lseactuary> hmm
10:04:11 <geekosaur> "imag" would normally be a way to extract the imaginary part of a complex, not the imaginary unit as a complex
10:04:34 <w1n5t0n_> Hi all, I'm working on a eDSL for live coding music (very similar to TidalCycles for anyone familiar). I have an interface function of the type "s :: String -> (Time -> Value) -> IO()" which takes a parameter name, a function of time, evaluates that function over a certain window of time (say, from 3.5 to 6 seconds) and writes it to a file. How can all "s" functions use the same time window without having to explicitly pass it to 
10:05:17 <Ariakenom> lseactuary: So what's the value of moveVector in my example? Given distance and direction.
10:05:36 <w1n5t0n_> For example, I want to be able to do: "window = (3.5, 6); s "amp" $ \t -> sin t; s "freq" $ \t -> cos t", and have both "amp" and "freq" functions evaluated over the same time window implicitly
10:05:37 <lseactuary> where is the example?
10:06:30 <Ariakenom> newPos - oldPos = moveVector    if you understand my names
10:06:55 <lseactuary> i am not sure tbh
10:07:17 <lseactuary> move 1 (pi/4) (0:+0) gives me 1.414 :+ 1.414
10:07:22 <lseactuary> which is good
10:07:33 <lseactuary> but now idk what to do with that
10:07:48 <EvanR> screw angles man
10:07:59 <lseactuary> then?
10:08:18 <EvanR> move dist v x = x + v * dist
10:08:41 <EvanR> v :: Complex Double, or V2 Double, or whatever
10:08:44 <monochrom> Yeah what is pi/4 doing in a function called "move"?
10:09:08 <lseactuary> x is Complex Double, v is double
10:09:21 <EvanR> v should be another Complex Double
10:09:27 <EvanR> the direction they are facing
10:09:44 <monochrom> You can use realToFrac.
10:10:02 <EvanR> not if its an angle O_o
10:11:22 <orzo> cabal's bootstrap.sh bulids 221 modules before telling me i'm missing dependencies
10:11:50 <lseactuary> attached
10:11:51 <lseactuary> testing now
10:12:39 <lseactuary> looks right
10:12:55 <lseactuary> except we get tiny numbers for 0 e.g. 6.123233995736766e-17
10:13:00 <lseactuary> is that because of the rounding
10:13:08 <Ariakenom> Nice. You had correct code right before I said you broke it. But this is better code
10:13:14 <lseactuary> awesome
10:13:35 <Ariakenom> Yes rounding. floats are mean
10:14:29 <lseactuary> good good
10:14:32 <lseactuary> ok so now turning
10:14:51 <EvanR> table makers dilemma
10:15:07 <Ariakenom> What I was trying to get at with polar form is that v is a complex number with magnitude dist and angle dir.
10:15:21 <lseactuary> ah
10:16:09 <EvanR> for 2D dynamics you can use complex numbers, but this is goofy. for both 2D and 3D and many other problems you are really trying to use vectors
10:16:35 <monochrom> Yeah, vectors and matrices.
10:16:38 <ab9rf> i genreally disapprove of using complex numbers as position vectors
10:16:48 <EvanR> some of the operations on complex numbers correspond to operations on 2D vectors, some dont, and many operations you want arent available for complex
10:17:19 <ab9rf> EvanR: and it locks you into two dimensions, forcing you to rewrite if you go to 3d or higher
10:17:21 <monochrom> But hey, Tcl programmers use strings for everything, just because strings are available.
10:17:38 <EvanR> unicode strings can represent anything!
10:17:50 <ab9rf> so can bignum integers :)
10:17:56 <EvanR> but so can Tree ()
10:17:58 <monochrom> Likewise, C -> arrays, Haskell/Lisp/Scheme -> list
10:18:06 <ab9rf> Peano numbers :)
10:18:26 <lseactuary> is my turn definition close?
10:18:31 <lseactuary> it seems to fail the compile for the next line
10:18:39 <Ariakenom> Agreed on complex. Are vectors smooth enough to use for whatever excercise lseactuary is doing?
10:18:56 <EvanR> its the same implementation, two Doubles
10:19:01 <EvanR> but different library support
10:19:10 <cocreature> orzo: parsec is not a boot library
10:19:17 <EvanR> i recommend the package linear
10:19:31 <Tuplanolla> It's not like vectors are much better for mechanics. As soon as you introduce a cross product, you lock yourself into three dimensions.
10:19:32 <monochrom> Different semantics actually.  The semantics of a type is not what field it has.  Far from it.
10:20:17 <Ariakenom> You could try to convince the author to switch :)
10:20:52 <Ariakenom> lseactuary: Eh, not even sure what you're trying to do there.
10:21:00 <lseactuary> sorry just realised my mistake
10:21:01 <lseactuary> 2 min
10:21:12 <lseactuary> its turn dir1 to dir2 basically
10:21:18 <lseactuary> and i need to define a direction
10:21:25 <lseactuary> well output the final direction
10:21:26 <lseactuary> right?
10:22:38 <Ariakenom> I don't follow. Given dir1 and dir2 then "turn" is what?
10:23:10 <lseactuary> hmm
10:23:14 <lseactuary> the book just says
10:23:21 <lseactuary> functions to move forwards (by a given distance) and to turn with this new representation of directions.
10:23:24 <lseactuary> dont get it
10:23:41 <lseactuary> why would you be given 2 directions
10:23:43 <lseactuary> isnt it just one
10:23:45 <Ariakenom> Perhaps the direction you get by facing dir1 and turn dir2 radians?
10:23:58 <lseactuary> ah
10:23:59 <lseactuary> yes
10:24:13 <lseactuary> ok trying
10:28:03 <Ariakenom> Obviously any tutorial dealing with space and not using geometric algebra is a waste of time though /s
10:29:34 <lseactuary> Ariakenom my turn function looks okay?
10:30:29 <Ariakenom> Hm. What do you consider the return value to be? A direction?
10:31:02 <lseactuary> yw
10:31:03 <lseactuary> yes
10:31:17 <lseactuary> btw i dont think move works
10:31:17 <lseactuary> move 1 (pi/2) (-1:+0)
10:31:22 <lseactuary> Precedence parsing error         cannot mix prefix `-' [infixl 6] and ‘:+’ [infix 6] in the same infix expression
10:32:52 <Ariakenom> parse error means you entered text incorrectly
10:33:06 <lseactuary> oh
10:33:40 <lseactuary> move 1 (3*pi/2) (1:+0)
10:33:45 <lseactuary> 0.9999999999999998 :+ (-1.0)
10:33:51 <lseactuary> move 1 (pi/2) (-1:+0)
10:33:54 <Ariakenom> in this case its ambigous if you mean (-1):+0 or -(1:+0)
10:33:56 <lseactuary> Precedence parsing error         cannot mix prefix `-' [infixl 6] and ‘:+’ [infix 6] in the same infix expression
10:33:59 <lseactuary> oh
10:34:10 <lseactuary> nice :)
10:34:12 <lseactuary> will note this
10:34:41 <lseactuary> my turn function is ok?
10:35:04 <Ariakenom> no
10:35:44 <lseactuary> can you give me a counter example
10:35:48 <lseactuary> then i can rewrite
10:37:40 <Ariakenom> > let turn dir1 dir2 = cos dir1 in turn 0 0
10:37:43 <lambdabot>  1.0
10:39:43 <lseactuary> ah
10:39:45 <lseactuary> ok working on it
10:40:19 <dubious> i'm a newb and i need help
10:40:20 <dubious> lol
10:41:24 <Ariakenom> dubious: You've found the right place, I think.
10:41:34 <dubious> awesome lol
10:41:49 <dubious> i tried doing a full uninstall of all my haskell-related stuff, because i was getting error messages trying to install ghc-mod
10:42:04 <dubious> however, when i type stack in my terminal (OSX), i'm still getting a list of commands and what not
10:42:30 <dubious> does this mean stack is still lying somewhere deep in my system, or nah?
10:42:35 <Ariakenom> If i recall correctly there's also #haskell-beginners
10:43:15 <dubious> ahh okay, i'll pop over there then thanks
10:43:18 <Ariakenom> (I have no idea)
10:43:29 <lseactuary> hmm this is hard
10:43:35 <lseactuary> turn 0 (pi/2) should be 1 or 0?
10:43:46 <lseactuary> or pi/2?
10:44:03 <Ariakenom> turn x y should be a direction you say? Then what direction is 1=
10:44:20 <lseactuary> isnt it just dir2 then
10:45:05 <lseactuary> hmm if i face west (pi) and turn ((-pi)/4) then i am facing 3 pi / 4
10:45:11 <lseactuary> so its just the sum of dir1 + dir2
10:45:12 <lseactuary> no?
10:46:40 <Ariakenom> lseactuary yup :)
10:46:44 <lseactuary> lol
10:46:46 <lseactuary> Gawd
10:46:55 <lseactuary> Haskell is so simple sometimes that its hard XD
10:47:26 <lseactuary> ok will try the next function
10:51:17 <lseactuary> step2 has the right setup - i need to just change the right hand side Ariakenom?
10:54:00 <lseactuary> oh i think i did it
10:54:27 <lseactuary> :)
10:55:15 <lseactuary> last one
10:57:45 <mfiano> So how does one actually install a proper ghc/stack environment on Arch Linux? haskell on Arch is an absolute mess with everything dynamic by default.
10:58:08 <mfiano> I'm trying to follow along in a book and I can't even get a working ghc/stack going to learn haskell with :/
10:58:27 <lseactuary> last one
10:58:29 <cocreature> mfiano: if you use stack then the fact that the default is dynamic linking is irrelevant
10:58:35 <Ariakenom> Fishy, turn left and turn right are the same. What does that mean? what should turnX do?
10:58:45 <mfiano> cocreature: I can't even install stack
10:59:01 <cocreature> mfiano: follow the instructions on the website instead of installing it via pacman
10:59:04 <mfiano> It tells me my distribution is not supported and then errores
10:59:06 <mfiano> I did :)
10:59:29 <mfiano> `curl -sSL https://get.haskellstack.org/ | sh` errors
10:59:41 <cocreature> what’s the error?
10:59:42 <lseactuary> Ariakenom but it can take e enum values
10:59:48 <lseactuary> *3
11:00:03 <mfiano> cocreature: I get: This installer doesn't support your Linux distribution, trying generic bindist... main: line 66: arch: command not found
11:01:11 <lseactuary> Ariakenom i think its because say starting at pi and moving -pi/4 is the same as starting at pi and moving 3pi/4
11:01:25 <Tuplanolla> Try downloading the script and changing `/bin/sh` to `/bin/bash`, mfiano.
11:01:52 <cocreature> mfiano: download the binary manually from https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2
11:02:28 <Ariakenom> lseactuary do some examples of turn2 with turnRight and turnLeft
11:02:42 <lseactuary> you mean turn?
11:02:54 <lseactuary> or step2?
11:03:26 <mfiano> I still get the error with bash, and I'm not downloading an arbitrary binary to my computer
11:04:08 <cocreature> you’re running arbitrary shell scripts that download binaries to your computer but you don’t download arbitrary binaries?
11:04:12 <cocreature> that seems like a pretty weird choice
11:04:26 <Ariakenom> lseactuary, oh yeah step2
11:04:30 <Tuplanolla> I wonder what's wrong with the shell there.
11:04:31 <lseactuary> oki trying
11:05:59 <cocreature> mfiano: you can install ghc and ghc-static via pacman (and those should be the only Haskell-related packages that you install via pacman), then build cabal using the supplied bootstrap script and then use cabal to build stack
11:06:31 <mfiano> I have some arch packages installed already that bring in some haskell stuff
11:06:44 <mfiano> Like shellcheck brings in a bunch of haskell-* packages
11:06:48 <cocreature> that’s likely to cause problems at some point
11:06:50 <lseactuary> Ariakenom the forward looks okay, its the turn left/right you are concerned about?
11:08:15 <lseactuary> i wonder also if in turn we should divide by 2pi
11:09:14 <mfiano> do I need ghc-static too? I only have ghc
11:09:22 <lseactuary> ah i need to add a minus to the TurnRight
11:09:34 <cocreature> yes you need that one for static linking (which is the default for ghc)
11:10:07 <Ariakenom> lseactuary, gj!
11:10:12 <lseactuary> :)
11:10:29 <lseactuary> updated
11:10:45 <lseactuary> Ariakenom can you help with the last one... really not sure how to fix this one :P
11:11:19 <Ariakenom> I'll have a look
11:11:24 <lseactuary> thanks!
11:14:50 <mfiano> cocreature: Ok, I installed the stack-bin package from AUR because at this point I just want to continue learning haskell. I also did `stack ghc` and it downloaded ghc, and `stack cabal-install`. Anything else I should get to continue?
11:15:15 <cocreature> should be fine
11:15:29 <mfiano> Thanks
11:16:10 <Ariakenom> lseactuary, looks good. You're forgetting to apply dist and dir1.
11:16:33 <lseactuary> ah lemme try
11:20:24 <lseactuary> Ariakenom doesnt compile checking bugs but updated just incase its something silly
11:21:28 <lseactuary> ah
11:21:31 <lseactuary> i missed it twice :)
11:21:45 <lseactuary> compiles :)
11:21:48 <lseactuary> is it good?
11:23:43 <lseactuary> Ariakenom can i ask a quick help on an earlier question i had, then i promise i will bug off. i wrote the code but it doesnt compile.
11:23:50 <lseactuary> http://lpaste.net/6132312802959818752
11:23:57 <lseactuary> its shorter so hopefully a quick fix
11:24:12 <lseactuary> just strings so nothing complex (pun intended lol_
11:25:53 <cocreature> lseactuary: don’t make us ask you every time to add compile errors :)
11:26:11 <lseactuary> ahah
11:26:19 <lseactuary> sorry sorry
11:26:23 <Ariakenom> nice pun!
11:26:45 <cocreature> when I said earlier that they are really helpful, I wasn’t joking. I don’t even start searching for bugs without seeing the compile errors
11:27:19 <lseactuary> updated: http://lpaste.net/6132312802959818752
11:27:31 <lseactuary> apologies i will remember from now :)
11:27:41 <cocreature> you can’t name two variables "a"
11:29:21 <lseactuary> updated but this new error is what i was getting before
11:29:24 <lseactuary> hence got confused
11:30:44 <geekosaur> did you notice the "Probable cause"?
11:31:56 <lseactuary> yes im more just not understanding the question
11:32:01 <lseactuary> therefore guessing
11:32:06 <lseactuary> if you can explain a bit what it means
11:32:10 <lseactuary> then i can write the function properly
11:32:33 <geekosaur> you declaredmaybeLookup def dict k = ...
11:32:59 <lseactuary> yup
11:33:00 <geekosaur> you invoked maybeLookup [c] [(a, [b])]
11:33:08 <geekosaur> do you see a problem?
11:33:16 <lseactuary> too few arguments
11:33:53 <toby1851> given fail "foo", is there a nice way to extract "foo" - rather than "user error (foo)" - from the resulting exception?
11:34:11 <Welkin> Better take a trip to the Argument Clinic
11:34:34 <toby1851> ofc i can just show and then extract the part of the string i want, but that seems ugly
11:34:48 <lseactuary> geekosaur but i cannot seem to understand what is going on here
11:35:34 <geekosaur> toby1851, it's an ErrorCall exception. dunno offhand if you can usefully deconstruct it
11:36:05 <geekosaur> lseactuary, I don't know either, if you were expecting me to decipher and explain the program to you
11:36:08 <cocreature> lseactuary: exactly what you just said yourself: you are passing too few arguments to maybeLookup. you need to pass 3 arguments
11:36:37 <cocreature> lseactuary: the first argument to maybeLookup should be a function so that one is definitely missing
11:36:43 <lseactuary> ye
11:36:59 <Welkin> `lookup` already exists
11:37:05 <Welkin> why would you define it again?
11:37:08 <Welkin> :t lookup
11:37:10 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
11:37:14 <geekosaur> yes, I'm not getting what is confusing you about this. you are missing a parameter. did you expect the compiler to guess it?
11:37:29 <lseactuary> Welkin - i use lookup in maybeLookup
11:37:30 <Welkin> :t Data.Map.Strict.lookup
11:37:31 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
11:37:31 <geekosaur> or expect me to guess it?
11:37:42 <lseactuary> geekosaur - sorry i did 3 parameters
11:37:45 <lseactuary> 2 sec i upload
11:37:55 <geekosaur> I see two list parameters.
11:38:09 <geekosaur> one is a list of tuples. that does not make it two parameters
11:38:28 <lseactuary> sorry i didnt update the paste
11:38:30 <lseactuary> updated now
11:39:30 <geekosaur> as cocreature said earlier, the first parameter should be a function
11:40:09 <lseactuary> maybeLookup lookup ...
11:40:11 <geekosaur> you are passing a value of type s instead of a function that produces a list of s-s from a value of type s
11:40:11 <lseactuary> like that?
11:40:23 <geekosaur> lookup doesn;t have that type
11:41:03 <heptahedron> Is there any way to relax the rule that type-level functions must be fully applied? I thought I saw some extension that was at least somewhat close to that but I can't remember now
11:41:19 <heptahedron> Trying to avoid defunctionalization
11:41:26 <geekosaur> heptahedron, there's a way to make it defer the check. there's no other way to relax it
11:41:40 <heptahedron> geekosaur: what does deferring the check accomplish?
11:42:38 <lseactuary> can you kindly provide an example
11:42:39 <orzo> Should this be an error? foo=foo where foo=3
11:42:41 <lseactuary> i dont think im udnerstanding
11:42:47 <lseactuary> therefore making silly errors on this
11:42:54 <orzo> it looks like recursion but isn't
11:43:00 <geekosaur> lseactuary, you mean I really must go drop everything and study your code for oi
11:43:03 <geekosaur> for you
11:43:13 <lseactuary> no sorry
11:43:34 <lseactuary> im just struggling to understand and dont want to keep uploading bugs
11:43:48 <orzo> is it just chance that it's not recursion or is that specified behavior?
11:44:41 <Welkin> orzo: you can't redefine something
11:44:46 <Welkin> after it has been defined
11:45:16 <geekosaur> heptahedron, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XLiberalTypeSynonyms
11:45:27 <orzo> Welkin, ghc/ghci accept foo=foo where foo=3
11:45:28 <geekosaur> no, you don;t get a way to make type lambdas
11:46:14 <geekosaur> orzo, normally the first two foo-s would be the same. but the where clause modifies that so it's: foo = {foo where foo = 3}
11:46:18 <orzo> Welkin: are you rationalizing why i should expect it not to be recursion?  Well, that's fine, but it looks bad and error prone.  Maybe the form should be disallowed anyway.
11:46:22 <eliaslfox> 11:35 < spruit11> Hehe. TRADE WAR!
11:46:40 <Welkin> orzo: let foo = foo is infinitely recursive
11:46:46 <cocreature> orzo: we already have name shadowing warnings that you can turn into an error
11:47:00 <orzo> hm, ok
11:47:15 <heptahedron> geekosaur: ah thanks!
11:47:17 <geekosaur> Welkin, see what I just said about the where
11:47:41 <geekosaur> the foo in scope there is the one from the where clause, which is shadowing the original
11:48:25 <Welkin> that makes sense now
11:48:40 <Welkin> but `where` can be tricky to use correctly
11:49:10 <Welkin> it is desguared to `let ... in` right?
11:49:16 <Welkin> desugared*
11:50:08 <geekosaur> yes. so foo = (let foo = 3 in foo) -- which makes it more explicit that it's a different foo there, from the let instead of from the outer level
11:50:42 <lsund> Hello
11:51:16 <gulguy> Hi Switching to haskell from rust is hard? As I know we need to forget many things of imperative languages when we start haskkell
11:51:34 <heptahedron> gulguy: You don't have to forget them, but you learn how to do things differently
11:52:11 <gulguy> heptahedron:  thats ok but what about my rust to haskell thing
11:52:35 <Welkin> rust already taught you about pattern matching, and traits (which are like type classes)
11:52:39 <Welkin> and you know how to think in types
11:52:41 <Welkin> so you should be good
11:52:58 <heptahedron> gulguy: I mean, haskell doesn't have the memory management restrictions that Rust does, I'd imagine besides that the basic parts of hs are fine
11:53:00 <Welkin> even algebraic data types
11:53:18 <lsund> Does anyone know how to group a Data.Vector like Data.List.group ?
11:53:24 <Welkin> the big change will be lazy evaluation
11:54:02 <Welkin> lsund: did you check here? https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector.html
11:54:12 <orzo> geekosaur: considering that, it seems unfortunate that foo = (foo where foo = 3) is disallowed
11:54:21 <Welkin> the Vector API is often 1:1 with the List API
11:54:29 <Welkin> there are extra vector packages too
11:54:34 <geekosaur> that's because where attaches syntactically to definitions
11:54:42 <Welkin> and if all else fails, you could always either write your own, or convert to a list, do the operation, and convert back
11:54:54 <geekosaur> everyone seems to think they should attach to expressions instead of definitions, but "where" *always* attaches to a definition
11:54:57 <geekosaur> module ... where
11:55:07 <geekosaur> class ... where
11:55:12 <lsund> Welkin: There is no special group function for vectors
11:55:14 <geekosaur> foo = ... where
11:55:37 <lsund> I tried to write my own but since `cons` is O(n) it is not efficient to do a fold
11:55:42 <Welkin> lsund: it makes sense for that kind of function to convert to a list and then back
11:56:00 <lsund> Also I can't convert to list and back because of performance
11:56:05 <Welkin> otherwise you will be allocating a new vector every single time you perform one step of the algorithm, ubless you wrap it up in ST
11:56:21 <geekosaur> ^ you think lists are slow...
11:56:22 <Welkin> thaw to a mutable vector at the least
11:56:26 <Welkin> lists are not slow
11:56:38 <Welkin> they are exactly what you want in this case
11:56:42 <geekosaur> "because of performance" so clearly they do think that
11:57:36 <lsund> Is lazy evaluation somehow taking care of the overhead of converting back and forth to a list? I'm kind of new to haskell
11:58:14 <geekosaur> the point here is that, no matter what, you are converting to and from something
11:58:43 <lsund> I want a function :: Vector Text -> Vector [Text]
11:58:44 <geekosaur> vectors are not magical creatures that always habve zero overhead for everything
11:58:51 <lsund> grouped by the first letter
11:58:56 <Welkin> a list will be the easiest, and I don't think a mutable vector will give you much of a perforamnce gain, if any, and your code will be a lot uglier and hard to read
11:59:49 <lsund> It has already given a lot of performance gain ... I know it is ugly but Its just one part of the program. Critical however
11:59:50 <Welkin> mutation is almost never the answer in haskell
12:00:03 <lsund> Its isolated
12:00:07 <Welkin> lsund: what has?
12:00:34 <Welkin> if you are worried about cache performance, then sure, go ahead and us a mutable vector
12:00:35 <lsund> I changed to mutable vectors for counting sort and got a huge performance increase
12:00:45 <Welkin> but you still have to copy the vector twice
12:00:53 <geekosaur> lsund, you seem to think that vectors really are magical. some things will be faster. some things will be *slower*
12:01:30 <geekosaur> this is one where you migth be able to get the same speed with something really ugly and hard to decipher, but you're unlikely to get a speedup no matter how clever you are
12:01:34 <lsund> I don't think vectors are magical, I just had some success with it here. I want to try it out
12:01:45 <geekosaur> grouping is not an operation that works well on vectors
12:01:57 <lsund> okay
12:02:18 <Welkin> you wouldn't use mergesort on vectors :P
12:02:19 <[exa]> lsund: why not just reimplement group for your Vectors? (it's 2 lines of code btw)
12:02:24 <Welkin> lists are ideal for that
12:03:05 <geekosaur> and half the battle in this kind of question is knowing your algorithms well enough to realize when you're barking up the wrong tree
12:03:08 <lsund> exa: I don't know how to reimplement group that's the problem
12:03:43 <Welkin> lsund: V.fromList . List.group . V.toList
12:04:00 <lsund> How would you implement this algorithm without mutation: https://en.wikipedia.org/wiki/Counting_sort
12:04:28 <Welkin> lsund: some algorithms depend on mutation to work properly, like quicksort
12:04:42 <[exa]> lsund: you can find the implementation in Data.List. Btw lists are really much nicer than vectors in most situations; most operations don't even need to have the lists allocated in the memory (so the pointer-chasing argument doesn't hold)
12:04:56 <lsund> I mean you can implement counting sort without mutation but it would not be O(K) anymore which is the whole point
12:05:12 <Welkin> but most algorithms are designed for imperative mutation-based languages
12:05:16 <[exa]> lsund: also, make sure to compile with -O2 if you're after speed (specialized inlined lists may be fast)
12:05:26 <lsund> Ok, thanks
12:05:27 <Welkin> there are many good algorithms and data structures designed for functional immutable languages
12:05:39 <infinisil> Welkin: Can't you implement all of those with ST?
12:05:57 <infinisil> Never played with ST but it seems to be a pure escape hatch for imperative algs
12:06:06 <Welkin> lsund: https://cstheory.stackexchange.com/questions/1539/whats-new-in-purely-functional-data-structures-since-okasaki/1550#1550
12:06:15 <Welkin> infinisil: of course you can implement them with ST
12:06:21 <Welkin> but it is ugly
12:06:33 <Welkin> infinisil: ST is still pure
12:06:37 <Welkin> it is not an escape hatch
12:06:40 <infinisil> Yeah
12:06:45 <infinisil> Hmm but why is it ugly
12:06:48 * [exa] suggests linearity
12:07:39 <Welkin> linearity?
12:07:54 <[exa]> the one from Linear Haskell paper
12:07:55 <Welkin> infinisil: if you have seen ST code, you will know
12:08:10 <Welkin> it is very difficult to read compared to a non-ST version
12:08:11 <[exa]> it's exactly the lsund's problem, but I didn't see the actual code running yet
12:08:28 <infinisil> Welkin: Hmm yeah just looked at some examples
12:08:49 <infinisil> But I feel like the uglyness is just because it's imperative :P
12:10:21 <lsund> Thanks for the pointers guys, will think about my assumptions
12:13:00 <gulguy> https://hackage.haskell.org/package/turtle-1.3.6/docs/Turtle-Tutorial.html  what is it ?? Can I generate bash code?
12:13:53 <Welkin> no
12:14:01 <Welkin> it allows you to write shell scripts in haskell
12:14:19 <Welkin> also, your name is too close to glguy
12:15:46 <glguy> I'm getting tired of your meddling. This town ain't big enough for the both of us and I'm going to give you 24 hours to get out. If I see you in Carabinas by this time tomorrow, it's you or me!
12:16:03 <gulguy> i dont know who is glguy i kept this nick  by my own
12:16:23 <glguy> (that's just a movie quote if you're not aware)
12:18:15 <tomguy> maany in ##programming say rust is waste :(
12:18:33 <Welkin> "Of all the gin joints, in all the towns, in all the world, she walks into mine. "
12:18:36 <Welkin> wrong movie
12:18:59 <Welkin> tomguy: rust is a niche language with a very specific use case
12:19:23 <tomguy> what does it mean?
12:19:35 <Welkin> it is for systems programming where you need manual control over memory
12:19:48 <Welkin> it is not for web apps
12:20:05 <tomguy> i dont need web apps
12:20:12 <[exa]> lucky you.
12:20:23 <Welkin> if you need rust, you will know it
12:20:29 <Welkin> it pretty much replaces c and c++
12:20:48 <[exa]> it's a specialization of c++ to simpler types and unique_ptr everywhere
12:21:07 <[exa]> certainly not a replacement of either C or C++   (sadly)
12:21:22 <tomguy> rust easier than c++ ?? But in ##programming they say rust is not replacement of c++
12:21:33 <tomguy> ok
12:21:34 <[exa]> certainly easier.
12:31:01 * veverak never noticed ... argument strong enough to switch to rus
12:31:03 <veverak> *Rust
12:31:08 <veverak> but I am biased because I allready know C++
12:33:11 <hpc> if you ever find yourself in a mood where you just can't be arsed to figure out if you're managing memory correctly
12:33:16 <hpc> rust starts to look really good
12:34:58 <ackthet> rust is like C++ with some ML features
12:35:03 <ackthet> ime
12:36:25 <veverak> hpc: thing is I do not have problems with C++
12:36:47 <veverak> but hey, that is debate for different channel propably ;)
12:41:51 <`Guest00000> look what I made up
12:42:05 <`Guest00000> data StreamWTF 0 k = Single k
12:42:30 <`Guest00000> data StreamWTF (S n) (x :> sx :: StreamWTF n _) = x :> StreamWTF (S n) sx
12:43:05 * frerich just defined 'type GetSet a b = (a -> b, a -> b -> a)' and wonders whether he's on the road to reinventing these awe-inspiring lenses...
12:45:04 <Ariakenom> Tip if anyone's looking for some graphics relevant math to read about: Geometric Algebra
12:47:05 <saksham> Hi people, I've tried quite a bit to find documentation on setting up custom builds with Setup.hs, but have drawn a blank. Does anyone know of something useful?
12:49:01 <saksham> If you're curious about the reason, I'm trying to bypass a (possibly) erroneous issue with ghc-pkg and static linking. (Demonstrated with code here: https://github.com/sakshamsharma/ffi-hs-testing).
12:50:04 <saksham> Want to convert a relative path (in .cabal file) to absolute, during build time. Because apparently ghc-pkg seems to be confused (:smile:) about whether it likes relative paths or not.
12:52:54 <pavonia> Are there some general rules for resolving circular function calls? I'm trying to modulize one huge single-file program and it's getting increasingly complicated because functions from (now) different modules call each other cyclically
12:53:11 <freshguy> Hello! anyone here?
12:54:10 <cocreature> pavonia: one option is to change one function to not call the other directly but instead accept it as an argument and thereby remove the circularity
12:54:17 <cocreature> freshguy: lots of people are :)
12:55:39 <pavonia> I'll try that, thanks
12:57:12 <freshguy> I bare in mind that u guys probably get question like this, and we all know that there isn't really one way of doing things correct. But how should i approach functional programming(mainly speaking about for what should i really pay attention too, books, maybe there some great books about this topic) anyway we could simplify this question to: What would you say too yourself in past before you started learning Functional Programming
12:57:42 <cement> "try programming something in the darn language, you tool"
13:02:03 <amx> "work through advent of code"
13:05:05 <Tuplanolla> How can I not lose name information when I `runQ [d| f = id; g = not |]`?
13:07:26 <ackpacket> Wondering if there is a name for this pattern.  It's trivial with mutable structures but... haskell.   Anyway, I have a deck of cards, and a list of hands.
13:08:03 <ackpacket> I need to go to each hand, in order, and "play it".  Which involves transforming the hand, and the available deck, into a result (win, lose, etc.).  Of course this *also* involves returning a new deck, since some cards were consumed.
13:08:31 <ackpacket> So I need to take the resulting deck of each handresult, and pass it to the next playHand call, on the next hand in the list.
13:09:14 <geekosaur> StateT trivially captures that, but there can be better / more specific ones
13:09:14 <amx> ackpacket: you could just fold, no pun intended
13:09:26 <geekosaur> like that
13:09:30 <ackpacket> I can think of a few ways to do this, even with tail recursion, but am wondering if there is a "most haskelly" way
13:09:48 <ackpacket> geekosaur, I think I've heard of that, is that a monad?
13:10:18 <cocreature> assuming it fits your pattern, foldl'/foldr is the first solution I would reach for
13:10:25 <geekosaur> don't think in terms of tail recursion. to the extent that it applies to Haskell, all calls are tail calls. and graph reduction doesn't work like imperative execution
13:10:41 <barrucadu> @type mapAccumL -- 'a' is the initial deck, 'c' is the result of a hand
13:10:43 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:10:49 <geekosaur> and yes, StateT is a monad (a monad transformer, actually, since you may want to do I/O so it'd be StateT GameState IO)
13:11:18 <ackpacket> brb, going to right some psuedocode paste to guarantee we're all on the same page.
13:13:57 <ackpacket> http://lpaste.net/363398 is the core of what I'm trying to do
13:15:31 <barrucadu> Yes, I'd use mapAccumL for that.  Something like `mapAccumL playHand deck hands`, where `playHand :: Deck -> Hand -> (Deck, HandResult)`
13:15:40 <barrucadu> At the end you'd get a `(Deck, [HandResult])`
13:16:09 <ackpacket> I considered that but there's oooooone tiny complication I didn't reflect in my paste
13:16:19 <ackpacket> the result of a hand can spawn new hands
13:16:26 <ackpacket> So there is sort of a Stack structure needed
13:16:40 <parsnip> [Hand]
13:17:42 <parsnip> Deck -> [Hand] -> (Deck, HandResult, [Hand])
13:17:50 <cocreature> in that case I’d probably just write a recursive function
13:17:54 <ackpacket> parsnip, yes, the issue is not finding a suitable thing in haskell to use as a stack, I was just commenting that the *need* for a stack might rule out mappAccumL as a possibility.
13:17:55 <parsnip> or actually, the hand can have a state
13:18:02 <parsnip> Deck -> [Hand] -> (Deck, [Hand])
13:18:29 <parsnip> so you might have a hand be playable, busted, etc
13:18:34 <parsnip> and then just count it up after
13:18:55 <parsnip> if it is a blackjack, it's done till counting
13:19:15 <parsnip> if dealer had blackjack, all but blackjacks lost.
13:19:37 <parsnip> depends on game really
13:19:56 <parsnip> i was trying to do spanish 21 strategy simulation in java :(
13:20:15 <parsnip> for a "job interview"
13:20:30 <ackpacket> parsnip, you in california?
13:20:36 <parsnip> no, seattle
13:20:55 <ackpacket> parsnip, do they have corporate banking on bj tables in seattle?
13:21:41 <parsnip> googling suggests that's a california thing
13:22:14 <parsnip> the blackjack rules are on wa.gov somewhere
13:36:35 <MarcelineVQ> Tuplanolla: not much luck finding a solution here, you may have to  do somehting uglier like     runQ [d| $(varP (mkName "f")) = id; g = not |]   if I'm understanding that you want to capture f
13:37:29 <Tuplanolla> This might have been a bad idea to begin with.
13:43:05 <MarcelineVQ> though I guess it's not so ugly with a little helper   [d| $(capN "f") = id; $(capN "g") = not |]
13:44:00 <MarcelineVQ> but if we keep saying silly things a th guru might step in
13:44:29 <Tuplanolla> That `capN` must be short for `captain`.
13:44:41 <MarcelineVQ> this is the case
13:47:55 <geekosaur> "the fastest way to get the right answer is to give a wrong answer"?
14:08:21 <`Guest00000> i want to create a language + compiler which separate specification of behavior from optimization for performance of programs. is there something fundamentally wrong with this idea?
14:08:56 <GodIsGreat> Hello everyone
14:09:12 <geekosaur> not fundamentally. iirc some ancient languages worked that way. and demonstrated that it's far more annoying to work with
14:09:15 <GodIsGreat> a very good morning or night to all
14:09:36 <`Guest00000> geekosaur: which languages?
14:09:46 <`Guest00000> why annoying?
14:10:10 <geekosaur> nobody wants to annotate for optimization. they want the compiler to work it out for them
14:10:15 <GodIsGreat> well I'm trying to  mimic a language like Haskell and implementing it (toyish project)
14:10:51 <GodIsGreat> I want to implement pattern matching can someone please help me how can I implement pattern matching
14:11:05 <GodIsGreat> or How it is being done in Real Haskell
14:11:49 <GodIsGreat> I'm asking for function patterns i.e. based on constructors and not for the case patterns
14:12:58 <GodIsGreat> any help will be highly regarded
14:13:47 <`Guest00000> geekosaur: but in the end, people choose a worse path and introduce 'optimizing' low-level constructions which both kill the high-levelness and annotate for/specify optimization anyway
14:15:05 <`Guest00000> 'optimization' is subjective anyway. must have a way to tell the compiler which way you like more
14:15:11 <`Guest00000> and who said my language wouldn't support annotationless code
14:15:14 <GodIsGreat> I want to ask that how this mattern matching has been implemented in Haskell
14:15:16 <GodIsGreat> http://lpaste.net/363403
14:16:56 <GodIsGreat> hello is there someone to help me ......
14:17:00 <geekosaur> `Guest00000, one of the major problems is portability. Great, you annotated for optimization... on x86_64. Won't compile on ARM or x86 32-bit. (DEC's BLISS family is kind of a canonical example)
14:17:15 <`Guest00000> wtf
14:17:24 <`Guest00000> how can you annotate for optimization on x86_64
14:17:26 <`Guest00000> it's nonsense
14:17:47 <`Guest00000> well
14:18:03 <`Guest00000> i mean "annotate for optimization" in the sense of
14:18:22 <`Guest00000> sorry
14:18:27 <`Guest00000> please ignore my last messages
14:18:30 <geekosaur> you might need more experience with this. or you are so used to high level languages where the compiler does the i=optimization heavy lifting that you haven;t thought about what manual optimization specification looks
14:18:40 <geekosaur> like
14:19:00 <`Guest00000> there will be a tree of annotation specification languages for different platforms
14:19:03 <`Guest00000> - ideally
14:19:04 <geekosaur> like, in C you can declare something 'register'. manual optimizaiton also lewts you specify which register
14:19:14 <`Guest00000> really, i don't care about different platforms, there will be only one
14:19:24 <Dynasty> GodIsGreat: you might be interested in my blog post on type inference. Implementing type safe pattern matching is just a specific case of constraint generation: http://www.calebh.io/Type-Inference-by-Solving-Constraints/
14:20:08 <`Guest00000> geekosaur: "register" is very low-level. by optimization annotations i mean more something like specifying a very high-level image of performance
14:20:35 <geekosaur> you're in even bigger trouble, I think
14:20:48 <`Guest00000> cool
14:20:50 <geekosaur> the higher level you go, the less optimization you can specify
14:21:10 <`Guest00000> high-level-in-performance
14:21:25 <geekosaur> the low level constructions you mentioned earlier are a perfect example, they;re avoiding the high levle stuff so they can manually optimize
14:21:39 <`Guest00000> sorry. need to agree what "optimization annotations" means or choose a better term
14:21:41 <Tuplanolla> My favorite is the "I don't actually need to run this program" optimization.
14:21:47 <Tuplanolla> It's very high-level too.
14:21:48 <geekosaur> high level in performance = low level in specification
14:22:10 <geekosaur> I am not in a position to recapitulate all of the experience form the 1940s on to you on IRC
14:22:24 <`Guest00000> i mean annotations for performance image/behavior
14:22:29 <`Guest00000> geekosaur: please point me then
14:22:55 <geekosaur> yesm I'm a walking bibliography for the entire past 80 years of language design, obviously
14:23:22 <geekosaur> or you;re so convinced that this is obvious and simple that you;re prepared to ignore history
14:23:33 <woodson> is there a way to get the type of a record? So for example Account = Account {field :: Text, field2 :: Text}: typeOf (acc)
14:24:18 <woodson> I want to know if its possible to pass a Type dynamically to Proxy ?
14:24:20 <geekosaur> also I'm still trying to look up the pattern stuff that someone else asked about
14:24:45 <Dynasty> geekosaur the person who asked the question closed the chat just before I tried to help them
14:24:51 <geekosaur> oh. figures
14:25:02 <Dynasty> yeah lol
14:45:29 <infinisil> woodson: Types don't even exist at runtime
14:45:36 <infinisil> woodson: what are you really trying to do?
15:12:35 <woodson> infinisil: I am trying to get the record field names of a record that is passed to one my functions
15:13:19 <woodson> something like so Acc {id_ :: String, name :: String }; myfunc :: a -> [String]
15:13:32 <woodson> where [String] is the field names
15:13:54 <woodson> I have been reading the GHC.Generic on hackage
15:14:15 <woodson> and it seems like I can do it with it but there is a part that confuses me a lot
15:14:56 <infinisil> Oh yeah it's probably possible with Generic, no idea myself though
15:14:56 <woodson> the Rep struct is really clear and understandable but the GHC.Generics "from" functions
15:15:07 <woodson> returns a structure that I dont get
15:15:10 <infinisil> What's your usecase?
15:15:38 <woodson> I building a library that will interact with salesforce rest api
15:15:55 <woodson> and I want to allow the end user to send define their data records
15:16:14 <woodson> and I will give them a function to retrieve salesforce sobjects
15:16:32 <woodson> I would like to give them the ability to provide me a record like so
15:16:45 <infinisil> Hmm, why not just use Aeson for encoding and decoding?
15:16:50 <infinisil> It does all the Generic magic already
15:17:00 <woodson> sobject :: a -> a
15:17:13 <woodson> I am using aeson a lot actually
15:17:36 <woodson> but for now the best format that I can get is this
15:17:37 <woodson> https://github.com/Woody88/Haskforce/blob/resources/src/Haskforce.hs
15:17:42 <woodson> sobject ::  SFClient -> Text -> Text -> [Text] -> IO SObject
15:18:01 <woodson> however I would like a user to be able to create their own Data types
15:18:18 <woodson> like Account {id_ :: Text, name :: Text} deriving Generics
15:18:29 <woodson> and just have a function
15:18:30 <infinisil> So the "user" is the one compiling your program?
15:18:36 <infinisil> not the end user?
15:18:45 <woodson> oops ya
15:18:53 <woodson> someone using the library
15:19:22 <woodson> sobject :: Generic a => a -> IO a
15:19:57 <infinisil> @t return
15:19:57 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
15:20:04 <infinisil> :t return
15:20:05 <lambdabot> Monad m => a -> m a
15:20:18 <woodson> ??
15:20:35 <infinisil> return has that type
15:20:50 <infinisil> I'm not sure what that function is supposed to do otherwise
15:21:03 <woodson> oh no in the background
15:21:12 <woodson> I am using Servant Client to perform the request
15:21:27 <woodson> and I need to format the input for servant client
15:21:50 <infinisil> Well actually whatever, i can't be helpful for you
15:22:15 <infinisil> (Because I don't know of any of this)
15:22:39 <woodson> infinisil: Thanks for replying haha
15:22:48 <woodson> it suddenly got so quiet here
15:22:55 <woodson> lol
15:23:06 <infinisil> Well it's european night time
15:50:08 <solrach> ?src ($)
15:50:08 <lambdabot> f $ x = f x
15:50:33 <solrach> ?src even
15:50:33 <lambdabot> even n = n `rem` 2 == 0
15:52:57 <infinisil> ?src rem
15:52:58 <lambdabot> Source not found. Maybe if you used more than just two fingers...
15:53:05 <infinisil> Aw
15:54:14 <monochrom> rem is probably a method.
15:56:17 <`Guest00000> ?src rem :: Integral a => a -> a -> a
15:56:17 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:24:10 <buhman> I'm reading "get programming with haskell" and I don't understand Q3.2. Why does this function https://ptpb.pw/E7F0/hs never return?
16:26:19 <buhman> shouldn't that be the same thing as ((x + 1) + 1) ?
16:26:54 <lyxia> buhman: 'let' is recursive
16:27:21 <lyxia> let x = x + 1  <- the x you are defining is used in its definition, it's not using a previously defined x
16:28:09 <parsnip> hmm, a logic course from a philosophy department might start relabelling things than simply x.
16:28:24 <parsnip> i remember noting they made that sort of thing more clear
16:28:43 <parsnip> whereas in math folks use the same variable for quite a while, in like, "for all x, blah blah"
16:28:55 <buhman> lyxia: hmm, I hope this gets explained better then, surely; thanks!
16:30:13 <parsnip> > let x = x + 1 in x
16:30:16 <lambdabot>  *Exception: <<loop>>
16:30:22 <buhman> yeah I saw just that loops too
16:31:16 <`Guest00000> in my GHCi it doesn't print <<loop>>
16:31:20 <`Guest00000> how to enable this?
16:31:37 <parsnip> > last [0..]
16:31:43 <lambdabot>  mueval-core: Time limit exceeded
16:31:50 <parsnip> `Guest00000: it's clever
16:34:03 <`Guest00000> ?
16:35:25 <lyxia> Maybe lambdabot compiles it
16:36:04 <monochrom> This is a brittle behaviour and you should simply not count on it.
16:47:20 <danilo2> Hi! How can I get inverse of injective type family? Lets say I've got `type family Foo a = b | b -> a` and I want to tell `type instance Bar x = InverseOfFoo x` ?
16:48:04 <lyxia> You can't.
16:48:10 <danilo2> :(
16:48:32 <danilo2> lyxia: is it designed for any purpose like so?
16:49:45 <lyxia> I don't know enough about injective type families to tell unfortunately
16:51:19 <danilo2> lyxia: thank you!
16:56:24 <salamander> 12:54 a.m. <• asdferfdsa> How can I keep track of state while live coding? For example, I want to be able to run sequentially: addString "someString"; addString "someOtherString"; and then run getStrings and get a list with the strings so far
17:12:17 <jle`> salamander: you can just do myString = myString ++ "someString"
17:12:26 <jle`> er wait
17:12:45 <jle`> myString <- return (myString ++ "someString")
17:12:53 <jle`> and take advantage of shadowing
17:13:12 <jle`> salamander: but if you are explicitly live coding, you can set up a small framework for this
17:13:30 <jle`> you can use IORefs
17:13:36 <EvanR> salamander: you can also save a set of functions that all take an IORef as  first param to ghci variables, and use those (after passing all of the progenitors the IORef you create first)
17:14:49 <woodson> is there a difference between using data and newtype when defining data structure for servant client's response?
17:15:07 <woodson> I am getting this error No instance for (HasClient (Verb 'GET 200 '[JSON] SObject))
17:15:12 <woodson> with a newtype defined
17:17:03 <lyxia> I doubt there's a difference
17:17:52 <lyxia> it's probably something else
17:18:57 <woodson> lyxia: you are right I defined another random newtype just to test and it worked..
17:19:34 <woodson> I'm really not sure whats interfering since its almost the exact same definition
17:21:16 <woodson> actually no it did not work
17:21:27 <woodson> giving me the same error hmm..
17:21:27 <EvanR> No instance for HasClient (Verb 'GET 200 '[JSON] SObject) should be enough for a starting point to the investigation... first... you might need to undo some type synonym expansions to see what it is complaining about that has no such instance
17:22:13 <EvanR> which one of those things corresponds to a type you defined
17:23:01 <EvanR> once you figure that out, figure out why it has no instance
17:23:10 <EvanR> no HasClient instance
17:24:06 <woodson> EvanR: I only have this
17:24:07 <woodson> newtype MyObj a = MyObj { fiel :: a } deriving (Generic)
17:24:16 <woodson> not really sure what I should undo...
17:25:07 <EvanR> if MyObj isnt appearing in the error, seems like youre just using the library totally wrong
17:25:15 <EvanR> regardless of your type
17:25:50 * EvanR looks at servant
17:27:22 <woodson> EvanR: the Original error was due to SObject type and then I said above that I tried with another type that I create and gave me the same error
17:27:33 <woodson> so just replace SObject -> MyObj
17:27:41 <EvanR> oh
17:33:53 <EvanR> woodson: i see some instances under HasClient which should match your Verb 'GET 200 type
17:34:08 <EvanR> but that each have requirements for your SObject or MyObj type
17:34:19 <EvanR> i dont understand them, but they are there
17:34:33 <EvanR> check near the bottom of https://hackage.haskell.org/package/servant-client-core-0.13/docs/Servant-Client-Core-Internal-HasClient.html#t:HasClient
17:35:13 <EvanR> for example... that very last one...  MimeUnrender * ct a, where a = MyObj
17:35:52 <EvanR> one way to satisfy it is to implement MimeUnrender or use a type that implements MimeUnrender
18:14:34 <dysfigured> is there a way i can download a snapshot of the haskell wiki preferably for offline viewing on my phone
18:18:06 <woodson> EvanR: It's really strange.. I should have to do all of this..
18:24:38 <EvanR> woodson: maybe go through the servant tutorial and see what the usual way is
18:24:55 <EvanR> it might be easy or automatic to implement some of these classes
18:25:39 <EvanR> (i still think lots of type classes can be counter intuitive for an API)
18:31:11 <woodson> EvanR: I have used servant for 3 small projects now. I never had that problem I pretty sure there something that I am doing thats messing everything up..
18:31:23 <woodson> after fixing one problem now I have another one ...
18:31:27 <woodson> omg it never ends
18:32:00 <EvanR> is your new type deriving different stuff or something
18:32:35 <woodson> just Generic
18:32:52 <woodson> and I also defined the FromJSON instance for it
18:32:52 <EvanR> difference between the working and non working example
18:33:00 <woodson> aside from that ...
18:38:22 <woodson> I think that its because of my generic synonym ..
18:38:44 <EvanR> i feel like we now dont have enough info to diagnose
18:38:57 <woodson> newtype SObject = SObject
18:38:57 <woodson>     { obj :: Int } deriving (Generic, Show)
18:39:00 <woodson> this will work
18:39:02 <woodson> but not
18:39:08 <woodson> newtype SObject a = SObject
18:39:08 <woodson>     { obj :: a }
18:39:08 <woodson>     deriving (Generic, Show)
18:39:42 <EvanR> because Int eventually has the instances needed by HasClient and "a" does not
18:40:11 <EvanR> that newtype looks pretty weird
18:40:42 <EvanR> its a newtype wrapper for anything, which only has bottom as a value
18:43:52 <woodson> type SObjectRow =  Capture "resourceName" Text :> QueryParam "fields" Text :> Get '[JSON] SObject
18:43:58 <woodson> this is my endpoint
18:44:09 <woodson> the reason why I wanted to wrap a within SObject
18:44:26 <woodson> is because I could be getting lets say an Account or Book
18:44:44 <woodson> or whatever
18:44:58 <EvanR> "whatever" is the part which ghc and I are going to be skeptical about
18:45:34 <woodson> "whatever" will equal to whatever data type the user using the library defined
18:45:37 <EvanR> if you can constrain Account, Book, and "whatever" somehow, then you could probably implement the required servant instances for the constraint and be ok
18:45:44 <woodson> as long as its wrapped within an SObject
18:46:09 <EvanR> if you try to implement the support for SObject, you will quickly run into a wall because the "a" has no information to sue
18:46:12 <EvanR> use
18:46:39 <EvanR> in the form of constraints, or helper functions on a
18:47:44 <EvanR> so maybe you want to specify that a must have a MimeUnrender instance
18:47:59 <EvanR> randomly guessing
18:49:40 <woodson> hmm I see
18:50:04 <EvanR> like, servant cant unseralize bytestring to random arbitrary types, it has to know something about it
18:55:15 <danilo2> Hi! Is there any type level util in GHC to convert type name to Symbol ?
18:59:38 <lyxia> Generics perhaps
19:00:49 <danilo2> lyxia: yeah Generics / TH would work here. Hmm I was looking for something built-in for that
19:00:57 <danilo2> lyxia: but yeah, Id pick TH here
19:09:00 <ertes> i'm trying to use OverloadedLabels for lenses…  either i'm doing something wrong, or 1. there is an absurd amount of boilerplate to write (HasBlah class + HasBlah instances + IsLabel instances), 2. it doesn't seem to work well with lenses at all, because i can't write IsLabel instances with higher-rank types
19:09:26 <ertes> am i doing something wrong?
19:14:00 <lyxia> @hackage generic-lens-labels
19:14:01 <lambdabot> http://hackage.haskell.org/package/generic-lens-labels
19:15:10 <ertes> ah, i see how it works, thanks
19:18:43 <ertes> instance (Functor f) => IsLabel "name" ((String -> f String) -> Person -> f Person) where fromLabel = dimap personName (fmap Person)
19:18:48 <ertes> that's actually quite nice
19:19:43 <ertes> (i know i could generalise to Iso, but it doesn't matter here)
19:20:00 <lyxia> it's better for inference to have most of the type to the left of => though
19:20:14 <xiaohei> Hi, I just started learning the language. and I can't get this to work. I have a type 'data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Eq)'
19:20:45 <xiaohei> and when I try to derive 'Show' manually with 'instance Show Tree where'
19:20:45 <xiaohei>   show EmptyTree = "empty"
19:20:45 <xiaohei>   show (Node value _ _) = "value=" ++ show value
19:21:09 <EvanR> Show can be implemented for types of kind *
19:21:14 <xiaohei> it shows me this error: '    • Expecting one more argument to ‘Tree’ Expected a type, but ‘Tree’ has kind ‘* -> *’
19:21:20 <EvanR> Tree has... yeah
19:21:37 <EvanR> instance Show (Tree a) where...
19:21:48 <EvanR> but because you need show for values...
19:21:58 <EvanR> instance Show a => Show (Tree a) where
19:21:58 <enterprisey> you probably want instance Show a => Show (Tree a) where...
19:22:36 <ertes> lyxia: you mean so that the connection to Person is more apparent?
19:22:37 <enterprisey> btw, how can I exit a do block early with Maybe
19:23:24 <xiaohei> : EvanR It worked! thank you.
19:23:38 <ertes> lyxia: i'm not sure how to do that (without reintroducing the boilerplate i'm trying to get rid of)
19:23:41 <EvanR> > do {Just 1; Just 'a'; Just False}
19:23:43 <lambdabot>  Just False
19:23:49 <EvanR> > do {Just 1; Nothing; Just False}
19:23:51 <lambdabot>  Nothing
19:24:11 <EvanR> if a Nothing comes up, the whole thing is Nothing
19:24:42 <enterprisey> and if I want to do that conditionally?
19:24:57 <EvanR> > do {Just 1; when False Nothing; Just False}
19:25:00 <lambdabot>  Just False
19:25:05 <EvanR> > do {Just 1; when True Nothing; Just False}
19:25:05 <enterprisey> oh solid
19:25:07 <lambdabot>  Nothing
19:25:12 <enterprisey> thanks!
19:25:38 <EvanR> if youre trying to do this is another monad, your milage may vary
19:26:07 <ertes> lyxia: oh, you mean literally just turn everything into a type equality like in the library you linked?
19:26:11 <lyxia> ertes: instance (Functor f, lens ~ (String -> f String) -> Person -> f Person) => IsLabel "name" lens
19:26:51 <ertes> lyxia: wouldn't that make it worse?  i'll have multiple types with the same label
19:27:24 <lyxia> I dunno, you tell me :)
19:29:44 <Gurkenglas> Why not 'instance IsLabel "name" (Lens' Person String)'?
19:29:54 <ertes> lyxia: yeah, as i expected aside from needing more extensions (TypeFamilies, UndecidableInstances) now i get duplicate instance warnings as expected
19:30:05 <ertes> Gurkenglas: because Lens' is rank 2
19:30:28 <ertes> s/warnings/errors/
19:30:38 <Gurkenglas> You can't provide instances for higher-rank types?
19:31:48 <ertes> Gurkenglas: to my knowledge you can't
19:32:12 <ertes> but that's fine…  the instance itself abstracts over f/p
19:32:21 <ertes> so you can still use it everywhere
19:41:59 <ertes> lyxia: this seems to be the best approach:  instance (Functor f, a ~ String) => IsLabel "name" ((a -> f a) -> Person -> f Person)
19:42:05 <GodIsGreat> hello all
19:42:24 <ertes> lyxia: reason is that when i write (p ^. #name), i don't have to specialise to String
19:42:45 <ertes> so yeah, here moving String to the left helps inference
19:43:23 <ertes> hi GodIsGreat
19:43:59 <GodIsGreat> I am implementing a toy mini haskell type of Language, I need help to understand how Haskell pattern matching works so that I can relate my implementation ... not case expressions , I'm asking about function patterns data constructors
19:44:43 <GodIsGreat> ertes: Hello I remember you help me earlier also, Its great to meet you again !!
19:46:03 <ertes> GodIsGreat: functions with patterns can always be translated into lambdas with case expressions
19:46:38 <ertes> sugared:  f (Just x) (Just y) = x + y; f _ _ = 0
19:47:05 <GodIsGreat> ertes: ohh..
19:47:27 <ertes> (something equivalent to) desugared:  f = \mx -> \my -> case (mx, my) of (Just x, Just y) -> x + y; _ -> 0
19:48:28 <ertes> if you're going for STG-based compilation you should probably not desugar to lambdas
19:48:48 <ertes> desugared for STG:  f mx my = case (mx, my) of (Just x, Just y) -> x + y; _ -> 0
19:48:55 <GodIsGreat> ertes: I don't know about STG compilation
19:49:28 <GodIsGreat> can you show me an example for more complex data constructor
19:50:02 <ertes> GodIsGreat: what would be more complex?
19:50:30 <GodIsGreat> ertes: having more datacontructors
19:51:38 <ertes> GodIsGreat: GHC translates all haskell code into a minimal core language, and there is a flag to dump the core version of a haskell module…  you may find it useful to come up with some examples and just see what the core version looks like
19:52:10 <ertes> GodIsGreat: in core everything is translated into non-pattern-matched let/lambda + case
19:52:36 <GodIsGreat> ertes: ohh that's great ... which flag
19:54:36 <ertes> "-ddump-…" something…  i don't remember exactly
19:55:32 <GodIsGreat> ertes: well this is very initial stage , and one problem is my language does not contain lambdas ... its in that sense imperative ... but I want to support type checking and higher order function
19:55:50 <ertes> GodIsGreat: without lambdas?
19:56:25 <ertes> that sounds horrible to work with =)
19:57:01 <EvanR> points free!
19:57:22 <ertes> GodIsGreat: is there a reason you want to avoid lambdas?
19:57:30 <GodIsGreat> ertes: yes I made funtion as first class .... I want to write an interpreter for that actually earlier I went with lambas but then it was problematic to get the steps out of a big lambda
19:57:51 <ertes> GodIsGreat: in which language are you writing the interpreter?
19:58:22 <GodIsGreat> ertes: I'm using Haskell only ... and there is my own Robot language
19:58:38 <GodIsGreat> for which I want to write an interpreter
19:59:08 <ertes> GodIsGreat: then supporting lambdas/HOFs is fairly cheap, because you can just reuse haskell's facilities
19:59:20 <ertes> including haskell HOFs, GC, etc.
20:00:26 <GodIsGreat> ertes: purpose is to learn ...my teacher told you have to build all on your own
20:01:16 <ertes> GodIsGreat: are you obligated to write an actual memory manager?  because if you don't use haskell, you'll need one
20:01:55 <EvanR> you could never free any memory, or only allow a finite amount of memory
20:02:11 <EvanR> (kind of the same thing either way)
20:02:27 <GodIsGreat> ertes: memory manager for interpreter .... I didn't have thought of this ... yes infinite memory
20:02:38 <ertes> GodIsGreat: (languages with basic FP features like HOFs with closures need GC)
20:02:40 <EvanR> modprobe infinite_memory
20:03:14 <EvanR> wget https://more.ram
20:03:30 <GodIsGreat> EvanR: sorry I thought you are talking to me
20:03:36 <EvanR> i was
20:03:46 <ertes> GodIsGreat: the usual way to write an interpreter is to design a core language first, then write an interpreter for that language, then translate the actual high-level language to your core language
20:04:14 <GodIsGreat> ertes: yes I am designing a core language
20:04:14 <ertes> GodIsGreat: keep the core language minimal…  even haskell's core language only has about a dozen constructs
20:04:40 <woodson> is it possible to create a class that sets the ToJSON function of the data type that derives it?
20:05:03 <GodIsGreat> ertes: yes I am designing a core language
20:05:15 <ertes> woodson: that…  didn't really make sense to me…  what are you trying to do?
20:05:58 <GodIsGreat> ertes: well I am sharing with you my initial implementation ... I don't know why lpaste is not working for me
20:06:31 <ertes> GodIsGreat: gist.github.com works, too
20:06:40 <ertes> (be sure to give it a filename ending in .hs)
20:06:58 <GodIsGreat> ertes: okay Thanks
20:09:25 <woodson> ertes: I know that we define a ToJSON instance for 'X' type I would like to know if its possible to define a default ToJSON definition for 'X' type that derives
20:12:11 <GodIsGreat> ertes: haha... that also told me sory not working!
20:13:04 <ertes> woodson: if X derives Generic (from GHC.Generics), then aeson will write the instance for you based on the shape of your type…  is that what you mean?
20:15:58 <woodson> ertes: almost I just noticed that I was approach the problem the wrong way ..
20:15:59 <woodson> I am using servant which uses FromJSON
20:16:00 <woodson> and I would like to define a way for the from JSON to execute the parsing
20:16:22 <ertes> GodIsGreat: well, the number of paste sites makes you question the continuum hypothesis…  i'm sure you'll find one that works =)
20:16:25 <woodson> and I found out that I would have to define my own MimeRender instance
20:16:26 <woodson> https://haskell-servant.github.io/tutorial/0.4/server.html#the-truth-behind-json
20:16:29 <GodIsGreat> ertes: hello ertes well It seems working can you here
20:16:47 <GodIsGreat> ertes: https://codeshare.io/GLZrXN
20:18:02 <ertes> that one doesn't work for me =)
20:18:16 <GodIsGreat> ertes: need to define the Pattern type used in FunctionDef
20:18:18 <ertes> skip the .io ones, they all require JS crap
20:18:34 <GodIsGreat> ertes: ohh =)
20:18:44 <ertes> … to display a simple paste…  you know…  text…
20:19:05 <GodIsGreat> ertes: can I send you a file
20:20:52 <GodIsGreat> ertes: is that a mail id     ....Q
20:21:03 <ertes> yes
20:21:15 <GodIsGreat> ertes: Thanks
20:25:45 <GodIsGreat> ertes: sent a mail
20:27:56 <ertes> instance (Functor f, a ~ String, b ~ String, t ~ Person) => IsLabel "name" (LensLike f Person t a b)
20:28:14 <ertes> any ideas to shorten this other than a constraint alias?
20:29:59 <ertes> GodIsGreat: i pasted it on lpaste: http://lpaste.net/363407
20:30:46 <GodIsGreat> ertes: okay
20:31:12 <GodIsGreat> ertes: yes I can see there
20:32:19 <GodIsGreat> ertes: should I explain the details ....
20:34:44 <GodIsGreat> ertes: well Aexp and Bexp are not being used ... I have just pasted it from my earlier different evaluator
20:37:34 <ertes> GodIsGreat: i'm currently focussing on something else…  just ask your question, there are a lot of helpful people here =)
20:38:00 <GodIsGreat> ertes: Thanks a lot
20:38:27 <GodIsGreat> ertes:can you give me just any pointer where I can read the implementation
20:39:07 <ertes> GodIsGreat: pretty much every tutorial on writing interpreters in haskell should do…  for example "write yourself a scheme in 48 hours"
20:39:28 <GodIsGreat> ertes: Thanks again
20:42:37 <ertes> i tried this, but it doesn't work…  for a really weird reason:  instance (Functor f, l Person ~ LensLike' f Person String) => IsLabel "name" (l Person)
20:42:49 <ertes> "Couldn't match type ‘Person’ with ‘Person -> f Person’"
20:43:08 <ertes> i have no idea where this error is coming from
21:02:59 <GodIsGreat> hello
21:04:16 <GodIsGreat> can anyone help me how can I support pattern matching for functions cases as in Haskell in my mini language (without lambdas)
21:04:50 <GodIsGreat> you can see some code here http://lpaste.net/363407
21:12:09 <geekosaur> the patience of a saint, that one hasn't >.>
21:16:38 <endojelly> Hello!
21:17:15 <endojelly> I spent way too much time on this already, but isn't there a lens operator already that lifts a view into a lens into an applicative?
21:17:17 <endojelly> Or simply put
21:17:46 <endojelly> (fmap (view g)) i
21:18:03 <endojelly> view g <$> i
21:18:28 <endojelly> trivial to define myself, but I keep thinking it must be there already...
21:20:46 <Xal> endojelly: have you tried a type search with hoogle?
21:20:56 <endojelly> Xal, with Hayoo, without much luck
21:21:15 <endojelly> Functor f => f s -> Getting b s b -> f b
21:21:21 <geekosaur> hayoo doesn; type search very well
21:21:35 <endojelly> Really? Huh, thought it was better, maybe not
21:21:52 <endojelly> "Warning: Unknown type Getting"
21:22:25 <geekosaur> it can handle basic stuff but it has to be a fairly close match to work; the kind of polymorphism lens does tends to defeat it
21:22:47 <geekosaur> for hoogle you'd need package:lens as part of the query iirc
21:22:56 <geekosaur> or it will only check the libraries that ship with ghc
21:22:58 <endojelly> ah
21:23:10 <endojelly> how can I make it search all packages?
21:23:17 <endojelly> That's what I like about Hayoo
21:23:33 <geekosaur> you can't; the downside of flexible type search is the metadata gets too big
21:23:55 <geekosaur> which iirc is why hoogle5's not doing type search properly yet
21:24:07 <geekosaur> part of it at least
21:24:07 <endojelly> ah
21:24:50 <endojelly> Where do I add the "package:lens"? Tried before and after, doesn't like the syntax.
21:24:55 <endojelly> Manual doesn't seem to mention it either
21:25:28 <endojelly> ah, "+lens" should do it
21:26:12 <endojelly> That worked... but unfortunately, the operator I'm looking for wasn't found: https://www.haskell.org/hoogle/?hoogle=%2Blens+Functor+f+%3D%3E+f+s+-%3E+Getting+b+s+b+-%3E+f+b
21:26:20 <endojelly> just the reguler (^.), which is view
21:35:14 <EvanR> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
21:35:16 <lambdabot>  (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
21:35:19 <EvanR> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
21:35:21 <lambdabot>  error:
21:35:21 <lambdabot>      • No instance for (Show
21:35:21 <lambdabot>                           (Integer, Integer, Integer, Integer, Integer, Integ...
21:35:30 <EvanR> just checking
21:35:46 <EvanR> poor "Show"
22:08:26 <enterprisey> Is there something for Applicatives like "some" and "many", but I specify the number of times to repeat?
22:15:34 <sl2c> ?hoogle Applicative f => Int -> f a -> f a
22:15:36 <lambdabot> Prelude (*>) :: Applicative f => f a -> f b -> f b
22:15:36 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
22:15:36 <lambdabot> Diagrams.Prelude (*>) :: Applicative f => f a -> f b -> f b
22:17:23 <nshepperd> ?hoogle Alternative f => Int -> f a -> f a
22:17:23 <lambdabot> Data.Attoparsec.ByteString option :: Alternative f => a -> f a -> f a
22:17:23 <lambdabot> Data.Attoparsec.ByteString.Char8 option :: Alternative f => a -> f a -> f a
22:17:23 <lambdabot> Data.Attoparsec.Combinator option :: Alternative f => a -> f a -> f a
22:17:39 <enterprisey> I can probably partially apply then lift replicate, actually
22:17:40 <nshepperd> some/many are an Alternative thing
22:17:48 <sl2c> nshepperd: oops, yeah.
22:17:59 <sl2c> enterprisey: yeah, there's probably something you can do with replicate and sequence
22:18:10 <enterprisey> oh there we go
22:18:18 <enterprisey> yeah, nice to know about sequence
22:18:27 <enterprisey> ty sl2c & nshepperd
22:18:29 <cocreature> :t replicateM
22:18:30 <lambdabot> Applicative m => Int -> m a -> m [a]
22:18:40 <nshepperd> ?hoogle Alternative f => Int -> f a -> f [a]
22:18:41 <lambdabot> Control.Applicative.Combinators count' :: Alternative m => Int -> Int -> m a -> m [a]
22:18:41 <lambdabot> Control.Concurrent.Speculation.Foldable asum :: (Foldable t, Alternative f, Eq (f a)) => (Int -> f a) -> t (f a) -> f a
22:18:41 <lambdabot> Protolude guarded :: (Alternative f) => (a -> Bool) -> a -> f a
22:18:48 <enterprisey> there we go, cocreature with the cosolution
22:19:04 <enterprisey> funny that hoogle wasn't able to find it
22:19:16 <cocreature> https://hoogle.haskell.org/?hoogle=Applicative%20f%20%3D%3E%20Int%20-%3E%20f%20a%20-%3E%20f%20%5Ba%5D finds it
22:19:23 <sl2c> enterprisey: I think a cosolution would be the other way around
22:19:28 <enterprisey> sl2c: true
22:19:30 <enterprisey> hmm
22:19:37 <sl2c> and hoogle wasn't able to find it because we forgot to try things returning [a]
22:19:41 <sl2c> well, f [a]
22:19:42 <enterprisey> regrettably I'm still stuck - as usual, I think I have an XY problem
22:20:11 <enterprisey> the context is I have a parser that parses strings like "t2aa", where the number specifies the number of characters to come after it
22:20:22 <enterprisey> I was using digitChar, but now I need to capture it
22:20:40 <enterprisey> oh wait do notation saves the day, disregard
22:21:03 <nshepperd> i'm not sure whether you want replicateM or count', though
22:21:56 <cocreature> sounds like the file format specifies the exact number and not just an upper bound
22:21:56 <nshepperd> oh i see, fixed number, then replicateM is correct
23:09:34 <godless> join #haskell
23:16:51 <Kuerin> list/
23:18:26 <Kuerin>  
23:18:51 <tsahyt> @hoogle (String -> String) -> (Text -> Text)
23:18:52 <lambdabot> Data.Text map :: (Char -> Char) -> Text -> Text
23:18:52 <lambdabot> Data.Text.Lazy map :: (Char -> Char) -> Text -> Text
23:18:52 <lambdabot> Data.Text.Lazy.Manipulate mapHead :: (Char -> Char) -> Text -> Text
23:20:44 <MarcelineVQ> tsahyt: what are you lookin for?
23:21:20 <tsahyt> MarcelineVQ: just \f -> pack . f . unpack, to apply some of the filepath transformations in System.FilePath to paths that are already stored in Text
23:21:28 <tsahyt> I thought perhaps there's a smarter way to do it
23:22:42 <ab9rf> (unpack .) . (. pack) :)
23:37:20 <EvanR> why does linear depend on lens
23:37:45 <EvanR> i thought compatible lenses were definable without depending on lens
23:39:38 <tsahyt> they are, it's all just type synonyms
23:39:51 <EvanR> well why the library dependency
23:40:10 <tsahyt> because it uses lens internally
23:40:28 <EvanR> really
23:40:30 <tsahyt> e.g. here https://github.com/ekmett/linear/blob/master/src/Linear/Vector.hs#L312
23:40:51 <EvanR> sigh
23:41:25 <EvanR> the result being that SDL2 bindings pull in all of lens deps
23:41:39 <EvanR> since it expresses rectangles using V2s
23:41:46 <EvanR> rather than tuples
23:41:54 <tsahyt> afaik SDL2 has a flag to disable the linear dependency
23:41:59 <EvanR> i saw that
23:42:04 <EvanR> what the heck does it do
23:42:12 <EvanR> change the whole API ?
23:42:21 <tsahyt> dunno, I haven't tried it
23:43:03 <tsahyt> "With the no-linear Cabal flag, instead exports a duplicate implementation of the V2, V3, V4 and Point types from SDL.Internal.Vect, which provides as many instances as possible for those types while avoiding any additional dependencies."
23:43:10 <tsahyt> found here https://hackage.haskell.org/package/sdl2-2.4.0/docs/SDL-Vect.html
23:43:27 <EvanR> ah now that is nifty
23:44:32 <EvanR> i like linear, it just seems odd to be used in the SDL bindings
23:45:28 <tsahyt> I can see how it's useful though, since it makes all sorts of transformations readily available
23:45:55 <boobayh> Hi why haskell not famous in data science ?
23:45:58 <tsahyt> I just throw linear at any problem that remotely looks like linear algebra. I don't particularly mind the lens dependency either tbh.
23:46:15 <EvanR> i accept that, why i want linear
23:46:18 <EvanR> when*
23:46:42 <EvanR> but the "dumb" bindings to SDL dont even do any transformations
23:47:17 <EvanR> i mean, the gl bindings dont require linear
23:47:25 <tsahyt> I think it's about convenience for the user
23:47:28 <EvanR> even though you will certainly want it
23:48:29 <EvanR> > (2,3) + (4,5)
23:48:32 <lambdabot>  error:
23:48:32 <lambdabot>      • No instance for (Num (Integer, Integer))
23:48:32 <lambdabot>          arising from a use of ‘e_12345’
23:48:41 <EvanR> r u srs
23:51:24 <boobayh> Hi why haskell not famous in data science ?
23:53:56 <cocreature> boobayh: because there are not that many Haskell libraries for data science which results in not many people using it for data science which results in not many people writing libraries and there you have your vicious cycle
23:54:32 <EvanR> we need a virus that translates all R libs into haskell
23:54:36 <boobayh> Can t be changed in any near future ?
23:54:39 <boobayh> it*
23:54:43 <tsahyt> boobayh: well there's inline-R
23:54:56 <cocreature> if you start writing libraries then that’ll help to change it :)
23:54:56 <boobayh> WHat is inline-R ?
23:55:14 <cocreature> there’s also the DataHaskell initiative but I haven’t kept up with what they’re up to these days
23:55:22 <EvanR> from what ive seen whatever R is doing would at least benefit from haskell syntax
23:55:27 <tsahyt> boobayh: it's a library that allows seamlessly calling R from haskell
23:55:36 <tsahyt> boobayh: https://tweag.github.io/HaskellR/
23:55:45 <boobayh> What about ML and DL ?
23:56:11 <tsahyt> there are also tensorflow bindings for Haskell. it's not like there's no ecosystem, it's just very limited compared to e.g. python
23:56:23 <boobayh> I hate that python
23:56:28 <tsahyt> as cocreature said, lack of libraries leads to lack of libraries. someone's gotta make the first step
23:56:46 <boobayh> Why not you top developers start ?
23:56:50 <EvanR> haskell has some good building blocks for this stuff
23:56:56 <EvanR> but none of the "killer apps"
23:57:02 <cocreature> boobayh: because not everybody is interested in data science or ML?
