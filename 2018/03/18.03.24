00:06:11 <halogenandtoast> I'm trying to write a Yesod auth plugin and I can't figure out how to be able to run getBy here: https://gist.github.com/halogenandtoast/12fe4b86b61556bd45826b3483b8b5fe#file-main-hs-L54
00:06:20 <halogenandtoast> Does anyone know what I might be doing wrong?
00:10:42 <lemmih> halogenandtoast: What error do you get?
00:11:59 <dmj`> lemmih: o/
00:12:35 <halogenandtoast> Couldn't match type ‘PersistEntityBackend record0’
00:12:35 <halogenandtoast>                      with ‘BaseBackend (YesodPersistBackend site)’
00:12:41 <halogenandtoast>         arising from a use of `getBy`
00:12:43 <halogenandtoast> sorry
00:12:49 <halogenandtoast> should have fixed that paste :\
00:13:01 <lemmih> dmj`: Hi David. :)
00:14:12 <halogenandtoast> updated the gist to remove an error, but a different one
00:14:33 <halogenandtoast> I was trying to isolate it to the simplest example and didn't copy over a part correctly
00:16:15 <lemmih> halogenandtoast: I don't know anything about yesod but it might be because you have a 'lift' too many.
00:16:18 <dtornabene> jle: what do you use as your main testing library
00:16:30 <dmj`> lemmih: good to see you here, David :)
00:17:43 <jle`> for property tests i use hedgehog for the most part
00:18:45 <halogenandtoast> I might have solved it, I think I need to specify the type as: oathPlugin :: (YesodAuth m, YesodPersist m, YesodPersistBackend m ~ SqlBackend) => AuthPlugin m
00:18:50 <dtornabene> jle: interesting, hadn't heard of that one
00:19:05 <jle`> yeah, i like it over quickcheck because it isn't typeclass-based
00:19:15 <jle`> but it's just a matter of personal preference probably
00:20:41 <dtornabene> quickcheck was the only one I knew of. but I know very little about the different libraries/eco-system in haskell world
00:22:26 <jluttine> Most (static site generator) template systems seem to build on inheritance (e.g., jinja). Do you know if there exists a template system that uses perhaps a more "functional"(?) approach by using composition? I don't know exactly what I mean or want, but I just feel there's something wrong with these templating systems that are based on inheritance..
00:22:35 <jle`> quickhceck vs hedgehog is not too big of a difference in terms of what they can do, it's basically flavors of writing the same property tests
00:23:03 <jle`> in quickcheck you can express different generators by using newtype wrappers, and in hedgehog you just use normal haskell functions
00:23:09 <jle`> but in the end they're the same tests :)
00:23:56 <dtornabene> sounds like I'd probably like hedgehog more, I'm going to find out one way or the other over the next few weeks though!
00:57:56 * hackage aivika-distributed 1.2 - Parallel distributed discrete event simulation module for the Aivika library  https://hackage.haskell.org/package/aivika-distributed-1.2 (DavidSorokin)
01:05:21 <robstr> I struggle converting a `Text` to `Query` from `PostgreSQL-Simple` package, I have OverloadedStrings extension enabled, can someone help here ?
01:07:01 <cocreature> robstr: OverloadedStrings only applies to string literals. it won’t magically convert things between different string types.
01:07:12 <cocreature> robstr: you can first convert Text to String and then manually apply fromString
01:10:15 <robstr> cocreature: for example with `fromString . encodeUtf8` ?
01:10:30 <cocreature> no encodeUtf8 converts from Text to ByteString not from Text to String
01:10:43 <cocreature> Data.Text.unpack is the function you’re looking for
01:11:00 <robstr> cocreature: oh yea, i just saw it, was confused by the error message
01:12:44 <robstr> cocreature: thank you
01:36:56 * hackage githud 2.0.0 - More efficient replacement to the great git-radar  https://hackage.haskell.org/package/githud-2.0.0 (gbataille)
02:04:44 <robstr> lpsmith: who I just realized you're the author of postgresql-simple :P
02:09:56 * hackage githud 2.0.1 - More efficient replacement to the great git-radar  https://hackage.haskell.org/package/githud-2.0.1 (gbataille)
03:07:15 <theemacsshibe[m]> Hi, I'm usually a scheme programmer but I'm writing up on some functional primitive ports and most Lisp channels are kinda dead.
03:07:48 <theemacsshibe[m]> Beyond English definitions and similar functions in other languages, can I use any other aids to help describe the functions I'm writing in my work?
03:08:04 <cocreature> theemacsshibe[m]: types? :)
03:08:14 <theemacsshibe[m]> Seriously?
03:08:19 <theemacsshibe[m]> You want TYPES?
03:08:29 <cocreature> what do you expect, you’re in a Haskell channel :)
03:08:36 <theemacsshibe[m]> I'm just asking about writing a book
03:08:59 <theemacsshibe[m]> It's about porting map and filter and other stuff to a CAS calculator
03:09:04 <theemacsshibe[m]> They don't even have first class functions.
03:09:51 <theemacsshibe[m]> Types are boring. Symbols are bloody awesome. Can I just get information about how to describe functional procedures?
03:11:19 <cocreature> I’m not sure what you’re looking for tbh.
03:12:19 <theemacsshibe[m]> I'm just wondering what the best way to explain how functional code works is, especially when it's in a language not designed for any interesting programming.
03:15:27 <theemacsshibe[m]> I don't think "join the application of f to x and the mapping of the rest of x" is very clear
03:15:31 <fakenullie> Lambda calculus?
03:15:58 <fakenullie> Haskell code?
03:16:20 <theemacsshibe[m]> Okay, I'll just λ.x λ.y my way out of explaining this.
03:16:34 <theemacsshibe[m]> I've provided Haskell and Scheme equivalent code.
03:16:57 <fakenullie> Dependent types
03:17:13 <theemacsshibe[m]> I'm trying to explain it, not confuse the reader.
03:18:24 <fakenullie> Python code
03:18:54 <theemacsshibe[m]> I'll also probably give this explanation to people who haven't programmed before and have just used their CAS to solve quadratics for them, so diving into lambda calculus or fancy metaprogramming would be a step backwards.
03:21:32 <theemacsshibe[m]> Would an expansion of the function help? I remember SICP had some of those when talking about recursion.
03:21:55 <cocreature> sure showing the evaluation steps can definitely be helpful
03:25:31 <theemacsshibe[m]> Before I'm bludgeoned to death by Scheme jokes, I can write Haskell too. Most cults let you off if you can recite some holy literature, so here's my map':
03:25:32 <theemacsshibe[m]> `map' f x = if null x then [] else (f (head x)) : (map' (tail x))`
03:28:15 <barrucadu> That is pretty Scheme-y Haskell
03:29:58 <cocreature> yeah I’m not sure a version of map that uses null, head and tail instead of pattern matching is sufficient to get absolution :)
05:49:27 <w1n5t0n> hi all, I have a bit of trouble understanding how to use StateT for my case. Here is what I am going for and what I think the types should be, but I'm not sure if I understand it right: http://lpaste.net/363996. Any help would be greatly appreciated!
05:50:35 <lyxia> Fun fact  (<=) :: Bool -> Bool -> Bool  is boolean implication.
05:52:26 <lyxia> w1n5t0n: what is an OSC message? why is helpFunc used as a function when its type is not a function type?
05:54:35 <w1n5t0n> lyxia: OSC is basically a message over UDP which can contain a variable number and type of arguments, and helpFunc should be String -> StateT [String] IO () instead, my bad
05:55:26 <lyxia> w1n5t0n: what is "some a -> b"
05:56:43 <w1n5t0n> lyxia: long story short, contextFunc represents a music synthesizer and each helpFunc is a single parameter, I want each parameter's filename to be prepended by the synth's name and after all the files have been written to send a message with the synth's name and all the filenames of it's parameters. The a->b is a function that gets evaluated over a specific set of inputs and saved to the files, that part is already working
05:59:20 <mpickering> cabal check now warns that the ghc option "-main-is" is not portable. How can I specify this in a portable manner?
06:01:30 <lyxia> w1n5t0n: is "etc" on line 13 "context2_someString", "context2_otherString"
06:02:21 <mpickering> It seems that the module must still be called Main
06:02:34 <mpickering> so this means I can't import another Main module into it...
06:03:18 <w1n5t0n> lyxia: no, it's "context1_someOtherHelpFuncString" for however many helpFuncs each synth requires. Sorry if it's undecipherable, I've tried to explain my problem without going into too much detail
06:05:14 <w1n5t0n> lyxia: I want each helpFunc to read one of the context strings, append it it's own string argument, write the file with that filename and then log that filename so that contextFunc can send the list of all filenames written to a different local process
06:05:39 <lyxia> w1n5t0n: You'll need to somehow pass the "context1" string to helpFunc, so helpFunc should probably also be a ReaderT
06:06:41 <jollygood2> is there a way to get a warning when incomplete function is being used, like head or !!?
06:07:01 <lyxia> mpickering: The only other way I know is to define a separate Main module that imports the actual main.
06:08:06 <w1n5t0n> lyxia: that's where I'm getting confused, I got it working with helpFunc returning a ReaderT but I don't know how I would make it also log itself, where with StateT I figured I could start with a default state like (String, String, [String]) and each helpFunc could read the first two strings, do some stuff and then add the resulting string to the list before moving on to the next one.
06:13:06 <zPlus-from-anoth> hi, can somebody please help me understand this error and how to fix it? http://paste.debian.net/plain/1016405
06:13:37 <lyxia> w1n5t0n: http://lpaste.net/363996 how's this annotation at the bottom
06:15:31 <lyxia> jollygood2: I don't think that's possible without redefining them (or hiding them altogether)
06:18:54 <jollygood2> lyxia what do you mean without redefining them? building a list of dummy variables with the same name as incomplete functions in prelude? I actually thought of doing that
06:19:26 <ongy> there's a {-# WARNING #-} afaik. But I'm not sure how exactly you have to apply that for this to work
06:20:26 * hackage hsass 0.6.0 - Integrating Sass into Haskell applications.  https://hackage.haskell.org/package/hsass-0.6.0 (jakubfijalkowski)
06:21:07 <ongy> I don't think I want ghc to be sassy o.0
06:21:25 <lyxia> jollygood2: right, define your own functions so you can add {-# WARNING #-} to them
06:22:19 <lyxia> Some linters may warn on these functions.
06:24:56 <jollygood2> lyxia not sure I understand. I thought I'd just have dummy function with the same name, so getting a name clash when I import my module. where does {-# WARNING #-} come into play?
06:28:31 <sternmull> is there a explanation of GHC error messages? I often only skim them because most of the type error texts are riddles to me. Can't find anything in the GHC manual. My googling also didn't help much.
06:28:33 <ongy> {-# WARNING #-} can give you a good warning message as to why it's warning you
06:29:10 <lyxia> jollygood2: If you still want to use those functions but have warnings when you do: create a MyPrelude module that imports Prelude, and redefine partial functions with warnings, and now everywhere else don't import the Prelude but import MyPrelude instead.
06:29:42 <jollygood2> lyxia ah
06:30:04 <ongy> sternmull: read them more often, then you will understand them? GHC error messages not being to friendly for quite a while is a known issue
06:31:20 <sternmull> ongy: I hoped for a guide... just playing around and reading them probably gives me only a fuzzy understanding.
06:32:57 <zPlus-from-anoth> hi, I'm trying to compile a program written in haskell but i'm getting this error http://paste.debian.net/plain/1016405 can somebody please help me understand how I can fix it?
06:33:57 <ongy> I just bothered #haskell when I didn't understand things. Or google a specific part, but I don't think there's something that covers all
06:35:16 <Ferdirand> halp, cabal broke my lens code. Now ghci complains that it cannot match Foo to (Index (M.Map Foo Bar))
06:35:25 <Ferdirand> is there anything special to do to import type instances ?
06:35:38 <sternmull> zPlus-from-anoth: That error comes from the compilation of C code. But i can't tell you how to fix that.
06:35:58 <skupra> Najbolji sajt na ovim prostorima: https://skupra.org/
06:36:31 <Ferdirand> the doc on hackage says that it is in Control.Lens.At, but even when i import that in ghci i cannot get :info to show the Index (Map k v) instance :(
06:36:41 <sternmull> ongy: Ok, then i do the same.
06:36:57 <Ferdirand> i mean Ixed sorry
06:37:15 <ongy> zPlus-from-anoth: not exactly C, it's hsc, which is a preprocessor commonly used for binding to a C library. Probably some dependency changed since the code was written and now things are a bit out of sync
06:37:43 <zPlus-from-anoth> thanks for the hints
06:38:57 <lyxia> Ferdirand: import Data.Map (Map)
06:42:33 <fr33domlover> ongy, which dependency could change though? It's the HsOpenSSL package being built on debian stable with regular stack and LTS-6.5
06:42:50 <fr33domlover> I'm wondering what may cause that error
06:49:15 <ongy> fr33domlover: maybe the package is too recent? The error is about an incomplete type, which is a good sign of mismatching versions (if things worked before)
06:50:14 <fr33domlover> ongy, but it's the HsOpenSSL from LTS 6.5, not modified at all
06:50:27 <fr33domlover> It's like plain "stack build HsOpenSSL"
06:50:46 <fr33domlover> Hmmm it's so werird
06:51:05 <ongy> whatever LTS 6.5 is, and for which versions of the openssl library it's usable *shrug*
06:51:56 <fr33domlover> ongy, HsOpenSSL is in Stackage, so,
06:52:06 <fr33domlover> It specifies *a* single specific version in there
06:52:15 <fr33domlover> And that is the one being built
06:52:57 * hackage trackit 0.2.1 - A command-line tool for live monitoring  https://hackage.haskell.org/package/trackit-0.2.1 (EmilAxelsson)
06:53:09 <fr33domlover> ongy, maybe the problem is in the C libssl being too recent? Is that possible?
06:54:10 <ongy> fr33domlover: if they made a breaking change. Some type isn't defined. It may just have moved headers and now needs another import
06:54:34 <Ferdirand> lyxia: that did not help
06:54:38 <fr33domlover> ongy, well it changed from 1.0 to 1.1
06:54:43 <fr33domlover> so i guess they did
06:55:00 <Ferdirand> however i copypasted the code for the two instances into my own source and it compiles
06:55:14 <Ferdirand> and cabal says i have the right version of lens
06:56:19 <ongy> fr33domlover: afaik stack LTS guarantees that packages in one LTS build with each other. I don't think they relate to C dependencies (and thus system packages) in any way. If you try to compile the latest LTS on debian wheezy for some reason, the packages will be too new and might not work with your libs. The same can happen when you try to build an old LTS with debian sid. They each guarantee things in the respective system work together, but mixing and mat
06:56:19 <ongy> ching can still fail
06:58:00 <zPlus-from-anoth> alright, I've downgraded to libssl-1.0 and it seems to work
06:58:07 <zPlus-from-anoth> thanks for the help guys
06:58:13 <fr33domlover> Yay!
06:59:13 <zPlus-from-anoth> now i can wait the next few hours in peace till it ends compiling :)
07:00:26 * hackage web-routes 0.27.14.2 - portable, type-safe URL routing  https://hackage.haskell.org/package/web-routes-0.27.14.2 (JeremyShaw)
07:19:56 * hackage composition-prelude 1.3.0.6 - Higher-order function combinators  https://hackage.haskell.org/package/composition-prelude-1.3.0.6 (vmchale)
07:30:15 <mclark1129> anyone had issues converting LocalTime to SqlLocalTime?  I'm getting an ODBC error "Invalid character for cast specification"
07:35:12 <mclark1129> nm, apparently the error is actually around SqlBool :dumb:
07:37:00 * hackage microlens 0.4.9.1, microlens-th 0.4.2.1 (Artyom): https://qbin.io/strobe-marshland-76yj
07:37:10 <lyxia> Ferdirand: Well that's weird, I see the Ixed instance for Map here: http://lpaste.net/364011
07:39:01 <mclark1129> A better question would be, is it possible to control the datatypes HDBC uses when loading records from the database?
07:39:14 <mclark1129> For some reason,  it is pulling out a bit (bool) field as SqlChar
07:40:47 <fr33domlover> mclark1129, maybe in the DB there is a field of type A and your code is treating it as type B?
07:41:13 <fr33domlover> check the actual running DB against the DB schema your Haskell code is assuming
07:41:24 <mclark1129> I have, it's definitely a bit field
07:42:00 <mclark1129> it comes out of the db as a SqlChar, but fromSql can convert that to a Bool fine
07:42:14 <mclark1129> so my record type is bool, that's what gets serialized out to JSON and everything's fine
07:42:18 <mclark1129> on the way back in though it's a problem
07:42:58 <fr33domlover> mclark1129, if your Haskell DB backend for whatever DBMS you're using treats the SQL bit/bool as an SqlChar it seems like a bug or something
07:43:17 <mclark1129> I'd agree, it's only a problem writing back to the db though
07:43:39 <mclark1129> i.e trying to save a SqlBool is when I get this invalid character for cast specification
07:43:49 <fr33domlover> mclark1129, you could check the DB library code and/or ask its devs about this, make an issue on the repo, make a merge request to fix it
07:44:24 <mclark1129> Probably a good idea, wasn't sure if it was just a misunderstanding on how I was using HDBC or something like that.
07:44:44 <fr33domlover> mclark1129, idk i never used HDBC, I use persistent for accessing SQL DBs
07:45:20 <mclark1129> guessing you like it pretty well?
07:45:41 <fr33domlover> Yeah it's really cool, I use it with esqueleto
07:45:49 <mclark1129> I'm using MSSQL as my backend, is that supported?
07:45:53 <fr33domlover> And there's also selda
07:46:08 <fr33domlover> mclark1129, yes it is although msssql is proprietary so I recommend against it :p
07:46:30 <fr33domlover> (well I *think* there's an mssql backend, check in hackage to be sure)
07:46:48 <mclark1129> i'll check that out.  I may see if there's an obvious bug in HDBC i can report as well
07:47:05 <mclark1129> thx
07:47:24 <vilu> Hello, a beginner question. As I'm trying to actually make my application usable in a production environment I'm beginning to need to do some logging. I'm currently using the hslogger package. My problem with this approach though is that now all of a sudden many of my functions start returning IO a and I start to wonder if this is the signatures then what's the point of trying to write FP? I've also thought about a Writer approach but I'm a bit
07:47:24 <vilu>  resistant to stacking so many monads on top of each other, I already do use a ReaderT. I guess this can be because I'm coming from Scala and I associate Monad transformers with pain but I do want to know what are your general thoughts on application logging? At some point I will have to collect metrics as well and I guess this will be a similar issue for me.
07:48:45 <kuribas> vilu: use lift and map.  Don't write everything inside a monad.
07:49:54 <guessWHo> suppose i have a function which forks a udp server on a new thread and forever listens for requests now how can i return details about this running instance of server since the function is never goanna terminate >?
07:50:16 <kuribas> vilu: I try to avoid big dependencies, and just group common functionality together...
07:50:29 <kuribas> vilu: then you can lift it into the monad when necessary.
07:50:54 <kuribas> vilu: it makes for more modular code than to write everything in the monad.
07:51:27 <ackthet> so i asked this before but didn't get a reply... is there any opinion on this book http://haskelldata.com/ ? or is there a haskell data channel?
07:52:35 <mclark1129> ackthet: I have no opinion on it
07:53:31 <ackthet> apparently the guy is a UVA professor?
07:53:44 <ackthet> and made http://shuklan.com/haskell/ also
07:54:01 <mclark1129> Are you asking just to find out if it would be a worthwhile purchase?
07:54:09 <guessWho_> sorry for asking again actually my battery died
07:54:10 <guessWho_>  suppose i have a function which forks a udp server on a new thread and forever listens for requests now how can i return details about this running instance of server since the function is never goanna terminate >?
07:54:16 <ackthet> mclark1129: basically, yes
07:54:56 <vilu> kuribas so just to see if I get your advice correctly. If you were to need logging in your code, you wouldn't write monadic code but you would rather have the functions return whatever information that you need and log it from a point up in the application where you were in fact inside of an IO?
07:55:04 <mjrosenb> Set has functions for removing the smallest and largest elements, is there a function for just removing whatever element is easiest?
07:55:19 <ongy> guessWho_: depends on what you need. There's IORef if you just have shared state, or Chan, I think Control.Concurrent.Char or similar (can't look it up right now)
07:56:10 <mclark1129> ackthet: I'd say maybe just look at a sample, or just try it out within Amazon's return policy IDK
07:56:11 <ongy> a Chan will allow you to send "messages" to a central thread, providing a way to reply might be a bit more complicated though
07:56:18 <guessWho_> ongy : i have some information about the state of server which i want to output when someone call this function say run server
07:56:25 <kuribas> vilu: no, I would write a logging function that works with you particular monad.  But if I were to do calculations on the collected data or so, I wouldn't do it in the monad.
07:57:04 <kuribas> vilu: there is nothing inherently bad about monads...
07:57:07 <guessWho_> ongy : i'm familiar with chan but i want something like , temp <- runServer , is it even possible since run server never goanna terminate ??
07:57:10 <ongy> guessWho_: "output"? To std(out/err)? you can just do that from the thread (though messages may interleave if you do that)
07:57:44 <ongy> I think you could do something with lazy IO and a bunch of unsafe* functions, but I wouldn't recommend it
07:58:02 <guessWho_> ongy : so there is no safe way of doing it right >?
07:58:11 <vilu> kuribas I have no problem with the monad per se my problem if anything would be how I loose the securities I would have were I not inside of it. I.e String -> Double is easy to know what it will do String -> IO Double all of I sudden I would wonder what's up with this function.
07:58:37 <ongy> yea, endless loops have no return value. and iirc forkIO also is over IO (), not IO a, so even going over the fork you will have to do some trickery to get a return value
07:59:00 <kuribas> vilu: you shouldn't use "String -> IO Double" if you aren't doing any IO.
07:59:42 <kuribas> vilu: you'd use fmap for that.
08:02:03 <kuribas> :t \m -> fmap read m :: IO Double --vilu
08:02:05 <lambdabot> IO String -> IO Double
08:02:20 <kuribas> vilu: for example
08:02:26 <vilu> Agreed, what I tried to illustrate with the example though is that today if I wanted to write a function "a -> b" but I wanted it to also log something along the way now I would write "a -> IO b".
08:03:23 <vilu> Which in your case I could've mapped over the monad if I just wanted to to "a -> b" but when I also want to log I end up being forced to return "IO b"
08:04:02 <kuribas> vilu: so your problem is that monads aren't very fine grained?
08:04:47 <kuribas> vilu: That's kind of true.
08:05:23 <kuribas> vilu: there is https://hackage.haskell.org/package/extensible-effects
08:05:34 <maerwald> freer is more modern
08:05:57 <guesWho> ongy : did you say something actually my session expired
08:06:50 <kuribas> vilu: but the important thing is that you cannot log using "a -> b", because that would violate the type signature.
08:07:04 <kuribas> vilu: so if you log you are required to show it somehow in the type.
08:07:23 <vilu> In a way I'm just new to the language, I barely know if I have problem. However, I like the understanding looking at type signatures in Haskell give me. When I add an IO in there that's almost out of the window. I do need quite a bit of logging in this particular situation, for now I'm adding IO to some places where I wouldn't have done so had I not logged. So in a way the actual business logic doesn't require the IO but the logging do. Maybe
08:07:23 <vilu>  people spread IO around, maybe people collect info along the way and only log at an IO point of the application I don't know. Just wanted to see in general how people reason about this.
08:07:45 <vilu> I understand
08:07:50 <kuribas> vilu: I would separate the functionality.
08:08:04 <kuribas> vilu: write a function "String -> Double", and then add logging to it.
08:08:13 <vilu> Ok
08:08:20 <anieuwland> Hi! I'm wondering how I can have a "parameter value" that's determined, but then fixed at compile, does anyone know?
08:08:22 <maerwald> that's hard when you are inside an algorithm
08:08:58 <anieuwland> Specifically I want to have a fixed installation directory from which my program looks up resource files and that directory path must be determined once (I guess at compile time), so that it is a String and not a IO String
08:08:59 <kuribas> vilu: or even a HOF that adds logging to an existing function
08:09:02 <kuribas> maerwald: not really
08:09:33 <maerwald> kuribas: are you proposing to run the algorithm, then inspect the result and do logging?
08:09:36 <mclark1129> yeah, as a beginner myself, I kind of imagine that you'd have to be inside some kind of a logging monad, and then just log the calls to specific pure functions
08:10:00 <vilu> kuribas then you can only log at the edges of that function right? So input and output?
08:10:03 <kuribas> maerwald: you can use a monad, then use IO for debugging, otherwise a pure monad for running.
08:10:09 <kuribas> maerwald: I did that in my code.
08:10:18 <maerwald> kuribas: yes, so you have to change the type of the function
08:10:22 <kuribas> vilu: yes
08:10:23 <maerwald> so you can do logging inside
08:10:45 <kuribas> vilu: otherwise use a monad.
08:10:47 <maerwald> and then probably have a "runner" function or something
08:11:03 <kuribas> maerwald: I don't
08:11:13 <the_2nd> how can I find /split numbers in a string? floating and possibly signed
08:11:22 <maerwald> kuribas: you don't what?
08:12:09 <kuribas> https://hackage.haskell.org/package/cubicbezier-0.6.0.5/docs/src/Geom2D-CubicBezier-Overlap.html#boolPathOp
08:12:36 <kuribas> maerwald: I don't have to change the function signature.
08:12:48 <maerwald> so you are not logging inside
08:13:20 <guesWho> guys if i have a non terminating function which runs forever is there a way to output something from that function other than using Chans ??
08:13:27 <kuribas> maerwald: with debugging enabled I run in IO, otherwise not.
08:13:58 <maerwald> yes, you cannot log inside the function
08:14:22 <kuribas> of course you can
08:14:31 <kuribas> "a -> (String, b)"
08:14:37 <maerwald> you are doing unsafePerformIO
08:14:39 <kuribas> the string contains the log
08:14:41 <kuribas> it's pure
08:15:06 <maerwald> why is the formatting so broken
08:15:26 <maerwald> runSweep :: SweepState -> SweepStateM () -> SweepState
08:16:03 <maerwald> I have no idea what you are doing there
08:16:04 <kuribas> maerwald: it's a literate haskell file :)
08:16:39 <ongy> guesWho: yea, I said that endless loops have no return value, so you can't do it that way. forkIO is already IO () -> IO () iirc, so if you fork anywhere you already have to do trickery to get a return value
08:16:43 <kuribas> maerwald: run a sweep using the sweep state.
08:16:55 <kuribas> maerwald: the debug code does use unsafePerformIO in my case.
08:17:02 <kuribas> but only for debugging.
08:17:04 <maerwald> My point is, if you have an algorithm that is composed of different functions and you need logging *across* all those functions, then you need to change the type signature of all of them and then apply such a "runner" function
08:17:31 <kuribas> maerwald: of course.  If you return a log, your function should reflect that.
08:18:22 <maerwald> yes, so you have to break the API to add effects
08:18:33 <guesWho> ongy : and there is no trickery which falls under the safe realm other than writing to chan >?
08:18:46 <kuribas> maerwald: yes you do.
08:19:03 <kuribas> And it's a good thing.
08:19:24 <kuribas> I really dislike API's doing so much magick around your back.
08:19:27 <kuribas> Like sqlalchemy.
08:19:28 <maerwald> depends how easy it is to add effects
08:19:42 <maerwald> freer is nice, but even that is not as declarative as you'd like it to be
08:19:56 <ongy> guesWho: chan is one way to do it. You could also go with a "raw" MVar or similar. But you need to go over some mutable ref in some way. And Chan takes care of a lot of concurrency issues when you need more than one value sent over
08:21:04 <ongy> oh and if you just want to output to std(out/err) you can just do that from your thread. There's some concurrency issues there (interleaving messages) but it's possible
08:21:13 <guesWho> ongy : and i have heard mutable structures should be avoided in haskell if possible right ?
08:21:17 <Ferdirand> lyxia: i get a different output indeed
08:21:23 <Ferdirand> am i in some sort of cabal hell ?
08:21:37 <Ferdirand> how do i check where ghci looks for packages ?
08:21:40 <maerwald> and even if you've settled for a way to do effects, there already is more than one. So consistency is gone
08:21:47 <maerwald> similar to the error handling mess in rust
08:22:08 <ongy> guesWho: you shouldn't avoid them for some interating loop or similar, but there's places where they are required
08:24:59 <guesWho> ongy : the problem with the chans is that you have to pass them around it's not like you can create a new chan and then access it from anywhere without passing it to the function wanting to read or write
08:25:17 <anhduy[m]> Hello
08:26:48 <ongy> guesWho: not any more difficult than getting the return value from the function anywhere, is it?
08:28:06 <lyxia> Ferdirand: what error do you get if you try using Ixed on a Map?
08:29:01 <Ferdirand> it complains that it cannot unify k with Index (Map k a)
08:29:11 <guesWho> ongy : it's not about difficulty i feel it's not a great solution for the problem
08:29:22 <Ferdirand> (and at other locations, that it cannot unify a with IxValue (Map k a)
08:30:20 <Ferdirand> importing in ghci shows the At and Ixed classes, and some instances, just not the one for Map
08:31:15 <guesWho> ongy : so if i have something like this forkIO $ forever someFunc would forkIO be able to return threadID ?
08:31:19 <Ferdirand> ghc 8.0.2... should i upgrade ?
08:33:18 <ongy> guesWho: yes, it returns a ThreadId, because the infinite loop runs in another thread. And forkIO returns (almost) instantly
08:34:35 <lyxia> Ferdirand: the only thing I can think of is that the imported Map is not the one lens was built with
08:35:56 * hackage haskell-packages 0.6 - Haskell suite library for package management and integration with Cabal  https://hackage.haskell.org/package/haskell-packages-0.6 (DavidHimmelstrup)
08:38:06 <Ferdirand> lyxia: aah, interesting trail
08:38:54 <Ferdirand> i never really understood it but i saw at some point ghci starting to prefix paths with a package name in :browse
08:39:27 <lyxia> yes that is a sign of it.
08:45:25 <Ferdirand> unrelated question: if i have a monad transformer stack containing two StateTs, is it possible to use zoom over the bottom one ?
08:48:56 <lyxia> probably, using 'hoist' enough times. https://hackage.haskell.org/package/mmorph-1.1.2/docs/Control-Monad-Morph.html#v:hoist
08:49:17 <Ferdirand> ah, thanks
08:50:57 <Ferdirand> lens is amazing, but i couldn't understand it properly just by reading the docs, it takes practice on real problems
08:51:21 <Ferdirand> that was also true for the entire language as well
09:04:58 <Ferdirand> lyxia: so, hoist wants a (forall a. m a -> n a)
09:05:10 <Ferdirand> but i want to zoom over a traversal, which seems to require Monoid a
09:05:17 <anieuwland> Is it possible to at compile time pass a string to ghc that somehow can be put into Haskell files?
09:06:17 <Ferdirand> anieuwland: the pragma OPTIONS_GHC maybe ?
09:07:05 <MarcelineVQ> anieuwland: based on your earlier wording of the question you probably want template haskell
09:07:42 <anieuwland> Ferdirand: Thanks, researching this now.
09:07:50 <Tuplanolla> There's an easier way, anieuwland.
09:07:57 <anieuwland> MarcelineVQ: I looked at it, but it seems very difficult :(
09:08:36 <anieuwland> All I want is a variable prefix to the folder with my resources that gets hardcoded
09:08:36 <Tuplanolla> Put `{-# LANGUAGE CPP #-}` into your file and pass `-DY=X` to `ghc` to replace all occurrences of `Y` with `X` before compiling.
09:08:53 <anieuwland> Tuplanolla: Oh that sounds exactly like what I need!
09:09:36 <Tuplanolla> Dubious, but go ahead.
09:10:05 <anieuwland> Tuplanolla: You don't recommend it?
09:10:57 <Tuplanolla> Consult the user guide for the potential problems.
09:16:15 <MacSlow> Greetings everybody!
09:19:56 <lemmih> MacSlow: Hi!
09:21:06 <iron_houzi> I have a "multi line" function: int2bin 0 = []; int2bin n = n `mod` 2 : int2bin (n `div` 2). When I run this in ghci, the last line overwrites the first, so the function doesn't get a recursive base case. How do I do this in ghci? I've tried searching for "multi-line" ghci, but I'm probably not using the correct terms..
09:23:08 <lemmih> iron_houzi: Start the line with ':{', then type your function and end with ':}'
09:23:20 <aaronStone> (<-) is specifically for IO for all Monads Ma we can do temp <- Ma ?
09:24:07 <lemmih> aaronStone: Use can use that notation with all monads.
09:24:30 <lemmih> *You can use ...
09:24:35 <iron_houzi> lemmih: ty
09:25:09 <aaronStone> lemmih : ok ty :)
09:25:17 <Tuplanolla> Alternatively `:set +m`, iron_houzi.
09:27:42 <MarcelineVQ> or even use ; as you did just now as one line
09:28:59 <anieuwland> Tuplanolla: This should be good enough right? In my cabal file `cpp-options: -DPREFIX share` and in my Haskell file `{-# LANGUAGE CPP #-}` at the top and defPath = "PREFIX/" :: FilePath to define my path
09:29:24 <anieuwland> PREFIX doesn't get replaced however and I can't seem to figure out why...
09:29:37 <Tuplanolla> This is why I pointed you to read the use guide, anieuwland.
09:30:01 <Tuplanolla> All the caveats of the C preprocessor apply.
09:31:05 <anieuwland> Tuplanolla: I looked at https://downloads.haskell.org/~ghc/7.0.2/docs/html/users_guide/pragmas.html and the page it linked to for LANGUAGE, but didn't see any page with details
09:31:30 <cocreature> that user guide is for GHC 7.0. that’s ancient
09:31:56 <Tuplanolla> You could say `-DPREFIX="PREFIX/"`, but I don't know how reliable the escaping of quotation marks is.
09:36:00 <cocreature> -DPREFIX=\"share\" seems to work for me
09:36:15 <Tuplanolla> Shell or Cabal file, cocreature?
09:36:24 <cocreature> shell
09:36:31 <aaronStone> what's the difference between TVar MVar ??
09:36:55 <anieuwland> Hmm
09:37:04 <cocreature> ah if I wrap the whole thing in ' I don’t need to escape the quotes
09:37:21 <aaronStone> are TVar just transactional version of MVar ?
09:37:40 <cocreature> aaronStone: not quite, MVars can be full and empty whereas TVars always contain a value
09:37:57 <anieuwland> cocreature: so that replaces `PREFIX` with `share`? It doesn't seem to do anything for me, hm..
09:38:31 <cocreature> anieuwland: you can’t make your example work. you need to use PREFIX outside of a string literal as Tuplanolla showed you
09:38:47 <aaronStone> cocreature : so that and atomicity are the only difference ?
09:39:22 <anieuwland> Aha, that's what he tried to say
09:39:50 <anieuwland> But then Haskell doesn't compile it to, complaining about a string literal :|
09:40:09 <cocreature> that’s why you need the quotes in the define
09:40:52 <anieuwland> cocreature: Yeah, I have them, but it hasn't even replaced PREFIX
09:41:33 <cocreature> anieuwland: you’ll have to show us the code you’re using now.
09:42:20 <anieuwland> Let me make a small example, because this project is too large. 1s
09:42:23 <cocreature> aaronStone: yeah but those are quite major differences. the only thing they have in common is that you can write values to them
09:52:09 <anieuwland> cocreature: Here is what I'm doing  https://github.com/Nimmerwoner/example
09:52:25 <anieuwland> As you can see in https://github.com/Nimmerwoner/example/blob/master/test.cabal I have -DPREFIX=\"share/\"
09:52:52 <anieuwland> And in https://github.com/Nimmerwoner/example/blob/master/src/Main.hs I have the CPP pragma on and path = PREFIX
09:53:19 <Tuplanolla> Try `-DPREFIX="share"` and `-D'PREFIX="share"'`, anieuwland.
09:53:35 <Tuplanolla> One should work.
09:53:53 <cocreature>   cpp-options: -DPREFIX="share" works for me
09:54:26 * hackage dhall 1.12.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.12.0 (GabrielGonzalez)
09:54:31 <anieuwland> Tuplanolla: If I do that I get a macro names error
09:55:18 <anieuwland> cocreature: It doesn't for me :( What command are you using to build? I do `stack build`
09:55:51 <cocreature> anieuwland: yes just stack build. which error message do you get? also just to be sure, can you push the updated cabal file you’re using?
09:56:53 <anieuwland> Wait! Yes! Now it works!
09:57:15 <anieuwland> When using cpp-options I still had the ""s escaped
09:57:37 <anieuwland> I thought I'd also already tried it without them escaped, but apparently I didn't
09:57:42 <anieuwland> Thanks cocreature, Tuplanolla
09:59:48 <anieuwland> Yay, now I can remove four modules whose only purpose was defining a different path for different compile targets :D
10:12:32 <mdim> Greetings! By using random :: RandomGen g => g -> (a, g) from System.Random, I can get a double number from the the semi-closed interval [0,1). How to get it from (0, 1]?
10:14:54 <cocreature> mdim: subtract the result from 1?
10:15:18 <mdim> cocreature: cool! thanks!
10:15:26 * hackage dhall-json 1.0.13 - Compile Dhall to JSON or YAML  https://hackage.haskell.org/package/dhall-json-1.0.13 (GabrielGonzalez)
10:16:31 <mxms> so i have some data like 'data Expr = Var Name | App Expr Expr | ...' and I pass an App as an argument to a function. how do i get the two exprs?
10:16:48 <mxms> i know i can do case exp of App a0 a1 -> etc
10:18:26 * hackage dhall-nix 1.1.2 - Dhall to Nix compiler  https://hackage.haskell.org/package/dhall-nix-1.1.2 (GabrielGonzalez)
10:18:31 <cocreature> mxms: if you know you can use pattern matching then I’m not sure what you’re looking for. that’s exactly what I would use here
10:19:43 <mxms> aaaaah, isee
10:24:56 * hackage dhall-bash 1.0.11 - Compile Dhall to Bash  https://hackage.haskell.org/package/dhall-bash-1.0.11 (GabrielGonzalez)
10:26:26 * hackage lambda-options 0.9.1.0 - Declarative command line parser using type-driven pattern matching.  https://hackage.haskell.org/package/lambda-options-0.9.1.0 (ThomasEding)
10:27:56 * hackage dhall-text 1.0.8 - Template text using Dhall  https://hackage.haskell.org/package/dhall-text-1.0.8 (GabrielGonzalez)
10:31:56 * hackage brick 0.35.1 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.35.1 (JonathanDaugherty)
10:40:55 <benzrf> is there a way to read data from a file into a Data.Vector.Storable
10:41:16 <benzrf> like, packed fixed-size items (doubles in this case)
10:42:08 <benzrf> iterating some kind of read-a-double function seems extremely inefficient given that it's possible to load big blocks of the file
10:42:47 <benzrf> ooooh wait https://wiki.haskell.org/Numeric_Haskell:_A_Vector_Tutorial#An_example:_filling_a_vector_from_a_file
10:42:49 <benzrf> :>
10:46:35 <woodson> Servant's QueryParam requires me to send my value as (Maybe Text) however it transforms the Just constructor as a text and also adds it to the params
10:46:45 <woodson> like so https://na50.salesforce.com/services/data/v42.0/sobjects/query?[("q",Just "SELECT+name+from+Account")]
10:47:16 <woodson> http://lpaste.net/1694032567235248128
10:47:28 <woodson> anyone knows why?
10:55:26 * hackage stratosphere 0.20.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.20.0 (jdreaver)
11:02:08 <cocreature> woodson: servant-client?
11:09:26 * hackage extra 1.6.5 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.6.5 (NeilMitchell)
11:09:33 <cocreature> woodson: also there seem to be more things wrong in that url than just the fact that the Just constructor is included. I would expect something like …query?q=SELECT…
11:10:56 * hackage giphy-api 0.6.0.0 - Giphy HTTP API wrapper and CLI search tool.  https://hackage.haskell.org/package/giphy-api-0.6.0.0 (passy)
11:15:14 <woodson> cocreature: Yes, servant-client
11:15:29 <cocreature> woodson: can you show us the code that actually constructs the query?
11:15:49 <cocreature> woodson: also which version of servant are you using? there have been a few changes specifically to QueryParam recently
11:17:26 * hackage hlint 2.1.1 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.1.1 (NeilMitchell)
11:18:58 <woodson> cocreature: http://lpaste.net/364018
11:19:41 <woodson> In my package yaml file I haven't yet specified a version
11:19:48 <woodson> so I should have pulled the latest
11:20:14 <jle`> woodson: check
11:20:29 <cocreature> package.yaml sounds like you’re using stack which will pull whatever is in the resolver you specify which is often not the latest
11:20:35 <jle`> not specifying a version doesn't necessarily mean you have the latest
11:20:44 <jle`> in fact it more often means that it doesn't
11:20:52 <jle`> *you don't
11:21:30 <jle`> you can check with `ghc-pkg list`, or `stack exec ghc-pkg list` if stack is managing your deps
11:21:45 <woodson> servant-client 0.11
11:21:55 <cocreature> that’s two versions behind
11:21:59 <cocreature> 0.13 is the latest
11:22:14 <cocreature> I’d try updating just in case it was a bug in servant
11:22:20 <jcowan> What is the conventional way to pronounce the >> monad operator?
11:22:40 <jle`> i say 'and then', or sometimes 'sequence'
11:22:48 <jle`> but sequence is also the name of another function
11:22:55 <jle`> sequence [x,y,z] = x >> y >> z, for the link
11:23:00 <EvanR> dont try to pronounce it
11:23:11 <EvanR> you could say "chevrons"
11:23:33 <ongy> trust TH call it NoBind :/
11:23:47 <EvanR> lol
11:23:51 <cocreature> jle`: that’s not correct, sequence will give you back a list of results
11:24:18 <woodson> cocreature: ok, rebuilding my project now
11:25:05 <jcowan> "and then" is how I pronounce && in C and other eager languages (lazy in the right argument only)
11:25:09 <jcowan> and || is "or else"
11:26:57 <jcowan> but I still like "and then".  Thanks, jle`.
11:40:52 <jle`> cocreature: oops, yeah, i guess it's closer to sequence_
11:41:14 <EvanR> you were thinking the '=' means their effects are equal
11:41:33 <EvanR> but... the effects are encoded in the value
11:41:44 <jle`> yeah they are equal in the equivalence class of effects :3
11:42:19 <jle`> equivalent modulo results
11:42:24 <jle`> s/equivalent/congruent
11:51:39 * hackage language-ats 1.2.0.3, dependency 0.1.0.10, hs2ats 0.2.1.8, shake-ext 2.7.0.4 (vmchale)
11:52:29 * hackage ats-pkg 2.7.1.2, shake-ats 1.5.0.10 (vmchale): https://qbin.io/vindicate-polka-86ia
11:55:56 * hackage composition-prelude 1.3.0.7 - Higher-order function combinators  https://hackage.haskell.org/package/composition-prelude-1.3.0.7 (vmchale)
11:58:26 * hackage direct-sqlite 2.3.23 - Low-level binding to SQLite3.  Includes UTF8 and BLOB support.  https://hackage.haskell.org/package/direct-sqlite-2.3.23 (JanneHellsten)
12:01:56 * hackage apply-refact 0.5.0.0 - Perform refactorings specified by the refact library.  https://hackage.haskell.org/package/apply-refact-0.5.0.0 (mpickering)
12:03:27 <rotaerk> wtf, monad-loops has so many dependencies, though they don't show up on hackage
12:03:40 <rotaerk> I added it to my cabal, and suddenly it's trying to get tasty, parsec, async, HUnit
12:04:09 <ongy> are they transitive deps?
12:05:03 <rotaerk> yea
12:05:15 <rotaerk> I think it's tasty (testing related package) that causes it
12:05:21 <EvanR> tasty is in the dependenies for the test suite
12:05:24 <rotaerk> of course, HUnit failed tto build...
12:05:25 <EvanR> but not the lib itself
12:05:58 <EvanR> interesting reporting on hackage
12:06:12 <EvanR> i wonder if it always did that
12:07:57 <rotaerk> hmm I've seen this HUnit build failure before; if only I had a decent memory
12:08:35 <davean> EvanR: Thats how Hackage has always reported it to me - sadly.
12:13:02 <v0idpwn> I know that if I want to use a function over all elements of a list I can use map, but what if the function receives an extra argument?
12:13:14 <EvanR> interesting... showCReal 1 is as slow as showCReal 50 when trying to sum 30000 "1/3s"
12:13:52 <EvanR> maybe i should exploit it and ramp it up to 10000 digits
12:14:13 <EvanR> otherwise why is 1 digit not speeding it up
12:14:34 <EvanR> v0idpwn: map (f extraArg) xs ?
12:17:20 <QWERTY> Does anyone know when/if RC3 of the Haskell book is/did coming out?
12:20:56 * hackage generics-eot 0.3 - A library for generic programming that aims to be easy to understand  https://hackage.haskell.org/package/generics-eot-0.3 (SoenkeHahn)
12:23:10 <rotaerk> I see; for some reason HUnit doesn't want to build when I have profiling enabled
12:24:24 <v0idpwn> thanks, EvanR, sorry for the newbie question, I still don't feel confident with Haskell syntax.
12:31:10 <cheater> hi
12:32:40 <cheater> i've seen a way to define DSLs where you defined something like data Expr a = Add a a | Let ... | ... and then you did something like type MyDSL = Fix Expr. What is that called? Is there a tutorial or doc that describes something like this in a simple way?
12:34:23 <pikajude> free monad i think?
12:35:47 <rotaerk> cheater, hmm was it this http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf
12:36:54 <Tuplanolla> Keywords, cheater: f-algebras, recursion schemes, fixed points of functors.
12:40:04 <joeyh> didn't hackage used to have a single taball containing all the package's tarballs?
12:42:38 <davean> joeyh: hum?
12:42:48 <davean> joeyh: packages are a single tarball
12:43:06 <joeyh> I mean a tarball containing the source for every package in hackage
12:43:19 <joeyh> eg a mirror
12:43:19 <davean> No, though if you want that, I have something for you
12:44:00 <joeyh> I'm looking for the simplest thing to get ingested into https://archive.softwareheritage.org/
12:45:28 <cheater> rotaerk, no, it was someone's code base. let me look at this pdf, thanks
12:47:16 <cheater> rotaerk, no, that wasn't it - they specifically used Fix
12:51:19 <cheater> rotaerk: it wasn't a "data types ala carte" approach because they still kept all constructors within one ADT.
12:52:29 <cheater> rotaerk: but, they used Fix so that when writing the evaluator on eg Lam or Let they didn't have to talk about what type values were inside them
12:54:12 <cheater> any other takers? :)
12:54:28 <cocreature> I think Tuplanolla has already given you all the options
12:54:56 <cheater> i've just noticed what they said yeah but i don't really know how those apply!
12:55:48 <Tuplanolla> Not the stock options!
12:59:27 <gabe4k> which pretty printing library should I use?
12:59:57 <cocreature> gabe4k: prettyprinter
13:00:15 <rotaerk> ah...  https://github.com/hspec/HUnit/issues/22
13:00:23 <rotaerk> wonder why he wont-fixed it
13:00:29 <rotaerk> guess I'll try to fix it...
13:00:49 <gabe4k> cocreature: I was considering that one, I'll go ahead with it then
13:01:23 <michalrus> For a `class A a where type B a`, can I require that `B a` belongs to some other class for all instances of `A`?
13:04:13 <cocreature> how can I figure out which version of Cabal a GHC release shipped with?
13:06:11 <michalrus> cocreature: on NixOS: find $(dirname $(dirname $(readlink -f $(which ghc)))) | grep -i cabal
13:06:16 <michalrus> /nix/store/30dh7kfr4q1fl5p2pzn277347wxnv4rg-ghc-8.0.2-with-packages/lib/ghc-8.0.2/Cabal-1.24.2.0/Paths_Cabal.hi
13:06:18 <michalrus> Etc.
13:06:30 <cocreature> michalrus: I’m not on nixos :/
13:06:41 <michalrus> One more reason to switch. (ﾉ^_^)ﾉ
13:06:46 <michalrus> No, but I dunno otherwise. :(
13:07:03 <cocreature> ah the download page of 8.0 mentions cabal 1.24 so it probably ships with that
13:07:07 <cocreature> that’s all I need to know
13:08:26 * hackage brick-skylighting 0.2 - Show syntax-highlighted text in your Brick UI  https://hackage.haskell.org/package/brick-skylighting-0.2 (JonathanDaugherty)
13:08:56 <woodson> cocreature: Just to let you know, upgrade the version to 0.13 fixed my issue. It broke some other things too but I manage to fixed those.It seems like they transferred quite a few things in this new module servant-client-core
13:09:19 <woodson> Servant.Client.Core
13:09:28 <cocreature> woodson: yeah the main reason for that was so that code could be shared with the ghcjs client afaik
13:11:13 <woodson> I see! I also upgraded my lts too. I will keep that in mind for my future projects
13:19:19 <v0idpwn>  
13:19:19 <v0idpwn> check_div :: (Int a) => a -> a -> Bool
13:19:19 <v0idpwn> check_div k p
13:19:19 <v0idpwn>   | mod k p == 0 = True
13:19:22 <v0idpwn>   | otherwise = False
13:19:27 <v0idpwn> why don't this workkkkkkk
13:19:48 <v0idpwn> I'm frustrated
13:19:52 <cocreature> v0idpwn: can you be a bit more precise? what doesn’t work?
13:20:00 <cocreature> also please use some pastebin for multi-line code samples
13:20:52 <v0idpwn> Expecting one fewer argument to Int, expected * -> Constraint but int has kind *
13:20:57 <v0idpwn> I'm sorry
13:21:59 <cocreature> v0idpwn: Int is a type not a typeclass. with "Int a => " you’re specifying that the type "a" has to be an instance of the typeclass "Int" which fails
13:22:06 <cocreature> v0idpwn: just use Int -> Int -> Bool
13:23:20 <v0idpwn> Do you have a good source on this kind of stuff?
13:23:58 <woodson> v0idpwn: sounds like your are just starting. http://book.realworldhaskell.org/read/
13:24:20 <cocreature> pretty much any introductory Haskell book should cover this. I haven’t read it myself but I’ve heard very good things about haskellbook.com
13:24:48 <woodson> https://en.wikibooks.org/wiki/Haskell
13:25:12 <woodson> or Haskellbook. I have it and its really good
13:25:50 <v0idpwn> I'll be taking a look on both. Yes, I'm starting :)
13:26:55 <woodson> v0idpwn: ok, ya so typeclass probably doesnt mean anything to yet.
13:27:12 <woodson> so just pick one of those links and go through the intro
13:28:03 <v0idpwn> Yeah I started yesterday and was just testing even smaller stuff on ghci
13:31:27 <gentooist> hey i still need help with making a lists from a list (including the empty list) so if i have the list [1,2] i need to get a list like so: [[],[1],[2],[1,2],[2,1]]. of course it should handle ant size of a list (for example also this one: [1,2,3,4,5,6,7,8]). i want to do it with a recursive function but i don't know how to do it. i thought about it for a long time and i again need help. please do not give me an answ
13:31:27 <gentooist> er (i have some answers that i still don't look at because i want to do it myself).
13:32:40 <gentooist> i need guidance
13:33:24 <woodson> gentooist: you want to transform [1,2,3] -> [[1],[2],[3]]?
13:33:41 <zachk> looks like he wants a powerset
13:34:52 <v0idpwn> I get confused about how stuff I wrote on ghci does not necessarily works on ghc
13:34:58 <gentooist> woodson no if i have [1,2,3] i need to get [[],[1],[2],[3],[1,2],[2,1],[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
13:35:54 <zachk>  > let power list = filterM (\x->[True,False]) list in power [1,2,3]
13:35:59 <zachk> this is kind of what you want
13:36:06 <gentooist> woodson: i need any posibble solution for a list from the source list
13:36:14 <zachk> > let power list = filterM (\x->[True,False]) list in power [1,2,3]
13:36:15 <Tuplanolla> > concatMap permutations . subsequences $ [1 .. 3] -- This was discussed a few days ago, zachk.
13:36:17 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:36:17 <lambdabot>  [[],[1],[2],[1,2],[2,1],[3],[1,3],[3,1],[2,3],[3,2],[1,2,3],[2,1,3],[3,2,1],...
13:36:31 <zachk> oh nice
13:36:44 <gentooist> Tuplanolla: you helped a week ago if you remember :)
13:36:52 <Tuplanolla> Yes.
13:36:58 <gentooist> but i didn't get to anywhere afterwards :)
13:38:14 <gentooist> i'm still thinking of this and dont get anywhere.
13:38:58 <gentooist> can i do this with basic haskell understaning (im noob). no monads etc'. just basic understanding of recursion and basic haskell.
13:39:20 <Tuplanolla> Yes, but the orderings make it quite tricky.
13:39:53 <Tuplanolla> > subsequences [1 .. 3] -- You should perhaps start with a recursive definition for this one.
13:39:55 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
13:41:29 <gentooist> Tuplanolla: i'll try it (will come back and look for you again :-)
13:42:25 <Tuplanolla> Most people here have the skills to help you if you just provide the context.
13:42:47 <Tuplanolla> In case I'm not around, that is.
13:43:21 <v0idpwn> Why do "takeWhile(< sqrt n)) xs" works on ghci, but on ghc I get No instance for floating int arising from a use of sqrt?
13:43:51 <gentooist> OK
13:52:24 <Hafydd> v0idpwn: how are xs and n defined?
13:53:48 <v0idpwn> n is Int, xs in [Int]
13:53:53 <v0idpwn> is*
13:54:24 <Hafydd> v0idpwn: that isn't what I asked, but that would explain why, when compiling with GHC, you get that error message. Did you specify them with those types in GHCi as well?
13:55:55 <v0idpwn> I wrote line per line on GHCi
13:56:09 <Hafydd> v0idpwn: what exactly was your input into GHCi?
13:56:21 <Eitan> hello
13:56:56 * hackage xlsx 0.7.2 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.7.2 (KirillZaborsky)
13:57:10 <v0idpwn> xs = [y | k <- [1..], y <- [(6*k)-1,(6*k)+1]]
13:57:32 <v0idpwn> used n = [2,3] ++ takeWhile(<sqrt n) xs
13:57:56 * hackage hspec-dirstream 0.5.0.0 - Helper functions to simplify adding integration tests.  https://hackage.haskell.org/package/hspec-dirstream-0.5.0.0 (vmchale)
13:59:07 <woodson> v0idpwn: you should maybe use http://lpaste.net/
14:01:33 <v0idpwn> Yeah I did it again ;_;, I thought I could because it was just two lines
14:01:53 <Hafydd> v0idpwn: you aren't finished, are you? You haven't defined n.
14:03:11 <Hafydd> v0idpwn: oh, I see your expression is in the definition of used. That doesn't cause any error because the type of xs isn't constrained to be [Int] there.
14:04:46 <v0idpwn> That's why it works on ghci but not on ghc?
14:05:07 <Hafydd> v0idpwn: if you compiled the same code with GHC, it would also not cause any error by itself.
14:05:32 <Hafydd> v0idpwn: but you stated that you defined xs with type [Int] in that case, which would make it a different program.
14:06:23 <v0idpwn> Ain't xs [Int] by definition? As it is just part of another [Int]
14:06:50 <v0idpwn> I'm reading about haskell types rn but I'm still confused
14:06:54 <Hafydd> v0idpwn: no, it isn't. By definition, it is of type xs :: (Num t, Enum t) => [t].
14:06:59 <zachk> @type fromIntegral
14:07:00 <lambdabot> (Num b, Integral a) => a -> b
14:07:56 <zachk> > filter (\x->(sqrt . fromIntegral $ x) < 4) [1..20]
14:07:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
14:08:06 <Hafydd> v0idpwn: although when given as a top-level definition in a Haskell program, the type will be specialised, by default, due to the monomorphism restriction. It might be specialised to something like [Float].
14:08:16 <zachk> you need to 'cast' the int to a float using fromIntegral
14:08:48 <Hafydd> v0idpwn: note that literals such as "1" can be of any numeric type, not just Int.
14:11:00 <v0idpwn> ohh
14:12:43 <Hafydd> v0idpwn: you can type ":t xs" on the GHCi prompt to see what the type is, either after typing it into GHCi (which will define it with a polymorphic type), or loading the definition from a Haskell source file (which will have a monomorphic type if it's at the top-level and with the monomorphism restriction).
14:13:23 <Hafydd> (And if it isn't explicitly given a polymorphic type.)
14:15:47 <cheater> what does this |= mean here? type Exp = ([String ⊨ Int], Int)
14:15:52 <cheater> it's in this blog post https://alessandrovermeulen.me/2013/07/13/the-difference-between-shallow-and-deep-embedding/
14:31:36 <Jacoby6000[w]> What's a good haskell web-client library?
14:31:59 <dmj`> http-client, wreq, servant-client
14:32:12 <dmj`> (latter 2 both based on former)
14:33:04 <Jacoby6000[w]> is http-client good enough to just use on its own?
14:33:15 <Jacoby6000[w]> I'm used to java where the built in stuff is basically unusable.  lol
14:34:13 <dmj`> Jacoby6000[w]: yea, its usable as is
14:53:45 <gentooist> Eitan: hebrew?
14:54:24 * gentooist
15:03:23 <rotaerk> hmm is there some way to test, either via CPP or at runtime, whether it's being built with profiling enabled
15:06:42 <rotaerk> basically, I want to run different logic if profiling is enabled (i.e. the -prof flag was passed to GHC)
15:07:17 <rotaerk> (Unusual need, I know, but it will fix a bug in HUnit's test case)
15:11:44 <Eitan> gentooist: yes, my name is Hebrew
15:11:49 <davean> rotaerk: wait, what?
15:12:07 <rotaerk> https://github.com/hspec/HUnit/blob/master/tests/HUnitTestExtended.hs#L27
15:12:35 <Eitan> anyone know how to set up circle ci using Haskell & Postgres?
15:12:37 <davean> rotaerk: I wouldn't call that an "unusual need", I'd call that flat out disingenuous code
15:12:41 <rotaerk> this line contains the string expected from calling:  error "error"
15:13:16 <rotaerk> except when profiling is enabled, the error that is produced is different
15:13:25 <davean> rotaerk: If I caught code doing something like changing its logic because profiling was ennabled I'd probably never trust that package, or any of its authors ever again
15:13:36 <rotaerk> I know, in general that's true
15:13:40 <rotaerk> I don't think that applies here
15:14:38 <davean> rotaerk: Why don't you parse the error?
15:15:56 * hackage lmdb-simple 0.4.0.0 - Simple API for LMDB  https://hackage.haskell.org/package/lmdb-simple-0.4.0.0 (RobLeslie)
15:16:23 <rotaerk> I think the intent of this test is to make sure (TestCase errorCall) produces the exact string
15:16:53 <rotaerk> though maybe a better fix would be to use a different error, one whose output is not impacted by profiling being enabled
15:16:58 <rotaerk> if such an error exists ...
15:17:46 <davean> rotaerk: well, profiling isn't all that will change that
15:18:11 <rotaerk> my goal here is to make HUnit *not* fail to build when I have profiling enabled
15:18:18 <rotaerk> (when tests are enabled, that is)
15:24:02 <davean> rotaerk: setUncaughtExceptionHandler
15:24:29 <davean> er, sorry, you're below there, you're catching it
15:24:41 <rotaerk> hmm maybe what I'll do is use errorWithoutStackTrace instead
15:24:55 <rotaerk> I wonder if that'll eliminate the details from the error message that vary based on whether profiling's enabled
15:25:03 <rotaerk> (but I'm not really clear on what the author is TRYING to test here)
15:25:14 <davean> Their test does seem weird
15:25:34 <davean> You can't relly rely on how it serializes to a string in most cases ...
15:26:23 <rotaerk> hmm lemme check history, see if comments are enlightening
15:27:28 <rotaerk> nope
15:29:09 <davean> You can easily test if its one of the two though - just not via direct string matching
15:29:33 <rotaerk> one of the two what
15:29:40 <davean> but if they're relying on that serialization I'm worried about its reliability in general
15:29:48 <davean> cases - profiling or non
15:29:53 <rotaerk> https://github.com/hspec/HUnit/commit/2b20abcd6a79c9ad1313afcf18257b29f67f2acf#diff-97828dee76e50bdab364a56f3e7491dd
15:30:09 <rotaerk> "hard code the call stack of a GHC 8 error call in the test suite" but whyyy
15:30:25 <davean> Well, the test already existed before it
15:30:51 <davean> they made it compatible with the new exception - which seems to not have broken other code, maybe? If it did, it was in a different commit that that was fixed
15:31:17 <chessandgo> is it possible to have your cake and eat it too, when combining lenses and view pattern matching. I want to view pattern match on a section of a datastructure but also return an altered whole version of it with a lens
15:31:43 <chessandgo> Ive resorted to having the same arguement twice in my function
15:31:52 <chessandgo> one to view pattern match on and one to use lenses on
15:32:03 <davean> chessandgo: @
15:32:12 <chessandgo> what
15:32:17 <davean> use @
15:32:50 <davean> chessandgo: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
15:32:50 <lyxia> myfun s@(view l -> v) = dostuffwith s v
15:32:55 <davean> chessandgo: right in the report
15:32:58 <chessandgo> thanks
15:33:03 <chessandgo> "what is @ haskell" wasnt giving me any results
15:34:39 <davean> chessandgo: when wondering about Haskell language things, the report basicly always answers them
15:35:42 <hpc> most of the report is really easy to read
15:37:20 <rotaerk> davean, think I figured out the best fix
15:38:23 <davean> rotaerk: oh?
15:39:06 <rotaerk> looks like they originally just had the simple test of: expectError "error" (TestCase (error "error"))
15:39:33 <davean> Yes
15:39:34 <rotaerk> but then GHC 4.9.0.0 changed error to report a stack trace, and they added a new function called errorWithoutStackTrace
15:39:45 <davean> Yep
15:39:54 <rotaerk> so the correct fix is in 4.9.0.0+, use errorWithoutStackTrace, to get equivalent behavior
15:40:14 <davean> That seems reasonable - assuming that test isn't there to make sure HUnit it self works
15:40:25 <davean> which is unclear to me - I have no idea why they're testing that at all
15:40:45 <rotaerk> oh darn
15:40:55 <davean> which is what I was talking about before
15:41:03 <rotaerk> with profiling enabled, even errorWithoutStackTrace tacks on a profiling-related stack trace
15:41:12 <davean> How to make the test pass, yes, I agree with you on that approach, that part is easy
15:41:30 <davean> Why they test it at all though confuses me and makes me hesitent to suggest any given fix
15:41:40 <davean> because it doesn't seem to be a good test of anything, but EXACTLY how it serializes
15:41:43 <davean> which you can't rely on ...
15:41:53 <rotaerk> yea
15:42:21 <rotaerk> I suspect that the expectError itself is just a bad idea
15:42:31 <davean> So yah, my view is that test either could jsut be deleted, or theres something delicate and concerning in HUnit
15:42:35 <rotaerk> since it's specifically for testing the error against a serialized string
15:42:56 <rotaerk> the point of this is to test expectError is doing its job, but maybe expectError itself is just a bad idea
15:43:30 <davean> well if that was the case, you could possibly put a stack stripping function into expectError, but ...
15:43:32 <davean> yah
15:43:37 <davean> This seems problematic
15:43:48 <rotaerk> though I don't think I want to go and remove expectError itself ...
15:43:58 <rotaerk> I mean, I might be overstepping by doing so
15:44:18 <davean> rotaerk: ok, so why would one care how an error prints?
15:44:30 <davean> Either you can catch it and handle it as a type, in which case you're good
15:44:36 <rotaerk> I think tthe point is to build a unit test that tests that a certain error was thrown
15:44:38 <davean> or you care how it looks on the console, which that test can't test
15:44:48 <rotaerk> only how they test that is to compare the thrown error to the string
15:44:53 <davean> because theres an exception handler that could be changing how it prints
15:45:49 <davean> or maybe not print it at all but do something entirely different
15:46:08 <rotaerk> yea I don't think they care how it prints so much as they want to have a way to build a test that knows it was thrown
15:47:33 <davean> Well then would it be better to match on type?
15:48:24 <rotaerk> lemme see how expectError even works ... where's it getting the string from, to compare to the hardcoded string, in the first place
15:51:47 <rotaerk> https://github.com/Rotaerk/HUnit/blob/master/src/Test/HUnit/Lang.hs#L93
15:51:59 <rotaerk> there ... catches the exception and then shows itt
15:53:05 <chessandgo> is haskell actual magic
15:53:27 <chessandgo> The fact that the usage pattern of lenssing + view patterns is captured in a single character
15:53:44 <chessandgo> makes me feel like haskell was invented so we'd feel like wizards manipulating arcane symbols
15:55:21 <chessandgo> davean: thanks, I was able to integrate it into my code
15:55:37 <chessandgo> im a little disgruntled its called an "as pattern" and not an "at pattern"
15:57:07 <rotaerk> well, because it's named based on what it does, not the symbol that's used in the syntax
16:00:51 <rotaerk> although, I wonder if it should be considered a bug for GHC.Err.errorWithoutStackTrace to produce a stack trace when profiling is enabled
16:17:44 <Guest66317> Hey buds, got a quick question about lenses. How do I update nested records? Doing "rec ^. field1 . field2 .~ newField2Value" doesn't seem to work.
16:23:40 <dmj`> > (1,(1,1)) & (_2 . _2) %~ (+1)
16:23:42 <lambdabot>  (1,(1,2))
16:23:58 <davean> Guest66317: "^." means you want to get it, so what dmj` said
16:24:06 <davean> er, well
16:24:11 <dmj`> Guest66317: rec & (field1 . field2) .~ newFieldValue2
16:24:15 <davean> That returns the result also
16:24:59 <dmj`> > 1,(1,1)) & (_1 . _2) %~ (+1)
16:25:02 <lambdabot>  <hint>:1:2: error: parse error on input ‘,’
16:25:15 <Guest66317> I gotta say I don't quite get lenses yet, but hopefully it clicks soon. Thanks for the help davean dmj`
16:25:18 <dmj`> > (1,(1,1)) & (_1 . _2) %~ (+1)
16:25:20 <lambdabot>  error:
16:25:20 <lambdabot>      • No instance for (Field2 Integer () Integer Integer)
16:25:20 <lambdabot>          arising from a use of ‘e_1111121’
16:28:56 * hackage language-docker 4.0.0 - Dockerfile parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-docker-4.0.0 (lorenzo)
16:33:48 <dmj`> Guest66317: which part doesn’t make sense?
16:36:31 <Guest66317> dmj`: It's not that it doesn't make sense (although I probably wouldn't be to explain what's happening), but rather this intimidating sea of operators that connect to each other in ways that aren't intuitive yet to me.
16:38:52 <nikivi> Can you write iOS apps in haskell?
16:53:51 <dsal> Can anyone grade my benchmark real quick?
16:53:56 <dsal> https://www.irccloud.com/pastebin/kfPq7pid/bench.hs
16:54:24 <dsal> I'm disappointed to find that my new parser performs roughly the same as my old parser.  It's plausible, but I want to make sure I'm not doing something wrong.
17:24:26 * hackage language-docker 4.0.1 - Dockerfile parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-docker-4.0.1 (lorenzo)
17:27:56 * hackage sandi 0.4.2 - Data encoding library  https://hackage.haskell.org/package/sandi-0.4.2 (MagnusTherning)
17:34:44 <atchoum> hello, I would like to know if you have any idea of how and what is the pattern consisting of defining a function `foo a b = foo_ acc a b` where acc is an accumulator that start with a neutral value and foo_ is the actual algorithm doing the job ?
17:35:21 <davean> atchoum: wrapper?
17:35:28 <davean> I'm really not sure what you mean
17:35:50 <atchoum> I just thought of foldr as a convenient stuff for this
17:35:55 <MarcelineVQ> helper function
17:36:08 <atchoum> I mean yes but then foo has to be a higher order function I think.
17:37:13 <atchoum> say for example > let sum = foldr (+) 0
17:37:21 <atchoum> for a perfect example.
17:37:23 <zachk> helper function with an accumulator?
17:37:46 <atchoum> okay but I assume this is very common in haskell, isn't it ?
17:37:59 <atchoum> nevermind
17:38:08 <davean> I mean using functions defined with other functions is super common in Haskell?
17:38:25 <davean> I don't see anything special about this case
17:39:00 <ddellacosta> atchoum: it's common in all languages where recursion and higher-order functions are possible, but I suppose it's fair to say that Haskell makes it easy compared to some languages
17:39:07 <MarcelineVQ> that foldr example there is just normal function use.  I thought you meant the common case of something like  foo a b = gofoo 0 a b where gofoo 0 a b= a; gofoo _ a b = b;   you'd call gofoo a helper function here
17:39:30 <davean> atchoum: And in Haskell every time you apply an arguement you sorta get that via currying
17:40:25 <atchoum> davean: ha yes
17:40:31 <atchoum> I just discovering functional programming
17:41:20 <atchoum> I am writing a short article maybe you will like it.
17:41:25 <atchoum> I ll post it asap here
17:42:41 <Tuplanolla> There are ways to formalize this "destructuring starting from identity" thing you describe, but I doubt that is helpful in any way, atchoum.
17:42:54 <Tuplanolla> Not yet, at least.
17:43:49 <atchoum> Tuplanolla: interesting
17:43:57 <atchoum> why wouldn't you think it as helpful ?
17:45:21 <Tuplanolla> The same reason you don't think about the Gibbs free energy of your flour when baking a cake.
17:46:27 <`Guest00000> sounds cool
17:46:38 <rotaerk> davean, https://github.com/hspec/HUnit/issues/22#issuecomment-375936228
17:47:32 <atchoum> Tuplanolla: I am actually thinking this kind of things when I bake a cake.
17:48:10 <zachk> what's gibbs free energy?
17:48:16 <atchoum> well actually when the white of eggs goes solid and white, is that a phase transition ?
17:48:35 <zachk> that is from the protein congealing
17:48:41 <atchoum> Actually it is not a phase transition, just that the proteins are folding
17:48:45 <atchoum> zachk: yes.
17:49:49 <atchoum> but when you bake a cake.
17:49:56 <atchoum> is that protein congealing as well ?
17:50:05 <atchoum> nevermind i am probably hopeless.
17:51:17 <davean> rotaerk: I'm disapointed he WONTFIXed without explanation
17:51:22 <rotaerk> yea
17:51:53 <davean> rotaerk: I want to point out his twitter bio is "
17:51:55 <davean> Obsessed with software correctness."
17:51:58 <davean> but clearly he isn't ;)
17:52:20 <rotaerk> the consequence of this bug is that if your project depends on HUnit (directly or indirectly), you simply can't enable profiling *and* testing at the same time
17:52:34 <rotaerk> which seems like it'd be a not so insignificant bug
17:52:59 <Tuplanolla> If you insist, here is some reading, atchoum...
17:52:59 <Tuplanolla> @google general recursion in type theory
17:53:00 <lambdabot> https://link.springer.com/chapter/10.1007/3-540-39185-1_3
17:59:42 <davean> rotaerk: yah, the "indirectly" part is particualrly nasty - I stick to tasty generally (run into too many limits with HUnit alone) but now I've got issues from other people's choices
17:59:50 <davean> rotaerk: though one can work around it
18:00:19 <rotaerk> yea I encountered this issue when I added a dependency to "monad-loops", which uses tasty, which depends on HUnit
18:00:53 <rotaerk> I can work around it though, because I'm using nix and I can configure it to disable testing for just HUnit when I have profiling enabled
18:03:04 <ben`> hello?
18:03:41 <ben`> how is everyone?
18:06:28 <rotaerk> hi ben`
18:06:44 <atchoum> what do you use as an editor for haskell (or in general?)
18:07:45 <rotaerk> atchoum, I used to use vim; now I prefer using spacemacs in vim mode
18:09:03 <ben`> I've only just started with haskell, but I use emacs
18:09:11 <atchoum> you have a special plugin for haskell ?
18:09:25 <atchoum> oh my it's 3am already
18:09:30 <ben`> spacemacs is great for 'out of the box' emacs though, especcialy if you are good with vim
18:10:13 <atchoum> okay, it seems to be the way to go with haskell.
18:10:38 <ben`> atchoum: don't box yourself in though. A lot of the fun is in exploring
18:11:05 <ben`> find something that works for you. you might even use (gasp) eclipse!
18:11:14 <ben`> ;)
18:12:58 <ben`> Personally, I used to use vim, because as a text editor on a single file it is phenominally powerful. I moved to emacs when I wanted to have a more IDE workflow. Vim can do that, but the architecture to make that happen didn't mesh will with me
18:13:50 <ben`> Emacs, I gave a try. At first it's a major PITA, but its architecture is very well suited to putting together an IDE workflow that works for you.
18:14:06 <ben`> any questions?
18:15:10 <ben`> anyone here have any suggestions on building a Haskell workflow for emacs?
18:15:38 <atchoum> I am looking for an IDE workflow actually with emacs.
18:15:40 <sm> haskell-mode in one window, ghcid in another
18:15:43 <atchoum> i MEAN WITH HASKELL
18:15:46 <atchoum> sorry
18:15:48 <atchoum> caps lock
18:16:05 <atchoum> I really am not a vim power user.
18:16:38 <atchoum> And I never used emacs but maybe I should give it a try. I am mostly coding with python at work, and the IDE is suiting me particularly well.
18:17:03 <rotaerk> the thing I liked about spacemacs is that it just worked nicely out of the box, and was easy to configure for haskell development
18:17:08 <sm> if you're using pycharm, you might like IDEA for haskell
18:17:16 <atchoum> that exists ?
18:17:25 <atchoum> never heard of
18:17:48 <rotaerk> I'm not a fan of building up a custom configuration for my editors; too time consuming and microoptimize-y
18:18:09 <rotaerk> I want a ready-made solution, and spacemacs was the closest I got, for haskell dev
18:18:11 <atchoum> that's why I like IDE
18:18:15 <ben`> so ghci-script-mode?
18:34:30 <davean> benzrf: I think we can all agree that while there isn't a right answer, eclipse is definately the wrong answer ;)
18:34:45 <davean> er, that was to ben`
18:36:03 <rotaerk> ^
18:36:20 <zachk> atchoum, I use sublime text with sublime haskell , works ok , used to use vim
18:37:13 <davean> "There are no right answers but there is an exactly wrong answer. That answer is and always will be "Eclipse""
18:39:39 <davean> Eclipse is the application that taught me that UI standards for responsiveness were entirely BS, and also that a response so slow that I thought the system had locked up was soemtiems fast enough other people didn't notice it.
18:40:41 <zachk> intellij was kind of slow until I installed their custom jre
18:40:53 <zachk> still kinda slow though
18:41:35 <zachk> and spotify seems to lag horribly if I am running neo4j desktop edition
18:41:58 <zachk> I mostly blame all that stuff being java/jvm
19:03:16 <ooo_miguel> I wonder if it is fine if I install cabal-install to my sandbox and then put its ./bin on the path in order to use the newest cabal version there?
19:04:42 <ooo_miguel> running it with "cabal exec -- cabal" seems strange to me
19:14:56 * hackage streamly 0.1.2 - Beautiful Streaming, Concurrent and Reactive Composition  https://hackage.haskell.org/package/streamly-0.1.2 (harendra)
19:37:56 * hackage netwire 5.0.3 - Functional reactive programming library  https://hackage.haskell.org/package/netwire-5.0.3 (esz)
20:33:56 * hackage hspec-dirstream 1.0.0.0 - Helper functions to simplify adding integration tests.  https://hackage.haskell.org/package/hspec-dirstream-1.0.0.0 (vmchale)
20:37:01 <koz_> I have two functions: both :: (a -> b) -> (a,a) -> (b,b) and both2 :: (a -> b -> c) -> (a,a) -> (b,b) -> (c,c). Their definitions looks very similar, and I was wondering if there was a way to write both2 in terms of both?
20:40:20 <theobromine> so i am a noob and barely know haskell, but maybe you can answer my question anyway... i was under the impression that haskell and haskell-like languages "required" a GC... but then i found this https://github.com/andyarvanitis/purescript-native, which compiles purescript to C++ with GC merely optional, and it says that somehow the purescript compiles down to some kind of RAII code
20:41:05 <koz_> theobromine: You can use refcounting instead of a GC - they fulfil the same needs.
20:41:30 <typedrat> you need automatic memory management
20:42:05 <theobromine> but i was under the impression that refcounting doesn't have "GC pauses" and the like...?
20:42:29 <koz_> theobromine: Refcounting doesn't have GC pauses. However, GC can be faster than it.
20:42:42 <koz_> Refcounting's main advantage is determinism.
20:43:09 <theobromine> is there an option to use refcounting for haskell memory management?
20:43:25 <koz_> theobromine: Not to my knowledge. However, I have to ask why you need this.
20:43:31 <koz_> Or more exactly, why you _think_ you need this.
20:44:03 <theobromine> sometimes i like writing code with latency requirements, such as audio processing or control systems
20:44:13 <theobromine> *realtime audio processing
20:45:09 <koz_> In that case, I'll yield to someone in the audience who actually knows about these things and what Haskell can and can't do there. :P
20:45:17 <koz_> (I don't even _pretend_ to understand these things)
20:46:12 <theobromine> i also have a weird intermittent fascination with memory management
20:46:26 * hackage aws-easy 0.1.0.1 - Helper function and types for working with amazonka  https://hackage.haskell.org/package/aws-easy-0.1.0.1 (rcook)
20:46:31 <koz_> I had a phase like that too.
20:46:43 <koz_> Memory allocators too - found some curious papers on the subject.
20:46:44 <theobromine> but now?
20:47:03 <koz_> I basically realized that my work doesn't really need this kinda knowledge, and it was only a very passing interest.
20:47:29 <theobromine> but yeah it would be pretty sweet if i could write in say, purescript, and not have latency spikes, even with lower throughput
20:47:54 <koz_> Well, if Purescript compiles to C++ without GC, then... you can?
20:48:06 <theobromine> right, that's the surprising thing :P
20:48:39 <koz_> I dunno about Purescript though - maybe someone else who does could chime in about that.
21:09:56 * hackage aws-ses-easy 0.0.0 - Wrapper over Amazonka's SES  https://hackage.haskell.org/package/aws-ses-easy-0.0.0 (jxv)
21:11:31 <exio4> theobromine: ref-counting seems pretty bad for haskell
21:11:54 <exio4> theobromine: specially considering haskell's semantics allow many kinds of loops which would make ref counting useless
21:13:26 * hackage aws-ses-easy 0.1.0 - Wrapper over Amazonka's SES  https://hackage.haskell.org/package/aws-ses-easy-0.1.0 (jxv)
21:25:12 <typedrat> exio4: do you mean loops or cycles?
21:25:55 <chessandgo> are view patterns the only way to pattern match against bytestrings? I cant seem to find any other methods of doing it
21:27:32 <exio4> typedrat: a cycle, is a cycle not a loop? :)
21:34:34 <theobromine> exio4: hm ok
21:35:17 <typedrat> yeah, thinking about it more i can't realize what i was thinking of before
21:35:25 <typedrat> but i have a strong memory of non-GC options
21:37:06 <exio4> chessandgo: you cannot pattern match against bytestrings, exactly! (ViewPatterns are simply way to "augment" pattern matching syntax with function calls)
21:37:10 <typedrat> but then again I am often wrong
21:39:47 <chessandgo> exio4: than what should be done?
21:40:14 <chessandgo> also does OverLoadedStrings impact this, I could have sworn you couldnt use case with bytestring but I just attempted it and it worked
22:00:27 * hackage google-oauth2-easy 0.0.0 - Opininated use of Google Authentication for ease  https://hackage.haskell.org/package/google-oauth2-easy-0.0.0 (jxv)
22:22:26 * hackage dhall-lex 0.1.0.0 - Lexer for the Dhall language  https://hackage.haskell.org/package/dhall-lex-0.1.0.0 (vmchale)
22:39:56 * hackage dhall-lex 0.1.0.1 - Lexer for the Dhall language  https://hackage.haskell.org/package/dhall-lex-0.1.0.1 (vmchale)
22:41:09 <EvanR> so lets say you have a function from non negative Int to A. if you implement it as a top level lazy list of A, then it will sort of memoize after you access higher and higher Int
22:41:31 <EvanR> but lookups will be O(n). how do you get the same effect but implement it as IntMap
22:41:47 <koz_> I wanna use a recursion scheme (specifically an anamorphism), but I need a monadic action at each step of the unfold.
22:42:01 <koz_> So the idea is that the final result gets returned in the same monad as these actions.
22:42:07 <koz_> What (if anything) should I use for this?
22:45:27 * hackage monad-logger 0.3.28.3 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.28.3 (MichaelSnoyman)
22:49:58 <nshepperd> EvanR: dunno if IntMap supports this per se. `memoize` package builds a binary tree of all ints, over which you then fmap your function
22:50:57 <EvanR> oh nice
22:57:37 <nshepperd> the code's pretty short and readable https://hackage.haskell.org/package/memoize-0.8.1/docs/src/Data.Function.Memoize.html#line-276
23:04:59 <nshepperd> apart from the rather bizarre trick where theFinites doesn't have any conditional to terminate the recursion but instead btLeft and btRight are filled with nonsense at the point the recursion would have stopped (that is never forced or used in any way so it dosn't matter)
23:06:21 <nshepperd> anyway that works for Integer too (basically using binary, left child = 2*x, right child = 2*x + 1), so you can memoize any function from integers with O(log n) lookup
23:18:16 <marmistrz> Is it possible to check two instances of a variant type for variant equality, e.g.
23:18:16 <marmistrz>  data Tree a = Branch (Tree a) (Tree a) | Leaf a
23:18:31 <marmistrz> if x :: Tree, y :: Tree
23:19:04 <marmistrz> I want to know if they are *both* Branch or *both* Leafs
23:19:44 <marmistrz> I could write an explicit match function, but my variant type has ~6 variants, so it's ugly
23:22:40 <exio4> marmistrz: what do you mean?
23:22:47 <koz_> I wanna use a recursion scheme (specifically an anamorphism), but I need a monadic action at each step of the unfold.
23:22:49 <koz_> So the idea is that the final result gets returned in the same monad as these actions.
23:22:51 <koz_> What (if anything) should I use for this?
23:23:21 <exio4> marmistrz: you want to know if they are the same structure?
23:23:56 <koz_> marmistrz: https://stackoverflow.com/a/25587871/2629787
23:24:06 <exio4> marmistrz: or do you just want an equality comparison?
23:24:07 <koz_> Assuming you don't mind a lens dep.
23:28:47 <cocreature> koz_: I think you can just put the monadic functions in your algebra?
23:29:02 <koz_> cocreature: I just realized that.
23:29:19 <koz_> It took me a while to click, but it means your base functor needs to actually be a base Traversable I think.
23:29:37 <cocreature> yeah that seems likely
23:29:45 <koz_> So I'm busy defining that.
23:30:06 <cocreature> you can just derive Traversable in most cases
23:30:32 <koz_> cocreature: Yeah, I should probably do that instead.
23:31:10 <cocreature> ofc defining it for learning purposes is a nice exercise but apart from that deriving us just way too convenient :)
23:31:19 <marmistrz> exio4, foo (Tree) (Tree) = True
23:31:27 <marmistrz> foo (Leaf) (Leaf) = True
23:31:29 <marmistrz> false otherwise
23:31:51 <marmistrz> e.g. foo (Leaf 4) (Leaf 6) = True
23:32:23 <marmistrz> and I have ~ 6 variants in my type so writing all those matches by hand is not such a good idea
23:34:38 <koz_> marmistrz: Checked my link? That seems exactly what you need.
23:35:57 <cocreature> koz_: I don’t think so. your link applies prisms to a single argument. the goal of marmistrz seems to be to check if the constructors of the two arguments match
23:36:41 <cocreature> marmistrz: An easy solution is to derive Data for your type and apply toConstr to both sides and then compare those
23:36:43 <koz_> Ah, I see why that wouldn't work. Whoops.
23:37:11 <cocreature> alternatively TH or generics
23:40:44 <koz_> cocreature: Quick sanity check - anaM :: (Traversable (Base t), Corecursive t, Monad m) => (a -> m (RS.Base t a)) -> a -> m t ?
23:41:15 <koz_> Does that seem like the right signature for such a helper?
23:41:49 <koz_> (ignore that RS there, sorry, using a qualified import)
23:42:18 <cocreature> koz_: looks at least plausible but I don’t use recursion schemes so I might very well be missing something here :)
23:42:36 <koz_> cocreature: OK, good to know. I'm basically trying to think through it properly. I might even blog about it.
23:43:44 <cocreature> recursion schemes are one of those things that seems really nice in theory but in practise, I’ve found that they rarely actually seem to help me
