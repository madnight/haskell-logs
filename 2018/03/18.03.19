00:00:03 <cocreature> dminuoso: really you should just stop what you’re doing and consider your life choices that got you to the point where you need incoherent instances :)
00:02:15 <Rembane> dminuoso: Something something dark side...
00:03:13 <Thomas_> lambdabot> > sum [1..10]
00:03:29 <dminuoso> cocreature: It was merely interest. I blame edward, his constraints library made me want to understand things about typeclasses. =P
00:05:58 <cocreature> I’m not sure I’ve ever seen a good usecase for IncoherentInstances that couldn’t be solved better in another way
00:12:12 <EvanR> i dont even know what that does. the label on the tin doesnt sound appetizing
00:13:33 <dminuoso> What's the sense of the word "incoherent" in that anyway? What coherence is this lacking?
00:14:23 <cocreature> GHC might choose different instances for the same type in different places in your program
00:17:50 <EvanR> how is that useful?
00:24:27 <cocreature> theoretically you could have something like "class C a b where …; instance C Int b where …; instance C a Int where …". if GHC needs to find an instance for "C Int Int" it will fail without incoherent instances. with incoherent instances it will choose one arbitrarily so if you know the instances agree for "C Int Int" then you don’t care which one it chooses
00:24:41 <cocreature> but as I’ve mentioned, I’ve yet to see an actual usecase for this
00:25:26 <EvanR> ive got it, instance selection plugins
00:25:56 <EvanR> program your own incoherent stuff, dont wait for GHC to release a feature
00:27:49 <Eduard_Munteanu> Maybe it's not useful in itself, like you don't really intend the compiler to pick different instances, it just happens.
00:28:49 <dminuoso> cocreature: Interesting, so if the behavior of the different instances is not extensionally equivalent, it allows for inconsistent programs..
00:30:20 <EvanR> it calls into question how you think multiparam type classes are supposed to work
00:30:44 <EvanR> other than "quite nicely please"
00:31:01 <cocreature> “like I intended them to work”
00:34:22 <dminuoso> EvanR: Is that possibly part of the reason why MultiParamTypeClasses were not part of the 98 or 2010 standard?
00:35:17 <EvanR> they make sense to me
00:35:35 <EvanR> only after doing 3 years of research into formal logic
00:35:59 <guessWHo> please suggest a logging lib for haskell which can work with STM, TChan etc
00:36:32 <EvanR> but when type classes were invented and encoded into standard haskell, they were a cool hack to make + work
00:44:46 <tdammers> so much for perspective: a feature that is considered academic and too abstract in most other language is seen as a hack in Haskell :x
00:45:22 <Rembane> tdammers: This made me curious. Which feature?
00:45:29 <tdammers> Rembane: typeclasses
00:46:06 <Rembane> tdammers: Oh. I see it as a very pragmatic solution. And also a hack. Which was the other language? Elm?
00:46:06 <muesli4> Hi, is there something with kind (* -> *) that behaves like `id` on values and that I can pass to type constructors? I want something like `data Foo f = Foo (f Int)` and then `Foo Maybe` and `Foo Id`.
00:46:50 <muesli4> (Of course I could wrap it in a newtype.)
00:47:11 <Rembane> muesli4: Maybe you want an existential type.
00:48:54 <muesli4> Rembane: I'm not sure whether I want to define a type class just for that.
00:50:07 <Rembane> muesli4: You don't need a typeclass for existential types. You just need some extra types. For instance: data Obj = forall a. (Show a) => Obj a
00:50:14 <guessWHo> can we write do inside where >?
00:50:22 <Rembane> muesli4: ...example gotten from the Haskell wiki. https://wiki.haskell.org/Existential_type
00:50:34 <Rembane> guessWHo: Yes!
00:50:50 <muesli4> Rembane: What about `Show` in your example? I mean you need something that the type can do.
00:51:11 <frerich> @faq
00:51:11 <lambdabot> https://wiki.haskell.org/FAQ
00:51:43 <Rembane> muesli4: We promise that it can show something. That's all we promise. Otherwise we don't know and don't care. This is the whole example: https://wiki.haskell.org/Existential_type#A_short_example
00:52:06 <fakenullie> muesli4: Identity a?
00:52:25 <cocreature> muesli4: sounds like you want to use a type family as a type parameter for a type constructor which isn’t possible
00:52:33 <muesli4> fakenullie: That's possible. Although I will have to wrap/unwrap/coerce.
00:52:50 <muesli4> cocreature: That's what I tried.
00:53:35 <muesli4> Rembane: Yes, I have to promise that I can do something (i.e. use a type class). Otherwise I can do nothing.
00:53:45 <dminuoso> muesli4: For your original question
00:53:47 <dminuoso> :k Identity
00:53:50 <lambdabot> * -> *
00:54:17 <dminuoso> =P
00:54:19 <fakenullie> I think what he wants is to get Foo Int
00:55:15 <muesli4> Well, I guess I'll go with Identity then. Thanks to all of you.
00:57:53 <guessWHo> dminuoso : sorry for repeating but any suggestion for logging library for haskell which is ideal to work with STM, TChan etc
00:58:59 <dminuoso> muesli4: Note that it only behaves as id wrt to Functor/Applicative/Monad
01:00:20 <muesli4> dminuoso: In what other respect does it not behave like id (minus wrap/unwrap)?
01:00:47 <tdammers> guessWHo: have you tried searching hackage for 'logging'?
01:01:40 <fakenullie> Identity does not need unwrapping for those
01:02:39 <Axman6> guessWHo: do you mean using a TChan to send log messages to?
01:04:45 <Axman6> I don't know of any which explicitly do that but making a simple wrapper around another logging library wouldn't be hard - just fork a thread to read from the TChan and pass the TChan (or a function which accepts log messages and hides the details of logging and closes over the TChan) to other thread which need to do logging
01:05:11 <Axman6> fast-logger does something similar to this
01:05:30 <tdammers> yeah, in fact I've done something similar myself, it's really straightforward
01:06:29 <guessWHo> Axman6 : i have couple of TChans which i'm writing and reading from but when i print the contents of it on screen they often get jumbled up so i was thinking maybe a logging lib  will help
01:07:13 <vaibhavsagar> guessWho: have you seen concurrent-output?
01:07:18 <tdammers> guessWHo: then your problem isn't so much the TChans, but rather writing to the console from multiple threads
01:07:29 <vaibhavsagar> guessWho: https://hackage.haskell.org/package/concurrent-output
01:08:00 <dminuoso> muesli4: Consider Category. `id` only makes sense within a given category.
01:09:24 <dminuoso> muesli4: `id` does not behave as an identity in a kleisli category.
01:10:02 <Axman6> eh?
01:10:17 <muesli4> dminuoso: I see.
01:10:19 <Axman6> id in kleisli = return no?
01:10:23 <dminuoso> Axman6: Yes.
01:16:06 <guessWHo> vaibhavsagar : https://hackage.haskell.org/package/logger i want to use this but getting errors when i try to install with stack project
01:17:42 <guessWHo> vaibhavsagar : here's the error http://lpaste.net/363788 and yeah it doesn't work even when i add logger to my extra deps
01:19:55 <Axman6> guessWHo: did you read the error message?
01:20:14 <Axman6> the first recommendation will probably solve your problem
01:20:36 <Axman6> step 1 when asking for help with an error: read the error
01:20:58 <dminuoso> step 2 try and understand the error.
01:23:21 <guessWHo> dminuoso : step 0 , read complete question , i tried both stack solver & putting logger in extra dep in stack.yaml
01:24:21 <Axman6> what did you actually do to put logger in the extra-dep section?
01:24:35 <Axman6> and what error did you receive at that point?
01:25:37 <guessWHo> Axman6 : i put it in my stack.yaml after that it suggest putting two more package in stack.yaml which i did extra-deps: ["logger-0.1.0.2","base-4.8.2.0","unagi-chan-0.4.1.0"]
01:25:54 <Axman6> uh, yeah changing base is not going to be a good idea
01:26:06 <Axman6> since it is linked to GHC's version
01:26:13 <guessWHo> Axman6 : exactly
01:26:45 <Axman6> maybe try a different logging library, one which is included in the LTS version your project is using
01:26:59 <Axman6> there are plenty to choose from
01:27:20 <guessWHo> Axman6 : this one is good & has good documentation
01:27:33 <guessWHo> Axman6 : can you suggest one
01:27:37 <dminuoso> guessWHo: And its obsolte and has not been maintained for 3 years.
01:27:39 <Axman6> well they you might need to find a different LTS
01:28:10 <guessWHo> dminuoso : i understand that , so any suggestion >??
01:28:56 <vaibhavsagar> guessWHo: https://hackage.haskell.org/package/fast-logger
01:29:02 <guessWHo> dminuoso : preferably one where i don't have to write instance  for TChan and stuff :P
01:29:39 <Axman6> uh, fast-logger is not a great suggestion, it's API is painful to use
01:29:46 <vaibhavsagar> guessWHo: https://hackage.haskell.org/package/heavy-logger
01:30:01 <vaibhavsagar> I've never used any of these libraries :)
01:30:10 <EvanR> haha
01:30:18 <Axman6> there are other libraries which wrap fast-logger though
01:30:29 <EvanR> all the loggers together form a team fortress team
01:30:34 <vaibhavsagar> yeah, heavy-logger is one of those
01:30:54 <EvanR> all you need now is a long-range-logger
01:31:00 <Axman6> if you go to https://www.stackage.org/lts-11.1/package/fast-logger-2.4.11 you can see all the libraries which depend on it
01:31:07 <dminuoso> EvanR: https://xkcd.com/927/ ;)
01:32:00 <guessWHo> what about hslogger and https://hackage.haskell.org/package/log-warper
01:33:35 <Axman6> for some reason, logging is something that we don't seem to have any good libraries for in Haskell, it really frustrates me
01:34:42 <Axman6> heavey-logger looks reasonable though (though it's not on stackage)
01:34:44 <guessWHo> Axman6 : while searching for logging lib i came across a medium post about rust saying don't be another haskell and one of the reason was absense of a standard logging lib
01:35:26 <guessWHo> Axman6 : that mean i can't use it directly by putting it in my package.yaml ????
01:36:39 <guessWHo> Also guys how to use do inside where ??
01:37:48 <vaibhavsagar> guessWHo: foo where bar = do ...
01:38:20 <vaibhavsagar> if you're having indentation issues, just indent one more level for the body of the do block and see if that fixes it
01:46:26 <ertes-w> ello
01:48:45 <vaibhavsagar> hi there ertes-w
02:02:09 <Thomas_> Hi
02:02:28 <Thomas_> > 1 + 2
02:02:31 <lambdabot>  3
02:07:16 <liste> hi Thomas_
02:27:53 <merijn> Does anyone know why cassava uses ByteString rather than Text for input?
02:28:27 <frerich> Sometimes I'm faced with a challenge and then I get really happen when I realize that I might have a good opportunity to use certain packages. 'aeson', 'brick' and 'fgl' are like that. I also have that with C (I'm still longing for a good problem to solve which lets me use 'sendfile' ;-).
02:30:09 <merijn> frerich: You're forgetting: binary, conduit/pipes, async, (mega/atto)parsec, optparse-applicative :p
02:30:25 <frerich> merijn: Oh, async, yes! That's certainly on my list, too.
02:31:12 <merijn> frerich: The others I listed are so good they, frankly, make comparable tools in all other languages I've tried look like utter embarassments
02:34:06 <tdammers> merijn: my guess would be because character encodings are notoriously undefined in CSV
02:34:47 <tdammers> (still kind of inconvenient though when it comes to UTF-16 / UTF-32)
02:35:44 <tdammers> hmm, I use async, (mega)parsec and aeson all the time
02:36:07 <merijn> tdammers: Yeah, I know, I'm trying to figure out whether it's worth adding an issue for the problem I ran into this weekend
02:36:45 <merijn> tdammers: Which is: The lack of unicode support means it treats byte-order marks as part of the first column messing up name based parsing
02:36:46 <tdammers> IMO, the sane thing for CSV would be to take Text input after all, and leave character encoding issues to the API consumer
02:36:58 <tdammers> hmm, that sounds wrong
02:37:09 <tdammers> but then, nothing about CSV is sane
02:37:38 <merijn> This was my girlfriend's first "real" code to do something useful and it didn't work. Took me 3 hours to figure out Excel outputs CSV with a byte-order mark, even when outputting utf-8 >.>
02:37:49 <tdammers> CSV is one of those things that are beautifully simple and elegant as long as you ignore the not-super-obvious complexity
02:37:58 <merijn> Also, while on the topic: I hope whoever came up with a BOM for utf-8 gets sodomised by a donkey
02:38:19 <[exa]> BOM for utf8, like, really?!
02:38:50 <[exa]> that deserves inquisition.
02:39:34 <merijn> [exa]: Yes
02:41:03 <[exa]> "Hi, I'm a self-referentially nonsential piece of binary ballast in your file"
02:41:31 <merijn> [exa]: "applications can use it to verify text is utf-8 rather than some unknown mystery encoding"
02:41:38 <[exa]> Mr. Clippy: "Having trouble removing the UTF-8 BOM?"
02:41:51 <merijn> To which I say: Burn the non-UTF-8 heretics
02:42:22 <[exa]> merijn: let's invent an encoding that accidentally produces UTF8 BOM as a first character
02:44:09 <Boarders_> does anyone know where is the Identity monad defined?
02:44:34 <Boarders_> I came across this: https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Identity.html
02:44:45 <dminuoso> Boarders_: Control.Monad.Identity
02:44:50 <Boarders_> ok thanks
02:44:56 <Boarders_> that page is a bit lacklustre
02:44:58 <cocreature> no it’s defined in Data.Functor.Identity
02:45:00 <[exa]> Boarders_: Data.Functor.Identity
02:45:03 <dminuoso> Oh sorry!
02:45:35 <[exa]> Boarders_: btw you can use :i Identity in ghci (at least here it also prints where the instances are defined)
02:45:36 <dminuoso> I was just thinking that Control.Monad.Identity reexports that name.
02:46:13 <Boarders_> thanks!
02:55:41 <muesli4> Is there something easy I can use to get a Show instance for something like `data Foo f = Foo (f Int)`. I saw something about lifted type classes (`Show1`) somewhere but fail to find it now.
02:59:39 <cocreature> muesli4: https://hoogle.haskell.org/?hoogle=Show1
03:01:59 <cocreature> muesli4: but you don’t need that here. you can also make an instance for "Show (f Int) => Show (Foo f)" (manually or using StandaloneDeriving)
03:04:49 <muesli4> cocreature: The type I pass to f is actually a bit more complex. Then I would have to use UndecidableInstances.
03:05:17 <muesli4> I'm not sure whether that's a good idea.
03:05:18 <cocreature> sure but UndecidableInstances should be fine here
03:06:04 <dminuoso> muesli4: The question is merely if you have the ability to define: instance (Show1 f) => Show1 (T f)
03:06:13 <dminuoso> T being your Foo.
03:06:18 <cocreature> UndecidableInstances is not as bad as the name might suggest. GHC’s termination checker for instances is pretty dumb and UndecidableInstances just shuts it off
03:06:40 <cocreature> in the worst case that will lead to an infinite loop at compile time
03:07:00 <muesli4> dminuoso: As a matter of fact both of the type constructors I want to use already have a Show1 instance.
03:07:12 <cocreature> dminuoso: that’s a kind error
03:07:47 <muesli4> Yes I want to define a Show instance with a Show1 instance.
03:09:11 <dminuoso> cocreature: How is that?
03:09:28 <cocreature> dminuoso: Show1 expects something of kind * -> *, Foo f has kind *
03:10:08 <dminuoso> cocreature: Oh shoot you are right.
03:34:58 <mkloczko> Hi, I have a problem with type funs and higher order functions - I'd like to compose type funs, but I get a problem with inside functions not being kind * (it is a -> b).
03:35:35 <merijn> mkloczko: Can you lpaste an example of what you're trying to do?
03:35:50 <mkloczko> merijn: sure - http://lpaste.net/363794
03:37:38 <merijn> mkloczko: Ah, yeah, pretty sure partially applied type families are not allowed
03:38:23 <mkloczko> :/
03:38:41 <dminuoso> mkloczko: You can use defunctionalization
03:38:48 <merijn> mkloczko: Because that tends to make type-checking undecidable
03:39:42 <mkloczko> merijn: I just wonder why does kind! work it out
03:39:55 <mkloczko> dminuoso: defunctionalization ?
03:41:17 <mkloczko> dminuoso: ok, got it, thanks!
03:41:55 <mkloczko> merijn: and thanks for explaining the problem!
03:42:28 <dminuoso> mkloczko: type family Apply (f :: k1 -> k2) (a :: k1) :: k2
03:43:02 <dminuoso> (As a starting point)
03:51:53 <reactormonk> What's a lens pointing to a Maybe? A Traversal, or a Prism?
03:52:34 <Axman6> do you mean focusing on the a in a Maybe a?
03:53:07 <Axman6> technically prisms are a subset of traversals, so something pointing to the a is either a lens or a prism
03:53:13 <Axman6> :t _Just
03:53:16 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
03:53:27 <Axman6> (that says Prism (Maybe a) a)
03:53:44 <Axman6> :t traverse
03:53:46 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
03:53:46 <lyxia> do you mean something of type  Lens' s (Maybe x)
03:54:09 <Axman6> something which focuses on a Maybe isn't anything special
03:54:26 <Axman6> it can be a lens, a prism, traversal, setter, getter
03:55:16 <Axman6> reactormonk: poke
03:59:09 <robstr> What is the way to combine json `Values` from Aeson ?
03:59:23 <merijn> Combine in what way?
04:00:33 <robstr> merijn: whoop, my fault
04:01:08 <joncol> I have the following function: notify :: Exception.Exception e => ApiKey -> String -> e -> Wai.Request -> IO ()
04:02:01 <joncol> ...And I want to declare a convenience type for it. But I cannot use type constraints then, can I? Is there some way around it?
04:02:50 <lyxia> you can with RankNTypes
04:05:13 <lyxia> But I'd just write something like  notify :: Exception e => NotifyApp e
04:06:16 <joncol> OK, and would NotifyApp be a `type` or a `data`?
04:06:22 <lyxia> type
04:06:44 <lyxia> type NotifyApp e = ApiKey -> String -> e -> Wai.Request -> IO ()
04:07:14 <joncol> Nice, thanks
04:07:28 <lyxia> Although there might be something better to do depending on what the other functions look like. Pulling e out of the synonym for example.
04:08:38 <AWizzArd> Intero – my Emacs is reacting very slow. For example moving the cursor can sometimes take half a second before I see a reaction. I reckon that some kind of even is being fired on each key press and analyzed first.
04:08:50 <AWizzArd> Can this be configured?
04:25:03 <michalrus> AWizzArd: did you try Haskell IDE Engine with lsp-mode? They work very well for me.
04:25:40 <michalrus> (Very well and asynchonously. HIE’s the future!)
04:26:04 <michalrus> Is there any way to do this in one line? `instance Generic (SomeDataFamily a) => ToJSON (SomeDataFamily a)`
04:27:13 <guessWHo> what is TH in context of haskell for eg TH logging >?
04:28:23 <guessWHo> merijn : can you please help me with this function "runStderrLoggingT :: MonadIO m => LoggingT m a -> m a"
04:28:36 <cocreature> guessWHo: template haskell
04:29:01 <guessWHo> cocreature : and what's that >?
04:29:26 <cocreature> compile-time metaprogramming
04:30:11 <guessWHo> cocreature : okay i can read mroe abou that but can you please help with this function "runStderrLoggingT :: MonadIO m => LoggingT m a -> m a"
04:30:17 <dsdg> what is this sytax (forall m c a.) in this code https://github.com/haskell-crypto/cryptonite/blob/master/Crypto/Tutorial.hs
04:30:20 <michalrus> Orrrr… can I require in a in-class data family declaration that its instances are of some class?
04:31:53 <cocreature> guessWHo: you’ll need to provide a bit more context? are you trying to write this function or do you want to use it? what exactly is causing problems?
04:32:17 <guessWHo> cocreature : i'm using it from this lib https://hackage.haskell.org/package/monad-logger-0.3.28.2/docs/Control-Monad-Logger.html#t:LoggingT
04:32:57 <guessWHo> cocreature : since i'm not yet comfortable with monads couldn't wrap my head around the arguments
04:36:26 <cocreature> guessWHo: LoggingT is a monad transformer that adds logging capabilities on top of an existing monad. runStderrLoggingT takes something of type "LoggingT m a" which is a computation in "m a" with added logging capabilities and provides a logging implementation which writes to stderr. so it gives you back an "m a" which will write all log statements to stderr
04:39:05 <guessWHo> cocreature : if it's not too much to ask can you please provide an example cause i couldn't find one anywhere else
04:40:24 <cocreature> something like "runStderrLoggingT (logDebugN "your log message here") :: IO ()"::
04:40:32 <cocreature> eh remove the last double colon
04:41:27 <statusbot> Maintenance update: Shutting down now... -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5aafa160c6fcb7046e959de9
04:43:38 <guessWHo> cocreature : but it's simple printing i'm not performing any computation here ??
04:43:54 <cocreature> right
04:44:22 <cocreature> guessWHo: if you want to do other stuff, you can use liftIO to get from "IO a" to "LoggingT IO a"
04:45:09 <cocreature> so something like "do logDebugN "starting db insertion"; liftIO insertIntoDB; logDebugN "finished db insertion""
04:47:00 <lseactuary> hi - i can't seem to figure out what is wrong with my code. it compiles and gives the right picture for when I use N/S/E/W compass points, but just a straight line when I use polar co-ordinates. i have tested each function, and i have a feeling its the final function or makePolyline that is the issue, but cannot see the reason why. can someone please help?
04:47:00 <lseactuary> https://gist.github.com/anonymous/640a955a1fa21e880dfc8b6e6ae56bb4
04:50:42 <statusbot> Maintenance update: Hackage up & running again; thanks for your patience -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5aafa160c6fcb7046e959de9
04:52:40 <merijn> Anyone here use cabal.project combined with freeze files? If so, what do those look like?
04:53:16 <guessWHo> cocreature : i did that but i got errors http://lpaste.net/363796
04:53:24 <Putonlalla> Is it possible to introduce variables in type instances? That is, `type instance Universal (S n) a = forall c. Universal n (c -> a)`.
04:56:39 <phadej> Putonlalla: nope
04:56:52 <phadej> merijn: try cabal new-freeze, you'll see
04:57:03 <Putonlalla> What a shame.
04:57:05 <phadej> merijn: in short, they are just a subset of cabal.project syntax
04:57:26 <AWizzArd> michalrus: would that be independend of Intero? Or is this something that one combines with it?
05:00:10 <cocreature> guessWHo: step 1 for debugging type errors should always be to add type annotations to at least all top-level bindings
05:00:15 <merijn> phadej: See also my comments in #hackage :)
05:00:59 <cocreature> guessWHo: the problem in this case is that logDemo is of type "LoggingT IO ()" but you’re trying to use it in "main" which has type "IO ()"
05:01:11 <cocreature> guessWHo: you need to wrap it in runStderrLoggingT
05:02:06 <michalrus> AWizzArd: I’m not sure, I think HIE plans on reusing some of Intero’s GHCi, but from your perspective it’s not important.
05:02:19 <michalrus> AWizzArd: it’s an LSP server which can talk to LSP-enable editors (including Emacs).
05:02:26 <michalrus> *enabled
05:03:37 <guessWHo> cocreature : okay, that worked , how does it work i mean what are those monad transformers and what's happening under the hood
05:04:12 <cocreature> guessWHo: sry I don’t have time to go into that right now. the short story is that LoggingT is basically a ReaderT that stores a logging function
05:04:20 <cocreature> I’m sure someone else can expand upon that
05:05:45 <guessWHo> cocreature : okay, thank you so much
05:13:02 <ffledgling> Hello, I'm trying to compile ghc from source, but it seems like I already need ghc installed to be able to compile ghc from source?
05:13:11 <ffledgling> Is that strictly necessary?
05:14:46 <ertes-w> guessWHo: do you understand the Maybe monad?
05:14:46 <michalrus> ffledgling: yes. =) https://en.wikipedia.org/wiki/Bootstrapping_(compilers)
05:15:18 <michalrus> ffledgling: there’s some effort in Guix to bootstrap GHC from 0, you can Google® that.
05:16:14 <michalrus> Other than that you just have to trust that no backdoors are planted in your compilers. (ﾉ^_^)ﾉ
05:16:28 <phadej> merijn: I'm not on hackage :/ my connection isn't reliable
05:16:41 <phadej> (so I forget / don't notice I need to auth)
05:17:33 <cocreature> michalrus: given that you’re probably not going to read all of the source code, you have to do that anyway :)
05:17:58 <merijn> phadej: ah, I was brainstorming what cabal's behaviour should be with hvr
05:18:12 <michalrus> cocreature: yes, but Guix wants to bootstrap in just a few (3? 4?) steps, not chronologically. =]
05:18:51 <michalrus> They have some simple Haskell compiler in Scheme (which is bootstrappable), which they use to compile some ancient JHC, and so on.
05:19:09 <michalrus> https://elephly.net/posts/2017-01-09-bootstrapping-haskell-part-1.html
05:21:42 <cocreature> michalrus: right but that seems more like a “can we do this” funproject than something that actually gains you a whole lot
05:22:11 <michalrus> ++
05:22:46 <ffledgling> michalrus: I decided to try and compile 8.2.2 instead which the wiki page seems to indicate I can do with ghc-7.10 (which I can get from my distro's pkgmgr). However, it seems ./boot no longer works when I do that.
05:22:49 <michalrus> But if a security researcher wanted to, they’d only have to read 4 versions, not 400. =]
05:23:19 <cocreature> sure but even reading 4 versions is going to keep you busy for quite some time :)
05:24:13 <guessWHo> ertes-w : yeah i think i do
05:24:37 <ertes-w> guessWHo: its effect can be explained as "short-circuiting": given (mx :: Maybe a) and (f :: a -> Maybe b) you can construct (my :: Maybe b) by inspecting 'mx'…  this is what (>>=) implements for Maybe
05:25:10 <merijn> phadej: Incidentally, if you use irssi it's fairly easy to set it up to pre-identify to freenode so that that issue never happen
05:25:20 <ertes-w> guessWHo: you can try implementing it as a little exercise, just name it differently:  (>>==) :: Maybe a -> (a -> Maybe b) -> Maybe b
05:26:13 <AWizzArd> michalrus: okay, then I will give that setup a try. When I looked at HIE I saw setup tips for Atom and Visual Studio Code, but not for Emacs.
05:26:29 <ertes-w> guessWHo: however, sometimes you come across a case where you need a slight variation of that:  where 'm' is a monad you'll need to combine (m (Maybe a)) and (a -> m (Maybe b)) into (m (Maybe b))
05:26:31 <phadej> merijn: I IRC from the shared machine
05:26:49 <ertes-w> guessWHo: for example where (m = IO)
05:27:03 <ertes-w> guessWHo: in that case of course you can't use Maybe's (>>=)
05:27:07 <michalrus> ffledgling: I’ve never done this myself, so… ¯\_(ツ)_/¯
05:27:32 <ertes-w> guessWHo: that's where monad transformers come in:  newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
05:27:36 <michalrus> AWizzArd: there’s some instruction in this LSP sub-mode README: https://github.com/emacs-lsp/lsp-haskell
05:27:57 <michalrus> AWizzArd: there’s also freenode/#haskell-ide-engine
05:28:25 <merijn> phadej: Can I PM you for a sec?
05:28:53 <ertes-w> guessWHo: a value of type (MaybeT m a) is really just a value of type (m (Maybe a)), but there is an instance:  instance (Monad m) => Monad (MaybeT m)  -- so you get the short-circuiting effect of Maybe, but for m-wrapped values
05:30:03 <guessWHo> " guessWHo: however, sometimes you come across a case where you need a slight variation of that:  where 'm' is a monad you'll need to combine (m (Maybe a)) and (a -> m (Maybe b)) into (m (Maybe b))" but isn't Maybe itself a monad >?
05:33:39 <ffledgling> michalrus: heh, interesting. It was an odd error about missing LICENSE files in a perl script, I disabled that check/failure and it seemed to succeed. Lets see how it goes...
05:35:10 <dminuoso> How do the more experienced haskellers deal with situations where you newtype wrap in order to overload typeclasses? Do you feel the need to unwrap/rewrap types annoying?
05:36:04 <ffledgling> michalrus: there wouldn't happen to be a specific irc channel for haskell build or something like that right? #haskell-build or #haskell-dev or similar?
05:36:38 <dminuoso> I mean at times it feels like a lot of noise mostly because type system pecularities are visible in the value level.
05:37:18 <michalrus> ffledgling: there is #ghc, but I’m not sure if that would be the right one. :o
05:39:00 <jcowan> If I wanted to add monads to a language that didn't have them, which ones would be the ones to start with, that give the most bang for the buck?  (Let's say the IO monad is off the table.)
05:39:55 <merijn> dminuoso: That's what 'coerce' is for
05:40:22 <lseactuary> cocreature do you happen to see the bug? really can't see the issue :/
05:41:55 <phittacus> Hello. I think I've gone the wrong direction, though can't find a better way.What I want is a datatype, which might have some fields not filled. The solution I see is through GADTs, but it's a bit weird to enable extensions for such a common use case. So
05:42:08 <dminuoso> merijn: Ahh interesting. Where do Coercible instances come from? Does GHC generate these implicitly?
05:42:31 <phittacus> if there is a common way to solve it, what it is? (sorry for breaking in two messages_
05:42:40 <dminuoso> merijn: Actually strike that, I was reading the wrong documentation.
05:42:45 <merijn> dminuoso: :)
05:42:51 <merijn> dminuoso: Also have a look at role annotations
05:43:27 <merijn> phittacus: Can't you just use "Maybe x" as field type and default non-filled in fields to Nothing?
05:44:25 <phittacus> merijn: Yeah, I just wanted a common structure for both filled-for-sure datatypes and not-entirely-sure
05:45:10 <dminuoso> merijn: Alright this looks like a thicker read. Gonna go through this later tonight when I have some time. Thank you very much.
05:45:10 <cocreature> phittacus: data X f = X (f Int); type NotSureX = X Maybe; type FulledForSureX = X Identity
05:45:19 <phittacus> (the naive thought was to parametrize it with a Monad and put in a Maybe in one case and Identity in other)
05:45:24 <cocreature> and apparently I can’t type
05:45:42 <merijn> dminuoso: honestly it boils down to "GHC can convert any newtype to any equivalent newtype safely, unless you tell it not to"
05:45:55 <phittacus> cocreature: And a restriction for a `f`?
05:46:24 <cocreature> phittacus: not sure why you want to restrict it. just instantiate it with what you need
05:46:33 <merijn> phittacus: No, that's what NotSureX and FilledForSureX do
05:46:57 <cocreature> lseactuary: sry that code sample is getting too large to just take a quick look at it
05:47:13 <cocreature> lseactuary: try testing the individual functions instead of only testing their composition
05:47:42 <lseactuary> you can ignore 50-87 - this is just a past example.
05:47:56 <lseactuary> i checked individual functions, everything seems correct, just the final render of the image seems completely wrong
05:48:10 <dminuoso> merijn: "We say that a parametric type variable has a representational role and a non-parametric one has a nominal role."
05:48:14 <dminuoso> merijn: This article is golden. :)
05:49:26 <phittacus> cocreature: Wouldn't a Monad be useful to map values inside datatype?
05:49:26 <phittacus> But yes, I can just then remap all NotFilled to Maybe Filled
05:50:00 <lseactuary> cocreature its line 90 onwards there is some issue
05:50:06 <lseactuary> the rest compiles and is correct
05:52:16 <cocreature> lseactuary: if the individual functions are correct then replace them by their result. that already makes it significantly easier for people trying to help you to know what they should focus on. also add the actual and the expected result to your paste
05:53:02 <lseactuary> cocreature how do you mean 'replace them by their result'
05:53:07 <cocreature> lseactuary: “here’s a 100 line file that gives the wrong result” is not a particularly good approach for finding people to help you. try to shrink it to what actually matters
05:53:45 <dminuoso> lseactuary: Also if it hasn't been mentioned, please be sure to name your file with a .hs extension (or use lpaste) in order to activate syntax highlighting. It greatly simplifies reading code.
05:53:51 <cocreature> lseactuary: if you know "evolve 4 kochCurve" is correct then replace that by the result, if you know interpret1 applied to that result is correct then replace that and so on
05:54:03 <lseactuary> its a long result...
05:54:37 <lseactuary> but ill try 2 min
05:55:32 <cocreature> basically if you want help, try to make life for the people trying to help you as easy as possible :)
05:55:43 <lseactuary> :)
05:56:44 <frerich> lseactuary: What cocreature described is basically the same approach I mentioned in the /query you opened, i.e. he starts to expand definitions from the 'inside' and I suggested to do it from the outside (i.e. verify that the generated SVG is correct, then verify that all arguments to the SVG generation are correct etc.).
05:56:57 <frerich> lseactuary: In either case, you'll eventually arrive at a function which gets correct arguments but produces incorrect results.
05:57:18 <lseactuary> frerich - that is the issue - i can't see to see the issue
05:57:40 <lseactuary> https://gist.github.com/anonymous/ea148bb5f767f09e449571c3aa137d59
05:57:58 <lseactuary> this code should compile in ghci now
05:58:09 <lseactuary> so you can see the image it produces
05:58:56 <w1n5t0n> Hey all, this might be a bit of an odd question (for a mini eDSL I'm making in Haskell). I want to be able to attach a name to a do block, which will be made up of a series of OSC messages to be sent, and I want to prepend the name of the block to each message. For example: someName = do sendOSC "first"; sendOSC "second"; sendOSC "third", and I want the messages sent to be something like "someName_first", "someName_second" etc. Is 
05:59:21 <dminuoso> lseactuary: Again, please edit your gist and enable syntax highlighting by renaming your file to have a .hs extension.
05:59:23 <cocreature> lseactuary: that still has no syntax highlighting, no expected and actual results and is a 100 lines long.
06:00:35 <lseactuary> my apologies using it the first time
06:00:45 <lseactuary> editing
06:00:58 <lseactuary> https://gist.github.com/anonymous/e90f6c48c6a19ab6f5ccdcccd5e28219
06:01:50 <cocreature> lseactuary: test if sh2 is still correct, if so then you can throw away everything in that file that produces sh2 since the bug must come after it. if it is incorrect then you can throw away everything that comes after it
06:02:00 <lseactuary> https://imgur.com/a/Yzd34
06:02:01 <cocreature> that way you can make your code significantly smaller
06:02:21 <srk> l-systems \o/
06:02:55 <lseactuary> the case where the direction is N/S/E/W works
06:03:21 <lseactuary> meaning the code for assemble should be fine
06:03:42 <lseactuary> i checked each component of sh = ... and this also looks fine
06:04:08 <lseactuary> makePolyline is basically just removing the same co-ordinates
06:04:14 <lseactuary> which is looking correct
06:04:20 <lseactuary> the interpret stuff is also correct
06:04:22 <lseactuary> so no idea
06:04:43 <cocreature> lseactuary: print out sh2, is it correct?
06:05:13 <lseactuary> its a bunch of co-ordinates - yup
06:05:34 <cocreature> but are they the coordinates that you expect?
06:06:35 <lseactuary> i checked the first 10 and they seem consistent with the picture
06:06:39 <lseactuary> i can upload if it helps
06:07:16 <cocreature> no the whole point of this that you learn how to debug this yourself or at least isolate the problems to a more suitable size for others to look at
06:07:40 <cocreature> by “consistent with the picture” do you mean consistent with the correct picture or the buggy picture that just shows a straight line?
06:07:57 <lseactuary> the correct picture
06:08:09 <lseactuary> i understand but i genuinly have gone through each function testing it
06:08:16 <lseactuary> and really dont get why its compiling a straight line
06:08:24 <cocreature> alright, so then the problem must be in "assemble" since that’s the only thing that comes after it
06:08:26 <lseactuary> if anything i would have expected an error or weird line
06:08:34 <[exa]> srk: btw did you see contextfreeart.org?
06:08:37 <cocreature> so replace sh2 by the list of coordinates and remove everything that is no longer necessary
06:08:38 <lseactuary> assemble is a standard code given in the book
06:10:09 <cocreature> well you have two options, either "sh2" is correct and "assemble" is wrong or "sh2" is already incorrect
06:10:22 <lseactuary> i am definite that assemble is correct
06:10:27 <lseactuary> so sh2 is wrong somewhere
06:10:32 <ertes-w> guessWHo: Maybe is a monad, so you can use:  (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
06:10:36 <srk> [exa]: cool :)
06:10:39 <lseactuary> but i cannot seem to see where as each function seems to produce an okay result
06:10:54 <ertes-w> guessWHo: but you can't use:  (>>=) :: (Monad m) => m (Maybe a) -> (a -> m (Maybe b)) -> m (Maybe b)
06:11:08 <ertes-w> guessWHo: that's why there is a separate type MaybeT
06:11:24 <ertes-w> guessWHo: (>>=) :: (Monad m) => MaybeT m a -> (a -> MaybeT m b) -> MaybeT m b
06:11:36 <ertes-w> this fits the type of (>>=)
06:12:14 <ertes-w> guessWHo: the following question might make it clear why you need a separate type:
06:12:33 <bwe> ertes-w: Sorry, I could not continue the discussion on monoid last time. At least I could have left a short note. Anyways, would you mind to continue at some later time?
06:12:42 <ertes-w> guessWHo: the type of (>>=) is:  (Monad m) => m a -> (a -> m b) -> m b
06:14:11 <ertes-w> guessWHo: which m would you need to pick in order to instantiate this type in such a way that you get:  (>>=) :: (Monad m') => m' (Maybe a) -> (a -> m' (Maybe b)) -> m' (Maybe b)
06:15:08 <merijn> hmm, any recommendations on how to deal nicely with nested if in a monadic context? i.e. "if not condition -> do more IO and check next condition"?
06:15:31 <ertes-w> bwe: whenever you're ready and i have time =)
06:15:35 <lseactuary> cocreature that is why i was trying to get another pair of eyes
06:15:46 <ertes-w> merijn: MaybeT?
06:16:13 <merijn> ertes-w: I only have 3 or 4 levels of nesting :\
06:16:33 <ertes-w> merijn: does that matter?
06:16:47 <ertes-w> MaybeT helps at >= 2 levels
06:16:50 <merijn> ertes-w: I'll have to see how much noise MaybeT adds
06:17:06 <cocreature> lseactuary: my point still stands, isolate it to something smaller or at least I won’t look at it. if you’re sure "assemble" is correct, remove everything related to that from your sample. if the lists are too long to figure out if results are correct, use "evolve" with a smaller number, …
06:17:49 <lseactuary> but if i dont include it, you will have trouble compiling no?
06:17:54 <lseactuary> thats why i left it in
06:17:58 <merijn> ertes-w: No, wait, actually MaybeT doesn't work at all
06:18:01 <cocreature> no just remove everything that calls "assemble"
06:18:12 <merijn> ertes-w: Because I need to distinguish which case failed
06:18:18 <lseactuary> but how will this help debug?
06:18:26 <[exa]> merijn: there's something with maybe and monoid that works like it, but I'm not sure
06:18:28 <merijn> ertes-w: i.e. I have 3 possible return states
06:18:33 <ertes-w> merijn: then ExceptT
06:18:33 <cocreature> it means that I know only need to look at 50 lines of code instead of 100 lines of code
06:18:38 <cocreature> *now
06:18:39 <lseactuary> oh
06:18:52 <lseactuary> ok sure let me clean up
06:19:14 <merijn> cocreature: You have the patience of a saint :p
06:19:44 <cocreature> merijn: I need an excuse to procrastinate ;)
06:19:57 <[exa]> merijn: (it's similar to mconcating a list of Ords)
06:19:59 <merijn> cocreature: I can give you some yaks to shave
06:20:01 <Boarders_> I have a function like: tryParseStringToLast :: (fromJSON a) => Object -> Text -> Parser (Last a)
06:20:16 <Boarders_> but it doesn't compile (unless I comment out the type signature)
06:20:22 <cocreature> lseactuary: once you’re done with that, add the actual result you get for sh2 and the one that you would like to the paste
06:20:35 <lseactuary> oki
06:20:41 <[exa]> Boarders_: what about the error message (and maybe a code sample?)
06:20:51 <Boarders_> I get: Could not deduce: fromJSON0 a       from the context: fromJSON a
06:20:59 <merijn> [exa]: Brilliant! I just realised I can slightly change my datatype, turn it into a monoid and abuse the monoid instance of IO
06:21:06 <muesli4> Any idea why GHC fails here: http://lpaste.net/363798 ?
06:21:26 <[exa]> merijn: the monoid instances on Maybe and Ord are pure wow
06:21:47 <[exa]> and well, Monoid (-> a) is dope.
06:21:50 <merijn> [exa]: The point is I have a IO I need to deal with
06:22:08 <Boarders_> exa: this is the error I get: http://lpaste.net/363799
06:22:10 <merijn> [exa]: So I can combine ((->) r) monoid with monoid on IO
06:22:15 <lseactuary> cocreature: https://gist.github.com/anonymous/7617ee8990e7593b03f8cfead14d5801
06:22:34 <merijn> [exa]: And just write 3 independent "Foo -> IO Bar" functions and just mconcat those
06:23:22 <Boarders_> exa: this is the type that ghci gives me back if I comment out my type sig: http://lpaste.net/363800
06:23:56 <cocreature> lseactuary: that contains the actual results which are incorrect (according to you). so what are the correct results?
06:24:19 <lseactuary> cocreature it should compile an image like this: https://imgur.com/a/Yzd34 not a straight line.
06:25:09 <cocreature> lseactuary: no, I want to see the actual list of coordinates that should be generated. not some abstract image that’s produced later on based on those coordinates.
06:25:21 <lseactuary> hmm i think that will be hard
06:26:23 <Boarders_> Here is a summary of the problem I am having: http://lpaste.net/363802
06:26:26 <Boarders_> any ideas?
06:28:24 <lseactuary> evolve 1 kochCurve "F+F--F+F" so its using this pattern instead
06:28:31 <lseactuary> F being move and the +/- being turn
06:28:44 <[exa]> merijn: yeah, dope. :]
06:28:55 <[exa]> Boarders_: lemme check :]
06:29:05 <lseactuary> cocreature based on this my assumption is either the step2 or run2 functions are not quite right
06:29:32 <lseactuary> i cannot see anything else wrong here
06:31:53 <lseactuary> cocreature so im comparing interpret1 (evolve 1 kochCurve) [Forward1,TurnLeft1,Forward1,TurnRight1,TurnRight1,Forward1,TurnLeft1,Forward1] to the curve and the problem seems the TurnRight1
06:32:18 <lseactuary> it seems to 'double turn' right i.e. back to the origin then down right again vs one single step to turn right
06:32:22 <lseactuary> i think this is the problem
06:32:36 <lseactuary> the line step2 dist dir1 TurnRight1 (x:+y, dir2) = (x:+y, turn (-1*dir1) dir2) must be wrong?
06:32:48 <lseactuary> also the run2 function is missing the first co-ordinate
06:33:09 <[exa]> Boarders_: I think that the problem is there because of ambiguity, not that the type would be wrong
06:33:27 <lseactuary> cocreature did that help?
06:33:51 <[exa]> Boarders_: btw can you paste the function?
06:34:25 <merijn> How can I make cabal report which version of a dependency it's chosen?
06:35:33 <[exa]> muesli4: I guess it's a missing $ before handleMaybe
06:35:47 <[exa]> muesli4: (or maybe just parens there)
06:36:32 <[exa]> muesli4: but maybe I'm wrong, your paste doesn't show the actual source code
06:36:54 <cocreature> lseactuary: let’s make this short: I won’t look at your program until you can provide me with an input to a function and the incorrect result that is produced by that function on those inputs as well as the correct result that you would like to get
06:37:04 <lseactuary> ok
06:37:07 <lseactuary> let me fix
06:37:53 <muesli4> [exa]: Yes, unfortunately I pass the first argument on. I'm trying to further reduce it.
06:38:42 <[exa]> muesli4: on debugging it helps a lot to use (undefined :: _ ) in place of some expressions that cause trouble, to see what the compiler is expecting from you
06:39:03 <[exa]> (or maybe just _ )
06:39:08 <muesli4> [exa]: Great idea, thanks.
06:39:38 <jollygood2> I got UTCTime with getModificationTime function, and now I want to convert it to my local time and then display it. Am I suppose to use ZonedTime or LocalTime?
06:41:33 <merijn> jollygood2: ZonedTime is just a LocalTime + TimeZone
06:41:49 <jollygood2> merijn yes
06:41:55 <jollygood2> why do we need both?
06:42:41 <merijn> jollygood2: a LocalTime is just a date + 24 hour clock time. But "March 29, 18:00" in Europe is not the same UTC time as in New York
06:42:42 <[exa]> jollygood2: so that the computer knows at what time zome the local time was measured
06:43:14 <merijn> jollygood2: If you're just trying to figure out "what date/time was this UTC time compared to my current machine's time zone" LocalTime is fine
06:43:26 <merijn> jollygood2: But when communicating a time to another machine it is not
06:43:48 <merijn> jollygood2: And you can't communicate future LocalTime's as UTC
06:44:08 <merijn> jollygood2: So for future times/dates you need ZonedTime to transmit a date/time + timezone
06:44:28 <jollygood2> merijn but there's no harm in using ZonedTime there as well, no? I'm still baffled what is the purpose of LocalTime without timezone. we can use ZonedTime everywhere LocalTime could be used, but reverse is not true
06:44:29 <AWizzArd> michalrus: thx for the link to emacs-lsp
06:44:49 <michalrus> Sure! LSP is the way.
06:45:22 <michalrus> (And, in my experience, this particular server works more reliably than Intero.)
06:45:22 <merijn> jollygood2: Because sometimes humans want to communicate local times without a timezone?
06:45:52 <michalrus> AWizzArd: I can’t wait for LSP impl. in Yi, to dump the dinosaur. :}
06:45:59 <AWizzArd> michalrus: hr hr hr
06:46:36 <lseactuary> cocreature: like this? https://gist.github.com/anonymous/3bb17d6e68ab4f87a67383f73488c9d6
06:47:14 <cocreature> lseactuary: I give up, I’m apparently not capable to communicate what I’d like you to do. sorry. maybe someone else can help
06:47:35 <lseactuary> you said share the code piece, the output, and what i want it to do...
06:49:39 <lseactuary> :(
06:51:40 <lseactuary> cocreature please tell me and i will do
06:51:50 <__monty__> Someone just pointed out to me that (_|_) looks a lot like a bottom, was this on purpose?
06:52:06 <merijn> __monty__: No, but it's a happy coincidence
06:52:47 <cocreature> I’ve tried to do that for the last hour or so, at this point I’m just not willing to try again. (it coul very well be my fault that I’ve failed!)
06:52:57 <merijn> __monty__: The original math symbol for bottom is ⊥ so _|_ is just an ascii approximation
06:53:18 <frerich> lseactuary: You need to specify the desired output by example instead of describing(!) it in english terms.
06:53:44 <lseactuary> but i did in line 10
06:53:50 <lseactuary> oh
06:53:57 <lseactuary> sorry
06:53:57 <merijn> __monty__: Traditionally you have ⊤ for top (the horizontal bar being at the top and looking like the T for top) and ⊥ as it's opposite bottom (horizontal bar at the bottom)
06:54:24 <frerich> lseactuary: Right, that's the english description. What you need to specify is the value 'foobar' such that 'run2 1 (pi/3) (interpret1 (evolve 1 kochCurve)) (0, 0) == foobar' evaluates to True.
06:54:48 <lseactuary> https://gist.github.com/anonymous/a5880643a750026242b7d740a6ffecbe
06:54:54 <lseactuary> like this?
06:54:55 <noan> Hi folks, This might seem like a stupid question, but I'm sort of just starting to learn haskell, and I was wondering what patterns there are for logging and monitoring of applications in haskell? Is it generally all very "roll your own"?
06:55:22 <frerich> lseactuary: That looks promising!
06:55:44 <lseactuary> omg i found the bug!
06:55:57 <lseactuary> but the one i attached is still a bug :P
06:56:03 <lseactuary> now it compiled the curve
06:56:07 <lseactuary> just without the first co-ordinate
06:56:10 <lseactuary> just like the error shows
06:56:11 <lseactuary> yay
06:56:16 <__monty__> merijn: Oh I know, would just be cool if it was done on purpose. Could've used other symbols.
06:57:19 <__monty__> noan: Afaik logging's a pain point still. There's several libraries though.
06:58:05 <noan> woah did hackage just get a huge update?
06:58:59 <merijn> noan: Why?
06:59:13 <merijn> noan: Looks the same as always to me?
06:59:53 <noan> I went to look up a logger and it was suddenly purple unless I'm mising it up with some other thing that's always in this like orange-brown
07:00:09 <lseactuary> sorry cocreature either way. didnt mean to be a pain.
07:00:21 <lseactuary> frerich any idea how to get the original co-ordinate in the list?
07:00:22 <merijn> noan: link?
07:00:30 <noan> https://hackage.haskell.org/package/hslogger
07:00:43 <noan> the css has been redone it seems, at least to my recent memory.
07:00:56 <noan> unless I'm mixing up two VERY SIMILAR websites
07:01:15 <merijn> noan: That still looks the same to me unless there's some weird caching
07:01:21 <merijn> ah
07:01:26 <merijn> looks like CSS was cached for me?
07:01:36 <clever> whoa
07:01:37 <noan> oh hackage, you don't have cache busting logic
07:01:38 <clever> that is different
07:01:38 <noan> what a shame
07:01:46 <frerich> Oh, indeed, CSS cached for me, too.
07:01:48 <Axman6> noan: looks the same as always to me
07:01:49 <merijn> I remember seeing the discussion ticket
07:01:56 <noan> Axman6, cachebust.
07:01:57 <merijn> Axman6: Force reload to clear CSS from cache
07:02:23 <merijn> Although module docs still seem to use the old CSS
07:02:50 <noan> Anyway, I suppose logging isn't the most painful thing, and can be implemented by hand pretty quickly
07:02:52 <Axman6> woah!
07:02:54 <Axman6> :o
07:03:03 <fendor_> spamming several channels, did someone try to use haskell-ide-engine on nix? Everytime I start it, it tries to download a new ghc and fails since it is not using nix
07:03:16 <noan> We use NewRelic in our Scala infrastructure pretty heavily, I kind of wonder if there is any kind of support for similar tooling and monitoring integrations?
07:03:24 <Putonlalla> Oh, nice. Hackage even switches to the old layout when there is not enough horizontal space.
07:03:43 <noan> In a sense though having them silently integrate would violate a half dozen principles of fp, so I won't be surprised if not
07:03:43 <frerich> noan: I think that's exactly how the plethora of half-hearted logging frameworks came into existence. :-)
07:04:10 <Axman6> noan: there's prometheus packages. I have an uneleased package for automatically creating prometheus metrics for every single endpoint for a servant app
07:04:12 <noan> frerich, yeah, doable in an afternoon pretty readily
07:05:08 <__monty__> Does anyone else not like the right-aligned identifiers in the side column for the new hackage css?
07:06:50 <sm> what's right-aligned ?
07:08:03 <barrucadu> Woah, the new css has been merged.
07:08:44 <barrucadu> Although I guess the actual docs of every package will remain on the old style until a new release is uploaded
07:08:55 <Psybur> Anybody know of a functor that isnt an applicative? An applicative that isnt a monad?
07:09:12 <merijn> Psybur: "Const k" is an Applicative, but not Monad
07:09:27 <merijn> Psybur: As are Async (from the async package) and Parser from optparse-applicative
07:09:50 <barrucadu> I think >>= for ZipList is only law-abiding if the two lists are the same length, so it's not a monad in general
07:10:02 <merijn> Psybur: As for "functor that's not an applicative" "Const k" is only an applicative if 'k' is a Monoid
07:10:14 <merijn> Psybur: So I suppose "Const k" fills both roles
07:10:26 <merijn> Oh, yes, ZipList is also not a Monad
07:10:27 <Psybur> > Const "bruh"
07:10:31 <lambdabot>  Const "bruh"
07:10:50 <Psybur> Ok, but whats a functor that doesnt suppose function application? :D
07:11:00 <Psybur> *support
07:11:40 <Putonlalla> The paper Trees that Grow features an empty constraint in the form of `pattern AppSh :: () => ...`. For what purpose?
07:12:04 <Psybur> > First (+1) <> First (+2) <*> First 1
07:12:08 <lambdabot>  error:
07:12:08 <lambdabot>      • Couldn't match expected type ‘Maybe (a0 -> b)’
07:12:08 <lambdabot>                    with actual type ‘Integer -> Integer’
07:12:24 <__monty__> sm: The Version, Maintainer, etc. identifiers.
07:14:30 <Psybur> Strange, didnt realize First expected a Maybe
07:14:33 <Psybur> :t First
07:14:36 <lambdabot> Maybe a -> First a
07:14:54 <[exa]> Psybur: if you have a functor you can always store a function in that, so there's probably always a way to make it "kindof work".
07:14:59 <jcowan> (reasking) If I wanted to add monads to a language that didn't have them, which ones would be the ones to start with, that give the most bang for the buck?  (Let's say the IO monad is off the table.)
07:15:29 <frerich> jcowan: I'd vote for Maybe and []
07:15:30 <Psybur> [exa], so whats the point of applicative then if functors are always applicative? :D
07:15:30 <[exa]> Psybur: I'd attack applicative laws instead.
07:15:44 <Psybur> Ah ok, I guess thats right
07:15:52 <noan> [exa], kind of my thinking. You can kind of loosely argue in my eyes that functors always suppose some kind of point-free function composition at the very least
07:15:53 <Psybur> Whats a functor that doesnt satisfy the laws?
07:16:10 <merijn> Psybur: Not all Functors are Applicative, though
07:16:26 <Psybur> merijn, yes I forgot there were additional laws
07:16:26 <jcowan> frerich: What about Either?
07:16:52 <merijn> Psybur: Applicative requires the ability to "reconstruct" a value of a type
07:17:27 <Boarders_> exa: sorry I had to step away here is the code: http://lpaste.net/363804
07:17:30 <[exa]> merijn: 'pure' is reconstruction?
07:17:34 <frerich> jcowan: I don't use that nearly as often as Maybe or [].
07:18:13 <merijn> [exa]: Well, more <*> I was thinking of
07:18:38 <Psybur> If I have a functor that just discards values does that make it not eligible to be an Applicative?
07:18:40 <merijn> Psybur: Actually, I have a (admittedly incredibly hacky) type that is a Functor but not applicative in my SQL query code
07:18:51 <merijn> Psybur: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Query.hs#L36-L44
07:19:19 <merijn> Psybur: The meaning of fmap for that type is trivial (just an additional conversion of query results), but Applicative has no (clear) sensible meaning
07:20:07 <jcowan> Also, why is the return function called that?
07:20:51 <merijn> jcowan: "because it usually used in positions where return statements are in imperative code. It'll make do blocks look familiar and easier to learn!" <- some optimist in 1998
07:21:17 * jcowan laughs
07:21:36 <jcowan> do { return 3; return 4; return 5 } being an outstanding example
07:21:43 <[exa]> Psybur: there's no problem with having an always-nothing applicative
07:21:48 <merijn> jcowan: Yeah, in hindsight not such a great idea
07:21:58 <Psybur> [exa], yeah I cant seem to make that fail any laws
07:22:25 <[exa]> Psybur: anyway, there's an easy Functor instance for binary trees, try to make it applicative. :]
07:25:33 <Putonlalla> Looking at `Prelude`, there is only one ordinary `Functor` that is not `Applicative`.
07:25:55 <Putonlalla> It's `Handler` from `Control.Exception`.
07:26:00 <Psybur> [exa], good point, thats interesting. Not sure how liftA2 would work haha
07:26:35 <ertes-w> jcowan: the name is really only confusing because…  other languages…
07:27:10 <Putonlalla> :t Exception.Handler
07:27:10 <ertes-w> jcowan: in a sequencing-effects interpretation (return x) is the action that does nothing and returns x
07:27:12 <lambdabot> Exception e => (e -> IO a) -> Exception.Handler a
07:27:46 <[exa]> Psybur: it's an exercise from hell
07:28:36 <Psybur> https://www.packtpub.com/mapt/book/application_development/9781786461353/4/ch04lvl1sec36/binary-tree-as-applicative
07:29:18 <Psybur> Never seen someone use Leaf to signal the end of a branch
07:29:42 <Psybur> Usually thats Empty right? :D
07:30:09 <MarcelineVQ> the trees in my back yard use leaves to end branches
07:30:21 <Psybur> Bleh they gray out the rest of the article sorry >.>
07:30:38 <[exa]> Psybur: any other way of saying Nil :]
07:31:00 <[exa]> Psybur: but yeah the thing with 'pure' might help you a lot
07:31:22 <[exa]> I'm not sure whether satisfying applicative laws is even possible without infinite pure
07:31:23 <Psybur> That would just be a new root right?
07:31:30 <Psybur> Oh right I see
07:31:52 <Psybur> Yeah similar to how ZipList uses infinity
07:32:19 <[exa]> hell it starts to remind me Π_0^1 classes
07:32:36 <guessWHo> any suggestion for resources on haskell language extension ??
07:32:53 <[exa]> guessWHo: how do you want to extend it?
07:33:10 <[exa]> guessWHo: (there's a module system in GHC which helps if you only want to tune a bit of stuff)
07:33:47 <Taneb> guessWHo: do you mean the language extensions that GHC provides, like -XFlexibleContexts, or do you mean extending Haskell yourself?
07:33:57 <MarcelineVQ> http://dev.stephendiehl.com/hask/#language-extensions  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/lang.html   https://ocharles.org.uk/blog/posts/2014-12-01-24-days-of-ghc-extensions.html
07:44:42 <guessWHo> Taneb : i was talking about the one haskell provides which are mentioned at top of the file like  { # }  , i want to learn more about them since they pop up with many libs i use,
07:44:53 <Boarders_> say I have a function f :: Type1 -> Type2 and a t1 :: Type1
07:45:09 <Boarders_> I want a new function which is equal to f apart from at t1
07:45:18 <Boarders_> what do people think is the neatest way to write this pattern>
07:45:20 <Boarders_> ?
07:47:33 <masaeedu[m]> supposing your function was a table of `(Type1, Type2)`s, you want to remove the entry `(t1, a)` and replace it with `(t1, not a)`.
07:47:49 <masaeedu[m]> I guess that requires some notion of being able to pull a non equal type from `Type2`
07:48:24 <Taneb> guessWHo: then MarcelineVQ had exactly what you need
07:48:33 <Taneb> Read the articles they linked
07:48:46 <masaeedu[m]> you could then just evaluate `notTheSame $ f t1` where `notTheSame` is some means of pulling a value that is not `f t1` implemented over Type2
07:48:49 <kosmikus> Boarders_: what's wrong with g x = if x == t1 then ... else f x ?
07:48:49 <frerich> Boarders_: I think I'd write a function 'g x = if x == t1 then custom else f x'.
07:50:20 <masaeedu[m]> e.g. if `Type2` is already a monoid you could use `notTheSame x = x <> mempty`
07:50:29 <Boarders_> nothing, that is probably how I would write it or with lamba case but I was just interested in alternative
07:50:34 <qmm> is there a way to say this structure is of type (a, b) where b isn't a?
07:52:27 <guessWHo> MarcelineVQ , Taneb : resources on Monads other than learn you a haskell and real life haskell
07:52:47 <masaeedu[m]> qmm: Maybe https://stackoverflow.com/a/25119516
07:53:49 <MarcelineVQ> guessWHo: https://en.wikibooks.org/wiki/Haskell/Understanding_monads https://wiki.haskell.org/Typeclassopedia
07:55:05 <masaeedu[m]> guessWHo: I was writing a monad tutorial in JS
07:55:07 <masaeedu[m]> about the state monad
07:55:48 <masaeedu[m]> i guess what resource would be useful to you depends on what language you're already most familiar with
07:56:05 <dminuoso> Yeah, we dont have enough monad tutorials yet. Im sure this will be the one that finally nails it and causes every reader to think "Well that was easy!"
07:56:10 <qmm> masaeedu[m]: type classes, thanks
07:56:53 <Cale> masaeedu[m]: It's pretty tricky to do a good job of implementing monads in JS without ending up with something that is annoying to use, because you basically have to pass the monad instance around by hand everywhere.
07:56:54 <dminuoso> guessWHo: If you want to learn monads, write them yourself and use them. There's no better substitute. =)
07:57:23 <Cale> (i.e. the implementations of return and bind, say)
07:57:42 <__monty__> qmm: Look into type families, I think they're more suited to what you want.
07:58:02 <masaeedu[m]> Cale: Yeah, except I don't mind passing the monad instance around everywhere, modules in JS are bags of functions
07:58:48 <Cale> The important thing is that you can write things like sequence/mapM just once, and reuse them for many different monads.
07:58:49 <masaeedu[m]> you just `const { return, bind } = Obj` if you're using it monomorphically, or accept a param that has those properties if you're trying to use it polymorphically
07:59:06 <Cale> yeah, I suppose that's fair
08:02:26 <qmm> __monty__: ah, that's nice too. thank you
08:02:29 * masaeedu[m] sent a long message: masaeedu[m]_2018-03-19_15:02:06.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/teRrENLkHRmOjGEwQLvSewTA>
08:02:38 <masaeedu[m]> Anyway, more to @guesswho's question
08:02:47 <masaeedu[m]> the best resource i've found is Bartosz Milewski's book
08:02:50 <masaeedu[m]> for understanding this stuff in general
08:03:01 <masaeedu[m]> it takes a long time to get through, but it's well worth it
08:03:19 <masaeedu[m]> https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
08:04:15 <jcowan> Somewhere there is a monad anti-tutorial saying how bad the whole idea of monad tutorials is
08:05:43 <lawsomw> Hi guys, we're having Haskell in Uni currently and have to infer our given functions. However I have no clue where to start with things like list comprehensions. How do you infer their type? Any good advice or good link for this?
08:05:48 <masaeedu[m]> mostly all these monad tutorials happen because people are learning it using the feynman method
08:06:25 <jcowan> https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
08:06:45 <Cale> lawsomw: Well, the type of a comprehension [<expr> :: t | ...] is [t]
08:07:53 <Cale> lawsomw: and then on the right of the |, whenever you see <pat> <- <expr>, the type of <expr> must be some type of list [a], and the type of <pat> will be a
08:08:16 <Cale> lawsomw: and the type of any other expression which occurs in the list of qualifiers is Bool
08:08:44 <Cale> (as it's a condition to be satisfied by the elements)
08:09:37 <masaeedu[m]> jcowan: I'm not sure that's a post about monad tutorials in general so much as it is a post about certain kinds of "here's what a monad is" tutorial
08:10:11 <jcowan> True
08:10:27 <masaeedu[m]> showing how such and so forms a monad (e.g. arrays/objects etc.) follows the direction of progression he's talking about, i.e. concrete to abstract
08:10:55 <armlesshobo> yeah but why are monads so versatile?
08:11:05 <lawsomw>  Cale That's clear, but how do you bring it all together? Say you input an Int and the functions output would be a list then obviously. But I don't get in which order the in between needs to be
08:11:29 <armlesshobo> my brother needed someone to jump his car when no one was around. he just plugged his battery into a monad and it started up just fine
08:11:43 <Cale> lawsomw: what are you trying to typecheck?
08:12:22 <jcowan> armlesshobo: That would be a windowless monad
08:12:36 <Cale> lawsomw: Your function takes an Int and produces a list of values of some sort?
08:13:15 <Cale> lawsomw: If so, then your function's type looks like  Int -> [...]  where the ... is the type of elements of the list which is produced
08:13:23 <lawsomw> Cale:  yeah, we have several ones we need to do. The one with list comprehension was for perfect numbers
08:13:55 <armlesshobo> jcowan: took me a sec to look up what windowless monads were. pretty funny response :)
08:14:01 <masaeedu[m]> armlesshobo: ours not to wonder why
08:14:11 <masaeedu[m]> ours but to `do` or die
08:14:19 <armlesshobo> :D\
08:14:23 <armlesshobo> :D
08:16:00 <lawsomw> Cale: Which uses mod n x == 0 obviously. That would be a bool. And the mod function itself is Int-> Int-> Int
08:17:55 <lawsomw> Cale: we have to write everything in detail unfortunately else I could just typecheck with :t
08:23:06 <frerich> lawsomw: Maybe your professor/tutor is the kind of person who enjoys wearing T-Shirts like https://www.zazzle.com/hindley_milner_type_inference_t_shirt-235812502357339841
08:23:58 <lawsomw> frerich: exactly xD
08:24:23 <Taneb> frerich: I want that shirt
08:24:44 <masaeedu[m]> does haskell give you an easy way to look at the "reduced" language it compiles to?
08:24:55 <Cale> lawsomw: Depending on how much detail you want to provide, you might use the Haskell Report's desugaring of list comprehensions first, and then go from there.
08:25:06 <merijn> masaeedu[m]: Yes, see the various dump flags in the GHC manual
08:25:12 <dminuoso> masaeedu[m]: -ddump-simpl et al
08:25:16 <merijn> masaeedu[m]: Well, for some value of "easy" :)
08:25:26 <dminuoso> merijn: https://downloads.haskell.org/~ghc/7.6.2/docs/html/users_guide/options-debugging.html =)
08:25:54 <lawsomw> Cale: okay, thank you. I'll have a look at it again
08:26:02 <masaeedu[m]> maybe doing that and doing the checking on the simplified language would help with reasoning backwards on the sugared up language constructs
08:26:29 <dminuoso> masaeedu[m]: The thing I found most enlightening and helpful is to understand how polymorphism/universal quantification actually works.
08:26:47 <lawsomw> dminuoso: how did you do so?
08:27:29 <lawsomw> Our lectures don't provide a lot of information unfortunately
08:28:53 <dminuoso> lawsomw: Through reading some articles about System F, receiving a lot input from this channel, and reading various dump outputs.
08:29:19 <ij> Can I split groundhog models into multiple files?
08:29:27 <dminuoso> ddump-ds is enough to see this magic happening
08:30:13 <lawsomw> Alright, thanks mate, gonna retry
08:31:46 <masaeedu[m]> dminuoso: Interesting. I was trying to follow an HM checker tutorial and the trickiest part for me was reducing complex syntactic constructs in the language to the 4 basic expressions.
08:32:49 <masaeedu[m]> once you have a tree of HM-like expressions applying the rules repeatedly is just an exercise in having a sharp eye
08:33:24 <masaeedu[m]> or being a computer :)
08:36:14 <ij> Does direct-sqlite include a copy of the sqlite library?
08:42:39 <dminuoso> masaeedu[m]: Actually in Haskell the type checker works _before_ the desugarer.
08:42:45 <dminuoso> Well, on GHC anyway.
08:45:31 <texasmynsted> cocreature: Thank you.  Wow 6 hours to edit and upload each Haskell Cast?  That seems really high.
08:45:44 <masaeedu[m]> I didn't know that. I was assuming it would be easier to prove correctness without a lot of fancy features
08:46:07 <[exa]> masaeedu[m]: it's usually harder to show user what the problem is than to prove he's wrong
08:46:45 <dminuoso> masaeedu[m]: It would, but then a) reporting errors would become problematic since you have lost the original information, and b) it means desugaring must preserve the type checking logic.
08:47:00 <masaeedu[m]> right, so i guess mapping errors back in a sensible way would be the major challenge
08:47:00 <[exa]> masaeedu[m]: having the exact location of the error on the sugared source helps a lot
08:47:57 <[exa]> btw afaik this way the locations can get killed in desugaring, except for some annotations
08:48:43 <abhir00p> Are there any restrictions associated with posting to the ghc-devs mailing list? I tried posting a query of mine yesterday, but it got rejected.
08:48:56 <dminuoso> masaeedu[m]: Supposedly there are cases where the desugarer would (at least given todays design of Core) might change whether a program would type check.
08:49:17 <dminuoso> So that choice gives more freedom wrt to desugaring and Core.
08:49:39 <[exa]> abhir00p: you might want to try #ghc here
08:49:59 <cocreature> texasmynsted: if you are able to, maybe try offering to help with editing? I would certainly be really happy if we get more episodes :)
08:50:04 <masaeedu[m]> does the reduced language perhaps do its own pass of type checking?
08:50:15 <cocreature> abhir00p: I think you need to be subscribed
08:50:29 <dminuoso> masaeedu[m]: Actually yes. Core is statically typed, which is mostly just a sanity check to ensure the simplifier passes dont screw up.
08:50:35 <[exa]> masaeedu[m]: yes core has extra typechecker, as a lint for passes
08:50:38 <abhir00p> [exa]: I had a discussion here yesterday and mpickering: and carter: suggested me to post to the ghc-devs mailing list
08:50:39 <texasmynsted> I would not be much help with edititing I think, but I am not unwilling to try.
08:50:54 <carter> abhir00p:  ?
08:50:54 <masaeedu[m]> or does each language extension come with its own proof of type soundness
08:51:07 <carter> abhir00p:  you have to sign up for the list
08:51:17 <carter> you can't post if you're not a member
08:51:43 <dminuoso> masaeedu[m]: You might find this article of interest: http://www.aosabook.org/en/ghc.html
08:52:03 <dminuoso> masaeedu[m]: It talkes about a lot of the design and choices of GHC, and its written by two of the most influential people in Haskell.
08:52:07 <masaeedu[m]> ok, that makes sense
08:52:24 <masaeedu[m]> i guess that's something you can lean on to an extent as an implementer of extensions to the compiler
08:53:16 <masaeedu[m]> thanks
08:53:17 <masaeedu[m]> i'll take a loko
08:53:25 <Welkin> a loko?
08:53:38 <lambdabot> look
08:53:39 <Welkin> that drink the teens like?
08:53:54 * Welkin slaps lambdabot 
08:54:00 <Welkin> *o.o*
08:54:12 <masaeedu[m]> that's when you look at things, but in a wild eyed and deranged manner
08:55:41 <abhir00p> carter: Ah! thanks I forgot to confirm my subscription. I was able to send now
08:55:52 <carter> cool
08:56:35 <dminuoso> masaeedu[m]: But yes, extensive features do seem to come with proofs, sometimes in form of published papers such as http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf being one of the papers justifying the changes in TypeInType
08:57:54 <masaeedu[m]> It seems like that paper is suggesting an extension of the reduced language itself
08:58:39 <dminuoso> masaeedu[m]: Right, so essentially you just need to prove properties in Core, and then present a way of translating syntax into core.
08:59:15 <masaeedu[m]> makes sense
09:01:22 <Sanya> hello! can anyone please give some insight about the "offline mode for stack project" in GSoc , and what all specific things i have to learn for it.I have been learning stack for quite a while now.
09:04:25 <hojourner> Hi all! New haskeller here, been trying to reproduce parts of the standard prelude for practice, and to give myself some background into what normal functions might look like. I've got a question with why a function I have terminates. I know the answer is, in some fashion "lazy evaluation", but after reading a good bit about it I'm at a loss as to what's really going on
09:04:51 <hojourner> The function in question is: `and' [] = True; and' (x:xs) = x && and' xs` (I'm at work and the pastebin clone is blocked, sorry). Basically, just a reproduction if `and` from the prelude
09:05:38 <dminuoso> hojourner: You could also use http://lpaste.net/new/haskell if that works =) Or maybe gist @ github.
09:05:39 <hojourner> If I call and' with something like `[True, True, False] ++ cycle [True]` it works and short circuits, but I'm not totally sure why
09:05:48 <MarcelineVQ> @src &&
09:05:48 <lambdabot> True  && x = x
09:05:49 <lambdabot> False && _ = False
09:06:21 <MarcelineVQ> when the first argument is False it never looks at the second, your second argument is where your recursion happens, so on False it doesn't happen
09:07:20 <hojourner> Doesn't that break referential transparency though? Since it would look something like (True && (True && and' [False, True..]))
09:07:34 <hojourner> Where the precedence is on the parens
09:07:46 <Welkin> no
09:07:52 <Welkin> the parens have nothing to do with evaluation order
09:08:35 <hojourner> How come? I guess I don't understand how the False value filters outside
09:08:57 <robstr> Is it possible to print the Data constructor name with putStrLn ?
09:09:07 <Welkin> (&&) True ((&&) True ...)
09:09:14 <guessWho> i'm learning about algebraic types and i have a question http://lpaste.net/363811
09:09:23 <Welkin> that keeps reducing down until you get to ((&&) False ...)
09:09:25 <Welkin> then it ends
09:09:41 <Welkin> robstr: yes, just `show` it
09:09:48 <masaeedu[m]> if you expand one more level in `(True && (True && and' [False, True..]))`, you get `(True && (True && False && (and' [True..])))`. Which is more or less how it actually evaluates
09:09:48 <Welkin> or write your own show instance
09:10:07 <robstr> Welkin: this print's the content too, but I just want the name
09:10:13 <masaeedu[m]> whoops, missed a parens
09:10:13 <Sanya> does anyone have any idea about "the offline mode for stack " project in GSoC and what all it includes. Please share.
09:10:22 <masaeedu[m]> the right hand side of the `False &&` expression never gets evaluated
09:10:23 <hojourner> Ohhh, I see, right... makes perfect sense
09:10:33 <Welkin> robstr: that is because that is the default Show instance. You will need to define your own explictly, or come up with a custom show function
09:10:38 <hojourner> Thanks a bunch @Welkin and @masaeedu
09:10:48 <robstr> Welkin: I see, ty
09:12:17 <MarcelineVQ> guessWho: just remove  :: DummyMap arg1 arg2   and it'll work
09:13:01 <masaeedu[m]> guessWho: The fact that you're doing `a -> b -> ` is actually a restriction for your function's implementation
09:13:06 <masaeedu[m]> any liberties you grant to the caller come at the expense of the liberties of the implementation
09:13:23 <masaeedu[m]> so now that you've said "I work for any a and b", you may not talk about which as and bs inside the function's implementation
09:14:14 <guessWho> masaeedu[m] : yeah i understand that i'm just playing around
09:16:51 <MarcelineVQ> the type that would be appropriate in this specific case is   :: DummyMap a b   but you can't write that because what it actually does is introduce a new a and b    you can use an extension called ScopedTypeVariables to be able to say  :: DummyMap a b  and mean the same a and b from  addToDummyMap :: a -> b -> DummyMap a b     but it's not really neccesary here
09:21:37 <godel> !help
09:21:47 <godel> how do i see functions definition?
09:21:49 <godel> with the bot
09:22:17 <dminuoso> @src head
09:22:17 <lambdabot> head (x:_) = x
09:22:17 <lambdabot> head []    = error "Prelude.head: empty list"
09:22:23 <dminuoso> godel: Keep in mind its a lie though.
09:22:31 <godel> @src fix
09:22:31 <lambdabot> fix f = let x = f x in x
09:22:34 <godel> yea i know, thanks
09:22:35 <dminuoso> godel: The bot simply has a text file mapping names to strings.
09:22:37 <godel> yea
09:22:39 <godel> cool
09:23:38 <dminuoso> godel: It's usually better to use hackage and the "Source" link next to names.
09:23:44 <cronokirby> is there a way to make some kind of "anonymous" sum type, so that foo :: Bar + Baz -> Int would need to match on both the cases of Bar, and Baz?
09:24:34 <muesli4> chronokirby: Either?
09:24:45 <cronokirby> well, ideally I'd like A + B + C to work as well
09:24:59 <cronokirby> and further on
09:25:00 <cocreature> cronokirby: not easily
09:25:12 <cocreature> cronokirby: you can use something like vinyl’s CoRec if you really want to
09:25:32 <cronokirby> yeah I've been thinking about this, because most of the way normal adts are constructed, you could with anonymous products, sums, and newtypes
09:26:26 <masaeedu[m]> maybe you can use a type family
09:26:29 <albeit> Is there a lens function I can use for MonadReader similar to "use" for MonadState?
09:26:31 <muesli4> chronokirby: Well, there is this https://ghc.haskell.org/trac/ghc/wiki/UnpackedSumTypes. But it's probably not exactly what you want.
09:26:52 <masaeedu[m]> although i guess in that case you can just declare a sum type
09:26:58 <Sanya> does anyone have any idea about "the offline mode for stack " project in GSoC and what all it includes. Please share.
09:27:01 <cronokirby> well in haskell it's not too useful
09:27:13 <masaeedu[m]> oh, there's this library for lower ceremony declaration of sum types
09:27:22 <cronokirby> but I've been thinking about whether or not you could have a functional language wit just anonymous sum and products, as well as newtypes
09:27:29 <cronokirby> and whether that's equivalent to haskell's adts
09:28:04 <amalloy> in the same way that a language with just lambdas is equivalent to allowing functions to be defined, i suppose
09:28:26 <cronokirby> I guess you could just use lambdas for anonymous sum / products
09:28:32 <cronokirby> church encoding ftw
09:28:45 <masaeedu[m]> https://nikita-volkov.github.io/first-class-sums-and-products/
09:28:54 <cronokirby> ooh thanks
09:29:07 <masaeedu[m]> what you're describing is sort of what typescript gives you
09:29:10 <masaeedu[m]> unfortunately there's a lot of holes and unsoundnesses
09:29:25 <dstolfa> cronokirby: an effect system + lambda calculus should be sufficient to implement a language
09:29:38 <dstolfa> the rest would just be a way to reason about it
09:29:40 <dstolfa> and useful things
09:30:03 <cronokirby> how does ghc implement stuff like putStrLn btw?
09:30:04 <cocreature> cronokirby: you probably need something to encode recursive types
09:30:24 <cronokirby> I've been wondering at how you implement the base abstraction of an effect system in a language
09:31:03 <dstolfa> cronokirby: runtime
09:31:37 <cronokirby> but like, don't you need some primitive functions that don't have an implementation?
09:31:39 <masaeedu[m]> you simply have to model the entire operating system as a pure computation
09:31:54 <cronokirby> and that get special treatment, or do ffi
09:31:55 <dstolfa> cronokirby: you do. it's called a runtime
09:32:12 <cronokirby> right, but when compiling you need to detect things that call out to the runtime right?
09:32:17 <dstolfa> cronokirby: exactly
09:32:23 <cronokirby> makes sense
09:33:08 <cronokirby> thx
09:34:52 <dsal> I was attempting to use lens to make some jsoning easier.  I'm not sure I've succeeded.  In particular, it's not currently obvious to me how to reach into a set of objects.    `j ^? key "x"` returns a Maybe which is an object in this case.  How do I reach into a key of that.
09:35:14 <dsal> i.e., I can't seem to mix lens and applicative sensibly.
09:36:26 <Taneb> «j ^? key "x" ^? key "y"»
09:36:43 <jle`> j ^. key "x" . key "y"
09:36:48 <Taneb> What jle` said
09:36:50 <jle`> er, j ^? key "x" . key "y"
09:36:59 <dsal> Oh, .  -- so obvious.
09:37:21 <dsal> I kept trying stuff like ^? and it kept laughing at me.
09:37:22 <jle`> it's only obvious once you know it
09:37:38 <dsal> Yeah.  I almost new lens once, but then I stopped doing haskell for a bit.
09:37:45 <jle`> but yeah, '.' is the lens composition operator
09:38:19 <jle`> > ((1,'c'),6) ^. _1 . _2
09:38:22 <dsal> I was looking all over for applicative mentions and stuff.  Lens is too dense to have a really great guide, I think.  Tiny library, endless reading.
09:38:22 <lambdabot>  'c'
09:38:47 <jle`> the lens introduction mentions composition of lenses with . :)
09:38:50 <jle`> and some other ncie fundamentals
09:39:10 <fendor> did someone try to use haskell-ide-engine in nix?
09:39:26 <dsal> Oh sure.  It's just the density.  That . is hard to see in any useful guide.  I just need more practice, I think.
09:39:36 <fakenullie> I've seen it
09:40:12 <fakenullie> https://hackage.haskell.org/package/lens-tutorial-1.0.3/docs/Control-Lens-Tutorial.html
09:41:54 <jle`> i like https://github.com/ekmett/lens/wiki/Overview
09:42:42 <dsal> Yeah... this is my second time using lens.  The first time, I started to really feel like I understood it.  Then I walked away for a while.
09:43:20 <jle`> just for some context, '.' can actually be considered "the" operator that the whole library is built around
09:43:29 <pfjdjo> Hello, I'm sorry to ask a python question because I was comparing some python syntax with haskell's.
09:43:47 <pfjdjo> In Python, list = ['a','b','c']
09:43:53 <pfjdjo> 'a' in list
09:43:55 <jle`> the other operators in the library are just for convenience, and most of them are actually just infix aliases of normal prefix functions
09:43:56 <pfjdjo> returns True
09:44:08 <pfjdjo> but why 'a' in list == True
09:44:11 <pfjdjo> returns False?
09:44:16 <pfjdjo> this confuses me
09:44:23 <jle`> probably is being parsed as 'a' in False
09:44:33 <ertes-w> dsal: if you don't think of lenses as an opaque concept, but consider that they are special types of traversals (literally the 'traverse' kind of traversal), then it should be much easier to remember how they work
09:44:51 <fakenullie> pdxleif: probably it compares list with True
09:44:55 <lavalike> 'a' in (list == True)     'a' in False     False
09:44:56 <jle`> as in, 'a' in (list == True)
09:44:57 <ertes-w> dsal: and a traversal is just "mapping with effects"
09:45:14 <jle`> the real question is why doesn't the type system stop you from typing something nonsensical like that
09:45:19 <ertes-w> dsal: mapFst :: (a -> b) -> (c, a) -> (c, b)
09:45:30 <ertes-w> dsal: traverseFst :: (Functor f) => (a -> f b) -> (c, a) -> f (c, b)
09:46:01 <pfjdjo> aha
09:46:04 <ertes-w> dsal: traverseFst happens to be a lens…  it's a mapping function, very similar to 'map', but it supports effects
09:46:09 <pfjdjo> Strange. Thanks.
09:46:46 <ertes-w> dsal: you could write its type as:  traverseFst :: Lens (c, a) (c, b) a b
09:46:48 <fakenullie> I think it's actually even worse, it's how python processes operators
09:47:04 <jle`> but i shouldn't be judging too much, we have things like 'length (1,2)' that you might originally haeve expected the types to stop
09:47:58 <ertes-w> dsal: and then it should be clear what (.) does:  how do you do nested maps?  for example how do you map 'f' over the inner elements of a list of lists?  answer: map (map f)
09:48:11 <ertes-w> dsal: which you can write as:  (map . map) f
09:48:29 <ertes-w> so (map . map) is the "mapping" that maps over the inner elements
09:48:59 <dsal> ertes-w: Thanks.  I think one of the things I learned is I need a lot more practice.
09:49:03 <fakenullie> pfjdjo: a op1 b op2 c ... y opN z  is equivalent to a op1 b and b op2 c and ... y opN z
09:49:24 <fakenullie> pfjdjo: so your expressions turns into 'a' in list and list == True
09:49:41 <ertes-w> dsal: similarly how do you map-with-effects 'f' over the right component of the right component of a nested tuple?  traverseFst (traverseFst f) = (traverseFst . traverseFst) f
09:50:04 <fakenullie> pfjdjo: ('a' in list) and (list == True)
09:50:09 <fakenullie> god, I hate python
09:50:10 <jle`> that's even more fun
09:51:11 <lavalike> :o
09:51:19 <ertes-w> dsal: if you want to gain a deeper understanding of lenses you should really just use 'traverse' more often =)
09:51:26 <ertes-w> especially with nested structures
09:51:58 <jle`> oh hey, when did hackage push the new stylesheets
09:52:39 <guessWHo> i have been learning haskell for a while now and now i have reached a point where i make thing work but not in the most pleasant way so is there any book or other resources on haskell good practices ??
09:53:11 <jle`> at that point, the best practice is probably to just do more projects
09:53:58 <Boarders_> guessWHo: give this a whirl: http://goalkicker.com/HaskellBook/HaskellNotesForProfessionals.pdf
09:54:34 <dsal> ertes-w: Thanks.  My last usage was kind of forced on me and not that complicated.  I'm getting more complicated in this usage.
09:56:23 <guessWHo> IO monad allow allow us to perform IO actions but how are they implemented at first place >? isn't a pure functional language should be isolated from outside world
09:57:03 <ertes-w> dsal: the key thing to understand is that 'traverse' is not the full story:  you can traverse anything, even the least significant bit of an Integer:  traverseLeastBit :: (Functor f) => (Bool -> f Bool) -> Integer -> f Integer
09:57:40 <ertes-w> dsal: and then of course you can nest:  traverse (traverseLeastBit f) = (traverse . traverseLeastBit) f
10:00:17 <amalloy> guessWHo: the saying goes that a program with no side effects at all isn't worth running: all it can do is heat up your CPU
10:00:39 <tdammers> amalloy: effects, yes; side effects, no.
10:00:49 <guessWHo> amalloy : i'm aware of that saying but
10:00:53 <Taneb> Front-and-back effects
10:01:08 <tdammers> Taneb: I prefer the term "special effects" :P
10:03:01 <guessWHo> amalloy : how the IO,STMs  and many other monads are implemented which are interacting with the outside words
10:03:13 <guessWHo> world*
10:08:47 <dsal> amalloy: to be fair, heating up the machine could be considered a side effect.  It's output, at least.
10:09:19 <fakenullie> it's a side channel
10:10:02 <fakenullie> but will be pure functional code evaluated?
10:12:07 <kuribas> How can I generate instances with TH, without having a circular dependency?
10:12:42 <kuribas> the TH depends on the class definition, but the instances depend on the TH.
10:13:00 <kuribas> If I put the instances in another module I get a warning about orphans...
10:13:37 <jle`> guessWHo: all IO functions etc. in Haskell are pure functions
10:13:49 <jle`> guessWHo: you purely assemble an IO action, call it main, and give it to ghc
10:14:02 <jle`> ghc then takes the IO that you describe, and compiles a program that does what you are describing
10:14:15 <jle`> guessWHo: so the pure functional part is how we *define* what action we want to do
10:14:34 <jle`> and the actual execution is up to whoever interprets our programs; in this case, ghc and a CPU
10:15:23 <jle`> guessWHo: so, the IO type is implemented so that it can describe IO in a pure way.
10:15:51 <guessWHo> jle` : what do you mean by "you purely assemble an IO action" >?
10:16:05 <jle`> guessWHo: for example, i can create an IO action that pritns "hello" by using the pure function putStrLn
10:16:09 <jle`> putStrLn :: String -> IO ()
10:16:33 <jle`> putStrLn takes a String and purely returns an IO action that describes the io of printing that string
10:16:41 <jle`> and we can use other pure combinators like (>>)
10:16:45 <jle`> (>>) :: IO a -> IO b -> IO b
10:16:52 <jle`> it takes two IO actions, and purely returns a new one
10:17:05 <masaeedu[m]> think of `IO` as an message describing what you wish to happen in the outside world
10:17:10 <jle`> so let's say I want to "desribe" an IO action that prints 'hello', and then prints 'world'
10:17:23 <Arney> somebody here having a cool utf8 expression for the y combinator?
10:17:23 <jle`> i would write myIoAction = putStrLn "hello" >> putStrLn "world" :: IO ()
10:17:59 <jle`> guessWHo: myIoAction is an IO action that i assembled purely (using pure functions putStrLn and (>>)), that *describes* the io of printing 'hello', then printing 'world'
10:18:27 <jle`> some program, like ghc, can then look at and inspect that action that i described, and then compile to machine code the action that it describes
10:18:36 <jle`> so in haskell, we don't ever "execute" IO
10:18:44 <jle`> we only *describe* it, for someone else to interpret and execute
10:19:18 <dminuoso> Arney: Ω for the omega comnbinator?
10:19:31 <Arney> dminuoso: do you ever sleep?
10:19:39 <dminuoso> I tried it once.
10:19:48 <Arney> how was it?
10:19:56 <jle`> guessWHo: IO is implemented as a data structure that can describe all sorts of IO actions, and can be easily manipulated and combined with itself, transformed, etc.
10:20:10 <jle`> but it is a pure data structure
10:20:12 <amalloy> Arney: "Y" fits that description
10:20:37 <jle`> guessWHo: the manipulation of a value of type 'IO a' is the pure manipultion of a pure data structure; it's the manipulation of a description of IO
10:20:48 <Arney> i mean the thing people like to tatoo themselves
10:20:52 <kuribas> Can I use TH in the same module where it's defined?
10:20:55 <Arney> can't dint that in utf8
10:20:58 <Arney> find*
10:21:05 <Cale> At least, you can imagine that it is, since it could be. In GHC, it's implemented with dirty hackery of course ;)
10:21:17 <jle`> as an abstract data type, its API is 100% pure
10:21:22 <Cale> yeah
10:22:39 <jle`> well, the 'official' api at least, heh
10:25:12 <guessWHo> jle` : so we describe and IO action and that IO action is performed by ghc but then i can say similary that  with printf i'm defining an IO action and gcc is performing it >? don't get me wrong i'm just not convinced and haven't developed that intuition
10:25:46 <jle`> well, printf in C isn't a first-class action
10:25:49 <jle`> you 'define' it using your text edit
10:25:51 <jle`> *or
10:26:01 <jle`> the closer analogy would be CPP
10:26:16 <jle`> sorry, i mean first-class value
10:26:42 <jle`> guessWHo: with IO, you can manipulate IO actions as first-class values, pass them to functions, modify them, transform them etc.
10:26:55 <masaeedu[m]> guessWHo: When you call `printf`, the action immediately occurs
10:27:18 <masaeedu[m]> when you compute an `IO`, nothing actually happens in the real world
10:27:30 <masaeedu[m]> you're just sitting with an IO, which you can throw away, or combine with other IOs, etc.
10:27:54 <masaeedu[m]> you may have noticed that at the top level you have an expression `main`, whose type is `IO`
10:29:10 <masaeedu[m]> this is saying: "do however much pure computation as you want without interacting with the outside world, in order to build an `IO` that reflects the changes you wish to visit upon the real world"
10:29:22 <guessWHo> jle` , masaeedu[m] : okay so when we have described IO actions how are those IO actions performed ?
10:30:13 <cocreature> guessWHo: they are executed by the runtime starting from "main"
10:30:34 <masaeedu[m]> they are only performed if they are combined into a further IO that is ultimately part of the definition of `main`
10:31:36 <cocreature> a good way to see that IO actions are first-class values is the fact that you can just write them to an MVar pass them to another thread and only then execute it in that thread
10:32:04 <masaeedu[m]> Once I compute a big `IO` and declare that this is `main`, my Haskell program is over. Now this `IO` will be taken by the Haskell runtime, and the computation from there on is no longer pure or well isolated from the world
10:32:32 <Psybur> Is something is left adjoint to a forgetful functor, does that that mean that instead of going from one category to another and losing part of its structure, it goes from one category to another and gains in structure? :D
10:33:05 <EvanR> sure
10:33:06 <guessWHo> cocreature : that's tricky coz similarly we can say that IO actions in c are performed by c runtime ??
10:33:10 <tabaqui1> Both ComonadApply and Divisable are presented as "contravariant Applicative" but Divisable has contrintuitive signatures
10:33:32 <tabaqui1> I mean tuple in definition of divide
10:33:46 <Psybur> SO a free functor is a functor that adds structure?
10:33:48 <EvanR> guessWHo: http://conal.net/blog/posts/the-c-language-is-purely-functional
10:34:30 <EvanR> Psybur: informally speaking yeah
10:34:33 <guessWHo> EvanR : why only c then all the languages will be functional >?
10:34:34 <Boarders_> Psybur: usually it is called a free functor and if you have such a thing Free : C -> D that is a way to make each C-object into a D-object in a 'minimal way' (minimal as in making nothing more true than you need to)
10:34:39 <tabaqui1> From the other side "contravariant Applicative" shoud be more rich class than "contravariant Monad", but ComonadApply implies Comonad
10:34:42 <EvanR> guessWHo: read the post?
10:34:44 <tabaqui1> where is the truth here?
10:35:14 <guessWHo> EvanR : i would when once i'm done with haskell's purity :P
10:35:27 <masaeedu[m]> guessWHo: Yes, you can say that c actions are performed by the c runtime, but there is no isolation between pure computation in your C code and the performance of those IO actions
10:36:08 <EvanR> there is isolation... between your C preprocessor program and the world :)
10:36:17 <EvanR> then the result is fed to the runtime
10:37:35 <masaeedu[m]> yes, but there are very few formalisms governing the construction of a C program
10:37:40 <masaeedu[m]> as a message to a runtime
10:37:42 <guessWHo> masaeedu[m] : what do you mean by that i mean i can have IO action anywhere in haskell code with do right ? so where is the isolation built into haskell >
10:37:44 <guessWHo> ??
10:38:08 <EvanR> were trying to think out of the box right now, and haskell IO is not really very formal itself
10:38:12 <Cale> guessWHo:  You can only run IO actions from inside other IO actions.
10:38:40 <masaeedu[m]> whereas there are a great many formalisms governing the construction of an `IO`, as a message to the Haskell runtime
10:38:47 <guessWHo> Cale : okay that's confusing and i have heard that first time can you give some example ?
10:38:48 <Cale> guessWHo: You can pass them around as inert values, or combine them from anywhere, but if you want the result of an IO action, you can only do that from inside another.
10:38:52 <EvanR> not sure about that
10:38:58 <Cale> For example, getLine :: IO String
10:39:11 <Cale> There's no way to write a nontrivial function IO String -> String
10:39:12 <masaeedu[m]> guessWHo: No, you actually may not have an `IO` anywhere inside haskell code
10:39:13 <masaeedu[m]> that's the point
10:39:36 <masaeedu[m]> unless you have an `IO` returning expression, you may not perform any `IO`
10:39:45 <EvanR> reverse :: [IO a] -> [IO a]
10:39:47 <masaeedu[m]> Any `IO`s incidentally evaluated in an expression that doesn't return an `IO` will simply be discarded and have no effect on the world
10:39:47 <Cale> (any such function would be a constant function, ignoring which IO action you gave, even, since there aren't really any ways to inspect IO actions themselves, and even if there were, it wouldn't be able to tell what the user typed)
10:39:50 <masaeedu[m]> (unless you use `unsafe*`, which you should avoid generally)
10:40:15 <EvanR> you can "have" IO, but you cant do I/O from anywhere
10:40:31 <Cale> guessWHo: We can write a function which takes a number and an IO action, and constructs an IO action which repeats the given one that many times
10:41:10 <Cale> Let's say, discarding the results to begin with
10:41:13 <Cale> times :: Int -> IO a -> IO ()
10:41:13 <masaeedu[m]> you could conceivably have a `inspectIO :: IO a -> String`, which computed some representation of the `IO`s internal structure
10:41:16 <masaeedu[m]> but again, this would not perform the action
10:41:26 <Cale> times n x | n <= 0 = return ()
10:41:45 <masaeedu[m]> if you passed in a `print "foo"` `IO`, nothing would happen except the conversion of its internal structure to a string
10:41:50 <Cale>           | otherwise = do x; times (n-1) x
10:42:35 <EvanR> the message "attack at dawn" vs. the general reading such message and beginning such preparations
10:42:39 <Cale> guessWHo: The difference between IO String and String is like the difference between /bin/ls and a listing of the files in your home directory.
10:43:47 <guessWHo> Cale : so what does this mean IO String ?
10:44:05 <Cale> That's the type of actions, which if you were to carry them out, would produce String results
10:44:26 <masaeedu[m]> in case you're getting confused about whether this is a "special rule" of some kind, it's simply a consequence of the fact that any `IO` that is ultimately performed must be rolled into the giant `IO` value that is `main`. If some function swallows up an `IO` value and never returns it, it will never become part of the`main` `IO`, by transitive property
10:44:29 <Cale> getLine isn't a String of course, because which string would it be? We don't know.
10:44:52 <Cale> It's an IO String, which is a description of how to get a String, by reading characters from the terminal.
10:45:17 <Cale> If we execute getLine, we'll obtain a different result each time -- whatever the user happens to type
10:45:31 <Cale> and we can only execute getLine from inside another IO action
10:45:48 <Cale> e.g.  do x <- getLine; putStrLn (reverse x)
10:46:08 <Cale> this is another IO action, of type IO ()
10:46:21 <EvanR> we can execute getLine as the first thing in the program, main = getLine >>= \x -> _, or somewhere down the line inside _
10:46:28 <Cale> It describes getting a line of text from the user, and then printing it out in reverse
10:46:47 <Cale> Right, in a compiled program, the action you define as main will be executed
10:47:02 <Cale> and in turn, it can be composed of simpler actions
10:49:34 <Cale> guessWHo: It's very important to realise that the execution of IO actions is a separate process from the evaluation of expressions.
10:50:26 <Cale> Evaluating an expression (which is typically done because something wants to pattern match on it) generally doesn't do anything user-visible -- it just computes the value which is the result, and warms up your CPU a bit.
10:50:35 <Cale> Even if that result is itself an IO action
10:50:49 <Cale> Only executing the IO action actually does anything.
10:51:50 <Cale> (Sort of like how loading /bin/ls from your disk in a hex editor won't accidentally cause a listing of files to get printed to the terminal)
10:54:48 <Psybur> Do you guys use Free a lot?
10:55:03 <guessWHo> Cale : the only argument which make sense is that Functions & IO are first class values , other than the point that with IO we are just describing IO actions and not actually performing action is quite unintuitive to be honest ?
10:55:43 <Psybur> Im wondering if I should default to using it when designing applications due to flexibility
10:55:47 <EvanR> guessWHo: you might see this a lot in other languages, if you were handling data that describe actions to do right?
10:56:24 <EvanR> {action: "sendEmail", payload: {subject:... body:..}, next: {action: ...} }
10:56:51 <EvanR> {action: "getLine", next: function(x){ return {action: ...}; }}
10:57:06 <EvanR> thats internally what IO is doing, spiritually speaking
10:57:21 <EvanR> you can juggle data like that all you want, and something can execute it
10:57:28 <Cale> guessWHo: Well, you can, as you're writing an IO action, think about what that action will be doing when it's executed, that's normal.
10:57:55 <Cale> guessWHo: But evaluation won't cause that execution to occur, so when you see, for instance, a function of type Double -> Double
10:57:55 <Psybur> I have a forex algotrader Im working on that can trade on a practice account, trade on a live account, and run a backtest. Im wondering if I can use Free to chain trades and then the different areas of my app can interpret differently
10:58:07 <Cale> You know that no IO can be occurring there.
10:58:09 <andrei> How can I convince coerce that two types are equal because of a set of associated types? I have data X x = X (Y x); class Z x where type Y x. When Y A ~ Y B, shouldn't X A be coercible to X B?
10:58:58 <Cale> andrei: It depends on the role of the type parameter...
10:59:23 <andrei> Cale: The role in which datatype?
10:59:54 <Cale> X
11:00:36 <andrei> Cale: I'm confused about why the role would matter here
11:02:11 <guessWHo> EvarR : "{action: "getLine", next: function(x){ return {action: ...}; }}" isn't that other way round reading a line is action and geLine a function
11:02:22 <EvanR> guessWHo: nope
11:02:38 <EvanR> IO a values are just data
11:02:39 <guessWHo> EvanR : what am i missing >?
11:02:56 <EvanR> also getLine is *not* a function
11:03:26 <masaeedu[m]> guessWHo: There's many benefits to separating out IO like this which may not be immediately obvious. One example is the fact that evaluation order is not important in most circumstances, and values can be computed lazily. This allows you to express things like computations over infinite lists with a simple and clear mental model. If every expression could carry side effects, the meaning of an expression would suddenly be
11:03:27 <masaeedu[m]> extremely dependent on the order in which otherwise equivalent subexpressions are evaluated.
11:03:37 <EvanR> sendEmail to subject body :: IO (), is NOT a function
11:05:30 <Ariakenom> does -fno-omit-yields work in ghci?
11:05:45 <guessWHo> EvanR : so what's the difference between say a :: Int -> IO () and a :: IO ()
11:05:46 <Cale> andrei: Suppose we have Coercible Int Dollars, and suppose Y Int = String, but Y Dollars = (). Then we don't have Coercible (Y Int) (Y Dollars), and so we won't have Coercible (X Int) (X Dollars).
11:06:11 <EvanR> guessWHo: one is a function returning IO (), the other is just an IO ()
11:06:25 <EvanR> and IO () is some data, not a function
11:06:27 <Cale> andrei: GHC doesn't know that the instances of Y preserve coercibility. If you want it to assume that, you can give a role annotation to X
11:06:40 <EvanR> it doesnt take any argument
11:06:52 <masaeedu[m]> neither of them actually causes any IO though
11:07:01 <Cale> guessWHo: Perhaps it would help if we implemented our own simple IO type with just some basic terminal IO
11:07:17 <EvanR> please dont confuse functions in other languages, which are imperative *procedures* with functions in haskell, which are all pure
11:07:36 <Cale> data MyIO a = Done a | PutStr String (MyIO a) | GetLine (String -> MyIO a)
11:07:52 <guessWHo> Cale : yeah let's do that :0
11:07:53 <guessWHo> :)
11:08:22 <Cale> So, looking at this type declaration, you can see that values of this type could be manipulated all we want, and nothing's going to be printed to the terminal.
11:08:48 <sm> __monty__: oh the labels, I see what you mean. I like em
11:08:49 <Cale> We could write a Monad instance for this
11:09:10 <Cale> and we could write:
11:09:16 <andrei> Cale: Ah. I see. Thanks!
11:09:26 <Cale> myGetLine :: MyIO String
11:09:34 <__monty__> sm: But the seperation from the body would be clearer with a crisp left margin.
11:09:37 <Cale> myGetLine = GetLine (\s -> Done s)
11:09:55 <Cale> myPutStrLn :: String -> MyIO ()
11:10:03 <sm> I feel the association with the field content is more important
11:10:21 <Cale> myPutStrLn x = PutStr (x ++ "\n") (Done ())
11:10:28 <sm> but we are probably seeing something different based on window geometry etc.
11:10:57 <__monty__> sm: I'm talking about the wide style, with the metadata on the side.
11:11:13 <__monty__> I like the narrow style, except for the colors.
11:11:23 <Cale> We can define (>>=) recursively by pattern matching
11:11:34 <Cale> Done x >>= f = f x
11:11:58 <Cale> PutStr s x >>= f = PutStr s (x >>= f)
11:12:20 <Cale> GetLine k >>= f = GetLine (\s -> k s >>= f)
11:13:23 <fendor> > map (+1) [1..10]
11:13:23 <Cale> Does that code make sense, or does it need some more explanation?
11:13:26 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
11:13:37 <fendor> @info map
11:13:38 <lambdabot> map
11:14:07 <Cale> The idea is basically that if the MyIO action is Done x, that's supposed to represent an action which does nothing except produce x as its result, so we just apply f to it in that case
11:15:18 <Cale> and if it's anything else, well, the way we've encoded the actions is always so that the first thing to be done is the outermost constructor, so we build a new action with the same constructor, but push the bind inward to the continuation bit
11:16:19 <Cale> If it's not clear, the constructors of this type generally take the parameters to our primitive actions, and then take a continuation which will either just be a simple action, or more generally, will be a function from the result of our primitive to another action
11:16:30 <Cale> (i.e. how to decide what to do next after this)
11:17:25 <Cale> guessWHo: So then we can write an executor which turns a MyIO action into an IO action
11:17:33 <Cale> execute :: MyIO a -> IO a
11:17:39 <Cale> execute (Done x) = return x
11:18:05 <Cale> execute (PutStrLn s x) = do putStrLn s; execute x
11:18:24 <Cale> execute (GetLine k) = do s <- getLine; execute (k s)
11:18:28 <maerwald> everyone will want to watch that execution
11:20:24 <Psybur> maerwald, who gets to be the executioner?
11:20:25 <frerich> Cale: Minor nitpick; 'MyIO' had no 'PutStrLn' so far, just 'PutStr' (I noticed this because I was trying to implement Functor/Applicative/Monad for your 'MyIO' type and then comparing my definitions with what you wrote)
11:21:09 <Cale> oh sorry
11:21:11 <Cale> yeah
11:21:24 <Cale> I forgot how I defined it already :D
11:21:35 <Cale> Just replace that line with one that doesn't have Ln in two places :D
11:24:45 <frerich> I always get confused by this; the instances for Functor and Monad are easy, but for Applicative: do I really need to write out the 9 different cases for (<*>) since both arguments are of type MyIO (and thus can be one of three different values)?
11:24:53 <frerich> I must be missing something simple here...
11:25:46 <EvanR> you can implement Applicative in terms of Monad
11:25:57 <EvanR> :t ap
11:26:00 <lambdabot> Monad m => m (a -> b) -> m a -> m b
11:26:25 <EvanR> thats one way out
11:27:05 <dyl_> Just checking in to see if anyone understands confluence yet.
11:27:10 <dyl> Hm.
11:27:15 <dyl> There we go.
11:28:27 <Cale> dyl: are you memeing, or did you actually want to know something about it?
11:28:34 <dyl> Cale! <3
11:28:48 <dyl> I wouldn't call in memeing, but, moreso that than a real question.
11:29:37 <Ferdirand> about this MyIO thing
11:29:49 <Ferdirand> can we get the monad implementation for free out of the Free monad or something ?
11:29:52 <Cale> yes
11:30:10 <Cale> this is just a free monad, with the definition of Free and the chosen functor sort of flattened together
11:31:35 * dminuoso weeps as he still does not understand what a free monad is
11:31:51 <Cale> Well, it's like one of these things
11:31:59 <Cale> Only with arbitrary different commands
11:32:06 <Cale> We can generalise this setup like this:
11:32:22 <Psybur> dminuoso, its like what a list is for monoids :D?
11:32:22 <EvanR> step0 understand the concrete example above
11:32:36 <Cale> data Free f a = Done a | Step (f (Free a))
11:32:55 <EvanR> step1 understand the abstract version Cale is about to blow your mind with
11:33:14 <Cale> and then whenever f is a functor, this will give us a monad
11:33:55 <Psybur> From my understanding its just a sequence of functors to be interpreted at a later time right
11:34:01 <guessWHo> Cale, EvanR, masaeedu[m]  and everyone else thank you so much guys for  all of your efforts but i still have my doubts but i appreciate your efforts guys i think i'm need to digg more deeper into haskell and also category theory
11:34:08 <Cale> We can write something like  data MyIOF k = PutStr String k | GetLine (String -> k)
11:34:31 <Cale> guessWHo: What in particular are you doubting?
11:35:44 <guessWHo> Cale : the notion that IO actions are just instructions for actual IO actions and not IO action themselves
11:35:53 <Cale> Well, IO actions are themselves...
11:36:18 <EvanR> guessWHo: is awesome?
11:36:31 <EvanR> programs that handle programs man
11:36:37 <Cale> But when you write getLine in a Haskell program, it doesn't necessarily cause a line to immediately be obtained from the user.
11:36:45 <dyl> One slightly different way you can think of it: IO actions are instructions for an "IO virtual machine", and your base program is producing and sequencing some program targeting this "IO machine".
11:36:49 <Cale> We can write a list of IO actions:
11:37:02 <c_wraith> guessWHo, at an implementation level, IO actions (in ghc) are procedures like you'd have in any other language. the interesting part is haskell making them values with no* direct ways to execute.
11:37:22 <Cale> [getLine, return "Hello", readFile "/etc/passwd"]
11:37:28 <Ferdirand> so, if you write MyIO as Free MyIOF, when it comes to write execute
11:37:57 <guessWHo> dyl : but aren't all programming languages doing that ?>
11:38:03 <Cale> and we can later pick out the second action in that list and just run that one
11:38:18 <Ferdirand> do you have to write it directly over MyIO or is there a trick involving writing a helper over MyIOF and using something from Free ?
11:38:24 <c_wraith> guessWHo, making IO a first-class type has useful consequences, though. IO (IO foo) is a meaningful and useful type.
11:38:26 <dminuoso> Psybur: What exactly is a list for monoids? ;o
11:38:51 <dyl> guessWHo you could say that mental model is generally useful, but in Haskell it's first-class.
11:39:06 <dyl> The "instructions" of the "IO Machine" are reified values.
11:39:10 <c_wraith> guessWHo, you lose things like that if IO actions get executed implicitly.
11:39:10 <dyl> They're not just a conceptual model.
11:39:46 <dminuoso> guessWHo: Some people like top call `IO a` objects "strategies to produce a result of type `a`" which is the mindmodel that helped me understand things like getLine :: IO String
11:39:47 <Myrl-saki> WTF
11:39:53 <Myrl-saki> Since when did Hackage get a makeover
11:40:00 <Myrl-saki> Sweet jesus, that looks so new.
11:41:27 <phadej> ~today noon
11:41:28 <cocreature> Myrl-saki: today
11:41:35 <Cale> I'm not sure how I feel about the colour scheme
11:41:39 <MarcelineVQ> color-wise it's harder to read for me but it is fresh looking :>
11:41:48 <Myrl-saki> MarcelineVQ: Yep. I agree. And I even like purple.
11:41:58 <guessWHo> c_wraith : IO is defined in some haskell module or it's defined in GHC itself >?
11:42:02 <Myrl-saki> Layout-wise seems good though.
11:42:12 <ongy> I don't like change :0
11:42:14 <Myrl-saki> phadej: cocreature Thanks.
11:42:19 <Myrl-saki> ongy: That's my first thought too. :P
11:42:28 <ongy> but it makes more sense on a wide output
11:42:36 <MarcelineVQ> ongy: how do you feel about continuous transformations?
11:42:58 <__monty__> It's terrible to read for people with color vision, can only be even worse for people with colorblindness.
11:43:05 <c_wraith> guessWHo, it's defined in a ghc-specific module in terms of lower-level primitives ghc provides
11:43:10 <dyl> guessWHo IO is very tightly bound to the compiler.
11:43:11 <Psybur> dminuoso, the list instance for Monoid basically just delegates the actual "flattening" logic to the underlying type :D?
11:43:15 <Cale> I would prefer a darker purple to this lavender/mauve thing
11:43:16 <MarcelineVQ> ongy: sorry I shouldn't be joking just now, people are discussing things
11:43:20 <dyl> Cale agreed.
11:43:21 <ongy> if it's a moving target, so be it ^^ you know, a body in motion
11:43:28 <c_wraith> guessWHo, other compilers might implement it differently.
11:43:35 <cocreature> __monty__: afaik the colors have been specifically chosen to be compliant with some accessibility guidelines
11:43:40 <dminuoso> Psybur: the list instance for monoid? say what?
11:44:06 <dyl> cocreature the color in the banner is fine, but the use of very light mauve for the headers is a little disconcerting, considering the intensity of the link color.
11:44:06 <__monty__> cocreature: Hard to believe, since it's all shades of the same color.
11:44:15 <dyl> headings*
11:44:19 <guessWHo> c_wraith : if it's tightly bound to compiler than its not that complicated or unintuitive as  it is just an abstraction
11:44:21 <Myrl-saki> Does the author of structured-haskell-mode come here?
11:44:25 <dyl> Imo, it deemphasizes the headings and throws off the rhythm of the page.
11:44:34 <ongy> oh the header isn't black? I didn't even notice that o.0
11:44:36 <dyl> It's difficult to read linearly without your eyes being drawn to the links in the body of each section.
11:44:46 <Cale> Unless Haskell documentation is supposed to simultaneously be a 14 year old girl's blog about kittens... which... might actually be a good way to get some documentation written.
11:44:58 <cocreature> Myrl-saki: haven’t seen him in quite some time. he used to hang out here years ago
11:45:03 <Myrl-saki> cocreature: Ah. Thanks.
11:45:19 <Psybur> dminuoso, I might be getting my terminology mixed up. https://stackoverflow.com/questions/13352205/what-are-free-monads/
11:45:41 <Psybur> The first answer gives the list/monoid, free/functor analogy
11:46:04 <c_wraith> guessWHo, at a low level it's all things you're used to from other languages. the interesting part is the IO interface and using it as the core of system interaction in Haskell programs, instead of the lower-level bits.
11:46:33 <dminuoso> Psybur: Oh. So the monoid instance for lists!
11:46:35 <dminuoso> ;-)
11:46:35 <dyl> Cale the documentation has to use a purple sparkling lambda cursor though.
11:46:42 <dyl> With a trailing unicorn that chases the lambda.
11:46:50 <Psybur> Heh, yeah thats what I meant!
11:46:54 <ongy> Cale: soo, do I have to update my haddock comments with ascii art kittens now? o.0
11:47:30 <Cale> dyl: My coworker says it needs more bows
11:47:32 <guessWHo> c_wraith : yeah as i said if it's tightly bound to compiler than it's just an abstraction or mental model, i was thinking that IO is defined on top of haskell itself
11:47:41 <dyl> Example of what I mean about vertical rhythm and focus: https://imgur.com/a/nxo55
11:47:51 <dyl> Just swapping the link and header color (which is not good) as an illustration.
11:47:55 <dyl> link and heading*
11:48:10 <cocreature> ongy: you can probably use mathjax to make even prettier kittens!
11:48:32 <cocreature> dyl: instead of complaining here, consider making an issue on the hackage-server repo or even better a PR :)
11:48:35 <ongy> cocreature: will they render in vim while I edit the file? :)
11:48:38 <Myrl-saki> Sweet Jesus. After using C for literally 6 months+, Haskell looks so weird.
11:48:38 <hyperisco> override backgrounds to black and text to green and don't worry about it
11:48:40 <EvanR> guessWHo: when its an abstraction, then it doesnt matter how its implemented, and you can pick your preferred model that satsifies the abstraction
11:48:45 <dyl> cocreature it's not a complaint, just a critique :p.
11:49:01 <cocreature> dyl: nevertheless, I think it’s valuable but here it will just get lost
11:49:01 <dyl> Myrl-saki you ever written Prolog..?
11:49:06 <Myrl-saki> dyl: Yep. :P
11:49:13 <EvanR> that works for many things, not just whats built into the compiler
11:49:20 <Myrl-saki> I have a feeling it's my API that's shit.
11:49:48 <__monty__> cocreature: I've actually complained both on the original issue and on reddit and been ignored, hence complaining here's the only avenue I have left ; )
11:50:23 <dyl> guessWHo to give a supporting example of what EvanR means, consider undefined behavior in C. Much of it is not undefined out of laziness, but because the lack of definition frees up the compiler to perform more aggressive transformations.
11:50:36 <__monty__> I'll probably just restyle with usercontent.css, sad that the default's form over substance though.
11:50:37 <dyl> Generality and non-definition have concrete advantages in some cases,
11:50:42 <dyl> just as specification does in others.
11:50:54 <Myrl-saki> dyl: To be fair, there *are* undefined due to laziness.
11:51:07 <dyl> Oh yeah, that's why I said "much of it", hahaha.
11:51:12 <EvanR> i think i was thinking the opposite direction from that
11:51:43 <EvanR> its already implemented some way, but i either dont know how or dont care because i am presented with a proper abstraction
11:51:57 <dyl> In theory you shouldn't have to, yeah.
11:52:04 <dyl> In practice, non-leaky abstractions are unicorns.
11:52:23 <EvanR> you can just choose not to care about more and more things in real life, like my ex wife
11:52:29 <dyl> :(
11:52:35 <dyl> or :), not sure.
11:52:36 <EvanR> just kidding
11:52:38 <dyl> Undefined behavior.
11:52:54 <dyl> ∃ emotion s.t. emotion ∈ reply
11:52:58 <dyl> Let's leave it at that.
11:53:55 <guessWHo> EvanR : right, if it's abstraction it could be anything, all this fuss and it turns out it's just a mental model just a fucking abstraction
11:54:16 <EvanR> just a fucking abstraction, whats the problem
11:54:59 <EvanR> guessWHo: actually we value proper abstractions here, in other systems you might find lip service about abstraction, then find its worthless because of how it doesnt live up
11:55:17 <EvanR> the way IO works you saw here is exactly how you can think of it
11:55:18 <dyl> I mean... I would argue lazy IO is one of those abstractions.
11:55:27 <EvanR> right
11:55:33 <dyl> It sounds great on paper until you use it heavily enough, and then you need to rethink your program.
11:55:52 <EvanR> lets not talk about "lazy IO"
11:55:57 <EvanR> for now
11:55:59 <dyl> Better not to.
11:56:35 <guessWHo> EvanR : but then again when i think about why there is so much fuss about purity in haskell i mean all other language functions similarly if you see you have instruction which define IO actions and then compiler does all the magic i only benefit i see here is that here IO along with functions are first class values
11:56:52 <dyl> In general, abstractions in Haskell are proper and well-behaved enough that you *don't need to worry about the implementation* until you're doing some very weird stuff.
11:57:05 <dyl> You can put your faith in the abstraction.
11:57:07 <EvanR> guessWHo: the difference is, other languages dont give you the first class actions
11:57:41 <EvanR> what you write is stuck that way
11:57:42 <dyl> A concrete example: in haskell you could build up a [IO a] and then reorder them explicitly in some manner before they're executed.
11:57:57 <dyl> You can work with IO actions as reified values. Boil em, mash em, stick em in a stew.
11:58:11 <guessWHo> EvanR : yeah i said that, so that's the only difference ??
11:58:18 <EvanR> operationally yeah
11:58:31 <dminuoso> guessWHo: There's another massive difference.
11:58:33 <dyl> IO action reification is a pretty big difference denotationally though.
11:58:43 <dyl> It changes the way you write programs substantially.
11:58:46 <dminuoso> guessWHo: By representing IO this way, side effects are tucked into your type system.
11:58:57 <Myrl-saki> I'm kinda stupid.
11:59:12 <Myrl-saki> `:: Lens' a b -> m a -> m b`
11:59:13 <dminuoso> guessWHo: Which means suddenly you get to reason about effects from a pure type perspective. Something has the shape `String -> String` - then you can be sure that it doesn't have any effects whatsoever.
11:59:15 <Myrl-saki> Err
11:59:16 <EvanR> yes, if you are writing a "non-IO" program, you know its not having side effects or checking the phase of the moon
11:59:22 <Myrl-saki> :: Functor f => Lens a b -> f a -> f b
11:59:31 <maerwald> dminuoso: IO is not very "reasonable"
11:59:32 <EvanR> or (reading)
12:00:08 <guessWHo> dminuoso : but what about IO String -> String then there is side effect >?
12:00:30 <dminuoso> guessWHo: Such a function doesn't exist.
12:00:37 <EvanR> what it exists
12:00:42 <EvanR> guessWHo: no side effect
12:00:46 <dminuoso> (Well you kind of can backdoor this in)
12:00:52 <dyl> :t unsafePerformIO
12:00:53 <EvanR> \_ -> "foo"
12:00:54 <lambdabot> error: Variable not in scope: unsafePerformIO
12:00:54 <Myrl-saki> dminuoso: `const ""`? :P
12:01:00 <dminuoso> dyl: lets not get into that :P
12:01:06 <EvanR> silly geese
12:01:08 <dyl> Yeaaaaah, best not to.
12:01:20 <cocreature> unsafeCoerce also has the right type!
12:01:22 <dyl> If it says "unsafe", it will lead you astray and break your heart </3.
12:01:27 <dminuoso> cocreature: haha =)
12:01:37 <ongy> ghci has one of those, doesn't it? :)
12:02:03 <dminuoso> guessWHo: IO is one of those things that you normally can't unwrap, and that's a good thing because it ensures String -> String is pure.
12:02:04 <EvanR> guessWHo: note that whether or not it returns IO, functions are all pure. and this has value for confusing long term complacent programmers
12:02:08 <ongy> guessWHo: it would probably be  String -> IO String, or IO String -> IO String in the wild
12:02:10 <dminuoso> guessWHo: i.e. you can't make an IO disappear.
12:02:20 <dminuoso> If something has an effect, then its in the type system.
12:02:21 <Myrl-saki> Just a quick sanity check. How many of those talking here use Lens regularly?
12:02:32 <cocreature> % unsafeCoerce (pure "hello world" :: IO String) :: String
12:02:32 <yahb> cocreature: "[Segmentation fault]
12:02:35 <cocreature> \o/
12:02:51 <cocreature> Myrl-saki: I do
12:02:53 <guessWHo> dminuoso : why doesn't it exist i mean what is signature for a function which takes seek Input from terminal and produces a Stirng
12:02:54 <dminuoso> cocreature: Interesting. so unsafeCoerce turns "hello world" into "[Segmentation fault]"
12:03:00 <dyl> You're trying to coerce an interned token representing the IO action into a string :p.
12:03:01 <ongy> but, but, but, I was told there are no segfaults in Haskell o.0
12:03:03 <EvanR> % unsafeCoerce (pure "[Segmentation fault]" :: IO String) :: String
12:03:04 <yahb> EvanR: "[Segmentation fault]
12:03:06 <EvanR> better
12:03:12 <Myrl-saki> EvanR: lol
12:03:14 <Myrl-saki> Oh right.
12:03:14 <dyl> haha
12:03:15 <cocreature> EvanR: nice!
12:03:23 <lavalike> that's missing a closing quote
12:03:23 <Myrl-saki> Dammit. I should change my `return` to `pure`
12:03:25 <dminuoso> guessWHo: lose the word `function`
12:03:27 <ongy> % unsafePerformIO (pure "[Segmentation fault]" :: IO String) :: String
12:03:28 <yahb> ongy: "[Segmentation fault]"
12:03:29 <dminuoso> guessWHo: IO String
12:03:30 <Myrl-saki> EvanR: Thanks for the reminder. :D
12:03:34 <dminuoso> guessWHo: functions dont do things in Haskell.
12:03:46 <dyl> so if unsafeCoerce (pure "[Segmentation fault]" :: IO String) :: String === unsafePerformIO (pure "[Segmentation fault]" :: IO String) :: String...
12:03:47 <dyl> ;)
12:04:00 <Myrl-saki> pure is also cleaner.
12:04:04 <Myrl-saki> s/cleaner/shorter/
12:04:10 <guessWHo> dminuoso : what do things in haskell then >
12:04:32 <dminuoso> ^- Ill refer that back into the channel because I dont want to be inaccurate.
12:05:21 <cocreature> I’ll have to try that sometime. make provocative statements and then let the channel justify them for me :)
12:05:46 <guessWHo> dminuoso : a <- getLine does this have side effects ?
12:05:59 <dminuoso> cocreature: Heh!
12:06:02 <EvanR> its not a complete program
12:06:08 <dminuoso> guessWHo: Think of `IO String` as a piece of paper with instructions for the runtime. That paper itself doesn't _do_ anything. But the runtime that executes your `main :: IO ()` gets hold of your `getLine :: IO String` paper, it will execute the instructions.
12:06:14 <EvanR> getLine >>= \x -> ?
12:06:16 <noipmups> Hello, how to, within QuickCheck, check that two Floats are close to each other?
12:06:19 <ongy> guessWHo: yes. It reads from a file descriptor
12:06:30 <EvanR> does
12:06:31 <dminuoso> guessWHo: It's the implementation of >>= for IO that contains the magic to *do things*
12:06:32 <Myrl-saki> dminuoso: In the same way, a C source code is technically pure. :P
12:06:41 <EvanR> dminuoso: noooo
12:06:48 <dminuoso> EvanR: no?
12:06:51 <EvanR> Myrl-saki: yeah i posted the conal post
12:07:07 <EvanR> dminuoso: >>= simply links actions togerher
12:07:11 <EvanR> together
12:07:14 <EvanR> we just went over all that
12:07:19 <dminuoso> EvanR: Oh. My apologies. Wrong mind model. :(
12:07:22 <ongy> guessWHo: So the side effect here is one that changes some outside things. In the Haskell sense, there's also sideeffects, that are a bit less intuitive. When they are read-only on some state that can change over time.
12:07:24 <dminuoso> Well. piece of paper analogy!
12:07:26 <EvanR> its like concatting a list
12:07:37 <dminuoso> EvanR: Yeah my apologies, I was thinking wrong.
12:08:22 <guessWHo> so how impure code and pure code is seperated in haskell ?
12:08:30 <Myrl-saki> guessWHo: Every code is pure in Haskell.
12:08:36 <Myrl-saki> (IIRC)
12:08:51 <Cale> Well, the execution of IO actions isn't pure
12:08:58 <Cale> Their evaluation is pure
12:09:00 <cocreature> evaluation is pure, execution of IO actions by the Haskell runtime is not
12:09:02 <Myrl-saki> Cale: Right, but that's outside of Haskell, in a sense.
12:09:04 <dminuoso> guessWHo: `IO String` is a pure object. It's a piece of paper that has impure actions scribbled on it.
12:09:08 <Cale> I don't really agree
12:09:17 <Cale> Evaluation of Haskell expressions is pure
12:09:19 <dminuoso> guessWHo: That piece of paper doesnt do anything. But when the runtime is forced to evaluate it, *stuff happens*
12:09:33 <Psybur> :t foldFree id $ liftF (+1) >> liftF (+2)
12:09:36 <lambdabot> error:
12:09:36 <lambdabot>     • Variable not in scope: foldFree :: (a0 -> a0) -> m0 b0 -> t
12:09:36 <lambdabot>     • Perhaps you meant ‘foldTree’ (imported from Data.Tree)
12:09:38 <Cale> But execution of IO actions, which is part of what Haskell is, and which is a separate process from that, isn't pure.
12:09:45 <EvanR> when the runtime *executes* it stuff happens
12:10:10 <EvanR> we can evaluate something to add or mov instructions all we want and nothing happens
12:10:21 <Psybur> @let import Control.Monad.Free
12:10:23 <guessWHo> Cale : but say i'm reading a file in that case content of file can change so how come its pure all the time ?
12:10:24 <lambdabot>  Defined.
12:10:29 <Psybur> :t foldFree id $ liftF (+1) >> liftF (+2)
12:10:31 <lambdabot> Num a => a -> a
12:10:47 <Psybur> How come when I try to apply say 2 to that, I get an error
12:10:48 <Cale> guessWHo: If you have an expression like readFile "foo" and you evaluate it, nothing happens. In particular, the file isn't read.
12:10:52 <Psybur> > foldFree id $ liftF (+1) >> liftF (+2) $ 2
12:10:55 <lambdabot>  error:
12:10:55 <lambdabot>      • Could not deduce (Num t0)
12:10:55 <lambdabot>        from the context: (Num (Free m a), Num t, Monad m,
12:11:16 <Cale> guessWHo: Only if the IO action value which is the result of evaluating that expression is *executed* will the file be read.
12:11:33 <guessWHo> dminuoso : then same goes for all procedural languages what's special about haskell other than first class treatment
12:11:46 <Cale> guessWHo: Only IO actions can specify that other IO actions should be executed, and then in a compiled program, main is executed.
12:11:49 <Myrl-saki> This reminds me, when lens, the library was made, was the hierarchy already established or did it develop overtime?
12:12:09 <dminuoso> guessWHo: A function `String -> String` is guaranteed to not have any effects.
12:12:18 <Cale> guessWHo: Execution can cause evaluation to occur (because you might need to pattern match in order to decide what action to take next)
12:12:20 <guessWHo> Cale : so that part is impure ?
12:12:21 <exarkun> guessWHo: "ignoring Haskell's abstractions over how a computer executes instructions, what's the difference between Haskell and any other language?"
12:12:21 <EvanR> guessWHo: when you evaluate x++ in C... stuff happens
12:12:25 <Psybur> > (foldFree id $ liftF (+1) >> liftF (+2)) 2
12:12:25 <Cale> guessWHo: But not the other way around.
12:12:26 <c_wraith> Myrl-saki, go look at old versions of the docs. hackage keeps them around!
12:12:28 <lambdabot>  4
12:12:30 <dminuoso> guessWHo: And conversely, if it produced an effect `IO String`, that doesn't run unless you somehow carry it back into your main :: IO ()
12:12:32 <exarkun> guessWHo: well guess you saw through the trick
12:12:32 <Cale> Yeah, execution of IO actions is impure
12:12:33 <EvanR> so its not the same in all languages
12:12:43 <Cale> But you can't just execute IO actions from anywhere
12:12:56 <c_wraith> Myrl-saki, (but no, the hierarchy changed immense in the first few major versions)
12:12:57 <exarkun> Haskell is definitely the same as writing native machine code.  Except for the abstractions.
12:13:03 <Cale> So if you're writing a function String -> String, it's not allowed to read and write to the network, for instance.
12:13:09 <Myrl-saki> c_wraith: Ah, thanks. :P
12:13:14 <EvanR> haha
12:13:31 <dminuoso> guessWHo: So `IO String` doesnt do anything, unless you somehow forced it into your `main :: IO ()`. And `String -> String` _CANT_ do anything, because there's no `IO a` effect to carry back into `main :: IO ()`
12:13:34 <guessWHo> dminuoso : so you mean same function in python is not consistent ? this philosophy of functional programming i have hard time digesting even after using haskell for 2 months now
12:13:57 <EvanR> linking and carrying back to main :: IO () seems like a red herring...
12:14:24 <exarkun> guessWHo: If you call a function in Python, does it have a side-effect?
12:14:28 <EvanR> all IO action expressions everywhere and valid
12:14:38 <EvanR> are valid*
12:14:49 <EvanR> they mean the same thing in each case, regardless of context
12:14:57 <dminuoso> EvanR: well my point is, it doesnt run unless you sequence it into your `main` (things like unsafePerformIO or ST aside)
12:15:12 <EvanR> more like... by convention... *main* is what you execute
12:15:18 <guessWHo> exarkun : according to me if it's without IO it guaranteed to return same result for a given input all the time yes
12:15:26 <exarkun> guessWHo: How do you know it's without IO?
12:15:36 <ongy> guessWHo: IMO the main advantage that we get, is that it's in the type system. There are a few things (some optimisations, some apis) that would need *huge* warning signs otherwise.
12:15:43 <EvanR> but you can imagine executing any IO action on the machine and getting the result in your hand
12:15:47 <dminuoso> EvanR: What Im trying to say is, if you have some function that does say `Int -> (Int, IO ())` and you somehow lose track of that `IO ()`, then it won't be executed.
12:15:51 <guessWHo> exarkun : coz i'll be the one writing function
12:15:54 <dminuoso> EvanR: Dunno how I could have phrased that better.
12:15:56 <EvanR> omg stop trying to say stuffQ
12:16:05 <Psybur> Could I use Free to chain together partially applied arithmetic functions and then use foldFree to compose them all?
12:16:09 <exarkun> guessWHo: This is the difference.
12:16:18 <dyl> Basically IO actions are prayers and the GHC runtime is a god who responds to all prayers. But it works in mysterious ways.
12:16:26 <exarkun> guessWHo: In Python, you know if a function does IO or not because you have memorized the source for all functions.
12:16:26 <EvanR> lol
12:16:30 <dminuoso> EvanR: me?
12:16:41 <exarkun> guessWHo: In Haskell, you know if a function does IO or not because of the type system.
12:16:44 <Myrl-saki> Fucking hell, my Haskell is so shitty.
12:17:11 <dyl> Here’s another way to look at it, flipping it around: what would happen if Haskell DID NOT use IO actions?
12:17:27 <dyl> What would the effects be on referential transparency and optimization thereof?
12:17:28 <EvanR> it would be an awesome calculator
12:17:32 <exarkun> guessWHo: Some people find this useful.  For example, it makes it easier to use a function that you didn't memorize.  Maybe even because someone else wrote it.
12:17:32 <ongy> lazyness would break a few things
12:17:44 <dyl> It’s often helpful to consider the motivating problem before the solution.
12:17:54 <dyl> Or, a motivating problem*
12:17:55 <EvanR> haskell at one time did NOT have IO actions
12:17:58 <dminuoso> dyl: You're at imperative languages. The compiler tries to prove whether things are referentially transparent, and optimize if it can, and not optimize if it cant?
12:18:10 <EvanR> and it was awful
12:18:11 <dyl> I’m not sure what you’re asking.
12:18:29 <dyl> e.g. the best way to explain complex numbers is to pose the question of solving x^2 + 1 = 0
12:18:43 <Myrl-saki> EvanR: `:: [Response] -> [Request]`?
12:18:46 <dyl> The best way to explain IO is to pose the question of how you resolve referential transparency and the need for doing IO.
12:18:52 <EvanR> that is what i am told
12:19:03 <ongy> at the dark times where it was a library to use from C. or so I heard
12:19:04 <EvanR> as backwards as that looks
12:19:37 <guessWHo> exarkun : that doesn't even make sense i mean at the end of the say just by looking at the code i can say weather IO will be performed or not
12:19:37 <Myrl-saki> ongy: Embedded Haskell sounds awesome TBH.
12:20:06 <dyl> The Before Times should not be spoken off outside of the consecrated sanctum to the uninitiated.
12:20:08 <exarkun> guessWHo: Sure.
12:20:12 <ongy> Myrl-saki: think more on the lines of foreign export pure functions then compiled into an .so or .a
12:20:17 <exarkun> guessWHo: How much time do you want to spend on that?
12:20:28 <dyl> The Before Times were a dark period, and their insidious echoes through history still crash against our shores.
12:20:30 <mnoonan_> guessWHo: "def not_really(s): return eval(s)"
12:20:39 <exarkun> guessWHo: Do you want to read 5000 lines of someone else's source code every time you try to call a function from a library?
12:20:57 <exarkun> mnoonan_: yea but even Haskell has unsafePerformIO.
12:20:59 <EvanR> have you tried ruby?
12:21:03 <Myrl-saki> ongy: oh god no
12:21:04 <dyl> exarkun: or more succinctly “do you want to write JS forever”
12:21:11 <Myrl-saki> ongy: I thought you meant like Lua.
12:21:23 <mnoonan_> exarkun: yes, true.
12:21:50 <ongy> guessWHo: I prefer when my computer yells at me for failing to see this, over things going wrong at some weird point. It's the reason I like static type systems in general, and don't want python to hopefully tell me about an error when a testcase lucked into that
12:21:53 <dminuoso> guessWHo: Also you have to check every lien of source code in the _entire_ call tree of that function.
12:22:26 <ongy> You *can* do all by hand, but static guarantess your compiler can prove are a bit different
12:23:05 <exarkun> It's cool when computers do more work so I can do less work.
12:23:07 <EvanR> guessWHo: are you asking why use types?
12:23:08 <ongy> Myrl-saki: I haven't been around at that time (tbh. I don't even know if i was even born), but that's how I understood it from the pages about "old" haskell I read
12:23:19 <Ferdirand> guessWHo: consider a function f x = foo (bar x) (bar x), where bar is a very expensive computation
12:23:25 <cocreature> expressed differently, we use Haskell not because we’re super smart but because we’re dumb and want the compiler to help us :)
12:23:38 <guessWHo> dminuoso : those are all just advantages that doesn't the question that how purity is not there in non functional languages what is this paranoia if function not returning same value for a given input ??
12:23:41 <Myrl-saki> ongy: Same here.
12:23:45 <Ferdirand> is it correct to define f x = let y = bar x in (foo y y) ?
12:24:04 <exarkun> guessWHo: It's not paranoia if they're really out to get you.
12:24:16 <dminuoso> guessWHo: It enables a) aggressive optimization, and b) easy refactoring.
12:24:44 <Myrl-saki> ongy: Kinda interesting that "newer"(Python and Haskell) languages  are actually pretty old.
12:24:48 <exarkun> guessWHo: Most real world programs written in most languages have real, impactful bugs that worsen real user interactions due to functions that return different results when called with the same arguments.
12:24:51 <guessWHo> exarkun,dminuoso : see if i have a add function in python it will always return the sum of two numbers right ??
12:25:03 <Myrl-saki> I wonder what other languages llook new but are actually old.
12:25:04 <exarkun> guessWHo: I don't know.
12:25:08 <dminuoso> guessWHo: If your function `foo` does a sneaky API call somewhere in midst of 50,000 lines but superficially it looks like some `String -> String`.. then refactoring becomes painful because you replace it, and for inexplicable reasons things break.
12:25:17 <exarkun> guessWHo: In Haskell, if you show me the type of the `add` function I can give you a pretty good answer.
12:25:36 <exarkun> guessWHo: In Python, if you show me the source of the `add` function (and any of its transitive dependencies), I can give you a pretty good answer.
12:25:56 <exarkun> guessWHo: A big difference is that the type tends to be short and simple and the source tends to be long and complicated.
12:26:16 <exarkun> guessWHo: Apart from this moment-in-time analysis, there's also the maintenance benefit.
12:26:24 <dminuoso> types are provable, assumptions and documentation about code and its dependencies are not.
12:26:40 <exarkun> guessWHo: If your `add` function uses another function and someone _changes_ the other function to not be pure, now your add function is not pure - even though you didn't do anything!
12:26:50 <Psybur> Lets say I have liftF (+1) and liftF (+2). How could I "chain" these, and then use foldFree to compose them?
12:27:02 <exarkun> guessWHo: In Haskell, if something similar happens, it's a type error at compile time.  Your add function _can't_ become non-pure.
12:27:46 <sternmull> i always struggle to remove left recursion when parsing (for example with Megaparsec). I basically mess around with some intuition until i find something that works, but this is no fun. Is there some approachable practical description on how to resolve left recursion?
12:27:49 <exarkun> guessWHo: If you use Python, you may have noticed that sometimes upstream developers decide to change things.
12:28:23 <guessWHo> exarkum : that make sense but doesn't type introduces new problems by themselves given a definition add :: int -> Int -> Int only tell you about types of input and output not what you are doing with them what if somewhere you code is doing some sneeky thing within :P
12:28:48 <dminuoso> guessWHo: Lets say Im working on GHC itself for some reason. I find some function `Code -> Int` that calculates some property. Because this has no side effects, I can replace the function without having to think about any of the hundreds of thousands of lines of code that might somehow use this function, as long as my new function produces the correct code.
12:29:23 <dyl> sternmull resolving left recursion, for a given parser class, is a mechanical problem.
12:29:25 <dminuoso> guessWHo: If Im in a Python project of hundreds of thousands of lines of code, chances are you cant just dive in, and replace a function with your own function without mapping out all the dependencies and side effects throughout the entire project.
12:29:29 <dyl> There are algorithms to do it, mechanically.
12:29:43 <exarkun> guessWHo: What, like someone might implement an `add` function that actually subtracts?  That kind of sneakiness?
12:29:46 <dyl> Back away from the parser library and start by writing out your productions formally.
12:29:55 <ongy> guessWHo: that's why we have dependent types and prove systems. They are just a bit of a hassle :)
12:29:56 <dyl> Transform your productions until you're happy with them, then try encoding them.
12:30:35 <guessWHo> exarkun : that's one but there could be other right becasue all you are doing is putting restriction on type which even C can do
12:30:38 <exarkun> guessWHo: It's true that types don't fix all possible problems that might befall a piece of software.  But they fix some.  Isn't that better than nothing?
12:31:05 <dyl> Types are just another tool. They give other people reading your code, and the compiler, more information about the invariants in your program.
12:31:09 <lyxia> Psybur: foldFree (\g -> Just (g 0)) (do x <- liftF (+1) ; y <- liftF (+2) ; return (x + y))
12:31:14 <dyl> Not all invariants can be easily statically encoded, and there are diminishing returns.
12:31:27 <dyl> A really sophisticated dependent-typing system can guarantee a lot, but it also is more of a pain.
12:31:29 <dminuoso> guessWHo: Sure. Types are not fool proof. But the invariants it does prove give you more information that python which is: nothing.
12:31:58 <Psybur> > foldFree (\g -> Just (g 0)) (do x <- liftF (+1) ; y <- liftF (+2) ; return (x + y)) $ 3
12:32:01 <lambdabot>  error:
12:32:01 <lambdabot>      • Couldn't match type ‘Maybe’ with ‘(->) Integer’
12:32:01 <lambdabot>        Expected type: Integer -> x
12:32:03 <Psybur> Ops
12:32:04 <dyl> Even if you could encode the rank and shape of a matrix type in the type, it wouldn't be all that helpful as then you'd end up having to work from statically known shape/rank matrices (literals, etc).
12:32:05 <lyxia> Psybur: I actually have no idea whether that corresponds to what you have in mind.
12:32:12 <dminuoso> guessWHo: but types are not as much about 'restricting', because that sounds a bit negative. it's more about proving properties, which is a good thing.
12:32:14 <dminuoso> proving things is good.
12:32:18 <sternmull> dyl: I have a simple grammar for expressions, but it has some left recursion. Is there a "pen and paper"-like way to get to a non-left-recursive grammar? At the moment i have no general way to transform my grammar in something that i can hand over to Megaparsec without ending in endless recursion.
12:32:23 <EvanR> dyl: not necessarily...
12:32:24 <dyl> Yes.
12:32:43 <dyl> sternmull https://en.wikipedia.org/wiki/Left_recursion#Removing_left_recursion
12:32:45 <EvanR> but you would have to work with logical laws of unknown matrix shapes
12:32:52 <dyl> The usual approach is stratifying your productions.
12:32:53 <dminuoso> guessWHo: If I can prove that my refactoring has no effects, isn't that great? Wouldn't you love to refactor code with the ability to prove that you dont unintentionally break 20 modules in the process?
12:33:13 <dminuoso> guessWHo: I challenge you to _prove_ such a claim about refactoring some python function.
12:33:14 <guessWHo> dminuoso : what are you saying just because type matches you can't replace the code and if you are indeed goanna make sure that same property is being calculated then you'll have to go through the code right ?? so what's the difference >?
12:33:22 <sternmull> dyl: Hm, ok. I already looked at that and hoped there would be something easier to understand.
12:33:23 <Psybur> lyxia, I suppose. That works
12:33:28 <dyl> I suggest trying a simple expression grammar with integers, +, and × as an example.
12:33:32 <Psybur> Actually
12:33:43 <Psybur> Im wondering if theres a way to get rid of the return (x + y)
12:33:46 <dyl> Start with the naive approach of one expression production and then transform it.
12:33:53 <sternmull> Ok, maybe i just have to try harder.
12:33:59 <dyl> e.g. expr -> int-literal | expr + expr | expr × expr
12:34:03 <dyl> this won't work, it's left recursive.
12:34:07 <dyl> But you can transform it to make it work :).
12:34:18 <sternmull> i can't but i will try :)
12:34:24 <Psybur> Lets say I have a lot of these operations and I cant hardcode something like return (x + y)
12:34:29 <dyl> Worked problems are very helpful. Human beings don't learn well without concrete examples.
12:34:53 <eacameron> Is there a way to get GHC to infer the most general type in let bindings like it does in ghci?
12:35:00 <dyl> Working things out with paper and pen, step by step, is almost always a good approach.
12:35:15 <cocreature> eacameron: -XNoMonomorphismRestriction
12:35:25 <dminuoso> guessWHo: the type system ensures that if `foo :: String -> String`, then I cant put in sneaky side effects. That's a provable property.
12:35:28 <eacameron> cocreature: I wondered if that's what it was.
12:35:30 <ddellacosta> guessWHo, dminuoso: I'll add, as someone coming from almost exclusively dynamically-/uni-typed languages, I've found that the type system of Haskell has dramatically improved my ability to reason about my code. Rather than thinking about it as restricting or even in terms of safety (although I very much appreciate that benefit as well) I have found that it has shown me how little I thought about types b
12:35:31 <ddellacosta> efore, and how important they really are for understanding just what my code is doing, no matter what language I'm using.
12:35:37 <sternmull> dyl: But i wonder if there is a parser library that automatically handles left recursion. I think it would just have to track positions of "open" non-terminals and avoid to enter them again.
12:35:54 <dyl> It would need to be able to infer a topological ordering of nonterminals.
12:35:59 <dminuoso> guessWHo: and conversely, if its `String -> String` I _know_ for certain the code doesnt have side effects, so I dont need to know how it interacts with the real world. I simply dont need to know.
12:36:01 <dyl> This isn't generally feasible "automatically".
12:36:10 <dyl> It would work for only a subset of useful grammars.
12:36:27 <dyl> You should try to understand this problem rather than trying to find tools that let you ignore it.
12:36:35 <ddellacosta> sorry dminuoso, was following up on a point you made a little while back
12:36:41 <sternmull> ok. I admit that i only have an rudimentary understanding of parsing algorithms.
12:36:46 <dyl> Trying to sidestep such a key problem in parsing will only incur more "debt".
12:36:47 <eacameron> cocreature: Thanks sure enough that was it.
12:36:50 <dyl> Then start from the beginning!
12:36:53 <dyl> Nonterminals, terminals, and production rules :).
12:37:01 <dyl> The basic theory isn't all that bad at all.
12:37:07 <lyxia> Psybur: I'm not sure where you're going with this
12:37:18 <dyl> Don't be afraid to step away from the problem to expose yourself to the necessary theory.
12:37:29 <dyl> If you find you don't understand *why you don't understand*, then you need to do some research.
12:38:14 <sternmull> dyl: I know terminals, nonterminals and rules. But getting from there to a working or even efficient implementation was always a trial and error approach so far.
12:38:32 <guessWHo> dminuoso :: if i have add :: int -> int -> int ; add a b = a-b you can't blindly replace the add function right ? you'll have to make sure that indeed addition is being performed other i can do anything. Although resulting type would be Int
12:38:55 <exarkun> guessWHo: I feel like your complaint/concern/question has transformed.
12:39:13 <exarkun> guessWHo: We started talking about what it means to be pure and now we're talking about something different.
12:39:17 <cocreature> eacameron: just make sure you’re aware of the reasons for why the MonomorphismRestriction exists in the first place. otherwise you’ll end up wondering why certain things are reevaluated
12:39:20 <dyl> sternmull writing parsers is actually just a bit hard.
12:39:22 <exarkun> guessWHo: Did you get a satisfactory answer to your earlier question?
12:39:26 <dminuoso> guessWHo: Well I can replace it, but I cant somehow sneak a `launchMissiles :: IO ()` in, because the type system says Int -> Int -> Int, and not Int -> Int -> IO Int
12:39:28 <dyl> Practice, practice, practice!
12:39:49 <dyl> I find it kind of fun though.
12:40:15 <eacameron> cocreature: Yeah I've researched this before but it's been a while. I'll take a little refresher. Thanks for the warning.
12:40:33 <guessWHo> exarkun : these are not complaints , there is fundamental principle which all sciences follows i.e don't believe anything blindly know for yourself and i follow that principle
12:40:40 <cocreature> eacameron: the Haskell report is quite readable in that regard https://www.haskell.org/onlinereport/decls.html#sect4.5.5
12:40:46 <exarkun> dminuoso: well, I hope you at least grep for unsafePerformIO when you deploy a library update to your missile control system.
12:40:50 <dyl> Every parsing framework/library/system has its own benefits and drawbacks. Encoding the same grammar into different ones often requires changing up your grammar. It's important to understand the grammar you're working with in isolation from the tools you're using first.
12:41:16 <exarkun> guessWHo: Okay it sounds like you're getting a little defensive now.  My question was meant to focus the conversation instead of letting it sprawl without resolving anything.
12:41:29 <exarkun> guessWHo: I'm sorry you read it as an attack.  It wasn't meant as one.
12:42:07 <dminuoso> guessWHo: Or more to the point, if I see its Int -> Int -> Int, I know it doesn't do some `updateServerAndInsertIntoDatabase` because the type system does not allow it. All that your `add` is allowed to do, is map two numbers to other numbers.
12:42:07 <dyl> sternmull give the expression grammar toy problem I mentioned a shot.
12:42:08 <sternmull> dyl: Can you recommend some online literature that gives a good (and hopefully quick) start? I find wikipedia mostly useless for understanding algorithms or math problems.
12:42:16 <exarkun> guessWHo: Do you see how discussions about purity aren't really related to discussions about whether `add` is implemented correctly?
12:42:19 <guessWHo> exarkun : i'm not being defensive i'm just saying i have just started functional programming and i have many questions and if even one gets answered i'll be more than happy
12:42:36 <guessWHo> exarkun : and yeah no offence taken :)
12:42:39 <dminuoso> guessWHo: it also doesnt `lauchMissiles :: IO ()` or `startNuclearWar :: IO ()` - that's not an assumption, that's a provable property.
12:42:50 <dyl> sternmull nothing specific comes to mind.
12:42:59 <dyl> sternmull my approach is usually to find a good book and work through the problems.
12:43:06 * dyl comes from mathematics.
12:43:16 <guessWHo> dminuoso : that make sense
12:43:21 <sternmull> dyl: ok, but thank you nonetheless.
12:43:47 <dyl> sternmull try writing out expr -> int-literal | expr + expr | expr × expr in the tool you're using.
12:43:49 <dyl> It won't work.
12:43:51 <dyl> Now try to fix it.
12:43:55 <pk6vx0x2> sternmull: online literature that gives a good start on what? Sorry, joined the conversation late.
12:44:00 <dyl> That's the smallest illustrative problem I can think of.
12:44:07 <dminuoso> guessWHo: And why do I know that? It doesn't return an IO object, so it cant have any side effects like launching missiles or starting a war. With that knowledge, I can simply delete the function, replace it with my own, without having to fear that it will break "some other portions that rely on some updates to a hidden global counter"
12:44:20 <dyl> Keep in mind the precedence of + and × as well...
12:44:39 <dyl> There's not only left-recursion in that grammar, but also ambiguity.
12:44:46 <sternmull> pk6vx0x2: Parsing algorithms. Preferable transforming left recursive grammars for recursive descent parsing.
12:44:47 <eacameron> cocreature: I am defining lenses in a let binding so having them reevaluated seems to make sense between view and set. Does it re-evaluate multiple views of the same lens though?
12:44:55 <guessWHo> dminuoso : yeah those examples make much more sense then the earlier one
12:45:29 <dyl> sternmull if you're doing recursive descent, maybe try writing a pratt parser?
12:45:45 <dyl> Pratt parsers work very well for recursive-descent style parsing in languages where the left recursion is baked into the grammar.
12:45:50 <cocreature> eacameron: afaik not necessarily (i.e. the optimizer can be smart and specialize it once) but you’re not guaranteed that
12:46:32 <eacameron> cocreature: Ok. Well I guess it's just something to be aware of and benchmark if performance becomes a problem. Thanks for your help.
12:47:08 <dyl> sternmull if you're doing recursive descent for expression grammars, the Pratt approach is the easiest way to start handling precedence and left recursion.
12:47:24 <dyl> It's often prefaced with almost exactly the toy grammar I gave before.
12:47:45 <guessWHo> dminuoso : do you think category theory will be helpful in understanding the essence of functional programming >?
12:47:53 <dminuoso> guessWHo: No.
12:48:08 <dminuoso> Well. Helpful yes, but not even close to necessary.
12:48:27 <sternmull> dyl: Actually i "just" want to parse a simple language, get a correct AST and then play around implementing language features and so on. So i don't want to spend weeks reading about complex parsing algorithms. But refreshing the basics to be able to write sensible grammars for a few days is ok.
12:48:35 <dminuoso> To the point where I think unless you have a personal interest, there's no reason to learn anything about category theory.
12:49:15 <guessWHo> dminuoso : i do have an interest in learning category theory any suggestions for books >?
12:50:11 <dminuoso> guessWHo: Im quite fond of "Coneptual Mathematics - A first introduction to categories", which was recommended to me by some of the more experienced folks in here.
12:50:29 <dminuoso> (From Lawvere and Schanuel)
12:50:42 <dyl> I found it a little easy, coming from a math background.
12:51:06 <dyl> I'm currently refreshing myself with Aluffi's Algebra Chapter 0, which introduces category theory early and while not approaching it directly too much, applies it in context all throughout the book.
12:51:28 <dyl> Which is indicative of how CT is useful imo, as an organizational tool and means of reasoning about patterns that exist across distinct domains.
12:52:01 <dyl> CT is much easier to learn with exposure to concepts which it can be used to reason about. In isolation, it's a bit too abstract.
12:52:08 <siwica> What is an idiomatic way to calculate the intersection of a set of sets in haskell?
12:52:31 <dminuoso> :t intersecft
12:52:33 <dminuoso> :t intersect
12:52:33 <lambdabot> error:
12:52:34 <lambdabot>     • Variable not in scope: intersecft
12:52:34 <lambdabot>     • Perhaps you meant one of these:
12:52:36 <lambdabot> Eq a => [a] -> [a] -> [a]
12:52:46 <dminuoso> :t intersection
12:52:49 <lambdabot> error:
12:52:49 <lambdabot>     • Variable not in scope: intersection
12:52:49 <lambdabot>     • Perhaps you meant one of these:
12:53:00 <dminuoso> Well. For Data.Set that's a thing =)
12:53:02 <dyl> :t Data.Set.intersection
12:53:04 <lambdabot> Ord a => S.Set a -> S.Set a -> S.Set a
12:53:09 <dminuoso> dyl: Ah. :)
12:53:14 <guessWHo> dyl : let's see how it turns out , are there any prerequisites for CT , i know some basic set theory , algebra , calculus and DE
12:53:15 <siwica> I mean n sets though
12:53:26 <siwica> Set (Set a) -> Set a
12:53:30 <dminuoso> siwica: foldr1 ?
12:53:33 <dyl> guessWHo Not really. But the more reference points in other areas you have, the better.
12:53:46 <dyl> The only vague requirement is basic set theory.
12:54:03 <guessWHo> dyl : in which areas abstract algebra , group theory ?
12:54:10 <dyl> Anything, really.
12:54:20 <siwica> Yeah, but for fold I need the union of all sets, right?
12:54:22 <dyl> Category theory is a way of reasoning about patterns in mathematical structures.
12:54:30 <dyl> The more places you've seen the patterns it seeks to "factor out" and reason about,
12:54:34 <dminuoso> guessWHo: Just dont start with CT in hopes of becoming a better haskell programmer. Too many people, including myself, fall into that trap =P
12:54:35 <dyl> the easier it will be to understand how and why it's useful
12:54:38 <dyl> dminuoso ^
12:54:51 <dyl> CT won't help you be better at Haskell.
12:55:28 <guessWHo> dyl : i have more experience with applied mathematics than with pure and abstract mathematics but i guess this will be my intro to abstract mathematics
12:55:33 <frerich> siwica: You can first convert the set to a list and then fold that list using 'intersect', i.e 'foldr1 intersect . toList'
12:55:33 <dyl> For me at least, CT is an organizational tool. When I'm working on some mathematical topic, it gives me a lexicon for identifying structural patterns and connecting them to what I've seen before.
12:55:33 <siwica> Ah, foldr1... That's handy. Thanks!
12:55:40 <Tuplanolla> :t \ ambient sets -> Data.Set.foldr Data.Set.intersection ambient sets -- Like so, siwica.
12:55:42 <lambdabot> Ord a => S.Set a -> S.Set (S.Set a) -> S.Set a
12:55:42 <guessWHo> dyl : i know it won't
12:55:45 <dyl> It's useful for mathematicians, not programmers, imo.
12:56:00 <dyl> category theory is a rough introduction to abstract math.
12:56:04 <Tuplanolla> You cannot define an arbitrary intersection without an ambient set.
12:56:09 <dyl> It's "too abstract" if that makes sense.
12:56:29 <alexteves> I prefer the term "generalized abstract nonsense"
12:56:31 <guessWHo> dminuoso : honestly i know it won't help me as a programmer but just can't resist the temptation of learning something interesting
12:56:36 <dyl> alexteves hehe
12:56:56 <dyl> The classical introduction to abstract mathematics is to build from Sets to Groups, and then use Galois' proof of the insolubility of the quintic as a motivating problem.
12:57:00 <dyl> This works pretty well, educationally.
12:57:33 <dyl> I'm enjoying Algebra Chapter 0 as a refresher though.
12:57:53 <dyl> It's helping a lot to string together things I learned in isolation from each other into a single tapestry.
12:57:59 <dyl> It really does start from nothing.
12:58:21 <guessWHo> dyl : you from maths background ?? i'm from engineering and always wanted to be a self taught mathematician :p i guess now is the right time
12:58:23 <dyl> The approach is non-traditional (CT is introduced at the beginning) but it's done in such a way that it's used as a learning tool.
12:58:58 <dyl> Math is fun, and addictive.
12:59:26 <dyl> Mathematics is learned, in general, by beating your head against a desk until sleep deprivation on a problem you just can't crack, and then realizing when you wake up the next morning that it makes perfect sense.
12:59:36 <dyl> It's an exercise in learning to think.
12:59:53 <ongy> silly or good idea: Use TH to add every header used over hsc2hs to the dependency files? Probably needs to do some silly calls out to $CC to get the path
12:59:55 <dminuoso> dyl: story of my life. going through some brutal evenings here studying formal semantics of programming languages
12:59:58 <dyl> Learning the material is just a means to learning how to think about the material.
13:00:00 <dminuoso> and its a painful excercise.
13:00:06 <dyl> dminuoso it really is the best way to learn abstract stuff though.
13:00:25 <dyl> You just have to beat it into your brain hard enough, and have faith that it'll adapt after a good night's rest.
13:00:29 <dyl> Somehow, this works.
13:00:36 <ongy> dminuoso: where do you study?
13:00:59 <dyl> Abstract reasoning is not natural to human beings. Learning to think that way is an exercise in "reprogramming yourself", kind of.
13:01:04 <dminuoso> ongy: At home.
13:01:10 <guessWHo> dyl : since you are from maths background and i always wanted to ask one let me ask you how should i start my journey of mathematics i wan't to get more into mathematics
13:01:15 <dminuoso> ongy: Im not a student, I just beat all this into my head on my own.
13:01:25 <ongy> We have a course "Semantics of Programming languages", and it's one of the hardest(in time invested)  but most fun and most rewarding courses I took
13:01:29 <ongy> ahh, good luck with that :)
13:01:35 <dyl> guessWHo Hm, I'm not sure what the best approach to start off is.
13:01:40 <dyl> I started with real analysis, as many do.
13:01:58 <dminuoso> ongy: Im on the second book right now, being unsure whether I need to dial it back one more, but I dont know what literature to get at this point.
13:02:02 <dyl> In general the best way to learn is to find an appropriate text, have a few mentors you can ask questions of, and then do every problem in the book.
13:02:20 <ongy> I need to get more books...
13:02:21 <dyl> If you can get together a group of people to do weekly problem sets with, even better.
13:02:33 <dyl> Mathematics is actually like an addiction though.
13:02:52 <dyl> When you're a few years in, and you start counting up how much the books on your bookshelf cost...
13:03:00 <dyl> "Wait, I've spent HOW MUCH money on this??"
13:03:12 <dminuoso> dyl: Im just glad that they are deductable if they are somehow programming related.
13:03:12 <dyl> A local engineering library can be invaluable ;).
13:03:36 <marvin3> could be worse. you could be counting how much you spent on booze and hookers
13:03:52 <guessWHo> dyl : i don't think i can meet those requirements and i don't want to wait no more why don't you give me some advice on path to take texts it better to get started then waiting for the right time
13:03:58 <dyl> guessWHo I would suggest Pugh's "Real Mathematical Analysis" as a starting book.
13:04:10 <dyl> It covers the same material as Baby Rudin, but is a bit friendlier and less dry.
13:04:19 <dyl> I would get them both and start there.
13:04:32 <dyl> It's often VERY helpful to approach the same material from two texts.
13:04:33 <guessWHo> dyl : rudin , i have heard that name a lot when it come to analysis
13:04:43 <dyl> Baby Rudin and Papa Rudin are the seminal undergrad and grad texts.
13:04:50 <dyl> AKA the blue book and the green book.
13:04:58 <dminuoso> dyl: thats why I got a second book along side of TaPL, because it was a bit too difficult
13:05:19 <dyl> These are nicknames, Baby Rudin is actually called "Principles of Mathematical Analysis"
13:05:30 <dyl> Papa Rudin is "Real and Complex Analysis"
13:05:38 <ddellacosta> dminuoso: I'm curious, because I'm slowing going through it myself--what was that second book in relation to TaPL?
13:05:39 <dyl> But yeah, Pugh is a great starting text.
13:05:53 <dyl> And it gives you a taste for the topological approach to analysis which Rudin doesn't.
13:06:09 <dyl> But Baby Rudin is an invaluable reference at that stage.
13:06:14 <guessWHo> dyl : yeah i know that, okay so will start with Pugh
13:06:23 <dyl> If you want to do analysis to start :p.
13:06:24 <dminuoso> ddellacosta: Winksel, 1993
13:06:28 <dyl> That's just what I did.
13:06:32 <ddellacosta> dminuoso: thank you!
13:06:46 <dyl> Also guessWHo
13:06:58 <dyl> I would suggest reading this short essay by Terence Tao: https://terrytao.wordpress.com/career-advice/theres-more-to-mathematics-than-rigour-and-proofs/
13:07:00 <dsal> Is there a normal way to do something like:   Functor f => (a -> f b) -> f a -> f b
13:07:09 <dyl> It's a good description of the learning process for most people.
13:07:13 <dsal> e.g., I've got a .   Maybe String and I want to readMaybe it
13:07:16 <dyl> And can help ameliorate some of the frustration you might experience.
13:07:19 <ddellacosta> this guy huh https://www.amazon.com/Formal-Semantics-Programming-Languages-Winskel/dp/0262731037
13:07:21 <dminuoso> ddellacosta: It goes into domain theory, various recursion techniques, higher types, recursive types, and other things.
13:07:33 <ddellacosta> dminuoso: great, will definitely check it out
13:07:34 <dminuoso> ddellacosta: I mainly got it for the induction
13:07:35 <Tuplanolla> :t (=<<)
13:07:37 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:07:38 <ddellacosta> appreciate it, thanks again
13:07:43 <ongy> dsal: ^ It's the monad interface
13:07:48 <Tuplanolla> Look familiar, dsal?
13:08:02 <dyl> guessWHo just remember, math isn't primarily about learning mathematical concepts, it's about learning *how to think about* mathematical concepts.
13:08:13 * dsal sigh
13:08:32 <dsal> I get all caught up in applicative and forget monad.  Thanks!
13:08:39 <ongy> happens^^
13:08:42 <dyl> Best of luck!
13:08:59 <guessWHo> dyl : yeah sure thanks man ! :)
13:09:17 <dyl> I swear math is actually fun. I don’t know why, but it is.
13:09:27 <dyl> It’s like explaining why lifting weights is fun to someone who doesn’t.
13:09:57 <Myrl-saki> dsal: Probably not.
13:09:58 <phadej> dyl: exercise ;)
13:10:11 <guessWHo> dyl :  i know so far i have wondered at the beauty of maths but now its time for some learning
13:10:19 <Myrl-saki> dsal: Oh whoops, they already showed the Monad instance.
13:10:24 <dyl> Math is to your brain as exercise is to your body.
13:10:30 <dyl> Also: they go together really well.
13:10:34 <dyl> Stuck on a problem? Hit the gym.
13:10:36 <dsal> My brain has not been getting a lot of exercise.
13:10:38 <dyl> It actually helps a lot.
13:10:45 <guessWHo> dyl : how often do you come here , i mean it'll be fun to if i can discuss things with someone
13:10:47 <dsal> I did simplify some of this code quite a bit coming up the stairs after lunch, though.
13:10:59 <dyl> I’m always idling via ZNC.
13:11:06 <maerwald> brain scientists have discovered that most of the brain is inactive when doing maths
13:11:08 <dyl> There is also a math channel.
13:11:11 <maerwald> compared to... social interaction
13:11:30 <dyl> > brain scientists
13:11:32 <Myrl-saki> maerwald: Must be something wrong with the sample. :P
13:11:33 <lambdabot>  error: Variable not in scope: brain :: t0 -> terror: Variable not in scope: ...
13:11:56 <glguy> yikes: t0 -> terror
13:12:03 <maerwald> haha
13:12:08 <dyl> Heh.
13:12:17 <guessWHo> dyl : sure man see you around and thanks once again
13:12:36 <Myrl-saki> OTOh. Can confirm. Love math. Am trainwreck with socializing.
13:12:56 <Myrl-saki> Trainwreck is putting it lightly, even.
13:13:03 <dyl> The bridge between math and socialization is an appreciation for whiskey.
13:13:09 <dyl> Whiskey goes with both.
13:13:13 <dyl> Also, math is a social activity.
13:13:23 <dyl> Learning without discussing with other people is needlessly harder.
13:13:33 <Myrl-saki> dyl: Rubber duck?
13:13:33 <dyl> You need sounding boards and mentors.
13:13:38 <dyl> Yeah basically.
13:13:44 <dyl> Rubber ducking math problems works really well.
13:14:12 <Myrl-saki> dyl: I actually explain to real people my realizations, and it seems to help me at remembering them.
13:14:16 <dyl> Also a fun question: what is mathematics?
13:14:23 <dyl> There’s no commonly accepted definition.
13:14:31 <dyl> https://en.wikipedia.org/wiki/Definitions_of_mathematics
13:14:36 <dyl> One of my favorite Wikipedia pages.
13:14:55 <dyl> I really like this one:
13:14:58 <dyl> A mathematician, like a painter or poet, is a maker of patterns. If his patterns are more permanent than theirs, it is because they are made with ideas. G. H. Hardy, 1940
13:15:14 <dyl> Math shares more kinship with philosophy and art than it does with science imo.
13:15:18 <dyl> It’s a creative process.
13:15:41 <EvanR> "science" is another one
13:16:00 <dyl> Funny how such useful tools for defining things are impossible to define.
13:16:06 <EvanR> means more than convincing governments to pay you to produce charts with error bars
13:16:27 <dyl> “Using” maths is not doing maths.
13:16:42 <EvanR> and in the more general sense math is a science
13:16:49 <dyl> Ehhh, I don’t think it is.
13:16:54 <dyl> I think math is an art, not a science.
13:16:57 <EvanR> or science is a form of art
13:17:04 <EvanR> and now you have to justify art
13:17:14 <dyl> “What is art” is an even more infuriating question.
13:17:32 <Cale> I just tend to regard mathematics as its own thing
13:17:44 <dyl> Axiom: Mathematics is whatever mathematics is.
13:17:55 <EvanR> the art of the science of the mathematics of the zen of motorcycle maintenance
13:18:11 <dyl> & Knuckles
13:18:40 <Cale> Where I went to university, it had its own faculty anyway. :)
13:18:45 <EvanR> experimental science is a dark art
13:18:50 <dyl> “History of the philosophy of mathematics” is actually a real thing.
13:19:02 <dyl> It’s practically it’s own area.
13:19:10 <dyl> its* autocorrect
13:19:36 <EvanR> at least its not dark science
13:22:22 <dyl> Complex analysis is pretty damn close to black magic.
13:22:58 <EvanR> i have here an interesting way to look at real numbers. as a possibly infinite list of rational fixups to an infinite approximation. you can add them in an obvious way, you can multiply them with n+2 cross terms per term, you can extend any rational function by using an internal accumulator and differencer
13:23:14 <EvanR> er to an initial approximation
13:23:21 <dyl> What do you mean "fixups"
13:23:24 <dyl> Like Dedekind cuts?
13:23:30 <EvanR> terms in a sum that decrease
13:23:40 <EvanR> (in a specific careful way of course, not shown)
13:24:20 <EvanR> with that established, transcendental functions defined as a series can be built in terms of those
13:24:25 <dyl> I'm not what you mean by fixup, or internal accumulator
13:24:27 <EvanR> since its just + and *
13:24:35 <dyl> It sounds like you'd get a kick out of reading Ramanujan.
13:24:49 <EvanR> 3 + 0.1 + 0.04 + ... = pi
13:25:05 <dyl> actually: https://crypto.stanford.edu/pbc/notes/pi/ramanujan.html
13:25:20 <dyl> There's a series definition of pi.
13:25:22 <EvanR> anyway, its cool because its lazy
13:25:27 <EvanR> yes i am using a fast one
13:25:32 <dyl> That seems more like representation theory.
13:25:36 <dyl> That's just decimal expansion.
13:25:41 <EvanR> :|
13:25:45 <Cale> EvanR: Yeah, that's basically the same thing as Cauchy sequences.
13:25:53 <dyl> How do you write that out in a succinct notation?
13:25:58 <dyl> Decimal numbers.
13:26:04 <EvanR> its a cauchy sequence which is rearranged to have the differences instead of the approximations
13:26:05 <aaronStone> i get following error when i try to write to a file http://lpaste.net/363821
13:26:16 <EvanR> dyl: this is not about decimal at all, that was just metaphor
13:26:19 <dyl> 3.14 is just a nice way of writing 3*10^0 + 1*10^-2 + ...
13:26:26 <Cale> (though it's the sequence of differences of adjacent elements of a Cauchy sequence for the real number)
13:26:32 <EvanR> right
13:26:38 <dyl> -1*
13:27:08 <EvanR> its cool because since an infinite series ... is this... you can implement a real as the series directly
13:27:15 <dyl> But yeah, this seems like the Cauchy sequence construction of the reals.
13:27:22 <EvanR> dyl: the fixups are rational numbers, not decimals
13:27:36 <dyl> decimals aren't a sort of number, just a representation.
13:27:43 <isovector> using ghc.generics is there a way to actually get the record selector functions?
13:27:44 <EvanR> its related to cauchy, but the interface is different so you can implement it lazily
13:27:54 <EvanR> stop talking about decimals please
13:27:54 <dyl> I'm not sure what you mean by "implement it lazily"
13:28:13 <isovector> eg if i have `data X = X { foo :: String }` is it possible to get `foo` with GHC.Generics?
13:28:34 <isovector> `foo :: X -> String`, that is
13:28:53 <EvanR> dyl: the interface is a list of rationals, the running sum is a way to observe the value improving. you dont get this with most implementations of exact real arithmetic
13:29:04 <EvanR> because... as i am finding out, its slow as hell. but still cool
13:29:23 <MarcelineVQ> isovector: you have foo
13:29:32 <dyl> EvanR I think I get what you're saying but I'm not entirely sure.
13:29:42 <dyl> It seems like this would allow you to do real arithmetic to "lazy precision" in a sense?
13:30:06 <EvanR> yes, if you hold a real in your hand, you can get an approximation, use it, or not, and increase the precision without starting over
13:30:18 <dyl> You're representing them with a rational series approximation which itself behaves as a field.
13:30:33 <frerich> Cocktail-party question: when pattern matching the first two elements of a list, do you use 'x:y:xs' or 'x0:x1:xs' or something else?
13:30:48 <EvanR> its not an approximation, its an infinite list of rationals
13:31:00 <dyl> Er, yes, sorry.
13:31:19 <EvanR> each one is honestly part of the answer
13:31:24 <isovector> MarcelineVQ: what do you mean?
13:31:40 <dyl> What I think I'm stuck on is how you efficiently store/represent this infinite sequence.
13:31:46 <EvanR> you dont, its lazy
13:31:57 <MarcelineVQ> well, foo is already available due to record syntax right there.
13:32:10 <dyl> But what defines how you unfold it?
13:32:23 <EvanR> nothing, thats the beauty of lazy lists
13:32:26 <EvanR> you dont decide that
13:32:28 <MarcelineVQ> but searching 'record' on http://hackage.haskell.org/package/base-4.11.0.0/docs/GHC-Generics.html mentions some promising directions if you meant something else
13:32:29 <isovector> MarcelineVQ: sure, but that is not helpful if i want to write a generic instance that will work for any type (not just `X`)
13:32:51 <dyl> a lazy list's next element has to be computed from somewhere though.
13:33:02 <dyl> There's some formula for resolving the next element.
13:33:03 <EvanR> i misunderstood
13:33:21 <dyl> That's my confusion, as it seems you intend that this approach be useful computationally.
13:33:26 <EvanR> i thought you asked how you would consume it
13:33:28 <EvanR> not produce it
13:33:29 <dyl> I'm missing something haha.
13:34:05 <EvanR> to inject a rational into the reals, you do [q], a finite list
13:34:23 <EvanR> to implement pi, you produce the terms of a fast series, as an infinite list
13:34:32 <EvanR> to add two reals, you zipWith (+)
13:34:34 <EvanR> see
13:34:40 <dyl> Yes, that makes sense.
13:34:51 <dyl> Can you provably construct any real this way?
13:34:55 <dyl> My intuition is yes.
13:34:58 <EvanR> sure
13:35:10 <EvanR> modulo questions about computable vs uncomputable reals
13:35:34 <dyl> But if you use this lazy representation, non-computable reals aren't too bad.
13:35:39 <dyl> You don't *need* to compute them in finite time.
13:35:40 <EvanR> lol
13:36:00 <dyl> ;p
13:36:14 <c_wraith> you can exactly represent the 0% of real numbers that are computable, sure.
13:36:44 <EvanR> assuming uncomputable reals "exist", i do not expect you to be able to represent them like this
13:36:54 <EvanR> i mean, in haskell
13:37:04 <c_wraith> in any programming language.
13:37:48 <c_wraith> a consequence of the definition of computable reals is that all non-computable reals require infinite information to represent to arbitrary precision.
13:37:52 <aaronStone> EvanR : i'm getting this error "readFromChan.log: openFile: resource busy (file is locked)" can you please help
13:38:13 <EvanR> anyway, if you had algorithms that output terms that shrank really really fast (like this pi i have here), then you could certainly use this for something cool IRL
13:38:26 <dyl> This room has been almost entirely about math for almost an hour now.
13:38:31 <dyl> I feel bad for the people joining in.
13:38:32 <EvanR> variable precision simulation etc
13:39:13 <ongy> __monty__: https://github.com/haskell/haddock/pull/721 have you seen this? From what you said earlier I take it you have a few things to say about contrast for people with non-optimal sight?
13:39:15 <dyl> EvanR it sounds like it would be useful.
13:39:24 <dyl> I wonder how you would reason about stability under this regime?
13:39:33 <dyl> It intuitively seems like it might be interesting.
13:39:46 <EvanR> with everything i covered so far, its "exact" it doesnt become unstable
13:39:53 <EvanR> which would be the whole point
13:40:26 <dyl> Right, so the only place you get error is at the very end when you have to convert to a machine representation.
13:40:37 <dyl> Machine approximation is deferred until the end.
13:41:03 <dyl> Yes?
13:41:03 <EvanR> if you implement exp, cos, sin, log, or arctan with a series though... then the argument would have to be very close to the reasonable region of convergence, which is a limitation
13:41:11 <EvanR> yes
13:42:02 <EvanR> but if you only ned exp and log, then you can run your whole simulation near x=0 :)
13:42:36 <EvanR> (shifted log)
13:43:33 <EvanR> higher performance lazy reals would be cool :(
13:44:10 <dyl> Sounds like a potentially interesting HDL problem :).
13:44:17 <Ariakenom> EvanR, set up some benchmarks and do some nerd sniping :p
13:44:20 <dyl> Dedicated hardware for working with this representation could be fun.
13:44:31 <EvanR> heh
13:44:49 <EvanR> the main problem is.... get ready for it... the same problem Rational has
13:44:51 <dyl> Instead of an FPU, it's a LRPU.
13:45:05 <EvanR> the more information happening, the larger the rationals become
13:45:11 <EvanR> in data size
13:45:23 <EvanR> soon your hardware wont be able to handle it
13:45:34 <EvanR> however!
13:45:43 <dyl> Yeah, I'm wondering how you manage this. If you ask for output to say, 15 places... you're going to need some of the values that the result depends on to crazy precision.
13:46:01 <EvanR> make hardware that can use numbers such as these, and youre golden! https://www.cse.unt.edu/~tarau/research/slides/slides_ictac14.pdf
13:46:48 <EvanR> dyl: unfortunately, you dont get that far. you cant know how accurate your running total so far is
13:46:53 <dyl> I can't even begin to think about how you would design such hardware.
13:47:00 <EvanR> so you dont have to worry about it :)
13:47:10 <dyl> The most I've done is implementing ALU stuff.
13:47:15 <dyl> I'm not a hardware person.
13:47:46 <EvanR> dyl: if you read that slideshow and paper... youll see each number if a DAG whose root node points back to numbers less than it, of which you only really ever need 1 of each
13:47:58 <aaronStone> readFromChan.log: openFile: resource busy (file is locked)
13:47:58 <Ariakenom> EvanR, big-endian? I ddos in disgust.
13:48:09 <dyl> "we propose an elitist representation: some numbers are treated more favorably, while others “suffer” by a constant factor"
13:48:20 <dyl> Soon:
13:48:20 <EvanR> Ariakenom: the direction is irrelevant
13:48:21 <dyl> > seize the means of representation
13:48:25 <lambdabot>  <hint>:1:17: error: parse error on input ‘of’
13:48:37 <Tuplanolla> > implying that makes sense
13:48:40 <lambdabot>  error:
13:48:41 <lambdabot>      Variable not in scope: implying :: t0 -> t1 -> t2 -> terror: Variable no...
13:48:43 <EvanR> lists happen to be written left to right
13:48:49 <Tuplanolla> I bet I can make this work.
13:49:07 <Tuplanolla> > implying that makes sense
13:49:08 <dyl> > kierkegaard
13:49:10 <lambdabot>  What a stupid idea.
13:49:11 <lambdabot>  error: Variable not in scope: kierkegaard
13:49:13 <MarcelineVQ> > greentexting in irc with a poor robut around misunderstanding things
13:49:16 <lambdabot>  <hint>:1:14: error: parse error on input ‘in’
13:49:30 <dyl> > kierkegaard x
13:49:33 <lambdabot>  error:
13:49:33 <lambdabot>      Variable not in scope: kierkegaard :: Expr -> t
13:49:38 <dyl> Aw, no "terror"
13:50:02 <dyl> EvanR this seems like a cool approach.
13:50:07 <Ariakenom> EvanR, list order is fine. its 20 that should be 2 :p
13:50:19 <aaronStone> guys someone for a minute please take a look
13:50:37 <MarcelineVQ> aaronStone: you're not showing anything, no one can guess what you're doing to get that error :>
13:50:38 <dyl> 5141.3 = π
13:50:40 <dyl> what's the problem?
13:51:28 <aaronStone> MarcelineVQ : finally http://lpaste.net/363822
13:52:50 <Ariakenom> dyl, decimal places? what is this, a ... a place for mad people? Fractions are the only way to go.
13:54:02 * Ariakenom rants incoherently about everything and nothing
13:54:54 <dyl> Ariakenom you want ##philosophy then
13:54:56 <dyl> ;)
13:57:48 <EvanR> indeed brouwer 1921, “Does Every Real Number Have a Decimal Expansion?”
13:59:31 <EvanR> enough of these, caused hilbert to fire brouwer :)
13:59:46 <EvanR> but he was right!
14:00:25 <oo_miguel> If every Applicative is a Monad and (<*>) is (ap) why there are two functions at all?
14:00:37 <oo_miguel> why should I ever use ap?
14:00:46 <EvanR> use ap to implement (<*>) with Monad
14:01:06 <amalloy> oo_miguel: ap came first, but now that <*> exists there's little reason to use ap
14:01:41 <EvanR> if you say (<*>) = (<*>)... it will freeze, so (<*>) = ap
14:01:44 <oo_miguel> In a perfect world Monad would not require ap to be impleneted at all now?
14:01:58 <glguy> Monad doesn't require ap to be implemented
14:02:15 <glguy> ap is implemented in terms of methods from the Monad class
14:02:15 <EvanR> ap is a function that uses >>=
14:02:27 <fakenullie> @src ap
14:02:28 <lambdabot> ap = liftM2 id
14:02:30 <oo_miguel> aah
14:02:41 <oo_miguel> sorry, I thought ap is required, sorry
14:04:36 <oo_miguel> still it makes me wonder why there are two functions with different names that do exactly the same thing. I do not see any point, beside historical reasons, as amalloy pointed out.
14:05:17 <glguy> ap is a suitable implementation for <*>, <*> is a class method that might not be implemented using ap
14:05:54 <EvanR> the mentality to use Applicative if you dont need full Monad powers is relatively new though
14:06:08 <EvanR> you used to see liftM2 more
14:06:20 <EvanR> instead of liftA2
14:06:37 <gemishhood> Hey!
14:06:45 <oo_miguel> glguy: oh ok, different implementations are a good reason as well.
14:06:57 <oo_miguel> while they produce identical results
14:07:40 <oo_miguel> EvanR: I am quite new to haskell alltogether, so both concepts are new to me ;)
14:07:58 <gemishhood> I'm planning to pick up haskell and am looking for libs that satisfy my needs. Is there a numpy/scipy equivilent for haskell?
14:08:35 <aaronStone> is there a function for fromList -> Text ??
14:09:18 <ixxie> gemishhood: checkout http://www.datahaskell.org/docs//community/current-environment.html and https://gitter.im/dataHaskell/Lobby
14:09:32 <ixxie> I am no expert but I am looking for similar things, I plan to dig into it soon :)
14:09:42 <EvanR> aaronStone: pack :: String -> Text ?
14:10:14 <aaronStone> EvanR : i have this map fromList [(1,[(1,"One"),(2,"Two")])]
14:10:40 <EvanR> you want a Map Int String -> Text ?
14:10:59 <EvanR> er
14:11:12 <aaronStone> EvanR : yeah
14:11:35 <EvanR> Map Int [(Int,String)] -> Text
14:11:59 <xandaros> So... I'm running into a little problem. I'm decoding a lot of JSON objects with similarly named fields. So I can't just make records and have aeson infer the instances using generic, since I can't have the same record field name multiple times (at least not without running into "it's ambiguous!" around every corner...). Ideally I'd like to use lens to easily access the data in those fields, but I'm still at
14:12:01 <xandaros> a bit of a loss as to how to convince aeson to play nice. Apart from writing every instance manually, that is
14:12:18 <aaronStone> EvanR : how to do that >?
14:12:34 <EvanR> what do you want it to do ?
14:13:39 <aaronStone> EvanR : i want to pack it and then log it using Control.Monad.Logger
14:14:13 <EvanR> what about show
14:14:59 <aaronStone> it works but adds few extra character "fromList [(1,[(1,\"One\"),(2,\"Two\")])]"
14:15:43 <fakenullie> > print $ Map.fromList [(1,[(1,"One"),(2,"Two")])]
14:15:46 <lambdabot>  error:
14:15:46 <lambdabot>      Not in scope: ‘Map.fromList’
14:15:46 <lambdabot>      Perhaps you meant one of these:
14:16:10 <EvanR> write your own fancy ormatter for the map
14:17:44 <fakenullie> Map has debug formatting methods https://www.stackage.org/haddock/lts-10.5/containers-0.5.10.2/Data-Map-Strict.html#g:25
14:19:15 <gemishhood> exit
14:20:27 <xandaros> Also: What is up with the new hackage design? Not a fan
14:21:15 <jle`> it's the future ~
14:21:59 <xandaros> http://tcpst.net/muo6.png
14:22:00 <jle`> oo_miguel: it's not quite just a historical reason
14:22:01 <xandaros> Such future
14:22:16 <jle`> oo_miguel: take a look at fmapDefault from Data.Traversable
14:22:26 <oo_miguel> jle`: ok thanks!
14:22:49 <jle`> oo_miguel: basically, the Traversable typeclass has everything you need to write 'fmap', just using 'traverse'
14:23:18 <jle`> oo_miguel: so if you ever write a Traversable instance for your class first, and are too lazy to define a Functor instance from scratch, you can just say 'instance Functor MyType where fmap = fmapDefault'
14:23:52 <jle`> so ap and liftM are useful for people who implement Monad instances for their class first, but are too lazy to write their Functor and Applicative instances too
14:24:17 <jle`> so they can just write instance Functor MyType where fmap = liftM; instance Applicative MyType where pure = return; (<*>) = ap
14:24:35 <jle`> in the future once we have DerivingVia, then liftM/ap may be considered actually obsolete
14:25:11 <jle`> DerivingVia is slated for the next version of ghc i think
14:25:27 <oo_miguel> hmmmm
14:25:39 <xandaros> Well, we already have DeriveFunctor, DeriveApplicative, DeriveMonad and GeneralizedNewtypeDeriving, don't we? That should already take care of the vast majority of custom Monad(etc) instance
14:26:34 <jle`> we don't have DeriveApplicative or DeriveMonad
14:26:50 <jle`> Applicative and Monad instances are actually not unique
14:26:53 <xandaros> Oh, just Functor? Ah well
14:26:59 <xandaros> true!
14:27:10 <jle`> the benefit of DerivingVia is that we can hand-pick what we want our instances to be defined in terms of
14:27:56 <jle`> so we could write deriving via TraversableFunctor to say fmap = fmapDefault, derivingVia ApplicativeFunctor to say fmap = liftA, or deriving via MonadFunctor to say fmap = liftM
14:28:37 <hexagoxel> xandaros: feel free to follow https://github.com/haskell/hackage-server/. In this case https://github.com/haskell/hackage-server/pull/693.
14:29:17 <amalloy> jle`: the deriving via Foo approach doesn't seem much shorter than writing the instance by hand. what's the advantage?
14:29:52 <jle`> amalloy: it's useful for big classes like Num or Floating
14:30:16 <jle`> Floating has like almost 20 methods, heh
14:30:54 <jle`> also there's a discoverability thing
14:31:27 <xandaros> hexagoxel: I think I mostly dislike the colours. The rest I can get used to. (But colours are easy to change on my end, so not a big deal. That readme box being cut off is hilarious, though)
14:31:38 <jle`> since for 'pure = return; (<*>) = ap', you'd have to find what return and ap are named as
14:31:47 <jle`> and there might be many different functions
14:31:56 <jle`> DerivingVia lets you package them all up together
14:32:43 <jle`> the only thing you'd need to find/remember is the name of the newtype
14:34:19 <xandaros> So nobody has a suggestion for my aeson problem? Guess I'll just write the instances by hand, then
14:34:58 <jle`> xandaros: you can give custom name strategies for aeson derived things
14:35:06 <beginner> Hi, how do I create a function like foldl but returns (a -> b -> (a, Maybe c)) -> a -> [b] -> (a, Maybe c) instead of  (a -> b -> a) -> a -> [b] -> a
14:35:09 <beginner> ?
14:35:30 <xandaros> jle`: You can? I did have a look through the aeson docs, but couldn't find anything in that direction
14:35:48 <jle`> 🔰 what do you want that function to do?
14:36:16 <jle`> ^ beginner
14:36:53 <jle`> xandaros: look at genericToEncoding and genericParseJSON and family
14:37:14 <jle`> both of them let you provide information on how to the naming
14:37:56 <jle`> http://hackage.haskell.org/package/aeson-1.3.0.0/docs/Data-Aeson.html#t:Options
14:38:17 <xandaros> I see. Thank you very much! :)
14:38:38 <xandaros> Also, whatever that character was you accidentally put earlier - it's messing up my terminal >:(
14:38:39 <zachk> @type foldM
14:38:42 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
14:38:58 <beginner> jle`: let say I have something like this multiply a b =  (a*b, if even b then Just b else Nothing)
14:39:14 <zachk> beginner , is foldM what you want?
14:39:48 <jle`> xandaros: i'm actually not sure what happened!
14:40:14 <zachk> @src foldM
14:40:14 <lambdabot> foldM _ a []     = return a
14:40:14 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
14:40:40 <beginner> zachk, I will look at it. Thanks!
14:40:56 <zachk> beginner, you might need to modify the definition of it a bit to make it fit
14:41:38 <beginner> zachk, example?
14:42:03 <beginner> I am still not very familiar with Monad
14:42:50 <jle`> 🔰 can you write how such a function would use 'multiply'
14:42:51 <dminuoso> beginner: Dont pay attention to the word "Monad", and just focus on what this does with Maybe. =)
14:42:56 <jle`> it's still not quite clear
14:43:13 <jle`> 🔰 maybe try writing the 'final' function, so we can see what it might do?
14:43:26 <jle`> that is, your (a -> [b] -> (a, Maybe c))
14:43:32 <jle`> or even your [b] -> (a, Maybe c)
14:43:46 <jle`> from there we can see exactly what you mean, and try to help generalizing it to be a higher order function
14:43:56 <jle`> how would this function handle your 'multiplying' function?
14:45:42 <jle`> for example, 'foldl' (+) 0' is:
14:45:53 <jle`> er, 'foldl' (+)' is:
14:46:04 <jle`> foldlPlus x [] = x
14:46:14 <jle`> foldlPlus x (y:ys) = foldlPlus (x+y) ys
14:46:50 <jle`> then we can ask, "ok, how to abstract this over (+)?  what if i wanted to use other functions?"
14:47:01 <jle`> once we know exactly what it is you want to do
14:48:08 <zachk> beginner , do you have a paste to your code in question? I personally have never used foldM in my code so I lack any pertinent examples, but it almost matched the type signature of what you were looking for
14:48:16 <beginner> let multiply a b = a * b
14:48:18 <beginner>  foldl multiply 2 [1,2,3]
14:48:23 <beginner> that's the normal fold
14:49:48 <beginner> but instead of just returning 12 I want it to return something like (12, Just 12)
14:50:12 * dminuoso ponders why jle` keeps using that symbol 🔰
14:51:07 <pagnol> are there any longtime opaleye users here? what do you think of the library?
14:51:17 <pagnol> I'm wondering if it's not getting too verbose
14:51:40 <beginner> somethling like multiply' a b = (a * b, if even a then Just (a * b) else Nothing)
14:52:39 <jle`> it's my autocomplete ;_;
14:53:03 <jle`> 🔰 so what would yourFunction multiply 2 [1,2,3] return?
14:53:08 <jle`> hm, it happened again
14:53:30 <amalloy> dminuoso: "🔰 Japanese Symbol for Beginner Emoji"
14:53:41 <jle`> oh, it must be an emoji autocomplete
14:53:51 <MarcelineVQ> how awful
14:53:57 <beginner> (12, Just 12)
14:54:08 <beginner> wait
14:54:37 <beginner> yup
14:54:50 <CodeKiwi> beginner has his own emoji
14:55:47 <zachk> @type foldM
14:55:49 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
14:55:59 <zachk> @type Map.lookup
14:56:01 <lambdabot> error:
14:56:01 <lambdabot>     Not in scope: ‘Map.lookup’
14:56:01 <lambdabot>     Perhaps you meant one of these:
14:56:10 <zachk> @type lookup
14:56:12 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
14:56:19 <dminuoso> beginner: Im seriously beginning to wonder what you are trying to accomplish
14:56:19 <jle`> beginner : what you wrote is actually similar to 'unfoldr'
14:56:40 <jle`> er sorry, it's not, i misread
14:56:56 <jle`> 🔰 try writing 'yourFunction multiplying'
14:57:01 <dminuoso> beginner: What's the context?
14:57:01 <jle`> using just pattern matching
14:57:09 <jle`> myThing 0 [] = ????
14:57:21 <jle`> etc.
15:03:09 <ddellacosta> how would you express a left fold as a catamorphism (or _-morphism I guess), in Haskell? It seems like by default a catamorphism is a right fold, no?
15:03:20 <pagnol> this is the boilerplate I seem to need in order to work with a simple table with two columns: https://gist.github.com/anonymous/67470bb590aafabfe9b05b2452bda869
15:05:50 <pagnol> I would love to know what others here use to talk to postgres
15:08:06 <boj> beam has been a pleasure to use. nice interface around postgresql-simple.
15:09:54 <pagnol> boj, I'll take a look, thanks
15:10:13 <boj> pagnol: we switched from tisch (opaleye), no regrets
15:10:38 <pagnol> boj, what made you switch?
15:11:11 <boj> pagnol: sadly tisch ended up being pretty much unsupported. we considered dropping back to just opaleye, but wanted to avoid all that boilerplate
15:11:36 <boj> beam just uses record types, and the documentation is very nice
15:11:45 <boj> was easier for my team to grasp
15:11:55 <pagnol> ah.. so others who were put off by the amount of boilerplate built something on top of opaleye
15:12:03 <boj> yeah
15:12:59 <pagnol> and beam doesn't use template haskell
15:15:46 <pagnol> I wish I had taken a closer a look at alternatives before investing two days in working with opaleye
15:28:36 <Guest69655> l ~ <3 BYK LDER <3 MUSTAFA <3 KEMAL <3 ATATRK <3  ~ l l ~ AfraN III ~ l
15:41:44 <zachk> the new color scheme on hackage is hurting my eyes
15:41:46 <zachk> :(
15:45:54 <xandaros> jle`: genericToJSON/genericParseJSON worked like a charm. Again, thank you very much :)
15:46:53 <xandaros> Those emoji, though... for some reason they do not agree with my terminal http://tcpst.net/4zu6.png
16:12:48 <delYsid> date
16:13:02 <Tuplanolla> 2018-03-20 01:12:40
16:13:34 <delYsid> which is, in this context, without a TZ, totally useless :-)
16:15:12 <Tuplanolla> Your fault for forgetting to set `TZ`.
16:18:21 <delYsid> true
16:24:26 <jle`> xandaros: maybe i do it on purpose to expose bad terminal fonts >:(
16:25:09 <jle`> ddellacosta: the right fold is *the* catamorphism, but you can write foldl in terms of foldr
16:25:53 <jle`> ddellacosta: http://hackage.haskell.org/package/base-4.11.0.0/docs/src/Data.Foldable.html#foldl
16:50:36 <ddellacosta> jle`: thanks, and thanks for that link! Very helpful
16:50:48 <jle`> no problem!
16:52:25 <jle`> oh boy stackage nightly is a mess right now isn't it
17:13:55 <MacSlow> Greetings everybody!
17:14:41 <cjay-> yo
17:32:19 <pagnol> MacSlow, hi
17:32:49 <pagnol> what are you working on?
17:32:58 <pagnol> out of curiosity...
17:33:28 <pacak> Let's try again (from yesterday): http://lpaste.net/363776 - suppose I have a class with constraint (Category with constraints on elements) and I want to add a notion of Cartesian Category by adding one of the projections - it works in simple cases (foo1) but as soon as you compose it with anything ghc starts demanding more constraints. Is there a way to tell ghc something like "k is a Cartesian as long as k is a category and  given Ok k a an
17:55:13 <pagnol> boj, do you use the FooT types everywhere in your application or do you convert back and forth and only use them in the parts of your code that interface directly with beam?
17:57:49 <boj> pagnol: we convert back and forth since we originally had things setup that way with opaleye/tisch
17:57:58 <pagnol> ah right, makes sense
17:58:19 <pagnol> boj, and if you were to write everything from scratch with beam, which approach would you favor?
17:58:51 <boj> i'd have to think on that one, honestly
17:59:18 <pagnol> I'm wondering what's the lesser of the two evils... tying things too closely to the db part or duplicating everything
17:59:38 <boj> we do type sharing with our reflex frontend, so ultimately i'd probably lean towards conversion
18:00:32 <boj> that said, beam types are just boring haskell values, so they'd work on the frontend - it would just be awkward
18:00:34 <flows> is it possible to multiply everything that comes on the RHS of * with the left, like "a * (b + c + d)" but without having to type the parentheses?
18:01:17 <EvanR> thats insane
18:01:49 <EvanR> but (a*) $ b + c + d
18:01:50 <pagnol> aren't you doing that already?
18:01:53 <jle`> flows: (*) a $ b + c + d, i suppose
18:01:57 <jle`> but don't do that
18:02:21 <jle`> flows: let bcd = b + c + d in a * bcd
18:02:33 <jle`> ^ that's probably better
18:03:32 <jle`> and that's the way that would avoid writing any parentheses
18:03:43 <jle`> both (a*) and (*) a require two parentheses
18:04:03 <jle`> one of each variety
18:06:11 <flows> I see, I'm doing some live coding where I have to be scaling various parts of expressions so I was hoping there'd be a nicer way (visually and typing-wise), something like "a * $ b + c + d". Anyway I can hack this together?
18:06:35 <flows> maybe a custom operator?
18:07:14 <jle`> flows: you can define mult = (*)
18:07:19 <jle`> then do mult a $ b + c + d
18:08:49 <flows> jle`: seems like this is the best way, cheers!
18:09:27 <jle`> no problem :)
19:00:25 <jakehehrlich_> Is there a way to peek a few characters ahead with parsec?
19:01:14 <jakehehrlich_> I have a case where I want to parse everything before "{{{" or everything before "[[[" as a single bit of text specifically
19:01:59 <jakehehrlich_> so like "This stuff {{{specific_format}}} unstructured [[[other structure]]]"
19:02:32 <jakehehrlich_> the parsers for the stuff between {{{ and }}} are easy enough to write but anything is allowed to go between the triple curly braces
19:10:32 <xandaros> jakehehrlich_: Do you mean something like lookAhead? https://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec.html#v:lookAhead
19:25:12 <et09> i try to open ghci and get - ghc: could not execute: /usr/lib/hardening-wrapper/bin/gcc
19:25:31 <et09> which ghci -> /home/d/.stack/programs/x86_64-linux/ghc-nopie-8.0.2/bin/ghci
19:25:45 <et09> confused
19:26:35 <catern> why is there only, like, one paper pointing out that you can implement an effect system just using implicit parameters
19:27:00 <catern> why would you add an entire specialized language feature (an effect system) when you could just add implicit parameters
19:27:05 <catern> I feel like I'm taking crazy pills
19:27:34 <et09> what are implicit parameters and effect systems
19:31:55 <et09> haskell is like quicksand, the more you know, the less you know
19:32:38 <dfeuer> catern: implicit parameters are kind of hard to work with. What do they have to do with effect systems?
19:35:41 <jakehehrlich_> xandaros: Eh...maybe. I need to recover all of that text and consume it and then, without failing, keep parsing until I hit "{{{"
19:36:03 <catern> dfeuer: you can implement an effect system with implicit parameters, as described in this paper https://infoscience.epfl.ch/record/219173/files/thesis-jan-15.pdf which is cited by like two people
19:36:21 <vaibhavsagar> et09: do you have the same issue with ghc-8.2.2?
19:37:00 <vaibhavsagar> if so, it sounds like an issue with your OS, and if not, an issue with your installation of GHC 8.0.2
19:43:44 <pagnol> I want to migrate to stack and leave the cabal-tool behind, but stack keeps re-creating a new my-project.cabal file... why does it do that?
19:45:59 <vaibhavsagar> pagnol: do you have a package.yaml that you want to use instead?
19:46:16 <vaibhavsagar> if not, stack will use a .cabal file
19:46:27 <pagnol> yes, I created a new package.yaml
19:46:33 <pagnol> and want to use that
19:47:24 <vaibhavsagar> hmm, maybe it's converting the package.yaml to my-project.cabal each time for some reason?
19:48:31 <vaibhavsagar> I don't use that feature so I can't be of much more help, sorry
19:48:41 <jchia1> What system do you guys use to build and deploy haskell code to production? I'm having a manual process right now and it's quite painful.
19:48:57 <vaibhavsagar> jchia1: Nix is good for this
19:49:12 <vaibhavsagar> also I hear Docker containers are nice
19:49:56 <vaibhavsagar> if you have 30 minutes to watch a video: https://www.youtube.com/watch?v=RsSNEkBGmj0
19:50:19 <jchia1> cool, i'll watch it
19:50:21 <vaibhavsagar> I really should convert it to a blog post too
19:51:28 <xandaros> jakehehrlich_: manyTill anyChar (try $ string "{{{") -- ?
19:55:35 <jchia1> pagnol: If you have a package.yaml, stack makes generates the cabal file.
19:55:56 <jchia1> but if you manually edit the cabal file, then stack won't overwrite it.
20:16:22 <pagnol> after transitioning to stack, everything builds but when I want to run my application, I get: 'openBinaryFile: does not exist (No such file or directory)'
20:17:04 <pagnol> I've been googling this for a while without coming up with anything helpful
20:17:31 <mnoonan_> pagnol: how are you running it, and are you getting that message from stack or from your own code?
20:18:38 <pagnol> stack announces that it copied the executable to ~/.local/bin..., then I run it via `stack exec name`
20:18:55 <pagnol> or ./name, which results in the same
20:19:20 <mnoonan_> ./name, or ~/.local/bin/name ?
20:19:30 <pagnol> `stack build` / `stack install` complete without errors
20:19:35 <pagnol> sorry, just `name`
20:19:56 <mnoonan_> and "where name" points where you'd expect?
20:19:59 <pagnol> yes
20:20:07 <pagnol> the executable exists
20:21:00 <jle`> pagnol: does your application involve any file IO ?
20:21:13 <pagnol> the same error is reported by a couple stack users on gh: https://github.com/rstudio/rmarkdown/issues/970
20:21:56 <pagnol> my understanding is that this is not directly related to my own code, but something related to the build process and Setup.hs
20:23:04 <xandaros> Have you tried it with a simple hello world or something to make sure your code is definitely not involved?
20:24:09 <mnoonan_> could be worth running under strace to see what the program is actually trying to do
20:24:56 <siwica> Having a list of sets, what is the easiest way to obtain the list of (list-)unique elements in each set? E.g. foo [{1,2,3}, {1,2,3,4}, {5,6}] == [{}, {4}, {5,6}]
20:25:22 <siwica> Where each set is a Data.Set.Set set
20:26:14 <pagnol> xandaros, oh god... it's related to my code after all... thanks
20:26:49 <vaibhavsagar> siwica: something involving a foldl keeping track of seen elements?
20:27:11 <pagnol> since I was messing with the migration to stack, I got stuck thinking it must be related to that... good catch
20:37:50 <benzrf> siwica: you could take the union of all of them and then take the relative complement of that against all of them
20:37:59 <benzrf> no wait
20:38:28 <benzrf> hmmm... you could do a multiset union and then reject anything with a multiplicty of 2 or more?
20:38:31 <Myrl-saki> benzrf: Actually, yes.
20:38:37 <Myrl-saki> benzrf: Yeah, that's what I was gonna say.
20:38:42 <benzrf> :)
20:39:37 <Myrl-saki> benzrf: He could also do `(\map x others -> x - union others)`
20:39:45 <Myrl-saki> Err
20:39:52 <Myrl-saki> benzrf: He could also do `map (\x others -> x - union others)`
20:39:53 <benzrf> do we know that siwica is a "he"
20:40:00 <Myrl-saki> (Pseudo-Haskell)
20:40:02 <Myrl-saki> benzrf: They. :P
20:40:20 <jle`> anyone have a good name for a (forall a. m a -> m [a]) ?
20:40:44 <jle`> er, for the category of functions that take the shape (forall a. M a -> M [a])
20:41:10 <benzrf> what are the morphisms of this category o.O
20:41:44 <Myrl-saki> jle`: `pure . fmap` :P
20:41:52 <Myrl-saki> jk
20:42:00 <jle`> some examples, 'many' if M is Alterantive
20:42:06 <jle`> 'replicateM 10' if M is Applicative
20:42:06 <benzrf> :t pure . fmap
20:42:08 <lambdabot> (Functor f2, Applicative f1) => (a -> b) -> f1 (f2 a -> f2 b)
20:42:25 <jle`> um those are the only two i can think of
20:42:26 <vaibhavsagar> siwica: uniques ss = [Set.difference one others| one <- ss, let others = Set.unions (ss \\ [one])]
20:42:28 <Myrl-saki> benzrf: And I messed up the joke too.
20:42:28 <benzrf> heh
20:42:30 <Myrl-saki> :/
20:42:33 <Myrl-saki> :t fmap pure
20:42:35 <lambdabot> (Functor f2, Applicative f1) => f2 a -> f2 (f1 a)
20:42:52 <jle`> yeah, fmap pure or replicateM 1 fits here
20:43:10 <jle`> but replicateM n (for any n) fits as well
20:43:17 <benzrf> jle`: but what are the morphisms of this category
20:43:19 <benzrf> out of curiosity
20:43:33 <jle`> oh hey, i get the joke now :P
20:44:02 <Myrl-saki> jle`: Yaay
20:44:09 <jle`> i mean 'class'/general english def of category, heh
20:45:11 <jle`> maybe i'll call it Replicator
20:45:15 <jle`> or Repeator
20:46:44 <Myrl-saki> jle`: What are the constraints of M?
20:50:54 <jle`> M is specific
20:51:07 <jle`> or er, arbitrary
20:51:22 <jle`> so for every M you get different things
20:52:12 <jle`> so for Alternative instances, you have 'many'
21:21:34 <jared-w> jle`: your backprop library looks legit
21:23:07 <jared-w> I got a lot of similar vibes to http://colah.github.io/posts/2015-09-NN-Types-FP/ for some reason, and I liked it :)
21:43:30 <jle`> jared-w: thanks!  let me know if you find it useful for anything interesting! :)
21:44:53 <jared-w> Oh I have a small ways to go before my haskell skills are mature enough to really be able to use it lol. I'm barely to the point of writing code complicated enough to think about maybe looking twice at a monad transformer. But it's definitely something I'm keeping my eye on!
21:52:18 <jchia1> I want to merge two sorted lists [a] and [a] to find their intersection, and at the second time want to check that the second list is sorted (error if it is not sorted). How can I do this easily in one pass (without materializing the list). (I know how to do the check and the merge separately.)
21:53:27 <jchia1> "and at the same time"
21:55:26 <lyxia> "in one pass" and "without materializing the list" are quite different
21:56:01 <lyxia> a single recursive function would solve the former but the latter requires knowledge about the producer.
21:57:03 <jchia1> lyxia: Without materializing the list. The producer of the second list? What needs to be known about it.
21:57:14 <jchia1> Trying to avoid generating garbage
21:57:57 <SailorR> hello
21:58:09 <SailorR> is there a good GUI for learning haskell
21:58:20 <SailorR> like visual haskell
21:58:34 <jared-w> The problem here is the intersection can be done in a fusable way but the property that a list is sorted requires the previous element so structural recursion isn't possible
21:59:00 <lyxia> jchia1: if the producer is opaque then there is no way to fuse.
22:01:06 <SailorR> i want to learn haskell but come from visual basic backgrounjd
22:01:31 <lyxia> jared-w: what do you mean? you can carry the previous element in a register while doing structural recursion.
22:01:54 <lyxia> (assuming a is word-sized)
22:02:34 <jared-w> hmm, good point. I suppose I meant more that structural recursion does not lend itself to a generic "access to previous element becaues that's how structural recursion works" as opposed to, say, a histomorphism
22:03:38 <jared-w> (although now you have me second guessing whether or not I'm remembering correctly :p )
22:03:40 <jchia1> lyxia: What does it mean by 'opaque'? I can get the elements of the list from left to right. I also just need to remember the last element and the current element for the sortedness check, so I think at least in theory, I don't need to keep the whole list in memory.
22:05:20 <ab9rf> SailorR: forget everything you learned about visual basic :)
22:05:32 <SailorR> ab9rf, whys that?
22:05:52 <ab9rf> SailorR: just trust me :)
22:05:56 <lyxia> jchia1: A more concrete and sufficient condition is to not be inlineable. If the producer is not inlineable and allocates, any amount of effort on the consumer won't get to 0 allocations.
22:06:25 <ab9rf> SailorR: also, you may find #haskell-beginners a bit less abtruse
22:06:43 <lyxia> it can also be inlineable but still too complex
22:09:08 <Myrl-saki> When is a good time to update the package version?
22:12:05 <dmj`> Myrl-saki: When others want to consume a change you’ve made.
22:21:45 <aaronStone> i get following error http://lpaste.net/363827 when i run this program although contents are written to the file http://lpaste.net/363826
22:29:56 <aaronStone> EvanR : you have a minute to take a look at this ^^ ?
23:05:52 <Myrl-saki> How long does it take to compile ghc in your system?
23:05:52 <Gurkenglas_> aaronStone, is a previous instance of the process still running?
23:06:27 <aaronStone> Gurkenglas_ : which process are you talking about ?
23:08:01 <Gurkenglas_> aaronStone, the one that runs the contents of learn.hs
23:08:41 <aaronStone> Gurkenglas_ : no it's not i guess i
23:09:10 <aaronStone> Gurkenglas_ : i guess i'm getting these errors because of the multiple threads i'm spawing with mapM and they all trying to read same file
23:14:06 <aaronStone> Myrl-saki, Gurkenglas_ : whats the difference between TH logging & Non-TH logging here https://hackage.haskell.org/package/monad-logger-0.3.28.2/docs/Control-Monad-Logger.html\
23:14:07 <ij> Wwhere does groundhog-sqlite get the sqlite linked? I don't have it installed (I think) and cabal wouldn't do it.
23:14:50 <ab9rf> sqlite isn't typically something you install
23:14:58 <ab9rf> sqlite is a single .c file, you just compile it in
23:16:09 <ab9rf> groundhog-sqlite explicitly depends on direct-sqlite
23:16:28 <ab9rf> and direct-sqlite includes the sqlite source
23:17:19 <ij> Indeed, thanks! I just was so curious.
23:17:35 <ab9rf> sqlite is distributed as a single, very large .c file
23:20:39 <ij> Yeah, I see it now in the repo.
23:20:53 <ij> 207k
23:21:03 <ij> Lines, that is.
23:25:26 <Axman6> SailorR: If you have a Mac Manuel Chakravarty's Haskell for Mac is excellent, it's a lot like Swift playgrounds
23:25:52 <Axman6> SailorR: Also there is iHaskell, a backend end server for Jupyter notebooks to run Haskell
23:44:43 <ij> Can groundhog models also have lenses made for them?
23:45:14 <Axman6> I don't see why not
23:45:25 <Axman6> IIRC they're basically just Tree a
23:45:49 <Axman6> (though potentially infinitely large trees so you would need to be careful about evaluating the whole thing
23:46:21 <Sanya> hey! can anyone please provide some pointers on the "offline mode for stack" project for Google Summer of Code . I am having a hard time figuring out how to break down the problem into pieces for my proposal.
23:46:52 <Axman6> Sanya: you might want to also try #haskell-stack
23:47:40 <Sanya> ok...thanks
23:48:30 <Axman6> I haven't seen much discussion in here about the GSoC projects though. Also the haskell-cafe mailing list may be a better place
23:58:54 <ij> Axman6, I guess the problem in my eyes is that you wouldn't want to prefix underscores to fieldnames, so what do people usually do instead?
