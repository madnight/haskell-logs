00:17:23 <rkaippully> What is a good way to generate some haskell code before building it with stack?
00:17:48 * hackage hledger-diff 0.2.0.13 - Compares the transactions in two ledger files.  https://hackage.haskell.org/package/hledger-diff-0.2.0.13 (gebner)
00:18:55 <rkaippully> For some context, I was going to write a chess engine with magic bitboards, they have some generated byte arrays.
00:21:08 <rkaippully> In C, I can just have a helper program/script dump the generated code to a C file before compilation and automate the entire thing with a Makefile. Can stack do something similar?
00:23:53 <lyxia> rkaippully: there are different build-types you can set for your Haskell project in the .cabal file
00:26:11 <lyxia> You can use Custom to set some hooks to generate the files before calling the standard build process https://www.haskell.org/cabal/users-guide/developing-packages.html#more-complex-packages
00:26:59 <lyxia> build-type: Make  also exists if that's simpler for you.
00:39:55 <rkaippully> lyxia: Thanks, I'll explore that.
01:40:01 <ebzzry> In ghci, how do I know which module I am in?
01:46:22 <osa1> ebzzry: try `:reload`
01:47:02 <osa1> I think by default ghci prompt shows the module name
01:48:50 <ebzzry> osa1: Yes, ghci by default shows the module name. However, if one is using intero-repl in emacs, it only shows the lambda symbol
01:49:35 <osa1> ebzzry: `:show modules`
01:49:40 <osa1> take a look at `:help`
01:51:23 <ebzzry> osa1: ':show modules' show the loaded modules, but not the active one.
01:54:15 <lerax> there is a such think like "active module"?
01:54:20 <lerax> thing*
01:54:50 <lerax> currently namespace in general is a bundle of modules loaded...
01:57:09 <ebzzry> lerax: ok
01:57:17 <osa1> one of the loaded modules is kinda special in that you can access to its internal (non-exported) definitions
01:57:27 <ebzzry> How does GHCI know what is the currently-loaded and active module/namespace?
01:58:13 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#what-s-really-in-scope-at-the-prompt
02:01:31 <ebzzry> MarcelineVQ: thanks!
02:12:17 * hackage euler-tour-tree 0.1.0.1 - Euler tour trees  https://hackage.haskell.org/package/euler-tour-tree-0.1.0.1 (koral)
03:34:32 <Myrl-saki> What's a currently-maintained Haskell implementation that is easy to port?
03:34:50 <merijn> Myrl-saki: As in compiler?
03:34:55 <srhb> Myrl-saki: Isn't there only one currently maintained haskell compiler?
03:35:02 <Myrl-saki> srhb: Ah, dammit. :(
03:35:06 <Myrl-saki> merijn: Yep.
03:35:10 <merijn> srhb: No, there's 2.5
03:35:17 <srhb> merijn: Counting ghcjs?
03:35:20 <merijn> srhb: the half being SC's Mu
03:35:22 <merijn> srhb: No
03:35:29 <merijn> srhb: GHC and UHC
03:35:34 <Myrl-saki> merijn: Why is it currently a .5?
03:35:47 <Myrl-saki> Err, wait.
03:35:55 <merijn> Myrl-saki: Because it's 1) not really Haskell but a weird dialect of it and 2) not open source anyway
03:35:58 <Myrl-saki> Is it a .5 because it'sa dialect, or a .5 because it's still far?
03:36:00 <Myrl-saki> merijn: Ah.
03:36:25 <merijn> UHC is a Haskell2010 compliant open source compiler, but probably not significantly easier to port than GHC
03:37:10 <Myrl-saki> How platform-independent is Cmm?
03:37:55 <Myrl-saki> (And does GHC still even produce Cmm?)
03:41:52 <merijn> Myrl-saki: Define "produce"
03:42:06 <merijn> Myrl-saki: Cmm is really just an internal representation used by GHC
03:42:52 <merijn> Myrl-saki: C-- was initially intended to take a role like LLVM asm, however it never took off. GHC's version of C-- (Cmm) has since diverged from the standard and, since no one actually uses the standard anyway, is pretty much just an internal detail of GHC
03:43:33 <merijn> Myrl-saki: GHC translates "Haskell -> Core -> STG -> Cmm -> machine code"
03:43:38 <Myrl-saki> merijn: `-o foo.cmm`, basically.
03:43:57 <merijn> Myrl-saki: Optionally the machine code step can be replaced with "LLVM asm -> machine code"
03:44:07 <merijn> Myrl-saki: What's the end goal?
03:44:16 <Myrl-saki> merijn: Cmm -> machine code. :P
03:44:32 <Myrl-saki> merijn: It feels like Cmm would be the easiest to port.
03:44:36 <Myrl-saki> merijn: That, or LLVM.
03:44:50 <merijn> Myrl-saki: Port to what?
03:44:52 <Myrl-saki> merijn: This reminds me, I've heard somewhere that LLVM is not platform-independent, is that true?
03:45:18 <Myrl-saki> merijn: One is MIPS, but pretty much $INSERT_ANY_ARCH_HERE.
03:46:39 <merijn> Myrl-saki: The old, bitrotting "unregisterised C" backend still exists (but is disabled in release builds) for porting to new architectures
03:47:28 <Myrl-saki> merijn: release builds means official builds?
03:47:31 <merijn> Myrl-saki: Anyway, if you're considering porting GHC to some other arch, you'll probably get more constructive help ing #ghc or on the ghc-devs mailing list
03:47:44 <merijn> Myrl-saki: Yeah, you have to build from source to get a GHC that supports it
03:47:55 <Myrl-saki> merijn: Ah. Thanks.
03:48:02 <merijn> Myrl-saki: And you'll probably have to manually fix a bunch of C code to get it to actually run
03:49:23 <Myrl-saki> merijn: Thanks.
03:51:54 <merijn> Myrl-saki: Honestly, I think this probably won't be THAT hard, it'll just be a lot of work and very tedious :p
03:53:21 <Myrl-saki> I'll give it a try once I'm done lazing off.
03:53:25 * Myrl-saki started feeling lazy
04:04:47 * hackage pomaps 0.0.0.2 - Maps and sets of partial orders  https://hackage.haskell.org/package/pomaps-0.0.0.2 (sgraf812)
04:06:21 <riaqn> Hello, which function writes directly to fd only once with no buffering, yet still utilize the GHC RTS? (I mean, light thread)
04:08:46 <riaqn> I feel my client is offline..
04:10:22 <merijn> riaqn: Have a look at the GHC.IO modules
04:10:48 <merijn> Like GHC.IO.Device and GHC.Conc.IO I think you can hack something together yourself using that
04:11:10 <riaqn> merijn: yeah I'm looking at it but it has soo many functions.
04:11:15 <riaqn> kind of confusing
04:11:34 <merijn> riaqn: GHC.Conc.IO has functions to block until an Fd is readable/writable, so if you use non-blocking operations to write, combined with those, you should be fine
04:11:37 <kakashiA1> [1, 2, 3]  <---I read that they call this a list of Int-Objects. I am comming from an OOP background, so why are literals like numbers are called objects in haskell?
04:12:20 <merijn> kakashiA1: Who calls it that?
04:12:42 <kakashiA1> merijn: I have a collection of university-scripts
04:13:23 <kakashiA1> merijn: in thos scripts they use this terminology and I just double-check :)
04:14:18 <merijn> kakashiA1: I suspect they just use "objects" to mean "things"
04:14:46 <kakashiA1> merijn: had the same idea, thanks for clearification :)
04:16:53 <kakashiA1> merijn: you can also create a list like this:  1 : 2 : 3 : [], which is an uglier way to write [1, 2, 3]. Do you know the history/reason why this ugly : notation exists?
04:19:03 <Naughtmare[m]> kakashiA1: I use the ugly : notation all the time when deconstruction lists: f (x:xs) = xs for example uses the 'ugly' : notation.
04:21:46 <kakashiA1> Naughtmare[m]: cant you get the same with the normal notation?
04:22:42 <merijn> kakashiA1: : *is* the normal notation, the , notation is syntactic sugar for the : notation
04:22:55 <kakashiA1> merijn: ehmm ... yes :)
04:23:11 <Naughtmare[m]> kakashiA1: No using f [x,xs] = xs only works for lists of size 2, because xs is just the second element in that case. In f (x:xs) = xs, xs is the whole rest of the list.
04:30:13 <MarcelineVQ> "Do you know the history/reason why this ugly : notation exists?"  :  is a value constructor for the list type, as is []     if list was defined as   data List a = Nil | Cons a (List a)    then 1 : 2 : 3 : []  would look like  Cons 1 (Cons 2 (Cons 3 Nil))
04:30:22 <MarcelineVQ> ^ kakashiA1
04:34:10 <MarcelineVQ> : happens to be infix where Cons is prefix, but one of the essential roots of functional programming is constructors like : and Cons  and pattern matching on them. examples, of pattern matching on these constructors length [] = 0; length (x:xs) = 1 + length xs        listLength Nil = 0; listLength (Cons x xs) = 1 + listLength xs
05:13:43 <beaky> hello
05:13:51 <beaky> what is the difference between refinement types and sigma types
05:14:28 <beaky> (seeing as both look like they're used to constrain types to a subset according to a predicate?)
05:19:41 <kakashiA1> why does this returns []?
05:19:43 <kakashiA1> [5..3]
05:20:14 <Tuplanolla> What should it return, kakashiA1?
05:20:37 <kakashiA1> Tuplanolla: I would expext [5, 4, 3]
05:21:00 <Tuplanolla> Would `[5 .. 5]` use `+ 1` or `- 1` then?
05:21:38 <kakashiA1> Tuplanolla: well [5..3] means from 5 to 3
05:21:57 <kakashiA1> [5..5] means from 5 to 5, which means list of 5
05:22:06 <kakashiA1> (as I understood it)
05:22:22 <Tuplanolla> That would work, but it would also be more complicated.
05:22:25 <Tuplanolla> It follows the degenerate interval convention from math.
05:23:06 <noteventime[m]> kakashiA1: I don't think Enum assumes Ord
05:23:41 <Tuplanolla> The starting point and all its successors, as long as they are smaller than the ending point.
05:24:12 <noteventime[m]> so the real question is why enumFromTo for Int is implemented this way
05:27:10 <MarcelineVQ> kakashiA1: have a read of the haskell 2010 language report when you can, it's full of good stuff like how [5..3] is really  enumFromTo 5 3  and what enumFromTo's behavior is defined to be
05:27:56 <kakashiA1> MarcelineVQ: could you summarize in a simple way?
05:28:13 <Mark___> I’m trying to learn about hspec. What is wrong with this assertion? putStrLn “foo” `shouldReturn` “foo”
05:28:40 <Mark___> I assumed shouldReturn tests the value coming out of any monad.
05:29:04 <ClaudiusMaximus> :t putStrLn
05:29:06 <lambdabot> String -> IO ()
05:29:17 <Tuplanolla> It returns `()`, Mark___.
05:29:52 <MarcelineVQ> I'd much prefer you read the report since it would be clearer and even answer questions you've yet to ask.  So my simple summary would be "read section 3.10 and it's link to section 6.3.4 "
05:30:14 <MarcelineVQ> https://www.haskell.org/onlinereport/haskell2010/
05:31:41 <MarcelineVQ> Most simply [5..3] is [] because that's how enumFromTo is defined, but that's not an especially satisfying answer.
05:32:00 <noteventime[m]> MarcelineVQ:
05:32:11 <noteventime[m]> I doesn't really give a motivation though
05:32:31 <noteventime[m]> It just states the semantics
05:32:47 * hackage crdt 5.0 - Conflict-free replicated data types  https://hackage.haskell.org/package/crdt-5.0 (cblp)
05:33:09 <MarcelineVQ> Yes but I would like him to peruse the report, I'm not the first person to request it
05:34:42 <noteventime[m]> I see no reason why you couldn't have "enumFromTo a b | a < b = enumFromThenTo a (a-1) b | otherwise = enumFromThenTo a (a+1) b"
05:35:03 <noteventime[m]> err, except flip the inequality :)
05:35:38 <Tuplanolla> The reason it's not done in mathematics is that every case analysis doubles your proof burden.
05:37:20 <Tuplanolla> It would also be impossible to define the empty interval in terms of its endpoints.
05:39:18 <noteventime[m]> That being said, this behaviour is a pain in the backside in R
05:39:42 <noteventime[m]> So I suspect it might be for purely pragmatic reasons
05:41:25 <Tuplanolla> Consider `[v ! i | i <- [0 .. length v - 1]]` for example.
05:45:03 <kakashiA1> MarcelineVQ: as I understand it:
05:45:05 <kakashiA1> [a, b..c]
05:45:07 <kakashiA1> - if (b-a) is 0, all the list elements are the same
05:45:09 <kakashiA1> - if (b-a) is negative, and a > c you will get an empty list
05:50:58 <yoho> > [5, 4..2]
05:51:01 <lambdabot>  [5,4,3,2]
05:52:32 <MarcelineVQ> kakashiA1: Those two examples are correct but there's also more to it than that, the sequence [a,b..c] uses the rules for enumFromThenTo
05:55:23 <merijn> <3 new-build
05:56:19 <kakashiA1> yoho: your example shows me that I am not correct
05:57:16 <yoho> I recommend you do as MarcelineVQ is telling you to
05:57:41 <kakashiA1> yoho: because [a, b..c]  (b-a) = (4-5) is negative and a > c : 5 > 2
05:58:07 <kakashiA1> yoho: I will try it again, the documentation is a bit hard and abstract, I will dig into it
05:58:39 <Mark___> I’m trying to learn how to use hspec shouldThrow. Here’s a simple function:
05:58:41 <Mark___> divError :: Float -> Float -> Float
05:58:41 <Mark___> divError x 0 = error "division by zero"
05:58:42 <Mark___> divError x y = x / y
05:58:54 <Mark___> Why doesn’t this work?
05:59:04 <merijn> Mark___: You cannot reliably catch or check for "error"
05:59:07 <Mark___> divError 6 0 `shouldThrow` anyErrorCall
05:59:19 <merijn> Mark___: If you want to reliably catch exceptions, use throwIO
05:59:34 <MarcelineVQ> doh looks like I was hasty just now in saying correct, thank you yoho
06:00:32 <ggVGc> trying to get stack to build and run things on 32bit arch linux :(
06:00:37 <ggVGc> not having a great time
06:01:03 <merijn> Mark___: Note how the examples using 'div' use evaluate to force the evaluation of the exception
06:02:17 * hackage crdt 5.1 - Conflict-free replicated data types  https://hackage.haskell.org/package/crdt-5.1 (cblp)
06:02:33 <Mark___> Where is evaluate defined? I get “Variable not in scope” for that.
06:02:39 <merijn> deepseq package
06:05:50 <yoho> MarcelineVQ: had to reread it a few times to be sure of what was being said myself :D
06:17:17 * hackage llvm-hs-pure 5.1.2 - Pure Haskell LLVM functionality (no FFI).  https://hackage.haskell.org/package/llvm-hs-pure-5.1.2 (cocreature)
06:19:17 * hackage llvm-hs 5.1.3 - General purpose LLVM bindings  https://hackage.haskell.org/package/llvm-hs-5.1.3 (cocreature)
07:13:10 <troido> Question about Aeson: I have a data type that is represented in JSON by a single number. I have a function to construct this data type from a Scientific. The fromJSON method needs a result wrapped in Parser. How do I wrap this?
07:14:53 <merijn> troido: Well, do you have a "Parser Scientific" somewhere?
07:20:59 <troido> merijn I don't think so, but maybe I don't understand you. What do you mean with a "Parser Scientific"?
07:22:38 <merijn> troido: Well, where are you getting the Scientific from?
07:23:01 <bartavelle> a research lab I hope
07:24:16 <troido> the Aeson function withScientific :: String -> (Scientific -> Parser a) -> Value -> Parser a
07:26:05 <hexagoxel> troido: Parser is Applicative. And Monad.
07:29:39 <troido> but where do I get the parser from?
07:30:43 <hexagoxel> :t pure
07:30:44 <lambdabot> Applicative f => a -> f a
07:32:16 <hexagoxel> you have (Scientific -> MyThing). You have pure :: MyThing -> Parser MyThing. You need Scientific -> Parser MyThing.
07:39:24 <troido> hexagoxel Thanks, I didn't know about pure!
07:41:51 <hexagoxel> troido: very similar to Monad's `return` method, which would work too.
08:01:37 <ryantrinkle> is there a MTL-style typeclass for representing "I hold a given mutex"?
08:03:35 <merijn> ryantrinkle: Sounds more like bracket pattern to me?
08:04:00 <ryantrinkle> merijn: yeah, but i want type-level evidence that a given operation is inside the bracket
08:04:50 <merijn> ryantrinkle: Sounds like an indexed monad?
08:05:10 <ryantrinkle> hmm, is that necessary? i'm thinking you could have something like
08:05:44 <ryantrinkle> runWithMutex :: WithMutex x m a -> Mutex x -> m a
08:05:54 <ryantrinkle> class HasMutex x m where ...
08:06:25 <ryantrinkle> instance Monad m => HasMutex (WithMutex x m) ...
08:06:35 <merijn> ryantrinkle: But that's just bracket with an unnecessary class on top of it?
08:06:38 <ryantrinkle> newtype WithMutex x m a = WithMutex (m a)
08:06:50 <ryantrinkle> merijn: i'm not sure what you mean by unnecessary
08:07:06 <merijn> Well, what does it get you that bracket doesn't have?
08:07:19 <ryantrinkle> the idea is to prevent people from accidentally forgetting to take the mutex
08:07:41 <Tuplanolla> It does sound a bit like `Codensity`, ryantrinkle.
08:07:53 <ryantrinkle> so i can define operations like: updateStructure :: HasMutex x m => Structure x -> m ()
08:08:07 <ryantrinkle> of course, updateStructure could contain the bracket
08:08:25 <ryantrinkle> but then if you compose it with other operations, you're constantly dropping and re-taking the mutex
08:09:04 <hexagoxel> sounds like MonadState
08:10:57 <hexagoxel> only with more hiding / different from usual "runMutexState" implementation
08:11:27 <ryantrinkle> hexagoxel: hmm, i think what i'm thinking of is possible to implement without any change to runtime representation
08:11:31 <ryantrinkle> just a newtype
08:17:35 <hexagoxel> ah, so Reader but with a Proxy payload and without the functional dependency. i guess.
08:18:08 <hexagoxel> i haven't seen that.
08:19:55 <ryantrinkle> hexagoxel: yeah, that's what i'm thinking
08:22:46 <Mark___> Can someone spot the error here?
08:22:57 <Mark___> class MyShow a where
08:22:57 <Mark___>   myShow :: a -> String
08:22:59 <Mark___> instance MyShow String where
08:23:00 <Mark___>   myShow s = s
08:23:01 <Mark___> instance MyShow Show where
08:23:02 <Mark___>   myShow a = show a
08:23:24 <Mark___> It says “Illegal instance declaration for “MyShow String”.
08:23:53 <liste> Mark___: do you have TypeSynonymInstances on?
08:24:09 <Mark___> No … because I’ve never heard of that. ;-)
08:24:34 <Tuplanolla> That's a kind violation anyway.
08:25:24 <Mark___> What I’m after is to have a function like “show” that doesn’t include quotes around Strings.
08:25:32 <Mark___> Is there a better way to do that?
08:26:02 <yoho> why are you trying to do that?
08:26:58 <Mark___> I have another function that takes an arbitrary number of arguments of any type and prints them out on a single line separated by spaces. It is like JavaScript’s console.log.
08:27:32 <Mark___> But when an argument is a string, I don’t want it to output with quotes around it.
08:29:39 <yoho> how do you tell apart "1" from 1? (I guess you don't care? What about more complex things where a string could look like multiple different things side by side, or multiple strings being printed one after another?)
08:31:26 <Mark___> I’m okay with outputting multiple strings side-by-side. That’s what I get with JavaScript’s console.log.
08:32:08 <liste> @let class MyShow a where myShow :: a -> String
08:32:10 <lambdabot>  .L.hs:165:1: error:
08:32:10 <lambdabot>      Multiple declarations of ‘MyShow’
08:32:10 <lambdabot>      Declared at: .L.hs:159:1
08:32:16 <liste> @undefine
08:32:16 <lambdabot> Undefined.
08:32:18 <liste> @let class MyShow a where myShow :: a -> String
08:32:20 <lambdabot>  Defined.
08:32:23 <Mark___> If I define a new type class, is there an issue with making builtin types like String be a member of it?
08:32:35 <liste> @let instance Show a => MyShow a where myShow = a
08:32:38 <lambdabot>  .L.hs:163:18: error:
08:32:38 <lambdabot>      • Couldn't match expected type ‘a -> String’
08:32:38 <lambdabot>                    with actual type ‘Expr’
08:32:40 <liste> @let instance Show a => MyShow a where myShow = show
08:32:42 <lambdabot>  Defined.
08:32:49 <liste> Mark___: that does, the trick, BUT
08:33:11 <liste> Mark___: String also has a Show instance
08:33:24 <liste> Mark___: so the MyShow instance would be ambiguous
08:33:37 <Mark___> I was hoping order of definition would matter, but maybe it doesn’t work like that.
08:33:42 <liste> nop4
08:33:47 <liste> nope*
08:34:20 <Mark___> Is there any way to do type checking inside a function? Something a little like this?
08:34:51 <Mark___> myShow a = (a instanceOf String) ? a : (show s)
08:34:55 <yoho> no
08:34:58 <liste> well there are some ways, but in 99% of cases it's not a good idea
08:35:02 <Mark___> I know that isn’t Haskell syntax using a ternary like that.
08:35:48 <Mark___> Is it fair to say there is no way to dupicate the functionality of JavaScript’s console.log in Haskell?
08:36:13 <hpc> :t putStrLn
08:36:15 <lambdabot> String -> IO ()
08:36:35 <liste> Mark___: depends on how faithful you want to be to console.log
08:36:46 <ertes> i recently upgraded to GHC 8.2 from 8.0, and since then haskell-mode no longer works…  whenever i try to fire up GHCi, i get "Unexpected response from Haskell process."
08:36:47 <liste> Mark___: and there's always hacks
08:36:48 <ertes> any ideas?
08:36:51 <Mark___> That doesn’t quite do it. Don’t have have to pass a single argument to putStrLn?
08:37:16 <yoho> another question here is what exactly you want to do with this function - duplicating console.log might not necessarily be the best way to go about whatever it is you're trying to do
08:37:49 <liste> trace and show (and traceShow) are usually good enough for debugging
08:37:50 <ertes> err…  it does seem to work actually
08:37:51 <Mark___> I don’t want to have to do something like this: putStrLn $ (show someBool) ++ “ “ ++ (show someNumber) ++ “ “ + someString
08:38:06 <liste> Mark___: check out printf and formatting
08:38:09 <liste> @hackage printf
08:38:09 <lambdabot> http://hackage.haskell.org/package/printf
08:38:13 <liste> @hackage formatting
08:38:13 <lambdabot> http://hackage.haskell.org/package/formatting
08:38:14 <Tuplanolla> How about just `print (all, the, things)`, Mark___?
08:38:24 <Mark___> I want this: myLogger someBool someNumber someString
08:38:30 <yoho> that'll leave the quotes in and look a bit odd Tuplanolla
08:38:43 <Tuplanolla> Does it matter? It's a log.
08:38:59 <yoho> I don't think it does but apparently the quotes are exactly Mark___'s issue
08:39:05 <liste> oh, printf's in base, sorry https://hackage.haskell.org/package/base-4.10.1.0/docs/Text-Printf.html
08:40:06 <Mark___> With printf I assume I would have to specify a format string containing the correct number of placeholders. I’d rather not do that.
08:40:28 <liste> Mark___: why? there's no variadic functions anyway
08:40:57 <liste> (variadic = variable number of arguments)
08:41:18 <liste> Mark___: if you're afraid of type safety, then use the formatting package
08:41:42 <p0a> Hello
08:41:51 <p0a> Why doesn't this work: divides = 0 == rem
08:41:57 <p0a> Or say divides = (0 ==) . rem
08:42:00 <Mark___> This gist shows how I was able to implement a variadic function: https://gist.github.com/mvolkmann/a4f5d5bb6a796828e04efd6816d5d44a
08:42:10 <p0a> I'm trying to make a point-free definition of divides n m = 0 == rem n m
08:42:19 <liste> Mark___: yes, the printf hack
08:42:40 <Tuplanolla> :t (0 ==) .: rem -- Like this, p0a.
08:42:42 <lambdabot> Integral a => a -> a -> Bool
08:42:48 <Mark___> The gist does exactly what I want except strings have quotes around them.
08:43:19 <p0a> Tuplanolla: what's .: ? You mean run :t on both (0==) and rem to make sure they match?
08:43:37 <Tuplanolla> It's `.` over two arguments.
08:43:55 <Tuplanolla> That is, `f .: g = (f .) . g`.
08:44:19 <monochrom> You can glean a lot of information from its type.
08:44:21 <Mark___> Is it possible to define a new type class and make String be a member of it?
08:44:23 <monochrom> @type (.:)
08:44:26 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
08:44:26 <ertes> ok, it seems like the interpreter itself works, but haskell-mode is severely broken with 8.2…  for example it doesn't highlight my errors/warnings
08:44:29 <p0a> Tuplanolla: well it doesn't work
08:44:31 <ertes> going back to 8.0 for now
08:44:39 <monochrom> Aw, I guess the Functor abstractness gets in the way.
08:45:01 <liste> Mark___: sure
08:45:06 <ertes> kinda sucks…  i was looking forward to playing around with some of the 8.2 features =/
08:45:15 <liste> you need TypeSynonymInstances though, because String = [Char]
08:47:16 <p0a> So it's the case that (a->a)->a is not the same type as a->a->a because the latter is a->(a->a)
08:48:20 <p0a> Is that the issue?
08:48:38 <p0a> I guess that's what makes point-free bad style
08:49:06 <merijn> p0a: Who says pointfree is bad style?
08:49:11 <p0a> according to some
08:49:15 <Tuplanolla> It tends to be a bad idea when more than one argument is involved.
08:49:18 <yoho> @let divides = ((0==).) . rem
08:49:21 <lambdabot>  Defined.
08:49:28 <yoho> > divides 10 2
08:49:31 <lambdabot>  True
08:49:34 <p0a> let me see if I can understand that
08:49:35 <p0a> just a sec
08:49:59 <[Leary]> > 10 `divides` 2
08:50:02 <yoho> that's the same as Tuplanolla's solution without requiring .:, which I can't actually find where it's defined that lambdabot is getting it from
08:50:03 <lambdabot>  True
08:50:12 <[Leary]> I'd swap those arguments. >.>
08:50:32 <yoho> nah man I hate infix functions
08:50:33 <p0a> yeah but at that point I'd just define it as divides n m = 0 == rem n m
08:50:47 <yoho> (more seriously yes that would make sense)
08:51:54 <p0a> but now I see it
08:52:06 <p0a> it's just a misunderstanding in math that we consider multivariable functions as a single variable
08:52:08 <p0a> of many dimensions
08:52:39 <p0a> so f . g (x) makes sense to us if f takes R->R and g takes R^n->R in haskell that's not the casd
08:52:40 <p0a> case
08:52:40 <lavalike> more than a misunderstanding it's a theorem
08:53:24 <p0a> Well in haskell it /is/ the case as well that it'd work with an n-tuple. But in my case I had R->R->R not R^2->R
08:53:49 <p0a> but those are identified in math
08:54:12 <[Leary]> @let ucDivides = (0==) . uncurry (flip rem)
08:54:14 <lambdabot>  Defined.
08:54:21 <[Leary]> > ucDivides (2, 10)
08:54:24 <lambdabot>  True
08:54:41 <p0a> [Leary]: ooh that's what you complained about
08:54:59 <p0a> [Leary]: is it bad style to have divides 4 2 == True? Would you rather divides 2 4?
08:55:36 <[Leary]> You can do either, but if reading the infix version can make sense, it's better that it does.
08:56:45 <p0a> also, I was trying to build the primes list using previous knowledge
08:57:07 <p0a> so I want to write it in such a way that says primes = 2: <stuff> where stuff computes the next prime using the known primes and so on
08:57:29 <p0a> what is this technique called so that I can read about it?
08:57:54 <p0a> the problem is that if I refer to primes within <stuff> I get an infinite loop
08:58:09 <p0a> so I'm not sure how to "stop" evaluation at what is "known". Of course this is vague
08:58:11 <[Leary]> It's probably equivalent to the Sieve of Eratosthenes ... If that's how you spell it.
08:58:19 <p0a> yeah well I know the algorithm
08:58:37 <p0a> and you're right yes that's what I'm trying to do
08:59:22 <p0a> I'm just trying to "optimize" it so that 1) it only checks odd numbers, 2) it stops after sqrt(n) when attempting to factor n 3) uses the previously computed primes instead of [2..(n-1)]
08:59:46 <p0a> I can't think of a more optimized sieve of eratosthenes conceptually. I'm sure there's stuff out there though
09:00:42 <p0a> but before looking at those I'd like to at least know how to do this in haskell. Basically I want a function f :: list -> number and a list = partial_list : next where next = f(partial_list)
09:00:50 <p0a> if that makes sense
09:00:59 <p0a> I did mess up the types there a bit ...
09:01:42 <[Leary]> Some combination of filter and takeWhile applied to Primes will get you what you want to use in your trial division.
09:02:12 <p0a> okay I'm guessing this is like the examples under "Memoization" in the haskell wiki
09:02:37 <kadoban> Kind of a side note, but if you're doing trial division, you're almost certainly not doing sieve of eratosthenes
09:03:00 <p0a> kadoban: right. He was just erasing the multiples
09:03:05 <ertes> s/almost//
09:03:53 <p0a> kadoban: but you need a "finite table" to run this algorithm. Or some way of deciding when to stop the sieve
09:04:08 <p0a> so I'm not sure what it is that I'm doing. Thanks for mentioning this
09:04:24 <Tuplanolla> You can build an indefinitely growing sieve, but it's quite tricky.
09:04:47 <p0a> Tuplanolla: how do you decide when to stop erasing 2's and go for 3's etc?
09:05:17 <kadoban> p0a: https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
09:05:17 <Tuplanolla> You delay the construction of the sieve itself until enough primes have been requested.
09:05:20 <ertes> the trick is to write a function that sieves a particular range, then you can just use that function blockwise
09:05:35 <ertes> the arithmoi library implements that trick
09:05:42 <kadoban> Or yeah, you can do segmented sieves.
09:05:54 <p0a> so you're saying that it's cutting-edge?
09:05:59 <p0a> or good-enough anyway?
09:06:02 <ertes> yes
09:06:08 <p0a> col
09:06:11 <p0a> I should go for hat
09:06:34 <ertes> however, it's not any prettier in haskell than it is in other languages, because you're working with mutable bit arrays to make it efficient
09:06:43 <p0a> kadoban: thanks
09:06:50 <p0a> oh really? wow
09:07:05 <p0a>  so you're using a bit array to uncheck numbers huh
09:07:28 <ertes> well, you can do sieving without bit arrays – even purely
09:07:41 <ertes> but then it's most likely even slower than trial division
09:07:50 <ertes> while if you do it properly, you can generate millions of primes within seconds
09:08:05 <ertes> billions even, if you implement all the little tricks to make it crazy fast
09:08:43 <p0a> but I'm getting a feeling
09:08:54 <p0a> this is about as easy as doing it in 64-bit assembly
09:09:18 <p0a> instead of a higher level language like haskell
09:09:36 <Tuplanolla> I think your issue is thinking the problem itself is trivial.
09:09:57 <p0a> I'll give it a shot first. It's just that I want to learn some asm too that's all
09:10:07 <kadoban> Depends what you're going for. You can get *decent* speed the pure way, asymptotically. Or you can get really pretty good speed doing it imperatively without a lot of trouble. Getting either great speed the pure way or fantastic speed the imperative way is ... harder.
09:10:19 <ertes> using arithmoi: (foldl' (+) 0 . take 10000000 . sieveFrom) 2
09:10:20 <ertes> 870530414842019
09:10:20 <ertes> (2.94 secs, 3,040,000,216 bytes)
09:10:30 <ertes> that's in GHCi, but i don't think it makes much of a difference
09:10:49 <monochrom> Haskell offers you "[n, n+p ..]" which is very convenient for sieving.
09:10:54 <ertes> (the memory footprint is misleading…  it's not the number of bytes resident, but the number of bytes allocated)
09:11:14 <p0a> That's good though right? Sure you used a lot of bytes since you had to keep a lot of primes around
09:11:29 <ertes> no, the memory requirement of that code is pretty much constant
09:12:07 <p0a> Doesn't it keep the primes?
09:12:19 <ertes> the point is that i calculated the sum of the first 10 million primes in 3 secs
09:12:25 <ertes> no, that would be horrible
09:12:52 <ertes> if i used 'primes' instead of (sieveFrom 2), then it would actually keep all the primes in memory
09:12:56 <ertes> let's see the difference
09:12:57 <p0a> I'm confused. How would it know that 2^100000 is not a prime?
09:13:07 <phadej> 2*2 *...
09:13:10 <p0a> At some point it has to check if it is divided by 2. In some way
09:13:10 <[exa]> p0a: pick a random divisor :]
09:13:28 <ertes> ok, it's not that bad, but the time jumped to 4.64 secs
09:13:28 <monochrom> And by the time you get to "mapM_ (\i -> writeArray a i 0) [n, n+p ..]" it no longer looks like assembly but it does what assembly would do.
09:13:29 <p0a> [exa]: choose random algos, get random results :P
09:13:36 * hackage hspec-discover 2.4.5, hspec-core 2.4.5 (SimonHengel): https://qbin.io/mxvqdsi
09:13:49 <ertes> p0a: the point of sieving is that you do it "along the way"
09:13:57 <[exa]> p0a: or learn math...
09:14:16 <ertes> p0a: once you sieved all multiples of 2 out, you can forget about 2
09:14:30 <p0a> ertes: but the multiples of 2 are infinite!
09:14:49 <p0a> I thought that's what we talked about before with the "block" technique
09:14:51 <ertes> p0a: but the sieve is not…  it's done blockwise, as i explained earlier
09:15:07 <ertes> each block is sieved separately
09:15:18 <p0a> wow really? How in the world
09:15:45 <p0a> So you're saying at the block [10^100, 10^100 + 100000] you sieve it out without using the previously sieved primes?
09:16:20 <p0a> this is a very confusing matter. I'll do some reading
09:17:28 <[exa]> > take 10 $ primes
09:17:31 <lambdabot>  error: Variable not in scope: primes :: [a]
09:17:34 <[exa]> :(
09:18:45 <ertes> p0a: no, each sieve block is independent…  you do need to restart
09:19:14 <ertes> arithmoi employs a lot of low-level tricks to make this efficient, but that's the basic idea
09:19:36 <ertes> for example i think it doesn't actually ever sieve 2…  it just modifies the sieving relation
09:20:29 <infinisil> > take 10 $ Data.Numbers.Primes.primes
09:20:33 <lambdabot>  error:
09:20:33 <lambdabot>      Not in scope: ‘Data.Numbers.Primes.primes’
09:20:33 <lambdabot>      No module named ‘Data.Numbers.Primes’ is imported.
09:21:02 <infinisil> > import Data.Numbers.Primes
09:21:05 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
09:21:10 <infinisil> > :m Data.Numbers.Primes
09:21:16 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
09:21:18 <ertes> to sieve the prime p you would normally solve (x ≡ 0 (mod p)) for all x in your buffer…  but 2*x + 1 is always odd, so you can just keep a bit for each x of that relation…  that makes the whole process twice as efficient in both time and memory
09:21:20 <infinisil> i give up
09:21:30 <ertes> just solve (2*x ≡ -1 (mod p)) instead
09:22:47 * hackage crdt 6.0 - Conflict-free replicated data types  https://hackage.haskell.org/package/crdt-6.0 (cblp)
09:23:18 <ertes> BTW, if you understand what i'm talking about, you could just as well implement the sieve of atkin instead and get another speed boost =)
09:23:45 <p0a> so you're saying that's a btter one? I thought arithmoi employed eratosthenes and you guys said it's fast
09:24:36 <ertes> currently it uses eratosthenes…  if you're really into generating small primes quickly, then atkin is better
09:24:49 <kadoban> I don't know what it does. Currently the best method I know how to do personally is a segmented sieve of eratosthenes. (for "small" primes anyway)
09:24:51 <ertes> but there aren't too many applications that require it
09:25:21 <p0a> hm.. It's okay.  A good enough speed is what I want
09:25:26 <p0a> I was getting slow speeds for project euler that's all
09:25:36 <yoho> infinisil: lambdabot isn't a fully fledged ghci
09:26:30 <p0a> I'll show you my code if I get it
09:26:47 <infinisil> yoho: does it only have a fixed set of imports?
09:26:56 <ertes> p0a: keep in mind that a proper prime sieve in haskell is just as imperative in haskell as it is in other languages…  you could argue that monadic imperative programming is still nicer than the usual statement/control-based one, but this particular problem is so small that you hardly notice a difference
09:27:20 <kadoban> Ya, most of my primes usage is competitive programming, haha. It seems to be mostly where it comes up. For project euler I used to do a thing based on that paper I showed, eventually I moved on to an imperative sieve though. I don't bother with segmented though, it doesn't tend to matter.
09:27:22 <yoho> infinisil: yes and I'm not sure what they are. yahb is a fully fledged ghci but it looks like it doesn't have that package either
09:27:46 <p0a> ertes: that's okay. I have C experience so I'm not going to be weirded out
09:28:22 <infinisil> primes are like the most important numbers though!!1!
09:28:24 <p0a> but not much Haskell experience. so if it requires advanced stuff that I haven't yet learned yeah... maybe that' dbe troubling
09:28:25 <kadoban> ertes: Depends what you consider proper I suppose. The o'neill paper I consider a proper sieve and it's not very imperative. But it's not that performant relatively either.
09:28:27 <glguy> Project Euler is more about math than programming. If you're interested in some programming tasks a lot of us have done the Advent of Code tasks recently
09:28:50 <p0a> glguy: yeah programming is more interesting to me
09:29:25 <ertes> p0a: also PE problems are interesting, but if you want to learn haskell as a utility, you should find other problems to work on…  with PE problems you will never experience anything but the toy aspect of haskell
09:29:48 <ertes> it's utterly useless for practical haskell
09:29:54 <p0a> alright
09:29:56 <p0a> cool
09:31:49 <ertes> p0a: my personal recommendation is to just do a toy project of your own…  something you could actually use…  trust me, that's more challenging than it sounds =)
09:31:49 <yoho> PE is pretty useless for any practical programming past learning some core concepts/syntax ime
09:32:24 <p0a> yeah but the problem is that if I were to do my own project I'd probably do it in C++
09:32:30 <p0a> because I'm better in C++ than Haskell
09:32:32 <p0a> so the urge is there
09:32:37 <p0a> to use that instead
09:32:43 <yoho> well then you're missing the point of doing the project explicitly to learn haskell :P
09:32:50 <p0a> lol yeah
09:33:15 <ertes> p0a: do a project with lots of concurrency =)
09:33:18 <p0a> Idk instead of a project I wanted to practice some concurrent stuff
09:33:19 <p0a> yes!
09:33:39 <p0a> I've seen books called "distributed algorithms". I think that's what I want? I don't know. I wasn't able to find problems online
09:33:48 <p0a> but I got hooked after a roommate described a CS project he had to do
09:33:49 <ertes> you won't be tempted to do that in C++, once you learn haskell's take on concurrency…  in fact you might hate doing anything with threads in C++ ever again =)
09:34:12 <ertes> optionally read The Book
09:34:17 <ertes> @where PCPH
09:34:17 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>
09:34:51 <monochrom> No, after you have learned Haskell's take on concurrency, you will expect C++ to live up to that, and then you will be grossly disappointed.
09:35:52 <p0a> It's just that it's hard to find problems to solve that require concurrency
09:36:02 <p0a> and are /toy/ problems, or small projects.
09:36:06 <monochrom> Sieving.
09:36:13 <p0a> I don't want to write my own chat server/client for instance. Sieving? wow
09:36:15 <merijn> p0a: Simple: parallel webscraper for a webcomic
09:36:36 <merijn> p0a: I wrote one in Haskell in like 80 lines of code (although I think it's bitrotted now)
09:36:48 <Costar> Write your own cryptocurrency
09:36:51 <hpc> i wrote an http stress tester of about the same length
09:37:17 <p0a> yea but all that involves networking. Here's a problem that I thought was very cool: start with random points on the plane, your "soldiers". Start with a "base". (random as well). The soldiers have to walk to the base using minimal steps. They can't step on each other
09:37:19 <ertes> p0a: do you enjoy por… image boards?  write a parallel downloader that can download from multiple sites
09:37:21 <hpc> it spins up request threads until the server can't handle any more, then slowly scales back and forth to find the maximum concurrency it supports
09:37:40 <infinisil> p0a: I have something that requires concurrency for you, recently created something like this
09:37:45 <monochrom> Anything that uses a "select loop" can benefit from converting to Haskell thread.s
09:38:21 <p0a> So it's a geometric problem involving the integer lattice. It's pretty nifty
09:38:23 <merijn> p0a: What's the problem with involving networking?
09:38:33 <p0a> merijn: scrappers as suggested above.
09:38:33 <hpc> you also can use concurrency for anything where you perform the same task multiple times, with no data dependency
09:38:47 <merijn> p0a: No, I mean, why is that an issue?
09:39:09 <p0a> merijn: well I'd have to have a real target. Then I'd have to make sure that legally I'm not doing anything wrong
09:39:14 <ertes> p0a: if you want to do something number-theoretic, write a quadratic sieve in haskell…  that can also benefit from haskell's concurrency
09:39:30 <p0a> okay since you guys are pressing me here's one such task: I'd like to write a Reddit statistics tool
09:39:36 <ertes> p0a: or perhaps the index calculus algorithm…  it's structurally similar, but easier to understand
09:39:55 <p0a> Something that helps me categorize the news every day and the people that post in those threads. To "spot" propaganda etc
09:40:02 <p0a> or news trends. things like that
09:40:26 <monochrom> An interpreter for a non-strict language. The interpreter uses concurrency to provide non-strictness.
09:40:46 <ertes> p0a: anything that is useful to you
09:40:52 <ertes> useful or entertaining
09:40:57 <monochrom> For example "x && y" is done by evaluating x and evaluating y concurrently.
09:41:10 <hpc> a concurrent solver for a game of some sort?
09:41:49 <infinisil> p0a: Build a server for a 2-player game whose purpose is to pair up 2 clients (including handling disconnects, etc.), and simulates a game based on the clients moves
09:42:13 <infinisil> this requires concurrency in 2 different aspects
09:42:14 <p0a> Some sort of data analysis of the reddit threads/posts. But that's mostly taking the data from the server and then you can decide what to do with it. and I'm not quite sure how legal it is to take that data (obviously depends on how aggressive you are)
09:42:20 <monochrom> People call it "speculative evaluation" but I think it is not spectacular enough. I call it "crazy evaluation" so it rhymes with "lazy evaluation".
09:42:41 <ertes> as far as solvers go, i like index calculus or anything based on dixon's method (quadratic sieve/NFS), because you can use concurrency *and* parallelism
09:42:45 <p0a> infinisil: that sounds cool
09:42:50 <ertes> especially if you want to write a distributed version of it
09:43:16 <ertes> but of course it's number theory, so there is a learning curve
09:43:24 <ertes> (aside from haskell itself)
09:43:51 <infinisil> p0a: Additionally, make clients able to restore the game upon disconnecting
09:43:55 <p0a> infinisil: wouldn't a first thing be to write a chat server though? I mean, a game server is a beefed up chat server
09:44:16 <p0a> infinisil: a "two person" chat server. tuples of clients
09:44:30 <infinisil> p0a: The tricky part is pairing up clients and handling disconnects
09:44:33 <infinisil> yea
09:44:39 <infinisil> something like that
09:44:54 <ertes> p0a: i like the reddit idea as a tool, but it might be rather "boring" from an engineering standpoint…  you just download posts and feed your statistical model
09:45:15 <infinisil> I recently implemented such a game server
09:45:23 <ertes> haskell is particularly good at stuff that is traditionally difficult to engineer
09:45:32 <monochrom> All GUIs should have been concurrent, if people didn't mess it up with mutable shared variables.
09:45:55 <p0a> ertes: well part of the idea is that you "shape" the statistical model as you read the news
09:46:29 <ertes> p0a: if you abstract the "reddit" away, then it becomes a lot more interesting =)
09:46:33 <p0a> ertes: i.e. you read a post on propaganda from Mars, so you tag it "Mars propaganda". You'd automatically get an option to tag later posts as mars propaganda later
09:47:14 <ertes> p0a: the way i would implement that it sounds like downloading and database operations
09:47:21 <p0a> Idk. there was a need for spam filters back in the day and I feel there's a need for idiot filters nowadays when we read the news
09:47:37 <p0a> at the risk of building your echo chamber of course
09:47:37 <monochrom> http://www.imdb.com/title/tt1034314/ propaganda from Moon :)
09:47:49 <ertes> p0a: interesting side note…  the abuse filter of facebook is written in haskell =)
09:47:54 <p0a> heh
09:48:53 <ertes> if i understood it correctly, it's a massively concurrent and distributed rule-based system
09:49:06 <p0a> fb's filter?
09:49:21 <ertes> yeah…  in fact they open-sourced their rule engine DSL: it's called haxl
09:49:29 <sqooq> for those who have seen me coming in here and complaining about the audio library thing I'm trying to make
09:49:39 <mdupont> How can I create an instance of Word or Word32
09:49:43 <sqooq> I finally did a correct delay line in ST
09:49:47 <sqooq> but it's nasty
09:49:59 <ertes> mdupont: Word and Word32 are both types…  you create instances of type *classes*
09:50:12 <geekosaur> mdupont, I think your OO background is confusing you.
09:50:24 <geekosaur> > 3 :: Word32
09:50:28 <ertes> mdupont: consider Word the "native" machine word type for your architecture, so it's most likely Word64
09:50:30 <lambdabot>  3
09:54:15 <p0a> thanks everyone. cu
09:55:00 <mdupont> yes, thanks
10:03:15 <metahumor> sqooq: what's nasty about it?
10:03:56 <sqooq> metahumor, well my actual running function is nasty but that's just me not knowing how to clean it up I'm pretty sure, otherwise the only nasty thing is having to pass a variable around all over the place
10:04:15 <sqooq> but you know what, I've come to accept that that's a lot better than changing a variable and not even knowing it
10:04:45 <infinisil> that's what makes haskell pure
10:04:51 <sqooq> otherwise my one pole filter function is pretty clean, just read the delayline, use it and delay it
10:05:15 <evgeny666> Hello
10:05:17 <metahumor> care to share your implementation?
10:05:20 <metahumor> hi
10:05:58 <sqooq> metahumor, ok, give me a sec. The "runTest" function is how I grab a list out of it and it's the ugly function. I literally use two dummyish variables to increment and countdown.
10:08:03 <sqooq> http://lpaste.net/361415
10:08:35 <sqooq> ignore "saw" it's incorrect. Should involve an integral or delayed sum.
10:08:44 <sqooq> the delay stuff is at the bottom
10:11:13 <infinisil> i don't know about the usage of ST for that
10:12:29 <infinisil> sqooq: have you looked at reactive programming?
10:12:39 <infinisil> functional reactive programming*
10:12:54 <sqooq> this is sort of a bare bones frp
10:12:58 <sqooq> so yes I ahve
10:14:14 <sqooq> infinisil, if not ST then what. I've been trying to do this for literally a month. Like it's so recursive it becomes problematic without storage
10:15:56 <[exa]> hm guys, is there some good introductory material to FRP?
10:17:16 <sqooq> [exa], conal's lectures
10:17:44 <sqooq> his stuff is here
10:17:45 <sqooq> https://github.com/conal/talk-2015-essence-and-origins-of-frp
10:17:55 <sqooq> not "lectures" just "talks"
10:18:02 <sqooq> he's not like teaching a class lmao
10:18:13 <metahumor> can you explain what the different Doubles are in onePole?
10:18:45 <sqooq> metahumor, 'a' and 'b'?
10:19:03 <metahumor> and x
10:19:10 <sqooq> x :: Signal Double Double
10:19:22 <sqooq> Signal is really Signal time output
10:19:33 <sqooq> so it takes a double time and outputs a double
10:19:58 <sqooq> but it's wrapped up (to allow for applicative and stuff), so I use "grab" to grab the function and apply it to the current time 't'
10:20:26 <sqooq> I could have also used applicative inside and grabbed at the end
10:20:34 <sqooq> but that's less efficient and messy
10:21:43 <sqooq> onePole is just a filter, so it's just doing math that filters frequencies on the signal outputs.
10:22:00 <sqooq> a and b are coefficients that control the gain and depth of the filtering.
10:22:11 <sqooq> x is the input signal
10:22:38 <infinisil> sqooq: Just stumbling around a bit, have you had a look at http://hackage.haskell.org/package/YampaSynth ?
10:22:46 <metahumor> am I mistaken that you're just writing a Store Comonad?
10:25:00 <sqooq> infinisil, yes I have, it seems to be focused on other things
10:25:17 <sqooq> I still have no clue how their oscSin definition would be efficient but I guess I just don't understand yampa
10:25:39 <sqooq> because really that's a pretty recursive function when it takes the integral
10:25:48 * hackage crdt 6.1 - Conflict-free replicated data types  https://hackage.haskell.org/package/crdt-6.1 (cblp)
10:26:08 <sqooq> yampa's integral function is probably defined in such a way to avoid this but that requires keeping track of past results so idk.
10:27:41 <sqooq> pretty sure yampa has global variables or something
10:28:10 <sqooq> actually ignore that
10:28:13 <sqooq> idk what I'm saying
10:29:24 <sqooq> but yeah the yampa integral uses an "a_prev" which I'm pretty sure is the previous calculation. But I don't know where it comes from. The signals themselves maybe have a built in state..? Idk.
10:30:38 <infinisil> sqooq: Arrows
10:30:47 <infinisil> I think
10:30:57 <sqooq> Arrows allows them to access the previous result?
10:30:58 <infinisil> yeah arrows
10:31:00 <sqooq> in time?
10:31:10 <infinisil> arrows are magic, they probably can do that
10:31:15 <sqooq> hmm
10:31:28 <infinisil> arrows can do whatever you want, it's like a better Monad
10:31:39 <sqooq> lmao
10:31:59 <sqooq> ertes, is this true, are arrows what allows the previous value to be used in the integration?
10:32:12 <infinisil> you might want to read a bit about arrows. Rather interesting topic, seems they're pretty powerful, although I've never used them personally
10:32:21 <sqooq> I don't like them really
10:32:28 <sqooq> I'd prefer to keep my code arrow free
10:32:41 <infinisil> but arrows are like the abstraction you need..
10:32:46 <infinisil> most likely
10:33:58 <sqooq> I don't want them lmao
10:34:12 <sqooq> No one can even understand them
10:34:27 <sqooq> by no one, I mean myself
10:34:29 <sqooq> and you
10:34:34 <infinisil> you not understanding them is not generalizable to everybody else
10:34:46 <infinisil> i understand them somewhat
10:34:51 <sqooq> You admit they're difficult though?
10:34:58 <sqooq> I don't want my users to have to understand arrows
10:35:01 <sqooq> to do stuff
10:39:07 <[exa]> sqooq: well I'm planning to write a GTK-like application and was kindof thinking if FRP could be applied
10:39:44 <metahumor> sqooq: i'm still trying to understand onePole. you're taking a stored value "y" and a function "f", and then return a new function "g" that can return "f y t"
10:39:47 <metahumor> right?
10:39:48 <sqooq> [exa], probably. That's like it's main use case.
10:40:33 <sqooq> metahumor, umm, well it's not taking in any functions. Are you talking about the whole "Signal $ \t ->" thing?
10:40:46 <sqooq> that's just turning it into a signal
10:41:04 <metahumor> Signal is just wrapping a function
10:41:08 <sqooq> yes
10:41:42 <sqooq> so onePole takes a stored variable. Accesses it, then basically stores it and returns the current calculation there.
10:41:53 <sqooq> stores the calculation that is
10:41:57 <sqooq> b*grab...
10:42:49 <sqooq> metahumor, I can give you the signal flow to give you an idea. the concept of "delay" is that it takes an input at current time t and ouputs it some time later t+n
10:43:33 <metahumor> sqooq: is the following close to what you want?
10:43:56 <metahumor> :t \ys f t -> ys >>= pure . f t
10:43:57 <lambdabot> Monad m => m a -> (t -> a -> b) -> t -> m b
10:44:14 <sqooq> what I want for what?
10:44:34 <metahumor> ys holds your y value, f is some function that takes "time" and "y value", and you get back a function that takes "t" and gives you a "state of transformed y values"
10:45:15 <sqooq> idk maybe
10:46:02 <sqooq> the chart at the top is the signal flow graph for a one pole
10:46:03 <sqooq> https://ccrma.stanford.edu/~jos/fp/One_Pole.html
10:46:25 <sqooq> z^-1 is a 1 sample delay
10:48:55 <sqooq> lmao the yampasynth's sine definition is wrong
10:49:06 <sqooq> he's supposed to multiply 2 pi after taking the integral
10:49:06 <jgt> how do I conditionally use a Database.Esqueleto.where_?
10:49:51 <jgt> I want to do something like where_ (company E.^. CompanyDateOfCreation E.>=. x)
10:50:22 <jgt> if x is a (Just a), then there where_ should be used
10:50:33 <jgt> then the* where_
10:50:48 <jgt> if the x is Nothing, the whole line should be a noop
10:50:48 <ertes> sqooq: context?
10:51:01 <[exa]> sqooq: oh wow there's frpnow-gtk
10:51:09 <[exa]> sqooq: thanks. :]
10:51:22 <ertes> sqooq: my default response to anything about arrows is: they're terrible, don't even think of using them
10:51:54 <sqooq> ertes, https://github.com/giorgidze/YampaSynth/blob/master/src/SynthBasics.hs
10:51:59 <sqooq> the oscSine definition
10:52:06 <ertes> sqooq: why yampa?
10:52:07 <sqooq> But now that I look at it...frequency is just a double???
10:52:17 <sqooq> ertes, not me using it lol
10:52:32 <sqooq> someone said to check it out, and I was confused how their integral was working
10:52:45 <sqooq> https://hackage.haskell.org/package/Yampa-0.10.7/docs/src/FRP-Yampa-Integration.html#integral
10:53:41 <ertes> sqooq: FRP can in principle do integration over time…  just multiply each delta by the length of the frame
10:53:44 <sqooq> because the integral is from 0 to t of the frequency changes. so for every t, if you don't memoize, it will be highly innefficient, but the memoization is completely hidden in that usage. But like I said, I'm confused how they're even integrating a double?
10:54:21 <sqooq> ertes, ok so I guess my question is, how are they accessing the delta?
10:54:32 <ertes> sqooq: it's far simpler operationally that you seem to imagine
10:54:44 <dexterfoo> what's the best HTML combinator library that the community has standardized on?
10:55:10 <ertes> sqooq: time deltas are an implementation detail…  unless you're an FRP implementor just consider it a black box
10:55:20 <sqooq> ertes, I've done brute force implementation. I definitely understand the concept.
10:55:28 <sqooq> ertes, I sort of am an FRP implementor LMAO
10:55:40 <sqooq> I'm trying to make an FRP system focused on audio
10:56:04 <sqooq> actually that's not true. I just want to make a clean audio library, I just happen to be using a lot of the FRP concepts.
10:56:41 <sqooq> ertes, also for a sine wave with frequency change it's the integral from 0 to t, it's not just the integral of the signal.
10:56:49 <sqooq> so you have to continuously add to the previous result.
10:57:22 <sqooq> at t=1, it's int 0 1 x, at t=2 it's int 0 2 x, in other words at t=2 it's int 1 2 x + int 0 1 x
10:57:24 <ertes> why would you make an FRP system focussed on audio?  that's like making a HTTP server library focussed on green web forums with animated emoticons
10:58:10 <sqooq> ertes, I corrected myself, I'm making a system focused on audio, it just so happens that the way to do things ends up being a lot like FRP.
10:58:38 <ertes> you could just…  you know…  use FRP =)
10:58:49 <sqooq> I tried that
10:59:00 <sqooq> I don't understand how to actually use it
10:59:26 <ertes> i seem to remember giving you a few resources on that
10:59:42 <sqooq> ertes, yes, I learned a lot about it, hell I've basically made a bare bones implementation of it.
10:59:51 <sqooq> I still don't know how to *use* it for my particular case
10:59:57 <sqooq> I have no clue how to set the loop in motion.
11:00:13 <sqooq> Because all the details are hidden, I don't know how anything is working so I don't know how to reason about it.
11:00:17 <Rembane> Is there an identity semigroup out there? I want to foldMap a list and get back the same list.
11:01:07 <ertes> Rembane: what's the type instantiation of foldMap that you need?
11:01:40 <chasebase> new-ish Haskeller here, need a bit help figuring out if the problem is with a library (Blaze SVG) or me?
11:02:10 <geekosaur> chasebase, you'd do better asking the actual question
11:02:23 <geekosaur> dexterfoo, the haskell community is not very good at "has standardized on"
11:02:37 <ertes> > foldMap pure [1,2,3] :: [Integer]
11:02:40 <lambdabot>  [1,2,3]
11:02:55 <jgt> trying this for my Esqueleto problem, but it doesn't compile: when (isJust (Just d)) E.where_ (company E.^. CompanyDateOfCreation E.>=. E.val d)
11:02:55 <Rembane> ertes: This, kinda? (??? t ByteString, Max Int)
11:03:06 <Rembane> ertes: Thank you!
11:03:22 <ertes> Rembane: you could just use 'id'
11:03:30 <ertes> > id [1,2,3]
11:03:34 <lambdabot>  [1,2,3]
11:03:39 <sqooq> ertes, for example reactive-banana has a "model" library that should be able to do everything as the real one but less efficiently. Looking at that page, I have literally zero clue how to use any of it. I have no clue how to construct a constant frequency sine wave. I have even less of a clue how to do a modulating frequency sine wave.
11:04:26 <chasebase> I'm using Blaze SVG and expected this line -- S.tspan ! A.dx (stringValue . show $ d) $ do (strig [ch]) -- to work, where everything after the $ is to be the contents of the tspan.  I've done this in other contexts, but it doesn't seem to work with this tag.
11:05:03 <Rembane> ertes: I combine it with a semigroup using the product and that makes things more interesting, I think pure helps me the most here.
11:05:09 <ertes> sqooq: you can't use the model for real applications…  consider it a test suite or prototype semantics…  you use Reactive.Banana.Frameworks to connect an FRP application to the real world
11:05:28 <sqooq> ertes, ok but I can't even use it as a test suite. How do I even construct a signal?
11:05:33 <geekosaur> chasebase, ($) is not going to magically figure out where it stops, it is a noirmal operator with low precedence
11:05:50 <geekosaur> if that precedence happens to be wrong in some context, ($) won't do what you apparently expect it to
11:05:53 <ertes> sqooq: ignore the model…  it's only useful to understand the semantics of FRP, but nothing else
11:05:57 <sqooq> it says behavior is a list. So do I have to actually map my sine wave across specific values??? That doesn't feel very continuous.
11:06:29 <sqooq> ertes, I literally observed for hours everything else
11:06:36 <sqooq> and I still have zero clue how to accomplish anything.
11:07:04 <sqooq> This also goes for reflex
11:07:16 <ertes> sqooq: do you know how people just get even more confused when they learn that IO is implemented like a state monad of the state of the universe?  same thing here…  you're probably just confusing yourself by looking at the model
11:07:18 <chasebase> geekosaur, reflecting on this now.  i haven't had issues with $ so far but i should be able to parenthesize explicitly or whatever to rule this out
11:07:43 <sqooq> ertes, I looked outside the model though. I'm just as confused.
11:08:08 <sqooq> tbh this is most haskell libraries
11:08:09 <ertes> sqooq: look for small reflex examples…  and i mean *reflex* examples, not reflex-dom
11:08:11 <sqooq> their documentation sucks.
11:08:40 <sqooq> ertes, I did that too, since it's gui stuff, I still have no clue what's going on lmaooo
11:09:08 <MarcelineVQ> Cale usually has some easy to approach examples for reflex when prompted
11:09:52 <MarcelineVQ> Rather I should say has had, usually carries more meaning :>
11:10:00 <sqooq> It has literally been easier for me to just build everything from scratch than to try and use a library. I've spent more hours trying to figure out the libraries, than I have coding and I've gotten much farther coding.
11:10:43 <ertes> sqooq: ok, i'm gonna give you step-by-step exercises now
11:10:49 <ertes> sqooq: if you're willing to do them
11:10:53 <sqooq> I am
11:11:03 <wedify> me too
11:11:08 <sqooq> I have a bad feeling
11:11:21 <sqooq> I'm gonna get into an frp system, and realize it can't handle delay lines nicely
11:11:32 <MarcelineVQ> me too
11:11:34 <sqooq> and realize I have to go back to where I came form
11:11:42 <yoho> me too thanks
11:12:04 <ertes> sqooq: using reflex write the following function:  myApp :: (MonadHold t m, Reflex t) => Event t Char -> m (Behavior t String)
11:12:31 <ertes> sqooq: the function should turn the character event into a string behaviour that just appends each incoming character
11:12:48 * hackage safe 0.3.16 - Library of safe (exception free) functions  https://hackage.haskell.org/package/safe-0.3.16 (NeilMitchell)
11:12:55 <jgt> Ok, I fixed my Esqueleto problem, but sprunge.us is not working properly right now :(
11:13:39 <ertes> sqooq: imagine a small terminal interface (that you're going to build later) that lets you type characters, and displays the resulting behaviour at the same time, so it would look like an insert-only editor
11:13:50 <jgt> here's my conditional E.where_ query, with a case statement: https://gist.github.com/jezen/309bfb4d13494ef7ff03919cdacfc0aa
11:14:04 <jgt> is there a nicer way to do that? Maybe without the case statement?
11:14:35 <ertes> sqooq: if you're lost, don't hesitate to ask for hints
11:15:05 <chasebase> okay i tried writing it a bit differently, but not sure how I could be misunderstanding $.  I have used similar code to -- S.tspan ! A.dx (stringValue . show $ d) $ do (string [ch]) -- with other SVG tags and it's only failing here.  Error is The first argument of ($) takes one argument, but its type `blaze-markup-0.7.1.0:Text.Blaze.Internal.MarkupM ()' has none.
11:15:25 <sqooq> ertes, i'm lost
11:15:45 <ertes> sqooq: first hint: you will need 'foldDyn' and 'current'
11:15:48 <chasebase> I looked previously at blaze SVG source and the tags that were working were not MarkupM () they had something instead of the unit type.... so could Blaze SVG just define tspan wrong??
11:16:12 <ertes> sqooq: oh, sorry, you also need a (MonadFix m) constraint
11:16:34 <ertes> sqooq: myApp :: (MonadFix m, MonadHold t m, Reflex t) => Event t Char -> m (Behavior t String)
11:16:38 <sqooq> lmao
11:16:39 <chasebase> it compiles if you remove "$ do (string [ch])" but the tpsans are of course empty
11:16:43 <sqooq> good luck to everyone else
11:16:52 <sqooq> if anyone else who doesn't already know reflex
11:16:53 <sqooq> manages to do it
11:17:02 <sqooq> I would be shocked
11:17:14 <ertes> sqooq: don't focus too much on the constraints…  the important part is that it takes an event and returns a behaviour
11:17:21 <ertes> the constraints are just book-keeping
11:19:48 * hackage collection-json 1.1.2.0 - Collection+JSON—Hypermedia Type Tools  https://hackage.haskell.org/package/collection-json-1.1.2.0 (alunduil)
11:22:53 <geekosaur> chasebase, I would guess you are using it with a predefined tag that normally doesn't take a parameter. which could be a bug on your part or a difference somewhere (spec version?)
11:22:59 <woodson_> Hi anyone can share their thoughts about Reflex, Miso and concur framework?
11:24:41 <sqooq> ertes, when do I give up
11:25:22 <[exa]> @pl (g .) . f
11:25:22 <lambdabot> (g .) . f
11:25:41 <[exa]> @pl \x -> g . f x
11:25:42 <lambdabot> (g .) . f
11:25:59 <[exa]> ok then.
11:26:12 <ertes> sqooq: if you stop being so sarcastic, you'll find that it's a lot easier than you thought
11:27:29 <ertes> sqooq: if you can't figure it out, ask me for another hint
11:27:47 * hackage network-uri-json 0.1.2.0 - FromJSON and ToJSON Instances for Network.URI  https://hackage.haskell.org/package/network-uri-json-0.1.2.0 (alunduil)
11:29:15 <sqooq> I can't get reflex to even build
11:30:32 <chasebase> geekosaur, thanks.
11:30:39 <[exa]> sqooq: which method are you following?
11:30:52 <sqooq> ?
11:30:56 <MarcelineVQ> the easiest way I ​know of to try reflex is to use the try-reflex repo unfortunately
11:31:08 <sqooq> I put it in my cabal and it complains, then I put the dependencies into the yaml, and it complains
11:31:18 <metahumor> sqooq: I think I made a simpler version of your onePole that works
11:32:05 <[exa]> sqooq: what does it complain about?
11:32:19 <sqooq> base
11:32:36 <metahumor> sqooq: http://lpaste.net/361419
11:33:25 <[exa]> sqooq: something more specific?
11:33:28 <ertes> sqooq: well, dinner is ready…  i'll be back later, and if you can't get reflex to build, we'll switch to reactive-banana…  however, i'm fairly sure that reflex is much more suitable for your kind of application, so try to get it to work
11:33:58 <metahumor> sqooq: ">  runTest 7                                                                              [[0.0,0.0,0.0,0.5,-4.999999999999999e-2,0.34500000000000003,-0.11050000000000004]]       "
11:34:14 <sqooq> metahumor, >simpler
11:34:23 <sqooq> and you got the wrong answer lmaaao
11:34:39 <metahumor> sqooq: ">runTest 7" gives me "[[0.0,0.0,0.0,0.5,-4.999999999999999e-2,0.34500000000000003,-0.11050000000000004]]"
11:34:50 <sqooq> you should only be able to run up to 5
11:34:58 <sqooq> because the list only has 5 elements
11:35:05 <sqooq> I made tht list as a really bad way to test
11:35:10 <metahumor> so get rid of the "repeat 0" in my ltos defn
11:35:18 <sqooq> the actual answer should be [0.1,0.11,0.20100000000000004,0.2191,0.30281]
11:36:14 <sqooq> metahumor, also the concept of "delay" should be generalized
11:36:20 <sqooq> so you can delay by 5 steps just as easily as one
11:36:54 <sqooq> in my example I made it a unit delay by default, but an actual system using arrays shouldn't be much more difficult, would just require modulo indexing
11:37:02 <sqooq> using ST
11:37:33 <metahumor> sqooq: to generalize delay, parametrize "runn" to be "runn f delay" and do "put (y, delay t)"
11:37:47 <kakashiA1> the notation [a, b..c] is just suggar for the enumFromThenTo function O_O]
11:38:39 <kakashiA1> my qiestion is what does this function means?  I mean enum means enumerate but what does From Then and To means?
11:39:18 <kakashiA1> why not calling it enumFromTo?
11:39:18 <Clint> do you know what [a, b..c] means?
11:39:37 <kakashiA1> Clint: I can explain it if you want
11:39:40 <sqooq> metahumor, i don't understand but neat, if it works
11:39:46 <sqooq> it doesn't give the correct result currently
11:39:50 <sqooq> but I don't quite understand it
11:39:56 <Clint> kakashiA1: [a..b] would be from-to
11:39:58 <metahumor> kakashiA1: From is the first element, Then is the second element, then To is the limit, such that the function returns [From, Then, Then + (Then - From), Then + 2 * (Then - From), ... To]
11:40:24 <kakashiA1> metahumor: thanks :)
11:41:02 <sqooq> I can't get reflex to work
11:41:04 <sqooq> stack solver fails
11:41:21 <sqooq> this is a clean project btw, so the only thing in my cabal is reflex
11:41:28 <kakashiA1> Clint: stupid question but is there a enumFromTo function?
11:41:56 <MarcelineVQ> I feel like I'm taking crazy pills.
11:42:17 <Clint> kakashiA1: http://hayoo.fh-wedel.de/?query=enumFromTo
11:42:21 <metahumor> MarcelineVQ: deja vu all the time, huh
11:42:41 <MarcelineVQ> metahumor: you're reading me like a book
11:43:15 <kakashiA1> Clint: EUREKA! almost all short and suggary list notations are just suggar for functions O_O
11:43:43 <jgt> does anyone know how to write this without the case statement? https://gist.github.com/jezen/309bfb4d13494ef7ff03919cdacfc0aa
11:44:21 <kakashiA1> jgt: with guards?
11:44:50 <jgt> kakashiA1: ok, so in one line then :P
11:45:03 <kakashiA1> jgt: you know what guards are?
11:45:41 <jgt> kakashiA1: usually they're written on multiple lines with pipes, right?
11:45:56 <jgt> pipes the operator, not pipes the streaming library
11:46:16 <sqooq> ertes, if i could actually test it `myApp e = current $ foldDrn (\x y -> y ++ "x") [] e
11:46:34 <sqooq> but I still don't know what I'm doing.
11:46:36 <jgt> I had thought to use Data.Maybe.maybe, but I couldn't get it to work
11:47:00 <orion> In an STG machine, data values and function values are represented uniformly as closures. These closures consist of a code pointer along with zero or more pointers to free variables. Is it correct to think of the code pointer as a "continuation"?
11:47:21 <orion> And when you JMP in to that code, would it be correct to call that "reducing the graph"?
11:48:12 <jgt> kakashiA1: wouldn't guards actually be worse than a case statement here? I'm seeing it as a guard with an isJust
11:48:29 <kakashiA1> jgt: its something like this: https://paste.xinu.at/DEcMD/hs
11:49:06 <jgt> kakashiA1: well, so, yes. I know what guards are. And I think that'd be worse than the case statement.
11:49:22 <[Leary]> jgt: maybe (return ()) (\d -> ...) md
11:49:39 <kakashiA1> jgt: order is important here, so it depends what you like and what is more redable in your eyes :)
11:49:53 <jgt> [Leary]: ah yes, that'll be it. I forgot the return!
11:51:21 <[Leary]> As a side-note, you can pattern match in guards, so you wouldn't need an isJust if you used them instead of case.
11:53:37 <[Leary]> > let f x | Just b <- x = b+1 in f (Just 1)
11:53:40 <lambdabot>  2
11:57:07 <metahumor> sqooq: I made it simpler, getting the same answer
11:57:38 <AndreasK> orion: I think calling it a continuation is fair. But I don't think just jumping to the code is enough to qualify as reducing the graph
11:58:03 <sqooq> metahumor, link
11:59:48 <jgt> [Leary] kakashiA1: my little handler is coming along nicely https://gist.github.com/jezen/4ef704397c59eb16d2eff53ff5d6ff7c
11:59:56 <orion> AndreasK: Ok. What does it look like when you reach the end of a continuation?
12:00:09 <metahumor> sqooq: http://lpaste.net/361419
12:00:48 <AndreasK> orion: I will defer making statements from halfbaked knowledge and link you to https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode instead
12:00:51 <kakashiA1> jgt: looks pretty
12:00:57 <sqooq> metahumor, that's not the right answer I don't think...
12:01:10 <sqooq> first result should be 0.1
12:01:16 <jgt> :D
12:01:58 <sqooq>  [0.1,0.11,0.20100000000000004,0.2191,0.30281]
12:02:02 <sqooq> should be the result
12:04:20 <sqooq> I had to use "allow-newer: true" to get my package with reflex to build, is that bad
12:04:20 <metahumor> AH
12:04:21 <metahumor> got it
12:04:43 <sqooq> nvm it failed
12:04:52 <sqooq>     Cabal-simple_mPHDZzAJ_2.0.1.0_ghc-8.2.2: The program 'happy' version >=1.19 is
12:04:52 <sqooq>     required but it could not be found.
12:06:26 <sqooq> metahumor, just stop wasting your time. To me you're getting more complex. My run function imo is the only non-simple thing and that's because I'm doing a brute force incrementation and countdown. I think I could probably just use fmap...
12:06:53 <metahumor> sqooq: I fixed it
12:07:01 <metahumor> http://lpaste.net/361419
12:07:18 * hackage hspec 2.4.6, hspec-discover 2.4.6, hspec-core 2.4.6 (SimonHengel): https://qbin.io/20zco6g
12:07:20 <metahumor> runTest 5 will also work, and give you what you need
12:07:38 <metahumor> you really want "evalState"
12:15:15 <unyu> What do you call a functor F such that the canonical map “split :: F (a, b) -> (F a, F b)” is an isomorphism?
12:15:57 <sqooq> metahumor, neat, I made mine simpler too
12:15:58 <sqooq>   traverse (grab (onePole dline 0.9 0.1 $ ltos [1,2,3,4,5])) [0..5]
12:16:11 <sqooq> in the runTest function, completely replacing "runn"
12:16:12 <unyu> For example, “data Pair a = Pair a a” fits the bill, but [] does not.
12:16:14 <hpc> unyu: Identity, probably
12:16:25 <mniip> nope, Maybe is one too
12:16:27 <sqooq> though the first element is 0, and the the rest are correct, not sure what's going on there
12:16:27 <hpc> oh, hmm
12:17:17 <mniip> (Maybe a, Maybe b) -> Maybe (a, b)  only has one monomorphic implementation
12:17:19 <unyu> mniip: No, I don't think Maybe fits the bill. With Maybe, “split” is merely a monomorphism.
12:17:46 <mniip> unyu, as a natural transformation it is an isomorphism
12:17:53 <mniip> pointwise of course it isn't
12:18:31 <unyu> mniip: split (unsplit (Just 1, Nothing)) --> (Nothing, Nothing)
12:18:38 <lyxia> unyu: "strong opmonoidal functor"? https://ncatlab.org/nlab/show/oplax+monoidal+functor
12:18:47 <unyu> lyxia: Checking, thanks.
12:18:50 <mniip> hmm
12:19:53 <lyxia> unyu: and well since it's an isomorphism, inverting split makes it a strong monoidal functor
12:21:46 <lyxia> ah, almost, strong monoidal functors must also have unit which is an isomorphism.
12:23:04 <unyu> Maybe this just isn't a generally useful structure. I just happen to need it now. I'll just bite the bullet and define a type class for it.
12:23:11 <i-am-the-slime> garg
12:23:38 <i-am-the-slime> how do I print something with a ToJSON instance?
12:25:04 <unyu> i-am-the-slime: Without having ever used Aeson in my life, from a quick inspection of its documentation, perhaps “show . toJSON” ?
12:25:21 <troido> i-am-the-slime `print encode myThing`?
12:26:04 <i-am-the-slime> that gives me a nice [12, 2, 42] kind of thing
12:26:14 <i-am-the-slime> which I guess is the show on a bytestring
12:27:13 <cocreature> Data.Text.Lazy.putStrLn . encodeToLazyText
12:28:03 <i-am-the-slime> So there's no putStrLn for bytestreams? Maybe putStrLnUtf8 ?
12:28:05 <i-am-the-slime> okay okay
12:28:25 <cocreature> http://hoogle.haskell.org/?hoogle=putstrln%20package%3Abytestring
12:28:53 <i-am-the-slime> Nice! I did not know about package:
12:31:04 <i-am-the-slime> Thank you cocreature
12:31:33 <i-am-the-slime> I get "it is a member of the hidden package bytestream-..."
12:31:45 <i-am-the-slime> Is that because I don't have an explicit dependency on bytestream_
12:31:50 <cocreature> you probably need to add bytestring to build-depends
12:32:22 <i-am-the-slime> Okay now the first option sounds more attractive again.
12:32:48 <i-am-the-slime> Is there some tooling where when I write "encodeToLazyText" in the editor, I can import it? Intero can't do this, right?
12:38:47 * hackage th-desugar 1.8 - Functions to desugar Template Haskell  https://hackage.haskell.org/package/th-desugar-1.8 (RichardEisenberg)
12:50:43 <hoon> I have a question about using Either as a Monoid -- I have implemented it, but receive an orphan warning in ghci; can someone take a look? http://lpaste.net/361422
12:51:32 <geekosaur> you have an orphan instance if you declare the instance somewhere other than where either the type being instantiated or the class is declared
12:51:51 <geekosaur> this is because instances are global, not scoped to a module, and must be for the type system to be consistent
12:51:59 <hoon> right, and it suggests a "newtype" to solve the problem
12:52:14 <geekosaur> the watrning can be ignored if you are working in ghci or doing it in a program. in a library, you should rethink what you are doing
12:52:17 <hoon> but I can't work out how to enforce that the "Right" side must itself be a Monoid
12:52:46 <hoon> this is just for a little program (not a library) but I am curious how it might be resolved
12:52:54 <geekosaur> the newtype thing there is just toi tell you how you can make it be on a type declared locally
12:53:25 <hoon> right, how would I do that
12:53:30 <cocreature> you are already enforcing that the Right side must be a monoid using the "Monoid b" constraint
12:53:33 <geekosaur> but there is a different issue that is resolvable via newtype, which I think you also don't care about: context is not used to resolve instances, so your instance is actually on (Either a b)
12:53:57 <geekosaur> hoon, ok, I said you don;t need to care, tghat means you don;t need to care, not ":how do I do that"
12:54:29 <geekosaur> the warning is on by default. possibly it should not be in ghci, since instances declared in ghci are not goingto infect other programs
12:54:48 <hoon> I don't need to know, but I'd like to learn
12:56:17 <geekosaur> the warning is there to makde you think whether you need to pollute the global instance namespace when creating a library containing that instance.
12:56:41 <hoon> I understand why there is a warning
12:56:58 <hoon> I don't understand how I might resolve it if I needed to
12:57:18 <nshepperd> newtype MyEither a b = My (Either a b)
12:57:32 <geekosaur> that depends on what you are trying to accomplish, meaning that nothing you are doing with a toy instance will help. you would need to be designing a new library
12:57:59 <geekosaur> but, to pretend, basically what nsheppard said, and then declare your instance on My instead of Either and unwrap the Either to work with it
12:58:30 <hoon> let me try to play for a moment
12:58:34 <unyu> hoon: So, were you asking two unrelated questions? One about dealing with orphan instances, another about enforcing the Monoid constraint on the second type argument.
12:58:45 <hoon> yes
12:58:52 <hoon> ^unyu
12:58:53 <unyu> Ah, okay. :-p
12:58:57 <geekosaur> but that is not necessarily "the" right answer; it would depend on what your library needs and what the library's users will need (or expect).
12:59:14 <geekosaur> this is a question of library design, not simply a question of "how to do this"
12:59:33 <unyu> Is there really any situation where orphan instances are the right tool for the job, and don't create problems for users later on?
12:59:58 <geekosaur> lens has a lot fo unnecessary dependencies just to avoid the orphans noise
13:00:22 <geekosaur> it's not always wrong to create new instances elsewhere. but it's problematic enough to be worth the warning
13:01:04 <nshepperd> unyu: when the original library designers didn't want to depend on each other or forgot to add the instance, you'll sometimes make a foo-bar-orphan package that depends on them both and provides it
13:01:15 <nshepperd> or when you're in ghci and just don't care :)
13:01:23 <cocreature> if you declare a typeclass and a _lot_ of instances for it in the same package then sometimes it can also be really painful to have to declare them all in the same module
13:01:39 <geekosaur> that, and it's silly to have to import half the ecosystem like lens does
13:02:08 <geekosaur> ideally the instances would be in separate packages, or at least separate modules... but now the instances are orphans
13:02:49 <geekosaur> instances have to be global for the typesystem to be sound, but this makes for rather annoying dependency issues
13:03:24 <geekosaur> s/but now/but if you do that,/
13:04:19 <unyu> Does Haddock document orphan instances?
13:04:32 <unyu> That's more of a tooling problem than a language problem, but it's still a problem.
13:05:13 <lyxia> unyu: Where should the instance Arbitrary Text be defined? In text or in QuickCheck? Users of one may not want to depend on the other.
13:07:32 <lyxia> unyu: they are documented now. For example: https://hackage.haskell.org/package/quickcheck-instances-0.3.16/docs/Test-QuickCheck-Instances.html
13:07:38 <nshepperd> i'm sure there must be some kind of cabal+ghc tooling based solution to the orphan instance problem, but i don't know what it is
13:08:30 <unyu> lyxia: Oh, nice.
13:19:32 <hoon> so, for what it's worth, I was trying to make a function like "myFunc f = foldM (\acc s -> mappend <$> pure acc <*> f s) mempty" where the Right half of an Either would `mappend`
13:21:51 <kamyar> someone plz help me about my question
13:30:48 * hackage tldr 0.2.4 - Haskell tldr client  https://hackage.haskell.org/package/tldr-0.2.4 (psibi)
13:37:46 <troido> When I try to encode a Map to json (using Aeson) on my own computer it just works, but when I try it on another computer I get an error "No instance for (ToJSON (Map String Int)) arising from a use of ‘encode’". Does anyone have any idea what could cause the issue and how to fix it? I already cabal installed 'aeson' and 'collections' to make sure I have the up-to-date packages
13:38:59 <[exa]> troido: please doublecheck the package and ghc versions
13:39:27 <[exa]> troido: (because otherwise it would be quite weird)
13:39:53 <davean> troido: That doesn't make it have up to date packages
13:39:54 <geekosaur> troido, in particular, if this is debian you could be using ghc 6.6 and packages compatible with that --- which might well be missing the instance
13:40:07 <troido> what should I check for?
13:40:14 <geekosaur> er, not 6,6
13:40:15 <davean> what versions you have installed
13:40:17 <geekosaur> 7.6.3\
13:43:24 <davean> troido: at the very least you'd need to "cabal update" first - thats the very least
13:43:39 <davean> troido: but it will install whats compatible with what the system already has
13:44:52 <troido> ghc is 7.10.3 (it's ubuntu). How do I see if a version is compatible? I did run "cabal update" before
13:45:22 <troido> also when I said I installed 'collections' I meant 'containers'
13:46:46 <[exa]> troido: some distributions provide distro packages for various stuff (esp. the commons, like containers) which may interfere with cabal, check out whether there isn't such a package
13:46:51 <davean> Well, with compatability with GHC, the base version requirement
13:46:56 <davean> but do you have the same GHC on both?
13:46:59 <[exa]> troido: (on ubuntu it would be something like dpkg -l |grep libghc)
13:47:03 <davean> do you have the same Aeson installed on both?
13:47:18 <davean> "cabal info aeson" to find out what you have installed
13:48:01 <davean> but also, you can constrain it to requiring aeson versions with the instance you require
13:48:08 <davean> also you probably don't want to install stuff globally?
13:48:52 <[exa]> speaking unix, I've noticed this: file foo.hi  --->   foo.hi: data
13:49:26 <[exa]> q: how do I send a pull request to 'file' ? :D
13:49:26 <davean> [exa]: well, of course - why do you mention?
13:49:40 <davean> well, you're using gnu file I expect
13:49:50 <[exa]> yeah
13:50:09 <davean> so thats part of coreutils I believe?
13:50:18 <davean> https://www.gnu.org/software/coreutils/coreutils.html
13:51:09 <[exa]> wow, going to try.
13:51:12 <geekosaur> but the .hi format changes periodically (some aspects with every ghc version)
13:51:49 <[exa]> even the magic number?
13:52:22 <[exa]> (.hi files on both of my machines start with 0x01face64 )
13:52:25 <troido> on my own computer I have ghc 8.2.2-1, aeson 1.2.3.0, and containers 0.5.10.2 . On the other computer I have ghc 7.10.3, aeson 1.2.3.0 and for containers both 0.5.6.2 and 0.5.10.2
13:52:54 <codeshot> The documentation for Applicative says that <*> sequences computations and combines their results, but I can't see anything in the laws that requires sequencing. Am I right to understand that the IO Applicative instance could run computations in parallel when they're combined with <*>
13:53:14 <troido> I don't have sudo permissions on the other computer so I can't install stuff globally there
13:53:27 <davean> troido: well, I never install Haskell stuff globally
13:53:30 <[exa]> troido: you can do it locally using cabal sandbox
13:53:51 <ertes> @tell sqooq no, that (myApp) is a type error, but you've got the right idea
13:53:51 <lambdabot> Consider it noted.
13:56:37 <geekosaur> [exa], judging by the error message, if it's old enough then yes
13:57:05 <amalloy> codeshot: i think that would not break Applicative laws, but would perhaps make it difficult for IO to be a Monad without breaking laws like (<*>) == ap
13:57:47 <geekosaur> for sufficiently new versions, that is probably okay. and then there's a 32 or 64 bit (dpeending on platform) gap, followed by the interface file version (which I think is 32 bit; still looking)
13:58:34 <[exa]> geekosaur: if you'd happen to come across some kind of specification or code that produces it, please share a link :]
13:58:38 <geekosaur> ...but "binary"-encoded
13:58:50 <geekosaur> ...but "binary"-encoded
13:58:51 <geekosaur> er
13:59:08 <geekosaur> I am looking at compiler/iface/BinIface.hs
13:59:39 <geekosaur> magic, 32/64 gap for old versions, compiler version and ways (in "binary" serialization format)
14:00:39 <codeshot> amalloy, Do the Monad laws require that 'ap' sequences computations instead of running them in parallel?
14:00:43 <geekosaur> I don't think there is a formal spec, because you're not supposed to depend on the .hi file format yourself but use ghc-api
14:01:36 <amalloy> codeshot: no, but ap is sorta necessarily sequential, because the second computation depends on the value from the first computation
14:01:49 <[exa]> codeshot: only sequencing is the one required by the explicit monad (e.g. passing the imaginary world state around IO)
14:01:57 <amalloy> ap mf mx = do {f <- mf; x <- mx; return (f x)}
14:02:19 <[exa]> s/explicit monad/explicitly required by the monad/
14:02:34 <[exa]> geekosaur: great, thanks
14:05:16 <troido> I removed the second newer version of 'containers' and this error seems to have gone away
14:05:32 <codeshot> [exa], thanks
14:08:14 <EvanR> :t ap
14:08:16 <lambdabot> Monad m => m (a -> b) -> m a -> m b
14:08:17 * hackage serverless-haskell 0.0.2 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.0.2 (AlexeyKotlyarov)
14:08:33 <EvanR> i disagree with the idea that ap requires "actions to be run sequentially"
14:08:54 <codeshot> Is there any reason we don't have a typeclass (maybe named 'Rollup') between Functor and Applicative that has <*> but no pure ? Ie, where instance Semigroup a => Rollup ((,) a)
14:09:19 <EvanR> depending on the monad's >>= implementation and the way you consume lazy results, it could do all kinds of things
14:09:34 <geekosaur> codeshot, it's often called Apply. see the Typeclassopedia. I think Lens has a version of it?
14:09:44 <codeshot> geekosaur, marvellous
14:09:51 <geekosaur> Apply and Pointed don;t get much use, so they're not standard
14:10:36 <geekosaur> (but I think ekmett wants to see both become standard, because lens needs hacks to retrofit them)
14:11:16 <ertes> i wish the whole semigroupoids package was in base
14:13:52 <codeshot> Apply would seem extremely useful to me since a compiler with useful diagnostics should be able to describe where each conflicting or incomplete program element came from - but pure leaves us open to accidentally interpreting an incomplete program fragment without providing source information for some relationships
14:14:30 <codeshot> Applicative -> missing diagnostic info is easy, Apply -> missing diagnostic info is impossible or obviously wrong when reading the code
14:14:56 <geekosaur> specifically, iirc lens doesn't have an affine traversal because it can only be made to work if Apply is actually part of the Functor -> Apply -> Applicative chain instead of hacked in after the fact
14:15:14 <codeshot> I agree with ekmett
14:17:38 <codeshot> I also wish that foldl1 was in a subclass of Foldable specifically for non-empty foldables, I don't like that foldl1 is permitted to be partial
14:18:16 <geekosaur> that one runs into there being no good way to "retrofit" list syntax onto things that arent basic lists without making a lot of other stuff Weird
14:18:24 <codeshot> I found an example where that introduces great risk under refactoring and thus a great hindrance when growing a development team
14:18:40 <geekosaur> (OverloadedLists, yes, but that gives the compiler way too much rope)
14:18:58 <codeshot> how come that requires foldl1?
14:19:38 <geekosaur> foldl1 wants to require a Foldable1, which would work best if NonEmpty could be treated as a normal list instead of requiring a wrapper
14:20:02 <geekosaur> (and I think "Foldable1" is taken for lifted Foldables anyway)
14:20:23 <codeshot> Well that last point is just a name, NonEmptyFoldable would be better anyway
14:20:42 <geekosaur> point being there's a lot fo parts that just don't fit together nicely in Haskell as it currently exists, and reworking them would at this point break too much code
14:20:58 <geekosaur> I think this is part of why edward was working on ermine?
14:21:14 <codeshot> The wrapper in question is the (head :|) pattern?
14:21:19 <geekosaur> yes
14:21:34 <codeshot> That's a data constructor, you have to have it don't you?
14:21:55 <geekosaur> specifically because e.g. [x] is not automatically NonEmpty, and the language can;t easiily be redesigned to allow that because it reuires distinct constructors, yeh
14:22:16 <geekosaur> you can do that kind of thing in, say, Agda
14:22:22 <codeshot> How does Haskell handle the fact that 1 can be Int, or Integer?
14:22:29 <geekosaur> :t 1
14:22:31 <lambdabot> Num p => p
14:23:01 <geekosaur> all numeric literals are rewritten by the compiler to be applications of fromInteger or fromRational as appropriate
14:23:20 <Iceland_jack> codeshot: '1' gets rewritten to 'fromInteger (1::Integer)'
14:23:25 <geekosaur> OverloadedLists extension attempts to provide the same ability for list syntax, but that turns out to be a bit too general
14:23:48 <kamyar_> http://lpaste.net/4305215891127140352
14:23:50 <Iceland_jack> if you have a 'Num' instance for a type, you can use '1 :: YourType'
14:23:50 <Iceland_jack>     instance Num Int
14:23:50 <Iceland_jack>     instance Num Integer
14:23:55 <geekosaur> ...well, aside from the "1::Integer" is actually an internal low level thing you can't do in normal Haskell code
14:23:57 <kamyar_> Please inspect my code
14:24:54 <codeshot> So [x], and [x,y] etc can be "fromNonEmpty (x :| [y])" and [] can be "vacant" or something
14:25:04 <codeshot> would that work?
14:25:19 <geekosaur> the typechecker is way too eager to look for IsList instances to deal with typos elsewhere, so what would normally be obvious errors become weird action at a distance things. you already get that to some extent with Num instances, but lists are so pervasive and so general as to make the problem much worse
14:26:31 <codeshot> How come it can't look for IsNonEmptyList at each point before looking for IsList ?
14:27:15 <ReinH> kamyar_: why?
14:27:23 <kamyar_> I have a problem
14:27:39 <kamyar_> I am trying to call a simple service on my computer 100 times
14:27:45 <kamyar_> you can replace with any pther service
14:27:47 <kamyar_> other
14:27:55 <ReinH> Ok. What is the problem?
14:28:03 <kamyar_> but the times are too variant
14:28:10 <geekosaur> and the channel exists for exactly this purpose of course, which si why they have been popping up and demanding action every coupel hours according to my backscroll
14:28:27 <ReinH> geekosaur: who?
14:28:38 <kamyar_> from fraction of second to near 3 seconds
14:28:45 <kamyar_> more than3
14:28:50 <ReinH> kamyar_: How do you know that this is a problem with your code?
14:28:51 <kamyar_> TimeSpec {sec = 3, nsec = 396361471}
14:29:03 <kamyar_> TimeSpec {sec = 0, nsec = 423715276}
14:29:12 <kamyar_> jus watch these 2
14:29:25 <ReinH> I see them. They don't answer my question.
14:29:27 <kamyar_> ReinH: Since I have tested the code with more urls
14:29:33 <monochrom> Every week for me. :)
14:30:01 <kamyar_> and the time is too divergent
14:30:03 <[exa]> kamyar_: what's running on that port 3000?
14:30:17 <kamyar_> a simple scotty service hello world
14:30:32 <kamyar_> [exa]: It does not change if you test another service
14:30:54 <ReinH> Are you aware that status200 there is a pattern variable that matches every case?
14:31:13 <ReinH> I'm not sure if that's part of the problem, but if you are expecting it to only match 200 statuses then you are mistaken.
14:31:27 <[exa]> kamyar_: and if you try it manually using e.g. curl, the response times are better/more predictable?
14:31:46 <kamyar_> [exa]: Yes I test with ab
14:32:11 <kamyar_> ReinH: it is not my problem but why?
14:32:32 <ReinH> Because it is a pattern variable. A pattern variable matches every case.
14:32:40 <kamyar_> ReinH: Oh yes u r right
14:32:46 <kamyar_> ReinH: Leave it for now
14:33:08 <[exa]> kamyar_: my first thought for bisecting the problem would be, just out of curiosity, try to rewrite the 'localhost' in url to 127.0.0.1
14:33:29 <ReinH> What happens if you run a worker without async?
14:35:28 <kamyar_> ReinH: I tried to run it several times in lines but still the results differ too much
14:36:27 <kamyar_> [exa]: 127.0.01 did not help. I also changes 3000 port to 80 (my nginx) still too divergent
14:39:52 <kamyar_> ReinH: Oh! I omitted async and now times are very convergent!
14:40:03 <ProofOfPizza> Hi folks, newbie here, working my way through learnyouahaskell. Simple question: there is this example, to display the first letter of a word,
14:40:06 <ProofOfPizza> capital :: String -> String
14:40:08 <ProofOfPizza> capital "" = "Empty string, whoops!"
14:40:11 <ProofOfPizza> capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]
14:40:15 <geekosaur> @paste
14:40:16 <lambdabot> Haskell pastebin: http://lpaste.net/
14:40:16 <kamyar_> http://lpaste.net/4305215891127140352
14:40:43 <kamyar_> ReinH: But how should I add async or forkIO?
14:41:05 <ProofOfPizza> Let's say I wanted the first and last letter. This is invalid @all(x:xs:y:[]) .. what would be a valid way to match the first and last ?
14:41:27 <geekosaur> ProofOfPizza, you can't match it directly like that
14:41:48 <yoho139> well you can if you only want it to work on three letter strings ;)
14:41:48 <geekosaur> (x:xs:y:[]) matches a list of length 3, and places the 3 items in x, xs, and y
14:42:04 <[exa]> ProofOfPizza: use `head` and `last`?
14:42:14 <geekosaur> Haskell lists are linked lists. just calling the middle thing "xs" does not cause it to match the middle of the list
14:42:24 <ReinH> > last []
14:42:56 <ProofOfPizza> yeah, head and last would help, but in terms of learning this pattern matching :)
14:43:00 <ReinH> Be careful suggesting partial functions to beginners.
14:43:25 <ReinH> ProofOfPizza: You can only pattern match on constructors. There is no constructor for "the last element in a list".
14:43:31 <kamyar_> ReinH: Any solution for me?
14:43:37 <ReinH> The only list constructors are (:) (or cons) and [].
14:44:38 <[exa]> kamyar_: mind using strace on the resulting executable to see what it really does in the meantime?
14:45:05 <kamyar_> [exa]: I am on Mac so I may be better to use Dtrace
14:45:16 <kamyar_> but I guess the problem must be easier
14:45:20 <[exa]> kamyar_: but since removing async helped I guess there's going to be some weirdness there in connection with sockets
14:45:43 <ReinH> In the case with all, you know that all is not an empty list (because it is a list that pattern matches on the constructor (:)).
14:45:49 <ReinH> So in this case, you know that last all is safe
14:46:09 <ReinH> so you can say "The last letter of " ++ all ++ " is " ++ [last all]
14:48:20 <infinisil> Hey there, I remember there being some markup language in haskell itself, as in you'd write haskell expressions with functions for headers, lists, etc.
14:48:27 <infinisil> Anybody remember what it's called?
14:48:59 <ProofOfPizza> ahh yeah right. Ok, well it was just an example, because if (who knows why?) I wanted the first and 4th letter then I'd have to find another way. But what I understand is that matching multiple elements in one time like this is not possible, right?
14:49:00 <Tuplanolla> @hackage lucid
14:49:07 <lambdabot> http://hackage.haskell.org/package/lucid
14:49:18 <Tuplanolla> Is it this one, infinisil?
14:49:26 <kamyar_> Can anyone remind me the concurrent loop functions? for example combination of replcate and forkio
14:49:36 <kamyar_> I remember there was a package
14:49:57 <Tuplanolla> @hackage async
14:49:57 <lambdabot> http://hackage.haskell.org/package/async
14:50:00 <Tuplanolla> Is it this one, kamyar_?
14:50:03 <infinisil> Tuplanolla: Hmm.. I'm not sure haha
14:50:10 <infinisil> I don't remember it using HTML
14:50:25 <kamyar_> Tuplanolla: NO!
14:51:54 <codeshot> geekosaur, The typeclassopedia is missing a counterpart to Alternative derived from Apply - for types with empty but no pure - ie, containers with selection but without building
14:52:26 <codeshot> How should I go about adding one - I assume I need to write a motivating example, upload a library to hackage and anything else?
14:53:16 * hackage n-ary-functor 0.1.0.0 - An n-ary version of Functor  https://hackage.haskell.org/package/n-ary-functor-0.1.0.0 (gelisam)
14:53:17 * hackage serverless-haskell 0.0.4, serverless-haskell 0.0.3 (AlexeyKotlyarov): https://qbin.io/xaq3ef9h
14:54:13 <geekosaur> "Please help update and extend it by editing it yourself or by leaving comments, suggestions, and questions on the talk page."
14:54:29 <geekosaur> aka https://wiki.haskell.org/Talk:Typeclassopedia
14:54:29 <codeshot> oh, okay :D
14:54:47 <geekosaur> or see if byorgey is around :)
14:56:07 <geekosaur> edwardk's another good person to talk to about it
14:56:24 * edwardk wakes from his slumber.
14:56:35 * Rembane hands edwardk a cup of coffee
14:56:46 <ReinH> Oh no, you have summoned the edwardk
14:56:46 <geekosaur> sometimes the problem with additions is they turn out to have unexpected effects (or need careful design ... sometimes just to be inhabitable)
14:57:09 * edwardk sips from the proffered mug, spits it out, then goes and grabs a diet coke from the fridge.
14:57:17 <Rembane> I hope for road runner speed.
14:57:19 <ReinH> Once summoned, all is lost, for there is no way to prevent him from speaking of... category theory
14:57:26 <Rembane> Dun-dun-duuuuuuuun!
14:57:38 <geekosaur> sorry, I'm mostly a coffee type :) sometimes tea though
14:58:45 <edwardk> I've been making a steady effort to switch to tea, but its slow going.
14:59:51 <edwardk> codeshot: there is 'Alt' in semigroupoids, but its missing the relationship to Apply, because I was lazy. https://hackage.haskell.org/package/semigroupoids-5.2.1/docs/Data-Functor-Alt.html
15:00:12 <edwardk> and because that is another notion that was missing
15:00:31 <edwardk> haskell kinda sucks at dealing with deep fine-grained class hierarchies
15:00:57 <edwardk> thats a good chunk of the reason why i'm working on coda and the like.
15:01:55 <edwardk> if every time we go to refine the class hierarchy its going to take 4 years to get the patches merged and the community updated, it behooves me to spend equal time trying to build a language in which that isn't a going concern.
15:02:00 <codeshot> I see Apply defines <.> as equivalent to <*>, it would be nice to keep <.> free for composition :/
15:02:12 <edwardk> codeshot: only so many symbols on the keyboard
15:02:20 <codeshot> why not define <*> to be imported qualified if that's what you want
15:02:22 <kamyar_> what library provides mix of forkIO and mapM/forM? I forgoten
15:02:32 <edwardk> because i don't like qualified operator imports
15:02:35 <edwardk> your mileage may vary
15:02:38 <codeshot> oh I see
15:02:49 <ReinH> I do like <.> for liftA2 (.)
15:03:04 <edwardk> ReinH: i do too, sadly i needed the operator =)
15:03:05 <ReinH> But you can import it qualified if *you* want to.
15:03:26 <ReinH> kamyar_: I don't have an answer. I suspect laziness may be involved.
15:03:45 <edwardk> i have 3-4 variants on (<*>) (<.>) (<@>) all for the "same" operator due to haskell silliness
15:03:50 <kamyar_> ReinH: The last time I asked people here recommenedd but I forgot
15:04:03 <ReinH> heh
15:04:08 <codeshot> I see Alt doesn't have empty, is there a typeclass that derives from Alt but adds just empty ?
15:04:21 <ReinH> edwardk: type directed resolution ftw, except when it isn't.
15:04:35 <edwardk> eh, no thanks
15:04:48 <edwardk> codeshot: "Plus"
15:04:50 <edwardk> same package
15:04:53 <codeshot> ta
15:05:03 <codeshot> This package is now my secret lover
15:06:28 <codeshot> It's typeclass graph is interesting, is there an Alt that isn't also an Apply?
15:06:54 <codeshot> paralleling the Applicative -> Alternative relationship
15:08:36 <edwardk> codeshot: you can think of "Alt" as morally "Monoid1" or something
15:08:52 <edwardk> and yeah you can come up with them
15:09:20 <edwardk> er Semigroup1 i guess
15:09:21 <ReinH> I mainly like <.> because it's a nice way to specify the Applicative laws tbh
15:10:30 <codeshot> It's also visually neater, especially under refactor comparison
15:45:12 <metahumor> I have a definition of "select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]"
15:45:25 <metahumor> is there a way to rephrase that to be breadth-first instead of depth-first?
15:46:29 <metahumor> that is, if i had a "f xs = do { (a,ys) <- select xs; (b,_) <- select ys; return [a,b]}", have it generate them "diagonally" instead of using the same "a" first
15:47:35 <metahumor> in the case of "f primes", I'd want "[[2,3], [2,5], [3,5], [2,7], [3,7], [5,7],...]" while now I get "[[2,3], [2,5], [2,7], [2,11], ...]"
15:48:36 * hackage fast-arithmetic 0.1.1.1 - Fast number-theoretic functions.  https://hackage.haskell.org/package/fast-arithmetic-0.1.1.1 (vmchale)
15:55:52 <edwardk> metahumor: https://hackage.haskell.org/package/control-monad-omega-0.3.1/docs/Control-Monad-Omega.html
15:55:56 <erisco> metahumor, maybe start from the top with a description of the problem and that way we can better understand what the program should do.
15:56:48 <erisco> if that is the sort of thing you are looking for, you might also check out data-list-zigzag
15:57:36 <erisco> you could say it is like Omega but has a stronger enumeration property
16:10:33 <woodson_> Hi guys I am having trouble trying to setup nix and reflex can anyone help me? Once I install nix how would I install ghcjs with nix if im not supposed to use cabal insall?
16:10:43 <woodson_> on the github to install ghcjs you need to download a tar file
16:17:21 <holycleugh> is there a way to attach ghci to a running process and make changes to an MVar?
16:27:21 <kakashiA1> accodring to the docs: "If the increment is negative, the list terminates when the next element would be less than e3; the list is empty if e1 < e3."
16:27:23 <kakashiA1> lets look at [10, 1..10]  <--this returns an empty list
16:27:24 <kakashiA1> here increment is negative (1-10) = -9
16:27:26 <kakashiA1> BUT e1 < e3 is 10 < 10, so why do I still get an empty list?
16:30:09 <int-e> > [10, 1..10]
16:30:14 <lambdabot>  [10]
16:30:56 <monochrom> [10] is correct.
16:31:07 <int-e> and it's not the empty list.
16:31:21 <monochrom> Err, no, I have to think again.
16:31:40 <kakashiA1> int-e: okay, dont know how I come up with that
16:32:30 <monochrom> Ah, it is correct.
16:40:06 <kakashiA1> if we look at this list constructor: [10,12..7]  <---(12-10) is positive and 12 > 7, thats why (according to the standards) we get an empty list
16:40:17 <kakashiA1> I have just one question about that:
16:40:33 <kakashiA1> is there anything intuitive why we get an empty list?
16:41:44 <parsnip> step from e1, e2, stopping at e3?
16:43:42 <parsnip> is it like, you have a1, a2, a3, ..., an, where a1 = e1, a2 = e2, and an <= e3
16:46:26 <kakashiA1> parsnip: ahh you mean if the steps that you are taking from a to b do not match to c if you further more with (b-a) steps ?:)
16:47:16 <EvanR> answer: no it makes no sense, try not to ask for enumFromThenTo's where the endpoints are degenerate
16:47:25 <EvanR> kind of like division by zeros
16:47:31 <parsnip> right, all a{j} - a{j-1} = a2 - a1
16:47:52 <parsnip> and all aj <= e3
16:48:21 <EvanR> the documentation of "a list starting at x0 ending at xN in steps of x1 - x0" doesnt predict the behavior, or even behavior where the endpoints dont match up
16:49:09 <kakashiA1> parsnip: thanks :)
16:49:18 <parsnip> :)
16:49:24 <kakashiA1> parsnip: makes a lot of sense :)
16:50:40 <kakashiA1> parsnip: now if we look at [10,1..10], it returns [10], does this makes intuitivly sense for you?
16:50:56 <kakashiA1> we move with -9 steps
16:51:17 <int-e> > [10,10..10]
16:51:20 <kakashiA1> parsnip: even here we will never reach 10
16:51:21 <lambdabot>  [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,...
16:51:31 <parsnip> yep, so ignore the endpoint, consider the list 10, 1, -9, -19, ..., and truncate it so that all values are..t at least 10?
16:52:06 <parsnip> statement needs to be cleaned up for decreasing i guess.
16:53:03 <parsnip> if e1 < e2, we want aj <= e3, else aj >= e3.
16:53:26 <int-e> I guess the idea is to have the case [0,-1..-k] mirror the case [0,1..k] = [0..k].
16:54:02 <parsnip> if it's increasing, we want an upper bound, otherwise a lower bound.
16:54:25 <parsnip> anything else would make less sense.
16:54:26 <kakashiA1> parsnip: let me summarize: [10, 1..10] <---we move with -9 steps, but we start with 10 and we also want to end with 10, so it will we: 10, 1, -8, -17 and 10 is the expected end, so haskell know that this inbetween is not possible, thats why it takes the biggest value between 10 and 10 which is 10
16:54:37 <parsnip> or would be less useful.
16:54:57 <kakashiA1> parsnip: [10, 1..9]  <---also returns [10]
16:55:45 <parsnip> [10, 1..x] for any x in [2..10] returns [10]
16:55:56 <yushyin> 'If the increment is negative, the list terminates when the next element would be less than e3' - haskell2010 language report
16:56:00 <parsnip> i forgot if haskell is inclusive
16:56:31 <hpc> > [0, -1 .. -10]
16:56:35 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
16:56:42 <Welkin> yes, of course
16:56:44 <parsnip> > [2..10]
16:56:45 <Welkin> that only makes sense
16:56:46 <kakashiA1> parsnip: [10, 1..x] for any x in [2..10] returns [10] <---this this makes intuitivly sense for you?
16:56:47 <lambdabot>  [2,3,4,5,6,7,8,9,10]
16:56:56 <Welkin> languages that have ranges that exclude the last value are screwed up
16:57:27 <Welkin> it is literally written as an inclusive range using [ and ]
16:57:35 <Welkin> not ( and ), or ( and ]
16:57:40 <parsnip> kakashiA1: yes, any value between 2 and 10 will include the 10 and prevent the 1.
16:58:03 <parsnip> oh right, nice.
16:58:10 <parsnip> very mathy
16:59:00 <kakashiA1> parsnip: still dont get it :(
16:59:16 <int-e> @check \a b c -> (a /= b) ==> ([a, b .. c] == map negate [-a, -b .. -c])
16:59:20 <lambdabot>  +++ OK, passed 100 tests.
16:59:44 <parsnip> kakashiA1: for [10, 1..x], ignore the x. we can think about 10, 1, -8, -17, ..., right?
16:59:54 <kakashiA1> parsnip: yes sir
17:00:08 <parsnip> and if we want aj <= x, then if x is greater than 2, we won't make it to 1, right?
17:01:29 <parsnip> oh sorry, we want aj >= x
17:01:33 <kakashiA1> parsnip: hmmm...I mean 10 and 1 are given
17:01:52 <parsnip> yes. the 10 and 1 imply a few things.
17:02:09 <parsnip> they imply an infinite list 10, 1, -8, -17, ...
17:02:37 <kakashiA1> 10, 1, a_1, a_2, ...., a_j, ...x    <---you mean like this right?
17:02:40 <parsnip> they also imply that e3 =x shall be a lower bound, since it's decreasing.
17:02:53 <parsnip> sort of yes.
17:03:23 <parsnip> i might have said 10, 1, a3, a4, ... or 10, 1, a2, a3, ...
17:03:37 <parsnip> but that's not so important.
17:03:59 <parsnip> that is, i mean, choice of indexing is not important, yours vs mine.
17:04:04 <kakashiA1> parsnip: you are asking me if one of the a_i's is 2, we cant reach 1, I dont see that, because we already have 10 and 1 given
17:04:18 <parsnip> i didn't say an aj is x.
17:05:04 <parsnip> kakashiA1: this is an intermediate step, the infinite list can "exist" without it being in the result.
17:05:28 <parsnip> kakashiA1: this is a use of notation math people are comfortable with.
17:05:44 <parsnip> you say you have a list {a_j} but it might be empty.
17:05:55 <kakashiA1> parsnip: hmmm...dont know what you whant to emphersize with that, but its still not clear
17:06:19 <parsnip> just because i say i have a list a1, a2, a3, ... aj, doesn't mean i have at least 3 or 4 elements, ok?
17:06:21 <kakashiA1> let make it more simpler:   10, 1, a, b, c, .... x
17:07:01 <parsnip> i could say a list {a1, a2, ..., aj, ...} is just {0}
17:07:14 <parsnip> it's just convenience in notation.
17:07:20 <kakashiA1> parsnip: hmmm....okay
17:08:09 <kakashiA1> parsnip: but what every you guess or think, 10 is the first element, 1 is the second and -8 is the third and so on
17:08:23 <parsnip> if i say i have 10, 1, a, b, c, ..., x, i want to allow that my list turns out to only be 10, or even empty.
17:09:12 <parsnip> and it is reasonable to completely ignore the x for a moment, and consider the infinite implied list.
17:09:17 <parsnip> 10, 1, -8, -17, ...
17:09:25 <kakashiA1> okay
17:09:25 <parsnip> imagine it just goes on forever.
17:09:39 <parsnip> and you simply want to take those aj that are at least x.
17:09:48 <parsnip> if x = 11, you take none.
17:10:04 <parsnip> even though i _wrote_ 10 in the intermediate thought.
17:10:11 <kakashiA1> because I cant reach x = 11, ever!
17:10:33 <parsnip> well, "reach", i don't know how you want to think about that step.
17:10:39 <parsnip> but that's fine.
17:11:22 <kakashiA1> thats why I give you an empty list, because I am telling you "you want me to start with 10 and go -9 steps further but you want me to reach 11, this is not possible, I protest so here you have an empty list"
17:11:38 <parsnip> it's _convenient_ to write that thinking as 10, 1, -8, -17, ..., x.
17:11:52 * hackage network-arbitrary 0.2.0.0 - Arbitrary Instances for Network Types  https://hackage.haskell.org/package/network-arbitrary-0.2.0.0 (alunduil)
17:12:15 <parsnip> oops, i shouldn't put the x there.
17:12:27 <kakashiA1> 10, 1, -8, -17, ...  <---okay I have this in my mind
17:12:29 <kakashiA1> what next?
17:12:36 <parsnip> let's say 10, 1, -8, -17, ..., an, where an >= x.
17:12:58 <parsnip> kakashiA1: next? take all aj >= x.
17:13:04 <parsnip> or all aj >= e3.
17:13:32 <parsnip> since it's monotone, you'll stop at the first failure.
17:14:06 <kakashiA1> parsnip: one of the failure could be 2
17:14:07 <codeshot> Are the Foldable, Applicative and Alternative laws such that @for_ (a <|> b) f = f a *> f b $> ()@ ?
17:15:02 <parsnip> kakashiA1: if e3 = 2, then aj = 1 is the first failure.
17:15:43 <kakashiA1> parsnip: so why do you neglect and see the 1 as a failure?
17:15:55 <kakashiA1> parsnip: 1 is a part of the definition
17:16:12 <kakashiA1> parsnip: you pretend that 1 is not part of the definition what I dont understand
17:16:23 <codeshot> Whoops: @for_ (a <|> b) f = for_  a f *> for_ b f $> ()@ ?
17:16:28 <parsnip> because aj = 1 < 2 = e3, breaking aj >= e3
17:17:05 <codeshot> More succinctly: @for_ (a <|> b) f = for_ a f *> for_ b f@ ?
17:18:48 <codeshot> d'urrr
17:19:00 <codeshot> of course not, 'cos of maybe
17:19:08 <kakashiA1> parsnip: you mean because [10, 1...x] is monotone, thats why aj >= x, if you now take 2 as x or one of the aj's it would be 1 >= 2 which breaks the monoton defintion (monotone decreasing in this case)
17:19:59 <parsnip> kakashiA1: no, monotone comes in in another type of reasoning. i don't think it's even necessary here.
17:20:10 <parsnip> you can ignore the monotone part.
17:20:19 <codeshot> I mean to ask about the ordering but I don't know how to state the rule algebraically
17:20:36 <kakashiA1> parsnip: so is it becaus you breal the aj >= x rule?
17:20:44 <parsnip> yes, that's when you stop.
17:20:55 <kakashiA1> breal = break
17:21:12 <parsnip> intuitively, e3 is the lower bound. you don't take anything less than e3.
17:21:42 <kakashiA1> parsnip: is that a "yes" to my question?
17:23:01 <kakashiA1> parsnip: we have 10, 1, -8, -17, ...     <---and you want me to stop at 2, which I cant do, because I run to the left side not to the ride side, each step I am going further and further away from 2
17:23:20 <kakashiA1> parsnip: so 2 makes no sense, agree with that ^?
17:23:27 <parsnip> kakashiA1: huh? no
17:24:09 <parsnip> kakashiA1: you seem to be fixated on that we have already written four elements, so we have to keep them. those are just elements to give an idea of what potential elements look like.
17:24:25 <parsnip> we may have written four elements, but we still have to check each one.
17:25:08 <kakashiA1> parsnip: I dont know what you mean, but we can write 1, 5 or 42 elements, I dont care because I know how to get my elements
17:25:12 <parsnip> i tried to describe this earlier, that a set indicated as {a1, a2, ..., aj, ...} could still be empty.
17:25:58 <kakashiA1> parsnip: okay, I agree, it could have 0, 1 or many elements, depending on the x
17:26:01 <parsnip> kakashiA1: can i go through a question with you?
17:26:20 <kakashiA1> sure
17:26:26 <parsnip> say i have a list {1, 3, 5, 7, ...}, infinite.
17:26:51 <parsnip> give me a shortened list with the elements no greater than 4.
17:28:00 <kakashiA1> parsnip: with "shortened list" you mean a list with the dot notation?
17:28:17 <parsnip> no, just a list not necessarily the same.
17:28:28 <parsnip> in whatever notation you want.
17:28:37 <parsnip> a subset, if you will.
17:28:43 <parsnip> or subsequence.
17:29:11 <kakashiA1> no greater than 4 {..., -2, -1, 0, 1, 2, 3 }
17:29:40 <parsnip> that is not a subset of the list i gave.
17:30:04 <kakashiA1> parsnip: I thought any list with the condition
17:30:12 <kakashiA1> but in that case it would be a set with 1 and 3
17:30:16 <parsnip> yep
17:30:25 <parsnip> okay, now no greater than 0.
17:30:58 <kakashiA1> parsnip: I cant, because your set does not have negative numbers
17:31:13 <parsnip> so you would say something like the empty list.
17:32:13 <kakashiA1> yes, because the empty list expresses: there is no element that fullfils that condition
17:32:14 <parsnip> kakashiA1: okay, now consider the list {10, 1, -8, -17, ...}, an infinite list, ok?
17:32:24 <kakashiA1> parsnip: yes sir
17:32:35 <parsnip> give me all the elements no less than 2.
17:36:37 <kakashiA1> parsnip: 10
17:36:41 <parsnip> give me all the elements no less than 11.
17:38:09 <kakashiA1> I cant, because your set does not contain an element that fulfills 11 >= x
17:38:20 <parsnip> {} works too
17:38:31 <kakashiA1> so I give you an empty set
17:38:36 <kakashiA1> parsnip: correct :)
17:38:36 <parsnip> perfect.
17:38:55 <parsnip> i feel like this might clarify some of your earlier questions about x.
17:40:52 <kakashiA1> [10, 1..2] <---give me something in that list [10, 1, -8, ...]  <---with the limit 2, give me everything between 10 and 2, give me every x where x >= 2
17:41:09 <kakashiA1> answer: [10]
17:41:10 <parsnip> yep
17:41:12 <parsnip> nice
17:41:19 <kakashiA1> parsnip: thanks brother!!!
17:41:25 <parsnip> You're welcome!
17:41:52 * hackage fast-arithmetic 0.1.1.2 - Fast number-theoretic functions.  https://hackage.haskell.org/package/fast-arithmetic-0.1.1.2 (vmchale)
17:43:57 <kakashiA1> parsnip: [1,1..10]  <---give me in that list [1, 1, 1......] that grows like that (unlimited ones) all elements, that are smaller than 10 or equal 10
17:44:07 <kakashiA1> => [1, 1, ...
17:44:26 <parsnip> yeah, i think any [x, x..y] will be infinite.
17:44:49 <kakashiA1> if x < y :)
17:44:54 <kakashiA1> no
17:44:57 <kakashiA1> forget that
17:45:35 <kakashiA1> wait, x <= y
17:46:06 <kakashiA1> because [5, 5..4]  would be empty :)
17:46:26 <parsnip> > [5, 5..4]
17:46:31 <lambdabot>  []
17:46:37 <parsnip> > [5, 5..5]
17:46:40 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
17:46:43 <parsnip> > [5, 5..6]
17:46:46 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
17:46:52 <parsnip> interesting.
17:46:58 <kakashiA1> parsnip: as I expected, not proud of me?
17:47:00 <kakashiA1> :P
17:47:02 <EvanR> it doesnt make sense
17:47:14 <kakashiA1> EvanR: it makes a lot of sense :)
17:47:29 <parsnip> yeah, it's not a symmteric definition, they made what looks like an arbitrary decision.
17:47:57 <kakashiA1> parsnip: you understand my explaination? (it describes all your results)
17:48:04 <Average-user> > [5,6,6]
17:48:08 <lambdabot>  [5,6,6]
17:48:21 <Average-user> > [5, 6 .. 6]
17:48:25 <lambdabot>  [5,6]
17:48:42 <EvanR> > ['a','c' .. 'd']
17:48:46 <lambdabot>  "ac"
17:49:32 <kakashiA1> its [a, b..c]    a and b describe how the list looks like, c describes where I want to "cut" that list :)
17:49:38 <kakashiA1> parsnip: thanks!
17:50:24 <EvanR> also, the exact behavior is up to the instance
17:51:03 <parsnip> kakashiA1: earlier, i said if e1 < e2, we want aj <= e3, and if e1 > e2, we want aj >= e3. this seems like the reasonable thing to do if you think about it. but how do we decide for e1 = e2?
17:51:22 <parsnip> it is arbitrary.
17:51:40 <kakashiA1> parsnip: give me an example
17:51:42 <EvanR> having different behavior if xN is less than, equal to, or greater than doesnt count as "intuitive" in my opinion
17:52:40 <parsnip> kakashiA1: for [x, x..y], which of y is x-1, x, or x+1, should the list be empty or infinite?
17:54:20 <EvanR> for Bool, Char etc its based on this
17:57:19 <parsnip> ah, it's specified in the report.
17:57:34 <EvanR> its based on the Enum instance for Int, which is apprently really complicated
17:57:56 <parsnip> if e1 >= e2, take aj <= e3, else aj >= e3
17:58:25 <parsnip> > [0, 0.. -1]
17:58:28 <lambdabot>  []
17:58:43 <kakashiA1> parsnip:
17:58:46 <kakashiA1> [x, x..(x-1)] RETURNS []
17:58:48 <kakashiA1> WHY? because if you look at [2, 2..1] we have [2, 2, 2, .... and you telling me to cut from the limit 1, which means all elements from that "set" that are <= 1
17:58:49 <EvanR> for Integer, it splits into two algorithms depending on xN >= x0 or not
17:58:49 <kakashiA1> [x, x..x] RETURNS [x, x, ....
17:58:51 <kakashiA1> WHY? because you look at [2, 2, 2... you are telling me cut at 2, so I have to take all values that are <= 2, which are unlimted 2, a list of unlimted 3
17:58:54 <kakashiA1> [x, x..(x+1)] RETURNS [x, x, ....
17:58:56 <kakashiA1> same principle like above, here we take a list of unlmited 2, because x <= (x+1)
17:59:09 <EvanR> it steps up or down but does the check first each time, explaining empty
17:59:49 <EvanR> so you can think of it as an imperative stepping algorithm, which direction it goes depends on whether the limit is greater or less than the starting number
17:59:59 <kakashiA1> parsnip: makes sense?:)
17:59:59 <EvanR> but this is only for Integer
18:00:09 <kakashiA1> parsnip: its so clear now because of you :)
18:00:51 <parsnip> kakashiA1: yes, what i was wondering about was the ambiguous part. they simply made a decision, and it does all the way to the 2010 haskell report.
18:01:01 <parsnip> *goes
18:01:29 <EvanR> *depends on if the limit is >= the starting number
18:01:35 <kakashiA1> parsnip: thanks so much seeing the intuition in that
18:01:36 <EvanR> so two cases not three
18:01:57 <EvanR> now good luck figuring out Int
18:02:04 <parsnip> that is, if e1 = e2, why pick e3 as upper bound instead of lower bound. it's ambiguous.
18:02:06 <EvanR> and thus most standard Enums
18:02:25 <parsnip> in a sense it is one of the simpler things they could do.
18:03:03 <parsnip> but picking e3 as lower or upper bound just based on if it's bigger or smaller than e1 might have been said to be more elegant in some sense.
18:03:07 <EvanR> > [maxBound - 6, maxBound - 4 .. 3]
18:03:12 <lambdabot>  error:
18:03:12 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M537840793996...
18:03:12 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
18:03:15 <EvanR> > [maxBound - 6, maxBound - 4 .. 3] :: [Int]
18:03:18 <lambdabot>  []
18:03:46 <kakashiA1> makes sense :)
18:03:58 <EvanR> > [maxBound - 6, maxBound - 4 .. maxBound] :: [Int]
18:04:02 <lambdabot>  [9223372036854775801,9223372036854775803,9223372036854775805,922337203685477...
18:04:18 <EvanR> > [maxBound - 3, maxBound - 1 .. maxBound] :: [Int]
18:04:22 <lambdabot>  [9223372036854775804,9223372036854775806]
18:04:27 <parsnip> heh
18:04:28 <EvanR> tricky tricky
18:04:58 <EvanR> ^ not just a stepping algorithm
18:05:51 <kakashiA1> parsnip: thanks again, will try to catch some hours of sleep
18:06:01 <parsnip> no problem :)
18:06:43 <EvanR> > [3, 1 .. -3]
18:06:46 <lambdabot>  [3,1,-1,-3]
18:06:51 <EvanR> > [3, 1 .. -3] :: [Word]
18:06:56 <lambdabot>  []
18:07:58 <metahumor> edwardk, erisco, thanks for the links! i haven't gotten them to work for my problem yet though, i'll keep trying.
18:13:29 <erisco> metahumor, if it is like it sounds then -XMonadComprehensions and change from [A] to Omega A or ZigZag A
18:14:33 <n_blownapart> hi I've defined some types including Subst for a book example. I don't see how type definitions work with :kind. I thought that if I did :kind [('A', False), ('B', True)] would return Assoc here (see comment at bottom of paste). http://lpaste.net/361423
18:15:14 <n_blownapart> *it would return..
18:16:38 <n_blownapart> sorry, it would return Subst* I meant
18:17:35 <n_blownapart> confused
18:18:17 <EvanR> :kind takes a type
18:18:31 <EvanR> :k [(Char,Bool)]
18:18:34 <lambdabot> *
18:22:21 <n_blownapart> EvanR, ok, yeah I need to quit. I see that thanks. Assoc [(Char, Bool)] :: * -> *    thanks
18:23:16 <n_blownapart> correction    :k Assoc [(Char, Bool)] :: * -> *
18:23:34 <EvanR> you were right the first time
18:23:59 <n_blownapart> thanks I was just showing my input
18:24:21 <n_blownapart> but yeah that is a bad post
18:25:51 <n_blownapart> I was looking at Hutton's "universality of fold" but I can't read all the notation sadly
18:29:41 <n_blownapart> so in that paste, Const Bool et al are not kinds that can be looked up ie ' :k Const Bool '
18:29:44 <n_blownapart> http://lpaste.net/361423
18:30:02 <EvanR> Const Bool isnt a type
18:30:08 <EvanR> its a Prop
18:30:20 <EvanR> (ignoring DataKinds extension)
18:30:35 <n_blownapart> yeah so :k Prop Const Bool is also wrong I guess... ?
18:30:54 <EvanR> Const Bool isnt even a prop, its weird shorthand syntax for one of the Prop ctors
18:31:05 <EvanR> Const :: Bool -> Prop
18:31:10 <EvanR> Const True would be a Prop
18:31:37 <EvanR> so :k Const Bool and :k Const True are both wrong
18:31:46 <aeolyus> Hello@
18:31:47 <EvanR> one makes less sense than the other
18:32:14 <erisco> a lattice of nonsense
18:32:33 <codeshot> Does GHC have a way to query the default instances that will be chosen for an expression? Like :t ?
18:32:34 <n_blownapart> a bit confused here. what a clusterf*&K
18:32:53 <EvanR> just stay in sane territory by only passing types to :k
18:32:59 <EvanR> and values to :t
18:33:08 <n_blownapart> thanks will do EvanR
18:34:02 <timhae> Hey, quick newbie question: what exactly is the difference between guards and patern matching? What can I do with the one I can not do with the other? To me they seem identical in their capabilities..
18:34:17 <EvanR> guards check boolean conditions
18:34:31 <EvanR> patterns check constructor structures
18:34:35 <erisco> timhae, pattern matching is something you can do in a guard … you can't put guards in pattern matches … I dunno otherwise
18:34:53 <EvanR> you cant pattern match in a guard
18:35:05 <erisco> why not
18:35:06 <EvanR> they go after a pattern
18:35:17 <EvanR> pattern | condition
18:35:27 <erisco> maybe you haven't see them then
18:35:51 <EvanR> wat, its two different languages
18:35:53 <timhae> EvanR, can you give a concrete example? Is there anything in a structure I could not check with boolean conditions?
18:35:56 <erisco> > let f x | Just x <- x = x in f (Just "see?")
18:36:00 <lambdabot>  "see?"
18:36:02 <geekosaur> view patterns
18:36:19 <EvanR> view patterns extension
18:36:20 <geekosaur> heh, ok, I'm a bit late there
18:36:25 <geekosaur> it's not an extension any more
18:36:28 <geekosaur> Haskell2010
18:36:29 <EvanR> oh what
18:37:17 <erisco> timhae,  \x -> case m of Just x -> x + 1; Nothing -> 0   rewrite that with booleans
18:37:22 <EvanR> timhae: if you mean like, if myList == [] then ... else ... instead of f [] = ..., see that == requires Eq support, which not everything has
18:37:31 <EvanR> all data types have constructors though, which can be pattern matched
18:38:08 <EvanR> if x == Nothing, for example wont work if the wrapped data type has no Eq instance
18:38:13 <geekosaur> sorry, pattern guards. vieew patterns are something else
18:38:25 <EvanR> oh pattern guards...
18:38:26 <timhae> erisco, sorry I do not know what several things mean in your example.. :D maybe this question will vanish after some more in depth studies
18:38:31 <geekosaur> view patterns are still an extension (exp -> patter) i a pattern)
18:38:54 <erisco> timhae, okay then just keep reading and eventually you'll learn why we pattern match things
18:39:08 <EvanR> timhae: in haskell most of the decision processes are done with pattern matching, it takes less space and less work than if statements in most cases
18:39:26 <EvanR> one works for all data types and one only works with bool test
18:39:37 <geekosaur> pattern matching lets you take something apart and pull components out of it by their shape
18:39:37 <timhae> but can you tell me what the difference between those two programs is:
18:39:39 <timhae> sumt1 :: Int -> Int
18:39:39 <timhae> sumt1 0 = 0
18:39:39 <timhae> sumt1 n = n + sumt1 (n-1)
18:39:39 <timhae> sumt2 :: Int -> Int
18:39:39 <timhae> sumt2 n
18:39:40 <timhae>     | n == 0    = 0
18:39:41 <EvanR> skipping bools is more efficient in terms of runtime and development
18:39:42 <timhae>     | n /= 0    = n + sumt2 (n-1)
18:39:46 <geekosaur> @paste
18:39:46 <lambdabot> Haskell pastebin: http://lpaste.net/
18:39:57 <geekosaur> don't paste long stuff into the channel, it just gets confusing
18:40:08 <timhae> yeah, sorry
18:40:11 <timhae> thanks for the link
18:40:17 <EvanR> timhae: that actually relies on equality tests in both cases, so you need another example
18:40:21 <geekosaur> anyway, the first oen is using patterns, but numeric literals are special and it gets rewritten into the second one
18:40:24 <EvanR> numeric patterns are a special case
18:40:44 <timhae> so in this special case it does not make a difference?
18:41:00 <EvanR> theres a difference in the size of source code
18:41:06 <EvanR> and readability
18:41:11 <geekosaur> (numeric literals are rewritten into applications of fromInteger ot fromRational as appropriate, since that can't be done in a pattern, "patterns" involving numeric literals are rewritten into guards.)
18:41:53 <timhae> ok, thanks
18:42:02 <geekosaur> a better example might be:   foo 'c' = a; foo x = chr (ord x + 1)
18:42:21 <geekosaur> since that can be done as an actual pattern match. it's a little faster than the guard version
18:42:42 <mniip> there is a subtle difference in when the == is not coherent with /=
18:42:42 <geekosaur> but where patterns are really useful is drilling into a structure by its shape, rather than having to write code to do so
18:42:50 <mniip> but otherwise they must be identical
18:43:34 <geekosaur> foo [Just ([_,'x'])] = ...; foo _ = ...
18:43:37 <metahumor> patterns also force the thunk representing the value passed
18:43:53 <mniip> metahumor, depends on the pattern!
18:43:58 <EvanR> theres a new abstraction barrier when you match on 'c' rather than comparing the value of something with 'c' and checking the resulting Bool
18:43:58 <geekosaur> only if there is a constructor. bindings and _ don't force
18:44:04 <timhae> thank you very much, this has been very helpful
18:44:04 <metahumor> oh? mniip can you say more?
18:44:11 <erisco> those two programs… there is very little difference
18:44:12 <mniip> f _ = ()
18:44:15 <mniip> _ is a pattern
18:44:18 <mniip> f x = ()
18:44:18 <geekosaur> foo x = ... -- the x is not forced, just bound
18:44:19 <mniip> ditto
18:44:37 <metahumor> i mean if you include the case constructor
18:44:40 <metahumor> *type
18:44:44 <geekosaur> foo (x : xs) = ... -- x and xs are not forced, but the list is forced far enough to verify the (:) constructor
18:45:11 <erisco> the only difference is one computes n /= 0 whereas the other doesn't (and it is already implicitly known)
18:45:25 <EvanR> weve just seen many differences
18:46:01 <mniip> gut feeling tells me the /= is optimized away in core but I can't be too sure
18:46:01 <erisco> not with integer literals
18:46:33 <EvanR> the broader question was about pattern matching vs guards
18:46:44 <erisco> eh, maybe because it is specialised to Int, maybe that optimisations is in there
18:47:01 <mniip> well yes
18:47:06 <mniip> otherwise Eq isn't special
18:47:34 <mniip> even RULES on constrainted identifiers have lots of caveats
18:48:14 <erisco> I'm just not sure if not (x == y) implies x /= y is something GHC wants to assume
18:48:31 <EvanR> GHC doesn't want to
18:48:44 --- mode: ChanServ set +o glguy
18:48:45 --- mode: glguy set -bbbb *!*322f5788@*.50.47.87.136 *!*327550b7@*.50.117.80.183 *!*327550c5@*.50.117.80.197 *!*451f67b8@*.69.31.103.184
18:48:45 --- mode: glguy set -bbbb *!*50f68b4c@gateway/web/cgi-irc/kiwiirc.com/ip.80.246.139.76 *!*6dfc4822@*.109.252.72.34 *!*7dd4d13d@*.125.212.209.61 *!*@*.com/ip.80.246.136.229
18:48:45 --- mode: glguy set -bbbb *!*@*/ip.152.26.178.32 *!*@*/ip.185.89.248.21 *!*@*/ip.95.168.45.50 *!*@*69.142.86.58
18:48:45 --- mode: glguy set -bbbb *!*@*jupaname* *!*@104.254.215.* *!*@108.175.0.0/20 *!*@109.255.44.234
18:48:46 --- mode: glguy set -bbbb *!*@124-197-56-160.callplus.net.nz *!*@172.98.85.252 *!*@185.25.84.* *!*@185.86.151.98
18:48:47 --- mode: glguy set -bbbb *!*@186.90.125.87 *!*@197.123.76.3 *!*@197.123.76.3 *!*@2-229-33-39.ip194.fastwebnet.it
18:48:48 --- mode: glguy set -bbbb *!*@202.131.75.94 *!*@204.14.79.61 *!*@205.164.4.70 *!*@206.176.124.180
18:48:49 --- mode: glguy set -bbbb *!*@24.69.197.34 *!*@2405:204:* *!*@2602:306:cf06:80b0:b055:b84e:94aa:2057 *!*@2602:ffca:b:15d:*
18:48:50 --- mode: glguy set -bbbb *!*@31.205.67.235 *!*@37.221.169.147 *!*@37.98.192.145 *!*@5.172.255.189
18:48:51 --- mode: glguy set -bbbb *!*@5.254.97.107 *!*@50-73-172-4-pennsylvania.hfc.comcastbusiness.net *!*@51.174.19.26 *!*@62.109.30.187
18:48:52 <geekosaur> in this case, I am pretty sure it's the expanson that does '| otherwise =' rather than inverting the (==)
18:48:52 <EvanR> its also wrong
18:49:01 <EvanR> mode flood
18:49:12 <geekosaur> annual cleaning :p
18:49:24 <glguy> I'll do it in chunks
18:49:28 <EvanR> erisco: consider laziness
18:49:48 <EvanR> (1/0) == (2/0) vs (1/0) /= (2/0)
18:50:03 <geekosaur> since the expansion could be partial if (==) doesn't match (/), you want it to use a default guard rather than (/=)
18:50:05 <EvanR> bottom doesnt imply not bottom
18:50:16 <geekosaur> oesn't match (/=)
18:50:23 * geekosaur eyes finfers
18:50:46 <EvanR> finfers
18:51:03 <metahumor> "have you ever seen fingers fing?"
18:51:04 <erisco> put some covfefe on them
18:53:30 --- mode: glguy set -bbbb *!*@65.113.255.173.bc.googleusercontent.com *!*@65.78.181.199 *!*@71.119.182.33 *!*@77.243.183.72
18:53:30 --- mode: glguy set -bbbb *!*@78-67-125-136-no247.tbcn.telia.com *!*@80.30.148.106 *!*@80.77.174.114 *!*@84.78.20.134
18:53:31 --- mode: glguy set -bbbb *!*@85.253.192.50.cable.starman.ee *!*@86.96.226.14 *!*@89-172-145-238.adsl.net.t-com.hr *!*@90.174.2.198
18:53:31 --- mode: glguy set -bbbb *!*@92.36.220.171 *!*@93.115.95.* *!*@95.66.* *!*@99.Red-79-153-211.dynamicIP.rima-tde.net
18:53:31 --- mode: glguy set -bbbb *!*@adsl-74-248-45-94.pfn.bellsouth.net *!*@adsl196-149-133-217-196.adsl196-13.iam.net.ma *!*@c-24-10-24-153.hsd1.ca.comcast.net *!*@c-68-47-216-166.hsd1.tn.comcast.net
18:53:32 --- mode: glguy set -bbbb *!*@cpe-24-90-159-176.nyc.res.rr.com *!*@cpe-74-134-218-138.kya.res.rr.com *!*@cpe-96-28-68-79.kya.res.rr.com *!*@gateway/web/cgi-irc/kiwiirc.com/ip.151.200.170.248
18:53:33 --- mode: glguy set -bbbb *!*@gateway/web/cgi-irc/kiwiirc.com/ip.185.32.179.90 *!*@gateway/web/cgi-irc/kiwiirc.com/ip.54.149.255.223 *!*@gateway/web/cgi-irc/kiwiirc.com/x-uqpfmnykjgeuonti *!*@gateway/web/freenode/ip.104.181.136.244
18:53:34 --- mode: glguy set -bbbb *!*@gateway/web/freenode/ip.172.58.72.172 *!*@gateway/web/freenode/ip.198.144.116.182 *!*@gateway/web/freenode/ip.2.216.39.151 *!*@gateway/web/freenode/ip.203.14.52.140
18:53:35 --- mode: glguy set -bbbb *!*@gateway/web/freenode/ip.46.55.167.132 *!*@gateway/web/freenode/ip.75.171.102.229 *!*@gateway/web/freenode/ip.93.137.58.12 *!*@gateway/web/irccloud.com/x-ciosbukvtbhjexta
18:53:36 --- mode: glguy set -bbbb *!*@gateway/web/irccloud.com/x-lccopqrlwvmikmyj *!*@generic-nat1.unisi.it *!*@h2537215.stratoserver.net *!*@h42-57.pool95-168.dyn.tolna.net
18:53:57 <erisco> that's a lot of ill-doers
18:54:25 <EvanR> is this going to be like ghost busters and every one of those IP addresses will become active in a minute
18:54:58 <mniip> EvanR, information can only travel at the speed of light
18:55:06 <erisco> think happy thoughts!
18:55:20 <geekosaur> none of those are likely to be, say, the recent spammers
18:55:48 <EvanR> i imagine them going to the homes of suburban bored teens who have been waiting in imprisonment all year
18:57:08 --- mode: glguy set -bbbb *!*@ip-18-228-239-173.router.siliconvalleywifi.com *!*@ip-18-41-54-196.montreal.ca.northamericancoax.com *!*@ip1f11f87f.dynamic.kabel-deutschland.de *!*@ip68-228-139-82.hr.hr.cox.net
18:57:08 --- mode: glguy set -bbbb *!*@knows.you.stole-my.pw *!*@ppp109-252-72-30.pppoe.spdop.ru *!*@scheisseparty.fecalsmear.powerbrownie.com.br *!*@static.134.225.9.5.clients.your-server.de
18:57:08 --- mode: glguy set -bbbb *!*@static.61.198.47.78.clients.your-server.de *!*@webbox222.server-home.org *!*Adium@*.dcc.fc.up.pt *!*Damn@197.14.9.*
18:57:08 --- mode: glguy set -bbbb *!*LLckfan@* *!*MakTa@187.153.35.* *!*RaceMatte@*.dl2music.com *!*Simplyy@*.as13285.net
18:57:09 --- mode: glguy set -bbbb *!*Tam5@*.oc.oc.cox.net *!*Welles@162.216.0.* *!*WhatsChat@*.lightspeed.cicril.sbcglobal.net *!*Zektor6@187.153.20.*
18:57:10 --- mode: glguy set -bbbb *!*Zogatribe@*.skybroadband.com *!*a1b2c3d4e@104.254.215.22 *!*a@94.242.205.* *!*acf93d47@*.172.249.61.71
18:57:11 --- mode: glguy set -bbbb *!*alex@162.221.200.* *!*asadkhan_@119.152.11.* *!*asdfgasdf@183.221.13.* *!*b1693309@*.177.105.51.9
18:57:12 --- mode: glguy set -bbbb *!*boov@*.neoplus.adsl.tpnet.pl *!*brasilnig@190.247.43.* *!*bzed@5.102.200.* *!*c242af59@*.194.66.175.89
18:57:13 --- mode: glguy set -bbbb *!*cc0e4f3a@*.204.14.79.58 *!*dsfasf@201.59.55.* *!*dsfsdfsdf@180.241.255.* *!*dudlitee@*.jetstream.xtra.co.nz
18:57:14 --- mode: glguy set -bbbb *!*fdsvervsd@*.hsd1.nj.comcast.net *!*fistinggr@200.79.253.* *!*fntr@109.73.64.* *!*fqhtb@86.96.226.*
18:57:49 <mellowmaroon> ???
18:57:59 <glguy> mellowmaroon: Oh no, you broke it
18:58:08 <mellowmaroon> :(! Sorry!
18:58:25 <glguy> This mode flood is on topic because I'm using a Haskell program to do it
18:58:43 <EvanR> how are you piping it into irc
18:59:26 <glguy> My client knows how many bans you can clear at a time and how fast to send the commands, so I just type in a single /unban command and it works it out
18:59:46 <EvanR> fancy
19:00:33 <erisco> don't program yourself out of a job glguy
19:01:03 <mellowmaroon> Are monads really comparable to burritos?  I find them kinda lasagna like personally
19:01:07 <sqooq> erisco, was I right
19:01:11 <sqooq> I never got reflex to work
19:01:24 <glguy> ... you win?
19:01:49 <erisco> thanks for the story but I don't think you were talking to me about it
19:02:49 <geekosaur> I've never tried to bind a burrito. or lasagne for that matter...
19:03:16 --- mode: glguy set -bbbb *!*generalma@185.16.123.* *!*ggallin*@* *!*gschuet*@* *!*iguano@166.48.42.*
19:03:17 --- mode: glguy set -bbbb *!*inixis@94.231.160.* *!*irc@*.dsl.static.sonic.net *!*ircap@*.Red-83-33-196.dynamicIP.rima-tde.net *!*ircap@213.143.61.*
19:03:17 --- mode: glguy set -bbbb *!*ircap@90.174.1.* *!*jswksl@* *!*kjhkj@*.dsl.bell.ca *!*krq@117.230.143.*
19:03:17 --- mode: glguy set -bbbb *!*magic@2a01:270:dd00:77ca:fadd:4ec6:ab67:* *!*markovirc@67.43.244.* *!*mylittle@183.160.111.128 *!*plant@87-121-128-45.bulsattv.com
19:03:17 --- mode: glguy set -bbbb *!*pooperpoo@200.79.253.* *!*porkys@* *!*reggal@112.145.53.* *!*remaxer@*.ip206.fastwebnet.it
19:03:18 --- mode: glguy set -bbbb *!*richard@*.dyn.embarqhsd.net *!*sdfg@*.elisa-mobile.fi *!*sexy@90.148.63.* *!*spamking@180.183.239.*
19:03:19 --- mode: glguy set -bbbb *!*ssjsj@* *!*sysRPL@*.res.bhn.net *!*tytyryty@jrcollado1987.ddns.net *!*ubuntu@*.53.148.146.bc.googleusercontent.com
19:03:20 --- mode: glguy set -bbbb *!*worshipfu@*.wireless.uic.edu *!*xdie@190.193.33.* *!*zubir@*.hsd1.fl.comcast.net *!322f5689@gateway/web/freenode/ip.50.47.86.137
19:03:21 --- mode: glguy set -bbbb *!43e741c3@gateway/web/freenode/ip.67.231.65.195 *!Enjambre@rolls.fat.blunts.ws *!Nietzsches@you.want.to.fuck.with.us.to *!aa85c8f0@gateway/web/freenode/ip.170.133.200.240
19:03:22 --- mode: glguy set -bbbb *!bb268478@gateway/web/freenode/ip.187.38.132.120 *!dicker@c-71-58-196-93.hsd1.pa.comcast.net *!rondon@* *!uid25435@gateway/web/irccloud.com/x-ikdtytgcrbnnarytnil
19:03:50 <mellowmaroon> :O
19:03:54 <erisco> I find them more like putting a belt through belt loops
19:04:30 <erisco> I practice my monads every day first thing in the morning…
19:04:35 <mellowmaroon> Yeah, that's a good analogy.  Gluten binds lasagna like a monad
19:06:15 --- mode: glguy set -bbbb *!xdccMule@* *!~34110025@104.240.236.254 *!~AngryBeer@110.208.139.5nil *!~Babycaz@198.7.59.108
19:06:15 --- mode: glguy set -bbbb *!~CLIENTE04@187.153.59.178 *!~Doctor_DO@02df1fa2.bb.sky.com *!~IanMc@* *!~IceChat7@24.114.41.176
19:06:15 --- mode: glguy set -bbbb *!~Ipil@187.153.74.248 *!~IzaakBloo@* *!~JohnMurde@119.186.244.189 *!~Lajla@*
19:06:15 --- mode: glguy set -bbbb *!~Leona21@37.221.169.149 *!~Shuttlewo@115.239.249.12 *!~XennonsPl@197.48.142.243 *!~brad@199-255-209-167.anchorfree.com
19:06:15 --- mode: glguy set -bbbb *!~dameloo@80.30.150.222 *!~ddss*@2600:1003:b0* *!~deph@virtual80.tentacle.fi *!~dfsgsdfgs@8.22.204.138
19:06:16 <sqooq> erisco, I still didn't really understand it. Like I need to know how it applies to my audio processing case.
19:06:16 --- mode: glguy set -bbbb *!~dssdsd@5.172.255.189 *!~letalvis@222-152-142-161.jetstream.xtra.co.nz *!~lumpysoup@*.btcentralplus.com *!~martin@85-127-100-72.dynamic.xdsl-line.inode.at
19:06:17 --- mode: glguy set -bbbb *!~neuroserp@187.21.59.228 *!~nodebot@117.220.247.56 *!~poutine@you.can.trust.this.trollbot.org *!~rapeseed@*
19:06:19 --- mode: glguy set -bb *!~smoke@pool-71-177-95-243.lsanca.fios.verizon.net *!~stormroof@*
19:06:20 <glguy> Last one for a little while
19:07:00 <geekosaur> "@you.can.trust.this.trollbot.org"
19:07:12 <sqooq> erisco, I wish it would build... so I can actually start playing with it and testing the result
19:07:33 <erisco> I have their root cert installed
19:07:48 <mellowmaroon> Suspenders -> monadic transformer stack
19:07:54 <erisco> sqooq, I don't know anything about reflex
19:08:28 <erisco> other than it is a web gui thingie that works with ghcjs … but I am using PureScript because it is less of a pain to get running
19:09:48 <sqooq> ????
19:09:50 <sqooq> waaat
19:09:59 <sqooq> but you were telling me...
19:10:04 <sqooq> am I tripping
19:10:52 <mniip> a decent haskeller probably could explain a topic to someone while having the documentation open in another tab
19:11:12 <erisco> is that a challenge?
19:11:25 <mniip> no it's a compliment
19:11:32 <mniip> *wink*
19:11:49 <EvanR> the non existent haskell docs ?
19:11:56 <EvanR> impressive
19:12:15 <erisco> if it is a build problem then you probably know more than I do, docs or not
19:12:28 <mniip> EvanR, I've never found haskell docs to be lacking
19:12:42 <sqooq> erisco, o is that what you meant??
19:12:52 <sqooq> like i thought you meant you don't know reflex
19:12:53 <sqooq> lmao
19:12:57 * EvanR tries to find reflex docs
19:12:58 <erisco> I don't
19:13:00 <mniip> so much in fact that I'd never publish a package without at least a moderate amount of documentation because it'd appear off
19:13:03 <sqooq> but like you have been trying to teach me it
19:13:10 <erisco> it was someone else
19:13:17 <sqooq> :thinking:
19:13:18 <sqooq> Wat
19:13:47 <sqooq> are you gaslighting me
19:13:49 <erisco> try another name that starts with e maybe… like ertes or ernst or erikd
19:13:50 <glguy> Are you thinking of erte-s
19:13:51 <EvanR> found a tutorial
19:14:00 <sqooq> ooooo
19:14:01 <mniip> or EvanR
19:14:01 --- mode: glguy set -o glguy
19:14:23 <sqooq> it was ertes
19:14:24 <sqooq> haha
19:14:38 <glguy> erisco: Don't you e- name people get together and share notes from the previous day?
19:15:04 <erisco> well that's the problem… sqooq was talking about this at about 5 today, I think
19:15:09 <EvanR> > 'e' == 'E'
19:15:13 <lambdabot>  False
19:15:17 <EvanR> not it
19:20:27 <eviltwin_b> now what?
19:32:06 <sqooq> ertes,
19:42:21 * hackage siren-json 0.1.3.0 - Siren Tools for Haskell  https://hackage.haskell.org/package/siren-json-0.1.3.0 (alunduil)
20:24:07 <SSWASEinfolud> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄ LRH IS LIVE NOW!! TODAYS EDITION SLIMER GETS FUCKED IN VEGAS!! https://www.youtube.com/user/l0de/live CALL 315-505-4666 vzowinedcz: alexteves jfredett_ saurabhnanda ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
20:24:07 <SSWASEinfolud> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ LRH IS LIVE NOW!! TODAYS EDITION SLIMER GETS FUCKED IN VEGAS!! https://www.youtube.com/user/l0de/live CALL 315-505-4666 tljynpiw: freusque cansis S007 ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
20:24:07 <SSWASEinfolud> ▄▄▄▄▄▄▄▄▄▄▄▄▄ LRH IS LIVE NOW!! TODAYS EDITION SLIMER GETS FUCKED IN VEGAS!! https://www.youtube.com/user/l0de/live CALL 315-505-4666 fvsvkxcuwz: x1n4u lambda-11235 wto ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
20:24:08 <SSWASEinfolud> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ LRH IS LIVE NOW!! TODAYS EDITION SLIMER GETS FUCKED IN VEGAS!! https://www.youtube.com/user/l0de/live CALL 315-505-4666 irmxv: lambdaman bengt_ woodson_ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
20:25:02 --- mode: ChanServ set +o glguy
20:25:03 --- mode: glguy set +b *!*@165.16.66.186
20:50:52 <WinterFox[m]> Does anyone know what name Yesod creates for table column IDs? I want to select users by a list of IDs but UserId is not found.
20:51:16 <Tehnix> Does anyone have a succint explanation on the difference between a `Free` monad and a `Freer` monad? Or do I need to go down the rabbit hole?
20:53:33 <dfeuer> Currently, Data.Sequence.chunksOf is documented as being O(n), but if my calculations are correct, I think it's actually  O((n/c) (log c + 1)), where n is the sequence length and c is the chunk size.
20:53:39 <dfeuer> Does that sound right?
20:57:27 <dfeuer> Actually, probably closer to   O((n/c - 1) (log c + 1) + 1), to catch edge cases.
21:05:22 * hackage network-arbitrary 0.3.0.0 - Arbitrary Instances for Network Types  https://hackage.haskell.org/package/network-arbitrary-0.3.0.0 (alunduil)
21:25:48 <darthmaul212> I am going through the Reader chapter of the Haskell FPP book and got a little confused. Is the Reader newtype something people define on their own or is it available through some package?
21:27:05 <glguy> It's available from the transformers package
21:27:08 <glguy> ?hackage transformers
21:27:08 <lambdabot> http://hackage.haskell.org/package/transformers
21:27:36 <glguy> But it might be the case that it's worth implementing locally for the purpose of the exercises
21:27:42 --- mode: glguy set -o glguy
21:27:49 <MarcelineVQ> the one in the book, if you're seeing it for the first time, is one you write
21:28:15 <MarcelineVQ> if you want me to confirm though let me know what section you're looking at it in :>
21:28:33 <darthmaul212> I think I'll just copy the definition from section 22.5
21:29:00 <darthmaul212> I think I am trying to get ahead of myself by looking for it in a package
21:34:52 * hackage dynamic-graph 0.1.0.10 - Draw and update graphs in real time with OpenGL  https://hackage.haskell.org/package/dynamic-graph-0.1.0.10 (adamwalker)
21:54:22 <ned> is there a monoid version of when/unless? Tried 'Monoid a => Bool -> a -> a' on hoogle but couldn't see anything...
21:54:52 * hackage sdr 0.1.0.10 - A software defined radio library  https://hackage.haskell.org/package/sdr-0.1.0.10 (adamwalker)
22:02:34 <verement> :t \b x -> if b then x else mempty  -- ned?
22:02:36 <lambdabot> Monoid p => Bool -> p -> p
22:05:23 <geekosaur> don'[t think I've ever seen a situation where one with only a Monoid constraint was useful. which doesn't mean such cases don't exist, but may suggest they're not common enough for such to be a common function
22:06:51 * hackage serverless-haskell 0.0.6 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.0.6 (AlexeyKotlyarov)
22:13:08 <MarcelineVQ> verement:  bool mempty id  if you want to impress your fans and make your enemies tremble
22:13:35 <verement> indeed
22:18:41 <verement> :t bool (const mempty) id
22:18:43 <lambdabot> Monoid a => Bool -> a -> a
22:19:23 <MarcelineVQ> parens! may as well just use flip :D
22:20:02 <MarcelineVQ> one of you guru's make a ConT version :>
22:20:31 <MarcelineVQ> *ContT
22:20:53 <ned> verement: exactly, yeah, but I was wondering if it was included in a package somewhere.
22:21:02 <geekosaur> i,i Con'T!
22:21:11 <verement> ned: nothing comes to mind
22:22:47 <ned> geekosaur: this came up because I wanted something like 'let text = when f (pack "hello")' for Data.Text
22:23:34 <verement> :t when
22:23:36 <lambdabot> Applicative f => Bool -> f () -> f ()
22:27:56 <geekosaur> come to think of it...
22:28:12 <geekosaur> @hoogle Alternative f => Bool -> f () -> f ()
22:28:13 <lambdabot> Protolude guarded :: (Alternative f) => (a -> Bool) -> a -> f a
22:28:13 <lambdabot> Protolude guardedA :: (Functor f, Alternative t) => (a -> f Bool) -> a -> f (t a)
22:28:13 <lambdabot> Configuration.Utils.CommandLine (.::) :: (Alternative ?, Applicative ?) => Lens' ? ? -> ? ? -> ? (? -> ?)
22:58:47 <dmwit> :t \b -> [b|b] >> "hello"
22:58:48 <lambdabot> Bool -> [Char]
22:58:53 <dmwit> ned: =P
22:59:50 <metahumor> whats a more idiomatic way of writing something like "return x >>= f >>= f >>= f >>= f"?
22:59:52 <dmwit> > let f b = [b|b] >> "hello" in (f True, f False)
22:59:56 <lambdabot>  ("hello","")
23:01:44 <dmwit> :t foldr (>=>) return . replicate 4
23:01:46 <lambdabot> Monad m => (c -> m c) -> c -> m c
23:02:02 <dmwit> :t \f -> iterate (>>=f) !! 4
23:02:04 <lambdabot> error:
23:02:04 <lambdabot>     • Couldn't match expected type ‘[a1]’
23:02:04 <lambdabot>                   with actual type ‘m a -> [m a]’
23:02:13 <dmwit> :t \f -> iterate (>>=f) (return x) !! 4
23:02:16 <lambdabot> Monad m => (Expr -> m Expr) -> m Expr
23:02:24 <metahumor> awesome, thanks
23:02:26 <dmwit> heh, forgot to abstract `x`
23:02:54 <dmwit> :t foldM
23:02:57 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
23:03:28 <mniip> ooh
23:03:34 <mniip> @let foo foo = foo
23:03:36 <lambdabot>  Defined.
23:04:00 <mniip> pattern bindings take presedence over... well, equation bindings
23:04:34 <dmwit> :t \f x -> foldM (flip (const f)) x (replicate 4 ())
23:04:36 <lambdabot> Monad m => (b -> m b) -> b -> m b
23:05:27 <dmwit> None of these really seem great. I kind of like `f >=> f >=> f >=> f` for how brain-dead easy it is to read.
23:06:39 <dmwit> :t foo
23:06:42 <lambdabot> p -> p
23:07:22 * hackage type-map 0.1.1.0 - Type-indexed maps  https://hackage.haskell.org/package/type-map-0.1.1.0 (lyxia)
23:08:18 <metahumor> StateT a [] b is so powerful
23:08:21 <metahumor> i'm loving it
23:11:13 <mniip> wait till you hear about StateT [a]
23:11:38 <mniip> or its obviously much better cousin FreeT ((->) a)
23:12:22 * hackage conduit 1.2.13 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.2.13 (MichaelSnoyman)
23:12:39 <dmwit> ?unmtl StateT a []
23:12:40 <lambdabot> Plugin `unmtl' failed with: `StateT a []' is not applied to enough arguments, giving `/\A. a -> [] (A, a)'
23:12:57 <metahumor> right now, i'm using a "StateT IntSet [] [Int]"
23:27:52 * hackage persistent-redis 2.5.2.2 - Backend for persistent library using Redis.  https://hackage.haskell.org/package/persistent-redis-2.5.2.2 (psibi)
23:42:28 <Ke> so did someone fix spectre for ghc yet?
23:47:41 <mniip> "fix" "spectre" for ghc?
23:48:14 <mniip> if you mean eliminating speculable indirect branches that sounds ridiculous
23:49:31 <mniip> only thing stg ever does is indirect branches
23:54:45 <geekosaur> "the sky is falling!" and most of the people asking questions like that don't actually understand the issue
23:55:03 <geekosaur> like, there is only one real fix for it. redesignt he CPU
23:55:26 <geekosaur> there are imperfect software mitigations
