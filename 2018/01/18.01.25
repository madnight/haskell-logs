00:14:41 <ertes-w> hllo
00:15:30 <ReinH> hllo rts-w
00:20:03 <dublefired> ciao
00:32:32 <sphalerite> Why might I be getting `hGetContents: invalid argument (invalid byte sequence)` from a use of readFile? iconv doesn't complain about the file, which is UTF-8 encoded
00:33:55 <Philonous> sphalerite, Check that your locale is UTF8-aware
00:34:36 <sphalerite> `locale` lists all of the vars besides LC_ALL as en_GB.UTF-8
00:38:06 <sphalerite> would stack affect this at all?
00:48:31 <ertes-w> sphalerite: perhaps there is an actual invalid character?
00:49:23 <whatsupboy> why every one here say haskellbook is best source I have gone throught LYAH + Someuniversity tutorials and I am not understanding how haskellbook making difference to them ?
00:49:30 <sphalerite> ertes-w: as I said, iconv doesn't complain about it. Do you have another way of checking?
00:50:00 <ertes-w> sphalerite: ah, sorry, didn't see that
00:50:32 <ertes-w> whatsupboy: that's by no means a universal opinion
00:50:58 <merijn> whatsupboy: LYAH is very incomplete, doesn't leave you well equipped to understand large parts of the ecosystem and, isn't very good in terms of didactics
00:51:16 <whatsupboy> ertes-w: but when i hang here many suggest that book since I downoaded it (pirated version) I just want to check but dont want to learn from a pirated copy
00:51:27 <merijn> whatsupboy: LYAH was great when it came out, since at that time there was nothing, but nowadays...not what I'd recommend
00:52:15 <ertes-w> whatsupboy: at the very least haskellbook is the most complete book right now, but there are some objections to its pace and some other aspects
00:52:16 <whatsupboy> merijn:  ok and LYAH + https://video.fsmpi.rwth-aachen.de/12ss-funkprog
00:52:38 <whatsupboy> how about combination of above 2
00:52:50 <whatsupboy> I found those lectures so intresting and helpful to me
00:53:04 <ertes-w> whatsupboy: i'm not familiar with the latter, but one course i can recommend is CIS 194
00:53:22 <whatsupboy> CIS 194 dont have video but only notes
00:53:25 <whatsupboy> right?
00:53:30 <ertes-w> yeah
00:53:49 <ertes-w> it's a quick hands-on way to learn haskell
00:58:53 <whatsupboy> ok ertes-w
01:12:48 <ertes-w> sphalerite: what does hGetEncoding on the handle report?
01:14:30 <jez_> foo :: Maybe (Maybe a)
01:14:30 <jez_> foo Nothing         = Nothing
01:14:30 <jez_> foo (Just Nothing ) = Nothing
01:14:33 <jez_> foo (Just (Just x)) = Just x
01:14:49 <jez_> ^ What function is this? I feel like this is a typeclass
01:15:00 <dminuoso> :t join
01:15:02 <lambdabot> Monad m => m (m a) -> m a
01:15:08 <jez_> ty!
01:15:28 <dminuoso> jez_: Note that the type signature is wrong (or incomplete)
01:15:36 <dminuoso> That shouldn't type check what you have written
01:15:48 <jez_> ah, yeah i forgot to run it
01:15:51 <jez_> it's missing an arrow
01:16:55 <dminuoso> jez_: and when I say `join` I obviously implicitly include >=> and >>= - basically you're tapping into the monad interface of Maybe.
01:16:58 <ertes-w> :t maybe Nothing id
01:17:00 <lambdabot> Maybe (Maybe a) -> Maybe a
01:17:15 <sphalerite> ertes-w: Just ASCII…
01:17:20 <sphalerite> which explains it
01:17:21 <merijn> ertes-w: That's just reinventing join from maybe >.>
01:17:23 <sphalerite> but why?
01:17:31 <merijn> > :t (>>= id)
01:17:34 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
01:17:36 <ertes-w> sphalerite: how did you open the handle?
01:17:40 <merijn> :t (>>= id)
01:17:41 <lambdabot> Monad m => m (m b) -> m b
01:17:57 <ertes-w> merijn: of course…  i just wanted to get my daily dose of code golf =)
01:18:05 <ertes-w> although i wouldn't even consider this golfing
01:18:29 <merijn> ertes-w: Well, in that case you need to step up your golf game and not suck :p
01:18:33 <sphalerite> ertes-w: just now using openFile. But previously using readFile
01:18:34 <merijn> 'cause mine is much shorter :p
01:18:41 <merijn> Although "join" is shorter still
01:20:06 <ertes-w> sphalerite: the initial encoding of an openFile-ed handle depends on a few factors, but for the most part the answer probably lies in your LANG or some LC_* variable
01:20:28 <ertes-w> sphalerite: in particular LC_CTYPE, if no others seem relevant
01:20:48 <ertes-w> sphalerite: (this is about unix-like systems…  i don't know about windows)
01:21:11 <sphalerite> ertes-w: well I'm on NixOS so that should apply
01:21:27 <ertes-w> merijn: not if the goal is to implement 'join' without Monad =P
01:22:08 <ertes-w> :t asum :: Maybe (Maybe a) -> Maybe a
01:22:10 <lambdabot> Maybe (Maybe a) -> Maybe a
01:22:22 <merijn> > length "fromMaybe Nothing"
01:22:24 <lambdabot>  17
01:22:32 <merijn> > length "maybe Nothing id""
01:22:35 <lambdabot>  <hint>:1:27: error:
01:22:35 <lambdabot>      lexical error in string/character literal at end of input
01:22:38 <merijn> > length "maybe Nothing id"
01:22:42 <lambdabot>  16
01:22:44 <merijn> Rats
01:22:55 <ertes-w> merijn: asum is even shorter =P
01:22:55 <sphalerite> ertes-w: I just tried doing `LC_ALL=en_GB.UTF-8 LANG=en_GB.UTF-8 stack ghci` and am still getting it opened as ASCII...
01:23:25 <ertes-w> sphalerite: well, one option would be to set the encoding explicitly, but that's probably the wrong approach
01:23:30 <sphalerite> ertes-w: could it be that stack is unsetting LOCALE_ARCHIVE?
01:24:00 <ertes-w> sphalerite: yes, that could be it
01:24:13 <ertes-w> LOCALE_ARCHIVE on NixOS has a non-standard path
01:25:33 <ertes-w> sphalerite: in that case i would assume that even stdin is ASCII-encoded for you
01:25:42 <mpickering> yes you need to set LOCALE_ARCHIVE as well as LANG
01:25:59 <sphalerite> well it's already set, but stack seems to be unsetting it
01:26:15 <merijn> Are you sure it's exported?
01:26:17 <mpickering> Why are you using stack with nix :P ?
01:26:25 <mpickering> what does "stack ghci" do?
01:26:36 <ertes-w> sphalerite: why would it do that though?  i have no experience with stack; have you verified that it does via System.Environment?
01:26:40 <sphalerite> mpickering:  because I have no idea what I'm doing :p
01:27:11 <Philonous> mpickering, Are you saying you can't use stack on nix?
01:27:12 <mpickering> are you using stack with --nix or not?
01:27:14 <ertes-w> merijn: you would have to explicitly unexport it on NixOS
01:27:30 <mpickering> you can use stack on nix but there's nearly no point
01:27:42 <sphalerite> Hm nope, it's not being unset
01:27:50 <sphalerite> I'm not using --nix, would that help?
01:28:08 <ertes-w> sphalerite: yeah, i would have found it very weird if it did
01:28:20 <ertes-w> stack has no business messing with locale settings
01:28:20 * sphalerite tries
01:28:30 <sphalerite> nope
01:28:49 <ertes-w> sphalerite: if you run GHCi directly, do your locales work properly?
01:29:03 <sphalerite> I figured it might be a thing like nix-shell --pure. As I said I have no idea what I'm doing with stack >.>
01:29:12 <Philonous> mpickering, There's existing projects that use stack, it would make sense to keep the build process consistent
01:29:19 <ertes-w> sphalerite: try 'cabal new-repl' instead of 'stack ghci'
01:29:26 <sphalerite> ertes-w: yes
01:30:00 <mpickering> Philonous: You don't want stack to manage your GHC installations and dependencies if you're using nixos as it's just wasting space surely?
01:31:01 <mpickering> https://github.com/commercialhaskell/stack/issues/3802
01:31:01 <Philonous> mpickering, No, but I want it to do the dependency resolution and actual build
01:31:55 <mpickering> I guess that's the point of the --nix flag
01:32:04 <sphalerite> cabal doesn't want to build OpenGLRaw
01:32:12 <sphalerite> (can't find GL)
01:32:25 <merijn> sphalerite: Is GL installed in a way that pkgconfig can find it?
01:32:30 <mpickering> likewise.. you shouldn't use cabal new-build with stack because it will manage dependencies for you
01:32:35 <mpickering> *nix
01:32:47 <sphalerite> merijn: yes, nixos
01:32:54 <sphalerite> Should I just use a nix shell with all the C deps?
01:32:56 <ertes-w> sphalerite: if you can, you should use the 'gl' package anyway
01:33:02 <mpickering> yes sphalerite
01:33:21 <ertes-w> sphalerite: in general you're going to do yourself a favour by using either cabal-install or nix on NixOS
01:33:30 <sphalerite> ertes-w: it's using GLOSS, which in turn depends on OpenGLRaw
01:33:36 <ertes-w> ah
01:34:00 <mpickering> If you do "cabal2nix . --shell > shell.nix"
01:34:10 <mpickering> then nix-shell will probably work to put you in the right environment
01:34:15 <ertes-w> yeah
01:34:29 <ertes-w> nix-shell shell.nix --command 'exec ghci …'
01:34:30 <mpickering> as the system dependencies of OpenGLRaw will be already declared upstream
01:34:51 <Philonous> I'm building gititi and it seems that the data directory (the one getDataFile uses) gets hard-coded into the executable as /home/<user>/build/gitit/.stack-work/install/[...] is there a way to change that?
01:34:54 <sphalerite> alright, I'll try that while I wait for the deps to build from cabal new-repl
01:35:08 <ertes-w> sphalerite: in fact i have a wrapper script for running GHCi in nix-shell in a way that integrates with haskell-mode, in case you use it
01:35:14 <Philonous> gitit, even
01:36:06 <sphalerite> I'm a vim user :p aspiring emacs user but the main thing stopping me from switching is that nixpkgs doesn't seem to have the same sort of packaging support for emacs as for vim
01:36:25 <ertes-w> sphalerite: https://github.com/esoeylemez/config/blob/master/bin/nix-ghci
01:36:32 <ertes-w> sphalerite: it does, i'm using it =)
01:36:58 <ertes-w> the script is not in any way related to emacs BTW…  it's sole point is to make nix+ghci transparent
01:37:05 <ertes-w> only caveat: it needs zsh
01:37:24 <mpickering> Philonous: What does gitit --help say, there is probably an option there to point to a different data dir
01:37:25 <sphalerite> oooooh is that new? I don't remember seeing it last time I looked but there it is indeed!
01:38:10 <sphalerite> ok so I've done cabal2nix to get a shell, how do I go about building the project now?
01:38:17 <mpickering> cabal configure
01:38:19 <mpickering> cabal build
01:38:31 <mpickering> after "nix-shell"
01:38:36 <sphalerite> cabal doesn't seem to be included in the shell
01:38:48 <electrocat> cabal isn't required
01:38:54 <Philonous> mpickering, There doesn't seem to be, and from what I've seen in the code they seem to just call "getDataFile" directly without checking whether it's been overridden
01:38:54 <ertes-w> sphalerite: use your Setup.hs
01:39:04 <electrocat> you could do 'runhaskell Setup.hs configure/build'
01:39:16 <ertes-w> sphalerite: runghc Setup.hs configure && runghc Setup.hs build
01:39:32 <Philonous> Also, it's the principle of the thing, I'd rather not have specifics of my build system hard-coded in a binary I want to distribute
01:40:09 <sphalerite> hallelujah, it works!
01:40:15 <sphalerite> Thanks for the help!
01:40:48 <mpickering> Philonous: https://github.com/jgm/gitit/issues/599
01:41:26 <sphalerite> trikl: so it's `nix-shell -p cabal2nix --run 'cabal2nix --shell . > shell.nix'; nix-shell --run 'runghc Setup.hs configure && runghc Setup.hs build && ./dist/build/*/* animate path/to/stuff'`
01:41:41 <mpickering> linked ticket: https://github.com/commercialhaskell/stack/issues/1005
01:42:20 <mpickering> ^ and that's why I think having language specific stuff nix stuff built into cabal and stack is a very good thing hah
01:42:23 <Philonous> mpickering, Oh wow, thanks. I've tried googling the problem for an hour to no avail.
01:43:26 <jpcooper> Hello. Is there any way in Spacemacs to find the usages of a symbol? I would also like to be able to rename a symbol and have all of its usages updated as well
01:44:06 <[exa]> hm guys, is there already some cheminformatics toolkit for haskell? something that would be able to at least parse SMILES/SDF files?
01:45:07 <sphalerite> Thanks for all the help!
01:56:04 <cycle337> hello
01:56:40 <cycle337> guys can you please help me? I am using Servant and trying to write a function that returns an AppM Jwt
01:57:16 <cycle337> the function is already written I just have to tap in and make it so it returns an Either type with a failure message for debugging purposes
01:58:15 <alp> cycle337, can you paste the code you have and possibly the thing you're trying to write, with ??? in the places where you don't know what to do, or something like that. so that we know precisely the step that's causing you trouble
01:58:18 <cycle337> where do I jump in and set my Either String AppM ? is it in the login type annotation ?
01:58:31 <cycle337> @alp yeah sure
01:58:31 <lambdabot> Maybe you meant: slap pl help ask arr
01:59:19 <cycle337> https://www.irccloud.com/pastebin/i8jSMaEE/login%20with%20either
02:00:02 <arne> someone wrote a RDS in haskell, can't seem to find it
02:00:06 * cycle337 so I'm thinking line 1 should end with... -> Either String (AppM Jwt)
02:00:09 <arne> someone remember it's anme?
02:01:38 <cocreature> arne: m36?
02:02:34 <Philonous> mpickering, After some digging in the code I found out that you can override the directories with environment variables. Not great, but good enough.
02:02:45 <cycle337> arne:  or amazonka-rds ?
02:03:30 <cocreature> cycle337: that’s just an API for accessing an rds not written in haskell
02:03:51 <cycle337> oh sorry
02:05:36 <dminuoso> Is there a way to interactively use IO in GHCi?
02:05:48 <dminuoso> I basically want some way to do `IO a -> a`
02:06:10 <dminuoso> in particular I have a function that produces a database handle, but I want to interactively play with that..
02:06:22 <cocreature> dminuoso: dbHandle <- getDBHandle
02:06:27 <cocreature> just like in a do block
02:06:32 <dminuoso> Oh. Wow.
02:06:59 <dminuoso> cocreature: That works great thanks.
02:07:13 <merijn> dminuoso: Most of ghci's weirdness is from the fact that it's effectively a big do-block that's had import and multi-line definitions hacked in later :p
02:10:15 <alp> cycle337, looking at your code now
02:10:17 <cycle337> oh by the way I am using https://www.stackage.org/haddock/lts-10.3/jose-jwt-0.7.8/Jose-Jwt.html to generate JWT
02:11:23 <alp> cycle337, what's AppM? and where/how is that 'login' function meant to be used? that pretty much determines the return type I guess :)
02:11:55 <cycle337> well `type AppM = ReaderT Config Handler`
02:12:31 <muzzle> is there a way to find out if I'm in the middle of a transaction in postgresql-simple?
02:12:43 <cycle337> that's AppM and that login is used either to login in a form or to login with facebook, both of which need Either instances to be returned instead of what's now
02:12:48 <muzzle> so that I don't start a new one?
02:13:40 <alp> cycle337, I see, so you want the return type to be 'AppM (Either SomeErrorType Jwt)' ?
02:13:53 <cycle337> yes
02:14:13 <cycle337> for now it can be AppM (Either String Jwt)
02:14:37 <cycle337> where I will personally hardcode the errors depending on which case is realized
02:14:56 <alp> cycle337, ok, so the first thing you'll want to do is replace the calls to 'throwError'
02:15:14 <alp> by: return (Left "some error string")
02:17:26 <alp> throwError uses the fact that the 'Handler' monad from servant knows how to throw ServantErr. if you want to explicitly return an error without throwing it just yet, you can simply return the error wrapped in 'Left'
02:18:06 <alp> the second thing is that everywhere where you simply return the toke, you will have to return it by wrapping it in 'Right'
02:18:36 <cycle337> great stuff alp, thanks for clearing that for me about ServantErr
02:19:07 <alp> cycle337, note that most of the time you'll want to use a custom monad that also has a custom error type
02:19:56 <cycle337> yes, I agree, there's grounds for a bigger refactoring
02:20:04 <alp> say: data AppError = TokenNotFound Jwt | CouldNotRegisterWithFB FBID
02:20:24 <alp> right, of course there's no rush
02:20:26 <cycle337> right now, the login will implement new functionality and I need to debug it but on the long run, it will use a custom monad
02:20:30 <alp> but I just thought I should point that out
02:20:50 <alp> I haven't yet written a good example to illustrate this in the servant cookbook yet unfortunately (https://haskell-servant.readthedocs.io/en/latest/cookbook/index.html)
02:20:52 <cycle337> thanks very much, this is good stuff, i'm learning things
02:21:24 <alp> also, note that servant-auth supports JWT already and also allows you to support multiple auth schemes
02:21:41 <alp> maybe you'll want to port your code over to that, I think you'd only have to implement support for the facebook thing
02:22:04 <cycle337> :))) I guess I'm taking the long road to implementing servant-auth right now :))
02:22:13 <alp> heh
02:22:16 <cycle337> but it's also for learning purposes
02:22:25 <alp> well this could be a second refactoring step I suppose :)
02:22:52 <cycle337> excellent, thank you, I have my work laid out for me in the coming week
02:23:15 <alp> I think I would recommend you just do whatever feels simpler for now, for which you have a clear picture of what to do, if you're still learning your way around servant
02:26:14 <WinterFox[m]> Is Quasiquotation related to template Haskell?
02:26:24 <merijn> WinterFox[m]: Yes
02:26:51 <merijn> WinterFox[m]: QuasiQuotation is just "a convenient method to run a TH function on this string input"
02:27:16 <WinterFox[m]> Ah ok.
02:27:36 <alp> cycle337, also note that there's a #servant channel where your questions are less likely to get lost in the middle of several other conversations =)
02:27:46 <WinterFox[m]> There is a file `config/routes` in my Yesod app with a DSL so I assume thats the QuasiQuotation stuff?
02:28:38 <cycle337> alp: thanks, just joined
02:28:41 * cycle337 thrilled
02:29:11 <merijn> You know what, next time I have some downtime I'm gonna add a new GHC flag to inhibit typed hole warnings/errors whenever there are other warnings/errors still around
02:36:17 <ertes-w> merijn: i would appreciate a flag that does the exact opposite
02:36:38 <ertes-w> if there is a hole, either display that warning at the top or inhibit all other warnings
02:37:07 <merijn> ertes-w: That should be easy enough if I get the other one sorted out
02:38:07 <ertes-w> merijn: BTW, there is a ticket about solving a more general problem: warning priorities
02:38:31 <merijn> ertes-w: Yeah... that sounds like it'd be too much work to quickly hack in
02:39:55 <ertes-w> merijn: certainly, but just for reference: https://ghc.haskell.org/trac/ghc/ticket/12157
02:42:54 <ertes-w> merijn: i think what you want to implement is another special case of this
02:43:40 <ertes-w> so if you implement it with this in mind, it may make a future implementation of priorities easier =)
02:44:17 <merijn> ertes-w: I'm hoping maybe someone here will go "that sounds amazing" and do it for me before I have time :p
02:44:40 <ertes-w> anyone? ;)
02:45:32 <merijn> Fame, glory, and eternal appreciation await ;)
02:48:18 <Bish> shouldn't haskell have it's own DBMS?
02:48:26 <merijn> Bish: Why?
02:48:29 <ertes-w> Bish: why?
02:48:35 <Bish> well,, to have type-safety in stuff in db, too
02:48:50 <merijn> Bish: A lot of databases already have type-safe schemas?
02:49:08 <Bish> uhm, okay, to serialize in between easily?
02:49:14 <ertes-w> Bish: whether you write a type-safe wrapper around an established DBMS or around the even less typed filesystem doesn't really matter =)
02:49:34 <Bish> i feel like that argument is like
02:49:44 <Bish> if you write typesafe code in C or haskell doesn't really matter
02:50:29 <ertes-w> Bish: not quite…  the point is: the haskell side of existing DBMSes is already type-safe
02:50:29 <merijn> Bish: Can't write type-safe code in C, though :p
02:50:39 <Bish> merijn: my point exactly
02:51:04 <merijn> Bish: You can easily check types when interacting with, say, postgres, though and afaik all haskell postgres libraries do
02:51:17 <Bish> okey
02:51:44 <merijn> Bish: i.e. if you try and insert an SQL integer in a column expecting text, it will complain
02:52:12 <Bish> and if you put a string into a date
02:52:12 <ertes-w> Bish: the reason no haskell DBMS already exists is that i haven't written one, because it's months of work to get it right…  now just transfer that to every other haskell programmer who has to choose between using an already existing sqlite/postgres wrapper and writing a DBMS basically from scratch =)
02:52:14 <Bish> it won.t
02:52:52 <ertes-w> Bish: and "months of work" is optimistic
02:53:06 <Bish> i know, im just wondering why none did
02:54:12 <ertes-w> Bish: there is a not-quite-DBMS, if you're interested: acid-state
02:54:59 <Bish> i mean haskell people tend to do a lot of work for things that are less worse
02:55:05 <ertes-w> it side-steps the whole getting-a-DBMS-right issue by just dumping an in-memory reference to disk, so it doesn't replace a DBMS, but it can be used in simple cases
02:55:45 <m0ar> Does anyone have experience running pure computations in parallel with Haxl?
02:55:48 <Bish> are there things that just shouldn't be written in haskell? or can you, in principle, get the performance of like.. let's say c
02:56:54 <merijn> Bish: It's a trade-off of how fast you want something done, how much time you're willing to invest, etc.
02:57:04 <cojack_> hi, does any1 have a book "Parallel Program Design: A Foundation"
02:57:10 <ertes-w> Bish: it would be much more challenging to get the same performance as, say, sqlite, not because of haskell directly, but because you would have to repeat decades of performance improvements in a completely different paradigm
02:57:51 <ertes-w> @where PCPH
02:57:51 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>
02:57:54 <AndreasPK> Where I wouldn't use it is if I plan on low level stuff where I WANT to manipulate pointers and the like
02:57:56 <ertes-w> cojack: ^ i don't, but have you seen this?
02:58:11 <Bish> ertes-w: so in principle there isn't something that cannot be done?
02:58:16 <Bish> or is it because of limitations like
02:58:20 <Bish> haskell can't inline-asm
02:58:25 <merijn> AndreasPK: Honestly, I'm using Haskell for that now, because it's much nicer than making my C++ code interface with Haskell directly :p
02:58:26 <cojack> ertes-w: yes, on amazon, but they don't ship to my country
02:58:32 <ertes-w> Bish: even if there is you can always write parts of it in C
02:58:42 <cojack> oh sorry
02:58:48 <cojack> I miss the point of the question
02:58:50 <merijn> Bish: You can just implement your own Cmm primops, write stuff in C and use the FFI, etc.
02:58:52 <Bish> but if i was about to write a AAA-game in haskell
02:58:56 <cojack> nope, I don't see this position before
02:59:05 <Bish> wouldn't the way fp models things get in my way?
02:59:08 <merijn> Bish: Depends on the kind of game
02:59:21 <ertes-w> Bish: no, because AAA games mostly compute on the GPU anyway =)
02:59:22 <Bish> crisis i don't know
02:59:22 <merijn> Bish: Civilisation in Haskell seems fine. Twitchy FPS, probably not
02:59:25 <Bish> it's just a example
02:59:48 <Bish> but is the way FP-programs get written not kinda suggesting that the "screen" is a transformation of data => screen
03:00:00 <Bish> and that's totally not how a pipeline in a Gfx-card works?
03:00:09 <ertes-w> Bish: we have some EDSLs for GPU computation, but they are far from offering the same performance as carefully hand-crafted GPU code
03:00:15 <m0ar> Bish: interesting little case analysis on the topic of performance compared to c: https://two-wrongs.com/on-competing-with-c-using-haskell
03:00:19 <AndreasPK> Not sure if FP would be as much of a hinderance compared to the 30 years of Imperative game programming experience out there
03:00:34 <AndreasPK> Which you can't make use of
03:01:05 <ertes-w> Bish: FP can be used in games…  for example FRP is a popular paradigm for long-running interactive programs
03:02:17 <tdammers> AndreasPK: not all of those 30 years are lost when you switch to FP
03:02:53 <reactormonk> In postgresql-simple, what does Decimal(20, 4) map to in Haskell types?
03:03:06 <hvr> tdammers: which years ain't?
03:03:22 <tdammers> hvr: the uneven ones
03:03:28 <AndreasPK> :D
03:03:29 <hvr> sounds legit
03:03:34 <tdammers> inorite
03:03:38 <tdammers> seriously though
03:04:08 <tdammers> of all the wisdom from those years, a lot is just figuring out how to tame certain shortcomings of imperative languages
03:04:12 <Bish> ertes-w: i am not asking about if it can be used.. i want an answer to the question if .. in theory.. FP was the dominant programing-style
03:04:25 <tdammers> guess what, in a paradigm that doesn't have those shortcomings, you don't need to replace that wisdom
03:04:26 <Bish> if we had the same performance
03:04:43 <tdammers> another part of it is general programming wisdom, and that part transfers nicely
03:05:15 <hvr> AndreasPK, tdammers: I assume you listened to John Carmack's epic fp-gaming monologue?
03:05:27 <ertes-w> Bish: assuming that, what's the question?
03:06:22 <tdammers> hvr: actually, no, I didn't really read Carmack much deeper than the occasional soundbite
03:07:35 <Bish> ertes-w: i don't know really.. i just want to know if haskell is limited in performance, and i guess it is
03:07:39 <Bish> because abstraction
03:07:45 <tdammers> Bish: no
03:07:47 <Bish> or if i am simply wrong
03:07:55 <hvr> tdammers: https://web.archive.org/web/20130819160454/http://www.altdevblogaday.com/2012/04/26/functional-programming-in-c/
03:08:00 <ertes-w> Bish: but there is a problem with that assumption: we can't really know, because things like IO may be a product of general wisdom about computation, and i'm glad we have it…  if FP were the dominant paradigm, our programs might be structured very differently
03:08:08 <tdammers> *some* of the abstractions Haskell provides have performance overhead
03:08:20 <m0ar> Bish: First answer here explains why it's fast pretty well: https://stackoverflow.com/questions/35027952/why-is-haskell-ghc-so-darn-fast
03:08:21 <hvr> tdammers: and there should be a  QuakeCon2013  video somewhere
03:08:25 <ertes-w> Bish: in haskell many abstractions are free…  haskell is designed in a way that facilitates cheap abstractions
03:08:32 <AndreasPK> hvr: For what it's worth I remember that being more a case for Rust style programming than haskell style
03:08:56 <ertes-w> Bish: that's why AFRP is so popular for games…  it's an extremely high-level abstraction that is essentially a thin wrapper around simple functions…  it's almost free
03:09:04 <tdammers> the one big issue Haskell has when it comes to things like games is that its garbage collection strategy prioritizes throughput over latency
03:09:36 <Bish> m0ar: seems like a good read
03:09:40 <Bish> ertes-w: interesting
03:09:41 <tdammers> which can be problematic in a game - if you want to render 120 fps, then a 20-millisecond stop-the-world round of garbage collection is a problem
03:09:56 <hvr> AndreasPK: probably, yeah
03:10:00 <hvr> tdammers: http://functionaltalks.org/2013/08/26/john-carmack-thoughts-on-haskell/
03:10:04 <Bish> gc isn't tunable in RTS of GHC
03:10:05 <m0ar> Bish: Check out the C-comparision-post i linked earlier as well :)
03:10:24 <Bish> m0ar: did, but that one is too complicated for me
03:10:26 <m0ar> Bish: Yes it is; you can set quite a few parameters :)
03:10:42 <tdammers> hvr: thanks!
03:10:51 <ertes-w> Bish: just to give you actual numbers: in a benchmark i ran a few years ago on my own AFRP framework (the now obsolete netwire) on an i5 the basic abstraction delivered 300 MFPS
03:10:52 <Bish> m0ar: i c
03:11:21 <ertes-w> Bish: that's almost as fast as the "main loop" approach
03:11:47 <Bish> so in theory, a triple-AAA title in haskell is possible with reasonable performance?
03:11:48 <hvr> tdammers: unfortunately, he then joined Oculus... and afaik didn't pursue FP further
03:11:51 <Bish> i know it's a stupid question
03:12:09 <Bish> and the code would be haskell-ish, not full of hacks
03:12:27 <ertes-w> Bish: we don't know…  nobody has explored that yet
03:12:35 <Bish> well.. theory
03:12:53 <ertes-w> Bish: but i think it would be possible, if you're careful about GC
03:13:04 <ertes-w> again: most computation would happen on the GPU anyway
03:13:16 <Bish> i mean if you watch videos of modern engines, it looks like people don't write code either way.. it always looks like they're writing graphs
03:13:19 <Bish> creating*
03:13:46 <tdammers> same thing :x
03:14:09 <Bish> yeah i know, but it has a high level of abstraction
03:14:18 <Bish> which would imply it being slower than "real" code
03:14:28 <Bish> which would be an argument why haskell could be as fast
03:14:39 <Bish> in AAA-game titles
03:14:54 <tdammers> GHC goes through great lengths to make those abstractions as cheap as possible, often zero-overhead
03:14:55 <AndreasPK> Well when you say writing an AAA game I would assume you mean from top to bottom, including the engine
03:15:06 <Bish> AndreasPK: i was thinking that right now, too
03:15:16 <tdammers> ultimately though, "how fast can I make it go given infinite effort" is not an awfully interesting question
03:15:29 <tdammers> the real question is, "how much effort does it take to make it go fast enough"
03:15:48 <ertes-w> also you can scratch the "AAA" part
03:15:50 <Bish> yeah i know that question was stupid.. but it helped me understand the limits or if there are any
03:16:10 <Bish> ertes-w: i just had that AAA so you know what i mean.. crazy gfx
03:16:24 <Bish> openworld something stuff
03:16:28 <Bish> i don't game alot
03:17:29 <AndreasPK> Must AAA games are built on bought engines and the studios don't bother that much with the low level stuff as I understand it
03:17:31 <ertes-w> well, actually AAA games would benefit from haskell…  since haskell is so refactoring-friendly it would be much easier to retrofit microtransactions
03:17:38 <AndreasPK> lol
03:18:33 <Bish> im thinking the same, games in future will be more complex.. like everything else
03:18:44 <phadej> AAA game probably isn't written in one language
03:18:46 <Bish> expressing a game as a set of rules sound more reasonable to the realistic approach
03:18:47 <AndreasPK> But using Haskell as a scripting/customization language for a engine I imagine would be uncontroversial. After all there are companies using pythong fo similar things .
03:18:55 <tdammers> ertes-w: also, would somebody please think of the cryptocurrencies
03:19:01 <Bish> pythong
03:19:01 <phadej> and it's fine to have "game logic" in Haskell and GFX engine in C++
03:19:03 <Bish> what a funny name
03:19:08 <phadej> even today
03:19:31 <AndreasPK> Bish: It's what hapeens when a python makes love to a g
03:22:28 <Bish> thanks for the conversation
03:22:49 <Bish> usually irc people tend to treat my stupid questions differently
03:33:25 <infinisil> I hope for linear types to eventually take over so we can use haskell for fast & memory-constrained low level stuff
03:34:33 <infinisil> (or any functional language with linear types, Idris has them to some extent already)
03:38:02 <[exa]> infinisil: /me working on one
03:56:25 <merijn> infinisil: linear types and rowtype polymorphism!
03:56:55 <infinisil> no idea about rowtype polymorphism but it sounds interesting
03:57:41 <merijn> infinisil: Are you familiar with structural subtyping?
04:01:05 <infinisil> merijn: more or less
04:04:26 <ertes-w> Bish: that reminds me…  linear types are coming to haskell, which will solve some of the GC issues
04:07:28 <reactormonk> With tasty / hedgehog, is there a nice "logging" statement where I can put the currently generated value, so in case the test fails, it'll display that value?
04:09:32 <gb_master> hello, is there a way to compile GHC without having LLVM installed?
04:10:39 <Guest34050> !search ansys
04:11:35 <AndreasPK> gb_master: On x86/amd64 it doesn't require llvm by default
04:12:01 <Cale> gb_master: I thought you only needed LLVM installed if you want -fllvm to work
04:12:47 <gb_master> I'm on ARM, but it complains at the beginning about the absence of opt and llc
04:14:05 <Cale> ah, I wonder if LLVM is being relied on more fully for ARM codegen now.
04:14:45 <gb_master> no idea
04:15:33 <[exa]> merijn: wait what is rowtype polymorphism?
04:16:45 <Axman6> I thought I read the other day that LLVM was the only way to do ARM codegen, but I might be wrong
04:16:50 <cheater> is there a thing like quickcheck that will test the statistical properties of my code?
04:17:09 <Axman6> statistical properties of your code?
04:17:30 <gb_master> Axman6: it might very well be, of course :)
04:18:19 <gb_master> it's just that I read that LLVM is an optional dependency, but it's actually failing on my ARM machine because it's not installed. hence my question
04:18:47 <Cale> gb_master: Yeah, it *usually* is, but when it comes to weird platforms, who knows. :)
04:18:55 <gb_master> hehe
04:19:14 <gb_master> Cale, Axman6, AndreasPK:  thank you very much for the clarification :)
04:19:52 <Cale> There's an already built linux ARM binary for GHC here: https://www.haskell.org/ghc/download_ghc_8_2_2.html#linux_armv7
04:19:57 <Cale> But it apparently requires LLVM
04:20:25 <Cale> (also gold)
04:20:54 <infinisil> [exa]: Google for Row Polymorphism
04:28:08 <[exa]> infinisil: set-containing variables yay!
04:30:20 <[exa]> infinisil: anyway, isn't row polymorphism subsumed by having a typeclass like `HasX' for each record field name `x' ? (minus some unwieldy syntax that can get sugarified)
04:33:56 <infinisil> i have no idea about all of this
04:34:25 <[exa]> ok nevermind :]
04:35:33 <wz1000> 333,p
04:36:57 <padre_angolano> coursera is offering master of computer science (for those who still don't have it) in data science (University of Illinois)
04:39:20 <padre_angolano> $19,200
04:40:29 <m0ar> infinisil: linear types are pretty useable already :)
04:45:57 <Philonous> m0ar, In Haskell?
04:52:43 <m0ar> Philonous: Yes! I've done a writeup here on how to get it running, there is a GHC fork with the extension activated: https://github.com/tweag/ghc/tree/linear-types
04:53:18 <m0ar> Worked with it in a practical project through Summer of Code, and helped Tweag with this and that meanwhile (like this documentation)
04:54:42 <m0ar> If you find it interesting I can plug the tech blog I wrote during the project as well: https://m0ar.github.io/safe-streaming/
04:57:52 <Philonous> Oh right, the GHC fork, but last I checked there was resistance against merging it into HEAD, is there any progress?
04:59:17 <m0ar> Philonous: I think it's still a bit down the line, apart from people having to settle on specifics there is AFAIK still a few naughty bugs that need resolution :)
05:00:34 <Philonous> In any case, it's great to see it's being worked on. Together with -XDependentHaskell this could make 2018 one hell of a year for GHC. :)
05:01:08 <m0ar> Indeed :)
05:03:55 <tabaqui> what extension is more readable for you: GADTs or TypeFamilies?
05:04:04 <tabaqui> Looks like they do the same job
05:04:17 <lyxia> not at all
05:04:44 <tabaqui> I already know GADT's but faced recently with lack of flexibility
05:04:52 <tabaqui> lyxia: what do you use then?
05:05:20 <lyxia> both
05:05:38 <mniip> yup
05:05:44 <mniip> they achieve different things
05:06:58 <tabaqui> at first sight, they are interchangeable
05:08:20 <mniip> % :set -XNOGADTs
05:08:20 <yahb> mniip: Some flags have not been recognized: -XNOGADTs
05:08:25 <mniip> % :set -XNoGADTs
05:08:25 <yahb> mniip:
05:08:41 <lyxia> Are you referring to the fact that both are mentioned by GHC to use the ~ syntax?
05:08:59 <lyxia> both extensions do so much more...
05:09:03 <mniip> % data Foo where Foo :: Foo
05:09:03 <yahb> mniip: ; <interactive>:13:1: error:; * Illegal generalised algebraic data declaration for `Foo'; (Enable the GADTs extension to allow this); * In the data declaration for `Foo'
05:09:14 <mniip> % :set -XGADTs -XNoTypeFamilies
05:09:14 <yahb> mniip:
05:09:25 <mniip> % type family Foo a
05:09:25 <yahb> mniip: ; <interactive>:16:1: error:; * Illegal family declaration for `Foo' Enable TypeFamilies to allow indexed type families; * In the type family declaration for `Foo'
05:09:42 <phadej> FWIW there was discussion to have LANGUAGE EqualityConstraints or such
05:09:54 <phadej> because they are useful even if you don't use GADTs or TypeFamilies
05:10:16 <phadej> though... at the point you have EqualityConstraints you have GADTs too (without syntax though)
05:12:07 <Bish> can someone give me a good example to FRP? i read some things about it, and can't really grasp it
05:12:24 <Bish> http://blog.reactiveprogramming.org/ this helps though
05:12:32 <Bish> define('WP_USE_THEMES', true); lol.
05:12:36 <phadej> % data Foo a = MkFoo (a ~ Int => Bool) -- data Foo a where MkFoo :: Bool -> Foo Int
05:12:36 <yahb> phadej:
05:21:05 <ertes-w> Bish: it's kinda difficult to find meaningful examples of FRP, but watch the videos of ryan trinkle, the main author of the reflex library
05:22:23 <__monty__> Does ndmitchell hang around here?
05:23:17 <ertes-w> Bish: also heinrich apfelmus, the main author of reactive-banana, has a blog on FRP with lots of information
05:23:27 <Bish> that project name
05:23:29 <Bish> that last name
05:23:43 <ertes-w> heh
05:24:11 <ertes-w> Bish: and don't worry about reading library-specific information about FRP…  between real FRP libraries information can easily be transferred
05:33:40 <Bish> 3 Fake Testimonials
05:33:42 <Bish> dat project
05:44:45 <quchen> Does anyone have ι expressed only using SKI handy?
05:45:02 <quchen> ι = λ f. ((f S) K)
05:45:26 <quchen> That’s the definition I found, but it’s an awkward hybrid between lambda calculus and SKI
05:48:10 <TMA> quchen: https://gist.github.com/shangaslammi/3438688 gives  i = s k k
05:52:55 <ertes-w> λ f. (f S) K = S (S I (K S)) (K K)
05:52:59 <ertes-w> quchen: ^
05:53:29 <ertes-w> alternatively:
05:53:56 <ertes-w> @pl \f -> f s k
05:53:56 <lambdabot> flip ($ s) k
05:54:06 <ertes-w> ok, ignore that
05:55:44 <mniip> TMA, that's the wrong i
05:56:14 <ertes-w> quchen: \f -> f (<*>) pure = id <*> pure (<*>) <*> pure k
05:56:21 <int-e> mniip: in what sense?
05:56:22 <ertes-w> which is the same as above, except infix
05:56:41 <ertes-w> and replace 'k' by 'pure' there =)
05:56:55 <ertes-w> id <*> pure (<*>) <*> pure pure
05:57:22 <ertes-w> or if you want to go all the way:
05:57:40 <ertes-w> pure <*> pure <*> pure (<*>) <*> pure pure
05:58:20 <int-e> @check \x -> ap const const x == id (x :: Int)
05:58:23 <lambdabot>  +++ OK, passed 100 tests.
05:59:38 <ertes-w> :t \f -> f (\g h x -> g x (h x)) const
05:59:41 <lambdabot> (((t1 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t3) -> (a -> b -> a) -> t4) -> t4
05:59:57 <ertes-w> :t pure <*> pure <*> pure (<*>) <*> pure pure :: (((t1 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t3) -> (a -> b -> a) -> t4) -> t4
05:59:59 <lambdabot> error:
05:59:59 <lambdabot>     • Ambiguous type variable ‘f0’ arising from a use of ‘pure’
05:59:59 <lambdabot>       prevents the constraint ‘(Applicative f0)’ from being solved.
06:00:27 <jchia_> geekosaur: Are you online? I think I just encountered a manifestation of https://github.com/haskell/process/issues/50. My C++ subprocess opens a file, and writes to the file as well as stdout (using cout). The content meant for cout got written to the file in addition to whatever else the C++ program tried to write to the file.
06:01:09 <ertes-w> :t let { (f <*> g) x = f x (g x); pure = const } in pure <*> pure <*> pure (<*>) <*> pure pure
06:01:11 <lambdabot> (((t1 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t3) -> (a -> b -> a) -> t4) -> t4
06:01:17 <jchia_> I think because stdout is closed, the file handle normally assigned to stdout got assigned to the file it opened.
06:01:27 <merijn> jchia_: Simple solution is to not use NoStream
06:01:58 <jchia_> merijn: How to drop the output?
06:02:25 <merijn> jchia_: Manually open /dev/null and specify UseHandle
06:02:45 <merijn> rats...
06:03:06 <merijn> Code that works perfectly fine when called by myself magically fails when run from my Haskell process :(
06:04:20 <mniip> iota is tricky to represent in haskell
06:04:27 <mniip> % i :: (((a1 -> b -> c) -> (a2 -> b) -> a1 -> c) -> (d -> e -> d) -> r) -> r; i = unsafeCoerce $ \v -> v (\f g x -> f x (g x)) (\x y -> x)
06:04:27 <yahb> mniip:
06:04:43 <mniip> % :t i (i (i i))
06:04:43 <yahb> mniip: d -> e -> d
06:04:47 <mniip> % :t i (i (i (i i)))
06:04:47 <yahb> mniip: (a1 -> b -> c) -> (a2 -> b) -> a1 -> c
06:05:07 <mniip> (in untyped lambda calculus, the two x in 'f x (g x)' can be at different types)
06:06:15 <mniip> % i (i (i i)) 3 5
06:06:15 <yahb> mniip: 3
06:06:22 <mniip> see it doesn't even crash
06:18:02 <quchen> ertes-w: Thanks :-)
06:18:15 <quchen> ertes-w: Do you have a λ-to-SK converter or something?
06:18:24 <ertes-w> quchen: no, i did it by hand
06:18:34 <quchen> Oo
06:19:07 <ertes-w> quchen: it's fairly simple:  \f -> X Y = S (\f -> X) (\f -> Y)
06:19:19 <ertes-w> repeat until no longer possible
06:19:39 <quchen> Huh? Doesn’t abstraction have 3 different cases for conversion to SKI?
06:19:48 <ertes-w> then (or at the same time) replace all (\x -> x) by I and all (\x -> y), where x ≠ y, by (K y)
06:20:19 <ertes-w> ^ yeah, those three =)
06:20:28 <int-e> and as an optimization do eta contraction, \x -> M x --> M (if x is not free in M)
06:22:11 <quchen> ertes-w: How does that relate to the »T« algorithm on Wikipedia that seems to have 6 rules? https://en.wikipedia.org/wiki/Combinatory_logic#Completeness_of_the_S-K_basis
06:22:32 <quchen> Aaaaaaaaaaaaaah
06:22:51 <quchen> Well, 3 of those 6 rules act on abstractions. I have an abstraction.
06:23:16 <ertes-w> quchen: T also encodes the actual traversal of the AST
06:23:27 <ertes-w> check rule 2, for example
06:23:27 <quchen> 4, even. Anyway, they’re probably a subset and I’ll just believe you by argument of authority.
06:23:55 <ertes-w> in other words, whereas my description is just a scheme, T is an actual algorithm =)
06:24:04 <quchen> I’m looking for rule 5 in your scheme
06:24:09 <quchen> Where is it contained?
06:24:19 <mniip> I would often do SKI by hand
06:24:24 <mniip> I mean I always pointfree by hand
06:25:21 <ertes-w> quchen: rules 3 and 5 complement each other
06:25:32 <ertes-w> they cover traversal into lambdas
06:26:44 <quchen> Right. It starts making sense.
06:26:56 <quchen> I should probably just implement it and everything is clear then.
06:27:20 <ertes-w> quchen: usually to avoid this kind of complexity you would traverse bottom-up
06:27:38 <Brian01> Hi guys!
06:27:57 <ertes-w> quchen: it doesn't add more complexity either, because checking whether a variable is free requires deep traversal anyway
06:27:58 <Brian01> I'm looking on a tutorial on processing mouse events in haskell sdl2 bindings
06:28:07 <Brian01> I found this so far:
06:28:07 <Brian01> https://github.com/palf/haskell-sdl2-examples/blob/master/examples/lesson17/src/Lesson17.hs
06:28:17 <Brian01> Is there anything else? blog posts?
06:28:19 <ertes-w> Brian01: are you familiar with general event processing in sdl2?
06:28:32 <Brian01> ertes-w: not really.
06:29:29 <ertes-w> Brian01: once you have all resources (windows, renderers, etc.) established you go into the main loop, where you use 'pollEvent' or 'waitEvent'
06:30:00 <Brian01> I would need to process the mouse position while the 'left mouse button' is down.
06:30:59 <Brian01> I'm going through this:
06:31:00 <Brian01> https://hackage.haskell.org/package/sdl2-2.3.0/docs/SDL-Event.html
06:31:16 <ertes-w> Brian01: yes, you receive an Event, which contains an EventPayload that you pattern-match on
06:31:46 <ertes-w> a MouseMotionEvent comes with a MouseMotionEventData
06:31:49 <ertes-w> https://hackage.haskell.org/package/sdl2-2.3.0/docs/SDL-Event.html#t:MouseMotionEventData
06:32:13 <ertes-w> mouseMotionEventState tells you which buttons are currently pressed
06:32:47 <Brian01> Thanks. And how do I get both 'MouseMotionEvent' and 'MouseButtonEvent'? Are there 2 events in the queue?
06:33:15 <ertes-w> Brian01: do you care about the button event?
06:33:43 <ertes-w> to answer your question: yes, they come separately
06:33:44 <Brian01> I could start with 'any button down'. I want to draw a polyline with the mouse
06:34:07 <Brian01> ertes-w: that 'separately' was what I was missing.
06:34:37 <Brian01> Okay, I think I have an idea on how to do this.
06:34:56 <ertes-w> Brian01: it's probably better then to ignore mouseMotionEventState and just handle the button and motion events separately, keeping track of the current button state
06:35:09 <Brian01> Okay, nice!
06:35:26 <Brian01> I mean I could also look at old 'sdl' code and port it to 'sdl2' as there will be little difference
06:35:53 <ertes-w> Brian01: the API differences between SDL and sdl2 are huge
06:36:12 <Brian01> okay, thanks! I didn't know that!
06:36:33 <Brian01> Is there a small game written in 'sdl2' haskell bindings?
06:36:38 <Brian01> Such as raindrops?
06:36:40 <ertes-w> while the event handling scheme hasn't changed much (still a main loop with event polling/waiting), the actual events and the overall API are very different, because SDL is an SDL 1.3 binding, whereas sdl2 is an SDL 2 binding
06:36:48 <Brian01> https://github.com/keera-studios/haskell-game-programming/tree/master/examples/raindrops
06:37:01 <Brian01> Okay, I understand.
06:38:45 <ertes-w> Brian01: i have a very very basic sdl2 example somewhere on lpaste, but it's heavily overengineered, because i'm using FRP (via reflex)
06:38:56 <ertes-w> it's not a game, just a little graphics demo
06:39:01 <ertes-w> let me see if i can find it
06:39:49 <Brian01> Okay, nice.
06:40:33 <ski> __monty__ : used to
06:41:07 <__monty__> ski: Then I guess I'll communicate through github. Thanks.
06:41:24 <ski> Last seen  : Oct 31 02:47:37 2017 (12w 2d 11h ago)
06:42:17 <ski> (hm, actually that may have been someone else)
06:44:31 <ertes-w> Brian01: https://gist.github.com/esoeylemez/b9be0918cace71051853402cf511b42c
06:46:08 <ertes-w> Brian01: the event loop starts at line 190
06:46:44 <ertes-w> if you're a haskell beginner, you better not look at it =)
06:47:12 * toby1851 is resisting the urge to rewrite this code that uses `Bool` to use `Maybe ()` instead :)
06:48:04 <AndreasK> You have strange urges
06:48:31 * hyperisco lives on the edge with  Either Void Void
06:48:35 <[exa]> Maybe void! Preposterous!
06:51:35 * ski . o O ( "when you demand into the void, the void demands you" )
06:54:07 <guillaum1> Is there a way to report error in template haskell with something more détailled than "error". If possible with the pretty color / caret introduced in 8.2?
06:55:36 <geekosaur> I think at present the only way user code can evoke a "proper" compile time error is the TypeError class... which seems like a bad fit here, although it depends on the actual use case
06:55:59 <toby1851> Data.Void isn't a joke, is it?
06:56:35 <ski> it's not a joke
06:56:41 <geekosaur> no, it's intended to be used when there is no value level information. which can come up when the real computation is at type level.
06:56:55 <geekosaur> or higher
06:57:05 <[exa]> toby1851: it's meant to be absurd
06:57:10 <ski> well, i would express it as "when there's a case missing", rather than "no information"
06:57:54 <ski> (since "no information", to me, leads thoughts to "zero bits of information", which would be what `()' (or `void' in C) describes)
07:00:18 <toby1851> ok, i sort of see what it is, after reading https://stackoverflow.com/questions/29953219/what-is-the-kind-of-void
07:00:25 <ski> (i agree the terminology related to this isn't that clear. e.g. the dissonance between having two (say binary) choices, so four alternatives, and having (say) three things to choose from. would the latter be having three choices ?)
07:00:29 <toby1851> is it something that you'd ever use practically?
07:00:49 <[exa]> toby1851: you might want to look at acme-* packages
07:01:14 <ski> yes, but not often
07:01:24 <[exa]> for some more general examples when a totaly unusuable thing comes handy
07:03:54 <geekosaur> I;d be hesitant to call acme packages "practically"
07:05:53 <hyperisco> you definitely use it when treating Haskell like a proof assistant
07:08:14 <ski> i had a simulation of processes, based on a monad, say `Action'. i then defined `type Process = Action Void', with `terminate :: Process' and `fork :: Process -> Process -> Process' to manage processes
07:09:09 <AWizzArd> let x = ((show i) :: L.ByteString)    doesn’t work for me. I tried Hoogle to find a function   Int -> ByteString
07:09:34 <ski> initially, i was using `Action ()' here, with liberal use of `undefined' (internally using a continuation monad). by using `Void', i was able to convince myself and the type-checker that these `undefined's were unnecessary, and thus would never have been triggered in execution
07:09:55 <hyperisco> AWizzArd, try looking for  String -> ByteString
07:10:24 <AWizzArd> hyperisco: oki, pack thx.
07:11:10 <merijn> Don't use pack to go "String -> ByteString"
07:11:12 <merijn> :(
07:11:19 <merijn> You're making baby Jesus cry
07:12:25 <hyperisco> hey Zeus
07:13:53 <AWizzArd> merijn: how would go from an Int to a lazy BS?
07:14:03 <Philonous> Is there a more direct way to encode a String into a ByteString as UTF8 than «Text.encodeUtf8 . Text.pack» ?
07:14:15 <cemerick> Is there a directive that will squelch missing-method warnings for a single instance?
07:14:17 <merijn> Philonous: Don't think so
07:14:43 <merijn> AWizzArd: What Philonous said. You explicitly encode from Text
07:15:12 <Philonous> AWizzArd, «show» is morally wrong here, but will work just fine, so «Text.encodeUTf8 . Text.pack . show»
07:15:30 <merijn> hmmm
07:15:43 <merijn> For some odd reason createProcess seems to lose half of my environment...
07:15:50 <AWizzArd> Philonous: will try that.
07:17:40 <Philonous> AWizzArd, You'll need «import qualified Data.Text as Text»  and import «qualified Data.Text.Encoding as Text»
07:17:55 <AWizzArd> Good.
07:18:11 <Philonous> Wait, you said lazy ByteString, then s/Data.Text/Data.Text.Lazy/g
07:22:08 <ertes-w> Philonous: https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Builder.html#v:stringUtf8
07:24:54 <parsnip> hmm, maybe my problem was `hakyll-init hakyll`.
07:25:22 <Philonous> Right! So «toLazyByteString . intDec» is the "morally correct" way to do it
07:25:27 <Philonous> AWizzArd, ^
07:25:36 <Philonous> Thanks ertes-w
07:25:49 <parsnip> how can we prevent dumb users from doing that?
07:26:37 * parsnip embarassed
07:28:16 <parsnip> this is the error that i took completely the wrong approach in troubleshooting, attempting to build hakyll with git clone or new-build: http://lpaste.net/361955
07:28:43 <parsnip> had trouble building, and in end turns out i just named my blog's directory badly.
07:53:08 <fiatjaf> I'm getting a "cabal not found" error on every stack command I try to run after a successful `stack setup` that installed ghcjs
07:53:15 <fiatjaf> http://lpaste.net/raw/361956
07:54:12 <fiatjaf> I' reproducing and will paste a bigger history of commands run here, but maybe someone knows what's happening already and can help me
07:57:07 <Tehnix> Hmm, what do people call the `~` in the signature `getArgs :: (MonadTrans t, MonadArguments m', m ~ t m') =&gt; m [Text]`? Having trouble google'ing it atm
07:57:21 <merijn> Tehnix: It means two types unify with eachother
07:57:33 <dmwit> It is more than just unification, it is equality.
07:57:36 <merijn> Tehnix: It's often called "type equality", but that's not quite right
07:58:07 <merijn> dmwit: "Foo a" unifies with "Foo Int" (assuming 'a' is free), but I wouldn't call those "equal"
07:58:21 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#equality-constraints
07:58:47 <dmwit> merijn: If `a` equals `Int`, then yes, I would call `Foo a` and `Foo Int` equal.
07:59:17 <dmwit> merijn: What's more, if `Foo` is injective, and you have `Foo a ~ Foo Int` in your context, then you can use `a` and `Int` interchangably in your type signature. Because they are equal.
07:59:53 <dmwit> > let f :: [a] ~ [Int] => a -> Int; f x = x in f 3
07:59:57 <lambdabot>  3
08:01:15 <Tehnix> dmwit: Are there any other valid interpretation of `Foo a` for `Foo a ~ Foo Int` than `Foo Int`?
08:01:34 <dmwit> Tehnix: Not if `Foo` is injective.
08:02:16 <dmwit> Tehnix: If `Foo` is a type family, there may be other values of `a` for which `Foo a` is also equal to `Foo Int`. But then they will both be equal to some third thing, too.
08:02:36 <dmwit> % type family Foo a
08:02:36 <yahb> dmwit: ; <interactive>:59:1: error:; * Illegal family declaration for `Foo' Enable TypeFamilies to allow indexed type families; * In the type family declaration for `Foo'
08:02:42 <dmwit> % :set -XTypeFamilies
08:02:42 <yahb> dmwit:
08:02:47 <dmwit> % type family Foo a
08:02:48 <yahb> dmwit:
08:02:56 <dmwit> % type instance Foo Int = Char
08:02:56 <yahb> dmwit:
08:02:58 <merijn> Tehnix: I think the main difference between dmwit and me is whether you treat the constraint is separate from the type or not
08:03:03 <dmwit> % type instance Foo [Char] = Char
08:03:03 <yahb> dmwit:
08:03:20 <merijn> Tehnix: Within the type signature "Foo a" must equal "Foo Int", else the constraint doesn't hold and it's a type error
08:03:30 <dmwit> % let x :: Foo Int ~ Foo [Char] => Int; x = 3 in x
08:03:30 <yahb> dmwit: 3
08:04:21 <geekosaur> the thung being, ghc does
08:04:28 <merijn> Tehnix: I always think of constrained types as "if constraint then type else type error"
08:04:35 <geekosaur> in the specific case of the constraint applying to a typeclass or instance thereof
08:04:45 <dmwit> And I think the difference is that merijn is wrong. When you pass evidence for a ~ constraint, you are passing a coercion between the two types as proof that they are equal. Unification doesn't come into it.
08:04:48 <merijn> Anyway, I think unification vs equality isn't very important distinction
08:06:10 <dmwit> You may use unification to learn *other* equalities.
08:08:25 <dmwit> Here is where the distinction lies, I think: if `a ~ b` *only* said that `a` and `b` unify, you would learn nothing, because variables always unify. But you learn more than nothing in Haskell; you learn that a value of type `a` may be used where a value of type `b` is expected (and vice versa), along with many other new facts.
08:08:34 <Tehnix> In the GHC User guide (linked earlier), they mention it is basically used in place of functional dependency, i.e. `class C a b | a -&gt; b`, which I took as "the type of a implies the type of b"
08:09:16 <geekosaur> mm, only half of it
08:09:20 <dmwit> Tehnix: Right. The standard rewrite of that is `class C a where type Foo a`. Then if you previously had `instance C A B` you would now have `instance C A where type Foo A = B`.
08:09:30 <geekosaur> that it is applied to a type family is the other half
08:11:41 <Tehnix> So in my original example `getArgs :: (MonadTrans t, MonadArguments m', m ~ t m') =&gt; m [Text]`, where `m` comes from a `Monad m` constraint on the typeclass, we are basically saying that the `m` in `m [Text]` unifies with `t m'`, meaning that `t m' [Text]` is valid?
08:14:12 <dmwit> Tehnix: yes
08:14:45 <dmwit> Tehnix: In fact, I find it a bit odd that it wasn't written that way.
08:14:54 <Tehnix> Okay, I think I'm somewhat starting to grok it then :slightly_smiling_face:
08:15:19 <dmwit> Tehnix: `getArgs :: (MonadTrans t, MonadArguments m') => t m' [Text]` seems strictly better as a type (in terms of human readability).
08:15:29 <Tehnix> dmwit: I think it might be more clear if I shared the full definition, which is
08:15:42 <ski> Tehnix : s/implies/functionally determines/ (as with Functional Dependencies in relational database theory, if you happen to know any of that)
08:15:44 <Tehnix> class Monad m =&gt; MonadArguments m where
08:15:45 <Tehnix>   getArgs :: m [Text]
08:15:45 <Tehnix>   default getArgs :: (MonadTrans t, MonadArguments m', m ~ t m') =&gt; m [Text]
08:15:45 <Tehnix>   getArgs = lift getArgs
08:16:29 <Tehnix> So the signature is then used for `instance MonadArguments m =&gt; MonadArguments (LoggingT m)` instances that use the default signature for `getArgs`
08:16:39 <ski> given the situation `C a b', and given a particular type for `a', there can be at most one type for `b', fitting this situation together
08:17:07 <dmwit> Hm. It's possible there's something odd going on with DefaultSignatures, but my a priori guess would be that the author assumed there would be a problem with the simpler signature but didn't actually test that fact.
08:17:57 <ski> (logically, the FD in `class C a b | a -> b' means `forall a. unique b. C a b', which is the same as `forall a b0 b1. (C a b0,C a b1) => b0 = b1'. another word for `unique' would be `exists_at_most_one')
08:18:06 <Tehnix> It indeed uses `DefaultSignatures`. Heh, I could perhaps have prempted some confusion with the full details first :slightly_smiling_face:
08:18:22 <lyxia> There is an odd rule with default signatures where the type of the default signature must match closely the original type
08:18:31 <Tehnix> For context, I'm trying to understand <https://github.com/osa1/mtl-style-example>
08:18:36 <fiatjaf> looking for a good soul that understands stack to help me figure out why cabal cannot be run after a `stack setup`: http://lpaste.net/6627182929124524032
08:18:41 <Tehnix> Wups, sorry, <https://github.com/lexi-lambda/mtl-style-example> was the one
08:19:02 <lyxia> For some definition of "closely" where "m [Text]" does not "match" "t m' [Text]".
08:19:05 <dmwit> Tehnix: No, no, it's obvious that it's using `DefaultSignatures`. I'm not saying "there's something funny, and it could be because of `DefaultSignatures`". I'm saying "there's `DefaultSignatures`, and also there could be something funny".
08:19:56 <dmwit> To distinguish between "`DefaultSignatures` explains what the funny thing is" and "perhaps `DefaultSignatures` has a bug". =P
08:20:06 <Tehnix> dmwit: ah ^_^
08:20:50 <lexi-lambda> The simpler signature works in older versions of GHC, but new GHCs require everything except the context be identical.
08:21:35 <sm> stack exec -- which cabal
08:21:51 <sm> oops
08:21:56 <dmwit> lexi-lambda: Odd. I wonder why.
08:22:05 <lyxia> lexi-lambda++ also see the manual https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#default-method-signatures
08:22:11 <sm> fiatjaf: does that ^ find it ?
08:22:16 <Tehnix> dmwit: I took it as a limitation from DefaultSignatures, that the free variables have to be the same
08:22:47 <lexi-lambda> dmwit: There's a trac ticket that explains the reasoning, but I can't stick around to find it right now.
08:22:52 <alexteves> wasn't there some prototype DB with ADT built-in ? It was called project31 or something, but I can't find it right now
08:23:18 <dmwit> lexi-lambda: Thanks for the pointer. I'll find it myself. Cheers!
08:24:16 <Tehnix> lexi-lambda: <https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/8.0.2-notes.html> they mention "Some programs using -XDefaultSignatures that incorrectly type-checked in GHC 8.0.1 are now rejected by GHC 8.0.2. Here is a characteristic example" and give an example of using the equality constraints that you used
08:24:51 <Tehnix> dmwit: ^ guess that was more for you actually
08:25:15 <Tehnix> And the trac ticket <https://ghc.haskell.org/trac/ghc/ticket/12784>
08:27:30 <reactormonk> I've got two records of the same type, with lenses on the fields. How can I copy two of these fields from one article ot the other one?
08:27:34 <cemerick_> I'm trying to define a record type with class-constrained members, starting with this "concrete" type:
08:27:34 <cemerick_> data Point = Point { px :: Int, py :: Int } deriving Show
08:28:08 <dmwit> Tehnix: I find the motivation for this restriction in the ticket *extremely* underwhelming.
08:28:22 <dmwit> This was, in my opinion, the wrong fix.
08:28:26 <cemerick_> The GADT equivalent (generalizing to Num, for example) produces insufficient-argument errors anywhere Point is used though
08:28:57 <dmwit> Tehnix: Oh, I'm looking at ticket 12918, a different one. Maybe yours is better, let me see.
08:28:58 <cemerick_> e.g. data Point x y where Point :: (Num a) => { px :: a, py :: a } -> Point x y
08:29:44 <cemerick_> where am I fouling up that GADT definition?
08:30:20 <merijn> cemerick_: That's... a weird definition of point...
08:30:29 <cemerick_> hah
08:30:31 <cemerick_> perhaps!
08:30:33 <merijn> cemerick_: Are you sure that shouldn't be "Point a a"?
08:31:04 <merijn> cemerick_: Right now you're basically saying Point takes 2 numbers and then has two type arguments completely unrelated to either of those?
08:32:01 <merijn> cemerick_: I wouldn't call the GADT a generalised version of your ADT at all, tbh. And you could just as easily use a regular ADT to generalise Point
08:32:25 <merijn> i.e., what's wrong with "data Point a = Point { px :: a, py :: a } deriving Show"?
08:33:34 <merijn> cemerick_: Also, class-constrained fields in a record almost universally a terrible idea (with the exception of RankN types)
08:33:35 <cemerick_> merijn: leaving aside my tripping over GADTs, that last suggestion has the same outcome
08:33:43 <dmwit> Tehnix: In my opinion, the correct fix would give an occurs check error for the examples they keep giving as motivating examples, and give no error for the version that gives a fresh name to the wrapped monad.
08:33:49 <merijn> cemerick_: Same outcome when doing what?
08:34:36 <dmwit> Tehnix: e.g. `class Monad m => MonadFoo m where foo :: m Int; default foo :: (MonadTrans t, MonadFoo m) => t m Int` should say that it can't solve `m ~ t m`.
08:35:01 <dmwit> Tehnix: While `class Monad m => MonadFoo m where foo :: m Int; default foo :: (MonadTrans t, MonadFoo m') => t m' Int` should be perfectly fine.
08:35:41 <dmwit> So I would indeed consider this a bug in DefaultSignatures. =P
08:35:53 <reactormonk> Any way to shorten (set foo (view foo x) y) (lenses)
08:35:55 <fiatjaf> which kind of computer do I need to have to be happy with haskell?
08:36:07 <dmwit> Which lexi-lambda and others have cleverly worked around.
08:36:22 <fiatjaf> every time I try to do something my computer is too old, too slow, compiling takes lots of time
08:36:31 <fiatjaf> what are you using?
08:36:35 <dmwit> fiatjaf: x86_64 with Linux and a few gigs of RAM
08:36:38 <sm> fiatjaf: one with at least 2G of ram
08:36:42 <fiatjaf> gigs?
08:36:58 <cemerick_> merijn: an error, "expecting one more argument to Point, Expected a type, but Point has kind `* -> *'
08:37:01 <fiatjaf> I have 4GB
08:37:11 <dmwit> reactormonk: yes, definitely
08:37:16 <fiatjaf> (I don't know what is my processor)
08:37:20 <merijn> cemerick_: Well, yeah, Point requires a type argument
08:37:24 <sm> sounds fine
08:37:30 <dmwit> reactormonk: wait
08:37:42 <sm> fiatjaf: did you see my comment above ? does "stack exec -- which cabal" find it ?
08:37:49 <fiatjaf> I'm on a x86-_64 linux
08:37:52 <merijn> cemerick_: You need to do something like "Point a" or "Point Int", etc.
08:37:52 <dmwit> reactormonk: Are you sure that's the code you mean to ask about? It looks a bit odd to me.
08:37:55 <dmwit> :t set
08:37:57 <lambdabot> ASetter s t a b -> b -> s -> t
08:38:19 <cemerick_> merijn: It's not much of a generalization if I need to ground the type terms on every usage though?
08:38:24 <fiatjaf> sm: sorry, I hadn't seen it
08:38:35 <merijn> cemerick_: What's wroing with using "Point a"?
08:38:40 <dmwit> reactormonk: It looks odd because you are reaching under `foo`, then reaching under `foo` again. Is that really right?
08:38:45 <reactormonk> dmwit, set <lens> <obj> <record>
08:39:09 <dmwit> reactormonk: (But then not modifying the outer container.)
08:39:12 <reactormonk> dmwit, yeah, x and y. Copy foo from x to y (or the other way)
08:39:18 <merijn> cemerick_: "translate :: Num a => Point a -> Int -> Point a" (or "Point a -> a -> Point a", or whatever)
08:39:30 <dmwit> reactormonk: Ah, right!
08:39:54 <merijn> Anyway, time to go home
08:39:58 <dmwit> reactormonk: Okay, now I've understood enough to know I don't know the answer. =P
08:40:09 <fiatjaf> sm: but any stack command was failing with the same error. I guess that one would fail too. I tried a bunch of other `stack exec` and they didn't even try to exec anything, just failed looking for cabal and that was it.
08:40:15 <cemerick_> merijn: ACH, thank you, I thought the error was complaining about the usage, not the signatures
08:40:17 <fiatjaf> sm: I ended up installing cabal-install with apt
08:40:38 <fiatjaf> then things are apparently working (but isn't it frustrating?)
08:40:48 <sm> fiatjaf: it's very quick to enter that command and report what happens. That helps when you're trying to get people to help you
08:41:05 <sm> your situation is unusual, so some tests are required
08:41:13 <fiatjaf> sm: I can't do it anymore since now I've installed cabal through other means
08:41:24 <fiatjaf> sm: that's what I was trying to say.
08:41:31 <fiatjaf> I was running `stack build` on my project now, it was taking a loooong time
08:41:55 <sm> I don't understand, but it sounds like you're on another path now so ok
08:41:55 <fiatjaf> then I opened another window and run `stack exec -- which cabal`
08:42:26 <fiatjaf> the `stack build` process stopped on the window it was running
08:42:48 <fiatjaf> and started again where I ran `stack exec -- which cabal`
08:42:53 <sm> uh..
08:43:08 <fiatjaf> (same directory)
08:43:38 <sm> running one stack command should not interrupt another
08:44:19 <fiatjaf> maybe it's a feature of stack 1.7?
08:44:42 <sm> do you have stack 1.7 ?
08:44:44 <fiatjaf> I guess that's an unreleased version, which I had to install yesterday when trying to build ghcjs
08:44:58 <fiatjaf> stack upgrade --git installs it
08:45:33 <fiatjaf> (it's ok for you to give up if my situation is too odd and horrible, thank you very much for trying to help me)
08:46:47 <fiatjaf> I like the fact that stack is honest and says "Booting GHCJS (this will take a long time) ..."
08:47:35 <sm> sounds like you're unstuck, so that's good :)
08:48:09 <fiatjaf> hahah, yeah, that seems to be it now.
08:48:14 <fiatjaf> thank you, and sorry for the confusion.
08:48:44 <sm> don't forget to call on the GHCJS devs too, it is known to be tricky to set up and few people here have done it
08:49:12 <dmwit> reactormonk: I mean, there's infix syntax that you might prefer. But I don't know of a way to mention `foo` only once.
08:49:32 <dmwit> reactormonk: namely, `y & foo .~ (x ^. foo)`
08:49:37 <fiatjaf> oh, didn't know they had a channel! I'll ask them the next time I have a problem.
08:49:53 <sm> and/or their issue tracker
08:50:09 <sm> if it's painful to set up, you should pass that on to them :)
08:54:17 <Welkin> I have never successfully set up ghcjs except through nix using reflex-platform
08:58:40 <cemerick_> thanks, irc <3 https://twitter.com/cemerick/status/956571594251558912
09:23:00 <ixxie> so I am a beginner playing with a toy IRC bot project based on the tutorial in the wiki; somehow this bit https://pastebin.com/AYZvd7ZD has a bug that makes the bot wait until the next ping/pong until running eval on any other commands
09:26:36 <swiggydib> Free Monads or Monad Transformers?
09:28:19 <int-e> ixxie: some problem with flushing the handle maybe; I don't think that the problem is in the code that you pasted
09:29:13 <sim590> Can I use ternary operator equivalent in plain haskell? I'm writing the implementation of `filter` function: http://paste.debian.net/1007172/. See where I have placed the expression (func x ? x : []), I'd likee to have a ternary operator equivalent.
09:29:23 <sim590> What's the haskell method?
09:29:33 <insanitea> sim590: bool
09:29:52 <insanitea> sim590: Data.Bool.bool
09:30:26 <insanitea> > Data.Bool.bool
09:30:32 <lambdabot>  error:
09:30:32 <lambdabot>      • No instance for (Typeable a0)
09:30:32 <lambdabot>          arising from a use of ‘show_M408801424666689377024856’
09:30:46 <insanitea> :t Data.Bool.bool
09:30:49 <lambdabot> a -> a -> Bool -> a
09:31:41 <insanitea> sim590: or you can use if then else construct there
09:32:26 <insanitea> filter' func (x:xs) = (if func x then (x :) else id) (filter' x)
09:32:29 <sim590> I tried this: filter' func (x:xs) = (if func x then x else []) : filter' x
09:32:45 <sim590> oh
09:32:54 <sim590> what's id?
09:33:04 <insanitea> sim590: whay you did is kinda invalid
09:33:07 <insanitea> :t id
09:33:08 <lambdabot> a -> a
09:33:11 <ski> @src id
09:33:11 <lambdabot> id x = x
09:33:30 <insanitea> ski++
09:34:46 <ertes-w> sim590: do you see that the whole 'if'-expression is a function?
09:34:46 <ski> sim590 : you'd need to use `++', then
09:35:16 <ertes-w> and insanitea is applying that function to (filter' x)
09:36:31 <sim590> I'm a bit fuzzed out (if that's an expression)
09:36:46 <ertes-w> > (if True then (2 +) else (5 *)) 10
09:36:47 <sim590> I tried this now: http://paste.debian.net/1007176/
09:36:51 <lambdabot>  12
09:36:53 <ertes-w> > (if False then (2 +) else (5 *)) 10
09:36:57 <lambdabot>  50
09:37:04 <hyperisco> sim590, you just invented it!
09:37:05 <ertes-w> sim590: ^ does this make sense to you?
09:37:20 <sim590> ertes-w: yes. i see what's going on
09:37:28 <sim590> hyperisco: :D
09:37:40 <ertes-w> sim590: insanitea is using exactly that pattern
09:37:54 <sim590> Okay. I understand the expression.
09:38:11 <ertes-w> (x :) is the function that prepends the element 'x' to its argument list
09:38:19 <ertes-w> 'id' is the function that returns the list unchanged
09:38:39 <sim590> But I get: http://paste.debian.net/1007178/
09:38:58 <sim590> ertes-w: Yeah, I got it now, but it doesn't work ? :/
09:39:21 <ertes-w> sim590: well, there is at least one mistake in their code =)
09:40:12 <ertes-w> sim590: filter' takes two arguments, but both of you are giving it only one
09:40:42 <sim590> One error was my fault. I did append `filter' func x` instead of `filter' func xs` at the end.
09:41:02 <ertes-w> the latter is correct
09:41:05 <ski> and the other error ?
09:41:22 <ski> can you figure out what it's attempting to point out for you ?
09:46:21 <sim590> I honestly don't understand the error here: http://paste.debian.net/1007184/
09:48:02 <ski> sim590 : why could it be talking about the type `Bool', do you think ?
09:48:22 <ski> how's `Bool' connected to what you you're doing here ?
09:49:51 <sim590> That's the "if then else" statement
09:49:53 <sim590> but...
09:49:57 <ski> ok
09:50:04 <ski> how's `Bool' connected to that ?
09:50:21 <sim590> The evaluation of (func x) should return a bool
09:50:22 <ski> (also, fwiw, it's an expression, not a statement)
09:50:25 <ski> ok
09:50:28 <ski> does it ?
09:50:51 <sim590> Nope.
09:50:57 <ski> why not ?
09:52:04 <sim590> I changed that. It's an error in my professor's énoncé.
09:52:14 <ski> you changed what to what ?
09:52:19 <Welkin> enonce?
09:55:11 <jcp19> hey there
09:55:12 <sim590> Welkin: I don't know the word in english. Look up énoncé in french.
09:55:28 <jcp19> I've been using the maximum function in prelude
09:55:35 <sim590> ski: I changed filter' :: (a -> b) -> [a] -> [b] to filter' :: (a -> Bool) -> [a] -> [b]
09:55:55 <ski> ok, that's better
09:56:23 <jcp19> and there's some strange behaviour. maximum (16,9) gives me 9. Is it the expected behaviour?
09:56:45 <sm> heh
09:56:45 <Welkin> :t maximum
09:56:46 <ski> it claiming `b' was "rigid", and thus not matching `Bool', has to do that, from the POV of this function, the type variables `a' and `b' are *unknown*
09:56:48 <lambdabot> (Ord a, Foldable t) => t a -> a
09:57:06 <Welkin> jcp19: the foldable instance of tuple is not what you think
09:57:18 <sim590> ski: Now the error is http://paste.debian.net/1007194/.
09:57:20 <Welkin> a tuple is treated as a key-value pair in most of these cases
09:57:29 <ski> sim590 : the caller decides what `a' and `b' should be. so the callee, your function implementation, can't expect `b' to always be picked as `Bool' by the caller, and so `b' doesn't match `Bool'
09:57:30 <Welkin> so the result you are getting is correct
09:57:48 <jcp19> Now I get it! Thank you very much :)
09:57:48 <Welkin> only the values are considered, and the only value is 9, so that is the maximum
09:57:48 <ski> sim590 : now the remaining error is of a similar nature as this, except now not involving `Bool'
09:58:01 <sim590> ski: My code is still http://paste.debian.net/1007196/
09:58:07 <ski> sim590 : so .. you should probably try to understand the point about "rigid" i was trying to make above ^
09:58:15 <Welkin> > maximum [16,9]
09:58:18 <lambdabot>  16
09:58:19 <Welkin> that is what you want
09:58:31 <jcp19> \welkin++
09:58:39 <jcp19> sorry, I'm noob xD
09:58:43 <sim590> ski: Yeah. I don,t understand what "rigid" stands for in this context. I'm looking for a description.
09:59:04 <ski> sim590 : how much sense does my description above make to you ?
09:59:14 <Welkin> jcp19: that ones trips up a lot of people
10:00:08 <ixxie> int-e: yeah I think I found it and it aint there, thanks
10:00:08 <ski> > 16 `max` 9  -- jcp19
10:00:11 <lambdabot>  16
10:00:20 <ski> > max 16 9  -- also
10:00:24 <lambdabot>  16
10:00:40 <Welkin> although `max` only compares 2 values
10:00:40 <sim590> ski: Oh ok. I can't do lists of [a, b, a, b, ...]
10:00:48 <sim590> That's what I,m doing I guess.
10:01:00 <ski> sim590 : `maximum' takes a list. `max' takes two operands
10:01:21 <ski> .. er, sorry, for some reason i thought jcp19 was asking that
10:01:36 <ski> sim590 : no, all elements in a list must have the same type
10:01:54 <sim590> I saw that there's another error
10:02:25 <ski> you have a list of `a's as input .. and you say that you'll turn these into a list of `b's -- where `a' and `b' are picked by the caller
10:03:10 <sim590> ski: that was my profs fault :p I'm fixing this. The signature is not good. I should be : filter' :: (a -> Bool) -> [a] -> [a]
10:03:19 <ski> correct :)
10:03:32 <ski> your prof accidentally supplied the type of `map'
10:03:36 <Welkin> being forced to write the definition for a predefined type signature is never fun
10:04:30 <insanitea> Welkin: I disagree :-)
10:05:08 <ski> sim590 : so .. when it complains about a rigid type variable not matching something else, it means that the callee can't guarantee that the caller will pick that type variable as the something else .. in this error, it means that the callee can't expect that the caller will pick `a' and `b' to be the same type
10:05:50 <ski> sim590 : and, since you *were* returning (some of) the input elements in the output list, that implementation did rely of the input element type and the output element type being the same type
10:06:12 <ski> sim590 : makes any sense ?
10:06:21 <humanoyd> > /quit
10:06:24 <lambdabot>  <hint>:1:1: error: parse error on input ‘/’
10:09:14 <sim590> ski: Yes! He did supply the type of map.
10:11:44 <insanitea> prof--
10:12:15 <sim590> ski: Thanks for all your explanations!
10:12:20 <ski> np
10:13:49 <Welkin> non-polynomial?
10:14:04 <shivansh> Hello, haskell beginner here. I've written a simple function (http://lpaste.net/361964), where the beginning if condition and the final else condtion do the same operation. The approach is dirty, although is it possible to combine these two conditions? Thanks in advance!
10:14:32 <Welkin> shivansh: generally we do not use "if then else"
10:14:43 <Welkin> instead, we use pattern matching and guards
10:15:36 <shivansh> oic ; wasn't aware that we can use guards inside a lambda function
10:15:59 <ski> shivansh : you could use `||' .. but pattern-matching might still be more appropriate
10:16:06 <ski> you can attach guards to a `case'
10:16:18 <Welkin> when writing something like that, I tend to use a `let` or `where` to define the folding function, so then the top-level definition looks more like `foldl g []`
10:16:24 <Welkin> where `g` is your locally defined function
10:16:36 <Welkin> it's easier to read for longer definitions
10:16:52 <ski> and then `g' could be defined using pattern-matching, with multiple defining equations
10:16:59 <Welkin> also, you will want to use foldl' instead of foldl
10:17:04 <ski> (and guards, if you want to)
10:17:42 <Welkin> lamdbas are helpful for short definitions, but for more complex ones, give it a name
10:18:04 * ski doesn't always agree with that
10:18:14 <Welkin> unless you like your code to look like lisp
10:19:08 <ski> (however, if you don't do that, and your function literal is large, it's best if it's the last argument)
10:20:18 <shivansh> thanks Welkin ski ; those were very helpful pointers
10:20:20 * ski doesn't see the harm in some brackets, as long as it's properly indented
10:20:59 <Welkin> I agree that is is okay if it is the last parameter in your definition
10:21:06 <Welkin> but in this case, it makes it hard to read
10:21:30 <ski> nothing a `flip' can't fix ;)
10:21:53 <ski> (or a right section)
10:33:50 <shivansh> Welkin: ski does this look good - http://lpaste.net/diff/361965/361966
10:34:28 <ski> i would define `f' locally inside `unbalanced', in a `where'-clause
10:34:38 <shivansh> ah, right
10:35:07 <ski> did you see how i meant that you could use `||' to not have to repeat one of the possible results ?
10:35:19 <Welkin> you can use pattern matching and reduce it down to 2 cases
10:35:38 <Welkin> instead of `null acc`, pattern match on `[]`
10:35:41 <ski> (knowing how to do that is good practice with `if's, even in this case you may want to settle for something better)
10:36:29 <Welkin> instead of `(head acc, x) == ('(', ')')`, pattern match on `('(':xs) ')'`
10:38:23 * shivansh is applying all the good suggestions
11:46:18 <ian5v> hi all second timer here. i feel like lines 21-23 here can be written a bit more elegantly: https://hastebin.com/jedatukene.hs
11:46:42 <ian5v> i understand that op is a string, and eg + is a... function? ie not a string
11:47:09 <Tuplanolla> That's a blank page, ian5v.
11:47:16 <hexfive> its not
11:47:27 <merijn> Tuplanolla: It's not, probably something wrong with your browser setup/their site setup
11:47:39 <ian5v> and that i must somehow map the string to the corresponding function
11:48:02 <Tuplanolla> Modern web, huh.
11:48:41 <merijn> ian5v: Well, you could simply have "Map String (Integer -> Integer -> Integer)"?
11:49:29 <ian5v> merijn: that feels simple, i'll give it a shot
11:49:55 <merijn> :t M.fromList ([("+", (+)), ("*", (*))] :: [(String, Integer -> Integer -> Integer)])
11:49:56 <lambdabot> M.Map String (Integer -> Integer -> Integer)
11:50:11 <merijn> > let opMap = M.fromList ([("+", (+)), ("*", (*))] :: [(String, Integer -> Integer -> Integer)])
11:50:14 <lambdabot>  <no location info>: error:
11:50:14 <lambdabot>      not an expression: ‘let opMap = M.fromList ([("+", (+)), ("*", (*))] :: ...
11:50:16 <cocreature> or do something like "let f = case op of "+" -> (+); … in f (calc a) (calc b)"
11:50:41 <merijn> Yeah, or that
11:51:23 <merijn> ian5v: Sidenote, you could just write "calc a + calc b" without all the parentheses
11:51:30 <ian5v> is M. shorthand for main?
11:51:58 <merijn> ian5v: M. comes from "import qualified Data.Map as M" importing the Map module from the containers library
11:52:05 <merijn> :t M.fromList
11:52:07 <lambdabot> Ord k => [(k, a)] -> M.Map k a
11:52:15 <merijn> @hackage containers
11:52:15 <lambdabot> http://hackage.haskell.org/package/containers
11:56:14 <merijn> Rats...
11:56:20 <merijn> 3 tuples aren't Traversable?
11:56:43 <merijn> A pox upon these purists complaining tuples don't need instances...
11:57:01 <merijn> Actually, I suppose people opposing those instances are the opposite of purists
11:57:10 <int-e> as we have learned from Lisp, pairs are enough for everything
11:57:14 <Average-user> how can I delete multiple values from a Map?
11:57:39 <merijn> int-e: Clearly the lisp users are wrong >.<
11:57:43 <int-e> :t M.filter
11:57:47 <lambdabot> (a -> Bool) -> M.Map k a -> M.Map k a
11:57:53 * ski . o O ( s/pair/RDF triple/ )
11:57:55 <int-e> :t M.difference
11:57:57 <lambdabot> Ord k => M.Map k a -> M.Map k b -> M.Map k a
11:58:01 <int-e> :t M.empty
11:58:03 <lambdabot> M.Map k a
11:58:16 <parsnip> thank you mmaruseacph2 for driving me back into the hakyll, looking forward to the sanity.
11:58:56 <Average-user> Foldable f => Map k a -> f k -> Map k a
11:59:03 <Average-user> something like that
11:59:12 <int-e> oh wasn't there a function for taking the difference of a Map and a Set, hmm
11:59:26 <Average-user> int-e: thats what I'm looking for
12:00:02 <ian5v> Data.Map.map is different from regular Prelude.map, huh
12:00:22 <ian5v> looks to me like Data.Map.map is more general, in that it can be applied on more than just lists
12:00:26 <merijn> ian5v: Well, yes, the former works on Maps, the latter on lists
12:00:29 <int-e> :t M.withoutKeys
12:00:31 <lambdabot> Ord k => M.Map k a -> S.Set k -> M.Map k a
12:00:42 <ian5v> cool
12:00:44 <Average-user> int-e: thanks
12:01:04 <ski> ian5v : it can be applied only on `Map's
12:01:06 <ski> @type M.map
12:01:08 <lambdabot> (a -> b) -> M.Map k a -> M.Map k b
12:01:25 <merijn> ian5v: Data.Map is designed to be imported qualified (e.g. "import qualified Data.Map as M" because otherwise the names clash with the ones from Prelude
12:01:41 <ski> @type M.mapWithKey
12:01:43 <lambdabot> (k -> a -> b) -> M.Map k a -> M.Map k b
12:02:21 <kadoban> ian5v: If you want a strictly more general 'map' that encompasses both, fmap works
12:03:04 <Average-user> int-e: from where can I import withoutKeys, Data.Map doesn't export it apparently
12:03:32 <merijn> ugh...this code would be so pretty and elegant if 3-tuples were Traversable :(
12:04:57 <cemerick_> following on merijn's help earlier, I have what seems like a reasonable generalized Point datatype. However, I can't seem to get away from the compiler wanting me to ground the constraint.
12:05:25 <Welkin> merijn: data Three a b c = Three a b c
12:05:41 <merijn> Welkin: Yeah, but then I might as well define a custom version of traverse for 3 tuples
12:05:56 <ski> @type Data.Map.withoutKeys
12:05:59 <lambdabot> Ord k => M.Map k a -> S.Set k -> M.Map k a
12:06:05 <cemerick_> given data Point a = Point { px :: a, py :: a, pz :: a } deriving Show ..... I'm told e.g. "Expected type: Point a
12:06:05 <cemerick_>         Actual type: Point Integer"
12:06:35 <merijn> cemerick: Can you lpaste the code you have + error?
12:06:37 <ski> cemerick : you need to tell how you're using that
12:07:09 <jle`> cemerick: the error probably doesn't have to do with the data type declaration, but rather a situation where you are using Point
12:08:46 <c_wraith> cemerick, that sounds like the usual case where someone mistakes parametric polymorphism for subtyping. if you promise a value of type Point a, you can't satisfy that with a value of type Point Integer
12:08:48 <cemerick> merijn, ski: it's not a trivial amount; I'll have to work on constituting a manageable example
12:09:00 <jle`> cemerick: start with the line that the error message is pointing to
12:09:12 <jle`> it should tell you a specific line that has an issue
12:09:23 <mark721> hi guys
12:09:24 <jle`> it helps you narrow down where the error is happening :)
12:09:36 <mark721> https://imgur.com/a/Bxc2j  there is something wrong with my where clause can someone have a look pls
12:09:37 <mark721> https://imgur.com/a/Bxc2j
12:09:39 <jle`> in recent ghc's it even has a cute little ASCII arrow pointing at the error in the line too :)
12:09:48 <Berra> Hello - I want to capture this behavior: f e (a -> e) -> f e a -> f e a - surprisingly to me I can't find anything of this signature online - what superior way to capture this am I missing?
12:09:55 <ski> (having explicit type signatures may also help, in case you're missing such)
12:10:03 <jle`> Berra: that's <*>
12:10:11 <jle`> oh sorry, misread
12:10:12 <ski> no it's not
12:10:22 <jle`> thought it returned f e e
12:10:25 <geekosaur> mark721, where attaches to declarations, not expressions
12:10:27 <jle`> do you have a specific type you are thinking of?
12:10:33 <geekosaur> let works for expressions
12:10:39 <jle`> mark721: 'where' is a part of declaration syntax, 'foo = ... where ...'
12:10:48 <jle`> mark721: so you aren't defining anything there, so it doesn't make any sense to use 'where'
12:10:57 <cemerick> c_wraith: put another way, if the compiler can see that I'm providing Point Integer somewhere up above, it's going to complain
12:11:46 <mark721> so jle`  geekosaur  how come this is valid https://imgur.com/a/eF7Qw
12:11:47 <jle`> cemerick: usually that error happens when you write a function that takes Point a -> ..., but then in the function definition, treat it as if it were a Point Integer
12:11:48 <kadoban> Berra: Example of what it should do?
12:11:54 <mark721> i mean i was using previous "knowledge" lol
12:12:04 <geekosaur> because it's attached to the "halve1 list ="
12:12:06 <jle`> mark721: so you see, in that definition, 'where' is attached to halv1
12:12:10 <Berra> jle`: Yes it indeed is similar to that - but just slightly different in a really useful way for what I'm trying to capture. data V e a = V e a - with such an operation as mentioned above.
12:12:19 <jle`> mark721: halv1 .. = ... where ...
12:12:20 <geekosaur> but when it attaches, it ends the expression. which broke your "if ... then ... else"
12:12:23 <jle`> that's the "syntax" for where
12:12:24 <geekosaur> in the other one
12:12:27 <Berra> For Validation that concatenates e using the validation function but keeps a
12:12:35 <merijn> Is Traversable derivable?
12:12:40 <geekosaur> with an extension
12:12:40 <jle`> where doesn't make sense floating out by itself :)
12:12:50 <geekosaur> DeriveTraversable
12:13:13 <jle`> mark721: think of `halv1 ... = ... where ...` as one syntactic construct
12:13:25 <jle`> mark721: kind of like `if ... then ... else ...`
12:13:30 <cemerick> jle`: if I swap out my test data (that satisfies a different `a`), then the code works equivalently. That is to say, I'm fairly confident that I'm not overspecializing on Integers, for example
12:13:50 <jle`> mark721: if/then/else themselves work together as a single unit, they don't make sense on their own
12:13:57 <merijn> cemerick: GHC appears to disagree with you ;)
12:14:17 <jle`> mark721: it's also sort of like `case ... of ... -> ...`, you wouldn't ever write just 'of' somewhere alone
12:14:23 <Berra> kadoban: As I mentioned above - I want it for a data Validation e a = Validation e a. I basically almost want <*> but I want to accumulate e and keep a at the same time - so Applicative isn't quite good enough
12:14:30 <ian5v> merijn: i'm confused how to use M.fromList [ ("+", (+)), ("*",(*)), ("-",(-)) ]
12:14:30 <jle`> mark721: `case .. of .. -> ..` is a single syntactic unit
12:14:34 <mark721> i havent been introduced into case yet
12:14:36 <mark721> um
12:14:40 <thehappycolorpro> hello, so i'm done with ch 5 of haskellbook, but i have an idea for a small program i could write, and it would run on ghci. would it be worth my time to spend some time trying to make it, or should i just continue with the book? i feel like i have enough tools to make it now, but i'm not sure.
12:14:54 <merijn> ian5v: Well, That gives you a "Map String (Integer -> Integer -> Integer)"
12:14:57 <merijn> :t M.lookup
12:15:01 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
12:15:04 <cemerick> merijn: it works equivalently *if* I twiddle the type annotations to make the compiler happy
12:15:06 <jle`> mark721: in other languages, it's kind of like in C/Java/Javascript, `foo(x,y) { ... }`
12:15:12 <merijn> ian5v: You can then use, for example "M.lookup" to lookup a string in the Map
12:15:16 <jle`> mark721: it wouldn't make sense to just have a } out in the middle of nowhere
12:15:23 <cemerick> The broader context here is that I have a separate numeric implementation, and want the codebase to work with Integers as well as this other numeric type.
12:15:26 <jle`> mark721: it only makes sense to use } if you are in that specific syntax thing, with another {
12:15:48 <merijn> @define opMap = M.fromList [ ("+",
12:15:48 <merijn>                (+)), ("*",(*)), ("-",(-)) ]
12:15:48 <lambdabot>  Parse failed: Parse error: EOF
12:15:52 <mark721> so i should wrap the where with {} ?
12:15:55 <mark721> to fix the error?
12:16:04 <geekosaur> you can't use the "where" there
12:16:07 <jle`> mark721: no, that's not what i mean
12:16:08 <mark721> oh :(
12:16:12 <geekosaur> it is breaking up the "if ... then ... else"
12:16:13 <merijn> @define opMap = M.fromList [ ("+",
12:16:13 <lambdabot>  Parse failed: Parse error: EOF
12:16:13 <merijn>                (+)), ("*",(*)), ("-",(-)) ]
12:16:20 <jle`> mark721: i'm saying that `halve1 ... = ... where ..` is a single syntactic unit
12:16:24 <merijn> argh I fail at copy-paste
12:16:32 <jle`> you wouldn't split a declaration from a where, just like you wouldn't split a bracket from its pair
12:16:36 <merijn> @define opMap = M.fromList [ ("+", (+)), ("*",(*)), ("-",(-)) ]
12:16:37 <lambdabot>  Defined.
12:16:40 <merijn> finally
12:16:44 <mark721> so what can i use instead of where?
12:16:46 <jle`> mark721: where doesn't make sense here, because you aren't defining anything
12:16:53 <jle`> you aren't declaring anything, i mean
12:16:54 <mark721> let?
12:17:05 <Berra> kadoban: Does that make any sense to you?
12:17:07 <jle`> yes, (let ... in ...) is an expression
12:17:12 <jle`> and you can use it wherever you can use any expression
12:17:16 <merijn> > case M.lookup "+" opMap of Just f -> f 1 3; Nothing -> 0
12:17:20 <lambdabot>  4
12:17:22 <jle`> the 'then' clause of an if statement takes an expression
12:17:22 <mark721> do you have to use in with let?
12:17:25 <mark721> or is let fine?
12:17:27 <merijn> ian5v: ^^^
12:17:31 <jle`> (let ... in ...) is a single syntactic unit
12:17:37 <jle`> it doesn't make sense to use them separately as an expression
12:17:52 <jle`> asking if you have to use 'in' with 'let' is like asking if you have to use } with {
12:17:59 <merijn> ian5v: Alternatively you can use M.! but that will crash if a key is missing
12:18:14 <merijn> > (opMap M.! "*") 3 5
12:18:17 <lambdabot>  15
12:18:30 <merijn> :t (M.!)
12:18:31 <lambdabot> Ord k => M.Map k a -> k -> a
12:18:34 <jle`> mark721: neither { nor } make sense on their own.  but { ... } is a thing.  neither 'let' nor 'in' make sense on their own.  but 'let ... in ...' is a thing
12:18:35 <kadoban> Berra: Yeah, but I don't know anything offhand that does it like that
12:19:12 <Berra> kadoban: Surprises me a bit that I can't find that signature online - make me think it's capture by a better way.
12:19:35 <jle`> Berra: i don't think it happens often enough for a typeclaass to be useful
12:19:50 <mark721> ok jle could you pls show me a valid version of the "where" clause use let
12:19:57 <mark721> using let and in
12:19:58 <mark721> *
12:20:11 <Berra> jle`: That is probably true - so just having it as a "validate" function should be useful enough
12:20:21 <jle`> (let n = ... in (take n list, drop n list))
12:20:30 <mark721> what is ...
12:20:32 <jle`> mark721: could go in the 'then' part of your if statement
12:20:39 <jle`> mark721: ... is whatever you want 'n' to be defined as
12:21:07 <jle`> in this case "length list `div` 2"
12:21:53 <ian5v> merijn: thank you! haven't figured everything out but working on understanding more now
12:22:23 <merijn> ian5v: If you know any other language, Map is just a dictionary of keys/values and in this case your values happen to be functions
12:22:54 <ian5v> right, i'm just confused by the interface
12:22:55 <mark721> jle`,  sorry lol i thought it couldve been another funky operator
12:23:05 <mark721> jle`, it works now ty :)
12:23:11 <jle`> no problem :)
12:23:33 <jle`> mark721: haskell syntax fits together like a puzzle in a way, you should always be aware of what is expected where
12:23:39 <jle`> 'if ... then ... else ...'
12:23:45 <ian5v> from regular Prelude.map i would expect to be able to `map f [1..3]`, but it doesn't look like i can opMap operator
12:23:49 <jle`> all of those '...'s should be expressions
12:24:00 <jle`> `if [EXPRESSION] then [EXPRESSION] else [EXPRESSION]`
12:24:14 <mark721> btw can you use if without else
12:24:16 <jle`> and, 'let .. in ...' is one way to create an expression
12:24:18 <mark721> this seems like a stupid question
12:24:22 <merijn> ian5v: You wanna map over a list of keys and look up corresponding values?
12:24:24 <mark721> but i havent seen any examples that dont have else
12:24:28 <jle`> it is not a stupid question, a lot of people ask this
12:24:37 <jle`> but, no, it doesn't make sense in haskell to have 'if' without else
12:24:47 <jle`> since an if/then/else defines an expression
12:24:50 <mark721> in haskell it doesnt :P
12:24:53 <geekosaur> Haskell is made of expressions
12:24:53 <mark721> (not java :D)
12:24:56 <jle`> if there is no 'else'...what would the expression be defined as?
12:25:02 <mark721> do nothing :)
12:25:06 <jle`> mark721: right, that's because java's if/the/else is not an expression
12:25:09 <jle`> it's a statement
12:25:11 <geekosaur> "do" notation pretends to be statements, but it makes expressions out of the result
12:25:12 <jle`> it *does* things
12:25:16 <mark721> literally blowing my mind
12:25:27 <ian5v> merijn: i want to have a map that i can ask "+" and be told (+)
12:25:29 <merijn> mark721: Think of if/then/else as "ternary expression", not "if/else statement"
12:25:30 <jle`> haskell's if/then/else is not a statement, it does not "do" anything
12:25:32 <jle`> it evaluates to something
12:25:44 <jle`> so 'if True then x else y' is a statement that is *equivalent* to 'x'
12:25:51 <jle`> it *evaluates* to 'x'
12:25:54 <jle`> it doesn't "do" x
12:25:56 <merijn> ian5v: Right, if you do 'opMap M.! "+"' you get that
12:25:56 <jle`> it *is* x
12:26:10 <jle`> 'if False then x else y' is a statement that is *equivalent* to 'y'
12:26:14 <merijn> > (opMap M.! "+") 3 5
12:26:15 <jle`> it doesn't "do" y, it *is* y.
12:26:17 <lambdabot>  8
12:26:25 <merijn> :t M.!
12:26:27 <lambdabot> error: parse error on input ‘M.!’
12:26:31 <merijn> :t (M.!)
12:26:31 <nullie> :t when
12:26:33 <lambdabot> Ord k => M.Map k a -> k -> a
12:26:33 <lambdabot> Applicative f => Bool -> f () -> f ()
12:26:36 <jle`> sorry, replace all of those "is a statement" with "is an expression
12:26:40 <merijn> :t (M.!) `asAppliedTo` opMap
12:26:42 <lambdabot> Num a => M.Map [Char] (a -> a -> a) -> [Char] -> a -> a -> a
12:26:54 <jle`> "if True then x else y" is a expression that evaluates to 'x', they are semantically *identical* expressions
12:27:07 <kadoban> mark721: If it helps, haskell's  if/else/then is more equivalent to like the ternary operator, in languages that have that
12:27:11 <jle`> mark721: "if False then x else y" is an expression that evalutes to 'y'.  it *is* 'y'.
12:27:19 <jle`> mark721: so if you have "if False then x", what would that statement evaluate to?
12:27:24 <ian5v> merijn: M.! is equivalent to Data.Map.!, right? i don't see that here: https://hackage.haskell.org/package/containers-0.4.0.0/docs/Data-Map.html
12:27:24 <jle`> *what would that expression evaluate to?
12:27:30 <merijn> ian5v: Yeah
12:27:38 <jle`> > (if True then 0 else 1) + 5
12:27:42 <lambdabot>  5
12:27:43 <nullie> There is when function, is it right to use it for conditional action execution in monad?
12:28:03 <thehappycolorpro> is it true that A function of type (a, b) -> a requires that 𝑎 and 𝑏 be of different types?
12:28:12 <merijn> ian5v: Containers 0.4 is ancient :)
12:28:17 <jle`> mark721: in the example above, `(if True then 0 else 1) + 5` is an expression that evaluates to `0 + 5` which *evaluates* to `5`
12:28:19 <jle`> thehappycolorpro: no
12:28:23 <mniip> thehappycolorpro, evidently not
12:28:24 <kadoban> thehappycolorpro: No, they *may* be of different types, it doesn't enforce that they actually are
12:28:36 <merijn> ian5v: https://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Map-Lazy.html#v:-33-
12:28:43 <ian5v> merijn: heck i don't have a sense of what "modern documentation" is, i just hoogle things and click the first links
12:28:45 <jle`> mark721: so, tell me, what would `(if False then 0) + 5` even mean?  what would it evaluate to?
12:28:49 <thehappycolorpro> then is it true that requires that 𝑎 and 𝑏 be of different types
12:28:51 <mniip> thehappycolorpro, when you implement such a function though you must assume they're different types
12:29:00 <merijn> ian5v: Are you using Chrome, by chance?
12:29:04 <jle`> thehappycolorpro: it is not true
12:29:05 <ian5v> merijn: yes
12:29:17 <jle`> but you can't assume that they are the same type
12:29:19 <thehappycolorpro> oh wait
12:29:31 <merijn> ian5v: Lookup the extension "Hackage-Fu" it extends the top right menu with a notifier telling you if you're looking at the latest version of a package's docs
12:29:44 <ian5v> merijn: thank you much c:
12:29:51 <thehappycolorpro> sorry, second question was supposed to be: is it true that  it takes a tuple argument and returns the first value
12:30:12 <jle`> thehappycolorpro: that is the only valid implementation yes, barring any funny business
12:30:34 <thehappycolorpro> hmm i am confused
12:30:42 <jle`> what other implementations can you think of? :)
12:31:09 <thehappycolorpro> i just thought that it meant that the function with that type must return the same *type* as a, but not necessarily the smae value as a
12:31:09 <jle`> by funny business i mean something like:
12:31:25 <jle`> thehappycolorpro: ah! yes this is something that is very surprising
12:31:42 <woodson> when using ffi javascript in my project does it mean that i can only build my project with ghcjs?
12:31:54 <geekosaur> woodson, yes
12:32:03 <geekosaur> ghc's FFI is C, not javascript
12:32:16 <geekosaur> ghcjs's FFI is javascript, not C
12:32:24 <woodson> oh ok
12:32:35 <jle`> thehappycolorpro: a function in haskell of type `(a, b) -> a`, where 'a' and 'b' are type variables (and not specific types), has to obey parametric polymorphism
12:32:41 <woodson> I am using reflex and was building my project with ghc
12:32:41 <ski> thehappycolorpro : if you have a function of type `(a,a) -> a', then it doesn't need to return the first component
12:32:42 <jle`> thehappycolorpro: it has to work for *all* possible a's that the user can give you
12:32:58 <woodson> but ghcjs requires me to always build an index.html
12:33:12 <woodson> is there some kind of way to have a hot reload ?
12:33:21 <jle`> thehappycolorpro: because it has to be so accomodating, it can't make any assumptions about what 'a' is
12:33:29 <thehappycolorpro> Ahhhhhhhh
12:33:40 <thehappycolorpro> it's similar to that weird id thing i did yesterday i think
12:33:43 <jle`> so something like 'foo (x,y) = True` would not work
12:33:48 <jle`> because that would assume that 'a' was Bool
12:33:51 <jle`> but it's not
12:33:54 <thehappycolorpro> yesss yesss
12:33:56 <thehappycolorpro> i see
12:33:56 <jle`> (or well, it might not be)
12:34:23 <ski> @djinn (a,b) -> a
12:34:23 <lambdabot> f (a, _) = a
12:34:49 <thehappycolorpro> and if i do any operation on some variable x with the type a, it would have a restricted type, so the type signature changes
12:35:17 <mark721> jle`,  it evaluates to + 5 no?
12:35:24 <thehappycolorpro> OK thank you very much
12:35:27 <jle`> mark721: what does that mean?
12:35:31 <jle`> thehappycolorpro: np!
12:35:33 <mark721> no idea LOL
12:35:43 <jle`> mark721: exactly -- that's why i'm saying it's meaningless :)
12:35:49 <mark721> O
12:36:09 <mark721> ok ty
12:36:33 <mark721> must run :) before some more questions come from jle`  :P i spent a good minute just confused reading the question
12:36:36 <jle`> thehappycolorpro: think of the type (a,b)->a as a promise that, whatever 'a' the user gives, it'll return a value of the same type
12:37:11 <jle`> thehappycolorpro: if you make any operations on 'a' that only work on restricted versions of it, then it breaks that promise
12:37:27 <jle`> mark721: no problem! and don't worry, these aren't easy questions
12:39:23 <mark721> jle`,  :)
12:39:28 <thehappycolorpro> err, why are there two copies of my .hs files? i have one normal one called 'example.hs' and another one called 'example.hs~'
12:39:37 <mniip> that's your editor
12:39:39 <jle`> some text editors do that sometimes
12:39:52 <jle`> sometimes they do it as an auto-save
12:39:53 <mniip> gedit? emacs? sublime?
12:40:03 <thehappycolorpro> yeah im using emacs
12:40:10 <thehappycolorpro> i see ok i thought i broke sometimg
12:40:40 <thehappycolorpro> i feel like a grandma who's learning how to use a smartphone
12:41:27 <kadoban> A smart language maybe. No idea if you're a grandma or not
12:42:13 <thehappycolorpro> not a grandma, but i can understand the pain now
12:47:24 <jle`> oh hey finally got around to getting hdevtools to work with syntastic + location list/error list in vim, writing haskell is really fun now
12:47:58 <jle`> every change i make the loclist shows all the errors and i just go through each one automatically until the loclist is empty
12:48:06 <merijn> jle`: I had that working and broke it again by using new-build >.>
12:48:08 <jle`> much nicer than the manual recompiling i was doing before heh
12:48:30 <jle`> i mean, it was still really fun before this
12:48:37 <jle`> merijn: ah :O
12:48:49 <merijn> jle`: Yes, it's pissing me off that I don't have auto highlighting anymore :\
12:49:10 <merijn> jle`: AFAIK ghcid is the only tool that is somewhat robust in that regard, but there's no vim plugin for it :\
12:49:11 <jle`> some time in the past my auto-completion of packages disappeared and that made me sad, i didn't even notice when it happened
12:49:30 <jle`> *of modules
12:50:16 <jle`> i might have an idea why though, i'm using a snippets package that binds the same key to jumping between blanks in the snippet
12:50:25 <jle`> next time i'm procrastinating i'll probably look into that
12:50:49 * jle` fights back the voice in his head saying "why not now?"
12:51:00 <merijn> jle`: Instead do something useful!
12:51:08 <merijn> jle`: Like making a ghcid plugin for me ;)
12:51:31 <srid> has anyone figured out how to use cabal new-repl and friends from Spacemacs? (spacemacs uses `cabal repl`, etc. and I don't think it can be configured away...)
12:51:43 <jle`> vim 8.0 is out too, and it has async IO
12:51:49 <jle`> i wonder if that would help anything
12:52:07 <merijn> jle`: Probably, it works well with ghc-mod on my desktop
12:52:25 <jle`> merijn: write me a vimscript backend to ghc and i'll write your ghcid
12:52:37 * srid would switch to vim right away if there is a working setup for nix + ghcjs + cabal
12:52:39 <merijn> jle`: Isn't there a vimscript backend for idris?
12:52:56 <jle`> oh hm that's actually kind of interesting
12:53:12 <jle`> actually i wonder if it would be that hard to have vim natively support haskell scripts
12:53:34 <jle`> since it already supports perl/python/ruby scripts
12:54:26 <jle`> time to re-learn C
12:54:39 <kadoban> https://hackage.haskell.org/package/nvim-hs
12:54:54 <merijn> jle`: It supports C too
12:55:04 <kadoban> Not sure why neovim instead of vim though, I thought they could share
12:55:04 <merijn> kadoban: That has the dreadful n of neovim :\
12:55:42 <kadoban> merijn: Ya. 1/2 the time stuff for one works in the other though, though ... probably not for this.
12:56:01 <merijn> kadoban: 90% of my current coding happens on stone age CentOS, sadly :\
12:56:14 <kadoban> merijn: Ooof, that's painful
12:56:25 <merijn> kadoban: Without root to install stuff too >.>
12:56:32 <kadoban> Eeek
12:57:07 <Tuplanolla> Once again we share the same fate, merijn.
12:57:49 <merijn> Tuplanolla: My condolences :)
12:57:50 <Tuplanolla> Do you also happen to use Biber to manage bibliographies?
12:58:23 <merijn> Tuplanolla: On the bright side GHC and cabal work stunningly well without root, if I have to compare to the trash that is C(++)/python/etc.
12:58:35 <Tuplanolla> I just had the pleasure of putting two days into installing it.
12:58:51 <merijn> I just don't manage my bibliography :p
12:59:06 <cocreature> merijn is way too cool to cite other people
12:59:22 <merijn> cocreature: Naah, I just let my co-authors deal with that shit :p
12:59:47 <Tuplanolla> It conflicted with the system Perl and the system TeXLive. My appreciation for Stack suddenly increased visibly.
13:01:28 <cocreature> merijn: nice, I thought you had to become a professor before you can offload that kind of work on other people :)
13:03:24 <metahumor> jle`: I found ALE to work better than syntastic for me
13:04:02 <metahumor> thehappycolorpro: re your earlier question about writing something now vs moving on in haskellbook: i'd suggest writing it now, then as you keep reading, you'll learn about ways you could have written your thing neater/cleaner
13:04:07 <merijn> I'm using neomake now, since that works with ghc-mod and that's the only thing I got working with new-build via an incredibly hacky and brittle way
13:04:33 <metahumor> thehappycolorpro: because you will have had the pain+pleasure of getting something working, you'll have the context with which to appreciate some more advanced topics
13:22:49 <never> hey
13:23:01 <never> forgive me if that's not the good place to ask this
13:23:04 <thehappycolorpro> when i do the function: myFunc xToY yToZ _ (a, x) = (a, (yToZ (xToY x)))
13:23:32 <cemerick> ah-HA!
13:23:46 <cemerick> turns out I was getting hit with a monomorphism restriction (I think)
13:23:57 <thehappycolorpro> how does it know that the type of the first part `xToY` is (t1 -> t2) ?
13:24:10 <cemerick> had some top-level function compositions; dropped them, and everything's happy
13:24:18 <thehappycolorpro> is `To` a function? i'm so confused
13:24:19 <never> but I get a weird error when trying to run stack install yesod-bin :
13:24:20 <never> http://lpaste.net/3173053823182700544
13:24:45 <glguy> thehappycolorpro: It knows because you applied that function to an argument in the definition of myFunc
13:24:51 <cemerick> jle`, ski ^^ :-)
13:25:21 <dmwit> thehappycolorpro: No, `To` is not a function. `xToY` is a single name, indivisible, under God, with liberty and justice for all.
13:25:36 <thehappycolorpro> im so lost
13:25:48 <thehappycolorpro> ok i will marinate this in my head
13:26:00 <thehappycolorpro> and out will come a deliciously newfound understanding
13:26:10 <glguy> :t \f g x -> f (g x)
13:26:12 <lambdabot> (t1 -> t2) -> (t3 -> t1) -> t3 -> t2
13:26:28 <glguy> That's a simpler example doing the same thing
13:26:50 <dmwit> :t \bToC aToB a -> bToC (aToB a)
13:26:51 <lambdabot> (t1 -> t2) -> (t3 -> t1) -> t3 -> t2
13:27:04 <dmwit> :t \foobar bazquux blargle -> foobar (bazquux blargle)
13:27:07 <lambdabot> (t1 -> t2) -> (t3 -> t1) -> t3 -> t2
13:27:35 <dmwit> Names don't matter.
13:28:45 <thehappycolorpro> :t \f g x = f ( g x)
13:28:47 <lambdabot> error:
13:28:47 <lambdabot>     parse error on input ‘=’
13:28:47 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
13:28:56 <metahumor> s/=/->
13:28:59 <thehappycolorpro> what do those arrows mean
13:29:20 <metahumor> :t let f g x = f (g x) in f
13:29:22 <lambdabot> error:
13:29:22 <lambdabot>     • Occurs check: cannot construct the infinite type: t2 ~ t0 -> t2
13:29:22 <lambdabot>       Expected type: t2 -> t3
13:29:30 <metahumor> whoops
13:29:32 <dmwit> `\x -> e` is the syntax for a function which takes an argument, names it `x`, and returns the result of the expression `e`.
13:29:37 <kadoban> thehappycolorpro: It's syntax for a lambda function. It's just a function in expression syntax
13:29:48 <metahumor> :t let q f g x = f (g x) in q
13:29:50 <lambdabot> (t1 -> t2) -> (t3 -> t1) -> t3 -> t2
13:30:52 <dmwit> Normally, functions of multiple arguments would be written `\x -> \y -> \z -> e`, but this is pretty common and kind of annoying, so as a shorthand Haskell also offers `\x y z -> e` as syntax that means the same thing.
13:31:03 <thehappycolorpro> ah ok i get that part now
13:31:13 <thehappycolorpro> sorry this is probably so basic lol
13:31:53 <thehappycolorpro> why is the type for 'f' in that example understood as (t1 -> t2)?
13:32:58 <lyxia> it's applied to something, therefore it's a function
13:33:03 <glguy> (t1 -> t2) is the type of values that are function that can be applied to a value with type t1 generating a result with type t2
13:33:47 <glguy> if f :: t1 -> t2,  and x :: t1,  then   f x :: t2
13:34:59 <thehappycolorpro> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
13:35:00 <thehappycolorpro> I GET IT
13:36:39 <thehappycolorpro> thank you T____T
13:54:12 <cheater> hi
13:54:18 <cheater> is there a thing like quickcheck that will test the statistical properties of my code?
13:54:54 <cheater> eg if i have a function that has randomized output, i would like to check what the distribution of that is
13:54:57 <cheater> and reason about it
13:55:58 <metahumor> i think that's a hard problem independent of programming language
13:56:21 <metahumor> do you want a specifically Haskell answer or a general sketch at how to approach such a problem?
13:59:53 <kadoban> cheater: I would guess that that's something usually better done via analysis than tools
14:02:06 <davean> cheater: I've got a thing for a similar statistical property test, but not that one - one of the problems you'll encounter is you have to specify how much error your willing to accept in both directions.
14:02:24 <cheater> davean: why is that a problem
14:02:27 <cheater> it's just part of what you do
14:02:33 <cheater> :)
14:02:46 <davean> Its a problem because it involves a stopping condition
14:02:53 <cheater> sure
14:02:55 <davean> and theres no general approach to the stopping condition problem
14:03:22 <cheater> i'm fine with saying "run the test until you are within 5% certain"
14:03:30 <davean> So sure, you "just do it" and get a PhD along the way
14:03:32 <cheater> and then possibly doing 1% instead
14:03:37 <davean> ... you can't do that though
14:03:43 <davean> if we could do that we could solve it better
14:03:44 <cheater> why not?
14:03:53 <davean> Because you can't know how certain you are really.
14:04:09 <davean> Because you don't actually knwo the distribution you're working with for one
14:04:15 <davean> and you have only seen what you've sampled
14:04:27 <davean> The very choice of when to stop introduces bias
14:05:21 <davean> This is a fairly well known problem in probabiltiy and statistics
14:05:29 <metahumor> "real" statisticians say, you must form your hypothesis first, and only then can you test to some level of significance
14:05:55 <davean> metahumor: this isn't that
14:06:23 <Tuplanolla> I've had this similar idea of "simulations as types", but never put any real thought into it.
14:07:35 <davean> cheater: Ok, so, consider this for a moment. The closer two things are, the more data you need to tell they're different, right?
14:08:42 <thehappycolorpro> i'm stuck. how would i go about defining the function that would type :: (a -> c) -> a -> a?
14:08:49 <cheater> davean: you can use the german tank problem to solve the issue you are bringing up
14:09:33 <davean> cheater: Uh, prove it
14:09:53 <davean> (by  which I mean, I don't even see how that relates)
14:09:54 <cheater> no
14:10:02 <cheater> ok well
14:10:29 <dmwit> thehappycolorpro: What have you tried so far?
14:10:30 <cheater> the german tank problem tries to figure out the rate of production of a specific kind of tank based of incomplete observations
14:10:53 <davean> Assuming no replacement and sequential ordering
14:11:01 <cheater> we're trying to figure out the rate of production of each, say, 256-bit number based off incomplete observations
14:11:09 <thehappycolorpro> the only thing i could think of was f a b = a (b) so far
14:11:11 <cheater> i think those are fairly directly connected
14:11:19 <davean> I don't
14:11:24 <thehappycolorpro> i feel like that part should at least be there so it knows that a is a function
14:11:25 <davean> for one, you don't have the ordering assumption
14:11:38 <thehappycolorpro> but how to make it turn to b value i'm lost
14:11:42 <cheater> you're right, the numbers are unordered
14:11:43 <cheater> except..
14:11:47 <davean> For two, you expect replacement
14:11:54 <cheater> why do i?
14:11:58 <dmwit> thehappycolorpro: Are you hoping to find a function whose inferred type is `(a -> c) -> a -> a`, or would you be satisfied with a function that could be given that type by type ascription?
14:12:17 <kadoban> thehappycolorpro: Why do you have to convince it that 'a' is a function? Giving a type annotation is typical anyway
14:12:44 <thehappycolorpro> oh waaaat
14:12:47 <thehappycolorpro> that's cheating
14:12:50 <davean> cheater: OK, either you have replacement, lack of density, or your distribution can only be exactly one thing
14:12:51 <glguy> :t \f x -> const x (f x)
14:12:53 <lambdabot> (t -> b) -> t -> t
14:12:54 <dmwit> thehappycolorpro: That is, if I replaced the `undefined` in `f :: (a -> c) -> a -> a; f = undefined` by something, and the compiler accepted this, would that be enough? Or do you demand that I replace the `undefined` in `f = undefined` and have the compiler then spit back the type `(a -> c) -> a -> a`?
14:12:57 <davean> and that thing is boring and trivial to test
14:13:26 <davean> and you didn't ask "How can I make sure it generates every number exactly once"
14:13:28 <cheater> i don't know what you are referring to davean
14:13:45 <thehappycolorpro> dmwit: sorry but i don't understand how those are different
14:13:56 <cheater> i don't really care to ask if the numbers are generated exactly once
14:14:03 <dmwit> thehappycolorpro: The former includes `f :: (a -> c) -> a -> a` as an input to the compiler. The latter doesn't.
14:14:15 <davean> cheater: yes, in which case either there are numbers you don't generate, or you generate numbers more then once
14:14:18 <cheater> a csrng is perfectly fine if it repeats numbers
14:14:28 <cheater> you can have both davean
14:14:37 <davean> I said or, not xor
14:14:44 <cheater> you said either
14:14:51 <davean> Yes
14:15:03 <cheater> either or is xor
14:15:04 <thehappycolorpro> dmwit: i think the first one is fine. i don't need the actual 'a's and 'b's to be there
14:15:08 <davean> So, again, the tank problem relies on non-replacement
14:15:19 <davean> and density
14:15:27 <cheater> how do you define density?
14:15:29 <davean> So since we have to lack at least one of those ...
14:15:45 <davean> containing all the numbers
14:15:46 <cheater> anyways
14:16:08 <davean> Anyway, I direct you to the large body of lit. of people attempting to even partially solve this problem
14:16:18 <cheater> i really am less concerned with all the ways in which this sort of problem can't be solved and am more interested in the ways in which it can be solved
14:16:30 <cheater> so, if someone here has solved it, that's all i wanted to know, or if there's a lib
14:16:31 <davean> Its large, its deep, and its prretty conclusive that its a hard problem for the moment until someone comes up with some idea no one has touched on yet
14:16:47 <davean> so I at least think its boring to spend more of my time on with you ATM
14:16:52 <cheater> if not, i might build something for myself, that's all i really came for here :-)
14:17:01 <dmwit> thehappycolorpro: Okay. Then here is the way to "turn the crank" and get what you want. We write `f :: (a -> c) -> a -> a`. Now we notice that the type of `f` is a function with two arguments, so we pick some names for them, let's say `x` and `y`. So we now write `f x y = ...`. We have `x :: a -> c`, and `y :: a`, and we are looking to replace `...` with something of type `a`. Right?
14:17:49 <davean> cheater: you need some way to deciding how much data to collect, good luck :)
14:17:58 <cheater> no i don't
14:18:08 <davean> Ok
14:18:13 <cheater> i can just go, collect for this amount of time, see how well data fits
14:18:14 <thehappycolorpro> dmwit: yes
14:18:26 <cheater> if it doesn't fit within margin, raise alarm
14:18:27 <davean> cheater: if you want a wrong result, sure
14:18:34 <davean> anyway, I'm done
14:18:35 <cheater> i guess that's what i want then
14:18:38 <thehappycolorpro> dmwit: so i just do f x y = y?
14:18:46 <dmwit> thehappycolorpro: Looks right to me.
14:18:50 <dmwit> thehappycolorpro: Let's ask GHC.
14:19:00 <dmwit> > let f :: (a -> c) -> a -> a; f x y = y in ()
14:19:03 <lambdabot>  ()
14:19:04 <ski> applying `x' would produce a `c' .. which you have no use for
14:19:08 <dmwit> thehappycolorpro: Seems to work!
14:19:11 <ski> @djinn (a -> c) -> a -> a
14:19:11 <lambdabot> f _ a = a
14:19:14 <thehappycolorpro> dmwit: is there another way to do it? without putting in the first stuff
14:19:30 <dmwit> thehappycolorpro: Can you be more specific than "the first stuff"?
14:19:57 <thehappycolorpro> without putting in let f :: (a -> c) -> a -> a; f x y = y in ()
14:20:31 <dmwit> ...that's the entire answer. No, you cannot skip putting in the entire answer if you want to know whether you got the right answer.
14:21:06 <thehappycolorpro> ah ok thank you
14:21:14 <dmwit> Or, to say it another way: let's ask GHC!
14:21:17 <dmwit> >
14:21:35 <kadoban> :t let f a b = let x = a b in b
14:21:37 <lambdabot> <no location info>: error:
14:21:37 <lambdabot>     not an expression: ‘let f a b = let x = a b in b’
14:22:08 <cheater> davean: what works were you going to point me to? i'd love to hear how others have tried and failed, it could give me some good ideas
14:22:20 <kadoban> Damn how do I write that better in lambdabot, too confusing with the 'in's
14:22:39 <glguy> kadoban: You could use my const version from earlier
14:23:10 <kadoban> Oh, yeah that's a better idea
14:25:45 <cheater> kadoban: use braces
14:26:13 <kadoban> cheater: Still ends up pretty crap
14:32:10 <cheater> sorry can't help you otherwise :l
14:32:16 <cheater> kadoban: maybe use "where"?
14:34:22 <geekosaur> where won't work, lambdabot is expressions
14:35:10 <cheater> hm
14:35:14 <cheater> where isn't expressions?
14:36:27 <kadoban> No, it goes with declarations or whatever they're called
14:36:34 <int-e> > let x = x where x = 42 in x
14:36:37 <lambdabot>  42
14:37:18 <int-e> > let { x = y where { y = 42 } } in x
14:37:21 <lambdabot>  42
14:37:56 <kadoban> Err
14:38:46 <int-e> declaration? binding? I'm too lazy to look up the grammar fragment in the Haskell report.
14:44:13 <fresheyeball> > let theMeaningOfLife = x
14:44:16 <lambdabot>  <no location info>: error:
14:44:16 <lambdabot>      not an expression: ‘let theMeaningOfLife = x’
14:48:08 <metahumor> cheater: check out this paper and how they tested statistical properties of PRNGs: http://www.thesalmons.org/john/random123/papers/random123sc11.pdf
14:48:56 <metahumor> cheater: specifically, for PRNGs, there are TestU01 and BigCrush. the paper goes on to explain why Random123 is good for some purposes and bad for others, and explains how it got that understanding
14:49:22 <metahumor> cheater: if your problem domain is testing whether your PRNG is "good", i'm giving you a good model system to compare with
14:50:02 <thehappycolorpro> http://lpaste.net/361972 i intended to make a function `sing` that prints either one or the other string depending on the numbers that follow it
14:50:50 <metahumor> thehappycolorpro: do you notice the "Warning: Use String"?
14:51:01 <thehappycolorpro> yes
14:51:14 <metahumor> thehappycolorpro: that's a nice way to exercise your knowledge. do you know of a way to make the defn of "sing" more idiomatic?
14:51:53 <thehappycolorpro> metahumor: i don't know what you mean by idiomatic
14:52:12 <metahumor> thehappycolorpro: as in, more in the traditional style of Haskell program syntax?
14:52:38 <thehappycolorpro> i don't know traditional haskell program syntax o_o
14:55:00 * ski . o O ( guards )
14:55:59 * metahumor . o O (ski . o O ( guards ) )
14:57:01 <metahumor> thehappycolorpro: are you familiar with guards? they're the traditional way of writing conditional expressions in Haskell
14:57:02 <thehappycolorpro> hmm alright i will just fail this part and move on
14:58:02 <metahumor> "f a b | a > b = fstString x | otherwise = sndString y where ..."
14:58:26 <thehappycolorpro> oh wat i haven't leanred that yet
14:58:31 <metahumor> thehappycolorpro: and of course, it might be nice to get rid of the warnings by changing your typesigs to "String -> String"
14:58:46 <metahumor> well now is not a bad time to find out about guards!
14:59:00 <ski> it's basically an alternative conditional syntax, that attaches to defining equations, and that allows more than two branches (without nesting)
14:59:07 <ixxie> so, about idiomatic conditional parameters - is using Maybe types and fromMaybe the gold standard?
14:59:12 <ixxie> I have been parusing https://stackoverflow.com/questions/7781096/is-there-a-better-way-to-have-optional-arguments-in-haskell
15:00:03 <ski>   sing a b
15:00:04 <thehappycolorpro> the problem i'm having is that my code is printing the second string every time
15:00:08 <ski>     | a > b     = fstString x
15:00:12 <ski>     | otherwise = sndString y
15:00:13 <ski>     where
15:00:16 <ski>     ...
15:00:31 <ski> how do your tests look like, then ?
15:00:44 <metahumor> thehappycolorpro: I've updated your lpaste to have a "sing'" that uses guards
15:01:07 <metahumor> ski also pasted it into the channel, with a nice formatting of aligning the equalsigns
15:01:25 <thehappycolorpro> i type in `sing 2 1`, and since 2 > 1 is true, i expect it to print the first string
15:01:42 <thehappycolorpro> so i think im misunderstanding something or typed it wrong or something else ah man
15:01:46 <metahumor> ixxie: are you asking about how to write functions that take an optional number of arguments, that is, variadic functions?
15:02:02 <thehappycolorpro> metahumor: thank u
15:03:19 <ixxie> metahumor: aye
15:03:32 <__Myst__> Hey. Quick question
15:03:37 <ski> thehappycolorpro : and that test works as expected ?
15:03:54 <thehappycolorpro> oh, no. it always prints the second string
15:04:06 <ixxie> metahumor: actually now I read further, the approach of making a custom data record and builds a default constructor is also quite appealing
15:04:25 <__Myst__> Is there a function that takes in an (a -> b -> b) function, an argument (Maybe a) and an argument b and either applies the function or returns b straight up?
15:04:59 <__Myst__> e.g. thisFunction (+) (Maybe 2) 3 == 5
15:05:03 <__Myst__> thisFunction (+) Nothing 3 == 3
15:05:35 <ski> > foldr (\x s -> concat ["(",show x," + ",s,")"]) "0" Nothing
15:05:38 <lambdabot>  "0"
15:05:39 <ski> > foldr (\x s -> concat ["(",show x," + ",s,")"]) "0" (Just 3)
15:05:42 <lambdabot>  "(3 + 0)"
15:05:52 <ski> > foldr (+) 3 Nothing
15:05:55 <lambdabot>  3
15:05:56 <ski> > foldr (+) 3 (Maybe 2)
15:05:59 <lambdabot>  error:
15:06:00 <lambdabot>      • Data constructor not in scope: Maybe :: Integer -> [b]
15:06:00 <lambdabot>      • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
15:06:03 <ski> er
15:06:06 <electrocat> __Myst__: you could use applicatives
15:06:09 <ski> > foldr (+) 3 (Just 2)  -- of course
15:06:12 <lambdabot>  5
15:06:19 <__Myst__> applicatives?
15:06:19 <ski> __Myst__ : that works ^ ?
15:06:19 <thehappycolorpro> ski: ok i don't know what happened but it's working normally now... i think i just loaded the wrong folder with an older version of my code
15:06:26 <__Myst__> ski: does it have to be foldr?
15:06:29 <ski> thehappycolorpro : that can happen
15:06:51 <ski> __Myst__ : i think that's the closest. `foldl' could also work, but then the argument ordering of the callback is different
15:07:06 <electrocat> hm
15:07:10 <electrocat> didn't know maybe was foldable
15:07:12 <ski> > foldl (\x s -> concat ["(",show x," + ",s,")"]) "0" Nothing
15:07:15 <lambdabot>  "0"
15:07:16 <ski> > foldl (\x s -> concat ["(",show x," + ",s,")"]) "0" (Just 3)
15:07:19 <lambdabot>  error:
15:07:19 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘3’
15:07:19 <lambdabot>      • In the first argument of ‘Just’, namely ‘3’
15:07:31 <ski> see, i already forgot about it !
15:07:34 <ski> > foldl (\s x -> concat ["(",show x," + ",s,")"]) "0" (Just 3)
15:07:37 <lambdabot>  "(3 + 0)"
15:08:40 <ski> electrocat : it can be useful if you have a `Maybe X', and want to "iterate" over the `X's in it, using `forM_' or `mapM_'
15:09:17 <ski> (of course, iterate here amounts to either skipping the "body", or doing it once, with the `Just' contents)
15:09:26 <electrocat> ski: yes i can see that :) good to know
15:09:57 <ski> sometimes this is exactly what one wants to do (the `Maybe' preexisting), and so it's nice to avoid reinventing the wheel for this
15:09:57 <woodson> is there a way for me to execute javascript third party library from ghc?
15:10:19 <electrocat> woodson: foreign function interface
15:10:30 <Tuplanolla> Do you want it to be a pleasant experience, woodson?
15:10:42 <electrocat> that's all i know :p
15:10:44 <metahumor> ixxie: i was going to suggest the datatype and records syntax for your variadic stuff too, it seems much less magic to me than the weird typeclass stuff
15:11:14 <metahumor> ixxie: but as another answer on that thread noted, records will make you unable to partially apply your function, for example
15:11:28 <geekosaur> woodson, there is no standard interface for running javascript from native programs aside from browsers
15:11:30 <metahumor> ixxie: and you'll have to define a new data for each of your variadic functions
15:11:41 <woodson> Tuplanolla: sure, I guess?
15:11:49 <geekosaur> you will have ot figure out how to integrate a javascript executive such as v8
15:12:12 <ixxie> metahumor: yeah that is a big minus
15:12:16 <Tuplanolla> Then you should follow geekosaur's advice, woodson.
15:12:43 <__Myst__> thank you ski
15:12:53 <electrocat> it can't be done with ghcjs?
15:13:32 <woodson> geekosaur: So if I want to interact with another language such as java, c, python between these three which one is done much easily?
15:13:36 <geekosaur> if you want to run the result in the browser, sure
15:13:43 <woodson> i guess c++ because of ghc?
15:13:48 <electrocat> woodson: c
15:14:00 <electrocat> why would you think c++?
15:14:34 <woodson> because I have a small project that requires me to use the google liphonenumber library
15:14:45 <geekosaur> C++ interfaces with C++. you have to use 'extern "C"' definitions in C++ to makie functions that can be called by non-C++
15:14:52 <woodson> and it offers only java c++ javascript python and c#
15:15:11 <Tuplanolla> I'd wrap the C++ with C and use that via ffi, woodson.
15:15:12 <electrocat> yeah, c++ works well too
15:15:35 <Tuplanolla> JavaScript is about the worst of your choices there.
15:16:35 <electrocat> woodson: https://en.wikibooks.org/wiki/Haskell/FFI
15:19:04 <woodson> Tuplanolla: what do you mean by wrap C++ with C?
15:19:18 <woodson> electrocat: Thanks!
15:20:00 <Tuplanolla> Again what geekosaur said, woodson.
15:20:02 <electrocat> woodson: write some c code to call the c++ functions to you can call those c wrappers you wrote from haskell
15:20:18 <electrocat> but preferably do what geekosaur says
15:20:43 <electrocat> c++ mangles you function names, so you need to 'unmangle' them somehow
15:21:14 <Tuplanolla> The worse option I was going to suggest was launching a separate process and communicating with it, but let us ignore that.
15:21:55 <electrocat> for certain languages that might be the most viable option :p
15:22:11 <woodson> electrocat: Oh i see.. damn that means that I have to rewrite the function calls in c
15:22:17 <woodson> and then call them from haskell
15:24:08 <electrocat> woodson: yeah, you need to wrap them in some way
15:24:19 <geekosaur> or keep ther current ones and write 'extern "C"
15:24:22 <geekosaur> wrappers
15:24:35 <geekosaur> which is usually better if you will also be uisng them from C++
15:25:35 <electrocat> geekosaur: wrap a #include in extern "C" ?
15:26:19 <electrocat> no that, wont work
15:26:21 <cheater> metahumor_aw: that's a pretty good starting point thanks!
15:26:36 <geekosaur> no, write a wrapper function which has 'extern "C"' linkage so it uses C conventions instead of name mangling representing parameter types
15:27:28 <electrocat> right
15:27:34 <electrocat> because you can still use C++ in those wrappers
15:27:58 <electrocat> yeah, that's better
15:28:54 <cheater> hey guys, what's that estimation technique that goes like, given you've seen n ships pass by, when do you stop looking and use the data you've already gathered to figure out how many ships there are total?
15:30:01 <woodson> ok I will give it a try
15:30:35 <MarcelineVQ> cheater: estimate immediatly away, update that estimate as data comes in
15:31:50 <cheater> no there was a specific theorem about this sort of thing
15:37:31 <dmwit> There is some delightful irony in that question, given your previous discussion with davean, esp. "<davean> you need some way to deciding how much data to collect <cheater> no i don't"
15:40:55 <cheater> yeah, because i don't
15:41:03 <cheater> not at the stage i'm at haha
15:41:16 <cheater> i don't need to build everything all at once at day 0
15:41:48 <cheater> i'm just curious about this article i read some time ago, and i'm trying to find again
15:49:07 <thehappycolorpro> allright
15:49:24 <thehappycolorpro> i have decided to sleep 3 hours a day and devote all my free time into finishing this book
15:49:38 <thehappycolorpro> reading* this book
15:51:50 <troydm> so, I kinda wrote this small app that pretty much connects to D-Bus and just reads certain messages and prints them out to console, and it works. However given that app is really functionally very small I still don't get it why it eats up 10mb of RSS when process is started, I tried lowering the heap limit but app fails to start unless I give it 10mb
15:52:15 <troydm> for comparison XMonad does tons of things and eats only 16mb of RSS
15:52:38 <troydm> my up is for using XMonad with dbus however it runs as separate process
15:53:05 <boj> keep in mind haskell has a complete runtime
15:53:44 <troydm> boj: yes I understand but still 10mb of ram just to printout messages from dbus is kinda overkill I think
15:53:48 <MarcelineVQ> ~4mb of that is the runtime, plus whatever else is linked in
15:54:24 <troydm> MarcelineVQ: just exactly what goes into those 4mb?
15:56:15 <MarcelineVQ> the rts does things like garbge collection, thread managing, memory allocation and managing, lemme look for reading material on it if you'r einterested
15:57:37 <MarcelineVQ> ezyang probably has the most approachable writeup on it  http://ezyang.com/jfp-ghc-rts-draft.pdf aside from https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts
15:57:46 <troydm> MarcelineVQ: thx
15:58:07 <silver1> I'm so sick of this...
15:58:27 <silver1> one of my coworkers on my first day, an older dude, told me "I never needed to use an enum in 25 years of programming"
15:58:34 <silver1> obviously a super smart dude, a lot of tenure, experience, definitely high IQ
15:58:54 <cheater> https://en.wikipedia.org/wiki/Secretary_problem
15:58:59 <cheater> that's the one
15:59:38 <silver1> so we ran into this library issue in a language that doesn't have neither enums nor optionals *ahem*go*ahem*
15:59:53 <silver1> and the function returns either a certificate pool if it loads it properly or an error
16:00:06 <silver1> but it has a bug and if the system has no certs in the pool, it'll return error as nil, but also the pool as nil
16:00:14 <silver1> and I say "look if we had enums, this wouldn't be a problem"
16:00:30 <silver1> he goes "enum doesn't save you from stupid logic errors :)"
16:00:41 <silver1> also why the hell is everyone so convinced that haskell is hard
16:00:51 <silver1> that's making me so mad
16:00:59 <silver1> these are people that can program in C++ ffs
16:01:02 <MarcelineVQ> because math is scary, people think it's all numbers
16:01:13 <silver1> I suck at math and I can do Haskell
16:01:49 <silver1> whoever perpetuates this myth that you need to understand category theory to even think about learning haskell is causing a lot of damage
16:01:53 <geekosaur> people who think it's just fine to have the whole application memorized. and then get hit by a bus and someone ends up rewriting the whole application because only that one person had the whole thing in their head, and made it impossible for anyone else to understand any but small parts
16:02:01 <troydm> silver1: sometimes old dogs can't learn new tricks, so they choose ignorance
16:02:29 <troydm> silver1: I see a lot of ppl like that
16:02:54 <geekosaur> that is usually self-inflicted
16:03:54 <silver1> I'm 33.. below average intelligence... below average programming mojo.. yet this is so clear to me
16:04:02 <silver1> as a below mediocre programmer I really embrace strong type systems
16:04:11 <silver1> because guess what, it makes me less likely to fuck up
16:04:16 <silver1> I guess it's the curse of the gifted
16:04:30 <silver1> they can lift all that weight with just sheer intelligence
16:04:58 <jle`> blah blah 10x programmer
16:05:31 <troydm> silver1: for instance the place I work in have lots of old timers so when I first started there we had only-Java policy and I was the only one saying we should do Scala. Fast-forward one year new CTO comes and says all new apps will be in Scala and all these ignorant old timers that were always saying for an year that they don't need Scala now feeling their job security threatened are watching vid courses
16:05:33 <troydm> about Scala to learn it...
16:06:24 <silver1> honestly even Java is better than Golang as a language. The thing at least has generics.
16:06:28 <silver1> YOU CAN USE A SET
16:06:42 <silver1> instead of a map from key to empty struct
16:06:55 <troydm> yeah Java 8 by itself is not too bad, but I feel more comfortable with Scala honestly
16:07:03 <silver1> Scala is better
16:07:23 <silver1> although my Scala knowledge is purely theoretical
16:07:35 <silver1> but then again so is my Java knowledge
16:07:41 <troydm> Golang is horrible language, I'd rather use Rust for near to system programming than Golang
16:08:03 <silver1> yeah golang is shit.. omg it's so bad... and the worst part is that go programmers are SO defensive about it
16:08:10 <silver1> about every single choice the language designers have made
16:08:36 <__Myst__> what are generics? :p
16:08:46 <silver1> __Myst__: think type classes
16:08:50 <troydm> silver1: I've tried learning it but every time I've encountered this so called choice I was like WTF are they seriously think this is usable
16:08:54 <__Myst__> it was sarcasm referring to golang silver1
16:09:12 <silver1> __Myst__: I know I just played along
16:09:19 <troydm> __Myst__: it's like templates in C++ but much more :)
16:09:40 <silver1> troydm: actually C++ templates are decent
16:09:45 <silver1> when compared to smth like generics in Java
16:09:54 <silver1> imo of course
16:09:59 <silver1> iirc Java had the weird type erasure stuff going on
16:10:08 <troydm> silver1: well generics are not too bad either, they cover most of the cases, not all but most
16:10:21 <silver1> but anyway, thanks guys for letting me vent here.... about languages and people that are irrelevant to this channel
16:10:43 <silver1> please, the next time you meet someone -- a friend, a neighbor, a stranger... just approach them, take their hand.. look into their eyes
16:10:44 <silver1> and tell them
16:10:49 <silver1> "Haskell isn't hard"
16:10:53 <silver1> "Haskell is easy"
16:11:04 <silver1> one person at a time, one community at a time
16:11:18 <troydm> yeah once you grokk Monads and Monad Transformers it's all easy-peasy
16:11:30 <silver1> monads aren't even hard
16:11:39 <silver1> start with Maybe and go from there
16:11:42 <troydm> yeah but they are confusing
16:12:04 <troydm> I had to write my own Monads in Java in order to understand them in Haskell
16:12:04 <silver1> they're somewhat abstract, but I think once you demonstrate 3 practically useful monad examples, it all clicks into place
16:12:11 <__Myst__> I mean I use haskell, I consider myself decent and I still don't fully understand monads
16:12:23 <__Myst__> I've genuinely never managed to use correctly the State monad
16:12:24 <silver1> __Myst__: what does that even mean? "understand monads"
16:12:30 <__Myst__> silver1: grok their usage
16:12:36 <silver1> it's like saying "I use functions but I don't understand them"
16:12:41 <troydm> __Myst__: try writing Monad in another language and you'll understand them quickly
16:12:47 <MarcelineVQ> a monad is a type that implements the functions  return  and  >>=  that follows the laws that equate the two
16:12:52 <silver1> I agree with troydm suggestion
16:13:38 <troydm> a lot of time ppl say what Monad is trying to explain instead of trying to explain in what way Monad can be used instead
16:13:51 <silver1> 100% agree
16:14:44 <__Myst__> I understand Monads as actions that can be chained and that potentially have some result
16:14:47 <__Myst__> or multiple
16:15:34 <troydm> __Myst__: actually that is the easiest explanation which is very near to truth
16:16:05 <__Myst__> What would be the explanation that's even closer but isn't the meme answer?
16:16:07 <troydm> __Myst__: well if you understand Java I wrote a blog post about my experience writing a Monad in Java http://troydm.github.io/blog/2015/01/25/write-you-a-monad-for-no-particular-reason-at-all/
16:16:59 <__Myst__> troydm: maybe it's just me, but I have a bit of an issue reading the first block of text
16:17:03 <__Myst__> maybe breaking it up a bit more would help
16:17:57 <jle`> __Myst__: i think you're almost right, except backwards
16:17:58 <troydm> __Myst__: yeah you are right I need to find time to go over all my blog posts and break them in paragraphs
16:18:10 <__Myst__> jle`: backwards?
16:18:12 <jle`> it's not "Monads are actions that can be chained and potentailly have some result"
16:18:26 <jle`> but rather "actions that can be chained and potentially have some result can be thought of as monads"
16:18:38 <jle`> sort of like "all squares are rectangles", but not "all rectangles are shapes"
16:18:43 <jle`> *all rectangles are squares
16:18:46 <__Myst__> So "monads can represent actions that can be chained and potentially have one or more results?"
16:18:52 <__Myst__> (the ? is meant to be outside the quotes)
16:19:01 <jle`> *some monads can...
16:19:06 <jle`> just like some rectangles can be squares
16:19:22 <jle`> at least in Haskell, most of the useful monads arise from this pattern
16:20:07 <__Myst__> troydm: just a question, your compose function is f . g -> g(f(x)), isn't the opposite true in haskell?
16:20:09 <jle`> you don't really need to really be comfortable with the platonic concept of a monad to use them effectively
16:20:28 <__Myst__> so there are monads that *don't* represent that?
16:20:32 <jle`> but it helps to know what sort of programming situations can be easily represented as monads
16:20:44 <jle`> __Myst__: yes, but it's not really worth looking for the ones that don't
16:20:58 <troydm> __Myst__: yeah it's a bit different compared to Haskell, but small difference
16:21:11 <__Myst__> alright, just wanted to make sure
16:21:13 <jle`> one obvious example is Proxy
16:21:27 <jle`> unless you think of it as a monad were every action is a no-op
16:21:32 <jle`> and nothing is ever produced
16:21:48 <jle`> but that's a bit of a stretch, and not too useful of one
16:21:58 <jle`> you don't gain much from trying to think of *all* monads as actions
16:22:11 <jle`> but you gain a lot from thinking that actions can be represented using monads
16:22:14 <__Myst__> troydm: I think an interesting approach to implementing partial application might've been to make non-unary functions return another function
16:22:22 <__Myst__> e.g. a -> b -> c => Function<A, Function<B, C>>
16:22:34 <__Myst__> jle`: Not sure what Proxy does
16:22:41 <jle`> Proxy is like Maybe without Just
16:23:01 <jle`> imagine 'data Maybe a = Nothing'
16:23:03 <jle`> that's Proxy :)
16:23:04 <troydm> __Myst__: yeah
16:23:19 <jle`> 'data Proxy a = Proxy'
16:23:34 <jle`> it has a Monad instance but it's not too helpful or productive to try to imagine it as representing actions
16:23:37 <__Myst__> that feels useless
16:23:49 <jle`> it's pretty useless as a Monad
16:23:56 <troydm> __Myst__: I've used this kind of trick to program few apps in Java 8 in functional style
16:23:59 <jle`> in Haskell, at least
16:24:06 <jle`> but it happens to just be one
16:24:06 <troydm> __Myst__: partial application I mean
16:24:08 <__Myst__> what's its use in general?
16:24:28 <jle`> it's sometimes used to help remove type ambiguity in type signatures
16:24:44 <jle`> mostly as a type system hack
16:24:51 <jle`> actually i have a cute usage of it that i haven't seen very often
16:25:03 <jle`> but it can be used as a 'zero' at the bottom of a monad transformer stack
16:25:17 <jle`> (this is an especially useless use case though :) )
16:26:12 <jle`> but in the wild, yeah, it's mostly used as a type system hack
16:28:51 <dmwit> ?unmtl RWST r w s Proxy a
16:28:51 <lambdabot> r -> s -> Proxy (a, s, w)
16:28:58 <dmwit> hm =)
16:29:05 <jle`> that's why i'm pushing for ProxyT to be in transformers :)
16:29:16 <dmwit> oh dear
16:29:44 <Welkin> jle`: you lobbyist!
16:29:54 <jle`> yeah, Identity is a 1
16:29:57 <Welkin> lobbying for Big Transformer
16:29:57 <jle`> Proxy is a 0
16:30:04 <Welkin> I mean
16:30:06 <Welkin> Big Proxy!
16:30:45 <Welkin> troydm: partial application isn't a trick, it's just normal
16:30:48 * jle` imagines monad transformer composition as a semi-nearring
16:31:10 <Welkin> I suppose that is strange to people not used to functional programming, though
16:31:28 <troydm> Welkin: yeah however in Java world it's considered a trick
16:31:41 <Welkin> It seems like people in the javascript world find ideas like partial application and function composition to be novel and exciting
16:32:10 <Welkin> they even freak out over "higher order functions" which are just... functions
16:42:36 <jle`> this just in, monad transformer composition is not a semi-nearring
16:42:48 <jle`> i tried
16:45:07 <jle`> it's just a monoid with a zero
16:49:23 <ski> silver_ : "if the system has no certs in the pool, it'll return error as nil, but also the pool as nil" -- domain contagion
16:49:39 <ski> __Myst__ : there's much to "actions that can be chained and that potentially have some result", i'd say
16:50:15 * ski tends to call this "dynamic sequencing", to distinguish from "static sequencing" (associated with idioms, aka applicative functors)
16:52:23 <silver> ski, what do you mean?
16:53:00 <Welkin> I think he means being able to decide what to do after each computation, rather than the unstoppable forward march of applicative
16:53:13 <Welkin> branching vs no branching
16:53:42 <ski> domain contagion is a term Riastradh used in his blog entry "Option types, optional parameters" in 2006-02-03 at <https://mumble.net/~campbell/blag.txt>
16:54:32 <ski> yes, that's the dynamic vs. static sequencing thing
16:55:27 <ski> and i do think that, on some level, monads *are* about sequencing. but the notion of sequencing that's involved isn't necessarily that closely connected to a notion of operational reduction order
16:56:44 <ski> the fact that some particular monads have no discernible nontrivial notion of sequencing, doesn't detract from this
16:56:49 <ski> one could say that monads are as much about sequencing, or ordering, as monoids are about sequencing, or ordering
16:57:18 <Welkin> what about warm fuzzy things?
16:57:19 <EvanR> why are we using the word sequencing
16:58:01 <Welkin> EvanR: "we" are not, ski is
16:58:09 <EvanR> generalized we
16:58:14 <Welkin> royal we?
16:58:42 <ski> a monoid is a set/type, say ⌜M⌝, with a binary operation, say ⌜(·) : M × M ⟶ M⌝, that is associative, and has a neutral element, say ⌜1 : M⌝
16:59:12 <MarcelineVQ> hey neat you should use those quotes for everything
17:00:32 <ski> what this enables you to do, is to take any finite *sequence* of elements from ⌜M⌝, say ⌜[m₀,m₁,m₂,m₃]⌝, and convert it into its "product" (or "combination", if you want to detach yourself from multiplicative terminology), ⌜m₀ · m₁ · m₂ · m₃⌝
17:01:23 <ski> where associativity guarantees that it doesn't matter how you bracket/group these interspersed operations, and where the neutral element gives you a sensible way to also convert the empty sequence
17:02:37 <ski> (where "sensible" can be interpreted as : the product of a singleton sequence is the sole element, and the product of the products of a sequence of sequences is the same as the product of the concatenated sequence -- the associativity and neutral element axioms give you exactly this, in terms of the sequence-into-product operation)
17:02:38 <EvanR> ski: odd arrow rendering... https://imgur.com/a/vF2pk
17:03:14 <ski> (it's "U+27F6 LONG RIGHTWARDS ARROW", fwiw)
17:03:19 <edwardk> ski: the thing i find frustrating is the 'they are about sequencing' view means that folks don't see things like 'round up' as a Monad when they come in with that intuition.
17:03:25 <Welkin> it's a chinese quotation mark
17:03:31 <Welkin> or japanese
17:03:56 <Welkin> french quotes are weird
17:04:24 <Welkin> edwardk: what is "round up"?
17:04:45 <edwardk> welkin: consider a category of real numbers, where x <= y    gives you your arrows
17:04:50 <ski> anyway, many monoids are commutative, ordering doesn't matter. but the monoid structure itself *allows* for non-commutative monoids, like e.g. matrix multiplication
17:05:13 <edwardk> there is a monad "ceiling':     return : x  <= ceiling x             join :: ceiling (ceiling x) <= ceiling x
17:05:52 <ski> edwardk : yes, so one must explain that "sequencing" doesn't need to look that close to what they first get in mind when they hear that term
17:06:01 <edwardk> and we can fmap. If you know (a <= b) then you know (ceiling a <= ceiling b)
17:06:07 <ski> but i do think there's something solid to the idea that sequencing is involved
17:06:46 <ski> e.g., in the list monad, "sequencing" corresponds to what one might think of as "loop nesting"
17:06:55 <edwardk> welkin: pushing on it you can find an adjunction between integers and the reals, then show that the monad from that adjunction does this round-up-and-turn-it-back-into-a-real transformation
17:07:31 <ski> > do x <- [0 .. 3]; y <- [x .. 3]; return (x,y)
17:07:34 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
17:07:35 <Welkin> edwardk: what is with all of the `<=` where I think there should be `->`
17:07:48 <EvanR> less than or equal
17:07:55 <edwardk> welkin: i described a category where the arrows are the less than or equal relationship
17:08:29 <edwardk> you'd believe x <= ceiling x   right? that isn't haskell, just sort of pseudo-haskell -- you could write it out in something like agda
17:08:58 <ski> (edwardk : and of course thinking in terms of closure operations and so on are also useful POVs, at least given the background where such things crop up)
17:09:57 <edwardk> similarly you can come up with a comonad on this category for 'floor'
17:10:22 <Welkin> I am lost on the adjunction part
17:10:28 <Welkin> I don't see what you mean
17:10:34 <ski> (edwardk : .. otoh, is that `ceiling' really computable ? :)
17:10:47 <EvanR> nope
17:10:49 <edwardk> ski: no
17:11:09 <edwardk> pick something smaller like the rationals that don't require so much hair splitting around deciding equality
17:12:13 <ski> hm, i wonder if one could use a quotient on the reals, to represent "integers" here, making it computable
17:12:52 <EvanR> since ceil is discontinuous youd expect no way to compute it
17:12:59 <EvanR> for all inputs
17:13:00 * ski . o O ( `=<' )
17:13:41 <ski> Welkin : well, do you know how monads are related to adjunctions ?
17:13:50 <edwardk> welkin: make two categories Q for <=_Rational  and Z for <=_Integer    where the former are rationals with arrows for the <= relation, mutatis mutandis for the latter. then you can have a function ceil :: Q -> Z that gives you the int you get if you round up, and 'fromInteger :: R -> Z'
17:14:37 <EvanR> toInteger ?
17:14:53 <edwardk> er fromInteger: Z -> Q
17:14:55 <ski>   fromInteger :: Z -> Q
17:15:07 <edwardk> sorry writing this out long hand without the ability to edit history =)
17:15:22 <EvanR> you have ceil :: Q -> Z and fromInteger Z -> Q
17:15:28 <edwardk> ceil . fromInteger = id
17:15:28 <EvanR> these are adjoint functors
17:16:16 <edwardk> this is enough to give you the FGF = F and GFG = G for an adjunction (galois connections always work out as particularly nice adjunctions)
17:16:24 <Welkin> ski: I'm starting to get lost in all of the terminology. an adjunction can just be a function on functors, right?
17:17:07 <ski> an adjunction situation is something that can hold, when you have two functors, in opposite directions
17:17:27 <edwardk> welkin: an adjunction is a pair of functors F    and G such that  the set of arrows  (F a -> b) is in one to one correspondence with the arrows (a -> G b)
17:17:51 <ski> it's saying something like a weaker version of : one functor is the inverse of the other
17:18:00 <edwardk> F : C -> D     and G : D -> C
17:18:14 <edwardk> where D and C are categories, F and G functors between them
17:18:29 <edwardk> we usually just write down something pithy like F -| G to denote this relationship
17:19:20 <ski> for reals `x', vs. positive reals `y', we have that `e^x = y' is equivalent to `x = ln y' .. so `(e^)' and `ln' (the natural logarithm) are inverses of each other
17:19:59 <Welkin> okay
17:20:03 <edwardk> abusing some notation if i write down something like (, e) -| (->) e  i'm saying  (a, e) -> b   is isomorphic to a -> (->) e b  = a -> e -> b      this is witnessed by the existence of curry and uncurry as inverses
17:20:18 <Welkin> so how are `ceil` and `fromInteger` inverses of each other in this situation?
17:20:29 <ski> in an adjunction (or even the simpler case of a galois connection, where you don't have categories, just partial orderings), you're saying something similar, except that instead of the bidirectional `=', you're using an inequality like `=<', or a morphism arrow (~ function type) `>--->'
17:21:14 <Welkin> ceil 3.4 = 4, fromInteger (ceil 3.4) = 4.0
17:21:20 <Welkin> how would you get back 3.4?
17:21:30 <edwardk> who said you could?
17:21:39 <edwardk> you can get into a monad easily
17:21:54 <edwardk> it can easily lose you information
17:22:24 <ski> well, if `x' is a real, and `n' an integer, then we're claiming that `ceiling x =< n' is equivalent to `x =< fromInteger n' -- or, in words : `ceiling x' is the least integer `n' whose translation back into reals is at least `x'
17:23:14 <Welkin> so what was the original point about rounding up with monads?
17:23:22 <edwardk> ceil -| fromInteger     is an adjunction
17:23:25 <ski> so, we have something like "approximate inverses". and these approximations have a *direction*. from a real number, we want the best integer that approximates it, and we're interested in approximating by rounding "upwards"
17:23:44 <edwardk> given F -| G     the composition GF is a monad, and FG is a comonad
17:24:10 <edwardk> i was stating one way how you could decompose the monad i gave for 'ceiling' into two parts
17:24:41 <Welkin> based on the definition for monad using `return` and `join`, which have nothing to do with sequencing?
17:24:54 <Welkin> rather than `return` and `bind`
17:25:09 <edwardk> yes, i was mostly trying to show a bit about how thinking about monads in terms of sequencing was somewhat self-limiting
17:25:12 <ski> (and i don't mean "approximate" in the sense that one could also pick some other function, rather than `ceiling' as the "upwards-approximate inverse of `fromInteger'" .. there can be at most one `f' such that `f' is left adjoint to `g')
17:25:30 <edwardk> as this sort of closure-operator doesn't appear much like a "common-sense" notion of a monad based on sequencing
17:25:47 <Welkin> okay, I think I see your point
17:25:51 <EvanR> if youve got a f (f (f (f ... (f a) ... ))) then you can use join n times to "sequence"
17:25:53 <sim590> Why can I write `sum (zipWith (*) [1,2] [3,4])` but it is not equivalent to `(sum . zipWith) (*) [1,2] [3,4]`
17:26:24 <geekosaur> :t sum . zipWith
17:26:25 <lambdabot> (Num ([b] -> [c]), Foldable ((->) [a])) => (a -> b -> c) -> [b] -> [c]
17:26:38 <ski> `fromInteger . ceiling' here would be the monad
17:26:40 <edwardk> given the adjunction i mentioned above    (,s) -| (->) s  -- when you put the monad together out of those halves you get State, when you put the comonad together you get Store
17:27:14 <geekosaur> :t sum . zipWith (*)
17:27:16 <lambdabot> (Num [c], Num c, Foldable ((->) [c])) => [c] -> [c]
17:27:27 <edwardk> ski: yeah i was being careful to call 'ceil' the function from Q -> Z, so i could use ceiling as the composition on : Q -> Q
17:27:59 <ski> ah, sorry, then i confused those two up :/
17:28:00 <geekosaur> notice things going wrong? (.) composes in a specific way
17:28:17 <Welkin> geekosaur: pointfree strikes again
17:28:32 <edwardk> ski: meh, just figured i'd let you in on what i was doing =)
17:28:44 <ski> and the sequencing part here corresponds to that if you have an alternating composition like `fromInteger . ceil . fromInteger . ceil' (iow `ceiling . ceiling') (or even more times), you can simplify it as just `fromInteger . ceil' (iow `ceiling')
17:28:45 <sim590> The output of `:t <thing>` is really cryptic to me still. Haskell may be concise, but it's cryptic.
17:29:15 <ski> EvanR is saying basically the same thing
17:29:20 <Welkin> sim590: it's only cryptic until you learn to understand it. Chinese must be cryptic to you too, but even a poor farmer can understand it.
17:29:33 <EvanR> cryptic isnt the right word here
17:29:47 <c_wraith> "unfamiliar"
17:29:49 <sim590> Welkin: poor farmers speak it, but don't read it. ^_-
17:30:16 <Welkin> perhaps
17:30:27 <Welkin> let me rephrase: even a child can understand it
17:30:33 <sim590> hah
17:31:15 <edwardk> anyways for deep fundamental reasons there aren't any interesting adjunctions between partial orders like this (galois connections always have that sort of idempotent comonad that is to say F.G = Id). But when we move to categories that aren't thin you can have more complicated adjunctions, they always look like that (F a -> b)  ~ (a -> G b), but they don't always have that some F . G = Id property that we have here.
17:31:22 <ski> so : `((sum .) .) . zipWith' works. `(sum . zipWith) f x y' is `sum (zipWith f) xs ys', but `(((sum .) .) . zipWith) f xs ys' is `((sum .) . zipWith f) xs ys' is `(sum . zipWith f xs) ys' is `sum (zipWith f xs ys)'
17:31:32 <ski> sim590 ^
17:31:35 <sim590> I knew that I should stop myself from saying such things even though it's good saying it for me. I knew that I would bother people. :/ I'm mad presently about haskell. Sorry.
17:32:00 <EvanR> good mad or bad mad
17:32:17 <sim590> EvanR: I'm not sure. :/
17:32:21 <Welkin> sim590: it takes time to "get it" and just requires some patience. You'll get there in no time
17:32:42 <ski> sim590 : if `zipWith' had taken a triple of a callback function, and the two lists, then what you tried would have worked
17:33:19 <ski> sim590 : iow, if it was `zipWith (f,xs,ys)', rather than `zipWith f xs ys', which really means `((zipWith f) xs) ys'
17:33:25 <edwardk> sim590: it took me the better part of 2 years to really fully internalize haskell when i first joined the community, keep throwing yourself at the wall and eventually you'll break through
17:34:29 <edwardk> on one hand there is more to learn than back then, but there are also so many more learning resources available now than back then
17:34:54 <Welkin> the more you learn, the more you will feel like you don't know
17:34:56 <sim590> edwardk: I have to master it before the end of may. I'm presently helping students with it in their course's laboratories. I'm not the teacher, but just a helper if I can say. So there's no time. I have to drill that wall.
17:35:14 <Welkin> so if you feel really dumb about haskell, that's a good thing
17:35:17 <Welkin> you probably know it well
17:35:34 <boj> sim590: times tickin', chop chop :)
17:35:43 <sim590> :D
17:35:49 <edwardk> boj: =P
17:36:10 <pacak> edwardk: fully internalize AKA rewrite half a hackage in a better quality and become successfull maintainer of it?
17:36:25 <edwardk> pacak: that took a couple more years
17:36:46 <Welkin> also, you will likely never "master" it
17:36:58 <Welkin> I don't think it is something that can be mastered, especially since it changes all the time
17:37:09 <edwardk> and nowadays really wouldn't be possible if it weren't for glguy and ryanglscott and phadej and countless others having my back
17:37:16 <ski>   \p -> do q <- f p; r <- g q; return r  :  x =< ceiling z  -|  x,y,z : |R , f : x =< ceiling y , g : y =< ceiling z
17:37:18 <Welkin> but knowing the basics will get you 80% of the way there
17:37:25 <ski> edwardk : what do you think of something like that ^ ? :)
17:38:22 <chocopuff> i'm struggling a bit with list comprehensions. For some reason, it seems to have trouble taking in large numbers. Say I have [choose 110 k | k <- [2,4,8,16,32,64]] for example
17:38:46 <chocopuff> the choose function seems to work properly, and compute all of it, but the list comprehension doesnt' return the correct choose function results
17:38:51 <edwardk> having free access to the scoping rules for that sort of thing are likely going to need something like an internal hom for the category you're running on
17:39:30 <sim590> ski: Do I really have to write it like this  (((sum .) .) . zipWith) (*) [1,2] [3,4]? There are more parenthesis than my initial (and more intuitive) approach.é
17:39:33 <ski> edwardk : aye. or restricting the scoping accordingly to something substructural or whatever
17:39:55 <edwardk> chocopuff: are your integers wrapping around?
17:40:00 <edwardk> 110 choose 64 is pretty big
17:40:01 <ski> sim590 : is there something wrong with `sum (zipWith (*) [1,2] [3,4])' ?
17:40:22 <chocopuff> edwardk: yeah, I believe that's the problem but I have no expreience with such large ints be4
17:40:35 <edwardk> what is the type of 'choose' in your code?
17:40:41 <chocopuff> I've heard of integers wrapping around, but that's the extent
17:40:45 * ski isn't sure what sim590 is attempting to do
17:41:00 <chocopuff> c :: Integral a => a -> a -> a
17:41:25 <ski> (and how do you use this list comprehension .. ?)
17:41:29 <edwardk> if you explicitly put  [choose 110 k | k <- [2 :: Integer,4,8,16,32,64]] does it work?
17:41:41 <chocopuff> aight let me try that
17:42:05 <sim590> ski: No. But I was attempting to do the same thing (which seemd logical, because I thought I may did understand the dot operator) as map (map (*5) [[1,2,3],[3,4,5]]) where I turned it to (map . map) (*5) [[1,2,3],[3,4,5]]
17:42:17 <edwardk> Int is only 32 or 64 bits long, Integer is arbitrary precision
17:42:34 <jle`> why does MVector's write take the index as the second argument, but modify take the index as the third argument
17:42:56 <chocopuff> edwardk: oh woah magic
17:42:57 <ski> > (zipWith . zipWith) (+) [[1,2,3],[3,4,5]] [[100,200,300],[300,400,500]]
17:43:00 <lambdabot>  [[101,202,303],[303,404,505]]
17:43:03 <ski> sim590 : like that ^ ?
17:43:28 <ski> @type map
17:43:30 <lambdabot> (a -> b) -> [a] -> [b]
17:43:31 <ski> @type map . map
17:43:32 <Welkin> lol ski
17:43:33 <lambdabot> (a -> b) -> [[a]] -> [[b]]
17:43:34 <ski> @type map . map . map
17:43:35 <lambdabot> (a -> b) -> [[[a]]] -> [[[b]]]
17:43:36 <edwardk> chocopuff: something you were doing was causing it to pick "Int" or something as the type there. defaulting, etc. it had nothing to do with the comprehension itself
17:43:37 <ski> @type zipWith
17:43:38 <Welkin> using compose as fmap
17:43:39 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
17:43:42 <ski> @type zipWith . zipWith
17:43:43 <lambdabot> (a -> b -> c) -> [[a]] -> [[b]] -> [[c]]
17:43:45 <ski> @type zipWith . zipWith . zipWith
17:43:47 <lambdabot> (a -> b -> c) -> [[[a]]] -> [[[b]]] -> [[[c]]]
17:44:07 <edwardk> a 32 bit int runs into problems representing numbers above a couple billion
17:44:16 <Welkin> I thought Int was 64 bit
17:44:26 <Welkin> unless your OS is really old
17:44:31 <edwardk> Welkin: depends on 32 or 64 bit platform builds
17:45:43 <ski> sim590 : `map' can be seen as converting a function of type `a -> b', into a function of type `[a] -> [b]', operating on lists. this can be iterated, by composing `map' with itself, as you saw
17:46:27 <edwardk> @let import Numeric.SpecFunctions
17:46:30 <lambdabot>  .L.hs:138:1: error:
17:46:30 <lambdabot>      Numeric.SpecFunctions: Can't be safely imported!
17:46:30 <lambdabot>      The module itself isn't safe.
17:46:32 <Welkin> well, (.) ends up being exactly `fmap` for functions
17:46:33 <ski> sim590 : similarly, `zipWith' can be seen as converting a function of type `a -> b -> c', into a function of type `[a] -> [b] -> [c]', operating on lists. this can similarly be iterated, by self-composition again
17:46:34 <edwardk> oh well
17:47:20 <sim590> ski: I'm trying to find out what I converted to what because I think that I'm making a mistake.
17:47:21 <ski> sim590 : however, if you try `sum . zipWith', then you're trying to feed a value of the return type of `zipWith', which is `[a] -> [b] -> [c]', as input to `sum', which expects a number
17:48:36 <ski> sim590 : `f (g x)' is the same as `(f . g) x'. but `f (g x y z)' isn't the same as `(f . g) x y z'
17:49:58 <ski> sim590 : your problem was that `zipWith' "takes three arguments" (there's no such thing, all functions always takes exactly one argument. `zipWith' takes a function, and returns a function that takes a list, and returns a function that takes a list, and returns a list. but that's more tedious to say, so as long as we know what we mean, we use imprecise terminology like "three arguments")
17:50:00 <chocopuff> edwardk: how do I do this with a list variable though?
17:50:05 <edwardk> anyways 110 choose 64 is around 2e31  but the maximum value representable by even a 64 bit Int is around 9e18
17:50:25 <chocopuff> it's crazy how big they get v. quickly
17:50:33 <edwardk> you can just give the type of the list as [Integer] or what have you
17:50:46 <chocopuff> like I want to do [choose 110 k | k <- listName]
17:50:56 <edwardk> or fromIntegral the Ints you are blowing up in this fashion before feeding them to choose
17:50:57 <Welkin> chocopuff: exponential growth
17:51:31 <chocopuff> Welkin: yeah. actually, I think exponential fast is slightly faster than factorial growth
17:51:37 <Welkin> which reminds me of that lecture on the exponential function filmed at CU Boulder in the 90's, titled on youtube as "The most important video you will ever watch"
17:51:59 <Welkin> I learned a lot from that one
17:52:02 <chocopuff> Welkin: very innocuous sounding title hmmm
17:52:14 <lyxia> chocopuff: factorial > exponential
17:52:17 <Welkin> it's true though
17:52:20 <sim590> ski: Okay I made a mistake. I did actually change  this map (map (*5)) [[1,2,3],[3,4,5]] to  (map . map) (*5) [[1,2,3],[3,4,5]]
17:52:50 <chocopuff> lyxia: oh right mbad yup
17:52:51 <ski> sim590 : yea, that's what my mind auto-corrected you as saying, anyway ..
17:52:52 <edwardk> chocopuff:  choose 110 <$> listName     or map (choose 110) will give, out of the box, a function Integral a => [a] -> [a]    -- but because your dynamic range is so high you really want to lock this to Integer. you can just put a signature on it, or even carefully convert the inputs that could be Ints to Integer with 'toInteger'
17:53:36 <chocopuff> it would be fine to just convert all of them to Integer to be safe right?
17:53:38 <edwardk> i'd personally write it as choose 110 . toInteger <$> myList
17:54:09 <edwardk> where myList is just a regular [Int] as you don't have much range there 0..110 are the only sensible things to 'choose'
17:54:20 <Welkin> for anyone wondering, it's this video https://www.youtube.com/watch?v=DZCm2QQZVYk
17:58:51 <Welkin> the example about the chess board and wheat grains at 4 minutes in is gold
17:59:35 <Welkin> > 2 ^ 64
17:59:38 <lambdabot>  18446744073709551616
17:59:43 <Welkin> lol
18:02:44 <sepakorayl> hello everyone, using the extensible library, ow would I reuse an existing record to create a new one by adding a new field ?
18:03:40 <Welkin> you can't modify types after they have been defined
18:03:46 <Welkin> they are closed
18:04:15 <Welkin> oh, you are using a library
18:05:09 <Welkin> I see, it uses templatehaskell
18:05:31 <Welkin> I've never heard of the extensible library
18:05:50 <Welkin> I'm not sure why you would feel the need to use that
18:06:23 <sepakorayl> writing a compiler, using them for annotations
18:12:00 <EvanR> out of nowhere one way to design a type which can be annotated is like
18:12:51 <EvanR> instead of data T = A | B X | C Y T ...
18:13:22 <EvanR> data T f = A (f ()) | B (f X) | C (f (Y,T f))
18:13:39 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/ImplementingTreesThatGrow is where ghc is going fwiw
18:14:00 <sepakorayl> I am following the trees that grow paper
18:14:00 <EvanR> f = Identity would be the same as old T, use different functors to put different things on the nodes
18:15:34 <sepakorayl> the paper allows to easily change the annotations at each stage
18:16:11 <sepakorayl> but if for instance the annotations are basically the same with the previous stage's plus an extra field you have to duplicate all the annotation types
18:17:46 <sepakorayl> something like Rawr helps a lot you basically write type instance XNodeAnnotation NextStage = XNodeAnnotation PrevStage :*: R("label" := type)
18:19:14 <sepakorayl> but I want a more mature library than Rawr, extensible seemed like a good idea.
18:21:00 <edwardk> welkin: its a good video for provoking thought. it misses some details, notably that pretty much anything that gives you exponential growth usually has some kind of carrying capacity where that model breaks, it moves the discussion out of the freshman year up to talking about differential equations and the stability of equilibria, etc. as a first-order approximation of the problem, though, its a pretty well put together argument
18:22:48 <EvanR> hmm data T a = A | B X | C Y a, data W t f = W (f (t (W t f))), type AnnotedT f = W T f
18:23:40 <edwardk> (most 'exponential' models really should be logistic)
18:34:24 <fiatjaf> is there a way to print strings (for debugging purposes) with all the special characters, like newlines?
18:34:40 <edwardk> , like, putStrLn?
18:34:44 <glguy> You can use print
18:34:49 <fiatjaf> yeah, but I want to see the newlines
18:34:50 <fiatjaf> \n
18:34:52 <fiatjaf> or whatever
18:34:57 <edwardk> print
18:35:03 <fiatjaf> ok
18:37:27 <fiatjaf> that's good
18:38:04 <fiatjaf> thank you
18:54:43 <tysonzero> What's the best way to override/jailbreak a haskell package with nix? I can't build datetime as nix is complaining about `base >=4.2 && <4.9`, so I wanted to jailbreak it, but the ways I am trying are giving me weird build errors.
18:55:24 <sm> jailbreak.. like it :)
19:02:27 <sm> tysonzero, inspiration for you: https://www.youtube.com/watch?v=oMFYs3gfgis
19:02:47 <qmm> i've never modeled data with persistent more complex than the Person examples i see regularly. how might i model store something like this? https://gist.github.com/qmmdb/770a1f670bc3f380251ac760cb102221
19:09:49 <Welkin> qmm: if you understand how those are translated to postgres types, it's easy
19:10:01 <Welkin> you can write your own instances too
19:10:29 <Welkin> to convert, for example, `Bid 0.0000079` into a double and back again
19:10:53 <Welkin> you don't need to use the template haskell functions
19:11:05 <Welkin> I write my own instances when it makes sense
19:11:44 <crestfallen> hi , apparently this book example I'm working on is called a proof of constructive induction, aka an abstract machine. could someone point out how this works as a proof? https://github.com/varreli/haskell/blob/master/hutton/77_abstractM.hs   thanks
19:12:32 <glguy> It's easier for everyone to keep track if you stick to one nickname
19:12:44 <crestfallen> glguy: sorry ok
19:13:06 <mniip> "I said the real one"
19:13:59 <n_blownapart> the somewhat confusing output is included in the paste
19:14:15 <n_blownapart> git
19:14:19 <qmm> thanks Welkin. that is motivating
19:16:00 <n_blownapart> so this uses mutual recursion which I can follow with some trepidation
19:24:38 <wroathe> So I'm playing around with wreq, and I get a compiler error saying that it couldn't match type [Char] with Data.ByteString.Internal.ByteString. The tutorial here: http://www.serpentine.com/wreq/tutorial.html recommends the OverloadedStrings pragma, which seems to work via GHCI, but not when I'm building my program. What am I doing wrong?
19:24:48 <wroathe> The pragma line is {-# LANGUAGE OverloadedStrings #-}
19:25:05 <wroathe> And it's complaining about: putStrLn $ r ^. responseStatus . statusMessage
19:25:06 <n_blownapart> darn, no takers, ciao
19:26:08 <wroathe> I understand that the types don't match, and that I'd normally have to convert them, but shouldn't that language pragma take care of that for me?
19:26:49 <tysonzero> OverloadedStrings only effects string literals like "foo", it doesn't apply to every string-related things
19:26:57 <mmaruseacph2> wroathe: the language pragma says that "asdf" can be String, ByteString, etc. but types must still match
19:27:12 <mmaruseacph2> it's so you don't have to BS.pack "asdf" for example
19:27:33 <wroathe> Oh, I see
19:28:11 <wroathe> So if I import Data.ByteString and use the putStrLn function it should work then
19:28:29 <mmaruseacph2> it won't
19:28:34 <mmaruseacph2> putStrLn :: String -> IO ()
19:28:51 <tysonzero> If you use Data.ByteString.putStrLn it will work yeah
19:29:07 <mmaruseacph2> that yes, I forgot there is one there too
19:29:11 <Welkin> or you con convert to String
19:29:58 <wroathe> Thanks guys
19:35:16 <jchia> Did this binary bug get fixed? I can't repro it but the github issue is still open. https://github.com/kolmodin/binary/issues/69
19:35:24 <jchia> λ> all (\x -> (runPut . putDoublele $ x) == (runPut . putFloat64le $ x)) [-1.23, 0.0, 1.23, 0/0, 1.0/0, (-1.0)/0]
19:35:24 <jchia> True
19:36:26 <jchia> Is this issue that the default get and put uses a weird format (but puts and gets with explicit type and endianness, e.g. 'putDoublele' are fine)?
19:36:49 <jchia> So, if I use putDoublele I'm using a portable format?
19:37:01 <jchia> λ> all (\x -> (runPut . put $ x) == (runPut . putFloat64le $ x)) [-1.23, 0.0, 1.23, 0/0, 1.0/0, (-1.0)/0]
19:37:01 <jchia> False
19:37:49 <jchia> LHS is some put function from binary and RHS is some put function from data-binary-ieee754
19:38:48 <lyxia> jchia: https://github.com/kolmodin/binary/blob/master/src/Data/Binary/Class.hs#L668
19:39:02 <lyxia> :t decodeFloat
19:39:06 <lambdabot> RealFloat a => a -> (Integer, Int)
19:39:26 <lyxia> You don't want to encode a Double as a pair of an Integer and an Int
19:39:48 <lyxia> and indeed the explicit serializers are fine
19:41:16 <jchia> lyxia: OK, I don't need to use data-binary-ieee754, then.
20:00:59 <woodson> Any sample example on shows how to call python function from haskell?
20:02:10 <cheater> hi
20:02:36 <cheater> what's a good way to get mouse coordinates that works in both linux and osx?
20:03:22 <jchia> woodson: I don't know of any immediately but I suppose you could examine the source code of FFI.Python.MessagePack
20:09:48 <cycle337> hey guys
20:10:03 <dmj`> woodson: https://github.com/nh2/call-haskell-from-anything
20:10:08 <dmj`> cycle337: hey
20:10:24 <cycle337> I was watching this nice video on simon pj
20:10:26 <cycle337> https://www.youtube.com/watch?v=ixmbkp0QEDM
20:11:02 <cycle337> and was just wondering
20:11:35 <cycle337> what are those black marble rectangles at 00:42 ?
20:11:54 <cycle337> I mean I looked up those engravings
20:11:59 <cycle337> and they seem to be patents
20:12:46 <amalloy> patents is what i would have guessed from the picture
20:13:24 <cycle337> so really ? simon pj has so many patents involved with spreadsheets ? :)
20:13:55 <amalloy> he works at microsoft, and spreadsheets have a lot in common with functional programs
20:14:05 <amalloy> so, sure, probably he had some ideas that would help excel?
20:14:07 <cycle337> and also, where can I find out more about those black squares ? :)
20:14:42 <cycle337> yeah, that makes sense amalloy what with him applying functions on a collection of cells :)
20:14:52 <amalloy> https://www.google.com/search?q=microsoft+patent+cube
20:15:48 <cycle337> oh nice !
20:16:17 <amalloy> a lot of big software companies have a similar patent program, with commemorative awards for employees who produce patents
20:16:53 <cycle337> yeah, it seems like a corporatey thing to compare sizes :))
20:18:16 <cycle337> anyway, I would've never guessed if I were to choose the world's most popular functional language
20:18:24 <cycle337> that it would be.... Excel
20:18:25 <cycle337> :))))
20:19:26 <AxelAlex> When working with pipes, do all stages have to share the same base monad?
20:22:02 <woodson> dmj: That is for calling haskell function
20:23:41 <ReinH> AxelAlex: look at the types of the pipe fittings.
20:24:20 <ReinH> e.g., the type of (
20:24:25 <ReinH> (>->)
20:25:52 <ReinH> amalloy: His patents help excel excel.
20:26:39 <ReinH> cycle337: spreadsheet engineering is fascinating
20:27:31 <ReinH> Just look at some of Felienne Hermans's publications http://www.felienne.com/publications
20:31:49 <Zemyla> Why isn't showList, in general, a good consumer?
20:33:22 <ReinH> > > take 10 $ show [1..]
20:33:25 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
20:33:34 <ReinH> > take 10 $ show [1..]
20:33:36 <lambdabot>  "[1,2,3,4,5"
20:33:39 <ReinH> Why do you think it isn't?
20:34:23 <Zemyla> ReinH: I mean in the sense that it doesn't use foldr on the list so it can absorb build-type lists.
20:35:01 <ReinH> what would the purpose of that be?
20:35:32 <Zemyla> To avoid making an intermediate list
20:36:01 <ReinH> Why would that be useful?
20:36:10 <ReinH> People tend to show tiny lists
20:36:14 <ReinH> Why bother optimizing it?
20:36:29 <Zemyla> Why bother leaving it pessimized?
20:36:42 <geekosaur> that is an odd question
20:36:50 <ReinH> Why is it pessimized?
20:36:50 <geekosaur> leaving as is is never a bother
20:36:53 <ReinH> It seems to do its job well
20:37:01 <Zemyla> Lots of containers define their show function in terms of showList (toList c).
20:37:02 <iqubic> > take 10 $ show [1..]
20:37:05 <lambdabot>  "[1,2,3,4,5"
20:37:15 <iqubic> > show $ take 10 [1..]
20:37:16 <ReinH> ok, again, the lists that get shown are vanishingly small
20:37:18 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10]"
20:37:33 <iqubic> Why are those different???
20:37:43 <ReinH> iqubic: Why do you think?
20:38:06 <iqubic> Because f(g(x)) ≠ g(f(x))
20:38:13 <ReinH> Yes
20:38:17 <iqubic> At least not in general.
20:38:27 <ReinH> what is being taken in each case?
20:38:57 <iqubic> In the first case you are taking 10 chars from an infinitely long string.
20:39:12 <ReinH> Right
20:39:14 <iqubic> In the second case you are taking 10 elements from an infinitely long list.
20:39:22 <ReinH> Does that answer your question?
20:39:27 <iqubic> yes.
20:39:31 <ReinH> Sweet.
20:39:52 <iqubic> I just didn't put it together that you could apply take to a string.
20:40:09 <iqubic> but I suppose a String is just [Char]
20:40:15 <iqubic> So it makes sense
20:40:20 <ReinH> Exactly right.
20:40:24 <Zemyla> ReinH: Because foldr is more Haskellish than iterating over each constructor of a list directly.
20:40:38 <ReinH> Ok. Submit a patch I guess.
20:41:29 <Zemyla> I'm honestly not sure how to submit patches to build a debug copy of base on Windows.
20:43:38 <ReinH> Then I suppose showList will continue being unacceptably pessimal.
20:55:06 <iqubic> :t showList
20:55:06 <iqubic>  
20:55:08 <lambdabot> Show a => [a] -> ShowS
20:55:16 <iqubic> What the heck???
20:55:35 <iqubic> > showList [1,2..10]
20:55:35 <iqubic>  
20:55:38 <lambdabot>  <[Char] -> [Char]>
20:56:04 <iqubic> > show $ showList [1,2..10]
20:56:07 <lambdabot>  "<[Char] -> [Char]>"
20:56:17 <glguy> You can play with lambdabot in /msg
21:38:23 <computato> is there a class like Functor but where map :: forall a. Something f => (f a -> g a) -> f a -> g a ?
21:40:06 <mniip> what exactly does that do
21:40:19 <mniip> looks like 'id' to me
21:41:54 <computato> yeah, it does. if i have data Foo f = Bar (f Int) (f Char) | Baz (f Boolean), and i have a function to Maybe a -> [a], i want to "map" it over my ADT
21:42:26 <computato> so Foo Maybe -> Foo ([])
21:44:52 <computato> i can write it by hand of course but i'm curious if there's a name for this (natural transformation?) or a common abstraction that generalizes this
21:46:34 <mniip> that's not quite what you said at all
21:46:49 <mniip> it is still a functor just in a higher category
21:47:26 <mniip> Fun p => (forall a . f a -> g a) -> p f -> p g
21:48:05 <mniip> base libraries don't have anything like that, but there's multiple CT-based frameworks where you can make such an instance of Functor
21:48:49 <computato> ok, can you recommend one or point me to what i should look for?
21:48:53 <mniip> not sure any of them exist as libraries on hackage though
21:48:58 <mniip> @google ekmett hask
21:48:59 <computato> hmm, ok
21:48:59 <lambdabot> https://github.com/ekmett/hask
21:49:36 <mniip> Hask.Category defines a Functor which can be higher kinded
21:49:49 <mniip> so you can lift functor morphisms (natural transformations)
21:50:17 <computato> thanks, this seems to put me in the right direction
21:50:20 <jchia> Is there no Double or Float literal value for NaN, -inf or +inf, so I have to use "0/0", "(-1/0)" and "(1/0)"?
21:50:43 <jchia> I'm wondering whether ghc will be lazy and defer the division till run-time
21:51:01 <mniip> jchia, even if, it's probably going to be a CAF
22:45:35 <cemerick> can someone explain why `readIORef stuff` yields `[()]` after this: https://repl.it/repls/PleasingEssentialKouprey
22:46:22 <cemerick> declaring `stuff` to be `IORef [String]` fixes it, but the result without that is...surprising?
22:49:28 <opqdonut> cemerick: because it's a "IORef [a]"
22:49:43 <opqdonut> cemerick: so "readIORef stuff :: [a]"
22:49:49 <opqdonut> which ghci defaults to [()]
22:49:54 <mjrosenb> can I build custom packages with cabal-install (e.g. random with profiling turned on?)
22:49:55 <opqdonut> I don't think you should use polymorphic IORefs
22:50:30 <cemerick> opqdonut: Probably not, but I wanted a quickie accumulator I could poke at from ghci, so that's what I tried first
22:51:07 <cemerick> I still don't understand how a perfectly good string gets clobbered into a nonsense value. Very much the sort of thing I'd expect a compiler error on.
22:51:41 <opqdonut> well you're basically using unsafePerformIO to do an unsafeCoerce from String to ()
22:52:05 <opqdonut> it's weird though, that modifyIORef call shouldn't type
22:52:26 <mniip> why not
22:52:28 <nshepperd1> That's why unsafePerformIO has unsafe in the name
22:52:48 <cemerick> the unsafe is being used in the definition though, not in the modification
22:52:53 <mniip> cemerick, basically never use polymorphic iorefs
22:53:33 <cemerick> mniip: that's fine, but I'm very curious as to why the compiler isn't yelling at me
22:53:45 <mniip> you didn't violate type correctness
22:53:52 <opqdonut> yeah the IORef API should be built differently so that you could type it safely
22:54:05 <mniip> you made a value of type 'forall a. IORef a'
22:54:12 <mniip> something not normally possible
22:54:23 <mniip> er, IORef [a]
22:54:27 <mniip> but the same basically
22:54:28 <cemerick> mniip: I consed a string onto Nil, that's not [()]
22:55:03 <mniip> you've effectively coerced String to ()
22:55:22 <cemerick> which I'd understand if the modify was within an unsafe
22:56:05 <cemerick> (actually, I don't understand that either, insofar as String and () are unrelated AFAIK?)
22:56:49 <kadoban> :-/
22:56:54 <opqdonut> the problem is somehow doing that on the top level using unsafePerformIO
22:57:19 <nshepperd1> The coercion is when you wrote readIORef stuff in the console and it defaulted the type to ()
22:57:25 <opqdonut> because this doesn't work: http://lpaste.net/361977
22:58:20 <nshepperd1> opqdonut: ghc should get an extension that lets you "safely" execute IO actions at the top level
22:58:36 <nshepperd1> Instead of using unsafePerformIO
22:59:40 <nshepperd1> Then we could assure that the result wouldn't be unreasonably polymorphic
22:59:49 <cemerick> FWIW, this derived from ma copypasta from https://wiki.haskell.org/Top_level_mutable_state
23:00:14 <nshepperd1> (And also concerns about assuring sharing would go away)
23:01:00 <opqdonut> cemerick: sure, yeah, the toplevel unsafePerformIO newIORef is a well-known trick
23:01:10 <opqdonut> cemerick: and it works if you don't use a polymorphic type
23:01:21 <cemerick> so I discovered! :-P
23:01:28 <opqdonut> I'm trying to understand why exactly it breaks with a polymorphic type but I'm not quite there yet...
23:01:50 <opqdonut> certainly you can't reproduce the same behaviour with just normal do-notation
23:02:01 <opqdonut> you get a type error since the [a] gets unified to [String] in that context
23:03:33 <amalloy> cemerick: you may be interested by: readIORef stuff :: IO [String]
23:04:11 <cemerick> lol
23:04:16 <nshepperd1> Normal monadic use of IO prevents you from creating such polymorphic references
23:04:20 <cemerick> amalloy: well, that's just silly :-D
23:04:21 <amalloy> the problem does not arise when you add the value to the list (in that context, the compiler knows stuff :: IORef [String]). but when you try to print it, ghc has to pick a type to use to display it
23:04:34 <opqdonut> here's what happens when you try to do this without unsafePerformIO
23:04:36 <amalloy> and you said stuff was of type IORef [a] for any a, and the simplest a to fill in is ()
23:04:37 <opqdonut> http://lpaste.net/361977
23:04:47 <opqdonut> 'type variable ‘c’ would escape its scope`
23:05:12 <amalloy> so it goes to print what is actually a [String], but it thinks it is a [()]
23:05:17 <amalloy> (because you cheated)
23:05:46 <nshepperd1> :t (>>=) -- because this is rank1
23:05:46 <opqdonut> so yeah the normal IORef API can't be abused like this
23:05:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:05:50 <opqdonut> nshepperd1: yep
23:06:03 <opqdonut> yeah you can't pass polymorphic stuff via >>=
23:06:12 <opqdonut> but you can do it via toplevel unsafePerformIO
23:06:14 <opqdonut> that's the answer
23:06:21 <cemerick> amalloy: lol, (readIORef stuff) :: IO[Int]
23:06:49 <opqdonut> yeah, haskell doesn't have runtime type checks
23:06:52 <opqdonut> it trusts the compiler
23:06:58 <opqdonut> that could've been a segmentation fault or something
23:07:28 <amalloy> well, interpreting a String as an Int is usually fine. the reverse could be a problem
23:07:40 * cemerick waits for someone to implement rowhammer using a polymorphic IORef 
23:12:17 <cemerick> thanks for the explanations, everyone :-)
23:12:20 <mniip> % unsafeCoerce [] :: Int
23:12:20 <yahb> mniip: 139801802177256
23:15:41 <xacktm> yahb = yet another haskell bot?  what's differentiates it from lambdabot?
23:16:18 <centril> I've been reading "Shrinking and Showing Functions" by Koen Claessen and it was an interesting read.. Do you know of any developments and improvements in this area? I found this slide http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/26/slides/koen.pdf which talks about more shrinking methods and about higher order functions but does not go into detail
23:16:47 <centril> the paper: http://dl.acm.org/citation.cfm?id=2364516
23:17:13 <mniip> xacktm, it's a ghci session
23:17:44 <mniip> also you might notice an overwhelming presence of unsafeCoerce and other fun stuff
23:18:32 <xacktm> ah, raw and unfiltered, nice :P
23:19:19 <pdxleif> @hoogle (Int -> String) -> f Int -> f String
23:19:20 <lambdabot> HsDev.Tools.Base matchRx :: String -> String -> Maybe (Int -> Maybe String)
23:19:20 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
23:19:20 <lambdabot> GHC.OldList findIndex :: (a -> Bool) -> [a] -> Maybe Int
23:20:09 <pdxleif> Why doesn't that just say `fmap`? None of those look like what I asked for. I don't understand computers anymore...
23:21:20 <mniip> pdxleif, you didn't specify Functor
23:21:25 <pdxleif> Oh, maybe String being an alias for [Char] makes things look weird.
23:21:35 <mniip> there's no formal way to understand what you meant
23:21:50 <pdxleif> Add a functor constraint on f?
23:22:12 <mniip> not saying it would help but without it there's definitely no way for it go guess fmap
23:22:45 <pdxleif> But I'm thinking of the use case where I don't already know the name of the class. I want to search all available functions and methods.
23:22:53 <pdxleif> It can certainly guess 'fmap'.
23:23:04 <pdxleif> @hoogle (a -> b) -> f a -> f b
23:23:05 <lambdabot> Data.GI.Base.ShortPrelude (>>=) :: m a -> (a -> m b) -> m b
23:23:05 <lambdabot> Data.Function.Between.Lazy withIn :: ((a -> b -> r) -> r) -> (a -> b -> r) -> r
23:23:05 <lambdabot> Data.Function.Between.Strict withIn :: ((a -> b -> r) -> r) -> (a -> b -> r) -> r
23:23:12 <pdxleif> Well, try it online.
23:23:19 <pdxleif> On the website I mean.
23:23:38 <pdxleif> @hoogle (Int -> Float) -> f Int -> f Float
23:23:39 <lambdabot> Numeric.Probability.Percentage liftP2 :: (Float -> Float -> Float) -> T -> T -> T
23:23:39 <lambdabot> Numeric.Probability.Visualize metaTuple :: [Float] -> [(Float, Float)] -> [(Float, Float)]
23:23:39 <lambdabot> GI.Gtk.Objects.Entry entrySetAlignment :: (HasCallStack, MonadIO m, IsEntry a) => a -> Float -> m ()
23:24:11 <mniip> all available functions and filter them by what?
23:24:21 <pdxleif> So this gives different results than the website does. But at least these results make more sense than the one with String.
23:24:48 <pdxleif> Err, entrySetAlignment makes no sense as a result to me.
23:25:04 <pdxleif> whatever can fulfil the type I'm querying by.
23:25:30 <mniip> but fmap can't fulfil that
23:25:31 <pdxleif> It pulls up `fmap` on the website: e.g https://www.haskell.org/hoogle/?hoogle=%28Int+-%3E+Float%29+-%3E+f+Int+-%3E+f+Float
23:26:17 <pdxleif> That's the signature for fmap with 'Int' for 'a' and 'Float' for 'b'.
23:26:19 <mniip> no
23:26:25 <mniip> it's missing Functor f
23:26:45 <mniip> I mean
23:26:54 <pdxleif> It's able to find that.
23:27:00 <mniip> id is the signature for 'undefined' with (a ~ b -> b)
23:27:10 <pdxleif> If I already knew the name of the class, I wouldn't be searching for that.
23:27:11 <mniip> context is crucial
23:27:43 <pdxleif> It works in Idris, too.
23:27:46 <mniip> searching functions by their unqualified type isn't going to be very...useful
23:27:51 <mniip> a -> a -> a
23:27:54 <mniip> could be god knows what
23:28:17 <pdxleif> hoogle works on that.
23:28:23 <pdxleif> It also works in idris.
23:28:23 <mniip> there's probably a hundred functions with a type of that shape in base alone
23:28:47 <pdxleif> :search (f : Type -> Type) -> (a -> b) -> f a -> f b
23:29:11 <MarcelineVQ> idribot doesn't live in here :>
23:29:38 <pdxleif> I know. I'm just saying searching for methods is a reasonable thing to do.
23:30:05 <centril> Hmm... Guess I'll just go and ask Koen today then :/
23:30:59 <pdxleif> fmap is a more specific case of the pattern I'm searching for. What I searched for doesn't have a constraint on 'f'.
23:31:38 <mniip> without a constraint on a *->* type a function is going to be quite useless
23:31:42 <pdxleif> I mean, hoogle also tell me 'map' for the above - which is even more specific.
23:31:43 <MarcelineVQ> I'm not sure you can do  (f :: * -> *) -> (a -> b) -> f a ->​f b on hoogle
23:32:36 <pdxleif> Yeah, it gives a syntax error there. Just asking for (a -> b) -> f a -> f b works fine.
23:32:50 <mniip> haskell doesn't have dependent types
23:32:59 <pdxleif> It has a kind signature flag.
23:33:13 <mniip> tyvar quantifiers need to be irrelevant anyway
23:33:16 <pdxleif> but that would be in a different namespace.
23:33:17 <mniip> forall. not ->
