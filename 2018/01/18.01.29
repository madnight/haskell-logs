00:01:54 <robstr> glguy: Thank you, funny thing, laws regarding applicative are the next chapter :P
00:07:48 <MarcelineVQ> robstr: what version of the book do you have and what section is this exercise in?
00:11:26 <jle`> wait, why would a book ask you to write an applicative instance before telling you what applicative is
00:12:40 <robstr> Its version 2016 page ¬± 651
00:14:32 <robstr> they compare applicative vs functor , give a few examples , say that applicative functors are monoidal functors then few examples (where I'm currently ) and then they define all laws in detail i think
00:15:31 <kadoban> Doesn't necessarily seem like you'd have to go into the laws before looking at some examples, though I do wonder if that makes some of the exercises a bit more ambiguous
00:15:39 <MarcelineVQ> 2k pages? ereader version I guess, what section though?
00:15:58 <MarcelineVQ> oh you mean year maybe hehe
00:16:11 <robstr> MarcelineVQ: Applicative
00:16:19 <robstr> the book has arround 1k pages
00:16:52 <robstr> at lest the types line up :P
00:16:56 <robstr> least
00:20:47 <asheshambasta> which web-framework would be good for a beginner starting out on a first Haskell project?
00:21:52 <cocreature> asheshambasta: "scotty" is probably the easiest for a beginner
00:22:51 <asheshambasta> cocreature: thanks!
00:24:06 <tdammers> asheshambasta: second that. Scotty, or code directly against WAI
00:44:01 <ertes-w> asheshambasta: scotty is a good choice, but just to provide some diversity: snap-server (not the whole snap framework) is similarly simple, but the way it composes handlers is different
00:51:59 <asheshambasta> ertes-w: thanks, I'll give that a try as well. I'm writing something that is meant to be very lightweight and run on a Raspberry Pi: exposing a web interface to debug ongoing things.
01:31:54 <ph88> out of curiousity i wonder how acceleratehs compares to futhark, does someone know ?
01:32:56 <jchia> MarcelineVQ: Thanks.
01:35:22 <merijn> hmmm, is there a way to "chunk" conduit processing without reifying an intermediate data structure like a list?
01:35:30 <merijn> There's groupBy, but that makes a list
01:35:51 <merijn> I basically wanna do "run this sink while this predicate holds" and then start a new sink
01:37:05 <Athas> ph88: Futhark is much less convenient to use from Haskell.
01:37:42 <ph88> oh ok
01:38:15 <ph88> similar features though ?
01:38:53 <Athas> They are more similar than different, sure.  The main difference is probably that Futhark supports nested parallelism.
01:40:16 <Athas> Accelerate's major advantage is that it has Haskell as a meta-language, so you can do all kinds of neat tricks where you generate Accelerate code semi-dynamically.
01:40:25 <Athas> This allows you to express things like unrolling or partial evaluation in a natural way.
01:40:47 <Athas> With Futhark, you are more dependent on the compiler (but that has other advantages).
01:41:16 <merijn> I'm gonna need trigger warnings on GPU discussion >.> ICS deadline is today, and my new updated benchmarks seem to have completely fucked up my model and ruined my publication >.>
01:41:42 <Athas> merijn: your publication is just a 'git revert' away!
01:42:05 <ph88> merijn, maybe you can do something with resumablesource, also check out these pages https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview https://haskell-lang.org/library/conduit
01:42:07 <merijn> Athas: Yeah, but then'd I be publishing numbers I know are wrong :\
01:42:22 <Athas> merijn: that's what final versions are for!
01:42:24 <ph88> what's nested parallelism ?
01:42:43 <Athas> ph88: in simple terms, e.g. mapping with a function that itself contains a map.
01:42:49 <merijn> ph88: Those resources are way to basic for what I want
01:42:52 <ggVGc> merijn: just put YMMV here and there
01:42:53 <ggVGc> you'e good
01:43:14 <merijn> ph88: But I think I can hack something up using concatMapAccum
01:43:33 <ph88> merijn, you can maybe connect another sink with resumablesource
02:00:50 <Bish> somebody explain to me, whats up with those dudes on the cover of functional programming books
02:02:23 <cocreature> Bish: which books are you referring to?
02:02:31 <Bish> https://books.google.de/books/about/Functional_Reactive_Programming.html?id=aO0zrgEACAAJ&source=kp_cover&redir_esc=y
02:02:35 <Bish> a.e.
02:03:09 <cocreature> that‚Äôs just the way manning (the publisher) likes to make their book covers
02:03:23 <Bish> odd
02:03:25 <cocreature> regardless of whether they are about functional programming or not
02:03:42 <Athas> O'Reilly has their animals, and Manning has those Ottoman woodcuts.
02:06:42 <anohigisavay> hello!
02:08:28 <anohigisavay> so i read from wikipedia about bottom type. seems the bottom type in Haskell is `data Void`
02:08:45 <anohigisavay> it also says the bottom type is the subtype of all types
02:09:02 <ski> there is no subtyping in Haskell
02:09:31 <anohigisavay> _(:–∑„Äç‚à†)_ i see
02:12:32 <anohigisavay> in languages that support subtyping, can i define an empty type that is not a subtype of all types?
02:13:58 <infinisil> Bish: TDD by Edwin Brady also has such a cover: https://www.manning.com/books/type-driven-development-with-idris
02:21:13 <Bish> Athas: kinda creepy, isn't it?
02:21:19 <osa1> anohigisavay: you mean supertype? empty type can't be subtype of anything other than itself
02:23:04 <osa1> actually I'm not sure what do you mean by empty type in this context so nvm
02:23:51 <anohigisavay> osa1, i just thought bottom type and empty type are exactly the same thing
02:24:53 <anohigisavay> but i can (i think) declare an empty type without declaring it's supertypes so it is not a subtype of anything else
02:28:24 <anohigisavay> osa1, so for example in Scala (not even sure it makes sense because i have had no experience with Scala at all): i just write `type Void`
02:30:52 <ertes-w> anohigisavay: "bottom type" is ambiguous‚Ä¶  "empty type" or "void type" is what you would usually call it
02:33:29 <anohigisavay> ertes-w, can i interpret it like this: "empty type" / "void type" means the type with no value, and "bottom type" emphasizes on the subtyping aspect?
02:33:46 <anohigisavay> (forgive my bad english)
02:33:46 <ertes-w> anohigisavay: no
02:33:49 <osa1> hmm yeah I think it may make sense to make it subtype of all types. the only way to construct a term of that type is via a bottom value (e.g. undefined) which is already have type (forall a . a) in Haskell for example.
02:33:58 <ertes-w> anohigisavay: just avoid "bottom type" altogether
02:34:58 <anohigisavay> ertes-w, i see,_(:–∑„Äç‚à†)_ thanks
02:35:47 <anohigisavay> osa1, but in higher order functions or generic types that involve co/contra-variance it may not work as intended
02:36:06 <ertes-w> i have a hard time reasoning about subtyping
02:36:19 <osa1> anohigisavay: any examples?
02:37:10 <anohigisavay> for example i have a func :: (Int -> Int) -> Int, i can't compile if i pass (undefined :: Int -> Void)
02:37:20 <anohigisavay> (assuming it's a language that supports subtyping)
02:37:29 <osa1> I'm not expert so I may be talking nonsense. my thought process is like: if I can pass B to a function that expects A then B < A.
02:37:47 <osa1> hmm right
02:38:28 <merijn> hmmm, there's no mutable zipWith for Vectors?
02:39:50 <osa1> anohigisavay: wait, why not? in Int -> Void, Int is supertype of Int and Void is subtype of Int so it should be OK.
02:40:09 <osa1> I think you mean undefined :: Void -> Int
02:40:19 <anohigisavay> osa1, yes, if Void is a bottom type
02:40:31 <anohigisavay> but it's just an empty type i randomly defined
02:41:25 <ertes-w> merijn: overwriting or copying?
02:42:00 <osa1> anyways I don't know the answer but I'm curious as well. I'd look for languages with bottom values (e.g. lazy languages) and subtyping. not sure if such a language exists.
02:42:21 <kahlil29> if I have a generalized function that is used in a fold (foldl' to be specific) and the accumulator that can be passed to the function/fold is either a 2-tuple(of type Int)  i.e. (0,0) or an empty list [] , how do I perform the accumulation in this function? Is there a way by which I can check and verify that it's getting a tuple or a list as the accumulator?
02:43:26 <anohigisavay> osa1, a quick google search shows that Scala has bottom values (Nothing) and subtyping (type X <: Y)
02:43:54 <osa1> anohigisavay: so, what's the subtyping relation between Nothing and other types?
02:43:54 <anohigisavay> so in the example above, if i replace Void with Nothing it should work as intended
02:44:11 <ertes-w> kahlil29: what's the type of the accumulator?
02:44:52 <osa1> anohigisavay: you can pass Int -> Nothing to a function that expects Int -> Int ? if so that means Nothing < Int
02:44:54 <anohigisavay> osa1, (from scala doc): Nothing is a subtype of every other type (including Null); there exist no instances of this type.
02:45:03 <osa1> right
02:45:46 <kahlil29> ertes-w: it is not fixed. This folding function (custom fold function) can be called from 2 top-level functions (one of which passes acc as (Int,Int) and the other a list [])
02:46:12 <anohigisavay> osa1, and it does not prohibit me from defining a `type Void` (i suppose)
02:46:23 <ertes-w> kahlil29: it still needs to have a type, even if it's polymorphic
02:46:49 <osa1> anohigisavay: I'd expect so, it'd be just another name for Nothing
02:47:59 <kahlil29> ertes-w: Not really . I have written and compiled code where the function's argument and return type is a generic type `b` ... e.g. foldScore :: b -> Sometype -> b
02:48:12 <kahlil29> since foldl
02:48:12 <osa1> but I guess in that case both Nothing <: Void and Void <: Nothing would hold. not sure if that causes any problems with type checking or inference or something.
02:48:41 <kahlil29> ertes-w : since it satisfies foldl' signature of (b -> a -> b) , it compiles and works.
02:49:09 <ertes-w> kahlil29: so you're not doing anything to the accumulator during iteration?
02:49:38 <anohigisavay> osa1, i don't have a scala environment but i'll give it a try when i have time
02:50:05 <kahlil29> Now i want to and that's where my problem arises :P I want to check if it's a tuple or list and accordingly handle the actual accumulation accordingly (had previously done the actul accumulation at the top-level which was not really correct)
02:50:13 <kahlil29> ertes-w : ^^
02:50:20 <ertes-w> kahlil29: id :: a -> a  -- do you see why this function can only return its argument unmodified (discounting bottoms)?
02:51:16 <kahlil29> ertes-w : I think so, not fully sure what you're getting at
02:51:58 <ertes-w> kahlil29: the problem is:  if it wants to prepend an Integer, it needs to make assumptions on 'a', namely "i have a function that can prepend an Integer"
02:52:08 <ertes-w> kahlil29: and that changes the type signature:
02:52:19 <ertes-w> f :: (Integer -> a -> a) -> a -> a
02:52:38 <ertes-w> f prepend x = prepend 5 x
02:53:13 <ertes-w> kahlil29: or if you want to do basic arithmetic, you assume a Num instance
02:53:18 <ertes-w> g :: (Num a) => a -> a
02:53:20 <ertes-w> g x = x + x
02:53:54 <ertes-w> kahlil29: so whatever operation you want to perform you either add a suitable constraint, or you take the modification functions as additional arguments
02:53:54 <kahlil29> ertes-w :  so you're saying I need to have a typeclass constraint ?
02:54:36 <ertes-w> not necessarily a constraint‚Ä¶  you can take functions explicitly
02:54:57 <ertes-w> what's best depends on what exactly you want to do to the accumulator
02:56:43 <kahlil29> ertes-w : that's actually  what I had done. I was passing a lambda to the folding function and each top-level function had the lambda implemented differently .So the lambda was being invoked on the last line of the folding function but then the accumulation was being done back at the top-level function and that seems conceptually wrong. So I tried to shift the accumulation logic to the custom folding function but got stuck with this issue.
02:58:15 <ertes-w> kahlil29: i don't really understand what you mean‚Ä¶  could you paste your code?
02:58:21 <ertes-w> the one you thought was wrong
02:58:45 <kahlil29> yes hold on.
03:01:45 <ski> osa1 : O'Haskell ?
03:01:48 <ski> anohigisavay : iiuc, `Nothing' is a type in Scala, not a value ?
03:02:43 <kahlil29> ertes-w : http://lpaste.net/1198091542514892800 ignore the removeDuplicates function for now. the top level functions are `avgMarks` and `invalidScoreChecker` . the custom fold fn is `foldScores`
03:03:39 <osa1> ski: thanks, I wasn't aware of it. anohigisavay may be interested
03:04:17 <ski> possibly Timber as well
03:04:43 <ertes-w> kahlil29: conceptually this looks fine to me
03:05:14 <ertes-w> kahlil29: the common pattern in your folds is the folding function, not the fold itself, and you're abstracting over it
03:05:39 <ski> @where O'Haskell
03:05:39 <lambdabot> extension to Haskell adding subtyping and records, plus non-blocking reactive communication, by Johan Nordlander, Magnus Carlsson, and Bjˆrn von Sydow, at <http://web.archive.org/web/20090517021445/
03:05:39 <lambdabot> http://www.cs.chalmers.se/~nordland/ohaskell/>, also see `Timber'
03:05:41 <ski> @where Timber
03:05:41 <lambdabot> concurrent, reactive, event-driven language that was inspired by O'Haskell, <http://timber-lang.org/home.html>. also see `O'Haskell'
03:07:30 <ertes-w> kahlil29: put differently: 'foldScores' is a template for two similar folding functions, and it abstracts over the things that are different‚Ä¶  you're abstracting exactly on the right level here
03:10:36 <anohigisavay> sorry was away from keyboard
03:11:55 <anohigisavay> wow thanks :D
03:14:49 <kahlil29> ertes-w : I'm glad you see it that way but I showed this code to someone and I was told that the application of the lambda that I am passing to `foldScores` should not be applied at the first or last step.
03:16:36 <anohigisavay> ski, yes, and the bottom value is `???` (defined as: `def ??? : Nothing = throw new NotImplementedError`)
03:17:50 <ski> is that delayed ?
03:18:06 <TMA> When I was taught haskell, we were told that bottom is defined as: bot = bot
03:18:30 <ski> that's one way to define a bottom value in Haskell
03:18:40 <ski> (anohigisavay was talking about Scala)
03:18:51 <kahlil29> ertes-w: I can only assume from that, that my accumulation also needs to be abstracted out so that my call to the lambda is not the last step. Can't think of any other change that would make the lambda invocation to not be the last call there.
03:19:07 <anohigisavay> ski, I don't think so. i think it's more used as a placeholder that shuts up the compiler first
03:19:24 <kahlil29> ertes-w : any other perspective on this would be appreciated :)
03:19:36 <ski> anohigisavay, ok
03:21:46 <ski> (another would be, say `undefined | False = undefined', or `undefined = error "Prelude.undefined". both of which would be aborting, rather that getting stuck in nontermination. but all of these are counted as bottom values in Haskell)
03:30:23 <AWizzArd> Do Rank-N types ever make sense in a context of non-function values? Examples I have seen always involve a forall and then something with a -> arrow.
03:31:20 <anohigisavay> i am personally not a fan of `undefined | False = undefined`. it is defined in a partial pattern and produces ugly error message ("Non-exhaustive patterns")
03:31:59 <ski> it's just an example of a partial definition
03:34:04 <phadej> :t [] :: forall a. [a]
03:34:05 <lambdabot> [a]
03:34:07 <ski> AWizzArd : you need a function, but its argument doesn't have to be a (polymorphic) function
03:35:19 <phadej> :t undefined :: (forall a. [a] -> Int) -> ()
03:35:21 <lambdabot> error:
03:35:22 <lambdabot>     ‚Ä¢ Cannot instantiate unification variable ‚Äòa0‚Äô
03:35:22 <lambdabot>       with a type involving foralls: (forall a. [a] -> Int) -> ()
03:35:35 <phadej> :t (\_ -> ()) :: (forall a. [a] -> Int) -> ()
03:35:37 <lambdabot> (forall a. [a] -> Int) -> ()
03:36:03 <ski> i wonder whether something like `(forall a. ExceptT e (StateT s m) a) -> ...' could be sensible
03:36:27 <phadej> ski: it is
03:37:02 <phadej> :t (\xs -> length xs) :: (forall a. [a]) -> Int
03:37:03 <wz1000> AWizzArd: f :: (forall a. Maybe a) -> () accepts values like Nothing, undefined and Just undefined
03:37:03 <lambdabot> (forall a. [a]) -> Int
03:39:43 <AWizzArd> Thanks for the examples!
03:47:53 <dminuoso> Mmm. What exactly is an Iso? Ive been trying to make sense of basically any of them, but only `non` seems clear what it does.
03:49:05 <phadej> dminuoso: Iso' s a ~ (s -> a, a -> s)
03:49:19 <dminuoso> phadej: oh.
03:49:57 <phadej> (with (f, g) having laws f . g = id, g . f = id)
03:50:33 <dminuoso> So basically it really is just a plain isomorphism.
03:50:38 <phadej> yes
03:51:20 <phadej> though as with lenses, you can have incorrect (unlawful) values
03:52:03 <merijn> bleh... I wish we had an division operator that took any input and just converted them to Fractional for me :\
03:52:20 <phadej> > 5 ^. adding 10 :: Int
03:52:23 <lambdabot>  15
03:52:26 <phadej> > 15 ^. from (adding 10) :: Int
03:52:29 <lambdabot>  5
03:52:40 <phadej> 5 ^. adding 10 . from (adding 10) :: Int
03:52:49 <phadej> > 5 ^. adding 10 . from (adding 10) :: Int
03:52:53 <lambdabot>  5
03:53:47 <ertes-w> kahlil29: well, to answer that i have too little problem-specific knowledge
03:54:28 <ertes-w> kahlil29: so you want to do something at the last step of folding?
03:54:34 <ertes-w> *something different
03:55:15 <dminuoso> phadej: How is that unlawful?
03:55:25 <dminuoso> phadej: Or was that just a random example for a simple Iso?
03:55:31 <phadej> latter
03:55:34 <phadej> unlawful would be
03:55:39 <phadej> :t iso
03:55:41 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
03:55:50 <phadej> > :t iso (+2) (+2)
03:55:54 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
03:55:58 <phadej> :t iso (+2) (+2)
03:55:59 <lambdabot> (Functor f, Profunctor p, Num t, Num a) => p a (f t) -> p a (f t)
03:56:36 <phadej> let i x = iso (+2) (+2) x in (5 :: Int) ^. i . from i
03:56:38 <phadej> > let i x = iso (+2) (+2) x in (5 :: Int) ^. i . from i
03:56:41 <lambdabot>  9
03:56:57 <dminuoso> phadej: Ah yeah. So generally with type families its my job to ensure that the laws are fulfilled.
03:57:03 <dminuoso> *lens families
03:57:15 <phadej> yes
03:57:42 <dminuoso> phadej: Alright. Thank you very much, that was helpful.
03:57:46 <phadej> cheers
04:04:08 <kahlil29> ertes-w: Just shift the accumulation into the foldScores function to make it an actual "folding" function
04:56:13 <makalu> when using stack, if I have a local path in extra-deps or packages, can I tell stack to build it in the .stack-work of the stack.yaml directory that refers to the package? Currently stack creates a separate .stack-work for each extra-dep/package
05:02:19 <phadej> makalu: Not atm to my knowledge, there was discussion to use single `.stack-work` for the project (not per package), but I cannot find the right ticket atm
05:02:46 <power-fungus> using stack lts-10.4, I cannot install ghc-mod. Its some form of dependency error. See: https://pastebin.com/BGq1dVVs
05:04:16 <makalu> phadej: I have this problem where two different projects refer to the same dependency in their stack.yaml files. They are built in parallel (two 'stack' processes) and I think they might mess up the dependency's .stack-work because it's not locked? Only .stack is locked when STACK_LOCK=true?
05:04:54 <phadej> makalu: you can use --workdir=.stack-work1 and 2 to have separate .stack-work
05:05:56 <cocreature> power-fungus: ghc-mod doesn‚Äôt support GHC 8.2
05:06:26 <makalu> phadej: thanks for the suggestion. I'll think how it would work out. I was also thinking about building all components in one superproject instead of multiple stack projects.
05:07:07 <phadej> makalu: the latter is probably a good idea
05:28:16 <concaveirc> I am trying to implement parallelism by using Eval to evaluate the elements of a list in parallel.
05:28:55 <concaveirc> However, unless I explicitly divide the task into 8 (number of cores) threads and concatenate the results, phe process gets killed.
05:29:40 <concaveirc> According to http://chimera.labs.oreilly.com/books/1230000000929/ch02.html, the loads should be dynamically distributed given +RTS -N8.
05:30:10 <concaveirc> Does process killing and parallelism ring a bell to anyone?
05:31:28 <ertes-w> concaveirc: "gets killed"?  what's the symptom?
05:31:56 <concaveirc> $ stack exec concavegenes-exe -- +RTS -N8
05:31:58 <concaveirc> [1]    11150 killed     stack exec concavegenes-exe -- +RTS -N8
05:31:58 <concaveirc>  
05:32:53 <flux> concaveirc, linux? what does dmesg say?
05:33:17 <concaveirc> I assume that this is due to too many threads being started, because evaluating a smaller list in parallel works.
05:33:18 <concaveirc> dmesg:
05:33:21 <concaveirc>  Out of memory: Kill process 11150 (concavegenes-ex) score 814 or sacrifice child
05:33:21 <concaveirc> [56199.450844] Killed process 11150 (concavegenes-ex) total-vm:1075266584kB, anon-rss:14095732kB, file-rss:0kB, shmem-rss:0kB
05:33:21 <concaveirc>  
05:33:30 <flux> bingo?-)
05:34:12 <int-e> So out of memory, 14GB rss, yay.
05:34:34 <concaveirc> I guess. However, I can get this to not happen by modifying the code to use 8 threads and combine the results later.
05:35:08 <concaveirc> The part where hardcoding is doing a better job than the automatic dynamic allocation makes me believe I am still doing something wrong.
05:35:30 <ertes-w> concaveirc: if you say -N8, only around 8 OS threads will be created‚Ä¶  however, sparks do have a cost of their own
05:36:22 <concaveirc> Are sparks the things which signal the end of a computation? I have not read too much into the literature yet.
05:36:36 <ertes-w> concaveirc: it's fine to create more sparks than threads, but you should pick a small constant factor and try not to exceed it
05:37:00 <ertes-w> concaveirc: no, a spark is kind of a "potentially parallel thunk"
05:37:10 <int-e> concaveirc: each `par` creates a spark, basically; there are worker threads that look for available sparks and evaluate them
05:37:37 <concaveirc> I see. Considering I am trying to do something involving shuffling a 6000 character string 100 times, I guess that is a lot of sparks.
05:37:45 <ertes-w> concaveirc: usually having 10-100 times as many sparks as threads is a good number‚Ä¶  the closer you get to the number of threads the better
05:38:03 <ertes-w> concaveirc: that's why in general you shouldn't create a spark for every single list element
05:38:38 <concaveirc> Is there a more elegant way to avoid the issue that is not specifying an amount of threads in a function and dividing up the task?
05:38:49 <concaveirc> Or sparks, in this case.
05:39:13 <ertes-w> concaveirc: if you can divide and conquer, do it, but stop parallelising beyond a certain level
05:39:33 <ertes-w> binary divide, stop after level 3 ‚Üí 8 sparks
05:39:58 <concaveirc> Ok. If I read into the chapters involving GPU acceleration, would the issue be to some degree allevated by having more threads available?
05:40:33 <concaveirc> Binary divide?
05:41:45 <phadej> 1 = half + half
05:41:53 <int-e> ertes-w: if the size of the parts is uneven and hard to predict, subdividing a bit further is probably helpful.
05:42:15 <int-e> (but I'd aim for hundreds of sparks, not millions)
05:42:48 <concaveirc> Ok
05:44:28 <concaveirc> Thanks everyone, it seems I have a bit more to read about.
05:49:11 <ertes-w> int-e: yeah, hence the factor 10-100
06:28:42 <Darwin226> Is there a convenient way to apply a `[a] -> m [b]` function over a `Traversable t => t a`?
06:29:27 <Darwin226> with the end result being `m (t b)`
06:30:46 <int-e> Darwin226: I think no, since [a] -> m [b] doesn't guarantee that the shape is preserved. You can pass the a's as singleton lists to get m (t [b]) though.
06:31:48 <Darwin226> int-e: Maybe an unsafe way?
06:32:11 <ertes-w> Darwin226: a special case of that would be possible
06:32:21 <ertes-w> :t partsOf traverse
06:32:23 <lambdabot> (Functor f, Traversable t) => LensLike f (t b) (t b) [b] [b]
06:32:43 <ertes-w> :t partsOf traverse :: (Functor f, Traversable t) => ([a] -> f [a]) -> t a -> f (t a)
06:32:45 <lambdabot> (Functor f, Traversable t) => ([a] -> f [a]) -> t a -> f (t a)
06:33:25 <ertes-w> but this really wants you to preserve the length
06:33:37 <Taneb> Darwin226: what ertes-w said is the easiest way to do this. It uses the lens library, and things will go wrong if you don't preserve the length of the list
06:33:43 <Darwin226> ertes-w: Why can't it change the `a` to `b`?
06:34:19 <int-e> :t partsOf
06:34:21 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
06:34:23 <Taneb> :t unsafePartsOf traverse
06:34:26 <lambdabot> (Functor f, Traversable t) => LensLike f (t a) (t b) [a] [b]
06:34:38 <Taneb> Darwin226: for changing the type of the list you can use unsafePartsOf
06:34:45 <ertes-w> and partsOf is already unsafe
06:35:04 <Darwin226> It' not obvious to me why changing the type is unsafe
06:35:23 <Darwin226> I get why the list length needs to be the same, of course
06:35:42 <ertes-w> unsafePartsOf is to partsOf what supercalliFragileUnsafePerformIO is to unsafePerformIO
06:36:03 <Taneb> > "hello" & partsOf traverse .~ []
06:36:07 <lambdabot>  "hello"
06:36:12 <int-e> ertes-w: is that the current name of inlinePerformIO?
06:36:12 <Taneb> > "hello" & unsafePartsOf traverse .~ []
06:36:17 <lambdabot>  [*Exception: unsafePartsOf': not enough elements were supplied
06:36:27 <Taneb> > "hello" & partsOf traverse .~ "hi"
06:36:30 <lambdabot>  "hillo"
06:36:33 <Taneb> > "hello" & unsafePartsOf traverse .~ "hi"
06:36:38 <lambdabot>  "hi*Exception: unsafePartsOf': not enough elements were supplied
06:36:46 <ertes-w> int-e: i don't know, but i wouldn't be surprised =)
06:36:50 <Darwin226> Oh, I see. It can default to something "sensible" if the type is the same
06:36:55 <Taneb> Darwin226: yeah
06:37:21 <int-e> ertes-w: or maybe you're scared enough to unsafeDupablePerformIO to call it that (I wouldn't blame you... I'm scared too)
06:37:30 <int-e> s/to/of/
06:38:12 * ski . o O ( `unsafeDupablePartsOf' )
06:38:50 <Taneb> ski: accursedUnutterablePartsOf
06:39:07 <Darwin226> Thanks guys.
06:42:17 <ertes-w> lens needs accursedUnutterableConfusing
06:43:19 <TMA> it already has it even without it being defined
06:44:20 <phadej> :t confusing
06:44:24 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
06:45:26 <Taneb> confusing :: Traversal s t a b -> Traversal s t a b (spiritually)
06:46:27 <ski> (is "spiritually" the new term for "morally" ?)
06:47:09 <Taneb> ski: to me they're different in a way I can't quite explain
06:47:41 <Taneb> Also I forgot the word "morally"
06:47:48 <ski> i would ask you to elaborate on the difference, except that you just indicated that you may be unable to do so ..
06:50:35 <Taneb> I'd be happy to say (eg) that Set is morally a functor, but not spiritually a functor
06:51:18 <ertes-w> i wonder if lovecraft knew about the lens library a century ago
06:52:14 <Taneb> (lens isn't quite that bad, really)
06:52:31 <Gurkenglas> Taneb, does undefined spiritually exist? Is Hask spiritually a category?
06:52:46 <mnoonan> Hask is immorally a category
06:52:47 <ertes-w> "any human how dares to study lenses must go insane"‚Ä¶  and then edwardk came along and made it worse
06:52:50 <Taneb> Gurkenglas: no, yes
06:53:11 <Taneb> Of course, this is all my opinion, I am not an authority on the English language
06:53:56 <Gurkenglas> Does Eq spritually have the law "x == y implies f x == f y"? Does Show spiritually have the law "Pasting show output into code gives back the same value"?
06:54:36 <Uniaika> Hmm, provided that Show instances provide Haskell code
06:54:52 <Taneb> No, and I don't know
06:55:09 <Gurkenglas> Aw, I was about to like your spirit. Maybe I should invent gurkenglasually.
06:55:37 <ski> Taneb : hm, "Mathematics, morally" by Eugenia Cheng in 2004-01 at <http://cheng.staff.shef.ac.uk/morality/morality.pdf> (which i just found), may perhaps have something to say on the matter ..
06:55:48 <Uniaika> In elixir some values are represented like #<Ecto.Changeset> 'cause they're opaque. Or at least the library maintainers decided tha their structure wasn't to be directly accessed
06:56:07 <Uniaika> (and # is the comment character)
06:56:49 <Gurkenglas> Uniaika, Data.Map solves that by using public constructors in the Show instance
06:56:58 <Uniaika> Indeed
06:57:05 <ski> > listArray (0,3) [2,3,5,7]
06:57:09 <lambdabot>  array (0,3) [(0,2),(1,3),(2,5),(3,7)]
06:57:38 <ski> (this seems harder to achieve for e.g. `IORef')
06:58:22 <Gurkenglas> Well yes, no Show instance for IORef.
06:59:08 <Taneb> ski: I guess I take "morally" to mean "we can pretend it is", and "spiritually" to mean "it was intended to be"
06:59:17 <ski> because you can't reliably encode it as a natural number, and expect to be able to read it back to the "same" `IORef'
06:59:31 <ski> Taneb : ok, ty
07:04:11 <Gurkenglas> I suppose we could give RealWorld Show and Eq instances, to be treated as time travel coordinates. Do RealWorld values exist at runtime?
07:04:52 <lyxia> I don't think they do
07:04:54 <ski> they aren't materialized as separate entities, no
07:07:18 <ski> (in Mercury, there's a notion of I/O tabling, by which you can debug over I/O code. when a primitive I/O operation is performed, a new token representing the new state is generated. the results of such operations, on the world tokens, are memoized/tabled, so that when you go back in time to replay part of the code, the actual I/O operations aren't reperformed, only their results are looked up)
07:08:04 <ski> (this is e.g. used for declarative debugging (also) over I/O, which relies on being able to retry, going back in time)
07:09:28 <Gurkenglas> "compile-time garbage collection" *stars*
07:12:02 <Uniaika> Mega-Neat
07:25:21 <dmwit> phadej: pong
07:29:38 <phadej> dmwit: about universe, what you think about changing it to use stream type (as I sketched in https://github.com/dmwit/universe/pull/30)
07:30:19 <phadej> because with universe :: [a] it leaks memory, and one cannot use it for "interesting" things
07:33:23 <dmwit> Right.
07:33:41 <dmwit> So, there's definitely some todo marks that I agree would need to be done before this is sensible.
07:33:47 <Bish> would you guys say writing in haskell is slower than procedual stuff?
07:33:55 <dmwit> My main concern is whether it's possible to keep it lazy enough.
07:34:16 <phadej> dmwit: it's as lazy
07:34:20 <Taneb> Bish: in general, no, but it depends on the sort of thing you're writing and the size of the project
07:34:39 <dmwit> Bish: Idiomatic Haskell is 1-2x slower than idiomatic C. Carefully tuned Haskell is +/-5% from carefully tuned C.
07:35:22 <dmwit> phadej: Well, `diagonal` is the one that has the carefully-done laziness, and I see you haven't replicated that one yet...
07:35:55 <phadej> I haven't but I'm confident it's possible
07:36:05 <phadej> if it was possible with [a], it's possible with Stream
07:36:12 <phadej> just way more plumbing
07:36:34 <dmwit> phadej: Oh, yes, I shouldn't have said "possible". What I meant was that my main concern is whether it *is* kept lazy enough. =)
07:36:53 <phadej> (it would be way easier to say to GHC to not retain `universe` CAF)
07:37:00 <phadej> but we cannot do that :/
07:37:13 <dmwit> Yeah. That would be a nice GHC feature in general, I think.
07:37:48 <metahumor> Bish: do you mean "slower" in terms of time to run or time to write the code?
07:39:44 <phadej> dmwit: also diagonal is nasty, as it "by definition" will leak memory :/
07:40:14 <phadej> but I guess it's fine, as it does leak today too
07:41:46 <phadej> dmwit: thanks for input anyway, I'll try to find time to complete that patch.
07:42:38 <dmwit> Well, it should be possible to leak less memory, right?
07:43:14 <dmwit> Like, you shouldn't need to leak the entire contained lists. Just one state element per list being diagonalized.
07:43:19 <dmwit> So that should be a big improvement.
07:43:31 <dmwit> phadej: (just pinging your nick in case you had stepped away already)
07:44:00 <phadej> dmwit: yes, but still, we'll leak O(sqrt n) where n is the element produced
07:44:18 <dmwit> right
07:44:19 <phadej> that's definitely better than O(n)
07:44:29 <metahumor> I'm reading quchen's FAQ... what about length is more efficient than genericLength?
07:44:30 <dmwit> No avoiding that, I think.
07:44:34 <metahumor> @src genericLength
07:44:34 <lambdabot> genericLength []    = 0
07:44:34 <lambdabot> genericLength (_:l) = 1 + genericLength l
07:44:37 <metahumor> @src length
07:44:37 <lambdabot> Source not found. My mind is going. I can feel it.
07:45:03 <metahumor> from Data.List: "length = foldl' (\c _ -> c+1) 0"
07:45:28 <dmwit> metahumor: Dunno if this is still the case today, but it used to be that length was implemented with unboxed ints and a single boxing at the end.
07:46:27 <dmwit> metahumor: ...that is not the implementation I see for the [] instance. Perhaps you are looking at the default definition?
07:46:50 <dmwit> metahumor: I see `length = List.length`, which is referring to GHC.List, which indeed does not use `foldl'`.
07:47:19 <dmwit> metahumor: ...and has some rewrite rules attached that presumably could also be related to a "more efficient" claim.
07:47:40 <metahumor> I looked it up using hoogle, which pointed me to http://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.Foldable.html#length
07:48:15 <dmwit> That is the default definition. The list instance overrides it.
07:48:39 <shdzzl> :exit
07:48:56 <dmwit> On https://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:length , instead of clicking the Source link next to length, click the Source link next to Foldable [].
07:49:20 <metahumor> length                  :: [a] -> Int
07:49:20 <metahumor> length xs               = lenAcc xs 0
07:49:20 <metahumor> lenAcc          :: [a] -> Int -> Int
07:49:20 <metahumor> lenAcc []     n = n
07:49:31 <metahumor> lenAcc (_:ys) n = lenAcc ys (n+1)
07:50:15 <dmwit> Right. I don't know for sure, but I suspect that GHC's strictness analyzer catches on to what's happening there and does what I suggested re: boxing.
07:50:47 <metahumor> could that be from the RULES pragma? I don't understand how those are used
07:51:49 <dmwit> No, the RULES just ensures that length gets rewritten to lenAcc wherever possible.
07:52:34 <dmwit> I don't know why it does it that way; NOINLINE + rules that makes it inline seems odd. But perhaps they didn't trust the inliner to do the right thing here for some reason.
07:54:03 <shapr> amazonka takes an amazing amount of time to compile
07:56:14 <phadej> dmwit: the rules do magic for foldr/build fusion
07:56:27 <phadej> length is good consumer
07:56:51 <dmwit> ahhh, that makes perfect sense
07:57:02 <dmwit> So probably the efficiency claims have nothing to do with boxing at all at this point.
07:57:12 <dmwit> Saving on allocating the list at all is going to be a much bigger win.
07:57:25 <ertes-w> both
07:57:42 <phadej> yes, if it doesn't foldr/build fuse, it will be tight unboxed loop
07:58:22 <metahumor> and why can't you get the foldr/build wins in genericLength? i understand how the unboxing can't occur for a polymorphic Num a
07:58:56 <phadej> anyway, "we" have to springle some http://hackage.haskell.org/package/inspection-testing on those rules to be sure, not it's "we hope it works" :)
07:59:06 <phadej> metahumor: because for generic Num a we don't know if (+) is strict
07:59:17 <ertes-w> metahumor: it can occur, if GHC inlines or specialises early enough
08:00:25 <phadej> and (1 + (1 + (1 ....))) isn't good for `Int`
08:01:41 <metahumor> thanks =)
08:06:16 <sepakroayl> Hello guys
08:07:02 <sepakroayl> Is there any extensible records library on stackage that allows constructing a new record type by appending a label/type pair to another record type?
08:07:27 <sepakroayl> Basically something akin to what Rawr does but on stackage
08:07:28 <shapr> Is there a list of the libraries that take the longest to compile? It'd be interesting to play around with the various GHC tuning options and see what helps.
08:08:20 <metahumor> shapr: acme-everything?
08:08:50 <shapr> I think my system may have issues with that, but that's a good point
08:09:16 <metahumor> its the degenerate case of "X is a subset of X"
08:09:16 <siro> !list
08:09:24 <shapr> siro: what does that do?
08:10:09 <phadej> acme-everything doesn't have install plan last time I teted
08:10:14 <lyxia> sepakroayl: isn't that what any record library ought to do
08:10:52 <lyxia> sepakroayl: Have you seen vinyl
08:14:30 <dmwit> shapr, siro: !list doesn't do anything special as far as I know. ?list or @list will tell you not to use @list (v. useful feature).
08:14:57 <Putonlalla> Does `uniqSetToList` sound familiar to anybody? I cannot compile a package that cannot find it.
08:15:04 <shapr> dmwit: since siro just left the channel, perhaps they were looking for warez?
08:15:10 <dmwit> Okay, that's not entirely fair. But the whole help system in lambdabot is totally user unfriendly these days.
08:15:38 <metahumor> Putonlalla: what does that function do?
08:17:16 <Putonlalla> I don't know, metahumor. It has the type `VarSet -> [EvId]`, so it supposedly converts some kind of a set into a list.
08:18:09 <dmwit> https://hackage.haskell.org/package/ghc-8.2.1/docs/VarSet.html looks related
08:19:24 <dmwit> There's also type EvId = Id in the Var module.
08:19:49 <Putonlalla> Those are some good clues.
08:31:15 <fraktor> Why is the expression [1, 2, 3] `(zipWith (+))` [4, 5, 6] invalid? Isn't (zipWith (+)) a function that takes two arguments?
08:31:33 <Putonlalla> Looks like it's defined as `eltsUFM` from `UniqFM`.
08:31:37 <glguy> The `` syntax only works to change an identifier into an operator
08:31:44 <glguy> not an arbitrary expression
08:32:48 <dmwit> fraktor: Because the language designers screwed up.
08:33:33 <dmwit> fraktor: Alternately: because the language designers were incredibly clever and protected us all from the horrible things we would do to our code if we were allowed to put arbitrary expressions inside backticks.
08:34:10 <shapr> hah
08:34:15 <dmwit> fraktor: I waffle between these two interpretations frequently.
08:34:25 <ski>   x `foo`baz`bar` y
08:34:26 <shapr> Haskell code golf would be an entirely different world if backticks worked that way.
08:34:33 <ski>   x `(foo`baz`bar)` y
08:34:38 <ski>   (x `foo`baz)`bar` y
08:34:42 <ski>   x `foo`(baz`bar` y)
08:34:47 <dmwit> ski: Yes, () required for anything more complicated than a single identifier.
08:34:49 <metahumor> it would be "Lisp : brackets :: Haskell : backticks"
08:35:21 <ski> (the latter two depending on the relative precedence level and associativity. the former version being the problematic additional case)
08:35:51 <dmwit> I'm okay with `( and `) being the delimiters instead of ` and `.
08:36:05 <dmwit> Or `( and )` is probably easier to read and write, actually.
08:36:09 <ski> yea, not using the same token would work
08:36:35 <geekosaur> plan 9? `{ ... }
08:36:47 <geekosaur> which for that mnatter is more like lisp :)
08:37:05 <ski> well, there is no corresponding notion of unquotation here, is there ?
08:37:13 <fraktor> Would it just be better to do something like [...] addPairs [...] where addPairs = zipWith(+)?
08:37:20 <fraktor> *zipWith (+)
08:37:39 <dmwit> fraktor: Sure, or ... <+> ... where (<+>) = zipWith(+)
08:37:56 <metahumor> why not also have syntax for mixfix then
08:38:19 <dmwit> Mixfix is significantly more complicated than my proposal, I think.
08:38:55 <ski> it would perhaps be nice if `<*> :: i (a <- b) -> i a <- i b', given `Applicative i'
08:39:37 <dmwit> ski: I don't understand.
08:40:13 <ski> (in general, instead of `(+-+) :: Al -> Ar -> B', we write `+-+ :: Al -> B <- Ar')
08:40:39 <dmwit> ick
08:41:03 <fraktor> dmwit: I don't really like using unpronouncable names for more complex functions. Call me old fashioned.
08:41:04 <dmwit> I wonder if I would still feel icky about that after having a chance to get used to it. =P
08:41:19 <dmwit> fraktor: Hi, old fashioned!
08:41:28 <ski> well .. i'm not sure it would be that nice in practice .. but it's an idea one can toy with a bit, and imagine how it would look like
08:44:34 <ski> (`A -> B' being type of functions that take argument of type `A' on the left, returning a `B'; while `A <- B' is the type of functions that take an argument of type `B' on the right, returning an `A')
08:44:34 <ski> (fwiw, i've toyed a bit more, in paper notes, with (solely) using `A <- B', rather than the above mixed system (cf. Lambek calculus, categorical grammar, ordered logic))
08:44:34 <Putonlalla> It appears GHC has changed from `VarSet` to `DVarSet` and broken this thing at some point.
08:44:34 <ski> ("Algebra of Programming" by Richard Bird,Oege de Moor uses morphism arrows `A <---< B')
08:47:25 <ski> (having a single function type, one don't need to worry about (more or less) explicitly converting between different styles. there's a single compatible interface by which third parties can communicate)
08:49:36 <ski> (that's also the advantage to not having mixfix : you don't need to eta expand (and possibly permute the parameters). however in e.g. Agda you can use the `_' notation, which ameliorates this)
08:52:45 <edwardk> > [1, 2, 3] & zipWith (+) $ [4, 5, 6]
08:52:48 <lambdabot>  [5,7,9]
08:52:51 <edwardk> ^- fraktor
08:53:18 <edwardk> read & as ` and $ as ` and you're all set. =P
08:53:23 <Putonlalla> I wonder if things will catch fire if I use `alwaysUnsafeUfmToUdfm` from `UniqDFM`.
08:54:45 <cocreature> using functions with `unsafe` in their name is a pretty good way to set things on fire
08:55:17 <Putonlalla> I don't see any other way to implement `VarSet -> [EvId]` as required.
08:59:13 <pinnaclejobs> If anyone is looking for a job, we are building a distributed system for interoperability in the British National Health Service(NHS).
08:59:16 <pinnaclejobs> We will build the thing from scratch using technologies and concepts like CBOR, Lua, Pony, Elm, Capability based Security and
08:59:20 <pinnaclejobs> eventual consistency by composing stand-alone services from across the NHS and private healthcare organisations(mostly our own at first).
08:59:23 <pinnaclejobs> You will take part in designing the system as well.
08:59:26 <pinnaclejobs> Positions are permanent with a salary somewhere around 30 to 60k depending on relevant skills and knowledge.
09:04:26 <Putonlalla> Actually, `nonDetEltsUniqSet` from `UniqSet` does the same thing, but does not have unsafe in its name.
09:18:42 <centril> Also... why 'elm' - purescript seems the more haskelly choice?
09:19:53 <centril> (sidenote: eww @ private healthcare... :/)
09:24:18 <hyperisco> be topical
09:25:32 <centril> hyperisco: is there a #haskell-politics =P ?
09:26:27 <glguy> Probably not yet, but that doesn't change the topic here
09:26:45 * centril has too many channels open in any case ;)
09:29:47 <AWizzArd> https://wiki.haskell.org/Monomorphism says ‚Äûa function is monomorphic if it works only for one type‚Äù. So is a function  foo :: Int -> Bool -> String polymorphic? Because it works on an Int *and* on a Bool?
09:30:09 <centril> AWizzArd: that is monomorphic
09:30:34 <centril> AWizzArd: foo really has the following type:  :: Int -> (Bool -> String)
09:31:04 <Putonlalla> What is the deal with "default type signature for `zero :: forall (h :: * -> *) b. (Pointed h, Additive b) => h b` does not match its corresponding non-default type signature when checking the class method `zero :: forall a. Additive a => a`"?
09:31:12 <AWizzArd> centril: oki
09:31:29 <ski> AWizzArd : the single type which `foo' works at is `Int -> Bool -> String', which is parsed as `Int -> (Bool -> String)'
09:31:48 <ski> however, compare with the following valid types of `take'
09:31:57 <ski>   take :: Int -> [Int] -> [Int]
09:32:14 <Putonlalla> I don't see why not `a ~ h b`.
09:32:14 <ski>   take :: Int -> [[Double]] -> [[Double]]
09:32:38 <ski>   take :: Int -> [(String,IO Bool)] -> [(String,IO Bool)]
09:32:41 <ski>   ...
09:32:46 <ski> but not including e.g.
09:32:53 <ski>   take :: Int -> [Int] -> [[Double]]
09:32:53 <AWizzArd> Makes sense.
09:33:31 <ski> so, `take' has infinitely many types, all being captured by a common "pattern"/template/schema :
09:33:37 <ski>   take :: Int -> [a] -> [a]
09:33:51 <centril> AWizzArd: polymorphism in this context means that the type-variable `a` in `head :: forall a. [a] -> a`  can be substituted for any type you like
09:34:00 <AWizzArd> Si.
09:34:14 <ski> where the placeholder / type variable `a', in each occurance / use / instance of `take', is to be replaced by the *same* specific type
09:34:17 <AWizzArd> I just wanted to clarify the definition that it only works for ‚Äûone‚Äù type.
09:34:24 * ski nods
09:34:48 <ski> terminology is important, for clarifying the crucial parts, and for communicating
09:35:01 <centril> You may want to read up on System F  =)  that might help
09:35:43 <ski> however, i might add that instead of thinking of `take' as being "overloaded" over all these infinitely many types, in a particular *regular* (parametric) way
09:36:24 <ski> we can think of `take' as a *single* polymorphic value (function, here), which have *instances* (not in the type class instance sense) that have all these specific monomorphic types
09:36:39 <ski> then we write *the* type signature of `take' as
09:36:48 <ski>   take :: forall a. Int -> [a] -> [a]
09:37:14 <ski> and it's really the presence of the `forall', directly after the `::' in the type of `take', which indicates that it is a polymorphic value
09:37:44 <ski> (in particular, it is *not* really the presence of type variables in its type which indicates that it is polymorphic)
09:38:44 <centril> ski: well, the presence of unconstrained type variables imply forall, so ;)
09:38:51 <ski> each specific use / occurance of `take' *implicitly* removes the `forall a.' part from its type, while simultaneously replacing all the `a's in the type by the same specific type that the use of `take' demands
09:40:09 <ski> (and this holds in general, for uses of polymorphic values. examples of polymorphic non-functions are `Nothing :: forall a. Maybe a',`[] :: forall a. [a]',`[[],[],[]] :: forall a. [[a]]',`System.Exit.exitSuccess :: forall a. IO a')
09:40:33 <ski> centril : *often*, but not always
09:41:55 <ski> (e.g. with `ScopedTypeVariables' you can have a signature of a locally defined operation, `foo :: [a] -> [a]', where it would be incorrect to claim `foo :: forall a. [a] -> [a]')
09:44:17 <ski> (other cases which may or may not count, depending on how you count, are type expressions in `type',`newtype',`data' declarations, method signatures in `class',`instance' declarations)
09:44:54 <centril> ski: hmm well... in that case `a` is being instantiated at the top level function's specific `a` which has a forall..?
09:45:37 <centril> I still think it is useful to mentally substitute  :: a -> a  for a forall. a -> a  even if it doesn't apply everywhere
09:46:07 <ski> yes, the exact placement of the `forall' is important. it's not just a matter of "add `forall' after the `::'"
09:46:22 <centril> ski: right =)
09:47:15 <ski> (which still is a better model than "wrap wih `forall'", which could cause one to interpret `([a] -> [a]) -> [Integer]' as `(forall a. [a] -> [a]) -> [Integer]')
09:47:37 <ski> one can interpret
09:47:39 <ski> @src Maybe
09:47:39 <lambdabot> data Maybe a = Nothing | Just a
09:47:42 <ski> as saying
09:47:44 <ski>   data
09:47:54 <ski>     forall a. (Maybe a = Nothing | Just a)
09:48:33 <ski> where this `forall' now isn't a type-expression-level `forall', but more like a type-declaration-level `forall'
09:49:12 <ski> (iow, for all types `a', we define the specific type `Maybe a' to have particular data constructors, with particular argument types, involving this `a')
09:49:13 <centril> ski: I think you're generalizing a lot now =) I was trying to be specific about type judgements for functions
09:49:52 <centril> ski: btw... is your nick referring to S K I combinators?
09:49:59 <ski> fwiw, i consider `(==)' in `Eq' to be a monomorphic method (though it is a polymorphic operation). otoh `return' in `Monad' is a polymorphic method
09:50:08 <ski> aye
09:50:58 <centril> ski: https://ro-che.info/ccc/8
09:51:54 <ski> (if you translate `class'es to `data' types, and `instance's to "dictionaries" of such types, then `(==)' would be a monomorphic field, but `return' would be a polymorphic field, requiring `PolymorphicComponents' (now subsumed))
09:52:13 <ski> centril :)
09:53:04 <centril> ski: whoever made CCC needs to make more =P
09:53:34 <ski> i think they've been in here, but i don't recall the nick
09:56:51 <dminuoso> If I want to hide the result from some IO, do I have to explicitly do some `a >> pure ()`, or is there another way to turn some IO a into IO () ?
09:57:09 <centril> dminuoso: use 'void'
09:57:22 <pavonia> :t void
09:57:25 <lambdabot> Functor f => f a -> f ()
09:57:26 <centril> http://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Monad.html#v:void
09:57:31 <dminuoso> centril: Ah brilliant! Thanks.
09:57:37 <centril> dminuoso: welcome!
09:58:59 <centril> ski: on pedagogy... how do you explain what a monad is to beginners (and non-Haskellers) ?
09:59:03 <dminuoso> Oh well I guess that's just `() <$ x` mmm
09:59:32 <centril> :t const ()
09:59:34 <lambdabot> b -> ()
09:59:49 <centril> :t fmap (const ())
09:59:51 <lambdabot> Functor f => f b -> f ()
10:00:40 <ski> centril : practically speaking, i prefer very early showing some code that exhibits certain different forms of boiler-plate, and showing how one can get rid of the boiler-plate by the monadic abstraction
10:01:12 <dminuoso> ski: That seems to be a very common theme. I've seen this frequently done for Writer
10:01:12 <hyperisco> :t void
10:01:14 <lambdabot> Functor f => f a -> f ()
10:01:24 <hyperisco> oh, someone already did that D:
10:01:48 <ski> one analogy, with flaws, but which i've used, is to compare the monad concept and its specific monad instances/implementations to the concept of a priority queue, and its specific implementations
10:02:59 <ski> one important flaw here is that if you know that you have some priority queue implementation, then you're basically good to go .. except that perhaps you need implementation-specific knowledge on how to initialize it (default capacity or whatever)
10:03:05 <centril> ski: but once we are beyond the examples (which I agree we should start with..) and want to get more theoretical?
10:03:28 <centril> I find that it is easier to explain 'join' than '(>>=)'
10:03:34 <centril> explain with*
10:03:35 <ski> while, for instances of the monad concept, we generally need many more primitive operations, than the ones afforded by the `Monad' interface, to be able to built anything non-trivial
10:04:11 <ski> yea, in several cases, `join' is easier to grasp
10:04:27 <ski> however, perhaps not for the `State s' monad e.g.
10:04:33 <centril> ski: perhaps with the exception of things like 'IO' where bind is easier?
10:04:40 <centril> yeah, IO and state-like things
10:05:45 <mnoonan> I don't know, "IO (IO a) -> IO a" isn't so bad. run a program that outputs a second program, then run that second program.
10:05:55 <centril> ski: perhaps we should have called it just 'flatten' and 'wrap' instead of 'join' and 'pure'?
10:06:02 <hyperisco> hrm, for this growing tree stuff, doesn't it only make sense for strict fields?
10:06:11 <ski> some people don't like when people associate monads to sequencing/ordering .. i think there's something deep in this association, but it needs to be qualified that we're not talking (in general) of a mere operational/procedural reduction/evaluation order, but a more conceptual order of sorts (cf. data dependencies)
10:06:13 <kadoban> join always seemed weirdly abstract to me until it was far too late, at least for most Monads
10:06:38 <hyperisco> going even simpler,  Maybe Void  still has two non-bottom inhabitants
10:06:44 <centril> ski: I think data dependencies is spot on
10:06:45 <ski> mnoonan : yes, but that's partly because `IO' is abstract
10:07:14 <hyperisco> data XY a = X !a | Y   but  X Void  has only one‚Ä¶ and I should see if GHC is smart enough about coverage checking‚Ä¶
10:07:28 <ski> if you do the same with `State s', and ask a newbie to follow the implementation of `join' vs. `(>>=)', i believe the latter will be easier to follow
10:07:29 <centril> mnoonan: I think this "run a program that outputs a second program and run that" is pretty advanced
10:07:47 <centril> ski: seconded
10:08:09 <mnoonan> centril: "configure && make" :)
10:08:23 <ski> i think there's also much to the perspective that monads encode effects, as in side-effects, except without the "side"
10:08:43 <ski> thinking of them as modelling notions of "imperative programming"
10:09:22 <centril> mnoonan: don't forget the short circuiting there ;)
10:09:27 <ski> (and i don't think it's bad to talk about "list/nondeterminism effects", if that's a helpful perspective on what you want to do)
10:11:37 <ski> from one perspective, namely on improving the usual side-effectful way to go about things in most other languages, i think one could say that the important part of monads (and also applicative functors) is when you're *not* using them
10:12:43 <ski> anyway, from the effects perspective, i think `pure' isn't *that* bad
10:13:47 <ski> (re sequencing, sometimes i say monads express "dynamic sequencing" and applicative functors "static sequencing". both of these terms needs qualification/elaboration, to explain what more precisely is meant here)
10:14:26 <ski> (and this is despite some monads being "commutative", like `Reader')
10:15:03 <hyperisco> the monadic interface is like procedural metaprogramming
10:15:34 <centril> ski: so I think I take away from this chat: 1. begin with and use lots of examples; 2. tailor the examples wrt. join and (>>=) depending on the monad - and perhaps start with 'join' with monads like [], Maybe, Identity; 3. introduce (>>=) after and use that for state-like monads such as State and IO; 4. Thinking in terms of data dependencies is useful, particularly wrt. "to look at 'a', you must first
10:15:36 <centril> evaluate 'm a', but you must place back a 'm b' and you can't leave the context; 5. Phrases like 'composing actions' may be helpful (?) 6. white lies like side-effects may be useful too (?)
10:15:44 <ski> yep, that's what i'm after, with "monads express effects"
10:17:08 <ski> centril : i do think that attempting to communicate a "conceptual, abstract, vague" view of monads can be helpful .. but i don't think it helps much to belabor this, until the student already has a diverse enough set of concrete monads to build and abstract experience from
10:17:35 <ski> (can be helpful, even if it's something that's hard to talk about)
10:18:03 <centril> ski: I agree that in the effects context, 'pure' is not so bad; but in terms of data contexts, 'wrap' is much better
10:18:23 <ski> before `(>>=)', probably `(>>)' should be introduced, at least for cases like `IO',`State',`Writer'
10:18:36 <centril> ski: Sure; the points 1..6 are sequenced =P
10:18:49 <centril> 1 >> 2 >> 3 >> ..
10:18:56 <ski> (you didn't mention `(>>)' :)
10:19:13 <centril> ski: please forgive =P
10:19:18 <ski> s/evaluate/execute/
10:19:34 <TMA> ski: monads are an umbrella term for a computation that does something more than the computation itself. such as (1) collects trace of the computation, (2) performs some action on the outside world, (3) performs multiple computations (or none at all) ... in a way that has a standardized interface
10:20:17 <centril> TMA: hmm... "more than the computation itself"... idk how I feel about that
10:20:19 <ski> i'm not sure how effective language like "you can't leave the context" is .. but this is something that is hard to do satisfactorially
10:20:34 <centril> ski: for sure
10:20:58 <centril> ski: I think monad-by-excessive-use-of-whiteboard-and-pictures might be nice
10:21:08 <metahumor> in my experience, I gear my "monad explanations" based on what programming language/paradigm my interlocutor is already familiar with
10:21:19 <ski> instead of "white lies like side-effects", i'd probably say "effects", and compare them to "side-effects" in a hand-waving way, while perhaps briefly mentioning salient differences in practice
10:21:27 <centril> metahumor: and if they are familiar with none?
10:21:29 <metahumor> so Javascript lends itself to discussing callbacks, Python to "with open(...) as infile"...
10:21:38 <metahumor> centril: that's a separate case-match =)
10:21:50 * centril giggles inside
10:22:11 <ski> TMA : i agree with what you want to express by "something more than the computation itself"
10:22:51 <ski> metahumor : *nod*
10:22:57 <TMA> centril: I agree that it is poorly worded, because it uses 'computation' on both sides
10:23:28 <centril> TMA: it's very easy to word things poorly around explanations of monad ;)
10:23:46 <metahumor> in explaining Cont, would you use (join) or (>>=) as your jumping off point?
10:24:01 <centril> in explaining Cont, don't
10:24:06 <ski> in `M A', `A' is the type of the result we're "focusing" on, while `M' is the type of the "something more" that "surrounds it"
10:24:14 <asheshambasta> am I the only one seeing errors like these when trying to build a fresh project? https://cl.ly/182U2w2u2H0M
10:24:24 <ski> metahumor : `(>>=)'
10:24:49 <ski> metahumor : but first i'd display code written in explicit CPS
10:25:11 <ski> (or nqCPS, as the case may be)
10:25:45 <centril> ski: but sometimes, the something more is what we really are interested in and not the A - such as when A ~ () and M ~ State Env
10:25:53 * TMA still finds the succint 'a monad is just a monoid in the category of endofunctors' the most straightforward explanation, though one of the least digestible for the uninitiated :)
10:26:23 <ski> centril : yeah. but the focus that `<-' in `do'-notation affords is what i described
10:26:27 <centril> TMA: that quote is a fast way to make people who don't like you
10:26:34 <centril> ski: for sure
10:27:23 <mnoonan> TMA: do you plan on adding the caveats "it should be *a* category of endofunctors", "the Functor typeclass actually means endofunctors on Hask", and "..but there are no such things, because Hask isn't a category"?
10:27:25 <ski> (and that corresponds closely to thinking of monads as expressing a notion of "imperative/procedural programming")
10:28:28 <ski> TMA : such explanations are for the category terrorists, and aspirants thereof
10:28:30 <centril> ski: Alejandro Russo once used the explanation " overloading the meaning of ; "
10:28:40 <centril> ski: hihiihih :P
10:28:47 <ski> *nod*, that's similar to "expressing sequencing"
10:29:28 <centril> category terrorists - priceless
10:29:29 <metahumor> maybe if "applicative do" was somehow magically inferred in cases where monadicity didn't matter, then there wouldn't be an inherent sequencing of "<-"
10:29:52 <ski> centril : and i mean that in a fond way :)
10:29:59 <ski> (cf. "abstract nonsense")
10:30:36 <um1b0zu> I wish I had 0.00001 bitcoins for every time CT was reffered to as abstract non-sense
10:30:39 <ski> metahumor : well, idioms, aka applicative functors, can be said to encode "static sequencing", so there's still sequencing involved
10:30:44 <TMA> ski: I have presented the two approaches that I have found the most helpful to me personally
10:31:04 <centril> ski: 'zygohistomorphic prepromorphisms' et al
10:31:23 <TMA> mnoonan: I do not plan explaining monads at all, no caveats necessary
10:31:29 <ski> well, you should probably blame the Squiggolists for that term, not the category terrorists
10:31:57 * centril mostly spends time at #rust; so centril is obliged to explain 'monad' from time to time
10:32:00 <mnoonan> if you're going to monoid-in-the-category-of-endofunctors, at least be maximally pedantic :)
10:32:41 <centril> mnoonan: well - monad in the general sense, not Monad the typeclass
10:33:13 <kadoban> centril: Teasing rustaceans by explaining the things they can't have?
10:33:22 <ski> centril : part of the problem is that, it's easier (with practice) to get some kind of practical sense of what good monads do, than to be able to express it in a coherent way to others, with some fixed background
10:33:45 <centril> kadoban: Uhm... I spend most of my time doing language design on Rust or writing Rust, so I'd be teasing myself then :/
10:34:06 <kadoban> centril: Ah :)
10:34:27 <ski> (this general phenomenon isn't specific just to monads, of course. but it may be more pronounced, due to there being less ground experience to build on, there)
10:34:36 <centril> ski: for sure ;) would you say that one progressively looses the ability to speak pedagogically about monads when one starts to dabble in abstract nonsense?
10:34:41 <Uniaika> btw
10:34:58 <Uniaika> Option<> and the like, they are considered as a Monad or a Functor?
10:35:16 <centril> Uniaika: Option is a functor, monad, etc. yes
10:35:39 <kadoban> Uniaika: Both, usually. But quite a few languages can't really express that (at least in the type system)
10:35:43 <asheshambasta> Hi guys, I cannot really get a new project from a template to build. I just did `stack new scottybasic scotty-hello-world` and then doing a `stack build` exits with https://pastebin.com/5ChyqQTN
10:36:08 <ski> centril : hm, i remember talking to a Rustic about how monadic reflection could be used to generalize proposals for implicitly propagating/percolating errors reported a la `Either'
10:36:19 <glguy> asheshambasta: Perhaps add your .cabal file and stack.yaml to the paste
10:36:21 <centril> kadoban: what Rust can't do is reason about monads in the abstract, as in about all monads generally - but Rust can encode *specific* monads perfectly well
10:37:20 <centril> (and does so in the standard library.., see  Option::Some, Option::and_then, iter::once, Iterator::flat_map)
10:37:27 <kadoban> centril: Right. In practice it seems a lot less cumbersome than I expected it to be (though I'm only a beginner).
10:38:06 <ski> centril : "would you say that ..." -- good question. i think not necessarily so, but it requires work to "stay in touch with your inner newbie", and to practice explaining what is now "obvious" (not really) to you -- which requires practice and overcoming resistance
10:38:49 <asheshambasta> glguy: https://pastebin.com/LNKTLPQu
10:39:09 <ski> in general, from a didactic perspective (but not only), i think it's good to practice strengthening the connections between implicit and explicit knowledge
10:39:47 <centril> kadoban: So Rust is getting associated type constructors, i.e:  trait Foo { type Assoc<T>; .. } - afaik, this allows for as much as higher kinded types do, but with a somewhat less direct approach and lesser ergonomics
10:40:03 <centril> ski: +1
10:41:09 <asheshambasta> glguy: basically this is _right_ after doing stack new ‚Ä¶ and then stack build ‚Ä¶
10:41:37 <ski> some would claim that much (a majority ?) of the use of monads is to be gained from being able to have code generic over any monad
10:41:42 <glguy> asheshambasta: Yikes. I don't use stack, but hopefully someone who does will find the extra information useful
10:41:56 <glguy> Nothing in those files seems unusual
10:42:55 <ski> centril : where is `T' bound ?
10:43:15 <centril> class Foo self where type Assoc self :: * -> * ;   <-- almost this
10:43:56 <centril> ski:  when you do  Foo::Assoc<MyType>  or Self::Assoc<MyType>
10:44:30 <asheshambasta> glguy: actually, switching the resolver to lts-8.3 seems to have done the trick
10:44:43 <TMA> mnoonan: it has clicked for me without the pedantry (or much of anything from category theory); it was even before i heard the word 'typeclass' or 'Hask' in the Haskell sense
10:44:44 <kadoban> centril: That sounds pretty cool, though I don't know if I'd understand it without seeing bunches of examples
10:45:10 <ski> centril : is a trait `Foo', like `exists a. Foo a *> a', `Foo' here being a type class corresponding to the original trait ?
10:45:28 * ski str Rust couldn't express `exists a. Foo a *> F a'
10:45:34 <ski> (perhaps it has changed)
10:46:01 <centril> trait PointerFamily { type Ptr<T>: Deref<T>; fn make_ptr(val: T) -> Self::Target<T>; }
10:46:10 <mnoonan> TMA: I guess what I mean, non-sarcastically, is that phrase simultaneously 1) scares away a large number of people with its heavy mathematical language, yet 2) does not actually hold up to mathematical precision.
10:46:23 <mnoonan> which isn't to say there is no content
10:46:55 <mnoonan> but coming at it simultaneously from the perspective of a teacher and a mathematician, it fails from both directions :)
10:47:08 <centril> struct BoxFamily; impl PointerFamily for BoxFamily { type Ptr<T> = Box<T>; fn make_ptr(val: T) -> Self::Target<T> { Box::new(val) } }
10:47:46 <centril> ski: traits are type classes - Rust just renamed them to fit a wider audience
10:48:25 <kadoban> Type classes always struck me as kind of an unfortunate name, though you get used to it really quickly.
10:49:21 <centril> kadoban: feels natural to me tbh; 'classes of types' as in "a class of types which has this in common"
10:49:38 <ski> centril : fwiw, i relatively commonly refer people to one of the earliest monad tutorials, "What the hell are Monads?" by Noel Winstanley in 1999-02-17 at <http://www-users.mat.uni.torun.pl/~fly/materialy/fp/haskell-doc/Monads.html>, even though it's a bit dated, because i think, while brief, it drives home the point of monads as abstracting away certain boiler-plate code patterns
10:50:04 <centril> ski: cheers
10:50:21 <ski> centril : so, how do you express `exists a. C a *> F a' ?
10:50:26 <kadoban> Right, if you can read it that way it works. I think my issue with it is mostly just that the word "class" has so much overloading from other languages that beginners all come in with some different idea of what it should mean
10:50:39 <centril> ski: not sure what that notation means
10:50:55 <centril> kadoban: I blame those other languages, not haskell ;)
10:51:07 <kadoban> Haha, that works
10:52:00 <ski> centril : a value of this type, translating to Rustish syntax, is a value of type `F<T>', for some unknown/hidden/abstract type `T', about which we only know that it implements the `C' interface (/ trait, i think)
10:52:01 <centril> ski: what is the operator *> here?
10:52:53 <ski> centril : the important part here is that we know that all the "elements" of this `F'-"collection" have the *same* (unknown) type `T'. for another "collection", of the same type, the corresponding (single) `T' can be a different type
10:53:47 <ski> centril : a value of type `Cxt => T' is such that if the user/caller supplies evidence for the constraint `Cxt', then the user/caller may use the value as having type `T'
10:54:11 <centril> ski: are you talking about existential types in general?
10:54:30 <ski> centril : a value of type Cxt *> T' is such that the user/caller *both* gets provided with evidence for the constraint `Cxt', *and* gets hold of a value of type `T'
10:54:59 <centril> ski: uhm; what's the haskell surface language equivalent?
10:55:21 <glguy> ski: Like this? data c *> a = c => WithConstraint a
10:55:34 <ski> so, the difference between `=>' and `*>' (syntax made-up by me, apparently also picked up by a few other people on the channel) is who must provide the evidence, and who can rely on it being provided
10:55:35 <glguy> assuming ExistentialQuantification, TypeOperators, and ConstraintKinds
10:56:00 <ski> for `=>', the caller/user provides the evidence, and the callee/implementation can just assume that it is given
10:56:35 <ski> for `*>', the callee/implementation itself must provide the evidence, while the caller/user can use take it as given
10:56:45 <TMA> mnoonan: yes, that is true. coming at it from the perspective of former somewhat matematically disinept (not a strict double negation) programmer with no background in abstract nonsense and only limited in general algebra, it helped a lot despite the flaws
10:57:49 <ski> centril : that's a good question, which i devote part of my (universals-and-)existentials "lecture" to
10:57:56 <ski> centril : existential types in general, yes
10:58:45 <ski> glguy : yes, that's a direct way to encode `*>', in isolation. in practice it may be preferable to not encode it as an isolated construct (as i'm sure you know)
11:00:16 <centril> ski: so Rust provides existential quantification in the the sense of   data ExistentialShow = forall a. Show a MkEShow a   in two forms; one that is dynamically dispatched and referred to as 'trait objects' with the syntax  IndirectionConstructor<dyn MyTrait>  and one that is statically dispatched in the form of   -> impl MyTrait
11:00:27 <ski> centril : to make the story short, we can encode `exists a. C a *> F a' in two main ways : (a) as `E', where `data E = forall a. C a => MkE (F a)'; (b) as `forall o. (forall a. C a => F a -> o) -> o'
11:00:33 <centril> (forgot a => in there)
11:00:39 <ski> sometimes one encoding is to be preferred, sometimes the other
11:01:28 <ski> centril : could you elaborate on how these two forms differ ?
11:03:17 <centril> ski:  -> impl MyTrait  allows the callee to hide the real concrete type (which the compiler still knows about) and make it nameable without indirections such as heap allocations in the case of Box<dyn MyTrait>
11:04:11 <ski> in which context(s) can this `-> impl MyTrait' occur ? return type in operation type signatures ?
11:05:03 <centril> ski: For example: in Rust, each closure has a unique type - but '-> impl Fn(A) -> B' makes the type of the closure nameable
11:05:39 <ski> iiuc, i think `dyn MyTrait' corresponds to `exists a. MyTraitClass a *> a'
11:06:05 <ski> (iow a *single* value of type `a' that conforms to the traint `MyTrait')
11:06:08 <centril> ski: yeah, return types such as:   fn make_iterator() -> impl Iterator<Item = u8> {..}   <-- make_iterator picks the real type
11:06:28 <metahumor> is there a typeclass that well-models the following: "nonempty `op` empty = empty"? that is, kinda like what "max" could do with "empty = Infinity"?
11:07:25 <centril> ski: A difference between 'dyn Trait' and 'impl Trait' is that the latter only allows one actual type to be returned, so you can't use one concrete type in an if branch and another in an else branch, while you can do that with 'dyn Trait' because it is dynamically dispatched
11:07:51 <ski> can which type is used by `make_iterator' depend dynamically on the *value* of arguments (or other information input, such as concurrency channel, &c.) ?
11:07:59 <centril> ski: dyn Trait  corresponds to that, yes
11:08:35 <mnoonan> metahumor: something in the area of semilattices, maybe?
11:09:10 <ski> ah, you already answered that question :)
11:09:35 <centril> ski: fn repeat<C: Clone>(elt: C) -> impl Iterator<Item = C> { ... }
11:09:48 <centril> C is universally quantified, Iterator is existentially quantified
11:13:25 <ski> so for `fn make_iterator(...) -> impl Iterator<Item = u8> {..}' that corresponds to `makeIterator :: exists item. Iterator item *> (... -> item)', with `item' picked as `Word8', while `fn make_iterator(...) -> Indirection<dyn Iterator> {..}' corresponds to `makeIterator :: ... -> (exists item. Iterator item *> Indirection item)', i think ?
11:14:30 <dmwit> metahumor: That smells a lot like Monoid; but if not, you should say why.
11:14:37 <centril> ski: since I'm unfamiliar with your notation it is a bit hard to reason in it
11:14:44 <dmwit> metahumor: Oh, no, I completely misread! Apologies.
11:15:31 <ski> centril : in the former case, since `exists' occurs before the argument types, that means that the type `item' selected can't depend on the values of those arguments
11:15:56 <ski> centril : while in the latter, it can, because `exists' is in the result type, "behind" a couple of `->'s
11:16:04 <dmwit> metahumor: So, rings have two operations, not just one, but they do have a law that the identity for the one operation is an annihilator for the other.
11:16:17 <dmwit> metahumor: So that's pretty close. There are various relaxations of rings, too.
11:18:08 <centril> ski: sec
11:18:40 <ski> metahumor : <https://en.wikipedia.org/wiki/Absorbing_element> (or Annihilating element)
11:21:47 <centril> ski: https://play.rust-lang.org/?gist=b0f1506b81d87d30764ee5173db7803c&version=nightly
11:22:10 <parsnip> oh man, almost everything broken about my hakyll site is left to studying pandoc in detail.
11:22:46 <parsnip> now i need a quick ugly fix before i can set time to study pandoc and troubleshoot.
11:23:23 <parsnip> i'm "including" an html resume into a webpage, but pandoc is formatting it as source code.
11:23:55 <parsnip> hmm, quick ugly fix is paste the resume html into a template.
11:24:13 <parsnip> thank you rubber ducky
11:24:49 <ski> centril : oh, `Iterator<Item>' (not `Iterator') is itself a (parameterized) trait ?
11:25:10 <centril> ski: Item is an associated type of Iterator
11:25:33 <ski> is that why you can mention it in the angle brackets ?
11:26:11 <centril> trait Iterator { type Item; fn next<'a>(&'a mut self) -> Option<Self::Item>; }
11:26:25 <metahumor> dmwit: thanks! yeah, either bottom with a JoinSemiLattice or top with a MeetSemiLattice works
11:26:37 <ski> can one write `trait Foo<T> { ..T.. }' ?
11:26:45 <metahumor> mnoonan: thanks for the reference
11:26:54 <glguy> ##rust is probably a better channel for diving into how Rust works
11:27:26 <centril> ski: sure; that is the equivalent of MultiParamTypeClasses; Rust has the first param implicit as 'Self'
11:27:37 <centril> glguy: I think we are comparing Haskell & Rust ;)
11:29:45 <ski> afaiui, Rust traits seems to follow the "OO" usage of existentials, of bundling a (single) value of the hidden type, together with a dictionary for the trait members
11:31:07 <centril> ski: unlike OO (Java) tho, existentials are marked explicitly, so you don't have subtyping
11:31:07 <ski> this would e.g. prevent one of having a collection of values, all of the same, unknown, type, but with a (single) ordering being available over the values
11:31:29 <ski> (as opposed to each value being bundled with its own comparision operation, which is less useful)
11:32:05 <hyperisco> so if empty is like zero, then pure () is like one
11:32:54 <ski> "OO" here is in opposition to the "ADT" (abstract data type) usage of existentials. which allows you to implement a merge/union operation on your collections, without having to serialize the elements of one connection to a list/stream, in order to be able to inject them into the other one
11:33:19 <centril> ski: in the sense of GADTs?
11:33:31 <ski> "abstract data type"
11:33:36 <centril> oh
11:33:39 <centril> misread
11:34:54 <ski> istr "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf> talks a bit about these two usages of existentials
11:35:04 <ski> @where TaPL
11:35:04 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
11:35:07 <ski> for sure mentions it
11:37:52 <centril> ski: uhm... dyn Trait is for having heterogeneous collections; so it has to keep a vtable for the methods of each object - i don't know how else you can do that
11:38:05 <centril> but with -> impl Trait there is no vtable needed
11:38:33 <ski> centril : anyway, do you understand the difference i way aiming at, with being able to have a single value of an unknown type conforming to an interface, as opposed to being able to have multiple values of a single unknown implementation/representation type, conforming to an interface ?
11:39:53 <ski> centril : in Haskell, you can encode `[exists a. [F a]]'. each inner list internally uses the same type `a' for each element (of type `F a' here), while the `a's used in one inner list may differ from the `a' used in another
11:40:16 <ski> so that's a mixed "homogenous and heterogenous existential collection"
11:40:49 <ski> the simpler cases being `[exists a. F a]', where each element may have its own `a'; vs. `exists a. [F a]', where each element must share the same (unknown) `a'
11:41:59 <ski> (the first you could call heterogenous, while the latter might be called homogenous, while still having a hidden type)
11:42:02 <centril> sure
11:44:51 <ski> centril : with `impl', i assume that the caller can't see the hidden type (as opposed to only there being a (presumably implicit) conversion to a form where the hidden type can't be seen) ?
11:45:06 <centril> ski: so; I don't think you can existentially quantify an 'a' into scope there as in  [exists a. [F a]]  in Rust
11:45:58 <ski> centril : *nod*, that was my impression, last i talked with a rustic about this
11:46:05 <ski> (rustite ?)
11:46:20 <centril> ski:  rustacean
11:46:25 <ski> ok
11:46:49 <centril> ski: I needed this kind of existential quantification for implementing :-> in Rust a la: https://hackage.haskell.org/package/QuickCheck-2.11.3/docs/Test-QuickCheck-Function.html#t::-45--62-
11:46:54 <ski> centril : would it be possible to say `fn repeat<C: Clone>(elt: C) -> C { ... }' (perhaps wrapping the result in an indirection) ? (i think yes)
11:47:19 <ski> (corresponding to Haskell `repeat :: forall c. Clone c => c -> c')
11:48:02 <centril> ski: oh yes, that has been possible for a long time
11:49:21 <centril> was actually discussing GADTs on #rust-lang yesterday
11:49:58 <ski> yea, i was just comparing it with your other `repeat', and was unsure how much it differed (re whether a caller could see the selected return type or not, but then other things you said made me realize that the `impl' probably couldn't "leak" in this way)
11:50:19 * ski . o O ( rank-2 for information hiding )
11:51:45 <centril> ski: yea the concrete type is fully anonymous for -> impl Trait
11:52:06 <centril> there is also anonymous universal quantification with  impl Trait in argument position
11:52:12 <ski> since there must be a single static choice, that wasn't completely clear to me
11:52:21 <centril> =)
11:52:25 <centril> anyways - dinner time
11:52:26 <ski> anonymous in which sense ?
11:53:59 <centril> ski: if you get returned a type 'impl Trait', you can't name the concrete type behind it, even if you know the exact type
11:55:45 <ski> to whom is the concrete type (provided by caller, i presume) for an argument `impl' anonymous ? the callee ? how does this differ from ordinary universal quantification ?
11:55:45 <hyperisco> :t liftA2 (<*>)
11:55:47 <lambdabot> (Applicative f2, Applicative f1) => f1 (f2 (a -> b)) -> f1 (f2 a) -> f1 (f2 b)
11:55:59 <hyperisco> I feel like I am missing a more obvious pattern here
11:56:59 <mnoonan> hyperisco: the Applicative instance for Compose f g?
11:57:25 <hyperisco> mnoonan, yes sir, thanks
12:02:47 <hyperisco> :t over Sum
12:02:48 <lambdabot> error:
12:02:48 <lambdabot>     ‚Ä¢ Couldn't match type ‚ÄòSum (a -> Identity b)‚Äô
12:02:48 <lambdabot>                      with ‚Äòs -> Identity t‚Äô
12:03:30 <hyperisco> not sure what I am doing wrong
12:04:08 <hyperisco> oh, ah ha
12:04:23 <hyperisco> read the type of over completely wrong‚Ä¶
12:05:31 <hyperisco> :t Control.Newtype.over
12:05:33 <lambdabot> (Control.Newtype.Newtype n', Control.Newtype.Newtype n) => (Control.Newtype.O n -> n) -> (Control.Newtype.O n -> Control.Newtype.O n') -> n -> n'
12:05:43 <hyperisco> mhm‚Ä¶ life is different depending on what package you use
12:06:03 <mnoonan> so true, so true
12:10:16 <hyperisco> so, I have two values‚Ä¶  f :: f (g (a -> b))  and  x :: f (g a)
12:10:43 <hyperisco> oh derp, don't need lens for this‚Ä¶
12:11:06 <hyperisco> can just write  Compose f <*> Compose x
12:11:18 <Gurkenglas> :t liftA2 (<*>)
12:11:20 <lambdabot> (Applicative f2, Applicative f1) => f1 (f2 (a -> b)) -> f1 (f2 a) -> f1 (f2 b)
12:11:26 <hyperisco> but then I have to uncompose again, so   unCompose (Compose f <*> Compose x)
12:11:33 <hyperisco> maybe this is lensy
12:12:45 <pavolzetor> hello, I am curious how to use horizontal white space in large functions
12:12:56 <pavolzetor> what is the common style for this?
12:13:13 <pavolzetor> let's say I have 10 variables in let statement
12:13:15 <hyperisco> pavolzetor, horizontal white space meaning‚Ä¶ spaces?
12:13:26 <pavolzetor> sorry, vertical
12:13:32 <hyperisco> \v?
12:13:48 <pavolzetor> what is that{?
12:13:51 <hyperisco> vertical tab
12:14:17 <byorgey> I doubt it.  Who ever uses vertical tab?  (How many people even know it exists?)
12:14:30 * hyperisco is spreading chaos
12:14:35 <byorgey> pavolzetor: do you mean like, where should you put blank lines?
12:14:52 <hyperisco> or do you mean how to vertically align things?
12:15:28 <pavolzetor> I googled how to type the vertical tab and it does not work in notepad
12:15:58 <hyperisco> a blessing in disguise
12:16:00 <byorgey> you should forget you ever heard about vertical tab =)
12:16:24 <pavolzetor> Yes, blank lines
12:16:44 <byorgey> pavolzetor: for blank lines, there is no commonly accepted style.  Do whatever you think makes your code most readable.
12:17:46 <pavolzetor> I am just bit puzzled how to make it readable
12:18:06 <pavolzetor> because then I have to put at least 4 newlines between functions
12:18:23 <hyperisco> Gurkenglas, yeah that is what I said first
12:18:36 <byorgey> pavolzetor: I don't understand.  Why do you have to put 4 newlines between functions?
12:18:45 <Gurkenglas> Whoops, yep
12:19:07 <pavolzetor> so I can see where the function ends
12:19:26 <pavolzetor> I know there is the one indent level but I found that it smushes together
12:19:33 <hyperisco> unCompose . f . Compose   is a pattern, but I don't know about the binary case
12:19:53 <pavolzetor> (the reason is the code I write is mostly procedural)
12:20:01 <byorgey> pavolzetor: do you have a type signature before your function?  And/or an explanatory comment?
12:20:10 <pavolzetor> as pretty much any code that does any error handling
12:20:10 <byorgey> those usually help to visually indicate where a new function starts
12:20:26 <pavolzetor> I have type signatures on function boundaries
12:20:35 <centril> ski: 'impl' in argument position is just sugar for the normal <T> syntax but for  fn bar(impl Foo, impl Foo) {..} you get two different Foos
12:20:52 <hyperisco> pavolzetor, you also have indentation level to help see separation
12:21:18 <pavolzetor> that helps, but you have cases where you are pattern matching on AST
12:21:39 <pavolzetor> I found that using explicit case is almost always win
12:21:44 <hyperisco> how about put some code on lpaste and we'll take a look. I can tell you exactly how I format it.
12:21:48 <pavolzetor> but that makes it harder to read
12:22:06 <pavolzetor> thanks, let me grab some
12:22:27 <hyperisco> at the end of the day we're making do with ASCII art, so try a little but not too hard
12:23:54 <pavolzetor> http://lpaste.net/362054#a362054
12:24:40 <pavolzetor> Programming is art; anyhow, I just find the style I learned from LYAH not practically useful for anything reasonable
12:24:41 <hyperisco> okay, well, don't use such huge tab widths
12:25:09 <pavolzetor> I am old, I need more whitespace
12:25:23 <hyperisco> 8 is for noobs, 4 is for casuals, 2 is for hardcore, and 1 is for underground
12:25:46 <pavolzetor> I used to do 4 tabs, not readable for long periods, especially if I need to read others code
12:26:08 <pavolzetor> Actually, what is the state of the art haskell codebase?
12:26:17 <pavolzetor> I would like to read it
12:26:24 <hyperisco> but at that wide you are afforded less levels of indentation
12:26:48 <pavolzetor> that is a good thing
12:27:24 <hyperisco> not necessarily‚Ä¶ it is also nice to have small definitions all in one spot, even if there is a lot of indentation
12:27:37 <hyperisco> I might go 6 levels in and be fine with that
12:28:07 <hyperisco> if I have an explicit case in a local def'n then I am already 3 levels in with how I format code
12:28:16 <byorgey> pavolzetor: that looks fine to me.  And with that kind of code, you're right, it makes sense to have multiple blank lines in some places
12:28:51 <hyperisco> there is nothing else I can really suggest given your example
12:29:11 <pavolzetor> can you show me some of your best code?
12:29:25 <pavolzetor> I can't imagine those 6 levels
12:30:24 <hyperisco> it can happen‚Ä¶ a case in a case is 4 levels for me
12:30:45 <ski> centril : i see, just like `(exists a. F a) -> (exists a. G a) -> T' is the same as `forall a0 a1. F a0 -> G a1 -> T'
12:31:10 <hyperisco> then make it a local defn, that is 5, then make it a class member, that is 6
12:31:32 <hyperisco> if you don't want to write code like that then you don't have to. You can't anyways with tabs that wide :P
12:31:32 <ski> centril : .. except i suppose with `impl' in argument position, you don't explicitly use the `<T0>' syntax when calling ?
12:31:43 <pavolzetor> For example, I would like to read compiler in Haskell that does have great error messages (not GHC); is there any example codebase? I am myself fighting with producing good messages
12:31:58 <hyperisco> maybe increase your font size, letter spacing, or line spacing
12:32:47 <pavolzetor> hyperisco, :), I will try to increase the spacing; can you paste the multiindentation level code?
12:33:16 <centril> ski: you can't supply T0 at call site with impl in argument position - it is not nameable, but you usually don't need to supply T at call site when doing  fn id<T>(x: T) -> T { x }
12:33:30 <centril> (type inference, etc. etc.)
12:34:06 <centril> ski: so it would not participate in any TypeApplications
12:36:22 <hyperisco> pavolzetor, http://lpaste.net/362055
12:36:37 <pavolzetor> Another thing, I have data Generator = Generator { gen :: (String, Int) -> (String, Int) }
12:36:47 <hyperisco> if you take anything from it, maybe my habit of putting -- like a close brace‚Ä¶ I actually do it because it helps with autoindentation in my editor
12:36:54 <pavolzetor> how do I make it an intance of Applicative?
12:37:04 <hyperisco> pavolzetor, you don't, because it has the wrong kind
12:37:13 <hyperisco> :k Applicative
12:37:16 <lambdabot> (* -> *) -> Constraint
12:38:14 <pavolzetor> thanks for the code, it is quite readable, I will try to use that style
12:38:29 <hyperisco> well, what helps readability is probably the short line length
12:38:37 <hyperisco> long lines are inherently more difficult to read
12:38:44 <pavolzetor> Do you put -- just below the function?
12:38:55 <hyperisco> I put a -- to separate definitions at the same level
12:39:16 <pavolzetor> I see, I did not notice it in the paste at first time
12:39:18 <hyperisco> I am kind of used to reading things this way now, but I did it originally just because of how auto-indentation works in Notepad++
12:39:37 <hyperisco> if I didn't do that then it would keep sticking in extra indents when I don't want them
12:40:40 <pavolzetor> I see, back to the applicative, can I use data Generator a = Generator { gen :: (String, Int) -> (String, Int) }
12:40:42 <pavolzetor> ?
12:40:59 <abhiroop> is it somehow possible to introduce equality constraints with generalized newtype deriving?
12:41:04 <byorgey> pavolzetor: you can, but that would be useless.
12:41:20 <byorgey> pavolzetor: that would essentially just be a Monoid instance.
12:41:35 <pavolzetor> when I put the a in the function signature, I was not able to come up with `pure` method
12:42:12 <hyperisco> pavolzetor, this is how your code would appear if I wrote it http://lpaste.net/362054
12:42:47 <hyperisco> pavolzetor, (see annotation) and if the case exprs are long then I would separate each with an extra newline
12:43:19 <hyperisco> maybe my way of lining up parens with operators will inspire you
12:44:41 <hyperisco> if you have a lot of trouble reading long lines then increase your line spacing in your editor
12:44:46 <pavolzetor> thanks, the concat is hard to read though
12:44:51 <hyperisco> go 1.5 or 2 line height
12:45:03 <hyperisco> it is a style you get used to
12:45:07 <pavolzetor> will try
12:45:34 <pavolzetor> not really, I do not see reason why I should mentally translate between the way it is if I do gcc -S main.c
12:45:42 <hyperisco> I am used to reading it like two columns‚Ä¶ I see the ( <> <> <> ‚Ä¶ <> ) and the arguments as two columns
12:46:23 <hyperisco> so I instantly understand all the stuff is being mappend'd together‚Ä¶ same as people do for lists (putting the comma first)
12:46:32 <pavolzetor> do you do a lot of dissasembly? in this case I think it is worse, but it may be better in other cases
12:46:58 <pavolzetor> byorgey, I will look to make it monoid
12:47:26 <ski> centril : *nod*
12:47:27 <hyperisco> if I wanted a disassembly to look like the source then I would write an auto formatter for it
12:47:54 <pavolzetor> I just want to use the do notation instead of doing it manually
12:48:57 <pavolzetor> I do not agree, I really like the -- idea so this was very helpful
12:49:09 <pavolzetor> I also googled and it seems elm compiler is in Haskell
12:49:21 <pavolzetor> and I know they have beautiful error messages
12:49:42 <hyperisco> I have 99 problems and syntax aint 1
12:50:07 <byorgey> given the mention of vertical tab earlier, I was morbidly curious what the Haskell Report says about it.  It turns out that... it is not entirely clear.
12:50:38 <byorgey> the Report mentions vertical tab as an allowed whitespace character.  But the section on layout does not mention it at all, so it is not exactly clear how indentation would be affected by it.
12:50:46 <pavolzetor> byorgey, how do you know what abstraction to use? I am bit lost in functor, monad, applicative. I wrote my own parsec (to get good errors) but only learned about Monad instance because of do notation
12:51:03 <pavolzetor> Is there some reference with many example?
12:51:03 <byorgey> experiments suggest that GHC treats it exactly like a space character, which seems a sensible way to interpret the Report.
12:51:52 <byorgey> pavolzetor: it's really just a matter of experience.  Keep playing around with them, seeing how they are used in other people's code, etc.
12:51:57 <byorgey> pavolzetor: have you read the Typeclassopedia?
12:53:47 <centril> btw... if and when Haskell adds linear types, would we change  id :: a -> a   into   id :: a -o a  ?
12:53:59 <hyperisco> (Monad m, Monad f) => Compose m f a  makes sense for monad transformers‚Ä¶
12:54:02 <pavolzetor> no, I will read it
12:54:13 <hyperisco> but then if you've got three things to compose‚Ä¶  Compose m (Compose f g) a ‚Ä¶ life is sad again
12:54:25 <pavolzetor> I am trying to get sense what abstractions are worth it and what are not
12:54:44 <pavolzetor> So I did not use almost any libraries and write my own
12:54:47 <byorgey> pavolzetor: every abstraction is worth it in the right context.
12:55:02 <hyperisco> or, actually, it should still work‚Ä¶
12:55:03 <byorgey> pavolzetor: but implementing them yourself is definitely a good learning exercise
12:55:21 <Tuplanolla> I think the chosen syntax was `->.`, centril, but that is the plan.
12:55:36 <centril> Tuplanolla: oh, why not -o ?
12:55:47 <lyxia> mixing symbols and letters
12:55:55 <lyxia> very ew
12:55:59 <byorgey> centril: that would require changing the lexical structure of the language
12:56:00 <Tuplanolla> Probably due to lexing woes.
12:56:08 <centril> ah, that makes sense
12:56:14 <centril> but -o looked very beautiful tho
12:56:37 <byorgey> -‚àò could work but would be annoying to input
12:57:11 <centril> byorgey: "no effing unicode" to paraphrase McBride
12:57:18 <Tuplanolla> I would've even preferred `-@` or `-+` over `->.`.
12:57:42 <centril> Tuplanolla: -@ looks pretty funny
12:57:48 <Tuplanolla> The dot looks like noise.
12:57:59 <pavolzetor> byorgey, I just find that some abstractions are hard to stick; especially, I sometimes write code that I have trouble understanding year later so I tend to write the simplest code
12:58:09 <centril> Tuplanolla: yeah, the dot is super easy to miss
12:58:11 <pavolzetor> and definitely avoid libraries if I can, just use the basics
12:58:13 <mnoonan> ->. looks like it would be easy to lose the dot. but if fira code has a reasonable ligature, I guess I don't care
12:58:16 <byorgey> pavolzetor: sure, that's a matter of taste and experience
12:58:35 <metahumor> why not "->o"
12:58:38 <byorgey> centril: I am not actually advocating for Unicode syntax =)
12:58:42 <centril> mnoonan: There are some strange people without Fira Code
12:58:49 <centril> byorgey: yeah I got that
12:58:50 <mnoonan> centril: that seems impossible
12:58:55 <pavolzetor> thanks everybody for help, this was great
12:58:57 <fishythefish> well, there's hasklig and so on
12:59:00 <metahumor> not all of us can run Fira Code -- some of us are in Vim
12:59:22 <byorgey> metahumor: because that involves both symbols and a letter, so according to the current Haskell standard it cannot be an operator.  It would be two lexical tokens.
12:59:27 <centril> What the hell is Vim?
12:59:38 <glguy> I use Fira Code and Vim
12:59:45 <glguy> or sometimes I use Fira Code, at least
12:59:49 <byorgey> centril: a torture device
12:59:54 <centril> byorgey: clearly
13:00:15 <mnoonan> assuming you vim in a terminal, some terminal emulators at least can do monospaced ligatures
13:00:37 <centril> https://en.wikipedia.org/wiki/Vim_(cleaning_product)
13:00:46 <metahumor> yeah, unfortunately i cannot isolate the other font to just a single pane of my tmux
13:04:53 <ski>   ‚ä∏
13:06:27 <hyperisco> actually, getting smarter yet, monad transformer types are essentially Compose already
13:06:47 <hyperisco> Compose ((->)a) m  or  ReaderT a m  for example
13:07:09 <jle`> many monad transformers are essentially newtype'd Composes
13:07:28 <jle`> MonadTrans could actually have been a different sort of typeclass
13:08:07 <hyperisco> right
13:08:40 <jle`> class MonadTrans t where join :: Monad m => Compose t (Compose m (Compose t m)) a -> Compose t m a
13:08:52 <jle`> instance MonadTrans t => Monad (Compose t m) were ...
13:09:15 <dmwit> StateT s is neither Compose (State s) _ nor Compose _ (State s)
13:09:52 <jle`> ah, yeah
13:10:07 <hyperisco> wasn't trying to say it was universal, but good counterexample
13:10:17 <jle`> that also explains why there's no Applicative instance for StateT s m unless m is Monad
13:11:38 <dmwit> Even if the types match up, there's no a priori reason to believe the Applicative instances should.
13:13:42 <jle`> well, if things are Compose, then you have a free (Applicative f, Applicative g) => Applicative (Compose f g)
13:13:55 <jle`> so if it was a composition, you would only need an applicative constraint
13:14:33 <dmwit> Yes. And my objection is that even if Compose f m is isomorphic to fT m, there's no reason to believe that the Applicative instance for fT m *should* be the same as the Applicative instance you get for free from Compose.
13:14:38 <jle`> but since StateT s is not a composition of any two applicatives, this doesn't apply and all bets are off
13:14:48 <jle`> dmwit: ah
13:15:09 <jle`> it might be a ZipList/normal list type of situation, you mean
13:15:33 <jle`> where there are multiple applicatives you could gain, but only one that matches the ap of the Monad instance(s)
13:15:40 <dmwit> Yeah. I don't see an obvious up-front reason to believe there can be one and only one Applicative instance; and choosing between them may depend on how the Monad instance looks.
13:15:54 <jle`> my life is a lie
13:20:13 <insanitea> so is cake
13:21:02 <hyperisco> oh, but Compose is not Monad =\
13:25:15 <ski> jle` : also `Cont o' and `Search o'
13:25:47 <dmwit> Hm. Bootstrapping cabal-install is kind of tricky.
13:27:19 <glguy> using the provided script?
13:28:04 <dmwit> Oh, that's probably simpler. I was using a very old existing cabal-install.
13:28:22 <dmwit> I always forget about the existence of the bootstrapper script.
13:28:28 <glguy> There are also binaries to download https://www.haskell.org/cabal/download.html
13:32:38 <dmwit> Thanks. The reason I'm doing this is because I need a toolchain on a system with an oldish glibc, so the binaries don't work.
13:39:26 <lhcopetti> Hi! Did anyone here ever used hipmunk (The Chipmunk physics library binding for Haskell)?
13:39:48 <dmwit> bootstrap.sh dies in fun ways, too. This is going to be Fun.
13:40:04 <dmwit> lhcopetti: Not for anything serious, but I did put together a little gtk2hs demo with it I think.
13:41:05 <dmwit> https://github.com/dmwit/physics
13:41:09 <dmwit> Probably bitrotted to heck. =P
13:41:14 <lhcopetti> @dmwit Cool! I'm playing around with the playground
13:41:14 <lambdabot> Unknown command, try @list
13:41:21 <lhcopetti> @list
13:41:21 <lambdabot> What module?  Try @listmodules for some ideas.
13:41:41 <glguy> lhcopetti: You can explore lambdabot using /msg
13:41:47 <metahumor> hipmunk is also a great hotel/flights booking site
13:42:00 <lhcopetti> Damn! thx guys. It is the first time I'm using IRC
13:45:39 <lhcopetti> So, about hipmunk. My question is about handling collisions
13:46:07 <lhcopetti> I've checked the docs and I saw a way of getting the shapes which collided by registering a callback
13:46:27 <lhcopetti> But how would I go about using the shapes to go back to a data object I defined, for example GameObject
13:48:56 <lhcopetti> Does anyone know if chipmunk/hipmunk has a userData property much like box2D has?
13:50:32 <dmwit> lhcopetti: I suppose you'd have to keep a mapping of Shape to GameObject somehow. Shape offers Ord, so Map would probably work for that.
13:51:38 <dmwit> (...and you can use `shapes :: Callback t (Shape, Shape)` to get the two `Shape`s that are currently colliding.)
13:52:32 <lhcopetti> Cool, the secret is that I can use a Map as: Shape, GameObject
13:52:47 <lhcopetti> How do I reply to you by the way? heheh
13:52:55 <lhcopetti> Thanks for the help.
13:53:40 <geekosaur> just start your response with their nick. usually followed by , or : but clients don;t generally care
13:53:52 <lhcopetti> geekosaur: Does it work?
13:53:55 <geekosaur> (some but not all will highlight on a nick being anywhere in the line)
13:53:56 <geekosaur> yes
13:54:07 <lhcopetti> Oh yeahh!!
13:54:18 <lhcopetti> I'm starting to get really good at this
13:54:19 <lhcopetti> hehehe
13:57:11 <lhcopetti> I'm using a webbased client, do you guys use recommend anything else?
13:57:56 <Tuplanolla> Yes, I recommend anything else.
13:58:03 <parsnip> weechat
13:58:16 <ski> lhcopetti : perhaps HexChat, if you're on windows or unix, and like gui
13:59:06 <dmwit> irssi is nice, and I'd be a bad friend if I didn't recommend glirc.
13:59:14 <ski> (mIRC also seems to be relatively popular on windows, even though it is nagware)
13:59:29 <MP2E> glirc is great, switched from irssi to it recently
14:00:03 <lhcopetti> I'm using Ubuntu
14:00:09 <JuanDaugherty> he/xchat here
14:00:53 <JuanDaugherty> (on ubuntu server 17 from the apt-get)
14:01:01 <lhcopetti> I'll check them out (HexChat and glirc) thx
14:07:58 <glguy> lhcopetti_: glirc ends up looking like this: https://imgur.com/a/ITVUP
14:10:18 <lhcopetti_> :glguy What are those 'x's and '+'s?
14:10:33 <EvanR> nice join and parts
14:10:38 <glguy> Those are joins(+) and quits(x) and parts(-)
14:11:00 <lhcopetti_> Ahh, sure. Much better looking indeed
14:11:21 <glguy> They can be hidden and restored on demand
14:12:33 <glguy> There's a wiki on the github page with more information if you explore it and you can always ask for help in #haskell-irc
14:15:47 <lhcopetti_> :glguy Sure, thanks!
14:16:10 <lhcopetti_> glguy: What do you use haskell for?
14:16:12 <glguy> I added a few more images to that imgur album, so feel free to refresh
14:17:26 <glguy> anything that needs to be programmed, mostly. work, my IRC client, solvers for various games, calculator for playing cookie clicker, etc :)
14:19:13 <lhcopetti_> You use haskell at work?
14:19:16 <lhcopetti_> How cool is that
14:19:36 <lhcopetti_> How long have you been playing with the language?
14:20:02 <glguy> You're in a channel where you're going to find a lot of people who use Haskell at work ;-)
14:20:40 <EvanR> whether or not theyre supposed to be
14:20:57 <kadoban> EvanR: Haha
14:21:01 <metahumor> EvanR: ^^
14:21:12 <glguy> Looks like since mid-2005
14:22:27 <lhcopetti_> ahahaah
14:22:57 <lhcopetti_> I have a lot of people tell me that my pursuit for haskell is empty
14:23:33 <lhcopetti_> I don't know why it captivated me so much
14:23:40 <lhcopetti_> But I'll get to the bottom of it
14:23:51 <EvanR> > let x = x in x
14:23:56 <lambdabot>  *Exception: <<loop>>
14:24:00 <EvanR> never!
14:24:34 <lhcopetti_> ahahahah
14:24:42 <lhcopetti_> I got that joke!!
14:24:47 <lhcopetti_> Damn, I'm so proud of myself
14:24:57 <lhcopetti_> And you have a weird sense of humor too
14:25:13 <pikajude> whoa, how long has printf been wrong
14:25:24 <pikajude> > printf "%.0e" 12.34 :: String
14:25:28 <lambdabot>  "1.2e1"
14:25:38 <pikajude> how preposterous
14:26:06 <EvanR> > printf "%.0g" 12.34 :: String
14:26:09 <lambdabot>  "12"
14:26:33 <EvanR> i guess it shows 12 in scientific notation
14:27:01 <pikajude> gcc's printf produces 1e01 which I'm pretty sure is the correct behavior
14:27:10 <EvanR> e01 o_O
14:27:17 <pikajude> 1e01 or 1e1
14:27:18 <pikajude> either way
14:27:22 <glguy> I see it generate: 1e+01
14:27:26 <pikajude> You're not supposed to show decimals with .0 in the format string
14:27:30 <pikajude> oh, right
14:27:44 <pikajude> Anyway the general gist of it is that %.0e doesn't work right
14:29:07 <Tuplanolla> > printf "%.-1e" 12.34 :: String
14:29:10 <lambdabot>  "*Exception: printf: bad formatting char '-'
14:43:11 <glguy> It looks like the fault could just be in:
14:43:17 <glguy> > showEFloat (Just 0) 12.34 ""
14:43:21 <lambdabot>  "1.2e1"
14:43:38 <glguy> which printf defers to
15:01:42 <lhcopetti_> Does anyone here have ever read the book "Haskell design patterns" (https://www.amazon.com/Haskell-Design-Patterns-Ryan-Lemmer/dp/178398872X)?
15:01:59 <lhcopetti_> The name is really compelling
15:04:13 <EvanR> design patterns, things you keep redoing in a language because the language has no way to make the pattern reusable
15:05:11 <sm> not really..
15:07:06 <geekosaur> design pattern = idiom
15:08:03 <pikajude> well
15:08:08 <pikajude> i think it's the other way around
15:08:17 <pikajude> showEFloat uses formatRealFloat which is in the printf module
15:08:47 <pikajude> the question is where i file a bug ü§î
15:16:19 <pdxleif> @hoogle a -> (a -> IO ()) -> IO a
15:16:20 <lambdabot> Control.Monad.Loops forkMapM__ :: (a -> IO b) -> [a] -> IO ()
15:16:20 <lambdabot> Network.Transport.Internal asyncWhenCancelled :: forall a . (a -> IO ()) -> IO a -> IO a
15:16:20 <lambdabot> System.Path brackettmpdir :: String -> (String -> IO a) -> IO a
15:18:17 <pdxleif> @hoogle (a -> IO ()) -> IO a
15:18:18 <lambdabot> Control.Monad.Loops forkMapM__ :: (a -> IO b) -> [a] -> IO ()
15:18:18 <lambdabot> Network.Transport.Internal asyncWhenCancelled :: forall a . (a -> IO ()) -> IO a -> IO a
15:18:18 <lambdabot> Graphics.UI.Gtk.Buttons.LinkButton linkButtonSetUriHook :: (String -> IO ()) -> IO ()
15:19:34 <Maxdamantus> That last type can't be implemented (without a loop/crash)
15:20:25 <dmwit> What are you hoping this function will do?
15:22:44 <dmwit> ?djinn Monad m => a -> (a -> m ()) -> m a
15:22:44 <lambdabot> f a _ = return a
15:26:07 <dmwit> :t liftA2 (<$) id
15:26:08 <lambdabot> Functor f => (a -> f b) -> a -> f a
15:27:02 <glguy> keepTrying a f = either (\_ -> return a) (`keepTrying` f) =<< try (f a)
15:27:21 <dmwit> awwww, it's adorable!
15:27:27 <dmwit> It's trying so hard!
15:27:42 <glguy> If at first you don't succeed, don't try again...
15:27:46 <geekosaur> that, or it;s very trying
15:28:35 <dmwit> :t asum . repeat
15:28:38 <lambdabot> Alternative f => f a -> f a
15:29:12 <glguy> Oh, I missed the function argument had type (a -> IO ()) and not (a -> IO a)
15:35:11 <pdxleif> I guess <$ works
15:36:30 <pdxleif> I was just hoping to skip the "do a <- foo; f a; return a" pattern of this stuff https://github.com/simlu/xmonad/blob/master/config/.config/taffybar/taffybar.hs#L239-L241
15:37:28 <pdxleif> Ended up with "preserveVal f x = x <$ f x"; not sure what to call that.
15:38:21 <pdxleif> ?djinn Functor f => (a -> f ()) -> a -> f a
15:38:21 <lambdabot> Error: Class not found: Functor
15:38:30 <pdxleif> ?djinn Monad f => (a -> f ()) -> a -> f a
15:38:30 <lambdabot> f _ a = return a
15:44:56 <geekosaur> :exf Functor f => (a -> f ()) -> a -> f a
15:45:44 <geekosaur> I broke it :p
15:47:02 <MarcelineVQ> geekosaur: it's been broke for a bit
15:58:12 * dugz fires up ghci for another round ...
16:11:25 <dugz> do we have a haskell-bot here?
16:11:45 <Tuplanolla> > yes
16:11:48 <lambdabot>  Hello there, dugz.
16:12:11 <dugz> Œª take 3 [1..]
16:12:27 <dugz> lambdabot, :D
16:12:39 <Tuplanolla> Use > to evaluate.
16:12:50 <dugz> > take 3 [1..]
16:12:53 <lambdabot>  [1,2,3]
16:12:57 <dugz> yaay!
16:12:59 <Tuplanolla> He also accepts private messages.
16:13:13 <dugz> you guys rock!
16:14:40 <paralel> hello. i have a basic question that suddenly came up on my mind. here is a screenshot of a "data Tree" and a function that tells if some variable is in the tree (https://image.ibb.co/dhYAR6/lala.png). what i don't understand is why the function return immediately if it evaluates to True? why it is not the opposite? what if i want it to return immeduatelly after it evaluate to False? why haskell behave like that? als
16:14:40 <paralel> o, and it's the same question but in different words: why the function will continue lookup for the variable, if it get False over and over again till the end of the tree? how it knows it should continue?
16:15:35 <glguy> ?src (||)
16:15:35 <lambdabot> True  || _ = True
16:15:35 <lambdabot> False || x = x
16:16:00 <glguy> paralel: Because (||) is defined to return True if the first argument is True and otherwise to return the second argument
16:16:52 <dugz> > :t "wŒµirŒ¥ stuff"
16:16:55 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
16:17:18 <dugz> that might be a ghci thing
16:17:50 <MarcelineVQ>  >  is for expressions
16:18:02 <MarcelineVQ> :t "wŒµirŒ¥ stuff"
16:18:03 <lambdabot> [Char]
16:18:07 <dugz> ahh
16:18:35 <paralel> glguy: thanks. it is still somewhat strange but it's late here so maybe i need to get a sleep and think of it tommorow :-)
16:19:54 <dugz> :t (3.7, "Abraham Lincoln", (1,2,3))
16:19:56 <lambdabot> (Num c, Num b, Num a2, Fractional a1) => (a1, [Char], (a2, b, c))
16:20:37 <glguy> dugz: You can explore lambdabot in private message. If you have any questions along the way you can ask them here
16:20:41 <paralel> ?src foldl
16:20:41 <lambdabot> foldl f z []     = z
16:20:41 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:20:42 <dugz> yeah sorry
16:21:12 <dugz> glguy, I'll PM it to screw around in more depth later
16:21:20 <paralel> glguy: is there manual for lamdabot? all the commands i can insert to it?
16:22:35 <geekosaur> not really
16:23:15 <paralel> geekosaur: thanks. so how do you know how to manipulate it?
16:23:37 <geekosaur> mostly by watching others. you can also get a list of non-admin commands
16:24:05 <dugz> its probably a stripped down ghci
16:24:06 <geekosaur> actually I used to run one, and wrote a manual of the admin commands for it --- but I was not using it in a Haskell context so it has none of the Haskell-related commands documented
16:24:16 <geekosaur> it's not¬∏actually
16:24:25 <paralel> what is the command for getting non-admin commands?
16:24:38 <geekosaur> @list
16:24:38 <lambdabot> What module?  Try @listmodules for some ideas.
16:24:42 <geekosaur> @listmodules
16:24:42 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
16:24:42 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
16:24:56 <geekosaur> then you have to @list from each of those, yuck
16:25:14 <dugz> jeez you could write an OS in lambdabot and boot it! O_o
16:25:33 <geekosaur> anyway http://users.ece.cmu.edu/~allbery/lambdabot/COMMANDS was what I wrote up for the one I used to run --- again, minus the haskell related plugins
16:26:03 <paralel> @undowait' lambdabot is not just for haskell?
16:26:04 <lambdabot> Unknown command, try @list
16:26:14 <paralel> lambdabot is not just for haskell?
16:26:33 <geekosaur> most of those are available separately on hackage: @run / @type / @kind is from mueval, @djinn is from djinn, etc.
16:26:39 <dugz> >(+ 2 3)
16:26:50 <geekosaur> space after the > is required
16:26:57 <geekosaur> but that syntax wouldn't work anywya
16:26:58 <dugz> > (+ 2 3)
16:27:01 <lambdabot>  error:
16:27:01 <lambdabot>      ‚Ä¢ Could not deduce (Num t0)
16:27:01 <lambdabot>        from the context: (Num (t -> a), Num t, Num a)
16:27:07 <geekosaur> > ((+) 2 3)
16:27:11 <pacak> It's not lisp...
16:27:11 <lambdabot>  5
16:27:18 <dugz> that was scheme i did
16:27:38 <paralel> geekosaur: thanks.
16:27:47 <geekosaur> someone could hypothetically write an iterface for some other language. I don;t know thta anyone has done so. I was using the logging, messaging, and a few other functions
16:28:15 <geekosaur> plus a few extra plugins I'd written specifically for where I was using it (@ipcalc in the commands list I pointed to, which is not in this lan=mbdabot nor did I publish it because it was kinda hacky)
16:29:25 <dugz> I learned scheme basics to have some grip on lisp
16:30:23 * dugz thumbs up!
16:30:57 <dugz> then I came here
16:31:29 <dugz> Anyways, back to work
16:33:19 <paralel> dugz: are you programmer?
16:34:35 <dugz> paralel, Hobbyist. I'm retired and I help patch gentoo bugs sometimes.
16:34:59 <paralel> i'm using gentoo right now :-)
16:35:05 <dugz> likewise
16:36:20 <dugz> I was a mechanical engineer, so I find Haskell especially nifty
16:36:58 <dugz> built in infinite series handling
16:37:03 <dugz> 'yes please!
16:37:49 <paralel> what languages did you  learn till now?
16:42:10 <dugz> paralel, I am best with Python, C, and Assembly. I have flirted around with many other programming languages though. Ada, FORTRAN, Pascal, Modula2, C++, Java, JS, Scheme, Forth, ...
16:43:16 <paralel> wow a lot |thumbs up|
16:43:33 <dugz> I can can probably debug better than I can code
16:44:07 <paralel> did you contribute some code to linux kernel?
16:44:45 <glguy> If you'd like to chat about some random topics, you could join #haskell-offtopic
16:44:58 <dugz> paralel, no, but I emailed Linus and told him to keep the ANSI term compatibility on the console forever
16:45:37 <paralel> dugz :-)
16:46:39 <dugz> glguy, sorry, I just intended to log in here and watch for haskell tips. I'll go hang in #gentoo-chat and try to keep the signal to noise ratio up
16:47:11 <paralel> dugz you are funny :-)
16:48:11 <dugz> paralel, he wrote me back, agreed it was fundamental ;)
16:57:38 <dmj`> Tehnix: ping
17:04:27 <paralel> good night from here :-)
17:23:48 <ericbmerritt_> I have a of types that represents different ids. They are all declared as :
17:23:54 <ericbmerritt_> https://www.irccloud.com/pastebin/NrHZLSVs/
17:24:15 <ericbmerritt_> they all have constructors that look like:
17:24:54 <ericbmerritt_> https://www.irccloud.com/pastebin/6tqxrRxC/
17:25:23 <ericbmerritt_> it feels like those constructors could be factored out in some way, but I have been unable to figure out a way to make them generic
17:31:03 <boj> ericbmerritt_: template haskell i suppose
17:33:50 <ericbmerritt_> boj: that would do it, I am hoping for something a bit more elegant
17:34:04 <fishythefish> ericbmerritt_: define newWrapper :: MonadIO m => (UUID -> a) -> m a; newWrapper constructor = ... and define your new<some-name>s in terms of that?
17:34:26 <fishythefish> not sure to what degree you want to automate this
17:37:23 <ericbmerritt_> fishythefish: thats a route I went down.
17:37:35 <ericbmerritt_> of course, I figured it out as soon as I posted the question
17:38:17 <ericbmerritt_> I am already GeneralizedNewTypeDeriving, I created a class for the constructor, created an instance of the class for the UUID type, and now it can be derived
17:43:32 <Rembane> ericbmerritt_: What about using a sum type instead?
17:44:49 <Rembane> ericbmerritt_: So you have a data type that models an ID that takes the sum type as a parameter.
17:47:45 <ericbmerritt_> Rembane I am not sure I follow
17:49:30 <Rembane> ericbmerritt_: data ID a = ID IDType a; data IDType = T1 | T2 | ... | Tn; and then you can make one smart constructor parametrized on IDType.
17:52:51 <dmwit> ericbmerritt_: `data IDableThings = Cars | Trees | Houses; newtype ID (a :: IDableThings) = ID UUID`
17:53:09 <dmwit> ericbmerritt_: Or you can use * instead of IDableThings if you want the collection of things which you can ID to be more open.
17:53:44 <ericbmerritt_> ah, the problem there is that they use the same data type. One of the goals of declaring them as `newtype` is that you can't accidentally use a type in a context for which it is not designed
17:54:00 <ericbmerritt_> so for example FooId and BarID should never be interchangable
17:54:16 <Rembane> They still aren't.
17:54:25 <fishythefish> IDable is lifted to a kind in dmwit's example
17:54:35 <fishythefish> ID Cars, ID Trees, and ID Houses are all different
17:54:35 <dmwit> ericbmerritt_: If you are responding to me: no, I declared three separate data types that can't accidentally be mixed.
17:54:38 <Dave___> hey, just getting started with Haskell and I'm kinda lost, how could I make a list of 4 empty chars: ['', '', '', '']
17:55:00 <geekosaur> Char-s are never empty. Did you want Strings?
17:55:07 <Rembane> > ['', '', '', '']
17:55:10 <lambdabot>  <hint>:1:4: error: parse error on input ‚Äò,‚Äô
17:55:17 <fishythefish> > replicate 4 ""
17:55:20 <lambdabot>  ["","","",""]
17:55:38 <geekosaur> (or perhaps Maybe Char)
17:56:01 <fishythefish> > replicate 4 None -- (in which case)
17:56:04 <lambdabot>  error:
17:56:04 <lambdabot>      ‚Ä¢ Data constructor not in scope: None
17:56:04 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
17:56:13 <fishythefish> s/None/Nothing
17:56:22 <fishythefish> too much ocaml at work
17:56:44 <dmwit> ericbmerritt_: (...and, to complete the API, `new :: forall a proxy. proxy a -> IO (ID a); new = UUID <$> V4.nextRandom`. use like `new @Cars` or `new @Trees`)
17:56:57 <dmwit> oops
17:57:11 <dmwit> use like `new (Proxy :: Proxy Cars)`
17:57:42 <Rembane> Dave___: What are you gonna use the empty Chars for?
17:57:57 <dmwit> Alternately `new :: forall a. IO (ID a); new = UUID <$> V4.nextRandom` and then you really can use it like `new @Cars`.
17:58:42 <Rembane> dmwit: What does the @ mean?
17:58:48 <dmwit> Type application.
17:58:56 <Rembane> Cool. Thank you.
17:59:02 <Rembane> Is that a new 8.2 thing?
17:59:09 <dmwit> When `f :: forall x. ...`, then `f @t` has type `...[t/x]`.
17:59:21 <dmwit> It's newish, but not 8.2-new. Maybe 7.10?
18:00:13 <Rembane> That looks like predicate logic.
18:00:15 <MarcelineVQ> 8
18:00:19 <Dave___> thanks it worked with replicate
18:00:33 <dmwit> ...
18:00:40 <dmwit> What you mean is "it worked with double quotes".
18:01:17 <dmwit> Using replicate 4 instead of writing the element 4 times was not the thing that changed whether it worked.
18:02:29 <Dave___> yes, String is [Char] so an empty string would be ['']?
18:02:39 <fishythefish> No, an empty string is []
18:03:00 <fishythefish> "a" would be ['a'] and so on
18:03:06 <Dave___> ok
18:03:12 <Rembane> :t ['']
18:03:12 <geekosaur> > 'a':'b':'c':[]
18:03:14 <lambdabot> error: parse error on input ‚Äò]‚Äô
18:03:16 <lambdabot>  "abc"
18:03:28 <Rembane> Sorry
18:04:07 <fishythefish> Dave___: do you understand geekosaur's point that there is no such thing as an empty Char?
18:04:07 <geekosaur> > [] :: String
18:04:10 <lambdabot>  ""
18:04:18 <dmwit> Dave___: *If* '' were indeed a thing, [''] would not be an empty string but rather a string with one character, specifically, whatever character '' meant. But '' is not a thing.
18:05:40 <geekosaur> I'm wondering if this is confusion like Perl/Python/Ruby considering '' and "" to both be string quotes, as opposed to C/Java/Haskell considering 'x' char (always nonempty) and "" string.
18:07:20 <Rembane> It's all Perl's fault, or maybe sh... string interpolation is the bandit here!
18:08:07 <Dave___> yes I think I did understand
18:09:23 <Dave___> 'x':'y':[] == "xy" and also [] == "" correct?
18:09:47 <dmwit> > ('x':'y':[] == "xy") && ([] == "")
18:09:50 <lambdabot>  True
18:09:54 <dmwit> looks good
18:10:19 <dmwit> > "\&"
18:10:22 <lambdabot>  ""
18:10:41 <dmwit> > ['\&']
18:10:45 <lambdabot>  <hint>:1:4: error:
18:10:45 <lambdabot>      lexical error in string/character literal at character '&'
18:12:10 <shapr> Can anyone point me to some example cabal.project files?
18:12:32 <shapr> I'm trying to modify amazonka and then build with the local modified copy.
18:13:34 <dmwit> Many of the repos on the GaloisInc github have cabal.project files.
18:14:26 <shapr> dmwit: thanks, I'll check those
18:14:31 <dmwit> Although most of them are pretty simple. Little more than a listing of packages.
18:14:55 <shapr> and that's all I need!
18:15:12 <shapr> oh, I didn't know I could include a .cabal file in a cabal.project
18:15:16 <shapr> that's helpful
18:16:10 <dmwit> Oh, yes, the standard usage is that each package still has its own .cabal file.
18:17:39 <Rembane> I think this calls for this xkcd: https://xkcd.com/927/
18:17:42 * Rembane hides
18:18:04 <shapr> Is there a list of every field possible for each stanza in each flavor of cabal config file?
18:18:10 <shapr> and what those fields can contain?
18:19:33 <MarcelineVQ> shapr: ye  https://cabal.readthedocs.io/en/latest/developing-packages.html#developing-packages
18:20:55 <MarcelineVQ> it's quite long though
18:22:14 <shapr> ah, and there's another page for the fields of cabal.project: https://cabal.readthedocs.io/en/latest/nix-local-build.html#configuring-builds-with-cabal-project
18:22:16 <MarcelineVQ> most stanzas are their own thing which you'll find at that link plus build information https://cabal.readthedocs.io/en/latest/developing-packages.html#build-information
18:23:05 <Dave___> overall I'm trying to write a function which takes a string like "4a1b1c5" and convert it to a list of strings while the number is the count of empty strings followed by the occurring char
18:24:24 <Dave___> my idea was to iterate with map over the chars and when its a digit (as string) insert the amount of empty strings and otherwise append the char
18:24:45 <Dave___> is that a good approach? or are there better ways?
18:25:39 <Rembane> Dave___: I think you need a fold rather than a map, since a map can't change the length of the string.
18:26:18 <Dave___> "1a2e1" should result in ["", "a", "", "", "e", ""]
18:26:46 <Dave___> ok thx I'll have a look on fold
18:27:59 <Rembane> No worries.
18:28:17 <Rembane> Dave___: You can also create a recursive function that solves the problem.
18:33:38 <jle`> Dave___: might also work out as a concatMap :)
18:33:57 <jle`> or a map + concat
18:56:03 <Dave___> I'm kinda stuck, I'm trying to use concatMap on that string and return a list of strings: rowToList s = concatMap (\x -> stringToList x) s
18:56:45 <Rembane> :t concatMap
18:56:47 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
18:57:00 <Rembane> Dave___: What does stringToList do?
18:57:48 <jle`> Dave___: not that if you concatMap a String, 'a' will be Char, not String
18:58:04 <jle`> :t concatMap :: (Char -> [b]) -> [Char] -> [b]
18:58:06 <lambdabot> (Char -> [b]) -> [Char] -> [b]
18:58:09 <jle`> :t concatMap :: (Char -> [b]) -> String -> [b]
18:58:11 <lambdabot> (Char -> [b]) -> String -> [b]
19:18:44 <siwica> What is the best way to quickly download the source code for a particular library from the command line? Can stack do that?
19:20:30 <geekosaur> stack get, I'd expect
19:23:24 <siwica> geekosaur: That command does not appear to exist...
19:23:44 <geekosaur> surprised they didn't alias it. stack unpack, then
19:24:04 <geekosaur> I suppose you;'re not supposed to do that in "proper" stack use
19:24:24 <Rembane> stack install <package name>
19:24:31 <geekosaur> source?
19:24:39 <Rembane> Oh. No. I failed at reading. Sorry.
19:24:54 <siwica> Yeah, I want to examine the source
19:25:13 <parsnip> unpack?
19:25:24 <siwica> unpack seems to be doing exactly what I want
19:40:26 <lijero> I managed to extract a recursion scheme ("morph") from two functions. Does anyone know what it might be called, or of any alternative formulations?
19:40:27 <lijero> If my code sucks for unrelated reasons, feedback would be helpful, since I've never had anyone who knew Haskell look at any of my code before.
19:40:27 <lijero> http://lpaste.net/1067146210227257344
19:44:05 <mnoonan_> lijero: your ‚Äúsome sort of algebra?‚Äù is an f-algebra in the Kleisli category for a state monad
19:45:12 <mnoonan_> so instead of being defined by an ‚Äúalg :: f a -> a‚Äù, you have an ‚Äúalg :: f a -> m a‚Äù (and your m happens to be State st here)
19:46:18 <mnoonan_> oops, wait, I didn‚Äôt quite read it right
19:46:18 <lijero> I figured it'd have something to do with the state monad
19:46:49 <mnoonan_> I think you might be able to put your updateState and next into one thing though :)
19:47:38 <lijero> by turning it into an f a -> State st a or something?
19:48:48 <mnoonan_> yeah.. if I‚Äôm reading you right, you‚Äôve kind of split your stateful computation into a reader part (next) and an update part (updateState)
19:52:06 <mnoonan_> otoh, you aren‚Äôt sequencing any state updates on the subtrees, since each recursive call is getting the same state
19:52:22 <mnoonan_> so.. I don‚Äôt know. it‚Äôs interesting looking :)
19:52:59 <lijero> yeah, it's kinda weird
19:53:41 <lijero> I was just learning about recursion schemes, so I tried to pull as much out of those two functions, what I was able to pull out ended up being the same, and that's just what I got
19:55:03 <lijero> I know virtually nothing about CT either
19:55:09 <lyxia> that looks like cata
19:55:25 <lyxia> I mean, if I squint enough
19:55:52 <mnoonan_> I‚Äôm going to stick with ‚Äúit‚Äôs cata in a Kleisli category‚Äù, except I still can‚Äôt suss out what the monad would be :|
19:56:00 <lijero> yeah, I noted that in a comment, but I'm not really sure how to turn it /into/ cata
19:57:30 <lijero> mnoonan_: can you explain "Kleisli category" in brief?
19:57:34 <lyxia> (f x -> x)  with  x ~ (st -> a)
19:57:44 <lyxia> is the type of the algebra
19:58:20 <mnoonan_> lijero: the gist is that you look at functions of the form ‚Äúa -> m b‚Äù for some fixed monad m, rather than ‚Äúa -> b"
19:58:33 <mnoonan_> so:
19:58:35 <mnoonan_> :t (.)
19:58:37 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:58:50 <mnoonan_> ^ composition in our good old Hask
19:58:54 <mnoonan_> :t (>=>)
19:58:55 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:59:08 <mnoonan_> ^ composition in the Kleisli category for m
19:59:22 <mnoonan_> (flipped, I guess)
19:59:28 <lijero> lyxia: so I'd be reducing to an (st -> a) function and then seeding it with 0?
19:59:28 <mnoonan_> :t (<=<)
19:59:30 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
19:59:34 <mnoonan_> there we go
20:00:26 <lyxia> :t  \update next state value -> cata (\f st -> fmap ($ update st (void f)) f) value state
20:00:29 <lambdabot> error:
20:00:30 <lambdabot>     ‚Ä¢ Occurs check: cannot construct the infinite type: b ~ f b
20:00:30 <lambdabot>       Expected type: a -> b
20:00:39 <lyxia> damn
20:01:05 <mnoonan_> the point is that you can compose together ‚Äúf :: a -> m b‚Äù and ‚Äúg :: b -> m c‚Äù by.. (well, should I say or do you want to work it out? :)
20:01:49 <lijero> I think I get it
20:01:50 <lyxia> :t  \update next state value -> cata (\f st -> next st $ fmap ($ update st (void f)) f) value state
20:01:52 <lambdabot> Functor f => (a -> f () -> a) -> (a -> f b -> b) -> a -> Mu f -> b
20:02:12 <pikajude> it's as easy as (a -> f () -> a) -> (a -> f b -> b) -> a -> Mu f -> b(tm)
20:02:38 <lyxia> pikajude: obviously
20:04:15 <lijero> alright, thanks to both of you!
20:07:02 <Axman6> hello injeans!
20:07:23 <shapr> @seen tommd
20:07:23 <lambdabot> TOmmd
20:07:23 <mnoonan_> anyway, for reference, since vanilla cata looks like cata :: (f a -> a) -> (Fix f -> a), cata-in-Kleisli would look like cataM :: Monad m => (f a -> m a) -> (Fix f -> m a)
20:07:25 <shapr> bah
20:09:07 <lyxia> @seen shapr
20:09:07 <lambdabot> z|-|aPR
20:09:21 <Gurkenglas> lijero, the only reason not to fuse update and next into (f b -> a -> (b, a)) is that this loses the gurantee that update depends only on the shape, yes?
20:10:30 <lijero> Gurkenglas: thats'
20:11:03 <lijero> that's not even a strict requirement actually, that's just how it happened to be in both functions I pulled it out of
20:12:19 <lijero> though right now I am trying to simplify it using what's just been explained to me
20:13:12 <Gurkenglas> (Though update seems to go from the outside in and next from the inside out)
20:16:30 <Gurkenglas> Yes, void takes not f a, but f (Fix f), I'm not sure the State approach will work directly. Perhaps a Tardis?
20:17:45 <lijero> maybe
20:22:31 <Gurkenglas> Feeding the f a produced by the fmap into the void should act the same as feeding the initial f (Fix f), since the fmap doesn't change the shape
20:29:03 <lijero> Gurkenglas: I'm not sure what you're referring to.
20:30:13 <Gurkenglas> Neither am I, I'm part hoping to inspire others and part attempting to throw together some code
20:36:08 <Gurkenglas> :t \alg -> cata (\f st -> let (st', result) = alg (fmap ($ st') f) st in result)
20:36:10 <lambdabot> Functor f => (f b -> a -> (a, b)) -> Mu f -> a -> b
20:37:05 <Gurkenglas> How does one eta-reduce a tied knot like that?
20:37:36 <benzrf> that's not eta-reducable
20:37:55 <benzrf> it's not of the form \x -> f x
20:37:57 <Gurkenglas> Maybe I'm saying it wrong. How do I not say st in there?
20:38:04 <lijero> point-free?
20:38:31 <benzrf> is this something like mfix
20:39:17 <benzrf> oh wait
20:39:19 <Gurkenglas> dunno, i just kept refactoring and it kept working
20:39:20 <benzrf> interesting
20:40:15 <lijero> that's pretty much how I got to where I did
20:41:13 <Gurkenglas> @pl \st -> let (st', result) = alg (fmap ($ st') f) st in result -- How do I pose this query right?
20:41:14 <lambdabot> (line 1, column 12):
20:41:14 <lambdabot> unexpected "("
20:41:14 <lambdabot> expecting "()", natural, identifier or "in"
20:42:00 <lijero> I've been trying to fix that in a /query
20:43:54 <PCChris> Hello. I'm using servant-client but can't figure out how to use the response from a previous request in the next request and so on without the code marching off the right side of the screen due to nested pattern matching. The return type of a request is `IO (Either ServantError ResponseType)`
20:44:08 <Gurkenglas> Shrinked: How does one point-free the x out of "\x -> let (a, b) = f a x in b"?
20:45:22 <Gurkenglas> PCChris, are all but one of the cases of each caseof short?
20:45:35 <PCChris> Gurkenglas, yes
20:45:36 <lijero> I think it'd just be
20:45:55 <lijero> oh, hm, nevermind
20:47:39 <Gurkenglas> PCChris, http://hackage.haskell.org/package/kan-extensions-5.1/docs/Control-Monad-Codensity.html should help
20:47:56 <ski> PCChris : `ExceptT ServantError IO ResponseType'
20:48:34 <Gurkenglas> PCChris, I assume you need to caseof the ResponseType values too, yes?
20:50:09 <PCChris> Gurkenglas, no, not currently. Codensity looks interesting but most of ekmett's stuff is still pretty intimidating to me as a beginner
20:50:22 <ski> Gurkenglas : `snd . fix . (. fst) . flip f' ?
20:50:31 <Gurkenglas> ExceptT will suffice if you just want to abort on the first Left.
20:52:21 <PCChris> ski, Gurkenglas yes, thought ExceptT was the correct route (thanks for the confirmation) but I was running into some issues. I'll probably have to post an lpaste and the specific compilation errors I'm running into. Will take another gander at it quick.
20:52:28 <ski> you could call this `trace'
20:52:50 <Gurkenglas> Why is that name appropriate?
20:54:51 <ski> <https://en.wikipedia.org/wiki/Trace_(linear_algebra)>,<https://en.wikipedia.org/wiki/Tensor_contraction>
20:55:07 <ski> @type loop
20:55:09 <lambdabot> ArrowLoop a => a (b, d) (c, d) -> a b c
20:57:51 <PCChris> Gurkenglas, ski code: http://lpaste.net/362063, error: http://lpaste.net/362064
20:59:09 <ski> PCChris : next time, you could annotate the paste with the errors
21:02:23 <ski> PCChris : which operations there have a return type of `IO (Either ServantError ResponseType)' ?
21:02:59 <PCChris> ski, runClientM
21:03:10 <ski> PCChris> :t runClientM
21:03:22 <ski> (i was just about to say, before you answered)
21:04:32 <PCChris> ski, there's actually two different response data types I have, TokenResponse and FeaturedPlaylistsResponse
21:04:52 <ski> well, i'm not sure that matters much
21:05:02 * ski would still like an answer
21:07:15 * ggVGc answers ski 
21:07:49 <ski> heh, not an answer to my question
21:08:02 * ski looks at PCChris
21:08:31 <PCChris> ski, answer to what?
21:09:01 <PCChris> runClientM :: ClientM a -> ClientEnv -> IO (Either ServantError a)
21:09:28 <ski> ty
21:11:38 <ski>   result <- runExceptT $ do
21:11:50 <ski>     tokenResponse :: TokenResponse <- ExceptT $ runClientM (queries ...) (...)
21:11:58 <ski>     liftIO . print $ tokenResponse
21:12:08 <ski>     ExceptT $ runClientM (queries' ...) (...)
21:12:16 <ski> PCChris : something like that might work ?
21:14:29 <PCChris> ski, sweet, that seems to work! Do you have any suggestions that might help me figure something like that out on my own in the future?
21:15:41 <ski> `ExceptT' is when you have `m (Either e a)' and you want to short-circuit / abort on the first `Left'
21:16:02 <ski> `MaybeT' similarly for `m (Maybe a)', aborting on `Nothing'
21:19:30 <PCChris> ski, would I be able to use the MonadError typeclass to ditch the ExceptT constructors?
21:21:40 <ski> no. you could use `throwError' and `catchError' instead of explicitly relying on `Either'
21:22:00 <ski> but here i think you already had an operation (`runClientM') which used `Either'
21:23:22 <PCChris> ski, yeah that's right. Well, thanks for the help. Saved me a lot more head scratching.
21:23:32 <ski> anyway, such a local use of `ExceptT' or `MaybeT' is nothing to be worried about, imho
21:24:01 <ski> (in some cases, one would define operations which had `ExceptT' or `MaybeT' in their signatures as well. but that wasn't needed here)
22:35:48 <erisco> I think I am finding that the composition of two Monads is not always a Monad, even if you know one of them
22:36:08 <dmwit> erisco: right
22:36:26 <Gurkenglas> erisco, see https://hackage.haskell.org/package/transformers-0.3.0.0/docs/Data-Functor-Compose.html
22:36:55 <dmwit> erisco: https://stackoverflow.com/q/13034229/791604
22:36:57 <erisco> Gurkenglas, but I am saying something stronger
22:38:04 <erisco> ReaderT r m a  is Monad i.e.  Compose (Reader r) m a  is Monad
22:38:19 <dmwit> erisco: The example given there is `Compose (Writer Any) Proxy`, which cannot be made a law-abiding monad.
22:38:44 <Gurkenglas> erisco, what are you saying exactly? I hope it's not "for each monad m exists monad n such that Compose m n is no monad", because m = Identity is a counterexample
22:38:48 <erisco> even say we know m, so  ReaderT r (Either e) a ‚Ä¶ if we compose again for  m (ReaderT r (Either e) a)  then I don't think this is Monad
22:40:05 <erisco> m (r -> m (r -> Either e a))  is what we get left with
22:40:45 <erisco> it is a little annoying trying to determine if it is impossible or I am just stupid :P
22:42:54 <erisco> that  r -> m (r -> m a)  is reducible is a bit surprising, after all
22:47:33 <erisco> so I wonder if you stick on another ReaderT‚Ä¶ :P
22:55:59 <dmwit> erisco: You don't like `(Bool, Proxy a)` as a counterexample? It's a lot simpler than your mix of readers and errors...
22:56:28 <erisco> well it isn't a counterexample of much interest to me :P
22:56:37 <dmwit> Can you say why not?
22:57:01 <erisco> because one I am working with and the other not
22:57:39 <erisco> like I said‚Ä¶ the annoyance is knowing whether the particular composition is impossible as Monad or I am just not seeing it
22:57:45 <phadej> erisco: it boils down to whether m (n a) ~ n (m a)
22:57:47 <phadej> in general it isn't
22:58:01 <phadej> but for some `m` (or `n` or pairs) it is
22:58:09 <dmwit> I'm not sure I understood "one I am working with and the other not". There's too many dangling references that I can't resolve.
22:58:32 <erisco> is that both necessary and sufficient phadej?
23:00:02 <phadej> erisco: join :: m (n (m (n a))) -> m (n a) = fmap join . join . fmap commute -- commute swaps inner n,m, so there is (m (m (n (n a))), join joins outer ms, fmap join, inner ns
23:00:35 <erisco> sufficient, okay, but necessary?
23:00:48 <dmwit> doubtful
23:01:18 <simplegauss> i'd like some resources/references/pointers on how to implement the following in haskell: in python it is useful to pair opaque objects (like functions) with some metadata about the object. then when the data is used (suppose the functions are composed) if the metadata is of the same type it is combined, but when two pieces of metadata are of different types they are just stored in a list together. this gives some information about 
23:01:18 <simplegauss> final composition, for example the metadata can encode whether or not the function at each stage is known to be injective. my problem is that in haskell it seems i have to make many decisions up front. either i can restrict all the types of metadata or i can make some heterogeneous list of [(IsInjective t) => t]. is there a way to allow the user to tag each function with "arbitrary" metadata? or what is the way around this? i know t
23:01:19 <simplegauss> vague, so general resources would be much appreciated as well.
23:01:19 <erisco> it would be excellent to have something reductive like this to determine if the composition is Monad or not
23:02:16 <erisco> simplegauss, Python is not statically typed, so you're talking about two different worlds here
23:02:37 * ski . o O ( `[exists t. IsInjective t *> t]' )
23:02:52 <erisco> simplegauss, static does mean you state everything up front. That is the point! :)
23:03:04 <phadej> erisco: http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf
23:03:13 <phadej> there seems to be weaker conditions discussed
23:03:21 <erisco> hey thanks
23:03:22 <phadej> m (n (m a)) -> m (n a) is enough e.g.
23:04:04 <erisco> I was thinking of both those‚Ä¶ did not figure out a way to say it was necessary though
23:04:04 <simplegauss> ski: yes, i'm rusty on the syntax, i should have written [forall t. IsInjective t => t] i think.
23:04:12 <ski> no
23:05:42 <simplegauss> erisco: of course i know the difference, i meant that there is something easy in python (basically to manipulate some opaque objects with arbitrary tags decided downstream), and i imagine there must be a hopefully elegant way of doing this, or at least a different way of thinking about it, in haskell
23:07:43 <erisco> hard to say if there is a different way of thinking about it unless you are more specific (I am not familiar with this feature in Python)
23:08:00 * ski isn't sure about the use case
23:08:10 <erisco> the problem is that if we do an apples to apples conversion then we just choose to tag things with data as we do in Python, and types are essentially irrelevant
23:09:27 <simplegauss> erisco: is there a way to "just tag things with data" in haskell though?
23:09:38 <erisco> sure, use a 2-tuple
23:10:12 <simplegauss> erisco: but then i can't really use it if the type is truly arbitrary :)
23:10:22 <erisco> how do you get by in Python?
23:10:53 <tdammers> I don't understand what the use would be of a variable whose type is truly arbitrary
23:11:18 <dmwit> simplegauss: Correct. Also, in Python, you can't really use it if the type is truly arbitrary.
23:11:28 <tdammers> or rather, you tag it, but there is a finite number of possible tags, and the tag is supposed to tell you something about the tagged thing, which makes it no longer of arbitrary type
23:11:55 <erisco> sounds like we're talking about GADTs
23:12:54 <ski> simplegauss : it's not enough to consider how you encode data, we also need to consider how you're going to use it
23:15:08 <ski> (consider e.g. how Haskell lists are "homogenous", which means that in some sense, one is using all the elements of a list in a homogenous/uniform manner. if one always has a fixed number of values, which are used/interpreted in distinct ways, a tuple (or a data type) would be better)
23:15:23 <simplegauss> ok, let me be specific. i am writing lots of compositions of functions on vector spaces, the functions are provided downstream. at first i am just composing the functions, this is easy in haskell or python. then i realize that it would be nice to know if the chain of compositions are injective. then functions that are known to be injective are wrapped in a class "InjectiveFunction" that composes with any other callable, but checks i
23:15:24 <simplegauss> the thing it's composing with is also injective. if it is then the whole thing is considered an "injectivefunction", if not then it 'decays' to normal functions
23:15:32 <simplegauss> that's fine, this is easy in haskell
23:15:59 <ski> (otoh, if we do want a list of arbitrary length, but where every element is used in one of two possible ways, then one can "uniformize" that by using a list of `Either A B'. or a custom data type)
23:16:02 <erisco> what does knowing if something is injective give you?
23:17:09 <simplegauss> but now a week later i also realize it's nice to know if functions are surjective and do the same thing. it's possible (i don't want to go through it but i can) to make some infrastructure in python with inheritance and functions that check the types of their arguments so that this works. of course it's not too elegant but it's possible. then the user can also decide he wants to know if the functions are continuous, etc., without mu
23:17:09 <simplegauss> trouble or intervention on my part
23:17:51 <tdammers> simplegauss: so in Haskell, you'd make a wrapper type that holds both the function and its metadata
23:18:19 <tdammers> simplegauss: and then define a custom composition operator that composes the functions and combines the metadata according to the rules you want
23:18:31 <ski> do you always want to compose the functions, or do you sometimes want to store them "beside each other", uncomposed ?
23:18:32 <tdammers> e.g. data FunctionMeta = { isInjective :: Bool }
23:18:38 <erisco> so, one way is to wait a few years and prove this in dependent Haskell
23:18:51 <ski> if the latter, is the intermediate type retained or forgotten ?
23:19:04 <tdammers> and then when there's an additional thing you want to have in the metadata, you add it to the FunctionMeta type
23:19:18 <vaibhavsagar> @djinn Monad m => (a -> b) -> m a -> m b
23:19:18 <lambdabot> -- f cannot be realized.
23:19:21 <tdammers> if you don't know yet what metadata exactly you want to track, then that's fine too
23:19:22 <simplegauss> erisco: certain algorithms using these functions can use a much more efficient version if i know the function is injective. also i can use this to keep track if a chain of functions is invertible, or for example some long composition actually ends up being equal to the identity
23:19:52 <tdammers> you make the function type wrapper polymorphic over the FunctionMeta type, and then write typeclasses to make sure the things you absolutely have to do to it are possible
23:19:53 <erisco> another thing you can do is read conal's Compiling to Categories paper (and corresponding concat package) which offers a mechanism by which to analyse functions
23:20:15 <tdammers> that's all assuming you want to do it at runtime
23:20:17 <simplegauss> ski: what do you mean "is the intermediate type retained or forgotten"?
23:20:39 <erisco> how do you make something more efficient? are you generating code?
23:22:13 <ReinH> vaibhavsagar: djinn doesn't do typeclasses but that's fmap.
23:22:13 <erisco> if I am catching the drift of what you are wanting to do, then give up on doing it in Haskell and go try a dependently typed language, such as a theorem prover or Idris or w/e
23:22:19 <ski> simplegauss : you can store a "list" of composable functions, but then (if you do nothing), you can't recover the intermediate types, so it might not be that useful. but if you know you're always composing endofunctions, that's another matter
23:22:21 <simplegauss> erisco: yes, and also choosing algorithms. and simplifying intermediate expressions using some mathematical identities. basically the metadata i'm talking about can get quite complex, and complex enough for a simplifier to run on the list and sometimes be able to construct a more efficient implementation of the same function (by composing simpler functions).
23:22:30 <vaibhavsagar> ReinH: it does do some typeclasses
23:22:36 <ski> @djinn Monad m => a -> m a
23:22:37 <lambdabot> f = return
23:22:39 <ski> @djinn Monad m => b -> m b
23:22:39 <lambdabot> -- f cannot be realized.
23:22:40 <erisco> if you are just generating code then forget about doing anything fancy with types and just tag things with data
23:22:47 <ReinH> Huh
23:23:08 <ski> Djinn doesn't really understand polymorphic methods, because they amount to rank-2
23:23:22 <vaibhavsagar> I just added Applicative to a local copy and that seemed to work fine too
23:23:31 <vaibhavsagar> my question is why is Functor not included?
23:23:34 <simplegauss> tdammers: so your suggestion is to just have some abstract metadata type 'm' and then use typeclasses to implement whatever i need? I was thinking of this but it seems clunky.
23:24:05 <erisco> if you're wondering how to make an extensible data type then read Trees That Grow
23:24:13 <geekosaur> because djinn is not smart, and will do stuff like that weirdness ski just demonstrated
23:24:19 <geekosaur> you might be interested in exference
23:24:40 <geekosaur> https://github.com/lspitzner/exference
23:25:10 <geekosaur> (sadly exferenceBot seems to be stuck)
23:25:47 <vaibhavsagar> fair enough
23:26:08 <simplegauss> erisco: sometimes i am generating code, but that is then used in conjunction with user-provided functions in the host (in this case python) language.
23:26:19 <geekosaur> djinn doesn;t really understand typeclasses at all; there's apparently some hacks that sort-of work, but as ski showed with Monad they don't work very well
23:26:26 <simplegauss> anyway, thanks a lot everyone! i have at least two papers to read before i come back with more questions :)
23:26:41 <erisco> simplegauss, well, my answer with respect to types is the same either way. give up.
23:27:03 <vaibhavsagar> geekosaur: thanks, that clears things up
23:27:21 <lkurusa> I absolutely love this about Haskell: You can always go and read a paper about a topic
23:27:22 <erisco> if you reeeeally want to bruise your brain then go try lifting functions with the singletons package
23:28:56 <simplegauss> erisco: are you serious about "give up"? i'm seriously asking because i've actually been wondering if there are well-formed/useful programs that just can't be written in haskell. so far when i've gotten stuck i've found a way around it (with copious language extensions sometimes, but w/e)
23:29:14 <tdammers> simplegauss: if you know in advance what kind of things you are going to track, then you don't need a typeclass, you can just define a plain old data type for it
23:29:21 <dmwit> This all sounds like a boring old Monoid to me.
23:29:49 <erisco> simplegauss, it is predicated on whether I am catching the drift or not. This is all still vague, remember.
23:29:50 <MarcelineVQ> gross
23:29:51 <dmwit> data Function a = Function { injective, surjective, continuous :: All, run :: Endo a } deriving Monoid
23:30:05 <tdammers> simplegauss: and yes, of course there are programs that cannot be written in Haskell. G√∂del's Incompleteness Theorem applies.
23:30:22 <simplegauss> tdammers: if i did, then dmwit is right and the solution is simple :) i don't and would like to write some more "generic" code
23:31:02 <dmwit> Hard to get more generic than "toss another field in the record when you realize you need to", I think.
23:31:32 <tdammers> simplegauss: data Function meta a = Function { meta :: meta, run :: Endo a } deriving Monoid
23:31:51 <tdammers> then you just need to make sure you have a suitable Monoid for your meta type
23:32:14 <erisco> the universal answer is that you need to try whatever which way to implement whatever it is you are doing, because that is the only way you're going to clarify what it is you want
23:32:32 <dmwit> I don't see what abstracting in that way gets you. Now instead of adding a field to `Function` you add one to the type you filled in for `meta`. *shrug*
23:32:41 <erisco> and if that means stumbling around in code for a while then‚Ä¶ well, that's normal
23:36:20 <tdammers> dmwit: it buys you the ability to not have to decide upon the kind of metadata you want to track when working with the part of the codebase that combines those functions
23:36:58 <tdammers> dmwit: e.g. when you put this abstract machinery in a library, leaving the choice of things to track to the consumer
23:37:05 <simplegauss> tdammers: actually leading up to this i was trying "data Product cat1 cat2 a b = Product { c1 :: cat1 a b, c2 :: cat2 a b }" and made that an instance of category in the obvious way (this is even more restrictive than your Monoid example). i don't have much experience in the language so i was looking to see if there were better solutions
23:37:53 <tdammers> simplegauss: Monoid is arguably a little sloppy, even, but I believe that the things you will want to track are generally going to be monoids, so it's probably OK
23:38:14 <tdammers> simplegauss: and I would urge you to try the version without typeclasses first (the one dmwit suggested)
23:38:24 <tdammers> simplegauss: don't use typeclasses when a plain old data type would do
23:38:46 <ski> (also don't use existentials, unless there's a good reason to)
23:39:22 <tdammers> ski: for existentials this advice should be worded about an order of magnitude more sternly
23:39:27 <ski> @where existential-antipattern
23:39:27 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
23:39:56 <ski> tdammers : i mention this because simplegauss seemed to be considering this, above
23:39:58 <tdammers> btw., I should link to that one on my Haskell OOP blog posts
23:40:27 <tdammers> ski: yes, and that's good (you mentioning it, that is, not simplegauss considering it)
23:48:29 <simplegauss> i agree that in the example in that article it is cleaner to avoid typeclasses, but i think i saw an article by gabriel gonzalez where typeclasses are completely eluded in favor of datatypes, so using typeclasses is always a stylistic choice, right?
23:49:30 <simplegauss> i guess the logic in that article is "look, we didn't need typeclasses!" but isn't that always the case? i've actually been confused by this before, since the "you probably don't need a typeclass" argument is popular, but doesn't it basically always technically apply? how then are you supposed to use that to evaluate if you actually do need a typeclass?
23:50:20 <simplegauss> here is the gonzalez article i mentioned: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
23:51:14 <tdammers> I know that one; it's a stylistic choice in part, but also one of practicality
23:51:17 <phadej> simplegauss: no it isn't stylistic choice
23:51:36 <phadej> simplegauss: you cannot work with Map k v without _unique_ Ord k
23:52:28 <tdammers> phadej: you can, if you close over some function (k -> Ordering) with your Map. But that would be inconvenient, ugly, and could lead to nasty surprises.
23:52:38 <phadej> tdammers: you cannot write `union` with that
23:52:59 <phadej> because there might be different comparators in two maps.
23:53:01 <ski> phadej : you can, if you use existentials
23:54:12 <phadej> if I want to have *efficient* (uses the fact that maps are ordered the same) union :: Map k v -> Map k v -> Map k v
23:54:40 <simplegauss> ski: can you say how? i thought the fundamental problem was that functions can't be compared for equality?
23:55:30 <tdammers> phadej: ah yes, right... then you would have to pass the ordering function to all map operations, but then you can no longer guarantee the invariant that all map operations on the same map use the same ordering function...
23:55:50 <opqdonut> well you can check it run-time :P
23:56:09 <ReinH> Sometimes.
23:56:42 <opqdonut> I mean every time you use the ordering function, you can use both of the available ones, and error if they return different values
23:56:45 <opqdonut> but that's silly
23:56:46 <simplegauss> so in light of the two above articles, apart from some intuitive notion of style (and perhaps some corner cases where an efficient algorithm can't be implemented without typeclasses?) how should we think of using typeclasses at all? only to implement well-defined notions with lots of laws from category theory?
23:56:56 <ski>   data MapOps k = forall map. MkMapOps {empty :: forall v. map v ; union :: forall v. map v -> map v -> map v ; ...}
23:57:07 <ski>   mapOps :: forall k. Ord k => MapOps k
23:57:13 <tdammers> it's not a corner case, and it's not really about performance either
23:57:25 <ski> then you start by opening `mapOps'
23:57:48 <ski> basically, you cram the whole module interface into a record
23:58:03 <phadej> OO-approach :)
23:58:10 <ski> no, ADT-approach
23:58:33 <ski> this doesn't work with the OO-usage of existentials, because there you bundle operations with state
23:58:58 <phadej> for me OO is bundling operations with data
23:59:03 <phadej> not necessarily state
23:59:05 <ski> exactly
23:59:11 <ski> (which was what i meant)
23:59:19 <ski> a value of type `map v' here is the "state"
23:59:53 <ski> in the above approach you pass around raw values of type `map v'
