00:07:18 <royal_screwup21> I'm trying to understand why the answer to this question is what it is https://prnt.sc/i070e3 I'm not sure I understand what they mean by "fold up" the heap.
00:08:05 <royal_screwup21> like, what does it mean to fold up a data structure?
00:12:09 <dmwit> Well. Hopefully that book has discussed what it means by folds.
00:12:19 <dmwit> But you can search the web for "catamorphism" to see further examples.
00:12:25 <dmwit> There might be a Haskell wiki page on them, too.
00:14:25 <royal_screwup21> is it just a way of systematically replaced constructors by functions?
00:14:35 <royal_screwup21> s/replaced/replacing
00:14:50 <dmwit> Pretty much, yes.
00:15:09 <royal_screwup21> hmm but is what is the point of that?
00:15:27 <royal_screwup21> I'm looking at another example here https://stackoverflow.com/questions/9371530/tree-fold-operation
00:16:08 <royal_screwup21> they're folding up a list but what exactly is that accomplishing? Why would anyone want to fold up a list?
00:16:30 <xacktm> when you evaluate that fold, you get a single return value
00:16:38 <dmwit> The catamorphism is the universal consumer.
00:17:05 <dmwit> All functions on lists can be implemented in terms of a fold (plus a selector sometimes).
00:17:52 <mniip> if you had to introduce an axiom for destructuring lists,
00:17:56 <mniip> foldr would be a good idea
00:18:22 <mniip> haskell's []/: pattern matching is fine too, given we have general recursion
00:34:33 <jmorriss[m]> Could anyone give me pointers on writing seqOptional from the Data61 course (https://github.com/data61/fp-course/blob/master/src/Course/List.hs), this is my current code http://lpaste.net/361627 which will return List a, not Optional (List a)
00:45:19 <shafox> dmj`: yeah that i noticed, however i am confused about which library would be beneficial (doesnt has to be pure performance such as attoparsec) to write a grammar that can be useful in my case.
00:50:55 <royal_screwup21> so I tried to fold up a tree https://thepasteb.in/p/Q1hBPG6MNQrh8 if this implementation is correct, what can I do with it?
00:52:47 <royal_screwup21> there was a question that asked to foldup  a tree then find the total elements in the tree. I mean, I didn't quite get why you'd have to fold it up -- isn't it possible and just as efficient to traverse the tree without folding it up?
00:57:37 <dmwit> Thinks you can do with a tree fold: find the min (max) of the tree; sum the values in the tree; count the nodes in the tree; "reverse" the tree (swap the children at every internal branch).
00:57:44 <dmwit> Doing those might be handy exercises.
00:58:28 <dmwit> Yes, you can do everything with direct recursion that you can do with a tree fold.
00:58:46 <dmwit> (After all, the tree fold itself is implemented in terms of direct recursion...)
00:59:14 <dmwit> But pulling out the common recursion pattern does reduce the amount of reading and understanding that a consumer of your code need do.
00:59:36 <dmwit> He doesn't have to look at the direct recursion and check if it follows exactly the usual fold pattern, or does something slightly different than usual and therefore requires greater attention.
00:59:51 <dmwit> He can just see the function name `foldtree` and know it will be the standard recursion pattern.
01:03:37 <royal_screwup21> dmwit: hmm thanks for clarifying
01:07:41 <royal_screwup21> dmwit: with the implementation that I have here https://thepasteb.in/p/nZhlD0GomNmiY could you give me a pointer or two as to how I could find the sum of all elements in a tree
01:08:12 <royal_screwup21> I know how to do with direct recursion
01:08:29 <royal_screwup21> but I can't quite wrap my head around doing it with folds
01:08:37 * hackage io-string-like 0.1.0.0 - Classes to handle Prelude style IO functions for different datatypes  https://hackage.haskell.org/package/io-string-like-0.1.0.0 (clinton)
01:20:51 <dmwit> royal_screwup21: How do you do it with direct recursion?
01:23:10 <royal_screwup21> dmwit sum Leaf = 0; sum (Node x left right) = x + (sum left) + (sum right)
01:23:55 <dmwit> Cool.
01:24:07 <dmwit> Let's suppose that `sum = foldtree leaf node` for some `leaf` and `node`.
01:24:36 <dmwit> Now, we have `sum Leaf = 0` and `sum Leaf = foldtree leaf node Leaf`.
01:25:10 <dmwit> And `foldtree leaf node Leaf = leaf`.
01:25:24 <dmwit> Put those three equations together and we can learn what `leaf` is, yeah?
01:25:25 <royal_screwup21> yup
01:25:46 <dmwit> See if you can do the analogous reasoning for the `Node a left right` case.
01:28:07 * hackage intricacy 0.7.1.1 - A game of competitive puzzle-design  https://hackage.haskell.org/package/intricacy-0.7.1.1 (mbays)
01:29:12 <royal_screwup21> dmwit: so... leaf  = 0?
01:30:06 * hackage atomic-file-ops 0.1.0.0 - Functions to atomically write to files  https://hackage.haskell.org/package/atomic-file-ops-0.1.0.0 (clinton)
01:30:18 <dmwit> royal_screwup21: Right!
01:37:39 <dmwit> royal_screwup21: And for `node`...?
01:41:14 <royal_screwup21> dmwit: is it something like this? https://thepasteb.in/p/2RhK3qVjmgWH4dm
01:42:30 <dmwit> That link doesn't work for me.
01:43:10 <royal_screwup21> huh, weird. Anyway, try this https://thepasteb.in/p/pghQor9jnljUR
01:43:37 <dmwit> Nice job!
01:43:52 <dmwit> "size" is the wrong name for that, though. It's sum!
01:44:15 <dmwit> I would also consider inlining the definitions of `leaf` and `node`.
01:44:27 <dmwit> So `sum1 = foldtree 0 (\x l r -> x+l+r)`.
01:45:42 <royal_screwup21> cool thanks for the continued guidance dmwit :)
01:46:27 <Tehnix> Anyone know what `A package using 'cabal-version: &gt;=2.0' must use section syntax. See the Cabal user guide for details.` (with GHC 8.2) means? Not much help in the user guide ._.
01:47:30 <Lokathor> http://lpaste.net/361628 so for some reason, it'll print each "line was" part when you type in lines
01:47:38 <Lokathor> but it won't print the debug stuff trying to check the history
01:48:51 <dmwit> Tehnix: Throw your cabal file up on lpaste.
01:50:00 <dmwit> Lokathor: The debug stuff mentioned in `betterGetLine`?
01:50:06 <Lokathor> yeah that stuff
01:50:08 <Lokathor> none of it prints
01:50:11 <dmwit> Lokathor: You never call `betterGetLine`.
01:50:17 <dmwit> It's not mentioned at all anywhere else in the file.
01:50:19 <Lokathor> oh boy
01:50:39 <Lokathor> it might be too late at night to be doing this >_<
02:33:54 <srhb> Do any of the shell scripting libraries contain a nice way of modifying both stderr and stdout of the processes? My use case is fairly simple: I want to prefix every line with something specific (think (hostname <> ":" <> ...)) -- this is easy in the case of turtle and stdout, but not quite so with stderr, as far as I can see.
02:38:14 <srhb> Essentially what I'm missing is a bimap over the output streams I suppose.
02:39:54 <srhb> hmm, okay, turtle has inprocWithErr, that might suffice.
03:07:07 * hackage io-string-like 0.1.0.1 - Classes to handle Prelude style IO functions for different datatypes  https://hackage.haskell.org/package/io-string-like-0.1.0.1 (clinton)
03:14:36 * hackage atomic-file-ops 0.1.0.1 - Functions to atomically write to files  https://hackage.haskell.org/package/atomic-file-ops-0.1.0.1 (clinton)
03:18:04 <amca> Quick question: if I'm using the Data.Modular module, how can I obtain the modulus of a value?  Like if I set x = 3::Integer/7 say, how do I obtain the modulus 7 from x?
03:42:54 <amca> Got it! Use Data.Typeable, and then it's simply: digitToInt $ head $ show $ typeRef x
03:56:58 <mniip> what
04:48:06 * hackage yaml 0.8.26 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.26 (MichaelSnoyman)
05:27:47 <Myrl-saki> MVC or FRP?
05:28:07 <Myrl-saki> (Elm is MVC, right?)
05:31:06 * hackage type-of-html 1.3.2.1 - High performance type driven html generation.  https://hackage.haskell.org/package/type-of-html-1.3.2.1 (knupfer)
05:31:59 <Rembane> Myrl-saki: FRP is cooler, go for it!
05:33:15 <Myrl-saki> Rembane: Yeah, I normally use FRP for my projects, but I'm not so sure how well FRP works when your "view" is meant to be malleable.
05:34:10 <Myrl-saki> Rembane: I'm thinking of making a text editor using FRP, but if it's hard, I'm thinking of just using rasa, which is a bit closer to MVC.
05:34:40 <Rembane> Myrl-saki: Use FRP if you don't have any deadlines, with some luck you will at least come to new insights.
05:36:13 <Myrl-saki> Rembane: True.
05:36:34 <Myrl-saki> Rembane: I'm thinking of how to do "view" on FRP though.
05:36:47 <Myrl-saki> Rembane: I guess I can also let the individual componennt handle that.
05:37:14 <Rembane> Myrl-saki: Let the data create the view. I have no idea how to explain this. :D
05:37:46 <Myrl-saki> Rembane: Something analogous to eval?
05:44:23 <Rembane> Myrl-saki: Hm... maybe, you have a fold which folds the stream of events into a view.
05:45:53 <Myrl-saki> Rembane: Hmm
05:46:07 <Myrl-saki> Rembane: I'll try to do FRP and ping back what I've made.
05:51:43 <Rembane> Myrl-saki: Sweet! Good luck!
05:53:45 <cheater> is there something like lazy lists that are backed by a high-performance db in case my ram is not enough? something that'll optimize access, keep caches, etc? i'm thinking of something that can be dropped in instead of normal lazy lists, similarly to how you can use data parallel haskell lists almost directly instead of normal lists
05:54:36 * hackage protolude 0.2.1 - A small prelude.  https://hackage.haskell.org/package/protolude-0.2.1 (sdiehl)
05:55:57 <AndreasK> What are you doing where you only ever traverse your list in order, need it all constructed but it doesn't fit in RAM?
05:56:33 <AndreasK> I don't have a solution but am curious about the Problem
05:57:37 <Rembane> More virtual memory!
06:19:51 <zennist> anyone remembers the name of ekmett's library that converts normal monad transformer into performance-improved right-associative variants? I remember reading about it somewhere, but now I don't remember the name anymore
06:26:01 <disfunctional> hello everyone, anyone experienced with gtk3 willing to help me out?
06:26:03 <hpc> zennist: oh wow, it's on the tip of my tongue
06:26:23 <zennist> hcp: I've been searching for this half an hour now -.-
06:27:06 <hpc> maybe this list will help: http://hackage.haskell.org/user/EdwardKmett
06:27:42 <hpc> i want to say it's free, but i have never needed to use that particular trick so i don't remember exactly
06:28:00 <disfunctional> i'm having issues rebinding a button callback dynamically http://lpaste.net/361632 <- see last line
06:28:49 <disfunctional> the form regenerates adequately, though only the button refers to the old objects, i believe im lacking some fundamental haskell knowhow in solving this
06:29:10 <zennist> thanks, will go through the list one by one I think ==; I know the one for Free, that is Control.Monad.Free.Church, but the more general form that applies to any monad binds is the one I couldn't find...
06:44:07 <kakashiAL> stupid question but does the cons operator :, is named cons because cons stands for "construct"?
06:46:02 <ania123> I know, here are intelligent people. I want to give following to quwstions students:
06:46:04 <hpc> that sounds right
06:46:09 <hpc> the term originated in lisp
06:46:12 <ania123> 1. Analyze merge sort and quick sort algorithms.
06:46:21 <ania123> 2. Compare merge sort vs quick sort, which algorithm is better? why is better?
06:46:28 <ania123> any comments, sugestions?
06:48:14 <hpc> quicksort has a lot of variations in how you pick the pivot point
06:48:30 <ania123> i know
06:48:39 <hpc> most people learn either the pivot is always the first element, or always the middle element, or always picked randomly
06:48:51 <hpc> if they pick randomly, the rng is another input to the function in haskell
06:48:58 <hpc> which changes the type
06:49:05 <ania123> yes
06:50:01 <hpc> the standard library has a pretty well optimized mergesort implementation you can look at too
06:50:45 <hpc> https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.OldList.html#sortBy
06:50:57 <hpc> that's all i can think of that would be noteworthy specifically to haskell programmers
06:51:49 <hpc> i would probably adjust question 2 to be "when is each better than the other" as well
06:51:58 <hpc> very few sorting algorithms are strictly better than another in all scenarios
06:52:56 <hpc> and it's a nice segue into a lot of other topics like optimizing based on use case, and how to pick an algorithm in general
06:53:06 * hackage servant-auth-cookie 0.6.0.3 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.6.0.3 (zohl)
06:53:26 <ania123> hpc:
06:53:29 <ania123> like this:
06:53:31 <ania123>  Compare merge sort vs quick sort, explain when is each better than the other?
06:53:53 <hpc> yeah, something like that
06:54:42 <ania123> ok, thx
06:57:03 <jchia_> How can I read IEEE-754 64-bit doubles from a ByteString? Can I use the binary package? I'm not sure what encoding they use. Is there a simpler way?
06:58:28 <hpc> jchia_: as in, the string "1.2345" packed into bytes?
06:59:03 <jchia_> hpc: Raw 64-bit IEEE-754 value stored in 8 bytes.
06:59:05 <hpc> jchia_: or as in a substring of 8 bytes fitting the IEEE-754 spec?
06:59:07 <hpc> ah
06:59:26 <hpc> hmm
06:59:49 <jchia_> What I really have is a file, but I can read that into a ByteString first.
07:00:01 <hpc> if you can get those bytes out as a Word64, https://hackage.haskell.org/package/data-binary-ieee754-0.4.4/docs/Data-Binary-IEEE754.html#v:wordToDouble
07:01:09 <jchia_> hpc: Looks like binary works
07:01:28 <jchia_> I think I can just use getFloat64le.
07:01:58 <hpc> @hoogle getFloat64le
07:01:59 <lambdabot> Data.Serialize.IEEE754 getFloat64le :: Get Double
07:01:59 <lambdabot> Data.Binary.IEEE754 getFloat64le :: Get Double
07:02:04 <hpc> ah nice
07:08:28 <kakashiAL> stupid question but does the cons operator :, is named cons because cons stands for "construct", right?
07:15:47 <jchia_> kakashiAL: I think it came from lisp: https://www.gnu.org/software/emacs/manual/html_node/eintr/car-cdr-_0026-cons.html
07:16:08 <jchia_> https://en.wikipedia.org/wiki/CAR_and_CDR
07:16:39 <kakashiAL> jchia_: so yes, it standst for construct :)  cons-operator == construct-operator :)
07:17:08 <kakashiAL> jchia_: or better said: cons-operator == construct-list-operator :)
07:21:25 <Ariakenom> Hello. Was there some irc for GHC compilery things?
07:22:20 <Ariakenom> anyway
07:22:24 <Ariakenom> STG. stack. does it not have argument frames since eval/aaply change?
07:32:53 <hydraz> Ariakenom: try #ghc
07:34:58 <Ariakenom> thanks!
07:59:06 * hackage stagen 0.1.0 - Static site generator  https://hackage.haskell.org/package/stagen-0.1.0 (jxv)
08:02:00 <EvanR> "a discrete clock can be thought of as a continuous one in which there is an error of up to 1/2 "tick" in reading it" -- lamport
08:03:02 <MarcelineVQ> :D
08:34:45 <pk6vx0x2_> are any of you guys using haskell-ide-engine (in neovim but not sure that's actually relevant)
08:35:27 <infinisil> pk6vx0x2: you may want to check out #haskell-ide-engine
08:36:26 <pk6vx0x2> infinisil: thanks, will give that a shot.
08:59:07 * hackage bishbosh 0.0.0.1 - Plays chess.  https://hackage.haskell.org/package/bishbosh-0.0.0.1 (AlistairWard)
09:28:07 <thegreekc> can someone please elaborate the curry and uncurry functions? why do i need it? what is it useful for? i tried to read this article: https://wiki.haskell.org/Currying but i can't seem to understand what is it good for.
09:28:58 <thegreekc> or a better link to read which explain in more depth.
09:29:19 <thegreekc> i also not understand the exercises in the buttom of this page :-)
09:29:30 <amalloy> it's useful if, for example, you have (a,b) and a function (a -> b -> c)
09:29:46 <[exa]> thegreekc: multi-parameter functions can be converted either as functions from tuples to result, and curried form. These functions just convert the 2 forms.
09:29:51 <amalloy> > uncurry (+) (1,2)
09:29:56 <lambdabot>  3
09:30:36 <[exa]> thegreekc: s/converted/represented/
09:30:56 <thegreekc> so it is just helper functions to move from touple -> variable or move from variables -> tuples?
09:31:25 <[exa]> yes, mostly
09:32:26 <monochrom> If you don't need it, then don't worry about it.
09:33:07 <thegreekc> OK, os there is one exercise in this web page that want me to simplify: curry id. can you guide me what exactky should i do?
09:33:45 <thegreekc> monochrom: i do not know what i need or what i don't need. i came across it in the exercises in the book of graham hutton :-)
09:33:50 <monochrom> Too many people overthink the standard library too much. They just assume out of thin air that every function in the library has a deep philosophy behind and every real world application uses it a thousand times.
09:33:52 <amalloy> write down some types and try to match them up with each other
09:34:32 <TMA> thegreekc: a -> b -> c  is a shorthand notation for  a -> (b -> c)  i.e. a function from a to functions from b to c. mathematically the distinction does not entail much, in programming (and haskell in particular) the distinction is important because of technical differences between (a, b) -> c and a -> b -> c
09:34:36 <monochrom> Whereas in reality it is just because one single person on the committee wants it included "for the sake of completeness" and the other persons are too polite to say no.
09:34:45 <[exa]> > (curry id) 2 3    --thegreekc
09:34:49 <lambdabot>  (2,3)
09:35:03 <[exa]> fancy side-effectish way to create tuples
09:35:15 <ReinH> "side-effectish"?
09:35:48 <[exa]> I should think more before using a word with 2 or more meanings. :]
09:37:27 <thegreekc> no more questions for now. thanks all the helpers here :-)
09:37:57 <monochrom> Even with the game-theory understanding that "if I say yes to your today, tomorrow you will say yes to mine"
09:49:22 <dmwit> I have used uncurry a handful of times. The fact is that tuples are the de-facto way to produce multiple arguments, but not the de-facto way to consume multiple arguments.
09:49:27 <dmwit> curry I have used much less frequently.
09:51:12 <dmwit> For example, I frequently wish that Data.Map.insert* started with `(k,v) -> ` instead of `k -> v ->`.
09:52:26 <dmwit> (Consequently I use this convention in my ordered-containers package.)
09:56:34 <Myrl-saki> :t intersperse
09:56:37 <lambdabot> a -> [a] -> [a]
09:56:37 <Myrl-saki> :t intercalate
09:56:39 <lambdabot> [a] -> [[a]] -> [a]
09:57:10 <dmwit> For what it's worth, I have only ever wanted intercalate, never intersperse.
09:57:14 <Gurkenglas_> dmwit, can you give an example where `(k,v) -> ` comes in handy?
09:58:19 <dmwit> e.g. when you are transfering a value from one map to another; all of the functions which consume Maps give you back `(k,v)` pairs.
09:58:57 <dmwit> But no, off the top of my head I cannot remember the details of a real-world use case.
09:59:16 <Gurkenglas> I suppose a record of maps is more compact than a map of eithers
09:59:21 <dmwit> I just remember a repeated vague unease. =P
10:00:30 <glguy> A record of maps would allow you to have one key associated with multiple values at each of the types
10:00:44 <glguy> Oh, you mean eithers in the keys
10:00:54 <Gurkenglas> no, in the values, and you're right
10:01:18 <Gurkenglas> (Map k v, Map k v) vs. Map k (Bool, v)
10:01:44 <mniip> 1515952604 [20:56:44] <dmwit> For what it's worth, I have only ever wanted intercalate, never intersperse.
10:01:51 <mniip> swedish = intersperse 'f'
10:02:12 <glguy> I think if I knew Swedish I could understand that joke
10:02:29 <dmwit> What is this 1515952604?
10:02:30 <sedeki> i understand swedish and I don't see what's funny
10:02:38 <Myrl-saki> glguy: If you know cat images, you would understand the joke.
10:02:41 <dmwit> I am not a number.
10:02:43 <geekosaur> I've used intersperse a few times, but intercalate is much more common
10:02:45 <hpc> dmwit: posix timestamp
10:02:51 <hpc> dmwit: you are number 6
10:03:00 <dmwit> WHO IS NUMBER ONE?
10:03:10 * yoho twirls
10:03:10 <yoho> me
10:03:12 <sedeki> Ken Thompson
10:03:28 <hpc> that show was great
10:03:30 <glguy> > Data.Time.Clock.POSIX.posixSecondsToUTCTime 1515952604
10:03:35 <lambdabot>  error:
10:03:35 <lambdabot>      Not in scope: ‘Data.Time.Clock.POSIX.posixSecondsToUTCTime’
10:03:35 <lambdabot>      No module named ‘Data.Time.Clock.POSIX’ is imported.
10:03:45 <hpc> @import Data.Time.Clock.POSIX
10:03:45 <lambdabot> Unknown command, try @list
10:03:48 <dmwit> Oh hey, that reminds me.
10:03:50 <hpc> > let import Data.Time.Clock.POSIX
10:03:53 <hpc> er
10:03:54 <lambdabot>  <hint>:1:5: error: parse error on input ‘import’
10:03:55 <geekosaur> % Data.Time.Clock.POSIX.posixSecondsToUTCTime 1515952604
10:03:55 <yahb> geekosaur: 2018-01-14 17:56:44 UTC
10:04:04 <geekosaur> there are easier ways :p
10:04:08 <geekosaur> and it's @let import ...
10:04:10 <dmwit> Recently, I've been seeing ghci occasionally tell me "such and such module is not imported" when I try to do that kind of thing.
10:04:28 <dmwit> I thought ghci was supposed to let you use any fully-qualified name you wanted. What gives?
10:04:31 <glguy> dmwit: new-repl?
10:04:36 <dmwit> probably
10:04:41 <dmwit> Does new-repl break that somehow?
10:05:03 <glguy> If the package in question isn't in the set of packages used by new-repl it probably doesn't exist to that GHCi instance
10:05:27 <geekosaur> ...same as stack ghci
10:05:34 <dmwit> I have verified that I can import the module and then use the thing I wanted to use.
10:05:35 <geekosaur> which we've had people trip over in here before
10:05:49 <geekosaur> otherwise, might indicate a problem with the package db
10:06:07 <geekosaur> "ghc-pkg check" and/or "ghc-pkg recache --user" might be
10:06:14 <geekosaur> good ideas (whoops)
10:06:16 <glguy> I'm speculating, though. Given the spiderweb of dependencies you can build up in a new-build store it just wouldn't surprise me if some packages are unreachable
10:06:45 <dmwit> I'll ask again next time it happens so I can do experiments and stuff instead of just trying to remember what happens.
10:07:36 * hackage hspec-smallcheck 0.5.0 - SmallCheck support for the Hspec testing framework  https://hackage.haskell.org/package/hspec-smallcheck-0.5.0 (SimonHengel)
10:07:40 <glguy> mniip: Does your client show you posix timestamps or is that only when you use the clipboard?
10:08:12 <mniip> clipboard only
10:08:55 <mniip> hexchat has a special format char for "hiding" stuff so that it's not displayed on screen but is included in clipboard copy
10:09:06 <mniip> I stuck a hidden %s in my timestamp format
10:12:07 <mniip> %! date --date @1515952604
10:12:07 <yahb> mniip: Sun Jan 14 17:56:44 UTC 2018
10:16:11 <monochrom> @type intersperse 'f'
10:16:13 <lambdabot> [Char] -> [Char]
10:16:26 <monochrom> intersperse 'f' "hello"
10:16:30 <monochrom> err
10:16:32 <monochrom> > intersperse 'f' "hello"
10:16:38 <lambdabot>  mueval-core: Time limit exceeded
10:16:44 <mniip> perfect
10:16:51 <monochrom> > intersperse 'f' "hello"
10:16:52 <dmwit> v swedish
10:16:55 <lambdabot>  "hfeflflfo"
10:17:06 <mniip> hfeflflfof fsaftfofsfhfi
10:17:57 <mniip> > let swedish = intersperse 'f'; very f x = f $ f $ f x; greeting = "hello" in very very swedish greeting
10:18:04 <lambdabot>  mueval-core: Time limit exceeded
10:18:09 <mniip> :I
10:18:35 <mniip> go try that in your local ghci
10:19:06 * hackage xml-conduit 1.7.1.0 - Pure-Haskell utilities for dealing with XML with the conduit package.  https://hackage.haskell.org/package/xml-conduit-1.7.1.0 (koral)
10:20:07 <monochrom> Yikes
10:20:30 <AndreasO> Why Swedish?
10:21:15 <dmwit> > 3^27
10:21:18 <lambdabot>  7625597484987
10:21:55 <mniip> yeah
10:22:01 <mniip> if you try to pronounce that you die
10:22:10 <AndreasO> I’m swedish, going to try Haskell.
10:22:18 <monochrom> haha
10:22:21 <mniip> but not if you've got one of those lungblowing machines
10:22:30 <dmwit> mniip: I'm a bagpiper, I know circular breathing.
10:22:48 <dmwit> I wonder what kind of fps you can get if you practice.
10:23:00 <dmwit> > 7625597484987/60/60/60/24/365
10:23:02 <mniip> f per second?
10:23:03 <lambdabot>  4030.101833347603
10:23:16 <dmwit> mniip: yes =)
10:23:25 <dmwit> 4 kiloyears ain't bad.
10:23:39 <dmwit> Of course, that's just the first set of fs. Then you get to the g.
10:23:52 <mniip> no
10:23:59 <mniip> the e
10:24:07 <hpc> mniip: jeez, that expands to 536870913 characters
10:24:21 <mniip> hpc, should be more last time I checked
10:24:30 <dmwit> mniip: ...yes. I made two errors in there.
10:24:58 <mniip> ah indeed, hpc is correct
10:25:39 <dmwit> No, he's off by 5. =P
10:25:47 <dmwit> Oh, no, the problem is that I can't read.
10:25:48 <mniip> he's not
10:25:57 <dmwit> Wow. I should maybe just stop.
10:26:22 <mniip> very very swedish = very $ very $ very swedish
10:26:25 <mniip> that's 27 swedish
10:26:36 <mniip> which is ah yeah, 2^27-1
10:27:05 <AndreasO> dmwit: what are you doing?
10:27:22 <mniip> mere 25 days if you're a professinal f-er like dmwit
10:27:49 <dmwit> (2^27, 536870913)
10:27:52 <dmwit> > (2^27, 536870913)
10:27:54 <lambdabot>  (134217728,536870913)
10:28:04 <mniip> well, per letter of greeting of course
10:28:06 <dmwit> AndreasO: Making a lot of mistakes, apparently.
10:28:27 <mniip> (2^27-1)*(5-1)+1
10:28:34 <mniip> no that's wrong
10:28:39 <dmwit> I think it's wrong.
10:28:39 <AndreasO> dmwit: doing something with Swedish??
10:28:44 <mniip> (2^27-1)*(5-1)+5
10:29:00 <mniip> AndreasO, pronouncing the hardest swedish word
10:29:01 <geekosaur> swedish fishing >.>
10:29:02 <dmwit> > (2^27-1)*4+5
10:29:07 <Rembane> Hallå! I Göteborg kan du köpa Haskell på burk!
10:29:07 <lambdabot>  536870913
10:29:21 <dmwit> mniip++
10:29:25 <dmwit> very very ++
10:29:41 <AndreasO> I can help you with the Swedish.
10:29:52 <mniip> > very $ very swedish greeting
10:29:56 <lambdabot>  error:
10:29:57 <lambdabot>      • Couldn't match expected type ‘t -> t’ with actual type ‘[Char]’
10:29:57 <lambdabot>      • Possible cause: ‘very’ is applied to too many arguments
10:30:01 <Rembane> What are you doing? Oo
10:30:02 <mniip> dangit
10:30:08 <mniip> > very (very swedish) greeting
10:30:11 <lambdabot>  "hffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff...
10:32:12 <dmwit> AndreasO: I'm sorry to get your hopes up. This has all been part of an elaborate joke aimed at filling a slow moment in #haskell. Nobody here is actually doing anything Swedish-ish.
10:32:33 <MarcelineVQ> it's true, swedish has more b's
10:32:34 <dmwit> Or at least, they have not been discussing it in here in the last few minutes.
10:32:47 <Rembane> dmwit: How do you define very using lambdabot?
10:32:58 <AndreasO> Dmwit: Ah, so there slow moment
10:33:32 <mud> @let omgStuff = "omg, stuff" -- Rembane
10:33:35 <lambdabot>  Defined.
10:33:39 <mud> > omgStuff
10:33:43 <lambdabot>  "omg, stuff"
10:33:53 <Rembane> mud: Pandora's box! :D
10:33:54 <AndreasO> Talk about vectors and quaternions, that’s funny shit!
10:34:13 <Rembane> @let f = "The ultimate Swedish" ++ f
10:34:14 <lambdabot>  .L.hs:166:31: error:
10:34:15 <lambdabot>      Ambiguous occurrence ‘f’
10:34:15 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
10:34:21 <Rembane> @let f' = "The ultimate Swedish" ++ f'
10:34:23 <lambdabot>  .L.hs:166:32: error:
10:34:23 <lambdabot>      Ambiguous occurrence ‘f'’
10:34:23 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f'’,
10:34:26 <Rembane> Meh
10:34:29 <geekosaur> heh
10:34:36 <Rembane> @let f''''' = "The ultimate Swedish" ++ f'''''
10:34:38 <lambdabot>  Defined.
10:34:40 <Rembane> :D
10:34:43 <Rembane> > f'''''
10:34:46 <lambdabot>  "The ultimate SwedishThe ultimate SwedishThe ultimate SwedishThe ultimate Sw...
10:34:55 <Rembane> :D
10:35:25 <AndreasO> Sverige är bäst!!
10:35:32 <monochrom> Say after me: Swedish Swiss fish dish.
10:36:14 <Rembane> The swish army fish?
10:36:27 <MarcelineVQ> (truly . truly $ Gem :: Outrageous) :: Outrageous
10:36:55 <dmwit> Are there any typing-twisters?
10:38:06 * hackage Villefort 0.1.2.9 - Villefort is a task manager and time tracker written in haskell.  https://hackage.haskell.org/package/Villefort-0.1.2.9 (ChrisReuter)
10:38:08 <AndreasO> ”Sex laxar i en laxask” try saying that really fast.
10:39:14 <monochrom> I think some libraries have type-twister infix operators :)
10:49:54 <malorie> what's a type-twister?
10:50:24 <monochrom> Analogous to tongue twister
10:50:27 <MarcelineVQ> a type that's fun to say
10:50:50 <mud> Like all of the s t a b in lens?
10:51:00 <malorie> oh, so I thought :-)
10:53:05 <koz_> :t confusing
10:53:08 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
10:53:10 <koz_> ^ type-twister
10:53:25 <koz_> (also, did that change again while I wasn't looking?)
10:57:06 * hackage pandoc-types 1.17.3.1 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.17.3.1 (JohnMacFarlane)
10:58:24 <sm> g'day all! shelltestrunner has a new release and a new support channel: #shelltestrunner. More: https://github.com/simonmichael/shelltestrunner#readme
10:59:22 <sm> hackagebot, you should have mentioned it
11:03:46 <cinimod> Has anyone seen this before: `Setup: hmatrix.cabal:119: 'then' branch of 'if' is empty`
11:12:24 <hux> Hello everyone
11:13:02 <hux> Does anyone know if its easy to combine differents types in free monad ?
11:13:22 <hux> I see that people use Sum a b for two types but what about having more types ?
11:13:30 <hux> Should I nest Sum ?
11:13:36 <Rembane> hux: Yes!
11:13:48 <Rembane> hux: Use Sum as you use a list.
11:13:55 <Rembane> hux: a : b : c : d : e
11:14:03 <Rembane> hux: a : b : c : d : e : []
11:14:05 <hux> Rembane: any example ?
11:14:23 <Rembane> hux: Not that I can think of, just be careful to make it a list and not a tree.
11:15:08 <Taneb> Rembane, why does it matter whether it's list-like or tree-like?
11:15:37 <Rembane> Taneb: Maybe it doesn't, it's a gut feeling that says it becomes faster and nicer if it's list like.
11:15:41 <hux> Rembane: Will try, thanks :)
11:18:31 <glguy> cinimod: What tool are you building hmatrix with? What version of that tool?
11:19:08 <hux>  Rembane: http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf
11:19:17 <hux> Rembane: Is that a good way ?
11:19:50 <Rembane> hux: I'm afraid I don't really get what you want to do.
11:20:13 <glguy> cinimod: and what platform are you building on? freebsd/linux/macos?
11:21:32 <glguy> Anyway, I have to run but maybe someone else can help. Maybe you need to upgrade your tool to get a newer Cabal library version, or maybe the mismatched indentation for freebsd is a problem, or something else, who knows :)
11:22:26 <hux> Rembane: Part 4 could be useful I think
11:24:37 * hackage hmm-hmatrix 0.1 - Hidden Markov Models using HMatrix primitives  https://hackage.haskell.org/package/hmm-hmatrix-0.1 (HenningThielemann)
11:26:06 <Unode> join #rust
11:26:19 <Unode> oops :)
11:40:22 <thegreekc> > curry . uncurry (+) a b
11:40:26 <lambdabot>  error:
11:40:26 <lambdabot>      • Couldn't match expected type ‘(Expr -> a -> (a1, b) -> c,
11:40:26 <lambdabot>                                       Expr -> a -> (a1, b) -> c)’
11:40:34 <thegreekc> > (curry . uncurry) (+) a b
11:40:40 <lambdabot>  a + b
11:41:37 <thegreekc> > uncurry (+) a b
11:41:41 <lambdabot>  error:
11:41:41 <lambdabot>      • Couldn't match expected type ‘(Expr -> t, Expr -> t)’
11:41:41 <lambdabot>                    with actual type ‘Expr’
11:42:18 <thegreekc> > uncurry (+) (a, b)
11:42:22 <lambdabot>  a + b
11:42:29 <thegreekc> > it
11:42:32 <lambdabot>  error:
11:42:32 <lambdabot>      • Variable not in scope: it
11:42:32 <lambdabot>      • Perhaps you meant one of these:
11:43:12 <geekosaur> lambdabot is not ghci
11:43:53 <thegreekc> can someone please explain what is going on? for example: (curry . uncurry) (+) a b ; how is it execute? i'm confused.
11:44:29 <mud> :t curry . uncurry
11:44:32 <lambdabot> (a -> b -> c) -> a -> b -> c
11:46:37 <mud> thegreekc: So a lot of how you can unwrap these types of things is just by equational reasoning. Meaning that if things are equal, you're allowed to substitue them in for each other. So  curry . uncurry is just ... id, the function that gives back its input unchanged. So then you have (id) (+) a b    and   id z = z  since that's exactly what 'id' does.  So then you just have (+) a b  which is just the (+) function applied to two arguments.  Another way of
11:46:39 <mud> writing that is: a + b
11:47:51 <thegreekc> mud: but it is not clear. i'm not understand this: (curry . uncurry) (+) a b ; at first i think it execute uncurry (+) a b but it cant because uncurry need tuple so how it is execute?
11:49:25 <mud> :t uncurry
11:49:27 <lambdabot> (a -> b -> c) -> (a, b) -> c
11:49:29 <thegreekc> > uncurry (+) (a,b)
11:49:32 <lambdabot>  a + b
11:49:38 <[exa]> thegreekc: rewriting the . out you get (curry (uncurry (+))) a b
11:49:42 <hololeap> what functor could be plugged into Cofree to get a binary tree structure?
11:50:01 <mud> :t uncurry (+)
11:50:03 <lambdabot> Num c => (c, c) -> c
11:50:11 <mud> :t curry (uncurry (+))
11:50:13 <lambdabot> Num c => c -> c -> c
11:51:20 <[exa]> thegreekc: so it first converts (+) to tuple-ish (+), then back to normal (+), and then sends arguments to it.
11:52:04 <thegreekc> [exa]: what do you mean tuple-ish (+)? it's new for me :-)
11:52:12 <hpc> :t uncurry (+)
11:52:14 <lambdabot> Num c => (c, c) -> c
11:52:17 <hpc> :t (+)
11:52:19 <lambdabot> Num a => a -> a -> a
11:52:24 <thegreekc> ah!
11:52:31 <hpc> :D
11:53:29 <hexagoxel> hololeap: data Pair a = Pair a a
11:54:10 <hpc> hololeap: write your ordinary binary tree type, then replace recursion with a parameter
11:54:19 <hpc> so like, data Foo = Blah | Whatever Foo
11:54:27 <hpc> becomes data Foo f = Blah | Whatever f
11:54:57 <hpc> in this case, data TreeFree f = Leaf | Branch f f
11:55:35 <hololeap> hpc: the problem wit that is, each node has to have either zero or two branches, no?
11:55:40 <hexagoxel> (what i said gives you an infinite tree though..)
11:55:57 <[exa]> thegreekc: the uncurried one is "tuple-ish" :]
11:55:58 <hpc> yes
11:56:04 <hpc> that's how a binary tree works ;)
11:56:15 <hololeap> the best I've come up with is: data TreeFree f = Branch f f | L f | R f | Leaf
11:56:53 <hololeap> maybe that's as simple as it gets...
11:56:59 <hpc> that would work too, if you want your tree type to have long chains without branches
11:57:19 <hpc> maybe you could also do data TreeFree f = Tadaa (Maybe f, Maybe f)
11:57:54 <hpc> but you gain more from the extra constructors when you're writing functions on it
11:59:13 <Hi_mynameisKonra> hi everyone. Just telling, your channel has been recommended to me.
11:59:38 <hololeap> well, i was hoping to get some things "for free" by forming it out of Cofree, but maybe it's simpler just to write it from scratch. this is for a hackerrank challenge, so only a few libraries are available (Cofree appears to be one of them)
12:01:00 <thegreekc> 21:50 [exa]: "so it first converts (+) to tuple-ish (+), then back to normal (+), and
12:01:00 <thegreekc>               then sends arguments to it." OK but other things not working like that (so i think :-D) for eample:  head . tail $ [1,2,3] it dirst apply tail and then to the *result* it apply head. why in the case above (curry . uncurry) it is not working like that?
12:01:08 <hololeap> i don't see any binary tree structure in the standard libraries
12:02:23 <hololeap> also, the possibility of an empty tree means it isn't really a Comonad
12:02:32 <hololeap> oh well
12:10:59 <runeks> Is there an equivalent of QuickCheck's "listOf" for SmallCheck? Or how do I generate a list of values for something with a "Serial m" instance?
12:12:27 <runeks> Never mind. I've realized my mistake
12:12:38 <MarcelineVQ> what was it?
12:14:04 * dmwit waves in Hi_mynameisKonra's direction
12:14:10 <dmwit> Are you learning Haskell?
12:24:23 <runeks> MarcelineVQ: my mistake?
12:28:36 <wedify> runeks: yep
12:31:39 <runeks> wedify: The lambda I had passed to "suchThat" (https://www.stackage.org/haddock/lts-9.21/smallcheck-1.1.2/src/Test.SmallCheck.Series.html#line-229) took a list item as an argument, rather than a "NonEmpty a" as its argument
12:31:46 <runeks> Not sure why that function isn't exported, though...
12:32:25 <runeks> Although now the test hangs if I specify a depth >= 6 :(
13:19:02 <Average-user> Anyone know the complexity of indexing in arrays of Data.Array? In the documentation arent too specific, or at least I did not found anything
13:19:14 <dmwit> Array indexing is O(1).
13:19:26 <dmwit> Plus whatever it costs to convert your index to an Int, of course.
13:22:06 * hackage vicinity 0.1.0 -   https://hackage.haskell.org/package/vicinity-0.1.0 (andrewthad)
13:22:29 <ggVGc> I've seen people advocate to never use case matching on Maybe, but I do it quite a lot because I find it a lot more readable in many cases
13:22:32 <ggVGc> am I being dumb?
13:22:46 <MarcelineVQ> no
13:23:05 <dmwit> That's an odd thing to advocate.
13:23:25 <ggVGc> dmwit: the logic is something along the lines of Data.Maybe supplying utility functions for all use cases
13:23:26 <mud> I don't think I've ever heard that advice. At best I'd say that if you have a bunch of deeply nested case matches, you might want to use the Monad instance instead perhaps.
13:23:45 <Rembane> I'm in the "it depends"-camp. Use whatever is easiest to read.
13:24:01 <Rembane> And if it goes too hairy I jump into the Maybe monad.
13:25:05 <amalloy> nested pattern-matches on Maybes usually have some better way to express the idea, i would think, but just one seems fine
13:26:14 <[exa]> ggVGc: if you use Maybe for expressing actual errors, case matching may be wrong. If Nothing is data for you, it's probably perfectly OK.
13:26:31 <ggVGc> yeah, that's a fair way of thinking about it
13:26:33 <ggVGc> thanks
13:27:06 * hackage postmark 0.2.3 - Library for postmarkapp.com HTTP Api  https://hackage.haskell.org/package/postmark-0.2.3 (MarkHibberd)
13:42:25 <monochrom> In https://wiki.haskell.org/Dynamic_programming_example I have a scenerio that benefits from using the Alternative-ness of Maybe.
13:43:42 <parsnip> okay, so back to this "build on one machine, deply to another"
13:44:14 <parsnip> i'm trying to run `stack build` in vagrant, and it just takes so long.
13:44:26 <parsnip> meanwhile, my OS is running very slow.
13:44:45 <parsnip> so, i get the sense haskell is for people with nice computers.
13:45:17 <parsnip> *deploy
13:45:33 <mud> parsnip: It's less painful if you have a bunch of RAM at least typically. Is it using swap perhaps? That'll really make things drag typically.
13:47:24 <monochrom> What is vagrant?
13:47:58 <mud> VM-ish thing I think?
13:48:24 <hpc> it controls your choice of VM-makey-thing
13:48:29 <hpc> usually virtualbox
13:48:40 <parsnip> makes vm easy to configure and ssh into.
13:49:00 <monochrom> I was on a 9-year-old laptop with 3GB RAM and it was OK. Swap did grow to 0.5GB but that's really more about Chrome than GHC.
13:49:20 <parsnip> running linux?
13:49:25 <monochrom> Yes.
13:49:38 <parsnip> linux being a second class citizen sort of doubles the issue.
13:49:51 <parsnip> i'm on a cheap mac.
13:50:12 <monochrom> And actually it started to get into swap just because I chose 64-bit. There was also a time I was on 32-bit and it didn't need swap.
13:51:21 <monochrom> I don't know man. I didn't use vagrant and everything was OK. So maybe it's vagrant that expects you to have a nice computer? Because mine was certainly not nice.
13:51:57 <hpc> what backend were you using?
13:52:09 <monochrom> Me? No backend.
13:52:14 <hpc> parsnip
13:52:25 <monochrom> Oh also I never used stack.
13:52:30 <parsnip> backend? virtualbox.
13:52:56 <hpc> how much ram did you give it?
13:53:02 <parsnip> 2 G
13:53:18 <hpc> hmm
13:53:19 <parsnip> i only have 4G total here
13:53:53 <parsnip> computer lags with that.
13:55:21 <hpc> maybe cpu is the bottleneck?
13:56:14 <monochrom> I also have a 2GB RAM mini PC. This one I only dare to run Ubuntu Server on it. But sometimes I still tell it to build Haskell code, and it is not bad, just not great.
13:56:32 <sm> @quote FAQ memory
13:56:32 <lambdabot> FAQ says: To build/link on low memory machines: use -j1, +RTS -M500m -RTS, and/or build fewer dependencies at once. Avoid swapping, it's too slow.
13:56:36 <hpc> i haven't ever had issues with cripplingly slow builds, so i don't know how to debug it
13:59:08 <hux> Rembane: Are you here ?
13:59:25 <parsnip> vb.customize ["modifyvm", :id, "--cpus", "2"]
13:59:32 <parsnip> vb.customize ["modifyvm", :id, "--memory", "2048"]
14:03:40 <Rembane> hux: Sure
14:04:05 <parsnip> stack: Most RTS options are disabled. Link with -rtsopts to enable them.
14:04:06 <hux> Rembane: can I show you the code i wrote and you tell me if it is how you explained earlier ?
14:04:33 <hux> Rembane: https://github.com/hussein-aitlahcen/freeinmonads/blob/master/src/Types.hs
14:04:57 <sm> parsnip: I think that needs to be passed to ghc using --ghc-options or something
14:05:09 <hux> Rembane: I feel it very verbose tho
14:05:36 <sm> but really, just manually build some of the bigger deps individually to move forward
14:05:58 <sm> making sure not to thrash swap
14:06:37 <Rembane> hux: I think that looks right. One of the drawbacks of free monads is the verbosity.
14:07:13 <hux> Rembane: Thanks again :)
14:08:31 <Rembane> hux: No worries. :)
14:12:15 <parsnip> swap on virtualbox, or swap on host?
14:13:41 <parsnip> build manually? should i not be using stack?
14:15:33 <MarcelineVQ> they probably mean do things idividually,  if your project has a bunch of depends and one is aeson you can   stack build aeson  in your project dir and it'l be made for that same resolver
14:15:35 <sm> parsnip: swapping on either is probably bad. Compare building on the native mac to see how much your vm is slowing things. Building with cabal instead of stack might save you a little, not sure
14:15:57 <MarcelineVQ> but they might mean that  :>
14:16:00 <parsnip> it's not nearly as slow on native mac.
14:16:27 <parsnip> nor does it freeze up entire os.
14:16:32 <sm> well, can you give your vm 3G instead of 2 ?
14:16:57 <parsnip> yep, but yeah, that means my os will get very slow i expect.
14:17:06 <hpc> if you take away the second vm cpu, does your os stay responsive?
14:17:15 <monochrom> I just built text-1.2.3.0 on my mini PC. It took 5 minutes but it seemed to just use 0.5GB.
14:17:44 <hpc> i vaguely remember virtualbox being awful at cpus > 1 sometimes
14:18:12 <sm> also have you tried my other tips ? If you keep memory usage below the swap threshold it just chug away in a reasonable time
14:18:19 <sm> it should just
14:19:21 <parsnip> i haven't figured out how to set rts yet.
14:19:34 <parsnip> stack: Most RTS options are disabled. Link with -rtsopts to enable them.
14:20:15 <sm> as I said, that needs to be passed to GHC. But never mind that one, how about building/linking fewer deps at once, or -j1
14:20:17 <parsnip> oh, you said --ghcopts, etc. this is all greek to me, takes a while to search for things, assuming i would ever find it.
14:20:46 <sm> oh it's not just you :)
14:21:52 <parsnip> trying 3 cpu and 3 G now
14:22:54 <parsnip> and just `stack build yesod`, i guess i'd have to look through yesod source to pick out dependencies.
14:23:02 <monochrom> It looks like you're suffering, not benefitting, from stack's abstraction.
14:23:36 * hackage composition-prelude 1.0.0.0 - Higher-order function combinators  https://hackage.haskell.org/package/composition-prelude-1.0.0.0 (vmchale)
14:23:50 <sm> parsnip: usually you can tell by watching top as it build various things
14:23:58 <parsnip> yeah, sttepping away from stack is entering my buuuuuuuuuuuuuuuucket list.
14:24:55 <monochrom> I think -j1 is a good idea. Parallel build means running multiple GHC instances means eating memory.
14:25:14 <monochrom> And with -j1 you now actually want to give fewer cores to virtualbox.
14:25:57 <monochrom> GHC does not assume you have a nice computer. But -j4 does.
14:26:18 <parsnip> k will try, computer frozen
14:26:39 <monochrom> And people demanded -j because they have 20 cores 80 hyperthreads and 100GB phyiscal RAM
14:26:57 <monochrom> and 1TB SSD
14:27:37 <c_wraith> wait, a 1TB SSD is actually affordable these days. :P
14:27:44 <sm> dang, my haskell hacking would go faster on a machine like that
14:27:58 <monochrom> I wonder when will people go on to demand also a -J which means distributing work over a Beowulf cluster.
14:28:01 <sm> well actually, would it. Maybe
14:28:59 <monochrom> Naw, why would a faster builder make you think faster?
14:29:29 <monochrom> Instead, a faster builder means fewer rolling-chair sword games ala xkcd 303
14:29:41 <hpc> monochrom: maybe sm uses emacs
14:30:02 <monochrom> Oh heheh
14:30:14 <c_wraith> that might be enough of a computer to run emacs.  maybe.
14:30:18 <monochrom> (But I used emacs on my mini PC too)
14:30:38 <sm> I do spend a lot of time waiting for builds
14:31:01 <sm> or trying to multitasking, which makes me inefficient
14:31:11 <parsnip> computer completely frozen for 5 minutes now
14:31:19 <parsnip> guess time to reboot
14:31:26 <sm> parsnip: ok, I think you gave it too much ram :)
14:31:32 <monochrom> Hrm I guess separate compilation has failed its promise of faster build, just like OO has failed its promise of separating concerns.
14:31:37 <parsnip> or cpu?
14:31:55 <monochrom> Because basically every pull request is going to touch every file and every class.
14:32:06 * hackage hlint 2.0.14 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.0.14 (NeilMitchell)
14:32:36 <hpc> monochrom: don't worry, i hear microservices will solve all our development problems
14:32:56 <sm> parsnip: course, after a reboot it'll probably work for a while
14:33:48 <monochrom> frozen is usually going into swap rather than cpu too busy.
14:34:07 <monochrom> Because OSes are great at time slicing even when cpu is too busy.
14:34:38 <monochrom> But swap holds up everyone and is basically a big global lock
14:38:34 <hololeap> parsnip: if it's linux, you can do Alt+SysRq+F and it will force the OOM-killer to run ... it should kill the process and unfreeze the computer pretty quickly
14:38:44 <monochrom> Perhaps you need to apply WD40 to your CPU fan :)
14:39:43 <MarcelineVQ> monochrom: don't you try this for fun some day, wd40 isn't a lubricant :<
14:39:48 <parsnip> dialed virtualbox back to 2 CPU, 2G or ram, `stack build -j1 Cabal` is pretty slow.
14:39:52 <sqooq> hi
14:39:57 <monochrom> Oh oops.
14:40:18 <MarcelineVQ> ah Cabal is no slouch on ram usage, I'm building it right now and just one component was using 1.7gb to build
14:40:26 <hololeap> 3 in 1 bike oil though...
14:40:40 <monochrom> But you wouldn't build Cabal.
14:41:06 <MarcelineVQ> oop, *cabal-install
14:41:18 <parsnip> "Cabal-2.0.1.1: build"
14:41:20 <ggVGc> is there any non-lens way of mapping only Left values of Either, without pattern matching in the mapped function?
14:41:35 <mud> MarcelineVQ: Most of it is GHC, regardless of what build tool you're using last time I checked.
14:41:46 <monochrom> Consider Bifunctor.
14:42:03 <MarcelineVQ> no I mean I'm builing cabal-install and it's quite hefty
14:42:07 <hololeap> :t isLeft
14:42:08 <lambdabot> Either a b -> Bool
14:42:28 <ggVGc> hololeap: how does that help me?
14:42:51 <ggVGc> yeah, bifunctor seems like what I want
14:42:52 <ggVGc> thanks
14:43:47 <monochrom> Hrm, would you find "mirror :: Either a b -> Either b a" useful? :)
14:44:05 <mud> MarcelineVQ: Ah, yes
14:47:08 <glguy> :t review swapped :: Either a b -> Either b a
14:47:10 <lambdabot> Either a b -> Either b a
14:47:28 <MarcelineVQ> :t \f -> either (Left . f) Right
14:47:30 <lambdabot> (a1 -> a2) -> Either a1 b -> Either a2 b
14:47:32 <monochrom> The fairest of them all.
14:51:06 * hackage composition-prelude 1.1.0.0 - Higher-order function combinators  https://hackage.haskell.org/package/composition-prelude-1.1.0.0 (vmchale)
14:53:55 <sqooq>  some functions take an Ordering argument, which comes from Data.Ord, there are 3 constructors LT,EQ,GT, but no explanation on what they are. How do I know which to use?
14:54:19 <c_wraith> Less Than, Equal, Greater Than
14:54:25 <sqooq> o
14:54:27 <sqooq> kek
14:54:47 <sqooq> I wonder what's the purpose of that argument in this function
14:54:52 <hololeap> :t compare
14:54:54 <lambdabot> Ord a => a -> a -> Ordering
14:54:57 <sqooq> I still wouldn't know which to choose
14:55:17 <sqooq> Ok well i'll figure it out, thanks
14:55:26 <hpc> what function?
14:55:58 <sqooq> https://hackage.haskell.org/package/alsa-pcm-0.6.0.4/docs/Sound-ALSA-PCM-Parameters-Hardware.html#t:T
14:56:00 <sqooq> many from here
14:57:36 * hackage madlang 4.0.0.1 - Randomized templating language DSL  https://hackage.haskell.org/package/madlang-4.0.0.1 (vmchale)
14:57:40 <glguy> Oh no, one of *those* packages: You are in a maze of tisty little types, all alike.
14:57:46 <glguy> twisty*
14:58:09 <sqooq> *those* packages? more like *all* packages
14:58:27 <c_wraith> most packages use meaningful types.
14:58:30 <sqooq> I haven't successfully used a library that was anything more than a new datatype in aes
14:58:31 <c_wraith> That one does not
14:58:37 <sqooq> ages*
14:58:39 <glguy> sqooq: No, most package do not name lot of things the same name
14:58:58 <sqooq> It just sucks because this is a pretty important library
14:59:39 <MarcelineVQ> why must he do this ;_;
15:00:12 <monochrom> He brings SML culture to this.
15:00:39 <monochrom> Nothing wrong with SML culture if the language is actually SML.
15:00:52 <monochrom> Or at least the module system is.
15:01:06 <hpc> it looks like in C, that ordering parameter corresponds to "direction"
15:01:14 <sqooq> :thinking:
15:01:21 <hpc> https://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m___h_w___params.html#gaa22d4f917c300b0c1f47b348c23705a4
15:01:21 <sqooq> the worst part is this hardly lines up with the C api
15:01:39 <hpc> compared to setPeriodTimeNear :: Time -> Ordering -> T i y (Time, Ordering)
15:01:49 <sqooq> true
15:02:01 <monochrom> If your language doesn't have "local  open MyModule ...." then there is no point using SML conventions.
15:02:15 <sqooq> I've always seen it in the C api usage as "0"
15:02:20 <sqooq> so I guess that's EQ?
15:02:38 <hpc> probably
15:03:13 <sqooq> ok. I'll just use that and hope for the best. I think I may have painfully analyzed and analyzed and analyzed this thing until now I think I can actually use it
15:03:24 <sqooq> BUT, how do I get my data in Ptr Storable form or whatever
15:04:37 <sqooq> Also what the hell is that "T" datatype
15:05:32 <c_wraith> T is a sign you're using a library by Henning Thielman
15:05:47 <hpc> https://hackage.haskell.org/package/alsa-pcm-0.6.0.4/docs/Sound-ALSA-PCM-Node-ALSA.html
15:06:06 <hpc> this library is painful
15:06:11 <sqooq> exactly
15:06:18 <sqooq> Ok so I'm glad I'm not crazy
15:06:29 <sqooq> maybe there's another alsa library out there
15:06:38 <hpc> even putting aside how it's structured and how T is named
15:06:49 <hpc> the module you linked reads like a lazy FFI job
15:07:01 <sqooq> what I don't understand is his first version stuck close to the C api, so I could just use those docs, but it's deprecated and won't build
15:07:14 <hpc> where someone went "this C function takes an int that can take 3 values, what has 3 constructors, oh let's use Ordering"
15:07:19 <sqooq> this one http://hackage.haskell.org/package/alsa
15:07:49 <sqooq> hpc, ye but you showed it did have to do with direction
15:08:00 <sqooq> "target/chosen exact value is <,=,> val following dir (-1,0,1) "
15:08:04 <hpc> yeah
15:08:06 * hackage ats-format 0.1.1.0 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.1.0 (vmchale)
15:08:10 <sqooq> so it sort of makes sense
15:08:21 <c_wraith> It would make way more sense to use a semantically meaningful data type
15:08:22 <hpc> a properly written FFI-using package will not require you to read docs for the underlying C
15:08:51 <sqooq> c_wraith, agreed
15:09:04 <c_wraith> Seriously, using Ordering saves like 3 lines of code.  It makes no sense.
15:09:08 <sqooq> hmm maybe someone else has an alsa library that's not bad
15:09:30 <sqooq> or like maybe I don't have to use alsa for realtime sound?
15:09:31 <hpc> c_wraith: can you find every language designer ever and tattoo that on their foreheads?
15:09:45 <c_wraith> language or library?
15:09:48 <hpc> both
15:09:53 <hpc> now that you mention it
15:10:00 <c_wraith> that's way harder
15:10:59 <sqooq> kek there are no other alsa libraries available, at least not on hackage
15:11:00 <sqooq> rip me
15:12:08 <MarcelineVQ> what's your lib for? you making hymmnos from scratch?
15:13:27 <sqooq> The goal was an intuitive and flexible/powerful audio processing/synthesizing library
15:13:57 <sqooq> Partially to realize a composition idea I've had but has been a pain to program in audio languages because they're just too limited
15:14:52 <parsnip> where does the 2G issue come in? is that from stack, or would it exist still if i learned to install with cabal?
15:15:03 <parsnip> *2G RAM
15:16:46 <sqooq> tbh there's common lisp music which sort of seems like it's what I want to accomplish with haskell, offering the full flexibility of lisp (as I would have with haskell) but providing all the useful primitives in a good way
15:16:50 <sqooq> ...but it's lisp haha
15:24:07 * hackage ratel 0.3.10, strive 5.0.1 (fozworth): https://qbin.io/wtsevz6
15:27:38 <ggVGc> monochrom: sorry, got stuck in my code. will check what you suggested. This is what I want to do, https://gist.github.com/c7e6344ccedb93f04bdd01a3d5d6518a
15:27:47 <ggVGc> without the explicit match
15:28:10 <ggVGc> is that bifunctor?
15:42:34 <mud> Yes, that's just map (first fillMaker)
15:42:37 <hololeap> ggVGc: `wrapFills = map (first fillMaker)` should do it using Data.Bifunctor
15:43:31 <mud> Which is almost too small to even need to have a name, depending on how it's being used and etc.
15:43:44 <Welkin> hololeap: where does your name come from?
15:44:25 <hololeap> Welkin: a book i read a decade ago that i was really into, Holographic Universe
15:44:34 <Welkin> mud: you play text-based rpgs? :P
15:44:58 <Welkin> multi user dungeon
15:45:26 <Welkin> there is one built into emacs that I play sometimes
15:45:42 <Welkin> I always eat the shovel, which results in instant death
15:53:55 <sm> parsnip: to learn about what takes up ram when building haskell things, I recommend watching top
15:55:08 <sm> it's certain packages, ghc, also the linker, and building multiple packages concurrently (as stack and cabal-install do by default)
15:58:08 <parsnip> hmm, okay thanks, will keep in mind to troubleshoot.
15:59:27 <sm> and ghc 8 tends to need more ram than ghc 7
16:02:23 <ggVGc> haskell is the best text based rpg I have
16:04:06 <sqooq> !!!!
16:04:09 <sqooq> look what I found
16:04:11 <sqooq> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.652.5985&rep=rep1&type=pdf
16:11:50 <mniip> hold on a second
16:11:57 <mniip> chronicle is the ultimate fizzbuzz monad
16:15:40 <mniip> condemn $ when (i `mod` 3 == 0) (dictate "Fizz") >> when (i `mod` 5 == 0) (dictate "Buzz"); return (show i)
16:27:24 <sqooq> euterpea is low level!!!
16:27:27 <sqooq> fml
16:28:53 <Adluc> mniip: the chronicle thing in Data.Control.Chronicle looks really cool
16:29:15 <Adluc> so recent its not yet mentioned on any blog
16:31:23 <Lokathor> intero can't find any modules at all
16:31:35 <Lokathor> Anything Haskell related really never wants to work on win32 :(
16:33:52 <carter> how'd all
16:33:55 <carter> it's been a while
16:35:16 <Lokathor> carter, i'm less fine than i told you i was about 10 minutes ago :P
16:35:35 <carter> Lokathor:  i just use sublime haskell via sublime text
16:35:37 <carter> and enjoy live
16:35:49 <carter> *enjoy life
16:35:56 <carter> the maintainer is super nice and responsive
16:36:05 <carter> granted i think i'm the only user who files bug reports
16:36:17 <carter> 'cause i've got exotic prefs that catch all the bugs :)
16:36:29 <Lokathor> 80 bucks is steep though
16:36:46 <carter> try it free
16:37:02 <carter> only difference is it says you should get a license every once ina while
16:37:02 <Sose> there are some decent plugins for vscode too
16:37:03 <hpc> @quote cost.me
16:37:03 <lambdabot> SimonMarlow says: This is the largest program (in terms of memory requirements) I've ever seen anyone run using GHC.  In fact there was no machine in our building capable of running it, I had to
16:37:03 <lambdabot> fire up the largest Amazon EC2 instance available (68GB) to debug it - this bug cost me $26.
16:37:23 <carter> hpc:  hehe, 26 dollar bugs === cheap bug!
16:37:33 <Lokathor> Sose yes they're broken because they all rely on intero
16:37:36 <Lokathor> and intero is broken for me
16:37:43 <carter> what relies on inero?
16:37:46 <Lokathor> it can't even find control.monad
16:37:49 <Sose> Lokathor: weird
16:38:00 <Sose> carter: the vscode haskell plugins do
16:38:01 <carter> granted, i also disable all the smart plugins
16:38:03 <Lokathor> carter, like, every major haskell plugin for vs code is backed by intero
16:38:04 <Sose> haskero and haskelly
16:38:06 <carter> oh
16:38:11 <carter> you'll like sublime haskell
16:38:12 <carter> tis good
16:38:20 <carter> has 2-3 different backends
16:38:51 <carter> plus a "read build output and let you click on type error location thing"
16:38:51 <Lokathor> hmm
16:38:56 <carter> also has cabal-newbuild support
16:39:05 <carter> (because i asked nicely / helped sketch it out)
16:39:16 <carter>  slash / i'd be hand patching it to do newbuild by hand every release for a hwile
16:40:04 <carter> https://gist.github.com/cartazio/1abc5d5a85060fd71d33e60eb198a293 is the config i have sublime haskell
16:40:12 <Sose> sublimehaskell looks pretty nice from the github page. probably a bit more advanced than the vscode plugins
16:40:28 <carter> Sose:  i have a very simple style
16:40:32 <carter> :)
16:40:41 <carter> i just want cabal new build to run on file saves
16:40:43 <carter> and to get type errors
16:40:50 <carter> and coverage warnings
16:41:18 <sssilver> hey guys, I have learned Haskell the past year, and write a lot of my own programs in Haskell now, and I get it, and it's great
16:41:21 <sssilver> but now I have this problem
16:41:41 <sssilver> where whenever I code in any other language, it just feels like shit, and I feel like my programs are not elegant at all, and I'm just doing crap work
16:41:50 <Lokathor> oh gosh i have to go install cabal too
16:41:53 <sssilver> do you guys ever experience this, and how do you cope with it?
16:41:58 <Lokathor> no thanks
16:42:04 <carter> Lokathor:  ?
16:42:15 <carter> where?
16:42:20 <EvanR> sssilver: standard haskell withdrawl syndrome
16:42:22 <Lokathor> for the sublime haskell plugin
16:42:33 <sqooq> sssilver, hahahah yes
16:42:33 <carter> Lokathor:  if you want to use cabalized stuff.. yeah
16:42:36 <Lokathor> sssilver, Rust isn't so bad
16:42:45 <Lokathor> carter, it lists cabal as a basic requirement for the plugin
16:42:45 <carter> write a compiler
16:42:49 <carter> Lokathor:  nope
16:42:52 <carter> just for builds
16:43:01 <sqooq> sssilver, I learned haskell first and rage quit it a few times only to come crawling back
16:43:02 <carter> Lokathor:  you have cabal the binary somewhere
16:43:06 <hpc> sssilver: after a while you learn to write haskell in other languages
16:43:06 <sssilver> Lokathor: I agree that Rust is the best among the inferior ones
16:43:07 <sqooq> sssilver, rust is bad
16:43:08 <carter> or you dont have haskell installed
16:43:16 <carter> no monads :)
16:43:20 <hpc> sssilver: in much the same way as if you've ever seen someone write C in java or something like that
16:43:28 <carter> Lokathor:  you just need cabal the binary
16:43:32 <carter> and then happy times
16:43:35 <sqooq> hpc, it's not the same though
16:43:37 <hpc> i like rust
16:43:50 <hpc> it's the future of C, imo
16:43:52 <carter> you can write haskell or white space in any language
16:44:00 <sqooq> hpc, it seemed so much harder though?
16:44:22 <hpc> it wasn't any harder than learning haskell for me
16:44:40 <hpc> you just have to totally change the way you think about what a program is
16:44:51 <hpc> "just" ;)
16:44:55 <sssilver> rust is harder to learn than haskell imo, a lot harder
16:45:02 <sssilver> the whole lifetimes thing I still dont completely get
16:45:03 <sqooq> yeah I learned haskell fine
16:45:04 <Sose> huh, what's so weird about rust?
16:45:14 <sssilver> everything's great when everything works
16:45:16 <sqooq> (i hope haha)
16:45:26 <sssilver> but then at some point of complexity the compiler goes "something something doesn't live long enough"
16:45:30 <sssilver> and you go "well, fuck"
16:45:32 <hpc> if you have a good grasp of memory management and don't mind adapting your coding style to the language, it's really easy to use
16:45:54 <sssilver> hpc: I'd say I am pretty adept with C++, yet I struggle with the type system when it comes to lifetimes in Rust
16:46:11 <sssilver> maybe I just haven't done enough of it
16:46:14 <hpc> the trick to tricky lifetime problems is to get your data structures right
16:47:20 <hpc> assuming you aren't using a library that does something tricky with lifetimes
16:48:14 <hpc> i was fiddling with sdl in rust and at one point had to refactor my texture loading code because of how textures are tied to the lifetime of a controller object
16:48:27 <sssilver> hpc: I had a good real life example for when things got hairy, perhaps it's worth to dig it and discuss with you because I'm genuinely curious
16:48:30 <hpc> but the code ended up better afterwards
16:49:02 <Lokathor> sssilver, lifetimes are easy to manage if your program doesn't track them. just always use raw pointers
16:49:24 <hpc> that's good advice
16:49:32 <sssilver> Lokathor: err
16:49:35 <hpc> one thing i learned early on is the more "lexical" your code is, the better
16:49:38 <hpc> as well
16:49:38 <sssilver> Lokathor: that defeats the whole purpose of the type system
16:49:39 <Lokathor> ;;;;D
16:49:48 <hpc> oh, /raw/ pointers
16:49:57 <sssilver> Lokathor: it's like saying "in your c program just pass everything as void* and cast it to whatever you need it to be"
16:49:57 <hpc> i thought you meant regular pointers vs Box
16:50:00 <EvanR> make all lifetimes infinite!
16:50:15 <sssilver> EvanR: that also doesn't work, there's a reason they are there
16:50:25 <Lokathor> the advantages of rust are (1) it mostly works on windows (unlike haskell) and (2) it has a cool build/package system that can help you out (unlike C/++)
16:50:25 <sssilver> come on guys
16:51:04 <sqooq> i just gave up learning rust because it seemed so ridiculously dense
16:51:22 <Lokathor> sssilver, as someone who's converted a 3k line C++ program into rust by hand, i can assure you that it's plenty fine to use raw pointers :3
16:51:29 <sssilver> sqooq: honestly if you can do haskell, you can do rust (minus the lifetimes bit)
16:51:50 <sssilver> Lokathor: it's one of those things that is fine until it isn't, and then it sucks
16:52:11 <Lokathor> just dont' ever de-allocate anything
16:52:11 <sqooq> sssilver, is it worth it though?
16:52:45 <hpc> one thing i saw some potential with, is a safe rust/haskell FFI
16:52:57 <Lokathor> yeah you could use inline-c
16:53:15 <hpc> do something on the haskell side to encode rust's fanciness
16:53:32 <hpc> and then give ghc an awareness of the types of rust definitions
16:53:49 <hpc> and you don't have to give type signatures for foreign imports/exports, they are automatically translated
16:53:58 <Lokathor> that sounds way too complicated
16:54:03 <hpc> probably
16:54:07 <EvanR> haha
16:54:08 <hpc> but it'd be pretty damn cool
16:54:08 <carter> sssilver: I do think rust doesn’t do linear logic.  Just really really affine regions of lifetime
16:54:29 <Lokathor> the reason to call rust from haskell would be that it's doing whatever operation way faster than haskell can go
16:54:35 <carter> I’d rather just have a linear logic type theory
16:54:51 <carter> That also doubled as a systems Lang :)
16:55:05 <EvanR> they are supposedly adding linear dependent types to idris
16:55:13 <EvanR> to replace uniqueness
16:55:43 <carter> EvanR: it looked like it’s based on atkeys QTT. It’s not quite what you want
16:55:57 <carter> But it is not a bad approach
16:56:12 <sssilver> sqooq: it's worth it if you're into high performance systems programming like idk drivers or video games pushing a billion vertices 60 times a second
16:56:14 <carter> There’s some approaches that better internalize fancy stuff
16:56:52 <sssilver> another reason to use rust from haskell is there are algorithmsh that are inherently imperative, and Haskell sucks when implementing those
16:56:59 <sssilver> *algorithms
16:57:07 <sssilver> let me think of some
16:57:08 <hpc> sssilver / sqooq: btw, besides rust another language that i think compares favorably to haskell is puppet
16:57:40 <hpc> if you're ever in the mood for a very different kind of programming
16:58:36 * hackage fast-arithmetic 0.3.0.2 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.3.0.2 (vmchale)
16:59:07 <sssilver> Floyd-Warshall algorithm -- pretty hard to implement in Haskell, pretty easy to implement in Rust
16:59:21 <sssilver> https://en.m.wikipedia.org/wiki/Floyd–Warshall_algorithm#Algorithm
17:00:41 <parsnip> can't one use state and vectors to do algorithms in haskell?
17:00:52 <parsnip> er, imperative algorithms.
17:01:33 <Welkin> you can write C in haskell, yes
17:01:47 <Welkin> using safe mutations (or unsafe, if you prefer)
17:03:02 <hpc> you could write it with ST, sure
17:03:09 <sqooq> parsnip, you may not need to
17:03:31 <parsnip> sqooq: assuming you can translate imperative flow to functional?
17:03:40 <sqooq> ye
17:03:58 <sqooq> I mean idk what you're trying to implement
17:04:07 <sqooq> but more things than you may think can be done purely
17:04:19 <sqooq> or mostly purely with just a final sprinkle of io
17:04:33 <sqooq> but I'm also a noob so don't listen to me
17:04:34 <parsnip> i had several reasons from stepping away from haskell about a year ago, wanting to learn algorithms in an imperative language was one of them.
17:04:55 <parsnip> i hit a bunch of learning curves all at once.
17:05:46 <sqooq> hmm. i'm not sure I understand
17:06:10 <sqooq> what's so great about imperative algorithms?
17:06:17 <parsnip> i was trying to learn programming, with haskell, and projecteuler was my main set of exercises.
17:06:23 <Welkin> they are very low level
17:06:35 <Welkin> a direct translation of what the computer is doing
17:06:37 <hpc> it's important to have variety
17:06:39 <Welkin> easy to write in assembly
17:06:53 <Welkin> but that also means they are error-prone
17:07:08 <hpc> getting your brain stuck in one language or programming style is bad, no matter how good that might be on its own
17:07:11 <parsnip> was having trouble getting further without knowing anything about algorithms... a few more reasons, more and less related.
17:07:16 <Welkin> quicksort is only fast because it modifies memory in place
17:07:36 <sqooq> I agree with hpc as much as I love haskell. Learning other languages really made me feel more confident in programming in general and more well rounded.
17:07:38 <Welkin> parsnip: so you learned haskell before leanring any other language?
17:08:02 <Welkin> most people start with something like C or java
17:08:09 <Welkin> I started with c and assembly
17:08:10 <parsnip> yes, i had tried a few languages, no more than a week, then i just kind of focused on haskell for about half a year.
17:08:10 <sqooq> I started with haskell
17:08:21 <sqooq> for about half a year now
17:08:24 <sqooq> lol
17:08:30 <hpc> parsnip: so your imperative experiment was also learning your second programming language?
17:08:32 <Welkin> haskell and C and assembly are all you need to have good coverage of programming
17:08:41 <parsnip> once i hit all the learning curves, i basically switched to python for a while.
17:08:48 <sqooq> Welkin, and lisp
17:08:50 <parsnip> hpc: yes?
17:08:54 <Welkin> lisp is not needed
17:09:02 <sqooq> o you said programming
17:09:14 <sqooq> I mean programming language generally so to speak
17:09:15 <hpc> the second language is always hard
17:09:39 <carter> I think monad-ste doesn’t get as much use as it should. Granted st and prim monad don’t either :)
17:09:41 <parsnip> i keep wanting to learn lisp or scheme, but i haven't really gravitated to them much yet.
17:10:27 <jackdk> I love the editing experience of s-expy languages (especially in emacs), but I need my types too much to jump to a lisp
17:10:48 <hpc> if you want the full lisp experience, i suggest common lisp
17:10:57 <hpc> it's... a cacophany of language features
17:11:27 <hpc> but sets you up nicely for knowing how to deal with it when code in other languages tries to get too fancy
17:12:02 <hpc> and it's a good test of functional programming skill in an environment where you don't have ghc to give you hints
17:12:18 <parsnip> why not scheme then
17:12:29 <parsnip> scheme is closer to haskell
17:12:38 <hpc> scheme isn't chaotic enough ;)
17:12:54 <Welkin> parsnip: I would look at racket if you want to get into lisp
17:13:14 <parsnip> yep, or chicken, or whatever, one of them.
17:13:14 <Welkin> lisp is a family of languages, I'd avoid the lisp-1 languages (including clojure)
17:13:25 <Welkin> er
17:13:29 <Welkin> lisp-2*
17:13:41 <Welkin> stick with the scheme derivatives
17:14:45 <parsnip> https://en.wikipedia.org/wiki/Lisp-1_vs._Lisp-2 redirects :(
17:15:02 <Welkin> lol
17:15:15 <parsnip> "Scheme's evaluation model is simpler ..."
17:16:23 <sqooq> lisp seems nice but super ugly
17:16:30 <sqooq> and I don't like the dynamic types
17:16:37 <hpc> does the number refer to how many namespaces the language has?
17:16:43 <Welkin> it is very annoying
17:16:45 <hpc> because i always had an issue with macros more than functions
17:16:47 <Welkin> and the lack of types sucks
17:16:53 <Welkin> hpc: yes
17:16:58 <hpc> really they're lisp-2 and lisp-3
17:17:24 <hpc> unless you say macros aren't part of the lisp language in which case i have an AI professor to introduce you to
17:17:44 <sqooq> macros is what made me attracted to the language
17:17:50 <sqooq> I haven't actually done anything in lisp though
17:17:55 <sqooq> just sort of made myself aware of it
17:22:09 <sqooq> racket looks nice, there's even typed racket
17:23:06 * hackage fast-arithmetic 0.3.0.3 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.3.0.3 (vmchale)
17:26:50 <sqooq> how does this work
17:26:53 <sqooq> ?
17:26:54 <sqooq> http://lpaste.net/361650
17:31:25 <parsnip> sqooq: it doesn't
17:31:34 <sqooq> :thinking:
17:31:53 <sqooq> it definitely does I can run it and it produces the right result
17:32:40 <parsnip> sqooq: can you run it from a fresh ghci?
17:32:54 <sqooq> yes...I guess
17:32:58 <parsnip> sqooq: maybe you aren't sharing all the code? dt is not defined.
17:33:04 <sqooq> o yeah dt is a time step
17:33:08 <sqooq> just let dt = 1/44100
17:33:22 <sqooq> or replace dt with 1/44100 in the code
17:34:18 <sqooq> sine signal is easily understood as sin(t*2pi*freq) for progressive t's. But this somehow progresses t in this weird fashion using cosine and that zipWith.
17:34:21 <sqooq> Idk what's going on
17:36:49 <Wizek> Would any one of you know if it is possible to ship a repl/interpreter with a built binary that would have access to some local bindings, be able to transform them with a haskell expression (specified as string at runtime), and be able to return a value that could be used by the main app?
17:36:59 <Wizek> I know of the hint package
17:37:21 <geekosaur> Wizek, it's in general hard to do that with a compiled application
17:38:36 * hackage uniquely-represented-sets 0.1.0.0 -   https://hackage.haskell.org/package/uniquely-represented-sets-0.1.0.0 (oisdk)
17:38:42 <dmwit> dyre might be relevant.
17:38:58 <geekosaur> even in C, you can't in general make your local variables visible to an interpreter without some specific way to bind them into it. (And you may then have to mark them volatile, or the C compiler may assume they can't be changed by the interpreter and generate optimizations that overwrite the interpreter's actions)
17:39:14 <geekosaur> in Haskell, this would end up being STM presumably
17:39:45 <Wizek> dmwit: looking into dyre, thanks for the pointer
17:40:30 <geekosaur> sqooq, looks to me like it's doing integration. you are aware of the cyclic nature of integrals/derivatives of trig functions?
17:41:08 <sqooq> I guess not
17:41:12 <geekosaur> or possibly derivatives instead of integrals. sais cyclic nature makes it hard for me to tell at a quick glance (esp. since I am currently a bit medicated. kidney stone.)
17:41:21 <sqooq> ouch
17:41:57 <geekosaur> https://en.wikipedia.org/wiki/Differentiation_of_trigonometric_functions
17:42:10 <geekosaur> the first one is relevant
17:42:34 <sqooq> well yes, if that's what you mean
17:42:38 <geekosaur> (if you think about it, this is actually pretty obvious: it's almost the *definition* of a circle)
17:42:40 <sqooq> but how does that relate to this code?
17:42:48 <geekosaur> your comment about using cos
17:42:56 <hololeap> i think that it's creating a stream of data points that correspond to a sine wave
17:43:18 <sqooq> well yes that's what it's doing but how
17:43:25 <geekosaur> yes, and it's doing so by using the derivative (and the derivative of sin is cos) iteratively to find the next point
17:43:42 <sqooq> and is this any better than what I've been doing which is "fmap (\t -> sin(t*dt*freq*2*pi) [0..]
17:43:46 <sqooq> "
17:43:48 <geekosaur> if I am reading it correctly.. which, as I said, I might not be
17:44:00 <geekosaur> it'd be faster, if nothing else
17:44:09 <sqooq> would that really be faster?
17:44:14 <sqooq> that's probably why, if that's the case
17:44:18 <sehqlr> hello all
17:44:26 <sqooq> this is from a paper on efficient audio synthesis in haskell
17:44:31 <geekosaur> right
17:44:54 <geekosaur> it's using clever math to reduce the number of computations
17:46:21 <sqooq> the first results if I did it correctly are r = [2*sin omh*cos omh,2sincos-cos,(2sincos-sin)-2sincos,...]
17:46:40 <sqooq> I still don't understand the math here
17:46:44 <sqooq> i've never seen this elsewhere
17:51:03 <Lokathor> so stack is forcing ghc to color the diagnostics despite me putting the opposite command in my cabal file
17:53:13 <sqooq> geekosaur, it's called Goertzel’s algorithm
17:53:20 <sqooq> apparently a specific application of it
17:53:26 <sqooq> and yeah it's just faster
17:53:32 <sqooq> neat
18:04:11 <hololeap> sqooq: it's the inverse of that algorithm
18:04:36 * hackage cli-setup 0.1.0.0 - Helper setup scripts for packaging command-line tools.  https://hackage.haskell.org/package/cli-setup-0.1.0.0 (vmchale)
18:04:49 <Lokathor> https://stackoverflow.com/questions/48256095/how-do-i-make-stack-not-pass-fdiagnostics-color-always-to-ghc
18:05:03 <Average-user> Hi guys, I'm a little sad because lpaste.net doesn't support highlighting for Clojure. And they have issues disabled on their repo.
18:06:50 <parsnip> what is `docker: enable: true` doing for my in stack.yaml? i still had to go through 122 items.
18:06:51 <sqooq> man I've been trying to figure out how to represent some data I'm working with, and whenever I think i've gotten it, I realize there are problems.
18:06:57 <parsnip> *for me
18:07:25 <hololeap> sqooq: i think i found that paper you're talking about. i'm also interested in using haskell to do sound synthesis and DSP
18:07:41 <sqooq> hololeap, it's a pretty good paper
18:07:51 <hololeap> this one? http://haskell.cs.yale.edu/wp-content/uploads/2011/01/AudioProc-TR.pdf
18:08:01 <sqooq> yes
18:08:11 <sqooq> you know they used the concepts in a library: Euterpea
18:08:36 <sqooq> It seems pretty solid, except that it uses arrows
18:09:30 <hololeap> oh, yeah, i saw a talk about all that done by Paul Hudak, but he passed away and i thought the project never continued
18:09:40 <sqooq> Back to what I was talking about. I have a connected paths but they can branch off, and the annoying part is they can loop. Their length does not matter, or in otherwords they do not have length.
18:10:00 <sqooq> hololeap, It's been maintained mainly by a single person according to the faq on the website
18:10:18 <sqooq> Donya Quick.
18:12:36 <hololeap> sqook, i'm a little confused about the data structure you're trying to implement... can you give an example?
18:13:55 <sqooq> so I have for example `a -- b -- c`. I would then like to traverse a path, but that comes from basically utilizing the data structure, but it gives some insights on why a simple list of connections won't work. For that example a legal path might be `a -> b -> c -> b`. So I think I didn't mention but when traversing you can go in either direction
18:14:09 <sqooq> another path might be `a -> b -> a -> b -> a -> b -> c`
18:15:23 <hololeap> what rules are there? can you jump from a to c?
18:15:27 <sqooq> But how do loops work, because they have an associated direction that in this sort of pseudo-notation does not appear. for example, `a -- a`.
18:15:37 <sqooq> hololeap, no
18:16:44 <hololeap> it almost sounds like a zipper would work, but i'm trying to learn how to use them myself
18:19:08 <dmwit> If the object at both ends of a loop is the same, in what sense is the loop directed?
18:19:43 <sqooq> dmwit, well this is actually a drawing of a graph. So there is clockwise and countercw
18:19:58 <Lokathor> Could not find module `Prelude'
18:20:04 <Lokathor> seems like a bad error message to get
18:21:05 <dmwit> sqooq: What is the difference between a clockwise loop and a counterclockwise loop? Can you have one of each?
18:21:20 <sqooq> the same loop can be traversed clockwise or counterclockwise
18:21:26 <hololeap> i'm still a bit confused as to what you're trying to do, but maybe the fgl library would have some helpful data structures/functions
18:21:45 <dmwit> sqooq: Then that is a property of the traversal, not the data structure.
18:22:06 <sqooq> but how would it know what is clockwise or counterclockwise if all it sees is a,a?
18:22:06 * hackage transformers-either 0.0.2 - An Either monad transformer  https://hackage.haskell.org/package/transformers-either-0.0.2 (lambda_foo)
18:22:18 <dmwit> sqooq: Don't tell it just a,a, obviously.
18:22:25 <sqooq> :thinking:
18:22:30 <sqooq> hmm I guess that makes sense
18:22:48 <dmwit> data Edge = ClockwiseLoop | CounterclockwiseLoop | Neighbor Node -- e.g.
18:23:10 <sqooq> Since eventually I want this to just be a random traversal, I could just have it decide which direction
18:23:17 <sqooq> separate from the data structure
18:26:14 <hololeap> data Direction = CW | CCW; type MyEdge = LEdge Direction    (LEdge is from Data.Graph.Inductive.Graph in fgl)
18:27:03 <xuemo> so
18:29:06 * hackage amazonka-s3-streaming 0.2.0.4 - Provides conduits to upload data to S3 using the Multipart API  https://hackage.haskell.org/package/amazonka-s3-streaming-0.2.0.4 (AlexMason)
18:29:55 <eacameron> Can anyone offer tips for figuring out why GHC might just hang and slowly run out of memory on my mobule?
18:30:18 <eacameron> *module
18:30:40 <eacameron> I'm imaging some sort of verbose compiler output where I can figure out where it's getting stuck
18:41:30 <Lokathor> so, tryReadTQueue :: TQueue a -> STM (Maybe a), and i want TQueue a -> IO [a]
18:41:47 <Lokathor> is there a magic combinator that repeats the (Maybe a) part until Nothing?
18:46:22 <eacameron> So putting -O0 in the troublesome module gets around the GHC bug
18:46:36 <eacameron> Now I wish I could figure out what code was troublesome and tweak it.
18:50:19 <mud> eacameron: Aren't there flags for every particular optimization instead of the -O1 -O2 etc. ones? Might start there, if you can narrow down what optimization is screwing something up. If it's that simple anyway.
18:50:34 <Gurkenglas> Lokathor, the (TQueue a -> STM (Maybe a)) -> (TQueue a -> IO [a]) will surely have form "(.) (_ :: STM (Maybe a) -> IO [a])", yes?
18:50:39 <eacameron> mud: Great idea
18:51:02 <Lokathor> Gurkenglas, i found monad-loops
18:51:03 <Lokathor> and whileJust
18:51:06 * hackage cli-setup 0.1.0.2 - Helper setup scripts for packaging command-line tools.  https://hackage.haskell.org/package/cli-setup-0.1.0.2 (vmchale)
18:57:36 * hackage ats-format 0.1.2.0 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.2.0 (vmchale)
19:06:06 * hackage nice-html 0.4.1 - A fast and nice HTML templating library with distinct compilation/rendering phases.  https://hackage.haskell.org/package/nice-html-0.4.1 (MikeLedger)
19:09:07 <sqooq> ok turns out my structure is definitely just a graph
19:09:24 <sqooq> undirected graph technically, the traversal part is an algorithm
19:09:29 <parsnip> can you share ~/.stack between linux and macos? for example, why can you use docker with your macos stack command?
19:09:46 <hololeap> eacameron: maybe this will help? https://www.reddit.com/r/haskell/comments/6ewq5l/infinite_loop_in_compiler_without_undecidablexxx/
19:11:53 <hololeap> sqooq: did you see my recommendation for the fgl library? it's pretty heavy in terms of learning-curve but it's very powerful
19:12:22 <hololeap> maybe more powerful than what you need
19:12:45 <parsnip> and for example, "I use stack-linux to install my project, mounting my local $HOME/.stack and $PWD/.stack-work in the container in order to cache builds and produce valid Unix executables."
19:12:50 <sqooq> a simple adjacency list would do me just fine I think
19:12:53 <sqooq> but I'll check it out
19:12:54 <parsnip> http://www.alfredodinapoli.com/posts/2015-11-03-how-i-deploy-haskell-code.html
19:12:59 <parsnip> hmm, i'll just try it
19:14:09 <Axman6> > logBase 10 100000 -- :(
19:14:15 <lambdabot>  mueval-core: Time limit exceeded
19:14:20 <Axman6> :|
19:14:22 <Axman6> > logBase 10 100000 -- :(
19:14:28 <lambdabot>  mueval-core: Time limit exceeded
19:14:33 <Axman6> > 1+1
19:14:38 <sqooq> hololeap, skimming over it, it might be useful for the traversal part, thanks.
19:14:39 <lambdabot>  mueval-core: Time limit exceeded
19:14:42 <MarcelineVQ> Axman6: welp
19:14:51 <sqooq> fuck I need to do OSC stuff too... or use euterpea :P
19:14:55 <Axman6> maths got hard
19:15:04 <sqooq> maths is great
19:15:11 <sqooq> are great (?)
19:15:19 <Axman6> is
19:15:24 <hololeap> sqooq: it has almost almost everything you need for graph theory
19:15:37 <hololeap> almost^2
19:15:40 <sqooq> I live in us and I get made fun of for calling math maths
19:15:46 <sqooq> but like maths just always made more sense to me
19:16:00 <hololeap> maths does make more sense if you think about it. math is singular
19:16:33 <Axman6> sqooq: keep fighting the good fight
19:16:34 <sqooq> yeah because the name implies a plurality of like techniques
19:16:47 <sqooq> "math" would imply "mathematic"
19:16:59 <sqooq> so like it works as a descriptor
19:17:04 <hololeap> i'm also from the US and i thought "maths" was a typo or a joke at first :)
19:17:18 <sqooq> lmao
19:17:45 <sqooq> it could be that I was born in trinidad, which uses lots of british stuff since they were last ruled by the brits
19:17:53 <sqooq> but I left at 6
19:18:07 <sqooq> maybe I just kept that aspect of calling math maths.
19:18:28 <Axman6> calling maths maths*
19:18:46 <sqooq> kek
19:20:09 <Axman6> > 1+1
19:20:13 <lambdabot>  2
19:20:23 <Axman6> > logBase 10 100000
19:20:27 <lambdabot>  5.0
19:20:31 <Axman6> > logBase 10 1000000
19:20:36 <lambdabot>  5.999999999999999
19:20:39 <Axman6> :(
19:22:16 <hololeap> sqooq, i think you might be interested in this guy's work... he takes the left channel and maps it to the x axis and the right channel to the y axis of an oscilloscope and makes music that creates accompanying visuals: https://www.youtube.com/watch?v=XziuEdpVUe0
19:23:14 <Axman6> really needs a CRO though, IIRC it doesn't work with digital certificates
19:23:32 <hololeap> you could plug it into an oscilloscope with the same hookups and see the same visuals
19:24:07 <hololeap> blows my mind
19:24:29 <Axman6> I've been meaning to try it with my CRO for a while
19:29:25 <eacameron> hololeap: Thank you, yeah that's actually pretty helpful. I by reducing simplifier ticks I can get GHC to panic.
19:30:13 <hololeap> yw. i read that a little while back. luckily i haven't run into such a bug yet
19:33:16 <hololeap> https://www.youtube.com/watch?v=19jv0HM92kw  .... yeah :p
19:46:39 <sqooq> hololeap, I've seen his work, it's really good
19:46:58 <hololeap> i bought the album
19:47:24 <hololeap> and made mkvs with the video and flac made from the original wavs
19:47:44 <hololeap> i still haven't tried it on a hardware oscilloscope thought
19:47:47 <hololeap> *though
19:49:41 <hololeap> he has some really informative how-to videos too. the guy obviously understands DSP to a high degree
19:57:02 <sehqlr> Anyone else a Yi user here?
19:57:07 * hackage madlang 4.0.0.2, cli-setup 0.1.0.3 (vmchale): https://qbin.io/nkpvv4b
20:22:36 * hackage atomic-file-ops 0.2.0.0 - Functions to atomically write to files  https://hackage.haskell.org/package/atomic-file-ops-0.2.0.0 (clinton)
20:23:42 <__Unsigned> Is Haskell any good?
20:24:06 * hackage quickcheck-string-random 0.1.0.1 - Helper to build generators with Text.StringRandom  https://hackage.haskell.org/package/quickcheck-string-random-0.1.0.1 (hiratara)
20:24:20 <Axman6> not really, but it's the best we've got
20:25:00 <__Unsigned> I just can't get over how much I hate compelled whitespace.
20:25:05 <mud> __Unsigned: It's pretty fun and useful.
20:25:39 <Axman6> __Unsigned: Syntax is a really terrible reason to dislike a language which offers so much
20:25:42 <mud> __Unsigned: If that's a big stumbling block, then Haskell might not be for you.
20:27:19 <__Unsigned> I just like to have full style control, maybe I should stick with lisp
20:27:36 * hackage atomic-file-ops 0.3.0.0 - Functions to atomically write to files  https://hackage.haskell.org/package/atomic-file-ops-0.3.0.0 (clinton)
20:30:18 <eacameron> __Unsigned: You can use braces and semicolons in Haskell
20:34:04 <Axman6> __Unsigned: what do you mean by full control?
20:41:54 <statusbot> Maintenance update: Upgrading Hackage SSL Cert. Expect a few minutes downtime. -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5a5c30d6dae27e23940e6d78
20:50:01 <statusbot> Maintenance update: Hackage SSL cert successfully upgraded -- back up and running. -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5a5c30d6dae27e23940e6d78
20:51:42 <mud> Upgrading certs requires downtime? :-/
20:52:11 <mud> Also ... who calls them SSL certs anymore.
20:55:22 <glguy> Clearly statusbot
21:01:00 <eacameron> mud: Most people "out there" still say SSL
21:01:34 <eacameron> I've been working with Wordpress marketers for a while. That term will die hard.
21:02:34 <mud> eacameron: Most laymen probably, but if someone actually doing something with certs calls them SSL certs, I get more than a bit nervous personally.
21:03:21 <eacameron> mud: Haha...I'm just answering your question
21:03:25 * Axman6 does too
21:03:36 <glguy> Like those clowns at Let's Encrypt that use the term
21:03:50 <glguy> Seems like maybe a lot of worry about nothing
21:07:04 <eacameron> I usually just say SSL/TLS to straddle both sides ;)
21:08:34 <Axman6> heathen
21:10:23 <Lokathor> "referentially transparent"
21:10:40 <eacameron> Axman6: Yeah, like those fools who say C/C++
21:10:47 <eacameron> ;)
21:11:10 <eacameron> Saying C/C++ is like saying Haskell98/GHC
21:11:44 <Axman6> it's like saying Lambda Calculus/Haskell2010
21:12:02 <Lokathor> http://lpaste.net/361651#line80
21:12:32 <eacameron> Axman6: I was making yet another lang extensions joke
21:16:38 <Lokathor> okay i've clearly hit some sort of degenerate case in GHC
21:17:49 <Axman6> hmm, I like the includions of which libraries each group of modules comes from. I should do that
21:18:04 <Lokathor> based on if a single character in a comment is there or not, it compiles differently
21:18:27 <Axman6> I often try to make logical groups of related modules (ie, if I import a bunch of modules at the same time they'll probably be grouped), but this is more consistent.
21:19:23 <Lokathor> full repo, https://gitlab.com/Lokathor/galaxy-break
21:19:38 <Axman6> what's the difference between the top and bottom?
21:19:55 <Lokathor> bigger than is needed to reproduce this bug, apparently
21:20:09 <Lokathor> the top has bool return values on the final pures
21:20:11 <Lokathor> the bottom has ()
21:20:48 <Lokathor> but in the version on the repo link, you can delete a period from the end of the line 74 commend to make the final binary change results
21:21:03 <Axman6> also, threadDelay is a bit of a code smell
21:21:03 <Lokathor> changes to comments clearly should not change a program
21:21:32 <Axman6> o.O
21:22:24 <Lokathor> yeah
21:24:23 <Lokathor> also, delete the thread delay, no extra newlines, delete the spare boolean returns, extra newlines come back
21:25:53 <Axman6> how does the killWorld function work?
21:26:25 <Lokathor> killWorld = atomically $ writeTVar simRunningV False
21:26:55 <Lokathor> oh here's a fun one, if i change <> to ++ with the newline appending on the final flush, it changes how it works
21:27:08 <Axman6> feels like there should be another variable you wait on until it's actually killed instead of hacking with threadDelay (this is never the right way to do things)
21:27:28 <Lokathor> i removed the thread delay , let me make a new paste
21:27:47 <Lokathor> http://lpaste.net/361652 okay just one copy of the code
21:28:04 <Lokathor> if you change the ++ at the very end to <> you get the wrong results
21:32:37 <Lokathor> oh well, it's not critical that the final lines be correct
21:33:26 <MarcelineVQ> if you can narrow it down to a minimal reproducable example you might discover the issue, and if you don't it can then be reported to people who might
21:33:42 <MarcelineVQ> as it is there's a lot of moving parts, it seems to me
21:35:41 <MarcelineVQ> or at least, enough parts that this one module isn't showing them all, re world related things
21:38:11 <Lokathor> i gave the full repo link as well
21:38:58 <Lokathor> but here's the thing I don't get: what possible thread timings could affect the _number of newlines between lines_ that show up
21:39:01 <Lokathor> it makes no sense to me
21:43:05 <Lokathor> right now the world is just an echo server
21:43:15 <Lokathor> except in the case of "zap"
21:43:25 <Lokathor> where it echoes "boom" twice instead of a straight echo
22:12:23 <jmorriss[m]> Can anyone help me write filtering here https://github.com/joshua-morris/fp-course/blob/master/src/Course/Applicative.hs ??
22:22:56 <amalloy> jmorriss[m]: not without a more specific question. numerous people here could write it *for* you, but to help you write it they'd need more input: what have you tried, what are you stuck on
22:35:41 <jmorriss[m]> amalloy: I can write filter with type (a -> Bool) -> List a -> List a
22:36:05 <jmorriss[m]> foldRight (\a b -> if p a then a:.b else b) Nil
22:36:18 <jmorriss[m]> my problem is that p a in filtering returns f Bool
22:36:34 <jmorriss[m]> which can't be used as a condition
22:38:35 <amalloy> well, since all you know about f is that it's some unknown Applicative, you probably want to use one of the functions you have that works on any Applicative. <*> and <$$> look like they could be relevant
22:43:57 <jmorriss[m]> amalloy: right, so you would use apply and fmap to somehow 'read' the value of p x
22:44:06 <jmorriss[m]> where p x :: f Bool
22:47:15 <amalloy> well, you can't exactly "read" it, because there's no way to get a Bool out of an f Bool. but you can do the opposite: apply a function from Bool -> t, for some type t, inside the context of p x, yielding f t
22:49:13 <glguy> jmorriss[m]: how can you combine (p x) and lift2?
22:51:27 <jmorriss[m]> glguy: (p x) :: f Bool, so it would be lift2 somefunction (p x) (some f a)
22:52:02 <dibblego> whenever you know part of the answer, but not all, write that answer and where you don't know put undefined, then check that it compiles
22:52:55 <jmorriss[m]> dibblego: filtering p (x:.xs) =  lift2 undefined (p x) undefined, compiles
22:52:56 <glguy> :t \f fa -> liftA2 f (pure True) fa
22:52:59 <lambdabot> Applicative f => (Bool -> b -> c) -> f b -> f c
22:54:10 <dibblego> now put _undefined on one of them, try to recompile, and you'll see the type of the expression that needs to go there
22:54:16 <glguy> pure True is a placeholder for p x to get the type right
22:54:32 <jmorriss[m]> glguy: right
22:55:21 <jmorriss[m]> dibblego: the first undefined has type Bool -> b0 -> List a
22:55:27 <jmorriss[m]> the function
22:55:37 <dibblego> ok, put that one back, and try the other one
22:56:08 <jmorriss[m]> dibblego: f b0
22:56:28 <jmorriss[m]> does that mean the b0 in the function has the same type as this b0
22:56:46 <dibblego> no, it means it can be anything not yet mentioned
22:57:14 <dibblego> I can tell you thought, that it is (List a), so the entire value that goes there must be of the type (f (List a)), and that value is obtained by recursion
22:57:18 <dibblego> s/thought/though
22:58:42 <jmorriss[m]> dibblego: xs is suggested by ghc and has type f a
22:58:44 <jmorriss[m]> List a
22:59:06 <dibblego> correct, that is the value, in a position of recursion with the filtering function
22:59:52 <jmorriss[m]> right, filtering p xs
23:00:01 <jmorriss[m]> which leaves one undefined
23:00:10 <dibblego> yes, that goes there, then put _undefined on the other one, which should narrow the type
23:01:06 <jmorriss[m]> Bool -> List a -> List a
23:01:19 <dibblego> yes, so you need a value of that type in that position
23:05:22 <jmorriss[m]> dibblego: right
23:05:53 <jmorriss[m]> (\b l -> _)
23:05:55 <jmorriss[m]> where the hole is List a
23:06:14 <dibblego> if b then x:l else l
23:07:20 <jmorriss[m]> oh right
23:07:36 <jmorriss[m]> that makes sense
23:10:42 <Lokathor> that is a... strange way to write your type signatures
23:12:55 <jmorriss[m]> Lokathor: you mean on separate lines?
23:13:08 <Lokathor> yeah
23:15:19 <jmorriss[m]> Lokathor: it's pretty neat
23:15:33 <mniip> dang that's some enter key heavy code
23:16:11 <dibblego> It's useful. For haddock, for adding arguments, for changing identifier names without affecting spacing.
23:16:39 <mniip> right
23:16:52 <mniip> but not on uhh
23:16:56 <mniip> <*>
23:17:44 <dibblego> for all things, at all times!
23:18:32 <mniip> I am having trouble reading that kind of code when it's excessive
23:18:46 <mniip> so it in fact hinders readability
23:18:56 <dibblego> everyone says that on the first day
23:19:06 <dibblego> including the person who wrote it
23:19:21 <parsnip> and on the second day?
23:19:45 <dibblego> "this is sooo much better"
23:19:51 <mniip> I have no problem reading this sort of code https://github.com/mniip/dequantify/blob/master/Main.hs#L44-L45
23:19:53 <dibblego> as you can see above, <jmorriss[m]> Lokathor: it's pretty neat
23:20:29 <Lokathor> dibblego, my code from today looks like this https://gitlab.com/Lokathor/galaxy-break/blob/master/src/GalBreak/WorldIO.hs
23:20:37 <mniip> easy to say that when you don't have much to compare to
23:21:31 <dibblego> my code, and that of my team, and that which jmorriss[m] has been working with for a long time, for around 10 years, does not look like that. There are zero problems.
23:21:55 <dibblego> I am not particularly fond on arguing about strings FWIW.
23:22:52 <dibblego> "but all my buddies do it that way" is about the best argument that exists, and I will win it if we go down that path
23:23:05 <dibblego> I would like to not have that argument.
23:23:28 <mniip> shrug
23:23:36 <dibblego> cheers
23:25:08 <Lokathor> dibblego, you're saying that you and everyone you know all uses the super vertical style?
23:26:09 <dibblego> not everyone, and some minor variations, but yes
23:26:27 <dibblego> I am teaching a class of 80 people this week, who will all use it, 48 the week after in another city, and so on
23:26:58 <mniip> hmm http://tcpst.net/h8ar.png
23:27:40 <dibblego> I also believe that arguing about strings is the single biggest barrier to progress in programming.
23:27:49 <Lokathor> nonsense
23:27:54 <Lokathor> there are much bigger barriers!
23:28:01 <mniip> strings?
23:28:10 <Lokathor> i think they mean formatting style
23:28:19 <dibblego> no, I mean strings
23:28:27 <mniip> are you one of those who believes code should be stored in AST form and formatted by the programmer's editor?
23:28:29 <geekosaur> naming :p
23:28:30 <parsnip> like, "hello, world!"?
23:28:35 <dibblego> naming falls under strings
23:28:50 <dibblego> mniip: I think even worse than that, but mostly yes
23:28:57 <parsnip> linebreaks are naming?
23:29:03 <dibblego> this person knows what's up, https://brianmckenna.org/blog/polymorphic_programming
23:29:04 <parsnip> filenames can have linebreaks
23:29:12 <mniip> well uh, what isn't strings
23:29:20 <dibblego> everything isn't strings
23:29:38 <parsnip> "everything"
23:29:43 <mniip> there's an iso between constructible things and strings
23:29:43 <parsnip> that's a string
23:29:56 <mniip> (nonconstructible things don't matter)
23:30:06 * hackage fast-arithmetic 0.3.1.0 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.3.1.0 (vmchale)
23:30:13 <dibblego> no it isn't
23:30:28 <parsnip> dibblego: "this person" supports more line breaks?
23:30:35 <mniip> okay if this is some kind of elaborate joke/pun then I think no one gets it
23:30:40 <dibblego> I don't know what this question means.
23:30:52 <dibblego> it's not a joke, I will win this argument by writing code instead
23:30:54 <parsnip> dibblego: i don't know why you said they know what's up.
23:31:09 <mniip> then what is even going on here
23:31:12 <dibblego> they know why I am right, that strings are a ridiculous waste of programmer effort
23:31:25 <dibblego> because arguing about strings is an excellent waste of programming progress
23:31:28 <dibblego> that's what
23:31:28 <parsnip> okay, remove all th strings
23:31:31 <dibblego> I am.
23:32:04 <mniip> parsnip, all TH strings?
23:32:12 <dibblego> especially those
23:32:13 <parsnip> uh oh
23:32:35 <parsnip> but i just got started on this yesod tutorial! :(
23:32:49 <Lokathor> dibblego, i've formatted a type signature vertical style once or twice ever for haddock, but you don't even have the haddock
23:33:06 <dibblego> because haddock is strings
23:33:20 <parsnip> dibblego: can you help me out here?
23:33:26 <parsnip> dibblego: define strings.
23:33:26 <dibblego> with what exactly?
23:33:35 <dibblego> I truly struggle to define it
23:33:38 <parsnip> i'm not sure what you mean.
23:33:48 <parsnip> well, then difficult to go on.
23:33:52 <dibblego> "noun. a data structure, which has no practical purpose but to distract the programming profession"
23:34:03 <parsnip> dibblego: okay, so... i'm done.
23:34:22 <Lokathor> but you specifically said that haddock was one reason for vertical type signatures
23:34:30 <dibblego> it has been discussed at length in other forums, and we are working on solving the practical problem
23:34:45 <dibblego> Lokathor: yes, I admit that sometimes I write haddock, just not in this case
23:35:14 <dibblego> it is compromise between "what currently exists" against "what I would like to exist"
23:35:35 <mniip> so do you just misuse the term for anything you don't like because the term is vague enough and allows it?
23:36:02 <dibblego> I am not particularly interested in arguing about how your-preferred-text-editor renders your-preferred-number-of-0x20-characters in your source file.
23:36:13 <parsnip> then don't?
23:36:19 <dibblego> no, I am talking about a very specific technical problem, that is difficult to summarise
23:36:39 <dibblego> but is well understood after significant discussion
23:36:47 <dibblego> we have called it, for years, the stringly-typed problem
23:36:50 <parsnip> how to i distinguish what you are saying from BS?
23:37:02 <dibblego> you don't
23:37:07 <parsnip> there you go
23:37:13 <dibblego> why do I care?
23:37:24 <parsnip> why are you still talking?
23:38:01 <dibblego> because I am a programmer, who is distracted by the string argument
23:38:08 <kiwi_banal> stringly it out
23:38:34 <parsnip> yeah can you please string along
23:39:01 <kiwi_banal> Give him enough stringly
23:39:04 <EvanR> i read progress and postgres, and am so glad they only have one string type
23:39:11 <EvanR> s/and/as/
23:39:16 <parsnip> those are the same string
23:39:30 <dibblego> but if I cared, you distinguish from BS with the code
23:39:36 <dibblego> there is no other way
23:39:41 <EvanR> > map sort ["progress","postgres"]
23:39:44 <lambdabot>  ["egoprrss","egoprsst"]
23:39:54 <parsnip> dibblego: it looks like you're just typing strings
23:40:08 <dibblego> funny, I'm not.
23:40:18 <EvanR> typed strings?
23:40:32 <parsnip> well, this has been a very elightening string.
23:40:34 <dibblego> string is a programmer bias and it is pretty insane to look at.
23:40:35 <parsnip> *en
23:40:44 <infinisil> dibblego: I'm with you on the strings argument, sick of this stringly typed everything
23:40:52 <dibblego> infinisil: welcome to the dark side friend
23:40:59 <Lokathor> i think that a string is anything that dibblego doesn't like, but since dibblego presumably likes their own words, their own words are not strings
23:41:08 <dibblego> ugh
23:41:26 <parsnip> Lokathor: we stringed that a moment ago, try to keep string.
23:41:32 <dibblego> yes, an unfamiliar idea must *definitely* be exactly that thing, there is no other explanation!
23:41:32 <Lokathor> oh string
23:41:49 <EvanR> you have to admit that the stereotypical string type you find everywhere like js is pretty sophisticated for what it is, its not just a byte vector
23:41:58 <dibblego> infinisil: I had a meeting earlier with our government funding to solve this problem, please help us
23:42:14 <kiwi_banal> https://www.youtube.com/watch?v=TiEwL5KcqG0
23:42:25 <Lokathor> dibblego, Do you love Back to The Future? right now i feel like i'm Marty McFly and you're Doc Brown. What you're saying might be true, but you're very bad at explaining it if so
23:42:27 <dibblego> EvanR: I bet everyone in this discussion, however ridiculous, will agree that javascript programmers abuse strings, but perhaps not themselves — they use strings responsibly
23:42:35 <parsnip> when is Pixar's next The Strings to be released?
23:42:36 * hackage hw-kafka-client 2.3.1 - Kafka bindings for Haskell  https://hackage.haskell.org/package/hw-kafka-client-2.3.1 (alexeyraga)
23:42:52 <dibblego> Lokathor: I have not attempted to explain it — I am not sure how many different ways of saying that exist, but I believe I have said them all
23:43:14 <Lokathor> well then we're back to the blind men and elephant problem
23:43:33 <dibblego> Lokathor: your best counter-argument to the original point is, "my buddies do it this way with their spaces" and 1. if that is your argument, I will win it. 2. I don't even care enough to win it.
23:43:35 <EvanR> can we devolve into the wittgenstein problem
23:43:48 <parsnip> dibblego: there's always another string.
23:43:50 <dibblego> Lokathor: this subject is discussed properly, and constructively, in other forums.
23:44:08 <EvanR> oh i get it, youre talking about formatting the code
23:44:16 <dibblego> in that specific circumstance, yes
23:44:17 <EvanR> still
23:44:20 <Lokathor> okay? but this place isn't those other forums so i've never heard of this magical other discussion ?
23:44:46 <dibblego> Lokathor: I posted one article, by one person, who has been in those discussions for quite a lot of years. What exactly would you like?
23:45:07 <dibblego> for me to believe in your magical stringly typed programming? I am happy to pretend.
23:45:18 <Lokathor> that article was unreadable to me because i don't use whatever language it's about (Scala, i think) and i couldn't understand it
23:45:19 <parsnip> that article was written by Trump
23:45:28 <dibblego> you don't need scala to understand it
23:45:39 <dibblego> yes, written by Trump
23:45:42 <parsnip> that article did not have many line breaks
23:45:45 <dibblego> that makes sense
23:45:55 <parsnip> hence why i asked how it supports.
23:46:09 <kiwi_banal> no more strings? But we have almost unlimited memory now. Isn't that why we use strings rather than cut-down bit-representations? For human benefit, no?
23:46:15 <dibblego> yeah righto, cheerio
23:46:27 <dibblego> jmorriss[m]: please don't ask questions in here, come to the channel where we work
23:46:58 <EvanR> we should use formal language, strings and bits are just encodings of sentences in a formal language
23:47:02 <parsnip> #no_strings
23:47:32 <jmorriss[m]> dibblego: copy
23:47:37 <dibblego> jmorriss[m]: cheers
23:47:49 <dibblego> jmorriss[m]: I think it is advisable that you leave this channel
23:48:06 <Lokathor> jmorriss[m], it's advisable that you don't leave
23:48:09 <Lokathor> we're friendly
23:48:16 <dibblego> no, he is leaving, I am his parent, he is leaving
23:48:25 --- mode: ChanServ set +o dibblego
23:48:25 <parsnip> i'm a frayed not
23:48:28 --- kick: jmorriss[m] was kicked by dibblego (jmorriss[m])
23:48:33 --- mode: ChanServ set -o dibblego
23:48:35 <EvanR> what in the
23:48:46 <Lokathor> whatr
23:48:52 <dibblego> I will not expose my children to this lunacy, sorry
23:48:56 <EvanR> child abuse
23:49:04 <dibblego> now, cheerio
23:49:07 <Lokathor> you're pretty strange dibblego
23:49:25 <dibblego> yes, and that is very important
23:49:28 <parsnip> he's been stringing us along this whole time
23:49:33 <EvanR> hahahahahaha
23:49:35 <infinisil> did i miss a message of jmorriss or something?
23:49:44 <kiwi_banal> oh dear, I'm in the midst of a meltdown, having just returned from a nice beer/chat at the pub. Settle down lads, the anger will only give you health issues. Come back.
23:50:20 <Lokathor> dibblego, but as strange as you are, i don't understand your point, even re-reading the article you linked
23:50:53 <dibblego> Lokathor: I am not in this discussion any longer.
23:50:54 <dibblego> Lokathor: if you'd like to discuss further, on technical merits, I can point you to other forums.
23:51:10 <parsnip> Lokathor: the joke doesn't work if you have to explain it.
23:51:27 <Lokathor> sure, i'm not clear what the technical merits are
23:52:18 <kiwi_banal> string theory. i should have paid more attention
23:52:40 <Lokathor> i'm mighty shocked that they could make themselves admin
23:55:29 <Lokathor> so from what i can gather
23:55:29 <Lokathor> the desired path for programming is where you write a metaprogram
23:55:29 <Lokathor> and then it gets transpiled into some other actual language
23:55:29 <kiwi_banal> parsnip: nice one. I'm a frayed not. Best one yet.
23:56:33 <parsnip> kiwi_banal: i followed your lead, it didn't occur to me to smurf it until you said , stringly it out
23:57:29 <parsnip> i was all set to be grumpused by the trolling
23:58:57 <parsnip> why don't you make like a string and get stranded.
23:59:24 <kiwi_banal> parsnip: well, you may have been hanging on by a thread, but that cannot be bested (but could be worsted).
23:59:50 <parsnip> ooh
23:59:52 <EvanR> please cut the string talk
