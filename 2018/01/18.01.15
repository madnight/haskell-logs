00:00:04 <parsnip> k
00:00:06 <kiwi_banal> EvanR: good call
00:00:30 <EvanR> tie up all the loose ends
00:01:18 <parsnip> you're on a roll
00:01:39 <Lokathor> zING
00:01:39 <EvanR> im trying to unwind this evening
00:01:39 <kiwi_banal> I'm loosing the thread of this joke
00:01:51 <kiwi_banal> err losing but, well
00:01:57 <EvanR> lol
00:02:15 <pharaun> what a bizarre conv
00:03:13 <ggVGc> not sure what I just tabbed into
00:03:18 <kiwi_banal> I'm out. Thanks for a chuckle. Gonna hang out with my strung out mates...
00:03:20 <pharaun> exactly
00:03:22 <ggVGc> I tried readint the scrollback
00:07:12 <parsnip> "I also believe that arguing about strings is the single biggest barrier to progress in programming." was a defining moment.
00:08:42 <EvanR> i was totally thinking at first, lexical syntax of comments
00:08:55 <mud> I still have no idea what any of that was even about.
00:09:13 <EvanR> dont drive and IRC
00:09:17 <EvanR> er drink
00:12:42 <parsnip> hmm, still sinking in for me, trying to appreciate `-v $HOME/.stack:/root/.stack` in http://www.alfredodinapoli.com/posts/2015-11-03-how-i-deploy-haskell-code.html
00:13:35 <parsnip> started to look at other articles with similar goals, but maybe i get this one now.
00:14:04 <parsnip> if i delete the local project, i still have the linux .stack cached in my ~/.stack
00:14:21 <parsnip> and that will speed up future builds on similar projects.
00:15:04 <parsnip> it was a bit slow though the first time out, i wonder if i can combine that with `docker: enable: true`.
00:15:55 <parsnip> docker-in-docker talks about sharing between neighboring dockers.
00:17:17 <parsnip> i wonder if i can docker pull fpco/stack-build and drop it in ~/.stack/ on macos
00:17:45 <parsnip> and then do that mount from another docker onto the ~/.stack
00:20:02 <jchia> Is there a trick to quickly locate the source of an infinite loop?
00:20:15 <jchia> I suspect I just have a typo somewhere
00:21:59 <parsnip> share code?
00:22:44 <jchia> parsnip: It's a big code base. That's also why manually looking for the loop is harder.
00:23:16 <dibblego> jchia: you could revert back to the code when you know it didn't exist, then slowly introduce more code/tests until it loops again
00:23:47 <osa1> jchia: check your let bindings which is usually the source of unintended loops in my experience
00:24:05 <EvanR> jchia: you can insert Debug.Traces in various places
00:24:06 <osa1> jchia: e.g. things like `let x = ... x ...` instead of `let x' = ... x ...`
00:25:18 <[exa]> jchia: debugger and ctrl+c in the middle?
00:26:13 <jchia> exa: The problem just exits with "<<loop>>" or "thread blocked indefinitely in an STM transaction". GHC is smart enough to detect an infinite loop but I suppose not smart enough to tell me where it came from.
00:26:45 <jchia> EvanR: I'm doing the printf debugging right now. Just wondering if there's a more efficient way.
00:27:04 <dminuoso> Hi. Can someone explain to me what this guard does exactly? https://gist.github.com/dminuoso/eb833cd69ff3e7724f2d154049251888#file-ex-hs-L11
00:27:19 <ertes-w> helo
00:27:30 <dminuoso> Ohh boy! Nevermind. Quirky eyesight.
00:28:03 <dminuoso> Kept thinking it was passing (elem) rather than using `elem` as infix. :o
00:29:13 <ertes-w> dminuoso: side note: i generally find it less boilerplaty to have getOpt return a function
00:29:59 <[exa]> jchia: sounds a bit more like a deadlock
00:30:07 <ertes-w> data MyConf = MyConf { somePath :: FilePath, verbosity :: Int }  deriving (Eq, Ord, Show)
00:30:18 <ertes-w> then getOpt returns [MyConf -> MyConf]
00:30:22 <jchia> exa: Not, a deadlock. I get <<loop>> if I run the same thing outside 'atomically'.
00:31:59 <ertes-w> jchia: the latter error message is very different from the former, and it usually just means that a transaction is waiting for an event that GHC knows can't happen anymore
00:32:21 <[exa]> jchia: try -fbreak-on-exception (it should give you a stacktrace or something)
00:32:26 <dminuoso> Hey ertes-w. What would those functions do exactly?
00:33:28 <jchia> It's a deadlock only in the sense that the Async being waited for never finishes.
00:33:48 <ertes-w> dminuoso: Option "v" ["verbose"] (NoArg (\cfg -> cfg { verbosity = verbosity cfg + 1 })) "Increase verbosity"
00:34:11 <jchia> exa: Do you means like this? stack build --ghc-options -fbreak-on-exception
00:34:12 <dminuoso> ertes-w: Interesting, so each "option" somehow transforms your config?
00:34:18 <ertes-w> dminuoso: yeah
00:34:35 <[exa]> jchia: maybe (it should also work with ghci if you can hand-trigger it)
00:34:46 <ertes-w> dminuoso: it's slightly easier to write those if you have lenses
00:35:01 <ertes-w> dminuoso: Option "v" ["verbose"] (NoArg (verbosity +~ 1)) "Increase verbosity"
00:35:52 <dminuoso> ertes-w: That's quite interesting. It kind of reminds me how I maintain application state using redux in my react apps.
00:37:08 <ertes-w> at the end you just fold them into a single function that transforms a default configuration:  case getOpt … of (fs, args, []) -> let cfg = foldl (.) id fs defCfg in …
00:38:36 * hackage monad-logger 0.3.28 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.28 (MichaelSnoyman)
00:40:11 <dminuoso> ertes-w: Which getOpts are you using? Or did you just accidentally flip `fs` and `args` in that pattern?
00:41:29 <srhb> Hmm, what am I misunderstanding here in lens-aeson? I have a JSON object, and I want to get at its keys. ^@.. gives me an indexed traversal, so shouldn't it be: objectFoo ^@..ifolded.asindex ?
00:41:32 <srhb> asIndex, even
00:42:30 <ertes-w> dminuoso: the one from base
00:43:09 <ertes-w> dminuoso: you can do it this way, if you prefer:  foldl' (flip ($)) defCfg fs
00:43:40 <ertes-w> dminuoso: i instead folded the list of functions into a function and then applied it
00:47:29 <srhb> Or similarly, what's the idiomatic way to get just the keys of an object?
00:49:58 <dibblego> srhb: does (\x k -> x ^? key k) work?
00:50:08 <ooKO> I'm learning on learnyouahaskell.com, and GHCi base:Haskell2010, but when trying to declare function type eg.: 'removeNonUppercase :: [Char] -> [Char]', they throw an error 'Variable not in scope'. How to overcome this error?
00:50:42 <dibblego> ooKO: you must also write the function body
00:50:57 <srhb> dibblego: Er, as an ifolded target?
00:51:21 <dibblego> srhb: sorry, I just now noticed keys not key
00:51:30 <srhb> Indeed. :)
00:51:35 <srhb> I'm missing something obvious.
00:53:07 <ertes-w> ooKO: you're probably just misspelled the name of a predefined function, or perhaps you forgot to import something
00:55:28 <ooKO> dibblego, my example is 2nd screenshoot from http://learnyouahaskell.com/types-and-typeclasses. Maybe it is intended to be writen in file and then loaded. But how to declare function with type (and body) in GHCi?
00:55:31 <[exa]> ooKO: in GHCI you need to squash definitions + explicit typings to one line, like this: let { removeNUC :: [Char] -> [Char] ; removeNUC = undefined }
00:55:58 <dibblego> ooKO: for ghci, removeNonUppercase :: [Char] -> [Char]; removeNonUppercase = …
00:56:22 <srhb> I guess regular old fst combines will do, for: fst <$> (objectFoo ^@.. members)
00:56:35 <dibblego> srhb: yeah I saw that, but nothing better
00:58:51 <EvanR> ooKO: you usually dont define new functions like that in ghci, rather you change a source file that is loaded, and reload with :r
00:59:09 <EvanR> thats usually more ergonomic
00:59:32 <ooKO> EvanR, OK I know that, but when experimenting and learning with small examples.
01:00:07 <ertes-w> ooKO: it's easier to use a file anyway
01:00:48 <srhb> ooKO: There's even an :edit (:e) command to quickly open the file :)
01:01:36 <ertes-w> ooKO: use the `:l PATH` command to load a file, and whenever you change it just type `:r`
01:04:47 <dminuoso> ertes-w: I was just a bit confused when you said that getOpt returned [MyConf -> MyConf], but I think you meant ([MyConf -> MyConf], [String], [String]), i.e. a ~ (MyConf -> MyConf)
01:04:57 <dminuoso> ertes-w: But it makes perfect sense, and I like the idea.
01:05:15 <ertes-w> dminuoso: yeah, that
01:12:10 <dminuoso> ertes-w: Alright, I think its time to start with lenses then, it's fairly obvious how they make this style more concise. Thank you for the hint. :)
01:13:03 <ertes-w> dminuoso: don't get lost in the rabbit hole =)
01:15:05 <dminuoso> ertes-w: Well luckily Im already somewhat familiar with them not only from the JS world, but the idea of how they work - thanks to someone helpful in this channel who gave me a series of tasks involving Traversable and a Vector. ;-)
01:16:15 <ertes-w> oh…  who could that have been? =P
01:16:42 <ertes-w> lenses in JS though?  that sounds horribly awkward to work with
01:17:15 <dminuoso> ertes-w: https://www.npmjs.com/package/partial.lenses
01:17:30 <dminuoso> It's quite.. verbose.
01:20:15 <dibblego> that looks like this, https://hackage.haskell.org/package/data-lens-2.11.2/docs/Data-Lens-Partial-Common.html
01:20:21 <ertes-w> well, it looks as reasonable as it could get in JS…  probably easier than traversing things with loops
01:21:03 <ertes-w> dibblego: not quite…  it looks like the library also supports traversals
01:21:37 * hackage yam-app 0.1.8, yam-job 0.1.8, yam-servant 0.1.8, yam-transaction-odbc 0.1.8, yam-transaction-postgresql 0.1.8 (leptonyu): https://qbin.io/r2y4sjd
01:28:28 <Bish> dminuoso: do you work with haskell professionelly?
01:31:22 <dminuoso> Bish: I suppose in the strictest sense of the word "professional" - yes, since Im writing a small tool and I get paid for it.
01:31:38 <Bish> also with ruby?
01:31:42 <Bish> i just thought the combination is odd
01:32:08 <dminuoso> Bish: Im trying to get away from Ruby, and Haskell is what Im exploring right now.
01:32:39 <Bish> sounds like a plan
01:42:36 * hackage yam-app 0.1.9 - Yam App  https://hackage.haskell.org/package/yam-app-0.1.9 (leptonyu)
01:43:06 * hackage yam-job 0.1.9, yam-servant 0.1.9 (leptonyu): https://qbin.io/vlma8l5
01:45:06 * hackage yam-transaction-odbc 0.1.9, yam-transaction-postgresql 0.1.9 (leptonyu): https://qbin.io/jk3dsikgs
02:26:38 * hackage StockholmAlignment 1.1.2 - Libary for Stockholm aligmnent format  https://hackage.haskell.org/package/StockholmAlignment-1.1.2 (FlorianEggenhofer)
02:33:47 <chocopuff> I have a question regarding "<-" vs "=". I believe "<-" only ever appears in a "do-block"? Whats the difference
02:33:50 <chocopuff> for example
02:34:20 <chocopuff> let x = readLn vs. x <- readLn
02:34:49 <chocopuff> I think the difference is that you are binding "x" to readLn
02:34:50 <lavalike> chocopuff: x <- action in do blocks is sugar for action >>= \x -> ...
02:35:18 <lavalike> whereas let y = value is just a boring normal let binding giving value a new name, y
02:35:28 <chocopuff> the reason why you can't do let x = readLn is because x isn't going to be the necessarily the same each time?
02:35:50 <chocopuff> i forgot the name for this, referential transparency? forgot
02:35:56 <lavalike> you can do let x = readLn but that binds x to a value of type IO String (I'm guessing readLn is IO String)
02:35:59 <chocopuff> lavalike: ahhh makes sense
02:36:06 <chocopuff> yeah
02:36:24 <lavalike> whereas readLn >>= \line -> ... binds the result of "running the action" readLine to the local variable line, of type String
02:36:27 <chocopuff> oh, so haskell will actually just set x as the function instead
02:36:38 <lavalike> yup
02:37:17 <chocopuff> oh yeah, this is the new thing about func. programming that seems pretty interesting
02:37:24 <chocopuff> functions being treated more or less like variables
02:37:31 <lavalike> that's very much key
02:37:34 <chocopuff> the line is really blurred
02:37:50 <lavalike> "first-class citizens" of the language, like any other value, they are values
02:38:02 <chocopuff> yup, yeah that's what i'm getting at
02:38:05 <chocopuff> thanks again!
02:38:08 <lavalike> my pleasure!
02:38:13 <ahihi> note however that readLn isn't a function
02:38:56 <lavalike> oh right, functions have "->" in their type, I like to call stuff of type "monad something" "actions"
02:40:18 <chocopuff> lavalike: what do you mean by "->" in their type
02:40:32 <chocopuff> like i've seen say getX :: Int -> Int -> Int for example
02:40:34 <lavalike> something like succ :: Int -> Int being a function that given an integer returns the next one
02:41:43 <lavalike> whereas readLn :: IO String does not take any parameters
02:42:45 <lavalike> does that make any sense
02:42:49 <merijn> chocopuff: You can totally do "let x = readLn", it just doesn't do the same thing as "x <- readLn" :)
02:51:21 <ertes-w> chocopuff: everything IO is essentially metaprogramming…  you're not *running* anything, you're really just constructing programs from small pieces
02:51:54 <ertes-w> chocopuff: in other words 'readLn' is not a side-effecting value, but a pure value that represents the program that would perform the effect
02:52:04 <ertes-w> and do-notation is a way to compose such programs
02:53:15 <ertes-w> chocopuff: and about 'readLn' not being a function:  the defining feature of a function is that you can apply it, but you can't apply 'readLn'
02:53:20 <ertes-w> readLn ()  -- error
02:54:48 <ertes-w> chocopuff: the former also explains what (x = readLn) is about:  x and readLn are indeed the same value: the program that reads and parses a value from stdin
02:57:57 <chocopuff> am still here, will start reading through now :D
02:58:07 <[exa]> I vote for showing the monad beginners the real world as soon as possible.
02:58:21 <[exa]> GHC.Prim.RealWorld: here it is.
02:58:40 <merijn> [exa]: Why? It only reinforces bad intuitions
02:58:53 <merijn> I think we should've called it GHC.Prim.FuzzyThing :\
02:59:17 <[exa]> merijn: I kindof dislike pretending that it's not there, it adds a lot of confusion to the 'functional' feeling of the language to students
02:59:38 <merijn> [exa]: What do you mean "pretending it's not there". It's an internal compiler trick
02:59:51 <[exa]> from my experience they can digest 'a bit of syntactic sugar' easier than 'do not care what is inside'
03:00:15 <merijn> [exa]: Except the analogy completely breaks down when we start looking at exception handling, forkIO, etc.
03:00:16 <[exa]> merijn: very real for serialization though.
03:00:34 <chocopuff> still raeading through, but now that you guys are discussinh the pedagogical aspects, do you guys think for a complete beginner, functional paradigms are just as hard/easy to pick up as OOP?
03:00:36 <merijn> [exa]: Unless you're going to argue we can "rollback" and "clone" the real world
03:00:38 <ertes-w> [exa]: the problem is that RealWorld is an implementation detail and prevents some of the more well-founded explanations from making sense
03:00:47 <ertes-w> to me IO is an EDSL, and i explain it as such
03:01:17 <ertes-w> the "state transformer" interpretation makes sense, but it's not easy to justify
03:01:28 <merijn> chocopuff: I think learning to program is about as hard in any lanuage. Haskell might actually be easier to learn as a beginner if you don't know other languages
03:01:58 <ertes-w> chocopuff: in my experience FP might be more difficult to *explain*, but not necessarily more difficult to learn
03:02:24 <ertes-w> in other words: you need a teacher who can explain things that lack intuitive examples
03:02:40 <ertes-w> OOP on the other hand is easy to explain, but hard to learn/use
03:03:46 <[exa]> chocopuff: sorry for pedagogical confusion :] Look at it like this: 'readLn' is something that interacts with the user and gets a value from him. If you do 'let x = readLn', you basically copy this function and you have two names (readLn and x) for the same function "interact with the user and get a value from him"
03:04:13 <ertes-w> s/function/INSERT SOME OTHER WORD HERE/
03:04:26 <ertes-w> program/action/recipe/…
03:04:36 <[exa]> s/action-ish/
03:04:40 <[exa]> thanks.
03:05:23 <ertes-w> even "something" is fine =)
03:05:57 <[exa]> chocopuff: "actually invoking" readLn by hand is hard though (if you look at it as a function, it is something that needs to take a whole real world with the user, produce a modified real world with a user that has finished answering, and remember his answer)
03:06:00 <chocopuff> [exa]: yeah i got that part!
03:06:13 <chocopuff> wait, then how are the IO functions actually written?
03:06:25 <ertes-w> chocopuff: they are composed from primitives
03:06:28 <chocopuff> i'm assuming they're like bindings to an imperative language?
03:06:28 <chocopuff> hmm oh
03:06:43 <ertes-w> chocopuff: the "recipe" interpretation might make sense
03:06:53 <[exa]> ..and the primitives are given to the language by the compiler as something that "just works".
03:07:03 <ertes-w> (getLine :: IO String) is a *recipe* for doing something
03:07:09 <chocopuff> ertes-w: is it right to think of "do" as like a block of iterative code?, it kinda is impure functionally ? but it's all enclosed within the main = do
03:07:30 <chocopuff> as in, the real world stuff is contained in it
03:07:37 <ertes-w> chocopuff: no, because it's important to see how and why even do-notation is actually completely pure
03:08:11 <chocopuff> hmm oh
03:08:22 <chocopuff> that's kind of the wrong impression i was piecing together then
03:08:48 <[exa]> chocopuff: anyway, the sense of the special do notation is to abstract you from this passing of real world state around. By doing  do { action1; action2;} it constructs a new action which chains the two actions together correctly, passing the "world state" through them.
03:09:33 <[exa]> chocopuff: which is in fact again just a function of a similar type as e.g. readLn. "Something that also must handle the complicated situation outside"
03:09:54 <parsnip> can't one kind of explain monads as just assisting with a bit of f(g(h(x), y), z)?
03:10:22 <parsnip> so then first h is applied to x, then result is passed to g and it's application to y, etc.
03:10:37 <quchen> That has nothing to do with monads.
03:10:43 <chocopuff> [exa]: oh wait, wait a minute. so main is just kinda equivalent to readLn
03:10:57 <chocopuff> i mean, as in, they both abstract from the real world, it's an action
03:11:06 <[exa]> chocopuff: yep, it's also an invisible transformation of the outside world. :]
03:11:17 <[exa]> chocopuff: now about that <- arrow
03:11:17 <chocopuff> that's actually pretty cool
03:11:48 <[exa]> if you couldn't extract any information from actions, they'd be of precisely zero interest to your program
03:12:11 <parsnip> quchen: i thought that's actually how the parentheses work for bind operator.
03:12:27 <[exa]> so there's a mechanism that allows some actions to return a value "extracted" from the complicated internals/outside world
03:12:39 <[exa]> chocopuff: look at the types of e.g. readLn and putStrLn
03:13:07 <quchen> The bind operator isn’t special in any way, it’s an ordinary function. And parentheses never tell when things are done before other things, they just group expressions together.
03:13:21 <[exa]> chocopuff: maybe getLine and putStrLn will be easier
03:13:55 <quchen> 0 * (1234567890 + 952987598376598645) -- you wouldn’t evaluate the parenthesis first, would you?
03:14:15 <quchen> const 0 (undefined + undefined) -- dito
03:14:20 <[exa]> ofc not
03:14:32 <EvanR> uh you would if you went to the elementary school i did
03:14:40 <[exa]> lol
03:14:42 <EvanR> parentheses first
03:14:45 <EvanR> or else
03:15:03 <chocopuff> they're just a social construct, parentheses
03:15:11 <chocopuff> [exa]: yeah i'm kinda getting it more
03:15:17 <chocopuff> getLine :: IO String
03:15:58 <chocopuff> something is only a function if it has a -> in the type right?
03:16:09 <[exa]> chocopuff: the IO is the 'magical world state handler type' whese internals we don't want to discover, and its parameter is the type of the value the action can return.
03:16:12 <[exa]> chocopuff: yes
03:16:39 <EvanR> getLine is a command that when executed (may) returns a String
03:16:58 <parsnip> quchen: i don't mean to say that you have to go in order "always". but i think monads do imply some order of parens.
03:16:58 <EvanR> getChar is a command that when execute (may) return a Char
03:16:59 <[exa]> (roughly as in set mathematics, F: N -> N )
03:17:13 <chocopuff> [exa], ertes-w: oh yeah, and about learning resources, well i'm using learning you a haskell
03:17:25 <chocopuff> adn kinda also jumping between "write yourself a scheme in 48 hours" if you've heard of it
03:17:37 <chocopuff> any comments on these resources?
03:17:37 <[exa]> chocopuff: yeah the scheme book is magnificent
03:17:48 <chocopuff> it sounds pretty fun and promising
03:17:54 <[exa]> LYAH is a bit hated for being under-supplied with practical examples
03:17:56 <quchen> parsnip: They don’t. You name a »parenthesis order« and I’ll give you a monad that does not respect that order.
03:18:10 <[exa]> ..........but you can have examples here.
03:18:29 <parsnip> quchen: i mean that do notation desugars exactly into parens.
03:18:38 <quchen> Oh. Well that’s true.
03:18:49 <chocopuff> ah i see, at least both authors were kind enough to release them for free
03:18:56 <quchen> The monad laws say that it’s irrelevant how we parenthesize it, though.
03:19:07 <chocopuff> the LYAH cartoons are pretty nice lol
03:19:10 <[exa]> chocopuff: they reasonably start with monads and IO quite late in the process, but well, beginners need IO.
03:19:24 <chocopuff> [exa]: is this LYAH or scheme
03:19:29 <[exa]> yeah the cartoons are unprecedented.
03:19:30 <[exa]> LYAH
03:19:38 <parsnip> and point free notation can make things look ridiculous.
03:19:59 <chocopuff> [exa]: what i've done so far is kind of read enough of LYAH, but get confused enough that I started reading scheme
03:20:12 <[exa]> parsnip: ((.) (.) .) yay.
03:20:27 <chocopuff> but doesn't scheme jump straight into monads kind of
03:20:44 <chocopuff> and i realize you have to fill in a lot of gaps with scheme (which LYAH def helped with)
03:21:25 <[exa]> I have a favorite scheme-like exercise
03:21:39 <[exa]> converting the exercises from this https://ds26gte.github.io/tyscheme/ to haskell
03:22:09 <[exa]> anyway, let's finish the <- thing
03:23:25 <[exa]> just as the IO action do {io1; io2; } takes the plumbing work of passing the user and his environs from io1 to io2 for you
03:23:51 <TMA> speaking of point free notation: is the set of basic functions that are needed for it finite (I think you cannot define (.) or flip in the point free notation)
03:24:02 <[exa]> chocopuff: do { x <- io1 ; io2 } additionally extracts this "return value" from the io1 action and lets you use it for later computation
03:24:21 <quchen> TMA: Yes, all you need is S and K.
03:24:37 <quchen> TMA: K = \x y -> x; S = \f g x = f x (g x)
03:24:53 <quchen> See »SKI calculus«
03:24:53 <EvanR> that is not a good fairy tale for IO's monad instance
03:25:29 <quchen> TMA: Here is hello world, https://gist.github.com/shangaslammi/3438688
03:25:38 <EvanR> no environment is being transferred in do { io; io2 }
03:27:31 <[exa]> EvanR: is there a simpler explanation? (except for EDSLs)
03:27:52 <EvanR> i dont know but theres certainly ones that arent misleading wrong
03:28:32 <EvanR> it desugars to io1 >> io2
03:28:38 <chocopuff> [exa]: ah got it, same thing with list comprehension? you want the values to be the ones generated, not the functions as the elements of the list
03:28:56 <EvanR> which means, an IO action which does io1, ignores the result, and does io2, returns that result
03:28:57 <[exa]> I know that the 'environment' is defined very implicitly as 'just this state' so there's no environment and I know that I'm dangerously instantiating everything to IO, but it kindof works
03:29:10 <EvanR> IO is not state
03:29:37 <[exa]> chocopuff: list comprehension uses the same syntax for hiding the complexity of something completely different, yes. :]
03:29:37 <EvanR> its instructions for a machine, or OS
03:30:55 <chocopuff> [exa]: is that a syntax short-coming?
03:31:08 <chocopuff> i guess this question is more of a philosophical one
03:31:15 <[exa]> EvanR: what type does an instruction have?
03:31:31 <EvanR> IO ()
03:31:41 <chocopuff> The different meanings for all the arrows sometimes are hard to remember? you also have -> for pattern matching as well as function types
03:31:58 <[exa]> EvanR: and how do you get the Char from that?
03:32:12 <EvanR> you dont
03:32:36 <[exa]> EvanR: and how do I connect that logically to the explanation of how getLine works?
03:32:43 <EvanR> you can only turn an IO Char and a Char -> IO () into an IO ()
03:33:18 <EvanR> so the resulting "instruction" will get a char, then handle it with another one
03:33:24 <EvanR> based on the value of the char
03:33:44 <EvanR> its not really stateful
03:34:20 <EvanR> a counterexample to the state theory is getCurrentTime :: IO UTCTime
03:34:37 <[exa]> chocopuff: a design choice. But there aren't extremely many meanings of the arrows. -> in a type expression is "function from _ to _", -> outside of type expressions is always 'pattern match' as in case
03:34:57 <EvanR> running three programs with the same start time (run them at the same time) will give you three different answers
03:35:05 <chocopuff> fair enough, there are only so many arrows you can have, perhaps ~> could work :P
03:36:02 <EvanR> how is that possible from the same start state, because its not a state machine. its a multitasking OS taking commands
03:36:27 <[exa]> EvanR: good point. After everyone gets it I usually show the students that there's no state at all because saving the whole world is impractical (they see the empty data GHC.Prim.RealWorld) and tell them that for practical reasons the state is stored implicitly (because well, it's everywhere around if you need it)
03:36:51 <EvanR> i am saying that saving the state in theory doesnt explain IO
03:37:10 <EvanR> state doesnt magically change with time while you dont evaluate something
03:37:11 <[exa]> chocopuff: ~> is already used for something else afaik :D
03:37:33 <[exa]> EvanR: it does if you don't actually save it to RAM
03:37:44 <EvanR> no.
03:38:21 <EvanR> the theory is that there is a universe state, a single value, and it gets passed around implicitly from statement to statement. and you use it deterministically
03:38:29 <[exa]> But yes I agree that it's certainly not valid this way
03:38:34 <EvanR> which is wrong because you get different behaviors running the same IO program
03:38:58 <EvanR> with, in the simple view, the same start state
03:39:38 <[exa]> if I should get mathematical I should probably insert some letTheWorldDoWorldyThings between all operations to get a rough equivalent of State
03:39:50 <EvanR> if you want to say, its not the same universe state, then you can postulate that you can run the IO program in a given prepared quantum state
03:40:03 <EvanR> then do IO to collapse it into a random result
03:40:10 <EvanR> thats not "state"
03:40:15 <[exa]> yep
03:41:14 <EvanR> im not saying i have a precise actual semantics for what this "OS" is
03:41:20 <EvanR> but its not state
03:41:49 <[exa]> well no one has. even if someone had, there are random neutrinos coming from universe flipping your bits here and there :]
03:42:15 <chocopuff> [exa]: darn! well i really don't blame the design choices then, can't think of any other arrows you could make
03:42:58 <[exa]> What I wanted to say is that this is the quickest way to understand why it needs extra syntax and some of the reasoning below. Idealizing some of it is a way to fit it in a CS course. :]
03:43:17 <[exa]> EvanR: thanks for discussion though, the time-measuring example is a good one
03:44:01 <[exa]> chocopuff: --> ==> => >=> >> >>= ~> >->    ( :] )
03:44:18 <[exa]> chocopuff: but they are all bound already
03:45:02 <EvanR> you can also read results of quantum experiments
03:45:05 <[exa]> chocopuff: the good point that the 'simple' -> arrow is the only one that has some extra syntactical meaning
03:45:34 <EvanR> which somehow gives you 1 answer at random, rather than a deterministic result based on the starting state alone
03:45:54 <EvanR> or all possible answers like list monad
03:49:06 <ertes-w> all this confusion goes away if you stop treating IO like a state monad
03:49:19 <ertes-w> it's an EDSL
03:50:37 <quchen> The problem with this state approach is that it’s highly misleading, yet technically correct (in GHC), so it will always be mentioned at some point discussing IO. :-/
03:50:49 <ertes-w> one could go as far as to raise physical concerns as to why "real world transform" couldn't possibly make sense
03:51:01 <[exa]> quchen: thanks for the 'technically correct'. :]
03:51:04 <ertes-w> it's not even technically correct…  it's just that the "RealWorld" type is horribly named
03:51:09 <quchen> Right.
03:51:12 <quchen> So is State#.
03:51:13 <ertes-w> it's nothing but a thread…  you can treat it like ()
03:51:26 <merijn> Hence my suggestion that it should've been GHC.Prim.FuzzyThing :)
03:51:28 <ertes-w> the only reason for its existence is strictness
03:51:55 <[exa]> FuzzyDangerousIncompleteWorldyThing
03:52:03 <quchen> I think »Token« would have been a good name.
03:52:12 <quchen> Means nothing unless you know its intention.
03:52:23 <[exa]> quchen: +1 for token
03:52:42 <ertes-w> the name doesn't really matter…  () would have been fine
03:52:50 <ertes-w> it's a dummy type
03:53:00 <[exa]> it has the same definition as ()
03:53:12 <quchen> Does it? I don’t think so
03:53:27 <quchen> I thought it was almost-but-not-quite ()
03:53:33 <quchen> …for technical reasons :-þ
03:53:38 <ertes-w> well, it's similar to (), except that you don't get access to the constructor
03:53:39 <[exa]> oh it doesn't have the data constructor, ofc. :D
03:54:18 <quchen> It’s a primtype, not a »data RealWorld = RealWorld«
03:54:26 <ertes-w> well, semantically speaking it needs to have a defined value
03:54:39 <quchen> https://github.com/ghc/ghc/blob/a1a689dda48113f3735834350fb562bb1927a633/compiler/prelude/primops.txt.pp#L2347
03:54:39 <ertes-w> but it doesn't have to give you access to it
03:54:45 <quchen> ertes-w: Why does it have to have a value?
03:55:10 <[exa]> oh lord there's actually State# RealWorld in Prim?!
03:55:14 <quchen> ertes-w: That always confused me, why isn’t Void a good token as well?
03:56:32 <ertes-w> quchen: take (putStrLn :: String -> State# RealWorld -> State# RealWorld)
03:56:55 <ertes-w> you need to use the new value, otherwise semantically it's the same as never having used that function
03:57:20 <ertes-w> but if there is no potential for a new value (because there are no inhabitants), then again you could just as well never have used the function
03:58:31 <quchen> Hmm. I guess it comes down to that it’s hard to force a non-inhabited value.
03:58:49 <ertes-w> it rather comes down to Void only having one value =)
03:58:58 <quchen> But then, it could be a zero-width hypothetical value with special STG calling conventions.
03:59:08 <ertes-w> () -> ()  -- there are 3-4 functions of this type, depending on whether 'seq' is allowed
03:59:24 <ertes-w> Void -> Void  -- there are only 1-2 functions of this type
03:59:54 <quchen> id, undefined, const undefined?
04:00:01 <quchen> :-þ
04:00:22 <ertes-w> for (Void -> Void) id and (const undefined) are the same function
04:01:06 <ertes-w> ignoring the obvious undefined function () -> () leaves 3 functions, so if you use the resulting value, GHC has no choice but to actually use the function
04:01:23 <ertes-w> f :: () -> ()  -- GHC can't optimise this one away
04:03:37 <merijn> ertes-w: Why not?
04:03:44 <merijn> I actually think it could
04:03:54 <ertes-w> merijn: assuming f is primitive and not inlinable =)
04:04:27 <ertes-w> merijn: i'm explaining why (State# RealWorld) can't be an empty type semantically
04:06:27 <[exa]> guys do you remember why void is named void?
04:06:35 <[exa]> void main(void) {...} ?
04:07:08 <Myrl-saki> [exa]: it's how you feel after programming in C for so long.
04:07:30 <[exa]> :]
04:07:35 <ertes-w> they needed a keyword for "IO action"?
04:08:08 <ertes-w> void = very obscure idiotic denotation
04:09:04 <nullie> It can change global variable
04:41:09 <geekosaur> [exa], because up until that point there was no way to express in C "this return value will not be used". you had to declare it as int, then ignore the value --- which meant useless warnings, or not warning in cases where it actually mattered
04:41:43 <geekosaur> the void parameter list and (void*) pointer type both came later, with ANSI C
04:46:54 <geekosaur> (actually no, (void *) was in some K&R-era C compilers. it wasn't very common outside of the BSD compilers though, iirc)
04:49:06 * hackage typesafe-precure 0.5.1.1 - Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)  https://hackage.haskell.org/package/typesafe-precure-0.5.1.1 (igrep)
04:58:36 * hackage dotenv 0.5.2.2 - Loads environment variables from dotenv files  https://hackage.haskell.org/package/dotenv-0.5.2.2 (camm)
05:08:50 <jchia_> I'm thinking of using ReaderT to pass in things like config params and options to functions so that my functions don't end up with a really long argument list. When a function calls another function, it may tag on additional params or remove params that the next function doesn't need to know about. I could make a record type catered to each function, but that's quite boilerplatey. Is there some standard trick or idiom for passing params
05:08:50 <jchia_>  into successive levels of function calls?
05:10:40 <dminuoso> [exa], geekosaur: Interestingly its legal to do this: void f(void g) { ... }
05:11:00 <dminuoso> So `void` actually exists in the Haskell sense. :P
05:11:17 <sphinxo> best way to create a list, setting the nth value to 1?
05:11:51 <dminuoso> You can even declare global void objects in C.
05:12:36 <sphinxo> ( and filling all the other variables to zero )
05:12:49 <sphinxo> ( and also specifiying the list size )
05:14:41 <cocreature> sphinxo: map (\i -> if i == n -1 then 1 else 0) [0..]
05:15:56 <dminuoso> maybe: f n s = set (element n) 1 $ replicate s 0
05:17:23 <dminuoso> cocreature: Curious, is there a reason you used `map` ?
05:17:29 <dminuoso> rather than fmap that is.
05:17:39 <cocreature> it’s one less character to type :)
05:22:36 * hackage kawa 0.1.0.0 - Key-value store in single files.  https://hackage.haskell.org/package/kawa-0.1.0.0 (thoferon)
05:22:57 <dminuoso> cocreature: Do you use this rationale in your own code as well?
05:24:40 <cocreature> dminuoso: I don’t use that rationale but I do use "map" rather than "fmap" fairly often. I don’t buy into the “always use the most general function you can find”-idiom
05:25:25 <cocreature> I don’t have any hard rules on when to use what, I just make a decision on a case-by-cases basis based on readability and how likely I am to be changing the type here
05:32:51 <parsnip> map is nice, it let's you know there's nothing more exotic coming than a plain old list.
05:33:12 <ertes-w> jchia_: ReaderT more or less forces you into using monolithic types, and that's why i generally avoid it…  if you design your types "a la carte", functions may work better
05:33:45 <ertes-w> jchia_: all it takes to reduce the number of arguments is to combine arguments into product types
05:34:22 <ertes-w> (a.k.a. record types)
05:36:59 <jchia_> Something like this: foo :: A -> B -> ... -> IO (); foo a b = ... bar b (f b) ...; bar :: B -> C -> ... -> IO (); bar a b = ... baz a b ...; bar :: B -> C -> ... -> IO();
05:37:36 <jchia_> multiple layers of functions from high-level to low, sharing various arguments. I want to avoid  long param list and explicitly making records for each function's unique signature.
05:38:01 <jchia_> ertes-w: Do you mean defining a record for each function?
05:38:09 <ertes-w> jchia_: that's kinda hard in haskell, unless you're comfortable with tuples
05:38:37 <ertes-w> we don't have a good extensible record/row type system
05:38:44 <jchia_> conceptually, it's like having a dictionary that i pass down the layers adding and removing elements
05:39:07 <jchia_> with presence of requisite keys checked at compile-time
05:39:58 <ertes-w> yeah, haskell doesn't have built-in support for that, and the libraries that try to emulate it (like vinyl) are not very nice to work with
05:40:36 * hackage quickcheck-state-machine 0.3.1 - Test monadic programs using state machine based models  https://hackage.haskell.org/package/quickcheck-state-machine-0.3.1 (stevana)
05:41:12 <ertes-w> jchia_: your best bet is the "a la carte" approach
05:41:32 <jchia_> ertes-w: What's the a la carte approach?
05:42:02 <ertes-w> jchia_: try to come up with a minimal set of types that you can combine into larger ones using sums/products
05:42:17 <jchia_> OK
05:42:41 <ertes-w> there is a paper on it, if you want a more in-depth explanation: "data types a la carte"
05:43:27 <ertes-w> by wouter swierstra
05:44:38 <jchia_> Oh, that "a la carte" paper. I've been wanting to read that but haven't.
05:49:06 * hackage filepath-crypto 0.0.0.3 - Reversable and secure encoding of object ids as filepaths  https://hackage.haskell.org/package/filepath-crypto-0.0.0.3 (gkleen)
05:55:36 * hackage project-template 0.2.0.1 - Specify Haskell project templates and generate files  https://hackage.haskell.org/package/project-template-0.2.0.1 (MichaelSnoyman)
05:57:33 <tabaqui> where can I found full TH manual?
05:57:54 <tabaqui> GadtC constructor has strange fields
05:58:53 <tabaqui> damn, downloads.haskell is down
05:59:37 * hackage forsyde-shallow 3.3.1.0 - ForSyDe's Haskell-embedded Domain Specific Language.  https://hackage.haskell.org/package/forsyde-shallow-3.3.1.0 (ugeorge)
06:00:23 <lyxia> tabaqui: which fields?
06:00:54 <tabaqui> lyxia: the first one [Names]. Why there is a list here?
06:00:58 <tabaqui> and second
06:01:11 <phadej> you can write data Foo a where Foo1, Foo2 :: Foo Int
06:01:18 <phadej> thus list
06:01:41 <tabaqui> I cannot use this syntax without GADT?
06:02:08 <tabaqui> hm, right
06:02:23 <tabaqui> ok, I'll check when haskell.org comes back
06:02:26 <tabaqui> and another one:
06:02:52 <tabaqui> suppose we have "data Foo a where Bar :: Foo Int; Baz :: a -> Foo Char"
06:03:25 <tabaqui> then Bar constructor has empty list of fields, while Baz has two
06:03:36 <tabaqui> where the first one is Bang NoSourceUnpackedness NoSourceStrictness
06:03:41 <tabaqui> what does it mean?
06:04:52 <dminuoso> parsnip: Fair enough. I suppose to me it's not helpful to think of map being any more special than fmap. I suppose in a way I'd like fmap to be just map without any list specific map.
06:05:13 <dminuoso> so that I could just do `map f someTree`
06:06:37 * hackage yam-app 0.1.10, yam-job 0.1.10 (leptonyu): https://qbin.io/71foenbw
06:07:28 <geekosaur> I have to assume you're guessing as to things because you can't copy them (downloads.h.o issue is known, they're working on it)
06:07:28 <phadej> tabaqui: what'are the Type's ther?
06:08:33 <geekosaur> but that sounds like things related to a struct field definition. presence of !, presence/absence of UNPACK pragma, presence/absence of STRICT pragma?
06:08:52 <tabaqui> ehm, their types? [(Bang NoSourceUnpackedness NoSourceStrictness,VarT a_19)] and []
06:09:23 <phadej> there's only one entry in the list
06:09:35 <tabaqui> why? two
06:09:38 <tabaqui> Bang and VarT
06:09:55 <tabaqui> ohh
06:10:06 <phadej> :)
06:10:07 <tabaqui> I need to get more tee
06:10:09 <tabaqui> thanks
06:10:15 <phadej> you're welcome
06:10:49 <tabaqui> well, then I just wait for the site
06:11:04 <tabaqui> actually I want to write generic compare for GADTs types
06:11:40 <tabaqui> I have about 3 layers of GADTs and need to write a lot of lines like
06:12:04 <tabaqui> compare a@Bar{} b@Bar{} = a == b; compare a@Baz{} b@Baz{} = a == b...
06:12:37 * hackage yam-servant 0.1.10, yam-transaction-odbc 0.1.10, yam-transaction-postgresql 0.1.10 (leptonyu): https://qbin.io/kbipwj42
06:13:15 <phadej> tabaqui: doesn't StandaloneDeriving works for you?
06:13:26 <phadej> i.e. `deriving instance Eq (MyType a)` ?
06:13:35 <tabaqui> nope
06:13:37 <phadej> I see
06:13:52 <jchia_> ertes-w: I think I'm going to use ImplicitParams.
06:15:17 <ertes-w> jchia_: that might work, at the expense of making everything a little awkward…  also i recommend not doing that in a library
06:15:52 <jchia_> ertes-w: Just my own app.
06:15:57 <ertes-w> jchia_: there is also the implicit configurations approach, but that one doesn't really solve your problem
06:18:37 * hackage servant-ruby 0.5.1.0 - Generate a Ruby client from a Servant API with Net::HTTP.  https://hackage.haskell.org/package/servant-ruby-0.5.1.0 (joneshf)
06:19:37 * hackage rattletrap 4.0.2 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-4.0.2 (fozworth)
06:39:06 * hackage hwhile 0.1.1.0 - An implementation of Neil D. Jones' While language  https://hackage.haskell.org/package/hwhile-0.1.1.0 (alexj136)
06:48:36 * hackage universum 1.0.3 - Custom prelude used in Serokell  https://hackage.haskell.org/package/universum-1.0.3 (shersh)
07:22:37 * hackage wrecker 1.3.0.0 - An HTTP Performance Benchmarker  https://hackage.haskell.org/package/wrecker-1.3.0.0 (lorenzo)
07:41:39 <dminuoso> If you were tasked to parse data in this format https://gist.github.com/dminuoso/25778f8f5a8b38de3d02dfa1687705c5 into something like [("foo", ["a1", "a2"]), ("bar", []), ("quux", ["c1"]), ("baz", ["d1", "d2", "d3"])], what kind of parsing approach would you do? Some simple State based string processing? Parsec?
07:42:42 <mud> dminuoso: Probably parsec-ish.
07:43:23 <mud> If it's for something *really* goofy and inconsequential and only I'd see it, I might consider some lame thing with splitting on blank lines and then just transforming each line and etc.
07:43:27 <ertes-w> dminuoso: i'd probably just use some basic string functions
07:43:51 <ertes-w> split into lines via stream processing, then split at ':' via Text functions
07:44:56 <ertes-w> dminuoso: just a side note: you could probably even abuse a YAML parser for that
07:45:58 <Gurkenglas> What are the cons for default superclass instances, such as one that would remove the need to change pre-AMP code to comply with AMP?
07:46:12 <dminuoso> ertes-w: Mmm. I was originally hoping for something like (a -> Bool) -> [a] -> [[a]] similar to dropWhile/takeWhile which would allow me to start a new group whenever the predicate held true.
07:47:06 * hackage wai-middleware-rollbar 0.8.2 - Middleware that communicates to Rollbar.  https://hackage.haskell.org/package/wai-middleware-rollbar-0.8.2 (joneshf)
07:47:36 <ertes-w> dminuoso: the first issue with that is []
07:47:55 <Gurkenglas> :t \p -> groupBy (\x y -> p y) -- dminuoso
07:47:57 <lambdabot> (t -> Bool) -> [t] -> [[t]]
07:48:07 <ertes-w> dminuoso: but if you're careful enough to parse linearly you might get away with it in terms of performance
07:48:24 <Gurkenglas> (not p, I suppose)
07:48:38 <dminuoso> ertes-w: The data is small enough to be quite liberal in the choice of container and algorithm.
07:48:53 <dminuoso> Somewhere between 10,000-100,000 lines total
07:49:14 <Gurkenglas> > let foo = \p -> groupBy (\x y -> not $ p y) in foo even [1..10]
07:49:20 <lambdabot>  mueval-core: Time limit exceeded
07:49:23 <dminuoso> Heh.
07:49:25 <Gurkenglas> um.
07:49:49 <Gurkenglas> > 2+2
07:49:51 <dminuoso> Gurkenglas: But I get the idea, interesting.
07:49:53 <lambdabot>  4
07:50:01 <ertes-w> :t T.dropAround isSpace . T.split (== ':') . T.lines
07:50:06 <lambdabot> error:
07:50:06 <lambdabot>     Not in scope: ‘T.dropAround’
07:50:06 <lambdabot>     No module named ‘T’ is imported.
07:50:08 <Gurkenglas> > let foo = \p -> groupBy (\x y -> not $ p y) in foo even [1..10]
07:50:12 <lambdabot>  [[1],[2,3],[4,5],[6,7],[8,9],[10]]
07:50:23 <ertes-w> :t Data.Text.Lazy.dropAround isSpace . Data.Text.Lazy.split (== ':') . Data.Text.Lazy.lines
07:50:28 <lambdabot> error:
07:50:28 <lambdabot>     • Couldn't match type ‘[Data.Text.Internal.Lazy.Text]’
07:50:28 <lambdabot>                      with ‘Data.Text.Internal.Lazy.Text’
07:50:37 <ertes-w> :t map (Data.Text.Lazy.dropAround isSpace) . Data.Text.Lazy.split (== ':') . Data.Text.Lazy.lines
07:50:41 <lambdabot> error:
07:50:41 <lambdabot>     • Couldn't match type ‘[Data.Text.Internal.Lazy.Text]’
07:50:41 <lambdabot>                      with ‘Data.Text.Internal.Lazy.Text’
07:50:44 <Gurkenglas> No brackets needed there
07:50:44 <ertes-w> d'oh
07:50:54 <ertes-w> :t map (Data.Text.Lazy.dropAround isSpace . Data.Text.Lazy.split (== ':')) . Data.Text.Lazy.lines
07:50:56 <lambdabot> error:
07:50:56 <lambdabot>     • Couldn't match type ‘[Data.Text.Internal.Lazy.Text]’
07:50:56 <lambdabot>                      with ‘Data.Text.Internal.Lazy.Text’
07:51:00 <ertes-w> oh, come on
07:51:03 <ertes-w> anyway, you get the idea
07:51:05 <ertes-w> dminuoso: ^
07:51:18 <ertes-w> Text comes with pretty much everything you need
07:51:29 <dminuoso> ertes-w: Yeah I do indeed. It does seem so, time to explore Text too.
07:51:31 <ertes-w> so even if [] would be good enough, Text is still better =)
07:51:43 <dminuoso> Right on :)
07:52:53 <ertes-w> :t map (map (Data.Text.Lazy.dropAround isSpace) . Data.Text.Lazy.split (== ':')) . Data.Text.Lazy.lines
07:52:55 <lambdabot> Data.Text.Internal.Lazy.Text -> [[Data.Text.Internal.Lazy.Text]]
07:52:56 <ertes-w> there =)
07:53:37 <ertes-w> that can be slightly improved though
07:54:07 * hackage dotenv 0.5.2.3 - Loads environment variables from dotenv files  https://hackage.haskell.org/package/dotenv-0.5.2.3 (camm)
07:55:41 <tabaqui> how can I create instance declaration for * -> *?
07:56:11 <tabaqui> when I try $(deriveCompare ''DataWithOneParameter)
07:56:24 <tabaqui> I get Expecting one more argument to ‘DataWithOneParameter'
07:57:24 <lyxia> tabaqui: what is deriveCompare
07:57:43 <ertes-w> :t map (fmap (both %~ Data.Text.Lazy.dropAround isSpace) . traverse (fmap snd . Data.Text.Lazy.uncons) . Data.Text.Lazy.break (== ':')) . Data.Text.Lazy.lines
07:57:44 <lambdabot> Data.Text.Internal.Lazy.Text -> [Maybe (Data.Text.Internal.Lazy.Text, Data.Text.Internal.Lazy.Text)]
07:57:59 <ertes-w> dminuoso: this should do everything
07:58:16 <tabaqui> deriveCompare :: Name -> Q [Dec]
07:58:19 <tabaqui> lyxia:
07:58:42 <ertes-w> dminuoso: you can eliminate the lens dependency by replacing (both %~ _f) by let f = _f in bimap f f
07:59:02 <ertes-w> (or: join bimap f)
07:59:20 <lyxia> tabaqui: where does it come from? Can I see the source?
07:59:39 <tabaqui> ok, I prepare a paste
07:59:53 <ertes-w> :t map (fmap (join bimap (Data.Text.Lazy.dropAround isSpace)) . traverse (fmap snd . Data.Text.Lazy.uncons) . Data.Text.Lazy.break (== ':')) . Data.Text.Lazy.lines
07:59:55 <lambdabot> Data.Text.Internal.Lazy.Text -> [Maybe (Data.Text.Internal.Lazy.Text, Data.Text.Internal.Lazy.Text)]
08:00:31 <tabaqui> lyxia: https://pastebin.com/Q5MTc77s
08:00:34 <lyxia> tabaqui: it should be possible to do with TH so if that doesn't work that may simply be an unforeseen limitation of deriveCompare that could be patched.
08:00:53 <tabaqui> I made it like in http://www.haskell.org/bz/thdoc.htm
08:01:40 <tabaqui> dunno, I thought, that compile error message should be other in this case
08:02:04 <tabaqui> s/other/different
08:02:22 <cocreature> the error message might come from the code produced by the TH
08:02:31 <lyxia> "AppT eqt (ConT t)" this represents "Eq DataWithOneParameter"
08:03:27 <lyxia> "Eq (DataWithOneParameter a)" would be something like "AppT eqt (AppT (ConT t) (VarT a))"
08:04:44 <tabaqui> hmm, then I need to extract variable from my vars of type Cxt
08:05:57 <lyxia> tabaqui: that last link is dead for me
08:06:07 <tabaqui> https://web.archive.org/web/20100703060856/http://www.haskell.org/bz/thdoc.htm
08:06:11 <tabaqui> try this one
08:06:36 <tabaqui> the code is in the bottom of the page
08:07:53 <lyxia> thanks
08:08:19 <lyxia> It has the same issue so you didn't do anything wrong.
08:10:12 <tabaqui> Oh, brilliant, now I need to convert [pred, pred, pred] to AppT pred (AppT pred (AppT pred pred))
08:10:54 <tabaqui> haskell templates are single-pass, right?
08:11:24 <tdammers> you mean template haskell?
08:11:31 <tabaqui> yes
08:11:45 <tdammers> sort of, yes
08:39:07 <nhan2> I am learning haskell and this is one line of code confused me:
08:39:28 <nhan2> somefunctionname = (fmap fst .)
08:39:53 <nhan2> can anyone explain the . a bit?
08:40:10 <kuribas> :t (fmap fst .)
08:40:12 <lambdabot> Functor f => (a -> f (b1, b2)) -> a -> f b1
08:40:12 <nhan2> I know fmap, fst, but why that .
08:40:16 <glguy> (fmap fst .) is another way to write:   \f -> fmap fst . f
08:40:28 <nhan2> hmmm,
08:40:37 <glguy> This is called a "section"
08:40:46 <glguy> :t (10 +)
08:40:48 <lambdabot> Num a => a -> a
08:40:49 <nhan2> so it's (fmap (fst . f))
08:41:03 <glguy> > (10 +) 20
08:41:06 <nhan2> oh,
08:41:07 <nhan2> ok,
08:41:07 <lambdabot>  30
08:41:29 <nhan2> oh,
08:41:34 <nhan2> "section"
08:41:42 <glguy> You can read more about sections in the Haskell Report section 3.5: Sections
08:41:59 <nhan2> I see, thank you glguy,
08:42:38 <nhan2> which takes precedence?
08:42:57 <glguy> I don't understand the question
08:43:06 <nhan2> the . or the (fmap fst) . f?
08:43:41 <nhan2> I think I can find that out, thank you.
08:43:44 <glguy> function application happens before operator application
08:43:50 <glguy> so a b . c   is   (a b) . c
08:43:57 <kuribas> nhan2: function application binds the most strongly
08:44:18 <nhan2> nice,
08:44:31 <nhan2> this is very helpful.
08:47:07 <kuribas> it's rather obfuscated
08:52:34 <kuribas> :t fmap (fmap fst) :: Functor f => (a -> f (b1, b2)) -> (a -> f b1)
08:52:36 <lambdabot> Functor f => (a -> f (b1, b2)) -> a -> f b1
08:53:47 <kuribas> even more obfuscated :)
09:05:00 <jmcarthur> :t (fmap . fmap) fst
09:05:02 <lambdabot> (Functor f2, Functor f1) => f1 (f2 (b1, b2)) -> f1 (f2 b1)
09:05:23 <jmcarthur> :t fmap fmap fmap fst
09:05:27 <lambdabot> (Functor f2, Functor f1) => f1 (f2 (a, b)) -> f1 (f2 a)
09:06:05 <jmcarthur> :t flip fmap fmap fmap fst
09:06:08 <lambdabot> (Functor f2, Functor f1) => f2 (f1 (a, b)) -> f2 (f1 a)
09:06:37 * hackage hakyll 4.11.0.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.11.0.0 (JasperVanDerJeugt)
09:07:06 <jmcarthur> :t fmap flip flip fmap fmap fmap fst
09:07:09 <lambdabot> (Functor f2, Functor f1) => f1 (f2 (a, b)) -> f1 (f2 a)
09:07:11 <jmcarthur> I'm done now
09:11:50 <ShalokShalom75> which databases written in functional languages are available?
09:11:56 <ShalokShalom75> next to Couch and Mnesia
09:26:57 <dmj`> ShalokShalom75: the tried and true, acid-state
09:27:01 <dmj`> @package acid-state
09:27:01 <lambdabot> http://hackage.haskell.org/package/acid-state
09:29:11 <dminuoso> ertes-w: Since I dont have your intuition, I decided to approach it a little differently and use Data.List.Split in conjunction with Data.Text, the Splitters feel a bit more intuitive to use.
09:29:50 <dminuoso> group' = tail $ (S.split . keepDelimsL . whenElt) (isPrefixOf $ pack "dn.")
09:30:13 <dminuoso> Gives me the kind of grouping I was looking for, beyond then its just simple string processing. :)
09:34:06 * hackage pgdl 10.10 - browse directory listing webpages and download files from them.  https://hackage.haskell.org/package/pgdl-10.10 (sifmelcara)
09:39:06 * hackage yaml 0.8.27 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.27 (MichaelSnoyman)
09:44:38 <ShalokShalom75> thanks a lot
09:45:11 <ShalokShalom75> Oh, this is exactly something is searched for ^-^
09:45:55 <ShalokShalom75> is there a specific name for data structures as your database?
09:48:39 <kuribas> jmcarthur: even better :)
10:08:06 * hackage wrecker 1.3.1.0 - An HTTP Performance Benchmarker  https://hackage.haskell.org/package/wrecker-1.3.1.0 (lorenzo)
10:17:10 <albatross_> I'm getting an error message for parse error http://lpaste.net/361666
10:18:02 <albatross_> not sure what's going on...
10:18:04 <glguy> Doesn't appear to be any error message in the paste
10:18:07 <dmwit> (==) is non-associative.
10:18:27 <dmwit> `x == y == z` is invalid. You can write `x == y && y == z`, which is probably what you meant.
10:18:32 <glguy> the first == was supposed to be a =
10:18:36 <glguy> perhaps?
10:18:42 <glguy> Oh, nope, scratch that
10:19:35 <dmwit> You can also write `(x == y) == z` or `x == (y == z)`, but then you are comparing one `Bool` and the output of one equality check, which probably is not what you meant.
10:19:37 <glguy> (I read it as another clause in the definition, not as an expression as dmwit did)
10:22:23 <dmwit> Also I suspect your `addSpaces (0, s)` definition has a bug. =)
10:29:04 <cocreature> dmwit: now I’m unreasonably annoyed that even for 3 booleans, (x == y) == z does not check if they are all equal
10:31:17 <dmwit> yeah =)
10:31:30 <dmwit> Some languages do fun hacks to make that kind of thing, and stuff like `x < y < z`, Just Work.
10:32:25 * cocreature waits for ReinH to tell us about the virtues of mixfix operators :)
10:33:30 <dmwit> Does mixfix help? Are you saying you would want another operator named _==_==_ or something? That seems like it doesn't scale...
10:34:01 <cocreature> it doesn’t scale particularly well but that’s pretty much how Coq handles this
10:34:36 <cocreature> agda too afaik
10:34:53 <ReinH> I mean, I'm not sure how mixfix would handle this.
10:35:37 <cmotoche> Hello everyone. May you know why for GHC 8.0 the result is "test-result missing" in Matrix Hackage? https://matrix.hackage.haskell.org/
10:36:06 <cocreature> cmotoche: did you intend to link to a specific package?
10:36:40 <cmotoche> https://matrix.hackage.haskell.org/package/dotenv
10:36:43 <cmotoche> Sorry
10:37:51 <cocreature> hm not sure what’s going on here, sorry
10:51:46 <dmwit> cmotoche: Seems like a great question for #hackage. Though beware they might direct you to another forum.
10:52:42 <cmotoche> Thanks dmwit
10:54:07 * hackage mono-traversable 1.0.8.0, chunked-data 0.3.1 (MichaelSnoyman): https://qbin.io/kqwqtm6
10:55:25 <fosskers> is repeatedly consing onto a Vector a bad idea?
10:55:40 <fosskers> or is it faster to cons a lot to build a list, then convert to Vector at the end?
10:56:27 <kadoban> Typically adding to the front of a vector over and over is not a good idea. I'm not super familiar with haskell's Vector's, but I thought I know how they're implemented.
10:56:49 * kadoban goes to look
10:57:23 <jmcarthur> fosskers: It'd probably be faster to build a list and then convert. Depending on your algorithm, it'd be even faster (and terser) to use some of Vector's higher level functions.
10:58:14 <jmcarthur> fosskers: In a worst case situation, consing will reconstruct the whole vector every time, but not so for a list.
11:00:13 <kadoban> Where do the modification functions on mutable vectors even live? Not seeing them ...
11:01:33 <lyxia> kadoban: Generic.Mutable defines the main class
11:02:18 <dmwit> fosskers: You might also like Data.Seq.
11:02:48 <dmwit> O(1) cons, snoc, uncons, unsnoc, O(log n) indexing, and generally no more than a log n hit for other operations.
11:02:49 <kadoban> lyxia: Okay, thanks. I guess there isn't even a cons on mutable vectors, so they must have been talking about the one for immutables.
11:03:17 <dmwit> (All asymptotic bounds are amortized, of course.)
11:06:13 <ReinH> fosskers: what are you trying to do that is causing you to repeatedly cons onto a vector?
11:08:50 <sqooq> what are causal commutative arrows, they sound like magic
11:10:04 <sqooq> from the little I understand it can normalize an arrow program with many loops into one with only a single loop and one vector of state variables (?)
11:10:15 <sqooq> so it improves efficieny like crazy
11:10:16 <sqooq> apparently
11:11:08 <jmcarthur> sqooq: That's pretty much it, but I don't think it's as exciting as it sounds. First of all, it doesn't work on all arrow programs. It only works on arrows with loop and init.
11:11:40 <sqooq> neat
11:11:42 <jmcarthur> sqooq: It also is unable to optimize anything that isn't expressed using the arrow framework, so it's really not that magical.
11:11:57 <sqooq> well apparently that's why the euterpea creator decided to stick with arrows, because he was considering arrowless because arrows suck
11:12:01 <jmcarthur> sqooq: Since most instances of these type classes will want to offer operations beyond just the arrow ones
11:12:29 <sqooq> but the efficiency of causal commutative arrows I guess was worth it
11:15:04 <ReinH> "arrows suck" [citation needed]
11:16:12 <jmcarthur> I would probably use arrows more if they didn't require arr
11:16:35 <sqooq> what about "proc" or whatever
11:17:07 <jmcarthur> Arrow notation is just a way to make arrows suck less, but really a feature that should make me want to use them.
11:17:07 <MarcelineVQ> jmcarthur: you seen conal's work on cartesian closed categories?
11:17:31 <jmcarthur> MarcelineVQ: Yeah, and also http://www.megacz.com/berkeley/garrows/
11:17:40 <MarcelineVQ> thanks for the link
11:18:41 <jmcarthur> *but not really a feature that should make me want to use them
11:18:46 <jmcarthur> That "not" was an important word
11:32:48 <albatross_> hey guys, when I do pattern matching, how do I have ghci recognize 1 as Int instead of literal '1'? http://lpaste.net/361666
11:34:50 <dmwit> (0:1) is a pattern that matches a list whose head is 0 and whose tail is 1. This asserts that 1 is a list. Presumably you did not intend to assert that.
11:35:04 <dmwit> Perhaps you meant (0:[1]), or (0:1:rest).
11:35:11 <dmwit> If the former, I would suggest writing it as [0,1] instead.
11:36:09 <fosskers> ReinH, I'd like to expose a `Vector` field in some type in my API, but have to build the field from nothing
11:36:40 <fosskers> I'm going to run some benchmarks to compare the "building" speed of list, seq, and vector
11:36:43 <albatross_> thanks dmwit
11:36:53 <hpc> it helps when you're starting out to always write list matches as (0:1:[]) so you always see the structure of lists in your code
11:36:56 <hpc> as cons cells
11:37:13 <hpc> and so you don't get () and [] confused
11:39:16 <kadoban> fosskers: Be careful because it'll matter a lot the size you look at. list and seq should have something like O(1) behavior for each const, vector will have something like O(n) behavior. So if there's any possibility they'll grow arbitrarily large, you really want to be careful with the vector one whatever your benchmarks say.
11:39:16 <kamyar> Hello guys
11:39:23 <kadoban> each cons*
11:39:32 <kamyar> please help me about finding Haskell package that merges replicateM with forkIO
11:39:50 <kamyar> Once I found it days ago but now I cant
11:40:10 <fosskers> kadoban, yeah the Vector could potentially be quite large
11:40:24 <fosskers> since they're vectors of coordinates
11:40:45 <jmcarthur> kamyar: Well, there's replicateConcurrently from https://hackage.haskell.org/package/async-2.1.1.1/docs/Control-Concurrent-Async.html
11:41:41 <jmcarthur> fosskers: It's not clear to me why you have to "build" it instead of just "define" it. What is the algorithm you're building it with?
11:41:58 <kamyar> jmcarthur: Really thanks!
11:42:36 * hackage HFuse 0.2.5.0 - HFuse is a binding for the Linux FUSE library.  https://hackage.haskell.org/package/HFuse-0.2.5.0 (M15K)
11:49:28 <sssilver> you guys ever find yourselves returning functions?
11:49:45 <dmwit> v. frequently
11:49:55 <sssilver> that's so odd
11:50:02 <sssilver> why would you return a perfectly good function?
11:50:09 <mnoonan> mine was impure
11:50:09 <dmwit> =D
11:50:44 <hpc> sssilver: every time i write a function of more than one argument ;)
11:50:44 <mnoonan> they replaced it for Free
11:51:08 <jmcarthur> sssilver: Do you really believe it seems odd or are you kind of joking around?
11:51:39 <sssilver> whenever I have a function that I like, I always feel tempted to invoke it instead of returning
11:52:33 <sssilver> also, there has to be a programming language where you can only return functions 2 weeks after implementing them, and only in original packaging
11:53:26 <monochrom> Creating a memoized function is a good time to return a function (and not the degenerate case).  f = let mytable = ... in (mytable !)
11:53:51 <tdammers> if you squint a little, almost everything you return is a function
11:54:00 <tdammers> thanks to non-strict evaluation
11:54:03 <metahumor> returning functions is great if you're going to pass them to something else =)
11:54:25 <MarcelineVQ> composecomposecompose
11:54:38 <monochrom> Another time to return a function is when the function depends on I/O.  g :: IO (Int -> Bool); g = do { inp <- getLine; if null inp then return even else return odd }
11:54:52 <metahumor> like an interpolating function that slerps between two points
11:54:52 <amalloy> tdammers: i don't think we need another "everything is a function in haskell" discussion
11:55:23 <tdammers> amalloy: fair enough
11:55:55 <monochrom> And of course IO (IO Char) and IO (Char -> IO Int) are often useful too
11:56:47 <shakranick> is there a function the any variable i give her, it give me back False?
11:56:52 <monochrom> And yeah it's pretty clear the question is not about merely "f x y = 2*x + y"
11:56:52 <hpc> some styles of threading code can end up with lots of IO (IO a) being passed around
11:57:03 <metahumor> "typedef int (*myfunc)(char);"
11:57:04 <shakranick> the = that
11:57:10 <metahumor> shakranick: "const False"
11:57:10 <jmcarthur> shakranick: const False
11:57:31 <shakranick> thanks you voth i'm going to try :-)
11:57:37 <shakranick> voth = both :-)
11:57:59 <dmwit> \x -> False -- if you like alternate spellings
11:58:05 <monochrom> You can also write "\x -> False" if you want to go under the hood.
11:58:25 * dmwit high fives monochrom for choosing the right variable name
11:58:35 <monochrom> But I guess reading the source code of const is as good.
11:58:41 <monochrom> heh
11:59:33 <monochrom> And oh on returning functions and currying in C I have this gem: http://lpaste.net/358634
12:00:47 <amalloy> monochrom: what is a scenario in which IO (IO Char) is useful?
12:01:36 <dmwit> amalloy: I'd like to create a communication channel between threads, but hide whether I'm using MVar or TMVar or Chan or whatever behind the scenes.
12:01:45 <monochrom> Yeah, that.
12:01:53 <hpc> amalloy: if you're passing work to a thread pool, you might have getNextOperation :: IO (IO whatever)
12:01:55 <dmwit> amalloy: Therefore in my library I expose `IO (IO Char)` as the method which constructs the channel and hands back the reading function for it.
12:01:56 <hpc> amalloy: and then
12:02:10 <dmwit> And maybe forks a thread to fill the channel, say. =)
12:02:11 <hpc> do {action <- getNextOperation; forkIO action}
12:02:38 <monochrom> do { v <- newEmptyMVar; return (putMVar v, takeMVar v) }  :: IO ( Char -> IO (), IO Char )
12:03:18 <hpc> Chan (IO ()) is a great type for that sort of thing as well
12:03:34 <hpc> a thread-safe queue of code to execute
12:03:41 <hpc> arbitrary code, even
12:05:05 <monochrom> Non-commutativity: (thread-safe queue) of code ≠ queue of (thread-safe code)  :)
12:05:30 <hpc> yeah
12:05:39 <hpc> sometimes you only need the queue because the code /isn't/ thread-safe
12:05:51 <hpc> like if you're using a library that uses thread-local storage
12:05:55 <monochrom> But I guess the thread-safe queue helps you run code sequentially so it's alright.
12:08:13 <ReinH> tdammers: squint a little... now squint some more... even more... now you can't see... everything is a function.
12:08:47 <lampda> Sorry for asking this in #haskell but... I have a hard time understanding how to make a "instance Functor Mydatastructure where" in Typescript. Is it possible to import the "typeclass definition" from a library or something? I've repeatedly failed to describe to typescripters what I want to do.
12:09:43 <centril> We have that:  (CoArbitrary a, Arbitrary b) => Arbitrary (a -> b)   which defines `shrink = []`.  My understanding is that this is the case because given:  (\(input :: a) -> (coarbitrary a (arbitrary :: Gen b) :: Gen b))  shrinking the output `Gen b` would entail that calling the function with two equal arguments would (potentially) yield different results wherefore it would not be a function any longer
12:10:00 <centril> Is this understanding right? And is there any sensible way of shrinking functions?
12:10:38 <centril> Also; What uses have you had for generating random functions?
12:10:55 <kamyar> I need to apply a function of a -> b to IO [a] and get IO b
12:10:59 <kamyar> What should I do?
12:11:12 <kamyar> sorry: I fix
12:11:22 <kamyar> I need to apply a function of a -> b to IO [a] and get IO [b]
12:11:40 <mnoonan> kamyar: do you know what to do if you had a [a] -> [b] and an IO [a], and wanted an IO [b]?
12:11:43 <kamyar> what is the solution? <$> does not work
12:12:13 <centril> kamyar:  Assume m :: IO [a];  m >>= \as -> pure $ fun <$> as :: IO [b]
12:12:19 <kamyar> mnoonan: AFAIK <$> digs one level
12:12:47 <mnoonan> kamyar: right. and can you think of a way to get an [a] -> [b] from an a -> b?
12:12:49 <centril> or:  fmap (fmap fun) m
12:13:28 <hyperisco> kamyar, the rule of thumb is: if <$> doesn't work then use more <$>
12:13:49 <centril> (which is what I did with   fmap (fmap fun) m)
12:13:51 <kamyar> thnx lets try
12:15:18 <centril> : fmap (fmap (+1)) (pure [1, 2] :: IO [Int]) :: IO [Int]
12:15:43 <centril> how do you make lambdabot do stuff again?
12:15:46 <dmwit> centril: You may like `data Fun a b -- ^ Generation of random shrinkable, showable functions.`
12:15:51 <mnoonan> > putStrLn "like this"
12:15:55 <lambdabot>  <IO ()>
12:15:56 <centril> mnoonan: cheers
12:16:04 <centril> > fmap (fmap (+1)) (pure [1, 2] :: IO [Int]) :: IO [Int]
12:16:07 <lambdabot>  <IO [Int]>
12:16:29 <dmwit> % fmap (fmap (+1)) (pure [1, 2]) :: IO [Int]
12:16:31 <yahb> dmwit: [2,3]
12:17:01 <centril> dmwit: cool; I'll check it out - are there any papers on this or CoArbitrary in general?
12:19:00 <dmwit> I don't know of any off the top of my head. All the things I would do to locate one are available to you as well: poring through the documentation, searching on Google scholar, etc.
12:20:06 <centril> dmwit: ofc =) Just that people might point you in a better direction than a search @ scholar =)
12:20:08 <centril> thanks
12:20:35 <dmwit> Yep, I understand. The "I don't know of any off the top of my head" was an important part of my message. =)
12:20:47 <shakranick> with your help i found the solution but i have another question that i screenshoted here: https://image.ibb.co/gZVY7R/baba.png
12:20:54 <dmwit> But I also didn't want to send the message "there aren't any" because I just lack knowledge here.
12:22:07 <dmwit> shakranick:
12:22:08 <dmwit> ?src id
12:22:09 <lambdabot> id x = x
12:22:44 <dmwit> ?. hoogle type \x -> x
12:22:46 <lambdabot> Prelude id :: a -> a
12:22:46 <lambdabot> Data.Function id :: a -> a
12:22:46 <lambdabot> GHC.Exts breakpoint :: a -> a
12:24:25 <dmwit> (This answer has two parts. One is the answer to your question. The other is a pointer to some tools that may help you answer further questions of this kind yourself in the future.)
12:25:13 <shakranick> smwit great thanks. i knew the id but didn't think about it :)
12:25:26 <shakranick> dmwit* (sorry)
12:25:58 <dmwit> =)
12:26:27 <centril> dmwit: And my thanks for the answer!
12:26:30 <centril> <3
12:32:15 <metahumor> re the "unfold" that shakranick sent out
12:32:36 <metahumor> is there a way of describing such unfolds with Profunctors?
12:33:10 <metahumor> it seems to me that the "h" is a "post-map", and the "f" is a "pre-map"
12:34:24 <centril> So... I need some help on naming an API for a property based testing framework in Rust.. there's an operation which is morally `Just :: Cloneable a => a -> Gen a`  and then I have an operation `<to_be_named> :: (() -> a) -> Gen a`.. Any ideas on what to name `<to_be_named>`  ?
12:34:56 <centril> I thought of  `Generator` and `Const`
12:34:59 <metahumor> "promoted_create"
12:35:33 <centril> metahumor: what's your reasoning?
12:35:41 <hpc> i don't see how those are different
12:36:11 <hpc> (() -> a) is the same as (a) in just about every in-language way
12:36:22 <centril> hpc: they are no different in Haskell, a lazy language without affine types - but they are very different in a strict and affine language like rust
12:36:33 <Gregor01> I get an error in my round function:
12:36:34 <Gregor01>  roundDouble :: Double -> Double roundDouble x = round ((x * (int2double 100))::Double)
12:36:54 <Gregor01> where is my error?
12:37:08 <Gregor01> GHC reports: No instance for (Integral Double) arising from a use of ‘round’
12:37:32 <mnoonan> :t round
12:37:34 <lambdabot> (Integral b, RealFrac a) => a -> b
12:37:52 <metahumor> centril: "create" as in "unit -> a" is "create", and "promoted" because you are supplying it as a Gen, not just as a "(->) () a"
12:38:07 <mnoonan> round gives an integral type back, so you either need to convert the integral type back to a double, or use some other function
12:38:07 <Gregor01> got it!
12:38:16 <Gregor01> The return type is an integer
12:38:40 <Gregor01> roundDouble x = fromIntegral $ round ((x * (int2double 100))::Double)
12:38:44 <metahumor> more exactly, a polymorphic type that is an instance of Integral
12:38:50 <Gregor01> thanks!
12:39:00 <mnoonan> you'll need to specify the intermediate type somehow, too
12:39:03 <centril> metahumor: that makes sense, thanks
12:39:22 <mnoonan> because you're going Double -> a -> Double, where a is some Integral type. But you didn't say which.
12:39:32 <mnoonan> kind of like doing "show . read"
12:39:48 <metahumor> yeah, althought GHC will complain if you don't have the "round" polymorphic type explicitly
12:39:53 <metahumor> oh mnoonan said that
12:42:19 <Gregor01> thanks!
12:43:04 <mnoonan> all that said, there are also "ceiling", "floor", and "truncate" that may meet your needs
12:43:29 <mnoonan> (whoops, sorry, for some reason I thought those went Double -> Double. they don't.)
12:44:45 <metahumor> any reason why the constraints for those are in "reverse" order?
12:46:58 <dmwit> This won't cause an error. Defaulting will kick in instead.
12:47:21 <dmwit> > fromIntegral (round 2)
12:47:24 <lambdabot>  2
12:47:55 <dmwit> % default ()
12:47:56 <yahb> dmwit:
12:48:00 <dmwit> % fromIntegral (round 2)
12:48:00 <yahb> dmwit: ; <interactive>:3:1: error:; * Could not deduce (Integral a0) arising from a use of `fromIntegral'; from the context: Num b bound by the inferred type of it :: Num b => b at <interactive>:3:1-22; The type variable `a0' is ambiguous; These potential instances exist:; instance Integral Word16 -- Defined in `GHC.Word'; instance Integral Word32 -- Defined in `GHC.Word';
12:48:09 <mnoonan> is that true even outside of ghci? I have poor intuition about defaulting in ghc..
12:48:15 <Hafydd> > fromIntegral (round 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999)
12:48:17 <lambdabot>  1000000000000000001915675085734668736215955127265192011152803514599379324203...
12:48:21 <dmwit> mnoonan: yes
12:49:26 <dmwit> % default (Integer, Double)
12:49:26 <yahb> dmwit:
12:49:37 <dmwit> % :set -XNoExtendedDefaulting
12:49:37 <yahb> dmwit: Some flags have not been recognized: -XNoExtendedDefaulting
12:49:46 <metahumor> Hafydd: yeah, I was just about to comment about how I'd love better support for arbitrary precision fractionals
12:49:55 <dmwit> % :set -XNoExtendedDefaultRules
12:49:56 <yahb> dmwit:
12:50:06 <Hafydd> metahumor: better than Rational?
12:50:15 <dmwit> % fromIntegral (round 2) -- mnoonan, still works without ghci's extended defaulting
12:50:15 <yahb> dmwit: 2
12:50:24 <dmwit> % :set -XExtendedDefaultRules
12:50:24 <yahb> dmwit:
12:50:36 <metahumor> Hafydd: how would you use Rational to fix your "fromIntegral . round" problem there?
12:50:38 <mnoonan> interesting, thanks. to the wiki for me..
12:51:02 <suzu> this is really confusing me
12:51:05 <dmwit> > fromInteger (round (9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 :: Rational))
12:51:08 <lambdabot>  9999999999999999999999999999999999999999999999999999999999999999999999999999...
12:51:11 <Hafydd> Yes.
12:51:14 <metahumor> sweet.
12:51:16 <suzu> why can't a traversal' be used as a lens'?
12:51:19 <suzu> type Traversal' a b = forall f . Applicative f => (b -> f b) -> (a -> f a)
12:51:20 <suzu> type Lens'      a b = forall f . Functor     f => (b -> f b) -> (a -> f a)
12:51:38 <suzu> all applicatives are functors.. so why aren't all traversal's lens's ?
12:51:51 <suzu> though all lens's are traversal's ?
12:51:55 <hpc> it probably has to do with being a rank-2 type
12:52:10 <cocreature> suzu: the type of the lens means that _to implement_ the lens you can make use of the fact that f is a Functor and only that
12:52:16 <dmwit> suzu: You hand me something that demands `Applicative f`. I only promise `Functor f`. Therefore I can't use your thing.
12:52:23 <cocreature> for an applicative you can make use of the fact that it’s an Applicative
12:52:43 <cocreature> so the implementation of a traversal is allowed to do more with f than a lens is allowed
12:52:52 <metahumor> suzu: you can use all Lens' as Traversal'.
12:53:07 <suzu> right. why does it work in that direction and now all Traversal' as Lens' ?
12:53:11 <suzu> not all *
12:53:21 <suzu> if something needs a functor and i give it an applicative, it should be happy with that
12:53:26 <dmwit> I like cocreature's explanation better than mine.
12:53:34 <ReinH> suzu: If I can use all applicatives as functors, why can't I use all functors as applicatives?
12:53:43 <metahumor> its not about what it needs, cocreature explains it well, its about what it provides
12:53:44 <dibblego> if you have (0 or many) things, you do not have (definitely 1) thing, but if you have (definitely 1) thing, you do have (0 or many) things
12:53:59 <dibblego> as a loose intuition for traversal and lens
12:54:14 <suzu> ohhh its not what it needs but what it provides to view/set/over
12:54:51 <suzu> so anything that can take a lens' can take a traversal' because making a lens' needs a functor
12:55:08 <suzu> err nope i mean that backwards *
12:56:45 <dmwit> suzu: You may also like: "Why can a Num act like a Fractional?" https://stackoverflow.com/q/42820603/791604
12:57:09 <tdammers> all dogs are animals, but not all animals are dogs
12:58:23 <metahumor> the "X is a Y, but not all Y is X" explanation is not sufficient, because it doesn't take into account whether we need a "X" or "Y" covariantly or contravariantly
12:58:36 <suzu> what is covariant / contravariant?
12:58:36 * hackage wai-logger-buffered 0.1.0.0 - A small library for performing buffered request logging rather than in-line logging  https://hackage.haskell.org/package/wai-logger-buffered-0.1.0.0 (ChrisCoffey)
12:58:37 <mnoonan> ^ ++
12:59:03 <dmwit> suzu: (You may like it because I give there a mechanical way to look at a type and answer the kind of question you asked. But you have to remember that "Why can't I use a traversal as a lens?" means you have to put the Lens' type as a function argument and use the Traversal' type as the argument being supplied.)
12:59:37 * hackage wai-logger-buffered 0.1.0.1 - Buffer requets before logging them  https://hackage.haskell.org/package/wai-logger-buffered-0.1.0.1 (ChrisCoffey)
12:59:38 <suzu> reading it now
12:59:41 <metahumor> covariant means that if we have a function "f x = y", we are alright with getting a "z" back if "z is a subset of possible y values"
12:59:47 <ReinH> dmwit: I literally just now realized that you are Daniel Wagner.
13:00:03 <mnoonan> suzu: Cat -> Cat can be given a Lion, and the return value can be used like an Animal, but not the other way around
13:00:34 <dmwit> suzu: Re: "what is covariant/contravariant"? You may like "Lifting a higher order function in Haskell". There I use the terms "positive position" and "negative position" instead of covariant and contravariant, respectively. https://stackoverflow.com/a/9243982/791604
13:00:51 <mnoonan> one of those is covariant, the other is contravariant, and which is which depends on how you like to draw your lattices :)
13:00:51 <dmwit> ReinH: Hi!
13:01:59 <dmwit> Oh, I actually do use the terms covariant and contravariant. =)
13:02:48 <suzu> ReinH: i understand that but that is in the wrong direction
13:03:11 <ReinH> suzu: Is it?
13:03:17 <suzu> you can use applicatives as functors but can't use all functors as applicatives, that makes sense
13:03:30 <suzu> if a traversal uses applicative, why can't it be used as a lens when lens only needs functor?
13:04:03 <ReinH> Once you've established that x < y, it can't also be true that x >= y
13:04:07 <dmwit> suzu: Because "used" means "function argument", and function argument subtyping is backwards from what you might guess.
13:04:12 <mnoonan> suzu: suppose the traversal was defined using <*> or pure..
13:04:44 <sssilver> ReinH: that depends on your definition of <, >, and =
13:05:05 <suzu> function argument subtyping is backwards?
13:05:07 <dmwit> suzu: Or, using mnoonan's example: all lions are cats. Why can't I give a cat to a function expecting a lion?
13:05:09 <metahumor> A Traversal' might "use" Applicative as you expect, but if "view" expects a Lens', "view" might not allow for "pure, <*>" to be used in the "lens-like" that you are "view"-ing through
13:05:33 <sssilver> I can easily imagine a system where x < y is equivalent to x > y
13:05:43 <suzu> i understand all of your analogies but fail to understand what is wrong with my logic here
13:06:46 <suzu> i will read this SO answer first and maybe that'll solve the puzzle for me
13:06:58 <ReinH> Sure, and I can imagine a system where false = true.
13:07:00 <dmwit> suzu: In your terms: all applicatives are functors. Why can't I give an applicative to a function expecting a functor?
13:07:13 <suzu> you should be able to
13:07:18 <metahumor> nop
13:07:20 <dmwit> suzu: So there you have the analogy and your question side by side, literally just replacing "lion" with "applicative" and "cat" with "functor".
13:07:29 <sssilver> ReinH: sure
13:07:35 <dmwit> suzu: If the lion/cat analogy makes sense, the applicative/functor one should, too.
13:07:36 <suzu> you can't give an applicative to a function that wants a functor?
13:07:58 <ReinH> In this case, we have an actual poset, and <= does what you expect.
13:08:00 <dmwit> suzu: Ah! So there's another wrinkle.
13:08:19 <suzu> but if all applicatives are functors then you should be able to satisfy something that wants a functor by providing an applicative
13:08:21 <dmwit> suzu: There's a difference between `foo :: Functor f => f a -> b` and `foo :: (Functor f => f a) -> b`.
13:08:30 <suzu> if all lions are cats then you can use a lion in place of a cat
13:08:37 * hackage fast-arithmetic 0.3.2.0 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.3.2.0 (vmchale)
13:08:39 <mnoonan> dmwit: yeah, I think that's the big co/contra flip here
13:08:46 <suzu> oh hm
13:08:49 <dmwit> suzu: The latter should more correctly be written `foo :: (forall f. Functor f => f a) -> b`.
13:08:57 <metahumor> how would I give a number that has a fractional part to a function expecting whole numbers? yes, there are some numbers with a fractional part of "0" that can count as whole numbers, but not "forall numbers"
13:09:10 <suzu> okay so i am misunderstanding what this function is asking for i see
13:09:32 <dmwit> suzu: (And indeed the type aliases for `Lens'` and `Traversal'` do include this extra `forall`.)
13:10:57 <metahumor> more simply, a Traversal' can only be used to view things that are _at least_ Applicative
13:11:13 <metahumor> while a Lens' can be used to view things that are _at least_ Functor
13:11:45 <metahumor> where "_at least_" means, are instances of
13:12:25 <metahumor> then, we can see why we can use a Lens' as a Traversal', because all things that are instances of Applicative are also instances of Functor
13:20:07 * hackage impure-containers 0.4.2 - Mutable containers in haskell  https://hackage.haskell.org/package/impure-containers-0.4.2 (andrewthad)
13:29:37 * hackage unit 0.1.0.1 - Aliases for `()`.  https://hackage.haskell.org/package/unit-0.1.0.1 (amohrland)
13:30:22 <suzu> ok i read the SO links dmwit posted
13:30:25 <suzu> i now understand everything
13:30:27 <suzu> :)
13:30:50 <albatross__> hey guys, I don't get why would the argument for f' would read as [Int] instead of Int http://lpaste.net/361670
13:30:54 <dmwit> suzu: \o/
13:31:05 <Gregor01> Is there any rule of thumb how many threads I can effectively use in Haskell under Linux?
13:31:18 <Gregor01> Because I get the warning "Using large values for -N is not allowed by default."
13:31:37 <Gregor01> I was thinking about using 32 or 90 threads..
13:31:46 <dmwit> albatross__: again: `(x:y)` binds `x` to the head of the list (an `Int`) and `y` to the tail (an `[Int]`).
13:31:58 <hpc> Gregor01: the value of -N is the number of OS threads to use
13:32:11 <hpc> the practical upper limit is your computer's number of processing units
13:32:16 <dmwit> albatross__: Perhaps, as before, you meant `x:y:[]` or its alternate spelling `[x,y]`.
13:32:21 <hydraz> Gregor01: use $(nproc)
13:32:23 <nshepperd_> You can use a lion in place of a cat, but you can't use a cage that can hold any lion as a cage that can hold any cat
13:32:49 <albatross__> dmwit (x:y) is not the same as x:y:[] ??
13:32:56 <suzu> it is not the same
13:32:58 <dmwit> albatross__: Absolutely not.
13:33:01 <nshepperd_> (but a cage that can hold any cat can hold any lion)
13:33:12 <Gregor01> Okay, thanks!
13:33:23 <dmwit> albatross__: Or: what did you think was happening with `x:y:xs`?
13:33:31 <metahumor> albatross__: What is the type of the function "(:)"?
13:33:56 <albatross__> a -> [a] -> [a]
13:34:19 <metahumor> that is why "x:y" will think of "y :: [a]"
13:34:30 <albatross__> ah
13:34:35 <albatross__> thanks guys!!!!!
13:35:41 <albatross__> you guys are da best!
13:36:14 <metahumor> albatross__: can I ask what you expect "f'" to do?
13:37:24 <dmwit> Put stars at specific positions in a string, I would guess.
13:37:35 <albatross__> metahumor, with respect to f, f' suppose to give me a string that has the appropriate spaces inserted. for example [2,3] = "   **"
13:37:51 <albatross__> yeah, dmwit you are right
13:38:19 <metahumor> woah
13:38:45 <dmwit> I suspect there's a fun bug with your `f' [x] = f x` case.
13:38:52 <albatross__> yeah there is....
13:38:58 <albatross__> i'm trying to figure it out
13:39:50 <metahumor> =) others might disagree, but i'd suggesting getting your base cases working first, even if that means "f'" is a partial function while you're debugging it
13:41:50 <albatross__> umhmm, thx metahumor
13:42:28 <dmwit> Actually, as a base case, `f' [x] = f x` is fine.
13:43:08 <albatross__> dmwit, but...?? i'm expecting a big but
13:43:14 <hpc> just don't write "f [x] = f x" ;)
13:43:26 <dmwit> But... another of your base cases is wrong. =)
13:43:39 <dmwit> I was simply wrong to point at `f' [x] = f x` as the problem.
13:48:31 <dmwit> > liftA2 (zipWith (\oldx newx -> newx-oldx-1)) (0:) id [5,10,13,14]
13:48:32 <glguy> Does this given example have an extra space in it? [2,3] = "   **"
13:48:35 <lambdabot>  [4,4,2,0]
13:49:02 <metahumor> i think we're all getting nerdsniped
13:50:26 <albatross__> i feel like i'm so close.. but i'm just not getting it
14:49:31 <xacktm> what do you recommend for text interpolation?  I found Text.Printf, Text.Format, and Text.Format.Simple
14:51:41 <Tritlo> xacktm: I ususally use Text.Printf it's pretty good and you probably already know how it works :)
14:52:58 <xacktm> I don't actually :P  I know how C's printf works though, so most knowledge should map over.  And another plus is that it's in base
14:53:18 <michi7x7> Text.Printf is nice
14:53:46 <monochrom> Text.Printf has similar format strings as C's printf. There are differences too of course.
14:54:31 <xacktm> my use case is constructing a JSON to send over HTTP, with needing newline and quote escaping, does printf supports that as well?
14:54:43 <xacktm> sorry for my horrible english heh
14:54:47 <monochrom> > printf "%d %s\n" 42 "hello" :: String
14:54:50 <lambdabot>  "42 hello\n"
14:55:13 <monochrom> That example is what C's sprintf dreams to be but fails to achieve.
14:55:31 <monochrom> Now if you change ":: String" to ":: IO ()" you will get it sent to stdout.
14:55:36 <int-e> > printf "%d %s\n" "hello" 42 :: String
14:55:39 <lambdabot>  "*Exception: printf: bad formatting char 'd'
14:55:45 <int-e> (it's not perfect)
14:55:48 <monochrom> And that's what Perl's printf dreams to be but fails to achieve :)
14:56:12 <monochrom> Yeah it checks parameter types at run time, but at least checked.
14:56:36 <michi7x7> xacktm: why don't you use a JSON-library then?
14:56:39 <monochrom> Or actually the other way round, eh? The types are known statically. It checks the format string at run time.
14:56:48 <int-e> monochrom: exactly
14:56:54 <monochrom> But yeah for JSON just use aeson.
14:57:24 <xacktm> ah didnt think about that, might do
14:57:38 <xacktm> mainly because I didn't realize aeson let me construct JSON
14:57:44 * xacktm takes a look
14:58:00 <monochrom> Heh heh heh aeson is easier said than done. But I think it's worth learning.
14:59:07 <xacktm> I've banged my head against it for decoding, it was steep but really nice when I got my record parsed
14:59:35 <xacktm> now it seems I'll have to do it for encoding
15:07:32 <xacktm> aeson supports escaping the escape characters right?  e.g. \n to \\n, \" to \\\" ?
15:10:53 <monochrom> Yes.
15:10:54 <dmwit> xacktm: If you control the JSON schema, deriving encoders and decoders for your data structures should only be 1-2 lines of code per structure.
15:11:12 <dmwit> xacktm: If not, it's a bit more work; but usually not much more than 2-3 extra lines per field in your record.
15:11:29 <monochrom> I actually handwrite my own FromJSON and ToJSON instances. It is pretty easy for me.
15:11:42 <dmwit> xacktm: And yes, escaping of string-y types is done automatically.
15:11:48 <monochrom> And also because usually I can't choose the schema.
15:12:17 <dmwit> monochrom: Does your experience match mine in terms of LoC?
15:12:59 <dmwit> (I've only used aeson a handful of times, and it sounds like you have more experience, so it might be nice to hear a second opinion.)
15:13:02 <monochrom> Oh it is not 1-2 lines per type, but it is 1-2 lines per field, which is the best we could ask for for handwriting.
15:13:28 <monochrom> I just learned from the examples in the doc.
15:15:07 <monochrom> data X = X{a, b :: Int} ...  parse obj = X <$> obj .: "a" <*> obj .: "b" ...
15:15:30 <monochrom> I may be misremembering the exact name for .:
15:16:09 <monochrom> I actually didn't bother to learn the two auto-derive stories!
15:16:54 <monochrom> OTOH even the auto-derive stories are greatly customizable.
15:26:34 <xacktm> (was afk) thanks! I couldn't find that point in the docs
15:27:30 <monochrom> In the doc of Data.Aeson there is a section "Writing instances by hand".
15:32:17 <koala_man> I have a test.hs with `main = putStrLn "Hello World`  and compiled it with  `ghc --make test.hs -optl-static -optl-pthread`. The static executable segfaults in the Docker image ubuntu:14.04. Any tips for figuring out why?
15:33:45 <monochrom> glibc is not so easy to statically link. Short story: requires exact version match between build time and run time.
15:34:04 <koala_man> really. why?
15:35:01 <koala_man> interestingly, the executable works fine under ubuntu 14.04, just not in the ubuntu:14.04 docker image
15:35:40 <monochrom> Long story: Even when statically linked, glibc still needs dlopen to load libraries for getpasswdent etc because it is how the "same" getpasswdent function works regardless of whether the computer happens to use the traditional unix user-password system or it's LDAP or...
15:36:55 <monochrom> Conclusion: Ironically, static linking for glibc makes your exe less portable, not more.
15:37:51 <monochrom> This goes against most people's intuition of "I want my exe to work on maximumly many systems, ah I know, I'll use static linking".
15:38:01 <monochrom> This is an XY^-1 problem. :)
15:38:30 <EvanR> XY^-1 = Y^-1 X^-1 ?
15:39:01 <monochrom> X (Y^-1)
15:44:43 <koala_man> monochrom: the program works fine if I delete glibc. can I do anything to make it not try to do any of that?
15:45:30 <monochrom> I don't know. Probably very hard.
15:53:44 <koala_man> monochrom: welp, I kludged it with  >libc.so.6; LD_LIBRARY_PATH=. ./exec
15:57:36 * hackage serverless-haskell 0.2.0 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.2.0 (AlexeyKotlyarov)
15:58:42 <siwica> Is there a way in GHCI to trace a type synonym back to the individual data constructors?
16:00:27 <siwica> Espeacially in libraries I'd like to quickly know what a particular type is built off...
16:00:36 <dmwit> :info will go one step.
16:00:56 <dmwit> % :info String
16:00:56 <yahb> dmwit: type String = [Char] -- Defined in `GHC.Base'
16:02:46 <jramsay> I'm working on implementing a bottom up natural merge sort for Mutable Vectors, and running into errors like `Couldn't match expected type ‘Int’ with actual type ‘m4 Int’` which relate to PrimState. I've read the PrimMonad and PrimState documentation but am struggling to get my head around how to apply it. I initially implemented the algorithm with Unboxed Vectors, but then thought it would be fun to experiment/learn about
16:02:46 <jramsay>  Mutable Vectors but got stuck when I started glueing functions together. If anyone is willing and able to help, I'd be very thankful
16:09:23 <dmwit> jramsay: You're gonna need to show some code. Minimal (as little code as possible), complete (we should be able to copy-paste and try it ourselves), reproducing (should show the error you're trying to fix)
16:10:03 <dmwit> ?lpaste is a nice pastebin if you're looking for one (don't paste code directly in-channel)
16:10:04 <lambdabot> Haskell pastebin: http://lpaste.net/
16:10:52 <ReinH> @where mcve
16:10:53 <lambdabot> I know nothing about mcve.
16:10:55 <ReinH> worth a shot
16:11:20 <jramsay> dmwit: here's the file ~100 lines but I can cut it down to something smaller http://lpaste.net/3138545869788282880
16:11:37 <jramsay> dmwit: and thank you :)
16:12:01 <dmwit> Oh, don't get me wrong: I'm not saying I'll help you. Just stating preconditions for getting help. =P
16:12:53 <jramsay> Haha, well thanks for replying and helping me get help at :P
16:15:46 <Gregor01> I would have a question...
16:16:00 <Gregor01> mat = [[1,2,3,4],[5,6,7,8],[11,12,13,14]]
16:16:06 <Gregor01> res = [[(1,6),(2,7),(3,8)],[(5,12),(6,13),(7,14)]]
16:16:32 <Gregor01> how do I get from mat to res? It's the top right and top left corners of the sub matrices.
16:16:46 <Gregor01> (top right and lower left; typo)
16:16:50 <dmwit> jramsay: I think you just need to bind more things.
16:17:12 <dmwit> jramsay: e.g. `do { l_t_val <- l_t; cmerge ... l_t_val ...; growSorted ... }`.
16:17:19 <dmwit> jramsay: Similarly for your other monadic actions.
16:19:45 <dmwit> > map init . init $ [[1..4],[5..8],[11..14]]
16:19:48 <lambdabot>  [[1,2,3],[5,6,7]]
16:19:59 <dmwit> > map tail . tail $ [[1..4],[5..8],[11..14]]
16:20:02 <lambdabot>  [[6,7,8],[12,13,14]]
16:27:51 <jramsay> dmwit: thanks for putting me on the right track. That's got me unstuck!
16:31:52 <ReinH> :t chunksOf
16:31:54 <lambdabot> Int -> [e] -> [[e]]
16:39:45 <ReinH> > map (xs -> \(head xs, last xs) . map concat . concat . map transpose . divvy 2 1 . map (divvy 3 1) $ [[1,2,3,4],[5,6,7,8],[11,12,13,14]]
16:39:48 <lambdabot>  <hint>:1:14: error: Parse error in pattern: head
16:39:50 <ReinH> > map (xs -> \(head xs, last xs)) . map concat . concat . map transpose . divvy 2 1 . map (divvy 3 1) $ [[1,2,3,4],[5,6,7,8],[11,12,13,14]]
16:39:54 <lambdabot>  <hint>:1:14: error: Parse error in pattern: head
16:40:04 <ReinH> fine
16:40:05 <ReinH> > map concat . concat . map transpose . divvy 2 1 . map (divvy 3 1) $ [[1,2,3,4],[5,6,7,8],[11,12,13,14]]
16:40:09 <lambdabot>  [[1,2,3,5,6,7],[2,3,4,6,7,8],[5,6,7,11,12,13],[6,7,8,12,13,14]]
16:40:09 <hydraz> it's \xs -> (head xs, last xs)
16:40:14 <ReinH> There are the element of the sub-matrices
16:40:32 <ReinH> > map (\xs -> (head xs, last xs)) . map concat . concat . map transpose . divvy 2 1 . map (divvy 3 1) $ [[1,2,3,4],[5,6,7,8],[11,12,13,14]]
16:40:36 <lambdabot>  [(1,7),(2,8),(5,13),(6,14)]
16:40:42 <ReinH> hydraz: thanks, I don't know what my fingers were thinking
16:40:45 <ReinH> oh that's not quite right.
16:40:54 <ReinH> Maybe I don't know what you mean by 'sub-matrices'.
16:41:30 <ReinH> changing the arguments to the divvies might be what you want
16:41:48 <ReinH> > map (\xs -> (head xs, last xs)) . map concat . concat . map transpose . divvy 2 1 . map (divvy 2 1) $ [[1,2,3,4],[5,6,7,8],[11,12,13,14]]
16:41:52 <lambdabot>  [(1,6),(2,7),(3,8),(5,12),(6,13),(7,14)]
16:41:54 <Gurkenglas> > let mat = [[1,2,3,4],[5,6,7,8],[11,12,13,14]] in zipWith (\x y -> zip (init x) (tail y)) mat (tail mat)
16:41:58 <lambdabot>  [[(1,6),(2,7),(3,8)],[(5,12),(6,13),(7,14)]]
16:42:01 <ReinH> That seems right.
16:42:27 <ReinH> Gurkenglas: Ok, now do a different sized matrix.
16:43:03 <Gurkenglas> As long as it's 2D, this'll get the \-pairs
16:43:17 <Gurkenglas> > let mat = [[1,2],[3,4]] in zipWith (\x y -> zip (init x) (tail y)) mat (tail mat)
16:43:22 <lambdabot>  [[(1,4)]]
16:43:55 <ReinH> sure
16:43:58 <Gurkenglas> > let mat = [[x..x+3] | x <- [0,10..100]] in zipWith (\x y -> zip (init x) (tail y)) mat (tail mat)
16:44:02 <lambdabot>  [[(0,11),(1,12),(2,13)],[(10,21),(11,22),(12,23)],[(20,31),(21,32),(22,33)],...
16:44:51 <jmcarthur> I decided to try c2hsc, and now I really wish I had a lot more memory on this machine
16:45:06 <ReinH> Gurkenglas: I stole mine from Richard Bird anyway.
16:45:30 <jmcarthur> It generated a single very reasonable looking hsc file which needs more memory than I have to compile.
16:46:22 <Gurkenglas> I don't even know whether you're disagreeing with me at this point. What does Gregor01 mean by top right and top left corners of sub matrices?
16:47:13 <ReinH> Gurkenglas: I don't think I was ever disagreeing with you.
16:47:35 <ReinH> I just meant to mention that yours doesn't generalize to other shapes of sub-matrix.
16:47:47 <Gurkenglas> What do you mean by shapes of sub-matrix?
16:48:14 <ReinH> This is, apparently, "print all 2x2 sub-matrices".
16:48:46 <ReinH> Mine works for any NxM <= the dimensions of the matrix
16:50:04 <Gurkenglas> Ah, then it should of course be flattened.
16:53:05 <ReinH> or, rather, print their corners, which is easy once you have the whole sub-matrix.
16:53:40 <Gregor01> ReinH: yes it was print the corners and I was away a few minutes...
16:55:06 <dmwit> ?let top = init; bottom = tail; left = map init; right = map tail
16:55:08 <lambdabot>  Defined.
16:55:27 <dmwit> > top . left $ [[1..4],[5..8],[9..12]]
16:55:31 <lambdabot>  error:
16:55:32 <lambdabot>      Ambiguous occurrence ‘left’
16:55:32 <lambdabot>      It could refer to either ‘Control.Arrow.left’,
16:55:35 <ReinH> wah wah
16:55:42 <dmwit> sad trombone
16:55:46 <dmwit> ?undefine
16:55:46 <lambdabot> Undefined.
16:56:27 <ReinH> dmwit: I used the trick from Bird's sudoku solver.
16:56:48 * dmwit makes a note on his pad of paper
16:56:59 <ReinH> (http://www.cs.tufts.edu/~nr/cs257/archive/richard-bird/sudoku.pdf)
17:01:38 <Gregor01> Gurkenglas: Thank you very, very much!
17:12:14 <aplainzetakind> What should I use to save my data in a file to be able to exactly recover it without parsing considerations? (The data type consists of quite a few strings of unknown length).
17:13:28 <Gregor01> @aplainzetakind how large is the data? Have you tried show + writeFile and readFile + read?
17:13:28 <lambdabot> Unknown command, try @list
17:13:59 <Gregor01> You can always searealize with the Cbor package
17:14:15 <EvanR> > show (Just [Just False, Nothing, Just True])
17:14:17 <Gregor01> (and also deseralize later)
17:14:17 <aplainzetakind> My data isn't here yet, I'm preparing to scrape a few thousand most frequent words from a dictionary.
17:14:18 <lambdabot>  "Just [Just False,Nothing,Just True]"
17:14:39 <EvanR> > read "Just [Just False,Nothing,Just True]" :: Maybe [Maybe Bool]
17:14:42 <lambdabot>  Just [Just False,Nothing,Just True]
17:14:52 <Gregor01> As long as you don use String and don't use Lists you are fine
17:15:09 <EvanR> i think thats going a little far
17:15:12 <Gregor01> Use Vector instead of LIsts and use strict Bytestring instead of String
17:15:35 <EvanR> using vector instead of list in all cases will surely make things work in some of them
17:15:44 <dmwit> Uh. Use ByteString if you are dealing with bytes. Use Text if you are dealing with text.
17:15:46 <aplainzetakind> It's a sum type of two Strings and three [String]s
17:15:51 <Gregor01> You can also use lazy Bytestrings as a start
17:15:57 <aplainzetakind> OK, I'll look into bytestrings.
17:16:09 <aplainzetakind> But aren't vectors of predetermined length?
17:16:09 <dmwit> ByteString is not a replacement for String.
17:16:29 <EvanR> vector is not a replacement for list
17:17:13 <Gregor01> https://github.com/well-typed/cborg/blob/master/serialise/src/Codec/Serialise.hs
17:17:23 <Gregor01> use serialize and deserialize, try that maybe
17:17:43 <Gregor01> combine that with writeFile/readFile or similar
17:18:13 <Gregor01> If you program is slow or users a lot of mem, avoid lists at all cost
17:25:08 <parsnip> 10.3 refers to a version of what exactly? i see it has stack 1.6.3, ghc 8.2.2, ...
17:26:08 <dmwit> E_NOCONTEXT
17:26:15 <parsnip> stackage curations?
17:26:54 <parsnip> # stack.yaml\nresolver: lts-10.0
17:27:37 <dmwit> I think "lts-10.0" is all part of the version number.
17:28:47 <parsnip> i guess it's a "stackage release" or in my words, a curated set of packages.
17:28:56 <dmwit> I think that's right.
17:29:22 <dmwit> I think a stackage release also includes a curated version of GHC, not just a curated set of packages.
17:29:39 <parsnip> i agree
17:29:57 <dmwit> Dunno if there are any other tools (besides ones built from packages) whose versions are pinned by a stackage release, but probably not?
17:31:22 <parsnip> that seems to sum up all the info i see on a page like https://www.stackage.org/lts-10.3
17:31:53 <parsnip> not that i've exhausted my web browsing
17:36:18 <MarcelineVQ> you don't have to guess what things are in your stack.yaml though, there's a manual   https://docs.haskellstack.org/en/stable/GUIDE/     https://docs.haskellstack.org/en/stable/yaml_configuration/    https://docs.haskellstack.org/en/stable/yaml_configuration/#resolver
17:36:27 <ReinH> An lts release doesn't pin a version of stack, in case that was unclear
17:36:46 <parsnip> ReinH: yeah, i was just thinking that.
17:37:17 <ReinH> It pins the GHC version and the versions of all packages in the release.
17:37:32 <parsnip> i mean, that i can have whatever stack version, and then all the cpu and disk space of building is about not picking an inconsistent stackage release.
17:37:46 <parsnip> say if i have a docker with one lts, and i stupidly put another one in stack.yaml
17:37:56 <ReinH> I don't see how you could do that.
17:38:09 <ReinH> The stack.yaml goes with the package
17:38:43 <parsnip> docker pull an image with lts 10.3 (FROM), then in project mounted, put stack.yaml with 10.0.
17:39:08 <parsnip> i think i did that yesterday, and that was when i said, "okay stop, what am i doing?"
17:39:20 <parsnip> i think that was my problem anyways, still researching.
17:40:46 <parsnip> ah, dmwit "A snapshot defines a GHC version, a number of packages available for installation, and various settings like build flags. "
17:40:50 <parsnip> MarcelineVQ: thanks
17:40:59 <MarcelineVQ> there's not a lot of time/space loss rebuilding things between 10.0 and 10.3 luckily    https://www.stackage.org/diff/lts-10.0/lts-10.3
17:41:27 <parsnip> well, when it started in with it's 0/122, i was not happy
17:42:34 <kadoban> parsnip: If you've already used a bunch of stuff from one, most of those should end up being "using precompiled package" or whatever it calls it. You'd probably have to be using more than every package in the whole resolver for it to need to actually rebuild that much.
17:42:37 <MarcelineVQ> when you switch to 10.3 it doesn't neccesarily build 122 of them though, it depends what it can find that's shared, assuming it's alreadfy built for 10.0
17:45:46 <MarcelineVQ> you've been dealing with memory constraints as I recall so it's an uphill battle, neither stack or ghc are particularily carefulabout hardware limitations, and I've no idea about how things go with docker, with or without stack's docker commands
17:46:36 <MarcelineVQ> is your plan to build in a container so you can avoid rebuilding between platforms?
17:46:54 <parsnip> "plan"
17:46:56 <parsnip> ha
17:47:13 <parsnip> if i tried to say, i'd be thinking out loud
17:48:21 <parsnip> i want a build environment for linux executable in one docker image. preferably built on a hub for me, so i don't have to rely on my laptop sitting somewhere if i come back to this after a long time. (i routinely have to delete stuff for small hard drive.)
17:48:55 <parsnip> then i think i would docker pull that, and build a linux executable from my own Main.hs etc.
17:49:25 <parsnip> i could possibly then make a think docker image with just the linux executable for pushing around onto server.
17:49:32 <parsnip> s/think/thin/
17:49:58 <parsnip> i did this before for hledger-web, but i wasn't actually hacking on the source, now i'd like to write some simple yesod apps.
17:50:19 <parsnip> i just did all that to have an hledger-web newer than what ubuntu provided.
17:52:01 <parsnip> here's how making a thin docker image worked: https://github.com/bradyt/docker-hledger-bin/blob/master/Dockerfile
17:53:36 <dukedave> Does anyone want to be a hero and tell us why this build is failing? https://travis-ci.org/LumiGuide/haskell-opencv
17:55:27 <kadoban> dukedave: At least looks a lot like you're compiling C++ as C or some really old C++ standard. It looks to be complaining about a lot of c++11 stuff.
17:57:11 <dukedave> kadoban: yer, that's about as far as I got. I figure that's what the -std=c++11 switches are supposed to do, but for some reason it's not respecting them?  https://github.com/LumiGuide/haskell-opencv/blob/master/opencv-extra/opencv-extra.cabal
18:03:25 <kadoban> dukedave: Just according to the output, something seems to be passing -std=gnu99, which is kind of nonsense for C++. It does appear to be treating it as C++, just ... really old though.
18:18:36 * hackage serverless-haskell 0.2.1 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.2.1 (AlexeyKotlyarov)
18:19:23 <dukedave> kadoban: oh yeah. No mention of gnu99 in the repo though. I wonder if it's a default?
18:30:04 <dukedave> Could this be a problem? https://github.com/dukedave/haskell-opencv/blob/master/opencv-extra/Setup.hs
18:44:01 <alphonse23_> I know this is a long shot, but is anybody familiar with the long(string, int) function in python? https://docs.python.org/2/library/functions.html#long
18:44:16 <alphonse23_> I'm looking for the equivalent in haskell
18:44:42 <alphonse23_> it does something like this: >>> long("f91cd7b06de40032a8fe566c256815475726475300a11323e578e72198838db0", 16)
18:44:42 <alphonse23_> 112676859647035132725551788130126914255437757243500873207572087076564926434736L
18:44:57 <alphonse23_> takes in a string in a particular base, and returns it as a long integer
18:49:18 <alphonse23_> maybe what I'm looking for is a way to convert a base 16 to a integer type
18:49:24 <alphonse23_> in base 10
18:49:29 <alphonse23_> oh well, I should be able to find that
18:51:02 <verement> > let long s b = foldl (\t c -> t * b + fromIntegral (digitToInt c)) (0 :: Integer) s in long "f91cd7b06de40032a8fe566c256815475726475300a11323e578e72198838db0" 16
18:51:04 <lambdabot>  112676859647035132725551788130126914255437757243500873207572087076564926434736
18:52:33 <verement> Data.Char.digitToInt will work for bases up to 16
18:52:41 <alphonse23_> cool
18:52:46 <alphonse23_> but how about this? http://hackage.haskell.org/package/text-1.2.3.0/docs/Data-Text-Lazy-Read.html#v:hexadecimal
18:52:49 <alphonse23_> already in a package
18:56:50 <glguy> > "f91cd7b06de40032a8fe566c256815475726475300a11323e578e72198838db0" ^? base 16
18:56:53 <lambdabot>  Just 11267685964703513272555178813012691425543775724350087320757208707656492...
18:57:23 <glguy> > readHex "f91cd7b06de40032a8fe566c256815475726475300a11323e578e72198838db0"
18:57:26 <lambdabot>  [(11267685964703513272555178813012691425543775724350087320757208707656492643...
18:58:07 * hackage dbus 0.10.15 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-0.10.15 (blaze)
18:58:12 <glguy> > readInt 16 isHexDigit digitToInt "f91cd7b06de40032a8fe566c256815475726475300a11323e578e72198838db0"
18:58:16 <lambdabot>  [(11267685964703513272555178813012691425543775724350087320757208707656492643...
19:05:22 <redrapscallion> i'm looking at a certain library, and there's a function that takes in a "Url", but the Url type is just "type Url = String". Aside from having a better descriptor of what the String is, is there really any point to defining types like this?
19:05:52 <alphonse23_> for sure the Numeric package was the fastest way, readHex was perfect, thanks glguy and verement
19:07:49 <redrapscallion> or to rephrase that more coherently, are type synonyms only useful for giving the programmer hints about what the data type is? (eg; if it's a String, what that String represents?)
19:08:10 <redrapscallion> or do they have some sort of other use that i'm not seeing?
19:08:14 <Rembane> redrapscallion: They are useful for hints and for making long types shorter.
19:08:21 <Rembane> redrapscallion: But in your case only for documentation.
19:08:46 <Rembane> redrapscallion: If you want some type safety you could wrap it in a newtype instead. But that won't help you now. :)
19:08:50 <misty5> Rembane: hey
19:08:52 <misty5> redrapscallion: hey
19:08:55 <misty5> alphonse23_: hey
19:09:23 <Rembane> misty5: What can I do for you?
19:09:36 <misty5> Rembane: guess what
19:10:18 <redrapscallion> misty5: oh hi
19:10:47 <parsnip> lol, tor-sasl
19:11:22 <misty5> redrapscallion: guess what
19:11:55 <parsnip> my guess is, you're talking to us across tor.
19:12:00 <parsnip> amirite?
19:12:22 <parsnip> much secure
19:12:56 <misty5> parsnip: nope, guess what
19:13:13 <parsnip> misty5: i give up then. what?
19:13:42 <parsnip> seven?
19:14:12 <Rembane> parsnip: You made it go away. Thank you.
19:14:58 <parsnip> i thought for sure i was going to provoke a deluge of spam.
19:15:32 <Rembane> Me too.
19:15:39 <redrapscallion> misty5 is a bot?
19:15:48 <Rembane> Or a rascal
19:16:59 <alphonse23_> hey guys, another really basic question, the readHex function returns a Text.ParserCombinators.ReadS in this form: [(112676859647035132725551788130126914255437757243500873207572087076564926434736,"")]
19:17:28 <alphonse23_> how do I get the first element, as in the integer, from the pair?
19:17:47 <redrapscallion> i think fst is what you're looking for
19:18:23 <vaibhavsagar> alphonse23_: missed your earlier message, but is `fst` what you want?
19:18:23 <redrapscallion> wait, nvm, it's wrapped in an array
19:18:30 <vaibhavsagar> > fst (1,2)
19:18:33 <lambdabot>  1
19:18:38 <alphonse23_> doesn't do it though
19:18:49 <Rembane> fst . head
19:18:52 <redrapscallion> fst $ head [(2, ""])
19:18:53 <alphonse23_> Couldn't match expected type ‘a -> (c, b0)’
19:18:53 <alphonse23_>                   with actual type ‘[(Integer, String)]’
19:19:13 <redrapscallion> fst $ head [(2, "")]
19:19:22 <alphonse23_> fst $ head $ readHex "f91cd7b06de40032a8fe566c256815475726475300a11323e578e72198838db0"
19:19:25 <alphonse23_> okay there we go
19:19:26 <alphonse23_> thanks guys
19:19:56 <alphonse23_> I always get mixed up with . (compose) and $
19:20:44 <redrapscallion> didn't there used to be a bot in this channel that would automatically parse valid Haskell expressions?
19:21:01 <Rembane> > 1+1
19:21:04 <lambdabot>  2
19:21:28 <Rembane> > "Hi, my name is lambdabot and I know a bit of Haskell."
19:21:31 <lambdabot>  "Hi, my name is lambdabot and I know a bit of Haskell."
19:21:34 <Rembane> :D
19:21:43 <redrapscallion> Rembane: is lambdabot *your* bot, or is that a channel-wide bot?
19:21:58 <Rembane> redrapscallion: It's a channel wide bot.
19:22:15 <redrapscallion> how come my expression before didn't work? it worked fine in ghci
19:22:36 <Rembane> redrapscallion: [(]) won't lex.
19:22:54 <Rembane> redrapscallion: And you need to add > at the beginning of the line
19:23:46 <Axman6> > test . show $ 2^512
19:23:49 <lambdabot>  error:
19:23:49 <lambdabot>      • Variable not in scope: test :: String -> c
19:23:49 <lambdabot>      • Perhaps you meant one of these:
19:24:09 <Axman6> > text . show $ 2^512
19:24:12 <lambdabot>  1340780792994259709957402499820584612747936582059239337772356144372176403007...
19:24:55 <redrapscallion> fst (2, 4)
19:25:00 <redrapscallion> >fst (2, 4)
19:25:05 <verement> > let [(n, "")] = readHex "f91cd7b06de40032a8fe566c256815475726475300a11323e578e72198838db0" in n
19:25:09 <lambdabot>  112676859647035132725551788130126914255437757243500873207572087076564926434736
19:25:22 <parsnip> ah, i did _something_ right, it flew threw the first half of the 122 packages this time.
19:26:12 <redrapscallion> Rembane: so it's impossible to get lambdabot to run anything involving tuples and lists?
19:26:20 <hydraz> > fst (2, 4)
19:26:22 <Axman6> @pl \x ->  f x >> g
19:26:22 <lambdabot> (>> g) . f
19:26:23 <lambdabot>  2
19:26:35 <hydraz> > head [ 1, 2, 3 ]
19:26:38 <lambdabot>  1
19:26:58 <Axman6> redrapscallion: look closely at what everyone else is doing, you need to prefix your expression with "> "
19:27:05 <redrapscallion> oh. you need a space after the >, I'm a goofball.
19:27:06 <dibblego> redrapscallion: you need space after >
19:27:06 <Axman6> > "Like this"
19:27:08 <lambdabot>  "Like this"
19:49:48 <parsnip> hmm, pretty sure i made a docker image with `stack install yesod`, now if i FROM that, `stack install base` takes zero steps, but `stack install yesod` goes through about 52.
19:49:59 <parsnip> i mean, download, build, etc.
19:50:44 <parsnip> https://hub.docker.com/r/bradyt/docker-yesod-build/
20:00:46 <pragmaticmonkey> hi
20:00:58 <pragmaticmonkey> if haskell is so great, why no one writes programs in haskell?
20:02:58 <kadoban> You got us there, good job.
20:03:42 <pragmaticmonkey> No, I am curious.
20:03:53 <pragmaticmonkey> I can't find a single job that lists Haskell as primary language.
20:03:58 <glguy> It's a shame you chose the approach you did if you were actually curious
20:04:17 <mmaruseacph2> pragmaticmonkey: LeapYear for example
20:04:33 <mmaruseacph2> pragmaticmonkey: https://functionaljobs.com/
20:04:44 <hodapp> pragmaticmonkey: I am curious myself what led you to the misconception that there is some strong connection between something being "great", and it being popular.
20:04:45 <kadoban> Oh. Because language choice has very little to do with the actual merits of a language
20:05:25 <kadoban> Especially in business. It mostly has to do with what languages are already popular, aka network effects, and stuff like what their last project was written in.
20:05:45 <kadoban> There is almost never a totally blank slate and people asking "Hmm, what language is objectively the best? Let's use that one."
20:07:28 <pragmaticmonkey> hodapp: I don't think being great automatically makes you popular but there is certainly a correlation.
20:07:41 <hodapp> pragmaticmonkey: what makes you certain there is a correlation?
20:08:06 <kadoban> I don't think there is much correlation at all.
20:08:43 <pragmaticmonkey> So the answer is that the whole tech industry is very ineffective at picking good technologies?
20:08:58 <geekosaur> "the perfect is the enemy of the good" predates programming, even
20:09:02 <pragmaticmonkey> And there is nothing wrong about Haskell but everyone who don't use it?
20:09:11 <Gurkenglas> I assume there's loads of mini-languages someone cooked up in private and didn't develop very far; those are extremely not popular and probably not great
20:09:11 <kadoban> Yes. And even defining objectively what is "good" is quite difficult currently.
20:09:18 <geekosaur> also there is much to be said for "someone else already did 80% of what we need but it's all in PHP"
20:09:36 <glguy> We use Haskell at work because it's the most suitable for the kind of analysis we do and because it's particularly good at prototyping and supporting dramatic refactoring and feature changes
20:09:57 <kadoban> pragmaticmonkey: Haskell is not a perfect language, but it's quite good, yes. There's no technical reason it shouldn't be used a lot more than it is.
20:09:59 <pragmaticmonkey> glguy: Are you guys hiring?
20:10:04 <glguy> but for some companies best means easy to hire cheap replacable labor
20:10:17 <Axman6> My job is writing Haskell, and it's my thrid job where I've done that :\
20:10:22 <hodapp> pragmaticmonkey: what the whole tech industry picks is based pretty strongly on..... what's already popular. oddly enough.
20:10:27 <glguy> pragmaticmonkey: Yeah, I've been doing a lot of interviewing lately, actually
20:10:41 <pragmaticmonkey> hodapp: That makes little sense, it is almost pure BS.
20:10:54 <hodapp> pragmaticmonkey: what is 'pure BS'?
20:10:56 <pragmaticmonkey> hodapp: You're saying people paint things blue because they're blue. what??
20:11:05 <hodapp> pragmaticmonkey: that's literally not what I'm saying. at all.
20:11:14 <pragmaticmonkey> hodapp: And so that is why only blue things are blue..... yeah, I think I see the logic. No.
20:11:17 <Gurkenglas> With the overabundance of people who want a Haskell job, wouldn't providing Haskell jobs be attractive because they can pay closer to minimum wage?
20:11:21 <glguy> pragmaticmonkey: If you have more specific questions about Haskell, you're welcome to return here with them
20:11:34 <Axman6> we're hiring haskell developers at the moment too
20:11:38 <kadoban> Gurkenglas: People don't want haskell jobs *that* bad
20:11:52 <pragmaticmonkey> kadoban: They do, trust me.
20:12:01 <hodapp> pragmaticmonkey: the technologies that are chosen for something *today* are based strongly on whatever was popular yesterday. This is not a difficult concept, especially if you don't try to interpret it with nonsense analogies about paint and colors.
20:12:10 <kadoban> Bad enough to take a severe salary cut? Sounds rare.
20:12:11 <pragmaticmonkey> kadoban: I have found that people either LOVE HASKELL or don't give a shit.
20:12:17 <pragmaticmonkey> Those who LOVE it, really want a job...
20:12:21 <pragmaticmonkey> but jobs are nowhere to be found.
20:12:31 <pragmaticmonkey> in contrast to Java, Scala, Elixir, and many other.
20:12:31 <Axman6> that was true years ago, but not any more
20:12:38 <glguy> pragmaticmonkey: Did you have some questions about Haskell itself or did you want to complain about jobs?
20:12:40 <pragmaticmonkey> I am not saying Haskell is bad, I am trying to understand what is going on.
20:12:47 <Axman6> there are plenty of companies hiring haskell developers, even more hiring functional programmers
20:12:56 <kadoban> Axman6: Don't suppose you're located anywhere near me magically? (Phoenix)
20:13:08 <pragmaticmonkey> glguy: How is the Haskell market not a question about Haskell? please drop it.
20:13:37 <Axman6> if Pheonix is near Brisbane, Australia then yes :)
20:13:45 <kadoban> :)
20:13:47 <parsnip> drop dropping it?
20:13:56 <pragmaticmonkey> Axman6: NSW is pretty close. ;)
20:14:07 <mmaruseacph2> pragmaticmonkey: there are a lot of Haskell-jobs, if you haven't found one is because you haven't looked properly
20:14:13 <Axman6> yeah but NSW is terrible
20:14:19 <mmaruseacph2> and that should be the end of the complaint
20:14:24 <Axman6> except for the one oasis contained within it, the ACT
20:14:26 <pragmaticmonkey> Axman6: Other than beaches and fit babes, I must agree.
20:14:27 <Gurkenglas> https://functionaljobs.com/ seems like 7 of them, where else does one look?
20:14:46 <pragmaticmonkey> Gurkenglas: Not an obscure job board.
20:15:07 <pragmaticmonkey> Gurkenglas: Zero jobs listed from Australia. Yeah right.
20:15:18 <mmaruseacph2> https://leapyear.ai/, https://www.tweag.io/ and see reddit, every month there are at least 2-3 calls for hires
20:15:19 <Axman6> our job ads are on stackoverflow jobs :\
20:15:26 <mmaruseacph2> also stackoverflow
20:15:30 <pragmaticmonkey> Axman6: Give me beach and babes and I am a happy man :)
20:15:32 <average> if i see someone heavily investing in learning haskell.. my only thinking about them could be that they have a ton of money.. and just want to play with new programming languages
20:15:45 <average> because for the regular joe, if they need a job, and they learn haskell, good luck getting a job
20:15:53 <kadoban> Learning haskell requires being rich? O.o
20:15:57 <average> kadoban: yes
20:15:58 <pragmaticmonkey> average: That is my experience so far.
20:16:00 <mmaruseacph2> lol
20:16:11 <pragmaticmonkey> kadoban: It requires that you can afford not having a job for a while.
20:16:12 <Axman6> average: that's nonsense, this is my third job programming Haskell
20:16:18 <pragmaticmonkey> Please don't pretend otherwise.
20:16:18 <average> if you're Bill Gates or Jeff Bezos, learning haskell is the most natural thing you can do
20:16:30 <average> Axman6: and where are you located sir?
20:16:33 <average> in Silicon Valley?
20:16:37 <kadoban> That makes ... no sense. People learn things for reasons other than direct financial benefit.
20:16:37 <Axman6> Australia
20:16:38 <average> or in the US probably
20:16:43 <mmaruseacph2> https://wiki.haskell.org/Haskell_Communities_and_Activities_Report also has listings of companies and projects using Haskell successfully
20:16:46 <Gurkenglas> https://stackoverflow.com/jobs/developer-jobs-using-haskell yep there's two more jobs
20:16:47 <kadoban> pragmaticmonkey: People with jobs do occasionally learn things.
20:16:47 <average> ok, Australia, so one of the large english speaking countries
20:16:48 <Axman6> one of the two jobs was in Tokyo, the other two here
20:16:49 <pragmaticmonkey> Axman6: I don't believe you for a second.
20:17:01 <average> Axman6: you must be rich
20:17:06 <pragmaticmonkey> Axman6: To have three jobs in a row doing Haskell in Brisvegas. Impossible.
20:17:06 <Axman6> hardly
20:17:14 <Axman6> I'm not in Bridbane
20:17:20 <pragmaticmonkey> I can't even find them in Sydney
20:17:23 * Axman6 is ok with that typo
20:17:23 --- mode: ChanServ set +o glguy
20:17:24 --- mode: glguy set +q *!*@gateway/web/freenode/ip.1.144.109.191
20:17:34 <average> hm
20:17:35 <glguy> You're welcome to hang out and see how we chat reasonably with each other
20:17:49 <glguy> get a sense of appropriate tone and then we can try more later
20:17:54 <average> glguy: uhm, who was that message directed to?
20:18:02 <glguy> average: pragmaticmonkey
20:18:08 <average> glguy: what did he wrong you with?
20:18:20 <Gurkenglas> average++
20:18:30 <glguy> Jump in #haskell-ops if you want to chat
20:18:47 <Axman6> glguy++, completely appropriate response to pretty poor trolling
20:19:28 <hodapp> screw you guys, I'm learning Go
20:19:30 * hodapp slams door
20:20:07 <Axman6> see you in 5 mins!
20:20:11 <nisstyre> hodapp: /j #elixir-lang
20:20:12 <hodapp> >:O
20:20:15 <nisstyre> we have magic potions
20:20:29 <hodapp> but do they have any...
20:20:31 <hodapp> side effects?
20:20:44 <nisstyre> hodapp: actually not really
20:20:53 <nisstyre> you drink them and they go right through your system :p
20:20:57 <average> yes, they have side-effects, you can end up under a bridge as a result of unemployment after learning elixir
20:21:00 <average> i'm not even kidding
20:21:08 <hodapp> ...wait, what?
20:21:15 <nisstyre> lolwat
20:21:33 <nisstyre> actually idek why it's called Elixir
20:21:54 <Gurkenglas> I think he means it's good enough that you don't want to code in other languages, but there's no Elixir jobs
20:21:58 <nisstyre> but you have lots of fun names for things like Distillery and HTTPoison
20:22:12 <nisstyre> there are actually a growing number of Elixir jobs
20:22:18 <nisstyre> and if not, you can always learn Erlang
20:22:25 <average> what is the most frequent purpose of adults writing code if not for money
20:22:31 <average> that is a very adult question
20:22:36 <average> please do not answer if you don't feel adult enough
20:22:53 <hodapp> "to encourage laziness" in my case
20:23:05 <average> what kind of laziness?
20:23:16 <average> and does the laziness get remunerated or not?
20:23:30 <hodapp> the kind of laziness where I can sit and do nothing while a computer handles the work
20:23:41 <average> (also an adult question, i should say)
20:24:44 <hodapp> anyhow, I gotta get to sleep... I have a busy day tomorrow of being unemployed because I learned Haskell
20:25:04 <nisstyre> have fun at the welfare office I guess
20:25:09 <average> hodapp: you must be rich
20:25:13 <Axman6> hey at least you exist, apparently I don't because there are no Haskell jobs so I obviously can't have one!
20:26:28 <nisstyre> does anyone have any actual Haskell questions? if not then I'm going to go eat something and then force myself to write YAML files for a few hours
20:27:24 <average> at least YAML files pay better
20:27:29 <nisstyre> yes they do
20:27:49 <nisstyre> I should start YAMLCoin actually
20:27:51 <average> indeed, otherwise you would be writing haskell while enjoying the luxury life of the rich and famous
20:28:38 <Axman6> mate, seriously, there are literally hundreds or even thousands of Haskell developers who are paid to do it. you're living a myth
20:29:00 <Axman6> some of the bigges tbanks have fairly large teams, so does Facebook
20:29:04 <Axman6> biggest*
20:29:46 <nisstyre> It seems like a lot of hedge funds run on Python, C++, or OCaml
20:29:58 <nisstyre> algorithmic or HFT hedge funds that is
20:30:03 <kadoban> average: Can't tell if this is supposed to be some weird meme or what
20:30:14 <Axman6> Standard Chartered has a pretty large haskell team
20:30:27 <nisstyre> they could be a snowflake
20:31:17 <nisstyre> anyway, it doesn't really matter
20:35:28 <ome> \q
20:56:07 <parsnip> entering my docker image, if i run `stack install yesod` from `/`, nothing happens. but if i enter my `/yesod-project/`, _now_ it starts considering 122 packages (half of them already compiled).
20:57:42 <kadoban> parsnip: Is there a stack.yaml there?
20:59:15 <parsnip> yes
20:59:36 <kadoban> Then I would assume the resolver configured there is not the same as the globally configured one.
20:59:46 <parsnip> with just `resolver:lts-10.0`, which i believe is same.
20:59:53 <kadoban> Or something else is different, could be flags or something.
21:00:01 <parsnip> hmm
21:02:32 <parsnip> going to try rebuilding my intermediate with more explicit base.
21:04:01 <parsnip> oho, interesting.
21:04:18 <parsnip> if i docker pull fpco/stack-build:lts-10.0
21:04:34 <parsnip> then docker run --rm -it fpco/stack-build:lts-10.0
21:04:52 <parsnip> and do `stack setup`, it starts grabbing 10.3
21:05:57 <kadoban> One of these days I need to figure out what the docker stuff is for and if I care enough to figure out how to use it.
21:07:00 <parsnip> first you need a computer for ants.
21:07:21 <glguy> Like a Raspberry PI?
21:07:29 <parsnip> yes
21:07:35 --- mode: glguy set -qo *!*@gateway/web/freenode/ip.1.144.109.191 glguy
21:07:45 <dmwit> Problem: my computer is underpowered. Solution: run a virtualization layer???
21:08:08 <glguy> It would make sense to just emulate a faster computer
21:08:12 <parsnip> dmwit: i guess the benefit is, you can push layers around.
21:08:33 <parsnip> so i can grab fpco/stack-build, etc, build on that, push it, etc.
21:08:55 <parsnip> let docker hub build some of the layers for me.
21:11:32 <parsnip> kadoban: yes! who cares that i might have convinced stack to build on 10.0 for the intermediate build but yes, changing stack.yaml to 10.3 fixed it! i now have fast builds!
21:11:46 <parsnip> w0000000t!
21:11:59 <parsnip> f'ing resolvers
21:13:26 <kadoban> Yay?
21:13:46 <parsnip> yes. yay indeed.
21:15:12 <parsnip> thanks for getting me on the right track.
21:15:37 <kadoban> Anytime. Always glad when I can assist without actually knowing what's going on at all, heh.
21:21:13 <parsnip> ah, `stack path would have revealed all the 10.3 riddled about.
21:21:23 <parsnip> *`stack path`
21:22:05 <parsnip> ugh, `/root/.stack/`, was having a tough time finding that.
21:23:02 <parsnip> we'll have to see if the first build would have been faster if i somehow kept stack on 10.0 like base image.
21:26:12 <sqooq> hi
21:26:31 <sqooq> is there anyway to go backwards in directory when naming a filepath in default haskell file IO stuff
21:26:38 <sqooq> as in "../file"
21:27:05 <glguy> sqooq: looks good
21:27:14 <sqooq> really?
21:27:21 <sqooq> Hmm maybe I typed the folder name wrong or something
21:30:11 <sqooq> huh it worked this time
21:30:12 <sqooq> sweet
21:30:23 <sqooq> must have made a typo
21:57:25 <Zircon[m]> Hey
21:57:26 <Zircon[m]> Any Computer Tech people interested in helping out a small tech site become something better?  Join www.digitaladdiction.info any questions? DM me.
21:59:09 <pacak> Zircon[m]: Website says "Python, C, C#, Java, HTML,PHP.". Channel says "#haskell"...
21:59:41 <Zircon[m]> Ik but it's kina dieing
21:59:51 <Zircon[m]> And we need help
22:00:26 <pacak> Natural selection, survival of the fittest and all that...
22:06:41 --- mode: ChanServ set +o dmwit
22:06:59 --- kick: Zircon[m] was kicked by dmwit (This channel is for Haskell-related discussions.)
22:07:04 --- mode: dmwit set -o dmwit
22:11:32 <sqooq> anyone good with signal stuff
22:12:04 <dmwit> ?where justask
22:12:04 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
22:12:13 <sqooq> I was about to
22:12:16 <sqooq> hold up
22:12:22 <dmwit> Okay, sorry. =)
22:12:37 <sqooq> nah it's my bad I should have been prepared for the second question
22:12:45 <sqooq> they were both supposed to come one after the other
22:12:45 <sqooq> haha
22:13:10 <sqooq> wait wait wait wait wait
22:13:15 <sqooq> Paul Hudak made haskell???
22:13:28 <sqooq> or helped create haskell I should say
22:13:36 <Axman6> was one of the members of the committee anyway
22:14:52 <sqooq> jeez that took long to find
22:15:03 <sqooq> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.652.5985&rep=rep1&type=pdf
22:15:13 <sqooq> so my question is, in section 2.3 he talks about sample rates
22:15:42 <sqooq> and in many audio languages there are multiple rates to make things more efficient. Usually audio rate and control rate, but perhaps more
22:17:09 <sqooq> so he develops his haskell system using type magic
22:17:13 <Axman6> are you familliar with the various signal/music generation libraries that already exist btw?
22:18:00 <sqooq> but then when he shows an example of combining two different rates he shows that you have to upsample or downsample to get them the same
22:18:16 <Axman6> Tidal comes to mind, though it's more a synth management language afaict. I thought there was another one but I can't remember its name
22:18:17 <sqooq> But doesn't this defeat the purpose?
22:18:46 <sqooq> Because if you upsample a control rate, you've effectively made it calculate at signal rate, or am I missing something?
22:19:44 <dmwit> Can you avoid effectively calculating at signal rate?
22:20:26 <sqooq> maybe
22:20:27 <sqooq> idk
22:20:34 <Axman6> I wonder how something like Copilot would be for signal processing
22:33:29 <dmwit> sqooq: The paper you linked appears to address this question pretty directly in the body. It discusses several reasons to prefer signals of different rates that do not have to do with calculation speed, and discusses how sampling and calculation speed relate to each other.
22:33:56 <dmwit> s/sampling/resampling/
22:42:54 <aplainzetakind> What does it mean when `stack build` tells me `No information found for ghc-7.10.3`?
22:43:25 <kadoban> aplainzetakind: That it doesn't know how to install that version of GHC on your OS setup.
22:43:37 <sqooq> dmwit, I don't see that. He says "Generating all signals at the same high rate is computationally expensive,
22:43:37 <sqooq> and thus we wish to develop ways to sample at lower rates when the higher rate is not required."
22:43:56 <sqooq> but you always have to eventually mix lower with higher
22:44:03 <aplainzetakind> But what's making it look for that particular version?
22:44:05 <sqooq> so you'll always have to upsample
22:44:28 <sqooq> so unless upsampling is more computationally efficient than just working with higher rate signals from the get go
22:44:36 <kadoban> aplainzetakind: The resolver that it's set to use by whatever stack.yaml is relevant, unless you're overriding that.
22:44:37 <sqooq> which may be the case
22:44:42 <dmwit> sqooq: It is the case.
22:45:17 <aplainzetakind> Found it, it's ancient I guess, lts-5.11
22:45:48 <kadoban> Yeah, pretty old
22:46:07 <aplainzetakind> Is overriding it likely to cause breakage?
22:46:37 <kadoban> aplainzetakind: Changing the resolver you mean? Fairly likely to cause it to not build, depending.
22:46:48 <kadoban> If this is some project you're trying to build I mean ...
22:47:03 <sqooq> dmwit, alright that settles it then
22:47:21 <sqooq> So I guess my next question would be, how is that the case? But I think I can already imagine the asnwer.
22:47:44 <aplainzetakind> This is what I'm trying to build: https://github.com/LuminosoInsight/wikiparsec
22:48:28 <kadoban> aplainzetakind: You can always try
22:49:45 <kadoban> IIUC, the thing where stack can't install that version of GHC for you is kind of a transient thing right now. Kind of vague to me why, something about gcc on a lot of OSes changing default behavior which is screwing up the old GHC bindists. So in the future that might just work, but that doesn't really do anything for you for right now I guess.
22:50:14 <dmwit> sqooq: Making three extra copies of an already-computed value is cheap.
22:50:40 <aplainzetakind> Overriding introduced version constraint issues, I'll try stack solver.
22:51:48 <dmwit> sqooq: Or, like, thinking of a control envelope, which might be sampled at a mere 100Hz, making 441 extra copies of each already-computed value is cheap, especially when compared to computing 441 times as many samples.
22:57:33 <parsnip> hmm, no thing like the following?
22:57:34 <parsnip> stack config --system-ghc set resolver --global lts:10.0
22:57:56 <parsnip> i can set globally for stack to use system-ghc, but i can't say globally which resolver to use?
22:59:23 <parsnip> hmm, nm i've confused myself, it's already in the global stack.yaml.
22:59:43 <sqooq> dmwit, yes but if it's upsampled and let's say multiplied by a signal, that multiplication will take place at audio rate
22:59:54 <sqooq> so I would figure it would lose the computational benefits
23:02:04 <dmwit> What is your proposal for modifying every sample of an audio signal without doing one calculation per sample of an audio signal?
23:02:50 <dmwit> Anyway it doesn't matter. You're just confused about what the computational benefits of having a lower signal lying around are.
23:03:08 <dmwit> The benefit is not: I can now modify the higher-rate signal with less computation.
23:03:16 <dmwit> The benefit is: I can produce the lower-rate signal with less computation.
23:03:49 <dmwit> You still have that benefit. And you can still produce an upsampled version of the lower-rate signal with less computation than you can produce a high-rate signal in the first place.
23:06:51 <sqooq> yes
23:12:37 <sqooq> you guys when I first started haskell showed me this great haskell program that auto type checks on save irrespective of any editor
23:12:47 <sqooq> the new ghc made ghc-mod out of date
23:12:52 <sqooq> so my editor doesn't type check anymore
23:13:05 <sqooq> so what was that program called?
23:13:16 <sqooq> this irc showed me****
23:13:19 <dmwit> ghcid?
23:13:24 <sqooq> that's it i think
23:13:25 <sqooq> thanks
23:35:08 <sqooq> man arrows are annoying :(
23:55:57 <epicallan> I am trying to write a function that pairs up adjacent values in a list. But i am having a Non-exhaustive patterns error. How can i correct this. http://lpaste.net/361680 or rewrite it better. Thanks
23:56:06 * hackage genvalidity-time 0.1.0.1, genvalidity 0.4.0.3 (Norfair): https://qbin.io/7jei5xak
23:57:07 <dmwit> epicallan: Start by writing `pairUp` instead of `pairUP`.
23:57:18 <dmwit> Then you'll get a type error, and hopefully it will guide you to the next fix. =)
23:57:49 <dmwit> ..possibly several type errors, actually.
23:59:51 <dminuoso> Mmm, fromJust rarely seems useful.
23:59:57 <amalloy> yeah there are a surprising number of type errors in there
