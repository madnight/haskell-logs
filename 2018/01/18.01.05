00:05:44 <Linat0k> lulz fair
00:05:48 <Linat0k> damn
00:05:53 <Linat0k> now my internet is all like
00:05:59 <Linat0k> blocking my shit
00:06:07 <Linat0k> things im under 18
00:06:15 <Linat0k> im only trying to get on pornhub
00:06:18 <Axman6> I wonder why...
00:06:23 <Linat0k> JMP +18;
00:07:28 <JuanDaugherty> are you in fact under 18?
00:07:45 <Axman6> surely not!
00:08:10 <LiaoTao> Age is just an integer anyway
00:08:26 <JuanDaugherty> well pornhub is pretty rough for a minor
00:08:31 <Linat0k> im 29 :'(
00:08:42 <Linat0k> internet says i dont have an active broadband subscription
00:08:49 <Linat0k> and that is going to be setup today
00:08:54 <Linat0k> but ive been on the internet for like ...
00:08:55 <Linat0k> two weeks
00:08:58 <Linat0k> wtfbbq
00:09:10 <LiaoTao>  Well the internet says a lot of things
00:09:21 <capisce> the internet of things
00:10:42 <JuanDaugherty> https://www.youtube.com/watch?v=ZLaj4VMQfxc
00:16:27 <JuanDaugherty> age is normally a positive definite integer in chinese culture, in american culture it's rational
00:17:33 <JuanDaugherty> and zero based in the west generally
00:17:53 <[exa]> JuanDaugherty: imaginary I'd say.
00:19:03 <[exa]> Anyway, I need a nice way to do something like this from C:   a=5; if(x1) modify1(a); if (x2) modify2(a); ... use a
00:19:31 <[exa]> it's not monadic code, the values are pure, except for accumulating the changes optionally
00:19:47 * hackage ocaml-export 0.3.0.0 - Convert Haskell types in OCaml types  https://hackage.haskell.org/package/ocaml-export-0.3.0.0 (mchaver)
00:19:48 <JuanDaugherty> looks like a switch
00:19:50 <[exa]> is there a good syntax for writing code like that?
00:19:50 <DigitalKiwi> MCDONALDS MCDONALDS
00:20:08 <[exa]> JuanDaugherty: multiple cases can be fired
00:21:19 <JuanDaugherty> [exa], you mean simulataneously don't you
00:21:50 <[exa]> yes
00:22:03 <[exa]> (it should be still processed in order though)
00:22:25 <[exa]> a good usecase is fixing/checking the input that can be broken in multiple ways
00:22:59 <JuanDaugherty> well serially is easy, just iterate till nothing fires
00:23:43 <JuanDaugherty> while, until, etc
00:24:23 <JuanDaugherty> simultaneously then gets more involved, especially if you mean literally simultaneously
00:24:30 <[exa]> hm maybe something like    5   & (if cond then modify1 else id) & (if cond2 then modify2 else id) ...
00:24:58 <[exa]> @pl \cond mod -> if cond then mod else id
00:24:58 <lambdabot> flip flip id . if'
00:25:06 <JuanDaugherty> while and until are at the same level of c as switch
00:25:24 <[exa]> whoa, flipping the flip
00:57:48 <mandiblegrip> Hey umm, can anyone help me in babby's first Haskell program? I'm trying to execute GET requests on a list of Requests using Network.HTTP.Simple.
00:57:49 <hololeap> :t if'
00:57:50 <lambdabot> error:
00:57:50 <lambdabot>     • Variable not in scope: if'
00:57:50 <lambdabot>     • Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
01:03:36 <raduom> Does anyone have a working link for: http://www.cis.upenn.edu/~eir/papers/2014/promotion/promotion.pdf ?
01:05:36 <cocreature> raduom: which paper is that supposed to refer to? maybe https://pdfs.semanticscholar.org/4793/7b9d492444c8769624617d9ddfe1be48330a.pdf ?
01:08:50 <raduom> cocreature: yes. thanks!
01:10:48 <liste> :t bool -- hololeap
01:10:49 <lambdabot> a -> a -> Bool -> a
01:52:41 <__monty__> Came across this "... Applicative do-notation. This allows programmers to write sequences of statements that the compiler automatically rearranges to exploit concurrency." Is this a special property of ApplicativeDo or is this valid for all applicatives?
01:52:47 * hackage emoji 0.1.0.0 - emoji utility  https://hackage.haskell.org/package/emoji-0.1.0.0 (nakaji_dayo)
01:53:08 <__monty__> In a post about haxl, hence the concurrency.
01:54:13 <Cale> __monty__: It's a combination of the particular Applicative instance they use, and the fact that ApplicativeDo's translation into Applicative operations is somewhat clever.
01:54:47 * hackage emoji 0.1.0.1 - emoji utility  https://hackage.haskell.org/package/emoji-0.1.0.1 (nakaji_dayo)
01:55:09 <__monty__> So applicative do is not just sugar?
01:55:30 <alp> well you won't get the concurrency part with other applicatives. but the transformation from do notation to applicative-only combinators works for all applicatives that are a monad too. whether this transformation can take place is a property of the expression, not the applicative
01:55:58 <alp> (IIRC, haven't used that extension at all)
02:02:46 <__monty__> Could it benefit something like nosql queries?
02:02:47 * hackage emoji 0.1.0.2 - emoji utility  https://hackage.haskell.org/package/emoji-0.1.0.2 (nakaji_dayo)
02:09:51 <Cale> __monty__: It is just sugar, but it's somewhat clever sugar. The translation isn't as straightforward as the usual do notation.
02:10:57 <Cale> __monty__: Personally, I think it's a little too clever for its own good, and when you want concurrency, you should probably just be explicit about it, rather than relying on a desugaring process that's moderately opaque.
02:11:36 <Cale> (e.g. by using the Applicative operations directly)
02:13:58 <phadej> ha, that's exact the opposite of motivation in the ApplicativeDo paper :)
02:15:45 <__monty__> Implicit optimization has it's place though.
02:16:14 <__monty__> Especially in DSLs.
02:17:02 <phadej> one point, refactoring manual Applicative expression is difficult in both scenarios: if you add data dependencies you have to rewrite a lot, as you have to add >>= somewhere. Opposite is true too, human is lazy, if the data dependency is removed, only few pedantic ones will actually rewrite the function to use the additional concurrency possibility
02:17:49 <phadej> i.e. you have to differentiate between simple cases like `mapConcurrently` vs complex data-dependent processes
02:18:10 <phadej> *simple cases where `mapConcurrently` is enough
02:19:02 <Phyx-> 01:44:40 < geekosaur> and we don't usually use screenshots. granting that copying text on windows is soemwhat annoying, it's still possible
02:19:04 <Phyx->                       (click the mini-icon in the window title)
02:19:25 <Phyx-> <-- standard windows dialogs can be copied just by giving the window focus and pressing ctrl+c
02:19:38 <Phyx-> geekosaur: ^^
03:03:27 <dysfun> they kept that one hidden
03:11:36 <saurabhnanda> is there a lens to wrap/unwrap a newtype?
03:12:16 <lyxia> if there is one I would expect to find it in generic-lens
03:14:31 <cocreature> https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Wrapped.html
03:14:38 <cocreature> but you’ll have to write the instances yourself
03:20:39 <MarcelineVQ> saurabhnanda: If you don't want the whole lens package there's also a package called newtype https://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html
03:21:08 <saurabhnanda> no TH helper to auto-generate the instances?
03:21:56 <cocreature> https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-TH.html#v:makeWrapped
03:40:47 <i-am-the-slime> does anybody here know how I can use ghc-mod with stack on nixos?
04:28:17 * hackage crdt 4.1 - Conflict-free replicated data types  https://hackage.haskell.org/package/crdt-4.1 (cblp)
04:29:50 <mpickering> i-am-the-slime: if you're letting stack manage your dependencies then just like how you would on any os?
04:39:47 <geekosaur> the problem might be more ghc-mod's tight ghc version dependencies (for example that it doesn't work with 8.2 yet)
04:45:58 <AnormalGuy> Hello, anyone at home, I am a noob in haskell, would love to join thecommunity to interact and improve m skills on the platform, anyone to help
04:46:41 <orion> AnormalGuy: https://haskellbook.com
04:56:56 <boothead_> Hi folks, is there a way to use infix type constructors with more than 2 arguments? I have something that I'd like to use like "label" ::> a b
04:57:18 <boothead_> but at the moment I have to say Labelled "label" a b
04:58:34 <Iceland_jack> boothead_: no, unless you count `(a ::> b) c'
04:59:18 <Iceland_jack> You can also tuple two of the arguments
04:59:18 <Iceland_jack>     "label" ::> '(a, b)
04:59:18 <Iceland_jack>     "label" ::> Two a b
04:59:44 <boothead_> thanks Iceland_jack :-)
05:06:52 <jgt3> oh it's Iceland_jack, the guy from the GHC warnings
05:08:54 <cocreature> Iceland_jack - soon in a compile error near you
05:11:31 <AnormalGuy> orion: I am getting sth like 'This site can’t be reached  haskellbook.com refused to connect.'
05:13:07 <cocreature> AnormalGuy: you’ll have to use http instead of https
05:25:17 * hackage crdt 4.2 - Conflict-free replicated data types  https://hackage.haskell.org/package/crdt-4.2 (cblp)
05:25:48 <faso> heyo, anybody here?
05:27:07 <metahumor> faso: hiyo
05:27:34 <faso> is learnyouahaskell.com still good for learning haskell today?
05:28:35 <metahumor> that's what I used initially, but there's some that don't particularly like it, because of the weird pacing
05:29:05 <metahumor> haskellbook is really good
05:29:39 <faso> oh, it does look pretty nice
05:29:42 <faso> guess i'll buy that then
05:29:43 <faso> thanks!
05:29:53 <metahumor> they have the first 4 chapters available for free
05:29:57 <metahumor> so you can get a sense for their style
05:30:13 <faso> yeah i'm flipping through them right now
05:30:18 <faso> looks hella solid
05:30:52 <faso> alright, im gonna be back with some dumb questions soon, no doubt
05:30:58 <faso> thanks for the pointer!
05:31:04 <metahumor> looking forward to it
05:36:14 <faso> is haskell as crazy with new features and systems as C++ is?
05:36:44 <metahumor> somewhat, there's always new language extensions being made available
05:37:14 <metahumor> but its your choice to include them, using what are called "language pragmas"
05:37:56 <faso> is there kinda of a "default" way to do things? because i assume there's a bunch of different ways to achieve the same results then
05:38:05 <metahumor> some are very common to include which get rid of small annoyances about haskell, like NumDecimals makes "1e6" a possible Integer, not just a float
05:38:27 <metahumor> there are a ton of ways to do the same thing often, especially syntax wise
05:38:59 <metahumor> i can define a function to add 1 to an integer in the following ways, not exhaustively:
05:39:36 <metahumor> "f x = x + 1", "f = \x -> x + 1", "f x = (+ 1) x", "f = (+ 1)", "f = succ"
05:40:39 <metahumor> oh, also "f = (+) 1"
05:41:07 <DigitalKiwi> and suddenly python looks comforting
05:41:38 <rampion> feeling a bit dumb today - any reason why `cabal update && cabal install hdevtools-0.1.6.1` wouldn't be able to find hdevtools 0.1.6.1?
05:42:20 <metahumor> faso: you can always do just "f x = x + 1"
05:42:57 <i-am-the-slime> mpickering probably. I haven't done it on any os. I will just live with intero for now.
05:43:20 <i-am-the-slime> How would I get a toJSON instance for a newtype that wraps a primitive type and is just the instance of the inner type?
05:43:28 <i-am-the-slime> ToJSON
05:44:52 <metahumor> "instance ToJSON NewType where toJson = toJson . runNewtype" ?
05:45:20 <Eduard_Munteanu> i-am-the-slime, with generalized newtype deriving
05:51:08 <i-am-the-slime> Eduard_Munteanu: But I thought that wrapped the values
05:51:18 <i-am-the-slime> { MyNewtype: 12 }
05:51:19 <i-am-the-slime> No?
05:52:06 <Eduard_Munteanu> No, it can't do anything ToJSON-specific
05:52:09 <Iceland_jack> jgt3 cocreature: haha!
05:53:02 <i-am-the-slime> Okay, I will see if it works, I guess.
05:58:27 <faso> alright, i wrote all that stuff down
05:59:26 <faso> gotta run, thanks for the help! hope i can milk y'all for some more knowledge later :D
06:15:54 <Phyx-> rampion: if using Cabal 2.0 you may be experiencing https://mail.haskell.org/pipermail/haskell-cafe/2018-January/128385.html
06:16:54 * hackage hsimport 0.8.5 - A command line program for extending the import list of a Haskell source file.  https://hackage.haskell.org/package/hsimport-0.8.5 (DanielTrstenjak)
06:43:13 <yeoman> hello, if i created a type with "data" and load that file with :l
06:43:21 <yeoman> how would i use that type.. or "instantiate" it?
06:46:17 <__monty__> yeoman: You'd use the type's constructors: let someBool = True or let someMaybe = Just True.
06:46:38 <__monty__> Where True and Just are constructors.
06:47:17 <yeoman> man confusing.. so i need to create a function that returns one?
06:47:24 <EvanR> > True
06:47:26 <lambdabot>  True
06:47:30 <EvanR> > Nothing
06:47:32 <lambdabot>  Nothing
06:47:39 <EvanR> > Just 9
06:47:41 <lambdabot>  Just 9
06:47:42 <metahumor> :t True
06:47:43 <EvanR> constructe
06:47:44 <lambdabot> Bool
06:47:51 <__monty__> yeoman: Not really, you can use the constructor as an argument to a function.
06:48:08 <EvanR> you dont instantiate values you just use them
06:48:18 <yeoman> yeah.. that's why i used "" < these guys
06:48:21 <metahumor> so the values that inherit in a type are inherently "functions" that have no arguments that return the value
06:48:24 <yeoman> i know that i just use them, but how do i use them
06:48:34 <yeoman> i wrote "data Symbol = X | O"
06:48:42 <yeoman> and i want to "create" a Symbol X now..
06:48:44 <EvanR> ex. 2 + 2, didnt have to instantiate 2 first
06:48:49 <__monty__> Just write X.
06:48:57 <EvanR> metahumor: what...
06:49:05 <yeoman>  No instance for (Show Symbol) arising from a use of ‘print’
06:49:11 <EvanR> in haskell functions that take no arguments arent functions
06:49:15 <__monty__> someSymbolFunc X = whatever happens in case you get an X.
06:49:37 <metahumor> EvanR: I was trying to explain that "f = True :: Bool" is a valid thing
06:49:47 <EvanR> f is not a function
06:49:49 <metahumor> yeah, i didn't mean "functions" in the haskell sense
06:50:18 <metahumor> yeoman: try "data Symbol = X | O deriving (Show)"
06:50:20 <yeoman> i can't write just X.. ir is that because my symbol-thing is not showable?
06:50:33 <EvanR> you can write X, but without Show support you cant print it
06:50:37 <yeoman> why is not everything showable?
06:50:39 <ggVGc> what is a function in not the haskell sense?
06:50:56 <metahumor> yeoman: what's happening is that you can definitely write X, but the REPL doesn't know how to indicate to you that you gave it X because it didn't have a Show Symbol instance
06:50:59 <EvanR> yeoman: its annoying, but thats the way it is. for example functions are not showable
06:51:05 <EvanR> IORefs arent showable
06:51:17 * hackage rattletrap 4.0.0 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-4.0.0 (fozworth)
06:51:33 <yeoman> lol.. that package.
06:51:40 <EvanR> many abstract data types arent showable
06:51:52 <metahumor> yeoman: you could also try ":t X" to get "X :: Symbol"
06:51:58 <yeoman> but why.. do i need show for something else than ghci?
06:52:07 <metahumor> ":t" stands for ":type" in the ghci repl
06:52:17 <yeoman> metahumor: thanks!
06:52:19 <EvanR> you dont need Show
06:52:26 <EvanR> its just for convenience
06:52:38 <ggVGc> I use show and read for dirty serialization quite often
06:52:42 <ggVGc> because I'm crap
06:52:45 <metahumor> :t print
06:52:46 <lambdabot> Show a => a -> IO ()
06:52:52 <yeoman> yeah.. but that's confusing me, if it's just for me as a programmer.. why isn't it possible with everything?
06:53:04 <EvanR> its just not possible with everything
06:53:06 <ggVGc> yeoman: because haskell is a compiled language
06:53:15 <metahumor> yeoman: "print" takes a thing that has a Show instance, and "print"s it. basically "print = putStrLn . show"
06:53:22 <yeoman> ggVGc: sorry, that reasoning does not make sense
06:53:37 <EvanR> what should it show for the sqrt function?
06:53:40 <EvanR> > sqrt
06:53:42 <lambdabot>  <Double -> Double>
06:53:45 <metahumor> LOL
06:53:49 <ggVGc> ownder
06:53:50 <EvanR> :|
06:53:51 <ggVGc> owned
06:54:07 <metahumor> > (not)
06:54:08 <lambdabot>  <Bool -> Bool>
06:54:08 <ggVGc> let x = x*x in x
06:54:15 <ggVGc> > let x = x*x in x
06:54:17 <lambdabot>  *Exception: <<loop>>
06:54:23 <ggVGc> uhm, well
06:54:30 <ggVGc> > let x y = y*y in x
06:54:32 <lambdabot>  <Integer -> Integer>
06:54:34 <metahumor> i think you should be more explicit as to what's goin on
06:54:35 <ggVGc> oh wel
06:54:41 <metahumor> > show (sqrt)
06:54:42 <EvanR> in reality, a dumb default way to display stuff in ghci would be nice
06:54:43 <lambdabot>  "<Double -> Double>"
06:54:47 <yeoman> metahumor: i know what it does.. but that doesn't explain to me.. why not everything does :D
06:55:01 <EvanR> yeoman: it just doesnt
06:55:12 <metahumor> yeoman: what would a show instance of an infinite tree be?
06:55:13 <EvanR> when they designed haskell you werent there to chime in on this
06:55:42 <EvanR> you can show an infinite tree using deriving Show
06:55:57 <yeoman> EvanR: just because you have it, just does not mean that you HAVE to use it..
06:56:11 <yeoman> show seems to be a debugging fucntion, that isn't possible by default
06:56:19 <metahumor> yeah, but you'd have to decide how to show it, which makes having a default instance of Show for it weird
06:56:20 <EvanR> yes
06:56:24 <EvanR> you got it
06:56:44 <yeoman> yeah well.. if it's for debugging only, i don't understand why i have to explicitly saying that everytime i want to debug
06:56:47 <EvanR> idris repl shows everything somehow, not necessarily in a good way
06:56:47 <metahumor> show is kinda like "__repr__" in python
06:56:49 <EvanR> including functions
06:56:59 <yeoman> i mean repl makes only sense if i see things, doesn't it?
06:57:37 <EvanR> when they designed haskell, they didnt not decide to treat Show class specially
06:57:48 <EvanR> types dont have any support unless you say so
06:57:48 <ggVGc> yeoman: what I meant by my comment is that with an interpreted language you have a lot more information available to you at runtime, which makes coming up with default printable representations easier. In a compiled language, anything you haven't explicitly defined how to print can't be printed
06:57:57 <metahumor> if you don't define "__repr__" for a new class, then "print(MyNewClass())" will often be something like '<__main__.MyNewClass instance at 0x7f9db26f9050>
06:58:05 <EvanR> did not*
06:58:25 <EvanR> they chose not to do some special case here for debugging convenience
06:58:41 <metahumor> a Show instance might also force thunks, which you might not want
06:59:07 <yeoman> ggVGc: that's a not true, and i didn't ask for that
06:59:46 <metahumor> :sprint (let x = 1 + 2 :: Int)
06:59:47 <steveo_> Hi! A question: is there a good library for message-passing style distributed computing? E.g., similar to Erlang style concurrency?
06:59:47 <EvanR> you havent accepted any of these answers, what then are we missing
06:59:49 <ggVGc> why is it not true?
07:00:08 <EvanR> steveo_: theres cloud haskell
07:00:32 <ggVGc> metahumor's answer is a good example of what I was saying. In python the default printable representation of something can include the class name because it's in the bytecode
07:00:37 <ggVGc> that's not true for compiled languages
07:00:45 <metahumor> steveo_: check out this book and this chapter: http://chimera.labs.oreilly.com/books/1230000000929/pt02.html
07:00:51 <yeoman> yeah it's mostly the case, but not in general..but i don't want to discuss
07:01:04 <yeoman> you could certainly do a compiled language that does the same thing, really
07:01:10 <metahumor> steveo_: there's also this: https://github.com/transient-haskell/transient
07:01:12 <TMA> ggVGc: a compiled language does the thing it is meant to do. Common Lisp is sometimes a compiled language yet it has not turned its nose upon folks wanting to print things
07:01:17 * hackage rattletrap 4.0.1 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-4.0.1 (fozworth)
07:01:33 <ggVGc> TMA: sure, but an interpreted language always has the information
07:01:34 <EvanR> theres no such thing as compiled / interpreted language
07:01:53 <steveo_> metahumor: Thanks! I love this book, read it already.
07:01:54 <nullie> isn't code is data in lisp?
07:02:01 <ggVGc> whatever, I think everyone knows what I mean, but I'll step out of this
07:02:01 <nullie> so it makes easy to show that
07:02:02 <steveo_> Has anyone used 'haskell-distributed.github.io' or 'github.com/hargettp/courier'?
07:02:17 <yeoman> ggVGc: doesn't make it right, if people say pi is 3 i know what they mean
07:02:19 <yeoman> it's still wrong
07:02:22 <yeoman> but it works in most cases
07:02:26 <EvanR> can you stop yeoman
07:02:33 <yeoman> yep.
07:03:05 <steveo_> Does anyone know how long it takes to serialize 1000 float values on a 5Ghz machine? I mean when I would choose the fastest Haskell lib that I can find?
07:03:23 <ggVGc> does serialize mean write to disk?
07:03:23 <TMA> ggVGc: it is just that Haskell designers chose not to incorporate it (maybe interactive repl for Haskell (ghci) is just an afterthought, therefore it is a second class inhabitant of the ecosystem)
07:03:30 <ggVGc> in that case it probably isn't up to haskel
07:03:39 <EvanR> ghci certainly could use improvements
07:03:47 <steveo_> ggVGc: Serialize to binary form (MsgPack or something faster)
07:03:54 <Iceland_jack> It's worth noting that instances of Typeable are created automatically
07:04:00 <steveo_> Prepare to send it over the net
07:04:05 <EvanR> its crappy lack of features is not some expression of ultimate wisdom
07:04:10 <Iceland_jack> So you can write
07:04:11 <Iceland_jack>     >> data Foo = F
07:04:16 <Iceland_jack>     >> typeOf F
07:04:16 <Iceland_jack>     Foo
07:04:24 <Iceland_jack> without saying (data Foo = F deriving Typeable)
07:04:24 <EvanR> steveo_: i hear CBOR is supposed to be fast, when its ready
07:04:45 <EvanR> a numeric answer to your question would be silly, run the code and find out
07:04:45 <steveo_> Yes, heared something about it too.
07:05:19 <EvanR> (5GHz is not even nearly enough info to predict)
07:05:43 <yeoman> are there 5GHz processors? without some liquid gas cooling stuff?
07:06:05 <steveo_> 8700k Intel chip on linux. Any good cooler (Air or AIO) can do that without any problem.
07:06:13 <EvanR> liquid gas is an interesting state
07:06:41 <yeoman> steveo_: on windowss it can't :p?
07:06:43 <yeoman> just kidding
07:06:47 <__monty__> Even with KPTI, steveo_?
07:07:31 <steveo_> yesoman: The chip will still run 5Ghz, you work load will just be slower
07:07:47 <yeoman> lol, okay
07:08:08 <metahumor> EvanR: I only cool my systems with water at triplepoint
07:08:28 <steveo_> Because of the bugs, I consider buying a Threadripper 16core machine. But will it be faster for parallel code? The high performance haskell group said they don't know
07:08:33 <__monty__> metahumor: How's this possible? Cooling without temperature change?
07:08:44 <EvanR> if each serialization takes 1 GHz, then you need to do 1000 GHz.  so at 5GHz thatll take 200 seconds
07:09:06 <metahumor> __monty__: or have an idealized heat bath
07:09:40 <yeoman> next stupid beginner question:
07:09:54 <yeoman> if i can just write X, and Haskell knows it's a Symbol
07:09:54 <EvanR> steveo_: if you write a proper parallel program for a parallelizable problem, yes it will be faster
07:10:10 <yeoman> what if i have multiple datatypes which both have "X"
07:10:15 <EvanR> you cant
07:10:19 <yeoman> Multiple declarations of ‘X’
07:10:30 <yeoman> i see, but.. how does that make sense..  ?
07:10:36 <lines> I've defined this auxilary function in some code: mayEq a b = if a == b then Just a else Nothing
07:10:39 <yeoman> can't i just do X::Symbol
07:10:46 <EvanR> no
07:10:51 <metahumor> yeoman: would it make sense to have multiple definitions of True?
07:10:52 <lines> is there some better way to achieve this?
07:11:09 <EvanR> to disambiguate two X's in two modules, youll need to import them qualified with two different namespaces
07:11:13 <yeoman> metahumor: .. now but.. i might have 2 types... where both have something named "Player"
07:11:16 <yeoman> or something.
07:11:19 <EvanR> Module1.X or Module2.X
07:11:26 <metahumor> EvanR: it is possible with type families...
07:11:26 <EvanR> but you cant declare two X's in the same module
07:11:40 <yeoman> i see.. that's also really weird.. but i get it
07:11:50 <steveo_> EvanR: Thanks. I was just told by the author of Accelerate that sorting isn't possible in Haskell in a performant way. He said only C FFI is working.
07:12:06 <EvanR> you also cant have the same field names in two record types in the same module
07:12:06 <Athas> Er, what?
07:12:23 <Athas> Surely you can sort something like an unboxed vector in Haskell pretty well?
07:12:31 <yeoman> i figured
07:12:33 <steveo_> The conclusion on reddit.com is just that there are too few people using numerical applications in Haskell so it is underdeveloped
07:12:43 <yeoman> i guess because they all have functions.. and are in the same scope
07:12:56 <EvanR> raw number crunching isnt one of haskells strong points
07:13:12 <Athas> steveo_: that is definitely true.
07:13:21 <EvanR> but edward k has nonetheless done some crazy 3D graphics
07:13:28 <metahumor> lines: "f :: Eq a => a -> a -> Maybe a; f a b = do {guard (a == b); return a}"
07:13:29 <Athas> The number crunching libraries for Haskell are pretty immature.
07:13:33 <steveo_> is there a link EvanR?
07:13:44 <Athas> The vector library is mature and really nice and simple to use, though.  But it's not parallel.
07:14:17 <yeoman> what is number crunching is that a sport?
07:14:45 <EvanR> is REPA parallel?
07:14:46 <metahumor> lines: "f a b = guard (a == b) >> return a :: Eq a => a -> a -> Maybe a"
07:14:53 <Athas> EvanR: yes.
07:14:56 <EvanR> good
07:15:04 <Athas> But it is difficult to use.
07:16:01 <EvanR> steveo_: https://github.com/ekmett/quine
07:16:28 <Iceland_jack> metahumor: even [ a | a == b ]
07:16:38 <steveo_> Thanks.
07:16:48 <Iceland_jack> with -XMonadComprehensions
07:16:49 <metahumor> Iceland_jack: "listToMaybe [a | a == b]"
07:16:52 <metahumor> ah
07:16:54 <metahumor> okay
07:17:29 <dexterfoo> i'm using cabal new-build. How do i get the path to the built executable inside the dist-newstyle directory?
07:17:38 <steveo_> The other number crunshing problem is that GPU acceleartion is Nvidia-only. So it's a lock-in. Also there is no SIMD-based sorting lib that I know of.
07:18:30 <EvanR> SIMD, i think you can technically access that stuff with GHC intrinsics
07:18:39 <__monty__> dexterfoo: Nix would leave a result symlink, maybe new-build does too?
07:18:39 <cocreature> dexterfoo: there is not really a nice solution sadly. https://github.com/haskell-hvr/cabal-plan and a bit of shell scripting is your best bet
07:19:36 <hexagoxel> dexterfoo: shell scripting: find dist-newstyle/ -name "$1" -type f | xargs -rx ls -t | head -n1
07:20:45 <yeoman> is there something like an autoload feature for ghci?
07:21:15 <dexterfoo> thanks guys
07:21:19 <metahumor> yeoman: on startup or when?
07:21:25 <yeoman> filesave
07:21:41 <yeoman> i mean :l is great, but having to do it all the time
07:21:50 <metahumor> like a hotload after you change code?
07:21:54 <yeoman> yes
07:22:20 <metahumor> i do ":r" after changing code that's being controlled by stack, and i run ghci using "stack ghci"
07:22:21 <MarcelineVQ> yeoman: check out https://hackage.haskell.org/package/rapid
07:22:37 <glguy_> There's a tool called ghcid for that
07:22:46 <yeoman> thanks together
07:23:10 <MarcelineVQ> ghcid is the better option if you just want ghci to recheck your stuff on code changes
07:23:27 <yeoman> sounds like i want
07:23:34 <yeoman> i don't like big tools
07:23:51 <lines> metahumor: thanks
07:24:22 <metahumor> i have a pretty good time with regular old ghci and vim that asynchronously runs hlint and hdevtools
07:24:51 <metahumor> lines: did you see Iceland_jack's version? it uses MonadComprehensions
07:26:02 <lines> I did not!
07:26:11 <Iceland_jack>     [ a | a == b ]
07:26:13 <Iceland_jack> :--)
07:29:51 <yeoman> how would i do something 100 tiimes to a value in haskell
07:30:03 <yeoman> say, i want to do x**2**2**2.....
07:30:23 <brynedwards> iterate?
07:30:28 <brynedwards> :t iterate
07:30:29 <lambdabot> (a -> a) -> a -> [a]
07:30:32 <Iceland_jack> > iterate (**2) x !! 100
07:30:35 <lambdabot>  ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((...
07:30:38 <Iceland_jack> lol
07:30:40 <brynedwards> :D
07:30:45 <Iceland_jack> > iterate (**2) x !! 10
07:30:47 <lambdabot>  (((((((((x**2)**2)**2)**2)**2)**2)**2)**2)**2)**2
07:32:06 <yeoman> iterate would walk forever?
07:32:10 <yeoman> now that's impressive
07:32:14 <metahumor> yeoman: laziness
07:32:19 <Iceland_jack> > iterate (**2) x
07:32:21 <lambdabot>  [x,x**2,(x**2)**2,((x**2)**2)**2,(((x**2)**2)**2)**2,((((x**2)**2)**2)**2)**...
07:32:30 <lines> Iceland_jack: that's really very neat
07:32:33 <yeoman> yeah i understand it.. but.. that's cool
07:32:45 * Iceland_jack taking credit for Haskell: Thanks!
07:32:48 <lines> I'm not entirely sure how that's working...
07:32:49 <metahumor> Iceland_jack blowing minds on a regular basis
07:33:02 <metahumor> lines: do you mean the MonadComprehension syntax?
07:33:05 <lines> yeah
07:33:12 <yeoman> i tried to do the very same thing in ruby
07:33:20 <lines> like I have made it work! but I want to be sure why it is.
07:33:25 <metahumor> lines: it's just syntactic sugar for my "f a b = guard (a == b) >> return a" defn
07:33:28 <MarcelineVQ> lines: check out the ghc manual's language extensions section
07:33:28 <yeoman> and it was a hassle, that this is a normal thing is really impressive
07:34:03 <metahumor> lines: think of how a regular old list comprehension would work: [a | a == b] would either give you [a] or []
07:34:14 <lyxia> it would probably be a for loop in ruby
07:34:26 <lines> metahumor: I suppose I don't quite get guards
07:34:31 <lines> *guard (not guards)
07:34:43 <metahumor> :i guard
07:34:54 <metahumor> :t guard
07:34:55 <lambdabot> Alternative f => Bool -> f ()
07:35:13 <hyperisco> guard True = return (); guard False = mempty;
07:35:18 <Iceland_jack> You can think of 'guard @Maybe' as
07:35:18 <Iceland_jack>     guard :: Bool -> Maybe ()
07:35:18 <Iceland_jack>     guard True  = Just ()
07:35:18 <Iceland_jack>     guard False = Nothing
07:35:24 <hyperisco> or apparently it is Alternative now
07:35:27 <metahumor> lines: guard takes a Bool (condition), and either exits with "empty" or continues
07:35:28 <hyperisco> and by mempty I meant mzero
07:35:43 <hyperisco> guard True = pure (); guard False = empty;   can't keep up with the times
07:36:23 <hyperisco> had this exact question two days ago I think … should go on a list of answers
07:36:30 <lines> oh I see -
07:36:47 * hackage fx 0.10 - Horizontally composable effects  https://hackage.haskell.org/package/fx-0.10 (NikitaVolkov)
07:36:55 <metahumor> lines: and "empty @Maybe = Nothing", "empty @[] = []"
07:37:15 <lines> got it
07:37:29 <hyperisco> and "exit" refers to laziness as well
07:37:33 <Iceland_jack> Yes so 'guard @[]' is
07:37:33 <Iceland_jack>     guard :: Bool -> [()]
07:37:33 <Iceland_jack>     guard True  = [()]
07:37:34 <Iceland_jack>     guard False = []
07:37:54 <hyperisco> and Monoid/Alternative/MonadPlus laws
07:37:58 <Iceland_jack> It's tricky to think about because () isn't what we care about
07:37:58 <lines> oddly, given another edit I made, my comparison is between two maybes...
07:38:05 <metahumor> so in haskell list comprehension syntax, [ retval | retval <- mylist, condition ], means, give me all the retvals that are in mylist as long as (condition)
07:38:13 <lines> but, you know, that's fine
07:38:26 <hyperisco> I think it is simpler than mfilter but if that helps you, reason with that
07:38:30 <metahumor> lines: do you know how to compare two "Maybe a"s?
07:38:47 <hyperisco> :t mfilter
07:38:48 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
07:38:54 <Iceland_jack> I see lambdabot still doesn't support -XTypeApplications
07:39:07 <lines> well, you could do liftM2 (==) a b
07:39:31 <yeoman> iterate is great if you want to kill your cpu
07:39:40 <metahumor> yeah, but what's cool is that Maybe has an "instance Eq a => Eq (Maybe a)"
07:39:47 <lines> the thing is, I realised I didn't actually need the result afer all
07:39:52 <metahumor> yeoman: only if you force all the thunks
07:39:52 <hyperisco> yeoman, try fix
07:39:52 <lyxia> Iceland_jack: you're back!
07:39:59 <Iceland_jack> lyxia: Yes!
07:40:03 <yeoman> metahumor: what does that mean?
07:40:06 <hyperisco> > fix (+1)
07:40:09 <lambdabot>  *Exception: <<loop>>
07:40:09 <yeoman> i don't have a swap.. and tried something
07:40:13 <Iceland_jack> I've missed #haskell
07:40:24 <hyperisco> maybe GHC will be too smart and give you <<loop>>
07:40:29 <metahumor> yeoman: do you mean you hit a stack overflow?
07:40:32 <yeoman> yes
07:40:42 <yeoman> and it filled my ram.. and my kernel didn't like that
07:40:58 <metahumor> ... because iterate is lazy by default, so it builds up thunks
07:41:04 <lines> ah, so actually I don't need the comprehension. hurrah.
07:41:08 <metahumor> strict iterate is coming in 8.4 i think
07:41:18 <lyxia> Iceland_jack: I'm looking forward to your DeriveVia thing.
07:41:35 <yeoman> metahumor: so that one would drop every value after having iterated over them?
07:41:41 <Iceland_jack> you are?
07:41:57 <yeoman> metahumor: can you define thunk for me?
07:42:16 <lyxia> Iceland_jack: looks like a lot of fun
07:42:27 <Iceland_jack> I'm so into it. It will cut down so much boilerplate for me
07:42:40 <metahumor> yeoman: right now, iterate works like the following -- build up a huge "f (f (f (f (... f (x) ) ) ... )" and then when you ask for it, then it will evaluate it
07:43:01 <lines> (the context: https://pastebin.com/PaaMjsMy)
07:43:06 <yeoman> oh,i expected it to create  alist of results
07:43:15 <metahumor> yeoman: that huge expression is a "thunk". a thunk is a value that is yet to be evaluated
07:43:22 <yeoman> i seeeee
07:43:25 <yeoman> so
07:43:30 <yeoman> reverse . reverse is a thunk?
07:43:42 <metahumor> yeoman: nope, it creates a thunk which is a list of thunks
07:43:56 <metahumor> yeoman: reverse . reverse by itself is a function
07:44:19 <hyperisco> (.) is non-strict on its arguments
07:44:20 <yeoman> so [reverse.reverse,reverse.reverse.reverse] is a thunk?
07:45:01 <metahumor> yeoman: basically, everything is a thunk. but when you submit it in ghci, it gets forced so it can show you the result
07:45:19 <metahumor> unless you do something like "> x = 1 + 2; >:sprint x"
07:47:17 <hyperisco> I wouldn't bother thinking about thunks because they mean nothing
07:47:43 <yeoman> i like understanding thinks
07:47:43 <hyperisco> it is a detail of how laziness is implemented
07:48:01 <metahumor> hyperisco: they mattered in this case because of the way "iterate" made yeoman's ghci stack-overflowq
07:48:21 <yeoman> and it explained to me what iterate does at all
07:48:35 <yeoman> i even thought it's just saving values and reapplying the function to it
07:48:44 <hyperisco> helps explain the SO but does not tell you what iterate does
07:49:01 <hyperisco> unless by "does" you mean how it runs on the computer
07:49:03 <yeoman> but that it's creating a "call-list"
07:49:08 <yeoman> hyperisco: well, it did.
07:49:09 <metahumor> yeoman: could you write out a simple definition for "iterate" that is lazy?
07:49:14 <MarcelineVQ> there's a good overview of what thunks are here if you get curious, but don't let it sidetrack you. don't be scared of the title  http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-whnf
07:49:17 <hyperisco> well then you probably got the wrong idea
07:49:36 <yeoman> hyperisco: okay
07:50:59 <raek> yeoman: have you seen this? https://www.vex.net/~trebla/haskell/lazy.xhtml
07:52:28 <yeoman> raek: i am super new to haskell so i haven't seen a lot of things
07:52:35 <yeoman> metahumor: i guess so
07:52:54 <hyperisco> iterate f x  is the list  x : f x : f (f x) : f (f (f x)) : ...  and that is what is important
07:55:59 <hyperisco> if you run your program and you get no output, or an exception due to a missing case, then maybe we need to look closely at strictness
07:56:10 <hyperisco> that's still a semantic question
07:56:52 <hyperisco> if we run our program and it takes too long, or we run out of memory, then we investigate how the compiler chose to implement our program, and that's a completely different domain of questions and answers
07:58:18 <hyperisco> but unless there is a compiler flag or some such we can tweak, the fixes we end up making tend to be semantic changes, but this is an accident of how our program runs on the computer
07:59:28 <hyperisco> so stack overflows might be because a non-strict definition ends us up with a program, after compiling, that runs out of stack space
07:59:56 <hyperisco> but it is conflated to think strictness has to do with memory consumption, for example
08:03:31 <metahumor> i just did a "stack install hoogle", and am trying "stack exec hoogle -- generate" but i'm getting a segfault. anyone familiar with cli hoogle?
08:07:49 <brynedwards> I think stack install copies binaries to $HOME/.local/bin so you'd add that to your path and run hoogle directly
08:08:24 <brynedwards> although if the hoogle binary is segfaulting that probably won't help
08:08:31 <metahumor> i tried a plain "hoogle generate", still segfault
08:09:51 <brynedwards> Does it give any output at all? Mine says 'Starting generate' at the beginning. Maybe try passing -v?
08:17:13 <metahumor> it segfaults after "Downloading https://www.stackage.org/lts/cabal.config..."
08:21:09 <Linat0k> nyone know how i ca mine web cookies/
08:21:20 <Linat0k> is there a mining pool where i can mine browser cookies?
08:21:35 <Linat0k> how much are thye worth?
08:21:55 <Linat0k> because scanbot spy and destroy say i have 32,3414 cookies
08:22:17 <s4ke> what was the haskell offtopic irc?
08:22:33 <nullie> #haskell-offtopic
08:22:35 <MarcelineVQ> they're worth so little you've lost money checking how many you have
08:27:11 <Linat0k> :'(
08:29:46 <redrapscallion> when dealing with records, is it best practice to just put each record as its own module to avoid name conflicts?
08:29:58 <redrapscallion> or is there some sort of other best practice method?
08:32:21 <metahumor> redrapscallion: have you used -XOverloadedRecordFields? I don't know how often people use that
08:36:57 <cocreature> redrapscallion: prefixing record fields to make them unique is relatively common albeit annoying. the DuplicateRecordFields extension is another solution if you use ghc >= 8.0. “classy lenses”, i.e., typeclasses that provide lenses for record fields are also relatively commmon
08:37:13 <glguy> redrapscallion: Best is to use unique names for the various fields so that when reading code its easier to know what you're looking at without having to check imports or types
08:41:17 * hackage vty 5.19.1 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.19.1 (JonathanDaugherty)
08:42:30 <Eduard_Munteanu> If we had better module support we could just define record types in separate modules.
08:43:45 <Eduard_Munteanu> And use qualified names.
08:58:14 <klntsky> Hi. Is it possible to prevent type unification when I use two similarly defined type synonyms? E.g. I have type A = SomeType; type B = SomeType; and some f :: A -> AnotherType. I need to disallow expressions like `f (x::B)`
08:59:00 <Iceland_jack> You want `newtype', type synonyms are only aliases
08:59:16 <Iceland_jack> Alternatively you could tag it with something
09:02:29 <klntsky> I forgot to mention that SomeType is a type of function. Seems like `newtype B = SomeType -> SomeType` is not allowed.
09:02:53 <dmwit> newtype B = B SomeType
09:02:56 <Iceland_jack>     newtype B = MkB (SomeType -> SomeType)
09:04:36 <klntsky> thanks.
09:15:17 <tomlukeywood> if i am right in thinking haskell has no variables
09:15:17 <tomlukeywood> how do you implement something like chess where each square of a board can have a different state?
09:16:03 <lyxia> (\x -> x)  -- how is x not a variable
09:16:47 * hackage iri 0.2 - RFC-based International Resource Identifier library  https://hackage.haskell.org/package/iri-0.2 (NikitaVolkov)
09:16:52 <Iceland_jack> tomlukeywood: https://stackoverflow.com/questions/993124/does-haskell-have-variables
09:16:57 <tomlukeywood> thanks
09:16:58 <mniip> tomlukeywood, how are variables involved in a chessboard
09:17:18 <tomlukeywood> mniip: diffrent states for each square (pawn, knight etc)?
09:17:26 <mniip> so?
09:18:30 <tomlukeywood> mniip: so if states must vary you must use a variable that can vary at runtime?
09:18:38 <mniip> no
09:19:05 <tomlukeywood> how?
09:19:15 <mniip> you can have a variable in lyxia's sense
09:19:26 <mniip> that will "vary" during various invocations of your function
09:19:35 <mniip> and you can arrange the program so that it does
09:19:41 <mnoonan> old world in, new world out
09:19:55 <tomlukeywood> oh that makes sense
09:21:49 <tomlukeywood> mnoonan: if its old world in new world out i assume you would not have a variable called WORLD
09:21:49 <tomlukeywood> how would you store the world in this situation?
09:22:03 <prz> @pl \xs n -> take n xs
09:22:03 <lambdabot> flip take
09:23:08 <prz> @pl s#n -> take n xs
09:23:08 <lambdabot> (line 1, column 7):
09:23:08 <lambdabot> unexpected '>'
09:23:08 <lambdabot> expecting operator
09:23:14 <prz> @pl f s n -> take n xs
09:23:14 <lambdabot> (line 1, column 9):
09:23:14 <lambdabot> unexpected '>'
09:23:14 <lambdabot> expecting operator
09:23:21 <prz> @pl f s n = take n xs
09:23:21 <lambdabot> f = const (flip take xs)
09:23:41 <prz> @pl a@(c:s)`g`n=s`g`n||n`take`a==(c<$[1..n])
09:23:41 <lambdabot> (line 1, column 13):
09:23:41 <lambdabot> unexpected "s"
09:23:49 <lyxia> prz: you can privmsg lambdabot
09:23:55 <prz> @pl g a@(c:s) n=g s n||n`take`a==(c<$[1..n])
09:23:55 <lambdabot> (line 1, column 13):
09:23:55 <lambdabot> unexpected "g"
09:24:07 <prz> @pl g a@(c:s) n=n`take`a==(c<$[1..n])
09:24:08 <lambdabot> (line 1, column 13):
09:24:08 <lambdabot> unexpected "n"
09:24:09 <mniip> tomlukeywood, you don't store it
09:24:18 <lyxia> prz: now you're spamming
09:24:18 <mniip> you pass it on
09:24:26 <prz> sry
09:24:47 * hackage gauge 0.2.0 - small framework for performance measurement and analysis  https://hackage.haskell.org/package/gauge-0.2.0 (VincentHanquez)
09:24:58 * tomlukeywood 's mind is being blown
09:26:51 <mnoonan> tomlukeywood: you might like to watch this short video of somebody writing a tictactoe game in Haskell: https://www.youtube.com/watch?v=P0_rIm9ntiQ
09:27:07 <tomlukeywood> mnoonan: thanks i will
09:27:27 <[exa]> tomlukeywood: don't worry about the storing world, it stores itself in the state you left it
09:27:37 <mnoonan> it uses TDD, so you can get an idea of what he is about to do as he is writing, and you can see how the game state is represented by the Position type
09:35:35 <mniip> mnoonan, do people actually have such a workflow
09:35:55 <mnoonan> not to that degree
09:36:27 <mnoonan> (er, I mean, *I* don’t to that degree)
09:36:47 <mniip> I mean being a lazy person I'd save 70% of the time by not writing thorough tests
09:36:51 <mniip> but rather just randomly poking it in ghci
09:36:55 <Linat0k> guys guys what does it mean when the computer asks if i want to restore system settings, surly the computer already has settngs?
09:37:11 <Linat0k> like i already set the mouse speed
09:37:35 <Linat0k> btw good news i phoned sky, i can watch porn again !
09:38:02 <koala_man> do you need their permission?
09:38:31 <[exa]> ops maybe?
09:50:12 <yoho> koala_man: some shitty providers filter your connection by default without asking
09:50:48 <yoho> my old mobile data provider did it and continued to do it after I went in in person and provided ID to tell them to stop (it also blocked a bunch of random non-nsfw/whatever sites)
09:52:47 <royal_screwup21> as I understand it, if I do: func $ stuff, a function is applied one argument, stuff. What if func accepts two arguments? I know you can do func stuff second_arg, but let's say I want to wrap stuff with the "$" operator. Doing func $ stuff second_arg doesn't accomplish that, because that's saying "apply stuff on second arg , then pass the result of
09:52:47 <royal_screwup21>  that to func.
09:53:37 <Adluc> Hello guys, I use in state monad: modify $ quadrantMode . _Just .~ qm -- for some reason, it does not modify actually, any ideas please?
09:53:37 <tput> All functions in haskell are unary, they n-ary functions return (n-1)-ary functions when applied to a single argument
09:53:43 <hexagoxel> royal_screwup21: why do you want to use ($) in that case?
09:56:15 <lyxia> Adluc: modify $ quadrantMode .~ Just qm
09:56:23 <royal_screwup21> hexagoxel: because in my specific case, "stuff" is a function that takes in argument. So: my whole function actually looks somewhat like this: func (stuff arg_for_stuff) arg_for_func. I wan to use $ to eliminate the need for the bracket
09:56:45 <Adluc> lyxia: thanks! :)
09:56:53 <Adluc> overengineered it as usually
09:56:57 <hexagoxel> royal_screwup21: it is not like parens are evil..
09:57:21 <hexagoxel> you could to `flip func arg $ stuff arg_for_stuff` if you really want
09:57:22 <mnoonan> yeah, this is a perfect example of where you don’t want to use $
09:57:49 <mnoonan> at the very least, whatever you figure out will involve >= 1 more character, so parens would be both clearer *and* shorter
09:58:08 <royal_screwup21> alrighty thanks guys
09:59:17 <hexagoxel> when stuff is not one-line, i can see a case for avoiding parens. but flip will indeed make things less readable most of the time.
09:59:49 <surehask> hello world, anyone knows if enabling optimisations in ghc completely solves the space leak problem?
10:00:59 <lyxia> no it does not
10:01:04 * royal_screwup21 waits for a sarcastic remark on the "hello world" greeting
10:03:03 <robbym> Is parsec the go-to parser lib?
10:06:08 <liste> robbym: check out megaparsec
10:06:08 <surehask> thanks
10:06:08 <liste> it's a more maintained fork of parsec
10:06:08 <johnw> robbym: it's my goto for starting out, because it's simple and there are other tools available for it
10:06:08 <johnw> but if things get serious, I switch to parsers or megaparsec
10:06:51 <surehask> i am looking for an example where optimisations from ghc are unable to fix space leaks, any good starting point?
10:07:04 <johnw> you want to create a space leak?
10:07:49 <surehask> i can create a leak by letting a thunk grow, but upon optimisation, ghc fixes it
10:08:02 <johnw> read in 10 mb of data and assign "length myData" in some tuple.  You'll now keep that 10 mb stuck in the heap until you evaluate that member of the tuple
10:08:17 <johnw> myData <- readFile "foo"; return (myData, ())
10:08:25 <nshepperd> i've been using parsers mainly for writing parsers recently, and parsec for the impl
10:08:29 <johnw> there are a few different kinds of space leaks, mind you
10:08:38 <nshepperd> does megaparsec have `parsers` instances?
10:08:46 <johnw> nshepperd: I'm not aware of them
10:08:54 <johnw> plus, with parsec now you get to use parsec-free to debug your grammar
10:09:19 <surehask> cool, because the reference to that object will remain live, thanks i get it
10:12:07 <johnw> different space leaks: (a) thunks that trap more heap data than they will need, (b) making lots of thunks, (c) holding discriminees on the stack due to lots of recursion, (d) churning memory by breaking fusion, thus causing lots of temporary values to pop in and out of existence
10:12:29 <johnw> there are slightly different techniques for discovering and narrowing each of these cases, although I think most people call all but the last one "space leaks"
10:12:55 <johnw> (d) is noticeable when your program uses only 10 mb resident, say, but the profile says it allocated 80 GB during the run
10:13:27 <johnw> to me it's a kind of space leak, it just doesn't inflate the total size of either the heap or the stack
10:14:53 <surehask> ok
10:16:08 <surehask> foldl (+) 0 [1..10000] , will you consider this as a leak of type a or b
10:16:27 <johnw> (b)
10:16:38 <johnw> because you are strict in the spine, but lazy in the elements
10:16:55 <johnw> i.e., your foldl produces N thunks
10:17:40 <johnw> foldr works better here because it only makes a single top-level thunk, waiting for you to force the computation
10:17:53 <johnw> oh, wait, scratch that
10:17:53 <surehask> so each of the (+) operations is a thunk and has one argument as a thunk, when using foldl
10:17:59 <johnw> + is not like :
10:18:04 <johnw> yes
10:20:47 * hackage hocker 1.0.4 - Interact with the docker registry and generate nix build instructions  https://hackage.haskell.org/package/hocker-1.0.4 (ParnellSpringmeyer)
10:21:04 <metahumor> robbym: I use megaparsec with a locally defined "type Parser = Parsec Void String"
10:21:17 <surehask> i am trying to study how ghc performs memory allocation
10:21:49 <johnw> surehask: have you read Joachim's thesis?
10:22:07 <johnw> http://www.joachim-breitner.de/thesis/Diss-Breitner-Published.pdf
10:22:20 <johnw> "Lazy Evaluation: From natural semantics to a machine-checked compiler transformation"
10:23:40 <surehask> johnw: that looks very useful, thanks
10:30:35 <Linat0k> linat0
10:31:13 <mnoonan> so I did a little grepping through hackage, and it looks like almost 1/3 of the uses of \case are of the form “foo >>= \case …”.
10:32:01 <mnoonan> iow, it isn’t being used as an anonymous function but only as a way to pattern match inside a monadic value
10:32:17 * hackage HappyTree 0.2018.1.5 -   https://hackage.haskell.org/package/HappyTree-0.2018.1.5 (MarisaVeryMoe)
10:32:53 <metahumor> what would you prefer?
10:33:33 <mnoonan> I’m not sure. “case <- monadicValue of …“ maybe?
10:34:19 <metahumor> ReverseViewPatterns? "case (vfoo<-foo) of ..."?
10:36:29 <mnoonan> metahumor: ghc pragmas are indistinguishable from satire, I had to check if that was real.
10:36:39 <fizbin> Hey, this is a bit of a long shot, but is anyone here looking for a job, ideally in or near Minneapolis? We're trying to hire someone and finding people who are senior level, know Haskell, and want to change jobs is difficult. We're also looking for someone who is (or can become) Minneapolis-local, more junior level, wants to change jobs and knows Haskell.
10:36:44 <mnoonan> but anyway, the point is not having to bind a name to the result
10:37:32 <metahumor> "mcase foo of ..."
10:38:28 <metahumor> a lot of cases where people would still like to have access to the result through some name
10:39:22 <mnoonan> for that, you’d just do the normal “name <- foo; case name of ..”. But the “foo >>= \case …” idiom is only used when you *don’t* want to name the plumbing.
10:42:02 <cocreature> fizbin: what kind of work do you do?
10:43:30 <fizbin> cocreature: See https://www.crowdstrike.com/careers/?p=job%2Foakp6fwJ
10:45:13 <cocreature> fizbin: looks interesting! too bad I’m still a few months away from finishing my masters
10:46:38 <cocreature> fizbin: you might also want to try advertising on /r/haskell.
10:48:26 <fizbin> cocreature: Huh. It hadn't occurred to me to look at reddit, but maybe I can look there too.
10:51:41 <binaryblade_> anyone have any good pointers or libraries for doing numerics work in haskell.
10:52:06 <metahumor> low-level or high-level?
10:52:35 <binaryblade_> well, say given a geometry compute the laplacian eigenmodes
10:52:38 <binaryblade_> that sort of thing
10:52:49 <binaryblade_> quickest route to toast
10:53:14 <cocreature> fizbin: job ads are quite common on /r/haskell
10:53:35 <binaryblade_> was looking at accelerate and repa, but was wondering if there were higher level stuff built on top
10:53:44 <metahumor> hmatrix is nice
10:53:52 <metahumor> for linear algebra based stuff
10:54:13 <metahumor> depends on how performant you want it to be, or how expressive. i've been meaning to play around more with hTensor too
11:00:12 <binaryblade_> will look at hTensor
11:00:21 <binaryblade_> but thats all cpu based is it not?
11:00:38 <metahumor> yeah
11:01:02 <Xal> is there a nice way of doing case on a monadic value?
11:01:33 <binaryblade_> accelerate and repa seem to do GPU / multicpu offloading automatically which is nice
11:01:49 <binaryblade_> but I guess there is not solution yet to sort of bridge the linalg domain with that
11:02:00 <geekosaur> Xal, LambdaCase extension?
11:02:02 <hyperisco> Xal, sure, what is the type?
11:02:06 <mnoonan> Xal: I was literally just talking about that 30 minutes ago :)
11:02:09 <metahumor> dataHaskell people work on that
11:02:17 <metahumor> re binaryblade_
11:02:34 <mnoonan> action >>= \case …
11:02:43 <Xal> geekosaur: well I need to work on my [gh]oogle skills.  that's exactly what I need, thanks!
11:03:40 <mnoonan> twice in an hour.. I’m taking it to the tweets https://twitter.com/BanjoTragedy/status/949350818460917760
11:06:32 <MarcelineVQ> Just what haskell needs, more syntax ^^;
11:07:00 <mnoonan> heh
11:08:57 <pavonia> Why is "foo >>= \case ..." not an anonymous function?
11:09:18 <amalloy> mnoonan: what do you mean, not being used to introduce an anonymous function? foo >>= \case ... is as much an anonymous function as any use of \case i can imagine
11:10:32 <fizbin> cocreature: There is the slight problem that mentioning my employer on reddit brings out the serious crazies. Not so much in /r/haskell , but if you search reddit overall for the company I work for, most of the results are *way* far out there.
11:10:50 <mnoonan> amalloy: actually, almost all of the other 2/3 appears in the form “something = \case …” So maybe I should say “\case is essentially never used to introduce an anonymous function”.. it’s always either named, or used for the bind-plumbing thing
11:11:15 <mnoonan> not many instances of writing (\case …) as a parameter to some other function, for example
11:11:28 <amalloy> mnoonan: what is a use case that you *would* consider being "used to introduce an anonymous function"?
11:11:32 <MarcelineVQ> fizbin: Sekret Machines?
11:11:57 <amalloy> since in your first example (\case ...) is indeed a parameter to some other function, namely (>>=)
11:12:02 <mnoonan> amalloy: something like “map (\case Just _ -> 1; Nothing -> 0)”
11:12:30 <metahumor> "\case" is useful wrt singletons, a la jle`'s blog post
11:12:32 <mnoonan> amalloy: fair enough, but I think it is clear that >>= \case together are forming one idiom
11:14:00 <metahumor> mnoonan: the only thing you've ever considered tweeting about?
11:14:29 <mnoonan> metahumor: I only tweet when it is -30 out
11:15:55 <metahumor> uhh did you mean (negate 30)? =P
11:17:34 <amalloy> that's fair, mnoonan. i certainly feel silly when i have to write foo <- x; case foo of ...
11:19:49 <mnoonan> it looks like most of the remaining instances are either things like “forM_ xs $ \case …”, “withMVar foo $ \case …”, or, in last place, “filter (\case ..)”, “fold (\case ..)” etc
11:21:22 <hyperisco> mnoonan, I thought this already was syntax, or at least proposed
11:21:49 <mnoonan> hyperisco: that’s interesting, I kind of had that feeling too but couldn’t dig up any references
11:22:42 <yoho> MarcelineVQ: CrowdStrike, bunch of conspiracy theories it looks like
11:23:23 <hyperisco> or maybe it was just someone talking about it… maybe it was you!
11:24:05 <MarcelineVQ> I'm paranoid they say, but am I paranoid enough?
11:25:29 <metahumor> how does the new version of megaparsec help with leakiness? it switched to monadic versions of "some" and "many", using MonadPlus instead of Alternative
11:26:19 <hyperisco> case x <- m of e  desugaring to  m >>= \x -> e  seems reasonable
11:26:49 <hyperisco> but I have never extended GHC so…
11:27:06 <mnoonan> oh, I just found a language report for Habit (a Haskell-ish language), and apparently they have this with exactly the same “case <- foo of” syntax
11:27:28 <mnoonan> (and also a monadic “if” with similar syntax)
11:27:37 <hyperisco> sorry I mean… desugar to  m >>= \x -> case x of e
11:28:17 <hyperisco> and then if you don't want the variable you write   case _ <- m of e  and I suppose  case <- m of e  could be supported
11:32:45 <woodson> Happy New Year everyone! Question, has anyone ever used miso framework? If yes, what are the advantages of miso framework over elm ?
11:33:20 <woodson> is it ready to at least deploy is small web app ?
11:34:38 <bodisiw> woodson, i am intrigued by it, but couldn't figure out anything (because i'm a haskell noob maybe, or nix)
11:35:22 <bodisiw> but there's a small #haskell-miso channel
11:39:37 <metahumor> is there an equivalent to (comparing) for Eq? "a -> a -> Bool"?
11:40:09 <MarcelineVQ> ==
11:40:21 <amalloy> metahumor: (==) `on` f
11:41:04 <MarcelineVQ> doh, misunderstood the question, read it as compare
11:41:44 <metahumor> thanks, that's what I was using, I just liked something about "compare = comparing fst"
11:42:08 <Welkin> woodson: I haven't used it yet, but have been meaning to. It can be a pain to get ghcjs set up for sure
11:42:39 <Welkin> miso is the elm architecture implemented in haskell
11:42:55 <Welkin> I have built elm projects before, and quickly ran into major limitations of the language and ecosystem
11:42:58 <Welkin> it's just not there
11:43:06 <Welkin> the languge is missing too many basic features
11:43:11 <Welkin> the library support is not there
11:43:18 <Welkin> it is a huge pain to do FFI with javascript
11:43:27 <Welkin> I would forget about elm and use miso
11:47:52 <lavalike> metahumor, amalloy, I sometime wish   equating = on (==)   (:
11:56:37 <metahumor> why does the following work, but the other version does not?
11:57:07 <royal_screwup21> the type definition for map is: (a->b) -> [a] -> [b]. What does (a->b) mean?
11:57:16 <geekosaur> a function from a to be
11:57:22 <metahumor> "parseValue = choice [V2 <$ char '2', V3 <$ char '3']" but not "parseValue = choice $ (<$ char) [minBound .. maxBound] "23""
11:57:57 <royal_screwup21> geekosaur: hmm so if I do map(+3) [1,2,3] -- what does (a->b) mean in that context?
11:58:12 <metahumor> i'm getting a "Couldn't match type 'Token s0' with 'Char'"
11:58:28 <metahumor> but it does work if i expand the lambda to (\v c -> v <$ char c)
11:59:34 <yoho> :t (+3) -- royal_screwup21 does this answer your question?
11:59:34 <lambdabot> Num a => a -> a
11:59:52 <geekosaur> royal_screwup21, b is forced to be the same as a by the type of (+), and gains a (Num a) constraint
11:59:57 <geekosaur> :t map (+3)
11:59:58 <lambdabot> Num b => [b] -> [b]
12:00:09 <geekosaur> or b, if it typechecked in that order
12:00:21 <geekosaur> (alpha renaming means it's the same thing anyway)
12:00:44 <royal_screwup21> alrighty
12:02:06 <MarcelineVQ> metahumor:  :t (<$ char)  and  :t \v c -> (v <$ char c)  are not the same
12:02:08 <amalloy> metahumor: i don't think (<$ char) is the same as (\v c -> v <$ char c). the latter is (v <$ (char c)), and the former is ((v <$ char) c)
12:02:30 <timhae2> Hey, quick question: I am reading http://learnyouahaskell.com/types-and-typeclasses and at the bottom it says: the length function has a type declaration of length :: [a] -> Int instead of having a more general type of (Num b) => length :: [a] -> b. Shouldn't the second part read length :: (Num b) => [a] -> b?
12:02:32 <metahumor> right, i'm mixing up left-fixity and right-fixity
12:03:14 <geekosaur> timhae2, yes
12:03:22 <timhae2> alright, thanks :)
12:03:41 <metahumor> amalloy, MarcelineVQ, think I should leave it in the expanded form or pointfree it?
12:03:45 <geekosaur> author vanished, nobody's maintaining it
12:03:58 <Welkin> lol
12:04:07 <Welkin> why was it that he disappeared again?
12:04:09 <MarcelineVQ> metahumor: depends how okay you are with flip
12:04:12 <amalloy> @pl \v c -> (v <$ char c)
12:04:12 <lambdabot> (. char) . (<$)
12:04:21 <Welkin> didn't like the attention?
12:04:22 <amalloy> which looks more readable to you
12:04:25 <metahumor> lol
12:04:42 <timhae2> geekosaur: too bad, seems like a really good tutorial
12:04:51 <metahumor> (.).(.)
12:05:01 <geekosaur> actually it's fairly crap. great grand tour, lousy for actually learning how to use the language
12:05:12 <timhae2> what do you recommend?
12:05:19 <metahumor> haskellbook!
12:05:34 <metahumor> "Ed, man! man ed
12:06:11 <timhae2> metahumor: do you mean this: http://haskellbook.com/ ?
12:06:53 <metahumor> yeah
12:07:46 <Athas> binaryblade_: for some reason people have built fairly little on top of Repa/Accelerate.
12:07:48 <timhae2> 60$ dollars is a bit much, I just want to get a taste of the language :D but thanks for your recommendation
12:09:09 <Welkin> timhae2: all of the best materials for learning basic haskell are going to be books that you pay for
12:09:49 <eschnett> timhae2: can you get a library to order the book, and then borrow it there?
12:10:07 <timhae2> eschnett: great idea! will ask at my university
12:10:07 <amalloy> do we really hate LYAH? it's old but i thought it was still pretty good
12:10:18 <Welkin> LYAH is enough to get started, but not to really learnin haskell
12:10:32 <amalloy> sure, you'll need something more
12:10:40 <Welkin> most of the books are between $40-$60
12:10:47 <Welkin> that is not expensive for a good book
12:11:18 <Welkin> the upenn course is good for exercises to get started
12:11:35 <Welkin> it links to LYAH and the free Real World Haskell book (which is pretty outdated by now)
12:11:52 <amalloy> but i think it's pretty reasonable to read LYAH to decide if you're going to like the language. i agree buying a textbook for $60 is quite reasonable, but there's no need to be like "oh i can't learn haskell for free because this LYAH thing is apparently awful"
12:11:53 <timhae2> Welkin: thanks, will try that as well
12:12:37 <geekosaur> again: it's a grand tour. you need something else to learn how to actually write haskell code
12:13:14 <timhae2> gekoosaur: and what would you recommend besides the already mentioned stuff?
12:13:23 <timhae2> geekosaur: and what would you recommend besides the already mentioned stuff?
12:13:53 <geekosaur> I'm partial to Hutton's Progrmaming in Haskell, but it's also an expensive textbook
12:14:24 <geekosaur> the Haskell wikibook is apparently okay (not great, but better than LYAH) as far as free resources go
12:14:37 <geekosaur> @where cis194
12:14:38 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
12:14:49 <geekosaur> ^ the upenn course Welkin mentioned
12:14:57 <timhae2> thanks so much
12:15:06 <Welkin> I started with LYAH
12:15:14 <Welkin> use it until it is no longer useful
12:15:16 <Welkin> then find more
12:15:17 <timhae2> I think I have quite some material to go through now
12:15:21 <Welkin> I started with all free material
12:15:33 <Welkin> in fact, I never spent any money on learning haskell
12:15:40 <Welkin> but that is "the hard way"
12:15:46 <Welkin> a book will help save you a lot of time
12:16:00 <Welkin> I mostly read blog posts, asked question in here, read source code, etc
12:16:02 <Welkin> used free books
12:16:14 <amalloy> i bought a hardcopy of RWH for some reason
12:16:57 <hyperisco> I never read a single book on Haskell… *shrug*
12:16:58 <geekosaur> "Gentle" Introduction followed by diving into xmonad because sjanssen needed X11 help :)
12:17:23 <amalloy> imo doing exercises is very valuable, whether they're the exercises from a book or from somewhere else
12:17:31 <geekosaur> but I already had lots of languages under my belt and was able to read (but not write) SML from exposure
12:19:11 <timhae2> actually, I am using xmonad as well and a friend sent me a few usefull codesnippets, thats why I wanted to learn
12:22:54 <Psybur> > let (r,_,_) = foldr (\x (l,f,g) -> (f x : l,g,f)) ([],(*2),(*3)) [1,3,6] in r
12:22:56 <lambdabot>  [2,9,12]
12:29:16 <kakashiA1> stupid question, but what is the name of -> in haskell? and how do you read it?
12:30:04 <amalloy> https://stackoverflow.com/q/7746894/625403
12:30:52 <Welkin> kakashiA1: "yields"
12:30:54 <amalloy> it's not really answerable anyway, since -> is used in at least three different ways that i can think of
12:31:08 <kakashiA1> amalloy: thanks, you read -> as "to" but what is the name of it? (arrow operator?)
12:31:09 <amalloy> a -> b, \x -> y, case foo of x -> y
12:31:10 <Welkin> spj pronounces it as "yields"
12:31:12 <Welkin> at least
12:31:19 <Welkin> when used with a lambda
12:31:41 <amalloy> i dunno, i've never needed to give it a name
12:31:49 <amalloy> its name is ->
12:31:54 <orion> Hmm. Let's say I have a pool of threads over which I want to distribute work. In theory, I could create a TQueue (IO Foo). Or, I could create a TQueue (Arg1, Arg2, Arg3) and call a function f :: Arg1 -> Arg2 -> Arg3 -> IO Foo. Both would achieve the same effect, but what are the pros and cons of each approach?
12:32:24 <kakashiA1> okay, thanks :)
12:32:34 <amalloy> orion: the most obvious one to me is that the latter allows for more introspection. you can look through the queue and see what work needs to be done
12:32:56 <orion> True.
12:33:12 <mnoonan> you may be able to GC the args with the first one
12:33:44 <mnoonan> i guess it depends on how forcey everything is
12:34:09 <amalloy> mnoonan: you mean if f x y = go (work x y) where go z = ...?
12:34:31 <orion> In my case, I need every single value.
12:36:49 <mnoonan> amalloy: I think I’m going to walk back on that, it seems like you’d usually just get some thunks that hold references to the parameters anyway
12:37:49 <amalloy> usually, yes
12:38:01 <metahumor> is there a GHC difference between the two, if "f' = uncurry (uncurry f)"
12:38:31 <lyxia> orion: the difference will be negligible if at all noticeable
12:39:06 <amalloy> what i was trying to get at was even if you could gc the parameters, it'd just mean there'd be some other value, computed from the GC'd parameters, that you can't GC, and you don't know which is bigger anyway
12:39:27 <mnoonan> ah, i see
12:50:18 * hackage category 0.2.0.1 - Categorical types and classes  https://hackage.haskell.org/package/category-0.2.0.1 (MatthewFarkasDyck)
12:53:06 <s4ke> mnoonan: parens also dont look fugly if you use them a lot
13:00:41 <sqooq> i'm back
13:00:55 <sqooq> I think I have given up
13:00:59 <sqooq> I just want to do a c binding or something
13:01:17 <sqooq> actually not even, idk how that would work.
13:06:58 <sqooq> is there a way to write a function to access an ioref that doesn't exist yet
13:07:34 <amalloy> what do you imagine would happen if you called that function before the ioref exists?
13:07:48 <sqooq> mein gott
13:08:04 <sqooq> there's got to be some way to do what I want to do, this is starting to drive me absolutely nuts.
13:08:28 <sqooq> so I always have to pass the IOref around?
13:08:34 <sclv> well, yeah
13:08:36 <sclv> in general
13:08:39 <sclv> i mean.. what do you want to do?
13:08:51 <sqooq> Can I make the function create an IORef, but then when it gets called again, it doesn't make a new one/overwrite the old one
13:09:00 <sclv> (there's a way to do a top level mvar or ioref using unsafeperformio)
13:09:05 <amalloy> it has to get to the function somehow. that could be via passing explicitly, or by using State or Reader or something
13:09:07 <sclv> (its used for building c bindings)
13:09:08 <sqooq> it just reads and writes the one that already exists
13:09:23 <sclv> (but i wouldn't recommend it for your own api)
13:09:45 <mnoonan> I’m missing the context, what are you trying to do that led to this design?
13:09:51 <sqooq> delay
13:09:55 <sqooq> sample delay
13:10:10 <sqooq> it's done in C perhaps like https://ccrma.stanford.edu/~jos/pasp/Software_Delay_Line.html
13:10:15 <geekosaur> had you considered creating the IORef as a Maybe something?
13:10:35 <sqooq> :thinking:
13:10:44 <sqooq> How does that help?
13:11:06 <sqooq> also if I do this IO stuff, but my other functions are pure, do I have to like... make all the other one's io too?
13:11:14 <sclv> yes
13:11:23 <sclv> but why not just pass around the state explicitly with no ref?
13:11:53 <sqooq> i don't know how
13:11:54 <geekosaur> you're not going to be able to do much in Haskell if you can;t escape C think
13:12:05 <sqooq> I learned C months after I learned haskell
13:12:14 <sqooq> Haskell was my first language
13:12:20 <geekosaur> "Nothing" is equivalent to nil/NULL/undefined/whatever
13:12:21 <sqooq> I just can't figure out how to do this nicely
13:12:28 <sclv> can you explain more clearly what the sample delay thing is you want to write
13:12:33 <geekosaur> if you need more than that then you are thinking about it wrong and no language will help you
13:12:37 <sclv> you're writing a synth or something?
13:12:50 <sqooq> sclv, a general purpose library
13:12:55 <sclv> for what
13:13:00 <sqooq> audio synthesis
13:13:05 <sqooq> and processing in general
13:13:47 <sclv> ok, imagine you had some top level mutable state. what would you put in it, and when would you read it, and when would you modify it
13:14:01 <infinisil> sqooq: Something like this should do: delay :: a -> State [a] a
13:15:12 <infinisil> that is, a function that receives an a and returns a computation that changes the state of an array of a's and returns an a
13:15:17 <sqooq> sclv, I don't think that works either, because what if I have a bunch of delay functions, I don't want to explicitly make a new storage for each one
13:15:23 <sqooq> top-level
13:15:25 <mnoonan> what about just using a queue?
13:15:42 <sqooq> also I am still pretty novice
13:15:48 <sclv> ok, what does a delay function do, conceptually
13:15:50 <sqooq> like I've been just using work arounds to get things done
13:15:53 <sqooq> but it's not pretty
13:16:00 <sqooq> basically just explicit recursion
13:16:21 <sclv> so one thing you can try, is write the ugly thing with explicit recursion
13:16:23 <sclv> and lpaste it here
13:16:28 <sclv> and people can talk you through how to clean it up
13:16:35 <sclv> its just not clear at all what you want to write
13:16:36 <mnoonan> i mean, really it seems like you should take it from the top level:
13:16:39 <sqooq> sclv, it takes a single at time t and outputs it t+N time later
13:16:44 <sqooq> signal***
13:16:51 <sqooq> aka a single number
13:17:00 <sclv> ok, how does it "output" it
13:17:02 <sclv> if it is pure?
13:17:08 <mnoonan> @let delay n f = \k -> f (k - n)
13:17:10 <lambdabot>  Defined.
13:17:17 <dmwit> sqooq: I have a great function for that. `delay n (t, v) = (t+n, v)`.
13:17:41 <dmwit> sqooq: If this function does not match your needs, perhaps it will give you some clues about how vague you are being.
13:17:51 <sclv> in your model you need to decide what a signal is, what a time is, and what it is to "output at a time"
13:17:53 <amalloy> sounds like time is a really important concept for your program, and everything will make more sense if you model time explicitly
13:18:05 <mnoonan> the point of the delay filter is to time-shift some signal, right?
13:18:35 <sqooq> yes
13:19:04 <sclv> so a common thing in haskell would be to represent a signal as a list of values and times
13:19:05 <mnoonan> so just translate that right into a definition ^
13:19:08 <sclv> or deltas of times
13:19:17 <sqooq> I can do that directly actually but when used recursively, it hangs
13:19:30 <sqooq> Right now I basically have an FRP setup
13:19:31 <mnoonan> @let f n = cycle [0..9] !! n
13:19:33 <lambdabot>  Defined.
13:19:34 <sclv> ok, so maybe you can post that code
13:19:38 <sclv> and someone can help debug the hang
13:19:40 <mnoonan> > map f [1..20]
13:19:42 <lambdabot>  error:
13:19:43 <lambdabot>      Ambiguous occurrence ‘f’
13:19:43 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
13:20:00 <infinisil> lol
13:20:25 <mnoonan> @let signal t = cycle [0..9] !! t
13:20:26 <lambdabot>  Defined.
13:20:46 <mnoonan> > map signal [5..15]
13:20:48 <lambdabot>  [5,6,7,8,9,0,1,2,3,4,5]
13:20:53 <mnoonan> > map (delay 3 signal) [5..15]
13:20:55 <lambdabot>  error:
13:20:55 <lambdabot>      Variable not in scope:
13:20:55 <lambdabot>        delay :: Integer -> (Int -> Integer) -> Integer -> b
13:21:05 <mnoonan> wat
13:21:22 <sclv> (and in mnoonan's example the times deltas are implicitly "1 step")
13:21:28 <sqooq> I tried delaying by padding zeros on lists as well
13:21:33 <sqooq> and again there are hanging issues
13:21:49 <sclv> ok, you should debug those
13:21:59 <infinisil> sqooq: can you maybe post a complete and minimal example of your problem/what you tried and doesn't work?
13:22:12 <sqooq> yes hold on, I'll start posting thigns
13:22:47 <sqooq> http://lpaste.net/361386
13:22:56 <sqooq> this is what is happening conceptually
13:23:33 <dmwit> Minimal is good. But it has to be complete, too.
13:23:48 <sclv> here, sum is refering to out, and out is refering to sum
13:24:08 <sqooq> yes that's part of the issue
13:24:11 <sqooq> it's super annoying
13:24:17 <sclv> so you're using some sort of mfix
13:24:25 <sclv> and i guess not being sufficiently lazy?
13:24:39 <sqooq> that was just conceptual btw, that's not actual code that runs
13:24:43 <infinisil> that is very far from a complete example, i have no idea what you're doing in your actual code sqooq
13:24:47 <sqooq> though I tried it with my list setup and it failed
13:24:53 <sqooq> infinisil, I said hold on lol
13:25:03 <infinisil> alright
13:25:27 <sqooq> shoot
13:25:31 <sqooq> I think I deleted everything
13:26:15 <Welkin> reinstall your operating system
13:26:29 <infinisil> buy a new computer
13:26:30 <sqooq> http://lpaste.net/361387
13:26:58 <sqooq> this is the core I've been working with, I can rewrite the brute force delay function and an example real use function that would use it recursively.
13:27:00 <Welkin> what is Data.WAVE?
13:27:13 <sqooq> it just makes .wav files
13:27:20 <sqooq> a lot of those imports aren't needed I don't think
13:27:28 <sqooq> I used them while experimenting at one point or another
13:27:41 <sqooq> that one I use to actually render my files and see if they sound as expected though
13:28:52 <dmwit> How do I cause a loop with this?
13:29:32 <Welkin> dmwit: loop?
13:29:34 <Welkin> use recursion
13:29:36 <Welkin> or a fold
13:29:47 <dmwit> Thank you, but that is not helpful.
13:29:58 <Welkin> I don't know what your question is
13:30:25 <dmwit> sqooq complains that he has something that hangs. I do not see anything in his paste that looks like it would cause a hang, and experimentally the things I tried did not hang.
13:30:51 <sqooq> hold on please
13:31:35 <sqooq> http://lpaste.net/361387
13:31:37 <sqooq> at the bottom
13:32:12 <EvanR> hanging loops, how insidious
13:32:48 <nkaretnikov> What’s the status of linear types in ghc? Can I program without GC at all yet?
13:32:52 <AndreasK> So I guess you expect the term on the left to only sometimes evaluate "onePole a b x"?
13:33:05 <dmwit> sqooq: There is no base case for your recursion...
13:33:18 <dmwit> sqooq: Are you intending that signals begin at (say) time 0 or something like that?
13:33:18 <AndreasK> ^
13:33:24 <sqooq> I know I wrote it quickly
13:33:28 <sqooq> I had an actual one before
13:33:34 <sqooq> and yes
13:33:39 <sqooq> the base case is t=0
13:33:52 <AndreasK> nkaretnikov: At the moment linear types don't allow for the removal of gc
13:33:53 <sqooq> it doesn't actually hang.... it just gets incredibly slow very quickly and crashes my computer
13:33:56 <dmwit> sqooq: Then you should add a base case for t=0.
13:34:19 <sqooq> dmwit, the same function had one in the past, I think I deleted it because it didn't work and went trying other things.
13:34:32 <EvanR> you might be leaking memory somehow
13:34:38 <EvanR> profile memory usage
13:34:40 <sqooq> well everytime it calls the function
13:34:53 <sqooq> it calculates all the previous values it already calculated the time step before
13:35:02 <nkaretnikov> AndreasK: are you aware of ETA on this? I’ve searched around, but it’s a bit hard to follow.
13:35:09 <sqooq> so really delay should be a storage write and read to be efficient
13:38:37 <AndreasK> nkaretnikov: No
13:39:56 <AndreasK> nkaretnikov: Afaik that requires nontrivial changes to codegen/rts so if it makes it in it will be a while.
13:40:35 <EvanR> i have not heard of GHC ever being able to go without GC
13:40:46 <sqooq> dmwit, http://lpaste.net/361390
13:40:50 <sclv> sqooq: ok i see the issue i think -- your delay functions build up in a huge thunk
13:41:02 <sqooq> sclv, yes that is the issue
13:41:12 <sclv> so modify your signal to have an explicit delay
13:41:28 <sclv> newtype Signal t b = Signal (Delay, t -> b)
13:41:34 <sclv> Delay i guess is really also of time t
13:41:54 <sqooq> hm?
13:42:18 <sclv> oh i see, that doesn't quite suffice
13:42:26 <sqooq> I don't even understand it lmao
13:42:29 <AndreasK> nkaretnikov: There are compact regions since 8.2 for long term heap objects which can reduce gc pressure. If you haven't come across that yet
13:42:50 <sqooq> o i guess I see it... when it's grabbed, it adds the current delay
13:43:45 <typetetris> join #haskell-beginners
13:43:50 <sqooq> I still think mdo notation (if it were possible to get it to work) would make things clearer, because the function shouldn't really just be called again
13:44:04 <AndreasK> EvanR: I don't know of concrete implementation plans. But intermediate objects in linear functions could be deterministically freed as I understand it. Similar to what rust does.
13:44:27 <EvanR> AndreasK: yes, that is all the rage. but ghc ?
13:44:29 <sclv> the problem is you can't grab the "front" of the signal because onePole loops forever
13:44:55 <nkaretnikov> AndreasK: too bad, I wish the compiler were more modular. as for the compact regions, nah, I’ve been out of the Haskell loop for a while now. Thanks!
13:44:56 <sqooq> I definitely in the past managed to get a form where it actually outputs numbers
13:45:08 <sqooq> I think I had an if statement somehow to stop it if time was t
13:45:31 <sclv> you should consider moving from a single function for signals to a list of functions, each with a duration
13:45:35 <sqooq> agh yeah I think that's it, I had the if statement in the onepole definition itself, it didn't help though. The complexity of the problem is like O(n^n!)
13:45:55 <sqooq> sclv, let me show you how I would like for it to be written
13:46:02 <sclv> [(t,t->b)]
13:46:14 <dmwit> sqooq: Consider using memoization. This will cost more memory but less time.
13:47:03 <dmwit> It is relatively easy to cook up a function of type `Memoizable a => (a -> b) -> (a -> b)` using one of the many memoization libraries out there. (N.B. They each have their own class for the `Memoizable` constraint.)
13:47:09 <sqooq> dmwit, well when using lists I can do explicit memoization, I just don't like that it's explicit
13:47:17 <sqooq> ok yes I was just about to ask that
13:47:46 <dmwit> Python teaches that explicit is better than implicit. (And I agree with that teaching.)
13:47:47 <sqooq> can a Signal in this form be memoized though? And can it be memeoized for more than 1 time step into the future?
13:48:02 <dmwit> I don't see why not.
13:49:25 <sqooq> hmm
13:50:05 <sqooq> How does memoization for more than just one past result work? Or can you link me to something that will help me understand that world?
13:50:27 <sqooq> sclv, this is how I think it should actually be written and make "sense" http://lpaste.net/361393
13:51:09 <sclv> ok consider the data representation i suggested
13:52:00 <AndreasK> EvanR: As I understand it it wouldn't remove GC in the sense that it works like Rust. But if you have a chain of linear functions calling each other you can free any linear values as soon as they have been used. Resulting in hopefully fewer collection cycles so better performance.
13:52:01 <HairyDude> Does a function with this type exist in standard libraries? appsE :: Name -> [ExpQ] -> ExpQ
13:52:22 <AndreasK> But as I said I'm not aware of plans to implement GC schemes taking advantage of linear types as of yet
13:52:28 <Xal> HairyDude: this sounds like a job for hoogle
13:52:29 <sqooq> sclv, I can't understand it but I'll keep thinking about it
13:52:41 <HairyDude> @Xal: that'd be a no then
13:52:41 <lambdabot> Unknown command, try @list
13:52:42 <glguy> HairyDude: Not in template-haskell, no
13:52:49 <glguy> You can build it out of appsE, though
13:53:15 <sqooq> dmwit, reflex uses https://hackage.haskell.org/package/MemoTrie-0.6.1/docs/Data-MemoTrie.html
13:53:23 <sqooq> maybe I should try that
13:53:30 <HairyDude> glguy: doh, why didn'T I just ctrl-F for appsE :)
13:53:57 <glguy> or: foldl appE . varE :: Name -> [ExpQ] -> ExpQ
13:54:54 <HairyDude> appsE is good enough
13:59:11 <dmwit> sqooq: Q: How does memoization work? A: Build a lookup table, and do lookups. Store a thunk in the lookup table to begin with, which will be forced the first time it is used as usual and mutated in-place to its evaluated value afterwards.
14:00:10 <dmwit> Think "replace `a -> b` with `Map a b`", except that sometimes it's another concrete type than `Map` (especially for `a`s that have infinitely many values or more than would reasonably fit in a `Map`).
14:03:06 <woodson> Welkin: Thanks for the info. I have been using elm for a few months now, and I am starting to see some limitations. Also the fact that I can't reuse my data structures are a bit of pain.
14:07:29 * ahihi idly wonders if using haskell for audio processing is really worth it
14:08:31 <sqooq> apparently not
14:08:43 <sqooq> I mean , when working with lists it's really nice
14:08:53 <sqooq> once I make the memoized functions
14:08:56 <ahihi> for a delay you really want a ring buffer
14:08:59 <sqooq> but its' not general purpose
14:09:08 <sqooq> ahihi, I know I linked the c code
14:09:23 <sqooq> but how the actual hell do I do it in haskell
14:10:33 <dmwit> A thought: in C you do not represent a signal as a function. Why do you think that will be the best representation in Haskell?
14:10:52 <sqooq> I wanted to use haskell because haskell is nice and intuitive to me, and typing audio expressions feels right. Haskell is good for embedded languages or whatever they're called. Whereas in another language it feels more like you're just programming than like using an audio program, idk.
14:11:19 <sqooq> dmwit, yes you do.
14:11:28 <sqooq> well, I do...
14:11:33 <mniip> it's called a DSL
14:12:14 <Linat0k> i love sheep baah
14:12:20 <sqooq> mniip, o whoops not that. I just mean haskell libraries are good at feeling like mini-languages in their own right
14:12:25 <Linat0k> some times i look into the sky and see sheep in the stars
14:12:32 <mniip> eDSL?
14:12:33 <Linat0k> they make me feel warm and fuzzy
14:12:48 <mniip> Linat0k, please stick to the topic
14:12:52 <Linat0k> sorry
14:13:37 <sqooq> mniip, o maybe Idk sorry. I googled eDSL and saw stuff about bindings and stuff. I mean maybe I'll use bindings for some stuff, but I just like writing signal expressions in haskell.
14:13:44 <dmwit> sqooq: Well, I don't know whether you do. But in the C code you linked, the signal is represented as an array, not a function.
14:14:04 <sqooq> dmwit, that's not the signal, that's the delay line
14:14:06 <sqooq> that's the buffer
14:14:14 <sqooq> the "signal" of the delay is just the return value "y"
14:14:31 <sqooq> and you basically call it in a loop of time rising.
14:14:50 <dmwit> sqooq: `delayline` does not take a function as an argument. Do you agree with this?
14:15:03 <sqooq> it takes the output of the function
14:15:20 <dmwit> So: you are not modifying functions in the C code.
14:15:49 <sqooq> No because C is stupid and in haskell I can take advantage of applicative and stuff, which unwrap the function and do stuff with the output before the output is actually called.
14:16:35 <sqooq> dmwit, the C model can't really be implemented in haskell in the same way
14:17:04 <sqooq> or maybe it can but that's not thinking functionally.
14:17:04 <mniip> sqooq, edsl is defining a bunch of functional combinators so that writing code made entirely out of them becomes a sort of mini-language
14:17:32 <ahihi> i went with rust myself
14:17:33 <sqooq> mniip, ok so yes, that's exactly what I was referring to. I like the potential for haskell being used for eDSL's.
14:17:49 <mniip> I made one for brainfuck recently
14:17:51 <sqooq> ahihi, for audio?
14:17:58 <ahihi> yeah
14:18:04 <sqooq> isn't it just like C++?
14:18:31 <mniip> http://tcpst.net/dtx9.png
14:18:32 <ahihi> not really
14:18:40 <sqooq> I mean I don't know much about anything outside of haskell really.
14:19:21 <sqooq> I learned C when I got angry with haskell once, and I worked with Chuck which is OOP, and matlab, and some other things.
14:19:24 <ahihi> rust is a lot more type-safe and also makes use of more functional constructs
14:19:32 <sqooq> ooh
14:19:39 <ahihi> but it's still imperative fundamentally
14:19:40 <sqooq> but with glorious side effects, I'm guessing?
14:19:43 <ahihi> yes
14:20:01 <sqooq> what kind of audio work did you do?
14:20:56 <ahihi> for now, some basic synthesis (noise/additive/FM + envelopes) and a few simple effects
14:21:16 <sqooq> ok so same as me lol
14:21:46 <sqooq> In writing some basic functions with explicit memoization, I was able to do additive, basic filters, FM, envelopes, as well
14:21:49 <sqooq> but all in lists
14:21:53 <sqooq> so no realtime potential...
14:22:08 <ahihi> ah, yeah, i was going for realtime from the start
14:22:16 <sqooq> ahihi, figuring out FM was a pain in the arse. I had to literally contact Miller Puckette for help.
14:22:29 <sqooq> I thought you literally just changed the frequency through time with a signal
14:22:47 <sqooq> but no, it's a stupid integral from 0 to your current time
14:22:51 <sqooq> (in continuous time)
14:23:01 <sqooq> in discrete time it's a recursive delay summation.
14:23:25 <sqooq> ahihi, maybe we should work together, do you have a github page for it?
14:24:22 <sqooq> because it sounds like we perhaps have similar goals. I just wanted a puredata-like eDSL that could do realtime, and was general audio purpose.
14:24:27 <sqooq> idk if that's the same goal as you.
14:25:16 <sqooq> I don't like the audio languages available, except pure data, but pure data being visual is a drag. I hate patching cables, I hate that it has no good concept of state (you quit your file and everything is lost).
14:26:15 <sqooq> Nyquist is terrible. Super collider seemed terrible too. Chuck is good in concept but feels really unfinished and buggy, and a little too high-level(?).
14:26:20 <sqooq> also I don't like OOP that much
14:27:38 <ahihi> well, what i did was indeed just simple changing of the carrier frequency with a modulator wave
14:27:43 <ahihi> i don't know about this integral stuff lol
14:28:09 <hyperisco> if Haskell's runtime is not suitable then output a program which runs with a runtime that is suitable
14:28:23 <ahihi> my goal is really to build hardware synths, so the edsl aspect is not that interesting to me
14:28:37 <ahihi> and alas this project is currently on hold
14:29:27 <mniip> nyquist the audacity language?
14:29:35 <sqooq> mniip, yes
14:29:39 <sqooq> ahihi, o I see...
14:29:46 <mniip> I wanted to try it once but never got around to do it
14:30:01 <sqooq> ahihi, I wish I knew circuitry. I hate computers lmao.
14:30:10 <mniip> turned out sonicvisualizer was the tool I actually needed
14:30:20 <sqooq> If I was rich, I would just buy a bunch of analog synths and be done with it.
14:30:31 <sqooq> but i have 3$ in my account
14:30:33 <ahihi> i'm not great at electronics myself, but i'm learning :-)
14:30:50 <hyperisco> time to start trading up paperclips.
14:30:56 <sqooq> ahihi, o god, laplace transform, *shudders*
14:57:47 * hackage serverless-haskell 0.0.0 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.0.0 (AlexeyKotlyarov)
15:30:40 <xocolatl> hi.  I'm getting this with "stack new projname": AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
15:33:03 <geekosaur> stack upgrade
15:33:09 <monochrom> IIRC this is old stack not knowing new syntax.
15:33:51 <stevo__> I am looking for a low-level haskell library to implement a rest server.
15:33:53 <geekosaur> (and make sure the stack bin directory is on $PATH (%PATH% on Windows) so you get the new one when you run it afterward)
15:34:19 <stevo__> I was told that Ysod is the best option to do that. Right? Should be performant and easy to use.
15:34:28 <xocolatl> geekosaur: same error after upgrade
15:34:54 <geekosaur> please read the second thing I said
15:36:33 <xocolatl> okay, so what's the stack bin directory?  `which stack` says ~/.local/bin/stack
15:36:37 <xocolatl> and this used to work
15:37:12 <geekosaur> how about "type stack"?
15:37:25 <geekosaur> "which" often lies and tells you what the next shell you open will see
15:37:38 <geekosaur> (also try: hash -r)
15:37:53 <xocolatl> stack is hashed (/usr/bin/stack)
15:38:00 <geekosaur> hash -r
15:39:14 <xocolatl> geekosaur: that worked.  what the heck is `hash -r` and why should I have to do it?
15:39:22 <xocolatl> nothing else has ever needed that
15:39:27 <geekosaur> because the shell remembers where it saw things
15:39:46 <monochrom> Software is generally imperfect.
15:39:58 <geekosaur> you probably don't normally upgrade things into new locations (you cannot replace /usr/bin/stack directly, your OS package manager owns that)
15:40:11 <monochrom> If I wrote the shell, you would not have to do this.
15:40:51 <geekosaur> monochrom, command hashing was a nice coinvenience when it was introduced, but became mandatory when linux decided that /ust/bin should have a couple thousand things in it
15:41:09 <geekosaur> you really d not want to wait for a PATH search every time you run something
15:41:29 <xocolatl> okay
15:41:37 <xocolatl> thank you for fixing it for me :)
15:41:37 <geekosaur> indirect blocks for directories are a performance killer
15:41:48 * hackage wolf 0.3.39 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.3.39 (markfine)
15:41:53 <xocolatl> I never would have thought to run  hash -r
15:46:00 <xocolatl> now I can fail yet again at learning megaparsec
15:58:35 <stevo___> Can I pattern match on a pair of bools? I.e., case xyz of (true, false) -> ...; (true, true) -> ....
15:58:54 <stevo___> I get: Conflicting definitions for ‘true’
15:58:58 <glguy> Yes, just make sure you capitalize them
15:59:00 <koala_man> True
15:59:05 <stevo___> ahhhh
15:59:05 <glguy> True is a constructor, true is a variable
15:59:09 <stevo___> Thanks!
16:03:50 <erisco> help I am case blind
16:04:44 <hpc> FoLlOw ThE sOuNd Of My TyPiNg
16:04:46 <hpc> ;)
16:05:13 <int-e> hpc: this is what I get for resisting that temptation?
16:05:16 <erisco> I learned to read the sound of shift keys when I was 5
16:05:51 <int-e> hpc--
16:05:55 <hpc> :P
16:06:12 <hpc> i think it was punishment enough having to press the shift key that many times
16:10:32 <orion> If I create a large Vector and pass it to 50 functions spawned via forkIO, will I have 50 copies of the Vector in memory, or will it follow copy-on-write semantics?
16:11:20 <glguy> Neither
16:11:43 <glguy> Are you asking about immutable Vector or mutable MVector?
16:12:03 <glguy> separately: forkIO doesn't spawn functions, it spawns threads
16:12:20 <orion> Immutable.
16:12:31 <glguy> Then there's no write, so no copy on write
16:12:46 <glguy> and they all use the same vector value
16:17:31 <orion> Great.
16:21:06 <sqooq> f/join
16:21:10 <sqooq> woops
16:25:13 <stevo___> Has anyone done a highly parallel web endpoint?
16:25:33 <iqubic> Do vectors support linear-time random access? IE, can I read and write the Nth element provided N is in bounds?
16:26:03 <EvanR> they do better than linear time
16:26:03 <iqubic> Specifically asking abut 2d vectors here.
16:26:16 <iqubic> EvanR: How is that possible?
16:26:32 <EvanR> log time and constant time are examples of something faster than linear time
16:26:44 <iqubic> What do vectors do?
16:26:45 <EvanR> reading vectors is constant time
16:26:55 <stevo___> It's just array acces with a pointer.
16:27:14 <stevo___> You can also sort a vector in O(n) time ;)
16:27:31 <stevo___> Unfortunately, you have to convert it to a list first.
16:27:55 <stevo___> Searching a vector in hardware is possible in O(1).
16:28:05 <iqubic> What's the speed trade-offs of using an MVector vs an STArray for a mutable 2d square structure?
16:28:24 <nshepperd_> Identical
16:28:45 <stevo___> iqubic: what are you doing? That's right what I am doing now. But I need it for fast 2D/3D graphics.
16:29:37 <stevo___> iquibic: If you want to go faster you need SIMD instructions, but that's not supported really in Haskell at the moment.
16:29:51 <Welkin> you can write it in C
16:29:53 <Welkin> and use the CFFI
16:29:59 <Welkin> then you can use SIMD
16:30:19 <EvanR> https://ghc.haskell.org/trac/ghc/wiki/SIMD
16:30:31 <iqubic> Writting my own implementation of 2048, and an AI to play it.
16:30:37 <iqubic> In Haskell.
16:30:50 <EvanR> robotron?
16:30:57 <iqubic> What is robotron?
16:31:02 <stevo___> EvanR: Yes. But even in the C/C++ world there are not too many options. An mangling with C is not my fun day.
16:31:10 <EvanR> robotron 2048 was an old arcade game
16:31:19 <iqubic> No.
16:31:38 <Welkin> nice link EvanR
16:31:41 <EvanR> i didnt say anything about C
16:31:59 <iqubic> https://gabrielecirulli.github.io/2048/
16:32:00 <Welkin> I know
16:32:04 <Welkin> I wasn't being sarcastic
16:32:07 <iqubic> that is what I was talking about.
16:32:38 <iqubic> I want to write an implementation of that, and then write a machine learning AI to play it well.
16:32:50 <stevo___> EvanR: The conses here was that GHC has partial SIMD support that nobody uses and noone maintains. And any numeric work is hopeless anyways in Haskell.
16:33:20 <EvanR> cool game
16:33:21 <stevo___> iqubic: I guess the MVectors are all you need.
16:33:41 <EvanR> i would not use mutable vectors for this game
16:33:48 <EvanR> its just a 4x4
16:34:06 <iqubic> nshepperd: If STArrays and MVectors have the same performance, why use one over the other?
16:34:21 <iqubic> EvanR: What should I do instead?
16:34:33 <Welkin> Array gives you an Ix instance to work with indexing
16:34:35 <Welkin> Vector does not
16:34:37 <EvanR> define an abtract data type for a 4x4 array
16:34:41 <verement> stevo__: Why is numeric work hopeless in Haskell?
16:34:44 <Welkin> but it gives you a ton of utility functions
16:34:51 <EvanR> implement it the simplest way behind the scenes, which will be immutably
16:35:08 <Welkin> and yes, lol
16:35:09 <iqubic> EvanR: Why not just use the already existing Array package?
16:35:20 <stevo___> I learned that recently. Basically, no one does that or maintains that.
16:35:24 <EvanR> thats an example of an implementation
16:35:26 <Welkin> trying to optimize by using mutable vectors for a game of 2048 is major overkill
16:35:29 <EvanR> using the Array package
16:35:37 <Welkin> premature optimization that likely will make 0 real world difference
16:35:38 <EvanR> and implementing your AST with it is still going to be non trivial
16:35:48 <stevo___> There is not a library to sort a vector in a performant way. Accelerate lib is understaffed. Etc.
16:35:52 <EvanR> the simplest way would be [[a]]
16:36:07 <glguy> Welkin: Maybe you just aren't good enough at 2048 to need the extra speed!
16:36:09 <Welkin> stevo___: there are a few vector sorting libraries
16:36:52 <EvanR> iqubic: since performance isnt going to matter here whatsoever, the important part is 100% the API of your data structure, the abstraction
16:36:55 <stevo___> Welking: Yes, but not in a performant way. If you want to sort unboxed Int's there is no problem at all. If not you are back in C land.
16:37:22 <stevo___> I can sort 1 000 000 Ints instantly.
16:37:42 <EvanR> as long as we assume they are already sorted
16:37:46 <iqubic> EmptyBoard = listArray ((0,0),(3,3)) (replicate 16 0)
16:37:48 <EvanR> really helps
16:38:00 <iqubic> Why not just do that?
16:38:03 <stevo___> Also, if the list/vector in infinitly long, the O(n) sorting lib is very fast ;)
16:38:33 <iqubic> Also, why do you say performance doesn't matter here?
16:38:47 <EvanR> why not just do replicate 4 (replicate 4 0)
16:38:53 <EvanR> > replicate 4 (replicate 4 0)
16:38:54 <lambdabot>  [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]
16:38:58 <stevo___> It's only ints, iqubic!
16:39:08 <iqubic> Because working with lists is rather slow IMO.
16:39:13 <stevo___> Int's don't count! Especially not if they are unboxed.
16:39:16 <EvanR> your opinion is wrong here
16:39:23 <stevo___> Yes, but noone uses lists!!!
16:39:45 <stevo___> Whereever you have lists for a uniform type, you have to get rid of them. Always!
16:39:47 <EvanR> using Array will be slow, in dev time, relatively speaking
16:40:05 <iqubic> Yeah, but working with lists is kinda hard.
16:40:05 <EvanR> of course if you do my abstract data type idea, no one can complain how you implemented it
16:40:21 <EvanR> i think you are misjudging the haskell involved
16:40:24 <iqubic> What do you mean by abstract data type?
16:40:35 <Rembane> Are you discussing instead of prototyping? :)
16:40:36 <stevo___> Welkin: Do you want to improve sorting in Haskell with me and other teammates?
16:40:51 <EvanR> newtype Array44 a = <hidden)
16:40:55 <stevo___> iqubic: I guess you need a good Haskell book
16:40:56 <EvanR> >
16:41:08 <Athas> stevo___: what kind of sorting algorithms are you considering?
16:41:29 <Welkin> Athas: the stevo___ sort
16:41:37 <iqubic> stevo__: I know haskell.
16:41:53 <EvanR> it is sounding like you have some more haskell to learn
16:42:11 <EvanR> like everybody else
16:42:12 <stevo___> One open problem for a Haskell lib seems to be a 'professional' parallel radix sort.
16:42:20 <stevo___> There is onyl a toy one in the Accelerate lib.
16:42:24 <Welkin> you cannot accept any more tea until you empty your cup, young iqubic
16:42:31 <Welkin> for it is full
16:42:35 <Athas> stevo___: what's concretely wrong with the Accelerate one?
16:42:37 <stevo___> The author said he would appreciate help with Accleerate.
16:43:10 <stevo___> If you want it in a performant way, you are locked-in to Nvidia CUDA code.
16:43:29 <Welkin> not gpgpu?
16:43:33 <Athas> Accelerate's multicore CPU backend (via LLVM) works well for me.
16:43:47 <stevo___> Athas: Also, there is currently no sorting algorithm that is based on Accelerate
16:43:48 <Athas> But I agree that it's a shame that Accelerate went for CUDA rather than OpenCL.
16:44:04 <stevo___> There is a toy Radix sort and some old Odd Even merge sort.
16:44:32 <iqubic> EvanR: Why do I want abstraction in my program?
16:45:40 <glguy> step 1, actually write the program, then you can worry about how much abstraction you need
16:45:49 <glguy> or if you need a different data structure
16:45:54 <Athas> stevo___: have you tried just improving the Accelerate radix sort?
16:46:07 <Athas> I think the main issue is that it goes by one bit at a time, and that should be easy to improve.
16:46:29 <stevo___> Athas: Not yet.
16:47:02 <Athas> The Accelerate guys write quite readable code.  I've had an easy time understanding most of their programs, and I'm not an expert.
16:47:24 <stevo___> Athas: That's good. The authors also respond to messages quickly.
16:47:28 <iqubic> Glguy, I don't know how to write this program with standard lists.
16:47:42 <glguy> OK, then write it with whatever you know how to use
16:50:05 <Welkin> write it using GOTO
16:50:24 <int-e> in case anyone wonders, lambdabot's caught in a meltdown/spectre related reboot
16:50:28 <mniip> write it using speculative execution of mispredicted branches
16:50:54 <mniip> int-e, I managed to reproduce meltdown on yahb in a very limited form :D
16:50:57 <erisco> int-e, I hope it is feeling better when it comes back
16:51:28 <mniip> %! ./melt 0xffffffffa8e07910
16:51:32 <EvanR> what
16:51:33 <yahb> mniip: cutoff: 132; 0xffffffffa8e07910 | 00 00 00 [Timed out]
16:51:36 <mniip> %! ./melt 0xffffffffa8e07910
16:51:41 <yahb> mniip: cutoff: 132; 0xffffffffa8e07910 | 00 00 f4 b2 00 [Timed out]
16:51:55 <Welkin> wtf?
16:51:55 <mniip> couple bytes from the toplevel page directory :D!
16:52:09 <int-e> mniip: Basically *I* have nothing else of importance running on that VPS, so I'm not overly worried. But that doesn't help the other VPSs :P
16:52:10 <EvanR> HMMMMMM......    %! rm -rf /
16:52:24 <mniip> EvanR, %! is *in* the sandbox
16:52:28 <erisco> am I going to need a new CPU =\
16:52:33 <Welkin> erisco: did it melt?
16:52:35 <mniip> ./melt was uploaded via printf
16:52:37 <iqubic> glguy: I could write my program with lists, but I'd have to literally have to pepper it with (!!)
16:52:49 <EvanR> erisco: you mean, a CPU over 23 years old
16:52:54 <erisco> well, if the perf hit is what they say it is, the average temp will be higher…
16:52:55 <EvanR> before this became an issue
16:52:59 <Welkin> iqubic: then use vector
16:53:01 <glguy> iqubic: That's fine
16:53:04 <glguy> just write it
16:53:07 <erisco> it is time to go back to the abacus
16:53:13 <EvanR> iqubic: implementation vs interface
16:53:17 <Welkin> vector has a very similar api to lists
16:53:22 <int-e> EvanR: my Arduino is probably fine ;-)
16:53:27 <iqubic> I thought (!!) was really slow.
16:53:35 <EvanR> your "arduino CPU" lol
16:53:38 <glguy> Nope, not on lists with 4 elements, go write it
16:53:39 <Welkin> it is, but for small enough data sets, it doesn't matter
16:53:40 <erisco> and when is Intel going to ship CPUs with this fixed
16:53:42 <Welkin> you wold be surprised
16:53:55 <int-e> EvanR: AVR CPU
16:54:02 <Welkin> I wrote a parser using parsec with *strings*
16:54:08 <Welkin> and ran it on a 20mb text file
16:54:12 <EvanR> iqubic: consider the difference between using !! on a list of length 1 and ! on a vector of length 1
16:54:13 <Welkin> it finished in a couple seconds
16:54:30 <int-e> EvanR: of course it's a moot point when there's no MMU in the first place.
16:54:35 <Welkin> on a macbook air
16:54:51 <EvanR> int-e: avr 8bits did it right... no division so no division by 0 issues
16:55:02 <EvanR> solving many of the worlds software problems
16:55:02 <iqubic> EvanR: I think for a list of length 4 it shouldn't really matter.
16:55:19 <Welkin> I was just thinking about this pre-optimization obsession that seems to common (especially among recent grads or college students)
16:55:49 <Welkin> it's because they teach this crap in the classroom! "Optimize that Big-O!"
16:56:21 <EvanR> iqubic: that is what i originally said
16:56:37 <Welkin> I used to think that way too
16:56:49 <int-e> will we see separated user and kernel mode caches as a processor feature soon?
16:56:53 <Welkin> now I take the smart approach
16:57:22 <EvanR> int-e: so you can only see cache effects from other user processes?
16:57:27 <int-e> EvanR: exactly
16:57:29 <EvanR> :|
16:57:33 <Welkin> I like the way that Casey Muratori phrases it: "Do the dumbest, simplest thing that works, then you can clean it up later or optimize *only* if you absolutely need to"
16:59:28 <iqubic> When are mutable arrays useful?
16:59:43 <Welkin> to optimize for speed and memory
16:59:55 <Welkin> or to interface with a C lib
17:00:10 <iqubic> I want to optimize for speed.
17:00:20 <Welkin> write it first
17:00:22 <Welkin> optimize later
17:00:32 <Welkin> the APIs are al lthe same
17:00:33 <EvanR> algorithms that make sense in terms of a mutable array
17:00:54 <Welkin> sure, that too
17:01:03 <Welkin> quicksort works only because of mutation
17:01:09 <Welkin> mergesort doesn't need it
17:01:19 <Welkin> but quicksort is not a very functional algorithm
17:01:24 <iqubic> Why doesn't mergesort need it?
17:01:32 <Welkin> it works best on lists
17:01:36 <EvanR> if you read a cryptohash algorithm on wikipedia, it will be in mutable array pseudocode
17:02:39 <EvanR> though, its really a fold
17:05:25 <iqubic> I just realized that instead of using a a record with all the fields being functions, you can just use a type class.
17:06:44 <iqubic> Now, I need help with Randomness in Haskell.
17:09:08 <geekosaur> usually people go the other direction: records are more flexible than typeclasses
17:09:16 <iqubic> Why is that?
17:10:10 <geekosaur> and records of functions don't usually run into the usual shortcomings of Haskell records, because you're not usually nesting them etc.
17:10:47 <iqubic> What can a record of functions do that a typeclass can't?
17:13:12 <geekosaur> https://stackoverflow.com/questions/8932917/type-classes-and-records-as-interfaces
17:13:50 <geekosaur> and many other such discussions... not like this is a FAQ or anything
17:14:44 <stevo___> iqubic: you are asking the wrong questions.
17:15:14 <stevo___> iqubic: The right questions is: Which books should I read? Which video lectures could help? etc.
17:15:15 <EvanR> because you can only have one instance of a class for a type
17:15:45 <stevo___> iqubic: What Haskell books did you read?
17:15:46 <EvanR> you can have any number of instances of a record type, regardless of associated types
17:16:01 <stevo___> Iquibic: Do you know Category theory?
17:16:10 <glguy> stevo___: This is an ongoing thing with iqubic, you're coming into it late
17:16:34 <stevo___> I left when it started...
17:16:59 <stevo___> I just think pointing to good material would be beneficial
17:17:02 <glguy> like months old or so
17:17:18 <stevo___> Okay, that old ;)
17:18:53 <int-e> @bot
17:19:00 <lambdabot> :)
17:19:09 <iqubic> stevo__: The only haskell books I've read is LYAH. Aside from that I've watched a dozen or so random very specialized Haskell lectures online, as well as read a whole lot of Haskell articals
17:19:34 <iqubic> stevo__: I know zero Catagry Theory.
17:19:58 <iqubic> > let x = 1:2:3:x in x
17:20:06 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
17:20:12 <iqubic> that took some time.
17:20:18 <iqubic> > 1 + 1
17:20:28 <lambdabot>  2
17:20:44 <stevo__> iqubic: What is LYAH spelled out?
17:20:54 <iqubic> Learn You A Haskell
17:21:21 <stevo__> iqubic: If you want Haskell you need to learn Category theory and Type theory sooner and Mathematics/Logic sooner or later
17:21:35 <stevo__> was so frustrating before that. Downside is, it takes years.
17:21:52 <Welkin> that is bullshit
17:21:54 <iqubic> stevo__: I don't think that's actually the case.
17:22:05 <Welkin> you don't need to know *any* category theory to be an expert in haskell
17:22:13 <stevo__> iqubic: What's not the case?
17:22:24 <stevo__> Welkin: Do you know Category theory?
17:22:33 <Welkin> only the tiniest amount
17:22:39 <Welkin> and it doesn't help in the slightest with my haskell
17:23:05 <iqubic> "<stevo__> iqubic: If you want Haskell you need to learn Category theory" That is false
17:23:32 <iqubic> I don't buy it one bit.
17:23:47 <stevo__> Okay, at least I get a good lough out of it.
17:24:16 <iqubic> lough??
17:24:41 <stevo__> Yes, laugh.
17:24:53 <stevo__> It's a good joke.
17:25:31 <iqubic> It's not a joke, it just plain wrong.
17:25:40 <EvanR> so you want to write hello world in haskell, let me give you a quick introduction to category theory
17:26:20 <Welkin> I have seen haskell (and purescript) tutorials like that EvanR
17:26:33 <stevo__> EvanR: you also don't know Category theory?
17:26:36 <Welkin> not as a joke
17:26:38 <Welkin> some people are that dense
17:26:56 <EvanR> not really no
17:27:20 <stevo__> Wow, honestly didn't know that exists.
17:28:04 <Welkin> there are too many lies and misconceptions about haskell on the internet
17:28:13 <Welkin> I see them all the time on hacker news (it's the worst place to go)
17:28:19 <EvanR> lies, damn lies, and haskell
17:28:38 <stevo__> Okay, sureley I know you are joking with me ;)
17:28:43 <erisco> I am now compiling a list of yes/no questions. Annotate if you have ideas http://lpaste.net/361398
17:29:06 <EvanR> a complete list?
17:29:20 <EvanR> i sense a russels paradox coming on
17:29:28 <Welkin> erisco: I added some
17:29:36 <stevo__> Guys, you made my day.
17:29:52 <erisco> dammit Welkin
17:29:56 <stevo__> We can start programming 101 if you want to listen.
17:30:23 <stevo__> Anyone interested?
17:32:32 <EvanR> maybe do a blog post instead
17:34:58 <erisco> Is this a yes/no question? -- like this EvanR?
17:35:41 <erisco> but unless you think about it too hard, the answer is just "yes"
17:39:07 <erisco> or you reason it is unanswerable because it is an infinite question, by expanding what "this" refers to
17:39:30 <iqubic> stevo___: What would programing 101 teach?
17:39:31 <EvanR> i am trying to find the particular guy
17:40:08 <erisco> how to program the number 5
17:40:24 <iqubic> erisco: print 5
17:42:47 <kakashiA1> the list [1, 2, 3] hast the typesignature   [1, 2, 3] :: [Int]
17:43:03 <kakashiA1> but I dont understand this:
17:43:05 <kakashiA1> Prelude> :type [1, 2, 3, 2, 7]
17:43:07 <kakashiA1> [1, 2, 3, 2, 7] :: Num a => [a]
17:43:56 <iqubic> :t [1, 2, 3]
17:43:59 <lambdabot> Num a => [a]
17:44:17 <erisco> kakashiA1, let a = Int
17:44:52 <kakashiA1> I dont understand it, but why does not haskell say that a is an Int? I only know that is has something to do with laziness, but not sure what
17:45:16 <erisco> it has nothing to do with laziness, it has to do with the type of integer literals
17:45:18 <erisco> :t 1
17:45:21 <lambdabot> Num p => p
17:45:43 <kakashiA1> erisco: why is :t 1 not just Int ?
17:45:53 <erisco> because there are many possible types for 1
17:46:20 <erisco> and most languages are like this, so it shouldn't be that much of a surprise
17:46:21 <iqubic> Because Haskell can't tell if you want 1 as an Int, or an Interger, or a Double.
17:46:23 <kakashiA1> erisco: I dont see that, because I wrote 1 and not 1.0
17:46:36 <iqubic> :t 1.0
17:46:38 <lambdabot> Fractional p => p
17:46:44 <erisco> do you know C? is 1 an int, a char, a uint …
17:46:52 <erisco> unsigned int I think they write it
17:46:53 <iqubic> Well, that's another can of worms.
17:47:03 <sqooq> scheme or clojure..?
17:47:16 <iqubic> sqooq: How does that help?
17:47:29 <sqooq> it doesn't help with anything
17:47:35 <sqooq> I just wanna learn a new language
17:47:42 <sqooq> Everyone keeps telling me to explore lisp family
17:47:52 <sqooq> i found two fp one's
17:48:02 <sqooq> so like do you guys recommend any coming from haskell?
17:48:18 <Welkin> lisp is not functional
17:48:21 <erisco> so, choices in Haskell might be Int, Integer, Float, Double, Rational, Num r => a -> r … many possibilities
17:48:22 <Welkin> there are 2 types of lisp
17:48:26 <Welkin> lisp-1 and lisp-2
17:48:33 <iqubic> I like elisp.
17:48:35 <kakashiA1> erisco: so with other words haskell says: "you gave me one, with no operation, but I cant read your mind, I dont know if you mean Int or Integer or Double, so I see it as Num, to allow you to use every Num operations"
17:48:37 <Welkin> or, scheme and common lisp
17:48:45 <Welkin> scheme is functional (enough)
17:48:51 <Welkin> I would recommend scheme or racket
17:48:59 <geekosaur> lisp has always been a house divided
17:49:01 <Welkin> racket is the newest version of scheme
17:49:20 <erisco> kakashiA1, it is more like  1 :: Num a => a  exactly as it is telling you, and if you do something Int-specific then a = Int
17:49:33 <Welkin> there is also typed racket, which looks cool
17:49:43 <sqooq> >lisp is not functional
17:49:48 <sqooq> >scheme is functional...enough
17:49:49 <sqooq> lol
17:50:03 <sqooq> i'll check out racket/scheme then. thanks.
17:50:04 <Welkin> most lisp family languages are not functional
17:50:08 <kakashiA1> erisco: and you dont agree with my description ?:P
17:50:11 <Welkin> only the scheme ones can even be considered
17:50:20 <sqooq> Welkin, what about clojure? it claims to be fp
17:50:32 <sqooq> well
17:50:36 <iqubic> kakashiA1: Yeah, that's more or less right.
17:50:37 <sqooq> it claims to be focused on fp
17:50:39 <Welkin> I hated clojure
17:50:39 <erisco> kakashiA1, Haskell doesn't have a theory of mind. At least not last time I read the report XD
17:50:39 <sqooq> which is good enough for me
17:50:50 <Welkin> it forces you to use the java ecosystem as well
17:50:54 <kakashiA1> iqubic: thanks
17:50:55 <sqooq> ew
17:51:03 <sqooq> ok scheme it is
17:51:13 <kakashiA1> erisco: be more relaxed with me :P
17:51:24 <iqubic> scheme is good. Not sure it counts as FP though.
17:51:42 <sqooq> I don't care really, just want to explore. Obviously I like fp so I'd stay as close as I can to it.
17:51:52 <erisco> kakashiA1, I just want to tell you how it is, rather than how you want it to be ;)
17:52:39 <kakashiA1> there one "NO NO" word that I did read in some haskell documentations: they talked that types has methods O_O
17:52:47 <kakashiA1> methods are functions attached to an object
17:52:55 <kakashiA1> it has nothing to do with a FP language
17:53:02 <kakashiA1> everything is pure
17:53:18 <kakashiA1> why do they still use the word "method" in haskell?
17:53:32 <erisco> cite it and we'll see
17:53:46 <iqubic> people sometimes use methods to talk about functions that are defined in a typeclass definition.
17:54:06 <ebzzry> Does intero supplant structured-haskell-mode and hindent?
17:54:18 <iqubic> But yeah, where do you see the word method in relation to haskell?
17:55:42 <kakashiA1> ebzzry: you said it has nothing to do with laziness:   https://www.youtube.com/watch?v=VFCXjYEBR4E    <---- minute 1:30
17:56:06 <iqubic> Is there  way to get intero to provide me with code suggestions on the fly? Like if I type the first few letters of function I want to be able to autocomplete that.
17:56:27 <EvanR> why is "method" used in any context, who knows
17:57:09 <kakashiA1> https://www.haskell.org/tutorial/classes.html     <----just search for the words method
17:57:23 <iqubic> kakashiA1: What part in that video do you want us to see?
17:57:44 <kakashiA1> iqubic: minute 1:30 and listen to it :)
17:58:22 <iqubic> Yeah, that's flat out wrong.
17:58:30 <erisco> kakashiA1, the report uses the same word "method" https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
17:58:36 <iqubic> :t let x = 1 in x
17:58:37 <lambdabot> Num p => p
17:58:44 <erisco> "A class declaration introduces a new class and the operations (class methods) on it."
17:58:59 <iqubic> I bound the variable to a name, and still haskell didn't pick a type.
17:59:24 <kakashiA1> iqubic: so it has nothing to do with laziness, it has something to do with "to less information to determin what you want, just just gave me a literal" right?  (please say yes)
17:59:33 <EvanR> iqubic: it picked a type, the most general type
17:59:44 <kakashiA1> EvanR: yep :)
18:00:01 <iqubic> EvanR: I suppose.
18:00:07 <iqubic> :t ()
18:00:09 <lambdabot> ()
18:00:13 <erisco> kakashiA1, yeah the presenter is a bit confused here
18:00:16 <kakashiA1> what I didnt know foo = 42   <---even this is a function O_O
18:00:25 <erisco> kakashiA1, the reason he gets x :: Integer is because of a feature called defaulting
18:00:25 <EvanR> thats not a function
18:00:29 <kakashiA1> erisco: okay, you see its not my fault :P
18:00:37 <EvanR> :t 42
18:00:40 <lambdabot> Num p => p
18:00:40 <geekosaur> this is one of those things where any word has to have exactly one meaning, isn't it? (god help you when you discover "functor" which means something different in every language that claims to have the concept)
18:00:43 <EvanR> no ->
18:01:02 <erisco> and saying "Haskell is being lazy" for that example he did probably not intend to conflate with laziness/non-strictness, but it wasn't a wise choice of words
18:01:12 <kakashiA1> EvanR: it is a function, that just returns a constant value (according to some scripts that I have)
18:01:16 <EvanR> no
18:02:02 <EvanR> functions take arguments, functions have a source and target domain
18:02:10 <kakashiA1> EvanR: foo = 42   is a function according to some scripts, maybe its also just a definition thing like with the word "method"
18:02:15 <erisco> kakashiA1, also this behaviour seems to have changed in ghci because I don't see that in 8.2.1
18:02:34 <EvanR> not in haskell
18:03:16 <erisco> kakashiA1, but anyways, the defaulting feature applies when an instance choice is ambiguous but one has to be made (for some reason or another)
18:03:19 <kakashiA1> EvanR: hmm...okay
18:04:42 <erisco> > 1 + 2
18:04:49 <lambdabot>  3
18:05:07 <erisco> to compute 3 it had to make a choice on what instance to use, even though the choice was ambiguous. It did this by using the default.
18:05:08 <iqubic`> What's the point of that?
18:05:28 <iqubic`> default is int.
18:05:36 <erisco> it is usually Integer
18:06:32 <kakashiA1> > :t (1 + 2)
18:06:35 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
18:06:48 <iqubic> :t (1 + 2)
18:06:51 <lambdabot> Num a => a
18:07:00 <erisco> I wonder if that change in ghci was around the monomorphism restriction …
18:07:08 <iqubic> It's not actually computing that there.
18:07:18 <iqubic> It's just giving you the type of (+)
18:07:25 <erisco> > 1 + 2 :: Num a => a
18:07:28 <lambdabot>  3
18:07:43 <erisco> it still arbitrated that  a = Integer
18:08:04 <erisco> > maxBound :: Int
18:08:05 <kakashiA1> iqubic: I dont agree because () in haskell means to evaluate the stuff inside ()
18:08:08 <lambdabot>  9223372036854775807
18:08:18 <erisco> > 9223372036854775807 + 1
18:08:21 <lambdabot>  9223372036854775808
18:08:38 <kakashiA1> :t 9223372036854775808
18:08:41 <lambdabot> Num p => p
18:09:03 <erisco> () in Haskell is either a type or a data constructor
18:09:06 <erisco> :t ()
18:09:08 <lambdabot> ()
18:09:13 <kakashiA1> erisco: never said that
18:09:16 <erisco> we pronounce it "unit"
18:09:32 <Welkin> :type (maxbound :: Int) + 1
18:09:36 <erisco> okay then I am not sure what you are referring to
18:09:42 <kakashiA1> erisco: just said that if haskell sees ( something )  it will evaluate something first
18:09:46 <Welkin> :type (maxBound :: Int) + 1
18:09:51 <erisco> kakashiA1, that is not true
18:10:00 <Welkin> :t (maxBound :: Int) + 1
18:10:02 <Welkin> damn it lambdabot
18:10:02 <kadoban> kakashiA1: All () does in that sense is change precedence, it doesn't force haskell to evaluate anything
18:10:03 <lambdabot> Int
18:10:10 <Welkin> > (maxBound :: Int) + 1
18:10:17 <lambdabot>  -9223372036854775808
18:10:20 <Welkin> lol
18:10:33 <kakashiA1> erisco: hmmm...okay
18:10:39 <Welkin> nothing in haskell is evaluated
18:10:39 <kadoban> > take 2 [1, 2, (undefined + undefined)]
18:10:44 <lambdabot>  [1,2]
18:10:52 <erisco> I am not exactly sure how to demonstrate it is not the case because I don't really understand how it'd work
18:10:54 <glguy_> kakashiA1: if you're getting confused about what is and isn't a function you should check out http://conal.net/blog/posts/everything-is-a-function-in-haskell
18:11:24 <EvanR> > Nothing
18:11:27 <lambdabot>  Nothing
18:11:38 <kakashiA1> glguy_: thanks!
18:12:30 <iqubic> Why not say everything has an implicit () as the first param?
18:12:37 <EvanR> why should you?
18:12:44 <exio4> because that's not what happens
18:12:55 <EvanR> its not accurate or helpful
18:13:25 <iqubic> But then it gives everything a function looking form.
18:13:33 <EvanR> try justifying (1 () + 2 ()) () in grade school math
18:13:49 <EvanR> "everything is a _" is just silly
18:14:12 <amalloy> don't forget that () is still not a function in this weirdo universe
18:14:18 <amalloy> so you don't even get what you wanted
18:14:25 <iqubic> Oh, lol
18:14:36 <iqubic> > Just ()
18:14:38 <EvanR> 1 (() (() (...
18:14:40 <lambdabot>  Just ()
18:15:07 <erisco> that's a categorical way to add constants, or at least that is a method I've seen in my limited CT study
18:15:13 <amalloy> EvanR: well we'd make function application right-associative for ease of use, in this language. then you could just write 1 () () () () () () () ...
18:15:58 <EvanR> erisco: generalized points... * -> X
18:16:18 <glguy> It's just as useless to speculate that "everything is an Int"
18:16:22 <iqubic> Does Haskell have anything equivalent to instanceof?
18:16:40 <EvanR> no
18:17:27 <iqubic> Why not?
18:18:01 <EvanR> the question is decidable at compile time
18:18:11 <EvanR> no need for a runtime test
18:18:46 <erisco> everything is zeros and ones
18:18:50 <amalloy> EvanR: except for polymorphic types, where it's decidable at neither compile time or runtime
18:18:54 <erisco> I mean everything is voltages
18:19:18 <EvanR> everything is either an instance of a class, or not known to be an instance of a class
18:19:44 <erisco> I mean everything is electrons that in this place but they'd rather be in that other place
18:19:45 <EvanR> (yet)
18:19:55 <jpx__> Why would anyone ever use Haskell over ADA, the programming language the DoD uses to write the missle navigation software
18:20:59 <kakashiA1> how do you READ that:   foo :: Num a => a     (foo has the type that implies a is Num) ?
18:21:05 <erisco> since they left the door open, maybe the pizza man can come in and teach them Haskell
18:21:21 <EvanR> you mean, how do you pronounce it
18:22:02 <EvanR> i read foo :: Num a => a
18:22:14 <iqubic> If I have a "Data Difficulty = Easy | Medium | Hard" can I make three different versions of "Instance GameAPI Easy where"?
18:22:36 <EvanR> where Easy is a value ?
18:22:40 <iqubic> Yes.
18:22:46 <EvanR> then it makes no sense
18:22:53 <EvanR> only types go where you put Easy
18:22:59 <ClaudiusMaximus> DataKinds!
18:23:04 <iqubic> Defined in that data declaration above.
18:23:15 <glguy_> You don't need to definite any type classes at all to write your 2048 game
18:23:18 <EvanR> if this is DataKinds, then no
18:23:21 <iqubic> I know.
18:23:37 <EvanR> only 1 instance per type
18:23:40 <erisco> for all types a, foo has the type a given a is an instance of Num.
18:24:49 <iqubic> Can I get intero to show me code sugggestions as I type, and then select the suggestions that I want?
18:25:48 <erisco> the notation gives you a bit of whiplash for understanding what it means
18:25:49 <amalloy> iqubic: for dispatch based on values, you use pattern matching, not typeclasses
18:26:03 <metahumor> does Data.Ratio expose a way to use (%) as a view?
18:26:12 <metahumor> or as a pattern-match?
18:26:16 <iqubic> amalloy, I figured that out shortly after I asked.
18:26:26 <iqubic> metahumor: What are you trying to do?
18:26:50 <erisco> oh boy, canonicalisation!
18:27:05 <metahumor> iqubic: i'm trying to make a predicate for filter that pattern matches on a "(a % b)"
18:27:18 <amalloy> pattern-matching is the closest thing to "instanceof" also, because we model sums of types as multiple constructors rather than multiple types
18:27:29 <kakashiA1> EvanR: I mean if you would read it to someone else (I know that you say "implies" to => )
18:27:50 <erisco> huh?
18:28:00 <erisco> is this some bot net conspiracy?
18:28:39 <mniip> no it's irccloud
18:28:48 <iqubic> So no one knows how to get intero to show code suggestions? Like if I type "Fil" I want to be able to see the type and module the filter function comes from.
18:29:19 <erisco> whizbang technology no doubt
18:30:07 <geekosaur> cloud technology. and we're getting a cloudburst...
18:30:23 <metahumor> i have a "match (a % b) = f a b", but I get "Parse error in pattern (a % b)"... do i have to use "numerator" and "denominator"?
18:30:28 <iqubic> Also, yasnippets doesn't seem to be working with intero either.
18:30:36 <geekosaur> yes, and a guard
18:30:43 <geekosaur> % is not a constructor
18:30:44 <yahb> geekosaur: ; <interactive>:11:1: error:; * Variable not in scope: is :: (Bool -> Bool) -> t0 -> t1 -> t; * Perhaps you meant one of these: `Control.Category.id' (imported from Control.Category), `id' (imported from Prelude), `iso' (imported from Control.Lens); <interactive>:11:8: error: Variable not in scope: a; <interactive>:11:10: error: Variable not in scope: constructor
18:31:17 <geekosaur> it would be a variable in infix position, except you already used one so a constructor is expected instead
18:31:45 <erisco> thanks yahb. lookin' out for us.
18:32:56 <kakashiA1> hmm... I did this:
18:33:10 <kakashiA1> > myList = [1, 2, 3]
18:33:14 <lambdabot>  <hint>:1:8: error:
18:33:14 <lambdabot>      parse error on input ‘=’
18:33:14 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
18:33:46 <erisco> lambdabot is not GHCi … try  @let myList = [1, 2, 3]
18:34:50 <kakashiA1> erisco: okay, do you understand this:
18:34:53 <kakashiA1> https://paste.xinu.at/rHH/ts
18:34:54 <erisco> I have a great new bot name: LING (LING is not GHCi)
18:35:39 <kakashiA1> I mean is myList not from type [Int] ?
18:36:05 <erisco> okay, again, integer literals have type  Num a => a
18:36:14 <metahumor> kakashiA1: no, it's not. when you do the "[...] :: [Int]", you're just asking for a possible instance
18:36:31 <glguy> instantiation*
18:36:52 <metahumor> kakashiA1: yes, glguy is right
18:36:57 <erisco> so if you construct a list from integer literals, it is going to be a list of numbers of some Num type
18:37:17 <metahumor> kakashiA1: imagine I had defined a "xs = [minBound .. maxBound]", then xs :: (Enum a, Bounded a) => [a]
18:37:18 <glguy> kakashiA1: First you declared myList without a type signature, so it got the inferred general type of  Num a => [a]
18:37:35 <erisco> possibly the confusion here is REPL vs file
18:37:54 <erisco> if you write that in a file then :t myList will tell you myList :: [Int]
18:38:00 <metahumor> kakashiA1: "xs :: [Int32]" would be very different than "xs :: [Int64]"
18:38:49 <erisco> what you told GHCi is "define myList as [1, 2, 3, 2, 7]" then you told it "print value of the expression myList :: [Int]"
18:39:01 <kakashiA1> you mean in the REPL, if you execute the constructior before and there are no typesignatures, it will take its own type and neglect every typesignature that comes after?
18:39:02 <glguy> kakashiA1: When you entered myList on its own into GHCi, then GHCi used defaulting to determine the type as [Integer] before it was printed
18:39:17 <glguy> kakashiA1: The thing that came after wasn't a type signature for that declaration
18:39:24 <glguy> it was an expression with a type ascription
18:39:27 <glguy> just like:
18:39:31 <glguy> > [1,2,3] :: [Int]
18:39:35 <lambdabot>  [1,2,3]
18:39:46 <metahumor> > [] :: [Int]
18:39:50 <lambdabot>  []
18:39:55 <metahumor> > [] :: [Char]
18:40:00 <lambdabot>  ""
18:40:02 <metahumor> > []
18:40:06 <lambdabot>  []
18:40:21 <metahumor> maybe [Char] wasn't the best example
18:40:26 <erisco> however, get this… if you tell it  myList = [1,2,3,2,7]; myList :: [Int]  then  :t myList  will tell you  myList :: [Int]
18:41:42 <glguy> This is confusing because GHCi is more clever now than it used to be. In the paste you'd have to put that all in a single let
18:41:45 <erisco> basically, you have to know the REPLisms to understand what you're doing
18:41:54 <kakashiA1> glguy: okay:
18:41:56 <kakashiA1> https://paste.xinu.at/kXem4Y/
18:42:11 <kakashiA1> glguy: as I thought and explained :P
18:43:05 <erisco> when in doubt you can just stick it in a file then :l the file
18:43:19 <erisco> or invoke ghci with the file name as argument
18:44:39 <erisco> everything you put into the REPL is a command, and is not the same as just writing Haskell code in a file
18:45:16 <erisco> though they've done a lot of work to make it convenient and mostly predictable
18:45:42 <erisco> ctrl+c is borked on Windows but, eh, who cares about Windows
18:45:49 * erisco cares immensely
18:48:07 <kakashiA1> why does haskell have two notations for creating a list with unlimted items?
18:48:20 <kakashiA1> [1..]  <---two points
18:48:21 <erisco> and what two notations is that?
18:48:35 <kakashiA1> [1, 2...]  <---thre points
18:48:57 <erisco> well, those desugar to different methods of the Enum class
18:49:01 <glguy> [1..] is when you want the default of stepping by 1, the other is when you want to be able to change that default
18:49:34 <erisco> > enumFrom 1
18:49:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:49:40 <erisco> > enumFromThen 1 2
18:49:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:49:57 <erisco> > enumFromThen 1 3
18:50:01 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
18:50:16 <erisco> note that it is defaulting to Integer, which we talked about earlier
18:50:46 <metahumor> I've never used the "three points" syntax, i thought "[1,3..]" is sufficient
18:50:55 <kakashiA1> erisco: if thats the case (stepping by 1) why [1, 2, 3..] is not working?
18:51:08 <erisco> wait a minute… three points?
18:51:42 <glguy> kakashiA1: That's not one of your choices
18:51:51 <erisco> that is just a syntax error, i.e. the three dots
18:52:35 <erisco> [x..] or [x,y..] or [x,y..z] or [x..z]
18:52:40 <erisco> did I miss any?
18:53:26 <erisco> enumFrom x; enumFromThen x y; enumFromThenTo x y z; enumFromTo x z
18:53:31 <kakashiA1> still dont understand the difference between 2 and 3 dots :/
18:53:45 <erisco> 3 dots isn't a thing … where did you see that?
18:53:48 <metahumor> we're saying that there's only "2 dots", no "3 dots"
18:53:52 <geekosaur> thta's it. nor cal they be used in the middle of another list (unless making a list of lists)
18:53:55 <[Leary]> > [1,2...]
18:53:58 <glguy> kakashiA1: the difference is that one is an error and the other isn't
18:53:58 <lambdabot>  error:
18:53:58 <lambdabot>      A section must be enclosed in parentheses thus: (2 ...)
18:55:57 <erisco> > [1,2.0..]
18:56:01 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0...
18:56:46 <kakashiA1> erisco, glguy: its its a type inside a script
18:56:52 <kakashiA1> type = typo
18:57:04 <erisco> :t (X...) -- out of interest
18:57:06 <lambdabot> error:
18:57:06 <lambdabot>     Not in scope: ‘X...’
18:57:06 <lambdabot>     No module named ‘X’ is imported.
18:57:31 <erisco> ha ha, I suspected so… but that would be undefinable… right? curious
18:58:21 <glguy> :t (X.--)
18:58:23 <lambdabot> error:
18:58:23 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
18:58:32 <erisco> could you make an object file with that name, though
18:58:45 <glguy> GHCi reports  Not in scope: ‘X.--’
18:58:57 <erisco> lol
18:59:07 <geekosaur> yeh, hint's parser is a bit too loose about comments
19:03:27 <[Leary]> (X[symbols]) would be ambiguous if X were a constructor and [symbols] were a valid infix name, so presumably those cases are ruled out.
19:04:31 <glguy> :t (Just.)
19:04:33 <lambdabot> (a1 -> a2) -> a1 -> Maybe a2
19:04:46 <[Leary]> (in particular I'm actually writing code atm in which both X and ... are defined)
19:11:21 <kakashiA1> stupid question, but why does haskell implemented two ways to create a list?
19:11:31 <iqubic> It does?
19:11:40 <erisco> two notations? because some like it hot and some like it cold
19:11:56 <kakashiA1> [1, 2, 3] ist the same like (1: (2: (3: [])))
19:12:10 <iqubic> One is more verbose.
19:12:13 <erisco> some like it in the pot three days old
19:12:31 <iqubic> It's syntactic sugar.
19:12:41 <kakashiA1> hmm....I see no benefit in that :/
19:13:10 <iqubic> Hardly anyone uses the second form to write lists, becuase it is more typing and look uglier.
19:13:13 <glguy> It's a nice way to define lists in your source code. If you don't like it you don't have to use it
19:13:28 <iqubic> Do what you want to do.
19:13:41 <iqubic> No one is forcing you to pick on style over the other.
19:13:46 <erisco> do I understand why people like list comprehensions? not really, but I just let them have their toy
19:14:28 <kakashiA1> okay, I thought there is a deeper meaning and reason why haskell has it
19:14:38 <iqubic> erisco: What do you use instead? the List monad?
19:15:08 <erisco> iqubic, or fmap, or filter, or a variety of other choices
19:16:03 <erisco> though it does have that handy pattern guard feature
19:16:45 <iqubic> What does? List comprehensions?
19:16:52 <erisco> yes
19:17:10 <metahumor> underneath, in ghc base definitions, is list defined in terms of "[a,b,c]" or "a:b:c:[]"?
19:17:20 <sqooq> the latter
19:17:29 <sqooq> actually, don't listen to me
19:17:32 <sqooq> I'm a novice
19:17:39 <iqubic> But that is true.
19:18:46 <iqubic> Data List a = [] | a : List a
19:19:17 <metahumor> yet the monad instance is defined using a list comprehension, right?
19:19:32 <glguy> probably not
19:19:34 <monochrom> I don't think so.
19:19:36 <[Leary]> Isn't it the other way around?
19:19:43 <monochrom> I don't think so either.
19:19:43 <erisco> that'd be a really bad idea with the monad comprehension extension, at least
19:20:28 <glguy> I don't know if it's still the case, but in the past GHC would generate faster code when you used list comprehensions than the equivalent do-notation
19:20:34 <monochrom> There is too much urban legend and wishy assumption on "since I can see their equivalence I'm pretty sure actual compilers actually do this"
19:20:51 <mniip> I wouldn't expect it to look particularly pretty because it was engineered to be fast
19:21:05 <metahumor> " -- See Note: [List comprehensions and inlining] -- | @since 2.01 instance Monad []  where     {-# INLINE (>>=) #-}     xs >>= f             = [y | x <- xs, y <- f x]"
19:21:09 <mniip> the monad instance probably refers to two module-bound identifiers
19:21:12 <metahumor> that's in https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#line-819
19:21:25 <mniip> oh huh
19:21:38 <mniip> that's interesting
19:21:44 <metahumor> i was reading monad instance definitions recently, and so i was surprised
19:22:40 <erisco> I am going to guess you'd have to go to Core to figure out what the difference is
19:22:51 <iqubic> Well, looks like list comprehensions and do notation boil down to the same thing more or less.
19:22:57 <metahumor> similar for "xs *> ys  = [y | _ <- xs, y <- ys]"
19:24:12 <mniip> erisco, not core
19:24:14 <mniip> rather RULES
19:24:28 <mniip> or DsListComp
19:24:58 <erisco> okay, good to know, but I mean the difference will be instantiated by Core
19:25:11 <erisco> RULES explain it, then
19:25:26 <danielmantovani> test
19:39:52 <p0a> Hello I'm trying to find the 10001st prime (project euler 7). Here's my code: https://pastebin.com/chFNh6Dq It's taking SO LONG! Is it really that bad?
19:40:05 <p0a> It's been at least 10 minutes
19:40:54 <metahumor> p0a: can you describe what happens when you run isPrime 4? what about isPrime 8?
19:41:16 <p0a> metahumor: I'm using the "optimized" version
19:41:21 <p0a> so isprime 4 should not be there
19:41:57 <p0a> isprime 4 and 8 return False...?
19:42:27 <p0a> so you're saying isprime is not lazy?
19:42:42 <freeside`> 20180105-19:41:56 mengwong@venice2:~/Desktop% time ./Euler7 > /dev/null
19:42:42 <freeside`> ./Euler7 > /dev/null  0.31s user 0.02s system 84% cpu 0.380 total
19:42:57 <glguy> p0a: Compiled with optimizations your code runs in 9.024s for me
19:43:24 <p0a> glguy: Should I compile with optimizations? I usually use the interactive haskell
19:43:37 <p0a> btw 9s is quite acceptable... I was waiting 10+ minutes
19:43:48 <freeside`> https://github.com/jmarianer/euler-haskell/blob/master/Euler7.hs
19:43:49 <p0a> or maybe 2 minutes. I don't know, but i t was a long time
19:44:01 <freeside`> (spoiler warning)
19:44:53 <glguy> p0a: your solution is going to be a bit slow since it's just doing trial division, but it'll be fast enough for this particular problem
19:45:30 <p0a> Yeah it's also the wrong answer for some reason. It computed the 9999th prime instead of the 10001th prime
19:46:03 <freeside`> usually programs are either slow and correct, or fast and wrong, but this seems to have landed on slow and wrong
19:46:29 <p0a> the sweet spot
19:46:32 <freeside`> this is a sign that you are now ready to INVENT YOUR OWN CRYPTOCURRENCY
19:47:04 <capisce> a rite of passage
19:47:21 <freeside`> in the old days the rite of passage was to just roll your own ORDBMS
19:47:38 <p0a> bitter much?
19:47:43 <freeside`> now it's writing your own javascript framework
19:47:48 <p0a> can't hear you over the sound of my lambos engine
19:47:54 <Welkin> I always grab an off-the-shelf library for everything
19:47:55 <freeside`> haha
19:48:16 <metahumor> you mean, write your own crypto for secure message passing
19:48:21 <metahumor> Welkin: i'm the same way
19:48:30 <metahumor> "import antigravity" xkcd
19:48:30 <Welkin> well, not *Everything*
19:48:33 <Welkin> there are limitations
19:48:42 <freeside`> we call such people "leftpad maximalists"
19:48:46 <Welkin> lol
19:50:00 <Welkin> is that comic in the book "What if?"
19:50:06 <mantovan`> just testing
19:50:06 <mantovan`>  
19:50:09 <Welkin> I just got it but haven't read the whole thing
19:50:20 <p0a> aha!
19:50:22 <mantovan`> test 2
19:50:24 <p0a> There's a bug
19:50:39 <metahumor> "leftpad = lambda n, s: ("{:>"+str(n)+"}").format(s)"
19:50:45 <p0a> nthprime 62 gives 289. But 289 is composite!
19:50:50 <p0a> o_O
19:51:06 <metahumor> congrats, you've found the -1st mersenne prime
19:51:25 <metahumor> Welkin: https://xkcd.com/353/
19:51:30 <p0a> lol
19:52:53 <p0a> oh wow! 289 = 17^2 and apparently nthprime 7 == 16!!!!
19:53:01 <freeside`> you can haz bug
19:53:09 <iqubic> What are we doing here?
19:53:16 <freeside`> euler 7
19:53:22 <glguy> iqubic: Does 2048 work?
19:54:30 <p0a> oh wow I see it
19:55:07 <p0a> [2+head ps..] _still_ includes even numbers in it
19:56:03 <metahumor> it'd be pretty cool if "(..)" figured out the rules of the preceding sequence and inducted on it
19:56:14 <p0a> [2,4..10] works fine but
19:56:28 <p0a> I'm not sure if [2+head ps, 4+head ps..] will work
19:56:44 <p0a> well I guess it does
19:57:09 <erisco> that's a question for artificial intelligence
19:57:18 <freeside`> yeah, sooner or later some deep learning engine will give you guessSequence
19:57:31 <p0a> well you can just use oieas or whatever it is called
19:57:36 <p0a> and autocomplete
19:59:35 <freeside`> mlGuess :: (Traversable t) => t a -> (t a -> a)
20:00:12 <metahumor> freeside`: it's pretty hard to get a neuralnet to get FizzBuzz right
20:00:31 <monochrom> telepathic_guess :: IO [a]
20:01:15 <monochrom> Most programmers aren't better than neural nets.
20:02:17 <erisco> the problem is easier if you know what "multiple of 5" and "multiple of 3" mean and what "this AND that" means and so forth
20:02:41 <metahumor> unfortunately, "multiple of n" is not a simple linalg operation
20:02:49 <erisco> if I showed you a bunch of seemingly random symbols over and over again it'd probably take you a long time too to understand what any of it was about
20:03:50 <p0a> ah compiling with -O2 makes it run pretty fast
20:03:56 <p0a> thank you!
20:04:25 <iqubic`> Why do we need IO for that list?
20:04:53 <erisco> most people's minds aren't pure … in fact they're downright filthy.
20:04:58 <iqubic`> LOL. I see.
20:05:10 <monochrom> You know telepathy don't you?
20:05:17 <iqubic`> Course.
20:05:26 <iqubic`> I get the joke the erisco
20:05:31 <iqubic`> was going for.
20:26:33 <jle`> metahumor: it could just do a lookup of the OEIS
20:42:48 * hackage network-arbitrary 0.1.0.0 - Arbitrary Instances for Network Types  https://hackage.haskell.org/package/network-arbitrary-0.1.0.0 (alunduil)
20:43:00 <Gurkenglas> If oeis remembers pairs of preliminary and corrected queries, they might be able to automate correcting them...
20:46:38 <Welkin> isis?
20:46:40 <Welkin> osiris?
20:46:56 <Welkin> didn't verizon have a product called "isis"?
20:47:08 <Welkin> and there was a release of a linux distro called "Isis" too
20:47:16 <Welkin> someone made a youtube video all excited about it
20:47:22 <Welkin> they said "ISIS IS COMING! YES!"
20:47:37 <Welkin> this was before the isis terrorist group existed though
20:47:42 <Welkin> still, funny is a dark way
20:51:24 <Gurkenglas> Welkin, Online Encyclopedia of Integer Sequences
20:52:14 <Gurkenglas> Your numbers follow some pattern, you look up whether anyone found that pattern important enough to write about.
20:54:56 <MarcelineVQ> Personally I like the pattern that any 9 involved in digit-wise addition cancels out.
20:55:39 <MarcelineVQ> not sure how to write that as a sequence though
20:57:09 <wedify> does this program work for anyone else? on my machine it makes a window with random content. this window can be moved but not closed. nor does pollEvent seem to return any events
20:57:14 <wedify> http://lpaste.net/361402
20:58:15 <iqubic> Why is it that the two documentation searchers, hoogle, and hayoo have similar names to other big companies.
20:58:48 <glguy> there's no way to know
20:58:54 <Clint> unpossible
20:59:02 <iqubic> My search engine, Duck Duck Go keeps autocorrecting to the obvious one, making it really hard to find what I want.
20:59:55 <iqubic> More specifically, I'm trying to find a way to integrate either hoogle, or hayoo into emacs, and keep getting results for how to integrate the more common engine into emacs
21:00:31 <redrapscallion> in haskell's wiki, one thing they say about "do" statements is that "the order of statements is not the criterion for the evaluation order". The snippet from wiki is this one : http://lpaste.net/6651601415930118144
21:00:41 <redrapscallion> while it's true that the order of statements doesn't guarantee evaluation order, are there any situations in which this severely matters?
21:00:54 <Gurkenglas> *checks in confusion for that sort of problems seems weird* *oh right im using google*
21:01:28 <iqubic> Gurkenglas: Why does using google change your outlook on this issue?
21:01:38 <Gurkenglas> Because it does not make that autocorrection mistake
21:01:53 <glguy> redrapscallion: It can be the difference between evaluation terminating or not
21:02:13 <iqubic> Ah, I see.
21:02:29 <freeside`> iqubic: maybe the + prefix will help in your search terms?
21:02:36 <iqubic> Does it make the Hayoo <=> Yahoo translation?
21:02:39 <Gurkenglas> iqubic, duckduckgo does seem to provide an option to not do the autocorrection when I search for 'integrate hoogle into emacs'
21:02:51 <geekosaur> + prefix doesn't do anything any more. double quotes replace it
21:02:53 <p0a> what's the natural way to have a list become f(1st) ++ f(2nd) ++ f(3rd) ++ ...
21:03:05 <Gurkenglas> iqubic, no
21:03:11 <freeside`> oic
21:03:14 <geekosaur> :t concatMap
21:03:17 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
21:03:19 <glguy> redrapscallion: execState (undefined >> put True) False -- True
21:03:22 <glguy> redrapscallion: [] >> repeat () -- []
21:03:25 <Clint> there sure are a lot of hoogles at https://duckduckgo.com/bang?c=Tech&sc=Languages+(Haskell)
21:04:27 <p0a> geekosaur: thanks!
21:04:39 <iqubic> Yeah, that means I can just search Hoogle directly by typing "!ho <term>" and DDG will redirect me to the right place.
21:05:02 <geekosaur> (this is also the list monad, btw)
21:05:04 <Welkin> you don't need ho
21:05:05 <Welkin> you ho!
21:05:08 <Welkin> you can use !h
21:05:12 <Welkin> :P
21:05:24 <Welkin> also !hayoo
21:05:24 <iqubic> Welkin: Do you use DDG?
21:05:26 <Welkin> yes
21:05:45 <freeside`> but if hoogle is a search engine, why are you using DDG to search another search engine?
21:06:05 <Welkin> I ddg as my default search engine
21:06:13 <Welkin> so when I type into the address bar, it searches ddg
21:06:24 <iqubic> Yeah, me too.
21:06:33 <iqubic> Which is why I like the bang patterns
21:06:42 <Welkin> I use lots of bangs in ddg
21:07:02 <iqubic> I think I submitted my own bang at one point.
21:07:08 <Welkin> !h, !hayoo, !w, !gt, !gm
21:07:11 <iqubic> Let's see if that still works.
21:07:18 <Welkin> !a
21:07:21 <Welkin> use that one a lot
21:07:42 <Welkin> it's the killer feature of ddg in my opinion
21:07:48 <iqubic> Yup, my custom bang that I submitted a few years back still works.
21:08:06 <Welkin> oh yeah, also !yt
21:08:09 <iqubic> What are !w, !gt, and !gm?
21:08:20 <Welkin> of course, you can add something after the bang and it searches that site
21:08:34 <Welkin> very helpful for youtube
21:08:40 <Welkin> iqubic: try them and see
21:09:21 <iqubic> Ah, I see.
21:09:24 <iqubic> I like those.
21:09:42 <MarcelineVQ> neat  !hayoo String -> Int
21:10:01 <p0a> is there another trick except let y = x:y to repeat [x,x,x,x,..]?
21:10:11 <Gurkenglas> :t repeat
21:10:13 <lambdabot> a -> [a]
21:10:19 <p0a> thanks!
21:10:21 <Gurkenglas> :t fix . (:)
21:10:23 <lambdabot> a -> [a]
21:10:48 <iqubic> I think (reapeat x) is easier to understand.
21:10:50 <MarcelineVQ> also [x,x..]
21:11:07 <MarcelineVQ> That needs Enum though
21:11:18 <glguy> and won't benefit from the sharing repeat does
21:11:28 <p0a> sharing?
21:11:35 <iqubic> glguy: [x,x..] isn't lazy?
21:11:57 <iqubic> I assume that's what sharing means
21:12:01 <glguy> It's not
21:12:16 <glguy> repeat n   will make a single use of (:) that points back to itself in the tail
21:12:39 <Gurkenglas> p0a, [x,y..] has to add the difference each time, so [x,x..] has to add 0 each time which repeat knows not to need
21:13:07 <iqubic> repeat n = let ns = n:ns in n
21:13:26 <Gurkenglas> *in ns
21:13:36 <iqubic> Yeah, I realized that.
21:14:19 <p0a> Gurkenglas: ah nice
21:14:47 <p0a> so if x had side effects that I wanted to evaluate
21:15:03 <p0a> [x,x..] would be better than (repeat x)! Or... ? just a silly question
21:15:08 <glguy> No, side effects don't factor in
21:15:32 <glguy> repeat x is always the best of the alternatives above
21:15:44 <p0a> alright
21:15:46 <p0a> thank you
21:15:56 <iqubic> An infinite list of [IO Int] can be gathered both ways, but I repeat x is the better way.
21:16:16 <Gurkenglas> Eh, you could write a version of repeat that'd ding a side effect each time someone accesses an element of the list if you really wanted to
21:16:46 <Gurkenglas> *that wasn't accessed yet
21:17:13 <p0a> I can see that
21:17:29 <glguy> You'd be driving off into unsafe functions that aren't really pertinent to the question of how to build this list
21:18:13 <p0a> it was just a silly question. I'm staying on the pure side for now and I had forgotten about how that part of haskell works
21:19:10 <p0a> gotta go!
21:19:30 <iqubic> Laziness is one of Haskell's major appeals.
21:19:47 <iqubic> So is the strict nature of the type checker.
21:20:39 <iqubic> If your code compiles, then there's a 90% chance it will do the right thing™
21:21:08 <Gurkenglas> Note that [x,x..] wouldn't infinitely replicate side effects of x, but those of adding 0
21:21:16 <iqubic> Around 90% by my estimates
21:22:21 <MarcelineVQ> who keeps telling people that..
21:22:34 <Gurkenglas> his estimates, keep up
21:23:03 <glguy> iqubic: Write some code so you can get data for your estimate
21:23:31 <iqubic> I really should. I need to get away from IRC
21:24:51 <glguy> We can put you on a voluntary "getting some code written" mute if you want
21:26:00 <iqubic> No thanks. I'll just go on and do it myself.
21:28:58 <metahumor> forget Boolean Blindness, I had Ordering Blindness today
21:29:21 <metahumor> its very easy to write wrong code when using "comparing `on` f" syntax
21:29:52 <[Leary]> My version of the statement is: If you refactor correct code and it compiles, it's probably still correct. If you write /new/ code that compiles, it will probabably have behaviour belonging to restricted, interpretable set that you can then find the correct code in relatively easily.
21:30:09 <[Leary]> Not quite as catchy though.
21:32:11 <geekosaur> xmonad is a lovely example of "just because it compiles doesn;t mean it does anything you intended". (because most of the actual behavior depends on what your code told the X server to do.)
21:38:17 * hackage hspec 2.4.5 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-2.4.5 (SimonHengel)
21:44:49 <[Leary]> I had some pretty interesting behaviour from it the other day. I could switch away from a workspace, then switch back to find the windows in different places. Non-deterministic tiling!
21:45:44 <[Leary]> Turns out the layout I was writing was accidentally doing some differences where it was supposed to be doing intersections, and was giving most of the windows more than one Rectangle.
21:46:14 <[Leary]> I don't really know how it works in the background but I guess it resulted in a race condition.
21:50:16 <geekosaur> not a race condition, but if you weren't returning what X.O.windows expected (a list of Rectangles, subsequently zipped against the current workspace's Stack) then you could certainly see odd things.
22:38:37 <ongy> is there any downside to add Show instances to types if they are never used?
22:43:41 <geekosaur> a few extra (static) dictionaries lying around
22:43:54 <Welkin> who doesn't love dictionaries?
22:44:00 <Welkin> you can read them when you get bored
22:44:50 <ongy> can the linker not optimize them out?
22:47:38 <geekosaur> probably not
22:47:53 <geekosaur> are you really that starved for space?
23:02:12 <ongy> no, just wondering if I can just add them without any worries
23:30:18 * hackage fast-arithmetic 0.1.1.0 - Fast number-theoretic functions.  https://hackage.haskell.org/package/fast-arithmetic-0.1.1.0 (vmchale)
