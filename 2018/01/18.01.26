00:04:09 <rzhanka> Is there a standard way to get linked list functionality in Haskell? By which I mean a circular (infinite) list with O(1) inserts and O(1) cutting of the circle. (take m . drop n . cycle) is convenient for rotating a list, but not very efficient, and take 4 (2:(cycle [1])) gets you [2,1,1,1] not [2,1,2,1]
00:05:39 <mniip> a slightly smart zipper?
00:05:59 <mniip> gets you amortized O(1) movement/pop
00:07:55 <rzhanka> mniip: sorry, I'm not quite following
00:08:00 <ertes-w> helo
00:08:10 <Rembane> ertes-w: ehlo
00:09:16 <ertes-w> rzhanka: Data.Sequence can be used as a ring buffer, where the head is the current element
00:10:50 <ertes-w> rzhanka: it supports efficient rotation: if the ring has n elements, rotating by c means splitting it at (mod c n) and just flipping the two parts
00:11:54 <ertes-w> @let import Data.Sequence (Seq, ViewL(..), ViewR(..), (<|), (|>), viewl, viewr); import qualified Data.Sequence as Seq
00:11:56 <lambdabot>  Defined.
00:14:10 <ertes-w> @let rotate c xs = let (xs1, xs2) = Seq.splitAt (c `mod` Seq.length xs) xs in xs2 <> xs1
00:14:12 <lambdabot>  Defined.
00:14:24 <ertes-w> > rotate 3 (Seq.fromList [1..10])
00:14:28 <lambdabot>  error:
00:14:28 <lambdabot>      Ambiguous occurrence ‘rotate’
00:14:28 <lambdabot>      It could refer to either ‘Data.Bits.rotate’,
00:14:38 <ertes-w> @let ringRotate c xs = let (xs1, xs2) = Seq.splitAt (c `mod` Seq.length xs) xs in xs2 <> xs1
00:14:41 <lambdabot>  Defined.
00:14:43 <ertes-w> > ringRotate 3 (Seq.fromList [1..10])
00:14:47 <lambdabot>  fromList [4,5,6,7,8,9,10,1,2,3]
00:14:52 <ertes-w> rzhanka: ^
00:17:14 <Zemyla> So pattern synonyms are generally desugared into a sort of matcher function which takes a success case and a failure case.
00:17:52 <rzhanka> ringRotate 2 (20 <| (ringRotate 2 (Seq.fromList [1..10])))
00:18:06 <rzhanka> > ringRotate 2 (20 <| (ringRotate 2 (Seq.fromList [1..10])))
00:18:09 <lambdabot>  error:
00:18:09 <lambdabot>      Ambiguous occurrence ‘<|’
00:18:09 <lambdabot>      It could refer to either ‘Lens.<|’,
00:18:23 <rzhanka> > ringRotate 2 (20 Seq.<| (ringRotate 2 (Seq.fromList [1..10])))
00:18:27 <lambdabot>  fromList [4,5,6,7,8,9,10,1,2,20,3]
00:18:47 <Zemyla> Like matchPattern :: Value -> (patArgs -> r) -> r -> r, where the first argument is the value to match, the second is the success argument, and the third is the failure argument.
00:19:31 <rzhanka> ertes-w: cool, thanks, I'm pretty new at this, I haven't encountered that library before.
00:19:57 <Zemyla> So what if a complete set of pattern synonyms could be represented as completeMatchPattern :: Value -> (patArgs1 -> r) -> (patArgs2 -> r) -> ... -> r?
00:20:29 <ertes-w> rzhanka: you should study that library, it's called 'containers'…  it comes with some of the most common FP data structures you'll need in practice
00:20:40 <ertes-w> rzhanka: https://hackage.haskell.org/package/containers
00:21:19 <ertes-w> @undef
00:21:19 <lambdabot> Undefined.
00:32:54 <rzhanka> ertes-w: thanks, figuring out what's important unfortunately seems like one of the challenges of learning Haskell. Looking at the library hierarchy, I'm familiar with some parts of the containers package (mostly Map).
00:36:06 <ertes-w> rzhanka: well, one of haskell's main strengths is easy refactoring, so if you ever find that you've used a bad library, chances are you can easily replace it =)
00:43:05 <rzhanka> It says Sequence is implemented with trees. Given that lists are so central in FP, I still find it puzzling that there is no obvious structure with the benefits of a regular linked list. Though maybe the problem is I only know enough to end up with lists I need to rotate, and not enough to end up with something else :)
00:45:00 <Rembane> rzhanka: You can implement it yourself using two lists too.
00:47:21 <rzhanka> Rembane: hm, I guess I'm not sure how you'd do that
01:08:41 <Rembane> rzhanka: This is the type: ([a], [a])
01:09:36 <Rembane> rzhanka: You say that the first elements of one of those lists is the first element of the sequence/deque which gives you amortized O(1) read and write to the ends of the data structure.
01:11:48 <rzhanka> Rembane: but how would you traverse it circularly?
01:20:35 <Rembane> rzhanka: By mapping over the first list, then the second.
01:24:35 <mpickering> Is there a "Lens s a -> Lens [s] [a]" combinator in lens?
01:38:02 <rzhanka> Rembane: I think we are talking about slightly different things. The property I'm looking for is basically is basically an O(1) inversion of the cycle function: reverting an infinite list to a finite one. This is basic to a linked list, but has no obvious analog in Haskell. (take n . drop m . cycle) rotates a list, but is not very efficient.
01:38:55 <Rembane> rzhanka: Oh. Indeed. There should be a paper about this which someone mentioned last time the channel spoke about this.
01:41:17 <merijn> rzhanka: I dunno, "take n . drop m . cycle" looks reasonably efficient to me
01:41:35 <phadej> mpickering: are you looking for `partsOf` or something else
01:42:21 <mpickering> I don't think partsOf is right as it turns a traversal into a lens
01:42:30 <phadej> mpickering: I always forget things around "Lens s a -> Lens [s] [a]", what you need it for?
01:42:36 <merijn> rzhanka: Efficient enough that if it's not good enough you probably won't find lists good enough at all?
01:43:27 <phadej> mpickering: there is `mapped` and `folded` for setting and getting, but one cannot have both at once (lawfully) for non-Representable container
01:43:30 <phadej> IIRC
01:43:35 <phadej> I might be very wrong about this
01:45:01 <mpickering> So I want the get :: [s] -> ([a], [c]) to be "unzip . map (get l)"
01:45:12 <rzhanka> merijn: true enough, the solution suggested earlier was to use Sequences
01:45:20 <mpickering> and set :: ([a], [c]) -> zipWith set
01:45:32 <mpickering> *set :: ([a], [c]) -> [s]"
01:45:52 <mpickering> and I maintain the invariant that the length of the list remains the same
01:47:02 <merijn> rzhanka: What exactly are you doing that you want this for?
01:53:55 <ij> Are there any musical haskell libraries that would define pitch classes for me and let me check for enharmonicity of chords?
01:55:17 <ij> I pretty much want to play and compute with notes and symbols, I don't actually intend to make music with it.
01:55:35 <rzhanka> merijn: at the moment, I'm just solving a puzzle, but I became curious as I realized that for all the FP use of lists, some of the basic properties of regular linked lists don't seem to carry over. I looked at the implementation of cycle was wondering how you could undo it.
01:55:55 <merijn> rzhanka: You can't, tbh
01:56:11 <merijn> Not without some extra information
01:56:22 <ertes-w> rzhanka: lists are great, as long as you never allocate them
01:56:42 <merijn> ertes-w: Pfft, I got plenty of RAM :p
01:56:52 <ertes-w> rzhanka: as soon as you do that, all hell breaks loose and performance goes to shit
01:57:13 <ertes-w> merijn: i hope you have massive caches, too =)
01:58:31 <ertes-w> ij: if there is something like that, it's probably used by packages like haskore and Euterpea
01:58:48 <ij> I just found mezzo on hackage. https://github.com/DimaSamoz/mezzo#the-classical-rule-set
01:59:00 <ij> the anchor isn't there on purpose
02:06:10 <rzhanka> merijn: I have no idea Haskell would implement xs' = xs ++ xs' under the hood, but, yes, I'm not aware of any conceptual support in the language for literally undoing that operation, rather than fishing out what you need with take
02:06:30 <rzhanka> merijn: *how Haskell would implement
02:07:01 <merijn> rzhanka: Oh, that's actually pretty obvious
02:07:16 <Rembane> rzhanka: https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#%2B%2B
02:08:17 <merijn> rzhanka: If you think of Haskells "x : xs" as "struct list_t { void * x; list_t xs; };" in C, then we're just doing "list_t xs = { ?, &xs };"
02:08:48 <ij> ertes-w, Yeah, haskore also might be applicable.
02:09:02 <merijn> rzhanka: Or in this case, we just create a copy of xs where we replace the empty tail node with a node that points back to the start of this new list
02:09:52 <merijn> rzhanka: i.e. "let ones = 1 : ones" would be similar to having "struct list_t { int head; list_t *tail; }; list_t ones = { 1, &ones };"
02:13:50 <rzhanka> merijn: that's pretty much what I would assume, but I didn't know if that was acutally the case. However, if it *is* doing that just more or less like I would expect in C, then the idea that the language could conceptually support undoing it doesn't seem obviously unreasonable, but I certainly don't know enough theory to know whether there are good reasons not to.
02:16:27 <merijn> rzhanka: Well, except that values are immutable in Haskell
02:16:41 <merijn> rzhanka: So you can't "cut" the list in place to undo it
02:16:54 <merijn> rzhanka: You'd have to cut while copying and how would you know your copy was done?
02:18:14 <ertes-w> rzhanka: it's better not to think of lists as in-memory data structures…  more generally don't think of haskell values as regions of memory
02:18:44 <merijn> ertes-w: but...but...Vector!
02:18:48 <ixxie> what do you call the bracket notation for defining a function like comp2 :: (a -> b) -> (b -> b -> c) -> (a -> a -> c)           comp2 f g = (\x y -> g (f x) (f y))
02:18:54 <ertes-w> … with some exceptions =)
02:19:10 <ixxie> I am refer to the (\  .... ) construct
02:19:19 <merijn> ixxie: That's not a construct, though
02:19:34 <merijn> ixxie: it's "\.. -> ..." that happens to be surrounded with parentheses
02:19:48 <merijn> "\a b -> ..." is just lambda syntax
02:20:01 <ixxie> ah!
02:20:03 <ixxie> right :)
02:20:07 <ixxie> cheers
02:20:28 <merijn> Also, that function just looks like on
02:20:31 <merijn> :t Data.Function.on
02:20:33 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
02:20:48 <merijn> :t comparing `on` snd
02:20:50 <lambdabot> error:
02:20:50 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ b -> ()
02:20:50 <lambdabot>       Expected type: b -> b -> b -> Ordering
02:21:10 <merijn> :t compare `on` snd
02:21:12 <lambdabot> Ord a1 => (a2, a1) -> (a2, a1) -> Ordering
02:21:19 <ertes-w> rzhanka: think of haskell as symbolic manipulation, much like in algebra…  the state machine conception will only make you write bad code
02:21:21 <merijn> I forgot comparing is already the "on" version
02:21:32 <merijn> :t comparing
02:21:34 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
02:21:51 <ertes-w> rzhanka: there are times when the state machine conception is appropriate, but you will know when it is
02:22:36 <ixxie> merijn: I just found that in https://wiki.haskell.org/Partial_application
02:22:40 <ixxie> merijn: I am not building it
02:25:01 <insanitea> :t (compare `on`)
02:25:02 <lambdabot> Ord a1 => (a2 -> a1) -> a2 -> a2 -> Ordering
02:25:55 <merijn> insanitea: Which in turn is just:
02:25:57 <merijn> :t comparing
02:25:59 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
02:34:09 <insanitea> indeed
02:50:57 <Franciman> hi
02:51:03 <Franciman> does vty support truecolor?
02:51:15 <merijn> Doubt it
02:57:03 <rzhanka> ertes-w: yes, in general I don't think of Haskell structures in terms of memory, my question here was conceptual: linked lists have a set of properties that can be useful, what's the best way to get those properties in Haskell (or why/how do I it differently)? I'm glad you mentioned Sequences, they seem to have a nice set of properties, and I can stop forcing Maps to do things they might find undignified.
02:57:47 <ertes-w> rzhanka: what are those properties?
02:57:57 <Franciman> got it, thanks merijn
03:00:28 <merijn> I'm rather confused how the hell the Pool setup of persistent is supposed to be used...
03:00:47 <merijn> Whenever I try running multiple connections I just get weird errors and issues :\
03:02:26 <ixxie> does f g x do  f(g(x))?
03:02:32 <Franciman> no
03:02:38 <Franciman> ah no sorry
03:02:48 <Franciman> I misread
03:02:56 <merijn> "f g x" does "(f g) x"
03:03:01 <Franciman> yes
03:13:26 <ixxie> I can't figure out http://termbin.com/p25n
03:13:36 <ixxie> trying to learn how to make optional parameters
03:13:43 <rzhanka> ertes-w: of linked lists? the ones I was thinking about were the ones I mentioned: efficient insertion into a circular list and conversion to and from a circular list
03:15:10 <rzhanka> ertes-w: I expect merijn is correct, that there may be no way to recover this behavior in a context of purely immutable values.
03:15:49 <rzhanka> (at least not without extra machinery like the ST monad)
03:16:08 <ixxie> I get: http://termbin.com/pk92
03:43:29 <ertes-w> rzhanka: keep in mind that haskell values have no concept of identity
03:43:46 <ertes-w> rzhanka: for example there is no way to distinguish between (cycle [1,2]) and (cycle [1,2,1,2])
03:45:36 <nullie> And no way to tell that they're identical
03:45:38 <ertes-w> rzhanka: (that's a lie; there are hacks, but they belong to the unsafe squad alongside unsafePerformIO and unsafeCoerce)
03:45:45 <Axman6> rzhanka: those sound like properties of mutable linked lists, not all linked lists
03:46:10 <ertes-w> rzhanka: that's why you really need to let go of that "linked list" conception…  just say "list"
03:46:29 <ertes-w> or perhaps "cons list"
03:46:40 <Axman6> if cycle [1,2] == cycle [1,2,1,2] reutnrs, it will return True
03:46:48 <Axman6> returns*
03:48:32 <ertes-w> rzhanka: especially don't compare cons lists to something like C++ linked lists…  they have much less in common than you might think
03:49:00 <[exa]> In Parsec, what's the best way to recognize keyword-like stuff from normal identifiers? Say I have a rule that says line = special <|> normal; special = keyword >> many identifier ; normal = many1 identifier
03:49:30 <[exa]> problem: when a keyword is e.g. 'class' and I try to parse a "normal" line that starts with 'c', it fails
03:49:36 <Axman6> rzhanka: you might want to look at structures beyond lunked lists, zippers are often used to give the sort of properties you mentioned. the zipper for [a] looks like ([a],a,[a]), ie, a focus element, and the elements before and after it, so you can move forwards and backwards easily
03:50:06 <[exa]> (I've attempted to stuff 'try' everywhere but it doesn't seem very systematical)
03:51:09 <ertes-w> [exa]: try keyword *> many identifier <|> many1 identifier
03:51:15 <Axman6> [exa]: what about using (keyword <|> identifier) >> many identifier?
03:52:55 <ertes-w> rzhanka: there are cases when, if you were to take a debugger and look into the heap memory, you would find that cons lists look a lot like linked lists, but that's misleading…  consider that an implementation detail…  in other cases you might find that the list doesn't seem to exist at run-time at all
03:52:56 <Axman6> [exa]: or (id <$ keyword <|> (:) <$> identifier) <*> many identifier?
03:52:57 <[exa]> Axman6: how's that functionally different from separated definition?
03:53:24 <ertes-w> [exa]: you should 'try' the keyword, but nothing else
03:53:32 <Axman6> hmm, actually maybe you do need try also
03:53:37 <Axman6> yeah
03:53:54 <ertes-w> wrong:  try (keyword *> _)
03:53:59 <ertes-w> right:  try keyword *> _
03:54:07 <[exa]> so the difference is in only trying the keyword part
03:54:12 <[exa]> hm lemme check
03:54:45 <Axman6> the parsec instance for Alternative considers a parser to have  not failed if it consumes any input, IIRC
03:55:15 <ertes-w> [exa]: background: once you're certain about a branch, you should stop backtracking
04:00:13 <[exa]> ertes-w: it now looks like this http://lpaste.net/516905601905721344 (I hope I didn't omit anything. 'definition' starts with identifier, which can match keywords also)
04:00:20 <[exa]> (without the 'try')
04:05:38 <rzhanka> ertes-w: the properties I was looking for were the properties of (mutable, I guess) linked lists. I was trying to be careful not to assume that Haskell lists had the same properties. Indeed, the fact that I couldn't imagine how to give them those properties is what led to my question, to which I assumed one likely answer to be "you don't, you do x instead", which seems to be the case :)
04:07:27 <rzhanka> Axman6: the first person to answer me mentioned zippers, but I didn't know that was anything different from a zip function. So, another thing I'll have to take a look at.
04:07:44 <[exa]> ertes-w: oh nevermind, it works with your approach with try (the rest of the class definition was causing the failure)
04:08:17 <rzhanka> Pretty tired over here, going to call it a night. Thanks everyone!
04:09:38 <mpickering> Anyone know why stack --nix uses a nix ghc rather than it's own managed version? but then uses it's own managed packages rather than nix managed packages?
04:15:23 <dexterfoo> is hackage down?
04:15:36 <ph88> how come hoogle finds nothing when i search for printCSV and hayoo finds two items?
04:16:01 <merijn> ph88: Hoogle doesn't index all of Hackage
04:16:40 <ph88> do you know why it doesn't?
04:17:16 <merijn> I think it requires building everything, there's work on a new version of Hoogle for a while which might get better coverage?
04:17:20 <Franciman> what do you think of this SLURP thing?
04:18:16 <merijn> ph88: The alpha Hoogle finds it, but alpha Hoogle doesn't support type searching
04:18:21 <merijn> ph88: http://hoogle.haskell.org/?hoogle=printCSV
04:21:22 <ph88> ah thanks merijn
04:48:07 <simon> ph88, I've liked it that way; if I want to find something in the standard library, I use Hoogle and don't get all the results from various libraries I won't depend on. if I want to find something anywhere, I use Hayoo.
04:48:23 <typetetris> Franciman: Nothing. Lots of drama. Ignore it and keep doing your stuff.
04:48:57 <Franciman> typetetris, I'm really afraid that the community is going to crack
04:49:00 <ph88> simon, ye that's fine if that works for you. I would prefer 1 website where i could set a few options like google search tools
04:49:01 <Franciman> break
04:49:24 <merijn> ph88: You can always install Hoogle locally and setup cabal to automatically index new packages you install
04:50:46 <typetetris> Franciman: There is nothing to be afraid of. The worst that will happen is, that you need to update your stack again, to keep it working.
04:51:50 <Franciman> I don't really like FPComplete moves
04:51:58 <Franciman> they'll take over haskell
04:52:04 <Franciman> hope it won't
04:52:14 <Franciman> typetetris, anyhow thanks for your explaination
04:59:49 <quchen> ertes: Hooray, I found a new fixed point combinator! It’s 8 megs on my disk.
04:59:54 <quchen> I should stop converting lambdas to SKI and back.
05:05:03 <ph88> how can i get a String with aeson instead of a ByteString ?
05:05:30 <int-e> :t BS.unpack
05:05:31 <lambdabot> BSC.ByteString -> [Word8]
05:05:40 <int-e> hmm, wrong module
05:07:20 <int-e> :t BSLC.unpack -- import qualified Data.ByteString.Lazy.Char8 as BSLC
05:07:22 <lambdabot> BSLC.ByteString -> [Char]
05:19:32 <merijn> >.<
05:19:55 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
05:20:09 <int-e> true
05:20:14 <merijn> I'm just gonna script irssi to auto link that whenever it sees Char8
05:20:49 <merijn> ph88: Short answer: You can't, unless you know the encoding of the originating JSON
05:21:07 <dminuoso> merijn: Oh wow. I wanted to ask that exact question maybe 30 minutes ago. Now neither did I have to waste my time formulating it, but still got the answer. Thanks!
05:21:12 <dminuoso> (Regarding ByteString.Char8)
05:21:44 <merijn> dminuoso: For the proper way you want Data.Text.Encoding
05:21:53 <int-e> "the"
05:22:11 <merijn> Usually you want decodeUtf8'
05:22:54 <ph88> merijn, i want toJSON
05:23:44 <merijn> ph88: Data.Aeson.Text
05:23:58 <merijn> encodeToLazyText :: ToJSON a => a -> Text
05:24:24 <ph88> something :: ToJSON a => a -> String
05:24:34 <merijn> :t T.unpack
05:24:37 <lambdabot> error:
05:24:38 <lambdabot>     Not in scope: ‘T.unpack’
05:24:38 <lambdabot>     Perhaps you meant ‘BS.unpack’ (imported from Data.ByteString)
05:24:40 <ph88> ok
05:24:41 <merijn> huh
05:24:48 <merijn> :t Data.Text.Lazy.unpack
05:24:50 <lambdabot> Data.Text.Internal.Lazy.Text -> String
05:28:25 <ph88> thx merijn
05:28:30 <ph88> interesting github page too
05:35:51 <mark721> hi guys
05:36:46 <Axman6> 'lo
05:37:25 <centril> Hmm, what was the rationale for Nothing < Just _ ?
05:37:46 <Axman6> because nothing is less than anything
05:38:11 <ph88> how can i make these instances available https://github.com/simonmichael/hledger/blob/master/hledger-api/hledger-api.hs#L163-L200 in https://github.com/simonmichael/hledger/blob/master/hledger/Hledger/Cli/Commands/Print.hs  ??
05:38:17 <centril> I believe it is intuitive, but was there something mathematical like a law here
05:38:31 <ph88> i'm trying to do some work on that library, but i never worked with a situation before where you have different sub-cabal projects
05:38:49 <Axman6> not that I'm aware of, generally things are ordered by the order their constructors are defined
05:38:53 <mark721> I have two functions but they are different yet they have the same type. Could someone explain why please :) https://pastebin.com/wYT00YhH
05:39:21 <centril> Axman6 that is what I told a friend, but they wanted a more mathy reason
05:39:26 <Axman6> mark721: how could they have any other type?
05:39:56 <mark721> Axman6: I mean i would've expected maybe an extra t -> t
05:39:59 <centril> The constructors could have been ordered differently
05:40:04 <Axman6> centril: you could mutter something about |Maybe a| = 1 + a, but there's no good reason why |Maybe a| shouldn't be a + 1 =)
05:40:07 <ph88> mark721, just as   k x = x + 1 + 2   has the same type as  g x = x + 1   but now you pass in "+ 1" as a function f that you apply more times
05:40:24 <Axman6> mark721: (t -> t) is the type of the function which is being passed in
05:40:27 <ph88> k x = x + 1 + 1   i mean
05:40:39 <Axman6> "Given a function from t's to t's, and a t, return a t"
05:40:57 <mark721> Axman6: ph88: eli5 pls :)
05:41:03 <ph88> eli5 ?
05:41:06 <Axman6> I just did :(
05:41:11 <centril> Axman6 damn, I would have loved to reply with a lemma or something =p
05:41:12 <mark721> explain like im five
05:41:40 <Axman6> mark721: do you understnad the type of map?
05:41:41 <Axman6> :t map
05:41:44 <lambdabot> (a -> b) -> [a] -> [b]
05:41:54 <mark721> Axman6: I havent learned about maps yet
05:42:04 <ph88> mark721, let f x = x + 1    then   f (f b) = b + 1 + 1    and   f b = b + 1
05:42:11 <Axman6> what haskell have you learned yet?
05:43:03 <ph88> mark721, suppose b is 5   then   5 + 1 + 1 = 7   and   5 + 1 = 6    but the output type is both Int, because 7 is Int and 6 is Int ... doesn't matter how many operations the function has internally
05:43:03 <Axman6> mark721: firstly, do you understand what twotimes and threetimes are doing? can you explain that to us?
05:44:37 <mark721> Axman6: twotimes is applying the same function to x  and then apply the function to the output
05:44:54 <mark721> Axman6: whereas threetimes does exactly that but applies the functioN AGAIN to the output.
05:45:08 <Axman6> mark721: close, but we also need to talk about the arguments to twotimes and threetimes
05:45:11 <ph88> mark721, in type signature "(t -> t) -> t -> t" the first part is dependent on the arguments which are the same for your functions "(t -> t) -> t", the last part is dependent on the result type of your function "-> t"  which i just explained stays the same
05:45:25 <michalrus> Can I have a sort of anonymous existential type, without defining its datatype?
05:45:35 * michalrus scratching head
05:45:42 <Axman6> michalrus: like Void?
05:45:51 <Axman6> @src Void
05:45:51 <lambdabot> Source not found. My mind is going. I can feel it.
05:45:55 <Axman6> :(
05:46:05 <michalrus> I need to read about it. :} Possibly.
05:46:07 <Axman6> data Void -- hat;s it, needs EmptyDataDecls
05:46:09 <mark721> ph88: right ...
05:46:14 <Axman6> that's*
05:46:24 <MarcelineVQ> Axman6: it doesn't need that these days
05:46:58 <Axman6> mark721: in twotimes f x = ... what type do the arguments to twotimes have? f :: ?, x :: ?
05:47:08 <Axman6> types*
05:47:15 <Axman6> MarcelineVQ: awesome
05:47:52 <MarcelineVQ> michalrus: what is your use for the thing you describe?
05:47:55 <mark721> f:: t->t, x:: t
05:48:10 <michalrus> Axman6: ah, then that’s not it. :c
05:48:25 <Axman6> great, so f is a function that can take some type t and will return something of the sime type
05:48:29 <Axman6> same*
05:48:35 * Axman6 needs to go to bed -_-
05:49:00 <MarcelineVQ> michalrus: are you wanting Proxy perhaps, and if so, are you aware of -XTypeApplications
05:49:12 <Axman6> michalrus: so, if we have f as show, which has the type String -> String, what type must x have?
05:49:31 <michalrus> MarcelineVQ: if I wanted a one-off function to take, say, a list of function that return forall a. Maybe a, but for that a to be different between consecutive elements…
05:49:53 <Axman6> [forall a. Maybe a]?
05:50:02 <michalrus> So really a data Arg b = forall a. Arg (b -> Maybe a)
05:50:04 <Axman6> does that work? I can't even remember
05:50:05 <michalrus> Hmmmmmmmmmm, can I do that? :o
05:50:10 <michalrus> That would be it.
05:50:51 <Axman6> not sure how that would be useful though, isn't forall a. Maybe a essentially Bool?
05:51:05 <Axman6> since you know nothing about a you can't do anything with it
05:51:13 <michalrus>     • Illegal polymorphic type: forall a. Maybe a
05:51:13 <michalrus>       GHC doesn't yet support impredicative polymorphism
05:51:13 <michalrus>     • In the type signature: xs :: [forall a. Maybe a]
05:51:15 <michalrus> You can’t. :P
05:51:24 <michalrus> Axman6: yes, yes.
05:51:24 <Axman6> booo
05:51:56 <Axman6> so, you've invented a fancy implementation of newtype Predicate a = Predicate (a -> Bool) :P
05:52:23 <Axman6> (the classic example of a Contravariant functor!)
05:52:59 <michalrus> ^.^
05:53:46 <Axman6> so what do you need it for?
05:54:07 <MarcelineVQ> there is -XImpredicativeTypes but idk how useful it is
05:54:13 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#impredicative-polymorphism
05:54:38 <phadej> if you feel you need -XImpredicativeTypes, but you don't know you need them: you don't need them
05:54:57 <phadej> know *for sure*
05:55:36 <Axman6> surely just blindly turning on whatever extensions GHC tells you you need shoudl be fine right?
05:55:48 <phadej> :)
05:56:11 * Axman6 will admit to having done that several times to get code to compile
05:56:13 <michalrus> Okie. ^.^
05:57:20 <phadej> wow, from 200kLOC of acme-kmett, there's one module with ImpredicativeTypes :)
05:57:24 <phadej> (in ersatz)
05:57:57 <Axman6> I just assume that about a third of the GHC extensions exist to keep Ed happy
05:58:11 <__Myst__> How does the Monad instance for Either work?
05:58:33 <electrocat> __Myst__: do you know how maybe works?
05:58:34 <phadej> __Myst__: like Maybe's
05:58:36 <phadej> :)
05:58:53 <Axman6> :t (>>=) `asAppliedTo` (undefined :: Either String Bool)
05:58:55 <lambdabot> Either String Bool -> (Bool -> Either String b) -> Either String b
05:59:04 <phadej> Axman6: I might be true
05:59:27 <phadej> Axman6: He does give "real world" motivations for reasearch
05:59:37 <Axman6> indeed
06:00:01 <__Myst__> electrocat: yes
06:00:08 <__Myst__> phadej: except that Left is Nothing and Right is Just?
06:00:14 <electrocat> yes
06:00:15 <phadej> __Myst__: yes
06:00:39 <Axman6> We had a good conversation a few months ago about why Haskell is terrible at abstraction, and explained how awful and clunky type classes are because you can'r retroactively extend them. I'm waiting for the extension that's needed for that now
06:00:54 <MarcelineVQ> I've got that page open actually
06:01:11 <phadej> Axman6: somethin like "DefaultSuperClasses" ?
06:01:22 <quchen> Someone who calls Haskell terrible at abstraction should try to write Java for a day
06:01:25 <electrocat> Axman6: you want type class subtyping?
06:01:27 <phadej> Axman6: As far as I understand no-one has a sound plan for that
06:01:30 <Axman6> __Myst__: so Either's monad instance is the same a sMaybe's, but you can associate some information with the failure (i.e. Left) case
06:01:30 <quchen> Or, god forbid, Go
06:01:30 <MarcelineVQ> https://ff32.host.cs.st-andrews.ac.uk/papers/mscthesis.pdf
06:02:24 <Axman6> quchen: Ed makes a pretty compelling argument for it. The conversaion usually includes something along the lines of "Haskell's terrible at abstraction, but it's the best we've got" (paraphrasing)
06:02:38 <Axman6> quchen: also, y u no like interface {}?
06:04:53 <ertes-w> quchen: haskell can be better than anything else and still be terrible
06:05:18 <quchen> Sounds like the metric needs to be renormalized then.
06:05:21 <AndreasK> Well there is no exact definition for terrible so thats kind of a meaningless statement
06:05:58 <ertes-w> AndreasK: "i want this abstraction, and i can't express it in haskell"
06:06:06 <ertes-w> → terrible
06:06:25 <Axman6> can we add sensible before abstraction?
06:06:30 <Axman6> because... interface {}
06:06:33 <dminuoso> Mmm. If due to my usage of ByteString I'm being forced to use some GHC.Int.Int64, do I really then have to import GHC.Int (Int64) just in order to explicitly annotate my functions?
06:06:38 <AndreasK> I want my car to fly but it cant -> it's terrible
06:06:39 <dminuoso> Im a bit annoyed. :(
06:06:48 <ertes-w> dminuoso: Data.Int
06:06:48 <Axman6> dminuoso: Data.Int
06:06:55 <Axman6> jinx
06:07:34 <dminuoso> ertes-w, Axman6: Ah! That feels better, thanks :)
06:10:21 <dminuoso> How comes Im seeing GHC.Int.Int64 anyway instead of Data.Int ?
06:10:40 <Axman6> what're you doing, and do you have GHC.Int imported?
06:10:50 <dminuoso> Axman6: https://gist.github.com/dminuoso/b4a09521210912575efa2f11e2de58e7
06:10:58 <dminuoso> Was what I originally had.
06:11:42 <Axman6> possibly because ByteString imports GHC.Int and not Data.Int? but Data.Int just reexports the types IIRC
06:12:03 <Axman6> if those bytestrings are lazy, you'll need to be using Int64 and not Int though
06:12:38 <dminuoso> Axman6: Right. Just gave you the code that triggered my thought process initially, it was fixed before I mentioned anything. :)
06:18:09 <phadej> because the type /is/ defined in GHC.Int module
06:18:37 <phadej> same way if you use lazy bytestring instead of strict you see 'Data.ByteString.Lazy.Internal.ByteString` or something like that
06:23:37 <fraktor> I'm trying to work my way through haskell, and I've gotten to the *dreaded monad.* I'm a little confused about do notation: does it only work for IO, or can you use it with other monads?
06:23:57 <Athas> fraktor: all monads.
06:24:17 <fraktor> This is going to be a stupid question: how does it know what value to get out?
06:24:21 <Athas> Do-notation desugars to applications of the >>= and >> operators and the 'return' function, which are part of the Monad typeclass.
06:24:46 <Athas> I'm not sure exactly what you mean.  It uses ordinary type inference to determine exactly which monad you are using.
06:25:24 <fraktor> Hmm... when you have something like the maybe type, you might have Nothing or Just a. How does it know what to do when the value you
06:25:31 <fraktor> are trying to get something out of is Nothing?
06:25:41 <ertes-w> fraktor: Nothing >>= f = Nothing
06:25:57 <ertes-w> > do x <- Nothing; pure (x + x)
06:26:00 <lambdabot>  Nothing
06:26:10 <fraktor> So that's part of the definition of >>= for Maybe?
06:26:16 <ertes-w> yes
06:26:37 <ertes-w> > Nothing >>= \x -> pure (x + x)
06:26:41 <lambdabot>  Nothing
06:26:41 <ertes-w> same thing
06:27:00 <fraktor> Oh! So that's why the return value of anything that uses do notation must be wrapped in the same monad as the monads you're getting values from.
06:27:51 <dminuoso> fraktor: Right.
06:28:01 <dminuoso> fraktor: https://gist.github.com/dminuoso/6a5e2ecd5e019531ec6e4694c17e38a1
06:28:09 <dminuoso> :t (>>=)
06:28:10 <dminuoso> :t (>>)
06:28:10 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:28:13 <lambdabot> Monad m => m a -> m b -> m b
06:28:47 <dminuoso> You have one m, produce another m, and that is again some m. The monad remains the same.
06:29:02 <fraktor> <insert mind expanding meme here> I think I understand now.
06:30:01 <dminuoso> fraktor: I personally found it helpful to write monadic code with explicit >>= and >> like in my gist for a while. It shows that you are simply just constructing monads from monads and kleisli arrows: a -> m b type of functions
06:32:48 <Myrl-saki> Trying to formalize something related to sorted lists. How do I make it more readable? https://imgur.com/a/Bvpze
06:34:13 <dminuoso> fraktor: incidentally it also shows why you can do something like "foo <- bar" and then use foo later, because all the rest of the do notation it's scoped inside a big function (\foo -> ...)
06:34:33 <Myrl-saki> This is basically on the same branch as `last . takeWhile`
06:34:56 <Myrl-saki> Actually, takeWhile.
06:49:38 <lts> Haskell newbie here. Is there a way to avoid making two recursive calls in this function - http://lpaste.net/361984 ; It'd be a bad idea to use assignments afaik, wondering if there might be a good approach.
06:50:11 <merijn> lts: You can add a where clause?
06:50:53 <lts> oh right ; thanks merijn! still a lot to learn
06:51:10 <chocopuff> how do I get better at writing loops as recursion / in a functional style?
06:51:21 <chocopuff> any resources or guides on this specifically?
06:59:06 <fraktor> Is there any difference between let... in... and ... where ... ?
06:59:11 <fraktor> Or is it just personal style?
06:59:21 <merijn> fraktor: They can't be used in the same places
06:59:30 <merijn> fraktor: where attaches to definition and can be shared across guards
06:59:35 <merijn> let/in is an expression
07:00:07 <fraktor> Hm. I'm gonna have to reread that part.
07:00:12 <fraktor> Thank you.
07:05:01 <dminuoso> fraktor: In the cases where you can use both I think it mostly comes down to preference. `where` lets you immediately express what your "foo" means, whereas `let` is kind of similar to uneffectful do-notation.
07:06:00 <dminuoso> fraktor: When I learned Monad transformers using `let` to implement the base monads first was incredibly helpful - there was some striking parallels to their respective transformers.
07:09:31 <sayola> the order of stacking RWST and RandT doesn't matter, right?
07:11:13 <byorgey> sayola: right, because RandT is essentially a specialized StateT, and State commutes with Reader, Writer, and State
07:12:02 <sayola> byorgey: thank you!
07:13:24 <sayola> i explained it myself by saying, non of them change/control the flow. but wanted to get sure. ;)
07:23:36 <mniip> so I've been thinking
07:23:55 <mniip> I remember reading somewhere on the GHC trac
07:24:13 <mniip> an idea that defaulting could be delegated to user code
07:24:52 <mniip> via some wired-in typeclasses
07:25:43 <mniip> that would be quite cool but I wonder what exactly would the typeclass look like
07:28:33 <mniip> ideally you'd desugar a defaulting of type 'forall a. c => F a' into 'F (Default (Rep c))'
07:28:48 <mniip> for some representation Rep that lets you discover how 'a' appears in 'c'
07:29:12 <mniip> but then since it would have to be an open type family, how would prelude ever implement the report defaulting rules
07:41:00 <robstr> Hey, I'm reading though the haskell programming from first principles and on page 620 there is an example I cannot follow.
07:42:39 <robstr> The point is (fmap . fmap) replaceWithP and (fmap . fmap . fmap) replaceWithP, I don't get how to end up with [Just "ppp", Nothing, Just "pppppp"]
07:42:52 <robstr> can someone help here ?
07:43:11 <hyperisco> :t replaceWithP
07:43:14 <lambdabot> error: Variable not in scope: replaceWithP
07:43:21 <hyperisco> I don't know what that is
07:43:28 <dxtr> Hmm, is there a function to convert an Int to Word16?
07:43:38 <hyperisco> dxtr, fromIntegral probably
07:43:57 <dxtr> Oh that worked this time :p
07:44:07 <merijn> hyperisco: It's defined in the book
07:44:07 <hyperisco> :t fromIntegral (5 :: Int) :: Word16
07:44:09 <lambdabot> Word16
07:44:18 <merijn> hyperisco: iirc replaceWithP is just "const 'p'"
07:44:20 <robstr> replaceWithP = const 'p'  and lms = [Just "ave", nothing, "=just "whoo"]
07:44:38 <robstr> merijn: thank you
07:44:49 <hyperisco> robstr, cool, so what part is confusing you? i.e. up to what point do you understand?
07:45:32 <robstr> with (fmap . fmap) I thought it is clear, I mean first fmap entering the functor of list, second of maybe
07:45:39 <robstr> is this correct ?
07:45:58 <mnoonan> remember that strings are a kind of list too
07:46:04 <hyperisco> I think so, though your wording is a bit strange
07:47:07 <robstr> I dont get how (fmap . fmap . fmap) can end with [Just "ppp", Nothing, Just "pppppp" ] starting from [Just "p", Nothing, Just "p"]
07:47:21 <hyperisco> so, does the third fmap confuse you?
07:47:25 <robstr> right
07:47:35 <merijn> robstr: Note that Strings are just [Char]
07:47:36 <hyperisco> > fmap (const 'p') "hello sailor!"
07:47:39 <hyperisco> does that confuse you?
07:47:40 <lambdabot>  "ppppppppppppp"
07:47:48 <merijn> robstr: So "foo" == ['f','o','o']
07:47:54 <merijn> > "foo" == ['f','o','o']
07:47:58 <lambdabot>  True
07:49:38 <robstr>  fmap (const 'p') "hello sailor!" - I'm ok with this but why do I end up with "ppp", I expect just one "p"
07:50:41 <robstr> oh -.-
07:50:44 <robstr> my fault
07:50:46 <robstr> thank you
07:51:19 <robstr> Now i got it
07:52:05 <robstr> great to get some support here
07:52:19 <hyperisco> glad to help and have fun!
07:58:02 <merijn> Is there a library that lets me get the day of the week from a ZonedTime?
08:01:56 <glguy> merijn: The time package can do that
08:02:10 <merijn> glguy: Yeah, I just managed to find "Day -> DayOfWeek" but it was a bit hidden
08:02:32 <cocreature> the DayOfWeek time is also quite new iirc
08:02:40 <insanitea> :t dayOfWeek . utctDay . zonedTimeToUTC
08:02:42 <lambdabot> error:
08:02:42 <lambdabot>     Variable not in scope: dayOfWeek :: b0 -> c
08:02:42 <lambdabot> error:
08:02:50 <cocreature> I remember seeing it in the changelog
08:02:51 <insanitea> it is in time-1.9 :-/
08:03:12 <glguy> toWeekDate :: Day -> (Integer, Int, Int) has been around for a long time, however
08:03:41 <merijn> I can depend on bleeding-edge stuff
08:06:26 <ph88> how do i run these tests?  https://github.com/simonmichael/hledger/tree/master/tests
08:07:59 <merijn> "cabal new-test"?
08:11:07 <ph88> let me try after finish compiling
08:11:31 <merijn> ph88: Better of interrupting if your not building with new-build, because else it'll compile again
08:11:51 <ph88> cabal: unrecognised command: new-test (try --help)
08:12:00 <merijn> ph88: Which cabal version do you have?
08:12:17 <ph88> cabal-install version 1.22.9.0
08:12:22 <merijn> ...
08:12:22 <ph88> using version 1.22.8.0 of the Cabal library
08:12:24 <merijn> That's ancient
08:12:27 <ph88> :(
08:12:39 <merijn> ph88: Might wanna install cabal-install 2.x first
08:12:40 <ph88> i never use cabal directly
08:13:21 <ph88> how can i install cabal with stack ?
08:13:40 <glguy> https://www.haskell.org/cabal/download.html will be faster
08:13:41 <ph88> oh cabal-install
08:13:43 <ph88> got it
08:14:37 <kuribas> is there a library to serialise an ADT to xml with generics?
08:14:38 <mnoonan> it looks like there is a "make test" target
08:15:20 <kuribas> that's not ten years old?
08:15:35 <kuribas> or deprecated?
08:17:57 <ph88> takes a long time to compile cabal ^_____^
08:18:08 <glguy> That's you shouldn't have
08:18:25 <ph88> i dunno, seeing something compiling is always satisfying :D
08:19:03 <kuribas>  hexpat-pickle-generic is deprecated.  Deprecated in favor of what?
08:19:52 <glguy> Probably in favor of the author didn't want to maintain it any more
08:23:20 <mnoonan> kuribas: did you see https://hackage.haskell.org/package/text-xml-generic-0.1.1 ?
08:23:26 <kuribas> this seems recent: https://hackage.haskell.org/package/generic-xmlpickler
08:23:46 <kuribas> mnoonan: that's 8 years old
08:24:37 <mnoonan> kuribas: ok, but what functionality is it missing?
08:25:26 <kuribas> documentation to start
08:25:36 <mnoonan> I mean, it uses String etc, but just being 10 years old doesn't seem like a no-go in and of iteself
08:26:31 <kuribas> I doubt it will work, but I haven't tried it.
08:27:44 <kuribas> And a garantee that it will be updated when things change (such as ghc).
08:27:58 <kuribas> Which I doubt with a 8 years old package.
08:28:17 <c_wraith> has GHC.Generic ever changed in such a way as to break backwards compatibility?
08:28:51 <glguy> A couple things broke when it started using datakinds in the Rep instances
08:29:28 <glguy> but that only affected a subset of uses
08:39:45 <ph88> merijn, https://bpaste.net/show/ac5bf6af023f
08:40:33 <mnoonan> ph88: did you look at the makefile? it seems like they have their own thing going on..
08:40:47 <glguy> ph88: Did you read the message you pasted?
08:40:51 <ph88> ah ye that works
08:41:16 <mnoonan> ph88: oh, actually, check this out: http://hledger.org/contributing.html#tests
08:41:23 <ph88> not sure if new-test is the command or the target
08:41:33 <glguy> new-test is the command
08:41:44 <glguy> You have to tell it what to test, probably: cabal new-test hledger
08:42:06 <ph88> great 5 different ways to test .. i'll see which one works
08:42:14 <loginoob> I have to learn javascript in my job but i really despise the language. what can i do to motivate myself.
08:42:21 <ph88> learn purescript :D
08:42:48 <kuribas> mnoonan: anyway, the generic-xmlpickler looks nicer and well maintained
08:42:56 <ph88> nice one kuribas
08:43:09 <loginoob> ph88: but javascript is used in my company
08:43:26 <ph88> loginoob, sorry man don't know how to help there
08:43:34 <ph88> get in, do your stuff, get out i guess
08:43:36 <glguy> loginoob: This particular channel is for discussing Haskell programming
08:43:39 <loginoob> :(
08:43:46 <kuribas> loginoob: javascript isn't really difficult
08:44:00 <kuribas> loginoob: it will not be hard to learn it, it will be hard to use it.
08:44:21 <mnoonan> life is suffering, etc
08:44:48 <merijn> ph88: "cabal new-test all"
08:44:54 <loginoob> It has these weird quirks that seems very unintutive to me
08:45:08 <merijn> glguy: You can just say "all" and have it test every package in cabal.project
08:46:31 <glguy> the directory in question might not be covered by any test-suites
08:46:38 <glguy> The makefile that keeps getting mentioned has some other test driver, too
08:48:12 <glguy> The previously linked documentation seems like a good reference
09:15:59 <newsham> ?type liftM fork
09:16:01 <lambdabot> error:
09:16:01 <lambdabot>     • Variable not in scope: fork :: a1 -> r
09:16:01 <lambdabot>     • Perhaps you meant one of these:
09:16:20 <newsham> ?type fork
09:16:21 <lambdabot> error:
09:16:21 <lambdabot>     • Variable not in scope: fork
09:16:21 <lambdabot>     • Perhaps you meant one of these:
09:17:02 <mniip> % :t liftM forkIO
09:17:02 <yahb> mniip: Monad m => m (IO ()) -> m (IO ThreadId)
09:17:08 <mniip> looking for this?
09:17:18 <newsham> :type liftM forkIO
09:17:24 <newsham> ?type liftM forkIO
09:17:26 <lambdabot> error: Variable not in scope: forkIO :: a1 -> r
09:17:31 <newsham> hah
09:18:12 <newsham> mniip: thank you.. type of a forklift
09:18:35 <mniip> % :t liftIO forkIO
09:18:36 <yahb> mniip: ; <interactive>:1:8: error:; * Couldn't match expected type `IO a' with actual type `IO () -> IO ThreadId'; * Probable cause: `forkIO' is applied to too few arguments; In the first argument of `liftIO', namely `forkIO'; In the expression: liftIO forkIO
09:18:41 <mniip> % :t liftIO . forkIO
09:18:41 <yahb> mniip: MonadIO m => IO () -> m ThreadId
09:22:33 <ph88> what does this mean Parser (a -> a) in optparse-applicative ? execute an options immediately and forget about the rest?   https://github.com/psibi/tldr-hs/blob/master/app/Main.hs#L69
09:27:34 <jim12> hi all, in scotty, I want to read the host for the headers and pass it to the template for debugging, I can't manage to get it to work: http://lpaste.net/361987
09:28:07 <jim12> read the host *from the headers
09:31:08 <geekosaur> ph88, with no constraint on a it looks like (Parser id), that is, the parser does nothing with respect to parsed options (but shows an informational message. specifically the version)
09:32:02 <ph88> i've only seen  Parser x   where x is a data type  .. not sure what it means if it's a function
09:32:19 <ReinH> phadej: It's an option parser that returns a function.
09:32:35 <ReinH> er, ph88
09:38:21 <ph88> how do i model that when i have two --flags and the first one triggers something and the second one is ignored ?
09:42:25 <ReinH> ph88: Using infoOption?
09:43:11 <ReinH> Also, how do you model *what*?
09:45:20 <ph88> well i could put flags in the record https://github.com/psibi/tldr-hs/blob/master/app/Main.hs#L17-L19  with a Maybe
09:45:38 <ph88> but then after optparse-applicative did it's work i don't know which one came first
09:46:15 <ph88> --flag2 "foo"  --flag1 "bar"     { Just "bar", Just "foo" }
09:46:24 <ph88> (not real syntax)
09:47:06 <mnoonan> sounds like you need optparse-monadic :)
09:49:19 <ReinH> I'm not sure what you're asking
09:50:16 <ph88> i wanted the order of how the flags are given to determine which flag should be active
09:50:25 <ph88> in case just one of the two can be active at the same time
09:50:36 <mnoonan> ReinH: I think ph88 wants something like "myprog --dothis --dothat" to do "this", but "myprog --dothat --dothis" to do "that"
09:50:47 <ph88> ye
09:50:54 <ReinH> That seems like a bad thing to want.
09:50:59 <ph88> ok :(
09:51:06 <ReinH> What's the use case?
09:52:14 <hexagoxel> if you have --enable-my-flag and --disable-my-flag, i'd expect the _last_ one to matter the most.
09:52:29 <Tuplanolla> I'd expect an error message.
09:53:10 <nullie> Override may be useful, like alias have enable flags and you want to override then
09:53:23 <geekosaur> ^
09:53:25 <ReinH> --sudo-disable-my-flag
09:53:26 <hexagoxel> ^
09:53:40 <geekosaur> and this is common both in shell aliases and e.g. git config aliases
09:53:58 <geekosaur> or system/user config files overrideable by options
09:55:02 <ReinH> I don't get it. optparse-applicative already parses options in the order they appear
09:55:14 <ReinH> > No matter which parsers appear first in the sequence, options will still be parsed in whatever order they appear in the command line.
09:55:17 <lambdabot>  <hint>:1:38: error: parse error on input ‘in’
09:55:22 <ReinH> woops
10:17:12 <COstar> Hi
10:26:00 <ph88> hi COstar
10:37:04 <ph88> how do i negate doesFileExist in     listDirectory "." >>= \paths -> filterM (doesFileExist) paths    i tried "not" and "fmap not"  .. sorry for nooby question but i haven't worked with filterM before
10:37:32 <mud> filterM (not . doesFileExist)
10:37:45 <ph88> that was the first thing i tried
10:38:04 <geekosaur> you need to fmap it
10:38:23 <ph88> listDirectory "." >>= \paths -> filterM (fmap not doesFileExist) paths
10:38:37 <geekosaur> fmap not . doesFileExist
10:38:48 <mud> Oh, yes
10:39:57 <ph88> i don't get why i need the dot as well
10:40:00 <humanoyd> filterM ((fmap . fmap) not doesFileExist)
10:40:25 <mnoonan> >:(
10:40:28 <glguy> keep it coming: fmap fmap fmap not doesFileExist :: FilePath -> IO Bool
10:42:14 <glguy> ph88: You need: \filename -> fmap not (doesFileExist filename)
10:42:33 <glguy> which is the same as: fmap not . doesFileExist
10:42:41 <geekosaur> ph88, (fmap not doesFileExist) would treat doesFileExist as (FilePath -> Bool) and use the ((->) e) Functor, then throw a type error upon discovering that doesFileExists :: FilePath -> IO Bool
10:43:03 <geekosaur> rememebr what (.) does, and follow the types
10:43:13 <ph88> ah yes i can understand that one better
10:43:34 <ph88> listDirectory "." >>= \paths -> filterM (\f -> fmap not (doesFileExist f)) paths
10:52:45 <ph88> is there something like a dropEnd function? i want to remove ".md" from all [FilePath]
10:53:31 <glguy> Poke around in System.FilePath
10:53:50 <ph88> ok
10:53:54 <glguy> ?hackage filepath
10:53:54 <lambdabot> http://hackage.haskell.org/package/filepath
10:57:26 <fishythefish> ph88: you probably want map dropExtension
11:00:58 <ph88> ye got it :)
11:01:22 <ph88> does anyone know of a function that prettyPrints a list over multiple columns just like ls  does ?
11:11:07 <hyperisco> I wonder what a good interface is for accumulating *all* errors … a concept which works if you first collect a bunch of information before computing with it
11:11:36 <hyperisco> for example if you have to parse and validate several inputs/fields before computing with them
11:13:21 <ph88> bbl
11:14:07 <cocreature> hyperisco: Validation?
11:15:02 <hyperisco> possibly
11:15:09 <cocreature> https://hackage.haskell.org/package/either-5/docs/Data-Either-Validation.html#t:Validation
11:15:49 <jle`> https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Applicative-Lift.html
11:16:58 <hyperisco> yeah I know where it is, thanks
11:17:44 <hyperisco> jle`, elegant
11:18:38 <hyperisco> yeah Applicative makes sense. I recognised Monad would not work but didn't have the thought to accept Applicative
11:20:01 <toom> beginner question here, anyone has an example on how to extract fields from a Document in mongodb?
11:24:19 <cocreature> toom: I’ve never used mongodb so I can’t help you too much but https://hackage.haskell.org/package/mongoDB-2.3.0.1/docs/Database-MongoDB.html contains an example at the top, does that help?
11:24:21 <fiatjaf> toom: first step: get a library that interacts with mongodb
11:24:48 <lts> So I've taken up a FP course this semester and have come across a problem while doing my assignments - validating if the changes that I introduce don't break the functionality. I was hoping if I could get suggestions on a unit testing frameworks in haskell, so that I can specify various testcases with the input and expected output.
11:26:11 <toom> cocreature: unfortunately they don't show how to extract the fields, they just show how to query
11:26:28 <dogui> lts: QuickCheck. It's not unit testing, but even better : )
11:26:48 * lts checks out QuickCheck
11:26:53 <davean> lts: Theres a number of options depending on the level of complexity and completeness you want
11:27:20 <fiatjaf> how do I proceed to implement a time-based "debounce"? like if multiple repeated events are triggered one right after the other I'll wait some milliseconds, dropping them all except the last one, which I'll somehow handle.
11:27:26 <davean> lts: the usual recomendations are a property testing framework (ie, quickcheck) but if you have a lot you want to tie together, and specific test vectors to cover, you mgiht want something like tasty to control all of it
11:27:49 <davean> lts: if you just are interested in test vectors (why? Unless you're doing crypto stuff this might be a mistake) you might just want hunit or something
11:29:07 <fiatjaf> toom: https://hackage.haskell.org/package/bson-0.3.2.3/docs/Data-Bson.html#t:Document
11:30:39 <fiatjaf> functions you want are there
11:31:23 <toom> fiatjaf: found them, but how do I convert to Text
11:31:35 <sm> lts: and if you have any command-line testing to do, take a look at shelltestrunner
11:32:21 <sm> and if you're considering QuickCheck, also consider http://hackage.haskell.org/package/hedgehog
11:34:04 <fiatjaf> toom: https://hackage.haskell.org/package/bson-0.3.2.3/docs/Data-Bson.html#t:Value
11:35:09 <fiatjaf> I guess once you have a Value you can do some form of `case val of String -> `
11:35:43 <fiatjaf> I hope that makes some sense to you (because I'm a begginer and don't know what I'm talking about)
11:36:28 <fiatjaf> yep, that's it
11:37:13 <fiatjaf> see the type definition for Value and how fval deals with it: https://hackage.haskell.org/package/bson-0.3.2.3/docs/src/Data-Bson.html#Value
11:38:33 <hololeap> is there anything that `maybe mempty id` is equivalent to?
11:38:54 <jle`> hololeap: fold ?
11:39:24 <jle`> > fold (Just "hello")
11:39:27 <lambdabot>  "hello"
11:39:29 <jle`> > fold Nothing :: String
11:39:33 <lambdabot>  ""
11:40:01 <hololeap> where is fold imported from
11:40:05 <jle`> Data.Foldable
11:40:12 <hololeap> oh
11:40:50 <hololeap> that's cool as hell
11:41:19 <hololeap> its like a more generic version of mconcat
11:41:30 <jle`> yeah :) i wish mconcat was fold actually
11:41:34 <jle`> oh well
11:41:46 <hololeap> monoids are amazing
11:42:16 <jle`> yeah, they're one of the perfect examples of where a little bit of generic interfaces and laws goes very far
11:43:04 <jle`> to me it's one of the standards by which other generic typeclass interfaces in haskell are weighed up against
11:43:12 <jle`> but it's hard to compete
11:43:26 <jle`> there probably isn't another typeclass with so many useful polymorphic functions on its values
11:44:08 <jle`> hm well besides the 'big' ones heh
11:44:53 <hololeap> i think the power comes from the fact that combining data structures is so ubiquitous in programming. if you can rewrite a problem in terms of monoids it instantly becomes easier to reason about
11:45:04 <fiatjaf> ok, how do I do the equivalent of javascript's setTimeout on haskell?
11:46:23 <jle`> fiatjaf: (threadDelay 1000000 >>)
11:46:23 <hololeap> well, i guess the combining part is more the realm of semigroups, but having an "empty" default happens quite a bit as well
11:46:39 <sm> there's also http://hackage.haskell.org/package/delay and http://hackage.haskell.org/package/timeout
11:46:57 <jle`> :t \n -> (threadDelay n >>)
11:46:58 <lambdabot> error:
11:46:58 <lambdabot>     Variable not in scope: threadDelay :: t -> m a0
11:47:11 <jle`> :t \n -> (threadDelay n >>)
11:47:13 <lambdabot> Int -> IO b -> IO b
11:47:25 <jle`> nice thing about first-class actions :)
11:47:46 <Tuplanolla> You have to ask yourself whether `threadDelay` reacts correctly to your process being suspended and resumed.
11:59:21 <concaveirc> I am trying to scramble a very large string a fixed number of times and store the scrambles in a list.
11:59:34 <concaveirc> Is the Eval monad the way to go?
12:00:03 <concaveirc> I have not used it before, but intuition says that I need to first establish a complete list of thunks somehow, rather than a list that is a thunk.
12:01:09 <concaveirc> I'd use Eval to parallelize the scrambles in the list.
12:03:25 <dminuoso> Im looking for a kind of "grouping" function: (Eq b) => (a -> b) -> [a] -> [(b, [a])] where I specify some kind of "calculate key" function, and then get buckets for each different key
12:04:04 <dminuoso> I feel like there must be something I can use to easily pipefit this together in Prelude.
12:05:42 <dminuoso> Mmm. Oh I was thinking too narrowly. I think I just want something like Map :)
12:06:20 <metahumor_aw> dminuoso: some combination of sort and groupBy?
12:06:33 <metahumor_aw> or fold into a map
12:07:41 <dminuoso> metahumor: Ah sort and groupBy was what I was somehow looking for, but folding into a map might be better. Thank you.
12:11:59 <metahumor> dminuoso: you might like to use something like "foldr (\x acc -> at (f x) . non [] <>~ [x] $ acc) M.empty"
12:13:27 <dminuoso> What is <>~ ?
12:13:34 <metahumor> :t \f xs -> foldr (\x acc -> at (f x) . non <>~ $ acc) M.empty xs
12:13:36 <lambdabot> error:
12:13:36 <lambdabot>     parse error on input ‘$’
12:13:36 <lambdabot>     Perhaps you intended to use TemplateHaskell
12:13:46 <metahumor> :t \f xs -> foldr (\x acc -> at (f x) . non <>~ [x] $ acc) M.empty xs
12:13:48 <lambdabot> error:
12:13:48 <lambdabot>     • Couldn't match type ‘p0 (Maybe ([a] -> Identity [a]))’
12:13:48 <lambdabot>                      with ‘Identity’
12:14:13 <metahumor> :t (<>~)
12:14:15 <lambdabot> Monoid a => ASetter s t a a -> a -> s -> t
12:14:27 <dminuoso> Ahh.
12:14:28 <metahumor> :t \f xs -> foldr (\x acc -> at (f x) . non [] <>~ [x] $ acc) M.empty xs
12:14:31 <lambdabot> (Eq a, Ord k, Foldable t) => (a -> k) -> t a -> M.Map k [a]
12:14:32 <metahumor> there we go
12:15:06 <dminuoso> That's pretty nifty with lenses. :)
12:15:09 <metahumor> (<>~) is a Setter that mappends
12:15:27 <metahumor> yeah. lists might not be the best choice for Monoid here because mappend is pricey
12:15:30 <dminuoso> Yeah, gathered that from that `Monoid a` and `ASetter` constraint and the context. :)
12:15:46 <dminuoso> metahumor: Right, I actually use Vector here.
12:17:20 <dminuoso> :t non
12:17:22 <lambdabot> (Functor f, Profunctor p, Eq a) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
12:17:24 <dminuoso> o.o
12:19:02 <metahumor> if you do end up using list, this might be better
12:19:17 <metahumor> :t \f xs -> foldr (\x acc -> at (f x) . non [] %~ (x:) $ acc) M.empty xs
12:19:19 <lambdabot> (Eq a, Ord k, Foldable t) => (a -> k) -> t a -> M.Map k [a]
12:21:00 <dminuoso> This is too crazy for my brain
12:21:46 <metahumor> broken down is: "at (f x)", that is, viewing at possible key (f x)
12:22:08 <dminuoso> Okay, so `at` does not just work for lists, but anything indexable?
12:22:13 <metahumor> followed by "non []", that is, if there is no such key, give back a "[]"
12:24:28 <metahumor> "at" works at anything Indexable, exactly. and what's nice is that for Maps, the IxValue is directly used as as the key
12:24:54 <metahumor> finally, "%~" modifies at the lens, and we modify by prepending x using (%~ (x:))
12:25:06 <metahumor> we do all of that on the accumulated Map
12:26:45 <dminuoso> metahumor: That `non` is the really strange part. On a superficial level I understand what its supposed to do, but the whole Control.Lens.Iso thing is a bit cryptic :)
12:26:56 <dminuoso> `If v is an element of a type a, and a' is a sans the element v, then non v is an isomorphism from Maybe a' to a.
12:27:20 <dminuoso> I mean I understand what this says
12:28:33 <Franciman> Hey, what's an idiomatic haskell alternative to Actors for concurrent software?
12:28:47 <metahumor> FRP? reflex?
12:29:00 <Franciman> I was reading about the super cool STM, but it looks like that it like gives the building blocks upon which to structure the program
12:29:04 <dminuoso> metahumor: Is this Isomorphism being used as a Prism there?
12:29:11 <Franciman> instead Actors is more about the structure directly
12:29:13 <Franciman> Am I wrong?
12:29:32 <metahumor> dminuoso: I'm not literate in the terminology
12:29:35 <metahumor> unfortunately
12:29:56 <Franciman> metahumor, thanks
12:30:10 <conal> Franciman: It depends on whether you care about having an underlying simple & precise mathematical model so that your software is well-defined and can be reasoned about practically and dependably.
12:30:28 <Franciman> conal, I do
12:30:36 <Franciman> simple is my jam
12:31:02 <Franciman> but I'm also interested about the case in which I don't
12:31:07 <Franciman> Just want to explore
12:31:20 <conal> Ah. Then you probably don't want actors. Or *any* form of concurrency, since it's imperative and non-deterministic in nature.
12:31:50 <Franciman> ah, I see what you mean
12:32:32 <fiatjaf> this may be exactly what I was looking for (at least it seems to work here). thanks, jle` and Tuplanolla.
12:32:53 <conal> Franciman: as a drastic alternative, check out FRP (as originally conceived): https://github.com/conal/talk-2015-essence-and-origins-of-frp/blob/master/README.md
12:32:57 <Franciman> If I need concurrency?
12:33:05 <Franciman> thank you
12:33:54 <conal> Franciman: note that most "FRP"-labeled systems (including relfex) lack the fundamental FRP properties discussed in that talk.
12:34:12 <Tuplanolla> Luck would have it that you're here, conal. We were discussing constrained categories earlier today.
12:34:18 <conal> Franciman: the talk will at least give you another perspective, whatever you decide to do with it.
12:34:25 <conal> Tuplanolla: oh?
12:34:40 <Franciman> conal, perfect, thank you very much
12:34:47 <conal> Franciman: my pleasure. enjoy!
12:34:59 <Franciman> and oh my god, you're like a superstar :P
12:35:01 <conal> Tuplanolla: I'm working hard on that project. It's still my main focus.
12:35:45 <Tuplanolla> I was wondering what it would require of the host language if the concept was to be implemented in it instead of being part of the compiler.
12:36:35 <Tuplanolla> I read the section on tradeoffs, but those regarded GHC.
12:38:18 <conal> Tuplanolla: Interesting. Would you want the ability to interpret in other categories to have a presence in the language?
12:38:23 <Franciman> Also, I'm writing this toy application: I have a set of tv series and I want to download subtitles for each of them. And I can modify this set of tv series by deleting and adding
12:38:28 <Franciman> this is my case for concurrency
12:39:11 <Tuplanolla> I was thinking of putting it into a proof assistant in the form of reflection or tactics.
12:40:11 <conal> Tuplanolla: oh, neat. johnw is doing something related, as i understand it.
12:40:17 <metahumor> dminuoso: were you able to get your groupings working?
12:40:33 <Tuplanolla> Can you elaborate on "doing"?
12:40:41 <dminuoso> metahumor: I cant fiddle any of this together. Im gonna scrap lenses away for now, because Im fighting on too many fronts with this.
12:41:01 <metahumor> what's the larger problem you're trying to solve?
12:41:19 <conal> Tuplanolla: only poorly, but johnw is often here.
12:42:25 <Tuplanolla> I'll have to ask him about it later.
12:42:46 <johnw> Tuplanolla: I'm here now
12:43:28 <Tuplanolla> That's great.
12:46:49 <dminuoso> metahumor: I just want to do some data processing :)
12:47:07 <metahumor> =) that's my day-to-day job too
12:48:33 <Tuplanolla> Are you working on something related to constrained categories, johnw?
12:48:46 <Franciman> Tuplanolla, what are you planning to do with constrained categories?
12:49:15 <johnw> Tuplanolla: is that a way of defining a sub-category of Hask?
12:49:23 <johnw> note that none of the work I'm doing is in Haskell
12:49:32 <Tuplanolla> Boundary value problems perhaps, Franciman.
12:50:36 <Franciman> Tuplanolla, https://en.wikipedia.org/wiki/Boundary_value_problem these?
12:50:43 <Tuplanolla> Yes.
12:52:08 <Tuplanolla> I was going to explore the idea with a proof assistant to see how it compares to the way it's done with GHC.
12:52:57 <EvanR> which proof assistant
12:53:14 <Tuplanolla> Any, EvanR.
12:53:32 <EvanR> any and all
12:53:43 <Tuplanolla> Well, definitely not all.
12:53:45 <EvanR> any and or all
12:54:09 <EvanR> curious if its something standard or something weird
12:54:35 <Tuplanolla> Coq, Agda or Idris right now.
12:57:33 <fiatjaf> stupid question: why do I have to do `data Record = Record { field :: Int }` instead of `data Record = { field :: Int }`?
12:58:07 <infinisil> fiatjaf: because that's how haskell works, the Record on the left is a type, the Record on the right is the constructor
12:58:29 <infinisil> fiatjaf: yeah it would be possible to introduce syntactic sugar for this, but it's not worth it
12:58:48 <Tuplanolla> The plan is to see how the formalism fits the synthesis of solvers for boundary value problems.
12:59:38 <EvanR> if you dont use a constructor, then youre thinking haskell has an actual record system, which it doesnt
13:00:26 <EvanR> "records" in haskell are individual separate product types with specially named projectors
13:00:36 <EvanR> they arent compatible with each other
13:00:43 <fiatjaf> infinisil: I understand, but what if I want to just define a type that has some fields?
13:01:03 <infinisil> fiatjaf: EvanR explained it nicely
13:01:06 <fiatjaf> EvanR: yes, that's exactly. I want an actual record system.
13:01:12 <EvanR> you just want to define a record, not a type
13:01:20 <EvanR> but in haskell you are defining a type
13:01:21 <fiatjaf> is that possible?
13:01:28 <infinisil> you just did
13:01:40 <fiatjaf> no, I mean the record
13:01:43 <EvanR> there are some libraries which try to jury rig a record system
13:01:47 <EvanR> like vinyl
13:01:50 <fiatjaf> why isn't it possible to define a record?
13:02:19 <EvanR> they didnt design a record system into the language
13:02:46 <EvanR> aiui miranda didn't have one either
13:02:59 <fiatjaf> for no reason at all, then?
13:03:07 <EvanR> right
13:03:23 <mnoonan> I think the reason was that the right underlying theory wasn't clear
13:03:29 <EvanR> in 1988 that wasnt really a killer feature of languages, i think
13:04:30 <fiatjaf> well, that's odd
13:04:42 <EvanR> note that C doesnt have a record system either, but its structs are nonetheless more ergonomic due to the way fields work
13:04:51 <fiatjaf> because it seems that typeclasses embed such a record system, only forcing us to declare the entire typeclasses instead
13:04:59 <EvanR> different structs can have fields with the same name
13:05:30 <mnoonan> from "A History of Haskell: Being Lazy with Class": "The strongest reason seems to have been that there was no obvious“right” design."
13:05:59 <EvanR> in the absense of the right thing, do something wrong? :)
13:06:12 <mnoonan> "There are a huge number of record systems, variously supporting record extension, concatenation, update, and
13:06:12 <mnoonan> polymorphism. All of them have a complicating effect on the type
13:06:12 <mnoonan> system (e.g., row polymorphism and/or subtyping), which was already complicated enough."
13:06:31 <mnoonan> EvanR: I think it was an accidental case of not avoiding success at all costs :)
13:06:53 <fiatjaf> I understand.
13:07:21 <EvanR> right so a retrospective thing to do on that front would have been, dont even do what we have now, with the record update syntax
13:08:01 <fiatjaf> I was thinking about Elm records, but then reading mnoonan quotes I remembered that Elm records are clearly not "the right design".
13:08:08 <EvanR> elm has some support for records, but not much
13:08:24 <EvanR> its type system allows certain operations to be well typed, but its limited
13:08:35 <Tuplanolla> I've looked at your Coq stuff on category theory, but I don't know if it has anything to do with conal's concat, johnw.
13:08:42 <Tuplanolla> Does it?
13:12:24 <mnoonan> conal: this is not quite on-topic, but one of my favorite things in the ccc paper is when you casually write "a -o b" for linear maps, in the linear-algebra sense
13:12:43 <mnoonan> I never made the connection between linear functions in logic and in algebra before :|
13:12:54 <conal> mnoonan: :)
13:18:15 <EvanR> lollipop https://www.youtube.com/watch?v=3rYoRaxgOE0
13:26:14 <Tuplanolla> I guess that's a no, so it's time for an adventure.
13:47:53 <typetetris> hmm, how do semigroups and monoids go together? shouldn't every monoid be a semigroup as of ghc 8.2 ?
13:48:46 <iqubic> Yes, they all monoids should be semigroups, but that's not officially stated in the code.
13:48:54 <metahumor> i thought its 8.4
13:49:05 <typetetris> ah, ok.
13:49:05 <geekosaur> half done oin 8.2, completed in 8.4
13:49:25 <typetetris> I wondered, why I couldn't do Data.Semigroup.(<>) with some imported Monoid.
13:49:52 <iqubic> Just use the Data.Monoid (<>) instead. Problem solved.
13:55:38 <jle`> typetetris: every monoid should be a semigroup, but semigroup is not a superclass of monoid until 8.4
13:56:06 <davean> Sadly, most of hackage hasn't gotten this message
13:56:15 <davean> I've had to make rather a huge number of local patches
13:56:25 <jle`> typetetris: you can also use WrappedMonoid to ge ta free semigroup instance fo ra given monoid
13:56:30 <jle`> and use Semigroup's <>
13:56:44 <jle`> but that's kind of silly unless you're using semigroup-polymorphic functions heh
14:00:13 <typetetris> No, it is just about playing around with it a bit and I kind of expected the (Semigroup m) => (Monoid m) relationship.
14:02:12 <SumpfSchlock> hey, any recommendations of books about graphics with haskell?
14:05:39 <EvanR> typetetris: careful is that a class or instance, because that => means opposite things in each case
14:05:56 <iqubic> It does?
14:06:17 <Stef> Hiyaaaaa people. How's it tonight?
14:06:21 <iqubic> How is that?
14:06:27 <iqubic> Stef: It is good.
14:06:32 <EvanR> class Semigroup m => Monoid m where means all monoids are semigroups
14:06:33 <Stef> Jaaaaaaaaa
14:06:39 <Stef> Awesome
14:06:48 <EvanR> instance Semigroup m => Monoid m where means all semigroups are monoids
14:07:26 <iqubic> Why is that so confusing?
14:07:52 <EvanR> because the => expression is the same
14:08:20 <Stef> What are classes in Haskell? Seems like a very oo paradigm
14:08:45 <[exa]> Stef: typeclasses != classes, there's some vague similarity to interfaces/concepts
14:08:45 <EvanR> classes in haskell are like interfaces in java
14:08:50 <mud> Stef: They're almost completely different from classes in OO actually, funnily enough
14:09:08 <Stef> That's good to hear
14:09:15 <Stef> :D
14:09:25 <Stef> Thanks guys
14:09:55 <EvanR> if a class in oo is a way to construct kinds of objects, then haskell has functions for that
14:10:07 <int-e> haskell typeclasses are a bit like interfaces
14:10:25 <iqubic> EvanR: Which are also called constructors funnily enough.
14:10:37 <EvanR> no, constructors are yet something else
14:10:52 <iqubic> What are you refering too then>
14:11:46 <EvanR> to "build" something of type X, with some parameters A B C... you just need a A -> B -> C -> X
14:12:20 <iqubic> Right, that makes sense.
14:12:22 <EvanR> True, Nothing, [] are constructors but not functions
14:12:42 <iqubic> Is Just a function or a constructor?
14:12:59 <EvanR> both
14:13:11 <iqubic> That's what I thought.
14:13:21 <iqubic> :t Just
14:13:23 <lambdabot> a -> Maybe a
14:13:32 <iqubic> Right. I see how that works.
14:13:44 <glguy> being a constructor or not doesn't have to do with the type of the thing, it's the capitalized name that can be used both to match in patterns and as a value
14:14:27 <Stef> So a constructor function is like a map?
14:15:02 <iqubic> glguy: In this case I'm showing that Just can be used as a function, in addition to being a constructor.
14:15:02 <Stef> x => n
14:15:24 <iqubic> :t Cons
14:15:27 <lambdabot> error:
14:15:27 <lambdabot>     • Data constructor not in scope: Cons
14:15:27 <lambdabot>     • Perhaps you meant one of these:
14:15:27 <glguy> Stef: There are two kinds of names: variables and constructors. constructor is a kind of name
14:15:53 <Stef> Ah cool
14:16:06 <Stef> Scratches head
14:16:36 <Stef> And a constructor of a given type will take an input and return a given output
14:16:41 <Stef> Like a function might?
14:16:55 <EvanR> data Bool = True | False
14:17:01 <glguy> type constructor is also another kind of name
14:17:03 <iqubic> No inputs there.
14:17:03 <EvanR> True and False are constructors
14:17:08 <glguy> at the type level we have type constructors and type variables
14:17:15 <glguy> doesn't tell us about being a function or taking inputs or outputs
14:17:19 <iqubic> What are type constructors?
14:17:34 <Stef> Ah cool
14:17:42 <glguy> The value and type namespaces are separate in Haskell, type constructors are constructors in the type namespace
14:17:55 <EvanR> Bool, Maybe, Either
14:20:07 <metahumor> why are there no "unary tuples" in Haskell? I understand the isomorphism between a value and "(value,)", is that the only reason why?
14:20:46 <metahumor> there is Linear.V1
14:20:48 <glguy> Probably because they didn't settle on a syntax for one
14:21:01 <EvanR> not really isomorphic... if you take Identity to be the unary tuple, that adds a bottom (just like 2-tuples do)
14:21:01 <glguy> We have Data.Functor.Identity
14:21:18 <glguy> but that's a newtype, so not quite the same
14:21:34 <EvanR> oh dang
14:21:45 <merijn> I'm not even sure why you'd ever want a unary tuple?
14:21:49 <merijn> What's the point?
14:22:02 <Stef> thanks guys going to keep reading learn you. Catch you in a bit
14:22:07 <metahumor> just was thinking about how to translate python (numpy specifically), since "ndarray.shape" returns tuples, possibly of value "(1,)" for example
14:22:31 <EvanR> youd want it for a complete picture of linear algebra, but then you dont really want tuples
14:22:36 <glguy> merijn: You might for some reason want to add an extra indirection
14:22:38 <metahumor> ignoring Vec (k :: Nat) for the time being
14:22:40 <EvanR> you want sized vectors
14:22:45 <davean> metahumor: might you just want Vector?
14:23:12 <metahumor> i'm not thinking about actual use cases there, just thinking about general differences in syntax and semantics of languages
14:23:36 <EvanR> so the corresponding thing is V1
14:23:44 <davean> metahumor: I believe GHC has a unary tuple built in way down below
14:23:45 <glguy> merijn: Suppose you had a Map-like data structure and you want to be able to distinguish indexing the Map from forcing the value and perhaps this map doesn't provide that functionality directly
14:24:51 <glguy> In the case of vector you'd just use indexM for this
14:25:12 <metahumor> yeah, Linear.V1 was my first thought. Unlike (a,b), however, Linear.V2 can only ever be V2 a, and fmap goes over both "dimensions"
14:26:01 <EvanR> if it didnt you have to do bimap
14:26:12 <metahumor> which is a reasonable way to generalize from 1D to n-D. I was trying to "de"generalize from n-tuples to 1-tuples, and whether there were underlying structures for it
14:26:18 <metahumor> Identity is close
14:26:24 <EvanR> and if everything can be different types... you need a corresponding matrix of functions of the right type
14:31:04 <metahumor> thanks for humoring me guys =)
14:46:08 <delta3> . ear
14:53:36 <woodson> hi guys I am using cpython lib to communicate with a python library, I am also using servant to create a little web api
14:54:08 <woodson> however, everytime i execute the code that communicates with the python library
14:54:14 <woodson> my app crashes with Segmentation fault (core dumped)
14:54:33 <woodson> Anybody knows why?
14:55:00 <Tuplanolla> You access memory you should not be accessing, woodson.
14:56:03 <Tuplanolla> Something goes wrong with the ffi there.
14:57:00 <woodson> Tuplanolla: When I am doing executing it in the ghci, I am not getting a segmentation fault
14:59:00 <dmwit> ?hackage OneTuple metahumor
14:59:00 <lambdabot> http://hackage.haskell.org/package/OneTuple metahumor
15:01:04 <iqubic> I love that.
15:01:24 <iqubic> It's like Identity, except not.
15:05:17 <iqubic> All you need to do is "type OneTuple a = Identity a"
15:05:30 <dmwit> No, that has a different semantics.
15:06:25 <dmwit> `OneTuple a` introduces a fresh element into the semantic domain that is unlike any of the elements of the `a` domain; whereas `Identity a` has exactly the same collection of semantic elements.
15:06:59 <dmwit> ?let data OneTuple a = OneTuple a
15:07:02 <lambdabot>  Defined.
15:07:13 <dmwit> > case Identity undefined of Identity x -> ()
15:07:16 <lambdabot>  ()
15:07:49 <dmwit> > Identity undefined `seq` ()
15:07:53 <lambdabot>  *Exception: Prelude.undefined
15:07:56 <dmwit> > OneTuple undefined `seq` ()
15:07:59 <lambdabot>  ()
15:08:11 <iqubic> How does that work?
15:08:26 <dmwit> Which thing is "that"?
15:09:01 <dmwit> Ah, here's the `case` expression I wanted to use for distinguishing the two:
15:09:08 <dmwit> > case undefined of Identity x -> ()
15:09:11 <lambdabot>  ()
15:09:14 <dmwit> > case undefined of OneTuple x -> ()
15:09:18 <lambdabot>  *Exception: Prelude.undefined
15:09:29 <iqubic> How does that case thing work?
15:09:38 <EvanR> ^ important question
15:09:57 <glguy> and what is?
15:10:02 <dmwit> If you are talking specifically about `case Identity undefined of Identity x -> ()`, then just think as the compiler does and erase all newtypes: `case undefined of x -> ()` does not force the scrutinee.
15:11:31 <dminuoso> Whats the most efficient way to turn a large Vector into a Set?
15:11:41 <dmwit> Or, another way to say: the `Identity` (term) constructor doesn't exist at runtime. So it cannot affect evaluation.
15:11:55 <iqubic> Oh. I see.
15:11:57 <EvanR> dminuoso: is it already sorted?
15:12:08 <dminuoso> EvanR: It can be if
15:12:31 <EvanR> fromAscList :: Eq a => [a] -> Set a
15:12:44 <dmwit> EvanR: I bet saying both answers is shorter than asking that question. =)
15:12:58 <dminuoso> EvanR: That would require turning it into a [] first though
15:13:15 <EvanR> well, thats how loops in haskell work
15:13:35 <dminuoso> EvanR: Well I was hoping for something more cache friendly. :(
15:13:49 <EvanR> youre building a Data.Set
15:13:53 <EvanR> good luck
15:14:02 <dminuoso> Heh.
15:14:11 <EvanR> the list part is probably the least of youre problem
15:14:56 <EvanR> if the lazy list is consumed immediately, gc tends to reclaim each node very soon
15:15:15 <EvanR> but the set structure is going to persist and outgrow cache
15:16:30 <dminuoso> EvanR: Well it just feels a bit silly considering I already have everything in consecutive memory.
15:16:57 <EvanR> when you fold over a toList, it doesnt make a list in memory
15:17:34 <dmwit> I checked. Data.Set.fromList and friends are not folds. You almost certainly will not get list fusion.
15:18:07 <EvanR> i didnt expect full fusion, but its not like you create a whole list in memory first, then build the set
15:18:23 <EvanR> though, why arent they folds
15:18:40 <dminuoso> EvanR: What do you mean "fold over a toList" ?
15:18:48 <dmwit> dminuoso: If fromList and friends aren't fast enough, you should consider looking at their source and replacing the list traversal operations with indexing. Copy-and-paste job, which is a bummer, but might make for an interesting stand-alone package.
15:19:19 <dmwit> dminuoso: Also, unless you are using an unboxed vector, your "in consecutive memory" claim is a bit of a misnomer. You have consecutive pointers to non-consecutive memory instead.
15:19:37 <dminuoso> Oh.. well there's that I guess.
15:19:44 <dminuoso> List route it is =)
15:19:45 <EvanR> dminuoso: if you hold a "toList somevector" in your hand, this is not a full list. this is the beginning of a "generator" for items of the vector that can be consumed in constant space
15:19:56 <dminuoso> EvanR: Ahh/
15:20:16 <EvanR> if it fuses, even better, because no intermediate list nodes are even created
15:20:19 <dminuoso> EvanR: "generator" in the sense that loop fusion can be applied I guess?
15:20:32 <EvanR> yes, when many list ops are chained
15:20:39 <dminuoso> right
15:20:47 <dmwit> dminuoso: No; just in the sense that as you traverse the list it can be GC'd (assuming you don't hold it in two hands at once instead of just one hand).
15:21:04 <EvanR> tie one hand behind your back
15:21:04 <dmwit> (Or: what do you mean by "loop fusion"?)
15:23:39 <dmwit> average xs = sum xs / genericLength xs -- very GC unfriendly
15:24:00 <EvanR> two hands hehe
15:24:09 <dmwit> average xs = (\(s, l) -> s / l) . foldMap (\x -> (Sum x, Sum 1)) $ xs -- GC friendly
15:25:18 <dminuoso> dmwit: Oh I don't. It would be something silly as (S.fromList $ V.fromList $ produceVector)
15:25:31 <dminuoso> Not even keeping it in any hand
15:25:39 <dminuoso> err, that second should be toList
15:25:45 <dmwit> There is one hand there. But just one. =)
15:25:50 <dminuoso> okay =)
15:26:06 <dmwit> Still: I don't think you get loop fusion in the sense you are hoping. But I'm not 100% sure because I'm not 100% sure what you mean by loop fusion.
15:31:42 * EvanR gets sucked into the implementation of Set
15:35:50 <dpren> can anyone recommend a strict, prefix trie type library for looking up Text? (for autocompletion)
15:37:58 <davean> dpren: I have a lot of good experience with https://hackage.haskell.org/package/list-tries
15:39:54 <davean> dpren: though, I can thinkof some possibly better structures memory wise for that ...
15:40:29 <davean> Tries certainly are nice and easy though
15:43:39 <dpren> davean: do tell
15:43:58 <EvanR> theres this... https://hackage.haskell.org/package/bytestring-trie
15:44:01 <dpren> I'm not too worried about memory though
15:44:05 <EvanR> if you utf8 encode everything
15:46:21 <davean> dpren: well, a DFA seems like it would be smaller
15:47:57 <davean> I guess the benefit of a Trie would be its complexity is lower in an online form?
15:48:57 <dpren> its for IDE server
15:49:18 <davean> or maybe a Ternary search tree?
15:49:40 <davean> Anyway, thats off the top of my head
15:50:32 <davean> if you think they've typoed or something I guess I might try a suffix array
15:51:58 <dpren> oh also, I need relatively fast indexing
15:52:47 <davean> well, suffix arrays have a lot of different complexities for building them, depending on what you know about your alphabet
15:53:06 <davean> but, it miht be O(n) for you (moderately large coefficient though)
15:54:26 <davean> anyway, they all ahve tradeoffs, I don't understand your problem well, nor do I plan to spend hours considering it in depth :)
15:54:41 <dpren> thats okay, thanks for your help :)
16:12:29 <Costar> hi
16:16:45 <JuanDaugherty> ello
16:17:02 <jpittis> Hey there. I'm using the Async library to build trees of long running light weight threads. I want a way to cancel the top parent of the tree and have it propagate to all the children. The Async library has link and link2 which do similar things but note quite that. Anyone have experience with building up these sorts of lwt trees?
16:17:05 <Average-user> jle`: are you here?
16:46:46 <freeman42x[NixOS> anyone has a tutorial of how to connect lambdabot to an irc channel? got lambdabot executable installed but I can't find how/where to set config
17:13:55 <Tehnix> Anyone have any good resources on building mobile apps with GHCJS/Reflex?
17:22:44 <srhb> Tehnix: You might want to try in #reflex-frp if you haven't already :)
17:41:18 <Tehnix> srhb: ah, didn't know they had a channel, thanks!
18:13:36 <cemerick> what is "package cryptonite-0.23-tBhIFydRM1BObErSMZHTR overrides a previously defined package" trying to tell me?
18:14:17 <winnner> hello what is theoritical part of haskell ?
18:18:51 <bq> What
18:20:57 <bq> All the theoretical parts are the theoretical parts
18:21:21 <winnner> bq: I didnt understand that phrase what theory in general here in programming language
18:21:35 <winnner> say lambda calculus is theory ?
18:21:41 <winnner> What exactly it will be ?
18:21:44 <bq> Sure
18:21:53 <bq> What exactly will what ve?
18:22:26 <bq> Lambda calculus is what it is
18:22:37 <geekosaur> cemerick, usually either that you are using stack with --system-ghc (don't) or you have modified stack's package repository outside of stack (*really* don't). otherwise it can mean you are depending on multiple verisons/builds of a package, which stack should prevent but cabal (old-)build might allow; use a sandbox or new-build
18:22:39 <bq> Same with category theory
18:23:10 <geekosaur> I would nto worry about theory
18:23:38 <geekosaur> you may care when you get into advanced haskell programming
18:23:43 <cemerick> geekosaur: just fixed it. Was actually a stray import in my Main.hs referring to a module I removed.
18:23:53 <cemerick> No idea why that triggered warnings about cryptonite
18:23:57 <bq> It's a whole series of books, too much for an IRC discussion
18:24:35 <winnner> bq ok
18:48:18 <freeman42x[NixOS> hscolor issue: https://stackoverflow.com/q/48472089/750216
18:58:11 <chocopuff> i forgot what this was called, you could ** a list, that is like concatenate an identical list to the original list
18:58:18 <chocopuff> i remember seeing this before, but don't know what it was
18:58:48 <mniip> > [1,2]>>"hello"
18:58:51 <lambdabot>  "hellohello"
18:59:09 <chocopuff> mniip: was there something with ** before? maybe i'm just mistaken then
18:59:21 <chocopuff> thanks for that too!
19:02:35 <geekosaur> not standard. sounds a bit like perl's x operator though
19:04:57 <mniip> chocopuff, what's wrong with 'replicate 2'
19:08:34 <chocopuff> it's a list of duplicates rather than
19:08:53 <chocopuff> [1,2] -> [1,2] ++ [1,2] ++ [1,2] ++ ....
19:09:10 <chocopuff> thanks for the clarification, geekosaur. probably may be the case and had mixed stuff up
19:10:02 <[Leary]> > cycle [1,2]
19:10:03 <mud> Python (and probably others) have similar things, like  [1,2,3] * 2
19:10:04 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
19:11:49 <chocopuff> mud: it might actually have been python that I confused it with then
19:12:12 <chocopuff> oh perfect
19:12:17 <chocopuff> > take 10 cycle [1,2]
19:12:21 <lambdabot>  error:
19:12:21 <lambdabot>      • Couldn't match expected type ‘[Integer] -> t’
19:12:21 <lambdabot>                    with actual type ‘[a1]’
19:12:33 <chocopuff> whoops
19:12:52 <chocopuff> > take 10 $ cycle [1,2]
19:12:56 <lambdabot>  [1,2,1,2,1,2,1,2,1,2]
19:13:09 <chocopuff> I guess this works!
19:51:26 <ReinH> > concat $ replicate 5 [1,2]
19:51:29 <lambdabot>  [1,2,1,2,1,2,1,2,1,2]
19:54:27 <EvanR>  > 12 x 5
19:54:32 <EvanR> 1212121212
19:55:20 <buhman> amalloy: were you going to do more episodes of AoC?
19:57:03 <amalloy> i was, but i kinda ran out of steam. if i ever get back to finish it i'll record it
19:57:15 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org' by ChanServ
21:31:43 <buhman> amalloy_: day 11 is as enlightening as it is absolutely hilarious. "what I computed is a mathematical quantity with no meaning"
21:35:02 <buhman> I think the hex geometry -> cubes in 3d space thing combined with the monoid explanation is also mind-bendingly cool.
21:38:12 <sqooq> hi
21:39:08 <sqooq> anyway to have two State computations have their own separate state but be able to combine their results?
21:39:19 <sqooq> Actually let me give a bit more detail.
21:40:23 <sqooq> I have 3 things to keep track of, 2 off them are "global". One of those two is a counter, the other is a list of results (I think Writer monad is usually used for that?)
21:40:28 <sqooq> of*
21:41:50 <sqooq> the third thing is local to the separate state functions and is just a buffer/memory storage that gets used. So there may be 2 or more computations going on that all use the 2 global states, but each have their separate state object.
21:43:04 <sqooq> I can model the whole thing assuming only 1 buffer, or one state computation group, and it works beautifully, but I can't figure out how to have separate one all working together.
21:43:18 <hololeap> sqooq: there is a RWS (Reader, Writer, State) monad
21:43:38 <hololeap> also, if you have more than one state "vairable", combine them into a tuple
21:43:46 <hololeap> *"variable"
21:43:54 <sqooq> hololeap, well I made a data type containing all 3
21:44:20 <sqooq> which works somewhat nicely, just made three gets functions that grabs specific onces, and three modify functions to modify them.
21:44:32 <sqooq> The main issue though is to have them separated.
21:49:15 <sqooq> i did it brute force but only focusing on the separate buffer aspect here http://lpaste.net/361994
21:49:26 <sqooq> as example of what I mean
21:52:42 <hololeap> that is hella confusing
21:53:51 <hololeap> i'm not sure what you're trying to do but it might help if you refactor your mental model
21:54:12 <hololeap> :D
21:57:07 <hololeap> you might be trying to force an imperative mindset into a functional language... i haven't seen the rest of your project, though, so i'm only speculating
21:58:07 <hololeap> (if you felt comfortable posting some of it, i wouldn't mind helping refactor it)
21:58:19 <sqooq> that was just a brute force example
21:58:30 <hololeap> i'm not sure what you mean by that
21:58:44 <sqooq> meaning it shows pretty much everything explicitly
21:58:52 <sqooq> but it's not how I've implemented anything
21:59:48 <sqooq> My code is just data Params a = Params {counter :: Int, results :: [a], buffer :: a }
22:00:00 <sqooq> and functions to modify and get them
22:00:10 <sqooq> the problem is I want to have separate buffers
22:00:29 <sqooq> but have them all constrained by the same counter, and have them not affect the results until they interact
22:00:39 <sqooq> in the brute force example I did x+y
22:02:18 <sqooq> so i want to have the counter be at a value, do x which uses it and the buffer and modifies the buffer, y which uses the *same* time and uses it's own buffer and modifies it's own buffer, and then extract their values and do x+y, add that result to the list of results, increment the counter, and then do another stateful computation (perhaps the same, perhaps different)
22:02:21 <hololeap> maybe make a Monoid (or Semigroup) instance with your data types to simplify combining them. also, if you just have an incremental counter, you probably don't need the State monad for that part. Reader will work or possibly even `zip [1..] $`
22:03:18 <sqooq> hololeap, I figured Reader and Writer could replace those two elements, but not sure zip could.
22:03:31 <sqooq> but you can ignore those for now
22:03:36 <sqooq> the tricky part is the separate buffers
22:03:57 <hololeap> what goes in the buffers and what exactly makes it tricky to keep them seperate?
22:04:26 <sqooq> imagine it's just State Double a, and x uses the double and then updates it, y has it's *own* buffer, uses it and updates it, and then their final results get added together x+y
22:04:47 <sqooq> hololeap, Idk is separating them trivial? I cannot figure out how to do it
22:05:22 <sqooq> just doing something like `do { a <- x; b <- y; pure $ x+y }` ends up making the state of x bleed into y
22:05:27 <sqooq> but y should have it's own state
22:05:48 <sqooq> and really that do block will get repeated
22:06:36 <sqooq> so x should use it's last computed state, y uses *it's* last computed state, and again they get added together.
22:06:50 <sqooq> Btw this can be more than two, this must work for arbitrary numbers of comptuations.
22:09:21 <hololeap> are you using the functions for State? get, put, modify
22:09:50 <hololeap> `pure blah` doesn't set anything in the State monad, you have to use put or modify
22:10:50 <sqooq> hololeap, yes, really the code (only one buffer) currently does `{out <- pure $ x + y; modify $ addResult out; pure out}
22:15:18 <hololeap> what is the type of your State monad?
22:15:25 <hololeap> State ??? a
22:15:54 <sqooq> State (Params a) a
22:16:09 <sqooq> data Params a = Params {counter :: Int, results :: [a], buffer :: a }
22:16:56 <hololeap> i see, so why not make it (assuming I understand correctly) data Params a = Params {counter :: Int, results :: [a], bufferX :: a, bufferY :: a}
22:17:18 <hololeap> since you want to have separate buffers for "x" and "y", right?
22:17:19 <sqooq> because I need arbitrary amounts
22:17:25 <sqooq> x,y,z,a,b,c,d
22:17:29 <sqooq> some cases i'll do x+y
22:17:39 <sqooq> other's Ill do a*b+(x-y*2)
22:17:40 <sqooq> or whatever
22:17:49 <sqooq> and each one may potentially require it's own buffer
22:18:51 <hololeap> and you need to have a variable number of buffers at runtime?
22:19:10 <sqooq> i guess, sure
22:19:43 <sqooq> and I'm very sure that this buffer idea is the way to go. There is a painful way to kind of sort of accomplish the same thing using recursing and memoization, but it's a mess.
22:19:54 <sqooq> recursion*
22:20:39 <hololeap> well, i don't know how you want to do it, but if you need more than one buffer, you will have to set up a data type to reflect that
22:21:03 <hololeap> it would make sense that you would know before compiling how many you need
22:21:57 <sqooq> ouch
22:22:12 <sqooq> is there no way to have some sort of separation of state and so for every seperation there's a buffer
22:23:58 <hololeap> i mean you might be able to do some magic with Data.Dynamic to have a variable number of buffers with different types
22:24:09 <hololeap> it seems like overkill though
22:24:13 <sqooq> well they'll all be the same type
22:24:21 <sqooq> I just need arbitrary amounts of them
22:24:44 <hololeap> then you could use a list or some other container for them
22:24:59 <sqooq> that's a bad idea I think
22:25:20 <sqooq> then for each separate computation, it will need to know which index to access the buffer from the list/array
22:25:44 <sqooq> and often these separate computations are exactly the same abstract function
22:25:49 <sqooq> call it "mystery"
22:26:02 <sqooq> x,y, and z may all be calls of mystery with different arguments.
22:26:32 <sqooq> having to pass in the right index would make things more confusing thann I think they need to be (though I don't know how to make it not-confusing lol)
22:26:36 <sqooq> (else I wouldn't be asking)
22:27:19 <hololeap> can you just tell me the problem you're trying to solve?
22:27:33 <hololeap> in less abstract terms
22:28:34 <sqooq> that never works well for me, so I would rather abstain from doing so
22:28:39 <sqooq> if that's ok with you
22:28:46 <hololeap> i don't think i can help then
22:28:55 <sqooq> that's ok, thanks for trying
22:29:26 <sqooq> it's really just arbitrary separate States without having to explicitly define each one.
22:29:31 <sqooq> if such a thing is possible
22:29:36 <sqooq> that's all I really need answered.
22:29:56 <hololeap> if you have more than one state, you will need a way to access each one. there is no way around that
22:30:31 <sqooq> well of course, but I feel like the access can be implicit, if that's the right word
22:30:37 <sqooq> like idk how "fork" and stuff works
22:31:10 <ReinH> This smells like an XY Problem to me but you won't say what you're trying to do so *shrug*
22:31:12 <sqooq> but imagine I could just do `do {x <- fork $ mystery 1; y <- fork $ myster 2; pure $ x+y}` or whatever
22:31:38 <sqooq> and the fork somehow separates them
22:32:03 <hololeap> if there's anything that's a "mystery" with the problem you're trying to solve, i would say try to pin down excatly what you're trying to do and refactor to the simplest terms possible. it's very likely that it's a common problem that has already been solved
22:32:55 <sqooq> Arbitrary amounts of state computations. That's it.
22:33:28 <hololeap> it's also likely that you don't need State and that it's getting in the way of your reasoning
22:33:50 <sqooq> I think I need something at least similar to State. Grabbing and Putting.
22:34:17 <sqooq> ST could work but I feel that's overboard
22:34:24 <sqooq> Btw there's no more specifity to this
22:34:34 <sqooq> like this is the problem, idk what else to say about it
22:34:42 <hololeap> a fold takes a previous computation and returns a new one for each element in a list
22:34:49 <ReinH> This is hard to follow, but why not just tuple up the global state with the local state in the local state computations?
22:34:55 <hololeap> it could be as simple as foldr
22:35:01 <hololeap> (or foldl')
22:35:19 <hololeap> try coming at it from a different angle
22:35:24 <sqooq> ReinH, hmm like `State (State ..., global stuff) a`
22:35:33 <ReinH> No, like a tuple.
22:35:39 <sqooq> hololeap, this is probably the 15th angle I've come at and it's been working the best by far
22:35:49 <ReinH> Do you need to modify the global state in the local computations?
22:35:54 <sqooq> ReinH, no
22:36:13 <ReinH> Then you can turn it into a ReaderT to enforce that
22:36:29 <sqooq> ReinH, what would the type look like
22:37:06 <ReinH> ReaderT GlobalStste (State LocalState a) or w/e
22:37:18 <sqooq> ok that's going somewhere thanks
22:37:25 <ReinH> GlobalState
22:37:29 <sqooq> so the State is embedded in the Reader
22:37:33 <sqooq> local state...
22:37:49 <sqooq> I figured something like that would make it cleaner, but I also figured I needed to really focus on the problem of separate buffers
22:37:52 <ReinH> Yes, or vice versa with StateT, it doesn't matter very much.
22:38:15 <ReinH> I don't uh newest addition what these buffers are or what they're used for.
22:38:19 <sqooq> OOOH but if the separation happens within the realm of ReaderT then they won't transfer to each other! If I'm thinking about this right
22:38:26 <ReinH> Uh sorry, autocorrect
22:38:35 <ReinH> I don't understand ...
22:38:44 <sqooq> ReaderT is a monad right?
22:38:49 <ReinH> Yes.
22:39:03 <sqooq> So within the ReaderT monad computation list (idk what to call it, "block"?)
22:39:11 <ReinH> action
22:39:15 <sqooq> the states will be separate
22:39:18 <sqooq> the local states
22:39:36 <ReinH> They're separate actions.
22:39:58 <sqooq> but both can access the reader values (the counter)
22:40:23 <sqooq> so if I do x then y within the readerT block, the readerT state will transfer into both, but their states will not
22:40:32 <sqooq> I'm pretty confident about this, thanks ReinH
22:40:41 <ReinH> Seems plausible, at least.
22:40:45 <sqooq> wait
22:40:58 <sqooq> ReinH, anyway to extract their state...temporarily (?)
22:41:04 <sqooq> Hold on let me try the words to explain
22:41:08 <sqooq> try to find**
22:41:44 <sqooq> Agh I don't think this will work so easily actually
22:41:49 <sqooq> This is so tricky
22:42:34 <sqooq> in pseudo notation:  (x,y) >> (x,y)    x and y happen, then x happens again using the state from x, y happens again using the state from y
22:42:49 <sqooq> I would need to allow them to transfer back into each other correctly within the ReaderT
22:43:12 <sqooq> maybe this really is a failure, man that would be upsetting. It works so beautifully for the specific case of a single buffer
22:44:55 <sqooq> ok what if I said that the only reason I have this counter is so that I can move it manually
22:45:01 <sqooq> increment it manually. Does that change things?
22:45:57 <sqooq> http://lpaste.net/361995
22:46:30 <sqooq> in pseudo-notation, hopefully you understand those symbols. They just mean the state of x goes back into x, y goes back into y
22:47:39 <sqooq> both x and y uses counter
23:21:01 <hololeap> sqooq: i'm reading what you said again, and it sounds like you have incoming functions that are a "black box" and have a variable number of arguments
23:21:11 <hololeap> is that close?
23:21:43 <sqooq> hololeap, what do you mean by black box?
23:23:03 <hololeap> i mean you don't know what it will be before it arrives, and it could have a different number of arguments each time
23:23:33 <sqooq> no it will have the same aruments I think
23:23:49 <sqooq> but you don't know what it will be becuase i uses the state (unless you know the state)
23:24:21 <hololeap> <hololeap> then you could use a list or some other container for them
23:24:27 <hololeap> <sqooq> that's a bad idea I think
23:24:31 <hololeap> <sqooq> then for each separate computation, it will need to know which index to access the buffer from the list/array
23:25:17 <hololeap> <sqooq> and often these separate computations are exactly the same abstract function
23:25:23 <hololeap> call it "mystery"
23:25:28 <hololeap> x,y, and z may all be calls of mystery with different arguments.
23:27:33 <sqooq> yeah but mystery has 1 argument perhaps
23:27:44 <sqooq> so x <- mystery 0.5; y <- mystery 0.9
23:27:51 <sqooq> increment time
23:28:03 <sqooq> x <- mystery 0.5; y <- mystert 0.1
23:28:32 <sqooq> so the arguments may change after incrementing time, but mystery always takes 1 argument.
23:29:00 <hololeap> well, it might hurt a little, but you could use a Map/IntMap/HashMap to make a way to access a different number of variables each time
23:29:14 <sqooq> hmm?
23:29:26 <sqooq> ok I'll check it out
23:29:38 <sqooq> you dont' mean arguments right?
23:29:50 <sqooq> by variables you're referring to the buffer right?
23:29:59 <hololeap> basically a function that is dynamic in regards to how many buffers it can access
23:30:30 <hololeap> so you could set up an IntMap, for instance, that has 1 -> buf1, 2 -> buf2, etc
23:30:48 <hololeap> and then use the integer keys to call it in a more dynamic way
23:31:49 <hololeap> it would allow you to store a variable number of buffer items, but also give you a quick way to reference each one. it's much more efficiant than a list when choosing arbitrary elements
23:32:32 * hololeap 's spelling is bad tonight
23:34:25 <hololeap> IntSet and IntMap are two of my favorite general-purpose containers. they can solve a lot of problems that aren't immediately obvious.
23:37:23 <sqooq> that sounds very useful
23:37:27 <sqooq> thanks for the recommendation
23:37:31 <sqooq> tomorrow I will check them both out
23:38:17 <hololeap> well, one nice thing is IntSet sorts Ints as you put them in, so you just have to call toList to get an ordered list
23:38:30 <hololeap> but, yeah, they are very useful
23:38:36 <hololeap> also look at Sequence
23:38:40 <hololeap> Seq
23:39:38 <hololeap> all the types i mentioned are in the containers library, part of the base library
23:40:25 <hololeap> and they all use finger trees behind the scenes, which allows them to quickly access inner/rightmost areas as opposed to a list
23:41:06 <sqooq> I've used Sequence before. It's great
23:43:54 <hololeap> btw, Data.Set does the same thing i mentioned (automatically sorting) with any Ord instance, but it's slightly slower. Data.Map can use any Ord instance as the key
23:47:17 <hololeap> you can do things like `Map String Params` if you want to use a String as a key instead of an Int
23:48:24 <hololeap> (actually it would be data Params a = Params {counter :: Int, results :: [a], buffers :: Map String a}
23:48:31 <hololeap> )
