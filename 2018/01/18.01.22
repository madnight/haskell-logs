00:00:10 <ertes-w> ello
00:13:14 <cheater> i'm having fairly big issues figuring out how to bunch up the values of a conduit (eg to 5 elements per item), as well as limiting the amount of things you can have buffered
00:14:40 <Axman6> yield =<< listA5  (,,,,) await await await await await?
00:15:14 <cheater> oh this looks great for the buffer thing https://hackage.haskell.org/package/stm-conduit-3.0.0/docs/Data-Conduit-Async.html#v:buffer
00:15:15 <cocreature> a short search lead to https://hackage.haskell.org/package/stm-conduit-3.0.0/docs/Data-Conduit-Async.html#v:buffer which looks like it does what you’re looking for
00:15:28 <Axman6> ha
00:19:12 <cheater> haha
00:19:13 <cheater> yeah
00:19:54 <cheater> this looks like it implements chunking of some form, but i'm not sure how i would modify it to support any values (and return a tuple of those values) rather than just bytestrings: https://stackoverflow.com/questions/25428065/rechunk-a-conduit-into-larger-chunks-using-combinators
00:20:16 <cheater> s/tuple/list
00:20:34 <cheater> so i'd like to have a conduit that accepts a, and spits out [a] where the lists have 5 successive elements
00:21:02 <cheater> eg [1..20] goes to [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], and so on]
00:21:56 <Axman6> replicateM 5 await >>= yield?
00:22:37 <cocreature> https://hackage.haskell.org/package/conduit-1.2.13/docs/Data-Conduit-List.html#v:chunksOf
00:31:02 <cheater> oh nice, i was looking at the index for 1.0.8 (which the readme on github linked to) and that didn't have chunksOf. i didn't remember to check the latest version. thanks a lot
00:32:41 <cheater> this is really good, thanks
01:17:48 <ertes-w> Axman6: what if the input has 4 items?
01:22:48 <cheater> does Integer overflow? i thought it didn't
01:22:55 <merijn> cheater: No
01:23:09 <merijn> Max size of Integer is basically "however much memory you have"
01:23:15 <EvanR> > (maxBound :: Integer) + 1
01:23:18 <lambdabot>  error:
01:23:18 <lambdabot>      • No instance for (Bounded Integer)
01:23:18 <lambdabot>          arising from a use of ‘maxBound’
01:23:22 <cheater> yeah i see that
01:23:31 <cheater> however, i'm having wraparound somewhere
01:23:44 <ertes-w> cheater: well, on 32-bit systems there is a slight potential for overflow, but that's very unlikely, and i don't know what would happen
01:23:47 <merijn> cheater: You're probably converting somewhere to a bounded type
01:24:02 <merijn> ertes-w: wut? why would Integer overflow on 32, but not 64bit?
01:24:15 <ertes-w> merijn: because the number of limbs is a 32-bit value
01:24:28 <EvanR> would it really overflow
01:24:29 <simon> Integers have limbs?
01:24:39 <EvanR> or UB
01:24:52 <EvanR> or do something saner
01:25:16 <ertes-w> anyway, i'm not sure if it's actually possible to exhaust that…  can a single process actually allocate more than 4 GiB?
01:25:38 <EvanR> on a 32bit computer
01:25:45 <ertes-w> yeah
01:25:48 <EvanR> haha
01:27:10 <EvanR> gmp should have side stepped the issue by using a gmp integer as the size field
01:27:19 <cheater> merijn: i don't think i am
01:27:20 <dexterfoo> can GHC be configured so that Int overflow causes a runtime error?
01:27:24 <cheater> http://lpaste.net/361857
01:27:28 <cheater> check this out
01:28:22 <ertes-w> cheater: where does the overflow happen?
01:28:47 <cocreature> cheater: are you sure that it’s not the shifting that breaks things?
01:28:50 <cheater> i print the Integer in provideOutput
01:29:29 <cheater> hmm cocreature
01:29:42 <cocreature> if you have more than 64 elements that’s not going to work
01:30:01 <cheater> might be yeah
01:31:26 <cocreature> in general if you actually care about overflows, converting to unbounded types as early as possible is usually a good idea
01:33:21 <cocreature> oh even 32 elements are enough to guarantee an overflow in your case
01:33:46 <cocreature> and that assumes the best case that the individual elements are only "1"
01:33:55 <cheater> yeah now we're talking, that was much better
01:34:24 <cheater> cocreature: each input int will just have 2 bits
01:34:29 <cheater> it's 0-3
01:34:53 <cocreature> well then 32 elements are still enough to shift everything out of the range
01:35:14 <cheater> why?
01:35:32 <cocreature> > shift 1 (2^32) :: Int
01:35:35 <cheater> well i guess 64 1's will be out of the range, right?
01:35:35 <lambdabot>  0
01:35:45 <cocreature> eh
01:35:49 <cocreature> > shift 1 (2*32) :: Int
01:35:50 <cheater> right yeah
01:35:53 <lambdabot>  0
01:36:14 <cheater> anyways, i rewrote part with Integer and now it's fine
01:36:16 <cheater> thanks for spotting that
01:39:10 <ertes-w> cheater: style note: shiftedBits = map (\i -> (`shift` i) <$> readTBQueue queue) (take num [0, 2 ..])
01:39:48 <ertes-w> less convoluted, more direct = more readable (at least to me) =)
01:42:05 <parsnip> is cabal global-dependency-caching expected to be default in near releases?
01:52:47 <mlehmk> Why even use Int when you don't want overflows?
01:53:07 <mlehmk> Haskell has unbounded integral type afaik
01:58:21 <merijn> mlehmk: Because lots of APIs want Int
01:58:30 <srhb> What's a good library for allowing a user to input something like a regex that will ultimately be used to filter a list?
01:59:02 <srhb> Input as in on the command-line
02:00:18 <merijn> Not sure there is a good way to do that :p
02:01:09 <srhb> merijn: I mean, I can do something like https://hackage.haskell.org/package/Glob-0.9.1/docs/System-FilePath-Glob.html -- but I'd prefer a more general solution. :-P
02:01:57 <haskellerrr> https://www.youtube.com/watch?v=F8OeEWt0Swg  I come across this haskell video, Can expert check and review that course please
02:03:32 <srhb> I guess I'll just compile a regex from the input.
02:19:20 <cheater> ertes-w: i don't think that's less convoluted
02:19:31 <cheater> ertes-w: it uses several levels of map and different functors at once
02:22:57 <ertes-w> cheater: the outer map is clearly on numbers due to the second argument, and the fmap is clearly on STM due to the readTBQueue right next to it…  even without type context it should be pretty clear, what is what
02:24:08 <ertes-w> cheater: also it's the same layering as in your version, except that it's not split into multiple definitions…  i had to piece those together to even understand what's going on
02:26:04 <ertes-w> i have the same problem with APIs that use type synonyms with good intentions, but ultimately they just make the types harder to follow
02:28:19 <cheater> yeah i'm just a bit tired now to see what's going on :)
02:28:48 <cheater> hey, does anyone know how to use withByteArray to write the byte array into a file handle? https://hackage.haskell.org/package/memory-0.14.6/docs/Data-ByteArray.html#v:withByteArray
02:35:18 <ertes-w> cheater: the easiest way is to convert to a ByteString first
02:35:19 <cheater> oh i can use unpack, nice
02:35:20 <ertes-w> https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Unsafe.html#v:unsafePackCStringFinalizer
02:35:25 <cheater> oh
02:35:53 <ertes-w> then you can use ByteString I,O
02:35:55 <ertes-w> I/O
02:36:23 <cheater> what do i use for the finalizer?
02:36:51 <ertes-w> cheater: pure ()
02:36:59 <cheater> right
02:37:01 <cheater> i thought so
02:37:21 <ertes-w> cheater: which type's withByteArray are you using?
02:44:42 <merijn> ertes-w: Good news for people like you who like *-simple. I'm so fed up that once this paper is out I'm gonna make sure sqlite-simple has a streaming interface for conduit/pipes >.>
02:45:37 <ertes-w> merijn: i suppose i could turn mine into a package and save you the trouble…  it should be fairly easy to convert machines code into conduit/pipes
02:46:55 <ertes-w> at least this particular one, because i'm not using any machines-specific features there i think
02:47:20 <merijn> ertes-w: How'd you do that? sqlite-simple's API doesn't seem to accomodate that right now, since the entire API is IO specific so you can't use e.g. the fold they have
02:48:49 <ertes-w> merijn: prepared statements and 'nextRow'
02:49:41 <merijn> Ah, right
03:12:52 <cheater> ertes-w: https://hackage.haskell.org/package/cryptonite-0.24/docs/Crypto-Hash.html#t:Digest
03:35:18 <cheater> hey is there a way to do cabal run without any output from the building? just have "cabal run" execute the binary once it's done building
03:36:56 <[exa]> cabal install && cabal run ?
03:37:34 <cocreature> or even cleaner "cabal build && cabal exec"
03:59:04 <merijn> cheater: You can filter the output
04:00:15 <merijn> cheater: See the messy string stuff here: https://github.com/haskell-hvr/multi-ghc-travis/blob/master/make_travis_yml_2.hs#L876-L883
04:00:55 <merijn> cabal -vnormal+markoutput will mark all cabal output with a banner, which you can then filter out using sed (see the sed command in the link)
04:02:04 <merijn> Also, if you use "cabal new-run" you don't have to do a separate build first :)
04:04:13 <cocreature> using run over build & exec only to then filter all output from build seems a bit silly
04:05:34 <merijn> cocreature: Depends what usecase
04:08:07 <jchia_> gcc have march and mtune options to control the target architecture. For example, it allows targeting different generations of x86 processors. Is there a similar way to tune ghc output for a particular processor family or particular set of features? If there isn't a way, which generation does ghc target?
04:09:01 <Axman6> I believe the answer to the first quetion is no for the NCG, but yes for llvm, using the same flags you'd usually use with llvm
04:09:29 <merijn> Of course, the llvm backend is a bit finnicky to get working
04:16:18 <jchia_> i'm wondering what happens when i run a ghc-compiled program on a target machine that has an older architecture than the build machine.
04:16:38 <jchia_> i wonder whether it will do wrong things silently
04:17:13 <jchia_> I think if there's an unrecognized machine instruction the program will crash, but maybe there are other issues.
04:17:46 <merijn> jchia_: Should be fine, GHC defaults to standard x86 (as do gcc/clang, afaik) so no fancy architecture specific instructions
04:19:10 <tdammers> IIRC gcc and clang both provide switches to enable nonstandard instructions and/or target specific architectures
04:20:12 <merijn> tdammers: Yes, but that's not default
04:20:53 <tdammers> merijn: yes, indeed. 'safe defaults'
05:01:32 <oo_miguel> how can I get a Character from the ascii code?
05:01:40 <oo_miguel> chr(219) does not work as I expected
05:01:56 <merijn> oo_miguel: 219 is not an ascii code
05:02:24 <merijn> There are only 128 ASCII characters
05:02:41 <oo_miguel> oh right. So how can I Get the Extended ASCII character?
05:02:44 <mauke> how does it work and what did you expect?
05:02:51 <ertes-w> > toEnum 219 :: Char
05:02:55 <lambdabot>  '\219'
05:02:59 <mauke> there is no such thing as "the extended ascii character"; there are dozens of ascii extensions
05:03:16 <merijn> mauke: dozens? that's an optimistically low number
05:04:09 <oo_miguel> ok forget it. I guess I should prefer utf8 ;)
05:04:25 <mauke> utf8 is made of bytes, not characters
05:04:38 <merijn> oo_miguel: What are you *actually* trying to do, because manually converting numbers to Char sounds like a bad idea to do it
05:05:13 <oo_miguel> I just wanted to output a specific character to the console
05:05:26 <oo_miguel> which looks like a "full block"
05:05:26 <mauke> what console, and which character?
05:05:43 <mauke> that would be U+2588
05:06:32 <mauke> > text "\x2588"
05:06:36 <lambdabot>  █
05:07:11 <mauke> > text "\9608"
05:07:11 <oo_miguel> nice
05:07:16 <lambdabot>  █
05:07:34 <ertes-w> > toEnum '\x2588' :: Char
05:07:38 <lambdabot>  error:
05:07:38 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Char’
05:07:38 <lambdabot>      • In the first argument of ‘toEnum’, namely ‘'\x2588'’
05:07:43 <ertes-w> err
05:07:47 <mauke> > chr 9608
05:07:48 <ertes-w> > toEnum 0x2588 :: Char
05:07:51 <lambdabot>  '\9608'
05:07:52 <lambdabot>  '\9608'
05:07:57 <oo_miguel> where do i find "text" ?
05:08:05 <mauke> you don't need it; it's just for lambdabot
05:08:36 <oo_miguel>  > "\9608"
05:08:50 <oo_miguel> > "\9608"
05:08:55 <lambdabot>  "\9608"
05:09:02 <ertes-w> oo_miguel: if this is really only about printing that particular character to stdout, then: putChar '\x2588'
05:09:12 <merijn> The show instance of Char never shows characters like this
05:10:08 <oo_miguel> ok thanks everybody it works fine.
05:10:35 <merijn> hmm "segmentation fault"...that's not what I want my Haskell code to report >.>
05:12:27 <merijn> fg
05:12:38 <mauke> ^Z
05:12:43 <merijn> mauke: :)
05:13:03 <merijn> Window focus is hard! I need an eye tracker for this...
05:14:11 <mauke> everyone knows focus-follows-eyes is the one true setting
05:14:24 <merijn> mauke: We have the technology!
05:15:37 <foldr> Hi, is there such a thing as contravariant comprehensions?
05:17:44 <foldr> Contravariant parallel comprehensions with Divisible would be so nice for Hasql.
05:17:56 <foldr> Because it would automatically choose the correct N for contrazipN.
05:19:45 <insanitymug> > text "\128539"
05:19:48 <lambdabot>  😛
05:19:54 <insanitymug> lambdabot: so rude...
05:24:24 <shramana> is there an existing function to compose two predicates in haskell?
05:24:30 <shramana> i want to do something like:
05:24:34 <shramana> p1 `or'` p2 = \x -> (p1 x) || (p2 x)
05:24:50 <merijn> shramana: You want the monoid instance of functions, combined with the Any newtype
05:25:44 <merijn> :t \l -> getAny . mconcat $ map (Any.) l
05:25:48 <lambdabot> error:
05:25:48 <lambdabot>     • Couldn't match type ‘a -> Any’ with ‘Any’
05:25:48 <lambdabot>       Expected type: [Any]
05:25:52 <merijn> hmmm
05:25:58 <cocreature> liftA2 (||) p1 p2
05:26:33 <merijn> cocreature: mconcat works for any number of predicates, though
05:26:42 <merijn> Even though I messed up my example :p
05:26:54 <shramana> ok i don't know what monoid or Any type is..
05:26:59 <shramana> but i'll look into it
05:27:03 <shramana> thanks a lot
05:27:16 <merijn> shramana: "newtype Any = Any { getAny :: Bool }"
05:27:29 <merijn> > Any True `mappend` Any False
05:27:32 <lambdabot>  Any {getAny = True}
05:27:42 <merijn> shramana: Basically the "or" monoid for Bool
05:28:05 <merijn> shramana: And the monoid instance for functions is "instance Monoid r => Monoid (a -> r)"
05:28:33 <foldr> foldM should work
05:28:46 <merijn> :t \l -> getAny . mconcat (map (Any.) l)
05:28:49 <lambdabot> [a -> Bool] -> a -> Bool
05:28:53 <merijn> There we go
05:28:58 <foldr> :t foldM (liftA2 (||))
05:29:00 <lambdabot> error:
05:29:01 <lambdabot>     • Couldn't match type ‘Bool’ with ‘m Bool’
05:29:01 <lambdabot>       Expected type: Bool -> m Bool -> m Bool
05:30:10 <merijn> shramana: If you can change the type of predicate from Bool to Any you can get rid of the entire ugly wrapping/unwrapping and it just becomes "mconcat listOfPredicateFunctions"
05:36:41 <AWizzArd> When I write Haskell code that makes no explicit use of concurrency libs, code in which I never explicity create new threads etc – will GHC still create code that tries to run on multiple cores?
05:36:54 <merijn> AWizzArd: No
05:37:33 <AWizzArd> I was reading this: „One of the first things I did to GHC in 1997 was to rewrite its runtime system, and a key decision we made at that time was to build concurrency right into the core of the system rather than making it an optional extra or an add-on library.”
05:37:46 <AWizzArd> In Simon Marlow’s book about parallel and concurrent programming in Haskell.
05:37:46 <shramana> merijn: i need some time to teach myself what monoids are.. thanks for the help
05:37:57 <cocreature> it will try to run GC in parallel by if you use "+RTS -N" but that’s about it
05:38:09 <merijn> AWizzArd: The tools are built-in to the core, yes
05:38:11 <AWizzArd> merijn: I misinterpreted that statement.
05:38:24 <AWizzArd> merijn: okay, thx for clearing this up.
05:38:35 <merijn> AWizzArd: The runtime has a lot of built-in support for things like pure parallelism, etc. builtin
05:38:41 <sr10> can we write if statement inside map?
05:38:53 <sr10> *conditions
05:38:54 <merijn> AWizzArd: But auto-parallelising is impossibly hard to do, so you still have to explicitly use those tools
05:39:09 <infinisil> sr10: yes, show the code you have trouble with
05:39:27 <sr10> validSubjects score validsubject studentname  = foldl' (\subMarksList x ->
05:39:28 <sr10>                                                 if (fst (validateMarksSubjects score validsubject studentname (fst x)))== True
05:39:28 <sr10>                                                       then subMarksList ++ [(fst x,snd x)]
05:39:28 <sr10>                                                 else subMarksList) [] (head (map (snd) (filter(\x -> (fst x) == studentname) score) ) )
05:40:15 <infinisil> sr10: um, can you minimize this a bit to the essential part of your question?
05:40:38 <metahumor_aw> sr10: you don't have to write (== True) in your condition for the if btw
05:40:47 <geekosaur> also consider a paste site so it's not interleaved with random stuff
05:40:48 <sr10> validsubjects = [String] studentname = String score = [(String,[(String,Int)])]
05:40:50 <geekosaur> @paste
05:40:50 <lambdabot> Haskell pastebin: http://lpaste.net/
05:43:21 <metahumor> sr10: your lambda variables are also probably in the wrong order for "foldl'"
05:44:09 <metahumor> sr10: if you are going to do "++ [(fst x, snd x)]", then x :: (a,b), so why not do "++ [x]"?
05:44:54 <metahumor> sr10: and if you are going to do that many times, it's way faster to do "x :", that way you don't incur an O(n) cost to append each time you want to append
05:46:01 <sr10> score=[ ("Mojo", [("English", 84), ("Chemisty", 80), ("Physics", 95), ("Geography", 75)])
05:46:02 <sr10>     , ("John Doe", [("Chemisty", 80), ("Physics", 95), ("Geography", 75)])
05:46:02 <sr10>     , ("Captain Jack", [("Chemisty", 66), ("Phsyics", 33), ("Geography", 56)])
05:46:02 <sr10>     , ("John Doe", [("Chemisty", 90), ("Economics", 45), ("Geography", 56)])
05:46:02 <sr10>     , ("Bahubali", [("Hindi", 45), ("Biology", -90), ("Geography", -75)])
05:46:03 <sr10>     , ("Dexter", [("Tamil", 110), ("Biology", 100), ("Geography", 100)])
05:46:04 <sr10>     ]
05:46:06 <sr10> validsubject = ["English", "Geography", "Physics", "Chemistry", "Economics", "Computer Science"]
05:46:10 <sr10> validSubjects score validsubject "Mojo"
05:46:12 <sr10> [("English",84),("Physics",95),("Geography",75)]   ---> output
05:46:14 <sr10> validSubjects score validsubject "John Doe"
05:46:15 <metahumor> sr10: try the lpaste site please?
05:46:16 <sr10> [("Physics",95),("Geography",75)]			---> output
05:46:20 <merijn> sr10: Don't paste code here
05:46:27 <sr10> oh okay
05:46:29 <sr10> sorry
05:46:34 <sr10> im new to this
05:49:05 <sr10> http://lpaste.net/361864
05:55:22 <infinisil> and there he goes
05:55:35 <metahumor> he's gone...
05:56:04 <metahumor> i have quits and joins filtered out, so i rely on tab-completion...
05:56:17 <slevin> anyone using arch linux and know the best to install haskell, nowadays? do i install packages through pacman, stack or cabal?
05:56:34 <infinisil> metahumor: i see quits and joins only from recently active nicks, quiet useful
05:56:59 <merijn> slevin: I recommend never using the system package manager for haskell packages (on any linux distro)
05:57:08 <merijn> slevin: stack vs cabal depends on what you're using
05:57:13 <infinisil> merijn: NixOS would like a word with you
05:57:13 <metahumor> infinisil: do you have a way to set that up for irssi?
05:57:31 <metahumor> sr10: do you have a defn for validateMarksSubjects?
05:57:35 <JuanDaugherty> i look at the list of users in xchat
05:57:47 <exio4> metahumor: I don't know about irssi, but weechat has a built-in smart filter for this
05:57:50 <infinisil> metahumor: (really offtopic for #haskell)
05:58:14 <slevin> merijn: alright, thanks. could you elaborate on the choice between cabal and stack?
05:58:48 <merijn> slevin: Not really, beyond "stack doesn't match my workflow, so it annoys the shit outta me"
05:58:50 <hydraz> sr10: instead of having a list of valid subject strings, make a subject type, like `data Subject = Maths | Physics | ...`
05:59:10 <metahumor> hydraz: it seems he is trying to validate strings
05:59:20 <metahumor> hydraz: as in "Phsyics" won't match
05:59:36 <hydraz> ah, znc ate my backlog
05:59:38 <merijn> slevin: Although, if you do end up not using stack, I'd recommend manually installing a GHC bindist and then compiling cabal yourself as install method. Since it's by far the most portable/reliable way to setup a haskell environment in my experience
05:59:41 <hydraz> sorry :x
05:59:48 <metahumor> hydraz: he didn't say so, i'm just guessing
05:59:49 <sr10> validateMarksSubject give me (True,"vaid subject") or (False,"invalid")
06:00:10 <hydraz> Still, I recommend your validateMarksSubject be String -> Maybe Subject
06:00:22 <metahumor> agreed
06:00:35 <metahumor> sr10: hydraz has a good suggestion for you for writing idiomatic Haskell
06:00:37 <merijn> slevin: i.e. the process is identical on any *nix variant I've used (FreeBSD, macOS, linux, etc.), doesn't require root, and doesn't suffer from random "maintainer breaks shit" occurences like Arch's Haskell setup
06:01:08 <sr10> yes okay
06:01:11 <slevin> merijn: understood. i dont have much experience with stack, so i think ill try it out and see
06:02:26 <slevin> merijn: i dont know if you use arch linux yourself, but there is the possibility of installing `cabal-static` or `cabal-bin` as an alternative to `cabal`, which avoids having dozens of haskell-* dependencies. have you tried this?
06:03:19 <merijn> slevin: I don't use arch, and as I said, I just install bindists, since in my experience it's by far the most reliable method
06:03:49 <metahumor> @tell sr10 if i understand correctly, your validSubjects can be written as "validSubjects sore validsubject studentname = filter (validateMarksSubjects score validsubject studentname . fst) . snd . head . filter ((== studentname) . fst) $ score
06:03:49 <lambdabot> Consider it noted.
06:04:06 <slevin> merijn: thanks
06:04:24 <infinisil> metahumor: i wouldn't even bother helping people that can't properly ask a question imo
06:04:49 <metahumor> maybe giving an answer that they don't totally get will help them rephrase their question more clearly
06:06:09 <metahumor> let's say he had phrased it clearly, do you think introducing Map would have been appropriate? in instances of such questions (where Haskell is being used unidiomatically), how much new material should be mentioned?
06:06:15 <metahumor> #meta-haskell-beginners
06:12:45 * infinisil nods
06:39:02 <joel135> Can I tell the version of ghci from within a ghci session using :...?
06:40:53 <joel135> I want to know what version of ghci interactive-haskell (emacs) uses.
06:48:02 <verement> joel135: maybe something like :! $_ --version
06:48:28 <metahumor> that gives my bash version for me
06:48:59 <verement> oh hmm
06:49:32 <metahumor> :! stack ghci --ghci-options="--version"
06:49:37 <metahumor> is what works on my machine
06:49:39 <ertes-w> joel135: :m +System.Info
06:49:45 <ertes-w> joel135: compilerVersion
06:50:01 <joel135> Version {versionBranch = [8,0], versionTags = []
06:50:33 <ertes-w> in almost all situations the base library is tightly coupled with the compiler, so this method is fairly reliable
06:51:19 <joel135> I am having some troubles with libraries so maybe it isn't as reliable in this case.
06:52:02 <geekosaur> ghci version would not help you there then
06:52:26 <joel135> In a terminal ghci I get [8,2] instead.
06:53:20 <metahumor> it probably depends on how your emacs is invoking ghci, using just "ghci" or "stack ghci" or something else
06:53:34 <geekosaur> or just a different $PATH
06:53:46 <geekosaur> terminal: echo $PATH
06:53:58 <geekosaur> emacs: M-: exec-path RET
06:54:16 <geekosaur> ...although that might not help if there's a customize-variable in effect
06:55:49 <joel135> they are similar but emacs has an extra entry https://pastebin.com/d4SB9fGp
06:57:45 <geekosaur> then I guess it's a customize somewhere. including possibly configuring it for stack, if that is installed
06:58:35 <joel135> There is a .cabal file in my project so I guess cabal *should* be choosing the binaries.
06:59:16 <geekosaur> no? emacs has an annoying tendency to do its own thing
07:01:09 <ertes-w> joel135: are you using regular haskell-mode?
07:04:26 <joel135> ertes-w: yes
07:04:46 <joel135> it says (Haskell) and the repl says (Interactive-Haskell)
07:06:01 <joel135> i just now tried uninstalling stack and the result was that i got different errors when loading my .hs file
07:06:35 <joel135> so apparently emacs is using stack rather than cabal in the present configuration
07:08:09 <ertes-w> joel135: it depends on the haskell-process-type setting
07:08:38 <ertes-w> i think it's auto by default, which means it chooses plain GHCi vs. cabal vs. stack depending on some heuristics
07:10:31 <joel135> without stack installing, i get "Symbol's value as variable is void: haskell-mode-map" from just having "(define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)" in my .emacs
07:10:36 <joel135> installed*
07:12:08 <joel135> with just "(custom-set-variables  '(haskell-process-type 'cabal-repl))" there appears to be some progress.
07:13:35 <joel135> when i load my .hs file *cabal* now crashes https://pastebin.com/g8yyRfLr
07:14:29 <kadoban> I would call that erroring out more than crashing
07:14:36 <kadoban> Though I don't understand that error message per se
07:20:09 <mmx> Does anyone have an idea for use-cases besides (debug-) logging where you'd want to do IO/mutation/effects in an otherwise pure function? (i.e. in that it does something that is not reflected in the return value, other than the fact that it does IO).
07:21:10 <kadoban> Caching, imperative algorithms to generate a result, etc.
07:21:28 <infinisil> mmx: malicious code
07:23:51 <infinisil> That's actually something that worries me: how can i be sure that my id :: a -> a doesn't launch nuclear weapons with unsafePerformIO ?
07:24:54 <mmx> Yess caching is a perfect example.. should've thought about that myself :p
07:25:28 <exio4> I think ST handles most of it
07:25:35 <verement> mmx: FFI calls that are essentially pure
07:28:08 <mmx> @infinisil that would indeed be malicious code.. but then again you trusted it enough to compile it. If its injected into memory, then all bets are off (no compiler to protect you there)
07:28:08 <lambdabot> Unknown command, try @list
07:29:39 <merijn> infinisil: Look up SafeHaskell
07:29:54 <ertes-w> mmx: i often use State/StateT in pure code
07:29:57 <merijn> infinisil: SafeHaskell bans use of unsafeX in untrusted modules
07:30:01 <ertes-w> mmx: and of course Maybe and Either
07:31:27 <infinisil> merijn: nice
07:32:22 <infinisil> I honestly don't think caching should be pure at all, so i prefer StateT or ST
07:32:43 <joel135> In what sense does https://pastebin.com/2jqp4KMx have multiple targets?
07:33:32 <joel135> What are the targets in this case?
07:33:39 <monochrom> The library is one target. The exe is another target.
07:33:42 <Tehnix> Does anyone have any resources on how one would limit effects using MTL-style classes? I'm trying to compare the usage to `Free`/`Freer`-style, to see what suits me best
07:34:31 <ertes-w> Tehnix: c :: (MonadState S m, Alternative m) => m ()
07:34:44 <ertes-w> Tehnix: this action can only do state operations and choice
07:36:54 <Tehnix> Hmm, I guess my question is then more oriented towards how one would sorta divide up `IO` capabilities. Like, being able to read a file, without giving access to `IO` entirely
07:38:29 <insanitymug> Tehnix: with something like https://github.com/IxpertaSolutions/freer-effects you can go crazy with granularity
07:39:36 <insanitymug> but that one is not really well maintained
07:40:06 <insanitymug> I mention it just because I used it in past
07:44:12 <sr10> http://lpaste.net/361867 i want to use map instead of foldl' for validSubjects, invalidSubjects, allStudentsForExam
07:49:26 <joel135> This is my haskell process log: https://pastebin.com/CviM86m5
07:50:10 <infinisil> sr10: check out the filter function
07:50:24 <orion> What would Haskell look like if it had parametrically polymorphic functions, but not parametricity?
07:50:53 <joel135> These are the messages: https://pastebin.com/nzGyEMNC
07:51:28 <joel135> It doesn't make sense to me.
07:52:06 <infinisil> @paste
07:52:06 <lambdabot> Haskell pastebin: http://lpaste.net/
07:52:52 <infinisil> joel135: use that instead in the future, pastebin is not well received here (or in any channel really)
07:52:56 <Athas> orion: like C#?
07:53:01 <Athas> Doesn't C# have something like that?
07:53:03 <joel135> hm ok
07:53:21 <Athas> C++ has too, if you squint a bit, treat pointers as type variables, and use dynamic_cast.
07:53:56 <Athas> In principle, I think 'seq' violates parametricity, but I'm not sure.
07:54:43 <orion> I am trying to understand parametricity better, so I ask: What would I be unable to express in Haskell without parametricity? What is an example of a statement that is polymorphic, but not parametric?
07:55:12 <Tehnix> @insanitymug: I've already toyed with `freer-simple`, which seems to be a fork of `freer-effects`, which in turn was a fork of the original. My question was more related to how one would mimic the same control of effects in MTL
07:55:12 <lambdabot> Unknown command, try @list
07:55:17 <Athas> if typeof(x) == Int then 0 else 1
07:55:23 <Athas> (If Haskell supported typeof().)
07:57:32 <joel135> haskell supports ad-hoc polymorphism, which is opposite to parametric polymorphism, in the form of typeclasses.
07:57:43 <Tehnix> insanitymug: Currently I can only find a way to either go 100% pure, or 100% in `IO` (on the concrete typeclass instances), but no way to go "just some IO operations, but not all"
07:57:44 <joel135> correct me if i am wrong.
07:58:36 <Tehnix> orion: like `id :: a -&gt; a` is polymorphic, but not parametric, compared to `print :: Show a =&gt; a -&gt; IO ()`?
07:59:16 <quchen> id is parametric (in the type parameter a) but not polymorphic.
07:59:29 <quchen> \x -> x is polymorphic, because it has a parametric type.
08:00:17 <orion> First I read: "`id :: a -&gt; a` is polymorphic", then I read, "id is parametric (in the type parameter a) but not polymorphic" and now I am confused because these two statements seem to contradict one another.
08:00:31 <coronakirby> id = \x -> x, how does this work then?
08:01:10 <quchen> id’s type is parametric, it’s value is polymorphic.
08:01:14 <Tehnix> orion: Sorry, my mix up. The correct term for the `print` one is ad hoc polymorphism
08:01:14 <infinisil> Tehnix: write a class (MyIO m) with functions like `putStrLn :: String -> m ()`, then make IO instance of it, and constrain your types to (MyIO m, ...) => ... -> m ()
08:02:18 <infinisil> also allows for testing stuff easier actually
08:02:32 <Tehnix> infinisil: ah, that would make sense!
08:02:33 <quchen> A »polymorphic type« is usually called »polykinded« in Haskell jargon.
08:03:39 <quchen> Const :: k -> * -> k -- polykinded.
08:03:54 <quchen> More explicitly, Const :: forall k. k -> * -> k
08:04:06 <Tehnix> orion: I think <https://wiki.haskell.org/Polymorphism> has a good overview of the differences
08:04:24 <orion> quchen: If `id` is parametric but not polymorphic, what is polymorphic but not parametric?
08:05:14 <quchen> If you want to make the distinction, it’s important to say which level you’re talking to. Usually, values are polymorphic, and types are parametric.
08:05:27 <quchen> s/to/about/
08:05:31 <orion> Ah, ok. That is helpful information.
08:05:58 <joel135> help please http://lpaste.net/1140244650934665216
08:06:10 <orion> quchen: Is it correct to consider functions as values?
08:06:11 <quchen> In other type systems the distinction isn’t necessarily that easy and I tend to mix up the levels a lot. But in Haskell, we mostly just have values, sometimes types, and rarely kinds, and then it ends for everyday programming.
08:06:26 <quchen> orion: Sure.
08:06:41 <quchen> orion: You can picture functions as things that have the lambda as their only constructor.
08:06:42 <joel135> that's what happens when i load my .hs file
08:06:43 <Hafydd> Sometimes types?!
08:07:06 <kadoban> joel135: That Ok message split onto two lines sure looks weird. No idea what that means though.
08:07:19 <quchen> Yes, sometimes types.
08:07:40 <Hafydd> At what times do you not have types?
08:07:47 <coronakirby> by sometimes types, you mean like, type level functions right?
08:08:01 <butterthebuddha> I'm trying to implement rightApply as an exercise, but I don't quite understand how it works
08:08:29 <quchen> I meant »sometimes« as in »time spent writing«. Most programs are written on the value level, some programs use type level stuff.
08:08:43 <Hafydd> I see.
08:08:44 <quchen> And few worry about kinds.
08:08:51 <quchen> All of them are always there of course.
08:08:56 <Hafydd> »_«
08:09:51 <coronakirby> dependent kinds when
08:10:41 <quchen> butterthebuddha: What’s rightApply?
08:10:53 <butterthebuddha> quchen (*>)
08:11:04 <quchen> Oh. For which Applicative?
08:11:28 <quchen> And I’m assuming you don’t want to use <*> for the definition of *>?
08:11:46 <coronakirby> isn't *> just \a b -> b <$> fa <*> fb
08:12:01 <cemerick> I would like to have three "profiles" in my project's cabal file: a library of common bits, an executable, and a test-suite. Do I really need to repeat all of the build-depends in each of their configurations?
08:12:03 <butterthebuddha> quchen: I don't actually understand how *> works. And for applicative, yes
08:12:13 <butterthebuddha> But I have nothing against using <*>?
08:12:44 <coronakirby> applicative lets you lift multiple arity functions over multiple functors
08:13:06 <coronakirby> so if you can do that, you can have a function that ignores the results of some of the functors
08:15:00 <butterthebuddha> coronakirby: Right, but like I said I'm not actually sure what *> is supposed to do in general
08:15:56 <coronakirby> well I like to think of functors as "programs", so if you have 2 programs, fa, and fb, then fa *> fb runs both ""in parallel"" and returns the result of the 2nd one
08:16:05 <coronakirby> as opposed to >> which does fa and then fb
08:16:10 <coronakirby> (once again, conceptually speaking)
08:17:07 <tmciver> cemerick: I believe the usual convention is to have your library contain most of the deps and then have the executable and test suite depend only on the library.  But, yes, if the executable and test suite need dependencies that the library also has, then I believe you do need to list them again. It's a common complaint of cabal.
08:17:51 <quchen> butterthebuddha: Well, *> simply ignores the value generated by the left argument (but still runs its effects)
08:18:00 <quchen> ?src (*>)
08:18:00 <lambdabot> (*>) = liftA2 (const id)
08:18:22 <butterthebuddha> What's the "effect" of a List tho
08:18:27 <quchen> f *> g = pure () <$> f <*> g
08:18:36 <coronakirby> program with many possible return values
08:18:54 <butterthebuddha> Also, just giving me the answer isn't helpful :/
08:18:56 <coronakirby> so (,) <$> la <*> lb, returns all possible return values
08:18:59 <cemerick> tmciver: Ah, so if I don't actually refer to one of my libraries' dependencies from e.g. a testing module, then I don't need to re-list it in the test package's build-depends?
08:19:07 <joel135> http://lpaste.net/361869
08:19:46 <quchen> butterthebuddha: The effect of a list value is iterating over all of its elements in order.
08:19:50 <joel135> i have tried following https://wiki.archlinux.org/index.php/haskell#Problems_with_linking but that doesn't solve things
08:20:27 <quchen> butterthebuddha: So [1,2,3] *> [4,5,6] gives you [4,5,6] for the »1« in the first list, another 4,5,6 for the 2, another 4,5,6 for the 3.
08:20:34 <quchen> > [1,2,3] *> [4,5,6]
08:20:36 <joel135> how can there be files missing in the base package??
08:20:38 <lambdabot>  [4,5,6,4,5,6,4,5,6]
08:20:55 <cocreature> joel135: which haskell-related packages have you installed via pacman?
08:21:16 <butterthebuddha> I guess, my next question is what does "calling" an applicative look like in general?
08:21:38 <quchen> I’m not sure what you mean with »calling« here :-(
08:22:02 <joel135> cocreature: http://lpaste.net/6339169813893480448
08:22:03 <butterthebuddha> I guess, "calling" a list would be iterating over the values of a list
08:22:05 <quchen> Are you familiar with list comprehensions? You can write *> with one
08:22:26 <quchen> I think calling is misleading here, it sounds like you’re running a function or something. Maybe you mean »performing«?
08:22:33 <butterthebuddha> Sure
08:22:45 <quchen> We sometimes say »performing an action« for »running an Applicative value«
08:24:05 <cocreature> joel135: I recommend to follow the approach described under "Static linking" which entails removing all Haskell related packages that you installed via pacman except for ghc, ghc-libs and ghc-static
08:24:46 <quchen> butterthebuddha: fs <*> xs = [ f x | f <- fs; x <- xs ]. The point of *> is ignoring the »f«s, so try coming up with something that doesn’t use the »f«.
08:24:48 <tmciver> cemerick: correct
08:25:46 <cemerick> tmciver: thank you, I can live with this :-)
08:26:24 <joel135> cocreature: ok
08:29:53 <tmciver> I'm trying to use GHC's pre-processing capabilities described here: https://downloads.haskell.org/~ghc/master/users-guide/phases.html#options-affecting-a-haskell-pre-processor but I get a compile error that a module cannot be found. This module's name is a module that is a part of the pre-processing executable that I'm listing but I was under the impression that I could specify any old executable - one no
08:29:59 <tmciver> t related to Haskell at all. Why do I get this error?
08:30:40 <geekosaur> can you show an example?
08:31:49 <stphrolland> Hi. I have switched to nixos from ubuntu some weeks ago. I'm not yet accustomed to the nix way of doing haskell. For example, it seems each time I invoke `stack --nix build` that my stack.yaml is re-initialised, and my modiciation on it (namely additionnal dependencies) are removed, thus the mini project won't compile. Does it remind you something, for those of you using nixos.
08:32:44 <joel135> cocreature: where do i get cabal?
08:33:10 <siwica`> What is the most elegant way to write a function `foo :: [Bool] -> [a] -> [a]` or `bar :: [(a -> Bool)] -> [a] -> [a]` that takes a list of Bools/predicates and filters those elements from a second list for which the respective index in the first list is True/ the predicate returns True?
08:33:53 <coronakirby> I'd use some kind of zip, instead of working with int indices
08:34:00 <siwica`> For lists of different lenghts, the function should behave like zip
08:34:12 <insanitymug> Tehnix: soemthing like would work http://lpaste.net/361870 ?
08:34:33 <glguy> :t \xs ys -> [ y | (x,y) <- zip xs ys, x ]
08:34:36 <lambdabot> [Bool] -> [a] -> [a]
08:34:38 <lyxia> :t \bs as -> [a | (True, a) <- zip bs as]
08:34:41 <lambdabot> [Bool] -> [a] -> [a]
08:34:48 <cocreature> joel135: you could either try the bootstrap script bundled with cabal, use stack to build it (you can remove stack after that) or find someone who has a statically linked binary and ask them to send it to you
08:36:18 <ReinH> :t map snd . filter fst
08:36:21 <lambdabot> [(Bool, b)] -> [b]
08:37:03 <tmciver> geekosaur: Here's where I specify the pre-processor: https://github.com/tmciver/kaletest/blob/master/src/Lib.hs and here's the error I see: http://lpaste.net/361871
08:37:04 <insanitymug> Tehnix: it is something like infinisil suggested
08:38:16 <coronakirby> :t \fs xs -> [x | (f, x) <- zip fs xs, f x]
08:38:18 <lambdabot> [a -> Bool] -> [a] -> [a]
08:38:45 <geekosaur> was afraid of that. I think stack is treating it as a script
08:39:07 <siwica`> ok, thanks! Didn't think of list comprehensions
08:39:11 <geekosaur> or, you have things aset up to confuse it so that it is finding the source instead of the executable
08:39:27 <geekosaur> (stack can be ... easy to confuse if you don;t do things its way)
08:39:32 <unclechu> hey guys, i have two type-families, and one of them is a helper for another, is there kinda `where` section for type-famlies to isolate scope of a helper?
08:39:46 <siwica`> ReinH: elegant!
08:39:56 <geekosaur> but this looks to me like it's doing runghc on the source, without the right stack package environment
08:40:03 <coronakirby> :t ((map snd . filter (uncurry ($))) .) . zip
08:40:06 <lambdabot> [b -> Bool] -> [b] -> [b]
08:40:10 <coronakirby> 8^)
08:41:08 <geekosaur> hm, on second thought that doesn't actually make much sense, the error should be relative to the helperin that case
08:41:15 <tmciver> geekosaur: You're saying that stack and not GHC is running the pre-processor using runghc
08:41:16 <geekosaur> maybe this is stack misparsing things?
08:41:33 <geekosaur> I think  stack has to know what's going on with OPTIONS_GHC for things to work right
08:41:56 <lyxia> unclechu: nope
08:42:02 <geekosaur> and ... since the error location is the OPTIONS_GHC pragma, this makes me think stack did something wrong/confusing here.
08:42:14 <geekosaur> might try it with some -v option
08:42:38 <tmciver> geekosaur: This is based on example code in the Kale repo here: https://github.com/parsonsmatt/kale/blob/master/example/src/Lib.hs
08:42:50 <unclechu> lyxia: okay, thanks for the info
08:43:13 <geekosaur> right
08:43:40 <tmciver> Perhaps my `kaletest` repo should not have a dep on Kale at all . . .
08:44:05 <geekosaur> the only other thing I can think of is that kale-discover is outputting a reference to that mofdule --- note that,w ith this setup, it is relying on the preprocessor to generate effectively the whole source file on the fly!
08:44:24 <tmciver> geekosaur: that's right
08:45:21 <geekosaur> right, so from the build log, seems like it does not have or is for some reason ignoring a lib dependency
08:45:30 <joel135> cocreature: i am trying stack to build it, do you understand the messages? http://lpaste.net/361872
08:45:59 <geekosaur> and again you probably need someone who understands stack better
08:46:21 <stphrolland> Any idea where I should start troubleshooting so as to understand why `stack --nix build` is modifying my cabal file back to original ?
08:46:28 <tmciver> geekosaur: Thanks for the help.
08:46:39 <glguy> stphrolland: It will stop that if you delete the package.yaml file
08:46:45 <glguy> which is used to generate the initial cabal file
08:46:47 <geekosaur> stphrolland,you are using a recent stack and have a project.yaml
08:46:52 <geekosaur> er package, yes
08:47:17 <geekosaur> joel135, you are on arch, yes?
08:47:21 <glguy> stphrolland: Also, you probably need to upgrade your stack. latest is 1.6.3
08:47:22 <joel135> yes
08:47:31 <cocreature> joel135: add "ghc-build: nopie" to ~/.stack/config.yaml and install ncurses5-compat-libs
08:47:36 <geekosaur> ^]
08:47:38 <geekosaur> er
08:47:42 <geekosaur> well, that
08:48:34 <geekosaur> except this already says it;s a nopie build, so that can;t be it
08:49:15 <cocreature> the ncurses5 nopie build seems to work on arch for some reason
08:50:24 <geekosaur> also how does this even get this far and then that error configuring network
08:50:40 <geekosaur> I have a feeling this is *nix* misconfiguration somehow
08:50:44 <cocreature> I think it only happens on packages with custom setups or something like that
08:50:48 <geekosaur> msiismatched with Arch native stuff
08:51:35 <joel135> cocreature: where should ghc-build: nopie be added?
08:51:41 <geekosaur> or possibly needing that nix workaround where it doesn't include the nix versions of e.g. zlib in the  derivation, so it ends up building a mismatch of system and nix stuff and is hosed
08:51:51 <cocreature> joel135: I already told you where you need to add it :)
08:52:09 <joel135> at the very end unindented?
08:52:09 <geekosaur> joel135, belay that unless you want to also remove --system-ghc and have to start over from scratch
08:52:19 <cocreature> yes, just add a new line
08:52:26 <geekosaur> or, just b ull on through
08:52:39 <geekosaur> where it will be ignored because of --system-ghc
08:52:41 <cocreature> it seems to ignore the --system-ghc option anyway for some reason
08:52:59 <geekosaur> oh, guess it does say it's doing that
08:53:09 <geekosaur> but this should still nto be that problem
08:53:28 <geekosaur> still think this is the nix C lib dependencies in Haskell derivations issue
08:53:38 <joel135> i would be happy to do anything, trying nopie now
08:53:39 <geekosaur> but, go nuts
08:54:08 <cocreature> geekosaur: I’ve stopped trying to figure out what’s going on at some point and just stick to what’s working for me :/
08:54:09 <geekosaur> (specifically this error *in zlib* is the most common symptom of it)
08:54:11 <stph__> Sorry, it seems my IRC client is deaf, I ask again my question here on Freenode where there's obvious activity. `stack --nix build` is always re-intialising my project.cabal to the state it was before adding my needed additionnal dependencies. Any idea why ? Sorry if you already answered, I could not read.
08:54:14 <geekosaur> yes, and you use nix?
08:54:34 <cocreature> no I use arch + cabal and arch + stack using the line I posted above
08:54:38 <geekosaur> fine
08:54:44 <geekosaur> never mind, point ignored and list
08:54:46 <geekosaur> have fun
08:55:21 <cocreature> joel135: if you’re happy with running binaries built by strangers on the internet, I can upload my cabal binary
08:55:22 <glguy> stph__: You have to delete the package.yaml once the initial .cabal file is generated
08:55:54 <joel135> cocreature: sure, if this doesn't work let's do that
08:56:09 <joel135> this = stack install --system-ghc cabal-install
08:58:18 <cocreature> joel135: http://purelyfunctional.org/downloads/cabal
09:02:24 <joel135> wow, i can install packages with cabal now! :D (using the $this method)
09:02:45 <stph__> glguy: but if I remove the stack.yaml file, then stack build no longer use the resolver 9.14 I had set with stack new myproject --nix --resolver lts-9.14 ...
09:03:14 <geekosaur> not stack.yaml, package.yaml
09:10:53 <stph__> geekosaur: thanks, that was it.
09:14:25 <jacobian> Curious if people here use haskell for simple matrix / vector / linear algebra experiments - currently using numpy and I'm curious about the difference in boilerplate
09:15:44 <coronakirby> I know that there's blas bindings
09:16:42 <cocreature> there’s also the "hmatrix" package
09:16:44 <kuribas> jacobian: the language itself is great, but the libraries not so.  There is a lack of unified datastructures.
09:19:15 <kuribas> jacobian: although if you just need basic operations, there are many possibilities.
09:19:34 <joel135> trying to install leksah from source http://lpaste.net/1328638727039221760
09:20:32 <kuribas> jacobian: though there is this: http://www.datahaskell.org/
09:25:11 <butterthebuddha> I don't understand the type of const id :/
09:25:34 <geekosaur> joel135, looks like missing constraints on gi-gtksource and/or gi-gtk-hs, incompatible with the haskell-gi-base required by leksah
09:26:27 <joel135> geekosaur: i don't understand
09:27:20 <jacobian> kuribas, cheers, thanks
09:27:27 <joel135> is there something i can do?
09:27:35 <kuribas> :t const id
09:27:37 <lambdabot> b -> a -> a
09:27:38 <geekosaur> I don;t see that version of leksah on hackage
09:28:34 <shapr> butterthebuddha: how would you describe const?
09:28:39 <joel135> i downloaded it from github
09:28:44 <shapr> @src const
09:28:44 <lambdabot> const x _ = x
09:28:44 <joel135> geekosaur: ^
09:29:04 <insanitymug> @dst const
09:29:04 <lambdabot> Maybe you meant: msg list let do ask
09:29:27 <shapr> :t id
09:29:27 <butterthebuddha> shapr: returns a function that always returns a constant regardless of it's input?
09:29:29 <lambdabot> a -> a
09:29:35 <joel135> geekosaur: the aur package is out of date
09:29:49 <shapr> butterthebuddha: ok, so what is the constant that "const id" returns?
09:30:02 <geekosaur> since it's not on hackage, I would be inclined to think there is a reason
09:30:06 <butterthebuddha> Ah, I realize now
09:30:15 <butterthebuddha> shapr: Sorry, it's been a rough morning
09:30:21 <shapr> butterthebuddha: no worries, I get those too
09:30:24 <shapr> rather often
09:31:56 <joel135> i am surprised no one is talking about this issue in forums etc
09:32:14 <geekosaur> I doubt most people try to build out of git
09:33:39 <joel135> but is there an alternative to doing that?
09:34:22 <geekosaur> hackage? which will be the older version, which as I said is probably the currently released one for a reason
09:34:32 <geekosaur> I am looking at its issue trcker now and there's several such build issues
09:35:21 <joel135> some of its dependencies are broken
09:37:01 <geekosaur> at this point all I can suggest si that you file an issue on their github
09:37:12 <geekosaur> because I am not in a position to be your developer.
09:37:45 <geekosaur> yes, I know the current hotness is anyone should be able to install any dev version of anything and it magically always just works,. except with complex projects, that's highly unlikely
09:39:25 <joel135> ok
09:39:35 <joel135> i'll try atom instead
09:39:42 <heptahedron> joel135: Have you ever tried emacs?
09:39:53 <heptahedron> joel135: It's got a pretty good Haskell experience imo
09:40:05 <joel135> heptahedron: that's what i am fleeing from
09:40:11 <heptahedron> joel135: whoops
09:40:35 <glguy> Fleeing from a good Haskell experience?
09:41:14 <joel135> it is the worst, but maybe it isn't the emacs plugin's fault, i just don't know what is happening
09:42:17 <heptahedron> joel135: what appears to be the issue
09:43:07 <joel135> i have this school haskell project i am working on
09:43:36 <joel135> i can't load it, as libraries don't load as they should i think
09:43:50 <joel135> like 'Failed to load interface for ‘Graphics.HGL’'
09:44:17 <orion> A lot of people want deterministic builds. What is the main obstacle to this in GHC?
09:44:18 <shapr> is your school project on github? It sounds like the package may not be listed in your cabal file
09:44:25 <heptahedron> FPComplete's article on exception best practices points out an issue in composability of error types when using ErrorT--are there any proposed solutions to this problem? It seems like the Freer approach, with open unions, might benefit a lot here, right?
09:45:14 <tommd> orion: The main issue was people using old compilers, I thought.
09:45:33 <heptahedron> joel135: I don't think a new editor will help you fix a library issue necessarily, unless somehow you have experienced success using a different one already?
09:45:38 <tommd> As in, new-build depends on deterministic builds.
09:45:45 <heptahedron> joel135: Can you give us more information about the project config?
09:45:49 <joel135> shapr: we have to make our repo private but here is the cabal file http://lpaste.net/6515271349999501312
09:46:00 <orion> tommd: Oh, so the functionality already exists.
09:46:18 <joel135> heptahedron: ^
09:46:37 <dmj`> butterthebuddha: flip (const id) == const
09:47:04 <shapr> joel135: how do you build / run the project?
09:47:33 <joel135> (i can upload a zip somewhere and post a link here if anyone wants it)
09:47:45 <shapr> probably better for us to discuss the problems :-)
09:47:47 <joel135> shapr: `cabal run` works fine
09:48:31 <heptahedron> joel135: are you just using haskell-mode in emacs?
09:48:39 <joel135> yes
09:49:33 <joel135> https://drive.google.com/file/d/1Be6bfpHXaEGdCvwZ1zzHsalV8yZoBbMS/view?usp=sharing
09:49:39 <cocreature> joel135: does "cabal repl" work?
09:50:37 <joel135> yes, I get 'Prelude>'
09:50:46 <joel135> wait
09:50:53 <joel135> wrong wd
09:51:12 <joel135> I get *TurtleGraphics>
09:51:50 <cocreature> and you’re getting the error in emacs when pressing "C-c C-l"?
09:52:52 <joel135> i have not configured the keyboard shortcuts right now, but if i load the Turtle.hs file in the emacs menu i get that error.
09:55:00 <joel135> has anyone tried the zip?
09:57:59 <shapr> I'm unable to try the zip at work
09:58:00 <amalloy> joel135: my experience has been that with stack projects, intero-mode works without a hiccup. i'm not sure how to interact with just a cabal package
09:58:35 <glguy> dante works well for interacting with whatever build system you've got going on whether it's stack or new-build or old-build
09:59:35 <joel135> so maybe i should try dante
10:02:31 <dmj`> joel135: turtle graphics works for me on osx
10:03:06 <joel135> dmj`: can i have your .emacs?
10:04:26 <dmj`> joel135: sure, there’s some cruft though, heres ~/.emacs.d/init.el https://gist.github.com/anonymous/6acdae71dd6211cfdbb1c710f8a1044c
10:05:16 <dmj`> joel135: -fshow-loaded-modules should fix the haskell-mode bug with ghc-8.2.2
10:08:25 <fresheyeball> I need some advice that I think yall will have fun with
10:08:38 <fresheyeball> I wrote a library called Compactable on hackage
10:08:57 <joel135> dmj`: thanks that works!
10:09:02 <fresheyeball> https://hackage.haskell.org/package/compactable-0.1.0.2/docs/Control-Compactable.html
10:09:18 <fresheyeball> It's a nice little abstraction over catMaybs
10:09:20 <dmj`> joel135: cool :)
10:09:49 <fresheyeball> now a very nice person named Gabe went and ported it to PureScript
10:09:56 <fresheyeball> and added a very interesting thing
10:10:28 <fresheyeball> https://github.com/LiamGoodacre/purescript-filterable/pull/13
10:10:45 <fresheyeball> https://github.com/LiamGoodacre/purescript-filterable/pull/13/files#diff-17ba42faf0fb6d026e1ba32f9b874392R62
10:10:54 <fresheyeball> specifically they added a new method "seporate"
10:11:11 <joel135> crucial lines the ones you mentioned http://lpaste.net/361877
10:11:22 <joel135> without them it keeps crashing
10:11:46 <fresheyeball> it turns out that the core method of my typeclass `compact :: f (Maybe a) -> f a`, has a relationship to a function `seporate :: f (Either l r) -> (f l, f r)`
10:11:55 <fresheyeball> where they can be defined in terms of each other
10:12:10 <fresheyeball> seporate has a lot of nice functionality and seems useful to me
10:12:15 <fresheyeball> but now I am at a loss
10:12:21 <joel135> nice, now i can enjoy an evening of programming. thanks everyone!
10:12:25 <fresheyeball> how best can I fold these learnings back into my library?
10:12:36 <tommd> phadej: I'm seeing issue 258 on your github package.  Am I to understand you'd accept a patch that adds `FromJSON` instances to the appropriate types (so I can avoid orphans)?
10:12:58 <fresheyeball> Should it be one typeclass with a minimal rep that will accept both?
10:13:17 <fresheyeball> Should I worry that there is a set of types that will work with one but not the other?
10:13:29 <fresheyeball> Should I make Seporate a subclass of Compactable?
10:13:49 <Darwin226> You guys think this is a bug? http://lpaste.net/7758653666248097792
10:14:11 <glguy> Darwin226: No, that's by design
10:14:32 <[exa]> a "weird feature" maybe
10:14:35 <lyxia> fresheyeball: didn't you say they can be defined in terms of each other
10:14:46 <lyxia> fresheyeball: so you could just add it as part of the typeclass
10:14:46 <Darwin226> glguy: What's the rationale?
10:14:54 <fresheyeball> lyxia: yes apparently they can be, in all cases where f is also a Functor
10:15:05 <lyxia> ah...
10:15:10 <glguy> Darwin226: Stability
10:15:19 <fresheyeball> it might be possible universally, I don't know
10:15:46 <glguy> You have to write out the type signature for an identifier to use explicit type application with it so that the order of type variables isn't affected by type inference or anything else
10:15:55 <glguy> Darwin226: read more at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeApplications
10:16:32 <fresheyeball> edwardk: Is there a standard way to do this? When you find out your type class has a relationship like this?
10:16:33 <Darwin226> glguy: Hmm, that's a decent reason. I wonder why explicit foralls aren't also required
10:16:43 <MarcelineVQ> fresheyeball: I​don't know much about it but when f is a functor what does your package do that witherable doesn't?
10:16:58 <lyxia> fresheyeball: I suspect all instances of Compactable will be Functor-like in a way that you will always have both
10:17:03 <glguy> Darwin226: becuase they aren't necessary to be able to satisfy the predictability reason
10:17:15 <fresheyeball> MarcelineVQ: lots, Witherable demands that f be traversable, mine asks for nothing
10:17:52 <fresheyeball> lyxia: MarcelineVQ: I have an instance for Set since we can "compact :: Set (Maybe a) -> Set a" coherently
10:18:00 <fresheyeball> Set of course not being a Functor
10:18:12 <glguy> MarcelineVQ: How'd you get a U+200B between "I" and "don't"?
10:18:13 <fresheyeball> there are also some contravariant types that can be "compact"
10:18:44 <MarcelineVQ> glguy: I've got bindings I hit accidenlty somtimes :>
10:19:30 <lyxia> fresheyeball: oh?
10:20:53 <fresheyeball> lyxia: yeah for example we could write a contrived instance for something liek this
10:21:36 <fresheyeball> data E a = Monoid b => E (a -> b)
10:22:05 <fresheyeball> then we should be able to `compact :: E (Maybe a) -> E a`
10:23:27 <fresheyeball> or prolly better
10:23:38 <fresheyeball> data E b a = Monoid b => E (a -> b)
10:25:40 <phadej> tommd: it's not mine, I just try maintain it :) That issue is about ToJSON, not FromJSON
10:32:21 <dmj`> phadej: what don’t you maintain :)
10:36:38 <phadej> dmj`: well, that's a good question
10:38:04 <phadej> dmj`: let's say I try to be helpful Hackage Trustee
10:38:15 <shapr> phadej: what's the list of cabbages you maintain?
10:38:59 <dmj`> phadej: you’ll make a fine SLURP trustee as well, or shall I say “slurpee” ;)
10:39:39 <phadej> dmj`: thanks for your confidence :)
10:40:45 <phadej> shapr: https://hackage.haskell.org/user/phadej
10:40:56 <shapr> wow
10:45:18 <phadej> shapr: others have way longer lists, https://hackage.haskell.org/user/EdwardKmett or https://hackage.haskell.org/user/MichaelSnoyman
10:46:02 <shapr> I have more nuanced things to say about edwardk :-P
10:46:20 <shapr> haven't interacted much at all with snoyman
10:47:13 <cocreature> more nuanced than “wow”? :)
10:47:21 <phadej> not to forget https://hackage.haskell.org/user/BryanOSullivan or https://hackage.haskell.org/user/DonaldStewart
10:47:25 <shapr> Yeah, only positive things to say about edwardk, he let me sleep in his office for a coupla weeks recently.
10:48:17 <shapr> phadej: good point, quite a few prolific maintainers exist
10:48:22 <phadej> latter though don't maintain their packages themselves that much anymore, AFAIK
10:48:40 <tommd> Facebook keeps them busy.
10:49:22 <phadej> tommd: true :)
11:06:59 <hololeap> is there anything that truely works like a pointer in other languages? if you create two IORef's, it doesn't appear that you can permanently switch one to the contents of the other. you can switch them to identical values, but if you change one the other will remain the same
11:08:47 <geekosaur> 2-level IORef. otherwise, not really unless you want to mess with FFI Ptr-s
11:08:49 <ski> hololeap : how would what you're looking for be done in say C ?
11:09:09 <phadej> geekosaur: 2-level IORef is pointer to pointer
11:09:32 <geekosaur> you can have two IORefs pointing to the same IORef though
11:09:40 <hololeap> i don't know if i remember C well enough to answer that
11:09:49 <geekosaur> not ideal, yes, but this is not something Haskell *does*
11:09:54 <hololeap> geekosaur: that's an interesting idea
11:10:03 <phadej> hololeap: I mean, if you do ptr1 = ptr2 you do mutation
11:10:12 <ski> well, any other example of "other languages", so that we can try go get a better idea of what you want / what you're missing ?
11:10:22 <phadej> hololeap: you can do that with one more level of IORef, but I doubt you want that
11:10:59 <int-e> hololeap: You're not running into a language difference, I think; you're running into the fact that the objects themselves are (mostly) immutable. Two IORefs pointing to the same UArray, for example, will both track modifications to that UArray.
11:11:47 <int-e> (hmm, I want something actually mutable like IOUArray there)
11:14:11 <hololeap> basically i have a bunch of pairs of ints that are coming in from IO and there is no way to predict their order. i am using something like (IntMap (IORef (Int, Int))), where the first Int inside the IORef is a unique identifier for the IORef and the second counts how many Ints are pointing to it
11:15:11 <ski> (an `IOUArray' is of course in a sense similar to an array index, or a map key, or an `IORef', in that it, conceptually speaking, doesn't itself contains the data it references. that data is conceptually carried around by `IO' itself)
11:16:04 <hololeap> so (1,2) would create one IORef for both, (3,4) would create another, but then if i got (2,3) i would want all four ints to point to the same thing. the problem is when the map gets large traversing over it to switch two big sets of ints all to the same IORef takes a long time
11:17:43 <hololeap> the only reason why i'm using IORef's was so i could "magically" (e.g. impurely) switch them all at once just by switching the IORef's value
11:18:32 <hololeap> but it seems i *still* have to go over both sets if a value comes in that links them
11:19:43 <hololeap> i hear a graph library would be the correct solution, but i still want to know if there is a way to do it using some sort of IO magic
11:19:58 <ski> hololeap : why do you need a unique identifier for the `IORef' ?
11:20:45 <hololeap> ski: because, at the end i need to quickly get a unique list of all the "chains" of ints, so i can count their size
11:21:09 <ski> is the unique identifier to be able to compare whether two `IORef's are the same ?
11:21:11 <hololeap> and the Eq instance given by IORef only gives me nub
11:21:29 <ski> hm
11:21:32 <metahumor> hololeap: Data.Graph will make all of this much much simpler
11:21:32 <hololeap> it allows me to set up an Ord instance so that i can use Set
11:21:39 <ski> ah, i see
11:21:57 <ski> hololeap : i'm wondering if you're looking for a union-find data structure (there's a package, e.g.) ?
11:22:23 <hololeap> union-find... ok i'll look into that
11:22:30 <ski> @hackage union-find
11:22:30 <lambdabot> http://hackage.haskell.org/package/union-find
11:22:41 <hololeap> metahumor: and i'll probably switch over to Data.Graph
11:22:47 <mnoonan> hololeap: I don't know if this is what you want, but I added a "tie" function to justified-containers that lets you tie the knot on a graph-ish thing
11:22:59 <metahumor> hololeap: if i understood your problem correctly, you're looking for buildG from Data.Graph
11:24:03 <[exa]> btw is there any good bound-less buildG ?
11:24:11 <mnoonan> e.g. you make a Map Int (f Int), hit it with tie and an initial Int, and get back a value of type Fix f
11:25:43 <metahumor> [exa]: not that i know of, but i also don't know the cost of a much-larger-than-necessary bound
11:27:00 <mnoonan> hololeap: in effect, your key is like a reference ID or something, and "tie" converts them to actual pointers.
11:27:24 <hololeap> mnoonan: i'll check out justified-containers too
11:27:28 <hololeap> thanks everyone
11:27:30 <metahumor> mnoonan: thanks for putting your "\case" analysis in that post
11:27:35 <ski> mnoonan : using something like `newCyclicIORef :: (IORef a -> a) -> IO (IORef a)' ?
11:27:46 <mnoonan> ski: just plain old laziness
11:28:09 <ski> no `mfix :: (a -> IO a) -> IO a' ?
11:28:30 <ski> oh, right. you had no `IORef' in your result. sorry, ignore me
11:28:51 <[exa]> metahumor: it's actually a tiny wrapper I use almost everytime (just takex min/max from the list to create the bounds and run buildG; just wondering whether it's been standardized :]
11:29:07 <mnoonan> hololeap: it does a pass over the map to ensure that there are no dangling references; if you don't want that, just copy the implementation of "tie" using normal Maps.
11:29:22 <mnoonan> metahumor: I'm surprised at how much interest it generated!
11:32:50 <ixxie> hello #haskell, I'm on my first day of Haskelling and I am trying to implement https://wiki.haskell.org/Roll_your_own_IRC_bot
11:33:26 <tdammers> that's mighty ambitious for your first day
11:33:34 <[exa]> ixxie: looking forward to see the bot!
11:34:09 <ixxie> section 3 doesn't compile for me, I get "Variable not in scope: eval :: Handle -> [Char] -> IO ()" for the line "if ping s then pong s else eval h (clean s)"
11:34:37 <[exa]> ixxie: definition of eval is a bit lower on the page
11:34:37 <ixxie> tdammers: well, since I am mostly copying existing code, its alright so far, except this error
11:34:59 <ixxie> ooops
11:35:05 <tdammers> well, 'variable not in scope' means just that - the variable is not in scope
11:35:14 <ixxie> lol thanks [exa], missed that
11:35:17 <tdammers> you need to either define `eval`, or import a module that does
11:35:18 <amalloy> ixxie: you're supposed to be adding to the existing definitions. i think section "2 Talking IRC" has the import you need, System.IO
11:35:29 <ixxie> tdammers: I am just not used to functions being called variables, isall xD
11:35:35 <ixxie> of course, I should get used to it xD
11:36:01 <amalloy> that is, section 3 is not meant to compile on its own
11:36:08 <amalloy> it needs the stuff from sections 1 and 2 as well
11:38:21 <ixxie> amalloy: well I have been reading this sequentially, so stuff that came in before is in there
11:39:23 <amalloy> okay, i guess you're right. it's not in System.IO after all
11:39:36 <amalloy> oh, it defines eval a few lines later
11:39:49 <kamyar> How can I omit t in this function:
11:39:51 <kamyar> msec t = ((/1000) . fromIntegral . nsec $ t) + ((*1000) . fromIntegral . sec $ t)
11:40:08 <amalloy> ixxie: you need to add everything in section 3, not just the first snippet
11:40:56 <mnoonan> ixxie: Haskell lets you put definitions in any order, so a code snippet might be depending on something not defined until a little later
11:43:19 <kamyar> Is this possible in Haskell? I mean a better syntax not more complicated
11:44:43 <glguy> kamyar: Here, I fixed it: msec t = fromIntegral (nsec t) / 1000 + fromIntegral (sec t) * 1000
11:44:43 <shapr> @pl msec t = ((/1000) . fromIntegral . nsec $ t) + ((*1000) . fromIntegral . sec $ t)
11:44:43 <lambdabot> msec = ap ((+) . (/ 1000) . fromIntegral . nsec) ((1000 *) . fromIntegral . sec)
11:45:13 <woodson_> is it possible to pattern match with function's result?
11:45:16 <mnoonan> kamyar: defining a Time newtype and then "instance Num a => Num (Time -> a) where ...", perhaps
11:45:17 <kadoban> kamyar: msec = liftA2 (+) ((/1000) . fromIntegral . nsec) ((*1000) . fromIntegral . sec) -- but I wouldn't actually do it myself
11:45:36 <woodson_> or a declared value?
11:45:56 <woodson_> such as top = ""; case location of top -> blabla
11:46:17 <mnoonan> then you'd just have "msec = nsec / 1000 + sec * 1000"
11:47:57 <jle`> kaychaks: it is possible but a bad idea
11:48:43 <jle`> woodson_: it is possible to pattern match with a function's result, and it is done pretty often
11:48:56 <jle`> oh, do you mean as the pattern itself?
11:49:10 <woodson_> jle: as the pattern itself
11:49:13 <jle`> woodson_: `case location of top -> blahblah` is matching on the wildcard case
11:49:23 <jle`> it's creating a shadowed definition
11:49:30 <jle`> like case location of  x -> blahblah
11:49:34 <jle`> that's how patterns work
11:49:51 <jle`> what you want is something like case location of x | x == top -> blabla
11:50:47 <woodson_> jle: Ohhhh that make sense now, thats why I am getting a redundant def error blabla
11:51:05 <woodson_> hmm I know about the function guards its just that I hate the use of '=='
11:51:21 <jle`> == is the only thing that really makes sense here, though
11:51:35 <jle`> any other solution you have would just be hiding a usage of == somewhere
11:51:36 <woodson_> but I guess that its best it will allow me to reuse already defined codes
11:51:47 <jle`> since you're checking if one value is equal to another
11:52:30 <jle`> woodson_: for what it's worth, case matching on numeric literals is doing the same thing
11:52:42 <tdammers> ixxie: it's not that functions are called variables; it's that functions are values too, and so we can have variables that hold functions
11:52:44 <jle`> `case x of 0 -> ...` is just sugar for `case x of y | y == 0 -> ...`
11:53:11 <hololeap> kamyar: you can use the "fanout" function from Control.Arrow: (&&&) and then uncurry (+) to combine both sides of the tuple
11:53:24 <hololeap> msec = uncurry (+) . ((/1000) . fromIntegral . nsec &&& (*1000) . fromIntegral . sec)
11:53:25 <woodson_> jle: hmm I see! Good to know about the part that its matching on wildcard
11:53:41 <woodson_> jle: As usual thank you man! You're the best !
11:53:42 <woodson_> lol
11:53:53 <jle`> woodson_: yup :) syntactically it trips up a lot of people when they are starting out
11:54:00 <jle`> it's a very common thing, someone just had the same question the other day too
11:57:22 <ixxie> mnoonan: I am familiar with that sort of thing from Nix; I just didn't read onwards xD
12:00:23 <hololeap> woodson_: there is also this, which may pertain to what you want: https://ocharles.org.uk/blog/posts/2014-12-02-view-patterns.html
12:07:11 <hyperisco> boo
12:08:09 <fresheyeball> is there a way to provide an optional typeclass method?
12:08:24 <hyperisco> fresheyeball, sure, provide a default implementation
12:08:26 <[exa]> fresheyeball: provide a default implementation
12:09:15 <[exa]> E.g. Foldable definition has a lot of them
12:09:48 <hyperisco> how different are we? are we individuals or merely different collages of the same ideas?
12:10:17 <metahumor> we've just been trained to respond to certain stimuli in coagulated ways
12:14:57 <woodson_> hololeap: Yes, I've heard about lens and used it a bit with library that already includes it but for now I am just avoiding it because im building an app that I want to put in prod. Once I got that working I feel like Lens is just a tool that will facilitate things for me
12:15:17 <woodson_> so I can take the time to learn it when I will refactor my code
12:15:50 <woodson_> but thanks! like the way their pattern matching
12:17:10 <hololeap> woodson_: i'm confused. i gave a link explaining View Patterns, not Lens
12:20:57 <woodson_> hololeap: I dont know why as already look at something related to Lens and got mixed up
12:21:02 <woodson_> lol
12:21:20 <hololeap> no worries
12:23:17 <woodson_> hololeap: Yes, thats its exactly what I was looking for
12:23:27 <woodson_> similar to erlang pattern matching
12:24:08 <ixxie> tdammers: thanks for clarifying that nuance
12:24:15 <woodson_> the link on the site for view Pattern is dead tho
12:25:02 <merijn> woodson_: Just look at the GHC manual, it's the most reliable documentation for extensions
12:25:20 <woodson_> merijn: thats what I am doing now.
12:25:22 <merijn> And way to often ignored by people :)
12:25:23 <ixxie> I'm currently using emacs but its a tad annoying in many ways, I am considering switching to Vim/NeoVim but since I plan to focus on Haskell in the next year/s I was wondering how those editors compare for Haskell development
12:25:27 <woodson_> thats a pretty sweet extension
12:25:45 <merijn> ixxie: It depends how bleeding edge you want to be
12:25:53 <merijn> ixxie: And how advanced you want your editor support to be
12:26:18 <ixxie> merijn: I'm on NixOS so bleeding edge isn't much of a problem
12:26:31 <hololeap> glad i could help
12:26:35 <merijn> ixxie: I mean more that bleeding edge means -> shit doesn't work :)
12:26:41 <ixxie> heh
12:27:07 <merijn> ixxie: I use vim, but none of the plugins (except ghcid) supports new-build and the only vim ghcid plugin is for NeoVim (which I can't use)
12:27:41 <merijn> ixxie: If you use stack/ "old" build, then ghc-mod will probably work, but it's a bit slow
12:28:01 <ixxie> merijn: I build with Nix
12:31:08 <merijn> I don't have any experience with that, so can't say how that works out
12:33:53 <ixxie> thanks anyway merijn
12:49:54 <fizzgig> fbchats
12:50:07 <fizzgig> oh sorry wrong channel :X
12:56:28 <metahumor> jle`: great new post on Duet
13:12:27 <statething> Hi there, haskell noob here. So if I have a servant API and want it to just populate some sort of generic in-memory store, how do I do that in Haskell? O:-)
13:15:36 <EvanR> generic in-memory store, fascinating
13:15:56 <EvanR> what goes in and comes out of this store
13:20:00 <JuanDaugherty> stuff
13:22:29 <rblaze> Data.Map ByteString ByteString
13:22:47 <EvanR> for that, you want a bytestring trie
13:25:11 <jle`> metahumor: thanks! :)
13:25:33 <jle`> it was one of the more fun problems in AoC for me this year, and i thought there weren't many posts out there talking about the modular interpreter pattern
13:30:37 <statething> EvanR Hi! Sorry, just looked away for a second. Instances of Records i'd naively say :-) things created by a normal data constuctor
13:31:15 <statething> is that even the right way to say it?
13:32:13 <statething> eg: things of type Maybe?
13:32:14 <EvanR> i dont know what you mean exactly
13:32:22 <EvanR> do you mean json objects
13:33:08 <statething> Well the JSON objects comming in are being marshaled into typical records
13:33:23 <EvanR> so you have a specific record type
13:33:42 <statething> yes, actually I have a bunch of them
13:34:06 <statething> the data types in my servant API
13:34:25 <EvanR> so if your collection of records has type X, you can implement the store with a TVar X
13:34:47 <statething> TVar? hang on, need to hoogle that :-D
13:35:17 <EvanR> STM mutable variable
13:35:51 <statething> Yeah, just reading this! Sounds like something I would need :-)
13:36:12 <statething> STM == Software Transactional Memory?
13:36:20 <EvanR> yes
13:38:36 <statething> so if I have a dict of tvars I would just use modifyTVar to update it?
13:38:44 <statething> eg: ad one or remove one
13:38:55 <statething> add
13:39:06 <statething> ?
13:39:10 <EvanR> well, ok, you can have many TVars or 1
13:39:24 <EvanR> either way you can access all of them atomically within a transaction
13:40:11 <EvanR> then all the concurrent requests will not mess each other up
13:42:05 <statething> OK, so in order to ensure correctness I would have one TVar which is some sort of dictionary to types and then update the specific sets/dicts via a modifyTVar right?
13:42:26 <monochrom> Indeed whereas Chan (using MVars) is a lot of MVars (one per item), TChan is just one TVar over ([a], [a]).
13:43:15 <EvanR> which seems counterintuitive because TVar is the one that simplifies using multiple vars
13:43:20 <monochrom> And indeed in the case of TVar (Map K V) I even just use IORef (Map K V) and atomicModifyIORef.
13:44:07 <monochrom> Ah but you never know whether users actually do "atomically {do  x <- dequeue from my TChan; if x<0 then retry ...
13:45:13 <merijn> EvanR: STM performs better with less variables, though
13:45:40 <merijn> EvanR: More variables = more chance of conflict = more chance of rerunning a transaction & waking up other threads needlessly
13:45:44 <monochrom> And in my use of IORef I can get away with it because my transaction is as simple as one single atomicModifyIORef. I assure you if I have a compound transaction I'll switch to TVar in no time.
13:46:38 <statething> OK, so TVar kind of sounds the right thing vor my use case :-)
13:46:56 <statething> Thanks everybody!
13:47:00 <EvanR> well as we just saw one IORef with your whole database and atomicModifyIORef also works
13:48:00 <monochrom> In fact my favourite application of TChan is you're polling two queues simulataneously and "I'll act on the first one available": atomically (dequeue first queue `orElse` dequeue second queue). This is where our STM shines. Our STM. Other people's STM can't do this.
13:49:21 <cheater> yeah, that's amazing, and i love it
13:49:49 <cheater> i wonder what the performance is of this vs select/epoll
13:49:59 <merijn> cheater: THis is MUCH faster than select/epoll
13:50:01 <cheater> i wish we could get it close to being like epoll. i really really do
13:50:03 <cheater> is it
13:50:08 <cheater> are you joking me? really?
13:50:09 <merijn> select/epoll have to do a syscall
13:50:18 <cheater> ohhh
13:50:28 <cheater> and especially now syscals are more expensive
13:50:33 <cheater> but even before
13:50:35 <monochrom> Heh
13:50:39 <cheater> niiiiiice.gif
13:50:47 <merijn> cheater: STM is ridiculously fast on relatively low contention
13:51:08 <cheater> yeah. maybe we could do something about contention performance.
13:51:11 <monochrom> "News flash: Haskell performance increased by 30% overnight without changing the compiler."
13:51:12 <siwica`> I try to pattern-match a String against `(ŕ:[c])`. Why doesn't that work?
13:51:32 <merijn> monochrom: That'd be the new IO manager all over again :)
13:51:34 <cheater> like a user-definable algorithm for consensus-seeking
13:51:39 <siwica`> I expected this to match against all two-character strings
13:51:46 <cheater> which you could tune for your own workload
13:51:47 <int-e> siwica`: that's a two-element list, a string of length two
13:51:58 <int-e> > case "ab" of r:[c] in (r,c)
13:51:58 <merijn> siwica`: No quotes around the r?
13:52:02 <lambdabot>  <hint>:1:20: error: parse error on input ‘in’
13:52:07 <int-e> ...
13:52:10 <int-e> > case "ab" of r:[c] -> (r,c)
13:52:12 <geekosaur> wtf was that syntax
13:52:13 <cheater> monochrom: err that would be 42% (100/70)
13:52:14 <lambdabot>  ('a','b')
13:52:16 <fishythe_> > let r:[c] = "ab" in (r, c)
13:52:19 <lambdabot>  ('a','b')
13:52:22 <siwica`> the quotes are not in the actual code
13:52:30 <monochrom> I'm bad at percentages.
13:52:37 <int-e> > case "abc" of r:[c] -> (r,c) -- this fails, of course
13:52:41 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
13:53:05 <int-e> siwica`: so the question is, what do you want to match?
13:53:14 <siwica`> And I can't do:
13:53:21 <cheater> do you guys think it would be possible to have a pluggable decontention algorithm in stm?
13:53:35 <siwica`> foo (r:[c]) = Just c; foo _ = Nothing
13:53:40 <siwica`> or something alike?
13:54:08 <monochrom> > let { foo (r:[c]) = Just c } in foo "ac"
13:54:11 <lambdabot>  Just 'c'
13:54:14 <monochrom> worksforme
13:54:14 <int-e> siwica`: you can do that. It's unnatural, I'd rather write [r,c] or perhaps r:c:[] than r:[c]. But they're all equivalent.
13:54:39 <cheater> something like, within the STM monad, a new keyword that's sort of type (STMCtx -> ???) -> STM a -> STM a
13:55:04 <cheater> where STMCtx is the current state of the STM run
13:55:06 <siwica`> Somehow I am getting "Variable not in scope: r :: Char"
13:55:16 <siwica`> Which really wonders me
13:55:17 <fishythefish> siwica`: do you have a paste with larger context?
13:55:26 <int-e> siwica`: you have an accent on the r
13:55:34 <fishythefish> that too
13:55:36 <int-e> (no clue where that came from)
13:56:33 <siwica`> http://lpaste.net/361882
13:56:34 <int-e> > let ŕ = 42; r = 23 in r
13:56:38 <lambdabot>  23
13:56:41 <int-e> > let ŕ = 42; r = 23 in ŕ
13:56:44 <lambdabot>  42
13:56:54 <int-e> siwica`: do you see the difference?
13:56:55 <fishythefish> siwica`: yup, there's an accent on the r in the pattern match
13:57:00 <siwica`> Ahh, omg. That is embarassing.
13:57:10 <siwica`> ^^
13:57:18 <siwica`> Well, sorry for wasting your time
14:00:50 * geekosaur has seen buggy utf8 processing do that
14:01:18 <geekosaur> smart quotes + buggy processing = 'r' becomes something weird like that. (gmail notifications like to do that for some reason)
14:01:44 <hexagoxel> regarding the slurp proposal: where does the "stack community" discuss the option of forking hackage?
14:03:51 * hexagoxel hopes the answer is not "this selection of tweets" or "mostly private emails"
14:04:34 <Uniaika> "this fine selection of private tweets"? :-p
14:04:41 * monochrom imagines "they gather at a secret dungeon under Westminister Abbey for this" :)
14:04:42 <Tuplanolla> What even is the Stack community?
14:04:57 <int-e> hexagoxel: a slack chatgroup (just kidding)
14:05:04 <hexagoxel> i don't know; it is simply the term the slurp proposal uses.
14:05:19 <hexagoxel> "If we do nothing it seems likely that the Stack community will create a separate Haskell package repository."
14:05:40 <hexagoxel> [citation needed]
14:05:46 <Tuplanolla> Maybe it's a code name for FP Complete.
14:05:48 <EvanR> stack.slack.com
14:06:15 <Uniaika> A discord server
14:06:37 <Uniaika> or better. An IRCd written in Haskell with every possible language extension turned on
14:07:49 <Uniaika> talking about tweets https://twitter.com/ttuegel/status/955554648756244481
14:07:51 <Uniaika> :'')
14:08:09 <int-e> hexagoxel: some more serious speculation, I would expect such discussions to leave traces on github (e.g. https://github.com/fpco/stackage) so that may be a starting point for a search
14:25:34 <ixxie> how do imports work relative to paths?
14:25:56 <merijn> ixxie: Imports are not related to path at all
14:26:16 <ixxie> hmm
14:26:18 <hexagoxel> all is relative to haskell-src-dirs
14:26:18 <c_wraith> that's... not exactly true.
14:26:20 <merijn> ixxie: Installed packages are registered with GHC, so GHC knows the paths of libraries
14:26:38 <c_wraith> merijn, you can import modules in your own package
14:26:53 <merijn> c_wraith: That's still an implementation detail of GHC, though
14:26:54 <ixxie> that is more what I am refering to
14:27:07 <ixxie> oh
14:27:10 <ixxie> so this: https://github.com/stepcut/ircbot/blob/master/Network/IRC/Bot.hs
14:27:17 <merijn> ixxie: Within a package every level of 'Foo.Bar' maps to a directory with GHC
14:27:18 <ixxie> is not part of the spec
14:27:21 <c_wraith> yes, so say "this is how the compiler with 99% of the market does it"
14:27:37 <merijn> ixxie: So the module "Foo.Bar.Baz" is "Foo/Bar/Baz.hs"
14:27:45 <merijn> ixxie: Relative to hs-src-dirs
14:28:16 <ixxie> hs-src-dirs is what exactly?
14:28:30 <merijn> ixxie: A field in your cabal file
14:28:53 <ixxie> hmm I don't have one
14:29:19 <merijn> ixxie: Then you'll wanna run "cabal init" to create one
14:29:36 <monochrom> This is a cluster-XYZ problem.
14:29:41 <hexagoxel> with raw ghc --make i guess the default is "." ?
14:29:48 <ixxie> merijn: I don't have cabal and so far I don't see a need for it
14:29:55 <hexagoxel> monochrom is right :)
14:30:13 <monochrom> Someone brought up "hs-src-dirs", and that someone doesn't even follow up with it afterwards, and now everyone goes crazy about making sure that it exists.
14:30:30 <merijn> hexagoxel: FYI, --make has been the default behaviour for GHC for over half a decade by now ;)
14:32:35 <ixxie> so if I don't use cabal and I have a module declared inside /maindir/subdir/file.hs, how can I import it into /maindir/main.hs ?
14:32:45 <merijn> ixxie: building code of more than 1 file by manually calling ghc is, imo, more hassle than using a cabal file. But if you don't want, I *assume* ghc just looks relative to "."
14:33:06 <merijn> But I don't make any promises
14:33:08 <monochrom> GHC has a command-line option "-i" for that.
14:33:30 <monochrom> Likely in your case -i/maindir/subdir no space.
14:33:47 <monochrom> But watch out for file.hs vs File.hs and module names etc etc
14:33:59 <monochrom> Generally, read the GHC user's guide from cover to cover.
14:34:40 <ixxie> so basically I am either tied to GHC or tied to Cabal if I want some sane way to import modules?
14:34:59 <merijn> ixxie: cabal is a build tool that deals with calling GHC for you
14:35:11 <monochrom> You can use Hugs too. I'm sure it also has a command-line option for extra directories to look into.
14:35:27 <merijn> ixxie: (well, technically you can use cabal with things other than GHC, but almost no one does)
14:35:34 <merijn> ixxie: So you're tied to GHC either way
14:35:46 <ixxie> alright
14:35:47 <ixxie> thanks
14:35:53 <tdammers> actually cabal is completely unnecessary if all you want to do is import local modules
14:36:01 <AndreasK> As soon as you depend on packages you will want cabal or stack. So it's defenitely not a waste of time to figure them out
14:36:04 <merijn> tdammers: I didn't say it was required
14:36:23 <tdammers> all you need to do is put all your modules into a directory tree that matches the module hierarchy (i.e., Foo.Bar.Baz goes into Foo/Bar/Baz.hs)
14:36:26 <merijn> tdammers: But code never sticks to just base once it's more than one file :)
14:36:27 <tdammers> and then you do ghc --make
14:36:34 <merijn> tdammers: s/ghc --make/ghc
14:36:50 <tdammers> and yes, the --make is optional, but I like to mention it for clarity
14:37:17 <ixxie> AndreasK: I have Nix for dependency management
14:37:23 <geekosaur> and in any case you are still stuck with the fact that there is no magical registry that knows that a module Foo lives in /some/where/foo.hs much less /some/where/bar.hs. Source paths are constructed from module names, which is why there is a case dependence
14:38:39 <AndreasK> Then you might be able to do without I guess. Not familiar with nix :)
14:39:38 <ixxie> Lets see how far I get without it :)
14:40:14 <monochrom> KYC = Know Your Compiler.
14:41:00 <merijn> I know my compilers in the biblical sense.
14:41:09 <merijn> That is, I always get fucked by them >.>
14:41:26 <geekosaur> that just means you're a programmer >.>
14:41:47 <lambdabot> <.<
14:43:15 <merijn> s/programmer/high-functioning alcoholic
14:43:34 <glguy> I was wondering what that term meant, thanks
14:46:22 <merijn> glguy: For a second I thought you meant "programmer" ;)
15:04:25 <thehappycolorpro> should i use "$" in my code, or just stick to parentheses?
15:05:01 <glguy> $ works in a couple of places, but mostly ()s
15:05:28 <glguy> for someList $ \x ->
15:05:36 <glguy> before a lambda in particular is nice
15:05:50 <AndreasK> return $ ... is nice too
15:05:56 <merijn> I like $ before do
15:06:03 <merijn> liftIO $ do ... :)
15:06:29 <AndreasK> unsafePerformIO $ do ... ;)
15:06:37 <Tuplanolla> Ideally, that would not be necessary.
15:06:51 <Tuplanolla> If only we had `ArgumentDo`.
15:07:46 <EvanR> at this point if $ were not necessary there i would be very uncomfortable
15:07:53 <merijn> EvanR: Me too
15:08:03 <merijn> I'm conflicted on ArgumentDo
15:08:05 <c_wraith> I'd get over it
15:08:19 <EvanR> unsafePerformIO do something, looks like 2 args to unsafePerformIO
15:08:34 <Tuplanolla> It would allow writing `don't do` and simplify the parser too.
15:08:46 <ixxie> tdammers: so in main/file.hs I can do import x.y.z if main/x/y/z.hs has a header module x.y.z (a,b,c) where [...]?
15:08:47 <merijn> Tuplanolla: :)
15:09:10 <EvanR> hmm how about a language with no punctuation and its just a sequence of words
15:09:20 <EvanR> so much simpler, lisp eat your heart out
15:09:23 <Tuplanolla> You just invented Forth, EvanR.
15:10:21 <merijn> argh
15:10:45 <merijn> Is there a word for that sinking realisation that you're royally screwed?
15:11:49 <kadoban> merijn: life
15:12:24 <merijn> kadoban: Not quite the feeling I was going for >.>
15:13:28 <ixxie> merijn: I only know some phrases, like gvdme etc
15:14:01 <lyxia> let x be forty-two in print quote hello world exclamation unquote
15:15:29 <merijn> Paper deadline on friday, and half of my data is considerably out of date with my current code, so I might have to rerun everything to get non-bogus results, which would kinda torpedo the whole "be done before friday" thing >.>
15:17:25 <Tuplanolla> I hope you're ready for some 15-hour workdays, merijn.
15:17:39 <merijn> Tuplanolla: Not gonna help
15:18:00 <merijn> Tuplanolla: I've automated all the experiments, there's just not nearly enough hours in between now and friday to run all of them
15:18:17 <Tuplanolla> This is starting to sound a lot like my thesis.
15:18:43 <glguy> merijn: Good thing you figured this out on Monday instead of wasting a whole week working on it and then not being done
15:18:50 <glguy> now you have a whole week to do something else
15:19:42 <thehappycolorpro> printInc n = print plusTwo /n where plusTwo = n + 2
15:19:45 <kadoban> merijn: Can you just run them in parallel on separate machines perhaps?
15:20:06 <merijn> Tuplanolla: I've basically got a setup where I can benchmark a bunch of different implementations, train a model, and then optimise at runtime based on the model. But since the original dataset the model was trained on and now I've updated the implementations (plus, discovered the nvidia compiler was braindamaged), so now the results don't match the current kernels. And I can't do my online optimisation
15:20:11 <thehappycolorpro> what is the point of writing code in that way?
15:20:12 <merijn> with the old kernels, because the APIs won't fit together
15:20:24 <merijn> glguy: I'm not 100% sure it's hopeless yet
15:20:28 <lyxia> thehappycolorpro: none
15:20:35 <thehappycolorpro> i'm a beginner so im confused. can't you just write print (n + 2)
15:20:37 <thehappycolorpro> o
15:20:40 <ski> thehappycolorpro : sometimes it can be nice to give an explicit name to something. especially if you want to refer to it more than once
15:20:45 <ski> sure you can
15:21:18 <Tuplanolla> You could call the results preliminary.
15:21:31 <thehappycolorpro> ok, it was in the haskellbook so i guess it was just to show how the functions would work
15:21:39 <thehappycolorpro> thanks
15:22:06 <merijn> Tuplanolla: If I'm lucky the relative performance didn't change too much
15:22:22 <merijn> Tuplanolla: Since the only thing that really affects me is the ranking of the implementations
15:22:38 <ski> thehappycolorpro : you can also define "helper" functions inside such a `where' .. and such definitions can have their own `where's attached to them. but one rarely nests them that many times
15:23:12 <ski> (you can attach `where's regardless of whether it's a function definition or not. it's just a bit more common to attach them to function definitions)
15:24:11 <Tuplanolla> That feeling of anxiety when your simulations take ages to produce wrong results is one of the reasons I'm so happy to be moving to more theoretical work.
15:26:27 <merijn> Tuplanolla: Well, the new ones that don't take nearly as long to run, since I figured out I was getting screwed by the compiler
15:27:18 <thehappycolorpro> ski: i seeeee
15:27:27 <merijn> I just have a lot to run, because the "how can I reduce the required work" part of my research isn't done yet :p
17:29:34 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | AoC leaderboard 43100-84040706'
17:29:34 --- topic: set by glguy on [Thu Nov 30 21:14:35 2017]
17:29:34 --- names: list (clog hjdskes emilypi Stanley00 mizu_no_oto revprez_atlanta oisdk brynedwards mvakula s4ke Bare seanparsons zarulshahrin alex`` x77686d_ x77686d dcoutts_ zaquest jackdk zero_byte cynapse conal infinity0 pavonia xcmw Durbley Guest51600 Wesleysld ManiacTwister Jaxan urdh sdhand TimWolla qdickon kensan pierrot ventonegro Windurr barcabuona DTZUZU kerrhau bs lagothrix sgronblo rcdilorenzo RGamma dtornabene jfredett plutoniix banc olligobber ghc_-o_exec sigmundv)
17:29:34 --- names: list (duncan^ minad atk mk_modrzew pmade Blkt Quintasan Tspoon_ zgrepc al-damiri tharper_ lynn higherorder eliasr strmpnk srid sdemos runeks thoradam TabAtkins edwardk Tallenz fnurglewitz tarcwynne__ zmanian dgonyeo jzelinskie stephe sonOfRa cpape unyu YungMoon Lokathor_ tg whaletechno machinedgod DrAwesomeClaws sleffy ninedotnine tsaka__ afarmer augur wonko7 louispan hiratara juhua Takumo MP2E bmeynell ammazza Psybur_ slackman1 avocado orphean mkoenig beanbagula)
17:29:34 --- names: list (DFCAK dmcmintty ziocroc3 toblorone sveit albel727 dcoutts solv3d eschnett amx rembo10 kuttifunk omilu hc cjay- bcoppens miladz89 mulk bickle1 gawen noumenon hamishmack stux|RC-only pera dmiles toby1851 Tuplanolla fr33domlover gnusosa AndreasK meck xkapastel Destol azahi replay yyy rbocquet elfets acarrico Rembane jramsay a9rkzz ziman byorgey micro caryoscelus Pacra bbear xor toks acidjnk jdnavarro Natch jdt `Guest00000 mingc sepp2k leat tmciver Gurkenglas Deide)
17:29:34 --- names: list (lukky513_ alx741 urodna unclechu Akito[m] jacobleach KevinMGranger aer[m] magnap sm lightandlight sielicki spacekitteh[m] M-kitsune M-moyamo maigel[m] Barnabas[m] hdurer[m] softashell kasbah[m] albertsg[m] M-berdario WilliamHamilton limonheiro[m] sujeet chuzz[m] sburavtsov[m] himmAllRight[m] Mcpurplemuffin[m jomari[m] HoelKervadec[m] matheusrv[m] Pilfers agraba[m] km42[m] dumpster[m] abel-abel[m] adziahel[m] lysgaard[m] TimWolla[m] fbreitwieser[m] howsiwei[m])
17:29:34 --- names: list (ElliotKiyomizu[m sn[m] rellen cipher1024[m] JackM[m] ttk2[m] sudoreboot[m] sh4pe[m] razvanc-r[m] geetam wizek[m] ycy[m] wubbalubbadubdub ReinH tester668[m] rizo[m] tibike_m[m] lierdakil[m] puminya[m] avatias0[m] oats[m] seizo[m] thejonny[m] unknownln sherushe[m] minhnhdo[m] CryptoCalsius[m] asthma[m] honeymilktea[m] ub[m] Litom[m] virginiam[m] Guest340521[m]1 caw__ dmj` tctara nyuszika7h JSharp rann bbielsa thoughtpolice dukedave wavewave edofic grandy____)
17:29:34 --- names: list (nelll cocreature thomashoneyman _flow_ capicue baamonde dessmm heyj Spritzgebaeck redcedar strugglingming lachenmayer iphy peteretep xintron_ systemfault huonw implementation DustyDingo swflint shutdown_-h_now ChongLi hegge abbe ab9rf_ Xal thunderrd darjeeling_ Lowl3v3l MissingNoIOI jao epicallan carlomagno byte512_ [Leary] cgfbee danthemyth govg heurist kadoban jeltsch lijero zar Firedancer sun777 jtcs ekrion prg318 drcode petermw Snircle dddddd staafl phryk)
17:29:34 --- names: list (maerwald thc202 slsels PatrickRobotham guios S007 raingloom ericsagnes nilg sdothum ertes-w jchia nshepperd cpup jcarpenter2 hololeap leothrix TryToReboot isenmann brennie otto_s piyush-kurur revprez_anz HEGX64 theDon nakal hucksy mk-fg Foritus owickstrom martingale albertid_ drewbarbs tessier baweaver chirpsalot DK21 __main__ bydo gfixler jounaz^ pnrfne[m] fryguybob william diskie dxtr beerdrop Sgeo_ infinisil Cthalupa taktoa niklasl ljhms alexbiehl andree)
17:29:34 --- names: list (peutri Tharbakim khisanth_ jlouis mceier gienah canta saurik michalisko marek Youmu antismap doctors[m] Logio weeirc8089 max3raza SAL9000_ _ashbreeze_ asjo linuxdaemon catsup ent sjl_ mjrosenb crosleyt [exa] thallada vjousse jluttine jchia_ monochrom sim590 m4lvin justanotheruser raynold markus1189 lev1athan sdx23 Unhammer dexterfoo tsahyt greymalkin ftop ironChicken a_t M2tias ahihi mountaingoat Lord_of_Life feepo siddhanathan[m] berton equalunique[m])
17:29:34 --- names: list (herzmeister[m] c0ff33[m] seto[m] henriquezanin[m] toumi124[m] Google[m] stites[m] undu[m] innaytool[m] moonrunes[m] Half-Shot davidar hiq[m] angelbeats[m] geekosaur icen[m] Dako300[m] Guest85017 MikasiCoyote[m] mith[m] grassator[m] DavesTestingAcco octalsrc[m] noperope[m] superobserver[m] iohidtbhfam[m] unlawfulmonad[m] gridaphobe[m] strangepowers[m] phil_frontal[m] asenski[m] zaphar_ps[m] usedname[m] M-x[m] mossid[m] Zircon[m] schplaf[m] arthurfragoso[m])
17:29:34 --- names: list (wchresta[m] reconmaster[m] atopuzov[m] metaxis[m] nkhodyunya snpriyanshu[m] just_test1ng[m] Heino[m] Frankablu madknight yushyin thebeast[m] seif_madc[m] AntonLatukha[m] ajtowns[m] GGMethos testtt0x11[m] hakan[m] PifyZ[m] bbslclubbin[m] cansis fristonio[m] alanz killtheliterate avn stux|RC dminuoso sphalerite raibutera m4sk1n Mike[m] drasich[m] maverickwoo[m] geodesic[m] Scapin[m] Dev[m] WinterFox[m] fgaz[m] M-whoops tobim[m] beemo[m] ollieh bennofs[m])
17:29:34 --- names: list (zalipuha[m] Orbstheorem[m] mak81[m] aniketd[m] kwaku[m] grisotto[m] bgrayburn[m] scrypso[m] goodboy[m] M-HirmeS towaii[m] skaillet[m] ngross[m] Elorm[m] M-rgh noteventime[m] javjarfer[m] pcm77[m] Naughtmare[m] SijmenSchoon[m] felipeac[m] chocowheel[m] aaronc[m] reactormonk[m] SansFr[m] zipper TylerCecil[m] mad[m]1 JCGrant[m] Flecheck[m] hpd_m deyg[m] shekel[m] sdvcxd[m] michaelw angular_mike andrew_n_ feltnerm si14 dxld Guest63586 jmct avdi TyOverby__ nekomune)
17:29:34 --- names: list (Bengi S11001001 houli metalrain_ Niamkik sbauman mgttlinger hsiktas paraseba dsal johs hexagoxel lukexi iravid trig-ger stig jameshaydon lopex dfranke reem yaknyasn lumimies cawfee niluje kaol exferenceBot jinblack flux DigitalKiwi naudiz osfameron jw358_ Guest66929 comboy riatre akermu Geekingfrog Laney gabiruh_ rjeli_ hive-mind verement Jesin iliastsi xplat tolt falafel logcat Tesseraction_j seveg srid[m] statusfailed leah2 esph ons lukd Digit uwap sbjorn)
17:29:34 --- names: list (dogui keri opqdonut freeside nullifidian Voldenet StoneToad pjan Sose ps-auxw dolio ertes amalloy cpallares mw Tourist nek0 salek__ Meanirelli steshaw cyberlard ericmathison Neo cogrendel pikajude pk6vx0x2 spoonm etiago giraffe cjwelborn wz1000 troydm imbigbrother[m] mt dqd aminb xacktm admin1 Klumben SolarAquarion kwantam MitchW newsham anhduy bob_twinkles NextHendrix hodapp bbaren srk dredozubov x-n2o dilinger kriztw iw00t CuriousErnestBro swhalen aweinstock)
17:29:34 --- names: list (BytesAndCoffee qmm arkeet alexknvl_ joehillen burp tv xaimus Axman6 dysfigured fluxit hanDerPeder tabaqui1 mjo_ lines datajerk Amadiro solatis SegFaultAX Saizan barrucadu nshepperd1 da-x thekyriarchy badamson[m] puffnfresh optimizationproc naviknair7[m] nh2[m] asm[m]1 georg3[m] strixy[m] srenatus daoo[m] bingen[m] testingriotnmatr lixiang4u[m] mrhania[m]1 Gratin[m] JanPath[m] PatrickM[m] dezren39[m] bustillo[m] neechoo saidinwot skeuchel supki Forkk zymurgy)
17:29:34 --- names: list (integral cyphase Jon william[m]1 braidn[m] ahf shikhin hiptobecubic Frans-Willem athan nnplv loli cheater Madars dan64 cjh` felixonmars riaqn esssing dzdcnfzd lionaneesh electrostat Tritlo zerokarmaleft gopnikovitch acowley CurryWurst dedgrant reactormonk twopoint718 Eduard_Munteanu averell edwtjo relyth[m] epta vimto glguy mnoonan fredcy bitemyapp Strix andyo Ornedan sqrt2 wildsebastian dpn` bjs Sigyn sagittarian mimi_vx bartavelle akkad zeroed dh eddsteel)
17:29:34 --- names: list (ids1024 johnw Jello_Raptor agrif wagle mou sdrodge Guest88515 iross mitch_ am2on jollyrogue[m] trikl[m] jvalleroy[m] zineje[m] Makinit Overload[m] emme[m] vsts[m] Frytka[m] gpunk[m] Bimmie[m] ThousandLions[m] stuebinm[m] ArchieT foo123[m] phittacus wizonesolutions solidsnack ocharles joel135 Kamuela hansihe wyvern bgyss gridaphobe ecx86 fingerzam simony zph ephemera_ Scorchin oh_lawd oldsnakey alvinsj marcel rjungemann mbrock kyagrd sclv monad_cat spinda)
17:29:34 --- names: list (AlainODea prizim llinguini customminer pranz squisher cgag zekt yoho bogdanteleaga reptar_ sw1nn jokester scinawa xnyhps drdo MarcWeber LeaChim dutchie malt3 infandum solarus duairc ianp jzeus nwf Purlox padre_angolano EvanR marble_visions yeshacker Adluc Matthew[m] nahra plll[m] Masaomi[m] anaxios beaky M-herah davidar_ rakete SuperW[m] magog[m] riadvargas[m] vitamin-q aspiwack[m] vakili[m] Niboor[m] gelidae[m] chominist[m] Shaunthesheep[m] srhb tuxitagnu[m])
17:29:34 --- names: list (saci[m] PyroLagus SuperTux88 amatecha jorendorff bitonic Ring0` xplat|work runawayfive mpickering nbouscal pikolinosimo japesinator ianconnolly salva toure WarzoneCommand ixian RaptorJesus Ewout heath ambrosia Drezil Magemanne bengt_ jle` defanor Guest6493 fgaz zmt00 coeus laplacian groscoe ck_y wrengr_away Chobbes jordanlewis Unode tjbp vaibhavsagar quicksilver kav arne tromp_ Benzi-Junior tureba Robin_Jadoul bind jtz typetetris zge chindy abra0 elomatreb)
17:29:34 --- names: list (ichigo mmaruseacph2 shiona klugez pandem `0660 SpaceKnight OnkelTem jan-sipr liyang Jonno_FTW Athas max-m Wamanuz2 saltykawaiineko[ xpoqp toppler Akii jdevlieghere koala_man jedai milli Flonk Cale bjobjo miklcct AntiSpamMeta dpanth3r MasseR raatiniemi Ranhir mniip yahb rootnode matchray rotaerk nisstyre philosaur dumptruckman n1 zomg colescott TallerGhostWalt anonguest[m] amiri m0rphism dpepsilon arianvp SCHAPiE revprez ego nhan2 amuck linduxed metahumor)
17:29:34 --- names: list (jameseb Taneb niko grumble PsyDebug ClaudiusMaximus scav Maxdamantus tabaqui alsoStevenXL Disavowed grayhatter noxd eL_Bart0 tomku gxt Clint jimmyrcom_ rostero nopf ski ft eboettch hvr Liskni_si Moyst __name__ acro delYsid idupree harmaahylje uptime Fairy erikd bq aberrant_ mrd Raptor8m3 c-rog platz oberstein lycium[m] arw webstrand a3f Kevin[m]3 echoreply daumie kosmikus megaTherion jrm mearnsh Phyx- michi7x7 wto _6a68 deba5e12 parsnip ezyang PlasmaStar)
17:29:34 --- names: list (bshelden mendez int0x27h kloeri int-e lmart[m] Nikotiini tortal jix nkaretnikov chrzyki kebertx[m] M-BostonEnginerd wedify Dykam Princess17b29a cheshircat prooftechnique treehaqr sanitypassing Chousuke sbrg s4msung Gabscap insanitymug Ke cstrahan mikedlr spicydonuts Chadtech prefork zachary12 hrnz noctux CindyLinz mrBen2k2k2k huaw lukeshu swalladge obiwahn pta2002 pyrtsa jerin[m] foreseaz[m] superpat[m] charlag[m] Zowlyfon tripty DDR ralu deni fredsir dustinm-)
17:29:34 --- names: list (trosa kipras Fubar^ Vq valkyr2e Philonous kaychaks bgamari aidecoe Solarion ninegrid mxf electrocat cods fiatjaf dpower nemesit|znc Soft Jinxit segin crooked gspia whiteline mdarse Majiir cromachina julmac nullie ggVGc divVerent MarcelineVQ carc noplamodo staffehn poga numberten mauke quaestor kuno Zoddo mlen simon ircbrowse NinjaTrappeur rom1504 bb010g M-x-matrix[m] LucasFrancesco[m hendrik[m]2 xffox[m] Obscurity[m] Bigcheese mak` otulp tjpeden tomaw tumdedum)
17:29:34 --- names: list (noobst fbauckho reu hackage akemot Tehnix peterhil sellout zzq heinrich5991 d6e Uniaika lugh JoelMcCracken SuprDewd jonge HalfEatenPie jstolarek nille Profpatsch eagleflo pita hpc Xorlev AWizzArd raek freeman42x turt2live Jikstra[m] M-ms cdal sa1 cdornan_ synopz[m] zpconn__________ nak verlet64 mbeidler mbrcknl_ runde orion kmicklas[m] Guest1573[m] infty[m] guyinjeans[m] ArrayWindrunner[ dbramucci[m] porcow[m] djangoblockchain mrdaak[m] bmjh dirb guest69[m])
17:29:34 --- names: list (sudom0nk[m] Mougan[m] Nerka[m] Cadey[m] Deleh[m] thekyriarchy__ peel[m] intheclouddan laaksoan[m] levzhazeschi[m] dkellner[m] AX3L[m] cwgoes[m] izahn[m] idnar[m] Stratege fall_ M-krsiehl fiddlerwoaroof_ Zialus tsani PotatoGim OliPicard m1dnight_ binaryblade jared-w lambdabot RevJohnnyHealey brixen_ gsingh93 gothos wladz_ mathu pfoetche1 anishath1lye lpsmith mozzarella ikopico llwu Nik05 capisce pacak Enigmagic Fylwind- sethetter TommyC hydraz Ninja3047)
17:29:34 --- names: list (MindlessDrone d3lxa x1n4u teej dibblego marmalodak incomprehensibly knmae janne- Dodgy-Debaser_ valdyn wting atomi hiredman timothyh_ ebutleriv Zebrah cynick paroxp wtw koz_ ekr greeny cow-orker pdgwien MalfaitRobin polux36 pharaun relrod vin-ivar detoxin jrslepak alp Zemyla ncl28 przemkovv nurupo carbolymer Hafydd bno1 benonsoftware lassulus asm89 lpvb tinco lavalike Eagle_Erwin phz_ ijp APic sunya7a phadej orzo Gabemo Deewiant k navilan- cross c0dyr statusbot)
17:29:34 --- names: list (ByronJohnson ectos mindtree parseval isaac__ thi_ changyj jonrh oak- Ankhers tnks butterthebuddha ynyounuo bsmt joncfoo ccase juri_ caasih magicman pikhq Reisen LnL theorbtwo dgpratt gilbertw1 Cheeky-Celery alek cnomad jswe bluepixel adamCS kubrat TMA mantovani michalrus ggherdov gleber_ rodarmor gareth__ darthThorik elvishjerricco chriswk fuziontech dstockwell ryanbooker rgrinberg carter eacameron banjiewen ghuntley terrorjack Argorok niveus kipd milessabin)
17:29:34 --- names: list (angerman bigs libbyk shans_ mkurkov_ Meow-J_ pchiusano twomix rizary Wizek rightfold gornikm peschkaj codedmart Cir0X dashed etrepum CARAM___ micmus paf31 ranberry lexi-lambda bradparker ericbmerritt_ billstclair bytesighs Guest32984 vikram__________ jml posco centril petercommand earthy vqrs thebnq jorj Willis Deadhand eikke fairfieldt dschoepe Fuuzetsu kshannon_ xa0 luigy nilOps betawaffle Tristan-Speccy WhereIsMySpoon_ jbalint Warrigal crlane wayne tdammers)
17:29:34 --- names: list (oleks kody^ ahf_ @ChanServ Skarn rotty Igloo kini ec2-user_ foolswood Eliel davean saftsuse joeytwiddle ij garphy ernst Paks pdxleif Gothmog_ fergusnoble catern sleepynate benzrf dysfun andjjj23 Hijiri jaargon mitchty c_wraith ramatevish Burnout641_ NemesisD lyxia edran reinh1 geal syamaoka brent80_plow tippenein robogoat fugyk richi235 markhuge Someguy123 blackdog spion tek0_ jackhill armlesshobo Oipo1 Squarism DwarfMaster deu aijony lieven inr xxpor_ sns)
17:29:34 --- names: list (Novitsh so pasukon noexcept ephemeron Cathy seliopou [df]_ anoe raid soncodi nonzen gargawel abrar ksj zenzike kapu tzaeru froztbyte peddie anderson hongminhee rofer danzimm twk- StianL kfish PHO Biohazard aatxe cic aib destiny_ yarou ongy hjklhjklhjkl suzu shapr mgaare croben exio4 ycheng jzl n3parikh karls henrytill DoubleJ joeyh papapishu lokydor Xandaros absence daft tokik mattp_ Adeon Cheaterman Desoxy_ monte gareth__- stefan- Sornaensis brisbin SlashLife)
17:29:34 --- names: list (MagneticDuck vodkaInf1rno cesardv flori Randy nikivi Xnuk Yaiyan emmflo _cyril_ wamaral surtn bus000)
18:09:41 <shapr> Does anyone know of example code that connects a Data.Bytes binary parser and a network socket?
18:18:06 <srk> shapr: I do have Data.Binary and sockets if it helps
18:18:25 <shapr> srk: yes please!
18:18:30 <srk> shapr: https://github.com/vpsfreecz/haskell-zre/blob/bbc703e3e281ed197380531603cdd4c52b2cc480/attic/zre.hs#L147
18:18:44 <srk> shapr: sendTo s (zreBeacon uuid port) addr
18:18:52 <srk> zreBeacon is constructed right after
18:18:53 <shapr> thanks!
18:19:24 <shapr> that's simpler than I expected
18:19:32 <srk> it's an udp beacon broadcaster for ZRE
18:19:49 <srk> on top there are ZMQ sockets as well, quite simple as well
18:20:01 <srk> as well
18:20:20 <srk> is there something like json-autotype for xml?
18:20:37 <shapr> srk: why use binary instead of cereal or Data.Bytes?
18:20:43 <shapr> I don't know the tradeoffs
18:21:36 <srk> not sure actually, it's been a while. but it was quite easy to write parsers by hand and there's bunch of conditional logic in them
18:22:16 <shapr> ok, sounds good
18:26:01 <ALandis> I am looking for ways to speed up compile times. Does anyone have experience with this?
18:27:01 <ALandis> Specifically, I am curious if adding cores could help. I know that increasing clock speed helps but am under the impression it runs in a single thread
18:29:30 <shapr> ALandis: as far as I know, there's not much you can do to compile one single module faster, but if you have a bunch of modules in your project, those can all be compiled separately
18:29:56 <shapr> I'm pretty sure cabal does that, not sure about stack
18:30:12 <shapr> I think stack can compile a bunch of package dependencies at the same time
18:31:57 <srk> also consider running ghcid during development, it can recompile stuff quite fast
18:32:49 <srk> I mostly use stack build --file-watch --exec now though
18:34:05 <srk> I was thinking of a distributed compiling support for cabal (there's a github issue for that iirc). also there were some reports of people using distcc with ghc
18:34:35 <srk> I would like to try adding zre as a backend to cabal so peers can be autodiscovered and used as builders
18:35:09 <ALandis> shapr: I've broken out some namespaces into separate modules, thats helped a little bit. Do you mean that modules can be compiled concurrently?
18:35:25 <srk> if they don't depend on each other
18:35:45 <ALandis> they do...
18:36:33 <ALandis> i use intero in emacs, it helps realtime dev feedback - however, reloading a namespace it seems to recompile every imported namespace even when no changes were made
18:36:49 <ALandis> seems like that is very non optimal and suprising
18:37:17 <ALandis> one theory i have is that the use of template haskell is slowing things down on all fronts (intero and stack build)
18:38:26 <srk> that's quite possible, I've heard people say that before
18:39:09 <shapr> yeah, Template Haskell can be slow
18:39:51 <shapr> ALandis: are you using stack or cabal?
18:39:56 <ALandis> stack
18:40:05 <shapr> srk: I've heard that buckbuild can do that, but I've not tried it myself.
18:40:34 <shapr> ALandis: I have *heard* that stack cannot compile multiple modules at the same time, but that cabal, especially cabal new-build, can do that.
18:40:39 <shapr> I haven't compared them myself.
18:41:00 <srk> that's java! /o\
18:41:05 <srk> and their build is failing :D
18:41:24 <srk> Get correct incremental builds. Buck looks at the contents of your inputs, not their timestamps to figure out what needs to be built. As a result, incremental builds should always be correct, so there's no need to perform a clean build.
18:41:28 <srk> sounds like nix!
18:42:03 <ALandis> skr: buckbuild works with haskell?
18:42:14 <shapr> srk: cabal new-build is documented as "nix style". But I've still not done more than install and play with nix
18:42:37 <srk> cool, didn't know about new-build
18:43:10 <srk> but I really like nix/nixos and nixops, seems like it's gonna solve most of my linux troubles
18:44:04 <ALandis> nix is great for sure
18:44:28 <srk> oo, package.yaml, that's new as well! :D
18:44:33 <ALandis> shapr: so you are recommending try cabal new-install as a potential speedup vs stack?
18:45:06 <srk> looks like no more repetition of dependencies \o/
18:45:16 <srk> is there a tool to autoconvert?
18:48:06 <srk> ah, .cabal is now generated
18:50:26 <shapr> ALandis: yeah, it might help
18:50:45 <shapr> ALandis: though my solution was a quad xeon laptop with 64gb of ram :-)
18:53:35 <srk> same here kind-of :D until my codebase gets too large for single PC it's ok
18:54:23 <ALandis> shapr: so adding cores scales build performance? because i'd get a 8 or 16 core xeon if so
18:56:04 <srk> they get crazy expensive at like 10-12 cores
18:56:14 <srk> maybe ryzen?
18:56:56 <srk> nah, threadrippers
18:57:10 <ALandis> with build times currently 3-5 minutes, it would be worth it for me
18:59:39 <shapr> ALandis: if your Template Haskell is taking a long time to build, could you split that part into a separate package so it's not rebuilt everytime?
19:00:09 <ALandis> It is, but i still feel it is having an effect
19:11:17 <Welkin> did stack change the directory where it places the build?
19:11:33 <Clint> to /welkin
19:12:43 <Welkin> it's under .stack-work/dist/<system>/Cabal-2.0.1.0/build/<name>/<name>
19:12:45 <Welkin> o.o
19:13:05 <Welkin> should be under .stack-work/dist/build/<name>/<name>
19:13:22 <Welkin> so `stack install` complains and it doesn't copy the file over to my local bin
19:14:04 <Welkin> oh, no
19:14:32 <Welkin> it's looking in .stack-work/install/<system>/<lts-version>/<ghc version>/bin
19:14:34 <Welkin> what?
19:15:13 <Welkin> maybe my manual upgrade from one stackage lts to the latest broke something?
19:15:36 <Welkin> it's very annoying to have to manually copy the binary over
19:15:44 <Welkin> it completely defeats the purpose of `stack install`
19:15:52 <Welkin> at this point it is identical to `stack build`
19:16:59 <sm> "my manual upgrade" sounds.. suspicious
19:17:27 <Welkin> well
19:17:41 <Welkin> I just changed the lts version in my stack.yaml, removed .stack-work
19:17:45 <Welkin> and then rand `stack install`
19:18:20 <sm> ah. fair enough
19:18:51 <Welkin> running stack 1.6.3
19:18:58 <Welkin> no one else has this issue?
19:19:11 <sm> upgraded stack recently ? maybe it's built with a different Cabal version or something ?
19:19:21 <glguy> Welkin: The issue of running stack?
19:19:23 <sm> try stack upgrade ? issue tracker ?
19:19:32 <Welkin> I'm looking on the issue tracker now
19:19:58 <Welkin> and yes, I updated stack before installing the new lts
19:20:09 <glguy> Welkin: Maybe the different resolver uses a different cabal?
19:20:31 <Welkin> but I deleted .stack-work entirely to start fresh
19:20:49 * sm thinks an additional stack clean is sometimes helpful
19:21:01 <sm> and there can be more than one .stack-work
19:22:01 <Welkin> oh
19:22:05 <Welkin> you mean ~/.stack ?
19:23:11 <sm> no, I think I get a .stack-work in top project dir and in each subpackage subdir
19:23:47 <Welkin> what is the correct way to upgrade?
19:24:18 <sm> your resolver ? Just change it in the stack.yaml, as you did
19:24:43 <Welkin> https://github.com/commercialhaskell/stack/issues/2065
19:24:50 <Welkin> that is old though
19:24:52 <Welkin> but still open
19:24:54 <hobnobh> is there anything existing that updates the state of a StateT while keeping the current result? I did it like this: http://lpaste.net/7177320883432718336
19:25:10 <hobnobh> also is there a better way to do that, besides the functor law thing the linter there suggests?
19:31:09 <Welkin> okay...
19:31:12 <Welkin> I just fixed it
19:31:26 <Welkin> it looks like, for some reason, a warning was causing it to break
19:31:50 <Welkin> I don't have a README at all, but it is listed in my .cabal file by default (from the template)
19:31:58 <Welkin> I removed that and it works now
19:32:53 <glguy> update m s = m <* put s -- hobnobh
19:40:50 <sm> Welkin: yay. Presumably it was telling you this somewhere in the output ?
19:41:11 <Welkin> yes
19:41:23 <Welkin> but it makes no sense why it would break the --copy-bins option
19:42:27 <sm> well, I'd think it has to decide the build was successful before it copies
19:42:51 <sm> perhaps your new stack version does stricter validation
19:44:48 <kadoban> IIUC it's not really stack trying to be picky, it's the part of Cabal or whatever that stack is using to build stuff insists on being picky about that. So it's not really intentionally doing that, it's just annoying to make it not do that.
19:51:47 <MarcelineVQ> kadoban: do you have a link to the explanation for that? it was in a ticket yeah?
19:53:13 <kadoban> Not offhand, I know there must be issue(s) related to it in the tracker though, the one that comes to mind is every once in a while someone runs into that same thing, usually with the LICENSE file.
19:53:22 <kadoban> I can look for it in a little bit if you can't find it
19:57:03 <Welkin> it's not a high-priority bug, but is annoying
19:57:35 <kadoban> It's fairly bad, yeah.
19:58:15 <kdkdkdkdk> @pl meme x = x > 1 && x < 2
19:58:15 <lambdabot> meme = liftM2 (&&) (> 1) (< 2)
19:59:13 <kadoban> xD
20:03:25 <rtyui> @pl isLeapYear x   | mod x 400 /= 0 && mod x 100 == 0 = False   | mod x 4 == 0 = True   | otherwise = False
20:03:25 <lambdabot> (line 1, column 52):
20:03:25 <lambdabot> unexpected " "
20:03:25 <lambdabot> expecting operator
20:03:36 <Welkin> wtf?
20:04:01 <Welkin> drive-by spamming is in fashion now?
20:04:56 <glguy> Welkin: It's the same user both times
20:05:04 <kadoban> Someone is doing ... exercism.io is that one? I forget where that problem is from
20:05:55 <Welkin> lambdabot is not an exorcist
20:08:23 <kadoban> It should be, my code could often use one.
20:11:06 <Welkin> point-free strikes again!
20:11:19 <Welkin> I'll make not of this
20:11:39 <Welkin> don't introduce point-free to someone until they have a very good understanding of haskell
20:11:44 <Welkin> make note of this*
20:25:42 <Welkin> if I want to change the name of a project, is there anywhere I need to update it for stack?
20:25:50 <Welkin> or is updating it in the .cabal good enough?
20:26:09 <kadoban> Welkin: That should be it
20:26:15 <MarcelineVQ> unless you have a project.yaml the cabal file is appropriate
20:26:20 <Axman6> the Data61 course makes a point of showing that it is always _possible_ to make an expression point free because we can arbitrarily rearrange parts mechanically to avoid points - it's used not to show you should write pointfree code, but that you can
20:26:49 <Axman6> re: Welkin's point
20:27:19 <Welkin> I had a simple point-free expression that I wanted to map `read` over, and it was giving me all kinds of errors
20:27:38 <newguy> has anyone ever come across a comonad version of traversable? something with a function (Comonad w) => t (w a) -> w (t a) ?
20:27:44 <Welkin> until I finally realized that I had to compose with `fmap read` instead of just `read <$>`
20:28:28 <newguy> do they exist in the wild at all?
20:29:06 <Welkin> there is no wild
20:29:12 <Welkin> all programs are artificial
20:29:24 <Welkin> unless it is some self-programming AI
20:30:56 <newguy> Welkin: well I still can't come up with any examples
20:31:30 <newguy> It seems like it should be an interesting structure
20:31:31 <jle`> newguy: Identity
20:31:39 <newguy> thats the only one?
20:32:27 <Axman6> newguy: surely there would have to be some restriction on t as well, as there is with Traversable
20:32:47 <jle`> i think we're talking about examples of 't' where such a function would exist
20:33:00 <jle`> but you probably have to add in some laws too to get useful answers
20:33:37 <newguy> I meant what jle`  said
20:33:57 <newguy> something like "Cotraversable"
20:34:19 <newguy> where you replace sequence with the signature I wrote before
20:34:22 <jle`> most of the Traversable instances i can think of don' count
20:34:29 <Axman6> I'm goint to take a stab at this being something that already exists, and is hiding somewhere in lens
20:34:49 <newguy> The way it came up was that
20:34:58 <jle`> you can write a typechecking version for NonEmpty
20:35:11 <newguy> hm
20:35:12 <jle`> but i'm not sure if it follows our hypothetical laws
20:35:36 <jle`> foo (x :| xs) = (:| []) <$> x
20:37:18 <newguy> yeah I really have no idea
20:37:51 <Welkin> damn it
20:38:02 <Welkin> stack still names the executable with the old name
20:38:16 <jle`> it should name the executables as whatever is in the cabal file/package.yaml
20:38:28 <jle`> you get to name the executables whatever you want :)
20:38:34 <jle`> it doesn't have to be related to the package name
20:39:02 <Welkin> I can?
20:39:08 <jle`> yeah
20:39:09 <Welkin> how do I do that
20:39:13 <jle`> where it says 'exectuable blahblah'
20:39:18 <jle`> you define your executables :)
20:39:18 <Welkin> and where is it getting the old name from?
20:39:29 <jle`> the cabal file has a section where you get to specify your executables
20:39:33 <Welkin> I changed the filename of the .cabal and the `name` parameter
20:39:40 <Welkin> oh, lol
20:39:43 <Welkin> I forgot about that
20:39:45 <Welkin> totally missed it
20:39:50 <Welkin> must be because it is bright blue
20:39:57 <kadoban> :)
20:39:59 <jle`> yeah, the project name changes, but the executable name is independent of the project name
20:40:09 <Welkin> thanks jle`
20:40:45 <newguy> speaking of lens
20:40:55 <newguy> what is the best way to start learning it?
20:40:56 <Welkin> we were?
20:41:09 <newguy> someone mentioned that I might find something in lens
20:41:13 <Welkin> I don't think you ever learn lens
20:41:19 <jle`> newguy: the lens library itself has a nice tutorial/introduction
20:41:29 <Welkin> you just use what you find useful
20:41:43 <newguy> I saw that, but
20:42:01 <newguy> I have a decent categorical background
20:42:10 <newguy> I feel like I understand the derivation for profunctor optics
20:42:26 <newguy> I know the theory, just not the practice
20:42:43 <jle`> the lens library tutorial only talks about practical things :)
20:42:46 <newguy> are there any tutorials that take a bottom up approach?
20:42:48 <jle`> and nothing about profunctor optics
20:43:06 <newguy> everything I can find is very top-down
20:43:15 <jle`> you mean, a tutorial about how it is implemented?
20:43:16 <newguy> "here's how to use it. don't look at the types, etc."
20:43:26 <jle`> that sounds like the least useful thing if you want to be able to use it practically, heh
20:43:32 <jle`> but 'lenses over tea' is a nice series about the theory of it in a nice way
20:43:35 <Welkin> newguy: you want edwardk's lens talk found one youtube
20:43:41 <Welkin> it's 2 hours long, I think
20:43:50 <x77686d> I happened to notice that :info !! doesn't show an 'infix...' declaration.  Anybody know why that is?  (Just curious...)
20:44:00 <newguy> https://www.youtube.com/watch?v=l1FCXUi6Vlw
20:44:13 <jle`> x77686d: it only shows an infix declaration if one is explicitly given/defined in the source
20:44:14 <newguy> this was the thing I watched
20:44:25 <jle`> if none is given then the default is used
20:44:46 <Welkin> newguy: lol wtf is with that intro?
20:44:47 <Welkin> hahaha
20:44:54 <Welkin> they made it looks like someone's vlog
20:44:58 <Welkin> oh god
20:45:01 <newguy> I was able to follow the derivation
20:45:22 <newguy> from getter settter pairs to that stuff
20:45:24 <Welkin> newguy: this is the talk you want https://www.youtube.com/watch?v=cefnmjtAolY
20:45:38 <jle`> newguy: sounds like you got the bottom, you just need the top :)
20:45:54 <newguy> so meet in the middle?
20:46:45 <newguy> alright then.
20:46:56 <jle`> it also helps to use libraries that have API's built around lens
20:46:57 <Welkin> ace ventura?
20:47:04 <jle`> wreq is a nice one
20:47:06 <jle`> lens-aeson too
20:47:10 <jle`> or was it aeson-lens
20:47:13 <jle`> i always mix it up
20:48:06 <newguy> yeah, that sounds helpful
20:48:32 <newguy> honestly the think I want most is just exercises
20:48:46 <jle`> you can always just throw in lens as a drop-in replacement to what you're already doing
20:48:57 <jle`> instead of directly using accessors and record syntax for setting, you can use lens getters and setters
20:50:02 <newguy> yeah, I was just wondering if there was something more structured
20:50:44 <newguy> that would let me nicely tour the different features
20:51:07 <Welkin> you'll have to make your own adventure
20:51:16 <newguy> you're right though. Its probably best just to use it and learn features as I need them
20:58:15 <x77686d> jle`: thx re !!.  I was thinking there needed to be an infix declaration(?) for !! to be usable as an operator but my knowledge is limited.  I do see 'infixl 9  !!' in base-4.10.1.0/docs/src/GHC.List.html.
20:59:48 <glguy> Since !! has the default fixity it isn't displayed
21:00:17 <glguy> Things don't need an explicit infix declaration to be used infix, it just allows you to override the associativity and precedence if you have one
21:00:50 <glguy> > 3 `elem` 2 : 3 : 4 : []
21:00:55 <lambdabot>  True
21:01:18 <glguy> You can even give fixity declarations for normal identifiers: infix 4 `elem`
21:05:44 <x77686d> glguy: thx
21:12:11 <jle`> huh i didn't realize that ghci hid infixl 9 declarations
21:13:45 <c_wraith> It probably doesn't distinguish an explicit infixl 9 declaration from no declaration
21:23:55 <jle`> i am making a new library but i can't think of a good name so i cannot even start working on it
21:24:23 <c_wraith> Is "Ted" taken?  It's the best name.
21:24:52 <jle`> Ted is not taken
21:24:58 <MarcelineVQ> jle`: gravitaxis
21:25:45 <jle`> ted-gravitaxis
21:26:03 <c_wraith> you're set.  you may now proceed without issue
21:26:26 <jle`> TeD-gRaViTaXiS in case it doesn't stand out
21:26:45 <MarcelineVQ> tbh I could see a family of packages prefixed with ted-
21:28:36 <newguy> I think comonad traversable should be called Extendable
21:28:41 <newguy> is that a good name?
21:28:45 <MarcelineVQ> whatever you do, be as cute as possible with naming so no one can possibly find your lib, especially if it's useful. use the handy dandy rule:  usefulness is inversely proportionate to findability
21:28:57 <MarcelineVQ> ^ that's for jle hehe
21:29:27 <edwardk> It is called Distributive
21:29:58 <MarcelineVQ> do you have comonad set to ping you? :>
21:30:02 <edwardk> (It winds up needing only Functor not Comonad, though)
21:30:07 <edwardk> MarcelineVQ: maaybe
21:30:08 <jle`> MarcelineVQ: i'll just spell the functionality of the library backwards
21:30:20 <jle`> MarcelineVQ: i mean, it's a part of the name of his blog
21:30:30 <edwardk> i try to rotate my keywords, comonad is in this week =)
21:30:36 <jle`> i have my blog url on ping too :)
21:31:14 <newguy> edwardk where is the best place to learn about Distributive?
21:31:30 <jle`> there's https://hackage.haskell.org/package/distributive-0.5.3/docs/Data-Distributive.html i suppose
21:31:31 <Axman6> right here, by forcing edwardk to tell you all about it
21:31:38 <newguy> wait, its just a distributive law
21:31:45 <edwardk> http://hackage.haskell.org/package/distributive is a decent start
21:31:51 <edwardk> newguy so is traversable ;)
21:32:09 <newguy> but distributing only over comonads?
21:32:14 <edwardk> functor in this case
21:32:15 <newguy> thats what distributive does?
21:32:18 <edwardk> and the other way around
21:32:23 <edwardk> from how traversable works
21:33:32 <newguy> hmm ok
21:34:41 <newguy> the reason I ask is I was trying to write catamorphism and anamorphism using kleili arrows instead of normal arrows
21:34:47 <newguy> and I realized I needed traversable
21:35:13 <newguy> so I wondered what would happen if I did cokleisli arrows
21:39:06 <righ> Attention! If you are using FreeNode, consider that you *must* obey scientific, political and historical beliefs of a small group of people that own that private network, otherwise you will be restricted access, read more: https://pastebin.com/E7QNnjDR
21:39:29 <Axman6> urgh
21:39:36 <Axman6> probably don't click that
21:41:12 <einstein> Attention! If you are using FreeNode, consider that you *must* obey scientific, political and historical beliefs of a small group of people that own that private network, otherwise you will be restricted access, read more: https://perl.bot/p/ww9wz9
21:42:45 <jle`> well, if einstein says so
21:43:12 <MarcelineVQ> the unfortunate price of a free service
21:43:56 <MarcelineVQ> seen a lot worse :>
21:51:38 <jle`> my library won't be called ted
21:51:40 <jle`> but rather hted
21:51:45 <jle`> to remind people that it's in haskell
21:51:52 <jle`> in case they forget
21:53:43 <n_blownapart> hi can you use traceShow on more than one argument , in one expression?
21:54:20 <jle`> what do you mean
21:54:42 <n_blownapart> thanks let me paste it jle`
21:54:42 <dmwit> % import Debug.Trace
21:54:43 <yahb> dmwit:
21:54:52 <dmwit> % traceShow (3, 4) 5
21:54:52 <yahb> dmwit: (3,4); 5
21:56:14 <dmwit> % traceShow 3 $ traceShow 4 5
21:56:14 <yahb> dmwit: 3; 4; 5
21:56:20 <jle`> % traceShow 3 (traceShow 4 5)
21:56:20 <yahb> jle`: 3; 4; 5
21:56:22 <jle`> aw man
21:56:36 * dmwit high fives jle`
21:56:50 <n_blownapart> I know this is wrong, see moves func : https://ptpb.pw/m0V-
21:57:10 <Axman6> k-lined within a second, that URL doesn't work
21:57:13 <Axman6> uh
21:57:18 <Axman6> that URL doesn't work*
21:57:43 <Axman6> or maybe it does and my terminal forgot that - can be in urls
21:57:44 <jle`> traceShow (m, p) False
21:57:51 <jle`> traceShow m . traceShow p $ False
21:58:02 <Axman6> n_blownapart: just stick the multiple elements in a tuple
21:58:19 <n_blownapart> thanks checking that
21:59:11 <jle`> i ended up giving my library a 4 letter name that i'm sure people won't hate me for taking
21:59:17 <n_blownapart> weird, so its expecting a tuple there
21:59:27 <jle`> n_blownapart: it expects anything showable
21:59:32 <jle`> % :t traceShow
21:59:32 <yahb> jle`: Show a => a -> b -> b
22:00:27 <n_blownapart> jle`, sorry I don't quite get that signature
22:00:30 <n_blownapart> on Show
22:00:53 <n_blownapart> oh the second arg is Bool
22:00:56 <jle`> Show a => a -> b -> b
22:01:09 <jle`> it's an `a -> b -> b`, where 'a' has to be an instance of Show
22:01:09 <n_blownapart> or False
22:01:51 <mjrosenb> bah, does anyone remeber the comment you need to put at the top of a file to get ghc to turn on type families?
22:02:02 <mjrosenb> and what it is called? my google fu is failing me.
22:02:02 <jle`> {-# LANGUAGE TypeFamilies #-}
22:02:19 <jle`> i don't type it myself anymore, though, i have an autocomplete do the {-# LANGUAGE ... etc. for me
22:02:30 <n_blownapart> so the False = undefined part isn't required jle`   ?
22:03:10 <jle`> if you leave it off, it'd be a syntax error
22:03:25 <jle`> are you familiar with 'guard' syntax
22:03:40 <n_blownapart> yeah,  thats like a predicate that has two parts, the instance of Show and False
22:04:02 <jle`> hm, not quite
22:04:05 <n_blownapart> after the guard you would say the lhs is a predicate?
22:04:13 <jle`> it's a Bool
22:04:59 <jle`> essentially, `moves m p | blah = ....` is a guard where the function will only go down that path if 'blah' is True
22:05:10 <jle`> so `moves m p | False = ...` is a guard that will always fail
22:05:59 <jle`> but `moves m p | blah = x`, `moves m p` will evaluate to 'x' if blah is True
22:06:03 <jle`> that's what the "= x" does
22:06:23 <n_blownapart> thanks hold on pls
22:06:25 <MarcelineVQ> I like that path idea "a path that will never be taken" has less other ideas crammed into it than fail does
22:06:25 <jle`> oh huh i just realized, maybe you're not sure how traceShow works or why it takes the 'b' argument
22:06:55 <n_blownapart> its a bit confusing right now
22:07:19 <jle`> 'traceShow x y' will evaluate to 'y'
22:07:34 <ggVGc> why do my projects always have a Misc module :(
22:07:38 <ggVGc> I feel shit every time I create it
22:07:58 <jle`> and, in the process of evaluating to 'y' (if 'y' is ever evaluated), it will emit 'x' to stderr
22:08:02 <jle`> (show x)
22:08:04 <n_blownapart> oh so we don't get undefined there
22:08:18 <jle`> so 'traceShow x False', as an expression, evaluates to False
22:08:39 <jle`> so `moves m p | traceShow (m, p) False = ...`
22:08:47 <jle`> evaluates to `moves m p | False = ...`
22:08:59 <MarcelineVQ> ggVGc: call it Util and you'll feel better
22:09:18 <jle`> except, in the process of evaluating 'traceShow (m, p) False` to `False`, `show (m,p)` is emitted to stderr
22:09:42 <n_blownapart> emitted?
22:10:10 <jle`> shot out of
22:10:16 <jle`> projectile launched
22:10:17 <n_blownapart> so that's just how traceShow works, it is printed as a sort of error, but you get the results you want
22:10:44 <n_blownapart> now I know how to use trace like it works in scheme
22:11:17 <n_blownapart> thanks jle`
22:11:19 <jle`> it probably doesn't work like it does in any other language
22:11:35 <n_blownapart> the results look very nice though
22:11:39 <jle`> think of it as a RTS hook
22:11:51 <n_blownapart> no capiche
22:13:33 <n_blownapart> so its always takes a tuple, or where you have traceShow (n) so similar ?
22:13:42 <n_blownapart> *or similar
22:14:04 <jle`> n_blownapart: the thing it pops out to stdout is any value that has a Show instance
22:14:07 <jle`> so it doesn't have to be a tuple
22:14:11 <jle`> it can be anything with a Show instance
22:14:40 <n_blownapart> thanks theres a lot to it, huh.
22:15:14 <jle`> GHC has a runtime system that evaluates items and stuff
22:15:34 <jle`> usually the process of evaluation doesn't produce any side effects
22:15:41 <jle`> any IO
22:15:58 <mjrosenb> jle`: danke.
22:16:16 <jle`> but 'traceShow x :: a -> a` is a function that annotates a value to GHC, so it knows that when it tries to evaluate that value, it'll print out 'x' to stderr
22:16:24 <jle`> it's like an RTS hack
22:16:55 <n_blownapart> thanks jle` I need to look that up
22:17:09 <jle`> no problem!
22:17:18 <n_blownapart> I'm not a programmer
22:18:11 <jle`> same
22:40:43 <mjrosenb> @hoogle [Either a b] -> ([a],[b])
22:40:44 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
22:40:44 <lambdabot> Data.List.HT unzipEithers :: [Either a b] -> ([a], [b])
22:40:44 <lambdabot> Text.XML.HXT.DOM.Util partitionEither :: [Either a b] -> ([a], [b])
22:42:58 <olligobber> :exf Either a b -> Maybe a
22:44:45 <MarcelineVQ> exferenceBot is tired I think :>
22:55:48 <cemerick> Can anyone explain why the second coercion to Foo here yields a stackoverflow? https://repl.it/repls/PointlessWealthyQueenant
23:00:04 <cocreature> cemerick: because for negative literals, fromInteger will turn into "negate (fromInteger 5 :: Foo)". you then get into an infinite loop between negate and - since the default implementations are defined in terms of each other and you’ve defined neither of those
23:00:04 <MarcelineVQ> (-5) is negate 5     you haven't defined negate for your Num instance, the default for negate is   negate x = 0 - x  you haven't defined - for your Num instance, the default implementation of   -   is  x - y = x + negate y   this is your  loop between negate and -
23:00:10 <MarcelineVQ> hehe
23:00:32 <cemerick> ah, I see
23:00:36 <cocreature> you can use the NegativeLiterals extension to change this behavior
23:00:42 <cemerick> cocreature, MarcelineVQ, thank you :-)
23:00:45 <cocreature> but really you should just implement one of those :)
23:01:05 <cocreature> there is a reason for the warning that you’ve disabled
23:01:23 <cemerick> heh, I was just trying to keep the REPL output clean for presentation here :-)
23:01:36 <cemerick> I'm just ~2 weeks into haskell, so appreciate the quality explanations
23:17:18 <hihk> how to get the elements which are duplicates in a list ["aaa","bbb","ccc","ddd","aaa","eee","bbb"]  output should be ["aaa","bbb"]
23:18:59 <int-e> hihk: does order matter? what about [1,1,1] as input, should that produce [1] or [1,1]?
23:19:02 <int-e> ...
23:20:04 <kadoban> map head . filter (null . not . drop 1) . group . sort
23:20:09 <kadoban> Oh ... and they're gone.
23:20:36 <int-e> null . not <-- hah
23:20:54 <kadoban> Woops
23:53:12 <jle`> > S.toList . S.fromList $ ["aaa","bbb","ccc","ddd","aaa","eee","bbb"]
23:53:17 <lambdabot>  ["aaa","bbb","ccc","ddd","eee"]
23:58:00 <ertes-w> hllo
