00:00:53 <jle`> heptahedron: the type 'n' refers to the length of the input vector but the value (singleton) 'n' refers to that length minus one
00:00:53 <heptahedron> jle`: Yeah--I knew the distinction, so I put them there on purpose, I'm just not sure those were the right type variables to put in those type applications
00:02:33 <jle`> heptahedron: i don't know the type of your append, but you probably would want to be appending a lengt-m vector with a length-(n-1) vector
00:02:45 <ertes-w> ello
00:02:45 <jle`> er, length-((n-1)*m)
00:03:21 <jle`> ello
00:04:33 <jle`> heptahedron: if append takes singletons, you would pass it (sing @m) and your 'n' singleton that came from your pattern match (which is @(n-1), in pseudosyntax)
00:04:50 <jle`> er, @((n-1)*m), not real operators/syntax
00:05:04 <heptahedron> jle`: I know I want the head of the type to be `AddNat m (TimesNat n' m)`, where `n'` is the predecessor of the type `n` from line 120, because `TimesNat`'s recursive case is defined like `TimesNat (S n') m = AddNat m (TimesNat n' m)`
00:05:24 <heptahedron> jle`: OH I think I miiight see what's going on
00:05:49 <heptahedron> jle`: my append type is `append :: forall n m a. (SingI n) => Vect n a -> Vect m a -> Vect (AddNat n m) a`
00:06:22 <infinisil> sr10: Take a look here: https://git.io/vN7cf
00:14:23 <infinisil> sr10_: Or in 1 function and a bit refactored: foldr (\(subject, student) -> M.adjust (student:) subject) subject marks
00:22:28 <heptahedron> jle`: oh! I think I got it. I think from now on I'll always write the explicit singleton-passing interface before I try to simplify to the SingI one lol
00:24:33 <heptahedron> I got it! sweet. I did not need dependent types for this project at all but hey it was fun
00:49:03 <johnw> heptahedron: if only I had a dollar for every time I've said that
00:52:08 <heptahedron> johnw: I can /kind of/ justify it because I'm generating some really simple fractal geometry, but there was no real imperative that needed to be reflected in the types lol
00:54:24 <Boomerang> heptahedron: It seems like a package like vector-sized might be useful to you. Here's a function similar to your merge: https://hackage.haskell.org/package/vector-sized-0.6.1.0/docs/Data-Vector-Generic-Sized.html#v:concatMap
00:54:59 <Boomerang> (I think your merge is basically `concatMap id`)
00:56:28 <heptahedron> Boomerang: I'm reinventing the wheel for the experience messing with dependent types, but that is a good vector lib, and that is what my merge is doing haha
00:56:47 <Boomerang> clash-prelude is pretty good for that kind of thing too (not sure how efficient it is though, ehich is why I recommended vector-sized first): https://hackage.haskell.org/package/clash-prelude-0.11.2/docs/CLaSH-Sized-Vector.html#v:concat
00:56:58 <heptahedron> Boomerang: I actually just got merge typechecking too!
00:57:20 <Boomerang> Great! :-) dependent can be fun but they are so time consuming!!!
00:57:30 <heptahedron> Now I'm working on flatten, which required me to make a new Nat type family for exponentiation haha
00:57:35 <Boomerang> s/dependent/dependent types/
00:59:53 <Boomerang> If you have a look at the vector part of clash-prelude, a function like dfold (dependently typed fold) may help you write something like flatten. Good luck!
01:02:38 <heptahedron> Boomerang: I'm purposefully struggling through this with as few hints as possible because I tend to simply read about the best solutions to things before I ever do any problem-solving on my own and I don't want to get too comfortable with that, but the notion of a dependently typed fold just made me realize I might have accidentally come across a sort of unfold in what I've made so far. thanks!
01:05:22 <EvanR> dependent type personality disorder
01:08:20 <heptahedron> EvanR: at this point I probably should go see a psych yeah
01:14:09 <EvanR> where everything looks like it needs and or is itself a dependent type
01:45:54 <infinisil> gotta love idris where dependent typing needs no additional syntax, because types are first-class
02:25:20 <Gurkenglas> Why is pos/peek not visible to lambdabot?
02:25:25 <Gurkenglas> @let import Control.Comonad.Representable.Store
02:25:27 <lambdabot>  .L.hs:48:1: error:
02:25:27 <lambdabot>      Control.Comonad.Representable.Store: Can't be safely imported!
02:25:27 <lambdabot>      The module itself isn't safe.
02:26:07 <Gurkenglas> :t (head . Control.Comonad.Representable.Store.pos &&& Control.Comonad.Representable.Store.peeks tail) . minimumBy (comparing $ head . Control.Comonad.Representable.Store.pos) . init . contexts -- improve pls
02:26:09 <lambdabot> Ord a => [a] -> (a, [a])
02:27:25 <infinisil> Ah so lambdabot uses safe haskell?
02:28:23 <Athas> It also uses some other sandboxing mechanism, doesn't it?
02:28:28 <Athas> Safe Haskell is not IO-safe, after all.
02:28:55 <Athas> > readFile "/etc/passwd"
02:28:58 <lambdabot>  <IO [Char]>
02:29:19 <Athas> > head . lines <$> readFile "/etc/passwd"
02:29:22 <lambdabot>  <IO [Char]>
02:29:34 <Athas> Oh, I guess it just refuses to run IO operations at all.
02:30:00 <ertes-w> even though lambdabot doesn't run IO, AFAIK there is a second layer of defence
02:30:05 <infinisil> > unsafePerformIO (putStrLn "hi")
02:30:08 <lambdabot>  error:
02:30:08 <lambdabot>      Variable not in scope: unsafePerformIO :: IO () -> t
02:30:25 <infinisil> > System.IO.Unsafe.unsafePerformIO (putStrLn "hi")
02:30:30 <lambdabot>  error:
02:30:30 <lambdabot>      Not in scope: ‘System.IO.Unsafe.unsafePerformIO’
02:30:31 <lambdabot>      No module named ‘System.IO.Unsafe’ is imported.
02:30:33 <ertes-w> it runs evaluations in a container or something similar
02:30:48 <infinisil> @let import System.IO.Unsafe
02:30:51 <lambdabot>  .L.hs:138:1: error:
02:30:51 <lambdabot>      System.IO.Unsafe: Can't be safely imported!
02:30:51 <lambdabot>      The module itself isn't safe.
02:31:13 <Gurkenglas> Has that line of defense ever averted an incident?
02:32:44 <AWizzArd> I’m about to try out cassava and learn how to use it. But I am curious: is it possible to parse a csv line into a list of strings? And in a quick example I saw how one can parse a row into a record. But: what if the data has a bad format or if a certain column is missing?
02:34:57 <infinisil> AWizzArd: having a quick look at its api, it seems that it just parses it into a Vector (Vector ByteString)
02:35:38 <infinisil> AWizzArd: And errors are most likely handled by the parser
02:36:26 <infinisil> AWizzArd: See the parse method: https://hackage.haskell.org/package/attoparsec-0.13.2.0/docs/Data-Attoparsec-ByteString.html#v:parse
02:37:02 <infinisil> its return type can indicate failure or success
02:39:46 <AWizzArd> infinisil: great, thanks for the pointer
02:50:23 <k01101011> people use haskell, who would a thought, must not be being used for anything other than hobbyists hum
02:56:37 <infinisil> lol
03:07:25 <ertes-w> > map ((toEnum :: Int -> Char) . fst) . (>>= readInt 2 isDigit digitToInt) . words $ "01001001 01110100 00100111 01110011 00100000 01100001 01101100 01101100 00100000 01101010 01100101 01110011 01110100 00100000 00110001 00100111 01110011 00100000 01100001 01101110 01100100 00100000 00110000 00100111 01110011"
03:07:28 <lambdabot>  "It's all jest 1's and 0's"
03:08:21 <ertes-w> that was jest one of the worst attempt's at trolling i've ever seen
03:08:43 <ventonegro> :D
03:09:01 <Boomerang> Well we got the jest of it... :)
03:10:16 <ertes-w> well, at least they used proper apostrophes improperly…  i`ve seen worse
03:10:49 <infinisil> ertes-w: what's the correct way?
03:13:58 <Boomerang> 1s and 0s? It's plural not possesive
03:17:10 <quchen> ertes-w: Hnnnnnnnng
03:17:30 <quchen> ertes-w: Take th‘is you monster
03:48:13 <michalrus> Is there a sequence/traverse for tuples? I need to change `(Maybe a, Maybe b) → Maybe (a,b)` and the patternmatching way seems too chatty.
03:49:33 <Rembane> michalrus: Combine sequence with bimap
03:49:35 <quchen> Not really. You can use bitraversable.
03:49:35 <Rembane> :t bimap
03:49:38 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
03:49:48 <Rembane> And on
03:50:12 <phadej> :t bitraverse
03:50:14 <lambdabot> error:
03:50:14 <lambdabot>     • Variable not in scope: bitraverse
03:50:14 <lambdabot>     • Perhaps you meant one of these:
03:50:16 <phadej> :(
03:50:19 <quchen> Not in scope :-(
03:50:35 <quchen> :t Data.Bitraversable.bitraverse
03:50:37 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable t) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
03:50:51 <quchen> :t Data.Bitraversable.bisequence :: (Maybe a, Maybe b) -> Maybe (a,b)
03:50:54 <lambdabot> (Maybe a, Maybe b) -> Maybe (a, b)
03:50:57 <phadej> https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Bitraversable.html#v:bisequence
03:51:15 <michalrus> Nice. ^.^ Thank you! ♥
03:51:25 <quchen> The pattern matching is probably clearer though.
03:51:33 <Gurkenglas> :t each id :: (Maybe a, Maybe a) -> Maybe (a, a)
03:51:35 <lambdabot> (Maybe a, Maybe a) -> Maybe (a, a)
03:51:37 <phadej> quchen: it's quite chatty
03:51:50 <hololeap> what is a "better"/more concise way of writing this function, especially lines 12/13? https://paste.pound-python.org/show/1XGWKvC3G8DQ3eY8cIOu/
03:51:52 <phadej> :t both :: (Maybe a, Maybe a) -> Maybe (a, a)
03:51:53 <quchen> Yup, but luckily there is no tax for expressive code
03:51:54 <lambdabot> error:
03:51:54 <lambdabot>     • Couldn't match type ‘r0 a0 a0 -> f0 (r0 b0 b0)’
03:51:54 <lambdabot>                      with ‘Maybe (a1, a1)’
03:51:56 <phadej> :t both id :: (Maybe a, Maybe a) -> Maybe (a, a)
03:51:58 <Gurkenglas> :t sequenceOf each :: (Maybe a, Maybe a) -> Maybe (a, a) -- or this if you like it more
03:51:59 <lambdabot> (Maybe a, Maybe a) -> Maybe (a, a)
03:52:00 <lambdabot> (Maybe a, Maybe a) -> Maybe (a, a)
03:52:06 <Rembane> :t (***)
03:52:08 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
03:52:16 <Rembane> :t (&&&)
03:52:17 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
03:52:29 <Rembane> Hm...
03:52:48 <phadej> (both is literally `bitraverse`)
03:53:03 <Rembane> :D
03:53:07 <kbeep> Can anybody help me get some intution about the foldr fusion law? I've read the equation, followed along with the proof (Thinking Functionally in Haskell pg. 121), but I am just not sure what the actual implications are?
03:53:19 <phadej> https://hackage.haskell.org/package/lens-4.16/docs/src/Control-Lens-Traversal.html#both
03:54:06 <quchen> kbeep: Do you understand how »\nil cons -> 3 `cons` (2 `cons` nil)« is a representation for the list [3,2]?
03:54:40 <quchen> \nil cons -> … is a representation for lists known as their Church encoding (or at least inspired by Church encoding)
03:55:04 <quchen> You can convert between ordinary ADT lists and Church lists via
03:55:09 <quchen> churchToAdt = build
03:55:29 <quchen> adtToChurch xs = \nil cons -> foldr cons nil xs
03:55:45 <quchen> where build f = f [] (:)
03:56:35 <quchen> (What encoding is it actually? Scott? Böhm-Beraducci?)
03:59:52 <quchen> kbeep: Now that I think about it, I wrote an article about this very subject some time ago. https://github.com/quchen/articles/blob/master/build.md
03:59:55 <phadej> it's church, if you believe wikipedia: https://en.wikipedia.org/wiki/Church_encoding
04:00:39 <quchen> phadej: As far as I know Church is untyped
04:00:59 <quchen> And Scott is »typed Church« and Böhm-Beraducci is similar, but folding is slightly different
04:01:14 <quchen> But that’s just half-knowledge
04:01:34 <phadej> quchen: https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding#Comparison_to_the_Church_encoding
04:01:38 <phadej> scott is "shallow"
04:01:50 <phadej> it doesn't recurse
04:02:07 <Gurkenglas> hololeap, no word you ever add is a prefix of another, yes?
04:03:13 <phadej> ScottNat = forall r. r -> (Nat -> r) -> r
04:03:27 <hololeap> umm... i'm not sure i follow
04:04:19 <hololeap> the idea is to quickly see if a string does *not* match any of the previously added words
04:05:44 <Gurkenglas> hololeap, you never check whether the word was already in there
04:05:44 <hololeap> i was mostly wondering if i had to pattern match on Free
04:05:57 <Gurkenglas> addWord b = foldr (.) id [_Free . at (ord c) . non (liftF M.empty) | c <- B.unpack b] .~ Pure b
04:06:20 <hololeap> oh dear, i don't know about lenses yet :p
04:10:28 <Gurkenglas> addWord b = foldr (.) id [\f (Free m) -> Free $ M.alter (Just . f . fromMaybe (liftF M.empty)) (ord c) m | c <- B.unpack b] (\_ -> Pure b) -- how about this then, hololeap
04:10:50 <boj> they are like a looking glass, into the detailed structure of human design, boring in the end
04:11:14 <hololeap> Gurkenglas: i'll look that over, thanks
04:12:20 <Gurkenglas> :t \b -> foldr (.) id [\f (Free m) -> Free $ M.alter (Just . f . fromMaybe (liftF M.empty)) (ord c) m | c <- Data.ByteString.Char8.unpack b] (\_ -> Pure b)
04:12:22 <lambdabot> BSC.ByteString -> Free (M.Map Int) BSC.ByteString -> Free (M.Map Int) BSC.ByteString
04:12:24 <Hijiri> anyone have an example for luminance using multiple vertex attributes
04:12:29 <Hijiri> I might be dropping a class over this library
04:15:49 <boj> Hijiri: you will stop going to a class in favor of self study from books?
04:15:58 <Gurkenglas> <hololeap> i was mostly wondering if i had to pattern match on Free <- well what do you want to happen when someone does addWord "asd" . addWord "as"?
04:17:07 <Hijiri> boj: I probably won't self-study outside of the class
04:18:18 <Hijiri> there is also that I didn't start this assignment early enough to find these apparent bugs
04:18:19 <boj> Hijiri: a lost cause
04:20:38 <boj> Hijiri: that felt way too serious. we weren't joking about you ditching a typeclass over some library which implements things better?
04:22:22 <Hijiri> no, I chose to use this library for a course and I don't have the motivation*time to reimplement it in something else if it turns out I can't work around this issue
04:23:05 <boj> well, i feel like i am on the wrong page
04:23:10 <boj> which library?
04:23:15 <Hijiri> luminance
04:24:11 <boj> well, openql fun
04:24:23 <boj> i know this because google knows this
04:24:44 <boj> what is making your life miserable?
04:25:00 <Hijiri> I can't get it to work with shaders that take multiple vertex attributes
04:25:20 <boj> is there an error or something you can show?
04:25:20 <Hijiri> it seems like it just treats all the data as being from the first attribute
04:25:29 <Hijiri> I can show broken rendering
04:25:41 <boj> actual haskell errors would be preferrable
04:25:55 <Hijiri> they're not haskell errors
04:26:05 <Hijiri> It's just not rendering correctly
04:26:18 <boj> hmm, sounds like a logic error then
04:26:50 <Hijiri> yes, it might be my fault, but I suspect it is in luminance
04:27:27 <boj> this seems to be a well used library downloaded 1860 times this last month, are you sure>
04:27:37 <Hijiri> I'm not sure, I said that I suspect it
04:27:47 <boj> well, trust your instinct of course
04:27:57 <Hijiri> I found another apparent bug in it earlier, but I was able to find a workaroudn for that
04:28:11 <boj> can you make a miniumun representation of what can produce the problem?
04:28:24 <Hijiri> I can but I want to sleep soon
04:28:31 <boj> indeed
04:28:33 <Hijiri> I still need to write a minimal example for the other bug I reported
04:29:05 <boj> i imagine if you can write these examples something may pop out
04:30:50 <Hijiri> well, for the earlier issue I thought I found a place in luminance that is causing the bug
04:31:15 <boj> if you can prove it i'm sure the author would appreicate a bug report
04:31:25 <Hijiri> I did make a bug report, I just need to write the example
04:31:27 <boj> better for everyone
04:31:29 <Hijiri> For the first one
04:31:53 <Hijiri> Apparently though the author's main development has moved to the Rust version of the library
04:32:12 <boj> maybe they still take haskell patches
04:32:31 <ertes-w> Hijiri: just a side note: you can still use the 'gl' library directly…  luminance doesn't interfere with that
04:32:33 <Hijiri> probably, since they responded on my issue
04:32:59 <ertes-w> so if there is something it doesn't do or does poorly, just don't use it for that part
04:33:33 <Hijiri> I would do that if it wasn't due tomorrow afternoon
04:33:52 <boj> university clssses, the bain of good software
04:34:05 <Hijiri> or me procrastinating
04:34:14 <boj> it's a toss up
04:36:34 <boj> bane* >.<
04:43:32 <Hijiri> ertes-w: If it's luminance that isn't supporting multiple vertex attributes properly, isn't that basically every real shader?
04:43:55 <Hijiri> at least vertex shaders that are dealing with geometry
04:45:16 <Hijiri> you might not need it if you're just rendering a big quad as part of some post processing or something like that
04:46:26 <ertes-w> Hijiri: can't comment on that; i haven't done much with luminance yet
04:46:45 <ertes-w> Hijiri: but yeah, i would expect it to support that
04:52:32 <cocreature> Hijiri: iirc luminance is not actively maintained since the author moved on to rust so you might want to be cautious before you depend on it too heavily
05:10:09 <kbeep> quchen: Thanks for the help, but I'm afraid I am not yet on the level that I need to understand your article...hope to get there someday
05:20:19 <Johanan> Hello! I have some sort of mapping operations with tuples and I have strong feeling that they can be formulated in arrows combinators.
05:21:23 <infinisil> Johanan: your code?
05:22:22 <Johanan> something like [1,2,3].map(\x -> (x,x)).map(\(k,v) -> (k, getFromMapByKey(v))).map(\(k,v) -> v.map(x -> (k, v)))
05:24:35 <infinisil> oh boy
05:24:59 <infinisil> the first map is unnecessary
05:25:25 <infinisil> ah, you transformed it into an arrow-like thing
05:25:35 <Johanan> right
05:25:56 <infinisil> yeah that does seem to be doable with arrows
05:27:10 <cloudhead> anyone know how to get callstacks working with assertions in Tasty.HUnit?
05:27:17 <Johanan> SO any ideas how to rise Maybe context that i got with getFromMapByKey ?
05:30:52 <hijk> i got this using groupby
05:30:52 <hijk> [[("xxx","a1"),("yyy","a1"),("zzz","a1"),("aaa","a1")],[("xxx","b1"),("yyy","b1")],[("zzz","c1")]
05:30:52 <hijk> can anyone tell me how to go about with it to get this
05:30:53 <hijk> [("a1",["xxx","yyy","zzz"]),("b1",["xxx","yyy"]),("c1",["zzz"])]
05:38:15 <lavalike> > (head . snd &&& fst) <$> unzip <$> [[("xxx","a1"),("yyy","a1"),("zzz","a1"),("aaa","a1")],[("xxx","b1"),("yyy","b1")],[("zzz","c1")]]
05:38:19 <lambdabot>  [("a1",["xxx","yyy","zzz","aaa"]),("b1",["xxx","yyy"]),("c1",["zzz"])]
05:41:42 <quchen> kbeep: That’s unfortunate, I was hoping it was for all skill levels. If you have specific questions, just ask me (or us) here! FWIW you don’t *need* the part about the type of build at the end
05:42:27 <infinisil> lavalike: that's the guy I've been trying to help before but he didn't respond and left
05:43:01 <lavalike> oh I hide the join part noise (:
05:43:07 <quchen> kbeep: I’d be happy to improve it, but I don’t know how exactly :-/
05:43:20 <infinisil> lavalike: i only see join/quits from recently active people, really useful
05:44:11 <infinisil> lavalike: (hijk has left minutes before you answered btw)
05:46:07 <quchen> kbeep: The only other resource about fold/build is Duncan Coutt’s thesis, but that’s around the same level as what I wrote
05:46:21 <quchen> It’s about stream fusion, but features a chapter on fold/build fusion too
05:46:32 <quchen> (Both are about fusing intermediate lists away)
05:48:07 <sr10> infinisil: http://lpaste.net/362097 i worked on it and got the desired result
05:48:33 <sr10> if any suggestion then let me know
05:49:10 <infinisil> sr10: have you seen the paste i linked earlier?
05:50:05 <infinisil> sr10: https://gist.github.com/Infinisil/5a1b2fe144abdf1be61bbdfda723cec1
05:50:58 <infinisil> sr10: Or in 1 function and a bit refactored: foldr (\(subject, student) -> M.adjust (student:) subject) subject marks
05:51:24 <infinisil> note that I'm using Data.Map instead of [(String, String)] because of efficiency and niceness reasons
05:54:08 <sr10> infinisil: yes okay. i'll try with
05:55:34 <kuribas> Is kleisli arrow a monoid?
05:56:02 <Taneb> kuribas: Kleisli is not an element of the Monoid typeclass because it is the wrong kind
05:56:08 <kuribas> mempty == return, <> == (>=>)
05:56:28 <Taneb> kuribas: that is a definition of a monoid only if you restrict to a single "a"
05:56:32 <Taneb> So, a -> m a
05:56:38 <kuribas> ah, right
05:56:59 <Taneb> kuribas: this is true for any Category
05:57:01 <quchen> Kleisli is an instance of Category, which is a generalized version of a monoid where you have more than one object. ;-)
05:57:07 <Taneb> https://hackage.haskell.org/package/monoid-extras-0.4.2/docs/Data-Monoid-Endomorphism.html has a newtype that does this
05:57:13 <kuribas> cool
06:10:35 <AWizzArd> Trying with cassava:  decode NoHeader "Hallo\n" :: Either String (V.Vector Text)   => error.
06:10:40 <AWizzArd> decode :: FromRecord a => HasHeader -> BL.ByteString -> Either String (V.Vector a)
06:11:07 <AWizzArd> And I saw that there is an instance FromField a => FromRecord (V.Vector a)
06:11:32 <AWizzArd> And there is an   instance FromField T.Text where [...]
06:11:34 <mauke> what's the error?
06:11:48 <AWizzArd> Error is: No instance for (FromRecord Text) arising from a use of ‘decode’
06:12:25 <AWizzArd> But    decode NoHeader "Hallo,2\n" :: Either String (V.Vector (Text, Int))      works fine.
06:12:45 <AWizzArd> => Right [("Hallo",2)]
06:12:56 <mauke> that makes sense
06:13:13 <mauke> a record is a collection of fields
06:13:40 <AWizzArd> mauke: ah okay, got it. I missed the []
06:13:50 <AWizzArd> decode NoHeader "Hallo\n" :: Either String (V.Vector [Text])    works
06:13:55 <AWizzArd> Must be [Text] and not Text
06:14:00 <AWizzArd> thx
06:14:09 <mauke> http://hackage.haskell.org/package/cassava-0.5.1.0/docs/Data-Csv.html#t:FromRecord here's a list of instances
06:14:17 <AWizzArd> Yes, but no wait
06:14:35 <AWizzArd>  FromField a => FromRecord (Vector a)     is also listed
06:14:47 <mauke> yeah, that would allow Vector (Vector Text)
06:14:59 <mauke> apparently you can also do 'V.Vector (Only Text)' for a single field
06:14:59 <AWizzArd> (Vector a) is fine, as long there is a  FromField instance for a.
06:15:24 <AWizzArd> Yes, the Only also works.
06:15:36 <AWizzArd> But I don’t see why   (Vector Text)  results in an error.
06:15:50 <mauke> because it needs to be Vector (Vector Text)
06:16:17 <mauke> decode :: FromRecord a => HasHeader -> BL.ByteString -> Either String (V.Vector a)
06:16:39 <mauke> with instance FromRecord (Vector Text), we get ... -> Either String (V.Vector (Vector Text))
06:17:07 <AWizzArd> True. Good. That’s it!
06:20:28 <AWizzArd> Are `Data.Vector`s lazy?
06:23:55 <lyxia> yes, they can contain undefined elements
06:45:52 <quchen> AWizzArd: Strict in the spine, lazy in its elements.
06:47:14 <quchen> length (Vector.fromList [1, undefined, 3]) -- should be 3
06:47:22 <quchen> Lambdabot doesn’t have Vector imported :-/
06:47:43 <AWizzArd> Okay
06:53:52 <elben> Hi, I’m trying to upload my first package to Hackage, and I’m get build errors. https://hackage.haskell.org/package/pencil-0.1.0/reports/1. By looking at the ghc 8.2.x dep in that build log, I assume hackage trying to build it using cabal 2.x? And If I’m reading those logs correctly, it seems like pandoc’s setup.hs is perhaps using some old cabal stuff that’s now gone. I’m using stackage lts-9.x (ghc < 8.2) to develop, so per
06:53:52 <elben> that’s why I wasn’t seeing the build failures. Trying to get cabal to build locally too, to figure this out. But does it seem likely that the fix here is to bump the pandoc dep? I’m also uncertain as to which ghc versions I need to test against before uploading to hackage. All? What happens when a package only builds against certain ones?
06:54:48 <bartavelle> elben: there are a couple travis scripts that could help you
06:54:58 <bartavelle> https://github.com/haskell-hvr/multi-ghc-travis
06:55:16 <bartavelle> I don't know how to be certain things *will* build on hackage, but this should help iron out problems
06:59:21 <elben> I’ll take a look!
07:18:54 <_d0t> ohai. Is there a testsuite to prove that a particular MonadBaseControl instance is valid?
07:20:21 <shapr> _d0t: I know conal's checkers package has a bunch of quickcheck instances for monad instances, have you looked at that?
07:20:36 <_d0t> shapr: no, not yet
07:20:51 <shapr> even if it doesn't support MonadBaseControl, perhaps it could give you a starting point?
07:22:38 <shapr> conal is not currently on #haskell, or we could just ask him
07:23:11 <_d0t> well, not sure it's gonna work since MonadBaseControl is lacking there
07:23:28 <_d0t> i was hoping for a bunch of tests that check the existing laws for this class
07:23:39 <_d0t> so I could just plug my type in and get it over with
07:26:21 <_d0t> the problem is that monad-control package doesn't have tests at all
07:26:58 <_d0t> despite being widely used
07:32:57 <lyxia> _d0t: I started working on something like that for mtl laws, and I'd like to add monad-control to it some time.
07:33:03 <lyxia> https://github.com/Lysxia/checkers-mtl/blob/master/src/Test/Monad/State.hs for example
07:34:15 <_d0t> lyxia: nice
07:46:11 <sm> elben: why not update or add another stack.yaml using lts-10, which includes ghc-8.2.2
07:47:03 <elben> I was waiting for ghc-mod to support ghc-8.2.2. But I didn’t know you could just add another stack.yml.
07:47:23 <sm> you can also just specify resolver=lts-10 on the command line
07:47:36 <sm> stack build --resolver=lts-10 ...
07:47:46 <BernhardPosselt> came across the first usecase for applicative map today in java
07:47:57 <BernhardPosselt> but no infix functions means everything is revesed
07:48:27 <BernhardPosselt> now im sad
07:51:26 <elben> sm: I see. lts-10.x however has dep bumps that would force me to change my code. So does this mean, for a particular version of my package, I would only be able to support either lts-9.x or lts-10.x? I suppose the easiest thing would just be to bump all my deps and go straight to ghc-8.2.2 + lts-10.x version bounds
07:52:51 <sm> elben: not necessarily. If it were me, I'd first test the (good) theory that pandoc < 2 with Cabal > 2 is the problem
07:53:36 <sm> it seems searching for the error pays, again: https://github.com/jgm/pandoc/issues/3876
07:54:19 <sm> maybe requiring pandoc >= 1.19.2.2 is enough
08:03:38 <sm> elben: btw, re "which ghc versions I need to test against before uploading to hackage". Hackages eventually tests half a dozen versions, which you can see at https://matrix.hackage.haskell.org/package/pencil . How many you want to try to support is up to you - last 3 is a common choice - but you should try and prevent the red FAILs on this screen, eg by setting a minimum bound on base to disallow older ghc versions
08:05:31 <sm> you may also want to maintain a tested-with field in your cabal file, as another way to communicate this to users
08:13:21 <elben> sm: this is great info, thank you!
08:14:00 <sm> np
08:14:32 <sm> https://wiki.haskell.org/Base_package shows correspondence of base and ghc
08:18:06 <elben> May matrix and hackage use different deps when building? Because my package says it succeded in the matrix https://matrix.hackage.haskell.org/package/pencil but fails here https://hackage.haskell.org/package/pencil-0.1.0/reports/1
08:23:51 <sm> elben: good question, #hackage will know
08:24:06 <sm> or hvr
08:37:46 <alexteves> is there any non-TH way of checking constructor tag in ADTs (isJust, isNothing) or need I always define them ?
08:39:34 <mauke> you can use pattern matching
08:39:35 <hyperisco> alexteves, you should never need them ^.^
08:41:03 <glguy> alexteves: No, Template Haskell is the way
08:42:56 <alexteves> pattern matching does work, and I do get the code smell argument, but one of the tags is basically "Complete stuff morestuff", so I end up with an isComplete function, even though I don't need the other isX
08:46:28 <mauke> > case Just "stuff" of Just{} -> True; _ -> False
08:46:31 <lambdabot>  True
08:52:45 <robstr> Hey,  I recently saw {..} - what does this mean ? I tried asking google -.-
08:53:26 <mauke> "all fields"
08:53:35 <robstr> thank you
08:53:45 <mauke> try searching for record wildcards
08:53:48 <robstr> under which topic i can read this ?
08:53:51 <robstr> :+1
08:54:13 <robstr> thank you
08:55:45 <sm> robstr: in the GHC user guide
08:56:27 <sm> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-wildcards
08:57:03 <robstr> got it, thanks
08:57:35 <Zemyla> Is there a primop that will tell me if a MutableArray has been frozen?
08:59:20 <hyperisco> Writer but instead of overwrite it is mappend… what is that called?
08:59:32 <hyperisco> it would be like Monad for logging
09:00:46 <mauke> isn't that ... Writer?
09:11:44 <hyperisco> :t WriterT
09:11:46 <lambdabot> m (a, w) -> WriterT w m a
09:11:54 <hyperisco> :t write
09:11:57 <lambdabot> error:
09:11:57 <lambdabot>     • Variable not in scope: write
09:11:57 <lambdabot>     • Perhaps you meant ‘writer’ (imported from Control.Monad.Writer)
09:12:16 <hyperisco> I can't remember what the effect is called… but no, that isn't WriterT as I recall it
09:13:06 <hyperisco> "The return function produces the output mempty, while >>= combines the outputs of the subcomputations using mappend."
09:13:11 <hyperisco> okay, apparently it does do that
09:13:24 <Average-user> who knows a good source for learning Arrows?
09:13:52 <lyxia> @where arrows
09:13:52 <lambdabot> http://www.haskell.org/arrows/
09:14:28 <hyperisco> this is a really interesting Monad:  (Monoid r, Monoid s) => EitherT r (Writer s) a
09:14:48 <hyperisco> er, not EitherT…
09:15:22 <hyperisco> not sure the one that I do mean has a name… you could consider it a dual to WriterT but not in the sense of being ReaderT :P
09:15:40 <lyxia> ValidationT?
09:15:47 <hyperisco> is that a type?
09:16:14 <lyxia> it is
09:16:36 <lyxia> although it uses the Monoid for the Alternative instance
09:16:36 <hyperisco> can't find it… but anyways, the idea would be to mappend over <|> instead of >>=
09:17:05 <aconz2> wondering if anyone has thoughts (or links) on what makes a "good" type-class. By good, I mean a type-class that has taken the essensce of functionality which multiple types share but has a principled criterion for *why* those things are similar. Something like Monoid is pretty clear but how is Show similar between disparate types?
09:17:25 <hyperisco> (Monoid r, Monoid s) => ValidationT r (Writer s) a   then is really interesting
09:17:40 <Average-user> https://hackage.haskell.org/package/Validation-0.2.0/docs/Data-Validation.html
09:17:55 <lyxia> hyperisco: http://hoogle.haskell.org/?hoogle=ValidationT
09:18:07 <hyperisco> zero results… already looked
09:18:36 <glguy> maybe look closer?
09:18:38 <lyxia> hyperisco: that's the wrong hoogle you looked at
09:19:12 <hyperisco> https://www.haskell.org/hoogle/?hoogle=ValidationT  D:
09:19:52 <hyperisco> someone fix the DDG bang pattern!
09:20:39 <hyperisco> Average-user, derp if I merely scrolled down… I thought that package only had an Applicative version
09:22:35 <Average-user> hyperisco: It takes a few scrolls
09:23:08 <Average-user> I wanna learn a new language. Some advices/ideas?
09:23:11 <glguy> I don't think that type has a valid monad instance, but it has one that makes a good effort
09:23:25 <hyperisco> why do you think that?
09:23:44 <glguy> Because I can't imagine how to write one where ap === (<*>)
09:24:00 <glguy> the monad instance will lose errors
09:24:07 <glguy> where the applicative one will not
09:24:15 <hyperisco> that's the point
09:24:28 <hyperisco> if they are not doing that then they did it wrong
09:24:29 <jcbell> Average-user: j language is pretty interesting: http://www.jsoftware.com/
09:24:31 <glguy> No, the point is that ap should always be equal to (<*>)
09:24:57 <hyperisco> I am saying that is the point of using the Monoid over <|> and not >>=
09:25:58 <glguy> validation doesn't merge errors with <|>
09:26:47 <lyxia> what <|> does is quite different from >>= or ap, so that's a strange comparison to make...
09:26:52 <hyperisco> mhm… reading the source and it doesn't look right
09:27:22 <hyperisco> the answer doesn't seem to be ValidationT then
09:27:37 <hyperisco> possibly this type has not been put on hackage yet
09:28:24 <jcbell> Anyone know elisp pretty well?  I'm having a bit of trouble with some buffer-formatting code and #elisp and #emacs-beginners are pretty dead.
09:28:28 <hyperisco> also it looks like WriterT uses a Monoid over <|> which isn't what I intend either… bleh.
09:28:56 <hyperisco> w/e when I get the time I will write it up and prove the laws
09:28:57 <lyxia> This validation does merge failure https://hackage.haskell.org/package/either-5/docs/Data-Either-Validation.html
09:29:10 <glguy> validation merges failures across <*>
09:30:32 <glguy> ExceptT merges failures across <|>
09:33:08 <lyxia> validation also merges across <|>
09:33:52 <glguy> doesn't appear to in link Average-user pasted earlier
09:34:18 <glguy> That Monoid constraint is only being used for mempty
09:34:42 <glguy> Failure _ <|> x = x
09:34:42 <lyxia> Okay, I was referring to Validation from either
09:35:52 <pmade> What's a good strategy for calling a function that uses the old Monad.fail and redirecting the error to MonadFail.fail?
09:36:14 <lyxia> "Validation" the package has been deprecated in favor of validation+either
09:37:25 <lyxia> pmade: use a Monad that defines Monad.fail as MonadFail.fail
09:41:43 <pmade> I wish there was a way to make GeneralizedNewtypeDeriving make Monad.fail a call to MonadFail.fail
09:43:33 <kuribas> jcbell: yes
09:44:16 <lyxia> pmade: The upcoming work on derivingVia will address that.
09:48:10 <lambdafan> is it possible to use non-curated packages with "stack script"?
09:51:36 <lyxia> there's probably some way to set an extra-dep
09:55:20 <MarcelineVQ> possibly via adding a --stack-yaml STACK-YAML  line but idk
09:55:46 <MarcelineVQ> the stuff in  script  are things that are allowed on cli, and extra-deps aren't a cli option
10:00:16 <lyxia> there's --package
10:01:56 <MarcelineVQ> I mean extra-deps in the sense that stack means it, dependencies not available in a particular snapshot
10:04:57 <lambdafan> MarcelineVQ: thanks :) That was helpful. I need to find another way
10:05:23 <Hijiri> ertes-w: Is there a way to get the underlying data for a luminance Geometry
10:05:31 <Hijiri> it doesn't look like it's exposed
10:10:43 <Hijiri> if it's not I can't work around this problem except for not using luminance at all for these objects
10:11:40 <shapr> MarcelineVQ: did you get amazonka building with new-build?
10:12:02 <shapr> I may have to use stack for amazonka
10:12:24 <MarcelineVQ> no, I only tried that once though
10:12:35 <shapr> ok, just curious
10:29:21 <jle`> pmade: note that if you're calling fail through do notation pattern matches, you can enable -XMonadFailDesugaring
10:29:42 <jle`> and failed pattern matches will call MonadFail's fail instead of Monad's fail
10:33:00 <dsal> stack has been broken for linux-arm for quite a while now.  Is this something I can throw some resources at to help keep this working?
10:51:53 <mud> dsal: If there's a github issue about it, that's probably the best place to ask
10:52:38 <dsal> Hmm...  Yeah, I found a few issues.  It looks like there may be enough information around to figure out how to at least do a build.  Being able to do that reproducibly would be a good start.
11:12:47 <Naughtmare[m]> Is there any frp library that is lazy enough to handle: `fmap fst (liftA2 (,) b undefined) == b`, where `b` is a behavior? Is this even theoretically possible?
11:16:34 <pmade> jle`: Thanks!
11:19:48 <phadej> > let b = Just 'b' in fmap fst (liftA2 (,) b undefined)
11:19:51 <lambdabot>  *Exception: Prelude.undefined
11:19:59 <phadej> even Maybe isn't lazy enough!
11:20:33 <hyperisco> mm, no, <*> is strict
11:21:12 <phadej> (but more seriously: `fst` is opaque function, so hardly any structure inspecting Applicative can satisfy that equation)
11:21:20 <phadej> > let b = Identity 'b' in fmap fst (liftA2 (,) b undefined)
11:21:23 <lambdabot>  Identity 'b'
11:21:28 <phadej> > let b = ['b'] in fmap fst (liftA2 (,) b undefined)
11:21:33 <lambdabot>  "*Exception: Prelude.undefined
11:21:56 <phadej> > let b = const 'b' :: Int -> Char in fmap fst (liftA2 (,) b undefined)
11:21:59 <lambdabot>  <Int -> Char>
11:22:04 <phadej> > let b = const 'b' :: Int -> Char in fmap fst (liftA2 (,) b undefined) 0
11:22:07 <lambdabot>  'b'
11:22:15 <byorgey> > let b = ZipList ['b'] in fmap fst (liftA2 (,) b undefined)
11:22:19 <lambdabot>  ZipList {getZipList = "*Exception: Prelude.undefined
11:22:20 <phadej> something works, something doesn't.
11:22:52 <phadej> let b = ZipList ['b'] in fmap fst (liftA2 (,) b (pure undefined))
11:22:56 <phadej> > let b = ZipList ['b'] in fmap fst (liftA2 (,) b (pure undefined))
11:22:57 <byorgey> huh, I was expecting ZipList to work.  Oh, wait, because the other list could be empty.
11:23:00 <lambdabot>  ZipList {getZipList = "b"}
11:23:09 <byorgey> right, that works
11:23:20 <phadej> structure is inspected, not the value
11:23:24 <phadej> (s)
11:23:41 <jle`> the problem with Maybe is that <*> needs to know if the second value is Nothing or Just, in order to determine if the result is Nothing or Just
11:23:44 <hyperisco> why Identity works is because of newtype-yness
11:24:05 <kuribas> what's a good course to teach haskell to (python) programmers as quickly as possible?
11:24:14 <jle`> Identity's <*> already knows that the result is made with the Identity consturctor
11:24:27 <jle`> no matter what constructor the second value is made with
11:24:44 <kuribas> this looks nice, but it doesn't contain info about lenses: http://www.seas.upenn.edu/%7Ecis194/spring13/lectures.html
11:25:01 <hyperisco> jle`,  Identity f <*> Identity x = Identity (f x)  no?
11:25:21 <byorgey> kuribas: so use that + some lens tutorial?
11:25:21 <jle`> kuribas: you could always teach lenses after :o
11:25:23 <hyperisco> but because it is a newtype, this pattern match is not strict
11:25:33 <jle`> hyperisco: yeah, the newtypeness is probably the only thing that lets it work
11:25:35 <kuribas> byorgey: yeah, that's also possible :)
11:25:45 <jle`> unless you use a lazy pattern match maybe
11:25:51 <metahumor> kuribas: as much as I don't suggest LYAH for haskell beginners, it might be alright with pythoners
11:25:55 <jle`> hm
11:26:04 <kuribas> byorgey: how much time do you think is needed to get imperative (python) programmers upto speed?
11:26:10 <kuribas> metahumor: right, thanks
11:26:18 <jle`> @let data IdLazy a = IdLazy a deriving (Show, Functor)
11:26:20 <metahumor> kuribas: are they familiar with iterators and generators?
11:26:20 <lambdabot>  Defined.
11:26:26 <kuribas> metahumor: I suppose
11:26:51 <jle`> @let instance Applicative IdLazy where pure = IdLazy; ~(IdLazy f) <*> ~(IdLazy x) = IdLazy (f x)
11:26:52 <byorgey> kuribas: it depends on what you mean by 'up to speed'.  It also depends on who the programmers are and what background they have.
11:26:53 <lambdabot>  Defined.
11:27:15 <jle`> > fmap fst (liftA2 (,) (IdLazy 'b') undefined)
11:27:19 <lambdabot>  IdLazy 'b'
11:27:21 <jle`> neat
11:27:23 <byorgey> kuribas: it also also depends on how much time they will be spending on this.  full time?  half time?  A couple hours every week? ...?
11:27:27 <kuribas> byorgey: full time
11:27:39 <metahumor> kuribas: my python->haskell "up to speed" workflow includes drawing parallels from python's iterators, generators, contextmanagers, decorators, and lambdas for creation of deferred values
11:27:43 <jle`> i hear byorgey has a famous course
11:28:06 <kuribas> metahumor: that's not a bad idea, I could show examples from python.
11:28:14 <byorgey> kuribas: and what do you want them to be able to do once they are 'up to speed'?
11:28:24 <mnoonan> metahumor: what parallel do you use for decorators?
11:28:35 <kuribas> byorgey: develop and maintain an app.
11:28:36 <jle`> higher order functions?
11:29:10 <mnoonan> maybe it's just me, but I often use decorators in a very not higher-order-functions kind of way
11:29:10 <metahumor> mnoonan, jle`: exactly, higher order functions, like "minimumBy", "groupBy", "comparing"
11:29:14 <mnoonan> e.g. for implementing DSLs
11:29:39 <kuribas> byorgey: our python app is a total disaster, and I hope I can show them how easier it is in haskell.
11:30:09 <kuribas> byorgey: and if it would get approved, to train them in haskell.
11:30:27 <kuribas> byorgey: probably won't happen, but if it does, I have a plan :)
11:30:38 <byorgey> kuribas: well, based on my experience training summer research students in Haskell, I would guess at least 4 weeks.
11:30:50 <kuribas> byorgey: full time (8hrs)?
11:30:53 <byorgey> yes.
11:31:02 <kuribas> hm, okay.
11:31:06 <byorgey> if you have buy-in and they are really working hard at it full time.
11:31:12 <kuribas> yeah
11:31:14 <mnoonan> that doesn't leave much summer!
11:31:35 <metahumor> one of my "i wish i was writing haskell" hacks for python is a "def lazy(fn): {@wraps(fn); def wrapper(*args, **kwargs): def lazy_fn(): return fn(*args, **kwargs); return lazy_fn; return wrapper}"
11:31:58 <kuribas> byorgey: is your course sufficient, or do you give additional material/exercises?
11:32:05 <metahumor> used as "@lazy def function_that_will_be_deferred(...)"
11:32:11 <byorgey> mnoonan: indeed!  But it's really more experience for them than actually helping me with research... =)
11:33:40 <kuribas> metahumor: another idea would be to rewrite in Python using xpath, etc... but meh, no typesafety, and double the effort because everything needs to be tested.
11:33:41 <byorgey> kuribas: well, when I have done it there is some particular goal, i.e. some library or codebase I want them to work on, so they are starting to work on that in parallel with going through the material
11:34:39 <byorgey> kuribas: I think something like that is critical, actually.  You can just go through the CIS194 material pretty quickly but not actually be 'up to speed' at the end of it, because you simply need more practice and experience.
11:34:56 <kuribas> byorgey: ok, I could use our app for it then.
11:39:30 <mnoonan> it isn't a particularly PL-ish conference, but is anybody here going to be at NDSS next month?
11:39:42 <byorgey> kuribas: yes, that would make sense
11:40:17 <srid> is it possible to exclude TemplateHaskell generated output from ghc error messages? my terminal doesn't scrollback :-) and the long css embed is overriding the original error (ghcjsi doesn't have `less` I suppose)
11:40:43 <glguy> srid: Unlikely. There's a flag for reversing the order that they are printed in , however
11:41:11 <[exa]> srid: &> log.txt ; less log.txt ?
11:41:17 <srid> from ghc[js]i?
11:41:47 <[exa]> oh so. You may run one within 'tee' btw
11:43:15 <srid> Normally I do `2>&1 | less -R` when I'm in shell.
11:43:34 <srid> which is better than tee, as you can scroll back at the end
11:47:00 <kuribas> byorgey: so for part-time, that would be 2 months?
11:48:01 <mud> I would think 8 hours a day isn't maximally efficient, in terms of hours spent (I know I don't think as well at hour 8 as I did at hour 2), so it might not just be a multiple
11:48:38 <byorgey> I agree with mud actually
11:49:05 <mud> (That's not to say 8 hours a day is a bad idea, if you're in a hurry of course though)
11:49:12 <pikajude> lol, so i solved the problem i had yesterday unintentionally
11:49:26 <pikajude> the way you force every name referenced in a splice to be in scope is you use GHC 7.10
11:49:35 <byorgey> The most efficient might be something like 3 hours a day for 6 weeks, I dunno
11:50:24 <byorgey> I am totally guessing here.  You should really be asking people with experience doing Haskell training in corporate settings, e.g. Well-Typed
11:59:32 <rco> ghci seems to ignore my numpad "*" and "+", but they work fine when I use getLine.
12:00:47 <parsnip> hmm, mempty for hakyll Context (missingField) doesn't seem very inert, it looks like an error.
12:01:24 <lyxia> parsnip: what does it mean to not be inert
12:01:35 <kuribas> mud: yeah, it would be more probable a few hours a day
12:01:43 <parsnip> like a+0=a
12:01:56 <kuribas> byorgey: ok, thanks :)
12:02:15 <parsnip> oh, is error not a violation of monoid?
12:02:32 <parsnip> like undefined being everywhere?
12:02:36 <mud> My personal rule of thumb is ~4 hours a day limit, but that's for direct programming. I'm not sure about learning per se, and I have little objective data even for my own case, it's hard to measure.
12:02:55 <kuribas> parsnip: bottom makes everythink lawless.
12:04:04 <lyxia> parsnip: fail is not error though
12:04:18 <kuribas> what kind of fail?
12:04:27 <kuribas> :t fail
12:04:29 <lambdabot> Monad m => String -> m a
12:05:56 <parsnip> hmm, defaultContext ends with mempty, so it must be fine, just looked weird
12:06:43 <kuribas> I thought that was MonadFail...
12:06:51 <lyxia> parsnip: missingField calls fail, which is defined for Compiler with compilerThrow, which is an IO action that returns an error of type CompilerResult
12:07:26 <lyxia> kuribas: MonadFail.fail and Monad.fail are still different, we're in the middle of the transition.
12:07:34 <kuribas> ah, right
12:10:48 <metahumor> byorgey: i just read your "Explaining Type Errors"... wonderful stuff!
12:11:11 <metahumor> I wish I had that for the scientific-experiment-DSL I've been mind-developing
13:00:14 <Tuplanolla> How do you do the equivalent of `\DeclareMathOperator` with Pandoc? The documentation for MathML is very sparse.
13:07:54 <shapr> Any haskellers in the DC area?
13:08:00 <shapr> I'm visiting for a weekend soon
13:08:55 <Tuplanolla> I guess `\newcommand` with `\operatorname` and `\limits` will do.
13:36:43 <dmwit> I will be there (sans unicycles =( ) starting Feb. 12.
13:38:52 <metahumor> what are people's opinions on Write You a Scheme? good choice for an intermediate-level exercise?
13:40:31 <heptahedron> who doesn't love a minimalist lisp?
13:42:44 * [exa] would prefer Write You a C
13:42:56 <metahumor> would that include the preprocessor?
13:43:08 <[exa]> (so it could also make fairly good C programmers along the way)
13:43:24 <dstolfa> [exa]: and people who hate C simulatneously?
13:43:47 <[exa]> dstolfa: would understand C is so thin that there's nothing to hate :D
13:43:50 <metahumor> writing a language implementation implies becoming a good writer of that language?
13:43:52 <geekosaur> is that a bad thing? :p
13:44:03 <Tuplanolla> I've worked enough with C and Scheme compilers to know they're both massive projects.
13:44:08 <dstolfa> [exa]: there's a lot of things to hate about C
13:44:12 <dstolfa> it's a terrible language
13:44:21 <metahumor> we should go Back
13:44:28 <[exa]> to Scheme.
13:44:28 <dstolfa> geekosaur: well, possibly not :)
13:44:30 <[exa]> yes :]
13:45:06 <dstolfa> Tuplanolla: writing a scheme REPL with basic features, no optimisation, no garbage collection and no asynchrony is trivial
13:45:14 <dstolfa> writing an actual scheme compiler... different story
13:45:22 <metahumor> Back implied B
13:45:23 <Tuplanolla> That's also completely uninteresting, dstolfa.
13:45:33 <[exa]> dstolfa: not really complicated too, except the memory management
13:45:36 <dstolfa> Tuplanolla: i fully agree, unless you're learning a language
13:46:10 <dstolfa> [exa]: you'd be surprising how quickly things get complicated when you add garbage collection to lisp and then try to deal with multithreading
13:46:13 <dstolfa> erm
13:46:14 <dstolfa> surprised*
13:46:35 <dstolfa> and especially if you want to paralellise things or vectorize them to make use of modern CPUs
13:47:19 <heptahedron> dstolfa: are there really people who're surprised by the fact that implementing garbage collection and multithreading isn't a walk in the park?
13:47:29 <dstolfa> heptahedron: actually, yes.
13:47:44 <[exa]> yeah I wouldn't want to implement multithreaded GC :D
13:47:58 <[exa]> I kindof hope that wouldn't be a part of the exercise
13:48:03 <heptahedron> dstolfa: I don't think I want to know them
13:48:06 <dstolfa> heptahedron: i've talked to people who were wondering why it's so difficult to do low latency GC in distributed systems
13:48:10 <metahumor> does any language (or implementation) have a well-functioning multithreaded GC?
13:48:31 <[exa]> metahumor: good point. :]
13:48:34 <heptahedron> metahumor: python /s
13:48:35 <dstolfa> metahumor: Pony has a decent one last i checked
13:48:43 <metahumor> praise GIL
13:48:44 <dstolfa> metahumor: https://www.ponylang.org
13:49:19 <[exa]> metahumor: anyway, afaik B is just a single-type C, that would be pretty nice even for compiling to llvm/asm
13:49:59 <metahumor> yup, way back when I was being taught C, we played around with some B
13:50:27 <metahumor> lol pony file-ext is *.py
13:50:33 <[exa]> and well, B/C is much better for grasping the secrets of parsing than scheme :D
13:50:56 <dstolfa> metahumor: :D, also here's the GC chapter: https://tutorial.ponylang.org/gotchas/garbage-collection.html
13:51:14 <dstolfa> i think this is a better solution, given the way pony works, than pausing threads
13:51:21 <dstolfa> instead, you just never GC while executing an actor
13:51:38 <dstolfa> it has its downsides and definitely isn't applicable to things like Java, C# and so on
13:51:41 <metahumor> how does Erlang do GC?
13:51:44 <dstolfa> but it does seem to work well for Pony
13:52:12 <dstolfa> metahumor: generational AFAIK
13:52:28 <codedmart> Anyone have an example or can point me in the right direction to get progress of a `putObject` in amazonka? Or do something after each chunk has been processed?
13:52:38 <dstolfa> they do work per-process though (erlang process, not unix process)
13:54:03 <[exa]> metahumor: erlang can 'send' the objects around to other GCs
13:54:45 <_d0t> metahumor: in short, erlang processes have separate heaps and no data is shared between them
13:55:01 <_d0t> that's why beam vm can run gc in parallel with actual work
13:55:15 <_d0t> i.e. it doesn't stop the world like in haskell or java
13:55:46 <_d0t> otherwise it's similar to haskell gc
14:10:10 <d-fish> Are there any tutorials on the "streaming" package? https://github.com/haskell-streaming/streaming
14:10:22 <d-fish> I don't understand the type parameters
14:11:51 <d-fish> streaming seems recommended over conduit/pipes/machines/io-streamsL https://www.reddit.com/r/haskell/comments/7nuhk0/how_do_people_use_streaming_libraries/
14:13:00 <sm> d-fish: Streamly may be worth a look
14:13:19 <sm> streamly
14:14:06 <Welkin> is it reasonable to expect that I can use Array with Ix to have 3-dimensional arrays?
14:14:21 <Welkin> indexing with (Int, Int, Int)
14:14:41 <Welkin> I think Array makes the most sense here
14:14:51 <Welkin> I could use Map, too
14:15:06 <Welkin> but that has no bounds checking
14:15:20 <glguy> Welkin: I don't know what sort of reasonable you're asking about, but you can index an array package Array with a 3-tuple
14:15:47 <Welkin> I'm wondering is that is a good way to handle it
14:15:52 <Welkin> if*
14:16:14 <metahumor> Data.Ix has instance of (Ix a1, Ix a2, Ix a3) => Ix (a1, a2, a3)
14:16:43 <Welkin> how does it behave though?
14:17:07 <glguy> rectangularly
14:17:39 <Welkin> I suppose I could order them in a different way
14:17:41 <Welkin> okay
14:17:47 <metahumor> Welkin: rightmost first
14:17:53 <Welkin> oh?
14:18:08 <metahumor> > Data.Ix.range ((0,0,0),(2,2,2))
14:18:11 <lambdabot>  [(0,0,0),(0,0,1),(0,0,2),(0,1,0),(0,1,1),(0,1,2),(0,2,0),(0,2,1),(0,2,2),(1,...
14:18:40 <Welkin> I see
14:19:01 <metahumor> this is one of those 0- or 1- indexing, little- or big- endian issues =)
14:19:21 <Welkin> I am trying to represent a sequence of 2d maps stacked on top of each other. The z coordinate was going to be the map identifier
14:19:36 <Welkin> I suppose I could move the z to the front
14:22:33 <Welkin> (z, y, x) should work
14:25:00 <hololeap> what is Ix supposed to stand for? is it sort of like I*?
14:25:07 <glguy> Index
14:25:13 <hololeap> ah
14:35:47 <hololeap> hmm, i wonder if it is possible in general to have a Monoid instance of a non-trivial sum type
14:38:39 <hololeap> more specificially, get a Monoid out of a Free monad... (Free ...) <> (Pure ...) seems to be where it falls apart
14:46:00 <cement> my coworker is writing code with multiple uses of accursedUnutterablePerformIO
14:46:20 <geekosaur> this should be fun ™
14:46:44 <cement> much like dwarf fortress, yes.
14:50:31 <Welkin> what's a cow orker?
14:50:44 <Welkin> like a cow and a pig?
14:51:05 <cement> co-worker
14:57:40 <bash0r_> Hi, anybody familiar with Transient?
14:58:25 <glguy> ?where justask
14:58:25 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
14:59:34 <bash0r_> I don't have a specific question how to solve something in Transient.
15:00:15 <bash0r_> More like... Is it really suitable for large cluster distribution? How does it perform in real world scenarios?
15:15:04 <greymalkin> Is there a version of `/` that will work on Scientific values without hanging?
15:31:48 <zomg> greymalkin: I recall you may have to convert it because / on scientific will hang if it has infinite decimal expansion
15:32:14 <zomg> the docs for the package might've had something about it if I remember correctly
15:46:24 <greymalkin> Yeah, they say "use toRationalRepetend" -- but there's no real example of Scientific -> Scientific
15:46:30 <greymalkin> I'm trying it through right now.
15:51:00 <greymalkin> Got it.
15:54:42 <heptahedron> is there any way to get ghc to tell me the contexts it's inferred by the time it reaches a hole? trying out some proofs with dependent types and it'd really help
15:55:47 <Axman6> greymalkin: Scientific is not for maths, it exists almost exclusively to give you lossless parsing of base 10 numbers possibly written in scientific notation
15:57:28 <c_wraith> never divide a Scientific value by anything with prime factors other than 2 and 5
15:57:46 <Axman6> yeah
15:58:08 <mniip> heptahedron, I'm fairly sure it does
15:59:02 <Axman6> greymalkin: Scientific is literally just an Integer and a base 10 exponent, and is intended to be able to represent all base 10 finite numbers. so 1/3 will never terminate because you will end up with 33333... and -<a really big number> as the exponent if it ever did terminare
15:59:07 <Axman6> terminate*
16:02:28 <heptahedron> mniip: Hm. I'm using `Data.Type.Equality.gcastWith` and I'm 88% sure the equality I provided to it appears in the type of the final argument, but it doesn't appear to be rewriting anything, and in the error message for the hole it's not showing me the context it would have inferred from the first argument. It's something like `gcastWith (prfAddComm n (SS m)) $ _prfAddComm1`
16:04:12 <heptahedron> The context I would have expected it to infer being `AddNat n (S m) ~ AddNat (S m) n`, roughly
16:05:55 <mniip> ah, rankN
16:06:42 <mniip> heptahedron, inference doesn't work that way backwards
16:07:38 <heptahedron> mniip: Yeah my grasp on how types are unified at this level of complexity is fairly weak, haha. Any pointers?
16:08:39 <mniip> whenever you have (informally speaking) a ((c => a) ~ b) equality, the typechecker can't force the c on b, it can only verify if the inferred type of b contains a c, and if so, discarding it would yield a unification for a
16:10:43 <heptahedron> mniip: so what you're saying is, roughly, I can't apply the commutativity proof to only one side of the equality?
16:11:26 <mniip> I'm not sure this has anything to do with that
16:12:04 <mniip> what I'm saying is, you can't hole a (c => a) argument of a function and expect GHC to add the c=> to hole's context
16:13:06 <heptahedron> oh hm.
16:14:17 <mniip> think about it,
16:14:27 <mniip> if you have, say, f :: (c => r) -> r
16:14:58 <mniip> rather
16:15:02 <mniip> if you have, say, f :: (C => r) -> r
16:15:15 <mniip> if you have (f (x :: D => X)) then r ~ D => X
16:15:20 <mniip> if you have (f (x :: C => X)) then r ~ X
16:16:37 <mniip> I don't know enough about RankN type inference to tell you what's the problem with inferring a quantified type like that if X can always subtype to C => X
16:16:45 <mniip> but I'm sure there's one somewhere out there
16:26:33 <parsnip> should the first 3 of these be 4? https://github.com/haskell/haskell-mode/blob/master/haskell-indentation.el#L53-L76
16:27:00 <parsnip> for example, according to this: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md#indentation
16:35:21 <heptahedron> parsnip: Looks like it to me, yeah
16:35:39 <parsnip> i've tried it for a few minutes, seems to make more sense.
16:36:16 <[Leary]> Good style is a matter of taste though. Is there any particular reason haskell-mode should follow that one guide? Personally I never indent by four spaces.
16:36:40 <heptahedron> parsnip: Yeah I've been running into that right now actually, where my `where` is at the same level of indentation as the code preceding it, and it looked weird but I just went with it
16:37:22 <parsnip> i'm not going so far as to say what defaults should be in haskell-mode, but any time i add a block in my hakyll site.hs, it's not going with surrounding convention.
16:37:32 <heptahedron> [Leary] has a point too. I prefer 2 just for compactness but I don't have a great answer for how to indent my `where` blocks now without just shifting everything above it over by 2 and that feels weird too
16:39:10 <parsnip> one day, we will all be using an LSP
16:39:36 <lyxia> just indent "where" by 1 space
16:39:44 * lyxia ducks.
16:40:05 <heptahedron> lyxia: odd numbers give me the heebie jeebies
16:40:16 <heptahedron> I recognize the irony in this statement
16:40:34 <shapr> it's hep to be square
16:40:48 <EvanR> odd numbers
16:40:53 <EvanR> are isomorphic to the evens!
16:41:03 <EvanR> your heebie jeebies arent categorical
16:41:11 <shapr> heptahedron: synesthesia?
16:41:30 <heptahedron> shapr: grapheme-color, yes actually
16:41:46 <shapr> shapr is short for synesthesist, I dig it.
16:41:49 <parsnip> you have to know category theory to get jokes on #haskell
16:42:08 <EvanR> and to write hello world in haskell
16:42:35 <heptahedron> EvanR: somehow they are not deterred by their failure to compose/have identity
16:43:51 <heptahedron> shapr: how is it short for that?
16:44:10 <mark721> hi guys quick question
16:44:21 <mark721> what's the difference between a class constraint and a typeclass
16:44:27 <mark721> or are they synonyms
16:45:18 <EvanR> whats the similarity
16:45:30 <mark721> what do you mean
16:45:42 <mark721> i feel they are exactly the same but i'm not sure?
16:45:44 <parsnip> class is synonym for typeclass?
16:46:08 <EvanR> constraints go before the => in a type signature
16:46:09 <lyxia> a (type) class is an interface that some type may implement, and a class constraint is a requirement that a type implements the corresponding interface
16:46:12 <parsnip> in other words, class is different from class constraint
16:46:51 <mark721> lyxia, perfect definition :)
16:47:01 <EvanR> i hope that wasnt homework
16:47:05 <mark721> No
16:47:10 <mark721> i was reading
16:47:26 <mark721> haskell the craft of functional programming then went on to learn haskell
16:47:35 <mark721> then i couldn't understand why they had two terms that seemed the same
16:48:25 <mark721> anyway gotta run ty again
16:58:44 <d-fish> How does streaming IO work with streamly? file handles?
17:21:44 <d-fish> The examples at <https://hackage.haskell.org/package/streamly-0.1.0/docs/src/Streamly.Examples.ListDirRecursive.html>. I want to stream the contents of a file into a function
17:41:45 <Gurkenglas> That example file does not contain tools to read the contents of a file
17:42:53 <Gurkenglas> Where is this "Path.IO (listDir, getCurrentDir)"?
17:43:12 <d-fish> It's from path-io
17:44:06 <Gurkenglas> https://hackage.haskell.org/package/streamly-0.1.0/docs/Streamly-Prelude.html#v:fromHandle says it can turn a handle into the sort of stream streamly works with
17:45:09 <d-fish> I didnt' see that!
17:45:15 <d-fish> *notice it
17:45:50 <Gurkenglas> Clicking on Handle finds https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-IO-Handle.html#t:Handle under which one finds https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-IO-Handle.html#v:mkFileHandle which turns file paths and some additional configuration values into a handle
17:46:41 <d-fish> I wanted to read bytestrings, but maybe I could hack something together
17:47:02 <Gurkenglas> http://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-IO-Handle-FD.html finds some handles (found that by hayooing stdin)
17:48:40 <Gurkenglas> d-fish, you should be able to unpack the lazy ByteString into a list and feed that through https://hackage.haskell.org/package/streamly-0.1.0/docs/Streamly-Prelude.html#v:each
17:49:31 <heptahedron> Is there anything in Haskell that would let you change the default way GHC names unification variables for a given type? how is this even decided currently?
17:50:26 <d-fish> Gurkenglas: good idea, I'll look into that
17:51:49 <Gurkenglas> And looking at https://hackage.haskell.org/package/streamly-0.1.0/docs/src/Streamly.Prelude.html#each , ByteString.foldr cons nil should work
17:51:49 <dmwit> heptahedron: I doubt there are controls for that. You could write a plugin to adjust the type after unification, maybe?
17:51:57 <Gurkenglas> *d-fish
17:52:13 <heptahedron> dmwit: er, adjust the type?
17:52:52 <dmwit> heptahedron: alpha-vary it only, most likely
17:53:27 <heptahedron> dmwit: Oh hm. I don't know that I'm knowledgeable enough yet to get around okay in GHC's implementation but maybe someday!
17:53:29 <dmwit> Come to think of it, that probably wouldn't affect error reporting at all, which is probably what you're after.
17:54:01 <dmwit> GHC plugins don't require you to muck about with GHC's implementations. You can write an arbitrary Core -> Core function.
17:54:21 <heptahedron> dmwit: Yeah, working with dependent types, it's naming all my variables in a similar way, would ease development if they were closer to what I specified heh
17:54:40 <heptahedron> dmwit: I don't even know anything about the Core lang yet, sadly
17:54:41 <dmwit> GHC works hard-ish to keep type variable names you explicitly declare.
17:55:14 <heptahedron> It might be complected by the fact I'm using a plethora of extensions and singleton types
17:55:20 <dmwit> Perhaps at this point it would be good to give an example of a place you see a badly named variable and what you'd like to see instead.
17:55:29 <dmwit> The smaller the better.
17:55:47 <dmwit> (I may not be around to answer, though. Dinner time!)
18:01:51 <Gurkenglas> There was this alternative to lambda calculus where you have strings running around in a 2d space and use local rules to reduce it to a normal form, anyone remember that?
18:07:17 <lyxia> Gurkenglas: To Dissect a Mockingbird http://dkeenan.com/Lambda/index.htm ?
18:08:59 <Gurkenglas> lyxia, no that's just lambda calculus in pink, I remember something that actually does its own thing
18:09:40 <Gurkenglas> If anyone remembers it @tell me, time for sleep.
18:40:15 <hololeap> "strings running around in a 2d space" -- i'm imagining little inchworm strings
18:54:21 <ReinH> That's a category!
18:54:51 <ReinH> The diagrams used in https://graphicallinearalgebra.net/ also form a category, which is cool
18:59:56 <pikajude> hmm, weird
19:00:50 <pikajude> errors like this http://lpaste.net/362115 usually mean you're missing a module in the cabal file, right?
19:03:50 <MarcelineVQ> I've seen similar as linker errors during compile time, typically cause by a missing "other-module:" duno about dynamic
19:04:56 <pikajude> :(
19:04:58 <MarcelineVQ> is a verson mismatch possible?
19:05:05 <pikajude> unlikely
19:05:15 <pikajude> unless something has gone drastically wrong with the nix haskell module builder
19:05:18 <pikajude> err, package builder
19:07:37 <geekosaur> that looks like at TH load/run time QuickCheck is not being included as a link library
19:08:03 <pikajude> right
19:08:26 <pikajude> i'm gonna check if that symbol actually exists in the quickcheck dylib I guess
19:08:34 <pikajude> normally this is a missing other-modules: entry but it certainly isn't this time
19:08:44 <pikajude> thank you new cabal/ghc/whatever for warning me :)
19:10:25 <pikajude> it's been about 18 months since i used nm, this is going to be tough
19:10:55 <geekosaur> nix has its own "fun"
19:11:23 <pikajude> err, wait
19:11:24 <pikajude> ok
19:11:33 <geekosaur> people have fairly often run into incorrect nix dependencies; zlib is the one most people run in to, but probably not the only one
19:11:40 <pikajude> all the symbols in the dylib start with _Quick, not _QuickCheck
19:11:50 <geekosaur> that sounds odd
19:11:51 <pikajude> _QuickzuAUk6S22Cw14BQtGjojOgjf_TestziQuickCheckziText_zdwxs_closure
19:12:04 <pikajude> _Quick, someone z-decode that
19:12:40 <geekosaur> not much to decode there, it's mostly abi hash >.>
19:12:55 <pikajude> it is, yeah
19:13:05 <geekosaur> and I;d expect a package version on that too
19:13:18 <pikajude> yep, actual symbol is '_QuickzuAUk6S22Cw14BQtGjojOgjf_TestziQuickCheckziGen_elements_closure'
19:13:18 <geekosaur> wonder if nix tried to elide that from the symbols, and ate too much
19:13:34 <pikajude> bizarre
19:13:40 <pikajude> it's missing an entire chunk of the name
19:13:52 <pikajude> it's not even the same ABI hash
19:14:03 <pikajude> ????
19:14:45 <geekosaur> lokks same to me? (zu is an encoded underscore preceding the actual hash)
19:14:58 <pikajude> yeah, but those two symbols are from the same dylib
19:15:06 <pikajude> the expected symbol is in the paste
19:15:07 <pikajude> sorry for the confusion
19:15:12 <pikajude> i confused myself in the same way
19:15:15 <geekosaur> oh
19:15:50 <geekosaur> right, and the one in the paste is the one I would expect
19:16:03 <geekosaur> so something has mangled the symbols in the QuickCheck package somehow
19:16:16 <pikajude> but it's a different hash, too
19:16:34 <pikajude> wasn't there a change from package IDs to package keys around the 7 -> 8 transition?
19:16:38 <geekosaur> "QuickCheck-2.10.1_" somehow got changed to "Quick_"
19:16:41 <pikajude> this vaguely reminded me of that
19:17:32 <geekosaur> and that could also alter the ABI hash, depending on how whatever mangled it
19:17:38 <pikajude> oh, ok
19:17:39 <geekosaur> I'd be tempted to suspect nix, tbh
19:17:47 <pikajude> i'm rebuilding without nixpkgs config
19:17:50 <pikajude> to see if i've fucked something up
19:19:21 <geekosaur> also I think the package ids are used on the command line, but the hashes are still used in symbols. the ids are just to make command lines slightly less unwieldy
19:20:15 <geekosaur> (but I could be wrong. still, the symbols Ive seen in 8.2.2-generated libs still seem to have ABI hashes in them)
19:20:21 <pikajude> sure
19:20:35 <pikajude> i thought package keys were just a shorter hash syntax
19:21:40 <dibblego> echo ":quit" > ./.ghci && ghci # this loads ghci, how can I make ghci quit if it is called in a directory ?
19:29:30 <pikajude> yeah, with empty nixpkgs config it builds fine
19:29:34 <pikajude> so i have bollocksed something up and no mistae
19:36:01 <hololeap> are there any good typeclasses that can be utilized by something like this: newtype Lookup a = Lookup (Int -> (Maybe a, Maybe (Lookup a)))
19:36:31 <Axman6> well, that looks like a functor to me, for one
19:36:44 <Axman6> possibly also an Applicative
19:37:09 <hololeap> the circular thing throws me off
19:37:10 <Axman6> yeah should be Applicative. Unsure about Monad
19:37:58 <mnoonan_> maybe work it out for “LookupF a t = LookupF (Int -> (Maybe a, Maybe t))” first
19:38:11 <Axman6> instance Functor Lookup where fmap f (Lookup g) = Lookup (\i -> bimap (fmap f) (fmap (fmap f)) (g i))
19:38:19 <hololeap> like is there a typeclass for self-referential structures like that? i have seen arrows that return a new arrow, but this isn't abstract enough to be an arrow, i don't think
19:39:12 <Axman6> it's similar to many of the streaming libraries
19:39:19 <hololeap> btw, it's supposed to crawl over a Free IntMap a
19:39:21 <Axman6> it's basically a generator function
19:39:26 <Axman6> like unfoldr
19:39:30 <Axman6> :t unfoldr
19:39:32 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
19:40:39 <Axman6> :t bimap
19:40:41 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
19:41:10 <hololeap> i looked at Data.Functor.Compose, but i don't think i could twist that into something self-referential
19:43:49 <hololeap> what does it mean by "Right-to-left composition of functors."
19:44:26 <hololeap> does that mean Compose f g a ~ g (f a) ?
19:45:00 <Axman6> f (g a)
19:45:06 <Axman6> which isn't what you have
19:45:27 <lyxia> hololeap: (Co)Recursive in the recursive-schemes library
19:45:29 <Axman6> well, actually, maybe, if a is a monoid
19:45:40 <hololeap> well, it's not supposed to be functorial for `Maybe a`
19:45:49 <Axman6> it's basically Compose ((-> Int) (Maybe a,)
19:45:51 <Axman6> almost
19:45:51 <mark__> I'm getting a compilation error for a code snippet from "Learn yourself a haskell for great good". Specifically, on the linked page (ctrl + f "null line"). Can someone point me to how to fix it?
19:45:53 <mark__> http://learnyouahaskell.com/input-and-output
19:46:57 <Axman6> Compose ((-> Int) (Compose (Maybe a,) Compose Maybe Lookup) (I think there's a Fix type that would allow that...)
19:48:05 <hololeap> right... i was thinking this might be related to Fix
19:48:24 <mark__> Here's the code snippet for my compilation error: http://lpaste.net/362116
19:48:25 <hololeap> i'm basically just trying to increase the number of tools at my disposal
19:49:10 <lyxia> mark__: indent the body of main
19:49:26 <geekosaur> not this one again
19:49:36 <mark__> thanks!
19:49:39 <geekosaur> NondecreasingIndentation has a lot to answer for
19:50:03 <hololeap> some of the libraries in base are really arcane to me
19:51:00 <MarcelineVQ> dibblego: :commands don't seem to to anything when run in a ghci file, except :set and :define maybe, however    import Unsafe.Coerce  unsafeCoerce "dsdaasd" 0    is humerously effective, on my computer
19:51:51 <geekosaur> ghci ignores certain commands for security reasons. this is not documented anywhere and iirc there's a bug open for it
19:52:40 <lyxia> hololeap: in base? do you mean modules?
19:52:45 <metahumor> there's a not-unknown haskell blogger that complains a lot about how ghci does not properly implement Haskell
19:52:50 <MarcelineVQ> threads are similarly opaque so you can't just call killThread on ghci's main thread, as far as I can determine anyway
19:53:16 <hololeap> i think it was pretty obvious what i meant, whatever your preferred terminology is
19:53:24 <Axman6> MarcelineVQ: what does that mean? :\
19:53:31 <Axman6> uh, metahumor
19:53:36 <geekosaur> ghci's certainly weird. it's never going to do haskell "properly" because haskell is pretty firmly file-based
19:53:46 <MarcelineVQ> it means that myThreadId doesn't refer to the ghci session
19:54:18 <metahumor> Axman6: one of his examples is, why should a naked expression evaluate its Show instance, thus forcing it?
19:55:04 <geekosaur> o.O someone is keen on not getting the point
19:55:08 <Axman6> "Haskell" defines nothing about how a repl should behave, and that behaviour is clearly pretty useful as a default position
19:55:25 <metahumor> i'm trying to find the exact quote
19:56:03 <geekosaur> if they want "runghc -", they know where to find it
19:56:34 <dibblego> looks like I can use :!
19:56:38 <mud> metahumor: Because it's useful, and that's kind of universally how repls work
19:56:48 <geekosaur> interesting, I thought that was one of the disabled commands
19:56:59 <metahumor> I am a huge fan of ghci, i just was interested in that pedantic opinion
19:57:07 <geekosaur> this is why the current situation wrt undocumented .ghci behavior sucks
19:57:27 <MarcelineVQ> Oh? I wasn't able to use :!  at least not in a way that was useful, output caused by it wasn't displayed  at least
19:58:39 <MarcelineVQ> "okay so what are my steps, hmm... get program name, call out to ps for the pid, send kill, question why I'm doing this"
19:58:55 <geekosaur> if sh is bash, $PPID might work
19:59:27 <geekosaur> ...ding
20:00:10 <hololeap> this actually works: newtype Lookup a = Lookup (Compose ((->) Int) (Compose ((,) (Maybe a)) (Compose Maybe Lookup)) a)
20:00:18 <MarcelineVQ> now I wonder if ghci captures kills instead of dying
20:00:34 <hololeap> if i have: instance Functor Lookup where fmap f (Lookup c) = Lookup $ f <$> c
20:00:42 <geekosaur> it does. but kill -9 works :p
20:00:59 <geekosaur> Prelude> :!kill $PPID
20:00:59 <geekosaur> ghc: signal: 15
20:00:59 <geekosaur> Prelude>
20:01:04 <MarcelineVQ> if your users has -9 permission <_<
20:01:30 <metahumor> lol it translates a 9 to a 15 signal
20:01:48 <geekosaur> what? no, I showed whgat the default (which is SIGTERM) does
20:01:50 <MarcelineVQ> oh nvm I was entering -9 wrong, it wasn't a permission thing
20:01:53 <geekosaur> you can;t translate signals
20:02:05 <geekosaur> er, you can;t trap SIGKILL and convert it
20:02:11 <metahumor> oh misread, i read "kill" as "kill -9"
20:02:34 <geekosaur> has to come before the pid. yeh
20:02:48 <geekosaur> because -pid is a process group, and you;re unlikely to have permission to kill a system process
20:02:59 <MarcelineVQ>  :! kill -9 $PPID in .ghci works as suggested here
20:04:25 <MarcelineVQ> ah neat if you use :! echo  you can even get a message out before kill
20:05:38 <MarcelineVQ> dibblego: Who/what is this for though? there's plenty of ways around a .ghci
20:06:06 <dibblego> MarcelineVQ: data61/fp-course where people keep going into ./src/Course then hit problems
20:07:46 <MarcelineVQ> ah a little tamperproofing for the unaware. is this avoided with cabal repl or stack repl in ./src/Course?  the latter of the two should load the project the same, not sure about cabal
20:08:45 <dibblego> we just use ghci now, some people just refuse to stay in the right directory, then get burnt
20:12:08 <geekosaur> also, what happens when they try that on windows?
20:12:36 <dibblego> try to use :! in .ghci ?
20:12:56 <geekosaur> that "kill" is unlikely to do what you want. windows doesn;t have the same "signal" concept
20:13:34 <mud> Maybe you can get something to display a big "Ugh don't do this!" message instead of just killing ghci?
20:13:42 <dibblego> I got the message working
20:13:48 <mud> Oh okay
20:14:15 <metahumor> could you edit the .ghci to mask a :! call?
20:14:15 <Axman6> make running in that directory produce a custom type error (using the new GHC type errors stuff)
20:15:36 <metahumor> whoo WSL no longer GSODs on trying to build hoogle
20:43:40 <koz_> metahumor: GSOD = Green Screen Of Death?
20:44:05 <nickuwo> hey everyone! Why does :t length give "Foldable t => t a -> Int" instead of "(Foldable t, Integral b) => t a -> b"?
20:44:41 <koz_> nickuwo: The same reason why genericLength and co exist.
20:45:19 <koz_> :t genericLength
20:45:21 <lambdabot> Num i => [a] -> i
20:45:33 <koz_> Wow, _Num_?
20:47:35 <metahumor> koz_: yeah, i'm on insider builds
20:47:59 <metahumor> nickuwo, koz_: you should still use length
20:48:11 <metahumor> and use "fromIntegral . length" if you need Integral a
20:48:25 <geekosaur> nickuwo, mostly performance I think.
20:48:34 <geekosaur> metahumor, thinko... you get Num a
20:48:47 <metahumor> right
20:49:27 <metahumor> well, technically correct
20:49:35 <nickuwo> geekosaur: ok, but my alternate type would "work" as well
20:49:46 <metahumor> :t length
20:49:48 <lambdabot> Foldable t => t a -> Int
20:49:53 <metahumor> :t fromIntegral . length
20:49:55 <lambdabot> (Foldable t, Num c) => t a -> c
20:50:07 <nickuwo> or would mine not cover some cases
20:50:25 <geekosaur> nickuwo, I said performance, not capability
20:50:37 <nickuwo> k
20:51:09 <geekosaur> there's two possible ways to do it: use Int internally and fromIntegral at the last step, or do it with the native type. for some native types, the second one could be fairly expensive
20:51:16 <geekosaur> as would be doing it with Integer as the intermediate
20:51:36 <geekosaur> wheras with Int ghc can usually optimize the heck out of it
21:17:07 <dsal> I've got a thing that generates values I'd like to be consumed by a few concurrent actors.  Is https://hackage.haskell.org/package/concurrent-extra-0.7.0.11/docs/Control-Concurrent-Broadcast.html a good choice?
21:17:27 <heptahedron> if you want to come witness the awful things I am doing with dependent types/possibly help me I'm on at https://twitch.tv/heptahedron
21:18:00 <heptahedron> If this kind of stuff isn't permitted here, I'm sorry, I didn't see anything in the MOTD!
21:44:41 <metahumor> heptahedron: can't see your channel
22:00:23 <metahumor> :r
22:13:11 <heptahedron> metahumor: https://www.twitch.tv/braxblaster doesn't work?
22:16:52 <boj> i see an example like: instance F a => G a (Maybe x) where: f v _ = f v (Proxy @x) -- however, when i attempt this my compiler says i have a parse error on input '@'. what am i missing here?
22:17:19 <boj> i'm not familiar with this @ syntax at all
22:17:21 <Axman6> TypeApplications
22:17:36 <Axman6> :t const @Int @Bool
22:17:37 <lambdabot> error: parse error on input ‘@’
22:17:41 <Axman6> bleh
22:17:52 <metahumor> :t pure @Maybe
22:17:54 <lambdabot> error:
22:17:54 <lambdabot>     Pattern syntax in expression context: pure@Maybe
22:17:54 <lambdabot>     Did you mean to enable TypeApplications?
22:18:05 <metahumor> @set -XTypeApplications
22:18:08 <Axman6> yes we did lambdabot
22:18:17 <metahumor> :t pure @Maybe
22:18:19 <lambdabot> error:
22:18:19 <lambdabot>     Pattern syntax in expression context: pure@Maybe
22:18:19 <lambdabot>     Did you mean to enable TypeApplications?
22:18:26 <metahumor> anyway, that's how it works
22:18:56 <Axman6> boj:  Proxy @x is a simpler way of writing (Proxy :: Proxy x) in that case
22:19:27 <boj> Axman6: cool, thanks
22:19:52 <geekosaur> also if it doesn't recommend TypeApplications, it's probably too old to support it
22:20:09 <Axman6> which is what you should use if you don't want that extension (but you will otherwise need ScopedTypeVariables so I would just turn it on - I think you need that either way)
22:20:26 <boj> yeah, whole new mess of errors now :)
23:11:02 <sebastianrkg> what's the best way to forkIO inside a monad transformer stack like ReaderT +IO a?
23:11:19 <Axman6> there's a package for that...
23:11:33 <sebastianrkg> whoops, hit enter too quick. I meant, ReaderT Config IO a
23:11:35 <Axman6> @hoogle fork
23:11:35 <lambdabot> Control.Concurrent.Lifted fork :: MonadBaseControl IO m => m () -> m ThreadId
23:11:35 <lambdabot> Turtle.Prelude fork :: MonadManaged managed => IO a -> managed (Async a)
23:11:35 <lambdabot> Control.Monad.Par fork :: Par () -> Par ()
23:11:40 <sebastianrkg> oh!
23:11:49 <Axman6> I think you want the top one
23:12:30 <sebastianrkg> thanks, cool
23:24:32 <quchen> How do I get »stack script« to load my ».ghci« file? It’s simply ignored :-/
23:25:47 <quchen> Nevermind, ignore me, »writable by someone else«, should have read GHCi’s startup messages.
23:42:22 <BN__> hello
23:43:21 <johnw> sebastianrkg: yes, monad-control is what you want, and lifted-base makes it easier to use for common patterns
23:43:28 <johnw> (which is where the top hit comes from)
23:43:39 <BN__> I haven't been here before but I was wondering if anybody could help me in figuring out how to make a monad stack with ST and ReaderT containing Mutable Vectors
23:43:53 <BN__> I can't seem to thread the rank N typed s
23:46:01 <BN__> the code currently is like this
23:46:02 <BN__> http://lpaste.net/362119
23:50:40 <quchen> BN__: What happens if you delete the type annotation in line 49?
23:51:53 <BN__> it still has the skolem type error the s in ST s
23:52:18 <johnw> you don't want to preserve the 's'
23:52:39 <BN__> i dont quite understand rank n types
23:52:41 <johnw> the only way you could use that as a type variable to CpuEnv, is if the CpuEnv's you create only live within the runST invocation
23:52:58 <johnw> think of rank-n types as "polymorphic functions as values"
23:53:05 <johnw> but that's not really the problem here
23:53:06 <BN__> as i understand it the s should only live in ST s
23:53:12 <BN__> as it's thread local
23:53:21 <BN__> but as i understand it
23:53:23 <johnw> right
23:53:33 <BN__> the CpuEnv needs to be frozen and im still within ST s
23:53:42 <BN__> so shouldnt the s be the same as the St s?
23:53:48 <johnw> let me try this here
23:54:57 <johnw> one sec, didn't have primitive
23:57:37 <BN__> btw
23:57:42 <BN__> the simple version
23:57:52 <johnw> ooh, yes?
23:57:54 <BN__> where it just return an a
23:58:09 <jle`> BN__: you might have a DMR issue
23:58:10 <johnw> i'm almost done adding primitive to my global environment
23:58:11 <jle`> with readerComp
23:58:21 <BN__> i managed to spam forall s till it compiled
23:58:53 <BN__> runST $ runReaderT (unCpu cpu) env
23:58:58 <jle`> BN__: runST expects (runreaderT readerComp env) to be polymorphic in s
23:59:14 <jle`> but since you name it, GHC picks a monomorphic type for s
23:59:32 <jle`> cause of DMR
23:59:37 <jle`> you can give it a type signature to counteract this
