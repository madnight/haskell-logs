00:00:01 <cocreature> miller: no it’s not, take a look here http://hoogle.haskell.org/?hoogle=(%3A%3D)%20package%3Awreq
00:02:15 <vjousse> Thanks a lot cocreature, it works! I suppose that the API of http-client has changed since the post I found on stackoverflow and I was a little bit lost. Makes sense now. I may add an answer to the stackoverflow post btw
00:02:50 <vjousse> It was this post: https://stackoverflow.com/questions/36361611/wreq-get-post-with-exception-handling
00:03:37 <dmj`> vjousse: http://lpaste.net/4881057476650205184
00:05:43 <miller> Oh.  hoogle.haskell.org != haskell.org/hoogle .  Okay then.
00:05:58 <miller> Thanks!
00:09:07 <vjousse> thanks dmj`! love the lpaste thing
00:09:49 <dmj`> yea lpaste is a good thing
00:11:37 <vjousse> dmj`: this error comes when you activate warning at compile time I suppose?
00:12:01 <vjousse> (love this undefined value too, useful for @TODO stuff)
00:12:08 <dmj`> vjousse: the code I pasted you doesn’t give me any compile time warnings
00:12:24 <dmj`> @def todo = undefined
00:12:29 <lambdabot>  Defined.
00:13:17 <vjousse> dmj`: lpaste tolds me
00:13:20 <vjousse> 19:30: Error: Redundant do
00:13:22 <vjousse> Found:
00:13:24 <vjousse>   do (Right <$> post url (toJSON $ Credentials loginId password))
00:13:26 <vjousse>        `E.catch` handler
00:13:28 <vjousse> Why not:
00:13:30 <vjousse>   (Right <$> post url (toJSON $ Credentials loginId password))
00:13:32 <vjousse>     `E.catch` handler
00:13:45 <dmj`> Oh, yea, sorry, yea that might be hlint running
00:15:18 <dmj`> vjousse: I just ran hlint, and it shows up
00:18:47 <geekosaur> yes, the 'do' does nothing there
00:18:57 <geekosaur> but that's hlint, not the compiler
00:19:47 <dmj`> > do do do 1 + 1
00:19:51 <lambdabot>  2
00:20:33 <vjousse> :-)
00:27:15 <olligobber> > do return do return 1
00:27:19 <lambdabot>  <hint>:1:11: error: parse error on input ‘do’
00:29:23 <olligobber> > do [undefined]; [1];
00:29:28 <lambdabot>  [1]
00:33:48 <dmj`> do obfuscation contest?
00:43:02 <ongy> can I manually trigger a major GC and/or set some RTS options to have it be more aggresive about triggering it?
00:57:09 <EvanR> ongy: System.Mem performGC and such
00:57:44 <EvanR> there are also RTS options to tune gc behavior, probably documented in the GHC manual
01:00:16 <ongy> thx
01:01:51 <ongy> ForeignPtr s are apparently cleared less often than I thought in normal situations. Good to know
01:06:57 <oo_miguel> having a datatype as: Foo {blah= 10, bum = 20} ... can I extract the data similar to : let Foo (a,b) = instanceOfTheType ?
01:07:27 <EvanR> you would say
01:07:47 <EvanR> let Foo a b = myFoo in ...
01:07:52 <EvanR> not Foo (a,b)
01:07:54 <[exa]> oo_miguel: \(Foo a b) -> ...
01:08:01 <oo_miguel> aa ok, thank you
01:08:17 <jle`> oo_miguel: just like how you can do `Foo 10 20` to make a new Foo, you can pattern match on `Foo a b`
01:08:31 <oo_miguel> yes, it makes absolutely sense
01:08:35 <jle`> oo_miguel: alternatively you can use record syntax too, let Foo { blah = a, bum = b } = ...
01:08:49 <oo_miguel> thank you all
01:08:56 <[exa]> jle`: wow didn't know about that
01:08:59 <jle`> oo_miguel: small note, 'instance' in Haskell means something different than it does in other languages :)
01:09:12 <jle`> [exa]: yeah it's nice cause you can do it out of order, and even leave off records you don't care about
01:09:21 <oo_miguel> I was afraid you will get me on the wording "instance" ;)
01:09:25 <oo_miguel> just was not sure how to call it
01:09:32 <jle`> oo_miguel: 'value' is how we call it in haskell :)
01:09:38 <oo_miguel> allright!
01:09:40 <[exa]> jle`: my case was patternmatching while preserving extensibility of the record. fixed. :D
01:09:44 <jle`> the problem with 'instance' is that 'instance' is used in Haskell to refer to other things as well
01:09:58 <jle`> s/other things as well/something else completely
01:10:08 <oo_miguel> hah ok
01:10:23 <jle`> as in, haskell has a language concept that uses 'instance', so it's potentially confusing to use them to mean value :)
01:10:26 <jle`> just a heads up, not a big deal
01:11:03 <oo_miguel> you are right.. instances are like Show, Eq etc. I will be more careful about the woring.
01:11:14 <jle`> (those are typeclasses, but i think you get the idea!)
01:11:18 <[exa]> oo_miguel: these are classes </nitpicking>
01:11:49 <jle`> [exa]: it's also a trick you can do with non-records, as well
01:12:25 <jle`> isJust Just{} = True
01:12:25 <[exa]> like, patternmatching head/tail on list?
01:12:29 <jle`> isJust Nothing = False
01:13:20 <jle`> @let isJust' Just{} = True; isJust' Nothing = False
01:13:24 <lambdabot>  Defined.
01:13:25 <jle`> > isJust' (Just 10)
01:13:29 <[exa]> oh so, just omitting nonexistent fields, got it
01:13:29 <lambdabot>  True
01:13:30 <jle`> > isJust' Nothing
01:13:34 <lambdabot>  False
01:13:40 <[exa]> s/nonexistent/unnamed/
01:13:56 <jle`> mhm, omitting the fields you don't care about and only mentioning the ones you do...which is no fields, in this case
01:14:19 <[exa]> underscores on steroids
01:14:27 <jle`> it's a bit silyl for Just, but for constrauctors with several fields, Foo _ _ _ _ _  -> ... could be written as Foo{} -> ...
01:45:00 <oo_miguel> I want to implement a few simple threads and share data between them. Where should I start?
01:45:49 <Brian01> Hello all!
01:45:55 <Brian01> How do I fix this error:
01:45:57 <Brian01> "    Not in scope:       type constructor or class ‘Data.Vector.Storable.Vector’     No module named ‘Data.Vector.Storable’ is imported.     | 245 | getImageDataVector :: Image a -> Data.Vector.Storable.Vector"
01:46:25 <EvanR> oo_miguel: simple, use forkIO from Control.Concurrent
01:46:46 <Brian01>    Could not find module ‘Data.Vector.Storable.Vector’     Perhaps you meant       Data.Vector.Storable (from vector-0.12.0.1)       Data.Vector.Storable.Internal (from vector-0.12.0.1)       Data.Vector.Storable.Mutable (from vector-0.12.0.1)     Use -v to see a list of the files searched for.   | 4 | import qualified Data.Vector.Storable.Vector as DVSV
01:47:06 <Brian01> Okay, found it...
01:47:09 <Brian01> nevermind
01:52:17 <mjrosenb> so, in a typeclass, can I require instances to define a type as well as a a bunch of values?
01:52:26 <oo_miguel> EvanR: thank you, forkIO works fine. Just not sure how to share data between two threads
01:52:52 <EvanR> what do you mean by share data
01:53:44 <oo_miguel> EvanR: I have threads reading data from multiple websockets.. and want to aggregate it and perform some work on it
01:54:43 <EvanR> so do you want 1 thread per websocket that each dumps messages into a channel, read by 1 processing thread
01:55:01 <oo_miguel> EvanR: sounds great :)
01:55:21 <oo_miguel> I have to look at "channels"
01:55:21 <EvanR> ok... so theres Control.Concurrent.Chan
01:55:26 <oo_miguel> thank you!@
01:55:48 <EvanR> if you cant see any of this before i recomment reading about MVars
01:56:24 <oo_miguel> I see all this for the first time now. I will follow your suggestion thank you
02:06:59 <[exa]> oh lord, even stack installs by `curl ... | sh -`   :/
02:07:10 <[exa]> and asks for password
02:08:29 <HEGX64> mjrosenb: Depending on the application you might be able to make your typeclass have a second type argument (like Either does). How would you even use the typeclass instance's type anyway?
02:09:07 <ongy> "even stack", erm? :)
02:11:12 <[exa]> ongy: it's like seeing each packaging framework totally fail at actual packaging at once
02:11:33 <[exa]> nevermind. :]
02:11:45 <mjrosenb> HEGX64: as the return value from functions, and on occasion, the argument to a function.
02:16:11 <mjrosenb> ahh, it looks like I may want type families?
02:16:23 <mjrosenb> class GMapKey k where
02:16:24 <mjrosenb>   data GMap k :: * -> *
02:25:45 <chocopuff> is it just me, or does it seem like a "toBinary" function is missing?
02:26:09 <chocopuff> one that takes in an Int (or a String) and returns a base 2 Binary representation of it
02:26:19 <chocopuff> i have to write that one myself right
02:28:47 <bq> Hmm, got my SSB transceiver to 7 nW of carrier when no modulation is being applied
02:28:56 <[exa]> :t showIntAtBase   -- chocopuff
02:28:58 <lambdabot> (Show a, Integral a) => a -> (Int -> Char) -> a -> ShowS
02:29:07 <bq> Ack, wrong channel
02:29:20 <EvanR> chocopuff: how do you show a String in binary?
02:29:30 <EvanR> also what is the type of a binary
02:29:34 <chocopuff> EvanR: I meant, binary rep of an int
02:29:48 <chocopuff> As in "3" -> "11"
02:30:34 <EvanR> i have a feeling other input and output types for this would be more useful
02:31:56 <EvanR> also make sure the Bits class in Data.Bits doesnt do what you want
02:32:28 <EvanR> Int is an instance of Bits
02:32:49 <chocopuff> that might be a better idea, looking into that
02:34:54 <olligobber> Data.Bits is a thing? I wonder if that would have helped with one of my projects...
02:36:41 <EvanR> its especially prudent for machine int types because there are more efficient primitives that access the bits
02:36:53 <olligobber> ah, I did look at it and decided not to use it
02:36:54 <EvanR> rather than implement bitwise ops using arithmetic
02:39:51 <cocreature> > let showBin x = showIntAtBase 2 intToDigit x "" in showBin 3 -- chocopuff
02:39:55 <lambdabot>  "11"
02:45:50 <winnner> Hi , from last 2months I tried so many programming languages like python,java, c, go, java script non I liked but I liked haskell alone but I am worried haskell have no jobs at all :(
02:47:06 <chocopuff> cocreature: thanks! saw it minutes after on stackexchange
02:47:19 <chocopuff> as well. but kinda seems bummer it's limited to up to base 16
02:47:38 <robstr> @winnner :P hehe this is true i think, but there are a few large companies working with haskell
02:47:38 <lambdabot> Unknown command, try @list
02:48:24 <cocreature> chocopuff: huh? I don’t think it’s true that showIntAtBase is limited to base 16
02:48:52 <chocopuff> cocreature: might have misread then
02:49:37 <winnner> robstr:  :(
02:49:57 <cocreature> > let show17 x = showIntAtBase 17 (\c -> chr (ord 'a' + c)) x "" in show17 16
02:50:01 <lambdabot>  "q"
02:50:26 <cocreature> ^ chocopuff
02:58:07 <geekosaur> the only way it could have that limitation is if the digit-to-character conversion has it
02:58:39 <chocopuff> geekosaur: good point, turns out I think that is the case?
02:58:50 <chocopuff> cocreature: yup, i see, thumbs up
02:59:33 <winnner> Can I know without job why so many nicks here and I wonder all are doing self projects ?
03:02:36 <geekosaur> that is symptomatic of bad thinking. you can just do the minimum necessary, and fall behind.
03:02:41 <geekosaur> or you can stretch yourself and do more
03:02:56 <geekosaur> Haskell will make you a better programmer in any language
03:07:12 <[exa]> winnner: in effect, you can write haskell-style in any reasonable language, with great success
03:09:20 <winnner> [exa]:  I want a genuine answer I am stuck with haskell vs C/C++  what do you suggest I really ike haskell style and hate c/C++ style but I dont find haskell so usefull to me unless I have my own company
03:09:31 <chocopuff> winnner: i'm kinda confused as to what you mean / are asking
03:10:07 <chocopuff> do you mean why so many ppl are learning haskell?
03:11:06 <winnner> chocopuff:  I also like haskell
03:11:20 <winnner> other than its deep learning curve
03:13:33 <chocopuff> yeah
03:14:37 <chocopuff> agreed, but here's to it getting better later. am new to haskell atm
03:16:17 <winnner> [exa]:  there friend what do you vote for ?
03:16:40 <[exa]> winnner: you need to separate the programming skills from their interpretation in a language
03:18:44 <winnner> [exa]:  I did not understand can you explain a little please?
03:18:55 <[exa]> winnner: c++ and haskell are both 'better' for different set of things. you might want to begin by identifying those two sets
03:21:35 <winnner> [exa]:  right now I have no goals or evn any idea what to achive all I wanted to is learn programming and build some software usefull to world and me, I come across machine learnign and tried python and realized I dont like language and I heard blockchain and tried c++ again I dont like, now I also tried haskell in between which I liked because its a bit like math formula I studied in my school but i am afraid it isnt used anywhere
03:22:06 <handyc> What’s “programming"?
03:22:32 <[exa]> "what"?
03:22:36 <[exa]> </philosophy>
03:22:45 <winnner> [16:51] -Sigyn- Your actions in #haskell tripped automated anti-spam measures, but were ignored based on your time in channel; stop now, or automated action will still be taken. If you have any questions, please don't hesitate to contact a member of staff
03:22:49 <winnner> is it to me ??
03:22:56 <handyc> I mean, if you don’t have goals, it will be difficult to know if you’ve achieved them
03:23:11 <[exa]> winnner: probably not. Invent a toy project and implement it
03:23:20 <[exa]> programming is best learnt by programming.
03:23:21 <handyc> The language that is going to be useful to you is somewhat dependent on what you want the computer to do
03:50:39 <winnner> [exa]:  if I am into C++ its hard to learn haskell again because its completely different to imprerative style
03:52:52 <[exa]> winnner: it's basically the same effort as the other way
03:56:23 <handyc> What’s wrong with knowing more than one language?
03:57:34 <handyc> I don’t think you will find it to be of much benefit to learn only Haskell and avoid all other languages.
03:58:56 <winnner> handyc:  sure , but When starting the one I dont find intresting say c or c++ they are not my style
03:59:36 <[exa]> winnner: you should start now :]
03:59:40 <handyc> winner: What’s “uninteresting” about them? What are you trying to accomplish? What would make one language more interesting than another, from your perspective?
04:00:52 <winnner> for example to write a list comprehension in c++ its possible ? I dont knwo
04:01:44 <winnner> [exa]:  true agreed but what you say c++ or haskell ?
04:02:31 <ggVGc> they fulfill entirely different roles
04:02:34 <[exa]> winnner: knuth's algorithms.
04:02:37 <ggVGc> it's all about what programs you want to make
04:02:37 <[exa]> :]
04:02:55 <ggVGc> I have exactly 0 overlap in my possible haskell and C++ usage
04:03:12 <winnner> [exa]:  what ??
04:03:42 <winnner> knuth algorithms is never in my list
04:03:56 <winnner> so every programmer must master those 4 volumes?
04:10:29 <geekosaur> eventually yes. but you can;t swallow the world in a single gulp
04:14:01 <asheshambasta> stack outputting the following, any ideas on what's going on? ```<no location info>: error:
04:14:01 <asheshambasta>     module ‘main:Main’ is defined in multiple files: /Users/asheshambasta/code/haskell/snaptest/src/Main.hs
04:14:01 <asheshambasta>                                                      /Users/asheshambasta/code/haskell/snaptest/src/Main.hs```
04:15:48 <geekosaur> would have to see your cabal file, but at a guess you have your test source file defined as both a main-is and as a module
04:18:11 <asheshambasta> I'm using stack so the cabal file is auto-generated
04:18:29 <geekosaur> then your project.yaml
04:18:47 <geekosaur> although I am likely less able to diagnose issues with that, since I am not a stack user
04:20:01 <asheshambasta> https://gist.github.com/asheshambasta/7b9ceff08f152e489034fad3eb47cb35
04:20:17 <asheshambasta> https://gist.github.com/asheshambasta/4b26d983c0e018c617a47c229832e69f ← cabal file
04:24:55 <geekosaur> yep. is that really the only thing in the project?
04:25:47 <geekosaur> basically, you have told it the library consists of your test program. which is pretty wrong, because it can't be used as a library if it contains a program's "main"
04:29:24 <asheshambasta> yeah
04:29:39 <asheshambasta> geekosaur: ah I see!
04:30:08 <geekosaur> if you're just prototypiong right now, I'd put a dummy module in the library and replace it later
04:30:33 <winnner> I see all haskellers know multiple programming languages and many of them hold phd and mostly academicians
04:30:49 <geekosaur> wouldn't bet on "many"
04:30:51 <geekosaur> I sure don't
04:31:16 <winnner> Haskellers are genius people out there and being a noob I shouldnt mess/ listen to them as they talk in their level :(
04:31:20 <geekosaur> no
04:31:31 <geekosaur> although if you want to argue yourself into a trap...
04:31:43 <geekosaur> "Argue for your limitations, and sure enough, they're yours"
04:31:48 <winnner> geekosaur:  you hold atleast MS or into programing for more than 10 years?
04:32:04 <geekosaur> have been in it for more than 10 years. no hdegree
04:32:24 <winnner> you got some job without degree?
04:32:40 <geekosaur> but if you;re goiing to argue years, ask yourself how you ever get 10 years of experience if you think you can;t do anything at all without 10 years of experience
04:33:03 <geekosaur> or, quit arguing yourself into a hole.
04:33:10 <geekosaur> do, or do not.
04:33:49 <winnner> geekosaur:  I think likr you yeah
04:33:53 <geekosaur> you learn by doing. you get experience by doing.
04:33:55 <[exa]> btw ever noticed that yoda speaks forth.
04:34:06 <geekosaur> you wil lnecessarily start small, but that does not mean worthless.
04:34:21 <geekosaur> the only time it;'s a problem is if you *stay* small.
04:35:48 <[exa]> winnner: anyway, just out of interest-- what motivates you to learn programming?
04:36:15 <asheshambasta> geekosaur: actually, it turns out that using Stack to try out snap is quite a pain
04:37:44 <winnner> [exa]:  I dont know, I watched some inspiring videos on youtube and heard story of satoshi nakamoto how his creation(bitcoin) got huge value and other things on Machine Leaning and AI say that go game etc
04:38:27 <winnner> they inspired me to learn programming and I also want to create something better things like that
04:40:20 <[exa]> winnner: any actual tangible target program that you'd like to see materialized?
04:41:47 <mbrock> there was a Stack Overflow blog post with statistics showing that Haskell is the #1 programming language that people use more on weekends than on weekdays...
04:42:15 <mbrock> which could mean (1) that the business use is lower than most; and (2) that it's fun and challenging regardless of what other languages you also might use
04:45:01 <geekosaur> I've noticed for a while that Haskell seems destined to push programming forward not so much directly, as by introducing new ideas and new ways of thinking
04:45:44 <geekosaur> which will, and in some cases already are, making their way into more popular languages.
04:45:56 <winnner> [exa]: Sorry I did not understand your last message
04:46:21 <[exa]> winnner: like a program that you want to create
04:46:59 <winnner> [exa]:  I want to create a chess website where tournments are organized onlined and payed with prizes where prizzes are my own crypto currency
04:47:33 <winnner> and to play those tournments they should join with my crypto currency and that coin can be bought with any coin
04:47:35 <[exa]> good news: haskell is great for that
04:47:47 <winnner> thats the idea but i dont think I can achive that at the monet
04:48:04 <[exa]> why not start with a simple website, then add chess and see what you can do?
04:48:04 <winnner> [exa]:  but I see all crypto currencies are in C++
04:48:31 <winnner> I should also hire javascript developers later right?
04:48:40 <capisce> winnner: there's a Haskell one too
04:48:40 <mbrock> (actually the #5 cryptocurrency by market cap is written in Haskell)
04:48:48 <winnner> for front end8
04:48:51 <winnner> for front end*
04:49:10 <[exa]> winnner: noep https://haskell-miso.org/
04:49:22 <winnner> mbrock:  cardano ?/
04:49:53 <winnner> [exa]:  https://haskell-miso.org/examples  with this we dont need js ?
04:50:16 <winnner> never heard we can build a front end without js
04:50:29 <[exa]> it takes (nice) haskell code and produces the (ugly) JS for you
04:50:31 <winnner> Thats making me exciting because I dont like js at all
04:51:00 <winnner> Ok now I stop Talking no c+= or something let me attack haskell right away
04:51:04 <[exa]> you might want to start with a simple website
04:51:49 <winnner> I have haskellbook and wanted to finish it to jump to any project
04:52:02 <winnner> or with my basic knowledge can I start right away
04:52:07 <winnner> and learn by doing
04:52:18 <[exa]> learning by doing is the only way of learning
04:52:23 <winnner> but my end goal if I fail in it I must be able to get job
04:52:35 <winnner> fail in my website idea like it dont succeed*
04:52:47 <mbrock> winnner: yep.  Also, Philip Wadler, one of the designers of Haskell, is working on a cryptocurrency smart contract language.  The cryptocurrency scene in general seems to have a very high view of functional programming, Haskell in particular, because of the emphasis on correctness and safety
04:53:16 <winnner> ok mbrock
04:53:32 <[exa]> winnner: you can't fail, even if the website idea fails you'll have a load of programming skill left
04:53:57 <winnner> [exa]:  sounds cool but with it I am not not going in structured way right ?
04:54:24 <[exa]> structured way?
04:54:50 <winnner> like mastering all the concepts first then jump to project so it helps to use concepts
04:55:34 <[exa]> if you are reading the haskell book they are probably taking care about that for you
04:55:40 <winnner> haskell miso have slack and no IRC ?
04:56:11 <winnner> [exa]:  but you only said to jump to project right away right?
04:56:18 <alp> dmj`, ^^^
04:56:25 <alp> (he's the author of miso)
04:56:32 <winnner> Ok I will do one thing I will finish haskellbook skipping exercises
04:56:38 <winnner> and will work on it
04:56:45 <mbrock> it's a bit like guitar, you want to play songs you like, but you also study some scales and stuff so you keep learning and improving -- so you can jump into a project and see how it goes, but also keep working through the book for structured learning
04:56:46 <[exa]> also, do not skip exercises.
04:56:47 <[exa]> :D
04:56:49 <winnner> who is the author?
04:57:14 <winnner> exercises take a lot of time :(
04:57:38 <winnner> alp:  dmj`  is the author ??
04:59:16 <winnner> mbrock:  ok
05:00:32 <alp> winnner, of miso, yes.
05:01:13 <winnner> alp:  ok SO I will find support in this channel I guess, i never used slack and dont want to use near by soon
05:02:51 <alp> winnner, looks like there's an IRC channel after all, #haskell-miso, according to https://haskell-miso.org/community
05:14:40 <dmj`> winnner: chess app sounds cool
05:15:25 <dmj`> Oh he quit 😃
05:47:15 <Matteo_> Hi, i cant seem to get hlint to work in atom could anyone help ?
06:00:28 <Matteo_> i get this errro but i dont know why
06:00:30 <Matteo_> <interactive>: interrupted <interactive>: warning: too many hs_exit()s
06:22:01 <nut> lpaste.net/361844
06:22:10 <atchoum> hello
06:22:42 <nut> could anyone explain why the import code is written this way?
06:22:59 <atchoum> Can you give me an example about the type Either ? I rencently came across a problem where I had to carry a payload through the code which could be either in encrypted state or in plaintext state. Does the Either type can apply in this context ?
06:24:20 <lyxia> nut: I would prefer to do without the last three lines but the idea is to have access to some unqualified identifiers while forcing qualification for the conflicting or more obscure ones
06:25:57 <lyxia> atchoum: http://lpaste.net/361845
06:30:30 <atchoum> lyxia: thanks. I suppose that is really a cool example for consistency
06:30:39 <atchoum> I mean a good use case for Either.
06:35:44 <nomeata> Hi. Is there a library that provides the functionality of djinn?
06:42:47 <geekosaur> hm. djinn itself is not a library, it appears. exference has a library, though
06:42:58 <geekosaur> https://github.com/lspitzner/exference
06:45:17 <nut> instance (a ~ Choose Tall (Choose (Mirror Tall) Full)) => Default (XConfig a) where
06:45:25 <nut> how to understand that tilt
06:45:27 <nut> ?
06:45:33 <nut> ~
06:45:45 <geekosaur> type equivalence
06:45:58 <nut> so a is a type of Choose Tall ...
06:45:59 <nut> ?
06:46:11 <hydraz> a must be Choose Tall ...
06:46:29 <nut> does this feature require any GHC extension?
06:46:41 <hydraz> TypeFamilies or GADTs, iirc
06:46:49 <nut> iirc?
06:46:59 <hydraz> if I recall correctly
06:47:08 <nut> thx
06:47:30 <nut> so basically it's type level computations
06:48:00 <hydraz> no, it's an equality constraint
06:48:11 <nut> ok
06:49:03 <geekosaur> I *think* that's just avoiding a different limitation. Default is kinda a poorly behaved class. (and I really wish xmonad had not adopted it)
06:49:46 <joel135> Is there a cool pointfree way of writing (\x -> f x ++ g x)?
06:50:01 <geekosaur> @pl \x -> f x ++ g x
06:50:02 <lambdabot> liftM2 (++) f g
06:50:08 <geekosaur> or liftA2 if you prefer
06:50:37 <joel135> hmm
06:51:02 <phadej> it's using (->) Applicative/Monad
06:51:12 <phadej> that's often confusing
06:51:22 <joel135> ok i see
06:51:29 <phadej> join f x = f x x
06:51:44 <phadej> > join (+) 2
06:51:50 <lambdabot>  4
06:52:05 <hydraz> nut: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#equality-constraints
06:59:24 <joel135> ok thank you!
07:17:43 <nut> in haskell literature, when we say unboxed we mean primitive types?
07:18:06 <nut> that cannot be defined in Haskell itself?
07:20:04 <nut> sorry i just found the chapter on unboxed types in the GHC doc
07:20:43 <Akii> Hi! I'm using a library that itself uses HTTP (openid). Since I need TLS I cannot use HTTP but it's hardcoded. Anyone know an existing mapping to another library?
07:24:31 <typetetris> Hi there. If I do `cabal freeze` for `parconc-examples`, there isn't an entry for `distributed-process` in cabal.config. That dependency can be turned off via  a flag, but the default is to use it, so I suspect `cabal freeze` assumes the flag is off. How can I change that behaviour?
07:53:43 <mpickering> anyone familiar with this error?
07:53:45 <mpickering> https://www.irccloud.com/pastebin/UFHMHPEu/
07:59:23 <electrocat> mpickering: give us some more information to go on, what are you trying to do, and how?
07:59:38 <mpickering> Just "cabal new-build"
08:02:39 <Matteo_> any one know why i get this bug on linux but not on windows
08:02:41 <Matteo_> freeglut  ERROR:  Function <glutReshapeWindow> called without first calling 'glutInit'.
08:04:35 <hpc> do you call glutInit?
08:05:38 <hpc> oh right, you're using gloss
08:05:38 <hpc> hmm
08:07:01 <phadej> mpickering: seems that the paste is truncated, or was it all?
08:07:21 <mpickering> There is more but that is the relevant part?
08:08:14 <phadej> i think the interesting part comes right after "setup: The following package dependencies were requested"
08:09:47 <mpickering> https://www.irccloud.com/pastebin/wCeSsvtq/
08:09:57 <mpickering> that's the full log
08:11:35 <phadej> mpickering: what's your 'ls ~/.cabal/store/ghc-$ver/' says, there should be that hash
08:15:41 <mpickering> https://www.irccloud.com/pastebin/TTxNnE6S/
08:15:50 <mpickering> that hash is there
08:16:20 <phadej> hmm, weird
08:16:41 <mpickering> I don't care too much as I was just trying to build a project locally as my internet was too crap to ssh to my server
08:16:46 <mpickering> but my internet seems to be better now
08:17:37 <phadej> mpickering: it might be that package is there, but store package-db doesn't have it
08:17:53 <mpickering> what can I delete to reset the slate?
08:18:16 <phadej> you can delete that single package folder and try again
08:18:56 <phadej> /maybe/ cabal checks that things via fs, but setup via package-db and they might be out-of-sync in rare situations
08:19:11 <mpickering> I think I did delete some folders
08:19:24 <mpickering> that seems to have done the tricks thanks :)
08:19:35 <phadej> cheers
08:30:33 <Matteo_> ERROR:  Internal error <Window Class Not Registered> in function fghInitialize
08:31:19 <loginoob> Why web development is trying to implement functional approach? Especially javascript
08:31:41 <asheshambasta> as I'm starting with a Haskell project, how important is an IDE for Haskell development?
08:32:36 <loginoob> asheshambasta emacs
08:32:58 <hydraz> "How important is [...]" "emacs"
08:33:11 <robstr> :D
08:33:12 <hydraz> that's sure to answer their question
08:33:49 <asheshambasta> :)
08:34:27 <loginoob> I m new too :P
08:36:54 <Squarism> how do i document the top level of a library/package with haddock? Not the modules them selves. Like what is visible on a page such as this https://hackage.haskell.org/package/Spock
08:37:36 <hpc> that's the description in the cabal file
08:37:46 <Squarism> oh ok
08:37:50 <Matteo_> HI, when i test my program by doing $ghci , then :l Test.hs its runs fine, but when i do runHaskell Test.hs it doesnt run fine what am i doing wrong ?
08:38:16 <lyxia> Matteo_: please explain what error you are seeing
08:38:37 <Matteo_> the error is Test.hs: zdGLUTzm2zi7zi0zi12zm6EAG9rnuF10HeWK97rVsdrzdGraphicsziUIziGLUTziRawziCallbackszdGLUTzzm2zzi7zzi0zzi12zzm6EAG9rnuF10HeWK97rVsdrzuGraphicszziUIzziGLUTzziRawzziCallbackszumakeDisplayFunc: interrupted
08:38:51 <Matteo_> or freeglut  ERROR:  Function <glutPostRedisplay> called without first calling 'glutInit'.
08:40:36 <lyxia> I don't know much about glut, sorry
08:40:45 <asheshambasta> loginoob: I'd really like to get started with working on the project, and unfortunately, getting with emacs would mean learning yet another tool
08:44:00 <cocreature> asheshambasta: just stick to whatever text editor you’re already using
08:44:23 <asheshambasta> I
08:44:28 <asheshambasta> I'm using an IDE :P
08:44:35 <Matteo_> why would something work with ghci and not with runhaskell fk my life
08:45:16 <cocreature> asheshambasta: which ide?
08:45:34 <cocreature> Matteo_: does it work if you compile it and then run the binary?
08:45:46 <cocreature> ghci and runhaskell sometimes behave strangely
08:45:59 <asheshambasta> IntelliJ IDEA with the Intellij-Haskell plugin
08:46:02 <Matteo_> i works fine whe i do ghci then :l Test.hs
08:46:08 <asheshambasta> its quite far from perfect
08:46:20 <Matteo_> but when I do runhaskell Test.hs it doesnt work
08:46:28 <Matteo_> and give some kind of glut error
08:47:05 <cocreature> asheshambasta: I highly doubt that using another editor will help enough to justify the learning curve so just keep using it.
08:47:22 <cocreature> Matteo_: you already said that but you haven’t answered by question :)
08:47:38 <Matteo_> cocreature: what do you mean with run the binary ?
08:48:03 <cocreature> ghc Test.hs -o output_file; ./output_file
08:48:24 <asheshambasta> yeah, was just wondering if there was something better suited for Haskell. Currently all plugins on Intellij for haskell pretty much suck quite hard
08:49:02 <jollygood2> hi
08:49:29 <jollygood2> is there a function that replaces a substring with another string?  replace "foobar" "foo" "bar" -> "barbar"
08:49:45 <erisco> look in Data.Text
08:50:04 <Matteo_> cocreature: yeah that works aswell
08:50:31 <cocreature> Matteo_: then I wouldn’t worry about it and just use that rather than "runhaskell"
08:50:32 <asheshambasta> if I add a dependency as one of the extra-deps in my stack.yaml am I supposed to find it when running stack ghci?
08:50:35 <erisco> this was asked just the other day though … not sure I still have the code around
08:51:02 <cocreature> asheshambasta: no you need to add it to the build-depends section in your cabal file and you might also need to run "stack build" before starting "stack ghci"
08:51:05 <jollygood2> erisco I see replace in Data.Text. seems a bit clunky to convert to Text and then back to String just for this though
08:51:35 <asheshambasta> cocreature: modding the cabal file makes stack throw warnings at me
08:51:51 <cocreature> asheshambasta: then you probably have a "package.yaml" and need to modify that instead
08:52:03 <erisco> well at any rate, there is a really inefficient solution if you first generate all the partitions of the target string
08:52:04 <asheshambasta> I just have a stack.yaml
08:52:10 <Matteo_> cocreature: i still get this erro when i try it on my main program: freeglut  ERROR:  Function <glutCreateWindow> called without first calling 'glutInit'.
08:52:19 <cocreature> asheshambasta: what’s the warning?
08:52:22 <erisco> er, not the target… not sure what you'd call it… the haystack string
08:53:23 <erisco> you can do it with parser combinators
08:53:38 <erisco> as long as they support the necessary backtracking
08:54:44 <erisco> % :t let word w = replicateM (length w) token in w
08:54:45 <yahb> erisco: ; <interactive>:1:45: error: Variable not in scope: w
08:54:47 <erisco> % :t let word w = replicateM (length w) token in word
08:54:47 <yahb> erisco: (Monad b, Foldable t) => t a1 -> Control.Monad.Trans.Free.FreeT ((->) a2) b [a2]
08:55:15 <asheshambasta> cocreature: actually, no, I was wrong, I was confusing these warnings with something else
08:55:25 <hydraz> % :t replicateM . length
08:55:25 <yahb> hydraz: (Applicative m, Foldable t) => t a1 -> m a2 -> m [a2]
08:55:29 <asheshambasta> adding it to the cabal file works
08:55:36 <hydraz> ah, missed the 'token'
08:55:48 <asheshambasta> thanks!
08:55:54 <hydraz> % :t flip replicateM token . length
08:55:54 <yahb> hydraz: (Monad b, Foldable t) => t a1 -> Control.Monad.Trans.Free.FreeT ((->) a2) b [a2]
08:56:44 <erisco> % :t let word w = replicateM (length w) token in (++) <$> many ("definitely" <$ word "not" <|> some token)
08:56:44 <yahb> erisco: MonadPlus b => Control.Monad.Trans.Free.FreeT ((->) Char) b ([[Char]] -> [[Char]])
08:57:16 <erisco> % :t let word w = replicateM (length w) token in mconcat <$> many ("definitely" <$ word "not" <|> some token)
08:57:16 <yahb> erisco: MonadPlus b => Control.Monad.Trans.Free.FreeT ((->) Char) b [Char]
08:57:49 <erisco> % let word w = replicateM (length w) token; p = mconcat <$> many ("definitely" <$ word "not" <|> some token) in parseString p "this is not cool"
08:57:49 <yahb> erisco: *** Exception: user error (mzero)
08:57:59 <erisco> % let word w = replicateM (length w) token; p = mconcat <$> many ("definitely" <$ word "not" <|> some token) in parseString @[] p "this is not cool"
08:58:05 <yahb> erisco: [("definitelydefinitelydefinitelydefinitelydefinitelyl",""),("definitelydefinitelydefinitelydefinitelydefinitely","l"),("definitelydefinitelydefinitelydefinitelycool",""),("definitelydefinitelydefinitelydefinitelycool",""),("definitelydefinitelydefinitelydefinitelycoo","l"),("definitelydefinitelydefinitelydefinitelycool",""),("definitelydefinitelydefinitelydefinitelycool",""),("definitelydefinitel
08:58:16 <erisco> well that's a boo-boo
09:00:04 <Matteo_> cocreature: I says that Iam not running glutInit but iam using gloss what does this mean ?
09:00:28 <erisco> % let word w = mfilter (==w) (replicateM (length w) token); p = mconcat <$> many ("definitely" <$ word "not" <|> some token) in parseString @[] p
09:00:29 <yahb> erisco: ; <interactive>:1:1: error:; * No instance for (Show ([Char] -> [([Char], [Char])])) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
09:00:44 <erisco> % let word w = mfilter (==w) (replicateM (length w) token); p = mconcat <$> many ("definitely" <$ word "not" <|> some token) in parseString @[] p "this is not cool"
09:00:50 <yahb> erisco: [("this is not cool",""),("this is not cool",""),("this is not coo","l"),("this is not cool",""),("this is not cool",""),("this is not coo","l"),("this is not co","ol"),("this is not cool",""),("this is not cool",""),("this is not coo","l"),("this is not cool",""),("this is not cool",""),("this is not coo","l"),("this is not co","ol"),("this is not c","ool"),("this is not cool",""),("this is not c
09:00:56 * erisco is unhappy
09:01:08 <erisco> well anyways, something approximately that
09:03:57 <cocreature> Matteo_: dunno, I’ve never used gloss
09:04:55 <erisco> I think the one we want is in there but there are so many other parses…
09:08:37 <parsnip> ugh, i hate algebra
09:08:52 <parsnip> "Using the above laws, prove that pure f <*> x = pure (flip ($)) <*> x <*> pure f"
09:09:06 <parsnip> i was never good at these
09:09:24 <erisco> jollygood2, it should be easier with attoparsec
09:12:23 <erisco> parsnip, interchange is probably involved
09:12:48 <parsnip> i've tried many paths, some even involving all the rules.
09:13:00 <parsnip> manye of them involving interchange
09:13:23 <cocreature> parsnip: step 1. write an automatic theorem prover step 2. let it find the proof for you :)
09:13:28 <erisco> let me try something…
09:13:47 <parsnip> i've always hated this algebraic stuff because it ends up being done in several steps, but the number of paths with several steps is large.
09:13:59 <MarcelineVQ> cocreature: there's an awful step 1.5 where you have to describe your problem to the prover :X
09:14:19 <erisco> seeing if we can do a wlog here
09:14:37 <cocreature> MarcelineVQ: describing it in some form is usually not too bad, describing it in such a form that the prover can actually find the proof is black magic :)
09:14:42 <MarcelineVQ> hoho
09:16:13 <parsnip> huh, one person on the internet used flip to flip the <*> positions.
09:17:02 <parsnip> so like pure (flip ($)) <*> x <*> y ==> pure ($) <*> y <*> x
09:17:26 * [exa] votes for flip <$>
09:18:11 <erisco> well if you can prove that you can use it too :)
09:19:55 <parsnip> hmm, another starts with interchange from the pure f on far right over the entire left associative chunk to the left... that's a nice idea.
09:25:43 <asheshambasta> cocreature: the state of affairs with the intellij-haskell plugin: https://github.com/rikvdkleij/intellij-haskell/issues/254 (I don't like complaining about open source software but using this plugin means being less productive, hence my earlier question about which programming environment to use for Haskell)
09:27:12 <cocreature> asheshambasta: oh don’t get me wrong, I’m not saying the situation is great. but ime all environments are rather fragile when it comes to Haskell so my recommendation is to start with a rather simple environment so basically whatever text editor you’re using + ghci
09:27:19 <MarcelineVQ> asheshambasta: anything you're comfortable with when you're first learning, you're going to be getting most of your feedback from ghci.
09:27:53 <erisco> > pure (++) <*> Const "hello" <*> Const "world"
09:27:56 <lambdabot>  Const "helloworld"
09:28:04 <erisco> > pure (flip (++)) <*> Const "world" <*> Const "hello"
09:28:08 <lambdabot>  Const "worldhello"
09:28:22 <erisco> so much for that person's intuition
09:28:36 <MarcelineVQ> > Const "hello" <*> Const "world"
09:28:40 <lambdabot>  Const "helloworld"
09:28:57 <erisco> if you do not show it with flip then it doesn't resemble what we were talking about :P
09:29:32 <MarcelineVQ> it's too early in the morning for gymnastics!
09:30:43 <parsnip> heh, my proof quotes pointfree.io for proof that ((.) ($ f)) (flip ($)) ==> f
09:31:44 <erisco> I was thinking we could choose an Applicative where this truth was more obvious
09:31:53 <erisco> but, nothing seemed that appealing
09:32:02 <parsnip> there's a suggestion on internet to use monoidal
09:32:55 <parsnip> but i've spent hours trying to smash these axioms together just right, so i'm going to move on to next section.
09:33:16 <MarcelineVQ> section?
09:33:22 <parsnip> trypeclassopedia
09:33:23 <cocreature> parsnip: which laws are you allowed to use?
09:33:27 <cocreature> ah
09:33:37 <parsnip> https://wiki.haskell.org/Typeclassopedia#Laws_2
09:33:48 <parsnip> >.< trype
09:40:17 <asheshambasta> cocreature: I get you, though. Just that the thing is that I'm most comfortable with Intellij and sadly it seems to be totally ill suited to haskell
09:40:58 <parsnip> asheshambasta: here's one approach:
09:41:04 <cocreature> asheshambasta: which os are you on?
09:41:36 <parsnip> at times, i rarely do much evaluating in my editor. i edit in the editor, and interact with ghci in a terminal.
09:41:57 <parsnip> asheshambasta: i don't think intellij will get too much in your way.
09:42:28 <asheshambasta> cocreature: Mac OS
09:42:52 <parsnip> if doing magic exhibit A makes intellij error, don't do magic exhibit A in intellij, just run ghci in terminal.
09:43:06 <cocreature> asheshambasta: does macOS have a builtin editor with syntax highlighting? if not try Gedit or whatever the equivalent thing on macOS is
09:43:18 <cocreature> an editor with syntax highlighting + ghci is really all you need to get started
09:43:37 <parsnip> isn't Sublime quite common?
09:43:45 <parsnip> or Atom
09:43:53 <cocreature> right those work just as well
09:44:00 <asheshambasta> parsnip, cocreature yeah sublime text is pretty common
09:44:07 <cocreature> or vscode or whatever people use these days
09:44:31 <parsnip> people seem to _love_ vscode
09:44:50 <parsnip> those that do use it, that is.
09:45:56 <parsnip> asheshambasta: but, for a quick fix, i still suggest just not using any console features in intellij, so having intellij open, and a terminal with ghci separate.
09:45:59 <drewbarbs> gotta say, emacs haskell-mode is a surprisingly painless experience so far
09:46:23 <parsnip> emacs takes some time to get used to, similarly for vim.
09:46:49 <asheshambasta> yeah I'm trying to stick with intellij
09:47:05 <erisco> parsnip, you can observe things like f and x need to swap over <*>, so some law that does that must be involved
09:47:22 <asheshambasta> lets see, I consider these things to be too many distractions – getting started consumed my sunday.
09:47:23 <erisco> parsnip, you can observe the count of <*>'s and reason the net change in <*>'s must match that
09:47:54 <erisco> parsnip, so identity and homomorphism removes a <*>, composition adds a <*>, and interchange remains constant
09:47:58 <parsnip> erisco: yeah, i spent too much time trying to manipulate things on the left, it didn't occur to me to focus on the right and throw it over in one fowl swoop.
09:48:01 <erisco> parsnip, same with count of pure's
09:48:20 <parsnip> whaaaaa
09:48:52 <parsnip> asheshambasta: a benefit of using ghci in terminal, more people here can assist with issues there.
09:48:54 <erisco> identity, homomorphism, composition remove a pure, interchange is constant
09:49:05 <erisco> though note that "remove" and "add" are dual in that it just depends on which way you run the rule
09:49:45 <erisco> but if you think like that then it can help narrow down what you need to look at
09:50:08 <erisco> how do you get f and x swapped around is a crux of the problem, for example
09:50:30 <erisco> and the *only* law that does swapping is interchange, so that is why I said you need that
09:50:33 <parsnip> yeah, i could not see the forest for the trees for that. to me, it's a brilliant focu.
09:50:35 <parsnip> *focus
09:50:59 <parsnip> tossing over left associative parens did not occur to me.
09:51:13 <parsnip> (then composition, etc...)
09:51:19 <erisco> I would not be surprised if you need to do a little refactor with functions
09:51:29 <erisco> for example, ($) is just specialised id, and (.) id = id, and so on
09:51:42 <parsnip> i cheated there, threw it into pointfree.io
09:51:48 <erisco> right, if you need to change associativity then the only law that does that is composition
09:51:50 <parsnip> need to get that setup locally at some point
09:53:20 <erisco> you shouldn't cheat on assignments
09:53:47 <parsnip> https://github.com/bradyt/typeclassopedia/blob/master/4-Applicative-2-Laws.lhs
09:53:59 <erisco> sometimes you just have to not know the answer. that's life :)
10:04:57 <erisco> parsnip, "tossing over left associative parens" you mean using interchange? :P
10:05:45 <parsnip> yes! you understand me! :)
10:06:04 <erisco> or do you mean you did not see that  a <*> b <*> c = (a <*> b) <*> c  ?
10:10:12 <parsnip> i understood that, it just did not occur to me to start there.
10:10:53 <parsnip> you see, proving algebraic identities often seems to me to involve arbitray paths through a large space.
10:11:17 <parsnip> i was never particularly good at it.
10:11:22 <erisco> it mostly is… that is why there are still mathematicians and not just computer solvers
10:12:08 <erisco> but the way you survive large search spaces is by developing heuristics that guide you towards more likely paths and away from the less likely
10:25:19 <siwica> Is it possible to retreive only the typeclass functions and minimal complete definition in ghci and hide the (sometimes rather verbose) list of instances that :info also displays?
10:25:51 <dmwit> I don't think so. Use the haddocks for that.
10:26:17 <dmwit> You can add a tool that will show you the haddocks from within ghci, but I'm not sure exactly what's in that output; it may be just as long or longer.
10:26:36 <dmwit> http://hackage.haskell.org/package/haskell-docs
10:28:46 <geekosaur> you can collapse the whole instances block in a haddock
10:29:05 <geekosaur> at least with recent versions of haddock; won't help much for docs generated with older versions
10:34:20 <[exa]> siwica: you can easily modify ghci to do that better (see ghc source in ghc/GHCi/UI.hs line ~1363)
10:35:08 <siwica> You think they would accept pull requests for that?
10:35:24 <siwica> I'll have a look at Haddock then!
10:35:57 <[exa]> siwica: why not, it's UI, it should work well. Maybe if you specialize it for typeclasses as :showdef or something
10:36:39 <[exa]> siwica: btw I guess there will be more people annoyed by the instance list, finding the typeclass definition is a relatively common operation
10:37:02 <siwica> Yeah, especially since tuples are around...
10:37:09 <siwica> Ok, I will have a look!
10:37:22 <erisco> whatever happened to the hackage bot?
10:37:47 <[exa]> seems kindof idle
10:40:12 <geekosaur> last reported 4 days ago
10:40:34 <erisco> it seems perpetually sick
10:40:41 <orion> hmm
10:41:01 <orion> Would it be technically possible to modify the RTS to allow for realtime debugging/pausing of applications?
10:42:01 <geekosaur> up to a point
10:43:09 <[exa]> haskell debugging doesn't work like with gdb? (trap&sigstop&analyze?)
10:43:56 <orion> I wouldn't want to set breakpoints on closures and such. It's too low level.
10:46:39 * [exa] avoids debugging
10:48:55 <[exa]> orion: what else is there to set breakpoints on?
10:51:22 <[exa]> btw, is there a function that would take 2 data.maps and 'zip' them on keys? say,  Map k a1 -> Map k a2 ->(k -> Maybe a1 -> Maybe a2 -> Maybe b) -> Map k b
10:52:33 <lyxia> [exa]: yes that's some variant of union or merge
10:53:29 <geekosaur> I have a feeling orion thinks there's always an interpreter underneath like in perl or python or ruby that they can do statement level breakpoints on
10:53:34 <geekosaur> (a) what statements?
10:54:00 <geekosaur> (b) if you are interpreting in ghci, maybe. in compiled code, no. you have machine code
10:55:19 <[exa]> btw haskell can't generate gdb-compatible debug symbols?
10:55:21 <geekosaur> (C debugging doesn;t go by statements either, except insofar as we're trained to put them on separate lines so line-based debug info almost works
10:55:31 <geekosaur> it does these days
10:55:41 <geekosaur> but debug symbols are not 100% of what you need
10:55:54 <[exa]> yah they would need to be tuned up to ingest STG stuff
10:56:28 <geekosaur> it is possible to do that, just as there are gdb shims to allow it to debug python or lua. but someone would have to write it, and keep it up to date with ghc
10:57:04 <[exa]> lyxia: oic merge has extra functions for missing values, not Maybe (that's why I missed that when looking). thanks!
10:57:33 <[exa]> geekosaur: which is imho unlikely, given the RTS size
10:57:47 <geekosaur> huh?
10:58:06 <geekosaur> that doesn;'t stop there being a python shim
10:58:22 <erisco> import GHC.TypeLits (type (*))  then I use * in a kind sig… GHC complains I should enable TypeOperators… what did I forget :s
10:58:24 <geekosaur> I do not mean somethingthat dumps the RTS state
10:58:59 <geekosaur> I mean something that relates the low level machine state to the higher level interpreter state. Or in this case, the STG state (e.g. pattern stack)
10:59:35 <JuanDaugherty> i think leksah and maybe one other do breakpoints
11:00:02 <JuanDaugherty> leksah for sure
11:00:31 <erisco> interestingly it was TypeInType causing the problem
11:00:50 <JuanDaugherty> the author is here so he can say
11:01:20 <[exa]> oh wow
11:01:46 <lyxia> erisco: use Data.Kind.Type instead of *
11:01:55 <[exa]> geekosaur: I wanted to say that the complexity of this exact relation in Python is tiny compared to what Haskell can do
11:02:03 <erisco> lyxia, ow verbosity
11:02:35 <[exa]> rename to Star?
11:02:42 <erisco> could not find module :(
11:02:58 <geekosaur> it's moved around in various ghc versions
11:03:05 <erisco> oh the module is Data.Kind
11:03:38 <runeks> Is it expected behavior that I can’t write a FromJSON instance of [a] if “a” doesn’t have a FromJSON instance, because Data.Aeson.Types has a FromJSON a => [a] instance? I would assume that the instance declaration in aeson on applies if a FromJSON instance of “a” can be found, am I mistaken?
11:04:28 <[exa]> runeks: that sounds a bit like overlapping instances
11:05:05 <runeks> It’s only overlapping if a FromJSON instance of “a” exists, isn’t it?
11:05:08 <geekosaur> runeks, the context does not play a part in instance selection. you cannot write another instance with the same head
11:05:29 <lyxia> erisco: With that GHC is trying to correct the mistake of naming Type as *
11:05:34 <[exa]> runeks: the type system must decide what instance to use (and also what context to verify) based just on the type.
11:05:53 <runeks> Alright, I see. Just wanted to understand how it works.
11:06:40 <[exa]> runeks: if you want different instances for "FromJSON inside" and "not FromJSON inside", there's some way to do that also
11:07:59 <runeks> [exa]: I’m not sure what you mean..
11:09:39 <[exa]> I remember it was possible to also write such an instance for all 'a' that do _not_ belong to FromJSON -- which would probably behave how you'd expect -- but it requires some advanced type magic and I'm not sure which.
11:10:38 <[exa]> type families probably.
11:12:18 <runeks> Ok, I see. I think I will either use a newtype, or perhaps OverlappingInstances. It’s just for a single, concrete type.
11:13:29 <runeks> But thank you :)
11:13:58 <[exa]> wrapping the list in something will probably be the easiest, yes. Probably also make it Foldable so that the code difference is minimal
11:14:34 * [exa] should finally read on type families
11:18:07 <sqooq> This Euterpea (audio synthesis library) paper I'm reading uses a phantom type setup to handle audio rates, which is very nice, but when I try to copy it, pretty much exactly, I get errors "could not deduce (Clock p0)"
11:18:14 <sqooq> I am making an lpaste to show
11:18:41 <sqooq> lpaste.net/361849
11:19:21 <sqooq> it's the use of "rate (undefined :: p)" which euterpea uses just fine with the exact same Clock typeclass definitions and type setup.
11:19:29 <sqooq> that causes errors for me
11:20:16 <runeks> sqooq: I think you need a “forall” in the type signature
11:20:53 <sqooq> forall p?
11:21:08 <runeks> Otherwise GHC thinks the p type of undefined is different from the one in the type signature
11:21:30 <runeks> Yes. forall p. Clock p => Double -> S p Double
11:22:15 <runeks> Perhaps you need to enable ScopedTypeVariables as well. I’m not 100% sure
11:23:13 <sqooq> it compiles with ScopedTypeVariables
11:23:15 <sqooq> neat
11:23:24 <sqooq> so that's what forall does?
11:24:06 <runeks> Only when combined with ScopedTypeVariables, I believe
11:25:20 <runeks> It sure why, though. Since we could just use a different letter if it isn’t the same type, as far as I can see.
11:26:21 <runeks> As far as I understand: forall without ScopedTypeVariables means the return type variable is the same as the argument type variable(s)
11:26:47 <runeks> Whereas with ScopedTypeVariables both the return type and any type variables in the definition become the same
11:28:30 <geekosaur> sqooq, yes, you need bot the explicit forall *and* the ScopedTypeVariables extension
11:28:47 <geekosaur> the default scope of a type variable is exactly the type in which it exists
11:28:51 <erisco> GHC.TypeNats.EqNat is not exported but I have to refer to it in a type… =\
11:28:56 <geekosaur> which means it does not extent from the signature to the body
11:29:04 <erisco> not sure why == turns into that… sounds like some janky GHC stuff
11:30:11 <sqooq> thanks runeks, geekosaur
11:30:42 <geekosaur> and there is code whcih relies on this, so you have to use the forall to specify *which* type variables get extended
11:31:20 <sqooq> how come this guy I'm talking to can use forall without ExistentialQuantification, whereas I can't
11:32:00 <sqooq> Nevermind he's using Data.Proxy isntead of undefined
11:32:11 <sqooq> and somehow that avoids the need for that language extension?
11:32:15 <sqooq> because it compiles for me too.
11:32:42 <geekosaur> that is possible if the proxy carries type information. "undefined" doesn't
11:32:54 <geekosaur> and since the purpose of proxies is generally to carry type information...
11:32:58 <sqooq> huh
11:33:09 <sqooq> I just thought the use of "forall" is what required the extention
11:33:23 <geekosaur> there are other extensions which enable it
11:33:47 <matteo_> is there away to have a delay function in haskell
11:34:29 <runeks> sqooq: ExistentialQuantification is for when you want to hide type variables —belonging to some type class — inside a type, so the information is there but it’s not visible from outside the type
11:35:13 <lyxia> matteo_: threadDelay
11:40:38 <sqooq> matteo_, delay function in what sense
11:40:59 <matteo_> like threadelay that works :)
12:09:14 <ongy> argh. I want cyclic includes
12:14:15 <EvanR> ongy: do you really
12:14:47 <hpc> cyclic includes are anti-modular
12:14:52 <hpc> if A imports B and B imports A
12:14:56 <hpc> you can't have either without the other
12:16:12 <hpc> (a similar logic applies to packages)
12:20:59 <erisco> hrm… I think I am looking for a partial dependency… so, if  n == 0  then  a ~ ()  for example
12:21:14 <erisco> if  (n == 0) ~ 'True   that is
12:21:49 <erisco> hm, can do that with ConstraintKinds…
12:23:12 <ongy> I could do it in other ways, but currently I don't want to split up every module into 20 modules just to please the imports
12:23:24 <hpc> what about one module?
12:24:03 <ongy> currently I have 5 hs-boot and 3 .Type files in this project and did already split some modules where it made sense :)
12:24:16 <hpc> i mean, put modules together
12:24:27 <hpc> you trivially don't need hs-boot files if you have only one module at all ;)
12:24:43 <isthatit> I don't understand when I defined "type Foo a = IO a" and try to use the type "ReaderT String Foo Int", I get "The type synonym ‘Foo’ should have 1 argument, but has been given none"
12:24:56 <hpc> sometimes your code doesn't separate out the way you want it to and you just have to go with it
12:24:59 <isthatit> But ReaderT expecte a type of kind * -> *
12:25:06 <glguy> isthatit: Whenever you use a type synonym you must provide all of its arguments
12:25:06 <hpc> isthatit: type Foo = IO
12:25:11 <ongy> mhh, in this case I could probably merge some of the stuff
12:25:20 <hpc> isthatit: type aliases can't be partially applied for halting problem reasons
12:25:46 <hpc> (specifically, it turns aliases into some measure of type-level functions)
12:26:08 <isthatit> thanks hpc and glguy
12:26:11 <isthatit> I get it now :)
12:27:05 <isthatit> hpc type Foo = IO solves my problem. However I don't understand the word "halting" in this context
12:27:09 <isthatit> is there something I could read about that?
12:27:23 <hpc> https://en.wikipedia.org/wiki/Halting_problem is a decent intro
12:28:17 <isthatit> hpc, am I understand right, this means that if you can partially apply type, this could lead to compilation that could not terminate?
12:28:28 <isthatit> not terminate -> end up in infinite loop?
12:28:32 <geekosaur> basically, there is no guarantee that typechecking won't get stuck in an infinite loop. so ghc is conservative and prohibits things that might work but can't be guaranteed
12:28:34 <hpc> yeah
12:28:44 <isthatit> makes sense :)
12:29:21 <[exa]> isthatit: even worse, infinite loop that might eventually terminate with a valid solution, but no one can know that answer before it terminates.
12:29:25 <hpc> it turns out there are a lot of things that reduce to the halting problem, which makes for convenient math sometimes when working out if something is possible
12:29:52 <[exa]> s/infinite/infinite-looking/
12:36:23 <EvanR> a finitist would say infinite-looking is all we actually have anyway!
12:43:36 <[exa]> EvanR: finitists are luckily uninterested in halting, they can't wait infinitely.
12:44:08 * [exa] wonders if existential comic has something on finitists.
12:45:24 <MarcelineVQ> probably not in general but it may have something about a finite prefix of finitists
12:46:44 <sqooq> I almost was convinced of ultra-finitism once
12:46:56 <sqooq> but realized it causes waaaay more problems than it thinks it solves
12:47:17 <sqooq> you would think it simplifies things but it just makes everything more complex.
12:48:29 <Tritlo> I am having the most weirdest of bugs. I have something that is a Functor, but when I don't fmap over it, the value inside gets corrupted!
12:49:27 <[exa]> Tritlo: can you be more specific?
12:49:35 <Tritlo> one of the parts should be a string that says "Dict" but it gets turned into 5 arbitrary letters like "\176\"\175J\254~"
12:49:55 <geekosaur> @paste
12:49:55 <lambdabot> Haskell pastebin: http://lpaste.net/
12:49:57 <[exa]> ok that looks a bit like memory corruption
12:50:15 <[exa]> pretty rare in haskell. :]
12:50:51 <mobofor> why does      lift2 (const id) (putStrLn "one") (putStrLn "two")  work at printing both strings, wouldn't the const id no-op the first?
12:51:41 <Tritlo> It's in this code where it happens. https://github.com/solrun/tools/blob/auto-observers/tip-lib/src/Tip/Haskell/Translate.hs#L823
12:51:57 <erisco> mobofor, because printing is the side effect. const id has nothing to do with that.
12:52:18 <Tritlo> If I do fmap id over the `(H.ConPat (constraints "Dict") [])`, it works, but otherwise the "Dict" string gets garbled
12:52:48 <int-e> mobofor: you have an elaborate way of writing putStrLn "one" >> putStrLn "two". The result of the first putStrLn is not used, but the effect is still visible.
12:53:07 <erisco> mobofor, you may as well say  liftA2 (\() () -> ()) (putStrLn "one") (putStrLn "two")
12:53:58 <erisco> :t \f -> liftA2 f (putStrLn "one") (putStrLn "two")
12:54:00 <lambdabot> (() -> () -> c) -> IO c
12:54:41 <erisco> :t \f -> liftA2 f getLine getLine -- is more interesting
12:54:44 <lambdabot> (String -> String -> c) -> IO c
12:55:30 <mobofor> i guess i just don't understand why the side effect executes
12:55:51 <erisco> putStrLn "one" has the effect to print "one" and returns ()
12:55:59 <amalloy> mobofor: that's what liftA2 does
12:56:05 <geekosaur> you have a function that discards a result. not discards an action
12:56:37 <erisco> imagine you wrote   var x = putStrLn("one"); var y = putStrLn("two"); return (f(x,y));  in another language
12:56:43 <geekosaur> discarding a result does not mean not running the action, just as a >> b does not skip running a even though its result is discarded
12:56:53 <erisco> that is what you are saying with  liftA2 f (putStrLn "one") (putStrLn "two")
12:57:08 <mobofor> but how is it different from foo _ x = x ; foo (print 1) (print 2)
12:57:33 <mobofor> or the reversed order, rather
12:57:37 <geekosaur> you are assuming the (print 1) is run before tis result is passed to foo
12:57:50 <erisco> mobofor, because it just isn't the same? =\
12:57:53 <geekosaur> it is not. you are capturing and discarding the *action*
12:57:56 <geekosaur> haskell is lazy
12:57:58 <erisco> why do you think that should be the same?
12:58:25 <mobofor> where is the action forced in the first?
12:58:32 <geekosaur> but in the case of the liftA2, or of (>>), it always does both actions. it only discards the result
12:58:44 <erisco> mobofor, you give it to main
12:59:11 <[exa]> Tritlo: that seems brutally dense
12:59:23 <erisco> mobofor, f depends on the result of both. That is why both are executed. Read my example again.
12:59:41 <Tritlo> [exa]: Yep. Not my code, I'm just the debugger :)
12:59:42 <[exa]> Tritlo: anyway, are the 5 letters "random" or same everytime?
13:00:02 <erisco> it is really a PITA that you cannot generate variables with ConstraintKinds
13:00:19 <erisco> F t = (a, b)   would be really helpful
13:00:55 <Tritlo> [exa]: They're random, i.e. they change everytime it is run
13:01:11 <erisco> sorry, derp, I mean   F t = t ~ (a, b)
13:01:19 <[exa]> Tritlo: is there any "external" function in process? Like one called by FFI or so?
13:01:35 <Tritlo> [exa]: not that I know of
13:02:09 <mobofor> it just seems like with const being defined as http://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#const it wouldn't reduce the second part
13:02:34 <geekosaur> it's not up to const, it's up to the definition of liftA2
13:02:40 <kamyar> How to get sum of IO [Int]?
13:02:44 <[exa]> Tritlo: just for the sake of triplechecking it, can you add a typed hole around the functor to see whether it is really the functor you're expecting?
13:02:48 <geekosaur> and liftA2 cannot know that your function discards a result
13:02:52 <kamyar> I want a IO Int
13:03:10 <geekosaur> so it must run both actions and pass them to your funciton, which then turns out to discard one of them
13:03:11 <kamyar> IO [Num] -> IO Num
13:03:26 <geekosaur> *pass their results
13:04:22 <mobofor> but where does lifta2 necessitate running both actions? doesn't it drive from outside in?
13:04:48 <geekosaur> you think it runs your function that discards something before it runs the actions?
13:04:58 <geekosaur> or somehow inspects it?
13:05:07 <geekosaur> it *does not know* that you gave it const id
13:05:27 <geekosaur> it *can not know* that you gave it const id. it just has something to run on two results, so it must get both results.
13:05:38 <kamyar> please answer my question
13:06:08 <mobofor> i just don't see where it runs on two results, rather than two things one of which doesn't need to be executed
13:06:10 <Tritlo> That just says that it has type `Pat (HsId a0) -> Pat (HsId a)`, where Pat is a functor that's been derived
13:06:24 <mobofor> in this case
13:06:29 <mobofor> i know it doesn't know about const id
13:06:33 <geekosaur> mobofor, you are passing it a function that takes two values
13:06:33 <mobofor> but const id knows about const id
13:06:38 <geekosaur> where do those values come form?
13:06:49 <geekosaur> what must liftA2 do to get those values?
13:06:51 <erisco> mobofor, how much do you know about Monad or Applicative?
13:07:05 <Tritlo> [exa]: That just says that it has type `Pat (HsId a0) -> Pat (HsId a)`, where Pat is a functor that's been derived
13:07:07 <erisco> i.e. is this a confusion about those or is it just about IO
13:07:08 <geekosaur> and unlike the other case, it can't just pass the actions directly because the function does not take *actions*
13:07:13 <geekosaur> it takes the *reuslts* of actions
13:07:31 <geekosaur> therefore liftA2 has to perform the actions to get their results
13:07:38 <[exa]> kamyar: what about  (>>= \a -> return (sum a) ) ?
13:07:53 <mobofor> why can't it just take two thunks and discard one, that's what i don't understand. where is the action run
13:08:09 <geekosaur> it does not take actions/thunks
13:08:16 <[exa]> Tritlo: so that's probably not the reason. Weird. I hope someone else here can comment on that
13:08:25 <erisco> mobofor, what you should do is experiment with State/StateT and you'll understand then
13:08:28 <mobofor> erisco: i'm implementing them right now
13:08:40 <[exa]> Tritlo: maybe check unsafePerformIOs around.
13:08:41 <erisco> you cannot implement IO
13:08:47 <geekosaur> it does not know what to do with an action to get a result. and an action is not a function
13:09:09 <mobofor> i understand that, i'm defining the classes and implementations for some of them
13:09:21 <erisco> State/StateT is much better because 1) it is pure 2) the implementation is simple
13:10:05 <erisco> liftA2 (const id) (modify (+1)) (modify (+1))  will show you
13:10:12 <EvanR> i will implement IO if i want
13:10:19 <mobofor> i'll experiment with state(t), but i already have and here i am so i don't know how much that'll help
13:10:20 <erisco> > runState (liftA2 (const id) (modify (+1)) (modify (+1))) 0
13:10:26 <lambdabot>  ((),2)
13:10:56 <erisco> if you know why that is ((),2) then you must know why both strings are printed with the IO example
13:20:28 <ertes> mobofor: you may want to read this:
13:20:31 <ertes> @where iotut
13:20:31 <lambdabot> https://www.vex.net/~trebla/haskell/IO.xhtml
13:21:10 <ertes> if the statement "IO is pure" sounds dubious to you, you should definitely read it
13:21:37 <erisco> what sort of thing would be needed so that   F n = a1 -> … -> an  for example… an exists quantifier?
13:21:46 <mobofor> i've read it, but thanks
13:22:14 <EvanR> if the universe is one big wave function, I/O is pure
13:22:29 <erisco> or lets say with ConstraintKinds so  F n t = t ~ (a1 -> … -> an)
13:22:43 <hpc> what are the a1, a2, ... types?
13:23:04 <erisco> F 0 t = exists a. (a ~ t); F n t = exists a. (a -> F (n - 1) t)
13:23:17 <erisco> whoops…
13:23:23 <mpickering> Is there a library for constructing csvs with a more sensible interface than cassava?
13:23:44 <erisco> yeah the recursion just doesn't work out… because the quantifiers are going to be buried in the type
13:23:50 <ertes> erisco: data F (n :: [*]) b where Func :: (a -> F [as] b) -> F (a ': as) b; Result :: b -> F '[] b
13:23:55 <ertes> erisco: something like that?
13:24:01 <erisco> no
13:24:14 <erisco> hpc, yes types
13:24:33 <hpc> i mean, what types are they
13:24:38 <erisco> any
13:24:52 <ertes> well, you can turn [*] into Nat, which makes the argument types existential
13:25:28 <ertes> erisco: data F n b where Func :: (a -> F ('S n) b) -> F n b; Result :: b -> F 'Z b
13:25:59 <ertes> you can probably even use a closed type family
13:26:39 <ertes> err, no, you can't
13:29:39 <Logic> Hello There, I was looking for some help with Haskell, did I come to the right place?
13:30:09 <lyxia> yes you did
13:30:17 <Logic> :)
13:30:22 <JuanDaugherty> there are special channels for new to haskell though
13:30:35 <Logic> Ok, what are they?
13:30:45 <EvanR> this one
13:31:08 <lyxia> Yeah, here is fine!
13:31:10 <erisco> the idea was that  (exists a. F a) => t ≡ forall a. F a => t
13:32:02 <Logic> Does anybody know the settings to change the font size?
13:32:12 <JuanDaugherty> Logic, search the channels for haskell, i believe there's more than one and as noted if you're comfortable here go ahead
13:32:12 <geekosaur> ...?
13:32:26 <geekosaur> font size is not a language attribute. what program are you using?
13:33:11 <erisco> then you could generate variables in this way
13:33:22 <ertes> Logic: you mean of this chat?
13:33:35 <Logic> No I was talking about this XChat, the words are really small, I was just wondering on how to zoom in to make it easier on my eyes.
13:34:11 <ertes> Logic: somewhere in the settings you can select the chat font, which includes its size, but i don't know where exactly
13:35:12 <geekosaur> settings > preferences > appearance tab > general > font
13:35:15 <JuanDaugherty> settins pref appearance in hxchat
13:35:26 <Logic> Ok thats much better thanks, ertes
13:35:31 <erisco> so say  F t = exists a b. (a, b) ~ t  then  x :: F t => t ≡ x :: (exists a b. (a, b) ~ t) => t ≡ x :: forall a b. ((a, b) ~ t) => t ≡ x :: forall a b. (a, b)
13:36:14 <Logic> ghci could not be spawned. Is it installed on your path.
13:36:18 <erisco> have to think about how recursion would work in the way I am imagining though
13:36:32 <Logic> If someone could help me with that error
13:36:37 <erisco> is what I am talking about making some sense? I keep running into this shortcoming
13:36:51 <ertes> Logic: which operating system, and how did you install GHC/haskell?
13:37:58 <Logic> ertes: I am using ubuntu and I installed everything with stack, for some reason I am having a hard time getting things to work on the Atom Text Editor.
13:38:14 <erisco> I guess you'd just let exists float out as a forall from a tycon
13:38:21 <hpc> Logic: try "stack ghci"
13:38:59 <erisco> [exists a. a] ≡ forall a. [a]  I dunno
13:39:00 <ertes> Logic: if you use stack, then it becomes your main tool…  anything haskell related you do through the stack command
13:39:22 <Logic> hpc: that works but the atom packages for haskell arent working correctly, maybe it has something to do with the paths.
13:39:56 <ertes> Logic: no, your editor needs special support for stack…  with stack you don't have a system-wide installation of GHC
13:40:16 <hpc> stack controls its own environment so you'll need to adjust how atom interacts with it
13:41:05 <Logic> ertes: That kind of defeats the purpose of using this Text Editor.
13:41:17 <MarcelineVQ> with the ide-haskell and language-haskell plugins atom is stack aware, the correct way to use stack is with a proejct though, you'll want to go  stack new myproject  or similar and then work on that to do your dev in atom
13:41:29 <EvanR> whats the purpose of using that text editor?
13:41:38 <ertes> Logic: well, stack is just one option…  the other main option is called cabal-installed, and it comes in the form of the 'cabal' command
13:41:50 <ertes> err
13:41:54 <MarcelineVQ> if your error exists despite doing this you'll need to be more specific about the problem
13:41:56 <ertes> it's called cabal-install
13:43:16 <erisco> a -> (exists r. r)  would not be the same as  forall r. a -> r  though
13:43:18 <Logic> Ok, I'll try that out, also I am having the problem with my packages being to new.
13:43:44 <erisco> it'd be like  newtype X = X (forall a. a);  a -> X
13:43:47 <ertes> Logic: you can try ubuntu's distribution packages for GHC and cabal-install, but make sure that you get at least GHC 8.0
13:44:13 <ertes> Logic: GHC 8.2 would be even better, and ideally you also get your hands on cabal-install 2.0
13:44:41 <Logic> Atom has the options for stack, I dont understand why it is not wanting to work correctly
13:46:20 <erisco> newtype X = X (exists a. a);  X :: (exists a. a) -> X ≡ X :: forall a. a -> X
13:46:30 <erisco> it is passing some sniff tests, so that's good
13:49:47 <Logic> ghci could not be spawned. Is it installed on your PATH    and    Failed to prettify.   If you guys could help me figure this out.
13:50:23 <Logic> spawn stylish-haskell enoent as well
13:50:29 <monochrom> I've never heard of "failed to prettify". What OS is this?
13:50:57 <Logic> ubuntu, and I am trying to run haskell in atom with stack
13:51:08 <monochrom> Oh Atom eh? I don't know Atom, sorry.
13:51:28 <Logic> :(
13:52:03 <MarcelineVQ> what haskell packages do you have installed for atom
13:54:54 <Logic> Well I have installed 8 and I am having trouble with 2, ide-haskell-repl and haskell-ghc-mod
13:54:57 <kerrhau> what do yuou guys use haskell for
13:55:01 <kerrhau> you*
13:55:21 <kerrhau> I've been wanting to learn haskell for a while, but never found any situation in which it would be practical to use haskell
13:56:30 <monochrom> I use Haskell for intermediate "scripting".
13:56:30 <Logic> kerrhau Read: Real World Haskell, there is a free pdf online, or you can read it for free on a its main website, good examples on the how haskell can be used in the real world.
13:56:56 <kerrhau> http://book.realworldhaskell.org/ this?
13:57:05 <monochrom> In fact I'm about to use Haskell to do SQL-like operations on CSV files. My upcoming project is to get join done.
13:57:05 <Logic> Yes
13:57:50 <monochrom> I also already have a Haskell program to run student programs with timeouts.
13:58:04 <Logic> kerrhau, I'd recommend  downloading the pdf though!
14:00:51 <erisco> I use Haskell to write ACME libraries
14:01:00 <ertes> kerrhau: pick anything you would have developed in another language and do it in haskell
14:01:05 <ertes> kerrhau: it's a general-purpose language
14:01:37 <kerrhau> ertes: alright
14:01:44 <jle`> asking what i use haskell for is basically the same as asking what i use progrmaming for
14:01:57 <jle`> kerrhau: do you have any situations where programming is useful for you?
14:02:01 <jle`> that is, the ability to program something is useful?
14:02:11 <nshepperd1> What *do* i use programming for
14:02:14 <jle`> if you do, then you have situations where haskell would be useful
14:02:33 <kerrhau> jle`: not specifically, I mainly just do PoCs and things of that nature
14:02:37 <jle`> (spoilers: it's those situations)
14:02:47 <jle`> kerrhau: ah, then you can use haskell for PoCs and things of that nature :)
14:02:51 <kerrhau> :)
14:03:00 <kerrhau> alright
14:03:03 <kerrhau> ill read real world haskell
14:03:45 <ertes> is RWH still good enough?  it's pre-AMP and pre-so many other things
14:04:03 <jle`> you probably have to have that list of errata/corrections open
14:04:14 <jle`> well, not errata, but things that have changed since then
14:04:50 <EvanR> addenda
14:04:51 <hpc> ertes: you could probably manage with RWH still
14:05:02 <hpc> although, in the same way you can still manage learning C with the K&R book
14:05:12 <hpc> starting with an up-to-date resource is a good idea
14:05:40 <kerrhau> hpc: anything you'd recommend?
14:06:26 <ertes> kerrhau: if you leave this chat open, RWH is probably fine
14:06:51 <hpc> @where learnhaskell
14:06:51 <lambdabot> https://github.com/bitemyapp/learnhaskell
14:07:05 <ertes> kerrhau: if you find any discrepancies, it's most likely due to a change in the base library
14:07:18 <ertes> the language itself hasn't changed much, but the base library sure has
14:09:25 <monochrom> I use programming to give students lower marks. :)
14:09:25 <kerrhau> \quit
14:09:30 <kerrhau> rip
14:09:37 <kerrhau> alright
14:10:12 <jle`> this is a nice list to have open https://stackoverflow.com/questions/23727768/which-parts-of-real-world-haskell-are-now-obsolete-or-considered-bad-practice
14:10:24 <jle`> sorry for long link -- https://stackoverflow.com/a/23733494/292731
14:11:56 <EvanR> removing return from Monad ?
14:13:07 <jle`> it's coming :o
14:14:48 <mmaruseacph2> good
14:16:46 <EvanR> there goes the explanation of monad's class thats been in use for n years
14:17:07 <erisco> you would of course say…  F 0 t = exists a. t ~ a; F n t = (exists a r. t ~ (a -> r), F (n - 1) r)
14:17:34 <EvanR> and the relationship of the name to category theory
14:17:57 <jle`> well, Monad in haskell would still have return
14:18:02 <jle`> just in a more practical way
14:18:07 <jle`> (as pure)
14:18:15 <EvanR> it wouldnt be in the class
14:18:33 <jle`> 'pure' would still be a part of the class
14:18:42 <jle`> as in you wouldn't be able to have a Monad instance without pure
14:18:43 <EvanR> maybe its good to take out the direct CT reference, but then change the name of Monad too
14:18:56 <jle`> defining Monad would still require defining pure
14:19:04 <jle`> 'return' was never the name from CT anyway
14:19:10 <EvanR> explaning monad will require explaining applicative
14:19:27 <jle`> indeed
14:19:46 <isthatit> Sometimes I don't undertand why some extensions are not enable by default... Like FlexibleContexts, what's the harm to enable that by default?
14:20:03 <jle`> isthatit: it's just not a part of Haskell-the-standard
14:20:10 <jle`> it's reasonable to add it in, but i thasn't been done yet
14:20:20 <EvanR> is ghc even standard by default?
14:20:27 <geekosaur> not any more
14:20:46 <EvanR> more like ghc is its own standard, more standard than standards
14:21:04 <geekosaur> first removing the Eq and Show prerequisites from Num, then adding Applicative as prerequisite for Monad, made full standard compliance essentially impossible
14:21:14 <Logic> Hello there guys, I have some questions regarding stack for haskell.
14:21:18 <jle`> fair
14:21:39 <EvanR> ghc = bog standard haskell
14:22:09 <Logic> How would I set my PATH ENV var for stack?
14:23:28 <monochrom> Sounds like you need a tech support channel for stack specifically.
14:23:49 <erisco> does Haskell have a type theory?
14:24:00 <erisco> the modern GHC Haskell
14:24:39 <jle`> ~/
14:24:40 <dibblego> return was removed from Monad years ago, in scalaz, and in Data.Functor.Bind
14:24:56 <dibblego> there is no reason to require it for do-notation
14:33:59 <jle`> huh pandoc is a ghc boot library now
14:35:21 <jle`> i wonder why
14:36:07 <jle`> oh i misread, not pandoc, but parsec
14:36:09 <jle`> still wonder why though
14:36:28 <geekosaur> cabal lib is using a real parser these days, I think?
14:36:32 <jle`> i thought ghc used happy/alex for parsing haskell source code
14:36:40 <jle`> oh, yeah, didn't think about cabal
14:36:43 <geekosaur> (package descriptions_
14:39:53 <atchoum> anybody is looking for haskell developers in Paris here ?
14:53:07 <byorgey> erisco: what do you mean by "does it have a type theory"?
14:54:33 <byorgey> erisco: there are several formalizations of GHC Haskell + various extensions floating around by Weirich, Eisenberg, et al
14:54:51 <erisco> byorgey, in papers? do you have a title for any of them?
15:00:05 <byorgey> erisco: "A Specification for Dependently-Typed Haskell" is the latest.  See also Richard's thesis.  Those have lots of stuff in them that is *not* part of GHC currently, but I know that along the way they formalized a lot of the current state of things.
15:00:37 <byorgey> erisco: you may also be interested in "System F with Type Equality Coercions" by Sulzmann et al
15:01:14 <byorgey> the machinery there is a bit more complicated than necessary, IIRC, but it's a good starting point for the metatheory of GHC's type system as it exists
15:03:10 <byorgey> erisco: then e.g. there's "Giving Haskell a Promotion" (by me et al.) which extends the system to include promoted kinds and some related stuff
15:03:33 <byorgey> that should keep you reading for a few months =P
15:04:16 <jle`> i'm going to start using me et al.
15:04:39 <geekosaur> mëtal?
15:05:47 <byorgey> hehe
15:17:22 <erisco> byorgey, thanks
15:31:03 <dxtr> Can I somehow spit out what data type ghc thinks a variable is?
15:31:30 <hpc> in ghci, use :t
15:31:36 <hpc> :t "a string"
15:31:39 <lambdabot> [Char]
15:31:42 <hydraz> % :t "a string"
15:31:42 <yahb> hydraz: [Char]
15:31:43 <hpc> when compiling, you can use type holes
15:31:44 <dxtr> Can I do that with variables inside a function?
15:31:45 <geekosaur> in ghci, yes. in a compiled program, types do not exist
15:31:57 <hydraz> % let a = 1 in _ a
15:32:00 <yahb> hydraz: ; <interactive>:3:14: error:; * Found hole: _ :: Integer -> t; Where: `t' is a rigid type variable bound by; the inferred type of it :: t; at <interactive>:3:1-16; * In the expression: _; In the expression: _ a; In the expression: let a = 1 in _ a; * Relevant bindings include; a :: forall p. Num p => p (bound at <interactive>:3:5); i
15:32:10 <dxtr> geekosaur: But I presume they exist during compile time?
15:32:29 <dxtr> let's save I have this: let foo = <something> where bar = <something>
15:32:34 <dxtr> I want to know what ghc thinks about bar
15:32:49 <hpc> dxtr: https://wiki.haskell.org/GHC/Typed_holes will get you started
15:32:56 <dxtr> intero isn't being too helpful
15:33:03 <dxtr> "Variable not in scope: bar"
15:33:11 <hpc> replace it with "let foo = <something> where bar = _"
15:33:20 <geekosaur> one cheat there is type-level holes, I think. where bar :: _; bar = ...
15:33:28 <hpc> and when you compile you will get a message saying hole found with type blah
15:33:34 <geekosaur> (may need PartialTypeSignatures ?)
15:33:49 <hpc> yeah, there's an extension of some sort
15:33:59 <hpc> i thought it was TypedHoles but i have never used it
15:34:07 <hpc> the concept is called "holes", in any event
15:34:24 <lyxia> PartialTypeSignatures is just to make it compile, you get the error/warning message either way
15:36:27 <geekosaur> yeh, that's why I said "may need", didn't recall if that was needed for the ability or just to have it not be an error
15:38:08 <lyxia> :)
15:48:54 <dmwit> dxtr: :type-at can tell you the type of an arbitrary expression in a loaded file.
15:49:25 <dmwit> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:type-at
15:49:45 <dmwit> Don't forget to :set +c before :load'ing your module.
15:50:07 <dxtr> oh cool
15:52:22 <dxtr> Although I discovered the error of my ways
15:52:35 <dxtr> Is a good idea to specify all the parameters of my function
15:58:27 <dxtr> okay so this works
15:58:28 <dxtr> neat
16:00:47 <thehappycolorpro> hellooooo
16:01:17 <thehappycolorpro> i'm about to buy the haskellbook, but was wondering if anybody knew of any promo codes to get a discount
16:01:32 <Axman6> Are you a student?
16:02:10 <thehappycolorpro> uh yes i am attending school
16:02:14 <thehappycolorpro> not a cs major tho
16:02:22 <Axman6> Chris has in the past been happy to offer disciounts if you email him
16:02:36 <Axman6> (this is not a guarantee)
16:03:27 <thehappycolorpro> ah man i'm shy
16:04:08 <thehappycolorpro> thank you :o
16:04:48 <dxtr> I should read that book
16:04:52 <dxtr> Bought it ages ago but haven't read it yet
16:06:38 <thehappycolorpro> i decided to just buy it. i did the sample, and i want to continue asap
16:42:37 <Axman6> thehappycolorpro: if you need help with the content, #haskell-beginners and this channel are good places to ask
16:43:34 <thehappycolorpro> Azman6: thank you :D
16:43:39 <thehappycolorpro> oh typo
16:55:30 <sqooq> hi
17:29:52 <n_blownapart> http://lpaste.net/361856  hi I'm working on an abstract machine for setting explicit order of evaluations. I was under the impression that the type keyword is used to apply aliases to types in the prelude. it seems we are defining an altogether new type here.
17:30:23 <n_blownapart> on line 7 of the paste
17:31:53 <n_blownapart> my query is I would expect to use newtype
17:32:14 <n_blownapart> but the textbook has it otherwise
17:32:27 <Wizek> nh2[m]: I ended up trying and succeeding with the hadrian method, thanks again!
17:32:52 <lyxia> n_blownapart: why does that look that way to you
17:33:09 <lyxia> n_blownapart: Cont is in fact a type alias
17:34:08 <lyxia> and there really isn't enough context to tell whether it would be a better idea to make it a newtype
17:36:13 <n_blownapart> lyxia ok thanks, I thought Op had to be in core haskell to make Cont an alias in that case, which is the only instance where we could use type
17:37:45 <lyxia> what do you mean by "core haskell"
17:39:09 <n_blownapart> the book is somewhat vague. It says ... :
17:40:35 <n_blownapart> The simplest way of declaring a new type is to introduce a new name for an existing type, using the haskell type mechanism." It goes on to give the example of String: type String = [Char]
17:41:55 <n_blownapart> so its using the data type Char from the prelude. Am I reading the text wrong
17:41:57 <n_blownapart> ?
17:44:57 <n_blownapart> it says: the type String is just a synonym for the type [Char] of lists of characters." It also gives the example of: ' type Nat = Int '
17:45:58 <n_blownapart> where Nat(ural) is an Int, but it is 'up to the programmer to supply positive integers'
17:46:31 <EvanR> String is a type synonym for [Char]
17:46:44 <EvanR> the type keyword defines a type synonym
17:47:00 <EvanR> but it doesnt create a new type (perhaps confusingly)
17:47:41 <n_blownapart> thanks, ok so the rhs doesn't need to be a prelude data type
17:47:56 <EvanR> no, and prelude data types arent special anyway
17:48:03 <EvanR> they are defined in the prelude with newtype or data
17:48:23 <n_blownapart> it was a subtle misread of mine, thanks all
17:49:26 <n_blownapart> I thought type was strictly for setting an alias to a defined haskell type
17:49:47 <EvanR> you can put any expression on the right that amounts to a type
17:50:08 <EvanR> for example type Foo a b = ([a], Maybe b, (a,b))
17:50:39 <n_blownapart> thanks, what's this business with all caps on line 8, EVAL, ADD
17:51:11 <EvanR> constructors have to start with a capital
17:51:30 <EvanR> other than that, looks like they went with all caps, cruise control for cool
17:52:37 <n_blownapart> oh good I thought I had to learn something new :)
17:57:27 <dukedave> Could someone explain to me how I might, "download the HEAD of cabal and try using new-build", with Stack?  It was suggested to me here: https://www.reddit.com/r/haskell/comments/7rtg6n/how_to_compile_with_stdc11/dszjd2b/
17:59:54 <nh2[m]> dukedave: what exactly do you understand is suggested there? The way I read that it doesn't seem to suggest to build cabal (the cabal-install package, version 2.2) with stack
18:01:31 <nh2[m]> dukedave: in my project I use 2 entries in the .cabal file: `cc-options: -std=c++14`, AND `ghc-options: -optc-std=c++14`
18:02:01 <thehappycolorpr_> hello, can someone explain to me why ([lambda]xy.xy) 1 2 is two separate 1 and 2?
18:02:35 <thehappycolorpr_> instead of 1 times 2
18:03:49 <lyxia> In the context of lambda calculus xy is most likely x applied to y
18:03:49 <nh2[m]> thehappycolorpr_: are you talking about Haskell or theoretical lambda calculus
18:04:06 <thehappycolorpr_> theoretical lambda calculus, sorry
18:04:11 <lyxia> so if you substitute x and y by 1 and 2, you get 1 applied to 2
18:04:14 <thehappycolorpr_> im on the first chapter of the haskellbook
18:04:23 <dukedave> nh2[m]: I figure I need to get my library to `stack build`, but using cabal built from git@github.com:haskell/cabal.git, instead of the one baked in to the lts resolver I'm using?
18:04:31 <thehappycolorpr_> what does it mean to apply something?
18:04:49 <EvanR> since 1 isn't a function, not sure what 1(2) would be
18:04:57 <thehappycolorpr_> oh, to apply an argument into a function i seee
18:04:57 <dukedave> nh2[m]: oh, I haven't seen `-optc-std=c++14` before, let me try that
18:05:29 <thehappycolorpr_> so the syntax in lambda calculus, when two stuff are next to each other it means to apply it
18:05:34 <lyxia> thehappycolorpr_: yes
18:05:46 <nh2[m]> dukedave: I doubt you will have a good time making stack depend on cabal 2.2 when that's not supported in upstream stack yet, probably a lot of work. I'd first try the -optc thing, it does work in my project (also depending on haskell-opencv)
18:05:53 <thehappycolorpr_> and i woul dhave to say x times y if i wanted x times y
18:06:00 <thehappycolorpr_> ok thank you all very much
18:06:15 <lyxia> thehappycolorpr_: xy means what you probably already know as "x(y)", or if we rename things a bit, fx is f(x)
18:06:57 <lyxia> a space often looks nicer "λxy. x y"
18:08:58 <thehappycolorpr_> hm. does that mean each variable can only be one character? how would you distinguish otherwise?
18:09:14 <thehappycolorpr_> like, what if i wanted one variable to be named "pumpkin"
18:09:23 <stepcut> I have a data set which consists of 60,000 grayscale images that are 28x28 pixels, and the grayscale value is a Word8. So, around 48M bytes of data. If I try to load them into `Vector (Vector (Vector Word8))`, it sucks up over 6GB of RAM. I am trying to figure out a better datastructure choice. Thougts?
18:09:24 <thehappycolorpr_> not sure if variable is the right word to use
18:09:37 <EvanR> no youre right
18:09:45 <EvanR> multiletter variables are rare in math
18:09:52 <EvanR> so they don't need spaces
18:10:15 <EvanR> in ascii haskell, its still easier to read with a space, nonetheless
18:10:48 <thehappycolorpr_> i see i see thanks
18:11:37 <stepcut> One thing the `Vector (Vector (Vector Word8))` data structure misses out on is that all the `Vector (Vector Word8)` arrays are the same shape (28x28). I am thinking maybe something like accelerate might be better?
18:11:52 <lyxia> stepcut: one image - one vector
18:12:31 <lyxia> or all of them into a single vector, and array libraries like accelerate do that kind of thing indeed
18:12:44 <nh2[m]> stepcut: `Vector (Data.Vector.Unboxed.Vector Word8)` might be your choice, where the inner one is the 28x28 flattened out, with custom indexing functions to get the 2-dimensionality
18:12:45 <stepcut> lyxia: I have considered that as well, one unboxed vector per image -- for my use case that is ok since I probably need to flatten the image anyway
18:14:08 <nh2[m]> stepcut: you can also use `array` (https://hackage.haskell.org/package/array-0.5.2.0/docs/Data-Array-Unboxed.html); it's a bit older and doesn't have fusion, but supports multi-dimensionality conveniently and depending on what you do, you might not give a damn about fusion
18:14:40 <stepcut> nh2[m]: I seem to care a lot about compact memory usage
18:15:05 <nh2[m]> stepcut: right, both of the suggestions above will already help a lot with this
18:15:33 <nh2[m]> because as soon as you unbox the 28x28, you'll get rid of most of the storage overhead, the rest will be negligible
18:15:40 <stepcut> yes, I should try the Vector (U.Vector Word8) approach because that format is actually closer to the final form I want the data in anyway
18:16:06 <dukedave> nh2[m]: omg `ghc-options: - -optc-std=c++11` worked!!1! You wouldn't believe how long I've been trying to get passed this build failure!  :D :D :D
18:16:21 <stepcut> nh2[m]: I hope so.. I tried (Vector (Vector (Unboxed.Vector Word8))) and saw little improvement, but I am hopeful that more flattening will help. bbiab.
18:16:34 <dukedave> (here's the issue I was tracking it on: https://github.com/LumiGuide/haskell-opencv/issues/104 )
18:16:45 <nh2[m]> dukedave: sorry, my bad. Had I cared to read your reddit thread a bit earlier, I would have saved you some time :(
18:17:54 <dukedave> nh2[m]: Haha, no worries, you already made my night; now to start  hacking on `haskell-opencv` !
18:18:05 <nh2[m]> stepcut: already the unboxing at the lowest level should have reduced the memory needed a ton. If it didn't, are you sure you aren't leaking the memory somewhere else?
18:18:26 <stepcut> nh2[m]: I am not sure
18:19:06 <nh2[m]> stepcut: so in raw memory, 28*28*60000 / 1000000 should be = 47 MB, right?
18:19:07 <stepcut> nh2[m]: I am sure that parsing this data is what is sucking up all the memory, but I am not sure where exactly that memory is going
18:19:16 <stepcut> nh2[m]: yes, and the input file is indeed that size
18:19:25 <nh2[m]> even if you have this *16 bytes overhead through a double-box, that should only be 752 MB
18:19:59 <nh2[m]> if you have 10x as much, then likely it's not the boxing that's creating your memory usage
18:20:07 <stepcut> yup. it seemed excessive to me
18:20:27 <stepcut> nh2[m]: https://github.com/stepcut/bad-idea/blob/master/Data/MNIST.hs
18:21:23 <stepcut> nh2[m]: I am calling, pMNISTUnsignedByteV3, on a 47MB input file, and that is what chews up all the RAM
18:22:41 <nh2[m]> stepcut: which is the iteration over the 60k?
18:23:40 <stepcut> nh2[m]: the main is here https://github.com/stepcut/bad-idea/blob/master/Main.hs#L60, and it is the `parseOnly pMNISTUnsignedByteV3 digitsFP` that seems to cause the trouble
18:24:04 <stepcut> nh2[m]: the training data come from here, http://yann.lecun.com/exdb/mnist/
18:24:56 <isthatit> Is there a  simple way to flip the nesting of monad transformer, for example converting a (ResourceT ReaderT ...) into a (ReaderT ResourceT)
18:25:11 <isthatit> or is that bad design?
18:29:09 <nh2[m]> isthatit: in general there is no simple way to do that. For example, exiting ResourceT will free its resources. You can't typically do that in the middle of something. From my experience it is extremely rare to need something like this (flipping monad transformers)
18:32:48 <nh2[m]> stepcut: hmm. First suspicion is that the `replicateM`s hold to your intermediate structures. Try forcing the `fmap`s to unboxed vectors, instead of only its arguments to WHNF, possibly also with a deepseq
18:33:11 <stepcut> nh2[m]: yeah, I wondered that as well
18:34:00 <nh2[m]> stepcut: you can also do a bit of profiling, that should reveal quickly which data types are in your ram
18:34:01 <stepcut> nh2[m]: You'd think in 18+ years of commercial Haskell programming I would have run into space leaks more often -- but fortunately, I have been spared which leaves me a big ignorant in tracking them down
18:34:37 <isthatit_> nh2[m], what about renesting? If I have "ResourceT m" and want to transform it into a "ResourceT (ReaderT m)"
18:34:39 <isthatit_> is that even possible?
18:35:01 <eschnett> is it possible to have a vector type that uses Data.Vector.Unboxed when possible, and Data.Vector otherwise? i imagine it would choose the representation automatically, depending on whether the element type is an instance of Unbox. is this possible?
18:36:42 <eschnett> i've tried implementing it via a type family, but i am not able to make this hybrid type an instance of e.g. Foldable.
18:37:17 <sqooq> in a video a guy does realtime do notation thing
18:37:36 <sqooq> in an interactive environment, perhaps not ghci, idk?
18:37:41 <sqooq> https://www.youtube.com/watch?v=xo3zUvPsizo
18:37:44 <nh2[m]> eschnett: this might do that: https://hackage.haskell.org/package/hybrid-vectors-0.2.2/docs/Data-Vector-Hybrid.html
18:37:47 <sqooq> anyone know what that is or how to do that?
18:39:03 <sqooq> ok it's definitely ghci. He has a "." instead of "Module>" and can just keep typing commands
18:39:14 <sqooq> even using do notation like "s <- synth fullSynthDef []"
18:39:19 <sqooq> how is he doing this?
18:39:34 <nh2[m]> isthatit_: you can always `runReaderT` locally, adding monad transformers at the bottom is "cheap"
18:40:15 <nh2[m]> sqooq: yes, you can run IO actions directly in ghci
18:40:27 <nh2[m]> sqooq: you can change the prompt with `:set prompt "> "
18:40:30 <nh2[m]> `
18:40:35 <geekosaur> I'm not seeing this yet
18:40:43 <geekosaur> but it may not be ghci as such. could be iHaskell
18:40:51 <geekosaur> so far all I have seen is an emacs window
18:41:07 <sqooq> nh2[m], he does stuff like "s <- ..." line by line though
18:41:11 <geekosaur> got an offset?
18:41:48 <nh2[m]> sqooq: yes, you can do that in ghci
18:42:07 <nh2[m]> sqooq: for example, run `line <- getLine` in plain ghci
18:42:49 <sqooq> nh2[m], weird, I swear I was doing it and it wasn't working earlier
18:51:30 <eschnett> nh2[m]: at first sight this does something different. i'll have a look at the details -- thanks!
19:00:02 <stepcut> nh2[m]: using lots of 'force' did not but. Then I switched from strict ByteString to lazy ByteString and it halved my memory usage. Still excessive though.
19:01:34 <nh2[m]> stepcut: that makes no sense to me, the bytestring for the input certainly should be only those 47 MB or what. Strict BS is the right type for this. Do you have the forced version pushed?
19:02:52 <stepcut> nh2[m]: using strict did seem like the right choice at the time, so I am a little surprised that using lazy helped.  I pushed the changes.
19:14:08 <jez_> Is anyone here with pretty printing libraries in Haskell? I'm trying to get text to look like this:
19:14:12 <jez_> 1 a
19:14:13 <jez_> 2 b
19:14:15 <jez_> 3 c
19:14:28 <jez_> but everything I try makes it come out like this:
19:14:30 <jez_> 1
19:14:32 <jez_> 2
19:14:33 <jez_> 3 a
19:14:35 <jez_>   b
19:14:37 <jez_>   c
19:14:46 <stepcut> nh2[m]: So I pushed a patch which switches to the flattened (Vector (U.Vector Word8)), and it doesn't seem to help much :-/ I guess I should start using the profiler instead of guessing
19:15:42 <jez_> (here familiar* with whoops forgot a word)
19:17:31 <lyxia> jez_: I haven't seen such horizontal composition in existing libraries. The best solution is probably to zip the list of numbers and the list of letters before rendering them
19:18:23 <jez_> lyxia: ah ok. Dang when I started looking into pretty printing libraries I thought that was the killer feature they were all supposed to have :/
19:23:58 <Axman6> jez_: I'm not even sure how you're possibly getting that layout
19:24:34 <lyxia> Axman6: put two columns next to each other
19:24:47 <Axman6> no pretty printing libraries I know of let you go backwards and add new text to the end of a line - you need to be telling it to write a followed by
19:25:12 <geekosaur> in theory you are building Doc-s and combining / manipulating them
19:25:12 <Axman6> the way you'd do that is by zipping the two pieces of text
19:25:24 <geekosaur> seems like pasting two Doc-s side by side should be a thing
19:25:33 <geekosaur> to make a new Doc
19:25:58 <Axman6> yeah, but I don't think I've ever seen it
19:27:38 <jez_> the little project i'm working on involves printing calendars, like you'd get with the Unix 'cal' program. What I'm really trying to do is show two months next to each other
19:27:49 <jez_> it would look something like if you ran this at the command line:
19:27:56 <jez_> pr -m -t <(cal jan 2018) <(cal feb 2018)
19:28:34 <jez_> so logically the lines wrap at the end of the week in the month
19:29:05 <jez_> the way I've written my code I'll have to do a bit of work to do the zipping suggested, so I was hoping that it was already built out in a library
19:29:22 <stepcut> nh2[m]: if I change the 'anyWord8' to 'pure 0', then it dramatically drops my memory usage. Not sure what to make of that :)
19:29:34 <jez_> (also seems like it should be possible, because I can do it at the command line with just 'pr -m -t' haha
19:29:37 <jez_> )
19:30:05 <stepcut> nh2[m]: the final data structure holds just as much data, but when it has to actually look at the input string, it requires a lot more space :-/
19:31:40 <nh2[m]> stepcut: another thing you can do for debugging's sake: Ditch attoparsec, write a manual loop indexing into the ByteString, reading out the Word8s
19:39:40 <Axman6> @quote stereo
19:39:40 <lambdabot> shachaf says: I remember when I joined #haskell and everyone would @quote stereo.
19:39:50 <Axman6> @quote stereo
19:39:50 <lambdabot> xplat says: Welcome to #haskell-blah, where your bot commands are executed in triumphant stereo!
19:40:13 <Axman6> I didn't want the meta stereo quotes, I wanted the original stereo quotes!
19:42:34 <stepcut> nh2[m]: yeah, I think attoparsec and ByteString are interacting poorly. If I leave the parser only but call it via,      r <- parseWith (hGetSome h 1) pMNISTUnsignedByteV3 mempty, then I get better memory usage. If I change the hGetSome to read more bytes at a time then memory usage goes back up
19:48:34 <nh2[m]> stepcut: would be great if you could investigate it a bit and then file an issue or write a post or something!
19:48:50 <Axman6> stepcut: do you have a link to the code?
19:49:07 <nh2[m]> as this stuff is supposed to work with attoparsec I think
19:49:33 <jez_> Ah, after working through it, the "zip the lines together" strategy required fewer changes than I originally thought I'd need. Thanks for the tips Axman6, lyxia, and geekosaur!
19:49:41 <parsnip> better name than rotate?
19:49:43 <parsnip> rotate (x:y:ys, z:w:ws) = [x, y, z, w] : rotate (ys, ws)
19:50:18 <parsnip> ah, zipByTwos?
19:50:32 <parsnip> no, unZipByTwos?
19:50:34 <Axman6> seems a little more appropriate than rotate
19:50:43 <Axman6> it's definitely a zip
19:50:55 <Axman6> the tuple is unnecessary though
19:51:05 <parsnip> yeah, i think i called it rotate because it started out as one line with an \n
19:52:00 <stepcut> Axman6: main is here, https://github.com/stepcut/bad-idea/blob/master/Main.hs#L62 parser is here, https://github.com/stepcut/bad-idea/blob/master/Data/MNIST.hs and data comes from here, http://yann.lecun.com/exdb/mnist/
19:52:29 <xplat> ah, the old days, when the stereo quote was old but not old enough to be nostalgic
19:52:46 <xplat> @quote questions.*stereo
19:52:46 <lambdabot> No quotes match. My pet ferret can type better than you!
19:53:24 <Axman6> @quote glorious.*stereo
19:53:24 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
19:53:29 <Axman6> u wot m8
19:53:36 <xplat> @quote monochrom stereo
19:53:36 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
19:53:45 <xplat> not quite ...
19:54:04 <MarcelineVQ> keep at it
19:54:10 <MarcelineVQ> I ​believe in you
19:54:43 * stepcut goes to sleep
19:56:35 <xplat> @quote Cale stereo
19:56:35 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
19:56:57 <Axman6> I feel that a big piece of the lore of #haskell might have died :(
19:57:04 <xplat> @quote Anonycale stereo
19:57:04 <lambdabot> No quotes for this person. I am sorry.
19:57:27 <Axman6> @quote majestic.*stereo
19:57:27 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
19:57:30 <Axman6> @quote majestic.*stereo
19:57:31 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
19:57:33 <Axman6> :(
19:57:57 <monochrom> No, you need this:
19:58:02 <monochrom> @quote monochrom fugue
19:58:02 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
19:58:12 <xplat> elsechan: 22:56 < ?????> xplat: Cale removed his quote, was tired of being pinged by it
19:59:01 <xplat> ironically, now being pinged by it anyways ._.
20:01:02 <parsnip> > concat $ transpose $ take 2 $ transpose $ lines "abefij\ncdghkl"
20:01:07 <lambdabot>  "abcd"
20:01:16 <parsnip> that's actually what i want.
20:01:37 <Axman6> @tell stepcut I would be looking at functions like take :: Int -> Parser ByteString to get the bytestring which should contain the right data, and then using something more efficient to directly go between the bytestring and the Vector Word8 you're storing. The easiest way to do that would be to use something like runVecotr (or whatever it's called) to build the Vector in ST. Having an intermediate [Word8] is a really bad idea if you know you
20:01:37 <lambdabot> Consider it noted.
20:01:37 <Axman6> 're just getting n bytes from an underlying bytestring
20:01:47 <Axman6> thanks lambdabro
20:10:25 <woodson_> Question in a functor definition
20:10:34 <woodson_> :t (<$)
20:10:37 <lambdabot> Functor f => a -> f b -> f a
20:10:53 <woodson_> Can the f be considered as a monad?
20:11:09 <Axman6> f might be a monad
20:11:18 <Axman6> but it is definitely a Functor
20:11:32 <Axman6> all Monads are Functors, but not the other way around
20:11:57 <Axman6> so, if f has an instance for Monad f, then you can also use that function
20:12:23 <woodson_> I am just confused about a code that I was working with that required me to call pure to meet the monad restriction. I figured it out because I am reading the types but dont understand why
20:12:47 <Axman6> (All Monads are Aplicatives, and all Applicatives are Functors, so all Monads are Functors)
20:13:19 <woodson_> Axman6: So for instance
20:13:22 <woodson_> myButton :: MonadWidget t m => m (Event t [T.Text])
20:13:25 <woodson_> myButton = button "hello" >>= (\x -> [""] <$ x)
20:13:32 <woodson_> this would not work unless
20:13:38 <woodson_> myButton = button "hello" >>= (\x -> pure $ [""] <$ x)
20:14:06 <Axman6> right
20:14:09 <woodson_> button :: DomBuilder t m => T.Text -> m (Event t ())
20:14:40 <woodson_> :t (>>=)
20:14:43 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:14:57 <Axman6> bhat can also be made simpler by using: fmap ([""] <$) $ button "hello" since using m >>= \x -> pure (... x ...) is the same as just fmapping without the pure
20:14:57 <woodson_> :t (<$)
20:15:00 <lambdabot> Functor f => a -> f b -> f a
20:15:30 <glguy> If you're going to wedge a $ in there anyway, might as well use <$>
20:15:53 <Axman6> yeah
20:16:13 <Axman6> ([""] <$) <$> button "hello"
20:16:25 <woodson_> yea, I mean i am getting a little bit comfortable a reading the types for now. But I feel like that there are so many functions doing the same thing that I am losing sight about what I should be understanding
20:16:32 <woodson_> instead of just focusing on the types
20:17:21 <Axman6> yeah that solution is becomming a bit line noisy and will take time to get used to
20:17:24 <woodson_> so fmap would have avoided me from using pure?
20:18:07 <Axman6> something you should make yourself familliar with is some of the patterns which are equivalent to other patterns. m >>= \x -> pure (...x...) is just fmap (\
20:18:23 <Axman6> fmap (\x -> ...x... m, for example
20:18:29 <Axman6> uh, ...)*
20:18:36 <Axman6> yep
20:18:55 <woodson_> Axman6: typing fast lol, no worries still following you
20:19:59 <woodson_> Axman6: There is another issue that I am starting to encounter
20:20:31 <Axman6> it's worth going through the exercise of proving a) that all Applicatives are Functors, using only the functions Applicative gives you (pure and <*>), and proving that all Monads are Functors, using only >>= and return, and that all Monads are Applicatives, by defining pure and <*> using only >>= and return)
20:20:57 <Axman6> (there should be a b) and c) in there, sorry -_-)
20:21:29 <woodson_> Sometimes the compiler will tell that "It could not deduce t with t2.. blabla"
20:21:45 <woodson_> where does that t2 suddenly come from?
20:21:55 <woodson_> also where can I find these exercise?
20:21:59 <Axman6> the compiler has to make up intermediate types during type checking
20:22:10 <woodson_> I know that we are jumping everywhere, but Im still following you.
20:22:11 <woodson_> lol
20:25:06 <ggVGc> I think asked this same question not so long ago but forgot the answer :( is there a standard function for oulling out the first element of a list? Like partition but with only one match
20:25:38 <Axman6> head?
20:26:41 <ggVGc> no, something like (a -> Bool) -> [a] -(Maybe a, []ODa)
20:26:45 <ggVGc> uhm
20:27:08 <ggVGc> (a -> Bool) -> [a] -(Maybe a, [a])
20:27:54 <parsnip> better name?
20:27:55 <parsnip> transposeAndConcatByTwos (x:y:ys) = (concat . transpose) [x, y] : transposeAndConcatByTwos ys
20:28:48 <parsnip> ggVGc: `find` from Data.List?
20:29:45 <Axman6> ggVGc: I don;t believe that's something that currently exists as  standard function anywhere (though there's probably an equivalent in lens)
20:29:47 <ggVGc> parsnip: that only gives me the element. I also want the rest of the elements returned
20:29:51 <ggVGc> I mean, I can write it up myself
20:29:56 <ggVGc> just wondered if there's altready something that I'm missing
20:30:11 <ggVGc> alright, thanks
20:30:17 <parsnip> splitAt 0?
20:30:50 <parsnip> any way, i would dig around in Data.List or hoogle.
20:33:04 <glguy> :t Data.List.uncons
20:33:07 <lambdabot> [a] -> Maybe (a, [a])
20:33:48 <Axman6> @hoogle (a -> Bool) -> [a] -> ([a],[a])
20:33:48 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
20:33:49 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
20:33:49 <lambdabot> Data.List span :: (a -> Bool) -> [a] -> ([a], [a])
20:33:56 <Axman6> span would be useful
20:34:13 <Axman6> > span even [1,3,5,6,7,8,9,10]
20:34:15 <lambdabot>  ([],[1,3,5,6,7,8,9,10])
20:34:21 <Axman6> > span odd [1,3,5,6,7,8,9,10]
20:34:23 <lambdabot>  ([1,3,5],[6,7,8,9,10])
20:35:31 <Axman6> remove f xs = case span (not . f) xs of (ys,[]) -> (Nothing,ys); (ys,z:zs) -> (Just z,ys++zs)
20:35:35 <ggVGc> still have to combine them afterwards. guess I'll just write it myself :)
20:36:05 <Axman6> well, I've just written it for you :P
20:36:13 <ggVGc> yeo, cheers :)
20:36:27 <ggVGc> think this would be something useful to have in Data.List though
20:36:42 <ggVGc> wonder if there's some other obvious way I'm missing
20:37:00 <Axman6> the only think I'm unsure of is if in the non matching case if you should return xs or ys, they're notionally the same but it might be a bad idea to return xs because... reasons
20:49:19 <amalloy> Axman6: span (not . f) = break f, right?
20:50:18 <Axman6> ah yes
20:55:07 <Axman6> :t build
20:55:09 <lambdabot> error:
20:55:09 <lambdabot>     • Variable not in scope: build
20:55:09 <lambdabot>     • Perhaps you meant ‘buildG’ (imported from Data.Graph)
20:55:14 <Axman6> :(
21:05:24 <jez_> so there's    (.)   ::            (b ->   c) -> (a ->   b) -> (a ->   c)
21:05:26 <jez_> and there's   (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
21:05:31 <jez_> but is there  (???) :: Monad m => (b ->   c) -> (a -> m b) -> (a -> m c)
21:05:58 <jez_> i.e., monad action composed with pure function
21:06:00 <Axman6> that's essentially just fmap
21:06:18 <Axman6> it's (fmap f .)
21:06:33 <Axman6> so, uh, (.) . fmap
21:06:39 <glguy> :t fmap fmap fmap :: Monad m => (b ->   c) -> (a -> m b) -> (a -> m c)
21:06:39 <Axman6> I think'
21:06:41 <lambdabot> Monad m => (b -> c) -> (a -> m b) -> a -> m c
21:06:55 <Axman6> :t (.) . fmap
21:06:57 <lambdabot> Functor f => (a1 -> b) -> (a2 -> f a1) -> a2 -> f b
21:07:34 <kaol> . is fmap for (->)
21:08:22 <jez_> This seems useful; is there not a symbol that this is usually given to this?
21:08:23 <Axman6> sure, but constraining it here makes it a bit clearer which Functor is being used
21:08:27 <Axman6> no
21:08:33 <jez_> :(
21:08:43 <Axman6> :t \f m -> fmap f <=< m
21:08:46 <lambdabot> Monad m => (a1 -> c) -> (a2 -> m (m a1)) -> a2 -> m c
21:08:54 <Axman6> hmm, not quite
21:09:08 <jez_> you're missing a return
21:09:17 <jez_> :t \x -> a x >>= (return . f)
21:09:19 <lambdabot> error:
21:09:19 <lambdabot>     Ambiguous occurrence ‘f’
21:09:19 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.f’,
21:10:10 <jez_> \f a x -> a x >>= (return . f)
21:11:35 <jez_> It kind of looks like (^<<) from Control.Arrow, so I've been using that in my code:
21:11:38 <jez_> :t (^<<)
21:11:41 <lambdabot> Arrow a => (c -> d) -> a b c -> a b d
21:11:59 <hololeap> besides the fact that IntSet takes only Int's as keys and Set can take any Ord, are there any major differences between the two?
21:12:39 <Axman6> their implemention is quite different
21:13:18 <Axman6> IntSet takes advantage of the fact that the values are Ints - take a look  at the source of IntSet to see the difference
21:15:25 <hololeap> Axman6: what about HashSet ... does that behave similarly to IntSet behind the scenes? the data i want to use is not an Int, but i did give it an Ord instance ... would there be any performance gain in switching to HashSet/Hashable?
21:16:17 <hololeap> i'm basically setting up a hash of IORef
21:16:26 <hololeap> s/hash/set
21:16:53 <Axman6> HashSet from unordered-containers would probably work well there
21:17:03 <hololeap> by using `newtype NewRef = NewRef (Int, IORef a)`
21:17:16 <hololeap> cool
21:18:07 <hololeap> so many options in Haskell, the hardest thing beyond learning the language is sorting through all the libaries with similar functionality
21:23:22 <hololeap> also, i'm a little confused as to which function to implement for a Hashable instance. there doesn't seem to be any MINIMAL pragma
21:23:48 <Axman6> doesn't IORef have a hashable isntance?
21:24:28 <hololeap> it doesn't appear to...
21:25:18 <hololeap> i could be wrong, but ghci doesn't show it
21:27:16 <hololeap> :t singleton <$> newIORef () :: IO (HashSet (IORef ()))
21:27:19 <lambdabot> error:
21:27:19 <lambdabot>     Not in scope: type constructor or class ‘HashSet’
21:27:19 <lambdabot> error:
21:27:37 <hololeap> in my ghci it says No instance for (Hashable (IORef ()))
21:29:47 <Axman6> hmmm, I thought IORefs had some kind of identity, but it looks like they don't
21:29:56 <hololeap> they have an Eq instance
21:29:57 <Axman6> they only have an Eq instance
21:30:38 <hololeap> i wish they did, but that's why i'm giving each one a unique id with a newtype and a counter threaded with a StateT
21:30:50 <Axman6> why do you need a set of IORefs anyway?
21:31:59 <hololeap> i need a way to quickly get a uniqle list of IORefs from an (IntSet (IORef Int)), where there may be many ints pointing to the same IORef
21:32:11 <hololeap> i meant IntMap
21:32:25 <hololeap> IntMap (IORef Int)
21:33:12 <hololeap> nub is O(n^2), so that won't cut it
21:33:22 <Axman6> sounds like IntMap (IORef a) to me
21:33:54 <hololeap> i'm not sure what you mean...
21:34:15 <Axman6> "Ints pointing to IORefs" is exactly what IntMap (IORef a) is, isn't it?
21:35:15 <hololeap> right, and that's what i have implemented. the Set is needed after the IntMap is built, because i need to get the number of unique IORefs in the IntMap
21:36:50 <Axman6> is the Int not some sort of identity for the IORef? if not, then O(n^2) is the best you can do because you only have Eq. to do better than that you need some sort of orderable key associated with each unique IORef
21:40:17 <hololeap> i had to attach another Int to give each IORef an identity. it is, in essence, `IntMap (IORef (Int,Int))` where the first Int is an Id and the second is a value i'm trying to store. i made it a newtype so i could give it an Ord instance based only on the Id value... it's actually working well
21:40:50 <Axman6> sounds reasonable to me
21:41:07 <hololeap> this is all for a HackerRank challenge, and they don't let you see the input that they test your algorithms with, but they seem to hit it with a lot of edge cases
21:42:18 <hololeap> https://www.hackerrank.com/challenges/prison-transport
21:44:18 <Axman6> @tell stepcut (\bs -> U.generate n (Data.ByteString.Unsafe.unsafeIndex bs) <$> take n is basically what you want
21:44:18 <lambdabot> Consider it noted.
21:46:29 <Axman6> hololeap: that looks like a graph problem to me, we have some pretty good graph libraries in Haskell
21:49:37 <hololeap> Axman6: how do you figure it is a graph problem? (genuinely curious)
21:50:42 <Axman6> because the groups of inmates are connected components in a graph. the answer to the problem is: find the size of all the connected components, find the smallest n where n^2 is larger than or equal to that size, and sum those  sizes for each connected component
21:52:23 <Axman6> Data.Graph from containers looks useful, but I'm not sompletely sure I understand how to use it. my knowledge of graphs is pretty limited
21:55:07 <hololeap> mine too
21:56:11 <hololeap> in any case, this current implementation of mine is way faster than the pure implementation i tried before. IORef's are killing it, and it's good practice for me since i haven't really used them before
22:21:12 <hololeap> meh, it's efficient enough, but i'm still getting wrong answers. on one test case it was supposed to return 18112 but my code is returning 18184... i wonder why...
22:23:37 <hololeap> for the "bus cost" function i'm doing `ceiling . sqrt . fromIntegral`
22:23:45 <hololeap> i wonder if that's introducing rounding errors
22:35:29 <whatsupboy> !guide
22:35:36 <whatsupboy> !books
22:35:40 <whatsupboy> ;;guide
22:35:40 <Axman6> hololeap: if you know your max N, you could just use an IntSet and lookupLE
22:36:11 <Axman6> uh, IntMap
22:37:03 <hololeap> it's something much more trivial, i think... you can "buy" the input/expected values for test cases. there is one with only 32 lines and it is still giving the wrong answer. i'm evaluating it now to see what i did wrong
22:37:32 <hololeap> i think i goofed somewhere
22:37:39 <Axman6> if n is large I could see sqrt giving bad answers
22:38:06 <whatsupboy> Friends there is some haskell mooc if I remember can somone post me that url ?
22:38:09 <hololeap> yeah, n is quite tiny on this one test case (80) and i'm still getting it wrong
22:38:23 <whatsupboy> that mooc  uses LYAH
22:38:25 <Axman6> hmm
22:38:47 <Axman6> whatsupboy: I've never heard of one
22:39:28 <Axman6> :t IntSet.empty
22:39:30 <lambdabot> error:
22:39:30 <lambdabot>     Not in scope: ‘IntSet.empty’
22:39:30 <lambdabot>     No module named ‘IntSet’ is imported.
22:39:38 <Axman6> :t Data.IntSet.empty
22:39:41 <lambdabot> IS.IntSet
22:40:43 <whatsupboy> Axman6:  there is one, DO you know how can I use bot for books
22:43:46 <Axman6> let sqrs = IM.fromList [(n*2,n) | n <- [0..1000]]; sqrt' i = snd . fromMaybe . lookupGE i $ sqrs in map sqrt' [1,2,3,4,10,12,60,64,65]
22:44:03 <Axman6> > let sqrs = IM.fromList [(n*2,n) | n <- [0..1000]]; sqrt' i = snd . fromMaybe . lookupGE i $ sqrs in map sqrt' [1,2,3,4,10,12,60,64,65]
22:44:07 <lambdabot>  error:
22:44:07 <lambdabot>      • Couldn't match type ‘Maybe a0 -> a0’ with ‘(a1, c)’
22:44:07 <lambdabot>        Expected type: IM.IntMap IS.Key -> (a1, c)
22:44:22 <Axman6> > let sqrs = IM.fromList [(n*2,n) | n <- [0..1000]]; sqrt' i = snd . fromJust . lookupGE i $ sqrs in map sqrt' [1,2,3,4,10,12,60,64,65]
22:44:26 <lambdabot>  error:
22:44:26 <lambdabot>      • Variable not in scope:
22:44:26 <lambdabot>          lookupGE :: t -> IM.IntMap IS.Key -> Maybe (a0, c)
22:44:42 <Axman6> > let sqrs = IM.fromList [(n*2,n) | n <- [0..1000]]; sqrt' i = snd . fromJust . IS.lookupGE i $ sqrs in map sqrt' [1,2,3,4,10,12,60,64,65]
22:44:45 <lambdabot>  error:
22:44:46 <lambdabot>      • Couldn't match type ‘Int’ with ‘(a0, c)’
22:44:46 <lambdabot>        Expected type: IS.IntSet -> (a0, c)
22:44:51 <Axman6> > let sqrs = IM.fromList [(n*2,n) | n <- [0..1000]]; sqrt' i = snd . fromJust . IM.lookupGE i $ sqrs in map sqrt' [1,2,3,4,10,12,60,64,65]
22:44:54 <lambdabot>  [1,1,2,2,5,6,30,32,33]
22:45:12 <Axman6> that's not right...
22:45:20 * Axman6 gives up to reduce noise
22:45:33 <pavonia> You want n**2, no?
22:46:27 <Axman6> uh, yes, was supposed to be either n^2 or n*n and got neither -_-
22:46:34 <Axman6> > let sqrs = IM.fromList [(n*n,n) | n <- [0..1000]]; sqrt' i = snd . fromJust . IM.lookupGE i $ sqrs in map sqrt' [1,2,3,4,10,12,60,64,65]
22:46:37 <lambdabot>  [1,2,2,2,4,4,8,8,9]
22:47:33 <hjhg> how to convert [11,12,13,14] to ["11","12","13","14"]
22:47:47 <Axman6> map show
22:48:26 <hjhg> thank u
22:53:36 <hololeap> Axman6: if you're interested, here is the simple input that my algorithm is failing on. it expects "62" as the answer, but i keep getting "65" even when i do it "by hand": https://paste.pound-python.org/show/DcwYA4Ew2N0oLRo6U409/
22:53:59 <hololeap> it's a little baffling
22:54:34 <hololeap> the answer could be wrong, but i'm not ready to conclude that yet
22:57:07 <hololeap> or, here is the list of pairs in [(Int,Int)] form: [(40,22),(60,6),(22,39),(43,40),(22,55),(48,57),(42,41),(22,57),(6,42),(33,74),(70,46),(4,11),(6,28),(22,79),(61,34),(77,40),(4,8),(72,26),(62,50),(72,51),(1,79),(34,29),(77,41),(2,48),(43,2),(62,45),(43,17),(19,33),(76,4),(35,54)]
22:58:34 <geekosaur> first things first: have you checked that list for typos?
22:59:07 <hololeap> geekosaur: i used a ruby one-liner to generate it :)
22:59:30 <geekosaur> then check that. doesnt matter how good the algorithm is if you've GIGOd it
23:02:56 <hololeap> it looks good. it matches what HackerRank gave me
23:04:50 <cheater> can someone suggest alternatives to conduit? is it still the nicest thing to use? i'm mostly looking for a fairly lightweight abstraction for streaming data from input, through filters, and to output. i would like to gather data from IO, then do things like drop items or bunch n items into a single n-tuple, apply functions on them, and then output via IO.
23:06:30 <cheater> also i would like to define a stage that has backpressure: a queue of up to k items, and if it's full, then all the stages before should stop processing and the input should stop polling.
23:08:43 <whatsupboy> cheater:  are you cheater than me ?
23:09:03 <whatsupboy> I deserve that nick please give me
23:18:36 <dmj`> cheater: streaming
23:18:43 <dmj`> @package streaming
23:18:43 <lambdabot> http://hackage.haskell.org/package/streaming
23:18:57 <dmj`> Is the new thing
23:19:59 <Axman6> yeah streaming looks pretty nice
23:26:34 <cheater> dmj`: thanks
23:27:01 <dmj`> np
23:27:15 <cheater> in conduit, is it possible to define back pressure? i mean, i have a stage in my pipeline somewhere, such that it will buffer at most 10 elements, and if there are more it will stop accepting new ones
23:27:21 <cheater> also is this possible in streaming?
23:27:42 <cheater> is there a lib function in either? (i can imagine how i might build one myself)
23:35:51 <whatsupboy> haskell have cs194 and I used to have similar one lost the url can some one tell me if they know it
23:41:01 <cocreature> cheater: not sure if something already exists for conduit or streaming but https://hackage.haskell.org/package/pipes-async-0.1.2/docs/Pipes-Async.html#v:buffer might be helpful if you want to implement it yourself
23:42:05 <geekosaur> @where nicta
23:42:05 <lambdabot> https://github.com/nicta/course
23:42:06 <cheater> thanks
23:42:12 <geekosaur> but it has changed a lot and is no longer recommended
23:42:16 <cheater> why would i use pipes or streaming over conduit?
23:42:18 <Axman6> hmm, that URL should be updated
23:42:29 <cocreature> it’s mostly a matter of taste
23:42:29 <Axman6> should point to /Data61/course
23:42:33 <geekosaur> yeh
23:42:52 <Axman6> (and we should probably rename if to fp-course or something)
23:43:13 <Axman6> we have!
23:43:28 <Axman6> https://github.com/Data61/fp-course
23:55:05 <cheater> thanks cocreature
