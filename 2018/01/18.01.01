00:58:53 <dkov> I have a transformers stack, including IO to read from a file on demand (not sequentially). how do I get rid of the IO, so I can specialize later to read either from the file or purly from a bytestring (or something else)?
01:01:15 <Zemyla> dkov: Make a typeclass for it.
01:16:56 <jle`> dkov: you can use an ADT to make a monad with the operations you want to do
01:17:06 <jle`> and then interpret it as IO, or as some pure function
01:17:14 <jle`> the Free Monad pattern is a nice way to achieve this cleanly
01:17:20 <jle`> but also MonadPrompt is useful for this too
01:34:18 <dkov> jle`: so I have to either go with free monads or transformer stacks? do they play together? I also have no clue about performance and latency implications. At the end of the day I have to process a file, log and handle errors relatively efficiently.
01:35:05 <jle`> dkov: i was assuming you were already working with a transformer stack
01:35:34 <jle`> and you don't have to use the free monad to implement what i'm talking about
01:35:45 <jle`> Free is just one of the tools to make it more convenient
01:35:45 * hackage pushme 2.1.1 - Tool to synchronize directories with rsync, zfs or git-annex  https://hackage.haskell.org/package/pushme-2.1.1 (JohnWiegley)
01:35:57 <jle`> so it's not quite a "free monads or tranfsormer stacks" dichotomy
01:37:02 <dkov> jle`: yes i am. ah, ok. I think I have to get some experience with free monads
01:37:23 <jle`> it's not really "free monads"
01:37:30 <jle`> you just need to use one :)
01:37:36 <jle`> you're making a monad
01:37:43 <jle`> and Free is one tool to make one conveniently
01:37:55 <jle`> but there are other ways to do it too
02:07:02 <cocreature> do we have a package that provides arbitrary length word types indexed by a typelevel nat or something similar?
02:15:15 * hackage imj-prelude 0.1.0.2 - Prelude library.  https://hackage.haskell.org/package/imj-prelude-0.1.0.2 (OlivierSohn)
02:17:16 * hackage imj-base 0.1.0.2, imj-game-hamazed 0.1.0.2, imj-animation 0.1.0.2, imj-measure-stdout 0.1.0.2 (OlivierSohn): https://qbin.io/galg04dts
02:18:45 * hackage date-conversions 0.2.0.0 - Date conversions  https://hackage.haskell.org/package/date-conversions-0.2.0.0 (joshuaclayton)
02:24:15 * hackage typed-process 0.2.1.0 - Run external processes, with strong typing of streams  https://hackage.haskell.org/package/typed-process-0.2.1.0 (MichaelSnoyman)
02:34:31 <rascal> Hello
02:34:53 <rascal> Is Haskell for everyone or only the distinguished?
02:37:19 <nyberg> mascle: for everyone
02:38:57 <mascle> nyberg: I have some reservations about the state of humanity and future of computing, would haskell in anyway impact my world view?
02:40:10 <nyberg> mascle: It certainly would if you have yet to venture into pure functional land
02:42:32 <mascle> nyberg: Would it make you believe I am insane if I believe barely anything is properly functional?
02:45:37 <mascle> So is haskell functional or not?
02:45:47 <nyberg> Haskell is
02:46:30 <mascle> How could something be functional in a dysfunctional world that thrives with mediocrity?
02:46:37 <nyberg> ...
02:48:07 <mascle> nyberg: Are you doubtful of how things are?
02:48:17 <mascle> or how I see things are, anyhow.
02:49:55 <nyberg> I fail see how this relates to learning haskell
02:50:44 <mascle> Nothing exists in a vacuum.
02:52:32 <davean> I mean, nothing exists *as* a vacuum
02:54:03 <mascle> I don't understand.
03:29:56 <lyxia> Is there any way to define a (type Type = *) synonym using base<4.9 (GHC<8)? So far I get parser errors because the parser thinks * is the operator...
03:31:24 <lyxia> ah, ghc-prim defines it as "type Type = TYPE 'LiftedRep". I definitely couldn't have guessed that.
03:34:53 <ggVGc> is this a good year for haskell?
03:35:04 <mozzarella> too soon to tell
03:35:22 <ggVGc> well, I better start investigateing
04:05:41 <Franciman> Hi
04:05:47 <Franciman> Happy new year
04:05:59 <mekeor> Franciman: thanks! you, too! :)
04:23:11 <mniip> is it possible to define a topology on *quantified types* such that the notion of topological continuity would be precisely the notion of parametricity in polymorphic functions
04:27:45 * hackage stackage2nix 0.4.0 - Convert Stack files into Nix build instructions.  https://hackage.haskell.org/package/stackage2nix-0.4.0 (dbushev)
04:40:19 <JuanDaugherty> is there such a thing as a typology of types?
04:40:57 <JuanDaugherty> (distinct from sets)
04:41:22 <JuanDaugherty> *topology
04:44:32 <lyxia> mniip: in this language for differential privacy there is a notion of Lipschitz-continuity that's similar to a form of parametricity https://www.cis.upenn.edu/~ahae/papers/adafuzz-icfp2017.pdf
04:46:25 <lyxia> hmmm it's another paper that mentions lipschitz...
04:48:39 <lyxia> ah no it's because they call it "sensitivity"
04:54:24 <jgt> Hey Folks. Happy New Year.
04:55:18 <jgt> How do I Aeson parse a nested field, where the upper level field is optional?
04:55:28 * JuanDaugherty puts the neu back in neujahr
04:55:40 <jgt> I'm guessing at something like ths
04:55:42 <jgt> officerBirthYear <- (o .:? "date_of_birth") >>= (.: "year")
04:57:11 <lyxia> ... >>= traverse (.: "year")
04:58:07 <jgt> lyxia: Oh wow. I should go learn what traverse does. Thanks!
05:06:59 <jgt1> lyxia: here's another one. I want a Maybe Int, but I'm getting a Maybe (Maybe Int). I know that I should use a bind somewhere, but I'm not sure where now
05:07:04 <jgt1> officerBirthDay <- (o .:? "date_of_birth") >>= traverse (.:? "day")
05:07:15 <Rembane> jtcs: You could also join at the end.
05:07:16 * hackage persistent-redis 2.5.2.1 - Backend for persistent library using Redis.  https://hackage.haskell.org/package/persistent-redis-2.5.2.1 (psibi)
05:07:19 <Rembane> jtcs: Mischat. :D
05:07:23 <Rembane> jgt1: You could also join at the end.
05:07:44 <jgt1> Rembane: I'm not sure what join is in this context
05:08:10 <jgt1> maybe my mind is blank, but I can only think of join as a string join
05:08:17 <Rembane> :t join
05:08:17 <lambdabot> Monad m => m (m a) -> m a
05:08:29 <jgt1> oh, yeah, that looks right
05:08:34 <Rembane> jgt1: Sorry, I wasn't very clear which join. I lives in Control.Monad.
05:08:38 <Rembane> It lives even.
05:11:09 <jgt1> Rembane: I tried this, but no such luck
05:11:13 <jgt1> officerBirthDay <- join $ (o .:? "date_of_birth") >>= traverse (.:? "day")
05:12:20 <Rembane> jgt1: What type did you get?
05:12:27 <jgt1> oh, I can do it in two steps
05:12:29 <jgt1>     oBD <- (o .:? "date_of_birth") >>= traverse (.:? "day")
05:12:31 <jgt1>     let officerBirthDay = join oBD
05:13:12 <Rembane> You can, or probably add more brackets.
05:14:10 <Rembane> officerBirthDay <- join ((o .:? "date_of_birth") >>= traverse (.:? "day"))
05:15:04 <Rembane> :t traverse
05:15:05 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:15:16 <Rembane> :t mapM
05:15:17 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
05:15:21 <Rembane> Ah
05:15:35 <Rembane> :t (.:?)
05:15:36 <lambdabot> error: Variable not in scope: .:?
05:15:42 <jgt1> Rembane: here's what I get back http://sprunge.us/YPJb
05:16:18 <Rembane> jgt1: Oh. Let me stare at the line of code for a little while and maybe something pops up.
05:21:02 <ongy> does the RTS do something special with SIGUSR1 depending on whether it's threaded or not?
05:21:50 <Rembane> jgt1: officerBirthDay <- fmap join ((o .:? "date_of_birth") >>= traverse (.:? "day"))
05:21:58 <ski> jgt1 : how about `officerBirthYear <- runMaybeT (MaybeT . (.: "year") =<< MaybeT (o .:? "date_of_birth"))', does that work ?
05:24:05 <jgt1> Rembane: yeah, fmapping works :)
05:24:08 <jgt1> thanks!
05:24:12 <Rembane> jgt1: Sweet. ^^
05:24:29 * ski wonders about the type of `(.: "year")' and `(.:? "date_of_birth")' here
05:24:49 <jgt1> ski: I just noticed the order of fields are reversed
05:24:53 <Rembane> jgt1: You could replace fmap with <$> and remove the brackets if you're code golfing. :)
05:25:36 <ski> jgt1 : i used `(=<<)' for more consistent ordering. you could use `(>>=)' instead, if you prefer
05:26:10 <jgt1> Rembane: yeah I know about infix fmap and that's what I tried first, but I can't remove the parens
05:26:59 <Rembane> jgt1: Okay, then I've forgotten the precedence of <$> and >>=.
05:28:45 * hackage mmark 0.0.4.2 - Strict markdown processor for writers  https://hackage.haskell.org/package/mmark-0.0.4.2 (mrkkrp)
05:57:39 <ertes> the cosmic rays did it again‚Ä¶  they made a bunch of bits flip in my memory‚Ä¶  i'm so happy when those particular bits flip, because now i get to tell random people on the internet to have a happy new number on your duns, while i experience the joy of having to update all my templates to reflect the change ‚Äì once the particularly annoying side effect of people going crazy pyromaniacs outside wears off, so i can focus on being the happy
05:57:39 <ertes> nerd that i am again
05:58:02 <ertes> so yeah‚Ä¶  happy 2018!
05:58:17 <ertes> i do have 50 fields again, don't i?
06:04:35 * JuanDaugherty waits for 4716 to be the happy
06:12:02 <mniip> JuanDaugherty, well I've seen people use the word "continuous", sometimes quoted, to denote the parametricity of a polymorphic function
06:12:40 <mniip> like, for example, if you had  f :: Proxy 'Bool -> Bool
06:12:59 <mniip> such that  f (Proxy @'True) = True; f (Proxy @'False) = False
06:13:14 <mniip> such a function would be "discontinuous"
06:14:06 <mniip> er
06:14:18 <mniip> f :: forall (b :: Bool). Proxy b -> Bool
06:14:21 <mniip> is what I meant
06:14:55 <mniip> formally the "discontinuity" is explained by violation of the profunctor end definition
06:15:15 * hackage imap 0.3.0.5 - An efficient IMAP client library, with SSL and streaming  https://hackage.haskell.org/package/imap-0.3.0.5 (mkawalec)
06:15:52 <mniip> an injection like f cannot be an element of the end of the Hom(Proxy(-), Bool) profunctor
06:16:09 <mniip> because a certain diagram doesn't commute
06:16:32 <mniip> that said diagram is the same one as the one induced by wadler's free theorems from parametricity
06:19:56 <ski> @where topology
06:19:56 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|
06:19:56 <lambdabot> dvi|ps)> by MartÌn EscardÛ
06:20:08 <ski> JuanDaugherty : perhaps that ^ could be interesting ?
06:21:50 <JuanDaugherty> just looked at the first, regular topology in haskell, like any other math apparently ...
06:22:46 <JuanDaugherty> 404 on the second
06:23:00 <JuanDaugherty> ah typo
06:23:06 <mniip> http://www.cs.bham.ac.uk/~mhe/papers/entcs87.pdf
06:23:07 <mniip> worksforme
06:24:29 <ski> JuanDaugherty : using "continuous" = "computable". a compact space is one over which one can universally quantify. a hausdorff space is one which has an inequality (technically "apartness") relation
06:24:44 <JuanDaugherty> yes i'm reading the operative section now
06:26:40 <JuanDaugherty> well without further comment it is certainly an attempt at a toplogy of types, so there is at least it
06:27:09 <mniip> well no, I was thinking more of...
06:27:11 <ski> instead of Boolean truth-values, it uses Sierpinski truth-values. `data Sierpinski = Terminated', `{Terminated}' is an open subset, `{_|_}' is a closed subset. we can compute `(/=) :: Stream Nat -> Stream Nat -> Sierpinski' (if two streams of naturals are apart, then we'll eventually find out)
06:27:17 <mniip> the topology on the set of all types
06:27:42 <mniip> where monomorphic types are open sets with one point
06:27:50 <mniip> and quantified types are other open sets
06:28:00 <ski> mniip : like "The intrinsic topology of Martin-L√∂f universes" by Mart√≠n H√∂tzel Escard√≥,Thomas Streicher in 2016-02-12 at <http://www.cs.bham.ac.uk/~mhe/papers/universe-indiscrete.pdf> ?
06:28:43 <mniip> hmm no
06:28:46 <ski> (it turns out that the topology of the universe of types here is (provably) indiscrete)
06:29:10 <mniip> the topological space of all terms!
06:29:36 <JuanDaugherty> i'm good with it but if I were a nay sayer I would say that types and sets being different beasts was settled before this
06:29:55 <JuanDaugherty> i am not however a knee jerk nay sayer
06:30:22 <mniip> it's ok, we can make up the set of all terms
06:30:39 <mniip> for a countable number of coinductive GADTs and functions
06:30:41 <mniip> and foralls
06:31:45 <mniip> I think...
06:32:06 <mniip> well computable terms definitely, others not so sure
06:32:07 <ski> mniip : hm. what would existential types be, there ?
06:32:17 <mniip> doubly quantified constructors
06:32:45 <ski> the CPS encoding ?
06:32:51 <mniip> exists a. P a = forall a r. (P a -> r) -> r
06:32:55 * ski nods
06:33:04 <mniip> for profunctor P in general
06:33:05 <ski> (s/forall a/forall/)
06:33:18 <ski> oh. sorry, no
06:33:43 <ski> iirc, it should be `exists a. P a  =  forall r. (forall a. P a -> r) -> r'
06:33:52 <mniip> ah yes
06:33:57 <mniip> indeed
06:34:02 <ski> (so rank-2)
06:34:07 <mniip> yeah
06:34:29 <mniip> if you're asking whether I'm restricting things to rank-1, I'm not
06:35:29 <mniip> you just take a parameterized profunctor Q_r(c', c) = Hom(P(c, c'), r)
06:36:07 <mniip> and take end_r Hom(end_c Q_r'(c', c), r)
06:52:07 <heebo> anyone suggest a cool haskell tutorial for graphics
06:52:18 <mekeor> heebo: what kind of graphics?
06:52:47 <heebo> 3d or vector graphics something with cool output
06:58:34 <heebo> i feel like doing a project with haskell
07:02:24 <ggVGc> same
07:03:07 <[Leary]> I don't know about a tutorial as such, but you probably want to use the Accelerate library anyway, and accelerate-examples has some pretty cool demos. One of the guys behind it did a ~20 minute talk introducing the basics, it's floating around somewhere...
07:03:12 <oak-> not sure about tutorials but I recommend to check out lambdacube
07:15:20 <sam_> trying to debug a State monad computation by using traceM but nothing is showing up in the console when running the program
07:19:05 <sam_> hmm, never mind it does seem to work.
08:06:22 <ertes> heebo: check out the 'diagrams' package‚Ä¶  it has lots of documentation and some cool samples
08:06:44 <ertes> heebo: https://archives.haskell.org/projects.haskell.org/diagrams/
08:07:44 <heebo> thanks all
08:07:49 <ertes> heebo: for 3D there are lots of options, and it would be best if you provided more context or at least told us on what level you want to do it
08:08:48 <heebo> ertes: im really just doing something for shits and giggles, no agenda... havent flexed my haskell muscle in a while and dont want it to atrophy
08:09:15 * hackage generic-random 1.1.0.0 - Generic random generators  https://hackage.haskell.org/package/generic-random-1.1.0.0 (lyxia)
08:10:11 <heebo> would be nice to do something that is rewarding...so im thinking visual rewards. I started doing adventofcode.com but after i finished question#3 i was feeling a little bored with it
08:10:26 <ertes> heebo: still there is a massive difference between the levels‚Ä¶  for example i consider it fun to write my own 3D rasteriser (the part that OpenGL does automatically for you), but it's extremely low-level, up to drawing the individual pixels of triangles
08:11:24 <ertes> the next higher level would be OpenGL (the 'gl' package) or vulkan if you dare, mid level would be something like GPipe or luminance, high level would be the already mentioned lambdacube
08:11:33 <heebo> ertes: im looking for a higher ROI than that, dont feel like busting my braincells for half a day to get a line between two points as a reward
08:11:52 <heebo> i think lambdacube
08:13:00 <ertes> another noteworthy option for 2D vector graphics is gloss‚Ä¶  it's extremely high-level
08:14:39 <heebo> cool üëçüèΩ
08:16:19 <ertes> compared to diagrams gloss is more suitable for live graphics and animation
08:16:39 <ertes> instead of an SVG/PNG file you get an interactive window
08:21:15 * hackage generic-random 1.1.0.1 - Generic random generators  https://hackage.haskell.org/package/generic-random-1.1.0.1 (lyxia)
08:46:13 <hoon> I've received a lot of helpful feedback here on my little toy project I've been working on to learn Haskell. I think I have a fully functioning version, but I'm left wondering if the architecture can be improved.
08:47:02 <hoon> anybody willing to look through it with me?
08:47:07 <hoon> http://lpaste.net/361250
08:47:55 --- mode: ChanServ set +o glguy
08:48:40 <hoon> the structure of the key functions are ReaderT to get access to the command line options and the relevant output file handle
08:49:08 <hoon> in the guts I end up using a StateT to try the number of input bytes read
08:49:17 <hoon> ^ from input
08:59:22 <kakashiAL> I would like to calculate the square root of 2 with a precesion of 50 and 100 numbers after the point
08:59:36 <kakashiAL> what type would you recommend for that?
08:59:54 <kakashiAL> Rational does not fit for that job
09:00:42 <liste> why not Rational?
09:00:44 <monochrom> Actually it does. Use a continued fraction algorithm.
09:01:16 <kakashiAL> liste: because you cant represent squareroot of 2 as p/q
09:01:18 <monochrom> There is a formula for how many iterations you need, specifically for square roots.
09:01:42 <kakashiAL> monochrom: I know what you mean :)
09:01:51 <liste> kakashiAL: you can't represent it with any other finite data type either
09:02:06 <liste> unless it's specifically for representing square roots
09:02:12 <nullie> heh
09:02:24 <nullie> algebraic number datatype
09:03:19 <liste> kakashiAL: calculating sqrt(2) for the 100th place (or any Nth place) is an approximation, wich CAN be represented as p/q
09:03:19 <kakashiAL> liste: sure, but is there a datatype, where I dont have to write a nummeric approximation for the value, and where I can my datatype: "please give me 10 or 50 or 200 numbers after the point"
09:04:27 <liste> kakashiAL: well that would just be a wrapper for calculating approximations of irrational numbers
09:04:30 <glguy> kakashiAL: You already know the answer
09:04:37 <liste> so it'd basically be a CAS
09:04:48 <glguy> Becase people have shared it with you a couple of times, you've asked this before
09:04:59 * monochrom just likes to throw a wrench into conventional wisdom
09:05:02 <kakashiAL> glguy: I dont, if you do please say it again :)
09:06:39 <kakashiAL> there is the Number package, dont know what to pick from there
09:08:20 <liste> kakashiAL: learn the math for continued fraction algorithms, apply it using Rational
09:08:29 <monochrom> Also, decimal is so 20th century.
09:09:14 <kakashiAL> liste: we are (at least I try to be) functional programmers, I would like to abstract that away
09:09:30 <kakashiAL> monochrom: AMEN :)
09:10:24 <liste> kakashiAL: then write a wrapper type for abstracting that away
09:10:31 <monochrom> Anyone wanna bet how long before they ask about the digits of pi?
09:10:44 <monochrom> Because I happen to know a Functional Pearl paper for that.
09:11:06 <monochrom> I mean speaking of a stream of numerical questions and "we are functional programmers"
09:11:11 <kakashiAL> liste: if you mean there is no wrapper that is already implemented (what its hard to belive) I can do that
09:11:15 * hackage cabal2nix 2.7.2 - Convert Cabal files into Nix build instructions.  https://hackage.haskell.org/package/cabal2nix-2.7.2 (PeterSimons)
09:11:22 <monochrom> (And yes, pun on "stream" too)
09:13:17 <kakashiAL> liste: what should I use, newton or maybe there are other good approximation, thats not the point, but haskell is a powerfull language with a powerfull community, I am very sure that there is something already implemented
09:13:45 <barnab> Hello all. How can I ask a question on Haskell here?
09:14:02 <barnab> Happy new year everyone too
09:14:05 <nullie> Just ask
09:14:14 <liste> @hackage quadratic-irrational -- kakashiAL
09:14:14 <lambdabot> http://hackage.haskell.org/package/quadratic-irrational -- kakashiAL
09:15:25 <barnab> I'm trying to shadow a global name: suppose I have x = 1 and a function f n = x + n. I want to see 10 in: let x = 0 in f 10
09:15:46 <barnab> Is there a way without changing types?
09:16:15 <monochrom> Oh I forgot Newton. Yeah that works too.
09:17:05 <liste> barnab: check out implicit variables
09:18:23 <hoon> barnab: ImplicitParams
09:18:24 <monochrom> f n = let x = 0 in x + n
09:18:24 <kakashiAL> liste: what I mean is I want a function, I dont know, something like (just to get the idea) "calculateSomethingComplicated" there you will have pi and squareRoots and so on, some function that maybe you or a smart professor wrote, you just want to calculate: (squareRoot 2 * 3.14) / (4 ^ x)  <---now you dont want to write the extra technical code for approximation, you just want a powerful and strong datatyp
09:18:25 <hoon> ?
09:18:27 <kakashiAL> that asking you: "how much precision do you want"
09:19:00 <liste> kakashiAL: quadratic-irrational does exactly that for quadratic irrationals
09:19:12 <liste> (and rationals)
09:19:12 <kakashiAL> liste: correct
09:19:49 <kakashiAL> liste: but is there nothing more polymorphic, that does not care what you have, could be that I have quadratioc
09:20:11 <kakashiAL> quadratic-irrationals, but also could be something else
09:20:17 <liste> kakashiAL: if you want that for general math expressions, you should be looking at CAS'es, like Mathematica, Maple and Maxima
09:20:18 <monochrom> .Internal.Lens eh?
09:20:39 <kakashiAL> liste: what do you think about Numbers?
09:20:46 <barnab> monochrom that was an example, but I can't normally change the body of the functions
09:20:56 <barnab> (but that would have been a good trick)
09:21:28 <liste> kakashiAL: looks good for number theory, not so much for analysis or arithmetic
09:21:50 * hackage fast-combinatorics 0.1.0.7 - Fast combinatorics.  https://hackage.haskell.org/package/fast-combinatorics-0.1.0.7 (vmchale)
09:21:59 <barnab> Can I use implicit params in ghci?
09:22:21 <liste> barnab: yes, if you turn on the extension
09:23:05 <monochrom> Implicit param will also require you to change the body, or the type sig.
09:23:12 <Kristjan> I'm in urgent need for money. Please help me. Send to my paypal account(My e-mail: kristjanrobam@hotmail.com) or bank account: EE671010010225901016. Name: Kristjan Robam. Thanks!
09:23:57 --- mode: ChanServ set +o monochrom
09:24:12 --- mode: monochrom set -o monochrom
09:24:48 <webstrand> Why do types in haskell have multiple layouts (contained types with order)? In older programming languages, each type has a single layout and haskell-like types are achieved through inheritance. Is this a feature of convenience, or based on some deeper mathematical concept?
09:25:20 <monochrom> I don't understand what's multiple or single layout.
09:25:30 <kakashiAL> webstrand: do you mean type classes?
09:25:38 <monochrom> And in really old languages, there was no inheritance either.
09:25:54 <webstrand> Well, each type can have multiple constructors, and each constructor corresponds to different stored data, right?
09:26:31 <webstrand> It's like a type in haskell is made up of multiple classes (c++) inheriting from one base class
09:26:58 <monochrom> In terms of mathematics, algebraic data types are simpler, inheritance is very complicated.
09:27:19 <monochrom> And in terms of practice, inheritance turns out to be disappointing on usefulness.
09:27:56 <webstrand> I was just relating the two concepts. So types in haskell are the way they are, because of algebreic typing?
09:28:00 <monochrom> Even now many game developers swear against inheritance (apart from one abstract class plus just one tier of children)
09:29:07 <glguy> webstrand: By defining all the "alternatives" at once we can write functions that we know always handle all alternatives and can be allowed to test the identities of each alternative
09:30:47 <webstrand> Ah, so if the alternatives were defined through inheritance, one could never be sure they handled all cases, and type inference would break?
09:31:02 <barnab> f :: (?x :: Int) => Int -> Int          f 0 = x
09:31:39 <barnab> Sorry, f n = x
09:32:04 <barnab> When I try: let x = 10 in f 0   I get: unbound implicit parameter arising from a use of it
09:32:11 <glguy> barnab: let ?x =
09:33:22 <barnab> glguy also in the body it should be ?x right?
09:34:24 <barnab> Is there a way to to dynamic binding / shadowing without changing the body of any function?
09:35:11 <liste> barnab: no
09:35:29 <barnab> Ok :) Thanks liste
09:35:31 <hoon> barnab: I'm totally uninformed, but it seems like you need a wrapper for the relevant functions
09:44:03 <monochrom> webstrand: You may like to read about "the expression problem"
09:44:14 <carter> http://www.shoup.net/ntb/ is a fun book :)
09:44:23 <monochrom> But the Composite Pattern exists because people lack algebraic data types.
09:44:44 <monochrom> And the Visitor Pattern is also partly because of that.
09:44:45 * hackage hledger-iadd 1.3.1 - A terminal UI as drop-in replacement for hledger add  https://hackage.haskell.org/package/hledger-iadd-1.3.1 (hpdeifel)
09:47:46 * hackage JuicyPixels 3.2.9.3 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.2.9.3 (VincentBerthoux)
09:48:24 <nullie> what bothers me in many languages that they don't have some kind of strong enum type
09:49:05 <nullie> which would only allow equality on same type
09:51:34 <monochrom> I think Pascal has it. :)
09:51:35 <webstrand> monochrom: Thanks for that; I've never had a name for my frustration with many language
09:51:52 <barnab> I am not able to make it work. F :: (?x :: Int) => (Int -> Int) -> (Int -> Int) -> Int where F g f = let ?x = g ?x in f 0
09:52:11 <barnab> Still unbound parameter :(
09:52:59 <nullie> > F :: (?x :: Int) => (Int -> Int) -> (Int -> Int) -> Int where F g f = let ?x = g ?x in f 0
09:53:01 <lambdabot>  <hint>:1:57: error: parse error on input ‚Äòwhere‚Äô
09:53:05 <monochrom> Is it really supposed to be "F"? Function names aren't allowed to be capital.
09:53:23 <barnab> I called it "af", but it wasn't a great name to write here :)
09:54:12 <monochrom> Delete "let ?x = g ?x"
09:54:17 <monochrom> and "in"
09:54:47 <monochrom> And delete "where"
09:55:04 <monochrom> use ";" or newline instead
09:55:13 <barnab> (where was just for pasting it here)
09:55:55 <monochrom> What else are not real there?
09:56:11 <barnab> Nothing, I didn't want two messages
09:56:20 <barnab> af  :: (?x :: Int) => (Int -> Int) -> (Int -> Int) -> Int
09:56:27 <barnab> af  g f = let ?x = g ?x in f 0
09:56:39 <barnab> That's how my file is
09:57:40 <barnab> But if I delete "let ?x = g ?x", then how do I update it?
09:58:02 <monochrom> There is no update. ?x is not a mutable cell.
09:58:24 <barnab> I mean, how do I make "f 0" see "x" with the new value
09:59:04 <monochrom> f has to expect ?x as an implicit param, too.
09:59:26 <monochrom> <monochrom> Implicit param will also require you to change the body, or the type sig.
09:59:40 <monochrom> It pays to believe monochrom.
10:00:16 <barnab> Oh I see
10:00:25 <monochrom> Haskell bannishes dynamic scoping, unlike very old Lisp.
10:04:43 <barnab> Then can I change the value of the global "x"?
10:04:53 <monochrom> No.
10:05:30 <monochrom> You can move f's code to a place where the undesirable x is inaccessible
10:05:38 <monochrom> Or you can rewrite f.
10:06:27 <barnab> Suppose f is given
10:06:35 <barnab> I mean, I don't write it
10:06:57 <barnab> "af" just calls "g", "f" with those signatures
10:07:22 <monochrom> Then you're thinking dynamic scoping.
10:07:57 <monochrom> Unfortunately only very old versions of Lisp did that. Because soon after people agreed that it was a mistake.
10:08:46 <monochrom> So I should be saying "Fortunately" instead.
10:09:19 <barnab> I mean
10:09:30 <barnab> Not that it makes it easier
10:09:32 <loli> Common Lisp has dynamic scoping for their global variables by default
10:09:45 <loli> you can make lexical variables special (dynamic) as well
10:10:28 <barnab> How?
10:11:02 <monochrom> I'm grateful standard Scheme exists.
10:11:30 <loli> let me remember how to promote lexical variables, I never use it
10:11:38 <loli> even scheme has dynamics, with "parameratize"
10:12:00 <EvanR> parameratize? really
10:12:05 <monochrom> That's a good name.
10:12:28 <loli> okay I think I did it barnab
10:12:51 <loli> I have not tested, but it should follow dynamic rules
10:12:55 <loli> http://lpaste.net/7496709074063458304
10:13:35 <loli> I find dynamic variables useful for very specific tasks
10:13:43 <loli> I often think of it as a worse state monad
10:14:00 <monochrom> Yeah "special" is a pretty bland name. I mean, I see that word on Amazon and Steam sales all the time. :)
10:15:51 <barnab> I'm not sure how to use it :p
10:15:59 <loli> here is one example
10:16:57 <loli> I'm making a finger tree in CL
10:17:07 <loli> and I want users to define their own monoids
10:17:39 <loli> so I'm doing this by making <>, measure and mempty be defined by default for numbers, strings, etc etc. but allowing a user to instantiate a struct called
10:18:04 <loli> "custom finger tree" that uses a macro that lets it's parameters over every finger tree call, so it uses the new <>,measure, and mempty
10:18:32 <loli> as all the function calls will now associate with the custom type or default if their finger tree is of a different type
10:18:44 <loli> or if they wish to make a custom monoid for many types
10:20:16 <loli> another way to solve this is to pass in <>,mempty, and measure with keywords or better yet use a state monad that has all 3
10:20:27 * danii20 Join all a new network Irc.RoIRC.ORG #roirc channels thank you happy new year!!!!!Join all
10:20:55 --- mode: glguy set +b *!*@80.96.206.110
10:21:41 <EvanR> its crazy to the extent that all our programming language technology goes to the management of context, scoping
10:21:59 <monochrom> #FirstWorldProblem
10:23:16 <carter> First scope problem
10:23:50 <EvanR> it seems very much removed from the core essentials of whats being communicated
10:24:01 <barnab> loli how is it in Haskell then?
10:24:11 <loli> Haskell uses proper lexical scoping
10:24:27 <loli> I haven't looked for dynamic variables, as a state monad is good enough for me
10:24:37 <loli> EvanR: I'm guessing that's because people assume lexical these days
10:24:56 <loli> and since they are used to it, it's very easy to think about
10:25:01 <EvanR> why would you use a state monad for accepting a custom monoid implementation
10:25:26 <EvanR> lexical scoping is definitely easy to read
10:25:36 <EvanR> and write
10:25:37 <loli> I wouldn't in Haskell as I have other tools
10:25:50 <EvanR> whats a state monad in lisp?
10:25:52 <loli> but for other instances of a dynamic variable I would use the state monad
10:25:57 <loli> you can define it yourself
10:26:00 <loli> which I really should
10:26:11 <EvanR> why not a reader monad
10:26:30 <loli> I'm not sure if that's defined
10:26:38 <EvanR> what
10:26:46 <loli> I do know there is an implementation of the state monad in the LiL library
10:26:57 <loli> but that library lacks documentation, and is thus rather annoying to use
10:27:22 <loli> I haven't really used reader much, but I don't think there is an analog? I can be confusing the reader monad
10:28:39 <EvanR> state monad is when you want to update the state during the computation
10:28:49 <EvanR> and get a final state in the end
10:29:40 <loli> yeah fair enough, there are many tools one can replace their dynamic variables with depending on their use case
10:30:32 <EvanR> great example of monumental context munging tech... backpack
10:30:49 <loli> ahh I've heard of backpack but never used it
10:31:50 <EvanR> ML modules on acid
10:34:49 <loli> sounds fun. Doesn't ML (at least SML) call their modules functors or am I thinking of a different abstraction?
10:36:08 <monochrom> They do. For parametrized modules.
10:41:24 <guillaum2> Hi. I'm wondering, what is the "recomanded" way of using template haskell. For example, do you prefer `foo :: Int -> Exp; foo i = AppE (VarE 'bar) (LitE (IntL i))` or `foo :: Int -> Q Exp; foo i = [|bar $(lift i)|]`. The first one is unreadable for complex expression, when the second one lives in `Q` and I'm failing to see if it will be an issue later.
10:44:40 <Arfed> cliched/overdone question: why is haskell not used more in cutting edge type places, like game engines?
10:46:25 <guillaum2> Arfed: for game engine, the latency and unpredicability of the garbage collector may be part of the answer.
10:47:19 <barnab> loli if you can't pass it with the monad, how do you manage it?
10:47:31 <Arfed> ahh, okey - I didn't realize haskell relied on garbage collection - is that a core part underlying other language features, or could it theoretically be swapped out with a different garbage collector?
10:48:13 <loli> barnab: for dynamic variables in general?
10:48:40 <barnab> Yes
10:48:52 <glguy_> guillaum2: the second one but without manual lift
10:49:15 <monochrom> For example suppose you want to provide mconcat :: Monoid a => [a] -> a in SML. You may do this: functor MconcatModule (M : sig  type a  val mempty : a  val mappend : a->a->a  end) = struct  fun mconcat xs = foldl M.mappend M.empty xs  end
10:49:42 <guillaum2> glguy_: how to remove the manual lift ? (offtopic: nice advant of code git repo, I learned a lot ;)
10:50:25 <loli> well dynamic variables pass fine until something above them decides to change what they mean. the transformations in the function below will still happen, but with the new definition of the variable
10:50:31 <EvanR> i am skeptical about gc being the core issue with game development
10:50:42 <monochrom> Theoretically you can always postpone garbage collection indefinitely.
10:50:45 <EvanR> i mean, look at c# and java
10:51:04 <loli> so you can say (let ((dyn-var new-value)) (function-call args)))
10:51:04 <guillaum2> EvanR: (I said part of the reason, game developers are always afraid of anything which may hurt performance...)
10:51:05 <monochrom> It is not like games written in assembly don't already expect 64GB memory anyway.
10:51:28 <loli> and in the new function-cal it will use new-value instead of whatever dyn-var is inside of the function-call
10:51:28 <glguy_> guillaum2: cool, glad you got value from it. Try: [| bar i |]
10:51:51 <EvanR> i am getting closer to a suspicion that haskell has a bad workflow for game development
10:51:52 <monochrom> Even not-cutting-edge things like web browsers behave as though they never free up memory.
10:52:12 <loli> does that answer your question, barnab ?
10:52:30 <monochrom> Or are web browsers cutting-edge too? What counts as cutting-edge, according to you? I think I never caught that.
10:52:38 <loli> if not I can get an interpreter a  colleague wrote that uses dynamic variables
10:52:52 <EvanR> can we ask about haskell and *any* game dev, cutting edge or not
10:53:10 <Arfed> well, any game dev might be too broad, as i work with a pretty cutting edge engine
10:53:22 <EvanR> i dont think it is
10:53:33 <barnab> I'm trying to re-write my function with that syntax loli
10:53:35 <EvanR> haskell broadly has almost no game development
10:53:42 <monochrom> cutting edge is too broad.
10:53:43 <Arfed> ok, well i havent got a direction in mind for the conversation, just learning, so work away
10:53:58 <monochrom> Unless you mean it means what you work on.
10:54:03 <guillaum2> glguy_: Damned, thank you, the manual lift was not necessary. Now I need to understand why, but it solves my issue ;)
10:54:11 <beaky> hello. i'm trying to factor away parts of the io monad into their own dsl that i run with "runEchoEffect", but although it prints the prompt string and reads input, it doesn't seem to putStrLn back the input. it seems to typecheck correctly so i wonder where the problem might lie in any ideas? https://ideone.com/sb3YTb
10:54:40 <monochrom> People are so anthropic.
10:54:43 <EvanR> if we get a good reason its not use for any game dev, it satisfies the cutting edge question by default, regardless of what cutting edge is
10:55:15 * hackage credential-store 0.1.2 - Library to access secure credential storage providers  https://hackage.haskell.org/package/credential-store-0.1.2 (blaze)
10:55:18 <Arfed> well, lets say you wanted to use haskell, to scale a game state (forget graphics and all, just think of a game server), across an arbitrary number of cpu cores
10:55:44 <Arfed> and lets restrict it to gameplay code, maybe with networking
10:55:53 <Arfed> well...yes, with networking
10:56:03 <EvanR> do you mean split a simulation across more than 1 core
10:56:07 <Arfed> ya
10:56:09 <monochrom> The anthropic principle for programming: "mainstream" means my niche, "real world" means my niche, "get a life" means my niche.
10:56:12 <Arfed> like an mmo, except on one computer
10:56:15 * hackage ats-format 0.1.0.15 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.15 (vmchale)
10:56:39 <EvanR> i would wonder how you would do that and maintain the intended semantics of the simulation
10:56:58 <EvanR> and the longer you think about that, no game gets created, maybe that helps answer it
10:57:43 <EvanR> but haskell has great support for concurrency and parallelism
10:58:03 <monochrom> Oh w00t someone please tell Hongwei Xi that ATS dev tools are now written in Haskell :)
10:58:08 <EvanR> so if you figured out the semantics, you could implement it
10:58:18 <Arfed> is it only limited parallelism though? i.e. splitting a mostly linear task into parallel tasks and rejoining?
10:58:47 <EvanR> if you wrote a linear task, thats not going to be parallelized
10:59:02 <Arfed> okey - nevermind i dont yet know a thing about haskell
10:59:48 <Arfed> could you do something crazy with haskell, and split a program state across several computers?
10:59:54 <monochrom> Or the two of you disagree on what "linear task" means.
11:00:18 <EvanR> as i understand it, no one has successfully made a thing that automatically parallelizes your naive code and gets any performance benefit, in anything
11:00:26 <Arfed> think of e.g. making a games gameplay code, execute in a distributed and scalable fashion
11:00:37 <Arfed> oh i understand - I would be thinking of writing from the ground up
11:00:48 <Arfed> not trying to fudge unsuited code into the task
11:00:57 <EvanR> i dont believe what you were suggesting is well defined
11:01:16 <monochrom> Yeah at this point it's management type talk.
11:01:25 <monochrom> scalable gameplay eh?
11:01:39 <monochrom> Great words to put in Powerpoint.
11:02:33 <monochrom> But look for "cloud haskell" for spreading across multiple networked computers.
11:02:43 <EvanR> in a model of an MMO i have here, it doesnt make sense to parallelize it
11:03:40 <EvanR> the game waits for either users to do actions or game objects to wake up and do actions, and some or all of these could happen simultaneously. at that time, the results are resolved in a computation
11:03:55 <EvanR> which gives a new world state and effects, which are executed
11:04:25 <EvanR> this is embarassingly not parallel
11:05:03 <Arfed> that's the kind of situation im thinking of. haskell is of no use for resolving that kind of situation?
11:05:24 <EvanR> resolving what?
11:05:31 <EvanR> my model?
11:05:35 <EvanR> being not webscale?
11:07:04 <EvanR> as i understand it, WoW areas are separated into different servers and each one acts just like that
11:07:17 <EvanR> with a local limit on directly connected players
11:07:43 <Arfed> like, if you have two game servers A and B, if game objects/users interact with each other across A and B at the same time, creating a conflicting update to the game state that has to be resolved - haskell doesn't provide anything of value for resolving a situation like that?
11:08:23 <EvanR> haskell has nice concurrency support for you to solve that problem yourself
11:08:57 <EvanR> but theres no chapter in the language report for webscale MMOs
11:09:33 <carter> Hehe.
11:10:41 <EvanR> monochrom mentioned cloud haskell which gives you something that extends threads to run on more than 1 machine, i am not sure to what extent that is usable yet
11:10:54 <Arfed> okey, hmm
11:11:17 <barnab> Sorry loli, how would you re-write my function with that syntax?
11:11:20 <EvanR> and it still doesnt directly solve your problem
11:12:04 <loli> where is your function barnab ?
11:12:51 <Arfed> ya okey - I suppose haskell wouldn't be a path worth researching for me, for that particular class of problems
11:13:54 <barnab> af  g f = let x = g x in f 0
11:14:10 <monochrom> x = g x still does not mean update
11:14:15 <barnab> f should see the new x
11:14:30 <barnab> I'm just trying to shadow it, not update it
11:14:34 <glguy> monochrom: How long until it does?
11:14:42 <barnab> So that f sees the new value
11:15:26 <monochrom> Remember lexical scoping? f won't see it.
11:15:43 <loli> barnab: well if x is dynamic and f uses x (does not let x inside, as that will change the meaning of what x is inside of f) then it shall use this new version. But this is a lexical variable
11:15:52 <loli> so that information will go away in Haskell's case
11:15:54 <beaky> so i've solved my problem by adding a `runEchoEffect` inside the Bind branch in line 25 https://ideone.com/uaclmN thanks. how would you recommend i handle things like exception handling with this kind of approach?
11:15:57 <monochrom> f sees things from the definition site, not the use site.
11:17:03 <glguy> barnab: If you want to make a value available to f, then you pass it in as a function argument
11:18:11 <loli> barnab: I have a few examples of dnyamic variables in CL if you wish to see
11:18:42 <barnab> CL = common lisp?
11:18:53 <loli> yes
11:19:23 <EvanR> dynamic scoping discussion is making me nausious
11:19:26 <loli> http://lpaste.net/361253 here is what I used to gain intuition
11:19:36 <loli> EvanR: really dislike the idea eh?
11:19:43 <loli> is it due to violating transparency
11:20:02 <EvanR> i am stuck in my haskell ways
11:20:07 <barnab> It's similar to Python; but I was trying to solve it in Haskell
11:20:16 <loli> Python has dynamics?
11:20:18 <barnab> Maybe I'm doing it the wrong way and that's it :p
11:20:29 <EvanR> python doesn't have lexical scope :(
11:20:48 <loli> Python's scoping is rather janky, I remember that much
11:21:05 <monochrom> EvanR: Oh hey did you know that delimited continuation could give you dynamically scoped variables? https://hackage.haskell.org/package/CC-delcont-0.2.1.0/docs/Control-Monad-CC-Dynvar.html
11:22:00 <EvanR> i dont understand delimited continuations yet
11:23:08 <EvanR> does Dynvar m a act like an IORef
11:23:37 <monochrom> More than that.
11:24:27 <monochrom> If you have "v :: Dynvar m a" its meaning changes according to where you use it, fulfilling dynamc scoping expectations.
11:24:39 <hoon> beaky: the unsafeCoerce is a pretty good sign you've done something fishy
11:24:50 <beaky> ah
11:25:36 <beaky> even if they're extracted from coq?
11:26:24 <EvanR> resisting the urge to see how they implemented this
11:26:28 <monochrom> Ah. Coq is not as fishy as Cod.
11:27:27 <monochrom> Oh I think we just need to understand at the coarse level of "Coq->Haskell translators add unsafeCoerce generously"
11:27:57 <EvanR> i wonder if such code will have higher performance than type safe code
11:30:15 * hackage ats-format 0.1.0.16 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.16 (vmchale)
11:31:45 <hoon> beaky: I'm not sure if this is suitable or sane but... https://hastebin.com/dorifecogo
11:33:16 <beaky> wow i didnt know you can get rid of the unsafecoerces
11:36:26 <hoon> I don't know anything about Coq
11:36:48 <hoon> so, I can't help you there
12:19:08 <dmwit> Do I still get shunned for using Data.ByteString.Char8.unpack, or is only pack ostracism-worthy?
12:22:25 <carter> Why would you? Totally sane for ascii stuff
12:24:27 <dmwit> \o/
12:25:12 <monochrom> I won't shun you. I may shun other people.
12:51:16 * hackage wreq 0.5.2.0 - An easy-to-use HTTP client library.  https://hackage.haskell.org/package/wreq-0.5.2.0 (ondrap)
12:52:17 <RedNifre> Hey there. So I thought that I should figure out what a "Transducer" is because I keep hearing it in my filter bubble... I'm now watching a Clojure talk by Rick Hickey about it (11 minutes in) and now he replaced partially applied map/filter/mapcat functions with mapping/filtering/mapcatting functions that take one argument and return a "transducer" and the composition of those functions is a transducer
12:52:19 <RedNifre> again. Isn't this all the same in Haskell given that you can partially apply everything and fmap doesn't only work on lists but also other mappables? (I haven't tested it but I guess that fmap also works on "Rx"/"Stream" stuff like pipes and conduit, right?)
12:54:11 <dmwit> Depends on your definition of a transducer. Many kinds of transducers allow significantly greater introspection than standard functions.
12:54:43 <dmwit> e.g. if your definition of transducer is finite-automata based, you can give a regex for the languages it accepts and a regex for the languages it produces; not something you can do with a plain function.
12:54:49 <RedNifre> I don't know about transducer definitions and was hoping that it means the same thing in most functional programming languages.
12:54:51 <dmwit> s/languages/language/g
12:55:36 <RedNifre> Can you give me a one sentence definition of what "Transducer" means in Haskell to keep in the back of my head while I continue watching the talk? :)
12:56:18 <dmwit> I think the answer to that is "no".
12:56:20 <dmwit> Sorry.
12:56:57 <dmwit> Even in the CS theory there's many different definitions for transducers. And once you go operational, there's all of a sudden a big collection of implementation choices that don't matter to the theory but do matter practically.
12:56:58 <RedNifre> No problem, I'll just continue to educate myself some more and come back with more concrete questions later.
12:57:54 <amalloy> when transducers had just been announced, someone wrote http://conscientiousprogrammer.com/blog/2014/08/07/understanding-cloure-transducers-through-types/, which contains: type Reducer a r = r -> a -> r;    type Transducer a b = forall r . Reducer a r -> Reducer b r
12:59:04 <dmwit> Right. So here's a great example of a definition of `Transducer` that really doesn't allow much introspection at all.
13:12:43 <RedNifre> Do Haskell's <$>, filter etc. work on everything (e.g. pipe/conduit stuff) or are there any limits?
13:13:09 <kadoban> :t filter
13:13:10 <lambdabot> (a -> Bool) -> [a] -> [a]
13:13:18 <RedNifre> okay, sure.
13:13:18 <kadoban> They are limited by their types. Like that just works on lists
13:13:24 <kadoban> :t (<$>)
13:13:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:13:41 <kadoban> fmap is a lot less limited, there's a *bunch* of Functor instances. But I'm not sure about pipe/conduit
13:13:45 <RedNifre> just like map is limited to list but we have fmap for serious mapping... is there an ffilter for serious filtering?
13:14:01 <hoon> ^ I was about to ask the same
13:14:14 <hoon> a filter for Traversables?
13:14:43 <RedNifre> silly map vs. fmap... I sure hope that there's no ffilter, freduce, fconcat, fthis.
13:14:45 <dmwit> Sorry, but you can't have filter for Traversables.
13:14:55 <dmwit> e.g. `data Two a = Two a a` can be made Traversable.
13:15:27 <RedNifre> What's the general name for this Rx/stream stuff like RxJava, Pipes, Conduit? Reactive Streams?
13:15:32 <kadoban> IIRC Traversable isn't powerful enough. I tihnk you need some wacky other typeclass. Witherable? One of the less known and less used ones that's not in base
13:15:35 <dmwit> Or, even more basically: `Identity` is `Traversable`.
13:15:46 <beauby> RedNifre: Functional Reactive Programming
13:16:00 <hoon> Yeah, I figured Traversable wouldn't fit the bill, something akin though
13:16:09 <beauby> (though apparently not exactly according to the Rx docs)
13:16:39 <kadoban> https://www.stackage.org/haddock/lts-10.2/witherable-0.2/Data-Witherable.html this looks possible, it has some decent instances. I don't know how well it works in practice.
13:17:03 <hoon> kadoban: ^ I just found that
13:17:16 <RedNifre> Okay, suppose I have a FRP thingy that emmits some values... I can filter and map those, but not with `filter` and `map` because those only work on lists... is there a filter that works on Filterables?
13:17:23 <hoon> I'm not particularly interested in using it for anything ATM, but curious none the less
13:17:41 <kadoban> RedNifre: IIRC reflex defines some of its own
13:17:48 <kadoban> Or maybe they come from some other package
13:17:51 <beauby> RedNifre: That would depend on the lib you're using, but I would expect so
13:18:40 <beginner> hi, it is normal that kaspersky detects a trojans in the installer?
13:18:52 <RedNifre> beauby that's the thing, the talk about Transducers I'm currently watching explains that the whole point is to have one for everything, like fmap works on every functor... It seems weird that there is a `filter`, but only for lists and no general Filterable in the standard library.
13:19:06 <geekosaur> beginner, which installer?
13:19:16 <beginner> core for windows
13:19:26 <beginner> the hash was correct
13:20:48 <geekosaur> unfortunately it *is* normal. Windows virus checkers use heuristic tests to detect viruses/trojans, because keying off any definite signature catches one version out of many (and most of them "mutate" these days, making exact matches worthless)
13:21:53 <beginner> so i can ignore it, ok thanks
13:21:54 <hpc> clamav documents how to write your own signatures
13:22:03 <geekosaur> this only works sanely as long as everyone uses pretty much the same languages and compilers for everything. Haskell's STG (graph reduction engine for lazy evaluation) ends up looking a lot like a common heuristic check for a virus mutator
13:22:12 <RedNifre> beginner you might want to check how old the release is.
13:22:49 <RedNifre> If it's very new it might actually have a troyan in it. If it's older somebody would probably have found the troyan already, resulting in a newer release.
13:22:51 <beginner> it is the current release
13:23:07 <RedNifre> I meant was it released today or some weeks/months ago?
13:23:24 <beginner> i downloaded the file today
13:23:30 <Phyx-> yes, karspersky seems to be throwing falls positives for the latest build
13:23:32 <RedNifre> no, when was it released?
13:23:35 <beginner> from the official website
13:23:37 <Phyx-> even on binaries that haven't changed
13:23:51 <Phyx-> false*
13:24:31 <RedNifre> I meant that it's not very likely to be an actual troyan if the release has been up for several months because somebody would have complained about it. If it was released today you might be the first person to actually get the troyan alert so it might be an actual troyan.
13:24:37 <Phyx-> it seems to be the only one though, https://www.virustotal.com/en/ for those files it "finds"  is mostly clean across the board.
13:25:25 <RedNifre> :t reduce
13:25:27 <lambdabot> Expr -> Expr
13:25:34 <RedNifre> ... huh?
13:25:35 <geekosaur> it would not have been released very recently. 8.2.2 has been out for over a month; an 8.4 prerelease is out but it's compiler only, not Platform
13:25:47 <Phyx-> someone has complain already, hitman pro (sophos) and kaspersky seem to think it's a variant of "Trojan-Downloader"
13:26:38 <Phyx-> but having trawled to the disassembly of one such flagged binary, I'm pretty confident it's clean
13:27:10 <geekosaur> the hitman one was for the 8.4 pre, wasn't it? and was *execution* heuristic, not static analysis
13:27:17 <Phyx-> also the variants they seem to flag only seem to exist in their virus database. so it very much seems like it's something they made up
13:27:28 <Phyx-> no, the hitman one was 8.2.2
13:27:34 <Phyx-> we've also had it with 8.0.2
13:28:08 <Phyx-> except it would also kill any haskell programs back then
13:31:33 <RedNifre> So if I have a "mapping" function that works on transducers, can I implement the list only "map" like `mapl f list = reduce ((mapping f (++)) [] list`?
13:31:57 <RedNifre> It looks like getting from a transducer to a concrete map function only requires the implementation of a conjoin function?
13:35:04 <amalloy> RedNifre: perhaps the Filterable you're looking for is Alternative, which has operations such as: guard, empty, (<|>)
13:35:46 <amalloy> filter f xs = do {x <- xs; guard $ f x; pure x}
13:36:09 <amalloy> although that requires monad too
13:36:51 <erisco> :t mfilter
13:36:51 <RedNifre> looks good.
13:36:51 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
13:37:06 <erisco> just sayin'
13:37:19 <hoon> there you go! ^
13:38:06 <amalloy> erisco: yes, MonadPlus seemed like the obvious constraint but i thought there might be something less powerful that still works
13:38:18 <nullie> :t filter
13:38:19 <lambdabot> (a -> Bool) -> [a] -> [a]
13:38:55 <erisco> Alternative doesn't work
13:39:09 <amalloy> nullie: if you read RedNifre's question, we were looking for a general case of Filterable. we know how to filter a list
13:39:36 <nullie> amalloy: yeah, I just wondered the same
13:40:11 <RedNifre> Heh, now Rick Hickey talks about types and that Haskeller's complained to him about it. He says the transducer type is ( (\BlackBox)^(N-1), A -> (\BlackBox)^N ) -> ( (\BlackBox)^(M-1), B -> (\BlackBox)^M )
13:41:11 <RedNifre> Where ^ means subscript, not superscript
13:41:19 <erisco> amalloy, you have a map  f :: Bool -> m ()  and a value  m Bool
13:41:45 <erisco> amalloy, so, with fmap we can get  m (m ())  and then it becomes obvious why we want Monad
13:43:28 <erisco> if the Bool was outside the context of m then you wouldn't need it
13:44:50 <shiddums> Heyo, I am pulling json data with an api call and trying to convert it into a data type. Is there a way that I can do conversions of the data as it's being assigned to that type?
13:45:14 <shiddums> I have a lot of strings that I want to convert to numbers, but they are returned as strings from the api
13:45:29 <amalloy> what is the Bool -> m () function? i was imagining we have: (a -> Bool) -> m a -> m a. we start with fmap, yielding, say, m (Bool, a). at that point we also seem pretty stuck without monad, but i don't follow the way you got there
13:46:00 <erisco> guard has the slightly more basic thinking here, but similar can be said with mfilter
13:46:43 <erisco> f :: Bool -> m ()  is a map from Bool to our type m at (), and in particular  f True = pure (); f False = mzero
13:49:04 <erisco> so, we want to take Bool in context, then map it to either zero or non-zero
13:49:37 <erisco> guard says let the non-zero value be  pure ()  and mfilter says let it be identical to argument
13:49:57 <amalloy> i see
13:50:24 <amalloy> so yes, we need at least monad, and either alternative or monadplus
13:50:37 <amalloy> (right?)
13:50:49 <erisco> MonadPlus implies Monad, Alternative does not
13:52:44 <erisco> maybe you want to consider Foldable
13:52:46 <erisco> :t foldMap
13:52:47 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
13:53:28 <erisco> > foldMap (\x -> if x `mod` 2 == 0 then [] else [x]) [1..10]
13:53:30 <lambdabot>  [1,3,5,7,9]
14:02:23 <Durbley> is installing haskell platform supposed to put cabal in my path on its own
14:03:40 <amalloy> oh, foldMap's another good one
14:04:10 <amalloy> (ping RedNifre since that's who was originally asking about a generic Filterable)
14:05:50 <erisco> you could be more generic, but I am not sure of the algebraic structure to use
14:06:49 <erisco> for example, you can filter a stream, but it is not a monoid
14:10:03 <amalloy> right, and MonadPlus works for that. it seems like there are two different approaches depending on the properties of the context
14:10:45 <amalloy> (probably more than two)
14:11:22 <erisco> I would probably consider sequences, in some general sense
14:12:54 <Durbley> can someone help me run the tests for https://github.com/data61/fp-course this
14:12:59 <Durbley> ive installed haskell-platform
14:14:17 <erisco> streams are tricky because many operations would have unbounded time and/or memory use
14:16:12 <amalloy> here by stream you mean Stream a = Cons a (Stream a), right? a list with no end
14:16:21 <erisco> yes
14:16:43 <nullie> which operations would be tricky?
14:17:55 <erisco> any which do not guarantee a result after looking at finite prefix of the stream, such as determining if an element is in the stream
14:21:09 <amalloy> Stream is a monoid if the wrapped type is a monoid, right? it's just not a very good one because mappend is vacuous
14:21:39 <erisco> and so for that matter, filter may be unproductive as well
14:22:45 * hackage cmdargs 0.10.19 - Command line argument processing  https://hackage.haskell.org/package/cmdargs-0.10.19 (NeilMitchell)
14:23:23 <erisco> what is zero?
14:24:00 <monochrom> mempty = Cons mempty mempty  OK this is confusing, I'll annotate in the next line
14:24:30 <monochrom> (mempty :: Stream a) = Cons (mempty :: a) (mempty :: Stream a)
14:24:44 <amalloy> mempty = fix (Cons mempty); mappend x y = x
14:25:22 <monochrom> But I have in mind mappend being a "zipWith mappend"
14:25:46 <erisco> that should work
14:29:15 * hackage gio 0.13.4.1 - Binding to GIO  https://hackage.haskell.org/package/gio-0.13.4.1 (HamishMackenzie)
14:31:45 * hackage uhc-light 1.1.10.0 - Part of UHC packaged as cabal/hackage installable library  https://hackage.haskell.org/package/uhc-light-1.1.10.0 (AtzeDijkstra)
14:33:19 <NickHu_> Say I wanted to write a open type family which has kind Bool, type family IsSpecial a :: Bool
14:33:32 <NickHu_> Is there any way to make that default to False?
14:33:49 <erisco> defaults and openness do not make sense
14:33:56 <erisco> but defaults and closedness do
14:34:30 <NickHu_> erisco: The problem is that users can't add to closed type families
14:34:54 <erisco> but the problem with a default is it assumes there are no more instances, which isn't an open concept
14:35:56 <NickHu_> Ok, failing that then, is there a quick way to define IsSpecial a = False for a ranging over basically all types in Prelude?
14:36:04 <erisco> there is the overloadable instance extension, though, and you might have luck with that
14:36:31 <NickHu_> Which extension do you mean?
14:36:43 <erisco> I am not sure of all the details of how it figures out overloads though ‚Ä¶ I defer
14:36:50 <erisco> OverloadableInstances I think
14:37:10 <NickHu_> Do you mean OverlappingInstances for typeclasses?
14:37:16 <NickHu_> It doesn't work for type families
14:37:23 <erisco> that sounds right
14:37:28 <erisco> why would it not work for type families?
14:38:04 <whatsupboy> hello I never seen a haskell program before, If I hate c, java nd python are there any chances i can like haskell ?
14:38:22 <kadoban> whatsupboy: It's very different from all of those, so it's worth a shot.
14:38:50 <nshepperd_> Can associated type families with a type class get a default?
14:38:53 <whatsupboy> kadoban:  i also heard haskell is some 2/3 years dedicated work so giving a shot is not so easy right
14:38:59 <erisco> see they talk about the very problem with assuming an open world is not open in the docs
14:39:02 <Tuplanolla> If you end up hating it, it will be a different kind of hate, whatsupboy.
14:39:03 <erisco> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overlapping-instances
14:39:08 <NickHu_> erisco: By design, see https://ghc.haskell.org/trac/ghc/ticket/4259
14:39:12 <glguy_> nshepperd_: yes
14:39:14 <erisco> "Overlapping instances must be used with care. They can give rise to incoherence (i.e. different instance choices are made in different parts of the program) even without -XIncoherentInstances."
14:39:18 <NickHu_> (I must admit I didn't read the full details)
14:39:35 <kadoban> whatsupboy: I doubt that long is really necessary to be productive in haskell with good learning materials. Depends where you're starting from though.
14:39:40 <NickHu_> nshepperd_: I'm pretty sure you hit the same problem
14:40:27 <NickHu_> When you come to define an associated type family which overlaps with your default it gives you the same error
14:40:32 <glguy_> nshepperd_: you still have to write out the instance declarations, it just allows you to only the type instance
14:40:35 <NickHu_> Making your default pretty weak
14:40:46 <glguy_> Omit*
14:41:10 <NickHu_> Is it possible to use template haskell for type instance declarations?
14:41:18 <glguy_> Yes
14:41:32 <NickHu_> For instance, to range over all 62 length tuples
14:41:52 <erisco> NickHu_, I don't know. That isn't official documentation.
14:41:55 <NickHu_> glguy_: Can you point me towards some documentation on that? Google doesn't bring up much
14:42:46 <erisco> it is 7 years old, at that
14:42:54 <NickHu_> erisco: see https://ghc.haskell.org/trac/ghc/wiki/NewAxioms
14:43:00 <NickHu_> It's to prevent incoherence
14:43:00 <nshepperd_> Why do you need such a type family anyway
14:43:25 <NickHu_> nshepperd_: I'm using a type-level conditional
14:43:40 <NickHu_> And I basically always want it to be false except for a few select types
14:43:48 <erisco> that is 4 years old
14:44:04 <NickHu_> erisco: That is the implementation in GHC
14:44:15 <erisco> okay, well, guess you can't then
14:44:34 <erisco> odd that the GHC docs on overlapping instances is silent on this‚Ä¶ *shrug*
14:44:56 <NickHu_> I guess it's so obscure that nobody has ever needed it
14:45:09 <NickHu_> This is one of those things that will fix itself I guess when dependent types land
14:45:42 <erisco> it is just a notational difference whether a type family is part of a type class definition, so my default thought is that what works with type classes works with type families
14:46:00 <glguy_> NickHu_: you can check it the GHC users guide and the haddocks for the template-haskell package
14:46:45 <NickHu_> erisco: It doesn't work with associated type classes either
14:46:47 <glguy_> Allowing overlap in type families would probably be a good way to introduce inconsistencies across modules in the type system
14:46:57 <NickHu_> It's designed this way to prevent type incoherence
14:47:21 <erisco> is that worse than instance incoherence? *shrug*
14:47:37 <erisco> it is a broken idea to begin with
14:47:48 <unclechu> hey guys, how could I set extra-dependency using stack-script?
14:48:32 <NickHu_> erisco: I have a feeling it that when it was implemented people still cared about making sure the type checker was decidable
14:48:43 <kadoban> unclechu: You can't. Closest you can do is define a custom snapshot and use that
14:49:23 <unclechu> kadoban: okay, thanks for the info
14:50:10 <kadoban> Custom snapshots aren't very hard though, so if you really need to you can. https://docs.haskellstack.org/en/stable/custom_snapshot/
15:01:04 <whatsupboy> can one write something like bitcoin in haskell ?
15:01:43 <exio4> yes
15:01:55 <exio4> functionalworks has a few [basic] tutorials on this stuff
15:02:19 <erisco> one day I'll figure out what all you geeks are up to
15:02:24 <erisco> or is it nerds? I don't know
15:02:27 <whatsupboy> exio4:  telling me ?
15:02:49 <erisco> yeah you‚Ä¶ functionalworks sends me emails on it all the time -.-
15:03:12 <exio4> whatsupboy: yes, it has a tutorial on writing a blockchain or something, I haven't checked 'em much though
15:03:34 <whatsupboy> functionalworks a nick or some user ? or some otehr ?
15:04:12 <erisco> it is a company / website
15:04:52 <erisco> you can also find a job there iirc
15:04:52 <whatsupboy> oh
15:04:54 <exio4> I barely check it nowadays, heavily unqualified, have been there nice jobs which don't seem to want a PhD?
15:05:25 <erisco> problem for me is I would essentially have to be willing to move anywhere in the world
15:06:35 <exio4> erisco: which doens't sound bad if you are single without children :)
15:07:18 <erisco> that makes things a lot easier, but I also just don't like to move away :P
15:08:39 <exio4> any tips on job seeking? (even if a bit offtopic, it's about potential-haskell jobs, right? :P)
15:08:51 <erisco> but if you're willing to relocate anywhere in Europe or North America or other tech places like Hong Kong ‚Ä¶ much more chances to find a Haskell job
15:09:47 <exio4> erisco: my issue is the requirements :)
15:09:58 <erisco> well because I don't want to move I just decided to take a job where I could learn something different
15:10:29 <erisco> and then FP remains a hobby, more or less
15:11:48 <erisco> put together a competently organised and edited resume & cover letter and start sending it out to as many places as you can consider yourself working
15:12:25 <erisco> mention real experiences you've had that qualify you
15:12:42 <erisco> any past jobs, projects, anything shipped or published, anything on github
15:13:11 <exio4> maybe I aim too high? I haven't had a stable job, most random programming gigs, and often in unrelated areas
15:14:11 <exio4> mostly*
15:14:21 <erisco> just keep in mind that you're not the only one applying, so that is why you need to apply to many places
15:14:51 <erisco> if you figure you have an x% chance of getting to an interview, then figure out how many applications that is before there is a >50% chance of an interview
15:15:05 <erisco> it is tough coming in cold ‚Ä¶ any references you can get help a lot
15:15:11 <Rembane> Poisson?
15:15:37 <exio4> Rembane: a good way to apply things you learn at uni!
15:15:55 <rom1504> register to linkedin and similar websites
15:16:07 <rom1504> then you can just wait to select what you like
15:16:11 <rom1504> *and
15:16:41 <rom1504> probably not in haskell though
15:17:10 <erisco> the other answer is to create your own job, and make it a Haskell job if that solves the problem
15:17:42 <Rembane> exio4: totally.
15:17:46 <exio4> rom1504: I don't mind, as long as it isn't legacy PHP or legagy C++, I said Haskell because that's where we are, and because functionalworks has haskell jobs
15:18:04 <exio4> my skills are mostly in C++ and Haskell, though, which are quite niche languages
15:18:24 <erisco> games industry likes C++
15:19:28 <rom1504> I think it mainly depends on whether you have a diploma
15:19:39 <rom1504> well it depends on the country too I guess
15:19:44 <exio4> I don't have one yet
15:19:48 <rom1504> ah
15:19:55 <rom1504> ok then I have no idea
15:19:57 <exio4> uni leaves me with way too much free time
15:20:09 <exio4> I am starting concurrent degrees just to spend my time on something
15:20:29 <erisco> what? really? oO
15:20:36 <Rembane> Which degrees?
15:20:59 <exio4> erisco: physics and teather next year
15:21:16 <exio4> well, this year, physics was last year
15:21:22 <erisco> maybe you work abnormally quickly
15:21:43 <exio4> well, we should go to -cafe I think
15:22:05 <erisco> there is a cafe? I can't subscribe to any more haskell channels
15:22:28 <exio4> -offtopic
15:24:20 <lambdaman> Argh.  Frustrated by file renaming in OS X and somehow stack or cabal caching the old name and doing a case-sensitive match causing a failure "File name does not match module name" (where they are in fact the same).  Does anyone have any clues??
15:24:54 <lambdaman> /Users/luke/Projects/psimulang/src/Lang/Codegen.hs:1:8: error:
15:24:54 <lambdaman>     File name does not match module name:
15:24:54 <lambdaman>     Saw: ‚ÄòLang.CodeGen‚Äô
15:24:55 <lambdaman>     Expected: ‚ÄòLang.Codegen‚Äô
15:25:19 <lambdaman> The only thing that changed is the "g" -> "G" in CodeGen
15:25:57 <lambdaman> I can't see how to reset whatever is cached... or indeed what part of the stack is caching it.
15:26:28 <lambdaman> The cabal file has the module name rendered correctly in other-modules.
15:29:27 <hexagoxel> lambdaman: and in Codegen.hs, what exactly comes after "module" keyword?
15:31:31 <lambdaman> @hexagoxel well the modules is actually "Lang.CodeGen" that's exactly what is after the "module" keyword, and also in the .cabal file.
15:31:31 <lambdabot> Unknown command, try @list
15:31:48 <lambdaman> well the modules is actually "Lang.CodeGen" that's exactly what is after the "module" keyword, and also in the .cabal file.
15:33:11 <lambdaman> I renamed the file from "Codegen.hs" (Lang.Codegen) to "CodeGen.hs" (Lang.CodeGen)
15:33:26 <lambdaman> I updated the cabal file
15:33:33 <lambdaman> I deleted .stack-work
15:33:45 * hackage opencv 0.0.2.1 - Haskell binding to OpenCV-3.x  https://hackage.haskell.org/package/opencv-0.0.2.1 (BasVanDijk)
15:34:17 <lambdaman> (and even tried deleting my ~/.stack directory)
15:34:43 <lambdaman> I can't seem to get whatever is caching the lowercase file name to give it up and find the new file name.
15:34:46 * hackage opencv-extra 0.2.0.1 - Haskell binding to OpenCV-3.x extra modules  https://hackage.haskell.org/package/opencv-extra-0.2.0.1 (BasVanDijk)
15:35:23 <lambdaman> I've also tried stack clean of course.
15:35:46 <hexagoxel> lambdaman: did an open editor save again under the old name or something? (wild guessing, you seem to have tried a lot already..)
15:38:17 <lambdaman> No, I've tried with the editor closed, but it only has a buffer open showing the new file name anyway.
15:38:18 <dmwit> lambdaman: I have a cunning plan. Delete CodeGen.hs.
15:38:27 <dmwit> (Or, okay, move it.)
15:38:32 <lambdaman> OK.
15:38:45 * hackage acme-mutable-package 0 - A mutable package.  https://hackage.haskell.org/package/acme-mutable-package-0 (fozworth)
15:39:25 <geekosaur> does anything else import it?
15:39:29 <lambdaman> Delete cabal entry too?
15:40:17 <geekosaur> hexagoxel, note this is OS X. filesystem is case independent by default, like Windows
15:40:30 <lambdaman> No, nothing else imports it (yet!)
15:41:10 <lambdaman> OK.  Definitely delete cabal entry, 'cause it complains about no source for that module now.
15:41:24 <beauby> Would reactive-banana be appropriate to gather states from various REST/websocket APIs and act on last states for each API upon update of one of the sources?
15:42:22 <lambdaman> Ohhh..  I lied about the import.  Yay, maybe that's it :)
15:42:31 <dmwit> lambdaman: Well. I was going to say "keep the entry, put the file back with the right name".
15:42:50 <dmwit> lambdaman: I just figured once the build system had seen that the file had disappeared it might think it ought to delete anything it had cached about that file. =P
15:43:07 <geekosaur> I noticed after it was complaijning about the .hs, if it were via the import it'd be complaining about a .hi file
15:43:20 <geekosaur> dmwit, except stack is all about caching...
15:43:40 <geekosaur> but it should not be caching the current project's *source*
15:44:30 <lambdaman> OK, I think that spurious import (which I'd forgotten about) was the problem.
15:44:38 <dmwit> I do not know enough to predict with confidence whether my cunning plan would solve the problem I thought was happening. But I figured if we were already in dead chicken territory I might as well describe my favorite goat.
15:44:42 <lambdaman> Thanks (phew)... that was driving me crazy!
15:45:52 <lambdaman> I guess the fact that OS X has the case-insensitive file system just makes this more confusing as it manages to actually find a file that matches, but it has the wrong module name of course, compared to the import.
15:46:55 <lambdaman> I thought it was somehow caching the old file name somewhere, but had hammered about everything I could think of :)
15:47:15 * hackage snap-templates 1.0.0.1 - Scaffolding CLI for the Snap Framework  https://hackage.haskell.org/package/snap-templates-1.0.0.1 (DougBeardsley)
17:41:00 <mnoonan_> I‚Äôm trying to grok what can and can‚Äôt be done with type-level naturals. Say I have an hmatrix vector.. I can use ‚Äúcreate‚Äù to convert a Vector to an ‚ÄúR n‚Äù if I statically know n, but can I do anything if n is only known at runtime?
17:41:18 <alsoStevenXL> Hi.
17:42:02 <alsoStevenXL> Anyone here use yesod? I'm trying to use their google email authentication, followin these instructions to pass the id and secret in as environmenal variables:
17:42:05 <alsoStevenXL> https://stackoverflow.com/questions/38024654/how-to-configure-google-oauth-with-client-id-and-secret-from-environment-variabl
17:42:31 <alsoStevenXL> but when i run stack exec -- yesod devel - it can't seem to find the env. variables
17:52:15 <jle`> mnoonan_: yeah
17:52:43 <jle`> you can do it with only GHC built-in GHC stuff using someNatVal
17:53:14 <jle`> someNatVal :: Natural -> SomeNat
17:53:15 <mnoonan_> hm, so is it baked in or could I make my own magic for my own types?
17:53:25 <jle`> SomeNat and someNatVal come with GHC
17:53:35 <jle`> it could be considered 'low level'
17:54:28 <jle`> mnoonan_: oh, what 'own types' do you mean
17:54:43 <jle`> hmatrix's types use the Nat kind
17:54:54 <jle`> and someNatVal gives you a Nat kind type that can be used with hmatrix
17:55:14 <jle`> hmatrix works with the baked in Nat kind that comes with GHC
17:57:15 * hackage haskell-tools-ast 1.0.0.3, haskell-tools-builtin-refactorings 1.0.0.3, haskell-tools-backend-ghc 1.0.0.3, haskell-tools-daemon 1.0.0.3, haskell-tools-cli 1.0.0.3, haskell-tools-debug 1.0.0.3, haskell-tools-refactor 1.0.0.3, haskell-tools-prettyprint 1.0.0.3, haskell-tools-experimental-refactorings 1.0.0.3, haskell-tools-demo 1.0.0.3, haskell-tools-rewrite 1.0.0.3 (lazac): https://qbin.io/b0de7bdr
17:58:11 <mnoonan_> jle`: well, I‚Äôm not sure exactly. I‚Äôm trying to flesh out generalizations of the tricks from justified-containers, which seem related to KnownNat and other such things in a way that isn‚Äôt totally clear to me yet.
18:01:36 <Axman6> alsoStevenXL: does stack exec env show the env vars?
18:02:33 <jle`> mnoonan_: the generalization of someNatVal to other kinds besides Nat is 'toSing' from singletons
18:02:54 <jle`> mnoonan_: someNatVal lets you reify Naturals and toSing lets you reify types from all sorts o fkinds
18:03:03 <jle`> (it subsumes someNatVal too)
18:03:45 <jle`> toSing, or the cps-style 'withSomeSing'
18:16:21 <alsoStevenXL> Axman6: Hi. Sorry - I was working through the problems. I think the problem was that I had a file with the secrets called .env, but it didn't export them.
18:17:08 <alsoStevenXL> I'm not well-versed in linxu, but, even though with and without 'export' they showed up in my 'echo $MYSECRET', it only worked when i had 'export MYSECRET=123'
18:19:53 <sqooq> i think my project is a failure and i'm pretty sad about it
18:20:00 <sqooq> i hope I'm just being ignorant
18:21:59 <kadoban> sqooq: What's your project?
18:22:06 <sqooq> continuous time audio
18:22:13 <sqooq> Stupid integrals ruin everything
18:22:52 <sqooq> it's integrals from 0 to t, that are annoying
18:23:04 <sqooq> because to do them efficiently you have to get meta and take note of your discretization process
18:23:31 <sqooq> but to me, at that point you're just faking continuous-time in what really amounts to a discrete time implementation
18:25:51 <sqooq> and a good sine wave implementation requires an integral, and that's foundational
18:29:44 <jle`> sqooq: needing integrals sounds very ....
18:29:48 <jle`> operational
18:29:55 <jle`> why not go denotational
18:30:04 <jle`> (like frp?)
18:30:08 <sqooq> it is frp
18:30:12 <sqooq> i'm pretty sure
18:30:59 <sqooq> Integral is in the very definition of a sine wave with potentially changing frequency: sin(2*pi* int 0 t of g(x) dx)
18:31:24 <sqooq> discrete time gets away with it by basically boiling it down to an averaging of the current sample and the last result
18:32:09 <jle`> ah your problem is at the point where you leave frp
18:32:25 <sqooq> I can do the integral directly (which is continuous time), but it gets exponentially harder through time
18:32:26 <jle`> and enter the discrete/sampled world
18:32:45 <jle`> that's the tricky part
18:33:04 <sqooq> an immediate efficient solution would be to take note of the final discretization of the continuous functions, and always just add to the last integration result
18:33:13 <sqooq> and sure enough, that makes for an efficient implementation
18:33:16 <sqooq> but
18:33:21 <sqooq> at that point it's basically discrete
18:33:28 <jle`> well
18:33:38 <jle`> the sampling/computational part is necessarily discrete
18:33:57 <jle`> the only 'continuous' part is the process of actually assembling the denotation of your sound/signal
18:34:03 <sqooq> yes, that I was ok with, as long as the continuous part was good
18:34:08 <jle`> er, if we're talking about FRP
18:34:08 <sqooq> what I'm saying here
18:34:29 <sqooq> is that one of my foundational units, has to take access of the final discretization, in order to be efficient
18:34:41 <sqooq> which imo, is breaking the continuous part
18:34:51 <jle`> ah
18:35:00 <jle`> that does break it
18:35:07 <sqooq> I mean maybe I'm being naive
18:35:29 <sqooq> tbh if I could do symbolic integration, then I would have a result that's probably even more efficient than the discrete-time solution
18:35:34 <sqooq> for most cases
18:35:44 <okily> I'm trying to install atom haskell on Mint Linux. And I'm trying to install an earlier version of GHC 8.0 since "stack ghci" installed 8.2 and I need 8.0 to install ghc-mod. I don't know how this is done. And how does that work. Does installing ghc-mod attach itself to only one version of GHC at a time?
18:35:45 <sqooq> the problem is for the not so simple cases
18:35:48 <jle`> to be fair, this no signal-base frp has been able to solve this problem
18:36:02 <sqooq> and also I'm assuming that integration of a piecewise is the piecewise of the integration of the pieces
18:36:05 <jle`> and yeah symbolic integration really only works in toy cases
18:36:22 <jle`> if only there was such a concept of automatic integration, analogous to automatic differentiation
18:36:28 <sqooq> jle`, ye, I wouldn't want to restrict the user to using things I know I can integrate symbolically
18:36:48 <sqooq> and I would hate to have some sort of checking system that does symbolic if it can, and discrete if not
18:36:58 <jle`> right now we have three main ways to compute derivatives -- numerical, automatic, and symbolic
18:37:05 <sqooq> basically this is a bunch of dookie and I'm not sure what to do next
18:37:06 <jle`> they all have their tradeoffs
18:37:14 <jle`> but for integration we only have numerical and symbolic
18:37:22 <sqooq> jle`, ye
18:37:24 <sqooq> sadly
18:37:39 <carter> There‚Äôs ways.
18:37:39 <sqooq> there's SO much integrals in audio too
18:37:45 <sqooq> not just sine wave
18:37:47 <sqooq> filters
18:37:51 <sqooq> filters of any kind
18:37:57 <sqooq> which are pretty foundational as well
18:38:07 <carter> There‚Äôs some pretty nice integration algs.  Just not as mature.
18:38:22 <jle`> i mean in DSP and stuff we represent filters in terms of their transforms and work in a transformed domain
18:38:26 <sqooq> carter, symbolic?
18:38:43 <sqooq> jle`, yeah but when you do the inverse z-transform you get a recursive signal
18:38:52 <sqooq> aka in the time domain, you don't really need integration per se
18:38:58 <sqooq> just access to the last computed result
18:39:18 <sqooq> (which is what my efficient solution essentially does, except it's still 'doing an integral')
18:39:30 <sqooq> (which is why I don't think at that point it's continuous anymore)
18:39:59 <okily> ok going to haskell-beginners bye.
18:40:27 <sqooq> conal, you here? Any thoughts on my issue?
18:42:06 <carter> sqooq: I‚Äôll take a look and get back to you on that.
18:43:04 <Axman6> alsoStevenXL: .env as far as I know isn't something that is used automatically by anything. if you ran stack exec echo $MYSECRET, that would work because the shell you're making the call to stack with is replacing $MYSECRET andnthen passing that to stack. there will be a different environment inside the stack exec call, which is why I asked if stack exec env worked
18:47:51 <geekosaur> stack exec -- sh -c 'echo $MYSECRET'
18:48:22 <geekosaur> and .env may be used by some shells (see ksh, although that's not automatic but keyed off of $ENV pointing to a file)
18:48:58 <geekosaur> conceivably also by other tools
18:56:18 <grokkingStuff> > map ($ 10) [(*3), (^2), (+4)] [30,100,14]
18:56:19 <lambdabot>  error:
18:56:19 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äò[Integer] -> t‚Äô
18:56:19 <lambdabot>                    with actual type ‚Äò[Integer]‚Äô
18:56:52 <grokkingStuff> > :t map
18:56:54 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
18:57:13 <geekosaur> (1) you included the answer, which makes it a type error
18:57:20 <geekosaur> (2) :t etc. do not want "> "
18:57:23 <geekosaur> :t map
18:57:24 <lambdabot> (a -> b) -> [a] -> [b]
18:57:54 <grokkingStuff> geekosaur: thanks! was wondering if i screwed up in trying the example.
18:58:03 <geekosaur> > map ($ 10) [(*3), (^2), (+4)]
18:58:05 <lambdabot>  [30,100,14]
18:58:13 <geekosaur> compare to the last chunk of yours
18:58:18 <grokkingStuff> got it :)
18:58:23 <grokkingStuff> > map (10) [(*3), (^2), (+4)]
18:58:25 <lambdabot>  error:
18:58:25 <lambdabot>      ‚Ä¢ Could not deduce (Num a0)
18:58:25 <lambdabot>        from the context: (Num ((a -> a) -> b), Num a)
18:58:44 <grokkingStuff> ^ why doesn't that work?
18:58:54 <grokkingStuff> why is ($) necessary?
18:59:12 <hoon_> :t ($10)
18:59:13 <lambdabot> Num a => (a -> b) -> b
18:59:24 <geekosaur> 10 is not a function
18:59:28 <hoon_> :t (10)
18:59:29 <lambdabot> Num p => p
18:59:29 <grokkingStuff> :t ($)
18:59:30 <lambdabot> (a -> b) -> a -> b
18:59:43 <geekosaur> the first parameter of map is (a -> b) i.e. a function
19:00:15 <geekosaur> (but the Num typeclass hides this; it's looking for a Num instance for functions, which is possible but not standard)
19:01:03 <geekosaur> > map ?f [(*3), (^2), (+4)]
19:01:04 <lambdabot>  mueval-core: internal error: PAP object entered!
19:01:04 <lambdabot>      (GHC version 8.2.2 for x86_64_unknown_linux)
19:01:04 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
19:01:07 <geekosaur> whoops
19:01:12 <geekosaur> :t map ?f [(*3), (^2), (+4)]
19:01:13 <lambdabot> (Num a, ?f::(a -> a) -> b) => [b]
19:02:15 <grokkingStuff> huh, that's pretty cool. I was wondering how ($) worked in this case but i get it now.
19:02:22 <grokkingStuff> it should really be written as this
19:02:29 <geekosaur> ($) is just function application made visible
19:02:36 <geekosaur> f $ x = f x
19:02:36 <grokkingStuff> > map ((flip $) 10) [(*3), (^2), (+4)]
19:02:38 <lambdabot>  error:
19:02:38 <lambdabot>      ‚Ä¢ Could not deduce (Num a0)
19:02:38 <lambdabot>        from the context: (Num (a1 -> (a -> a) -> c), Num a)
19:02:49 <amalloy> grokkingStuff: (flip ($)) if you want to do it that way
19:03:09 <grokkingStuff> > map ((flip ($)) 10) [(*3), (^2), (+4)]
19:03:11 <lambdabot>  [30,100,14]
19:03:48 <geekosaur> > map (`id` 10) [(*3), (^2), (+4)] -- now figure this one out
19:03:50 <lambdabot>  [30,100,14]
19:04:04 <grokkingStuff> right. thanks! should keep in mind that i can partially apply the second argument like this if it's an infix function
19:04:22 <geekosaur> or the first
19:04:26 <geekosaur> :t (3 +)
19:04:27 <lambdabot> Num a => a -> a
19:04:27 <amalloy> geekosaur: is that ?f feature of :t a lambdabot special or is it in some version of ghci? it doesn't seem to work for me
19:04:38 <geekosaur> ImplicitParams extension
19:04:50 <grokkingStuff> :t `id` 10
19:04:51 <lambdabot> error: parse error on input ‚Äò`‚Äô
19:04:55 <geekosaur> and arguably replaceable by typed holes, which is why I got it wrong the first time --- I wanted a _ istead
19:04:58 <grokkingStuff> :t (`id` 10)
19:04:59 <lambdabot> Num t1 => (t1 -> t2) -> t2
19:05:06 <grokkingStuff> :t (id 10)
19:05:07 <lambdabot> Num a => a
19:05:13 <grokkingStuff> :|
19:05:16 <amalloy> ah, i didn't realize i could use typed holes in :t queries
19:05:20 <geekosaur> :t id
19:05:21 <lambdabot> a -> a
19:05:37 <amalloy> oh i see, i don't have to. i can just use _f whether it's a :t query or not
19:05:46 <geekosaur> but when using `` to make it an operator, it has to take two parameters like an operator
19:06:46 <grokkingStuff> right i get it. that's pretty cool
19:07:00 <geekosaur> :t let (<+>) = id in (<+>)
19:07:01 <lambdabot> a -> a
19:07:06 <geekosaur> hm, no
19:07:20 <geekosaur> anyway infix id is also function application.
19:07:35 <grokkingStuff> with the map you're going [ (*3) `id` 10]
19:07:49 <grokkingStuff> which is really the id function applied to the function
19:08:26 <grokkingStuff> > (*3) `id` 10
19:08:27 <lambdabot>  30
19:08:34 <grokkingStuff> :t (*3) `id`
19:08:35 <lambdabot> error:
19:08:35 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
19:08:54 <geekosaur> :t ((* 3) `id`)
19:08:55 <lambdabot> Num a => a -> a
19:09:07 <geekosaur> has to be section syntax to be a complete expression
19:09:19 <grokkingStuff> right.
19:09:51 <grokkingStuff> kinda curious now if i can use foldl on a list of arguments now.
19:10:18 <grokkingStuff> instead of goin f.g.h $ a i can go foldl ($ a) [f,g,h]
19:10:34 <grokkingStuff> instead of going* f.g.h $ a,        i can go foldl ($ a) [f,g,h]
19:10:59 <kadoban> grokkingStuff: That doesn't look like the same meaning at all
19:11:24 <grokkingStuff> right got the order of the functions mixed up.
19:11:31 <grokkingStuff> instead of going* f.g.h $ a,        i can go foldl ($ a) [h,g,f]
19:12:06 <grokkingStuff> foldl ($ 10) [(*2),(+1),(*3)]
19:12:11 <grokkingStuff> > foldl ($ 10) [(*2),(+1),(*3)]
19:12:13 <lambdabot>  error:
19:12:13 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äò[a1 -> a1]‚Äô
19:12:13 <lambdabot>                       with ‚ÄòInteger -> a -> [a1 -> a1]‚Äô
19:12:58 <kadoban> > foldl (flip ($)) 10 [(*2),(+1),(*3)]
19:12:59 <lambdabot>  63
19:13:00 <grokkingStuff> hmmm, not quite
19:13:02 <kadoban> Something like that?
19:13:18 <grokkingStuff> kadoban: yeah, that's it.
19:15:04 <grokkingStuff> sweet. is that expression used anywhere?
19:15:46 <grokkingStuff> seems like it would be handy somewhere.
19:16:47 <grokkingStuff> > applyFunctionList xs x = foldl (flip ($)) x (reverse xs)
19:16:49 <lambdabot>  <hint>:1:24: error:
19:16:49 <lambdabot>      parse error on input ‚Äò=‚Äô
19:16:49 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
19:16:55 <grokkingStuff> > let applyFunctionList xs x = foldl (flip ($)) x (reverse xs)
19:16:56 <lambdabot>  <no location info>: error:
19:16:56 <lambdabot>      not an expression: ‚Äòlet applyFunctionList xs x = foldl (flip ($)) x (rev...
19:18:49 <webstrand> Is it possible to write a type definition that accepts only one data constructor of a type? For example if I wanted a function that only works on the Just form of Maybe, could this be done?
19:18:54 <grokkingStuff> yahb applyFunctionList xs x = foldl (flip ($)) x (reverse xs)
19:23:07 <d34df00d> What's my best choice library-wise if I want to read an image of unknown but common (JPG/PNG/etc) format and just get its dimensions in pixels?
19:23:24 <d34df00d> I heard JuicyPixels was the library of choice some time ago, but things might have changed.
19:25:55 <amalloy> grokkingStuff: you could fold (.) over the list [f, g, h] and then apply the result to a, if the types of f, g, and h are all the same (a -> a). but if they're not the same type you can't make a list out of them
19:30:05 <amalloy> your original approach with ($) should work too, but you want a right fold instead
19:31:31 <folded> Hello! I have a question about folds and stream fusion.
19:31:45 <folded> I am confused about the definition of foldl' which appears in here: http://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Foldable.html#foldl%27
19:32:23 <folded> I am aware that foldl' should not grow the stack, but it is defined in terms of foldr
19:32:32 <folded> Which _would_ grow the stack
19:32:47 <folded> So I suspect there is some optimization in stream fusion that I just don't know about
19:32:54 <folded> Does anyone know what's going on?
19:36:00 <Axman6> webstrand: no (well, sort of, if your type was a GADT you could
19:36:00 <glguy> foldr doesn't grow the stack
19:36:51 <folded> @glguy, how is that possible?
19:36:51 <lambdabot> Unknown command, try @list
19:37:14 <fraktor> I'd like to take a list of tuples [("ABCDE", 1), ("FGHIJ", 2) ...] and turn it into [('A', 1), ('B', 1), ('C', 1) ... ('H', 2) ... ]. What's the best way to do that?
19:37:38 <folded> glguy, is there any documentation about that?
19:37:51 <jle`> d34df00d: i still use JuicyPixels
19:38:02 <amalloy> foldr doesn't generally grow the stack. it produces a thunk, and when that thunk is forced, its second argument is another thunk that will fold the remainder of the list
19:38:07 <folded> Or are you just saying that it's lazy, so "it does not grow the stack" at this particular moment.
19:38:11 <jle`> folded: sequence
19:38:15 * hackage capataz 0.0.0.0 - OTP-like supervision trees in Haskell  https://hackage.haskell.org/package/capataz-0.0.0.0 (RomanGonzalez)
19:38:26 <jle`> * fraktor: sequence
19:38:37 <jle`> > sequence [(1,"ABCDE"),(2, "FGHIJ")]
19:38:38 <lambdabot>  error:
19:38:39 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòa0‚Äô arising from a use of ‚Äòshow_M615880700626...
19:38:39 <lambdabot>        prevents the constraint ‚Äò(Show a0)‚Äô from being solved.
19:38:44 <d34df00d> jle`: thanks!
19:38:48 <jle`> i did this wrong
19:38:55 <d34df00d> And I guess it doesn't really matter for the task of reading the image metadata.
19:38:59 <glguy> > sequence [("ABC",2),("DEF",3)]
19:39:00 <lambdabot>  ("ABCDEF",[2,3])
19:39:11 <kadoban> > concatMap sequence . map swap $ [("ABCDE", 1), ("FGHIJ", 2)]
19:39:13 <lambdabot>  [(1,'A'),(1,'B'),(1,'C'),(1,'D'),(1,'E'),(2,'F'),(2,'G'),(2,'H'),(2,'I'),(2,...
19:39:20 <folded> glguy, I'm afraid I do not understand the performance implications of what you are saying.
19:39:22 <amalloy> oh good. i was wondering how sequence was going to help
19:39:44 <jle`> > sequence (1, "ABCDE")
19:39:46 <folded> I want to get a "while loop" that strictly accumulates information
19:39:46 <lambdabot>  [(1,'A'),(1,'B'),(1,'C'),(1,'D'),(1,'E')]
19:40:15 <sqooq> everything sucks
19:40:22 <fraktor> jle`: so something involving map sequence. Got it.
19:40:26 <kadoban> > map swap . concatMap sequence . map swap $ [("ABCDE", 1), ("FGHIJ", 2)] -- I guess. Slightly unfortunate swaps
19:40:28 <lambdabot>  [('A',1),('B',1),('C',1),('D',1),('E',1),('F',2),('G',2),('H',2),('I',2),('J...
19:40:38 <folded> I think what you are saying is that foldr does not grow the stack, but it does heap allocate thunks
19:40:42 <glguy> I actually used that sequence behavior during AoC this year :) https://github.com/glguy/advent2017/blob/824bed6c07341cd9b6b91efe94fe3bdcdf37e717/execs/Day12.hs#L28
19:40:44 <amalloy> kadoban: sorta easier to do by hand imo
19:40:46 <folded> My goal is to not allocate anything
19:40:46 <jle`> > concatMap sequence [("ABC",1),("DEF",2)]
19:40:48 <lambdabot>  error:
19:40:48 <lambdabot>      ‚Ä¢ No instance for (Num [()]) arising from a use of ‚Äòe_112‚Äô
19:40:48 <lambdabot>      ‚Ä¢ In the expression: e_112
19:40:58 <kadoban> amalloy: Well, depends what "by hand" is I guess
19:40:58 <jle`> > concatMap sequence [(1,"ABC"),(2,"DEF")]
19:41:00 <lambdabot>  [(1,'A'),(1,'B'),(1,'C'),(2,'D'),(2,'E'),(2,'F')]
19:41:12 <fraktor> kadoban: Nothing says that I can't have those tuples reversed, e.g. (1, "ABCDE"), so it's no issue
19:41:26 <kadoban> amalloy: It's quite possible it'll be more readable avoiding 'sequence', sure.
19:41:30 <kadoban> fraktor: Ah, that helps a tad then
19:41:43 <fraktor> I can just do
19:41:50 <amalloy> >do {(s, x) <- [("ABC", 1), ("FGH", 2)]; c <-s; pure (c, x)}
19:41:59 <fraktor> > map swap . concatMap sequence $ [(1, "ABCDE")]
19:42:00 <jle`> that's probably less readable heh
19:42:00 <amalloy> > do {(s, x) <- [("ABC", 1), ("FGH", 2)]; c <-s; pure (c, x)}
19:42:00 <lambdabot>  [('A',1),('B',1),('C',1),('D',1),('E',1)]
19:42:02 <lambdabot>  [('A',1),('B',1),('C',1),('F',2),('G',2),('H',2)]
19:42:47 <glguy> > sequenceOf (traverse . _1) [("ABC", 1), ("FGH", 2)]
19:42:49 <lambdabot>  [[('A',1),('F',2)],[('A',1),('G',2)],[('A',1),('H',2)],[('B',1),('F',2)],[('...
19:43:02 <webstrand> Axman6: That looks interesting. Is it safe to use language options? Can I mix code that uses GADTs with libraries that don't or vice versa?
19:43:09 <kadoban> amalloy: I don't find that particularly better personally, though it might be a matter of taste.
19:43:31 <fraktor> What module is swap in?
19:43:32 <glguy> oops
19:43:33 <glguy> > sequenceOf _1 =<< [("ABC", 1), ("FGH", 2)]
19:43:34 <lambdabot>  [('A',1),('B',1),('C',1),('F',2),('G',2),('H',2)]
19:43:40 <folded> Okay, I'll refine the question. Is there a way to do a fold on lists that does not result in any stack or heap allocation? (ignoring any allocation from the accumulator function)
19:44:29 <glguy> folded: If you're OK with foldl', then you should be ok with foldr
19:44:58 <folded> I'm not sure what you mean.
19:45:16 <folded> Does "OK" mean "the performance is acceptable"?
19:45:48 <folded> My goal is to not make any unnecessary allocations.
19:45:50 <monochrom> It depends on the strictness of the binary operator you use. If it's strict, use foldl'; if it's non-strict, use foldr.
19:46:26 <monochrom> For example (&&) should be foldr, (+) for most types should be foldl'
19:46:30 <amalloy> folded: foldl' and foldr are the best we've got. i doubt if it's strictly zero-allocation, but very little is in a functional language
19:46:33 <Axman6> folded: ghc is very good at not making unnecessary allocations in particularly this use case
19:46:35 <glguy> If you want to use a strict function but be able to stop processing the list early and want to use a fold, use foldr
19:46:38 <folded> I don't have any code that purposely relies on laziness, so if I have something that is "non-strict" it is because the strictness analysis failed.
19:46:55 <monochrom> Oh, stop early? Then yeah foldr.
19:46:59 <folded> I don't want to stop early
19:47:07 <Axman6> the folds aren't where the allocation will come from, it'll be the list producers or the functions you pass to the folds
19:47:10 <monochrom> Well, stop-early is a kind of non-strictness, so meh.
19:47:27 <folded> Axman6: can you give me some docs on that claim?
19:47:30 <Axman6> folded: what are you actually doing?
19:47:35 <glguy> foldr can efficiently implement foldl', It's not clear which allocation you're getting stuck on
19:48:00 <monochrom> But seriously, study lazy evaluation for real. Recipes don't scale.
19:48:11 <Axman6> folded: you can research it yourself, by looking at optimisations like deforestation, stream fusion and build/foldr fusion
19:48:45 <monochrom> And presumably at some point you will also need to read core and asm to verify your guesses. (Even experts guess wrong 10% of the time.)
19:48:45 <folded> I am optimizing a compiler, and I'd like to avoid GC pauses as much as possible. I have shown that this has quite significant overall perf advantages. So the goal is to just use a fold that does no extra allocations.
19:49:24 <folded> My stuff is strict, I don't need to stop early. I am happy to handle cases like that by hand.
19:50:12 <folded> So I guess I'll try another question: Is there any function I can use that will guarantee the behavior of foldl in a strict language like OCaml or SML or Elm?
19:50:34 <monochrom> foldl' for the 5th time
19:51:13 <folded> monochrom: are there any docs that explain how the implementation of foldl' (which is in terms of fordr) makes that guaratee?
19:51:14 <folded> http://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Foldable.html#foldl%27
19:51:46 <monochrom> Bird's "Introduction to Functional Programming Using Haskell 2nd edition" has one.
19:52:03 <glguy>  folded: you seem to be misapplying intutition from a strict language about how foldr works to Haskell
19:52:41 <monochrom> No, glguy, they're looking at Foldable's default implementation.
19:53:10 <monochrom> which is super misleading and the wrong tree to bark at because I bet you 10 to 1 the [] instance is going to override it with more efficient code.
19:53:26 <folded> I'll check
19:53:47 <folded> (But the hackage docs link to Foldable when you click "source")
19:54:02 <amalloy> http://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.List.html#foldl%27
19:54:06 <monochrom> I think I my "No" is wrong because the two actually have no conflict.
19:54:06 <glguy> using foldr doesn't mean memory inefficient foldl'
19:54:47 <folded> No foldl in http://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html that I can see
19:55:08 <amalloy> folded: i just linked you the foldl' implementation for []
19:55:52 <monochrom> Yeah this is a whole mess of barking at the wrong fold based on wrong assumptions
19:56:40 <monochrom> > foldr (&&) undefined (False ++ repeat True)
19:56:42 <lambdabot>  error:
19:56:42 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äò[Bool]‚Äô with actual type ‚ÄòBool‚Äô
19:56:42 <lambdabot>      ‚Ä¢ In the first argument of ‚Äò(++)‚Äô, namely ‚ÄòFalse‚Äô
19:56:49 <monochrom> > foldr (&&) undefined (False : repeat True)
19:56:51 <lambdabot>  False
19:57:00 <monochrom> This uses O(1) time therefore O(1) space.
19:57:14 <glguy> or that lambabot has an infinitely fast cpu and infinite ram to allocate...
19:57:29 <monochrom> Until you actually believe that, you are not ready to predict any other space usage.
19:58:41 <amalloy> glguy: alternatively lambdabot could be the "sufficiently smart compiler" we've been waiting for since the dawn of computing
19:58:45 <fraktor> Is it a bad idea to use fromJust if I've already checked that the value is a maybe?
19:58:50 <folded> monochrom: can you point to any documentation that will help me unpack this?
19:59:17 <fraktor> *checked that the value is Just
19:59:21 <kadoban> fraktor: Checking and then using fromJust itself seems a bit broken, usually you can combine that step and it's a better idea.
19:59:30 <kadoban> Like via using pattern matching
19:59:32 <amalloy> fraktor: in principle it's fine, but you shouldn't really have to. pattern matching should be able to do both
19:59:34 <marvin3> fraktor a more common method would be to use case
19:59:56 <monochrom> http://www.vex.net/~trebla/haskell/lazy.xhtml
20:00:09 <monochrom> http://www.vex.net/~trebla/haskell/crossroad.xhtml
20:00:37 <glguy> folded: It might be interesting to you to see how once can implement foldl step by step with foldr https://www.reddit.com/r/haskell/comments/2892a9/someone_asked_me_to_derive_foldl_from_foldr_is/ci8yp1b/
20:00:53 <glguy> the difference between this and foldl' is an extra use of seq, but is the same idea
20:02:24 <fraktor> That makes a lot of sense.
20:02:27 <fraktor> Thanks guys!
20:02:56 <folded> So to make it super concrete, how would (foldr (+) 0 finiteListThatIsAlreadyHeapAllocated) be evaluated?
20:03:22 <monochrom> I thought my article has that example?
20:04:00 <folded> Knowing that I'm not working with lazy lists, I worry about going down a big rabbit hole if the answer is "We crawl to the end of the list, and then crawl to the front."
20:04:21 <folded> I'll read. I just want to make sure we are thinking of the same thing before going through it all.
20:04:22 <fraktor> kadoban, amalloy, marvin3: You guys were absolutely right. This is much cleaner.
20:04:30 <folded> Does my concern make sense?
20:04:41 <kadoban> fraktor: Cool :)
20:04:43 <monochrom> I thought my example does not use lazy list either.
20:05:07 <folded> It relied on (False : repeat True)
20:05:16 <folded> Is that not lazy somehow?
20:05:21 <monochrom> The example in my article.
20:05:32 <monochrom> OK you know what, read nothing, I'm done.
20:06:24 <folded> Sorry that my uncertainty has been frustrating. I wasn't certain my perspective was clear, but I guess it was. I'm happy to read through.
20:07:05 <monochrom> No you're just being context-free, even free of your own context.
20:07:51 <monochrom> You asked "foldr (+) 0 finiteListThatIsAlreadyHeapAllocated" so if I dared to reply it had to be about that rather than the 10-minute-old (&&) business.
20:09:05 <amalloy> folded: you can also try to reassure yourself by reading the core that ghc outputs for a case you're worried about. when you compile a foldl' call with -O2 it should be quite good
20:09:19 <folded> Okay, so for your (&&) example, it seems that it relies on this line in the docs you shared: "If the binary operation is lazy in the 2nd argument, foldr is not a hog."
20:09:33 <folded> Am I missing something?
20:10:07 <folded> I assume I am. I don't mean to sound confrontational here. I am just confused.
20:10:13 <monochrom> I would use "relies on" on a premise, not a conclusion. You quoted a conclusion, not a premise.
20:12:53 <folded> amalloy: would you say that reading core dumps is the best way to make progress on figuring out the specific code generation implications?
20:14:09 <amalloy> i'm no expert. just wanted to suggest an alternate approach since you don't seem to be making much progress with what you're getting from monochrom and glguy (and me)
20:14:43 <folded> monochrom: I think why I sounded confrontational is because it seems like that article is about the beginner intuition of (laziness + foldr) and I think the concern is more about the practical implications of stream fusion on code gen
20:14:53 <amalloy> you are afraid of poor performance of generated code despite protestations from experts (ie not me) who say it's not a problem. if you look at some generated code you can find out whether you're right
20:15:06 <folded> (knowing that GHC also does strictness-analysis)
20:15:37 <folded> amalloy: I think that is probably the way to go
20:16:34 <amalloy> and if you find cases that perform badly, you can come back with specific questions about specific code, with the generated core, and say "i was told xyz should work well, but as you can see it does not; what am i doing wrong"
20:17:47 <amalloy> i'm sure there are people here who love diagnosing stream-fusion problems
20:18:26 <folded> My code base has about 80 modules. Is there a way to get info on specific functions in that setting?
20:29:23 <folded> (1) I want to make a note about what I think derailed this conversation: I have around 20k lines of Haskell code, and I would like to default to folding over strict lists in a way that gives some "performance guarantees" about stack and heap usage.
20:29:38 <folded> (2) The resources seem to be targetted at beginners who do not get laziness yet, but I am knowledgable enough to know that this intuition is probably not very helpful for code gen (knowing about inlining, strictness analysis, and stream fusion.)
20:29:48 <folded> (3) But experts are meant to just start reading core dumps. There is a huge gap there, and it would be awesome to have some posts that help me bridge that divide.
20:31:10 <folded> I hope that if anyone knows about this topic they will write more on this "transition" range that can be really difficult!
20:31:16 <folded> Anyway, I guess I should just go back to working on this. I apologize for causing frustration with my behavior here.
20:31:23 <c_wraith> There's no way to guarantee anything
20:32:12 <c_wraith> The closest you can get is involving the NFData class, and that has performance issues even when it isn't subverted.
20:34:16 * hackage reflex 0.4.0.1 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.4.0.1 (RyanTrinkle)
20:34:34 <folded> c_wraith: I mean like a "it will only be this bad" kind of guarantee. E.g. if you use a foldr, the worst case is that X. Or if you use a foldl' the worst case is that Y.
20:34:55 <folded> I get that it's complicated with all the compiler stuff in between though, so optimizations may not hit.
20:35:14 <c_wraith> they both have arbitrarily bad worst cases, because they are passed a function that can create any sort of data structure.
20:35:47 <folded> Assuming the accumulator function is O(1) for space and time
20:36:26 <folded> Maybe it matters what the function is too for the optimizations
20:36:39 <ezyang> having spent too much time coding C++ recently, I wonder, what *really* is wrong with overlapping instances
20:36:55 <folded> It's fine. I think the only thing left is to say that it _feels_ like there could be docs that help with this middle ground.
20:37:01 <folded> Anyway, thanks everyone for the help!
20:37:32 <c_wraith> ezyang: the traditional line (which I agree with to some extent) is that it's bad when an additional import changes program behavior without any other code changes.
20:39:24 <fraktor> How can I use IO's control effects for exceptions?
20:39:49 <monochrom> I don't understand that question.
20:40:05 <monochrom> But read my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
20:41:51 <brandon__> interesting article monochrom
20:46:19 <ezyang> c_wraith: but, like, (1) if you're not using MPTCs and don't use orphans, this basically can't happen, and (2) isn't that the point!
20:48:14 <davean> ezyang: I would have figured C++ would have shown you what was really wrong with them - its part of what drove me away from C++
20:48:34 <c_wraith> There is one other issue I've seen, which is sometimes code that's written to be general sometimes won't pick up the more specific instance.
20:49:14 <c_wraith> I don't recall the details, but I know ocharles ran into some issue with that.  I recall tracking it down as the cause of why what looked like a simple refactoring broke the code.
20:52:31 <fraktor> I guess what I want is to be able to return early when I can't read a file. Maybe I'm just used to imperative programming, but adding another level of nesting for each check adds a lot of complexity (to my eye, anyway).
20:54:14 <monochrom> IO is not different from imperative programming. Unless you count IO's enhancements as differences.
20:55:37 <monochrom> And I have not seen any language that lets you catch exceptions without one more level of nesting.
20:56:00 <monochrom> OK OK I have seen one, it's C with longjmp.
20:56:52 <monochrom> OK OK I guess BASIC's "on error goto ..." counts as well.
20:57:30 <monochrom> Do you want that? Because https://hackage.haskell.org/package/BASIC exists.
20:58:45 <monochrom> But Haskell is the first language in your life where you finally have a choice between: using a catch-block like everyone else does; turning exceptions into Eithers.
20:59:11 <c_wraith> oh man.  ON ERROR GOTO NEXT.  Just pretend the error didn't happen!
21:00:47 <carter> Ok yeah those are nice.
21:01:09 <Axman6> fraktor: various monads give us much better ways to exit early than exceptions, such as Maybe and Either (and their monad transformer variants)
21:01:26 <monochrom> Anyway my article opens with exactly that example of "when I can't read a file, just quit", and I am sure my code has no more nesting than a typical Java version.
21:02:07 <monochrom> Oh wait actually it has one more level, but that's because of s/openFile/withFile/ which is actually superior.
21:02:57 <fraktor> monochrom: Perfect! That's exactly the kind of use case I have.
21:03:06 <monochrom> Because withFile contains the "finally { close the file }" so you don't have to remember to write it yourself. It is superior that way.
21:03:34 <fraktor> Is that like python's "with open(...) as f" syntax?
21:03:40 <fraktor> But a function, obviously.
21:03:52 <monochrom> No.
21:04:16 <monochrom> Well, maybe, I don't know Python, and I don't want to know.
21:04:29 <MarcelineVQ> monochrom :X
21:04:38 <monochrom> Does it automagically close the file for you? Because that's the point of withFile
21:05:18 <c_wraith> If you want a whole bunch of withFile without nesting, there's always Codensity!  (this suggestion may be dumb)
21:05:47 <lijero> monochrom, Java has try-with-resources blocks which do exactly that as of Java 7
21:06:12 <monochrom> I forgot, is "Condenity m a" equivalent to "forall r. ContT m r a"?
21:06:18 <c_wraith> yes
21:07:12 <MrFrankeistein> Hey guys, I am very new to Haskell and functional programming and been struggling with this particular task
21:07:19 <monochrom> I'm going to totally brag about this when I teach a "principles of programming languages" course this term.
21:07:26 <MrFrankeistein> Anyone available to help or give hints?
21:07:46 <c_wraith> MrFrankeistein: just ask the question.  There's usually someone around who'll take a look.
21:08:03 <c_wraith> MrFrankeistein: this channel does have over 1700 people in it, after all
21:08:18 <monochrom> With Java you have to wait for the power that be to add a new hardwired construct. With Haskell, or Scheme macros, the like withFile is user-definable.
21:08:53 <Axman6> c_wraith: how does Codensity help? I'm sure I've seen how before but can't remember how
21:08:55 <lijero> that is true, but I was just pointing out your specific example
21:09:07 <MrFrankeistein> Basically I am I am trying to write a function which takes a list and a function, and returns true if the function returns true for at least one item in the list.
21:09:13 <MrFrankeistein> For example: hasMatch(isEven,List(1,2,3,5)) will return true, but hasMatch(isEven,L ist(1,3,5)) will return false.
21:09:18 <monochrom> OK I was just bragging on a tangent.
21:10:03 <ahihi> i'm pretty sure you could write withFile as a function in java
21:10:06 <Axman6> MrFrankeistein: well the simple answer is "use any"
21:10:13 <monochrom> Actually the store front is already open! http://www.cs.utoronto.ca/~trebla/CSCC24-2018-Winter/
21:10:20 <Axman6> but if you want to learn by implementing, you can help you with that too
21:11:04 <c_wraith> Axman6: you can say something like this: handle <- Codensity $ withFile "path" ReadMode
21:11:32 <c_wraith> Axman6: And then you haven't introduced a layer of nesting
21:11:38 <Axman6> ah nice
21:11:57 <c_wraith> Of course, then you need to liftIO all your IO operations, so..  win some, lose some. :)
21:13:57 <Axman6> eh, that's no different than working in any other moderately sized app
21:14:46 <Axman6> it's funny the things we get annoyed by as Haskellers, a few characters extra typing seems to hurt much more than it would in other languages. elegance++
21:15:55 <c_wraith> the better the big things are, the easier it is to complain about smaller things
21:16:02 <Axman6> indeed
21:16:09 <MrFrankeistein> Did not quite get that explanation
21:16:33 <monochrom> This is why I tell people "just go with your heart". Because Haskell does raise your aesthetics bar, to the point you no longer need coding-style-guideline-intended-for-zombies.
21:16:54 <Axman6> :t any
21:16:55 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
21:17:07 <Axman6> > any even [1,2,3,5]
21:17:08 <lambdabot>  True
21:17:23 <Axman6> > any even [1,3,5] -- MrFrankeistein
21:17:25 <lambdabot>  False
21:18:18 <Axman6> MrFrankeistein: but if you want to know how to write any, not just that it exists, we can help you figure that out
21:19:33 <MrFrankeistein> Yes please, I would indeed prefer that
21:19:46 <Axman6> ok, how much Haskell have you written?
21:20:46 * hackage fast-combinatorics 0.1.0.8 - Fast combinatorics.  https://hackage.haskell.org/package/fast-combinatorics-0.1.0.8 (vmchale)
21:21:00 <MrFrankeistein> I started learning Haskell 3 days ago by completing a few tasks
21:21:06 <MrFrankeistein> Very new to it
21:21:14 <Axman6> have you written any functions over lists?
21:23:00 <MrFrankeistein> I did write a simple task that checks if a list has even numbers, I used filter for this particular task
21:23:18 <Axman6> it might be easier to start from scratch
21:23:45 * hackage capataz 0.0.0.1 - OTP-like supervision trees in Haskell  https://hackage.haskell.org/package/capataz-0.0.0.1 (RomanGonzalez)
21:24:03 <Axman6> so, if you had hasMatch f [], what result do you think you should get?
21:24:46 <MrFrankeistein> false, for being an empty list and not having any matches
21:25:15 <Axman6> sounds good to me, so the first part of the definition would be: hasMatch f [] = False
21:25:40 <Axman6> now we need the non-empty case. what should we do with hasMatch f (x:xs)?
21:27:18 <MrFrankeistein> I know that (x:xs) refers to the head and tail of a list, so, we should check for matches in both cenarios
21:28:26 <Axman6> how about we start with an if statement - we're making a decision based on a boolean value so that's not a bad place to start: hasMatch f (x:xs) = if ... then ... else ...
21:31:48 <MrFrankeistein> Aha good point
21:37:17 <KOle> hello
21:42:12 <jle`> anyone else here use ghc/stack on WSL ?
21:43:26 <Axman6> WSL?
21:43:36 <Axman6> MrFrankeistein: so, any ideas how to replace the ...'s?
21:47:02 <MrFrankeistein> if (<variable> x) then True else hasMatch <variable> xs, not confident though
21:47:26 <Axman6> looks good, what is <variable> though?
21:48:42 <MrFrankeistein> In that case would be f, sth like if (f x) then True else hasMatch f xs
21:49:02 <Axman6> yep. so, what's the whole function definition look like?
21:49:14 <Axman6> don't forget the base case we started with
21:53:04 <MrFrankeistein> Would it be sth like
21:53:06 <MrFrankeistein> hasMatch :: (a -> Bool) -> t a -> Bool
21:53:14 <MrFrankeistein> hasMatch p [] = False
21:53:19 <Axman6> not t a, [a]
21:53:48 <MrFrankeistein> hasMatch f (x:xs) = if (f x) then True else hasMatch f xs
21:54:07 <Axman6> yep, looks good, though the brackets in the if statement aren't necessary
21:54:19 <MrFrankeistein> The second statement should, hasMatch f [] = False, instead of p
21:54:40 <Axman6> well, since you don't even use that argument, it should really be _
21:54:46 <Axman6> hasMAtch _ [] = False
21:58:10 <MrFrankeistein> hasMatch would be the first function taking taking the list and another function, how would the second look like or how would it work?
22:04:17 * hackage wreq-stringless 0.5.2.0 - Simple wrapper to use wreq without Strings  https://hackage.haskell.org/package/wreq-stringless-0.5.2.0 (jkeck)
22:10:12 <anon136> Well this isnt really a question. But I thought maybe someone might be interested in commenting on my code. http://ix.io/nxF it's for project euler problem 2 "By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms."
22:11:31 <glguy_> Axman6: maybe you saw me mention it before, but here's a bunch of FFI marshaling getting unnested by Codensity: https://github.com/glguy/irc-core/blob/v2/src/Client/CApi.hs#L225
22:12:27 <glguy_> anon136: you could improve that by using pattern matching instead of head and tail
22:13:07 <anon136> cool ill try to figure out how to do that. thanks.
22:13:07 <kadoban> anon136: Instead of using head and tail like that, it's better to use pattern matching.  stepFib xs@(a:b:_) = a + b : xs  -- or so
22:13:39 <glguy_> anon136: if you made a lazy list of Fibonacci numbers instead of iterating up the list until you had them all, you could about needing to store the whole list in memory at one time
22:13:45 * hackage fast-combinatorics 0.1.0.9 - Fast combinatorics.  https://hackage.haskell.org/package/fast-combinatorics-0.1.0.9 (vmchale)
22:14:02 <anon136> i really wanted to find a way to not store them in memory but couldnt figure it out at the time
22:14:09 <glguy_> You could avoid*
22:14:14 <verement> anon136: mod x 2 == 0 = even x
22:15:12 <glguy_> > let fibs x y = x : fibs y (x+y) in fibs 0 1
22:15:14 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:16:15 <glguy_> Now you can use takeWhile, filter, and sum
22:16:59 <anon136> awesome. thanks for all the suggestions guys.
22:57:30 <dminuoso> Hi. Are there alternative strategies to "specialize" instances for some concrete type other than overlapping instances? i.e. right now I some some instance for `[a]` where I definitely want special behavior for `String`
22:59:49 <dminuoso> The one thing I can think of right now is to just newtype wrap that type I want special behavior for
23:00:38 <lyxia> dminuoso: does the way Show work for String count as another strategy
23:02:46 <dminuoso> lyxia: Ah, it seems like it uses the SPECIALIZE macro. :-)
23:03:02 <Marisa_> Hi, a threepenny specific question :)
23:03:47 <lyxia> dminuoso: I was referring to the showList method
23:04:11 <lyxia> dminuoso: SPECIALIZE doesn't affect behavior other than performance
23:04:26 <Marisa_> So I have it setup and running, but I want to make something like ms paint, and there are no Event [(Int, Int)] to represent a event of mousestrokes, only mouseup, mousedown, mousemove... Upon inspecting event they are some Memo and Pulse thing that I never heard of
23:04:51 <dminuoso> lyxia: Ahh, fair enough. Yeah I suppose that could work.
23:05:13 <Marisa_> So How should I 'interleave' event?
23:05:56 <dminuoso> lyxia: Im guessing SPECIALIZE is for providing optimized specialized implementations that are extensionally equivalent?
23:07:02 <dminuoso> Oh, no. Just found the relevant article, nevermind.
23:39:27 <Marisa_> BTW, the fruit url on https://wiki.haskell.org/WxFruit is a dead link... I dont have a wiki account, so can anyone remove it?
23:43:33 <lyxia> Marisa_: done
23:43:53 <Marisa_> lyxia, thx > <
23:49:24 <lyxia> From (get >> get = get) is it possible to deduce (get >>= \s -> get >>= \s' -> return (s, s')  =  get >>= \s -> return (s, s))   (get :: m s  for some monad m)
23:59:06 <lyxia> There might be some free theorem but I can't figure it out.
