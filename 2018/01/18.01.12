01:22:16 <tsahyt> When carrying around a complex environment in a Reader, what's the preferred way to be more specific in the types about what parts of the environment a function requires? I could have a (MonadReader r m, HasFoo r) constraint, but there's also this Magnify construct in lens that looks like it could be used here.
01:24:04 <merijn> tsahyt: I'd prefer not carrying a complex environment :p
01:24:12 <merijn> Are you sure you need something that complex?
01:25:10 <tsahyt> merijn: well I need the DB handle, and I need those few handles to communicate with a bunch of threads.
01:25:20 <amalloy> tsahyt: you can use something like withReader :: (r' -> r) -> Reader r' a -> Reader r a
01:25:23 <tsahyt> I don't see any other sane way to carry those to the servant endpoint handlers
01:27:04 <alp> pass them as arguments :)
01:27:30 <tsahyt> alp: that does amount to pretty much the same thing though
01:27:45 <alp> tsahyt, yes, see e.g 'server' at https://haskell-servant.readthedocs.io/en/latest/cookbook/db-postgres-pool/PostgresPool.html
01:28:00 <tsahyt> and the DB at least is required in every single endpoint
01:28:00 <alp> if some particular handlers just need one bit, then they can just take that one bit as argument
01:28:45 <phadej> tsahyt: if you are into lens, you can setup an environment as a tree, i.e. not "collection of fields" but "collection of (fields or collections ..)"
01:29:00 <phadej> tsahyt: then you won't have too many Has constraints
01:30:08 <phadej> otoh, I don't use `hoistServer` in servant myself :)
01:30:36 <tsahyt> I wanted to use my own stack anyhow, since later down the line I'll want a nice logging solution etc.
01:30:49 <tsahyt> and when I added the DB handle in a reader that made perfect sense too, because it's really needed everywhere
01:31:43 <alp> tsahyt, I've used approaches like the one you suggest in the past with success too, I was just playing the role of the person that suggests to keep it dead simple until it's really not good enough.
01:32:03 <tsahyt> alp: yep, I'm usually like that. for some reason it didn't occur to me now though
01:32:13 <tsahyt> I do not need all of the handles in all endpoints, that's true
01:32:38 <alp> phadej, what, no custom, business-domain error types?
01:32:49 <alp> you use ServantErr directly?!
01:33:04 <tsahyt> actually for now I'm also using ServantErr in my custom stack :P
01:33:05 <phadej> alp: we don't error :)
01:33:13 <tsahyt> I'll likely want to rewrite that
01:34:23 <phadej> alp: I separated most query endpoints into "read data" and "process" steps, the "read data" wrapper also does "write response" on the way back
01:35:30 <alp> phadej, oh so you could even use custom error types but they would never bubble up to appear in the type of the handlers
01:35:42 <alp> as you turn them into ServantErr before they get a chance to
01:35:59 <phadej> alp: somewhat that
01:36:27 <alp> I used to do something like that as well in the early days
01:36:33 <ertes-w> helo
01:36:36 <alp> but that was because we couldn't use custom monads =)
01:38:06 <phadej> alp: rather I'd like to have contextful Capture's
01:38:30 <phadej> so I have UserId in api type, but User in handler
01:38:53 <phadej> but it's not that bad issue, I had really need to think about it
01:41:21 <alp> that could be quite nice
01:41:21 <phadej> I have only two (one small and one big) patch to make for Cabal
01:41:21 <phadej> and deadline is 15.1
01:41:21 <phadej> so after that I'll concentrate again on servant
01:41:21 <phadej> and now I noticed this isn't #servant
01:48:51 <xpoqp> https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State#Introducing_State  -- In the description of the bind operator, can't see that k' :: a -> s -> (b, s), does this check out? Trying to derive the type myself I apply k :: (a -> State s b) to (.) which yields (k .) :: (a -> c) -> a -> State s b.
01:50:42 <merijn> xpoqp: My general recommendation for understanding State (and later StateT) is: Try and implement it yourself https://gist.github.com/merijn/098106abd45c940dab09
01:51:11 <lyxia> xpoqp: k :: a -> State s b   runState :: State s b -> s -> (b, s)
01:51:20 <xpoqp> thanks, but there's got to be an error in my thinking which is not related to state merijn
01:52:41 <xpoqp> that suddenly looked obvious..
01:53:06 <amalloy> (a -> c) -> a -> State s b is a type that can't exist, because there's no way to produce a b
01:54:49 <xpoqp> ok, thanks
01:55:10 <ertes-w> (nitpick: the type is just fine)
01:55:32 <tsahyt> ertes-w: it's a type with no inhabitants, no?
01:56:47 <tsahyt> ignoring bottom that is
01:57:01 <geekosaur> correct
01:57:10 <xpoqp> I was trying to derive looking at the type of (.) :: (b -> c -> (a -> b) -> a -> c
01:57:11 <geekosaur> this being Haskell, you don;t get to ignore bottom :)
01:57:32 <merijn> geekosaur: Sure you do!
01:57:32 <tsahyt> geekosaur: something something morally correct
01:57:43 <merijn> geekosaur: You just handwave and mumble about moral correctness!
01:57:47 <geekosaur> tsahyt, that's CT, not Haskell
01:57:57 <merijn> geekosaur: Eh, wut
01:58:13 <merijn> geekosaur: That paper is very much about programming languages and not CT
01:58:15 <geekosaur> specifically it's using CT reasoning with respect to the category Hask
01:58:57 <geekosaur> which was why Andrej was annoyed with people being *too* loose about it
02:00:20 <merijn> On a more constructive note: If I add a library dependency (as in C) to my cabal file, will cabal take care to pass the right -L and -I flags to my compiler?
02:02:27 <geekosaur> if you do it as a pkgconfig dependency, it will. otherwise, no
02:02:43 <merijn> ok, sweet
02:02:59 <merijn> Now I just need to figure out how to make cabal.project specify flags for dependencies
02:03:10 <geekosaur> (when I was on OS X, I eventually used a local hacked-up X11 package that used pkgconfig deps instead of C library deps, specifically for this reason)
02:04:28 <ertes-w> tsahyt: yeah, but the type itself is fine…  it's just uninhabited
02:04:35 <ertes-w> (ignoring bottoms)
02:10:18 <phittacus> Hello. I am looking at this answer and can't figure what's the problem with writing
02:10:36 <phittacus> Oh, sorry
02:13:02 * phittacus sent a long message: phittacus_2018-01-12_10:12:39.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/dxCTzpUbuBYxoakXcEupeXAS>
02:16:13 <phittacus> I understand that in case of using Free we will get Functor and Monad instances, while in this case I'll have to write them myself, but is there any better reason?
02:16:32 <lyxia> you're missing a Pure next constructor
02:17:12 <lyxia> I think not writing the boilerplate is the only reason
02:19:31 <merijn> tbh, with Free I always find myself writing lots of boilerplate
02:19:54 <phittacus> lyxia: okay, thank you. But what do I need `Pure next` constructor for in this case?
02:20:01 <merijn> I was talking with edwardk at some point about a Free based AST and he told me to just use a direct recursive AST and avoid the boilerplate
02:20:26 <lyxia> phittacus: how would you implement "pure :: a -> DSL a"?
02:20:39 <centril> merijn: I like the "trees that grow" version
02:23:27 <phittacus> lyxia: Well, isn't `next` parameter in my case phantom?(I should've realized this while writing the original question, sorry)
02:25:40 <lyxia> phittacus: so?
02:27:22 <phittacus> lyxia: Should've thrown it away in the first place in this case? I just can't see no point in `pure` if we stick to the code I pasted into the question.
02:29:21 <lyxia> yes
02:29:47 <phittacus> thank you :)
02:32:40 <ertes-w> merijn: https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free-TH.html
02:32:55 <ertes-w> this helps quite a bit
02:33:21 <ertes-w> but then of course it depends on what kind of boilerplate you're referring to
02:33:31 <merijn> ertes-w: When pattern matching, etc.
02:33:44 <ertes-w> merijn: you mean in the interpreter?
02:34:03 <merijn> yeah
02:34:37 <ertes-w> i see what you mean…  it doesn't bother me too much, because for the most part i use FT with an occasional fallback to FreeT
02:34:38 <phadej> I'm sure you can tweak that TH code to  generaate patterns too!
02:36:51 <ertes-w> for non-transformers you might be able to reduce that boilerplate by using F instead of Free
02:37:24 <phadej> F _
02:37:25 <phadej> ?
02:37:38 <merijn> ertes-w: Yeah, but when doing like an AST you pattern match a lot
02:39:05 <ertes-w> phadej: Control.Monad[.Trans].Free.Church
02:39:15 <phadej> ertes-w: thanks
02:39:44 <ertes-w> if you can use F/FT, most of the Free-related boilerplate including recursion disappears
02:40:05 <ertes-w> and you might even get a speed boost as a bonus on top of that
02:40:23 <merijn> phadej: TH generated patterns are going to be as ugly as writing out the boilerplate
02:41:41 <ertes-w> merijn: i suppose you mean having to write "Free (Blah …)" as opposed to just "Blah …"?
02:41:50 <merijn> Yes
02:42:37 <ertes-w> yeah, that turns into a folding pattern…  same way foldr saves you from having to pattern-match on lists
02:43:31 <ertes-w> runF action (pure ()) (\c -> case c of Blah -> …)
02:43:50 <Bish> what is "when" for?
02:44:04 <ertes-w> Bish: when b c = if b then c else pure ()
02:44:12 <Bish> what is pure for :D
02:44:17 <ertes-w> pure = return
02:44:29 <Bish> that's really equivalent?
02:44:33 <ertes-w> yeah
02:44:41 <Bish> because you return to pure world?
02:44:48 <ertes-w> (pure ()) is the action that does nothing and returns ()
02:44:54 <ertes-w> example:  main = pure ()
02:44:56 <centril> Are there any notable differences between CoArbitrary and a type that can be Hash:ed ?
02:44:58 <ertes-w> this is the program that does nothing
02:45:09 <Bish> why do you have 2 returns?
02:45:14 <ertes-w> Bish: history =)
02:45:20 <Bish> eh
02:45:28 <ertes-w> Bish: 'pure' is more general than 'return', so you should prefer it in new code
02:45:51 <centril> Bish: The Applicative type class was thought of after Monad, and in it the operation "pure" was added
02:46:36 <ertes-w> Bish: also 'pure' has nothing to do with "returning"…  (pure ()) is literally the action that does *nothing*
02:46:51 <ertes-w> main = do pure (); putStrLn "blah"  -- this does nothing and then prints "blah"
02:46:59 <ertes-w> so it prints "blah"
02:47:09 <centril> (assuming that the Monad follows the laws)
02:47:28 <Bish> still havn't got it.. but i know more than before
02:47:45 <centril> (Bind, if poorly implemented can do crazy shit with `pure ()` )
02:47:47 <ertes-w> Bish: you haven't used 'return' before?
02:47:49 <Bish> but again.. why do i need when for?
02:48:01 <Bish> ertes-w: sure i did.. but i can replace it with pure whenever?
02:48:06 <ertes-w> Bish: when wantLogging (putStrLn "some log message")
02:48:12 <ertes-w> Bish: yes
02:48:13 <centril> Bish: Always use pure, never return
02:48:30 <Bish> why literally all books out there use return?
02:48:39 <centril> Bish: they are old =) ?
02:49:02 <Bish> ertes-w: why don't i use if for that?
02:49:27 <ertes-w> Bish: 'pure' has been around for quite a while, but for historical reasons Monad was not a subclass of Applicative for a long time, so monads weren't guaranteed to have 'pure'
02:49:27 <centril> Bish: when is shorter and clearer
02:49:32 <Bish> oh that's all
02:49:35 <Bish> i see
02:49:46 <Bish> ertes-w: i am not into haskell for that long
02:49:49 <Bish> no clue what applicative is
02:49:58 <ertes-w> Bish: recently (GHC 7.10, i believe) the Applicative-Monad-Proposal went through, which introduced that dependency, so now 'pure' and 'return' are equivalent
02:50:08 <ertes-w> Bish: most books were written/started before the AMP
02:50:17 <ertes-w> and that's why they use 'return'
02:50:36 <centril> Bish:  when = \cond action -> if cond then action else pure ()
02:50:41 <ertes-w> Bish: short answer: the books use it for historical reasons, nothing else =)
02:51:23 <Bish> and when is just a shortcut tool
02:51:35 <centril> unless = when . not
02:51:46 <ertes-w> Bish: this is the definition: when b c = if b then c else pure ()
02:51:56 <Bish> so, yes
02:51:57 <ertes-w> 'when', like most things, is not a language feature, but just a library function
02:52:01 <centril> ertes-w: what's with the one letter names =) ?
02:52:31 <ertes-w> centril: b = bool, c = aCtion =P
02:52:37 <Bish> i am trying the chat server example atm
02:52:44 <Bish> and it's eating up utf8 characters
02:52:44 <centril> ertes-w: eww, hungarian notation :P
02:53:04 <Bish> ⇒⇒⇒⇒⇒⇒ becomes ⇒⇒⇒⇒⇒��
02:53:08 <Bish> is haskell good with utf8?
02:53:26 <tdammers> Bish: define "good"
02:53:28 <ertes-w> Bish: yeah, but you need to set your assumptions straight
02:53:49 <Bish> well i don't know why utf8 should be eaten up there
02:53:59 <ertes-w> if you use String, you're using the built-in localisation functionality, so which encoding is used depends on a few factors
02:54:21 <ertes-w> if you use ByteString and explicitly decode it into Text/String, then you can hard-code the encoding
02:54:21 <Bish> how can i find out?
02:54:50 <ertes-w> so the short answer is: use ByteString and encode/decode from/to Text/String =)
02:55:11 <Bish> https://wiki.haskell.org/Implement_a_chat_server
02:55:14 <Bish> what exactly is happening in there
02:55:17 <Bish> that destroys the string?
02:55:37 <ertes-w> Bish: for now i recommend that you just live with that
02:55:48 <Bish> eh
02:55:53 <ertes-w> you will learn to deal with encodings (and not to use String for networking)
02:56:31 <ertes-w> the proper way to implement such a server is to use ByteString to interact with the socket/handle, but that basically means you can't use much from that article
02:56:42 <Bish> okay
02:56:56 <tdammers> the problem isn't with Haskell, it's with IRC / telnet, which is essentially built on the assumption that ASCII ought to be good enough for anyone, and that it is thus OK to use the "character equals byte" approximation
02:57:33 <Bish> tdammers: what has this to do with irc telnet?
02:57:36 <ertes-w> Bish: the trouble here is that haskell receives raw bytes from the network, but Char is not a type for *bytes*, but for *characters*
02:57:45 <ertes-w> so yeah, it's the same problem as IRC/telnet
02:57:52 <Bish> ertes-w: yeah i think i got it already, thanks
02:58:07 <Bish> but irc/telnet does not have these problems for me?
02:58:07 <ertes-w> haskell now needs to *guess* how to interpret those bytes as characters
02:58:17 <ertes-w> and it will go with your environment's localisation settings
02:58:25 <Bish> isn't that true for any language?
02:59:02 <ertes-w> most languages, especially in the C family, just sweep the issue under the rug and give you raw bytes
02:59:23 <ertes-w> haskell doesn't do that…  you have to distinguish between raw bytes and characters
03:00:39 <ertes-w> Bish: IRC doesn't have that problem for you, because chances are you're using a modern client that defaults to UTF-8, and if the message isn't valid UTF-8 it falls back to your system encoding =)
03:00:49 <ertes-w> IRC itself isn't actually text-based
03:02:41 <ertes-w> in fact IRC is the worst example of text handling in internet protocols =)
03:02:59 <centril> and yet, we are using it :P
03:03:53 <centril> hm... so does anyone have any input on my Hash vs. CoArbitrary question?
03:04:08 <Bish> what is fix for?
03:04:11 <Bish> last question i annoy you with
03:04:19 <Bish> this chat server example does it all the tiem
03:04:30 <centril> Bish: fix is for fixpoint recursion
03:04:48 <Bish> forkIO $ fix $ \loop
03:04:53 <Bish> so.. why does he do that here?
03:06:35 <ertes-w> Bish: convenience
03:06:46 <ertes-w> Bish: consider it a way to write a loop
03:06:58 <Bish> why wouldn't it possible without the fix?
03:07:04 <ertes-w> it is
03:07:21 <Bish> why does he do it then :o ?
03:07:29 <Bish> because otherwise he couldn't pump it into forkIo?
03:07:32 <centril> convenience
03:07:34 <ertes-w> fix (\again -> do c; again) = let go = do c; go in go
03:07:45 <ertes-w> 'fix' is really just a way to avoid the 'let' here
03:07:46 <Bish> well.. if you do it.. for cenvenience.. but can do it without
03:07:53 <Bish> that rather would it make more complicated
03:08:08 <ertes-w> Bish: why do you use 'map'?
03:08:10 <centril> Bish: people do tons of stuff for convenience
03:08:15 <ertes-w> Bish: it's just foldr after all =)
03:08:31 <centril> in fact, programming languages are all about convenience and the safety you can get from it
03:08:34 <Bish> .... but how is adding something useless comfortable
03:08:35 <centril> why not just write in ASM?
03:08:59 <ertes-w> > foldr (\x -> ((x + 1) :)) [] [2,5,8]
03:09:02 <lambdabot>  [3,6,9]
03:09:06 <ertes-w> > map (+ 1) [2,5,8]
03:09:09 <lambdabot>  [3,6,9]
03:09:38 <ertes-w> Bish: would you argue that 'map' is useless, just because you could as well have used 'foldr'?
03:09:51 <centril> ertes-w: why write with foldr when you can write the recursion with a custom function yourself?
03:09:54 <Bish> well.. that i did know.. but i still don't know why he doesn't leave the "fix" out
03:09:56 <centril> :P
03:10:03 <ertes-w> centril: because that doesn't fuse =)
03:10:23 <ertes-w> Bish: to force you to learn 'fix'…  you should appreciate it =)
03:10:41 <Bish> ... wel.. but you keep saying he adds it because it's comfortable to him
03:10:44 <centril> Bish: next lesson: mfix
03:10:55 <Bish> but he can leave it without..
03:11:03 <Bish> isn't that paradox to you?
03:11:08 <Bish> the code would work without the fix?
03:11:41 <ertes-w> Bish: i'd say this much: i wouldn't have used 'fix' in a tutorial (that doesn't teach recursion)
03:12:03 <centril> that's a good point
03:12:32 <Bish> the code doesn't work without the fix.. so what is it good for
03:12:33 <ertes-w> Bish: but i do occasionally include stuff that forces readers to think or even go on a tangent to figure something out
03:12:39 <Bish> other than.. being convinient
03:12:54 <sphinxo> does ghc by itself only build changed files?
03:13:11 <ertes-w> Bish: fix f = let x = f x in x  -- if you replace it like this, it will work
03:13:20 <Bish> grr
03:13:30 <Bish> what's fixes job IN THAT line
03:13:31 <ertes-w> Bish: if it doesn't, you probably have a layout issue
03:13:32 <Bish> i posted
03:13:33 <Bish> i know what it does
03:13:38 <Bish> but i do+.t understand what it does there
03:13:40 <Bish> in that context
03:13:55 <Bish> if you replace it with it's definition it works..
03:13:58 <Bish> really?
03:14:03 <ertes-w> yes
03:14:29 <ertes-w> that's the definition after all…  again 'fix' is just a library function, and it's defined like this
03:14:31 <Bish> would've never expected that.
03:14:46 <centril> Bish: the snippet above just forks a new thread that I assume loops forever (I assume)
03:14:46 <Bish> yeah you explained all that stuff, including that map is actually foldr with benefits
03:14:50 <Bish> but still, no clue what fix does there
03:15:02 <ertes-w> Bish: welcome to the wonderful world of referential transparency, where "=" actually means "equals" =)
03:15:26 <ertes-w> Bish: do you understand the 'let' version?
03:15:32 <centril> ertes-w: hmm... doesn't _|_ + seq mess with that?
03:15:35 <Bish> centril: and that wasn't possible without the fix?
03:15:48 <centril> Bish: sure it was, but what's your point?
03:15:55 <Bish> ... what does it do there.
03:15:56 <Bish> the fix.
03:16:02 <Bish> stilla sking the question from the beginning
03:16:05 <ertes-w> Bish: first you define a recursive value 'x', and then you use that value
03:16:14 <ertes-w> let x = … x … in x
03:16:18 <ertes-w> do you understand this pattern?
03:16:21 <centril> the language is turing complete, you can do lots of things in lots of ways
03:16:26 <Bish> yes, i read about lambda calculus
03:16:26 <Gurkenglas> Bish, "forkIO $ fix $ \loop" = "forkIO $ (\loopfunction -> let loop = loopfunction loop in loop) $ \loop"
03:16:28 <Bish> i know what a fixpoint is
03:16:29 <ertes-w> connrs: nope
03:16:36 <ertes-w> err
03:16:40 <ertes-w> centril: nope
03:16:51 <ertes-w> > let xs = 1 : xs in xs
03:16:54 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:17:05 <ertes-w> now 'fix' is a way to write that without giving it a name
03:17:08 <ertes-w> > fix (1 :)
03:17:11 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:17:23 <Bish> Gurkenglas: yeah that's the definition again... but still
03:17:37 <Bish> you keep saying that the recursion would be possible without the fix, too
03:17:54 <Bish> i mean the loop lambda is calling itself
03:18:59 <Gurkenglas> "forkIO $ (\loopfunction -> let loop = loopfunction loop in loop) $ \loop -> ..." = "forkIO $ let loop = ... in loop"
03:19:13 <Bish> maybe if you paste it one more time i understand it
03:19:41 <Gurkenglas> That wasn't a straight paste
03:19:50 <Bish> doesn't matter for my sarcasm i guess
03:20:00 <MarcelineVQ> quality of answers are proportionate to quality of questions
03:20:10 <centril> MarcelineVQ: +100
03:20:19 <Gurkenglas> MarcelineVQ: -100
03:20:39 <centril> MarcelineVQ: +1000
03:21:05 <Bish> MarcelineVQ: if you can't explain it simple enough you didn't understand it well enough
03:21:16 <Bish> if we're throwing useless quotes
03:21:23 <centril> Bish: https://stackoverflow.com/questions/4787421/how-do-i-use-fix-and-how-does-it-work
03:21:29 <Bish> i know
03:21:30 <Bish> fix
03:21:32 <Bish> i know, what it does.
03:21:44 <Bish> but i don't get the job in that context
03:21:53 <centril> Bish: if you know what it does, then what's the problem?
03:22:10 <Bish> sigh. nothing, you're right, you're helping with telling me the definition over and over
03:22:13 <Bish> imt he idiot
03:22:15 <Bish> i will find out..
03:22:19 <centril> Bish: more: https://www.vex.net/~trebla/haskell/fix.xhtml
03:22:32 <Bish> yeah link few more links explaining it's definition, it helps, really
03:22:36 <centril> Bish: can you paste the link to wherever the snippet was from?
03:22:39 <Gurkenglas> Bish, attach \s to the right places there, because I can't tell
03:22:52 <centril> Bish: stop being so rude and realize that I am spending my time trying to help you
03:23:20 <Bish> yeah im thankful, but that doesn't lead anywhere, so we should just stop
03:23:27 <centril> Bish: the link?
03:23:49 <Bish> centril: the haskell chat server example https://wiki.haskell.org/Implement_a_chat_server
03:24:14 <Naughtmare[m]> I think it was this: https://wiki.haskell.org/Implement_a_chat_server
03:24:27 <centril> Bish: is it below this comment? "-- fork off a thread for reading from the duplicated channel"
03:24:57 <Gurkenglas> Bish, that specific "forkIO $ fix $ \loop -> ..." could be replaced with "forkIO $ forever $ ..."
03:25:13 <centril> yeah, using forever is clearer
03:25:18 <Bish> forever does loop a thing forever?
03:25:29 <Bish> but.. wouldn't that lambda call it self forever either way?
03:25:30 <Gurkenglas> forever x = x >> forever x
03:25:38 <centril> Bish: "forever act repeats the action infinitely." , so yes
03:25:52 <Bish> yeah that's the part that confuses me
03:25:55 <Gurkenglas> Yes, that's why you could replace one with the other. If they did different things, you couldn't
03:25:59 <Bish> because.. that loop lambda.. calls itself
03:26:25 <Bish> ohshit.. i think i got it..
03:26:28 <Bish> that's so imple
03:26:31 <Bish> now i know where i got confused
03:26:38 <centril> Bish: that's no different from a function in an imperative language calling itself
03:26:45 <Bish> well.. heres the thing
03:26:50 <Bish> i totally forgot lambdas are anonymous
03:26:53 <Bish> my bad..
03:26:59 <Gurkenglas> There was a block written on your map about going where things refer to themselves, but that block was never in the territory
03:27:02 <Bish> so forever gives the lambda.. the lambda..
03:27:07 <Bish> itself..
03:27:19 <Bish> sorry, i was ultra confused.. my bad
03:27:24 <Bish> should've known
03:27:38 <centril> Bish: OK; Good, it's all solved then?
03:27:41 <Bish> because that's what fix does ;; god im stupid
03:27:55 <Gurkenglas> How would this break if lambdas weren't "anonymous"?
03:27:55 <Bish> yes
03:28:33 <Bish> i mean.. can functions call itself in haskell?
03:28:35 <Bish> i don't know
03:28:51 <Bish> i expected the lambda to magicially know what "loop" is
03:29:11 <Bish> like fun loop() {loop();}
03:29:24 <Bish> i didn't see/forgot that it is fun(loop){loop();}
03:29:46 <Gurkenglas> \loop introduces the argument. If one could refer to loop outside that introduction, why would the language have introduction syntax? Just use anything anywhere
03:30:04 <Bish> yeah that's the point i was missing
03:30:10 <Bish> i simply didn't get loop was a param to the lambda
03:30:12 <sanitymug> that is not lamdba in terms of anonymous function... second one is, then you need fixexd point operator
03:30:15 <Bish> somehow i thought it's the name of the lambda
03:30:46 <Gurkenglas> Ah, like a label in goto syntax. I see the confusion now I think
03:30:55 <Bish> yeah.. but i should've known..
03:31:11 <Bish> still really confusing to beginners trying haskell. i mean do you expect them all to learn lambda calculus?
03:31:21 <Bish> shouldn't bits like this abstracted awayh
03:31:31 <centril> Bish: I wouldn't teach fix to a beginner
03:31:47 <Bish> i would figure that many people start with this chat server example ^^
03:32:12 <centril> the haskell wiki is in a sorry state
03:32:19 <centril> other resources are usually better
03:33:56 <centril> lyxia: so... is there a particular reason why CoArbitrary isn't just a Hash class instead where you can hash a value and then perturb the RNG with the hash value as the seed?
03:34:19 <mniip> centril, what if the input is a function
03:34:54 <centril> mniip: oh right, functions are themselves CoArbitrary
03:35:42 <centril> mniip: thank you - that is an excellent counter-example
03:36:08 <Bish> is thread "main" gets run it, also a green thread?
03:36:26 <Bish> or is it a real os thread?
03:36:52 <centril> Bish: haskell calls "green threads" sparks, and they are ultra light
03:36:54 <centril> http://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Concurrent.html#v:forkIO
03:37:09 <Bish> okay, does main gets run in a spark?
03:37:21 <centril> don't think so
03:37:37 * hackage yam-app 0.1.3, yam-transaction-odbc 0.1.3, yam-servant 0.1.3, yam-job 0.1.3, yam-transaction-postgresql 0.1.3, yam-app 0.1.4, yam-job 0.1.4, yam-servant 0.1.4, yam-transaction-postgresql 0.1.4, yam-transaction-odbc 0.1.4, yam-job 0.1.5, yam-app 0.1.5, yam-transaction-odbc 0.1.5, yam-servant 0.1.5, yam-transaction-postgresql 0.1.5 (leptonyu): https://qbin.io/5u5e3l8
03:37:44 <mniip> centril, you could try rolling your own [Co]arbitrary
03:37:52 <Bish> so most likely green threads really run parallel to main?
03:37:59 <Bish> assuming you have multiple cores
03:38:18 <centril> Bish: an OS process has to be spawned somewhere =)  of course you can call `main` inside another function, but that seems weird
03:38:56 <centril> Bish: GHC will compile a program that will schedule the green threads on an N:M basis on real OS threads
03:39:02 <Bish> that was really impressive when reading about "warp"s performance
03:39:21 <Bish> i read about how fast it is.. and how they accomplished that
03:39:35 <centril> mniip: that's exactly what I'm trying to do :P  https://github.com/Centril/proptest-arbitrary/blob/master/src/coarbitrary.rs#L52-L56
03:39:45 <mniip> class Numbered a where gimme :: Integer -> a
03:39:59 <Bish> and their blog says "by using ghc, lol"
03:40:10 <centril> Bish: link?
03:40:17 <Bish> can't remember, trying to find
03:40:38 <Bish> https://crypto.stanford.edu/~blynn/haskell/warp.html
03:40:46 <Bish> How do we get green threads in Haskell? By doing nothing! The runtime system (RTS) of GHC includes an efficient tunable user-level thread scheduler and plain Haskell code automatically runs in green threads.
03:41:09 <mniip> class CoNumbered a where pick :: a -> (Integer -> b) -> (Integer -> b)
03:41:10 <Bish> that really impressed me.. and got me into learning haskell
03:41:12 <tdammers> green threads are super suitable for writing web servers
03:41:14 <MarcelineVQ> centril: are you sure green threads are sparks? I didn't think they were related and that sparks were for parallel tasks rather than concurrent
03:41:23 <mniip> you could even require a law:
03:41:31 <mniip> (gimme k) (gimme k) = gimme k
03:41:40 <tdammers> but warp does a few other things right, too, and it has the advantage of being able to define rigidly what the payload application can and cannot do
03:41:50 <mniip> I don't think Arbitrary does that but it's a cool law
03:41:53 <centril> mniip: wait... isnt't gimmie :: Integer -> a  "CoHash" ?
03:42:03 <mniip> sorta
03:42:25 <mniip> enumeration, cohashing, you name it
03:42:29 <tdammers> also, lazy evaluation means that when Warp decides that it doesn't need something the application hands it, then that something doesn't even get evaluated
03:43:14 <centril> MarcelineVQ: I thought sparks were just Haskell's particular name for green threads according to how haskell does them... green theads just means scheduling N logic threads on M OS threads
03:43:23 <MarcelineVQ> I don't think they are
03:43:48 <centril> MarcelineVQ: well sparks are used for N:M scheduling, no?
03:44:24 <centril> MarcelineVQ: https://en.wikipedia.org/wiki/Green_threads#Green_threads_in_other_languages
03:44:29 <centril> a link to haskell there
03:44:41 <centril> and Golang, which makes me sad
03:44:53 <cocreature> afaik sparks are used for multi-threading outside of IO, i.e., `par`. afaik they are not involved if you do forkIO
03:45:17 <centril> cocreature: oh, so haskell has 2 green thread models?
03:45:30 <linduxed> would verifying that a monad conforms to monad laws primarily be done with unit tests, or are there other methods for enforcing these?
03:45:42 <linduxed> would dependent types potentially help?
03:45:50 <cocreature> centril: sparks sit on top of green threads afaik
03:45:58 <cocreature> but I’m really the wrong person to ask about this :)
03:46:11 <centril> cocreature: does Marlow hang in these channels :) ?
03:46:26 <MarcelineVQ> sometimes, jaffacakes iirc
03:46:29 <cocreature> he is sometimes in #ghc but not particularly often
03:46:46 <centril> I guess I could just ask John or Mary sometime
03:48:14 <merijn> centril: Have you read Simon's book?
03:48:33 <centril> merijn: Marlow? Not yet
03:48:52 <merijn> centril: It covers all that sorta stuff too
03:48:53 <centril> I took a course in Parallel functional programming with Hughes and Sheeran @ Chalmers
03:49:04 <centril> REPA, map-reduce, etc.
03:49:55 <MarcelineVQ> looking at the rts code, a spark does seem to run on a Capability so it's the same underlying mechanism for green (forkIO) threads and sparks.
03:50:27 <centril> MarcelineVQ: id be surprised if it wasnt like that
03:51:57 <Bish> there was also something to tell pure functions they can run in parallel, right?
03:52:00 <Bish> par or something?
03:52:06 <cocreature> yep par
03:52:16 <centril> Bish: but don't use par manually =)
03:53:20 <Bish> centril: why does make a link to golang make you sad?
03:53:25 <Bish> don't they use greenthreads?
03:53:31 <centril> Bish: Golang makes me sad.
03:54:02 <centril> It's not a language I wish to be associated with
03:54:09 <Bish> i don't know, it has some cool features.. doesn't it?
03:54:18 <liste> go is the antithesis of haskell
03:54:21 <Bish> i've heard some talks about.. their protocol definition
03:54:27 <Bish> liste: hows thath
03:54:38 <MarcelineVQ> centril: Right, but it's not quite correct to say a spark is a green thread is what I mean when I mention that. a spark is something more specific, enough so that the rts and profiler treats it differently
03:55:02 <centril> MarcelineVQ: ah, that's fair =)
03:55:05 <liste> Bish: go explicitly rejects all programming language research after the 60's-70's, and limits abstraction capabilities
03:55:27 <MarcelineVQ> centril: I'd love if someone who knew more suddenly stumbled in and set us straight though :D
03:55:58 <centril> Golang also seems to reject that correctness matters
03:56:05 <centril> but what I dislike most about Golang is Rob Pike.
03:56:07 * hackage accelerate-fourier 1.0.0.3 - Fast Fourier transform and convolution using the Accelerate framework  https://hackage.haskell.org/package/accelerate-fourier-1.0.0.3 (HenningThielemann)
03:56:11 <liste> Bish: and Haskell is also an active research language, and expands abstraction above and beyond what mainstream languages do
03:56:23 <tdammers> I just realized today that the success of languages like PHP, Python, or Go, can easily explained once you realize that the majority of programming language users out there are not career programmers, especially not when they start learning a programming language
03:56:35 <tdammers> be explained*
03:56:50 <centril> tdammers: it's also about hype and being driven by eras and certain projects
03:57:19 <centril> Go is driven by hype, PHP was driven by the need for simple tools for the web - python was driven as a need for a bash replacement
03:57:23 <centril> etc.
03:57:31 <centril> MarcelineVQ: =)
03:57:44 <merijn> Python was driven by Amoeba :p
03:57:51 <tdammers> centril: yes, that too, but they also did one thing "right": postpone the need for rigorous thinking
03:57:56 <MarcelineVQ> correct you say?  why be correct when you can use a restricted enough vocabulary that it would be impossible to say something wrong
03:58:01 <Athas> Cool, is accelerate-fourier a pure Accelerate FFT?
03:58:14 <Athas> I have to try that out.
03:58:39 <centril> tdammers: postpone the bugs until production =)
03:59:14 <tdammers> centril: I'm not talking about career programmers here; for those, Go or Python are outright bad languages
03:59:18 <centril> tdammers: but I don't see why a language like Haskell or Rust couldn't be successfully taught as a first language
03:59:35 <merijn> centril: It can
03:59:35 <tdammers> because they demand that you think like a programmer
03:59:37 * hackage quickcheck-instances 0.3.16.1 - Common quickcheck instances  https://hackage.haskell.org/package/quickcheck-instances-0.3.16.1 (phadej)
03:59:58 <centril> tdammers: eh... lots of my fellow CS students got on the Golang hype train
04:00:13 <centril> tdammers: Haskell demands more that you grasp some discrete math
04:00:14 <tdammers> "CS student" doesn't imply "programmer"
04:00:20 <tdammers> nah
04:00:28 <tdammers> you can learn haskell just fine without any math
04:00:30 <centril> tdammers: not much, just a little
04:00:30 <liste> merijn: do you have success teaching Haskell to a non-programmer? :)
04:00:33 <tdammers> it helps, but you don't need any
04:00:43 <tdammers> you do need to start thinking like a programmer though
04:00:51 <centril> tdammers: well, I guess you can learn discrete math by haskell =)
04:00:54 <merijn> liste: My girlfriend is currently at the semigroup/monoid chapter of Haskell Book
04:00:55 <tdammers> maybe
04:00:59 <tdammers> not the point though
04:01:03 <dibblego> liste: Yes.
04:01:23 <liste> merijn: nice! has she enjoyed it?
04:01:25 <merijn> liste: But honestly, that's even without teaching her, that's just her doing it on her own and me mostly helping with system troubleshooting things
04:01:30 <tdammers> point is, when you learn haskell, one of the first things you are confronted with is the harsh reality of an unforgiving rigorous system
04:01:40 <tdammers> in its incarnation 'ghc' or 'ghci'
04:01:41 <dibblego> hundreds of people, including my two children
04:01:51 <liste> dibblego: awesome!
04:01:54 <merijn> liste: So far yeah, but I think she's getting a bit bored, so I'm trying to rush her through the next few Functor/Applicative/Monad chapters so she can actually *do* stuff
04:02:04 <centril> tdammers: pretty forgiving to me - just sprinkle undefined until you match up the types right
04:02:05 <tdammers> doesn't mean you can't teach it to non-programmers; of course you can
04:02:10 <centril> it's not like it is Agda
04:02:20 <tdammers> centril: it's not like in Python either
04:02:25 <centril> tdammers: ;)
04:02:25 <dibblego> There is no more suitable first language than Haskell, that I know of.
04:02:39 <tdammers> in Python, you write "1 + 1", and it says "2", and you say, OK, so "+" means "add"
04:03:04 <centril> dibblego: what's your experience teaching haskell?
04:03:06 <tdammers> and then you write "Hello" + "world", and it says "Helloworld", so you conclude that "+" actually means "add"
04:03:43 <tdammers> iow., Python has confirmed your intuition that your vague concept of "adding", derived from your everyday usage of the English language, holds up
04:03:44 <centril> I guess it can get difficult when you begin with the more category-typey things
04:03:45 <dibblego> centril: I am teaching 80 people next week in Sydney, 50 the week after in Melbourne. I have been doing it for 15 years. My children started about 8 years ago. They are in high school. I am paid by my government to teach FP using Haskell.
04:04:11 <centril> dibblego: At university or?
04:04:31 <dibblego> centril: No, government research lab.
04:04:38 <centril> dibblego: That sounds like a wonderful life =)
04:04:42 <tdammers> try the same in Haskell, and it'll blow up, because "+" actually refers to addition, and not even the addition of numbers, reallyu
04:04:48 <mniip> tdammers, but how about adding an element to a set
04:04:49 <dibblego> I teach industry programmers, I refuse to teach at university.
04:04:57 <mniip> 3 + set([4, 5])
04:04:59 <mniip> oh no
04:05:03 <dibblego> centril: we are hiring :)
04:05:39 <centril> dibblego: haha :P I have to finish university first and then Sweden and Australia are pretty far apart =)
04:05:56 <mniip> earth is pretty small
04:05:56 * centril would be delighted to work at Mozilla Research
04:06:02 <dibblego> if you conclude that + means add based on that, I would be tempted to immediately run the Wason Rule Discovery test
04:06:04 <tdammers> mniip: well, as I said, it's a lie, and those lies do come back at you eventually, which is why Python is a bad language for professionals, but by the time you figure that out, you're already 5-10 years into your career, and thousands of others with you, and you keep confirming each other's Stockholm Syndrome
04:06:30 <centril> tdammers: the Num typeclass could have been defined differently
04:06:38 <dibblego> centril: aeroplanes are fun, we have those here, I fly them.
04:06:50 <centril> you could have just had (+) be an operation in Semigroup instead
04:07:17 <mniip> tdammers, I, too, have become very picky in languages after learning haskell
04:07:26 <centril> mniip: me three.
04:07:38 <centril> dibblego: :P
04:07:40 <dibblego> We are fixing python.
04:07:55 <centril> Right now I'm mostly doing language design and working on property based testing improvements for Rust
04:07:56 <mniip> any language where + works on something more than integers, floats, and strings, without a consistent way to add more
04:07:58 <tdammers> dibblego: the target audience I'm talking about here is people who aren't very interested in programming per se, but just want to get stuff done for their main gig - sysadmins, data scientists, researchers, EE folks, CG artists, you name it - anyone who needs programming as a small part of their job
04:08:17 <dibblego> tdammers: I know these people well, as yes, they are prone to biases.
04:08:25 <mniip> is automatically "bad"
04:08:37 <dibblego> mniip: introducing java, scala, c# and many others...
04:08:43 <mniip> tup
04:08:47 <mniip> yup*
04:08:52 <tdammers> dibblego: my point is, they shouldn't be using Python either, but it's oh so tempting, and they are blissfully unaware of the problems
04:08:56 <mniip> wait, uh, what can + do in java?
04:09:07 <centril> I think this is pretty nice:  https://doc.rust-lang.org/nightly/std/ops/trait.Add.html
04:09:08 <dibblego> tdammers: we are working specifically on this problem.
04:09:13 <mniip> besides adding integral types, and invoking toString and concatenating strings
04:09:15 <dibblego> mniip: "abc" + "def"
04:09:18 <tdammers> dibblego: "we" being who?
04:09:21 <dibblego> mniip: "abc" + 6
04:09:22 <tdammers> dibblego: and how?
04:09:26 <centril> I think this is how it should have been defined in Haskell
04:09:26 <dibblego> tdammers: http://qfpl.io/
04:09:31 <mniip> well, that fits within what I described
04:09:41 <dibblego> tdammers: how is difficult to answer summarily.
04:09:57 <dibblego> mniip: "abc" + null // :)
04:10:03 <tdammers> dibblego: "Encapsulation, data hiding, modularity" is where you're going to lose that audience
04:10:11 <dibblego> tdammers: incorrect
04:10:12 <mniip> okay String.valueOf
04:10:15 <mniip> or whatever
04:10:31 <dibblego> tdammers: I will answer your question with code.
04:10:47 <dibblego> in approximately 6 months
04:10:57 <centril> Learning Java patterns was such a painful experience... I can't say I remember 10% of them now... and it was way harder than understanding functors, monads, etc.
04:11:04 <tdammers> dibblego: you don't have 6 months. You have 10 seconds. vOv
04:11:05 <centril> and they call Haskell elitist...
04:11:17 <dibblego> tdammers: I challenge anyone else on the planet to achieve it sooner.
04:11:34 <tdammers> dibblego: capture the target audience? python already has.
04:11:37 <mniip> what was the question
04:11:43 <centril> mniip: idd..
04:11:43 <dibblego> tdammers: No. Fix python.
04:12:11 <dibblego> This person knows what we are doing, and gives a slightly less summarised description, https://brianmckenna.org/blog/polymorphic_programming
04:12:26 <tdammers> dibblego: oh, ok. I assumed you were talking about *replacing* python with something sane. Teach the target audience a proper language.
04:12:37 <dibblego> tdammers: no, screw "languages" altogether
04:12:39 <mniip> centril, expand?
04:12:46 <dibblego> stringly-typed programming be gone
04:13:06 <dibblego> tdammers: I work with lots of people who use python, research scientists, etc.
04:13:14 <tdammers> dibblego: I have read that
04:13:23 <mniip> dibblego, what but all foundational computation models are stringy
04:13:28 <mniip> okay no
04:13:32 <mniip> nevermind actually
04:13:37 <tdammers> if you ask me though, I wonder how this is any different from inventing a new programming language
04:13:39 <dibblego> mniip: System F
04:13:42 <mniip> minsky machines
04:13:54 <dibblego> tdammers: I will only answer that with code.
04:13:55 <centril> mniip: on?
04:14:01 <mniip> centril, idd=?
04:14:06 <centril> mniip: indeed
04:14:15 <dibblego> I refuse to invent a new programming language.
04:14:35 <tdammers> if not a programming language in the wider sense, then what?
04:15:08 <dibblego> note that Brian has participated on many FP projects in many languages, such as java, scala, haskell, python, ruby, objective-c
04:15:19 <mniip> dibblego, http://images.slideplayer.com/15/4689676/slides/slide_2.jpg
04:15:23 <dibblego> as have all those who are fed up with "inventing programming languages"
04:15:36 <Bish> what is liftIO for?
04:15:38 <Bish> i didn't get that one
04:15:41 <dibblego> mniip: I am not in that game.
04:16:51 <mniip> Bish, when you have a compound monad where executing IO is one of the things it can do, it will be an instance of liftIO
04:16:51 <centril> Bish: liftIO lifts an action in the IO monad into an action in some other monad
04:17:16 <centril> (that usually has an IO component in the base)
04:17:29 <Bish> hm that doesn.t tell me much yet
04:17:35 <Bish> i think i need to do more haskell myself
04:18:20 <centril> Bish: https://wiki.haskell.org/Lifting
04:18:59 <centril> MonadIO is a specialization of class MonadTrans t where lift :: Monad m => m a -> t m a
04:22:06 * hackage system-info 0.1.0.13 - Get information about CPUs, memory, etc.  https://hackage.haskell.org/package/system-info-0.1.0.13 (dtaskoff)
04:40:02 <angerman> I'll be around a bit longer if someone has questions regarding the cross compiler
04:42:55 <MarcelineVQ> the adventures of Angerman and his Cross compiler
04:43:00 <merijn> hmmm
04:43:21 <angerman> MarcelineVQ: should I look for book deals? :-)
04:43:32 <k0ral> Hello guys, at the moment I'm having difficulty finding an excuse to write Haskell, and I need my fix, so would you have project ideas ? Preferably a program (not a library), either from scratch, or an existing one that isn't maintained anymore
04:43:40 <MarcelineVQ> It's a timeless story for all ages
04:44:59 <angerman> MarcelineVQ: haha
05:00:20 <electrocat> angerman: the binary distribution links time out
05:00:53 <angerman> O_o
05:00:58 <angerman> which one did you try? all?
05:01:01 <angerman> let me check.
05:01:14 <electrocat> yes all of them
05:01:25 <electrocat> a while ago i would get 404 not found
05:01:32 <electrocat> now i get varnish timeouts
05:02:59 <angerman> electrocat: wow. let's see where that broke.
05:04:46 <merijn> I don't suppose I can sucker someone into writing a nice ghcid plugin for vim? >.>
05:06:44 <angerman> electrocat: great, looks like the fastly <-> vps connection is down. great.
05:07:03 <k0ral> well, vim isn't my brand of vodka
05:07:28 <Phyx-> oh noes.. you're an emacs guy? :)
05:07:58 <electrocat> angerman: :S
05:08:02 <angerman> electrocat: can you try again?
05:08:13 <Bish> ed
05:08:48 <angerman> electrocat: I see fastly hitting the server occationally.
05:09:00 <electrocat> angerman: waiting.. probably gonna time out again
05:09:24 <electrocat> yep, stille timeout
05:09:27 <electrocat> still*
05:10:06 <Phyx-> Bish: you just like to be different :)
05:10:27 <Bish> now i am not using ed
05:10:36 <Bish> my editor is actually a brainfuck interpreter
05:10:43 <k0ral> emacs guy mainly, trying atom right now
05:11:07 <metahumor> Ed, man! man ed
05:11:10 <angerman> electrocat: guess I should get myself some s3 bucket or something.
05:11:22 <angerman> electrocat: ghc-8.4.0.20180109-aarch64-linux-android.tar.xz might work :(
05:11:44 <electrocat> angerman: yes!
05:11:46 <electrocat> it's working :)
05:11:53 * Uniaika hails from neovim
05:12:08 <merijn> Sadly I seem to have broken the brittle ghc-mod setup I had for use with new-build again and besides ghcid I'm not aware of anything that plays nice with new-build...
05:12:50 <MarcelineVQ> merijn: you could craft a plugin that talks to ghci directly and be a hero to vim users, it's got all the features of things like ghc-mod and hdevtools now
05:12:57 <merijn> neovim is a no go, since I don't have that available on the system I'm working on. I think there actually is a ghcid plugin for neovim
05:13:05 <electrocat> angerman: the rest isn't working still though, however the arm64 linux android one is the one i needed :)
05:13:06 <merijn> MarcelineVQ: That'd basically be ghcid
05:13:06 <angerman> electrocat: this one ghc-8.4.0.20180109-aarch64-linux-android.tar.xz will likely work as well. Wow. This is bad. I really need to figure out what's going on.
05:13:14 * Phyx- hasn't figured how to exit emacs
05:13:23 <MarcelineVQ> merijn: a bit more, you can query types at specific locations or ask what's in scope for completion
05:13:24 <angerman> caches coming up...
05:13:24 <Phyx-> i'm not mostly vim
05:13:26 <merijn> MarcelineVQ: The problem is that I don't know vim plugins well enough and I just can't invest the time right now (paper deadlines, etc.)
05:13:36 <ertes-w> Phyx-: what do you mean, exit emacs?
05:13:37 <merijn> MarcelineVQ: Pretty sure ghcid does type querying
05:13:47 <merijn> MarcelineVQ: Honestly I don't really care about completion
05:14:09 <Phyx-> ertes-w: you know.. like close it..
05:14:22 <ertes-w> Phyx-: close?
05:14:38 <merijn> Phyx-: He's making a joke about doing everything inside emacs
05:14:38 <ertes-w> are we talking about the same emacs?
05:14:40 <Phyx-> lol, point taken
05:19:16 <angerman> electrocat: thanks for pointing that out, I wouldn’t have noticed :-/ still don’t know where the latency issue is at. The server is responsive to me; no idea why fastlys connection to the vps times out.
05:23:01 <electrocat> angerman: lukcy i caught you here then
05:23:07 <electrocat> lucky*
05:23:37 * hackage lrucaching 0.3.3 - LRU cache  https://hackage.haskell.org/package/lrucaching-0.3.3 (cocreature)
05:23:50 <angerman> I‘m usually around and get push notifications for IRC messages ;-)
05:24:12 <Barry_> Hallo, I am having troubles with monads
05:24:51 <Barry_> Is it okay if I post my assignment and my thoughts, so someone can navigate me into the right direction?
05:26:19 <tdammers> Barry_: if you can link to something relevant, that would probably be fine, but don't expect people to do your homework for you
05:26:41 <Barry_> Obv I dont expect that
05:26:43 <tdammers> Barry_: best would be if you accompany that with information about where exactly you are stuck, which parts you don't understand
05:26:53 <Barry_> If I wanted the solutions, I would take it from friends
05:27:03 <tdammers> fair enough
05:27:36 <tdammers> btw. I'll be out the door in a minute, but I'm sure others will help you out
05:27:45 <Barry_> alright thanks
05:28:20 <Barry_> So it sais: Implement preorderM, which is a more general Version of preorderB (a function we implemented in earlier assignments): preorderM :: MonadPlus m => Bintree a -> m a
05:28:51 <Barry_> the topic is Monad, but more specific MonadPlus
05:29:39 <Barry_> So the Method is supposed to behave differently, depending on the return type
05:29:45 <ertes-w> Barry_: it would be helpful if you could paste the definition of preorderB
05:29:48 <ertes-w> @paste
05:29:48 <lambdabot> Haskell pastebin: http://lpaste.net/
05:30:02 <Barry_> for list: preorderM $ Fork 3 (leaf 4) (leaf 5) :: [Int] ~> [3,4,5]
05:30:18 <Barry_> and for Maybe just the Root node
05:30:29 <Barry_> foldBtreeB :: val -> (a -> val -> val -> val) -> Bintree a -> val foldBtreeB val _ Empty = val foldBtreeB val f (Fork a left right) = f a (foldBtreeB val f left) (foldBtreeB val f right)  preorderB :: Bintree a -> [a] preorderB (Empty) = [] preorderB (tree) = foldBtreeB [] (\(a) (bs) (cs)->a:bs++cs) tree
05:30:31 <Barry_> dammit
05:30:39 <Barry_> foldBtreeB :: val -> (a -> val -> val -> val) -> Bintree a -> val
05:30:43 <Barry_> foldBtreeB val _ Empty = val
05:30:47 <Barry_> foldBtreeB val f (Fork a left right) = f a (foldBtreeB val f left) (foldBtreeB val f right)
05:30:51 <Barry_> preorderB :: Bintree a -> [a]
05:30:54 <Barry_> preorderB (Empty) = []
05:30:57 <Barry_> preorderB (tree) = foldBtreeB [] (\(a) (bs) (cs)->a:bs++cs) tree
05:30:57 <ertes-w> Barry_: don't paste it here…  use the pastebin i linked above
05:31:02 <Barry_> ups
05:31:03 <Barry_> sry
05:32:03 <Barry_> http://lpaste.net/361573
05:32:25 <Barry_> I wrote that
05:32:42 <Barry_> We were taught how to make anything foldable
05:32:57 <ertes-w> Barry_: ok, can you explain in words what MonadPlus is?
05:33:00 <fishythe_> Barry_: so preorderB :: BinTree a -> [a] and preorderM :: MonadPlus m => BinTree a -> m a, so we need to upgrade from just lists to any MonadPlus
05:33:13 <ertes-w> Barry_: yeah, that's very good
05:33:13 <fishythe_> what operations does MonadPlus provide, and what operations do they correspond to on lists?
05:34:37 <Barry_> give me a second
05:35:06 <Barry_> so in  my understanding
05:35:09 <Barry_> we got mzero
05:35:33 <Barry_> which is basicly saying something failed or we got a Nothing state
05:36:09 <Barry_> Our class script sais, that its used for failing methods
05:36:31 <Barry_> further research showed me that it represents the "zero" state
05:36:37 <Barry_> that we dont have a solution
05:36:39 <ertes-w> Barry_: so if you interpret lists as "lists of solutions"…  then which list represents failure to find a solution?
05:36:40 <fishythefish> mzero corresponds to mempty from Monoid. it could represent failure, depending on your interpretation, but i would stick with the zero/empty interpretation
05:36:46 <metahumor> does MonadPlus have anything else?
05:37:08 <Barry_> []
05:37:13 <ertes-w> Barry_: correct
05:37:21 <Barry_> and mplus
05:37:22 <mlehmk> I see [] as mempty, while Nothing as mzero
05:37:27 <Barry_> would be a list with solutions
05:37:30 <mlehmk> only semantic difference
05:37:51 <ertes-w> Barry_: no, mplus takes two lists of solutions and returns a combination of both…  what does that correspond to?
05:38:00 <metahumor> mplus is a binary operation, not a thing of itself
05:38:06 <Barry_> ++
05:38:10 <Barry_> (++)
05:38:17 <Barry_> or (:)
05:38:28 <Barry_> If I add one item to the front
05:38:38 <ertes-w> Barry_: correct: given the lists of solutions [1,2] and [3,4], the compound list of solutions is [1,2,3,4] (or [3,4,1,2])
05:38:57 <ertes-w> > mplus [1,2] [3,4]
05:38:59 <mlehmk> is there a generalized (++)?
05:39:00 <lambdabot>  [1,2,3,4]
05:39:05 <metahumor> great! so the two pieces you've mentioned so far are mzero and mplus -- can you substitute them into your preorderB defn in the places you think they need to be? doesn't have to typecheck yet
05:39:06 <fishythefish> mlehmk: mappend
05:39:24 <ertes-w> Barry_: given this information, do you see a way to implement preorderB in terms of mzero instead of [] and mplus instead of (++)?
05:39:46 <Barry_> I belive I do
05:39:51 <Barry_> give me a second
05:40:14 <amca> Is there a version of : as in (x:xs) that works from the right, so that you could have (xs:x) , that is (init:tail) instead?
05:40:28 <metahumor> "snoc"
05:40:35 <ertes-w> amca: (++ [x])
05:40:46 <metahumor> you'd use a SnocList or a Sequence with (xs |:> x) for that
05:40:48 <ertes-w> amca: of course lists aren't particularly great at "snoc"-ing
05:41:12 <mlehmk> with mzero, it would be an error condition, while with mempty, it'd mean no result
05:41:18 <metahumor> ehh (xs |> x) is the operation and (xs :|> x) is the pattern
05:41:25 <ertes-w> mlehmk: mzero and mempty are the same concept
05:41:37 <mlehmk> ertes-w, little difference though, I think
05:41:54 <fishythefish> mlehmk: not necessarily. the interpretation as error is too narrow
05:41:56 <mlehmk> see above about comparision to Nothing and []
05:41:59 <amca> I mean, you can use (x:xs) in a recursive function, f (x:xs) = (something with x) and (something with f xs), but can you do the same thing working from the right hand end of lists?
05:42:05 <fishythefish> mplus is an associative operation on the monad, and mzero is its identity. that's it
05:42:24 <ertes-w> mlehmk: well, MonadPlus is slightly stricter than Monoid and Alternative
05:42:28 <metahumor> Barry_: other than the bound variables [tree, foldBtreeB] and free variables [a bs cs], you have 3 other things in your preorderB defn
05:42:28 <mlehmk> > Nothing `mplus` (Just 1)
05:42:31 <lambdabot>  Just 1
05:42:51 <metahumor> Barry_: you've mentioned two things from MonadPlus, [mzero, mplus]
05:42:58 <mlehmk> but mappend doesn't like it
05:43:29 <metahumor> Barry_: you've made a correspondence between {mzero: [], mplus: (++)}... what's the third thing that is in your preorderB defn that I haven't written yet?
05:43:30 <ertes-w> metahumor: let them finish their current task first…  we'll get there =)
05:43:33 <Barry_> preorderB (mzero) = [] preorderB (a left right) = a mplus (preorderB left) (preorder right)
05:43:53 <ertes-w> Barry_: that's incorrect
05:44:08 <metahumor> Barry_: can a "Bintree a" be an "mzero"?
05:44:17 <ertes-w> Barry_: you just learned that for lists (mzero = []) and (mplus = (++))
05:44:26 <Barry_> oh true
05:44:34 <ertes-w> Barry_: so take the definition of preorderB and just replace
05:44:36 <fishythefish> amca: no, you can't pattern match at the right end of a list
05:44:55 <mlehmk> ohh... mplus on Maybe is like || in c-like languages
05:45:05 <Barry_> preorderB (tree) = foldBtreeB mzero (\(a) (bs) (cs)->a mplus bs plus cs) tree
05:45:06 <mlehmk> I mean, javascript
05:45:19 <metahumor> Barry_: you're almost there! well-replaced
05:45:19 <ertes-w> Barry_: that's a type error
05:45:26 <mlehmk> when treating Nothing as a falsey state. Interesting
05:45:44 <Barry_> give me a minute to soak all this in
05:45:56 <ertes-w> Barry_: at this point you don't know how to deal with (:), so don't replace it
05:45:59 <Barry_> I feel like I am not undertsanding it as I should
05:46:00 <metahumor> Barry_: we have (mzero = []) and (mplus = (++)), how do you express (:) in MonadPlus?
05:46:15 <ertes-w> Barry_: focus only on (++) and []
05:46:31 <mlehmk> metahumor, it'd require a lift, wouldn't it?
05:47:19 <metahumor> mlehmk: msg
05:47:26 <metahumor> mlehmk: msg'd you privately =)
05:47:43 <Barry_> so for the :
05:47:57 <Barry_> I would just do [a] and would be able to ++
05:48:01 <Barry_> hence I could use mplus
05:48:07 <metahumor> great!
05:48:24 <ertes-w> Barry_: yeah, that's correct, although you went one step ahead =)
05:48:27 <metahumor> but is there a way to do "a -> [a]" in MonadPlus syntax?
05:49:00 <ertes-w> Barry_: so with this new definition is there anything in your function that is list-specific?
05:49:29 <angerman> electrocat: they seem to finally all be cached.
05:50:04 <Barry_> let me check mplus type def quickly
05:50:14 <electrocat> angerman: all seem to be working :)
05:50:21 <mlehmk> https://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:MonadPlus
05:50:43 <amca> The question I asked about seven hours ago, but had to leave is now at http://lpaste.net/361577
05:50:51 <electrocat> angerman: i've got a suggestion
05:51:00 <angerman> electrocat: yea, now they just have to stay that way :D
05:51:12 <mniip> amca, I don't think that's csv
05:51:13 <amca> Maybe I should be in the haskell-beginners channel...
05:51:41 <metahumor> amca: using Data.Csv is overkill
05:51:50 <mniip> for one,
05:51:53 <electrocat> angerman: when you got time, would it be possible to serve over https and include checksums? your distributing binary packages after all, should be a little more secure in my opinion
05:52:03 <mniip> read . ("("++) . (++")")
05:52:05 <electrocat> you're*
05:52:07 <amca> In fact mnnip you're probably right; thanks also metahumor - all I need to do is parse those strings
05:52:22 <Barry_> maybe I need to go one step back
05:52:23 <mlehmk> if something isn't explicitly in that typeclass, maybe it is in a base typeclass up the hierarchy
05:52:34 <angerman> electrocat: yea. I'll probably have to take out the binaries anyway, as I want to automate the overlay. For the overlay I'll need to use http (cabal ...).
05:52:35 <metahumor> amca, do you know of a quick way of breaking a string into lines in Haskell?
05:52:36 <Barry_> I will quickly find out why let k= [2] >>= \x -> x >> return x
05:52:40 <Barry_> behave so weir
05:52:41 <Barry_> weird
05:52:45 <Barry_> and than I will be back
05:52:51 <angerman> electrocat: if you end up wanting to use cabal, the following might be of interest https://github.com/mobilehaskell/hackage-overlay/issues/5#issuecomment-357190951
05:52:53 <Barry_> hope someone will be left here than I am back
05:52:54 <mlehmk> if it is a MonadPlus, it is also a Monad, it is also a Functor
05:52:54 <metahumor> Barry_: we'll be here =)
05:53:06 <amca> I don't know much about string handling at all: I've never had to do it until now
05:53:20 <mmaruseacph2> metahumor: lines :: String -> [String]
05:53:21 <metahumor> amca: "lines :: String -> [String]"
05:53:28 <angerman> electrocat: so I guess I'll just have one more (https) domain, (dl.mobilehackage.org or something), and put the bindists there.
05:53:32 <mlehmk> uhm, sorry, scrapt that last thing
05:53:36 <metahumor> mmaruseacph2: it was a leading question =)
05:53:38 <amca> The only reason for my handling strings is because of the result of readFile
05:53:47 <mlehmk> there are Monads that aren't Functors, I think
05:53:54 <mmaruseacph2> mlehmk: impossible
05:53:59 <MarcelineVQ> mlehmk: not in haskell
05:54:05 <angerman> electrocat: all a question of automating it. This is a one man job right now, and I'd prefer not to spend too much time on infrastructure :D
05:54:10 <merijn> MarcelineVQ: Not in math either
05:54:16 <MarcelineVQ> merijn: even better
05:54:18 <amca> Thanks folks, I'll give all of that a try
05:54:26 <mlehmk> Well, the possibility seems to be left open in Haskell
05:54:31 <merijn> MarcelineVQ: Functor laws are a subset of monad laws
05:54:41 <merijn> mlehmk: Not in recent GHCs
05:54:43 <mlehmk> in Haskell, Functor and Monad are distinct
05:54:50 <mmaruseacph2> not anymore
05:54:51 <merijn> mlehmk: Functor is a superclass of Monad
05:54:57 <mlehmk> ohh? that is new
05:55:02 <merijn> mlehmk: You cannot make a Monad instance without Functor
05:55:04 <mlehmk> so, what I said was right after all
05:55:08 <mniip> in mathematics...
05:55:13 <mniip> "monad is an endofunctor that..."
05:55:26 <mlehmk> MonadPlus is also a Monad and Fuctor then
05:55:29 <merijn> mlehmk: It was right 2 or more years ago
05:56:04 <electrocat> angerman: i see, i'll try it out this evening
05:56:17 <mniip> oh right
05:56:29 <mniip> I somehow completely forgot that AMP introduced not only A=>M but F=>M too
05:56:43 <angerman> electrocat: good luck! Let me know how it goes. I'd suggest not touching TH yet. I should write up more on that first :D
05:56:52 <Barry_> okay I belive I can transfer a like this: a>>=\x->x>>return [x]
05:56:57 <merijn> mniip: That's because Functor was always a superclass of Applicative :)
05:56:58 <ertes-w> Barry_: i would expect that to be a type error, unless you wrote a really wird Monad instance
05:57:02 <ertes-w> *weird
05:57:26 <mlehmk> Do I need to understand Arrow to understand Lens?
05:57:33 <merijn> mlehmk: No
05:57:33 <ertes-w> mlehmk: nah
05:57:34 <mniip> ertes-w, I wouldn't
05:57:40 <mlehmk> ahh, okay
05:57:41 <electrocat> angerman: i'll try something simple first :p
05:57:44 <merijn> mlehmk: Also, I don't think lens uses Arrow at all?
05:57:45 <mniip> ertes-w, if a::m(m b)
05:57:52 <ertes-w> mniip: i mean the earlier one, where 'a' was [2]
05:57:56 <mniip> ah
05:58:00 <mniip> 2::m b
05:58:07 <MarcelineVQ> mniip: :>
05:58:32 <metahumor> amca: if you have a 'cp <- readFile "text.txt"', then 'convert = fmap (read . ("(" ++) . (++ ")")) . lines'
05:58:57 <ertes-w> mlehmk: understanding lenses is a matter of understanding the pattern of 'traverse'
05:59:01 <metahumor> Barry_: what's a clean way of going from "a -> [a]" in MonadPlus?
05:59:29 <metahumor> Barry_: a hint, can you express "a -> [a]" if I call "[]" as "m"?
05:59:32 <amca> Thanks, metahumor.  These are subtleties I have yet to get my head around.
05:59:38 <mniip> ertes-w, uhhhh
05:59:44 <mniip> that's traversals
05:59:56 <ertes-w> mniip: lenses are traversals
06:00:12 <metahumor> amca: just break it down piece by piece. you break your string into lines, then prepend and append parens on each line, and then read each line
06:00:19 <mniip> lenses subtype to traversals
06:00:30 <mniip> don't forget the variance
06:00:37 <Barry_> (++) [] 2
06:00:57 <mlehmk> gotta get the 2 into [2]
06:01:05 <ertes-w> Barry_: every MonadPlus is also a Monad, and every Monad is an Applicative, right?
06:01:14 <Barry_> yes
06:01:16 <Barry_> but
06:01:18 <metahumor> Barry_: can you write type signature for "a -> [a]" using "m" instead of "[]"?
06:01:21 <mniip> lenses only use the functorial parts of the transformation
06:01:36 <ertes-w> Barry_: with the Applicative interface do you see a way to construct a singleton list?  i.e. a "single solution"?
06:01:40 <mlehmk> could be done with (:[]), but that is still list specific
06:02:01 <mlehmk> so, what is: ? = (:[])
06:02:10 <fishythefish> ertes-w: pedagogically, any reason to prefer the Applicative interface over the Monad interface for this?
06:02:24 <mniip> traverse f (Pair a a) = Pair <$> f a <*> f a
06:02:33 <mniip> oops
06:02:37 <Barry_> a -> m a
06:02:38 <mniip> traverse f (Pair x y) = Pair <$> f x <*> f y
06:02:47 <mniip> _1 f (Pair x y) = Pair <$> f x <&> y
06:02:48 <ertes-w> fishythefish: more like: no reason to prefer Monad over Applicative =)
06:02:52 <metahumor> Barry_: perfect! is there a function you know that has that type signature?
06:03:04 <fishythefish> ertes-w: I'd agree if we weren't already committed to MonadPlus :P
06:03:07 <metahumor> Barry_: in MonadPlus, which is an instance of Monad, which is an instance of Applicative?
06:03:17 <mlehmk> (:[]) is pointless for \a -> [a], isn't it?
06:03:17 <fishythefish> but yes, in general I'm in favor of using the least powerful thing required
06:03:18 <mniip> ...not <&>
06:03:22 <mniip> but you get the diea
06:03:22 <ertes-w> fishythefish: if we turn this into a debate, we'd be debating for hours =)
06:03:30 <amca> Thanks again, metahumor, I'll give it my best shot!
06:03:33 <fishythefish> ertes-w: i don't mean to debate, i was genuinely curious about your choice
06:03:52 <ertes-w> fishythefish: the rationale is that i always try to teach the correct thing right away
06:04:10 <Barry_> mzero
06:04:14 <Barry_> has m a
06:04:22 <Barry_> but a-> m a
06:04:28 <mlehmk> if MonadPlus doesn't have it explicitly, look at Monad
06:04:37 * hackage ratel 0.3.9 - Notify Honeybadger about exceptions.  https://hackage.haskell.org/package/ratel-0.3.9 (fozworth)
06:04:42 <metahumor> Barry_: sorry, "mzero :: m a", and "mplus :: m a -> m a -> m a", we need some way of wrapping "a -> m a"
06:04:54 <ertes-w> Barry_: remember that MonadPlus comes with more than just mzero and mplus, because every MonadPlus is a…  you know…
06:05:06 <Barry_> again the return function
06:05:09 <metahumor> yeah!
06:05:18 <metahumor> Barry_: what's the typesig for return?
06:05:24 <mniip> does lens have an uhh, hmm
06:05:29 <Barry_> a-> m a
06:05:40 <Barry_> return :: a -> m a
06:05:53 <metahumor> Barry_: great, that's right. so what would "return 2" be if I was using the return of []?
06:06:02 <mniip> I need to review 'each'
06:06:16 <ertes-w> Barry_: and now pretend that the 'return' function doesn't exist and use 'pure' instead – the same function, but from Applicative =)
06:06:20 <Barry_> []->m []
06:06:27 <mniip> or do I...
06:07:01 <Barry_> instance Applicative M where pure = return
06:07:16 <Barry_> isnt that the same?
06:07:21 <metahumor> Barry_: no, sorry. [] is the wrapper. if I had "pure :: a -> Maybe a", what would "pure 2" equal?
06:07:37 <ertes-w> Barry_: yeah, in modern code you would define 'pure' first and not define 'return' at all (it defaults to 'pure' and is only there for historical reasons)
06:08:08 <mlehmk> wait, liftA is Arrow, not Applicative?
06:08:26 <Barry_> instance Applicative M where pure = return
06:08:32 <Barry_> (pure 2) :: (Num a, Applicative f) => f a
06:08:32 <Gurkenglas> mniip, but an Each may contain more information than the targets
06:08:36 <fishythefish> :t liftA -- mlehmk
06:08:39 <lambdabot> Applicative f => (a -> b) -> f a -> f b
06:09:20 <metahumor> Barry_: yeah, the type of "pure 2" will be "m 2" for some Applicative (possibly Monad) m. do you know about Maybe?
06:09:43 <metahumor> Barry_: I'm asking for what the value of "pure 2 :: Maybe Int" will be, I gave you the type
06:10:28 <Barry_> m (Maybe Int)
06:10:47 <Barry_> I feel like my brain just stops working
06:10:50 <metahumor> Barry_: you're giving me the type again, and, I'm sorry, that's incorrect
06:10:54 <metahumor> Barry_: let's ask ghci
06:10:58 <metahumor> > pure 2 :: Maybe Int
06:10:59 <mniip> Gurkenglas, right, I need a class for data that has nothing else
06:11:01 <lambdabot>  Just 2
06:11:23 <metahumor> :t Just 2
06:11:25 <lambdabot> Num a => Maybe a
06:11:32 <Barry_> OHHHH
06:11:34 <Barry_> OHHHH
06:11:34 <metahumor> :t Just (2 :: Int)
06:11:37 <lambdabot> Maybe Int
06:11:41 <Barry_> but how does it do that
06:11:56 <metahumor> Barry_: can you verbalize what you're thinking atm?
06:12:32 <Gurkenglas> mniip, or maybe we should add as an Each law that there is no additional information? (up to "nonobservables" such as Map structure)
06:12:44 <mniip> okay I have a temporary workaround
06:12:47 <Barry_> so I belive that the pure function is overloaded in its return type. And each type defines
06:12:49 <Gurkenglas> Wait, Maps have additional information in the keys.
06:12:53 <Barry_> how the value is returned
06:12:56 <mniip> sat f = let x = runSelect (each (const $ Select (\p -> p True)) x) f in x
06:13:11 <mniip> screw guaranteed termination!
06:13:33 <ertes-w> Barry_: that's correct
06:13:50 <metahumor> Barry_: exactly, because "pure :: Applicative m => a -> m a"
06:13:51 <ertes-w> Barry_: type classes are principled overloading
06:14:16 <ertes-w> Barry_: where the the instance is chosen by types
06:14:26 <metahumor> Barry_: so if "pure 2 :: Maybe Int" gives us "Just 2", what would "pure 2 :: [Int]" give us?
06:14:30 <Barry_> yeah true... I need to use the types that are provided...my mind is just thinking so narrow
06:14:39 <ertes-w> Barry_: so if GHC knows that m = [], it will use 'pure' for the (Applicative []) instance
06:14:52 <Barry_> [2]
06:15:09 <Barry_> yeah my brain just did not make that connection
06:15:37 <metahumor> Barry_: sweet. so now you have the pieces you need, you have things that are of types "m a", "m a -> m a -> m a" and "a -> m a"
06:15:47 <ertes-w> > pure ()  -- the type of this is (Applicative f => () -> f ()), but GHC doesn't know which 'f' i want here, so it complains
06:15:51 <lambdabot>  error:
06:15:51 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M542940298513...
06:15:51 <lambdabot>        prevents the constraint ‘(Show (f0 ()))’ from being solved.
06:16:09 <mniip> % pure () -- defaulting, sort of
06:16:09 <yahb> mniip:
06:16:17 <metahumor> Barry_: can you name the three pieces that I gave the typesigs of?
06:16:27 <ertes-w> > pure () :: [()]  -- but now i'm more specific and specialise to f = [], so GHC will pick the instance (Applicative [])
06:16:30 <lambdabot>  [()]
06:16:57 <Gurkenglas> mniip, don't know Select but partsOf may let you think about reviewing a single target instead of multiple?
06:17:11 <Barry_> a->m a should be for a to convert it to a list
06:17:26 <Barry_> m a->m a->m a should be mplus
06:17:28 <Barry_> and mzero
06:17:40 <Barry_> the first typesig you provided
06:17:50 <metahumor> Barry_: what's the function name for that "a -> m a" typesig again?
06:18:00 <Barry_> pure
06:18:03 <metahumor> perfect
06:18:16 <metahumor> so the three pieces you have are "mzero, mplus, pure"
06:18:33 <ertes-w> Barry_: now you know how to append, construct singleton lists and the empty list without using list-specific functionality…  can you write that preorderB function again, but without list-specific things?
06:18:33 <metahumor> can you use those three to rewrite the inner lambda in your preorderB defn?
06:19:00 <Gurkenglas> mniip, you could assert that the Each has no information but the targets by constructing the review like "each .~ 1 $ undefined"
06:19:28 <Barry_> preorderB (tree) = foldBtreeB mzero (\(a) (bs) (cs)->(pure a) mplus bs mplus cs) tree
06:19:32 <Barry_> preorderB (Empty) = mzero
06:19:39 <metahumor> Barry_: does that typecheck? =)
06:19:42 <mniip> Gurkenglas, that fails with an ambiguity check
06:19:50 <Gurkenglas> > each .~ 1 $ undefined :: (Int, Int)
06:19:53 <Barry_> let me try typechcking that
06:19:53 <lambdabot>  (1,1)
06:19:55 <ertes-w> Barry_: correct thinking, wrong syntax =)
06:19:58 <mniip> recursion does essentially the same
06:20:06 * hackage QuickCheck 2.11.1 - Automatic testing of Haskell programs  https://hackage.haskell.org/package/QuickCheck-2.11.1 (NickSmallbone)
06:20:07 <mniip> but doesn't fail with ambiguity :P
06:20:11 <ertes-w> Barry_: if you want to use 'mplus' infix, you have to use backticks
06:20:16 <Barry_> pure is not in scope
06:20:19 <ertes-w> > [1,2,3] `mplus` [4,5,6]
06:20:22 <lambdabot>  [1,2,3,4,5,6]
06:20:28 <ertes-w> Barry_: ghc --version
06:20:39 <metahumor> Barry_: what version of ghc are you using?
06:20:48 <Gurkenglas> > each .~ 1 $ error "additional information requested" :: (Int, Int) -- mniip, this gives you more debug information than an infinite loop though
06:20:50 <Barry_> using ghci
06:20:52 <lambdabot>  (1,1)
06:20:55 <Barry_> cant I just use return?
06:20:57 <quchen> (<|> is infix mplus as well)
06:21:18 <Barry_> preorderB (Empty) = mzero
06:21:23 <Barry_> Expected type: (m0 a0 -> m0 a0 -> m0 a0)                    -> [a] -> (m1 a0 -> m1 a0 -> m1 a0) -> [a] -> [a]       Actual type: (m0 a0 -> m0 a0 -> m0 a0) -> a
06:21:26 <ertes-w> Barry_: GHCi is just `ghc --interactive`…  what's version of GHC do you have installed?
06:21:31 <ertes-w> Barry_: type:  ghc --version
06:21:51 <Barry_> It doesnt allow me to type that
06:21:59 <ertes-w> Barry_: then type:  ghci --version
06:22:01 <Gurkenglas> mniip, it's the traverse callCC thing all over again, don't replace your undefined with a value just because you have one
06:22:12 <ertes-w> Barry_: or look at the first few lines when you start GHCi
06:22:20 <mniip> no, this case is actually different
06:22:35 <Barry_> 7.6.3
06:22:39 <mniip> in traverce callCC I actually had a point :P
06:22:54 <ertes-w> Barry_: that's ancient…  are you forced to use such an old version?
06:23:20 <Barry_> Well thats the one we have at our university
06:23:25 <Barry_> can change it
06:23:28 <Barry_> cant
06:23:33 <Gurkenglas> mniip, maybe I missed the point there, then? Could you spell it out?
06:23:40 <metahumor> okay, in this case, we'll let you use "return" =)
06:23:48 <Barry_> thanks xD
06:23:52 <metahumor> but you should read and think of "return" as "pure"
06:24:09 <Barry_> alright, I will make a comment as a note to not forget
06:24:26 <ertes-w> Barry_: that's almost a time machine to the Before Times…  before the Great AMP
06:24:26 <mlehmk> return is kind of a misnomer
06:24:36 <metahumor> reason being, there is nothing special about Monad that makes it need a separate "return" from its Applicative's "pure"
06:24:48 <mlehmk> it has a very different meaning in Haskell than it has in procedural languages
06:25:18 <mlehmk> return wraps the value in a Monad, it does not end "flow"
06:25:38 <mniip> Gurkenglas, p o i n t
06:25:43 <ertes-w> Barry_: (ideally you should convince them to upgrade…  a lot of information they are teaching is no longer representative of modern haskell)
06:26:03 <mlehmk> it should probably have been called pureM or something
06:26:10 <Barry_> I will talk to the tutor
06:26:18 <Barry_> maybe there is a reason for that
06:26:28 <Barry_> otherwise I will send an email to the IT guys
06:26:33 <Barry_> so
06:26:35 <metahumor> Barry_: probably just institutional inertia
06:27:24 <metahumor> Barry_: so yeah, we're trying to solve two issues currently: using "return" in place of "pure" and proper infix notation of "mplus", which is " `mplus` "
06:27:34 <Gurkenglas> mniip, recursion works in more cases than undefined, so using undefined gives the reader of your code context. (replace undefined in that sentence with almost any definition made in any library and get another correct piece of advice)
06:27:36 <ertes-w> Barry_: it may also be related to their distribution…  many universities use debian and ancient versions at that…  debian has a reputation for distributing ridiculously old verions of GHC
06:28:01 <merijn> bah...
06:28:04 <metahumor> Barry_: you should be able to write that inner lambda now, given those solutions to the issues you had
06:28:10 <merijn> I wish I had the time to get rid off persistent...
06:28:19 <mniip> Gurkenglas, what
06:28:27 <mniip> nothing works in more cases than undefined
06:28:45 <Gurkenglas> mniip, we are working with different values of works
06:29:28 <Gurkenglas> recursion can make values you want to use and values you dont want to use. undefined can only make values you dont want to use
06:29:38 <ertes-w> merijn: if you have 4/5 done, each time you write a new SQL query, convert four of the existing ones to SQL along the way =)
06:29:59 <Barry_> this does not cause errors for me
06:29:59 <Barry_> preorderB (Empty) = mzero preorderB (tree) =  foldBtreeB mzero (\(a) (bs) (cs)->(return a) `mplus` bs `mplus` cs) tree
06:30:04 <merijn> ertes-w: I'm not writing new queries, though.
06:30:12 <mlehmk> is that kind of "ex falso quodlibet"?
06:30:13 <metahumor> Barry_: that's because it's exactly right!
06:30:20 <metahumor> Barry_: you did it
06:30:24 <Gurkenglas> recursion can unfold lists and do other things. unfoldr can only unfold lists.
06:30:29 <Barry_> yay
06:30:32 <ertes-w> merijn: then why does persistent bother you? =P
06:30:33 <metahumor> Barry_: one last thing
06:30:45 <merijn> ertes-w: Because, I need access to the raw SQLite database pointer
06:30:47 <metahumor> Barry_: is there anything superfluous in your definition of preorderB?
06:31:09 <merijn> ertes-w: Right now I do that at the backend creation moment, which works, but means I can only do my manipulation globally
06:31:21 <merijn> ertes-w: Instead of nicely localised access to the SQL API
06:31:36 <merijn> ertes-w: And there's no way in persistent to smuggle the raw pointer to where I need it
06:32:02 <ertes-w> merijn: what about 'wrapConnection' and 'wrapConnectionInfo'?
06:32:13 <ertes-w> merijn: i.e. open the sqlite database outside of persistent and then hand it over?
06:32:14 <merijn> ertes-w: That's where I'm accessing things now
06:32:38 <merijn> ertes-w: Yes, but then I still need to propagate the database pointer to the usage location, which I don't have a convenient way of doing
06:33:04 <Barry_> That I dont have a type definition?
06:33:10 <ertes-w> merijn: functions/ReaderT?
06:33:21 <metahumor> Barry_: superfluous as in, you have something extra which you don't even need
06:33:22 <merijn> ertes-w: persistent already claims the ReaderT, that's the issue
06:33:32 <ertes-w> oh, indeed
06:34:13 <ertes-w> merijn: well, use ReaderT below persistent's ReaderT, then 'lift' your own reader actions
06:34:21 <ertes-w> (or just use functions)
06:34:36 <merijn> ertes-w: That was the backup plan, yes, but that's annoying as shit, though >.>
06:34:47 <ertes-w> yeah, i can imagine
06:34:53 <Barry_> so
06:34:59 <Barry_> I got to definitions
06:35:04 <Barry_> one for the empty case
06:35:20 <ertes-w> merijn: another option would be an SqliteT + MonadSqlite
06:35:25 <Barry_> which needs to deliver the appropriate zero element
06:35:29 <Barry_> hence mzero
06:35:31 <Barry_> so thats needed
06:35:37 <metahumor> is it though?
06:35:47 <ertes-w> merijn: or wait…  what about writing a custom backend?
06:35:52 <metahumor> what's your definition of foldBtreeB? does it have a case for Empty trees?
06:36:05 <Barry_> TRUE
06:36:07 <merijn> ertes-w: That's what I was thinking
06:36:18 <merijn> ertes-w: Turns out I can't simply smuggle a value into the backend :\
06:36:31 <ertes-w> merijn: instance (IsSqlBackend backend) => IsSqlBackend (backend, Connection)
06:36:38 <merijn> ertes-w: Because I need to define both "MyBackend -> SqlBackend" and "SqlBackend -> MyBackend"
06:36:38 <ertes-w> doesn't this work?
06:36:44 <ertes-w> oh
06:36:53 <merijn> ertes-w: No, not if you look at the persistent classes
06:36:59 <merijn> ertes-w: I had the exact same idea
06:37:00 <ertes-w> persistent really resists being pleasant to work with =)
06:37:04 <merijn> ertes-w: Which would've been super nice
06:37:25 <merijn> ertes-w: Yeah, I've been looking at Selda, which looks promising, but can't switch over right now
06:38:13 <Barry_> It really works
06:38:23 <Barry_> Thanks a lot
06:38:28 <metahumor> Barry_: our pleasure
06:38:37 <metahumor> Barry_: so your final definition for preorderB is?
06:38:37 <Barry_> And i even understand now what I did there
06:38:45 <Barry_> preorderM (tree) =  foldBtreeB mzero (\(a) (bs) (cs)->(return a) `mplus` bs `mplus` cs) tree
06:39:08 <metahumor> Barry_: there's a little extra thing left still, but it is fine to leave it in for clarity's sake
06:39:30 <ertes-w> merijn: i'd be super-sceptical about switching to a new "high-level database" library
06:39:46 <metahumor> Barry_: can you explain back to us how you went about converting functions that use lists to generalized MonadPlus functions? I think writing it out will help reinforce what you learned
06:40:34 <Barry_> well
06:40:45 <Barry_> the most important things in my eye are
06:41:00 <merijn> ertes-w: Well, I've looked at opaleye and really liked it, but there's no sqlite support. Selda looks a lot like opaleye in design, but designed to be more extensible (i.e. both postgres and sqlite support) and generally more hackable
06:41:04 <Barry_> empty elements (or lists) are covered by mzero
06:41:20 <Barry_> converting elements into your desired type
06:41:39 <Barry_> is defined by the type itself by overloading the return/ pure method
06:41:51 <Barry_> mplus allows to combine multiple results
06:42:13 <Barry_> with those function I can generalize a lot of operations
06:42:58 <ertes-w> merijn: yeah, my scepticism comes from the fact that i've never actually run into any of the problems those libraries are trying to solve…  the only valid argument i know for those libraries is that "SQL is ugly"
06:43:14 <Barry_> thats its isnt it @metahumor?
06:43:32 <metahumor> Barry_: you also used the fact that your "fold" took care of dealing with Empty trees
06:43:55 <Barry_> yeah true :D
06:43:59 <metahumor> Barry_: so that your base case for the fold, "mzero", is what you get when you pass an Empty tree
06:44:05 <mlehmk> can I use generalized pattern matching on MonadPlus?
06:44:39 <metahumor> Barry_: "overloaded" isn't exactly right, you're applying a C/C++ concept here
06:44:41 <merijn> ertes-w: No, the argument is "type safety on the boundary between database and Haskell types is nice"
06:45:09 <metahumor> Barry_: it's better to say that different types, when instances of Applicative, have their own "pure" definitions
06:45:26 <ertes-w> merijn: how are those libraries better than *-simple in that respect?
06:46:02 <metahumor> Barry_: and that you MUST have a "pure" definition if you are Applicative
06:46:08 <ertes-w> merijn: or simpler question: which aspect of the *-simple API is not type-safe?
06:46:34 <metahumor> Barry_: which is much stronger than "overloading", we are requiring "pure", not just using it "if it exists"
06:46:43 <merijn> ertes-w: You only find out type mismatches between table and query at runtime
06:47:06 <metahumor> Barry_: you also utilized the instance hierarchy "Applicative m => Monad m => MonadPlus m", that is, all MonadPlus are Monad are Applicative
06:47:08 <ertes-w> merijn: that problem isn't solved by the higher-level libraries
06:47:31 <ertes-w> databases aren't type safe – especially not sqlite
06:47:44 <metahumor> Barry_: i think that's it!
06:48:15 <Barry_> wow
06:48:32 <metahumor> Barry_: the last extra thing i mean was "preorderB = foldBtreeB mzero (\a bs cs -> (pure a) `mplus` bs `mplus` cs)"
06:48:42 <Barry_> And all you said makes actually sense. Before you guys i was sure to never understand this
06:48:42 <merijn> ertes-w: It's solved by matching the database schema with the codebase schema on program start and reporting useful mismatches, rather than random queries failing
06:48:56 <Barry_> yeah the dotnotation
06:49:03 <metahumor> Barry_: no "tree" variable used, because "preorderB blah = ... blah"
06:49:06 <Barry_> (translated directly form german)
06:49:09 <metahumor> and I canceled out the blah
06:49:17 <Barry_> I am coming from java
06:49:27 <metahumor> Barry_: it's ok, i understand german, so i hear what you mean
06:49:31 <Barry_> xD
06:49:35 <ertes-w> merijn: if i'd care about that, i could probably do it…  there are even some generic migration libraries around…  other than that it comes down to using FromRow and ToRow
06:49:41 <mlehmk> I am coming from C#. There is F# in .NET, though it is just some better ML
06:50:04 <metahumor> F# is nice in some ways because of how one can explicitly define mutable variables
06:50:17 <mlehmk> I don't like mutable structures any more
06:50:25 <quchen> Haskell is also some better ML.
06:50:32 <metahumor> Barry_: now an exercise could be, write a postorderB
06:50:37 <mlehmk> Haskell teached me to like immutable structures
06:50:42 <metahumor> Barry_: or an "infixorderB"
06:51:01 <ertes-w> merijn: but more importantly this isn't a problem i've *ever* run into in my whole career…  that's why those higher-level libraries lost their appeal to me =)
06:51:02 <mlehmk> I even changed my coding style in C# to prefer immutability and pure methods when possible
06:51:23 <metahumor> mlehmk: have fun writing a histogram function with "immutable" structures
06:51:45 <mlehmk> .NET has some nice immutable collections to solve those
06:52:36 <mnoonan> metahumor, "Map.toList . Map.fromListWith (+) . map (,1)" ?
06:52:53 <merijn> ertes-w: We've had this discussion before and it boiled down to you saying "oh, but I never change my schema, just extend it"
06:52:55 <Barry_> Will do, but I have to get something to eat first
06:53:02 <merijn> ertes-w: Good for you, but that's not what most people do
06:53:06 <metahumor> Barry_: a guten appetit
06:53:10 <Barry_> thanks :)
06:53:34 <Barry_> are you online later on? If I have more specific questions :)
06:53:34 <Barry_> ?
06:53:49 <metahumor> mnoonan and mlehmk, I'm thinking of something like Vector, where thaw and freeze and modify are very useful and use ST s a
06:53:54 <metahumor> Barry_: yeah prolly
06:54:52 <Barry_> alirght than until later! Thanks again
06:55:05 <mlehmk> metahumor, I know a similar thing from ImmutableJS, where immutable collections can be "cloned" into mutable structures that yield immutable structures at the end
06:56:33 <metahumor> lenses also make things interesting, i had this the other day: "m & at key <>~ (Just [v])" to build up a "Map Int [Int]"
07:02:58 <ertes-w> merijn: i guess
07:03:41 <ertes-w> merijn: but if i would, there are libraries for migrations…  i wouldn't mind using those
07:06:06 <ertes-w> back when i started doing DB stuff in haskell persistent was the only option for automatic migrations, so i had two options (after figuring out that persistent wasn't for me): live with it and design schemas accordingly, or write my own migration library…  i went with the former
07:20:28 <Bish> ertes-w: where is that migration library?
07:23:23 <ertes-w> Bish: search for "migration" on hackage…  there are a few libraries
07:27:01 <Bish> ertes-w: i want yours :3
07:28:01 <Bish> but shouldn't a library like that be both?
07:28:08 <tsahyt> This might be a bit unconventional, but is there a way to dump a markdown string generated by servant-docs at compile time to a file?
07:28:12 <Bish> i mean shouldn't a db library
07:28:16 <Bish> handle migrations and querying?
07:28:17 <ertes-w> Bish: i said i went with the former option =)
07:28:29 <Bish> and maybe models?
07:28:52 <ertes-w> Bish: depends on the level of abstraction you want to go with
07:29:18 <Bish> don't you believe there is a level ob abstractions that covers 99 percent of the cases
07:29:25 <tsahyt> there's file-embed which does pretty much exactly the opposite of what I want, so maybe there's also a lib out there to generate a file at compile time
07:29:29 <Bish> and if that's not enough you go back to creating a string ?
07:29:39 <ertes-w> Bish: i don't know, but i haven't seen it yet
07:30:49 <Bish> well i did.. but not in haskell :/
07:30:59 <ertes-w> Bish: i'd actually like to have a relational algebra library…  attempts to do that exist (haskelldb), but they come with the usual caveats: if you do anything fancy with the database system, you quickly hit the abstraction boundary
07:31:40 <Bish> hm
07:32:12 <mnoonan> tsahyt: maybe see what inline-c does? the inline-c splices get turned into .c files at (ghc-) compile time
07:34:06 <tsahyt> mnoonan: I'll check it out, thanks!
07:34:49 <EvanR> ertes-w: meaning you dont get what you want?
07:34:57 <EvanR> it becomes slow?
07:35:11 <EvanR> you cant access certain features of the underlying db?
07:35:20 <EvanR> the abstraction leaks?
07:36:32 <ertes-w> EvanR: there are things you can't express, so you have to break the abstraction, and then everything goes to hell
07:38:22 <ertes-w> the first time i ran into this was with persistent (this is easily 6-7 years ago, so it may no longer apply):  there was no way to create indices, views, and you couldn't join within the abstraction
07:39:26 <EvanR> not being able to join, somehow, sees really odd
07:39:54 <ertes-w> well, persistent always claimed that it was not an ORM, but it sure was designed with an ORM mindset
07:40:16 <ertes-w> at the same time it didn't support nesting in any useful way
07:40:29 <ertes-w> so naturally it would never have to perform joins by itself
07:43:19 <EvanR> i dont see what nesting has to do with anything, joins are a central part of relational algebra
07:43:34 <EvanR> and the only way to combine data from different places efficiently
07:46:09 <ertes-w> EvanR: "nesting" is really just another term for products
07:46:22 <ertes-w> so we're probably talking about the same thing anyway =)
07:49:21 <merijn> EvanR, ertes-w: The problem is that persistent tries to accommodate non-SQL datastores to, drastically limiting the API
07:49:55 <EvanR> NonSQL (tm)
07:50:14 <EvanR> why
07:50:41 <merijn> EvanR: Because MongoDB is webscale
07:51:30 <EvanR> the amount of work that goes into the data storage part of a DBMS to make it "reliable" is so much, it seems like a shame to redo it in order to get a different API like mongo or redis
07:51:35 <tsahyt> speaking of persistent, has anyone here used it to write a database agnostic app, such that the user has a choice of backends?
07:51:43 <EvanR> seems like the storage part would have been solved somehow
07:51:49 <EvanR> and you can put whatever interface you want
07:52:44 <EvanR> least common denominator of a variety of *different* APIs as another API seems to be backwards
07:53:02 <EvanR> database-speaking
07:53:28 <EvanR> now you lose the benefit of different apis and different storage
08:10:36 * hackage ngx-export 1.0.1 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-1.0.1 (lyokha)
08:30:41 <ertes-w> merijn: sure, the design decisions make sense, but persistent is a good summary of what happens if you try to unify too many concepts =)
08:31:03 <merijn> ertes-w: I didn't say it was a good reason, frankly I think it's dumb as hell
08:32:02 <ertes-w> agreed
08:42:55 <jchia_> Is there an operator or fairly standard function that is the same as (flip fmap)?
08:43:04 <metahumor> (<$>)
08:43:10 <metahumor> eh wait
08:43:10 <glguy> <&>
08:43:12 <metahumor> yeah that
08:43:45 <jchia_> glguy: Thanks
09:06:29 <hux> hey guys
09:06:51 <hux> I have a question about the base lib, why would head function not return a Maybe ?
09:07:07 <shapr> hysterical raisins
09:07:18 <shapr> aka, poor design choices in the distant past
09:07:45 <shapr> hux: there's a Safe package that has readMy, headMay, and that kind of thing.
09:07:55 <glguy> base already has listToMaybe
09:08:11 <hux> shapr: thanks for the explanation
09:08:21 <hux> glguy: will look at it :)
09:09:10 <iqubic> anyone here use dante for emacs to edit haskell code?
09:09:37 <shapr> I tried it, but as far as I can tell, it doesn't let me dump my buffer into ghci
09:10:04 <iqubic> I can't seem to get flycheck to work with dante
09:11:02 <iqubic> not sure if this is is a user error or what though.
09:12:42 <iqubic> Also, it seems that Dante requires an internet connection to work, which seems like a design flaw.
09:19:29 <infandum> I'm storing a large tree structure in JSON using aeson. I'm loading
09:19:30 <infandum>            it with aeson as well. The loading step, however, takes up a ton of
09:19:30 <infandum>            memory (393,484,974,360 bytes) from the input tree file (876MB).
09:19:33 <infandum>            With profiling enabled, I see that all 85-90% allocation and time
09:19:35 <infandum>            are from internal Data.Aeson or Data.Attoparsec functions. Is there
09:19:38 <infandum>            any way to fix this?
09:19:41 <infandum> Gah, sorry about that.
09:20:37 * hackage tasty-quickcheck 0.9.2 - QuickCheck support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-quickcheck-0.9.2 (RomanCheplyaka)
09:22:41 <glguy> infandum: Are you just looking at "bytes allocated in the heap" ?
09:23:02 <glguy> Because I assume you didn't have 393GB resident
09:23:30 <joebetz> is it possible for all haskell entities (i.e., all types and functions) to be sorted using the mathematical definition of a category?
09:25:25 <joebetz> the main reason FP languages lack a good GUI is that unlike OO, there's no class hierarchy, so no higher level structures to represent. and modules are just namespaces, so not a good substitute. but if everything belonged to a category in the same way that everything in OO belonged to a class, that wouldn't be a problem.
09:26:01 <infandum> glguy: It's on a server, looks like a max of 60gb resident at peak usage.
09:26:58 <infandum> Apparently it may be because aeson has to read in the entire object as it's a single giant object. I don't know an alternative though...
09:27:56 <glguy> For processing such an oversized json file you'd want to try to do some stream processing rather than completely parsing it into memory only to process it later
09:28:28 <infandum> glguy: But it's a single tree object -- how can I stream a single object?
09:30:00 <glguy> The stream will have elements like "open list" and "close list", the whole thing gets flattened to open, close, and data elements
09:30:16 <infandum> It's that smart?
09:30:24 <glguy> That's the definition of it
09:30:39 <glguy> aeson isn't a stream processing library for json
09:31:14 <marigold> Who knows,is it possible to create a Functor instance for a type with two parameters,such as Either?
09:31:26 <glguy> Either has a functor instance already
09:31:41 <glguy> instance Functor (Either a) -- Defined in ‘Data.Either’
09:31:46 <infandum> glguy: Interesting. Well in that case I have no more excuses to avoid my issue with the Streaming library.
09:32:52 <cocreature> infandum: what are you doing with the json?
09:33:13 <infandum> cocreature: Loading the tree from it to work with it downstream.
09:33:55 <cocreature> I was more referring to the operations that you are performing on it. whether you can avoid loading things in memory heavily depends on those
09:34:51 <infandum> Uh, converting it to another formatted tree, flattening, then plotting.
09:37:07 * hackage serokell-util 0.6.0 - General-purpose functions by Serokell  https://hackage.haskell.org/package/serokell-util-0.6.0 (shersh)
09:38:41 <infandum> glguy: Would the streaming work? If it's streaming a type (say (Of Tree)), there is a giant tree, that wouldn't work right?
09:39:04 <glguy> streaming is a completely different paradigm, you have to process the data as you go
09:39:08 <glguy> you don't build up the whole tree
09:42:04 <infinisil> Umm, why are some docs just not available in hackage?
09:42:20 <infinisil> E.g. the serokell-util one posted by hackage just above
09:42:27 <MarcelineVQ> too new to have the docs generated
09:42:41 <hyperisco> you can generate the docs yourself and upload them
09:42:55 <infinisil> Oh, but hackage does this for you if you don't do it?
09:43:00 <hyperisco> (if you are the package maintainer)
09:43:03 <infinisil> it just takes a while?
09:43:10 <monochrom> In some cases the doc building server is just being slow. In some other cases the doc builder fails for many reasons.
09:43:52 <monochrom> If a version is more than a few days old and still no doc, you can bet it's a failure.
09:44:09 <infinisil> I see
09:44:32 <infinisil> Hmm, that doesn't sound very good though
09:45:03 <monochrom> Yeah, the really cool kids upload their docs and don't wait for the automatic doc builder.
09:45:39 <hyperisco> it is also a utility so you can correct docs without releasing a new package version
09:46:20 <monochrom> Also, I don't rely on hackage for docs, I tell cabal-install to build local docs. Bonus when cafe free wifi sucks or my version is older.
09:46:40 <MarcelineVQ> cafe free wiki is my band's name
09:46:42 <MarcelineVQ> *wifi
09:46:43 <infinisil> monochrom: how do you view them?
09:46:52 <monochrom> web browser
09:46:56 <infinisil> hmm
09:47:06 <infandum> With streaming, I can't figure out how to do a simple csv parse. I have this: x <- runResourceT $ S.toList $ S.print $ S.take 2 $ S.partitionEithers $ decodeWithErrors defaultDecodeOptions NoHeader $ B.readFile "./test.csv"  :: IO (Of [String] ()), but that results in hGetBufSome: illegal operation (handle is closed).
09:47:13 <infinisil> i would've hoped some man page thing or so, i don't like the web
09:47:38 <monochrom> Does an HTML file right there on your very own hard disk count as web? :)
09:47:44 <MarcelineVQ> you can read them with  less  if you likess
09:47:53 <monochrom> Yeah that too. Also elink.
09:48:12 <hyperisco> I think all the $ is breaking it
09:48:15 <infinisil> monochrom: well i need to run a browser to view it, which is like the slowest and most battery consuming app by far on my computer
09:48:22 <monochrom> But then that just adds "less" and "elink" to the collective of "web browser".
09:48:50 <monochrom> I heard that Microsoft Edge is the most energy-efficient.
09:48:59 <MarcelineVQ> infinisil: you might like lynx then like monochrom is saying
09:49:14 <monochrom> Err, OK, not more than elinks. But more than Chrome.
09:49:38 <infinisil> eh, i've tried terminal browsers a couple times, it sucks (imo)
09:49:40 <monochrom> I don't like lynx. And it is not because of text mode. Cf. I prefer elinks when in text mode.
09:49:42 <MarcelineVQ> oh is elink different thank lynx, never thought about it, somehow always lumped them together
09:50:24 <monochrom> lynx requires you to memorize unmemorizable keymapping in practice. elinks at least has a browsable menu.
09:50:46 <MarcelineVQ> in my water-based computing unit lynx sounded like the cool offspring of elink
10:21:39 <sudoreboot[m]> Can anyone tell me why it appears I need a .cabal file when creating a nix derivation?
10:22:04 <sudoreboot[m]> Doesn't my default.nix suffice?
10:25:07 * hackage QuickCheck 2.11.2 - Automatic testing of Haskell programs  https://hackage.haskell.org/package/QuickCheck-2.11.2 (NickSmallbone)
10:25:34 <qmm> how might i extract out Foo $ Bar from "foo `elem` map  Just [ Foo $ Bar Baz, Foo $ Bar Quz, Foo $ Bar Zoo ]"
10:27:25 <nisstyre> sudoreboot[m]: shouldn't you ask that in the nix channel?
10:27:31 <qmm> "foo `elem` map (Just Foo $ Bar $) [Baz, Quz, Zoo]" isn't valid, but is close to what i want
10:27:41 <nisstyre> or are you thinking of the nix integration that stack has?
10:27:57 <mnoonan> qmm: "foo `elem` map (Just . Foo . Bar) [Baz, Quz, Zoo]"
10:27:57 <sudoreboot[m]> nisstyre: I don't see why it's more appropriate in there as it's more about haskell + cabal than just nix
10:28:13 <qmm> mnoonan: composition. thank you
10:28:20 <nisstyre> but nix doesn't depend on cabal and cabal doesn't depend on nix
10:28:31 <nisstyre> what's asking you to create a .cabal directory?
10:28:59 <sudoreboot[m]> nisstyre: Not directory, cabal file
10:29:09 <nisstyre> ok, but what's the command you're running?
10:29:23 <sudoreboot[m]> `Setup: No cabal file found.` is the message I get
10:29:25 <dmwit> qmm: The mechanical translation is ```foo `elem` map (\x -> Just $ Foo $ Bar x) [Baz, Quz, Zoo]```. But the idiomatic transformation is what mnoonan said.
10:29:33 <sudoreboot[m]> `nix-build release.nix --show-trace`
10:29:47 <nisstyre> and the derivation you're trying to run?
10:30:21 <sudoreboot[m]> In my `release.nix` I have my `nix-build release.nix --show-trace` function
10:30:34 <sudoreboot[m]> Oops misspasted
10:31:04 <sudoreboot[m]> s/`nix-build release.nix --show-trace`/`pkgs.haskellPackages.callPackage ./default.nix { }`/
10:31:17 <nisstyre> what's in default.nix though?
10:32:26 <sudoreboot[m]> https://privatebin.net/?c2291ae02e1c598c#MjQK0k8TfE60VwAil1K4pFGeGdvayd1Is/JwmlpUagY=
10:33:09 <nisstyre> could it be an issue with one of those packages?
10:33:15 <nisstyre> try removing them one by one
10:33:47 <nisstyre> also, do you need to pass "base" as a dependency?
10:34:30 <sudoreboot[m]> nisstyre: I don't think they are the problem. Here's the output: https://privatebin.net/?2e80ffdedd65cef2#ppow78KvyvrT54YgqYooW+hTwysTVmcCNRnPYySITko=
10:35:03 <sudoreboot[m]> When trying to build it specifically says:
10:35:04 <sudoreboot[m]> > Setup: No cabal file found.
10:35:04 <sudoreboot[m]> Please create a package description file <pkgname>.cabal
10:35:06 <lambdabot>  <hint>:1:28: error:
10:35:06 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:35:12 <nisstyre> "Please create a package description file <pkgname>.cabal" so there's no cryptokeeper.cabal file or whatever
10:35:56 <sudoreboot[m]> nisstyre: That's what I'm saying.
10:36:14 <sudoreboot[m]> Why is a .cabal file necessary when I have my nix derivation?
10:36:17 <nisstyre> so why don't you try making one?
10:36:32 <nisstyre> sudoreboot[m]: nix doesn't know how to build Haskell code
10:36:32 <ShowMeDaWea> hey, could somebody maybe help? I'm trying to find a way to use mutable maps, I'm trying to use STRef with a regular Map in it but can't figure out the syntax
10:36:45 <sudoreboot[m]> It's not that I haven't considered making one, it's that I want to know why it's needed
10:36:50 <nisstyre> it just knows what you've previously built has a certain hash
10:36:55 <nisstyre> and it executes the derivation
10:37:35 <wedify> i feel really dumb but can someone help me understand why this code for calculating slope does not work correctly? http://lpaste.net/361583
10:37:43 <sudoreboot[m]> As far as I can see, everything Nix needs to know is in the derivation. It has the compiler, the versions, the libraries, the flags, everything
10:38:54 <nisstyre> sudoreboot[m]: https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/generic-builder.nix
10:39:43 <sudoreboot[m]> nisstyre: I've looked at that. Is there anything specific I missed?
10:39:46 <nisstyre> sudoreboot[m]: it looks like it tries to fetch a cabal file from hackage if one exists
10:39:57 <ShowMeDaWea> wedify what error does it return ?
10:39:59 <nisstyre> so that probably doesn't exist I'm guessing
10:40:51 <mnoonan> wedify, -12345 < 0.0001 :)
10:40:51 <nisstyre> or youre package name and version are wrong maybe
10:40:57 <qmm> dmwit: that was helpful. thank you
10:40:57 <nisstyre> *your
10:41:32 <wedify> mnoonan: omg lol
10:41:41 <wedify> knew it was something simple
10:42:31 <nisstyre> sudoreboot[m]: doesn't look like there is a cryptokeeper package on hackage
10:42:38 <nisstyre> so you'd have to build this from source
10:42:58 <nisstyre> manually that is
10:43:19 <sudoreboot[m]> nisstyre:  It's not a published package. It's a local toy project
10:43:51 <nisstyre> sudoreboot[m]: then you'll have to create a .cabal file
10:43:59 <nisstyre> you could also just use stack
10:44:05 <nisstyre> it has nix integration already
10:44:39 <sudoreboot[m]> nisstyre: Thanks but I'm not looking for solutions to building it, I'm curious about why nix isn't enough
10:45:09 <nisstyre> because nix isn't a haskell build tool
10:45:11 <geekosaur> stack would still require the cabal file, and probably a project.yaml on top
10:45:14 <nisstyre> it's for building ANY software
10:45:27 <nisstyre> you can't expect it to be smart enough to avoid that
10:48:30 <sudoreboot[m]> nisstyre: Like you said, it *is* a build tool unspecific to any particular language and it's not nix itself that's dumb or smart because it's just a language that explicitly brings together an environment with the right tools and configurations. What I'm wondering is what additional information is missing which can be found in a .cabal file.
10:49:07 <ShowMeDaWea> so... anyone know how to use Data.STRef combined with Data.Map?
10:49:31 <sudoreboot[m]> I already specified license, compiler, package deps, versions, flags and all that jazz
10:49:54 <nisstyre> sudoreboot[m]: it's not that it has any less information than it needs there it's that you just need a .cabal file to build anything with cabal
10:50:13 <nisstyre> otherwise it has no way of knowing that info
10:50:26 <nisstyre> the flags you specified are for the generic haskell module that nix has
10:50:59 <geekosaur> sudoreboot[m], more to the point, Setup.hs uses Cabal the library, which also uses .cabal files to understand dependencies. and iirc nix/haskell integration just builds a dummy cabal file from the nix derivation if one doesn't exist, because Cabal-the-library can't see nix
10:51:15 <mnoonan> ShowMeDaWea: what problem are you having?
10:51:17 <nisstyre> like you could just have a .cabal file with the bare minimum
10:51:18 <sudoreboot[m]> nisstyre: But why is cabal needed? I realize it's the standard haskell build tool, but what is it doing that can't be done in nix?
10:51:21 <nisstyre> and it would probably work
10:51:30 <geekosaur> ShowMeDaWea, you may be trying to use ST wrong
10:51:36 <nisstyre> sudoreboot[m]: I mean you could manually compile everything with ghc
10:51:48 <nisstyre> but that would be really frustrating
10:52:01 <geekosaur> you can;t "carry" data between ST "invocations"; that's the *point* of ST
10:52:27 <sudoreboot[m]> nisstyre:  Hmm, so there's an explicit dependency on cabal. Where does the Setup.hs file come from?
10:52:29 <ShowMeDaWea> I'm trying to instantiate a map in my main function, then pass it around to other functions to insert items into it, get items out and delete items
10:52:49 <ShowMeDaWea> is that possible with ST?
10:53:03 <sudoreboot[m]> I meant to ping geekosaur
10:53:06 * hackage bdcs 0.1.1 - Tools for managing a content store of software packages  https://hackage.haskell.org/package/bdcs-0.1.1 (clumens)
10:53:14 <sudoreboot[m]> I actually don't have a Setup.hs file
10:53:35 <nisstyre> sudoreboot[m]: that gets created when you do `cabal init`
10:54:04 <geekosaur> ShowMeDaWea, not if it contains STRefs
10:54:13 <geekosaur> STRef is *only* valid inside a single runST
10:54:30 <geekosaur> this restriction is why ST exists
10:54:36 <sudoreboot[m]> nisstyre: But if the dependency on cabal is in Setup.hs and I don't have a Setup.hs then I don't have a dependency on cabal. Where is the dependency on cabal that makes me unable to build using purely nix?
10:54:54 <ShowMeDaWea> yeah no, I'm not trying to put STRefs in a Map, I put a Map in an STRef to make it mutable
10:55:02 <nisstyre> the dependency on cabal is the fact that you have to run `cabal install` to build the actual code
10:55:19 <nisstyre> that's what the haskell nix module is doing
10:55:41 <geekosaur> sudoreboot[m], https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/generic-builder.nix#L93
10:55:46 <mnoonan> ShowMeDaWea: it doesn't sound like you need ST's special sauce.. why not just use State MyMap?
10:55:51 <geekosaur> the nix derivation is making a Setup.hs and a cabal file
10:56:13 <sudoreboot[m]> Alright so what I've been missing is the fact that nix is actually depending on cabal
10:56:16 <geekosaur> because tht is how nix's dependencies make their way into ghc
10:56:17 <nisstyre> it's trying to fetch the .cabal file from hackage as far as I can tell
10:56:37 <geekosaur> nix is not a magic wand that chahges every single command on your system to magically know about only what a nix derivation exposes
10:56:53 <geekosaur> nix hooks into build tools. in this case, that means cabal
10:57:11 <ShowMeDaWea> mnoonan I just googled a way to make mutable maps in haskell and that's the best answer I found
10:57:30 <ShowMeDaWea> how would it work with state?
10:57:50 <geekosaur> ShowMeDaWea, are you sure you need a mutable map?
10:58:09 <ShowMeDaWea> yeah, pretty sure
10:58:18 <geekosaur> immutable does not mean "values can't be replaced". it does mean that when you replace something, it creates a new map, sharing all the other values
10:58:41 <mnoonan> ShowMeDaWea: you'd replace functions "a -> b" that need to mutate a state type "s" with functions of the form "a -> State s b", which is more or less the same as "a -> s -> (b,s)"
10:58:42 <geekosaur> if you need a map that is available to multiple threads, you probably want a Map inside a single IORef
10:58:51 <mnoonan> original inputs and original state in, original output and new state out
10:59:10 <ShowMeDaWea> well, the purpose is to use it in a "parser" to store and be able to modify variables
10:59:43 <ShowMeDaWea> so I thought a mutable map would be best to store such variables
11:00:37 <geekosaur> again, that is not what immutable means
11:00:39 <mnoonan> it's actually problematic, possibly! what if a parse creates some new variables and then decides it needs to backtrack, for example.
11:01:29 <ShowMeDaWea> ok, no mutability needed, understood :)
11:01:45 <mnoonan> the simplest thing is to just thread in the environment (variable mapping or whatever) as an argument to each parser component, and have each component also return the updated environment
11:02:04 <ShowMeDaWea> so what would the best alternative be then? a Map with a State or inside an IORef?
11:02:18 <mnoonan> just a plan vanilla Map
11:02:19 <ShowMeDaWea> oh so none off that?
11:02:22 <mnoonan> *plain
11:02:27 <ShowMeDaWea> just pass it around everywhere
11:02:30 <mnoonan> yeah
11:02:47 <mnoonan> and if you eventually get sick of that, you can mechanically refactor it to use State
11:02:51 <sudoreboot[m]> geekosaur: I don't know what you're assuming I think there's any magic involved. I'm ignorant of what makes nix so dependent on cabal when one could presumably write a builder expression that only uses ghc, considering nix uses packages from nixpkgs and not hackage, stackage or anything else
11:03:09 <geekosaur> sudoreboot[m], you are assuming ghc magically sees only the nix derivation
11:03:11 <sudoreboot[m]> s/what you're/why you're/
11:03:19 <ShowMeDaWea> I'll try that, thanks :)
11:03:19 <geekosaur> in fact, ghc is promiscuous and will use antthing it can find
11:03:35 <geekosaur> which is why cabal and stack exist, to force it to use only what they expose to it
11:03:42 <sudoreboot[m]> geekosaur: I'm not assuming ghc sees *anything* outside of its command flags and environmental variables
11:03:57 <geekosaur> so nix is using cabal instead of trying to reverse engineer cabal and do the same itself
11:04:11 <geekosaur> ...
11:04:25 <geekosaur> ok, yes, you are explicitly passing every library to it. then why do you need nix?
11:04:28 <nisstyre> that's what I said, basically, it would be a waste of time
11:04:38 <geekosaur> otherwise, yes, you are making assumptions about how ghc finds libraries
11:04:45 <geekosaur> and those assumptions are wrong
11:05:16 <nisstyre> the value in using nix is that you get confidence in knowing that two builds have the same hash, etc
11:05:49 <sudoreboot[m]> Nix is told explicitly exactly which libraries I depend on in the derivation, and as such would let ghc know which they are and where they are located....?
11:06:34 <sudoreboot[m]> Why would ghc "magically" try and find libraries? Why would you presume I think that?
11:06:36 * hackage gnuplot 0.5.5 - 2D and 3D plots using gnuplot  https://hackage.haskell.org/package/gnuplot-0.5.5 (HenningThielemann)
11:07:37 <geekosaur> sudoreboot[m], how do you think it tells ghc that?
11:07:46 <geekosaur> the answer is: it builds a Setup.hs and cabal file
11:08:06 <geekosaur> nix is not magical. it does not reach inside ghc's guts and tell it how to find things
11:08:17 <geekosaur> it uses ghc's existing mechanisms. which means Cabal.
11:08:22 <sudoreboot[m]> Ghc takes source code and produces object code or machine code, I don't see why it would also pretend to be anything other than that, and as such, nix or cabal or stack (which also uses cabal?)  would handle locating and making available all dependencies and instructions and handing them over to ghc
11:09:03 <geekosaur> if ghc has not been told via Cabal where to look, it looks fir or itself. nix cannot control that "looks for itself'.
11:09:17 <geekosaur> *it looks for them itself
11:10:04 <sudoreboot[m]> geekosaur: You keep letting me know there's no magic involved. I'm not staying at hogwarts, I get how things work on a higher level. I'm trying to understand why cabal is needed when obviously it results in duplication of effort...
11:10:12 <geekosaur> but nix can only tell it about nix-managed dependencies, so if you have an additional dependency then you need to create a manual cabal file
11:10:24 <geekosaur> sudoreboot[m], you are deeply confused
11:10:31 <geekosaur> cabal *is* the effotty
11:10:32 <sudoreboot[m]>  > if ghc has not been told via Cabal where to look, it looks fir or itself. nix cannot control that "looks for itself'.
11:10:33 <sudoreboot[m]> Which is exactly what I assumed Nix would be great at doing *instead* of cabal
11:10:33 <geekosaur> effort
11:10:51 <barrucadu> sudoreboot[m]: Why would nix reinvent a wheel already solved by cabal?
11:11:04 <geekosaur> "nix cannot control" does not mean "nix automatically controls"
11:11:06 <barrucadu> People don't transcribe makefiles into nix expressions
11:11:10 <[exa]> sudoreboot[m]: but well, cabal is the primary dependency database. You can copy half of cabal codebase to nix and pretend it's not cabal
11:11:11 <geekosaur> it  means "nix cannot control"
11:11:41 <nisstyre> sudoreboot[m]: if you were building a Ruby or Python program with nix, then nix would still use gem/bundler/etc or pip, to build the respective programs
11:12:36 * hackage QuickCheck 2.11.3 - Automatic testing of Haskell programs  https://hackage.haskell.org/package/QuickCheck-2.11.3 (NickSmallbone)
11:13:30 <sudoreboot[m]>  > sudoreboot[m]: Why would nix reinvent a wheel already solved by cabal?
11:13:31 <sudoreboot[m]> It's fine to use existing tools, I don't mind it using cabal under the hood. But why do I need a .cabal file when it has **the exact same information I'm providing in my default.nix**?
11:13:44 <geekosaur> because ghc does not read default.nix
11:13:51 <geekosaur> something needs to get that information into ghc
11:14:02 <geekosaur> that something is cabal; therefore nix converts your default.bix into a cabal file
11:14:16 <nisstyre> the only case I can see where it would do everything in the nix derivation is with gcc, but even then it would still leverage tools that help with that
11:14:28 <`Guest00000> type refactoring........
11:15:40 <nisstyre> unless you're using something like autoconf on top of nix I guess
11:16:05 <sudoreboot[m]>  > because ghc does not read default.nix
11:16:06 <sudoreboot[m]> I'm past that. My question has gone from "why is it asking for a .cabal file" to "why would *I* need to create a .cabal file when *I'm* not using cabal? If *Nix* is using cabal, then it can create it's own internal .cabal using the information I provided it
11:16:26 <geekosaur> only up to a point. you're also using a dependency that is not managed by nix
11:16:39 <geekosaur> ghc still has to be told about *that* dependency
11:16:46 <geekosaur> nix doesn;t manage it, so it can;t tell ghc about it
11:17:50 <sudoreboot[m]>  > ghc still has to be told about \*that\* dependency
11:17:50 <sudoreboot[m]> What dependency?
11:19:09 <sudoreboot[m]> I mean, if I say `  executableHaskellDepends = [ http-conduit aeson mtl ];` in default.nix, what is there more to know? Nix knows what that package is, where it is, what version it is...
11:19:48 <dmj`> nix builds haskell packages with a Setup.hs script. It constructs an immutable ghc-pkg list before hand, so nix will fetch prebuilt deps. It uses the Cabal library, not the executable. You’d never call ‘cabal install’ when using nix for example.
11:22:04 <sudoreboot[m]> dmj`: What is the cabal lib doing there that requires the use of a .cabal file?
11:23:00 <sudoreboot[m]> lol the ` in your name messes up the formatting of mentions in riot
11:24:33 <dmj`> sudoreboot[m]: it will enforce versions, flags, etc. So if your version of nixpkgs has an old lens version, and your cabal file says to use a new one, your build will fail.
11:25:45 <glguy> cabal files define exported vs private modules, source directories, c source files
11:25:55 <glguy> and lots more, it's not just about dependencies
11:28:13 <sudoreboot[m]> dmj`: Ah, so it's doing a pretty important job to make sure it all works together. I wonder if nix create a temp .cabal file for this though so you only need a default.nix in your project (theoretically - of course it would exclude people not comfortable with nix from building)
11:29:01 <sudoreboot[m]> s/nix create/nix could create/
11:29:20 <[exa]> btw what's so good about nix?
11:29:56 <sudoreboot[m]> The reason I'm wondering about this is because of the duplication of information involved with maintaining both a .cabal file and a nix derivation (and maybe even a stack.yaml)
11:30:39 <nisstyre> [exa]: it's very useful for deploying code because it gives you a guarantee that if your package changes, then it won't break other packages (each build goes to a directory under /nix with a hash in the directory name)
11:30:47 <[exa]> sudoreboot[m]: btw can't you create a single file to autogenerate all 3 of them? maintaining anything by hand is awkward
11:30:56 <nisstyre> so you can have packages that depend on completely different versions of things than other ones
11:31:05 <sudoreboot[m]> [exa]: It's not necessarily better than any other option, it's just a way of building an isolated, immutable environment and has a bunch of nice features for building, CI, project management in general
11:31:12 <nisstyre> i.e. you could run every version of ghc on the same system with no conflicts
11:31:16 <glguy> stack.yaml already has a tool for generating them
11:31:54 <sudoreboot[m]>  > btw can't you create a single file to autogenerate all 3 of them? maintaining anything by hand is awkward
11:31:55 <sudoreboot[m]> There are tools for converting .cabal files to nix expressions and to make stack use nix under the hood
11:31:59 <nisstyre> glguy: yeah that's what I said before
11:32:03 <[exa]> nisstyre: that's not possible with cabal alone?
11:32:12 <nisstyre> [exa]: no it's definitely not
11:32:15 <sudoreboot[m]> They are just extra steps and are only rewriting the same information into different formats
11:32:18 <nisstyre> with cabal sandboxes maybe
11:32:25 <glguy> stack.yaml isn't the same information as a cabal file
11:32:29 <nisstyre> but it's still not as nice an experience IMO
11:33:14 <[exa]> oh so.
11:33:25 <glguy> Multiple versions of GHC work side-by-side well, they don't interact with each other
11:33:48 <nisstyre> [exa]: nix doesn't assume *anything* about your system
11:33:56 <nisstyre> that means it needs to know every dependency
11:34:11 <nisstyre> including C libraries, etc
11:34:31 <dmj`> sudoreboot[m]: if you don’t want to use a cabal file in your project, you can get a ghc that has all the deps you want from nixpkgs
11:34:40 <[exa]> except some baseline like posix, I guess
11:34:45 <dmj`> sudoreboot[m]:  https://gist.github.com/6191f39612d5f9359cfe9b53ff57c3c6
11:34:54 <nisstyre> [exa]: I can't remember if it assumes libc or not
11:34:58 <[exa]> (sorry, posix-like kernel api)
11:35:03 <dmj`> sudoreboot[m]: but I’d recommend pinning your version of nixpkgs
11:35:08 <[exa]> good to know though
11:35:19 <nisstyre> yeah it definitely uses its own libc from what I can tell
11:35:39 <sudoreboot[m]>  > stack.yaml isn't the same information as a cabal file
11:35:40 <sudoreboot[m]> You're right, it's not accurate to say they do
11:35:41 <[exa]> it has to if it breaks FHS
11:36:55 <sudoreboot[m]>  > sudoreboot[m]:  https://gist.github.com/6191f39612d5f9359cfe9b53ff57c3c6
11:36:56 <sudoreboot[m]> Hehe that is definitely straight forward
11:36:59 <nisstyre> [exa]: it can also use existing versions of things, so if program A and program B both depend on a specific version of a tool, then it just does a hash of the nix derivation and checks if it exists
11:37:06 <nisstyre> if it exists then no need to do anything else
11:37:19 <[exa]> yeah, unlike docker :]
11:37:37 <nisstyre> yeah so it is much more lightweight than docker
11:37:40 <[exa]> I'm reading about that. Got an impression that the 'responsible way of updating' is more of a selling feature
11:37:51 <sudoreboot[m]>  > sudoreboot[m]: but I’d recommend pinning your version of nixpkgs
11:37:51 <sudoreboot[m]> It's the biggest pain right now I think, not being able to define a specific version of everything
11:38:48 <nisstyre> [exa]: it also makes rollbacks pretty damn easy
11:39:19 <nisstyre> which is a major selling point for those of us in the business of doing deployments
11:40:18 <dmj`> sudoreboot[m]: yea, well, cabal does that for haskell versions if you abide by the PVP. But nix encompasses versioning for third party deps, and even the kernel as well (if you’re on nixos). You can use nix to fetch nix and pin that way
11:41:16 <dmj`> { pkgs ? import (import <nixpkgs> {}).fetchFromGitHub { repo = “nixpkgs”; owner = “NixOS”; rev = “..”; sha256 = “..”; }), .. }
11:49:07 * hackage git-annex 6.20180112 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20180112 (JoeyHess)
11:49:26 <`Guest00000>  i'm dying refactoring my types
11:49:31 <[exa]> nisstyre: I was a solaris admin before, kindof lack understanding for the "devops" now :D
11:49:43 <[exa]> but yeah, it helps a lot
11:50:28 <nisstyre> [exa]: yeah you were much more old school than I am
11:53:36 * hackage attoparsec 0.13.2.1 - Fast combinator parsing for bytestrings and text  https://hackage.haskell.org/package/attoparsec-0.13.2.1 (BenGamari)
12:12:27 <CuriousErnestBro> How good is gui stuff compared to Qt?
12:13:37 * hackage hlint 2.0.13 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.0.13 (NeilMitchell)
12:21:38 <CuriousErnestBro> Was there a Haskell summer of code this summer?
12:22:05 <CuriousErnestBro> (and will there be one this year?)
12:24:29 <Yotam_> I get openDirStream: does not exist when I try to `stack exec App`, any help?
12:24:49 <monochrom> There was a Haskell Summer of Code recently. The future is still unknown but they are applying for Google Summer of Code again (more money).
12:26:24 <geekosaur> Yotam_, I'd start by making sure $PATH doesn't have any missing directories in it (although I'd also argue that would be a bug in stack)
12:27:33 <Yotam_> geekosaur: it's on nixos with nix (I need to manualy say which libraries I'm using)
12:27:59 <geekosaur> ...what exactly does that have to do with what I said
12:29:17 <Yotam_> That I don't know which directory I'm looking for
12:29:39 <geekosaur> sorry, by missing I meant "does not exist"
12:29:50 <iqubic> Anyone use Dante on Emacs?
12:29:52 <geekosaur> because that error *dounds* like it hit a nonexistent directory while looking for the app
12:29:57 <geekosaur> er, sounds
12:30:04 <Yotam_> oh ok
12:31:23 <geekosaur> but I don't know for certain. I'd probably be using 'strace -f' myself to try to verify what's going on, because that error message is missing anything useful (not your fault)
12:31:37 <iqubic> Who here uses Emacs? And how do you configure it?
12:32:40 <Yotam_> iqubic: https://github.com/yohad/NixOS/blob/master/emacs.nix
12:36:40 <iqubic_> So I can't get Dante and Flymake to work.
12:36:49 <Yotam_> I didn't try
12:36:59 <iqubic_> https://github.com/jyp/dante
12:37:14 <iqubic_> Yeah, so that's a pain in the butt.
12:37:34 <Yotam_> https://github.com/jyp/dante#installation
12:38:08 <iqubic_> I have done that. Flymake isn't working for me.
12:38:29 <iqubic_> I'm not trying to use hlint, just regular flymake.
12:38:54 <MarcelineVQ> flycheck isn't flymake is it?
12:39:05 <Yotam_> right
12:39:36 <iqubic_> I'm really stupid. Flycheck \= Flymake. I have meant to be writting Flycheck since I joined.
12:41:13 <iqubic> Like I type in something that is clearly gibberish and save the file. Flycheck doesn't mark it as wrong.
12:41:58 <iqubic> Also, I don't think that dante has support for launching an interactive REPL.
12:43:24 <iqubic> All it has is that REPLoid thingy.
12:48:27 <iqubic> So I'm not sure how I can fix / debug this.
12:53:36 * hackage htoml-megaparsec 1.1.0.0 - Parser for TOML files  https://hackage.haskell.org/package/htoml-megaparsec-1.1.0.0 (vmchale)
12:54:38 <shapr> iqubic: I went back to using interactive-haskell-mode and cabal new-repl
12:56:22 --- mode: ChanServ set +o dcoutts
12:56:24 --- mode: ChanServ set -o dcoutts
12:56:33 <dcoutts> just checking :-)
12:57:36 * hackage htoml-megaparsec 1.1.0.1 - Parser for TOML files  https://hackage.haskell.org/package/htoml-megaparsec-1.1.0.1 (vmchale)
13:06:36 * hackage tldr 0.2.5 - Haskell tldr client  https://hackage.haskell.org/package/tldr-0.2.5 (psibi)
13:24:03 * merijn sighs
13:24:17 <merijn> I hate persistent's constraints with a fiery passion...
13:24:39 <glguy> a sigh doesn't feel that fiery to me...
13:25:04 <merijn> glguy: That's because we're 12 hours of frustration in and depression is starting to kick in >.>
13:26:20 <merijn> glguy: They go through all this effort to have a polymorphic backend class, only to restrict it in such a way that you can never define any extensions/variations on it...
13:26:56 <MarcelineVQ> 'merijn looked up from his studies with bleary eyes, all around was ash, yes there had been fire once'
13:27:00 <merijn> Like...why?!
13:30:37 <metahumor> merijn: Why? For the glory of satan, of course! https://i.kinja-img.com/gawker-media/image/upload/s--s63D65iO--/c_scale,f_auto,fl_progressive,q_80,w_800/fio6nkh9rdtmio81zt9i.png
13:32:26 <dpren> when talking about `Reader`, what exactly is meant by "environment"?
13:33:10 <merijn> A pox upon your family "IsSqlBackend" constraint! May the seven dogs of hell sit on your chest and bark at your soul...
13:35:07 <geekosaur> dpren, a Reader is a wrapper around a function that takes a parameter of some specific type. runReader injects a value of that type into the wrapped function. that value is the environment
14:02:36 * hackage generic-random 1.1.0.2 - Generic random generators  https://hackage.haskell.org/package/generic-random-1.1.0.2 (lyxia)
14:16:23 <merijn> hmm, am I evil if I simply use a nullPtr in cases where I can't get the right pointer?
14:17:08 <[exa]> not necessarily evil
14:17:12 <[exa]> but certainly java
14:17:38 <merijn> Alternatively, if someone is better than me at subverting Haskell APIs, I'm all ears...
14:17:49 <[exa]> :D
14:18:34 <[exa]> is it still about the IsSqlBackend class?
14:18:37 * hackage live-sequencer 0.0.6.1 - Live coding of MIDI music  https://hackage.haskell.org/package/live-sequencer-0.0.6.1 (HenningThielemann)
14:19:01 <merijn> [exa]: Until I find a work around everything is about that roadblock >.<
14:19:37 <widp> Is the "functional reactive video for musical programming" video abou tidal?
14:23:22 <[exa]> merijn: mind elaborating on what is the effort going to achieve?
14:24:21 <merijn> [exa]: I have this to let people access the underlying SQLite database pointer: https://github.com/yesodweb/persistent/pull/772/files
14:25:23 <[exa]> fffffffffffff
14:25:37 <merijn> [exa]: However, the "withSqliteConn", etc. function in https://hackage.haskell.org/package/persistent-sqlite-2.6.4/docs/Database-Persist-Sqlite.html don't give you access to the Connection, so I'm trying to make a version of the API the boils down to (Connection, SqlBackend), but all of persistent's bracket functions like withSqlPool insist on an IsSqlBackend instance :\
14:27:32 <[exa]> I see myself craving for a quick dynamic_cast<...>
14:40:28 <[exa]> merijn: what about patching Database.Persist with a small class hierarchy of IsSqlBackend a => IsSqliteBackend a etc? except you don't want to break persistency logic
14:41:33 <merijn> [exa]: Doesn't change the fact that all the persistent functions require IsSqlBackend, which requires I can write "SqlBackend -> MyType"
14:41:48 <merijn> [exa]: [exa] That's what kills me
14:42:02 <merijn> [exa]: Because that function doesn't allow for any smuggling of extra values
14:44:45 <[exa]> merijn: does it require the accepted functions to be generic over all IsSqlBackends ?
14:45:13 <[exa]> accepted = parameter 2 of withSqlitePool
14:45:41 <merijn> It's not required, I think, but makes it rather limited
14:49:25 <merijn> I think I might've a workable solution (i.e. reimplement half the withX functions from persistent to wrap things
14:49:30 <merijn> Awful, but it works
14:51:06 * hackage snaplet-persistent 0.5.1 - persistent snaplet for the Snap Framework  https://hackage.haskell.org/package/snaplet-persistent-0.5.1 (MichaelXavier)
14:59:36 * hackage attoparsec 0.13.2.2 - Fast combinator parsing for bytestrings and text  https://hackage.haskell.org/package/attoparsec-0.13.2.2 (BenGamari)
15:02:20 <CuriousErnestBro> guys
15:04:35 <royal_screwup21> when I did xs ++ ys ++ zs, why is binding done to the right like so xs ++(ys ++ zs) and not (xs++ys)++zs
15:05:02 <Peaker> royal_screwup21, because of the fixity of ++ which is set that way because it is more efficient
15:05:03 <royal_screwup21> I read that it's more efficient but I don't see how
15:05:50 <dsal> xs ++ (ys ++ zs) is lazier
15:05:51 <Peaker> royal_screwup21, xs ++ ys     must "copy" the entire xs list - so it replace its final empty list cell with a reference to ys.  It doesn't touch "ys".  So its runtime/memory complexity is O(len(xs)) (regardless of ys)
15:06:39 <royal_screwup21> ah
15:06:51 <Peaker> So (xs ++ ys) ++ zs   must copy "xs" twice and "ys" once, whereas (xs ++ (ys ++ zs)) must copy "xs", "ys" once each
15:07:41 <troydm> I have define a custom C function in cbits/mycode.c and added c-sources: cbits/mycode.c to package.yaml, but linker failes not finding the function what did I missed?
15:08:06 <Peaker> also, that's why foldr (++) []   is linear to the sum of sizes of all the lists, whereas foldl (++) []  is N^2
15:08:13 <merijn> troydm: Got a public repo somewhere?
15:08:27 <Peaker> troydm, the .cabal file should have it
15:08:30 <royal_screwup21> in (xs++ys) ++ zs, why is ys copied at all? Isn't it referenced to the final empty list cell in xs?
15:08:58 <Peaker> just wrote a little "git-cache" thingie, that lets you e.g: "cabal build" via "git-cache" - and if you check out an old git version, it'll restore the build result from cache. Very useful for bisects :)
15:09:27 <merijn> Peaker: Now add new-build support ;)
15:09:44 <Peaker> merijn, you just give it an arbitrary command to execute, and a list of output files to cache for it
15:09:54 <Peaker> royal_screwup21, The (++ zs) call must copy the (xs++ys) list to set the tail to "zs"
15:10:09 <Peaker> merijn, (it's not specific to cabal in any way)
15:11:29 <EvanR> ghc doesn't know xs++(ys++zs) is equivalent and more efficient
15:11:41 <EvanR> or does it
15:11:51 <EvanR> due to RULES
15:16:58 <nate1> Can Reflex be used for a native program? Any examples I've found have been for Reflex-DOM and a website
15:18:49 <boj> nate1: yep, you can build native apps
15:20:13 <Peaker> Awesome, no more tiresome, slow "git bisects"! :-)
15:20:26 <royal_screwup21> I'm trying write a function that returns Nothing if any element in given list is Nothing. Here's what I tried: https://thepasteb.in/p/vghO860X6OjF3 It compiles but throws an error at runtime (the error's in the pastebin as well)
15:21:32 <merijn> :t sequence -- <-- royal_screwup21
15:21:33 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
15:21:44 <troydm> Peaker: I don't understand your question
15:21:53 <merijn> :t sequence `asAppliedTo` [Nothing]
15:21:55 <lambdabot> [Maybe a] -> Maybe [a]
15:22:13 <Peaker> troydm, which one?
15:22:27 <troydm> > troydm: Got a public repo somewhere?
15:22:30 <lambdabot>  <hint>:1:37: error:
15:22:30 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
15:22:45 <Peaker> merijn, why didn't AMP/FTP generalize that one to Applicative?
15:22:55 <royal_screwup21> merijn: just realized the test case was mJusts Just [1,2,Nothing] -- not mJusts [1,2Nothing]
15:22:57 <merijn> Peaker: Hysterical raisins
15:23:01 <troydm> Peaker: well anyway I see my module is being compiled to .o file
15:23:05 <merijn> Peaker: sequenceA for that
15:23:22 <Peaker> merijn, may as well have both be Applicative with a DEPRECATION for sequenceA?
15:23:29 <merijn> Sure
15:23:42 <Peaker> like 90% of "Monad" stuff in Haskell base/stdlib are actually Applicative, including *all* stuff in Control.Monad except 'join'
15:23:46 <merijn> Peaker: I'm all for more aggressive deprecation, but not everyone is me, sadly
15:23:51 <troydm> Peaker: but I'm not sure how to make stack use ghc when linking executable
15:24:23 <Peaker> troydm, that's merijn's question, not mine
15:25:13 <Peaker> merijn, can at least make sequence=sequenceA, to make the future a nicer place for eventual cleanups.. what's the point of unneeded constraints?
15:25:23 <merijn> Peaker: Don't ask me :)
15:34:23 <lyxia> Peaker: it's already the case that sequence = sequenceA  https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.Traversable.html#Traversable
15:41:17 <royal_screwup21> is there a quick way to convert a list of Just Ints to Ints? Like [Just 1, Just 2] -> [1,2]
15:43:08 <dsal> @hoogle maybeToList
15:43:09 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
15:43:09 <lambdabot> Distribution.Compat.Prelude.Internal maybeToList :: () => Maybe a -> [a]
15:43:09 <lambdabot> CorePrelude maybeToList :: Maybe a -> [a]
15:43:22 <ReinH> :t catMaybes
15:43:23 <lambdabot> [Maybe a] -> [a]
15:43:27 <dsal> Yeah, that one.
15:44:33 <ReinH> > > [Just 1, Nothing] >>= maybeToList
15:44:36 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
15:44:37 <ReinH> > [Just 1, Nothing] >>= maybeToList
15:44:40 <lambdabot>  [1]
15:44:49 <ReinH> catMaybes = (>>= maybeToList)
15:47:31 <koala_man> royal_screwup21: do you want just the Justs or do you want to also ensure that they're all Just?
15:47:58 <dsal> just the justs or justice for all?
15:48:09 <ReinH> > sequenceA [Just 1, Nothing]
15:48:13 <lambdabot>  Nothing
15:50:30 <infinisil> :t (`>>=` maybeToList)
15:50:30 <infinisil> :t (>>= maybeToList)
15:50:31 <lambdabot> error: parse error on input ‘>>=’
15:50:32 <lambdabot> [Maybe b] -> [b]
15:52:28 <royal_screwup21> okay so now I'm trying to write a function that takes in a list of Maybes and if there's a Nothing in it, the functions returns True. Here's what I tried: https://thepasteb.in/p/zmh8q2NkK8WUZ the compiler throws the follwoing error: https://thepasteb.in/p/mwh1lnLgyzPS5 I'm not sure what it means. How do I fix this?
15:53:15 <merijn> royal_screwup21: I'm guessing "isnothing :: Maybe a -> Bool"
15:53:23 <merijn> royal_screwup21: So you're comparing a Bool with Nothing
15:53:44 <royal_screwup21> holy shit
15:54:03 <merijn> royal_screwup21: Sound's like bedtime for you :p
15:55:16 <royal_screwup21> nah, let her wait for a while ;)
15:55:24 <dsal> > let isnothinglist = (Nothing ==) . sequenceA in  isnothinglist [Just 1, Just 2]
15:55:28 <lambdabot>  False
15:56:26 <glguy> any isNothing :: [Maybe a] -> Bool
15:57:01 <dsal> That's much less obnoxious
15:59:01 <dexterfoo> "But, the more I dug into object oriented programming and really dug into SmallTalk and the state of the art research with metaclasses, I came to the realization that it was this kind of voodoo brain virus that didn't have any real theoretical underpinnings. Whereas, when you look into Haskell and Curry Howard iso-morphism, and other really advanced principles in programming, you see that there is a source
15:59:03 <dexterfoo> and structure that should inspire us." -- Jan 2018, Tim Sweeney, Epic Games, Unreal Engine
15:59:17 <dexterfoo> https://www.gamasutra.com/blogs/DavidLightbown/20180109/309414/Classic_Tools_Retrospective_Tim_Sweeney_on_the_first_version_of_the_Unreal_Editor.php
15:59:39 <merijn> dexterfoo: You might be interested in Tim Sweeney's keynote at POPL a few years back
16:00:05 <merijn> dexterfoo: https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
16:01:36 <dexterfoo> merijn: i remember that. and 13 years later and he is still talking about haskell. but where is his haskell work?
16:02:01 <merijn> dexterfoo: If you look at that presentation it's pretty clear Tim Sweeney isn't going to adopt Haskell
16:02:24 <merijn> Just stealing ideas from it, which is fine, I'm not convinced Haskell is a great language for the Unreal Engine anyway
16:03:48 <dexterfoo> well this interview was from just a few days ago. and he mentioned haskell. (and not rust :D)
16:20:49 <n_blownapart> hi apologies to dm.wit who helped me on this yesterday. the last function boolsR , you can see I attempted to use traceShow (not too helpful).  please help me write the recursive steps out properly. I can do that with other recursive functions but this has other things going on. thanks : http://lpaste.net/361587
16:21:37 <n_blownapart> this is line 76,77
16:23:37 <n_blownapart> btw I understand how the first function, bools, gives the same result
16:25:41 <lyxia> n_blownapart: look at some small examples
16:26:04 <lyxia> n_blownapart: can you find something that looks like bools 2 inside bools 3
16:26:41 <n_blownapart> lyxia yes thanks, please see the following textbook screenshot :
16:26:56 <n_blownapart> https://snag.gy/APeCrT.jpg
16:27:44 <n_blownapart> still, I don't see how the recursion gives us the two copies of False False, False True  etc
16:27:55 <n_blownapart> the *initial two copies
16:28:22 <lyxia> well the recursive call is in bss
16:28:26 <lyxia> and bss is the two copies
16:29:03 <dramforever> What about an example?
16:29:08 <dramforever> Let's use strings
16:29:57 <n_blownapart> btw I'm calling the bools in the screenshot boolsR
16:30:09 <dramforever> > let bss = ["dram", "is", "talking"] in map ('+':) bss ++ map ('-':) bss
16:30:12 <lambdabot>  ["+dram","+is","+talking","-dram","-is","-talking"]
16:30:25 <dramforever> Try to understand this
16:30:30 <n_blownapart> hold on thanks
16:32:09 <n_blownapart> ok yeah I see that. ('-') is True in my case
16:32:19 <n_blownapart> * True:
16:32:30 <dramforever> Strings are not important
16:32:37 <dramforever> they're just a bit easier to read
16:35:38 <n_blownapart> but my example is different from that. we have a list of lists , where they are specifically [False, False], [False,True], [True, False], [True,True]  .. I still don't see how those are built up
16:35:58 <n_blownapart> in the case of boolsR 2
16:36:33 <n_blownapart> the screenshot example is boolsR 3 (sans the 'R')
16:36:54 <n_blownapart> dramforever: ^
16:37:18 <glguy> Your example is the same, instead of lists of lists of Char you have lists of lists of Bool
16:37:36 <dramforever> oh
16:37:55 <dramforever> Then... Let's go all Bool's!
16:38:46 <dramforever> > let bss = [[True, False], [False, True], [False, False]] in map (False :) bss ++ map (True :) bss
16:38:49 <lambdabot>  [[False,True,False],[False,False,True],[False,False,False],[True,True,False]...
16:39:03 <dramforever> I *knew* it would happen
16:39:21 <glguy> ?let data B = T | F deriving Show
16:39:23 <lambdabot>  Defined.
16:39:47 <glguy> There you go, so much savings
16:40:15 <n_blownapart> but wait, the initial two element lists [False, False] etc, are built up recursively, right?
16:40:25 <dramforever> > let bss = [[T, F], [F, T], [F, F]] in map (F :) bss ++ map (T :) bss
16:40:30 <lambdabot>  [[F,T,F],[F,F,T],[F,F,F],[T,T,F],[T,F,T],[T,F,F]]
16:40:32 <dramforever> Not in *this* case
16:40:38 <fishythefish> sure, but take their existence to be your inductive hypothesis :)
16:41:32 <n_blownapart> can we follow the recursion better, by ...
16:41:42 <n_blownapart> looking at each side of ++  ?
16:42:07 <dramforever> I want to say no
16:42:13 <dramforever> but what do you mean?
16:42:14 <fishythefish> mmm, could help
16:42:42 <fishythefish> if you understand the map (F :) bss and map (T :) bss separately, the only thing left is the concatenation
16:42:44 <n_blownapart> its 2 recursions with their own maps, on either side of ++ , which all makes a single recursive function. this is why I'm confused
16:43:09 <dramforever> Hmm
16:43:21 <n_blownapart> ie can you see why I'm confused?
16:43:31 <dramforever> Do you know 'depth first search'?
16:43:40 <fishythefish> n_blownapart: have you done recursion on binary trees before?
16:44:28 <n_blownapart> yeah fishythefish a bit; I sort of sense how this works, I'd like to be able to write it out so I'm certain I'm thinking about it properly
16:44:47 <fishythefish> n_blownapart: consider that at each node, you make not one but two recursive calls - one for each child subtree
16:44:53 <n_blownapart> no dramforever
16:45:06 <fishythefish> same concept here - you can make more than one recursive call and then combine the results
16:45:11 <n_blownapart> depth of branches in tree?
16:45:49 <dramforever> @letlpaste 361587
16:45:51 <lambdabot>  .L.hs:215:9: error:
16:45:51 <lambdabot>      Ambiguous occurrence ‘Const’
16:45:51 <lambdabot>      It could refer to either ‘Lens.Const’,
16:46:03 <dramforever> ummm, disregard that
16:46:07 <MarcelineVQ> this is an appropriate exercise for substituting recursive function calls with their bodies by hand
16:46:57 <dramforever> I still don't see why you are confused though
16:47:07 <n_blownapart> so to get [False, False]  first of all, no True: is involved there.
16:47:18 <dramforever> hmm
16:47:46 <dramforever> @let update bss = map (F :) bss ++ map (T :) bss
16:47:48 <lambdabot>  Defined.
16:47:59 <dramforever> > update [[]]
16:48:03 <lambdabot>  [[F],[T]]
16:48:21 <n_blownapart> bools (n - 1) gives us for starters: [False, False]. how?
16:48:36 <fishythefish> for what value of n?
16:48:38 <n_blownapart> * boolsR
16:49:03 <n_blownapart> sorry the book has n as ...
16:49:06 * hackage ats-format 0.1.0.27 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.27 (vmchale)
16:49:46 <dramforever> Do you understand the 'update' function?
16:49:53 <n_blownapart> boolsR 2 gives us [False, False]
16:49:54 <dramforever> > update [[]]
16:49:56 <n_blownapart> no dramforever
16:49:57 <lambdabot>  [[F],[T]]
16:50:07 <dramforever> > update (update [[]])
16:50:11 <lambdabot>  [[F,F],[F,T],[T,F],[T,T]]
16:50:55 <monochrom> @msg merijn Do you happen to know what Tim Sweeney means by lenient evaluation? Thanks.
16:50:55 <lambdabot> Not enough privileges
16:51:09 <monochrom> Oh! @tell
16:51:09 <MarcelineVQ> monochrom: tell :>
16:51:16 <monochrom> @tell merijn Do you happen to know what Tim Sweeney means by lenient evaluation? Thanks.
16:51:16 <lambdabot> Consider it noted.
16:51:19 <fishythefish> > take 3 $ iterate update [[]]
16:51:20 <MarcelineVQ> msg tells the bot to say something I think
16:51:23 <lambdabot>  [[[]],[[F],[T]],[[F,F],[F,T],[T,F],[T,T]]]
16:52:15 <n_blownapart> one moment please. the update is another thing I have to juggle now...
16:52:50 <n_blownapart> is there a way to use traceShow that gives us more than 2,1,0 ?
16:53:22 <n_blownapart> I have it with just (n)
16:54:04 <fishythefish> well, what do you want it to show?
16:54:12 <glguy> n_blownapart: Go spend some time understanding what dramforever's update function does. You'll need to be able to understand that before you will be ready to understand boolsR
16:56:04 <n_blownapart> glguy: ok thanks , one thing all before I crawl into a box...
16:58:37 <n_blownapart> map uses two functions in boolsR -  False:   and   True:     . those are appendages to two separate lists that are identical copies. those two copies are built up using 'map (False:)  blah'    and 'map (True:) boof'     ..   correct?
17:00:56 <n_blownapart> does this work on the fact that False < True   at all?
17:01:06 * hackage lucid-colonnade 1.0 - Helper functions for using lucid with colonnade  https://hackage.haskell.org/package/lucid-colonnade-1.0 (andrewthad)
17:01:31 <glguy> I don't know what your first question means and no, it has nothing to do with <
17:04:57 <dramforever> I think you are assigning too much magic
17:05:11 <dramforever> Theres's no magic with that recursion
17:05:33 <dramforever> > update (update [[]]) -- Understand this first
17:05:37 <lambdabot>  [[F,F],[F,T],[T,F],[T,T]]
17:06:25 <dramforever> update bss = map (F :) bss ++ map (T :) bss
17:06:36 <n_blownapart> thanks will do.   I'm looking at the pattern in the table. can we look at it for one sec dramforever  ?   https://snag.gy/APeCrT.jpg
17:07:14 <n_blownapart> the first recursion gives us False True False True False True False True
17:07:26 <dramforever> ummm
17:07:35 <n_blownapart> no?
17:07:41 <dramforever> the first recursion gives us four rows
17:07:53 <dramforever> gives us a single box
17:08:40 <dramforever> Then we put False before each row
17:08:59 <n_blownapart> looking down the 2 boxes from the right, we have every other, every two, every four ..
17:09:08 <dramforever> No
17:09:31 <dramforever> That's not how you're supposed to read it
17:09:50 <n_blownapart> ok
17:10:10 <dramforever> We have a 'small box to whole thing' function
17:10:18 <dramforever> It's the 'update' I just wrote
17:10:22 <dramforever> update bss = map (F :) bss ++ map (T :) bss
17:10:39 <n_blownapart> I'll look at it thanks for your patience and time
17:10:52 <dramforever> update [[F, F], [F, T], [T, F], [T, T]]
17:11:02 <dramforever> > update [[F, F], [F, T], [T, F], [T, T]]
17:11:05 <lambdabot>  [[F,F,F],[F,F,T],[F,T,F],[F,T,T],[T,F,F],[T,F,T],[T,T,F],[T,T,T]]
17:11:17 <wedify> can haskell express that i want a double between 0 and 2pi as a type?
17:11:19 <dramforever> Can you see the small box? It's right there in the argument
17:11:32 <n_blownapart> yeah
17:11:49 <dramforever> wedify: check out 'smart constructors'
17:12:13 <dramforever> n_blownapart: what about the whole thing?
17:12:24 <Munchlaxx> Anyone know why I get this error ''parse error (possibly incorrect indentation or mismatched brackets)'' with the following code
17:12:25 <dramforever> Do you recogize the output?
17:12:38 <Munchlaxx> let numbers = [1,2,3]
17:12:39 <ReinH> As a type? No.
17:12:48 <Munchlaxx>     main = do
17:12:52 <Munchlaxx>     numbers
17:13:06 <n_blownapart> yes thats the output of boolsR 3
17:13:12 <ReinH> Munchlaxx: Probably the incorrect indentation
17:13:21 <ReinH> @where layout
17:13:21 <lambdabot> http://haskell.org/onlinereport/lexemes.html#sect2.7
17:13:23 <dramforever> Munchlaxx: indent the third line
17:13:36 <dramforever> the 'numbers' line
17:13:51 <Munchlaxx> In my program I have numbers indented 4 spaces after the main = do
17:13:53 <ReinH> And also probably the second line? Hard to tell.
17:14:00 <ReinH> @where lpaste
17:14:00 <lambdabot> http://lpaste.net/
17:14:06 <ReinH> use this rather than pasting code into irc
17:14:19 <ReinH> both so we can see its formatting clearly and to avoid spamming
17:14:33 <dramforever> n_blownapart: well do you understand the 'update' function now?
17:14:48 <dramforever> If you do, write bools in terms of that
17:15:29 <dramforever> It should do this: given 'n', apply 'update' n time to [[]]
17:15:37 <Munchlaxx> My bad. Here is the code http://lpaste.net/361593
17:15:55 <ReinH> Munchlaxx: main is indented
17:16:06 <ReinH> ok, it's... part of the let block?
17:16:09 <dramforever> Say, 'boolsU 3' should be 'update (update (update [[]]))', i.e. the answer
17:16:11 <ReinH> what's your entire code?
17:17:12 <Munchlaxx> I'm just learning haskell. I'm trying to just create a list then print it.
17:17:43 <ReinH> That's great, but we can't tell why you're getting that error without seeing the whole code.
17:17:58 <Munchlaxx> I can do it fine in the ghci compiler, but I keep getting indentation errors when trying to compile a program
17:18:02 <ReinH> This is a fragment of code that might be fine or not depending on how it's used
17:18:12 <ReinH> It is not a complete program.
17:18:22 <ReinH> So we need to see the context in which you use it.
17:18:32 <Munchlaxx> That's all the code. Like I said I'm just tring to print that list
17:18:52 <ReinH> So you put that in a file with a .hs extension and then tried to use ghc to compile it?
17:19:12 <ReinH> You don't need a let at the top-level of a file to define variables.
17:19:16 <Munchlaxx> yeah. ghc -o testHaskell testHaskell.hs
17:19:30 <dramforever> You *can't* use let at the top level
17:19:37 <ReinH> Indeed.
17:19:39 <dmwit> Munchlaxx: Delete the let and the indentation you used because you had it.
17:19:46 <ReinH> ^
17:19:47 <Munchlaxx> So it needs to be inside main?
17:19:55 <ReinH> No...
17:19:57 <dramforever> You need to remove let
17:20:09 <dmwit> Munchlaxx: Nah. `numbers = [1,2,3]; main = do numbers` is fine (though not type-correct for a full program).
17:20:12 <dramforever> and define it *like* main
17:20:38 * dramforever is having trouble load lpaste somehow, so he's just speculating
17:20:56 <dmwit> Munchlaxx: http://lpaste.net/361593
17:21:09 <dmwit> Well. If you already have it open, reload it.
17:21:18 <dmwit> I annotated with two ways to do it.
17:22:16 <Munchlaxx> Thanks! I got it working.
17:22:20 <ReinH> Haskell is not like a scripting language where you can put expressions anywhere.
17:22:38 <ReinH> At the top level of a Haskell source file you are restricted to declarations, like foo = bar and data Bizz = Bazz.
17:22:39 <Munchlaxx> So what is the purpose of "let" then if you can just declare a list with the variable name?
17:22:43 <ReinH> And imports.
17:22:54 <dramforever> Munchlaxx: historical reasons
17:23:05 <dramforever> you can literally just do
17:23:13 <ReinH> The context of a GHCi session is not the same as the top-level of a Haskell file.
17:23:14 <dramforever> numbers = [1, 2, 3]
17:23:16 <dramforever> in ghci
17:23:30 <ReinH> A GHCi session is a lot like the inside of a do block, specifically one for IO.
17:23:47 <ReinH> Previously, because of this, you had to use let to bind variables just like you would in a do block.
17:23:57 <ReinH> In recent Haskells, GHCi specially allows the foo = bar syntax as well.
17:23:57 <dramforever> Because some time ago usually people got confused because 'numbers = [1, 2, 3]' doesn't work in GHCi
17:24:03 <ReinH> s/Haskells/GHCs
17:24:04 <n_blownapart> dramforever: thanks I see how update works. but the argument is elaborately written in by hand. in boolsR it is recursively generated. that's what I don't see, how , what is the argument of update (boolsR 2) , is generated
17:24:05 <dramforever> apparently you have the reverse problem
17:24:32 <dramforever> n_blownapart: Do you underatand recursion?
17:24:47 <dramforever> Can you write 'factorial' recursively?
17:25:27 <dmwit> n_blownapart: Do you understand how `boolsR 0` works?
17:26:03 * dramforever thinks n_blownapart has a larger problem...
17:26:38 <dramforever> n_blownapart: write a recursive 'factorial' function that given n, computes 1*2*3*...*n
17:27:13 <dramforever> That's basic recursion, make sure you know how that works first
17:27:48 <ReinH> Where is this boolsR out of curiosity?
17:28:00 <wedify> dramforever: yeah i guess i could use a newtype. but i was wondering if haskell could express that constraint on the typelevel.
17:28:02 <fishythefish> ReinH: http://lpaste.net/361587
17:28:11 <ReinH> wedify: no, it can't.
17:28:27 <ReinH> You need (more) dependent types.
17:28:27 <dramforever> not really sorry
17:28:49 <ReinH> Specifically, you need a sigma type.
17:29:07 <dramforever> wedify: then maybe check Liquid Haskell
17:29:09 <ReinH> Because what you want is both the number and evidence that the number satisfies the constraint
17:29:37 <ReinH> you need to carry that evidence around so you can produce it later on demand
17:30:48 <wedify> ReinH, thank you, i will look up sigma types
17:31:08 <ReinH> That won't help you in Haskell, but it might make you want to write Idris or Agda instead
17:31:14 <wedify> i've slowly been learning some dependent types but i haven't made much progress
17:31:17 <dmwit> wedify: Even if Haskell could express that type, it would still be a distinct type from `Double` (or whatever). So you wouldn't get away with avoiding "I guess I could use a new type [spaces inserted by editor with full knowledge of the semantic change]".
17:31:33 <ReinH> wedify: I recommend Conor McBride's new CS410 lectures and exercises
17:31:41 <ReinH> https://github.com/pigworker/CS410-17
17:31:44 <dramforever> wedify: You can have it with external processors
17:31:52 <dramforever> LiquidHaskell can do it
17:31:53 <ReinH> They have accompanying videos on youtube too
17:32:01 <dramforever> As for how you need to check to see
17:32:08 <ReinH> Yeah, LiquidHHaskell is an interesting option
17:33:04 <wedify> i will check out liquid haskell too. asking this question went better than expected :)
17:37:07 <ReinH> wedify: the type you want is Σ ℝ λ n → n ≥ 0 ∧ n ≤ π, glossing over how the reals are represented.
17:37:32 <ReinH> Translated: a pair of a real number and evidence that the real number is within those bounds
17:38:55 <hux> Heyyy
17:39:08 <hux> Again me having trouble with monads yeyyy
17:39:44 <hux> I would like to understand why I'm not able to liftIO a function that returns m a when I constraint m to be MonadIO
17:40:36 <fishythefish> :t liftIO
17:40:38 <MarcelineVQ> liftIO is used on functions that return IO a
17:40:38 <lambdabot> MonadIO m => IO a -> m a
17:40:43 <fishythefish> it doesn't take a function as an argument
17:40:57 <MarcelineVQ> that's a much better thing to say ^^;
17:41:41 <hux> Sorry, by function I meant a monadic action m a
17:41:56 <n_blownapart> > update 9update [[]])  --  very sorry I had no idea update did this . so no, i'm clueless, how does update work
17:41:59 <lambdabot>  <hint>:1:20: error: parse error on input ‘)’
17:42:06 <hux> It takes an IO a, my function returns m a where m is MonadIO
17:42:17 <fishythefish> hux: there's your problem
17:42:20 <n_blownapart> > update update [[]])  --  very sorry I had no idea update did this . so no, i'm clueless, how does update work
17:42:24 <lambdabot>  <hint>:1:19: error: parse error on input ‘)’
17:42:30 <fishythefish> if your function returns a MonadIO m => m a which is not an IO a, what can liftIO do?
17:42:35 <fishythefish> liftIO can only accept an IO a
17:42:45 <n_blownapart> > update (update [[]])  --  very sorry I had no idea update did this . so no, i'm clueless, how does update work
17:42:48 <lambdabot>  [[F,F],[F,T],[T,F],[T,T]]
17:42:52 <monochrom> hux: Are you learning monads because Kylo Ren told you to? :)
17:43:02 <dmwit> n_blownapart: Do you understand how `boolsR 0` works?
17:43:10 <hux> monochrom: Yes
17:44:01 <hux> I mean, its literally saying it accept IO a, I call it with a m a where I constraint m to be a MonadIO, where is the difference between MonadIO m => m a and concret IO a ?
17:44:13 <n_blownapart> yes that's the base case dmwit
17:44:18 <fishythefish> IO is not the only instance of MonadIO, hux
17:44:24 <monochrom> liftIO goes the direction from IO to m, not the other way round.
17:44:27 <dmwit> n_blownapart: Okay. Do you understand how `boolsR 1` works?
17:44:31 <hux> fishythefish: Ohhhhh
17:44:55 <monochrom> And yeah an exmaple of m would be ReaderT Int IO
17:45:00 <n_blownapart> yes thanks
17:45:09 <hux> How could I handle that, give the lift function as argument ?
17:45:15 <dmwit> n_blownapart: Okay. Do you understand how `boolsR 2` works?
17:45:28 <fishythefish> hux: what is the type you ultimately want to get out of this?
17:46:02 <fishythefish> if you just want a MonadIO m => m a, then you don't need liftIO, since your function already returns that
17:48:03 <hux> fishythefish: Im trying to make my free monad working http://lpaste.net/361595
17:48:38 <hux> And I would like yo give both consumer and producer function to the interpreter
17:49:23 <hux> Its not working at the exec body, where it say that f returns m1 instead of m
17:52:05 <hux> I know that may be trivial for you but I'm trying to improve trust me lol
17:52:08 <n_blownapart> yeah now I see the pattern dmwit. I was trying to see how the lists fell to either side of the ++ , to get the next mapping of False: or True:
17:52:23 <dramforever> oh
17:52:30 <dramforever> do you understand ++
17:52:37 <n_blownapart> thanks kindly. I'll read up on update.
17:52:52 <n_blownapart> yeah I do, but in this context it was playing tricks on me
17:52:58 <dramforever> It's not
17:53:23 <fishythefish> hux: so what's the text of the error message?
17:53:25 <dramforever> Do you know how to manually compute expressions?
17:54:04 <n_blownapart> thanks dramforever a lot.. manually, that's what I was asking about initially. I've done it with various recursions, and I wanted to see how you would do it.
17:54:09 <dmwit> (I think dramforever is making a lot of assumptions about what is going on in your head. For what it's worth, the thrust of my questions was not intended to be explanatory. It was to find the tiniest piece that you didn't yet understand. I still do not know what that was, and I don't think anybody else in the channel does either.)
17:54:58 <n_blownapart> dmwit I know its not difficult, I look for patterns and this one was harder. maybe I'm austistic
17:55:27 <dmwit> (So be wary of explanations that start from an assumed state and try to tell you the difference between that state and the truth. Explanations which merely state true things need not fall under suspicion.)
17:55:50 <dmwit> I make no claim one way or the other about what is difficult or easy.
17:55:58 <fishythefish> also that's not what autism is
17:56:32 <MarcelineVQ> it's a lot of things these days, none of them on-topic luckily
17:56:46 <n_blownapart> no you questions did turn out to be explanatory. or I was able to see the pattern at that precise point.
17:56:53 <n_blownapart> word! :)
17:57:25 <dmwit> I am glad they were explanatory. But they were not intended to be. =)
17:57:58 <dmwit> There was a long series of follow-up questions, which at some point may still be useful to chase through. But if you are now unstuck, it can wait until you feel stuck again.
17:59:52 <n_blownapart> in any case, the (++) and having the where statement added some obscurity .. dmwit  follow up questions ie dramforever asking about manual computations of expressions?
18:00:25 <dmwit> No. You have not seen the follow-up questions because I have not yet asked them.
18:00:38 <n_blownapart> !!
18:00:45 <dramforever> Recursion is no different from usual function calls
18:01:10 <n_blownapart> yes but one must be keen on what happens first...
18:01:45 <n_blownapart> I look at those 2 lines and ask, what happens first?
18:01:58 <dramforever> Nothing
18:02:04 <dramforever> Everything happens together
18:02:33 <dramforever> You pick *any* part and start working on it
18:02:56 <n_blownapart> word, that is surely part of my problem. in scheme with linear recursion, you can look at it on a timeline, so to speak
18:04:22 <dramforever> Hmm
18:04:26 <dramforever> what linear recursion?
18:04:38 <dramforever> I think you can do the same with scheme don't you
18:04:54 <n_blownapart> like   (+1 (+1 (+1 (5)   where the innermost (+1) comes 'first'
18:05:01 <monochrom> At this point since infinite lists are not involved at, Scheme and Haskell don't differ.
18:05:16 <monochrom> s/ at,/ yet,/
18:05:44 <n_blownapart> thanks
18:07:14 <dramforever> Oh
18:07:22 <n_blownapart> thanks so much ALL I have it now;   more drama later.
18:08:35 <n_blownapart> dramforever: at least 'visually' the innermost comes first, since the convention is to expand the recursions to the left if its linear (in scheme)
18:09:36 <dramforever> oh
18:10:06 <dramforever> Why don't you do the same with the haskell one?
18:11:10 <n_blownapart> I realize you do the same (False: (False: []) but my brain wasn't taking care of everything on both sides of the ++ . I was stuck
18:12:48 <dramforever> ?
18:14:03 <dramforever> But
18:14:32 <dramforever> n_blownapart: but you can write exactly the same code in scheme
18:16:26 <n_blownapart> dramforever: thanks again, for whatever reason, I was not seeing the pattern until about 5:47pm  PST
18:17:07 <CuriousErnestBro> core or full?
18:18:09 <monochrom> How about: full core :)
21:05:17 <bsima> How do I fix this error with Esqueleto?
21:05:21 <bsima> "Couldn't match type 'BaseBackend b' with 'SqlBackend'"
21:09:48 <glguy> It's not possible to say for sure given the current information. One way is to replace b with the particular backend you're using
21:10:43 <bsima> I'm using PostgreSQL
21:10:59 <bsima> the query is a simple select
21:12:16 <bsima> I guess my question is, how do I specialize the type signature at all?
21:12:50 <glguy> You can add a type ascription to an expression with ::
21:12:55 <glguy> expression :: type
21:13:04 <bsima> yeah I know that
21:13:45 <bsima> the type sig I have now is "refForDoi :: SqlExpr (Entity Doi) -> ReaderT b m [ Entity Ref ]"
21:16:06 <glguy> Does it help to change the b to SqlBackend ?
21:17:40 <bsima> yeah I think that worked, thanks glguy
21:18:20 <ania123> can one tell me most reliable journal/proceedengs indexing in CS?
21:18:59 <glguy> bsima: another solution might have been to do: refForDoi :: IsSqlBackend b => SqlExpr (Entity Doi) -> ReaderT b m [ Entity Ref ]
21:19:32 <glguy> I've not used this package, so I'm just going on the documentation
21:21:35 <bsima> glguy: ok I'll remember that
21:26:08 <dmwit> ania123: This isn't really the right forum for that question. Consider the CS subreddit instead, perhaps.
21:26:33 <dmwit> Sorry, "compsci" is the name of the subreddit, not CS.
21:45:28 <iqubic> Is #haskell just really quiet tonight.
21:46:09 <mniip> no it's you who is loud
21:46:23 <iqubic> Ha. LOL
21:46:28 <boj> the sound of one hand clapping
21:46:40 <mniip> uhhhh
21:47:54 <iqubic> I can actually clap with one hand.
21:48:06 <xpoqp> partial clapping?
21:52:16 <iqubic> Something like that.
21:52:21 <iqubic> yeah.
22:02:52 <cemerick> Just getting started here really, and am trying stack
22:02:53 <xacktm> partial clapping... bottoms out
22:03:07 * xacktm leaves :P
22:03:20 <cemerick> is it really the case that I need to list all transitive dependencies in stack.yaml?
22:04:35 <bsima> cemerick: yeah if they aren't on stackage
22:04:57 <bsima> `stack resolver` usually finds everything for you
22:06:35 <bsima> er, `stack solver`
22:06:57 <bsima> also `stack solver --update-config` is useful to remember
22:08:03 <cemerick> `stack solver` actually fails with my (not large) set of dependencies
22:08:35 <cemerick> beyond that tho, the whole exercise seems incredibly duplicative, to put it mildly
22:09:44 <bsima> what does it fail with?
22:09:47 <cemerick> I guess this is similar to gem lock files, but manually managed.....
22:09:53 <mniip> xacktm, wow that was totally a joke
22:09:58 <bsima> sometimes it helps to update the resolver to the latest lts
22:10:37 <cemerick> bsima: I'm actually locked to 8.0.2 because of a key dependency, so that's out
22:11:21 <cemerick> `stack solve` bails trying to resolve a compatible version of "singletons"
22:11:37 <cemerick> cabal does just fine with it, fwiw
22:14:18 <piyush-k`> cemerick: I think with the new-build feature cabal-install seems to be a better option. I have been mostly a fence sitter on the stack-vs-cabal thing but I think with the new-build cabal-install has an edge
22:16:00 <cemerick> piyush-k`: are you meaning this? https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
22:17:05 <piyush-k`> yes
22:17:27 <piyush-k`> what I hear is that this will be the default in Cabal-3.0
22:17:29 <cemerick> I will check it out, thank you
22:18:12 <cemerick> so cabal will now install the relevant ghc, etc based on a build configuration?
22:18:26 <dmwit> No.
22:18:39 <piyush-k`> cemerick: no
22:18:50 <geekosaur> at least, not yet
22:18:56 <cemerick> hm, ok
22:18:58 <piyush-k`> cabal does not take care of that.
22:19:10 <geekosaur> there *is* work on getting ghc to be installable without having to deal with bindists like stack does
22:19:56 * piyush-k` is looking for hvr
22:20:00 <geekosaur> (which, among other things, leads to problems like the tinfo6 Arch issue, because there aren't enough custom bindists for various Linux configurations)
22:20:42 <dmwit> piyush-k`: If you're looking for him for a cabal thing, it might be better to ask in #hackage (the unofficial #cabal).
22:21:04 <piyush-k`> dmwit: I meant to point cemerick towards hvr
22:21:22 <piyush-k`> sorry that was not clear
22:22:17 <cemerick> so just FWIW, I was originally looking at stack only because I'm shopping for a better editor/IDE tooling situation, and some require stack
22:23:02 <cemerick> though given the manual transitive dependency management thing, I'm strongly disincentivized ;-P
22:23:23 <piyush-k`> cemerick: you may also want to have a look at the https://www.reddit.com/r/haskell/comments/7oxzjr/new_things_in_haskell_package_qa_tools_cabalplan/
22:24:10 <piyush-k`> cemerick: I am still using intero+stack but it is sometimes a pain when you are offline and want to work on a new project
22:25:23 <piyush-k`> I think this design is a bit strange to my tastes (due to its insistence on stack) but currently gives a reasonably good tooling for emacs
22:26:51 <cemerick> piyush-k`: Yeah, that was one of the aforementioned stack-requiring tools
22:27:34 <cemerick> but after N iterations of `stack build` and copy/pasting extra-deps, I now have a 180-line stack.yaml for a pretty basic project
22:28:02 <cemerick> either I'm doing something wrong, or this approach doesn't fit my aesthetic ;-P
22:37:06 <mud> cemerick: Doesn't sound typical
22:39:38 <cemerick> mud: yeah, I can't imagine people would enthusiastically tolerate what I'm seeing. I think I'm in come-back-in-6-months territory tho.
22:45:48 <dramforever> % 5
22:45:49 <yahb> dramforever: 5
23:07:50 <cemerick> so, it turns out I was setting the resolver wrong
23:09:09 <cemerick> I specified `ghc-8.0.2`, which meant no packages were in scope at all
23:09:41 <mud> cemerick: Ah, yeah that'll not be a fun way to go
23:10:23 <cemerick> mud: alas, it's one of the examples in the generated stack.yaml file, and I need a particular GHC rev, so... :-|
23:12:37 <glguy> It's fine to use the ghc resolver, you just need to list your package choices in extra-deps
23:12:58 <glguy> stack solver. can help you populate that automatically
23:59:09 <dmj`> jle`: ping
