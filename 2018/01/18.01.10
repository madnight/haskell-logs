00:16:31 <ertes-w> hell
00:19:32 <ertes-w> cocreature: ansible and python in general, debian/ubuntu, bad legacy code, broken legacy infrastructure, …
00:39:10 <dminuoso> Im trying to gain some basic understanding of how types are propositions, and programs are proofs. Are there good introductory papers for someone who doesn't have a math or background in lambda calculus?
00:42:21 <vaibhavsagar> dminuoso: https://www.youtube.com/watch?v=IOiZatlZtGU
00:42:39 <EvanR> dminuoso: you could look at chapter 1 section 11 of the free HoTT book  (1.11)
00:43:20 <vaibhavsagar> dminuoso: https://codewords.recurse.com/issues/one/type-systems-and-logic
00:44:39 <dminuoso> vaibhavsagar, EvanR: Ah great, that looks readable, thanks. :)
00:50:24 <EvanR> in their example proof of demorgan's law, the do some funny stuff in lieu of case split. they use a "recursion principle" for sum types (OR), which amounts case split on Left and Right
00:50:48 <merijn> Ola! I need a bit of help, I have a stream of N datapoints and I want to deterministically (i.e. reproducibly via a seed or something) uniform randomly keep P percent of them. Now, if I had everything in memory I'd just use a partial Fisher-Yates, but if possible I'd prefer to do this streaming so I don't have to first load millions of datapoints in memory
00:50:48 <kmelva> Anyone familiar with Gogol library? Trying to use Youtube Data API, stuck on the first step - auth :). My API keys are for "web applications", what kind of auth should I use with Gogol? ApplicationDefault or InstalledApplication?
00:50:51 <EvanR> even though no recursion is involved, in that specific case
00:59:07 * hackage mmark-ext 0.1.0.0 - Commonly useful extensions for MMark markdown processor  https://hackage.haskell.org/package/mmark-ext-0.1.0.0 (mrkkrp)
01:00:38 <_sras_> When using Servant web framework, is there any way to include the shape of the error response (other than 200) in the type of the endpoints?
01:02:00 <alp> _sras_, so the 'servant-checked-exception' package does provide you with somthing like this, but is not a definitive solution
01:02:32 <alp> a definitive solution is what will come out of https://github.com/haskell-servant/servant/issues/841 when we get around to executing one of the two plans there
01:02:49 <alp> but the end goal is indeed to _be able to_ (not forced to) declare the exhaustive list of outcomes for your endpoint
01:03:27 <alp> so that even the client could use a very precise error type (allowing the same errors as the ones returned by the server), the docs would be very precise, etc
01:06:03 <Ferdirand> merijn: i've seen this problem in the context of fair sampling of network streams.. iirc their solution was to take the output of a stream cipher and sample every time the cipher output crosses a given threshold. Would such an approach work for your case ?
01:06:48 <ij> Is the stack setup's haskell dynamicly linked and thus might very well break when I'll update OS's icu lib?
01:07:21 <ertes-w> merijn: do you know the number of points?
01:07:27 <merijn> ertes-w: Yes
01:08:07 <merijn> ertes-w: Ideally I also know the exact resulting set of points before filtering the stream
01:08:53 <merijn> Ferdirand: My problem is slightly easier in one way (I know the number of points ahead of time) and slightly harder in another (I would like to know the number of "surviving" points before processing the stream AND I want it to be reproducible)
01:08:57 <ertes-w> merijn: if you want to keep c items out of n, one option is to construct a sufficiently random cycle modulo n
01:09:25 <merijn> ertes-w: Sure, but Iw as asking if someone already had something like that lying around ;)
01:09:26 <ertes-w> merijn: linear congruential generators and linear feedback shift registers come to mind
01:09:45 <ertes-w> merijn: i don't, but it's really easy to construct and code =)
01:10:09 <Ferdirand> merijn: also, do you have an adversary that can take advantage of the sampling being deterministic ?
01:10:11 <merijn> ertes-w: I know LCGs, but I'm not qualified to determine if the randomness is good enough
01:10:24 <ertes-w> merijn: it's not cryptographically strong
01:10:25 <merijn> Ferdirand: No, I just need good randomness to avoid sample bias
01:10:31 <merijn> ertes-w: Not doing cryptography
01:10:36 <merijn> ertes-w: I'm doing statistics
01:10:57 <ertes-w> merijn: it also has very bad statistical properties…  be sure to filter only on high bits, if you do this
01:10:59 <merijn> ertes-w: When I say good quality randomness I mean "statistical quality"
01:11:12 <ertes-w> LFSRs are much better, but they're modulo 2^n
01:11:15 <merijn> i.e. actual uniform randomness
01:11:42 <merijn> If it comes to it I'll just do Fisher-Yates, but that involves loading everything into memory, which makes me unhappy
01:11:46 <EvanR> actual randomness, the most random randomness of all
01:12:21 <merijn> EvanR: I don't want *actual* random, though :p I want uniform, the universe's randomness might be biased :p
01:12:22 <Ferdirand> you can do external fisher-yates at least ?
01:12:26 <EvanR> to get N random points, take the first N <- super random decision
01:12:37 <ertes-w> merijn: there is another option, where you can select your preferred RNG: if it's not too much to hold a single bit in memory for each value, you can just cross off bits
01:12:41 <merijn> Ferdirand: What do you mean by external?
01:13:00 <Ferdirand> do fisher-yates on an array of indices, then load the corresponding points ?
01:13:42 <merijn> Ferdirand: that doesn't help, since that still means millions of indices
01:13:52 <ertes-w> create a field of n bits, generate a random number modulo n for each incoming value…  if the corresponding bit is unset, retry…  if the bit is set and the number is below c, keep the value, otherwise throw it away, unset the bit, loop
01:14:49 <ertes-w> there is probably also a way to construct a pseudo-random function, which doesn't have the caveats that this method has
01:15:12 <merijn> Anyway, I'll see if anyone in numerical-haskell wakes up and has an idea :)
01:18:59 <kmelva> In this code example: https://hackage.haskell.org/package/gogol-0.3.0/docs/Network-Google-Auth.html#g:3  ... how can I call redirectPrompt? Where do I get the `proxy s` thing?
01:19:38 <ertes-w> > iterate (\x -> 15*x `mod` 107) 15
01:19:41 <lambdabot>  [15,11,58,14,103,47,63,89,51,16,26,69,72,10,43,3,45,33,67,42,95,34,82,53,46,...
01:20:06 <merijn> kmelva: proxy is a type variable
01:20:07 <ertes-w> merijn: this is a random cycle of length 106 with very good statistical properties
01:20:40 <rodol> @pl (\x y -> 0.5*(x+y))
01:20:40 <lambdabot> ((0 . 5 *) .) . (+)
01:20:41 <kmelva> merijn: that's basically the only thing I know... but still, how do I call the function? :D
01:20:42 <merijn> kmelva: There is a "data Proxy a = Proxy" type in Data.Proxy for these kinda things. But most APIs use a lowercase "proxy" type variable so you can use other datatypes too
01:20:48 <alp> kmelva, 'Proxy :: Proxy ["hello", "world"]' would be one valid value modulo the fact that it's not a "known scope" I suppose. any type that's tagged by a typelvel list of strings, like "s" is.
01:21:19 <merijn> kmelva: "redirectPrompt (Proxy :: Proxy myS)" works
01:21:29 <merijn> kmelva: Or "redirectPrompt (Nothing :: Maybe myS)"
01:21:41 <merijn> Or "redirectPrompt ([] :: [myS])"
01:21:55 <merijn> If you happen to have an actual value of type 's' you can also use "Just thatValue"
01:22:29 <ertes-w> merijn: if you have n elements, pick a prime p > n such that (p - 1)/2 is also a prime, then pick k such that k*k > p and k^((p - 1)/2) ≢ 1 (mod p)
01:22:37 <EvanR> oh lord... oauth scopes at the type level
01:22:50 <kmelva> merijn: what is "myS" in your example?
01:22:53 <ertes-w> merijn: now (iterate (\x -> k*x `mod` p) k) is a cycle of length p - 1
01:23:00 <EvanR> its like oauth was invented to test how extra complex stuff can be
01:23:10 <EvanR> extraly complex
01:23:34 <ertes-w> merijn: if the next number from the cycle is > n, ignore it…  otherwise if it's (> c), drop the element, otherwise keep the element
01:23:41 <tdammers> oauth's complexity is literally accidental
01:24:03 <merijn> kmelva: a type, which type depends on what you wanna call redirectPrompt with
01:24:25 <merijn> kmelva: I dunno anything about gogol or that API, so I dunno what would be a sensible type
01:25:02 <kmelva> merijn: thanks, it's a bit clearer now, although I still can't make it work...  :/
01:25:19 <ij> Does stack build all the deps when the snapshot's so old that it doesn't store the precompiled versions any more? (8.17)
01:25:33 <royal_screwup21> suppose I have list like so: [ [1], [2] ]. I want to add 3 to the second sublist to get: [ [1], [2,3]]. What's the easiest way to accomplish this?
01:25:38 <ertes-w> merijn: this is like 5-6 lines of code (use the arithmoi package for the primality test)
01:27:18 <merijn> royal_screwup21: It it always just two lists? is the list you want to add to always the same?
01:27:57 <royal_screwup21> merijn: not always two list, but the idea is the same: I want to add one element to the last sublist of a given list
01:28:00 <royal_screwup21> lists*
01:30:11 <kmelva> merijn: I got something, THANKS! (those proxy scopes are defined in each gogol-* package, still not super sure how it works but it's progress...)
01:31:28 <ertes-w> merijn: off-by-one mistake: it should be (>= c)
01:32:06 <merijn> royal_screwup21: Right, in that case I'd probably write something by hand "appendLast v [l] = [l++[v]]; appendLast v (x:xs) = x: appendLast v xs"
01:32:11 <merijn> royal_screwup21: Something along those lines
01:36:43 <merijn> ertes-w: I think I've found the secret code word
01:36:57 <merijn> ertes-w: "Reservoir sampling is a family of randomized algorithms for randomly choosing a sample of k items from a list S containing n items, where n is either a very large or unknown number."
01:37:04 <merijn> Time to read up on reservoir sampling :)
01:37:16 <royal_screwup21> why is([1]++[2]:[]) invalid? I get an error Non type-variable argument in the constraint: Num [t] (Use FlexibleContexts to permit this)
01:39:33 <wz1000> royal_screwup21: that parses as [1]++([2]:[])
01:39:46 <wz1000> which is [1] ++ [[2]]
01:39:54 <royal_screwup21> shite
01:40:04 <royal_screwup21> thanks wz1000
01:41:07 <wz1000> so it thinks 1 :: Num a => a should unify with the type of [2] :: Num a => [a]
01:41:41 <ertes-w> merijn: ah, indeed…  seems to be simple enough
01:54:09 <EvanR> something is rotten in the world of referential opaqueness
01:54:49 <merijn> EvanR: hmm?
01:54:53 <EvanR> in google sheets, i had a big list of formulas referring to some parameters, which were themselves defined in terms of a reference is a different worksheet, which were manual numbers
01:55:15 <Uniaika> Damn.
01:55:29 <EvanR> so copied and pasted the middle set of cells, entered in constants on top of them, then "restored" the intersheet reference cells
01:55:47 <EvanR> in addition to becoming  REF! error, it filled in all my dependent formulas references with "REF!"
01:55:55 <EvanR> so my formulas were ruined
01:55:59 <EvanR> o_O
01:56:27 <EvanR> seems like a semantic snafu
01:58:38 <EvanR> as if writing bottoming code in haskell caused ⊥ to be written into every variable in your source code file
01:59:01 <EvanR> maybe i dont even have language to explain this
02:01:48 <contiver> I'm getting an error saying "unusuable due to shadowed dependencies" when building criterion 1.3.0.0 to benchmark a package.
02:01:57 <contiver> Any idea of how can I fix that?
02:16:54 <dminuoso> So in Ruby I've developed a habit of frequently doing things like map.with_index in order to treat say the first item specially, or every 3rd. What would be the Haskell way of doing the same thing?
02:17:28 <merijn> dminuoso: "map f . zipWith (,) [0..]"?
02:17:37 <ania123> can one help me to download the following paper: https://link.springer.com/chapter/10.1007/978-3-319-38884-7_9
02:17:55 <merijn> ania123: pm your email
02:17:58 <dminuoso> merijn: Okay, I suppose my question was rather meant as, would that be an antipattern?
02:18:10 <ania123> merijn: what?
02:18:10 <nullie> @pl zipWith (,)
02:18:10 <lambdabot> zip
02:18:17 <merijn> ania123: So I can email it to you :p
02:18:24 <ania123> aa, thanks
02:18:48 <nullie> merijn: isn't zipWith (,) pointless?
02:18:51 <EvanR> dminuoso: some container APIs come with a map-with-index thing, lists dont
02:18:58 <merijn> nullie: oh, yeah, I wasn't thinking :)
02:19:13 <EvanR> but zipping with [0..] is idiomatic in that case
02:19:27 <EvanR> > zip "cool" [0..]
02:19:31 <lambdabot>  [('c',0),('o',1),('o',2),('l',3)]
02:19:42 <EvanR> zipWith f "cool" [0..]
02:19:51 <merijn> dminuoso: Depends on what you're doing, I can think of a bunch of legit usecases for it
02:19:52 <nullie> and you can even do [1,,[
02:19:54 <merijn> Actually
02:20:08 <merijn> You can skip the map, just do "zipWith f [0..]"
02:20:34 <tdammers> > zipWith (\k v -> "Key: " ++ show k ++ ", value: " ++ show v) [0..] ["hello", "world"]
02:20:38 <lambdabot>  ["Key: 0, value: \"hello\"","Key: 1, value: \"world\""]
02:20:44 <tdammers> something like this
02:21:16 <tdammers> but if all you want to do is treat the first item specially, pattern-matching on (x:xs) is sometimes a more elegant solution
02:21:41 <A001> could someone clarify for me, in the lambda expression (\xyz.xz(yz)) do the parentheses around `yz` imply they are separate and not bound to the \yz?
02:22:05 <A001> and could even be renamed
02:22:27 <merijn> A001: No, it means that "y" is applied to 'z' and the result of that is passed to "x applied to z"
02:23:16 <A001> merijn: ah yes, thank you
02:25:54 <royal_screwup21> I have class with a function like so: https://thepasteb.in/p/RghnWY32jPkCz It throws an error: https://thepasteb.in/p/48hY5PwXXKlTR How do I fix this?
02:30:37 <royal_screwup21> I'm not sure I understand the error message at all :(
02:31:59 <Gurkenglas_> royal_screwup21, the instance would have to define "func :: Maybe -> [Char]", which doesn't make sense since Maybe isn't a type that has a set of values attached to it, such as Int.
02:32:37 * hackage yam-app 0.1.0.0, yam-job 0.1.0.0, yam-servant 0.1.0.0, yam-transaction-odbc 0.1.0.0, yam-transaction-postgresql 0.1.0.0 (leptonyu): https://qbin.io/ym4aar4k6
02:32:55 <Gurkenglas_> "Int :: *" expresses that Int has a set of values attached to it, "Maybe :: * -> *" expresses that Maybe takes a type that has a set of values attached to it as an argument and returns a type that has a set of values attached to it
02:33:47 <Johulk> Hello
02:33:55 <dminuoso> merijn: Things along those lines: https://gist.github.com/dminuoso/38fea6eaa87069d592ea0678e92e3d3d
02:33:55 <Johulk> Can you help me with this error? http://lpaste.net/361530
02:34:20 <Gurkenglas> (as the compiler would say it: "'Int' has kind '*'", "'Maybe' has kind '* -> *'")
02:34:28 <royal_screwup21> Gurkenglas_: thanks I'm going to have mull over this for a bit before I can truly internalize the concept
02:34:31 <merijn> dminuoso: Seems reasonable enough to me
02:34:45 <dminuoso> Johulk: You are missing a "=" for the function definition.
02:34:54 <dminuoso> Johulk: The guard does not imply "=" :)
02:35:00 <brynedwards> Johulk: Guard syntax uses = not then
02:35:06 <Gurkenglas> Johulk, replace "then" with "=", replace "else" with "otherwise ="
02:35:10 <Johulk> OOOHHH
02:35:17 <Johulk> *facepalm*
02:35:39 <Johulk> Thanks guys
02:35:47 <Gurkenglas> > otherwise
02:35:51 <lambdabot>  True
02:36:19 <dminuoso> Ohh. `otherrwise` is just a variable?
02:36:26 <dminuoso> :t otherwise
02:36:29 <lambdabot> Bool
02:36:33 <dminuoso> TIL. :)
02:36:33 <EvanR> tricky tricky
02:37:01 <EvanR> a global variable nonetheless
02:37:06 <royal_screwup21> Gurkenglas: what is "* -> *" called"?
02:37:26 <dminuoso> royal_screwup21: It's a kind.
02:37:32 <EvanR> type constructor
02:37:43 <Gurkenglas> A kind of type constructor
02:37:45 <royal_screwup21> alrighty
02:37:53 <EvanR> though people will call constant types like Bool a type constructor for some reason
02:37:59 <Gurkenglas> *"A kind of type constructors"
02:38:28 <dminuoso> EvanR: Do you consider `1` a data constructor?
02:38:45 <EvanR> not really
02:38:46 <royal_screwup21> isn't Bool a datatype? I mean, shouldn't True and False be considered the type constructors instead?
02:38:52 <dminuoso> royal_screwup21: No!
02:38:55 <EvanR> what
02:38:59 <EvanR> True and False are values
02:39:11 <EvanR> and also data constructors
02:39:21 <royal_screwup21> ah data constructors
02:39:36 <dminuoso> royal_screwup21: Kinds are to types what types are to values. * -> * means that you have a type constructor/function that takes one type "*" and produces a type "*".
02:39:38 <EvanR> pattern matching acts on data constructors
02:40:07 * hackage websockets 0.12.3.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  https://hackage.haskell.org/package/websockets-0.12.3.1 (JasperVanDerJeugt)
02:42:28 <sphinxo> is there a linker option to get HsFFI.h or do I have to include the ghc include dir?
02:42:42 <dminuoso> royal_screwup21: [] is another example of a type constructor. `[] :: * -> *` and you can apply [] to another type like `Int` like this: `[] Int` or using sugar `[Int]`, the result of which is just a (mono)type.
02:43:00 <royal_screwup21> :k []
02:43:02 <lambdabot> * -> *
02:43:34 <merijn> sphinxo: That's a compile option, header files don't exist at link time
02:43:35 <dminuoso> royal_screwup21: And you can have higher arity types too. Like:
02:43:35 <royal_screwup21> :k [Int]
02:43:36 <dminuoso> :k Either
02:43:37 <lambdabot> *
02:43:39 <lambdabot> * -> * -> *
02:43:51 <royal_screwup21> :k [Int]
02:43:53 <lambdabot> *
02:43:56 <royal_screwup21> ah okay
02:44:37 * hackage ocaml-export 0.4.0.0 - Convert Haskell types in OCaml types  https://hackage.haskell.org/package/ocaml-export-0.4.0.0 (mchaver)
02:44:49 <dminuoso> royal_screwup21: So `Either Int` gives you back `* -> *`, and `Either Int String` gives you back `*`
02:44:55 <dminuoso> royal_screwup21: If that makes sense.
02:45:20 <royal_screwup21> :k Either Int String
02:45:22 <lambdabot> *
02:45:36 <Gurkenglas> If Bool is the umbrella for True and False, and * is the umbrella for Bool, Int, Maybe Char, ..., what is the umbrella for *, * -> *, ...?
02:45:45 <dminuoso> royal_screwup21: And then there's things that takes type constructors as functions like  `(* -> *) -> * -> *` (so the first argument has to be of kind * -> *
02:45:54 <dminuoso> :k StateT
02:45:57 <lambdabot> * -> (* -> *) -> * -> *
02:46:00 <royal_screwup21> holy shit
02:46:15 <EvanR> Gurkenglas: BOX ?
02:46:28 <EvanR> (if BOX still exists)
02:46:53 <Johulk> Mmm..
02:46:54 <Johulk> http://lpaste.net/361530
02:47:09 <dminuoso> *takes type constructors as arguments
02:47:26 <yeoman> who else thought that the type = constructor paramName thing was foncusing
02:47:32 <yeoman> when starting haskell
02:47:34 <dminuoso> royal_screwup21: And like you have seen before with `Either Int` they can be curried too. :)
02:47:34 <Johulk> It's saying I'm making a list of lists, but I'm making a continuous one
02:47:39 <dminuoso> :k Either Int
02:47:41 <lambdabot> * -> *
02:48:42 <Gurkenglas> So when something has kind "k -> k", there's an implicit "forall k. BOX k =>" before it? And that which maps "k :: BOX" to "k -> k :: BOX" would have signature "BOX -> BOX"? What's the umbrella for BOX, BOX -> BOX, etc.?
02:48:46 <ertes-w> Gurkenglas: it doesn't have a name in haskell, but if you call it Sort, then * :: Sort, and (->) :: Sort -> Sort -> Sort
02:48:55 <Johulk> Anyone knows whats wrong with my function?
02:49:07 * hackage haskell-src-exts-sc 0.1.0.1 - Pretty print haskell code with comments  https://hackage.haskell.org/package/haskell-src-exts-sc-0.1.0.1 (achirkin)
02:49:22 <ertes-w> Gurkenglas: if you enable TypeInType, then actually all type-level layers collapse into a single layer, and then (as the name implies):  Type :: Type
02:49:29 <EvanR> a continuous list? fascinating
02:49:34 <tdammers> :t (:) -- Johulk
02:49:35 <dminuoso> Johulk: The error message points you to: In the second argument of `(:)', namely `converteMSet ts'
02:49:37 <lambdabot> a -> [a] -> [a]
02:49:39 <ertes-w> Gurkenglas: or (* :: *) in traditional terms
02:49:52 <tdammers> > [1] : [2]
02:49:55 <lambdabot>  error:
02:49:56 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_112’
02:49:56 <lambdabot>      • In the expression: e_112
02:50:05 <tdammers> > 1 : [2]
02:50:09 <lambdabot>  [1,2]
02:50:09 <dminuoso> Johulk: It's inferring that whatever is to the right side of it, must be an array of the same type of the left side of (:)
02:50:30 <Johulk> Weird.
02:50:41 <Johulk> It should be
02:50:42 <EvanR> Gurkenglas: ive never heard of a BOX -> BOX
02:50:45 <merijn> ertes-w: Honestly, I find TypeInType super confusing
02:50:47 <dminuoso> Johulk: But you are basically doing something like `convert a : convert a` which wont type check.
02:51:02 <Gurkenglas> ertes-w, that just sounds like the sort of dynamic typing that throws 2 and True into one type. Couldn't we instead just define all the layers at once, while still being able to tell them apart?
02:51:07 <dminuoso> just like 1:1 doesn't work.
02:51:23 <Johulk> What do I need to do then?
02:51:24 <tdammers> Johulk: no, it shouldn't - your converteMSet function's return type is [a], it can't be both a and [a]
02:51:26 <Gurkenglas> EvanR, id for one
02:51:30 <ertes-w> merijn: i find it natural (except for the obvious logical implications of (Type :: Type))
02:51:39 <Johulk> Wait
02:51:41 <Johulk> dont tell me
02:51:43 <ertes-w> Gurkenglas: dynamic?  there is nothing dynamic about this
02:51:45 <Johulk> let me try to fix it myself
02:51:48 <dminuoso> +1 :)
02:51:51 <EvanR> Gurkenglas: if id has every x -> x for all x including itself, you have a problem
02:52:06 <EvanR> Gurkenglas: so there has to be many different id's with many types, and theres no type of all of them
02:52:18 <EvanR> s/has every/has type/
02:52:36 <ertes-w> Gurkenglas: in a logically consistent type system you would have a hierarchy of universes:  Int :: Type 0;  Bool :: Type 0;  Type 0 :: Type 1;  Type 1 :: Type 2
02:52:51 <Johulk> tdammers: got it
02:52:58 <EvanR> x -> x for all x including itself is like time traveling with bill and ted back to late 19th century logic
02:52:59 <Johulk> instead of using : to construct a list
02:53:05 <ertes-w> Gurkenglas: but haskell doesn't really want to be a theorem prover, so we collapse all those type levels into a single level and just call it Type
02:53:06 <Johulk> I used ++ to add both lists
02:53:07 <Johulk> :D
02:53:57 <Gurkenglas> ertes-w, attaching natural numbers there sounds correct except for you leaving no space for an umbrella over Type 0, Type 1, etc.
02:54:07 <EvanR> there isnt one
02:54:25 <EvanR> except in agda which lets you quantify over all universe somehow
02:54:39 <Gurkenglas> EvanR, what stops us from attaching a name to it
02:54:51 <EvanR> god
02:54:54 <EvanR> or godel
02:55:03 <EvanR> or your mother in cleveland
02:55:42 <Gurkenglas> We're already inconsistent using "newtype Liar = Liar { runLiar :: Liar -> Void }", what's one more inconsistency in exchange for complete expressibility
02:55:56 <EvanR> well thats what TypeInType gives you
02:56:07 <EvanR> the top level thing is... Type which is its own type
02:56:07 <ertes-w> Gurkenglas: there doesn't have to be one…  most type systems with universes use a cumulative hierarchy, where (Type n :: Type (n + k)) for all n and k
02:56:38 <ertes-w> Gurkenglas: so (Type 500) has both (Type 0) and (Type 499) as members
02:56:40 <Gurkenglas> Ah, 0, 1, 2... are to be seen not as natural numbers but as ordinals?
02:56:51 <ertes-w> they are natural numbers
02:56:52 <Gurkenglas> That should work
02:56:56 <EvanR> no they are a special copy of natural numbers
02:57:35 <EvanR> and your issue isnt solved by ordinals
02:57:35 <ertes-w> they're really just built into the type system itself
02:57:43 <Gurkenglas> EvanR, it's not what I meant by "complete expressibility" if I can't tell Type 0 from Type 1, and why isn't it?
02:58:06 <ertes-w> Gurkenglas: you only need to tell them apart, if you want a consistent logic
02:58:19 <EvanR> thats a weird form of complete expressibility
02:58:37 <ertes-w> the only reason for that parametrisation is russell's paradox
02:58:47 <Gurkenglas> Okay, I'm not attached to that term, give me a better word for what I want where everything that sounds like it should get its own name gets it
02:58:58 <EvanR> Gurkenglas: you do or dont want consistency? you do or dont want "a name for everything" ?
02:59:12 <ertes-w> Gurkenglas: you want a collection of *everything*?
02:59:15 <Johulk> Does anyone know where I can find the minimum requirements to add a show instance to a new data type?
02:59:19 <Gurkenglas> I'm ready to sacrifice consistency
02:59:25 <EvanR> then TypeInType
02:59:38 <ertes-w> Gurkenglas: if you make that sacrifice, then Type is the collection of everything
02:59:45 <Gurkenglas> That also sacrifices "a name for everything"
02:59:47 <A001> can anyone recommend a website that shows beta reduction of some arbitrary lambda expressions step by step?
02:59:47 <EvanR> including itsel
02:59:56 <EvanR> Type is not a name?
03:00:26 <Gurkenglas> Um. Is this the wrong term again? I want a lot of names, one for each thing, not just a single name for all of the things
03:00:45 <EvanR> what doesnt have a name
03:01:00 <Gurkenglas> If Type contains itself, Type 0 gets no name
03:01:08 <EvanR> since it doesnt exist its ok
03:01:19 <EvanR> (and you used its name anyway lol)
03:01:21 <ertes-w> Gurkenglas: this is a matter of what is in what collection…  Int is a member of Type, and of nothing else
03:01:29 <ertes-w> and Maybe is a (Type -> Type), but not a Type
03:01:33 <ertes-w> is that not what you're asking for?
03:01:46 <EvanR> "is a" vs "is in" ;_;
03:02:25 <EvanR> and (Type -> Type) :: Type ?
03:02:33 <Gurkenglas> What I'm asking for is that Type is not in Type, because that sounds like 1 is in Everything and True is in Everything
03:02:33 <ertes-w> yeah
03:02:51 <ertes-w> Gurkenglas: nope, that's not the case
03:02:54 <EvanR> 1 being a type would be awesome
03:03:07 <EvanR> wait no it wouldnt
03:03:15 <EvanR> thats how it is now, with TypeLits
03:03:25 <ertes-w> Gurkenglas: if (x :: Integer), then (x :/: Type)
03:03:33 <EvanR> and we have duplicate copies of everything, but we dont want them
03:03:38 <ertes-w> Gurkenglas: the only implication of (Type :: Type) is (Type :: Type)
03:03:40 <Gurkenglas> y cant u just look at my neurons and see what i mean ;_;
03:04:46 <ertes-w> Gurkenglas: i think you're just reading more into (Type :: Type) than there is =)
03:05:25 <royal_screwup21> the more I delve into this, the more I feel like this language is for people with high IQs, not for mere mortals like me. The learning curve is very harsh :(
03:05:53 <ertes-w> Gurkenglas: consider the hierarchy of universes to be a "hack"…  it's a hacky way to avoid russell's paradox
03:06:23 <ertes-w> (Type :: Type) is the natural, intuitive thing, but we can't have that, otherwise we run into really weird barbers
03:06:28 <EvanR> theres definitely a tame subset of haskell, but they workhorse libs out there tend to go way beyond it (see the question earlier about OAuth scopes at the type level :()
03:06:32 <Gurkenglas> Huh, if Type 2 :: Type 3, then Type :: Number -> _, where _ must be Type 3 and Type 4 which I didn't want to unify
03:07:09 <ertes-w> it's the same thing set theory people do when they distinguish "sets" and "classes"…  there is really no difference between sets and classes, other than that there is a class of all sets
03:07:15 <ertes-w> but not a class of all classes
03:07:36 <ertes-w> now instead of calling them "sets" and "classes", call them "0-sets" and "1-sets"
03:07:47 <ertes-w> now there is a 2-set of all 1-sets
03:07:49 <EvanR> ertes-w: the hierarchy comes from the precursors to russels paradox which all involve quantifying over way too much stuff, which always led to stupid situations of a statement talking about its own self.
03:07:55 <ertes-w> a "sueprclass" of all "classes"
03:07:59 <ertes-w> etc.
03:08:03 <Gurkenglas> I suppose we can say that _ is the disjoint union of Type k for all k
03:08:04 <ertes-w> *superclass
03:08:07 * hackage yam-servant 0.1.0.1, yam-job 0.1.0.1, yam-app 0.1.0.1, yam-transaction-postgresql 0.1.0.1, yam-transaction-odbc 0.1.0.1 (leptonyu): https://qbin.io/9zb4ptzg
03:08:13 <EvanR> a natural way to solve it is to carefully delineate what youre quantifying over
03:08:29 <EvanR> and it definitely cant be "everything ever"
03:08:33 <ertes-w> Gurkenglas: wait…  if you have a hierarchy, then Type itself doesn't have a type
03:08:43 <EvanR> they all showed many ways that makes no sense
03:08:55 <toby1851> i'm stumped by this type signature: getYesod :: MonadHandler m => m (HandlerSite m)
03:09:10 <Gurkenglas> ertes-w, why not? It maps a hierarchy index to a hierarchy level
03:09:14 <toby1851> istm that the first use of m is * -> * and the second is * so how can that possibly work?
03:09:19 <ertes-w> Gurkenglas: Type is not really a thing…  the things are called (Type 0), (Type 1), (Type 2), etc.
03:09:37 <EvanR> toby1851: all 3 are * -> *
03:10:05 <EvanR> HandlerSite takes a * -> *
03:10:06 <geekosaur> toby1851, that usually means HandlerSite is a type alias which expands to something meaningful
03:10:08 <ertes-w> Gurkenglas: you can have some limited form of parametrisation there, but you would have to carefully justify it (like agda's universe polymorphism)
03:11:11 <Gurkenglas> We might be better served having Umbrella map (Type 0) to (Type 1), (Type 1) to (Type 2), etc.
03:11:40 <EvanR> and what is the type of Umbrella
03:12:03 <Gurkenglas> (And then UmbrellaLimit mapping Umbrella and Type 0 to Type Omega-0)
03:12:10 <EvanR> :|
03:12:32 <EvanR> ordinals are a cancer of the mind
03:12:46 <EvanR> break out of the loop
03:13:14 <Gurkenglas> Umbrella :: forall k. k :: Umbrella k => k -> Umbrella k
03:14:08 <EvanR> i think one of the problems to be solved in type theory is the reduction of universe bureaucracy, not an expansion of it
03:14:38 <Gurkenglas> It's all already there, we're just describing it
03:14:47 <EvanR> no
03:15:02 <EvanR> there not already a Type Omega0
03:15:24 <geekosaur> good luck trying to reduce it...
03:16:55 <Gurkenglas> UmbrellaLimit :: forall s k. (s :: UmbrellaLimit s k -> UmbrellaLimit s k, k :: UmbrellaLimit s k) => s -> k -> UmbrellaLimit s k
03:17:37 <EvanR> idris supposedly somehow does universe bureaucracy for you
03:17:52 <EvanR> you dont mess with universe levels
03:18:01 <Gurkenglas> (Umbrella and UmbrellaLimit, of course, inductively define the ordinal type hierarchy which we never name in the theory so we don't have to talk about its signature?)
03:18:45 <EvanR> theres ordinals defined against every universe
03:21:54 <EvanR> https://golem.ph.utexas.edu/category/2012/12/universe_polymorphism_and_typi.html
03:30:42 <toby1851> well, i'm still stumped :( I can use getYesod just fine in Handler. I was hoping to generalize to MonadHandler, but no dice: http://lpaste.net/361536
03:34:19 <cocreature> toby1851: looks like you need to add "HandlerSite m ~ App" to the constraints
03:35:40 <toby1851> cocreature: i owe you a beer / pizza / whatever - thanks!
03:36:54 <toby1851> is a similar remedy usually going to apply when you get a "Couldn't match type" error that involves type variables?
03:37:00 <Gurkenglas> EvanR, I approve of the link and now realize that whenever I might want to say something about a particular universe level, it ought to be true for all of them so I shouldn't choose one
03:37:13 <Gurkenglas> (and so they need no names)
03:38:11 <A001> does this beta reduction look correct https://pastebin.com/raw/9NxU5KwW ?
03:38:18 <A001> parentheses most likely off
03:39:07 <A001> the (\uv.v)z) step is bothering me
03:40:13 <EvanR> i like they pointed out category theory, and how people will talk about a category of categories with functors between them like it aint no thang. This completely relies on an implicit working sewerage system of universe polymorphism in all category theory
03:40:59 <cocreature> toby1851: in most cases those are just errors that need to be fixed. but if one site involves a type family (HandlerSite in your case) then you often need such constraints
03:49:19 <ertes-w> EvanR: i think cumulative universes are already a very good reduction of that bureaucracy
03:50:15 <ertes-w> EvanR: i've used coq for category theory, and i've never had to specify anything universe-related…  in fact i'm not even sure whether i could if i wanted
03:52:41 <phadej> I don't remember if I had cases where I had to have `id` and `id2` for Coq to pick them different universes
03:52:46 <phadej> i.e. needed universe polymorphism
03:53:00 <phadej> cases *lately
03:53:00 <ertes-w> when i did the same in agda, it was a horrible mess, and i kept myself asking: why do i have to do all this bureaucracy?  why do i have to pass all those levels around explicitly?  and why do we all have to wear these ridiculous ties?
03:54:01 <phadej> ertes-w: but it's not about cumulative universes, but univierse-polymorphism, is it?
03:54:32 <ertes-w> phadej: in cumulative universes you can think of the polymorphism being implicit
03:56:14 <phadej> Eval evaluate in id id.
03:56:15 <phadej> Error: Universe inconsistency.
03:56:20 <phadej> maybe I have old coq
04:02:53 <Johulk> Hey
04:02:57 <Johulk> Can someone help me with this one?
04:02:58 <Johulk> http://lpaste.net/361538
04:06:55 <shiona> Johulk: "a : percorre (xs) h)" tries to make a list that has first element of type a and the rest of the elements of type Maybe [a]
04:07:00 <int-e> Just (a : percorre (xs) h) <-- percorre is not a list.  fmap (a :) (percorre h)  may be the right thing
04:07:16 <int-e> ... err, I dropped the (xs).
04:09:53 <toby1851> Johulk: a design point, do you actually need to distinguish `Nothing` and `Just []` ?
04:13:30 <Johulk> toby1851:  No??
04:13:43 <Johulk> I mean
04:13:53 <Johulk> I need to use ' Maybe '
04:13:53 <Johulk> so
04:14:03 <saurabhnanda> is there a quick one-liner using lenses/prisms that checks the data-constructor of a sum-type? i.e. the isJust equivalent of a custom sum-type?
04:14:04 <Johulk> I need Just and Nothing
04:15:25 <saurabhnanda> git it
04:15:31 <saurabhnanda> :t Control.Lens.has
04:15:33 <lambdabot> Getting Any s a -> s -> Bool
04:16:27 <raduom> Hi. Given the append function over HList, I want to be able to say that if i have a contraint over all types of the first list and over all types of the second list, i will also have it over all the results of the appended lists. How would I do that? Gist: http://lpaste.net/361539
04:17:56 <merijn> raduom: Maybe you can get some inspiration from here? https://gist.github.com/merijn/dc00bc7cebd6df012c5e
04:18:36 <phadej> saurabhnanda: there's also `Control.Lens.Extra.is`
04:18:47 <saurabhnanda> phadej: thanks!
04:19:03 <phadej> :t Control.Lens.Extras.is
04:19:05 <lambdabot> APrism s t a b -> s -> Bool
04:19:09 <merijn> So, I don't suppose anyone has ported ghcid to vim yet?
04:20:29 <raduom> merijn: I do not see the constraints in your gist.
04:21:11 <raduom> merijn: nevermind. saw the zip. let me study more.
04:21:43 <merijn> oh, I actually thought I had a constraint map in there too
04:22:13 <merijn> raduom: You can combine Zip with the constraint constructing map I have here: https://gist.github.com/merijn/6130082
04:23:53 <tabaqui> I'm trying to use Control.Exception.Lifted in my project, but cannot understand ghc error log
04:24:00 <tabaqui> can someone help me with it, please?
04:24:02 <tabaqui> https://pastebin.com/ALf95tCS
04:24:21 <merijn> I always find MonadBaseControl super confusing
04:24:33 <merijn> No way you can get away with using the exceptions package?
04:24:44 <tabaqui> I thought "liftWith $ const getChar" can be any "MonadBaseControl IO m => m Char"
04:25:01 <tabaqui> but, it doesn't want to compile
04:25:30 <bartavelle> I wrote "instance MonadState s (HMS s)" and I get "No instance for (MonadState ServerState (HMS s))"
04:25:32 <tabaqui> merijn: I want to `simplify` my code and make it more generic
04:25:49 <bartavelle> the monadstate instances in mtl do not seem magical in any way
04:25:54 <bartavelle> what did I do wrong?
04:26:05 <tabaqui> there is a lot of filesystem interaction inside of ExceptT SomeException IO
04:26:07 <merijn> tabaqui: exceptions and it's MonadCatch/MonadThrow/etc. is much simpler to use than MonadBaseControl
04:26:34 <phadej> bartavelle: MonadState ServerState (HMS ServerState)
04:26:48 <tabaqui> merijn: dunno, actually I didn't see MonadCatch before
04:27:05 <bartavelle> phadej: yeah, but that is what GHC infers
04:27:21 <bbear> what is the relationship between haskell and scala ?
04:27:21 <bartavelle> ahhhh
04:27:23 <tabaqui> someone showed me Control.Exception.Lifted, so I'm trying it now
04:27:25 <bartavelle> phadej: my bad
04:27:49 <merijn> bbear: Pretty much nothing?
04:28:08 <bbear> they are both statically typed and functional ?
04:28:32 <bbear> Doesn't the scala programming language exhibit some relationship with Haskell ?
04:28:41 <phadej> you can argue about how functional is scala :)
04:37:20 <ij> Is there a flipMaybe 3 Nothing => Just 3; flipMaybe 3 (Just 4) => Nothing?
04:37:53 <s4ke1> damn. co-monads seem neat
04:39:28 <cocreature> ij: I highly doubt it. that doesn’t seem like a particularly common function
04:40:43 <alp> ij, you can easily define it with the help of a function or two. flipMaybe a m = maybe (Just a) (const Nothing) m -- you can even leave out the 'm'
04:41:19 <ij> That's precisely what I've written in my ghci, excluding the m part, yes. :)
04:42:41 <Johulk> Can someone help me with this function?
04:43:26 <Johulk> Its supposed to be like this
04:43:37 <Johulk> percorre :: [Int] -> RTree a -> Maybe [a]
04:43:55 <Johulk> Given a list of Ints and a Tree, you get a pathway
04:44:16 <Johulk> and gives you either a list of a's or Nothing
04:44:49 <Johulk> As in, in the list of ints, 1 means the left-most branch
04:45:48 <lavalike> break it down into cases, e.g. if the list if empty
04:49:49 <ij> Can I auto-derive MonadPlus for a newtype outside of source code I'd like to control?
04:50:25 <merijn> ij: I'm not sure what you mean?
04:51:11 <ij> I'm newtyping IRC, which hasn't derived MonadPlus, so I can't derive it.
04:51:12 <ij> https://hackage.haskell.org/package/irc-client-1.0.0.1/docs/src/Network-IRC-Client-Internal-Types.html#IRC
04:51:32 <merijn> You can't auto-derive a non-existent class, no
04:51:44 <merijn> Also, is IRC even a legal MonadPlus instance?
04:51:46 <cocreature> you can use StandaloneDeriving but that will create an orphan instance
04:52:37 <ij> merijn, It's a reader with IO.
04:52:44 <ij> IO has MonadPlus.
04:55:05 <barrucadu> ij: I can add a MonadPlus instance
04:55:10 <barrucadu> Any other instances you want?
04:55:25 <ij> No, just that would be nice. :)
04:59:08 <ij> I can't derive it on my own, can I?
04:59:19 <ij> No, I can with runIRC, I'm pretty sure.
05:00:02 <ij> At the expense of importing Network.IRC.Client.Internal.Types, though.
05:01:25 <ij> I didn't know "mzero :: IO a" is an error, though that is unsurprising.
05:04:37 <ij> barrucadu, You'll have to also derive Alternative then.
05:06:01 <ij> cocreature, I wanted to flip maybes because I was looking to get a Nothing in a special case of an exception, to ignore timeouts. Instead I put Just mzero on the special case and mzeroed it with the usual case.
05:08:03 <ij> fromException gives you a MaybeException, so I've got a (Maybe SpecialCase) | Nothing.
05:08:30 <AWizzArd> I found this 10-year-old blog post about error handling in Haskell. Today, ten years later – can we say that there is a clear trend of preference?
05:08:37 <AWizzArd> http://www.randomhacks.net.s3-website-us-east-1.amazonaws.com/2007/03/10/haskell-8-ways-to-report-errors/
05:10:17 <kakashiAL> I worked with recursion in java, most of the time with tree structures and oc corse the classic the faculty
05:10:35 <kakashiAL> my question is, if there is a way of thinking about recursion
05:10:52 <kakashiAL> how dou you think, how do you model stuff if you use recursion
05:10:55 <Ferdirand> the faculty ?
05:10:59 <Ferdirand> you mean the factorial ?
05:11:11 <kakashiAL> Ferdirand: sorry, yes :)
05:12:36 <kakashiAL> so I understand how a recursion works, if you give me one implementation I can tell what it does
05:12:48 <kakashiAL> but at the moment I have problems to model stuff with it
05:13:10 <ertes-w> kakashiAL: hard to answer…  i think, neither is the way i think about recursion constant (i have a very different mental model today from the one i had five years ago), nor is there a "correct"/universal one
05:14:14 <Ferdirand> what do you mean, you have problems to model stuff with it ?
05:14:24 <Ferdirand> what are you trying to model, for instance ?
05:14:34 <ertes-w> kakashiAL: i can tell you this much though: for the most part it starts with recursive *types*
05:15:42 <tdammers> there are several ways of constructing recursive code
05:16:37 <tdammers> one way is to start by identifying the base case, i.e., finding an input for which you can find a non-recursive solution right away
05:17:13 <tdammers> and then you try to find an input for which you can find a solution in two steps, based on the one-step nonrecursive case
05:17:24 <tdammers> and then for three steps, and so on, until you see a pattern
05:17:28 <mlehmk> might reimplementing folding be an exercise for recursive functions?
05:17:37 * hackage stateWriter 0.2.10 - A faster variant of the RWS monad transformers.  https://hackage.haskell.org/package/stateWriter-0.2.10 (SimonMarechal)
05:17:55 <ertes-w> kakashiAL: you might be interested in my foldr tutorial…  it's highly relevant
05:18:29 <ertes-w> kakashiAL: http://ertes.eu/tutorial/foldr.html
05:18:43 <tdammers> another nice way is to pretend you already have the solution; and then ask yourself, knowing that I already have the solution for f(n), how can I find the solution for f(n+1)
05:18:52 <kakashiAL> ertes-w: could you tell me your mental model?
05:18:57 <tdammers> then all you need is to find the base case
05:19:09 <mlehmk> and maybe for non primitive recursive, going from fibonacci to ackermann
05:20:10 <ertes-w> kakashiAL: i think in terms of fixed points most of the time
05:20:22 <mlehmk> I don't like mLength of that tutorial
05:20:53 <kakashiAL> tdammers: could you explain it a bit more?
05:20:54 <ertes-w> mlehmk: if you can think of a better one, i'll be happy to replace it =)
05:21:23 <mlehmk> I dunno, it seems it is doing its job as being educational
05:21:31 <tdammers> kakashiAL: sure. let's try map: mapping a function over the empty list is the empty list, that's easy, that's your base case
05:21:59 <tdammers> now in the first approach, you say, OK, so I can solve map f [] = [], how about the next more complex step?
05:22:19 <tdammers> what list can I map over in 2 steps, of which the second step is the base case []?
05:22:24 <mlehmk> I still consider the length of a Maybe [a] to be undefined in case of Noting
05:22:32 <tdammers> easy: [x], a.k.a. (x:[])
05:22:52 <tdammers> map f (x:[]) = f x : []
05:23:12 <tdammers> OK, next more complex case: map f (y:x:[]) = f y : f x : []
05:23:43 <tdammers> but wait, some of that looks familiar: we have x:[] in the argument, and f x : [] in the body
05:24:13 <tdammers> so apparently map f (y:x:[]) = f y : map f (x:[])
05:24:39 <tdammers> and in fact, [] = map f [], so we can even perform a similar substitution in our two-step example:
05:24:49 <tdammers> map f (x:[]) = f x : map f []
05:25:03 <tdammers> now our refactored 2-step and 3-step solutions look very similar
05:25:11 <tdammers> in fact they both follow the same general shape:
05:25:17 <tdammers> map f (x:xs) = f x : map f xs
05:25:34 <tdammers> where xs is [] in the 2-step example, and (x:xs) in the 3-step one
05:25:54 <tdammers> (except that the x there are two different variables, hope that didn't confuse you)
05:25:54 <ertes-w> i think the recursive case can be explained in a simpler way:  if 'ys' is the variant of 'xs' where 'f' has been mapped over all elements, then what's the variant of (x:xs) where 'f' has been mapped over all elements?
05:26:03 <tdammers> ertes-w: getting there
05:26:07 <tdammers> ertes-w: that's the second approach
05:26:31 <tdammers> the second approach is that we pretend that for any value xs, we already have the solution for map f xs
05:26:37 <tdammers> that's the f(n) case
05:27:10 <tdammers> the f(n+1) case for a list is (x:xs), that is, a list with another value prepended to it
05:27:52 <tdammers> map f (x:xs), assuming that we already know how to get map f xs, is a matter of applying f to the prepended element, and prepending that to the solution
05:27:54 <tdammers> so:
05:28:03 <tdammers> map f (x:xs) = f x : map f xs
05:28:33 <tdammers> now all we need to do is add a base case so that our implied chain of reasoning halts somewhere, and that base case is the empty list
05:28:53 <tdammers> either way, things hinge on equational reasoning
05:29:22 <tdammers> sustitute variables into expressions to make them either simpler, or more complex but similar to something that we know
05:31:49 <cheater> hi
05:33:05 <mlehmk> to map using f over x, take f(head of x) and apped map using f over tail of x
05:33:23 <mlehmk> or better, prepend that value to
05:33:40 <cheater> is building with debug info or with coverage supposed to take considerably more ram? a not so complex project made ghc run out of mem. this is the command that failed: cabal install --enable-profiling --enable-debug-info --enable-tests --enable-coverage --enable-benchmarks  this one finished building: cabal install --enable-profiling --enable-tests --enable-benchmarks
05:33:47 <mlehmk> the recursion is, that map is using itself to map the taiö
05:34:24 <ertes-w> kakashiAL: a slightly less obvious function is insertion sort:  base case: the sorted version of [] is [];  recursive case: if 'ys' is the sorted version of 'xs', then what's the sorted version of (x:xs)?
05:34:50 <ertes-w> kakashiAL: feel free to take it as an exercise
05:35:59 <tdammers> cheater: it can take a lot more RAM, yes
05:36:42 <mlehmk> haskel might produce a huge expression tree before resolving it, as it is lazy in evaluation
05:37:01 <tdammers> cheater: in part because of the additional instrumentation that is compiled in, and in part because it prevents some optimizations that lead to more code being processed in intermediate stages of the compilation process, which may occasionally hit performance edge cases in the compiler, causing compile times to blow up nonlinearly
05:41:38 <cocreature> iirc there were also some bugs in ghc < 8.2 where producing DWARF debug info consumed an unreasonably large amount of RAM
05:54:07 * hackage irc-client 1.0.1.0 - An IRC client library.  https://hackage.haskell.org/package/irc-client-1.0.1.0 (barrucadu)
05:55:37 <barrucadu> ij: ^ now with Alternative and MonadPlus
05:55:58 <ij> Thanks!
05:57:27 <kmelva> Just starting with lenses, how to write this `set recordField True someRecord` with `.~`?
05:57:56 <kmelva> But in a way it resembles OOP: `someRecord.someField = True`?
05:59:37 <cocreature> someRecord & recordField .~ True
05:59:49 <liste> > (1,2) & _1 .~ 5
05:59:54 <lambdabot>  (5,2)
06:01:48 <ertes-w> kmelva: there is still a fundamental difference between this and OOP…  if you want to emulate OOP, you can use a state monad or a mutable variable
06:02:13 <kmelva> ertes-w: right, thanks, I think I get that :) I was just wondering how to replicate the syntax, not the semantics
06:02:51 <ertes-w> kmelva: just for the record: the lens library comes with state monad versions of its operators
06:03:13 <ertes-w> (.~) becomes (.=), (+~) becomes (+=), etc.
06:03:19 <kmelva> I was missing an import for (&) and that was messingme up :D embarrasing... I thought that was part of the prelude
06:04:27 <kmelva> ertes-w: thanks, that might come next in my lens exploration... learning this thing is like learning two other fullblown programming languages :)
06:04:55 <kmelva> and that's not joking... I think all of Clojure was less complicated than lens is
06:04:57 <kmelva> :D
06:05:06 <ertes-w> proper lenses are perhaps the most boring aspect of the lens library =)
06:06:18 <ertes-w> > (partsOf (traverse . filtered isUpper) %~ reverse) "Sony Playstation"
06:06:22 <lambdabot>  "Pony Slaystation"
06:06:56 <kmelva> whaaaaaa :)
06:07:23 <ertes-w> traverse: traverse the elements of a list (in this case)
06:07:39 <ertes-w> traverse . filtered isUpper: traverse only the elements that are upper-case letters
06:07:59 <kmelva> I'm with you up to that... but how does it swap them?
06:07:59 <ertes-w> partsOf (traverse . filtered isUpper): lens into those elements as a list
06:08:35 <ertes-w> partsOf (traverse . filtered isUpper) %~ reverse  -- function that reverse that list
06:08:38 <ertes-w> *reverses
06:08:40 <kmelva> oooooooh, so a lens into a list ... is basically an index into list?
06:09:46 <ertes-w> if 'f' is a traversal into parts of 'x', then (partsOf f) is a lens into those parts as a list
06:09:50 <kmelva> that's freaky, so little code should now be able to do that :)
06:10:52 <ertes-w> > view (partsOf (traverse . filtered isUpper)) "Hellow There Bloke!"
06:10:56 <lambdabot>  "HTB"
06:11:27 <ertes-w> except that (partsOf (traverse . filtered isUpper)) is an actual lens, so you can modify that list, and it will be reintegrated into the original value in its modified form
06:12:10 <kmelva> yup, that part is what freaked me out :)
06:12:18 <kmelva> thanks again!
06:16:37 <L0g4nAd4ms> amalloy, just for information my stuff works now properly. thanks again
06:16:47 <ij> I can't catch this ConnectionError from a servant lib. The trace before fromException's successful, but the trace inside "trace =<< fromException e" never gets executed, though it expects a ServantError.
06:22:01 <bartavelle> where can I get the GHC/base version relation?
06:23:01 <cocreature> bartavelle: https://wiki.haskell.org/Base_package
06:23:26 <bartavelle> thx!
06:29:38 <buttbutter> Is anyone aware of a compilers course that uses Haskell?
06:30:54 <nicball> There's a tutorial on writing a LLVM frontend using haskell
06:31:39 <buttbutter> nicball: Stephen Diehl?
06:31:45 <buttbutter> I want an actual course, unfortunately.
06:31:52 <cocreature> nicball: https://github.com/llvm-hs/llvm-hs-kaleidoscope or with more text (but maybe slightly outdated) http://www.stephendiehl.com/llvm/
06:31:59 <nicball> Ok
06:32:14 <us_r-1> hi
06:32:17 <buttbutter> I guess the next best thing is doing the ML Tiger book :(
06:36:42 <us_r-1> I'm tring to use Savant to accept a FormUrlEncoded post request, but the structure of this request is rather odd... it's just a string (not a record). As such, I'd like to specify '[FormUrlEncoded] Text. In doing that though, the compiler rightfully complains that there is no instance of (FromForm Text).. does anybody have any ideas?
06:37:23 <nicball> 《Language Implementation Patterns》?
06:37:53 <nicball> If ur looking for a quick start(
06:41:30 <us_r-1> Savant -> Servant
06:42:07 * hackage yam-servant 0.1.0.2, yam-job 0.1.0.2, yam-app 0.1.0.2, yam-transaction-postgresql 0.1.0.2, yam-transaction-odbc 0.1.0.2 (leptonyu): https://qbin.io/vfgpwfi04
06:50:04 <merijn> Anyone here know how I should go about foreign importing a FunPtr?
06:54:01 <cercerilla> merijn: are you thinking of something like: 'foreign import ccall "&exp" a_exp :: FunPtr (Double -> Double)' (from https://wiki.haskell.org/Foreign_Function_Interface#Function_pointers) ?
06:56:32 <cercerilla> Does anyone here happen to either have experience using BigQuery from haskell (with or without the gogol-bigquery library, which is the only one I've found so far)- or know of any open source projects that I can crawl through the source for?  gogol-biquery is pretty opaque (at least if you don't know the bigquery API well already).
06:57:05 <cercerilla> I'm nearly at the point of just shelling out to 'bq'
07:03:32 <ij> http://sprunge.us/QLDA <-- I'm trying to catch a ConnectionError and the code works, when I made the exception data, but not when I get it, though both of the "show" outputs are similar.
07:04:47 <ij> g label a = trace (show (label, show a)) a
07:05:09 <us_r-1> okay so I solved my problem - I didn't want FormUrlEncoded at all, I wanted an OctetStream.
07:07:32 <Johulk12> Is there a haskell function that given a [Int] and an RTree we get [a], on which each Int is a number from the node, and for example , [1:..] it goes towards the left-most tree
07:07:54 <Johulk12> I have no idea on how to do this one
07:08:15 <jchia_> What's the diff between Control.Concurrent.STM.TBChan (stm-chans) and Control.Concurrent.STM.TBQueue (stm)? What's the recommended module to use for a multiple-witer-single-reader queue used to for multiplex outputting from multiple threads to the the console (multiple threads write to queue, one thread pops from queue to console)?
07:08:59 <amalloy> Johulk12: i guess the first questoin is, what is an RTree
07:09:08 <Johulk12> Is it not predefined on Haskell?
07:09:10 <Johulk12> Thought it was
07:09:41 <Johulk12> http://lpaste.net/361541
07:09:41 <Johulk12> here
07:09:45 <Johulk12> my current function
07:09:47 <Johulk12> but it doesnt work
07:10:14 <Johulk12> I can show you the question I need to awnser
07:10:17 <Johulk12> See if it helps
07:10:34 <maerwald> mh, no useful microservices framework/DSL afais
07:11:29 <lavalike> Johulk12: I'd have guessed you compare x with the length of the children
07:11:29 <Johulk12>  From fine the 'run' function: [Int] -> RTree a -> Maybe [a] that receives a path and a tree and give it a list of values ​​where that path passes. If the path is not valid the function should return Nothing. The path is represented by a list of integers (1 indicates followed by the first sub-tree, 2 by the second, etc.)
07:13:48 <ania123> can one help me to get this paper: http://ieeexplore.ieee.org/abstract/document/8100435/
07:15:01 <cocreature> ania123: sci-hub can :)
07:16:32 <ania123> link?
07:17:31 <ania123> cocreature: could  u give me link please
07:18:13 <cocreature> 1. search for a working scihub url on google 2. paste your url in the search bar there 3. have fun reading the paper
07:22:27 <machinedgod> Yeah, I picked up some kid's schoolwork in haskell. 2 hours, 30euros
07:22:39 <machinedgod> Wrong - channel - sorry
07:22:55 <lavalike> that's some real world haskell
07:22:59 <Clint> ka-ching
07:23:18 <shapr> machinedgod: you can probably get a better price :-P
07:24:01 <machinedgod> Beggars can't be choosers ;-)
07:24:29 <machinedgod> Choice of haskell work on Freelancer is, mildly said, terrible
07:24:58 <shapr> I've never found good work on Freelancer
07:25:37 <shapr> Wasn't someone crowd funding a collection of examples and documentation for the most popular Haskell libs?
07:25:53 <merijn> You know you're doing things right when you resort to using true-name
07:26:05 <shiona> machinedgod: I just hope it was Java class but the kid didn't understand even that much. The face on that teacher would be a sight to behold
07:27:15 <machinedgod> Hahaha, yeah... well I'm offering him some guidance free of charge. He seems to be a good kid, and totally overwhelmed.
07:27:22 <cocreature> now that poor kid will probably never get to learn haskell :(
07:28:48 <metahumor> buy you a haskell
07:28:52 <shapr> Schoolwork never overwhelmed me when I started as soon as I got hold of the assignments. But I was consistently overwhelmed when I left it to the last minute.
07:28:58 <Psybur> Why would somebody sell their homework heh
07:29:09 <consus> For money
07:29:14 <consus> It's obvious
07:29:30 <Psybur> Wait
07:29:31 <machinedgod> You guys are totally correct, but I have an internal grudge against the schooling system, that shuts down my morality system when it comes to this
07:29:34 <Psybur> I think I have it backwards
07:29:39 <shapr> We've had a bunch of people buying homework solutions here over the years.
07:29:44 <Psybur> Why would somebody buy answers
07:30:04 <Psybur> Defeats the purpose doesnt it
07:30:05 <merijn> Psybur: So their parents don't disinherit them over their bad grades :p
07:30:16 <shapr> Some students just want a degree, not actual learning.
07:30:17 <[exa]> I buy high quality questions!
07:30:24 <Clint> it's like academia is completely flawed or something
07:30:27 <Psybur> But then you cant actually use the degree :D
07:30:33 <consus> You can
07:30:37 * hackage wrecker-ui 3.1.0.0 - A web interface for Wrecker, the HTTP Performance Benchmarker  https://hackage.haskell.org/package/wrecker-ui-3.1.0.0 (lorenzo)
07:30:45 <shapr> My classmates were unhappy when I asked in-depth questions that sometimes turned into homework assignments.
07:30:47 <consus> If person who's hiring is only looking for a degree
07:30:53 <[exa]> Psybur: 80% of the world considers the degree to be a paper
07:30:54 <Psybur> You get hired then fired and blacklisted and talked about behind your back and end up on someones blog about stupid people
07:31:01 <consus> That's why there is so much incompetent fuckers around us
07:31:02 <[exa]> ok 95%
07:31:05 <metahumor> Psybur: why install prebuilt packages when you can compile it on your own?
07:31:16 <shapr> consus: yeah, someone interviewed here at this company who had clearly bought their way through a Harvard CS degree. We didn't hire them.
07:31:18 <Johulk12> ffs
07:31:21 <tdammers> Psybur: that's assuming that honest grades are somehow correlated strongly with observed job performance
07:31:22 <Johulk12> I can't get this to work
07:31:23 <Johulk12> :(
07:31:29 <consus> metahumor: Because compiling firefox takes time
07:31:34 <Johulk12>  From fine the 'run' function: [Int] -> RTree a -> Maybe [a] that receives a path and a tree and give it a list of values ​​where that path passes. If the path is not valid the function should return Nothing. The path is represented by a list of integers (1 indicates followed by the first sub-tree, 2 by the second, etc.)
07:31:35 <consus> shapr: Someone else did
07:31:44 <Johulk12> Does someone know how to make this function?
07:31:51 <Psybur> tdammers, Im not talking about the grades received for doing the work, Im talking about doing the work so you know what youre doing :P
07:31:55 <shapr> consus: I'd believe it, the guy was very good in the interview until you started asking him about code.
07:32:10 <consus> shapr: Yeah
07:32:34 <shapr> He certainly snowed my co-interviewer
07:32:35 <Psybur> shapr, what questions did you ask that made him crumble?
07:32:38 <tdammers> Psybur: I'm talking about people bullshitting their way through college, getting good grades they don't deserve, and then using those to score a job
07:32:51 <[exa]> Johulk12: do you have some code to start with?
07:33:01 <shapr> Psybur: I asked questions that weren't the kind of thing you could answer after having read "cracking the coding interview" and that kind of thing.
07:33:20 <Psybur> shapr, do you happen to remember one specific question? :D
07:33:35 <shapr> let me check my notes
07:33:53 <Psybur> Ill take more than one if youre generous :D?
07:33:53 <tdammers> Psybur: in some jobs, this will end badly, because you need to actually know your stuff in order to stand a chance of performing well, but the majority of office jobs seems to be more about being good at waiting for people to say words you know in a meeting, and responding with words you also know
07:35:13 <[exa]> Johulk12: (also, do you have the RTree definition?)
07:35:29 <consus> I like to ask about how the hell do people debug there stuff
07:35:50 <Psybur> consus, by using copious print statements OBVIOUSLY :D?
07:36:06 <lavalike> Debug.Trace.{traceShowId,traceM} mostly
07:36:10 <consus> Well something like 'we have a crashed binary, what's next'
07:36:20 <consus> (talking unix here)
07:36:27 <Psybur> Load core dump into gdb :D?
07:36:27 <shapr> Psybur: ah it turns out I asked him to write code to reverse a list in his favorite language, and he was unable to do anything other than mylist.reverse()
07:36:28 <kadoban> consus: "Run in circles, scream and shout" ?
07:36:40 <consus> Only a very small amount of people know about a goddamn crash dump
07:36:45 <Johulk12> @Exa Yes
07:36:45 <lambdabot> Unknown command, try @list
07:36:51 <Johulk12> [exa]: Yes I do
07:36:55 <shapr> Psybur: hehe, here's my interview conclusion: "I might hire him as a salesperson, but not as a developer."
07:37:03 <Psybur> rofl
07:37:13 <[exa]> consus: gdb, find the line, add printfs!
07:37:15 <Johulk12> http://lpaste.net/361541
07:37:27 <consus> [exa]: Even less know about gdb
07:37:43 <[exa]> I don't know much gdb either
07:37:44 <consus> [exa]: Well... they do know about gdb, but they do not know that coredump + gdb + binary = win
07:37:47 <[exa]> like, press r
07:37:50 <shapr> Psybur: it goes on: "X had not heard of sqlite, thus his use of postgresql for his GSD. This is surprising, since his choice for his GSD, django, uses sqlite by default."
07:37:51 <[exa]> then bt full
07:37:55 <[exa]> see what happens
07:38:06 <consus> Scream and shout :D
07:38:25 <consus> But, that was a C-developer
07:38:49 <shapr> I've interviewed something like sixty people here, I've seen a wide variety of lack of self-knowledge.
07:39:13 <[exa]> Johulk12: ok, let's construct it from the inside. The recursion scheme is right, but we first need to recognize whether we can continue taking the n-th turn in the tree
07:39:23 <DK21> how do you exactly start haskell webapps on a server?
07:39:28 <Psybur> > let rev (x:xs) = (rev xs) ++ [x] in rev "abcd"
07:39:33 <lambdabot>  "*Exception: <interactive>:3:5-32: Non-exhaustive patterns in function rev
07:39:34 <DK21> just execute it? and a reverse proxy to forward requests?
07:39:52 <Johulk12> Mm.
07:39:53 <shapr> One of my favorite interviews was an applicant who was nearly sixty years old, he'd started with Python the week before and wrote better code than I do now. I'm so glad we hired him.
07:39:55 <DK21> 8
07:40:01 <cocreature> shapr: what’s a GSD?
07:40:07 <Psybur> > let rev [] = []; rev [x] = [x]; rev (x:xs) = (rev xs) ++ [x] in rev "abcd"
07:40:11 <lambdabot>  "dcba"
07:40:16 <shapr> cocreature: I forget the polite terminology, but it's short for "get shit done"
07:40:16 <Psybur> shapr do i get the job :D?
07:40:35 <Johulk12> [exa]: Would I need some kind of "lateral" length for that right?
07:40:43 <shapr> Psybur: if you want to write Python, Go, Ruby, and C++ in Atlanta, send me a resume
07:40:54 <Psybur> Sounds like everything I -dont- want to do haha
07:40:57 <toby1851> speaking of jobs, my employer is recruiting at the moment - it's mainly system / network admin, but there is some development and a teeny tiny bit of Haskell - http://jobs.mythic-beasts.com/
07:41:19 <shapr> toby1851: oh that's sneaky awesome recruiting
07:41:21 <lavalike> > foldl (flip (:)) [] "rubsyP"
07:41:25 <[exa]> Johulk12: Start here http://lpaste.net/361541
07:41:26 <lambdabot>  "Pysbur"
07:41:36 <shapr> toby1851: I got an HTTP 505 when I clicked step 1 :-(
07:41:38 <Psybur> Rubsy P!
07:41:43 <Johulk12> Thanks [exa]
07:42:05 <shapr> toby1851: is step 1 figuring out how to work around the website?
07:42:20 <kadoban> Step one is debugging that server error, yes.
07:42:20 <[exa]> Johulk12: btw write the recursion without "Just" first, if you can. Catching the incoming "nothing" will require another if
07:42:25 <toby1851> shapr: you're doing well!
07:42:53 <kadoban> It seems to just hang on a blank page for me. Maybe too many people at once xD
07:42:54 <[exa]> shapr: in the age ofmeltdown/spectre you're expected to dig the information yourself
07:42:58 <Johulk12> Alright
07:43:11 <Johulk12> [exa]: How would I then add the Just ? I need this function to use maybe
07:43:25 <shapr> [exa]: fair enough, I was just wondering if I could use meltdown to beat ransomware
07:44:33 <[exa]> Johulk12: I was thinking about not mixing two concerns together (1. choosing and returning the right path 2. failing safely when there isn't any)
07:44:48 <metahumor> Johulk12: fyi, indexing in lists in haskell is 0-based
07:45:43 <Psybur> shapr, get shit dones are web frameworks to you, or is this different from person to person
07:45:48 <[exa]> Johulk12: fill up a piece of the code and send it back to me when you reach something problematic, I'll add some pointers
07:45:50 <Psybur> Depending on role
07:45:56 <Johulk12> Okay
07:45:59 <Johulk12> I have 10 minutes
07:46:01 <Johulk12> lets goo
07:46:29 <shapr> Psybur: We ask our applicants to not put their solutions on github, but they do it anyway. Once new applicants start reusing code from previous applicants, we change the GSD task description.
07:46:39 <Johulk12> also [exa] : this list must start in 1
07:46:53 <Johulk12> Not with the number 1 is correct
07:46:57 <toby1851> kadoban: i'm not supposed to give any clues, but i don't think the server is overloaded :) you may have to think outside the box
07:47:01 <Johulk12> BUT the minimum value is 1
07:47:16 <Psybur> Oh so GSD is specific to your interview process. I thought you were referring to programmers in general.
07:47:26 <Psybur> I was thinking my GSD right now is apache-spark heh
07:47:48 <shapr> Psybur: lots of applicants just can't write code, but somehow believe they could work here.
07:48:01 <kadoban> toby1851: Ah, I see.
07:48:01 <toby1851> DK21: systemd .service file to start the binary, reverse proxy (nginx / apache) fronting it
07:49:06 <toby1851> however, i've been thinking recently that i might skip the reverse proxy and just let the apps (all yesod in my case) bind 80 / 443 directly
07:49:44 <[exa]> Johulk12: so the lists are indexed from 1 if I get it?
07:49:53 <Johulk12> Yes, this one
07:49:57 <Johulk12> I have less than 5 minutes
07:49:58 <Johulk12> ffs
07:50:39 <cercerilla> shapr: My philosophy has always been that I don't care if you post your solution to github- in fact I encourage it.  I'm judging the solution more based on how well someone can talk about their solution and why they made the decisions than did than strictly on the code.  Someone who stole code isn't going to be able to get through that part of the interview anyway.
07:51:10 <shapr> toby1851: ok, this is fun
07:51:17 <[exa]> Johulk12: anything yet?
07:51:45 <Johulk12> Well
07:51:46 <Johulk12> Nope
07:51:48 <Johulk12> ITs okay
07:51:49 <Johulk12> I have to go
07:51:54 <[exa]> Johulk12: btw only for the reason you can make it on time, this should work http://lpaste.net/5273513429036957696
07:51:55 <Johulk12> Been stuck here for quite some time
07:51:56 <cercerilla> Besides, I'm not going to give someone else free work during the interview process (especially since exercises tend to come early).  Either let me own my own work and have it as part of my portfolio, or pay me for it.
07:52:05 <Johulk12> Oh thanks
07:52:09 <Johulk12> I'll be back later :D
07:52:10 <[exa]> Johulk12: also a better version
07:52:32 <consus> Can I somehow break recv?
07:52:52 <[exa]> Johulk12: http://lpaste.net/6912019319039721472   (maybe it fails, I don't have ghci at hand)
07:52:59 <consus> I want something similar to poll
07:53:21 <[exa]> consus: break in what way?
07:53:32 <shapr> cercerilla: We get a large number of applicants, it's good to filter them early if possible.
07:53:42 <shapr> cercerilla: but I agree with what you said.
07:53:51 <[exa]> consus: if you only need polling, do it with select or poll
07:54:11 <consus> The thing is -- I want to exit on sigTERM
07:54:13 <metahumor> [exa]: that (<$>) version is nicer and tail-recursive =)
07:54:26 <consus> So I've installed my handler, created a recursive  loop  via MVar
07:54:52 <consus> Only to find out that recvmsg ultimately blocks :)
07:55:05 <[exa]> metahumor: if I remembered stuff from Data.Maybe we could also shove out the other condition :D
07:55:07 * hackage haskell-src-meta 0.8.0.2 - Parse source to template-haskell abstract syntax.  https://hackage.haskell.org/package/haskell-src-meta-0.8.0.2 (GeoffreyMainland)
07:55:19 <consus> I want something similar to what libev does I guess
07:55:31 <consus> An event loop
07:55:32 <[exa]> consus: set it nonblocking?
07:55:36 <kadoban> metahumor: That doesn't look actually tail recursive
07:56:07 <consus> I guess it's not that syscall blocks
07:56:12 <[exa]> consus: the usual way to do it is call setsockopt(fd, SO_NONBLOCK) or something like that, and then use select() for waiting
07:56:17 <consus> Yeah
07:56:27 <consus> Though I thought haskell does it internally
07:56:38 <consus> I can't see how green threads works if not
07:56:43 <[exa]> consus: I don't know on what level the RTS interferes
07:56:54 <[exa]> consus: but you can easily see the source of blocking using strace
07:57:00 <consus> Yeah
07:57:03 <consus> I know
07:57:32 <consus> Just being lazy
07:57:39 <[exa]> :]
07:58:01 <kakashiAL> why are lists called "recursive data"?
07:58:24 <[exa]> metahumor: btw it's not tail recursive, <$> needs the right value before returning anything
07:58:42 <metahumor> oh
07:58:43 <[exa]> (but it looks tricky)
07:59:24 <[exa]> kakashiAL: because their definition is self-referential ("list is either empty, or contains a value and a list with the rest of the values")
08:00:07 * hackage elm-bridge 0.4.2 - Derive Elm types and Json code from Haskell types  https://hackage.haskell.org/package/elm-bridge-0.4.2 (SimonMarechal)
08:02:01 <metahumor> [exa]: what about "percorre = traverse . go' where go' :: [Int] -> RTree a -> [Maybe a]"
08:02:35 <metahumor> and then the "go'" can have a tail recursive call of "a : go' ns ..."
08:02:49 <metahumor> * "Just a : go' ns ..."
08:03:25 <[exa]> the probem is that he wanted the inner Nothing escape to toplevel (so you can't emit anything until you're sure that the path ends well)
08:04:26 <metahumor> > traverse id [Just 1, Nothing]
08:04:30 <lambdabot>  Nothing
08:04:34 <kakashiAL> [exa]: you mean its a recursive datastructure, because you can express it as:  "head of the list" : "rest of the list"
08:04:45 <ph88_> need to decide in which frontend framework i want to invest, my favourites candidates are purescript and vue
08:04:54 <ph88_> can't make up my mind
08:05:19 <[exa]> kakashiAL: exactly because "rest of the list" is also a list
08:06:16 <[exa]> ph88_: vue is pretty good
08:06:25 <[exa]> at least compared to the rest of js
08:06:25 <ph88_> i know :p
08:06:42 <kakashiAL> "head of the list" : "rest of the list"  which can be expressed as  "head of the list" : ""head of the list" : "rest of the list""  and so on, thanks [exa]
08:07:18 <[exa]> kakashiAL: it's about words I guess, "recursive" is usually used as a synonym for "self-referential" or "contains itself"
08:08:03 <kakashiAL> "recursive" "self returning" which makes sense if you have the stack in your mind
08:08:49 <[exa]> self-returning might be a completely other kind of beast (like quines)
08:10:32 <toby1851> ph88_: PureScript looks interesting, thanks for the pointer
08:10:38 <ph88_> :D
08:11:52 <ph88_> well purescript is fp and seems hackable enough to be a good choice .. on the other hand vue already gives you a lot out of the box and is also a great framework
08:12:10 <kakashiAL> [exa]: recursion comes from the word "recurrere", which means "walkin back" :)
08:12:14 <ph88_> with vue more people created stuff for it (more batteries included)
08:12:29 <kakashiAL> [exa]: but still looking for a better way to think about it
08:17:05 <metahumor> [exa]: "percorre ixs tree = traverse id (go ixs tree) where go [] (R a _) = [Just a]; go (n:ns) (R a bs) | n < length bs = Just a : go ns (bs !! n) | otherwise = Nothing : []"
08:17:14 <yushyin> kakashiAL: https://en.wikipedia.org/wiki/Recursive_data_type
08:34:48 <rovar> hey all,  I am looking at building a server based on the MQTT protocol in Haskell.  I am wondering what is the current recommendation for higher level socket/stream abstractions which can encompass scenarios such as  clients streams which might disconnect/reconnect, and also, outside of the scope of the main/happy path of code, things like handling PING/PONG and other connection maintenance type tasks..
08:35:03 <rovar> or are there examples of libs that do this? e.g. http2 etc..
08:43:52 <orion> rovar: That sounds like a fun project.
08:44:00 <orion> Do you need to keep state?
08:45:42 <rovar> orion:  There would definitely need to be state kept at both the connection and the server level.  e.g. A connection would need to track all topic subscriptions created by the consumer of the connection.. (not to mention user identify, etc)
08:46:20 <rovar> also the MQTT spec allows for client reconnections,  which include short-term message buffering.
08:46:22 <orion> hmm
08:46:37 * hackage haskell-src-exts-sc 0.1.0.2 - Pretty print haskell code with comments  https://hackage.haskell.org/package/haskell-src-exts-sc-0.1.0.2 (achirkin)
08:50:06 <orion> I've connected TCP sockets to Pipes before.
08:50:41 <orion> IIRC, Pipes does not have finalizers like conduit does.
08:51:07 <orion> https://www.yesodweb.com/blog/2013/10/core-flaw-pipes-conduit
08:53:00 <ertes-w> pipes doesn't have them *built in*
08:53:20 <ertes-w> you'd normally use something like ResourceT for that
08:53:48 <ertes-w> or my favourite monad transformer, Codensity, in simple cases =)
08:54:39 <ertes-w> rovar: stream processing is a "low-level" abstraction for that, but you could also choose to go with a high-level abstraction: concurrency
08:55:03 <ertes-w> individual threads would then take care of connecting, reconnecting, etc. and only send the other threads messages they care about
08:55:27 <cocreature> conduit is actually considering to drop finalizers https://www.snoyman.com/blog/2018/01/drop-conduits-finalizers
08:55:36 <ertes-w> rovar: see the 'async' library as a starting point
08:55:57 <rovar> ertes-w :  I'll have a look. thanks.
08:56:30 <ertes-w> rovar: also if you're ready to invest some time in learning how to do it properly and efficiently, read The Book
08:56:33 <orion> The book keeping required to support client recommections/message buffering.
08:56:33 <ertes-w> @where PCPH
08:56:33 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>
08:57:16 <ertes-w> rovar: the main difference between these two approaches is that with stream processing there is a much tighter semantical/operational coupling between the producer and the consumer
08:57:28 <rovar> I am most concerned about ergonomics for the user of the API, so I would want to make sure it is idiomatic and as simple as possible
08:58:00 <amalloy> is there a way i can enable -Wall by default for stack builds on my machine? i'm guessing the answer is, i can't do it machine-wide because of reproducible builds, but there's something i can put into my stack.yaml?
08:58:20 <ertes-w> rovar: in that case i'd go with stream processing…  API users can wrap a higher-level abstraction around it, if they want/need to
08:58:23 <rovar> on the client API,  I think that a tight coupling would make sense.. since there aren't many tasks it would need to perform..
08:58:56 <rovar> on the server, though.. there are quite a bit more responsibilities, also, making custom brokers/servers would be less likely..
09:00:22 <rovar> I'm just trying to picture how streams would compose into higher level streams..  like the reconnecting stream, for example..
09:00:26 <orion> ertes-w / rovar: Do you consider semantic/operational coupling to be not ergonomic?
09:00:38 <rovar> which would "swap out" its underlying stream if the connection fails and is re-established..
09:00:47 <ertes-w> rovar: stream frameworks like conduit, machines, pipes are all compositional, so users actually get a lot of freedom in how they want to compose
09:01:06 <rovar> I'll look at those as well, then :)
09:02:17 <ertes-w> rovar: if they go with the "default" of the framework (($$) for conduit, (~>) for machines, (>->) for pipes; they all do the same thing), they get tight coupling
09:03:15 <ertes-w> (seems like (.|) is now the normal way to compose conduits)
09:05:23 <ertes-w> rovar: there are ways to "restart" a producer…  the most obvious one is to handle failure, while a library like machines has "failure" as a built-in concept and provides something like 'repeatedly'
09:06:42 <ertes-w> rovar: disclaimer 1: machines is my favourite, so consider this highly biased =) disclaimer 2: out of those three it's the one with the smallest amount of community support
09:08:59 <rovar> hmm
09:10:16 <alexteves_> is there some sort of type-level composition operator? like (Just . singleton "whatever" . Just) 0 would have type (Maybe :.: Map String :.: Maybe) Int
09:10:37 <dmwit> https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Functor-Compose.html
09:10:39 <Ferdirand> there is Compose
09:13:58 <alexteves_> ah, so an operator form of the Compose constructor (plus precedence/associativity and such) would do the trick
09:14:55 <ertes-w> alexteves_: it's a bit unwieldy, but you can use Compose infix
09:14:58 <ertes-w> f `Compose` g
09:15:03 <alexteves_> oh right
09:17:04 <ertes-w> @let type (.) = Compose
09:17:05 <lambdabot>  .L.hs:171:7: error:
09:17:05 <lambdabot>      Illegal symbol '.' in type
09:17:05 <lambdabot>      Perhaps you meant to write 'forall <tvs>. <type>'?
09:17:42 <ertes-w> @let type (:.) = Compose
09:17:45 <lambdabot>  Defined.
09:17:51 <ertes-w> :k Maybe :. Maybe
09:17:52 <lambdabot> * -> *
09:29:12 <orion> ertes-w: I've never heard of machines before. I'm reading about it now. Looks pretty cool.
09:31:31 <kmelva> Any ideas how to fix this type error with gogol & gogol-youtube: https://gist.github.com/kmelva/3317f293f699f0119a7c9adfa1749d8e
09:34:17 <dmwit> I suggest following the advice given in the error message.
09:34:46 <kmelva> dmwit: that's what I would do also! if I knew how to :D
09:35:33 <dmwit> What is the type of G.newEnvWith?
09:36:17 <kmelva> newEnvWith :: (MonadIO m, MonadCatch m, AllowScopes s) => Credentials s -> Logger -> Manager -> m (Env s)
09:36:33 <kmelva> It's this lovely thing :D
09:38:53 <dmwit> Right. You should pick concrete types for `m` and `s`, then use them to annotate either the type of `G.newEnvWith` or the type of the whole expression, whichever feels better to you.
09:39:25 <dmwit> e.g. `G.newEnvWith {- args ... -} :: IO (Env [])`.
09:39:45 <kmelva> Let me try!
09:40:57 <dmwit> (It is probably intended that in a larger program, you would use `environment` in a way that fixes `s` and this never comes up. Test programs can be harder than full programs in this way sometimes.)
09:40:57 <kmelva> Does not work just like that, I had to write: IO (G.Env '[])
09:41:21 <kmelva> Don't quite get why it needs that tick there... a type level list?
09:41:29 <kmelva> Now it compiles... let's see if it works :)
09:46:46 <kmelva> Weeeeell... it compiles, makes some kind of a request, but it's malformed :/
09:47:07 <kmelva> Man, working with Haskell sometimes one feels so powerless :/
10:02:33 <sqooq> dmwit, the thing you made me hangs when using double, even with the conversions. Not sure why.
10:02:51 <sqooq> probably floating point errors causing issues
10:22:07 <amalloy> is there a way i can enable -Wall by default for stack builds on my machine? i'm guessing the answer is, i can't do it machine-wide because of reproducible builds, but there's something i can put into my stack.yaml?
10:27:40 <dmwit> sqooq: The standard debugging techniques apply. Minimal reproducible example, Use the Source, etc.
10:36:56 <sqooq> dmwit, hmm i just tested again and it wasn't bad...
10:37:06 <sqooq> idk, i'm taking a break
10:44:16 <hux> Hey everyone
10:44:55 <cement> I love how nearly everything that happens over the network ends up devolving to bit-bashing
10:45:51 <hux> Can someone help me with the StateT monad, I have a StateT s IO [a], i give him a State s [a] and I would like to be able to got (<-) in the body of the StateT function, but the compiler is saying that StateT s IO [a] is expected (StateT s Identity [a] is inferred from State s [a] I guess)
10:53:05 <euniarte> hux: Are you trying to use a function of type f :: State s [a] inside a function g :: StateT s IO [a]?
10:54:01 <mnoonan> hux: you should be able to put it together from state :: (s -> (a,s)) -> m a" and  "runState :: State s a -> s -> (a,s)"
10:54:04 <euniarte> I think you will have to change the type of f to support arbitrary monads inside stateT
10:57:05 <cheater> tdammers: thanks! that makes sense to me. which of the flags is the offender - debugging or coverage?
11:31:47 <tdammers> cheater: honestly, no idea. both have the potential, I would wager that either could be the culprit
11:41:57 <parsnip> where do i look up what a specific language pragma is?
11:42:38 <glguy> ghc user's guide
11:45:15 <parsnip> aha, thank you https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html
11:45:52 <glguy> There's a search box, you can just type in the one you wanted
11:48:20 <codeshot> I've asked before but forgot. How do you transform IO with the ((,) a) monad? Or any standard monad that supports transformation?
11:49:51 <glguy> Neither (,)a nor IO is a monad transformer, you could use:  WriterT a IO
11:50:00 <glguy> or whatever are you trying to do?
11:54:22 <codeshot> I want to write a function that makes a IO value to print a pseudo random number with randomR getting the range limit from a precursor list, but I have to mapM (I think) so the random number generated is evolved through the list. Then I want to make a list of IOs and use traverse to make the precursor list. This way I have to independently developed units. Then I want to compose those two units so a limit is read
11:54:22 <codeshot> and the random number printed, then the next read and print ...
11:54:39 <codeshot> This is to practice building and composing software with haskell, such as would happen in a large team
11:55:30 <codeshot> ]write a function to make a list of IO values...
11:55:36 <dmwit> % replicateM 5 (randomRIO (1, 10)) -- ?
11:55:38 <yahb> dmwit: [7,7,7,9,9]
11:55:57 <dmwit> What terrible luck.
11:56:00 <dmwit> % replicateM 5 (randomRIO (1, 10))
11:56:00 <yahb> dmwit: [7,1,3,5,4]
11:56:09 <dmwit> There, that looks much more random. ;-)
11:56:18 <codeshot> I want to do this by composing or else I'm unprepared for large scale application development
11:56:32 <codeshot> the random number thing is just a vehicle for learning, not the goal
11:56:54 <dmwit> But maybe what you should be learning from this is that complicated is not necessarily better.
11:57:12 <codeshot> I'm not looking for complicated
11:57:21 <codeshot> I'm looking for distributable development process
11:57:27 <codeshot> and distributable design
11:58:00 <dmwit> "Distributable" as in "can be split into jobs that get sent to other computers"?
11:58:09 <codeshot> to other engineers
11:58:24 <dmwit> Okay, I'm lost. I don't think I can help you.
11:58:27 <codeshot> without waiting for a grand design from a rockstar superhero
11:58:54 <consus> codeshot: Frankly, it's pretty hard to distribute work if the project is in early stage
11:59:11 <codeshot> I can see, but that's not necessarily required of our language
11:59:31 <codeshot> because we have done that to ourselves doesn't mean we're required to do it to ourselves tomorrow
12:00:33 <codeshot> last week I asked a deli attendant if she could score and remove some meat's peppercoating before slicing so it was removed easier and she said she couldn't because "that's how it's sold". I suspect this is the same situation
12:01:00 <MarcelineVQ> sounds like you should switch deli's
12:01:17 <codeshot> but this is the only haskell chat room I know
12:01:28 <MarcelineVQ> I wasn't being allegorical, I meant your deli sucks
12:01:35 <codeshot> oh i see :D
12:01:57 <consus> The thing is -- haskell is not very good for large teams
12:02:01 <consus> Really
12:02:42 <ggVGc> is that because there is a sum total of 5 haskell programmers?
12:02:49 <codeshot> which is odd because as a lazy functional language with so much provable ways to compose things you'd think the means of composition would be in the library by now
12:03:02 <consus> Nah
12:04:22 <consus> The whole 'you have to design your goddamn monadic stack before you can even log anything' is not helping in this area
12:05:39 <ggVGc> dmwit: fun fact about randomness, that you just experienced. In the early days spotify got critique for their shuffle algorithm not being random enough, because people often experienced getting multiple songs by the same artist in a row, which is because it was in fact totally random. So they spent a lot of effort making it "nicely random", and now it's not random at all, but fairly carefully managed
12:05:39 <koala_man> codeshot: I think that's retail speech for "you've got to be kidding me"
12:05:45 <ggVGc> randomness to appeal to what people expect from
12:05:48 <ggVGc>  playlists
12:06:07 <mud> consus: Even if that were true, which seems ... dubious. Why would that have anything to do with limiting the lize of a haskell team?
12:06:47 <codeshot> koala_man, its "run a knife round, pull it off, slice the peeled bit". vs "dangling bits of crap handed to the customer which he peels of inch by fragile inch getting wholly messy"
12:07:03 <consus> Because in order to get things done on a level you need a a) good team b) VERY good communication inside that team
12:07:06 <codeshot> attendent is not required. machine can slice and wrap by itself
12:07:33 <koala_man> codeshot: also, please peel my grapes because I don't want to pay for the skin and seeds
12:07:46 <Vyse007> consus: exactly. You either need a "master design", or just pray to god that your stack works with that of your fellow engineer(s)
12:07:57 <codeshot> I would be happy if she included the peel when weighing and discarded it after I paid
12:08:06 <ggVGc> my wife once ordered a dragonfruit smoothie "without the seeds". The woman didn't get the joke and looked fairly confused and annoyed
12:08:14 <koala_man> from what I read of retail stories, usually a fight will ensue
12:08:39 <codeshot> it's only the faff I cared about
12:09:50 <mud> consus: How is that unique to haskell? Not following
12:28:21 <codeshot> Rofl:
12:28:22 <codeshot> Prelude System.Random Control.Monad Data.Bifunctor> foldM (\g l -> first (:[]) $ randomR (1,l) g) g [100,100,100,100,100,100,100,300]
12:28:22 <codeshot> ([12,67,67,49,92,84,36,95],595486200 1622029567)
12:28:23 <codeshot> Prelude System.Random Control.Monad Data.Bifunctor> foldM (\g l -> first (:[]) $ randomR (1,l) g) g [100,100,100,100,100,100,100,1000]
12:28:23 <codeshot> ([12,67,67,49,92,84,36,195],595486200 1622029567)
12:28:24 <codeshot> Prelude System.Random Control.Monad Data.Bifunctor> foldM (\g l -> first (:[]) $ randomR (1,l) g) g [100,100,100,100,100,100,100,10000]
12:28:27 <codeshot> ([12,67,67,49,92,84,36,195],595486200 1622029567)
12:28:29 <codeshot> Prelude System.Random Control.Monad Data.Bifunctor> foldM (\g l -> first (:[]) $ randomR (1,l) g) g [100,100,100,100,100,100,100,100000]
12:28:32 <codeshot> ([12,67,67,49,92,84,36,40195],595486200 1622029567)
12:28:34 <codeshot> Prelude System.Random Control.Monad Data.Bifunctor> foldM (\g l -> first (:[]) $ randomR (1,l) g) g [100,100,100,100,100,100,100,1000000]
12:28:37 <codeshot> ([12,67,67,49,92,84,36,940195],595486200 1622029567)
12:28:39 <codeshot> Prelude System.Random Control.Monad Data.Bifunctor> foldM (\g l -> first (:[]) $ randomR (1,l) g) g [100,100,100,100,100,100,100,10000000]
12:28:44 <codeshot> last number of each run: 95, 195, 195, 40195, 940195
12:29:34 <[exa]> multiplicative groups ftw
12:30:23 <[exa]> (see man 3 rand)
12:34:02 <albatross_> http://lpaste.net/361546  this funciton doesn't work with an empty list....
12:34:25 <albatross_> > skips []  <interactive>:66:1: warning: [-Wtype-defaults]     • Defaulting the following constraint to type ‘()’         Show a0 arising from a use of ‘print’     • In a stmt of an interactive GHCi command: print it []
12:34:29 <albatross_> this is the error message
12:34:30 <lambdabot>  <hint>:1:103: error: parse error on input ‘type’
12:36:15 <dmwit> ggVGc: Sure. In short, many people conflate "random" and "uniform and IID", but it turns out that IID uniform is pretty crappy for many, many uses of randomness.
12:36:40 <EvanR> IID?
12:36:50 <dmwit> Independent and identically distributed.
12:37:34 <infandum> Is there a space leak here? https://pastebin.com/NydjhXyg
12:37:35 <dmwit> A common assumption in machine learning models that is surely wrong but nevertheless useful, and so got its own abbreviation.
12:37:40 <wedify> albatross_, skips has no error for me
12:37:58 <infandum> Should be "Dendrogram Special"
12:38:06 <infandum> err
12:38:09 <infandum> Dendrogram Int
12:38:13 <infandum> doesn't really matter
12:38:22 <infandum> It's the traversal which makes me think there is
12:39:02 <EvanR> "surely wrong but nevertheless useful" <- lovin it
12:39:41 <mud> EvanR: Pretty much describes any model of anything
12:40:37 <dmwit> EvanR: You may also like this Asimov quote: "When people thought the earth was flat, they were wrong. When people thought the earth was spherical, they were wrong. But if you think that thinking the earth is spherical is just as wrong as thinking the earth is flat, then your view is wronger than both of them put together.".
12:40:53 <MarcelineVQ> albatross_: yes it does
12:40:55 <EvanR> nice
12:41:55 <albatross_> MarcelineVQ, yeah i misread the warning XD
12:41:56 <Welkin> EvanR: mcdonalds native ad spotted
12:42:02 <Welkin> EvanR is a shill
12:42:40 <MarcelineVQ> albatross_: hehe alrighty. yeah, it's saying that it doesn't know what the type of your empty list is so for [a] it's picking () for a
12:44:01 <dmwit> infandum: Space leaks happen when the programmer and the program disagree about what things should be kept in memory. What things do you think should be kept in memory by this traversal? Keep in mind that the program's answer to that question will depend a lot on the *consumer* of the traversal, and therefore yours should too.
12:45:09 <consus> dmwit: I just had a memory leak inside a monadic recursive function
12:45:43 <consus> https://ghc.haskell.org/trac/ghc/ticket/13080
12:48:39 <infandum> dmwit: Well now I'm not so sure what the the leak would be, but essentially I have a tree structure saved in a text file by haskell and I want to read it back in using read . B.unpack . B.readFile $ file. The file is 1gb but the program is taking up over 10gb. I understand that reading with bytestring and immediately unpacking is wasteful, but reading with lazy strings tend to result in unclosed file handles with me.
12:50:07 <dmwit> consus: Good to know, I guess. I don't really know why you told me, though, so if you had a goal you should spell it out clearly for me. I take after my nick, you see. =)
12:50:54 <dmwit> infandum: I suggest using a parser designed for working with ByteStrings directly; perhaps attoparsec or similar.
12:51:19 <dmwit> Especially so if B is Data.ByteString.
12:51:35 <dmwit> 10 bytes per Char in a String wouldn't surprise me at all.
12:52:12 <glguy> I'd be surprised if it was that low :)
12:52:20 <dmwit> And I don't think read is especially GC-friendly. At least I don't think it was designed/implemented with that in mind.
13:08:46 <wedify> regarding lazy io, what if readFile kept track of how many strings have been created and raised an error if there's too many. it would be problematic if you needed more than that but for fewer strings than max file handles would this approach work?
13:12:24 <infandum> dmwit: I specifically saved it as a haskell structure. What would be better: saving as json with aeson then reading it in or saving with haskell and reading it in?
13:12:31 <infandum> I did the latter for convenience
13:14:28 <dmwit> infandum: Either is fine, but there is not any existing code that I know of for parsing the standard Show format efficiently.
13:15:15 <dmwit> e.g. see xmobar, which goes to great lengths to implemont a parser for Haskell format configurations.
13:15:49 <dmwit> though they didn't do it for efficiency, I think
13:17:54 <yeoman> are there people choosing () over $
13:18:11 <metahumor> i would like to choose $$$ over $
13:18:22 <wedify> yeoman: yeah
13:18:25 <dmwit> sometimes, yes
13:18:25 <hyperisco> yeoman, as much as I can
13:18:51 <hyperisco> there are some nice uses of $ such as immediately before a lambda
13:19:07 <EvanR> $ when youre lazy
13:19:20 <glguy> yeoman: In the beginning of learning Haskell people tend to overuse $
13:19:30 <hyperisco> using End & Home keys will help you a lot with parens… ;)
13:19:31 <EvanR> ( ... when youre trying to make code to hang on the wall
13:19:59 <hyperisco> or whatever these obvious keys get obscured to in Emacs/Vim …
13:20:12 <EvanR> no End or Home on macbook air :(
13:20:17 <metahumor> hyperisco: funnily, in vim, End is $
13:20:21 <hyperisco> lol
13:20:31 <metahumor> because it is in regexs
13:20:39 <EvanR> no End is ESCAPE SHIFT 4 i
13:20:47 <EvanR> in vim
13:20:56 <EvanR> (or escape capital A i)
13:21:11 <hyperisco> yeah sounds more like it
13:21:46 <metahumor> capital A suffices to start writing, $i won't write at end of line, it will insert before last character
13:21:58 <EvanR> oh right
13:22:01 <metahumor> either "A" or "$a"
13:22:07 <EvanR> i can do it but not explain it
13:22:08 <hyperisco> Home, End, Pg Up, Pg Down, and any of those + shift is all the extra editing power I desire
13:22:19 <hyperisco> but I am a bit of a text editing simpleton
13:22:26 <metahumor> hyperisco: also Ctrl-arrowkeys
13:22:43 <hyperisco> metahumor, I have never used that before
13:22:51 <hyperisco> shift+arrowkeys yes, for selections
13:23:10 <EvanR> real programmers paint the code on the screen with the mouse, instead of colors you pick letters from the palette
13:23:19 <hyperisco> metahumor, in my IRC client it jumps to word boundaries
13:23:19 <metahumor> ctrl-arrow for moving words or paragraphs
13:23:29 <hyperisco> neato… will try and learn that
13:23:44 <metahumor> shift-ctrl-arrow to select words or paragraphs, similarly
13:23:52 <hyperisco> EvanR, you mean programming with UnicodeSyntax? :P
13:23:58 <EvanR> ^
13:24:04 <L0g4nAd4ms> what is the difference between `div` and `quot` for integer division  ? Hoogle says the latter is truncated towards 0 and the former towards "negative infinity" ?
13:24:17 <metahumor> that is the difference
13:24:36 <hyperisco> I think insert and delete are a waste of keys though
13:25:01 <[exa]> L0g4nAd4ms: try applying that to negative numbers
13:25:07 <L0g4nAd4ms> Yeah, well i am not english native and dont know what that means
13:25:21 <EvanR> > [f x y | f <- [div,quot], x <- [13,-13], y <- [4,-4]]
13:25:26 <lambdabot>  [3,-4,-4,3,3,-3,-3,3]
13:25:27 <glguy> L0g4nAd4ms: If you don't know what a word means it would help us if you specified that word
13:25:41 <metahumor> L0g4nAd4ms: specifically, try dividing or `quot`ing with a negative number in the "denominator"
13:26:24 <L0g4nAd4ms> okay i get it now
13:26:29 <metahumor> EvanR: unfortunately, its not obvious which order [f],[x],[y] get expanded in that example
13:26:36 <EvanR> yeah, useless
13:26:59 <EvanR> you could tag bits with what math expr is being computed
13:27:20 <EvanR> and do divMod quotRem for the full story
13:27:35 <metahumor> the EvanR example has the first 4 as `div` and last 4 as `quot`
13:27:40 <[exa]> metahumor: why not remap insert to something useful?
13:27:57 <metahumor> i have no issues with insert, that's hyperisco
13:28:07 <[exa]> oh sorry I can't lines.
13:28:08 <metahumor> insert can be useful too...
13:28:18 <metahumor> or in vimspeak, "R"
13:28:51 <[exa]> R is closer. I've had insert remapped to something like "insert long compose key"
13:29:03 <[exa]> hyperisco: ^
13:29:20 <[exa]> basically for writing long keywords quicker
13:29:53 <hyperisco> long compose being twice pressed compose key?
13:30:13 <phz_> hey, quickie: is there a fundamental difference between an open type family and a typeclass with only one associated type?
13:30:44 <phz_> type family Foo :: * -> *
13:30:44 <phz_> vs.
13:31:12 <phz_> class Foo a where type F a :: *
13:31:17 <[exa]> hyperisco: I was an admin that time, for example [insert]-L typed /var/log automatically
13:31:54 <hyperisco> lol I see
13:31:56 <[exa]> (not related to compose :D)
13:32:14 <hyperisco> phz_, you can't close type classes, so that is the difference
13:32:28 <Athas> How do I evaluate the components of a tuple in parallel using Control.Parallel.Strategies?  And what if only some components of the tuple are instances of NFData?
13:32:29 <infandum> I have a type "T a b" and I want to give it an instance of "ToJSON". Why does instance (ToJSON a, ToJSON b) => ToJSON (T a b) not work?
13:33:13 <glguy> infandum: is this a quiz or do you have an error message?
13:33:19 <[exa]> infandum: do you have a minimal failing example?
13:33:51 <phz_> hyperisco: I said open type families
13:34:12 <phz_> if there’s no difference… why introducing them?
13:34:15 <phz_> for convenience?
13:34:29 <infandum> "Illegal instance declaration for ToJSON (T a b), (All instance types must be of the form (T t1 .. tn)"
13:34:39 <hyperisco> phz_, sorry, somehow I read "closed". No, there is no difference, other than the type class version also defines a type class ;)
13:34:40 <phz_> infandum: FlexibleInstances
13:34:58 <phz_> hyperisco: yeah, I see
13:35:01 <glguy> infandum: better, don't make instances of type synonyms
13:35:11 <phz_> oh it’s a type synonym
13:35:18 <phz_> yeah don’t do that
13:35:21 <phz_> GHC won’t let you anyway
13:35:52 <EvanR> TypeSynonymInstances
13:35:58 <infandum> It's not a synonym, T here is a data
13:36:01 <EvanR> not nec a good idea but GHC does let you do it
13:37:00 <consus> Guys
13:37:01 <consus> Guys
13:37:02 <consus> sigINT    :: CInt
13:37:03 <consus> sigINT = CONST_SIGINT
13:37:09 <[exa]> infandum: what kind is T?!
13:37:12 <consus> If I have sigTERM that has virtually the same definition
13:37:19 <consus> But different constant
13:37:48 <glguy> consus: you're going to lose your enter key privileges
13:37:51 <consus> doing case signal of sigINT -> ... sigTERM -> ... will result in redundant pattern matching, right?
13:38:08 <[exa]> infandum: oh nevermind, that's not the problem probably
13:38:16 <infandum> data T a b = T { items :: Vector a, mat :: b, mod :: Int }
13:38:17 <geekosaur> it's a binding, not a constructor, so yes. use a guard
13:38:32 <geekosaur> the definition is coming from a C #define
13:38:57 <glguy> infandum: paste your failing code and error to the paste bin
13:39:00 <geekosaur> (and ultimately it's a number)
13:39:05 <consus> Yep
13:39:13 <consus> 2 -> ... 15 -> ... works :)
13:39:54 <glguy> Pattern synonyms are a nice way to handle magic numbers like this
13:40:46 <infandum> I need to write a small case then
14:00:44 <wedify> there's gotta be some way lazy io works. what if we had unlimited file handles?
14:04:58 <[exa]> wedify: sounds like unlimited memory?
14:08:10 <wedify> [exa] we could crash when we run out of memory. that's what happens when we overfill the stack
14:27:32 <glittershark> hey all: I'm sure this is pretty common as a question, but how do I get a value in a nested HashMap using lenses?
14:27:46 <glittershark> I can do it just fine when my value is a Monoid, but not when it isn't
14:28:03 <glittershark> >  let m = ([("foo", [("bar", 2)])]) :: HashMap String (HashMap String Integer) in m ^. at "foo" . _Just . at "bar"
14:28:06 <lambdabot>  error:
14:28:06 <lambdabot>      Not in scope: type constructor or class ‘HashMap’error:
14:28:06 <lambdabot>      Not in scope: type constructor or class ‘HashMap’
14:29:21 <glittershark>     • No instance for (Monoid Integer) arising from a use of ‘_Just’
14:30:14 <ertes> glittershark: _Just collapses to a traversal when used as a getter
14:30:32 <glguy> ^? ix "foo" . ix "bar"
14:30:38 <ertes> glittershark: lenses point to *exactly* one thing, not *up to* one thing
14:30:49 <glittershark> ah, ok
14:31:15 <glittershark> can I use the same (ix) traversal to set the key, even if the top-level key isn't present?
14:31:22 <glittershark> or do I have to do something else there?
14:32:08 <glguy> else
14:32:55 <glguy> at "foo" . non' _Empty . at "bar"
14:33:26 <ertes> glittershark: you should probably just use insert/insertWith
14:33:58 <glittershark> ah, yep, just found non
14:34:18 <glittershark> "how do I use lenses?" "dont."
14:34:19 <glittershark> lol
14:34:45 <glittershark> but yeah, I'm mostly just trying to poke at the edges of my understanding of the library right now
14:42:31 <hexagoxel> tnight
15:03:09 <SpinTensor> Hi, I'm trying to understand how to read from stdin into datatypes. I created the following program, which does not work https://pastebin.com/db1v37DY
15:04:00 <glguy> You'll have to be more specific
15:04:19 <glguy> incidentally you can replace this use of getLine and read with readLn, but that probably isn't your "doesn't work" issue
15:04:21 <SpinTensor> when i echo in "H 1 2 3" i get a Prelude.read: no parse
15:04:29 <nick_h> 09000000
15:04:36 <glguy> SpinTensor: You'll need to use record syntax
15:04:54 <SpinTensor> glguy: I don't understand.
15:04:57 <glguy> Atom { symb = "Whatever", x = 0 ...
15:05:12 <fishythefish> SpinTensor: construct an Atom in ghci and use `show` to see what format it's expecting
15:05:37 <hackage> ACTION gi-atk 2.0.15, gi-cairo 1.0.15, gi-girepository 1.0.15, gi-gio 2.0.15, gi-ggit 1.0.2, gi-gdkx11 3.0.2, gi-gdkpixbuf 2.0.15, gi-gdk 3.0.15, gi-gsttag 1.0.15, gi-gstpbutils 1.0.15, gi-gstbase 1.0.16, gi-gstaudio 1.0.15, gi-gst 1.0.15, gi-gobject 2.0.16, gi-glib 2.0.16, gi-gtkosxapplication 2.0.15, gi-gtk 3.0.19, gi-gstvideo 1.0.15, gi-javascriptcore 4.0.15, gi-javascriptcore 3.0.15, gi-gtksource 3.0.16, gi-vte 2.91.17, gi-soup 2.4.15, gi-secret 0.
15:05:56 <glguy> mniip: Is that one yours?
15:05:56 <SpinTensor> okay, I know how to assign this in ghci by hand, but i don't get it to read from outside the program.
15:07:28 <fishythefish> SpinTensor: by default, `read` and `show` are inverses. What you type in for `read` to parse must be the same format that `show` would emit. In this case, "H 1 2 3" is not in that format
15:08:11 <glguy> Atom { symb = "H", x=1, y=2, z=3}
15:08:11 <SpinTensor> fishythefish: ok, i see.
15:08:12 <fishythefish> Atom {symb = "test", x = 1.0, y = 2.0, z = 3.0} -- SpinTensor: this would work as input
15:10:39 <SpinTensor> so i would need to split the line into words and assign this using the Atom { symb = ... syntax?
15:11:45 <fishythefish> no, `read` takes care of the parsing if you provide input in the format it's expecting
15:12:07 <SpinTensor> but the format is "H 1 2 3" can't change that one
15:12:33 <fishythefish> in that case, do what you said
15:12:42 <SpinTensor> ok i try. thanks
15:12:50 <fishythefish> split the line up, `read` the individual members, and then construct an Atom from them
15:13:36 <fishythefish> also, you don't have to construct an Atom with record syntax; `Atom "H" 1 2 3` would be valid too
15:15:08 <glguy> It just won't be valid input to read
15:15:20 <fishythefish> right
15:18:03 <SpinTensor> fishithefish: thanks, that works like a charm
15:26:46 <SpinTensor> when i want to access the member of a type, why do i have to write "member type". I think type.member is more logical
15:27:05 <cheater> tdammers: thank you :)
15:28:59 <Axman6> because these are functions, not methods
15:29:19 <SpinTensor> Axman6: thanks
15:29:22 <Axman6> accessor functions aren't special, and having them be exactly the same as any other function makes them much more useful
15:29:30 <Axman6> @src Identity
15:29:30 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
15:29:41 <Axman6> :t runIdentity
15:29:43 <lambdabot> Identity a -> a
15:30:57 <SpinTensor> so its like defining a function member (type _ _ member _ ... _) = member
15:32:22 <Gurkenglas> Optimization never makes a value more defined, right?
15:33:39 <Axman6> SpinTensor: right, that's exactly what it is
15:34:11 <Axman6> it also gives you a name to be able to set that member (but annoyingly record accessor names aren't first class, so you can't pass them around, only the getter functions)
15:34:38 <Axman6> so you can't write something like: set field a x = x { field = a }
15:34:46 <jle`> SpinTensor: why do you think 'type.member' is more logical?
15:35:10 <SpinTensor> i guess i am used to it from C
15:35:22 <jle`> ah, so you mean familiar
15:35:32 <SpinTensor> from left to right you access the elements
15:36:05 <jle`> so by 'more logical', you mean 'more like C' :)
15:36:19 <SpinTensor> yeah. i guess so.
15:37:25 <SpinTensor> i'm fairly new to haskell but quite used to languages like C and fortran. So i'm used to think in momory states instead of functions like in haskell.
15:38:35 <jle`> mhm, makes sense
15:38:52 <jle`> was just a challenge to be more critical about what you think is logical vs. what is just an arbitrary habit
15:39:03 <EvanR> you can think of haskell evaluation in terms of expression graph states
15:39:09 <EvanR> if you want to get low level
15:39:23 <EvanR> but memory states... thats too low
15:39:33 <EvanR> unless its STM memory!
15:41:41 <SpinTensor> maybe another time. I have enough problems to translate a problem into haskell. if i read the solution it is logical most of the time, but its really hard to find the solution myself. Need to work on that.
15:44:14 <SpinTensor> bye bye. time for bed
15:44:32 <shapr> aw, was gonna ask what got SpinTensor looking at Haskell
15:45:07 * hackage eq 4.1 - Leibnizian equality  https://hackage.haskell.org/package/eq-4.1 (ryanglscott)
15:45:45 <EvanR> divide the problem into manageable pieces
15:55:05 <mniip> glguy, looks like it didn't fit into 512 bytes
15:55:10 <mniip> so the lst \x01 was missing
16:12:37 * hackage rtcm 0.2.13 - RTCM Library.  https://hackage.haskell.org/package/rtcm-0.2.13 (markfine)
16:14:01 <kakashiAL> a stupid question, but why would it be bad to allow multiple types in a list?
16:14:58 <mniip> what would the list's type be
16:16:22 <mniip> kakashiAL, what would be the type of ['a', True]
16:17:06 <kakashiAL> I dont know, but lets say we introduce a special notation for that
16:17:16 <mniip> that's already a bad thing
16:17:20 <mniip> but continue
16:17:22 <puffnfresh> HList
16:17:35 <mniip> puffnfresh, hold your horses
16:17:42 <puffnfresh> http://hackage.haskell.org/package/HList
16:18:20 <mniip> kakashiAL, what would said notation behave like
16:18:31 <mniip> in respect to typechecking and type inference
16:18:59 <kakashiAL> mniip: I dont know, so maybe you can give me a simple example to show why its bad
16:19:18 <mniip> give me an example of what you have in mind and I will
16:20:01 <mniip> it is not bad - it is invalid as per the current rules. As I understand you ask why not change the rules to allow it
16:20:13 <mniip> You have to be very specific about what you want to change
16:20:57 <mniip> Haskell's typesystem is describable as a rather short list of formal logic statements, and it's not going to be any other way any time soon
16:22:13 <puffnfresh> data X = forall a. X a; xs = [X 1, X True, X "three"]
16:22:22 <jle`> kakashiAL: one problem is like, what would the type of 'head' be ?
16:22:38 <jle`> head :: ???? -> ????
16:22:40 <mniip> there's many potential problems
16:22:44 <jle`> how would you even use this list?
16:23:06 <mniip> I wanted him to try to come up with a concrete idea so I could prove why it's broken
16:23:54 <kakashiAL> jle`: hmm...so the typesystem limits us? I mean in javascript an array can contain all kind of types, and never had a problem/limitation with that
16:23:59 <mniip> even HList will break on sight of polymorhic recursion
16:24:10 <jle`> kakashiAL: that's why javascript's array's indexing/head has no type
16:24:24 <puffnfresh> head :: (h :' t) -> h
16:24:32 <jle`> kakashiAL: do you realize how much this limits type safety in other languages?
16:24:48 <mniip> kakashiAL, static typing is the best bug prevention technique ever invented
16:24:52 <mniip> and I mean numerically best
16:25:11 <jle`> kakashiAL: libs in other language have to say in their docs "a list of ints", but there's no way to say this in their types
16:25:16 <puffnfresh> kakashiAL: it is possible, sometimes useful, but rarely
16:25:22 <jle`> untyped lists is a huuuge limiting thing for type safety/bug prevention
16:26:41 <jle`> kakashiAL: are you really saying that you've never had a problem/limitation with the fact that javascript has no types? ;)
16:27:42 <jle`> (the fact that jatascript's arrays are untyped is extremely limiting)
16:29:20 <mniip> here's an example of a limitation
16:29:39 <mniip> dynamic typing is kind-of equivalent to runtime bottom up (in the AST) type inference
16:30:13 <mniip> but without any sort of top-down type inference, overloading of functions by context is impossible
16:30:18 <mniip> and haskell does it all the time
16:30:19 <koz_> :t when
16:30:21 <lambdabot> Applicative f => Bool -> f () -> f ()
16:30:54 <mniip> cf 'pure', 'return', 'maxBound', 'fromInteger'
16:30:55 <koz_> :t comparing
16:30:57 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
17:09:17 <hux> Im back dudes
17:09:27 <hux> Again with my questions about lenses :P
17:09:46 <hux>  born :: (HasStdGen s, MonadState s m) => m a
17:10:03 <hux> Im doing something like that and have searched on net about state monad with lens
17:10:19 <hux> is there any best practive on constraining like this ?
17:19:10 <Gurkenglas> hux, try MonadRandom
17:20:19 <hux> Gurkenglas: okay thx :)
17:22:37 <acidjnk> hello
17:30:51 <kakashiAL> jle`, mniip, puffnfresh: okay, typed lists to prevents errors
17:31:04 <mniip> type systems to prevent errors
17:31:30 <mniip> no untyped lists because there's type-theoretical issues (that are very practical though)
17:31:43 <jle`> hux: looks fine to me
17:32:18 <jle`> using classy lenses with mtl is something i've seen done
17:32:38 <jle`> i saw a blog post about it a couple years ago too
17:32:42 <mniip> kakashiAL, if you believe you know how a typechecker would attribute types to lists, ask yourself a few questions,
17:33:22 <mniip> what is the type of ['a', True], what is the type of [True, 'a', True], ['a'], what is the type of []
17:33:28 <mniip> (\x y -> [x, y])
17:33:37 <mniip> (x y -> x:y)
17:33:59 <mniip> what's the type of [(1::Integer) ..]
17:34:12 <mniip> what about  let l = (1::Integer) : l in l
17:34:40 <mniip> or maybe
17:34:55 <hux> jle': ok no worry about that so
17:35:15 <kakashiAL> myCrazyList :: [Char, Bool]  <---each element represents the type of the element, but in that case you need polymorphic/overweight functions to be able to map over the list
17:35:17 <hux> jle': i feel like its better because you just ask for constraint instead of asking for types
17:35:26 <mniip> let l x = x : l (Just x) in l Nothing
17:35:31 <puffnfresh> kakashiAL: that's exactly a HList
17:35:35 <jle`> hux: yeah, it's programming towards some abstract interface
17:35:43 <mniip> kakashiAL, what about type of [True, 'a', True]
17:35:44 <puffnfresh> it exists already, HList package
17:35:49 <mniip> would that be [Bool, Char, Bool]
17:36:31 <hux> another question, is there any easier way (maybe this question is stupid but still) to do: Type <$> f a <*> pure b <*> pure c
17:36:49 <mniip> (\a -> Type a b c) <$> f a
17:37:10 <hux> mniip: fantastic thanks ^^
17:37:24 <jle`> hux: you can use do notation if you want
17:37:40 <jle`> do x <- f a; pure (Type x b c)
17:37:55 <hux> jle`: oh yes, was just for learning purposes :)
17:38:02 <mniip> jle`, only if ApplicativeDo
17:38:13 <mniip> which isn't really the best thing ever
17:38:26 <jle`> i think ApplicativeDo was made for situations like this
17:39:04 <mniip> ApplicativeDo neither has an easily describable processing algorithm, nor has an easily describable general result
17:39:14 <mniip> it's hard to predict what it does for arbitrary expressions
17:39:38 <hux> what do you mean by hard mniip ?
17:39:44 <jle`> indeed applicative-do-ization is a really weird thing
17:39:49 <jle`> but for this specific situation it's nice
17:40:05 <mniip> hux, you need to know the nontrivial algorithm of how exactly it does things
17:40:09 <puffnfresh> yeah I agree mniip
17:40:09 <puffnfresh> can even have different performance
17:40:30 <jle`> but, if we're using <$>/<*>/pure for a Monad, the point is mootish
17:40:37 <mniip> puffnfresh, err?
17:40:40 <hux> mniip: ok I see, inlining applicative is better then ?
17:40:40 <jle`> since it can just be normal monadie do
17:40:52 <hux> piffnfresh: there is real performance costs ?
17:41:11 <mniip> hux, could be if <*> is sufficiently different from ap
17:41:24 <mniip> in the sense that <*> is more efficient than binding
17:41:52 <hux> mniip: maybe not for my trivial case but good to be advised :)
17:44:19 <puffnfresh> pretty sure Kmett showed that the operator association is a bit different so you can construct an applicative/monad which performs best under one association
17:44:44 <puffnfresh> so then do without -XApplicativeDo makes it perform well, then adding it makes it perform not so well
17:44:58 <puffnfresh> sorry, trying to find a reference
17:58:26 <d-fish> I can't find any upcoming meetings for boston-haskell meetup group <https://www.meetup.com/Boston-Haskell>. Looking at the history, there might be one around the 15th-20th this month?
18:22:15 <NemesisD> is there a category theory or haskell concept that represents "reducing" a sequence of values? i've got a sequence of moves along a compass rose and i'd like to fold over it and reduce it to the "net" movements
18:23:09 <argent0> catamorphism
18:24:01 <argent0> part of recurssion schemes
18:24:12 <mniip> not sure that's a catamorphism
18:24:57 <argent0> :t cata
18:24:59 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
18:25:13 <mniip> it is a metamorphism,
18:26:00 <mniip> aactually neither
18:26:01 <argent0> Idk, what a metamorphism is
18:26:05 <mniip> this isn't a functorial problem
18:26:31 <mniip> NemesisD, semigroup equivalence
18:26:35 <mniip> from formal systems theory
18:27:13 <mniip> word equivalence in free semigroups under relations
18:27:59 <NemesisD> interesting. sounds like i have a lot to google
18:28:18 <mniip> it is undecidable in general
18:28:27 <mniip> but your free semigroup which is actually a group is decent enough
18:28:32 <mniip> moreover it's a free group
18:28:48 <mniip> no
18:28:56 <mniip> not a free group, it commutes
18:29:19 <mniip> free abelian...
18:29:23 <mniip> that's just a Z-module
18:29:40 <mniip> well indeed
18:29:54 <mniip> movements along an n-dimensional compass reduce to n coordinates of the target point :P
18:36:51 <ReinH> NemesisD: that sounds like a fold given an appropriate Monoid instance for the moves
18:37:21 <ReinH> The instance is probably just vector addition.
18:37:35 <NemesisD> ReinH: i haven't really gotten that far in the problem but i somewhat suspect that order may not matter
18:39:00 <mniip> did any of that get through :(
18:39:39 <NemesisD> ReinH: yeah its like vectors where the magnitude is immaterial/always 1
18:39:42 <ReinH> mniip: you said a lot of things
18:39:52 <ReinH> > foldl (\(x,y) (x',y') -> (x + x', y + y')) (0,0) [(1,0), (0,1), (-1, 0)]
18:39:55 <lambdabot>  (0,1)
18:40:01 <mniip> 1515637770 [05:29:30] <mniip> movements along an n-dimensional compass reduce to n coordinates of the target point :P
18:40:37 <ReinH> Checking to see if V2 from linear has the Monoid instance you want.
18:40:48 <NemesisD> ReinH: i started down the road of a monoidal fold but i got to thinking (and no spoilers, this line of thinking may be incorrect but i'd like to discover it for myself) that order may not matter and that what i'm trying to do is reduce the input repeatedly until it can be reduced no further
18:40:57 <ReinH> It doesn't.
18:41:19 <ReinH> I don't understand what "reduce the input repeatedly" means in this context.
18:41:44 <ReinH> Do you want to find the shortest equivalent sequence of moves to a given sequence?
18:42:01 <ReinH> So say that you have [N, S, E], you want [E]?
18:42:04 <NemesisD> given [Direction], the first reduction may be to have opposing directions cancel eachother out
18:42:17 <NemesisD> ReinH: yeah pretty much
18:42:19 <ReinH> Translate into vector space, fold, translate back into direction space
18:43:02 <ReinH> [N, S, E] => [(0,1), (0,-1), (1,0)] => (1,0) => [E]
18:43:25 <mniip> NemesisD, is [N, E] same as [E, N]
18:43:29 <NemesisD> i guess i haven't done much vector computing, this could be fun. this is complicated a bit by it not actually being NESW, the problem is a hex grid, so N, NW, SE, S, SW, NE, no E or W
18:43:47 <NemesisD> mniip: i think so, yes
18:43:47 <ReinH> NemesisD: Or treat it as a group theory problem.
18:44:10 <mniip> then it's abelian
18:44:14 <ReinH> You have an abelian group, which probably even has a name already
18:44:25 <mniip> it's a free abelian group
18:44:35 <ReinH> Yes
18:44:37 <mniip> on a hex grid it's a free abelian group over equations
18:45:00 <mniip> namely the N+SW+SE=0
18:45:12 <ReinH> Seems good.
18:45:25 <NemesisD> cool, i didn't even know that term so that's what i was seeking :)
18:46:11 <mniip> ugh, looks like not the whole of my wall of text went through
18:46:28 <ReinH> I assume that this problem already has a name and a solution in group theory that I can't remember.
18:46:43 <mniip> NemesisD, http://lpaste.net/raw/9187942014111449088
18:46:51 <mniip> ReinH, for an arbitrary groupoid it's undecidable
18:47:09 <NemesisD> mniip: i did get that i just didn't understand any of that
18:47:11 <mniip> er
18:47:17 <mniip> ReinH, for an arbitrary semigroup it's undecidable
18:47:49 <mniip> formal arithmetic is reducible to semigroup equivalence
18:51:08 <mniip> dang, feels nice to, for once, use the material that has been actually taught to you by your university
18:51:29 <mniip> as opposed to my regular extracurricular interests
18:53:15 <ReinH> A quick and dirty solution would be to create a Map Direction Int storing, say, NW, N, NE, folding over your list and adding 1 for those and subtracting 1 for their inverse, then turning the result into a sequence of directions.
18:53:35 <ReinH> You don't even need a map, just an (Int, Int, Int).
18:55:28 <NemesisD> ReinH: haha that's pretty close to what i have  so far. that got me inverses. now i just need to combine directions, i.e. N + SE = NE
18:55:41 <ReinH> then fold over applying case d of { NW -> _1 +~ 1; N -> _2 +~ 1; NE => +~ 1; SE -> _1 -~ 1; S -> _2 -~ 1; SW -> _3 -~ 1 }
18:56:04 <ReinH> How is N + SE = NE?
18:56:27 <ReinH> Ah right.
18:56:59 <ReinH> That complicates things.
18:57:06 <NemesisD> groups seem interesting though, monoid + inverse seems to apply here
18:57:30 <ReinH> The abelian group is equivalent to unit movements in N^3
18:57:44 <ReinH> The hex grid add extra equalities to that group
18:58:04 <ReinH> like N + SE = NE, which isn't true for the free group.
18:58:22 <ReinH> *adds
19:00:11 <ReinH> The problem is that the vectors you get from these moves in 2d space are not linearly independent
19:00:35 <ReinH> N + SE = NE is linear dependence
19:01:43 <ReinH> mniip: any ideas, smart university-education-having person?
19:02:19 <mniip> that's not a vector space
19:02:28 <ReinH> What isn't?
19:02:29 <mniip> only the free abelian groups are Z-modules
19:02:42 <mniip> on a hex grid it's divided by an equivalence relation
19:03:27 <mniip> hmm
19:04:22 <mniip> ReinH, I guess this equation is "nice" in that it lets us express NE as N+SE
19:04:39 <mniip> and so our group becomes isomorphic with a free abelian group generated by {N, SE}
19:05:08 <mniip> (A non-nice equation could be B+B+A+A=0)
19:05:32 <ReinH> I agree that it is nice FSVO nice.
19:42:02 <codeshot> Do all the Applicative laws follow from the Apply and Pointed laws?
19:42:17 <codeshot> If so does anyone have a reference to a proof?
19:48:29 <ReinH> What Pointed laws?
19:51:21 <ReinH> Anyway, the answer is no.
19:52:53 <redrapscallion> say i have a shell script that prints out "Hello World!", and i wanted Haskell to call that script, and directly pipe the output into Haskell as a String. is that possible?
19:53:09 <mniip> yes
19:53:17 <ReinH> Yep.
19:53:19 <redrapscallion> without creating a temp file?
19:53:22 <mniip> gimme a minute
19:53:23 <ReinH> Yep.
19:53:57 <ReinH> @hackage process
19:53:57 <lambdabot> http://hackage.haskell.org/package/process
19:54:24 <ReinH> @hackage turtle
19:54:24 <lambdabot> http://hackage.haskell.org/package/turtle
19:54:39 <mniip> % :t System.Process.readProcess
19:54:39 <yahb> mniip: FilePath -> [String] -> String -> IO String
19:54:46 <ReinH> @hackage shelly
19:54:46 <lambdabot> http://hackage.haskell.org/package/shelly
19:55:08 <ReinH> Take your pick. System.Process is low-level, the other two are abstractions.
19:55:35 <mniip> % System.Process.readProcess "echo" ["hello"] ""
19:55:35 <yahb> mniip: "hello\n"
19:56:03 <ReinH> You have a bot now? Neat.
19:56:10 <mniip> % System.Process.readProcess "cat" [] "I am a cat"
19:56:10 <yahb> mniip: "I am a cat"
19:56:47 <ReinH> If you actually want streaming, there’s conduit or pipes stuff too
19:57:51 <redrapscallion> i don't need streaming, so i've already got what i need, i think
19:59:06 <mniip> ReinH, well, I have many bots
19:59:15 <mniip> not many of them interpret haskell however
20:01:19 <ReinH> I remember being unhappy with shelly when I used it in anger some years ago, which is ironic given that its author was a coworker at the time.
20:01:45 <ReinH> I ended up being happy with the System.Process stuff.
20:30:17 <codeshot> ReinH pointed law: fmap fn f = pure (fn f)
20:30:33 <iqubic> How close is dependent haskell to being a real thing?
20:31:17 <glguy> codeshot: That typechecks?
20:31:38 <iqubic> I don't think it would.
20:31:44 <codeshot> laws don't typecheck in haskell
20:32:01 <codeshot> their documentation comments
20:32:06 <codeshot> *they're
20:32:28 <ReinH> codeshot: I think you mean fmap f (pure x) = pure (f x)
20:32:32 <codeshot> yep
20:32:35 <codeshot> ta for the fix
20:32:43 <ReinH> They still need to be well formed.
20:33:03 <glguy> codeshot: and yes, the expressions used in "laws" have a meaningful relationship to types
20:33:08 <glguy> it's not important that they are written in comments
20:34:35 <ReinH> That law is a free theorem, and insufficient for proving the Applicative laws because the applicative laws cover the behavior of pure and <*> together.
20:35:15 <ReinH> Which neither Apply nor Pointed alone can do.
20:35:29 <iqubic> What are Apply and Pointed?
20:35:48 <ReinH> Apply is just <*> and Pointed is just pure.
20:36:17 <ReinH> That is, if you take an applicative and forget about pure, you get an Apply.
20:38:59 <iqubic> What is the point of Pointed?
20:39:07 <ReinH> There isn’t much point.
20:39:22 <codeshot> That's why I was wondering if the laws of Apply and Pointed together would imply the laws of Applicative
20:39:34 <jle`> i don't think so
20:39:40 <jle`> since there are no actual Pointed laws
20:39:51 <jle`> so the laws of Apply and Pointed together is just "the laws of Apply"
20:39:54 <codeshot> jle`: fmap f (pure x) = pure (f x)
20:39:58 <jle`> that's a free theorem
20:40:04 <jle`> so it doesn't add anything that the types of Apply don't
20:40:15 <codeshot> Oh I see
20:40:20 <codeshot> thanks, nice answer
20:40:40 <jle`> it was ReinH's answer :o
20:40:50 <ReinH> :)
20:41:08 <codeshot> so I see, missed it
20:41:17 <ReinH> Naturality strikes again.
20:41:50 <ReinH> See also this edwardk rant https://www.reddit.com/r/haskell/comments/1lokkj/lens_based_classy_prelude/cc1cm92
20:42:34 <`Guest00000> data X a where A :: X Int; B :: X Int; C :: X Int; D :: X Int; E :: X Int; ... Y :: X Int; Z :: X Char; -- is there syntax to avoid repetition of ":: X Int" and just line up A..Y?
20:43:05 <ReinH> A, B, C :: Int
20:43:12 <ReinH> Wait does that work in GADTs?
20:43:18 <MarcelineVQ> yes
20:43:22 <ReinH> Noice
20:43:30 <ReinH> I’ve somehow never tried.
20:44:14 <ReinH> Er, X Int
20:44:44 <mniip> 1515645574 [07:39:34] <jle`> that's a free theorem
20:44:45 <Hafydd> It says so in the GHC manual.
20:44:46 <mniip> are you sure
20:45:23 <ReinH> mniip: I’m sure, a) because Kmett says so and b) because parametricity
20:45:24 <jle`> maybe
20:45:42 <mniip> I'd like to see a rigorous statement
20:45:51 <`Guest00000> thanks ReinH
20:46:32 <iqubic> What is the point of Pointed? Why have a thing that's only pure?
20:46:36 <ReinH> Wasn’t there a free theorem generator online somewhere?
20:46:46 <ReinH> iqubic: again, there isn’t much point.
20:46:59 <ReinH> You can read the thing I linked for more discussion
20:47:20 <iqubic> Yeah. Apply seems to make mores sense. But only a tiny bit more.
20:47:38 <ReinH> It’s a way to factor Applicative and Monad, so Applicative = Apply + Pointed and Monad = Bind + Pointed
20:47:51 <iqubic> I see.
20:48:04 <ReinH> (With the necessary extra laws for each)
20:48:07 <Hafydd> Surprisingly, Pointed is Pointed.
20:48:12 <iqubic> I guess that Bind is either >>= or Join.
20:48:21 <wz1000> Is there any way to get the total heap size of a large, complex datastructure with lots of small subparts?
20:48:42 <ReinH> Bind is >>= but you could use Join if that existed
20:49:05 <wz1000> With +RTS -hy I can only see the heap size of the components
20:49:17 <ReinH> You can get join from (>>=) and pure and vice versa.
20:49:31 <iqubic> ReinH: I get that.
20:49:58 <iqubic> Join x = x >>= id
20:50:10 <ReinH> yeah you don’t even need pure
20:50:36 <iqubic> What about >>= written in terms of Join?
20:51:07 <codeshot> What about the situation where there are several type classes that add different methods to pure which each have a law with pure but don't have a law with each other ?
20:51:26 <ReinH> iqubic: you need join and fmap. You should try it.
20:51:42 <iqubic> ReinH: I have no idea how that would work.
20:51:59 <iqubic> :t (>>=)
20:52:04 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:52:05 <iqubic> :t join
20:52:08 <lambdabot> Monad m => m (m a) -> m a
20:52:11 <iqubic> :t fmap
20:52:13 <ReinH> :t fmap pure pure
20:52:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:52:15 <lambdabot> (Applicative f2, Applicative f1) => a -> f1 (f2 a)
20:52:59 <ReinH> :t m k -> join (fmap k m)
20:53:01 <lambdabot> error: parse error on input ‘->’
20:53:11 <ReinH> Whoops
20:53:37 <ReinH>  :t \m k -> join (fmap k m)
20:53:53 <ReinH> Oh come on lol
20:54:08 <ReinH> :t \m k -> join (fmap k m)
20:54:09 <lambdabot> Monad m => m a1 -> (a1 -> m a2) -> m a2
20:54:38 <iqubic> Is there someone in this channel named "k"
20:55:13 * glguy wonders if there's any way to know
20:55:41 <iqubic> glugy, Looks like there is.
20:56:00 <iqubic> *glguy
20:56:08 <MarcelineVQ> gugly
20:56:19 <ReinH> glguy: it is a mystery
21:01:09 <ReinH> Also you are gugly now sorry.
21:02:02 <ReinH> It’s homotopy equivalent to your name, close enough.
21:02:59 <glguy> /r/thisismylifenow
21:03:13 <ReinH> Yes that exactly
21:03:24 <MarcelineVQ> my one useful contribution to the haskell community
21:07:01 <jle`> codeshot: what situation are you talking about
21:07:19 <k> yes
21:08:31 <ReinH> The Situation.
21:08:44 <ReinH> He’s from New Jersey.
21:09:49 <codeshot> I appreciate that it's fun to tease newbies but can you pick on someone else?
21:10:35 <MarcelineVQ> he was teasing jle`, who is asking so he can help :>
21:14:40 <ReinH> I’m not even talking to you.
21:17:02 <codeshot> I don't believe it
21:17:09 <ReinH> That’s not my problem.
21:17:27 <codeshot> Stop trolling me ReinH
21:17:43 <MP2E> stop bringing your persecution complex in here
21:17:50 <codeshot> I'm not
21:17:51 <ReinH> You made a baseless accusation and then called me a liar.
21:18:19 <ReinH> So why don’t you stop trolling me.
21:18:28 <codeshot> I'm not
21:18:34 <ReinH> I don’t believe you.
21:19:31 <ReinH> Anyway, if you want help with your situation you should answer jle`’s question.
21:19:41 <glguy> Come on guys, I'm trying to play Hexcells. Can everyone get along please?
21:19:44 <concatmap> I have a [Either a b] and I would like an Either [a] [b]. In other words to collect all the rights if there are no lefts or else collect all the lefts. What’s an idiomatic way to accomplish that.
21:20:03 <concatmap> I think traverse or sequence are not quite right.
21:20:04 <MarcelineVQ> glguy: is that like hexic?
21:20:07 <glguy> :t partitionEither
21:20:09 <lambdabot> error:
21:20:10 <lambdabot>     • Variable not in scope: partitionEither
21:20:10 <lambdabot>     • Perhaps you meant one of these:
21:20:12 <glguy> :t partitionEithers
21:20:14 <lambdabot> [Either a b] -> ([a], [b])
21:20:31 <ReinH> You’d need to do a bit more work than that
21:20:45 <glguy> MarcelineVQ: Dunno, I'll look up Hexic
21:20:45 <concatmap> Is there a way to get an either back?
21:21:03 <kadoban> partitionEithers and then a case sounds like a decent way to go
21:21:06 <MarcelineVQ> glguy:  doesn't look like it
21:21:12 <ReinH> pattern match to determine whether there were lefts.
21:21:15 <glguy> MarcelineVQ: This is more like advanced minesweeper
21:21:28 <MarcelineVQ> glguy: are you working on a solver for it yet :>
21:21:42 <glguy> No, probably ought to, though
21:21:49 <concatmap> Ok then that’s easy enough. I’m using Either for a rudimentary multiphase validation system
21:22:37 <concatmap> So I want to collect valid results or invalid results, rather than just the first invalid result.
21:22:40 <ReinH> glguy: hexcells is great, super relaxing
21:22:44 <MarcelineVQ> concatmap: I've yet to use this still but might it fit the bill https://hackage.haskell.org/package/either-5/docs/Data-Either-Validation.html
21:23:05 <concatmap> Thanks mate, will take a look.
21:23:16 <concatmap> Any other recommendations?
21:23:42 <concatmap> I’m ok going back to the drawing board on this. But either is sufficiently powerful for my purposes.
21:24:48 <ReinH> concatmap: maybe you want the Validation Monad or w/e it’s called. It’s Either with a Monoid for collecting lefts.
21:24:56 <ReinH> Where was that hiding again?
21:25:00 <concatmap> What I’d like realistically is a way to collect results in any generic monoid.
21:25:07 <MarcelineVQ> where indeed
21:25:14 <concatmap> Oh that sounds right up my alley if you have a link.
21:28:02 <concatmap> Actually now that you say that maybe I saw something similar in PureScript
21:28:25 <concatmap> Still if you can think of where you saw it I’d be mighty appreciative. :)
21:30:57 <ReinH> @google Haskell validation monad
21:30:58 <lambdabot> https://hackage.haskell.org/package/validation
21:31:03 <ReinH> I thought of it.
21:31:13 <concatmap> Hey thanks,,
21:31:21 <concatmap> !!*
21:31:36 <ReinH> Well technically google thought of it for me.
21:31:39 <concatmap> I’ll hack on that. Cheers all.
21:36:05 <jle`> concatmap: sounds like lift and sequence
21:36:15 <jle`> concatmap, ReinH: Validation is in transformers now
21:36:59 <dibblego> you want a Semigroup, not a Monoid
21:42:56 <ReinH> Oh nice
21:43:19 <ReinH> dibblego: Yes, but Semigroup isn't in base.
21:43:40 <ReinH> Or is it now? I can't remember.
21:44:19 <dibblego> is now yeah
21:45:02 <ReinH> Noice.
21:45:46 <concatmap> So it turns out that library is not monadic.
21:45:54 <dibblego> it can't be
21:46:01 <concatmap> Which means I can’t use it. :(
21:46:04 <dibblego> there is no monad whch collects lefts
21:46:34 <concatmap> I have a vague intuition as to why that might be. Care to fill it in a bit?
21:47:06 <ReinH> Ah that's right.
21:47:10 <concatmap> (I think to solve my problem I will just partition eithers as originally suggested)
21:47:29 <concatmap> I was learning that way as it is.
21:47:40 <dibblego> it's why bindValidation exists
21:47:53 <dibblego> it does not collect lefts, since it cannot
21:48:00 <concatmap> Leaning rather.
21:48:47 <concatmap> Yea I don’t see how I could implement such a thing. But I didn’t have the certainty to say it couldn’t be done.
21:49:33 <concatmap> Unfortunately I think I need more power than an applicative has to offer.
21:49:37 <ReinH> Oh right this is dibblego's thing too
21:49:46 <concatmap> I need to sequence the validation steps. Any of which could fail.
21:49:47 <dibblego> for bind, if you have a left, then you cannot use that to get the next value, thereby, never having two lefts with which to (<>)
21:50:02 <dibblego> sequence works on Applicative
21:50:11 <dibblego> @type sequenceA
21:50:13 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
21:50:16 <dibblego> go nuts
21:50:34 <concatmap> Sorry what I mean is I need to apply validation steps in order. Building on the result of the previous step
21:50:49 <ReinH> How can you build on the result of a failed step?
21:50:54 <dibblego> then you will not collect lefts, since what does it mean for those two things to co-exist?
21:51:11 <concatmap> I have many things being validated concurrently. And I want to collect all those results.
21:51:25 <ReinH> Then how do things depend on previous results?
21:51:36 <concatmap> Um let me backup
21:51:51 <dibblego> you can fail at the first left, or you can collect possible lefts at the end, but you cannot do both
21:51:51 <concatmap> map validate items
21:51:55 <sprigs> Hi, could someone please tell me how I can uninstall my Haskell platform 8.2.2 on my Mac? I would like to install Slack instead
21:51:56 <concatmap> Validate us
21:52:06 <concatmap> Validate is a multi step process
21:52:24 <concatmap>  It I am doing many independent validations.
21:52:29 <ReinH> Do you need bind?
21:52:33 <concatmap> Grr. Typing on an iPad sucks.
21:52:43 <concatmap> I need bind in the validate function yes.
21:53:07 <sprigs> I have tried the various rm -rf lines suggested on the internet but prelude still opens
21:53:10 <concatmap> item >>= step1 >>= step2
21:53:24 <ReinH> Ok, then you can't collect lefts.
21:53:27 <nshepperd> sounds like you want a newtype wrapper
21:53:29 <dibblego> then you cannot collect lefts
21:53:32 <concatmap> At the end I have a list of validation results for all items.
21:53:37 <concatmap> A list of eithers.
21:53:49 <ReinH> Ok, I think I see
21:53:52 <ReinH> You have multiple items.
21:54:01 <ReinH> Each item goes through a workflow where there are multiple steps that can fail.
21:54:02 <concatmap> Right!
21:54:09 <concatmap> Yes exactly
21:54:10 <nshepperd> newtype Collect e a = Collect (Either e a)
21:54:23 <nshepperd> traverse (Collect . validate) items
21:54:26 <ReinH> :t traverse
21:54:29 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
21:54:37 <nshepperd> Collect will have a applicative but not monad instance
21:54:45 <ReinH> You want to traverse (step1 >=> step2) items
21:55:34 <ReinH> That will collect the failure result of the first failing step for each item
21:55:48 <concatmap> Ok I need to unpack that a bit. I don’t quite see how that will collect the lefts.
21:56:07 <concatmap> Give me a few minutes to process it. :)
21:56:20 <ReinH> You understand how sequence will collect the lefts?
21:56:40 <concatmap> I don’t full understand traverseable
21:56:51 <concatmap> I have to stare at the signature.
21:57:17 <concatmap> Unless you can provide a crash course.
21:57:45 <jle`> traverse is like fmap but with effects
21:57:45 <ReinH> > sequenceA [Left 1, Right 2]
21:57:49 <lambdabot>  Left 1
21:58:14 <ReinH> > sequenceA [Left [1], Left [2], Right 3]
21:58:17 <lambdabot>  Left [1]
21:58:25 <ReinH> With the accumulating version, you would get Left [1,2]
21:58:46 <ReinH> traverse f = sequence . fmap f
21:58:56 <jle`> @let import Control.Applicative.Lift
21:58:58 <lambdabot>  Defined.
21:59:08 <ReinH> you apply the workflow then you sequence, which collects the resulting lefts.
21:59:39 <jle`> > traverse eitherToErrors [Left [1], Left [2], Right 3]
21:59:41 <concatmap> Will it collects rights if there are no lefts.
21:59:42 <lambdabot>  error:
21:59:42 <lambdabot>      Variable not in scope:
21:59:42 <lambdabot>        eitherToErrors :: Either [Integer] Integer -> f b
21:59:52 <ReinH> > sequenceA [Right 1, Right 2]
21:59:56 <lambdabot>  Right [1,2]
22:00:34 <mniip> hmm
22:00:42 <mniip> EitherT e m a -> EitherT a m e
22:00:44 <concatmap> Why did your second example not accumulate?
22:00:50 <ReinH> Because I used Either
22:00:52 <mniip> wouldn't that be the most universal tool
22:00:55 <ReinH> And not the thing that accumulates
22:00:58 <ReinH> mniip: it isn't a Monad
22:01:26 <mniip> how so
22:01:28 <ReinH> Is the thing that accumulates in scope?
22:01:30 <jle`> > traverse eitherToErrors [Left [1], Left [2], Right 3]
22:01:33 <ReinH> mniip: ask dibblego :D
22:01:34 <lambdabot>  Other (Constant [1,2])
22:01:39 <concatmap> Oh I see. I need an applicative that will accumulate the semigroup left?
22:01:47 <dmwit> ReinH: What is the "it" in "it isn't a Monad"?
22:01:48 <jle`> > runErrors . traverse eitherToErrors $ [Left [1], Left [2], Right 3]
22:01:51 <lambdabot>  Left [1,2]
22:01:52 <concatmap> Either applicative just uses the first
22:01:52 <sprigs> Hi, could someone please tell me how I can uninstall my Haskell platform 8.2.2 on my Mac? I would like to install Slack instead. I have deleted the Haskell directory from my library but can still access GHCi
22:01:58 <concatmap> Is that right?
22:02:02 <ReinH> dmwit: The Either that accumulates lefts with a semigroup instance
22:02:16 <jle`> sprigs: i'm assuming you mean stack, but stack still works with haskell platform on your system
22:02:19 <ReinH> concatmap: right
22:02:31 <ReinH> or possibly left
22:02:33 <jle`> concatmap: not right, left
22:02:35 <jle`> aw man
22:02:38 <ReinH> haha
22:02:41 <ReinH> owned again
22:02:45 <mniip> :t swapEitherT
22:02:47 <lambdabot> error:
22:02:47 <lambdabot>     • Variable not in scope: swapEitherT
22:02:47 <lambdabot>     • Perhaps you meant one of these:
22:02:49 <concatmap> Ok this is perfect. Thanks so much.
22:02:57 <ReinH> concatmap: Noice.
22:02:58 <mniip> :t Control.Monad.Trans.Either.swapEitherT
22:03:01 <lambdabot> error:
22:03:01 <lambdabot>     Not in scope: ‘Control.Monad.Trans.Either.swapEitherT’
22:03:01 <lambdabot>     No module named ‘Control.Monad.Trans.Either’ is imported.
22:03:03 <ReinH> jle`: <3
22:03:08 <jle`> </3
22:03:11 <ReinH> :(
22:03:15 <concatmap> Thanks so much Rein and dibb!!!
22:03:31 <sprigs> jle`: Sorry, yes. I originally installed with the .pkg provided. You're saying there is no need for me to uninstall that, and I can directly install Stack?
22:03:39 <mniip> oh that's not even transformers
22:03:41 <jle`> sprigs: yes
22:03:42 <concatmap> I need to grok Traverseable.
22:03:42 <jle`> and also stack too
22:03:52 <jle`> concatmap: just look at fmap vs traverse
22:03:52 <nshepperd> oh, my collect is called Validation
22:03:53 <concatmap> Is there a good resource for that?
22:04:07 <jle`> fmap :: (a -> b) -> [a] -> [b]
22:04:13 <dmwit> ReinH: ExceptT gathers Lefts in its Alternative instance.
22:04:19 <jle`> traverse :: (a -> f b) -> [a] -> f [b]
22:04:39 <jle`> huh then i guess you can use asum
22:04:52 <ReinH> concatmap: the typeclassopedia still, maybe?
22:04:53 <dmwit> ReinH: I don't think it's sensible to want the Monad instance to gather Lefts. (In `Either e a -> (a -> Either e b) -> Either e b`, what `a` would you call the second argument with if the first argument is a `Left`?)
22:04:55 <ReinH> :t asum
22:04:57 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
22:05:27 <concatmap> Cheers all. I will reflect on this more closely.
22:05:31 <ReinH> dmwit: I mean, it can't gather lefts, right?
22:05:32 <jle`> but the Either instance that is in scope in lambdabot sucks for some reason
22:05:41 <ReinH> hysterical raisins
22:05:45 <dmwit> ReinH: What is "it" in "it can't gather lefts"?
22:05:59 <ReinH> the putative monad instance
22:06:20 <ReinH> bind, specifically, since if the thing on the left is a Left then the computation halts, there are no more Lefts to gather.
22:06:26 <dmwit> I don't even know what it would mean to "gather lefts". You can't call bind's continuation if you get a `Left`.
22:06:34 <ReinH> We are literally saying the same thing.
22:06:37 <dmwit> Yes.
22:06:42 <ReinH> Yes.
22:06:47 <ReinH> I am an echo bot now.
22:06:55 <nshepperd> https://hackage.haskell.org/package/either-5/docs/Data-Either-Validation.html here is the Either with an Applicative instance that gathers left values
22:07:04 <jle`> nshepperd: it's in 'transformers' now too
22:07:09 <ReinH> nshepperd: I heard it was in transformers now but I can't find it
22:07:16 <jle`> it's in Control.Applicative.Lift
22:07:20 <dmwit> ReinH: But I think it is interesting to differentiate between "you can't do that because it would violate the laws" and "you can't do that because there is no term you can write that would do that". =)
22:07:22 <jle`> it's hiding from u
22:07:25 <ReinH> Ah of course the obvious place for it to be
22:07:39 <jle`> it only reveals itself for the worthy
22:07:48 <dmwit> ReinH: (...and the language "that's not a Monad" suggests to me that you can do it, but it violates the laws.)
22:07:51 <ReinH> now I am the one who is owned
22:08:13 <ReinH> dmwit: I mean, it doesn't have a Monad instance.
22:08:13 <jle`>  > flip tables
22:08:34 * dmwit nods agreeably
22:08:35 <sprigs> Thank you, jle`. What if I just wanted to get rid of my previous install and start off fresh again,? I've tried "sudo uninstall-hs" but that doesn't work. Have deleted the "/Frameworks/GHC.framework" as well as the Haskell dir from the Library.
22:08:38 * jle` . o ( > swap tables ) ?
22:08:39 <mniip> :t Control.Monad.Trans.Except.mapExceptT (fmap (either Right Left))
22:08:41 <lambdabot> Functor n => ExceptT b n e' -> ExceptT e' n b
22:08:55 <ReinH> dmwit: I thought I was missing something, because I don't see how a monad instance would violate laws either.
22:09:32 <mniip> @let swapExceptT = Control.Monad.Trans.Except.mapExceptT (fmap (either Right Left))
22:09:34 <lambdabot>  .L.hs:175:5: error:
22:09:34 <lambdabot>      Not in scope: ‘Control.Monad.Trans.Except.mapExceptT’
22:09:34 <lambdabot>      Perhaps you meant one of these:
22:09:37 <mniip> oh right
22:09:38 <dmwit> ReinH: Oh, that's easy. If you give the same Monad instance that you would normally give, then it won't satisfy the "the Applicative instance and the Monad instance do the same thing" law.
22:09:41 <ReinH> dmwit: And the distinction between "it can't gather Lefts" and "there are no extra Lefts to gather" seems meaningful.
22:09:52 <ReinH> dmwit: Oh right, it's because ap isn't <*>
22:09:57 <nshepperd> so anyway clearly you use Either for the sequential part then convert to this Validation thing for the parallel gathering part
22:09:58 * dmwit nods
22:09:59 <ReinH> wah wah
22:10:15 <nshepperd> type Errors e = Lift (Constant e) O_O
22:10:35 <mniip> :t \m k -> swapExceptT (swapExceptT m >>= swapExceptT . k)
22:10:37 <lambdabot> Monad n => ExceptT a n b -> (a -> ExceptT e' n b) -> ExceptT e' n b
22:10:48 <jle`> nshepperd: reductionism at its finest
22:10:49 <ReinH> dmwit: Me, after understanding why there isn't a Monad instance: I am tired of Earth, these people. I'm tired of being caught in the tangle of their lives.
22:10:59 <nshepperd> actually I'm mostly surprised that it's not called Const any more?
22:11:11 <jle`> yeah transformers is holding onto its own Constant for some reason
22:11:15 <dmwit> nshepperd: You might also like ChronicleT.
22:11:36 <nshepperd> oh, separate Const
22:11:39 <nshepperd> that's weird
22:11:42 <MarcelineVQ> ReinH: As you reach for the cold, perspiring glass...
22:11:53 <dmwit> https://hackage.haskell.org/package/these-0.7.4/docs/Control-Monad-Chronicle.html#t:MonadChronicle
22:11:57 <jle`> yeah it's been there since before base, it's one of the weirdest historical things in haskell libs
22:11:58 <mniip> those names
22:12:18 <dmwit> mniip: The best one in that package is "malign", which is actually m - align.
22:12:44 <ReinH> wait what
22:13:34 <dmwit> In case that "wait what" was responding to me: https://hackage.haskell.org/package/these-0.7.4/docs/Data-Align.html#v:malign
22:13:46 <nshepperd> what I really need to do is play around with the new Accum and Selection monads, and also the new monad instance for Store
22:14:12 <mniip> that's a cool monad
22:14:35 <dmwit> Yeah. It's super handy for writing a compiler that wants to have fatal errors and non-fatal errors (or warnings).
22:14:37 <mniip> did I just unironically say tht
22:14:58 <ReinH> dmwit: Ah yes, align with a monoid, clever girl
22:15:42 <jle`> nshepperd: i already used Accum in advent of code, it's pretty nice
22:15:53 <jle`> i still have no idea how to use Select
22:16:47 <ReinH> jle`: from where?
22:16:49 <dmwit> I looked briefly at the paper on Select, and concur with your assessment.
22:16:56 <ReinH> Oh, we're still talking about Lift?
22:17:01 <jle`> ReinH: the transformers shipping with ghc 8.4
22:17:09 <jle`> has two new monads/transformers
22:17:17 <ReinH> Select paper link for me because I am le tired pls?
22:18:02 <jle`> @hackage transformers/docs/Control-Monad-Trans-Select.html
22:18:02 <lambdabot> http://hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-Select.html
22:18:21 <ReinH> ty
22:18:23 <dmwit> Was that actually easier than copy-pasting the full URL yourself?
22:18:32 <dmwit> I mean it was very clever, so gj on that.
22:18:38 <jle`> no because i looked at the url and typed it out by hand
22:18:46 <jle`> thank you
22:18:54 <dmwit> heh, yikes
22:19:10 <mniip> okay what
22:19:13 <ReinH> why would you even
22:19:18 <mniip> ((a -> r) -> a
22:19:22 <jle`> i upgraded to a preview build of WSL and my terminal emulator's pasting seems to be broken
22:19:30 <ReinH> oops
22:19:51 <ReinH> mniip: your unbalanced bracket is making my eye twitch
22:19:52 <ReinH> )
22:19:53 <ReinH> There.
22:20:29 <ReinH> jle`: I mean, I definitely didn't expect anyone to go to that much trouble :3
22:20:29 <dmwit> (()())(()()(())()((())())
22:20:47 <mniip> unbalanced
22:20:49 * ReinH *twitch*
22:20:52 <mniip> ))
22:20:56 <ReinH> thank you
22:21:02 <jle`> ReinH: i thought it would be humorous to put extra work into making you do more work than you asked
22:21:05 <noob33> I'm not sure on the appropriate ettiquette for asking questions here buuuuuut... I was attempting to understand PolyKinds and ran across an example I thought should work...but does not. I'm not sure if I'm using ghci wrong or if the example I found has a typo:https://pastebin.com/FeJ4CCYY
22:21:06 <mniip> did I close one too many
22:21:35 <mniip> noob33, did you enable PolyKinds at MkFoo's definition
22:21:37 <jle`> noob33: proper ettiquette is to just ask your question :)
22:21:45 <jle`> so you did well
22:22:08 <jle`> noob33: PolyKinds at ghci would be useless becuase Foo is already monokinded
22:22:15 <mniip> @djinn ((a -> r) -> a) -> (a -> ((b -> r) -> b)) -> (b -> r) -> b
22:22:15 <lambdabot> f a b c = b (a (\ d -> c (b d c))) c
22:22:20 <mniip> oh dear
22:22:26 <dmwit> see? no problem
22:22:34 <jle`> noob33: that'd be like trying to make a monomorphic function polymorphic after-the-fact
22:22:59 <noob33> Thank you! I think it was the article you posted this week jle that I got it from. Were you using ghci in the singletons part 2 post?
22:23:01 <ReinH> mniip: you did :(
22:23:29 <jle`> ah i suppose i didn't explain the extension very well/at all
22:23:48 <noob33> It's no problem! I just saw your use of ghci there and figured I could do the same
22:23:55 <jle`> it's supposed to be emulating a ghci session yes
22:23:59 <noob33> I appreciate your (and everyone else's ) taking the time to answer
22:24:21 <unyu> Is there any example of essential use of PolyKinds?
22:24:21 <jle`> what code are you looking at exactly?
22:24:28 <mniip> ooooh
22:24:30 <unyu> i.e., something that you can't express without it.
22:24:33 <mniip> I sense sense
22:24:48 <noob33> I was also looking at Diehl's site which seems to have useful examples of PolyKinds in action
22:26:11 <jle`> noob33: ah yeah i see the ghci session in Part 1 which is a little misleading
22:26:16 <noob33> jle it was singletons part 1 actually
22:26:19 <noob33> my mistake
22:26:34 <jle`> no problem :)  i edited the post, thanks for helping me catch this!
22:26:41 <unyu> I guess PolyKinds makes more sense when you use DataKinds.
22:27:00 <unyu> Because I can't see myself using arbitrarily higher-kinded type constructors. :-|
22:27:18 <noob33> I had them both up. I really really appreciate your writing. It's difficult to find long examples of type level stuff in action. I've basically been collecting scraps around the internet and summarizing them myself. Your posts are quite helpful.
22:27:24 <jle`> unyu: in a non-datakinds sense, it's useful for making non-* kinded instances of Category
22:27:36 <jle`> noob33: really happy to hear that it's been helpful :)
22:27:51 <jle`> unyu: (.) :: Category r => r b c -> r a b -> r a c
22:28:07 <jle`> unyu: there is no reason why a, b, and c should have to be kind *
22:28:28 <jle`> so PolyKinds lets us write instances of the Category class that take things other than *
22:28:45 <ReinH> > let go xs '(' = ')':xs; go [] ')' = undefined; go (x:xs) ')' = xs in foldl go "" "(()())(()()(())()((())())"
22:28:49 <lambdabot>  ")"
22:28:54 <jle`> unyu: like everyone's favorite Natural Transformation example
22:29:05 <mniip> % :t \xs -> SelectT (\f -> find (isJust . f) xs)
22:29:05 <yahb> mniip: Foldable t => t a1 -> SelectT a2 Maybe a1
22:29:07 <jle`> and also the neat (:-) instance
22:29:10 <unyu> jle`: What would that example be?
22:29:32 <mniip> it's like
22:29:35 <ReinH> my naive brace balancer is a success
22:29:35 <jle`> @let newtype NT f g = NT { runNT :: f a -> g a }
22:29:37 <lambdabot>  .L.hs:161:32: error: Not in scope: type variable ‘a’
22:29:37 <lambdabot>      |
22:29:37 <lambdabot>  161 | newtype NT f g = NT{runNT :: f a -> g a}
22:29:45 <jle`> @let newtype NT f g = NT { runNT :: forall a. f a -> g a }
22:29:47 <lambdabot>  Defined.
22:29:49 <jle`> i was hoping that would work heh
22:29:58 <unyu> jle`: Oh, I thought you mean "example of a natural transformation", rather than "natural transformations as an example".
22:30:02 <mniip> we're looking for a1's by testing them in the Maybe monad
22:30:28 <jle`> unyu: oh yea, i meant, the Category instance of NT, everyone's favorite example Category instance that isn't on *
22:30:41 <jle`> and (:-) from the Constraints library is cute too
22:31:00 <jle`> and also an instance for delayed matrix multiplications
22:31:11 <jle`> that one is neat
22:31:36 <ReinH> > let go xs '(' = Just (')':xs); go [] ')' = Nothing; go (x:xs) ')' = Just xs in foldM go "" "(()())(()()(())()((())())"
22:31:39 <lambdabot>  Just ")"
22:31:45 <dmwit> unyu: Typeable is polykinded now.
22:31:46 <ReinH> My slightly less naive brace balancer is a success
22:31:54 <unyu> Ah.
22:32:31 <dmwit> Which, thank $DEITY for that, because the whole Typeable1 Typeable2 Typeable1To2 hierarchy was an awful mess.
22:33:21 <mniip> % runSelectT (selector [1..] >>= \x -> selector $ map ((,) x) [1 .. x]) (\(x, y) -> if even x && y > 6 then Just () else Nothing)
22:33:21 <yahb> mniip: Just (8,7)
22:33:26 <mniip> it is kinda making sense
22:33:34 <mniip> but this is probably just one aspect of it
22:33:44 <jle`> that's the first working code for select that i've seen, and i spent a good while looking for some
22:34:05 <mniip> % :i selector
22:34:05 <yahb> mniip: selector :: Foldable t => t a1 -> SelectT a2 Maybe a1 -- Defined at <interactive>:27:1
22:34:09 <mniip> just something I've just defined
22:34:17 <mniip> selector xs = SelectT (\f -> find (isJust . f) xs)
22:34:34 <MarcelineVQ> jle`, mniip: "SelectT is not a functor on the category of monads, and many operations cannot be lifted through it." What is this telling me as a basic haskell user? What is the category of monads? The set of Monads that can compose to form Monads?
22:35:08 <mniip> MarcelineVQ, the category of monads is the one with objects monads and morphisms monad homomorphisms
22:35:15 <ReinH> mniip: well that seems to do... something.
22:35:42 <unyu> jle`: Now that I think about it, how exactly is a value of type "forall a. f a -> g a" necessarily a natural transformation from "f" to "g"? "f" and "g" needn't even be functors.
22:35:45 <mniip> a functor on the category of monads, like MaybeT, is one that for every monad gives you a monad back
22:35:52 <nshepperd> % let choose xs = asum (map (\x -> SelectT (\k -> x <$ k x)) xs) in runSelectT (choose [-5, 1, 2 :: Int]) (\x -> if x > 0 then [x] else [])
22:35:52 <yahb> nshepperd: [1,2]
22:35:53 <mniip> ContT and SelectT aren't such
22:36:09 <ReinH> "functor on the category of monads" means endofunctor here?
22:36:11 <jle`> unyu: it is one if f and g are Functors :3
22:36:13 <mniip> yes
22:36:27 <ReinH> ok
22:36:33 <mniip> or rather
22:36:38 <mniip> ContT and SelectT do such
22:36:44 <mniip> but they can't lift arbitrary monad homomorphisms
22:36:50 <jle`> unyu: the nice thing is that it is automatically a natural transformation because of free theorems/"naturality"
22:36:51 <mniip> which is the other part of being a functor
22:37:08 <mniip> jle`, yeah until it is not!
22:37:23 <jle`> it must never be not
22:37:33 <jle`> and not for naught
22:37:33 <mniip> I mean edwardk has been explaining this stuff to me recently
22:37:46 <unyu> mniip: Is it really enough that applying the type constructor to a monad gives another monad? Don't you need some extra condition on how it acts on monad morphisms? Or maybe parametricity already takes care of it?
22:37:56 <mniip> 1515652581 [09:36:21] <mniip> but they can't lift arbitrary monad homomorphisms
22:38:21 <mniip> this is exactly the problem with ContT
22:38:27 <unyu> Ah.
22:38:38 <MarcelineVQ> mniip: thank you. quite an uh opaque thing to describe an interface with to users.
22:38:56 <jle`> mniip is now the only living user of SelectT
22:38:57 <mniip> I don't think it was quite intended for public use yet
22:39:01 <MarcelineVQ> precise at least, I hope
22:39:07 <mniip> jle`, yeah I'm about to
22:39:09 <mniip> do some fancy
22:40:29 <parsnip> in https://www.yesodweb.com/book/shakespearean-templates#shakespearean-templates_calling_shakespeare
22:40:29 <mniip> hrm
22:40:35 <mniip> there's no findM
22:40:36 <parsnip> is there some magic with the types?
22:40:48 <parsnip> that is, main = putStrLn $ renderHtml $ template "My Title" render
22:41:00 <parsnip> but `template :: Text -> HtmlUrl MyRoute`
22:41:15 <parsnip> it TH doing some magic?
22:41:29 <lyxia> parsnip: https://hackage.haskell.org/package/yesod-core-1.4.37.2/docs/Yesod-Core.html#t:HtmlUrl
22:41:39 <parsnip> looks like template :: x -> y`, but then we have `t z w`.
22:41:57 <parsnip> oooohhhh
22:41:59 <jle`> mniip: yeah it's weird, i've always used MaybeT and asum in those situations
22:42:20 <parsnip> lyxia: thanks
22:42:25 <lyxia> parsnip: :)
22:42:32 <parsnip> i thought for sure i hat tried to answer my question, clearly not, sorry.
22:42:39 <parsnip> *that i
22:42:49 <lyxia> no worries
22:42:52 <ReinH> jle`: FWIW, forall a. f a -> g a is actually "much stronger" than naturality. http://math.andrej.com/2016/08/06/hask-is-not-a-category/comment-page-1/#comment-66575
22:42:54 <parsnip> TH won't do anything crazy like that, right?
22:43:02 <parsnip> TH scares me
22:43:02 <ReinH> parametricity, in general, is much stronger than naturality.
22:43:16 <jle`> ooh
22:43:32 <mniip> ugh mtl is weird
22:43:48 <ReinH> Unfortunately, I can't figure out what he's citing because dl.acm.org seems to not be responding.
22:43:58 <mniip> there's no MonadMaybe
22:44:07 <jle`> surprise
22:44:10 <jle`> it's in base!
22:44:13 <jle`> hehe
22:44:14 <srhb> Is there a candidate for something like Line Text -> Maybe FilePath in turtle somewhere? Can't seem to find it.
22:44:21 <ReinH> Ah, google is my friend, it's Logical Relations and Parametricity - A Reynolds
22:44:25 <mniip> no it's not?
22:44:29 <lyxia> parsnip: The type won't change.
22:44:59 <jle`> mniip: i've been using Alternative and sometimes MonadFail as MonadMaybe
22:45:00 <parsnip> okay, good. i probably need to improve my "jump to definition" workflow soon.
22:45:22 <jle`> since Nothing ~ empty/mzero/fail ""
22:45:25 <jle`> Just ~ return
22:45:27 <mniip> ugh, I guess I can make do with ExceptT
22:45:34 <mniip> yeah no, see, I need
22:45:40 <mniip> nothing :: MonadMaybe m => m a
22:45:51 <dmwit> :t empty
22:45:53 <lambdabot> Alternative f => f a
22:46:01 <mniip> maybeT :: m c -> (a -> m b) -> MaybeT m a -> m c
22:46:03 <mniip> er
22:46:05 <mniip> maybeT :: m c -> (a -> m c) -> MaybeT m a -> m c
22:46:08 <mniip> err
22:46:09 <nshepperd> % runSelectT (choose [-5, 4, 1, 2 :: Int]) (filters even) :: Maybe Int
22:46:09 <yahb> nshepperd: Just 4
22:46:11 <jle`> yeah last time i needed to polymorphize over Maybe, i used Alternative
22:46:14 <nshepperd> % runSelectT (choose [-5, 4, 1, 2 :: Int]) (filters even) :: [Int]
22:46:14 <yahb> nshepperd: [4,2]
22:46:15 <mniip> yeah that
22:46:19 <mniip> I think
22:46:22 <jle`> and actually if you use MonadFail, you get the right behavior for patterns in do blocks
22:46:37 <jle`> (will be MaybeT (pure Nothing))
22:46:52 <nshepperd> I wrote choose and filters
22:46:57 <jle`> :t choose
22:46:59 <lambdabot> Random a => (a, a) -> Gen a
22:47:06 <nshepperd> % :t choose
22:47:06 <yahb> nshepperd: MonadPlus f => [a] -> SelectT b f a
22:47:09 <nshepperd> % :t filters
22:47:09 <yahb> nshepperd: Alternative f => (a -> Bool) -> a -> f a
22:47:29 <ReinH> "all polymorphic functions are natural transformations" was originally a folk theorem due to Wadler with a sort of Fermat's Last Theorem flavor since in Theorems For Free he said he'd write it up in a future paper and then never did. He does mention it in The Algebra of Programming, though again without a proof.
22:47:41 <dmwit> :t \nah yeah act -> (act >>= yeah) <|> nah -- not quite right
22:47:43 <lambdabot> (Monad f, Alternative f) => f a1 -> (a2 -> f a1) -> f a2 -> f a1
22:47:56 <dmwit> (Because it will do `nah` even if `act` succeeds but `yeah` fails.)
22:48:24 <dmwit> mniip: But maybe that's close enough for your needs?
22:48:40 <jle`> dmwit: that's the behavior for MaybeT at least anyway
22:49:04 <dmwit> :t \nah yeah -> runMaybeT >=> maybe nah yeah
22:49:07 <lambdabot> error:
22:49:07 <lambdabot>     Variable not in scope: runMaybeT :: a1 -> m (Maybe a)
22:49:19 <dmwit> :t \nah yeah -> Control.Monad.Trans.Maybe.runMaybeT >=> maybe nah yeah
22:49:21 <lambdabot> Monad m => m c -> (a -> m c) -> Control.Monad.Trans.Maybe.MaybeT m a -> m c
22:51:20 <mniip> here goes
22:51:21 <mniip> % :t SelectT . flip (alaf Alt foldMap)
22:51:21 <yahb> mniip: (Foldable t, Alternative g) => t b -> SelectT b g b
22:53:06 <mniip> aha
22:53:12 <mniip> SelectT is already Alternative
22:53:16 <mniip> given MonadPlus g
22:54:08 <mniip> % selectorT :: (Alternative m, Foldable f) => f a -> SelectT a m a; selectorT = SelectT . flip (alaf Alt foldMap)
22:54:08 <yahb> mniip:
22:56:30 <mniip> % supervise f m = m >>= \x -> SelectT (const (f x)) >> return x
22:56:30 <yahb> mniip:
22:58:55 <mniip> % runMaybeT $ runSelectT (supervise (lift . print) $ selectorT [1 ..]) (\e -> if e > 5 then return e else empty)
22:58:55 <yahb> mniip: 1; 2; 3; 4; 5; 6; 6; Just 6
22:59:59 <nshepperd> ok I have no idea what this is doing now
23:02:04 <mniip> % tracing s = supervise (lift . putStrLn . ((s ++ ":") ++) . show)
23:02:04 <yahb> mniip:
23:03:02 <mniip> % runMaybeT $ runSelectT (tracing "x" (selectorT [1 ..]) >>= \x -> tracing "y" (selectorT [1 .. x])) (\e -> if e > 3 then return e else empty)
23:03:02 <yahb> mniip: x:1; y:1; x:2; y:1; y:2; x:3; y:1; y:2; y:3; x:4; y:1; y:2; y:3; y:4; y:4; x:4; y:1; y:2; y:3; y:4; y:4; Just 4
23:03:44 <mniip> notice how it ordered the putStrLns in backtracking order
23:04:01 <jle`> [ e | e > 3 ]
23:04:05 <mniip> this is like a listT but
23:04:14 <mniip> jle`, MaybeT
23:04:33 <mniip> not sure if MonadComprehensions is on
23:04:40 <jle`> MaybeT has a MonadFail instance :D
23:04:47 <jle`> ah so does this deliver on the promises of ListT?
23:04:58 <mniip> not sure
23:05:06 <mniip> I sense issues with lawfulness
23:05:24 <mniip> maybe
23:05:54 <mniip> this *is* different from ListT
23:06:01 <mniip> see how after it finds y=4
23:06:16 <mniip> reaffirms it again,
23:06:20 <mniip> that fixes "x"
23:06:32 <jle`> hmm
23:06:35 <mniip> but we discard y at this point
23:06:39 <mniip> so we look through ys again
23:07:16 <mniip> it wouldn't have a computational-class-changing effect on anything polynomial, but
23:07:20 <mniip> hmm
23:19:43 <mniip> ugh
23:19:54 <mniip> something in that SelectT I still don't get
23:21:33 <dmwit> > [(1, 2), (3, 4)] ^.. _1
23:21:37 <lambdabot>  error:
23:21:37 <lambdabot>      • Could not deduce (Field1 [(a0, b0)] [(a0, b0)] b1 b1)
23:21:37 <lambdabot>        from the context: (Field1 [(a, b)] [(a, b)] b1 b1, Num b, Num a)
23:21:54 <mniip> ambiguous
23:21:58 <jle`> > [(1, 2), (3, 4)] ^.. folded . _1
23:22:02 <lambdabot>  [1,3]
23:22:05 <dmwit> thanks
23:22:14 <jle`> or traverse/traversed/etc.
23:22:33 <jle`> np
23:23:46 <dmwit> > [(1, 2), (3, 4)] >>= _1 pure
23:23:50 <lambdabot>  [(1,2),(3,4)]
23:23:57 <dmwit> nailed it
23:24:07 <jle`> success.jpg
23:24:30 <MarcelineVQ> yesthisisdog.png
23:24:33 <mniip> uhhh
23:24:35 <mniip> that's uh
23:25:00 * nshepperd is playing with the one line sat solver from the paper
23:25:02 <mniip> yeah no, everyone realizes the laws in play here, right?
23:26:00 <mniip> hold on
23:26:08 <MarcelineVQ> nshepperd: of https://arxiv.org/pdf/1406.2058.pdf ?
23:26:08 <mniip> the latter bindee in SelectT
23:26:14 <nshepperd> yeah
23:26:15 <mniip> can override some things
23:26:55 <nshepperd> sat = sequence (repeat (select (\p -> p True)))
23:27:31 <mniip> that's
23:27:33 <mniip> elegant
23:27:40 <mniip> I can almost figure out the types
23:27:54 <jle`> we need a repeatM
23:28:16 <mniip> repeatM = sequenceA . repeat ?
23:28:18 <jle`> i guess it's just many
23:28:22 <mniip> no
23:28:26 <mniip> not at all
23:28:32 <mniip> many is the klenee star
23:28:59 <jle`> it's many if the thing never fails i think
23:29:02 <mniip> many k = pure [] <|> liftA2 (:) k (many k)
23:29:33 <mniip> quite the opposite
23:29:45 <mniip> :t select (\p -> p True)
23:29:47 <lambdabot> error:
23:29:48 <lambdabot>     Variable not in scope: select :: ((Bool -> t0) -> t0) -> t
23:29:50 <mniip> % :t select (\p -> p True)
23:29:50 <yahb> mniip: Select Bool Bool
23:29:55 <mniip> so far so good
23:29:57 <mniip> oh
23:30:12 <mniip> that's a Select Bool [Bool]
23:30:18 <mniip> dang
23:30:26 <mniip> that's amazing
23:31:33 <mniip> combined with the explicit backtracking
23:42:48 <nshepperd> not exactly an efficient solver
23:42:55 <nshepperd> but it's a fun one-liner!
23:51:56 <dmwit> > mapAccumL (\a b -> (f a b, g a b)) w [x,y,z]
23:51:59 <lambdabot>  error:
23:51:59 <lambdabot>      • Ambiguous type variable ‘c0’ arising from a use of ‘show_M826587491542...
23:51:59 <lambdabot>        prevents the constraint ‘(Show c0)’ from being solved.
23:53:03 <dmwit> > mapAccumL (\a b -> (f a b, g a b)) w [x,y,z] :: (Expr, [Expr])
23:53:07 <lambdabot>  (f (f (f w x) y) z,[g w x,g (f w x) y,g (f (f w x) y) z])
