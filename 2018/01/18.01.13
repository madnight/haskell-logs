00:14:36 * hackage fast-arithmetic 0.3.0.0 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.3.0.0 (vmchale)
00:22:13 <woodson_> hi guys, just want to clarify something
00:23:17 <woodson_> when you use the do notation an unpure action will be performed correct?
00:24:53 <geekosaur> only in IO
00:25:08 <geekosaur> IO is not special because of bdo notation or because it is a monad; IO is special because it is IO.
00:25:17 <geekosaur> likewise ST (IO is actually a specialization of ST)
00:25:50 <geekosaur> if you use do notation with Maybe or lists, it's all pure
00:25:54 <koz_> If you use do-notation for [], for instance, it's perfectly pure.
00:26:02 <koz_> geekosaur: I think I owe you a soda?
00:27:18 <geekosaur> you can think of do notation as working with "actions". actions may be pure or impure, depending on the monad they're in.
00:28:19 <geekosaur> in IO, they're impure. in ST, they're impure but delimited so that the impurity can't leak out easily into pure code. in STM, they're "future" impure actions when you apply them with "atomically" (which itself is in IO)
00:28:49 <jle`> woodson_: do notation is just a way of combining actions
00:28:54 <jle`> in a pure way
00:29:01 <geekosaur> and that's the limit to impurity in Haskell, at least currently. (Someone might conceivably come up with a different source of impurity.)
00:29:40 <parsnip> is state pure for an input?
00:29:44 <geekosaur> use do notation with anything but those three and it's all pure. Including STM as long as you haven't applied the transaction in IO with "atomically".
00:29:57 <jle`> do notation doesn't actually do anything impure, but the actions themselves might represent impure things, semantically
00:30:01 <geekosaur> state is pure. it's a wrapper for passing and returning a parameter
00:30:07 <geekosaur> which is entirely pure
00:30:27 <geekosaur> IORef and STRef are *not* pure... which is why they're in IO and ST, respectively
00:30:39 <jle`> 'action1' and 'action2', if they are IO actions, might represent the idea of doing impure things.  'do action1; action2' just returns a *new* action, that represents differnt action, which might, semantically, represent impure IO actions
00:30:45 <jle`> but do notation itself is not impure
00:30:46 <parsnip> yeah, i'm guessing state is pure, but it helps you represent things that allow you to think in non-pure ways.
00:31:16 <parsnip> isn't IO somehow pure until execution?
00:31:17 <geekosaur> I'd say it's a convenient way to do things purely while writing "apparently impurely"
00:31:46 <jle`> parsnip: an IO action is a pure action, but it represents something that will be executed impurely
00:31:46 <geekosaur> and IO is technically pure because it's technically just chaining a bunch of actions together and handing them to the (impure!) runtime via main
00:32:00 <jle`> well, pure action in the sense that it's a pure value
00:32:09 <geekosaur> but, just as STM is actually "pure" until applied, you still have to think of ti as impure because the whole point is applying it
00:32:25 <jle`> `getLine :: IO String` is the same exact IO action, no matter when you use it
00:32:41 <jle`> it's not like evaluating `getLine :: IO String` once, and the evaluating it again somewhere else, will give you a different IO action
00:32:51 <jle`> everywhere in your code, `getLine :: IO String` (from Prelude) is the same IO action
00:33:07 <jle`> just like how `putStrLn :: String -> IO ()` is a pure function
00:33:31 <woodson_> so is possible to pass a list of action perform in a do block
00:33:47 <woodson_> to a function as an argument?
00:33:49 <jle`> woodson_: pass a list of action perform in a do block?
00:33:54 <parsnip> list as in lines of code, or list as in [1, 2, 3]?
00:33:57 <jle`> do you mean an actual list?
00:34:05 <woodson_> jle: sorry no
00:34:07 <woodson_> i mean
00:34:18 <jle`> woodson_: remember that a do block is an expression; the point is to construct a value
00:34:21 <woodson_> do {action1;action2;action3...etc}
00:34:30 <jle`> so `do action1; action2; action3` is a value
00:34:35 <jle`> the result is a normal ol' value
00:34:43 <jle`> that you can give to any function expecting a value of that type
00:34:59 <jle`> `do putStrLn "hi"; getLine` is a normal Haskell value, nothing special about it
00:35:04 <jle`> no different than an Int or a Bool
00:35:07 <jle`> its type is `IO String`
00:35:16 <jle`> so if i had a function `foo :: IO String -> Int`
00:35:22 <jle`> i could definitely pass in (do putStrLn "hi"; getLine)
00:35:27 <jle`> since that's just a normal ol' value of type IO String
00:35:50 <jle`> do notation is just a way to construct a value in a cleanish way
00:36:00 <jle`> :t do putStrLn "hi"; getLine
00:36:02 <lambdabot> IO String
00:36:07 <geekosaur> worth noting is IO <something> acts as if it were a function. but if you use do notation in the list monad, the result is a list.
00:36:11 <geekosaur> not a function
00:36:15 <parsnip> that would have to be a constant function?
00:36:16 <jle`> :t (do putStrLn "hi"; getLine, True, "hello")
00:36:18 <lambdabot> (IO String, Bool, [Char])
00:36:25 <jle`> see, three normal values :)
00:36:30 <geekosaur> (in fact, a list comprehension is more or less that, with slightly different notation)
00:37:06 <jle`> woodson_: the result of a do block is not any special haskell or magic value, it's just a normal value
00:37:18 <jle`> and the result is always constructed purely
00:37:34 <jle`> (do action1; action2) creates a *new* IO action, purely
00:37:43 <jle`> (do action1; action2) will always create the same action
00:37:44 <woodson_> jle: oohh so at the end of he the day, your final action will still be the value that gets passed
00:37:47 <geekosaur> a do "block" just sticks operators in for you to make an expression. like any Haskell expression, it is lazy by default.
00:38:01 <woodson_> if one wish to pass a do block to a function
00:38:02 <jle`> woodson_: yeah, do block is just another haskell syntax thing to let you create a value
00:38:11 <jle`> yeah, just like how you can create values with a bunch of other syntax
00:38:14 <geekosaur> "do x; y" is the expression (x >> y)
00:38:20 <jle`> like [1,2,3] is a list literal, to create a value of type [Int]
00:38:27 <jle`> and "hello" is a string literal, to create a value of type String
00:38:30 <geekosaur> what it does depends on the definitoon of (>>) for that monad
00:38:42 <geekosaur> also:
00:38:43 <jle`> 'do putStrLn "hi"; getLine' is an expression that creates a value of type 'IO String'
00:38:45 <geekosaur> :t do 5
00:38:47 <lambdabot> Num p => p
00:38:51 <jle`> and they all fill the same role, syntactically
00:39:22 <jle`> woodson_: yeah, remember functions don't "take" expressions, they take values
00:39:23 <geekosaur> "do" by itself does nothing. except tell the compiler to teat semicolons and the "<-" notation specially (as (>>) and (>>=), respectively)
00:39:33 <jle`> so you don't really pass a do block to a function, you pass a value that you might make using a do block
00:39:46 <jle`> just like how you don't pass a "list literal" to a function...you pass a list
00:39:54 <mniip> 1515831893 [11:24:53] <geekosaur> likewise ST (IO is actually a specialization of ST)
00:40:04 <mniip> is that fact actually useful information?
00:40:06 <geekosaur> true in ghc, at least
00:40:14 <mniip> not really true
00:40:18 <mniip> they're both newtypes
00:40:46 <mniip> you can't "subtype" ST to IO
00:40:50 <geekosaur> it can be useful, if you're trying to understand what's actually going on. it's another indication that the "special" is related to the type, not to the notation
00:41:00 <woodson_> jle: oh man, as usual thank you!
00:41:04 <geekosaur> context matters
00:41:14 <woodson_> geekosaur: thank you too!
00:41:15 <jle`> woodson_: no problem!
00:41:21 <parsnip> helps to sequence things?
00:41:34 <parsnip> and build things.
00:41:42 <jle`> woodson_: yeah, the important thing i think (based on what i saw you ask earlier) is that do blocks don't actually perform anything impure, they're just another convenient way to purely construct a value
00:41:44 <geekosaur> if sequencing or building is part of what the type does, yes
00:41:51 <parsnip> right
00:42:06 <geekosaur> which is the main reason do notation is useful. (and why some builders used to abuse do notation with non-monads)
00:42:39 <parsnip> oh, like dressed as a monad but not satisfying the axioms?
00:42:56 <mniip> more like RebindableSyntax
00:42:58 <geekosaur> conversely, you almost never see do notation with Maybe (the direct operators are usually more sensible) or lists (list comprehensions are usually more convenient)
00:42:59 <woodson_> jle: Got it!
00:43:21 <parsnip> ha, i'm looking at my Maybe do problem now.
00:43:27 <geekosaur> parsnip, yes. (specifically if you used <- aka >>= with it, it'd throw an exception)
00:43:46 <parsnip> interesting
00:43:49 <jle`> for what it's worth i use Maybe with do notation all the time, so you're not weird if you use it :3
00:43:59 <parsnip> here's Maybe in do: http://lpaste.net/361603
00:44:19 <mniip> % :set -XRebindableSyntax
00:44:19 <yahb> mniip:
00:44:35 <mniip> % let (>>=) = flip id in do { x <- 3; x + 5 }
00:44:36 <yahb> mniip: 8
01:30:31 <Lokathor> ghc 8.2 is all sorts of broke on win32
01:30:47 <Lokathor> 8.2.2 to be precise
01:31:26 <koz_> Lokathor: Colour me distinctly unsurprised. What broke?
01:31:44 <Lokathor> i guess the compilation output uses color codes now?
01:31:50 <Lokathor> even when i try to turn them off, they don't turn off
01:32:08 <Lokathor> and they're ANSI escape sequences, which the windows command prompt just prints because it doesn't recognize them
01:32:21 <koz_> Lokathor: Have you tried PowerShelling it instead?
01:32:54 <Lokathor> never used powershell, and VS Code opens a cmd.exe
01:33:01 <Lokathor> as its in-editor terminal
01:33:31 <koz_> I'd be curious if PowerShell can understand the colour codes, but it is a problem definitely.
01:33:47 <koz_> (and you can't change VSCode's in-editor terminal at all?)
01:34:00 <Lokathor> ah, yeah, powershell uses the colors
01:34:56 <Lokathor> and i have no idea how to make VS Code change its terminal :/  I just use it because it's "not as bad as actually using vim or emacs"
01:35:16 * koz_ prefers Neovim to all the above, but w/e.
01:35:29 <koz_> You probably can, or at least I'd expect so anyway.
01:35:36 <Lokathor> oh, wait, i was looking at the wrong error message
01:35:41 <koz_> But I agree that unremovable colour codes is not ideal.
01:35:44 <Lokathor> powershell also doesn't interpret the color commands
01:36:15 * Lokathor sighs
01:36:41 <Lokathor> there's no way at all that a single person could have tested GHC 8.2.x on win32 and not immediately noticed this problem
01:36:51 <koz_> Lokathor: Reported it?
01:37:01 <koz_> If not, do, because that's a pretty annoying problem.
01:37:02 <Lokathor> i'm not sure where to
01:38:06 <mniip> Lokathor, load ANSI.SYS?
01:38:11 <mniip> oh wait this isn't DOS
01:39:24 <mniip> Lokathor, https://ghc.haskell.org/trac/ghc/newticket?type=bug
01:39:42 <Lokathor> oh no
01:39:51 <Lokathor> i need to reset my password i guess
01:41:45 <Lokathor> -fdiagnostics-color=never
01:41:49 <Lokathor> that's the flag, right?
01:42:02 <Lokathor> i tries that one in the ghc-options part and it did nothing
01:56:54 <Lokathor> ah HA
01:57:09 <Lokathor> i realized the trouble
01:57:22 <Lokathor> GHC is doing the right thing, but GHC through stack is doing the wrong thing
01:59:13 <koz_> So it's a Stack-on-Windows problem?
01:59:19 <Lokathor> oh well, saves a bug report to GHC
01:59:33 <Lokathor> yeah if i go to the directory and execute Ghc itself there's no problem
01:59:47 <Lokathor> somehow stack is tricking GHC into turning bad
02:02:59 <angerman> hackage.mobilehaskell.org should hopefully be reliably and quick now. After moving it over to S3+Fastly
02:04:01 <angerman> If you had problems earlier, please try again
02:04:22 <mniip> angerman, typo in the first line
02:06:22 <angerman> mniip: but the site does work?
02:06:52 <mniip> only tried the homepage
02:07:31 <angerman> mniip: I’ll fix the spelling when I’m back. Thanks!
02:14:37 * hackage hspec-core 2.4.7, hspec-discover 2.4.7, hspec 2.4.7 (SimonHengel): https://qbin.io/77kwx2szw
02:33:34 <parsnip> do you expect in emacs to be able to put point on `mkYesod` and have emacs open a page at hackage in your browser? or is there a better workflow?
02:34:04 <parsnip> i have M-x hoogle, maybe i need to look at these some more
02:35:31 <nullie> parsnip: M-x hoogle works for me
02:35:47 <nullie> or do you want something like open it in emacs?
02:35:52 <parsnip> https://www.haskell.org/hoogle/?q=mkYesod ==> No results found
02:36:09 <parsnip> no, i appreciate formatting in modern browsers ;)
02:36:21 <nullie> parsnip: is there some hoogle which finds it?
02:36:27 <parsnip> so, no real preference there
02:36:36 <parsnip> hmm, looking into that now.
02:39:38 <nullie> http://hoogle.haskell.org seems to have it
02:40:36 <nullie> www.stackage.org
02:40:36 * hackage mmark 0.0.5.0 - Strict markdown processor for writers  https://hackage.haskell.org/package/mmark-0.0.5.0 (mrkkrp)
02:41:09 <nullie> parsnip: customize variable haskell-hoogle-url
02:46:08 <parsnip> nice, (setq haskell-hoogle-url "http://hoogle.haskell.org?hoogle=%s")
02:46:12 <parsnip> thanks!
02:46:50 <parsnip> i should read more about these when i can, but this gets back into the reading faster.
02:48:05 <nullie> parsnip: you can do just M-x customize-variable
02:49:11 <parsnip> ah!
03:02:20 <electrocat> angerman: how does llvmng differ from the old llvm?
03:03:54 <cocreature> electrocat: it uses llvm’s binary bitcode format instead of the textual IR
03:04:11 <cocreature> which has the advantage that LLVM actually offers some compatibility for that
03:04:48 <angerman> Right. And it does away with most of the aliases.
03:05:22 <angerman> And as such actually allows to dead_strip on iOS.
03:06:47 <electrocat> ah, i see, thanks
03:07:56 <angerman> -fast-llvm sidesteps the assembly generation and mangler.
03:08:30 <angerman> .bc -> .o instead of .bc -> .S -> .o
03:25:47 <malorie> I'm looking to build a small data scraping engine in haskell, that allows me to scrape certain sources continuously. so I'm thinking about implementing a daemon in haskell that can manage the scrapers (loading, unloading, etc). I also want to be able to talk to this daemon via a cli-program. is there any literature/package I could be checking out?
03:29:05 <cocreature> I’d have the daemon start an http server and talk to it via that
03:29:46 <malorie> so I'm not limited to clients that run on the OS?
03:30:16 <cocreature> that’s one nice side effect of doing it that way but even if you run on the same os, it’s one of the easier ways of accomplishing this
03:31:53 <malorie> can you recommend an http-server package?
03:39:42 <cocreature> I like servant
03:39:54 <cocreature> it also has the advantage that you get the client code basically for free using servant-client
03:40:24 <cocreature> but it does make use of a fair amount of advanced Haskell extensions
03:52:15 <malorie> thanks, I'll check it out. it would be nice to provide the client with a graphql api, since my database service is providing that already
03:53:07 <malorie> but it looks like efforts to integrate graphql into servant have been stalled
03:55:12 <dramforever> Hello, here's a nix question! Does anybody know how to build ghc HEAD with 8.2.2 instead of 8.2.1? I tried to override bootPkgs = haskell.packages.ghc822 but it doesn't seem to work perfectly -- it still downloads ghc-8.2.1-binary
04:01:27 <geekosaur> dramforever, I would assume you need to make a ghc-8.2.2-binary package, or rewrite its derivation to use an installed one instead of a special bootstrap package
04:11:22 <alp> malorie, well those efforts are fairly recent
04:11:41 <alp> but yeah, there isn't a usable bit of code for now re graphql
04:11:50 <alp> (re: servant & graphql)
04:21:07 <malorie> alp: I've seen the graphql-api package, which seems to be maintained. surely it can't be too hard to use that in servant, somehow?
04:23:46 <alp> malorie, well, I'll just let you take a look at the existing discussion & code at https://github.com/haskell-servant/servant/issues/554 and https://github.com/haskell-servant/servant-graphql
04:24:10 <alp> I don't really know graphql all that well so I can't really provide any helpful summary.
04:31:15 <centril> Does this make sense?  data Void = ;  instance CoArbitrary Void where coarbitrary = undefined ;
04:37:06 * hackage hedis 0.10.0 - Client library for the Redis datastore: supports full command set,pipelining.  https://hackage.haskell.org/package/hedis-0.10.0 (k_bx)
04:45:21 <lyxia> centril: coarbitrary x = case x of {}
04:45:31 <malorie> incidently I've just tried to access redis documentation and it redirects to an old package version where the doc is missing: https://hackage.haskell.org/package/hedis/docs/Database-Redis.html
04:45:51 <lyxia> centril: in practice they're the same
04:47:09 <malorie> alp: thanks for the link to the issue, btw :-)
04:48:54 <centril> lyxia: right, thanks =)
05:16:24 <ph88> hey guys, in this video they say that purity is the result of laziness https://youtu.be/kYaowT7wT0E?t=6m50s does that mean that strict code is no longer pure ?
05:21:56 <ph88> i have another question as well .. i saw many languages implement monads (all sorts of ways) .. (also imperative languages) .. but it has not really caught on. Is there anything specifically that make monads work well in haskell (like a language/compiler design decision) or is it more of a historical choice because "they had to use something" ?
05:25:40 <miladz89> ph88_: I believe the Haskell type system and currying is the reason that monads (and all other category theory types) work so well
05:25:44 <pk6vx0x2> ph88: strict code is also pure.
05:26:22 <ph88> what is this guy on about with "purity is the result of laziness" ??
05:27:29 <merijn> ph88: There is some logic to that
05:27:44 <merijn> ph88: People wanted to experiment with lazy languages, but without purity you're doomed
05:28:05 <merijn> ph88: Because then you can't control when side-effects happen
05:28:34 <merijn> ph88: The requirement that Haskell was pure was definitely strongly influenced by wanting to work on laziness
05:29:40 <merijn> ph88: So saying purity is entirely the result of laziness is a stretch, but there's a grain of truth
05:30:48 <ph88> ah i see ..
05:37:11 <pk6vx0x2> 2
05:40:53 <Peter123> Hey guys! Quick question.
05:41:13 <Peter123> Are there any scientifc workshops were I could present Haskell related research?
05:41:32 <merijn> Peter123: Loads :p What kinda research?
05:42:14 <Peter123> merijn: GUI related.
05:42:35 <merijn> That's...not really specific enough to be helpful :p
05:42:48 <merijn> ICFP and cohosted workshops would be a good starting point
05:42:58 <merijn> There's also IFL which has a very low barrier to entry
05:43:07 <Peter123> merijn: GUI, generic, formal verifiction
05:43:24 <Peter123> Something like the former haskell workshop, low entry barrier
05:43:29 <merijn> POPL might be relevant, depending on how much formal verification you have
05:43:33 <Peter123> and also in the next 2-3 months
05:43:55 <Peter123> haha. I meant workshop not the most respected conference in programming languages
05:44:17 <merijn> Peter123: That's why you go to the workshop list at related conferences
05:44:32 <Peter123> merijn: okay, got what you meant!
05:45:12 <Peter123> Any other conferences besides ICFP, POPL that have co-located workshops?
05:45:32 <merijn> most of them, but I dunno of any related to FP/formal verification :)
05:46:03 <Peter123> I will probably just check the conferences where other researchers published
05:46:10 <Peter123> merijn: thanks!
05:46:18 <merijn> Peter123: Are you in grad school?
05:46:53 <Peter123> merijn: end of PhD. I did a journal paper that was published in the FP field
05:47:12 <merijn> Peter123: Doesn't your advisor know conferences to go?
05:47:43 <Peter123> merijn: it's complicated. there is more than one.
05:49:42 <Peter123> merijn: It's quite strange that computer science doesn't manage to have a central conference database.
05:50:19 <Peter123> There is wikicfp but only a few conferences have their CFP there
05:50:39 <Peter123> The rest just write to some 'mailing lists'.
05:50:54 <Peter123> Any mailing lists that I could join?
05:51:04 <merijn> For FP the haskell lists are pretty good
05:51:49 <Peter123> Do you mean 'mail.haskell.org'?
05:51:58 <merijn> The haskell-cafe one
05:52:13 <merijn> Although that also has a lot of non CFP mail
05:53:24 <Peter123> Okay!
06:06:36 * hackage microlens 0.4.8.2 - A tiny lens library with no dependencies. If you're writing an app, you probably want microlens-platform, not this.  https://hackage.haskell.org/package/microlens-0.4.8.2 (Artyom)
06:07:07 * hackage microlens-th 0.4.1.2 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.4.1.2 (Artyom)
06:07:36 * hackage microlens-mtl 0.1.11.1 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.11.1 (Artyom)
06:07:52 <jchia_> How can I 'coerce' Word64 to Int64 assuming two's complement representation? Data.Coerce doesn't apply.
06:08:06 <merijn> jchia_: Eh, just use fromIntegral?
06:11:17 <jchia_> merijn: Does fromIntegral for standard integral types work just by chopping or adding possibly sign-extended most-significant bits as necessary?
06:11:20 <geekosaur> jchia_, fromIntegral should already be optimized away for all built-in types
06:11:35 <merijn> jchia_: I'd expect it to, yes
06:11:37 <geekosaur> via RULES
06:11:46 <jchia_> OK
06:12:23 <merijn> Let's see how much faster I get by spreading nullPtr and C all over my haskell :p
06:17:46 <exio4>  
06:19:36 * hackage mmark-cli 0.0.1.0 - Description  https://hackage.haskell.org/package/mmark-cli-0.0.1.0 (mrkkrp)
06:20:08 <geekosaur> "Description"
06:20:12 <geekosaur> here we go again...
06:21:23 <merijn> geekosaur: At least it has a readme
06:21:42 <merijn> Ideally hackage gets a way to just include the README in the description
06:26:07 <merijn> huh...
06:26:53 <merijn> I...didn't know 783% CPU utilisations was doable...
06:27:07 <merijn> Especially since I don't recall multi-threading this program...
06:28:15 <merijn> Any Haskell profiling tool that is able to also look into CPU usage by C libraries?
06:28:24 <bennofs[m]> multi-threaded GC? :p
06:28:57 <bennofs[m]> afaik recent GCCs have dwarf support, so you may be able to just use standard native profiling tools like perf
06:29:11 <merijn> perf is dreadful, though >.>
06:29:20 <merijn> I should badger people into getting VTune
06:30:30 <merijn> But yeah, maybe GC overhead is kicking in, since I just noticed I do, in fact, compile threaded
06:30:52 <merijn> Right, now I'm just pinning it at 100%
06:31:07 <merijn> Apparently it goes up to 1900% on this machine >.>
06:31:19 <merijn> I should maybe look into reducing GCing, etc. a bit
06:31:34 <merijn> wow...
06:31:36 <merijn> dear god
06:32:23 <merijn> order of magnitude reduction (although I did change something else, so maybe it's not JUST threading)
06:35:51 <merijn> So...any pros know how I can reduce the impact of parallel GC?
06:36:21 <JuanDaugherty> don't use hs?
06:36:52 <MarcelineVQ> merijn: be sure to check out rts options first, there's quite a few for gc
06:36:54 <geekosaur> disable it entirely? +RTS -qb
06:37:04 <geekosaur> er -qg not -qb
06:37:23 <geekosaur> -qb disbles load-balancing while leaving parallel gc on
06:37:39 <JuanDaugherty> at least for critical sections
06:37:58 <MarcelineVQ> and by quite a few I​ mean at least 6 that start with g and more than don't
06:38:04 <MarcelineVQ> *q :>
06:38:31 <merijn> JuanDaugherty: There is no critical section, unless you suggest I rewrite the entire program in C
06:38:43 <merijn> MarcelineVQ: Yes, but I dunno which ones to fiddle with
06:39:06 <JuanDaugherty> merijn, ah, no I wasn't suggesting that
06:39:23 <merijn> geekosaur: I only have on thread right now, but long term I wanted to run this code in parallel, but if threaded GC kills me this bad I'll have to drop that plan
06:40:06 <geekosaur> so I guess I confused you. corrected version: disable it entirely? +RTS -qg
06:42:25 <merijn> geekosaur: Right, but what is the exact impact of that on threaded program?
06:43:06 <Peter123> Hi guys! Does anyone know a performant merge sort in haskell?
06:43:17 <Peter123> intro sort unboxed MVector   Bench time: 133.51us
06:43:18 <Peter123> merge sort unboxed MVector   Bench time: 478.44us
06:43:20 <merijn> Peter123: Besides "sort"? :p
06:43:33 <merijn> Peter123: What's your input data there?
06:43:54 <geekosaur> iirc threaded gc is often more expensive and turning it off can be beneficial
06:43:55 <Peter123> I'm using 'vector-algorithms' package applied to unboxed MVectors
06:44:19 <Peter123> Actually, for vector-algorithms the data type of the vector elements makes almost zero difference
06:44:33 <Peter123> Float, Double, Int, Paris of Ints all sort in the same time
06:44:43 <Peter123> *Pairs of Ints
06:45:02 <merijn> Peter123: Yeah, but how are you generating the test data?
06:45:16 <merijn> Peter123: Random? constant? sorted?
06:45:26 <merijn> Peter123: Are you using the same MVector for all runs?
06:45:29 <Peter123> The 133us for introsort and 478us merge sort is for a random vector of 10 000 Ints in the range of 1 to 3000
06:45:51 <Peter123> Yes, I am using the same vector but re-run the benchmarks often
06:46:44 <merijn> Peter123: Which are you running first?
06:48:03 <Peter123> merijn: I just changed the order of the criterion benchmarks and also benchmarked each algo alone
06:48:15 <CuriousErnestBro> why is let used?
06:48:15 <Peter123> merijn: doens't make a difference
06:48:31 <CuriousErnestBro> when you can just load definitions in the ghci without it
06:48:44 <MarcelineVQ> CuriousErnestBro: it used to be needed but isn't anymore
06:48:47 <lyxia> Communication would be more efficient by sharing the code of the benchmark
06:49:10 <Peter123> lyxia: OK. wait a sec.
06:49:31 <CuriousErnestBro> MarcelineVQ, I will omit it now, thanks
06:49:36 * hackage servant-auth-cookie 0.6.0.2 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.6.0.2 (zohl)
06:49:46 <Peter123> CODE: https://gist.github.com/stephano33/271d32e1d7fc9b242472801eb5ff67ce
06:49:48 <lyxia> I don't know of a performance-focused implementation of sort in Haskell
06:50:17 <Peter123> lyxia: I was in contact with the Accelerate package author and the high performance group
06:50:42 <Peter123> All said the same thing: there is no performant sort in haskell
06:51:07 <CuriousErnestBro> they say definitions are immutable, but i can do a = 3 and then a =2 just fine
06:51:39 <geekosaur> CuriousErnestBro, in ghci yes
06:51:47 <geekosaur> you are shadowing the old one, not rebinding it
06:52:01 <Peter123> The problem is I can't use Julia to sort my Ints.
06:52:02 <geekosaur> if something else was using the old one, it will keep using it (with laziness, this can be surprising)
06:52:16 <CuriousErnestBro> oh okay
06:52:27 <CuriousErnestBro> but there's no way anymore to access the old one anymore then?
06:52:29 <Peter123> Because serializing to Cbor format for numers takes 500 Microseconds.
06:53:00 <Peter123> Can anyone run my benchmark code? Maybe my ghc (version 8.2.2. is the bottleneck)
06:53:01 <geekosaur> not in ghci
06:53:51 <merijn> Peter123: Where is speedTest from?
06:55:00 <Peter123> merijn: What do you mean? I adapted the vector-algorithms benchmark code.
06:55:26 <merijn> The vector-algorithms benchmark code used to be very flawed
06:55:42 <Peter123> merijn: Yes. Unfortunately, there is no maintainer for the vector-algorithms package
06:55:44 <merijn> Not sure if Dan got around to updating it to use my criterion additions
06:56:00 <Peter123> merjin: I did update the benchmarks to use criterion.
06:56:23 <Peter123> I also wrote 2 e-mails to Dan, which didn't get a reply.
06:56:32 <Peter123> Perhaps he is too busy.
06:56:35 <merijn> ok, so vector-algorithms also uses speedTest, but I dunno where that comes from, still
06:57:17 <Peter123> merijn: I just checked. The mergsort doesn't even get faster on an *already sorted* vector. Strange.
06:58:01 <merijn> ok, so the speedTest in vector-algorithms is pretty bad
06:58:34 <merijn> Peter123: You may wanna write some better benchmarks using perRunEnv from criterion to make sure you have a fresh vector for each iteration
06:59:08 <Peter123> merijn: Okay, this is a very good point.
06:59:23 <Peter123> merijn: I thought that is the default.
06:59:32 <merijn> Peter123: No
06:59:41 <merijn> Peter123: THe default is globally shared environment with criterion
07:00:04 <merijn> Peter123: I had to implement perRunEnv and perBatchEnv for criterion myself when I wanted to do this kinda benchmarking :)
07:00:21 <Peter123> merijn: Thanks a ton for this info!
07:01:09 <Peter123> merijn: Do you have any other tips?
07:01:16 <Peter123> Would you go for a parallel sort solution?
07:01:18 <merijn> geekosaur: ok, so with -qg it's about as fast as unthreaded :)
07:01:37 <Peter123> Or would you go via the C FFI (but the FFI has perhaps also an overhead)?
07:01:44 <merijn> Peter123: Writing a *good* parallel sort in both Haskell and C++ is still on my todo list, but sadly I'm not getting to it any time soon
07:02:17 <merijn> Peter123: The FFI has very negligible overhead (especially if you know what you're doing and use unsafe calls, which are basically like having C calls inlined in your code)
07:02:19 <[exa]> funnel yay
07:02:36 <merijn> Peter123: unsafe FFI calls should have, like, a couple instructions overhead max
07:02:53 <Peter123> merijn: I could write the fast parallel sort and you could just *supervise* that I don't do some mistake
07:03:11 <Peter123> then the haskell world would have one thing less to worry about
07:03:22 <Peter123> because fast sorting does come up periodically
07:03:35 <merijn> Peter123: Also depends on the size of data you intend to sort
07:04:02 <merijn> Personally the existing sorts aren't up to scratch for the bigger datasets I want to sort
07:04:07 <Peter123> merijn: That is true! In Haskell, as the size goes to infinity, the O(n) sort pays off!
07:04:50 <merijn> Like, your benchmark results were 100s of ms? Not sure a parallel sort is remotely worth it there
07:05:07 <merijn> I have data where C++'s std::sort takes a few minutes to complete :)
07:05:30 <Peter123> merijn: My sorts where about 100 *Microseconds*  (1/1000 000 * 100)
07:05:46 <merijn> right
07:05:51 <Peter123> merijn: I have benchmarked std:sort and it was very slow
07:05:57 <merijn> So, parallel sort would be pointless
07:06:06 <merijn> Peter123: How big is your dataset?
07:06:18 <merijn> i.e. how many numbers are you sorting and is it a static amount?
07:06:24 <Peter123> merijn: R had 3x the performance of C++; Julia had 9x the performance of C++.
07:06:40 <merijn> That...sounds like a shitty old STL version
07:06:51 <merijn> and/or shitty old compiler
07:07:06 <Peter123> I'm sorting in vector rasterization where I have a frame rate of 60 frames per second.
07:08:05 <Peter123> I have around 10ms (1/1000 * 10) to sort around 5000 to 1000 vectors that have 5000 elements.
07:08:13 <Peter123> The vectors change for each frame.
07:09:06 * hackage dictionaries 0.2.0.4 - Tools to handle StarDict dictionaries.  https://hackage.haskell.org/package/dictionaries-0.2.0.4 (zohl)
07:09:12 <merijn> Peter123: Also, is the mergesort in vector-algorithms a true mergesort (so starting at partitions of size 1?) If so you could gain speed by switching to better sorts for the last bit of the merge sort
07:09:25 <Peter123> merijn: My strategy was to split up the vector, sort in parallel the subparts and then merge the suparts again.
07:09:28 <merijn> Peter123: Something like starting with a sorting network for the raw data, then mergesorting the results
07:09:39 <Peter123> merijn: yes!
07:10:13 <Peter123> merijn: but the problem is that the "merge" part is very, very inefficient.
07:10:29 <merijn> How so?
07:10:29 <Peter123> merijn: also my handwritten 'merge' was very inefficient.
07:11:01 <merijn> So write a less inefficient one? ;)
07:11:22 <Peter123> merijn: yes! Any ideas how to do it?
07:11:47 <Peter123> merijn: (Because if I allocate a temp buffer, this takes time and GC time, etc.)
07:11:52 <merijn> Not really looked into it yet
07:11:58 <merijn> Peter123: You can merge in place
07:12:27 <merijn> Peter123: Paper I found on how to do in-place merge: http://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf
07:12:35 <Peter123> merijn: that is a good point.
07:14:15 <merijn> gah
07:15:00 <merijn> Does anyone know how I can control the labelling in heap profiles? The legend is squashing my graph
07:17:02 <Peter123> merijn: can I keep you updated about my progress?
07:17:09 <merijn> sure
07:19:52 <Peter123> merijn: how would I do that?
07:20:09 <merijn> I'm pretty much always here except weekends :p
07:20:22 <Peter123> merjin: okay! good to know!
07:24:22 <exio4> merijn: but it's saturday! how can you be here if we are on a weekend?
07:24:38 <merijn> exio4: Stress working >.>
07:26:01 <pk6vx0x2> merijn: sounds bad.
07:26:11 <merijn> pk6vx0x2: Paper deadlines and shit
07:27:06 * hackage toolshed 0.18.0.0 - Ill-defined library.  https://hackage.haskell.org/package/toolshed-0.18.0.0 (AlistairWard)
07:28:06 * hackage factory 0.3.1.4 - Rational arithmetic in an irrational world.  https://hackage.haskell.org/package/factory-0.3.1.4 (AlistairWard)
07:33:29 <Peter123> If anyone is interested. I wrote if there is a pattern defeating quicksort availiable in Haskell
07:33:30 <Peter123> https://www.reddit.com/r/haskell/comments/7q52b8/is_there_a_pdqsort_sort_variant/
07:34:24 <Peter123> It's just that Rust and Julia and also the good old R is just beating Haskell by far at the moment
07:34:56 <merijn> Peter123: Someone has to be the first person to implement these things ;)
07:35:36 * hackage fishfood 0.0.1.8, squeeze 1.0.4.16, regexdot 0.12.1.0, regexchar 0.9.0.16 (AlistairWard): https://qbin.io/h70lub4
07:39:18 <Peter123> merijn: This is really the extreme downside of CS and Haskell/FP. People only work alone or in groups of say 3 persons.
07:40:33 <merijn> Anyone have: 1) a cabal package with an executable they can compile and 2) a few seconds to test something for me?
07:42:26 <AndreasK> Peter123: I disagree. I think it's more likely that it seems like that because of the smaller user base
07:45:27 <widp> Is there I way I could do visual live-coding while using tidal?
07:45:36 <widp> *a way
07:47:28 <widp> I see this : https://github.com/sleexyz/hylogen
07:47:33 <widp> but I am new to haskell and I don
07:47:44 <widp> 't know if it could be used with tidal easily.
08:06:55 <ongy> Is there a way to get OVERLAPPING/OVERLAPPABLE to work if only the required instances are different, because I want the actual types to still be variable? Currently it tells me it's the same instance, but one is more specific, because it has another required class isntanciation
08:08:06 <geekosaur> that's not more specific
08:08:20 <geekosaur> contexts don't play a part in instance selection
08:09:08 <ongy> so I can't. that's annoying
08:09:19 <merijn> ongy: IfCxt ;)
08:11:25 <ongy> yea, probably.
08:47:13 <dingaling> I must not fear
08:55:24 <geekosaur> fear is the little mutation that leads to total impurity
08:55:51 <merijn> geekosaur: I dont do little mutation, I just do lots of it ;)
08:58:36 * hackage sessiontypes 0.1.2 - Session types library  https://hackage.haskell.org/package/sessiontypes-0.1.2 (ferdinandvw)
09:15:05 <s4ke> quick question: can i somehow import test code in another package?
09:15:29 <s4ke> i have a base package and i want to export some modules for reuse in other packages
09:15:33 <s4ke> test utils
09:32:20 <mniip> trying to make sense of the typing section for pattern synonyms
09:35:08 <mniip> it is assigned a pattern type of the form  pattern P :: CReq => CProv => t1 -> t2 -> ... -> tN -> t
09:35:14 <mniip> that type makes no sense
09:35:40 <mniip> is that really saying  CReq => t1 -> t2 -> ... -> tN -> CProv *> t
09:36:50 <mniip> no
09:36:53 <mniip> the opposite
09:38:19 <mniip> hmm
09:39:39 <mniip> okay so when the pattern is used as a constructor the two constraints are indeed union'd
09:41:39 <mniip> aha
09:41:46 <mniip> c => a -> b
09:41:48 <mniip> iso to
09:41:54 <mniip> (c *> a) -> b
09:42:00 <glguy> s4ke: what part don't you know how to do? Making a package? Depending on a package? Exporting a module?
09:42:03 <mniip> so really what we have here is
09:42:25 <mniip> CReq => (CProv *> (t1, t2, ..., tN) -> t
09:42:28 <mniip> CReq => (CProv *> (t1, t2, ..., tN)) -> t
09:42:32 <MarcelineVQ> what is this *>  I feel like I"ve asked that before
09:42:49 <s4ke> glguy: i have some tests in a Definition module. there i want to define utilities that i want to use in packages that depend on the Definition module
09:43:01 <s4ke> s/module/library
09:43:33 <mniip> data (c :: Constraint) *> (a :: *) where K :: c => a -> c *> a
09:44:12 <mniip> it's like => but with opposite variance
09:45:37 <MarcelineVQ> thank you, what is variance when talking about types?
09:45:52 <mniip> you know core, right?
09:46:42 <MarcelineVQ> Not well but I've met it
09:46:52 <mniip> I could answer in a very cryptic way!
09:47:18 <mniip> (c *>) is left adjoin to (c =>)
09:47:24 <mniip> anyway,
09:47:39 <mniip> c => a  is a function from the dictionary of c to a
09:47:49 <mniip> c *> a  is a pair of a dictionary of c, and an a
09:48:08 <mniip> so c => a "consumes" a c, while c *> a "provides" one
09:48:16 <MarcelineVQ> Oh that's quite clear, thanks again
09:49:33 <monochrom> It is related to: "every even number is bigger than 1" one way to write it is "for all n. even n implies n>1". "some even number is bigger than 1" one way to write this is "for some n. even n and n>1"
09:50:31 <mniip> I think the adjunction demonstrates that quite clearly :P
09:50:34 <monochrom> So when you make a forall statement with restriction, you use implication. And a forsome statement with restriction, you use conjunction.
09:51:46 <MarcelineVQ> that's very interesting
09:52:50 <monochrom> Conjunction is analogous to multiplication in many ways, so we chose the "*" in "*>".
09:53:18 <ReinH> Oh look Pi and Sigma types again
09:55:21 <monochrom> A pity Haskell tuple types are written like (X,Y). SML tuple types are written X*Y.
09:57:30 <hexagoxel> what is this: https://hackage.haskell.org/package/microlens-0.4.8.2/src/src/Lens/Micro/Extras.hs
09:58:06 <hexagoxel> file system corruption?
09:59:15 <geekosaur> looks more like someone accidentally created and saved. file contains two blank lines, exclamation point, and a <DEL>... like they created it by accident with line editing disabled or something
09:59:25 <MarcelineVQ> idris uses ** for sigmas, overloading * was probably a bridge too many
09:59:56 <s4ke> glguy: nvm using source-dirs : ../Definition/src/test
10:00:01 <s4ke> works
10:01:59 <dmwit> hexagoxel: Ouch, that's really bad.
10:02:24 <dmwit> I'll let #hackage know.
10:03:31 <hexagoxel> dmwit: might be upstream though?
10:03:49 <dmwit> Yes. Somebody (you, maybe...?) should let Artyom know as well.
10:04:15 <hexagoxel> it was already reported. i was just curious what kind of mistake might lead to this.
10:05:21 <dmwit> It's pretty crazy. It looks like a dump of some shell's history memory or something.
10:06:25 <hexagoxel> (it is also an interesting case where regular upper bounds don't help you, because it was only a C-component version bump..)
10:07:16 <dmwit> Yep. Perhaps the trustees can either remove the version outright or mark it as unbuildable in a way that cabal's solver can understand.
10:07:25 <hexagoxel> right
10:12:55 <dmwit> hexagoxel: #hackage informed me that the correct forum is github. https://github.com/haskell-infra/hackage-trustees/issues/123 now exists =)
10:19:33 <iqubic> What's going on here?
10:20:27 <Welkin> iqubic: you have entered the matrix
10:20:33 <iqubic> Cool.
10:25:14 <mniip> dmwit, that's a weird file indeed
10:28:33 <monochrom> Oh! I know! tar suffered a meltdown. TEE HEE HEE
10:31:04 <iqubic> Tar suffered a meltdown? OH NO.
10:31:10 <hexagoxel> that's spetreculation
10:31:23 <mniip> what intel do you have to confirm this
10:31:25 <hexagoxel> *spectreculation
10:31:35 <mniip> hexagoxel, pathetic
10:31:42 <mniip> spectre is named after "speculation"
10:32:15 <monochrom> haha
10:32:22 <hexagoxel> :p
10:33:05 <Welkin> and that terrible james bond film that came out a couple years ago
10:34:08 <hpc> there are some good vulnerability names in bond movies
10:34:12 <hpc> moonraker, goldeneye
10:34:47 <MarcelineVQ> christmas
10:35:29 <mniip> ugh, those people who are vulnerable to christmas
10:35:36 * hackage sbv 7.5 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-7.5 (LeventErkok)
10:36:40 * systemfault uses christmas, it's super effective!
10:51:36 * hackage data-dword 0.3.1.2 - Stick two binary words together to get a bigger one  https://hackage.haskell.org/package/data-dword-0.3.1.2 (MikhailVorozhtsov)
10:53:36 * hackage reddit 0.2.2.2 - Library for interfacing with Reddit's API  https://hackage.haskell.org/package/reddit-0.2.2.2 (Intolerable)
11:16:14 <qmm> what are the cons to using rust? i imagine haskellers are using haskell instead of rust for a reason
11:19:13 <hpc> rust is still fundamentally an imperative language
11:19:33 <hydraz> rust doesn't let me play with fancy types
11:19:36 <hpc> and there's some properties of the borrow checker that hurt equational reasoning
11:19:39 <hpc> and that
11:20:12 <liste> rust and haskell are two quite different languages for somewhat different purposes
11:20:18 <hpc> in general in haskell, you can substitute (let f = whatever in f x) with (f x), and with whatever the result of (f x) happens to be
11:20:37 <hpc> in rust, each of those has different memory characteristics
11:21:14 <widp> where does cabal keep extracted packages?
11:21:21 <widp> on linux.
11:21:43 <monochrom> Somewhere under $HOME/.cabal/packages
11:21:54 <widp> but those are tarred
11:22:13 <hydraz> somewhere under $HOME/.cabal
11:22:28 <monochrom> Oops I misread. Extract in a temp directory for building, then thrown away.
11:23:11 <widp> oh, so if the package came with examples etc.. I would have to re-extract it?
11:23:21 <widp> or is there some other way?
11:23:33 <monochrom> That depends on the package itself. There are two cases.
11:24:14 <widp> and those cases are?
11:24:15 <monochrom> 1. The author marks the example files as extra data files to be installed. Then it is kept under $HOME/.cabal/share
11:24:27 <monochrom> 2. The author doesn't. You're toasted.
11:24:34 <widp> ahh, thank you monochrom
11:25:29 <monochrom> Consider the "cabal get" command.
11:33:20 <dmwit> cabal unpack is even better.
11:33:57 <dmwit> No, wait, cabal unpack is better than cabal fetch.
11:34:01 <dmwit> I don't know what cabal get does.
11:34:16 <monochrom> unpack doesn't exist anymore
11:34:51 <dmwit> Okay! That makes cabal unpack worse than cabal get.
11:34:54 <monochrom> Probably "get" replaces "unpack"
11:35:34 <monochrom> They need to stop using meaningful-therefore-not-future-proof names and start using UUIDs.
11:36:16 <geekosaur> yes, it's just a rename
11:36:25 <monochrom> cabal 24680-XWPDO-C3PO2 unordered-containers
11:36:29 <glguy> Do it like Megaman
11:36:31 <glguy> cabal tool1
11:39:04 <hpc> monochrom: ridiculous, we need a config file
11:39:16 <hpc> $ cat ~/.cabal/config/commands
11:39:22 <hpc> 24680-XWPDO-C3PO2: install
11:39:38 <hpc> the default of course, would be
11:39:44 <hpc> 24680-XWPDO-C3PO2: 24680-XWPDO-C3PO2
11:39:52 <monochrom> :)
11:39:58 <widp> what are UUIDs and why are they better as commands?
11:40:05 <MarcelineVQ> sounds complicated, let the machines do the thinking:  cabal dothething
11:40:06 <monochrom> Future-proof.
11:40:14 <hpc> cabal dowhatimean
11:40:24 <glguy> Oh, then it could be like a game where as you explore the ecosystem you find new commands (thinking of a metroidvania) and as you find them you can add them to your own commands file
11:40:42 <glguy> cabal wall-jump
11:40:56 <hpc> glguy: every time you compile ghc you have a 20% chance to get a loot box
11:41:03 <monochrom> Notice that, for example, modern disk partition types are UUIDs, too.
11:41:04 <hpc> glguy: and if you pay to unlock it you might get a cabal command
11:41:27 <hpc> hoping for cabal install, tough you get cabal clean
11:41:46 <glguy> That would ensure that people got a sense of pride and accomplishment while using cabal
11:41:50 <lyxia> hpc: D: this makes me feel uneasy
11:41:55 <hpc> glguy: exactly
11:43:09 <hpc> this would of course, coincide with a rewrite using npm as the new backend
11:43:16 <hpc> and then when people complain, you only roll back one of them
11:44:13 <monochrom> Keep grinding GHC until you receive cabal install, or just pay up to get it immediately. I like this idea, this is a free-market self-adapting way to supersede "two different licenses and pricing, one for 'personal' use, one for 'commercial' use"
11:44:56 <MarcelineVQ> then you could use that extra money to pay the devs, that's how software dev works right?
11:45:04 <monochrom> Yeah!
11:50:43 <glguy> Did you get the new TypeFamilies DLC?
11:51:06 <ddellacosta> hello, I'm getting stuck on some very basic syntax in this verbose example of the monad instance implementation for State: https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State#Instantiating_the_Monad
11:52:11 <ddellacosta> I don't understand what the line starting with `q' s0` is doing. Is there partial application going on? Could that be re-written as an anonymous function with e.g. q' = \s0 -> ... ?
11:52:28 <ddellacosta> the concise example makes more sense and seems more clear to me to be honest!
11:52:39 <glguy> Yes, that's defining q to be a function that takes an argument named s0
11:52:41 <monochrom> No this is not partial application.
11:53:01 <glguy> It could be written as q' = \s0 -> ...
11:53:20 <glguy> but then you wouldn't use a "where" to define the extra variables because s0 would not be in scope in the where
11:53:45 <glguy> Just erase "yes" from my answer
11:54:42 <ddellacosta> okay, thanks glguy and monochrom. I've never seen that particular syntactic construction before.
11:55:22 <glguy> ddellacosta: You've probably seen it lots of times, for example the definition of return just above the one you're asking about
11:55:53 <monochrom> "q' s0 = blah" is just the same syntax as "f x = x+x"
11:56:36 * hackage fast-arithmetic 0.3.0.1 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.3.0.1 (vmchale)
11:56:41 <ddellacosta> okay, I think the problem is that I wasn't seeing the connection between that syntax (especially in the context of `where`) and standard function definition syntax. Thanks monochrom, that helped it click for me.
11:58:11 <ddellacosta> I suppose what surprised me was being able to use it within a `where` term--I suppose I had internalized at some point that it was only allowed on top level function definitions
12:13:16 <merijn> ddellacosta: Other fun fact, you can actually have arbitrarily complex pattern matches at the top level :)
12:14:10 <ddellacosta> merijn: meaning, as long as it resolves into a viable pattern you can do all kinds of insanity within the pattern match itself? Not sure if I'm putting that the right way
12:15:06 <merijn> ddellacosta: So this "Just Works": http://lpaste.net/361617
12:16:15 <ddellacosta> ah, I see. Thanks for the example merijn!
12:16:39 <ddellacosta> that particular example reminds me of Clojure vector destructuring
12:16:44 <mud> Yeah you don't see that kind of thing very often, but it can be quite handy.
12:19:37 <monochrom> I used a record pattern binding at the top level in https://wiki.haskell.org/Parsing_expressions_and_statements#Make_token_parser
12:20:02 <monochrom> Marvel at how the LHS pattern is 10 times longer than the RHS term!
12:20:42 <ddellacosta> looks like it could be handy, never seen that
12:38:47 <mmaruseacph2> could also be less verbose with -XRecordWildCards
12:39:17 <monochrom> Not useful when I want top-level names.
12:41:03 <mmaruseacph2> oh, that's cool
12:58:36 * hackage hspec-dirstream 0.3.0.0 - Helper functions to simplify adding integration tests.  https://hackage.haskell.org/package/hspec-dirstream-0.3.0.0 (vmchale)
13:07:48 <Zemyla> Why don't more Traversables specialize Traversing on ->?
13:07:58 <Zemyla> :t (\f m e -> fmap (\a -> f a e) m) `asTypeOf` traverse
13:08:00 <lambdabot> Traversable f => (t1 -> t2 -> b) -> f t1 -> t2 -> f b
13:08:14 <gentooist> > foldr (\a b -> f a : b) [] :: Expr
13:08:19 <lambdabot>  error:
13:08:19 <lambdabot>      • Couldn't match expected type ‘Expr’
13:08:19 <lambdabot>                    with actual type ‘[()] -> [a0]’
13:08:47 <gentooist> > foldr (\a b -> f a : b) [] [1,2,3,4,5,6] :: Expr
13:08:51 <lambdabot>  error:
13:08:51 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘[a0]’
13:08:51 <lambdabot>      • In the expression:
13:08:55 <Zemyla> :t f
13:08:57 <lambdabot> FromExpr a => a
13:09:12 <Zemyla> I have no idea what FromExpr is.
13:10:08 <gentooist> > foldr (\a b -> f a : b) [] [1,2,3,4,5,6]
13:10:12 <lambdabot>  error:
13:10:12 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M104823791652...
13:10:12 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
13:10:38 <MarcelineVQ> > foldr (\a b -> f a : b) [] [1,2,3,4,5,6] :: [Expr]
13:10:41 <lambdabot>  [f 1,f 2,f 3,f 4,f 5,f 6]
13:11:37 <gentooist> MarcelineVQ: thanks :-) but i want it to make me all the parenthesis
13:11:41 <gentooist> how do i do that?
13:11:48 <MarcelineVQ> > foldr f z [a,b,c]
13:11:52 <lambdabot>  f a (f b (f c z))
13:12:02 <gentooist> MarcelineVQ: Great!
13:12:18 <gentooist> thank you :)
13:12:37 <gentooist> can't i do it with lambda function?
13:13:34 <MarcelineVQ> not sure f z a b c .. are special things called Expr from the simple-reflect package
13:13:38 <MarcelineVQ> there's also reduce/reduction
13:13:44 <MarcelineVQ> > reduce (sum [1,2,3])
13:13:48 <lambdabot>  1 + 2 + 3
13:13:50 <MarcelineVQ> > reduction (sum [1,2,3])
13:13:54 <lambdabot>  [0 + 1 + 2 + 3,1 + 2 + 3,3 + 3,6]
13:14:53 <MarcelineVQ> but if you're asking for a way to do it more generally Cale had something kicking around, maybe I​ can find it
13:15:23 <gentooist> thanks :)
13:16:11 <gentooist> > foldr (\a b -> f a : b) z [c,d,e,f,g] :: Expr
13:16:14 <lambdabot>  error:
13:16:14 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘[a0]’
13:16:14 <lambdabot>      • In the expression:
13:16:43 <gentooist> > foldr f z [c,d,e,f,g] :: Expr
13:16:45 <lambdabot>  f c (f d (f e (f f (f g z))))
13:16:58 <gentooist> > foldl f z [c,d,e,f,g] :: Expr
13:17:02 <lambdabot>  f (f (f (f (f z c) d) e) f) g
13:17:14 <MarcelineVQ> https://wiki.haskell.org/Fold examples section here has some ways to show fold steps
13:17:44 <gentooist> thank you. i'll look into it :)
13:18:19 <MarcelineVQ> if you're interested in what this Expr thing is there's a page on it here https://twanvl.nl/blog/haskell/simple-reflection-of-expressions
13:20:43 <ongy> is there a user-definable well known Coerceable class so I don't have to make up new names for all 1<>1 conversions?
13:21:57 <MarcelineVQ> is Data.Coerce not appropriate?
13:22:42 <gentooist> MarcelineVQ: thank you very much :-)
13:22:59 <MarcelineVQ> *Are you aware of Data.Coerce and if you are is it not suitable?
13:23:27 <ongy> Data.Coerce docs tell me I can't define the instances myself, but I have to rely on compiler auto-generated ones
13:23:38 <geekosaur> what are you trying to do?
13:24:04 <merijn> ongy: What's the problem with letting the compiler generate them?
13:24:45 <ongy> I should try if it can, but it's 2 distinc ADTs
13:25:34 <gentooist> > foldr (\x y -> concat ["(f ",x," ",y,")"]) "z" (map show [1..5]) :: Expr
13:25:39 <lambdabot>  error:
13:25:39 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘[Char]’
13:25:39 <lambdabot>      • In the expression:
13:25:52 <ongy> yea, the compiler can't create it for me
13:26:05 <Zemyla> ongy: If they're two different data structures, then they aren't coercible.
13:26:11 <gentooist> > foldr (\x y -> concat ["(f ",x," ",y,")"]) "z" (map show [1..5]) :: [Expr]
13:26:14 <lambdabot>  error:
13:26:14 <lambdabot>      • Couldn't match type ‘Char’ with ‘Expr’
13:26:14 <lambdabot>        Expected type: [Expr]
13:26:18 <MarcelineVQ> gentooist: read the error :>
13:26:28 <geekosaur> gentooist, Expr doens't work that way
13:26:39 <geekosaur> it is not magical incantation for "show me what this looks like symbolically"
13:27:11 <geekosaur> you get that from the predefined names f, g, h (functions) + other single character names (values)
13:27:14 <hnoob> how do i log to file inside a mtl stack? should the logging to the file be a WriterT ?
13:27:22 <ReinH> :t f
13:27:22 <geekosaur> the type ascription just helps it deal with things like Foldable
13:27:24 <lambdabot> FromExpr a => a
13:27:38 <geekosaur> iirc FromExpr is a hack so it can "show" a function
13:27:40 <ongy> I could unsafeCoerce them... Zemyla that's why I can't use Data.Coerce, but both of them are 2 (+ undefined) inhabitant ADTs that map to a C enums, which do make sense to convert one into the other. I just don't want to make up a bunch of names, but looks like I got to
13:27:49 <Zemyla> Though, merijn, I wish there were a standard form for a proof that a type "f" is representational in a certain argument, so I could take a proof that Coerce a b => Coerce (f a) (f b) and turn it into a proof that Coerce a b => Coerce (X f a) (X f b).
13:28:02 <ReinH> There's no actual difference between f and x iirc, we just like to use f for functions and x for (non-function) values.
13:28:05 <moriarty> so is anyone here developing for cardano?
13:28:50 <MarcelineVQ> ReinH: there is a difference
13:29:15 <ReinH> Ah yes, indeed.
13:29:17 <ReinH> :t x
13:29:19 <lambdabot> Expr
13:35:01 <ReinH> hnoob: do you want to log to a file or do you want to prepare something to be logged to a file later?
13:35:14 <moriarty> finally haskell has its own cryptocurrency
13:35:16 <moriarty> :-) cardano
13:36:22 <hnoob> @reihn: log to a file. What is the best approach? I was going to write inside io.
13:36:22 <lambdabot> Unknown command, try @list
13:36:58 <hnoob> reinh: log to a file. What is the best approach? I was going to write inside io.
13:37:21 <ReinH> If you want to do IO (like writing to a file), the base of the stack has to be IO and you can use liftIO.
13:37:43 <gentooist> geekosaur: it is not magical incantation for "show me what
13:37:44 <gentooist>                   this looks like symbolically" :: SAD :-)
13:38:32 <hnoob> reinh: thanks. Also, have you used io-streams or machines : any recommendations?
13:38:45 <ReinH> You could also consider something like @hoogle monad-logger
13:38:49 <ReinH> er, @hackage monad-logger
13:38:51 <hnoob> reinh: i will simply log with liftio.
13:38:53 <ReinH> Ok fine it has to be
13:38:57 <ReinH> @hackage monad-logger
13:39:00 <lambdabot> http://hackage.haskell.org/package/monad-logger
13:39:25 <ReinH> I think conduit and pipes are the most commonly used streaming libraries.
13:39:36 * hackage sessiontypes-distributed 0.1.1 - Session types distributed  https://hackage.haskell.org/package/sessiontypes-distributed-0.1.1 (ferdinandvw)
13:41:19 <hnoob> reinh: thanks again. I will review their docs and learn how to use conduit.
13:43:42 <MarcelineVQ> ReinH: machines is getting popular
13:43:49 <ReinH> Cool.
13:44:06 <ReinH> conduit and pipes still probably have the ecosystem advantage
13:45:41 <d-fish> When does the Boston Haskell meetup usually happen? I can't find any upcoming meetups
13:54:36 * hackage microlens 0.4.8.3, microlens-th 0.4.1.3 (Artyom): https://qbin.io/zu5o9t8g4
14:02:30 <exio4> are there meetups in netherlands/finland/germany in february/march?
14:26:19 <mark__> Hi guys so I'm learning haven't actually done that much coding yet but I was reading about function composition and I had a question. Before I write the code how do i format code in IRC
14:26:32 <mark__> *learning haskell
14:26:40 <xacktm> past a whole block of code on a paste site, like http://lpaste.net
14:27:08 <Welkin> take a breath mark__
14:27:15 <Welkin> use some punctuation, too
14:27:24 <hpc> the occasional line pasted directly is fine as well
14:27:47 <hpc> > words "and you can use lambdabot to evaluate one-liners"
14:27:51 <lambdabot>  ["and","you","can","use","lambdabot","to","evaluate","one-liners"]
14:29:32 <nisstyre> mark__: for longer things I recommend gist.github.com (also you might as well make a Github account)
14:29:47 <nisstyre> it's cool you're learning Haskell!
14:31:53 <mark__> nisstyre: yeah I have a github account idk i already done it on pastebin https://pastebin.com/weUFbXS0
14:32:43 <nisstyre> gist is very useful
14:32:54 <nisstyre> and much nicer than pastebin in my humble opinion
14:33:17 <Welkin> pastebin is icky
14:33:21 <Welkin> use lpaste
14:33:46 <mark__> nisstyre: no i agree completely lol it's just the first thing that came into my head :) and i had the site open already.
14:33:47 <Welkin> github gist is fine too if you want to keep track of all your pastes
14:34:10 <nisstyre> yeah it's fun to go back and look at stuff you wrote 5 years ago
14:34:20 <Welkin> nisstyre: tongue in cheek?
14:34:28 <nisstyre> nope
14:34:30 <Welkin> by some definition of "fun"
14:34:37 <Welkin> more like embarassing
14:34:39 <nisstyre> I mean you might either cringe or get new ideas from old ideas
14:34:44 <nisstyre> in my case it's both
14:34:52 <nikivi> Hey guys
14:34:53 <mark__> um so lol any ideas on the code I sent?
14:34:54 <nikivi> I am coming to Haskell from Go
14:34:56 <Welkin> I suppose I agree
14:35:08 <nikivi> Want to learn the functional paradigm mostly
14:35:09 <nikivi> https://github.com/data61/fp-course
14:35:16 <nikivi> Is this a good course, anyone done it?
14:35:19 <parosh> > foldr f z [1..10] :: Expr
14:35:19 <hydraz> :t (square .) . (+) -- mark__
14:35:20 <Welkin> I wrote some pretty crazy code years ago, and looking at it now can't figure out how I came up with such an idea
14:35:21 <lambdabot> Num c => c -> c -> c
14:35:22 <nisstyre> mark__: you can't have an expression like that at the top-level scope of your program
14:35:22 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 z)))))))))
14:35:34 <parosh> > foldr f z [1..10] :: Expr
14:35:40 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 z)))))))))
14:35:59 <parosh> > foldr f z [1..10] :: [Expr]
14:36:02 <lambdabot>  error:
14:36:02 <lambdabot>      • Couldn't match expected type ‘[Expr]’ with actual type ‘Expr’
14:36:02 <lambdabot>      • In the expression: foldr f z [1 .. 10] :: [Expr]
14:36:21 <nisstyre> mark__: what was the error you got though?
14:37:17 <mark__> hydraz: what if i wanted to use the method add not just the operator? since it seems you cant do this with methods that have more than one argument
14:37:25 <mark__> nisstyre: im running main from the console
14:37:26 <nisstyre> mark__: it might be helpful to look at the type of (.)
14:37:29 <nisstyre> :t (.)
14:37:31 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:37:43 <hydraz> :t add -- mark__
14:37:45 <lambdabot> Num a => a -> a -> a
14:37:46 <hydraz> :t (+)
14:37:48 <lambdabot> Num a => a -> a -> a
14:38:03 <nisstyre> it's expecting you to give it two functions that take one parameter
14:38:20 <nisstyre> you're trying to pass add which has the type Num a => a -> a -> a
14:38:57 <nisstyre> so if you were to pass one parameter to that you'd get (a -> a)
14:39:42 <nisstyre> > let f x = x + 1; g x = x * x in f . g $ 3
14:39:46 <lambdabot>  10
14:42:09 <parosh> > foldr f z [1..10] :: [Expr]
14:42:12 <lambdabot>  error:
14:42:12 <lambdabot>      • Couldn't match expected type ‘[Expr]’ with actual type ‘Expr’
14:42:12 <lambdabot>      • In the expression: foldr f z [1 .. 10] :: [Expr]
14:42:18 <parosh> > foldr f z [1..10] :: Expr
14:42:22 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 z)))))))))
14:42:49 <parosh> > foldr f z [1..10] :: Expr
14:42:52 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 z)))))))))
14:43:08 <parosh> > foldl f z [1..10] :: Expr
14:43:11 <lambdabot>  f (f (f (f (f (f (f (f (f (f z 1) 2) 3) 4) 5) 6) 7) 8) 9) 10
14:43:16 <mark__> nisstyre: and hydraz lol im quite confused. especially lol because IRC (personally hard to read) could you explain again.
14:44:00 <nisstyre> mark__: which part are you confused about? the syntax?
14:44:18 <nisstyre> what I did just defines two functions f and g
14:44:23 <nisstyre> each one takes a single argument
14:44:38 <nisstyre> then it composes them to produce a function that squares a value and adds 1 to it
14:45:14 <nisstyre> f . g $ 3 is the same as doing let h = f . g in h 3
14:45:50 <mark__> ok no forget that bit for a minute.
14:45:58 <mark__> [22:37] <nisstyre> it's expecting you to give it two functions that take one parameter [22:37] <nisstyre> you're trying to pass add which has the type Num a => a -> a -> a
14:46:15 <dmwit> f . g = \x -> f (g x)
14:46:26 <dmwit> Therefore:
14:46:32 <dmwit> square . add = \x -> square (add x)
14:46:46 <nisstyre> yes
14:46:57 <nisstyre> technically doing f (g x) is also referred to as function composition
14:47:01 <dmwit> Since we want it to take two arguments, we then would add an equation:
14:47:13 <dmwit> square . add = \x -> square (add x) = \x y -> square (add x) y
14:47:26 <dmwit> This last thing is not the same as \x y -> square (add x y), and that is your problem.
14:48:08 <dmwit> However, we can work the other direction.
14:48:28 <dmwit> \x y -> square (add x y) = \x y -> square ((add x) y) = \x -> square . add x
14:48:41 <dmwit> If we want to eliminate the other x, we must do some gymnastics.
14:49:12 <dmwit> Namely: we must recognize that `f . g` is actually the application of the function `(.)` to `f` and `g`, just with some nice sugar. So:
14:49:31 <dmwit> \x -> square . add x = \x -> (.) square (add x) = \x -> ((.) square) (add x)
14:49:40 <dmwit> Now this is in the form of the definition of composition, so
14:49:55 <dmwit> \x -> ((.) square) (add x) = ((.) square) . add
14:50:31 <dmwit> Now I will stop typing for a while. Please ask questions about the first part of this exposition that confuses you.
14:50:59 <mark__> My reply will probably disappoint you but I genuinely feel I haven't got enough haskell knowledge to understand what your explaining.
14:51:11 <mark__> lol I thought it was just a matter of syntax to be able to do what i wanted.
14:51:18 <dmwit> I am not disappointed. Start from the top, and point to the very first thing that you don't understand.
14:51:24 <nisstyre> mark__: . is just another function
14:51:34 <mark__> no i get that as in
14:52:04 <mark__> first 5 lines in pastebin I understand how function composition works
14:52:33 <mark__> addsq = square . add
14:52:36 <mark__> why is that not valid
14:53:07 <dmwit> Because `square . add` is the same as `\x y -> square (add x) y`, which is not the same as `\x y -> square (add x y)`.
14:53:14 <nisstyre> basically because it's expecting add to return an Integer and you're actually returning another function
14:53:38 <mark__> dmwit THAT MAKES SENSE :)
14:53:43 <mark__> finally lol progress
14:53:50 <nisstyre> when you do (add x) it returns another function
14:54:00 <dmwit> 14:46 < dmwit> square . add = \x -> square (add x) = \x y -> square (add x) y
14:54:00 <dmwit> 14:47 < dmwit> This last thing is not the same as \x y -> square (add x y), and that is your problem.
14:54:02 <nisstyre> all functions do that if they take more than one param
14:54:06 <dmwit> mark__: ^^ =P
14:55:20 <dmwit> mark__: I do encourage you to read my messages again, slowly, from the top. This style of reasoning (so-called "equational reasoning") is very common in Haskell both for refactoring and for debugging.
14:56:21 <Welkin> so is the process of programming also known as "bugging" then?
14:56:23 <mark__> dmwit i'll try. (that program i just wrote is basically my first so it's a bit odd)
14:56:25 <parosh> dmwit: i think i'll also read it. i'm a little confused now :-)
14:56:37 <nisstyre> mark__: you're off to a pretty solid start IMO
14:56:42 <dmwit> parosh: I welcome your questions, too. =)
14:56:43 <nisstyre> if that was your first program
14:59:53 <nisstyre> mark__: I'd encourage you to pay attention to type errors even if they seem confusing at first
15:00:10 <nisstyre> don't just jump straight to changing the code, but try to understand what it's actually saying
15:00:35 <geekosaur> Welkin, that joke's older than I am >.>
15:00:44 <nisstyre> that is often much easier if you have the type signatures written out too
15:00:49 <nisstyre> which you did
15:01:03 <Welkin> the codeless code
15:02:28 <parsnip> okay, the hard-headed is trying to hobby in haskell again.
15:02:43 <parsnip> is building on 1GB ram still a pain?
15:02:49 <MarcelineVQ> yes
15:03:00 <Welkin> you need at least 64 GB
15:03:02 <parsnip> halcyon is some magic bullet?
15:03:04 <parsnip> lol
15:03:18 <parsnip> i think you need 4GB of ram
15:03:20 <MarcelineVQ> well, plenty of dependencies can be an issue with just 1G, your own stuff probably won't get up there
15:03:21 <nisstyre> parsnip: that sounds excruciating to try and do anything with
15:03:29 <Welkin> 2 GB is the minimum if I remember correctly
15:03:33 <nisstyre> you might be fine *running* compiled code there but compiling it will suck
15:03:40 <nisstyre> maybe you should try Erlang instead ;)
15:03:45 <Welkin> yes, to compile base
15:03:54 <parsnip> yeah, maybe i have to compile in virtualbox.
15:04:00 <Welkin> doing haskell development on a vps is not going to be fun
15:04:09 <Welkin> develop locally and deploy remote
15:04:17 <Welkin> then you can run on a 512 MB box just fine
15:04:29 <parsnip> so develop in macos, compile in virtual box, and push to vps.
15:04:38 <Welkin> ah, yeah
15:04:41 <parsnip> :(
15:04:42 <Welkin> that is an issue I have too
15:04:44 <nisstyre> yeah I wouldn't recommend having "build on VPS" as your deploy strategy
15:04:53 <MarcelineVQ> why is virtual box in there
15:04:58 <Welkin> I just use a separate computer to pull my code from git and compile locally, then push up to the server
15:05:10 <MarcelineVQ> rarther, if you have a 1g limit how is a vm helping
15:05:12 <parsnip> are macos compiles runnable on ubuntu?
15:05:16 <Welkin> you could also have a vps that is sleeping and starts up when you need it that has adequate ram
15:05:23 <monochrom> Because has mac but targets linux.
15:05:26 <nisstyre> parsnip: you could build it in docker or something
15:05:44 <MarcelineVQ> ah hmm
15:05:45 <parsnip> yep, i can do docker, but that uses virtualbox for example.
15:05:53 <Welkin> the best way it works for me is to use two computers for the workflow
15:05:55 <nisstyre> yeah but it's at least possible to use other backends
15:05:59 <parsnip> yes
15:06:04 <nisstyre> and you can automate it
15:06:07 <monochrom> And perhaps the real question is "how much memory do I tell virtualbox to use".
15:06:16 <Welkin> develop on any system you want (in my case, on mac) then pull from git on a linux machine, compile, and push
15:06:45 <Welkin> deploying to the server is not something I do every day at least
15:06:55 <Welkin> even if you did this once a day, or a couple times a day, it should be no problem
15:06:58 <nisstyre> yeah but it's good to make it as frictionless as possible
15:07:04 <nisstyre> that way you can quickly iterate on it
15:07:25 <Welkin> I don't see how deploying to the server has anything to do with iterating quickly
15:07:36 <Welkin> you deploy the code when it's done
15:07:38 <nisstyre> easily pushing to production means you can easily push new features or fix bugs
15:07:41 <Welkin> not when it is in development
15:07:43 <nisstyre> when is it done?
15:08:05 <parsnip> well, if i want to see what it feels like on phone, i'll need it on a VPS
15:08:16 <nisstyre> not necessarily
15:08:20 <Welkin> parsnip: access it on your local network
15:08:26 <parsnip> hmm
15:08:30 <nisstyre> you don't even need that if you're on android
15:08:37 <parsnip> yep, android
15:08:41 <Welkin> either way, I thik using 2 computers that are sitting beside each other is as frictionless as deploying from the same machine
15:08:50 <Welkin> it's only one extra step (pull from git)
15:08:51 <nisstyre> you can do a trick with adb to make it access localhost
15:08:57 <nisstyre> I forget exactly how
15:09:25 <nisstyre> https://stackoverflow.com/questions/4779963/how-can-i-access-my-localhost-from-my-android-device
15:09:33 <Rembane> Computing in high definition stereo.
15:09:52 <nisstyre> adb reverse tcp:4000 tcp:4000
15:10:01 <Welkin> you don't even need any of that
15:10:08 <Welkin> get your ip address for your machine on your local network
15:10:11 <Welkin> then type that in with the port
15:10:12 <Welkin> done
15:10:18 <Welkin> use `ifconfig`
15:10:20 <nisstyre> yeah you can do that too
15:10:34 <nisstyre> if you're on a mac you probably also have bonjour setup
15:10:42 <nisstyre> so you can just use the hostname
15:10:42 <Welkin> I did that all the time when developing with iOS mobile in mind
15:11:06 <monochrom> Apply lubricants to the wheels and joints of your chair to minimize friction between two computers. Plus it'll make https://xkcd.com/303/ so much more fun. :)
15:11:17 <Rembane> And make sure that the server binds to all interfaces.
15:11:24 <Rembane> monochrom: That's the best tip of today!
15:11:37 <MarcelineVQ> and attract dust into the wheels and joints of your chair so that it gets worse faster :>
15:11:52 <nisstyre> monochrom: I would say I spend at least half my time just staring at ansible output tbh
15:12:04 <nisstyre> 10 minute long playbooks and all that
15:12:10 <parsnip> ha, you admit, you don't use propellor!
15:12:14 <Welkin> I used to use ansible
15:12:17 <Welkin> then my contract ended
15:12:19 <Welkin> no more!
15:12:24 <nisstyre> contract for what?
15:12:27 <Welkin> a job
15:12:29 <nisstyre> ah
15:12:37 <nisstyre> well, I don't mind it, but it's really inflexible sometimes
15:12:40 <MarcelineVQ> "Now I'm a bash master... Thank you, Satan!"
15:12:45 <Welkin> I'd probably go for nixops
15:12:49 <nisstyre> I'd prefer an actual DSL
15:12:52 <Welkin> I love using keter for app deployment
15:12:52 <nisstyre> rather than YAML
15:12:57 <Welkin> it's incredibly easy
15:13:00 <nisstyre> but I didn't decide to use it
15:13:47 <Welkin> I don't need to deploy or make changes to my server often if at all
15:14:07 <Welkin> but deploying apps is very common, so pretty much all I need is keter
15:14:23 <Welkin> I have gotten used to manually setting up my servers once, then don't touch them for a long, long time
15:14:38 <iqubic> Welkin: How many servers do you have?
15:14:42 <Welkin> a few
15:18:21 <parsnip> hmm, maybe it wouldn't be too hard to just write haskell in one place, have docker act on it, and if it works, push the executable that's there.
15:19:17 <parsnip> just an scp for now, to get started.
15:19:20 <Welkin> I compile, zip up into a format keter knows how to use, then scp it to the server
15:19:22 <Welkin> simple
15:19:31 <Welkin> all done with a tiny bash script
15:19:45 <Welkin> actually, I made it a little better
15:20:00 <Welkin> it pulls from git, compiles, bundles, then scp's to the server all in one script
15:20:16 <Welkin> ./deploy-production is all you need then
15:21:08 <Welkin> keter handles it on the server side. It unpacks the bundle, starts up the application, checks to make sure it is working properly, then switches the reverse proxy over to the new app and kills the old one
15:24:51 <mark__> nisstyre:  ty :) and dmwit yes it makes sense i understand although im not sure its one of those things
15:24:56 <mark__> i would say i would be able to do myself
15:25:27 <nisstyre> mark__: just keep at it, it might take a while before it starts to click
15:25:51 <nisstyre> it took me a while to figure out how things fit together
15:26:15 <mark__> i will :) lol coming from a Java background this is VERY different
15:27:16 <mark__> by the way i assume atleast someone here uses SublimeHaskell?
15:27:26 <mark__> *one person
15:28:29 <mark__> anyone?
15:29:22 <mark__> ok let me change question what do u guys develop in since there aren't any IDEs that are haskell only
15:29:31 <mark__> *many
15:30:01 <parsnip> emacs
15:30:14 <MarcelineVQ> the vocal majority use emacs or vim, some use atom or vscode or sublime, some people just use their most familiar text editor alongside ghci
15:30:49 <mark__> hm i tried using sublimehaskell since it would be nice to be able to compile inside sublime i felt there was a lot of overhead
15:30:58 <mark__> e.g i had to understand what cabal was ?
15:31:03 <mark__> i mean it started to work kind of
15:31:22 <mark__> i had to do cabal init but it felt like using it didnt have as much benefit/
15:33:17 <mark__> anyway thanks for the help guys have a good night (for uk anyway )
15:33:43 <Welkin> it's night in the US too! >:0
15:34:10 <Welkin> mark__: avoid IDEs
15:34:22 <Welkin> they are for people who can't think
15:34:36 <mark__> um thats quite a strong opinion
15:34:48 <Welkin> it's true
15:34:51 <mark__> not really
15:35:05 <Welkin> I use emacs with nothing but text highlighting, no auto complete, no special extensions
15:35:33 <mark__> i have nothing wrong with developing in a text editor onl;y
15:35:34 <Welkin> I started by programming haskell on paper
15:35:38 <Welkin> complete programs
15:35:49 <Welkin> it helped me immensely
15:35:58 <mark__> but IDEs save time using commandline personally i would rather have a command
15:36:04 <MarcelineVQ> not everyone will share that opinion, I can only reccomend you try a few things and do what fits you best
15:36:06 <mark__> that compiles and runs
15:36:13 <hydraz> cabal run?
15:36:20 <Welkin> I use my terminal emulator to compile
15:36:46 <Rembane> :r in cabal repl is nice imo
15:36:49 <Welkin> there are many extensions for emacs and vim that allow you to have a more IDE-like environment
15:36:59 * infinisil is using emacs and ghc-mod
15:37:08 <mark__> hydraz: sorry i meant um a shortcut
15:37:25 <Welkin> I personally don't use any
15:37:32 <mark__> I mean i know lol
15:37:33 <Welkin> I like the minimalism and less overhead
15:37:34 <mark__> i get it
15:37:37 <Welkin> forces me to stay sharp
15:37:39 <mark__> but like
15:37:44 <mark__> a shorcut is nicer.
15:38:12 <mark__> imho like everyones different sometimes i like using IDEs and sometimes I don't sometimes I use text editors.
15:38:33 <mark__> I used eclipse for ages I came ton IntelliJ and it was too different so I wasn't that into it
15:38:37 <mark__> to*
15:38:50 <Welkin> I imagine anyone coming from java will believe that IDEs are essential
15:38:57 <Welkin> but that is only because java is so terrible
15:39:16 <Rembane> Welkin: You're not making friends today, eh?
15:39:41 <Welkin> Rembane: :D
15:42:07 <parsnip> IDEs are for Java. nothing more.
15:42:30 <mark__> You heard of phpstorm? RubyMine ?
15:42:32 <mark__> Welkin: Im going now. think about this. you seem very confident that you know the *perfect* way of doing things. But sometimes ignorance is bliss. If I didn't know e.g how to use emacs efficiently then or a text editor but im used to an IDE then the most minimalist option is to use an IDE that I know. I may not use all the features. But the point is what's useful for you as a developer.
15:43:16 <Welkin> I know the best way for me to work, but everyone is different
15:43:45 <parsnip> i should be more serious.
15:43:52 <Welkin> the point I tried to get across is that an IDE is certainly not necessary, and can make it harder to get things done if you rely on all kinds of ntegrations for compilation, debugging, etc
15:43:58 <parsnip> IDEs are relatively necessary for Java.
15:44:23 <parsnip> for a lot of other languages, there's not much difference, use an editor or an IDE
15:44:25 <mark__> Welkin: you know how many times I use the debugger?
15:44:34 <mark__> about zero
15:44:40 <parsnip> one less reason
15:44:45 <mark__> genuinely i use an IDE as a text editor
15:44:51 <mark__> the main benefit is compiling in the window
15:45:20 <mark__> 3 features I use, refactoring variables, extract to methods, and search workspace. All of which can be done in sublime - a text editor.
15:47:17 <Rembane> I can't do any of those in vim. Hm...
15:47:26 <Welkin> Rembane: emacs
15:47:44 <Welkin> I have run vim inside emacs
15:47:47 <Welkin> and emacs inside emacs
15:48:00 <Welkin> emacs inception
15:48:02 <parsnip> oh they left. were they just running into cabal issues in sublime?
15:48:16 <parsnip> then work in terminal until you fix it.
15:48:33 <MarcelineVQ> mostly wondering whether they had to use cabal, an IDE would make the project for you
15:48:39 <Rembane> Welkin: Indeed, emacs is quite powerful. https://www.xkcd.com/378/
15:49:04 <Rembane> We should've told them that cabal is our ide.
15:49:13 <MarcelineVQ> but they got onto a tangent for some unknown and completely mysterious reason
15:50:27 <Rembane> Very strange indeed.
15:54:24 <parsnip> what is result of `sublime - a text editor`?
15:54:49 <MarcelineVQ> sublemon
15:54:54 <parsnip> chrome?
15:55:24 <Rembane> Supercitrus?
15:55:46 <parsnip> i know from my chemistry class that `atom - a text editor = electron`.
15:56:00 <Welkin> you mean chrome
15:56:13 <Welkin> apparently, since the spectre/meltdown patches, electron apps run like shit
15:56:47 <parsnip> schrodinger's text editor
15:56:59 <Rembane> electron - spectre = shit ?
16:13:48 <parosh> a
16:13:52 <theelous3> b
16:13:58 <parosh> >:-D
16:14:05 <theelous3> !logs
16:14:08 <theelous3> !log
16:14:13 <theelous3> wut
16:14:17 <theelous3> awh fuck
16:14:20 <parosh> just check if i'm online :-)
16:14:54 <parosh> > foldl f z [1..10] :: Expr
16:14:57 <lambdabot>  f (f (f (f (f (f (f (f (f (f z 1) 2) 3) 4) 5) 6) 7) 8) 9) 10
16:15:26 <theelous3> haha, oh man
16:15:34 <theelous3> I am not in the channel I thought I was in
16:15:48 <theelous3> went and restarted my bot because it didn't respond :/
16:17:16 <Gregor01> Quick question...
16:17:27 <Welkin> not a slow question?
16:17:51 <Gregor01> How do I program a list of lists representing a matrix such such that each element is a pair of the positions?
16:18:04 <Welkin> don't use lists for a matrix
16:18:08 <Welkin> use vectors or arrays
16:18:33 <parosh> Welkin: :)
16:18:55 <Gregor01> Eg. (0,0), (0,1),....(0,99),...,(1,0),(1,1),(1,3),....(99,99)
16:19:03 <Rembane> Gregor01: You can use (,) <$> [0..] <*> [0..]
16:19:17 <Rembane> Gregor01: Or a list comprehension if you prefer that.
16:19:18 <erisco> that won't have good results w/o OverloadedLists
16:20:08 <erisco> what does it mean for each element to be a pair of the positions? a position on a matrix is a 2-tuple, yes? and so a pair of positions would be a 2-tuple of 2-tuples
16:20:09 <Welkin> for multidimensional arrays, use Array
16:20:21 <Welkin> then you can use a tuple for the index
16:21:35 <Gregor01> Rembane: Thanks, that works!!
16:22:02 <Rembane> Gregor01: No worries.
16:23:49 <suzu> is there some easy way to work with nested Maps in some list monad esque fashion?
16:24:27 <erisco> > find ((==1) . fst) ((,) <$> [0..] <*> [0..])
16:24:29 <suzu> that is: i've made a "2d array" using a map within a map
16:24:34 <lambdabot>  mueval-core: Time limit exceeded
16:24:44 <Welkin> uh... what
16:24:57 <Welkin> you could use a single Map to have any dimension array you want
16:25:01 <Rembane> suzu: Why? Why not use a tuple for key and your data as a value?
16:25:03 <Welkin> use a tuple as the key
16:25:18 <Welkin> or just use a proper Array
16:25:27 <Welkin> where you can also use a tuple as the index
16:25:49 <suzu> hmm
16:26:36 <suzu> supposing i wanted to traverse the first index to find all pairs for the second index, would that be possible?
16:26:48 <suzu> if i had a singular key that is a tuple
16:28:13 <suzu> i suppose i can't efficiently do that. but my map is small and so that doesnt matter in this case
16:28:55 <heptahedron> Hello, could anyone tell me if the behavior in this snippet is a bug? https://gist.github.com/heptahedron/a70eb18c96680b09733fa846ffb2ad75 Reordering declarations causes typechecking to fail, and I've never seen that before
16:29:36 * hackage ats-format 0.1.0.28 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.28 (vmchale)
16:30:55 <MarcelineVQ> "-- but moving the declaration down here " which declaration
16:31:04 <MarcelineVQ> Oh I'm blind
16:31:08 <MarcelineVQ> :>
16:32:21 <heptahedron> MarcelineVQ: lol. But this is weird, right? That example was the boiled-down version, I was trying to accomplish something last night for hours and kept running into the strangest typechecking error, only to find that moving the data decl fixed it
16:33:02 <heptahedron> Oops I should have put the exact contents of the error in the gist, one sec
16:35:37 <MarcelineVQ> seems pretty weird
16:36:47 <erisco> it wants it before the declaration of C'
16:38:09 <parosh> > foldl f z [1..10] :: Expr
16:38:12 <lambdabot>  f (f (f (f (f (f (f (f (f (f z 1) 2) 3) 4) 5) 6) 7) 8) 9) 10
16:38:49 <erisco> I have no idea if it applies here but keep in mind that TypeInType results in an inconsistent type system
16:38:50 <lyxia> heptahedron: how are you compiling this
16:39:10 <heptahedron> lyxia: I've just been loading it in GHCi, let me look at the version
16:40:54 <heptahedron> lyxia: `The Glorious Glasgow Haskell Compilation System, version 8.2.2`
16:41:37 <erisco> GHCi 8.2.1 reproduces
16:41:48 <Welkin> it is autosexual?
16:41:56 <heptahedron> lol
16:42:03 <lyxia> I can't reproduce it with 8.2.2
16:42:03 <gentooist> what is autosexual?
16:42:23 <heptahedron> lyxia: what happens? does it typecheck both ways for you or do both fail?
16:42:32 <gentooist> foldl f z [1..10]
16:42:46 <gentooist> > foldl f z [1..10] :: Expr
16:42:47 <lyxia> oh wait nvm I can reproduce it
16:42:50 <lambdabot>  f (f (f (f (f (f (f (f (f (f z 1) 2) 3) 4) 5) 6) 7) 8) 9) 10
16:43:23 <gentooist> > foldl f z [1..10] :: Expr
16:43:27 <lambdabot>  f (f (f (f (f (f (f (f (f (f z 1) 2) 3) 4) 5) 6) 7) 8) 9) 10
16:43:54 <erisco> it isn't wholly clear to me if the correct behaviour is a compile error or not
16:44:31 <heptahedron> erisco: I don't think I knew that, but is the inconsistency purely from the fact that it could allow non-terminating/partial type functions? I don't think the way in which it's being used in this case is illogical but then again I'm fairly new to this level of programming
16:45:17 <erisco> heptahedron, it is because * :: * is known to cause inconsistency, and how that problem can manifest in Haskell programs I am not sure
16:46:16 <lyxia> inconsistency doesn't mean reordering declarations breaks your program
16:46:29 <erisco> merely moving a definition sounds suspect as a bug, but on the other hand there may be no reasonable solution to what you've constructed here. That is why I am not sure what the beheaviour should be yet.
16:46:40 <heptahedron> erisco: Do you have any sources where I could read more about that?
16:46:40 <gentooist>                                                                                                  /kill
16:47:18 <MarcelineVQ> heptahedron: the ghc manual :>
16:47:27 <MarcelineVQ> oh you mean the inconsistency specifically?
16:47:41 <heptahedron> MarcelineVQ: yes haha, but honestly that's probably a good idea too
16:48:27 <lyxia> heptahedron: that sounds like a bug to me in any case
16:50:03 <heptahedron> erisco: Do you think `TypeInType` is strictly necessary in order for a subclass' type family's parameter's kind to depend upon the superclass' type family like this? Would explicit kind annotations work? Again, I'm fairly new to this so I'm not entirely grounded w.r.t. the theory
16:50:59 <heptahedron> I didn't want to have to use a pointless superclass for the thing I was actually implementing that lead to me discovering this, but if I had both type families in the same class GHC complained because they were both 'part of the same recursive group'
16:51:19 <geekosaur> that suddenluy sounds like you are using TH somewhere
16:51:31 <geekosaur> and in that case, yes there will be issues with where definitions are
16:51:45 <MarcelineVQ> geekosaur: no TH here where I can reproduce the issue here with their example code
16:52:05 <zabornig> foldl f z [1..20]
16:52:12 <zabornig> > foldl f z [1..20] :: Expr
16:52:15 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f z 1) 2) 3) 4) 5) ...
16:52:28 <geekosaur> zabornig, you might want to learn about /query
16:52:46 <zabornig> what is /query?
16:52:56 <erisco> heptahedron, to use a type as a kind that is the extension you need
16:52:56 <heptahedron> zabornig: PMs for IRC
16:53:28 <lyxia> heptahedron: Inconsistency just means every type/kind is inhabited. But Haskell is already inconsistent so TypeInType doesn't break anything that's not already broken.
16:53:41 <erisco> heptahedron, it is essentially turning the type system into a dependently-typed programming language
16:53:46 <heptahedron> lyxia: that's comforting, haha
16:54:00 <heptahedron> erisco: Yeah I figured, but dependently-typed doesn't imply inconsistent does it?
16:54:12 <zabornig> i can have private "conversation" with lambdabot, using /query?
16:54:22 <erisco> no, it doesn't
16:54:41 <lyxia> zabornig: you can
16:55:07 <heptahedron> zabornig: And it works with rcirc!
16:55:25 <zabornig> can you please guide me how i do it?
16:55:31 <heptahedron> erisco: I mean Idris gets away with what is effectively TypeInType without being inconsistent (unless explicitly annotated) (afaik), does it just get to do that because it has a more sophisticated totality checker?
16:55:39 <heptahedron> zabornig: Just say `/query lambdabot`
16:55:40 <zabornig> example would be nice :-)
16:55:46 <zabornig> ah OK!
16:55:46 <erisco> but it doesn't get away with what is effectively TypeInType
16:55:57 <zabornig> thanks i'll try
16:56:07 <jle`> heptahedron: idris doesn't really have TypeInType ... you can't treat anything as a member of itself
16:56:48 <erisco> no one escapes the math!
16:57:59 <heptahedron> Okay, hold on--I wasn't saying that, at least I don't think--my understanding was that, while syntactically the type of types is Type in Idris, in the implementation it actually maintains a hierarchy of type-universes that is inferred at compile time
16:58:13 <zabornig> heptahedron: when i write /query lambdabit and press ENTER i get an error: Wrong type argument: listp, #<buffer @irc.freenode.net> [3 times]
16:58:13 <zabornig> Mark set
16:59:02 <heptahedron> zabornig: Are you entering that in the minibuffer? I meant enter that after the prompt in the rcirc buffer
16:59:04 <erisco> well… I am not sure typing in a syntactical sense has any sense, but yes :P
16:59:51 <heptahedron> erisco: I meant they are only apparently the same `Type` in that it is written as `Type` for every occurrence in Idris despite the fact that it's actually `Type 0`, `Type 1`, etc
17:00:34 <heptahedron> gentooist: To be clear, I meant you should write `/query lambdabot` in the rcirc buffer, the same way you're sending messages to this channel, not in the minibuffer where you enter commands like `write-file`
17:01:09 <zabornig> heptahedron: i has a misteke. i think it is working :-)
17:01:10 <geekosaur> heptahedron, haskell is not idris. there are no type universes. TypeInType collapses everything together into a single type level
17:01:21 <zabornig> *i had a mistake
17:01:36 <erisco> "it is actually" refers to "it means"
17:01:48 <heptahedron> geekosaur: Ah okay, that helps me understand more about the reason for the inconsistency that extension implies (despite the fact Haskell is already inconsistent), thanks!
17:02:20 <zabornig> heptahedron: yes it's working. thank you :-)
17:02:45 <heptahedron> erisco: I think we are in accord now, though I might have stumbled with the verbiage haha
17:02:56 <heptahedron> Is it weird I'm sort of excited to submit my first GHC bug report? Lol
17:04:06 * hackage Unique 0.4.7.2 - It provides the functionality like unix "uniq" utility  https://hackage.haskell.org/package/Unique-0.4.7.2 (kapral)
17:04:43 <Welkin> heptahedron: accord, verbiage
17:04:46 <Welkin> how diplomatic sounding
17:04:51 <zabornig> programming in haskell - graham hutton (2nd edition): is it good book to cover all haskell up to date?
17:04:52 <Welkin> are you by chance a politician?
17:06:19 <heptahedron> Welkin: I'm a 22-year-old recent CS bachelor's graduate lmao. I just like to try and be specific with my language
17:06:34 <heptahedron> you can imagine how I ended up in this channel
17:07:23 <geekosaur> zabornig, yes. although it does cover specifically standard haskell and not necessarily extensions like the TypeInType discussion that's going on here
17:07:45 <geekosaur> I don't know of any books offhand that cover ghc's type level programming extensions
17:09:15 <zabornig> geekosaur: thanks.
17:43:20 <Gregor01> Any one still up?
17:43:42 <Gregor01> Is there actually a library to benchmark C code?
17:43:50 <Gregor01> I mean somthing similar to 'cirterion'?
17:44:11 <Gregor01> I'm writing Haskell FFI code that calls C. I would like to benchmark my C code first.
17:44:32 <Gregor01> Theoretically, I could still use criterion. But I would prefer to use a C tool if such a thing exists.
17:55:17 <royal_screwup21> so I was looking at  a theoretical proof for when a functor obeys the functor laws and I saw this. https://prnt.sc/i04ojm I know the functor laws but I can't quite understand the inermediary steps. could someone walk me through it? :)
17:55:34 <lyxia> Gregor01: try asking on ##c
17:56:59 <lyxia> royal_screwup21: fmap id (Error s) = Error s   by the first clause in the definition of fmap
17:57:15 <lyxia> royal_screwup21: what is confusing about that
17:57:16 <royal_screwup21> hmm okay
17:59:11 <royal_screwup21> I mean it's trivial but how exactly did they arrive to that point? What's with all the {def. fmap} and {def id} and the 3 intermediate steps? Why didn't they just write in one line
17:59:59 <lyxia> the stuff in braces explains the step
18:00:16 <lyxia> {def fmap} means "by definition of fmap"
18:00:53 <lyxia> you could write it in one line if you wanted
18:01:38 <royal_screwup21> alrighty
18:07:57 <royal_screwup21> not sure I understand the underline line. How do we go from Error s to that line?
18:08:00 <royal_screwup21> https://prnt.sc/i04s5f
18:11:11 <lyxia> royal_screwup21: fmap h (Error s) = Error s,  set h = g . f
18:16:23 <pierrot> Hi. This module: https://hackage.haskell.org/package/chesshs-0.2.1/docs/Chess.html has some conceptual errors. The most important one is that `mate` function is wrong. It says that we're checkmated when our king is in check and he piece can't move. But that's wrong, because you can defend your king with a piece and that's not taking into account by that module.
18:17:40 <royal_screwup21> lyxia: just before underlined line, there's this step: fmap g (Error s) which becomes Error s. I get this. But Then that somehow turns into fmap (g o f) Error s. Not sure I understand that part
18:25:36 <d-fish> When's the next Boston-Haskell meetup? The proposed meetups page is blank
18:30:32 <glguy> pierrot: you should report report any bugs to the author
18:32:55 <mmaruseacph2> d-fish: used to be every third Wednesday of the month
18:32:58 <glguy> Also your interpretation of the logic seems wrong to me, it's checking that *no* piece can move and the king of under check
18:37:22 <lyxia> royal_screwup21: fmap h (Error s) = Error s    for all h. In particular, if  h = g . f   that yields  fmap (g . f) (Error s) = Error s   and by symmetry of equality   Error s = fmap (g . f) (Error s)
18:40:47 <pierrot> @glguy : yeah, that would be the correct interpretation if the `stalemate` function was implemented properly but... https://github.com/ArnoVanLumig/chesshs/issues/4
18:40:47 <lambdabot> Unknown command, try @list
18:40:52 <royal_screwup21> ah okay thanks for clarifying :)
18:41:32 <pierrot> stalemate doesn't check for real stalemate. is just verifies that the king can't move which is also wrong
18:41:39 <pierrot> it*
18:44:49 <pierrot> @glguy : I think you didn't read the code for the stalemate function when you said my interpretation was wrong
18:44:49 <lambdabot> Unknown command, try @list
18:48:01 <orion> What's the name of the extension which allows you to specify the type of a polymorphic function argument?
18:48:14 <glguy> TypeApplications
18:48:17 <orion> Thank you.
18:48:49 <glguy> pierrot: I just said the mate logic looks right. The stalemate logic might very well be wrong
18:49:57 <fro-969> ▄▄▄▄▄▄▄▄▄▄▄ TRELANE IS OFFERING FREE FELACIO CLASSES IN #FREENODE (FEEL FREE TO MESSAGE HIM AS WELL). mmjaw: mnoonan_ albertid__ antsanto ▄▄▄▄▄▄▄▄▄▄▄▄▄▄
18:49:57 <fro-969> ▄▄▄▄▄▄▄▄▄▄▄ TRELANE IS OFFERING FREE FELACIO CLASSES IN #FREENODE (FEEL FREE TO MESSAGE HIM AS WELL). hedfmxpysi: Gregor01 mnoonan_ xcmw ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
18:49:57 <fro-969> ▄▄▄▄▄▄▄▄▄▄▄ TRELANE IS OFFERING FREE FELACIO CLASSES IN #FREENODE (FEEL FREE TO MESSAGE HIM AS WELL). lqeczt: machinedgod cheater Johannes13__ ▄▄▄▄▄▄▄▄▄▄▄▄▄
18:49:57 <fro-969> ▄▄▄▄▄▄▄▄▄▄▄▄ TRELANE IS OFFERING FREE FELACIO CLASSES IN #FREENODE (FEEL FREE TO MESSAGE HIM AS WELL). ficuvywb: dysfun bogdanteleaga kuttifunk ▄▄▄▄▄▄▄▄▄▄▄
18:49:59 <fro-969> ▄▄▄▄▄▄▄▄▄▄ TRELANE IS OFFERING FREE FELACIO CLASSES IN #FREENODE (FEEL FREE TO MESSAGE HIM AS WELL). lkndkpkhc: beerdrop brent80_plow tippenein ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
18:50:15 --- mode: ChanServ set +o glguy
18:50:26 --- mode: glguy set +b *!*@177.158.221.228
18:58:30 <pierrot> @glguy : I don't think so. Even if `stalemate` was impelemented correctly, the condition for mate isn't "stalemate" && "king in check"
18:58:30 <lambdabot> Unknown command, try @list
18:58:42 <glguy> OK, sounds good
18:59:56 <pierrot> in most of checkmates, you have a piece that can make a move
19:00:05 <pierrot> and that condition would say that it's not checkmate
19:04:02 <pierrot> checkmate happens when: 1-your king is in check, 2-you can't move your king to a safe place (that's what the function `stalemate` of that modules does) and 3-there's no piece that can protect your king
19:04:23 --- mode: glguy set -o glguy
19:09:34 <ReinH> Stalemate happens when the player is not in check and has no legal moves. Checkmate happens what the player is in check and has no legal moves.
19:10:20 <ReinH> s/what/when
19:16:11 <pierrot> ReinH : yeah, but they're not legal moves because the king is in check but they'd be otherwise
19:16:24 <ReinH> Yes, they're not legal moves.
19:17:48 <ReinH> My point is both that it's easier to make a slightly smarter legal move detector and only have two things to test in your "is the game over?" checker, and also that this is the official definition of checkmate.
19:20:20 <ReinH> case (isInCheck, hasLegalMoves) of { (_, True) -> Nothing; (True, _) -> Just Checkmate; (False, _) -> Just Stalemate; }
19:21:58 <pierrot> ReinH : yeah, that looks fine
19:41:49 <exio4> in what situation could you be left without legal moves and the king is not in check?
19:42:05 <NextHendrix> ie if king only piece left and can only move into check
19:42:12 <exio4> ah
19:42:15 <NextHendrix> or all other pieces are blocked
19:42:32 <NextHendrix> or if material becomes insufficient to checkmate
19:42:56 <NextHendrix> also perpetual check
19:43:30 <NextHendrix> if i can force your king to constantly have to go between two spaces by checking every time to infinity, then its a draw
19:44:47 <exio4> but that's agreed upon, or how do you detect it?
19:47:50 <parsnip> threefold repetition of a position
19:48:23 <parsnip> "The rules allow for several types of draws: stalemate, threefold repetition of a position (with the same player to move), if there has been no capture or a pawn being moved in the last fifty moves, if checkmate is impossible, or if the players agree to a draw."
19:49:01 <parsnip> checkmate with bishop and knight is hard, you might eventually agree to draw.
19:49:22 <parsnip> oh, and fifty moves anyways
19:50:55 <NextHendrix> two bishops is quite hard too
20:01:36 * hackage miso 0.12.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-0.12.0.0 (DavidJohnson)
20:09:19 <sqooq> How do i get into ALSA? I'm using a resource for the api and sort of understand but in C they just create a pointer with a certain type, the equivalent type in Haskell has the constructor with type "PcmHwParams (Ptr PcmHwParams)" which I don't understand, Ptr is a type from another library.
20:10:22 <EvanR> Ptr a is from the haskell FFI
20:10:58 <EvanR> its a pointer to something that can be stored or retrieved from memory
20:11:11 <EvanR> (if it has a Storable instance)
20:11:20 <EvanR> :t peek
20:11:23 <lambdabot> error: Variable not in scope: peek
20:12:01 <crick_> Can someone tell me how this works? powerset :: [a] -> [[a]];   powerset xs = filterM (\x -> [True, False]) xs
20:12:11 <EvanR> peek :: Storable a => Ptr a -> IO a
20:12:23 <crick_> How is the non determinism being handled?
20:12:32 <EvanR> :t filterM
20:12:35 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
20:12:57 <EvanR> its using the list monad instance (well, technically Applicative now)
20:14:21 <EvanR> > do { x <- [1,2,3]; y <- [4,5]; return (x,y) }
20:14:23 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
20:14:37 <EvanR> that computation can proceed 6 different ways
20:14:48 <EvanR> its simply boils down to this implementation of join
20:15:46 <EvanR> > join [[(1,4),(1,5)],[(2,4),(2,4)],[(3,4),(3,5)]]
20:15:52 <lambdabot>  [(1,4),(1,5),(2,4),(2,4),(3,4),(3,5)]
20:15:59 <crick_> Okay
20:19:23 <crick_> Still not getting it fully, can u show what's happening behind the scenes for powerset [1,2]?
20:19:47 <mniip> @src filterM
20:19:47 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:20:14 <EvanR> powerset [1,2] = filterM (\x -> [True,False]) [1,2] = ... looking for the source of filterM
20:20:37 <mniip> huh how does it work with applicative
20:20:48 <EvanR> filterM p        = foldr (\ x -> liftA2 (\ flg -> if flg then (x:) else id) (p x)) (pure [])
20:20:54 <mniip> ah sure
20:21:17 <EvanR> not the most pedagogical code...
20:21:25 <mniip> you can expand it into manual recursion
20:21:29 <sqooq> EvanR, how do I actually use it?
20:22:24 <mniip> filterM p [] = pure []; filterM p (x:xs) = liftA2 (\b ys -> if b then x:ys else ys) (p x) (filterM p xs)
20:22:36 <EvanR> crick_: so... for each element of [1,2], its going to "run" (\x -> [True,False]) on it, which has 2 outcomes, one in which the result is appended to the result and one in which it isnt
20:23:18 <EvanR> then it repeats, but there are now two paths to take
20:23:29 <EvanR> so you get a total of 2^n result lists in the end
20:23:57 <EvanR> sqooq: through the Storable interface
20:25:15 <EvanR> i should have said "element" instead of "result" the first time i said result
20:25:27 <EvanR> due to this mistake i said result 5 times so far
20:25:54 <crick_> ya, I got it
20:26:02 <crick_> mniip: That made it clear
20:26:33 <crick_> EvanR: I was thinking on same lines but was not able to put in code
20:47:05 <royal_screwup21> I'm trying to map over a tree and here's what I tried: https://thepasteb.in/p/k5hYBQKBX08sE the compiler throws an errorL https://thepasteb.in/p/k5hYBQKB1ZWIE what am I doing wrong?
20:48:44 <geekosaur> what were you expecting (fmap left) and (fmap right) to do?
20:48:58 <geekosaur> hint: look at the beginning of that line
20:50:27 <royal_screwup21> I want those to map over the left and right subtrees
20:51:27 <geekosaur> there is something missing in what you said. it's the same thing that is missing in your code.
20:51:34 <royal_screwup21> oh I see
20:51:42 <royal_screwup21> didn't specify the value
20:52:02 <geekosaur> no, you have the values. you are missing the thing to map over the values
20:53:36 * hackage Villefort 0.1.2.6 - Villefort is a task manager and time tracker written in haskell.  https://hackage.haskell.org/package/Villefort-0.1.2.6 (ChrisReuter)
20:55:07 <royal_screwup21> dear lord
20:56:33 <royal_screwup21> is there any chance at all haskell's error message would become a little friendlier? otherwise dim-witted creatures like me are probably going to have a hard time :(
20:59:13 <mud> royal_screwup21: Consider what the optimal error message for this could even be, taking the position that the compiler doesn't actually understand how to code.
20:59:55 <EvanR> AI to diagnose a problem with your car, i can see that
21:00:00 <EvanR> AI to tell you how to code...
21:01:53 <geekosaur> royal_screwup21, it's telling you that you gave it a function (a partial application of fmap)
21:02:02 <geekosaur> was it supposed to read your mind?
21:02:09 <geekosaur> guess wildly?
21:03:49 <MarcelineVQ> they are scary errors when you first see them :>    royal_screwup21: ghc errors are daunting but they're also very exact about what is wrong so it's worth getting comfortable with them
21:03:56 <geekosaur> are we supposed to completely remove partial application from the language so it's "friendly"? what else needs to be removed so it's properly "friendly"? laziness? types?
21:04:18 <EvanR> remove the programmers
21:04:52 <royal_screwup21> OK, calm down, y'all, I was only kidding.
21:05:48 <mud> There is a case to be made for like a "beginner mode" or maybe separate beginner switches that turn off error messages assuming you'd be trying various things. But damn does that sound hard to get right.
21:05:55 <mud> It'd probably be super nice though in certain cases.
21:07:16 <MarcelineVQ> strongly against,  try to save time teaching things a person will need to learn anyway and end up wasting time teaching them the differences between what they've learned and the real deal
21:07:34 <MarcelineVQ> *try to save time by not teaching things
21:08:33 <MarcelineVQ> maintainer burden on such a feature as an entirely seperate argument ^^;
21:15:37 <MarcelineVQ> heeey pretty good http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_understanding_basic_haskell_error_messages.pdf
21:32:07 * hackage Villefort 0.1.2.7 - Villefort is a task manager and time tracker written in haskell.  https://hackage.haskell.org/package/Villefort-0.1.2.7 (ChrisReuter)
21:45:39 <dmwit> "turn off error messages" -- there is -fdefer-type-errors
21:46:06 * hackage Villefort 0.1.2.8 - Villefort is a task manager and time tracker written in haskell.  https://hackage.haskell.org/package/Villefort-0.1.2.8 (ChrisReuter)
22:46:06 * hackage yam-app 0.1.6 - Yam App  https://hackage.haskell.org/package/yam-app-0.1.6 (leptonyu)
22:56:07 * hackage yam-transaction-postgresql 0.1.6, yam-transaction-odbc 0.1.6, yam-servant 0.1.6, yam-job 0.1.6 (leptonyu): https://qbin.io/mg876jxsv
23:00:51 <shafox> Any library to write grammar so that I can parse text ?
23:01:06 * hackage yam-transaction-odbc 0.1.7, yam-servant 0.1.7, yam-job 0.1.7, yam-app 0.1.7, yam-transaction-postgresql 0.1.7 (leptonyu): https://qbin.io/fai3ldbh
23:01:15 <shafox> Basically I want to write grammar to parse wiktionary dataset.
23:03:50 <shafox> Does any variant of parsec such as parsec, megaparsec, attorparsec will work ?
23:05:44 <sqooq> shafox, probably, yeah.
23:05:51 <sqooq> parsec is general purpose parser
23:06:02 <sqooq> attoparsec I heard is better because more efficient
23:06:50 <dmj`> shafox: Those projects have almost identical APIs, there  are some differences though, attoparsec docs outline them, http://hackage.haskell.org/package/attoparsec-0.10.4.0/docs/Data-Attoparsec-ByteString.html
