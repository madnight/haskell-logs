00:06:11 <osa1> glguy: what font are you using? ^_^
00:12:23 <glguy> Cartograph mono cf , I think
00:12:53 <glguy> Not at my computer, will check later
00:55:36 <parsnip> there, did the isbn verifier exercise: http://lpaste.net/361452
00:59:55 <asheshambasta> has anyone here had any luck with intellij based haskell plugins?
01:12:38 <moet> why does Data.Graph reexport Data.Tree ?
01:13:33 <moet> i don't see any interop routines between the two modules..
01:13:44 <cocreature> moet: I’m just guessing here but I suspect that it does so since it uses Forest for some functions, e.g. dfs
01:14:43 <merijn> Honestly, I should just write a vector backed graph datatype one of these days for Haskell. It's been on my todo list for a while
01:16:13 <moet> cocreature: ah, yeah.. that makes sense. i didn't search for forest!
01:38:46 <DK21> can anyone give me a doc / help about deploying haskell applications into the boot/shutdown process of a server?
01:40:02 <ent> I don't think it's haskell-specific
01:40:21 <cocreature> take a look at the docs for your init system, e.g. systemd or whatever else you are using
01:45:43 <teknokratsevilla> hi
01:47:57 <heebo> hello the following code is my solution to http://adventofcode.com/2017/day/5
01:48:17 <heebo> but it stackoverflows, can anyone suggest an elegant alternative?
01:48:43 <heebo> https://gist.github.com/23de00d2f087c4befbbdcf1f5bc511bd
01:50:33 <cocreature> heebo: how can I reproduce the stackoverflow?
01:51:07 <heebo> evalState (result 0) (0,input)
01:53:22 <lyxia> it seems (n+1) is only evaluated at the end
01:55:18 <heebo> ok - it maybe my approach is wrong , its highly recursive
01:55:23 <cocreature> change your accumulator from a lazy to a strict pair and it should work
01:55:37 <cocreature> your approach is fine, you just need to add some strictness
01:56:06 <heebo> cocreature: can you show me how to make it a strict pair please
01:56:18 <heebo> my haskell is rusty
01:56:18 <cocreature> "data StrictTuple a b = StrictTuple !a !b"
01:56:32 <heebo> thanks
01:58:26 <cocreature> you might also want to use an unboxed vector
01:59:33 <lyxia> or a Map
02:00:38 <heebo> ok i need to remind myself what those are
02:06:34 <jle`> i call it a stuple
02:06:39 <jle`> or sometimes a struple
02:07:49 <jle`> heebo: what version of ghc are you using, by the way?
02:15:51 * hackage blaze-markup 0.8.1.0 - A blazingly fast markup combinator library for Haskell  https://hackage.haskell.org/package/blaze-markup-0.8.1.0 (JasperVanDerJeugt)
02:22:54 <heebo> jle`: 8.2.2
02:23:53 <heebo> thanks guys i got a result!! and it didnt stack overflow!!
02:24:44 <heebo> its pretty large so i can see why it was causing problems, one question how did you ascertain the tuple was to blame
02:29:22 <cocreature> the lazyness of tuples is one of the more common causes of space-leaks so it’s just one of the first things I look for when I try to debug one
02:38:41 <merijn> Also, repeated summing is another common cause of space leaks :p
02:39:13 <Athas> Does GHC ever turn non-strict foldls into strict foldls?
02:39:32 <opqdonut> yes
02:39:43 <opqdonut> via strictness analysis
02:40:04 <opqdonut> try a "main = print $ foldl (+) 0 [1..1000000000]" program with -O2 and without
02:40:12 <opqdonut> that used to be an easy example at least
02:40:41 <cocreature> Athas: if it didn’t, "sum" would always spaceleak on lists :)
02:41:23 <Athas> But maybe it does!
02:41:30 <Athas> Space leaks only matter if you blow the stack.
02:41:50 <cocreature> depends on what you mean by “matter”
02:41:52 <Athas> Also, "sum" is particularly simple.  Can GHC reliably do that with less trivial functions?
02:41:56 <cocreature> performance can be significantly worse
02:42:08 <cocreature> definitely not reliably
02:43:15 <s4ke1> jle`: you here?
02:53:37 <Peter1_> Is there any advice on how to run two ST monad operations in parallel?
02:53:52 <Peter1_> I know that is not so advisable, but I still want to try it.
02:54:09 <Peter1_> I can't do it in IO, really just the ST monad.
02:55:24 <s4ke1> Peter1_: define parallel?
02:55:50 <s4ke1> i don't know the ST monad
02:56:28 <Peter1_> https://hackage.haskell.org/package/vector-algorithms-0.7.0.1/docs/src/Data-Vector-Algorithms-Merge.html#sort
02:57:06 <Peter1_> I want to speed up the "loop l mid" and "loop mid u" parts by using more than 1 thread.
02:57:32 <Peter1_> I benchmarked that it is perhaps still faster even after cloning and coping the MVector
02:57:57 <s4ke1> hmm sorry, i guess i am not suited for helping you
02:58:11 <s4ke1> damn that was a complicated sentence
02:58:20 <s4ke1> *sorry, i cant help you
02:58:42 <Athas> Peter1_: no, ST is not parallel.  You'll have to use unsafe operations.
02:59:42 <Peter1_> I am willing to try unsafe operations. Which ones? It's just a test if it would speed up stuff
03:00:16 <Athas> Peter1_: specifically, the operations from https://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Monad-ST-Unsafe.html
03:00:45 <Athas> unsafeIOToST could certainly do it.  Maybe also unsafeInterleaveST, if you then also use 'par' cleverly, but I'm not sure.
03:01:04 <Peter1_> Okay, thanks alot!!
03:10:50 <ocramz> hullo!
03:10:59 <ocramz> is this a new Cabal feature? optparse-applicative ^>= 0.14.0.0
03:11:07 <ocramz> the ^>= sign I mean
03:14:17 <cocreature> ocramz: yes it was added in 2.0 iirc
03:32:45 <nschoe> Hi guys :) I feel silly for asking but I'm trying to read a 8 bytes from a file descriptor. In order to go fast I wanted to read a Word64. I've got the file descriptor from a FFI call. I have turned it into a Fd form System.Posix.Types and then used fdToHandle to get a Handle. I can easily read a ByteString from this Handle.
03:32:54 <nschoe> But how can I read my Word64?
03:34:08 <dminuoso> Can I view `filter` as `filterM` with `a -> Identity Bool` ?
03:37:13 <verement> nschoe: you'll probably want to use something like Data.Binary, and you'll need to know what endianness the data is
03:37:56 <nschoe> verement, erf, okay thanks
03:39:49 <cocreature> nschoe: if you already have an ffi call, you could just make an ffi call to "read"
03:40:03 <verement> if you know the data is definitely the same endianness as your host, you might be able to use Foreign.Storable
03:46:31 <Axman6> dminuoso: sure, those would be equivalent (modulo calls to runIdentity)
03:48:29 <nschoe> cocreature, Well _currently_ I have the FFI call to wiringI2CSetup to get the file descriptor, and I use fdReadBuf from System.Posix.IO to get a Ptr Word8 (then I use peekArray to get a [Word8] and then a [Int]. But it was suggested to me that it was faster to read the whole bytes as once as a Word64
03:48:42 <nschoe> And then I'd binary AND and shift to get the 8 different Ints.
03:48:57 <nschoe> So I wanted to avoid the FFI "cost".
03:49:21 <nschoe> I just need the initial FFI call to open the connection to the I2C bus, but that's one time. Then in the 'loop' , I'
03:49:30 <nschoe> d like to avoid FFI calls. Hence my asking.
03:50:12 <nschoe> I'll look into binary. As for the endinanness I am not sure: thre data come from an Arduino, sent over I2C, fetched from a rPi. But sicne this works right now with the fdReadBug  and the Ptr Word8 I suppose the endianness is the same, right?
03:54:29 <verement> nschoe: if it is the same endianness, you might just cast the Ptr Word8 to Ptr Word64 and peek that, assuming there's also good alignment
03:54:37 <dminuoso> Axman6: Alright great thanks.
03:55:40 <Axman6> dminuoso: you could also verify this for yourself by going through by hand what gets executed by filter and filterM
04:50:28 <nschoe> verement, okay good idea I'll check. thx
04:55:01 <yeoman> man entering haskell is so hard, geez
04:55:26 <merijn> yeoman: Learning, in general, is hard :)
04:56:15 <merijn> nschoe: Depending on what you're doing the FFI is really quite low
04:56:32 <Psybur> merijn, especially after age 25 :{
04:56:43 <merijn> verement: on x86/x64 the alignment is pretty much irrelevant
04:56:57 <Psybur> I think I still have a bit of the ol' neuroplasticity left though :D
04:57:02 <merijn> verement: You can do unaligned reads with basically no slowdown
04:57:43 <yeoman> merijn: well, would be easy for me to learn python
04:57:52 <merijn> Psybur: If it's any consolation, neuroplasticity is trainable :)
04:57:54 <yeoman> altough i never wrote it
04:58:07 <yoho> I thought a large part of the neuroplasticity concept was bunj?
04:58:09 <yoho> bunk*
04:58:10 <yeoman> i cannot even get my input to main
04:58:17 <merijn> yeoman: The problem is that many programming languages are so similar that "learning" them doesn't require actually learning anything
04:58:43 <yeoman> yes.
04:58:59 <merijn> yeoman: From my point of view python, ruby, JS, Java, and C# are all "basically the same" if you squint a bit. Haskell, otoh, is wildly different
04:59:01 <geekosaur> a lot of neuroplasticity is currently unknown and if you're not hearing it from a researcher in the area then it's probably snake oil
04:59:36 <geekosaur> also there is a LOT of "use it or lose it" in this area. keep stretching yourself
04:59:40 <merijn> yoho: Well, it's generally agreed upon that kids learn things more easily than adults, but anything more detailed/specific than that is probably BS
04:59:44 <Psybur> merijn, interedasting. Cant seem to find any free workout plans though heh
05:00:05 <yeoman> merijn: yes, same here
05:00:12 <yeoman> you can add C to the mix.. don't you
05:00:15 <merijn> yoho: The other thing, which I just referred, is that people who keep learning find learning new things easier than people who don't
05:00:15 <yeoman> except for pointers maybe?
05:00:27 <yeoman> poor yoho
05:00:30 <yoho> ?
05:00:37 <merijn> yeoman: What's the problem you have with getting input into main?
05:00:54 <yeoman> i am writing tictactoe, and my first step is to let the player choose X or O
05:01:21 <yeoman> i have a function getPlayersChoice which returns Symbol
05:01:29 <merijn> yeoman: Do you want a "proper" terminal UI, or are you just printing a board and asking for coordinates?
05:01:46 <nschoe> merijn, but is it fast?
05:01:57 <yeoman> but i guess, because it has IO i guess... the "return" value has to be IO
05:01:58 <yeoman> right.
05:02:02 <yeoman> IO Symbol.. im guessing
05:02:12 <merijn> nschoe: unsafe FFI call introduces a few cycles overhead, but not much
05:02:17 <merijn> yeoman: Right
05:02:33 <nschoe> merijn, because in my case, it's for a robot, more specifically for reading obstacles sensors, that needs to run at least at 15Hz,on a rPi 3.
05:02:41 <yeoman> oh i get it.. return does wrap it..
05:02:50 <merijn> yeoman: Do you know how to write "String -> Maybe Symbol"?
05:02:52 <nschoe> merijn, hum okay, so FFI call is doable then, ok.
05:03:37 <yeoman> merijn: well it's not supposed to return Nothing, why would i need maybe?
05:03:42 <merijn> nschoe: "safe" foreign calls add some overhead (releasing locks, run in a separate OS thread to unblock the haskell thread), unsafe FFI calls are *really* cheap, but you have to be a bit careful
05:03:56 <merijn> yeoman: Well, what if the user writes wrong input? :)
05:04:33 <nschoe> merijn, yes but in this case, the unsafe version is no problem: a simple read will never call back some Haskell code.
05:04:36 <merijn> yeoman: You probably wanna use "getLine :: IO String" and "convert :: String -> Maybe Symbol" and write a loop that handles "wrong" input from the user :)
05:04:37 <yeoman> he simply get's X :D
05:04:59 <yeoman> whats the difference between "return X" and just writing "IO X"
05:05:11 <geekosaur> you can't write the latter
05:05:18 <yeoman> why?
05:05:21 <geekosaur> IO is a type, not a data constructor
05:05:24 <LiaoTao> IO is a type, not a constructor
05:05:29 <merijn> nschoe: Keep in mind that unsafe foreign calls will prevent GC from running until the call returns, so you should only use it for things that you *know* will never take long
05:05:30 <LiaoTao> Lag
05:05:34 <nschoe> merijn, but actually I still don't see the difference: if I FFI call to `read`, I will still get a pointer, so it's the same as calling `fdReadBuf`, right?
05:05:48 <nschoe> merijn, okay, good to know, thanks.
05:05:49 <yeoman> so.. how would i create something of type "IO"
05:06:31 <merijn> nschoe: fdReadBuf is a better way to go than calling read, since read can block iirc. But I think cocreature was referring to using an FFI cal to do the conversion
05:06:32 <yeoman> or is that one special and abstract so it can encapsulate stuff
05:06:33 <geekosaur> you don't create one out of nothing. you work in an IO monadic context
05:06:36 <liste> yeoman: with "return", for example
05:06:40 <liste> yeoman: or getLine
05:06:45 <merijn> yeoman: It's special and abstract to encapsulate stuff, yes :)
05:07:02 <yeoman> i figured.. im just asking the questions to understnand, i know they're stupid
05:07:13 <merijn> yeoman: So you use existing IO actions and put your pure function into those using fmap and >>=
05:07:16 <geekosaur> you start out in main :: IO a
05:07:21 <liste> > return "hi there" :: IO String -- I created a value of type IO String here
05:07:26 <lambdabot>  <IO [Char]>
05:07:44 <geekosaur> things that can produce results in IO have to ultimately lead mack to monadic actions in main
05:07:46 <yeoman> yeah i already did that, as i said, im asking these questions because i think the answers to them lead me the right way
05:07:50 <geekosaur> *lead back
05:08:18 <liste> getting values *into* IO is easy, but getting them *out of* IO is not
05:08:24 <nschoe> merijn, oh okay.
05:08:29 <geekosaur> this way, when you write pure code, you know it's not doing IO behind your back. (and so does the compiler, which enables a bunch of optimizations you can't do safely in, say, C)
05:08:31 <merijn> yeoman: "fmap :: Functor f => (a -> b) -> f a -> f b", so the Functor for IO is "fmap :: (a -> b ) -> IO a -> IO b", so you build your own code, say, "IO Symbol" out of "convert :: String -> Symbol" and "getLine :: IO String" by doing "fmap convert getLine" :)
05:08:37 <nschoe> merijn, but the conversion... how to I return "a list" in C for Haskell?
05:08:57 <nschoe> merijn, apart from returning a pointer, but then it's back to Ptr Word8 or Ptr Word64
05:09:17 <geekosaur> it also means you know that code can't e.g. mutate data in another thread
05:09:20 <merijn> nschoe: Have a look at Foreign.Marshal?
05:09:34 <geekosaur> Foreign.Marshal.Array
05:09:39 <merijn> nschoe: That has, for example "peekArray :: Storable a => Int -> Ptr a -> IO [a]"
05:09:59 <yeoman> do i already use monads when using do and return
05:10:02 <merijn> You can also use storable vectors
05:10:04 <yeoman> yes, right?
05:10:10 <geekosaur> return, yes.
05:10:18 <geekosaur> do, not necessarily:
05:10:21 <geekosaur> > do 5
05:10:24 <lambdabot>  5
05:10:31 <merijn> yeoman: do is just syntactic sugar for introducing ">>=" and ">>"
05:10:35 <tdammers> also depends on your definition of "using monads"
05:10:53 <yeoman> yeah i know these.. bind and return that's what it does.. is that a "monad" i mean
05:10:57 <yeoman> the naming is odd to me
05:11:03 <LiaoTao> geekosaur: I don't understand that
05:11:11 <merijn> yeoman: Generally I recommend beginners avoid using do notation and instead writing things using explicit >>= and >> before switching to do notation
05:11:25 <nschoe> merijn, ha yes, but this is what I already do actually :)
05:11:32 <tdammers> yeoman: the naming is historical, mostly... "return" in particular is more of an accident than anything
05:11:40 <geekosaur> LiaoTao, if you don't use <- or the implicit >> from semicolon (or next line in layout), you don't get a Monad type constraint induce
05:11:40 <merijn> yeoman: Since, in my experience beginners attribute too much "magic" to do, whereas it is a simple mechanical translation
05:12:02 <yeoman> i mean, in my function getPlayersChoice which returns IO Symbol where Symboll = X | O
05:12:03 <geekosaur> this is why ApplicativeDo is possible, for example
05:12:05 <yeoman> what is the monad in there
05:12:06 <merijn> yeoman: This page has a good explanation of the syntactic sugar: https://en.wikibooks.org/wiki/Haskell/do_notation
05:12:12 <nschoe> merijn, I use callocArray to create the Ptr Word8, thenf dReadBuf reads into this Ptr Word8 and then I use peekArray to go from Ptr Word8 to [Word 8]
05:12:28 <merijn> nschoe: Constructing a list is probably expensive
05:12:28 <yeoman> merijn: i read all of these.. still confuses me.. where is the pointer to a single monad "instance"
05:12:29 <LiaoTao> geekosaur: Mmph, guess I'll have to read up on that
05:12:29 <LiaoTao> Thanks
05:12:36 <geekosaur> yeoman, the monad is what lets you perform IO actions (getLine, putStrLn, etc.)
05:12:44 <yeoman> is each operation (bind,return) a monad.. is there one monad per function that returns stuff
05:12:45 <merijn> nschoe: If you'd make a Storable vector out of it, it'd probably be more efficient if you want speed
05:13:14 <yeoman> i know what it is for etc.. but i can't put my finger on it, what is the monad
05:13:18 <nschoe> merijn, about using >>= and >> (sorry I follow both conversation because they are interesting :)) instead of do notations for beginners, this means that functions body become quite complex and not easily readable over time, no?
05:13:36 <merijn> yeoman: Everything in a single expression of >> and >>= is the same monad type. Which one that is, is inferred by the compiler from the types
05:13:38 <geekosaur> IO is a monadic type. putStrLn :: String -> IO () is a monadic action. the "monad" is an interface, not really a thing as such
05:13:44 <yeoman> i even without knowing much about haskell
05:13:48 <geekosaur> the interface specifies two operations, bind and return
05:13:53 <yeoman> i think i agree with merijn with skippiong do
05:13:57 <nschoe> merijn, about the list: yes but I need to list in the end anyway: it's a list of distances measures by sensors, so I need to process them individually :)
05:13:59 <yeoman> but i already think i know what "do" does
05:14:04 <merijn> nschoe: Well, that's why I said only in the beginning. :p There's a reason why everyone uses it :)
05:14:15 <nschoe> merijn, okay thanks :)
05:14:28 <LiaoTao> yeoman: Whatever you do, don't think of `return` as actually some kind of data in a structure
05:14:28 <merijn> nschoe: It's much more readable, but it's important that you understand HOW to write it without do using >>= first
05:14:38 <geekosaur> "do" just enables the use of convenient syntax which is useful with monadic types (and Applicative types, with the ApplicativeDo extension enabled)
05:14:40 <LiaoTao> +returning
05:14:47 <merijn> nschoe: Like, if the examples in that wikibook are obvious to you, yeah, keep using do
05:15:13 <nschoe> merijn, yes I agree. I ususally start my functions with >> and >>=, but "revert" to do sugar when I end up needing several bound values for a later computation and that makes me chain the lamba functions.
05:15:23 <merijn> nschoe: As long as you understand that "foo <- myaction; f foo" is just "foo >>= f" and there's no magic
05:15:47 <merijn> nschoe: But many beginners think "<-" is some "monad-b-gone" magic :)
05:15:50 <nschoe> merijn, absolutely yes. Thx
05:15:57 <nschoe> merijn, I get that. Been there too.
05:15:58 <centril> I'm hacking on a hypothesis/quickcheck like lib for property based testing for Rust... I'd love some design input from fellow Haskllers on the trait ArbitraryF1 at the end:  https://play.rust-lang.org/?gist=2cf89a364bfe6824a377d70284ebe97a&version=stable
05:16:12 <nschoe> merijn, still gets me sometimes when I stack some monad transformers and whatnot :/
05:16:32 <yeoman> https://en.wikibooks.org/wiki/Haskell/do_notation at "nameLambda" what is the "monad"
05:16:41 <yeoman> i mean .. how many monads are they. 0,1,2?
05:16:50 <merijn> yeoman: 1, IO
05:16:52 <yeoman> i understand the code.. but i can't get a concept of what a monad is.
05:16:57 <merijn> yeoman: Which is inferred from "putStr"
05:17:01 <centril> Also - are there any papers or other relevant resources for deriving Arbitrary for recursive types (including co-recursive ones)?
05:17:04 <merijn> :t (>>=)
05:17:06 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:17:17 <merijn> yeoman: Note that the 'm' is the same everywhere
05:17:38 <merijn> :t (>>=) `asAppliedTo` getLine
05:17:39 <lambdabot> IO String -> (String -> IO b) -> IO b
05:18:00 <LiaoTao> yeoman: Since you know a bit of Haskell, could I recommend the "What is a Monad?" video by Computerphile
05:18:04 <merijn> yeoman: So by using getLine, the compiler infers the Monad 'm' in ">>=" to be IO
05:18:13 <yeoman> LiaoTao: i even know that one
05:18:16 <yeoman> i always thought im smart
05:18:21 <yeoman> but i read all this shit, and still confused
05:18:24 <centril> (on the topic of monads... <3 kleisli composition)
05:18:30 <merijn> centril: Yes!
05:18:32 <nschoe> merijn, since we're talking about do notations, allow me to hijack a small question: sometimes inside a do notation I wonder if it's better to use: `let a = "foo"` or `a <- return "foo"`. For instance inside an IO computation I might do `tic <- getCurrentTime; let diff = diffUTCTime tic tac` and that sorts of "mixes" `let` and `<-`, so I'm sometimes tempted to `diff <- return $ diffUTCTime tic tac`. Any thought?
05:18:37 <LiaoTao> yeoman: That video will tell you the reasoning behind this abstraction
05:18:42 <LiaoTao> The rest is just learning the mechanics
05:18:43 <merijn> centril: Kleisli composition makes the monad laws a lot nicer too
05:18:51 <yeoman> LiaoTao: i understand it.. maybe the mechanics is what i am missing, yes
05:18:58 <centril> merijn: yeah - "what monad laws... oh, you mean the category laws?"
05:19:11 <yeoman> LiaoTao: but that video explains "maybe" not actually what the "nameLambda" does
05:19:13 <merijn> nschoe: Personally I use let
05:19:14 <yeoman> actually.
05:19:23 <yeoman> or am i wrong?
05:19:39 <nschoe> yeoman, not particularly related to Monads, but if you're new to Haskell, I find this "Haskell concepts in one sentence" sometimes useful: https://torchhound.github.io/posts/haskellOneSentence.html
05:19:48 <centril> Here's my style guide for Haskell: https://github.com/DATX02-17-26/DATX02-17-26/blob/dev/docs/code-style.md  someone might find it useful...
05:19:54 <LiaoTao> yeoman: The point of the video, to me, is that the same set of operations can be performed on lots of different types
05:19:55 <nschoe> merijn, but no performance cost?
05:19:57 <yeoman> nschoe: thanks i think that helps
05:20:06 <nschoe> yeoman,
05:20:08 <merijn> nschoe: Yes, no, maybe
05:20:10 <LiaoTao> Whose side effects aren't necessarily restricted to failing with a Nothing
05:20:18 <merijn> nschoe: Unlikely to have a noticable one, though
05:20:41 <yeoman> i think the problem with monads is actually that i am getting them all the time
05:20:48 <yeoman> and i keep searching for it's magic.. where there is none
05:20:50 <yeoman> not even kidding
05:21:04 <merijn> yeoman: That sounds very likely, yes
05:21:13 <nschoe> yeoman, and as for trying to give an intuition about Monads, I do not know if you have a Math background, but I usually think of Monads as "a set of rules" to chain computations. In the same sense that in Mathematics, a Group or Ring is a set of rules. Well Monads is kind of the same thing.
05:21:18 <yeoman> it's just "lol, this function has side effects, so you can't actually see directly what it returns because you're in pure world, lol"
05:21:19 <merijn> yeoman: There is no "deep magic", it's just "an abstract interface that happens to occur a lot"
05:21:21 <yeoman> that's how i get it..
05:21:30 <nschoe> merijn, okay thanks, I won't bother anymore. Thanks for you time =)
05:21:44 <yeoman> and if i had to come up with a concept for this i would end up having monads.
05:21:48 <yeoman> that's how i imagine it.
05:21:49 <merijn> yeoman: Except they don't have side-effects if we're being pedantic
05:22:04 <centril> I find it useful to explain monads by lying a bit - you don't have to be fully general in your description
05:22:15 <centril> and then you can ease into the more general description
05:22:17 <yeoman> merijn: from the view of the pure world that is correct.. but main is always unpure, isn't it?
05:22:25 <centril> Usually it helps to explain functors first
05:22:26 <merijn> yeoman: A side-effect is an effect that is not visible in the type of a value. The entire point of IO is that any effects *are* in the type, and thus not *side*-effects
05:22:46 <yeoman> interesting
05:22:55 <merijn> yeoman: The IO monad is a *pure* DSL for constructing imperative programs, basically
05:23:10 <centril> merijn: that's a really apt description, +100
05:23:16 <yeoman> yeah i like it too
05:23:24 <yeoman> it's a competent version of my "lol im a function"
05:23:30 <merijn> yeoman: Don't think of "getLine :: IO String" as "impure function that gets a String", think of it as "a program fragment describing a piece of program, that when executed produces a String"
05:23:54 <merijn> yeoman: Then ">>=" and ">>" are pure functions for gluing small program fragments into bigger ones.
05:24:12 <merijn> The end result is a single program fragment "main :: IO a" which can be constructed and then executed by the runtime
05:24:23 <yeoman> well, but isn't it misleasding to see functions as "piece of programs"
05:24:27 <ertes> yeoman: the magic of monads is that you can abstract over them…  imagine you want to write a function that turns a list of IO actions into an IO action that returns the individual results
05:24:31 <yeoman> isn.t that what haskell abstracts away form.. being a program at all?
05:24:38 <tromp> think of it as recipe for obtaining a String from IO
05:24:54 <centril> yeoman: no, that is exactly right - "program" is just a fancy word for "expression"
05:24:58 <ertes> :t foldr (\c go -> liftA2 (:) c go) (pure []) :: [IO a] -> IO [a]
05:24:59 <lambdabot> [IO a] -> IO [a]
05:25:23 <yeoman> centril: well cpu is just a fancy word for interpreter.. i think this is misleading
05:25:24 <ertes> yeoman: but if you look at the implementation, there is nothing IO-specific…  you can generalise this to any Monad (or indeed, any Applicative)
05:25:31 <ertes> :t foldr (\c go -> liftA2 (:) c go) (pure [])
05:25:32 <geekosaur> you kinda can't abstract that away fully if you intend your program to interface with the world at all
05:25:32 <lambdabot> (Applicative f, Foldable t) => t (f a) -> f [a]
05:25:49 <yeoman> programs have all these stuff in it.. memory management, and control flow, while haskell really tries to get around those
05:26:19 <yeoman> ertes: what implementation?
05:26:27 <ertes> yeoman: the one i just wrote
05:26:34 <yeoman> oh jesus.. i ccan't read that
05:26:39 <centril> yeoman: A modern CPU is a very particular type of interpreter ;)  A program is usually just "a big expression made up of subexpressions"
05:26:41 <geekosaur> but what haskell does offer there is a way to mark all the things that have to deal with interfacing with the real world, and keep them separate from pure program logic
05:26:44 <centril> Program != Application
05:26:49 <Psybur> :t foldr (\c go -> liftA2 (:) c go) (pure []) [Just (*3)]
05:26:51 <lambdabot> Num a => Maybe [a -> a]
05:26:51 <yeoman> i didn't except fold to have monads at all
05:27:00 <yeoman> i don't understand that yet
05:27:01 <ertes> yeoman: nevermind, just think of a recursive function that does what i described…  and look at the type
05:27:10 <ertes> yeoman: [IO a] -> IO [a]
05:27:13 <yeoman> i know fold.. i read "haskell for greatooer good or something"
05:27:17 <ertes> yeoman: does the type make sense to you?
05:27:18 <Psybur> :t foldr (\c go -> liftA2 (:) c go) (pure []) [Just (*3)] <*> [2,3,4]
05:27:20 <lambdabot> error:
05:27:20 <lambdabot>     • Couldn't match type ‘[Integer -> Integer]’ with ‘Integer -> b’
05:27:20 <lambdabot>       Expected type: Maybe (Integer -> b)
05:27:21 <yeoman> yes
05:27:25 <yeoman> wait, no
05:28:13 <ertes> @let mySeqA = foldr (liftA2 (:)) (pure [])
05:28:15 <lambdabot>  Defined.
05:28:21 <ertes> yeoman: here is a use case:
05:28:44 <ertes> :t mySeqA [getLine, getEnv "BLAH"]
05:28:45 <lambdabot> error:
05:28:46 <lambdabot>     • Variable not in scope: getEnv :: [Char] -> IO String
05:28:46 <lambdabot>     • Perhaps you meant ‘getAny’ (imported from Data.Monoid)
05:28:51 <ertes> :t mySeqA [getLine, System.Environment.getEnv "BLAH"]
05:28:53 <lambdabot> IO [String]
05:29:16 <ertes> yeoman: you give it a list of IO actions, and the result is an IO action that runs each individual action and returns a list of the results
05:29:47 <yeoman> yeah that's even what i figured from the type
05:29:55 <Psybur> :t sequence [getLine,  System.Environment.getEnv "BLAH"]
05:29:57 <lambdabot> IO [String]
05:30:13 <Psybur> @source sequence
05:30:13 <lambdabot> Unknown command, try @list
05:30:15 <centril> ertes: that wording is a bit misleading imo, there's a critical happens-before relationship btw the actions
05:30:17 <Psybur> @src sequence
05:30:17 <lambdabot> sequence []     = return []
05:30:17 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:30:17 <lambdabot> --OR
05:30:17 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
05:30:19 <ertes> yeoman: but now look at the implementation (even if you don't really understand it)…  you will notice that there is nothing IO-specific in it
05:30:33 <ertes> yeoman: mySeqA actually generalises to arbitrary monads (and even further)
05:30:37 <Psybur> ertes, why liftA2 instead of liftM2 in your def?
05:30:51 <centril> Psybur: to generalize for Applicative - more reusable
05:31:00 <s4ke1> i talked to some of you guys about this already, but hear my shameless plug: https://github.com/s4ke/Parrows We have just submitted my first paper about parallel Arrows
05:31:02 <Psybur> I figured. Then why is it liftM2 here? :D
05:31:08 <s4ke1> more work has to be done though
05:31:16 <centril> Psybur: history =)
05:31:27 <ertes> Psybur: 'sequence' is part of a historical mistake…  just use sequenceA instead
05:31:33 <merijn> Psybur: Because liftA2 didn't exist when liftM2 and that function were written :)
05:31:40 <Psybur> gotcha
05:31:41 <centril> just like 'return' is a historical mistake
05:31:43 <yeoman> ertes: well i don't know the functions used in that thingie.. so i can't understand it :/
05:31:46 <centril> just use pure
05:31:49 <merijn> Psybur: Applicative wasn't invented until 2004, some 14 years after the first Haskell report :)
05:31:49 <yeoman> go and pure etc
05:32:08 <centril> yeoman: return == pure
05:32:19 <yeoman> but the word IO is missing. yeah that's funny
05:32:23 <yeoman> how did it get out there
05:32:54 <sphinxo> where does haskell look for gcc?
05:32:58 <centril> s4ke1: cool
05:33:28 <s4ke1> centril: thanks :)
05:33:33 <geekosaur> sphinxo, $PATH (%PATH% on Windows)
05:33:41 <ertes> here is an even simpler example: a function that takes an action and runs it three times, returning the result of the last run
05:33:48 <ertes> :t \action -> action *> action *> action
05:33:50 <lambdabot> Applicative f => f b -> f b
05:34:11 <centril> s4ke1: have you seen the work on sized monads and such?
05:34:16 <ertes> yeoman: the main point i want to get across is that you can use this function for IO actions, but you can also use it for parser actions
05:34:41 <ertes> yeoman: or anything else with an Applicative instance
05:34:44 <s4ke1> centril: no, i guess.
05:34:47 <geekosaur> sphinxo, you can override the default in the settings file, but this can get you into trouble if it doesn't match what your ghc was configure-d with
05:34:47 <s4ke1> got a link?
05:35:05 <Psybur> :t (*>)
05:35:06 <lambdabot> Applicative f => f a -> f b -> f b
05:35:14 <s4ke1> or maybe i just dont know what you mean with sized
05:35:33 <ertes> yeoman: if you look at the type, it abstracts over Applicative…  naively you might think of its type to be (IO a -> IO a), but there is nothing IO-specific in it
05:35:43 <earthy> 588
05:35:50 <Psybur> > 1+2*>3+4*>5+6
05:35:54 <lambdabot>  error:
05:35:54 <lambdabot>      • Could not deduce (Num (f a0))
05:35:54 <lambdabot>        from the context: (Num (f b), Num (f a2), Num (f a), Applicative f)
05:36:06 <ertes> yeoman: much like when you look at an expression like (3*4 + 1) there is nothing Integer-specific in it…  it abstracts over Num
05:36:07 <Psybur> > (1+2)*>(3+4)*>(5+6)
05:36:10 <lambdabot>  error:
05:36:10 <lambdabot>      • Could not deduce (Num (f a0))
05:36:10 <lambdabot>        from the context: (Num (f b), Num (f a2), Num (f a), Applicative f)
05:36:15 <Psybur> Oh oops
05:36:21 <ertes> :t 3*4 + 1
05:36:22 <centril> s4ke1: dont have a link atm, but the idea is that you annotate the cost of operations in the type system so that you don't make sparks for operations that are too cheap
05:36:23 <Psybur> 1+2 is a value not a function
05:36:23 <lambdabot> Num a => a
05:36:59 <Psybur> > (f*3)*>(f*3)*>(f*3)
05:37:02 <lambdabot>  error:
05:37:02 <lambdabot>      • Could not deduce (FromExpr (f a0))
05:37:02 <lambdabot>        from the context: (FromExpr (f b), FromExpr (f a2), FromExpr (f a),
05:37:06 <sphinxo> geekosaur: thanks
05:37:12 <yeoman> man shit is hard :D
05:37:15 <s4ke1> centril: ah okay. at the moment our approach focuses on parallelizing Arrows that support ArrowChoice and ArrowLoop and expressing parallel skeletons with them
05:37:15 <Psybur> :t f*3
05:37:17 <lambdabot> (FromExpr a, Num a) => a
05:37:23 <Psybur> Dammit haha
05:37:29 <s4ke1> we don't do dataflow parallelism
05:37:36 <centril> s4ke1: ah =)
05:37:36 <ertes> Psybur: 1 + 2 could be a function
05:37:48 <ertes> it's a matter of writing a Num instance =)
05:37:49 <s4ke1> centril: i have seen Justin Le's blog post about that
05:37:57 <geekosaur> Psybur, use a instead of f
05:38:00 <geekosaur> :t f
05:38:02 <lambdabot> FromExpr a => a
05:38:04 <s4ke1> s/that/an Arrow that does dataflow parallelism
05:38:05 <geekosaur> :t a
05:38:08 <lambdabot> Expr
05:38:18 <centril> s4ke1: haven't read much about it myself - I know a friend was working on it
05:38:18 <Psybur> > (a*3)*>(a*4)*>(a*5)
05:38:23 <s4ke1> but we are doing parallelization of general purpose arrows
05:38:23 <lambdabot>  error:
05:38:23 <lambdabot>      • Couldn't match expected type ‘f a0’ with actual type ‘Expr’
05:38:23 <lambdabot>      • In the first argument of ‘(*>)’, namely ‘(a * 3)’
05:38:37 <centril> s4ke1: I'm mostly doing language design on Rust these days
05:38:42 <s4ke1> ah okay :)
05:39:09 <Psybur> > (pure 1)*>(pure 2)*>(pure 3) :: [Int]
05:39:13 <lambdabot>  [3]
05:39:22 <centril> s4ke1: working on custom deriving for a quickcheck/hypothesis port for Rust atm ;)
05:39:41 <geekosaur> ok, yeh, you're beig tricker than simple-reflect can easily deal with
05:39:41 <s4ke1> centril: our general idea relies on programmers knowing a bit of their data flow before writing the program. We base all our stuff on a primitive parEvalN :: [arr a b] -> arr [a] [b]
05:39:51 <s4ke1> we implement that with multiple backends
05:40:09 <s4ke1> centril: sounds awesome
05:40:10 <s4ke1> got a link?
05:40:49 <ertes> Arrow isn't an interface i would use for parallelism
05:41:56 <cocreature> ertes: s/for parallelism// :)
05:42:25 <centril> s4ke1: not done yet - here's the hypothesis/quickcheck-like framework:  https://docs.rs/proptest/0.3.4/proptest/index.html   here's my work on "canonical Gen" (Arbitrary) for proptest: https://docs.rs/proptest-arbitrary/0.2.2/proptest_arbitrary/  (will hopefully be merged into proptest proper soon, and also supports most of the standard library),  and here's my work on custom derive:
05:42:27 <centril> https://github.com/Centril/proptest-derive
05:42:57 <centril> Currently working on deriving recursive sum types - co-recursion will be hard ;)
05:42:58 <ertes> yeah, but it's particularly poor for parallelism…  the way you have to structure your actions with the Arrow interface is very expensive
05:43:17 <ertes> and as soon as you use -XArrows heavily you can throw performance out the window
05:44:02 <centril> s4ke1: If you understand Rust, here's also an idea for Arbitrary1: https://play.rust-lang.org/?gist=2cf89a364bfe6824a377d70284ebe97a&version=stable  (a bit more general, and scroll down to ArbitraryF1)
05:44:07 <s4ke1> ertes: wdym with structuring the actions?
05:44:39 <ertes> s4ke1: the whole Arrow interface is based on passing information through side channels, and those aren't free
05:44:49 <ertes> so you get deep tuples everywhere
05:45:11 <s4ke1> ertes: but that's only if you use proc notation, right?
05:45:46 <ertes> s4ke1: no, that's Arrow itself…  proc notation only obscures it
05:47:26 <s4ke1> ertes: wdym with deep tuples
05:47:41 <s4ke1> deeply nested?
05:47:57 <ertes> s4ke1: one of the main problems of AFRP is that those side channels quickly add up, so you're inclined to use proc/do as little as possible and use Category for higher level composition…  adding an Applicative interface helps replacing some of the proc/do blocks by more efficient (and even shorter) descriptions, but it still adds up
05:48:09 <ertes> yeah
05:48:15 <s4ke1> ertes: ah i get it now.
05:48:21 <s4ke1> well we don't do that
05:48:35 <s4ke1> we just use Arrows as the interface and show that we can parallelize arbitrary arrows
05:48:44 <s4ke1> okay arbitrary arrows that allow for certain operations
05:48:50 <s4ke1> next version will work with profunctors i guess
05:48:55 <s4ke1> s/with/on
05:49:41 <s4ke1> i guess our stuff isn't that groundbreaking in a sense, but i still think it has its worth
05:49:54 <s4ke1> i mean even if it doesnt get accepted i dont really mind that much
05:50:26 <centril> s4ke1: working hard at lowering expectations, eh?
05:50:41 <s4ke1> centril: that's the sanest way to do things
05:50:42 <ertes> s4ke1: for parallelism i would focus on Applicative
05:50:54 <centril> s4ke1: hehe ^,-
05:51:41 <yeoman> Type classes are similar to OOP interfaces.
05:51:49 <yeoman> i find this one so counter intuitive
05:51:52 <yeoman> i don't know if it's just me
05:52:09 <centril> yeoman: hmm well... they are and they are really not at the same time
05:52:30 <s4ke1> you can abuste them similarly though
05:52:35 <geekosaur> up to a point
05:52:37 <s4ke1> at least from my experience
05:52:38 <dminuoso> I know edward talked about this, differentiating between true typeclasses and implicits..
05:52:39 <yeoman> well, i certainly can't
05:52:45 <centril> yeoman: for example:  class Arbitrary a where arbitrary :: Gen a   <-- not expressible in Java, you first need an object of the interface
05:52:51 <yeoman> interfaces ( i only seen them in java ) feel like an api to me
05:53:16 <yeoman> so i , as a dev, know what my object has to implement so that it works at all
05:53:40 <yeoman> type classes realy feel like voodoo compared to that.... that describe HOW you can make them do certain things.. be comparable, ordable etc..
05:53:47 <centril> Also... once you get HKTs, type classes run circles around Java interfaces
05:53:53 <yeoman> they're closer to ruby mixins than to java interfaces
05:54:14 <centril> yeoman: Most like Rust traits I'd say
05:54:21 <yeoman> dunno rust
05:54:22 <ertes> yeoman: i suggest you don't compare type classes to anything else…  type classes are a mechanism to communicate interfaces *implicitly*
05:54:28 <centril> (Rust traits are essentially a rip-off Haskell type classes)
05:54:34 <yeoman> btw, what does haskell expect "main" to return?
05:54:43 <ertes> :t let f x = 2*x + 1 in f
05:54:45 <geekosaur> nothing
05:54:45 <lambdabot> Num a => a -> a
05:54:50 <centril> yeoman: main :: IO ()
05:54:59 <ertes> yeoman: IO's result is ignored
05:55:03 <geekosaur> most commonly one does main :: IO (), but it will accept any type
05:55:09 <geekosaur> main :: IO a
05:55:13 <ertes> you can have (main :: IO Int), and the resulting Int will be ignored
05:55:13 <centril> geekosaur: it will? o.O
05:55:15 <yeoman> how would i change a haskell programms exit code?
05:55:16 <centril> news to me
05:55:28 <centril> yeoman: exitFailure, and such
05:55:29 <merijn> centril: The report says main can have any type that unifies with "IO a"
05:55:29 <s4ke1> ertes: thanks for the input though. appreicated
05:55:30 <geekosaur> System.Exit.exitWith
05:55:45 <s4ke1> s/appreicated/appreciated
05:55:54 <geekosaur> a valid program is presumed to have completed successfully if it returns normally
05:56:02 <centril> merijn: oh - I assume  `void $ main` is what happens semantically
05:56:05 <ertes> s4ke1: happy to help…  the reason i point out Applicative is that it captures the idea of "embarrassingly parallel" as an API
05:57:10 <geekosaur> and the main reason it is IO a is so you can do cheaty stuff like main = putStrLn "enter something" >> getLine >>= putStrLn . doSomething >> main
05:57:16 <ertes> s4ke1: so anything that is a proper (i.e. non-monad) Applicative is naturally parallelisable, while anything with a Monad instance is partially parallelisable
05:57:35 <phadej> cd geekosaur you can do that with IO () too
05:57:47 <geekosaur> in that particular case, yes
05:57:49 <geekosaur> not all of them
05:58:01 <ertes> s4ke1: this is not only in the API, but also in the laws…  the Applicative laws are very similar to the Monoid laws, and those are the driving force behind something like MapReduce
05:58:02 <centril> geekosaur: I've just used  Control.Monad.void  thus far
05:58:12 <s4ke1> ertes: i guess with our current parEvalN :: [arr a b] -> arr [a] [b] we are doing exactly the "embarrasing parallel" case
05:58:12 <geekosaur> ok, next time I will find something pedantic. or just not bother explaining what's really going on, since it might annoy a pedant
05:58:55 <centril> s4ke1: hmm... does this extend to Vector and other things that are not linked lists (i hate linked lists...)
05:58:57 <centril> ?
05:59:00 <ertes> s4ke1: that's not surprising, because Arrow is equivalent to Category+Applicative, modulo laws =)
05:59:26 <s4ke1> entril: linked lists are good for this case
05:59:50 <s4ke1> centril: ^
06:00:02 <yeoman> uhm, why does haskell actually use lists?
06:00:05 <yeoman> i mean the world lists..
06:00:06 <centril> s4ke1: I have to ask... are you really sure (one should always ask this about linked lists..)
06:00:14 <yeoman> wouldn't it have been cleverer to call them "sets"?
06:00:17 <yeoman> i know there are also sets..
06:00:23 <ertes> yeoman: because they aren't sets
06:00:34 <yeoman> but what exactly is the difference between a list and a n-touple of same cardinality
06:00:35 <s4ke1> centril: we are using infinite lists a lot and rely on the nature of linked lists
06:00:43 <yeoman> i mean they both have order
06:00:51 <ertes> yeoman: tuples are a completely different beast in a statically typed language
06:01:09 <ertes> yeoman: example: write a function that concatenates tuples
06:01:17 <s4ke1> ertes: yeah, as of now i think the paper is not bad, but in a future version of the API we (or at least i) want to focus on other interfaces which are not Arrows
06:01:26 <ertes> yeoman: before that, what's the *type* of such a function?
06:01:34 <yeoman> okay, i see your point
06:01:42 <s4ke1> because we do not really require Arrows that much. The current API can easily be replaced with Category, Strong and Choice
06:02:06 <tdammers> yeoman: in a nutshell, tuple: fixed number of elements, heterogenous; list: varying number of elements, but homogenic (all elements must be of the same type)
06:02:22 <centril> s4ke1: the from  parEvalN :: [arr a b] -> arr [a] [b]   it seems like the input and output sizes match... so can't you do initial allocation for the result and then do fusion to get rid of temporary allocations?
06:02:35 <s4ke1> and some kind of lifting :: (a -> b) -> p a b
06:03:29 <s4ke1> centril: we can also do parEvalN (map (+) [1..]) [1..4] =
06:03:33 <s4ke1> [2..4]
06:03:58 <s4ke1> but i guess that might be possible
06:04:52 <centril> s4ke1: that's just  zipWith (+) ?
06:06:06 <s4ke1> centril: this is just an example. the input list of arrows can be infinite
06:06:14 <centril> =)
06:06:29 <s4ke1> then parMap is just parEvalN (repeat (+1)) [1..4]
06:08:04 <s4ke1> centril: we could however define parEvalN with any Traversable
06:08:18 <s4ke1> or sec
06:08:51 <s4ke1> at least i think that should be possible
06:09:06 <centril> s4ke1: that sounds nice, since Vector is Traversable
06:10:20 <s4ke1> centril: anyhow. gotta go
06:10:25 <s4ke1> nice talking to you
06:10:28 <s4ke1> and you as well, ertes
06:10:29 <centril> s4ke1: dito
06:12:02 <ertes> =)
06:13:45 <AWizzArd> Is „Parallel and Concurrent Programming in Haskell: Techniques for Multicore and Multithreaded Programming” (2013, by Simon Marlow) still worth to buy? Still pretty much up to date?
06:14:04 <ertes> AWizzArd: yes
06:17:27 <AWizzArd> Does Haskell have some function that checks if two values are identical in all aspects, that is: it is the same object (same memory address) with just two names. Like `eq` in Common Lisp or `is` in Python.
06:18:14 <merijn> AWizzArd: Not possible to do safely
06:18:30 <AWizzArd> k
06:18:30 <merijn> AWizzArd: And yes, Parallel and Concurrent Programming in Haskell is good
06:18:45 <AWizzArd> Will order it (:
06:18:48 <merijn> AWizzArd: There's reallyUnsafePtrEquality#, but the name should be a clue :p
06:19:18 <merijn> AWizzArd: What's the use-case for wanting that?
06:19:36 <King_of_the_Home> reallyUnsafePtrEquality# can be made less really-unsafe by enforcing strictness. From what I know, it never produces a false positive.
06:19:51 <tdammers> if you do that, you will inevitably produce implementation-specific behavior
06:20:04 <AWizzArd> merijn: I was just amused by http://9tabs.com/random/2017/12/23/evil-coding-incantations.html
06:20:04 <merijn> King_of_the_Home: Last time I asked in #ghc I was told it could produce false positives, but later discussions made me doubt it
06:20:08 <tdammers> in fact, the behavior might even change between builds with different compiler flags
06:20:37 <AWizzArd> In Python when x and y are -5 then x is y. But if both are -6 then x is not y.
06:21:14 <tdammers> AWizzArd: yes, but in Haskell, everything is conceptually by-value, and shared pointers happen mainly as optimizations, at the discretion of the compiler
06:21:45 <centril> ^ -- which allows GHC to be a highly optimizing compiler
06:21:48 <AWizzArd> tdammers: so in some cases ghc can generate efficient code, under the hood.
06:22:01 <AWizzArd> efficient comparison of values
06:22:03 <srid1> I see an interesting piece of open source software. Dig around the source code and realize it is written in PHP (https://github.com/wallabag/wallabag). Perfect! A great opportunity to write one in Haskell!
06:22:07 <centril> AWizzArd: GHC has a ridiculous amount of optimizations
06:22:17 <King_of_the_Home> I haven't really tried this, but maybe reallyUnsafePtrEquality# produces false positives if you unsafeCoerce it to a -> b -> Int#, and then check PtrEq between, say, Nothing and ()
06:22:29 <tdammers> AWizzArd: when you write, for example, let x = 5 + 6 in (x, x), the compiler is free to either substitute x into the tuple and evaluate the addition twice, or to precalculate the addition, store it in an intermediate value, and substitute *that* into the tuple
06:22:31 <King_of_the_Home> because unit constructors have identical internal memory representation
06:22:57 <merijn> AWizzArd: If you want "fun" evil things, the Haskell would probably "accursedUnutterablePerformIO"
06:23:00 <phadej> King_of_the_Home: there were recent discussion on haskell-cafe (IIRC) about false positives of reallyUnsafePtrEquality#, check it, I don't remember the conclusion
06:23:05 <tdammers> AWizzArd: in one case, both tuple elements would be "the same object", in the other case they would be two distinct objects that happen to hold the same value
06:24:19 <King_of_the_Home> In any case, reallyUnsafePtrEq# breaks referential transperancy, even if you're just using to to "short-circuit" an equality check.
06:24:19 <phadej> King_of_the_Home: But I don't know about that unsafe way, interesting point
06:24:34 <centril> Are there any real world use cases for trifunctors and + ?
06:24:59 <phadej> +?
06:25:14 <centril> phadej: and more (NFunctors where N > 2)
06:25:18 <simy93> ciao
06:25:32 <simy93> !list
06:27:39 <phadej> centril: well, we have (a, b, c) and could have Either3 a b c; but it's questionable if you really want to go above that
06:28:17 <centril> phadej: we could have, yes - but is that useful?
06:30:22 <phadej> It would be useful to talk about NFunctors generally, i.e. write single type-class for *, * -> *, * -> * -> * etc
06:30:25 <phadej> but we cannot at the moment
06:30:51 <phadej> I cannot find Conor McBrides post about the topic
06:32:42 <phadej> also in recursion-schemes I had lengthy discussion with edwardk about fixing bifunctors into functors, (and simlarly trifunctors into bifunctors), but we cannot really do that with current Haskell either https://github.com/ekmett/recursion-schemes/pull/23
06:35:08 <centril> phadej: this is more about "are there general containers that are trifunctors or quadfunctors" than what we can/can't do in Haskell
06:36:18 <phadej> centril: which isn't a composition of bifunctors? (like (a, b, c) ~ ((a, b), c)); I don't know
06:36:36 <KingoftheHobos> Question: in ghc-prim (or maybe base, can't recall) there exists thenIO to specialize (>>) for IO, but it isn't used in the actual instance. Why? And why doesn't more specialized stuff like mapIO or apIO exist, considering IO is so important?
06:37:15 <centril> phadej: right =)
06:37:27 <phadej> KingoftheHobos: it is
06:37:38 <phadej> (>>) = (*>); (*>) = thenIO
06:37:41 <merijn> KingoftheHobos: >> is (*>) which is implemented using thenIO
06:37:51 <KingoftheHobos> What? I could have sworn it wasn't.
06:38:00 <KingoftheHobos> I might be going insane, hold on.
06:38:05 <centril> phadej: I'm asking cause I wonder if I should go for Arbitrary3 , or just Arbitrary2 and Arbitrary1 =)
06:38:40 <phadej> centril: in QuickCheck there is Arbitrary2 and Arbitrary1
06:39:12 <phadej> I needed Arbitrary2 (because of pair instance), didn't need Arbitrary3
06:39:17 <KingoftheHobos> huh. I was insane.
06:39:20 <michalrus> Hey, what’s the best way to pass a list of types to a function, which will then call some method that is parametrized by `Proxy eachOfThoseTypes`?
06:39:24 <phadej> KingoftheHobos: welcome to the club
06:39:27 <KingoftheHobos> Still, why doesn't apIO or mapIO exist?
06:40:15 <phadej> KingoftheHobos: GHC is good in inlining, maybe someone checked but it wasn't any better
06:41:00 <KingoftheHobos> Curiously, the fmap instance for IO is explicitly x >>= (pure . f), and not simply liftM
06:41:11 <KingoftheHobos> maybe to help inlining?
06:41:33 <phadej> well, that code is @since 2.0
06:42:00 <KingoftheHobos> Of course, liftM is only exported by Control.Monad
06:42:11 <phadej> it is defined in that module
06:42:14 <phadej> GHC/Base.hs
06:42:20 <KingoftheHobos> hah
06:42:21 <KingoftheHobos> yes it is
06:42:23 <KingoftheHobos> nevermind
06:43:12 <centril> phadej: right - I checked QC, and doing it up to bifunctors covers maps and such, so I guess it is a good idea to not do trifunctors
06:43:45 <phadej> note, that (<*>) doesn't have INLINE pragme (good question why), so it's implementation is optimised and then used probably exported in unfolding
06:44:02 <phadej> yet fmap isn't {-# INLINEd #-} either
06:44:21 <phadej> dunno. KingoftheHobos you probably have to change those and run nofib to see if it matters or not
06:44:37 <phadej> if you have CPU time to spare, that will answer your questions :)
06:44:49 <phadej> centril: I'm intrested, what are you working on?
06:45:41 <geekosaur> and hope you don't manage to re-derive accursedUnutterablePerformIO >.>
06:45:54 <centril> phadej: on Arbitrary for a hypothesis/quickcheck-like port for Rust , as well as custom deriving for it
06:46:09 <phadej> centril: i see
06:46:47 <centril> phadej: https://github.com/Centril/proptest-derive   https://docs.rs/proptest/0.3.4/proptest/index.html   https://docs.rs/proptest-arbitrary/0.2.2/proptest_arbitrary/   if you are interested
06:47:36 <phadej> I try stay away from Rust (as I might get interested, and I don't need more think to be interested in right now)
06:47:43 <phadej> things*
06:49:17 <centril> phadej: haha :P
06:49:46 <centril> phadej: to make temptation harder for you: there's a lot of room for fast paced language design in Rust
06:50:49 <phadej> but I don't have real world use for Rust, I have no problem with occasional GC pauses ;)
06:52:43 <centril> ^,-
06:54:56 <lseactuary> where is monty?
06:54:59 <lseactuary> :)
06:56:29 <sphinxo> how is the nix ghcWithPackages implemented?
07:05:52 <Boomerang> sphinxo: https://github.com/NixOS/nixpkgs/blob/b2e9096f68172565b48be2c6b26b7a313c896c18/pkgs/development/haskell-modules/make-package-set.nix#L192
07:06:35 <Boomerang> I'm not sure exacly how it works but you basically pass self to the selectFrom function to set the current packages
07:07:57 <Boomerang> (not sure why I didn't link to master's version but it's implemented the same way :) )
07:19:00 <sphinxo> ahh ok
07:27:21 <ertes> sphinxo: it's based on fixed points
07:27:42 <ertes> > fix (\ ~(x, y) -> (y + 1, 6))
07:27:45 <lambdabot>  (7,6)
07:27:49 <ertes> like this
07:28:30 <ertes> this is – confusingly – referred to as object-oriented programming by some people =)
07:29:54 <ertes> @let override f x = let y = f y x in y
07:29:56 <lambdabot>  Defined.
07:31:08 <ertes> @let data Packages a = Packages { px :: a, py :: a, pz :: a } deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
07:31:12 <lambdabot>  Defined.
07:32:18 <ertes> > override (\self super -> super { px = py self + 2, py = 5, pz = pz super - 1 }) (Packages { px = 1, py = 2, pz = 3 })
07:32:21 <lambdabot>  Packages {px = 7, py = 5, pz = 2}
07:32:33 <ertes> sphinxo: ^ like this
07:32:45 <ertes> but in this particular case without the 'super' part
07:37:09 <Gurkenglas> When should `class Foo a where ...` become `class Foo where type A :: *; ...`?
07:38:41 <centril> Gurkenglas: was that a typo or are you really asking about null-param type classes with associated types?
07:38:55 <Gurkenglas> Other type parameters could also exist
07:39:33 <Gurkenglas> I was just giving a minimal example. I suppose there should also be a " | -> a " functional dependency on the left.
07:40:15 <Gurkenglas> "When should an associated type be a type parameter with a functional dependency on it?"
07:40:49 <centril> Gurkenglas: Assuming that other params also exist, then I'd say you should pick the latter when   Foo MyType Bar , Foo MyType Baz  is never a thing
07:41:02 <lyxia> it would definitely have taken me a while to understand that from that minimal snippet.
07:41:24 <Gurkenglas> centril, but don't functional dependencies say the same?
07:42:02 <centril> Gurkenglas: ah.. in that case always go with associated types if they are semantically equivalent imo
07:42:06 <centril> it just reads better
07:42:10 <Gurkenglas> lyxia, it scared the channel into giving me words to use to refine the question :P
07:42:41 <lyxia> haha
07:43:27 <Gurkenglas> I'm suprised, I found functional dependencies better because you can express more with them than with associated types and documentation works for them
07:43:43 <Gurkenglas> (ie you have to look into the source to find out what type is associated with an instance)
07:44:06 <centril> Gurkenglas: but what you can express with associated types is expressed in a more clear way syntactically, imo
07:44:19 <centril> documentation is more a matter of tooling
07:44:35 <centril> and has nothing to do with the language
07:44:51 * hackage tasty 1.0 - Modern and extensible testing framework  https://hackage.haskell.org/package/tasty-1.0 (RomanCheplyaka)
07:45:54 <centril> ^ -- Cool!
07:46:18 <Gurkenglas> If for a type class with four parameters and an associated type it turns out that the first three parameters already determine the associated type, is the function dependency way to express it then better?
07:46:22 * hackage compressed 3.11 - Compressed containers and reducers  https://hackage.haskell.org/package/compressed-3.11 (EdwardKmett)
07:46:30 <Gurkenglas> *functional
07:46:51 <phadej> luckily I adde dmy packags to skipped-tests section on Stackage, so I don't need to update everything (I was lazy last major bump, it paid off :P)
07:47:57 <centril> Gurkenglas: do you have some concrete use case?
07:48:40 <Gurkenglas> no, I'm just reaching because I was annoyed by https://www.stackage.org/haddock/lts-9.17/megaparsec-5.3.1/Text-Megaparsec.html#t:Token :P
07:49:34 <Gurkenglas> Surely "spaceChar :: MonadParsec Char e s m => m Char" is better than "spaceChar :: (MonadParsec e s m, Token s ~ Char) => m Char"
07:51:42 <centril> Gurkenglas: I'm having a hard time deciding that it is surely better
07:52:00 <centril> the former is shorter, but perhaps also less clear
07:53:39 <phadej> on that regard they are quite similar, e.g. there is: https://hackage.haskell.org/package/mtl-tf-0.1/docs/Control-Monad-Reader-Class.html
07:58:46 <Gurkenglas> Maybe when we depend on such a package or open a haddock link we should be able to specify which of the equivalent ways to write it we like better
08:02:27 <kakashiAL> is this a generator? x <- [1..10]
08:02:46 <kakashiAL> what how do you call/what do you say to the <- operator?
08:03:03 <liste> kakashiAL: <- is bind
08:03:11 <liste> kakashiAL: the actual operator for that is >>=
08:03:18 <liste> <- is just syntactic sufgar
08:03:22 <liste> sugar*
08:03:22 <hyperisco> <- is not an operator, it is part of the list comprehension syntax, or do-notation syntax
08:03:31 <kadoban> Don't think [1..10] is a generator
08:03:41 <hyperisco> everything you know is a lie
08:03:42 <liste> @undo do { a <- [1..10]; b <- [1..10]; return (a,b) }
08:03:43 <lambdabot> [1 .. 10] >>= \ a -> [1 .. 10] >>= \ b -> return (a, b)
08:04:01 <liste> that's what the desugared code looks like ↑
08:04:01 <hyperisco> actually it is part of the pattern guard syntax too
08:04:27 <kakashiAL> [x | x <- [1, 2, 3] ]   <---where is the generator here?
08:04:30 <MarcelineVQ> some people call <-  yeilds  in that context, especially in somethng like   [x | x <- [1..10]]     but it's actually called <-
08:04:38 <kakashiAL> [x | x <- [1, 2, 3], x mod 2 == 0 ]   <---where is the generator here?
08:04:39 <hyperisco> Haskell doesn't have generators
08:05:00 <kakashiAL> hyperisco: okay, I read that in an blog article :)
08:05:36 <hyperisco> "generator" refers to that yield stuff that they have in procedural languages
08:05:50 <kakashiAL> hyperisco: thats why I am asking :)
08:05:55 <hyperisco> and is a way for them to realise nonstrict semantics
08:06:32 <cocreature> lazyness doesn’t remove the need for all uses of generators. that’s why we have libraries such as pipes or conduit
08:06:41 <hyperisco> but, Haskell is nonstrict by default, so we don't need such a thing
08:06:55 <kakashiAL> so why do they call this [x | x <- [1, 2, 3] ]  "list comprehension" ?
08:07:01 <hyperisco> yes, there are libraries with a "yield" keyword that let you make coroutines
08:07:17 <kadoban> kakashiAL: It's gotta be called something
08:07:21 <hyperisco> or a "yield" definition I should say
08:07:46 <kakashiAL> kadoban: thats correct, could you explain the reason behind that?
08:07:52 <mnoonan> kakashiAL: it is a name inherited from existing notation in math: https://en.wikipedia.org/wiki/Set-builder_notation
08:08:04 <hyperisco> but, we don't have to involve pipes just to have a nonstrict list
08:08:20 * centril dislikes list comprehensions
08:09:11 <hyperisco> note also that "generator" typically refers to a language feature, whereas pipes/conduit are not language features
08:09:18 <kadoban> kakashiAL: I'm not really sure of the etymology if that's what you mean. A lot of tech/math words just come up because they were like sort of vaguely related and odd enough sounding that they weren't being used yet.
08:09:41 <kakashiAL> I know that it comes from math, something like {x | x in Z, x > 0} = {1, 2, 3, ...} = N   :)
08:09:51 <cocreature> https://stackoverflow.com/questions/1903980/why-list-comprehension-is-called-so-in-python/1904054#1904054 explains the name
08:10:22 * hackage singletons 2.4.1 - A framework for generating singleton types  https://hackage.haskell.org/package/singletons-2.4.1 (RichardEisenberg)
08:13:02 <kakashiAL> some other words for "comprehension" are: understand, range, seeing the view, to get, get the reason... (i hope you got what I mean)
08:13:16 <kakashiAL> I dont see this word coresponds to what we have
08:13:51 <kakashiAL> for me its a constructure with properties and conditions
08:13:59 <hyperisco> if you worry like this for every name you come across in math and programming you're going to have a bad time
08:14:21 <kakashiAL> hyperisco: nope, at the moment almos everything made sense
08:15:25 <centril> hyperisco: +1000
08:15:53 <kakashiAL> I guess they call it like this because it's a very **comprehensive** way to describe a sequence
08:15:59 * centril would like a haskell extension that gets rid of list comprehensions
08:16:42 <kadoban> I find them pretty convenient sometimes. Though I guess they're a tad redundant with the [] Monad instance
08:17:02 <hyperisco> people come up with an idea, then they have to call it something, so they come up with *whatever*. Sometimes a novel name, sometimes a name based on vaguely related meaning … you can't expect an alternate definition for a word/name to perfectly agree with another definition for the same word/name
08:17:34 <mniip> why the hell is it called a monad
08:17:39 <centril> kadoban: they are just not very functional... they mix  map filter join  into one big mess - just use those operations instead
08:17:41 <hyperisco> oh lordy lord
08:17:49 <kakashiAL> hyperisco: but the better I understand the name and its history, the better I can relate to it
08:18:05 <centril> mniip: https://english.stackexchange.com/questions/30654/where-does-the-term-monad-come-from
08:18:11 <mniip> centril, have you heard of MonadComprehensions
08:18:19 <hyperisco> I guess if you like to study etymology, but it aint going to teach you anything about list comprehensions.
08:18:19 <centril> mniip: not a fan
08:18:40 <mniip> I have no problem with list comprehensions with that in mind
08:18:47 <mniip> it's just binds, returns and guards
08:19:02 <centril> mniip: MonadComprehensions is on my naughty list
08:19:50 <mniip> % [() | () <- print "hi"]
08:19:50 <yahb> mniip: "hi"
08:20:23 <phz_> is there a valderman here?
08:20:26 <phz_> I’m patching selda
08:20:31 <phz_> they might be interested :D
08:20:41 <kadoban> centril: [x | x <- people, isNaughty x] -- what a naughty list might look like
08:21:34 <centril> kadoban: what you meant is:  filter isNaughty people
08:22:11 <hyperisco> it is like trying to learn about humpback wales by studying the meaning of "Mr. Splashy Pants"
08:22:21 * hackage agum 2.7 - Unification and Matching in an Abelian Group  https://hackage.haskell.org/package/agum-2.7 (JohnRamsdell)
08:22:36 <hyperisco> sorry UK, I meant whales
08:22:41 <mniip> centril, [f x y | x <- c; p x; y <- g x; q x y]
08:22:43 <mniip> I'll wait
08:22:51 * hackage cmu 1.11 - Unification in a Commutative Monoid  https://hackage.haskell.org/package/cmu-1.11 (JohnRamsdell)
08:23:26 * centril is saddened by mniip's use of one character identifiers
08:24:02 <loli> the x <- c part seems pointless
08:24:16 <hyperisco> meh, if you need more than one character then your program is too confusing
08:24:17 <centril> also... that syntax is ungodly and unclear
08:24:22 * hackage HappyTree 0.2018.1.8 - Type Safe and End to End Decision Tree  https://hackage.haskell.org/package/HappyTree-0.2018.1.8 (MarisaVeryMoe)
08:24:58 <hyperisco> why? it is a really straight-forward translation to do-notation or Monad notation
08:25:17 <mniip> loli, that probably means you don't understand what it does
08:25:37 <mniip> centril, oh yeah sorry all of those ; were meant to be ,
08:25:43 <loli> oh sorry mniip I read it backwrods
08:25:49 <loli> backwards*
08:25:50 <hyperisco> so, even if you didn't know how to read list comprehensions, you could learn through the translation.
08:25:52 <loli> I read c <- x
08:26:16 <hyperisco> it would still matter
08:26:36 <mniip> @let x x = [x | x <- x]
08:26:37 <centril> do notation has a clear flow to it being top-down , but I tend to use (>=>), (<$>), (>*>) when I can instead
08:26:39 <lambdabot>  Defined.
08:27:00 <MarcelineVQ> mniip: such shadow, so dark
08:27:07 <mniip> damn, that's gonna conflict with the Expr stuff
08:27:10 <hyperisco> list comprehensions are last, then left to right
08:27:41 <mniip> centril, I sure hope you don't mean evaluation flow :P
08:28:30 <centril> I more or less only use do notation for error/state/writer-like monads and never for lists
08:29:06 <centril> (well, lists and writers are kinda...)
08:31:52 * kakashiAL does not know what they talking about lists and monads but he wants to belong to the gang so he says something just to hide his lack of knowledge
08:31:58 <mniip> lists and writers are kinda what
08:31:59 <kakashiAL> monads are cool
08:32:30 <mniip> kakashiAL, yeah don't you just love how monoidal they are
08:32:41 <mniip> impressive, for an endofunctor
08:32:57 * centril doesn't get the joke
08:33:15 <kakashiAL> mniip: I understand what you can do with them and what they are good for, but didnt get the "list/monad" part
08:33:16 <mniip> there's no joke
08:33:31 <mniip> monads are monoids
08:33:33 <centril> mniip: but you formulated it like the prelude to a joke
08:33:45 <centril> mniip: yes, in the category of endofunctors... what's the problem?
08:33:51 <mniip> there's irony in that I'm trying to out kakashiAL's lack of knowledge
08:33:53 <MarcelineVQ> they're the most cromulon example of inductive right flux extensions that can be caught by abstraction filters
08:34:46 <mniip> MarcelineVQ, yeah and comonads are flux capacitors
08:34:56 <kakashiAL> O_O
08:35:10 <MarcelineVQ> sure, if you're running 3-phase
08:35:36 <kakashiAL> yes lets use more unknown words to get more complexity :P
08:36:59 <kakashiAL> "if someone use simple words to explain something, this person realy wants that you understand the point"  :/
08:37:08 <mniip> MarcelineVQ, what else would you use in the tri-state area
08:39:46 <shapr> mniip: is that a Phineas and Ferb reference?
08:39:57 <mniip> transitively yes
08:40:02 <mniip> Acme.Inator
08:40:07 <shapr> heh, ok
08:40:22 * hackage Ordinary 0.2018.1.8 - A Programming Language in Construction  https://hackage.haskell.org/package/Ordinary-0.2018.1.8 (MarisaVeryMoe)
08:41:02 <kakashiAL>  if <- is suggar for >>=, why does this not work? [ x | x >>= [1, 2, 3, 4, 5] ]
08:41:25 <mniip> you substituted the sugar wrong
08:41:28 <MarcelineVQ> because you stopped too soon in trying to understand it
08:42:05 <phadej> x <- [1,2,3]; foo ~~>  [1,2,3] >>= \x -> foo
08:42:24 <phadej> x <- [1,2,3] alone doesn't desugar into anything
08:44:58 <kakashiAL> phadej: could you please rewrite this: [ x | x <- [1, 2, 3, 4, 5] ]  with this: >>=
08:45:14 <phadej> [1,2,3,4,5] >>= \x -> return x
08:46:26 <kakashiAL> <- is called "bind" do you also call >>= "bind" ?
08:46:45 <liste> >>= is called bind
08:46:47 <phadej> the <- is bind in do notation, do { x <- [1,2,3,4,5]; return x }
08:46:59 <phadej> or *desugared* into bind (which is >>=)
08:47:02 <liste> <- just happens to result in bind in do notation
08:47:12 <phadej> in list comprehension nobody calls <- anything
08:48:51 * hackage generics-sop 0.3.2.0 - Generic Programming using True Sums of Products  https://hackage.haskell.org/package/generics-sop-0.3.2.0 (AndresLoeh)
08:48:59 <phadej> one might read [ x * y  | x <- [1,2,3,4,5], y <- [6,7,8,9,10] ] as "x * y where x ranges over [1,2,4,3,5] and y ranges over [6,7,8,9,10]
08:49:46 <pie_> has anyone ever tried putting a haskell repl in their program or should i just go with python?
08:49:49 <pie_> ( :P )
08:50:32 <phadej> usually we put some own language (made with haskell) into our programs ;)
08:51:17 <pie_> yeah but id like something full featured
08:51:41 <pie_> it would be cool if haskell could work, but otherwise im thinking python and/or scheme
08:51:47 <phadej> isn't PureScript or Elm good enough? :P
08:52:06 <pie_> ive never looked at either of those
08:52:07 <phadej> (I have no idea if you can use them as a library, without too much pain though)
08:52:42 <pie_> well *glances around cautiously* the former woulld "only" need a javascript engine :P
08:58:21 <wedify> pie_: would hint work?
09:00:27 <pie_> *shrug* maybe
09:00:31 <pie_> if it works, probably? :P
09:00:53 <pie_> can i find a list of apps using hint somewheer?
09:02:52 <thomashoneyman> Hey folks -- I'm curious if any of y'all have recommendations on topics or books to study to help write more rigorous software in Haskell. I'm thinking things like logic, algebra, or category theory (but I have no formal background in CS, so other options are open!)
09:03:07 <thomashoneyman> I wrote a question about this here: https://www.reddit.com/r/haskell/comments/7owcjg/ask_favorite_math_topicsbooks_youd_recommend_to/
09:04:09 <pie_> wedify, seems promising though thanks
09:04:54 <pie_> thomashoneyman, i cant really help but do you mean like with more expressive types and mathematical constrains or whatever, or better software engineering?
09:05:31 <kadoban> thomashoneyman: Something on algorithms seems like it'd be appropriate. Also I notice that you're talking about kind of a software focus and yet there's not a lot specifically about writing software on there. Even algorithms are somewhat hard to actually apply in most day-to-day software, and much that's on that list is even harder to connect directly.
09:06:01 <kadoban> Not that you shouldn't learn them, just saying ... that list doesn't look likely to me to help you write better software in most cases.
09:07:18 <thomashoneyman> pie_: Preferably both! In other words, having a better foundation for writing sound systems and leveraging the type system available to me.
09:08:28 <pie_> theres books that usually use dependent types on writing more formalized systems
09:08:41 <pie_> cant remember off the top of my head but theres a few usually recommended ones
09:08:53 <pie_> they usually use agda though i think
09:08:54 <thomashoneyman> kadoban: You're right, these aren't topics directly related to writing software. I have the vague idea I'd like to shore up my foundational knowledge on topics that underpin computer science
09:09:02 <kakashiAL> thanks phadej!
09:09:25 <thomashoneyman> As I do spend a lot of time at work learning more directly applicable stuff about writing better software
09:09:47 <thomashoneyman> > Something on algorithms seems like it'd be appropriate.
09:09:51 <lambdabot>  <hint>:1:56: error:
09:09:51 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:09:57 <thomashoneyman> ^ This would probably help me a lot, however.
09:10:49 <thomashoneyman> pie_: I've just found 'Type-Driven Development in Idris' which looks like a good resource.
09:12:01 <wedify> thomashoneyman: 'category theory for haskell programmers' covers some of the math that you hear about often
09:12:38 <thomashoneyman> wedify: The Milewski book?
09:12:55 <wedify> yeah
09:13:18 <thomashoneyman> Reading it right now! :) There are also some lovely talks on category theory on YouTube.
09:13:42 <thomashoneyman> It's been an enlightening topic to study, and not just because of its connections to programming.
09:13:45 <[exa]> about CT, would there be an actual dictionary that I could print out and stick to a wall next to the screen so that I don't get lost in CT discussions?
09:14:04 <kadoban> thomashoneyman: Depending on where your algorithms knowledge is at, I liked CLRS introduction to algorithms, though it's more about in an imperative setting I think you have to learn that first. And then for functional-specific the okasaki book is really good, purely functional data structures.
09:14:41 <[exa]> possibly with pics
09:16:35 <A001> Hey, could someone please explain why the reduction step [x := \x.x] in this image (https://i.imgur.com/Jrj5ip1.png) doesn't cause loop of the same substitution over and over?
09:16:42 <A001> Hope this is the right chan
09:17:06 <[exa]> A001: \x.x is `id', not a loop
09:17:48 <wedify> thomashoneyman: as for learning how to be more rigourous in developing code the agda book 'verifed functional programming in agda' and 'certified programming with dependent types' are both good books. they're not haskell but the lessons will transfer
09:18:18 <[exa]> A001: so, written simply, there you have (\z.(id id)z)
09:18:20 <thomashoneyman> wedify: thanks!
09:18:44 <[exa]> A001: id of id is id, so you have \z.id z, which is \z.z, which is id (again :])
09:19:23 <[exa]> A001: the example that _would_ loop instead would be something like (\z.((\x.xx)(\x.xx))z)
09:19:24 <lyxia> A001: don't substitute recursively.
09:20:13 <lyxia> A001: you have "x", replace "x" with "ANYTHING", you get "ANYTHING", if "ANYTHING" is "\x.x", you get "\x.x".
09:20:49 <[exa]> yeah that's the other concern, even though (\x.x)(\x.x) share a variable name, the first and second paren contains a completely different 'x'
09:21:08 <lyxia> Substituting recursively also wouldn't actually do anything for scoping reasons.
09:21:25 <lyxia> but it doesn't matter since we don't do it.
09:22:29 <[exa]> A001: maybe α-convert the second (\x.x) to avoid name clashes
09:22:47 <anu> hi, i want to learn haskell
09:23:25 <[exa]> anu: what form of learning do you like most? :]
09:24:14 <anu> learning through practice
09:24:58 <[exa]> anu: do you know any other programming language?
09:25:16 <A001> [exa] - ahh id of id is id yes I get it now, was trying to reason about that
09:25:26 <A001> this is just on paper btw
09:25:28 <A001> thanks for the help
09:25:33 <liste> @where learnhaskell
09:25:33 <lambdabot> https://github.com/bitemyapp/learnhaskell
09:25:46 <anu> yes i know c/c++, python, javascript etc but not any functional programming language
09:25:50 <[exa]> A001: np
09:26:37 <A001> to lyxia's point would anything ever recursively sub id?
09:27:33 <lyxia> A001: there is no free variable in \x.x to substitute
09:28:13 <lyxia> so even if you had the need for a substitution that continued recursively, it would stop after encountering id
09:29:33 <[exa]> A001: anyway, the substitution is usually defined so that it does not expand the substitued part (usually it's better to either have it prepared as fully expanded, or be lazy)
09:29:54 <[exa]> A001: related reading: occurrence check
09:31:16 <[exa]> ("occurs check" is more googlable I see)
09:31:19 <A001> lyxia, ofc re the free variable thanks
09:31:26 <A001> [exa]: thanks, will check that out
09:31:39 <pie_> thomashoneyman, not sure if these will help https://softwarefoundations.cis.upenn.edu/
09:33:34 <[exa]> anu: the traditional resources are "Real world haskell" and "Learn you a haskell" (both online, the first one is more practical)
09:35:07 <lyxia> both are old though
09:35:34 <lyxia> @where cis194
09:35:34 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
09:35:37 <kadoban> The traditional resources are pretty bad IMO. Especially LYAH. No exercises, kind of weird descriptions, slightly goofy tone.
09:36:00 <[exa]> kadoban: I liked it
09:36:05 <[exa]> ok nvm
09:37:13 <thomashoneyman> anu: I learned Haskell almost entirely from Haskell Programming from First Principles (as my first real programming language) and highly recommend it; its length is daunting, but most of the value is in the first half leading up to Ch. 17
09:37:22 <MarcelineVQ> cis is actually outdated too unfortunately, one of the early weeks runs into an AMP issue where a newtype isn't deriving Applicative :(
09:37:56 <lyxia> MarcelineVQ: ah :(
09:38:28 <thomashoneyman> thanks pie_! This looks almost exactly like what I've been looking for.
09:38:32 <MarcelineVQ> plain to solve if a person knows to ask about it but you'd have to know enough to know it's not your fault
09:41:33 <jmcarthur> fold is to foldMap as asum is to what? It looks like there isn't anything in Data.Foldable for this.
09:42:10 <jmcarthur> Which makes me sad, because the instance I'm using is Set.
09:42:39 <jmcarthur> And the target type does not have an Ord instance.
09:42:53 <Sonderblade> given a function like: (\x -> x `mod` 2 == 1) what would its inferred type signature be?
09:43:07 <kadoban> :t (\x -> x `mod` 2 == 1)
09:43:09 <lambdabot> Integral a => a -> Bool
09:43:11 <jmcarthur> And I wanted to be able to take advantage of the internal balancing Set already has.
09:43:24 <lyxia> :t ala Sum foldMap
09:43:27 <lambdabot> (Num b, Foldable t) => t b -> b
09:43:48 <glguy> > alaf Alt foldMap (\x -> [x,-x]) [1,2,3]
09:43:51 <lambdabot>  [1,-1,2,-2,3,-3]
09:44:02 <jmcarthur> ooh
09:46:10 <jmcarthur> :t alaf Alt foldMap
09:46:12 <lambdabot> forall k2 (t :: * -> *) (g :: k2 -> *) (b :: k2) a. (Monoid (Alt g b), Foldable t) => (a -> g b) -> t a -> g b
09:46:33 <glguy> The (Monoid (Alt g b)) hangs around due to polykinds
09:49:44 <jmcarthur> So this actually just uses a list with (++). :(
09:50:06 <glguy> What does that?
09:50:14 <jmcarthur> Alt
09:50:36 <glguy> Only if you use it with lists
09:50:47 <glguy> In that case yes, ++ is the expected implementation of <|>
09:50:59 <jmcarthur> But the implementation of Alt is a list of AltFs
09:51:02 <glguy> no
09:51:17 <jmcarthur> I must have found the wrong Alt then
09:51:18 <glguy> newtype Alt f a = Alt {getAlt :: f a}
09:51:28 <glguy> :t Alt
09:51:30 <lambdabot> forall k (f :: k -> *) (a :: k). f a -> Alt f a
09:51:34 <jmcarthur> Ah
09:51:36 <jmcarthur> Sure enough
09:52:28 <lyxia> There's two Alt in base and free
09:52:41 <jmcarthur> I see
09:52:58 <jmcarthur> I found a reference to Alt in Control.Lens.Wrapped and didn't realize there was another one
09:53:08 <jmcarthur> Thanks!
09:54:57 <ninjazoete> data Tuple a b = Tuple a b deriving (Eq, Show)
09:54:57 <ninjazoete> data Flip f a b = Flip (f b a) deriving (Eq, Show)
09:54:57 <ninjazoete> instance Functor (Flip Tuple a) where
09:54:59 <ninjazoete>   fmap f (Flip (Tuple a b)) = Flip $ Tuple (f a) b
09:55:01 <ninjazoete> — Usage
09:55:03 <ninjazoete> (fmap . fmap) toUpper $ Flip (Tuple "abc" 1)
09:55:18 <ninjazoete> Can someone help me understand why do I need to lift toUpper 2 times to get to "abc"
09:55:41 <ninjazoete> if Flip is a functor and it applies the fmap directly to Tuple's first argument
09:56:02 <ninjazoete> It is example from Haskell Book - I am scratching my head and can't get it
09:56:52 <ninjazoete> is it because String is a [Char] and also a functor ?
09:57:03 <ninjazoete> so first fmap goes straight to Flip and second goes for [] functor?
09:57:11 <kadoban> ninjazoete: So then once for the Flip and once for the [], yeah.
09:57:58 <ninjazoete> I think I chose a bad example that confused me even more
09:58:16 <ninjazoete> I should have just put normal argument :) ok thank you
09:58:30 <kadoban> Sure
09:58:37 <jmcarthur> Ugh, Haskell under Arch Linux without Stack is a disaster. I decided to see what the fuss with cabal new-build is, but it's so broken due to Arch.
10:02:25 <glguy> jmcarthur: is it more complicated than just not using GHC from Pacman?
10:08:10 <jmcarthur> Not really. It's just that I already have a lot of tooling around stack which was automatically using it, so I moved it and all of its products aside to try and make sure I didn't screw something up.
10:08:31 <jmcarthur> I deserve this.
10:09:45 <ryantrinkle> jmcarthur: have you considered trying nix?  i think you'd really enjoy it after a little time getting up to speed
10:10:20 <ryantrinkle> i remember there being some jank regarding nix on arch, but that was over a year ago
10:12:36 <jmcarthur> ryantrinkle: I played around with it in a VM and appreciated it, but didn't at the time feel like learning the language just to get a system I was comfortable with.
10:12:44 <jmcarthur> NixOS, that is
10:13:09 <jmcarthur> But I think a similar issue would exist with Nix alone, except with a bit less benefit.
10:16:23 <ryantrinkle> jmcarthur: yep, that's basically the long and short of it
10:16:41 <ryantrinkle> it does require the time investment to learn the language, but at least it's not a complex language
10:16:44 <ryantrinkle> basically scheme + records
10:17:25 <jmcarthur> The next time I set up a new system, I'm likely to seriously try NixOS.
10:17:43 <jmcarthur> I just don't want to uproot everything on my existing machine for now.
10:18:05 <ryantrinkle> yeah, it's definitely disruptive to switch distros
10:18:21 <ryantrinkle> i switched to nixos a couple of years ago because my ubuntu setup blew itself up for like the 3rd time
10:18:28 <ryantrinkle> due to a simple (non-dist) upgrade
10:18:42 <ryantrinkle> so i wasn't really abandoning anything of value :P
10:19:04 <jmcarthur> Yeah, that's how I felt leaving Ubuntu many years ago
10:19:57 <cocreature> jmcarthur: what exactly is the problem you’re running into?
10:20:10 <ryantrinkle> next time you're messing with nix(os), feel free to bounce things off me or let me know about any trouble you're having
10:20:40 <ryantrinkle> we use it for everything at obsidian, so i've gotten very accustomed to it
10:20:59 <ryantrinkle> and one of our guys is a core contributor, so i can always ask him if i don't know :P
10:22:27 <jmcarthur> cocreature: All the dynamic linking nonsense, plus issues with the ghc-pkg registry, files that don't exist in the right place, etc.
10:23:14 <cocreature> jmcarthur: step 1: get a statically linked version of cabal from somewhere (e.g. install it using stack). step 2. nuke everything haskell related that you installed via pacman except for ghc and ghc-static
10:23:19 <cocreature> things should be working then
10:23:22 <jmcarthur> Yeah yeah this is what I'm doing
10:23:51 <jmcarthur> It's what I did before. I was just seeing what a non-stack workflow looked like these days and then Arch attacked me from the shadows.
10:24:19 <cocreature> after that point you can have a non-stack workflow
10:24:50 <jmcarthur> cocreature: I had a bunch of tooling that was using stack automatically, which I didn't want, so I blew all my stack stuff away on purpose.
10:24:59 <jmcarthur> cocreature: Including the ghc it had installed, etc.
10:52:16 <pie_> since haskell and rust both have expressive types is there a "typeful" FFI? or would that not really work due to types being implemented differently so you still need to serialize things
10:53:14 <cocreature> pie_: sadly there isn’t. you have to use C as the lowest common denominator
10:54:22 <kadoban> pie_: That sounds quite interesting. But AFAIK one doesn't exist. I would imagine it'd be somewhat harder than it sounds like it would be since the type systems aren't really the same
10:55:48 <pie_> googling translating type systems doesnt yield anything relevant
10:59:33 <pie_> ( meanwhile https://internals.rust-lang.org/t/cross-language-safer-abi-based-on-rust/4691/10 )
11:08:49 <metahumo1> :r
11:19:37 <ongy> hm, https://www.fpcomplete.com/blog/2015/04/ghc-prof-flamegraph doesn't work on a .prof file generated from an application built with 8.2.2, did something in the .prof file format change?
11:19:51 <pie_> looks like this might support some simple stuff https://github.com/harpocrates/inline-rust
11:28:54 <pie_> dude....did this just pass a function pointer across the ffi? https://github.com/harpocrates/inline-rust/blob/master/examples/Integrate.hs i think thats kind of amazing? (i dont  know)
11:30:31 <parsnip> is there anything like (a -> b) -> (a -> Bool) -> Maybe b? or should i just write it out as if-then-else
11:30:52 <parsnip> so if f x then Just g x else Nothing
11:31:21 <kadoban> parsnip: Was there supposed to be an a or a Maybe a somewhere in there?
11:31:21 <athan_> guard b >> pure x?
11:31:54 <pie_> isnt like...filter supposed to do something like that? map filter? (idk what im talking about)
11:32:12 * athan_ whispers from the depths of hackage... "wither"
11:32:23 <ongy> you could hack it with filter and map, but if-then-else is cleaner
11:32:35 <parsnip> the function is actually `if isDigit c; then Just (digitToInt c); else Nothing`
11:33:20 <parsnip> yeah, i guess that is easiest to read
11:33:33 <MarcelineVQ> :t \f -> (bool empty . (pure .f ) <*>) -- was thinking about that the other day and making awful hard to read things
11:33:35 <lambdabot> Alternative f => (a1 -> a2) -> (a1 -> Bool) -> a1 -> f a2
11:33:47 <mnoonan> parsnip: that's way more unoffensive than the alternatives
12:00:10 <amalloy> when the documentation in Data.Text says that a function's performance is O(n/c), what is the c? specifically i'm looking at append in Data.Text.Lazy
12:01:07 <c_wraith> amalloy, I think it's chunk size
12:01:20 <c_wraith> amalloy, which is a constant most of the time.
12:01:22 * hackage continued-fraction 0.1.0.4 - Types and functions for working with continued fractions in Haskell  https://hackage.haskell.org/package/continued-fraction-0.1.0.4 (vmchale)
12:01:41 <c_wraith> amalloy, but not in every use case, so it's a detail worth mentioning
12:02:05 <amalloy> i see. that makes sense. thanks
12:05:22 * hackage continued-fraction 0.1.0.5 - Types and functions for working with continued fractions in Haskell  https://hackage.haskell.org/package/continued-fraction-0.1.0.5 (vmchale)
12:06:45 <pikajude> does cabal sdist preserve symlinks?
12:06:52 <pikajude> I don't think it does
12:14:12 <kakashiAL> from Cambridge - Programming in Haskell:  "the expression x <- [1..5] is called a generator“
12:14:56 <hyperisco> yup says so in the report https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
12:15:49 <tdammers> that's mildly misleading isn't it?
12:15:57 <kakashiAL> (just saying because someone told me that haskell does not have generators :)
12:16:01 <hyperisco> it doesn't
12:16:08 <tdammers> as in, x <- [1..5] isn't even an expression, is it
12:16:20 <hyperisco> that is a name it gives that piece of syntax
12:16:43 <tdammers> yes, but it also suggests that the piece of syntax is an expression proper, which it is not
12:16:50 <lyxia> they call it "qualifier"
12:17:05 <hyperisco> where?
12:17:19 <lyxia> first sentence
12:17:25 <hyperisco> no, where do they say it is an expr
12:18:53 <hyperisco> what I explained earlier is it has little to do with "generator" as seen in procedural programming languages, like C# and such
12:18:54 <mnoonan> that's interesting, they only call it a generator when it is in a list-comprehension, and give it no name as a statement
12:19:15 <hyperisco> it is a name in the grammar rules… that's it…
12:19:37 <tdammers> I think the intent is more to call it "the" generator of the list comprehension, rather than "a" generator
12:19:48 <hyperisco> if you want something like "generator" in other languages, look at pipes or conduit, which was also mentioned
12:19:52 <tdammers> as in, the term "generator" in Haskell simply doesn't mean anything outside of comprehensions
12:19:58 <fishythefish> you can have multiple generators in a list comprehension, so "the" may not be appropriate
12:20:12 <tdammers> ah yes, fair point
12:20:25 <tdammers> still, it's only meaningful in a list comprehension context
12:20:35 <tdammers> both the syntax itself and the "generator" name
12:20:54 <fishythefish> well, the syntax also may apply in a do block
12:21:03 <fishythefish> or a pattern guard
12:21:18 <tdammers> it means slightly different things there though
12:21:26 <fishythefish> it does, but that's semantics, not syntax
12:21:26 <hyperisco> just because it is the same symbols does not mean it is the same grammar rule
12:21:34 <hyperisco> yes it is syntax -.-
12:21:51 <kakashiAL> hyperisco: not attacking you, I am also agreeing with you, just wanted to point out what my sources are, I mean even Dr. Erik Meijer recommends that book :)
12:21:59 <hyperisco> that is like saying the 'case' in  case  and  "case"  are the same thing syntactically, and they are not
12:22:21 <cocreature> kakashiAL: that guy also recommends that you use hugs :P
12:22:31 <fishythefish> hyperisco: that's an incorrect analogy
12:22:57 <fishythefish> both list comprehension generators and do blocks have a syntactic element "pat <- exp"
12:23:14 <fishythefish> the syntactic element is identical, but it has different semantics in each location
12:23:15 <kakashiAL> cocreature: I didnt know who I can trust, so this "guy" is a doctor and well know in the haskell community, so I went with that :/
12:23:34 <hyperisco> fishythefish, and it is *not* called a generator
12:23:54 <fishythefish> where did I say it's called a generator everywhere?
12:23:57 <kakashiAL> hyperisco: you have the book?
12:24:20 <hyperisco> fishythefish, we have very different ideas of "syntax" then
12:24:27 <fishythefish> what's your idea of syntax?
12:24:34 <hyperisco> the grammar
12:24:49 <fishythefish> I agree
12:25:02 <mnoonan> are you sure? :)
12:25:13 <kakashiAL> hyperisco: yes? no? maybe?:)
12:25:45 <mnoonan> the two forms that look like "foo <- bar" correspond to different rules of the grammar
12:26:06 <hyperisco> kakashiAL, no I do not
12:26:57 <kakashiAL> hyperisco: it is THE haskell book, recommended like crazy on amazon and even every haskell college paper reference it
12:27:08 <kakashiAL> and the Dr. Meijer thing :P
12:29:34 <fishythefish> Dr_mnoonan: perhaps that's where hyperisco and I differ, then
12:29:59 <fishythefish> e.g. I would say that let bindings have the same syntax even across different rules in the grammar, but presumably hyperisco would not
12:30:34 <kakashiAL> hyperisco: if you have this: [x | x <- [1..100], guard]   <---it makes sense that they call "x <-[1..100]" generator, because it generates values. The conditions that come after are called guards (in the book at least) and they check what "generated" value can be or not be in the list
12:31:09 <hyperisco> kakashiAL, it makes sense exactly because The Haskell Report 2010 names that part of syntax a "generator"
12:31:13 <kakashiAL> I also guess that they dont mean it like generator in procedural languages like in python or javascript, just generator "that creates stuff"
12:31:53 <kakashiAL> hyperisco: so now you do agree that its an generator?:)
12:33:21 <hyperisco> if we want to argue naming then perhaps it should be called a "reader", because doesn't [1..100] generate the values? just a thought
12:33:37 <hyperisco> maybe call it an "iterator"
12:33:53 <kakashiAL> "<- is read as is drawn from"  <---according to the book, but here someone told me that you read it as "binds"
12:34:16 <MarcelineVQ> <- alone isn't anything
12:34:16 <kakashiAL> ( hyperisco: if you changed your opinion about that I am happy :)
12:34:40 <cocreature> call it “warm fuzzy thing” and find something better to spend your time on than debating nomenclature :)
12:34:54 <kakashiAL> MarcelineVQ: you mean <- reads as "bind" or "is drawn from" according where it is used/ its context ?
12:35:18 <yoho> yes context matters, no nomenclature isn't really worth debating at this level
12:35:22 <MarcelineVQ> yes, in your parlance, I wouldn't call it bind or drawn form myself, I read it as <-
12:35:48 <kakashiAL> cocreature: why is everything a provocation, discussion or debating for you? I just asked "what is this" or "what are they calling it" :/
12:35:51 <MarcelineVQ> kakashiAL: did you find time to read the haskell 2010 report yet?
12:36:34 <kakashiAL> MarcelineVQ: its pretty hard stuff, without a ton of extra knowledge and without mastering the basics its very very hard, but each day I invest on the basics it becomes easier
12:36:38 <hyperisco> kakashiAL, as long as you aren't confused that they are the same as generators such as in C# or Python, then we agree
12:37:10 <cocreature> kakashiAL: oh I didn’t mean “debate” as a negative thing. but you are talking about this for ages and I highly doubt that anything useful will come out of it
12:37:16 <Gurkenglas> How do I list the fininte minor diagonals of a twice infinite [[a]]?
12:37:32 <mnoonan> the thing is, this isn't really part of the basics. it doesn't help with understanding how the program behaves, it doesn't give you a workable analogy to something from another language, it isn't even commonly agreed on what to call it (clearly)
12:37:38 <mnoonan> so where is the benefit?
12:38:15 <kakashiAL> hyperisco: I accept your apology :P
12:38:52 <lyxia> Gurkenglas: what are the finite minor diagonals
12:39:40 <Gurkenglas> The minor diagonals are those that go like / and are thus finite
12:40:09 <kakashiAL> MarcelineVQ: one of many reasons why I want its name is to google more stuff about it and can talk about it
12:40:11 <Gurkenglas> As opposed to those that go like \. Twice infinite [[x]] means something like repeat (repeat 0)
12:40:22 <lyxia> Ok.
12:40:30 <hyperisco> Gurkenglas, check out Data.List.ZigZag
12:41:02 <hyperisco> Gurkenglas, actually I don't think it is defined on infinite product… (data-list-zigzag btw)
12:41:29 <metahumor> Gurkenglas: try if "diagonal" from Control.Monad.Omega would help
12:41:56 <metahumor> you'd have to define how the indices of your minor diagonals are defined
12:42:01 <hyperisco> Gurkenglas, the problem is enumeration order. Because you are infinite dimensional, you can never get past the first diagonal
12:42:19 <MarcelineVQ> kakashiAL: if you abstract that idea a step you can instead google about resrouces that take you through all the basic terms and ideas
12:42:28 <metahumor> unless if you have a [(0,0), (1,0), (0,1), (2,0), (1,1), (0,2), ...]
12:42:54 <metahumor> and you want [[(0,0)], [(1,0), (0,1)], [(0,2), (1,1), (2,0)], ...]
12:42:59 <hyperisco> Gurkenglas, actually that explanation is wrong, let me retry… digging up my notes here
12:43:37 <hyperisco> Gurkenglas, consider the infinite product [[0],[0],...] i.e. all factors are [0] then obviously the diagonals are [[0,0,...]]
12:43:43 <mnoonan> :t \n xss -> (map head xs, map tail xs ++ rest) where xs = take n xss; rest = drop n xss
12:43:46 <lambdabot> error: parse error on input ‘where’
12:44:00 <hyperisco> Gurkenglas, now consider [[0,1],[0,1],...] i.e. all factors are [0,1] then what are the digonals?
12:44:09 <hyperisco> Gurkenglas, the problem here is it is impossible to list them all!
12:44:14 <mnoonan> oops, well, anyway :) that gives you an Int -> [[a]] -> ([a], [[a]])
12:44:38 <mnoonan> you can chain them together to get what you want, I think
12:44:41 <Gurkenglas> Something that maps "zipWith zip (repeat [0..]) (map repeat [0..])" to "[[(x, n-x) | x <- [0..n]] | n <- [0..]]"
12:44:47 <hyperisco> Gurkenglas, since you've just asked to list every infinite binary sequence which is provably impossible
12:45:32 <Gurkenglas> hyperisco, https://sketchtoy.com/68485113 each of these diagonals is one list entry
12:45:52 <hyperisco> Gurkenglas, do you have an infintary product or finite product?
12:46:12 <Gurkenglas> Where did I say product?
12:46:30 <mnoonan> hyperisco: he's just talking about enumerating Nat x Nat
12:46:31 <hyperisco> Gurkenglas, you are listing the diagonals... that is Cartesian product, unless I grossly misunderstood you
12:46:31 <lyxia> > let f ((x : xs) : xss) = [x] : zipWith (:) xs (f xss) in take 5 $ f [[(i, j) | i <- [0 ..]] | j <- [0..]]
12:46:34 <lambdabot>  [[(0,0)],[(1,0),(0,1)],[(2,0),(1,1),(0,2)],[(3,0),(2,1),(1,2),(0,3)],[(4,0),...
12:47:11 <hyperisco> also the mirage effect on those lines is tripping me out
12:47:16 <Gurkenglas> Oh, right. lyxia wins the prize.
12:47:26 <Gurkenglas> The prize is one [].
12:47:30 <hyperisco> I wish this problem ever made any sense…
12:47:59 <Gurkenglas> hyperisco, there's a vibration setting, just set it to 20
12:48:19 * lyxia eats the [].
12:48:20 <hyperisco> if you just want the 2-partition sums then yes, check out data-list-zigzag as it does exactly this
12:48:21 * hackage continued-fraction 0.1.0.6 - Types and functions for working with continued fractions in Haskell  https://hackage.haskell.org/package/continued-fraction-0.1.0.6 (vmchale)
12:48:43 <hyperisco> and generalises to n-partitioning
12:50:40 <hyperisco> your initial example was  repeat (repeat 0)  which is  [repeat 0]
12:51:13 <hyperisco> er, actually, no sorry,  repeat [0]  is  [repeat 0]
12:51:27 <mnoonan> what?
12:51:33 <mnoonan> map length, etc etc
12:51:42 <hyperisco> repeat (repeat 0)  has a cute solution of  repeat (repeat 0)  :P
12:51:55 <hyperisco> but I was showing you that  repeat [0,1]  is impossible
12:52:25 <hyperisco> any finite product is possible, even with infinite factors
12:52:51 <hyperisco> there are different ways to enumerate it… Omega is one, and ZigZag is another I made which specifically gives you the diagonals you want
12:53:20 <hyperisco> I needed to develop that for a search problem where I needed the product to retain similar ordering to the factors
12:54:45 * hyperisco feels like nothing he said made any sense or any difference
12:55:08 <hyperisco> feels daut man
13:05:51 * hackage util 0.1.5.0 - Utilities  https://hackage.haskell.org/package/util-0.1.5.0 (MatthewFarkasDyck)
13:09:22 * hackage pretty-show 1.6.16 - Tools for working with derived `Show` instances and genericinspection of values.  https://hackage.haskell.org/package/pretty-show-1.6.16 (IavorDiatchki)
13:11:09 <orion> What is special about top-level definitions?
13:11:49 <ph88> nice one jle` front page
13:14:36 <hyperisco> orion, you can export them from modules, and some definitions are only allowed at top level
13:15:50 <orion> hyperisco: Initially, the top level definitions are thunks. After they get evaluated, their definition is overwritten to something more "normal". Do I understand correctly?
13:16:09 <hyperisco> I can't evaluate that
13:18:30 <bkzhang> exit
13:18:33 <shapr> NO
13:18:42 <shapr> dang
13:22:11 <metahumor> ph88: what did jle` do?
13:22:50 <ph88> metahumor, https://news.ycombinator.com/ 	Typesafe Neural Networks in Haskell with Dependent Types (jle.im)  133 points by KirinDave 15 hours ago | hide | 17 comments
13:22:58 <metahumor> ah nice
13:29:14 <koz_> jle` does many cool things - gonna have to read that one now.
13:34:19 <unclechu> hey guys, about type-level, what is purpose of `SomeNat` could I for instance add `SomeNat` to some `Nat` and get runtime value with result of this addition?
13:34:53 <ph88> i heard ReLU is prefered over sigmoid these days
13:35:34 <unclechu> I know that this addition would happen in runtime, because `SomeNat` isn't known at compile time of course
13:35:34 <lyxia> unclechu: yes, though you might need a plugin for that
13:35:55 <unclechu> but anyway, could I do this, kinda, type-level addition?
13:36:06 <hyperisco> unclechu, perhaps. Depends on what you want to do. In fact I don't really know why one would care for SomeNat.
13:36:17 <unclechu> lyxia: by `plugin` do you mean some package?
13:36:22 <ph88> unclechu, yes you can do type level addition
13:36:24 <hyperisco> maybe it plugs into some other interface… anyways all it does is store the KnownNat dict for a particular n
13:36:57 <hyperisco> and the only thing that dict is good for is natSing, which is just good for a Nat, so… may as well just use Nat… as far as I am concerned
13:39:27 <ph88> is hmatrix on par with numpy for performance ?
13:39:29 <lyxia> unclechu: https://hackage.haskell.org/package/ghc-typelits-knownnat
13:40:37 <lyxia> plugins are user-defined extensions of the compiler
13:41:05 <ph88> code like     data BlaBla where   .. does the where part make it a GADT ?
13:41:05 <unclechu> thank you guys, i'll dig to this
13:41:25 <lyxia> ph88: every ADT is a GADT
13:41:38 <ReinH> some are just more GADT than others
13:41:45 <glguy> The where part makes it use GADT syntax
13:41:45 <hyperisco> if you want to use that syntax you have to enable the GADT extension tho
13:42:07 <ph88> :D
13:42:10 <glguy> If you just want the syntax and not the actual generalization you can enable GADTSyntax
13:42:36 <hyperisco> now that's being picky.
13:42:43 <ph88> when would you want the syntax and not actual generalization ?
13:43:18 <glguy> Turning on GADTs forces you to use MonoLocalBinds
13:43:45 <glguy> so if you just want the syntax and not the type system extension or the monobinds then you can just turn on the syntax
13:43:55 <ph88> oh ok
13:58:52 * hackage hspec-dirstream 0.1.0.0 - Helper functions to simplify adding integration tests.  https://hackage.haskell.org/package/hspec-dirstream-0.1.0.0 (vmchale)
14:05:22 * hackage ats-format 0.1.0.20 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.20 (vmchale)
14:05:50 <yeoman> hi.. it's me
14:05:51 <yeoman> still sad
14:05:56 <yeoman> The type signature for ‘initialGameSate’
14:05:57 <yeoman>       lacks an accompanying binding
14:06:02 <yeoman> what does this mean :(
14:06:33 <yeoman> oh.. just a typo
14:11:49 <yeoman> data GameState = Game { board :: Board, activePlayer :: Symbol }
14:11:59 <yeoman> what does this line actually mean?
14:12:17 <timhae> Hey, is there a shorter/more elegant way of traversing a list of numbers and doubling every second number from the right? Using length so often feels kind of bad. Here is what I have: http://lpaste.net/361476
14:12:31 <glguy> yeoman: Is there some particular part you don't understand?
14:12:53 <bennofs[m]> It means that a value of type GameState has two record fields: board of type Board and activePlayer of type Symbol
14:13:17 <yeoman> what exactly is "Game"
14:13:27 <orion> timhae: https://www.stackage.org/haddock/lts-10.3/base-4.10.1.0/Data-List.html#v:unzip
14:13:57 <orion> You could unzip the list, double one but not the other, then rezip them.
14:14:10 <yeoman> bennofs[m]: that's how i got it too, and that particular code has an "initial game state" function
14:14:16 <LKoen> timhae: for starters, you could keep an extra argument to your function to tell the next call whether it's on an odd or even number
14:14:18 <MarcelineVQ> timhae: if you ask the length only once and then decide which order to double things in you'll only us length once
14:14:19 <yeoman> that calls(???) game
14:14:34 <yeoman> and the word "Game" alone is nowhere to be found, but there
14:14:44 <yeoman> confuses me
14:14:49 <glguy> That's where Game is being declared
14:15:00 <bennofs[m]> yeoman: Game is the constructor that creates a new value of type GameState.
14:15:11 <yeoman> wow, that's hell of confusing
14:15:14 <yeoman> i mean..
14:15:23 <yeoman> i understand Symbol X = Y | Z
14:15:30 <yeoman> i mean data X = Y | Z
14:15:40 <timhae> thanks for the tips, will try my luck!
14:15:48 <yeoman> but why should a undefined constructor stand on the right side of the equals sing
14:15:49 <glguy> yeoman: For a lot of this stuff you won't be able to guess what things mean, you'll need to find some introductory book or website about Haskell or the Haskell Report and read it
14:16:06 <yeoman> glguy: i read haskell for a greater good, but without trying code much
14:16:12 <bennofs[m]> you'd use it like: `Game theBoard theSymbol` or `Game { board = theBoard, activePlayer = thePlayer }`
14:16:24 <yeoman> i saw data constructors, but i get confused by data & type
14:16:36 <yeoman> that's why i am trying to write tictactoe alone.. but i get stuck with the simplest tasks
14:17:00 <yeoman> i thought the recordsyntax was just so you can ditch the order
14:17:14 <yeoman> data Game = ActivePlayer Board
14:17:24 <yeoman> how would i make an initial configuration out of this
14:18:15 <yeoman> while ActivePlayer is X or O and Board is [[ActivePlayer]
14:20:46 <yeoman> wouldn't "X [[]]" be a valid start?
14:21:37 <Gurkenglas> yeoman, what board value would correspond to someone putting an X in the middle? your definition is btw written "data Game = Game ActivePlayer Board"
14:22:18 <yeoman> why do i need to write that double?
14:22:20 <yeoman> the word Game.
14:22:46 <wedify> on the left you are naming a type, on the right you are naming a constructor
14:23:08 <glguy> In both cases you're naming a constructor, one the left case you're naming the type constructor, in the right case the value one
14:23:11 <Gurkenglas> You could also have done "data Game = Foo ActivePlayer Board", which would have defined a function Foo :: ActivePlayer -> Board -> Game
14:23:21 * hackage hspec-dirstream 0.1.0.1 - Helper functions to simplify adding integration tests.  https://hackage.haskell.org/package/hspec-dirstream-0.1.0.1 (vmchale)
14:23:30 <yeoman> i didn't even get that while reading the book. okay.
14:23:31 <sqooq> hi
14:23:33 <sqooq> folk
14:23:37 <sqooq> folks
14:23:40 <glguy> type and value constructors live in different namespaces, they are separate, so you have to name both
14:24:01 <yeoman> yeah i got that now
14:24:16 <sqooq> wedify, I thought and thought all night. Unless I just don't understand memoization, I don't think there's anything that's gonna really work well for my thing except for ST.
14:24:34 <sqooq> I'm going to try and write a sort of conceptual example of what would explicitly need to be done
14:24:36 <sqooq> but not sure how to do it
14:25:01 <yeoman> data Game = Game ActivePlayer Board deriving (Show)
14:25:03 <yeoman> this is how it looks now
14:25:08 <yeoman> how do i get my initial game state now?
14:25:23 <yeoman> i can't just write "Game X [[]]" as it seems
14:26:28 <yeoman> oh , i can
14:26:33 <ph88> :D
14:26:45 <ph88> yeoman, can you pastebin the code you have so far ?
14:27:23 <yeoman> sure
14:28:05 <yeoman> https://paste.pound-python.org/show/lUjkOxSIFuwGAvcFLQM4/
14:28:10 <yeoman> trying to print the board now
14:28:48 <yeoman> rather the game state
14:29:07 <wedify> sqooq: you can just write examples using ST and i will try to help you to see if it is really neccesary to use it
14:29:26 <yeoman> i can't pre-fill the array with "Nothings" right?
14:29:41 <ph88> yeoman, i think you can
14:30:04 <yeoman> uyheah that works.
14:30:04 <ph88> the "array" is called a list in haskell
14:30:14 <yeoman> i will never get used to that, i knoiw that
14:30:18 <yeoman> but [] is array to me :D
14:30:44 <timhae> another question: can somebody explain why there is this a in this signature: length :: Foldable t => t a -> Int . Is this a special case with Foldable?
14:30:52 <ph88> ye but in C an array in continious memory .. but [] in haskell is a linked list .. so every element has a pointer to the next
14:30:58 <yeoman> i know that, really
14:31:25 <yeoman> i understand that [a] ++ super_long_list is basicially cost-free
14:31:30 <yeoman> and appending not.
14:31:38 <ph88> timhae, "a" is "any type"  .. "any type" in the "foldable container"
14:32:05 <timhae> ph88, thanks :) I figured it would be something like this
14:32:06 <yeoman> ph88: how do i access the Board now, if i get that Game thingie as parameter
14:32:23 <sqooq> wedify, http://lpaste.net/361477
14:32:31 <sqooq> i tried my best to explain
14:32:47 <sqooq> the >>> may exist, but I'm overloading it's meaning just to show conceptually what would need to happen
14:33:03 <ph88> yeoman, let's say you have  gameParam   as your Game parameter, then replace   gameParam by  (Game player board)
14:33:51 <ph88> yeoman, i suggest that you rename your data constructor to  MkGame  .. it's easier to give your type constructor and data constructor different names when you are starting with haskell
14:34:01 <ph88> data Game = MkGame ActivePlayer Board
14:34:08 <yeoman> okay, done
14:34:29 <yeoman> i write a function now named "showGame" :: Game -> [Char]
14:34:38 <yeoman> how do i get the activeplayer of the Game?
14:34:48 <ph88> String is synonym to [Char]
14:35:01 <yeoman> okay.
14:35:07 <ph88> yeoman, let's say you have  gameParam   as your Game parameter, then replace   gameParam by  (Game player board)
14:35:15 <ph88> player is of type ActivePlayer
14:35:30 <yeoman> i don't follow :(
14:35:40 <yeoman> showGame g = "Current Player is"
14:36:08 <ph88> showGame (MkGame activePlayer board) = "Current Player is: " ++ (show activePlayer)
14:36:28 <sqooq> wedify, this might be better http://lpaste.net/361478
14:36:32 <yeoman> can i rename those?
14:37:03 <ph88> you replace "g" which is the variable of your game" by it's parts  (MkGame activePlayer board)   this is called pattern matching
14:37:25 <ph88> you can also write (MkGame x y)  .. only the name of the data constructor needs to be the same
14:38:19 <yeoman> "Current Player isX" UHYEAH
14:38:22 <yeoman> im so clever
14:38:44 <yeoman> hows that called
14:38:49 <ph88> g  is  equal to  (MkGame activePlayer board)   if you still want to access the entire game you can use alias with @ like this:   g@(MkGame activePlayer board)
14:38:56 <yeoman> that x (constructor a b) = "something" ++ a
14:39:00 <yeoman> is that, pattern matching?
14:39:05 <fishythefish> since you're using record syntax, you could alternative do: showGame g = "Current Player is: " ++ activePlayer g
14:39:09 <fishythefish> alternatively*
14:39:16 <ph88> yeoman, yes the   (constructor a b)    is the pattern match
14:39:18 <fishythefish> yes, that's pattern matching
14:39:26 <yeoman> uhyeah
14:39:29 <yeoman> that's the biggest leap
14:39:31 <yeoman> i took in haskel
14:39:33 <yeoman> lever
14:39:35 <yeoman> :D thanks
14:39:39 <yeoman> im so happy
14:40:04 <ph88> yeoman, when you have a type that has a choice (sum type) like   data MyChoice = FirstChoice Int | SecondChoice String .. you can pattern matching like    displayChoice (FirstChoice int) = blalba    displayChoice (SecondChoice string) = foofoo
14:40:30 <yeoman> so it acts.. kinda like a name?
14:40:32 <ph88> so 2x  displayChoice below each other
14:40:39 <ph88> what name ?
14:40:47 <yeoman> what is "FirstChoice"
14:40:49 <yeoman> is it a type..
14:40:56 <yeoman> what is it?
14:40:59 <fishythefish> it's the name you've given a constructor
14:41:01 <ph88> it's a data constructor for type MyChoice
14:41:13 <yeoman> and what is SecondChoice?
14:41:18 <fishythefish> another constructor
14:41:21 <ph88> it's just something i came up with
14:41:22 <dmwit> No, it is a (value) constructor, as defined by the data declaration "data MyChoice = FirstChoice Int | SecondChoice String" from earlier in his message.
14:41:22 <yeoman> for the same thing??
14:41:45 <ph88> MyChoice must be EITHER   FirstChoice or SecondChoice   it can not be both
14:41:47 <yeoman> i get it.. deciding datatype means multiple constructors
14:41:49 <dmwit> yeoman: lambdabot is about to blow your mind.
14:41:51 <dmwit> ?src Maybe
14:41:52 <lambdabot> data Maybe a = Nothing | Just a
14:42:00 <yeoman> no, i knew that :D sorry.
14:42:06 <yeoman> but Just is a constructor
14:42:09 <yeoman> Nothing is just a "value"
14:42:11 <fishythefish> and so is Nothing
14:42:15 <dmwit> Nothing is also a constructor.
14:42:15 <yeoman> i got that by your explanation
14:42:18 <yeoman> i see.
14:42:23 <yeoman> what does it construct
14:42:25 <yeoman> inb4, nothing
14:42:27 <fishythefish> Nothing
14:42:28 <dmwit> Maybe a's.
14:42:38 <yeoman> that's funny
14:42:50 * yeoman draws a board
14:43:16 <ph88> yeoman, you can thing of the data constructor as some kind of container .. but in case of Nothing .. it's a container with nothing extra in it. But in case of   Just you can put "a" (any type) in it
14:43:36 <dmwit> (Nothing is also a value, for what it's worth. You were not wrong about that. Just is also a value.)
14:44:29 <noobyGuy> friends is it true that it is very very hard to know the basics of haskell to write/solve competitve problems that are usualy askedin job interviews
14:44:44 <ph88> "Nothing" is a value of type (Maybe a),  "Just a" is a value of type (Maybe a),   "Just" is a data constructor of type   :: a -> Maybe a
14:44:46 <noobyGuy> in one month*
14:44:50 <dmwit> It is very very hard to know the basics of any language, Haskell included.
14:45:07 <fishythefish> harder still to ensure your interviewer can read Haskell
14:45:33 <ph88> noobyGuy, yes it's very very hard, one month is not enough to show of in job interviews
14:45:37 <[exa]> noobyGuy: depends on what job you're applying for
14:46:14 <dmwit> noobyGuy: It is probably worth reading http://norvig.com/21-days.html . He expresses there my instant reaction to anybody asking "How do I learn X in Y days?".
14:46:32 <ph88> day by day ? :D
14:46:43 <noobyGuy> ph88:  [exa]  web devloper jobs and I dont want tomaster language as I know it takes years
14:46:49 <noobyGuy> I am asking to know basics
14:46:50 <dmwit> Answer: first make sure Y>3000.
14:47:04 <noobyGuy> dmwit: ^^
14:47:10 <troido> is there a way to check whether a unicode character is printed as halfwidth or fullwidth when printed in a monospace font?
14:47:27 <glguy> If your goal is to get any job at all as a web developer and you don't know any Haskell yet, and you have one month, then you'll be more successful with a different langauge
14:47:42 <ph88> noobyGuy, i didn't see any book yet which let's you learn basics fast
14:47:47 <dmwit> troido: I don't think there's a really great one. Depending on how you want to use it, pango has some font metric stuff. I think brick (or maybe vty) has some stuff for taking a guess about what terminals will do.
14:47:52 <glguy> troido: Not really, no. The answer varies by terminal emulator, unicode version, and bug
14:48:07 <yeoman> if Nothing is a constructor
14:48:10 <yeoman> why does it return Maybe
14:48:14 <noobyGuy> glguy:  which languge js ?/ my goal is not job
14:48:19 <yeoman> because it's a maybe constructor?
14:48:21 <yoho> it constructs a value of type Maybe a
14:48:21 <dmwit> yeoman: What do you think it should return instead?
14:48:25 <yeoman> that.s actually confusing
14:48:27 <noobyGuy> but to solve problems
14:48:29 <ph88> yeoman, yes it's the constructor for a "Maybe a"
14:48:37 <yeoman> i think i get it.. nothing is one of two Maybe constructors
14:48:43 <ph88> YES ! :D
14:48:49 <yeoman> that's why it returns a Maybe, but it's actually returning always Nothing
14:48:53 <yoho> type constructors and data constructors don't have any naming relationship
14:48:55 <yeoman> because it's the constructor that does exactly that.
14:49:05 <yoho> :t Nothing
14:49:07 <lambdabot> Maybe a
14:49:08 <ph88> yeoman, yes it returns value Nothing of type "Maybe a"
14:49:22 <yeoman> yeah i think that could've been done more intuitively
14:49:22 <yoho> :t Nothing :: Maybe Int
14:49:23 <yeoman> but i got it now
14:49:24 <lambdabot> Maybe Int
14:49:32 <yoho> :t Just (3 :: Int)
14:49:34 <lambdabot> Maybe Int
14:49:36 <dmwit> troido: vty appears to use https://julialang.org/utf8proc/
14:50:02 <wedify> sqooq: i think you have the idea it just needs refining. so 't' is meant to be time, 's1' and 's2' are signals? in '(result, [Int]' what is a result and what is the list of ints meant to represent?
14:50:26 <dmwit> troido: (...and wraps up this functionality in Haskell functions here: https://hackage.haskell.org/package/vty-5.19.1/docs/Graphics-Text-Width.html )
14:50:50 <glguy> https://github.com/jtdaugherty/vty/blob/master/cbits/mk_wcwidth.c
14:51:07 <troido> thanks, that look useful :)
14:51:51 <yeoman> brb
14:52:33 <glguy> dmwit: I think it only used that library for a short time, but it's based on a newer unicode version that most terminals use today
14:52:47 <glguy> so it generated worse output than the old approximation
14:52:52 <yeoman> does haskell have inline assembly?
14:53:02 <cement> I don't think so
14:53:41 <orion> That would make for an interesting coding experience.
14:53:52 <dmwit> glguy: Hm, okay. I was just going by what the documentation for brick says. Perhaps that hasn't been updated to match reality.
14:54:58 <dmwit> yeoman: There is https://hackage.haskell.org/package/inline-c for including inline C. I don't know exactly how it works, but if it uses a real compiler it may support inline assembly via C's support for that.
14:59:21 <iqubic> Is it fine if I write a type class that has no laws that I can associate with it?
14:59:34 <[exa]> yeoman: the two things are called type and data constructors, "Nothing" and "Just" construct data of some type; "Maybe" constructs the type (if given a parameter)
14:59:54 <iqubic> It still has a valid use, just not one I can write laws for.
15:00:53 <[exa]> iqubic: perfectly valid (btw. google "Typing the technical interview" if you didn't read it already :] )
15:02:04 <[exa]> yeoman: btw Nothing/Just are the same "term" language as other functions (e.g. Just is a function from whatever to Maybe whatever), but Maybe belongs the type language (same as eg. Integer or Char)
15:03:11 <parsnip> i see i can do (f . g) as (g >>> f), but is there a way to do `f . g . h $ x` as like `x ??? h >>> g >>> f`? asking for a friend.
15:03:44 <ReinH> x & f = f x
15:03:57 <ReinH> so x & h >>> g >>> f, with the right fixity
15:04:01 <[exa]> parsnip: (&) acts as "pipe"
15:04:08 <ReinH> it's defined in lens or you can define it for yourself
15:04:22 <parsnip> ah, thanks all.
15:04:44 <parsnip> i used & before, forgot about it.
15:05:14 <fresheyeball> how can I compose an Iso into a composition of Prisms?
15:06:07 <sqooq> wedify, s1 and s2 are signals, the list is supposed to represent the delay line, for a unit delay it's just a number. I should I have done [Double] though my bad. The functions f1 adn f2 are the signals
15:06:49 <glguy> ReinH: fyi, (&) :: a -> (a -> b) -> b 	-- Defined in ‘Data.Function’
15:06:53 <unclechu> hey guys, is anyone using the Hoogle from command-line? when i try to `hoogle generate` i realize it limited to 2000 packages, could i up this limit?
15:07:05 <unclechu> or even make it be unlimited?
15:07:10 <iqubic`> glguy: & = flip id?
15:07:20 <iqubic`> to really mess with people.
15:07:44 <iqubic`> unclechu: Do you use stack?
15:08:16 <sqooq> I only wrote two steps but this general operation where things are passed onto the next should happen for arbitrary times steps
15:08:25 <sqooq> 1 second of audio is usually 44100
15:09:05 <yeoman> so
15:09:11 <yeoman> i took a walk and thought about it
15:09:25 <yeoman> if Nothing is a constructor
15:09:28 <yeoman> what does it construct
15:09:32 <iqubic> is there a better way to check if one number is a multiple of another besides using "x `mod` y == 0 || y `mod` x == 0"? I don't know which number is smaller there.
15:09:35 <yeoman> pls don't say "Maybe a"
15:09:46 <iqubic> yeoman: see this.
15:09:51 <iqubic> :t Nothing
15:09:53 <yeoman> i mean is there also a value "Nothing"
15:09:53 <lambdabot> Maybe a
15:09:57 <sqooq> wedify, now delay is most naturally just replacing the t of the function with (t-n), but in use this leads to inefficieny, but I was told memoization fixes this, I just don't know how.
15:10:07 <yeoman> yeah i understadnd that. Nothing is one of two constructors of Maybe a
15:10:09 <iqubic> :t Nothing
15:10:10 <glguy> yeoman: constructor is a lexical category, we have constructors and variables
15:10:12 <lambdabot> Maybe a
15:10:19 <glguy> Constructor variable
15:10:31 <yeoman> so it's kinda both?
15:10:39 <yeoman> value and constructor?
15:10:53 <glguy> value is a separate category from constructor
15:11:07 <yeoman> nyeh
15:11:11 <yeoman> can't follow
15:11:30 <yeoman> i mean.. for a type a
15:11:36 <yeoman> there are many if not infinite amount of justs
15:11:44 <yeoman> but only one nothing
15:12:00 <yeoman> (that is logical to me, because nothing has no parameter)
15:12:26 <glguy> parameters are not related to whether something is a constructor, this just categorizes the kind of name something is
15:12:32 <parsnip> return $ calculate firstNine & ((+ lastNum) >>> (`mod` 11) >>> (== 0))
15:12:34 <parsnip> return . (== 0) . (`mod` 11) . (+ lastNum) $ calculate firstNine
15:12:40 <parsnip> second one is more readable i think
15:12:44 <ph88> yeoman, yes that's right it's a value and a data constructor
15:12:57 <yeoman> kinda like really everything is a function in FP
15:13:03 <iqubic> parsnip: The second one is more readable.
15:13:05 <glguy> when you're writing an expression, you can use a constructor and it will have a value
15:13:12 <glguy> yeoman: No, not everything is a function in FP
15:13:14 <glguy> only the functions are
15:13:14 <iqubic> yeoman: Nothing is not a function.
15:13:20 <ph88> yeoman, a data constructor can be either a value if it takes no arguments or it can be a function if it takes arguments. But you could also argue that a function is also a value (because functions are first class) .. but that's beside the point
15:13:34 <yeoman> iqubic: is just a function?
15:14:19 <parsnip> return $ calculate firstNine & (+ lastNum) & (`mod` 11) & (== 0)
15:14:21 <glguy> The type of the expression (Just) is  a -> Maybe a, since the outermost type there is (->) then this value is a function
15:14:39 <ph88> Nothing data constructor and value,   Just data constructor and function that takes "a" to make value "Just a"
15:15:26 <fishythefish> :t Just -- yeoman: yes, it's a function
15:15:28 <lambdabot> a -> Maybe a
15:15:59 <yeoman> fishythefish: and how is nothing not?
15:16:06 <fishythefish> :t Nothing
15:16:08 <lambdabot> Maybe a
15:16:15 <yeoman> :t (x = 3)
15:16:17 <fishythefish> there's no -> in the type; it doesn't accept an argument
15:16:17 <lambdabot> error:
15:16:17 <lambdabot>     parse error on input ‘=’
15:16:17 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
15:16:24 <glguy> An interesting part of being a constructor means we can match with it in patterns
15:16:28 <[exa]> yeoman: the type of Nothing is calculated dynamically from the context (that's what type inference is for)
15:16:49 <[exa]> so if it looks it should return Maybe Integer, it returns Maybe Integer
15:16:56 <yeoman> so everyone is d'accor with nothing is not a function?
15:17:00 <glguy> When you see a variable in a pattern you know that it's being bound there, when you see a constructor in a pattern you know it's being matched
15:17:12 <[exa]> (s/dynamically/statically at compilation/    sorry)
15:17:14 <glguy> yeoman: Yeah, you can see from its type that it's not a function
15:17:17 <yeoman> x = 3
15:17:20 <yeoman> is x a function?
15:17:22 <fishythefish> yeoman: Nothing is not a function the same way 0, True, and "" are also not functions
15:17:24 <[exa]> yeoman: it is a nullary function (commonly called a constant)
15:17:34 <glguy> Haskell doesn't have "nullary functions"
15:17:46 <glguy> yeoman: we don't know if x is a function or not yet assuming the most general type
15:17:50 <iqubic> Yes, we are all fine with Nothing nt being a function
15:17:51 <fishythefish> Haskell only has unary functions, talking about nullary functions is misleading in terms of language semantics
15:18:07 <[exa]> ok, sorry :]
15:18:39 <iqubic> glguy: in "x = 3" is x a function? That's what yeoman wants to know.
15:18:46 <glguy> iqubic: I answered that
15:19:16 <glguy> if x :: Num a => a, then it might be used at a function type or it might not depending on what Num instances are handy
15:19:40 <ph88> let's go with  x :: Int  :p
15:19:49 <iqubic> glguy: "x :: Num a => a" is not a function is it?
15:19:49 <yeoman> if x=3 is a constant
15:20:03 <yeoman> couldn't you say.. 3 is just the function returning 3?
15:20:05 <glguy> iqubic: It can be used at a function type and also at other types
15:20:07 <iqubic> Then x is not a function.
15:20:07 <fishythefish> iqubic: we don't know until we specialize a
15:20:17 <glguy> yeoman: YOu could say whatever you wanted to say, but it wouldn't be useful in a Haskell context
15:20:18 <monochrom> Similarly, "pure () :: Applicative m => m ()" may or may not be a function, depending on what you set m to.
15:20:32 <yeoman> hm.
15:20:45 <[exa]> yeoman: mathematically yes (in haskell "function" refers to stuff constructed by (->) )
15:21:00 <royal_screwup21> is a list a functor?
15:21:03 <monochrom> In general, writing an essay that would get an A from an essay teacher is not going to give you much predictive power.
15:21:10 <fishythefish> royal_screwup21: yes, with fmap given by map
15:21:11 <[exa]> royal_screwup21: yep
15:21:22 <jle`> royal_screwup21: List is a functor, but a list is not
15:21:23 <glguy> yeoman: Check out http://conal.net/blog/posts/everything-is-a-function-in-haskell
15:21:36 <[exa]> royal_screwup21: try :i [] in ghci
15:21:59 <royal_screwup21> alrighty
15:22:16 <monochrom> At the end of the day, it may not even matter what you call a "function". The bottomline is do you know whether an expression like "3 ()" is legal.
15:22:46 <yeoman> glguy: okay, thanks
15:23:07 <yeoman> what was the difference between let and where bindings?
15:23:21 <[exa]> yeoman: none except syntactic/sugaring rules
15:23:37 <[exa]> and readability
15:23:40 <iqubic> Yeah, where you put the things being bound is different.
15:23:41 <yeoman> i see.
15:23:52 <yeoman> but essentially except for scoping
15:23:55 <yeoman> they're not different and all
15:23:57 <ph88> yeoman, go finish your game :p
15:24:03 <[exa]> yeoman: anyway, about nothing:
15:24:04 <yeoman> i am on it.. using "where" right now
15:24:08 <yeoman> for the boardprinting thing
15:24:12 <[exa]> :t head [Nothing, Just 'a']
15:24:13 <lambdabot> Maybe Char
15:24:21 <iqubic> Where is at the end of a function. Let is at the start of a function.
15:24:40 <yeoman> what's a clever way to print a 2d list in haskell?
15:24:43 <yeoman> a 3x3 grid?
15:25:00 <monochrom> What's the type of "2d list"?
15:25:24 <yeoman> [[Cell] where type Cell = Maybe Symbol
15:25:26 <[exa]> yeoman: try: mapM_ print [[1,2],[3,4]]
15:25:59 <yeoman> i think i can't print Cells
15:26:25 <lugh> yeoman: Make Symbol derive Show
15:26:58 <yeoman> i did that!
15:27:06 <iqubic> lugh: I don't think there's an instance for Show (Just a)
15:27:08 <yeoman> but Cell is Maybe Symbol
15:27:26 <monochrom> There is no such thing as "Just a".
15:27:29 <yeoman> oh .. that just works..
15:27:35 <[exa]> yeoman: Maybe a should have Show instance for all types a
15:27:35 <jle`> ph88: reminds me to start finishing up part three
15:27:41 <yeoman> i am not used to things working in haskjell for me
15:28:07 <[exa]> (..which have a Show instance)
15:28:18 <fishythefish> the instance is Show a => Show (Maybe a)
15:28:21 <yeoman> initialGameState = Game X (take 3 $ cycle [[Nothing,Nothing,Nothing]])
15:28:25 <yeoman> BE PROUD
15:28:26 <yeoman> I AM SO CLEVER
15:28:33 <fishythefish> :t repeat
15:28:36 <lambdabot> a -> [a]
15:28:36 <yeoman> is it actually?
15:28:43 <fishythefish> :t replicate
15:28:44 <lambdabot> Int -> a -> [a]
15:29:00 <yeoman> wheres the difference to mine?
15:29:05 <iqubic> I think replicate 3 (replicate 3 Nothing) looks better.
15:29:07 <monochrom> Simpler.
15:29:12 <iqubic> Easier to read
15:29:21 <monochrom> Less XY problem.
15:29:35 <yeoman> take 3 $ repeat [Nothing,Nothing,Nothing]
15:29:37 <yeoman> i like this one.
15:30:11 <iqubic> monochrom: I meant " I don't think there is an Instance (Maybe a)"
15:30:26 <glguy> iqubic: Do you know how to check if there is before guessing?
15:31:18 <iqubic> Use Hoogle or Hayoo?
15:31:42 <yoho> > show $ Just 3
15:31:42 <monochrom> Go to ghci and ask ":info Maybe" or ":info Show".
15:31:47 <lambdabot>  "Just 3"
15:31:54 <amalloy> @pl \x -> f (f x)
15:31:54 <lambdabot> f . f
15:31:58 <ph88> jle` :D
15:32:04 <monochrom> But people prefer to be opinionists than to be scientists.
15:32:45 <iqubic> Looks like there is an instance for that.
15:33:04 <ph88> yeoman finished ?
15:33:06 <iqubic> How can I tell if I'm using typeclasses properly?
15:33:21 <yeoman> ph88: still fighting
15:33:24 <monochrom> Also people prefer to do everything in their IRC windows. This is why https://hackage.haskell.org/package/manatee was invented.
15:33:30 <yeoman> board = show $ map show b
15:33:32 <amalloy> iqubic: pretty vague question, isn't it? one facile answer would be: if your code compiles, you must have used typeclasses properly
15:33:33 <yeoman> current progress :D
15:33:52 <iqubic> amalloy: Yeah, I got that.
15:33:54 <yeoman> guess i could putStrLn
15:33:57 <yeoman> each of them
15:34:07 <amalloy> yeoman: that's why mapM_ print was suggested
15:34:39 <iqubic> @pl \x -> f $ f x
15:34:39 <lambdabot> f . f
15:34:47 <yeoman> mapM_ does print automagicially?
15:35:07 <amalloy> if you call it with print, then it prints things
15:35:08 <monochrom> mapM_ print [a,b,c] = do { print a; print b; print c }
15:35:12 <parsnip> i used mapM_ in the past as pretty print
15:35:26 <iqubic> That works.
15:35:51 <iqubic> printBoard = mapM_ print board
15:36:03 <iqubic> where board is your 2d list of cells.
15:36:21 <yeoman> board = mapM_ print b
15:36:23 <ph88> :t print
15:36:25 <yeoman> this doesn't work either :(
15:36:26 <lambdabot> Show a => a -> IO ()
15:36:39 <yeoman> oh.. i get it.. no
15:36:42 <yeoman> board has to be string
15:36:54 <yeoman> i want to map it to a string representation of the board, no IO
15:36:54 <iqubic> Why does board have to be a string/
15:36:58 <yeoman> showGame (Game a b) = "Current Player is " ++ current_player ++ "\n" ++ board where
15:37:02 <lugh> yeoman: just use show
15:37:05 <iqubic> I see.
15:37:13 <monochrom> Then you will want to know about "intercalate" from Data.List
15:37:36 <yeoman> lugh: i did that already and wanted to move on with a pretty version
15:37:46 <yeoman> .. maybe show nothing.. for "Nothing"
15:37:47 <yeoman> etc
15:37:52 <ph88> yeoman, you making some nice ascii board for your tic tac toe ?
15:38:00 <yeoman> maybe show nothing <= lol !
15:38:12 <sqooq> hmm it seems even ST makes separate functions being added together difficult
15:38:13 <yeoman> ph88: something like that!
15:38:33 <yeoman> man im trying to learn haskell for so long now, i am finally making progress
15:38:40 <yeoman> but some decisions in haskell are really odd
15:38:41 <yeoman> like
15:38:44 <iqubic> sqooq: How is ST being a pain?
15:38:46 <lugh> yeoman: You're going to need to write your own pretty-printing function if you want to get something other than the show string representation.
15:39:04 <yeoman> lugh: rather pretty-stringify function?
15:39:17 <ph88> yeoman, intersperse puts strings between a list of strings .. it's useful .. and intercalate does the same but then concats your list into a string
15:39:20 <iqubic> yeoman: Those are the same thing.
15:39:34 <yeoman> ph88:  i don't need the right tools yet.. rather write my own stsupid ones
15:39:38 <yeoman> before i move on to this
15:39:54 <yeoman> iqubic: not anymore if i want to print that thing to a socket?
15:39:55 <ph88> yeoman, it's hard to do without
15:40:00 <yeoman> isn't a function that makes it a string more composable?
15:40:22 <yeoman> ph88: who does haskell who wants it easy?
15:40:23 <yeoman> :D
15:40:28 <iqubic> yeoman: Learning about these functions is how you can get better at Haskell
15:40:40 <yeoman> iqubic: even if it's my first stupid program?
15:40:52 <lugh> yeoman: print is just putStrLn . show
15:40:56 <lugh> :t mapM_
15:40:58 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
15:40:58 <yeoman> i mean there are many fancy things... do i need to save my state in STM so i can rollback if someone does something wrong?
15:41:02 <yeoman> isn't that a bad way to learn?
15:41:03 <lugh> There's nothing magic here.
15:41:20 <ph88> yeoman, intersperse is a basic function you should get to know it
15:41:23 <ph88> same for concat
15:41:25 <yeoman> okay.
15:42:12 <iqubic> yeoman: Don't worry about STM right now.
15:42:28 <monochrom> STM doesn't roll back for that.
15:42:32 <yeoman> that was just an example.
15:42:38 <yeoman> metaphor
15:43:05 <yeoman> my question was if writing my own tools for relatively simple tasks like that would be better for a beginner
15:43:08 <monochrom> For rolling back when someone does something wrong, hire a consultant.
15:43:21 <ph88> > "|" ++ (intercalate "|" ["O", "X", "O"]) ++ "|" -- yeoman this can be a row of your board in ascii
15:43:24 <lambdabot>  "|O|X|O|"
15:43:41 <yeoman> yeah, that's great i just used hoogle
15:44:04 <sqooq> iqubic, maybe I'm the one putting the restriction, but if I pass in two STrefs into two separate functions, I somehow want for their results to be added together, while they still maintain their separate ST, but I don't think that's so immediately possible
15:44:16 <yeoman> thanks alot guys, you made me really happy
15:44:18 <yeoman> im heading to bed now
15:44:27 <yeoman> thanks a bunch this is by far one of the nicer channels in irc
15:45:01 <iqubic> I think that might be possible, but I'm not the right person to ask.
15:45:07 <monochrom> Theoretically yes, writing your own code for simple tasks is good for beginners. In practice no, beginners always misjudge "simple". As if they put their judgment through a not-gate.
15:45:20 <yeoman> well, im not a code beginner
15:45:24 <yeoman> quite the opposite, just haskell
15:45:54 <monochrom> Oh you're one of those who still believe "picking up another language is easy, it's just a different syntax"?
15:46:07 <yeoman> well.. it's true for all i've seen yet
15:46:11 <yeoman> but haskell is different, i admit
15:46:17 <sqooq> it's true within respective families
15:46:20 <sqooq> from what I've seen
15:46:31 <yeoman> well. i never learned R or some fancy stuff
15:46:38 <sqooq> R feels C like
15:46:46 <yeoman> but people in the places i worked always cringed when i said something
15:46:47 <sqooq> but with like type safety
15:46:54 <yeoman> "i have no problem learning python, i know ruby"
15:47:01 <yeoman> i never got that
15:47:09 <ph88> i do :p
15:47:21 <iqubic> I think that the hardest part of learning a new language is learning the ecosystem.
15:47:22 <yeoman> well.. i wrote both now
15:47:32 <yeoman> well that is because pythons ecosystem is shit
15:47:43 <yeoman> and rubygems are actually good :D
15:47:46 <sqooq> yeoman, I agree with you, but I'm also quite the noob so maybe it's naivety
15:47:49 <ph88> batteries included
15:47:59 <yeoman> i mean.. if you have problems with a package in ruby... because some nativelib fails to build
15:48:04 <yeoman> it's the same frekaing thing in python
15:48:12 <yeoman> googling on stackoverflow until you get mad
15:48:25 <sqooq> like from my experience there are these larger language cateogories, and once you learn the main things for each of those categories, you can pick up the other languages relatively easily
15:48:47 <yeoman> sqooq: doing this for quite some time.. people always cringed, never seen my assumption fail in that regard
15:49:05 <yeoman> worst thing i saw was matlab
15:49:15 <sqooq> what's so bad about matlab lmao
15:49:18 <ph88> lol
15:49:20 <sqooq> (matlab is shit)
15:49:24 <fishythefish> 1 indexing
15:49:33 <ph88> but it can vectorize code
15:49:33 <aberrant> erm
15:49:34 <yeoman> i only mean.. in terms of "being a different language"
15:49:38 <aberrant> 1-indexing isn't that bad :)
15:49:38 <sqooq> fishythefish, that threw me on a loop the first time I picked it up
15:49:40 <sqooq> like wtf
15:49:46 <aberrant> you get used to it
15:49:47 <yeoman> it's still easy to learn for someone who did C at some point in life
15:49:51 <sqooq> aberrant, yeah
15:49:52 <yeoman> that's my point
15:50:02 <sqooq> yeoman, agreed, because I knew C, it was easy to pick up
15:50:10 <sqooq> I made a program that shifts harmonic partials around
15:50:13 <sqooq> it wasn't that hard
15:50:14 <aberrant> I migrate among scala, haskell, julia, and python and have very few issues with indexing.
15:50:17 <yeoman> and if you say that in an interview, i don't know why people laugh about you
15:50:28 <sqooq> yeoman, you're not alone dw
15:50:34 <yeoman> different thing with haskell.. honestly
15:50:43 <yeoman> im trying to learn it for a half a year now or something
15:50:44 <sqooq> yeoman, well it's not haskell perse, it's ML
15:50:51 <yeoman> always losing courage
15:50:57 <sqooq> There's ML, C, and Lisp.
15:50:59 <sqooq> that's it
15:51:12 <sqooq> everything else is a subcategory
15:51:22 <iqubic> See I learned Java first, and then I learned Haskell.
15:51:22 <ph88> there is also prolog
15:51:30 <sqooq> this is coming from my 5 months programming, so take that as you will.
15:51:32 <fishythefish> something something "Hask is not a subcategory"
15:51:39 <amalloy> sqooq: C is a subcategory of fortran, if you're going to take that perspective
15:51:50 <yeoman> ph88: prolog was fun too see in university
15:51:54 <amalloy> (and ML is a subcategory of lisp)
15:51:55 <iqubic> ph88: I want to learn prolog, but I can't find a suitable tutorial for it.
15:51:57 <yeoman> never knew it existed until then
15:52:00 <sqooq> amalloy, perhaps, but like fortran wen't out of style.
15:52:06 <wedify> sqooq: regarding memoization, have you seen https://wiki.haskell.org/Memoization? In particular the memoized_fib example in section 2. do you understand it? you start by using a data structure to store the results of each n, say a Map. Then define a function to calculate this data structure recursively but instead of simply recursing to get 'f (n-1)' you look it up in the Map
15:52:44 <ph88> iqubic, http://www.learnprolognow.org/
15:53:06 <sqooq> wedify, yes but I'm not sure how to like compartmentalize it
15:53:15 <sqooq> since you don't actually know when time will get calculated
15:53:16 <yeoman> who actually uses prolog?
15:53:19 <yeoman> anyone have an example?
15:53:30 <ph88> people in #prolog use prolog ^^
15:53:43 <ph88> they use it for production systems too
15:53:49 <yeoman> that's cray
15:54:01 <yeoman> that's something i wouldn't dare to say in an interview
15:54:02 <sqooq> amalloy, also ML may have come from lisp but it's like within the fp paradigm, but Idk, I never actually learned ML, it looks a lot like the other fp languages to my eyes, and I have a feeling I could learn it with my fp knowledge, and it wouldn't be that bad
15:54:03 <yeoman> "prolog, no prob"
15:54:07 <ph88> swi prolog mostly
15:54:35 <ph88> yeoman, there is a correlation between logic programming (like prolog) and haskell types
15:54:52 <amalloy> yeoman: i saw someone link a prolog program they had created to compute ratios for factorio
15:54:56 <yeoman> yeah i had flashbacks, when using pattern matching
15:55:12 <yeoman> never played factorio
15:55:15 <albatross_> http://lpaste.net/361482
15:55:16 <yeoman> never will
15:55:20 <ph88> yeoman, https://en.wikibooks.org/wiki/Haskell/The_Curry%E2%80%93Howard_isomorphism
15:55:24 <albatross_> hey guys i'm getting an erro saids nonexhaustive pattern
15:55:25 <Xe> it's worth it man
15:55:27 <albatross_> please help
15:55:32 <yeoman> Xe: i know, but it will kill me
15:56:00 <yeoman> someone said "play stellaris, it's really fun" in the office
15:56:02 <yeoman> half a year ago
15:56:04 <geekosaur> you should include the full error message
15:56:06 <yeoman> didn't leave my flat
15:56:15 <Xe> factorio won't kill you if you leave food by your computer
15:56:16 <yeoman> since thenm (jk)
15:56:19 <fishythefish> albatross_: do you know what that error means?
15:56:24 <ph88> factorio -- never head of looks crazy
15:56:29 <albatross_> fish, I do
15:56:39 <albatross_> but I don't see any other case that i can write
15:56:52 <dmwit> albatross_: Turn on -Wincomplete-patterns and it will tell you.
15:56:53 <geekosaur> but the likely answe is line 21-22 doesn't handle the empty list
15:56:55 <fishythefish> what if getTimestamp takes an UnknownString?
15:57:04 <yeoman> either way g2g
15:57:07 <yeoman> thanks again, bye!
15:57:15 <geekosaur> or that omne, yes
15:57:26 <sqooq> wedify, does that make any sense? Like the memoization happens within the function in all examples I've seen, I need a memoization across function calls.
15:57:28 <dmwit> fishythefish: I am willing to bet the problem is in `insert`, not `getTimeStamp`.
15:57:35 <fishythefish> what if insertString takes a LogMessage an a Leaf?
15:57:38 <albatross_> ah, I defined empty list as UnknownString somewhere else
15:57:40 <albatross_> hold on
15:57:42 <yeoman> man memoization must be awesome in haskell
15:57:55 <yeoman> i really g2g. :(
15:57:57 <sqooq> yeoman, it seems like pure magic
15:57:59 <fishythefish> what if build takes a Node instead of a Leaf?
15:58:13 <geekosaur> sorry not empty string. empty list of LogMessage
15:58:17 <yeoman> sqooq: i wrote it in ruby.. and was furious because i always had some side effects i forgot about
15:58:21 <monochrom> To fix errors, delete more code until there is no error. :)
15:58:29 <fishythefish> dmwit: aren't all three nonexhaustive?
15:58:31 <yeoman> that was actually really the first time i was thinking about haskell
15:58:35 <dmwit> albatross_: In short, there are many incomplete patterns here, and you should ask the compiler to tell you about all of them.
15:58:48 <glguy> monochrom: Hmm: The IO action ‘main’ is not defined in module ‘Main’
15:58:52 <dmwit> fishythefish: I am making a bet about which one he is having trouble with, based on incomplete data. Want to take me up on the bet? =)
15:59:05 <yeoman> sqooq: i had a lot of classes in ruby, which very terribly slow.. so i wrote a function that replaced selected functions with memoized counterparts"
15:59:18 <fishythefish> dmwit: I never take bets on what I think someone else is doing with code
15:59:22 <fishythefish> I always err on the side of reasonableness
15:59:26 <yeoman> worked fine.. but most times there was something ohter thing the function was doing
15:59:29 <yeoman> EITHER WAY GN
15:59:48 <albatross_> how do i implement -Wincomplete-patterns
15:59:58 <fishythefish> you pass it as a flag to the compiler
16:00:00 <dmwit> Add that to the command line when you start ghc or ghci.
16:00:10 <albatross_> ok thanks
16:00:19 <monochrom> glguy: Yeah. Add "-c" to the command line. :)
16:00:23 <dmwit> e.g. `ghci -Wincomplete-patterns my-fancy-program.hs`
16:00:42 <glguy> monochrom: For my empty file I get the same result!
16:01:04 <monochrom> DELETE GHC.
16:01:10 <glguy> roger, wilco
16:01:15 <dmwit> glguy: ...I don't!
16:01:38 <geekosaur> alias ghc=rm # and now you've replicated an old ghc bug :)
16:01:55 <glguy> dmwit: Sorry dmwit, I'm going to head home. My computer doesn't seem to work any more
16:01:59 <monochrom> If you have a time machine, go back in time to mug SPJ or something!
16:02:27 <ph88> if you have a time machine, go buy bitcoins
16:02:30 <dmwit> glguy: Interesting, `ghc -c test` and `ghc -c test.hs` behave differently.
16:02:33 <monochrom> (EA will have to buy this plot from me for C&C Red Alert 4!)
16:02:37 <dmwit> And the former does not cause an error, which blows my mind.
16:03:15 <monochrom> Oh, interesting.
16:03:25 <monochrom> Is that on Windows?
16:03:53 <dmwit> Nope. `touch test.hs; touch test; ghc -c test` exits with no errors on Linux, GHC 8.0.2
16:04:09 <glguy> dmwit: I get: <command line>: does not exist: test
16:04:20 <glguy> version 8.2.2
16:05:29 <royal_screwup21> I'm trying to define a function under a class like so: https://thepasteb.in/p/Y6hklYjnNn9t7 that tells you whether a list empty. When I do is_empty [1,2,3] -- an exception gets thrown: https://thepasteb.in/p/Mjhx3PvwmVgiV  what am I doing wrong?
16:06:09 <dmwit> glguy: Seems to be a bug in 8.0 through 8.2.1. I get an error in 7.8.4 and before, and don't have 8.2.2 to test on.
16:06:11 <glguy> royal_screwup21: The pattern   [a]    only matches singleton lists
16:06:26 <royal_screwup21> shite
16:06:26 <dmwit> But 8.0.1, 8.0.2, and 8.2.1 no error.
16:06:58 <dmwit> royal_screwup21: Luckily, the even shorter pattern `a` matches all lists.
16:07:21 <royal_screwup21> oh
16:07:36 <iqubic> unless you just want to match lists that have at least one item. Then use (x:xs).
16:07:36 <dmwit> (Kinda makes sense, don't it? =)
16:07:50 <iqubic> note that the parens are needed in my thing.
16:07:56 <amca> Quick question: how can I make ghci aware of a newly installed package (with cabal)?
16:08:17 <dmwit> amca: If in a sandbox, `cabal sandbox exec ghci`. Otherwise it should already be aware.
16:08:42 <sqooq> wedify, so the best way I can explain myself, is that for the maybe memoizable solution I'll have things like y(t) = x(t) + y(t-1) + y(t-2) + ...  But the y calls on t will be completely separate from each other. So I will do y(0), then y(1), and the y(1) call would have to use the y(0) call, so I don't think memoization fits here.
16:08:49 <sqooq> this is more a transfer of state
16:08:54 <fishythefish> iqubic: if you don't need to name the head and tail, just matching on `a` is fine, since the empty case is handled first
16:09:11 <dmwit> sqooq: Recursive functions can still be memoized. Just takes some gymnastics.
16:09:26 <iqubic> fishythefish: that makes sense
16:09:30 <dmwit> sqooq: (Namely, the recursive definition must use the memoized version rather than the non-memoized version.)
16:10:05 <geekosaur> amca, you can't make a running ghci aware of it; you'd have to restart. beyond that, depends on how the package was installed. as mentioned, if it's in a sandbox of some kind, you need to use the sandbox's ghci wrapper to see it
16:10:27 <iqubic> Can I use intero and ghc-mod together?
16:10:52 <sqooq> dmwit, yes but the recursion isn't self contained...
16:11:00 <amca> Thanks <dmwit>, but it isn't.  For example, I installed the MonadControl package, which contains the Control.Monad.Random module, but ghci doesn't know about it.  I seem to have to quit and restart ghci in order for it to known about the newest modules.
16:11:25 <monochrom> It is best to not use ghc-mod and intero together.
16:11:36 <amca> Oh, thanks <geekosaur> - that does make sense!
16:11:39 <monochrom> But I haven't tried.
16:12:09 <dmwit> amca: Yes, that's true. I should have mentioned that; sorry.
16:12:12 <monochrom> I, too, just give an opinion without testing, eh?
16:12:12 <dmwit> sqooq: ?
16:12:13 <geekosaur> ghci's just a special mode of ghc, and ghc has no mechanism to incorporate new packages while it is running
16:13:01 <sqooq> dmwit, aha I think I know how to explain. The recursive function call y(0) doesn't need memoization all by itself. It calculates itself just fine, memoization won't help at all. y(1) on the other hand needs y(0), y(2) needs y(1), and so on. But these calls aren't in one self contained function, so like unless y(0) stores itself side-effectfully, or y(0) transfers over into the y(1) calculation. Does this make sense? Maybe I'm wrong and I don't understand
16:13:01 <sqooq> memoization and somehow this actually works.
16:13:07 <amca> By the way, before I clock off again - where can I find a simple explanation (suitable for a newbie like me) as to the relative benefits and advantages of cabal vs stack?
16:13:08 <geekosaur> and I'm not sure offhand how you would handle the case of a package that is in use (i.e. a bound thunk referencing the package is in scope) going away or changing
16:13:37 <amca> That's a good point.
16:13:38 <geekosaur> laziness complicates things rather considerably compared to most REPLs
16:14:11 <sqooq> dmwit, it would be like running fib 100000, and having it take a while, then running the same thing a second later, and it spits out the answer immediately.
16:14:29 <sqooq> except my function by itself doesn't need memoization to work.
16:14:47 <rodol> @pl \xs ys -> (fst (last xs)) .|. (fst (last ys))
16:14:47 <lambdabot> (. (fst . last)) . (.|.) . fst . last
16:15:13 <amca> Right - gotta go and help my elderly mother in her garden.  I like this place - and I'll be back again!
16:16:32 <sqooq> like it doesn't actively use past calculations when you call it. y(4) = x(4) + x(3) + x(2) + x(1) + x(0). This by itself doesn't benefit from memoization right? Am I missing something here?
16:17:47 <metahumor> is there a general type class for a functor that is also has "empty"?
16:18:06 <metahumor> like how Maybe has Nothing and Just a, or if we limited List to [] and [a]
16:18:38 <dmwit> > let collatzNext n | even n = n `div` 2 | odd n = 3*n + 1; collatz 1 = 0; collatz n = 1 + fromMaybe (collatz (collatzNext n)) (lookup (collatzNext n) collatzTable); collatzTable = [(n, collatz n) | n <- [1..1000]] in collatz 3
16:18:42 <lambdabot>  7
16:18:48 <dmwit> sqooq: There is an example of the technique I'm talking about.
16:19:17 <dmwit> Using a terrible memoization table type (`[(Int, Int)]`) for simplicity of in-channel implementation.
16:19:34 <sqooq> dmwit, what is this syntax? the `|`
16:19:49 <metahumor> that's a guard
16:19:49 <fishythefish> sqooq: that's a guard
16:19:56 <sqooq> o true
16:19:57 <sqooq> in a let
16:20:01 <dmwit> It's a guard. `f pat | cond = a | cond2 = b` is `a` when `cond` is true, `b` when `cond2` is true.
16:20:03 <sqooq> the let confused me for a sec
16:20:26 <dmwit> (...and when `pat` matches, of course)
16:20:50 <iqubic> sqooq: The let is just for defining the function in lambdabot
16:21:02 <sqooq> agh ok
16:21:08 <geekosaur> any pattern can have guards. binding patterns, case patterns, ...
16:21:13 <dmwit> sqooq: In particular, notice that the memoization table `collatzTable` is shared across calls to `collatz`, not recomputed for each possible argument.
16:21:56 <dmwit> Which, if I'm reading you correctly, is your objection? Not 100% sure.
16:22:05 <metahumor> sqooq: and it's alright that collatz and collatzTable are mutually recursive
16:22:31 <sqooq> dmwit, thanks I'll try and parse this
16:22:34 <amalloy> metahumor: Alternative, sorta, except that Alternative also requires <|>
16:22:37 <sqooq> and see if it's the solution
16:23:08 <ph88> why is singletons called singletons ?
16:23:23 <dmwit> sqooq: Most memoization libraries offer something of type `memoFix :: SomeConstraint a => ((a -> b) -> (a -> b)) -> (a -> b)` to generalize this pattern to arbitrary recursive definitions.
16:23:52 <dmwit> ph88: A singleton is a family of types for which each type has exactly one (completely defined) inhabitant.
16:24:04 <ph88> oh ok
16:24:12 <dmwit> The "exactly one inhabitant" part motivates the name "singleton".
16:24:13 <metahumor> amalloy: yeah, but <|> doesn't really make sense if I want to somehow link my wrapped values, like an mappend
16:24:24 <sqooq> dmwit, this is confusing haah
16:25:11 <fishythefish> dmwit: er, surely a singleton is just one type, not a family of types
16:25:17 <dmwit> no
16:25:22 <dmwit> well
16:25:26 <dmwit> Okay, sure. However you like.
16:25:35 <fishythefish> a set with one element is a singleton, but a collection of such sets is not
16:25:38 <dmwit> Usually they come in families. =)
16:25:46 <fishythefish> that's true, i'm just picking nits
16:25:56 <sqooq> dmwit, how is the table working?
16:25:58 <fishythefish> #haskell's favorite pastime
16:26:36 <dmwit> sqooq: Pretty well, I gather! (But seriously: can you make your question more concrete? What bit is surprising you?)
16:26:43 <metahumor> sqooq: the table builds values of (n, collatz n)
16:26:53 <metahumor> sqooq: and we lookup the values using "lookup"
16:26:54 <sqooq> dmwit, wouldn't the table just get rebuilt for every function call?
16:27:23 <dmwit> No, it is defined once and for all as a single equation.
16:27:33 <sqooq> waaaat
16:27:39 <sqooq> but but but
16:28:00 <metahumor> the collatzTable definition is outside of the collatz definition
16:28:05 <sqooq> so all those values get calculated right away?
16:28:11 <sqooq> at compile time or something?
16:28:16 <dmwit> No, laziness means they are computed as needed.
16:28:26 <sqooq> ok, but then since it's lazy
16:28:29 <sqooq> if I call collatz 3
16:28:33 <sqooq> then collatz 5
16:28:40 <sqooq> shouldn't it recalculate for the collatz 5 call?
16:28:48 <dmwit> Why should it recalculate?
16:28:57 <iqubic> Nope. That's what lazyness means.
16:29:06 <sqooq> so how does haskell keep track
16:29:17 <sqooq> this seems effectful
16:29:17 <iqubic> Does this use a closure to keep the lookup table from going out of scope?
16:29:24 <metahumor> collatz 3 -> is 3 in table? if yes, give back what table has for 3, if it isn't put in table (3, 1 + collatz 10)
16:29:26 <amalloy> sqooq: they're defining two mutually-recursive values, collatz and collatzNext
16:29:57 <metahumor> then collatz 3 now gives you "1 + collatz 10"
16:29:58 <dmwit> Yes, laziness is effectful. It is write-once mutation.
16:30:04 <metahumor> and we do the same for collatz 10, etc
16:31:31 <sqooq> hmm
16:31:36 <sqooq> this is literal magic
16:31:39 <sqooq> I do not understand it
16:32:22 <fishythefish> which bits are you struggling with?
16:32:22 <metahumor> can you identify what you arent understanding?
16:32:39 <sqooq> so the table get's updated through time because lazy
16:32:40 <geekosaur> any sufficiently advanced technology...
16:32:43 <sqooq> but it's there in storage
16:32:50 <geekosaur> "lazy" = it's a pointer to a chunk of code
16:33:00 <sqooq> and everytime you call the function, the table get's looked up and potentially updated
16:33:05 <geekosaur> when something forces evaluation, the chunk of code is replaced with a computed value
16:33:27 <geekosaur> because that "node" is referenced by other parts of the table, it sticks around instead of needing to be recomputed again later
16:33:35 <metahumor> the table isn't really updated, its just the references kept in the table get updated to point to different values
16:33:35 <hydraz> mis?read that as "a thunk of code"
16:33:50 <sqooq> metahumor, ok wow this feels like cheating
16:33:50 <metahumor> geekosaur just said the same as me whoops
16:33:56 <sqooq> I think I understand
16:34:02 <sqooq> This is the solution to my problem then
16:34:26 <hpc> sqooq: if you know javascript or some other related language, a thunk is a lot like "x = function() {var foo = slow_computation(); x = function() {return foo}; return foo}"
16:34:31 <amalloy> sqooq: you will find more interesting functions written in this style if you search for "tying the knot"
16:34:53 <amalloy> well, assuming your search also includes the word "haskell". otherwise you probably get wedding pictures
16:35:01 <metahumor> watch, a week from now, he'll be back with questions about ContT
16:35:04 <geekosaur> heh
16:35:12 <sqooq> probably
16:35:26 <hpc> (in case that helps your mental picture of what's going on)
16:35:37 <dmwit> sqooq: Perhaps this ghci session will provide some evidence that collatzTable is not recalculated multiple times: http://lpaste.net/361484
16:35:45 <dmwit> sqooq: Oh, I have an even better idea for evidence. One moment.
16:35:47 <sqooq> hpc, I'm not aware of slow_computation() but yeah it does help
16:35:58 <sqooq> Haskell was my first language so
16:36:01 <hpc> slow_computation is some hypothetical thing you're thunking over
16:36:17 <sqooq> If anything I understand java in reference to haskell (that's not actually the case obviously)
16:36:17 <hpc> in the higher-level language that would implement a thunk for, you could imagine x = slow_computation
16:37:45 <dmwit> sqooq: Now there is an annotation that you may find fun. I modified the table to trace the inputs it evaluates the table at.
16:38:09 <dmwit> sqooq: As you can see, after I call `collatz 5` (which needs to learn `collatz 16`), calling `collatz 16` does not evaluate any further parts of the table.
16:38:34 <iqubic> so can you use intero and ghc-mod in tandem?
16:39:04 <iqubic> What even is ghc-mod for? I know it's an editor plugin, but IDK what it does.
16:39:11 <sqooq> I use it
16:39:19 <sqooq> for it's type checking
16:39:47 <kadoban> You can use it as a backend for completion as well I believe. Or does intero do completion?
16:40:36 <metahumor> ghc-mod is a command line tool which editors can use to call sync or async for linting and type hints and other stuff
16:40:59 <metahumor> intero afaik is more stuff like that for emacs, or for neovim
16:41:07 <sqooq> dmwit, wow
16:41:26 <sqooq> this is definitely definitely the direction I need to take
16:41:37 <sqooq> sweet it would make the delay definition actually intuitive too
16:41:44 <sqooq> now how the hell do I actually start
16:42:53 <iqubic> sqooq: Intero gives me type checking on the fly.
16:43:27 <doyougnu> +1 for intero
16:43:33 <sqooq> what's intero
16:43:51 <kadoban> sqooq: editor integration thing
16:43:59 <sqooq> >emacs
16:44:02 <sqooq> :nauseation:
16:44:15 <metahumor> Ed, man! man ed
16:44:16 <kadoban> neovim? I think it's also in the works for other editors.
16:44:23 <sqooq> >vim
16:44:30 <sqooq> *actual vomit*
16:45:35 <glguy> dante is nice for emacs and on-the-fly checking and working with more build tools
16:47:01 <iqubic> can you use dante with intero, or is it meant to be a standalone thing?
16:48:09 <glguy> it saves you from needing intero
16:52:13 <iqubic> is dante better? Should I switch?
16:53:42 <monochrom> Yes.
16:54:05 <iqubic> How do I go about switching? Is dante on melpa?
16:54:14 <monochrom> I don't know.
16:54:52 <iqubic> According to the GH page, it is on melpa
16:55:08 <iqubic> Should I use hlint too?
16:55:38 <monochrom> No.
16:55:53 <iqubic> Why not?
16:56:19 <monochrom> Too many warnings.
16:57:20 <dmwit> sqooq: re: "how do I start?" By writing the function you want to memoize in terms of `fix` rather than using direct recursion.
16:57:31 <dmwit> ...then call this instead of `fix`: https://hackage.haskell.org/package/MemoTrie-0.6.8/docs/Data-MemoTrie.html#v:memoFix
16:57:56 <dmwit> > let fact 0 = 1; fact n = n*fact(n-1) in fact 10 -- direct recursion
16:57:59 <lambdabot>  3628800
16:58:31 <dmwit> > let fact = fix (\f n -> case n of 0 -> 1; _ -> n*f(n-1)) in fact 10 -- no recursion, but yes calls to fix
16:58:35 <lambdabot>  3628800
16:58:51 <monochrom> People call this "open recursion".
16:58:52 <iqubic> How do I remove the files installed by intero?
16:59:57 <parsnip> iqubic: perhaps create two test directories, use intero in one of them, and see what the difference is?
17:00:45 <sqooq> dmwit, so I have y = x +: (del 1 y)
17:00:48 <sqooq> how do fix
17:01:14 <sqooq> maybe I should learn fix better
17:01:15 <iqubic> :t (+:)
17:01:15 <sqooq> brb
17:01:17 <lambdabot> error:
17:01:17 <lambdabot>     • Variable not in scope: +:
17:01:17 <lambdabot>     • Perhaps you meant one of these:
17:01:18 <monochrom> y = fix (\w -> x +: del 1 w)
17:01:34 <dmwit> sqooq: y = fix (\y -> x +: del 1 y)
17:01:37 <monochrom> In general you may want to read my http://www.vex.net/~trebla/haskell/fix.xhtml
17:03:38 <iqubic> Fix is still holy magic for me. Why does that ever terminate?
17:03:48 <iqubic> :t Del
17:03:51 <lambdabot> error: Data constructor not in scope: Del
17:03:57 <sqooq> iqubic, they're my functions
17:04:01 <iqubic> I see.
17:04:05 <sqooq> +: is liftA2 (+)
17:04:21 <sqooq> x is a function wrapped in a type
17:04:34 <sqooq> del just shifts the time it's applied to
17:04:57 <sqooq> `• Couldn't match expected type ‘a -> a’
17:04:57 <sqooq>               with actual type ‘Signal a a’`
17:04:59 <iqubic> What is the for?
17:04:59 <sqooq> hmmmm
17:05:38 <monochrom> "fix (\y -> x +: del 1 y)" type-checks iff "y = x +: del 1 y" type-checks.
17:06:49 <sqooq> hmm it doesn't
17:06:53 <sqooq> I think I need to define the base case
17:10:58 <sqooq> weird, I swear I've gotten this same function to work in the past
17:11:27 <monochrom> Does the direct-recursion version still work? :)
17:11:40 <sqooq> no
17:11:44 <monochrom> Heh
17:11:47 <sqooq> well wait what do you mean?
17:11:58 <sqooq> `y = x +: del 1 y` doesn't type check
17:12:08 <sqooq> and I thought putting an if statement for t <= 0 would fix things
17:12:09 <sqooq> but it didn't
17:12:54 <amalloy> iqubic: fix can terminate for the same reason any recursive function can terminate: it contains a circular reference, but that reference is not always traversed
17:13:14 <sqooq> waaait, it needs to just not even do anything for t<0
17:13:18 <sqooq> how the hell did I get this to work before
17:13:24 <monochrom> haha
17:13:36 <monochrom> This is known as "bit rot".
17:14:28 <sqooq> Wait the if statement should be in the del !
17:14:36 <sqooq> i think...
17:14:40 <sqooq> :p
17:16:02 <sqooq> Ok
17:16:04 <sqooq> it type checks now
17:17:12 <[Leary]> This is one of the reasons it's good to code in a git repo and commit often. If you mess things up you can always pull up the old version and have a look at it.
17:17:50 <sqooq> now literally just replace fix with memoFix?
17:18:22 <monochrom> We need the whole file system to be version-controlled. Because this benefits more than code revision. It also benefits "I upgraded stack and it breaks now".
17:18:36 <metahumor> monochrom: that's what we have at my work
17:19:03 <metahumor> you know the aphorism that "any sufficiently sophisticated software includes in it a Lisp compiler"?
17:19:16 <monochrom> I think memoFix is for functions not other values.
17:19:18 <metahumor> we have a similar one at my work except we just write new filesystem
17:19:41 <sqooq> monochrom, yeah it doesn't type check
17:19:42 <sqooq> so now what
17:20:20 <amalloy> sqooq: you're trying to memoize a value which is not a function?
17:20:23 <monochrom> If you have "fib n = fib (n-1) + fib (n-2)" memoFix will help. But not applicable to e.g. "x = 0 : x".
17:20:35 * geekosaur has been tossing around version controlled (and transactional) filesystems for 35+ years
17:20:48 <sqooq> amalloy, I guess.
17:21:00 <geekosaur> there's even a trivial extension of the original unix filesystem that enables versioning
17:21:12 <geekosaur> the real problem is now you need a librarian to keep track of the filesystem for you
17:21:13 <monochrom> Although, if Signal is a function underneath, there is something you can do.
17:21:21 <sqooq> I can grab it
17:21:21 <sqooq> ye
17:21:25 <sqooq> but like
17:21:27 <sqooq> ok
17:21:42 <sqooq> but what about the "+:"
17:21:48 <monochrom> Then you have to unwrap, memoFix, re-wrap.
17:21:54 <sqooq> so right now I have `summer x = memoFix (\w -> x +: del 1 w)`
17:21:57 <metahumor> sqooq: my memoization defs usually look like "fib = fix (memoize . go) where go f n | n == 1 = 1 | n == 2 = 1 | otherwise = f (n-1) + f (n-2)"
17:21:59 <sqooq> x :: Signal a a
17:22:19 <metahumor> geekosaur: it also gets more complicated if you have mounts across networks
17:22:57 <sqooq> wait del 1 w should just be w I think...
17:23:03 <sqooq> maybe ...
17:23:04 <sqooq> no
17:24:05 <metahumor> geekosaur: do you work in chip DV?
17:24:25 <geekosaur> nope. used to ride herd on a bunch of those types though
17:24:46 <geekosaur> current job is in fact maintaining a network filesystem :)
17:25:13 <metahumor> nfs or...?
17:27:33 <jle`> woo hoo singletons 2.4 is out
17:28:17 <jle`> i wonder if i should wait for it to land on stackage before publishing my tutorial
17:28:33 <metahumor> jle`: how does the new version change your tutorial/workflow, if at all?
17:28:34 <geekosaur> openafs
17:28:46 <jle`> oh 2.4 is ghc 8.4 only
17:28:55 <jle`> so i guess i'm not waiting
17:29:04 <geekosaur> not exactly a popular one, but it does things many other network filesystems don't handle well
17:29:25 <jle`> oh the biggest thing i was personally waiting for was for Nat to be the singleton of Natural instead of Integer
17:30:00 <jle`> that was bugging me for a long time
17:31:24 <jle`> the new version introduces a lot of useful utility types and tools, from ryanglscott and Iceland_jack
17:31:57 <jle`> and it looks like a lot of naming conventions have changed so that will probably break almost all existing code that uses defunctionalization so i'll have to rewrite my april fools post probably
17:32:08 <jle`> but fundamentally it doesn't look like anything changed, just superficial things
17:32:16 <metahumor> enforced bit rot
17:32:56 <jle`> oh the story for promoted-* is a lot nicer too
17:33:04 <jle`> but i'm not sure if anyone really used promoted *
17:33:13 <jle`> well...they might start now :)
17:34:16 <metahumor> on the topic of Nats, is there a version of Dedekind cuts to define typelevel Reals?
17:35:10 <jle`> haven't looked into the topic, but the general undecidability of real math makes it a little less appealing
17:35:17 <jle`> but i've had on some occasions wished for type level rationals
17:35:52 <metahumor> aren't type level rationals just (Int, Int) with additional equivalence classes?
17:36:07 <metahumor> * (Int, nonzero-Nat)
17:36:35 <jle`> yeah, it's not too fundamentally tricky i think
17:37:00 <jle`> we just need rational type literals now :)
17:37:33 <edwardk> i do wish we had type level integers more so than nats
17:37:52 <sqooq> so am I screwed monochrom, dmwit
17:37:54 <metahumor> jle`: you might like https://en.wikipedia.org/wiki/Construction_of_the_real_numbers#Construction_from_Z_(Eudoxus_reals)
17:38:38 <jle`> thanks :)
17:40:01 <sqooq> I wrote it wrong earlier it's actually more like "summer x = x +: del 1 (summer x)" if that makes a difference
17:41:21 <monochrom> summer2 x = go where go = x +: del 1 go
17:41:40 <monochrom> Does that perform better?
17:42:23 <sqooq> like right now?
17:42:27 <sqooq> trying to use it?
17:42:36 <monochrom> If you want memoFix involved, I know how to do it, but I doubt that it helps.
17:42:52 <monochrom> Whereas this "go" version has a better chance.
17:43:27 <sqooq> it does not perform better
17:43:39 <sqooq> well maybe it does
17:43:44 <sqooq> but it still performs very very badly
17:43:51 <sqooq> computing 1 second of sound
17:43:55 <sqooq> still hasn't finished
17:44:05 <sqooq> it's been like 1 minute
17:44:29 <sqooq> i'm going to stop it
17:44:30 <sqooq> WAIT
17:44:33 <metahumor> are you still using your ST version?
17:44:36 <sqooq> I CALLED MY FUCTION WRONG
17:44:41 <metahumor> =)
17:44:42 <sqooq> no it's definitely faster
17:44:44 <monochrom> haha
17:44:46 <hodapp> function*
17:44:47 <sqooq> wtf, how did this work???
17:44:49 <hodapp> >_>
17:44:57 <metahumor> rubber #haskell debugging
17:45:06 <sqooq> this changes hardly anything
17:45:07 <sqooq> how did htis
17:45:09 <sqooq> what???
17:45:12 <monochrom> go reuses go itself rather than re-compute summer x.
17:45:52 <sqooq> but is that not the same thing
17:46:00 <sqooq> at t=5 does it not have to recompute
17:46:02 <sqooq> this is magic
17:47:05 <monochrom> To be honest, whether it helps or not depends on what +: is and what Signal is and what del is etc etc all the things I don't know but I can always ask you to empirically test.
17:47:35 <monochrom> But it is known that it helps some scenerios so it's worth a try.
17:48:14 <sqooq> no in the past, calculating 1 second took literally forever
17:48:23 <sqooq> it still feels kind of slow compared to like a brute force recursion
17:48:26 <sqooq> but it's a lot faster
17:48:45 <metahumor> sqooq, compare how long it takes to run the following
17:48:55 <metahumor> "f x = 1 : f x; f 0 !! 100000000"
17:48:57 <metahumor> and
17:49:13 <metahumor> "f x = go where go = 1 : go; f 0 !! 100000000"
17:50:33 <sqooq> haha
17:50:44 <sqooq> it's like less than a second for the 2nd one
17:50:50 <sqooq> the first one never stopped
17:52:25 <metahumor> on my machine, I can still get to indices that make the second f run slow
17:52:30 <metahumor> so it's not total magic
17:53:36 <buhman> I'm trying to learn how to write not-overcomplicated code. I was playing with this problem: http://lpaste.net/361486 . Is there some magic/strategy people use to try to avoid functions that are more complicated than they need to be?
17:55:09 <metahumor> buhman: i like the second defn
17:55:38 <buhman> slightly related: I'm pretty noob; is there some sugar that I could have used instead of writing a function explicitly on line 9?
17:55:43 <buhman> metahumor: me too
17:55:47 <metahumor> but why would f [x] not be x?
17:56:05 <metahumor> i'd expect "every other" to do indices "0,2,4,..." where lists are 0 indexed
17:56:17 <metahumor> "p = odd . fst"
17:56:26 <buhman> "starting at the second element"
17:56:32 <metahumor> ah
17:57:03 <buhman> nice, I was just reading about $ vs ., I clearly didn't understand it even though I thought I did :S
17:57:18 <metahumor> what's scary to me about that is that "concat . map f" would not be equal to "f . concat"
17:58:48 <metahumor> i mean, of course they wouldn't be equal for any arbitrary f, but i'd hope itd be the same if i did "concat . map (f . pure)" == "map f"
18:00:23 <jle`> buhman: for the last one you can also just use a wildcard
18:00:35 <jle`> f (x:y:zs) = ...
18:00:38 <jle`> f _ = []
18:01:04 <buhman> jle`: ah, yeah
18:01:41 <iqubic> > [0,1,0,2..]
18:01:42 <jle`> but yeah the first one generalizes better to 'every nth element'
18:01:45 <lambdabot>  <hint>:1:9: error: parse error on input ‘..’
18:02:11 <jle`> f = map snd . filter (odd . fst) . zip [0..]
18:02:16 <sqooq> oops
18:02:25 <sqooq> metahumor, I think it's still slow haha
18:02:43 <buhman> jle`: I don't think I understand
18:02:44 <sqooq> I wrote del 1
18:02:52 <sqooq> but it's del by 1 time step which is 1/44100
18:02:57 <jle`> buhman: the first one can be more easily generalized if you want "every nth element"
18:03:02 <jle`> instead of only "every other element"
18:03:06 <jle`> like, "every 12th element"
18:03:07 <iqubic> is there a way to get an ifinite list where the odd elements are 0 and the even elements are n/2?
18:03:07 <iqubic>  
18:03:10 <buhman> oh
18:03:19 <jle`> the second one is harder to generalize if your boss comes and says "oh but now i need every 12th element"
18:03:25 <jle`> but the first one is more flexible
18:03:46 <metahumor> iqubic: concatMap (\x -> [0, 2 * x]) [0..]
18:03:52 * hackage ats-format 0.1.0.21 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.21 (vmchale)
18:03:53 <sqooq> yes noow this is what I remember
18:04:00 <sqooq> I can literally see it getting slower through time
18:04:10 <buhman> so is some kind of "zip, fst, snd" a common pattern?
18:04:11 <jle`> one issue with the !! version is that !! is not "strict" enough
18:04:14 <sqooq> metahumor, I probably do have to do the memoFix thing
18:04:43 <metahumor> jle`: you defined (!!!) in your AoC code =)
18:04:45 <jle`> buhman: yeah, i would say it comes up a lot
18:04:51 <jle`> metahumor: yeah heh i can't stand it
18:05:04 <jle`> there should at least be an iterate'
18:05:11 <jle`> then i wouldn't need (!!)
18:05:26 <jle`> *!!!
18:06:44 <jle`> buhman: the 'zip [0..]' pattern is at least a pretty common one for lists
18:07:12 <metahumor> jle`: iterate' is default in 8.4 iirc, i define it a lot tho too
18:07:17 <jle`> whoa
18:07:23 <jle`> it's a new day
18:07:25 <metahumor> not default, i mean it is supplied
18:07:52 <metahumor> jle`: https://ghc.haskell.org/trac/ghc/ticket/3474
18:08:37 <jle`> :D
18:09:01 <jle`> 8 years in the making
18:10:13 <iqubic> So is there a way for me to add hoogle/hayoo support to emacs?
18:10:47 <iqubic> Preferably in a way where I can download the database once and then access it offline.
18:11:58 <metahumor> iqubic: you can install hoogle as a cli, then do shell calls using the emacs syntax for it
18:12:36 <iqubic> Isn't there a package for it? Like a wrapper around "Stack Hoogle"
18:13:00 <iqubic> Because I use stack which I think has hoogle integration
18:13:22 <metahumor> "stack install hoogle"?
18:13:47 <metahumor> "stack exec hoogle -- "[a] -> Maybe a" "
18:14:47 <iqubic> metahumor: I thought I could just use "stack hoogle [a] -> Maybe a" and it would query Base + whatever other packages my project included
18:14:49 <metahumor> there's a "hoogle generate" you have to do before you can use it
18:15:19 <iqubic> I see.
18:15:55 <iqubic> I also have a local hoogle server that I can access by pointing my browser at "localhost:8080"
18:16:17 <iqubic> NixOS is cool because you can just ask for it to set that up for you automatically.
18:16:35 <iqubic> I'm not sure if I can get a cli version of that though.
18:16:52 <metahumor> iqubic: might be useful: https://gist.github.com/chrisdone/78c1c1c052a853697cf3b902de086172
18:25:58 <dmwit> sqooq: I do not believe you are screwed. I also believe monochrom already told you how to fix the problem: unwrap to a function, memoFix, rewrap to Signal.
18:26:25 <monochrom> But that one is easier said than done.
18:26:36 <sqooq> dmwit, I tried it but couldn't get it to work but I will keep trying
18:26:40 <sqooq> for now, somewhat unrelated
18:26:48 <sqooq> if I have a binary operator but I want to flip it
18:26:50 <sqooq> how do I do that
18:26:58 <monochrom> Most combinators and utilities for Signal are designed to be not unwrapped ever. Especially when used in recursive ways.
18:27:00 <sqooq> using `` syntax
18:27:04 <sqooq> flip `add`
18:27:34 <monochrom> To be honest, I don't know for sure, but most people implement newtyped abstractions this way.
18:27:35 <dmwit> > transpose (chunksOf 2 "abcdefg") >>= drop 1 -- buhman, the obfuscated way
18:27:39 <lambdabot>  "cegdf"
18:27:51 <dmwit> Also wrong!
18:27:52 <dmwit> ouch
18:28:12 <dmwit> > concat . drop 1 . transpose . chunksOf 2 $ "abcdefg"
18:28:16 <lambdabot>  "bdf"
18:28:31 <sqooq> monochrom, yeah I would want this to work in general, I wouldn't want to have to do a memoFix thing for every case
18:28:57 <dmwit> sqooq: ... flip add
18:29:10 <sqooq> is it useful to note that reflex imports Data.MemoTrie and has a function "pull" that is Behavior . memo
18:29:13 <sqooq> https://github.com/reflex-frp/reflex/blob/develop/src/Reflex/Pure.hs
18:29:23 <monochrom> I mean, imagine if I suggested "unwrap Parsec, write in open-recursion style, insert memoFix, re-wrap Parsec" to "many p = p >> many p <|> return ()" :)
18:29:33 <dmwit> I do not know what "useful" means, so I cannot answer that question.
18:29:36 <sqooq> dmwit, but I want to us it infix :(
18:29:51 <dmwit> sqooq: Oh, right. Too bad.
18:29:53 <dmwit> You can name it.
18:29:59 <sqooq> ouch ok
18:30:06 <sqooq> I'll just flip manually then
18:30:30 <dmwit> Unfortunately Haskell does not have syntax for making arbitrary terms infix. I would like, e.g. `( and )` or similar to be delimiters for that, which wouldn't even need to steal any existing valid syntax.
18:30:52 * hackage hspec-dirstream 0.1.0.2 - Helper functions to simplify adding integration tests.  https://hackage.haskell.org/package/hspec-dirstream-0.1.0.2 (vmchale)
18:31:12 <metahumor> dmwit: what happens if i did "`(`add`)`"?
18:31:14 <dmwit> > (chunksOf 2 >=> drop 1) "abcdefg"
18:31:17 <lambdabot>  "bdf"
18:31:26 <dmwit> That's much better.
18:31:41 <jle`> :t (tail <=< chunksOf 2)
18:31:42 <dmwit> And easy to generalize to the "every 12th character" case, too.
18:31:44 <lambdabot> [c] -> [c]
18:32:34 <dmwit> jle`: doesn't generalize...
18:32:44 <jle`> oh yeah
18:32:47 <dmwit> > (chunksOf 3 >=> (tail . tail)) "abcd"
18:32:51 <lambdabot>  "c*Exception: Prelude.tail: empty list
18:33:08 <dmwit> > (chunksOf 3 >=> drop 2) "abcd"
18:33:11 <lambdabot>  "c"
18:33:22 <jle`> drop n = drop (n - 1) . tail
18:33:35 <dmwit> metahumor: Looks like a syntax error to me.
18:33:39 <iqubic> What's the best way to take two Ints, x and y, and check if one is a multiple of the other? Note, x might be bigger than y, equal to y or smaller. All I know is that I have two Ints.
18:33:43 <dmwit> > `add` -- not a valid expression
18:33:46 <lambdabot>  <hint>:1:1: error: parse error on input ‘`’
18:34:13 <iqubic> I wrote "x `mod` y == 0 || y `mod` x == 0" but that seems clunky and weird.
18:34:26 <dmwit> Seems natural and good to me.
18:34:31 <iqubic> Is there a better way to do that?
18:34:41 <jle`> be careful to make sure neither are 0
18:34:41 <metahumor> some weird arrow stuff
18:35:19 <iqubic> jle`: I'll need to add that in.
18:36:14 <iqubic> In fact I'm going to add some checks to make sure that the Ints are non-zero positive integer
18:36:41 <metahumor> iqubic: f x y | y == 0 = False | x < y = f y x | otherwise = x `mod` y == 0
18:37:06 <iqubic> metahumor: that looks good.
18:37:19 <dmwit> metahumor: f 0 0 = False looks like a bug
18:37:39 <metahumor> can 0 evenly divide anything?
18:37:59 <dmwit> That's not what he asked. What he asked was "check if one is a multiple of the other". And 0 is definitely a multiple of 0.
18:38:02 <iqubic> dmwit: let's just add an x == y guard before the y == 0 guard.
18:38:21 <sqooq> metahumor, hey if it means anything. For my list-based version of my library, the "go" trick fixes things, and so a delay function that just pads with zeros can be used
18:38:23 <metahumor> ah, you're right
18:39:07 <metahumor> sqooq: if you need a default value, maybe a List isn't the best approach
18:39:15 <metahumor> i mean, padding a List
18:39:40 <iqubic> f x y | x == y = true | y == 0 = false | x < y = f y x | otherwise = x `mod` y == 0
18:39:46 <orion> Anyone know what could be causing these errors on OSX?: kevent: does not exist (No such file or directory); ioManagerDie: write: Bad file descriptor
18:39:47 <iqubic> That'll work for me.
18:39:54 <metahumor> "variable not in scope: true"
18:40:13 <dmwit> monochrom, sqooq: I have a cunning plan. Write `memoSignal :: (Signal a b -> Signal a b) -> Signal a b` that unwraps, calls `memoFix`, and rewraps once and for all.
18:40:14 <iqubic> orion: can we see the code that is producing those errors.
18:40:39 <iqubic> metahumor: I'm coming from java where True and False were lowercase.
18:40:46 <orion> iqubic: The entire repository?
18:41:19 <metahumor> iqubic: "bool" and "maybe" are functions, don't get confused =)
18:41:28 <iqubic> What does bool do?
18:41:34 <iqubic> I know what maybe does.
18:42:15 <iqubic> orion: It's easier for us to help you if you can figure out exactly what function or line of code is causing that error.
18:42:26 <iqubic> Is this a stack error or something?
18:42:30 <jle`> https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Bool.html#v:bool
18:42:36 <orion> iqubic: It's a proprietary application and I'm under NDA.
18:42:47 <metahumor> iqubic: "bool onFalse onTrue boolVal = if boolVal then onTrue else onFalse"
18:42:53 <orion> However, I have full access to do whatever profiling/debugging is needed.
18:43:11 <jle`> bool is basically maybe for Bool
18:43:19 <iqubic> Yeah I see.
18:43:20 <glguy> Maybe you can pay someone to also sign the NDA and help
18:43:25 <metahumor> orion: there's some things where Handles can't be read from and written to simultaneously
18:43:34 <jle`> and maybe is basically either for Maybe
18:43:51 <iqubic> jle`: I understand that.
18:44:21 <orion> metahumor: Interesting. I've got a RabbitMQ connection, postgres connection, and stdin/stdout/stderr.
18:48:44 <sqooq> metahumor, my list version of my code is just another version of my code, it's not my final goal, it's just easier to work with sometimes
18:50:29 <orion> I've reproduced the problem with eventlogging enabled.
19:08:19 <orion> base must match >=4.5 && <4.11, but the stack configuration has no specified version (latest matching version is 4.10.1.0) <-- thanks stack
19:08:41 <orion> I literally can't even...
19:09:10 <orion> Has anyone experienced an error like that when building with --profile?
19:11:46 <geekosaur> that to me sounds like you don't have a version of base built for profiling
19:12:08 <geekosaur> which implies you are using --system-ghc and you need to install the system packages with the haskell profiling libs
19:13:02 <geekosaur> (if it were a stack-installed ghc, it should have them already or know how to obtain them; it's --system-ghc where its hands are tied)
19:13:56 <geekosaur> that particular error message is arguably the single most incomprehensible one in stack --- but it reflects the fact that there are too many possible causes and no way for it to know what;s going on
19:14:01 <geekosaur> IOW it's as confused as you are :)
19:14:48 <monochrom> "Computer confesses confusion, passes Turing Test"
19:15:20 <geekosaur> nah. it confessed confusion. which is different from what most humans do usually
19:15:30 <geekosaur> (which is typically XY problem)
19:15:38 <monochrom> Oops.
19:26:32 <orion> geekosaur: Bingo. That was *precisely* it.
19:28:34 <Zemyla> I wish there were a Hint-like library that made it easier to create well-typed expressions.
19:29:20 <MarcelineVQ> "<geekosaur> that particular error message is arguably the single most incomprehensible one in stack" and the single most common one :X
19:29:42 <Zemyla> I think it'd use something similar to distributed-static.
19:41:52 * hackage generic-lens-labels 0.1.0.1 - GHC.OverloadedLabels.IsLabel instance for lenses from ghc-generics  https://hackage.haskell.org/package/generic-lens-labels-0.1.0.1 (duog)
19:43:52 * hackage generic-lens-labels 0.1.0.2 - GHC.OverloadedLabels.IsLabel instance for lenses from ghc-generics  https://hackage.haskell.org/package/generic-lens-labels-0.1.0.2 (duog)
19:47:15 <iqubic> Zemyla: Why can't you use hint?
19:47:31 <wedify> does anyone happen to know why sdl and glfw programs don't run properly when you load them in ghci? when i do it i get ghost windows that can be moved but not closed
19:49:02 <buhman> is there any "code challenge" that isn't excessively math-heavy?
19:49:29 <glguy> advent of code finished up recently, so a bunch of us have solutions to share
19:49:37 <iqubic> buhuman: Try Advent of Code.
19:49:42 <glguy> and have the problem in mind if you have questions
19:49:50 <iqubic> That wasn't to math heavy this year.
19:50:24 <iqubic> 25 two part coding challenges for you to try your hand on.
19:50:37 <iqubic> the two parts of each challenge are related.
19:52:32 <iqubic> buhman: If you do ask for help, please tell us which day and which part you're working on so we can help you.
19:54:13 <geekosaur> wedify, it will depend on platform, but generally it's related to thread local state that opengl expects to be stored in the main thread --- but most I/O is done in worker threads
19:56:22 <Zemyla> iqubic: (a) I'd rather not have to take an ADT that I want to convert to bytecode, transform it all the way to Haskell, and have hint transform it all the way back; and (b) it's very difficult to pass data into the inner interpreter, and almost impossible to pass functions.
19:57:02 <iqubic> Wait, hint isn't an editor plugin?
19:57:10 <iqubic> I don't know what hint is then?
19:57:34 <monochrom> Hint: Ask Hackage. :)
19:58:04 <Zemyla> iqubic: hint is a package that provides a typesafe eval from a String.
19:59:44 <vaibhavsagar> iqubic: perhaps you were thinking of hlint?
19:59:53 <iqubic> yes. I was
20:00:23 <wedify> geekosaur: thx
20:00:30 <Zemyla> I am not sure whether it creates another interpreter, or just creates BCOs and runs those in the current program.
20:00:36 <Zemyla> The code is almost impenetrable.
20:02:52 <vaibhavsagar> Zemyla: it says it's a wrapper around the GHC API
20:03:00 <vaibhavsagar> which AFAIK interprets bytecode
20:03:15 <geekosaur> you're thinking at least one level up from where Zemyla is
20:03:53 <iqubic> I am? Or is someone else?
20:04:23 <ReinH> iqubic: Yes.
20:05:21 <Zemyla> I only just recently found out there was an actual thing that printed out the bytecode when compiling a file.
20:05:31 <vaibhavsagar> wait what
20:05:37 <vaibhavsagar> tell me more please
20:06:12 <geekosaur> -ddump-bcos
20:07:02 <vaibhavsagar> cool!
20:07:06 <monochrom> Oh! I should learn to read bytecode some day. ("Achievement unlocked: can read bcos.")
20:07:53 <Zemyla> I need to learn how to write bytecode.
20:09:56 <Zemyla> Also, the fact that GHC does no optimization whatsoever when compiling bytecode is a bit baffling.
20:10:37 <amalloy> hm. which file is produced by -ddump-bcos?
20:11:14 <geekosaur> like any other dump, it's to stderr by default or to foo.dump-bcos
20:11:28 <geekosaur> Zemyla, it's just that nobody has bothered
20:12:05 <geekosaur> although part of that is that one of the normal optimizations involves unboxed tuples... and there's an assumption baked deep in the bco interpreter that tuples aren't boxed.
20:13:07 <amalloy> geekosaur: i ran `stack exec -- ghc -ddump-bcos src/Main.hs` and i don't see such a file anywhere in .stack-work/ or on my stderr
20:13:08 <geekosaur> which means if you enable optimization in interpreted mode, the interpreter promptly dumps core on the first I/O operation because it thinks the State# unboxed tuple is boxed and tries to use data as a pointer
20:14:06 <geekosaur> interesting. wonder if that is stack or ghc
20:14:14 <Zemyla> geekosaur: I thought it could run such code because the State# data is 0 bytes and thus doesn't actually exist?
20:14:21 <amalloy> the closest thing i found was a file called Main.dump-hi
20:14:28 <amalloy> but i don't think that's bytecode
20:14:32 <Zemyla> amalloy: It dumps to stdout.
20:14:54 <geekosaur> oh.
20:15:05 <geekosaur> you only get bytecode if it's running in bytecode mode
20:15:08 <geekosaur> runghc or ghci
20:15:26 <geekosaur> if it's generating object code, the bco path is not followed (unless it's needed for TH splices)
20:15:30 <amalloy> ah
20:16:11 <amalloy> indeed, that makes it go
20:16:28 <Zemyla> amalloy: A simple way to do it: "stack exec -- ghci | tee Main.bcos", then type in ":set -ddump-bcos", followed by ":load src/Main.hs", and finally ":q".
20:16:44 <amalloy> yep, just did that
20:16:46 <geekosaur> Zemyla, I'd have to dig but someone was trying to implement this over in #ghc several months ago and ran into this problem
20:17:20 <geekosaur> tried to track it down and gave up because it'd require a major overhaul of the bytecode interpreter to fix
20:17:37 <amalloy> i've read a lot of jvm bytecode in my life, and i can say with certainty that this is (unsurprisingly) not jvm bytecode
20:17:43 <geekosaur> hm, maybe it does work specifically for I/O
20:17:54 <geekosaur> yeh, it's not JVM, not Beam, not CLR...
20:17:59 <geekosaur> it's its own weird thing
20:20:40 <amalloy> hm, how do i make it output core?
20:21:13 <Zemyla> amalloy: -ddump-simpl
20:21:17 <geekosaur> ^
20:21:46 <iqubic> ghc is a weird beast.
20:23:06 <mrkgnao> how do I use bound to encode dependent function types (pi-types)? (x : A) -> B binds both x and A in B, correct?
20:25:37 <Zemyla> geekosaur: And GHCi can handle unboxed values, like Int# or ByteArray#.
20:26:27 <geekosaur> as long as they are not tuples
20:44:56 <mrkgnao> does anyone here know Bound?
20:54:39 <dibblego> mrkgnao: the library? yes
20:57:16 <dalaing_> mrkgnao: someone mentioned you have a question about Bound?
20:57:42 <dalaing_> also: I'm a big fan of your various writings etc..
20:57:52 * hackage time 1.8.0.4 - A time library  https://hackage.haskell.org/package/time-1.8.0.4 (AshleyYakeley)
20:58:38 <mrkgnao> oh, sorry, issed that
20:58:47 <mrkgnao> dibblego: yes
20:59:15 <buhman> http://lpaste.net/361487 this seems almost-right, except for the list-circularization thing
20:59:28 <mrkgnao> how do I encode a dependent arrow in Bound? for example, in (x : A) -> B, x and A should both be in scope in B
21:00:15 <dalaing_> that can get messy :)
21:00:16 <buhman> I "solved" the actual question just by adding the digit to then to the end of the number, but I have no idea how to do literally that in haskell or something more clever
21:00:25 <mrkgnao> I can think of doing {A : Type} -> (x : A) -> B, but does that mean I use a separate form to bind types?
21:00:47 <dalaing_> so you have two options that I know of
21:00:52 <mrkgnao> or should I bind two things at once, using something like Scope Bool _ _?
21:01:30 <mrkgnao> the latter sounds icky
21:01:47 <dalaing_> you can have TermF tyV f tmV for terms and TypeF tmV f tyV for types, and have newtypes that flip around the positions of the term and type variables for use with Monad / Bound instances
21:04:11 <dalaing_> or you can have something like data Ick a = Var a | IckTerm (TermF Ick a) | IckType (TypeF Ick a), IckVar a = TmVar a | TyVar a, data Term a = Ick (IckVar a), and a pile of smart constructors / prisms etc..
21:04:29 <orion> In .prof output, does %alloc refer to the number of allocations or the size of the allocations?
21:05:00 <dalaing_> basically one big structure you can substitute through, with pieces of your data types keeping things on track, and smart constructors holding it together so it doesn't explode
21:05:12 <mrkgnao> dalaing_: the second one sounds painful imo
21:05:17 <glguy> A way to unnest the list comprehension in buhman's paste: digits num = reverse [m `mod` 10 | n <- [0..], let m = num `div` 10 ^ n, then takeWhile by (m > 0)]
21:05:26 <mrkgnao> it does remind me of your "little languages" talk
21:05:27 <dalaing_> I have some stuff in here to make it less painful: https://github.com/dalaing/type-systems
21:05:43 <glguy> buhman: Do you have a question about how to implement something in Haskell or do you just not know how you'd go about computing the answer in general?
21:05:55 <dalaing_> type-systems is kind phase 2 of little languages, and there will be a phase 3 before too long
21:06:26 <buhman> glguy: I guess my question is more like "how should I be thinking about the problem overall?"
21:07:29 <glguy> buhman: the easiest way is to just append the head of the list onto the other end before you process it
21:07:50 <glguy> Otherwise you could remember the head of the list in an argument in order to use it when you process the very last element
21:08:10 <mrkgnao> so you prefer the latter approach, dalaing_?
21:08:26 <dalaing_> https://github.com/dalaing/type-systems/blob/master/src/Fragment/Int/Ast/Term.hs#L99 and https://github.com/dalaing/type-systems/blob/master/src/Fragment/Int/Helpers.hs show what you end up with
21:08:32 <buhman> is there a reason why the answers on reddit do this in 3 stages?
21:08:45 <buhman> https://www.reddit.com/r/adventofcode/comments/7gsrc2/2017_day_1_solutions/dqlhkcj/
21:08:47 <glguy> buhman: I don't know, are you looking at a particular answer?
21:09:04 <mrkgnao> that repo looks very cool, btw. can it handle things that don't conform to the, idk, "setup" of STLC/Fw etc?
21:09:19 <dalaing_> I basically tried the latter approach because of something Ed said about the use of bound in Ermine, it seems to be pretty good so far (once you section away the bookkeeping)
21:09:22 <glguy> buhman: That solution solves the problem once and then uses that single solution for part 1 and 2
21:09:29 <lightandlight> mrkgnao: In `(x : A) -> B`, is `A` concrete, or was `(A : Type) -> (x : A) -> B` closer to what you meant
21:09:48 <buhman> oh, there's a part 2
21:09:50 <dalaing_> I've been trying out the former approach for something else at the moment, not quite done with that yet though
21:10:03 <mrkgnao> e.g. OutsideIn(X), for which you have a constraint solver integrated into the system, or systems where the inference engine elaborates to a core lang on-the-fly
21:10:23 <dalaing_> I haven't tried it with anything off the main path of STLC / Fw yet
21:10:24 <mrkgnao> lightandlight: concrete, otherwise I'd want {A : Type} -> ... with two binders and be done
21:10:31 <glguy> buhman: Once you've solved a problem you might be interested in looking at my solutions, I tried to comment them pretty well https://github.com/glguy/advent2017/blob/master/execs/Day01.hs#L66
21:10:35 <dalaing_> I wouldn't mind playing with some affine types for it
21:10:59 <buhman> wow that looks super helpful, thanks!
21:11:18 <dalaing_> and I'm keen to play with different kinds of inference algorithms - I'm keen to have a crack at HMF / HML and a few others
21:11:33 <lightandlight> Alright, so why do you need shenanigans
21:11:52 <amalloy> buhman: also, i have a youtube series wherein i explain my haskell AoC solutions
21:12:05 <mrkgnao> lightandlight: aren't x and A both in scope in B? how do I encode that with Bound?
21:12:12 <dalaing_> if I can use the stuff from Scoped Type Labels for row polymorphism / polymorphic variants along with inference for most of System Fw via HML I'll be happy for a while :)
21:12:21 <amalloy> https://www.youtube.com/playlist?list=PLKDpSfFMS1VTrh_S3pfy_oiwyxbc26H1z if you're interested
21:12:38 <mrkgnao> (bear in mind I'm very new to it and only grok the untyped LC example ~properly)
21:13:07 <mrkgnao> dalaing_: sounds cool. that repo is a Framework™ :)
21:13:09 <lightandlight> But you said `A` is concrete
21:13:18 <lightandlight> So isn't `x` the only thing that needs to be instantiated in B?
21:13:20 <dalaing_> mrkgnao: you could have data S ty tm = STy ty | STm tm and Scope (S ty tm) f a
21:13:21 <buhman> why is day 12 deleted?
21:13:30 <dalaing_> or something like that
21:13:47 <amalloy> oh, thanks for pointing that out. i didn't realize that deleted video was in the playlist
21:13:51 <dalaing_> it would come out the same as Bool if you were only binding things one at a time
21:14:14 <amalloy> buhman: i did day 13 before day 12, and i guess uploaded them in the wrong order the first time
21:14:15 <mrkgnao> lightandlight: oh, right
21:14:33 <lightandlight> `Pi n (ExprF n a) (Scope (Name n ()) (ExprF n) a)`
21:14:34 <mrkgnao> damn, I wasn't thinking correctly. now the setup in Sixten makes sense to me.
21:14:36 <lightandlight> is what I had
21:15:00 <dalaing_> once you get how the "let" stuff works in the LC example, I think you'll be good to take over the world :)
21:15:10 <mrkgnao> the (ExprF n a) is the type?
21:15:34 <glguy> buhman: since you're doing these in Haskell you might join our private leaderboard: http://adventofcode.com/2017/leaderboard/private 43100-84040706 . Helps show how far along everyone else and helps to find links to solutions
21:15:35 <dalaing_> lightandlight: heh, I forgot that you were a `bound` convert :)
21:15:47 <lightandlight> Yeah https://github.com/LightAndLight/lambdapi/blob/master/src/Expr.hs
21:15:49 <mrkgnao> and the binder is the actual pi-type?
21:15:52 <mrkgnao> ah, cool
21:15:58 <lightandlight> dalaing_: Bound and dependent types :>
21:16:05 <mrkgnao> is that the "tutorial dependently-typed LC" paper?
21:16:34 <lightandlight> `pi (x : A) B` is a single construct
21:17:14 <lightandlight> Yeah
21:17:39 <lightandlight> I don't remember whether I actually implemented it correctly, but I know I got it working with bound
21:17:44 <mrkgnao> I was trying to understand how the datacon translates to that
21:18:56 <mrkgnao> okay, I understand this. now suppose I did want (A : Type) -> (x : A) -> B, would I have to have a separate form for binding types?
21:20:05 <lightandlight> The first argument to `Pi` is the dependent function's argument name
21:20:06 <lightandlight> The second argument to `Pi` is the type of the dependent function's argument
21:20:07 <lightandlight> The third argument is the output type of the dependent function, abstracted over the name
21:20:34 <mrkgnao> `n` is a name hint?
21:20:50 <lightandlight> `A` would be a valid identifier in your lang, and that type would be `Pi "A" Type (Pi "x" (Id "A") (Id "B"))` or some such
21:21:19 <lightandlight> Since types are terms, you only need a single binding construct
21:21:27 <mrkgnao> ah, okay
21:22:32 <orion> I'm using aeson to parse JSON from a RabbitMQ queue. During peak load the application uses all available system memory. This is my heap profile: https://i.imgur.com/0UYpriT.png
21:22:47 <orion> How should I interpret these results?
21:23:12 <mrkgnao> lightandlight: dalaing_: thanks, I'm happy with this stuff now. :)
21:23:25 <dalaing_> no worries
21:23:37 <orion> Cost center 39587 is from runParser in Attoparsec
21:23:40 <lightandlight> Awesome, also come hang on #qfpl ;)
21:24:00 <dalaing_> I'd still suggest playing with Let in LC - once you have that, you have `bound` down pretty well
21:24:43 <dalaing_> that's how I got properly comfortable with the `b` in `Scope b f a`, at any rate :)
21:24:48 <lightandlight> Patterns seem a bit cray
21:25:03 <dalaing_> in what context?
21:25:32 <lightandlight> Patterns using bound
21:25:37 <dalaing_> I should really finish of the redundancy / incompleteness stuff for patterns in type-systems
21:25:43 <lightandlight> I just remember looking at the example and having a bit of a wat moment
21:25:52 <dalaing_> I've got some patterns and bound stuff in there
21:26:06 <mrkgnao> dalaing_: what about GADTs? that's fun
21:26:22 <dalaing_> I'm trying to do everything else first :)
21:26:31 <mrkgnao> it's the only part of the Sound and Complete paper I have left to implement: coverage checking
21:26:49 <mrkgnao> in the presence of GADTs that's ... enjoyable
21:26:52 <dalaing_> although if something else pushes me to add existentials, I may as well go for it
21:27:07 <mrkgnao> mhm
22:15:05 <Junior> Anyone worked with React.js interoperating with Haskell?
22:18:40 <vaibhavsagar> Junior: can you clarify what you mean by 'interoperating'?
22:19:15 <Junior> I mean including React.js library in a Haskell web app?
22:20:11 <vaibhavsagar> Junior: you can include arbitrary files in a Haskell package
22:21:18 <vaibhavsagar> React.js is backend-agnostic, right?
22:21:47 <Junior> Is there any preferred way to include react.js?  Taking a look I see there is react-flux, react-haskell, ghcjs-react.
22:43:23 <boj> there's not much adoption in that area. probably because most groups pick up reflex or purescript
22:43:53 <boj> or elm i suppose
22:45:01 <lightandlight> Junior: Do you want to write react-compatible code using haskell?
22:45:49 <Junior> lightandlight: Can you explain what you mean by write react-compatible?
22:46:32 <lightandlight> The Haskell code is compiled into javascript that uses React.js
22:50:01 <Junior> lightandlight:  I'm learning Haskell now.  However to make myself marketable in the area I'm living it seems there is a demand with React.js.  So I was thinking building something that uses both to learn both at the same time.
22:50:25 <boj> Junior: you could write a backend in haskell, and a frontend in react
22:52:28 <Junior> boj:  Okay, so your saying it is doable to learn both at the same time by creating a project that uses haskell in the backend and read in the front end?  Or would it be more efficient to focus just on Haskell right now, then once I feel proficient move on to react?
22:53:14 <boj> Junior: depends on your priorities. if you want a job in a react hungry world, do that first. if you have a line to a haskell job, then that would make sense
22:53:56 <boj> if you want to find pure haskell jobs then forget react, and investigate reflex
22:56:41 <Junior> boj: You wouldn't recommend both at the same time?  My interest is in Haskell, and I'm feeling if I switch focus that would be wasted effort.  However, where I live there really isn't Haskell demand.  So to balance this out I was thinking of doing both together.
22:58:27 <boj> Junior: sorry, definitely both if you have the time and your goal is to make a full stack app :)
22:59:10 <boj> scotty is fairly trivial to get started with, but if you want to dive deep into fully typed power look into servant
23:01:36 <Junior> boj: Thanks for the input.  I just want to make sure I'm not getting too over my head trying to do both.  I guess I won't know for sure until I give it a try, and best thing to do is build something that combines both. :)
23:01:56 <boj> Junior: indeed, good luck :)
23:02:13 <Junior> boj: Thanks :)
23:02:47 <dminuoso> Junior: Im at least planning to use Haskell driven data processing in my web app, though it's very separated from the stack, and so far away from React that neither is aware of the others existence.
23:04:50 <Junior> dminuoso: Are you saying your planning something like I've described?
23:05:59 <dminuoso> Junior: Well we have React driven webapps, but I got bored with React - which is why Im learning Haskell now. :-)
23:09:01 <Junior> dminuoso: I see.  My feeling is with just focusing with Haskell too. :-)  However, there seems to be an abundance of positions where I live with react.  So to make myself marketable for jobs it seems that it would be wise to get knowledge in this as well.
23:09:57 <dminuoso> Junior: Have not seen many Haskell jobs in my area either. For now Im pushing to try out some Haskell in some small company projects, but the main goal is just broadening my own horizon.
23:10:28 <dminuoso> But Im still at the early steps of trying not to be overly confused by staring at Haskell code.
23:11:49 <Junior> dminuoso: How would you say the learning curve is with React?  Also pre-requistes?  How much javascript knowledge is necessary?  Also do I need to know much about html and css?
23:13:47 <Junior> dminuoso: I see, yeah that seems like the same reasons I want to learn Haskell.  It looks something that will definitely broaden my horizon.
