00:02:37 <u-ou> What are some good books on lambda calculi
00:04:37 <opqdonut> Pierce's Types and Programming Languages is nice
00:04:53 <opqdonut> basically introduces the lambda cube
00:06:26 <u-ou> sounds cool i don’t know what that is
00:06:55 <opqdonut> well it's this classification system for typed lambda caulculi
00:07:07 <u-ou> ok
00:07:15 <opqdonut> but the focus of the book is perhaps more on type theory
00:07:19 <opqdonut> basic type theory
00:07:33 <opqdonut> anyway it's a nice book
00:07:55 <u-ou> ok, I’ll add it to my stack :)
00:20:50 <ski> @where TaPL
00:20:50 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
00:21:12 <opqdonut> thanks
00:37:34 <dxtr> So, I don't quite understand why this isn't working: https://git.fsfe.org/dxtr/bwhs - seems like I can't get the types right
00:38:33 <opqdonut> what error are you getting? linking the whole repo is a bit unhelpful
00:44:43 <Barry_> Hallo again :). Can someone help me to understand why a certain line works?
00:44:47 <Barry_> https://pastebin.com/THduYrdB
00:45:00 <Barry_> I dont understand what this "Var x   -> ($x)" exactly does
00:45:53 <Barry_> I belive it uses "(->) r" to retrieve the data from the state (store in this case)
00:46:23 <Barry_> but it doesnt make any sense to me why putting a $x works
00:47:00 <srhb> Barry_: Is that a template haskell splice?
00:47:01 <ski> `($x)' has type `Store x -> Int', here
00:47:26 <Barry_> I dont know what you mean?
00:47:33 <Barry_> that is code from our class
00:47:35 <jle`> Barry_: are you familiar with the ($) operator
00:47:38 <Barry_> yes
00:47:44 <jle`> are you familiar with operator sections?
00:47:49 <jle`> > (/5) 10
00:47:52 <lambdabot>  2.0
00:48:07 <jle`> (/5) is syntactic sugar for \x -> x/5
00:48:11 <jle`> so (/5) 10 is 10/5
00:48:21 <jle`> > (*2) 10
00:48:25 <lambdabot>  20
00:48:33 <jle`> > ($1) succ
00:48:36 <lambdabot>  2
00:48:42 <Barry_> yes I understand that
00:48:42 <jle`> > succ $ 1
00:48:44 <Barry_> but in this case
00:48:47 <lambdabot>  2
00:48:48 <Barry_> we have
00:48:56 <Barry_> Exp x -> Store x -> Int
00:49:11 <Barry_> oh
00:49:16 <Barry_> ($x) store x
00:49:20 <Barry_> is what is called than
00:49:22 <jle`> yeah, so whatever thing you return has to have type (Store x -> Int)
00:49:31 <jle`> ($x) is sugar for \store -> store x
00:49:48 <jle`> er, for \store -> store $ x
00:49:55 <jle`> just like how (/5) is sugar for \blah -> blah / 10
00:49:55 <dxtr> opqdonut: Sorry about that!
00:49:59 <dxtr> Moment :)
00:50:03 <jle`> * blah / 5
00:50:21 <dxtr> Worked dragged me into a meeting as soon as I posted it
00:50:29 <dxtr> s/Worked/Work'
00:50:36 <dxtr> .. Typing is hard
00:50:59 <Barry_> so if I tried to take that trhhough its type
00:51:00 <jle`> Barry_: if it helps, you can write out the desugared way
00:51:14 <jle`> Con i -> \store -> i
00:51:23 <jle`> Var x -> \store -> store $ x
00:51:41 <jle`> but, you see, `\store -> store $ x` is ($ x), just like how `\x -> x / 5`is (/5)
00:52:06 <Barry_> yeah I understand
00:52:08 <Barry_> thanks
00:52:19 <jle`> np
00:52:42 <jle`> > map ($5) [succ, pred, (*2), negate]
00:52:45 <lambdabot>  [6,4,10,-5]
00:52:52 <jle`> ^ if that makes sense to you, then you should be good :)
00:52:59 <dxtr> So, the repo here: https://git.fsfe.org/dxtr/bwhs, compile time warnings: https://gist.github.com/dxtr/9ed79201cff985f8b4c7347c88a112f4, run time errors: https://gist.github.com/dxtr/1fde5ea5823f0d9151fc1a7bd06ede86
00:53:07 <dxtr> I can't seem to get any types correct
00:53:11 <Barry_> yeah that one is easy
00:53:18 <Barry_> we are learning reader monads
00:53:30 <Barry_> and as you can see in the function I posted you
00:53:42 <Barry_> we are making use of a reader functor (?)
00:53:55 <Barry_> and our own task is to apply what we learned
00:53:55 <jle`> fwiw ($5) is probably not the easiest thing to read
00:54:01 <Barry_> for: bexp2store :: BExp x -> Store x -> BStore x -> Bool
00:54:17 <jle`> i've been using haskell for a long time and i'm still on the fence about using it
00:54:19 <opqdonut> dxtr: seems like the structure of your servant handler isn't matching the api. that's a pretty common problem
00:54:27 <Barry_> xD
00:54:29 <jle`> obviously (`id` 5) is better
00:54:31 <jle`> hehe
00:54:56 <Barry_> but thanks a lot I will try doing my assignment with this information
00:55:05 <jle`> or (`id`x) to be even more cryptic
00:55:23 <ertes-w> ello
00:55:26 <opqdonut> dxtr: note how your BwhsAPI doesn't have a :<|> but your handler has a <|>
00:55:55 <opqdonut> dxtr: maybe try with "handlers = registerHandler" since you're only defining the register api
00:56:17 <jle`> hullo
00:56:31 <opqdonut> dxtr: also, with servant it's useful to add as much type annotations as you can
00:56:43 <opqdonut> dxtr: to get better type errors
00:57:10 <dxtr> opqdonut: Yeah I tried that first
00:57:23 <dxtr> doing `handlers = registerHandler`
00:57:30 <dxtr> Didn't work either :p
00:57:33 <opqdonut> dxtr: so I recommend a "handlers :: Handler BwhsApi"
00:58:08 <opqdonut> sorry, "Server BwhsApi"
00:58:17 <opqdonut> and if you're composing many handlers, type all of them as well
00:58:40 <opqdonut> also note you have defined the register api type in two places
00:58:41 <opqdonut> type BwhsAPI = "api" :> "accounts" :> "register" :> Post '[JSON] Int
00:58:49 <opqdonut> type RegisterAPI = "api" :> "accounts" :> "register"
00:58:54 <opqdonut> :> Post '[JSON] AccountReq
00:59:26 <opqdonut> you need to work systematically when using something as type-heavy as servant
00:59:32 <opqdonut> just trying out random stuff will lead to pain
00:59:40 <dxtr> Hehe
00:59:40 <maerwald> there was this thread where someone said something witty about expressivity in programming languages, I can't remember
00:59:44 <opqdonut> stop, think, and perhaps start with a simple example application that you extend bit by bit
01:02:27 <ertes-w> suggesting the conclusion that the more you encode on the type level, the less you can use rapid prototyping – though in general i think that conclusion is wrong
01:09:58 <raquai> hey there, quick question: can I use a certain type in list pattern matching, like can I put (Int:xs) instead of (x:xs)?
01:12:21 <cocreature> no
01:12:29 <cocreature> raquai: what do you expect that to do?
01:12:43 <cocreature> raquai: types are a static property, they are not present at runtime. pattern matching however is a runtime thing
01:13:14 <raquai> ok, so then i'll just do (x:xs) with a case of :)
01:13:33 <ski> the `case'-`of' containing which patterns ?
01:13:34 <cocreature> you can’t do a case of to figure out the type of something either
01:19:19 <ski> @let figureItOut x = case typeOf x of t | t == typeOf (undefined :: Int) -> "an integer : " ++ show (fromJust (cast x) :: Int) | t == typeOf (undefined :: Bool) -> "a boolean : " ++ show (fromJust (cast x) :: Bool) | otherwise -> "something else .."
01:19:22 <lambdabot>  Defined.
01:19:28 <ski> > figureItOut False
01:19:32 <lambdabot>  "a boolean : False"
01:19:34 <ski> > figureItOut (37 :: Int)
01:19:39 <lambdabot>  "an integer : 37"
01:19:40 <ski> > figureItOut (37 :: Integer)
01:19:45 <lambdabot>  "something else .."
01:19:52 <raquai> well no it's not for like Int's or something, it's to use with my own data type :)
01:19:59 <raquai> and there it works
01:20:04 <cocreature> oh then you can also use it in a list
01:20:18 <raquai> yeah?
01:20:36 <raquai> so if I have something like data Fruit = Apple | Banana
01:20:45 <raquai> and then put (Apple:xs)
01:20:48 <raquai> that would work?
01:20:54 <ski> then `Apple' and `Banana' are not types, but data constructors
01:21:03 <raquai> oooh ok :)
01:21:06 <ski> (`Fruit' is a type, more specifically a type constructor, though)
01:21:20 <raquai> kinda new to haskell :) thanks!
01:21:38 <ski> `Apple' and `Banana' are values. `case' operates on values, not types
01:22:05 <raquai> ooh ok nice!
01:24:45 <ertes-w> raquai: you can use type signatures in patterns, if you enable ScopedTypeVariables, which is occasionally useful, but it does not mean that the *type* is matched…  it's just another way to place type signatures
01:25:22 <ertes-w> case myFruits of (x :: Fruit) : xs -> …; [] -> …
01:26:26 <merijn> ski: to be fair, "type constructor" is not really "more specific", it's just an additional observation
01:26:27 * ski . o O ( type ascriptions )
01:26:38 <merijn> ski: Since "Fruit" is both a type and a type constructor
01:26:47 <ski> merijn : what's the difference ?
01:29:33 <jle`> types: Maybe Int
01:29:43 <jle`> and Maybe, and Int
01:29:48 <jle`> type constructors: Maybe and Int, only
01:29:55 <jle`> (maybe?)
01:30:19 <ski> well, what's the difference between "more specific" and "additional observation" ? :)
01:30:27 <jle`> type constructors and types seem to exist in orthogonal worlds
01:30:40 <jle`> type constructor is a syntactic thing, associated with expressions
01:31:03 <jle`> type is a semantic thing, about the semantics of the language
01:33:20 <ski> hm .. type constructors are names that map to (injective, i suppose) types ?
01:33:52 <ski> while type expressions can be more complicated, but still map to types (given a tyvar valuation)
01:34:36 <mniip> it depends
01:34:40 <mniip> some consider Maybe a type
01:34:54 <mniip> under that notion, tycons are just literals in the language of types
01:35:06 <jle`> Maybe is definitely a type
01:35:29 <jle`> because it can be an instance of a typeclass
01:35:32 <mniip> depending on the context I would only consider TYPE-kinded types types
01:35:52 <merijn> I think this conversation heads into the usual "concrete type" tarpit
01:35:58 <mniip> yup
01:36:02 <jle`> i remember spending some time looking into the report to see if it ever defined what a type was
01:36:10 <jle`> and there is only one situation where it comes close
01:36:18 <jle`> and it talks about instances of typeclasses as being types
01:36:37 <jle`> so um...i guess that defines it in an indirect way :)
01:37:01 <jle`> if Maybe can be an instance of a typeclass, and the Haskell Report calls typeclass instances types, then Maybe is a type ~
01:37:05 <jle`> don't quote me
01:37:13 <jle`> without attributing me
01:38:44 <jle`> of course, there's a difference between the haskell report definition and the useful definition
01:38:50 <mniip> I'm not sure but I don't think HKT exists in MLTT
01:39:36 <jle`> oh hey actually there might be more to justify my interpretation
01:39:38 <jle`> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-630004.1
01:39:46 <jle`> it lists things like (->) and (,) and (,,) as types
01:40:03 <jle`> oh, and i missed this line
01:40:31 <jle`> "Maybe and IO are unary type constructors, and treated as types with kind ∗→∗."
01:40:32 <mniip> "kinds are entirely implicit and are not a visible part of the language"
01:40:41 <mniip> ha, how much has changed since '98
01:40:54 <jle`> "Maybe and IO ... are treated as types ..."
01:41:03 <ski> early papers called classes like `Functor', "(type) constructor classes" (because clearly `Either e' is a type constructor)
01:42:18 <Barry_> hi again :D. I am currently writing my solutions and am getting a type error. My current solution (copied some stuff from Expr.hs so you have sufficiant information):https: //pastebin.com/wX793WEB
01:42:19 <mniip> ugh, terminology
01:42:22 <Barry_> Expected type: BExp x -> Store x -> Bool       Actual type: BExp x -> Store x -> BStore x -> Bool
01:42:48 <jle`> i don't think 'Either e' qualifies as a type constructor according to the Report
01:43:35 <mniip> Barry_, well, do you understand what the type error means
01:44:16 <Barry_> well I  belive I do. It has more args than it expects
01:44:19 <Barry_> or than its needed
01:44:20 <ski> Barry_ : what is the expected type of `is' ?
01:44:32 <ski> (the type you expect, i mean)
01:44:35 <Barry_> list of BExp
01:44:50 <mniip> well that is wrong
01:44:52 <Barry_> no
01:44:54 <Barry_> i menat
01:44:58 <Barry_> list of boolean
01:45:04 <mniip> still wrong
01:45:37 <mniip> :t mapM
01:45:40 <ski> as written, it would have type `[BStore x -> Bool]' .. see why ?
01:45:40 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
01:46:05 <mniip> bexp2store :: BExp x -> Store x -> BStore x -> Bool
01:46:08 <jle`> i think ok, my conclusion is that the difference between type constructors and types is that a type is a semantic value, and type constructors are 'literals' you can use in haskell to denote/express types.  so, 'Fruit' is a type constructor that can be *used* to denote a type, specifically the type defined using the 'data Fruit = ...' declaration
01:46:21 <ski> in your case, `a' is `BExp x', `b' is `BStore x -> Bool', and `m' is `(Store x ->)' (and `t' is `[]')
01:46:28 <nshepperd1> I don't think anyone calls (,) 1 a data constructor either, so that checks out
01:46:30 <Barry_> one second my brain is slow
01:46:30 <mniip> ski is faster than me...
01:46:50 <jle`> so 'Fruit', the type constructor, can be thought of a literal denoting the type Fruit
01:47:00 <jle`> just like "hello" is a string literal denoting the value "hello"
01:47:20 * ski thought they were complementing what mniip said
01:47:35 <nshepperd1> But the thing that makes me care about constructors as a concept in haskell is that you can pattern match them
01:47:49 <Barry_> That doesnt make sense to me
01:47:59 <nshepperd1> Generative + injective
01:48:00 <Barry_> why is b
01:48:06 <Barry_> Bstore x -> Bool
01:48:12 <merijn> nshepperd1: You can match on type constructors with type families, though :)
01:48:17 <ski> jle` : ok, so one could then say that type constructors are type expressions, and that both denote types. for short, i often abbreviate "type expression" as just "type", though
01:48:39 <jle`> might be the difference between expressions and values
01:48:40 <mniip> :t mapM (?bexp2store :: BExp x -> Store x -> BStore x -> Bool)
01:48:43 <lambdabot> error:
01:48:43 <lambdabot>     Not in scope: type constructor or class ‘BExp’
01:48:43 <lambdabot> error:
01:48:46 <mniip> oh right
01:48:58 <ski> nshepperd1 : what does generative mean, specifically ?
01:49:02 <mniip> (are implicit type params a thing)
01:49:09 <mniip> (I suppose not)
01:49:10 <jle`> this is actually something that i spent too much time explaining when they made me teach intro to comp sci
01:49:23 * ski idly ponders implicit keyword params
01:49:44 <jle`> but for some reason the distinction between expressions and values is really close to my heart
01:50:02 <ij> values are in normal form/
01:50:13 <ski> using a denotational notion of values .. or an operational ?
01:50:17 <ski> oh, the latter
01:50:31 <nshepperd1> merijn: yes. In fact you can match type constructors slightly more liberally in that you can match Either e against f but you can't match (,) 1 against f
01:50:49 <jle`> my example was that '4 + 8' and '12' are two different expressions that represent the same value
01:50:54 <jle`> so i went about it from a denotational perspective
01:51:01 <ski> > "ij" == "jle`"  -- hm, ok
01:51:04 <lambdabot>  False
01:51:35 <jle`> this was my attempt at teaching denotational semantics to freshmen
01:52:09 <ski> Barry_ : `Store x -> BStore x -> Bool' is `((->) (Store x)) (BStore x -> Bool)', and to match that with `m b', we get `m = (->) (Store x)' and `b = BStore x -> Bool'
01:53:14 <Barry_> you are to advanged, I cant keep up with that input you giving me. I am used to java and this is too diffrent. I am currently writing down a step by step type replacement
01:53:18 <makalu> I run stack setup on debian unstable and get this: https://pastebin.com/raw/1sxQEyvQ stack doesn't have nopie 7.10?
01:53:19 <Barry_> so I can understand it
01:53:35 <ski> Barry_ : perhaps instead of `Store x -> BStore x -> Bool', you could use `ReaderT (Store x) ((->) (BStore x)) Bool' (or `ReaderT (Store x) (Reader (BStore x)) Bool', .. or perhaps even `Reader (Store x,BStore x) Bool' or `(Store x,BStore x) -> Bool') ?
01:53:39 <Barry_> I will write it down and than ask again (if you are still here)
01:53:50 <ski> ok
01:54:02 <nshepperd1> ski: idk exactly how it is defined. I think of it like, injective lets you run a function backward to get its input. Generative lets you run a function backward to get the function itself
01:54:08 * ski has no idea whether Barry_ has seen `Reader' and `ReaderT' yet
01:54:17 <Barry_> I have
01:54:31 <Barry_> but I dont just want to use things without fully understanding the reason
01:54:36 <Barry_> xD but thanks
01:55:27 <Math22232> Barry_, what's ur issue?
01:55:33 <Barry_> (I dont need to finish the assignment I already am allowed to participate at the exam, cause I onece failed already and this time I want to actually learn the language)
01:55:40 <ski> Barry_ : roughly speaking, the problem in your code is that you have two "environment monads nested inside each other", and the `do' only "attaches" to the outermost one
01:56:38 <ski> Barry_ : it's as if you had `IO (Parser Blah)', and expected `do x <- whatever' to both execute the `IO'-action part of `whatever' *and* perform the `Parser' part of the result, leaving the parser result as `x'
01:57:09 <Barry_> what creates the double nested envioment monads?
01:57:16 <ski> Barry_ : sorry, `do' here will only "attach" to the `IO', so `x' will the the parser itself, not the parser result
01:57:19 <Barry_> is it the call to bexp2store?
01:57:47 <Barry_> ohhh
01:57:48 <ski> Barry_ : it's the fact that you have `Store x ->', and then `BStore x ->', in the type signature
01:57:58 <Barry_> I think I am understanding it
01:57:59 <mniip> hmm is there a type-level unsafecoerce
01:58:15 <ski> (as opposed to a `(Store x,BStore x) ->' that's a *single* "implicit/hidden" argument)
01:58:55 <ski> (any of the other versions involving `ReaderT' and `Reader' would also work)
02:00:11 <Barry_> I am missing something to really undersand monads and I dont know what..its the same as in MonadPlus. It was so easy, but I just couldnt get my head to solve it myself
02:00:15 <Barry_> its frustrating
02:01:02 <ski> i suspect that the problem is mostly one of getting more familiar with types in general, not with monads in particular
02:01:20 <ski> `do' notation is a thin syntactic wrapper around `(>>=)' (and `(>>)' and `fail')
02:01:35 <ski> @undo do is<- mapM (bexp2store) bs; return $  (\x->x) (\y-> (or is))
02:01:36 <lambdabot> mapM (bexp2store) bs >>= \ is -> return $ (\ x -> x) (\ y -> (or is))
02:02:07 <merijn> I usually recommend beginners avoid using do notation until their comfortable writing code with >>= and >> to minimise confusion
02:02:46 <Barry_> you know what. I should write this with >>= and >>
02:02:58 <Barry_> That will make everything more clear
02:03:09 <Barry_> Thanks for that idea
02:03:34 <merijn> Barry_: IMO for beginners do notation is to opaque and "magic" at first. It helps to know do does by doing it yourself
02:03:53 <merijn> Barry_: Also read up on how do notation is desugared: https://en.wikibooks.org/wiki/Haskell/do_notation
02:04:00 <Barry_> we learned it already
02:04:20 <Barry_> but I guess I am just not thinking about everything
02:04:43 <merijn> Barry_: ok, then you can skip that step :)
02:04:47 <ski> after a while of practicing, you get type inference running in your mind
02:05:14 <EvanR> even in languages where you thought there was no type system to speak of
02:05:26 * ski smiles
02:11:23 <Brian02> Hi guys!!
02:11:32 <Brian02> Is someone in the mood of running this code:
02:11:33 <Brian02> https://github.com/Twinside/Rasterific/blob/master/exec-src/snowflake.hs
02:11:48 <Brian02> I would bady need the timings of the criterion benchmarks.
02:12:05 <Brian02> I am getting 180ms on my fast machine and 300ms on my slow machine
02:12:19 <Brian02> (Just if anyone is interested...)
02:13:00 <Brian02> The reason is that my machines are not typical (5Ghz etc.), but I also need a more realistic feedback
02:14:20 <Barry_> ehmm
02:14:36 <Barry_> okay... so the type of k (BVar x)= x>>= \y-> return y
02:14:51 <Barry_> is k :: Monad m => BExp (m b) -> m b
02:15:03 <Barry_> why is it BExp (m b)
02:15:09 <merijn> That doesn't seem right?
02:15:15 <Barry_> I though I had to use return to make it "boxed"
02:15:19 <merijn> oh, wait "k" is the function?
02:15:23 <Barry_> yes
02:15:31 <phittacus> Hello. I'm looking into building distributed service and thought about doing it in Haskell. What are the books i should look for if I'm a little bit familiar with distributed programming from akka? And is "Parallel and concurrent programming in haskell" outdated?
02:16:26 <merijn> Barry_: You have "BExp foo" where 'x :: foo' and then do 'x >>=' therefore it infers "foo = m a" for some Monad m
02:16:30 <Barry_> and changing k to : k (BVar x)= return x>>= \y-> return y deliver the type: k :: Monad m => BExp b -> m b
02:16:57 <Barry_> I see
02:17:25 <merijn> Barry_: Then "\y -> return y" is a function "b -> m b" expected by the right hand side of >>=
02:18:10 <Barry_> I see
02:20:23 <geekosaur> phittacus, pconc book is pretty up to date
02:21:11 <Barry_> I understand it thanks. Will continue with the task
02:23:07 <ski> @where PCPH
02:23:07 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>
02:24:32 <geekosaur> parts of Haskell move pretty quickly, but the foundations with respect to this are still the same
02:25:17 <geekosaur> that said, it's about those foundations really. For building an actual application, there are newer libraries to help with various kinds of distributed setups
02:26:16 <phittacus> geekosaur: any recommendations about what are those and where to read about them?
02:28:10 <geekosaur> I don't know that anyone's collected them, beyond Hackage which is not exactly the best way to figure out which is appropriate when. (But note that we don't try to do "one framework that tries to handle all situations".)
02:28:18 <geekosaur> usually
02:29:14 <geekosaur> so there's for example the distributed-process set of packages, aka Cloud Haskell... which, for all its size and apparent completeness, is focused on one particular model of concurrency
02:29:44 <geekosaur> of distributed concurrency I should say
02:30:23 <geekosaur> I dudpect if I were in this situation, I'd be looking for blog posts of people trying to do this in Haskell, and probably end up writing a wiki article comparing the various things I found
02:30:27 <geekosaur> suspect
02:34:18 <merijn> Is there an easy way to get numbers nicely formatted in haskell?
02:34:27 <merijn> "show" is really tedious for large numbers
02:34:38 <merijn> i.e. get "11,355" instead of 11355
02:35:00 <otulp> phittacus: For an leftfield actors-centric approach, "Learn You Some Erlang for Great Good!", then go use the distributed-process package. It's actors all over. Marlow's book should come first, though.
02:36:01 <phadej> actors are good when you have more than one machine
02:36:19 <phadej> in single haskell process there are better ways to do concurrency
02:36:35 <merijn> phadej: Depends on what kinda concurrency you want/need
02:36:45 <phadej> merijn: have you checked whether fmt or formatting works for you?
02:36:54 <phadej> (I don't know what they can do)
02:37:11 <merijn> phadej: Looks a bit heavy weight for me
02:37:13 <otulp> Agreed, but phittacus asked about distributed processing, which should be more than one haskell process.
02:37:48 <merijn> phadej: Doesn't seem to support locales either?
02:38:19 <phadej> uuh, locales
02:38:34 <phadej> can I abort this discussion now :)
02:40:00 <otulp> :)
02:40:17 <merijn> phadej: It shouldn't be this hard to do "format this number according to the active locale" :\
02:40:37 <phadej> merijn: that would be -> IO String
02:40:38 <EvanR> interesting technology for distributed haskell, if you have compact regions you can send "values" to another process without a serialization deserialization step
02:40:59 <nullie> I think locales could only format monetary values like that
02:41:03 <EvanR> though it would need to be mostly static data to get any benefit
02:42:08 <merijn> phadej: I'm ok with that
02:42:19 <merijn> nullie: Eh, no?
02:42:33 <nullie> Yeah, I'm wrong
02:42:38 * geekosaur needs to find time to dig out and finish that number formatting library...
02:42:40 <merijn> nullie: Locale specify numeric separators, date format, currency, etc.
02:43:20 <geekosaur> (was going to be my first real Haskell project, but I decided there was no need for it any more --- largely because I was just coming off a databse job that had made it clear the future of report generation was PostScript)
02:44:11 <nullie> Don't you need to generate PostScript
02:44:34 <geekosaur> yes, but you need the formatting to be done on the PostScript side because font glyph widths come into it
02:45:11 <geekosaur> "traditional" report formatting kinda went away when PostScript became the norm
02:45:43 <phadej> can't you use tex (which is postscript generator? :)
02:45:55 <geekosaur> in fact we did :)
02:46:53 <phadej> bingo
02:47:00 <EvanR> i recall suggesting tex technology at an old job and being laughed out of the room
02:47:14 <EvanR> for generating reports
02:47:32 <EvanR> the right answer was clearly HTML
02:47:33 <phadej> EvanR: you should suggested node-reports (imaginary package, which would call tex behind the scenes)
02:47:43 <EvanR> node wasnt a thing back then
02:47:46 <phadej> :)
02:47:51 <EvanR> it was PHP
02:47:52 <phadej> rails-reports
02:47:53 <phadej> ah
02:47:54 <phadej> sorry
02:47:55 <phadej> :)
02:47:58 <geekosaur> the tex stuff was, uh, 1989
02:47:59 <EvanR> lol keep going back
02:48:02 <geekosaur> what html?
02:48:26 <EvanR> HTML and CSS were a horrible idea for reports
02:48:56 <ij> But can't tex render to postscript?
02:48:56 <EvanR> later on page breaking was incorporated into CSS
02:48:57 <Barry_>  Is it possible to ignore types? E.g.  For BExp x -> Store x -> BStore x -> Bool I implemented: True_ ->  (\x->(\y->True))
02:49:07 <EvanR> dont know if it works yet
02:49:15 <Barry_> But I would like to just ignore Store x-> BStore x
02:49:31 <ij> ah, phadej already aksed that
02:51:09 <Barry_> "return $ return True" works...
02:52:07 <phittacus> otulp: do actors work fine with haskell type system? Because in akka actual message passing isn't typed.
02:52:21 <geekosaur> yeh. in 1989 we were doing latex. by the early 1990s I'd tried to use both troff and tex and decided neither was really viable for some of the things I wnated to do, and was generating PostScript directly. which is why by 2006 my traditional "first programming project in a new langauge" didn;t hold my interest any more
02:53:13 <Barry_> why does return $ return True works? the type signature for return is a->m a
02:53:40 <Barry_> and e.g. BStore is x->Bool
02:53:45 <Barry_> so a becomes x
02:53:52 <Barry_> and m becomes Bool?
02:53:56 <nullie> Monad wrapped in monad?
02:54:07 <ij> Barry_: m is (->) x, a is Bool.
02:55:28 <EvanR> a mystery monad wrapped in an engima monad
02:56:15 <Barry_> how can m become (->)
02:56:31 <ij> @type return
02:56:35 <lambdabot> Monad m => a -> m a
02:56:51 <ij> Barry_: m can be any type that's a monad and -> has a Monad instance.
02:57:36 <ij> "return = const; (f >>= g) x = g (f x) x" if I'm not mistaken.
02:59:19 <ski> well, `(rho ->)' is a monad, for any `rho'
02:59:31 <ski>   return :: a -> (rho -> a)
02:59:54 <ski>   (>>=) :: (rho -> a) -> (a -> (rho -> b)) -> (rho -> b)
03:00:33 <ski> so `m' becomes `(rho ->)', for some `rho'. it doesn't become `(->)'
03:02:28 <humanoyd> geekosaur: EvanR have you, by chance, used HaTeX for writing LaTeX? looks really nice at a first glance
03:06:55 <royal_screwup21> in the context of using a map as a set, what does it mean for its keys to be "ordable"?
03:08:22 <royal_screwup21> like say you have a list of Ints. You put all of these Ints into a map where each key is an INT and its value is ()
03:08:39 <royal_screwup21> what does it mean for these keys to be ordable?
03:08:47 <EvanR> works because Int has a comparison operation
03:08:52 <EvanR> its an instance of Ord
03:09:17 <EvanR> not all types have an Ord instance
03:09:49 <royal_screwup21> EvanR: hmm why does it necessarily have to be an Ord instance?
03:10:24 <EvanR> :t insert
03:10:30 <lambdabot> Ord a => a -> [a] -> [a]
03:10:37 <royal_screwup21> oh
03:10:38 <EvanR> well, thats the list version but
03:10:48 <EvanR> the one for Map has the same Ord constraint
03:10:55 <royal_screwup21> can you import libraries on here?
03:11:09 <EvanR> the implementation of Map uses the comparison operation to make the tree work
03:11:15 <royal_screwup21> :import qualified Data.Map as M
03:11:19 <royal_screwup21> :t import qualified Data.Map as M
03:11:21 <lambdabot> error: parse error on input ‘import’
03:11:31 <royal_screwup21> ah I se e
03:13:13 <EvanR> a good example of a type which isn't "orderable" is CReal
03:13:27 <EvanR> though it probably has a broken Ord instance anyway
03:20:29 <Barry_> My brain does not want to understand this. I will try again later in the day
03:20:33 <Barry_> need to go to work now
03:20:39 <Barry_> thanks everybody for the help
03:26:57 <otulp> phittacus: I think it works well, though the matching on messages is a little more convoluted than Erlang's. You get to match on multiple types using 'receiveWait' in combination with 'match', so I usually have a receiveWait [ myFirstMatch, mySecondMatch, ...] and define myFirstMatch and so on separately in a where clause. I haven't looked too closely at Akka, so I can't compare.
03:37:13 <amca> Quick newbie question about Data.Modular: I can create a modular integer by "z = 3::Integer/7", say.  But how do I do this from a program?  So that "mkMod a b
03:37:56 <nullie> mkMod 3 7?
03:37:59 <amca> ..sorry... so that "mkMod a b", say, would produce the modular value a `Mod` b.
03:38:47 <EvanR> you can do that in a program if you want
03:38:52 <EvanR> z = 3::Integer/7
03:38:56 <EvanR> or
03:39:00 <EvanR> z :: Integer / 7
03:39:01 <amca> There isn't a "mkMod" function currently, so I'd need to write one.
03:39:07 <EvanR> z = 3
03:39:46 <amca> If I want a function "mkMod a b = a :: Integer/b" what are the types of a and b?  This is where it gets tricky.
03:39:50 <hydraz> amca: there's modVal
03:39:54 <EvanR> with top level type sigs, you might be able to use just 3, the type being inferred
03:40:12 <EvanR> you can't use b there
03:40:13 <hydraz> your problem is that mkMod a b takes two values, but b is a type—a type-level natural.
03:40:35 <hydraz> s/is/needs to be/ hmmpf
03:40:51 <amca> There seems to be the difficulty that b would be of class Nat, nut when read from the keyboard is given a Num value.
03:40:54 <EvanR> amca: you just invented dependent types, which is not a thing in haskell (yet)
03:41:02 <amca> Dammit....
03:41:29 <amca> I was sure there'd be some simple way to do what seems to be a simple operation!
03:41:33 <EvanR> there is
03:41:49 <hydraz> haskell doesn't support it
03:41:52 <EvanR> you would just the number 3 instead of mod 3 7, and rely on type inference
03:42:02 <EvanR> use the number 3
03:42:27 <nullie> can't you just use divMod for modular arithmetic?
03:42:35 <amca> The thing is I might have different types: mod 7 and mod 11 say - how do I ensure 3 gets the correct type it needs?
03:42:43 <EvanR> Modular is for modular numbers
03:43:04 <EvanR> amca: as long as you have some type sigs somewhere, it will just know
03:43:08 <EvanR> or tell you its ambiguous
03:43:24 <amca> I can use divMod, and simply mod, but the Data.Modular module wraps operations very neatly.
03:44:24 <amca> And yes hydraz, there is modVal, and also toMod, but I can't seem to use them to create a number with a modulus provided by the user.
03:45:22 <amca> So I guess, EvanR, what needs to hapen is that the user creates a modular value, and then further functions simply pick up its type automagically?
03:45:23 <Math22232> how can I do the func bexp2store with the use of the reader- monad + do-notation? https://pastebin.com/uUc34wx5 , I do get that a Reader-Monad has an enviroment, which I can get with ask, but I don't understand at all how I can use the reader monad for the func bexp2store
03:47:27 <hydraz> amca: you need a function like KnownNat n => Natural -> proxy n and I'm not sure such a thing exists
03:48:04 <hydraz> or, hm, someNatVal
03:48:12 <EvanR> :t someNatVal
03:48:14 <lambdabot> error: Variable not in scope: someNatVal
03:48:15 <hydraz> from GHC.TypeLits
03:48:26 <amca> What a nuisance!  I've seen a function fromNat somewhere
03:49:11 <EvanR> this KnownNat and SomeNat stuff is haskells version of dependent types
03:49:15 <EvanR> enjoy :)
03:49:25 <amca> It's in Data.Number.Nat
03:49:37 <EvanR> thats a different kind of Nat
03:49:51 <hydraz> those are values. you need *types*
03:49:53 <amca> "enjoy" is hardly the word... it's more frustrating!
03:50:03 <EvanR> i was kidding
03:50:17 <amca> Is it, EvanR?  well, there's my newbie status exposed...
03:50:31 <EvanR> yes
03:50:39 <EvanR> > 3 :: Nat
03:50:42 <lambdabot>  error:
03:50:42 <lambdabot>      Not in scope: type constructor or class ‘Nat’
03:50:46 <EvanR> come on
03:50:52 <EvanR> > 3 :: Natural
03:50:53 <amca> Just when I thought I was getting a hang of types, I'm dealing with classes, kinds, proxies,...
03:50:56 <lambdabot>  3
03:50:56 <hydraz> amca: actually, here https://hackage.haskell.org/package/modular-arithmetic-1.2.1.2/docs/Data-Modular.html#v:someModVal
03:51:05 <EvanR> > (-3) :: Natural
03:51:10 <lambdabot>  *Exception: Natural: (-)
03:52:11 <EvanR> amca: at a certain point, putting more information in the type system causes the complexity to cross a line
03:52:32 <amca> Thanks, hydraz, EvanR, but if I want to write a function that returns a modular value its type signature must include "i `Mod` n" with (KnownNat n)
03:52:41 <EvanR> you get more safety and expressiveness, but at a cost
03:52:58 <hydraz> amca: SomeMod is a modular value with the index n hidden
03:53:21 <amca> as in: mkMod :: (Integral i,KnownNat n) => i -> i `Mod n
03:53:28 <hydraz> there is not way to take a value (n :: Num a => a) to a type (n :: Nat) without tons of beating around the bush
03:53:41 <amca> This is what I thought.
03:53:51 <EvanR> use modVal
03:53:53 <hydraz> you need dependent types for that
03:54:03 <amca> I'd have though this should be simple and natural...
03:54:04 <EvanR> because it sounds like you know the modulus
03:54:11 <nazarewk> is there haskell docker image newer than for debian jessie?
03:54:14 <EvanR> someModVal is when you dont know until runtime
03:54:16 <nazarewk> it's seriously outdated
03:54:30 <amca> In which case maybe Data.Modular is wrong for me, in spite of the convenience it provides
03:54:45 <EvanR> modVal :: (Integral i, KnownNat n) => i -> proxy n -> Mod i n
03:55:08 <amca> I might want several different moduli in use at once
03:55:15 <EvanR> you can do that
03:55:25 <EvanR> use different second arguments
03:56:04 <amca> Orright, I'll try this out.  This is all right at the limits of my tenuous understanding
03:56:11 <EvanR> somewhere define
03:56:26 <EvanR> mod7 :: Proxy 7
03:56:37 <EvanR> mod7 = Proxy
03:56:39 <EvanR> then
03:56:47 <EvanR> modVal 3 mod7
03:56:50 <hydraz> % :t Proxy
03:56:50 <yahb> hydraz: forall k (t :: k). Proxy t
03:57:00 <hydraz> % :t Proxy @Nat @7
03:57:00 <yahb> hydraz: ; <interactive>:1:1: error:; * Cannot apply expression of type `Proxy Nat'; to a visible type argument `7'; * In the expression: Proxy @Nat @7
03:57:09 <hydraz> % :t Proxy @7
03:57:09 <yahb> hydraz: Proxy 7
03:57:11 <hydraz> ehm.
03:57:33 <EvanR> similarly for mod11
03:58:07 <EvanR> maybe theres a better name since "mod" is being repeated
03:58:14 <amca> So this would have to be done by the user in GHCi, then my functions would manage all the computations on the modular values?
03:58:36 <EvanR> i thought you were asking how to write source code, not ghci
03:59:06 <hydraz> I don't get what you're trying to do
03:59:09 <EvanR> but yes
04:00:02 <amca> I am writing a set of functions for computations on finite fields.  in GHCi, the user enters a modulus, power, and irreducible polynomial, then my functions take over from there.
04:00:24 <EvanR> i am skeptical that youre getting much out of this Modular lib
04:00:28 <amca> The problem is when I want to create a random modular value.
04:00:29 <hydraz> in which case you can just make the user write `Proxy @7` (needs TypeApplications) instead of 7
04:00:38 <EvanR> you dont need to put all that info in the type system
04:00:59 <hydraz> a value with a random modulus is going to be really complicated to make, what with having to promote the modulus to the type level
04:01:30 <amca> No - the modulus is not random!  But the values returned are.
04:01:53 <EvanR> you can make a "dynamic modulus" type... data Mod = Mod Integer Integer which knows the modulus
04:02:07 <EvanR> or get a different lib
04:02:22 <amca> I think you're right, EvanR, about the Data.Modular module; it may be not my best choice.
04:02:28 <EvanR> you seem to want to mix moduli, so
04:03:02 <amca> I don't have to use that module, of course.
04:03:50 <amca> I can just have list of integers between 0 and n-1, and ensure that all computations are done modulo n.  This is all handled in the Prelude.
04:04:45 <hydraz> well, you can wait until we have dependent haskell in 2 years or so, or you can use values when you need values and types when you need types
04:04:46 <amca> Give Data.Modular the boot (until Haskell has dependent types which are manageable by idiot newbies like me)
04:05:14 <amca> Thanks, hydraz, very sensible advice I think!
04:05:38 <hydraz> our lack of proper dependent types leads to inscrutable solutions for things like this, unfortunately
04:06:24 <amca> Is there any reason why Haskell doesn't have dependent types?  Especially given its strong type system?
04:07:44 <hydraz> Lack of people working on it.
04:08:02 <Sornaensis> you can emulate dependent types in haskell
04:08:08 <EvanR> we were just doing that
04:08:18 <EvanR> as a beginner amca is frustrated with it
04:08:25 <[exa]> amca: for the most of the good purposes you can easily fake them
04:08:28 <amca> Yep, he sure is!
04:08:37 <Sornaensis> try idris?
04:08:40 <EvanR> "easily" fake them haha
04:08:41 <[exa]> amca: do you like c++ template metaprogramming?
04:09:16 <[exa]> EvanR: it's basically prolog on typeclasses right :]
04:09:49 <amca> I have avoided c++ as much as possible... my background is in mathematically oriented languages, including Python and more recently Racket.  I experiment with Haskell every few years, but this time I'm digging a little deeper.
04:10:40 <amca> Which means I'm more and more often getting totally stumped
04:11:43 <EvanR> amca: dependent types is a really advanced area, in 1989 the haskell committee was probably more interested in exploiting stuff they knew would work and how it would work
04:11:47 <amca> I've had both idris and agda recommended to me, but I don't really want to go down the road of niche languages.
04:12:08 <Lowl3v3l> amca: if you did some typed and lazy racket haskell tends not to be that bad :)
04:12:33 <EvanR> so haskell was not designed with dependent types in mind, the current tricks were discovered later as a side effect of type classes
04:12:45 <amca> No - I like Haskell very much.  But I still find its strong typing throws up difficuties at me.
04:12:51 <EvanR> today they nonetheless have an extension in the works for real dependent types
04:13:31 <Lowl3v3l> i have some very ambivalent feelings towards haskell, but maybe i am to deep into lisp :D
04:13:38 <amca> So maybe waht we need is a document explaining in simple words of one syllable how to "fake" dependent types with the appropriate extension.
04:13:46 <EvanR> that exists
04:14:24 <merijn> You don't really want to fake dependent types in Haskell, because it's painful as hell
04:14:30 <amca> In that case I've probably read it and failed to understand it.
04:14:36 <merijn> There's a reason why the "dependent" Haskell paper is called "hasochism"
04:14:51 <Math22232> how can I do the func bexp2store with the use of the reader- monad + do-notation? https://pastebin.com/uUc34wx5 , I do get that a Reader-Monad has an enviroment, which I can get with ask, but I don't understand at all how I can use the reader monad for the func bexp2store
04:14:59 <merijn> When you hit the point in Haskell where you wanna use dependent types, you're probably better of using Idris
04:15:16 <merijn> Because dependent types in actually dependent languages are so much cleaner, nicer, and easier to use
04:15:26 <EvanR> idris is cool
04:15:34 <merijn> EvanR: Not lazy, though :\
04:15:41 <amca> But hardly anybody else uses Idris, where at least Haskell has a large user base, and masses of libraries
04:16:04 <EvanR> idris is missing a lot of things that would otherwise make it practical for real world use
04:16:13 <merijn> amca: Sure, but that's because Idris is the first dependent language designed for practical programming
04:16:13 <amca> Idris not lazy?  Does it have infinite lists?  I love those...
04:16:21 <EvanR> laziness by default is not one of them i dont think
04:16:47 <EvanR> it does have laziness as a feature though, its just not the default
04:16:52 <merijn> amca: But anyway, Idris is explicitly designed for "haskell programmers transitioning to dependent types"
04:17:06 <amca> What I need to do is to re-think my programs so that they don't require dependent types.
04:17:11 <EvanR> amca: in idris the infinite list is called Stream
04:17:17 <merijn> amca: So the entire Idris community and documentation is designed to specifically be accessible for Haskell programmers
04:17:19 <EvanR> and is a different data type
04:17:35 <amca> I might check it out... sounds interesting.
04:18:02 <merijn> amca: There's a nice youtube cost by Edwin on implementing type-safe printf
04:18:24 <merijn> oh, wait, not Edwin, but Brian McKenna
04:18:39 <EvanR> printf is the gift that keeps on giving
04:18:42 <merijn> amca: https://www.youtube.com/watch?v=fVBck2Zngjo
04:18:44 <EvanR> every language has something to say about it
04:19:29 <amca> Look, thank you so much for your helpful discussion!  I really appreciate your time and your generosity.
04:19:41 <amca> I mean, thank you everybody.
04:21:41 <amca> It's getting late here (southern Australia), and I'm thinking of a bit of shut-eye...
04:30:27 <amca> Thank you all again.  Bye for now.
04:31:27 <Math22232> how can I do the func bexp2store with the use of the reader- monad + do-notation? https://pastebin.com/uUc34wx5 , I do get that a Reader-Monad has an enviroment, which I can get with ask, but I don't understand at all how I can use the reader monad for the func bexp2store
04:42:34 <merijn> Refactoring Haskell is so zen :)
04:46:02 <int-e> merijn: you have to beware of accidental bottoms
04:46:40 <merijn> int-e: I'm comparing to the C++ code I was refactoring earlier this week :p
04:49:19 <raquai> soo... I've got a Map inside an IORef, and then I've got a key "x" inside that map with value 1, now I'm trying to put in a that x + 1 as a new value for x, but it gives me the <<loop>> exception, I know why this exception is normally given but I thought that when it's not really a haskell variable but just a value within a map, this wouldn't happen...
04:49:28 <raquai> is there any way to fix this?
04:50:25 <raquai> and then I mean, is there any way to put in the new value as the old value modified?
04:51:28 <opqdonut> yes
04:51:33 <kosmikus> raquai: yes, "adjust"
04:52:00 <kosmikus> raquai: but anyway, I don't think your infinite loop comes from this. are you giving the new map the same name as the old one?
04:52:16 <raquai> ooh, so far I was just re-entering the values with insert and the same name
04:52:30 <kosmikus> raquai: yes, that works
04:53:11 <raquai> hmm... then there's probably another issue
04:53:31 <opqdonut> raquai: are you perhaps reusing a variable name? so accidentally using recursion?
04:53:37 <kosmikus> raquai: what does the line look like where you change the map?
04:54:21 <raquai> maptje <- readIORef m;writeIORef m ( Map.insert s (AInt ((expToInt m a) * (expToInt m b))) maptje
04:54:21 <Uniaika> merijn: I was reading some 2 months-old code yesterday and at some point I told the code "I don't understand you anymore…".
04:54:24 <Uniaika> ;_;
04:54:34 <raquai> and that's within a do block
04:55:26 <kosmikus> the use of m in expToInt is suspicious
04:55:29 <opqdonut> yeah
04:56:05 <kosmikus> what does expToInt do, and why does it need the IORef as an argument as well?
04:57:17 <raquai> well I have a data structure Exp, and that can be an AInt with an Int, a VarRef with a String (name of a "variable" within that map) and some basic operators like +, *...
04:57:32 <raquai> and expToInt converts such a Exp to an Int
04:58:01 <raquai> and in case it's a VarRef, it has to have the Map/IORef to get the int out
04:58:17 <kosmikus> raquai: but if AInt takes an Int (and not an IO Int), then how can that work?
04:58:26 <kosmikus> raquai: m is an IORef
04:58:37 <kosmikus> raquai: it cannot possibly be used by expToInt if that returns a plain Int
04:58:56 <raquai> expToInt returns an int
04:59:23 <kosmikus> raquai: right, but then it cannot use the IORef
04:59:24 <raquai> if the variable is inside the IOMap I use unsafePerformIO
04:59:27 <kosmikus> hah
04:59:28 <kosmikus> ok, sorry
04:59:43 <kosmikus> but then that's your problem
04:59:49 <merijn> @quote not.a.bug
04:59:49 <lambdabot> cdsmith says: Yeah, that's weird... but it's documented, so it's not a bug. :)
04:59:55 <merijn> eh, wrong
05:00:18 <raquai> the unsafePerformIO is the problem?
05:00:45 <kosmikus> unsafePerformIO is always a problem
05:00:51 <merijn> @quote Lemmih not.a.bug
05:00:51 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
05:01:13 <raquai> lol, yeah ok but I couldn't find a way around it :/
05:01:21 <merijn> raquai: Unless you are absolutely, positively, 100% sure what you're doing the problem is *always* unsafePerformIO
05:01:46 <kosmikus> merijn: why do you need an IORef in the first place?
05:01:49 <kosmikus> sorry
05:01:51 <kosmikus> raquai: ^^
05:01:59 <opqdonut> raquai: pass maptje instead of m to expToInt?
05:02:01 <int-e> And even if you're 100% sure it's healthy to doubt yourself.
05:02:45 <raquai> yeah.. I could probably try with just passing the map itself
05:03:03 <opqdonut> raquai: or alternatively, do something like: maptje <- readIORef m; x <- expToInt m a; y <- expToInt m b; writeIORef m (Map.insert s (AInt (x * y)) maptje)
05:03:04 <raquai> it's only when the value is being adjusted that I need the IORef right?
05:03:19 <opqdonut> if expToInt truly needs the IORef
05:03:36 <kosmikus> raquai: I don't know what you mean by the value being adjusted
05:03:37 <raquai> yeah I tried it by seperating it like that, it gave the same problem
05:03:49 <opqdonut> and in this second option, make expToInt return "IO Int" instead of "Int"
05:03:53 <kosmikus> raquai: I'm not yet convinced your program needs an IORef at all
05:04:27 <raquai> it probably doesn't kosmikus, but it's the first thing that actually worked for me :)
05:04:59 <int-e> raquai: if it's a short program it may be best to paste it so we can get an idea of what you're doing (lpaste.net is popular here)
05:05:04 <raquai> and it's a project that's due in 2 days, I'm already working on it for like a week, so I probably won't change it anymore :)
05:05:28 <kosmikus> raquai: sounds like you're writing an interpreter for some kind of language
05:05:29 <raquai> yeah, no it's not that short :p
05:05:35 <raquai> yup
05:05:44 <raquai> for a language I had to make myself
05:06:25 <kosmikus> raquai: usually, that doesn't require IO, even if the modelled language is imperative
05:06:28 <int-e> hmm, I seem to have missed a link anyway, sorry
05:06:51 <kosmikus> int-e: what link?
05:07:10 <raquai> yeah I probably could've done with just State or something alike
05:07:11 <int-e> I don't know where opqdonut's code came from
05:07:27 <kosmikus> raquai: right, if you know about State, then yes, State or Reader are probably enough
05:07:41 <kosmikus> raquai: even if you don't know about them, you can always encode state-passing just via function arguments
05:09:38 <raquai> yeah that probably would've been better, but I don't think I have the time to change that, I might try with just passing the Map instead of the IORef(Map)
05:09:57 <raquai> that'll probably work if the problem was unsafePerformIO
05:10:57 <kosmikus> raquai: fwiw, if this is some kind of university task, you can almost be certain you wouldn't get this marked as "pass" even if it did somehow work when using unsafePerformIO
05:11:10 <opqdonut> int-e: raquai pasted a line some lines up
05:13:13 <raquai> yeah kosmikus but if I pass just the Map, I wouldn't have to use unsafePerformIO anymore :)
05:13:14 <int-e> kosmikus: heh, how about a conditional pass, conditional on a proof of correctness of the program...
05:13:35 <kosmikus> raquai: right :)
05:14:06 <int-e> (unsafePerformIO invalidates equational reasoning... so good luck with such a proof.)
05:14:36 <merijn> int-e: You can prove it based on operational semantics of GHC
05:14:39 <kosmikus> int-e: no :) not even that. even with a proof of correctness it would be unnecessarily fragile and complex, so it would still fail on stylistic reasons.
05:14:44 <ski> Math22232 pasted "evaluation with environment", at <http://lpaste.net/2219018802216042496>
05:14:47 * ski annotated "evaluation with environment" with "environment (non)passing" at <http://lpaste.net/2219018802216042496#a361799>
05:15:04 <ski> Math22232 : how about that ^ ?
05:15:13 <kosmikus> int-e: I mean, I cannot speak for all professors/lecturers, but back when I taught Haskell at university, I would certainly never have allowed such a solution :)
05:16:46 <raquai> kosmikus: yeah they would've probably deducted quite a few points for leaving that in, it was my "last resort", I had been working for like 2 days on a problem that unsafePerformIO gave a "solution" to, so in the end I just gave in and used that
05:37:12 <raquai> kosmikus: thanks a lot! it worked, and my project is now completely unsafePerformIO-free :)
05:38:47 <kosmikus> raquai: great. that's an improvement. now if you can also make it completely IO-free, at least if IO isn't really needed, that'd be even better. :)
05:39:24 * ski . o O ( `ST' )
05:40:58 <raquai> kosmikus: I might give that a try if I've got time to spare and my project is backed up :) right now I still have some things I have to implement first
05:42:10 <ertes-w> 'git commit' is kind of a backup, especially when followed by 'git push' ;)
05:42:59 <raquai> ertes-w: well yeah, that's what I meant :)
05:52:48 <mrkgnao> is there any way to have the deriveShow* functions work their magic on a recursive datatype?
05:55:22 <lyxia> mrkgnao: doesn't it Just Work?
05:55:37 <mrkgnao> I have a GADT with 40 constructors and am really not looking forward to learning how to write liftShowsPrec implementations
05:55:46 <mrkgnao> lyxia: no
05:56:22 <hydraz> would StandaloneDeriving work?
05:56:58 <phadej> mrkgnao: http://hackage.haskell.org/package/deriving-compat
05:57:51 <phadej> mrkgnao: if you generate an instance, it should work
05:57:56 <dodj> Beginner here: I want something like `(||)` but that works on functions, something like `or :: (a -> Bool) -> (a -> Bool) -> a -> Bool`. Is there something like this in the stdlib? Can I make `||` work like this?
05:58:06 <lyxia> dodj: liftA2 (||)
05:58:13 <phadej> ... for recursive types too
05:58:21 <dodj> aaah brill: I'll google lift :)
05:58:32 <merijn> lyxia: Also mappend if you don't mind wrapping Bool into Any
05:59:17 <phadej> (\/): https://hackage.haskell.org/package/lattices-1.7/docs/Algebra-Lattice.html#v:-92--47-
05:59:33 <phadej> shameless self-plug of max's library
06:00:16 <phadej> (I'd really like people to use `lattices`, so I'd know how to make it better)
06:01:11 <mrkgnao> phadej: so the way I know it goes is `deriveShow1 ''Foo` and then instance `(Show1 f, Show a) => Show (Foo f a) where showsPrec = showsPrec1`
06:01:26 <mrkgnao> er, s/instance `/`instance /
06:01:52 <mrkgnao> but that complains about not being able to solve Show a1, for whatever reason
06:02:59 <phadej> so the error comes from deriveShow1 ''Foo ?
06:03:07 <phadej> ah, I see.
06:03:46 <phadej> mrkgnao: could you try following
06:04:31 <mrkgnao> it could also have something to do with my funky version of Scope (I'm playing with "strongly-typed Bound")
06:04:52 <ski> (hmm, which parameters of `Foo f a' are indices ?)
06:05:08 <mrkgnao> just `a`, I think
06:05:09 <zik> hi. lift is the name of operation when going from e.g. ma -> t m a, but is there any "generic" name for the operation that goes into other direction, t m a -> m a?
06:05:11 <lyxia> mrkgnao: could you paste your datatype
06:05:19 <mrkgnao> yeah, one moment
06:05:27 <ski> then probably having `Show a' there doesn't help at all
06:05:27 <phadej> mrkgnao: there should be recursion check in deriveShow1
06:05:45 <lyxia> zik: nope
06:06:06 <phadej> mrkgnao: please open a ticket on https://github.com/haskell-compat/deriving-compat, with minimal example
06:06:34 <phadej> mrkgnao: I think it's easy to fix, Ryan just need be aware of it
06:07:06 <phadej> mrkgnao: You can make a workaround today using recursion-schemes, but it's not really worth it
06:07:08 <zik> lyxia, yeah, i was suspecting that as libraries are full of runXXX etc. functions. thanks
06:07:08 <lyxia> zik: there is usually something called runMyTransformerT but they all have quite distinct types so it doesn't make sense to put them in a typeclass
06:07:14 <ski> is your GADT existential ?
06:07:40 <ski> zik : would this be for a comonad transformer or something ?
06:07:49 <phadej> actually, https://github.com/haskell-compat/deriving-compat/issues/5
06:07:50 <phadej> hmm
06:08:43 <zik> ski, yeah
06:09:21 <mrkgnao> ski: no, it's just a HOAS-like thing, the constructors look like Foo :: Syn f (Coercion a) -> Syn f (Term a)
06:10:50 <mrkgnao> http://lpaste.net/361801
06:11:18 <ski> mrkgnao : i wonder, if the type `Syn f a' is completely known, will all the parts of a value of this type also have completely known types ?
06:11:37 <mrkgnao> lyxia: there's the lpaste ^^
06:11:50 <mrkgnao> ski: I don't understand (completely)
06:15:16 <mrkgnao> phadej: ski: an easier example is Scope from that paste. I can't get deriveShow1 ''Scope to work either
06:19:50 <ski> mrkgnao : fwiw, you could declare like `TmStar :: Term f a',`TmConv :: Term f a -> Coer f a -> Term f a',&c.
06:20:06 <mrkgnao> as separate datatypes?
06:20:14 <ski> no, inside the same `Syn' declaration
06:20:20 <mrkgnao> or using the type synonyms?
06:20:23 <ski> yes
06:20:35 <mrkgnao> oh, you can use type synonyms in constructor "output" positions
06:20:37 <mrkgnao> neat
06:20:42 <ski> (that doesn't help with your problem, but it may be nice to know about)
06:20:54 <mrkgnao> yes, thank you! :)
06:24:13 <ongy> merijn: ah, ifCxt doesn't work with MultiParamTypeclasses :(
06:24:33 <merijn> Sad times :(
06:25:16 <mrkgnao> so, for now, I am stuck with :force as a Show replacement :(
06:25:36 * mrkgnao just wanted to join the sadparty
06:26:06 <ongy> "party"
06:28:15 <mrkgnao> nevertheless, just thinking about writing an interpreter for DC makes me happy
06:29:03 <Gurkenglas> How would you use http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Data.html#v:gfoldl to implement "Data a => a -> String"?
06:29:25 <JuanDaugherty> join #haskell-blah,#haskell-offtopic,#python-offtopic
06:29:32 <JuanDaugherty> ouch
06:31:51 <lyxia> mrkgnao: I agree with phadej that this is worth opening a ticket on deriving-compat
06:32:24 <mrkgnao> lyxia: should I just post the Scope problem? that seems minimal
06:32:26 <lyxia> mrkgnao: if it's for debugging have you tried just standalone deriving of Show?
06:33:09 <ski> mrkgnao : hmm .. trying to figure out how you want to use `Scope' with `Syn' (and `Co',`Tm')
06:33:29 <mrkgnao> lyxia: doesn't seem to work, but I could be giving it the wrong constraints
06:33:49 <mrkgnao> ski: do you know this? http://lpaste.net/79582
06:34:30 <mrkgnao> I'll take any Show instance I can get!
06:34:35 <lyxia> mrkgnao: Scope is a different story
06:34:49 <ski> mrkgnao : not really
06:35:00 <mrkgnao> although I think this may be the push I need to bite the bullet and write a proper pretty-printer
06:35:34 <ski> something along the lines of `Scope Tm b Syn f (Co a)', i think ?
06:35:36 <mrkgnao> ski: notice how Kmett uses the index to track the types in `Remote`? that's essentially what I'm doing with `Tm` and `Co`
06:36:25 <lyxia> mrkgnao: For Scope it's probably best to specify the instance constraints explicitly
06:36:48 <mrkgnao> yeah, I think I agree that that's really a different problem
06:37:12 <ski> not seeing what you mean with `Remote'
06:40:28 <ski> (i think this seems a bit similar to a GADT "trick" i've used some times, but i'm not sure)
06:42:06 <mrkgnao> ski: Remote f (b -> a) "contains" a function, for instance
06:44:22 <ski> yes, it types the result of evaluating a `Remote' thing
06:44:29 <ski> i'm currently wondering what the point of `Tm a', `Ct a' and `Co a' is .. e.g. what is the `a' here ?
06:45:02 <ski> it seems that the second argument of `Syn' is always of this form .. except for `SynVar'
06:45:27 <ski> but perhaps `f a' in the signature of that will force that `a' to be of that form, still ?
06:45:43 <mrkgnao> yeah, ultimately the data contained inside the whole thing is of type `a`
06:46:05 <ski> so, what is the meaning of the types `Tm a',`Ct a',`Co a' ?
06:46:32 <ski> is there a need for `Tm',`Ct',`Co' to be type (and data) constructors at all ?
06:46:53 <ski> (i see you already have `DataKinds' enabled)
06:47:01 <mrkgnao> they encode the kind of thing; originally there were separate types Tm, Ct, and Co
06:47:13 <mrkgnao> but Bound doesn't work with mutually recursive datatypes
06:47:57 <ski> could `Tm',`Ct',`Co' be datakind constructors of some new datakind (as opposed they currently being kinded as `* -> *') ?
06:48:05 <mrkgnao> so Kmett suggested I use "strongly typed Bound" and move everything into one type, using the index to track the kind of thing (term, constraint, or coercion)
06:48:20 <ski> yea, that sounds similar to the trick i've been using
06:48:39 <ski> i dunno whether that trick is compatible with `Bound', but i suppose you could try
06:48:45 <mrkgnao> it isn't
06:48:56 <mrkgnao> https://github.com/ekmett/bound/issues/69
06:49:01 <ski> you already know what trick i had in mind ? :)
06:49:23 <mrkgnao> also see this: https://www.reddit.com/r/haskell/comments/7r0jkt/using_bound_with_mutually_recursive_expression/
06:49:34 <mrkgnao> ha, I don't suppose I do, but I made a guess
06:51:11 <ski> i don't think the trick i was thinking of is mentioned/used on either of the pages you pointed to
06:52:03 <ski> anyway, i'm still trying to to grasp all the moving parts of your `Syn' and `Scope'
06:52:20 <mrkgnao> ski: I'd be interested in a paste, at least
06:52:40 <ski> if we ignore the `Tm',`Ct',`Co' aspects for the moment, are you still interested in keeping the `a' part, of e.g. `Syn f (Tm a)' ?
06:53:04 <ski> does it play a similar role to `a' in `Remote f a' ?
06:53:15 <mrkgnao> yes
06:53:20 <ski> ok, good
06:53:46 <mrkgnao> Tm etc are of kind * -> * because I wanted to accomplish both that and "sort"-tracking at the same time with the GADT idnex
06:53:49 <mrkgnao> index*
06:54:19 <ski> btw, what does `Ct' stand for ?
06:54:24 <mrkgnao> "constraint"
06:54:28 <ski> ok, fine
06:55:12 <ski> so, what i'm suggesting then is something along these lines (i'm ignoring the `f' component of `Syn f a' now, please insert as appropriate) :
06:55:31 <mrkgnao> (is this your trick?)
06:55:52 <ski> no
06:55:55 <ski>   data Cat = Tm | Co | Ct
06:56:38 <ski>   data Syn :: Cat -> * -> *
06:56:40 <ski>     where
06:57:03 <ski>     TmStar :: Syn 'Tm a
06:57:29 <ski>     TmConv :: Syn 'Tm a -> Syn 'Co a -> Syn 'Tm a
06:57:32 <ski>     ...
06:57:34 <mrkgnao> I had that before
06:57:51 <ski> ok. and this is incompatible with `Bound' ?
06:59:01 <mrkgnao> hm, what would a Monad instance for that look like?
06:59:11 <mrkgnao> instance Monad (Syn 'Co) etc?
06:59:44 <ski> i suppose ?
06:59:45 <mrkgnao> I don't think you could write a Monad instance for that.
06:59:56 <mrkgnao> for example, taking the case of TmConv,
07:00:31 <mrkgnao> TmConv tm co >>= (f :: a -> Syn 'Co a) = TmConv ??? (co >>= f)
07:00:53 <ski> (i don't see a `Monad' instance in your paste, though there is a `HMonad' instance)
07:01:09 <mrkgnao> you need a Monad instance to use Bound with your type
07:01:21 <mrkgnao> this isn't Bound, this is a sort of "higher-order Bound"
07:01:41 <mrkgnao> notice the lack of a Bound import, and the fact that my Scope is differently-kinded from the one in Bound.Scope
07:01:45 <hyperisco> conal_, johnw the concat paper says fixed points are future work. What is the status of that work? I was thinking of different methods for observable recursion and concat came to mind.
07:01:54 <ski> i noticed the latter
07:01:59 <ski> ok
07:02:13 <mrkgnao> I wouldn't define Scope and Var for no reason! :)
07:03:31 <ski> anyway, i didn't mean that you should scrap the `f' argument to `Syn'. i just omitted it above, since i wasn't sure whether it should also be passed a `Cat' argument or not
07:04:07 <ski> (also, the proper argument ordering of `Syn' (if any) isn't quite clear to me, either)
07:05:33 <juanpaucar> Does somebody know if it's possible to have something like this?:
07:05:33 <juanpaucar> type Something =  Num c => (String, c)
07:05:36 <ski> looking at
07:05:39 <ski>   SynVar  :: f a -> Syn f a
07:05:55 <ski> i suspect it would have to be changed into
07:06:06 <metahumor_aw> juanpaucar: not easily. you can't have a constraint in a type synonym afaik
07:06:09 <ski>   SynVar :: f cat a -> Syn f cat a
07:06:14 <mrkgnao> tl;dr: `f` is the usual Bound `a` argument
07:06:32 <ski> juanpaucar : how would you like `c' to be bound ?
07:06:33 <mrkgnao> metahumor: yes, you can. (as an example, literally all of Lens is based on those)
07:06:47 <mrkgnao> that came out wrong, sorry
07:06:53 <mnoonan> juanpaucar: you just need RankNTypes, I think
07:07:09 <juanpaucar> let me check
07:07:09 <mnoonan> (and put c on the LHS, unless you're trying to do something trickier)
07:07:24 * ski is suspecting adding the obvious `forall' won't do what juanpaucar wanted to do
07:07:48 <ski> (nor parameterizing `Something' on `c')
07:08:09 <ski> juanpaucar : do you have an example (e.g. type signature), where you'd like to use `Something' ?
07:08:21 <metahumor> i have an inkling about what juanpaucar wants to do (i had similar motivations when i first started with Haskell) and while yes, Lens has constraints in the type synonym, they are universally quantified
07:08:40 <metahumor> juanpaucar: can you give us a broader description of what you're trying to achieve?
07:09:19 <juanpaucar> I wanted to avoid creating something like a data record that could be bounded using DataTypeContexts
07:09:23 <ski> metahumor : i think several of us can guess, yes :) but i don't think (in this case) that guessing will really help much more, without seeing some more example uses or explanation of uses, anyway
07:09:35 <metahumor> ski: agreed.
07:09:38 <juanpaucar> but (String, Int) was not general enough
07:09:54 <juanpaucar> for the right side
07:10:45 <metahumor> juanpaucar: how do you plan on using (String, Num c)? or what about (String, Int) was not general enough?
07:10:51 <dzdcnfzd> Is there a ($) analogue for type application?
07:11:49 <ski> juanpaucar : by `DataTypeContexts', you're referring to stuff like `data Ord a => Tree a = Tip | Node (Tree a) a (Tree a)' ?
07:12:22 <dzdcnfzd> e.g. type Foo a = "foo" :> a; type Bar = Foo $ Baz "baz"
07:12:50 <ski> what's wrong with `type Bar = Foo (Baz "baz")' ?
07:13:13 <dzdcnfzd> ski: nothing, it's just contra normal style
07:13:20 * ski disagrees
07:13:22 <dzdcnfzd> normally, Foo (Baz "baz"
07:13:23 <dzdcnfzd> )
07:13:45 <dzdcnfzd> *Normally, Foo (Baz "baz") is written Foo $ Baz "baz"
07:13:46 <juanpaucar> This is the example https://pastebin.com/veNE84sY
07:13:47 <ski> i almost never do that
07:14:12 <dzdcnfzd> ski: really? I see $ for right-associativity all the time...
07:14:15 <mnoonan> the more I use haskell, the less I like $
07:14:18 * ski wishes introductions would stop using `$' as much ..
07:14:25 <juanpaucar> GHC says that it doesn't support impredicatie polymorphism
07:14:47 <mrkgnao> juanpaucar: that means you're trying to put foralls inside a type constructor
07:14:54 <mrkgnao> like Maybe (forall a. a)
07:15:28 <ski> basically, i use `$' as a right section, and directly before `do',`if',`case',`let',`\'
07:15:55 <ski> also, i *seldomly* use it, when i would otherwise have a bracketed expression spanning many lines
07:16:06 <dzdcnfzd> ski: okay, but is there a way to do it?
07:16:07 <ski> otherwise, i prefer using plain brackets
07:16:08 <dzdcnfzd> with types?
07:16:36 <ski> i think you could probably define an infix type synonym ?
07:17:16 <mrkgnao> dzdcnfzd: I think you can define type ($$) f a = f a with the corresponding fixity declaration
07:17:18 <dzdcnfzd> ski: okay, but there isn't one floating around
07:17:26 <metahumor> juanpaucar: the type of y is weird
07:17:35 <mnoonan> ski: re $ do, did you see this proposal was accepted? https://github.com/takano-akio/ghc-proposals/blob/argumentdo/proposals/0000-block-arguments.rst
07:17:42 <ski> not that i'm aware of (but i wouldn't be surprised if it's in some relatively commonly used library)
07:17:49 <dzdcnfzd> mrkgnao, ski: kk, thanks!
07:18:07 <mrkgnao> mnoonan: I'm really excited for it
07:18:23 <mrkgnao> PureScript has it and it is good
07:18:30 <mnoonan> me too! I'm going to go on a $-deleting spree
07:18:31 <metahumor> juanpaucar: okay, expand the type synonym, you then get that "y :: [forall a . (Show a) => (String, a)]", which should be isomorphic to "y :: [(String, forall a . (Show a) => a)]"
07:18:33 <castilma> hey, can someone point me to some information about the variable 'it' in ghci? it seems to be set to the value of the last evaluation.
07:18:42 <ski> mnoonan : i didn't, though i've been wishing for something along these lines for a long time. ty !
07:18:44 <metahumor> someone please correct me if i'm wrong on that isomorphism
07:18:50 <metahumor> castilma: yes, it is a magic variable in ghci
07:19:29 <metahumor> juanpaucar: ghc doesn't know how to make a "weirdlist :: [forall a . (Show a) => a]", that's the polymorphism error
07:20:28 <ski> juanpaucar : from your example, it's obvious that you intended (as i and metahumor suspected) `type ParamTuple = exists a. Show a *> (String,a)'
07:20:58 <metahumor> now, your defn for "x :: (Show a) => [(String, a)] -> String" works fine, because GHC will know how to deal with [(String, Int)], [(String, Bool)], etc
07:21:12 <castilma> metahumor: that took me some time to debug. do you think it would be possible to emit a warning in ghci, when someone assigns something to it?
07:21:47 <metahumor> castilma: you'd have to hook into ghci directly. you have end-users using your app/lib directly through ghci?
07:21:55 <juanpaucar> ski: what is *> I thought that was something from applicative
07:22:42 <ski> dzdcnfzd : anyway, instead of `foo x $ bar y z $ baz t', i'd prefer `(foo x . bar y z . baz) t', or at the very least `foo x . bar y z . baz $ t'
07:22:42 <juanpaucar> And what extension should be used, also "exists" it's not clear to me
07:22:48 <metahumor> castilma: ghci is kinda _wrong_ on some ways it interprets Haskell, some would consider it to be a faulty implementation of the language spec. it does things that ghc wouldn't in compilation, like monomorphism related stuff etc. but that's not super relevant to your question
07:23:00 <mnoonan> juanpaucar: in the specific case of Show, there is only one typeclass method. so there is only one thing you can even do with a "Show t => t"
07:23:16 <ski> juanpaucar : this is pseudo-Haskell, to explain conceptually *what* you want. *how* to actually get it in GHC is a slightly more involved matter
07:23:17 <mnoonan> so why not just do it, and get a (lazy) [(String,String)]?
07:23:40 <lyxia> mrkgnao: another obstacle to a Show instance is that Show (Tm a1) doesn't imply Show (Co a1) (that is required by TmConv for example)
07:23:52 <ski> juanpaucar : however, as mnoonan is explaining, you probably don't really need existentials here anyway, so why complicate the code for no good reason ?
07:23:53 <juanpaucar> mnooman: no issue there
07:24:11 <ski> juanpaucar : .. unless your real code is more complicated, and perhaps actually could benefit from existentials
07:24:16 <metahumor> juanpaucar: there's some logic/math involved why "x :: (Show a) => [(String, a)] -> String" is OK and "y :: [forall a . (Show a) => (String, a)]" isn't
07:24:42 <juanpaucar> ski: I'm intrigued about what "type ParamTuple = exists a. Show a *> (String,a)" does, where can i find more about that. Also, which extension should be used
07:24:58 <metahumor> juanpaucar: that's just conceptual syntax in this particular case
07:25:20 <ski> (mnoonan : well, there are actually more than one typeclass method .. but it looked like juanpaucar only cared for `show' anyway, so it's as if that was the sole method)
07:25:47 <mnoonan> ski: I always forget about showsPrec :|
07:26:07 <ski> and `showList' !
07:26:20 <ski> (also `shows' is not `show')
07:27:16 <ski> juanpaucar : well .. to explain it, it may be well-adviced to first explain `forall' (and `=>') better
07:28:11 <mrkgnao> lyxia: hmm, I'm going to try using the output of ddump-deriv and fix it myself
07:28:17 * mrkgnao gulps loudly
07:28:26 <ski> juanpaucar : if you have some time to kill, i could try to explain
07:28:55 <juanpaucar> ski: I do, I would like to understand that
07:29:16 * ski ponders whether to do it here, or in #haskell-overflow
07:30:36 <juanpaucar> ski: i guess overflow
07:32:59 <ski> (i've explained it in here several times in the past. but perhaps the channel atm seems to be more active with other people asking for help, which might get drowned a bit in the explanation then. and maybe some (currently active) people are already familiar with it, and would prefer it elsewhere. otoh, sometimes people notice something interesting in the scrollback after the fact, and haven't joined that other channel ..)
07:33:26 <ski> i suppose we'll take -overflow this time, since you're there now
07:45:48 <Matteo_> hi
07:46:46 <Matteo_> can some one help me with haskell ?
07:47:33 <metahumor> Matteo_: what are you having issues with? just ask!
07:48:46 <Matteo_> I have simulator in haskell using gloss but i can't use the functions i have written to change the simulator, like moving the robot around etc.
07:50:43 <Matteo_> some people say that i have to use multithreading and mvar for communication with the simulator but i have no succes with that
07:53:08 <Matteo_> am I in the right channel for asking questions ?
07:53:14 <metahumor> yeah, you are
07:53:44 <metahumor> i'm not familiar with gloss. google is showing me that it is a vector graphics library. is this correct?
07:54:13 <Matteo_> yes, its used for simple games
07:55:09 <metahumor> okay, i'm taking a look. are you using Graphics.Gloss.Interface.Pure.Simulate.simulate?
07:55:55 <Matteo_> yes I use that one
07:56:40 <Matteo_> and the robot is driving around and detecting collision, but i can't type any more commands in terminal so i cant call my other functions :s
07:58:17 <metahumor> can you give an example of "commands" you _were_ able to run?
07:58:57 <Matteo_> i can only start the program then it runs the main that starts the simulator
07:59:13 <Matteo_> but i cant run any other commands because the terminal doesnt let me
07:59:34 <conal> hyperisco: for handling recursion in compiling-to-categories, i think the theory is fairly clear & simple, but needs some careful engineering. i knew how to when i was targeting only a single category (graphs/circuits) and compiling whole modules as well as targeted functions. lately, i've been focused on scaling up automatic differentiation and incorporating reverse mode in a simple & general way.
07:59:49 <metahumor> Matteo_: when you say terminal, are you using some sort of repl or cli?
07:59:58 <conal> hyperisco: and yes, CtC gives a completely different perspective on observable sharing (including recursion), making it easy without any dodgy semantics.
08:00:27 <Matteo_> iam using atom to write the code then i use bash and ghci to run it
08:01:28 <MarcelineVQ> conal: it's exciting stuff, even to laypeoples like myself that only think of categories as circles with arrows
08:01:46 <hyperisco> conal, okay thanks!
08:01:52 <MarcelineVQ> iow as pretty pictures :>
08:02:11 <mrkgnao> lyxia: I solved my problem!
08:02:31 <metahumor> Matteo_: the "simulate" function takes several arguments, one of which is of type "(ViewPort -> Float -> model -> model)". do you have such a transformation function?
08:02:52 <conal> MarcelineVQ: :) . i'm amazed at how powerful and useful category theory is being to my current practical work.
08:03:09 <mrkgnao> I grabbed the output of -ddump-simpl from doing deriveShow1 ''Syn, separated it into Tm and Co cases in different functions, and regexed everything into working :(
08:03:18 <Matteo_> metahumor: yes I use that function to update the status of the robot the speed etc.
08:03:58 <conal> hyperisco: you're welcome! i'm eager to demonstrate recursion, since it makes a clearer case for benefits of the CtC approach over deep or shallow embeddings.
08:05:10 <lyxia> mrkgnao: hahaha
08:05:34 <mrkgnao> I actually did this with 90% of the constructors commented out, so time to do it with the full type
08:05:40 <mrkgnao> woe is me
08:05:57 <metahumor> Matteo_: so what do you mean by "run any other commands"? all the commands you want should be incorporated into that particular function, if i understand correctly
08:06:49 <hyperisco> conal, let me encourage you further then :) looking forward to it. I will get to reading the cited papers with respect to categorical descriptions of fixed points.
08:08:28 <Matteo_> metahumor: The simulator is running fine but i want to be able to change for example the speed of the robot while the simulator is running
08:10:09 <metahumor> Matteo_: my understanding of the library is that all of that has to be done within the body of that "step" function
08:10:35 <metahumor> so if you wanted to change the speed, you'd have to change how your "step :: ViewPort -> Float -> model -> model" uses the Float argument
08:12:29 <mnoonan> conal: do you end up needing to make a finer distinction about least/greatest fixpoints than Haskell usually does?
08:13:25 <Matteo_> metahumor: how do i call that function from another program, i need concurrency for that and mvar no ?
08:13:39 <conal> mnoonan: i don't know. haven't yet, but we'll see.
08:18:09 <Matteo_> could anyone help me with running 2 programs in 2 threads and having communication between them ?
08:20:56 <metahumor> Matteo_: sorry, I didn't understand completely before. are you also using playIO?
08:23:18 <Matteo_> metahumor: no iam using simulate, but i could use playIO instead of simulate if that way i can communicate with the simulator
08:26:58 <metahumor> Matteo_: yeah, I'd suggest taking a look at playIO
08:27:11 <metahumor> Matteo_: this might be very helpful: https://ocharles.org.uk/blog/posts/2013-12-10-24-days-of-hackage-gloss.html
08:27:26 <metahumor> Matteo_: they even use MVars in this example
08:28:49 <Matteo_> metahumor: ill try it thx, ill keep u update :)
09:29:10 <tabaqui> Sorry, I've already asked this, but didn't remember the answer
09:29:21 <tabaqui> why ListT from mtl is worse than from transformers?
09:29:53 <Matteo_> metahumor: I look at the code, but it dont think my problem is what he is doing,
09:30:23 <glguy> tabaqui: It's not, they're the same thing
09:30:34 <Welkin> ListT sounds like an odd transformer
09:30:34 <Welkin> o.o
09:30:39 <Welkin> what would you use it for?
09:30:47 <Matteo_> metahumor: do you think i could fork the simulator in a new thread and my other code in the original thread ?
09:30:56 <Welkin> and how would it even work?
09:31:23 <glguy> Welkin: In general it doesn't
09:31:34 <tabaqui> Welkin:
09:31:36 <tabaqui> name <- ListT $ return names
09:31:36 <electrocat> Welkin: non-deterministic computation
09:31:37 <tabaqui>     void $  ListT $ liftIO (guard <$> doesDirectoryExist (repo </> name))
09:31:39 <tabaqui>     void $  ListT $ liftIO (guard <$> doesFileExist (repo </> name </> sample))
09:31:59 <tabaqui> for dealing with filesystem, for example
09:32:57 <tabaqui> glguy: ok, thx
09:33:25 <Welkin> what's wrong with Maybe or Either?
09:33:26 <phadej> Welkin: the one in transformers is m [a], the one with list-t is `newtype ListT m a = ListT (m (Maybe (a, ListT m a)))`, adn then there's https://hackage.haskell.org/package/logict-0.6.0.2/docs/Control-Monad-Logic.html#t:LogicT
09:33:35 <glguy> You can't mix ListT and IO
09:33:43 <glguy> (and still get a Monad out the other end)
09:34:29 <glguy> (at least not the one from mtl/transfomers)
09:34:35 <tabaqui> glguy: it is said that monads must be commutative
09:35:01 <tabaqui> if I understand that means memory leaks in big computations
09:35:15 <tabaqui> but I have a really small tree
09:35:17 <phadej> no, that means ordering of effects
09:35:19 <glguy> it means incorrect results
09:35:31 <Arguggi> barrucadu, thanks for the release, I'll bother you one last time since I'm not sure if I'm missing something. I want to put some MVars in my Env for the ReaderT, but then I can't create the Env in IO right? See http://lpaste.net/3740824924638412800
09:36:02 <phadej> "reading filesystem" is often considered "commutative", writing to log file isn't
09:36:09 <Welkin> phadej: I cannot help but read your name as "jade"
09:36:24 <phadej> Welkin: i'm fine with that, np
09:36:42 <phadej> IRL i prefer Oleg :)
09:36:45 <Welkin> it's like pig latin
09:36:48 <Welkin> what!
09:36:53 <tabaqui> ah, of course
09:36:59 <phadej> (not kiselyov)
09:37:02 <tabaqui> it doesn't matter
09:37:05 <Welkin> you are oleg kiselyov?
09:37:09 <Welkin> hahaha
09:37:21 <Welkin> I suppose Oleg is a very common name
09:37:25 <tabaqui> олег киселёв,
09:37:27 <tabaqui> ?
09:37:28 <barrucadu> Arguggi: Yeah, that's a situation I don't have a good answer for yet
09:37:35 <tabaqui> who is this guy?
09:37:54 <phadej> Welkin:  I guess it's in top20 in russian speaking world
09:38:04 <Welkin> tabaqui: a legend in haskell
09:38:43 <Arguggi> I guess I could run runReaderT with undefined in IO, create an env, and then use local?
09:39:23 <tabaqui> Welkin: his site is still alive
09:39:49 <tabaqui> comments on govnokod are funny
09:40:03 <Welkin> tabaqui: http://okmij.org/ftp/
09:40:25 <tabaqui> wait, Elkin is your second name?
09:40:57 <Welkin> what?
09:41:05 <tabaqui> W.Elkin
09:41:11 <Welkin> no
09:41:14 <tabaqui> ok :)
09:41:18 <Welkin> it's a nickname
09:45:42 <barrucadu> Arguggi: Another issue is that you can't really use an `MVar m a` inside a `Stack m`, even though they're actually the same type (because GHC can't know that in general).  But you can get around that with a slightly verbose alternative formulation: http://lpaste.net/1854950784064552960
09:46:10 <barrucadu> *even though `MVar m a` and `MVar (Stack m) a` are the same type
09:51:18 <Welkin> is there an updated guide for getting local hoogle set up?
09:51:53 <Welkin> and how does that relate to local hackage docs?
09:51:56 <Welkin> do you build them separately?
09:52:29 <ski> @quote olegs
09:52:30 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
09:52:38 <ski> @quote oleg
09:52:38 <lambdabot> oleg says: I submit that a type-checker that accepts ill-typed terms, loops and causes segmentation faults is not correct.
09:52:44 <ski> tabaqui ^
09:53:34 <tabaqui> @quote oleg
09:53:34 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
09:53:39 <tabaqui> lol
09:54:10 * tabaqui is going home
09:54:13 <Sornaensis> wow
09:54:16 <Sornaensis> that quote is me
09:54:31 <Arguggi> barrucadu, Ok using your suggestion and the local function my simple program seems to work, I have to try testing it now
09:54:47 <ski> @where oleg
09:54:47 <lambdabot> http://okmij.org/ftp/
09:55:05 <Welkin> holy crap!
09:55:20 <shapr> that's oleg
09:55:25 <shapr> he's amazing
09:55:29 <shapr> @quote oleg
09:55:29 <lambdabot> oleg says: I submit that a type-checker that accepts ill-typed terms, loops and causes segmentation faults is not correct.
09:55:29 <Welkin> I just discovered that there is a pdf version of the ghc user's guide byt browsing around the file index
09:55:34 <shapr> @quote .*oleg.*
09:55:34 <lambdabot> AndrewCoppin says: Oleg cat sez: "see, yr type problum not so hard".
09:55:37 <shapr> @quote .*oleg.*
09:55:37 <lambdabot> Pseudonym says: Olegs can be warded off by adding a note claiming that it's impossible to implement in the type system.
09:55:41 <shapr> @quote .*oleg.*
09:55:41 <lambdabot> Jafet says: Can oleg create a term so complicated that even he could not type-check it?
09:55:44 <shapr> @quote .*oleg.*
09:55:44 <lambdabot> vincenz says: we need a flag like "ghc --I-am-oleg"
09:55:44 <Welkin> https://downloads.haskell.org/~ghc/latest/docs/
09:55:48 <shapr> @quote .*oleg.*
09:55:48 <lambdabot> merijn says: If Oleg is the unit of type hackery I propose Edward as the unit of haskell productivity.
09:55:51 <shapr> haha
09:55:53 <Welkin> as well as a downloadable html version
09:55:53 <MarcelineVQ> you goofs :>
09:55:59 <ski> @quote O.leg.k
09:56:00 <lambdabot> ddarius says: shift k. O(leg k)
09:56:21 <MarcelineVQ> @quote shapr
09:56:21 <lambdabot> shapr says: what's the best Haskell cabbage?
09:56:21 <shapr> whoa, I tripped the anti spam measures, I promise I'm not spamming!
09:56:56 <edwardk> mrkgnao: technically i think i recommended you use unbound but that the strongly typed bound trick or the ermine trick were how i'd handled it in the past :)
09:57:08 <ski> shapr : that happens to me, semi-regularly
09:57:20 <shapr> lesson learned, don't repeat the same message a bunch of times in #haskell
09:57:31 <mrkgnao> edwardk: yeah
09:57:31 <ski> usually when i'm explaining something to someone
09:57:49 <mrkgnao> I guess I was just really excited about "hbound" :)
09:58:18 <ski> shapr : it can trigger even if the lines are not exactly the same (e.g. designed to compare and contrast different versions of lambdabot requests)
09:58:22 <Welkin> does anyone use a 100% offline workflow, or have some kind of 100% offline setup?
09:58:42 <Welkin> local docs, guides, books
09:59:04 * mrkgnao raises his hand
09:59:19 <codedmart> Anyone familiar with https://hackage.haskell.org/package/authenticate-oauth? I am getting an `Invalid Signature` response from the api I am trying to call and am not sure how to debug.
09:59:20 <Welkin> I'd like to get local hoogle setup and have all local haddocks
09:59:23 <mrkgnao> hoogle server --local, Nix setup with local haddocks
09:59:47 <mrkgnao> for me it's just a single switch in my per-project shell.nix: "wantHaddocks = true"
09:59:54 <ski> shapr : i've had to walk over to #freenode and appeal to the authorities perhaps three to five times already, concerning an automatic K-line of someone else, which was undeserved, imho
10:01:42 <Welkin> ski: did you use a different computer?
10:03:01 <ski> Welkin : those cases were different people (like e.g. Peaker) getting K-lined, not me
10:03:37 <ski> (but i've also experienced it myself, once. that time i did in fact use a different computer to connect and immediately join #freenode, and appeal)
10:04:30 <ski> it appears that now it isn't quite as trigger-happy, only warning, in case you have some substantive amount of time on the channel (not sure whether activity is counted)
10:08:46 <mrkgnao> how do you write a Show1 instance for a GADT with constructors with types like G (Maybe a) -> G a -> G (Maybe a)?
10:09:34 <mrkgnao> (I asked this before, and I have a horrible solution, which involves splitting up the constructors by what index they "output", and writing separate functions for each)
10:09:54 <mrkgnao> cemerick_: o/
10:10:16 <AWizzArd> Is there a way to derive Num behaviour for a newtype Point = (Int, Int), so that I can add Points?
10:11:01 <mrkgnao> AWizzArd: do you only want to add them?
10:11:26 <AWizzArd> mrkgnao: I am more interested in seeing what kind of behaviour can be derived.
10:11:43 <AWizzArd> Having simple addition for Points is just one example.
10:11:54 <AWizzArd> Without implementing Num I couldn’t implement (+) for Points.
10:11:59 <cemerick_> mrkgnao: \o
10:12:24 <ski> `newtype Point = (Int, Int)' is bad syntax
10:12:24 <cemerick_> what's the occasion?
10:13:08 <AWizzArd> ski: yes sorry, but you get the… Point :)
10:13:08 <mrkgnao> oh, came by looking for ways to convince GHC to give me more free stuff
10:13:32 <Welkin> I like using `data Point a = Point a a a`
10:13:42 <ski> AWizzArd : no, i'm not sure if a `newtype' (or equivalently, for this matter, a `data' type), or otherwise a `type' synonym was desired
10:14:04 * ski secretly inserts a `Mk'
10:14:07 <mrkgnao> what brings you here? the next logical step in Haskell stanning? :)
10:14:15 <AWizzArd> ski: Not too important if newtype or data, I am just wondering if Nums can be derived.
10:14:36 <cemerick_> mrkgnao: hah :-) I've been lurking for a while
10:14:44 <AWizzArd> cemerick_: Hi, nice to see you here!
10:15:01 <Welkin> AWizzArd: I read your name as AzzWizard
10:15:08 <ski> AWizzArd : i think only with `GeneralizedNewtypeDeriving', which doesn't apply here
10:15:17 <AWizzArd> Welkin: congratulations!
10:15:47 <mrkgnao> AWizzArd: base doesn't have the intuitive (Num a, Num b) => Num (a, b) instance (for good reason), which gets in the way
10:16:02 <ski> AWizzArd : because of what mrkgnao just said
10:16:14 <AWizzArd> Okay I see. So this will require an explicit implementation.
10:16:34 <mrkgnao> nevertheless, you can implement it very mechanically once you write an Applicative instance
10:16:37 <mrkgnao> https://gist.github.com/Icelandjack/5afdaa32f41adf3204ef9025d9da2a70#any-applicative-is-num
10:18:02 <amalloy> it's like a #clojure alumni party in here today
10:18:10 <Welkin> why is that?
10:18:26 <Welkin> was there a mass exodus from clojure?
10:18:36 <AWizzArd> amalloy: uh, you’re also here :)
10:18:50 <amalloy> no, just a number of people i saw in #clojure a long time ago who suddenly i am seeing in #haskell today
10:19:02 <AWizzArd> amalloy: just thought the same.
10:19:29 <mrkgnao> I lurked on #clojure once upon a time, for about a week, asking silly questions about what type this function or that had :)
10:19:31 <amalloy> but in a way, i suppose also yes. much of #clojure has moved to slack
10:19:41 <Welkin> ew, slack
10:19:58 <Welkin> it saddens me that the elm and purescript communities are dead on irc and moved to slack
10:20:04 * ski . o O ( slackers )
10:20:05 <Welkin> if that ever happens with #haskell, I am done
10:20:09 <Welkin> slack is terrible
10:20:19 <cemerick> AWizzArd: likewise
10:20:35 <isBEKaml> Well, uh, Clojure kinda goes to the community.
10:20:54 <isBEKaml> It lives wherever the community is
10:21:18 <ski> mrkgnao : nice (the Icelandjack post)
10:21:18 <Welkin> slack will die at some point
10:21:20 <Welkin> irc is forever
10:21:49 <mrkgnao> ski: his gists are excellent (he uses Gist as a blog/scratchpad of sorts)
10:22:08 <cemerick> amalloy: how've you been?
10:22:30 <Welkin> oh, haha
10:22:33 * ski . o O ( <https://xkcd.com/1782/> )
10:22:42 <Welkin> I met IcelandJack in person
10:22:49 <Welkin> haven't seen him on IRC in ages
10:22:51 <ski> mrkgnao : i've spoken to him before in here, yes
10:23:05 <ski> Welkin : oh, point
10:23:13 <amalloy> cemerick: good. moved back to the bay area, took a job at google. had more fun with haskell then clojure, but i still hang out in #clojure to advise. i thought you'd fallen off a cliff or something. how've you been?
10:23:36 <Welkin> amalloy: why google?
10:23:52 <Welkin> aren;t you forced to write java and work on projects that get killed off a year later?
10:24:24 <cemerick> amalloy: We had twin girls a few years back, so I was def gone for ~a year. Came back to tumbleweeds in #clojure. ¯\_(ツ)_/¯
10:24:40 <amalloy> well, this is not a totally inaccurate representation, Welkin
10:25:00 <amalloy> though s/java/go/
10:25:27 <amalloy> it turns out that for side projects though, there is some really great integration for haskell, and i wrote a toy project in it recently
10:26:00 <AWizzArd> amalloy: can you use Haskell at Google?
10:26:41 <amalloy> like i said, for small projects. there are some evangelists who worked hard on some great tooling for it
10:27:26 <amalloy> but anyway i try to consider myself "a developer" rather than "a haskell developer" or "a clojure developer". learning to drink the kool-aid of new languages, even if it's distasteful, is good for me
10:27:51 <amalloy> and google has built a lot of stuff that makes a difference in my actual life, so i was happy to get a chance to work on it
10:28:21 <ski> amalloy : at the least, there may be ideas to cannibalize back
10:29:13 <amalloy> ski: i'm excited to bring "if err {return nil, err}"-oriented programming to haskell
10:29:40 <ski> `return nil, err' ? returning two values ?
10:29:47 <yushyin> amalloy: :(
10:29:53 <metahumor> AWizzArd: Take a look at Linear.V2
10:29:59 <amalloy> ski: it's just a tuple
10:30:20 <amalloy> because they don't have Either
10:30:23 <amalloy> or Maybe
10:30:50 <amalloy> so they have to return a possibly-neutral value, and a possibly-neutral error, and it's up to you to treat exactly one of them as meaningful
10:30:59 <ski> @quote code.in.any.language
10:30:59 <lambdabot> Unknown says: Real programmers can write assembly code in any language.  :-)
10:31:42 <ski> amalloy : so that's in place of `Maybe' ?
10:31:49 <amalloy> more in place of Either really
10:32:10 <ski> how do you know which of them is meaningful ?
10:32:43 <mrkgnao> Rust does that pervasively (all "IO actions" return Either) and it is Good, modulo some bits about it not being lazy so exceptions are different or something
10:32:56 <AWizzArd> metahumor: yeah, they did it via Applicative I see.
10:33:03 <amalloy> ski: if the err value is "empty", then there was no error, and the first value is meaningful. otherwise, the err is non-empty and meaningful
10:33:11 <amalloy> it really is an abysmal idiom
10:33:41 <ski> hm, i remember trying to convince someone on a rust channel to add monadic reflection syntax to Rust
10:33:57 <Welkin> truthy and falsey are some of the stupidest ideas in programming, besides java oop, and null
10:34:00 <ski> (since it seemed they were already thinking about things along that vein)
10:35:12 <amalloy> they have static types and lambdas, but they don't have type parameters so you can't implement map
10:35:39 <ski> amalloy : ok. so the "error" value can't be `empty' then. domain contagion i suppose, but perhaps not that severe if you're always using `Either MyError', for a speficic fixed `MyError', rather than custom errors
10:36:09 <ski> "they" being Go ?
10:36:11 <amalloy> yeah
10:36:31 <ski> but they have overloading, i presume
10:36:45 <amalloy> uhhhhh
10:36:57 <amalloy> i have bad news for you
10:37:13 <metahumor> "lol no generics"
10:37:43 <AWizzArd> metahumor: as in „Java Generics”?
10:38:04 <ski> i remember hearing a lecture by one of the guys behind Turbo^WPDC^WVisual Prolog, which is statically typed. they apparently got tired after adding the fiftyeleventh overloading of reverse/2 and append/3 for new types, and finally got around to implementing parametric polymorphism (aka generics)
10:38:33 <metahumor> AWizzArd: it's a recurrent joke about Go
10:38:58 <Welkin> haha
10:39:03 <ania123> can one tell me webpage from where I can get freely scientific papers?
10:39:12 <Welkin> oh my god. Look at the screenshots in this paper https://downloads.haskell.org/~ghc/papers/composing-haggis.ps.gz
10:39:13 <AWizzArd> metahumor: okay I see. I was just referring to the fact that many things are called „Generic” and Haskell’s idea of it is more like datatype-generic programming than Java Generics.
10:39:39 <Welkin> is that from mac os 9? Windows 95?
10:39:41 <metahumor> yes! and Go has none of either of those, from my very surface level understanding
10:39:42 <ski> gio123 : perhaps <https://arxiv.org> ?
10:39:56 <metahumor> ania123: arxiv?
10:40:00 <cocreature> scihub
10:40:18 <ski> Welkin : don't they look lovely ?
10:40:33 * ski misses Fudgets
10:40:57 <Welkin> I guess it might be system 7 even
10:48:38 <Matteo_> can someone help me iam trying to run a game with closs in a separated thread ?
10:50:34 <cocreature> Matteo_: you’re going to need to be a bit more specific
10:50:59 <Matteo_> cocreature: what do you need to know more ?
10:51:24 <cocreature> Matteo_: do you just want to run it in a new thread? in that case just call "forkIO" and run it there
10:51:46 <cocreature> do you have some existing code that is causing problems?
10:53:28 <Welkin> has anyone gotten pandoc to have nice syntax highlighting?
10:53:31 <metahumor> Matteo_: sorry, I was away. you need to use playIO, check out the part in the blog I sent you about "handleInput"
10:53:39 <Matteo_> cocreature: I have an other program that can controll an IRL mbot robot with commands, and I have a simulator of the robot (render and draw with gloss) that has to communicate with the program so it also runs the commands, and i think that a way of doing that is with multi threading and mvar but iam stuck :s
10:53:45 <Welkin> I would love if I could make it look just like haskell-mode in emacs (with the appropriate color theme)
10:54:04 <Welkin> the default zenburn in pandoc looks like crap (not even close)
10:54:24 <Welkin> and it seems like the syntax engine in pandoc is not as detailed as haskell-mode
10:54:26 <cocreature> Matteo_: alright, in that case you’ll have to follow metahumor’s suggestion. you can then use one of the various communication mechanisms that Haskell provides such as mvars
10:54:59 <metahumor> Matteo_: also, look at forkAi in that blog -> in your case, instead of making a random move, you'll get one using some sort of "handleInput"
10:56:14 <metahumor> Matteo_: a sketch: "forkMove movevar board = void $ forkIO $ do {input <- getInput; let move = handleInput input board; putMVar move board}
10:56:51 <Matteo_> metahumor: but there are no inputs only another program that imports my module and then calls functions
10:57:17 <metahumor> where "getInput :: IO Event", "handleInput :: Event -> Board -> ..."
10:57:47 <metahumor> calls functions means what? reading from a file? getting input from a terminal? you mentioned earlier that it might be a terminal
10:58:54 <Matteo_> metahumor: openMBot, closeMBot, sendCommand, readUltraSonic, readLineFollower, setMotor, leftMotor, rightMotor, setRGB, Line(LEFTB, RIGHTB, BOTHB, BOTHW), Command(..), Device.
10:59:16 <Welkin> whoever wrote the pandoc implementation of the zenburn theme must have been color blind...
10:59:28 <Welkin> eveyrything is some shade of yellow!
11:00:08 <Matteo_> meta
11:00:32 <Matteo_> metahumor: The other program has to be able to use these functions on the simulator
11:00:45 <metahumor> those are functions that are being called, are they being parsed in from a file, or from an interactive prompt?
11:10:05 <metahumor> btw gloss seems very cool!
11:11:05 <Welkin> wow, pandoc 2 is out
11:11:25 <Welkin> time to fix this horrible disaster of a theme that someone dares call zenburn
11:12:20 <metahumor> http://kippura.org/zenburnpage/ 404
11:12:48 <sm> the colors you're seeing are probably not the colors others see
11:13:31 <Matteo_> metahumor: those functions that are being called have to change the state of the simulator (by changing the state)
11:13:45 <sm> (just curious, what's the display context ? terminal ? emacs ? web page ?)
11:14:19 <Welkin> sm: I want the same colors I see in emacs, which looks beautiful
11:14:36 <sm> you want to see them where ?
11:14:36 <Welkin> the colors are completely wrong in the skylighting css (everything is some awful shade of yellow)
11:14:45 <Welkin> I am compiling literate haskell to html
11:14:49 <shapr> ooh neat
11:14:50 <sm> in a pandoc-generated html.. ah
11:15:07 <metahumor> Matteo_: i understand about how the functions are supposed to change the state of the simulator. how would you like to deliver them to the running thread? parsing a file or interactive prompting or precompilation?
11:16:21 <Matteo_> metahumor: I would like to use them in precompilation
11:16:23 <Welkin> I've been using hand-written css so far for my hakyll site
11:17:47 <metahumor> Matteo_: so you have a file somewhere with these "instructions" written out, would you mind sharing how that looks? that'd help me figure out the cleanest way to restructure
11:17:51 <metahumor> @where lpaste
11:17:51 <lambdabot> http://lpaste.net/
11:20:08 <Matteo_> metahumor: I have another haskell code that calls those functions
11:20:14 <Matteo_> metahumor: Like this
11:20:24 <Matteo_> metahumor: main = do  d <- openMBot  sendCommand d $ setRGB 1 0 0 100  sendCommand d $ setRGB 2 100 0 0  closeMBot d
11:20:59 <Matteo_> metahumor: main = do  d <- openMBot
11:21:20 <Matteo_> metahumor: sendCommand d $ setRGB 1 0 0 100
11:21:22 <metahumor> and do you have a function that's something like "transformF :: (robotTransformF) -> (simulationTransformF)"?
11:21:37 <Matteo_> metahumor: no
11:21:43 <metahumor> basically, some way of interpreting those functions to change a simulation/picture state instead of a robot state?
11:23:44 <Matteo_> metahumor: i have no problem with make the functions work in the simulator, i have a problem with letting the other program use and run those functions
11:24:58 <metahumor> ah, you might have it already. instead of "sendCommand d $ cmd" where d is a robot, you could have "playIO ... $ cmd"
11:26:23 <metahumor> if you have a typesig of "sendCommand :: Robot -> Action -> IO ()" and "playIO :: some -> display -> args -> Action -> IO ()"
11:28:26 <metahumor> it'd be easier for me to understand if you shared a little example of how things like "sendCommand" and "setRGB" are defined
11:29:45 <Matteo_> metahumor: I dont yet have those functions implemented all i have is a simulator of a robot that has a left and right wheel speed and that can turn and collision with other stuff (the world is read form a file)
11:32:03 <metahumor> okay! i'd read the blog again. in the blog, the world is (Board, Play). in your case, you'll have to figure out how to implement drawing the world (equiv to the blog's drawBoard)
11:32:32 <Matteo_> metahumor: this is the code of the simulator I already have
11:32:35 <Matteo_> metahumor: https://codeshare.io/50x19N
11:34:31 <Welkin> it still looks like the way skylighting parses haskell sucks
11:34:35 <Welkin> I'm very disappointed
11:35:43 <Welkin> for example: `addOne :: Int -> Int` is parsed as `addOne ::`, `Int`, `->`, `Int`
11:35:50 <Welkin> why not `addOne` `::`
11:35:51 <Welkin> !!!!
11:36:19 <Welkin> every case of `name ::` is parsed together
11:36:21 <Welkin> drives me mad
11:37:18 <metahumor> Matteo_: before we deal with the MVar stuff, you should write a sketch definition of moveRobot
11:37:30 <metahumor> oh its at the bottom
11:37:43 <Welkin> thankfully `name =` is parsed as `name` and `=`
11:38:03 <Welkin> but this means I cannot syntax highlight `::` and `->` like is done in every editor
11:38:10 <Matteo_> metahumor: yeah that function moves the robot based on the speed of the wheels
11:38:13 <Welkin> the text preceding `::` will be the same color
11:41:46 <Matteo_> so i nee some way of changing the wheel speeds but i have no idea how
11:42:58 <metahumor> Matteo_: well, if you just have an initialState of the world, you could do something like "animate display color (\frame -> render (moveRobot frame initialState))"
11:43:26 <metahumor> that's the case where you're not supplying any instructions during the simulation, just letting it evolve on its own from starting conditions
11:45:09 <Matteo_> metahumor: i dont understant what you mean with the "animate display color (\frame -> render (moveRobot frame initialState))"
11:47:38 <Matteo_> metahumor: If i do it that way then i use animate instead of simulate or playIO
11:47:47 <Matteo_> metahumor: or can i use both ?
11:48:21 <metahumor> well, right now, i don't see anywhere in your code a list of the actions you'll be running
11:48:38 <metahumor> so your world is fully determined by its initial state
11:48:58 <metahumor> so you can just animate that. animate is from Graphics.Gloss.Interface.Pure.Animate
11:50:24 <Matteo_> so you animate instead of simulate ?
11:51:18 <metahumor> that's what i'm suggesting you try first, to make sure all of your code works fine
11:51:28 <metahumor> then we can think about how we'd incorporate a list of actions
11:56:47 <Matteo_> but what's the difference between the 2 what are the benefits of using animate over silumate ?
11:58:16 <metahumor> simulate expects you to provide a function that can deal with time properly AND the viewport. i doubt your robot functions care about how you're viewing the world. and right now we know exactly how our world is changing, so we don't need to update at all
11:59:35 <Matteo_> metahumor: but if i want to then later implement the functions then i would need some kind of step function with you dont have with animate no ?
12:01:16 <metahumor> if you know all the functions at compile time, then you can still build the Float -> Picture transformer
12:01:35 <metahumor> through some sort of time-conditional-fold
12:02:09 <metahumor> I'm just suggesting you iteratively develop your simulator, verify that a robot properly "animates" when supplied with no instructions, given a starting state
12:02:26 <Matteo_> but then i wont be able to run commands from the otherprogram that change the state op the simulator
12:02:53 <metahumor> i think we're discussing slightly different things
12:03:20 <metahumor> i believe that if you get the "animate" working, refactoring that to use "simulateIO" or "playIO" will be easy
12:05:13 <Matteo_> metahumor: oke ill try to change it to animate, but why do you use \frame ?
12:07:09 <metahumor> animate :: Display -> Color -> (Float -> Picture) -> IO ()
12:07:27 <Matteo_> ah oke
12:07:38 <metahumor> you have a "moveRobot :: Float -> Simulator -> Simulator" and "render :: Simulator -> Picture"
12:08:37 <metahumor> together, you can have your world at some "timevariable" using "moveRobot timevariable initialState" and then render that
12:08:52 <metahumor> i called "timevarible" the "\frame -> "
12:09:01 <Matteo_> oke the simulator is working fine with the animate function
12:09:19 <elvishjerricco> Is there a function `String -> Maybe Rational` that parses decimal format (e.g. `3.5`) and doesn't go through an intermediate `Double`?
12:09:26 <metahumor> you could also write "render . flip moveRobot initialState"
12:10:09 <metahumor> elvishjerricco: when would it be Nothing? on an invalid string?
12:10:17 <elvishjerricco> metahumor: Yea
12:10:28 <hyperisco> what is the "safe read" function
12:10:41 <hyperisco> @hoogle Read a => String -> Maybe a
12:10:42 <lambdabot> Text.Read readMaybe :: Read a => String -> Maybe a
12:10:42 <lambdabot> Test.Tasty.Options safeRead :: Read a => String -> Maybe a
12:10:42 <lambdabot> Safe readMay :: Read a => String -> Maybe a
12:10:55 <hyperisco> > readMaybe "3.5" :: Maybe Rational
12:10:59 <lambdabot>  error:
12:10:59 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Maybe Rational
12:11:12 <geekosaur> @index readMaybe
12:11:12 <lambdabot> Text.Read
12:11:14 <elvishjerricco> hyperisco: That is not how Rational's `Read` instance is formated
12:11:16 <hyperisco> well, you're going to have bad times there anyways, because 3.5 isn't a show of a Rational
12:12:18 <hyperisco> maybe you should split the string on the decimal point and parse as two integers
12:12:42 <hyperisco> or can do that with any parser combinator lib
12:12:55 <Matteo_> metahumor: thx for all the help, but iam going to bed i cant see anymore haskell code xD
12:12:57 <metahumor> elvishjerricco: something like "f str = case (splitOn "." str) of (x:y:[]) -> read x + (read y % (10 ^ length y)"
12:13:29 <hyperisco> I wouldn't do that…
12:13:38 <Matteo_> metahumor: see you tomorrow mayby
12:13:39 <metahumor> there's a Just and a Nothing missing
12:13:41 <Matteo_> bye
12:13:44 <elvishjerricco> Yea I do not want to write my own number parser if I can avoid it
12:13:45 <metahumor> bye Matteo_
12:14:55 <erisco_> from  x.y  do  fromIntegral x + 1 / fromIntegral y
12:26:02 <hyperisco> sorry, am battling with my client
12:28:31 <hyperisco> would be neato if lambdabot had some parser combinators in stock
12:28:50 <hyperisco> should have mniip's… no… merijn's… dammit… parser combinators loaded
12:29:34 <barrucadu> Welkin: I gave up on pandoc's syntax highlighting a long time ago and shell out to pygmentize in my hakyll script: https://github.com/barrucadu/barrucadu.co.uk/blob/master/hakyll.hs#L104
12:29:35 <hyperisco> mniip's!
12:29:37 <mniip> can do
12:30:39 <mniip> give it a few minutes, HEAD cabal likes to be extra slow
12:34:38 <c_wraith> hmm. even though I know he doesn't hang out here, happy birthday to SPJ
12:35:39 <hyperisco> \o/
12:36:19 <merijn> I don't suppose anyone here has implemented a conduit library for sqlite-simple?
12:36:59 <merijn> Or is aware of one, for that matter
12:40:48 * merijn sighs
12:41:02 <merijn> All of these libraries are so close, but not quite what I need :\
12:47:25 <Welkin> barrucadu: why pygment?
12:48:08 <barrucadu> Welkin: I like its output
12:48:35 <Welkin> any example of how it looks?
12:48:48 <Welkin> I did use pygments when I tried using jekyll
12:48:54 <Welkin> I don't remember though
12:49:25 <barrucadu> https://www.barrucadu.co.uk/posts/etc/2017-05-18-visualise-your-finances-with-hledger-influxdb-grafana.html
12:49:29 <Welkin> can you still use the same stylesheets though? Or does it require a pygments stylesheer?
12:50:17 <barrucadu> It does need a pygments stylesheet
12:50:42 <Welkin> I got skylighting with my custom zenburn stylesheet to look almost the same as in emacs
12:50:47 <Welkin> except for a few issues
12:50:55 <Welkin> pygments obviously won't look the same either
12:51:49 <Welkin> I've been thinking about how I want to display normal text along with code
12:52:17 <Welkin> I considered making an html-ized version of the plain text literate haskell file (with all the pretty colors)
12:52:34 <Welkin> that may not be the best for long reading sessions, though
12:52:59 <Welkin> the bird tracks make it easy to separate code from normal text
12:53:38 <Welkin> but if I use colors/fonts instead, having black text on a white background, then having code using a dark theme looks a bit odd
12:54:48 <Welkin> barrucadu: do you have any good zenburn or tomorrow night stylesheets for pygments?
12:55:57 <Welkin> also, are you using lhs or markdown/rst?
12:56:43 <barrucadu> I think this is the collection of pygments themes I looked at when I picked one https://github.com/richleland/pygments-css, but it doesn't have a zenburn or tomorrow night
12:57:39 <barrucadu> I'm using markdown on my website, in my memo site (eg https://memo.barrucadu.co.uk/dejafu-multithreaded-runtime.html) I sometimes use markdown, sometimes lhs
12:57:55 <barrucadu> Though the hakyll code is very similar for both of them
12:58:14 <Welkin> I have used markdown and rst
12:58:23 <Welkin> I recently switched to using lhs for this project though
12:59:07 <Welkin> it's REALLY nice being able to have your code properly formatted and syntax highlighted in your editor while you write
12:59:20 <Welkin> I will never go back to markdown/rst for anything that involves course code
12:59:31 <barrucadu> It is nice
12:59:37 <Welkin> source code*
13:00:49 <metahumor> Welkin: have you tried "doctest"?
13:01:03 <barrucadu> My memos are a somewhat unpolished dump of my thoughts, so the main benefit of lhs there for me is that I can load the files into ghci and play around with the code
13:01:15 <Welkin> metahumor: no
13:01:48 <metahumor> code is code and comments can be ran by "doctest
13:01:57 <Welkin> I remember reading about that
13:02:07 <mrkgnao> Welkin: I have some code that lets Hakyll execute "doctest"-like blocks, something like the Scala "tut" tool
13:02:09 <Welkin> I am using lhs for a slightly different purpose though
13:02:10 <mrkgnao> it's very neat
13:02:16 <Welkin> it's not meant to be executable
13:02:20 <Welkin> it's a book about haskell
13:03:20 <Zemyla> I really wish there were a way to have a guaraneed nonempty Seq.
13:22:57 <thehappycolorpro> hello, complete noob here
13:23:28 <ski> hello thehappycolorpro
13:23:42 <thehappycolorpro> i'm starting out on learn you a haskell and i downloaded the haskell platform
13:24:20 <thehappycolorpro> in the WinGCHi thing i type in "ghci" like it says to in the tutorial but i get this error : <interactive>:7:1: error: Variable not in scope: ghci
13:24:35 <electrocat> thehappycolorpro: you're already in ghci :)
13:24:43 <thehappycolorpro> o
13:24:48 <thehappycolorpro> ez
13:24:55 <thehappycolorpro> hello ski :D
13:25:21 <thehappycolorpro> ah man i have no idea what i'm getting myself into
13:25:30 <thehappycolorpro> i am new to programming in general
13:25:39 <ski> i suppose you'd type `ghci' (or maybe `ghci.exe') in a `cmd.exe' command shell / terminal window, on Windows, unless you have a more suitable shell and/or terminal emulator
13:26:09 <thehappycolorpro> oh i see
13:26:15 <thehappycolorpro> i am dumb
13:26:22 <ski> but using WinGHCi instead of that will probably be easier for you, at least for now, so you can probably safely ignore what i just said above
13:26:48 <ski> how do you know you're dumb ?
13:27:20 <ski> you don't know your way around things, presumably. but that's the case for everyone, when they start out (with something new)
13:27:40 <thehappycolorpro> i just misread the instructions
13:27:44 <thehappycolorpro> hahahahahaha
13:28:03 <ski> most important is to keep going, keep learning, and keep having fun .. as long as you feel it's something you'd like to do, of course
13:28:18 <thehappycolorpro> yes yes thank you very much
13:28:23 <elfets> hello
13:29:36 <mniip> hyperisco,
13:29:38 <mniip> % :browse Control.Monad.Yoctoparsec
13:29:38 <yahb> mniip: type Control.Monad.Yoctoparsec.Parser (b :: * -> *) t a = Control.Monad.Trans.Free.FreeT ((->) t) b a; Control.Monad.Yoctoparsec.parseStream :: Monad b => (s -> b (t, s)) -> Control.Monad.Yoctoparsec.Parser b t a -> s -> b (a, s); Control.Monad.Yoctoparsec.parseString :: MonadPlus b => Control.Monad.Yoctoparsec.Parser b t a -> [t] -> b (a, [t]); Control.Monad.Yoctoparsec.token :: Applicative b => Con
13:29:55 <ski> if you're new to programming as well, then you're probably even more in need of a good introduction text, than people who know other programming languages (not counted under the "functional programming" umbrella)
13:30:03 <mniip> should I bring it in the default scope?
13:30:06 <metahumor> elfets: hi
13:30:17 <hyperisco> at least an alias would be nice
13:30:29 <thehappycolorpro> i read the book "code" by charles something
13:30:43 <ski> thehappycolorpro : have you found at least a tutorial ? a textbook ? are you following a course ? do you have anyone near you physically, that you can ask for help ?
13:31:02 <thehappycolorpro> nope, i figured i can learn from the internet
13:31:07 * ski isn't sure which book thehappycolorpro is thinking of
13:31:21 <thehappycolorpro> i'm following the "learn you a haskell" to start off
13:31:23 <elfets> is http://learnyouahaskell.com/ a good place to start?
13:31:55 <merijn> elfets: Honestly, not really
13:31:58 <ski> well, this channel is usually happy to help newbies with learning (though one is required to display that one tries to make an effort, of course)
13:32:00 <metahumor> it's not bad, some concepts are shown in an unusual order
13:32:03 <geekosaur> it's a nice grand tour, but you really need exercises
13:32:06 <elfets> oh, can you recomment something?
13:32:09 <metahumor> HaskellBook!
13:32:12 <metahumor> @where haskellbook
13:32:13 <lambdabot> http://haskellbook.com
13:32:14 <elfets> thanks
13:32:15 <geekosaur> @where cis194
13:32:15 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
13:32:20 <ski> thehappycolorpro : however, having some kind of teaching text to follow along with, would probably help much
13:32:30 <thehappycolorpro> ahhh
13:32:36 <merijn> elfets: It has a historic place in being the first "mainstream" haskell book, but it's not particularly good pedagogy wise
13:32:50 <mniip> hyperisco, okay I've included all terms from Control.Monad.Yoctoparsec but not the Parser type as that name is fairly universal
13:32:52 <ski> metahumor's and geekosaur's suggestions are usually considered good here
13:32:52 <thehappycolorpro> is there a text you would recommend?
13:32:55 <mniip> % :t parseString
13:32:55 <yahb> mniip: MonadPlus b => Y.Parser b t a -> [t] -> b (a, [t])
13:33:11 <hyperisco> % help
13:33:11 <yahb> hyperisco: ; <interactive>:3:1: error: Variable not in scope: help
13:33:21 <ski> i learned from "Haskell: The Craft of Functional Programming" by Simon Thompson
13:33:37 <shapr> I have a copy of the 2nd edition of Programming in Haskell, I'd like to read that this year.
13:33:37 <ski> @where HPFFP
13:33:38 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
13:33:49 <ski> might be more thorough, i haven't read it
13:33:50 <shapr> I wish I could find an online study group for the various Haskell books I'm reading.
13:34:01 <shapr> I bet I'd get more learned.
13:34:12 <mniip> hmm
13:34:23 <mniip> the name 'token' is fairly univesal too, not sure about that
13:34:33 <ski> elfets : people often liken LYAH with a four-hour long movie trailer. you don't learn enough in depth, partially because it doesn't have exercises
13:34:39 <shapr> I wonder if a google group and irc channel would work for an online study group?
13:34:47 <ski> thehappycolorpro : that ^ also goes to you
13:34:53 <elfets> thanks
13:34:58 <thehappycolorpro> ahh
13:35:19 <elfets> I did some C/C++, python, lua, etc
13:35:22 <hyperisco> % :t some (mfilter isDigit token)
13:35:22 <yahb> hyperisco: MonadPlus b => Control.Monad.Trans.Free.FreeT ((->) Char) b [Char]
13:35:30 <elfets> but somehow the concept reminds me a bit of forth
13:35:35 <metahumor> mniip: do you have any nice predefined tokens/parsers in yocto?
13:35:51 <mniip> no
13:35:53 <mniip> it's yocto
13:36:06 <mniip> anything else and it's femto
13:36:25 <thehappycolorpro> alright i will start with the haskell book
13:36:37 <hyperisco> % (read :: String -> Integer) <$> some (mfilter isDigit token)
13:36:37 <yahb> hyperisco: ; <interactive>:12:1: error:; * No instance for (Data.Functor.Classes.Show1 ((->) Char)) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
13:36:39 <thehappycolorpro> so far i failed on the first instruction in LYAH and then quit
13:36:43 <hyperisco> % :t (read :: String -> Integer) <$> some (mfilter isDigit token)
13:36:43 <yahb> hyperisco: MonadPlus b => Control.Monad.Trans.Free.FreeT ((->) Char) b Integer
13:36:47 <hyperisco> okay now we're cooking with gas
13:37:07 <metahumor> parseString (some (mfilter isDigit token)) "123" gives me "error: mzero"
13:37:21 <mniip> metahumor, it inferred b ~ IO
13:37:21 <ski> thehappycolorpro : note that the #haskell-beginners channel is created partly to help with people following that book. however, beginner questions are also welcome in this channel
13:37:42 <metahumor> oh. right.
13:37:47 <thehappycolorpro> ohhhh i didn't know that existed, thank you very much
13:38:15 <mniip> % parseString @[] (read @Integer <$> some (mfilter isDigit token)) "123"
13:38:15 <yahb> mniip: [(123,""),(12,"3"),(1,"23")]
13:38:15 <hyperisco> % :t let int = (read :: String -> Integer) <$> some (mfilter isDigit token); dot = mfilter (== '.') token; in (\x y -> (fromIntegral x + 1 / fromIntegral y) :: Rational) <$> int <*> (dot *> int)
13:38:16 <yahb> hyperisco: MonadPlus b => Control.Monad.Trans.Free.FreeT ((->) Char) b Rational
13:38:18 <ski> (i'll let the others in here take further care of you now, though)
13:38:22 <mniip> I mean hey
13:38:24 <mniip> TypeApplications
13:38:29 * ski heads over to #haskell-overflow
13:38:51 <hyperisco> % let int = (read :: String -> Integer) <$> some (mfilter isDigit token); dot = mfilter (== '.') token; p = (\x y -> (fromIntegral x + 1 / fromIntegral y) :: Rational) <$> int <*> (dot *> int) in parseString @[] p "3.5"
13:38:51 <yahb> hyperisco: [(16 % 5,"")]
13:39:11 <metahumor> uhh are you sure you mean "1 / fromIntegral y"?
13:39:52 <hyperisco> hm, wow, not sure that even reached the standard of napkin math
13:40:08 <metahumor> it's like some weird mix of regular and p-adics =P
13:40:24 <hyperisco> lets just say it is intended
13:40:32 <mniip> why not use do notation
13:40:43 <hyperisco> was never into monadic parsing
13:40:46 <centril> I'm trying to induce a type error which shows me the type of all the parts... but my brain is too tired to figure one out atm... does anyone have any type error they wanna give me?
13:40:50 <sudoreboot[m]> Does anyone know of any existing desktop apps built with Reflex.Dom (with GHC, not GHCJS)? I'm shopping for a way to build desktop GUI applications entirely in Haskell
13:41:28 <metahumor> % parseString @Maybe (some (mfilter isDigit token)) "1234"
13:41:28 <yahb> metahumor: Nothing
13:41:34 <metahumor> why?
13:41:58 <metahumor> centril: ?
13:42:07 <centril> metahumor: like this:  http://lpaste.net/361538
13:42:15 <mniip> metahumor, it can't backtrack
13:42:18 <mniip> that screws it up
13:42:23 <centril> need some examples to use for discussion about rustc's error messages
13:42:39 <mniip> ah right, some is greedy
13:42:42 <Wizek> sudoreboot[m] are you aware of this? https://github.com/reflex-frp/reflex-todomvc Or are you looking for something else?
13:42:56 <metahumor> % fmap fst . listToMaybe $ parseString @[] (some (mfilter isDigit token)) "1234"
13:42:57 <yahb> metahumor: Just "1234"
13:43:10 <mniip> % :t hoistFreeT
13:43:10 <yahb> mniip: ; <interactive>:1:1: error: Variable not in scope: hoistFreeT
13:43:13 <mniip> hrm
13:43:19 <hyperisco> mniip, what do you mean it can't back track?
13:43:30 <mniip> Maybe is a non-backtracking nondeterminism monad
13:43:41 <hyperisco> oh I thought you were choosing []
13:44:12 <sudoreboot[m]> Wizek: I glossed over it. I'll take a look at it, thanks
13:44:14 <mniip> % :t Control.Monad.Trans.Free.hoistFreeT listToMaybe (some (mfilter isDigit token))
13:44:14 <yahb> mniip: Control.Monad.Trans.Free.FreeT ((->) Char) Maybe [Char]
13:44:31 <mniip> temporary backtracking enable :O
13:44:32 <mniip> :P *
13:44:57 <metahumor> % parseString @Maybe ((mfilter isDigit token)) "1234"
13:44:57 <yahb> metahumor: Just ('1',"234")
13:45:13 <metahumor> something about the Alternative might be weird here
13:46:10 <thehappycolorpro> uhh, why does the haskell book FFP start on chapter 2?
13:46:42 <thehappycolorpro> i'm using the sample version. does the full version have a chapter 1?
13:46:45 <thehappycolorpro> D:
13:47:03 <metahumor> yeah, it does in the full vers
13:48:09 <hyperisco> > zipWith (*) (iterate (/10) 1) [1..10] :: [Rational]
13:48:11 <lambdabot>  [1 % 1,1 % 5,3 % 100,1 % 250,1 % 2000,3 % 50000,7 % 1000000,1 % 1250000,9 % ...
13:48:26 <ski> thehappycolorpro : you could also ask (one of) the author(s) of the book, bitemyapp, about it
13:48:50 <merijn> thehappycolorpro: chapter 1 is basic setup, etc.
13:48:57 <merijn> thehappycolorpro: So not really about Haskell
13:49:31 <MarcelineVQ> actually chapter 1 is lambda calculus if you wanted to search that on your own, large sounding thing but very simple at heart
13:49:45 <mniip> metahumor, no actually it makes sense
13:50:12 <thehappycolorpro> i watched a computerphile video on it xd
13:50:29 <hyperisco> I dunno, the parser doesn't cram onto one line so well, but it is still pretty easy
13:50:30 <mniip> some/many can neither do a greedy match in the Maybe monad
13:50:40 <hyperisco> though it needs to be  iterate (/10) (1/10)
13:50:42 <merijn> thehappycolorpro: The full version of Haskell Book is like 800 or so pages, so even if chapter 1 was missing there's still way too much ;)
13:51:08 <thehappycolorpro> alright, i'll try the sample for now and if i can somehow make it to the end of the sample without quitting then i will buy the book
13:51:19 <MarcelineVQ> a large % of that is exercises so that you remember what you read :>
13:54:02 <thehappycolorpro> so would everyone recommend i go all the way through the book once before attempting to make something
13:55:04 <Rembane> thehappycolorpro: No! Hack first! Come bcak here when you get stuck. :D
14:05:48 <Wizek> sudoreboot[m]: Also, do you know of https://github.com/reflex-frp/reflex-platform ? If you clone this and run `$ ./try-reflex`, then inside the shell that launches you'll be able to type `$ todomvc-reflex` (or something similar) to launch it.
14:08:56 <sudoreboot[m]> Wizek (@freenode_Wizek:matrix.org): I didn't know it had todomvc in there too. I was about to build it from the repo
14:10:08 <Wizek> sudoreboot[m]: I think you'll be able to save some time if you start out with the try-reflex route
14:11:20 <sudoreboot[m]> Wizek (@freenode_Wizek:matrix.org): Thanks, I'll do that
14:11:38 <Welkin> matrix...
14:11:43 <Welkin> wtf
14:12:04 <Welkin> sudoreboot[m]: you have a ton of extra garbage in your autocomplete that should not be there
14:12:25 <Welkin> who invented matrix?
14:12:32 <Welkin> we should burn them at the stake
14:12:54 <Welkin> they unleashed a blight upon the world
14:13:40 <Wizek> Welkin: Are you saying that because of the extra bit of noise in the mention, or for some other deeper reasons too?
14:13:55 <Welkin> Wizek: many other reasons
14:14:15 <Welkin> notice all the matrix "netsplits"
14:14:19 <sudoreboot[m]> Welkin: I'm trying out an immature matrix client which is less intelligent about mentions than riot.im
14:14:52 <Welkin> there was talk of banning matrix from #haskell (or maybe even Freenode) I think
14:15:35 <mniip> they're definitely not banning matrix off freenode, but
14:15:40 <MarcelineVQ> sounds like hearsay
14:15:41 <mniip> it is very inconvenient as is
14:15:48 <mniip> something needs to be done about that
14:16:07 <Welkin> anyone remember Bottler?
14:16:19 <Welkin> that crappy irc client that was banned on almost every irc network a decade ago
14:16:36 <thehappycolorpro> AAAAAAAAHHHHHHH
14:16:46 <thehappycolorpro> i cant get haskell stack to work
14:17:00 <Welkin> you don't sound happy to me, bob ross
14:17:04 <thehappycolorpro> i run it and a black box appears for a split second and then disappears
14:17:16 <Welkin> there should not be any boxes appearing
14:17:23 <Welkin> stack runs in a terminal
14:17:39 <MarcelineVQ> open a terminal first and then run it
14:17:49 <metahumor> thehappycolorpro: Win+R -> cmd -> stack ghci
14:18:29 <thehappycolorpro> oh
14:19:11 <sudoreboot[m]> How do you even run a cli application without the terminal
14:19:16 <thehappycolorpro> im a noob
14:19:26 <metahumor> thehappycolorpro: did it work?
14:19:42 <Wizek> sudoreboot[m]: double click in the explorer.exe, I'd guess.
14:20:22 <thehappycolorpro> it downloaded some stuff and is now extracting
14:20:30 <geekosaur> stack is a build tool, that expects to run in a terminal. if you just try to run it from the cli, a terminal window opens, stack probably displays an error message because you didn't tell it what to do, and exits and the terminal closes
14:20:41 <thehappycolorpro> it's my first time using terminal stuff
14:20:42 <geekosaur> er, from the gui
14:20:43 <thehappycolorpro> i see I SEE
14:20:45 <MarcelineVQ> sudoreboot[m]: ime console applications in windows will open a console, but it'll close when they're done
14:20:57 <metahumor> thehappycolorpro: you are now probably installing a system-wide ghc that stack is going to use so it can run ghci
14:21:19 <metahumor> thehappycolorpro: that should be more than sufficient to get your feet wet with haskell
14:21:36 <Welkin> thehappycolorpro: then how are you on irc?
14:21:45 <thehappycolorpro> website
14:21:53 <metahumor> Welkin: webchat
14:21:54 <Welkin> connecting to irc outside of a web client requires some level of computer knowledge
14:22:00 <geekosaur> (os x handles this a little better, the terminal stays open afterward)
14:22:05 <Welkin> so wait...
14:22:12 <Welkin> how are you a programmer that has never used a terminal?
14:22:14 <Welkin> sounds impossible
14:22:16 <thehappycolorpro> i'm not
14:22:30 <thehappycolorpro> i am a noooob
14:22:32 <geekosaur> Welkin, there's lots of gui-only workflows for e.g. java
14:22:41 <Uniaika> and windows
14:22:54 <metahumor> there are cli tools that you can open from Explorer, they have special hooks to recognize they've been opened that way
14:23:26 <geekosaur> if they need a terminal, they embed one and show it only when needed
14:23:41 <geekosaur> apple's xcode does the same thing
14:24:30 <thehappycolorpro> ohh a bunch of words are scrolling through the screen
14:24:34 <thehappycolorpro> i feel like a hacker
14:24:44 <metahumor> well you are hacking away
14:25:34 <Welkin> geekosaur: don't remind me of xcode... possibly the worst software ever made. Worse than windows
14:25:52 <geekosaur> heh
14:26:12 <geekosaur> I'm not exactly fond of it, or recent os x in general
14:26:35 <geekosaur> the mac is sitting gathering dust in the corner, just in case I need vmware for some reason
14:26:49 <Welkin> I just avoid updating to high sierra
14:26:53 <Welkin> for as long as I can at least
14:27:08 <metahumor> gotta keep that root login easily accessible!
14:31:07 <thehappycolorpro> NICEEEEEE it works
14:31:18 <thehappycolorpro> 2 + 2 is 4
14:35:45 <thehappycolorpro> what text editor would you all recommend?
14:36:28 <sudoreboot[m]> spacemacs
14:36:47 <Welkin> normal emacs
14:37:27 <Welkin> it will take time to learn, and you will not like it at first. But once you learn some basic keybindings, you will not want to use anything else
14:38:00 <Welkin> everything else feels slow and incomplete by comparison
14:38:06 <thehappycolorpro> hmmm
14:38:12 <lambdafan> I'm trying to locate the package that defines the type operator (:~>)
14:38:25 <thehappycolorpro> i googled spacemacs and it says that spacemacs is emacs used for evil
14:38:28 <lambdafan> I've got some old servant code I am trying to update
14:38:52 * geekosaur uses emacs... but see /nick. also, I was willing to give atom a chance but it was more willing to get in a fight with chromium over who could eat all my memory faster
14:39:12 <geekosaur> thehappycolorpro, that sounds like the opinion of an old emacs user
14:39:28 <lambdafan> :t (:~>)
14:39:30 <lambdabot> error:
14:39:30 <lambdabot>     • Data constructor not in scope: :~>
14:39:30 <lambdabot>     • Perhaps you meant one of these:
14:39:40 <lambdafan> :k (:~>)
14:39:42 <lambdabot> error:
14:39:43 <lambdabot>     Not in scope: type constructor or class ‘:~>’
14:39:43 <lambdabot>     Perhaps you meant ‘:~:’ (imported from Data.Typeable)
14:39:46 <geekosaur> the idea of emacs with a friendlier UI and defaults is terrifying to some of those people
14:40:25 <sudoreboot[m]> What is lambdabot doing
14:40:43 <geekosaur> lambdafan is asking for something not imported
14:40:55 <monochrom> "Its job."
14:41:00 <geekosaur> (note different last 3 characters of nick)
14:41:49 <sudoreboot[m]> Must be a riot thing that I don't see anyone asking lambdabot about anything
14:42:01 * geekosaur asks hayoo about the consgtructor in questionm then wonders which one lambdafan was looking for
14:42:16 <lambdafan> hayoo!
14:42:22 <lambdafan> thanks I will try hayoo
14:43:13 <MarcelineVQ> geekosaur: it's not an opinion thing hehe. evil is a vim mode for emacs, spacemacs has evil mode by default
14:43:20 <geekosaur> ah
14:43:24 <lambdafan> Servant.Server.Internal.Enter  <-- used to get it from there, but this module is being depricated
14:43:33 <geekosaur> not one I'd heard of before
14:43:49 <Welkin> emacs with vim bindings is just plain wrong
14:43:51 <Welkin> it feels dirty
14:43:59 <lambdafan> Oh I see where it lives now, thanks for the hayoo tip
14:44:03 <Welkin> vim bindings make no sense to me
14:44:08 <geekosaur> lambdafan, so my lookup suggests it's in Servant.Server directly noiw
14:44:19 <geekosaur> which would be why the internal one would be deprecated
14:44:43 <geekosaur> (next entry under the Internal one)
14:46:20 <lambdafan> geekosaur, I went to that module and did a search for it. To no avail.
14:46:28 <geekosaur> probably version skew
14:47:12 <lambdafan> version skew? like it's one off?
14:47:41 <geekosaur> hm... yes, hayoo is linking to a version without it, it seems
14:48:01 <geekosaur> or perhaps not documenting it for some reason
14:48:21 <lambdafan> I just tried compiling, that operator does not live in that module
14:49:53 <thehappycolorpro> oh man im installing all these programs and i feel like im playing dwarf fortress again
14:50:20 <lambdafan> hmm 0.11.1 has that operator, I wonder how important 0.12 is, or maybe they moved it's location in 0.12?
14:50:32 <geekosaur> seems like it
14:50:37 <geekosaur> that was what I meant by version skew
14:50:43 <geekosaur> hayoo gets out of step sometimes
14:51:33 <geekosaur> oh, hm, looks like the redesigned the "enter" stuff
14:52:03 <geekosaur> "Use hoistServer (a successor of now deprecated enter)."
14:52:15 <geekosaur> and :~> was part of "enter"
14:52:23 <Welkin> enter is deprecated?
14:52:24 <Welkin> :(
14:52:33 <Welkin> I have been away from servant longer than I thought
14:52:39 <geekosaur> new in 0.12, yes
14:57:24 <phadej> enter lacked working when you most needed it :)
14:57:40 <phadej> hoistServer is way more robust approach
14:58:36 <dmj`> enter was pretty lawless as well
14:59:29 <hololeap> i'm looking for something, and i'm having a hard time thinking of how to explain it. it's like Applicative on lists, except working more like zipWith and giving a remainder if the target list is longer than the list of functions...
14:59:35 <Welkin> an outlaw with a fistful of dollars?
14:59:46 <Welkin> hololeap: everybody's looking for something
14:59:53 <phadej> hmm. All the stuff in `servant` is ad-hoc type-classes making GHC think hard
15:00:10 <hololeap> it would be of type :: [a->b] -> [a] -> [[b]]
15:00:20 <phadej> though you can imagine composition law for `hoistServer`
15:00:30 <phadej> (and identities)
15:00:34 <Welkin> Some of them want to use you
15:00:46 <Welkin> Some of them want to get used by you
15:01:02 <hololeap> an example would be: `zipThing [(+1), (+2)] [1,2,3,4,5]` returns `[[2],[4],[3,4,5]]`
15:01:48 <phadej> it won't work if a /~ b
15:02:07 <phadej> 3,4,5 is "a", not "b"
15:02:47 <phadej> and what happens if first list is longer?
15:02:48 <hololeap> phadej: you're right, so it would probably have to be `zipThing :: [a->b] -> [a] -> ([b],[a])`
15:03:17 <phadej> anyway, you can build it with https://hackage.haskell.org/package/these-0.7.4/docs/Data-Align.html
15:03:20 <phadej> or something like that
15:04:11 <hololeap> ok, i'll look at Data.Align ...
15:05:09 <phadej> but general Applicative doesn't feel possible; but I haven't seen it "proved" it cannot be done :)
15:05:35 <phadej> (one insight: what `pure` would do for such applicative?)
15:06:06 <hololeap> i suppose pure x = ([x],[])
15:06:38 <phadej> here types don't align
15:07:43 <phadej> you should try out, types don't align :)
15:08:00 <phadej> you'd need zipThing :: [a -> b] -> [a] -> [b]
15:08:39 <hololeap> hmmm.... well the motivation is an input that has 2 or 3 lines that would have a unique function, and then N lines that would be processed as a group, so a convenient way to take the first few items of a list, do something unique with them, and then run an fmap over the rest
15:09:22 <phadej> now you lost me
15:09:29 <dmj`> @def zipThang xs ys = let zs = zipWith (\f x -> [f x]) xs ys in zs ++ [drop (length xs) ys]
15:09:32 <lambdabot>  Defined.
15:09:44 <dmj`> > zipThang [(+1), (+2)] [1,2,3,4,5]
15:09:47 <lambdabot>  [[2],[4],[3,4,5]]
15:10:00 <Welkin> snoop dogg oriented programming?
15:10:09 <dmj`> ain’t nuthin’ but a zip thang baby
15:10:13 <Uniaika> \o/
15:10:40 <phadej> :t zipThang
15:10:43 <hololeap> eh, don't worry about it, i think i'm looking for a clever abstraction when it would be easier just to write it out explicitly
15:10:45 <lambdabot> [a -> a] -> [a] -> [[a]]
15:10:55 <phadej> a -> a is easy ;)
15:12:50 <Welkin> zipThong
15:12:53 <Welkin> dipthong?
15:14:35 <dmj`> phadej ;)
15:19:12 <thehappycolorpro> uhh. how do i open my ghci REPL in the same directory as my "test.hs" file?
15:19:18 <thehappycolorpro> i feel like a grandma
15:19:54 <dmj`> cd folder-with-test-hs && ghci test.hs
15:19:55 <hpc> cd to that directory and run ghci?
15:20:32 <MarcelineVQ> *on windows using stack
15:20:39 <hpc> if you're on windows it's usually easier to shift-right-click in explorer to open a prompt in the current directory
15:20:57 <hpc> use "stack ghci"
15:21:22 <thehappycolorpro> what does it mean to cd to the folder
15:21:23 <thehappycolorpro> LOL
15:21:50 <Welkin> step one: install linux
15:21:59 <thehappycolorpro> :o
15:22:22 <Welkin> cd is a command
15:22:27 <Welkin> it stands for "change directory"
15:23:04 <monochrom> Windows command prompt also has "cd".
15:23:09 <thehappycolorpro> OK i will figure it out thank you very much
15:24:57 <Welkin> windows also has `dir`
15:25:00 <Welkin> but not `ls`
15:30:33 <koala_man> I have a program 'main = sequence (replicate 10000 $ putStrLn "x")' that results in 3 write calls and 109 clock_gettime and rt_sigaction calls. why?
15:32:01 <koala_man> I suspect the number of additional calls is causing unnecessary slowdowns in a real, CPU bound program run under proot (i.e. ptrace)
15:33:44 <thehappycolorpro> awww yeeeeee i got it
15:35:00 <u-ou> :t sequence
15:35:02 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
15:37:33 <thehappycolorpro> Prelude> ((1 + 2) * 3) + 100 *** Exception: <interactive>:10:1-9: Non-exhaustive patterns in function +
15:37:45 <thehappycolorpro> im so confused
15:37:59 <geekosaur> sounds like you defined a (+) at some point
15:38:32 <thehappycolorpro> how would i go about undefining it?
15:38:48 <thehappycolorpro> i wrote x + 2 = 3 to see what would happen
15:39:03 <thehappycolorpro> nothing happened D:
15:39:23 <fishythefish> you changed the definition of (+) to give you 3 whenever you provide something that looks like _ + 2
15:39:58 <fishythefish> note that this definition doesn't say what (+) should do in all other cases, which is why it's complaining (... + 100 doesn't look like _ + 2)
15:40:01 <geekosaur> yes. this is one of the things you have to watch out for: that is aperfectly valid definition of an infix operator
15:40:02 <thehappycolorpro> +
15:40:04 <thehappycolorpro> woops
15:40:59 <thehappycolorpro> Prelude> 1000000 + 2 3
15:41:00 <thehappycolorpro> ahahahaha
15:41:25 <thehappycolorpro> INTERESTING
15:42:57 <thehappycolorpro> ah man i shouldve just kept to the book
15:43:21 <geekosaur> we could give you a Num instance for functions and break your brain even more :)
15:43:34 <thehappycolorpro> have mercy
15:43:51 <thehappycolorpro> i am the guy who had trouble running the stack thing
15:44:00 <thehappycolorpro> take it easy
15:44:11 <thehappycolorpro> niceeee
15:44:19 <thehappycolorpro> i typed :m and it reset
15:44:57 <thehappycolorpro> jk nvm
15:48:17 <thehappycolorpro> eh i give up i cant figure out how to undo
15:48:33 <thehappycolorpro> google searches dont help
15:48:52 <fishythefish> type :l
15:49:10 <MarcelineVQ> thehappycolorpro: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html
15:49:15 <thehappycolorpro> yus i get 1
15:49:35 <fishythefish> or :r if you want to reload modules rather than loading none
15:50:12 <MarcelineVQ> that page eventually says  "Temporary bindings introduced at the prompt only last until the next :load or :reload command, at which time they will be simply lost. However, they do survive a change of context with :module: the temporary bindings just move to the new location."
15:51:21 <thehappycolorpro> is there no way to undo it without reloading?
15:52:16 <MarcelineVQ> you can define it again and shadow the old one with the new, but not undo no.
15:53:00 <thehappycolorpro> ahhhh
15:53:04 <thehappycolorpro> i have much to learn
15:53:07 <MarcelineVQ> once you're comfortable you'll be working with a source file so this is less of a problem
15:53:38 <thehappycolorpro> was it a mistake to learn haskell as my first programming language
15:53:50 <hpc> probably not
15:53:55 <MarcelineVQ> I don't think so :>
15:54:03 <thehappycolorpro> ok
15:54:06 <hpc> i can think of a good 50 or so worse languages
15:57:07 <benzrf> thehappycolorpro: haskell is much harder to use without knowing what you're doing
15:57:31 <benzrf> it's traditional, when learning programming, to not know what you're doing, which results in Things Happening On Your Screen much more quickly
15:57:38 <benzrf> this is a difficult approach to take in haskell
15:58:35 <benzrf> to be fair: most things are learned better by doing-without-understanding while in the process of coming to understanding
15:58:38 <benzrf> ¯\_(ツ)_/¯
15:59:33 <benzrf> on the other hand, haskell has a lot less hidden weirdness where you think you know what you're doing but you're wrong
15:59:42 <hpc> at the same time, ghc will give you immediate feedback on all your terrible ideas, so you find the good ideas faster
16:03:47 <tommd> How does hvr create his ppa's?  Does he use cabal-debian?  I'm looking to release and package a couple haskell executables via a PPA.
16:03:48 <thehappycolorpro> aha
16:04:19 <thehappycolorpro> i think i would've even been able to start without this irc lul
16:04:23 <thehappycolorpro> thanks everyone
16:04:34 <thehappycolorpro> i dont* think
16:04:54 <geekosaur> tommd, you might have better luck with that question in #hackage
16:06:24 <dmj`> MarcelineVQ: if on Windows, you should use Cygwin
16:08:21 <tommd> geekosaur: Sounds good
16:19:46 <thehappycolorpro> why is the syntax different for REPL and source code? specifically the usage of "let"
16:22:59 <hololeap> i want to have a (IntMap IntSet) but have multiple keys pointing to the same IntSet without having duplicates in memory. can this be done?
16:23:13 <jle`> thehappycolorpro: the repl is a different sort of environment than the source code
16:23:28 <jle`> for example, it's useful to be able to import modules anywhere and at any time
16:23:40 <jle`> and also, things like `:t True`, to find types of things, is useful
16:23:41 <EvanR> definitions in source code dont have any particular order
16:23:56 <EvanR> the repl gets new definitions all the time, possibly contradictory
16:24:15 <jle`> s/contradictory/shadowy
16:24:18 <EvanR> also the repl grew legs over time to try and mimic other languages repl
16:24:31 <EvanR> like you can now do x = 1 instead of let x = 1
16:24:57 <EvanR> break blows the theory that "ghci is just an implicit IO do block" out of the water
16:25:03 <EvanR> s/break/which/
16:26:08 <jle`> i mean, ghci being an implicit IO do block was gone loooooong before that
16:26:15 <thehappycolorpro> ah i understood about a tenth of that
16:26:21 <jle`> even if you don't count things like :t, :i, etc.
16:26:27 <EvanR> i figured
16:26:31 <thehappycolorpro> lol
16:26:33 <EvanR> now its blown out of the water
16:26:35 <jle`> there's import, data, type, etc.
16:27:16 <EvanR> thehappycolorpro: i think an import thing is to know that a .hs file is not like a python or ruby file which gets interpreted line after line
16:27:26 <jle`> even before the 'let' change, there were more things different between ghci and a do block than similar
16:27:29 <EvanR> dynamically creating an environment
16:27:45 <EvanR> its more like a system of equations
16:28:06 <thehappycolorpro> oh
16:28:28 <thehappycolorpro> what would happen if you gave contradictory equations in the .hs file then
16:28:35 <EvanR> compile error
16:28:39 <thehappycolorpro> oooooooo
16:28:42 <thehappycolorpro> imma try that now
16:28:45 <thehappycolorpro> is it safe
16:29:02 <EvanR> as long as youre not running the ghc version that responds to errors by deleting your source code
16:29:30 <EvanR> a feature i want restored as an option
16:29:32 <jle`> interestingly enough, contradictory equations in ocaml are source files are allowed, since ocaml source files are sugar for nested let in's
16:29:42 <EvanR> o_O
16:30:13 <jle`> `x = 3\nx = 4` in an ocaml source file is sugar for let x = 3 in (let x = 4 in ... )
16:31:22 <thehappycolorpro> hmm thats weird when i ran my .hs file it took the first one as priority
16:31:25 <jle`> oh sorry, i'm rusty, you have to 'let' top-level bindings, so it'd really be 'let x = 3\nlet x = 4'
16:31:33 <thehappycolorpro> well i just put
16:32:01 <thehappycolorpro> triple x = x * 3       triple x = x / 3
16:32:15 <jle`> thehappycolorpro: ah that's actually special syntax for defining a function over multiple cases
16:32:26 <jle`> you're really defining one function, triple, which has two branches
16:32:53 <jle`> you might have seen 'not' defined as:
16:32:55 <jle`> @src not
16:32:55 <lambdabot> not True  = False
16:32:55 <lambdabot> not False = True
16:33:24 <jle`> in Haskell there's a style of defining functions where you split a function definition over multiple lines, each one handling a different case of input
16:33:52 <jle`> so if i did 'not True', that'd be False, and if i did 'not False', that'd be True
16:34:00 <jle`> @src (&&)
16:34:00 <lambdabot> True  && x = x
16:34:00 <lambdabot> False && _ = False
16:34:25 <jle`> which means `True && x` would just be `x`, and `False && anything` would just be `False`.
16:43:52 <dmwit> hololeap: Sure, why not? Just insert the same `IntSet` at multiple keys in the `IntMap`.
16:44:21 <dmwit> hololeap: Of course, it's up to you to make sure that you re-insert at all the appropriate duplicated keys if you ever need to update the `IntSet`.
16:49:15 <Costar> Hi
16:49:28 <dmwit> hololeap: e.g. try `let s = trace "hi!" IntSet.empty; m = IntMap.fromList [(0, s), (1, s), (2, s)] in [m!0, m!1, m!2]`. You should see `hi!` printed only once, corresponding to the fact that `s` is shared across keys 0, 1, and 2.
16:54:18 <codedmart> I always forget how `scientific -> integer`
16:54:39 <thehappycolorpro> ok i am done for today. i will return on sunday, thanks for all your help
16:55:13 <glguy> codedmart: perhaps: truncate, ceiling, floor
16:55:40 <codedmart> Ah duh
16:55:44 <codedmart> Thanks glguy
16:56:51 <koala_man> haha, I just met Don Stewart and gave him a beer. so starstruck :D
17:03:47 <phadej> codedmart: https://hackage.haskell.org/package/scientific-0.3.5.2/docs/Data-Scientific.html#v:toBoundedInteger
17:03:59 <phadej> if scientific is from untrusted source
17:05:20 <phadej> limit = maxExpt = 364 -- | The same limit as in GHC.Float.
19:00:20 <ppp886v> qq
19:00:25 <ppp886v> whois live?
19:01:44 <ppp886v> whois live
19:02:37 <ppp886v> heey
19:09:17 <ppp886v> rus est?
19:09:45 <ppp886v> who is live?
19:19:04 <Zz3null> qq
19:31:12 <ReinH> phadej: scientific the package?
19:38:11 <sgronblo> Is there some sort of flag you can apply when running or building a Haskell program that would prioritize debuggability over performance? So that you would get more callstacks for errors etc.
19:43:50 <iqubic> Hello Haskellers.
19:46:00 <iqubic> What's going on in here today?
19:47:45 <pragmaticmonkey> Hello
19:48:01 <pragmaticmonkey> Is glguy still around? otherwise I have some questions.
19:49:22 --- mode: ChanServ set +o geekosaur
19:49:34 <geekosaur> yes, mods cease to exist when you hope them to do so after being generally insulting\
19:49:37 <geekosaur> any more questions?
19:54:57 <pragmaticmonkey> geekosaur: Well, yes sir. I was never insulting. They insisted that the whole idea of a Haskell Job is not a discussion about Haskell.
19:55:11 <geekosaur> no, they did not
19:55:18 <pragmaticmonkey> Which I find a lil silly, assuming we are talking about doing software development professionally.
19:55:25 <pragmaticmonkey> Anyways, no use beating a dead horse.
19:55:27 <pragmaticmonkey> How are you?
19:55:32 <geekosaur> I was reading at the time, I reviewed them in moderator discussion afterward
19:55:50 <geekosaur> do not bother pretending
19:56:10 <pragmaticmonkey> Come on. I want to learn Haskell and make money.
19:56:21 <geekosaur> and then you have come back multiple times *always* starting with the anti-glguy crap. which pretty much proves the point
19:57:11 <pragmaticmonkey> I just ask if he is around, so I can just leave.
19:57:23 <pragmaticmonkey> No need to talk if someone is going to block you halfway without any good reason.
20:01:16 --- mode: ChanServ set +o dibblego
20:01:20 <monochrom> pragmaticmonkey: Asking about jobs is fine. Your provocative, challenge-the-channel attitude "if ___ is so great, why aren't ___" is just cause for banning.
20:01:20 --- kick: pragmaticmonkey was kicked by dibblego (no thanks)
20:01:43 --- mode: geekosaur set -o geekosaur
20:02:51 --- mode: ChanServ set -o dibblego
20:04:25 <pragmaticmonkey> So I have no idea what you said before kicking me. It hurts.
20:04:43 <monochrom> OK, I'll repeat it.
20:04:44 <jle`> you can check the channel logs in the links in the topic :)
20:04:50 <monochrom> Asking about jobs is fine. Your provocative, challenge-the-channel attitude "if ___ is so great, why aren't ___" is just cause for banning.
20:04:55 <pragmaticmonkey> it is late by a day :(
20:05:12 <pragmaticmonkey> The logs, that is.
20:05:24 <jle`> http://tunes.org/~nef/logs/haskell/18.01.19
20:05:35 <pragmaticmonkey> monochrom: Today is the 20th, isn't it?
20:05:52 <pragmaticmonkey> Oh, not on the otherside of the world.
20:05:54 <pragmaticmonkey> I see.
20:06:07 <jle`> check the link :)
20:06:28 <pragmaticmonkey> Yeah, figured, here, it is 20th. Date and Time is kinda funny.
20:07:16 <pragmaticmonkey> monochrom: You know what? our local hipster cafe is called Monochrome. It has excellent coffee.
20:07:57 <pragmaticmonkey> But on your point, fair enough, I was actually trying to wrap my head around why primitive languages like Go are so widespread but much better alternatives are not?
20:12:14 <ReinH> pragmaticmonkey: have we interacted before?
20:13:06 <pragmaticmonkey> Not that I can recall. I am afraid.
20:14:01 <ReinH> Did you tell me the definition of the word "this" when I asked you what the word "this" referred to?
20:15:05 <pragmaticmonkey> Unlikely. I have no memory of such conversation.
20:15:59 <ReinH> Because someone who did that then said that I was bullying them and that they were afraid, so I am suspicious.
20:17:02 <pragmaticmonkey> That is one hell of a plot twist. From This to Bullying.
20:17:07 <dmwit> Perhaps we can turn the conversation to Haskell at this time.
20:18:24 <ReinH> It was an... unproductive conversation. But I agree with dmwit.
20:19:11 <lizzin> i have a list of 30 elements and i would like to iterate over it in groups of 3. what would be the most concise way to 'take' by groups of 3 at a time?
20:19:24 <dmwit> :t chunksOf
20:19:27 <lambdabot> Int -> [e] -> [[e]]
20:19:28 <kadoban> lizzin: chunksOf from the 'split' package
20:19:43 <dmwit> Or, depending on what you want...
20:20:03 <dmwit> :t \xs -> zipWith (flip const) (drop 3 xs) (take 3 <$> tails xs)
20:20:04 <lizzin> just what i need. thanks
20:20:06 <lambdabot> [a] -> [[a]]
20:20:15 <lizzin> ...chunksOf
20:20:39 <lizzin> i see how those other work too. soo many options. i love it
20:20:47 <MarcelineVQ> bonus points, try out chunksOf to see how it works then write it yourself
20:23:01 <ReinH> :t splitAt
20:23:04 <lambdabot> Int -> [a] -> ([a], [a])
20:23:08 <ReinH> Free hint.
20:23:17 <pragmaticmonkey> :t splitN
20:23:20 <lambdabot> error:
20:23:20 <lambdabot>     • Variable not in scope: splitN
20:23:20 <lambdabot>     • Perhaps you meant one of these:
20:27:24 <jle`> :t evalState . sequence . repeat . state . splitAt 3 $ [1..]
20:27:26 <lambdabot> error:
20:27:26 <lambdabot>     • Couldn't match type ‘([Integer], [Integer])’ with ‘s -> (a, s)’
20:27:26 <lambdabot>       Expected type: [Integer] -> s -> (a, s)
20:27:42 <Zz3null> est russkie?
20:27:50 <jle`> :t evalState (sequence . repeat . state $ splitAt 3) [1..]
20:27:53 <lambdabot> (Enum a, Num a) => [[a]]
20:27:59 <jle`> > evalState (sequence . repeat . state $ splitAt 3) [1..]
20:28:03 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
20:29:30 <jle`> if only we had repeatM
20:31:04 <jle`> closest thing we have is probably 'many'
20:37:16 <iqubic> What would repeatM_ do?
20:38:17 <jle`> repeatM_ is just 'forever'
20:51:33 <ReinH> jle`: sequence . repeat is pretty nice
20:55:18 <dmwit> > unfoldr (\xs -> guard (not (null xs)) >> return (splitAt 3 xs)) [1..]
20:55:22 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
20:55:36 <dmwit> But mine works on finite lists. =P
22:57:06 <jle`> dmwit: s/finite/boring
23:16:52 <chocopuff> pic
23:17:03 <chocopuff> whoops accident! mbad
