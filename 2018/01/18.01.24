00:00:00 <jle`> noobi: you could foldMap and wrap them all in Sum's to let them do their trick
00:00:05 <cocreature> > read "1" :: Sum Int
00:00:09 <lambdabot>  Sum {getSum = *Exception: Prelude.read: no parse
00:00:09 <MarcelineVQ> jle`: what is happening there :X
00:00:10 <jle`> > foldMap (Sum . read) ["1","2","3"]
00:00:15 <lambdabot>  Sum {getSum = 6}
00:00:18 <jle`> > foldMap (Product . read) ["1","2","3"]
00:00:25 <lambdabot>  mueval-core: Time limit exceeded
00:00:28 <jle`> oops
00:00:31 <jle`> > foldMap (Product . read) ["1","2","3"]
00:00:37 <lambdabot>  mueval-core: Time limit exceeded
00:00:49 <jle`> did i break lambdabot
00:00:54 <jle`> > foldMap (Product . read) ["1","2","3"] :: Product Integer
00:00:58 <lambdabot>  Product {getProduct = 6}
00:01:09 <jle`> maybe a bad example because their sum and product are the same
00:01:38 <jle`> `getX . foldMap (X . f)` is actually a pretty common pattern
00:01:44 <jle`> sum = getSum . foldMap Sum
00:01:46 <noobi> ah ok. Just to clarify. The read function can't create the Sum directly because there isn't a read instance for it right?
00:01:49 <jle`> product = getProduct . foldMap Product
00:02:07 <jle`> noobi: there is a read instance for (Sum Int), but it only parses strings of the form "Sum { getSum = 6 }" etc.
00:02:15 <jle`> not "6"
00:02:28 <jle`> > read "Sum { getSum = 6 }" :: Sum Int
00:02:31 <lambdabot>  Sum {getSum = 6}
00:02:38 <jle`> > read "6" :: Sum Int
00:02:42 <lambdabot>  Sum {getSum = *Exception: Prelude.read: no parse
00:03:08 <jle`> it's kind of weird how laziness interacts with the show instance like that
00:03:19 <jle`> when it's a newtype wrapper
00:03:25 <noobi> gotcha. thank you.
00:03:54 <jle`> @let showSum (Sum x) = "Sum { getSum = " ++ show x ++ "}"
00:03:59 <lambdabot>  Defined.
00:04:14 <jle`> > showSum (read "6" :: Sum Integer)
00:04:19 <lambdabot>  "Sum { getSum = *Exception: Prelude.read: no parse
00:04:50 <jle`> > showSum undefined
00:04:56 <lambdabot>  "Sum { getSum = *Exception: Prelude.undefined
00:05:32 <jle`> oh i suppose if Sum were 'data' and not 'newtype' that would throw an exception before starting outputting the string
00:06:00 <jle`> neat
00:11:51 <cycle337> typetetris: hello, I couldn't find haskell exchange 2017 keynote, tried all sorts on youtube ... do you have a link ?
00:12:31 <quchen> cycle337: https://skillsmatter.com/conferences/8522-haskell-exchange-2017#skillscasts
00:12:55 <cycle337> oh great thanks quchen
00:13:22 <quchen> cycle337: For some reason Skills Matter wants you to register a dummy account to view their videos
00:13:38 <cycle337> ah ok
00:14:10 <typetetris> but otherwise it is free
00:14:24 <quchen> Yes
00:14:30 <cycle337> oh beautiful stuff there
00:14:38 <cycle337> will watch every single clip
00:14:41 <cycle337> thanks guys
00:14:42 <typetetris> And haskell exchange was great! I can just recommend attending it, if it is feasable for you.
00:14:44 <quchen> The conference itself is great, but quite expensive
00:14:59 <quchen> Around 500 GBP
00:15:05 <cycle337> i was thinking I had to choose between lambda world and haskell exchange
00:15:16 <cycle337> this year
00:15:18 <typetetris> not at all, I spend 150 GBP for my haskell exchange 2018 ticket.
00:15:24 <quchen> And London is a nice city to visit
00:15:29 <quchen> Sure, if you book super early
00:15:54 <quchen> But even then it’s out of reach for most students and enthusiasts, keeping in mind that hotels in London also come at a premium
00:16:14 <typetetris> airbnb helped with that
00:16:25 <typetetris> Was quite interesting though.
00:16:33 <quchen> Did it? Haven’t used it in London yet
00:16:38 <cycle337> i would also have used airbnb
00:17:11 <cycle337> i also know about a couple of hostels there that are very cheap but you know, get in get out sorts
00:17:34 <typetetris> off for work now
00:17:34 <cycle337> there's one at elisabeth town
00:17:45 <cycle337> ok typetetris have a great day
00:19:22 <cycle337> that wasn't lazy was it ? https://usercontent.irccloud-cdn.com/file/ZDycZkh1/image.png
00:19:33 <cycle337> look at how many references
00:19:48 <cycle337> i'm on the wrong side of wikipedia again :))
00:23:06 <amalloy> i hadn't thought before about attending a haskell conference, but since you guys mention i am sorta interested. i see haskell exchange; are there any other good ones?
00:23:43 <Darwin226> Anyone know what's blocking deriving Generic for types like `data T = T { forall a b. a -> b }`? Is it just impredicative types?
00:25:50 <ertes-w> helo
00:26:06 <quchen> Why is it called *Lambda* Calculus? Why did Church choose λ for functions?
00:26:46 <quchen> amalloy: ZuriHac is also great, but more of a Hackathon with talks than a conference
00:27:05 <quchen> …and it’s free
00:27:44 <mauke> âa
00:27:47 <mauke> hat calculus
00:27:50 <[exa]> quchen: iirc church's dissertation talks about that
00:28:05 <amalloy> well, for both of those the main cost is getting across the ocean
00:28:11 <amalloy> rather than the conference fee
00:30:26 <quchen> amalloy: Well, if you want to attend only one of them, you’ll have a hard choice.
00:30:45 <quchen> Haskell Exchange is two days full of talks and fairly organized.
00:31:14 <quchen> ZuriHac is maybe 6 talks total, and lots of time to talk to other Haskellers on the lawn, hack on projects, etc.
00:31:26 <quchen> Plus the area is beautiful :-)
00:33:19 <amalloy> quchen: thanks for the suggestion
00:44:12 <siwica> What is the reason that there is a typeclass for a monoid in the standard library, yet no typeclasses for half-groups, groups, commutative groups, ...
00:44:15 <siwica> ?
00:44:35 <siwica> What makes Monoid "special" enough to be part of the standard library?
00:45:12 <ventonegro> Ubiquity
00:46:44 <siwica> So it just happens that monoid structures occur far more frequently in computing than e.g. (half-)groups? Is this backed up by some research?
00:47:31 <tdammers> part of it is just historical accident
00:47:51 <tdammers> similar to how the Num typeclass is still a thing
00:49:23 <merijn> siwica:"backed by research" <- probably not, but as anecdotal evidence, I use monoid *all* the time, I've never wanted half-groups, groups or commutative groups
00:49:47 <siwica> So if people would redo it from scratch we would actually have a hierarchy: e.g. magma > half-group > monoid > group > abelian group?
00:49:55 <merijn> Doubt it
00:50:02 <merijn> THat adds a shit ton of work for no clear gain
00:51:00 <siwica> Ok. Maybe I am just not an experienced anough programmer to appreciate the frequent occurence of monoids.
00:51:42 <merijn> siwica: Or maybe you're too much of an experienced mathematician to overestimate the use of the others ;)
00:51:55 <ventonegro> siwica: http://ertes.eu/tutorial/config-monoids.html
00:52:02 <MarcelineVQ> semigroup is nice when you don't have an obvious identity
00:52:13 <merijn> MarcelineVQ: We're already fixing semigroup, though :)
00:52:34 <MarcelineVQ> but if one were to add the rest I really hope it would come along with automatic class deriving if that were to happen, so you don't have to writer a bunch of instance heads
00:52:51 <ventonegro> siwica: https://skillsmatter.com/skillscasts/10522-keynote-a-monoid-for-all-seasons
00:53:33 <ventonegro> siwica: https://pdfs.semanticscholar.org/d9a0/1bb931cc57584bae5ec10ee82942e7c9a215.pdf
00:54:16 <siwica> Yeah, somehow I'd like to map as many algebraic structures to typeclass hierarchies as possible. That is for purely aesthetic reasons though :D
00:55:12 <siwica> MarcelineVQ: Yeah, that would be cool! Is that something that is work in progress?
00:57:30 <MarcelineVQ> I'm sure it's been kicked around, I recall reading conversations on it, though I've no links.
00:57:34 <siwica> ventonegro: Thanks for the links!
00:57:41 <ventonegro> siwica: sure
00:57:57 <siwica> Ok, I will do some reading
00:58:48 <quchen> siwica: Groups are fairly rare in programming in my experience
00:59:14 <quchen> From a practical point of view, semigroups and monoids are all over the place, while having inverses is rare
00:59:23 <ania123> is here anyone from russia?
00:59:25 <MarcelineVQ> to be clearer what I'm referring to is that when you have somethnig like  instance Monad MyType where ....    you could potentially say something like,  instance Monad MyType where .... implements (Applicative, Functor)  and avoid writing  instance Applicative MyType where pure = return; <*> = ap   etc etc
00:59:31 <quchen> We tend to combine more things than we cancel them out :-)
00:59:46 <quchen> …is not a good English sentence but I hope you get my point.
01:00:43 <siwica> MarcelineVQ: Yeah, I understood that!
01:01:46 <siwica> quchen: Yeah :D
01:05:16 <MarcelineVQ> siwica: https://ghc.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances
01:06:11 <MarcelineVQ> not sure if that's quite what I was suggesting, haven't looked too close, but it sounded right hehe
01:07:08 <MarcelineVQ> looks like it
01:26:06 <merijn> <3 Haskell refactoring
01:27:09 <bartavelle> true dat
01:27:15 <merijn> This is so much easier than the accompanying C++ I had to refactor
01:28:17 <tdammers> and C++ is still orders of magnitude easier to refactor than, say, Python
01:30:13 <merijn> tdammers: Lots of work, though :(
01:33:28 <bartavelle> refactoring python is, in some cases, very little work
01:33:37 <bartavelle> it is having the code working after that that is a lot of work ;)
01:33:42 <merijn> bartavelle: You just don't know when it's done :p
01:34:13 <bartavelle> on the other hand, my python is horrible, so that might not help
01:35:45 <carbolymer> in python you're forced to rely on tests coverage when refactoring
01:36:34 <carbolymer> if not... may the god have mercy upon your soul :D
01:36:50 <merijn> "lol, tests"
01:36:56 <carbolymer> ;d
01:37:37 <carbolymer> I HAVE SECURE TYPE SYSTEM IN HASKAL, WHY WOULD I WANT TESTS?????///
01:37:53 <merijn> carbolymer: As if I have tests for my C++ or Python >.>
01:38:01 <carbolymer> :D
01:38:14 <merijn> Unrelatedly: How the fuck did I live before streaming libraries like pipes and conduits?
01:38:42 <merijn> What a savage and ridiculous world that was
01:38:47 <carbolymer> merijn, interesting
01:38:59 <carbolymer> merijn, got a 5 min intro tutorial into them maybe?
01:39:36 <merijn> carbolymer: "I want to process 5 million (or whatever) items one a time, potentially loaded from disk, network, whatever, but don't wanna get them all in memory"
01:41:35 <merijn> carbolymer: Basically they allow you to stream items "element wise" down a pipeline of transformations. So, suppose you have a huge file that consists of many small records you can just stream fixed size chunks of input to a parser (just some regular attoparsec/binary parser you wrote) that immediately outputs each record as parsing completes and then process the result
01:42:22 <lonokhov> tdammers: I've rewritten some code from python into c++ and it was great success. Too bad can't use haskell (or rust) there.
01:42:39 <merijn> carbolymer: So "process a stream of data in constant memory" goes from "hard and complicated task" to "lol, lemme just throw in a few library calls and get on with my life"
01:45:17 <carbolymer> merijn, interesting, thx
01:46:01 <carbolymer> merijn, so it's like a discrete approach to RFP (if it can even be described that way)?
01:46:22 <merijn> carbolymer: Not really
01:46:30 <merijn> carbolymer: Assuming you meant FRP
01:46:39 <carbolymer> yep
01:47:07 <merijn> carbolymer: FRP often has many different "streams" of input, these only one
01:47:40 <merijn> carbolymer: Think of it more as "composing lots of 'mapM' over a lazy list, with more control over resource usage"
01:49:08 <merijn> I can't quickly find a good intro, though. Maybe the Pipes Tutorial works, but that's a bit specific to Pipes
01:49:59 <merijn> carbolymer: Or just mix the pipes and conduit intros: https://github.com/snoyberg/conduit#readme https://hackage.haskell.org/package/pipes-4.3.7/docs/Pipes-Tutorial.html
01:53:06 <carbolymer> merijn, that will do, thanks a lot!
01:58:55 <ania123> can someone help me to get this paper: https://elibrary.ru/item.asp?id=25303771
02:01:37 <padre_angolano> ania123: doesn't look haskell-related :-)
02:01:56 <ania123> right, but I need help :)
02:02:09 <padre_angolano> ania123: it says you can downloaded it if you register
02:02:21 <ania123> they ask to pay
02:02:24 <padre_angolano> ah
02:02:26 <ania123> for registration
02:02:28 <ania123> "_
02:02:30 <ania123> :)
02:02:35 <padre_angolano> I see
02:03:23 <Cooler> is this the channel for compiler theory?
02:03:27 <Cooler> Programming languages which permit a function to return a function as its
02:03:28 <Cooler>    result cannot be implemented with a stack-based storage allocation scheme
02:03:28 <Cooler>    for activation records
02:03:46 <Cooler> is that true? doesn't sound right, why can't i just return a function pointer?
02:04:05 <Cooler> maybe i should ask in #asm
02:04:16 <merijn> Cooler: Generally function pointers are static, which means you can't capture a closure with them
02:04:19 <[exa]> Cooler: assembly guys will just tell you a loud "no" :]
02:04:28 <merijn> Cooler: Which you often need/want when returning functions
02:05:29 <[exa]> Cooler: btw the problem with functions is that they usually pack scopes (so you'd need a pointer with some environment), and the scopes can recursively pack the same function (so in effect the environments can be infinite). So it's a bit unwieldy for stack
02:06:00 <[exa]> Cooler: but if the evaluation is eager, stack-like structures are perfectly valid for that
02:06:37 <Cooler> merijn, well the claim is that you can't return functions, doesn't mention closure
02:07:34 <amosbird> hello, can I install shellcheck without installing a bunch of haskell dependencies ?
02:07:43 <amosbird> a static binary would be greater
02:07:47 <[exa]> Cooler: also, there's a lot of compiler techniques that can efficiently compile this out, see defunctionalization (O. Danvy's papers) and I'm working on one as well
02:07:56 <merijn> amosbird: Lemme guess: Arch?
02:08:01 <amosbird> yup
02:08:04 <[exa]> :]
02:08:21 <merijn> amosbird: The answer is "you can, but the Arch maintainers are fundamentally opposed to packaging haskell that way"
02:08:29 <amosbird> um
02:08:35 <amosbird> so what should I do
02:09:10 <[exa]> amosbird: managing all haskell packages using stack is usually recommended
02:09:11 <MarcelineVQ> grab shellcheck-static off the aur
02:09:19 <amosbird> MarcelineVQ: thanks!
02:09:29 <merijn> amosbird: You have a few options: 1) give up and just install via package manager and accepting a ton of dependencies being installed, 2) build shellcheck yourself, 3) whine at the arch maintainers, 4) give up?
02:10:14 <Cooler> [exa], couldn't the compiler generate a custom struct data structure for the function and return that along with the function pointer?
02:10:19 <MarcelineVQ> You don't always gotta go the hard route my boys
02:10:23 <Cooler> to return the context as well
02:10:25 <merijn> amosbird: Basically, traditionally GHC has always build static executables, which means no one cares about the number of dependencies. But Arch has decided "everything has to be dynamic", so now people suddenly see 100s of haskell dependencies
02:10:32 <merijn> MarcelineVQ: I have no clue what aur is, so :)
02:10:44 <[exa]> Cooler: it's not as easy as it sounds but yes it can
02:10:47 <amosbird> merijn: good to know :)
02:11:19 <[exa]> Cooler: in fact I'm waiting for the paper to get published now (it should be out in a week)
02:11:31 <merijn> amosbird: Especially since you can't really update these dynamic libraries independently of the programs anyway, so the common argument of "dynamic libs make updating easier/safe space" isn't even true :)
02:11:50 <amosbird> merijn: so, what distro do you use :)
02:11:55 <Cooler> [exa], so what is being done currently to implement such languages?
02:11:58 <padre_angolano> ania123: I registered for free and downloaded it for you, but the whole article is only 2 pages: elibrary_25303771_89422585.pdf
02:12:01 <merijn> amosbird: OSX :p
02:12:07 <amosbird> ...
02:12:10 <[exa]> Cooler: nothing, I'm implementing one. :D
02:12:17 <[exa]> (for that reason)
02:12:23 <padre_angolano> ania123: http://jail.mp2.macomnet.net/elibrary_25303771_89422585.pdf
02:12:38 <Cooler> what? javascript, haskell and lots of others can return functions with closures
02:12:51 <merijn> amosbird: I only know all of this because there's so many arch users running into problems :p
02:13:02 <merijn> Cooler: GHC haskell doesn't use a function call stack at all, though
02:13:08 <[exa]> Cooler: neither javascript nor haskell has a "stack" in traditional sense
02:13:08 <amosbird> haha
02:13:11 <amosbird> that's ironic
02:13:57 <ania123> padre_angolano: thank you very much...
02:20:47 <merijn> > maxBound :: NominalDiffTime
02:20:51 <lambdabot>  error:
02:20:51 <lambdabot>      Not in scope: type constructor or class ‘NominalDiffTime’
02:21:19 <merijn> bleh, not bounded anyway
02:21:36 <merijn> I guess I'll have to set "infinite time" via "type in very large number"
02:43:47 <insanitea> > maxBound :: Data.Time.NominalDiffTime
02:43:52 <lambdabot>  error:
02:43:52 <lambdabot>      Not in scope: type constructor or class ‘Data.Time.NominalDiffTime’
02:43:52 <lambdabot>      No module named ‘Data.Time’ is imported.
02:45:14 <insanitea> merijn: `Maybe NominalDiffTime`?
02:45:34 <merijn> insanitea: I don't control the API
02:46:20 <insanitea> ou :-(
02:51:15 <slevin> quick question which i found difficult to google: what use of surrounding operators (or literals) with '<' and '>', like `parseExpr = parseString <|> parseNumber`?
02:51:41 <slevin> *what is the use of
02:52:06 <merijn> <|> isn't an operator surrounded by <>, that IS the entire operator. It's commonly done to differentiate from similar but different operators
02:52:17 <merijn> :t (<$>)
02:52:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:52:19 <merijn> :t ($)
02:52:21 <lambdabot> (a -> b) -> a -> b
02:52:29 <[exa]> slevin: usually  it's a variant of the operator supposed to work on Functors, Applicatives etc.
02:52:32 <merijn> slevin: Consider how those look quite alike
02:52:41 <[exa]> slevin: <|> is "or another Alternative"
02:52:50 <whatsupboy> Guys any one checked these videos https://www.youtube.com/watch?v=yvwaxYro4FU
02:53:09 <merijn> slevin: As for <|> it matches the other Applicativ operators of <$> and <*> and '|' is a reserved symbol, so can't be used
02:53:14 <whatsupboy> are they outdated ?? I meant shooted before 2010 ?
02:53:31 <whatsupboy> I need such haskell classroom videos any one have them all ?
02:53:37 <merijn> slevin: So <|> works around | not being allowed and matches other applicative operators
02:54:16 <merijn> slevin: | being a desirable choice as <|> (for parsers, anyway) has the meaning that | does in BNF
02:54:35 <[exa]> whatsupboy: doesn't seem outdated, but I'm not a fan of that classroom approach :D
02:54:56 <slevin> thanks everybody! very helpful as always
02:55:50 <whatsupboy> [exa]:  I never had such quality education so I am fan and why arnt you any particuar reason ?? I cant find all those videos :(
02:55:59 <Cale> whatsupboy: http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung
02:56:05 <Cale> I *think* this is the one?
02:57:33 <[exa]> whatsupboy: I prefer a bit more action and less writing on the lectures :] but that's nitpicking from me, the guy's doing a good job
02:58:00 <Cale> oh, maybe not
02:58:15 <Cale> Looks like maybe the same classroom though?
02:58:23 <mxf> a
02:58:57 <whatsupboy> and 2005 is very outdated I think Its better to have anything after 2010 ?
02:59:36 <Cale> For the stuff they're covering, it shouldn't be bad at all, but yeah.
03:00:34 <Cale> Oh, it actually is the same course -- downloaded the 9th lecture and it's the same :)
03:01:10 <Cale> So, if I recall correctly, that course mostly covers properties of the language which would not really have changed since its inception.
03:02:14 <Cale> But it's been quite a long time since I watched the videos :)
03:03:45 <whatsupboy> Okay I think no harm in checking them to me, so that the url I found the same from haskell wiki page and my video still downloading
03:05:17 <Cale> They take a fairly mathematical approach to a lot of things, and it gets quite pedantic, if you're just looking to learn the language on a surface level, there might be better options, but I remember liking the course overall.
03:09:19 <Cale> (a lot of it would be quite relevant if you were writing a compiler for Haskell)
03:10:18 <whatsupboy> Cale:  I like that word "mathematical approach"
03:10:39 <whatsupboy> I beleive in "mathematical approach" to anything
03:11:58 <baboum> Cale: Hello, I missed the start of the conversation, which courses are you referring to?
03:12:51 <whatsupboy> http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung
03:12:57 <whatsupboy> baboum:  ^^
03:13:18 <baboum> whatsupboy: thank you!
03:16:45 <merijn> I wish there was a more convenient way of doing "Show a => a -> Text" then "T.pack . show"
03:21:25 <phadej> merijn: http://hackage.haskell.org/package/text-show
03:22:44 <merijn> phadej: That seems to have a rather ridiculous dependency footprint, though :\
03:24:15 <wklm> hey Everyone :)
03:24:16 <wklm> I'm reading this intro to programming with algebraic structures. https://fsharpforfunandprofit.com/posts/monoids-part2/
03:24:19 <wklm> It's said that the word count monoid ( `(String, +)` ) from the end of the post is homomorphic, this is clear to me.
03:24:25 <wklm> My question is: is it isomorphic (bijektiv homomorphic) in the same time? How do you define an isomorphic monoid?
03:25:59 <mpickering> Does anyone know what the future of "cabal build" is? It works very well for nix where everything is installed globally, I wonder if new-build can made to also play nicely
03:26:01 <phadej> merijn: does it? https://imgur.com/a/9tg9V
03:26:23 <Taneb> wklm: do you mean "Is wordCount a monoid isomorphism"? wordCount is described as a monoid homomorphism
03:26:35 <[exa]> wklm: can you reconstruct the string back from it's word count?
03:26:43 <Taneb> ("homomorphic monoid" doesn't really make sense)
03:26:58 <phadej> mpickering: it will be gone. But there's cabal act-as-setup
03:27:08 <merijn> phadej: That one is lacking a lot of dependencies listed on hackage
03:27:31 <mpickering> What is "cabal act-as-setup"?
03:27:55 <[exa]> Taneb: (I guess he means something like factormonoid, if I borrow factor* name from factorgroups)
03:28:11 <[exa]> Taneb: (not that it would be correct as well)
03:29:11 <phadej> merijn: it doesn't list boot-libraries (i.e. what's bundled with ghc)
03:30:02 <Cale> wklm: "homomorphic" isn't a very commonly discussed adjective, especially when it comes to monoids (any two monoids have at least one homomorphism between them -- there's always the one which sends everything to the identity element)
03:30:09 <phadej> merijn: now there's one with "builtins" too
03:30:34 <Cale> wklm: But also, these would be properties of a *pair* of monoids. You say that one monoid is isomorphic to another, when there exists an isomorphism between them.
03:32:58 <Cale> wklm: That is, if you have two monoids, say (A,*,e), and (B,+.e'), they are isomorphic if there exist functions f: A -> B and g: B -> A such that f and g are both homomorphisms, and they compose to the identity function in either direction.
03:34:51 <merijn> hmmm, I keep wanting "Monad m => (a, m b) -> m (a, b)" I recall seeing that somewhere, but I forget where
03:35:22 <Cale> That usually goes by the name of 'strength'
03:35:44 <merijn> Cale: I know, but it doesn't seem to be defined anywhere convenient
03:36:20 <Cale> Yeah. I don't know if it's anywhere particularly good. Usually I would just write the fmap.
03:37:14 <merijn> Cale: Yeah, but writing it out always takes more mental effort than it should for me >.>
03:37:20 <Cale> Perhaps somewhere amongst Ed's packages there is something which specialises that way :)
03:37:49 <Cale> (but doubtless finding it requires more mental effort than writing the lambda)
03:37:56 <wklm>  [exa]: Naturally I'm not, but isn't the inversability a requirement for groups? (not monoids) | Cale: Many thanks for this awesome explanation!
03:38:09 <phadej> :t uncurry (fmap . (,))
03:38:11 <lambdabot> Functor f => (a1, f a2) -> f (a1, a2)
03:38:19 <phadej> -- codegolf
03:38:23 <Cale> wklm: Oh, I was in the middle of typing out all the requirements if you'd like them listed :)
03:38:53 <Cale> So, first of all we need that f: A -> B is a homomorphism, so we want f(e) = e' and for all a and a' in A, we have f(a * a') = f(a) + f(a')
03:39:03 <wklm> wow, so there's more :) Sure, I'd love to
03:39:08 <Cale> analogously, we need g(e') = e and for all b and b' in B, g(b+b') = g(b)*g(b')
03:39:41 <Cale> and then we need for every a in A, that g(f(a)) = a, and for every b in B, that f(g(b)) = b
03:40:18 <Cale> and when such an f and g exist, we say that A and B are isomorphic, and we refer to f and g as isomorphisms
03:40:41 <[exa]> wklm: the inversibility is on the homomorphism -- bijective homomorphism on any 2 algebraic objects is an isomorphism. Cale will probably show you better :]
03:42:18 <Cale> Usually I prefer not to involve bijectivity, but that is a consequence for algebraic structures built on sets, because our homomorphisms are set functions (satisfying some additional conditions), and the fact that they're inverse functions will mean that there's an isomorphism of *sets* (which is a bijection)
03:42:30 <whatsupboy> Cale: https://video.fsmpi.rwth-aachen.de/12ss-funkprog  I found same professor 2012 videos and I watched last 15 mins of last video to check if its complete course or not and he says next is logic programming in next semester and I have the doubt many programmers here study logic ?How I can use logic in real world ? I never had such beautifcul education :(
03:43:19 <Cale> whatsupboy: Well, as functional programmers, there's a sense in which we're applied logicians. :)
03:44:13 <Cale> whatsupboy: There's a phenomenon called the Curry-Howard correspondence which relates on the one hand types and propositions, and on the other hand, terms (of a lambda calculus) and proofs
03:45:28 <merijn> For a more in-depth (and excellent!) talk so that Cale doesn't have to write all of it out: https://www.youtube.com/watch?v=IOiZatlZtGU
03:45:32 <merijn> whatsupboy: ^^
03:46:43 <Cale> whatsupboy: For better or worse, our logics tend to be inconsistent though. General recursion allows you to define a fixed point combinator:
03:46:45 <Cale> :t fix
03:46:46 <lambdabot> (a -> a) -> a
03:47:27 <Cale> and read logically, that says for any proposition a, if a implies a, then a
03:47:42 <Cale> and from that we can conclude anything whatsoever
03:47:59 <whatsupboy> ok thank you merijn  and Cale, I will watch that youtube video now
03:48:25 <Cale> But once you start caring about not just what is true, but which proofs of it exist, and how they interact, perhaps it's not as painful as it seems to work in an inconsistent logic :)
03:48:55 <whatsupboy> logic helps a lot with AI right ?
03:49:09 <Cale> Some sorts of AI
03:49:12 <[exa]> everyone wished that it would. :]
03:50:00 <Cale> AI almost encompasses too many techniques now to really make very coherent claims about it all at once.
03:52:19 <Cale> A lot of the modern techniques don't really get much use out of logical systems directly, and instead consist of large amounts of linear algebra and tree searches and nonlinear optimisation and a variety of other stuff :)
03:54:39 <whatsupboy> ok
03:58:13 <amosbird> MarcelineVQ: hi
03:58:19 <amosbird> is there a static pacdoc too ?
03:58:23 <amosbird> pandoc*
03:58:41 <amosbird> ah
03:58:43 <amosbird> pandoc-bin
04:06:49 <[exa]> hm, is there some standard implementation for "duplicate elements in a list" ?
04:07:07 <Taneb> [exa]: what do you mean by that?
04:08:06 <[exa]> duplicatedElems [1,2,3,2,5,1] = [2,1]
04:09:22 <[exa]> I've got one hacked together by hand here, but I guess something similar should be available in the libraries. Unluckily I wasn't able to find anything
04:09:52 <[exa]> (except for Agda.Utils.List's duplicates)
04:13:17 <Taneb> Hmm, I can't think of anything like that
04:13:56 <AndreasK> At least hoogle finds only a single one in hxt when searching by type
04:14:07 <[exa]> oh nvm, rubber#haskellduck debugging worked as usual
04:14:11 <[exa]> https://hackage.haskell.org/package/Unique-0.4.7.2/docs/Data-List-Unique.html#v:repeated
04:14:23 <[exa]> Taneb: thanks anyway :]
04:15:08 <Taneb> :D
04:16:00 <jchia_> Is there a compelling use case for Data.Functor.Contravariant, where not using it makes life a lot harder?
04:21:13 <Uniaika> Lenses I guess?
04:23:02 <MarcelineVQ> amosbird: yep, but you can ask arch that https://aur.archlinux.org/packages/?O=0&K=pandoc
04:23:51 <MarcelineVQ> amosbird: I ​use  pacaur  which is what it sounds like
04:36:42 <cycle337> omg so annoyed by comic sans in slides
04:37:20 <[exa]> it will take 2 more generations before comic sans damage is gone
04:46:43 <hydraz> comic sans is great
04:47:19 <electrocat> comic sans reminds me of simon pj lectures
04:47:52 <cycle337> electrocat: that's where I spotted it just now
04:48:04 <cycle337> and I h8 it :)
05:01:39 <hydraz> cycle337: you're wrong, fyi
05:01:43 <hydraz> SPJ's slides are great
05:04:05 <cycle337> totally
05:22:47 <cycle337> https://xkcd.com/1597/
05:37:30 <srid> Folks who use vim for haskell development - should I use vim or neovim?
05:38:28 <AWizzArd> ghc nopie? What does this mean? It is the 8.2 version that Stack downloaded for me.
05:38:44 <kadoban> srid: I would do neovim
05:39:57 <srid> kadoban: what's a recommended way to configure haskell development with neovim? (i'm quite new to vim, except for familiarity with keybindings, and considering to switch away from Emacs)
05:41:20 <kadoban> srid: No idea, haha. I don't tend to use too much haskell specific. I know neovim has some support for intero, which is popular (I don't use it yet though) and I find its background hlint checking thing quite a bit less annoying on neovim than on vim myself.
05:42:31 <srid> Also, I use nix (instead of stack) .. so maybe I shouldn't be looking into intero ...
05:43:02 <kadoban> Maybe not then. I'm not sure if any of the common editor integration things handle nix well though
05:43:37 <srid> Oh I just recalled that https://github.com/jyp/dante was mentioned in the context of ghci / nix
05:44:27 <srid> Maybe I should try dante with spacemacs: https://www.reddit.com/r/haskell/comments/6nvgla/vim_and_haskell_in_2017/dkeadmr/
05:49:30 <srid> This is most relevant to me: https://www.reddit.com/r/haskell/comments/7nnfad/spacemacs_dante_nix_setup/
06:07:44 <ertes-w> srid: i'm using regular haskell-mode with nix
06:08:07 <ertes-w> caveat: it has no direct support for nix, so i'm using it with a wrapper script
06:11:02 <hexagoxel> what a foolish waste of everyone's attention (and other mental resources) this slurp thing has been and is.
06:13:02 <tdammers> hexagoxel: it has, but I got a bit of a glimpse into the emotional turmoil that's happening behind the scenes today, and eruptions like this are, I fear, inevitable and necessary
06:13:17 <ertes-w> "this slurp thing"?
06:13:34 <tdammers> https://github.com/haskell/ecosystem-proposals/pull/4 <- ertes-w
06:13:43 <ventonegro> ertes-w: You. Dont. Know?
06:14:09 <ventonegro> It's 2018's hottest topic yet
06:18:26 <Uniaika> :)
06:20:02 <ertes-w> i'm happy to report that i completely missed it, and that i have no intention to take part in it =)
06:20:05 <[exa]> the SLURP thing shows an unfortunate lack of do-oism
06:20:27 <hexagoxel> ah, and there is the mandatory call for respect. the only thing it is doing at this point is increase my cynicism. great work.
06:20:46 <[exa]> or do-ocracy, to call it better
06:21:24 <lyxia> ertes-w: I envy you so much
06:21:44 <ertes-w> my understanding of SLURP is superficial, but this seems like the kind of proposal that should have come with proof of concept code
06:21:49 <tdammers> the interesting part about it isn't what's in the thread itself, but what's going on behind the scenes to trigger this whole mess, and the stuff that causes all those panic reactions on the thread
06:21:57 <ertes-w> "here is the initial attempt, let's work on this together!"
06:22:18 <tdammers> the thread really isn't about the proposal itself
06:22:29 <ertes-w> could someone provide a one-line summary of what people are concerned about?  or is it too complicated?
06:22:37 <hexagoxel> but the things not in the thread .. are not in the thread. i have to resort to guesswork, without official sources.
06:22:50 <tdammers> hexagoxel: yes, and that's the main problem here
06:22:59 <tdammers> so much left to guesswork
06:23:06 <tdammers> and as a result, everyone goes bonkers
06:23:31 <tdammers> also, not everyone is concerned about the same things
06:24:52 <tdammers> and not everyone subscribes to the same history of events either, which is problematic
06:28:37 <ertes-w> i honestly didn't consider the hackage/stackage split a problem to begin with
06:28:52 <ertes-w> in fact i don't even consider it a *split* in that sense
06:30:39 <[exa]> well, I've stopped reading at second point in 2.Principles
06:31:06 <[exa]> 1] diversity is a good thing, 2] there should be single unambiguous namespace ...what?!
06:34:06 <kadoban> [exa]: I would imagine that they don't mean in point 1 that diversity of ambiguity of names is a good thing.
06:35:14 <hexagoxel> ertes-w: i think an important concern is not about the (technical) contents of the proposal, but about its motivation and where it is coming from. And on that part, the proposal made some rather foolish mistakes, like not even defining "fork", falsely attributing things to the "stack community", and stating that "a fork is likely" without any attribution/references.
06:35:16 <[exa]> it certainly isn't, but I think it is unavoidable unless there is single active ruling entity that makes effort to rename the packages in the consistent way
06:35:58 <hexagoxel> (it is still a sine line, right? :)
06:37:29 <hexagoxel>  /s/sine/single/
06:37:48 <ertes-w> hexagoxel: so you think it serves a political purpose?
06:42:06 <nkaretnikov> can i bridge the gap between types and values in ghc haskell like it's done here in cpp?
06:42:06 <nkaretnikov>  https://gist.github.com/nkaretnikov/51734071b9c0cfa55148bddb8526b2a9
06:43:17 <tdammers> nkaretnikov: not with vanilla haskell, at least not without tricks
06:43:23 <ertes-w> nkaretnikov: if all you need is to lift values to types and back, you need reflection
06:43:34 <ertes-w> nkaretnikov: see the 'reflection' package
06:44:02 <tdammers> nkaretnikov: there are language extensions that give you type-level integers, or you can get a crummy approximation of type-level integers using peano numbers
06:44:06 <cocreature> depends on what exactly you want. if all you want is to move information from types to values, you can use typeclasses for that
06:44:47 <tdammers> e.g. data Z = Z; data P a = P a
06:45:16 <tdammers> and then define something polymorphic to go from Z and P to integers at runtime
06:46:30 <mnoonan> tdammers: short for "psuccessor"?
06:46:38 <nkaretnikov> tdammers: i'm familiar with peano numbers: https://github.com/nkaretnikov/triangle-inequality/blob/master/src/TH.hs https://github.com/nkaretnikov/triangle-inequality/blob/master/src/Test.hs but this is too much work for my taste, i wonder if there's anything easier to use
06:46:46 <nkaretnikov> ertes-w: i'll check it out, thanks
06:47:19 <nkaretnikov> cocreature: could you provide a small example?
06:47:25 <tdammers> nkaretnikov: https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/type-level-literals.html
06:48:55 <mnoonan> nkaretnikov: "class TypeToInt a where number :: Proxy a -> Int", then use "number (Proxy :: T)" to get the number from the type
06:49:15 <cocreature> nkaretnikov: the basic idea is something like http://lpaste.net/361917
06:49:25 <cocreature> oh mnoonan beat me to it :)
06:49:42 <nkaretnikov> nice, thanks all!
06:53:54 <nkaretnikov> one more question, though. with the proxy example above, i'd need to roll out peano numbers again (or use type level lits?) because there's a unique mapping between a type and a value, correct?
06:54:08 <cocreature> yes
06:54:25 <nkaretnikov> so i'd need number (Proxy :: Succ Nil) to get 1 etc
06:54:32 <nkaretnikov> okay
06:55:19 <tdammers> yes, typeclass instances would be what gets you from types to values
06:56:07 <ocharles> Hey, does this monad transformer exist anywhere? https://gist.github.com/ocharles/cab1397182c1c76b40f20c884fc5ca93
06:56:46 <ocharles> It's like ExceptT, but the MonadError instance just proxies to an underlynig MonadThrow instance, and running the transformer sticks `try` infront of it from `MonadCatch`
06:58:37 <phadej> ocharles: I have a gut feeling that async exceptions are slight party pooper there, e.g. you don't want to catch them
06:58:53 <ocharles> phadej: even with try from safe-exceptions?
06:59:22 <ocharles> plus, the try only catches the type `e` that you're running against
06:59:43 <ocharles> so unless you specifically throw into that thread, you shouldn't have to worry about async exceptions, no?
07:00:03 <phadej> yeah, but as it's `Exception e` it can be async exception too
07:00:17 <phadej> but maybe with `safe-exceptions`'s try MonadError's laws pass
07:00:21 <phadej> s/pass/hold/
07:00:45 <ocharles> oh crap, I'm missing a key bit in that paste
07:00:49 <phadej> (I have thought about similar monad too)
07:01:22 <ocharles> phadej: ok, refresh that gist
07:02:13 <ocharles> my point is that `e` only matters when you instantiate it in `runExceptional`. Async exceptions would only matter if a) you instantiated `e` to SomeAsyncException or b) had actually thrown an async exception of type `e` into your code, but you'd have to try really hard to do that
07:02:19 <ocharles> but it does weaken the foundations
07:03:41 <phadej> yeah. I think it's good idea, and I have used something like that (wrote MonadError to something which uses exceptions)
07:03:57 <phadej> I'd try to poke edwardk with a PR to `exceptions` :)
07:04:42 <phadej> or maybe it belongs to safe-exceptions, dunno.
07:05:34 <ocharles> the ability to have typed exceptions and MonadMask is mega useful
07:05:43 <ocharles> i'll chew on this idea a bit more
07:06:43 <tmciver> Hi folks. I'm trying to use the GHC options `-F -pgmF <pre-processor>` that is described here: https://downloads.haskell.org/~ghc/master/users-guide/phases.html#options-affecting-a-haskell-pre-processor (this techique is used by hspec). I'm using this in a test application here: https://github.com/tmciver/kaletest/blob/master/src/Lib.hs. When I try building the project, I get a "Could not find module" err
07:06:49 <tmciver> or. The module that GHC is looking for is one that is a part of the `kale-discover` executable that is being used as the preprocessor. This is surprising since I was expecting to be able to specify any executable there.
07:08:09 <tmciver> If I add a dependency on kale (https://github.com/parsonsmatt/kale), the error goes away but I'd like to see if it's possible to remove the dependency.
07:09:14 <tmciver> Anyone know if the preprocessor specified with `-pgmF` is required to be a part of the project?  I assumed it just had to be on the path.
07:11:40 <srid> The preference for Haskell goes up as you become older: https://research.hackerrank.com/developer-skills/2018/
07:12:06 <Taneb> srid: I started using Haskell when I was about 15, what am I going to think of it when I retire?
07:12:15 <chocopuff> any idea why that seems to be the case?
07:12:23 <tdammers> probably because wisdom and experience correlate with age, and because short-term memory decreases as you age
07:12:36 <srid> Taneb: it will become your religion
07:12:45 <mnoonan> tdammers: dang, that's almost literally the response I was writing :)
07:12:58 <tdammers> :)
07:12:59 <mauke> h2::after { content: "\258B"; color: #32c766; animation: 1.2s blink infinite; } -- beautiful
07:13:02 <kadoban> Probably because hackerrank is weird and their results are wacky
07:13:18 <srid> It matches my own experience. A decade ago I was a Python fan boy.
07:14:11 <mnoonan> working on large codebases has hugely influenced what features in a PL seem important to me.
07:15:08 <srid> I am just finishing up on working on a large Python code-base. It largely influenced my decision to switch to Haskell.
07:16:25 <mnoonan> out of curiosity, what does "large" mean in your case?
07:16:49 <mnoonan> I noticed my company is advertising for both C++ and LISP programmers with experience on "large codebases", but..
07:17:08 <mnoonan> in the C++ posting, "large" is defined as 10 MLOC, and in the Lisp posting it is defined as 10 KLOC :)
07:24:35 <TMA> mnoonan: it's about the same size
07:24:40 <[exa]> mnoonan: 10MLOC of C++ sounds more like really bloated than just large :]
07:25:06 <mnoonan> [exa]: yes, well :)
07:25:22 <infinisil> maybe the lines are just 1000 times longer
07:25:46 <mnoonan> actually, a good chunk of it is generated from a pure functional language
07:26:04 <mauke> t e m p l a t e s
07:26:40 <mnoonan> mauke: well, more accurately, the pure language compiled to C++ *templates* already..
07:27:11 <mnoonan> you know, c++ templates, the industry standard pure functional language :)
07:27:11 <infinisil> i never worked on such a large project (10MLOC), I'd really like to have a look at it and evaluate just how much of it is glue and irrelevant stuff
07:27:50 * mauke writes a quick script to count lines in this codebase
07:28:14 <tdammers> mnoonan: I thought that was Excel
07:28:45 <kadoban> infinisil: linux kernel is probably up vaguely in that ballpark, at a guess
07:29:03 <infinisil> kadoban: isn't that mostly just drivers though?
07:29:13 <kadoban> Yes
07:29:43 <kadoban> Any codebase that big is probably going to have something like that though, some part(s) you could consider separate things if you want to.
07:30:33 <infinisil> so probably all big code bases are just so big because nobody wants to split it up in separate components?
07:30:45 <tdammers> yes, of course
07:30:52 <infinisil> hmm makes sense
07:31:04 <tdammers> or because nobody has given it enough thought to figure out where you would logically split it
07:31:12 <tdammers> which is arguably much worse
07:31:13 <kadoban> I would strongly suspect so, yeah.
07:31:29 <adamt> Hiya. Super stupid question, but I'm tired from googling. I have a string, i want to split it on '=' exacly one time. I looked at Data.List.Split, and can't find any functions that can limit the split to n parts. Data.Text has breakOn, but then the 2nd string includes the delimiter, which is kinda ugly. Please tell me I'm blind, and where I should be looking. :-)
07:31:49 <tdammers> I don't think there is any kind of problem that is intrinsically self-contained yet large enough to require more than a few thousand lines of code
07:31:52 <mnoonan> it's also cheaper, short term, to add to a ball of mud. so you have to make a careful argument that splitting is worth it, when there are no immediate benefits.
07:32:32 <mauke> ~400kloc here (this includes comments)
07:32:37 <infinisil> mnoonan: probably worth it in the long run
07:33:02 <kadoban> adamt: Just use breakOn and then drop the first thing from the second string?
07:33:05 <phadej> some definition of kmettverse/kmettosphere/acme-kmett is 200kLOC https://github.com/phadej/acme-kmett
07:33:13 <tdammers> infinisil: question is, can you afford to wait it out until the long-term investment pays off
07:33:13 <infinisil> who's got time for refactoring though lol, smash dem new files in there
07:33:17 <mnoonan> infinisil: oh, absolutely! I'm just pointing out how businesses can get themselves into a big codebase
07:33:27 <phadej> so having 1MLOC haskell codebase isn't that hard, "if you reinvent everything"
07:33:32 <mauke> > drop 1 <$> break ('=' ==) "foo=bar=baz"
07:33:33 <byorgey> adamt: that's not a stupid question.  I don't think there is any one nice library function which will do that.
07:33:37 <lambdabot>  ("foo","bar=baz")
07:33:51 <tdammers> but usually, it's a matter of using the wrong metrics as your KPI's
07:33:51 <byorgey> adamt: but you can build it out of smaller parts, like mauke did above
07:33:56 <adamt> kadoban: Yeah, but surely a fairly stanard library would do exacly that :-)
07:34:02 <phadej> (I mean it's hard, but not unachivable)
07:34:11 <mauke> > drop 1 <$> break ('=' ==) "foo"
07:34:14 <tdammers> "number of features delivered", "number of bugs fixed", "number of support calls", that kind of thing
07:34:16 <lambdabot>  ("foo","")
07:34:58 <tdammers> it's like how British aircraft mechanics during WWII would look at the fighters coming back from a battle, and reinforce all those parts that had bullet holes in them
07:35:15 <byorgey> adamt: mauke's version is a bit golfed, an easier to understand version might be    second (drop 1) (break ('=' ==) "foo=bar=baz")
07:35:16 <infinisil> I like to think that the smaller a codebase the better
07:35:23 <tdammers> until at some point they figured that that was the wrong approach, because they were only looking at the fighters that actually made it back
07:35:37 <byorgey> > second (drop 1) (break ('=' ==) "foo=bar=baz")
07:35:41 <lambdabot>  ("foo","bar=baz")
07:35:49 <adamt> byorgey: Sure, i could also split on every '=', take the head for the first and join the rest, but I'm just wondering why something like "a=b=c".split("=",1) (python) has to be this silly in Haskell. :P
07:35:51 <mauke> doesn't that pull in arrows?
07:36:26 <byorgey> adamt: it's a conspiracy.
07:36:37 <phadej> :t second
07:36:39 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
07:36:49 <adamt> I could also search for the first '=', then use splitAt. Plenty of options :P
07:36:54 <byorgey> adamt: there are also lots of things that are easy to do in Haskell but silly in Python.
07:37:18 <phadej> hmm... so not second :: Bifunctor p => (b -> c) -> p a b -> p a c
07:37:42 <adamt> Yeah i know, i used to do quite a bit of haskell years ago, but, alas, my knowledge has been GC'ed. I like haskell, no need to convince me about it. :-)
07:37:46 <byorgey> adamt: probably the real reason is that people using Haskell tend to more quickly reach for a real parsing library rather than doing low-level string munging.
07:37:54 <kadoban> The lambdabot one is from Arrow, yeah. The probably-more-used one is from Bifunctor
07:37:54 <byorgey> ok, fair enough =)
07:38:17 <ertes-w> nkaretnikov: the academic term for this is "implicit configurations", from the original paper…  if reflection does everything you need, i strongly recommend that you use it and not invent your own class-based approach
07:38:18 <mauke> my ($key, $value) = split /=/, $line, 2;  # obviously
07:38:24 <chocopuff> byorgey: and vice versa. kinda like the quirks of every language. some stuff just tends to be easier in one than the other yeah
07:39:15 <byorgey> mauke: hehe.  That brings back some memories
07:39:34 <phadej> λ Text.Regex.Applicative> match ((,) <$> few anySym <* sym '=' <*> many anySym) "foo=bar=quux"
07:39:37 <phadej> Just ("foo","bar=quux")
07:39:42 <ertes-w> nkaretnikov: reason is simplicity and efficiency; direct class-based methods usually come with a massive performance hit, unless you use super-ugly hacks
07:40:00 <infinisil> phadej: oh boy
07:40:05 <byorgey> phadej: nice =)
07:40:15 <infinisil> this is becoming a contest of who can come up with the most complicated implementation
07:41:22 * byorgey goes off to write a version using a DFA encoded in the untyped lambda calculus running in a Haskell interpreter
07:42:19 <mauke> nah, you need to do it in the type system
07:42:50 <phadej> (my example is to illustrate that using "parsing library" is comparable to using regexp's in perl, you just have to learn the syntax ;)
07:43:30 <mauke> uh
07:43:36 <mauke> the regex in my code was just =
07:44:25 <adamt> I love the amount of time Haskell devs can waste on discussing how to split a string.
07:44:29 <adamt> :P
07:44:54 <int-e> splitting strings, splitting hairs, it's all the same principle
07:45:06 <byorgey> we're not wasting time, we're, uh, learning!
07:45:32 <phadej> mauke: but you had `split`, not match :)
07:46:23 <phadej> let split2 re = (,) <$> few anySym <* re <*> many anySym -- can be written by user!
07:47:33 <Taneb> > splitOn "=" "a=b=c"
07:47:36 <lambdabot>  ["a","b","c"]
07:48:33 <nkaretnikov> ertes-w: thanks for the tips
07:48:57 <mnoonan> split is just a comonoid on strings, what's the problem?
07:49:43 <Taneb> Oh, I didn't read the original problem
07:53:12 <mauke> phadej: yes, because I wanted to use perl's strengths, not its weaknesses :-)
07:53:35 <mauke> hmm
07:54:18 <mauke> my ($key, $value) = $line =~ m{ \A ( [^=]* ) (?: = (.*) )? \z }xs;
07:54:51 <mauke> still more readable than the haskell version in my opinion
07:55:16 <Taneb> Readability is in the eye of the beholder ;)
07:55:17 <mauke> it probably depends on what notation you're more used to
07:55:26 <Taneb> (you can quote me on that)
07:56:23 <adamt> Thx for the help guys. Laters. Although it seems like i have to read the history of the channel later. :P
08:03:25 <kindaro> I need a second pair of eyes to measure the performance of the programs from stackoverflow.com/q/48410245, is there someone around with a half an hour of free time to help me out? I have nonsensical results and I want to verify.
08:09:45 <sr10> (snd(unzip [(1,11),(2,22),(3,33),(4,44)]))                                  output [11,22,33,44]                                  is there any better way to get this
08:10:11 <sm> g'day all. To help stop the harassing "snoyjerk" posts on reddit, please upvote/message mods re https://www.reddit.com/r/haskell/comments/7shikr/replacing_hackage_hash_based_package_downloads/dt5eluy/
08:12:26 <kadoban> Ew, reddit
08:16:20 <ertes-w> "avoid success at all costs" – why didn't we listen?
08:18:46 <cycle337> ertes-w: hahaha :) i was just watching that ! :)
08:19:19 <ertes-w> =)
08:32:17 <kindaro> I need a second pair of eyes to measure the performance of the programs from stackoverflow.com/q/48410245, is there someone around with a half an hour of free time to help me out? I have nonsensical results and I want to verify.
08:32:31 <tabaqui> is there some "free" function "runReadP :: ReadP a -> String -> a"?
08:32:44 <tabaqui> I want to read from string without Read instance
08:34:07 <mauke> :t \p s -> fst (head (readP_to_S p s))
08:34:08 <lambdabot> error:
08:34:09 <lambdabot>     Variable not in scope: readP_to_S :: t -> t1 -> [(a, b0)]
08:35:33 <tabaqui> mauke: ah, ReadS is just a type synonim
08:35:38 <tabaqui> I forgot about this, thanks
08:58:05 <cesco969> ciao a tutti
08:58:16 <cesco969> !lista
09:04:40 <koala_man> amosbird: I've updated the shellcheck readme with the shellcheck-static package ^^
09:07:09 <mpickering> what version of ghc does debian currently ship with?
09:09:12 <cocreature> mpickering: https://packages.debian.org/stretch/ghc
09:09:30 <mpickering> ok so 8.0.2, good
09:09:35 <cocreature> 8.0.1
09:09:38 <cocreature> afaict
09:09:49 <mpickering> I am wondering whether to drop 7.x support from haskell-src-exts
09:10:04 <mpickering> because I really don't want to depend on semigroups as it makes the dependency tree much bigfer
09:10:05 <mpickering> *bigger
09:10:26 <cocreature> you can always go for a conditional dependency no?
09:11:00 <mpickering> that alleviates the pain somewhat I guess
09:11:17 <cocreature> well it puts the pain on the maintainer, i.e., you so if you don’t want to do this fair enough :)
09:11:27 <mpickering> it is still however extremely annoying to have to make this change for no benefit
09:11:49 <mpickering> the library compiles just fine with 7.4.2 features before people start messing around with the classes
09:13:01 <cocreature> the trick is to not do anything and wait for ryanglscott to fix your package :P
09:13:27 <mpickering> he did already ;)
09:13:32 <cocreature> heh :)
09:13:37 <mpickering> but added this dependency and used CPP
09:13:46 <mpickering> both of which I want to avoid as much as possible
09:15:14 <cocreature> assuming 8.4 stays somewhat close to its current release schedule it won’t be long before you can drop 7.10 support even if you want to stick to the 3 GHC release policy, so dropping it now seems fairly reasonable
09:15:42 <phadej> FWIW, I thinks is completely ok to support GHC-8.0 for something like haskell-ext-srcs
09:16:04 <mpickering> and you mean not anything older?
09:16:09 <phadej> support only 8.0+, yeah
09:16:10 <cocreature> yeah, I agree
09:16:25 <phadej> it's not "text"
09:17:46 <phadej> ... though haskell-src-meta...
09:18:13 <fresheyeball> what's the deal with the MINIMAL pragma?
09:18:14 <phadej> but I think they'll be fine with older haskell-src-exts for older GHC too
09:18:44 <fresheyeball> I don't see it in the source for the Enum typeclass, and yet the docs show a minimal representation automatically?
09:18:54 <fresheyeball> Is it a deprecated thing, or something forward looking?
09:19:48 <metahumor> fresheyeball: iiuc MINIMAL labels the function in the class defn that is the minimum for an instance to define to be a valid instance
09:20:46 <metahumor> fresheyeball: that is, to have a valid Enum instance, I only need to define toEnum and fromEnum
09:21:23 <phadej> mpickering: ah, you cannot get away with CPP, then you'll have (Semigroup m, Monoid m) => context
09:21:42 <metahumor> fresheyeball: I'm free to also define "succ", for example, if i somehow prefer my definition (due to efficiency for example), but I don't have to, because the Enum class defines "succ = toEnum . (+ 1) . fromEnum"
09:21:44 <phadej> like we have (Applicative m, Monad m) to support pre AMP code
09:21:51 <mpickering> That's preferable to CPP definitely
09:22:23 <metahumor> fresheyeball: hopefully, if you do still define a "succ", it should probably give you the same result the default "succ" would
09:22:54 <phadej> mpickering: and you can have `append = (<>)` still
09:23:07 <phadej> i.e. no need to remove it for base-4.11
09:24:48 <hyperisco> upgrade your monoids to semigroup monoids!
09:32:30 <insanitea> Yesterday someone asked about mtl and finer-grained IO... shameless plug: http://xkollar.github.io/posts/2018-01-25-fine-grained-io-with-mtl.html
09:36:59 <metahumor> could someone explain how the types work out when I have a "guard p" statement inside a do block? how does "m ()" get unified with "m a"?  how exactly does the "empty" bubble up out of the block?
09:38:08 <fresheyeball> is there a way to combine Prisms with and Alternative style behavior?
09:38:09 <nkaretnikov> metahumor: rewrite the do block as a sequence of >>= and >>
09:38:19 <nkaretnikov> metahumor: then reduce by hand
09:38:27 <fresheyeball> like, try this Prism, if it fails, use the next Prism
09:45:25 <glguy> fresheyeball: failing
10:26:45 <hololeap> what is the difference between a b-tree and a rose-tree?
10:37:29 <AndreasK> hololeap: Going by wiki rosetree has no limit on the number of child nodes. But I'm sure there is more to it
10:38:31 <hololeap> AndreasK: i ask because on the wiki page for Zipper, it says, "Note that in the original paper, Huet dealt with B-trees (ones where nodes have arbitrary numbers of branches),"
10:39:00 <hololeap> but my understanding is that rose trees were precisely that
10:40:59 <hololeap> i see, wikipedia says that there is a defined range of how many branches each node can have
10:41:01 <AndreasK> hololeap: Going by past experiences, there is a good chance the haskell wiki is wrong.
10:41:49 <hololeap> ok, thanks
10:43:48 <AndreasK> Maybe the original paper described b-trees and then went on to extend the approach to variable sized nodes.
10:46:07 <AndreasK> hololeap: The huet paper linked from the page at least doesn't mention b-trees as far as I can tell
10:47:31 <hololeap> noted... in any case the names for these data structures seem pretty arbitrary half the time
11:10:28 <amalloy> a friend recently reminded me of https://mail.haskell.org/pipermail/haskell-cafe/2006-June/016179.html, which claims to be a one-pass algorithm for replacing all elements in a tree with the minimum value of the whole tree. i remember seeing it a long time ago and not really getting it; these days i think i understand what's going on and it doesn't actually look single-pass to me
11:11:33 <amalloy> specifically it seems there is first a pass in which we build up one giant thunk which is sorta a linked list of partially applied `min` calls, whose size is the size of the original tree; then once we reduce that we traverse the original tree again to build a new tree with the same shape but the new value. is that about right, or am i missing something?
11:18:42 <lyxia> I see only one pass
11:20:31 <lyxia> the second component of the result could be forced in rpMin
11:33:34 <amalloy> i don't understand what you mean, "could be forced in"
11:37:10 <lyxia> rpMin (B l r, m) = ... let !mOut = ml `min` mr in (B l' r', mOut)  <- no thunk here
12:05:53 <jle`> metahumor: 'm ()' unifies with 'm a' where a ~ ()
12:08:05 <typetetris> What is that `Paths_<libname>` Module hpack insist on inventing in my cabal files?
12:08:46 <n_blownapart> hi I'm learning some basic proofs, I like particularly Euclid's Proof of the infinitude of primes. Here is a proof for basic peano arithmetic. Its 110 lines long. Is it that haskell is just not the language for this?
12:08:48 <n_blownapart> http://lpaste.net/361928
12:09:10 <lyxia> typetetris: it's a module to resolve paths for extra files that may come with your package
12:09:40 <lyxia> typetetris: see Cabal documentation on data-fields and https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
12:10:41 <lyxia> n_blownapart: indeed haskell was not designed for theorem proving, even though you can kind of do it with enough extensions enabled
12:10:58 <typetetris> lyxia: Thank you very much!
12:11:34 <n_blownapart> thanks lyxia yeah another thing to distract me from learning haskell.
12:11:48 <lyxia> typetetris: yw.  and I meant "data-files"
12:13:57 <n_blownapart> lyxia one thing, haskell leaders are always saying: types == propositions and programs == proofs
12:14:10 <n_blownapart> say , on youtube
12:14:30 <lyxia> yeah, the Curry-Howard isomorphism
12:15:07 <n_blownapart> I wonder if a beginner can see how that is
12:15:22 <Rembane> n_blownapart: Coq and Agda are better at theorem proving.
12:15:58 <n_blownapart> Rembane: thanks yeah there's a meetup but they want me to fully learn haskell first
12:16:21 <Rembane> n_blownapart: Sweet!
12:17:55 <typetetris> if I build a package with `cabal build` how can I list, which flags did get turned on and off?
12:22:54 <n_blownapart> sorry disconnect if I had a response..
12:23:25 <n_blownapart> freenode changed my nick at the disconnect, weird
12:25:14 <n_blownapart> still wondering why the textbook has those 2 constructors: EVAL , ADD. this program is confusing
12:25:22 <n_blownapart> https://ptpb.pw/O3x5
12:29:56 <lyxia> yeah it is confusing
12:31:37 <n_blownapart> I took out value' and main at bottom if you care to look : http://lpaste.net/361929
12:31:41 <n_blownapart> lyxia:
12:32:12 <n_blownapart> this is called an abstract machine according to author
12:33:35 <kamyar> Please consider this code
12:33:37 <kamyar> http://lpaste.net/7177377121734492160
12:33:46 <kamyar> The result seems wrong!
12:34:10 <lyxia> kamyar: what is the result and what should it be instead
12:34:11 <kamyar> I am testing the response time of my local Nginx which is below 11 ms using ab
12:34:22 <kamyar> But the result is upper than 100 always
12:34:35 <kamyar> Am I doing the time calculation wrong?
12:35:00 <thehappycolorpro> can someone help me with this haskellbook problem?:
12:35:07 <thehappycolorpro> f :: (a, b) -> (c, d) -> ((b, d), (a, c))
12:35:17 <thehappycolorpro> i need to write a function that does that, using fst and snd
12:35:52 <kadoban> thehappycolorpro: How far did you get?
12:36:09 <thehappycolorpro> i tried f (x, y) = ((snd x, snd y), (fst x, fst y))
12:36:20 <thehappycolorpro> i think i have the right idea, idk but the syntax
12:36:31 <thehappycolorpro> i'm on chapter 4 exercises of haskellbook
12:36:49 <kadoban> thehappycolorpro: Try  f x y     instead at the start
12:37:13 <thehappycolorpro> oh
12:37:22 <kadoban> f (x, y)  would be more  f :: ((a, b), (c, d)) ->  ...
12:37:36 <thehappycolorpro> o mah goodness
12:37:38 <thehappycolorpro> you are aa genius
12:37:41 <mox> Or f (a, b) (c, d) = ((b, d), (a, c)) that looks cleaner
12:37:52 <kadoban> mox: Ya, but I think the point is to use fst and snd for some reason
12:37:56 <kadoban> thehappycolorpro: :)
12:37:56 <mox> Yeah ok
12:38:09 <kamyar> lyxia: Did u read the code?
12:38:12 <kadoban> But ya, mox's is definitely how I'd write it if I had to
12:38:45 <thehappycolorpro> oho i see
12:38:58 <thehappycolorpro> for this problem, would there be a better way to write it using fst and snd?
12:39:11 <lyxia> kamyar: I did, I can't see anything wrong though I don't know much about wreq or clock
12:39:31 <kadoban> thehappycolorpro: I don't think so
12:39:36 <kadoban> Yours seems fine, given the instructions
12:39:48 <thehappycolorpro> aww yeee
12:39:53 <thehappycolorpro> it's starting to get fun
12:40:23 <n_blownapart> hi I'm still hoping for some help with this : I'm not exactly sure what it does ; how we can manipulate the order of operations if we want http://lpaste.net/361929
12:41:06 <n_blownapart> the abstract machine that produces tired eyes
12:45:51 <ski> looks like an abstract machine for evaluating integer expressions
12:46:36 * ski . o O ( "an abstract machine for pigs" )
12:46:46 <Rembane> Can they fly?
12:47:08 <Logic> Good moring guys: here is my code:
12:47:13 <Logic> module Main where
12:47:13 <Logic> main :: IO ()
12:47:13 <Logic> main =
12:47:13 <Logic>   bmiTell :: (RealFloat) => a -> a -> String
12:47:13 <Logic>   bmiTell weight height
12:47:14 <Logic>         | weight / height ^ 2 <= 18.5 = "Underweight"
12:47:16 <Logic>         | weight / height ^ 2 <= 25.0 = "Average"
12:47:18 <Logic>         | weight / height ^ 2 <= 30.0 = "Overweight"
12:47:25 * ski blinks
12:47:49 <cycle337> a1btd
12:48:59 <n_blownapart> ski please elaborate Rembane
12:49:56 <n_blownapart> Its the last long example from chapt 8 of the hutton book
12:50:18 --- mode: ChanServ set +o ski
12:50:55 --- mode: ski set -o ski
12:51:04 <ski> Logic : please don't paste into the channel
12:51:11 <ski> you can use a paste-site, like e.g.
12:51:12 <ski> @paste
12:51:12 <lambdabot> Haskell pastebin: http://lpaste.net/
12:51:33 <thehappycolorpro> i just want to make sure: (+) :: Num a => a -> a -> a
12:51:52 <thehappycolorpro> num a with the => means the first a has to be a number
12:52:05 <thehappycolorpro> and the last a means that itll also be a number
12:52:10 <thehappycolorpro> but what does the middle a mean?
12:52:33 <cycle337> Logic: yea or gist or simply use a web interface that will ask you to automatically upload to a pastebin instead of the chan
12:52:34 <Logic> Hello you guys if you could please help me with an indentation error,   could not parse '|'    Ive tried indenting it but I still cant get rid of the error?
12:53:06 <glguy> Logic: You'll need to post the code to a pastebin if you have questions about it
12:53:35 <Logic> glguy: what is  a pastebin?
12:53:39 <ski> @paste
12:53:39 <lambdabot> Haskell pastebin: http://lpaste.net/
12:53:45 <n_blownapart> a dog needs a home ... a shelter, from pigs on the wing
12:53:58 <ski> Logic : it's a site where you can paste your code. then you give the link to the paste (only), to the channel
12:54:01 <n_blownapart> I'll never learn haskell
12:54:35 <Rembane> n_blownapart: You will, eventually.
12:54:36 <glguy> n_blownapart: That's too dramatic, you'll learn it over and over again
12:54:45 <n_blownapart> I can't understand you kind people, and I always get lost in the book
12:55:15 <n_blownapart> like "an abstract machine for pigs", what does it mean
12:55:37 <ski> thehappycolorpro : "num a with the => means the first a has to be a number" --  no, `Num a' means that `a' has to be a *type* that *supports* "basic number operations". then all the three `a's in `a -> a -> a', but be such a type (all must be the same type)
12:55:38 <MarcelineVQ> Logic: move your defintion of bmiTell to the top level to be on its own
12:55:50 <ski> n_blownapart : that's a joke / play with words
12:55:57 <amalloy> thehappycolorpro: Num a => ... means that a, which is the same a for the whole rest of the signature, must be an instance of Num
12:56:23 <MarcelineVQ> you can't just state functions inside something else like you are, you need to use let or where, but is usually better to make it its own thing
12:56:27 <amalloy> so it is the same signature as a -> a -> a, with the additional constraint that a must be Num
12:56:32 <Logic> MarcelineVQ: Ok I'll give it a try, thanks.
12:56:32 <ski> n_blownapart : so `(+) :: Num a => a -> a -> a' means that addition take two `a's, and produces an `a', *provided* that `a' is a numeric type
12:56:39 <ski> er
12:56:41 <ski> thehappycolorpro ^
12:57:00 <thehappycolorpro> aaaah OK
12:57:13 <thehappycolorpro> so hypothetically if (+) was a funciton to add 3 numbers
12:57:35 <thehappycolorpro> it would be Num a=> a-> a-> a-> a->
12:57:38 <amalloy> yes
12:57:42 <thehappycolorpro> uhh without that last arrow
12:57:43 <amalloy> minus the -> at the end
12:57:44 <thehappycolorpro> OK
12:57:48 <thehappycolorpro> thank u
12:57:56 <amalloy> :t \x y z -> x + y + z
12:57:58 <lambdabot> Num a => a -> a -> a -> a
12:58:12 <thehappycolorpro> ooooooo
12:58:31 <thehappycolorpro> also why do people quote using `like this'
12:58:40 <Logic> MarcelineVQ: I am not sure what you mean, it is throwing more errors.
12:58:47 <MarcelineVQ> thehappycolorpro: mostly it's ski
12:58:52 <kadoban> thehappycolorpro: It's like vaguely markdownish syntax
12:58:52 <ski> TeX
12:58:56 <amalloy> thehappycolorpro: imo because ski is a weirdo
12:58:57 <kadoban> Or that
12:58:58 <MarcelineVQ> Logic: use a pastebin to show what you have
12:59:04 <MarcelineVQ> including errors
12:59:11 <ski> amalloy : certainly ;)
12:59:20 <n_blownapart> so we have a function called eval and a type constructor called EVAL. is there a better way for readability to have that?
12:59:28 <thehappycolorpro> haha ok
12:59:37 <n_blownapart> http://lpaste.net/361929
12:59:46 <kadoban> It is rather nice to have a way to quote code, because otherwise it gets weird. Especially when the code is like ... single letter variable names, in which case sentences get hard to parse.
13:01:10 <ski> n_blownapart : perhaps `EVAL' would be better called `EVAL_THEN_ADD', or something like that
13:01:24 <Logic> MarcelineVQ: did you figure out what I did wrong?
13:01:39 <n_blownapart> ski thanks a bit crestfallen
13:01:45 <MarcelineVQ> Logic, I can't see your screen.
13:01:49 <ski> n_blownapart : also, `EVAL' is not a type contstructor, it's a data constructor
13:01:50 * glguy can
13:01:54 <MarcelineVQ> 3 people have told you now to paste your code into some site you can link to :>
13:01:58 <ski> (`Op' and `Expr' are type constructors)
13:02:19 <Logic> MarcelineVQ: I pasted my code on that website.
13:02:39 <metahumor> jle`: and does () ~ a unify over all a?
13:02:39 <ski> Logic : but you didn't give us the link to the paste, yet
13:03:08 <Logic> http://lpaste.net/361930
13:03:10 <ski> (there used to be a bot here who'd automatically do that, if you filled in the channel on the paste. but it appears to be broken for the moment)
13:03:14 <crestfallen> <<
13:03:15 <Logic> sorry about that still learning.
13:03:29 <ski> no worry
13:03:29 <MarcelineVQ> you shouldn't indent the first     bmiTell weight height
13:03:44 <Logic> MarcelineVQ: http://lpaste.net/361930
13:03:54 <ski> MarcelineVQ is already looking at that
13:03:54 <amalloy> Logic: the biggest mistake i see is your RealFloat constraint is wrong
13:04:05 <metahumor> jle`: why shouldn't guard and other stuff that is 'm ()' be "m Void"? this is one of the things i still haven't internalized about haskell and am having weird influence from C on
13:04:35 <glguy> metahumor: Void means no value at all, it would indicate that the guard doesn't return
13:04:40 <Logic> amalloy: so do I replace it with something else?
13:04:48 <glguy> () means that there's merely an uninteresting value
13:04:59 <metahumor> glguy: while () can be any value?
13:05:03 <amalloy> Logic: i mean, you are copying this from the LYAH book, so i'd say go read it more carefully and copy correctly
13:05:05 <glguy> no, it can only be the value ()
13:05:23 <ski> crestfallen : anyway, it looks like `Cont' is simulating/representing a stack of things to do (aka a continuation), after evaluating a subexpression
13:05:30 <metahumor> okay, so () is only inhabited by ()
13:05:37 <ski> @src ()
13:05:37 <lambdabot> data () = ()
13:06:20 <glguy> forever (putStrLn "looping") :: IO Void
13:06:42 <glguy> Here's an example where Void makes sense, this action isn't going to finish and thus will never be required to produce a value with type Void
13:07:32 <crestfallen> ski thanks kindly . sorting it out
13:08:00 <mniip> in practice it's 'forall a. IO a'
13:08:05 <mniip> which is iso to Void
13:08:07 <Logic> amolloy: I think i figured it out, I dont know why my indentation is always screwed in Haskell.
13:08:08 <amalloy> metahumor: it can't be m Void because the usual do-notation (do {guard foo; return 5}) desugars to (guard foo >>= (\_ -> return 5))
13:08:10 <ski> metahumor : `void' in C basically corresponds to `()' in Haskell. `Void' is more like `__attribute__ ((noreturn))'
13:08:11 <MarcelineVQ> Logic: see the annotation on your paste  http://lpaste.net/361930
13:08:31 <amalloy> since no value of type Void can ever exist, there'd be no value to pass to the lambda (\_ -> return 5)
13:08:38 <metahumor> and in the case of "guard" in the context of a StateT s [] a, "empty" will be StateT s [] (), and we can use () there because the empty list doesn't care which values are in it?
13:09:11 <metahumor> thanks for all the explanations, you guys are giving great details of different facets of () and Void
13:09:12 <amalloy> whereas with guard's real signature involving m (), you can pass ()
13:10:58 <mniip> metahumor, () and Void are resp the initial and terminal objects in the category of types
13:11:05 <mniip> er
13:11:08 <mniip> terminal and initial
13:12:29 <ski> metahumor : also, in case you weren't aware of it, `()' is pronounced "unit". it is the empty tuple type (and the empty tuple is spelled the same way, as you know)
13:13:59 <metahumor> ski: yeah, and it's represented as U1 in Generics
13:14:00 <dexterfoo> the existence of () has always felt like a code-smell to me. why have a value if its value is meaningless?
13:14:40 <ski> how do you feel about the empty list ? the empty string ?
13:14:41 <amalloy> dexterfoo: it's a useful placeholder to put into data structures where the shape of the data structure has meaning in itself
13:14:54 <Logic> If someone could please tell me what I am doing wrong:   http://lpaste.net/361930
13:15:35 <dexterfoo> anaxios: yeah, it's very useful in practice in lots of places, but has always felt like an inellegant hack to me
13:15:41 <kadoban> Logic: bmiTell doesn't make any sense there, put it all the way to the left and leave a blank link before it
13:16:11 <metahumor> mniip: there's no partial order to types other than Void -> Type and Type -> (), right?
13:16:11 <amalloy> Logic: the last version, in "bmi (annotation)", looks good. the other two definitions are indented weirdly and don't really belong there
13:16:32 <kadoban> ie add a blank line after line 4, and move lines 5 and 6 all the way to the left. Also probably want to indent the other lines a bit less, but shouldn't matter.
13:16:52 <kadoban> Oh, there's an annotation
13:17:24 <ski> metahumor : from one POV, every function `f :: A -> B' describes a partial ordering inequality
13:17:53 <metahumor> "from my point of view, the Jedi are evil!"
13:18:11 <ski> (categories generalize partial orders)
13:19:00 <crestfallen> glguy: I'll never learn the *basics* of haskell   :)
13:19:07 <Logic> Now I am getting an error at height. http://lpaste.net/361930
13:20:04 <kadoban> Logic: Which one is the code that you're running? And what's the error?
13:21:18 <Logic> kadoban: I edited bmi, it fixed the gaurd( | ) error that I had but now I am getting an error at height.
13:22:05 <amalloy> Logic: consider creating a new paste (or editing the existing one) so that it only contains code you are actually running, rather than both old+broken code and your current version
13:22:11 <kadoban> Logic: Which one? There's like 3 versions on that page, two of them in one thing. And what error? I guarantee it doesn't just say "error at height"
13:22:51 <Logic> kadoban: the first: bmi not bmi annotation.
13:23:23 <metahumor> is it a law that "mzero = empty" and "mplus = (<|>)" for types that have instances for both Alternative and MonadPlus?
13:23:29 <ski> you can edit or annotate it to include the error message at the end
13:23:54 <ski> metahumor : a law of which type class ?
13:23:54 <metahumor> corollary, are all (Alternative m, Monad m) => MonadPlus m?
13:24:01 <metahumor> a law of MonadPlus
13:24:14 <metahumor> ehh, i guess a joint law
13:24:32 <ski> it can't be expressed as a law of `MonadPlus', since not all instance of it need to be instances of `Alternative'
13:25:14 <kadoban> Can't laws be conditional and only apply if things are instances of something else?
13:25:30 <Logic> http://lpaste.net/361936     error at height, please help!!!
13:25:43 <kadoban> Logic: I give up.
13:26:03 <metahumor> Logic: can you also include the error in your paste?
13:26:28 <ski> kadoban : hm, perhaps if the module defining one class depends (indirectly or directly) on the module defining the other one
13:27:31 <kadoban> ski: Is that even necessary? I mean it's not like the compiler can even check them, right? Aren't they just for humans to quite a large extent?
13:27:41 <ski> (probably i'd require it to import the name of the other class, perhaps either explicitly, or otherwise explicitly the module referencing it)
13:27:49 <ski> (in code, i.e.)
13:27:59 <Logic> metahumor: http://lpaste.net/361936   the error is there now.
13:28:50 <ski> kadoban : i don't really believe in e.g. requiring that instances of `Read' and `Show' satisfying a particular joint law, without having any concrete place (such as a common subclass) in the language to "attach" that law to
13:29:24 <ski> so, if you have the common subclass as a constraint, then you know you can assume the law holds. if you don't then you don't
13:29:41 <ski> (and commonly such a subclass would have zero methods)
13:30:45 <kadoban> ski: Hmm, interesting. I've never really thought about it. Not sure why I see why that'd be necessary, I kind of see them as mostly a specific form of documentation
13:30:46 <ski> "Aren't they just for humans to quite a large extent?" -- is a point of what i'm saying. how is the human supposed to know whether these two classes were brought together intentionally, in the sense of the joint law to hold, or not ?
13:31:24 <metahumor> Logic: try changing "^" to "**" and "2" to "2.0"
13:32:11 <kadoban> ski: Well, I can just go look it up in the docs, right? Or you mean like, one instance could come from Bob and one from Jack and neither is really responsible for knowing what the other is doing?
13:32:23 <ski> exactly. diamond problem
13:32:40 <kadoban> That seems like it could be a good point
13:34:12 <kadoban> Yeah, that's pretty convincing. Seems a bit unfortunate to me still though.
13:35:59 <glguy> metahumor: That shouldn't be necessary (**/^)
13:36:56 <ski> metahumor : in practice, i can't think of any deviation. doesn't mean there are none, though
13:37:09 <glguy> thought it would remove the defaulting, better would be ^ (2::Int)
13:37:12 <glguy> though*
13:37:24 <Logic> metahumor: no more errors, thanks for the help!!
13:37:26 <glguy> Logic: Those weren't errors
13:38:04 <kadoban> That defaulting warning is pretty unfortunate. Never quite liked that situation.
13:39:00 <thehappycolorpro> testing
13:39:23 <thehappycolorpro> i just experienced my firs ttime crashing ghci
13:39:30 <thehappycolorpro> or maybe it was terrible lag. imma try it again
13:39:54 * ski . o O ( "famous last words" )
13:39:55 <thehappycolorpro> asdf
13:40:11 <thehappycolorpro> hmm yeah lol
13:40:15 <glguy> thehappycolorpro: This isn't a testing channel
13:42:02 <[exa]> thehappycolorpro: sounds a lot like OOM.
13:42:21 <thehappycolorpro> what is that
13:42:33 <thehappycolorpro> and sorry, didn't mean to spam
13:43:24 <[exa]> if you mess ghci to the level that you are testing even IRC window to work, out-of-memory is a common cause
13:43:36 <metahumor> continuing on the MonadPlus/Monoid discussion, is there a class that describes well some action that "intersperses" something upon "not-mzero `mplus` not-mzero"?
13:44:26 <metahumor> for example, path joining, where "parentfolder `mplus` filename" should intersperse an OS dependent path-sep, but only if neither are empty strings
13:44:32 <[exa]> thehappycolorpro: btw (if it's really oom) you can run e.g. htop in a terminal to see exactly what's getting crashy.
13:46:51 <[exa]> metahumor: I've been trying to setup something similar; you need your monoid to be able to check whether an element is Eq to mempty
13:50:53 <metahumor> wouldn't a crappy Eq be sufficient for that, where "mzero == mzero = True; _ == _ = False"?
13:51:10 <metahumor> s/mzero/mempty/g
13:51:33 <metahumor> and if that
13:51:46 <metahumor> 's the case, why not just pattern match on the memptys?
13:53:10 <[exa]> metahumor: you need that function-match extension to patternmatch on mempty but yes it will work
13:53:42 <metahumor> [exa]: what's your use case that you're working on
13:53:47 <dmwit> % newtype Path = Path [String] deriving Monoid; getPath (Path fps) = intersperse '/' fps
13:53:49 <yahb> dmwit: ; <interactive>:1:39: error:; * Can't make a derived instance of `Monoid Path':; `Monoid' is not a stock derivable class (Eq, Show, etc.); Try GeneralizedNewtypeDeriving for GHC's newtype-deriving extension; * In the newtype declaration for `Path'
13:54:01 <dmwit> % :set -XGeneralizedNewtypeDeriving
13:54:01 <yahb> dmwit:
13:54:05 <dmwit> % newtype Path = Path [String] deriving Monoid; getPath (Path fps) = intersperse '/' fps
13:54:05 <yahb> dmwit: ; <interactive>:3:39: error:; * No instance for (Semigroup Path) arising from the 'deriving' clause of a data type declaration; Possible fix: use a standalone 'deriving instance' declaration, so you can specify the instance context yourself; * When deriving the instance for (Monoid Path)
13:54:12 <dmwit> oooookay
13:54:18 <dmwit> Anyway maybe my point is clear enough.
13:54:28 <dmwit> The instance doesn't have to do it if the only observer does it.
13:57:09 <dmwit> mniip: What does this mean?
13:57:20 <dmwit> % newtype Path = Path [String] deriving (Semigroup, Monoid, Show)
13:57:20 <yahb> dmwit: <interactive>: ^^ Could not load 'base_GHCziShow_showListzuzu4_closure', dependency unresolved. See top entry above.; ByteCodeLink.lookupCE; During interactive linking, GHCi couldn't find the following symbol:; base_GHCziShow_showListzuzu4_closure; This may be due to you not asking GHCi to load extra object files,; archives or DLLs needed by your current session. Restart GHCi, specifying; the missi
13:57:41 <mniip> %kill
13:57:41 <yahb> mniip: Done
13:57:44 <mniip> % newtype Path = Path [String] deriving (Semigroup, Monoid, Show)
13:57:45 <yahb> mniip: ; <interactive>:1:40: error:; * Can't make a derived instance of `Semigroup Path':; `Semigroup' is not a stock derivable class (Eq, Show, etc.); Try GeneralizedNewtypeDeriving for GHC's newtype-deriving extension; * In the newtype declaration for `Path'; <interactive>:1:51: error:; * Can't make a derived instance of `Monoid Path':; `Monoid' is not a stock derivable cla
13:57:59 <[exa]> metahumor: type variable substitutions. There are some extra checks I wanted to omit when the substitution is trivial
13:58:03 <dmwit> If you want to reproduce, first make the type without the Show derived.
13:58:27 <dmwit> (Dunno if that's important. But it's what I did last time that lead to this.)
13:58:32 <mniip> one sec lemme look up command history
13:58:45 <dmwit> afk for a bit
13:59:16 <Logic> I forgot what is the website to paste my code?
13:59:16 <mniip> this might or might not be a desugarer bug
13:59:30 <metahumor> @where lpaste
13:59:30 <lambdabot> http://lpaste.net/
13:59:42 <Logic> lambdabot: thanks!!
14:01:48 <mniip> weird
14:01:54 <mniip> looks like it's induced by one of the options
14:04:09 <mniip> ah
14:04:21 <mniip> -dynload deploy and the chrooted libs
14:14:45 <jle`> metahumor: if you're in a place where you expect 'm a', you can give it an 'm ()'
14:15:41 <jle`> metahumor: you're right though, the semantics of 'guard' probably are better conveyed using Void
14:16:11 <jle`> er sorry
14:16:17 <jle`> nevermind, was thinking of another function
14:16:24 <jle`> metahumor: the thing about 'guard' is that it can alos succeed with a value
14:16:40 <jle`> it can succeed with ()
14:18:36 <metahumor> right, when it succeeds, it passes forward a "pure ()", but when fails, gives an "empty", and in the case of "StateT s [] a", empty is "mzero" and "mzero" is "StateT $ \_ -> mzero @[]"
14:19:16 <metahumor> then the question being, how is "StateT $ \_ -> mzero @[]" a "StateT s [] ()"?
14:19:23 <mniip> weird
14:22:14 <jle`> mniip: it's actually 'forall s a. StateT s [] a'
14:22:17 <jle`> * metahumor
14:23:00 <nshepperd1> guard_ :: Monad m => m Void -> Bool -> m ()
14:26:00 <nshepperd1> Actually Functor would do there
14:28:00 <mpickering> does miso work with the 8.0 version of ghcjs?
14:29:11 <dmwit> :t StateT
14:29:13 <lambdabot> (s -> m (a, s)) -> StateT s m a
14:29:21 <amalloy> nshepperd1: you're proposing a function guard_ :: Functor f => f Void -> Bool -> f ()?
14:29:45 <dmwit> metahumor_aw: Well, `mzero @[] = []`, which is a perfectly good list of *any* type, including the type `[(a, s)]`.
14:30:07 <amalloy> the only implementation of that i can imagine is guard x _ = fmap (const ()) x, which is not very interesting
14:30:13 <ixxie> what does <- do, what does do do, and what are their relations?
14:30:19 <dmwit> metahumor_aw: Excuse me, I meant: including the type `[((), s)]`.
14:31:02 <dmwit> ixxie: They are only meaningful together. `do { x <- actA; actB }` becomes `actA >>= \x -> actB`. There are a few other such rules for `let` bindings and clauses with no `<-`.
14:31:18 <dmwit> ixxie: (And `<-` with a pattern on the left is also a bit special.)
14:31:24 <nshepperd1> amalloy: oh right i forgot you need pure
14:31:30 <dmwit> ixxie: The Haskell Report has the full details; give me a second and I'll link you to the right place.
14:31:49 <mpickering> (answer is, yes it does just not with their example file)
14:31:51 <dmwit> ixxie: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
14:32:34 <ixxie> cheers
14:32:34 <dmwit> ixxie: (Oops, I wrote it wrong: it should have been `do { x <- actA; actB }` becomes `actA >>= \x -> do { actB }`, of course!)
14:32:51 <amalloy> nshepperd1: that fixes part of the problem, but i think you would have some issues because most interesting Functors (and thus Applicatives) have no non-bottom values of type f Void
14:33:24 <amalloy> a more reasonable type would be guard_ :: Applicative f => f a -> Bool -> f ()
14:33:34 <amalloy> i think? not sure about that
14:33:51 <ixxie> dmwit I think I need to read that guide from the begining
14:33:55 <nshepperd1> I'm not really proposing such a function as much as imagining it
14:34:03 <nshepperd1> The idea is that you pass your own mzero
14:34:15 <ski> @undo do { x <- actA; actB }
14:34:15 <lambdabot> actA >>= \ x -> actB
14:34:25 <dmwit> ixxie: Do you say that because there's a piece you don't understand (in which case perhaps we can explain it and save you some time) or because the guide looks especially good (in which case I certainly agree and please do read the whole thing)?
14:34:58 <amalloy> ah, i think i see what you mean. it can exist for any Applicative, but it can only be *called* for Applicatives where something like mzero makes sense
14:38:04 <dmwit> :t bool(pure()).(()<$) -- such readable, wow, very understand, am not same programmer
14:38:05 <lambdabot> Applicative f => f b -> Bool -> f ()
14:38:35 <glguy> nshepperd1: What's the implementation you had in mind?
14:38:40 <nshepperd1> Then you can write something like myGuard = guard_ (putStrLn "something went wrong" >> throwIO MyError)
14:40:56 <glguy> nshepperd1: Because it wouldn't make sense to use Void in the way that I'd have guessed guard_ works
14:41:09 <glguy> Oh, I was scrolled up
14:42:39 <thehappycolorpro> Prelude> let f :: a -> a -> a -> a; f = undefined /n Prelude> let x :: Char; x = undefined
14:43:11 <thehappycolorpro> why does :t f x give x :: Char -> Char -> Char?
14:43:21 <thehappycolorpro> i thought it would give 4 Chars
14:43:23 <nshepperd1> guard_ z = bool (fmap absurd z) (pure ())
14:44:16 <dmwit> thehappycolorpro: Because you've already given one of the `Char`s (namely, `x`).
14:44:17 <kadoban> thehappycolorpro: Because that's the type of the function you get when you apply one argument already to f
14:44:39 <dmwit> thehappycolorpro: If `f :: A -> B` and `x :: A`, then `f x :: B`.
14:44:56 <kadoban> :t subtract
14:44:58 <lambdabot> Num a => a -> a -> a
14:44:59 <kadoban> :t subtract 5
14:45:01 <lambdabot> Num a => a -> a
14:45:07 <kadoban> > (subtract 5) 2
14:45:11 <lambdabot>  -3
14:45:44 <thehappycolorpro> aaaaaaaaaaaaah i seeee
14:45:46 <thehappycolorpro> thank you
14:50:39 <thehappycolorpro> how long does it take on average for a complete programming beginner to become proficient enough to make useful stuff?
14:52:19 <dmwit> On the order of months, I think, depending on how strict "useful" is.
14:52:28 <Tuplanolla> A few years, regardless of language.
14:52:38 <cycle337> thehappycolorpro: it kind of depends on how many hours per day he actually allocates to learning and the efficiency to not-understanding ratio, basically somewhere between 3-6 moths with 8 hrs / day and 0.5 ratio i guess
14:53:20 <Hijiri> If someone is already a proficient computer user it might not be too long to create scripts for automating their own stuff
14:54:04 <Tuplanolla> My interpretation of useful is having more users than you can keep track of.
14:54:29 <cycle337> check out https://en.wikipedia.org/wiki/Four_stages_of_competence
14:57:01 <dexterfoo> http://turnoff.us/geek/functional-world/
14:59:59 <cycle337> dexterfoo: lol
15:02:22 <ski> dexterfoo : also don't miss <http://www.lisperati.com/landoflisp/panel60.html>
15:03:44 <ski> (and </landoflisp/panel57.html> before that)
15:04:37 <cycle337> alright guys, have a good night, see you tomorrow
15:05:03 <thehappycolorpro> bye bye
15:07:15 <dexterfoo> ski: hehe
15:09:46 <thehappycolorpro> If the type of kessel is (Ord a, Num b) => a -> b -> a, then the type of kessel 1 2 is (Num a, Ord a) => a
15:10:25 <iqubic> that confuses me.
15:10:30 <thehappycolorpro> if i understand this correctly, because the function "kessel" compares a with b, which has the Num type, it has to assume that a is also a Num type?
15:11:11 <thehappycolorpro> yeah i posted because i was confused
15:11:26 <Tuplanolla> :t kestrel -- This?
15:11:28 <lambdabot> a -> b -> a
15:11:50 <thehappycolorpro> oh that was just an example in the haskellbook
15:12:42 <Hijiri> :info kestrel
15:12:44 <kadoban> thehappycolorpro: The type of 1 is :: Num a => a, and it's also required to be an instance of Ord because of the type of kessel, that should explain the type of the result
15:12:51 <Hijiri> > kestrel 4 "banna"
15:12:54 <lambdabot>  4
15:13:03 <Hijiri> I guess it couldn't be anything else
15:13:07 <Tuplanolla> @hackage data-aviary -- It's from here, Hijiri.
15:13:07 <lambdabot> http://hackage.haskell.org/package/data-aviary -- It's from here, Hijiri.
15:13:13 <Hijiri> oh
15:13:15 <Hijiri> the birds thing?
15:21:11 <thehappycolorpro> kadoban: thank you.
15:22:27 <Philonous> How can I change the data directory (the one getDataDir returns) when building a package?
15:33:58 <thehappycolorpro> Given the type a -> a, which is the type for id, attempt to make a function that terminates successfully that does something other than returning the same value. This is impossible, but you should try it anyway.
15:34:13 <thehappycolorpro> i did let f x = (-x)
15:34:21 <thehappycolorpro> and then f 2 = -2
15:34:29 <kadoban> thehappycolorpro: What's the type of f?
15:34:32 <geekosaur> but that does not have the type (a -> a)
15:34:43 <thehappycolorpro> oooo
15:34:43 <geekosaur> cjheck it. then figure out why
15:34:45 <thehappycolorpro> wait
15:34:52 <kadoban> It a has type that kind of looks like that, but you can't leave out stuff :)
15:35:16 <thehappycolorpro> ok i actualy did f x = id (-x) lol
15:35:28 <thehappycolorpro> i am dumb
15:35:39 <iqubic> The type of f is (Num a => a -> a) in both cases.
15:35:43 <kadoban> Throw in a few more id if you want, it shouldn't change anything, heh.
15:35:54 <iqubic> No, it doesn't change anything.
15:36:00 <geekosaur> which is kinda the point here...
15:36:57 <thehappycolorpro> woah the ghci can divide by zero
15:37:12 <iqubic> > 1/0
15:37:16 <lambdabot>  Infinity
15:37:31 <iqubic> > (round (1 / 0))
15:37:34 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
15:37:49 <iqubic> Yes, it can. And weird stuff happens if you try.
15:37:52 <kadoban> > 1 `div` 0
15:37:55 <lambdabot>  *Exception: divide by zero
15:38:07 <iqubic> See, weird stuff indeed.
15:38:25 <amalloy> kadoban: although of course if you throw in infinitely many useless calls to id, things suddenly do change: `f = fix id` is a silly expression
15:38:37 <amalloy> silly definition, rather
15:39:33 <kadoban> Fix is quite often silly, ya
15:45:21 <iqubic> I love fix.
15:45:43 <dexterfoo> floating point divide by zero is legal and well defined, right? also in haskell?
15:46:30 <boj> > 1.0 / 0.0
15:46:33 <lambdabot>  Infinity
15:46:49 <monochrom> Depends on the compiler. GHC goes with what the hardware does, and the hardware goes with what IEEE 754 says, so yeah.
15:47:39 <monochrom> Although, I haven't seen any compiler (for any language) that deliberately deviate from hardware or 754.
15:48:26 <dexterfoo> monochrom: but what about order of evaluation? in haskell i believe it is undefined. but i think it makes a difference for floating point
15:49:01 <monochrom> Or maybe I did without knowing! Do you remember there was a bygone era when floating-point hardware was absent on most PCs and every compiler came with runtime software for floating-point?
15:49:34 <monochrom> If you write "(a+b)+c" I'm pretty sure GHC won't mess with that.
15:51:08 <monochrom> My dad actually shelled out money to buy a 80287 chip to plug into our PC. :)
15:52:29 <thehappycolorpro> is there a nice visual graph of types and classes?
15:53:39 <thehappycolorpro> my brain is hurting and im only on chapter 5
15:53:56 <AWizzArd> Looking for csv and Startpage mentions cassava, Data.CSV and Text.CSV.
15:54:17 <monochrom> I use cassava too.
15:54:35 <AWizzArd> Ok good, will look into it, thx.
15:55:41 <monochrom> Not easy to start, but I like its approach and don't mind the investment.
15:56:21 <EvanR> dexterfoo: haskell is great for frustrating people with the difference between group-during-parse like a+b+c => (a+b)+c
15:56:47 <EvanR> and order of evaluation
15:57:13 <Tuplanolla> You can change the rounding mode to ruin everything, right?
15:57:27 <monochrom> Yes.
15:57:54 <monochrom> No, you can change the rounding mode to fix everything. :)
15:59:38 <dmwit> thehappycolorpro: https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1270006.3 leads with a visual graph of numeric classes. There is also the Typeclassopedia.
15:59:41 <dmwit> ?where typeclassopedia
15:59:41 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
16:45:18 <Guest52140> hi
16:59:45 <Guest8511> :D
16:59:48 <Guest8511> Hello
17:32:29 <fiatjaf> at which moment does stack create a local .stack folder?
17:32:37 <fiatjaf> stack setup isn't creating one here
17:33:49 <fiatjaf> I'm running stack setup, then stack is (apparently correctly) installing ghc, ghcjs and other stuff, but in the end it tells me that the installed stuff is at ~/.stack/some/long/path/bin and thus not in the $PATH
17:34:21 <sm> ls -ld $HOME/.stack
17:34:32 <fiatjaf> then I try to run `stack exec ghcjs-boot` and get an error message telling me that "cabal was not found at [long list of my PATH]"
17:35:34 <fiatjaf> sm: I mean a local .stack directory, inside the project's directory
17:35:43 <fiatjaf> not the "global" at $HOME/.stack
17:35:45 <sm> in the project dir, it's .stack-work
17:35:53 <fiatjaf> oh
17:35:57 <fiatjaf> alright
17:36:05 <fiatjaf> but it isn't creating that also
17:36:26 <fiatjaf> shouldn't it?
17:36:58 <fiatjaf> what about the cabal error? how is it related?
17:39:17 <sm> fiatjaf: stack setup doesn't do that thing, it just installs ghc. It's pretty much an obsolete command
17:39:44 <fiatjaf> what does that thing?
17:39:48 <sm> stack build
17:39:50 <fiatjaf> stack build?
17:39:52 <fiatjaf> oh
17:39:53 <fiatjaf> right.
17:40:08 <fiatjaf> so everything is ok.
17:40:12 <fiatjaf> except for the cabal error.
17:41:00 <fiatjaf> disregarding the obsolescence of stack setup, if I must to use it (I must because of ghcjs), what should I do to ensure cabal will be installed?
17:41:26 <sm> I know nothing about ghcjs's setup process, but you should probably paste your command & output somewhere
17:41:38 <sm> hastebin.com is great
17:43:04 <fiatjaf> ok.
17:43:06 <fiatjaf> thank you.
17:43:14 <fiatjaf> I'll do that tomorrow.
17:43:19 <sm> np
18:02:23 <loli> ii1
18:49:51 <iqubic> TIL GHC depends on perl.
18:51:07 <ski> @quote perl
18:51:07 <lambdabot> Fatalnix says: Perl is worse than Nazis
18:51:10 <ski> @quote mangler
18:51:10 <lambdabot> Pseudonym says: All hail the Evil Mangler!
18:51:17 <ski> hm, that one
18:52:42 <ski> @quote dive.bar
18:52:42 <lambdabot> JohnMeacham says: Last night I was at this dive bar listening to live music and there was this cute girl I was talking too while this guy was there, we started ribbing each other in the appropriate
18:52:42 <lambdabot> way when confronted with the situation of two guys talking to the same girl, and our jeers eventually turned technical until we were arguing about haskell, perl, and pugs development. it turning out
18:52:42 <lambdabot> he was one of the pugs de
18:54:59 <mmaruseacph2> lol
18:55:12 <mmaruseacph2> too bad lambdabot doesn't give the continuation of the story
18:56:38 <ski> iirc, the remainder was "velopers."
18:57:45 <mmaruseacph2> ok then :)
19:29:59 <Guest61691> :t <*>
19:30:01 <lambdabot> error: parse error on input ‘<*>’
19:30:49 <exio4> :t (<*>) -- Guest61691
19:30:51 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:30:57 <Guest61691> thanks
19:40:20 <parsnip> is jekyll and hugo popular with haskellers?
19:40:46 <iqubic> *Are
19:40:52 <iqubic> not "is".
19:42:24 <jle`> parsnip: lots of haskellers like hakyll :)
19:44:54 <parsnip> oh, yeah, i can't really put everything on hold to get hakyll working :( filed issue, fifth one recently, others complain hakyll doesn't build with stack, i filed one trying to build it with new-build. maybe an older hakyll versoin would work, but unfortunately i don't want to work on that at the moment. i recall i stopped using hakyll when ghc had issues on macos release.
19:59:29 <mmaruseacph2> hakyll builds with stack, I'm compiling a hakyll project as we speak
20:00:21 <parsnip> oh, it might be macos related.
20:00:34 <kadoban> parsnip seems to be getting some really crazy error message that I've never seen before, yeah hakyll has been in stackage for like ... all eternity now.
20:00:53 <parsnip> there's five recent issues, some more similar.
20:01:15 <kadoban> You found 5 ways to get hakyll to not build?
20:01:21 <mmaruseacph2> I'm on linux at the moment, so might be just macos, I could try building there, one second
20:01:25 <parsnip> no, five issues on github, sorry.
20:01:47 <parsnip> i did a git clone and cabal new-build
20:02:09 <parsnip> did cabal install cabal-install prior.
20:02:46 <kadoban> The only non-buildy one I see is what I assume is yours. There's also a thing about nightly, but that's just an automated "hey fix your bounds" thing.
20:04:29 <parsnip> issues 606, 595, 579, 544, 526, some less related though.
20:05:59 <mmaruseacph2> 595 could be closed, nightly has moved past that point
20:06:05 <mmaruseacph2> and hakyll is already in nightly
20:06:16 <mmaruseacph2> so stack should be able to build it
20:06:40 <kadoban> 544 is not something that would affect stack, 579 I'm not sure what that is, maybe something similar to yours.
20:07:21 <mmaruseacph2> 544 can also be closed
20:08:00 <kadoban> Hmm right
20:08:28 <mmaruseacph2> 579 I think it's just some dll not found in path, not a hakyll issue though
20:09:08 <mmaruseacph2> 526 is similar, but on a linux
20:09:34 <mmaruseacph2> 579 is the closest to 606 though
20:15:20 <parsnip> https://github.com/commercialhaskell/stack/issues/740
20:16:14 <parsnip> https://github.com/haskell/cabal/issues/2715
20:21:43 <mmaruseacph2> parsnip: so, I cloned my repo on a mac, and then stack build --fast on it and it seem to have finished building
20:22:12 <mmaruseacph2> so I'd say it's something related to your system's configuration, not really an issue on hakyll's side
20:23:02 <parsnip> are you on macos or osx?
20:23:17 <mmaruseacph2> macos high sierra
20:24:23 <parsnip> okay, thanks for testing it.
20:25:22 <mmaruseacph2> you could try stack unpack hakyll; go in the new directory stack init --resolver=nightly and then stack build
20:28:02 <parsnip> hmm, should i take suggestion to use --solver?
20:28:49 <parsnip> http://lpaste.net/2849095551125815296
20:30:46 <mmaruseacph2> oh, you got the 4.10 instead of 4.11
20:30:57 <mmaruseacph2> try stack init then
20:31:21 <mmaruseacph2> (remove the stack.yaml file)
20:32:30 <parsnip> it's build 36 items
20:32:34 <parsnip> *building
20:32:41 <mmaruseacph2> perfect
20:33:22 <parsnip> did unpack get a version better suited than my git clone?
20:33:49 <ion> Hi, are there any active projects that provide an S-expression syntax for Haskell? Projects I can find seem to be somewhat dead. Or any other ideas on how to generate Haskell types and data structures from a single data structure in a nicer manner than Template Haskell?
20:34:22 <ski> hm, i suppose Liskell is not active anymore ?
20:34:36 <ion> That seems to be the most dead out of the ones I could find.
20:35:14 <ski> heh
20:36:03 <mmaruseacph2> parsnip: yes, unpack gives you one that stack tested (or the last one from Hackage if not found in any stack snapshot)
20:36:17 <ski> maybe therp (author of Liskell) could give some suggestion. or maybe not
20:37:19 <parsnip> weird, i thought i had tried `stack install hakyll`
20:37:49 <ski> (perhaps #esoteric, or one of the lisp channels, would have an idea. not sure)
21:01:15 <parsnip> http://lpaste.net/361943
21:01:33 <parsnip> Cabal-simple_mPHDZzAJ_2.0.1.0_ghc-8.2.2: Encountered missing dependencies:
21:02:46 <parsnip> i think this motivated me to try cabal new-build, i was only guessing that removing stack from the picture might make things simpler. but then i found i couldn't install with new-build.
21:36:33 <ion> ski: Thanks for your input.
21:54:08 <iqubic> parsnip: What dependencies are you making?
21:54:20 <iqubic> s/making/needing/
21:54:40 <iqubic> Also try "cabal-install dep"
21:59:21 <mniip> okay I take some of my words back
21:59:28 <mniip> debugging C++ can be as bad as debugging haskell
21:59:39 <mniip> if you're full of template madness
21:59:59 * pacak likes debugging haskell
22:01:22 <mniip> pacak, I mean stepping through code
22:01:37 <mniip> not cases where a simple Debug.Trace can save the day
22:06:54 <c_wraith> I wasn't aware such cases exist
22:36:27 <woodson> ffi javascript can only be used with ghcjs?
22:39:48 <dmj`> woodson: yea
22:41:15 <woodson> is there a way to use it with ghc?
22:41:44 <woodson> I am trying to figure out how to run a third party function to initialize a dropdown.
22:56:48 <dmj`> woodson: not sure what you’re trying to do.
23:42:29 <cocreature> wonko7: what do you expect javascript ffi to do outside of ghcjs?
23:42:42 <cocreature> shell out to nodejs?
23:42:51 <pk6vx0x2> cocreature: wrong person.
23:43:24 <cocreature> ah sry, they left already
