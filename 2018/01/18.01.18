02:05:26 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | AoC leaderboard 43100-84040706'
02:05:26 --- topic: set by glguy on [Thu Nov 30 21:14:35 2017]
02:05:44 <__monty__> geekosaur: Thank you.
02:07:44 <phadej> duh, __monty__ left before one had an opportunity to tell about: https://pvp.haskell.org/faq/#how-does-the-pvp-relate-to-semantic-versioning-semver
02:08:28 <geekosaur> or https://wiki.haskell.org/Shared_libraries_and_GHC which explains some of the reasons
02:11:54 <royal_screwup21> if you were to define a datatype for a SET, would this be the right way to go about it: Set a = Set a? My textbook says it should be Set a = Set [a] and I'm not sure why this is better (if it is).
02:12:00 <royal_screwup21> Set*
02:13:25 <royal_screwup21> the assumption I made when I defined it my way was that 'a' would always be a list
02:13:43 <geekosaur> but you have nothing that forces it to be a list
02:14:02 <geekosaur> the second one takes the element type as parameter, and forces it to be a list
02:14:08 <geekosaur> *produce a list
02:17:19 <geekosaur> more generally: the only time you want to expose the implementation like that is when it is part of the interface. if you are creating a Set that is internally a list, you do not generally want to expose that fact
02:17:52 <geekosaur> or force the user to know it
02:23:07 <mevsthevoices> hey, if there's anyone around that has a minute to help a n00b? http://lpaste.net/361756 . Am trying to pass an array IO [Int] in to a function ctree :: (Ord a) => [a] -> Tree a, getting an error from ghci
02:25:41 <sanitymug> ctree <$> getBlock
02:25:57 <sanitymug> or: fmap ctree getBlock
02:26:06 <sanitymug> IO a /= a
02:27:10 <sanitymug> getBlock >>= \ block -> pure (ctree block)
02:27:22 <sanitymug> mevsthevoices: ^^
02:27:54 <geekosaur> in general you don't pass IO actions around unless there is a need to bind them in a particular context. you bind the result of the IO action and use it
02:28:36 <geekosaur> @where iotut
02:28:36 <lambdabot> https://www.vex.net/~trebla/haskell/IO.xhtml
02:29:14 <mevsthevoices> sanitymug: now I just need to figure out how you did that xD, thank you very much!
02:30:34 <mevsthevoices> geekosaur: Is that what it's saying? that IO [Int] is an action that still needs to be applied? I thought it was meaning that it was type IO Int?
02:31:44 <geekosaur> mevsthevoices, both, depending on how you look at it
02:31:54 <geekosaur> (IO a) is an IO action that has not yet happened
02:32:35 <geekosaur> you can't, in general, force it to happen. but you can say what to do when it does happen, using >>= (or <- in ghci or a do block)
02:32:40 <Athas> Does anyone know why Hackage adopted the slightly idiosyncratic PVP rather than SemVer?  My suspicion is that the PVP was designed to be compatible with already existing practice in the Haskell community, but the spec is not clear about that.
02:33:20 <geekosaur> [18 10:07:22] <phadej> duh, __monty__ left before one had an opportunity to tell about: https://pvp.haskell.org/faq/#how-does-the-pvp-relate-to-semantic-versioning-semver
02:33:20 <geekosaur> [18 10:08:06] <geekosaur> or https://wiki.haskell.org/Shared_libraries_and_GHC which explains some of the reasons
02:33:42 <osa1> what is idiosyncratic about PVP?
02:33:52 <geekosaur> or for the tll;dr set: it *is* semver. b ut semantic versioning in haskell is more complicated than in other languages
02:34:25 <Athas> osa1: what's subjective, of course.  But my own impression is that SemVer is more similar to older version numbering conventions.
02:34:26 <geekosaur> because of things like instances being global, and the complications discussed in the shared libraries wiki article
02:35:49 <Athas> To me, the biggest difference between SemVer and PVP is the fact that in PVP the "major version" is the first two numbers together.  That seems to have little technical justification behind it.
02:35:49 <Athas> This is not really something that affects me in any way, I'm just curious.
02:36:59 <geekosaur> Athas, that's not something the PVP invented. ever look at how linux kernel versions work?
02:38:32 <mbrock> ... https://twitter.com/meekaale/status/953938713670807553 -- I am becoming a bit tired of coding Haskell programs using records, Data.Map, and IDs... does anyone feel the same?
02:38:40 <mevsthevoices> I get what I was messing up, thank you guys very much :)
02:39:07 <mbrock> it feels like I am constantly reinventing some form of relational paradigm
02:39:12 <mniip> mbrock, that's what lens is about
02:39:14 <Athas> geekosaur: those are mostly aesthetic, I think.
02:39:18 <Athas> They change when Linus feels like it.
02:39:23 <mbrock> mniip: yeah, lens makes it more bearable...
02:39:32 <mniip> you still have a huge nested record
02:39:35 <geekosaur> [18 10:07:22] <phadej> duh, __monty__ left before one had an opportunity to tell about: https://pvp.haskell.org/faq/#how-does-the-pvp-relate-to-semantic-versioning-semver
02:39:35 <geekosaur> [18 10:08:06] <geekosaur> or https://wiki.haskell.org/Shared_libraries_and_GHC which explains some of the reasons
02:39:36 <geekosaur> er
02:39:47 <geekosaur> guess I didn;t save that to the buffer, sorry
02:39:55 <mniip> but lens lets you write comfortable accessors
02:40:07 <mniip> and other things
02:40:27 <geekosaur> solaris did the same thing until around 2.7 when sun decided to change it, and thereby confused everything more (especially since the kernels continued to use the old versioning which was different from both)
02:40:43 <mbrock> I think it's the hierarchical nature of records that is starting to seem unnecessary and cumbersome to me
02:40:56 <geekosaur> but I have a feeling this will not go anywhere. any more "I don't like it" is supposed to be treated as law.
02:42:45 <mbrock> and I start to envy paradigms like Prolog where you can just say "ok, Joe is the brother of Amy" instead of, like, `unless (people ^? ix "Amy") (people . at "Amy" .= mempty); people . at "Amy" . siblings += "Joe"` etc etc
02:43:51 <mbrock> of course I could do `siblinghoods += ("Amy", "Joe")` or some such...
02:44:34 <mbrock> but the "huge nested records with IDs and maps + lens" seems to be more or less a standard paradigm of contemporary Haskell
02:45:34 <mbrock> oh and "manipulated within a program-encompassing state monad"
02:46:04 <mbrock> it's kind of like typesafe JavaScript as an EDSL
02:47:13 <royal_screwup21> what does this declaration mean? newtype Set a = Set (M.Map a ()) -- specifically, the M.Map a () part?  Are we creating a map where the key is of parameter a and its value is a set?
02:48:00 <geekosaur> a map where the key is of type a and the value is unit
02:48:03 <geekosaur> :t ()
02:48:06 <lambdabot> ()
02:48:16 <royal_screwup21> ah
02:48:40 <mevsthevoices> ++geekosaur
02:49:03 <kahlil29> is it possible to remove duplicates from a list using the `nub` function? But I need to remove duplicates entirely. Example : [1,2,3,4,2,4] -> [1,3]
02:49:12 <mniip> hmm
02:49:13 <mbrock> hmm, `ixset` is an interesting library for what I've been complaining about
02:49:32 <mniip> Set is a contravariant functor from the category of preorders to the category of types
02:52:27 <Saizan> > concat . filter (\ x -> case x of [_] -> True; _ -> False) . group . sort $ [1,2,3,4,2,4]
02:52:31 <lambdabot>  [1,3]
02:54:36 <ertes-w> mbrock: if i were competent enough, i'd implement a GHC extension for row types
03:00:12 <AWizzArd> I found this link and it seems to pretty much offer the full book. Could an owner of the book please confirm that it is the complete one? http://chimera.labs.oreilly.com/books/1230000000929/index.html
03:00:26 <AWizzArd> This is Simon Marlow’s „Parallel and Concurrent Programming in Haskell”
03:02:24 <mrkgnao> AWizzArd: it i
03:02:26 <mrkgnao> is*
03:02:37 <AWizzArd> k, thx
03:05:41 <sanitymug> Do I understand it correctly, that PVP (https://pvp.haskell.org/#decision-tree) does not allow version change 0.1.1 -> 0.2.0  but only -> 0.2.1?
03:07:36 <merijn> sanitymug: You do not understand correctly, no
03:08:07 <merijn> That flowchart is ambiguous
03:08:14 <sanitymug> merijn: they seem to fix A B and C int hat diagram
03:08:19 <merijn> It implies C must stay the same, which is not true if you bump A/B
03:08:57 <merijn> sanitymug: Note that the text above does not say the same thing as the flowchart
03:09:07 <royal_screwup21> is it possible to see the function definition on ghci?
03:09:39 <royal_screwup21> apparently not, huh
03:09:48 <merijn> sanitymug: "Breaking change. If any entity was removed, or the types of any entities or the definitions of datatypes or classes were changed, or orphan instances were added or any instances were removed, then the new A.B MUST be greater than the previous A.B. Note that modifying imports or depending on a newer version of another package may cause extra orphan instances to be exported and thus force a
03:09:54 <merijn> major version change."
03:09:55 <sanitymug> royal_screwup21: but you can see where it was defined, with :info
03:09:58 <merijn> sanitymug: Note that it does not refer to any restrictions on C at all
03:10:26 <merijn> sanitymug: If C had to stay the same, 90% of hackage would be wrong :)
03:10:45 <sanitymug> merijn: yes, but still picture is part of spec and kinda may cause confusion :-|
03:11:03 <merijn> sanitymug: I've never seen that picture before, tbh
03:11:24 <merijn> sanitymug: You can file a bug report on github, seems to be a link in the bottom
03:13:14 <sanitymug> merijn: I know it makes only little sense... hadn't noticed github link, thanks :-)
03:26:16 <merijn> sanitymug: As a sidenote, the PVP only says when you *have* to bump versions, you're allowed to do so even when not breaking things, although that'd probably piss of your users :p
03:27:43 <mbrock> I've never really used type lits or families, but I just had the notion of making a data type used like `Staged 2 n Int` which would evaluate to `Void` when `n < 2` and `Int` when `n >= 2`
03:28:01 <mbrock> to be used in e.g. an AST record that goes through stages of analysis
03:29:05 <merijn> mbrock: What's the question, exactly?
03:30:34 <mbrock> I don't know how to define it. `Staged i n = ` and then I'd want to do a conditional (if less than) but that's probably not how to do it
03:31:16 <sanitymug> merijn: about pvp: There seem to already have been issue #14, so I created pr for that
03:31:41 <merijn> mbrock: Data.TYpe.Bool?
03:31:53 <merijn> mbrock: https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Type-Bool.html#t:If
03:32:00 <mbrock> oh! okay, cool, thanks
03:33:12 <phadej> note: the new C can be whatever (and can be void); you don't need to set it to 0
03:33:20 <phadej> sanitymug: ^
03:33:34 <phadej> e.g. if there's breaking change in 1.2.3, new version can be 1.2.1
03:33:43 <phadej> sorry
03:33:45 <phadej> e.g. if there's breaking change in 1.2.3, new version can be 1.3.1
03:33:55 <phadej> or 1.3 (or even 1.4)
03:34:14 <phadej> (or 2, or 2.1 or ...)
03:34:36 <geekosaur> 2.6 -> 7 :p
03:35:30 <merijn> phadej: He's right that the flowchart is wrong, though
03:35:38 <merijn> phadej: Because the flowchart appears to fix C
03:36:30 <phadej> yes it's wrong, but the fix makes it wrong in different way
03:36:36 <phadej> that's the problem with giving /an/ example
03:37:21 <sanitymug> even if that in just one of possible interpretations of text, I would really like it to be resseting, as that seems more common and people are more likely to consult easy to understand image than reading through text
03:38:59 <phadej> sanitymug: well, you can try to convince edwardk not to use truncated versions, e.g. https://hackage.haskell.org/package/nats-1 ;)
03:40:10 <phadej> resetting is obligating requirement, there /could/ be non-released version which is 1.2.0, but for reason or another never released.
03:40:18 <phadej> it could be tagged in repository for example
03:40:33 <phadej> that happened e.g. with https://hackage.haskell.org/package/Cabal-2.0.0.2https://hackage.haskell.org/package/Cabal-2.0.0.2
03:40:36 <phadej> https://hackage.haskell.org/package/Cabal-2.0.0.2
03:40:44 <sanitymug> phadej: I just think that resetting example is better than fixing example
03:41:03 <phadej> sanitymug: i'd use C' ;)
03:41:19 <merijn> a better way would be to not reuse C in the "new" version for an a/b bump
03:41:49 <phadej> I have mixed feelings, the chart helps with understanding, but I don't know how to phrase that "if in doubt consult the text"
03:43:02 <sanitymug> phadej: I can also make pr with B' and C' ;-)
03:44:27 <phadej> "If your last release's version was A.B.C, what should be the next release version X.Y.Z?", and then "major bump, "X.Y > A.B, for example X.Y.Z = A.(B+1).0 or .. or ..."
03:44:33 <mbrock> this seems to require undecidable instances: `type family Staged i n a where { Staged i n a = If (i <=? n) a () }`
03:45:03 <tabaqui> Monomorphic restriction looks is a hard bitch, is it a fundamental attribute of Haskell, or a imperfection of GHC?
03:45:15 <tabaqui> s/looks is/is
03:46:12 <[exa]> tabaqui: a design choice on a tradeoff introduced between polymorphism and memoization/inlining capabilities
03:48:52 <tabaqui> can we get both if GHC would more complicated?
03:49:00 <tabaqui> *would be
03:49:40 <merijn> tabaqui: The monomorpism restriction is GHC protecting you against yourself being dumb
03:49:50 <sanitymug> phadej: hmm, the image says that what your new version "should" be, not must, anyway, suggesting zeroes seem like good suggestion
03:49:53 <merijn> It's literally the most trivial thing to solve
03:50:12 <merijn> tabaqui: And no, you can't get both
03:50:57 <phadej> sanitymug: fair point, yet then it doesn't convey the "must" of "X.Y > A.B" :)
03:51:08 <phadej> infografics are hard
03:51:13 <merijn> tabaqui: There's two possible choices to prevent unexpected computation blowup/memory blowup: 1) fail at compile time for things that look like values but are polymorphic or 2) silently become slower/consume more memory than expected at runtime
03:51:32 <merijn> tabaqui: Clearly, 1 is the only reasonable choice, which is why code that violates MMR does not compile
03:51:48 <merijn> tabaqui: Which is not a problem since making code that fails due to MMR compile is trivial
03:55:49 <tabaqui> merijn: actually, I've just enabled -Wmonomorphism-restriction and got a lot of warnings
03:56:17 <merijn> tabaqui: You shouldn't have to enable it, it should be on by default
03:56:24 <tabaqui> that means, that GHC already made some choice about polymorphic "values"
03:56:40 <tabaqui> merijn: I compile all of my code with -Wall -Werror
03:57:01 <merijn> tabaqui: GHC automatically monomorphises polymorphic values so it works as expected
03:57:03 <tabaqui> here it says that -Wall doesn't enable MR
03:57:04 <tabaqui> https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/using-warnings.html
03:57:20 <merijn> You only get MMR failures if it *can't* monomorphise (due to, e.g. conflicting uses)
03:58:03 <merijn> tabaqui: That warns when GHC monomorphises a value, which is uninteresting and can be ignored
03:59:43 <merijn> tabaqui: Basically if you write "foo = [1..1000000]" that looks like a value and you'd EXPECT it to only get computed once. But of course the real type is "foo :: Num a => [a]", so now you have 2 choices. Either store the entire huge list for ALL different types 'a' that it is used as (bad) or recompute it every time it is used (bad, because you don't expect it to be recomputed every time, since it looks
03:59:49 <merijn> like value)
04:00:47 <merijn> tabaqui: GHC will monomorphise values like that. Say, you use 'foo' in a place where you need "[Int]" GHC will go "welp...let's just do 'foo :: [Int]'" and now you can compute it once and only store the Int version. (this is what the -Wmonomorphism-restriction warning tells you about)
04:01:43 <merijn> tabaqui: The problem is: What if I use foo as BOTH [Int] AND [Double]? Now it can't monomorphise it to [Int] anymore, so we're back to the old problem of "store all copies" OR "recompute always". This is when GHC errors with the "dreaded" MMR error
04:01:50 <tabaqui> well, that means that I'll get default warning when I use polymorphic "value" without signature?
04:02:37 <merijn> tabaqui: Monomorphisation is different from defaulting. Defaulting happens when you can pick any type and it doesn't know which type to infer.
04:03:17 <merijn> tabaqui: monomorphisation happens when something can pick any type and *elsewhere in the program* GHC sees you really just wanted [Int] (so unlike defaulting monomorphisation is not ambiguous)
04:03:56 <merijn> tabaqui: If the monomorphisation *is* ambiguous (due to multiple uses) it just errors
04:04:39 <merijn> Of course, if you have conflicting uses of 'foo' that GHC is warning about you can simply tell it "I'm fine with recomputing every time" by adding an explicit polymorphic type signature to 'foo', in which case the whole problem disappears
04:07:14 <mniip> merijn, I feel like there is something like a solution
04:07:28 <merijn> mniip: Which is?
04:08:44 <mniip> hmm
04:09:58 <mniip> by the time a real program is compiled all types at which this value is used are known
04:10:39 <mniip> instantiate a map indexed by instance heads
04:10:47 <mniip> with values thunks at each type
04:11:53 <merijn> mniip: That only applies to whole-program optimising compilers
04:12:10 <merijn> mniip: GHC can't do that, due to the fact that modules/libraries are compiled independently
04:12:10 <tabaqui> merijn: ok, I understand, thanks
04:12:13 <mniip> ghc could do that if it wanted to
04:12:46 <merijn> mniip: Not without investing hundreds of thousands of man hours and making everyone's compilations SUPER slow
04:13:03 <merijn> mniip: There's a reason there aren't many whole-program optimising compilers around
04:13:13 <mniip> any 'C \bar{sigma} => t' "function" you import from a module you can turn into such a thunk map
04:13:27 <mniip> oh, except the library is linked against the function
04:13:51 <mniip> okay how about a super simple solution
04:13:56 <mniip> instance dictionaries are CAFs
04:14:00 <mniip> so they have stable pointers
04:14:08 <mniip> memoize the "function" over the pointer
04:14:09 <merijn> I mean, the MMR is not some dumb oversight in the report. It's a tricky design trade-off and I'm convinced the MMR is the simplest/most ideal choice
04:14:24 <mniip> probably
04:14:30 <mniip> I'm not disagreeing with that point here
04:14:40 <mniip> just exploring the design space
04:14:56 <mniip> oh hmm, sometimes dictionaries are functions and not CAFs
04:15:44 <mniip> okay, tricky
04:16:39 <mniip> sometimes via polymorphic recursion you can end up with a linearly-sized type with a linearly sized instance dict
04:16:47 <mniip> memoizing such a recursion would require quadratic space
04:24:46 <mniip> % foo = maxBound
04:24:47 <yahb> mniip:
04:24:53 <mniip> % instance Bounded a => Bounded (Maybe a) where minBound = Nothing; maxBound = Just maxBound
04:24:54 <yahb> mniip:
04:25:00 <mniip> % bar = go () where go :: (Show a, Monoid a) => a -> String; go j = show (foo `asTypeOf` j) ++ go (Just j)
04:25:00 <yahb> mniip: ; <interactive>:3:73: error:; * Could not deduce (Bounded a) arising from a use of `foo'; from the context: (Show a, Monoid a); bound by the type signature for:; go :: forall a. (Show a, Monoid a) => a -> String; at <interactive>:3:19-57; Possible fix:; add (Bounded a) to the context of; the type signature for:; go :: forall a.
04:25:05 <mniip> er oops
04:25:09 <mniip> % bar = go () where go :: (Show a, Bounded a) => a -> String; go j = show (foo `asTypeOf` j) ++ go (Just j)
04:25:09 <yahb> mniip:
04:25:41 <mniip> bar does polymorphic recursion building up a linearly sized instance dict
04:25:51 <mniip> % take 100 bar
04:25:51 <yahb> mniip: "()Just ()Just (Just ())Just (Just (Just ()))Just (Just (Just (Just ())))Just (Just (Just (Just (Just"
04:34:57 <merijn> Anyone know what the best way to reach Lennart would be if I wanna patch one of his packages on Hackage?
04:35:49 <mniip> prayers?
04:36:05 <merijn> mniip: Not an ideal solution :p
04:36:39 <hpc> have you tried turning it off and on again?
04:40:38 <merijn> hpc: I can just inline the code in my project since it's small, but I dislike fixing something for *me* when I could be fixing it for *everyone*
04:42:04 <hpc> doesn't he work for a university? i bet you could get his email from one of his published papers
04:42:41 <merijn> hpc: He works for Standard Chartered, afaik
04:43:10 <hpc> ah
04:43:41 <hpc> message him on github?
04:43:55 <merijn> hpc: There's no github/repo link with the packages
04:44:28 <merijn> Else I'd just open a PR :p
04:44:33 <hpc> heh
04:44:40 <hpc> that's all i can think of :(
04:45:28 <merijn> hpc: I figure someone in the Haskell community must now :p
04:46:43 <merijn> s/now/know
04:47:57 <hpc> ooh ooh
04:48:00 <hpc> mailing list archives
04:48:23 <hpc> i bet you can get his email from that, if he's ever sent anything
04:49:48 <sanitymug> let f = fromRational . toRational in f (30::Double) :: NominalDiffTime
04:49:59 <sanitymug> anybody knows better impl for f? ^^
05:31:18 <hexagoxel> sanitymug: 30 :: NominalDiffTime
05:32:17 <hexagoxel> are you sure you need `f` ?
05:34:15 <hexagoxel> (also, realToFrac)
05:49:39 <sanitymug> hexagoxel: thansk for realToFrac. Yes, I am getting data from outside in (Time a) from dimensional package and I need to modify timestamp based on that (and I wanted something that would make constraint as small as possible, but haven't specifed that)
05:50:28 <matheus23> @djin a -> a
05:50:28 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
05:50:37 <matheus23> @djinn a -> a
05:50:37 <lambdabot> f a = a
05:50:44 <matheus23> @djinn Int -> Int -> Int
05:50:44 <lambdabot> Error: Undefined type Int
05:50:54 <matheus23> @djinn [a] -> a
05:50:54 <lambdabot> Error: Undefined type []
05:51:03 <matheus23> @djinn Either a b -> a
05:51:03 <lambdabot> -- f cannot be realized.
05:51:12 <matheus23> @djinn a -> Either a b
05:51:12 <lambdabot> f = Left
05:52:07 <Gurkenglas> You can see [a] as (forall b. (a -> b -> b) -> b -> b), and then djinn can work with it
05:53:06 <Gurkenglas> ...I thought, though I can get neither of the approaches I had in mind to work in query. ._.
05:53:57 <EvanR> boggling at that supposed analog of a list
05:53:58 <Gurkenglas> Ah, of course. It's because [a] -> a can't actually be realized :D
05:54:40 <opqdonut> EvanR: representing data structures as their catamorphism, standard lambda calculus encoding
05:54:51 <EvanR> ok, thats foldr
05:54:56 <opqdonut> church encoding?
05:55:10 <opqdonut> yeah I guess that's the right term
05:55:35 <Gurkenglas> @djinn (a -> c) -> (forall b. (a -> b -> b) -> b -> b) -> (forall b. (c -> b -> b) -> b -> b)
05:55:36 <lambdabot> f _ _ _ a = a
05:55:56 <Gurkenglas> For example, this is the implementation of map that discards all the list elements.
05:56:03 <opqdonut> so cute
05:56:34 <opqdonut> yeah djinn will return [] for any function that's supposed to return a list
05:56:38 <opqdonut> that's the easiest way out
05:57:12 <EvanR> i like djinn's style
05:57:21 <phadej> "easiest way out" ? :)
05:57:21 <opqdonut> @djinn (forall b. (a -> b -> b) -> b -> b) -> a
05:57:21 <lambdabot> -- f cannot be realized.
05:57:22 <Gurkenglas> Looks like it can't work with streams :(
05:57:22 <Gurkenglas> @djinn (a -> c) -> (forall b. (a -> b -> b) -> b) -> (forall b. (c -> b -> b) -> b)
05:57:22 <lambdabot> -- f cannot be realized.
05:57:41 <opqdonut> oh right yeah head is not total, my bad
05:57:41 <EvanR> don't do any more than strictly necessary
05:57:41 <Gurkenglas> opqdonut, it is correct in that case, [a] -> a can't be realized
05:57:44 <opqdonut> yeah
05:58:20 <Gurkenglas> I suppose djinn doesn't use fix.
05:58:39 <Gurkenglas> @djinn (forall f. (f -> f) -> f) -> (a -> c) -> (forall b. (a -> b -> b) -> b) -> (forall b. (c -> b -> b) -> b)
05:58:39 <lambdabot> -- f cannot be realized.
05:58:40 <opqdonut> yeah well djinn is a theorem prover and fix makes the logic inconsistent...
05:58:43 <Gurkenglas> Not even if you give him one.
05:59:36 <phadej> systemf (rankntypes) isn't decidable, and djinn doesn't try to be too clever
05:59:43 <opqdonut> @djinn ((Void -> a) -> a) -> a
05:59:43 <lambdabot> f a = a void
05:59:51 <Gurkenglas> @djinn (forall f. (f -> f) -> f) -> (forall x. x -> x) -> a
05:59:51 <lambdabot> -- f cannot be realized.
06:00:01 <Gurkenglas> Doesn't even think of applying its first argument to its second
06:00:04 <cheater> hi
06:00:47 <Gurkenglas> The forall magic's the problem somehow?
06:00:48 <Gurkenglas> @djinn ((a -> a) -> a) -> (a -> a) -> a
06:00:48 <lambdabot> f a = a
06:00:56 <opqdonut> rank n types, yeah
06:01:06 <opqdonut> @djinn ((a -> a) -> a) -> (b -> b) -> a
06:01:07 <lambdabot> f a _ = a (\ b -> b)
06:01:18 <opqdonut> clever
06:01:48 <opqdonut> but yeah, rankntypes make things hard as phadej said
06:02:09 <opqdonut> I guess rank2types is a bit more tractable, but nobody's bothered to implement a djinn2
06:02:59 <cheater> can someone suggest a good io library to use for this? conduits, machines, something else? i want constant-space io and it should perform pretty well. i have two threads, one gets data from a C-based IO layer as ints and should push to a second thread through a fixed-sized queue. the first thread should block if the queue is full. the second should block if it tries to read and it's empty. the second ...
06:03:05 <cheater> ... thread will process this data in some way and put it out to stdout.
06:03:22 <phadej> inference is possible for rank2types, but I'm don't remember about synthesis, and whether they are equivalent.
06:03:57 <Gurkenglas> Is it possible for rank<=ntypes for any n?
06:05:00 <phadej> only for 1 and 2
06:05:04 <phadej> 3 is undecidable
06:05:49 <opqdonut> do you have a simple undecidable rank3 sentence at hand?
06:05:53 <tdammers> bogodjinn: just try random functions until you run into something that typechecks
06:06:50 <hodapp> tdammers: is that really that much different from just trying out code in $language until the tests pass?
06:07:00 <tdammers> hodapp: not at all
06:07:05 <lyxia> opqdonut: undecidability can not be proved by counterexample
06:07:52 <opqdonut> lyxia: of course it can?
06:08:29 <Gurkenglas> sure it can, you provide a sentence that a brute-force ZFC theorem prover cannot ever decide
06:08:30 <opqdonut> oh sorry I mixed up my definitions
06:09:26 <opqdonut> hmm well you can still do something semi-constructive, like embed the liar's paradox
06:09:29 <opqdonut> a la gödel
06:09:40 <lyxia> "there is no algorithm that outputs the right answer for all inputs"
06:09:47 <lyxia> you do not prove that by exhibiting a single input
06:10:10 <lyxia> because for every input either of "always output YES" or "always output NO" outputs the right answer
06:10:32 <opqdonut> yeah but you can have a construction that works given an algorithm X
06:10:41 <lyxia> sure.
06:10:54 <opqdonut> but I was thinking about completeness and not decidability I guess
06:11:05 <opqdonut> been some time since my logic classes
06:12:07 <EvanR> i still cannot wrap my head around incompleteness
06:12:20 <EvanR> but then, the obvious halting problem has that as a special case
06:13:44 <phadej> undecidability in this case means `for all algorithms. there are inputs for which the algorithm won't terminate, i.e. cannot say neither "well-typed" nor "ill-typed"`
06:14:26 <phadej> so yes, it's kind-of halting problem
06:14:53 <phadej> you obviosly can have /approximate algorithms/, which can give up and say "I don't know"
06:14:53 <ertes-w> slightly relevant: http://blog.sigfpe.com/2008/02/how-many-functions-are-there-from-to.html
06:15:15 <phadej> and that's what GHC does, at that point you have to help and provide type-signatures
06:15:25 <Lowl3v3l> EvanR: want a real world example of incompleteness?
06:15:45 <Lowl3v3l> EvanR: no compiler can find semantic errors.
06:16:07 <Gurkenglas> We could, given the laws of physics, construct the turing machine that simulates our universe, and pick a theorem we never end up being able to decide
06:17:07 <mniip> 1516284539 [17:08:59] <opqdonut> hmm well you can still do something semi-constructive, like embed the liar's paradox
06:17:08 <mniip> what no
06:17:09 <merijn> Lowl3v3l: That's not an example of incompleteness, and an example of the limits of formal methods
06:17:12 <mniip> that's not how that works
06:17:49 <Lowl3v3l> merijn: actually thats a direct conclusion from Rice's theorem ;)
06:17:50 <mniip> godel's incompleteness follows from the halting problem
06:18:22 <Lowl3v3l> merijn: and as you may know, Rice's theoem and the halting problem are pretty much interconnected.
06:18:25 <EvanR> "semantic errors" ?
06:19:08 <infandum> Does this function exist? (Applicative f) => (a -> b -> c) -> a -> f b -> f c
06:19:08 <mniip> I vaguely remember that if free semigroup word equivalence is decidable, then all formulae in formal arithmetic are decidable
06:19:15 <Lowl3v3l> EvanR: take for example this case : i want to compute fibonacci numbers, but do start with the wrong starting numbers, e.g. 4 and 5. the resulting list is wrong. this is a semantic error
06:19:31 <merijn> infandum: That's just "\f a b -> f a <*> b"?
06:19:32 <Lowl3v3l> mniip: if i remember correctly you do as well^^
06:19:33 <hyperisco> infandum, are you asking if it is implementable?
06:20:07 <hyperisco> well it isn't quite that merijn or else I need my tea
06:20:14 <ertes-w> replace (<*>) by (<$>)
06:20:20 <merijn> hyperisco: You're right, I'm sloppy
06:20:25 <mniip> no, the other way around
06:20:28 <mniip> ugh
06:20:48 <hyperisco> mniip how am I to tell you apart from merijn?
06:20:49 <mniip> basically you connect turing machines, semi-thue systems, free semigroups, and formal arithmetic
06:21:00 <mniip> into one long chain of "imposisble"
06:21:04 <merijn> hyperisco: by reading? ;)
06:21:14 <infandum> Wait ... how about (Applicative t, Functor f) => (a -> b -> c) -> t a -> t (f b) -> t c
06:21:22 <hyperisco> I don't know why but your usernames are nearly the same in my head
06:21:26 <ertes-w> hyperisco: use a client that replaces nicknames by randomly generated avatars seeded from the nickname
06:21:36 <hyperisco> ah ha! maybe there is a plugin for that
06:21:55 <ertes-w> hyperisco: or, slightly less cool, a client that does random colour-coding
06:22:45 <phadej> hmm, my nickcolors have the same color for mniip and merijn, but I guess one could make then different if really needed
06:23:01 <mniip> hyperisco, you can't
06:23:03 <EvanR> Lowl3v3l: so the problem would specifically be posed as, compiler make sure my program computes the fib seq
06:23:10 <mniip> like I said semigroup word equivalence is undecidable
06:23:12 <EvanR> which is defined as...
06:23:33 <EvanR> i am not sure the problem is well defined as yet, to me
06:23:38 <infandum> Gah, I think I got it, it's just not that simple is all.
06:24:36 <Lowl3v3l> EvanR: a computer can not know if the program does what you want it to do, it can't look into your head. Thats not incompleteness directly, but its heavily intertwined with godels theorems
06:26:07 <ertes-w> incompleteness is more like there are semantics(es?!) that can be specified but not verified
06:26:15 <ertes-w> right?
06:27:17 <insanitymug> propositions that are true but can not be prooved so?
06:27:22 <EvanR> if the definitions of what you want are a free choice, what is it even failing to verify
06:28:08 <Lowl3v3l> ertes-w: de facto the task "decide wether what i wrote is what i wanted" is a verification problem , yeah^^ ( but sure, my sloppy example falls short because it is a small metaphor ;)
06:28:43 <EvanR> what insanitymug said is an example of where accounts of incompleteness dont make sense to me
06:29:25 <EvanR> is "what i wanted" another program or something?
06:29:28 <ertes-w> i mean given a formal semantics, which might take the form of a predicate on a function (say, "λ f → ∀ x, f x = f (f x)"), there are functions that satisfy the predicate, but you can't prove it
06:29:30 <EvanR> or specification
06:29:43 <EvanR> written in its own language
06:29:55 <ertes-w> or more simply: there are true propositions that can't be proved
06:30:15 <insanitymug> or rather existence of such propositions in system
06:30:34 <insanitymug> incompleteness is property of system/logic/whatever
06:30:48 <insanitymug> not of particular formula
06:31:21 <TMA> to be precise: if the system does not contain contradiction, there are true propositions that cannot be proved
06:31:31 <insanitymug> what ertes-w said
06:31:58 <TMA> if there is a contradiction you can prove anything (even false propositions)
06:31:58 <EvanR> uh huh...
06:32:11 * EvanR continues in ignorance
06:32:24 <ertes-w> the way i understand it to prove an unprovable proposition (bear with me) you have to embed the calculus in a meta-language that can prove it…  you just can't prove it in the original calculus…  is that accurate?
06:33:10 <TMA> ertes-w: except that there would still remain true unprovable propositions
06:33:36 <EvanR> in what sense can a proposition be true and not provable
06:33:41 <mniip> incompleteness is a statement about a sentence of a theory, in a metatheory
06:34:39 <hyperisco> it comes down to what you mean by "true"
06:34:49 <EvanR> i have no idea
06:34:59 <EvanR> i didnt invent incompleteness
06:35:20 <hyperisco> well, there is some criteria by which you judge something as being true
06:35:31 <ertes-w> well, usually "true" means "has a proof", but that obviously doesn't work here =)
06:35:40 <TMA> EvanR: a proof is a formal description of steps. it is a purely syntactic thing. you start with some propositions that you hold true and a set of rules that transform true propositions to other true propositions
06:35:40 <EvanR> ^
06:35:45 <hyperisco> and in this discussion, the meaning of what is true is changing
06:37:10 <EvanR> TMA: so then, would i expect to be shown a proposition that is true (by that standard) and also has no proof
06:37:19 <ertes-w> the ZFC continuum hypothesis is *not* an example of that, is it?  it can neither be proved nor disproved in ZF
06:37:24 <ertes-w> *ZFC
06:37:41 <TMA> whereas truth is a property of a proposition that the proposition has irrespective as to whether it is reachable by the process of starting with the axioms (the propositions held true) and applying finitely many instances of rules
06:37:56 <EvanR> what
06:38:16 <Logio> EvanR: some examples are listed here: https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems#Examples_of_undecidable_statements
06:38:37 <EvanR> i jumped the gun and thought TMA explain both concepts before
06:39:37 <ertes-w> oh, wait…  so the CH is an example?
06:39:54 <Logio> ertes-w: yes, why wouldn't it be?
06:39:56 <EvanR> Logio: where?
06:40:02 <ertes-w> so incompleteness just means that some statements can neither be proved nor disproved?
06:40:11 <Logio> EvanR: in the linked section
06:40:16 <TMA> ertes-w: no
06:40:41 <Logio> ertes-w: ... in the given system
06:41:13 * EvanR stares at a wikipedia explanation of undecidable stuff, with a reference to CH, not a list
06:41:15 <ertes-w> yes…  so ZFC is incomplete because of the CH?
06:41:33 <TMA> ertes-w: the undecidables can either be true or not. the axiom of choice is undecidable and independent -- there are interpretations (truths) in which it is true and others in which it is false
06:42:27 <EvanR> the tangent into things independent of ZFC seems to be a tangent from incompleteness and what true is
06:43:09 <EvanR> we were talking about logic not set theory
06:43:37 <insanitymug> ⊢ ≡ ⊨ ?
06:43:39 <TMA> ertes-w: provided that you live in a world, where ZFC is true, the CH can be either true or false ; if you live in a world where both ZFC and CH is true, but have only ZFC axioms, you cannot prove that CH is true
06:44:19 <ertes-w> TMA: and that makes ZFC incomplete, because CH is a statement that can't be proved or refuted, right?  that's my question
06:44:48 <ertes-w> if it were complete, all statements could be proved or refuted…  that's how i understand it
06:45:20 <EvanR> thats a totally different story than "there are true statements that can't be proven"
06:45:47 <ertes-w> EvanR: unless "true" means "can't be refuted" =P
06:45:57 <ertes-w> then it's totally the same story =)
06:46:04 <EvanR> that seems different
06:46:30 <TMA> ertes-w: yes. that makes ZFC incomplete; on the other hand, the formulation 'true propositions cannot be proved' is somewhat different. you need a true statement (like: "ZFC does not contradict itself") that cannot be proved in ZFC
06:46:41 <insanitymug> random exceprpt from wikipedia: A set of axioms is (syntactically, or negation-) complete if, for any statement in the axioms' language, that statement or its negation is provable from the axioms.
06:46:42 <EvanR> things are not true until proven false
06:48:06 <ertes-w> TMA: likewise type theory is incomplete because LEM can be stated, but neither proved nor disproved, correct?
06:48:09 <EvanR> that definition makes way more sense
06:49:03 <EvanR> i will pretend that "there are true unprovable propositions" is hyperbole or something
06:50:01 <Logio> EvanR: by that definition, an incomplete system will have a statement which can't be proven false or true
06:50:14 <EvanR> right
06:50:29 <ertes-w> then isn't gödel's incompleteness theorem really a statement about induction?
06:50:32 <Logio> and one would assume such a statement to be in fact, false or true
06:50:41 <EvanR> one would?
06:50:48 <Logio> given axioms
06:50:48 <EvanR> how why what
06:51:04 <ertes-w> "as soon as you have induction in your system, your system is necessarily incomplete"
06:51:16 <EvanR> you could assume a statement is true, as an additional assumption, or false, or not
06:51:52 <dmcmint> does the incompleteness of a system imply there are a set of statements that it can evaluate, or is it more fundamental - the set of statements it can evaluate can never be determined (because you could filter your inputs to only accept valid inputs if they could)?
06:51:53 <EvanR> if its not an assumption one way or another, then you cant rely on it or access it
06:52:03 <EvanR> i see no problem
06:52:22 <Logio> EvanR: meaning, that it could be proven using means outside of the given axioms
06:52:31 <EvanR> what?
06:52:34 <Logio> such as extra axioms
06:52:35 <EvanR> what means that
06:52:45 <phadej> In mathematical logic, a theory is complete if, for every formula in the theory's language, that formula or its negation is demonstrable. Recursively axiomatizable first-order theories that are rich enough to allow general mathematical reasoning to be formulated cannot be complete, as demonstrated by Gödel's first incompleteness theorem.
06:52:49 <TMA> ertes-w: the CH is different from "ZFC does not contradict itself" -- think of a sentence "All the presidents of the USA were males" ... this is not a proposition that is either true or false by itself --- you can think of different histories where there might have been a female president, so you need to specify the history in addition to the statement to tell the truth of it
06:52:50 <phadej> This sense of complete is distinct from the notion of a complete logic, which asserts that for every theory that can be formulated in the logic, all semantically valid statements are provable theorems (for an appropriate sense of "semantically valid"). Gödel's completeness theorem is about this latter kind of completeness.
06:52:57 <phadej> https://en.wikipedia.org/wiki/Complete_theory
06:53:00 <phadej> "complete" is overloade
06:54:09 <ertes-w> TMA: i understand the CH and its independence from ZFC…  i just wanted to understand how it's related to completeness and the incompleteness theorem
06:54:21 <dmcmint> "that formula or its negation is demonstrable." - is the negation the issue due to the principle of explosion?
06:54:21 <EvanR> yeah i am suspecting 100 years of retelling of the incompleteness story
06:54:24 <Logio> EvanR: the point is, adding the axioms to a system does not change whether the statement is true or false, it only allows giving a proof
06:54:33 <ertes-w> phadej: is that a response to my question?
06:54:43 <EvanR> Logio: i dont believe that
06:54:55 <TMA> ertes-w: whereas the statement "either it is not the case that 1 = 1 or it is not the case that it is not the case that 1 = 1" is true for all models that has the equivalent axioms as the usual predicate logic
06:55:19 <dmcmint> wouldn't adding axioms would just change which statements that were undecidable?
06:55:39 <phadej> ertes-w: not particularly, I just lost track of what completeness people are talking right now
06:55:41 <EvanR> you add "CH is true" "CH is false" all the time
06:55:46 <Logio> dmcmint: exactly, or make the system inconsistent
06:56:15 <ertes-w> ah, ok
06:57:08 <Logio> EvanR: I don't think it is known whether either of those makes ZFC inconsistent
06:57:23 <EvanR> or if its already inconsistent
06:57:29 <Logio> that too
06:57:35 <EvanR> so that doesnt even come into play
06:57:43 <EvanR> theres no proof one way or the other
06:57:52 <EvanR> so you just add them as extra rules
06:58:08 <EvanR> like when you add LEM to intuitionism
06:58:22 <EvanR> youre not worrying if it makes the system inconsistent
06:58:27 <TMA> X = { statements that are decidable } Y = { statements that are true or false } Z = { statements } ;; for every sane theory X is subset of Y is a subset of Z ;; moreover for every sane theory there exists a in Y - X
06:58:29 <Logio> EvanR: but if we were to prove that ZFC is consistent for say, CH true, it would mean that it would not be consistent for CH false
06:58:31 <TorkMattar> CH and not CH are known to be consistent with ZFC (if ZFC is consistent), that's what "CH is independant of ZFC" means
06:58:48 <Logio> TorkMattar: oh
06:58:50 <EvanR> how does it even make sense to prove that
06:59:10 <Logio> EvanR: read the sketch of the proof from the wiki
06:59:12 <dmcmint> does GHCI throw an error when you give it an undecidable statement, or is the undesirability undecidable?
06:59:16 <TMA> an example of such a is the sentence "this theory does not contradict itself"
06:59:21 <EvanR> a proof that ZFC is consistent?
06:59:31 <Logio> EvanR: no, the gödel theorem
06:59:37 <dmcmint> undecidablity *
06:59:48 <EvanR> i guess you werent responding to my question
07:00:51 <EvanR> TMA: i dont understand set Y
07:01:38 <TorkMattar> there is no "universal truth", there is only "true in a given model"
07:01:45 <Logio> EvanR: given TorkMattar's comment, CH is not the pathological example I'm thinking of
07:02:14 <Logio> EvanR: the question is, whether there are statements which are unprovable but not independent
07:02:42 <EvanR> that doesnt make sense
07:02:42 <TMA> TorkMattar: there is a "universal truth" formulated that way --- it is "true in any model"
07:02:43 <dmcmint> can you tell if something is undecidable in a given model, i.e. can GHC detect all undecidable Haskell statements?
07:03:15 <Logio> EvanR: so you are claiming that there cannot be such a thing?
07:03:31 <EvanR> that the problem isnt well posed
07:03:42 <TorkMattar> Logio: if a statement is not provable, and neither its negation (in a given theory), then it is independant by definition! So an unprovable statement not independent is just a statement whose negation is provable
07:03:56 <EvanR> ^
07:04:08 <Logio> TorkMattar: is that really true?
07:04:18 <Logio> can you give a mathy reference
07:04:24 <EvanR> as soon as we define these words, stuff evaporates
07:04:46 <EvanR> like waking up from a dream
07:04:55 <TorkMattar> A reference for what? That independent means neither provable nor refutable?
07:05:13 <Logio> TorkMattar: yes
07:05:21 <insanitymug> EvanR: do not tell that to people who spend lots of time thinking about incompletenes... :-)
07:05:38 <dmcmint> isn't knowing they are independent "deciding something" about them?
07:05:44 <TorkMattar> https://en.wikipedia.org/wiki/Independence_(mathematical_logic)
07:06:18 <TorkMattar> 2nd sentence
07:07:18 <Logio> TorkMattar: ok, but this does not then mean that all such statements can be added as axioms without effecting consistency
07:07:23 <EvanR> (wikipedia as a reference...)
07:07:29 <Logio> as is pointed out in the results section
07:08:40 <TorkMattar> Logio: well, if you get a contradiction from adding a sentence phi to a theory T, then in fact T proves not phi
07:08:57 <Logio> TorkMattar: yes, but not within the previous system
07:09:11 <TMA> ah, english term 'independence' is used in narrow sense of 'not provable'
07:09:14 <Logio> which is exactly the point of the incompleteness theorem
07:09:21 <dmcmint> are there any simple/famous examples of something undecidable in number theory? I ask because most of this seems to be about various set theories
07:09:30 <TMA> now it makes sense, why there is a misunderstanding
07:10:05 <TorkMattar> I don't understand your objection Logio
07:10:24 <Logio> TorkMattar: the proof of contradiction cannot be made in the original system of axioms
07:10:33 <lieven> dmcmint: Goodstein's theorem is not provable in Peano Arithmetic
07:11:23 <Logio> TorkMattar: you cannot add something to a theory and stay within the theory
07:11:32 <TorkMattar> agree
07:11:34 <Logio> in the sense we are talking here
07:11:58 <TorkMattar> I think I forgot what was exactly the initial question
07:12:05 <EvanR> you can certainly take something as an assumption and get a contradiction
07:12:09 <Logio> making the statement added as an axiom true or false (by proof made in the expanded theory), but keeping it unprovable within the original theory
07:12:42 <dmcmint> yeah if you add something to a theory you need to run all your unit tests again to see if the old theory still works
07:12:44 <EvanR> thats how you prove something false
07:13:22 <merijn> EvanR: Not in constructive logic
07:13:35 <EvanR> yes in constructive logic
07:13:43 <merijn> Can't prove by contradiction in constructive logic
07:13:44 <EvanR> A -> Void
07:14:00 <EvanR> now youre pulling an unnecessary confusion of terminology
07:14:00 <merijn> eh, wait, I guess you can by contradiction
07:14:16 <Logio> EvanR: but Gödel precisely says that there are statements for which you cannot find the contradiction from the original axioms
07:14:17 <merijn> You can't prove A from "not (not A)"
07:14:18 <ertes-w> merijn: proving false by contradiction is fine
07:14:27 <merijn> ertes-w: Yeah, I got mixed up
07:14:50 <EvanR> talkinga bout not A
07:15:05 <ertes-w> i remember andrej bauer talking about this very confusion of terminology
07:15:09 <EvanR> its like the diff between having an A at the top level or taking it as an argument
07:15:19 <EvanR> (axiom vs assumption)
07:15:48 <ertes-w> i think it was in his "five stages of accepting constructive mathematics" talk
07:16:07 <TMA> well, it was half a semester of dense logic theory before we understood the goedel theorems
07:16:10 <ertes-w> BTW, if you haven't seen it, it's a funny talk =)
07:16:42 <merijn> hmmm
07:16:43 <TMA> no wonder it confuses people :)
07:17:05 <JuanDaugherty> technicall, it's you can't prove by excluded middle, subtle diff
07:17:08 <merijn> Fun times...my haskell is segfaulting my python >.<
07:17:10 <EvanR> ertes-w: https://i.imgur.com/91PpLkb.png :D
07:17:18 <JuanDaugherty> y
07:17:30 <ertes-w> heh
07:17:37 <dmcmint> can a system be complete for a particular domain?
07:17:46 <EvanR> TMA: yet halting problem is pretty straightforward
07:18:01 <merijn> dmcmint: You can get completeness if you're willing to sacrifice expressiveness
07:18:04 <TMA> EvanR: it is the simpler version
07:18:12 <ertes-w> merijn: is that another one of those GHC bugs?  you know, like the one that deleted source files, if you had a type error…
07:18:25 <merijn> dmcmint: You can't be complete AND express every mathematical formula in the same system
07:18:44 <ertes-w> "python?  you gotta be kidding me…  *kills python interpreter*"
07:18:57 <dmcmint> that's fine in the non-abstract
07:19:00 <merijn> dmcmint: So you can have a complete system if you're willing limit the expressiveness of it
07:19:13 <EvanR> can we have a python bug where if you get a runtime error, it deletes python?
07:19:22 <mniip> proposition calculus is complete, right?
07:19:41 <merijn> dmcmint: Consider total languages like Idris, Coq, and Agda. They sacrifice expresiveness for totality. (Well, in some of those totality is optional)
07:19:46 <TMA> dmcmint: for example statements in the language of group theory are all decidable, because there is only one binary functor (therefore you cannot embed peano arithmetics into the language)
07:20:37 <merijn> The formal system Troo, which has 1 statement Troo, which is True. Is trivially complete. Every statement in Troo is provable
07:20:57 <merijn> It's not a very expressive or interesting system, I'll grant you that
07:21:14 <dmcmint> I'm thinking of it from a program perspective and limiting functionality, or input, is necessary to prevent unintended consequences
07:21:21 <merijn> dmcmint: The real question of interest is "how far can we push the boundaries of expressiveness without becoming incomplete"
07:21:21 <TorkMattar> Group theory is not decidable
07:21:45 <TMA> dmcmint: another example is anything that is limited to finite size -- you can just enumerate everything
07:23:15 <TorkMattar> The theory of group is not complete: for instance you cannot prove nor disprove that every elements commute
07:23:16 <dmcmint> merijn: that is an interesting question
07:24:03 <EvanR> how do you express "every elements commute" in just group theory
07:24:15 <TorkMattar> forall a,b  a.b = b.a
07:24:22 <EvanR> group theory has forall ?
07:24:33 <TorkMattar> yes, it's a first order theory
07:24:33 <EvanR> is that quantifying over all groups or what
07:24:38 <ertes-w> are there known incomplete systems that have peano arithmetic sans indunction?
07:24:43 <ertes-w> *induction
07:24:44 <TorkMattar> (Gödel's theorems talk about first order theory)
07:24:54 <EvanR> or one particular group
07:25:37 <merijn> dmcmint: Hard one too, since it's very easy to accidentally become Turing complete (which automatically costs you the battle)
07:26:03 <EvanR> turing complete = incomplete, funny
07:26:07 <TorkMattar> I'm talking about the theory of group : there is a binary operation, and it is associative, there is a neutral element and every element has an inverse
07:26:37 <TMA> ertes-w: I think you do not need induction --- you need to be able to encode and number formulas, for which you do not need to use induction
07:26:37 <EvanR> if thats your formal language, you cant say forall such and such
07:26:50 <lyxia> EvanR: the language considered is first order sentences
07:26:58 <TorkMattar> that's not the formal language, that's the axiom
07:27:00 <TorkMattar> axioms*
07:27:43 <EvanR> so you have an unspecified group and  make first order statements about it
07:27:58 <lyxia> EvanR: "completeness" is relative to a class of models, here groups.
07:28:18 <TorkMattar> the Gödel's theorems are all talking about theories in first order logic (so we are in classical logic, with quantifiers forall exists, ...)
07:28:28 <EvanR> lyxia did you just show up
07:28:38 <EvanR> i thought i was getting somewhere until you said that
07:28:54 <ertes-w> (BTW, perhaps this discussion should be moved to #haskell-offtopic)
07:30:48 <dmcmint> haskell is expressive but the type system is pretty complicated - is it necessarily the case that increasing expressiveness increases complexity? I think I've got a handle on Troo
07:30:48 <JuanDaugherty> foundations isn't hs enough?
07:31:25 <merijn> dmcmint: Haskell type system is also incomplete and like the opposite of what you'd want in a total language :p
07:31:46 <EvanR> dmcmint: haskell has grown legs over the years
07:32:05 <merijn> ertes-w: Not just legs, but various other unspecified appendages too...
07:32:08 <EvanR> other languages exist with more posterior vision
07:32:32 <EvanR> and less
07:32:37 <ertes-w> i don't mind the topic, but whenever something like this comes up people get so enthusiastic that the discussion drowns everything else, including those boring beginner questions =P
07:32:48 <Tehnix> Is there a way to run a TH function in either the beginning or the end? E.g. wipe a file only at the beginning, but not on subsequent calls to the TH function
07:33:41 <Tehnix> In essence, checking if a function has run before, I guess
07:34:16 <dmcmint> idempotency?
07:34:52 <EvanR> TH can do IO so... you can do anything
07:35:18 <dmcmint> even get the tie
07:35:21 <Tehnix> Yeah, just what would be a good way to go around it, hmm
07:35:21 <dmcmint> time*
07:35:40 <EvanR> write to a tempfile maybe
07:36:31 <EvanR> but if you can save and recall the tempfile name, you could just use that as the sentry for "dont do this again"
07:36:52 <dmcmint> how do you know what the beginning is? the beginning of the file changes if you wipe the beginning
07:37:13 <dmcmint> alter the file to indicate it has been processed
07:37:16 <EvanR> is there a TH-specific namespace that can be dynamically updated
07:37:39 <EvanR> as awful as that sounds
07:38:45 <lyxia> why not simply put what needs to be done once in a separate function and call it once
07:39:44 <dmcmint> what if it's an API call and you don't know if the first message is received?
07:46:24 <JuanDaugherty> boring beginner questions has a dedicated channel
07:46:37 <JuanDaugherty> hs foundations not sfaik
07:47:05 <merijn> JuanDaugherty: That way of thinking lies ##C(++) curmudgeoniness
07:47:21 <JuanDaugherty> off my lawn!
07:47:36 <merijn> #haskell is great exactly because it ISN'T as curmudgeony and "fuck off to ##C++-basic!" as those
07:48:10 <EvanR> i agree keep beginners in here
07:48:42 <JuanDaugherty> my point not about excluding that but rather including theory here
07:49:39 <JuanDaugherty> even if a precious flower fails to open its petals for that trenchant query
07:52:05 <ertes-w> i guess theory talk is fine, as long as nothing else is happening, and if there is, just move it to -offtopic or -blah
07:52:24 <ertes-w> then you can continue the theory talk here =P
07:52:29 <dmcmint> what's the distinction between blah and offtopic?
07:52:31 <JuanDaugherty> c++, at least here has an officially adopted bitter engineer/curmudgeon character
07:52:48 <ertes-w> dmcmint: -blah = haskell, but a lot of traffic
07:53:03 <JuanDaugherty> blah is tls
07:53:12 <EvanR> #haskell-blah has almost no traffic
07:53:32 <JuanDaugherty> due to forcing by an individual that subsequently vanished but the split endures
07:53:40 <ertes-w> i mean: you go to blah for discussions that produce a lot of traffic
07:54:01 <EvanR> in the old days yeah
07:54:15 <merijn> ertes-w: You go to -overflow for on topic discussions that produce lots of traffic :p
07:54:22 <merijn> To many haskell channels ;)
07:54:40 <ertes-w> … or that…  i don't even know most haskell channels =)
07:55:42 * merijn sighs and resets the "Days Since I Was My Own Worst Enemy" sign back to 0
07:56:33 <merijn> Guess who screwed up an SQL query in a subtle way that seemed to work for months, but suddenly broke on new data...
07:56:46 <hyperisco> -blah isn't the same since medfly stopped showing up
07:56:51 <ertes-w> i seem to have confused -blah with -offtopic, so s/-blah/-offtopic/ =)
07:56:57 <ertes-w> err
07:57:04 <ertes-w> i seem to have confused -blah with -overflow, so s/-blah/-overflow/ =)
07:57:04 <hyperisco> @quote medfly>
07:57:04 <lambdabot> No quotes match. Maybe you made a typo?
07:57:41 <dmcmint> merijn: is there any corrupt data?
07:58:01 <merijn> dmcmint: It's read only anyway
07:58:09 <merijn> dmcmint: Plus I have multiple backups of the database
07:58:13 <hyperisco> hrm, that is a shame… I am pretty sure that is where that quote used to be
07:58:34 <dmcmint> ah, if the mistake was writing data that'd be a lot worse
07:58:49 <hyperisco> yeah that quote got nuked :( darn
07:59:27 <dmcmint> merijn: what was the subtlety?
07:59:43 <metahumor> quick lens question: I know about "<>=" for mappending into a state, is there a lens version of "find and remove"?
08:00:22 <Gurkenglas> find as in lookup, or as in filter?
08:00:28 <metahumor> lookup
08:00:43 <JuanDaugherty> she didn hang out in main channel much
08:00:52 <merijn> I have a ridiculously dumb query that repeatedly joins several tables. One of the joins missed a limit, but that worked since I only had 1 row per value in the starting table. Later I got multiple rows per id and then it broke
08:00:57 <metahumor> i want to use the state as a queue, and either push onto end of a queue, or find and pop the first match from a queue
08:01:07 <Gurkenglas> > at 2 .~ Nothing $ M.fromList [(1,10),(2,20),(3,30)]
08:01:10 <lambdabot>  fromList [(1,10),(3,30)]
08:01:17 <hyperisco> um, is there a text searchable log for this channel
08:01:19 <Gurkenglas> metahumor, what happens if the queue is empty?
08:01:22 <Gurkenglas> > StateT uncons
08:01:26 <lambdabot>  error:
08:01:26 <lambdabot>      • No instance for (Show (StateT [a0] Maybe a0))
08:01:26 <lambdabot>          arising from a use of ‘show_M416228357173581863525293’
08:01:32 <metahumor> if queue is empty, return a Nothing
08:01:32 <Gurkenglas> :t StateT uncons -- whoops
08:01:34 <lambdabot> StateT [a] Maybe a
08:02:09 <Gurkenglas> Consider SearchT
08:02:11 <AWizzArd> Isn’t this a very inefficient implementation?    count = (length .) . filter
08:02:34 <AWizzArd> If the input list is very large, wouldn’t we have to kind-of copy it first?
08:02:34 <EvanR> why is it inefficient
08:02:44 <EvanR> filter is lazy
08:03:14 <metahumor> Gurkenglas: while I am looking for SearchT, are there lens-likes that can take a filter-like as the lens?
08:03:19 <AWizzArd> EvanR: and length would need to totally consume it.
08:03:27 <EvanR> thats the idea
08:03:28 <metahumor> so instead of "at 2", it'd be "at (match item)"
08:03:36 <hyperisco> searching hundreds of thousands of pages at 100 messages each is hopeless
08:03:37 <ertes-w> @quote medfly
08:03:37 <lambdabot> medfly says: 'quoting' on IRC is never nice :)
08:03:42 <Gurkenglas> metahumor, what do you mean by match item?
08:03:43 <EvanR> you can accidentally defeat it though, if youre not careful
08:03:57 <Gurkenglas> metahumor, maybe you can provide a type signature
08:04:25 <EvanR> the input list maybe have already been expanded by some other thing, instead of it being consumed in the counting process
08:04:43 <metahumor> "atlike ((==) myitem) . non mydefault .~ Nothing $ myqueue"
08:05:05 <hyperisco> guess my mission is to make a text index for the entire #haskell history
08:05:18 <ertes-w> metahumor: that doesn't sound like a proper traversal
08:05:28 <Gurkenglas> metahumor, "x . non mydefault .~ mydefault" or "x .~ Nothing"
08:05:43 <hyperisco> apparently in 2001 shapr was a real hustler for the channel
08:05:47 <Gurkenglas> metahumor, is myitem a key or a value?
08:06:04 <merijn> hyperisco: shapr is the founder of #haskell
08:06:04 <metahumor> myitem would be a value, the queue would probably be a Seq
08:06:32 <EvanR> hes not just the president, hes also a member
08:06:35 <hyperisco> and by greeting everyone who arrived he blossomed it into #haskell today
08:07:36 <EvanR> some OG shit right here: http://wiki.c2.com/?ShaeErisson
08:08:02 <Gurkenglas> hyperisco, where'd you find 2001 logs?
08:08:28 <hyperisco> Gurkenglas, https://wiki.haskell.org/IRC_channel#Logs
08:08:58 <hyperisco> the search isn't a search though, just a reader
08:09:06 <merijn> On the one hand I'm sad that ircbrowse is disfunctional
08:09:34 <merijn> On the other hand, with it down I don't have to feel guilty about my IRC procrastination being bad enough to end up in the top 10 every month >.>
08:10:02 <hyperisco> the leaderboard of shame
08:10:02 <Gurkenglas> At some point in the future, we'll compute all those stats retroactively
08:10:25 <metahumor> i'm not great at writing typesigs for lenses
08:10:30 <Gurkenglas> And some AI or another might find this exact line in which I tell it to remind me to laugh at you over your retroactive stats
08:11:24 <metahumor> basically, instead of an (At m) => Index m, i'd like to use some predicate (a -> Bool) -> Maybe m to get the first index that matches on the predicate
08:12:06 <Gurkenglas> hyperisco, http://tunes.org/~nef/logs/old/ only seems to go back to 2013, do you have a direct link?
08:12:18 <ertes-w> hyperisco: i'd like that…  would be kinda fun to see what people were talking about in the early days =)
08:12:45 <merijn> heh, I should go over my quotes more often, lambdabot has some good putdowns I came up with...
08:12:56 <ertes-w> @quote merijn
08:12:56 <lambdabot> merijn says: if there's anything the GHC is good at it's releasing memory fast.
08:12:59 <merijn> @quote merijn arbitrary
08:12:59 <lambdabot> merijn says: If I could program with arbitrary real world side effects I'd use "unsafeStabComputerUser" if someone attempted that
08:13:01 <merijn> ^^
08:13:04 <merijn> That one
08:13:16 <merijn> I'm not sure when I said that, but damn. I need to use that more often
08:13:23 <ertes-w> heh
08:13:27 <ertes-w> @quote
08:13:27 <lambdabot> anonymous says: Why is haskell-platform 138MB? Does it include monad of the entire world?
08:13:54 <merijn> 138MB sounds rather small, tbh
08:13:56 <ertes-w> it was only 138 MiB?!
08:14:13 <ertes-w> @quote
08:14:13 <lambdabot> pigworker says: The usual style is to write as if everything is inductive, and if it still works on infinite data, to pat ourselves on the back for using Haskell rather than ML.
08:14:15 <merijn> ertes-w: Absurdly good compression?
08:14:21 <Gurkenglas> metahumor, usually I'd filter some larger traversal, but the traversal that allows arbitrary map entry deletion would also allow insertion, which means it'd have as many targets as there are values in the key type
08:15:16 <ertes-w> merijn: perhaps it was a source distribution
08:15:25 <ertes-w> alright, last one
08:15:26 <ertes-w> @quote
08:15:26 <lambdabot> dfeuer says: But my goal is to carefully confuse GHC's full laziness transformation so [snipped]
08:16:12 <merijn> I should put my quote database online too sometime. I mirrored lambdabot a long time ago and since then I think a bunch of stuff was lost
08:16:19 <metahumor> Gurkenglas: ok, so i'll just resort to chaining "modify'", "elemIndexL", and "deleteAt"
08:19:47 <Gurkenglas> (metahumor, a traversal that depends on a property of the target is only lawful if your update doesn't invalidate the property)
08:22:39 <metahumor> so removing an element by the fact that it has that element is invalid because it will no longer match that fact
08:23:05 <metahumor> however, removing at an index or at a key is always valid because we can always try to access at said index/key, we just might not get a value back
08:23:15 <metahumor> correct?
08:24:49 * dmwit . o O ( A traversal that depends on a property of the target is lawful, it just has a type you can't/don't want to express in Haskell. )
08:25:06 <metahumor> nice thought bubble
08:25:16 <dmwit> ski taught me
08:25:24 <metahumor> "dmwitsay ..."
08:25:52 <merijn> Time to start a #haskell MUD :p
08:26:45 <relyth[m]> guys I think I am too dumb to understand Haskell
08:26:58 <chocopuff> relyth[m]: agreed
08:27:00 <chocopuff> I mean myself
08:27:08 <chocopuff> but it's fun! coming as a newbie too
08:27:23 <merijn> relyth[m], chocopuff: That's what learning feels like :)
08:27:30 <geekosaur> the cure for that is to hack-skell :p
08:27:30 <relyth[m]> I've learned several languages so far but I can't with Haskell
08:27:33 <relyth[m]> kms tbh
08:27:39 <metahumor> I'm totally blanking atm: If I have a "runAction :: a -> b -> m c -> m c" and an "actions :: [b]
08:27:56 <chocopuff> relyth[m]: i guess that kinda is both the fun and frustrating part about picking up functional if you're coming from years of exp. with imp. and oop
08:28:01 <metahumor> how do i sequence that "[b]" to make a lot of "m c" changes?
08:28:11 <chocopuff> relyth[m]: i'd even go out on a limb and say it's harder the more exp. you have had with other languages
08:28:20 <merijn> relyth[m]: tbh, most people who "learn" programming languages haven't learned something since the first one. 90% of mainstream programming languages all you need is a syntax cheat sheet and you can keep doing what you've been doing all this time
08:28:25 <metahumor> "traverse (runAction mya) actions" would be "[m c -> m c]"
08:28:51 <metahumor> or would it?
08:28:54 <merijn> relyth[m]: The reason Haskell feels hard is that for many people it's one of the first times in a long while they end up *actually* having to learn something new
08:29:07 <merijn> chocopuff: See ^^
08:29:15 <metahumor> that's if I did fmap. would traverse properly chain with (>=>)?
08:29:18 <dmwit> :t foldr (.) id -- metahumor
08:29:19 <lambdabot> Foldable t => t (b -> b) -> b -> b
08:29:26 <merijn> relyth[m]: But actually learning something new is what makes it so valuable to learn :)
08:29:36 <relyth[m]> my mind is not wired for functional and declarative languages. Imperative, OOP languages like C#, Java feel so natural and intuitive
08:29:45 <hyperisco> metahumor, your description is not that clear to me… do you have  f :: a -> m b  and  xs :: [a]  and desire  ys :: m [b]  ?
08:29:52 <relyth[m]> and haskell feels like complicating a good schema too much with no aparent reason. or at least I'm not seeing that reason
08:29:52 <merijn> relyth[m]: How long have you been programming?
08:30:12 <relyth[m]> not much, like 2 years
08:30:17 <dmwit> hyperisco: I think he has things of the two types he said (and presumably an `a`) and wants a `m c -> m c`.
08:30:20 <relyth[m]> I'm still an apprentice
08:30:43 <metahumor> hyperisco: yeah that's basically it
08:30:45 <merijn> relyth[m]: If you're curious about the *why* behind Haskell, there's a very interesting talk by Wadler
08:30:47 <dmwit> hyperisco: Also presumably `a`, `b`, `c`, and `m` are monomorphic-ish.
08:30:51 <hyperisco> okay, I still do not get it :P
08:30:54 <merijn> relyth[m]: https://www.youtube.com/watch?v=IOiZatlZtGU
08:31:13 <merijn> relyth[m]: It's an excellent talk
08:31:13 <dmwit> :t foldr
08:31:15 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:31:30 <relyth[m]> okay I'll check that, thanks
08:31:45 <chocopuff> how important is it to know the innards of the ghc?
08:31:58 <metahumor> it's going to be something like "foldr (.) id . traverse (runAction)"
08:32:02 <relyth[m]> tbh I don't really need to learn haskell, I'm only trying (and struggling) because it is compulsory in my university
08:32:11 <chocopuff> I mean, I hear people talk about how to get better at programming, you should kno how the compiler works
08:32:12 <dmwit> :t let runAction :: a -> b -> m c -> m c; runAction = undefined in \a bs -> foldr (\b f -> runAction a b . f) return
08:32:14 <lambdabot> (Monad m, Foldable t) => a -> p -> t b -> c -> m c
08:32:16 <dmcmint> chocopuff: i presume not very unless you want to work on it
08:32:31 <hyperisco> runAction :: a -> b -> m c -> mc   I guess we need some  x :: a  right? so  runAction x :: b -> m c -> m c  do we care about  m c -> m c  really? lets call that X  so  runAction x :: b -> X  now you have  xs :: [b]  therefore  fmap (runAction x) xs :: [X]
08:32:34 <dmwit> :t let runAction :: a -> b -> m c -> m c; runAction = undefined in \a bs -> foldr (\b f -> runAction a b . f) id
08:32:38 <lambdabot> forall k (t :: * -> *) a p b (m :: k -> *) (c :: k). Foldable t => a -> p -> t b -> m c -> m c
08:32:38 <chocopuff> dmcmint: is that true for languages like C? where you are in control of the optimizations
08:32:40 <relyth[m]> if I could choose I would keep using my beloved C# but well let's see where this trip ends for me
08:32:45 <ertes-w> relyth[m]: C++ and PHP used to feel natural to me…  now they feel alien, and haskell feels natural
08:32:47 <dmcmint> knowledge of GCC isn't really needed to code C++
08:32:53 <dmwit> :t let runAction :: a -> b -> m c -> m c; runAction = undefined in \a -> foldr (\b f -> runAction a b . f) id
08:32:56 <lambdabot> forall k (t :: * -> *) a b (m :: k -> *) (c :: k). Foldable t => a -> t b -> m c -> m c
08:33:05 <dmwit> metahumor: ^^
08:33:06 <merijn> relyth[m]: I learned ML in university, struggled with it the entire course. Tried 2 times to learn Haskell 2 years later, got completely lost. 1 year later Haskell finally stuck and now I can't NOT write it anymore
08:33:11 <chocopuff> dmwit: yeah definitely, but I hear sayings such as it would help you write better code
08:33:41 <relyth[m]> that's interesting
08:33:44 <chocopuff> dmcmint: ^^ my apologies dmwit wasn't meant for you
08:34:06 <relyth[m]> I wish I could also make it "click"
08:34:29 <chocopuff> relyth[m]: have you studied abstract math at uni? relyth[m]
08:34:36 <relyth[m]> I've heard so many good things about the language but I feel like that enlightenment is not for me and my lesser mind
08:34:48 <chocopuff> i'm not sure if that helps actually i haven't
08:34:55 <ertes-w> relyth[m]: take your time…  you're learning something that is genuinely new as opposed to just a recolouring of something you've already known
08:34:55 <hyperisco> relyth[m], there isn't a simple misunderstanding that will be resolved all at once and give the sense of a click
08:35:05 <ertes-w> relyth[m]: in other words: this is what actual *learning* feels liek =)
08:35:09 <ertes-w> *like
08:35:10 <relyth[m]> yes
08:35:41 <merijn> relyth[m]: Lots of people who don't know haskell say "I'm not smart enough to understand it", many people who write Haskell say "I'm not smart enough to NOT write Haskell" :)
08:35:42 <hyperisco> relyth[m], you have to tough it out and believe that you can learn it
08:35:53 <metahumor> cool, thank you. so now I have a result of the fold "m c -> m c". if my "m c :: State s c", how would I "run" my "m c -> m c" in the context of my State do block?
08:36:23 <hyperisco> most learning isn't a problem of difficulty but rather a problem of dedication
08:36:30 <metahumor> relyth[m]: to me, learning Haskell is similar to how learning organic chemistry is so different than anything before
08:36:39 <relyth[m]> okay thank you all. I'm genuinely impressed to find such a nice community around something like Haskell
08:36:49 <metahumor> before organic chem, chemistry is just equations (mostly arithmetic and dimensional analysis)
08:36:54 <dmwit> metahumor: Dunno. How did you run it when you had just one `b` lying around instead of many?
08:36:59 <relyth[m]> metahumor: bad example, I hate organic chem
08:37:02 <relyth[m]> xD
08:37:18 <ertes-w> relyth[m]: what did you expect? even most haskell programmers are humans =)
08:37:19 <dmwit> metahumor: "How do I run it?" depends on "What do I want to do with it?", and I don't know the answer to the latter one.
08:37:20 <merijn> Also, for everyone else, go watch that Wadler talk. I was just rewatching the start and it's truly an amazing talk
08:37:22 <metahumor> but organic chemistry requires thinking about hexagons and stuff
08:37:32 <dmcmint> the thing about haskell, is some functions are easy and much less verbose, than e.g. C#, but the type system is fairly complex and my inclination, coming from OOP, is to create records for everything
08:37:42 <merijn> ertes-w: Bad example, many humans are awful and not nice :p
08:37:50 <metahumor> dmwit: I guess I can change my runAction to use "get" and "put" and have it just be "a -> b -> m c"
08:37:51 <dmcmint> when I should probably be using classes, typeclasses, newinstances, etc
08:38:08 <Rembane> dmcmint: Records for everything is allright imo.
08:38:14 <relyth[m]> I mean have you ever been in a tech community on IRC/Matrix/non-mainstream network? it's just not... nice. at least not 99% of the time
08:38:17 <Rembane> dmcmint: As long as you don't use records for sum types
08:38:18 <dmwit> metahumor: (But also, I'd like to point out that having `m c` as an argument, instead of, say, `c`, is very strange. If it were the latter, I'd have a quick and easy guess. But because of the former you make me suspect you're doing something either clever or dumb.)
08:38:22 <merijn> dmcmint: tbh, you almost never end up using typeclasses other than the main ones except for really niche things
08:38:35 <dmwit> metahumor: Yes, that would be much more natural. Then it would indeed just be a `traverse`.
08:38:53 <dmwit> metahumor: Consequently I am coming down on the "dumb" side of "clever or dumb". =P
08:39:17 <metahumor> i'm trying to write a DSL-like for constructing movies
08:39:18 <Rembane> dmwit: KISS programming?
08:39:34 <metahumor> using keyframes and actions like "spin, zoom, fade"
08:39:56 <ertes-w> metahumor: are you familiar with store comonads?
08:40:31 <metahumor> so that an action itself never needs to worry about when it's pushed onto the queue or popped off, the facilitating monad supplies the correct start- and end-frames
08:40:39 <metahumor> surface familiarity
08:40:47 <chocopuff> relyth[m]: yeah, can relate
08:40:58 <metahumor> i have read about the State <=> Store relationship
08:41:17 <metahumor> but i don't have a good grasp on when certain patterns in State usage are better expressed in Store
08:41:25 <hyperisco> relyth[m], 1) the general consensus is we want the Haskell community to grow, so we're nice to people, and 2) there is such a range of knowledge represented here that an elitist attitude doesn't really work
08:41:57 <hyperisco> there is always some other smart ass who knows more than you on any particular thing :P
08:42:30 <ertes-w> metahumor: stores capture the notion of a space with a "current position" (a sound wave with a "current time", an image with a "current pixel", an animation with a "current frame") and "neighbourhood mapping": if you know how to construct a sample from its immediate neighbourhood, you can construct a whole image from it
08:42:38 <merijn> You start arguing about FRP only to get called out by Conal :p
08:42:38 <shapr> learning is hard
08:42:46 <Rembane> hyperisco: It's scary! :D
08:43:18 <shapr> hyperisco: yeah, that's my experience. The few things where I know more than most everybody, I still get into conversations with the few who know FAR more than I do.
08:43:41 <relyth[m]> I feel like 99% of people here know more than me
08:43:49 <ertes-w> metahumor: so a comonadic image filter might look like this:  blur 0.2 =>= rotate 45 =>= …
08:44:04 <hyperisco> relyth[m], that's a good crowd to hang out with then
08:44:41 <metahumor> ertes-w: thanks for the explanation! how would you deal with the fact that actions like zoom have a start and end "position"?
08:44:46 <dmcmint> relyth[m]: what have you tried to do in haskell?
08:44:58 <ertes-w> metahumor: transforms have access to the current position
08:45:28 <royal_screwup21> I've defined  a set like so: data Set a =  Set (M.Map a ()) deriving (Show)  . (I've imported M as qualified Data.Map). When I try something like "Set (M.Map 3())" -- I get an error  "Not in scope: data constructor ‘M.Map’ Perhaps you meant variable ‘M.map’ (imported from Data.Map)" How do I fix this?
08:45:40 <shapr> relyth[m]: I've had a few jobs where I really did know more than everyone around me, it was terrible! I wasn't learning or growing!
08:45:44 <ertes-w> metahumor: not implicitly, but literally, so you can just do position arithmetic
08:46:11 <metahumor> ertes-w: so if i have an "data Enqueue a = Push a | Pop a", then either I push onto my queue with my action using current position, or pop a previous action, using the stored "curried" (action, old-pos) and use curr-pos
08:46:14 <relyth[m]> dmcmint: simple stuff. hello world, factorial, fibonacci
08:46:32 <relyth[m]> you know the classic "I don't know what to do" stuff
08:46:48 <ertes-w> metahumor: what exactly is the purpose of the queue? (i haven't followed the whole backlog)
08:47:17 <ertes-w> relyth[m]: want an exercise?
08:47:25 <relyth[m]> boy when university exercises start coming I'm going to be crushed so hard
08:48:04 <relyth[m]> ertes-w: sure
08:48:07 <dmcmint> i've been using it to help play: https://www.kongregate.com/games/cael/reactor-incremental#
08:48:27 <metahumor> ertes-w: thanks for your patience! i have actions of "spin, zoom" etc. they need a start and end frame. i'd like to specify my keyframes as, for example, [(1 % 4, [Push (Spin Y 360)]), (1 % 1, [Pause]), (1 % 2, [Pop (Spin Y 360)])]
08:48:46 <metahumor> ertes-w: where the list is [(Rational, [Enqueue Action])]
08:48:47 <dmwit> relyth[m]: Would you like a proposal for a slightly larger-scale exercise?
08:48:52 <ertes-w> relyth[m]: implement a function of type (Integer -> IO ()) that takes an integer and presents a simple text game, where the user has to guess the number
08:49:25 <metahumor> ertes-w: as you can see, i'd like to start my Spin Y 360 at the first keyframe, and end it at the third keyframe
08:49:26 <dmcmint> i've got functions to calculate heat generated and dissipated but it's complicated because you get multiple upgrades that affect values and the cells in the grid affect the values as well
08:49:53 <metahumor> ertes-w: where the keyframes are defined as the cumulative addition of those Rationals times some fps
08:50:04 <ertes-w> metahumor: so you have keyframe granularity for actions?
08:50:23 <dmcmint> what about project euler for exercises?
08:50:35 <ertes-w> dmcmint: fun, but not good at teaching haskell
08:50:47 <dmwit> relyth[m]: I like ertes-w's suggestion a lot. It's a very familiar exercise from other languages.
08:51:15 <dmwit> relyth[m]: I would propose an exercise that I think plays a bit more to Haskell's strengths: implement a very small language.
08:51:23 <ertes-w> with project euler you learn a very narrow subset of haskell that is barely useful for practical programming
08:51:32 <hyperisco> dmwit, haha, and it sounds terrifying too
08:51:48 <dmcmint> relyth[m]: this may not be too popular here, but, as you've tried C#, have you ever considered learning F#?
08:51:49 <metahumor> ertes-w: can you explain more? the animator I am using, in python, looks like "anim.addSpin(y, 360, lim=(f0,f1))" where I have to supply the f0 and f1. I'd like the Spin to not have to worry about f0 and f1, and have the parent figure out the f0 and f1
08:51:55 <relyth[m]> yeah I'll try it later. I've been programming in JS (don't judge) for 3 hours today and I'm tired now
08:51:56 <dmwit> relyth[m]: Regular expressions (CS ones, not programmer ones), for example; or a small language that has just numbers, booleans, if, while, and some simple arithmetic and assignment.
08:52:01 <mnoonan> another ++ for ertes-w's suggestion. sometimes when you're learning, it can be easy to forget that you can write "normal" things in Haskell too :)
08:52:05 <ertes-w> dmcmint: considered and done
08:52:42 <dmwit> relyth[m]: For those, I'd suggest a particular implementation path: first, the data type for the AST of the language; then an evaluator that works and doesn't care about efficiency. A real parser that converts String's into the AST and an efficient evaluator can wait for later.
08:52:54 <dmcmint> relyth[m]: this is quite a good F# reference and covers functional principles: https://fsharpforfunandprofit.com/
08:53:07 <dmwit> relyth[m]: The first two are already a fairly large project, but they will really let you see why Haskell is great.
08:53:21 <ertes-w> metahumor: allow me to explain stores in isolation, and then you can decide whether and how much you want to integrate them into your project
08:53:33 <relyth[m]> okay lots of resources. I'm going to copy the links somewhere to check them all later
08:53:40 <relyth[m]> thank you all
08:53:53 <hyperisco> parsing is an excellent vector into Haskell but it helps if you know what parsing is about first
08:54:16 <dmwit> Yeah. That's why I recommend leaving it for last.
08:54:35 <dmwit> v. fiddly at best, and it's rarely at its best
08:55:53 <ertes-w> metahumor: do you see how (V2 Int -> Colour) represents a 2D image?
08:55:57 <dmcmint> any good resources for processing arguments (e.g. from getopts) in Main?
08:56:08 <ertes-w> metahumor: (V2 is from the 'linear' library:  data V2 a = V2 !a !a)
08:56:19 <Rembane> dmcmint: I like optparse-applicative
08:56:19 <metahumor> ertes-w: yeah, that's clear and familiar to me
08:56:36 <dmcmint> Rembane: thanks, I'll have a look
08:56:39 <Rembane> dmcmint: https://hackage.haskell.org/package/optparse-applicative
08:57:06 <metahumor> ertes-w: probably V2 Int -> Maybe Color so our image has bounds and our function is total
08:57:11 <dmwit> dmcmint: There is a direct getopt analog in Haskell, so if that's familiar from e.g. C you might look at that. Otherwise optparse-applicative is very nice for somebody who has Haskell experience but not getopt experience.
08:57:11 <hyperisco> an infinitely large 2D image at that
08:57:30 <dmwit> dmcmint: (optparse-applicative is also nice for somebody who has Haskell experience and getopt experience.)
08:57:32 <MarcelineVQ> bounds? we don't need no stinkin bounds :>
08:57:42 <hyperisco> boundary conditions are annoying anyways
08:57:44 <ertes-w> metahumor: now let's generalise that:  (p -> a) represents an abstract "image"…  depending on 'p' and 'a' it could be a sound wave, a video or a 3D voxel space…  in fact it can even be continuous (modulo floating-point error)
08:57:50 <dmcmint> can hackage packages be installed through stack? or is that what cabal should be used for?
08:57:57 <hyperisco> rotate a square 45 degrees and you have to figure out new boundaries… just sucks
08:58:20 <Rembane> dmcmint: Yes.
08:58:22 <hyperisco> do a finite sample at the end :)
08:58:25 <metahumor> ertes-w: alright
08:58:45 <ertes-w> metahumor: if you couple a (p -> a) with a 'p', then you get a store from 'p' to 'a'
08:58:54 <ertes-w> metahumor: data Store p a = Store (p -> a) p
08:58:56 <dmwit> dmcmint: https://hackage.haskell.org/package/base-4.10.1.0/docs/System-Console-GetOpt.html
08:59:38 <ertes-w> metahumor: this happens to be a comonad, which means that you get a Functor interface and one particularly interesting function:  extend :: (Store p a -> b) -> Store p a -> Store p b
08:59:42 <dmcmint> dmwit: thanks dm, I don't really have that much experience with getOpts but it'll be good to get some
09:00:05 <metahumor> ertes-w: cool! that makes sense to me. so how would generating said image look like?
09:00:38 <dmwit> dmcmint: If you don't know any argument parsing library yet, I recommend starting with optparse-applicative as Rembane suggested. I only suggested getopt because it sounded like you were familiar with that style already from your question.
09:00:43 <ertes-w> metahumor: let's say that you read an image from a file into a concrete array…  you can easily turn it into a store by just capturing the index lookup
09:01:13 <ertes-w> myImage = Store (myArray V.!) 0  -- a one-dimensional example
09:01:42 <metahumor> is there a way to go the other direction? generate the Array using a Store s a?
09:02:16 <ertes-w> metahumor: in fact you probably want two ways to do that
09:02:57 <dmcmint> dmwit: I only started using Linux in the last year and just come across the getopts command
09:03:11 <ertes-w> metahumor: realise :: (Unbox a) => a -> V2 Int -> Store (V2 Int) a -> Store (V2 Int) a  -- takes a rectangle and a default value and turns an arbitrary store into one backed by a concrete unboxed array (which also forces all its pixels)
09:03:26 <phadej> is linux a gateway drug to Haskell :O
09:04:21 <ertes-w> metahumor: toArray :: (Unbox a) => V2 Int -> Store (V2 Int) a -> Vu.Vector a  -- takes a rectangle and returns an actual array that you can use e.g. with JuicyPixels
09:05:08 <royal_screwup21> is there a way to break out of a fold?
09:05:25 <dmcmint> filter and then fold?
09:05:49 <mnoonan> royal_screwup21: it depends on your situation, what exactly do you want?
09:06:10 <royal_screwup21> like say you were looping through a list of ints and when you hit a specific number, you want to return the accumulator and stop folding
09:06:41 <sm> dmcmint: also consider cmdargs
09:06:57 <mnoonan> royal_screwup21: just fold with a short-circuiting function and laziness takes care of the rest
09:07:01 <ertes-w> metahumor: the really interesting feature of this approach is that you get a lot of separation of concerns…  the way you do interpolation is by just transforming stores:  linearInterp :: (Fractional a) => Store (V2 Int) a -> Store (V2 Double) a
09:07:05 <kadoban> royal_screwup21: That would be better done using takeWhile first and then folding
09:07:08 <metahumor> toArray (V2 h w) store = V.generate h (\hix -> V.generate w (\wix -> peek store (V2 hix wix))) ??
09:07:25 <dmwit> royal_screwup21: you might like takeWhile
09:07:38 <dmwit> > takeWhile (/= 32) [1,10,64,32,83]
09:07:42 <lambdabot>  [1,10,64]
09:07:49 <ertes-w> metahumor: you need some arithmetic there
09:08:00 <ertes-w> > map (`divMod` 5) [0..]
09:08:04 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(1,0),(1,1),(1,2),(1,3),(1,4),(2,0),(2,1),(2,...
09:08:11 <dmcmint> i'm guessing takeWhile is a recursive take that's lifted with a bool?
09:08:31 <dmwit> dmcmint: That combination of words doesn't make a lot of sense to me.
09:08:33 <ertes-w> metahumor: oh, you're doing nested arrays…  but you don't need to
09:08:41 <dmwit> ?src takeWhile
09:08:41 <lambdabot> takeWhile _ []                 = []
09:08:41 <lambdabot> takeWhile p (x:xs) | p x       = x : takeWhile p xs
09:08:41 <lambdabot>                    | otherwise = []
09:09:05 <ertes-w> metahumor: ideally you just use a single array and convert the coordinates
09:09:07 <dmcmint> dmwit: i was thinking the input would need to match the output for some reason so would need a bind
09:09:30 <dmwit> Still not making a lot of sense.
09:09:47 <dmwit> The input does need to match the output.
09:09:56 <dmwit> But I don't see how that leads to "needs a bind".
09:10:02 <dmwit> :t takeWhile
09:10:05 <lambdabot> (a -> Bool) -> [a] -> [a]
09:10:16 <dmcmint> dmwit: is that not what the >>= operator does?
09:10:30 <dmwit> dmcmint: What is the "that" in your question?
09:10:35 <metahumor> ertes-w: i like this comonad a lot. unfortunately, i am unable to calculate (interpolate) between the start and end of an "action" like a spin
09:10:51 <metahumor> so i wouldn't be able to use "peek" at arbitrary positions
09:10:58 <merijn> mmm, is there some sort of lightweight LVar? Basically, I wanna have a variable that gets computed (in IO) by the first code to read it and all the rest reuses that code
09:11:09 <dmwit> merijn: IVar
09:11:48 <dmwit> https://hackage.haskell.org/package/monad-par-0.3.4.8/docs/Control-Monad-Par.html#t:IVar
09:12:00 <dmcmint> dmwit: that, >>=, is called bind isn't it?
09:12:02 <ertes-w> metahumor: the idea is that you abstract the keyframes away and only keep them as meta-data…  in other words, if you ask for a frame that is between keyframes, the store would actually compute the frame
09:12:07 <metahumor> ertes-w: thank you for explaining Store to me and giving me motivating examples with images and the linearInterp
09:12:16 <dmwit> dmcmint: Yes. You say "isn't [that] what bind does"? What is "that"?
09:12:31 <ertes-w> metahumor: much like you abstract the array away
09:12:59 <metahumor> ertes-w: that would be the dream! however, at the end, i am generating a list of instructions for a non-Haskell animator
09:13:00 <dmcmint> dmwit: lifts the input and output into the same type for function composition
09:13:03 <dmwit> dmcmint: Or are you asking "isn't bind what the >>= operator does?" in which case the answer is "yes, but I don't see how that's relevant".
09:13:23 <metahumor> ertes-w: that doesn't consume per-frame information, but instead expects the frame-bounds for actions
09:13:56 <merijn> dmwit: That looks like I have to compute it before returning from runPar
09:13:57 <dmwit> dmcmint: No, bind does not lift arbitrary inputs and outputs into the same type. That is know possible in Haskell, to a first approximation.
09:14:00 <metahumor> ertes-w: if i was writing the entire animation computation on my own, i think i can see how i'd use Store
09:14:07 <merijn> dmwit: Which is not what I want
09:14:46 <metahumor> ertes-w: but here, i'm just trying to quickly store tuples of ((start_frame, end_frame), action) so then I can send those off to another program
09:14:54 <dmcmint> dmwit: my understanding of monads comes mostly from this talk: https://vimeo.com/113707214
09:15:10 <metahumor> ertes-w: I have to apologize, I'll be back in around an hour. thanks again for listening and explaining
09:15:11 <ertes-w> @let rect w = dimap (\p -> let (y, x) = divMod p w in V2 x y) (fmap (\(V2 x y) -> y*w + x))
09:15:14 <lambdabot>  .L.hs:170:17: error:
09:15:14 <lambdabot>      Not in scope: data constructor ‘V2’
09:15:14 <lambdabot>      Perhaps you meant variable ‘_2’ (imported from Control.Lens)
09:15:21 <dmwit> s/know/not/ yikes, that's incomprehensible before the fix
09:15:30 <merijn> dmwit: Basically, I'm trying to just memoise an expensive IO computation
09:15:49 <ertes-w> @let data V2 a = V2 !a !a deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
09:15:49 <dmwit> merijn: Oh, well, for memoization, usually a thunk is just what you want. Write-once mutation.
09:15:52 <lambdabot>  Defined.
09:15:55 <ertes-w> @let rect w = dimap (\p -> let (y, x) = divMod p w in V2 x y) (fmap (\(V2 x y) -> y*w + x))
09:15:58 <lambdabot>  Defined.
09:16:19 <ertes-w> metahumor_aw: ^ you can use this iso to translate linear coordinates to 2D coordinates for the given width
09:16:28 <merijn> dmwit: No, because those can't do IO
09:16:43 <ertes-w> > 17 ^. rect 5
09:16:47 <lambdabot>  V2 2 3
09:16:58 <merijn> dmwit: I have "foo :: IO Foo" and I want it to compute a Foo *once* and any further invocation should just reuse the old one
09:17:19 <merijn> io-memoize looks promising
09:17:19 <ertes-w> metahumor_aw: well, i guess the python library you're using doesn't support comonads =)
09:19:07 <dmwit> :t \act -> do { x <- newIORef Nothing; return $ do { mv <- readIORef x; case mv of Nothing -> do { v <- act; writeIORef x v; return v }; Just v -> return v } }
09:19:09 <lambdabot> error:
09:19:09 <lambdabot>     • Variable not in scope: newIORef :: Maybe a0 -> m1 t0
09:19:09 <lambdabot>     • Perhaps you meant ‘newSTRef’ (imported from Data.STRef)
09:20:44 <dmwit> % :t \act -> do { x <- newIORef Nothing; return $ do { mv <- readIORef x; case mv of Nothing -> do { v <- act; writeIORef x (Just v); return v }; Just v -> return v } }
09:20:45 <yahb> dmwit: IO a -> IO (IO a)
09:20:48 <dmwit> merijn:
09:21:12 <dmwit> % ioMemoize act = do { x <- newIORef Nothing; return $ do { mv <- readIORef x; case mv of Nothing -> do { v <- act; writeIORef x (Just v); return v }; Just v -> return v } }
09:21:12 <yahb> dmwit:
09:21:34 <dmwit> % do { x <- ioMemoize (print 3 >> return 4); x; x; x }
09:21:34 <yahb> dmwit: 3; 4
09:21:36 <merijn> dmwit: Right, seems to be about what io-memoize does, except without me having to worry about the exception stuff, etc :)
09:21:45 <dmwit> sure
09:21:52 <royal_screwup21> I'm trying to write takeWhile using foldlr. Here's what I tried: ftakewhile f list = foldl(\acc x -> if f x then acc++[x] else return acc)[] list. The "return acc" isn't valid but there doesn't seem to be an equivalent. How do I get around this? Use a short-circuiting function?
09:21:56 <royal_screwup21> foldl*
09:22:52 <dmwit> dmcmint: (Just for transparency: I don't intend to watch an hour-long video on a topic I already know well.)
09:24:20 <eschnett> i'm looking for a function that is a bit like an inverted fmap -- the signature would be (f a -> g a) -> f (x a) -> g (x a)
09:24:41 <eschnett> does this exist? it would interpose a functor between a functor and a type.
09:24:43 <merijn> eschnett: Looks like contramap for MFunctor?
09:24:56 <dmcmint> dmwit: i didn't expect you to, i was just trying to give you some context
09:24:58 <merijn> oh, wait, no
09:25:09 <merijn> eschnett: Yeah, have a look at the mmorph function
09:25:46 <merijn> eh
09:25:47 <merijn> package
09:25:50 <dmwit> dmcmint: Right, and I appreciate that. I'm just saying I haven't already watched it, and don't plan to, so I won't have that context.
09:26:12 <eschnett> MFunctor's hoist is the wrong way around...
09:26:30 <hyperisco> eschnett, what is an example for f, g, x?
09:26:55 <dmwit> eschnett: Presumably the type would have to be more like `(forall a. f a -> g a) -> f (x a) -> g (x a)`.
09:27:12 <dmwit> eschnett: But then the implementation is too easy: `\f -> f`.
09:27:43 <geekosaur> dmcmint, are you aware that there are two different things called "bind"? one is the monad operation. the other is referring to capturing part or all of a value via a pattern.
09:28:17 <hyperisco> geekosaur, glad you weren't talking about variable binding then
09:28:20 <eschnett> hyperisco: f, g could be a tuple, or a small user-defined type
09:28:29 <eschnett> hyperisco: x could be an array
09:28:30 <Gurkenglas> eschnett, which of the variables are specified by the instance and which by its user? Is it "forall f g a. (f a -> g a) -> f (x a) -> g (x a)"?
09:28:49 <geekosaur> enh, that's just a trivial case of pattern matching
09:29:18 <eschnett> Gurkenglas: yes, x would be "fixed" in that sense
09:29:32 <dmcmint> geekosaur: no i wasn't aware, i thought pattern matching with a literal was like make a proposition, or assertion
09:29:51 <geekosaur> dmcmint, I am not talking about literals
09:29:52 <Gurkenglas> eschnett, can we assume that there's Functor instances on f and g, or something along those lines?
09:29:53 <hyperisco> eschnett, okay, so  ((Int, Char) -> (Int, Int)) -> (Int, Array Char) -> (Int, Array Int)  would do what exactly?
09:30:56 <eschnett> hyperisco: it would be more like ((Double, Double) -> (Double, Double)) -> ((Array Double, Array Double) -> (Array Double, Array Double))
09:31:01 <dmcmint> geekosaur: can you give an example of the pattern bind? is it something like f (x:_) ?
09:31:05 <royal_screwup21> I'm curious - has anyone been hanging out here since the 90's?
09:31:12 <geekosaur> \x -> x + 1 -- x binds whatever you apply the lambda to. it's a trivial pattern in this case
09:31:16 <Gurkenglas> eschnett, try writing down the class definition, such as (though this one would probably be useless) "class Eschnett x where eschnett :: (f a -> g a) -> f (x a) -> g (x a)"
09:31:17 <hyperisco> eschnett, I gave you a valid signature and now I am asking what it is supposed to do, i.e. implement it
09:31:21 <merijn> royal_screwup21: Pretty sure this channel didn't exist in the 90s
09:31:25 <eschnett> hyperisco: in my mind, it would replace all calls to functions that involve the type "a" by fmapping that function
09:31:28 <merijn> shapr: When did you make #haskell?
09:31:39 <dmcmint> geekosaur: oh, like alpha replacement?
09:31:47 <royal_screwup21> merijn: https://wiki.haskell.org/IRC_channel apparently it did in the late 90's
09:31:53 <geekosaur> but consider \(Just x) -> x + 1
09:32:05 <geekosaur> which is a more complex pattern
09:32:11 <dmcmint> geekosaur: alpha conversion, sorry
09:32:44 <Gurkenglas> eschnett, some choices of f do not contain values of a as a list would - for example, f could map the type a to the type functions a -> a
09:32:46 <hyperisco> eschnett, I don't understand. So lets start with  f :: (Int, Char) -> (Int, Int)  and  ab :: (Int, Array Char)  what am I supposed to do from here?
09:33:01 <shapr> merijn: about sixteen years ago
09:33:24 <eschnett> Gurkenglas: good idea. it would be "class Interpose x where ..." with Functor (or tighter) constraints for f and g
09:33:27 <hyperisco> eschnett, oh sorry I changed Int to Char but your type does not allow that, so lets correct things
09:33:28 <merijn> royal_screwup21: So, primary sources say somewhere in 2001 ;)
09:33:49 <mnoonan> royal_screwup21: re: your short-circuiting foldl: http://lpaste.net/361769
09:34:01 <eschnett> hyperisco: when i said "tuple" earlier, i meant a tuple with all elements the same, hence i put "Double" everywhere
09:34:02 <shapr> merijn: easiest way is /msg chanserv info #haskell
09:34:07 <mnoonan> (but note that this is getting you into space-leak territory, even with foldl')
09:34:18 <dmcmint> geekosaur: i think you're talking about beta reduction?
09:34:25 <geekosaur> no
09:34:29 <hyperisco> eschnett, I have  f :: (Char, Int) -> (String, Int)  and  ab :: (Char, Array Int)  and what do I do from here? I need  cd :: (String, Array Int)
09:34:35 <Gurkenglas> eschnett, do you think it would suffice if the class defines a function of type "Functor f => f (x a) -> x (f a)"?
09:35:01 <hyperisco> eschnett,  f = (,) Char; g = (,) String; x = Array
09:35:16 <eschnett> Gurkenglas: thinking... that would just be Traversable or Distributive...
09:35:18 <geekosaur> I am talking about Haskell's pattern matching, not lambda calculus
09:35:34 <shapr> royal_screwup21: according to chanserv, this channel was created Apr 30 22:22:56 2001
09:35:35 <Gurkenglas> eschnett, yes, Distributive, was hoping to get you to agree there so I can just link you to Distributive :P
09:35:43 <royal_screwup21> woot
09:36:11 <eschnett> Gurkenglas: maybe. the implementation could then just sequence, fmap the function, and distribute again.
09:36:15 <royal_screwup21> shapr: so you've been here for the past ~17 years?
09:36:19 <eschnett> Gurkenglas: thanks! that is helpful.
09:36:23 <shapr> royal_screwup21: yup
09:36:44 <hyperisco> Atom is looking a little dead (last updated 2015, links to or within tutorials are broken) https://hackage.haskell.org/package/atom what else could I use?
09:37:05 <eschnett> hyperisco: i was thinking of tuples in the sense of "Pair a = (a, a)"
09:37:13 <shapr> royal_screwup21: lots of cool ideas and code came from this community, it's a good place to spend time
09:37:23 <dmcmint> geekosaur: but you were doing it in the context of a lambda function. fib 1 = 1 ; fib 2 = 1 is what i meant by literal pattern matching
09:37:23 <MarcelineVQ> hyperisco: Atom still, Copilot, Ivory, Tower
09:37:23 <hyperisco> eschnett, it doesn't really matter, does it? those are valid choices for f, g, x no?
09:37:58 <geekosaur> dmcmint, there is no difference in Haskell between f 1 = ... and f = \1 -> ...
09:38:05 <hyperisco> MarcelineVQ, why Atom still? hard to figure it out when the only docs are some blog posts and only *one* is still up
09:38:09 <eschnett> hyperisco: yes, they are. yes, you need to produce "(String, Array Int)".
09:38:19 <geekosaur> (well, there are very subtle differences in ghc's implementation)
09:38:20 <dmwit> hyperisco: I have a worse example. `((a, Void) -> (b, Void)) -> ((a, Const () Void) -> (b, Const () Void)`
09:38:21 <dmcmint> geekosaur: because of beta reduction
09:38:28 <geekosaur> sigh
09:38:47 <geekosaur> yes, keep getting stuck in the wrong place, it's important
09:38:47 <royal_screwup21> shapr: holy shit. So you must've watched some beginners at the time grow into the pros they are now
09:39:01 <MarcelineVQ> hyperisco:  hodapp has some good info on the subject  https://haskellembedded.github.io/
09:39:05 <Gurkenglas> eschnett, afaic the only way we can possibly construct "(Functor f, Functor g) => (f a -> g a) -> f (x a) -> g (x a)" is by having values "yon :: x a -> a" and "hither :: a -> x a" and doing \f -> fmap hither . f . fmap yon"
09:39:06 <dmwit> hyperisco: (The former is inhabited, the latter not.)
09:39:23 <shapr> royal_screwup21: yes, now it's your turn
09:39:38 <geekosaur> f 1 x (Just y) = x + y + 1 -- this is three patterns: one literal, one irrefutable, one that requires a specific constructor
09:39:42 <hyperisco> eschnett, okay, and does that make sense? or can you describe more features that narrow the types so it does make sense? give one implementation, choosing whatever f, g, x you like
09:39:55 <eschnett> Gurkenglas: if "x" is an array, then how can it traverse the whole array?
09:40:12 <geekosaur> it binds two names if it matches
09:40:19 <Gurkenglas> I'm saying that there wouldn't be a sensible instance where x is an array
09:40:24 <geekosaur> this is *not* the same as the Monad (>>=)
09:40:32 <hyperisco> MarcelineVQ, thanks
09:40:47 <MarcelineVQ> hyperisco: galios was using it in 2012, so it's not so ancient as to be useless, not that 2012 is recent either :X
09:41:07 <eschnett> hyperisco: i think Gurkenglas's idea of using Distributive is the right approach. if i write things as "x (f a) -> x (f g)", then it's just fmap. and then i use Distributive to swap the functors.
09:41:11 <hyperisco> MarcelineVQ, I am just anticipating how soon I'll have to fork it
09:41:41 <eschnett> hyperisco: the functors would be collections, such as arrays or lists or similar, i.e. they are more than just Functor.
09:42:06 <MarcelineVQ> hyperisco: then you could end up as someone's hero
09:42:13 <dmcmint> geekosaur: thanks, i guess i should be aware of the two meanings of bind
09:42:48 <MarcelineVQ> hyperisco: be sure to check out #haskell-embedded if you haven't, for people who are active on the subject
09:43:10 <hyperisco> *another* Haskell channel? oh dear
09:43:18 <MarcelineVQ> it's a plague
09:43:45 <eschnett> hyperisco: thanks!
09:43:45 <Gurkenglas> Maybe we should just have a bot join all the Haskell channels and paste what it hears to its own channel
09:43:52 <hyperisco> eschnett, take care
09:44:51 <hyperisco> why is all my text italic
09:45:07 <MarcelineVQ> hard to say
09:45:09 <hyperisco> okay, so I was going to say that hodapp make Ion, cool
09:45:17 <hyperisco> then I hit some weird key combo and all my text went slanted
09:51:17 <dmwit> Gurkenglas: I suspect flood control would prevent that from working well.
09:51:40 <hhefesto> hi! I am trying to follow a yesod tutorial
09:52:06 <hhefesto> (https://youtu.be/SadfV-qbVg8), but I get an early error: https://gist.github.com/hhefesto/7a9947589b3f8008e560f9ae14ab202c
09:52:43 <hhefesto> does anyone know what I'm missing?
09:53:21 <geekosaur> yesod is kinda infamously pain-filled. in this case, it looks like a template haskell splice is coming up empty
09:53:30 <nullie> hhefesto: why do you have $ in last line?
09:54:17 <hhefesto> I thought it was wierd too, but it's how the tutorial puts it. Also the scaffolding site uses it too
09:54:45 <sm> hhefesto: try one of stack's yesod project templates, which should work, and compare
09:54:46 <hhefesto> you mean $(widgetFile "posts/new") right?
09:54:51 <nullie> Yes
09:55:14 <hhefesto> I am using stack's yesod project template
09:55:18 <geekosaur> yes. it should be reading that file and generating haskell code form it, then splicing it in
09:55:18 <sm> which ?
09:55:28 <geekosaur> but it is instead splicing nothing in, leading to a syntax error
09:55:34 <geekosaur> *from it
09:55:34 <hhefesto> yesod-sqlite
09:57:05 <sm> hhefesto: ok.. so the template builds, and this error happens after you add PostNew.hs I guess
09:57:16 <hhefesto> yes
09:57:35 <sm> does the file posts/new exist ?
09:57:41 <hhefesto> yes
09:57:52 <hhefesto> with a simple <h1> Create post!
09:59:19 <dmwit> hhefesto: You might try adding -ddump-splices to your compilation line to see what it's doing with $(widgetFile ... )
09:59:32 <sm> hhefesto: it looks like the yesod-sqlite template does not enable TemplateHaskell for all modules, so try adding {-# LANGUAGE TemplateHaskell #-} to this file
09:59:57 <dmwit> sm++
10:00:11 <colcode> Hi folks.  So I'm trying to figure out why mapM_ has a nasty memory leak.  I've narrowed down to: mapM_ ((\_ -> return ()) :: a -> IO ()) (repeat 1)
10:00:23 <colcode> why does this eat RAM?  GBs very fast
10:01:11 <hhefesto> it compiles!!!! THANKS! Been stuck there for a while
10:01:37 <geekosaur> weird. I'd expect an error about TH not being enabled, or a different syntax error than "empty do"
10:02:10 <hhefesto> yes... a bit frustrating :(
10:02:33 <sm> I got "parse error on input ‘$’  Perhaps you intended to use TemplateHaskell"
10:02:36 <dmwit> colcode: That eats RAM when executed in ghci for me, but not when compiled.
10:02:45 <sm> with ghc 8.2.1, stack 1.6.3
10:02:54 <colcode> dmwit: weird, for me it does in both cases.
10:03:02 <colcode> ghc 8.0.1 here
10:03:26 <colcode> did you use and -O or something with ghc?
10:03:48 <hhefesto> no
10:04:14 <sm> warning, crossing threads..
10:04:23 <dmwit> colcode: I have now tested with ghc-8.0.2 as well and see the same behavior. No compilation flags. Just stuck your exact code in a file, prepended `main =`, and `ghc test.hs`.
10:04:36 <dmwit> colcode: Well, `ghc-8.0.2 test`. =)
10:04:39 <colcode> well drat, yes.   I see that as well.
10:05:01 <colcode> so perhaps I have over-simplified my code, as the underlying test program did indeed have a leak under ghc as well
10:05:15 <dmwit> Okay. Time to try again! =)
10:05:51 <hodapp> hyperisco: yes, Ion is mine but diverges a bit from Atom in spots and is probably ill-maintained... what are you trying to do?
10:07:35 <t7> what did wadler say about ambiguity when he presented typeclasses ?
10:07:52 <t7> with regards to: show . read
10:08:18 <dmwit> Is this, like, a quiz show, or what?
10:08:25 <t7> im interested
10:08:38 <t7> i skimmed through how to make ad-hoc polymorphism less ad-hoc
10:08:45 <t7> and could see a mention
10:09:12 <hodapp> hyperisco: to my knowledge some of the only remaining docs on Atom are the ones I wrote which I did a PR on, and the blog posts I put up at HaskellEmbedded
10:14:42 <dmwit> t7: Given how freshly you have seen what Wadler said in his typeclass presentation, you are probably the top world expert on your question at this moment.
10:15:29 <dmwit> (This is not a joke.)
10:21:05 <mnoonan> t7: have you read the original mailing list post? https://homepages.inf.ed.ac.uk/wadler/papers/class-letter/class-letter.txt
10:21:41 <mnoonan> he does mention show and read in the conclusion, but not "show . read" or anything with a similar issue afaict
10:22:34 <t7> mnoonan, i will have a read, cheers
10:57:07 <bsamorim> Hi, guys! Can i configure ghci such that functions are automatically memoizable?
11:00:19 <glguy> no
11:00:35 <bsamorim> glguy: ok, thanks!
11:05:14 <abdo> #Ubuntu
11:08:35 <kahlil29> I want to run a delete function over a list and I want to pass a list of values to delete from that list. Is there a way to do that? So to give an idea, if I had just a single value to delete, I would write something like `map (myDeleteFn singleValue) [listOfValues]` . I want to pass a list of values in place of `singleValue`
11:09:36 <cocreature> :t \xs -> filter (not . (`elem` xs))
11:09:38 <lambdabot> (Eq a, Foldable t) => t a -> [a] -> [a]
11:09:46 <cocreature> ^ kahlil29 something like this?
11:10:07 <kahlil29> yeah I think so. I'll try it out.
11:10:11 <kahlil29> cocreature : thanks
11:10:22 <cocreature> hm that doesn’t match what you’ve written
11:10:30 <cocreature> but I’m not sure how your version is supposed to work
11:10:35 <cocreature> how do you remove elements with a "map"?
11:10:43 <ski> > "abcdbcdcdd" \\ "acdc"
11:10:46 <lambdabot>  "bbdcdd"
11:10:52 <kahlil29> I think I'm going about this wrong
11:10:54 <kahlil29> woah woah
11:10:56 <cocreature> ski: oh right, I keep forgetting that’s a thing
11:10:57 <kahlil29> what is that magic
11:11:07 <ski> @type (\\)
11:11:09 <lambdabot> Eq a => [a] -> [a] -> [a]
11:11:45 <ski> perhaps you should start by explaining what you want to achieve ?
11:12:15 <kahlil29> yes I think this was the x y problem
11:12:22 <kahlil29> ski : thanks a bunch!
11:12:31 <ski> all clear, then ?
11:12:46 <kahlil29> I think so
11:13:13 <kahlil29> oh wait no. I want to delete all occurrences from the smaller list that are present in the bigger list
11:13:40 <kahlil29> I think \\ just removes the first occurence?
11:13:41 <ski> note that `(\\)' will not remove all occurances of a removed item. it matches items in the "to remove" list with items in the "remove from" list, discarding any remaining unmatched items in the "to remove" list
11:14:47 <ski> in my example, it removed two `c's, because i had two of them in the list to the right. so it doesn't just remove the first occurance
11:15:34 <ski> if you want to remove all occurances of items that are present in the "to remove" list, then see cocreature's suggestion
11:16:16 <kahlil29> ski: yup. checking it out
11:16:46 <ski> (it's not clear to me whether by "smaller list" you mean the "to remove" list in my terminology, or the "remove from" list. ditto for the "bigger list")
11:19:28 <kahlil29> ski: so I'll tell you my basic problem. I have the list [1,2,3,3, 4, 5,5, 6, 7]. And no duplicates are allowed. In the sense, any duplicate elements have to be completely removed. So after processing, I should get [1,2,4,6,7]
11:19:52 <ski> (if you have no duplicates in your lists, using them to represent (finite sub)sets (so also ignoring order), then `(\\)' is set difference/subtraction. if you may have duplicates, but order doesn't matter, you're representing bags / multi-sets, and then it is bag difference/subtraction)
11:20:10 <ertes> kahlil29: if by any chance you're trying to implement sets, and this is not an exercise, you should probably just use Data.Set
11:20:53 <kahlil29> I've actually used Data.Set before. But I've been told to implement this with basic functions from the list module :P
11:20:56 <kadoban> kahlil29: nub, if the lists will always be small. Otherwise a faster version using Set or something. If you don't care about order,  Set.toList . Set.fromList works. Or yeah maybe you should just be using a Set in the first place.
11:20:59 <ski> > nub [1,2,3,3,4,5,5,6,7]  -- note that if you know that your list is ordered, then this is needlessly inefficient
11:21:03 <lambdabot>  [1,2,3,4,5,6,7]
11:21:14 <kahlil29> I tried nub, didn't work.
11:21:26 <kadoban> In what sense did it not work?
11:21:36 <ski> oh, sorry, i see. any element that is replicated should be wiped out
11:21:38 <kahlil29> I think what cocreature gave me is the solution. Trying it out now and I'll be back soon
11:22:48 <kadoban> Oh I see
11:23:02 <ski> kahlil29 : `filter' considers the elements independently of each other, so that can't be a solution
11:23:51 <ski> if your list is sorted, then using `group' could be one solution
11:26:54 <ertes> ideally create (newtype Bat a = Bat { fromBat :: [a] }) with the contract that any value of type (Bat a) has to be sorted and unique
11:30:24 <ski> hm, if it's not sorted, and you'd want to preserve the order of the remaining elements, then i don't see a simpler solution than spelling out the traversal (by which i mean recursion) yourself
11:35:46 <kahlil29> ski: tbh the order probably doesn't matter here. But I think I found a solution. I'm using a fold in order to create a list of elements that are present more than once in the list. So with the appropriate conditions I could probably insert into that list the exact repetitions maybe? So then I'd just be done with a simple \\
11:37:01 <ski> if you extract the list of repeated elements, then you could use a `filter' with that to remove them from the original list
11:37:43 <kahlil29> but even that isn't foolproof. Discard my last suggestion. it is very flawed.
11:40:15 <kahlil29> ski: yes your last suggestion is what I'll do. Using the list of repeated elements, use a filter and remove from the original list. thanks, again
11:40:25 <kadoban> If the order doesn't matter, you can do something like    map head . filter ((== 1) . length) . group . sort
11:40:51 <kadoban> You can improve the (==1) . length part quite a bit as well, though it won't really matter for most inputs
11:41:20 <bsamorim> what does "!!" do in haskell?
11:41:32 <kadoban> bsamorim: Indexing in lists
11:41:57 <bsamorim> kadoban: Could you point me to a reference? I coudn't find anything through google
11:41:57 <ski> does "order probably doesn't matter" mean that elements will come in any order, or that, since order doesn't matter, you can make sure to provide them in sorted order ?
11:42:04 <ski> kahlil29 ^
11:42:07 <kadoban> > [7,8,9] !! 0
11:42:13 <lambdabot>  7
11:42:30 <kadoban> bsamorim: https://www.stackage.org/haddock/lts-10.3/base-4.10.1.0/Prelude.html#v:-33--33-
11:43:42 <bsamorim> ohh, ok, thanks! I came across this token reading the "Memoization" section of Haskell Wiki. Are arrays memoized by default, then?
11:44:23 <Gurkenglas> The only thing that isn't memoized is function application
11:45:12 <bsamorim> Gurkenglas: ok, thanks!
11:45:19 <ski> bsamorim : things bound to variable names, and also components of data structures (including arrays) can be assumed to be memoized/cached in a by-need / lazy implementation like GHC
11:45:34 <kadoban> bsamorim: If you give a name to a value or store its result in an array or some other way of holding on to it, GHC won't usually ever compute it more than once.
11:46:14 <ski> bsamorim : memoization of functions, where you keep track of an association from passed inputs to previously computed outputs, is something else. you have to ask for that specifically to get it
11:46:41 <bsamorim> Is it due to implementation difficulties, cost, or impossibility that function application isn't memoized?
11:46:44 <kahlil29> ski: Nothing has been specified about order till now. The dummy data I am currently working with are marks of students. They are not given sorted and I don't think they are expected to be returned sorted.
11:47:08 <kadoban> bsamorim: It is in general a hard problem to decide when it makes sense to memoize a function. It's very easy for it to be the wrong strategy.
11:47:48 <bsamorim> Yes, but why not make it an optional parameter or something on ghci? Wouldn't it be useful?
11:48:08 <kadoban> Because it doesn't need to be a language feature, you can write code that does it nicely.
11:48:08 <ski> bsamorim : e.g. if you make an array (or `Data.Map') with input-output associations, for some selection of inputs, and then use an indexing function to turn that back into a function, then (if you do that right) that function will be memoized (on at most those inputs). you can't clear the cache here, apart from dropping the function, though
11:48:50 <bsamorim> ski: nice!
11:49:13 <ski> kahlil29 : ok, good. i'm asking because the kind of solution one can make can depend on knowing such extra info about the indata
11:49:18 <malorie> kadoban: shouldn't it ideally be decided by the runtime, when to memoize a function?
11:50:14 <ski> bsamorim : e.g., it's easy to make a function `memoArr :: Ix i => (i,i) -> (i -> a) -> (i -> a)', that will memoize the argument function on the given index range, using an intermediate `Array'
11:50:24 <Gurkenglas> bsamorim, the memoize package has a Data.Function.Memoize module with a function "memoize :: Memoizable a => (a -> v) -> a -> v", which you can use to "explicitly tell it" to memoize a function (implemented with a map thingy like what ski said). (As long as a as a type can be indexed, as opposed to, for example, function types, which can't.)
11:50:50 <kahlil29> ski: So I incorporated what cocreate gave me earlier into a deleteAllInstances function and it seems to work well
11:51:33 <ski> bsamorim : you should also note that, sometimes, one can nicely implement (top-down) dynamic programming by indirecting your function via an (immutable) array, which is recursively defined
11:51:41 <bsamorim> ski, Gurkenglas, kadoban: Thanks, guys! You've made haskell's memoization understandable to me
11:52:05 <ski> kahlil29 : cool :)
11:52:06 <kadoban> malorie: That would also be an option, that is also a hard problem though AFAIK
11:52:15 <kadoban> Especially doing it without enough overhead to annoy people
11:52:18 <bsamorim> Names have nothing to do with memoization, do they?
11:52:26 <kahlil29> incase anyone was curious the final function accepts two lists as arguments and its body is         filter (not . (`elem` duplicateNames)) allNames
11:52:53 <bsamorim> I mean, binding the same thunk to two different variables a and b, I would be memoizing b by computing a, wouldn't I?
11:53:19 <ski> bsamorim : btw, if you want to memoize a recursive function, then you can't construct it first, and then pass it to something like `memoize' or `memoArr'. you'd have to either weave that call into the recursion, or use a memoizing version of `fix'
11:53:27 <kadoban> bsamorim: Yes, if I understand you correctly.
11:53:27 <Gurkenglas> :t let removeDuplicates (x:xs) = case partition (==x) xs of ([],_) -> x:removeDuplicates xs; (_,ys) -> removeDuplicates ys in removeDuplicates
11:53:29 <lambdabot> Eq a => [a] -> [a]
11:53:42 <malorie> kadoban: well, you can always re-incorporate what you learned into a runtime-less compilation, no?
11:54:15 <bsamorim> ski: yes, that's what got me into this research of mine in the first place. I was hoping that my fibonacci implementation would be memoized for me
11:55:02 <ski> bsamorim : if you do `let a = ...; b = a in ...', then `a' will memoize the computation of `...', and `b' will memoize the computation of `a' (which further will demand `...', if not computed yet)
11:55:41 <kahlil29> ski: thanks for trying to solve my problem though. All you guys here are really great. I never hesitate to ask you guys stuff for fear of being ridiculed. Even noobs are explained stuff with patience. Thanks everyone else especially cocreature .
11:55:43 * ski isn't sure whether this means "Names have nothing to do with memoization" or not, in bsamorim's understanding
11:56:02 <bsamorim> ski: yes, that's pretty much it. Thanks!
11:56:02 <ski> kahlil29 : *nod*
12:00:31 * ski hopes bsamorim sees why "you can't construct it first, and then pass it to ..."
12:01:06 <ski> (well, you can, but you probably don't want to, since it probably doesn't do what you had in mind)
12:01:07 <bsamorim> ski: haha I'm not sure I follow.
12:01:18 <ski> well, take `fib'
12:01:32 <bsamorim> yes
12:02:11 <ski> if you define `memoizedFib = memoBlah fib; fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)', then only the "final result" will be memoized
12:02:51 <ski> so, if you call `memoizedFib 12', it will call `fib 12', which will call `fib 11' and `fib 10', which will call `fib 10', `fib 9', `fib 9' and `fib 8'
12:03:17 <ski> and here the two subcomputations of `fib 9' *won't* be shared
12:03:47 <ski> you'll only get an association/table of inputs to *`memoizedFib'*, whose results will be remembered
12:03:48 <bsamorim> yes, I realized that when my simple sum got stuck hehe
12:06:42 <ski> but if you define `memoizedFib = (fibArr !) where ix = (0,12); fibArr = listArray ix [fib n | n <- range ix]; fib 0 = 0; fib 1 = 1; fib n = memoizedFib (n-1) + memoizedFib (n-2)', then, during a single initial call to `memoizedFib', subcomputations *will* be shared
12:07:53 <ski> (in this case, since `memoizedFib' isn't defined by a function definition, the array `fibArr' would be shared across subsequent calls to `memoizedFib')
12:09:14 <Junior_> Can anyone see anything incorrect with line 22 of http://lpaste.net/361771.  I get an error 'Couldn't match expected type 'EntityDef' with actual type 'Maybe Person'.
12:09:34 <Junior_> I'm following code snippet from https://www.yesodweb.com/book/persistent.
12:10:21 <ski> (if you instead did `memoizedFib n = (fibArr !) where ix = (0,n); ...; fib n = fibArr ! (n - 1) + fibArr ! (n - 2)', then each call to `memoizedFib' (which now can handle inputs larger than `12'), would create a new array, which will be used internally to that call, to avoid recomputing repeated subcomputations)
12:10:58 * ski realizes bsamorim left
12:11:36 <electrocat> is there a way to do 'like' queries with persistent?
12:12:37 <mnoonan> ski: mutable state strikes again
12:16:54 <ski> mnoonan : strikes in which sense ?
12:18:19 <mnoonan> as in "ski's efforts to explain were struck down by mutation of the channel's subscriber list"
12:18:52 <ski> ah :)
12:19:37 <int-e> mnoonan: great, now I'm pondering immutable people... it's scary.
12:20:11 <mnoonan> int-e: I think I've met a few of those
12:20:17 * ski was suspecting it was a reflection on the implementation of laziness through mutation causing the abstraction to leak in some regard ..
12:23:13 * ski . o O ( <https://en.wikipedia.org/wiki/Hold-And-Modify> )
12:23:21 <dysfun> HAM!
12:24:02 <ski> would you like it boiled or oven prepared ?
12:24:18 <dysfun> glazed and roasted i think
12:24:52 * ski offers dysfun some mustard-with-honey
12:25:25 * ski . o O ( perhaps that'd be Honey-And-Mustard ? )
12:25:33 <dysfun> :)
12:26:45 <geekosaur> money-and-hustle?
12:35:19 <albatross_> hey guys, what does an infinite type mean? here is the error message Occurs check: cannot construct the infinite  type: a ~ [Maybe [a]]
12:36:01 <ski> albatross_ : practically, it usually means that you're confusing a list element with a list, or something of that sort
12:36:26 <ski> in your case, it looks like you're confusing a list of maybe lists with the elements of those inner lists
12:36:48 <ski> it's hard to say more, specifically, without seeing the offending code in question
12:37:32 <albatross_> http://lpaste.net/361772
12:37:43 <albatross_> just pasted the code here
12:38:17 <ski> (in relatively rare circumstances, what you want to do is reasonable, but Haskell's type system won't accept it, as is. you'll then have to explicitly make a recursive data type. but far more common, at least for beginners, is for it to be a symptom of a confusion/bug in your code)
12:39:06 <albatross_> so i need to write a recursive data type
12:39:26 <albatross_> ?
12:39:35 <mnoonan> no, you just need to think through these expressions' types a bit more
12:39:46 <mnoonan> :t \xs -> map safeHead (group xs)
12:39:48 <lambdabot> error:
12:39:49 <lambdabot>     Variable not in scope: safeHead :: [a] -> b
12:40:29 <ski> i'm not even sure what you want `chhh' to do
12:40:34 <mnoonan> :t group
12:40:37 <lambdabot> Eq a => [a] -> [[a]]
12:41:08 <mnoonan> so ch has type "Eq a => [a] -> [Maybe a]"
12:41:19 <mnoonan> and how about chh?
12:41:35 <albatross_> chh should be the same
12:41:55 <albatross_> oh actually, it is Maybe [a]
12:42:07 <ski> albatross_ : first, do you want `ch' to fail (i.e. give `Nothing'), in case *any* of the `safeHead's fail ? or perhaps you want to ignore/forget the cases when it fails (also stripping the `Just's in the remaining cases) ?
12:42:08 <mnoonan> right, [a] -> [Maybe [a]]
12:42:22 <ski> albatross_ : also, same question for `chh'
12:43:31 <albatross_> ski, when safehead fails i want it to ignore/forget the case, I wrote safeHead with maybe data type
12:43:44 <ski> albatross_ : so use `catMaybes'
12:43:50 <ski> @type catMaybes
12:43:52 <lambdabot> [Maybe a] -> [a]
12:43:56 <mnoonan> so now, if xs has type [a], what type will chh (chh xs) have?
12:44:17 <albatross_> thx ski
12:44:25 <ski> albatross_ : second, i'm wondering if, when you wrote `chh (chh xs)', perhaps you meant `ch (chh xs)' ?
12:45:25 <albatross_> mnoonan chh xs will have [Maybe [a]]
12:45:36 <ski> (alternatively, you *could* try to explain what you want `chhh' to do .. or more generally, what you're trying to achieve here)
12:46:09 <mnoonan> albatross_: right, so "chh (chh xs)" will have which type?
12:46:46 <albatross_> chhh [1,2,3,4,4,5,6,6] == [[4,6], [1,2,3,4,5,6]]
12:47:33 <albatross_> mnoonan, I meant to write chhh xs = chhh (chh xs) ++ ch xs
12:47:43 <albatross_> making it into a recursion
12:49:03 <mnoonan> albatross_: I'd strongly suggest adding the expected type signatures for ch, chh, chhh. at the very least, it'll give better errors.
12:49:19 <albatross_> mnoonan, ok
12:49:40 <mnoonan> also, it'll help you figure out the right implementation
12:51:39 * ski seconds mnoonan
12:52:46 <ski> albatross_ : looks like you'll need a base case for `chhh', at the very least
12:53:13 <albatross_> ok ski, let me take a look
12:56:02 <albatross_> is there a difference between [[Maybe Int]] and [Maybe [Int]]?
12:57:01 <mnoonan> sure, here is an example of each: [ [Nothing, Just 1], [], [Just 2] ] vs [ Just [1,2,3], Nothing, Just [4,5] ]
12:57:22 <albatross_> ah ok
12:57:39 <albatross_> geez, how did it get into this messy typing..
12:57:43 <EvanR> exercise prove that there is no bijection between them
12:57:52 * hyperisco was working on that
12:58:54 <EvanR> how acausal
12:59:19 <siwica> When using Emacs intero-mode with recent stack snaphots I always get a window (refreshing about once a second) complaining that intero does not find the project root. However, if I edit my stack.yaml to use an older snapshot, everything works fine. Does anyone know why this is?
12:59:26 <hyperisco> if we want to program in hott one day then we better get serious about such questions
13:02:42 <siwica> Also, I am getting the error "AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\"""
13:02:57 <glguy> siwica: If you aren't using stack 1.6.3 it's time to upgrade
13:03:11 <siwica> I did upgrade stack to 1.6.3
13:03:29 <phadej> what your stack --version says
13:03:36 <siwica> 1.6.3 ...
13:03:46 <phadej> then it's very weird
13:04:35 <kadoban> siwica: Can you lpaste the entire output of 'stack --version' and whatever command is showing that error please?
13:04:55 <siwica> Hm... When I run stack version in my zsh shell I get 1.6.3, however running inside of emacs: M+! stack-version I get 1.3.3
13:05:04 <kadoban> Yeah, there we go
13:05:08 <phadej> :)
13:05:47 <siwica> Ok, so it seems a path problem I guess...
13:05:52 <kadoban> That's odd though, I'm not sure why that would be happening, but then I don't know emacs at all.
13:06:55 <siwica> Yeah, it seems weird. Maybe there are two conflicting installations and the more recent one is not within the search path of the emacs shell
13:07:12 <geekosaur> one way is emacs was started before $PATH was changed in the terminal window
13:08:01 <geekosaur> M-: exec-path RET
13:08:15 <geekosaur> compare to, in terminal: echo $PATH
13:09:38 <metahumor> "rewrite emacs in haskell"
13:09:58 <metahumor> "run that in the Emacs monad"
13:10:02 <albatross_> guys, i finally got it http://lpaste.net/361773
13:10:07 <siwica> Ok, Emacs uses /usr/bin/stack whereas my shell uses ~/.local/bin/stack
13:10:08 <Uniaika> :D
13:10:09 <albatross_> thanks ski and mnooan
13:10:18 <siwica> Well, knowing this should solve it, hopefully
13:10:23 <Uniaika> siwica: oh, you installed a system-wide stack?
13:10:58 <siwica> Yeah, I forgot about that :D
13:11:00 <MarcelineVQ> once you have a stack in .local/bin I'd be inclined to remove the system one entirely
13:11:02 <siwica> Apparently...
13:15:00 <albatross_> can I tag people on this chat room?
13:15:21 * drdo tags albatross_
13:15:37 <tathougies> does anyone know what the term 'large eliminations' means in the context of the lambda calculus (specifically, typed lambda calculi)
13:15:47 <MarcelineVQ> albatross_: most people are using clients where just mentionthing their name will draw their attention
13:16:00 <albatross_> *ski *moonan I got the function to work, thanks http://lpaste.net/361773
13:16:11 <albatross_> *albatross
13:16:30 <albatross_> drdo albatross
13:17:15 <mnoonan> albatross_: great!
13:19:54 <fishythefish> tathougies: consider how we can construct data by performing recursion on existing data. "large eliminations" is analogous, only we can construct types by recursion on data
13:23:42 <tathougies> fishythefish: thanks for the context… do you have any papers you could recommend that describe this in more detail (versus just referencing it) :)
13:25:12 <fishythefish> tathougies: I can't think of any off the top of my head which focus specifically on large eliminations. In my experience, having large eliminations is just noted as a feature of a particular system
13:25:37 <ski> albatross_ : your `safeTail' has a bug
13:26:13 <ski> albatross_ : for "tagging", just mention their nickname, e.g. like this
13:26:55 * ski idly ponders "large introductions"
13:28:10 <albatross_> http://lpaste.net/361773
13:28:14 <albatross_> base case problem
13:28:50 <albatross_> the last element of the result of f' wouldn't show
13:29:59 <ski> albatross_ : next time, either make a new paste, or at least annotate the existing paste, when you want to do something else that adjust the current paste
13:31:44 <ski> albatross_ : "Annotate" is for adding related information (on the same page). "Edit" can be used to paste a new version, when there'sn't much point in seeing the older version as well on the same page
13:32:25 * fishythefish squints at "there'sn't"
13:33:27 <albatross_> lol k thx *ski
13:34:07 <ski> albatross_ : did you consider my comment on `safeTail', yet ?
13:36:48 <albatross_> are we talking about this post? http://lpaste.net/annotate/361773
13:37:34 <albatross_> ski, you said safeTail has a bug? I just saw your comment, I'm not sure if I see teh bug
13:37:44 <albatross_> can you please point it out
13:40:16 <metahumor> i don't see a "safeTail" in that link
13:40:40 <ski> metahumor : click on the "2018-01-18 21:27:20 UTC" revision
13:41:04 <ski> albatross_ : what is the tail of `[3]' ?
13:41:44 <ski> metahumor : er .. sorry, that should be the "2018-01-18 21:08:41 UTC" revision
13:42:23 <ski> (.. see how "Edit"ing a paste to contain something unrelated confuses people ?)
13:44:02 <albatross_> ski the tail of [3] is Nothing
13:44:18 <dmwit> > tail [3]
13:44:22 <lambdabot>  []
13:44:40 <albatross_> oops []
13:44:42 <dmwit> albatross_: I think the safeTail of [3] should not be Nothing.
13:45:03 <dmwit> ski: I don't even see a way to view other revisions.
13:45:45 <albatross_> http://lpaste.net/annotate/361773
13:45:49 <albatross_> i need help with the base case
13:45:58 <albatross_> the last element of f' wouldn't show
13:46:09 <ski> dmwit : hm, there is a visible link in W3m (textual browser), at least. try <http://lpaste.net/revision/361773>
13:47:06 <dmwit> What is the content in the link?
13:47:11 <albatross_> ski i'm using chrome, i can't see the revision
13:47:17 * ski usually doesn't bother displaying lambdapastes in $VISUAL_BROWSER
13:48:03 <ski> dmwit : definitions of `safeHead',`safeTail',`ch',`chh',`chhh', and one example use of `chhh'
13:48:10 <dmwit> no no, I mean
13:48:11 <albatross_> http://lpaste.net/361776
13:48:15 <dmwit> What is inside the <a> tag.
13:48:22 <ski> oh
13:48:28 <metahumor> dmwit: safeHead [3] == safeTail [3] ??
13:48:30 <albatross_> maybe different browsers are different, i made a new paste http://lpaste.net/361776
13:48:57 <metahumor> albatross_: that link show's the f and f' for me
13:49:10 <ski> dmwit : "#361773"
13:50:43 <bubble> hi
13:50:44 <albatross_> metahumor, yeah, I put safeTail [x] = Nothing, it worked for chhh, then I have a new problem with f'...
13:51:16 <metahumor> I agree with dmwit that safeTail [3] might better be as not Nothing
13:51:18 <albatross_> ski, i can't do safeTail [x] = [], becuase it is not of type Maybe, so i did Nothing
13:51:25 <ski> (dmwit : "<a href="/revision/361773">#361773</a>", if you want it all)
13:51:50 <ski> albatross_ : how about using `Just' ?
13:53:04 <metahumor> albatross_: I'd say you already have the defn of safeTail you want. in general, i find defining total functions on lists often needs only 2 cases, [] and (x:xs)
13:53:24 <metahumor> there's a nice symmetry you can have between your defns for safeHead and safeTail
13:53:24 <ski> metahumor : their definition has three cases
13:53:57 <albatross_> metahumor thanks
13:53:59 <metahumor> ski: yeah, i'm suggesting that that might be faulty
13:54:15 <albatross_> guys, what f'???
13:54:18 <albatross_> http://lpaste.net/361776
13:54:25 <albatross_> what about*
13:54:47 <ski> albatross_ : what about `safeTail' ?
13:55:10 <metahumor> albatross_: would you expect this to hold? "Just mylist == (:) <$> safeHead mylist <*> safeTail mylist"??
13:55:16 <Zemyla> Where's the paper proving that using the ST monad really is safe?
13:55:17 <albatross_> safeTail [x] = Just [] ski, do you mean this one?
13:55:30 <ski> (i'm suggesting that there may be a lesson to learn here. i'm also thinking that this lesson could help you also a bit with  f'  but i'm not suggesting that yet)
13:55:43 <ski> albatross_ : yea, what do you think about that ?
13:56:18 <ski> metahumor : i think it's safe to assume that albatross_ doesn't know about `Applicative', given that they're (a little bit) struggling with list recursion
13:56:24 <albatross_> ski hmmmmm..... i'm not sure
13:57:08 <ski> albatross_ : does it conform better to the behaviour of `tail' ?
13:57:08 <albatross_> yeah i'm don't know applicative... I'm only few weeks into Haskell with zero programming background....
13:57:20 <albatross_> ski, yeah it does
13:57:28 <ski> is that a good thing ?
13:57:35 <albatross_> i guess?
13:57:45 * ski would agree
13:57:47 <metahumor> albatross_: okay, i'll rephrase -- lets say we have an "xs" that I promise to you is NOT '[]'
13:57:59 <metahumor> albatross_: would you expect "xs == (head xs) : (tail xs)"?
13:58:17 <ski> given that it's called `safeTail', it would be surprising if it deviated from `tail' (at least more than necessary) in a way that didn't have to do with the "safe" thing
13:58:24 <albatross_> metahumor, yeah i do
13:58:37 <ski> metahumor : good point
13:58:45 <albatross_> ski, i see your point now
13:58:51 <metahumor> then if you expect that, ski's expression of surprise is what matches up with that expectation
13:59:34 <metahumor> let's say we had a magic (:::) that made the following work: "Just xs == (safeHead xs) ::: (safeTail xs)"
13:59:54 <ski> albatross_ : now, remember that the notation `[x]' is syntactic sugar for `x:[]'. now perform the suggested replacement (for the sake of this exercise), and contemplate the resulting definition of `safeTail'
13:59:59 <metahumor> I wrote (Just xs) because the right hand side is all (Maybe blah)
14:01:06 <ski> (just like the notation `[x,y,z]' is syntactic sugar for `x:y:z:[]', which is read like `x:(y:(z:[]))'. `:' adds an element to the left to the *list* to the right. `[]' is the empty list. every list is built in one of these two ways (empty vs. non-empty))
14:01:41 <Zemyla> Does anyone have an updated link to the paper proving that ST is safe? I found an old link, but it 404s now.
14:01:42 <albatross_> ah ski, now i REALLY see your point
14:02:10 <albatross_> if i write safeTail [x] = Nothing, it really violates what it actually should be []
14:03:01 <metahumor> ehh, it shouldn't be plain old [], it should be ...?
14:03:13 <albatross_> metahumor, I'm not sure if you were asking me to answer a question
14:03:23 <albatross_> metahumor it should be Just []
14:03:35 <metahumor> yup
14:03:40 <albatross_> ding ding ding
14:04:08 <albatross_> ski, were you saying I should apply that to f'?
14:05:35 <metahumor> i think ski meant the general approach of writing functions that use lists to deal with only two cases, [] and (x:xs)
14:05:59 <metahumor> similar to how safeHead only considers [] and (x:xs), and now your safeTail only considers [] and (x:xs)
14:06:18 <dmwit> ski: Thanks. I found that link in the source. It is contained in an element whose CSS includes `display: none`. =(
14:06:20 <metahumor> your f' right now considers 5 cases
14:07:04 <metahumor> albatross_: what would you want (f' [0,1]) to be?
14:07:52 <albatross_> metahumor f' [0,1] = "**"
14:08:42 <metahumor> okay, now, which of the 5 cases of f' would [0,1] match?
14:09:15 <ski> dmwit : yea, i think W3m ignores CSS :)
14:09:22 <albatross_> 2nd and 4th
14:09:37 <dmwit> ski: Aha! Clicking "expand" deletes that CSS.
14:09:47 <dmwit> ski: Then the revision links are clearly visible.
14:09:58 <ski> albatross_ : did you perform the suggested replacement ?
14:10:18 <albatross_> on safeTail? or f'?
14:10:29 <ski> dmwit : oh, *that*'s how you do it ?!
14:10:40 <ski> on `safeTail'
14:10:46 <albatross_> yeah i did
14:11:04 <ski> and what insight, if any, did your contemplation then result in ?
14:11:35 <siwica> How can I run 'stack build' from inside Emacs intero-mode?
14:12:29 <albatross_> ski I don't think i'm getting what you are trying to say
14:12:43 <Zemyla> Why isn't tail just a synonym for "drop 1"?
14:13:40 <ski> i suppose `tail' is meant to be a partial accessor, and not to truncate/default
14:13:54 <phadej> > tail []
14:13:57 <lambdabot>  *Exception: Prelude.tail: empty list
14:14:32 <ski> (of course it only matters if you step outside the precondition of `tail' .. but it makes the definition of `tail' simpler, to newbies learning the trade)
14:14:57 <EvanR> tail, when it applies, follows a law that it reduces the length of the list by 1
14:15:13 <dmwit> Zemyla: I think I would prefer not having tail to having `tail = drop 1`.
14:15:33 <metahumor> lets just go back to car and cdr
14:15:44 <Zemyla> dmwit: I meant semantically. Instead of tail [] = badTail, just have tail [] = [].
14:16:18 <kadoban> Zemyla: Because sometimes that should be an error condition instead of silently doing nothing
14:16:24 <albatross_> ski, would you explain?
14:16:36 <phadej> tail :: NonEmpty a -> [a]
14:16:37 <ski> albatross_ : well, after the replacement, you get
14:16:41 <ski>   safeTail [    ] = Nothing
14:16:45 <ski>   safeTail (x:[]) = Just []
14:16:46 <ski>   safeTail (x:xs) = Just xs
14:16:48 <ski> yes ?
14:16:51 <albatross_> yes
14:16:51 <EvanR> if you are using tail in a situation where you think [] doesnt occur, tail can "catch" bugs
14:17:11 <EvanR> instead of hiding them
14:17:17 <phadej> I want type-system to catch them. NonEmpty helps
14:17:28 <dmwit> Zemyla: I don't understand why you think that would change my attitude.
14:17:30 <ski> now, as your eyes pass over these three definition equations of `safeTail', does anything in particular strike your mind ?
14:17:37 <phadej> group :: [a] -> [NonEmpty a] (from Data.List.NonEmpty) is one what you want to use, e.g.
14:17:47 <metahumor> in situations where you should have been using NonEmpty a instead... =) but yeah I can understand how its annoying to swap to NonEmpty when List has better support in the lang
14:18:10 <ski> phadej : refinement types might be nice ..
14:18:12 <albatross_> ski f' [x] = [] ??
14:18:28 <ski> albatross_ : i'm not considering that function (yet), only `safeTail'
14:18:33 <phadej> ski: yes, but NonEmpty is here already
14:18:34 <albatross_> ok
14:18:50 <dmwit> Zemyla: Today, I think no tail > current tail > tail = drop 1
14:18:57 <dmwit> Zemyla: No promises about tomorrow.
14:19:26 <ski> albatross_ : e.g. do you spot any .. regularities in this snippet of code ?
14:19:55 <albatross_> ski, i'm not sure what you are getting at :/
14:20:09 <dmwit> ski: This is the worst kind of trick question.
14:20:26 <EvanR> nonempty does introduce extra noise into the code
14:20:45 <dmwit> "Can you figure out what I, the teacher, am thinking?" Answer: yes, if you have enough expertise to be the teacher yourself. Otherwise no.
14:20:57 <ski> dmwit : yea i know .. but it's hard to do it better (or at least i don't see how to), if the learner doesn't take your hint ..
14:21:38 <dmwit> albatross_: Two of your clauses are redundant. Spend a little while trying to figure out which two; if you can't, say so, and I'll tell you.
14:21:40 <ski> thank you for the criticism
14:22:45 <dmwit> Well. Depending on how you understand "redundant". You might prefer the statement "one of your clauses is redundant".
14:22:59 <albatross_> safeTail [] is redundant ?
14:23:08 <ski> try removing it, and see ?
14:23:08 <dmwit> albatross_: Convince me.
14:24:14 * ski . o O ( overlapping vs. redundant )
14:24:24 <albatross_> ahhh dmwit, it is not redundant
14:24:52 <metahumor> albatross_: two of your three cases for safeTail have a very similar structure
14:24:57 <dmwit> albatross_: Same response: convince me!
14:25:12 <metahumor> albatross_: what is similar about these two, and what is different about them?
14:25:17 <albatross_> the element case and also the Just xs case
14:25:49 <metahumor> can you rephrase that in terms of the "right hand side" of the cases?
14:25:58 <albatross_> the similarity is that they both ignore the first element of the list
14:26:10 <metahumor> there's an additional similarity
14:26:15 <albatross_> the differences is that one contains element in the list and the other is an empty list
14:26:37 <albatross_> an additional similarity is that they both say Just ?
14:27:06 <metahumor> yes, that is true. and after ignoring the first element of the list, what do they do with the rest of the list?
14:27:24 <albatross_> metahumor they kept the rest of the list
14:27:54 <metahumor> that's right.
14:27:57 <ski> albatross_ : how would the behaviour of `safeTail' differ, if, say, the middle defining equation was removed ?
14:27:59 <albatross_> so i can just ignore teh last case
14:28:10 <albatross_> ski the same
14:28:13 <ski> why ?
14:28:20 <albatross_> metahumor i see it thanks
14:28:23 <metahumor> albatross_: try removing the last case, what happens then?
14:28:39 <shapr> shouldn't that be __main__ ?
14:28:41 <shapr> ohh
14:29:02 <ski> hej hopp, shapr
14:29:11 <albatross_> metahumor if i remove the last case it get an error message
14:29:33 <ski> so, in that case, the behaviour changes (do you see why ?)
14:29:40 <shapr> hej hopp ski! hur mår det med dig?
14:29:49 <albatross_> oh geez what language are we speaking now
14:29:56 <metahumor> yeah, because you only have cases of [] and (x:[]), without a general case for (x:xs). is there a case you can remove that will retain all the functionality you want and not give errors?
14:30:16 <albatross_> yeah, i can remove safeTail [x] = []
14:30:39 <metahumor> again, I think you mean "safeTail [x] = Just []"
14:30:47 <albatross_> metahumor leaving safeTail [] = Nothing and safeTail (x:xs) = xs
14:30:49 <metahumor> careful to remember the Just
14:30:57 <albatross_> yes Just xs
14:31:04 <albatross_> yep
14:31:27 <metahumor> can you explain again how you came to understand that you had a case you could remove?
14:31:57 <dzdcnfzd> even though I have the line 'import Servant (Proxy)', my code is telling me the data constructor for proxy is not available.
14:32:16 <dzdcnfzd> I refer to Proxy here: https://hackage.haskell.org/package/servant-server-0.11/docs/Servant.html#t:Proxy
14:32:45 <metahumor> dzdcnfzd: what happens if you do "import Servant (Proxy())
14:32:53 <dzdcnfzd> The error I get is: Data constructor not in scope: Proxy :: Proxy Api \ Perhaps you want to add ‘Proxy’ to the import list in the import of ‘Servant’
14:32:56 <kadoban> Because you can see that one is a generalization of the other.   f (x:[]) = ...    and f (x:xs) = ...   are redundant because    xs = [] is a possibility. Assuming they have the same right-hand sides of course.
14:33:30 <albatross_> metahumor the tail of x:[] and x:xs meant that we are dropping the first element of the list
14:33:35 <metahumor> dzdcnfzd: I meant "import Servant (Proxy(..))"
14:33:41 <dmwit> dzdcnfzd: import Servant (Proxy(Proxy))
14:33:56 <metahumor> buffalo buffalo
14:34:04 <albatross_> metahumor and I also tested it out on the terminal of the return result
14:34:11 <dmwit> dzdcnfzd: `import Servant (Proxy)` imports the type constructor but not the data constructor. You can list data constructors to import in parentheses, or use `..` to import all data constructors for that type.
14:34:11 <albatross_> buffalo?
14:34:23 <dzdcnfzd> dmwit, metahumor: yes!
14:34:26 <dzdcnfzd> thanks!
14:34:29 <ski> shapr : det mår bara bra :)
14:34:36 <shapr> :-)
14:34:37 <metahumor> the buffalo thing was just a reference to the Proxy(Proxy) thing
14:34:40 <dzdcnfzd> I suspected there was some sort of difference between the type and constructor
14:34:47 <dzdcnfzd> but haven't seen it before
14:35:04 <dmwit> dzdcnfzd: That said, I've started using `[] :: [Foo]` instead of `Proxy :: Proxy Foo` because it's so much shorter and `[]` is damn near always in scope. =P
14:35:28 <metahumor> albatross_: right, you only care about the "xs" in (x:xs), and it doesn't matter exactly what "xs" is
14:35:37 <ski> albatross_ : as a thought experiment, what would happen if you took the last defining equation of `safeTail', and (throughout) replaced `xs' by `[]' ?
14:35:38 <dmwit> dzdcnfzd: There's a terminology bug in your last message. Both `Proxy` at the term level and `Proxy` at the type level are constructors.
14:35:46 <dmwit> dzdcnfzd: One is a data constructor, and the other is a type constructor.
14:36:09 <albatross_> ski I will get an error message when i have an list of more than 1 item
14:36:22 <metahumor> albatross_: I don't think so
14:36:23 <albatross_> metahumor, thanks a lot,
14:36:41 <Peaker> is there any way to print the (preferably qualified) name of an exception type hiding inside a "SomeException"?
14:36:47 <dzdcnfzd> dmwit: yes, though in this case, I need the Servant type for the sake of its api
14:36:58 <Peaker> The "show" is human-readable - but it's hard to know which *type* you want to catch in order to catch it
14:37:00 <metahumor> albatross_: "weirdTail (x:xs) = Just []" would give an error?
14:37:20 <dmwit> dzdcnfzd: Usually consumers use `proxy` (with a lower-case) exactly so that the trick I proposed works.
14:37:33 <dmwit> dzdcnfzd: Are you sure Servant doesn't do likewise?
14:37:34 <Peaker> dmwit, how about: []@Foo ?
14:37:56 <dmwit> Peaker: Sure, depending on how friendly the current project is to extensions/demanding newish GHCs.
14:38:00 <albatross_> no, weirdTail [x] = Just [] , then i input weirdTail (x:xs) would give me an error
14:38:22 <metahumor> albatross_: ski asked about a thought experiment earlier
14:38:29 <albatross_> metahumor ski was asking what if i remove the last case of safeTail and keeping safeTail [x]
14:38:46 <ski> albatross_ : fwiw, the thought experiment works better, if you use the desugaring you had earlier
14:38:49 <mniip> hmm
14:38:52 <mniip> polykinded gadts
14:38:53 <Peaker> The "typeRep" of a SomeException just says it's a.. SomeException.. :-(
14:39:06 <dzdcnfzd> dmwit: https://hackage.haskell.org/package/servant-server-0.11/docs/Servant-Server.html#v:serve
14:39:06 <ski> albatross_ : sorry no, i didn't ask about that
14:39:11 <metahumor> mniip: i read that as "polykinded goats"...
14:39:18 <albatross_> let me read it again
14:39:28 <dmwit> dzdcnfzd: Nasty. File a bug. =)
14:39:29 <ski> <ski> albatross_ : how would the behaviour of `safeTail' differ, if, say, the middle defining equation was removed ?
14:39:49 <dzdcnfzd> What should it be replaced with?
14:39:58 <ski> (note "middle", not "last". my latter thought experiment about modifying the last one was a separate thing to try)
14:39:59 <lyxia> Peaker: pattern match and get the typerep of the wrapped value
14:40:08 <metahumor> good luck albatross_ !
14:40:14 <dmwit> dzdcnfzd: s/Proxy/proxy/g
14:40:23 <Peaker> lyxia, oh, right, there's an exposed field there, thanks!
14:40:36 <dzdcnfzd> I mean, on the type level
14:40:48 <dzdcnfzd> dmwit: what should the new signature of serve be?
14:40:50 <albatross_> ski, if the middle definition were removed safeTail would work the same
14:40:54 <albatross_> thanks metahumor
14:40:55 <dzdcnfzd> just replace Proxy a with [a]?
14:40:55 <dmwit> dzdcnfzd: s/Proxy/proxy/
14:40:56 <mniip> % data PList (a :: k) where PNil :: PList a; PCons :: a -> PList a -> PList a
14:40:57 <yahb> mniip:
14:40:59 <dmwit> dzdcnfzd: I really meant what I said.
14:41:02 <albatross_> metahumor are you leaving
14:41:05 <mniip> % :t PNil
14:41:05 <yahb> mniip: forall k (a :: k). PList a
14:41:16 <dzdcnfzd> dmwit: But isn't proxy... Oh, is proxy a typeclass?
14:41:19 <dmwit> dzdcnfzd: No, not `Proxy a`. Not `[a]`. `proxy a`
14:41:19 <mniip> (unlike [] :: forall (a :: *). [a])
14:41:25 <dmwit> dzdcnfzd: No. It's a variable.
14:41:33 <dzdcnfzd> dmwit: in a type signature?
14:41:42 <dzdcnfzd> dmwit: what does that mean?
14:41:42 <dmwit> dzdcnfzd: Sure. You use them all the time.
14:41:51 <dmwit> dzdcnfzd: You used one right afterwards. What is the `a` in `Proxy a`?
14:42:23 <dzdcnfzd> It's an argument to a type constructor
14:42:24 <dmwit> dzdcnfzd: Just because people don't usually give descriptive names to their type variables doesn't mean you *have* to give terrible names to your type variables. =)
14:42:25 <ski> albatross_ : yes .. and if you don't remove the middle, but instead change the last one as indicated ?
14:42:39 <albatross_> ski i got an error message
14:42:40 <dmwit> dzdcnfzd: Okay. Let me try again. What is the `m` in `Monad m => m ()`?
14:42:42 <mniip> dzdcnfzd, are you familiar with HKT
14:42:49 <mniip> for example the f in Functor f
14:42:56 <mniip> or, yes, the m in Monad m
14:43:18 <dzdcnfzd> mniip: I mean, I know what those mean, or at least, if I don't know what they mean, I don't know I don't know
14:43:26 <ski> (albatross_, in case you wonder, people keep talking to me in other channels, which is why i don't always respond immediately)
14:43:39 <albatross_> ski xD the cafe is closing in a few minutes, hope I will get yoru point before it closes
14:43:42 <dmwit> dzdcnfzd: Okay. So `proxy` is just a longer string of letters than `f` or `m`.
14:43:43 <dzdcnfzd> dmwit: But what's confusing me is that I thought everything in a type signature had to be a type
14:43:45 <ski> albatross_ : what is the resulting defining equation that you got after doing the replacement ?
14:43:48 <dmwit> dzdcnfzd: `p` would work just as well
14:43:53 <dmwit> dzdcnfzd: It *is* a type.
14:44:00 <dzdcnfzd> ooooh
14:44:03 <mniip> :t fmap
14:44:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:44:06 <ski> albatross_ : ok, sorry, i'll try to hurry up a bit and be more present, then
14:44:08 <dzdcnfzd> it's a polymorphic
14:44:09 <mniip> this f
14:44:09 <dzdcnfzd> okay
14:44:15 <mniip> is pretty much the same as
14:44:21 <mniip> :t GHC.TypeLits.natVal
14:44:22 <albatross_> ski safeTail (x:[]) = Just []
14:44:23 <lambdabot> GHC.TypeNats.KnownNat n => proxy n -> Integer
14:44:26 <mniip> this proxy
14:44:31 <albatross_> ski is that what you asked for?
14:44:36 <ski> yes it is
14:44:46 <ski> albatross_ : and how does this compare to the middle defining equation ?
14:44:49 <albatross_> ski i got an error message for that
14:44:52 <albatross_> oh
14:44:54 <albatross_> they are the same
14:44:57 <ski> exactly
14:45:10 <ski> *that* is *why* the middle defining equation was redundant
14:45:18 <albatross_> gotcha
14:45:27 <albatross_> thanks for your help ski
14:45:28 <dzdcnfzd> dmwit: and you don't need things wrapped in any particular type constructor to use them on the type-level?
14:45:34 <ski> because, in case the `xs' part of the input argument is passed as `[]', then these two defining equations will compute the same answer
14:45:36 <dzdcnfzd> (I've never done type-level programming)
14:45:43 <ski> albatross_ : now, you can do something similar with  f'
14:45:46 <dmwit> dzdcnfzd: I'm not sure I understood that question.
14:45:51 <mniip> me neither
14:46:02 <dmwit> dzdcnfzd: Ah, I think maybe I did. No, types need not have a constructor anywhere. For example:
14:46:03 <mniip> this isn't type-level programming
14:46:05 <dmwit> :t undefined
14:46:05 <albatross_> ski thanks
14:46:07 <lambdabot> a
14:46:10 <dmwit> no type constructors there
14:46:10 <albatross_> good night guys
14:46:19 <dmwit> :t return
14:46:21 <lambdabot> Monad m => a -> m a
14:46:28 <dmwit> no type constructors there either
14:46:29 <mniip> I would argue -> is a type constructor
14:46:35 <dmwit> Okay, fair.
14:46:36 <ski> albatross_ : keep in mind that, usually (not always), list recursions can be done, considering only empty vs. non-empty lists. only more seldom do you *need* to consider singleton lists like `[x]', or to consider more than one element at a time in a list, &c.
14:46:39 <mniip> => maybe less so
14:46:45 <dmwit> :t empty
14:46:47 <lambdabot> Alternative f => f a
14:46:54 <riaqn> hello, what are some GUI library that's cross-platform including html5 and desktop?
14:47:15 <dmwit> You might consider Alternative a type constructor, maybe.
14:47:20 <dmwit> Hm.
14:47:30 <dmwit> :t undefined :: (Alternative ~ Monad) => Int
14:47:32 <lambdabot> error:
14:47:33 <lambdabot>     Couldn't match type ‘Alternative’ with ‘Monad’
14:47:33 <lambdabot>       arising from an expression type signature
14:47:38 <mniip> that's unreachable
14:47:38 <dmwit> neato!
14:48:06 <ski> albatross_ : and, usually, if you *can* simplify your recursion like that, you *should*. sometimes you can only do this, if you define your function on empty lists (which might not be obvious at the start how to do, sensibly). it's usually worth it to make "empty cases" working, though
14:48:12 <dmwit> Oh, that didn't check what I wanted it to check.
14:48:32 <dmwit> :t let f :: Alternative f ~ Alternative g => f a -> g a; f x = x in f
14:48:34 <lambdabot> g a -> g a
14:48:36 <mniip> if you want to have zero tycons I think you're limited to various forms of 'error#'
14:48:37 <dmwit> neato!
14:48:49 <dzdcnfzd> mniip: Well, the proxy is getting used somehow. I'm not sure how to describe it, because I
14:48:50 <dmwit> In which case, I definitely would consider Alternative a type constructor. =P
14:49:07 <ski> hm, that's interesting
14:49:09 <Welkin> tycoons?
14:49:10 <mniip> usually said proxy is only used to drive type inference
14:49:12 <dmwit> mniip: seems so
14:49:17 <dzdcnfzd> 'm not well-enough versed, but Proxy a is, by definition, only useful for the type system, right?
14:49:20 <mniip> and on value level it's ignored
14:49:29 <dmwit> dzdcnfzd: pretty much
14:49:29 <dzdcnfzd> I see
14:49:30 <mniip> it's not type programming, just a
14:49:38 <mniip> baton passtrough of some sort
14:49:50 <Welkin> mniip: are you speaking english?
14:49:56 <dmwit> dzdcnfzd: Specifically, it is usually used to choose a particular class instance.
14:49:57 <Welkin> because I don't understand anything you are saying
14:49:58 <mniip> not sure
14:50:17 <dmwit> Welkin: Yes. "tycon" = "type constructor". "passtrough" was just a typo
14:50:29 <dmwit> Not sure which other bits you found tough, though.
14:50:52 <Welkin> what is a baton passthrough?
14:50:54 <Welkin> never heard of it
14:51:03 <mniip> I tried to do a metaphor
14:51:08 <dmwit> A "baton" is a token used in relay races to indicate who's currently running.
14:51:11 <dzdcnfzd> dmwit: I see. Why class instance in particular?
14:51:11 <mniip> looks like it didn't work
14:51:36 <dmwit> It is passed from one runner to the next.
14:51:51 <mniip> dzdcnfzd, well technically Proxy has a bunch of other uses
14:51:54 <dmwit> (There are other meanings of "baton", too, of course.)
14:52:07 <mniip> it is the terminal monad, monoid, applicative, and what not
14:52:27 <mniip> > do { x <- Proxy; x; x }
14:52:30 <lambdabot>  Proxy
14:52:49 <dmwit> dzdcnfzd: Hm. I find that question hard to answer. An alternative question that I would find easier to answer would be: "Why is Proxy used more for choosing instances than it is used for X?" for some concrete X.
14:53:30 <mniip> you could say the answer isn't natural in X
14:53:34 <dmwit> You are leaving it on me to cook up values for X right after I said I don't know of many other values for X. =P
14:53:35 <mniip> haha I'm hilarious
14:53:39 <dzdcnfzd> dmwit: I guess I don't know quite what it means to "choose" a class instance
14:53:52 <dmwit> dzdcnfzd: Oh, sure.
14:54:01 <Welkin> Proxy does still confuse me
14:54:02 <mniip> dzdcnfzd, simple, consider
14:54:09 <mniip> :t sum
14:54:09 <dmwit> dzdcnfzd: A standard trick is this. `class Foo a where foo :: proxy a -> Int`
14:54:10 <Welkin> I have read explanations, but I never remember
14:54:11 <lambdabot> (Num a, Foldable t) => t a -> a
14:54:13 <mniip> :t pure
14:54:16 <lambdabot> Applicative f => a -> f a
14:54:20 <mniip> now what is
14:54:22 <mniip> sum . pure
14:54:27 <dmwit> dzdcnfzd: This associates one `Int` with each type that is an instance of `Foo`.
14:54:33 <dmwit> dzdcnfzd: It's sort of a way to map types to `Int`s.
14:54:35 <mniip> (Foldable t, Applicative t) => a -> a ?
14:54:44 <mniip> that looks somewhat absurd doesn't it
14:54:47 <dmwit> dzdcnfzd: But now you need to supply this map with an input. =)
14:55:12 <mniip> you have no way of telling it what t to use
14:55:19 <dmwit> dzdcnfzd: (Imagine the incorrect `class FooWrong a where fooWrong :: Int` by comparison. How would you identify which type you wanted the `Int` for when you wrote `fooWrong`?)
14:56:14 <dmwit> dzdcnfzd: Phew, now you have two explanations, one my mniip and one by me. I recommend you pick one of us and read our full explanation first, then complain about the bits you don't understand, then read the other full explanation.
14:56:27 <mniip> we explained pretty much the same thing though
14:56:31 <mniip> an ambiguous type
14:56:37 <dzdcnfzd> Haha but you were talking over each other
14:56:42 <dzdcnfzd> I'm trying to thread through
14:56:45 <mniip> welcome to IRC
14:56:55 <dmwit> mniip: Yeah. But it turns out interleaving two copies of the same explanation is not clearer than just having one explanation. =)
14:57:27 <mniip> that's weird
14:57:41 <dmwit> (Also, I subtly left off the "then complain" bit from after the second readthrough because I expect it won't be needed.)
14:57:54 <Welkin> why don't you make a comic strip about it?
14:58:00 <Welkin> then you can just link it
14:58:20 <mniip> a comic strip about ambiguous types?
14:58:37 <Welkin> about proxy
14:58:58 <mniip> I can only draw ponies
14:59:18 <Welkin> then use ponies
14:59:25 <dzdcnfzd> dmwit, mniip: Thanks guys, I think I somewhat understand
14:59:50 <mniip> Welkin, expect a Chicken chicken chicken-chicken style paper
15:00:50 <mniip> wait
15:00:55 <mniip> since when do we have higher kinded defaulting
15:01:10 <mniip> (please don't be '98)
15:03:50 <mniip> what is this sorcery
15:07:19 <mniip> I can't even tell what it's defaulting to
15:09:41 <mniip> let { $dAlternative_a3SG = $fAlternative[] } in let { $dFoldable_a3SD = $fFoldable[] } in letrec { it_a3SK = length $dFoldable_a3SD (empty $dAlternative_a3SG); } in it_a3SK
15:09:47 <mniip> so it's [] for some reason
15:09:59 <mniip> but it doesn't default all *->* classes either
15:12:31 <mniip> is this documented? looking this up in the GHC sources seems tough
15:51:20 <Welkin> has anyone used pandoc to transform literate haskell into html, but have it looks identical to what you would see in a text editor?
15:51:33 <Welkin> I mean, not reading it as markdown
15:52:17 <Adluc> https://github.com/lucansky/pcb-tools
15:52:26 <Adluc> My first project halfly done :D
15:52:28 <Adluc> proud of it
15:53:40 <ggVGc> is it possible to get stack to skip the "installing executable" step?
16:01:05 <dmwit> mniip: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghc-flag--XExtendedDefaultRules
16:01:21 <dmwit> mniip: "The unit type () and the list type [] are added to the start of the standard list of types which are tried when doing type defaulting."
16:02:11 <dmwit> mniip: As usual, the description is precise but dense. Read carefully. I misunderstood it my first few times through.
16:03:32 <dmwit> mniip: Oh, and also relevant to your question, I guess, is "The interactive classes are any numeric class, Show, Eq, Foldable, or Traversable. As long as a type variable is constrained by one of these classes, defaulting will occur."
16:04:46 <MarcelineVQ> you can use :type +d to explore defaulting by hand as well
16:05:22 <dmwit> ggVGc: Dunno about stack, but with cabal, most commands take an optional target. You might look at the documentation for whichever stack command you're looking at to see the format of the target specifiers and see if one of them covers all the pieces you care about but not the executable(s).
16:05:45 <Welkin> MarcelineVQ: doesn't work for me
16:05:49 <dmwit> ggVGc: e.g. in cabal I'd expect a target like pkg-name:lib to work, or similar.
16:05:52 <Welkin> it gives a parse error on '+'
16:06:10 <Welkin> ghc 8.0.2
16:06:11 <MarcelineVQ> use a newer ghc :>
16:06:26 <Welkin> make me!
16:06:43 * ski makes Welkin up
16:06:52 <Welkin> I get tired of upgrading everything all the time
16:07:01 <dmwit> MarcelineVQ: Doesn't work for me either, on 8.2.1.
16:07:15 <MarcelineVQ> there it should work, what are you trying?
16:07:46 <dmwit> I was wrong.
16:08:17 <Welkin> dmwit: forgive you, for you have sinned, and now you see the light?
16:08:20 <Welkin> the light of the seven?
16:08:29 <dmwit> I tried :set +d assuming you had made a mistake. Then just to make sure I tried :type +d. But of course you need to give an expression to the latter...
16:08:41 <MarcelineVQ> :type +v is also pretty interesting
16:09:41 <Welkin> does nothing
16:09:44 <MarcelineVQ>   :type length  length :: Foldable t => t a -> Int       :type +d length    length :: [a] -> Int     :type +v length   length :: Foldable t => forall a. t a -> Int
16:10:11 <dmwit> ahh, I was wondering how one would be able to discover that information.
16:10:16 <Welkin> @type +d length
16:10:17 <dmwit> I hope haddocks start showing it somehow.
16:10:18 <lambdabot> [a] -> Int
16:14:47 <dmwit> MarcelineVQ: Hm. I don't understand how to interpret this output.
16:14:53 <dmwit> ?type +v (^)
16:14:56 <lambdabot> (Num a, Integral b) => a -> b -> a
16:15:00 <dmwit> ?let f = (^)
16:15:03 <lambdabot>  Defined.
16:15:04 <dmwit> ?type +v f
16:15:06 <lambdabot> error:
16:15:06 <lambdabot>     Ambiguous occurrence ‘f’
16:15:06 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.f’,
16:15:13 <dmwit> ?let foo = (^)
16:15:15 <lambdabot>  Defined.
16:15:16 <dmwit> ?type +v foo
16:15:18 <lambdabot> (Num a, Integral b) => a -> b -> a
16:15:30 <dmwit> MarcelineVQ: Identical output, yet one allows type applications and the other doesn't.
16:15:42 <dmwit> So what purpose is +v actually serving?
16:17:38 <dmwit> ah
16:17:44 <dmwit> % :set -fprint-explicit-foralls
16:17:44 <yahb> dmwit:
16:17:49 <dmwit> % :t +v (^)
16:17:50 <yahb> dmwit: forall a b. (Num a, Integral b) => a -> b -> a
16:17:55 <n_blownapart> wondering if a (difficult) class in discrete math would be worthwhile, or would I get enough of that discipline by just continuing to hack with haskell
16:17:59 <dmwit> % foo = (^)
16:17:59 <yahb> dmwit:
16:18:02 <dmwit> % :t +v foo
16:18:02 <yahb> dmwit: forall {b} {a}. (Integral b, Num a) => a -> b -> a
16:18:06 <dmwit> boom
16:18:51 <dmwit> n_blownapart: You will not get much of that discipline just by hacking in Haskell.
16:19:05 <dmwit> I do not know how to judge how much is "enough". My gut reaction is "not enough".
16:19:52 <MarcelineVQ> % :t foo
16:19:52 <yahb> MarcelineVQ: forall {b} {a}. (Integral b, Num a) => a -> b -> a
16:20:12 <dmwit> % :t (^)
16:20:13 <yahb> dmwit: forall {b} {a}. (Integral b, Num a) => a -> b -> a
16:20:13 <MarcelineVQ> I'm not actually sure what the answer to your question is dmwit :(
16:20:14 <n_blownapart> thanks. remember that tautology checker I was working on? that's from a textbook, I learned a lot with it... wondering how much more will be covered in that vein
16:20:24 <n_blownapart> dmwit ^
16:21:15 <dmwit> MarcelineVQ: Seems the answer is that :t +v and -fprint-explicit-foralls taste great together and are worthless if you use just one or the other.
16:26:06 <argent0> hi, I'm using stack. I have lib/Foo.hs and then I have in the file Lib.hs `import Foo`. It says `could not find Module' how do you modularize your code with stack
16:26:29 * argent0 is new to stack
16:30:02 * argent0 of course, the file was missplaced :p
17:11:28 <manjaroi3> hello haskell people, I have a question
17:11:45 <duncan^> Ask it
17:11:57 <Welkin> is it about manjaro or i3?
17:12:30 <manjaroi3> say I want to represent a list of characters as data type, what is the idiomatic way to do this?
17:12:38 <Welkin> o.o
17:12:45 <Welkin> a List of Char
17:12:48 <Welkin> [Char]
17:13:07 <manjaroi3> that's too general
17:13:12 <duncan^> How?
17:13:20 <duncan^> It is a list, of characters.
17:13:31 <duncan^> That is the data type of such a list.
17:13:31 <manjaroi3> it is correct, but it is not accurate
17:13:41 <duncan^> They are not synonyms?
17:13:51 <manjaroi3> let's say I don't want the char '8' to be in it
17:14:07 <duncan^> Sure, its type is still [Char]
17:14:19 <manjaroi3> what you say is correct
17:14:22 <manjaroi3> but not accurate
17:14:24 <duncan^> but it is not accurate
17:14:26 <duncan^> yeah we get it
17:14:43 <duncan^> You should ask more pertinent questions
17:14:57 <duncan^> Then you might get more pertinent answers.
17:15:16 <manjaroi3> ok, gimme a second
17:15:52 <Welkin> to be, or not to be, that is the question
17:16:12 <duncan^> How very Rumsfeldian
17:16:28 <manjaroi3> Let's say I want to represent even numbers in my program as a data type
17:16:44 <Welkin> you are looking for dependent types
17:16:52 <Welkin> haskell does not quite have those yet
17:17:17 <manjaroi3> I know, but is there a workaround? some idiomatic way of hacking haskell to do this?
17:17:49 <duncan^> You can implement your own types, but you might not find it very amicable
17:18:05 <Welkin> data Even = Two | Four | Six | Eight ...
17:18:12 <manjaroi3> is that a joke?
17:18:15 <Welkin> no
17:18:16 <duncan^> No.
17:18:31 <ski> dependent types, or refinement types
17:18:47 <exio4> manjaroi3: the 'workaround' inside normal Haskell would be to do this manually with smart constructors
17:18:55 <exio4> manjaroi3: another solution is to use Liquid Haskell
17:19:29 <ski>   data EvenInteger = DoubleThe Integer
17:19:31 <Welkin> smar constructors work well enough
17:19:36 <ski> `DoubleThe 3' represents `6'
17:19:39 * duncan^ still uses hugs!
17:20:04 * ski hugs duncan^
17:20:43 <manjaroi3> thanks I will look these up
17:20:57 <ammazza> @undo do { foo 'c'; bar "hello"}
17:20:57 <lambdabot> foo 'c' >> bar "hello"
17:21:07 <ammazza> @undo do { x <- foo 'c'; bar x "hello"}
17:21:08 <lambdabot> foo 'c' >>= \ x -> bar x "hello"
17:21:18 <koz_> I wanna do a bunch of stuff in Haskell which is SIMDable as hell. Should I be using Repa?
17:21:49 <Welkin> https://ghc.haskell.org/trac/ghc/wiki/SIMD
17:22:01 <Welkin> you can use SIMD in C and use the CFFI
17:22:27 <koz_> Welkin: How unpleasant is the latter option?
17:22:33 <Welkin> no idea
17:22:35 <Welkin> I've never done it
17:22:37 <koz_> Building a patched GHC seems really unpleasant.
17:22:50 <Welkin> it shouldn't be any different than doing anything else with the CFFI
17:23:12 <koz_> Welkin: Let me rephrase then. How unpleasant is the C FFI in general?
17:23:14 <c_wraith> koz_, is it stuff llvm would get right?
17:23:36 <Welkin> I find the CFFI to be fine
17:23:40 <koz_> c_wraith: As in, if I wrote it using dumb C, would Clang vectorize it?
17:23:46 <c_wraith> koz_, yes
17:23:50 <koz_> ('dumb' meaning 'no instrinsic use')
17:24:08 <c_wraith> yeah, that's how I read it.
17:24:15 <koz_> I'm unsure about whether Clang would optimize this honestly. I wanted to write this in Haskell for a reason, lol.
17:24:32 <koz_> And I'd probably use intrinsics in C anyway just to make sure.
17:24:51 <c_wraith> I only ask because if llvm will do it, just compiling with the llvm backend is the best approach
17:25:19 <koz_> c_wraith: I'm genuinely not sure, but that seems the easiest option.
17:25:34 <koz_> Or I could learn the C FFI I guess.
17:26:07 <c_wraith> one other option - you could write your own ghc primops, which can be packaged in libraries these days
17:26:08 <koz_> But from the answers, I gather I don't want Repa?
17:26:49 <c_wraith> repa is designed for multi-core parallelism, not really vector operations
17:27:19 <koz_> Ah, OK. So for that, it's one of 'C FFI', 'LLVM backend and pray', or 'compile a patched GHC'?
17:27:37 <c_wraith> new primops doesn't require patching ghc
17:27:45 <koz_> Primops?
17:28:16 <c_wraith> the imperative bits of code IO is built on top of.
17:28:37 <koz_> c_wraith: Ah, OK
17:28:51 <dzdcnfzd> Hey all. Wondering if someone can help me debug a type error that happens when I add BasicAuth to my servant API: http://lpaste.net/7880051814517702656
17:29:16 <koz_> c_wraith: What do I need to read to be able to use them? How would this be different to the C FFI?
17:29:19 <Welkin> https://downloads.haskell.org/~ghc/7.2.2/docs/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html
17:29:21 <c_wraith> they're written in C--, which... may or may not give you vectorization hints. maybe it wouldn't work after all.
17:29:31 <Welkin> I would love to play with primops at some point
17:30:00 <koz_> I think C FFI seems like the safest bet. Could anyone advise me on any reading material/examples/etc for it?
17:30:05 <dzdcnfzd> What I can't figure out is how to match the type of the functions I'm passing to readerServer with their respective API types
17:30:18 <Welkin> oh, here is the latest https://hackage.haskell.org/package/ghc-prim-0.5.1.1/docs/GHC-Prim.html
17:30:59 <Welkin> koz_: this is okay https://wiki.haskell.org/Foreign_Function_Interface
17:31:01 <c_wraith> koz_, the ghc manual has an excellent reference. not sure where to go for more introductory stuff. I think I just looked at a couple libraries to get the basic idea.
17:31:12 <koz_> c_wraith, Welkin: OK, thanks. I will read.
17:31:24 <Welkin> ah yes
17:31:25 <Welkin> https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/ffi-chap.html
17:31:29 <Welkin> I used that, too
17:31:36 <koz_> OK, thanks!
17:31:47 <dzdcnfzd> I can't actually figure out how ServerT Api (...) matches your Api with your handling code, which is making my efforts to debug fruitless
17:32:15 <dzdcnfzd> Or, put another way, how :<|> constructs a ServerT in the first place
17:32:31 <Welkin> dzdcnfzd: in the order they appear
17:32:55 <Welkin> the api spec has to be in the same order as the handlers
17:32:58 <dzdcnfzd> Welkin: I understand that, but I mean the actual process by which it happens
17:33:19 <Welkin> you could ask in #servant
17:33:34 <dzdcnfzd> Ooh, thanks!
17:39:31 <koz_> c_wraith, Welkin: When I'm dealing with SIMD vector types, I assume I have to treat them as opaque structs when using the Haskell FFI?
17:39:37 <koz_> s/Haskell/C/
17:40:37 <Welkin> you will want to use Storable Vectors
17:40:48 <koz_> Welkin: Ah, OK.
17:41:11 <Welkin> https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Storable.html
17:41:11 <koz_> https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Storable.html <-- these?
17:41:19 <koz_> Seems like I owe you a soda, lol. :P
17:43:58 <koz_> Welkin: Which specific Storable should be in such vectors? For example, suppose I'm dealign with __m128: what should I use to represent it in my Haskell code?
17:44:59 <koz_> Is that just Vector Float which just happens to have a certain size?
17:45:14 <Welkin> I'm not sure. I've never done what you are trying to do before
17:45:34 <koz_> Welkin: OK, thanks anyway.
17:50:30 <koz_> Welkin: This seems to be a way to go: https://hackage.haskell.org/package/primitive-simd
17:53:47 <Welkin> I didn't know that existed, cool
17:54:46 <koz_> Also, how do I tell Stack that I want (for example) to have the vec256 flag on for this package?
17:55:34 <Welkin> try passing the flag when you install the package, perhaps
17:55:50 <koz_> Welkin: I usually just ask it to build and have it pull the deps automatically.
17:56:05 <koz_> I figured I'd have to say something in the cabal file, but I dunno what, having never dealt with this before.
17:56:55 <Welkin> https://docs.haskellstack.org/en/stable/yaml_configuration/#flags
17:57:05 <koz_> Welkin: Thanks!
17:57:06 <Welkin> in your stack.yaml instead
17:57:17 <koz_> That'll come in handy.
17:57:43 <Welkin> I learn new things in here every day
17:57:47 <Welkin> I didn't know stack could do that either
18:04:08 <jchia> I think a common command-line profiling option to give to the RTS is -p, but where is it documented? It's not on this page: https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/runtime_control.html
18:05:03 <jchia> I can see it in the description from +RTS -help, though
18:05:06 <Welkin> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
18:18:55 <koz_> Could someone please explain to me the data declarations here: https://hackage.haskell.org/package/primitive-simd-0.1.0.0/docs/Data-Primitive-SIMD.html#t:Word64X8
18:19:09 <koz_> Like, what does the 'data Vector Word64X8 = ...' mean exactly?
18:19:51 <jchia> koz_: I think it's type family
18:21:06 <jle`> koz_: it's a 'data family', a special type of type family
18:21:51 <jle`> koz_: it means it's generating the type 'Vector Word64X8', a type which has one constructor, V_Word64X8
18:22:12 <jle`> koz_: and that constructor contains a `Data.Vector.Vector Word64X8` as its only field
18:23:13 <koz_> OK, and if that was missing, does that mean that Vector Word64X8 wouldn't work as a type in my Haskell code?
18:23:33 <jle`> 'Vector Word64X8' is a type that should work anywhere
18:24:10 <jle`> think of it like, for `data Maybe a = Nothing | Just a`, 'Maybe' is parameterized by a type 'a', and for every 'a', you have the same two constructors, Nothing or Just
18:24:19 <koz_> OK.
18:24:25 <jle`> in this case, you have a paramterized type 'Vector a', except for every choice of 'a', you have different constructors
18:24:37 <jle`> the constructor for 'Vector Word64X8' is V_Word64X8
18:24:41 <koz_> Ah, I see.
18:24:45 <koz_> That makes sense, thank you!
18:24:50 <jle`> like how the constructor(s) for `Maybe Int` are Nothing/Just
18:24:52 <jchia> jle`: Can type family be said to be ad-hoc polymorphism, like C++ templates?
18:24:53 <jle`> no problem :)
18:25:02 <cheater> is there something weird about doing case expressions on Int?
18:25:13 <cheater> i just tried that and the results were not as expected.
18:25:14 <jle`> cheater: there's some syntactic sugar going on, yes
18:25:17 <koz_> cheater: Could you be more specific? What issue are you encountering?
18:25:19 <jle`> Int's "constructors" are abstract
18:25:35 <jle`> jchia: hm, i'm not sure exactly what you mean sorry
18:25:58 <jle`> cheater: `case myInt of 1 -> ...` is syntactic sugar that lets you treat 1 as a "constructor" for Int
18:26:07 <jle`> but it's sugar for case myInt of n | n == 1 -> ...
18:26:17 <jchia> not sure if you are familiar with C++ templates. You can say something like "template<typename T>foo(...);" Then you can specialize for specific cases of T.
18:26:19 <cheater> loop old = do { new <- bar; case new of { old -> return (); otherwise -> print new }; loop new }
18:26:26 <cheater> this would always print no matter what bar returned
18:26:34 <jle`> cheater: oh in that case it has nothing to do with Int's
18:26:39 <jle`> there you're shadowing the definition of 'old'
18:26:41 <cheater> what then
18:26:50 <cheater> how am i shadowing?
18:26:50 <koz_> Also, because I keep forgetting, what is the name of the field of an 'executable' in a cabal file that allows me to tell the code that I have some additional files to be used as libraries?
18:26:51 <jle`> `case new of blah -> ...`
18:26:53 <cheater> oh
18:26:54 <cheater> right
18:26:55 <cheater> duh
18:26:57 <jle`> cheater: it makes a new definition of 'blah'
18:26:59 <jle`> to be whatever 'new' is
18:27:04 <cheater> i should -Wall
18:27:10 <jle`> -Wall is helpful :)
18:27:10 <cheater> i guess that would've caught it
18:27:11 <jchia> In type families you 'specialize' for different type parameters, instead of providing a uniform definition for all type parameters, like in "[a]"
18:27:27 <cheater> yeah why on earth doesn't cabal turn it on in new cabal files by default
18:27:55 <koz_> other-modules, OK.
18:28:02 <jle`> jchia: hm, is that what you do forC++ templates as well?
18:28:04 <cheater> thanks guys
18:30:15 <jchia> C++ templates allows you to provide a definition for all types T that you plug in, but you can override for specific instances of T by providing definitions for specific cases. So it allows both parametric and ad-hoc polymorphism.
18:30:40 <jle`> ah i didn't realize that you can do that with C++ templates
18:30:41 <jchia> So, I tend to associate type families to C++ templates
18:30:49 <jle`> yeah, there might be a relationship there
18:31:23 <jchia> I started becoming more comfortable with type families once I made that connection.
18:33:04 <jchia> jle`: Is it accurate to say that one of the reasons to use type families is this: "length :: [a] -> Int". Doesn't care what a is. If you want a version of length that does different things for different a's, for a limited set of a's, then you need type families.
18:33:31 <cheater> btw is there a good way to replace this pattern? http://lpaste.net/361785
18:39:39 <jle`> jchia: it's a bit tricky though because you have to handle type family results in a parametrically polymorphic way
18:40:08 <jle`> if you had `length :: ListOf a -> Int`, you can't really do anything that depends on specific 'a'
18:40:19 <jle`> because of type erasure
18:40:29 <elvishjerricco> Does GHC have a mode for aligning the number of OS threads in use with a max system load? So it stops using or gets rid of OS threads when it detects the system load is over a certain threshold?
18:40:32 <jle`> in the case of type families, 'ListOf a' is basically a text find-and-replace
18:40:54 <jle`> to do anything interesting, you'd probably have to use GADTs or data families
18:40:56 <elvishjerricco> Something like `make -l` but for GHC's OS thread management
18:58:19 <jchia> profiling question: The names in the .hp file are truncated, e.g. 'primitive/basicUnsafe...', so they are useless. How can I get normal names?
19:03:46 <acowley> jchio: You can control how much they are truncated with a -L flag, I think
19:04:01 <acowley> So, like -L40
19:10:37 <argent0> Hi, Is it possible to define this instance? http://lpaste.net/361787 . Involves GADTs
19:11:11 <manjaroi3> i am back
19:11:16 <manjaroi3> :)
19:12:17 <glguy> argent0: Are you trying to use ScopedTypeVariables ?
19:12:41 <glguy> Because you need to enable that via a {-# Language pragma
19:13:41 <argent0> glguy: I wasn't. I enabled it and still get the same error
19:13:56 <argent0> Couldn't match expected type ‘SqlType a0’ with actual type ‘a’
19:15:17 <glguy> OK, now update the type signature to SqlType a
19:16:45 <glguy> Keep in mind that the only reason that the 'a' in (sqlColumns :: SqlType a) is related to the instance you're defining is because ScopedTypeVariables is now enabled
19:17:01 <glguy> otherwise it would be a fresh 'a' local to the type signature you were defining
19:17:33 <argent0> glguy: Ok, thanks for the help it works now
19:18:24 <argent0> It wasn't clear to me that ScopedTypeVariables also worked for instances
19:20:59 <ludat> hi everyone, I've run into a thing, let's say I have `data Wrapper a = Wrapper a` can I do something like `instance (Foldable a) => Foldable (Wrapper a)`? I know that's not valid but is there some way to get this to compile? or I'll have to write `wrappedSum` and so on
19:21:53 <glguy> You'd need to write an: instance Foldable Wrapper
19:22:38 <glguy> and as a special case here, if you turn on {-# Language DeriveTraversable #-}, you can derive Functor, Foldable, and Traversable
19:23:08 <glguy> The problem with what you wrote is there is a kind error, Foldable expects a type with kind * -> *, but Wrapper a would have kind *
19:28:13 <ludat> hmm it compiles but now I need to override the definitions
19:30:04 <manjaroi3> smart constructors were very interesting
19:35:33 <manjaroi3> data EvenInteger = DoubleThe Integer
19:35:36 <manjaroi3> what a friendly community
19:36:39 * kadoban valiently resists the urge to make a rude gesture
19:37:57 <ludat> glguy, I'm building something that traces operations on some data, and a valid operation is `sum` for example and I wanted to avoid having to reimplement all the foldable functions
19:38:49 <glguy> 1) For Foldable you'd need only implement one operation to start 2) Foldable can be derived automatically 3) you probably want a newtype and not a data for this
19:39:13 <unyu> What does the default Foldable instance do for a type that isn't even a Functor?
19:39:45 <unyu> Say, "data Endo a = Endo (a -> a) deriving Foldable".
19:40:01 <glguy> That type can't be Foldable
19:40:16 <glguy> without trivially being one where it always is toList _ = []
19:40:35 <glguy> So I would expect that deriving would fail
19:40:35 <ludat> it says that deriving Foldable needs Functor
19:40:48 <glguy> ludat: OK, derive that , too
19:41:51 <ludat> but if I derive Foldable and Functor using DeriveTraversable I can't override them
19:42:09 <unyu> glguy: But, if I recall correctly (I checked very long ago), Hackage says that Foldable doesn't have any interesting laws that aren't enforced by mere typechecking.
19:42:17 <glguy> Yeah
19:42:28 <glguy> ludat: OK, then only implement the bare minimum required by the Foldable class
19:42:34 <glguy> You can look in the documentation to see what that minimum is
19:43:06 <unyu> glguy: How can that be true if there is no meaningful "instance Foldable Endo"?
19:43:47 <glguy> unyu: I don't know what conflict you're thinking of
19:43:53 <unyu> Oh, never mind. base's documentation now gives laws for Foldable.
19:44:11 <unyu> But I distinctly recall that at some point it didn't give Foldable laws.
19:46:09 <glguy> What instance for Endo did you have in mind? toList (Endo f) = [fix f] -- perhaps?
19:47:05 <unyu> glguy: I didn't have any particular instance in mind. In fact, it baffles me that a Foldable instance can be provided for a non-Functor.
19:47:15 <unyu> Errr, a meaningful* Foldable instance.
19:47:33 <glguy> OK, Do you know of any examples of such instances already?
19:47:40 <ludat> oh, I just read more carefully the type of foldr and it really doesn't make sense to use it the way I want to use it
19:48:38 <unyu> Mmm, maybe there is one for Set, but that one really *is* a functor (HaskOrd -> Hask at the very least), even if it isn't a Functor.
19:50:07 <WinterFox[m]> Is there a name for the datatype that have named parameters like `data Foo = Foo {a :: Int, b :: Int}`?
19:50:24 <kadoban> WinterFox[m]: A record type I believe
19:50:53 <WinterFox[m]> I have seen it called record syntax so that seems right.
19:51:16 <ludat> I just noticed that I want something like `instance Foldable t => Foldable (Tagged (t ?)) where` which I don't think is possible with haskell right?
19:51:28 <ludat> WinterFox[m]: yep, record is usually called
19:53:26 <WinterFox[m]> I just don't understand why records have to fill the namespace with functions for every name.
19:55:09 <ludat> `instance Foldable t => Foldable (Tagged . t) where`??
19:58:33 <glguy> nope
19:59:20 <glguy> % :info Data.Functor.Compose.Compose
19:59:21 <yahb> glguy: type role Data.Functor.Compose.Compose representational nominal nominal; newtype Data.Functor.Compose.Compose (f :: k -> *) (g :: k1 -> k) (a :: k1) = Data.Functor.Compose.Compose {Data.Functor.Compose.getCompose :: f (g a)}; -- Defined in `Data.Functor.Compose'; infixr 9 `Data.Functor.Compose.Compose`; instance forall (f :: * -> *) (g :: * -> *). (Alternative f, Applicative g) => Alternative (Data
19:59:40 <glguy> Well, that's more than I had hoped for, but it's kind of what you're trying to do
19:59:54 <jle`> thanks yahb
20:24:37 <ggVGc> is it possible to unit test code in an "executable" target, or do I have to move it to a library?
20:25:43 <glguy> You should move it to the library; worst case you can add the executable's source directory to the test suite's hs-source-dirs
20:25:56 <glguy> that results in having to recompile things, though
20:26:08 <glguy> and to specify dependencies in multiple places
20:26:21 <ggVGc> alright
20:26:22 <ggVGc> thanks
20:31:47 <manjaroi3> Can I write the following in a dependently typed language or am i just retarded? [1,2,3] -> FooBar
20:32:25 <glguy> What does that mean in your dependently typed language?
20:34:34 <manjaroi3> it defines FooBar
20:35:19 <byorgey> if you mean it defines FooBar to be the list [1,2,3], you don't need a dependently typed language to do that.
20:35:43 <ggVGc> I think he means the type FooBar will be those thre numbers
20:35:58 <ggVGc> but yes, that could be done in haskell at this time
20:36:08 <manjaroi3> how
20:36:47 <byorgey> manjaroi3: I still don't understand what you are asking.  We are just guessing at this point.  Is FooBar supposed to be a type?  What does the arrow mean? What would you do with FooBar?
20:38:29 <manjaroi3> think of FooBar as a functor that only knows about 1,2,3
20:39:09 <glguy> You might be misunderstanding "functor"
20:39:32 <glguy> You're trying to define a type that is a subset of the integers perhaps?
20:40:29 <manjaroi3> no, I am asking if it makes sense for a language to allow such an expression
20:40:51 <glguy> Your question doesn't make sense, so we're trying to narrow it down to something we can answer
20:41:34 <manjaroi3> it does not make sense in haskell, but i want to know if it's a limitation of haskell
20:42:47 <manjaroi3> for example in haskell we say: data Functor = Functor a
20:43:14 <manjaroi3> no sorry
20:45:29 <manjaroi3> I guess I still don't understand where exactly the division between types and values is
20:46:44 <cawfee> 【 http://www.paultaylor.eu/stable/prot.pdf 】
20:55:16 <manjaroi3> fun :: [1,2,3] -> FooBar ---- fun 1 = One, fun 2 = Two, fun 3 = Three
20:56:43 <manjaroi3> fun is here a functor from a cat that has only three identities to cat with only three identities
20:57:30 <manjaroi3> does that make sense?
20:59:03 <byorgey> manjaroi3: so it's just a function at the level of types?
20:59:37 <byorgey> it the categories only have identity morphisms then the fact that it is a functor is not very interesting.  It would just be a mapping between objects.
20:59:49 <byorgey> s/it the/if the/
21:00:55 <byorgey> manjaroi3: if I have understood what you want, you could create such a thing in Haskell with something like a closed type family
21:02:54 <manjaroi3> let me look it up
21:14:44 <glguy> % parseTest (P.char 'a' <* P.char 'b') "abc" -- boathouse2112
21:14:44 <yahb> glguy: 'a'
21:15:17 <glguy> mniip: Can we have megaparsec added?
21:15:18 <dmj`> manjaroi3: http://lpaste.net/2576583252038909952
21:16:54 <parsnip> why don't imperative or OOP have flagship languages like haskell to show them in an elegant light?
21:17:30 <parsnip> python seems closest
21:27:59 <Hijiri> Is there a luminance example using transformations passed through uniforms known to work with the newest version of luminance?
21:31:55 <ski> parsnip : hmm .. maybe Ada or something ?
21:33:20 <ski> cawfee :)
21:33:36 <MarcelineVQ> gweenteee
21:33:36 <Hijiri> well it seems like I can pass uniforms ok, so maybe it is some issue with the transformations
21:34:21 <Hijiri> or maybe it just doesn't work in DrawCmds
21:34:59 <ski> manjaroi3 : it looks like by `[1,2,3]' you mean a type which only contains `1',`2',`3' as values ?
21:36:18 <Hijiri> ah no, it doesn't look like I'm succeeding at changing the transformation even when making it part of the ShadingCmd
21:36:31 <parsnip> thanks. ada is not in my radar.
21:36:34 <parsnip> *now
21:36:51 <Hijiri> Should I be able to use the projections from Linear.Projection as-is with Luminance?
21:38:45 <ski> parsnip : as far as (a bit old, structured) imperative languages go, Ada isn't too bad, it seems
21:39:15 <ski> it has in and out parameters, for procedures
21:39:43 <ski> (as opposed to using `&' to pass a pointer in C, or using reference arguments in C++, say)
21:40:11 * ski now has a vague memory of C# also having in and out parameters ..
21:41:29 <ski> Ada has this thing called "variant records", which is sortof product-of-sums data types. you can encode variant types (or algebraic data types), using it
21:41:58 <ski> (recall that algebraic data types are sums-of-products)
21:44:34 <dmwit> parsnip: For a "just the elegant basics" of OOP, consider smalltalk.
21:47:08 <ski> (in C syntax, what you do is something similar to `struct { enum tag {fee,fi,fo,fum}; switch (tag) { case fee: break;  case fi: int k; break;  case fo: size_t k; blah_t *blahs; break;  case fum: char *str; break; } }', and then you proceed as with a C `struct'-containing-`union')
21:47:25 <glguy> Io's a basics language for prototype-based OO
22:01:08 <jchia> In an IO do block, I have two "atomically $ writeTBQueue ..." writing to the same queue. I'm observing in the reader of the TBQueue a reordering. Are those two writes in my IO block reorderable? I'm puzzled about the observed reordering.
22:01:47 <dmwit> IO actions are in general not reordered.
22:01:50 <glguy> No, atomically things aren't reorderable
22:01:58 <dmwit> Perhaps you have a smallish example we can see/try ourselves...?
22:04:22 <Hijiri> ugghghghghghgh
22:04:30 <Hijiri> Linear matrices are row major
22:04:42 <Hijiri> but for some reason luminance treats them as column major when sending them to gpu
22:05:10 <jchia> OK, I read the logs wrongly.
22:05:31 <jchia> I was using writeTBQueue to multiplex logs from multiple threads.
22:05:46 <Hijiri> I want my hours back
22:08:55 <royal_screwup21> I'm looking for an example with the "return" function of the Monad class
22:08:57 <jchia> I have a TBQueue reader thread that's responsible for copying from the queue to the console. Somehow it's running very slowly and I'm seeing the logs very late, many seconds after I they have been written to queue. I run with +RTS -N20 -RTS and there are 20 worker asyncs writing to the TBQueue and 1 async reading from it. What can cause the reading thread to be so slow? My program is very sluggish. Perhaps something about GC?
22:09:26 <kadoban> > return 5 :: Maybe Int
22:09:30 <lambdabot>  Just 5
22:14:09 <royal_screwup21> kadoban: ah interesting. when I type that out on ghic, I get 5 (not Just 5)
22:14:09 <dmj`> jchia: Can you paste your code
22:14:29 <jchia> dmj`: Big project.
22:14:36 <royal_screwup21> > return 5
22:14:39 <lambdabot>  error:
22:14:39 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M929387877954...
22:14:39 <lambdabot>        prevents the constraint ‘(Show (m0 Integer))’ from being solved.
22:14:49 <dmj`> royal_screwup21: return 5 in ghci will assume you’re in the IO monad, are you doing return (Just 5)
22:15:21 <kadoban> royal_screwup21: It's using a different type, it should be    return 5 :: IO Int, and then ghci automatically "runs" that action and gives you the result, which is 5
22:15:57 <royal_screwup21> :t return
22:15:59 <lambdabot> Monad m => a -> m a
22:16:31 <royal_screwup21> hmm could you walk me through what happens when you do return 5:: Maybe Int
22:16:43 <royal_screwup21> I'm looking at the definition but it isn't making much sense
22:17:13 <kadoban> Not a lot, it just uses the instance that's defined for Maybe, which the only thing it could possibly lawfully do is throw it in a Just
22:18:19 <simon> royal_screwup21, you're looking at the type for return. it makes more sense when you look at concrete definitions for return for instances of Monad that you understand.
22:18:24 <kadoban> There's some code somewhere in GHC's crap with    instance Monad Maybe where\n return = Just   (and then the more interesting (>>=) definition)
22:18:41 <royal_screwup21> :src return
22:19:48 <simon> royal_screwup21, e.g. 'return x = Just x' for Maybe a.
22:19:55 <simon> :t Just
22:19:57 <lambdabot> a -> Maybe a
22:20:06 <simon> :t return
22:20:08 <lambdabot> Monad m => a -> m a
22:20:20 <Hijiri> and the rest of my problems were caused by me using pointwise multiplication rather than matrix multiplication
22:20:23 <Hijiri> fun stuff to debug
22:20:33 <Hijiri> at least it's over
22:20:38 <kadoban> If it helps, 'return' is somewhat unfortunately named. There's *very* little magic there. It's just a function that makes like, the most uninteresting possible value of the correct type.
22:20:57 <simon> :t Right
22:21:00 <lambdabot> b -> Either a b
22:22:25 <simon> :t (:[])
22:22:28 <lambdabot> a -> [a]
22:24:14 <simon> royal_screwup21, those are all definitions of return for various Monad instances.
22:25:17 <simon> :t (\x -> [x]) -- that was the last one, but less cryptic
22:25:19 <lambdabot> a -> [a]
22:25:45 <royal_screwup21> hmm need some time to wrap my head around this, hehe
22:26:13 <kadoban> royal_screwup21: The function 'pure' does exactly the same thing, by the way. I find that one less annoyingly named personally.
22:26:31 <simon> royal_screwup21, there is plenty of stuff to learn about Haskell before 'return'. :) are you reading LYAH?
22:27:00 <royal_screwup21> yup
22:27:49 <royal_screwup21> say I do something like this:
22:28:02 <royal_screwup21> Just 0 >>= (\ x -> if (x == 0) then Just 0 else Just 1)
22:28:24 <simon> > Just 0 >>= (\ x -> if (x == 0) then Just 0 else Just 1)
22:28:27 <lambdabot>  Just 0
22:28:52 <simon> yes?
22:29:05 <royal_screwup21> so...this is really extracting the 0 from Just 0 and passing to the function on right?
22:29:32 <royal_screwup21> Just 1 >>= (\ x -> if (x == 0) then Just 0 else Just 1)
22:29:35 <royal_screwup21> > Just 1 >>= (\ x -> if (x == 0) then Just 0 else Just 1)
22:29:38 <lambdabot>  Just 1
22:30:03 <royal_screwup21> > Just 1 >>= (\ x -> if (x == 0) then 0 else 1)
22:30:06 <lambdabot>  error:
22:30:06 <lambdabot>      • No instance for (Num (Maybe ())) arising from a use of ‘e_11001’
22:30:06 <lambdabot>      • In the expression: e_11001
22:30:13 <royal_screwup21> :t >>=
22:30:15 <lambdabot> error: parse error on input ‘>>=’
22:30:22 <simon> :t (>>=)
22:30:24 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:30:31 <royal_screwup21> ah I see
22:30:36 <simon> (haskell infix operators require that you put parentheses around them to make them nonfix)
22:30:37 <royal_screwup21> so it has to return a MOnad
22:30:42 <kadoban> Yeah, the result has to be in the same Monad
22:31:28 <royal_screwup21> > Just 1 >>= (\ x -> if (x == 1) then Just 1 else Nothing)
22:31:32 <lambdabot>  Just 1
22:31:37 <koz_> Is a Data.Vector.Storable.Vector a not Storable itself?
22:31:43 <royal_screwup21> > Just 0 >>= (\ x -> if (x == 1) then Just 1 else Nothing)
22:31:46 <lambdabot>  Nothing
22:33:23 <simon> > Just 2 >>= \x -> return (x + 2)
22:33:27 <lambdabot>  Just 4
22:33:36 <royal_screwup21> interesting
22:33:54 <royal_screwup21> return (x+2) is essentially Just x+2
22:34:03 <simon> return is Just here, yes
22:34:18 <kadoban> royal_screwup21: For the Maybe Monad, yep.
22:34:27 <kadoban> Woop, I was scrolled up, ignore that.
22:34:59 <simon> >>= makes it so that it only applies \x -> ... if there's a value to put into x.
22:35:08 <simon> > Nothing 2 >>= \x -> return (x + 2)
22:35:13 <lambdabot>  error:
22:35:13 <lambdabot>      • Couldn't match expected type ‘Integer -> m b’
22:35:13 <lambdabot>                    with actual type ‘Maybe a0’
22:35:18 <simon> er.
22:35:21 <simon> > Nothing >>= \x -> return (x + 2)
22:35:24 <lambdabot>  Nothing
22:35:26 <simon> :P
22:35:41 <royal_screwup21> huh
22:35:49 <royal_screwup21> hmm
22:35:51 <kadoban> royal_screwup21: Make sure you play with other Monads as well. It's easy to generalize incorrectly from one
22:35:55 <simon> that's the whole point of the trick.
22:35:58 <jchia> Is there a simpler way to copy from an Storable Vector of Double to an mutable ST Unboxed Vector of Double other than writing an ST to manually do the element-wise copy of values from the Storable Vector to the mutable Unboxed Vector?
22:36:37 <simon> kadoban, I found it hard to generalize from Maybe.
22:37:01 <royal_screwup21> really? :(
22:37:53 <royal_screwup21> I mean the the bind thing seems deceptively straightforward: you take an arg from a moand, then pass said arg to another function that returns a monad
22:38:11 <jchia> I want to convert from one vector type to another. Maybe fromList . toList?
22:38:34 <kadoban> > [3,7,9] >>= (\x -> [x, x+1])
22:38:38 <lambdabot>  [3,4,7,8,9,10]
22:38:44 <simon> royal_screwup21, >>= is a bit weird if you ask me. it's like a composition operator, but it's asymmetric.
22:39:08 <royal_screwup21> off to figuring out what makes a monad a monad...
22:40:00 <simon> royal_screwup21, don't get hung up on the word monad. it's better to explore what functions can do. you could end up inventing them anyway. they're easier to understand then. ;)
22:40:10 <royal_screwup21> alrighty :)
22:40:45 <royal_screwup21> I mean [] is a moand, isn't it? kadoban's example seems to indicate that
22:40:59 <royal_screwup21> monad*
22:41:27 <simon> royal_screwup21, that sentence only makes sense if you understand the words in it. [] is also a monoid, but we're not really any wiser.
22:41:40 <royal_screwup21> [3,7,9] >>= (\x -> x+1)
22:41:45 <royal_screwup21> > [3,7,9] >>= (\x -> x+1)
22:41:49 <lambdabot>  error:
22:41:49 <lambdabot>      • No instance for (Num [()]) arising from a use of ‘e_13791’
22:41:49 <lambdabot>      • In the expression: e_13791
22:41:55 <simon> remember to return :)
22:41:59 <kadoban> royal_screwup21: If it helps, I suggest you mess with at least the following Monads:  Maybe, Either e, ((->) r), IO, [] and one of the parsers is nice, like megaparsec.
22:42:06 <royal_screwup21> > [3,7,9] >>= (\x -> return (x+1))
22:42:09 <lambdabot>  [4,8,10]
22:42:27 <kadoban> But not like it's the most important thing to do right away either, too much emphasis is put on Monad for beginners in a lot of texts.
22:42:29 <koz_> What's the general approach to implementing Storable for things? Is there an existing definition of Storable for vectors of Storable things?
22:43:21 <simon> royal_screwup21, did you read the LYAH chapter on functors and monoids?
22:43:59 <royal_screwup21> simon: yeah I read up on functors, not so much on the monoids
22:44:20 <royal_screwup21> are monds just beefed up monoids?
22:44:27 <royal_screwup21> monads*
22:45:56 <royal_screwup21> > [3,7,9] >>= (\x -> return (x+1))
22:45:59 <lambdabot>  [4,8,10]
22:46:11 <kadoban> royal_screwup21: Not really, they're pretty separate. Monoid is a different but also not very complicated concept
22:46:20 <royal_screwup21> why is it the way it is, as opposed to [[4],[8],[10]]?
22:46:22 <simon> royal_screwup21, they're related in theory.
22:46:29 <kadoban> It's a generalization of things you can squish together that have an "identity" element
22:46:35 <simon> royal_screwup21, good question!!!
22:46:46 <simon> royal_screwup21, because >>= for lists is concatMap, not map. :)
22:47:11 <simon> > concatMap (\x -> [x+1]) [3,7,9]
22:47:14 <kadoban> royal_screwup21: Look at the types again, could it be [[4], [8], [10]] and typecheck correctly?
22:47:15 <lambdabot>  [4,8,10]
22:47:20 <simon> > map (\x -> [x+1]) [3,7,9]
22:47:23 <lambdabot>  [[4],[8],[10]]
22:47:42 <royal_screwup21> ah right the types
22:48:09 <simon> royal_screwup21, you can imagine that it kind of needs to be concatMap rather than map because otherwise, when you chain them together, the result type would be lists of lists of lists of ...
22:48:18 <royal_screwup21> hmm
22:48:19 <simon> :t concatMap
22:48:21 <simon> :t (>>=)
22:48:22 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
22:48:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:48:55 <simon> :t flip concatMap
22:48:57 <lambdabot> Foldable t => t a -> (a -> [b]) -> [b]
22:50:03 <simon> > [1,2,3] >>= (\x -> [x*1, x*2, x*3])
22:50:06 <lambdabot>  [1,2,3,2,4,6,3,6,9]
22:50:58 <royal_screwup21> hmm
22:51:44 <simon> > [1,2,3] >>= (\x -> [x*1, x*2, x*3]) >>= (\y -> [-y])
22:51:48 <lambdabot>  [-1,-2,-3,-2,-4,-6,-3,-6,-9]
22:51:54 <royal_screwup21> pure [1,2]
22:52:02 <royal_screwup21> > pure [1,2]
22:52:05 <lambdabot>  error:
22:52:05 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M810304247968...
22:52:05 <lambdabot>        prevents the constraint ‘(Show (f0 [Integer]))’ from being solved.
22:52:22 <royal_screwup21> huh
22:52:22 <simon> pure [1,2] of what type class?
22:52:35 <simon> pure is overloaded. it means any one of a hundred things.
22:52:40 <royal_screwup21> return [1,2]
22:52:43 <royal_screwup21> > return [1,2]
22:52:46 <simon> just like return could be Just, Right, (\x -> [x]), etc.
22:52:46 <lambdabot>  error:
22:52:47 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M609755288582...
22:52:47 <lambdabot>        prevents the constraint ‘(Show (m0 [Integer]))’ from being solved.
22:52:47 <kadoban> royal_screwup21: It doesn't know what instance you want, and none of the defaults made sense. If you give it a type, it'll work.
22:52:54 <royal_screwup21> ahhh yes
22:53:03 <kadoban> > pure [1,2] :: Maybe [Int]
22:53:03 <osa1> anyone know a legal & free way of getting the paper "
22:53:06 <lambdabot>  Just [1,2]
22:53:07 <simon> if you don't say what type it is, and GHC(i) can'
22:53:15 <simon> t infer the type, it'll say it is ambiguous.
22:53:21 <osa1> Causality of optimized Haskell: what is burning our cycles?" e.g. maybe from the author's site
22:53:24 <osa1> (sorry for the line break)
22:54:02 <royal_screwup21> pure [1,2] :: [Int]
22:54:10 <royal_screwup21> > pure [1,2] :: [Int]
22:54:13 <lambdabot>  error:
22:54:13 <lambdabot>      • Couldn't match type ‘[Integer]’ with ‘Int’
22:54:13 <lambdabot>        Expected type: [Int]
22:54:32 <simon> > pure 2 :: [Int]
22:54:36 <lambdabot>  [2]
22:54:41 <simon> > pure [2] :: [[Int]]
22:54:44 <lambdabot>  [[2]]
22:54:53 <simon> :t pure
22:54:55 <lambdabot> Applicative f => a -> f a
22:55:03 <royal_screwup21> :t return
22:55:05 <lambdabot> Monad m => a -> m a
22:55:20 <simon> so it takes the 2 (or the [2]) and sticks it inside some applicative functor.
22:56:08 <simon> > pure [2] :: Maybe [Int]
22:56:09 <kadoban> osa1: http://eprints.whiterose.ac.uk/77401/19/hask025-wortmann_with_coversheet.pdf looks like it
22:56:12 <lambdabot>  Just [2]
22:56:19 <kadoban> (search in google scholar brought up the pdf)
22:58:16 <osa1> kadoban: thanks
22:58:51 <simon> > "hello" >>= \c -> return (toUpper c)
22:58:54 <lambdabot>  "HELLO"
23:00:03 <simon> > concat (map (\c -> [toUpper c]) ['h','e','l','l','o'])
23:00:06 <lambdabot>  "HELLO"
23:00:18 <royal_screwup21> I read that some people consider the >>= to be the equivalent of ;
23:01:20 <royal_screwup21> is there any truth to that?
23:01:25 <simon> sort of
23:01:39 <kadoban> It's kind of a goofy metaphor, I've heard it called a "programmable semicolon" before. Which kind of makes sense if you look at how 'do' notation works and desugars. But I don't think it's actually helpful for understanding, myself.
23:02:13 <royal_screwup21> welp
23:03:07 <pyrtsa> Heh, maybe if that helps one distinguish between =<< and >>=.
23:04:04 <royal_screwup21> doing stuff with >>= seems a lot like list comprehension...
23:04:11 <simon> it is.
23:04:51 <Rembane> Have you told royal_screwup21 that lists have a monad instance? :)
23:04:52 <simon> > [ toUpper c | c <- "hello" ]
23:04:53 <kadoban> List comprehensions can be mapped really directly to the [] Monad, yeah.
23:04:55 <lambdabot>  "HELLO"
23:05:12 <Rembane> > "hello" >>= toUpper
23:05:16 <lambdabot>  error:
23:05:16 <lambdabot>      • Couldn't match type ‘Char’ with ‘[b]’
23:05:16 <lambdabot>        Expected type: Char -> [b]
23:05:18 <Rembane> :(
23:05:23 <simon> > "hello" >>= return . toUpper
23:05:27 <lambdabot>  "HELLO"
23:05:56 <Rembane> :D
23:05:58 <simon> ( or: \c -> return (toUpper c) )
23:07:29 * simon disappears
23:12:13 <ski> royal_screwup21 : "you take an arg from a moand" -- no, monads are not values. the left argument of `>>=' is not a monad, it's a monadic action
23:13:28 <Rembane> ski: So not a monadic value?
23:13:37 <ski> that also works
23:13:59 <Rembane> Ah.
23:16:17 <ski> in particular, one can say e.g. `IO'-action, `IO'-computation ..
23:16:30 <Rembane> Do we ever talk about "Applicative values" or "Functor values"? Or "Applicative actions" or "Functor actions"?
23:16:54 <ski> i sometimes say "action" also for idiomatic values
23:17:12 <ski> for functor ones, i don't
23:17:43 <Rembane> I'm usually getting entangled in terminology, so this is really interesting.
23:17:45 <ski> (there, i might say "collection" or "container" as a generic term)
23:17:50 <Rembane> Indeed
23:18:18 <Rembane> There is an applicative instance for IO for instance and ... does Applicative actually evaluate the actions? Or "run" them?
23:18:50 <ski> i suppose "action" and also "computation" presupposes a notion of sequencing (at least in the form of "juxtaposition", not implying that the ordering need to matter)
23:19:14 <royal_screwup21> is this monadic instance of Maybe correct? I'm specifically confused about the underline - I think it should be Just f x
23:19:16 <royal_screwup21> https://prnt.sc/i2j0pj
23:19:29 <royal_screwup21> s/underline/underlined part
23:19:58 <ski> no, there should be no `Just' there
23:20:02 <ski> that's the point
23:20:27 <ski> the continuation `f' should be able to decide for itself whether it wants to fail (`Nothing'), or succeed (`Just')
23:20:46 <ski> with your suggestion, it'd always succeed in this case, and so you'd get `fmap', not `(>>=)'
23:21:03 <royal_screwup21> ah okay
23:21:29 <royal_screwup21> so the f x has to return either Just <something> or Nothing -- it can't return anything else like say an Int
23:21:36 <ski> right
23:21:43 <ski> the types always have to align properly
23:22:39 * ski . o O ( Iä iä ! )
23:22:48 <Rembane> royal_screwup21: A pattern that emerges is that you unwrap the type, do something with the value and then wrap it again.
23:25:26 <ski> royal_screwup21 : consider a `safeNaturalLogarithm :: Double -> Maybe Double', that gives `Nothing' when the input is not positive. if we write `safeNaturalLogarithm x >>= \y -> safeNaturalLogarithm (x - y)', then you can see that we want to allow either "side" to fail (in which case the whole computation fails)
23:27:05 <ski> for `>>=', the right "side" (argument) is a function that'll get passed the result (on success, if any) of the left side, and then that "right side" will compute for itself whether it decides to succeed or fail, given that left result
23:29:20 <ski> .. in the case of `Functor', there's only one side that can fail. in the case of `Applicative', there's two sides, but they're more symmetric than in the `Monad' case. no information gets passed from one side to the other, we just have to check whether both sides succeed, or otherwise (i.e. whether any of them fail)
23:30:19 <ski> (all this is talking about the case of `Maybe', where success/failure makes sense. for other type functions, that could possibly be instances of some of `Functor',`Applicative',`Monad', that terminology might not make sense)
23:30:57 <ski> Rembane : i'm not sure what you mean by "does Applicative actually evaluate the actions? Or \"run\" them?"
23:31:39 <ski> `IO' actions are being run/executed, by being part of `main' (or, by being placed in the interactor)
23:32:38 <ski> i'd say that the `Applicative' instance for `IO' no more executes the actions, than the `Monad' instance does (on its own, in both cases)
23:33:44 <ski> (if you actually meant "evaluate", rather than "execute", then that's a different matter. most `Applicative' instances would *evaluate* the arguments of `(<*>)')
23:33:51 <Rembane> ski: Ah. Good point.
23:34:32 <ski> if you take e.g. `State s', then i'd say it's `runState' (and `evalState', and `execState') which "executes" a `State s'-action
23:36:07 <ski> however, you could say that when `iab <*> ia' or `ma >>= amb' are *executed*, then `iab' and `ia', respectively `ma' (and then *possibly* `amb') are executed
23:37:22 <ski> it is useful to say that a definition of an action is tail recursive, wrt execution, in this sense, even if it need not be tail recursive in the ordinary sense here
23:38:16 <ski> e.g. `forever act = do act; forever act' may be tail recursive, wrt execution, depending on which monad is being used
23:39:27 <ski> (e.g. for `IO',`State s',`StateT s IO', but not `WriterT w IO')
23:58:34 <diemac10plenty> the battle for a free market continues in 2018!!!
23:58:38 <diemac10plenty> ladies and gents, I give to you the largest music exchange on the planet
23:58:46 <diemac10plenty> a free market with no middleman
23:58:50 <diemac10plenty> I've just returned from the future
23:58:50 <diemac10plenty> 2023
23:58:59 <diemac10plenty> and boy I can tell you this shit is hot
23:59:05 <diemac10plenty> the largest music exchange on the planet and your finding out about it early on
23:59:08 <diemac10plenty> here and now
23:59:18 <diemac10plenty> a great fortune unto you
23:59:26 <diemac10plenty> I give to you
23:59:27 <diemac10plenty> VOISE
23:59:38 <diemac10plenty> the south korea turmoil in regards to autorities shutting down crypto exchanges has caused a huge correction to happen for all cryptocurrencies on the market
23:59:51 <diemac10plenty> the time to buy is now as everything is on sell!
