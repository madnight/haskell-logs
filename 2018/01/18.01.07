00:02:39 <Ke> I think the matter is extremely serious, but I am casually asking
00:03:23 <Ke> I did not actually assume nothing had been done, but that also means that ghc executable memory is readable under many conditions
00:04:45 <osa1> please excuse my ignorance but I was wondering why should we fix every single software instead of fixing the CPU. is that because the problem is not patchable (in micro-code level or something)? I'm genuinely curious, I haven't been following the developments too closely.
00:05:30 <Ke> osa1: there has been some talk of microcode fixes, but that is definitely not applicable to cortex-a75 or any ARM cpu
00:05:44 <Ke> since thay do not have microcode
00:06:37 <Ke> ARM published explicit intrinsics for the C code that you can use for bounds checking and such, I am not even remotely sure that it covers everything
00:07:09 <verement> Ke: the risk depends much on whether there is an opportunity for an attacker to execute code in your program; interpreters for example are more at risk than most other types of programs
00:07:31 <osa1> interesting
00:07:54 <Ke> I would have hoped that someone knew enough compiler magic to just make compiler hide the vulnerable patterns
00:08:05 <mniip> well
00:08:08 <mniip> that was my reply above
00:08:16 <mniip> I don't see it being possible
00:09:00 <Ke> I don't see throwing away all the cpus a short term option either
00:09:07 <mniip> if intel's recommended speculation-free indirect branches are implemented that'd cost many, many % of performance
00:09:14 <Ke> we are probably going to live with this
00:09:27 <mniip> well, frankly, we did live with this
00:09:30 <mniip> but now everyone knows :P
00:10:10 <mniip> less frankly but also true, this vulnerability is not a piece of cake to pull off
00:10:38 <Ke> yes
00:10:38 <Xe> yay, two letter nick buddies
00:11:31 <mniip> I speak from the position of having attempted to implement it for the last 4 days
00:11:43 <mniip> pretty much non-stop I think?
00:11:55 <Ke> mniip: what is your target?
00:12:11 <Ke> as in which language and what are you trying to do
00:12:13 <Ke> just asm?
00:12:23 <mniip> asm with bulk of the code in C
00:12:34 <mniip> at this point I'm trying to RE the BPU so that I can reliably inject branch mispredictions
00:13:08 <mniip> so that I can inject a misprediction at a kernel address such that it would speculatively loads something into L1D with the full privilege set
00:13:20 <mniip> and from L1D I can already yank it - I have a PoC on github
00:14:20 <nshepperd_> I think losing some % of performance is preferable to being unusable for secure purposes
00:14:56 <Ke> I guess the good part is that you can onyl protect the sensitive applications
00:15:16 <mniip> the bad part is that everything everywhere is affected
00:15:41 <Ke> you can even only run them exclusively on the whole cpu without touching existing code afaik
00:15:50 <Ke> kernel has to be fixed though
00:16:18 <Ke> eclusively meaning sufficiently strong barrier in between
00:16:36 <Ke> ARM has some explicit instructions to flush the BPU data etc.
00:16:49 <verement> the kernel can mitigate Meltdown, not so much Spectre
00:17:23 <nshepperd_> If you use the llvm backend for ghc, there is the llvm patch going in that will have a flag to replace all indirect branches
00:17:25 <Ke> on big.LITTLE you can run sensitive code on LITTLE cores also AFAIK
00:17:49 <nshepperd_> But it does nothing about normal speculation
00:18:47 <Ke> but I guess then you need a properly located gadget in the code, not just anywhere in the code would suffice, right?
00:19:12 <mniip> technically...
00:20:03 <mniip> you need about two gadgets
00:20:11 <mniip> which I'm sure are abundant in a large codebase
00:20:24 <mniip> (though automating finding of such gadgets might be a problem)
00:22:14 <Ke> automatic finding would perhaps imply automatic fixing, unless you have some complicated heuristics
00:23:05 <nshepperd_> Combine the retpoline with a memory fence at every branch target, and maybe we'd be fine
00:24:12 <nshepperd_> Memory fence instructions are absurdly expensive of course but such is life
00:24:23 <Ke> =o)
00:24:30 <mniip> about 400 clks innit?
00:25:17 <mniip> I mean it's gotta bea pipeline flush followed by waiting on all current load/store units
00:26:11 <geekosaur> Ke, it is not a qiuestion of how seriously you take it. It's a question of whether you even know what you are talking about
00:26:24 <geekosaur> there are incomplete software mitigations
00:26:30 <geekosaur> mitigation = not a fix
00:26:41 <geekosaur> incomplete = not reliable
00:27:13 <Ke> probably incomplete
00:27:15 <nshepperd_> The example in the spectre paper looked like a standard bounds check on a boxed array, such as there are all over a normal haskell program
00:27:19 <geekosaur> the ONLY FIX is redesign the CPU. the mitigations, meanwhile, mean your computer gets to run like a decade ago or worse
00:28:12 <geekosaur> you may of course now go back to demanding that everyone "fix" what cannot be fixed in software period.
00:28:31 <Ke> =oP
00:55:51 * hackage fuzzyset 0.1.0.4 - Fuzzy set for approximate string matching  https://hackage.haskell.org/package/fuzzyset-0.1.0.4 (arbelos)
01:15:16 <akr> hello, is there any way to get cabal to tell me why it thinks it needs to install some package?
01:15:45 <akr> I'm trying to add cryptocipher as a dependency and something's trying to pull in foundation, but idk what
01:19:21 <osa1> akr: probably this https://hackage.haskell.org/package/memory (via securemem via cipher-aes)
01:19:58 <osa1> akr: I either generate a dependency graph (I forgot name of the package that does this) or follow links here https://packdeps.haskellers.com/reverse/foundation
01:21:04 <akr> osa1: oh, thanks, I was clinking through the deps on hackage but must've missed that one :/
01:21:31 <cocreature> if you use new-build you can also get a dependency tree using https://github.com/haskell-hvr/cabal-plan
01:22:47 <akr> looks like you already have to have a working plan for that to work, though
01:23:10 <akr> anyway, does anyone know a package that implements the AES cipher which is less dependency-heavy?
01:23:30 <akr> https://hackage.haskell.org/package/AES maybe
01:41:21 <oak-> How about cryptonite? https://hackage.haskell.org/package/cryptonite
01:41:47 <glguy> That's the heavy one
01:46:11 <akr> yeah unfortunately pulling in foundation is a no-no
01:46:35 <osa1> nvim .tinyr
01:46:40 <osa1> sry
01:46:54 <oak-> it seems it could be possible to build memory package without foundation support
01:49:12 <akr> probably not the best place to ask, but I want to use AES in ECB mode to encrypt a single 16-byte block of data, but I have multiple such data that are unrelated. Can I use a fixed IV?
01:49:35 <akr> oak-: well, I don't really feel like messing with someones package :|
01:51:37 <oak-> It seems to be available as a build flag, although I'm not sure if that disables the dependency from the package
01:53:04 <akr> probably not, as cabal won't even pass the "resolving dependencies" stage
01:53:05 <oak-> but setting the flag for dependency should be rather easy with stack
01:53:32 <lyxia> It should disable the dependency
01:53:42 <akr> unfortunately, this is a legacy project that uses cabal only
01:54:04 <lyxia> you can set flags in cabal too though
01:54:20 <akr> hmm, okay, let me give it a try
01:59:04 <akr> it's only possible to pass flags on the command line? I can't in the .cabal file?
02:04:21 * hackage hedgehog-gen-json 0.1.0 - JSON generators for Hedgehog  https://hackage.haskell.org/package/hedgehog-gen-json-0.1.0 (amrhassan)
02:06:01 <lyxia> akr: https://stackoverflow.com/a/28907638/6863749
02:06:35 <akr> yeah, just found that as well. Not great :/
02:07:24 <lyxia> :/
02:08:32 <akr> I think I'll just use https://hackage.haskell.org/package/AES-0.2.8
02:08:40 <akr> thanks for the help though, learned some new things :)
02:10:01 <lyxia> yw
02:25:11 <faso> hi! does anybody know of a good resource with little problems/tasks for learning Haskell?
02:25:37 <faso> reading a book and following the examples is good and all, but i really wanna start writing small things on my own
02:25:46 <faso> and i'm not that good at coming up with problems to solve
02:26:57 <faso> is the 99 problems page on the haskell wiki any good?
02:31:45 <lyxia> yes it is
02:37:03 <[exa]> is the source code of lambdabot's @pl available as standalone utility? (I only found @unpl)
02:37:26 <lyxia> [exa]: https://hackage.haskell.org/package/pointfree ?
02:37:51 <[exa]> ......
02:37:56 <[exa]> I fail at googling obviously
02:37:58 <[exa]> thanks.
02:47:07 <asheshambasta> λ> (++) <$> getLine <*> getLine
02:47:07 <asheshambasta> Foo
02:47:07 <asheshambasta> Bar
02:47:07 <asheshambasta> "FooBa"
02:47:16 <asheshambasta> "FooBar" sorry
02:47:30 <asheshambasta> Question: What gets a little ambiguous in that code snippet is: what if we had f1 :: IO String and f2 :: IO String; now. f1 gets its IO from the stdin and f2 gets it from elsewhere — say, a temperature sensor connected to the computer. The code snippet above is often called `sequencing` (also the sequence function in the Control.Monad module); but what I’m interested in: those 2 inputs are independent of each other. so in a case w
02:47:30 <asheshambasta> re you’re doing `(++) <$> f1 <*> f2`; does the evaluation of f2 wait till f1 is finished even when its independent?
02:48:02 <[exa]> asheshambasta: because IO monad is coded like that
02:48:23 <[exa]> asheshambasta: not generally applicable to other monads though
02:48:39 <asheshambasta> ok, so in this case, the evaluation of f2 will wait for f1?
02:49:59 <[exa]> asheshambasta: yes. Not exactly full evaluation, but the input actions will be ordered.
02:50:19 <asheshambasta> I see.
02:50:36 <[exa]> asheshambasta: IO works by passing an invisible 'world state' token among functions; and the second getline requires the token which the first getline returned
02:50:39 <cocreature> for IO you are usually interested in the order of execution rather than the order of evaluation
02:50:47 <[exa]> (the first one requires that token from the interpreter)
02:50:54 <asheshambasta> I was wondering if there was any internal optimisation for this going on — given that the compiler was able to figure out the sources for the 2 inputs were independent.
02:51:13 <[exa]> asheshambasta: like, reading from another file?
02:51:34 <asheshambasta> yes: one receiving input from stdin and another reading from a file
02:52:33 <[exa]> yeah well, the problem is that the underlying system usually doesn't work that way (in most OSes the file reads within one process are not independent because both may have side effect on the other)
02:53:06 <[exa]> so you're usually forced to run that in multiple environments or have some nonblocking event IO
02:53:53 <lyxia> IO doesn't do such things on its own. There are libraries for that. async.
02:53:55 <[exa]> in haskell that would translate to forkIO or something like that
02:54:06 <[exa]> or async, eys.
02:54:28 <asheshambasta> ah I see
02:55:07 <asheshambasta> thanks for clarifying [exa] & lyxia
02:55:21 <asheshambasta> & cocreature
02:55:54 <[exa]> parallel single-process reading of files is usually painful btw; most unices don't have "nonblocking" file descriptors. I remember playing with AIO but that was scary
02:56:42 <[exa]> windows has LPOVERLAPPED
02:56:46 <[exa]> way more fun.
02:58:46 <asheshambasta> for me this question popped up while reading LYAH
02:59:13 <asheshambasta> and what if f1 expects input from the keyboard and f2 expects it from a device connected to the system?
03:00:47 <EvanR> a world state token doesnt sound like the right way to intuit IO at all
03:01:02 <EvanR> the free monad-like model makes more sense
03:02:49 <mniip> the world state token made perfect sense to me
03:03:15 <mniip> I mean in the graph reduction model
03:04:53 <geekosaur> it's fine as long as you realize the only state involved is who goes next
03:04:58 <EvanR> the... graph reduction model doesnt execute any effects
03:05:20 <geekosaur> (aka who's got the baton)
03:05:24 <EvanR> effects caused by the side effect of evaluating?
03:05:26 <EvanR> gross
03:59:45 <seanparsons> If I run `cabal get units-2.4.1` (having run an update) it denies the package exists.
04:00:20 <seanparsons> `cabal info` tallies up with that as well, but that version is clearly on Hackage.
04:04:02 <merijn> seanparsons: Works fine here
04:04:12 <merijn> Oh!
04:04:19 <merijn> Hold on, which version of cabal?
04:06:02 <merijn> seanparsons: cabal-install 2.x?
04:10:45 <ProofOfPizza> quit
04:11:46 <seanparsons> This is 2.0, yeah.
04:12:07 <seanparsons> Well 2.0.0.0, with 2.0.0.2 of the Cabal library.
04:12:18 <merijn> seanparsons: Yeah, you're 1) lucky I suddenly remember this email and 2) unlucky because you hit a client side issue :p
04:12:31 <merijn> seanparsons: See this email: https://mail.haskell.org/pipermail/glasgow-haskell-users/2018-January/026679.html
04:12:51 <merijn> i.e. it's not working because "cabal update" isn't working :p
04:15:50 <seanparsons> merijn: Aha, that was it!
04:16:01 <seanparsons> That's a pain in the face.
04:31:21 * hackage fmlist 0.9.2 - FoldMap lists  https://hackage.haskell.org/package/fmlist-0.9.2 (SjoerdVisscher)
04:32:02 <Marisa_> Hi, why does NFData (a -> b) say this instance assume WHNF and NF is the same for function? Arent they the same by definition?
04:33:34 <merijn> Marisa_: No
04:33:43 <merijn> Marisa_: Those are, like, the opposite of the same
04:34:18 <merijn> Marisa_: Or did you mean "the same by definition *for functions*"?
04:34:22 <Marisa_> I mean, I get that they are not the same for list, etc, but what is the definition of NF for function than?
04:34:26 <Marisa_> yes, only for function
04:34:42 <merijn> Marisa_: That depends on how you implement functions? Which is not specified by the report
04:35:14 <Marisa_> Hmm... I thought NF/WHNF has to do with operational semantic
04:35:43 <Marisa_> (reduce the value in eager sense/lazy sense).. But I get you, ty
04:36:14 <merijn> Marisa_: I mean, it'd be perfectly legal to make all functions like "partial applied data constructors", in which case the NF of "foo undefined" would be bottom, but WHNF not
04:36:46 <merijn> Probably pretty stupid to do that, but yeah...
04:37:28 <merijn> Marisa_: It boils down to "since implementation details of functions are completely unspecified, you can really only do something NFData if you make assumptions about implementations
04:39:45 <Marisa_> Hmm...
04:40:22 * hackage concurrent-utilities 0.2.0.1, eventloop 0.8.2.6 (sebaslafleur): https://qbin.io/j4sjjz5i
04:40:37 <Marisa_> I See your point, thx
05:01:04 <Ulrar> Hi, dumb question but how do you do a lookup on Data.HashSet ? I see insert, map, member .. but I don't see anything that looks like a lookup
05:01:33 <sbrg> Ulrar: `member`
05:01:52 <sbrg> what do you mean by lookup?
05:01:54 <Tuplanolla1> What should `lookup` do for a set, Ulrar?
05:02:13 <sbrg> the most you can ask for is whether an element is a member of a set or not
05:02:30 <sbrg> maybe you were looking for HashMap instead?
05:02:31 <Ulrar> Mh okay that's my bad, HashSet is basically like a list, not a map
05:02:37 <Ulrar> I was mislead by stackoverflow
05:02:55 <Ulrar> Yeah, HashMap sounds more like what I need
05:17:04 <orion> Often I see strictness annotations in data types, but I'm almost certain the author didn't add them as a result of careful profiling. What heuristic is appropriate for setting certain values to be strict?
05:18:55 <lyxia> strict by default
05:21:17 <orion> ha
05:22:10 <merijn> orion: If a value will 100% certainly will be used, then it doesn't really matter if you evaluate it when storing it in the datatype or when you finally use it, but making it strict can avoid keeping large amounts of memory thunks around
05:25:30 <Junior> What is the preferred way to install Haskell?  I'm thinking either 1) Stack or 2) Platform
05:25:43 <MarcelineVQ> orion: sometimes you'll see strict for the benefit of ghc unpacking the fields as well, though it's probably better practise to be specific about that
05:26:00 <merijn> Junior: It depends on the person and how minimalist you like to be
05:26:24 <merijn> Junior: Personally I prefer installing the bindist of GHC and building Cabal from source, then doing everything else via cabal
05:26:53 <merijn> (unless the machine already has cabal, then you can simply install cabal via cabal)
05:27:21 <Junior> merijn: So you prefer the minimal installers route?
05:27:37 <MarcelineVQ> merijn: leaning towards that myself these days, what is your method for switching out ghc versions for different projects. I believe I recall you saying you've done this
05:29:18 <merijn> MarcelineVQ: I don't switch very often, but literally just change the directory that's first in my path
05:29:30 <MarcelineVQ> hehe alrighty
05:30:00 <merijn> MarcelineVQ: GHC automatically uses a per version package db, so it doesn't collide with itself (assuming all GHC versions you care about have different version numbers) and cabal automatically uses whatever GHC it finds first in your path
05:31:31 <merijn> Junior: I don't even use installers for that. The main reasons are: it's a portable method (it works on everything but windows, and I don't do windows dev), 2) it's easy to install a bunch of different versions quickly and 3) also works in environments where you don't have root (I often work on university machines where I only have a regular user account)
05:32:05 <merijn> MarcelineVQ: And if you use new-build you don't even have to worry about sandboxing/conflicting packages in the database for different GHC versions
05:34:05 <merijn> Honestly, as much as I like to bitch about cabal-install ruining stuff for me, this tooling is lightyears ahead of many other languages in terms of fundamentals
05:34:18 <Junior> merijn: I see.  If my goal is to get up quick and running with Haskell would installing Platform fit my needs?  What exactly is the difference between the Stack installer compared to Platform?
05:35:21 <MarcelineVQ> stack can probably say it best  https://docs.haskellstack.org/en/stable/GUIDE/#what-makes-stack-special
05:35:32 <merijn> Junior: Stack is rather opinionated on how you "should" do package development. It functions as an overlay for GHC/cabal tooling only ever exposing "blessed" sets of packages to the user
05:35:48 <MarcelineVQ> say what it is I​ mean
05:36:19 <merijn> Junior: The Platform ships a bunch of default packages, which can help on, say, windows where some packages might be tricky to compile. I believe it currently ships with cabal-install AND stack, so in that sense the platform isn't very opinionated
05:36:47 <merijn> Junior: Personally I prefer using GHC and cabal-install directly and not being forced to do things "stack's way"
05:38:14 <Junior> merijn: How about dealing with library/version conflicts.  Know if that would be an issue with Platform?
05:39:40 <MarcelineVQ> merijn: ohmy, there's progress on new-install
05:40:01 <merijn> MarcelineVQ: Yup :)
05:41:45 <merijn> Junior: Platform dumps a whole bunch of stuff in the package db which can cause conflicts yes, the old solution was to sandbox every project, but that's of course a hassle and leads to a lot of recompilation. I've been using new-build for a while which is the future replacement for "cabal build", the new commands use a more Nix like approach where you can safely have many different versions of the same
05:41:51 <merijn> package installed locally, so you should never have conflicts anymore
05:42:32 <merijn> Junior: Basically, new-build is like all package are automatically sandboxed and can actually reuse dependencies from other packages safely. The downside is that new-build still has some rough edges, since it in active development
05:42:53 <merijn> Such as, as MarcelineVQ mentioned, there not even currently being a "new-install"
05:43:06 <merijn> MarcelineVQ: I've been told it's supposedly usable already, but not yet merged into master
05:45:07 <MarcelineVQ> looks merged but there's more to do now that it is, must have happened just after we talked about it last because it's been in this state for a little while now
05:47:01 <Junior> merijn: Just clarify me if I am understanding correctly.  The main drawback with Platform is the dependency/conflicts of libraries issue.  Also, wouldn't be ideal for a minimalist approach..
05:47:48 <merijn> Junior: If you say what you personally want, it's probably easier to say what'd work for you :)
05:48:43 <merijn> Like, if you care about developing on windows, stack might be the most reliable way to go
05:51:46 <Junior> merijn:  I'm on a windows machine.  Want a simple install, and have to deal with less issue/conflicts as much as possible with versions/libraries.  Any suggesstion?  I think I'm fine to start with an opinionated structure/approach.  Stack would fit these needs best?
05:52:31 <merijn> Junior: Probably, I used stack to get my girlfriend set up on Windows (also because Haskell Book uses that, so I didn't wanna do something wildly different)
05:53:38 <Tuplanolla1> What's the command to set up a girlfriend?
05:53:50 <yoho> stack install girlfriend
05:54:02 <Junior> merijn:  Sounds good.  It would work just as well in other operating systems?
05:55:05 <merijn> Junior: "Probably"? :) As I said, I don't use stack, so my knowledge of it is limited
05:55:42 <Junior> merijn: Thanks
07:39:52 <mzabani> hi everyone! I'm having some trouble with indentation rules.. I wonder if someone can explain me what I'm missing here: http://lpaste.net/361440
07:42:00 <MarcelineVQ> where can't be used there https://stackoverflow.com/questions/4362328/haskell-where-vs-let
07:42:19 <merijn> mzabani: the 'where' on line 9 is parsed as part of (and end of) 'spec'
07:42:38 <merijn> mzabani: So the second 'it' is parsed as being outside 'spec' which is a syntax error
07:43:46 <orion> Has anyone gotten the ghc-options stack.yaml config option to work? I am having great difficulty specifying "$everything": "-split-sections". The option is being ignored.
07:44:02 <mzabani> hmm.. but why is it so? it is indented after the first "it"
07:44:24 <orion> I know it's being ignored because I specified "$everything": "-non-existent-ghc-option" and everything build correctly.
07:44:28 <orion> built*
07:44:29 <merijn> mzabani: where is not possible in the middle of a do block, so it MUST be the end of 'spec'
07:45:03 <mzabani> oh wow.. no where inside do. I didn't know that
07:48:45 <mzabani> merijn: changed it to let and things worked.. thanks a lot
07:49:09 <mzabani> MarcelineVQ: thank you for the link as well, I'll surely take a look
07:50:32 <merijn> mzabani: You could keep it in where, if you just move the where behind the second "it" as part of spec's where block :)
07:51:55 <MarcelineVQ> orion: specifying a non-existent flag,   ghc-options:\n  "$everything": "-split-secfdgdfgftions"   fails as expected here, is stack actually building anything in your attempts? changing flags in stack.yaml isn't enough to prompt stack to rebuild
07:53:50 <orion> MarcelineVQ: I blew away .stack-work and ~/.stack
07:54:04 <orion> It built all ~100 dependencies of my project successfully.
07:54:53 <boojinks> Bit of a long shot but has anyone here built ghc-8.2.2 on OpenBSD 6.2?
07:55:36 <MarcelineVQ> orion: lpaste your stack.yaml
07:59:35 <orion> MarcelineVQ: http://lpaste.net/8547536148027670528
08:03:47 <MarcelineVQ> oh I see you've placed the setting in your config.yaml and not your stack.yaml   interesting, I wonder how that is affects things, did you try it in your stack.yaml to see if the behavior changes?
08:04:24 <MarcelineVQ> as an aside just  stack clean  should be enough to prompt a rebuild, while nuking .stack-work/ is equivalent to stack clean --full
08:05:22 <MarcelineVQ> you may need  apply-ghc-options: everything  when using is in config.yaml
08:06:00 <orion> MarcelineVQ: That worked, however I am confused as to why.
08:06:01 <MarcelineVQ> Probably not but it's worth a try
08:06:10 <MarcelineVQ> the stack.yaml thing worked? I'm not sure why either
08:06:29 <orion> https://docs.haskellstack.org/en/latest/yaml_configuration/#ghc-options <-- "Non-project-specific config"
08:10:39 <orion> I'll file a bug report.
08:12:44 <MarcelineVQ> seems like a good idea
08:13:42 <MarcelineVQ> in the mean time if you're going to change ghc settings in your yaml files pretty often you'll probably want  rebuild-ghc-options: true  in your config.yaml
08:13:48 <MarcelineVQ> *flags
08:14:06 <MarcelineVQ> *change ghc flags
08:16:33 <EvilMachine> What is, in your opinion, the best interface to enable editing multiple elements in a tree via a filtered and sorted view of it? It makes me think of functors and of file system handles, but also of zipper state monads, which all seem to be sub-optimal.
08:17:08 <EvilMachine> (And: Imply the simplest solution possible. No nothing fancy.)
08:17:10 <[exa]> Hm guys, anyone knowledgeable about how kind inference works in GHC?
08:18:17 <[exa]> EvilMachine: depends on the parts of the process that you want to abstract as variables (do you want the filtered-editing functions materialized?)
08:18:41 <EvilMachine> I could give each tree node a unique id, and have handles that store those (like pointers), but that means traversing the tree for each edit. I could use zippers, but that means each edit is a different zipper state that needs to be merged.
08:19:02 <EvilMachine> [exa]: Materialized? …
08:20:38 <[exa]> EvilMachine: Maybe I totally misunderstood you. Implying that design of such thing is best carried out by first envisioning the interface.
08:20:39 <EvilMachine> [exa]: The filter and sorting will be what the user of the program will input. (Think of basically a file system tree where each “directory” is also a row and the whole thing is also a table. the user should be able to do very simple things in the spirit of SQL SELECT.)
08:21:37 <EvilMachine> [exa]: I’m open to other suggestions. :) I prefer picking the best mindset and solution for the job, not the one I feel closest to. :)
08:22:07 <[exa]> oh so, something that an act as a partially interpreted SQL-like query
08:22:32 <[exa]> to be used as a carrier type for the interpreter I guess
08:24:59 <EvilMachine> [exa]: not as complex though. basically just a (view :: Filter -> Sorting -> TreeTable DataRecord -> (???)) function, and an (edit :: (DataRecord -> DataRecord) -> (???) -> (???)) … What would the (???) be ideally?
08:25:36 <EvilMachine> [exa]: (Oh, I forgot that TreeTable DataRecord should of course be the one edited, and end up as the result at the end.)
08:25:49 <[exa]> well -- SQL-like queries are best constructed from smaller SQL queries, ideally abstracting out the mechanism with pointers to rows etc before the final moment, if you bring in the data too early, you're going to overcomplicate it
08:26:34 <EvilMachine> [exa]: No interpreter. That’d be far to fat. I’ll not use any free text language or anything. Basically a simple text UI will do for the first test version. Later probably a GUI, but we’ll see.
08:26:49 <EvilMachine> [exa]: Very good point.
08:27:32 <EvilMachine> [exa]: Then the only issue that makes me feel uneasy with it, is the requirement to traverse much of the tree for each edit. (Basically like the implementation inside Map?)
08:27:58 <[exa]> That way you can view "table" and "view" as basically the same thing. In SQL databases they have only like 3 methods, "plain traverse", "traverse in order X" and "traverse elements that satisfy Y" which then chooses index usage
08:28:15 <[exa]> yeah well and "prototype before optimizing"
08:28:22 <EvilMachine> [exa]: (My trees might become rather large)
08:28:42 <[exa]> just make yourself a bit of space of extension of the view type in advance
08:28:43 <EvilMachine> [exa]: :) Indeed
08:28:54 <[exa]> as in "not hardcoding it as a list"
08:29:56 <EvilMachine> [exa]: Soo … SQL databases actually traverse the whole thing (or at least as much as is necessary to reach the rows) each time? NoSQL Graph ones too?
08:30:24 <merijn> EvilMachine: Any reason why you don't just use an SQL database instead of building something yourself?
08:30:43 <[exa]> That should be able to materialize stuff like (sortOnRow :: RowId -> View -> View), (joinOnRow :: RowId -> View -> View -> View), (loadData :: View), (update :: something -> View->View)
08:30:50 <EvilMachine> [exa]: Don’t worry. Actually, the list is just the current test implementation. The structure and interface are 100% independent of the content type, and use the content type’s Matching class implementation.
08:31:34 <[exa]> EvilMachine: about SQLs, they have indexes and query optimizers that make the best use of indexes, so traversing the whole database is rare (unless the programmer does something dumb)
08:31:53 <merijn> [exa]: Pffft, it's rare even if the programmer does something dumb
08:32:01 <merijn> Unless you're MySQL, then you're just fucked :p
08:32:13 <[exa]> merijn: i was in middle of writing MySQL
08:32:18 <[exa]> yap./
08:32:37 <[exa]> :]
08:33:42 <[exa]> well and about NoSQL databases, there is a thing called OpenLink Virtuoso
08:34:41 <EvilMachine> merijn: Yes, valid question. :) The reason is, that 1. I don’t want to bring in the huge baggage of an entire SQL database for something so simple, and this is only a prototype to get things usable until the real things comes, which will rather diverge away from SQL, and more towards NoSQL graph databases, again minus most of the baggage. (As the rows are supposed to reference other rows.)
08:34:46 <merijn> I have some absolutely retarded queries in SQLite, which get turned into some truly amazing executions through, what I can only assume is, sheer voodoo
08:35:09 <merijn> EvilMachine: Most NoSQL graph databases have piss poor performance
08:35:10 <EvilMachine> [exa]: Yep, I looked into them. :) Huge packages for huge companies, mostly. Otherwise a fine choice.
08:35:43 <merijn> EvilMachine: Why is an SQL huge baggage? Just drop in SQLite and be done?
08:36:07 <EvilMachine> merijn: If I have to use SQL, I use PostgreSQL. I ditched MySQL with my former nighmare job as a PHP+JavaScript+MySQL “programmer”, long ago. :)
08:36:30 <merijn> EvilMachine: What's wrong with SQLite?
08:36:33 <EvilMachine> [exa]: Your MySQL would probably turned out better. :)
08:36:35 <[exa]> EvilMachine: do your best to avoid Virtuoso :D last time we used it we found out that the equivalent of 'select count(*)' returns the result randomly with mean error of ~20 items
08:37:09 <EvilMachine> merijn: Yes, SQLite too. But not on servers where there is a full (Postgre)SQL server anyway.
08:37:43 <merijn> Honestly, most graph tooling performs piss poor, not just NoSQL graph databases
08:37:46 <EvilMachine> merijn: Yes, the performance thing with traversing graphs is exactly why I came here to ask. (Although it was hard to tell from the way I did. :)
08:38:06 <merijn> What kinda traversals?
08:39:31 <EvilMachine> [exa]: Lol. I checked out ArangoDB. Sadly, it wasn’t fully free either. (With the Damocles sword of a commercial company hanging above it.)
08:39:50 <EvilMachine> merijn: Indeed. Reddit’s search being a great example too. :)
08:39:59 <[exa]> EvilMachine: graph traversal-dbs is hard, but doable easily in haskell if you fit in the memory
08:41:31 <[exa]> storing graphs to external media is something you desperately want to avoid
08:42:38 <EvilMachine> merijn: Well, the kind I mentioned above: “Have a Tree/Graph, make me a view of it using a filter and a sorting rule, (display that to the user, let him make edits) and apply multiple edits to the items in the view, so they might end up in the Tree/Graph.” … [exa] suggested keeping handles. Which would mean traversing the tree for each edit. And a zipper can’t be in multiple positions at once. And multiple zippers
08:42:38 <EvilMachine> need to be merged in a way that I don’t know.
08:42:54 <merijn> EvilMachine: What size graph are we talking?
08:43:04 <rostero> i'm learning haskell and saw a stackoverflow post about producing an infinite list of [0, 1, -1, 2, -2, ...].   is there anything wrong with this solution:  `solution = 0 : ([1..] >>= (\x -> [x, -x]))`
08:43:04 <EvilMachine> [exa]: Lol, storing the graph is basically the most important point in my case. :))
08:44:12 <EvilMachine> merijn: Anything from the size of a medium text file, to basically the entire project planning for a person “until the end of time”. :)
08:44:26 <merijn> That...tells me nothing :p
08:44:41 <merijn> Are we talking 10s of nodes? 100s of nodes? 1000s? millions?
08:45:55 <MarcelineVQ> > take 11 $ 0 : ([1..] >>= (\x -> [x, -x])) -- rostero: looks good to me
08:46:03 <lambdabot>  [0,1,-1,2,-2,3,-3,4,-4,5,-5]
08:46:11 <EvilMachine> merijn: Hmm, I don’t know … let’s say 100 projects of 10 to 10,000 steps? (So noting more than small-to-medium-sized projects?)
08:46:34 <rostero> MarcelineVQ: thanks
08:47:33 <[exa]> EvilMachine: if the graph has a hotspot (and other nodes are cold), you can store the whole thing in adjacency table and you won't notice any performance problems
08:47:44 <EvilMachine> merijn: Sorry, I’m not always saying everything in a direct way, because my plans are usually far out there compared to the current needs. I’m working on it. (But the problem is: it’m far out theer in that case too. :)
08:48:37 <[exa]> EvilMachine: which is your case I guess, people can't do graph-global actions easily (if the model is reasonable)
08:48:51 <EvilMachine> [exa]: It would definitely have 1–3 hotspots, <10 warm spots, and the rest would mostly be cold data, just above freezing.
08:49:12 <[exa]> EvilMachine: no problem with simple adjacency table then
08:50:02 <glguy> > 0 : do x <- [0..]; [x,-x]
08:50:05 <lambdabot>  [0,0,0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,...
08:50:41 <EvilMachine> [exa]: well, graph-global filters is an important feature. (Think “give me all ideas and things we ever had related to “design inspirations” for “wooden toys”)
08:51:12 <glguy> Oops, forgot to start with 1, just playing with do
08:52:34 <EvilMachine> [exa]: I’m not a native English speaker. Do you have a link regarding what exactly you mean with an adjacency table?
08:52:35 <[exa]> EvilMachine: if you don't want the search to be locality-based or locality-scored, this can be easily solved by an added layer with some indexing
08:53:54 <EvilMachine> [exa]: Yes, that’s true. Indexes would probably be a good idea. Now I just have to figure out what the in-memory solution would be, in case I don’t want to load the entire thing into memory at once …
08:53:57 <[exa]> EvilMachine: the way of storing the graph where you have a list of nodes and a list of neighboring pairs
08:54:02 <merijn> [exa]: Honestly, if this is for interactive editing, I'd probably dump it into an SQL table and only reify the small relevant part being edited
08:54:09 <merijn> But I'm off for now
08:54:23 <[exa]> merijn: it's going that direction. :]
08:54:43 <EvilMachine> [exa]: Aah, okay. So the list of neighboring pairs is basically the list of edges (connections between the nodes)?
08:54:48 <[exa]> yep
08:54:56 <EvilMachine> Alright, that I know.
08:55:25 <[exa]> also doable by separated adjacency list (better for in-memory ops) as Map Idx (NodeData, [(EdgeData,Idx)])
08:55:34 <[exa]> esp. if your graph is directed
08:55:54 <EvilMachine> [exa]: And the view? Are you still recommending handles containing pointers? (And would they point to a position in the list of nodes, or to a unique id of the node, or would that be the same?)
08:56:38 <[exa]> View in this case can be just a list of indices
08:57:30 <[exa]> (btw s/handles containing pointers/indices)
08:58:03 <EvilMachine> [exa]: It is definitely directed. It will basically be a tree of “to get this, we must make this list of things, for which we must make these lists, etc”, with the addition that ideally, one sub-task done should advance as many parent tasks as possible. Which, in my case, is true for a suprisingly big chunk of the tasks.)
08:58:56 <EvilMachine> [exa]: Ah, so the view would still need the original tree/graph to act on. (Maybe kept inside the structure.)
08:59:16 <EvilMachine> [exa]: Makes sense.
09:00:03 <[exa]> EvilMachine: I'd abstract the data out -- there's no data in view object until you actually put it on some data
09:00:08 <[exa]> EvilMachine: compare with State monad
09:01:19 <EvilMachine> [exa]: Yes, I have to teach myself to keep that in mind. One data store, and the rest as lightweight as possible. Sounds like a good principle.
09:01:28 <EvilMachine> [exa]: Thank you a lot for clearing all this up.  My brain is rather weak today. :) If you happen to be around the corner here in Cologne currently, I’ll bring you a beer or something, if you want. :)
09:01:50 <webstrand> In `getChar :: IO Char`, what is the `IO`? It doesn't look like a type. I just need a name for the language construct, so I can google it
09:02:31 <kadoban> webstrand: It's a type or a type constructor, whichever you want to call it.
09:03:22 <EvilMachine> webstrand: Oh boy… :) … IO is a monad acting on the RealWorld type, which, from Haskells standpoint is the entire universe, and a bit of GHC smoke and mirrors / black magic. ;)
09:03:23 <MarcelineVQ> webstrand:  here's a pretty neat overview http://www.vex.net/~trebla/haskell/IO.xhtml
09:04:27 <webstrand> Is it like C++ templates then? IO<String>? I'm struggling to interpret what a type constructor means in a type declaration
09:04:36 <EvilMachine> webstrand: It’s how one gets around the problem that Haskell is supposed to be 100% deterministic with no “outside” for side-effects to end up in. So the idea is to turn things around, and declare the universe to be a subset of the Haskellverse.
09:05:54 <kadoban> webstrand: Somewhat close to that, yeah.
09:06:12 <EvilMachine> webstrand: Monads are usually what people struggle with, but they’re actually quite easy, if you look at the type, instead of the “simple analogies”. And IO is particularly nasty, because it isn’t a normal Monad type. It has special tricks done to it by the compiler, to do this trickery. Which also means it can’t really be expressed as a Haskell type in its entirety, and RealWorld would have to stay abstract.
09:06:33 <kadoban> webstrand: Are you going through a book? Haskell isn't something I'd personally recommend you learn in a slipshod fashion like looking up random stuff.
09:06:48 <webstrand> I
09:07:01 <kadoban> EvilMachine: Can't tell if these explanations are supposed to help or just make it sound complicated.
09:07:27 <webstrand> I've actually been working through the wiki page All about Monads, which makes sense. The IO monad is like an interpreted language, I think.
09:07:36 <EvilMachine> webstrand: Also, I recommend using Hoogle for Haskell searches. This one lets you filter packages but is sometimes incomplete: https://www.haskell.org/hoogle/ and this one is more complete, but lacks the filter: https://www.stackage.org/lts/hoogle
09:08:07 <EvilMachine> kadoban: Hmm, I didn’t think they sounded complicated … :)
09:08:34 <MarcelineVQ> it's just a lot to give to someone trying to read the type still ^^;
09:09:13 <EvilMachine> webstrand: This will help you a lot: http://book.realworldhaskell.org/read/ (Buy the book if you found it helpful. :)
09:09:13 <webstrand> I think I understand now, data constructors != type constructors, though they are related?
09:10:25 <EvilMachine> webstrand: Well, Haskell has 3 layers. The normal layer, the type layer, and the kind layer. The type layer is like its own small language to define types for the normal layer. And the kind layer is like the type layer _for_ the type layer, and very very simple.
09:11:16 <EvilMachine> webstrand: (Not to overwhelm you, but if one is crazy enough, one can use the type layer as its own programming language, completely executed during compilation. ;))
09:11:46 <EvilMachine> webstrand: Oh wait, you meant type and data.
09:12:13 <EvilMachine> webstrand: type is just for aliases. while data creates really fully new types.
09:13:38 <EvilMachine> webstrand: There is newtype too, which creates true types too, and not just aliases, but those types are merely renamed/wrapped version of other real data types. (Which is useful if you e.g. want to use a Int as a unique ID or handle of some kind, but not allow every random Int to act as a handle that might not even exist.
09:13:53 <EvilMachine> )
09:17:13 <[Leary]> Yes, webstrand. Take a list for example; it has the constructors [] that takes no arguments and the : constructor that takes two. It's type is [a], also written [] a. Here [] is a type constructor taking one concrete type as an argument and returning a new concrete type.
09:17:16 * aaditya hello, just getting started with Haskell. Would be great if I could get some good recommendation on best resources.
09:18:11 <kadoban> aaditya: I like http://haskellbook.com/ quite a bit
09:19:22 <aaditya> thanks a lot Kadoban :)
09:26:21 <glguy> Hutton's Programming in Haskell is worth getting, 2nd Ed specifically
09:26:59 <asheshambasta> hm, I've been trying to combine RWH and LYAH and I think I'm in luck.
09:27:28 <asheshambasta> I'm going especially slowly with Monads/Applicatives/Monoids just to get them right in my head from the get go.
09:27:52 <asheshambasta> kadoban: Haskellbook indeed looks very promising.
09:28:41 <webstrand> EvilMachine: thanks for your help
09:28:51 <EvilMachine> webstrand: :)
09:29:53 <EvilMachine> aaditya: My favorite resource: http://book.realworldhaskell.org/read/
09:30:19 <EvilMachine> aaditya: And of course https://downloads.haskell.org/~ghc/latest/docs/html/
09:30:55 <asheshambasta> EvilMachine: what time would be a good time since starting to learn Haskell to dive into a project?
09:30:58 <EvilMachine> aaditya: plus  ttps://www.haskell.org/hoogle/ and https://www.stackage.org/lts/hoogle
09:31:35 <EvilMachine> asheshambasta: Sorry, I don’t understand the question …
09:32:01 <asheshambasta> I've been working on a home-automation project and have been considering Haskell for the device side of things (RPi) using https://hackage.haskell.org/package/HPi-0.4.0/docs/System-RaspberryPi-GPIO.html
09:32:26 <EvilMachine> asheshambasta: Ah, I run Haskell programs on a similar device myself.
09:32:50 <asheshambasta> So, its been about 3 months since I seriously got into Haskell and have been reading RWH and LYAH — and I was wondering if this is the right time to dive into a real project.
09:32:57 <EvilMachine> asheshambasta: Haskell is really high-level and more towards the academic / math side than the low-level hardware / engineering side.
09:33:22 <glguy> To get GHC working on my RPi3 I had to editing one of the configuration files after installing GHC, so if things don't work out when you install come back here and we can probably help
09:33:31 <EvilMachine> asheshambasta: So only use it if you like that, as otherwise you will try to climb a large mountain for nothing. :)
09:33:42 <asheshambasta> I see.
09:33:59 <asheshambasta> the other option for me is Scala, but I don't want to write things in anything imperative.
09:35:49 <EvilMachine> asheshambasta: Regarding diving into a real project: No need to think in hard cuts like that. Get in gradually. Like a good game. (I know game design very well :) The key part is that you know well, how much you can do, and pick a project size that fits it as closely as possible. Listen to your own judgment, not to what you think you should. This will automatically give you maximum motivation (especially with little surprises,
09:35:52 <EvilMachine> which will make it fun too, not just rewarding).
09:35:56 <consus> Guys, anyt thoughts on haskell-socket library? I'm kinda new to the whole haskell ecosystem stuff, so I want to decide what I should use for my new project
09:36:16 <glguy> consus: You want to do IP networking?
09:36:28 <consus> unix socket and a bit of udp
09:36:40 <glguy> The "network" package is the standard starting point for that
09:36:46 <consus> So the other option is network
09:36:53 <consus> Which is way more commonly used
09:37:05 <consus> So I'm trying to understand why does the socket one exists
09:37:06 <EvilMachine> asheshambasta: There is no “too small” or “too big” for project size. There is only your ideal size. For me, biking is a good example: Only when I allowed myself to start out with only 800m the first time, did I succeed, and now I do 60km.
09:37:18 <asheshambasta> EvilMachine: yeah, so far, Haskell seems like a beautiful language and you start to feel impatient to use it.
09:37:55 <EvilMachine> asheshambasta: Good, good, let the motivation flow through you… ;)
09:38:19 <asheshambasta> allright, letting it flow then :D
09:38:40 <EvilMachine> asheshambasta: (Remember, being underchallenged is just as bad for motivation as being overchallenged.)
09:38:54 <asheshambasta> true that
09:39:05 <asheshambasta> I've also been looking at SPOJ
09:39:23 <asheshambasta> maybe I'll start with some small problems there once I've spent more time reading and learning
09:40:10 <infinisil> I really love how you can pretty much understand a (good) Haskell API just from the types of the functions
09:40:28 <Welkin> infinisil: unless it is littered with custom typeclasses
09:40:29 <Welkin> :D
09:40:52 <consus> And exceptions
09:40:56 <consus> They are not typed
09:41:30 <infinisil> Like the actual exceptions at runtime you would have to catch?
09:41:34 <asheshambasta> Welkin, consus: in that case the constraint of a good API doesn't hold no?
09:41:37 <infinisil> Don't like those and I think nobody should use them
09:41:49 <consus> Ooops
09:42:00 <consus> But when you're dealing with IO you have no other option
09:42:34 <consus> Pretty much everything in System.Posix throws exceptions
09:42:51 <infinisil> solution: only deal with IO very constrained, make most functions IO-less
09:42:57 <infinisil> if possible
09:43:01 <consus> Of course
09:43:07 <consus> But you still have to deal with IO
09:43:13 <consus> If you're doing some IO in your programm
09:43:29 <infinisil> May I highlight the GitHub API: https://hackage.haskell.org/package/github-0.18/docs/GitHub-Endpoints-Repos-Contents.html#v:contentsForR
09:44:18 <infinisil> It contains a variant of every method that instead of doing the request in IO, returns a Request type instead (pure). then you can use https://hackage.haskell.org/package/github-0.18/docs/GitHub-Request.html#v:executeRequest to execute it
09:44:36 <infinisil> props to the designer of that
09:44:48 <Welkin> why is everyone in here so obsessed with a moon of Jupiter?
09:45:06 <yoho> it's the only impure moon
09:45:18 <EvilMachine> Welkin: IO ≠ Io :D
09:45:30 <consus> BTW
09:46:01 <consus> Is there a way to extract io_description without from IOError without importing GHC.IO.Exception?
09:47:19 <EvilMachine> infinisil: I must disagree, because that has exactly be my problem: The types are completely useless in understanding what it actually does. E.g. think of all the things that [a] -> [a] could do.
09:48:26 <EvilMachine> *been
09:49:38 <EvilMachine> <rant>But of course, who cares, since we prefer to use it for research, not actually in the Real World!</rant> /hides /ducks
09:49:49 <consus> :D
09:50:19 <consus> I do work in a company where some mad fella wrote the core service in haskell
09:51:36 <consus> And now we are pretty much stuck with haskell because everyone is too lazy to rewrite it
09:51:51 <Welkin> consus: are you complaining?
09:51:54 <consus> Nah
09:51:59 <consus> I guess it's pretty ok
09:52:00 <MarcelineVQ> "<consus> Is there a way to extract io_description without from IOError without importing GHC.IO.Exception?" Not last I checked
09:52:08 <consus> =/
09:52:14 <Welkin> okay?
09:52:22 <Welkin> I would imagine you would be overjoyed
09:52:22 <consus> Yeah
09:52:36 <Welkin> you don't have to work on a crappy rails codebase
09:52:40 <Welkin> or .net
09:52:43 <consus> Well
09:52:51 <consus> The other option was C
09:53:19 <consus> So no rails in any case
09:57:32 <infinisil> EvilMachine: You mean you prefer dependent typing that specifies that e.g. reverse :: [a] -> [a] can only reverse the array and not shuffle them?
09:58:17 <infinisil> I'd love that, am also doing some Idris which allows this, although I'd have to think a bit about how to write this reverse method
10:09:40 <consus> Btw
10:09:44 <consus> Anyone using hasktags?
10:10:22 <EvilMachine> infinisil: No, I do not meant that.
10:11:03 <consus> I want someone to confirm this import qualified Data.ByteString.Char8 as ByteString
10:11:07 <consus> Whoops
10:11:15 <consus> https://github.com/MarcWeber/hasktags/issues/41
10:11:17 <consus> This
10:11:31 <EvilMachine> infinisil: I dislike that I cannot tell what it does, as the type alone is not enough, but people always act like it is.
10:11:47 <consus> EvilMachine: +1
10:12:01 <consus> What I do dislike in haskell ecosystem is an extensive lack of complete documentation
10:12:06 <EvilMachine> precisely
10:12:40 <EvilMachine> I would love to add it … when I would actually fully understand the thing.
10:12:51 <EvilMachine> (thing = library / package)
10:13:18 <infinisil> EvilMachine: but that's what I meant?
10:13:52 <EvilMachine> infinisil: But what you said is not what I meant. :)
10:14:33 <infinisil> EvilMachine: I mean it to some extent haskell allows to say that e.g. a type [a] -> [a] can't start a nuclear weapon, but it could well just be `const []` or `shuffle`, and you don't know what it is
10:14:50 <infinisil> dependent typing allows you to say exactly what it's supposed to do
10:14:54 <consus> Nah
10:14:56 <EvilMachine> infinisil: I meant/said The type alone is not enough. So I did not mean that the type language should change. Just that the documentation should change.
10:15:19 <consus> He meant that you have to write what the hell your function does
10:15:30 <consus> What argument means what
10:15:31 <consus> And so on
10:15:39 <infinisil> ah, docs
10:15:49 <infinisil> Types are docs though!
10:15:53 <consus> Nope
10:15:57 <consus> Types are just types
10:16:05 <consus> Leave the types to the compiler
10:16:05 <infinisil> good types can document an api
10:16:21 <MarcelineVQ> sometimes a type is just a type, other times it's also a strong hint
10:16:27 <EvilMachine> infinisil: For typing purposes, the type is fine. But if you want the type to describe what it actually *does* between the interface (which the type is), you enter model-based-design territory and try to model the function itself with the type. Which would be pointless, since that’s what the function is for. :)
10:16:29 <cocreature> types are documentation but in a lot of cases they are far from sufficient documentation
10:16:33 <consus> It's a hint
10:16:36 <consus> Nothing more
10:16:58 <EvilMachine> infinisil: That is precisely my point: Types are not full docs. They only document the interface. Not the function.
10:17:18 <infinisil> yeah they are not full docs and i didn't say that, but they sure are part of the docs
10:17:25 <consus> Because otherwise in 5-10 years we'll start to have stupid security bugs because someone got the function wrong
10:17:52 * hackage swagger-petstore 0.0.1.7 - Auto-generated swagger-petstore API Client  https://hackage.haskell.org/package/swagger-petstore-0.0.1.7 (jonschoning)
10:18:08 <infinisil> EvilMachine: That's where formal methods and proofs come in play though, and they do work
10:18:24 <EvilMachine> infinisil: It’s like “Here’s 2 switches, a dial and 3 lights” “And what do they do?” “But can’t you see, it’s 3 switches, a dial and 3 lights … that documents what it does!” … “No, it does not. *switches 2nd switch without turning the dial*” … *Nuke goes off*
10:18:45 <consus> :D
10:18:57 <consus> Formal proofs of what?
10:19:21 <EvilMachine> infinisil: Yes, if you want to precisely know what the functions does, the formal proof stuff is nice. But you know what? For that I can also just look at the function code!
10:19:47 <consus> The problem is: formal proof cannot guarantee the logical workflow
10:19:47 <infinisil> e.g. to have a type that says it takes a list and sorts it, then you implement this with whatever alg you want, and prove that the alg does indeed sort it and conform to the type
10:19:54 <consus> Which is, dunno, kinda important
10:20:12 <infinisil> consus: why not?
10:20:33 <consus> Okay
10:20:40 <consus> Let's say we have the following
10:20:49 <EvilMachine> infinisil: What’s needed is a “well, it’s a nuclear control panel. The first switch is for which side you’re on, the second launches the nuke, and the dial is for your amount of blind hate of people you don’t know and refuse to understand. The lights show you how dead you will be once the retaliation arrives.”
10:21:08 <consus> mkFile :: String -> Maybe Mode -> Maybe Flags -> IO ()
10:21:21 <cocreature> infinisil: and then you’ll have to spend a year proving that your fancy sorting algorithm actually sorts the input :P
10:21:26 <consus> If I do pass Nothing to both Mode and Flags what'll happen?
10:21:40 <infinisil> cocreature: nobody said it's easy :P
10:21:51 <EvilMachine> (s/of people/against people/)
10:22:01 <infinisil> consus: No idea, anything could happen
10:22:07 <consus> Precisely
10:22:22 <consus> That's why it's important to have a goddamn interface description
10:22:51 <consus> This kinda of stuff (like the function name + function type describes it all) works in Linux Kernel at best
10:23:15 <consus> Because ctags + cscope allow you to quickly check what the hell is going on
10:23:30 <[exa]> consus: not even in the kernel (not even remotely)
10:23:37 <consus> Welll
10:23:40 <[exa]> :]
10:23:43 <consus> The kernel do lacks proper documentation
10:23:46 <consus> Seriously
10:23:48 <EvilMachine> infinisil: What does umagummayummawooma :: String -> Bool -> [Either (Float, Float, Float) [Int]] do?
10:23:57 <cocreature> tbh I don’t think you’re disagreeing. consus is saying that types often are not sufficient documentation, infinisil is saying that types document some properties and using more expressive types you can extend the properties that can be documented using types
10:24:07 <consus> Bug I rarely had troubles with understanding what's goind on
10:24:30 <monochrom> I don't even think the two of you are on the same page about what "type" refers to.
10:24:47 <infinisil> cocreature: EvilMachine: But these types are just really way too imprecise
10:24:49 <[exa]> EvilMachine: if I got it correctly, you're trying to make an expression that is usuable both as documentation and as a machine-readable specification for what the function should do?
10:25:25 <infinisil> Okay back to the reverse type
10:25:27 <monochrom> One of you is thinking "Integer -> Integer" (which says absolutely nothing, this space is Turing-complete) and the other of you is thinking "a -> a" (which allows only two cases).
10:25:30 <consus> Anyway, I'm off to writing syslog server in haskell :D
10:25:37 <consus> Wish me luck
10:25:40 <EvilMachine> infinisil: We’re not disagreeing that the Haskell type system is quite nice. Nothing wrong with it, to me. In describing the interface. But that’s it.)
10:25:46 <infinisil> First stage: `reverse : List a -> List a`
10:25:54 <cocreature> infinisil: reverse is a fairly bad example, a proper specification of reverse is about as complicated as the code so you haven’t gained a whole lot
10:26:04 <infinisil> Second stage: `reverse : Vect n a -> Vect n a` (guarantees same length)
10:26:42 <[exa]> consus: good luck (seriously)
10:26:56 <consus> Well, it's a bit of attoparsec I guess
10:27:09 <consus> I only need new rfc5424 support
10:27:10 <ertes> names + type do work, but only with parametricity
10:27:23 <ertes> map :: (a -> b) -> [a] -> [b]  -- pretty clear
10:27:29 <EvilMachine> infinisil: Okay, how about this type: doTheFancy :: String -> SunState -> [Either [Color] [Smell]]
10:27:33 <infinisil> Or, even better example with a sorted list (in idris): https://github.com/davidfstr/idris-insertion-sort/blob/master/InsertionSort.idr#L222-L225
10:27:49 <consus> ertes: It's work okay only with simple pure functions
10:27:52 <ertes> if you don't have parametricity, either add prose, or abstract further
10:27:56 <ertes> consus: no
10:28:04 <cocreature> ertes: map _ _ = [] :)
10:29:11 <consus> ertes: hPutStrLn :: Handle -> String -> IO ()
10:29:16 <ertes> consus: if names and types alone don't explain the value, either you abstract further until parametricity explains it, or you add prose
10:29:17 <EvilMachine> ertes: If the names are truly descriptive. Rule 1 of programming: “Use descriptive names” → Completely ignored in the Haskell community. → f :: a -> b -> [(a,b)]
10:29:28 <ertes> consus: i generally try to go for the former option first
10:29:29 <consus> ertes: What happens on I/O error?
10:29:34 <EvilMachine> ertes: Okay, not completely ignored. I exaggerated unfairly.
10:30:02 <EvilMachine> ertes: Look for the amount of functions that do  :: (a -> b) -> [a] -> [b] on Hoogle. Besides map. :)
10:30:32 <ertes> EvilMachine: "use descriptive names" is often abused…  my favourite function from the windows API is MsgWaitForMultipleObjectsEx =)
10:30:41 <infinisil> Other option with Vect again: `map : (a -> b) -> Vect n a -> Vect n b` (but still not sufficient)
10:31:04 <ertes> in any case, my point is that names and types can explain a function even in highly domain-specific cases
10:31:22 <ertes> abstraction and DSLs are the key
10:31:25 <consus> ertes: You forgot about exceptions
10:31:51 <EvilMachine> ertes: That is the mirror-same as just using “a”. Every insane extreme has an opposite and precisely as insane extreme. And people *never* get it. When you argue against one extreme, they assume you’re siding with the other. Just for the record: I’m siding /against/ *ALL the things*. :)
10:32:08 <ertes> consus: you're ignoring my main point: you have an IO in there
10:32:14 <consus> ertes: So?
10:32:22 <ertes> consus: if you had a more generic 'm' there, it would be different
10:32:29 <consus> ertes: But it doesn't
10:32:33 <consus> ertes: It has IO
10:32:50 <ertes> consus: i said: "either you abstract further until parametricity explains it, or you add prose"
10:33:01 <ertes> consus: i said further: "i generally try to go for the former option first"
10:33:36 <cocreature> or just do a bit of both. expressive types and documentation are not a contradiction
10:33:36 <consus> BTW IOException is not the only kind of exception
10:34:04 <monochrom> Yes, people always just assume that you take the enemy's side.
10:34:09 <monochrom> The tragedy of the bat.
10:34:45 <ertes> i'm quite a heavy user of the "both" approach =)
10:35:16 <infinisil> Alright, everybody interested in types that specify what a function does, have a look at this interface to file handles in Idris: https://github.com/idris-lang/Idris-dev/blob/master/libs/contrib/Control/ST/File.idr#L54-L85
10:35:51 <infinisil> If you want to understand the ST type there, you'll want to read http://docs.idris-lang.org/en/latest/st/index.html#st-tutorial-index
10:37:47 <EvilMachine> infinisil: I’m sorry, but frankly, that doesn’t tell me s**t ^^
10:38:42 <monochrom> I think you have to have learned Idris in order to appreciate the "addIfRight (FileHandleI mode)" part.
10:39:36 <infinisil> Maybe, oh well, I tried
10:40:07 <monochrom> But it's using dependent typing (to depend on whether the Either happens to be Right) and type-level list/set (to record, at the type level, which file handles you have access to) to do what I just wrote in the parentheses.
10:40:24 <infinisil> yup
10:42:06 <ertes> how does I/O work in idris these days?  extensible effects?
10:47:43 <infinisil> ertes: I think ST has been favored instead of the Effects library, since ST is more flexible
10:47:59 <infinisil> ertes: (not an expert though)
10:49:10 <troido> I have a program that reads a file (using readFile) and later writes again to the same file. However when I try to open the file for writing I get a runtime error because the file is still locked. Is there a way I can force haskell to read and close the whole file so I can open it for writing?
10:50:15 <c_wraith> troido: what's your level of comfort with using additional packages?
10:51:12 <troido> if it's not too much it's ok
10:51:50 <c_wraith> there's a package named strict which has a System.IO.Strict module with a readFile that pulls in all the file contents at once.
10:52:14 <ertes> troido: if you're going to do that, i suggest that you use the 'text' package instead
10:52:45 <ertes> its readFile is strict as well, and doesn't have the drawback of potentially constructing a massive linked list
10:52:46 <troido> I am currently using Data.Text.IO.readFile
10:53:13 <troido> and it gives the error
10:53:18 <ertes> troido: then readFile is not the culprit
10:53:45 <ertes> are you sure that's the only way you access the file?
10:54:02 <troido> I just realized I have to go. I'll try to fix it another time
10:54:39 <ertes> this is also a question of OS: i think POSIX-based systems are fine with opening the file for writing at the same time
10:55:31 <glguy> Haskell Handle IO won't open a file for read and write at the same time independent of the underlying OS
10:56:50 <infinisil> Oh, Idris 1.2.0 got just released!
11:13:04 <consus> >  Haskell Handle IO won't open a file for read and write at the same time independent of the underlying OS
11:13:07 <consus> WHAAAAT
11:13:08 <lambdabot>  <hint>:1:85: error: parse error on input ‘of’
11:13:54 <[exa]> interesting that lambdabot knows all the words until 'of'
11:14:02 <kakashiAL> does this double point in [1..42] has a name in haskell? maybe pointoperator?
11:14:28 <[exa]> kakashiAL: it's special syntax for enumerated ranges, maybe there's something in docs of Enum
11:14:37 <monochrom> [exa]: No, it knows none of the words until "of". At which point it notices the absence of "case". :)
11:14:52 <consus> glguy: So you're saying that it's impossible to work with a character device in haskell?
11:15:12 <kadoban> kakashiAL: It probably does, but it's not an operator. I dunno what it's actually name is.
11:15:57 <c_wraith> yeah, .. is one of the rare bits of reserved punctuation syntax in haskell.
11:16:53 <monochrom> You can safely call it "dot dot".
11:18:05 <monochrom> Try not to overthink how to convert computer files to voice.
11:21:01 <kakashiAL> monochrom: found some articles where they call "dot dot" the "range-notation"
11:21:11 <kakashiAL> which is nice :)
11:22:15 <[exa]> kakashiAL: internally it's a syntactic sugar that's converted to 'enumFromTo'
11:22:23 <kakashiAL> [exa]: sure
11:22:30 <[exa]> which is not a very fancy name
11:23:24 <monochrom> I'm wondering how often you would actually use a name for this.
11:24:12 * [exa] envisions pointfree functions with enumFromTo
11:24:27 <monochrom> Even if you're being a modem, i.e., converting computer files to voice, "one dot dot two" suffices, why bother with any more technical "professional" name.
11:24:28 <davean> [exa]: writen more then one
11:25:26 <[exa]> wow, I'll use this "modem" naming for some teachers
11:25:35 <royal_screwup21> :t foldl
11:25:37 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
11:27:05 <Tuplanolla> If everything had a name, we would have infinite names or ambiguities.
11:27:07 <royal_screwup21> I know what foldl does but I can't seem to understand why its type is defined the way it is. Could someone please walk me through it?
11:28:02 <[exa]> royal_screwup21: what part of the type you don't understand? (guess 1: Foldable t, guess 2: why order the arguments like this)
11:28:04 <royal_screwup21> (b -> a -> b) -- I understand that this means it takes in a function, which takes in 2 things and outputs 1 thing
11:28:21 <royal_screwup21> the order of argumentns
11:28:42 <metahumor> royal_screwup21: :t \useaccumandnext baseaccumcase foldableofnext -> foldl useaccumandnext baseaccumcase foldableofnext
11:28:56 <metahumor> :t \useaccumandnext baseaccumcase foldableofnext -> foldl useaccumandnext baseaccumcase foldableofnext
11:28:57 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
11:29:56 <metahumor> royal_screwup21: we know that foldl, at some argument, expects of Foldable of some things. we can identify that in the typesig of "foldl" as "t a"
11:30:11 <[exa]> royal_screwup21: the first argument is the folding function (correctly), next one is the initial "leftmost" value of type b, 't a' is a "foldable container of a's", and result is b
11:30:12 <royal_screwup21> okay
11:30:33 <metahumor> royal_screwup21: we also know foldl requires a "base value" on top of which to accumulate, and the output value must be of the same type, which here is "b"
11:30:50 <royal_screwup21> yup got that
11:31:21 <metahumor> royal_screwup21: putting those two together, we see that foldl expects a function that takes a "type of accum" and "type we're folding over" and outputs the new "accum"
11:31:32 <metahumor> compare that to the typesig of "foldr"
11:31:34 <metahumor> :t foldr
11:31:36 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:31:55 <[exa]> royal_screwup21: and the order of stuff in (b->a->b) is different from foldr (where it's (a->b->b)), where the 'b' value comes from right
11:32:03 <metahumor> its slightly different, the order of arguments for the function it expects are flipped
11:32:10 <[exa]> yep
11:32:27 <metahumor> royal_screwup21: can you write out in "infix notation" what "foldl f 0 [1..]" would be?
11:32:46 <metahumor> royal_screwup21: similarly, write out in "infix notation" what foldr f 0 [1..]" would be?
11:33:07 <metahumor> ehh... change the list to [1..4] for this example
11:34:49 <[exa]> luckily humans can't loop inifinitely. :]
11:35:32 <metahumor> we can understand abstractions tho!
11:36:03 <royal_screwup21> I think i'm going to have to read up some more before I can internalize the concept
11:36:43 <metahumor> royal_screwup21: what's on your mind?
11:36:56 <royal_screwup21> :foldr
11:37:00 <royal_screwup21> :t foldr
11:37:02 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:37:17 <royal_screwup21> what's with the "t a"?
11:37:32 <[exa]> royal_screwup21: it's a more generic version of [a] in this case
11:38:15 <[exa]> royal_screwup21: fold can work on many more things than on lists (but all must be marked as Foldable)
11:38:25 <royal_screwup21> ah okay
11:38:57 <royal_screwup21> suppose I do: foldr (\x acc -> acc +x) 0 [1..4]
11:39:31 <royal_screwup21> I'm trying to see how the type definition matches up with that^
11:39:46 <metahumor> royal_screwup21: you got it exactly right for that one
11:40:31 <jared-w> :t foldr
11:40:34 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:40:46 <iphy> $ stack build
11:40:46 <iphy> No information found for ghc-7.8.4.
11:40:46 <iphy> Supported versions for OS key 'linux64-nopie': GhcVersion 8.0.2, GhcVersion 8.2.1, GhcVersion 8.2.2
11:40:51 <[exa]> royal_screwup21: it sometimes helps to put the parentheses there correctly
11:40:52 <jared-w> :t (\x acc -> acc + x)
11:40:55 <lambdabot> Num a => a -> a -> a
11:41:05 <jared-w> So there's your (a -> b -> b) :)
11:41:07 <iphy> does anyone know how to fix that?
11:41:18 <royal_screwup21> yup
11:41:24 <iphy> I'm using resolver: lts-2.22
11:41:57 <jared-w> Lists are an instance of Foldable, so the list is your `t a`
11:42:10 <royal_screwup21> :t foldr
11:42:13 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:42:21 <iphy> stack new myproject --resolver lts-2.22; cd myproject; stack build # <- this gives me the error "No information found for ghc-7.8.4."
11:42:21 <jared-w> so putting it all together you have `Foldable t => (a -> a -> a) -> a -> t a -> a`
11:42:22 <royal_screwup21> ^ what does this b signify?
11:42:29 <[exa]> jared-w: Num a ^
11:42:36 <jared-w> The b signifies that b and a don't need to be the same type
11:42:36 <royal_screwup21> the "b" that comes after the function
11:42:49 <jared-w> the b after the function is your 'default value'
11:43:02 <jared-w> :t foldr1 -- can't be used on empty foldable containers
11:43:03 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
11:43:04 <metahumor> iphy: try running "stack setup" first
11:43:13 <royal_screwup21> ah the default value okay
11:43:15 <iphy> metahumor: same error
11:43:25 <[exa]> royal_screwup21: folding function parameters can have different types (e.g. fold chars to a string)
11:43:29 <metahumor> maybe your architecture isn't supported by stack for older "ghc"s
11:43:31 <jared-w> Since it can't be used on foldable containers, foldr1 has no 'b' and requires that everything is the same type
11:43:31 <iphy> stack version 1.6.3
11:43:49 <iphy> metahumor: it used to be.. I built things with it a few minutes ago
11:43:53 <jared-w> So you can't implement 'elem' with a foldr1 function, you need to use foldr
11:43:58 <iphy> then I upgraded stack from 1.4 to 1.6.3 and it stopped working
11:44:09 <royal_screwup21> wow thanks so much guys, I think I "get" it now :)
11:45:04 <[exa]> royal_screwup21: two more bonus things :]
11:45:22 <[exa]> :t foldr (+)
11:45:24 <lambdabot> (Num b, Foldable t) => b -> t b -> b
11:45:55 <jared-w> :t foldr (\a as -> a + as)
11:45:58 <lambdabot> (Num a, Foldable t) => a -> t a -> a
11:46:15 <royal_screwup21> ah they're the same
11:46:27 <jared-w> The fancy name for that is called function slices, I believe
11:46:38 <jared-w> :t (+1) -- simple example
11:46:41 <lambdabot> Num a => a -> a
11:46:48 <iphy> downgrading doesn't fix it (I also deleted ~/.stack)
11:46:50 <jared-w> :t (\x -> x + 1)
11:46:52 <lambdabot> Num a => a -> a
11:47:08 <infinisil> jared-w: or function sections?
11:47:20 <[exa]> > (foldl (+1) [1..1234])
11:47:24 <lambdabot>  error:
11:47:24 <lambdabot>      • Couldn't match type ‘[a1]’ with ‘a -> [a1]’
11:47:24 <lambdabot>        Expected type: [a1] -> a -> [a1]
11:47:31 <[exa]> holy god.
11:47:32 <jared-w> Since all functions are curried in haskell, and since + is nothing more than a function, if you apply only one argument to + ... it just works as you'd expect :)
11:47:36 <[exa]> > (foldl (+1) 0 [1..1234])
11:47:41 <lambdabot>  error:
11:47:41 <lambdabot>      • Occurs check: cannot construct the infinite type:
11:47:41 <lambdabot>          b ~ Integer -> b
11:47:43 <royal_screwup21> if I subbed "t a" as "[a]" -- would that be alright? I think t a is more generic but [a] seems right
11:47:59 * [exa] failed
11:47:59 <jared-w> royal_screwup21: that'll work just fine
11:48:13 <jared-w> [exa]: think about what you're trying to do for a second :)
11:48:20 <[exa]> yeah I know
11:48:21 <jared-w> does 0 +1 2 +1 3 +1 4 +1 ... make sense?
11:48:44 <jared-w> (I figured you'd know this)
11:49:01 <royal_screwup21> > (foldl (+) [1..1234])
11:49:01 <[exa]> I wanted to come to something like length = foldr (const (+1)) 0
11:49:05 <lambdabot>  error:
11:49:05 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_111234’
11:49:05 <lambdabot>      • In the expression: e_111234
11:49:29 <infinisil> lol
11:49:37 <jared-w> > foldl (\x xs -> xs + 1) 0 [1..10] -- Pretty sure this is how you'd write it?
11:49:37 <albatross_> hey guys, how do i convert [[1,2,3],[4,5,6]] to [[1,2,3],[4],[5,6]]
11:49:39 <[exa]> royal_screwup21: it's trying to use [1..1234] as the 'b', which should be integer
11:49:41 <lambdabot>  11
11:49:50 <jared-w> So, pointfree...
11:49:57 <infinisil> > foldl (+) 0 [1..1234]
11:49:59 <lambdabot>  761995
11:50:13 <jared-w> > foldl' (flip (+1)) [1..10] -- let's try this out...
11:50:16 <lambdabot>  error:
11:50:16 <lambdabot>      • No instance for (Num ([Integer] -> [Integer]))
11:50:16 <lambdabot>          arising from a use of ‘e_11110’
11:50:23 <jared-w> > foldl' (flip (+1)) 0 [1..10] -- let's try this out...
11:50:29 <lambdabot>  error:
11:50:29 <lambdabot>      • No instance for (Enum (Integer -> Integer))
11:50:29 <lambdabot>          arising from a use of ‘e_110110’
11:50:40 <[exa]> jared-w: you need const to discard the argument, but I hope there will be something that can make flip work :D
11:50:56 <jared-w> oh right, duh
11:51:02 <jared-w> :t const
11:51:03 <infinisil> Can the people here please use your local ghci instead of lambdabot for trying things out?
11:51:04 <metahumor> the error messages are kinda intimidating because we're mixing in Enum and Num classes
11:51:04 <lambdabot> a -> b -> a
11:51:13 <[exa]> infinisil: sorry. :]
11:51:23 <jared-w> You need both flip and const :p
11:51:23 <Iceland_jack> albatross_: By what rule? \[[1,2,3],[4,5,6]] -> [[1,2,3],[4],[5,6]]
11:51:58 <metahumor> it might be more instructive to try folding on lists of Strings, there, the errors will be better. try rewriting a "unwords" function
11:52:35 * [exa] back to kind inference
11:52:41 <jared-w> [exa]: oh that's what was messing with me. const (1+) works but const (+1) won't
11:52:57 <[exa]> jared-w: it must, (+1) is unary
11:53:11 <jared-w> > foldl (const (1+)) 0 [1..10]
11:53:14 <lambdabot>  11
11:53:17 <jared-w> > foldl (const (+1)) 0 [1..10]
11:53:22 <lambdabot>  11
11:53:42 <albatross_> Iceland_jack, what do you mean by what rule?
11:53:45 <[exa]> but I'd expect parsing shenanigans in different environments (+1) looks a lot like integer
11:54:14 <jared-w> hmm, nvm, you're right. The pf function just spit out 1+ instead of +1 so that confused me for a second. Also, in the curry language 1+ and +1 behave differently sometimes and in Haskell -1 and 1- work differently :p
11:54:26 <[exa]> yeah. :]
11:55:00 <Sose> jared-w: isn't that only doing 10+1 in the end now? and not calculating the length
11:55:27 <jared-w> mmm... Now that I think about it, I think you're right
11:55:38 <jared-w> > foldl (const (+1)) 0 [3..5]
11:55:41 <metahumor> albatross_: "f (xs:(y:ys):_) = [xs, [y], ys]"
11:55:41 <lambdabot>  6
11:55:42 <[exa]> luckily not, const discards second argument
11:56:01 <ph88> can categories be created with type classes ?
11:56:02 <[exa]> ah you're doing it with foldl
11:56:04 <jared-w> Yeah but I'm using a left fold instead of a right fold :p
11:56:32 <jared-w> > foldr (const (+1)) 0 [3..5] -- This works as expected
11:56:36 <lambdabot>  3
11:56:37 <[exa]> let's use length from now on.
11:56:44 <[exa]> :D
11:56:45 <Sose> :D
11:58:37 <jared-w> ಠ_ಠ
11:58:59 <jared-w> with foldr it's const (+1), with foldl it's const . (+1)
11:59:28 <jared-w> > foldl (const . (+1)) 0 [3..5] -- makes sense if you think about it too hard
11:59:32 <lambdabot>  3
11:59:51 * hackage ex-pool 0.2.1 - Another fork of resource-pool, with a MonadIO and MonadCatch constraint  https://hackage.haskell.org/package/ex-pool-0.2.1 (KimAltintop)
12:00:19 <[exa]> @pl foldl (const.(+1)) 0
12:00:19 <lambdabot> foldl (const . (1 +)) 0
12:00:23 <[exa]> :(
12:00:42 <[exa]> (that was pointless)
12:00:53 <jared-w> lol
12:01:18 <qmmm> if i have a directory structure such as parent/child1 and parent/child2 where child1 and child2 are cabal projects created using "stack new", can i import child2 from within child1? is there documentation describing how to do this?
12:03:30 <jared-w> You're looking for for multi-package projects in stack, I believe
12:04:29 <jared-w> https://docs.haskellstack.org/en/stable/GUIDE/#multi-package-projects
12:04:38 <qmmm> thank you for that term jared-w
12:05:22 * hackage ats-format 0.1.0.18 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.18 (vmchale)
12:06:52 <jared-w> You can also just stick the other codebase in the extra-deps using a relative file path (it's on the same page of documentation, a little further down)
12:13:00 <kakashiAL> 42 : [1, 2, 3] returns [42, 1, 2, 3]  because it prepends everything to the list that is at the left side of :
12:13:14 <kakashiAL> what is the symbole for "add to the back of the list"?
12:13:21 * hackage unliftio 0.2.4.0 - The MonadUnliftIO typeclass for unlifting monads to IO (batteries included)  https://hackage.haskell.org/package/unliftio-0.2.4.0 (MichaelSnoyman)
12:14:29 <qmmm> is there a way to create a multi-package project without stack?
12:14:52 <Hafydd> kakashiAL: there is not a constructor that does that, but to append an element to the end of an ordinary list you can use xs ++ [x].
12:15:06 <koz_> kakashiAL: You can also look up the snoc function.
12:15:20 <Hafydd> > [1, 2, 3] ++ [4]
12:15:24 <lambdabot>  [1,2,3,4]
12:15:26 <jared-w> Terrible time complexity for lists, of course, but meh :p
12:15:26 <koz_> > :t snoc
12:15:33 <lambdabot>  mueval-core: Time limit exceeded
12:15:39 <Hafydd> snoc is not in the standard library.
12:15:41 <jared-w> :t snoc
12:15:43 <lambdabot> Snoc s s a a => s -> a -> s
12:15:43 <kakashiAL> Hafydd, koz_: thanks, good to know
12:15:58 <jared-w> Snoc typeclass? wtf?
12:16:04 <kakashiAL> just in case but x : xs  <--the x in xs stands for the plural form of the x ?:)
12:16:14 <koz_> jared-w: Yeah, what's up with that?
12:16:15 <kakashiAL> I mean the s
12:16:25 <jared-w> kakashiAL: yeah, it's an idiom
12:16:37 <jared-w> you can use head:tail as well, which might be clearer
12:16:51 <jared-w> or head:restOfTheList :p
12:17:15 <Hafydd> If you have awful taste.
12:17:21 * hackage rio 0.0.0.0 - A standard library for Haskell  https://hackage.haskell.org/package/rio-0.0.0.0 (MichaelSnoyman)
12:18:15 <jared-w> ¯\_(ツ)_/¯ it's often clearer to beginners, and it's important for people to understand that : is a constructor, not a magical incantation that's used with x and xs
12:18:24 <kakashiAL> jared-w: thanks, but I guess they use x and xs to symbolise that x is the argument of a function (or can be one) and the xs is something independent from x
12:18:41 <koz_> kakashiAL: No, it's just an idiom for 'head and tail'.
12:18:57 <koz_> It could just as easily have been 'y:ys'.
12:19:01 <koz_> Or 'foo:bar'.
12:19:04 <koz_> Or literally anything else.
12:19:14 <koz_> (with a colon as a separator obviously)
12:19:19 <kakashiAL> koz_: sure, but x makes more sense in a functional context :)
12:19:21 <koz_> It's just pattern matching on the list constructor.
12:19:31 <koz_> No more so than y, or frob.
12:20:08 <Hafydd> x is often used in mathematics for a single value, for example as elementary algebra is introduced, so if you're dealing with a value whose type you do not know, x can be a good choice; and xs is, as you say, the plural form.
12:20:44 <kakashiAL> Hafydd: thats what I meant :)
12:20:51 <Hafydd> kakashiAL: that's not what you said.
12:21:04 <kakashiAL> sometimes I also see (1 : (2 : 3 : ([4, 5, 6])))   <---sometimes with and sometimes without ( )
12:21:20 <kakashiAL> when and when not can I remove ( )?
12:21:51 <[Leary]> > 1:2:3:[4,5,6]
12:21:54 <lambdabot>  [1,2,3,4,5,6]
12:22:02 <shiona> kakashiAL: (1 : (2 : ([]))) is same as (1 : (2 : [])) is same as (1:2:[])
12:22:10 <Hafydd> kakashiAL: (:) is right-associative, so you can remove parentheses whenever right-associativity disambiguates it properly.
12:22:18 <shiona> (1 : 2) : [] is not the same as 1 : 2 : []
12:22:35 <koz_> > (1 : 2) : []
12:22:38 <lambdabot>  error:
12:22:38 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_112’
12:22:38 <lambdabot>      • In the expression: e_112
12:22:44 <koz_> Thought so.
12:22:49 <shiona> so you can remove the ()'s if the ending bracket is after the last element
12:23:04 <shiona> parentheses*
12:23:45 <Hafydd> Remember that the first argument to (:) is a single value, and the second argument is a list of values of the same type as the first argument.
12:23:51 <kakashiAL> does haskell always evaluates from left to right?
12:24:05 <Hafydd> kakashiAL: no; some functions are left-associative, or not associative.
12:24:09 <MarcelineVQ> kakashiAL:   :info in ghci will give you a little note about operator fixity,  :info :   will tell you : is infixr 5  which means it's right associative and has a precendece of 5 for how tightly it binds compare to other operators
12:24:25 <c_wraith> Fixity determines the parse tree, not the evaluation order. :)
12:24:35 <c_wraith> The two need not be related in Haskell.
12:25:15 <c_wraith> Well, that's not totally true.  The root does need to be evaluated far enough to determine what it does with its arguments first.
12:25:52 <kakashiAL> what I mean is: if haskell sees this: 1 : 2 : []   it would return an error, because its starts from the left, it finds a 1 then it finds a (:) and then it finds a 2, which is not a list, thats why I mean "from left to right"
12:26:05 <c_wraith> that's parsing, not evaluating.
12:26:09 <c_wraith> > 1 : 2 : []
12:26:13 <lambdabot>  [1,2]
12:26:17 <c_wraith> Also, it parses just fine
12:26:23 <Welkin> : is infix Cons
12:26:37 <[Leary]> It doesn't find a 2, it finds a 2:[].
12:26:37 <kakashiAL> Welkin: infix Cons?
12:26:42 <Welkin> it works because of lazy evaluation
12:27:05 <Welkin> data List a = Nil | Cons a (List a)
12:27:07 <ph88> can categories be created with type classes ?
12:27:10 <Welkin> that's the common example
12:27:31 <Welkin> wha tis a category?
12:28:23 <MarcelineVQ> ph88: sure, there's the basis in  Control.Category
12:28:24 <c_wraith> ph88: there's a Category class in base..
12:29:02 <albatross_> hey guys
12:29:04 <albatross_> http://lpaste.net/361442
12:29:12 <albatross_> i'm trying to make a binary tree
12:29:20 <ph88> i'm going through the book category theory for programmers and on page 36 it says:   Generate a free category from:  (a) A graph with one node and no edges
12:29:26 <MarcelineVQ> ph88: if it's a subjet that interests you conal's blog is well stocked with category stuff in haskell http://conal.net/blog/
12:29:28 <albatross_> I'm having trouble figuring out how to make this recursion work
12:29:38 <ph88> no clue what they mean with "generate a free category"  .. so i guessed i had to use type classes ^^
12:30:35 <Welkin> albatross_: what pat exactly?
12:30:37 <Welkin> which part*
12:31:04 <Welkin> albatross_: you are missing a base case
12:31:08 <ph88> it's on this page under challenges  https://bartoszmilewski.com/2014/12/05/categories-great-and-small/
12:31:21 <Welkin> also, I see syntax errors
12:31:44 <Welkin> and no definition for your data type
12:31:48 <Welkin> too much i missing
12:31:50 <Welkin> paste the whole thing
12:32:22 <Welkin> I don't understand what's with the comma and the <-
12:45:36 <ph88> not sure if using Control.Category is what i'm suppose to do here
12:48:21 * hackage data-msgpack 0.0.11 - A Haskell implementation of MessagePack  https://hackage.haskell.org/package/data-msgpack-0.0.11 (iphydf)
12:50:48 <Tuplanolla> It's not a programming exercise, ph88.
12:53:14 <ph88> oh ..
12:53:39 <ph88> what does he mean with "generate" ?
12:53:55 <Tuplanolla> Write a recipe.
12:54:08 <ph88> a function ?
12:54:14 <Tuplanolla> An informal description.
12:55:01 <ph88> still not sure what that should look like
12:55:04 <ph88> a drawing perhaps ?
12:55:45 <Tuplanolla> Have you ever seen a mathematical publication? Like that.
12:56:08 <Welkin> a feynman diagram
13:01:52 * hackage HappyTree 0.2018.1.7 -   https://hackage.haskell.org/package/HappyTree-0.2018.1.7 (MarisaVeryMoe)
13:02:41 <ph88> Tuplanolla, no i haven't seen a mathematical publication
13:03:07 <Tuplanolla> Let's fix that right now: https://arxiv.org/archive/math
13:06:01 <consus> Guys
13:06:39 <consus> Ah, nevermind
13:06:44 <consus> I'll better benchmark
13:07:47 <ph88> Tuplanolla, this book is "category theory for programmers" now i feel like "category theory for mathematicians"
13:08:02 <ph88> https://arxiv.org/pdf/1801.00321.pdf
13:08:49 <ph88> the images on page 22 look nice though
13:09:26 <Welkin> it says it's for programmers, not that you will write programs for the book
13:09:34 <Tuplanolla> It's not the most faithful title either.
13:09:39 <Welkin> category theory is math
13:09:47 <Welkin> not programming at all
13:10:31 <ph88> ye i got that so far i worked up to page 37
13:17:35 <dmwit> ph88: You can draw a graph by putting dots for nodes and lines for vertices.
13:18:02 <dmwit> ph88: You can do a similar thing for categories: draw a dot for objects and arrows for arrows.
13:18:55 <dmwit> ph88: You should label one loop on each object "id", for sure. And then you need to notate somehow what composition does, and that probably should be done separately from the drawing.
13:19:24 <dmwit> ph88: (But for the particular exercise you posted above, generating the free category from the graph with one node and no edges, this will be quite a small extra note.)
13:20:33 <ph88> drawing sounds good to me
13:24:21 <parsnip> trying to do exercism's hello-world, running into AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
13:24:41 <parsnip> have done `stack upgrade`, `stack setup` results in this error.
13:25:52 * hackage uuagc-cabal 1.1.0.0 - Cabal plugin for UUAGC  https://hackage.haskell.org/package/uuagc-cabal-1.1.0.0 (AtzeDijkstra)
13:27:10 <ProofOfPizza> Hi guys, another simple question. I am confused about some of the types like Ord, Eq etc. Is there some documentation that describes these types and what'n in em ?
13:29:15 <parsnip> oh, i don't have the right stack on path i think
13:29:25 <parsnip> disregard for a bit
13:30:41 <parsnip> ProofOfPizza: i'm a bit rusty, but i could try to discuss for a moment.
13:30:59 <Average-user> whats the best data structure in Haskell for cutting from one side and pasting in the other?
13:31:07 <parsnip> what is confusing about them? i might start by pointing out, they are not types.
13:31:52 * hackage chr-core 0.1.0.1, chr-lang 0.1.0.1 (AtzeDijkstra): https://qbin.io/kg9bmnxz0
13:32:33 <monochrom> All confusions are caused by wrong assumptions.
13:33:04 <parsnip> ProofOfPizza: one place to start for documentation, is the 2010 Haskell Report.
13:33:37 <parsnip> section 6.3
13:34:49 <parsnip> also see section 4.1
13:35:26 <ProofOfPizza> hehe ok. Well I am trying to follow the learnyouahaskell and it talks a bit about these ehm, typeclasses (?), so I try, to get the hang of it, to write the excercises with those types. Eg: elem' :: (Ord a) => a -> [a] -> Bool  .. apparently works better as elem' :: (Eq a) => a -> [a] -> Bool
13:35:49 <[Leary]> Seq should be pretty good for it, Average-user; I believe both adding to and reading from either end is O(1).
13:36:10 <mniip> [Leary], not logarithmic?
13:36:33 <[Leary]> Oh, adding might be log... I'm not sure.
13:36:40 <ProofOfPizza> seems to make a bit of sense, intuitively, but I was just wondeing if there is some comprehensive documentation of this kind of stuff. Like javadocs for java, something like that
13:38:03 <parsnip> ProofOfPizza: i provided some docs.
13:38:14 <ProofOfPizza> :r
13:38:20 <[Leary]> Actually since concatenating is log in the shorter length, I guess it is O(1) either way.
13:38:27 <Hafydd> ProofOfPizza: https://www.haskell.org/onlinereport/haskell2010/
13:38:33 <ProofOfPizza> e `elem'` "hallo?"
13:38:44 <ProofOfPizza> oh ppff  sorry.. :) wrong tab!
13:39:26 <Average-user> [Leary]: Currently I'm using Sequences, I asked in case some of you know something better
13:39:29 <verement> ProofOfPizza: you could also read https://hackage.haskell.org/package/base (Data.Ord, Data.Eq, etc.)
13:40:00 <parsnip> oh right, hackage is the other great source of docs.
13:41:52 * hackage ats-format 0.1.0.19 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.19 (vmchale)
13:42:27 <Hafydd> GHC's standard libraries are also described at <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/index.html>.
13:44:07 <ProofOfPizza> wow cool stuff, I'll lool into them, thanks!
13:53:52 * hackage network-msgpack-rpc 0.0.4 - A MessagePack-RPC Implementation  https://hackage.haskell.org/package/network-msgpack-rpc-0.0.4 (iphydf)
13:56:51 * hackage shuffle 0.1.4.0 - Shuffle tool for UHC  https://hackage.haskell.org/package/shuffle-0.1.4.0 (AtzeDijkstra)
14:05:06 <anon136> is it possible to map the output of a function back to it's input and just leverage lazy evaluation treat it like an infinite list?
14:05:19 <glguy> :t iterate
14:05:22 <lambdabot> (a -> a) -> a -> [a]
14:06:10 <anon136> yea i tried iterate
14:06:18 <anon136> probably just didn't try it correctly
14:06:35 <mdupont> anyone take a look at cardano-sl the new crypto currency based on haskell?
14:06:41 <monochrom> It also depends on what you exactly want.
14:06:51 <anon136> h/o ill show you
14:08:08 <monochrom> There is something ill about a crypto currency basing on a language rather than on crytpo design or economics or algorithms.
14:08:59 <monochrom> It's like saying "Chrome is a Mountain View-based web browser".
14:09:22 <anon136> Cardano isn't based on haskell its not their selling point or anything. It's just coded in it.
14:10:59 <anon136> So I have this little bit of code http://ix.io/DMR And I'm trying to figure out how to make another function that will call it on it's self infinitely and let me do something like "take 10 fibonacci"
14:11:41 <anon136> and you know map the output of stepFib back to its input each time
14:12:05 <monochrom> Oh, that one is "fib = 0 : 1 : zipWith (+) fib (tail fib)"
14:12:55 <anon136> Sure I've seen that code from a google search. Never the less I'm trying to figure out if its possible to do THIS thing.
14:13:03 <monochrom> Or if you like to start with 1,1 instead of 0,1, do a s/0 : 1/1 : 1/
14:13:50 <anon136> I'm not trying to solve any particular problem just trying to learn by giving myself challenges.
14:13:55 <monochrom> OK if you want a function involved, then the recursion is not going to be in the function itself. Instead:
14:14:31 <monochrom> f xs = 0 : 1 : zipWith (+) xs (tail xs).  Then do a fib = f fib
14:16:32 <anon136> Can that same idea be applied to my function?
14:16:42 <monochrom> Or if you want to involve iterate, then it begins to look like what you posted. But you still don't do your own recursion --- iterate already does it.
14:18:22 * hackage idris 1.2.0 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-1.2.0 (EdwinBrady)
14:18:51 <monochrom> step [] = [1, 0]; step (x1 : x2 : xs) = x1 + x2 : xs
14:18:58 <anon136> i think i know what i need to do!
14:19:20 <monochrom> which is closest to what you posted, complete with having a fib sequence in reverse.
14:19:30 <monochrom> And you do a "iterate step []"
14:19:47 <monochrom> And damn English s/ a / an /
14:23:07 <Franciman> Hi
14:23:48 <Franciman> I'm using threadDelay to repeat an action every x minutes. But it isn't precise and sometimes the action is executed even much time later the x minutes
14:23:49 <Franciman> Why?
14:23:55 <Franciman> And is there another way to do this?
14:24:52 <dmj`> Franciman: can you paste your code?
14:25:58 <Franciman> dmj`, yes, just one minute because I changed some things and broke everything
14:28:29 <dmj`> is it just like (forever $ threadDelay (1000000 * 60 * 5 {- 5 mins -}) >> doThing) ?
14:30:03 <srid__> dmj`: how long does `doThing` take to run normally?
14:30:18 <Franciman> dmj`, yes
14:30:22 <Franciman> why?
14:30:29 <Franciman> just the opposite, actually
14:30:42 <glguy> The next timer doesn't start until doThing finishes
14:30:44 <Franciman> forever $ doThing >> threadDelay fifteenMinutes
14:31:22 <Franciman> ah, so you're suggesting that doThing take A LOT of time?
14:31:40 <Franciman> I didn't consider that :P Sorry for the dumb question, then
14:31:44 <dmj`> Franciman: what thing does doThing do
14:31:58 <Franciman> does a bunch of HTTP requests
14:32:02 <srid__> there you go
14:32:38 <dmj`> If you get a timeout it could take a lot longer
14:32:49 <parsnip> hmm, `stack --version` is 1.3.2 while `$(which stack) --version` is 1.6.3: http://lpaste.net/361443
14:33:22 <MarcelineVQ> did you just upgrade?
14:33:24 <glguy> Did you just upgrade, perhaps you need to reset your search path cache: hash -r   in bash
14:33:26 <MarcelineVQ> try a fresh console
14:33:28 <parsnip> yes
14:33:45 <parsnip> ah, thanks >.< that fixed it
14:34:50 <srid__> TIL `hash -t ls` is what you need sometimes instead of `which ls`
14:35:43 <Franciman> dmj`, http://lpaste.net/361447#line96 here's the code looping
14:37:11 <dmj`> Franciman: `ItalianSubs`, like an italian sub sandwich or italian subtitles?
14:37:31 <Franciman> Subtitles ahahah
14:37:52 <dmj`> just needed clarification ;)
14:43:12 <anon136> Sorry I thought that would be more convenient.
14:46:36 <anon136> So I did it like this http://ix.io/DMY and it doesn't compile.
14:47:12 <monochrom> Ah OK, let me try.
14:48:06 <glguy> anon136: When you get an error message you should include it in your paste
14:48:25 <monochrom> Oh haha "x1 + x2 : xs" is not enough
14:48:39 <anon136> will do in fugure glguy
14:48:42 <consus> Ugh
14:48:44 <consus> Guys
14:48:52 <consus> Any way to check that toEnum will not fail?
14:49:10 <consus> I mean without C-style hacks like "this element of the enum should always be the last"
14:49:15 <glguy> consus: It's OK to have more than one sentence in a single chat message
14:49:26 <consus> I'm using irssi
14:49:39 <monochrom> step xs@(x1 : x2 : _) = x1 + x2 : xs
14:50:08 <monochrom> consus: We mean we want you to press <enter> less often.
14:50:35 <verement> consus: check against (fromEnum . maxBound)?
14:50:55 <verement> oops I did not mean (.)
14:50:57 <anon136> "take 10 fib" returns a list of lists of fibs. Not just a list of fibs.
14:51:14 <consus> verement: maxBound require the data type to be Bounded, right?
14:51:21 <verement> sure
14:51:26 <monochrom> OK, then it is not as simple as iterate.
14:52:05 <consus> verement: So it's like Data Foo = Foo | Bar deriving (Bounded, Enum, Show)?
14:52:06 <anon136> Yea this list of lists is something I got to a while ago but couldn't figure out how to get past.
14:52:25 <verement> consus: I think that would work
14:52:27 <monochrom> You will want to have iterate to produce a list like [(0,1), (1,1), (1,2), (2,3), (3,5), (5,8), (8, 13) ...] first. Then do a "map fst"
14:52:45 <consus> verement: Non type-variable argument in the constraint: Bounded (Foo -> t)
14:53:13 <consus> verement: Ah, I see, it's FlexibleContexts
14:53:25 <anon136> I could figure out how to do that I'm quite sure.
14:54:51 <anon136> Does it have to be tuples though instead of [[0,1], [1,1], [1,2] ...]?
14:55:40 <monochrom> Tuple is less error-prone than list-of-fixed-length
14:56:23 <monochrom> Fewer partial functions involved.
14:56:57 <anon136> Cool. I've never actually used a tuple for anything. Now seems like a good time. Thanks for the ideas and advice.
15:03:21 * hackage cabal-plan 0.3.0.0 - Library and utiltity for processing cabal's plan.json file  https://hackage.haskell.org/package/cabal-plan-0.3.0.0 (HerbertValerioRiedel)
15:04:38 <steveo> What is "cabal.project"?
15:04:40 <steveo> https://github.com/haskell/cabal/blob/master/cabal.project
15:04:51 <steveo> I've never seen such a file.
15:04:56 <glguy> It's the file that configures "cabal new-build"
15:06:14 <glguy> It's the settings that are intended to be shared by all users, there's also cabal.project.local for settings specific to a particular instance of the repository
15:06:22 * hackage singletons 2.4 - A framework for generating singleton types  https://hackage.haskell.org/package/singletons-2.4 (RichardEisenberg)
15:07:57 <troydm> what's the best IPC communication library for haskell?
15:08:19 <troydm> like I have two processes running on linux that I want to communicate with each other
15:16:10 <steveo> If cabal and stack never work, isn't it time for a new tool?
15:16:11 <steveo> https://gist.github.com/anonymous/edd5276c50fd5a3ff3f2da445befda05
15:18:11 <monochrom> Hypothetical question. cabal works for me.
15:18:21 <glguy> Assuming false than anything
15:18:31 <glguy> steveo: You read this part?  Warning: Installed version of cabal-install (2.0.0.1) is newer than stack has been tested with.  If you run into difficulties, consider downgrading.
15:18:49 <glguy> What version of stack are you using?
15:18:52 <monochrom> Consider quitting stack :)
15:19:08 <davean> steveo: I never have issues with cabal
15:19:10 <glguy> then*
15:19:24 <monochrom> But why does stack care about cabal-install version?
15:19:33 <glguy> Because it uses cabal for its solver
15:19:40 <steveo> How do I downgrade cabal-install?
15:19:40 <monochrom> Or maybe it should be s/care about/is affected by/
15:19:59 <glguy> The two modes of stack are "You do version resolution manually or you let cabal-install do it"
15:20:16 <monochrom> Hrm. Interesting.
15:20:36 <davean> steveo: just because you're trying to hammer a screw in with a screwdriver doesn't make the screw driver broken
15:20:38 <monochrom> You know, I also want to call up cabal-install for only-version-resolution too.
15:20:49 <glguy> monochrom: Isn't that the --dry flag?
15:20:56 <monochrom> Because they're deprecating --global but I want --global.
15:21:05 <monochrom> Is that it? :)
15:21:21 * hackage miso 0.11.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-0.11.0.0 (DavidJohnson)
15:21:43 <glguy> monochrom: also: http://hackage.haskell.org/package/cabal-plan
15:22:08 <monochrom> Oh I forgot that plan.json exists.
15:23:17 <joebetz> @let sum' = foldr (+) 0
15:23:20 <lambdabot>  Defined.
15:23:38 <joebetz> @let product' = foldr (*) 1
15:23:40 <lambdabot>  Defined.
15:24:44 <joebetz> that's weird. I get type errors when I try that elsewhere.
15:25:13 <joebetz> about the type variable for the foldable structure being ambiguous
15:25:44 <glguy> joebetz: You'll need to give those type signatures in your file or add an explicit function parameter
15:25:51 <glguy> sum' xs = foldl' (+) 0
15:25:55 <glguy> sum' xs = foldl' (+) 0 xs
15:27:33 <joebetz> glguy: and why not here?
15:27:53 <glguy> lambdabot has the Monomorphism-restriction disabled
15:29:49 <steveo> This all gives the impression that haskell and its tools are done not by experts but by amateurs
15:30:49 <glguy> steveo: You're welcome to be unproductive somewhere else
15:31:18 <EvanR> "experts"
15:32:38 <monochrom> Ah but in many other communities provocation and challenge-the-channel are their ways of being productive.
15:33:11 <steveo> Maybe people here think that replacing Cabal hell with Stack hell is productive
15:33:40 <steveo> Wasn't "the evil cabal" written in the community
15:33:56 <joebetz> glguy: so, what information exactly does it need from the type signature? iow, what can't it infer?
15:34:06 * EvanR waits for the booming voice of the community to respond
15:34:39 <glguy> steveo: No, we don't recommend replacing "cabal hell" with "stack hell". the "hell" was largely resolved by sandboxes and then later the new-build system
15:34:44 <MarcelineVQ> Not sure who's been giving you these impressions about stack and cabal, both are open to PR's though. if no one's an expert and one is needed the solution is to become the expert
15:34:47 <joebetz> and how does adding an explicit function parameter provide that information?
15:35:05 <glguy> and the community rejected the the "evil cabal" message as unproductive
15:35:51 <monochrom> What is stack hell? Much as I speak against stack, even I don't say "stack hell".
15:36:29 <steveo> What is the offical "cabal version" of stack?
15:38:04 <anon136> Victory! http://ix.io/DN8
15:38:07 <MarcelineVQ> joebetz: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-930004.5.5
15:39:06 <glguy> joebetz: The issue is that the inferred type of sum' would have a constraint in it that can't be resolved by defaulting
15:39:21 <glguy> so this value is going to have to be recomputed every time its used, like the behavior of a function
15:40:07 <glguy> this would often be surprising that the value is repeatedly recomputed because it was declared with a value declaration instead of a function declaration (one having some function parameters in it)
15:40:34 <glguy> so instead of a performance surprise at runtime, you get a compiler error
15:50:39 <monochrom> anon136: Congrats.
15:53:28 <joebetz> how exactly is it surprising? and from who's perspective?
15:58:40 <glguy> joebetz: Have you read the link MarcelineVQ provided yet?
16:03:31 <joebetz> not yet. I'll read it but busy now. be back in a bit.
16:06:28 <MarcelineVQ> muaahaha
16:06:51 <dmj`> dropWhile True
16:07:05 <MarcelineVQ> morelike filterM  doh hoho
16:07:32 <dmj`> (const True)* :)
16:11:00 <sqooq> can someone explain the concept of state, in the haskell sense, pls/
16:11:08 <sqooq> I literally don't know what state is AT ALL
16:11:15 <sqooq> I never came from imperative
16:12:45 <mozzarella> are you familiar with OOP?
16:13:52 <EvanR> "state" is used in several different ways around town
16:13:59 <EvanR> haskell or not
16:14:07 <kadoban> sqooq: Any particular usage in context you are confused by?
16:14:49 <kadoban> In general it's just ... information you carry around that may be "updated" in some sense. Something like that.
16:20:25 <sqooq> mozzarella, yes but not really
16:20:43 <sqooq> kadoban, ok. I guess I understand that much but like. I'm still just confused in general.
16:21:39 <shiona> The way I think about it is that functions that share a state take an extra parameter and always return the state in addition to the possible "actual" return value.
16:22:41 <sqooq> ugh huh
16:22:42 <shiona> This extra parameter may actually be just a parameter and an extra return value (using tuples) or hidden away by using monads
16:23:01 <sqooq> ok
16:23:17 <parsnip> simply, it's like stuff besides input and output of pure function
16:23:24 <sqooq> can I somehow map a function that takes a parameter across a list, but have every new function use the result of the last one as a parameter?
16:23:44 <glguy> :t scanl
16:23:46 <dmj`> scanl?
16:23:47 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
16:24:26 <sqooq> what's the b?
16:25:28 <wedify> sqooq: the second one? it's the initial "last value"
16:25:40 <ReinH> The type of the output of the function
16:26:07 <ReinH> > scanl f [a,b,c]
16:26:10 <lambdabot>  error:
16:26:11 <lambdabot>      • Could not deduce (FromExpr [Expr]) arising from a use of ‘f’
16:26:11 <lambdabot>        from the context: Show a
16:26:22 <sqooq> wedify, oooh nice. Thanks.
16:26:33 <sqooq> How does the State type play into this
16:26:43 <ReinH> > scanl f z [a,b,c])
16:26:44 <sqooq> or I make my function take it explicitly?
16:26:48 <lambdabot>  <hint>:1:18: error: parse error on input ‘)’
16:26:58 <ReinH> sqooq: Why do you think State plays into this?
16:27:00 <ReinH> > scanl f z [a,b,c]
16:27:04 <lambdabot>  [z,f z a,f (f z a) b,f (f (f z a) b) c]
16:28:39 <sqooq> ReinH, o idk, I figured it didn't. Idk if it's cleaner or something to use it instead of scanl somehow.
16:28:51 <ReinH> Depends on what you're actually doing?
16:29:00 <sqooq> Circular buffer
16:29:08 <sqooq> across computation
16:29:48 <sqooq> it's tricky though because I have several functions that need to work together
16:30:09 <sqooq> but I only have one final fmap (or what y'all offered as scanl)
16:30:21 <sqooq> but anyways this at least helps
16:30:22 <sqooq> thanks.
16:30:52 <ReinH> fmap and scanl are pretty different
16:31:46 <sqooq> I know.. I'm saying I have several functions that should become one final function, but those functions individually may require state or may not, but they should somehow compose together into a final function
16:32:06 <sqooq> then I use I guess scanl, fmap, or something idk, to actually apply them to values in sequence
16:34:57 <ReinH> It's hard to say without seeing some code.
16:36:33 <wedify> sqooq: consider 'let x=3 in (x+1)+x' and 'x:=3;(x++)+x'. in the first one we can use simple substitution, wherever you see x put 3. in the second one we can't because the '++' modifies the x so the second use of it is actually 4 instead of 3. the first example is pure because we can simply substitute a value wherever we see a variable. the second is stateful because we have to follow the code to know what a given variable is
16:37:20 <wedify> haskell doesn't really have state. we can simulate it using monads
16:37:53 <wedify> dunno if that makes sense
16:37:59 <sqooq> it does
16:38:12 <sqooq> so I think I should state monadify my code
16:38:20 <sqooq> whoever suggested that days ago was probably right
16:38:30 <sqooq> because right now I'm sort of naively using ST without knowing how it works
16:38:46 <sqooq> but I figure since I'm passing the variable around anyway, that this could be more pure
16:38:53 <sqooq> which I figured was what `State` was
16:48:26 <wedify> sqooq: can you post code? it's hard to give advice about whether to use the state monad or otherwise without seeing some
16:52:01 <sqooq> wtf
16:52:09 <sqooq> so many joins
16:52:12 <sqooq> all at once
16:52:52 <Axman6> matrix.org split
16:53:07 <nobodi> what's that
16:53:10 <glguy> It's the matrix.org IRC bridge. It's primary purpose is to test an IRC client's handling of join/part floods
16:53:21 <Axman6> heh
16:53:22 * Clint claps.
16:53:31 <Axman6> matrix is actually pretty cool
16:53:41 <sqooq> wedify, http://lpaste.net/361448
16:54:03 <kakashiAL> if you have something like this: foo (x:_) = x   <---you cant write it like this: foo x:_ = x  because in haskell, it will know that you define a function, and they have priority over everything and it will be left associated, correct?
16:55:31 <nobodi> for a guy coming from R, is learning haskell difficult?
16:55:59 <Axman6> you'll probably have to forget a lot of what you know
16:56:03 <kakashiAL> nobodi: it does not care where you come from, haskell is color blind
16:56:10 <kakashiAL> nobodi: but you have to work for it
16:56:48 <nobodi> kakashiAL: learn you a haskell for great good, is a good place to start?
16:56:56 <[Leary]> I don't know, Haskell seems pretty fond of mathematicians.
16:57:01 <[Leary]> And vice versa.
16:57:51 <kakashiAL> nobodi: take everything what you get, so yes it is, but I am also a haskeel noob, so I have many sources and read everything about a topic to get as much view about a topic as possible
16:58:04 <kakashiAL> if I dont understand something I ask
16:58:36 <nobodi> cool thanks
16:58:45 <kakashiAL> nobodi: but the most important thing is setup your work environem, which means install haskell and your IDE (I use atom and the plugins)
16:59:07 <kakashiAL> nobodi: after that you start simple (I would recommend to document stuff in your own words)
16:59:35 <nobodi> im sure emacs has some packages for haskell
16:59:58 <kakashiAL> nobodi: emacs is still a thing :P
17:00:13 <kakashiAL> just kidding, I use vim and atom(with the vim plugin)
17:00:43 <nobodi> kakashiAL: emacs + evil for me
17:01:06 <nobodi> kakashiAL: need auctex, its too good
17:01:18 <nobodi> kakashiAL: and org mode
17:02:13 <kakashiAL> nobodi: I use plain latex
17:02:36 <kakashiAL> big difference between latex and auctex?
17:03:32 <nobodi> kakashiAL: auctex is just a package for emacs, it contains a wealth of features for working with latex files
17:18:29 <iqubic> So I need a random number generator in Haskell now.
17:19:33 <iqubic> Preferably something that doesn't touch IO (i.e. is escapable), but I can make that work.
17:20:23 <iqubic> Ideally I want "RandomNumber :: Int -> Int -> Int" Which generates a number within the bounds given
17:20:46 <iqubic> but I suppose I can make it work if the output has to be IO Int.
17:21:20 <iqubic> is it safe to run a random number generator, get an IO a, and then call unsafePerformIO?
17:22:58 <nisstyre> why would you do that?
17:23:17 <nisstyre> you can use a pure PRNG too
17:23:21 <nisstyre> you just have to seed it
17:23:36 <ReinH> nobodi: emacs has the best haskell interface imo, although a properly working haskell-ide-engine in VS Code might change my mind.
17:24:31 <nisstyre> also what do you mean by "escapable"? Do you mean you can hold the state of the RNG somewhere?
17:24:36 <nisstyre> because you can do that without IO
17:24:37 <ReinH> I've used pretty much everything I can find for most editors, including Leksah.
17:25:11 <ReinH> iqubic: No, it is not safe to use unsafePerformIO for that. It's right there in the name.
17:25:36 <ReinH> But you also don't need IO. You can generate a StdGen and then work with it in a number of ways.
17:26:16 <nisstyre> the only time I've ever used unsafePerformIO it was totally unnecessary and just a hack to make something look more elegant (I believe it was checking the filetype of something)
17:26:22 <EvanR> randomNumber :: Int -> Int -> Int
17:26:57 <ReinH> For less to more abstracted: you can pass it around, you can put it in State, you can use RandT, you can hide your implementation behind the MonadRandom class.
17:27:00 <EvanR> randomNumber a b = a
17:27:09 <ReinH> s/For/From
17:27:11 <wedify> sqooq: you can change 'runTest' to 'scanl f 0 [0..5]'. where f st x = grab (onePole st 0.9 0.1 $ ltos [1..6]) x
17:27:26 <EvanR> assuming a < b
17:27:53 <wedify> sqooq: i don't think you need the ST monad
17:28:00 <iqubic> nisstyre: I mean escapable as in, I can use runST or runIO or something to get rid of the Wrapper.
17:28:29 <nisstyre> iqubic: ok, I wouldn't really think of it as "escaping" from anything then
17:28:30 <EvanR> iqubic: do you understand how your randomNumber pure function makes no sense
17:28:38 <iqubic> Yeah.
17:28:51 <iqubic> It breaks referential transparency
17:29:02 <EvanR> its breaks the concept of a function
17:29:09 <iqubic> It does?
17:29:13 <ReinH> With the MonadRandom package, you can write die :: (RandomGen g) => Rand g Int; die = getRandomR (1, 6)
17:29:16 <nobodi> ReinH: thanks, im thinking of using haskell for ML
17:29:32 <EvanR> yes since when can a function have a different result each time you apply it
17:30:08 <ReinH> nobodi: Haskell is a good language for ML in principle. The main disadvantage a lack of robust libraries.
17:30:08 <iqubic> EvanR: That's what I said with breaking referential transparency.
17:30:34 <iqubic> You should always be able to replace a call to a function with the value on the rhs.
17:30:36 <EvanR> "referential transparency" is a really long and misdirected way to explain why its wrong
17:30:39 <ReinH> Although Haskell is improving in that regard
17:30:58 <kakashiAL> (x : xs) deconstructs a list, if you use it as a function argument. My question is can you use that notation to deconstruct a function without using that in a function or does it only make sense to use it as an argument ?:)
17:31:03 <ReinH> nobodi: You might find the HLearn paper interesting https://izbicki.me/public/papers/tfp2013-hlearn-a-machine-learning-library-for-haskell.pdf
17:31:10 <nobodi> ReinH: honestly that is my main concern, im semi comfortable with python and R which both seem to have some strong libraries for thi type of work
17:31:24 <iqubic> ReinH: do you use emacs to write haskell code?
17:31:28 <ReinH> kakashiAL: If you're asking whether you can pattern match on functions, the answer is no.
17:31:28 <EvanR> iqubic: shorter, it wouldnt be a pure function or if thats redundant, it wouldnt even be a function
17:31:33 <ReinH> iqubic: yes
17:31:48 <iqubic> ReinH: What does your set-up look like?
17:31:59 <kakashiAL> ReinH: I mean can you use (x : xs) alone, outside from a function defintion
17:32:03 <ReinH> iqubic: Spacemacs with the haskell layer enabled and a small amount of config
17:32:10 <EvanR> iqubic: but in shaders, random numbers are used pretty often despite the shader program effectively being a pure function
17:32:16 <ReinH> mostly just enabling intero
17:32:42 <iqubic> What sort of info do you have in the company drop down?
17:32:54 <ReinH> kakashiAL: You can use patterns anywhere that desugars into case statements, including the lhs of function definitions, let bindings, and case statements themselves
17:33:09 <ReinH> There's a complete list in the report somewhere, one sec
17:33:21 <wedify> kakashitAL: you  can use a case expression to deconstruct a list inside of a function. eg 'f l = case l of (x:xs) -> ...'. is this what you mean?
17:33:33 <nisstyre> EvanR: wouldn't a shader be pure with respect to the state of any of the other pixels on your screen? (since the whole point is that it runs in parallel)
17:33:35 <wedify> er, whoops kakashiAL
17:33:58 <nisstyre> (i.e. it won't depend on the state of other pixels)
17:34:11 <iqubic> ReinH: If you type "fil" does company tell you that you can complete that as "filter"?
17:36:22 <kakashiAL> ReinH: I guess you did not understand what I mean: look at this (x : xs) <---I only use this if I define a function
17:36:43 <ReinH> kakashiAL: Ok...
17:37:04 <kakashiAL> ReinH: my question is can you use (x : xs) as an operator or does (x : xs) only make sense if you define a function and want to deconstruct a list?
17:37:22 <ReinH> What do you mean by "use (x : xs) as an operator"?
17:37:31 <ReinH> (:) is an operator
17:37:46 <iqubic> Where are you trying to (x : xs?)
17:37:46 <ReinH> (:) is a data constructor, which means that it is a function
17:38:29 <iqubic> Do intero and ghc-mod work together?
17:38:49 <ReinH> > 1 : []
17:38:52 <lambdabot>  [1]
17:38:54 <ReinH> I just used (:) as an operator.
17:39:49 <iqubic> > 1 : (2 : (3 : []))
17:39:53 <lambdabot>  [1,2,3]
17:39:55 <iqubic> I can use it thrice
17:40:38 <iqubic> But that is the (:) being thrice
17:40:53 <ReinH> > foldr (:) [] [1..] -- I can use it forever
17:40:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:41:08 <glguy> (being a data constructor isn't sufficient for being a function)
17:41:20 <wedify> kakashiAL: '(x : xs)' can be a pattern or an expression. if you give it as a pattern you can use it to descontruct lists, otherwise, as an expression, it creates a list.
17:41:45 <iqubic> How do you foldr with an infinite list? You can't start with the right most element if that doesn't exist
17:42:25 <EvanR> it doesnt start with the rightmost element
17:42:26 <ReinH> glguy: fair point
17:42:49 <iqubic> What does it do? Start with the head and fold to the right?
17:42:58 <EvanR> it does this
17:43:00 <EvanR> @src foldr
17:43:00 <lambdabot> foldr f z []     = z
17:43:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:43:05 <iqubic> I see.
17:43:06 <ReinH> @iqubic https://stackoverflow.com/a/24370977/2225384
17:43:06 <lambdabot> Unknown command, try @list
17:43:10 <ReinH> Sorry
17:43:57 <ReinH> foldr *associates* to the right. It doesn't start on the right.
17:44:03 <ReinH> > foldr f z [a,b,c]
17:44:08 <lambdabot>  f a (f b (f c z))
17:44:17 <sqooq> wedify, I want it to be very generalized though so I may have something that is in essence "sine' 200 + onePole 0.9 0.1 (sine' 300)"
17:44:29 <sqooq> I guess that's not a problem
17:44:34 <sqooq> it can still take the state
17:44:47 <iqubic> > foldl f z [a,b,c]
17:44:48 <sqooq> although it gets even trickier, some functions have a delay of longer than 1
17:44:51 <lambdabot>  f (f (f z a) b) c
17:45:00 <iqubic> Oh, I se how that works.
17:45:01 <glguy> > let (!) = True in (!) && (!) -- being an operator isn't enough sufficient for being a function :)
17:45:05 <lambdabot>  True
17:51:31 <kakashiAL> wedify: can you show what you mean with that
17:53:26 <yushyin> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17 (Patterns appear in lambda abstractions, function definitions, pattern bindings, list comprehensions, do expressions, and case expressions.)
17:56:51 * hackage accelerate-llvm-ptx 1.1.0.1 - Accelerate backend for NVIDIA GPUs  https://hackage.haskell.org/package/accelerate-llvm-ptx-1.1.0.1 (TrevorMcDonell)
17:57:26 <wedify> kakashiAL: i'm not sure what you mean. consider 'f (x:xs) = (x:xs)'. on the left the '(x:xs)' is a pattern and on the right it is an expression
17:58:05 <kakashiAL> wedify: at the moment, you used this so called pattern (x : xs) in a function defintion
17:58:28 <kakashiAL> wedify: is it possible to use (x : xs) outside a function defintion?
17:58:35 <wedify> no
17:58:54 <wedify> both patterns and expressions have to occur inside a function definition
18:01:03 <glguy> You can use (x : xs) outside of a function declaration like this top level value declaration:   x : xs = [1..10]
18:01:54 <wedify> glguy: oh wow. i didn't know you could do something like that
18:02:37 <jle`> @let 5 = 9
18:02:41 <lambdabot>  Defined.
18:02:44 <jle`> patterns are neat
18:02:54 <iqubic> > 5 + 5
18:02:57 <lambdabot>  10
18:03:12 <iqubic> > let 5 = 9 in 5 + 5
18:03:17 <lambdabot>  10
18:03:24 <iqubic> That stinks
18:03:35 <jle`> iqubic: '5' is a pattern
18:03:46 <iqubic> glguy: What does that top level declaration do?
18:03:51 <jle`> so <pat> = <thing> is allowed at the top level
18:03:53 <cawfee> nice
18:03:59 <jle`> iqubic: it's the same as, say, (x,y) = (5,6)
18:04:06 <jle`> @let (foo1,foo2) = (6,7)
18:04:07 <kakashiAL> wedify: I dont agree that ALL expression have to occur inside a function, I mean if you use a constructor lile [1 .. 42]  <---you have an expression that is not in a function, or what do you mean?
18:04:09 <lambdabot>  Defined.
18:04:12 <jle`> > foo1 + foo2
18:04:16 <cawfee> arabic digits are nothing more than mere symbols
18:04:17 <lambdabot>  13
18:04:23 <cawfee> you could attach your own meaning to those
18:04:29 <cawfee> at your own risk
18:04:29 <jle`> cawfee: it's actually parsed differently than operators/symbols
18:04:36 <jle`> 5 as a pattern is syntactic sugar
18:04:40 <jle`> for x | x == 5 =
18:05:18 <verement> > let (5, x) = (9, 2) in x
18:05:21 <iqubic> kakashiAL: [1..42] is an expression, and in can go anywhere other expressions can.
18:05:23 <lambdabot>  *Exception: <interactive>:3:5-19: Irrefutable pattern failed for pattern (5, x)
18:05:37 <jle`> 5 = (anything) is a failed pattern match for anything other than 5
18:05:59 <jle`> it's just that top level pattern matches are all lazy
18:06:10 <kakashiAL> iqubic: yes, because every expression can be seen as a value
18:06:11 <jle`> so they don't throw any exceptions until you try to evaluate any 'bound' variables
18:06:21 <jle`> but, 5 = ... doesn't bind any variables
18:06:27 <jle`> so it'll never be exposed as a fraud
18:06:34 <wedify> kakashiAL: if you're using the interpreter you can give an expression outside of a function. but if you're compiling all expressions must be inside a function. compiling was what i was thinking of
18:07:29 <kakashiAL> wedify: you mean if I just tpe [1, 2, 3] in a file, that is not stored in a variable or used in a function, the compiler will throw an error?
18:07:52 * hackage fast-arithmetic 0.1.1.3 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.1.1.3 (vmchale)
18:08:10 <wedify> yep
18:08:21 <jle`> kakashiAL: a haskell source file is a list of declarations
18:08:28 <jle`> [1,2,3] on a line is not a declaration
18:08:57 <iqubic> kakashiAL: Half the things you asking can be verified by testing it on your own.
18:09:13 <kakashiAL> jle`: so a haskell file/ compiler only allows declaration, right?
18:09:25 <jle`> you can have things that aren't declarations in a haskell source file
18:09:38 <jle`> but a haskell source file (a module) is a collection of declarations
18:09:40 <jle`> that's what it "is"
18:09:52 * hackage hscurses-fish-ex 1.3.2 - hscurses swimming fish example  https://hackage.haskell.org/package/hscurses-fish-ex-1.3.2 (DinoMorelli)
18:09:54 <iqubic> is an import a declaration?
18:10:04 <kakashiAL> iqubic: test it :P
18:10:07 <jle`> https://www.haskell.org/onlinereport/haskell2010/haskellch1.html#x6-100001.1 (the first couple paragraphs of the language spec) are helpful :)
18:10:48 <kakashiAL> jle`: so is that what wedify not correct?
18:10:50 <jle`> iqubic: good question
18:10:52 <jle`> it's not
18:11:24 <jle`> kakashiAL: [1,2,3] is an expression (in one way of interpreting it), and so can be used wherever expressions are expected
18:11:33 <jle`> kakashiAL: declarations often use expressions
18:11:38 <jle`> for example, foo = [1,2,3]
18:11:45 <jle`> ^ that's a declaration (of foo) that uses an expression ([1,2,3])
18:12:03 <kakashiAL> kakashiAL | wedify: you mean if I just tpe [1, 2, 3] in a file, that is not stored in a variable or used in a function, the compiler will throw an error?
18:12:09 <wedify> yes
18:12:24 <jle`> iqubic: actually sorry, they're 'impdecls', so i guess they're declarations? :o
18:12:29 <jle`> kakashiAL: yes that is correct
18:12:34 <jle`> source files have expressions in them
18:12:42 <jle`> expressions are useful because tehy help us write our declarations
18:13:26 <jle`> kakashiAL: a haskell file is allowed to have non-declarations of course; a file of nothing except declarations would be uninteresting
18:14:04 <jle`> but the file itself contains just a collection of declarations
18:14:17 <jle`> in these declarations we usually use expressions
18:15:12 <jle`> kakashiAL: you can think of a haskell source file as a list of declarations, a list of definitions of what things are, in a declarative/pure way
18:15:54 <jle`> this is different from a source file for a language like python or ruby -- a python/ruby source file is a 'script' -- it's a list of *statements*
18:15:58 <kakashiAL> jle`: correct, even the main is a declaration, but I didnt know that you cant use an expression and get an error if you try to compile it
18:16:00 <jle`> a list of actions to perform sequentially
18:16:31 <dmj`> Is there any way to encode a json object preserving the order in which the elements were defined in Haskell. fromList for Map and HashMap change the order, and [(k,v)] encodes as an array of arrays
18:17:30 <jle`> kakashiAL: i mean you can imagine it as the most sensible grammar; there isn't any reason to add expressions as a thing to expect
18:17:43 <dmj`> encode $ M.fromList [(“b”,”2”),(“a”,”1”)], want this to be {‘b’:2,’a’:1}
18:18:07 <jle`> kakashiAL: i think you might be holding onto some influence from interpreted languages/scripts where a source file is a sequence of statements, and also for some reason expressions can themselves be statements
18:18:10 <jle`> gross
18:19:47 <kakashiAL> jle`: I see...haskell will see my expression and think "hey, you use that expression just for fun, that is not used somewhere, thats stupid" use it in a declaration
18:20:08 <jle`> kakashiAL: it's more like haskell will interpret your file as a list of declarations
18:20:15 <jle`> and if you have just [1,2,3], that's not a declaration
18:20:19 <jle`> haskell will be "what is this?"
18:20:31 <jle`> you might as well put a bunch of nonsense symbols :)
18:20:34 <kakashiAL> jle`: you just argument with the defintion, give it some soul :)
18:21:01 <kakashiAL> jle`: my vivid explaination make it more grappable :)
18:21:02 <jle`> dmj`: that might be tricky because all json encodings go through hashmap
18:21:08 <jle`> in aeson
18:21:57 <jle`> i think it's because strict json quotients over object item order
18:22:40 <dmj`> yea :/ emphasis on *any*way possible. Could make a binary instance for a newtype on [(k,v)] I guess
18:23:05 <jle`> i mean you can directly write a [(k,v)] -> String/ByteString function
18:23:26 <EvanR> where quotient means, your code has a probability of being wrong if you depend on ordering
18:23:32 <EvanR> silent failure
18:23:46 <EvanR> what kind of quotient is this
18:24:24 <ReinH> The usual kind. :p
18:24:31 <jle`> quotient in the sense of the equivalency classes of json objects being defined modulu item order
18:24:43 <jle`> modulu, dark lord of algebra
18:25:39 <iqubic> Isn't it modulus?
18:26:00 <jle`> i meant to write modulo heh
18:27:12 <EvanR> equivalence meaning, js will randomly substitute them for each other
18:27:22 <EvanR> and you can observe the difference
18:27:26 <EvanR> what kind of equivalence is this
18:27:54 <iqubic> jle`: So did I. :)
18:28:02 <EvanR> quotient is loftily hiding some practical realities
18:28:31 <jle`> well we aren't quite talking about js
18:28:36 <jle`> just json :)
18:28:37 <ReinH> The usual kind.
18:28:52 <jle`> js definitely differentiates in an observable way
18:29:49 <jle`> but json can't
18:30:13 <EvanR> ?_?
18:30:17 <jle`> "{'a':1,'b':2}" and "{'b':2,'a':1}" have to be interpreted as identical json objects
18:30:22 <jle`> in every observable way
18:30:37 <EvanR> they do?
18:30:52 <jle`> https://www.json.org/
18:31:31 <EvanR> no programming language abides by that
18:31:47 <jle`> aeson abides by this property
18:32:29 <jle`> and it's not really a property of programming languages, it's a property of whatever json library you're using
18:32:45 <jle`> but aeson in particular will not let you distinguish between the two while parsing
18:32:51 <EvanR> haskell is different for not having a built in "object"
18:33:06 <EvanR> and they happened to use unordered containers
18:33:12 <EvanR> for performance
18:33:20 <jle`> other languages might have containers where order is observable
18:33:31 <jle`> but the json library is what enforces this equivalence
18:33:42 <EvanR> enforces?
18:33:44 <jle`> the library you use might normalize order before giving you an object
18:33:46 <qmm> i am using a library which is giving me a type of [Foo 1.12, Foo 1.34, Foo 0.34], but there is no Ord instance for Foo. it's obvious to me that these numbers can be ordered. what should i be doing to define an instance Ord Foo?
18:33:56 <EvanR> like randomly rearranging them so you sometimes fail and have to stop observing the order?
18:34:08 <EvanR> in reality, they just put them in whatever order they came in
18:34:13 <qmm> "Instances of Ord can be derived for any user-defined datatype whose constituent types are in Ord."
18:34:20 <jle`> EvanR: or always giving them to you in a deterministic order
18:34:33 <iqubic> qmm: You can define your own Ord type.
18:34:37 <EvanR> i dont see how doing that enforces an equivalence
18:34:45 <iqubic> instance Ord Foo where:
18:34:54 <EvanR> encode decode still dont match
18:35:28 <jle`> encode/decode never really has to match
18:35:39 <jle`> the spec even says that whitespace is ignored
18:35:57 <jle`> so you aren't allowed to observe whitespace differences either
18:36:20 <EvanR> what has to happen for quotient to work as an abstraction is you need to not observe an ordering, which exists. extra processing with no type system cant stop you
18:36:35 <kadoban> qmm: Is this for an executable or a library? If it's a library, you usually want to be wary of creating orphan instances like this.
18:37:08 <kadoban> But, does it give you the ability to "unwrap" or something? You're going to have to have some way to get at the thing so you can actually create the Ord instance.
18:37:23 <qmm> kadoban: it's a library
18:38:27 <kadoban> qmm: Then you have a somewhat more annoying problem. Can you change the upstream library? Submit a PR or something?
18:38:35 <jle`> qmm: well, what do you actually want to do?
18:38:45 <jle`> if you want to write an Ord instance:
18:38:47 <jle`> 1) Don't
18:38:49 <jle`> 2) Why?
18:39:16 <iqubic> Why do you want an Ord instance>
18:39:24 <qmm> i don't care about "Foo". i really care about the numbers and i want to sort them
18:39:32 <jle`> qmm: in a list?
18:39:35 <jle`> then you can just use sortBy
18:39:49 <jle`> :t \f -> sortBy (comparing f)
18:39:51 <lambdabot> Ord a => (b -> a) -> [b] -> [b]
18:40:11 <kadoban> qmm: Or just ... make them not "Foo" anymore first?
18:40:15 <jle`> > sortBy (comparing length) ["hello","abc","abcd","4"]
18:40:20 <lambdabot>  ["4","abc","abcd","hello"]
18:40:51 * hackage skylighting 0.5.1 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.5.1 (JohnMacFarlane)
18:41:04 <qmm> kadoban: how to make them not Foo anymore?
18:41:11 <iqubic> sortBy (comparing (unwrap foo)) will sort the list of foo the way you want it too.
18:41:23 <iqubic> qmm, that depends on the library in question.
18:41:58 <kadoban> qmm: Depends what Foo is. I assume there's some unwrapping function?
18:41:59 <iqubic> unwrap is not an existing function, but whatever function has type of Foo a -> a
18:42:12 * ReinH whispers StandaloneDeriving
18:42:24 <jle`> shoo shoo
18:42:42 <jle`> :)
18:42:43 <ReinH> Join the dark side. We have cake.
18:42:46 <kadoban> ReinH: Sounds like this is for a library, so ... orphan instance.
18:43:31 <iqubic> kadoban: It wouldn't be a well designed library if it lacked an unwrapping function.
18:43:52 <iqubic> qmm: What library are you trying to use here?
18:44:07 <jle`> i mean, there might not be an unwrapping function, and the type could be abstract
18:44:17 <jle`> but qmm seems to imply that you can observe the Int
18:44:21 <jle`> *number
18:44:25 <iqubic> Yes, but then sorting it might be impossible.
18:45:05 <iqubic> if you can pattern match on Foo, than that would be all you need for a sort of Foo a.
18:45:15 <iqubic> I think.
18:45:16 <ReinH> If it's a newtype then unsafeCoerce it >:)
18:45:25 <iqubic> is that safe here?
18:45:30 <glguy> about 15 more messages that we needed while we waiting for qmm to respond as to what Foo is :-p
18:45:30 <iqubic> Sounds unsafe.
18:45:39 <iqubic> lol.
18:45:51 <ReinH> It's safe if it's a newtype, not that you should actually do it.
18:46:12 <iqubic> I see.
18:46:13 <jle`> sortBy (comparing unsafeCoerce)
18:46:17 <jle`> what can go wrong
18:46:29 <iqubic> You could nuke North Korea.
18:46:31 <ReinH> Yes feel the power
18:46:54 <jle`> > sortBy (comparing unsafeCoerce) ["hello","abc","abcd","4"]
18:46:55 <glguy> jle`: In that case I'd just coerce the whole list and sort
18:46:57 <lambdabot>  ["hello","abc","abcd","4"]
18:47:09 <jle`> i guess that wasn't so bad
18:47:14 <EvanR> :t unsafeCoerce unsafeCoerce unsafeCoerce
18:47:17 <lambdabot> error:
18:47:17 <lambdabot>     • Couldn't match expected type ‘(b0 -> ()) -> t’
18:47:17 <lambdabot>                   with actual type ‘()’
18:47:21 <EvanR> dang
18:47:32 <iqubic> :t unsafeCoerce
18:47:35 <lambdabot> b -> ()
18:47:36 <jle`> > unsafeCoerce "hello"
18:47:39 <lambdabot>  ()
18:47:51 <EvanR> wat
18:48:06 <jle`> i mean it's technically correct isn't it
18:48:06 <iqubic> What does unsafeCoerce even do? How is that helpful and/or unsafe?
18:48:21 <kadoban> :t unsafeCoerce
18:48:24 <lambdabot> b -> ()
18:48:24 <iqubic> @src unsafeCoerce
18:48:24 <lambdabot> Source not found. My mind is going. I can feel it.
18:48:25 <jle`> ghci> unsafeCoerce "hello" :: ()
18:48:27 <jle`> ()
18:48:31 <EvanR> thats not the usual type signature
18:48:37 <kadoban> Wait ... wtf is going on with that
18:48:42 <glguy> ?undefine
18:48:42 <lambdabot> Undefined.
18:48:49 <iqubic> I assume "unsafeCoerce x = ()"?
18:48:55 <kadoban> :t unsafeCoerce
18:48:56 <lambdabot> error: Variable not in scope: unsafeCoerce
18:49:15 <EvanR> @let unsafeCorce x = let y = y in y
18:49:18 <lambdabot>  Defined.
18:49:20 <kadoban> iqubic: It's :: a -> b, with no constraints
18:49:22 <EvanR> :t unsafeCorce
18:49:24 <lambdabot> p -> t
18:49:32 <glguy> If you guys want to play with unsafeCoerce just do it on yahb
18:49:36 <kadoban> It's pretty much just "hey, make this be this type, thanks!" which I'm sure you can guess how that's unsafe.
18:49:39 <glguy> or in GHCi locally
18:49:48 <jle`> i mean at least my 'unsafeCoerce = const ()' definition was correct
18:50:01 <EvanR> "correct"
18:50:19 <EvanR> but not very general
18:50:23 <iqubic> jle`: I also wrote the same sort of thing. I just did it with a point.
18:50:49 <iqubic> unsafeCoerce x = ()
18:50:52 * hackage eng-stemmer 0.1.0.0 - An English language stemmer (Porter2)  https://hackage.haskell.org/package/eng-stemmer-0.1.0.0 (ChrisCoffey)
18:51:02 <iqubic> I think that's right
18:51:15 <ReinH> Right?
18:51:16 <jle`> iqubic: it basically treats whatever the reference is pointing to as a value of that type, in memory
18:51:33 <EvanR> it throws the type system out the window
18:51:41 <EvanR> like c casting
18:51:49 <jle`> it's unsafe in that it relies on how GHC encodes data in memory
18:52:29 <iqubic> unsafePerformIO is also bad, but I'm not sure why.
18:52:44 <EvanR> unsafeCoerce is unsafe. unsafeInterleaveIO is safe. unsafePerformIO = ?
18:53:08 <[Leary]> Well you can use it to write unsafeCoerce iirc
18:53:22 <kakashiAL> is it somehow a convention to use _ in foo (x:_) if you dont use the tail in the function defintion?
18:53:22 * hackage eng-stemmer 0.1.0.1 - An English language stemmer (Porter2)  https://hackage.haskell.org/package/eng-stemmer-0.1.0.1 (ChrisCoffey)
18:53:39 <ReinH> kadoban: Naming an unused pattern variable _ is a convention.
18:53:46 <Axman6> unsafePeformIO breaks referential transparancy, so it's really bad
18:53:58 <kadoban> ReinH: What?
18:53:59 <qmm> it is a newtype
18:54:00 <kakashiAL> ReinH: thank you sir :)
18:54:00 <iqubic> kakashiAL: it tells the reader that the variable is uneeded.
18:54:04 <ReinH> kadoban: what?
18:54:06 <kakashiAL> iqubic: thanks
18:54:11 <kadoban> Oh, that was for not me.
18:54:15 <glguy> kakashiAL: It's more than a convention, it has special support for not binding any names at all
18:54:16 <ReinH> kadoban: oh sorry
18:54:25 <iqubic> qmm: Do you just want tell us what library and data type this is?
18:54:25 <kadoban> No worries, I just didn't see the thing you were responding to, heh.
18:54:32 <glguy> kakashiAL: That means you can use more than one of them at a time: (_ : _)
18:54:51 <kakashiAL> glguy: I dont understand your example
18:54:56 <ReinH> qmm doesn't seem to want to tell us anything :)
18:54:59 <kakashiAL> foo (_ : _) = ....?
18:55:04 <qmm> this is the only thing that has worked so far: sortBy (comparing unsafeCoerce) $ myList
18:55:06 <glguy> kakashiAL: Sure
18:55:27 <kakashiAL> glguy: what do you mean with that? how is that helpful
18:55:43 * kadoban wonders how it even guesses what to coerce to when you do (comparing unsafeCoerce)
18:55:50 <glguy> kakashiAL:  It saves you from making up a name you aren't going to use
18:56:09 <kakashiAL> glguy: I mean your (_ : _) example
18:56:10 <qmm> i don't mind
18:56:11 <qmm> https://github.com/dmjio/bittrex/blob/master/src/Bittrex/Types.hs#L454
18:56:22 <glguy> kakashiAL: That saves you from making up two names you aren't going to use
18:56:27 <qmm> i have a list of Volume
18:56:37 <iqubic> qmm: Why do you need to sort this?
18:56:49 <qmm> because it's useful to do this
18:57:04 <iqubic> Useful how?
18:57:15 <qmm> because sorting numbers is useful when making decisions
18:57:16 <ReinH> qmm: If you're going to use unsafeCoerce, which I suggested as a joke, why wouldn't you use StandaloneDeriving?
18:57:19 <[Leary]> kakashiAL: it's just a pattern that matches any nonempty list.
18:57:20 <kakashiAL> glguy: but your example makes no sense for me: foo (_ : _)  = ....  <---you define a function that should deconstruct your list, with elements that you dont want to use at all
18:57:39 <glguy> kakashiAL: (_ : _) is a pattern that only matches lists with one or more elements
18:57:47 <qmm> ReinH: i don't understand what it is. i am open to trying it out
18:58:12 <iqubic> qmm: What will you be doing with this list once it is sorted?
18:58:22 * hackage fast-arithmetic 0.1.1.4 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.1.1.4 (vmchale)
18:58:23 <kakashiAL> glguy: you mean you can write stuff like:   listIsNotEmpty (_ : _) = True ?
18:58:42 <kadoban> kakashiAL: Yep. (note you'd also have to handle the other case)
18:58:53 <qmm> iqubic: i don't see how your questions are related :(
18:59:06 <kakashiAL> kadoban: could you give me another example ?:)
19:00:30 <Axman6> qmm: is it important that you don't export things like the Volume constructor? if you did, you could use safe coercions
19:00:50 <iqubic> Axman6: This isn't his library
19:01:03 <Axman6> ah, right, lame
19:01:54 <ReinH> @src length
19:01:55 <lambdabot> Source not found. It can only be attributed to human error.
19:02:11 <qmm> iqubic: your questions are coming off as "why are you programming? why do you care to use this library at all." why are you asking why i need to sort a list of numbers?
19:02:13 <ReinH> length (_:xs) = 1 + length xs
19:03:54 <iqubic> qmm: I was just wondering if there was way to do you work without sorting the list.
19:04:10 <iqubic> Also, this is a bit more complex than just a list of Numbers.
19:04:38 <kakashiAL> ReinH: could you give me a crisp example for the pattern matching (_:_) ?:)
19:04:39 <qmm> okay. i don't have any grand plans, i'm mostly tinkering
19:04:50 <ReinH> kakashiAL: you already have one
19:05:11 <kakashiAL> ReinH: my is stupid/not realy useful :/
19:05:16 <ReinH> Sure it is
19:05:18 <ReinH> @src null
19:05:18 <lambdabot> null []    = True
19:05:18 <lambdabot> null (_:_) = False
19:05:36 <[Leary]> I find null pretty useful.
19:05:55 <Axman6> Nulls is certainly a mistake
19:06:07 <iqubic> Why not write that as "null x = length x == 0"
19:06:25 <Axman6> iqubic: how long would null [1..] take to finish?
19:06:33 <Axman6> hint, it won't
19:06:57 <iqubic> Does the pattern match version ever finish with an infinite list?
19:07:04 <[Leary]> The match is O(1). You can't really do better.
19:07:08 <Axman6> yes
19:07:26 <Axman6> it finishesd as soon as it compute what the constructor making the list is
19:08:13 <Axman6> if you can't tell if it's (:) or [] in finite time then it will also not finish, but it will finish in many many more situations than using length ever could
19:08:39 <qmm> StandAloneDeriving works nicely! thanks ReinH
19:08:41 <ReinH> iqubic: why not try it?
19:08:53 <Axman6> so, if you have let x :: [Int}; x = x, null x will never terminate because it'll just run in circles trying to figure out what the first constructor is (because there isn't ont, this value is bottom)
19:08:54 <kadoban> Even if you ignore infinite lists, it's not great if a 'null' check has to take time proportional to the length of the list. Pretty wasteful.
19:09:49 <ReinH> You could write it as length x == 0 if length returned a nat, but there's no point. That's just a rube goldberg device for writing the version with pattern matching.
19:10:25 <qmm> jle`: i was having problems trying to use map (\f -> sortBy (comparing f)) myList
19:10:43 <ReinH> qmm: why would that work?
19:11:25 <qmm> i have no clue. it was a suggestion from jle`
19:11:39 <ReinH> I doubt that was the suggestion, since it's nonsense.
19:11:39 <qmm> probably mistakenly translated
19:12:45 <ReinH> perhaps jle` meant sortBy (comparing f) myList where f :: Foo -> Double
19:13:36 <qmm> i would need to write a function that converts the Volume to a Double
19:13:50 <qmm> that makes the error messages a little more clear
19:13:52 <ReinH> Yes
19:14:13 <iqubic> that is what jle` was suggesting
19:14:18 <EvanR> newtype Volume = Volume { toDouble :: Double } ?
19:14:46 <ReinH> iqubic: yes, that is what I just said.
19:15:04 <glguy> That's what iqubic is suggesting ReinH is suggesting jle` said
19:15:33 <EvanR> i say i say who say i say
19:16:19 <hoon> having read this: https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell I'm left wondering the best way to handle parse errors within and outside of IO
19:16:56 <jle`> what kind of parse errors are we talking about
19:17:34 <hoon> well, as a for instance, just something simple: parsing hex in ascii form into a binary string
19:17:41 <jle`> also that is indeed what i was suggesting
19:17:46 <jle`> (to qmm)
19:18:04 <jle`> hoon: sounds like you could just return Maybe there?
19:18:06 <EvanR> hoon: are you intending for that to ever fail?
19:18:24 <EvanR> or is it like a quick bin "01234ff"
19:18:30 <hoon> the parsing function was originally returning Either ParseError String
19:18:55 <jle`> hoon: that sounds reasonable
19:19:32 <hoon> EvanR: quick bin?
19:19:52 <jle`> hoon: i think you just answered your own question?
19:19:54 <EvanR> if youre peppering stuff like
19:20:06 <jle`> the function that returns Either ParseError String is already a fine way to handle that :)
19:20:06 <Axman6> There's nothing wrong with Either ParseError String, unless you need to compose those functions with other things that can throw errors. Since evaluating parsers tends to be one off actions, there's isn't really a good reason to do anything more complicated than Either
19:20:25 <EvanR> bin "ff00ff" throughout the code, and not putting hex literals would never be expected, would be a bug, then Either can get in the way
19:20:40 <hoon> jle` - well, the question is I end up reading from a file or from stdin I end up with an IO (Either ParseError String)
19:20:41 <jle`> if you want a deeper answer, you'll have elaborate more on what you want to do with the result
19:20:55 <EvanR> ah yeah you really want Either
19:20:58 <jle`> hoon: an IO (Either ParseError String) is also reasonable
19:21:17 <jle`> but
19:21:27 <jle`> i guess i'm still waiting for the question
19:21:28 <EvanR> you can also write a wrapper that returns IO String, but throws IO exceptions when the pure parser returns Left
19:21:33 <hoon> based on the article and Axman6's comment, that may not be desirable?
19:21:34 <jle`> what's the question?
19:21:51 <jle`> hoon: it really depends on what you want to do with it
19:22:17 <hoon> I guess I already got my answer
19:22:39 <EvanR> i think the best practices blog post was good for trying to eliminate one of the zillion ways people do this, but its also saying "use transformers" when thats not always proper
19:22:54 <hoon> that answer: IO (Either ParseError String) is a reasonable type
19:23:16 <jle`> IO Int is also a reasonable type -- but really in the end, it depends on what you want to do with the result
19:23:30 <iqubic> or if you like: ExceptT ParseError IO String
19:23:40 <EvanR> ;_;
19:23:43 <iqubic> It's mostly the same thing
19:23:58 <hoon> iqubic -- the claim was that ExceptT ParseError IO String is expressly rejected in the article
19:24:25 <jle`> iqubic: that's like saying that you might as well use 'Sum Int' instead of 'Int'
19:24:45 <iqubic> why was thrown out?
19:25:22 <hoon> pull it up and look at the first major bullet point ^iqubic
19:25:31 <hoon> I guess I'm hung up on that
19:25:46 <jle`> 'Sum Int' is useful if you want to take advantage of the Monoid instance
19:25:57 <jle`> but it's silly to use Sum Int instead of Int if you aren't
19:26:19 <hoon> because I, too, felt like IO (Either Err String) is not that much different than ExceptT ParseErr IO String
19:26:20 <Axman6> hoon: iqubicis not good at reading things when when it;'s obvious they should be, so be prepared for more of this :P
19:27:25 <glguy> Lucky for Axman6 that won't be read
19:27:27 <hoon> I can post some source code and you can get a feel for what I'm considering
19:27:38 <Axman6> This is why I felt confident writing it
19:27:43 <EvanR> hoon: i would write a -> Either Err String at the base level, then if you arent already using transformers for anything, respond to that error in IO by throwing an (possibly custom) IO exception
19:28:00 <EvanR> its all about what else you have going on
19:28:08 <EvanR> what jives well with your the rest of the program
19:28:11 <hoon> EvanR, i think that's what I'm doing now
19:28:25 <hoon> let me post it on lpaste -- 1 moment
19:28:41 <EvanR> since IO exceptions at your top level might be happening anyway, join the club
19:29:05 <iqubic> Why not use MonadThrow?
19:29:16 <EvanR> why use MonadThrow?
19:29:38 <hoon> have a look see here: http://lpaste.net/361450
19:29:46 <iqubic> The article suggested that as a good alternative.
19:30:02 <hoon> the bulk of the "good stuff" is down below "a2h"
19:30:13 <EvanR> i cant take the beginning of the article seriously so
19:30:28 <hoon> beyond line 97
19:31:27 <EvanR> hoon: i would use throwIO not throw there
19:31:52 <hoon> fair point, but I think in Exception.Safe they're the same thing?
19:31:58 <hoon> maybe not
19:32:04 <EvanR> :t throw
19:32:06 <lambdabot> Exception e => e -> a
19:32:09 <EvanR> :t throwIO
19:32:11 <lambdabot> Exception e => e -> IO a
19:32:33 <EvanR> throwIO have the effect of throwing now, not accidentally later
19:32:48 <EvanR> throw e throws when you evaluate it
19:32:55 <EvanR> which may be never!
19:33:09 <hoon> gotcha
19:36:02 <hoon> so as a followup question: is the reason for converting the "Left" to an exception to facilitate handling of multiple exceptions? and does that mean that my ParseError should be an instance of a particular type of exception?
19:36:51 <EvanR> all Exceptions are dynamically typed and part of the same universe
19:38:11 <hoon> so lets say that runParse throws a ParseError
19:38:15 <EvanR> your code doesn't handle the error or exception so its hard to say if theres any good reasoning
19:38:36 <hoon> haha caught me ^ EvanR, I haven't added it in yet
19:38:41 <EvanR> if you were never going to handle it, then throwing as soon as possible will save some headache
19:39:09 <EvanR> if you are going to catch it in IO for some reason, IO exceptions are convenient
19:39:45 <EvanR> if you were going to handle it in pure code and never let that exception be thrown, then the Either version is good
19:40:11 <EvanR> but since you insist on the API being an IO action, the third option has been eliminated
19:40:36 <hoon> ok
19:40:53 <hoon> so I think I'm leaning toward the catch in IO option
19:41:14 <EvanR> really
19:42:21 <EvanR> heres another way to structure it
19:42:32 <EvanR> instead of runParse :: InputSource -> IO String or IO (Either Err String)
19:42:54 <EvanR> runParse :: InputSource -> (Error -> IO a) -> (String -> IO a) -> IO a
19:43:11 <EvanR> sort of callback style
19:43:16 <hoon> yeah, I toyed with that
19:43:31 <hoon> I've been writting and rewriting this program in a number of different ways for fun
19:43:42 <hoon> hah
19:43:53 <EvanR> that requires the user (or you, or whoever) to definitely handle it
19:43:59 <hoon> just spinning my whells
19:44:00 <EvanR> and doesnt involve either
19:44:08 <hoon> fair enough
19:44:46 <EvanR> exceptions are good when you dont know if or where to handle failures
19:45:15 <hoon> I see
19:45:20 <EvanR> yet another way is to use async threads to run a computation, and youll get back and IO (Either...) when you wait for the result
19:45:50 <EvanR> where any exception whatsoever in the child is returned as a value to you
19:46:04 <hoon> huh, that's interesting
19:46:26 <EvanR> you can also do that with Control.Exception.try
19:50:33 <hoon> so, in the case where the parse result goes to stdout, I was planning on caching intermediate parse results to a temporary file
19:50:50 <hoon> if the result of all of the input is successful, then the temp file is read and dumped to stdout
19:51:55 <hoon> with the code as it was, I had to explicitly catch the exception
19:52:56 <EvanR> what happens if all the input is not successful
19:53:03 <hoon> no output to stdout
19:53:34 <hoon> show exception on stderr
19:53:45 <hoon> abort with an error code?
19:53:52 <EvanR> delete the temp file ?
19:54:04 <hoon> well, I was running with withSystemTempFile
19:54:11 <hoon> which does that for me
19:54:52 <EvanR> yeah thats a bracket-like thing, it cleans up resources if the body completes or fails
19:54:58 <EvanR> good stuff
19:55:29 <EvanR> so you dont really need to catch the exception
19:55:43 <hoon> right
19:55:46 <EvanR> parse failure will result in stderr output and resource cleanup
19:55:52 <hoon> in the other case, writing to output file
19:55:56 <hoon> I would have to catch
19:56:13 <EvanR> why
19:56:31 <EvanR> to delete the output file?
19:56:57 <hoon> yes
19:57:14 <EvanR> if you think there wont be any exceptions because there wont be any parse failures...
19:57:45 <EvanR> if youre worried about dangling output files you will need your own bracket anyway
19:57:52 <EvanR> or onException
19:58:03 <hoon> yeah
19:58:45 <hoon> well, I assume there will be parse failures, in the sense that I intend to handle them eventually
19:59:10 <EvanR> in case there are none, you still have other IO exceptions
19:59:15 <hoon> right
19:59:21 <hoon> so I was coming to this question
19:59:41 <hoon> how would I handle both IO Exceptions AND my ParseError exception
19:59:49 <EvanR> onException does that
19:59:50 <hoon> If I catch on ::SomeException
19:59:54 <hoon> oh, it would?
20:00:01 <EvanR> it doesnt care what exception was thrown
20:00:37 <EvanR> same as bracket
20:00:42 <EvanR> and finally
20:01:03 <hoon> oh, ok
20:01:26 <hoon> I see that
20:01:33 <EvanR> to catch two different exceptions and care about them, theres catches
20:01:58 <EvanR> i know all this because the docs exist and are good :)
20:02:11 <hoon> I've been using "try" and couldn't see how to make that work without try (try (try (...doThingException)...)))
20:02:23 <hoon> I see
20:02:30 <EvanR> try or catch is when you care about the exception itself
20:03:00 <glguy> try is for when you don't want to mask asynchronous exceptions while you handle the exceptional case, catch is for when you do
20:03:00 <hoon> I'm not entirely sure what you mean by "the exception itself"
20:03:19 <EvanR> the exception value
20:03:30 <hoon> oh, ok
20:03:44 <hoon> yeah, not just that it happened, but its contents, too
20:03:54 <EvanR> if youre just going to crash and print it out, then its not really necessary to mess with it
20:03:59 <EvanR> youd want to rethrow
20:04:05 <hoon> right
20:04:22 * hackage xmonad-vanessa 0.1.1.5 - Custom xmonad, which builds with stack or cabal.  https://hackage.haskell.org/package/xmonad-vanessa-0.1.1.5 (vmchale)
20:04:59 <EvanR> good point, at this point you are now ready to always be wondering about async exceptions :)
20:05:02 <hoon> ok
20:05:06 <EvanR> and masking
20:05:52 * hackage xmonad-vanessa 0.1.1.6 - Custom xmonad, which builds with stack or cabal.  https://hackage.haskell.org/package/xmonad-vanessa-0.1.1.6 (vmchale)
20:05:58 <hoon> i'll be honest, I've seen the distinction and have completely disregarded it for now
20:06:07 <hoon> seems to me I just need to sit and read
20:06:37 <hoon> but I tend to never actually "do" anything with code if I fall down the documentation rabbit hole very deep
20:07:13 <EvanR> now youre talking the EvanR school
20:07:50 <hoon> I tried to pick up haskell several years ago
20:08:11 <hoon> and I got lost somewhere deep in category theory, thinking I might have understood Monads
20:08:33 <hoon> and then after weeks of reading never managed to make even a tiny little useful application
20:08:49 <Welkin> yeah, don't do that
20:09:04 <Welkin> that seems like one of the biggest misconceptions that we need to eliminate
20:09:11 <hoon> having put Haskell down for a long time, I came back and opt'ed for the opposite, seems to be going much better
20:09:15 <Welkin> haskell has nothing to do with category theory, and learning it won't help you one single bit
20:09:24 <hoon> but maybe my pendulum swung a bit too far the other way
20:09:32 <hoon> as I'm not reading documentation well enough
20:09:37 <Welkin> you could be an expert in category theory and be useless at programming haskell
20:09:54 <hoon> Welkin -- yeah, I see that now
20:10:02 <EvanR> esoteric but powerful ideas may help you in the future
20:10:08 <EvanR> in a wildly different context
20:10:31 <hoon> part of the "motive" for getting into the category theory side is the terminology
20:10:41 <Welkin> that's where it ends
20:10:41 <EvanR> :(
20:10:50 <EvanR> CT has way too much terminology
20:10:57 <Welkin> CT monads, functors, etc are not the same as haskell monad, functors
20:10:57 <hoon> you don't get far in haskell documentation without running into Monoids, Functors, monads...tec etc
20:10:58 <EvanR> relative to theorems
20:11:09 <MarcelineVQ> it does?
20:11:11 <Welkin> monad is just a typeclass
20:11:14 <Welkin> plain and simple
20:11:47 <EvanR> unless you count "X is a Y" where the proof is expanding the definitions, is a theorem
20:12:15 <hoon> and you come across all these foreign terms and its very tempting to try to "understand" them rather than use them
20:12:36 <Welkin> I have seen this parallel while learning about music: history, music theory, how to play the piano, how to compose
20:12:43 * hoon steps away momentarily
20:12:53 <Welkin> I had the misconception that, if I learned music theory well enough, I could write any song, and play the piano with ease
20:12:56 <Welkin> that is dead wrong
20:13:20 <Welkin> they are completely different skillsets
20:15:09 <EvanR> you could come at it from both directions
20:15:54 <Welkin> then I spoke with people who have dedicated their lives to music and got some good advice
20:16:14 <EvanR> like the english channel tunnel
20:16:24 <Welkin> composing has nothing to do with music theory, but it may help you understand why things are the way they are
20:16:58 <Welkin> I feel that category theory (and computer science in general) is the same way in relation to programming
20:17:19 <Welkin> another parallel is human language
20:17:59 <Welkin> grammar is like the theory for language; it's based on observation of how natural language works (but is just an approximation)
20:18:08 <Welkin> it is not in itself the language
20:18:18 <Welkin> so learning the grammar for a language won't make you better at speaking the language
20:18:24 <Welkin> totally different skills
20:18:49 <Welkin> native speakers of a language have no idea what the grammar is for it either
20:18:55 <Welkin> ask anyone (or yourself)
20:19:13 <EvanR> formal language vs natural language
20:19:34 <geekosaur> labguages vs. linguistics is an interesting anticorrelation
20:19:51 <geekosaur> people tend to be good at one or the other
20:28:24 <capisce> Welkin: when learning a foreign language as an adult, studying grammar can help
20:28:56 <capisce> to speed up the process
20:29:45 <capisce> maybe that's partially due to adults being more worried about making mistakes than children
20:30:39 <capisce> whereas children will just babble on and thus get continuous feedback, adults might be more likely to clam up if they're not sure how to say something
20:31:28 <capisce> maybe you should be less worried about making mistakes when programming too, as making mistakes is a valuable way to learn
20:32:09 <capisce> i.e. don't try to have a perfect idea of how your program should look in your mind before you produce any code
20:34:05 <geekosaur> actually, learning grammar is useful in becoming more proficient, but you're much better off learning the language as a whole. which is why full immersion courses are the preferred way to learn languages
20:34:07 <Welkin> I like Casey Muratori's approach, which he calls "exploratory programming" where you "do the simplest, dumbest thing that works" and don't worry about optimization or code organization until later, only if you really need it
20:34:47 <Welkin> it's like doing a rough sketch, as an artist would when composing music, or before doing a painting
20:35:00 <geekosaur> don't try to take the pieces apart to see how they work until you know how the device/language works as a whole
20:35:36 <capisce> geekosaur: yes, a balanced approach
20:35:50 <Welkin> he has also gone back to the basics, choosing C (and some asm) as his language of choice
20:36:06 <Welkin> after having programmed using all the bells and whistles of C++ for years, he now denounces them
20:36:27 <capisce> heh, he could just stick to a useful subset of C++
20:36:39 <geekosaur> which is called C
20:36:49 <geekosaur> :)
20:36:50 <capisce> no, there are useful constructs in C++ that don't exist in C
20:38:22 * hackage serverless-haskell 0.1.0 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.1.0 (AlexeyKotlyarov)
21:14:22 * hackage radixtree 0.4.0.0 -   https://hackage.haskell.org/package/radixtree-0.4.0.0 (MikeLedger)
21:29:32 <sqooq> what if I have several functions in one big function that require individual states that get passed on after the calculation of the function
21:29:38 <sqooq> so the function is being "mapped" against a list
21:30:01 <sqooq> for the first element, there is perhaps an arbitrary amount of states that need to be stored for the next element's calculation
21:31:46 <Axman6> can you give us some types?
21:31:51 * hackage fast-arithmetic 0.1.1.5 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.1.1.5 (vmchale)
21:31:55 <Axman6> I don't understand the question
21:32:24 <sqooq> I don't understand the question either
21:32:37 <EvanR> step 1: understand the question
21:32:47 <sqooq> LOL
21:32:54 <sqooq> ok
21:33:00 <sqooq> I'm going to try and like, draw this one out
21:33:05 <EvanR> not even a joke, mr feynman
21:33:06 <Axman6> step 0: understand the problem
21:33:24 <parsnip> step -1: answer the question
21:33:32 <EvanR> step -1/12
21:33:49 <parsnip> you put your left foot in
21:34:06 <Axman6> step 2: think really hard
21:34:08 <sqooq> Axman6, the problem is the audio processing concept of the delay and how to implement it in haskell cleanly. It requires state (if i understand that word correctly)
21:34:12 <Axman6> step 3: write down the answer
21:34:49 <EvanR> that sounds like a specific requirement of a delay implementation, rather than the delay concept
21:34:49 <parsnip> that worked! thank you!
21:35:13 <EvanR> delay dt f t = f (t - dt)
21:35:22 <sqooq> EvanR, no the delay concept requires passing on things
21:35:42 <sqooq> If you want to allow recursion at leas
21:35:44 <EvanR> not if the delay is a transformation of a signal, which is a function of time
21:35:52 <sqooq> and like all the useful things with delays are recursive
21:35:57 <EvanR> o_O
21:36:13 <EvanR> this is a tasteless mix of abstraction levels
21:36:13 <sqooq> EvanR, that simple definition sadly hangs whenever you try to actually use it
21:36:31 <EvanR> not if you have a base case
21:36:38 <EvanR> in your recursive construction
21:36:57 <EvanR> like, some base signal which is a constant
21:37:04 <EvanR> or given by explicit formula
21:37:08 <sqooq> EvanR, then it's like highly highly inefficient
21:37:17 <sqooq> because it recalculates everything at every time step
21:37:28 <EvanR> back to what i originall said
21:37:32 <sqooq> O(n^n!) I think
21:37:52 <EvanR> ... i dont think were thinking of the same kind of efficiencies then
21:38:04 <sqooq> idk
21:38:09 <EvanR> anyway youre asking about a particular implementation
21:38:20 <sqooq> all I know is that for a recursive delay like y(n)=x(n)+y(n-1)
21:38:30 <sqooq> even if you define a base case
21:38:34 <sqooq> for every n that is input
21:38:50 <sqooq> it calculates all the y(n-1)'s until base case
21:39:05 <sqooq> even though at the previous time step you already calculated it
21:39:08 <sqooq> aka state
21:40:04 <EvanR> y(n) = x(n) + y(n-1) isnt a delay
21:40:15 <sqooq> y(n-1) is
21:41:33 <EvanR> also your implementation might benefit from memoization, which is a technique to apply to things that are conceptually (pure) functions
21:41:44 <sqooq> isn't that state?
21:41:46 <EvanR> that may avoid any recalculation you are experiencing
21:41:50 <EvanR> no its not state
21:41:51 <sqooq> a state implementation?
21:41:53 <sqooq> o
21:42:00 <sqooq> well what I've been calling state is memoization
21:42:18 <EvanR> then state has failed its role as technical jargon
21:42:25 <EvanR> later
21:42:36 <sqooq> So how do I do memoization again?
21:43:05 <sqooq> EvanR, and memoization can go multiple steps in the past right?
21:44:56 <sqooq> Or can you explain. Like maybe I don't understand memoization, but how can it work without being aware of the later computations you know?
21:45:00 <sqooq> Like if signals are just functions
21:45:13 <sqooq> and you have this function definition that needs memeoization
21:46:30 <sqooq> How can it work without passing values on in "time" which is really just when the function gets applied again. Like the way I think about it, and which I think you want to correct in me, is that a computation at t=0 occurs and stuff happens, you pass on the stuff needed in the inner functions into computation 2, and so on.
21:46:58 <sqooq> sorry `computation 2` was meant to be `t=1`
21:47:51 * hackage bittrex 0.6.0.0 - Bindings for the Bittrex API  https://hackage.haskell.org/package/bittrex-0.6.0.0 (DavidJohnson)
21:50:28 <sqooq> is "Memo functions, Polytypically!" what I should read? Online resources have been pretty vague or lacking in detail. I have no clue how this stuff works.
21:50:33 <sqooq> I guess I'll try it thanks.
21:51:58 <wedify> sqooq: just asking out of curiosity, did you understand how your use of ST in the code you gave me didn't need the ST monad?
21:53:07 <sqooq> wedify, with scanl?
21:53:08 <wedify> i'm thinking that what you mean by state is a "carrying forward" of a value, which doesn't neccesarily have to be State or ST
21:53:12 <wedify> yeah
21:53:28 <sqooq> well yeah, but I don't know how different functions can have their own values that pass on
21:53:49 <sqooq> like what if there are two "onePole" functions that get added together, each one will need to pass on it's own values
21:53:58 <sqooq> but they're added together into a final function so
21:54:04 <sqooq> idk man i'm trying my best here
21:54:51 <wedify> no it's cool. i find it fun trying to understand what other people are asking and "helping" them
21:55:15 <wedify> i'm interested to know more about your code
21:55:37 <sqooq> sweet
21:55:43 <sqooq> most people just get frustrated and yell at me
21:55:51 <wedify> you're doing something with sound? it's a domain i'm not familiar with but it seems cool
21:55:58 <sqooq> wedify, yes
21:56:25 <wedify> so we have a trade. i can help you out and you can teach me a bit about sound.
21:56:58 <sqooq> i'm down with that, but make sure you ask questions, because I suck at helping/teaching people if they don't ask questions.
21:57:18 <sqooq> so do you understand my current dilemna
21:57:25 <sqooq> I still barely understand scanl btw
21:58:38 <sqooq> well I do, but I don't think it's the end all for my problem.
22:01:40 <wedify> sqooq: based on the little conversation that we've had i think it would be a good idea to think of how to write your functions using scanl. folds are very powerful and used a lot in haskell
22:03:59 <wedify> i don't know what the proper term for it is but with folds you have an "accumulator". i think what you're calling state is what i call an accumulator
22:04:38 <wedify> eg 'foldl (\acc x -> ...) ...' 'foldr (\x acc -> ...) ...'
22:08:20 <Axman6> sqooq: you might find this very relevant: https://www.youtube.com/watch?v=Mlbe7d90DoI&list=PLNoHgLVTxtarRJWmMAs3RSy9BbB_TGlgj&index=1
22:15:11 <jez_> Why did stack choose to go with resolvers and pin packages globally? Could stack have been implemented with per-project lockfiles of some sort, or would it not have worked as well?
22:16:25 <MarcelineVQ> jez_: https://docs.haskellstack.org/en/stable/GUIDE/#what-makes-stack-special
22:17:18 <MarcelineVQ> it's not pinned globally though, projects are free to choose their own individual resolver versions
22:18:01 <jez_> Yeah, by globally I meant that stackage kind of acts like a global lockfile for everyone using stack
22:18:25 <MarcelineVQ> hmm that doesn't sound to me like what it does
22:18:41 <jez_> really?
22:18:45 <sqooq> wedify, only thing is the accumulator can look to the past more than once in cases. like I want this to be general. Not saying folds can't handle this, I just don't know enough about them. Like it's tricky because the functions themselves have to be applied to times
22:18:53 <sqooq> like fold implies you run it once and it goes through
22:18:59 <sqooq> but all the functions are stuck at the same time
22:19:05 <sqooq> for a given time
22:19:33 <jez_> if i say "lts-10.3", then stack might know to use version 0.9.0.0, but if I say "lts-10.0" then maybe it resolves to version 0.8.0.0
22:19:55 <jez_> so somewhere there's version pinning, which is what I think of lockfiles as
22:20:11 <MarcelineVQ> it's the global part I'm not too sure about
22:20:37 <MarcelineVQ> anyway that link there describes what it does pretty well
22:21:34 <rodol> sqooq is it a fixed amount of past? Or can it be dynamic?
22:22:27 * hackage pandoc 2.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.1 (JohnMacFarlane)
22:22:58 <rodol> I'm asking because if you know for sure you wont need more than x elements in the past, and x is relatively small, you can just add that number of parameters to your function and have it shift them over by one every recursion
22:23:00 <sqooq> rodol, for now I'm ok with fixed amount, but yeah crazier synthesis techniques have dynamic delay lines, which I have literally no idea how to implement, but I haven't gotten there yet.
22:24:33 <sqooq> rodol, that feels so bad though lmao. Every function with recursion would have to be explicitly defined with these parameters. The idea with an audio library is to have some like primitives, or at least a cohesive set of functions, that you use to build higher structures. Like it would be really nice to have a specific delay function or a consistent way of dealing with delays
22:24:51 <sqooq> Axman6, thaks
22:25:09 <rodol> You can use internal cases, the parameters don't need to be visible outside of the function
22:25:29 <rodol> and i'd recommend vectors to keep the values (or lists) if its more than 2 or 3
22:26:15 <sqooq> rodol, I found Data.Sequence which seems perfect
22:26:21 <parsnip> whitespace style guide for [x,y..z]?
22:26:23 <sqooq> since delays you basically take from the front and add to the back
22:26:30 <rodol> not sure what the syntax is called but its a let with pattern matching
22:26:33 <sqooq> with Data.Sequence, those actions are O(1) time
22:27:18 <rodol> Nice, sqooq. I'm pretty new to haskell myself :P
22:29:51 <sqooq> rodol, same
22:29:56 <sqooq> new to programming in general
22:30:05 <sqooq> well
22:30:12 <sqooq> 5 months I think now.
22:31:00 <rodol> i've been programming for 7 years, but only started haskell 2 days ago haha. I have a bit of functional experience in elm though.
22:32:04 <sqooq> I rage quit haskell a few times
22:32:16 <sqooq> and went learning C, Java, and other "normal" languages
22:32:24 <sqooq> but I came running back
22:32:27 <sqooq> they feel straight wrong
22:32:45 <sqooq> I rather deal with haskells lack of side effects than use them. They feel so like unclear and messy.
22:35:07 <rodol> I mostly use C#, because I work with Unity game engine.
22:35:27 <rodol> I'd love to use Haskell with it though, I'm loving it so far
22:36:06 <rodol> I really like the pointfree style, its so amazing that it just works
22:37:02 <rodol> this type of thing looks so cool: scaleList = map . (*)
22:37:40 <rodol> the one thing I don't get is why negative numbers work the way they do. (-1) is wierd, it acts like a literal but shouldn't it really be a partially applied function?
22:38:29 <saurabhnanda> what happens if an error is thrown for one of the elements when using mapConcurrently? https://www.stackage.org/haddock/lts-9.0/async-2.1.1.1/Control-Concurrent-Async.html#v:mapConcurrently
22:38:41 <sqooq> rodol, I hate point free style haha
22:38:50 <sqooq> I use it when it feels right though
22:38:57 <sqooq> but like when it's abused it's just like, wtf is going on
22:39:29 <parsnip> rodol: googling "haskell negative one" shows discussions about how unfortunate it is.
22:39:37 <rodol> well yeah im not gonna do everything in point free, if i can't think of it easily then i just do it the pointful way
22:39:43 <rodol> thanks parsnip
22:39:58 <parsnip> https://prime.haskell.org/wiki/NegativeSyntax
22:40:10 <koz_> @pl \x y z a b -> (a, z, x, b, y)
22:40:10 <lambdabot> flip . ((flip . (flip .)) .) . flip (flip . flip (,,,,))
22:40:12 <nshepperd_> rodol: that weirdness is a concession to the way negative numbers are written in every other language
22:40:46 <koz_> Wait, (,,,,) is seriously a thing?
22:41:12 <parsnip> this one leads to mailing lists
22:41:14 <parsnip> https://wiki.haskell.org/Unary_operator
22:41:24 <nshepperd_> It would be no fun to write (negate 1) every time you need a negative number
22:41:54 <rodol> you could just do (0-1)
22:42:15 <nshepperd_> koz_: all the way up to 62 commas or something
22:42:30 <koz_> nshepperd_: Wtf?
22:42:33 <koz_> Wow.
22:42:59 <koz_> @pl \a b c d e f g h i j k -> (a,b,c,d,e,f,g,h,i,j,k)
22:42:59 <lambdabot> (,,,,,,,,,,)
22:43:07 * koz_ is speechless.
22:43:33 <nshepperd_> All the tuples!
22:43:50 <koz_> :t (,,,,,,,,,,,,,,,,,,,,,,)
22:43:52 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w)
22:44:05 <koz_> Well, TIL.
22:44:19 <manju> Why 62 ?
22:44:36 <manju> I mean that seems arbitrary :-)
22:45:04 <rodol> well if you did one more than that then it'd be 63
22:45:09 <rodol> and that's no good
22:45:14 <rodol> 62 is better
22:45:49 <manju> <interactive>:1:1: error:
22:45:49 <manju>     A 63-tuple is too large for GHC
22:45:49 <manju>       (max size is 62)
22:45:49 <manju>       Workaround: use nested tuples or define a data type
22:45:51 <osa1> saurabhnanda: you get an error, not sure what happens to in-flight threads though (are they cancelled or not)
22:45:51 <MarcelineVQ> 61 commas probably, since you're making a 62-tuple
22:46:00 <nshepperd_> Ah wait it's 61. The largest tuple size is 62
22:46:02 <osa1> saurabhnanda: it seems like it uses race under the hood so other threads should be cancelled
22:46:14 <nshepperd_> Hence 61 commas
22:46:29 <koz_> Why that specific number though?
22:46:29 <osa1> err wait, I'm looking at wrong code
22:46:34 <koz_> Is it a committee decision or something?
22:47:11 <saurabhnanda> osa1: so I won't come to know which ones succeeded and which ones didn't?
22:47:17 <osa1> saurabhnanda: sorry, it uses `concurrently` under the hood so see its documentation
22:47:23 <manju> TIL after a,b,c,d, ... ,z the next type is t26, t27, etc.,
22:47:42 <osa1> saurabhnanda: nope, if one of them fails you just get an exception. you can wrap your async tasks with exception handlers so that they all succeed
22:48:13 <saurabhnanda> osa1: thanks
22:48:26 <osa1> e.g. using Control.Exception.try
22:48:29 <nshepperd_> koz_: well, it's almost 64 so presumably the reason comes down to "word size, minus overhead" somehow
22:48:52 <koz_> nshepperd_: Yeah, probably. So does that mean that on 32-bit GHC, it'd be 32 elements max?
22:49:10 <rodol> how do I get a recursive thingy into pl?
22:50:23 <nshepperd_> There is apparently a comment in the source code to the effect "we tried adding a 63-tuple, but it made it segfault"
22:50:52 * hackage imprint 0.0.1.0 - Serialization of arbitrary Haskell expressions  https://hackage.haskell.org/package/imprint-0.0.1.0 (mrkkrp)
22:51:02 <osa1> saurabhnanda: we should improve the documentation, users shouldn't have to look at the source code to answer this question. I have some time right now so maybe I should do it.
22:52:10 <nshepperd_> koz_: don't know!
22:52:19 <rodol> @pl \(x:xs) (y:ys) -> x+y:add xs ys
22:52:19 <lambdabot> ap (flip flip tail . (ap .) . flip flip head . ((.) .) . (. add) . flip . (((.) . (:)) .) . (+) . head) tail
22:52:26 <tdammers> IIRC it's 64 minus overhead, but nobody knows why there is overhead, or why 64 is the limit :x
22:52:29 <koz_> nshepperd_: I don't have a 32-bit GHC handy.
22:54:43 <anon136> I made this (with some help) and I'm pretty proud of it. Fibonacci sequence in one line and different from any other way I've seen it done. fibonacci = map fst $ iterate (\x -> (fst x + snd x, fst x)) (1,0)
22:55:26 <tdammers> 34-tuple compiles just fine on 32-bit x86
22:58:35 <rodol> @pl \x -> (fst x + snd x, fst x)
22:58:35 <lambdabot> ap ((,) . uncurry (+)) fst
23:02:17 <rodol> is there anywhere i can vote to vanquish the unary minus
23:02:30 <osa1> saurabhnanda: actually if you think about it there's nothing else you can do in case of an exception, you have to re-throw it. the question is what happens to other threads and the answer is they're cancelled (so they don't hang)
23:03:53 <saurabhnanda> osa1: right. And then this leads to a common pattern where the internal function should use a `try` and return an Either so that this ambiguity about which thread succeeded or didn't, no longer remains. Probably this code snippet can also be added to the docs.
23:05:12 <osa1> agreed
23:15:53 <rodol> why so many people leaving and rejoining? is this standard?
23:16:21 <MarcelineVQ> sometimes
23:16:26 <koz_> rodol: Netsplits.
23:16:29 <koz_> They're annoying.
23:19:23 <parsnip> rodol: an irc client can usually filter out join/quit. some can even show just those for people that have recently spoken.
23:20:04 <SlashLife> I find it interesting how many of those people have a [,] in their name.
23:20:24 <koz_> [m] means they're using a Matrix client I think.
23:20:28 <SlashLife> I wonder if that's a matrix.org free tier or something.
23:20:53 <koz_> SlashLife: I think that's a default.
23:20:59 <parsnip> [m] is a matrix thing
23:21:05 <parsnip> oops
23:21:14 <SlashLife> Okay then. TIL :)
23:21:14 <rodol> Maybe matrix did the netsplit intentionally to advertise their client.
23:21:34 <SlashLife> And irccloud at the same time? :D
23:21:42 <srk> rodol: I disable join/quit notices for large channels, too much noise
23:21:47 <[Leary]> Joins/parts are just spam, filtering them should be default.
23:21:54 <SlashLife> And linode.
23:22:00 <koz_> Yeah, I should really do that on my own clients.
23:22:03 <srk> [Leary]: it's pretty useful for small chans
23:22:15 <SlashLife> I'd rather guess those hosts may get routed to specific IRC entry servers.
23:22:53 <parsnip> https://weechat.org/blog/post/2013/02/17/The-IRC-smart-filter-even-smarter
23:23:43 <parsnip> there's also (setq circe-reduce-lurker-spam t)
23:26:02 <[Leary]> I used weechat for a while and tried that smart filter ... it's trying to be clever, but it kinda still sucks because every part/join you do see is still a whole line.
23:26:16 <pharaun> irssi can filter the join/parts
23:26:17 <[Leary]> The toggleable, condensed view in glirc is much better.
23:26:20 <pharaun> and i see no excess lines
23:34:21 <parsnip> but can it do this?
23:42:09 <glguy> Since [Leary] brought up glirc, here's what the channel looked like a moment ago in each of three togglable views: normal, hidden metadata, detailed view
23:42:10 <glguy> https://imgur.com/a/qbkiU
23:46:52 <parsnip> the clever filter in weechat is not annoying to me, the frequency of people who have actually spoken and joined or quit is very low.
23:48:44 <glguy> It doesn't surprise me that some people would find that behavior useful
