00:00:15 <edwardk> then to improve on this you get sharing in the graph, and if you put a canonical ordering on the variables so that you always branch off of variables in the same order if you branch at all, and never bother with if x then y else y cases then there is a normal form for the graph for a given function.
00:00:44 <edwardk> so with sharing/hash-consing you can compare boolean formulas that you have BDDs for in O(1) time. mind you the normal forms are potentially exponential in size
00:01:02 <dfeuer> You're using unsafePerformIO? You should be ashamed of yourself. Isn't unsafeDupablePerformIO good enough for you?
00:01:09 <edwardk> coda is my current language research project
00:01:19 <edwardk> nope. it needs noDuplicate ;)
00:01:23 <dfeuer> :/
00:01:28 <dfeuer> Why's that?
00:02:16 <dfeuer> I mean for nodeId.
00:02:17 <edwardk> short answer is that you don't want it to screw up and have one update the hash table one way and another invocation give another unique id into the table
00:02:33 <dfeuer> Ah.
00:02:36 <dfeuer> Hrm...
00:02:44 <edwardk> some of those may be able to downgrade to unsafeDupablePerformIO, but not many
00:03:01 <dfeuer> You have a lot of scary code, Ed.
00:03:04 <dfeuer> Oh!
00:03:17 <edwardk> under the current assumptions we can know we'll get the same node id out of any invocation with the same types and arguments
00:03:21 <dfeuer> Is there a Boston Hackathon coming up anytime soon?
00:03:45 <edwardk> i haven't done anything to schedule one
00:03:49 <edwardk> usually we aim for june or so
00:04:08 <dfeuer> Ah.
00:04:45 <edwardk> last year we didn't get the space because greg hale moved away and we didn't manage to get a new sponsor at MIT. maybe i'll reach out to adam chlipala this year, but it means we won't be in the neuroscience building, but would rather have to be in one of the usual c.s buildings, which are more awkward to access
00:04:53 <dfeuer> Well, I have a couple people I'd like to see in Bahstahn, and I hope to hang those visits off the Hackathon.
00:05:43 <edwardk> anyways, if you want a fun project, try to figure out why that code uses 680 _gigabytes_ of intermediate memory to compute the factors of 143 ;)
00:05:48 <dfeuer> Maybe the math building? Is that any better?
00:06:02 <dfeuer> edwardk: the BDD code?
00:06:11 <edwardk> mostly would come down to whomever we can get to get us the space
00:06:16 <edwardk> yeah
00:06:26 <dfeuer> Why are you using it to factor numbers?
00:06:35 <edwardk> https://github.com/ekmett/coda/blob/master/lib/bdd/examples/factor.hs
00:06:39 <dfeuer> And no, I'm *not* going to do horrible performance checking for you.
00:06:42 <dfeuer> That's my day job.
00:06:48 <edwardk> it was just using ersatz as a test run
00:07:10 <edwardk> https://github.com/ekmett/coda/blob/master/lib/coda-automata/Coda/Automata/Presburger.hs is the actual usecase
00:07:18 <edwardk> and why i have that automata code in the first place
00:07:27 <edwardk> lets you ask questions about natural numbers
00:07:33 <dfeuer> *nod*
00:08:13 <edwardk> e.g. given forall n. exists m. 2 * m == n   -- it can say 'no'
00:08:27 <dfeuer> Nifty.
00:08:53 <edwardk> playing with it as a component in the larger coda type checker
00:09:16 * hackage fast-arithmetic 0.1.0.1 - Fast number-theoretic functions.  https://hackage.haskell.org/package/fast-arithmetic-0.1.0.1 (vmchale)
00:09:19 <dfeuer> So what is Coda ... for?
00:09:20 <edwardk> most recent plan was to write a lot of the BDD stuff using that crazy spmd style i like
00:09:56 <edwardk> you know how i keep saying that haskell is bad at abstraction re the way we handle typeclasses?
00:10:13 <dfeuer> Yeah.
00:10:16 <edwardk> i wanted to try to express what it would take to have a language that was _good_ at those things.
00:10:21 <dfeuer> Ah.
00:10:24 <edwardk> i also had some other concerns
00:10:29 <dfeuer> Well, I hope you succeed.
00:10:32 <edwardk> https://www.youtube.com/watch?v=Txf7swrcLYs talks about the funny way i parse
00:10:41 <whatsupboy> Is it easy to be self employed with hasekll ?? How/where ione can get any work ?
00:11:18 <dfeuer> whatsupboy: no, it's not easy to be self employed in *any* line of business.
00:11:22 <dfeuer> Sheesh.
00:11:52 <edwardk> whatsupboy: i'd say its about as easy as being a 'self-employed' python developer or java developer, a little bit easier in some ways because of a smaller talent pool, so its easier to stand out
00:12:26 <edwardk> but i agree with dfeuer in that its not easy to be a self-employed developer in any language, really
00:12:35 <whatsupboy> :(
00:13:11 <edwardk> self-employment is usually a function of whatever special circumstances make you the right person to do whatever it is you do in whatever narrow niche you can do all on your own
00:13:44 <dfeuer> edwardk knows whereof he speaks.
00:14:27 <whatsupboy> Ok
00:14:48 <edwardk> well, his commitment to haskell didn't last long ;)
00:16:49 <amalloy> i hope it that was a followup from the guy who stopped in here this afternoon to ask if you need a phd in math to learn haskell, and then left
00:16:55 <dfeuer> edwardk: I can't quite imagine you dropping Haskell entirely, even as you experiment with other things.
00:17:12 <edwardk> dfeuer: not expecting to
00:17:32 <edwardk> <- no phd
00:17:46 <edwardk> i seem to muddle through on this high-falutin haskell stuff though
00:19:18 <dminuoso> edwardk: Honestly looking at some of your code made me wonder what kind of math background one might need to make sense of it.
00:21:21 <edwardk> dminuoso: i dont use a lot of super-deep math from any one area. I just like to draw on things that are just a little over the horizon from what most people are looking at in lots of areas.
00:21:58 <edwardk> or rather i like to go as far out into theory as i can drag kicking and screaming back into practice
00:23:50 <raduom> Hi. Which package should I use if I need an HList like thing?
00:24:27 <edwardk> type level or also with value witnesses?
00:25:12 <edwardk> personally i'm rather partial to the 'Rec' type in vinyl. https://hackage.haskell.org/package/vinyl-0.7.0/docs/Data-Vinyl-Core.html
00:25:44 <edwardk> that way I can use Rec Proxy or Rec Identity or Rec Maybe, etc.
00:29:15 * hackage fast-arithmetic 0.1.0.2 - Fast number-theoretic functions.  https://hackage.haskell.org/package/fast-arithmetic-0.1.0.2 (vmchale)
00:30:04 <raduom> edwardk: with value witnesses. i'll take a look at that. thanks.
00:53:45 * hackage Ordinary 0.2018.1.4 - Short description of your package  https://hackage.haskell.org/package/Ordinary-0.2018.1.4 (MarisaVeryMoe)
01:31:08 <ph88> Does anyone know why i'm not getting a callstack printed with this code?  https://bpaste.net/show/033d4ccb4329
01:40:31 <MarcelineVQ> include your imports :>
01:44:58 <MarcelineVQ> Why do you expect a callstack to be printed?
01:52:37 <ph88> MarcelineVQ, https://bpaste.net/show/9bce3e275d26 i don't expect it to happen for the virtue of this code, but i want it to happen :P Or maybe i expect it to happen because other languages are also able to print a stacktrace on exception
01:53:57 <MarcelineVQ> You can get one, but your code isn't using the one it has. https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-Stack.html#g:2 details how to use a CallStack if you don't want to use things like errorCallWithCallStackException (which error uses anyway), or errorWithStackTrace
02:02:50 <MarcelineVQ> As a quick example, changing "b" to (prettyCurrentCallStack callStack) in your code will display the CallStack in your error
02:08:17 <MarcelineVQ> should anyway, I'm not so good at will :>
02:10:05 <MarcelineVQ> aha, pardon me that's prettyCallStack I was looking at the wrong module
02:11:54 <ph88> i like to move the callstack logic to the top instead of the bottom
02:13:59 <ph88> what's the -g in ghc 7.10 ?
02:17:20 <i-am-the-slime> A query string. This type is intended to make it difficult to construct a SQL query by concatenating string fragments, as that is an extremely common way to accidentally introduce SQL injection vulnerabilities into an application.
02:17:42 <i-am-the-slime> Unfortunately that's exactly what I am trying to do.
02:26:38 <MarcelineVQ> ph88: could you ask again using more words?
02:28:47 <ph88> https://ghc.haskell.org/trac/ghc/ticket/9049#comment:15
02:28:58 <ph88> We currently have two imperfect ways to get a stack trace: profiling and the new -g in 7.10.
02:30:11 <MarcelineVQ> And what is your question asking?
02:30:46 * hackage hdaemonize 0.5.5 - Library to handle the details of writing daemons for UNIX  https://hackage.haskell.org/package/hdaemonize-0.5.5 (sickmind)
02:32:01 <ph88> MarcelineVQ, what this "-g" thing is
02:32:08 <i-am-the-slime> How do I get ghc-mod to work on nixos?
02:33:01 <MarcelineVQ> Well, it's a flag for ghc. For 7.10 it's the same thing it is in 8 and above, except that in 8+ you can choose more levels of detail. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debug-info.html#ghc-flag--g⟨n⟩
02:33:35 <ph88> thx MarcelineVQ
02:34:21 <ph88> so it's very low level debugging for when you want to use gdb right ?
02:34:46 <MarcelineVQ> Dunno, I don't know a thing about DWARF files
02:35:59 <geekosaur> 7.10 doesn't support DWARF call traces iirc
02:36:21 <geekosaur> the DWARF support wasn't functional in ghc yet
02:37:09 <geekosaur> well. it generated symbols, but nothing that could use them. IIRC 8.0 included partial support, expanded in 8.2
02:37:20 <MarcelineVQ> The flag is accepted by ghc but I've no idea if that does anything useful
02:37:27 <MarcelineVQ> aha
02:37:32 <geekosaur> for exception reporting with +RTS -xc to use the DWARF symbols
02:50:19 <John882> Hey, is there someone who knows how to apply telescopic series?
02:51:20 <John882> H(k) = H(k-1) + c        => ck
02:52:11 <John882> how can I apply that to H(k) = (3/2)*H(k-1) + c??
03:05:00 <ph88> documentation issues in base should i also report them to ghc trac ?
03:06:20 <lyxia> that seems to be it, since the package links to it
03:10:39 <[exa]> is there a name for a version of tail that would work as [] -> []; (_:xs) -> xs  ?
03:12:05 <[exa]> John882: is that from the 2-connectivity graph algorithm?
03:28:01 <infty[m]> The length :: String -> Int function is additive w.r.t. concatenation/addition. Is it universal with respect to this property? If so, can this be used to define it, or does it still need an explicit construction?
03:29:04 <ph88> instead of    ghci -fexternal-interpreter -prof     is it possible to pass this option with the .ghci file ?
03:31:06 <ph88> how can i combine that command line flag with stack ?  https://bpaste.net/show/46b49d1aee20
03:31:48 <djwraith> does someone mind explaning to me what the the nested "let ... in ..." statements do exact on the topmost part of Wadler's paper at http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf ?
03:31:55 <djwraith> s/explan/explain
03:32:51 <djwraith> for example, why is it "(a,y) = eval t x" instead of "eval t x = (a,y)"?
03:33:52 <djwraith> oh, nvm, recursion...
03:34:19 <brynedwards> ph88: try `stack ghci --ghci-options="-fexternal-interpreter -prof"`
03:34:43 <dminuoso> djwraith: And it's nested because it fiddles part of the result of the first `eval`, namely `y` into the next recursion.
03:35:25 <dminuoso> djwraith: its a bit similar to a monad without the monad part. :-P
03:35:53 <djwraith> right, I thought x weren't given (which is given)
03:38:26 <djwraith> anyway, does wadler himself come here often?
03:39:34 <yoneda> exit
03:59:09 <butterthebuddha> http://blog.sigfpe.com/2007/04/trivial-monad.html
03:59:10 <butterthebuddha> ^ the type for >>= is different in that blog post than the type I get when running :t (>>=) in ghci?
03:59:52 <Rembane> :t (>>=)
03:59:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:00:11 <Rembane> It is indeed.
04:00:15 <Rembane> :t flip (>>=)
04:00:16 <lambdabot> Monad m => (a -> m b) -> m a -> m b
04:00:38 <Rembane> But if you change the order of the arguments and add some more brackets you get the same type.
04:00:43 <Rembane> bind :: (a -> W b) -> (W a -> W b)
04:00:55 <int-e> :t (=<<)
04:00:56 <lambdabot> Monad m => (a -> m b) -> m a -> m b
04:01:22 <butterthebuddha> Ah
04:01:32 <rzhanka> Is there some standard way to declare an alias for arrays? type Foo = STUArray s Int Int; fails with the complaint that type variable is not in scope. I tried: type Foo = forall s. STUArray s Int Int; but that seems to require a language extension. Is there some way to do this that I'm missing?
04:02:06 <Rembane> butterthebuddha: the order of the arguments for (>>=) makes us program from left to right and top to bottom.
04:02:33 <Rembane> butterthebuddha: ...which is better for do-notation and code that needs more than one line.
04:05:53 <ph88> brynedwards, ye that works for my global project .. however in a stack project i get    <command line>: can't load .so/.DLL for: libHSbasement-0.0.4-7pJikASNmAFFwadsMZ0ihV.so (libHSbasement-0.0.4-7pJikASNmAFFwadsMZ0ihV.so: cannot open shared object file: No such file or directory)
04:06:00 <barrucadu> rzhanka: You can't get rid of the 's' parameter for ST-based things.  You could have 'type Foo s = STUArray s Int Int'
04:09:55 <rzhanka> barrucadu: ah, I see, thanks.
04:14:17 <brynedwards> ph88: I don't know about that, maybe look at stack issues on github or create one
04:14:48 <ph88> oki
04:14:50 <ph88> thx
04:19:06 <saurabhnanda> is there any known/easy technique for writing look-ahead / look-behind / context-sensitive (don't know the correct term) parsers? Basically, how a value is parsed depends on another value that has already been parsed. I'm writing an applicative parser, btw.
04:24:51 <[exa]> If I have a module that imports something from another module, what's the simplest way for that something from the inner module to be also exported from the outer module (and imported by default when importing the outer module)?
04:33:20 <saurabhnanda> [exa]: import inner module and re-export in the outer module. is there a better way?
04:38:37 <dminuoso> butterthebuddha: https://gist.github.com/dminuoso/979646d0939c40a90eb7a85ad88b631b
04:53:45 * hackage q4c12-twofinger 0.1 - Efficient alternating finger trees  https://hackage.haskell.org/package/q4c12-twofinger-0.1 (quasicomputational)
05:03:07 <arianvp2> test
05:13:52 <Myrl-saki> My router has 7 MB RAM+tmpfs. Seems like a perfect place to ram hugs into. :)
05:14:42 <unclechu> hey guys, look at this simple example: http://lpaste.net/361324 is it possible to get KnownSymbol from list this way?
05:15:56 * liste would expect hugs to be code-rotten a bit
05:22:47 <piotr_> Is there an easy way to explore the AST of a Haskell program? My goal is to see how curried function application and composition etc look like in Haskell (GHC) AST. There's a program Astview but it doesn't work on my mac
05:25:49 <lavalike> piotr_: maybe this https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debugging.html?highlight=ast#ghc-flag--ddump-parsed-ast
05:46:15 <djwraith> can someone take a look page 11 of http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf and come back to tell me what Wadler put "Left Unit" and "Right Unit" there for?
05:46:46 <djwraith> I understand the associativity of monad laws, but... not the two units.
05:48:59 <djwraith> and I don't think the unit there as in left/right unit refers to monad's unit function
05:50:52 <ventonegro> djwraith: return a >>= \b -> return b === return a
05:52:24 <djwraith> ok. so it basically means left of * and right of * in Wadler's notation.
05:53:28 <Cale> djwraith: Are you just wondering why the laws have those names? The reason is pretty abstract.
05:54:56 <Cale> Or are you asking what the purpose of the laws is?
05:55:10 <djwraith> Cale: I think ventonegro answered my original question, but yes, I think I am somewhat confused at the nomenclature, since monad in Wadler's paper comes with two infix operators
05:56:01 <djwraith> monad explained with a single prefix operator would be preferable, though I suppose infix operator help with the writing.
05:56:33 <Cale> djwraith: So, there's an analogy to be made between the definition of a monad on some category, and the definition of a monoid on a set.
05:57:00 <djwraith> and I believe, with a reasonable amount of certainty, that I understand the purpose of the laws.
05:58:00 <Cale> A monoid consists of some set M equipped with a unit and a multiplication. If we have our category theorist hats on, we don't want to be talking about elements of sets, so rather than saying the unit is an element of M, we'll let it be a function from a one-element set, which I'll call 1, to M
05:58:25 <Cale> So we have some unit: 1 -> M, and multiplication: M x M -> M
05:58:38 <Cale> and then these have to satisfy some laws
06:01:45 <Cale> Let's call the unit η: 1 -> M and the multiplication μ: M x M -> M. Then in order to express the usual law that for all x in M we have 1 * x = x, that's saying that μ(η(i),x) = x (where i is the unique element of 1)
06:02:06 <djwraith> so the unit here is identity as in additive identity and multiplicative identity?
06:02:19 <Cale> yeah
06:02:21 <djwraith> or id mapping
06:02:26 <Cale> In the case of monoids
06:03:07 <Cale> anyway, we can write out the laws for a monoid in an arrow theoretical way where we're not discussing elements of sets, but just properties of μ and η
06:03:20 <Cale> and then have a look at the situation with a monad
06:03:59 <Cale> A monad T on some category C is an endofunctor C -> C which comes equipped with some natural transformations η: 1 -> T, and μ: T . T -> T
06:04:15 <Cale> which looks similar except that 1 now refers to the identity functor instead of a one-element set
06:04:15 * hackage kicad-data 0.5.0 - Parser and writer for KiCad files.  https://hackage.haskell.org/package/kicad-data-0.5.0 (kasbah)
06:04:33 <Cale> and instead of taking a cartesian product of sets, we're using a composite of functors
06:04:59 <Cale> and it turns out that the laws are actually perfectly analogous as well
06:05:03 <Cale> https://en.wikipedia.org/wiki/Monoid_(category_theory)
06:05:04 <dminuoso> djwraith: https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Monad_unit_explicit.svg/284px-Monad_unit_explicit.svg.png the laws basically are a different way of stating: this diagram must commute.
06:06:31 <jchia_1> I can't use "data Foo n m = ..." for n and m being type literals. How do I fix this code? http://lpaste.net/361329
06:07:05 <Cale> djwraith: So according to the analogy, the 'multiplication' is what we usually call join in Haskell
06:07:07 <Cale> :t join
06:07:08 <lambdabot> Monad m => m (m a) -> m a
06:07:11 <djwraith> dminuoso and Cale: ok. thanks for the bringing together the dichotomy.
06:08:31 <Cale> and then the left unit is saying that if we start out from m a and get to m (m a) by applying return (that's the unit), and then apply join (the multiplication) to get to m a again, that's the identity
06:08:47 <Cale> and you can translate that into a condition that bind will have to satisfy as well
06:08:49 <jchia_1> Never mind, I had a type and repeated n and failed to mention m in the 'data' definition for Foo
06:08:50 <dminuoso> djwraith: And another point of view is to see all the laws as stating: Given your functor f, all arrows of shape `a -> f b` form a category.
06:08:57 <dminuoso> djwraith: (It's analogous)
06:09:37 <djwraith> and join is idempotent
06:09:52 <dminuoso> djwraith: no?
06:10:07 <Cale> Well, it doesn't quite make sense that it would be idempotent since its domain and codomain are different
06:10:32 <dminuoso> djwraith: T(T(X)) -{ μ_X }-> T(X)
06:10:37 <dminuoso> djwraith: This is very non idempotent.
06:10:48 <Cale> But if you start with something of type m (m (m a)), and you use join to "collapse the outer two m's", and then you join again to get to m a
06:11:15 <Cale> it's the same as if you fmap join to first "collapse the inner two m's", and then join to get to m a
06:12:39 <dminuoso> djwraith: join is whats needed to make kleisli arrows composable, return is whats needed to give an identity under composition, associativity... well. You have a category.
06:13:03 <djwraith> well, I can't find the right word for it, but I think I get it.
06:14:45 * hackage ghc-tcplugins-extra 0.2.2 - Utilities for writing GHC type-checker plugins  https://hackage.haskell.org/package/ghc-tcplugins-extra-0.2.2 (ChristiaanBaaij)
06:14:45 <jchia_1> I'm trying to use type literals for 'data'. How do I make this work? http://lpaste.net/361332
06:25:03 <jchia_1> I managed to fix it using KindSignatures: "data Foo (n :: Nat) (m :: Nat) = Foo { f1 :: VS.Vector n Int }"
06:30:45 * hackage ghc-typelits-natnormalise 0.5.8 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.5.8 (ChristiaanBaaij)
06:31:08 <petrus> I have just read on reddit: "Monad isn't Applicative and Monoid isn't Semigroup". Since when is that correct?
06:31:46 <Rembane> petrus: Where on reddit? Does it have a context?
06:31:48 <[exa]> petrus: scary
06:34:10 <petrus> Rembane: https://www.reddit.com/r/haskell/comments/7ny867/a_haskell_problem_set/?st=jc0hi8nc&sh=387c65ad
06:35:08 <mnoonan> the definitions are dated *because* Monad isn't Applicative, etc
06:35:37 <mnoonan> https://wiki.haskell.org/Functor-Applicative-Monad_Proposal
06:36:00 <mniip> petrus, yeah that's an opposite statement
06:36:01 <barrucadu> See this commit from around the time of that comment, adding the Semigroup and Applicative superclasses: https://github.com/JD95/haskell-problem-sets/commit/7b1fb8109c26c5b6849238b28166a267116b5daf
06:36:39 <will__> Can anyone help with an Aeson question... I am decoding an array of things back from an API response.  Some values are a bit malformed - one field is sometimes a string, sometimes the number zero.  I would like to not include the item in the decoded list if this field contains the number zero.  I'm not sure how to do this - currently parsing the whole list just fails with an error.
06:37:48 <Rembane> will__: You can turn the JSON array into a list of Value, then pattern match on the type of Value and remove all that has type Number (or what the name of the constructor is)
06:38:58 <will__> Rembane: OK, thanks... I'll have a go at that
06:39:18 <Rembane> will__: No worries, come back if you get stuck. :)
06:42:18 <petrus> barrucadu: well it was a bit confusing since I actually looked at the source but did not noticed that it was recently changed.
06:44:30 <c_wraith> Rembane, will__: aeson's Array is a Data.Vector.Vector.  You could always use its filter operation directly, instead of going through lists
06:46:46 * hackage ghc-typelits-knownnat 0.4 - Derive KnownNat constraints from other KnownNat constraints  https://hackage.haskell.org/package/ghc-typelits-knownnat-0.4 (ChristiaanBaaij)
06:48:21 <Rembane> c_wraith, will__: Very good point. I had forgotten that.
06:52:27 <jchia_1> Is there a way to realize isomorphism for free and assign/copy from one type to another one that's isomorphic (different only by a phantom type)? http://lpaste.net/361333
06:53:01 <Iceland_jack> jchia_1: coerce?
06:53:16 <Iceland_jack> import Data.Coerce
06:53:58 <Iceland_jack> (You need to think of roles accordingly)
06:56:38 <mnoonan> jchia_1: I wrote up some perhaps-relevant background in the readme for roles: https://github.com/matt-noonan/roles
06:56:40 <jchia_1> Iceland_jack: Thanks. Seems to work. How can I tell for sure when two types "have the same representation", as mentioned in the docs for Data.Coerce?
06:56:58 <Iceland_jack> jchia_1: In terms of newtypes basically
06:57:06 <jchia_1> Is the value constructor all (Foo m n) considered to be the same constructor?
06:57:13 <liste> % :i Coercible
06:57:14 <yahb> liste: {-; Coercible is a special constraint with custom solving rules.; It is not a class.; Please see section 9.14.4 of the user's guide for details.; -}; type role Coercible representational representational; class Coercible a b => Coercible (a :: k0) (b :: k0); -- Defined in `GHC.Types'
06:57:16 <jchia_1> There's no newtype for my Foo example
06:57:39 <Iceland_jack> Oh right, it should be :)
06:59:14 <Iceland_jack> Is yahb some new bot
06:59:28 <unclechu> hey guys, is this possible to automatically deduce instances of `KnownFBZ` in this example somehow? http://lpaste.net/361336 i mean without templating, with some generics magic or something else?
06:59:52 <Iceland_jack> unclechu: singletons does that for you
07:00:32 <unclechu> Iceland_jack: do you mean the package 'singletons'?
07:00:47 <Iceland_jack> yes
07:00:48 <c_wraith> Iceland_jack, the name would imply it's "yet another haskell bot"
07:01:33 <c_wraith> but I know nothing about it. I just am used to "ya" at the start of a project name. :)
07:01:36 <Iceland_jack> how does it differ
07:01:38 <unclechu> Iceland_jack: so, it provides some templates for that, right?
07:01:38 <Iceland_jack> oh well
07:02:03 <Iceland_jack> unclechu: Yes,
07:02:04 <Iceland_jack>     singletons [d| data FBZ = Foo | Bar | Baz |]
07:02:51 <Iceland_jack> this generates instances
07:02:52 <Iceland_jack>     instance SingI (Foo :: FBZ) where sing = SFoo
07:02:52 <Iceland_jack>     instance SingI (Bar :: FBZ) where sing = SBar
07:02:52 <Iceland_jack>     instance SingI (Baz :: FBZ) where sing = SBaz
07:03:11 <unclechu> Iceland_jack: okay, actually my question was about if it's possible or not to do it without templates, but thanks anyway, i could use that
07:03:30 <Iceland_jack> It will be unnecessary once we have dependent types
07:03:51 <Iceland_jack> but for now
07:06:16 * hackage fast-arithmetic 0.1.0.3 - Fast number-theoretic functions.  https://hackage.haskell.org/package/fast-arithmetic-0.1.0.3 (vmchale)
07:07:04 <Iceland_jack> unclechu: your fbzVal is akad as fromSing
07:09:00 <Iceland_jack>  
07:09:00 <Iceland_jack>     >> fromSing @FBZ SFoo
07:09:00 <Iceland_jack>     Foo
07:09:03 <Iceland_jack>     >> fromSing @_ @Foo sing
07:09:06 <Iceland_jack>     Foo
07:10:45 * hackage fast-arithmetic 0.1.0.4 - Fast number-theoretic functions.  https://hackage.haskell.org/package/fast-arithmetic-0.1.0.4 (vmchale)
07:10:50 <Gurkenglas> Should it be "Coercible s t a b", meaning "if you replace all instances of a with b, s becomes t"?
07:11:39 <jchia_1> mnoonan: Thanks. The explanation is pretty clear.
07:15:46 * hackage fast-arithmetic 0.1.0.5 - Fast number-theoretic functions.  https://hackage.haskell.org/package/fast-arithmetic-0.1.0.5 (vmchale)
07:16:34 <unclechu> Iceland_jack: thanks, now my example looks like this: http://lpaste.net/361340
07:17:27 <Iceland_jack> You can skip the $( .. )
07:17:28 <Iceland_jack> looks good
07:31:15 * hackage fast-arithmetic 0.1.0.6 - Fast number-theoretic functions.  https://hackage.haskell.org/package/fast-arithmetic-0.1.0.6 (vmchale)
07:32:16 * hackage ghc-typelits-extra 0.2.4 - Additional type-level operations on GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-extra-0.2.4 (ChristiaanBaaij)
08:20:15 * hackage quickcheck-arbitrary-adt 0.3.1.0 - Generic typeclasses for generating arbitrary ADTs  https://hackage.haskell.org/package/quickcheck-arbitrary-adt-0.3.1.0 (mchaver)
08:34:15 * hackage hocker 1.0.3 - Interact with the docker registry and generate nix build instructions  https://hackage.haskell.org/package/hocker-1.0.3 (ParnellSpringmeyer)
08:38:29 <AndChat|556404> If I want to support terminal actions like moving the cursor forward and backward and up arrow brings back last command?
08:38:48 * hackage hspec-golden-aeson 0.5.1.0 - Use tests to monitor changes in Aeson serialization  https://hackage.haskell.org/package/hspec-golden-aeson-0.5.1.0 (mchaver)
08:42:17 <brynedwards> AndChat|556404: see https://hackage.haskell.org/package/readline-1.0.3.0/docs/System-Console-Readline.html
08:44:15 <mnoonan> there is also haskeline, if readline license issues are problematic for you
08:46:47 * hackage hackage-whatsnew 0.1.0.2 - Check for differences between working directory and hackage  https://hackage.haskell.org/package/hackage-whatsnew-0.1.0.2 (JeremyShaw)
08:48:36 <AndChat|556404> That's what I was looking for, I just didn't know what to type into hoogle
08:49:17 * hackage nix-deploy 1.0.1 - Deploy Nix-built software to a NixOS machine  https://hackage.haskell.org/package/nix-deploy-1.0.1 (ParnellSpringmeyer)
08:53:23 <anon136> I'm stumped. I feel like this should work: fib [x:y:ys] = fib ((x + y) : x : y : ys)
08:53:50 <glguy> You wanted (x:y:ys)
08:53:59 <glguy> [_] makes a pattern that matches a list with one element in it
08:54:01 <anon136> ooooh
08:54:27 <Cale> (which in this case would itself also need to be a list with at least two elements)
08:54:43 <glguy> Unfortunately this appoach won't do anything but warm up your computer before running out of memory
08:55:10 <glguy> (unless you've got more cases in the code that aren't pasted yet)
08:55:12 <anon136> I'm sure its not the best way to do it. I just felt like it should work (poorly or otherwise) and it wasnt.
08:55:15 <Cale> You probably meant to have fib produce some elements of the list
08:55:26 <Cale> in addition to applying itself to something new
08:56:15 <Cale> For example, this would work:  fib a b = a : fib b (a+b)
08:57:36 <Cale> Since you're directly producing a nonempty list there, the first element becomes available immediately, and the recursion only proceeds when someone wants to look at subsequent elements of the list.
08:58:17 <Cale> Whereas if you just have fib immediately apply itself to a new argument, no part of the result will be available until it stops doing that
08:58:26 <anon136> I hadn't really gotten to the point of trying to do it well yet.
08:58:29 <anon136> That was next on my list.
08:58:35 <anon136> I just wanted SOMETHING ANYTHING that worked
08:58:50 <glguy> What you pasted to channel won't work, though
08:59:59 <anon136> Haskell can be frustrating. When you get shown the solution you are robbed of the ability to figure it out yourself but all I ever get when trying to figure it out is 1000 type errors in a row.
09:00:20 <Cale> Eventually you'll learn what the type errors mean
09:00:43 <glguy> In another language you'd get 1000 runtime errors, you have to learn from the errors
09:00:49 <Cale> But they usually do indicate a real problem
09:00:58 <anon136> Maybe if I try really hard not to think about it I can forget the solution that you showed me and try again tomorrow to figure it out :D
09:01:08 <Cale> Well, that's just one of many ways to do it
09:02:19 <anon136> Yea I was thinking there has to be a way to do it with nested list comprehensions also. I beat my head against that wall for about 6 hours last night.
09:02:58 <Cale> We could do something tail recursive if we introduced some limit on how many Fibonacci numbers we wanted to generate, or we only wanted to know the nth one.
09:03:53 <Cale> You'd have something like fib a b n for finding the nth element of the Fibonacci sequence (or Lucas sequence) starting with a and b
09:04:26 <Cale> and it would work by applying fib to some new arguments with n getting smaller each time
09:06:46 <Cale> In general, if you're trying to translate an imperative program into a functional one, it tends to be helpful to turn mutable variables into function parameters, so that they can actually vary, as you apply the function to new arguments.
09:07:00 <anon136> I really was trying to get a definition that would just BE the fib sequence. So that i could do something like this: take 10 fib
09:07:08 <Cale> right
09:07:22 <mniip> Cale, only if the mutable variables are reader/local-transformable
09:07:33 <anon136> but without it being stored in memory or evaluating any further than it needed to when called
09:07:38 <mniip> otherwise you need to thread them into returned values which is pretty much state
09:07:49 <mniip> but oh well, monads
09:07:59 <Cale> mniip: Not necessarily
09:08:09 <Cale> mniip: You can turn each point of control in the imperative program into a function
09:08:22 <mniip> Cale, I mean you cannot label a tree without threading the index
09:08:44 <Cale> and have the functions apply each other according to the flow of control, to arguments according to how the variables change :)
09:08:59 <mniip> or can you
09:09:12 <mniip> is this a thing ContT can do...
09:09:55 <mniip> Cale, ah well yes, in that case a "recursive function call" in the imperative program turns into a continuation passing
09:11:42 <Cale> mniip: Well, you'll have a few separate functions which are going to be mutually recursive
09:20:54 <mniip> fancy
09:21:23 <mniip> @let labelTree t = lab 0 t (const id) where lab i (Node _ fs) k = go (i + 1) fs (\j fs -> k j (Node i fs)); go i [] k = k i []; go i (f:fs) k = lab i f (\j t -> go j fs (\l ts -> k l (t:ts)))
09:21:24 <lambdabot>  Defined.
09:22:00 <mniip> > labelTree (Node () [Node () [Node () []], Node () []])
09:22:01 <lambdabot>  Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = [Node {ro...
09:22:51 <lavalike> > levels $ labelTree (Node () [Node () [Node () []], Node () []])
09:22:53 <lambdabot>  [[0],[1,3],[2]]
09:25:27 <ph88> what was the repo/ticket to discuss packages not working in stack ?
09:31:54 <kadoban> ph88: What do you mean?
09:32:04 <andrei> Is there a way to know that some code is running in ghci?
09:32:24 <ph88> i saw on github some discussions when packages where not compatible in stack release .. i can't find where
09:32:59 <kadoban> ph88: Are you talking about packages from stackage? Otherwise I'd think you'd just report that to the package's bug tracker if something isn't building that should be able to.
09:33:35 <ph88> yes about stackage
09:39:47 * hackage servant-aeson-specs 0.6.0.0 - generic tests for aeson serialization in servant  https://hackage.haskell.org/package/servant-aeson-specs-0.6.0.0 (mchaver)
09:41:31 <L0g4nAd4ms> I have a list of Booleans, i.e. `[Bool]`. I want to write a func `myAnd :: [Bool] -> Bool`, that performs the logical *and* on the list. I have already one recursive solution, but i am struggling to find the solution with using `map`.
09:42:10 <L0g4nAd4ms> my main problem with `map` is, that it always returns a list of Bools, but not a single Bool in the end.
09:42:14 <lyxia> how do you know there is such a solution
09:42:25 <monochrom> I don't think map is relevant.
09:42:31 <iqubic> What are the reasons someone might choose to use a mutable Array like IOArray or STArray over a standard immutable Array
09:42:58 <lyxia> iqubic: if you want to mutate it...
09:43:28 <iqubic> What does that mean? Can't you just pass a new copy of the array into a looping function?
09:43:49 <L0g4nAd4ms> lyxia, monochrom: well, i assume there has to be a valid solution with `map` since this an exercise
09:44:04 <Cale> L0g4nAd4ms: If you had a list of some type [t] and a predicate on the elements, some function of type t -> Bool, you could use map to apply the function to the elements of the list and get a list of Bool values in the first place
09:44:09 <iqubic> Like I have a thing update :: Array i e -> Array i e. Can't I just iterate over that?
09:44:35 <Cale> L0g4nAd4ms: But map isn't useful for collapsing the list. It'll always give you a list of the same length as the list you give it
09:44:45 <lyxia> iqubic: it's expensive to update an immutable array
09:44:56 <iqubic> How expensive?
09:45:07 <lyxia> traversing the whole array
09:45:12 <lyxia> and copying it
09:45:17 <Cale> L0g4nAd4ms: That is, map would be useful for writing the "all" function, but not so much for "and"
09:45:25 <Cale> :t all
09:45:27 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
09:45:39 <Cale> Of course, that's the generalised one...
09:45:39 <iqubic> Oh. I think I I'll go with STArray then.
09:45:47 <L0g4nAd4ms> Cale, i know, an easier solution would be with all
09:45:52 <Cale> all :: (a -> Bool) -> [a] -> Bool
09:46:11 <iqubic> How would you summerize the list using mconcat and the All newtype wrapper? I can't recall how that's done.
09:46:14 <Cale> Well, if the point is to define your own all, and you want to use map, you could write
09:46:22 <Cale> all p xs = and (map p xs)
09:46:33 <lyxia> iqubic: the update could be implemented destructively if you can guarantee that you don't need the old version
09:46:35 <Cale> But that requires and
09:46:55 <Cale> The natural way to define and is to use foldr
09:47:00 <monochrom> When can I read the verbatim unabridged text of the exercise?
09:47:06 <iqubic> lyxia: I know that I'll never need the old array.
09:47:22 <L0g4nAd4ms> well the professor said map has to be used, but not necessarily without anything else, @Cale
09:47:28 <monochrom> Err, s/When/Where/
09:47:32 <Cale> map id ;)
09:47:35 <iqubic> I'm using an array to model the state of a game.
09:47:50 <Cale> L0g4nAd4ms: Well, do you have or?
09:48:11 <iqubic> And once a move has been made, I can safely discard the old array.
09:48:12 <Cale> and = not . or . map not
09:48:13 <AndChat|556404> .
09:48:13 <AndChat|556404> ..
09:48:14 <AndChat|556404> .
09:48:16 <AndChat|556404> I.
09:48:17 <AndChat|556404> ..
09:48:21 <AndChat|556404> .. ..
09:48:21 --- mode: ChanServ set +o glguy
09:48:21 --- kick: AndChat|556404 was kicked by glguy (AndChat|556404)
09:49:20 <lyxia> iqubic: well there are unsafe primitives, there could be compiler heuristics (but that's pretty ad-hoc), and there's linear types (WIP).
09:49:21 <iqubic> monochrom: Can I do a destructive update function without using an STArray, or do I need mutability in this case?
09:49:23 <L0g4nAd4ms> Cale, well tbh another implementation of "myAnd" has to be solved with foldr. what do you mean with "do you have or" ? logical or ?
09:49:30 <Cale> yeah
09:49:32 <Cale> for lists
09:49:53 <iqubic> lyxia: What does that mean? What are you trying to tell me?
09:50:08 <Cale> I'm trying to scrape the bottom of the barrel for reasons why you might use map in order to define and, and using de Morgan's law in that way is the best I can come up with
09:50:30 <iqubic> Cale: I think this is a homework assignment.
09:50:52 <iqubic> He mentioned a professor giving the assignment.
09:51:04 <L0g4nAd4ms> Cale, yes myOr has to implemented three times for list also, i already have the recursive implementation there too
09:51:08 <monochrom> The student always misread misremember misinterpret. I want to see the verbatim unabridged text.
09:51:40 <lyxia> iqubic: I meant that in theory what you imagined is feasible.
09:52:12 <iqubic> Yeah, but it would be easier with a mutable STArray.
09:52:45 <L0g4nAd4ms> thats the thing, i dont get either why using map is here is meaningful
09:52:46 <iqubic> Now I need to find some references that tell me how to use STArrays.
09:52:54 <Cale> L0g4nAd4ms: It's not.
09:53:13 <Cale> I suppose you could do mutual recursion with de Morgan's law :D
09:53:34 <iqubic> I think you may have mis-remembered what you you need to do.
09:53:45 <L0g4nAd4ms> nope, i have the pdf right in front of me xD
09:54:20 <monochrom> Where can I read it?
09:54:21 <iqubic> Oh. Can we see it? That might help us to give you better advice.
09:54:50 <monochrom> Pics or it didn't happen
09:55:06 <L0g4nAd4ms> well its not public available, but i can give you an excerpt of the exercise
09:55:18 <monochrom> Or you can smuggle it out.
09:55:32 <iqubic> yeah, lol
09:55:33 <Cale> myOr [] = False; myOr (x:xs) = x || not (myAnd (map not xs)); myAnd [] = True; myAnd (x:xs) = x && not (myOr (map not xs)) -- Stupidly wasteful
09:55:44 <monochrom> I do that all the time to pay-walled academic papers.
09:56:01 <iqubic> monochrom, sounds risky
09:56:26 <monochrom> Statistically I haven't run into opposition.
09:56:38 <iqubic> I figured.
09:56:38 <L0g4nAd4ms> monochrom, Cale : https://imgur.com/Z4gjyHc
09:57:12 <Cale> L0g4nAd4ms: Oh
09:57:28 <Cale> L0g4nAd4ms: You didn't tell us that you had your own MyBoolean type
09:57:35 <monochrom> It means convert MyBoolean to Bool?
09:57:38 <L0g4nAd4ms> Well its just a wrapper thing,
09:57:43 <L0g4nAd4ms> yes pretty stupid
09:57:46 <Cale> L0g4nAd4ms: yeah, so map would be useful for that
09:57:57 <Cale> for converting [MyBoolean] -> [Bool]
09:57:59 <monochrom> <monochrom> The student always misread misremember misinterpret. I want to see the verbatim unabridged text.
09:58:12 <iqubic> First use map to unwrap, then use all.
09:58:14 <L0g4nAd4ms> Well but the signature of the function is [MyBoolean] -> MyBoolean
09:58:23 <Cale> yes, sure
09:58:30 <L0g4nAd4ms> not another list
09:58:38 <monochrom> Then perhaps one last stage of Bool-to-MyBoolean
09:58:57 <monochrom> [MyBoolean] to [Bool] to Bool to MyBoolean
09:59:15 <lyxia> @where xy
09:59:15 <lambdabot> http://xyproblem.info/
09:59:20 <Cale> So you go [MyBoolean] -> [Bool] using map applied to something, and then [Bool] -> Bool using the usual and function, and then Bool -> MyBoolean using the opposite of the function you applied map to in the first part
09:59:22 <iqubic> myAnd xs = wrap (all (map unwrap xs))
10:00:09 <lyxia> L0g4nAd4ms: This was a XY problem.
10:00:09 <kakashiA1> kadoban: fixed the problem with "cabal install ghc-mod"
10:01:31 <L0g4nAd4ms> iqubic, well we never used wrap and unwrap until this point
10:02:11 <iqubic> Or whoops. Sorry for spoiling it
10:02:24 <monochrom> XYX^-1 problem :)
10:03:39 <iqubic> L0g4nAd4ms: They don
10:03:55 <iqubic> They don't exist.
10:04:13 <iqubic> I think you can infer what they do and write them yourself.
10:06:41 <L0g4nAd4ms> iqubic, well i think  unwrapping means deconstructing a container and wrapping constructing the container
10:07:50 <iqubic> Try it and see.
10:08:03 <iqubic> I'm not going to give you any more help right now.
10:08:13 <L0g4nAd4ms> ok boss
10:10:52 <iqubic> Do you have the recursive and the foldr versions done?
10:11:09 <iqubic> How did you deal with myBool not being a Bool in those cases.
10:11:23 <iqubic> Notice any parallels with this function?
10:11:44 <monochrom> Are you two even talking about the same "wrap"?
10:12:09 <iqubic> monochrom: For me wrap is just a type hole.
10:12:16 <iqubic> myAnd xs = wrap (all (map unwrap xs))
10:12:24 <iqubic> myAnd xs = _ (all (map _ xs))
10:13:16 <iqubic> That has has the form that the question is requesting
10:15:18 <iqubic> because you have to convert to and from myBool at some point to make the call to all type check
10:15:30 <L0g4nAd4ms> iqubic, i have the recursive impl. of myAnd yes, well thats was just simple list recurisoin
10:15:41 <iqubic> I understand.
10:16:00 <iqubic> The map version is very similar to what I have given you.
10:21:29 <iqubic> What's the method for writting all with mconcat and the correct newtype wrapper?
10:23:49 <nullie> > let xs = [True, True] in mconcat (map All xs)
10:23:51 <lambdabot>  All {getAll = True}
10:24:09 <hydraz> :t \p -> getAll . foldMap (All . p)
10:24:10 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
10:24:18 <mnoonan> > ala All foldMap [True, False]
10:24:19 <lambdabot>  False
10:24:34 <hydraz> :t ala
10:24:35 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
10:25:06 <hydraz> Lens?
10:25:45 <mnoonan> hydraz: or Control.Newtype, but iirc lens has a variant of it too
10:25:58 <hydraz> ah
10:27:19 <iqubic> Why are newtype wrappers like this useful?
10:29:21 <mnoonan> typeclasses give you functions from types to values, but sometimes you want a different value, and newtypes give you a nearly zero-cost way to get it by introducing a new type.
10:29:55 <mnoonan> (in this case, the "value" is the mappend function)
10:30:06 <iqubic> What is the point of the Dual newtype wrapper?
10:30:20 <hydraz> Dual x `mappend` Dual y = Dual (y `mappend` x)
10:30:28 <hydraz> > Dual [1,2,3] `mappend` Dual [4,5,6]
10:30:31 <lambdabot>  Dual {getDual = [4,5,6,1,2,3]}
10:31:25 <mnoonan> that should be called Op rather than Dual :|
10:37:03 <ph88> if a package is not in an lts will it build when i use an lts ?
10:41:03 <kakashiA1> anyone using atom for haskell development and the haskell REPL plugin of atom?
10:41:12 <kakashiA1> I defined a simple file test.hs
10:41:32 <kakashiA1> inside that file I have a simple function: inc x = x + 1
10:42:06 <kakashiA1> I cant execute that function nor use :t inc
10:42:19 <dpakj> hey, I'm fairly new to Haskell, can someone explain the difference between Parser and GenParser in the parsec library
10:42:59 <dpakj> Parser :: ParsecT s () Identity
10:43:10 <dpakj> GenParser :: ParsecT s u Identity
10:43:16 <kakashiA1> kadoban: fixed the problem by restarting :/
10:43:43 <glguy> dpakj: GenParser is a generalization of Parser
10:43:48 --- mode: glguy set -o glguy
10:43:58 <dpakj> right, what specifically is being generalized here
10:44:03 <dpakj> soemthing to do with state
10:44:07 <dpakj> user state
10:44:20 <dpakj> i guess a better question is when would i need a genparser vs parser
10:44:34 <glguy> You'd need GenParser when you don't like the choices that Parser makes for you
10:44:53 <glguy> (getState :: Monad m => ParsecT s u m u) and (putState :: Monad m => u -> ParsecT s u m ())
10:45:21 <glguy> There are multiple occurences of Parser and GenParser depending on which module you've imported
10:45:34 <dpakj> yeah, i need the bytestring one
10:45:47 <kadoban> kakashiA1: Which one?
10:46:15 <dpakj> whats a concrete example of a decision that parser makes that GenParser would be required
10:46:53 <mnoonan> dpakj: imagine parsing something like C++, where the parse depends on what is a type, what is a function, etc
10:46:53 <kakashiA1> kadoban: just how to use a haskell atom plugin correctly :)
10:46:55 <dpakj> sorry if my question is stupid, I'm still quite new to all this and have a very cursory understanding of monads and nearly none at all of monad transformers
10:47:11 <dpakj> ah i see
10:47:19 <glguy> It's not really to do with Monads, it's just if you were parsing something that required you to remember something from earlier in the parse when parsing later
10:47:33 <glguy> this could be a convenient way to pipe that information ahead
10:47:37 <dpakj> so the default parser has no state
10:47:45 <dpakj> in taht sense it can only parse context free?
10:48:18 <glguy> The default parser makes you carry your own state around, or it can do it for you
10:48:18 <kadoban> kakashiA1: Ah, nice.
10:48:45 <dpakj> cool gotcha, do u know of any projects or source code involving using gen parser over parser?
10:49:11 <mnoonan> dpakj: surprisingly, no :) you can parse a^n b^n c^n by parsing a^n1 b^n2 c^n3 and then checking that n1 == n2 == n3
10:49:30 <dpakj> haha true
10:49:30 <glguy> Not off the top of my head, maybe someone else does
10:50:17 <mnoonan> that's a feature of monadic parsers, that you can make later decisions based on earlier ones.
10:50:25 <dpakj> just a really handwavy question but do people use gen parser to store state to prevent deep recursion in recursive desccent?
10:51:05 <dpakj> hmmm i see
10:51:10 <dpakj> ive been mostly using applicative
10:51:11 <glguy> do do n <- length <$> many (char 'a'); count n (char 'b'); count n (char 'c'); return n :: Parser Int
10:52:11 <hyperisco> hehe, you said "do do"
10:52:12 <dpakj> oh cool
10:52:18 <glguy> You could use it to store information from earlier in the parse which names are types and which are variables, or whatever
10:52:32 <glguy> you could could carry that information around manually, which might just be cumbersome
10:57:23 <hyperisco> forward declarations… love it
10:58:14 <Marisa_> Hi... Can haskell promte function via datakind?
10:58:29 <hyperisco> Marisa_, no
10:59:13 <Marisa_> sad QAQ so now I need to write once for type and write once for value ... Remind me of C++ TMP
10:59:13 <hyperisco> singletons has some fairly complicated TH stuff which can lift some functions
10:59:41 <Eduard_Munteanu> If you really need that kind of flexibility, you want a dependently-typed language like Agda.
10:59:51 <hyperisco> go try Idris
11:00:10 <Marisa_> what beside singleton? I can do a bit of Coq, but I dont have that much of need
11:00:33 <infandum`> How can I use "stack exec ghci" globally (not in a package) using a specific version of a library?
11:00:49 <hyperisco> I am not aware of any other libraries which lift functions
11:01:28 <Marisa_> oh thx, I am gonna look into it... Only used singleton for something sorta trivial before
11:02:46 <Eduard_Munteanu> You could use an ADT to describe operations and define one function and one type family to execute the operations.
11:02:50 <kadoban> infandum`: You can put extra-deps in ~/.stack/global-project/stack.yaml I guess
11:03:15 <kadoban> I don't know if you'll have to do 'stack ghci --package whatever' then, I think you will.
11:03:30 <kadoban> Oh wait, why stack exec ghci? I forget how that ends up working.
11:03:40 <infandum`> kadoban: I tried that, but I installed a later version and it defaults to that. I found the answer though: load with stack exec ghci --package library-version, then use :set -package library-version
11:03:50 <infandum`> It's that second command in ghci I was missing.
11:05:32 <Marisa_> why not a bunch of type family though
11:06:53 <kadoban> infandum`: Pretty sure 'stack ghci' will do that part for you, unless you really need 'stack exec ghci' for some reason.
11:11:35 <infandum`> kadoban: I don't remember why, but I need to use stack exec ghci because stack ghci would result in unexpected package loading.
11:21:04 <ph88> are linear types and sessions types the same thing ?
11:22:05 <[exa]> ph88: session types are usually meant as "linear types used for sessions"
11:22:41 <ph88> i meant how it's applied here http://wiki.clean.cs.ru.nl/images/e/e7/2017-FP-Dag-TDD-Sessions.pdf
11:23:26 <Marisa_> I am using singleton... But how can I map a type family onto a [*]? Map MyTypeFamily has kind error..
11:24:29 <dmwit> Marisa_: Perhaps you could produce a minimal example that shows the problem, but is complete enough that we can reproduce it ourselves.
11:25:16 <Marisa_> just a sec, it is just ~3 line
11:26:26 <[exa]> ph88: looks like they don't use linearity there at all? (I might be wrong but the types there don't protect from making copies of the communication channel)
11:26:33 <Marisa_> given type family AsTuple (x :: [*]) :: *, suppose I have x :: [[*]], what is the equivalent of AsTuple (Map AsTuple x)?
11:35:09 <lyxia> It's not possible with AsTuple defined that way.
11:35:34 <lyxia> Defunctionalization is one technique.
11:37:19 * hackage time-lens 0.4.0.2 - Lens-based interface to Data.Time data structures  https://hackage.haskell.org/package/time-lens-0.4.0.2 (RomanCheplyaka)
11:49:19 <piotr> How do I get last command in Emacs Haskell Mode REPL? Arrow up doesn't work
11:49:35 <nullie> ctrl-arrow-up
11:52:38 <lyxia> Marisa_: http://lpaste.net/361355
11:52:41 <bphobia> hello
11:54:01 <ph88> hi
11:55:41 <bphobia> anyone knows termux or how to install ghc/hubs on termux without gcc?
11:56:08 <bphobia> i got clang which is the replacement for gcc
11:56:46 <bphobia> but the package won't install without gcc
11:57:17 * hackage hadolint 1.2.5 - Dockerfile Linter JavaScript API  https://hackage.haskell.org/package/hadolint-1.2.5 (lorenzo)
11:58:28 <[exa]> @pl \x -> head . f x
11:58:29 <lambdabot> (head .) . f
11:58:42 <[exa]> oh my.
12:01:07 <implementation> what the hell is [*]? has this to do with DataKinds?
12:04:29 <implementation> ok found it in the docs
12:07:24 <mniip> :k '[Char, Bool]
12:07:25 <lambdabot> [*]
12:13:18 <fosskers> Hi all, I'm having trouble getting my benchmarks to run w/ Nix. Should I ask about that here or is there a better place?
12:14:01 <iqubic> What is the point of the Functor instance for Dual?
12:15:16 <iqubic> > fmap (+10) (Dual 10)
12:15:18 <lambdabot>  Dual {getDual = 20}
12:15:40 <iqubic> Why is that a thing? Why is Dual even a thing?
12:15:58 <nullie> :i Dual
12:16:27 <nullie> The dual of a Monoid, obtained by swapping the arguments of mappend.
12:16:53 <iqubic> I know what it is. I just don't when to use it.
12:16:56 <nullie> > mappend (Dual [1]) (Dual [2])
12:16:58 <lambdabot>  Dual {getDual = [2,1]}
12:17:08 <nullie> right
12:17:22 <iqubic> Why not just use (flip mappend)?
12:17:44 <iqubic> > flip mappend [1] [2]
12:17:46 <lambdabot>  [2,1]
12:17:49 <fosskers> Would that still do what's intended with Foldable?
12:18:09 <nullie> > foldMap Dual [1, 2]
12:18:12 <lambdabot>  error:
12:18:12 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M638302880151...
12:18:12 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
12:18:30 <nullie> > foldMap Dual [[1, 2], [3, 4]]
12:18:32 <lambdabot>  Dual {getDual = [3,4,1,2]}
12:19:00 <iqubic> why not just this:
12:19:20 <nshepperd_> iqubic: flip mappend doesn't work with foldMap
12:19:37 <nshepperd_> Or any other function with Monoid constraint
12:20:04 <redrapscallion> when doing imports, is it common and best-practice to always make them qualified? (https://wiki.haskell.org/Import_modules_properly)
12:20:13 <iqubic> So is that like foldrMap?
12:20:22 <fosskers> redrapscallion, depends on the library
12:20:43 <redrapscallion> well, in my case, i'm working with Network.Wai and Network.HTTP
12:20:51 <fosskers> ByteString, Text, everything from `containers`, vector are always brought in qualified
12:21:13 <fosskers> Yeah you could probably qualify those as `N`
12:21:17 * hackage language-docker 2.0.1 - Dockerfile parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-docker-2.0.1 (lorenzo)
12:21:53 <redrapscallion> realistically, i just find it difficult to tell what comes from where if the imports aren't qualified
12:22:00 <iqubic> foldMap Dual xs == foldl (reverse xs) right?
12:22:25 <iqubic> or is Dual more subtle than that?
12:22:43 <nshepperd_> foldl and foldr just change how the thing is associated
12:23:24 <nshepperd_> foldMap Dual = Dual . foldr (flip mappend) mempty
12:23:36 <iqubic> so why does Dual exist?
12:25:07 <hyperisco> well, there was this big bang, and then everything sort of just was
12:25:26 <nshepperd_> Why not?
12:25:59 <nshepperd_> Why does Sum exist?
12:26:06 <iqubic> I can't see a reason why you'd use it
12:26:21 <nshepperd_> Sometimes you can't use foldr
12:26:27 <hyperisco> yet we still have appendixes. The universe is weird isn't it?
12:26:45 <nshepperd_> You have a function that only works with a Monoid constraint
12:27:36 <hyperisco> :t Dual
12:27:37 <lambdabot> a -> Dual a
12:28:17 <iqubic> :t getDual
12:28:18 <lambdabot> Dual a -> a
12:28:46 <hyperisco> when in doubt, it is probably to select type class instances
12:29:41 <hyperisco> so,  Monoid (Dual a) where mempty = Dual mempty; mappend (Dual x) (Duel y) = Dual (y `mappend` x)
12:29:45 <hyperisco> just a guess
12:29:59 <hyperisco> instance Monoid a => Monoid (Dual a) where …
12:30:04 <iqubic> Yes, that is mostly how it would work.
12:31:48 <hyperisco> > foldMap pure [1..10] :: [Int]
12:31:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:32:16 <hyperisco> > getDual (foldMap (Dual . pure) [1..10]) :: [Int]
12:32:18 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
12:32:28 <iqubic> What is the pure doing there?
12:32:35 <hyperisco> (:[])
12:33:11 <hyperisco> :t ala
12:33:12 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
12:33:32 <iqubic> What does ala doing?
12:33:34 <hyperisco> but can I remember how to use it without messing it up… probably not
12:34:47 * hackage xml-conduit 1.7.0.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  https://hackage.haskell.org/package/xml-conduit-1.7.0.1 (koral)
12:34:55 <hyperisco> :t ala Dual . flip foldMap
12:34:56 <lambdabot> (Monoid b, Foldable t) => t (Dual b) -> Dual b
12:35:16 <hyperisco> well that's not what I wanted
12:35:27 <iqubic> What do you want?
12:35:38 <iqubic> What package is ala in?
12:36:57 <dmwit> :t ala Dual foldMap
12:36:58 <lambdabot> (Monoid b, Foldable t) => t b -> b
12:37:00 <fosskers> Does anyone has nix experience?
12:37:11 <hyperisco> :t ala Dual
12:37:12 <lambdabot> Functor f => ((b1 -> Dual b1) -> f (Dual b2)) -> f b2
12:37:47 <iqubic> @where ala
12:37:47 <lambdabot> I know nothing about ala.
12:37:53 <iqubic> @package ala
12:37:54 <lambdabot> http://hackage.haskell.org/package/ala
12:38:11 <hyperisco> ala is a strange beast
12:38:48 <hyperisco> is the generalisation to Functor an afterthought or is foldMap a surprising fit?
12:39:07 <iqubic> I want know where I can can get the documentation n ala
12:39:19 <hyperisco> @hoogle ala
12:39:20 <lambdabot> Control.Lens.Wrapped ala :: (Functor f, Rewrapping s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
12:39:20 <lambdabot> Control.Newtype ala :: (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> (b -> o')
12:39:22 <lambdabot> Control.Newtype ala :: (Newtype n, Newtype n', o' ~ O n', o ~ O n) => (o -> n) -> ((o -> n) -> b -> n') -> (b -> o')
12:39:40 <byorgey> iqubic: do you know about hoogle and hayoo?
12:39:46 <hyperisco> yup
12:40:00 <iqubic> I do.
12:40:11 <byorgey> iqubic: then why not use them?
12:40:11 <iqubic> But hoogle failed to find the thing for me.
12:40:25 <byorgey> hayoo searches a lot more packages than hoogle
12:40:53 <iqubic> Found it.
12:41:57 <dmwit> hoogle.haskell.org (which supports name search but is a bit worse at type search) did not fail to find the thing for me. You may like to try it as an alternative to the standard Hoogle.
12:42:07 <iqubic> > ala Dual foldMap [[1,2],[3,4]]
12:42:09 <lambdabot>  [3,4,1,2]
12:42:18 <iqubic> That's what you want, right?
12:42:53 <glguy> > alaf Dual foldMap reverse [[1,2],[3,4]]
12:42:55 <lambdabot>  [4,3,2,1]
12:43:16 <iqubic> > ala Sum [1..100]
12:43:17 <lambdabot>  error:
12:43:17 <lambdabot>      • Couldn't match expected type ‘(Unwrapped (Sum b0) -> Sum b0)
12:43:17 <lambdabot>                                      -> f (Sum b)’
12:43:29 <iqubic> > ala Sum foldMap [1..100]
12:43:31 <lambdabot>  5050
12:43:39 <iqubic> > ala Product foldMap [1..100]
12:43:41 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
12:44:13 <iqubic> What does alaf do?
12:47:11 <glguy> > alaf Dual foldMap f [a,b,c] :: Expr
12:47:12 <lambdabot>  ((mempty <> f c) <> f b) <> f a
12:47:58 <d34df00d> Probably a very basic question, but let's say I'm given `getAllMetadata :: MonadMetadata m => m [(Identifier, Metadata)]` and `sortBookOrder :: (MonadMetadata m, HasMetadata a) => [a] -> m [a]`, where (Identifier, Metadata) is an instance of HasMetadata.
12:48:32 <d34df00d> In ghci, `:t getAllMetadata  >>= sortBookOrder` is MonadMetadata m => m [(Identifier, Metadata)], which is fine.
12:49:03 <d34df00d> If I do the same in my .hs, I get `Ambiguous type variable ‘m0’ arising from a use of ‘getAllMetadata’ prevents the constraint ‘(MonadMetadata m0)’ from being solved.`
12:49:20 <glguy> add a type signature to the place where you defined that
12:49:27 <d34df00d> IIRC there is an extension that's on by default in ghci and off for interpreted file, what's that?
12:49:39 <glguy> MonomorphismRestriction
12:49:54 <d34df00d> Ah right, thanks!
12:50:02 <glguy> It's on by default in Haskell and off by default in GHCi
12:50:34 <d34df00d> glguy: an explicit signature won't really help I guess, since it'll have to relate to the foralled type of a record field (that's partially related to what I asked yesterday).
12:50:52 <kakashiA1> I would like to understand the haskell error messages:
12:50:55 <kakashiA1> https://paste.xinu.at/74Vr/hs
12:51:00 <d34df00d> Also, ghc happily suggested checking the monomorphism restriction some releases ago, but stopped doing so a few releases back :(
12:51:11 <kakashiA1> why is there no error about the type that I passed?
12:51:16 <glguy> d34df00d: It would probably help to add a type signature just the same
12:51:18 <d34df00d> glguy: yeah, {-# LANGUAGE NoMonomorphismRestriction #-} fixes things.
12:51:30 <glguy> d34df00d: That's not a good idea to put your your actual .hs file, though
12:51:42 <d34df00d> Hmm, let me try out of curiosity...
12:51:43 <d34df00d> glguy: why?
12:52:18 <glguy> d34df00d: That restriction exists to avoid runtime inefficiencies where you're recomputing values you thought would be computed once
12:52:28 <glguy> it's not just to generate questions on IRC
12:53:02 <d34df00d> So that I don't carry the implicit dictionary parameter, and the function can be memoized in a sense, right?
12:53:07 <glguy> kakashiA1: You defined increment to only work on Int
12:53:20 <glguy> but then you used it on the floating literal 3.456, which is not an Int
12:53:32 <kakashiA1> glguy: yes, but my problem is that I want to understand the haskell error messages :)
12:53:32 <glguy> That has type: Fractional a => a
12:53:51 <kakashiA1> glguy: so where does it say "I expected Int man, but you gave me something else :P
12:53:54 <glguy> so for what you wrote to make sense, there would need to be an instance Fractional Int
12:54:07 <glguy> kakashiA1: It says that on the first line of the error message
12:55:06 <kakashiA1> glguy: could you help me to understand this in a more human friendly language:
12:55:08 <kakashiA1> No instance for (Fractional Int) arising from the literal ‘3.456’
12:55:30 <glguy> kakashiA1: Is there a particular part you don't understand?
12:55:55 <kakashiA1> glguy: does (Fractional Int) mean: you gave me Fractional but I expect Int ?
12:55:58 <dmwit> kakashiA1: The literal `3.456` is syntactic sugar for `fromRational (3456 % 10000)`.
12:56:01 <dmwit> :t fromRational
12:56:02 <lambdabot> Fractional a => Rational -> a
12:56:09 <dmwit> kakashiA1: This is the source of the `Fractional` constraint.
12:56:19 <glguy> kakashiA1: No, it means you provided 3.456, which has type Fractional a => a to be used at the type, Int
12:56:24 <glguy> so that would be Fractional Int => Int
12:56:39 <glguy> but there's no such instance Fractional Int, so error message
12:57:27 <glguy> > let increment :: Int -> Int; increment x = x+1 in increment (3.456::Double)
12:57:29 <lambdabot>  error:
12:57:29 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Double’
12:57:29 <lambdabot>      • In the first argument of ‘increment’, namely ‘(3.456 :: Double)’
12:57:46 <glguy> If you'd instead used a value with a specific type, you'd get this sort of error message instead
12:58:09 <glguy> but 3.456 is more flexible than that so that we can use it as a literal for Float, Double, Rational, etc
12:58:59 <dmwit> kakashiA1: Or, another way of saying: the compiler knows from `increment _` that `_ :: Int`. The compiler knows from `_ 3.456` that `3.456 :: Floating a => a`. So it tries to unify these two facts, and concludes it must choose `a ~ Int`, and find an instance `Fractional Int`. The latter doesn't exist.
12:59:00 <kakashiA1> glguy: you mean that incremtent 3.567 is less specific than increment (3.567 :: Double)
12:59:21 <glguy> Specifically that 3.456 is less specific than (3.456::Double)
13:00:12 <kakashiA1> glguy: let me try to understand that (maybe I will repeat some stuff)
13:00:16 <dmwit> > 3.456 :: Int
13:00:18 <lambdabot>  error:
13:00:18 <lambdabot>      • No instance for (Fractional Int) arising from the literal ‘3.456’
13:00:18 <lambdabot>      • In the expression: 3.456 :: Int
13:07:17 * hackage mulang 3.6.1 - An intermediate language designed to perform advanced code analysis  https://hackage.haskell.org/package/mulang-3.6.1 (flbulgarelli)
13:20:45 <pierrot> Hi. What's the best way to represent a date in Haskell?
13:21:13 <glguy> The time package provides types and operations for working with dates and times
13:26:16 <pierrot> If I want a record with a field `date :: UTCTime` (this type is defined in Data.Time.Calendar), how can I get the current date in that format? If I call `getCurrentTime` I'll get it but wrapped in a `IO`.
13:27:58 <glguy> `There no one value that is always the current date, you'll always have to get the current date at some particular point
13:28:17 <glguy> when the getCurrentTime action executes it returns the time at that moment as a value
13:30:57 <pierrot> but what would happen if I want to store it at particular point?
13:31:31 <glguy> You execute getCurrentTime at the point in time that you wanted and then you store that somewhere
13:31:37 <glguy> store the result of that*
13:32:25 <pierrot> Oh, yeah. It makes sense.
13:32:28 <pierrot> Thanks
13:57:52 <serendependy> I've a really quick question about second-order and impredicative type inference for the following code: http://lpaste.net/361358 . For `test2' is there any way to convince GHC not to perform implicit type abstraction?
13:59:34 <serendependy> (refresh to see error message)
14:01:51 <huss`> Hey guys, I'm having trouble in defining a Bifunctor for a binary tree...
14:01:59 <huss`>  
14:01:59 <huss`> data BinTree a = Node a (Maybe (BinTree a)) (Maybe (BinTree a)) deriving Show
14:02:18 <glguy> serendependy: No, you can't instantiate a type-variable with a quantified type
14:02:26 <monochrom> That won't be a Bifunctor. You need two type variables. "BinTree a" has only one.
14:04:10 <glguy> You can hide the quantifiers behind newtypes, however:
14:04:11 <glguy> newtype AllF = AllF { unAllF :: forall x. F x }
14:04:11 <glguy> test2p = unAllF (fix (\(AllF x) -> AllF (l' x)))
14:04:22 <serendependy> glguy: I have ImpredicativeTypes enabled, so shouldn't I be able to? In particular I can check test :: List (forall a . List a)
14:04:22 <serendependy> test = Nil (not shown in the snippet)
14:04:24 <huss`> monochrom: I would like to use bimap over it even if it has only one type, that would be bad to introduce a useless type ?
14:04:49 <monochrom> What is the type of bimap again?
14:04:56 <serendependy> I'll take a look at that, thanks!
14:05:02 <geekosaur> serendependy, ImpredicativeTypes is broken
14:05:09 <huss`> :t bimap
14:05:09 <geekosaur> and as of 8.x should be deprecated
14:05:10 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
14:05:34 <serendependy> geekosaur: I'm on v7.10 still, will get around to updating
14:05:50 <geekosaur> doesn;'t matter, it is still broken. it has always been broken
14:06:02 <glguy> serendependy: ImpredicativeTypes is broken and unsupported. I don't know what parts of it will let you do what at this point
14:06:03 <monochrom> You can add a newtype wrapper that has the 2nd type variable and make it useless, yes. But it has to be a newtype wrapper.
14:06:35 <geekosaur> or, more precisely, has never had a specification for what it should be doing, and has always been treated as "does what I happen to need" and constantly tweaked to try to fit various people's needs, usually at the cost of someone else's needs
14:06:37 <huss`> monochrom: okay, but why it has to be ?
14:06:41 <monochrom> Or rather, you cannot directly do "instance Bifunctor BinTree"
14:07:30 <geekosaur> huss`, typeclasses like Bifunctor are not conveniences that you can tweak around just because you'd like to use bimap for something that looks vaguely similar to existing uses.
14:07:52 <geekosaur> Bifunctor has a specific meaning with specific implications, and code *depends* on those implications
14:08:42 <monochrom> I guess the analogous reason, at the value level, we don't equate "True" with "\_ -> True", for example?
14:10:41 <monochrom> We separate Bool from a->Bool, and we separate *->* from *->*->*, even when we have a use-case in which "the 2nd parameter is unused semantically"
14:11:36 <monochrom> There are other languages that let you conflate them. For example mathematicians' language.
14:11:42 <glguy> Maybe the question was just "why does it have to be a newtype wrapper, why can't I add the unused parameter to my type"
14:11:43 <huss`> geekosor: why a binary tree is not a bifunctor when it has two objects to map ?
14:12:04 <monochrom> Eh that's very faulty thinking.
14:12:05 <geekosaur> the implications are stated as laws that a valid instance must obey. similarly, newcomers often want to try to force an unparameterized type to be a Functor so they can (ab)use fmap; but the laws are there for a reason, and existing code depends on those laws being obeyed.
14:12:06 <huss`> monochrom: okay, i see :)
14:12:40 <monochrom> A list has an unbounded number of objects to map, yet no one would deduce "therefore [] is an n-ary functor, for all n"
14:13:04 <geekosaur> in particular, there are other typeclasses that rely on some type with instances thereof having valid Functor instances. the compiler will trust you if your type has such an instance, and you will get garbage as a result.
14:13:17 * hackage hpg 0.8 - a simple password generator  https://hackage.haskell.org/package/hpg-0.8 (fritjof)
14:13:25 <huss`> monochrom: well, we don't know the arity, but its the same for (,,,,,,), in what a tree is different to a nested tuple
14:13:39 <serendependy> glguy: That's a pretty neat trick. I don't think it's preventing type abstraction of y, but hiding the quantification of x in a newtype and having ghc solve x = y later?
14:14:57 <serendependy> (and eta-expanding l' modulo the AllF constructor)
14:15:25 <redrapscallion> with stack, how do i downgrade the ghc version? it auto-installs the latest version when i make a new project, and i need a pre-8.0 ghc version
14:16:26 <glguy> search for a resolver that has the versions of things you want and use that one
14:18:05 <redrapscallion> glguy: oh. that was a lot easier than expected lol
14:18:55 <glguy> serendependy: sounds right
14:20:17 <EvilMachine> Hmm, I can’t find a function with this signature: (a -> m a) -> (a -> ma) -> a -> ma
14:20:45 <EvilMachine> I want a (f <|> g), with both f and g being (a -> m a)
14:21:30 <EvilMachine> All I can think of, is (\x -> f x <|> g x), but I think there might be a shorter way.
14:22:52 <monochrom> @type (>=>)
14:22:53 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:22:59 <monochrom> Will that be OK?
14:23:23 <fraktor> Is there a function with this type: (a -> b) -> [a] -> [(a, b)] ?
14:23:58 <EvilMachine> monochrom: Partially … The Alternative version of that would be right.
14:24:21 <fraktor> :t (\f, xs -> zip xs (map f xs))
14:24:21 <lambdabot> error: parse error on input ‘,’
14:24:24 <monochrom> I don't think we have a ready-made \x -> f x <|> g x
14:25:14 <fraktor> :t (\f xs -> zip xs (map f xs))
14:25:15 <mniip> liftA2 (<|>)
14:25:15 <lambdabot> (a -> b) -> [a] -> [(a, b)]
14:25:18 <EvilMachine> monochrom: Seems like it.
14:25:19 <Axman6> it's listA2 (<|>)
14:25:25 <Axman6> liftA2*
14:25:28 <EvilMachine> mniip: Oh, nice
14:25:33 <fraktor> :t liftA2
14:25:34 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
14:25:43 <fraktor> :t liftA2 (<|>)
14:25:43 <EvilMachine> Wait, that’s not it.
14:25:44 <lambdabot> (Applicative f2, Alternative f1) => f2 (f1 a) -> f2 (f1 a) -> f2 (f1 a)
14:25:44 <Axman6> wait no
14:25:47 <Axman6> ha
14:25:47 * hackage persistent-postgresql 2.6.2.2 - Backend for the persistent library using postgresql.  https://hackage.haskell.org/package/persistent-postgresql-2.6.2.2 (MaxGabriel)
14:26:10 <fraktor> :t <|>
14:26:11 <lambdabot> error: parse error on input ‘<|>’
14:26:19 <fraktor> :t (<|>)
14:26:20 <lambdabot> Alternative f => f a -> f a -> f a
14:26:37 <Axman6> @pl (\x -> f x <|> g x)
14:26:38 <lambdabot> liftM2 (<|>) f g
14:26:49 <Axman6> hmm, maybe it is then
14:26:53 <EvilMachine> liftM2 (<|>)
14:27:03 <EvilMachine> > liftM2 (<|>)
14:27:05 <lambdabot>  error:
14:27:05 <lambdabot>      • No instance for (Typeable m0)
14:27:05 <lambdabot>          arising from a use of ‘show_M14196307825770121996572’
14:27:09 <monochrom> liftA2 (<|>) is a bit too abstract for a simple lambda IMO
14:27:10 <EvilMachine> Hmm, wait, how does that work. ^^
14:27:19 <monochrom> f2 = (->) a
14:27:24 <Axman6> using the (a ->) applicative
14:27:29 <monochrom> f1 = m
14:28:31 <EvilMachine> :t liftM2 (<|>)
14:28:32 <lambdabot> (Alternative f, Monad m) => m (f a) -> m (f a) -> m (f a)
14:28:33 <fraktor> I'll just do the lambda I had.
14:29:28 <EvilMachine> :t liftMA2 (<|>)
14:29:29 <lambdabot> error:
14:29:29 <lambdabot>     • Variable not in scope: liftMA2 :: (f0 a0 -> f0 a0 -> f0 a0) -> t
14:29:29 <lambdabot>     • Perhaps you meant one of these:
14:29:32 <EvilMachine> :t liftA2 (<|>)
14:29:33 <lambdabot> (Applicative f2, Alternative f1) => f2 (f1 a) -> f2 (f1 a) -> f2 (f1 a)
14:30:10 <Axman6> @unpl liftA2 (<|>) show (const "foo")
14:30:10 <lambdabot> liftA2 (<|>) show (\ _ -> "foo")
14:30:22 <Axman6> lame
14:30:52 * Clint nods.
14:35:15 <Marisa_> I think I am doing something very wrong... Now I need list of list of type binded with a dictionary (dont even know if it is possible or not)... lol
14:36:25 <Marisa_> So I want to make a type class that represent 'pattern matchable', basically class MatchC (a :: *) where type Match a :: [[*]]
14:37:05 <Marisa_> But I want element of Match a to be instance of MatchC as well, is this possible or am I designing it wrong?
14:41:54 <metahumor> EvilMachine: Axman6: what about this
14:41:55 <geekosaur> that seems a bit circular. what's the base case?
14:42:15 <metahumor> :t \x f g -> (uncurry (<|>)) (curry (bimap ($ x) ($ x)) f g)
14:42:16 <lambdabot> Alternative f => a1 -> (a1 -> f a2) -> (a1 -> f a2) -> f a2
14:43:13 <metahumor> you can substiture (<|>) with (>=>) if you prefer
14:43:32 <d34df00d> I'm trying to hack a bit on some third-party library, and I can't build it:
14:43:41 <d34df00d> http://bpaste.net/show/6bd1796e53b7
14:43:59 <d34df00d> pandoc is surely present in build-depends for the library, but what concerns me is that it mentions two pandocs with two different hashes.
14:44:04 <EvilMachine> metahumor: No clue what this has to do with my original question. ^^ Nevermind though, I didn’t bother. (f x = g x >>= \ x' -> (h1 x' <|> h2 x')) was fine enough.
14:44:08 <geekosaur> more to the point, you'll need to break that into a primitive class (base case) and a potentially recursive class which can have instances of the non-recursive primitive class as instances
14:44:17 * hackage hslua 0.9.5 - A Lua language interpreter embedding in Haskell  https://hackage.haskell.org/package/hslua-0.9.5 (tarleb)
14:44:33 <geekosaur> ...but that last part is itself potentially tricky, as the obvious ways of declaring it will overlap
14:45:27 <geekosaur> d34df00d, that is telling you that there are two possible places it could get it, and a version constraint isn't sufficient
14:45:44 <d34df00d> geekosaur: how come there are two pandocs of the same version?
14:45:49 <d34df00d> And how do I resolve this?
14:45:53 <geekosaur> how you proceed will depend on what build tool you are using
14:45:56 <d34df00d> stack
14:46:09 <geekosaur> uh. stack normally prevents this
14:46:35 <geekosaur> what OS/distro, and are you using system ghc or one stack installed?
14:47:06 <d34df00d> Haha. Gentoo Linux, system ghc. hakyll built fine when it was pulled as a dep for my own site.
14:47:12 <geekosaur> ghc is not very smart and will try any compatible version of a package it can find. stack and cabal-install provide different ways to deal with it
14:47:32 <geekosaur> ok, easiest solution is tell stack to install its own ghc
14:47:49 <geekosaur> you likely have a system install of pandoc, and if you are using the system ghc then stack can't hide that one
14:48:06 <d34df00d> Yeah, that makes sense!
14:48:13 <d34df00d> I surely have system pandoc of just the same version.
14:48:29 <d34df00d> Why didn't it break hakyll when it was pulled as a dep of my project though?
14:48:49 <geekosaur> likely stakc built a second one to deal with some other dependency of both pandoc and your current project being a different version
14:49:16 <geekosaur> but because it can;t force a system-installed ghc to only see its version, ghc becomes confused.
14:49:37 <d34df00d> Hmm, won't stack always build one for its own needs? Like, if I understand its model correctly, it tries to depend on the system as little as possible.
14:50:09 <geekosaur> not "always". if you force it to use system ghc, you are explicitly breaking that model
14:50:33 <d34df00d> geekosaur: ah, I see. Also, just curious, can I ask it to use its own ghc just for the given project?
14:51:09 <d34df00d> In the meanwhile, I wonder if one can do significantly better than https://github.com/jaspervdj/hakyll/blob/master/lib/Hakyll/Core/Store.hs#L196 — 50% of time and 54% of allocations spent in this function, I want to try to fix it.
14:52:19 * geekosaur is looking for the right stack.yaml entry for this
14:53:25 <d34df00d> geekosaur: seems like it's system-ghc: False!
14:53:33 <geekosaur> https://docs.haskellstack.org/en/stable/yaml_configuration/#system-ghc
14:53:35 <geekosaur> yes
14:53:40 <d34df00d> Neat, let me try...
14:54:21 <d34df00d> Oh, now it's compiling everything.
14:54:33 * d34df00d gonna grab some tea.
14:54:39 <fraktor> I've got a recursive function that, based on a condition, is sometimes tail call optimizable and sometimes not. Will my program only create stack frames when it's not possible to do tail call recursion?
14:54:53 <pushp0p> are min and max operations monoidal for Integer?
14:55:02 <pushp0p> or no because they don't have a zero
14:55:03 <geekosaur> right, it will now have to buiuld everything ti was getting from the global package database
14:55:28 <geekosaur> but that way it will have a consistent package database and will avoid the confliuct you ran into
14:55:53 <geekosaur> pushp0p, for Integer the corresponding identities are signed infinities
14:56:38 <geekosaur> (thinking of identities as "zeroes" will lead you into traps like that)
14:57:09 <d34df00d> You just have to think of zeroes as of identities :)
14:57:15 <d34df00d> So one is zero multiplication-wise.
14:59:14 <fraktor> If I want to compare if a pair tuple is equal, can I just do uncurry (==)?
14:59:39 <geekosaur> that said, I don't think Integer as such supports "infinity" as a value. but iirc there is a monoid setup that hacks around that?
14:59:40 <beauby> pushp0p: A "zero" is usually called a "neutral element" or "identity element"
14:59:43 <geekosaur> for min/max
14:59:45 <monochrom> fraktor: Without actually seeing your code, I bet yes. But read the generated core, cmm, and asm to be sure. There is no blanket answer.
15:00:03 <geekosaur> fraktor, (==) on tuples should already do the right thing
15:00:32 <monochrom> > (True, 'x') == (True, 'x')
15:00:34 <lambdabot>  True
15:00:43 <geekosaur> instance (Eq a, Eq b) => Eq (a, b) -- Defined in ‘GHC.Classes’
15:01:27 <iqubic> I need a mutable 2d data structure that is in the ST monad. I could theoretically work in the IO monad, but ST is just cleaner IMO
15:01:54 <geekosaur> or, do you mean check if both values inside the pair are equal? then yes, uncurry (==)
15:02:21 <geekosaur> (this should give you an idea that you need to be more precise in the problem specification :)
15:02:48 <iqubic> What do you think the best data structure would be for me? An array, or a vector?
15:02:49 <monochrom> But those who have that skill have already become lawyers and are earning more money.
15:03:07 <iqubic> Because I need updating and access both to be fast.
15:03:29 <d34df00d> iqubic: do you need it to be jagged?
15:03:43 <iqubic> No.
15:03:55 <iqubic> It's going to be a square 2d structure.
15:04:03 <monochrom> I don't know which one is faster, STArray or MVector. But both work fine in ST.
15:04:14 <d34df00d> In my experience vectors don't impose significant overhead, so I'd decide based on the API.
15:04:40 <monochrom> But good decision to go ST.
15:05:14 <iqubic> monochrom: yeah, I don't want the mutability to creep into the rest of my program.
15:06:45 <iqubic> Is there a way I can make my program structure agnostic, and benchmark later? Or are the APIs of Array and Vector to different for me to abstract that out?
15:07:20 <iqubic> s/agnostic/independant
15:07:35 <monochrom> Pretty different API. I don't think there is a class to cover them both.
15:07:46 <iqubic> Alrighty then.
15:08:35 <monochrom> Hell, array comes with one class and vector comes with a different class. Each one wants to own the whole world, and none actually does.
15:09:58 <d34df00d> Right, and what does this mean when I try to stack build?
15:09:59 <d34df00d> AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
15:10:09 <iqubic> Do you have guides for STArrays and MVectors? Is reading the Hackage documentation good enough?
15:10:13 <jchia_1> What's the difference between Data.Proxy.Proxy and GHC.Prim.Proxy#?
15:10:46 <d34df00d> monochrom: nah, it's not about owning the word, but covering the operations common to all sorts of combinations of ST/IO/pure, boxed/unboxed, storable/not-storable, etc.
15:11:53 <monochrom> You have just defined owning the world for me. :)
15:12:10 <geekosaur> except for the minor issue that doing so without introducing so much overhead as to make it not worth the effort is difficult at best
15:12:10 <d34df00d> The little vector's very own world :)
15:12:52 <geekosaur> d34df00d, that stack error means you need to run "stack upgrade"
15:13:05 <geekosaur> which may also explain why your stack was defaulting to system-ghc
15:13:30 <iqubic> geekosaur: What does that mean? Not introducing any overhead?
15:13:59 <geekosaur> (more recent versions of stack make it harder to use system-ghc, so I expect distributions will be slow or unwilling to update to it)
15:14:10 <d34df00d> geekosaur: nah, that's a different one, I realized that lts-9.* has old pandoc, so I moved to 10.*
15:14:16 <d34df00d> Thanks, I'll try upgrading!
15:14:45 <geekosaur> iqubic, did you think magic happens? something has to sit in between your code and the actual implementation and make the two fit. that something is code, and slows your code down
15:15:00 <iqubic> I see.
15:15:08 <iqubic> What does that mean for me?
15:15:44 <geekosaur> it means nobody is going to make a layer that hides the difference between MVector and STArray
15:15:58 <geekosaur> because you'd lose any speedup that you got by using either
15:16:19 <iqubic> Right.
15:16:47 <iqubic> So if I want to benchmark my thing with both MVector and STArray, and benchmark both to see which is faster?
15:17:47 * hackage heist 1.0.1.2 - An Haskell template system supporting both HTML5 and XML.  https://hackage.haskell.org/package/heist-1.0.1.2 (DougBeardsley)
15:18:29 <pushp0p> geekosaur: so would max be cconsidered an instance of a monoid over int or other ordered stuff?
15:18:42 <iqubic> :t Max
15:18:43 <lambdabot> error:
15:18:43 <lambdabot>     • Data constructor not in scope: Max
15:18:43 <lambdabot>     • Perhaps you meant variable ‘max’ (imported from Data.Ord)
15:18:55 <iqubic> :t Maximum
15:18:56 <lambdabot> error:
15:18:56 <lambdabot>     • Data constructor not in scope: Maximum
15:18:56 <lambdabot>     • Perhaps you meant one of these:
15:19:29 * geekosaur is poking Data.Monoid. don't remember offhand if there is a hacky definition that avoids the lack of an infinity value in Integer
15:20:20 <geekosaur> looks like not, at least currently. I think at one point there was one, but the lack of an infinity Integer value made it hacky
15:20:37 <geekosaur> and we can't retrofit an infinity into gmp
15:24:13 <monochrom> Maybe semigroup has min and max.
15:24:58 <amalloy> monochrom: it does
15:26:20 <geekosaur> right, but Semigroup is not Monoid (and the difference is exactly this...)
15:26:32 <d34df00d> This is getting better and better. So now I'm having this error when trying to build pandoc as the dependency:
15:26:40 <fraktor> > (uncurry (==)) (4, 4)
15:26:42 <lambdabot>  True
15:26:45 <d34df00d> <command line>: can't load .so/.DLL for: /home/d34df00d/Programming/readonly/hakyll/.stack-work/install/x86_64-linux-tinfo6/lts-10.2/8.2.2/lib/x86_64-linux-ghc-8.2.2/libHSskylighting-0.5-7sBWLGals8hBAV5DS9SEuc-ghc8.2.2.so (/home/d34df00d/Programming/readonly/hakyll/.stack-work/install/x86_64-linux-tinfo6/lts-10.2/8.2.2/lib/x86_64-linux-ghc-8.2.2/libHSskylighting-0.5-7sBWLGals8hBAV5DS9SEuc-ghc8.2.2.so: failed to map segment fr
15:26:53 <d34df00d> Wut?
15:28:22 <pushp0p> i thought haskell was the only safe language out there
15:28:47 <d34df00d> Ah, I have the partition mounted with noexec.
15:28:48 <Axman6> that's definitely untrue for at least two reasons
15:31:40 <geekosaur> the only truly "safe" languages are the non-turing-complete ones
15:31:51 <geekosaur> they're also the least useful languages...
15:32:00 <monochrom> What is "safe"?
15:33:44 <lijero> monochrom: provable termination, probably
15:34:26 <monochrom> Is that all?
15:34:48 <d34df00d> Why, you can refactor most of the business logic in the provably terminating part and isolate the full Turing completeness in a very small part.
15:34:53 <d34df00d> Just like you do with purity in Haskell.
15:36:05 <monochrom> I mean for example type-safety can be encoded as termination, but do you want the language to provide both directly, or do you want the language to provide just termination directly, and have each programmer do their own type-safety-to-termination reduction? Every time?
15:39:33 <d34df00d> geekosaur: yeah, after all the struggle I'm able to finally build that stuff, thanks a lot!
15:50:17 * hackage log-warper 1.8.5 - Flexible, configurable, monadic and pretty logging  https://hackage.haskell.org/package/log-warper-1.8.5 (shersh)
16:09:47 * hackage persistent-mysql-haskell 0.3.6 - A pure haskell backend for the persistent library using MySQL database server.  https://hackage.haskell.org/package/persistent-mysql-haskell-0.3.6 (naushadh)
16:16:59 <d34df00d> So how do I point stack to a local version of a package?
16:17:17 * hackage crypto-api 0.13.3 - A generic interface for cryptographic operations  https://hackage.haskell.org/package/crypto-api-0.13.3 (ThomasDuBuisson)
16:17:19 <d34df00d> According to https://docs.haskellstack.org/en/stable/yaml_configuration/#packages-and-extra-deps , adding `- ./hakyll` shall work, yet I get
16:17:27 <d34df00d> Error in $['extra-deps'][1]: failed to parse field 'extra-deps': (Invalid package identifier: "./hakyll","./hakyll")
16:22:36 <geekosaur> you are confusing packages with extra-deps
16:23:20 <geekosaur> oh, no, the docs are. and say as much
16:23:21 <d34df00d> geekosaur: but the docs say:
16:23:22 <d34df00d> > Like packages, local file paths can be used in extra-deps, and will be relative to the directory containing the stack.yaml file.
16:23:24 <lambdabot>  <hint>:1:14: error: parse error on input ‘,’
16:23:41 <geekosaur> yes, with a warning later that it will be parsed as a package spec
16:23:54 <d34df00d> So this is why I'm using this ./ stuff.
16:24:05 <d34df00d> Like the last example in that section shows.
16:24:51 <d34df00d> Anyway, what's the best approach if I'm going to use this hacked version of hakyll just locally?
16:25:40 <geekosaur> I think you really want it to be package dep, not extra-dep, since the point is you're hacking on it specifically
16:25:45 <geekosaur> (iirc)
16:27:31 <geekosaur> and if I had to guess, which apparently I do, things are actually a bit more complex than that doc says and it takes more than just leading "./" to make it not parse a package spec.
16:28:04 <geekosaur> (or, they decided this was too confusing and punted extra-deps paths entirely in favor of packages paths)
16:29:45 <d34df00d> geekosaur: right, so let me try just moving that to packages.
16:37:26 <fraktor> How do I turn on the profiler to determine which functions are taking the most time?
16:39:48 * hackage fast-arithmetic 0.1.0.7 - Fast number-theoretic functions.  https://hackage.haskell.org/package/fast-arithmetic-0.1.0.7 (vmchale)
16:41:31 <redrapscallion> if i have a qualified import, would there be any problems in using a part of package's name as the alias? (see http://lpaste.net/3015437396821934080)
16:42:28 <monochrom> No problem.
16:44:13 <geekosaur> no issue with it being part of the name. you can even do things like importing different modules "as" the same alias, as long as you avoid name conflicts between imported things
16:44:35 <geekosaur> (which iirc means you have to use the fully qualified name, not the alias, for those)
16:44:48 <fraktor> import qualified Data.Map as Map is very commonly done.
16:45:15 <geekosaur> haskell acts as if "Network.Wai.Handler.Warp" is one long name, not 4 components
16:53:30 <Axman6> fraktor: how are you building your application?
16:53:39 <fraktor> Nevermind; I figured it out.
16:56:14 <fraktor> I've got this function: http://lpaste.net/361362 that's taking up over a quarter of my runtime. Is there a way to make it more efficient, or should I just find a way to reduce calling it?
16:59:33 <mniip> fraktor, maybe make it INLINABLE
16:59:41 <fraktor> How can I do that?
16:59:56 <mniip> {-# INLINABLE isPositionValid #-}
17:00:00 <mniip> er
17:00:11 <mniip> yeah that
17:00:18 <mniip> INLINABLE, or INLINE for more insistence
17:02:17 * hackage ats-format 0.1.0.17 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.17 (vmchale)
17:03:07 <L0g4nAd4ms> how can i prevent haskell from using `Integer` when using `^` with a numeric literal ?
17:08:00 <Gurkenglas> Does some library provide the monoidal closure of sets under intersection? (ie sets and an added neutral element, a "full set". perhaps also the subsets of a set given by a property?)
17:08:06 <fraktor> By inlining my functions, it seems like runtime is going up. Is that possible, or is it due to some other factors?
17:08:17 <Gurkenglas> *"subsets of the full set"
17:09:49 <monochrom> @type (^)
17:09:50 <lambdabot> (Num a, Integral b) => a -> b -> a
17:10:23 <monochrom> L0g4nAd4ms: You can give explicit types, e.g., (5 :: Double) ^ (4 :: Int)
17:10:40 <geekosaur> I suspect what they really want is to avoid the defaulting warning
17:11:06 <L0g4nAd4ms> correct, i get a warning when having a^2 + b^2 = c^2 as a condition in a list comprehension for pythagorean triplets
17:11:11 <L0g4nAd4ms> geekosaur,
17:11:16 <geekosaur> so just explicitly specify the type, since (^) provides no other way to constrain it ("b" only appears once in a parameter type)
17:11:51 <geekosaur> you can also disable the defaulting warning if you're tripping it that often
17:12:20 <verement> or define another operator that appropriately constrains the type and use that instead
17:13:01 <L0g4nAd4ms> not very often, ok warning is now gone
17:13:04 <geekosaur> {-# GHC_OPTIONS -Wno-type-defaults #-}   (before ghc 8.0: -fno-warn-type-defaults)
17:13:08 <verement> though it's unfortunate that we have so many power operators already
17:13:23 <kakashiA1> the typeclass Fractional is the set of the types Float, Double and Complex
17:13:25 <kakashiA1> now if haskell gets the number 3.456, haskell will see the point and know that it belongs to the Fractional type class, but how does it know what type it is (not type class)
17:14:15 <monochrom> Sometimes the context determines the type.
17:14:37 <monochrom> When the context isn't enough, defaulting kicks in.
17:14:48 <monochrom> Read the Haskell 2010 Report on defaulting.
17:14:54 <monochrom> Read now.
17:16:10 <kakashiA1> monochrom: link?
17:16:57 <L0g4nAd4ms> thanks, no time anymore
17:17:35 <monochrom> https://www.haskell.org/onlinereport/haskell2010/
17:17:41 <kakashiA1> monochrom: thanks
17:19:36 <kakashiA1> monochrom: I cant find "defaulting"
17:19:40 <L0g4nAd4ms> offtopic: run this: https://repl.it/repls/DeliriousGreenOxpecker. spectre proof of concept
17:19:49 <monochrom> Read from cover to cover to find it.
17:23:19 <verement> kakashiA1: § 4.3.4
17:24:54 <crick_> Can someone please brief me on how to use functions from Control.Monad.Trans.Except?
17:25:44 <crick_> I want to translate the sample example from Control.Monad.Error knowing that it is deprecated.
17:26:37 <kakashiA1> verement: thanks
17:27:31 <kakashiA1> monochrom: https://paste.xinu.at/ti7/ :)
17:28:57 <crick_> I don't understand what throwE and catchE are doing!
17:31:41 <geekosaur> generally you don't want to use Control.Monad.Trans.* directly; they're intended for implementations (Control.Monad.Except in this case)
17:33:59 <crick_> okay
17:34:28 <geekosaur> as exposed in Control.Monad.Except, these are throwError and catchError, and there's a decent example there.
17:35:21 <geekosaur> the internals are intended for people biuilding actual implementations on top of the raw transformer and monads using either functional dependencies or type families; as such, they're not very useful by themselves
17:35:50 <geekosaur> because you need to know which of those two possibilities is being used by an actual monad implementation of it
17:37:00 <geekosaur> (mtl is the fundeps implementsation; monads-tf, which is still being maintained, is the type families implementation. there is also monads-fd, but that was the testbed for what is now mtl (2.x).)
17:37:44 <crick_> ohaky
17:38:10 <crick_> Basically ghc showed - Deprecated: "Use Control.Monad.Trans.Except instead"
17:38:37 <crick_> Hence I went to Control.Monad.Trans.Except instead of Control.Monad.Except
17:38:44 <monochrom> Which module did you use to get that?
17:38:45 <geekosaur> I suspect that's a holdover that should be fixed, or someone was not thinking about actual use cases or users thereof
17:39:32 <crick_> monochrom: I was using Control.Monad.Error
17:40:29 <geekosaur> for a long time ExceptT was a separate package; it was only merged into mtl relatively recently. since you'd have gotten transformers as a dependency anyway, I *think* that deprecation notice was just avoiding referencing what was at the time a separate package
17:41:36 <monochrom> I disbelieve you, because I have just checked Control.Monad.Error's source code and it should not be causing that message. It should be just causing "Use Control.Monad.Except instead".
17:42:09 <monochrom> So I conclude that you were using something else that pointed you to Control.Monad.Trans.Except
17:42:38 <geekosaur> unless they're using stack and an old resolver
17:42:39 <crick_> monochrom: Well...is there a way to post screenshots here?
17:42:52 <geekosaur> in which case they're getting an old version of mtl
17:43:39 <crick_> Ya that might be the case
17:44:41 <glguy> I disagree with not using the .Trans. modules directly, generally you don't want the mtl-classes
17:45:03 <geekosaur> and we don't usually use screenshots. granting that copying text on windows is soemwhat annoying, it's still possible (click the mini-icon in the window title)
17:45:10 <glguy> I also haven't ready about any of the backlog so that might not be helpful!
17:45:11 <geekosaur> right, religion time
17:45:21 <geekosaur> already had one of those today; please worship as you see fit
17:45:43 <glguy> It's just important to recognize the difference, use mtl if you want the typeclasses as an effect system approach
17:45:54 <glguy> it's not that transformers is secret implementation detail
17:50:18 <pierrot> I did `import Data.Either` but it doesn't export any `fromRight` function as I expected
17:50:55 <dmj`> :t rights
17:50:56 <lambdabot> [Either a b] -> [b]
17:51:50 <dmj`> pierrot: what do you think the type of fromRight should be
17:53:00 * geekosaur is "liking" how we immediately go for the unsafe / partial operation as the thing that "really ought to" exist
17:54:00 <geekosaur> :t either
17:54:01 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
17:55:27 <pierrot> in some situations, you already know that the `Either a b` value is of the form `Right x`
17:55:39 <pierrot> and I think it would be useful to have a function to unwrap it
17:56:49 <pierrot> dmj`: it would be `Either a b -> b`
17:57:47 <pierrot> and maybe it should fail with an error if it's fed with a `Left x`
18:02:24 <dmj`> pierrot: but what about that rare case when it’s a Left :)
18:02:58 <camsbury> hi guys
18:03:16 <camsbury> how would I create an Arbitrary instance for (a -> b) ?
18:03:36 <camsbury> I guess for TypeConstructor (a -> b)
18:03:47 <camsbury> which is actually TypeName a b
18:04:11 <camsbury> I know it probably has something to do with coArbitrary, but I'm lost on that one
18:05:55 <Axman6> you want to make arbitrary functions?
18:05:56 <eschnett> camsbury: there is a special mechanism to create arbitrary functions, if that's what you're asking. the QuickCheck documentation should have the details. look for "Fun" or "Fn".
18:06:13 <camsbury> okay thanks!
18:07:42 <dmj`> Test.QuickCheck.Function
18:07:45 <camsbury> ah looks like (Arbitrary a, CoArbitrary b) => Arbitrary (a -> b)
18:08:09 <camsbury> oh no, opposite of what i said
18:23:03 <kakashiA1> increment x = x + 1  has the typesignature increment :: Int -> Int   which means: function "increment" takes one argument of type Int and returns Int
18:23:30 <kakashiA1> 3.456 has the typesignature  3.456 :: Fractional a => a -> a
18:23:38 <kakashiA1> biw what is the first argument of that?
18:23:42 <kakashiA1> I mean its just a value
18:24:59 <kakashiA1> but why has 3.456 a signature of a function with one argument?
18:26:28 <Axman6> kakashiA1: it shouldn't, but it will depend on how you're using it
18:26:38 <Axman6> I think you're leaving out some important code
18:26:49 <Axman6> :t 3.456
18:26:49 <lambdabot> Fractional p => p
18:36:38 <Axman6> :t (\f -> map f [1.0,2.0,3.0]) `asAppliedTo` 3.456
18:36:39 <lambdabot> (Fractional (a -> b), Fractional a) => (a -> b) -> [b]
18:38:56 <fraktor> Is there a function that transforms [[a, b], [c, d]] into [[a, c], [b, d]] ?
18:39:34 <glguy_> Transpose
18:43:59 <int-e> > fix ((0:) . (1:) . map sum . transpose . take 2 . tails)
18:44:01 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:45:59 <Gurkenglas> > fix $ \x -> 0 : 1 : zipWith (+) x (tail x)
18:46:01 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:47:29 <byorgey> int-e: nice =)
18:50:08 <byorgey> > fix $ (0:) . (1:) . map succ . scanl1 (+)
18:50:10 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:54:57 <glguy> > [ showCReal 0 ((phi ^ n - (- phi) ^^ (-n)) / (2 * phi - 1)) | n <- [0..]]
18:55:02 <lambdabot>  mueval-core: Time limit exceeded
18:55:09 <glguy> > [ showCReal 0 ((phi ^ n - (- phi) ^^ (-n)) / (2 * phi - 1)) | n <- [0..]] -- one more try
18:55:15 <lambdabot>  mueval-core: Time limit exceeded
18:55:23 <glguy> Well, sometimes it works in /msg :)
18:55:33 <glguy> > take 10 [ showCReal 0 ((phi ^ n - (- phi) ^^ (-n)) / (2 * phi - 1)) | n <- [0..]]
18:55:35 <lambdabot>  ["0","1","1","2","3","5","8","13","21","34"]
18:56:17 <byorgey> nice.  Is phi already defined in CReal?  Or did you sneakily define it in @let ?
18:56:41 <glguy> let phi :: Floating a => a; phi = (1 + sqrt 5) / 2
18:56:58 <byorgey> yes, I know what phi *is*, just wondering where it was bound =)
18:57:13 <glguy> That's how I defined it
18:57:33 <byorgey> ok.
18:59:42 <byorgey> I was about to say I was surprised that the library never got stuck deciding whether the answer was e.g. 34 vs 33.99999....   but then I noticed 'showCReal 0', does that mean to round to 0 decimal places?
19:00:41 <glguy> > take 10 [ showCReal 2 ((phi ^ n - (- phi) ^^ (-n)) / (2 * phi - 1)) | n <- [0..]]
19:00:42 <lambdabot>  ["0.0","1.0","1.0","2.0","3.0","5.0","8.0","13.0","21.0","34.0"]
19:00:52 <glguy> Yeah, it tells how much precision you want
19:23:14 <MarcelineVQ> kakashiA1: 3.456 does not have the type  Fractional a => a -> a
19:24:48 * hackage nvvm 0.8.0.2 - FFI bindings to NVVM  https://hackage.haskell.org/package/nvvm-0.8.0.2 (TrevorMcDonell)
19:44:54 <Cale> :t 3.456
19:44:55 <lambdabot> Fractional p => p
20:37:12 <dysfigured> in 140 characters or less, do your best to explain functors
20:37:38 <dysfigured> ideally in a manner that assumes no knowledge of category theory or haskell
20:40:18 <Axman6> :t fmap
20:40:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:40:54 <dysfigured> >ideally in a manner that assumes no knowledge of category theory or haskell
20:41:01 <Axman6> you don't need to undertstand CT to understand functors at all
20:41:11 <Axman6> it's just map, but generalised to many different types
20:41:57 <dysfigured> i'm trying to write a blog post explaining some basic category theory, i think i did a pretty good job of monoids, but for some reason i'm struggling with properly explaining functors even though they're super simple
20:42:07 <Axman6> something is a functor if it has the ability to take a function which accepts a's, and apply it to all the a's "in" the thing, while keeping its shame the same
20:42:24 <Axman6> shape*
20:42:38 <Axman6> (but of course, maintaining shape also means maintaining shame)
20:42:42 <dysfigured> heh
20:45:35 <EvanR> a functor is an embedding of one category in another
20:46:24 <EvanR> or possibly itself
20:46:32 <dysfigured> oh. embedding. that's an interesting perspective
20:49:57 <EvanR> its the same idea as a homomorphism
20:50:33 <EvanR> a functor is a category morphism
20:52:22 <dysfigured> i'm still new to all this myself, i just like writing about things that i learn hoping that i can find new insight into the thing by trying to explain it
20:53:32 <dysfigured> i understand that a morphism is like an edge in a graph between two categories, describing a transformation.. but what is a homomorphism
20:57:38 <beauby> dysfigured: A homomorphism is just a morphism, the two terms are interchangeable
20:57:44 <dysfigured> oh. hm.
20:58:27 <dysfigured> does that imply there are heteromorphisms?
21:08:13 <ReinH> In algebra, a homomorphism is a structure-preserving map.
21:08:53 <ReinH> But then, so are morphisms.
21:09:09 <fraktor> Does the any function short-circuit? By profiling some code I'm using, it seems like it isn't.
21:09:16 <ReinH> @src any
21:09:16 <lambdabot> any p = or . map p
21:09:21 <ReinH> @src or
21:09:21 <lambdabot> or = foldr (||) False
21:09:29 <ReinH> > True || undefined
21:09:31 <lambdabot>  True
21:09:32 <ReinH> Yes.
21:10:03 <ReinH> > any id [True, undefined]
21:10:05 <lambdabot>  True
21:10:13 <ReinH> any short-circuits.
21:11:18 <fraktor> Does foldr calculate the entire list?
21:11:33 <EvanR> not necessarily
21:12:11 <ReinH> fraktor: I've just shown you that it doesn't necessarily.
21:12:18 <fraktor> I see.
21:12:50 <EvanR> > foldr (\x y -> x) 0 [1..]
21:12:51 <lambdabot>  1
21:13:36 <ReinH> > foldr (const . Just) undefined [1..]
21:13:38 <lambdabot>  Just 1
21:14:00 <ReinH> > foldr (const . Just) Nothing []
21:14:02 <lambdabot>  Nothing
21:14:14 <ReinH> foldr (const . Just) Nothing is an implementation of safeHead.
21:16:53 <ReinH> Actually, perhaps you want to know two different things: whether it's strict in the spine and whether it's strict in the values.
21:17:06 <fraktor> Spine and Values?
21:17:08 <ReinH> And the answer is no to both, depending on the strictness of the function you fold over.
21:17:19 <ReinH> the constructors of the list
21:18:36 <ReinH> https://upload.wikimedia.org/wikipedia/commons/3/3e/Right-fold-transformation.png
21:19:07 <ReinH> > foldr (const . Just) Nothing [1..] -- the spine of the list is not forced
21:19:09 <lambdabot>  Just 1
21:19:27 <ReinH> > foldr (const . Just) Nothing [1, undefined] -- values not demanded by the folding function are not forced
21:19:29 <lambdabot>  Just 1
21:20:29 <fraktor> Would you mind if I showed you the code so I could give a more concrete example?
21:20:38 <ReinH> Sure.
21:20:38 <mozzarella> I wish I knew how to code in haskell
21:21:00 <fraktor> mozzarella: I know the feeling.
21:21:16 <fraktor> http://lpaste.net/361364
21:21:52 <fraktor> It seems that inSpace is being evaluated every time for every list (roughly speaking by napkin math on the profiling data).
21:24:26 <ReinH> Well, there are a number of inefficiencies. I'm not sure what might be causing that perception.
21:24:54 <fraktor> What are they?
21:24:59 <ReinH> length xs > 1 forces the whole spine of xs when you only need to check if the list is [] or (x:[]).
21:25:10 <ReinH> xs ++ [x] forces the whole spine of xs
21:26:20 <ReinH> (I sometimes wish that Prelude, or at least base, provided a list length using natural numbers so that the first could be made efficient without throwing away the ergonomics of length xs > 1)
21:28:00 <fraktor> I've changed it to (not . null) (drop 1 xs). Is that better?
21:28:20 <ReinH> Well, it'll prevent having to force the whole spine of xs, so probably
21:29:34 <fraktor> Also, I've looked at the part you're talking about, and those are not a huge issue, since a) the lists are fairly small (we're talking no more than 15) and b) they're only computed once in the program.
21:31:19 <jle`> ReinH: isn't that what genericLength does?
21:31:37 <ReinH> fraktor: If those lists are small then why does it matter whether any short-circuits?
21:31:51 <ReinH> @jle` I don't know if it's productive.
21:31:51 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
21:31:54 <ReinH> Ugh sorry
21:31:59 <ReinH> @src genericLength
21:31:59 <lambdabot> genericLength []    = 0
21:31:59 <lambdabot> genericLength (_:l) = 1 + genericLength l
21:32:21 <jle`> it depends on how + is implemented on your natural number type i suppose
21:32:36 <fraktor> searchSpaces is small, but the list I'm filtering over is not.
21:32:39 <jle`> but it appears to associate properly
21:32:49 <fraktor> @src length
21:32:49 <lambdabot> Source not found. You untyped fool!
21:33:04 <fraktor> Well then. I guess that's what I get
21:33:09 <ReinH> jle`: BTW your blog post on uncertainty propagation has a footnote ^2 in math notation which makes it look like you're squaring something.
21:33:12 <EvanR> thats odd
21:33:20 <jle`> fraktor: surprise -- length is now a typeclass method :)
21:33:20 <EvanR> :t length
21:33:21 <lambdabot> Foldable t => t a -> Int
21:33:27 <jle`> ReinH: thanks for the heads up :)
21:33:33 <EvanR> :t genericLength
21:33:34 <lambdabot> Num i => [a] -> i
21:33:40 <EvanR> funky
21:33:40 <ReinH> fraktor: But any isn't concerned with the length of the list you're filtering over
21:33:53 <ReinH> you don't pass that list to any
21:34:02 <ReinH> you pass *elements* of that list to inSpace and then pass that to any.
21:34:07 <fraktor> But if I can get it to only filter over half of the search spaces, then it should still cut the run time in half.
21:34:15 <fraktor> (approximately)
21:34:18 <EvanR> superGenericLength :: (Foldable t, Num i) => t a -> i
21:34:48 <jle`> heh
21:34:49 <ReinH> fraktor: Ok, but first we have to agree that any isn't operating on that list
21:34:57 <fraktor> Absolutely.
21:35:27 <ReinH> filter is a good producer, but it will scrutinize the whole list if something that consumes the filter demands it
21:35:48 <ReinH> s/the filter/the filtered list
21:36:02 <ReinH> One thing that sometimes trips people up is that
21:36:06 <ReinH> > filter (< 5) [1..]
21:36:10 <ReinH> won't know when to stop
21:36:12 <lambdabot>  mueval-core: Time limit exceeded
21:36:38 <ReinH> whereas
21:36:39 <fraktor> Calculating the lists that I'm using any to filter over is not the issue.
21:36:44 <ReinH> > takeWhile (< 5) [1..]
21:36:44 <ReinH> will
21:36:45 <lambdabot>  [1,2,3,4]
21:36:53 <fraktor> * that I'm applying any to
21:37:17 <ReinH> fraktor: Ok, but we've established that the problem can't be where you originally thought it was, so maybe you need to reevaluate where the problem is.
21:38:19 <fraktor> Where I thought the problem was was that the function isSpace (which is taking up 47.7 percent of my runtime) is being called spaces*words times, where it should be significantly less than that if any short-circuits.
21:39:19 <ReinH> well, asymptotically it will be called spaces*words times. any short-circuiting can only reduce the constant factors.
21:39:45 <fraktor> As far as big O goes? Yes.
21:40:03 <fraktor> but I mean I took the number of words, took the number of spaces, multiplied them, and got approximately the number of calls to isSpace.
21:40:04 <exio4> ReinH: is that a general statement?
21:40:13 <ReinH> exio4: Is what a general statement?
21:40:37 <exio4> that short circuiting will only reduce the constant factors
21:41:42 <ReinH> It's somewhat general
21:42:13 <ReinH> If you have an algorithm that is O(n*m) and short-circuiting can, on average, reduce n or m, then it only improves constant factors.
21:42:47 <ReinH> If, on average, you only have to check half of the list, then it is O(n*m/2), which is still O(n*m)
21:42:56 <fraktor> That is correct.
21:43:13 <beauby> fraktor: Try running the same benchmark with a naive implementation of isSpace (one that you are certain does not short-circuit), and compare the times
21:43:22 <ReinH> beauby: great idea
21:43:38 <fraktor> isSpace doesn't short-circuit.
21:43:43 <fraktor> I'm sorry I'm not explaining this well.
21:44:23 <ReinH> a naive implementation of any, then
21:44:30 <beauby> Or whichever function calls isSpace in your code
21:44:34 <ReinH> foldl (||) True . map p
21:44:39 <fraktor> I'm expecting isSpace, which is being called by any, to be called significantly less than (spaces*words) times, since any short-circuits, and isSpace should return true roughly half the time (unless I'm not understanding my problem correctly).
21:45:04 <beauby> fraktor: Right, then benchmark with a naive implem of any
21:45:32 <ReinH> Ok, but let's say that any is being called on m
21:45:49 <ReinH> If n is much larger, as you say it is, then the runtime of the algorithm is dominated by the size of n
21:45:51 <fraktor> ReinH: that implementation always returns true.
21:46:00 <ReinH> and a reduction in the size of m isn't very important
21:46:18 <fraktor> (n/2)*m == n*(m/2)
21:46:36 <ReinH> Yes, but now we're talking about runtime, not algorithmic complexity, and there are transaction costs
21:48:33 <fraktor> True
21:49:28 <exio4> fraktor: O(nm/2) is the same as O(nm) so why optimize? >:P
21:50:31 <fraktor> Reducing either one by half would improve runtime costs, though not by half due to transaction costs.
21:51:18 <fraktor> Also, I'm now convinced that any is short-circuiting, because I get different numbers of calls if I reverse the list first.
21:51:27 <ReinH> Anyway, I don't think that your evidence about the cost of isSpace shows that any isn't short-cirtuiting.
21:51:44 <ReinH> Also I already proved that any is short-circuiting
21:52:15 <fraktor> But they're both at least 99 percent of spaces*words, which I still don't understand.
21:52:35 <ReinH> What is "they"?
21:53:07 <fraktor> the number of calls to isSpace, both with a reversed and non-reversed list.
21:54:10 <ReinH> I mean, that algorithm calls inSpace about n*m times so I'm not sure why that's surprising.
21:54:16 <fraktor> Surely if most of the time I need to go to the end of the list when it's not reversed, then I should be near the beginning of the list when it *is* reversed.
21:55:08 <ReinH> Or maybe the distribution is symmetric
21:55:27 <ReinH> maybe sometimes it's near the beginning and roughly the same amount of time it's near the end.
21:55:42 <fraktor> Then why is it running as if it needs to go the end 99% of the time in both cases?
21:55:43 <ReinH> Maybe there's a way you could sort the list to make it more likely that it's near the beginning.
21:56:14 <fraktor> I tried that by sorting by length. It made no noticeable difference. I don't know of a better way.
21:56:28 <ReinH> It doesn't seem likely to help in any event.
21:56:46 <ReinH> Not with such small lists.
21:57:36 <ReinH> Uh, you're doing (++h) and then sorting.
21:58:02 <fraktor> I've sinced removed that part; I'm now just doing (++h).
21:58:34 <fraktor> Should I create a new paste with the new code?
21:58:49 <ReinH> Sure
21:58:57 <ReinH> Some other facts that may or may not be useful
21:59:06 <ReinH> filter (p && q) = filter p . filter q
21:59:25 <fraktor> Makes sense.
21:59:42 <ReinH> I'll give you that one for free. (Because it's a free theorem.)
21:59:43 <fraktor> BTW, I updated the code, but it should be the same link.
22:02:09 <ReinH> I suspect that some equational reasoning could yield a more efficient solution. Have you seen Richard Bird's Sudoku solver?
22:02:19 <fraktor> I haven't.
22:02:26 <ReinH> http://www.cs.tufts.edu/~nr/cs257/archive/richard-bird/sudoku.pdf
22:02:49 <ReinH> It's probably somewhat similar to what you're doing. Also his entire Pearls of Functional Algorithm Design book might be useful.
22:03:24 <ReinH> What problem is this solving?
22:03:56 <fraktor> Finding playable words given a scrabble board and hand.
22:04:12 <fraktor> So yes, very similar.
22:04:58 <ReinH> Yeah, I bet something from Bird's bag of tricks might be useful here.
22:05:07 <fraktor> My approach here is to determine whether each word can be spelled using only the letters in each row or column combined with the hand.
22:05:59 <ReinH> Maybe there's a way to reduce the search space beforehand
22:06:18 <fraktor> This is the function that reduces the search space.
22:06:47 <ReinH> Right, I mean, like, a better one. :D
22:07:05 <ReinH> Sorry, what I really mean is perhaps to do it in phases
22:07:14 <ReinH> starting with cheaper but less restrictive methods
22:08:37 <fraktor> Oh wait!
22:09:06 <fraktor> I just realized that I'd been doing a naive method before that was working relatively well (reducing 62000 words to 5000, whereas this reduces it to 1000)
22:10:09 <ReinH> Yeah
22:10:59 <fraktor> So if I use the fast method, then run *that* through the slow method, it should be faster. Right?
22:11:13 <ReinH> For instance, you can't use words that contain letters that exist in neither your hand nor the board
22:11:21 <ReinH> So if you keep a set of all known letters on the board, you can use that.
22:11:33 <fraktor> That's actually what the previous method was.
22:13:13 <sqooq> http://lpaste.net/2277482867711803392
22:13:17 <sqooq> this is impossible right?
22:13:21 <sqooq> this if I'm not mistaken
22:13:24 <sqooq> is the correct "flow"
22:13:43 <sqooq> but out calls s and s calls out
22:14:38 <dmwit> :t mfix
22:14:39 <lambdabot> MonadFix m => (a -> m a) -> m a
22:14:45 <dmwit> sqooq: See also `mdo`
22:15:49 <dmwit> sqooq: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-recursive-do-notation
22:16:43 <fraktor> Yep. That worked quite a bit.
22:19:16 <sqooq> dmwit, omg thanks
22:20:19 <sqooq> ...I'm just getting zeros rip
22:22:14 <sqooq> actually it's stuck
22:22:25 <sqooq> rip
22:46:22 <dfeuer> Ping ekmett
22:46:56 <dfeuer> Ping edwardk
23:29:44 <Linat0k> C till i die
23:29:51 <Linat0k> native code till  die
23:30:02 <Linat0k> nativve
23:30:17 <Linat0k> your all traitors
23:44:41 <Axman6> Linat0k: you know Haskell compiles to native binaries right? It also has a great C FFI, so you can resort to C if you want to
23:46:19 <MP2E> C is not really native, either. It's an abstraction layer that gets compiled to assembly. Even if you write assembly, that's just a farce, in the end!
23:46:25 <MP2E> That gets compiled down to microops and optimized in processor
23:46:30 <MP2E> :D
23:46:36 <Axman6> microcode4lyf
23:46:54 <Axman6> VHDL4lyf
23:47:04 <exio4> how can you even exploit your processor from C?
23:47:58 <LiaoTao> Sure you can, if you include assembly opcodes as data :^)
23:47:59 <Axman6> well, it turns out you can do that from javascript, so pretty easily I guess!
23:49:09 <DigitalKiwi> Axman6 hehe
23:49:23 <exio4> I guess JS is a very low level language then
23:51:47 * hackage EdisonCore 1.3.2.1 - A library of efficient, purely-functional data structures (Core Implementations)  https://hackage.haskell.org/package/EdisonCore-1.3.2.1 (RobertDockins)
23:52:47 <Axman6> woah... EdisonCore... that used to be a thing when I first started learning Haskell!
23:52:56 <Axman6> that was 10 years ago now
