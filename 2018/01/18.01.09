00:24:08 <kakashiAL> why is this not valid?:
00:24:10 <kakashiAL> [a | a :: Int, a > 0, a < 2]
00:25:08 <boj> what is `a`?
00:25:37 <cocreature> kakashiAL: what do you expect that to do?
00:25:38 <kadoban> kakashiAL: It's not a logic programmer, it just follows some rules. None of them are like, inferring what range of values would be possible based on guards like that.
00:27:17 <cocreature> you could do [ a | a <- enumFromTo minBound (maxBound :: Int), a > 0, a < 2] but that will just walk through all integers and test if they match the predicate which will be terribly slow
00:27:56 <shiona> I was just about to write that best haskell could automatically do is what cocreature just coded
00:28:05 <liste> kakashiAL: a:: Int is not an expression
00:28:09 <liste> a > 0 and a < 2 are
00:28:51 <liste> (well technically it is, but it's not Boolean)
00:28:51 <kadoban> I don't think I agree with that. It certainly *could* do better in this case. It just wouldn't be very general, and I doubt it'd add expressive power or anything, this is kind of just a funky verbose syntax for what we already can do easily.
00:33:10 <shiona> Ok, I meant it could not do better in a sensible general case. I don't think I would make sense to add features as specific as syntax sugar for list comprehensions for well ordered (or some other definition of ordered) values.
00:33:28 <shiona> And of course with the additional requirement that the lower bound is given
00:34:19 <kadoban> Yes, it certainly doesn't make sense to add something like that to me.
00:35:47 <shiona> Actually I would consider that a fine intuition why kakashiAL's example could not work. List comprehension returns a list, so the order of values is meaningful. [ a | a :: Int, a > 0, a < 3 ] could be either [1,2] or [2,1], since there is absolutely nothing to hint the ordering of the values
00:41:40 <[exa]> #haskell hitting undecidability this early in the morning? :]
00:44:34 <vaibhavsagar> kakashiAL: in addition to everything else, this is a list comprehension and there is no list on the RHS of the `|`
00:46:04 <kakashiAL> liste: thanks, "its not an expression" makes sense :)
00:46:28 <kadoban> Neither is   x <- [2 .. 8]
00:47:12 <kadoban> But ignore that, not a useful comment. Sleep time xD
00:47:13 <kakashiAL> kadoban: I dont agree, I follow the cambride haskell book that call this an expression, which also makes sense for me, but I dont want to start a flamewar on that
00:48:01 <kadoban> Well, I mean it actually isn't an expression, but here that doesn't really matter.
00:48:04 <vaibhavsagar> kakashiAL: do you know how list comprehensions map to do-notation?
00:48:34 <kadoban> :t (x <- [1 .. 5]) -- this should work if it were an expression
00:48:36 <lambdabot> error:
00:48:36 <lambdabot>     parse error on input ‘<-’
00:48:36 <lambdabot>     Perhaps this statement should be within a 'do' block?
00:49:07 <vaibhavsagar> > [x | x <- [0..5], x>0, x<3]
00:49:10 <lambdabot>  [1,2]
00:49:46 <kakashiAL> vaibhavsagar: I did not spend time with the "do-notation" but I see x <- [1..5] as an expression, that only makes sense in the comprehension notation
00:49:59 <vaibhavsagar> > do {x <- [0..5]; guard (x > 0); guard (x < 3); return x}
00:50:02 <lambdabot>  [1,2]
00:50:05 <[exa]> kakashiAL: it's in fact monadic value binding
00:50:12 <cocreature> the whole list comprehension is an expression "x <- [1..5]" on its own is not
00:50:50 <kadoban> kakashiAL: I don't think that's a useful view of what an expression is. They all have types, they can be manipulated, you can assign names to them, etc. It doesn't fulfill really any of those requirements.
00:51:17 <kakashiAL> [exa]: if you give the child another name that I dont understand it does not make it clear, better would be to ask "do you know what a monadic value is" (just in an educational point of view) :)
00:52:32 <[Leary]> You don't really need to know anything about monads. The important point is that within the comprehension scope a <- l binds a. Without that you're trying to use an unbound variable.
00:52:35 <kakashiAL> kadoban: I do not disagree with you, I respect and accept your opinion, what I say and the cambridge book is that it makes sense (in an cognitive point of view) to see this as an expression (even if its only there)
00:52:52 * hackage hadolint 1.2.6 - Dockerfile Linter JavaScript API  https://hackage.haskell.org/package/hadolint-1.2.6 (lorenzo)
00:53:25 <kakashiAL> [Leary]: I would say that I know to 60% what monads are (maybe more) :)
00:54:15 <vaibhavsagar> kakashiAL: do you see how the list comprehension and my rewrite give the same result?
00:54:56 <[exa]> kakashiAL: oh it was only about naming :] sorry, got confused by scrollback. Better call it 'syntactic sugar' though or something, 'expression' carries a very different meaning here (i.e. it should have a type, which a<-x doesn't directly have afaik
00:56:05 <kakashiAL> vaibhavsagar: I saw your rewrite if you mean this: do {x <- [0..5]; guard (x > 0); guard (x < 3); return x}   but I would say its not fair to talk about it, because I dont want to wast your time because I didnt spend time with the do notation, its syntax and so on
00:56:08 <[exa]> btw is there any real usage of polymorphic kinds? (or any more complicated kind inference?)
00:56:50 <cocreature> [exa]: Proxy is often used in a polykinded way to pass around type-level numbers or strings
00:58:29 <[exa]> yeah, that'd be valid. Thanks
01:00:29 <tdammers> kakashiAL: I disagree on the "makes sense to see this as an expression" part
01:01:12 <tdammers> being an expression suggests that you can apply substitution-based reasoning on the whole thing or its parts, but you can't
01:02:47 <ertes-w> ello
01:03:36 <piyush-k`> the type Void seems to be in a separate package instead of being in base. Is there any reason for this ?
01:04:00 <ertes-w> [exa]: Category is also a valid use case: objects are no longer constrained to be of kind *
01:06:13 <ertes-w> @let newtype Trans f g = Trans { applyTrans :: forall a. f a -> g a }; instance Category Trans where id = Trans id; Trans f . Trans g = Trans (f . g)
01:06:16 <lambdabot>  Defined.
01:06:30 <[exa]> :k Trans
01:06:32 <lambdabot> (k -> *) -> (k -> *) -> *
01:06:57 <[exa]> yeah.
01:10:14 <vaibhavsagar> piyush-k`: I think it's that way for compatibility all the way back to Haskell 98
01:10:36 <[exa]> is there a some search engine where I could find packages that use Trans?
01:10:57 * [exa] kindof curious to see that in action
01:11:16 <vaibhavsagar> [exa]: that looks like (~>)
01:11:43 <vaibhavsagar> https://hackage.haskell.org/package/natural-transformation
01:11:43 <Unhammer> If I want to compile a haskell server to run on freebsd from my linux machine, is it easiest to just virtualbox a freebsd installation, or is there a more lightweight way?
01:12:16 <merijn> Unhammer: compiler in a VM like virtualbox is definitely going to be the least frustrating way
01:12:35 <merijn> Unhammer: Because cross-compilation is a bitch and if you can avoid it, you should
01:13:09 * [exa] remembers the easy cross compilation days with autotools
01:14:02 <merijn> [exa]: That's only easy in the sense of "hundreds of others invested hundreds of hours in making the hard thing work", but that manpower is lacking in Haskell, so you'll have to do all that yourself :p
01:14:18 <tdammers> particularly, cross compiling Haskell is problematic because of things like TemplateHaskell
01:14:30 <[exa]> vaibhavsagar: yeah that's it, thanks
01:15:16 <[exa]> tdammers: that's isomorphic to "crosscompiling C is problematic because people mess it up with macros"
01:15:46 <merijn> [exa]: Not really
01:16:04 <merijn> [exa]: TH is problematic in fundamental theoretical ways, not just implementation fuckups
01:16:05 <tdammers> [exa]: no, it's not. C macros don't depend on C code, you don't need to compile anything before running CPP
01:16:45 <[exa]> ok, you surprise me
01:16:47 <merijn> [exa]: i.e. it's not that "cross-compiling TH doesn't work" (well, a bit of that too), but more importantly "it's unclear what cross-compiling TH is even *supposed* to do"
01:16:53 <Unhammer> ok, thanks merijn
01:17:18 <[exa]> I thought that TH is one level simpler.
01:17:21 <geekosaur> btw. re search engine, if you know the package it's from there is http://packdeps.haskellers.com/reverse
01:17:38 <[exa]> geekosaur: great, thanks
01:17:39 <geekosaur> TH isn't simple
01:17:47 <merijn> [exa]: Like, if my TH makes use of Storable or whatever and my host arch has Int with a size of 32bit and the target has Int with size of 64bit, which storable instance should my TH use at compile time?
01:18:22 <tdammers> the big picture is fairly clear; you have to first compile the TH, and then run it in order to generate AST to inject into the compilation unit
01:18:58 <piyush-k`> vaibhavsagar: thanks for the info on Void. Is it the case that Haskell98 does not allow EmptyDataDecls
01:19:02 <piyush-k`> ?
01:19:03 <tdammers> the devil is the details though
01:19:06 <merijn> piyush-k`: Yes
01:19:14 <geekosaur> 98 doesn't, 2010 does
01:19:41 <[exa]> merijn: well, nothing better than an error message (exactly as when mixing different ABIs in lowlevel)
01:19:49 <vaibhavsagar> piyush-k`: I believe so, it's listed as a Haskell Prime feature: https://prime.haskell.org/wiki/EmptyDataDecls
01:20:10 <vaibhavsagar> but I don't have any other sources for that info and I could be wrong
01:20:27 <[exa]> merijn: but well, cross-compilation involves simulating a bit of the target architecture
01:20:28 <merijn> [exa]: Why? The problem no one ever sat down, thought long and hard about what exactly TH promises and how that should map to cross-compilation
01:20:33 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-680004.2
01:20:43 <geekosaur> as of Haskell2010, empty data declarations are standard
01:20:51 <geekosaur> (see "topdecl")
01:21:11 <tdammers> or what if your code uses System.FilePath, and you're cross compiling from Linux to Windows
01:21:44 <merijn> [exa]: TH logically executes on the compiling machine to generate code, so in a cross-compilation setting we may have code executing on a machine whose instances/etc. have properties X, which don't match the generated code. You'd have to somehow parameterise TH over arch/etc. to make it sensible
01:21:49 <tdammers> in order to resolve file paths on the TH side at compile time, you would have to use the Posix flavor, but you want to generate code for the Windows flavor
01:22:15 <[exa]> merijn: I need to read about TH a bit more, I only used it as a scheme-like macro engine so far so I'm probably missing a bit of that
01:22:19 <tdammers> but conditional compilation with CPP in the System.FilePath module will have to make a choice at compile time, for one or the other
01:22:56 * piyush-k` surprised that Haskell98 folks did not notice that there was no way to define an empty type in the language.
01:23:21 <merijn> [exa]: TH can run arbitrarily complex code at compile time
01:23:31 <[exa]> merijn: but well, if it needs to compute stuff as on target, it will need to simulate the target (just as C inliners and linkers do)
01:23:36 <merijn> piyush-k`: No one thought it was important at the time
01:23:37 <tdammers> so the TH will use the correct one for its compile-time filesystem access, but when you try to emit references to anything defined in System.FilePath for use at runtime, you have a problem
01:23:38 <nschoe> Hi all
01:23:59 <merijn> [exa]: Right, but there's no theory/tooling to sensibly decide what has to be simulated
01:24:17 <[exa]> yeah I know.
01:24:20 <tdammers> it would be less of a problem if TH were completely separate, with its own namespacing and scoping and imports and all
01:24:24 <piyush-k`> merijn: Even if there was no EmptyDataDecls, just postulating a Void type as a built in type would have done the trick
01:24:40 <[exa]> Thanks for pointing that out anyway, I've got one more thing to consider :]
01:24:51 <geekosaur> there's worse problems too, insofar as it may need to load compiled modules.
01:25:13 <merijn> piyush-k`: Lots of things that seem obvious and universal in Haskell now weren't invented until way after Haskell was :)
01:25:15 <geekosaur> there *is* some work being done on this, it's the reason -fexternal-interpreter exists
01:25:47 <geekosaur> the current plan is you have that running in an emulator for the target, or possibly on the target, and it will satisfy such modules from its own (native) packages
01:26:32 <tdammers> personally I think that having namespaces and imports serve both plain and TH code at once was a mistake
01:26:46 <merijn> piyush-k`: Monadic IO wasn't invented until 7 years after the first Haskell report, Applicative wasn't invented until 2004, the latest ecosystm conquering abstraction seems to be Profunctors and Profunctor optics, which are from, like, 2011-2012
01:26:47 <piyush-k`> merijn: Was 1998 that far in history, proof assistants would have been standard by that time and the crowd there (in the Haskell98 committee) am sure had all the background (After all they included Monads to do IO)
01:27:04 <piyush-k`> Sorry Monads not in Haskell98 ?
01:27:26 <merijn> piyush-k`: Monadic IO was first added in Haskell Report 1.4 in 1997, but the first Haskell Report dates to 1990
01:27:42 <merijn> Haskell98 was not the first Haskell Report
01:28:25 <merijn> If anything, given how incremental 2010 was, Haskell98 is more like the *last* report :p
01:29:01 <piyush-k`> merijn: that is not a happy thought
01:29:14 <merijn> Well, maybe the current Haskell Prime effort will fix that :)
01:30:03 <piyush-k`> history is amazing
01:30:20 <piyush-k`> I mean in retrospect ofcourse
01:31:24 <[exa]> lol
01:31:43 <tdammers> I tend to think of it as a very comforting thought actually
01:31:52 <tdammers> it signals a certain degree of maturity
01:32:01 <[exa]> They could generally do something about import backend semantics (hell there's trouble to port that even to arch linux)
01:32:05 <[exa]> </troll>
01:32:07 <merijn> Lennart Augustsson gave a nice talk on the history of Haskell at IFL a few years ago
01:33:06 <sphinxo>  why does the ghc-static package not include static versions of stm or mtl?
01:33:18 <sphinxo> (  the arch linux package )
01:33:29 <sphinxo>  ( which are distributed with ghc: https://github.com/ghc/ghc/tree/master/libraries )
01:35:14 <merijn> sphinxo: I've given up trying to understand Arch packaging logic :p
01:35:49 <[exa]> sphinxo: the general arch advice: make yourself a favor and install from stack
01:36:52 <sphinxo> [exa]: I do normally use stack, but I just have this special case and I'm only installing the system ghc for the first time now
01:38:15 <[exa]> sphinxo: from arch wiki: "Unfortunately, if your project depends on any of the haskell-* packages that you have installed, Cabal does not take the absence of static libraries into account during dependency resolution. As a result, it will try to use the existing haskell-* package and then fail with linker errors when it realizes the static libraries are missing. Unlike ghc-static, there are no
01:38:21 <[exa]> “haskell-*-static” packages to fix this problem."
01:38:34 <geekosaur> I like the way they try to make it sound like haskell's fault
01:38:50 <[exa]> yep.
01:38:59 <geekosaur> when they're the ones that (a) ripped everything apart (b) changed all the packages to remove all static libraries
01:39:25 <[exa]> sphinxo: there are some other workarounds there: https://wiki.archlinux.org/index.php/Haskell
01:39:27 <merijn> piyush-k`: I'm assuming you're piyushkurur on reddit, so I was wondering why you were asking whether new-build etc. has support for building GHC? I haven't had to build GHC in years, you can just install the bindist in like 10s on any unix system
01:39:53 <sphinxo> [exa]: yeah that's not even what I'm running against, the ghc-static package which is supposed to contain all the static boot libraries
01:39:59 <geekosaur> ghc is not designed to build with cabal at all
01:40:03 <geekosaur> it uses makefiles
01:40:04 <sphinxo> doesn't arbitrarily
01:40:19 <merijn> sphinxo: I would recommend avoiding the system GHC and doing a manual GHC install, since it's trivial to do so manually and will work on any system, including broken ones like Arch
01:40:28 <geekosaur> and hadrian as of 8.4 unless they have to rip it out again
01:40:54 <merijn> sphinxo: My approach is just: 1) install GHC bindist, 2) compile Cabal and cabal-install myself from source, 3) install/build everything Haskell via cabal-install
01:41:23 <sphinxo> merijn: yeah I already have and use ghc via stack
01:41:31 <merijn> sphinxo: That approach "Just Works"
01:41:32 <[exa]> wow, hadrian reminds me of m4, it must be good
01:41:52 * hackage ngx-export 1.0 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-1.0 (lyokha)
01:42:15 <merijn> sphinxo: If you already have a GHC, why are you installing the system-ghc one?
01:42:43 <sphinxo> I'm trying to use https://github.com/tweag/rules_haskell and setting the haskell_toolchain to the stack installed one causes problems since then ghc can't find gcc
01:43:24 <[exa]> (whoops, ignore the last comment, I was looking at some old code)
01:45:04 <piyush-k`> merijn: yes I am piyushkurur on reddit
01:45:26 <piyush-k`> Just that it is good to some times compile code accross different ghc versions
01:46:33 <merijn> piyush-k`: You can just install multiple versions of the bindist, takes a handful of seconds to do
01:46:57 <yeoman> https://github.com/lpsmith/postgresql-simple
01:47:03 <yeoman> this is a libpq binding
01:47:04 <piyush-k`> but as far as I know not all distros has multiple versions of ghc
01:47:05 <piyush-k`> ?
01:47:07 <yeoman> where is the actualy.. binding?
01:47:22 <piyush-k`> I mean for ubuntu there is hvr's ppa
01:47:27 <piyush-k`> but otherwise ?
01:48:43 <merijn> piyush-k`: You go to https://www.haskell.org/ghc/download.html download the bindist for linux x64 for your OS, run "./configure --prefix=path/to/install && make install" and it's done in 10 seconds
01:49:00 <merijn> piyush-k`: cabal/cabal-install works with whatever GHC is in your path
01:50:23 <merijn> Unrelatedly, lemme pimp some of the stuff I (and phadej) have been hacking in the past few months: http://oleg.fi/gists/posts/2018-01-08-haskell-package-qa.html
01:50:27 <piyush-k`> merijn: I did not really realise that there was an option of binarys
01:50:33 <piyush-k`> TIL
01:50:50 <piyush-k`> I thought they were source tarballs mainly
01:50:55 <vaibhavsagar> nix-shell -p haskellPackages.ghc<version> is nice too
01:51:12 <merijn> piyush-k`: I've been using the bindists to install GHC on university machines where I don't have root for years now :)
01:52:11 <piyush-k`> okey so now I think stack is gone for good on my machine
01:52:16 <piyush-k`> sorry stack lovers
01:52:30 <piyush-k`> ;-)
01:52:31 <vaibhavsagar> piyush-k`: everything uses it though!
01:52:51 <cocreature> yeoman: postgresql-simple depends on https://hackage.haskell.org/package/postgresql-libpq which does the actual ffi
01:53:10 <vaibhavsagar> I'm considering configuring a chroot with stack on it for when I can't be bothered fiddling with Nix
01:54:21 <yeoman> i see
01:54:38 <merijn> vaibhavsagar: "everything uses it" <- depends on your definition of everything. Most Haskellers I talk to frequently don't use stack at all
01:54:55 <vaibhavsagar> merijn: most packages I see on GitHub
01:56:12 <merijn> I don't generally look at github unless I'm fixing/patching packages. And having a stack.yml does not mean the maintainer necessarily uses stack himself
01:56:28 <vaibhavsagar> that's fair
01:56:34 <vaibhavsagar> I don't use Stack much these days either
01:57:04 <vaibhavsagar> but for most of the packages I want to install, it's almost guaranteed that they build cleanly with Stack, even if the maintainer doesn't use it
01:57:31 <merijn> I never had that many problems before, so I was never really motivated to switch
01:57:41 <yeoman> cocreature: if haskell is so great, why do i actually have to write sql when using a db with haskell?
01:57:53 <sphinxo> I just did a clean install of ghc from the bindists, why is there no stm, text or mtl folder in the lib directory? are they not distributed with haskell? https://github.com/ghc/ghc/tree/master/libraries
01:57:54 <yeoman> why isn't there a DSL or something like that
01:58:01 <vaibhavsagar> yeoman: there are so many
01:58:06 <piyush-k`> merijn: it is good to have a blessed set of packages
01:58:13 <piyush-k`> platform was supposed to be that
01:58:19 <EvanR> sphinxo: these libs are... libs
01:58:22 <merijn> yeoman: SQL *is* a DSL
01:58:26 <cocreature> there are a bunch of Haskell dsls but imho sql is actually a fairly decent dsl for interacting with databases
01:58:28 <piyush-k`> but I think it did not have enough
01:58:33 <merijn> yeoman: It's actually a pretty good DSL too
01:58:34 <yeoman> merijn: well, yeah i know.. you know what i mean
01:58:50 <EvanR> sphinxo: theyre as easy to install as any others
01:58:52 <yeoman> i am building them as strings
01:59:09 <piyush-k`> Also cabal new-build is what is tilting the scales towards cabal for me
01:59:10 <merijn> sphinxo: stm/text/mtl aren't part of GHC, you just install them with cabal-install
01:59:21 <merijn> piyush-k`: <3 new-build
01:59:29 <vaibhavsagar> yeoman: https://github.com/tomjaguarpaw/haskell-opaleye, https://hackage.haskell.org/package/esqueleto, https://hackage.haskell.org/package/squeal-postgresql
01:59:40 <ertes-w> yeoman: there are lots of DSLs for databases, but honestly i actually prefer writing SQL
01:59:43 <merijn> vaibhavsagar: esqueleto was *awful* when I tried to use it
01:59:54 <merijn> Super restrictive, ulta confusing errors, etc.
01:59:56 <vaibhavsagar> I haven't used any of those packages
01:59:59 <vaibhavsagar> but they exist
02:00:00 <Tehnix> Anyone have a succinct explanation of the differences between `Free` monads `Freer` monads? Or do I have to jump down the rabbit hole on this one?
02:00:01 <sphinxo> https://github.com/ghc/ghc/blob/master/ghc.mk#L473 ?
02:00:09 <piyush-k`> so with cabal new-build + a basic wrapper function that downloads ghc bin we more or less have stack
02:00:17 <yeoman> ertes-w: i don't
02:00:22 <yeoman> sql is the worst
02:00:27 <merijn> In the end I ditched esqueleto and wrote my queries by hand with Text concat :)
02:00:43 <yeoman> finding "sequel" for ruby was the best day of my developer life
02:00:55 <yeoman> i expected haskell to have things that are as good
02:01:01 <merijn> piyush-k`: Have you seen the new-build based automatic Travis test setup script by hvr (and by now me and phadej) I linked earlier? :)
02:01:12 <geekosaur> sphinxo, ghc uses those internally. it does not ship with them
02:01:29 <phadej> merijn: having template-haskell verification of queries would be great
02:01:30 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ is what comes with ghc
02:01:31 <ertes-w> yeoman: the problem with most DSLs is that they're too abstract…  i'm a heavy user of database-specific features
02:01:43 <sphinxo> ahh ok thanks geekosaur
02:01:56 <phadej> merijn: but i'm not aware of anything supporting enough postgresql syntax (parser)
02:02:02 <yeoman> ertes-w: i don't want to annoy this channel with different languages.. but have a look at sequel of ruby
02:02:04 <ertes-w> yeoman: the way i deal with that is to write application models:  class AppData h where addUser :: h -> UserData -> IO UserId  -- something like that
02:02:08 <piyush-k`> merijn: you mean the reddit post ?
02:02:27 <yeoman> it has a plugin systme.. which adds db-specific features for each different DB it supports
02:02:30 <merijn> phadej: If you find someone to pay me, I will write a TH DSL for SQL in Haskell with an accompanying CLI wrapper for things like the sqlite command line so you have coloured multi-line SQL editing on the CLI!
02:02:47 <merijn> piyush-k`: And the multi-ghc-travis repo, yeah
02:02:59 <yeoman> ertes-w: i've not encountered queries i couldn't create with it's DSL, including weirdo features like json_b of postgresql
02:03:01 <phadej> merijn: I'd do that myself if someone pays ;)
02:03:38 <Tehnix> Anyone have a succinct explanation of the differences between `Free` monads `Freer` monads? Or do I have to jump down the rabbit hole on this one?
02:03:46 <piyush-k`> merijn: I was reading the post with the blinds on (I mean I did not realise the ghc binaries)
02:04:02 <piyush-k`> I will have a look again
02:04:07 <yeoman> ertes-w: and i would love something like that for haskell, but have no idea how that would look like
02:04:08 <merijn> piyush-k`: multi-ghc-travis doesn't really rely on your local setup anyway
02:04:39 <merijn> piyush-k`: It's generates a fancy Travis CI testing script with caching, support for multiple GHC versions, etc. automatically
02:04:55 <yeoman> ertes-w: you write your statements as strings or do you map something to it?
02:05:12 <piyush-k`> merijn: yes I have been using the multi-ghc-travis in raaz but I had a home grown version
02:05:23 <piyush-k`> I think at that time there was no cacheign in travis
02:05:31 <piyush-k`> Been lazy to change it
02:05:39 <merijn> piyush-k`: It has new-build support for multiple cabal files in the same repo now :)
02:05:47 <ertes-w> yeoman: well, there is haskelldb, which is a DSL that tries to do relational algebra…  i've briefly tried it, but that was many years ago
02:06:13 <piyush-k`> merijn: I will have a look
02:06:16 <merijn> piyush-k`: Example https://github.com/merijn/broadcast-chan has 4 packages in it that are tested against each other using new-build :)
02:06:28 <ertes-w> yeoman: my main database package is sqlite-simple, where you write SQL, but it has a separate type for SQL text, so you can't accidentally put raw values in there
02:06:43 <merijn> piyush-k`: So you can test against dependencies that aren't on hackage yet :)
02:06:53 * piyush-k` is secretly hoping that merijn will send a pull request 
02:06:59 <piyush-k`> :-)
02:07:04 <tabaqui> hey again
02:07:07 <yeoman> ertes-w: how do you circumvent things like sql injection
02:07:07 <merijn> ertes-w: I just write my SQL queries with Text concat like a savage ;)
02:07:10 <yeoman> by type safety?
02:07:21 <piyush-k`> merijn: just joking
02:07:22 <tabaqui> why uses MonadBase FunctionalDependencies
02:07:25 <tabaqui> ?
02:07:27 <merijn> ertes-w: Actually, I write them by horrific TH Text concat :)
02:07:30 <tabaqui> *does use
02:08:30 <cocreature> yeoman: postgresql-simple does parameter substitution for you which takes care of escaping things
02:08:34 <tabaqui> one base monad can have more than one lifted monads
02:08:50 <tabaqui> *one lifted monad can have more than one base monads
02:09:02 <ertes-w> yeoman: that's the point of having a separate Query type…  it forces you to use sqlite's substitution
02:09:06 <tabaqui> like we can get List a from Maybe a or Either e a
02:09:22 <ertes-w> merijn: well, then what's the point of using esqueleto?
02:09:29 <tabaqui> liftBase Nothing [Left _] -> []
02:09:40 <tabaqui> liftBase Just x [Right x] -> [x]
02:10:16 <ongy> Can I (maybe with some cpp hook) determine whether I'm compiled in new-build or normal build?
02:11:33 <merijn> ertes-w: I don't, I do that because esqueleto was a PITA to use
02:11:48 <merijn> ongy: Doubt it, why?
02:12:03 <piyush-k`> merijn: the multi-ghc-travis looks good
02:12:04 <ertes-w> merijn: ah, but then why don't you use one of the *-simple packages?
02:12:10 <ongy> but in old cabal with new-build and custom Setup.hs that prevents building on debian stable
02:12:14 <ongy> *bug
02:12:19 <sphinxo> is it possible to cabal install a package for static linking? ( make .hi files? )
02:12:35 <ongy> it first compiles properly with new-build but then seems to try and rebuild the Setup.hs again with old build and is missing dependencies
02:12:43 <merijn> ongy: You could put a flag in your cabal.project and detect if that flag is set
02:13:03 <piyush-k`> together with a package freeze that one gets from stackage we can also claim support for stack lts/nightly
02:13:13 <merijn> ertes-w: Right now I'm using persistent (because I wrote a bunch of code using it before conculding it was a pain and didn't want to rewrite it)
02:13:42 <ertes-w> ah, i see…  luckily i found that out very quickly and decided not to use it =)
02:13:58 <ongy> merijn: I'd have to bubble that up when I have it as sub-project, right? But I guess that's not really much of a problem
02:14:22 <merijn> ertes-w: Well, I'm using the conduit streaming interface, which is the main reason for not ripping out persistent
02:14:39 <merijn> ertes-w: Because else I'd have to handroll a conduit/pipes interface for sqlite-simple
02:16:08 <yeoman> ertes-w: what's your thought on  yesod models?
02:17:10 <[exa]> is there any good way for patching single data type entries (except lenses) ?
02:17:33 <sphinxo> is there an easy way to uninstall ghc installed using the bindists?
02:17:49 <Sonderblade> :t switch_it f x y = f y x
02:17:51 <lambdabot> error:
02:17:51 <lambdabot>     parse error on input ‘=’
02:17:51 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
02:17:53 <merijn> sphinxo: Just rm the prefix directory it installed into
02:18:13 <sphinxo> /usr/local/ :/
02:18:29 <merijn> sphinxo: Ah...that's a rookie mistake
02:18:46 <merijn> sphinxo: I think there's an uninstall script floating around, but forgot where
02:19:48 <piyush-k`> merijn: is your id on reddit not merijn ?
02:19:49 <ongy> merijn: do you by chance know the syntax to check for a flag?
02:20:15 <merijn> piyush-k`: I think it's merijnv or something, but I don't post a lot
02:20:26 <lyxia> [exa]: do you mean changing one field? record notation
02:20:33 <merijn> ongy: You can't, but you can use the flag to conditionally set a CPP define using -D
02:20:38 <piyush-k`> just referred to you on reddit and did not realise
02:21:11 <ongy> oh, does that work for the Setup.hs?
02:23:58 <merijn> ongy: Dunno about Setup.hs, tbh
02:24:11 <merijn> ongy: But I think Setup.hs can inspect the flags directly?
02:25:21 <ertes-w> merijn: yeah, i've done that (for machines)…  it's not too complicated to do that
02:25:42 <[exa]> lyxia: currently have something like setEntry a = modify (\StateRecord _ b c d -> StateRecord a b c d)
02:25:54 <[exa]> lyxia: I'd like to avoid rewriting the whole thing if I add one record
02:26:01 <[exa]> s/record/field
02:26:14 <ertes-w> yeoman: i abandoned yesod years ago
02:26:24 <ertes-w> so i don't have much of an opinion on anything yesod-sepcific
02:26:26 <ertes-w> *specific
02:27:01 <merijn> My main opinion is "oh god, the awful errors" and "I don't understand what this TH is all generating"
02:27:12 <ongy> nop doesn't work :/
02:27:38 <ongy> merijn: at that point I'd have to have pulled in the dependencies already, so I got to do that before my Setup.hs gets build :/
02:27:41 <ertes-w> yeoman: my opinion is on yesod as a whole: i much prefer the compositional style of other frameworks over the black-box style of yesod, and that goes for most of its components as well
02:28:27 <ongy> can I specify an alternative Setup.hs file?
02:28:36 <yeoman> hm, there are so many things i don't like about haskell, but i freakin love pureness and type-safety
02:29:25 <lyxia> [exa]: setEntry a = modify (\r -> r { fieldA = a })
02:29:49 <lyxia> [exa]: why not lens though
02:30:23 <[exa]> lyxia: oh wow, thanks
02:43:46 <ertes-w> yeoman: what are some examples of things you don't like about it?
02:45:29 <yeoman> i don't know, the existence of language extensions in general
02:45:30 <yeoman> syntax
02:45:43 <yeoman> quasiquoters look ugly af and are ambigious if i am not mistaking?
02:46:14 <yeoman> i don't know how people always claim that (E)DSLs are so easy and cool in haskell but they get barely used.. atleast i don't see it
02:46:20 <yeoman> but maybe it's just me..
02:48:16 <geekosaur> they do get used. thing is, they just look like functions
02:48:17 <dibblego> vaibhavsagar: there are a lot of us who do not use stack; we just aren't noisy.
02:49:04 <merijn> yeoman: What's ambiguous about QuasiQuoters?
02:49:51 <tdammers> yeoman: language extensions are a compromise between setting a language standard in stone (and thus preventing innovation) and throwing in new features uncritically before they have stood the test of real-world exposure
02:51:26 <yeoman> tdammers: i get that.. but somehow it feels scarier
02:52:31 <yeoman> merijn: 11679
02:52:36 <yeoman> merijn: https://ghc.haskell.org/trac/ghc/ticket/11679
02:53:01 <merijn> yeoman: Solution: Use typed quasi quoters, which are not :p
02:53:31 <yeoman> also .. quasiquoters look really ugly
02:53:40 <yeoman> like every other syntax in haskell ^^
02:53:52 <geekosaur> there's far worse conflicts than that. anything that steals a keyword (e.g. ExplicitForAlls which is turned on by seemingly half the other extensions), TypeApplications, BangPatterns, ...
02:53:52 <yeoman> [v|x|] .. holy shit who wants to read that
02:53:53 <merijn> Says you, I disagree strongly
02:54:51 <yeoman> merijn: you like the quasiquoter syntax?
02:54:55 <sphinxo> is it possible to get cabal to generate .hi files when it includes a package?
02:55:04 <sphinxo> sorry, when you install a package
02:55:10 <yeoman> you like things like "=." operators?
02:55:21 <merijn> yeoman: I don't mind the quasiquoter syntax and I don't think Haskell syntax is ugly
02:55:30 <geekosaur> it does. why do you think it doesn't?
02:55:41 <yeoman> .. a dot behind an equal sign
02:55:44 <geekosaur> (they have to exist, otherwise you couldn't import modules)
02:55:46 <yeoman> that's madness..
02:55:47 <sphinxo> geekosaur: because I only see .dyn_hi ?
02:55:53 <merijn> yeoman: I've never used that operator and it's not Haskell, so I don't see how that's a haskell issue
02:55:58 <geekosaur> then you need to build static as well as dynamic
02:56:06 <yeoman> merijn: people tend to use that.. when they create DSL
02:56:17 <yeoman> if they want to have equality in their DSL
02:56:23 <sphinxo> so how do I install and build packages through cabal statically?
02:56:25 <yeoman> but it seems to be quite common in haskell
02:58:15 <geekosaur> --enable-library-vanilla --enable-shared
02:58:54 <merijn> Isn't static the default?
02:59:22 <lyxia> yeoman: I think infix operators are just another way to name things and it's sometimes convenient
02:59:27 <yeoman> merijn: i like the core-cool aspects about haskell, but i can't help it, but i think those things could've been done so much easier
02:59:43 <yeoman> lyxia: my problem is not that it is infix..
02:59:43 <shiona> what is a good way to show the value of Ratio Integer. These are propabilities very close to 0 or 1, and I would like to know how close.
02:59:56 <lyxia> yeoman: what is the problem?
02:59:56 <yeoman> =. is my problem.. who does that
02:59:57 <merijn> "Things could be nicer than they are" <- welcome to the world
03:00:36 <merijn> yeoman: I think this is a pointless discussion to have. Yes things could be nicer, but would require massively breaking backwards compatibility, so it's not going to happen, so why bitch about it?
03:00:36 <yeoman> merijn: .. yeah well.. ruby doesn't even have DSLs.. but people abused a function of it to create.. DSL-like things
03:00:40 <yeoman> and they look nice
03:00:47 <sphinxo> geekosaur: hmm I try running  cabal install --disable-library-vanilla --enable-shared --enable-executable-dynamic  --reinstall --global  text stm mtl --root-cmd=sudo
03:00:53 <yeoman> merijn: haskells core-features are.. like.. the best things available
03:00:57 <sphinxo> oh wait
03:00:59 <yeoman> but it hurts so much using it
03:01:00 <lyxia> yeoman: well it's the closest we can get to overloading record syntax
03:01:16 <merijn> I'm bored with this discussion tbh
03:01:22 <yeoman> lyxia: you can use quasiquoters to "reuse" =
03:01:30 <yeoman> merijn: i understand that.. so am i.. it's just bothering me so much
03:01:38 <yeoman> sorry to annoy you
03:01:42 <merijn> yeoman: Well, make your own language that's better
03:01:43 <yeoman> lyxia: can't you?
03:01:58 <yeoman> merijn: well we both know that won't happen^^ i even fail at understanding haskell
03:01:58 <lyxia> yeoman: quasiquoters require implementing a parser
03:02:15 <yeoman> yeah.. well, maybe that step could'e been made easier? i don't know?
03:02:24 <sphinxo> geekosaur: so I run cabal install --disable-library-vanilla --enable-shared  --reinstall --global  text stm mtl --root-cmd=sudo
03:02:31 <sphinxo> see it installing to /usr/local/lib/x86_64-linux-ghc-8.2.2/text-1.2.2.2-EakMpasry3jA6OIwSZhq9M
03:02:38 <sphinxo> go there and all I see are .dyn_hi
03:02:40 <geekosaur> reread your command
03:02:41 <merijn> sphinxo: o.O
03:02:55 <merijn> sphinxo: Why are you installing shit globally? o.O
03:03:09 <geekosaur> notice that I did not say "disable". also, yes, installing globally is a bad idea.
03:03:11 <merijn> That's usually a recipe for a mess
03:03:28 <geekosaur> package managers *will* throw fits, and quite possibly break things without warning
03:03:32 <sphinxo> yeah i'm wrangling something
03:04:16 <lyxia> yeoman: all that for a single dot.
03:04:22 <sphinxo> normally I would use stack etc. but in this case I need to mess about with global stuff
03:04:27 <mlehmk> "left-pad"
03:04:37 <geekosaur> or, if I have to be explicit: you are forcing --disable-library-vanilla. Take a guess as to what that does.
03:04:45 <geekosaur> given what I said earlier
03:04:48 <sphinxo> yeah I've got it now, thanks
03:06:13 <yeoman> lyxia: a single dot that gets used a billion times
03:08:47 <lyxia> yeoman: I disagree that this seriously hurts anyone and I quit this discussion.
03:09:04 <yeoman> okay, thanks
03:28:37 * hackage tasty-dejafu 1.0.0.1 - Deja Fu support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-dejafu-1.0.0.1 (barrucadu)
03:42:24 <oddasat> hi all, is there any way i can look at how DeriveAnyClass actually implements a typeclass, say `Serialize`?
03:43:37 <cocreature> DeriveAnyClass generates empty instances. you’ll have to look at the default implementation of Serialize
03:44:35 <oddasat> thanks, cocreature!
03:45:09 <cocreature> there is a -ddump-deriv option which you can use if you’re interested how a class such es Show is derived
04:09:42 <saulzar> Hi people - I presume there are people here who use stack and ghc 8.0.2? I'm trying to install ghcjs, and the ghc which stack downloads seems to have an issue.  It runs this script .stack/programs/x86_64-linux/ghc-8.0.2/bin/ghc "-e" "either error id (Text.Read.readEither \"GHCJS\" :: Either String Distribution.Simple.CompilerFlavor)"  to check if cabal can use ghcjs
04:10:21 <saulzar> But for me this gives libHSCabal-2.0.1.1-61z5REOTsUmCPJSNCcIic9-ghc8.0.2.so: undefined symbol: timezm1zi6zi0zi1_DataziTimeziClockziCTimespec_getCTimespec1_closure
04:12:03 <saulzar> Is it just me?
04:30:50 <us_r-1> hi everybody
04:33:21 <brynedwards> hi
04:33:32 <ertes-w> yeoman: quasiquoters are not what i consider EDSLs, because they aren't *embedded*, and since you mentioned yesod, yes that one is definitely heavy on the TH/QQ front, which is one of the reasons i don't like it
04:33:50 <ertes-w> yeoman: anything that involves TH or QQ immediately gets a black-box character
04:34:48 <ertes-w> yeoman: EDSLs are just values…  for example blaze-html and lucid are EDSLs for writing HTML, clay is an EDSL for writing CSS: you write normal haskell code (no QQ)
04:35:07 <ertes-w> yeoman: then a "template" is really just a function of type, say, (Html -> Html)
04:36:21 <ertes-w> page title body = doctypehtml_ (head_ (title_ title) <> body_ (h1 title <> body))
04:36:40 <ertes-w> s/h1/h1_/
04:38:10 <geekosaur> I can only conclude they think the E means embedding some other language, hence quasis.
04:38:46 <ertes-w> yeoman: other good examples of EDSLs are stream processing (conduit, machines, pipes), free monads and more traditional composition-based web frameworks like happstack, snap, spock and scotty
04:40:09 <ertes-w> yeoman: oh, and of course IO is a great example of an EDSL =)
04:40:28 <ertes-w> ever noticed that 'catch' is a regular function in haskell?
04:43:56 <geekosaur> or bracket. or, perhaps especially, when.
04:47:07 * hackage ansi-wl-pprint 0.6.8.2 - The Wadler/Leijen Pretty Printer for colored ANSI terminal output  https://hackage.haskell.org/package/ansi-wl-pprint-0.6.8.2 (phadej)
04:50:54 <i-am-the-slime> Hello. How do I add some time period to a UTC time_
04:52:02 <liste> :t addUTCTime
04:52:04 <lambdabot> error: Variable not in scope: addUTCTime
04:52:16 <cocreature> https://hackage.haskell.org/package/time-1.8.0.4/docs/Data-Time-Clock.html#v:addUTCTime
04:52:29 <liste> https://hackage.haskell.org/package/time-1.8.0.4/docs/Data-Time-Clock.html#v:addUTCTime
04:52:37 <liste> oh
04:56:37 <Sose> I wonder why stack ghci with intero won't work inside a project but will outside it? I'm new to haskell / stack etc. here's a log showing what happens http://lpaste.net/6043742064691118080
04:56:57 <Sose> vscode needs to do that
04:59:04 <Sose> is there something weird going on with the version aswell? It says "Intero 0.1.23 (GHC 8.0.2)" but the file path is for ghc-8.2.2
05:00:58 <i-am-the-slime> liste: But then I need a NominalDiffTime or something
05:01:14 <i-am-the-slime> I thought I could do something like myUTCTime + (Days 3)
05:02:03 <phadej> NominalDiffTime behaves like a number
05:02:28 <phadej> so you could do 3 * 86400 (86400 = 24 * 3600)
05:02:41 <phadej> > 3 * 86400 :: NomimalDiffTime
05:02:47 <lambdabot>  error:
05:02:47 <lambdabot>      Not in scope: type constructor or class ‘NomimalDiffTime’
05:02:48 <phadej> > 3 * 86400 :: NominalDiffTime
05:02:51 <lambdabot>  error:
05:02:51 <lambdabot>      Not in scope: type constructor or class ‘NominalDiffTime’
05:02:54 <phadej> :/
05:03:26 <phadej> but if you want + 3 months (which isn't as fixed inteval), then you have to rethink what you want :)
05:03:50 <hpc> even with just days you can be off by a bit using that math
05:04:15 <hpc> up to a couple of hours depending on the time zone you're using
05:04:28 <phadej> well, UTCTime won't be off
05:04:29 <i-am-the-slime> I'm fine with it being just a certain number of days or whatever.
05:04:59 <phadej> but if you go localtime -> utctime -> (+ days) ->  utctime -> localtime, then yes
05:05:09 <i-am-the-slime> But I thought there was a more type safe way than doing * 1000 * 60 * 60 * 24 and all of that crap
05:05:10 <liste> i-am-the-slime: X days = X*24 hours = X*24*60 minutes = X*24*60*60 seconds etc...
05:05:26 <hpc> phadej: it depends on what you want
05:05:40 <phadej> hpc: that's why I pointed out, "you have to think about what you want" :)
05:05:41 <hpc> phadej: if you want a consistent say, 9:00 to 9:00
05:05:45 <hpc> yeah
05:06:04 <hpc> my point is even days isn't a very fixed interval
05:06:22 <i-am-the-slime> Yeah, I get it.
05:06:49 <i-am-the-slime> Okay, then.
05:07:07 <phadej> i heard Standard Chartered have sophisticated time library, they should open source it :)
05:07:07 <i-am-the-slime> I think what I want is a random date in between now and now-100 days.
05:07:42 <liste> i-am-the-slime: date, or an instant in time?
05:07:43 <merijn> phadej: Probably about as likely as Mu getting open sourced
05:07:46 <Sose> ok.. regarding my earlier problem, I see that the global stack.yaml has a different resolver (lts-9.0 instead of lts-10.3) that works. is there a bug with this version or do I need to somehow update intero? should intero be in the global stack.yaml somehow?
05:07:48 <merijn> phadej: Damn bank lawyers
05:07:51 <phadej> :)
05:07:59 <hpc> it's the third inevitable thing
05:08:03 <hpc> death, taxes, bad time libraries
05:08:09 <i-am-the-slime> Instant in time. At the end I need a json instant fro it
05:08:43 <liste> haskell's time lib isn't very bad :)
05:09:01 <tdammers> it's not that time libraries are bad, it's that the way humans decided to deal with time is horrible
05:09:03 <hpc> it's more complete than others, but i wish it was more intuitive
05:09:05 <phadej> it isn't, but it lacks a lot of convinience functions
05:09:06 <liste> (though it's not the best either)
05:09:32 <tdammers> at least the Haskell one is somewhat correct
05:09:38 <liste> tdammers: good time libraries can make dealing with time "the wrong way" more difficult
05:09:40 <hpc> perl's is pretty okay if you don't mind lots of typing and some awkward (+1900)
05:10:28 <tdammers> liste: more often than not you have no choice but to deal with time the wrong way, you just hope to avoid the worst wrongness
05:11:20 <Boarders> hi could someone explain why this fails: http://lpaste.net/361492
05:11:47 <Boarders> I also tried "deriving Eq a => Eq (Vec n a)" but get the same error
05:12:15 <hpc> what's the error?
05:13:01 <Boarders> error is: http://lpaste.net/361493
05:13:36 <phadej> uh, that's nasty
05:14:41 <phadej> didn't mniip had same problem here not so long ago
05:16:01 <phadej> I have an answer you won't like, use http://hackage.haskell.org/package/vec (peano numbers) or https://hackage.haskell.org/package/vector-sized-0.6.1.0/docs/Data-Vector-Generic-Sized.html#t:Vector (unsafe implementation)
05:16:37 <hpc> would writing the type with (1+n) work?
05:16:43 <Boarders> I was doing it as a learning exercise
05:16:49 <cocreature> hpc: nope just tried that
05:17:03 <cocreature> I’d try ghc-typelits-normalize
05:17:10 <phadej> that would work
05:19:21 <cocreature> yep just tried it
05:19:46 <Boarders> I'd added: ghc-typelits-natnormalise >= 0.5.7 - ghc-typelits-knownnat >= 0.3.1 but forgot to add those options 0_o
05:20:25 <Boarders> those do it
05:20:26 <Boarders> thanks
05:20:29 <phadej> cheers
05:20:53 <cocreature> it’s kind of embarrassing that GHC can’t even reason about typelits in those simple cases
05:22:34 <Boarders> similarly this function fails without those options: http://lpaste.net/361495
05:22:42 <JuanDaugherty> why? does hs have semantic pretensions?
05:23:40 <JuanDaugherty> functions is functions
05:25:48 <phadej> cocreature: I think having ghc-typelits-natnormalise as a library is good choice, as it can iterate faster than GHC
05:26:17 <phadej> and GHC can reason trivial Nat equations
05:27:08 <phadej> but p + n ~ p + m  => n ~ m  is not trivial IMO
05:28:22 <sphinxo> when I do stack exec, how does stack tell ghc to use the stackage snapshots package db?
05:28:44 <sphinxo> GHC_PACKAGE_PATH ?
05:29:33 <phadej> yes
05:29:42 <sphinxo> ok
05:29:45 <cocreature> phadej: oh sure, I wasn’t saying all of ghc-typelits-natnormalise should go in ghc. but imho it wouldn’t be unreasonable to expect it to be as smart as it would be if you defined this using peanonaturals, i.e., 1 + n ~ 1 + m => n + m
05:31:44 <phadej> I can blame only myself for not documenting about details about how to add these rules
05:31:51 <phadej> as ghc knows 0 + n ~ n, e.g
05:32:09 <phadej> but IIRC it doesn't know implications
05:33:41 <phadej> yeah, there are no implications in https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcTypeNats.hs
05:35:16 <phadej> or more precisely https://github.com/ghc/ghc/blob/fb78b0d22635b1d7ae68385c648b8c407f5562c2/compiler/typecheck/TcTypeNats.hs#L354-L375
05:55:22 <i-am-the-slime> Okay I can't seem to create a NominalDiffTime from an Integer
05:56:49 <liste> i-am-the-slime: fromInteger
05:57:03 <liste> https://hackage.haskell.org/package/time-1.8.0.4/docs/Data-Time-Clock.html#v:fromInteger
05:57:52 <i-am-the-slime> Thanks, I was looking in the wrong place it seems.
05:58:06 <raduom> Hi. Can I constrain the result of a type function?
05:58:07 * hackage wrecker 1.2.4.0 - An HTTP Performance Benchmarker  https://hackage.haskell.org/package/wrecker-1.2.4.0 (lorenzo)
05:58:35 <i-am-the-slime> Thanks, I was looking in the wrong place it seems.
05:59:44 <yeoman> foldl (++) ["1","2"]
05:59:48 <yeoman> what did i get wrong?
06:00:17 <Ferdirand> :t foldl
06:00:20 <liste> yeoman: you're missing an initial value
06:00:21 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
06:00:25 <liste> :t foldl1
06:00:29 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
06:00:39 <merijn> raduom: You can simply use the type function in the constraint?
06:00:40 <liste> >foldl1 (++) ["1", "2"]
06:00:47 <liste> > foldl1 (++) ["1", "2"]
06:00:54 <lambdabot>  "12"
06:01:04 <merijn> raduom: i.e. suppose we have a type family Foo you can just write "foo :: Ord (Foo t) => t -> Foo t -> Bar"
06:01:10 <liste> yeoman: note that foldl1 is partial
06:01:16 <liste> > foldl1 (++) []
06:01:20 <lambdabot>  *Exception: Prelude.foldl1: empty list
06:03:42 <yeoman> liste: ah, right
06:03:58 <raduom> merijn: seems to let me do that if i add ConstrainedClassMethods ghc will allow it. Thanks.
06:04:20 <merijn> raduom: Can you lpaste a small example? I never saw that extension before
06:05:26 <raduom> merijn: http://lpaste.net/5480930950382616576
06:05:46 <yeoman> what do i do if i want to add a newline every fold step?
06:06:07 <merijn> yeoman: unlines :p
06:06:16 <merijn> > unlines ["1", "2"]
06:06:23 <lambdabot>  mueval-core: Time limit exceeded
06:06:27 <merijn> really?
06:06:30 <merijn> what?
06:06:32 <merijn> > unlines ["1", "2"]
06:06:35 <lambdabot>  "1\n2\n"
06:06:41 <yeoman> im more interested in the function composition step
06:06:59 <merijn> yeoman: you replace (++) with a function that does (++) and adds a newline
06:07:00 <yeoman> foldl "++" "" ["_","_"] < i get this
06:07:12 <yeoman> merijn: but i can't do that with some short "." thingie, right?
06:07:21 <yeoman> i would have to do a lambda with 2 params, right?
06:07:25 <merijn> Not easily, no
06:07:32 <raduom> merijn: GHC lifts this restriction with language extension ConstrainedClassMethods. The restriction is a pretty stupid one in the first place, so ConstrainedClassMethods is implied by MultiParamTypeClasses. (https://downloads.haskell.org/~ghc/master/users-guide/glasgow_exts.html#extension-ConstrainedClassMethods)
06:07:34 <yeoman> und uneasily?
06:07:39 <yeoman> and*
06:07:41 <liste> :t intercalate -- this too
06:07:46 <lambdabot> [a] -> [[a]] -> [a]
06:08:01 <liste> > intercalate "\n" ["a","b"]
06:08:05 <lambdabot>  "a\nb"
06:08:29 <liste> doesn't have the last \n though
06:08:33 <liste> so different use case
06:09:04 <yeoman> yeah i am a haskell genius!
06:09:36 <sphinxo> can I enable language extensions passing something into ghc?
06:09:56 <liste> @pl \x y -> x ++ y ++ "\n"
06:09:56 <Taneb> sphinxo: it's not necessarily the best idea, but yes
06:09:57 <lambdabot> (. (++ "\n")) . (++)
06:10:08 <tdammers> sphinxo: you mean like -XOverloadedStrings?
06:10:09 <Taneb> sphinxo: like the -XGADTs flag
06:10:21 <sphinxo> Taneb: oh, can I just pass then like that? great thanks
06:10:49 <tdammers> sphinxo: it's generally considered bad style to rely on the user to pass the right compiler flags though
06:11:51 <yeoman> liste: that's what i did
06:18:54 <[exa]> merijn: you seem to be the author of https://wiki.haskell.org/Vim , mind putting a special command for correctly opening/closing the {- comments -} there?
06:19:12 <merijn> [exa]: I'm not :)
06:19:43 <merijn> [exa]: I think someone is crediting my dotfiles repo that I occasionally link to people
06:19:51 <[exa]> ok your name was there, I kindof supposed you can edit it
06:20:32 <Psybur> So you guys use vim and the like? Why not use something like intellij + haskforce?
06:20:52 <yeoman>  board = foldl (\a b -> a ++ b ++ "\n") "" $ map (\e -> intersperse '|' $ map showCell e) b
06:20:57 <yeoman> something stupid about this line?
06:21:23 <Psybur> Why foldl?
06:21:37 <yeoman> i thought of it like reduce?
06:21:42 <merijn> Psybur: Why *would* I use something like intellij?
06:21:46 <[exa]> Psybur: I once compared ratios of package sizes and features of Vim vs. IntelliJ
06:22:12 <HaskellLord69> spacemacs
06:22:36 <yeoman> Psybur: what should i use?
06:22:38 <merijn> Psybur: I've used vim as my main editor from everything from python, C++, Java, Haskell, etc. for years. Switching to another editor feels like lobotomising myself, tbh
06:22:44 <[exa]> yeoman: foldl' with the ' is "reduce", normal foldl is too lazy for most tasks
06:22:48 <Psybur> merijn, any screenshots of what it looks like when you use vim? In intellij Ive got all kinds of collapsing trees and the like
06:23:00 <Psybur> All kinds of stuff going on heh
06:23:14 <Psybur> You cant use your mouse in vim can you?
06:23:17 <ertes-w> yeoman: you should really use foldr with (++)
06:23:21 <HaskellLord69> If you are a mouse toucher intellij is probably good for you
06:23:24 <yeoman> [exa]: forgot the difference, what was it?
06:23:28 <merijn> Psybur: You can, but I don't
06:23:33 <[exa]> Psybur: do not confuse vi and vim :]
06:23:41 <merijn> Psybur: Not having to use a mouse is the main reason I use vim
06:23:48 <ertes-w> > foldr (++) [] (cycle "abc")
06:23:51 <lambdabot>  error:
06:23:52 <lambdabot>      • Couldn't match type ‘Char’ with ‘[a]’
06:23:52 <lambdabot>        Expected type: [[a]]
06:24:31 <Psybur> > foldr (++ pure . ) [] (cycle "abc")
06:24:34 <Psybur> rofl
06:24:37 <lambdabot>  mueval-core: Time limit exceeded
06:24:40 <Psybur> > foldr (++ . pure) [] (cycle "abc")
06:24:45 <lambdabot>  <hint>:1:11: error: parse error on input ‘.’
06:24:50 <Psybur> ok i give up
06:24:54 <Psybur> I havent had my coffee :D
06:25:01 <hyperisco> I have… what's the objective
06:25:12 <Psybur> > foldr ((++) . pure) [] (cycle "abc")
06:25:18 <lambdabot>  "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
06:25:50 <hyperisco> > cycle "abc"
06:25:56 <lambdabot>  "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
06:26:02 <hyperisco> nice identity function though!
06:26:20 <yeoman> (\e -> intersperse '|' $ map showCell e)  <= this function is supposed to map each field on a board to a char
06:26:24 <yeoman> put | between them
06:26:32 <yeoman> nw i want to add a | at the beginning and end
06:26:47 <yeoman> if i just write | at the end.. the | will also get added to the parameter of map
06:26:51 <yeoman> how do i fix that
06:27:17 <[exa]> Psybur: vim here: http://e-x-a.org/stuff/gvim-hs.png
06:28:43 <hyperisco> > '|' : zipWith (++) (fmap pure "hello world!") (repeat "|") -- first try
06:28:49 <lambdabot>  mueval-core: Time limit exceeded
06:29:04 <hyperisco> uhh what
06:29:13 <merijn> Psybur: Yeah, my vim looks pretty much like [exa]'s, except prettier font and colours ;) Also I use terminal vim, not gvim
06:29:20 <merijn> hyperisco: lambdabot is a bit overloaded, it seems
06:29:24 <hyperisco> > '|' : zipWith (++) (fmap pure "hello world!") (repeat "|") -- first try
06:29:30 <lambdabot>  mueval-core: Time limit exceeded
06:29:39 <hyperisco> or I am bottoming out
06:29:53 <merijn> hyperisco: Then it should still print '|'
06:30:18 <Psybur> merijn, [exa], hows the git integration? Do you get the pretty graphs, stashing, being able to branch multiple projects at a time etc in vim?
06:30:26 <hyperisco> hm, yup
06:30:26 <merijn> Psybur: I don't use git
06:30:28 <[exa]> merijn: "prettier font and colours" picture needed!
06:30:34 <Psybur> Gradle integration?
06:30:37 <hyperisco> anyways, throw that in ghci yeoman and play with it
06:30:50 <Psybur> %  '|' : zipWith (++) (fmap pure "hello world!") (repeat "|") -- first try
06:30:51 <yahb> Psybur: ; <interactive>:18:7: error:; * Couldn't match type `[Char]' with `Char'; Expected type: [Char]; Actual type: [[Char]]; * In the second argument of `(:)', namely `zipWith (++) (fmap pure "hello world!") (repeat "|")'; In the expression: '|' : zipWith (++) (fmap pure "hello world!") (repeat "|"); In an equation for `it': it = '|' : zipWith (++) (fmap pure "hello world!")
06:30:56 <HaskellLord69> what do you use?
06:30:58 <[exa]> Psybur: there's a terminal open behind that, so much for git integration
06:31:10 <hyperisco> seems I mucked it up :D
06:31:13 <[exa]> Psybur: when stuff gets weird, I open gitg to see whats happening
06:31:23 <[exa]> (what is Gradle)
06:31:28 <Psybur> I just right click and compare with :D
06:31:32 <merijn> When I want to access version control I do Ctrl-Z to drop into the shell
06:31:34 <Psybur> Gradle is a build manager like maven
06:31:45 <hyperisco> uhh right
06:32:06 <hyperisco> > '|' : mconcat (zipWith (++) (fmap pure "hello world!") (repeat "|"))
06:32:10 <lambdabot>  "|h|e|l|l|o| |w|o|r|l|d|!|"
06:32:15 <hyperisco> we'll call it a rebound :P
06:32:52 <[exa]> Psybur: I can't stand mouse-ing stuff around when working :]
06:33:11 <hyperisco> now lets make it better…
06:33:40 <hyperisco> > '|' : ("hello world" >>= \x -> [x, '|'])
06:33:44 <lambdabot>  "|h|e|l|l|o| |w|o|r|l|d|"
06:33:53 <merijn> [exa]: Word
06:34:04 <yeoman> hyperisco: that'ss cool
06:34:13 <merijn> [exa]: Just search/jump/etc. to move around :)
06:34:17 <hyperisco> > '|' : ("hello world" >>= (:"|"))
06:34:22 <lambdabot>  "|h|e|l|l|o| |w|o|r|l|d|"
06:34:22 <yeoman> but still,... how would i fix that problem?
06:34:31 <yeoman> i mean.. do i have to add () to fix thath
06:34:32 <hyperisco> what problem?
06:34:38 <yeoman> (\e -> intersperse '|' $ map showCell e)  <= this function is supposed to map each field on a board to a char
06:34:54 <Psybur> > foldr (\x a -> ['|',x] ++ a) "|" "bruh"
06:34:56 <yeoman> now i want to add a | at the beginning and end
06:34:59 <lambdabot>  "|b|r|u|h|"
06:35:01 <yeoman> if i just write | at the end.. the | will also get added to the parameter of map
06:35:03 <ertes-w> > foldr (++) [] (repeat "abc")
06:35:04 <hyperisco> well I don't know what mapCell does
06:35:08 <lambdabot>  "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
06:35:17 <yeoman> >map each field on a board to a char
06:35:23 <hyperisco> > intersperse '|' "hello sailor!"
06:35:30 <lambdabot>  mueval-core: Time limit exceeded
06:35:41 <hyperisco> you see, there is no '|' at the end … well you would if lambdabot wasn't out of breath
06:35:51 <hyperisco> so intersperse just isn't the right function to be using
06:36:22 <Psybur> % intersperse '|' "hello sailor!"
06:36:22 <yahb> Psybur: "h|e|l|l|o| |s|a|i|l|o|r|!"
06:36:45 <Psybur> > foldr (\x a -> ['|',x] ++ a) "|" "this is probably the easiest to understand while also being quick"
06:36:49 <lambdabot>  "|t|h|i|s| |i|s| |p|r|o|b|a|b|l|y| |t|h|e| |e|a|s|i|e|s|t| |t|o| |u|n|d|e|r|...
06:37:20 <hyperisco> really? you don't think the bind/list comprehension is easier?
06:37:28 <Psybur> :P
06:38:34 <Psybur> Lists bind is weird
06:39:31 <hyperisco> mm, it is map then concat, not that weird
06:39:42 <hyperisco> :t concatMap
06:39:44 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
06:40:11 <hyperisco> :t (>>=) `asTypeOf` concatMap
06:40:14 <lambdabot> error:
06:40:14 <lambdabot>     • Couldn't match type ‘[b] -> [b]’ with ‘[a]’
06:40:14 <lambdabot>       Expected type: [a] -> (a -> [b]) -> [b]
06:40:18 <Psybur> Oh wait Im thinking of >>
06:40:25 <Psybur> > "abc" >> "xyz"
06:40:26 <hyperisco> :t (=<<) `asTypeOf` concatMap
06:40:29 <lambdabot> (a -> [b]) -> [a] -> [b]
06:40:31 <lambdabot>  "xyzxyzxyz"
06:40:49 <hyperisco> right, well that's just the constant map
06:40:50 <merijn> Psybur: That's just: "abc" >>= \_ -> "xyz"
06:40:53 <Psybur> Yes
06:41:00 <hyperisco> > fmap (const "xyz") "abc"
06:41:06 <lambdabot>  ["xyz","xyz","xyz"]
06:41:36 <i-am-the-slime> is there some native app for linux that I can use to hoogle?
06:41:57 <yeoman> :t Just Nothing
06:42:00 <lambdabot> Maybe (Maybe a)
06:42:09 <merijn> i-am-the-slime: Yes, hoogle :p
06:42:35 <merijn> i-am-the-slime: You can build your own local hoogle database and it comes with a CLI for that database
06:42:48 <hyperisco> > ((.) <$> (:) <*> (=<<) . flip (:) . pure) '|' "hello sailor!"
06:42:48 <Psybur> heh, Just Nothing. Thats a good one
06:42:51 <lambdabot>  "|h|e|l|l|o| |s|a|i|l|o|r|!|"
06:42:57 <hyperisco> not sure that is the best expression, but it is one
06:43:44 <Psybur> > mconcat Just Nothing
06:43:50 <lambdabot>  error:
06:43:50 <lambdabot>      • Couldn't match expected type ‘[Maybe a1 -> t]’
06:43:50 <lambdabot>                    with actual type ‘a0 -> Maybe a0’
06:43:59 <[exa]> Just what.
06:44:47 <Psybur> :D
06:45:16 <infandum> I installed a program I want to profile with "stack install --executable-profiling --library-profiling". The result from "+RTS -p" gives me all cost centers, even from all dependencies. Is there a way to only have cost centers for the program itself (the local files) and select dependencies rather than all?
06:45:57 <merijn> infandum: Maybe, but I usually just do some grep/sed to get the results I want
06:46:07 <Psybur> > join $ Just Nothing
06:46:13 <lambdabot>  Nothing
06:46:28 <infandum> merijn: What do you grep for? I want the most time / most allocated for all of my local functions.
06:46:43 <hyperisco> @pl \x y -> x : (y >>= (: pure x))
06:46:43 <lambdabot> liftM2 (.) (:) ((=<<) . flip (:) . pure)
06:46:51 <hyperisco> hey we came up with the same thing! :D
06:47:02 <merijn> infandum: if you just care about your own functions you can add manual cost center annotations to your functions and tell the profiler to only log those
06:47:06 <[exa]> merijn: anyway, is there any smart indentation for vim that would skip to a reasonable place when pressing tab after a line that opens indentation?
06:47:30 <merijn> [exa]: I have a half working setup. I start writing one for myself, but never finished and it's half working/half broken atm :p
06:47:31 <infandum> merijn: I thought about that, but there are way too many functions for me to manually do that.
06:47:34 <[exa]> merijn: example:  funcfunc a s d a s d = do  [enter] [tab]  -> skips right below 'do'
06:47:42 <[exa]> or at least after the =
06:48:28 <merijn> infandum: I'd recommend the GHC manual on profiling and see what it says. There's like a billion options and flags, so presumably at least one of them should be helpful...
06:49:52 <infandum> merijn: I looked at the fprof-* flags but unfortunately it's none are quite what I need.
06:49:59 <infandum> I can try more intelligent grepping.
06:51:22 <infandum> Oh, question about the *.prof file: in the second part of the file, with the cost center tree, are the %s there out of the entire program? So if a function inherits 42% of allocation, that means that within that function, 42% of memory of the program resides?
06:51:48 <merijn> infandum: Also, pro-tip "sort" understand columns, so you can use it to sort stuff by column (like execution percentage) to find relevant/interesting cost centers
06:51:57 <merijn> infandum: Yes
06:52:04 <merijn> infandum: afaict
06:52:06 <babeguy> harward university cs50 vs haskell which one should a noob take first
06:52:22 <infandum> Ah, then I found my culprit. Apparently the majority is just loading a file, geez.
06:52:36 <infandum> Hours to load a 50 mb file
06:52:43 <infandum> Into a matrix, that is.
06:53:07 * hackage eng-stemmer 0.1.0.2 - An English language stemmer (Porter2)  https://hackage.haskell.org/package/eng-stemmer-0.1.0.2 (ChrisCoffey)
06:53:48 <infandum> Holy smokes, it's almost all from cassava! Am I using cassava right?
07:06:24 <merijn> infandum: Probably not, then :p
07:06:28 <merijn> 50 mb file of what?
07:16:21 <infandum> merijn: A matrix of numbers, with text header and text first column
07:16:44 <infandum> This may be a silly question but I can't really find it: where is the "head" for foldable instances?
07:18:45 <metahumor> infandum: foldr const blah
07:19:23 <metahumor> infandum: last would be "foldl' (flip const) blah"
07:19:41 <metahumor> where blah is what you want as the default value in the case that your Foldable might be empty
07:19:49 <infandum> Does that traverse the whole list?
07:19:54 <infandum> foldable?
07:19:56 <infandum> I mean
07:19:57 <metahumor> yes
07:20:20 <infandum> Does head traverse the whole list?
07:20:32 <metahumor> no, head uses the list constructor afaik
07:20:40 <infandum> Yeah, I see, it pattern matches.
07:22:02 <infandum> Does "head" from the "foldl" package traverse the whole list?
07:22:29 <infandum> I *think* it does, looking at the definition of _Fold1
07:24:03 <metahumor> yeah, it Folds using const
07:25:08 <infandum> Okay, thanks for your help!
07:26:44 <metahumor> but know that you'll have to rely on the defn on Foldable for that type
07:27:21 <metahumor> so for a data Tree a = Empty | Leaf a | Node a (Tree a) (Tree a)
07:27:28 <metahumor> it might be DFS or BFS
07:29:04 <merijn> eh...
07:29:12 <merijn> fold with const does not traverse the entire structure
07:29:20 <merijn> At least not for any sensible fold implementation
07:30:04 <infandum> I'm using the streaming cassava, so it should behave like a list
07:35:09 <sphinxo> why am I getting these errors about unrecognised flag when I set the GHC_PACKAGE_PATH  http://lpaste.net/8832063665369776128
07:39:51 <phadej> they aren't flags recognised by ghc
07:40:04 <phadej> looks more like cabal or stack flags
07:41:03 <sphinxo> ahh ok phadej
07:41:17 <phadej> ghc --show-options fwiw :)
07:42:14 <sphinxo> phadej: so why is it that ghc doesn't error when the env variable isn't set?
07:42:33 <Boarders> does anyone know how to do a replicate function for fixed length vectors (where I am using typeLits)?
07:42:57 <sphinxo> to narrow it down even further, removing the : from the env var seems to fix it
07:44:21 <albatross_> morning guys
07:45:03 <metahumor> morning
07:45:35 <albatross_> I have a couple of question regarding binary search trees. If i have to start a tree with a leaf, and subsequently insert one node at a time
07:45:57 <albatross_> morning metahumor
07:46:34 <albatross_> how would the very first line of code look like
07:47:07 * hackage blaze-markup 0.8.2.0 - A blazingly fast markup combinator library for Haskell  https://hackage.haskell.org/package/blaze-markup-0.8.2.0 (JasperVanDerJeugt)
07:47:08 <albatross_> I guess more specifically, when i insert a node into a leaf, leaf being the empty spot, with pattern matching
07:47:08 <sphinxo> oh wait nevermind I've got it now
07:47:29 <albatross_> insert x Leaf = Node Leaf x Leaf
07:47:34 <albatross_> does this look right to you guys
07:48:31 <mnoonan> albatross_: probably!
07:50:07 * hackage snap 1.1.0.0 - Top-level package for the Snap Web Framework  https://hackage.haskell.org/package/snap-1.1.0.0 (DougBeardsley)
07:51:28 <metahumor> Boarders: do you want you replicate func to take a Nat param, or to know how long to make by type inference?
07:51:43 <albatross_> http://lpaste.net/361482
07:51:58 <albatross_> can you guys please take a look at why the build function isn't working?
07:52:03 <metahumor> Boarders: this might be useful: https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html#generating
07:53:18 <metahumor> what isn't working about it?
07:53:46 <albatross_> when i run build, it returns Leaf
07:54:04 <albatross_> when it is suppose to be a tree
07:54:20 <Boarders> metahumor: I want something like replicateV :: forall a n.KnownNat n => a -> Vect n a
07:54:31 <Boarders> but I don't know how to do the different cases depending on n
07:55:26 <metahumor> Boarders: the link i shared shows how to do it using the KnownNat, such that you don't have to case it
07:56:54 <electrocat> is there a way to avoid the unsafeCoerce in this example? http://lpaste.net/361501
07:57:30 <metahumor> albatross_: when you run build xs tree, what are you supplying as tree?
07:57:55 <albatross_> [LogMessage]
07:58:03 <albatross_> a list of logmessages
07:58:26 <metahumor> thats your "xs", but your build also takes a tree
08:00:15 <albatross_> does this look right to you guys? insert x Leaf = Node Leaf x Leaf
08:09:41 <Boarders> metahumor: my problem is I have a declaration like: http://lpaste.net/361502
08:10:26 <Boarders> so I can't use the regular replicate without a function fromListV :: ?? => [a] -> Vec n a
08:10:47 <Boarders> but the problem is there n is err existentially scoped (not sure how to say it)
08:11:22 <Boarders> the point being you want to use an iso like List a ~ Sigma_n : N Vec n a
08:11:52 <cocreature> Boarders: you’ll have to write something like "Proxy n -> a -> Vect n a"
08:15:07 * hackage postgrest 0.4.4.0 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-0.4.4.0 (begriffs)
08:34:16 <Boarders> cocreature: could you give more of a hint, I don't see how I can work with this stuff at all
08:42:14 <metahumor> "replicate p x -> mkVec (V.replicate n x) where n = fromIntegral (natval p)"
08:42:49 <metahumor> whoops, "=" instead of "->"
08:42:53 <metahumor> and you need a
08:43:27 <metahumor> "replicate p x :: forall n a . KnownNat n => Proxy n -> a -> Vec n a"
08:45:37 <Boarders> I am not using the mkVec wrapper so I don't know how to go from a list to this representation
08:46:04 <metahumor> what is your regular way to go from a list to a sized vector?
08:46:43 <Boarders> that is what I am trying and failing now to write down
08:47:12 <merijn> metahumor: "use a dependently typed language" :p
08:49:12 <metahumor> Boarders: did you read https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html?
08:51:07 <cocreature> Boarders: http://lpaste.net/361504
08:54:05 <Boarders> metahumor: not properly, I added it to my reading list for later
08:54:20 <Boarders> cocreature: thanks!
08:56:29 <cocreature> I really wish there was some way to get singletons for GHC.TypeLits
09:27:07 * hackage eliminators 0.4 - Dependently typed elimination functions using singletons  https://hackage.haskell.org/package/eliminators-0.4 (ryanglscott)
09:29:07 * hackage re2 0.2 - Bindings to the re2 regular expression library  https://hackage.haskell.org/package/re2-0.2 (blaze)
09:31:02 <yeoman> my girlfriend teaches programming at her university and some people haven't seen programming yet
09:31:15 <yeoman> some of the students expected.. if a function get's called in an if statement
09:31:20 <yeoman> that it has no side effects
09:31:31 <yeoman> do you guys think haskel would actually be easy, if people learned it first?
09:32:47 <shiona> My personal guess: No.
09:33:35 <exio4> yeoman: programming is rarely easy when you are starting
09:33:48 <yeoman> yeah but would it be harder.. than java for example?
09:34:01 <yeoman> im always amazed people learn java as a first language here in germany
09:34:07 * hackage criterion 1.3.0.0 - Robust, reliable performance measurement and analysis  https://hackage.haskell.org/package/criterion-1.3.0.0 (ryanglscott)
09:34:07 <yeoman> i think that's a really stupid choice
09:35:50 <shiona> The fact those students noticed unexpected side effects in an if clause is that they wrote something side-effectful in there. I don't believe that by teaching haskell they would have not written such code. Sure, haskell would have given an error, but more often than not beginner programmers seem to understand error messages even less than what they understand unexpected output
09:35:56 <zomg> I think it's fairly pragmatic. Java has similarities to many languages used in the industry
09:36:15 <ReinH> beginning programmers understand what they learn
09:36:27 <ReinH> if they use haskell, they will learn to understand error messages
09:36:56 <liste> I think learning Python or JS as first language is worse, that gives no exposure to any kind of type system
09:37:32 <exio4> liste: I badly agree with that!
09:39:10 <guillaum1> In (Mega)Parsec, how can I fail if a parser succed but with failing information with position at the begininng of the parsing ?
09:40:00 <shiona> And I believe that C/C++ is the correct language to begin with (or at least learn in the early stages of programming career) to give an idea of memory management and using system services
09:40:47 <guillaum1> I'm currently doing something crazy with `a <- p >> modifyParserLocation (\currentLocation -> currentLocation - length a) >> fail "This is wrong !"`
09:42:07 * hackage lens-properties 4.11.1 - QuickCheck properties for lens  https://hackage.haskell.org/package/lens-properties-4.11.1 (ryanglscott)
09:44:20 <infandum> I have a "hPutStrLn stderr "Filtering matrix."" statement. It shows up once in the program, but is printed multiple times. How can I bugfix this?
09:47:47 <metahumor> I think learning programming with directly imperative langs like NetLogo is good
09:48:14 <metahumor> esp because NetLogo has a direct way of displaying calculations etc
09:48:37 <metahumor> typing isn't obvious, i think it's difficult to introduce
09:48:50 <metahumor> Scheme is also good for a second language, and that is untyped
09:54:37 * hackage hpqtypes-extras 1.5.0.1 - Extra utilities for hpqtypes library  https://hackage.haskell.org/package/hpqtypes-extras-1.5.0.1 (MikhailGlushenkov)
09:54:47 <yeoman> shiona: no they ddidn't notice them.. they expected them to be not there if you use them inside "if"
09:54:57 <yeoman> like.. the function got pure, because it is in if
10:13:56 <Math22232> why is z not in scope though x is in scope? https://pastebin.com/9N0XQJxK
10:15:03 <cocreature> you need to use "\z -> "
10:15:08 <liste> Math22232: z is not a bound variable there, it should probably be something like solution' z = .. or \z ->
10:18:48 <Math22232> liste, cocreature I still get an error if I change it to this: https://pastebin.com/GSttDdwU
10:19:05 <Math22232> still z is not in scope
10:19:34 <cocreature> if you use (\z -> z) then z is not accessible outside the parenthesis
10:20:18 <Math22232> yes, but how do I need to change it?
10:20:30 <cocreature> change the parenthesis
10:20:46 <cocreature> in particular move the right parenthesis to the end
10:22:07 <Math22232> cocreature, thanks
10:39:27 <mnoonan> infandum, I didn't see if you got an answer; if not, have you tried Debug.Trace.traceStack ?
10:44:37 * hackage api-builder 0.14.0.0 - Library for easily building REST API wrappers in Haskell  https://hackage.haskell.org/package/api-builder-0.14.0.0 (Intolerable)
10:45:33 <L0g4nAd4ms> If i have an algebraic data type like `data Figure = Figure Shape Point` is there a way to have a function only accept e.g. `Circle`, but do not have to pass the `Point` extra ?
10:45:58 <metahumor> L0g4nAd4ms: is Circle a value of Shape?
10:46:04 <L0g4nAd4ms> Shape is `data Shape = Circle Float | Rectangle Float Float`
10:46:37 <metahumor> what do you mean by "not have to pass the Point extra", as in, not require a point?
10:47:23 <L0g4nAd4ms> well i need the point because its the center of the circle / top left point of a rectangle
10:48:07 <metahumor> can you explain further about "only accept a Circle"?
10:49:12 <L0g4nAd4ms> Well i have an overlap function, which checks if a figure overlaps a figure. In this function i differentiate between Circle Circle, Rectangle Rectangle, Rectangle Circle
10:49:44 <L0g4nAd4ms> of course these 3 collisions are 3 different implementations (you could say its overloaded 3 times)
10:50:38 <glguy> If you had a distinct type for circles, then you could have a function that only accepted that type
10:50:57 <cocreature> start with "data Circle = Circle Float; data Rectangle Float Float" and change Figure to "data Figure s = Figure s Point"
10:51:00 <L0g4nAd4ms> but the way its currently implemented i get errors with overlapping patterns, because my functions for checking Rectangle - Rectangle and Rectangle - Circle accept Figures
10:51:01 <glguy> then you'd want to update your Shape type's Circle constructor to expect a value of this new circle type instead of a Float
10:51:54 <mnoonan> L0g4nAd4ms, why aren't you just writing "intersects :: Figure -> Figure -> Bool" like "intersects (Figure (Circle r) c) (Figure (Circle r') c') = circle intersection code.." etc?
10:52:34 <L0g4nAd4ms> mnoonan, i have that for two circles, but for rect - rect and rect - circle i wrote extra functions because they are longer
10:52:55 <L0g4nAd4ms> glguy, well this is a limitation i have to accept, this is a constraint from the exercise
10:53:19 <glguy> L0g4nAd4ms: OK, then when you want to only take a circle somewhere, then only take a Flaot
10:53:22 <glguy> Float*
10:53:24 <L0g4nAd4ms> that the Shape type has to structured that way
10:53:28 <mnoonan> L0g4nAd4ms: I don't see how extra functions saves you any space here, compared to multiple equations to define "intersects"
10:54:01 <jle`> L0g4nAd4ms: if you're stuck with that type, then the best way is probably to just write a function that takes Float -> Point -> ...
10:54:28 <jle`> cocreature: do you mean without the singletons library? ;)
10:55:14 <cocreature> jle`: the singletons library doesn’t really help, does it? you still can’t get type information by value-level pattern matching like you can for other singletons
10:55:46 <jle`> cocreature: the way it's set up, you can but you need ScopedTypeVariables
10:55:55 <jle`> case myNatSing of (SNat :: Sing n) -> ...
10:56:10 <L0g4nAd4ms> mnoonan, well it seems to be prettier because for rect - circle i can just check if any of my 3 intersections for circle and rectangle are true
10:56:21 <L0g4nAd4ms> so this a one liner in intersects
10:56:31 <cocreature> jle`: that doesn’t seem like an improvement over proxies
10:56:51 <jle`> you get the KnownNat constraint
10:57:25 <jle`> well, i guess the real main benefit is that it integrates with the rest of 'singletons' machinery
10:57:45 <cocreature> fair enough although I’d say that’s still significantly more clumsy than the singleton you can get for peano naturals
10:57:45 <L0g4nAd4ms> well i could show you the code specifically, if thats helps a bit extra
10:57:48 <jle`> i had a phase where i did use proxies for everything
10:57:54 <mnoonan> L0g4nAd4ms: yeah, that would help
10:58:04 <L0g4nAd4ms> its on my github
10:58:15 <jle`> cocreature: it's a singleton in the same sense that TypeRep is a singleton
10:58:22 <L0g4nAd4ms> but currently the intersection for circle - rectangle is buggy because i made a logic error i have to fix
10:58:24 <jle`> you would have to pattern match and also scope-type-variable
10:58:42 <cocreature> jle`: right and I don’t want to have to do that :)
10:58:56 <jle`> fair enough :o
10:59:27 <L0g4nAd4ms> https://github.com/L0g4n/IFP_Haskell/blob/feat/overlap_rect_circle/sheet3/main.hs
10:59:38 <cocreature> I wonder if you could make a ghc plugin but given that nobody has done that so far it’s probably not possible :)
11:01:28 <jle`> to be fair most useful ghc plugins are probably not made yet
11:01:56 <jle`> most useful and possible plugins
11:02:11 <cocreature> heh good point
11:05:51 <amalloy> L0g4nAd4ms: basically your type Figure exists specifically to permit both circles and rectangles. that's why you can't write a function which accepts a Figure but only if that figure is a circle
11:06:19 <amalloy> or rather, your Shape type
11:06:49 <L0g4nAd4ms> amalloy, yeah well i get that. i am still thinking how to solve that though without changing the Shape or Figure type
11:07:14 <amalloy> you can't, is what we are saying. that's why all the recommendations have been "if you want to do this you need a different type"
11:08:15 <amalloy> it's like saying, i've written a function from String -> Int, but i'd like the compiler to verify that i only ever call this function with the sting "test"
11:08:30 <Peter123> I have a question: I have 2 pure sort functions: "sortTIM" and "sortIntrosort".
11:08:57 <amalloy> "test" is a value that has meaning at runtime, not a type with meaning at compile time, so the compiler can't verify that: you have to write code to work with values of type String at runtime
11:09:13 <Peter123> Can I write a "combindSort" that executes both "sortTIM" and "sortIntrosort" in parallel and returns the result whatever sort function is quicker?
11:09:35 <L0g4nAd4ms> amalloy, well but i could match for two rectangels or a circle and a rectangle in the `overlap` function and do the specific stuff there then
11:10:00 <Peter123> Because usually Introsort is quicker, but somtimes "sortTim" is quicker (because it makes less comparisons).
11:10:13 <amalloy> yes, you definitely could do that. that's what mnoonan suggested, i think
11:10:30 * mnoonan nods
11:10:57 <amalloy> because in that context you've already done the pattern matching and so know what constructors your values have
11:11:27 <L0g4nAd4ms> well but then i have to change a couple of things
11:12:05 <L0g4nAd4ms> well but there seems to be no other choice with those constraints
11:12:23 <L0g4nAd4ms> because i have to destructure and restructure, very unsatisfying
11:12:51 <amalloy> sounds about right
11:13:02 <amalloy> unsatisfying because the constraints you're working with are awkward
11:13:05 <kadoban> Peter123: I think there is some primitive from some library that'll do something like that, trying to remember what it is. http://tomasp.net/blog/speculative-par-monad.aspx/ this sounds like it, except experimental and a bit odd
11:14:02 <L0g4nAd4ms> amalloy, not my choice :P
11:15:44 <Peter123> kadoban: thanks! I have to check it out. I didn't find this in Simon Marlow's book, but I might have overlooked it.
11:16:36 <lyxia> Peter123: there's "race" in async
11:17:01 <kadoban> Peter123: I thought there was at least something in that book about it, but I really could be remembering totally wrong, and I'm not seeing it on a quick scan. "haskell speculative parallelism" seems to be yielding some hits though. Or that sounds right ^
11:18:03 <Peter123> lyxia: Thanks for the tip! This seems to require "IO" and not pure sort functions. Will use that if IO isn't aviodable.
11:19:16 <lyxia> Peter123: I don't think you can avoid IO. Par/unamb just hide it.
11:20:13 <metahumor> L0g4nAd4ms: "f (s@(Circle _) _) = circleval; f _ = defaultval"
11:20:21 <lyxia> Peter123: if the two sort functions return different results, then such a combinator would be nondeterministic
11:21:27 <kadoban> Peter123: http://hackage.haskell.org/package/unamb sounds possible, though I don't know much about it really at all.
11:22:08 <Peter123> lyxia: That would be a problem. I've checked with quickcheck that the results are always the same, samplesize 10000 different sorts.
11:22:57 <Peter123> kadoban: great!
11:23:20 <L0g4nAd4ms> metahumor, is this the pattern binding thing like in rust
11:24:46 <metahumor> you have "data Shape = Circle Float | Rectangle Float Float", so if my function is "f shape blah = ..."
11:24:58 <metahumor> i can pattern match on constructors that give me Shape
11:25:17 <metahumor> in this case, "f (Circle floatval) _ = ..."
11:25:52 <metahumor> the "s@(Circle floatval)" syntax makes me also have access to the value of type Shape under name "s"
11:26:02 <metahumor> jic you need that constructed value too
11:26:32 <metahumor> the "_" is a way to ignore function arguments that you won't need
11:26:55 <lyxia> Peter123: that's fine I guess. The point is to be mindful of it. unamb is probably what you're looking for, but there's a bug that makes it not finish as soon as one side terminates https://github.com/conal/unamb/pull/1
11:31:01 <argent0> Hi, does anyone uses haskell on archlinux is willing to share their config for cabal or stack? Arch wiki haskell page seems to be outdated
11:31:22 <cocreature> ertes-w: what problems are you running into?
11:32:21 <cocreature> eh that was meant for argent0
11:34:43 <argent0> Hi cocreature I was looking at your answer here: "https://www.reddit.com/r/haskell/comments/7a1ty3/whats_the_correct_way_to_install_ghc_and_cabal_on/". My issue is that `cabal install --only-dependencies` fails to install the linear package and complains about missing packages. Is your reddit answer still relevant?
11:34:52 <kadoban> argent0: I know there's some magic recipes in the stack issue tracker for various problems, mostly just random fixes to try if you're running into some specific problem.
11:35:11 <cocreature> argent0: yes it is, how did you install cabal?
11:35:27 <cocreature> argent0: also please show us the full error you are geting. maybe it’s something unrelated
11:44:44 <argent0> cocreature: This is how I setup my project: http://lpaste.net/533353316604706816 and the errors thereafter
11:46:12 <cocreature> argent0: remove shared: true and executable-dynamic and then follow the instructions in that reddit post
11:47:25 <argent0> kadoban: I've been using those magic recipes, it works today but maybe not after updating.
11:47:34 <argent0> cocreature: ok, i'll give it a go
11:48:43 <jason10> How would I define a monoid for ordered lists?
11:50:58 <cocreature> jason10: merge them by looking at the heads of both lists, taking the smaller element and recurse on the remaining lists
11:52:35 <wedify> is there a document that explains what issues cabal/stack face? like what's important and what's difficult?
11:52:54 <wedify> i'm itching to help but it is a complex thing
11:53:55 <lyxia> wedify: look at the issue trackers
11:57:10 <wedify> lyxia: cool idea, thanks
11:59:28 <jason10> cocreature: thanks
12:14:49 <Psybur> I finally got around to making that wiki on RWST with the code example that helped me understand working with monads more
12:14:50 <Psybur> https://wiki.haskell.org/Simple_RWST_use
12:15:00 <Psybur> If anyone wants to improve it feel free ;p
12:15:07 * hackage tasty 1.0.0.1 - Modern and extensible testing framework  https://hackage.haskell.org/package/tasty-1.0.0.1 (RomanCheplyaka)
12:24:27 <codedmart> I am trying to upgrade my project to stack lts-10.3 (ghc 8.2). If I use `--fast` it compiles, but without `--fast` I get an out of memory error. Any thoughts on what I could look for?
12:24:53 <Peter123> stack isn't very good with 8.2 and 8.2.2
12:25:14 <Peter123> Is 8.2 even officially supported?
12:25:14 <MarcelineVQ> codedmart: is it your project that happens on or dependencies?
12:25:21 <MarcelineVQ> Peter123: yes
12:25:23 <kadoban> Peter123: Yes
12:25:31 <codedmart> MarcelineVQ: My project.
12:25:39 <kadoban> codedmart: How much memory do you have?
12:25:46 <Peter123> OK. 8.2. is uspported and 8.2.2 is unsupported. I see.
12:25:53 <codedmart> 16GB and like a 2GB swapfile.
12:26:06 <codedmart> It is fine with GHC 8.0.2.
12:26:31 <kadoban> Peter123: That certainly doesn't sound right. There are LTS releases using 8.2.2
12:26:46 <codedmart> Not really sure where to start debugging.
12:27:42 <kadoban> codedmart: Odd. I've never seen stack specifically increase memory usage greatly. I mean you could try -j1 on the build, but ... that's a lot of memory. GHC occasionally has bugs that cause OOM for certain weird source files, is there anything particularly odd about your project?
12:28:08 <Peter123> I can only use 8.2.2 if I set "allow-newer". But perhaps it is supported. Stack also only officially supports a quite old version of cabal.
12:28:11 <Peter123> But okay.
12:28:27 <cocreature> codedmart: is it failing for your own project or for a dependency?
12:28:36 <MarcelineVQ> Peter123: to use a newer ghc you use a newer resolver
12:28:46 <kadoban> Peter123: You're probably trying to use a different version of GHC than the resolver you have set. Change to a different resolver if you want that.
12:28:47 <Peter123> I use the nightly resolver
12:28:58 <Peter123> Okay, I have to study that more.
12:29:00 <kadoban> Peter123: From which night?
12:29:11 <Peter123> ~ 8. of January
12:29:21 <cocreature> codedmart: either way that sounds like something that’s worth a bugreport
12:29:40 <kadoban> Also, AFAIK stack supports cabal-install 2.something, just not every little feature yet possibly.
12:29:55 <codedmart> cocreature: For my own project
12:30:00 <kadoban> Peter123: That should be using GHC 8.2.2 by itself then.
12:30:17 <cocreature> codedmart: definitely make a bugreport in that case
12:30:26 <codedmart> kadoban: Not sure about odd. There is a fair amount of type level programming in spots.
12:30:28 <jason10> cocreature: can you help me with some type problem I have?
12:30:34 <kadoban> Assuming you mean 8th of january this year, you're not on 2017, right? There actually doesn't look like there was a nightly on 2018-01-08, but ...
12:30:49 <cocreature> jason10: maybe? you haven’t told us the problem so it’s hard to say if I can solve it :)
12:31:45 <jason10> cocreature: http://lpaste.net/1754014439813677056
12:32:00 <kadoban> cocreature: I'm not all that familiar with that kind of fanciness, but maybe check the bug tracker and see if anything pops up (the GHC one, I wouldn't think stack would care)
12:32:08 <kadoban> Woops, codedmart ^
12:32:08 <jason10> cocreature: I did like you said, pick the smaller element of both lists and then recurse on remaining lists
12:32:11 <Peter123> I have another question. Is there also a pure monad that doesn't allow any IO? I want my code parametrized over a Monad. An later it should be possible to run it again as pure code (pure means without any IO).
12:32:52 <amalloy> Peter123: every monad except for IO (and transformers with IO at their base) does not allow IO
12:33:52 <Peter123> amalloy: Okay, seems to be a beginner question then. Is there an example of how to write generic code, where generic means generic of the type of monad?
12:34:27 <amalloy> sure, lots. for example, the function (liftA2 (,)) is a simple one
12:34:29 <infinisil> Peter123: You can use the Identity monad if you just don't need any monad
12:34:53 <amalloy> liftA2 (,) [1,2,3] "abc"
12:34:54 <cocreature> jason10: 1. I don’t think that unicode syntax works, ε is not the same as mempty. 2. in the recursive case you are using `mappend` on lists instead of using it on OrdLists
12:34:54 <Peter123> infinisil: thanks!
12:34:58 <amalloy> > liftA2 (,) [1,2,3] "abc"
12:35:00 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
12:35:17 <amalloy> > liftA2 (,) (Just 1) (Just 'a')
12:35:21 <lambdabot>  Just (1,'a')
12:35:56 <cocreature> jason10: you are also missing the basecases where one of the lists is empty
12:36:43 <mnoonan> Peter123: you can make a little mini-typeclass that defines the capabilities you want, then instantiate it purely or with IO. e.g. https://commentedcode.org/blog/2017/08/21/better-io-testing-through-monads/
12:36:45 <jason10> cocreature: How can I fix 2.?
12:37:02 <mnoonan> (well, "mini".. I guess they end up being relatively large :)
12:37:07 <kadoban> Peter123: Essentially: blah :: Monad m => something something something -> stuff -- this won't let you use anything that's specific to IO. Though I'm not sure that's actually what you're looking for.
12:37:14 <cocreature> jason10: wrap the lists in Ord, call mappend and then unwrap them after that.
12:37:24 <cocreature> jason10: e.g. http://lpaste.net/361511 should fix all problems
12:38:19 <cocreature> jason10: alternatively you could write a separate "merge :: Ord a => [a] -> [a] -> [a]" function and then only unwrap the newtype once to call that
12:38:31 <Peter123> Thanks! Great!
12:38:36 <codedmart> Can I build a single file with stack?
12:38:49 <jason10> cocreature: ah yes, I had trouble unwrapping it, but I see how it's done now, thanks!
12:39:07 <cocreature> codedmart: yep use "stack ghc"
12:40:03 <kadoban> cocreature: You can use runghc, or more interestingly you can also use the script interpreter stuff. Kind of depends what it should do
12:40:14 <codedmart> cocreature: Oh right
12:40:28 <kadoban> Crap, I am awful at directing at the right person today.
12:42:26 <duairc> Hey, does anyone know if there's a Haskell library somewhere that will take something like a NominalDiffTime and return a string like "3 hours ago" or "7 months from now" and so on? Localisation would be nice to have but not absolutely necessary right now
12:44:52 <cocreature> duairc: https://hackage.haskell.org/package/friendly-time-0.4.1/docs/Data-Time-Format-Human.html although it only accepts to times rather than a NominalDiffTime so you’ll have to make up some time
12:45:37 * hackage singleton-nats 0.4.0.4 - Unary natural numbers relying on the singletons infrastructure.  https://hackage.haskell.org/package/singleton-nats-0.4.0.4 (AndrasKovacs)
12:46:13 <cocreature> or make a pull request to expose a function that operates on NomialDiffTime :)
12:48:43 <duairc> cocreature: Thanks, that's the kind of thing I was looking for! It's annoying because it seems to use NominalDiffTime internally, just doesn't expose it in the API for some reason
12:50:05 <infinisil> goddamnit, my IRC bot written in haskell randomly terminates every couple days
12:50:20 <infinisil> my intuition says memory leak
12:50:52 <infinisil> very easy for it to hide in my mess of code
12:51:47 <jason10> cocreature: I have a question about the base cases, e.g. Ord [] • ys = ys, is this correct? Because what if ys is not ordered?
12:53:12 <argent0> cocreature: I followd the reddit instructions but, alas, I can't build the `foo` project: http://lpaste.net/533353316604706816 Why is it speaking about reinstalls? I deleted the sandbox
12:53:57 <amalloy> jason10: if your type is the type of sorted lists, and all your operations on sorted lists maintain their sortedness, then it is impossible for ys to not be sorted
12:54:38 <amalloy> (plus, if that invariant were somehow not preserved, this mappend function would not be the place to detect&fix it)
12:56:08 <jason10> amalloy: ok I see, but can such a monoid be used to sort a given list?
12:57:18 <amalloy> i don't understand that question at all
12:58:12 <jason10> amalloy: http://lpaste.net/3227293663788793856
12:58:20 <jason10> How can I implement a sorting function using this monoid
12:59:47 <amalloy> so, i think what you need is a smart constructor, mkOrdList :: Ord a => [a] -> OrdList a
13:00:28 <amalloy> you'll have an [a] as input, which will not necessarily be sorted, and you wish to produce as output an OrdList a, which you will guarantee is sorted
13:02:13 <amalloy> you could use the Monoid instance for OrdList a to do this, for example by writing: mkOrdList = foldMap (Ord . pure)
13:02:24 <amalloy> but it would probably ont be terribly efficient
13:03:53 <jason10> amalloy: http://lpaste.net/4705037467613396992
13:03:56 <jason10> like this?
13:04:35 <jason10> *MapReduce> let a = [1,45,7,43,222,2,4,7] *MapReduce> monoidSort a Ord [1,2,4,7,7,43,43,45,222,222,222,222]
13:04:41 <jason10> I get this strange output
13:04:54 <jason10> some numbers are duplicated
13:05:41 <amalloy> yes, that looks correct. so probably your <> implementation is broken
13:08:41 <amalloy> ah, indeed. your otherwise clause uses ys in place of xs
13:09:48 <jason10> amalloy: ah oops! Thanks, finally got it working now :)
13:09:48 <platz> has anyone used https://hackage.haskell.org/package/discrimination in anger/practice?
13:10:28 <amalloy> jason10: note that you've just reimplemented foldMap, though. it might be a good exercise to work out why what you've written is equivalent to my suggestion, monoidSort = foldMap (Ord . pure)
13:15:27 <buhman> amalloy: your advent playlist is next-level enlightening, for me
13:16:45 <amalloy> i'm glad you're enjoying it
13:17:17 <amalloy> i forget, are you new to functional programming, or just new to haskell?
13:17:33 <buhman> both
13:22:37 <kadoban> platz: I tried to look at it at one point, but I got annoyed when I realized it doesn't even give a hint of how its statements of behavior could make sense or what computational model it's talking about or etc. You pretty much have to read the entire paper as far as I could tell.
13:23:48 <platz> kadoban: are you referring to usage or grokking internals?
13:27:07 <dmwit> kadoban: copy/paste from a comment I made on reddit a while ago: "Also a minor point about the discrimination package: linear-time sorting sounds so good, but please do a few small benchmarks before you dive deep. I was playing with it just this week, and in my (admittedly very simplistic) test discrimination used more memory and more time than Data.List.sort, right up to the point that my OOM-killer kicks in, so although it may scale better you 
13:27:12 <kadoban> platz: Just the time bounds it quotes mostly. Sorting general things in O(n) time is possible in some computational models, but not too many where it's a very good practical description IMO. It seems to me that it should have some short hint of how it's going to make sense or what the limitations are or etc. without reading ~100 pages of papers.
13:28:11 <kadoban> platz: The usage looks a little weird, but I figured it out enough to apparently get something to work. But then the small benchmarks I tried weren't very compelling so I stopped caring.
13:28:42 <kadoban> dmwit: Ah, yeah that's about what I found as well, but I didn't try that hard, just did a couple of small things.
13:29:45 <platz> kadoban/dmwit: ah, i see, thanks - yeah i did a search on github cabal files and wasn't finding much either; yes i usually treat theoritical bounds and constant factors as very different things, it's hard to use something without understanding of the latter
13:35:01 <kadoban> Well, the theoretical bounds are a bit funny as well, because it's fairly difficult to sort generic things in O(n) time. The most obvious way is in the comparison model, where it's provably impossible to sort an unordered collection of N things in O(N) time. So it kind of raises the question of what it's doing if not that. There's other O(N) sorts, in various models, but none of them at least immediately appear to apply. You're not going to sort Int64
13:35:03 <kadoban> using counting sort, you're not going to sort a collection you don't know the distribution of with bucket sort, radix sort you can kind of pretend is O(N) if you want, but it's not a super honest description and there's reasons people don't use radix sort too often in practice, etc. So all that's provided are theoretical bounds that don't immediately make sense to me. So I'm probably missing something, but just looking at it all I can tell is ... it
13:35:04 <kadoban> sorts stuff, and takes some amount of time, which is not bounded in a way I understand. And it doesn't give benchmarks or any reason to believe the constants are very good either.
13:40:23 <platz> perhaps there are some special use cases where bucketing is better than comparisons; would be interesting to see where radix sorts are actually used
13:44:58 <infinisil> platz: perhaps it would make sense with huge datasets, since then then O(n) really kicks in in comparison to O(nlogn)
13:46:33 <AndiK> Radix sort also seems like something that would be easier to parallelize
13:52:07 * hackage reddit 0.2.2.0 - Library for interfacing with Reddit's API  https://hackage.haskell.org/package/reddit-0.2.2.0 (Intolerable)
13:54:37 * hackage reddit 0.2.2.1 - Library for interfacing with Reddit's API  https://hackage.haskell.org/package/reddit-0.2.2.1 (Intolerable)
13:55:08 <MarcelineVQ> eddit 0.2.2.2 - Library for interfacing with Reddit's API  https://hackage.haskell.org/package/reddit-0.2.2.2 (Intolerable)
13:56:07 <Gurkenglas_> "
13:56:07 <Gurkenglas_> RedditT (FreeT (RedditF m) m a)" <- that m is in there twice smells wrong
13:57:27 <mniip> is it on the RHS of a data definition
13:58:23 <Gurkenglas_> mniip, "newtype RedditT m a = RedditT (FreeT (RedditF m) m a)"
13:58:41 <infandum> mnoonan: I got the best results using grep, so I can make do with that.
13:58:42 <Gurkenglas_> ...and RedditF refers to RedditT in its definition, ew
13:58:44 <infandum> Thanks though.
13:59:21 <Gurkenglas_> Which is also the only place RedditF uses m
13:59:30 <mniip> Gurkenglas_, then it's completely fine
14:23:01 <cement> Data.Vector is 1-indexed, right?
14:23:21 <dmwit> I don't think so.
14:23:28 <dmwit> ?let import qualified Data.Vector
14:23:30 <lambdabot>  .L.hs:130:1: error:
14:23:30 <lambdabot>      Data.Vector: Can't be safely imported!
14:23:30 <lambdabot>      The module itself isn't safe.
14:23:39 <glguy> \o/
14:23:47 <dmwit> Welp.
14:23:51 <glguy> Ask yahb
14:24:30 <dmwit> % V.singleton 0 V.! 0
14:24:31 <yahb> dmwit: ; <interactive>:20:1: error:; Not in scope: `V.singleton'; Perhaps you meant one of these: `S.singleton' (imported from Data.Set), `M.singleton' (imported from Data.Map), `IS.singleton' (imported from Data.IntSet); No module named `V' is imported.; <interactive>:20:15: error:; Not in scope: `V.!'; Perhaps you meant `M.!' (imported from Data.Map); No module named `V' is imported.
14:24:52 <dmwit> % import qualified Data.Vector as V; V.singleton 0 V.! 0
14:24:52 <yahb> dmwit: error: expecting a single import declaration
14:25:00 <dmwit> oh?
14:25:05 <dmwit> % import qualified Data.Vector as V
14:25:06 <yahb> dmwit:
14:25:11 <dmwit> % V.singleton 0 V.! 0
14:25:12 <yahb> dmwit: 0
14:25:21 <dmwit> cement: Looks 0-indexed to me.
14:25:42 <dmwit> yahb: help
14:26:20 <cement> tyvm
14:26:34 <mniip> dmwit, you are beyond helping
14:28:42 <cement> well, that's gotta be worth something as a milestone on my haskell journey: I was looking at a chain of functions, and some of them had types that gave back Maybes, and my immediate thought was "I should use the Maybe Monad"
14:30:11 <hoon> ...maybe ;)
14:35:17 <dmwit> mniip: =(
14:36:00 <dmwit> mniip: I just want to know how to un-import. Or is that just a Thing now? What if I accidentally import something with lots of name clashes?
14:36:19 <mniip> uhhh
14:36:23 <mniip> it's a ghci session
14:36:37 <dmwit> Oh, really?
14:37:10 <dmwit> % :m - Data.Vector
14:37:10 <yahb> dmwit:
14:37:12 <dmwit> neat
14:37:26 <benzrf> cement: "understanding monad" is simply understanding which patterns of code can be understood as usage of the Monad interface
14:37:47 <dmwit> % V.singleton 0 V.! 0 -- just to be sure...
14:37:47 <yahb> dmwit: ; <interactive>:26:1: error:; Not in scope: `V.singleton'; Perhaps you meant one of these: `S.singleton' (imported from Data.Set), `M.singleton' (imported from Data.Map), `IS.singleton' (imported from Data.IntSet); No module named `V' is imported.; <interactive>:26:15: error:; Not in scope: `V.!'; Perhaps you meant `M.!' (imported from Data.Map); No module named `V' is imported.
14:38:40 <dmwit> % !:ls
14:38:40 <yahb> dmwit: ; <interactive>:28:1: error: parse error on input `!:'
14:38:47 <dmwit> % :!ls
14:38:47 <yahb> dmwit: melt
14:38:51 <dmwit> oh my
14:38:53 <dmwit> salacious
14:39:09 <dmwit> % :!sleep 100
14:39:14 <yahb> dmwit: [Timed out]
14:39:22 <dmwit> v. nice
14:39:58 <cement> now I just gotta refactor certain functions into ExceptT and I'll feel competent with base haskell
14:40:14 <dmwit> mniip: I'm kind of impressed. How does that work?
14:40:23 <mniip> magic
14:40:30 * dmwit nods agreeably
14:41:23 <mniip> ptrace
14:54:07 * hackage fast-arithmetic 0.2.0.0 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.2.0.0 (vmchale)
14:56:02 <unclechu> hey guys, about haskell-stack, `lts-3.12` is broken now, this revision https://hackage.haskell.org/package/semigroupoids-5.0.0.4/revisions/ brakes build-plan
14:56:22 <unclechu> revision have been made 6 jan
14:56:50 <unclechu> is there a solution to use original revisions or something like this?
14:59:05 <jle`> welp
15:05:37 * hackage hspec-dirstream 0.2.0.0 - Helper functions to simplify adding integration tests.  https://hackage.haskell.org/package/hspec-dirstream-0.2.0.0 (vmchale)
15:07:53 * unclechu created an issue https://github.com/fpco/stackage/issues/3185
15:09:37 * hackage fast-arithmetic 0.2.0.1 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.2.0.1 (vmchale)
15:54:57 <codedmart> Does `-Wall -Werror` give a error or warning on a missing case?
15:56:14 <metahumo1> warning "-Wincomplete-pattern" iirc
15:56:22 <metahumo1> *patterns
15:57:27 <codedmart> metahumo1: Thanks
15:57:47 <codedmart> I thought that was on with -Wall
15:57:52 <metahumo1> it is
15:57:59 <metahumo1> i meant that its a warning
16:03:41 <Costar> Hi
16:11:37 * hackage map-exts 0.1.1.0, map-exts 0.2.0.0 (coopercm): https://qbin.io/tbe1c0g
16:11:56 <metahumor> hi
16:13:27 <Zemyla> Oh, this is a thing I've been looking for https://elephly.net/posts/2017-01-09-bootstrapping-haskell-part-1.html
16:19:45 <dmwit> codedmart: That seems like a really easy question to answer yourself by doing a quick experiment.
16:44:41 <centril> Does the concept of "Associated types" originate from Haskell? Or does Haskell derive them from somewhere else? I found: https://www.microsoft.com/en-us/research/wp-content/uploads/2005/01/at-syns.pdf
16:46:43 <hxx> heyo
16:46:50 <hxx> can anyone help me with lenses
16:47:01 <sqooq> j'ai retourne
16:47:15 <sqooq> hxx, what's up, I probably can't help much but maybe.
16:47:29 <Uniaika> sqooq: tu retournes ?
16:47:52 <hxx> i have an object A that have a function mutate :: a -> IO a
16:47:57 <hxx> a list of A's
16:48:11 <sqooq> Uniaika, Oui. Je suis la. J'ai retourne'
16:48:12 <hxx> a list of indexes to mutate
16:48:27 <hxx> and i would like to something like
16:48:27 <hxx>   pure $ foldl (.) id (map (\i -> element i %~ mutate) idx) pop
16:48:39 <hxx> where pop are my A's
16:48:46 <Uniaika> sqooq: "je suis de retour" plutôt, non ?
16:48:52 <glguy> Sorry, English only
16:48:54 <sqooq> idk I don't speak french
16:48:59 <mniip> :t Control.Lens.Indexed.indices (`elem` ?is)
16:49:01 <lambdabot> (Applicative f, Foldable t, ?is::t a1, Eq a1, Indexable a1 p) => Optical' p (Indexed a1) f a2 a2
16:49:19 <sqooq> Uniaika, yeah that sounds right lmao. learn something new everyday
16:49:29 <codeshot> hxx, are you trying to compose functions each of which is an a -> IO a? chaining them?
16:49:46 <codeshot> You have to use <=< to chain them instead of .
16:49:49 <hxx> codeshot: more like composing the update on the list
16:50:26 <hxx> for each index i in idx, i create a setter function that mutate the A at index i
16:50:50 <codeshot> so each element of [a] goes to [IO a] ?, then another such round of mutation is done after?
16:51:01 <mniip> :t (traversed . Control.Lens.Indexed.indices (`elem` ?is)) (?mutate `asTypeOf` evaluate)
16:51:03 <lambdabot> (Foldable t, ?mutate::b -> IO b, ?is::t Int, Traversable f) => f b -> IO (f b)
16:51:05 <mniip> hxx, ^
16:51:18 <glguy> foldM (\acc i -> element i mutate acc) idx
16:51:22 <hxx> it's more like i have trouble with the lens part, its working if i remove the IO from mutate
16:51:28 <glguy> foldM (\acc i -> element i mutate acc) original  idxx
16:51:39 <hxx> glguy: will try that thanks
16:52:10 <Costar> sqooq: are you french?
16:52:31 <sqooq> Costar, creole perhaps, mais non
16:53:09 <hpc> centril: if not haskell, somewhere else in the ML family
16:53:25 <sqooq> Je me suis appris un peu de francais, mais je ne sais pas si je le parles correctement
16:53:39 <codeshot> Also I think replacing (.) with ((<=<) . sequence) will do it. sequence will pull the IOs out ([IO a] -> IO [a]) and the <=< will compose one transformation with the next in the same way
16:53:41 <hpc> centril: i can't actually think of a non-ML language that has that terminology
16:53:43 <centril> hpc: aight, but can I say "Haskell popularized associated types" ?
16:53:44 <codeshot> I didn't check though
16:54:01 <mniip> codeshot, sounds like traverse might come up somewhere
16:54:18 <hxx>  
16:54:18 <hxx>   pure $ foldM (\acc i -> acc & element i %~ mutate) pop idx
16:54:21 <hpc> centril: that's probably close enough to true, yeah
16:54:22 <codeshot> yeah because traverse = sequence .fmap and map = fmap for lists
16:54:30 <centril> hpc: cheers
16:54:38 <mniip> haven't checked but sequence is usually the more convoluted answer
16:54:40 <codeshot> so . becomes <=< and map becomes traverse
16:54:42 <sqooq> is monochrom and dmwit present?
16:54:43 <glguy> hxx: pure and %~ won't feature
16:54:47 <sqooq> I forgot what they taught me
16:54:55 <glguy> hxx: If you're set on using an operator you can use %%~
16:55:03 <mniip> monochrom and dmwit pelase repeat everything you've ever said
16:55:04 <codeshot> but it can be really instructive to replace one element with an alternative
16:55:24 <sqooq> haha
16:56:17 <codeshot> mniip, may I say I think both your manner and knowledge are excellent
16:56:37 <hxx> glguy: i'm not finding the way :(
16:57:02 <mniip> codeshot, thanks but I already knew that
16:57:15 <mniip> nononono
16:57:23 <mniip> codeshot, you're telling me as if I don't already know
16:57:36 <sqooq> wat
16:57:41 <sqooq> r u being cocky
16:57:49 <mniip> sense the irony
16:57:54 <codeshot> only 99/100 - one mark lost on modesty
16:57:55 <sqooq> mniip, teach me how to memoFix
16:58:02 <iqubic> Does Dante need internet to work?
16:58:07 * hackage fast-arithmetic 0.2.1.0 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.2.1.0 (vmchale)
16:58:28 <mniip> uhh
16:58:29 <mniip> one second
16:58:42 <iqubic> So I finally figured out how fix works. But I have no idea how to write fibs with fix.
16:58:54 <sqooq> iqubic, same haha!
16:59:00 <jle`> iqubic: first write fibs without fix, then fixify it
16:59:05 <sqooq> ye
16:59:29 <jle`> iqubic: one way to look at it is to just parameterize over the recursive "next" call
16:59:39 <Costar> iqubic: do a catamorphism on your Fix with the proper Algebra.
16:59:43 <jle`> fac n = n * fac (n - 1)
16:59:43 <sqooq> fib n = \x -> x (n-1) + x (n-2)
16:59:54 <codeshot> iqubic, jle` has the strategy the detail is that fibs = blah fibs blah goes to fibs recurse = blah recurse blah
16:59:57 <jle`> but instead of directly re-facing
17:00:05 <sqooq> idek what fib is
17:00:05 <jle`> parameterize by a continuation
17:00:07 <sqooq> I've never made one
17:00:11 <jle`> fac nextFac n = n * nextFac (n - 1)
17:00:17 <glguy> hxx: You can do it like I pasted in the foldM code above
17:00:17 <codeshot> well fibs_step recurse = blah recurse blah, and fibs = fix fibs_step
17:00:33 <jle`> i think i did that backwards
17:00:39 <iqubic> jle`: fib n = if n < 2 then n else fib (n - 1) + fib (n - 2)
17:00:46 <iqubic> How do I fixify that?
17:00:54 <jle`> iqubic: instead of directly calling fib again
17:01:04 <jle`> parameterize on a continuation
17:01:13 <iqubic> What is a continuation?
17:01:15 <hxx> glguy: the signature is pretty strange, not working in my case...
17:01:18 <jle`> fib n nextFib = if n < 2 then n else nextFib (n - 1) + nextFib (n - 2)
17:01:19 <sqooq> iqubic, the recursive part is that you're calling fib
17:01:21 <sqooq> so fix that
17:01:23 <codeshot> iqubic, fib_step recurse n = if n < 2 then n else recurse (n - 1) + recurse (n - 2)
17:01:26 <codeshot> that's all
17:01:30 <glguy> hxx: I can't see your screen so I don't know what you did
17:01:30 <jle`> did i do it backwards again
17:02:01 <jle`> yeah i did it backwards
17:02:13 <jle`> iqubic: isntead of directly caling fib, let the user provide a "next step" function
17:02:14 <codeshot> you see each fib was replaced by recurse, the name is now fib_step (just my convention) and there's a recurse argument
17:02:27 <Costar> continuations are the Yoneda lemma with Identity Functor
17:02:27 <codeshot> now "fibs = fix fib_step"
17:02:28 <jle`> fib nextStep n = if n < 2 then n else nextStep (n - 1) + nextStep (n - 2)
17:02:40 <mniip> @let memoFix p = f where f = p (lup (jn (p2 (-1) 0) 0 (p2 0 1))); jn l a r = Free (Compose ((a, f a),bool l r)); lup (Free (Compose ((b, x), f))) a = case compare a b of { LT -> lup (f False) a; EQ -> x; GT -> lup (f True) a }; p2 i j = if i >= 0 then jn (bi i j) j (p2 j (2 * j)) else jn (p2 (2 * i) i) i (bi i j); bi i j = let m = (i + j) `div` 2 in jn (bi i m) m (bi m j)
17:02:40 <lambdabot>  Parse failed: Illegal character ''\SI''
17:02:43 <mniip> @let memoFix p = f where f = p (lup (jn (p2 (-1) 0) 0 (p2 0 1))); jn l a r = Free (Compose ((a, f a),bool l r)); lup (Free (Compose ((b, x), f))) a = case compare a b of { LT -> lup (f False) a; EQ -> x; GT -> lup (f True) a }; p2 i j = if i >= 0 then jn (bi i j) j (p2 j (2 * j)) else jn (p2 (2 * i) i) i (bi i j); bi i j = let m = (i + j) `div` 2 in jn (bi i m) m (bi m j)
17:02:45 <lambdabot>  Defined.
17:02:49 <mniip> :t memoFix
17:02:50 <jle`> iqubic: now you can sort of see what happens if you want to recover your original fib
17:02:51 <lambdabot> Integral a => ((a -> p) -> a -> p) -> a -> p
17:02:55 <codeshot> jle`, nextStep is misleading. It's all following steps
17:03:19 <mniip> :t memoFix (\f x -> if x < 2 then 1 else f (x - 1) + f (x - 2))
17:03:21 <lambdabot> (Num a2, Integral a1) => a1 -> a2
17:03:26 <mniip> > memoFix (\f x -> if x < 2 then 1 else f (x - 1) + f (x - 2)) 100
17:03:28 <hxx> glguy: i have a list of indexes idx, a list of A's and i have a function mutate :: a -> IO a, i would like to update each A at index (in idx) by applying the mutate function on it
17:03:29 <lambdabot>  573147844013817084101
17:03:44 <glguy> hxx: Yeah, that's what the code I pasted did
17:03:51 <jle`> @let replaceableFib nextStep = \n -> if n < 2 then n else nextStep (n - 1) + nextStep (n - 2)
17:03:54 <lambdabot>  Defined.
17:03:55 <mniip> what's wrong with my code :(
17:04:02 <iqubic> fibs = fix (\n -> if n < 2 then n else fibs (n - 1) + fibs (n - 2))
17:04:12 <sqooq> iqubic, no
17:04:16 <jle`> iqubic: now for that part there, you can imagine what would happen if you passed different things to nextStep
17:04:19 <sqooq> the fibs is still direct recursion
17:04:19 <mniip> iqubic, that's both wrong and bad
17:04:23 <iqubic> Wait, that doesn't work.
17:04:28 <jle`> > replaceableFib id 1
17:04:30 <codeshot> iqubic, fibs = fix (\recurse n -> if n < 2 then n else recurse (n - 1) + recurse (n - 2))
17:04:31 <lambdabot>  1
17:04:39 <sqooq> you're basically replacing the recursion with the variable in fix
17:04:40 <jle`> > replaceableFib id 2
17:04:43 <lambdabot>  1
17:04:50 <sqooq> like codeshot
17:05:06 <jle`> what you really "want" to do is give replaceableFib itself, as its own continuation
17:05:26 <jle`> > replaceableFib (replaceableFib (replaceableFib (replaceableFib id)) 4
17:05:31 <lambdabot>  <hint>:1:70: error:
17:05:31 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
17:05:36 <jle`> > replaceableFib (replaceableFib (replaceableFib (replaceableFib id))) 4
17:05:41 <lambdabot>  3
17:06:06 <jle`> what's what 'fix' does, it gives the function itself as its continuation/"next step", forever
17:06:11 <iqubic> fib = fix (\f -> \n -> if n < 2 then n else f (n-1) + f (n-2))
17:06:15 <iqubic> is that right?
17:06:19 <jle`> what happens when you try?
17:06:20 <iqubic> Does that work?
17:06:27 <codeshot> iqubic, looks right
17:06:28 <hxx> glguy: thanks dude :)
17:06:37 <hxx> glguy: no way to do it with lenses ?
17:06:39 <iqubic> Why the heck does that even work?
17:06:46 <mniip> hxx, hello?
17:06:57 <glguy> hxx: It's doing it with the same operations you asked about
17:06:59 <jle`> iqubic: look at the function fib f n = if n < 2 then n else f (n - 1) + f (n - 2)
17:07:07 <jle`> iqubic: what does "f" have to be, for that to be fibonnaci?
17:07:14 <jle`> it has to be fib, right:
17:07:18 <jle`> *right?
17:07:39 <hxx> mniip: hey
17:07:43 <jle`> iqubic: do you see how, if you pass in the original "fib" to f there, it'll be exactly the original fib?
17:07:48 <mniip> hxx, traversed . indices (`elem` is)
17:07:49 <iqubic> Yes.
17:07:53 <jle`> that's what fix does
17:07:53 <mniip> hxx, where is is your index list
17:07:56 <jle`> it passes the function to itself
17:08:01 <iqubic> I see.
17:08:06 <hxx> glguy: okay
17:08:11 <iqubic> So why did you call it a continuation?
17:08:14 <jle`> fix fib is fib (fib (fib (fib (fib ...))) etc.
17:08:20 <codeshot> iqubic, fix passes the fix (\f -> ...) in as f so when you call f it's calling the whole of fibs again
17:08:32 <iqubic> Yes.
17:08:50 <jle`> iqubic: i called it a continuation because it's like the "next thing to do" to proceed in your computation
17:08:57 <iqubic> so fix takes the the function you give it, and feed it to itself?
17:09:01 <jle`> yeah
17:09:04 <jle`> fix f = f (fix f)
17:09:06 <iqubic> fix f = f (fix f)
17:09:10 <iqubic> I see.
17:09:16 <mniip> that's wrong however
17:09:21 <codeshot> it feeds "fix (\f -> ...)" to your (\f -> ...)
17:09:21 <mniip> fix f = let x = f x in x
17:09:28 <jle`> so fix fib = fib (fib (fib (fib (fib ...)))
17:09:29 <glguy> mniip's traversed will only "traverse" the list once, using elements will repeatedly traverse, so that's a bonus
17:09:56 <mniip> I don't like the 'elem' though
17:09:56 <jle`> iqubic: and (fib (fib (fib (fib ...)))) is exactly the argument you need to give to 'fib' to give it fibby behavior
17:10:08 <iqubic> how are those two definitions of fix isomorphic?
17:10:47 <jle`> iqubic: x is 'fix f'
17:11:46 <iqubic> both of the functions boil down to f (f (f (f (f (f...)))))
17:11:46 <mniip> there's a performance difference: my fix will use data sharing by creating a single thunk, jle`'s fix will be constantly applying closures
17:12:15 <sqooq> mniip, ok now fix my memoFi
17:12:23 <mniip> :t fix memoFix
17:12:25 <lambdabot> error:
17:12:25 <lambdabot>     • Occurs check: cannot construct the infinite type: p ~ a -> p
17:12:25 <lambdabot>       Expected type: (a -> p) -> a -> p
17:12:27 <sqooq> i have `summ x = fix (\w -> x +: del dt w )`
17:12:30 <sqooq> which works
17:12:34 <sqooq> how do I memofy this
17:12:47 <mniip> I have no idea what that is
17:12:51 <sqooq> x :: (t -> a)
17:12:51 <codeshot> doesn't jle`'s fix share the closure after a couple of reduction steps - ie, a constant overhead upon first use
17:12:58 <sqooq> :(
17:13:02 <iqubic> So can you use fix to write the ackermann function?
17:13:03 <mniip> x = unsafeCoerce?
17:13:09 <mniip> iqubic, yes
17:13:16 <iqubic> How?
17:13:20 <mniip> by definition
17:13:35 <sqooq> mniip, well x :: Signal Double, where Signal t a = Signal (t -> a)
17:13:35 <jle`> codeshot: i don't think so
17:13:49 <mniip> sqooq, kind error!
17:13:58 <sqooq> then +: is just liftA2 on the signal, so it just adds the signals
17:14:15 <sqooq> how is it a kind error?
17:14:17 <sqooq> it works fine
17:14:21 <mniip> Signal Double :: * -> *
17:14:32 <sqooq> ugh huh
17:14:45 <mniip> what I'm trying to say is too little information
17:14:50 <sqooq> :(
17:15:00 <mniip> either concentrate your problem to a minimal testcase
17:15:07 <mniip> or introduce me to the whole context
17:16:13 <centril> Would you guys be irked if I repurposed the word "pure" as a keyword in Rust that wraps a value in a container and then early-returns that container?
17:16:35 <jle`> doesn't really sound anything like purity but
17:16:45 <mniip> centril, is it an applicative container
17:16:48 <codeshot> that early return is exactly the opposite of what haskell does - it would be confusing
17:16:55 <centril> mniip: yes
17:17:11 <codeshot> do { pure a; pure b; } -> we get the second value not the first
17:17:17 <sqooq> mniip, http://lpaste.net/3810176087984439296
17:17:28 <jle`> codeshot: i mean, that pure doesn't follow the applicative laws for 'pure'
17:17:31 <jle`> so you might have to have two things
17:17:39 <jle`> one that follows the applicative laws and the other just a keyword 'pure'
17:17:45 <centril> codeshot: yeah, I'm changing the meaning somewhat in Rust
17:17:51 <jle`> the pure keyword wouldn't be Applicative pure
17:17:57 <centril> jle`: yea true
17:18:02 <codeshot> I think that would make a problem for people crossing over languages
17:18:07 <jle`> but Applicative pure isn't really the best named either
17:18:18 <mniip> yesterday
17:18:25 <mniip> someone insisted a functor is just a lambda
17:18:26 <sqooq> all my troubles seemed so far away
17:18:27 <jle`> centril: the main problem is that what you are propsing isn't Applicative, but something else
17:18:35 <mniip> and they threw wikipedia pages at me
17:18:40 <centril> codeshot: but I mean... "return" in haskell vs. return in some imperative language
17:18:41 <mniip> all because C++ repurposed our word
17:18:48 <jle`> haha
17:18:50 <sqooq> that's hilarious
17:19:17 <sqooq> "
17:19:17 <sqooq> Ask Question
17:19:17 <sqooq> up vote
17:19:17 <sqooq> 30
17:19:17 <sqooq> down vote
17:19:17 <sqooq> favorite
17:19:17 <mniip> centril, long story short if you have any sort of reputation in rust please don't
17:19:18 * centril is just making sure every other Haskller won't hate him for introducing this in Rust
17:19:19 <sqooq> 5
17:19:21 <sqooq> 	
17:19:23 <sqooq> I wonder where should we use lambda expression over functor in C++. To me, these two techniques are basically the same, even functor is more elegant and cleaner than lambda. For example, if I want to reuse my predicate, I have to copy the lambda part over and over. So when does lambda really come in to place?
17:19:27 <sqooq> c++ lambda
17:19:29 <sqooq> shareimprove this question
17:19:31 <sqooq> 	
17:19:33 <sqooq> edited Feb 13 '17 at 15:45
17:19:35 <sqooq> Cœur
17:19:37 <sqooq> 10.7k36898
17:19:39 <sqooq> 	
17:19:40 --- mode: ChanServ set +o mniip
17:19:41 --- mode: mniip set +q sqooq!*@*
17:19:44 <codeshot> centril, two wrongs don't make a right
17:19:52 <jle`> centril: well, i mean, i don't use Rust.  but, if you want to utilize Applicative/the Applicative abstraction, then you can't do it with that 'pure'
17:20:01 <codeshot> The haskell designers apologised for 'return'
17:20:04 <jle`> if that's the reason you chose the name in the first place
17:20:37 <centril> mniip: idk if I have this reputation, but I've written most RFCs for 2018 so far :P
17:21:18 <centril> jle`: the reason wasn't so much Applicative as "Pointed" (has no laws) in general - i.e: wrap stuff in container
17:21:47 <Costar> codeshot: why?
17:22:09 <centril> Are you guys more comfortable with `wrap` instead of `pure`?
17:22:16 <jle`> i don't really think Pointed wraps stuff in containers in general
17:22:33 <jle`> that's more a behavior of a specific degenerate subset of Pointed instances
17:22:41 <codeshot> Costar, because it doesn't return control
17:22:54 --- mode: mniip set -qo sqooq!*@* mniip
17:22:57 <codeshot> "apologised" is a humorous turn of phrase only
17:23:10 <jle`> well, they're apologizing for it by removing it from Monad
17:23:16 <sqooq> I'm sorry. idk what happened there. I thought I copied one small thing
17:23:18 <jle`> so i guess they're putting their money where their mouth is :)
17:23:20 <sqooq> but like the entire page got copied
17:23:33 <centril> jle`: elaborate? any example?
17:23:37 <sqooq> it was just someone saying more or less "lambdas are just syntactic sugar for functors" haha
17:23:43 <sqooq> (in C++)
17:23:52 <mniip> sqooq, worst part is is comes out line by line on the other end. You just finished by the time I unquieted you
17:23:54 <jle`> centril: most Pointed instances are not containers
17:23:57 <Costar> Hom functor lol
17:24:00 <centril> C++'s use of "functor" is so weird
17:24:03 <sqooq> mniip, ouch
17:24:10 <centril> jle`: you said so... example?
17:24:23 <jle`> (->) r, IO
17:24:24 <mniip> Costar profunctor lol
17:24:24 <Costar> jle`: Pointed is not that class with pure only?
17:24:38 <centril> class Pointed f where pure :: a -> f a
17:24:41 <jle`> State s
17:24:48 <codeshot> I don't understand the point of Pointed
17:25:00 <centril> codeshot: it has no useful laws, so I get your point.
17:25:06 <kadoban> centril: Best to think of them as just functions in C++
17:25:20 <jle`> i can only think of a few Pointed instances that are containers
17:25:27 <jle`> the rest aren't
17:25:28 <mniip> everything applicative is pointed
17:25:31 <mniip> question is what isn't
17:25:32 <centril> kadoban: yes I know what they are... but it irks me that they used functor for that
17:25:37 <codeshot> oh wait, pure has laws wrt const doesn't it?
17:25:47 <jle`> it's a free theorem
17:25:54 <centril> jle`: the word "container" is somewhat fuzzy
17:25:55 <codeshot> fmap (const x) a = pure x
17:26:01 <mniip> codeshot, fmap f (pure x) = pure (f x)
17:26:05 <kadoban> centril: Yeah, it's fairly annoying.
17:26:10 <codeshot> ooh
17:26:11 <jle`> centril: yes it's pretty fuzzy
17:26:20 <centril> jle`: I include State in my def of container
17:26:30 <codeshot> yup, that's fine and useful
17:26:31 <jle`> that ... doesn't sound like a very useful definition of container
17:26:36 <Costar> forall f. Pointed f => a -> f b -> f c is isomorphic to a x (b->c) + c
17:26:53 <centril> jle`: well, Mostly "container" for me is just defined as pure + fmap
17:26:56 <Costar> or Either c (a,b->c)
17:27:12 <jle`> centril: also definitely not a useful definition of container
17:27:12 <Costar> this is the only thing I know about Pointed
17:27:14 <mniip> Costar, is the isomorphism haskell-recoverable
17:27:34 <Costar> mniip: I think in one way
17:27:44 <mniip> well, Either->forall obviously
17:27:45 <codeshot> mniip, and my suggested law is bollocks anyway
17:27:49 <mniip> what about forall->Either?
17:28:27 <centril> jle`: I find it very useful to talk about containers and functors as the same thing when teaching functors & monads
17:28:30 <Costar> mniip: just theoretical, I think
17:28:43 <jle`> centril: i don't think it's a useful definition because it flies in the face of every other common intuition/definition of container
17:28:54 <mniip> actually are you sure that's right
17:28:59 <jle`> so it's not a particularly helpful definition either
17:29:02 <mniip> I see something along the lines of
17:29:18 <jle`> your intuition about containers doesn't apply to functors/pointed, and your intuition of functors/pointed doesn't apply to containers
17:29:26 <mniip> forall f. Pointed f => f b -> f c  ~~  Either c (b -> c)
17:29:33 <Costar> mniip: It is proved in a paper. A Representation Theorem for Second-Order Functionals. Proved by Jaskelioff
17:29:46 <jle`> so it's like...doubly useless
17:29:53 <iqubic> What's the best way to deal with random numbers in Haskell
17:30:02 <jle`> i mean, you can like, add them, subtract them
17:30:09 <jle`> maybe even multiply them
17:30:33 <codeshot> Costar, what's the precedence of x vs + ?
17:30:35 <mniip> hmm
17:30:41 <mniip> is Either the free Pointed
17:31:07 <mniip> or rather
17:31:08 <jle`> mniip: https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Applicative-Lift.html
17:31:12 <mniip> (Identity :+:)
17:31:13 <iqubic> jle`: What I meant was, what's the right way to generate random numbers?
17:31:14 <codeshot> iqubic, Num a => IO a
17:31:19 <mniip> right
17:31:23 <mniip> just like I said
17:31:23 <Costar> codeshot: the usual
17:31:38 <codeshot> like arithmetic?
17:32:01 <jle`> iqubic: it depends on your needs
17:32:12 <mniip> random = 4
17:32:18 <jle`> if you just need one random number , you can pick one from a hat
17:32:22 <jle`> and hard-code it
17:32:45 <iqubic> jle`: I need a way to get a random value from a list. Several dozen times.
17:32:55 <jle`> there's no one-size-fits-all solution, it all depends on what kind of randomness you want and for what purpose
17:33:31 <iqubic> I'm trying to generate numbers for an implementation of the game 2048.
17:33:31 <jle`> the 'random' module is sort of the built-in way, it's a part of the Report
17:33:47 <jle`> it's a basic way if your standards aren't too high
17:33:59 <jle`> MonadRandom wraps it with some utility combinators
17:34:10 <iqubic> What is MonadRandom?
17:34:16 <jle`> it's a package on hackage
17:34:23 <centril> Are there any nice papers or work for/about deriving Arbitrary for recursive and co-recursive types?
17:34:31 <jle`> that wraps the 'random' package with some utility combinators
17:34:44 <codeshot> iqubic I'm not sure but I suppose you start with System.Random.newStdGen if you can use a pseudo number generator with a random seem
17:35:07 <iqubic> codeshot: Yeah, that'll work.
17:35:36 <iqubic> Is there a good way to pipe around the generators?
17:36:21 <codeshot> iqubic, then use randomR
17:36:33 <codeshot> fmap
17:37:07 <codeshot> they're not service/reference objects - haskell's not like that
17:37:18 <iqubic> codeshot: that will work, but I'll have to pipe around the generators won't I?
17:37:32 <iqubic> yes, but how do I prevent duplicate code stuffs.
17:37:57 <codeshot> You can use a different generator for each purpose
17:38:27 <codeshot> I haven't done a lot with random numbers so I don't have a rule of thumb for you
17:38:51 <codeshot> and my intuition is still too junior to describe my thinking so I have to duck out
17:39:26 <jle`> MonadRandom gives you a nice way to propagate your generator, but for simple usage, manual passing is fine too
17:39:30 <codeshot> think about passing the numbers in
17:39:46 <mnoonan_> iqubic: you can use randomRs to get an infinte list of random numbers and just pass that around, taking numbers off the top as needed
17:39:56 <codeshot> you can generate an infinite list if need be - haskell can do that and it does the passing around in the background
17:39:59 <mnoonan_> you still have plumbing, but at least it isn’t in IO
17:41:04 <amca_> Random numbers, in ghci first load the random module with :m +System.Random
17:41:15 <mnoonan_> or random whatevers, since I guess you want to randomize positions and values both
17:41:19 <amca_> then create a generator with: g = mkStdGen 42
17:41:38 <amca_> then use it: take 10 $ randoms g
17:41:50 <codeshot> iqubic, each time you select an index do you have to delete that index from the list so the range is smaller next time?
17:42:02 <codeshot> (ie, lottery emulation)
17:42:15 <codeshot> if so then randomRs is not the right choice
17:42:19 <amca_> or: take 10 $ randomRs (1,40) g
17:43:33 <amca_> I believe you can use the State monad to keep the current value of g always updated to the value returned by "random", which means that each time you call "random" you'll get a different result.  However, as a newbie I'm a bit unclear on the specifics
17:43:35 <mnoonan_> it’s fine, you just make the list of randoms part of your state and provide some function “getRandom :: MyState -> (Pos, MyState)”
17:47:19 <amca_> let lottery x = take 6 $ randomRs (1,40) $ mkStdGen x
17:47:34 <Peter123> I am getting a very strange exception: "./Data/Vector/Generic/Mutable.hs:513 (slice): invalid slice (3500,5250,7000)"
17:47:44 <Peter123> https://hackage.haskell.org/package/vector-0.12.0.1/docs/src/Data.Vector.Generic.Mutable.html#slice
17:48:13 <Peter123> How is that possible? I am making a slice from 3500 to 5250 element of a vector that has 7000 elements?
17:48:46 <jle`> hard to know without seeing code
17:50:04 <Peter123> What does "slice i n v" mean? I know "v" is the vector...
17:52:18 <wedify> Peter123: could n be how long the slice is?
17:52:33 <mniip> sounds likely
17:52:37 <mniip> otherwise it'd be i j
17:52:43 <Peter123> Okay, thanks!!!
17:52:56 <Peter123> i is the index!!!
17:53:20 <Peter123> 3500 + 5250  is greater than 7000 which is the length of the vector!
17:53:23 <Peter123> thus the error!
17:53:23 <codeshot> iqubic, if it's the lottery problem then maybe you want this: traverse (randomR . ((,) 1)) [10,9..1] g
17:53:25 <mniip> not saying you should derive meaning from such variable names, this is a case of poor documentation
17:53:29 <iqubic> codeshot: I'm actually going to be using a different list every time. I'll want to pass the list in and just pick a single value from that list.
17:53:49 <iqubic> I want to randomly pick a single value from a given list.
17:53:50 <Peter123> I will write a issue report.
17:53:57 <centril> do you guys prefer in general to write code using  MonadState s m => ...  or using a specific type like  State Env MyType ?
17:54:14 <centril> (also applies to MonadReader, etc...)
17:54:15 <codeshot> if each list is the same length then mnoonan_'s answer is cool
17:54:28 <jle`> centril: it depends on the context
17:54:31 <Peter123> centril: It could make a performance difference.... When in doubt, benchmark the most specific type
17:54:51 <codeshot> otherwise you need to use my answer from a moment ago for the lottery problem, and replace [10,9..1] with a list containing the length of each list
17:54:52 <centril> Peter123: wrt. monomorphization?
17:55:08 <iqubic> codeshot: The lists are not going to be the same length.
17:55:23 <centril> jle`: everything always depends on context usually
17:55:29 <centril> that is somewhat a nonanswer :P
17:55:42 <mniip> centril, sometimes when a monad is compound I'd like to use some primitives that use only part of the effects to implement the next layer
17:55:55 <codeshot> let ls = [[1,2,3],[4,5],[6,7,8,9]] in traverse (randomR . ((,) 1)) (map length ls) g
17:55:57 <Peter123> centril: I don't know that. But there is a best pratice guide on reddit and github. It says to always check to see if more concrete types improves performance.l
17:55:59 <mniip> and those primitives I might wish to reuse at the outer level too
17:56:08 <mniip> so mtl's classes are the way to go
17:56:08 <iqubic> I only want a single element from a list.
17:56:08 <centril> mniip: and then lift?
17:56:09 <codeshot> iqubic, see that let ls = ...
17:56:09 <Peter123> I am working on stuff where performance matters (sorting vectors)
17:56:21 <jle`> centril: i use MonadState s m => ... for any application-level stuff, but when i'm doing things like quick one-offs i use State
17:56:28 <mniip> centril, no, let the typeclasses do the thing
17:56:37 <codeshot> iqubic, it takes a list of lists (ls) and gets a list of random indexes suited to each list
17:56:37 <centril> mniip: aight
17:56:40 <jle`> also i rarely ever use MonadReader myself
17:56:50 <codeshot> pseudorandom, of course
17:56:58 <codeshot> g <- newStdGen
17:57:06 <mniip> I mean I recently had an interesting case
17:57:11 <mniip> I basically had an RWS
17:57:16 <iqubic> RandomGen -> [a] -> (RandomGen, a) where RandomGen is the generator.
17:57:29 <jle`> RandomGen is a typeclass
17:57:32 <centril> jle`: Hmm well, you can mostly merge the reader bit into the state bit
17:57:48 <mniip> where all the boring primitives were implemented using the writer
17:57:57 <jle`> centril: i usually pass in arguments manually
17:57:59 <iqubic> jle`: Yeah, I'm still learning how the Haskell randomness works.
17:58:01 <mniip> and then I plopped on some functionality via the reader, using the writer primitives
17:58:11 <jle`> iqubic: so maybe StdGen -> [a] -> (StdGen, a)
17:58:12 <centril> jle`: but lens... :P
17:58:15 <mniip> and then I plopped on some more via State, making use of the previous ones
17:58:21 <jle`> or RandomGen g => g -> [a] -> (g, a)
17:58:59 <iqubic> Yes that jle`.
17:59:07 * hackage ats-format 0.1.0.22 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.22 (vmchale)
17:59:08 <iqubic> How would I write that function?
17:59:28 <jle`> lists might not be the best data structure for that, but you can pick a random Int from 0, len-1
17:59:34 <centril> mniip: what's the word on using WriterT these days? "don't use a monoid where append is expensive"? so dlist instead of [] ?
17:59:37 * hackage gnss-converters 0.3.28 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.3.28 (markfine)
18:00:13 <codeshot> iqubic, what's wrong with let ls = [[1,2,3],[4,5],[6,7,8,9]] in traverse (randomR . ((,) 1)) (map length ls) g
18:00:23 <codeshot> after getting g with g <- newStdGen
18:00:24 <mniip> centril, I had an ENdo
18:01:03 <codeshot> This gives a list of three random numbers, in the range 1->3, 1->2, and 1->4 - to match each of the lists
18:01:15 <mniip> most operations added a thing via Endo's mappend, one did a censor
18:01:31 <mniip> it seemed very natural
18:01:37 * hackage constraint 0.1.0.1 - Reified constraints  https://hackage.haskell.org/package/constraint-0.1.0.1 (MatthewFarkasDyck)
18:01:40 <jle`> centril: the problem isn't mappend, it's the associativity of the mappending from the built in WriterT
18:01:45 <mniip> given it was a "scope" type operation
18:03:02 <centril> mniip: DList is essentially  Endo [a] , right?
18:03:09 <mniip> yes
18:03:12 <iqubic`> Sorry, my computer randomly rebooted.
18:03:19 <mniip> but with less visibility
18:03:24 <codeshot> iqubic`, let ls = [[1,2,3],[4,5],[6,7,8,9]] in traverse (randomR . ((,) 1)) (map length ls) g
18:03:28 <codeshot> after getting g with g <- newStdGen
18:03:31 <centril> mniip: visibility wrt.?
18:03:42 <mniip> internally it is isomorphic to Endo
18:03:43 <iqubic`> will the thing work if ls is [char]
18:03:53 <codeshot> [ [Char] ]
18:04:06 <codeshot> you said you have many lists
18:04:10 <mniip> but the unexported constructor divides the type by extensional equality that you can observe via the exported primitives
18:04:25 <codeshot> so you put all the lists into a list: let ls = ["hello", "goodbye"]
18:04:35 <iqubic`> codeshot: I have many lists, but I'm only going to have one list at a time.
18:04:36 <mniip> depending on how you ask it is isomorphic to [a], or Endo [a]
18:04:40 <mniip> but the two are not iso to each other
18:04:47 <codeshot> iqubic`, haskell doesn't work that way
18:05:07 <codeshot> the expression I gave should work for your situation
18:05:22 <centril> mniip: right, that makes sense, thanks
18:05:25 <codeshot> it delays the calculation like a coroutine or thread
18:05:29 <iqubic`> I can't write a function of type "StdGen -> [a] -> (StdGen, a)"
18:05:39 <jle`> `DList a` is the subspace of `Endo [a]` that represent appendy functions
18:05:47 <jle`> right-appendy
18:05:52 <mniip> prependy
18:06:05 <jle`> i took a 50/50 shot
18:06:31 <centril> jle`: idk if that formulation makes me any wiser - I'm not familiar with that particular jargon
18:06:33 <mniip> 50ml what
18:06:46 <jle`> centril: Endo ([1,2,3]++) is a part of DList Int
18:06:53 <jle`> centril: but not Endo reverse
18:07:06 <centril> ah
18:07:07 * hackage constraint 0.1.1.1 - Reified constraints  https://hackage.haskell.org/package/constraint-0.1.1.1 (MatthewFarkasDyck)
18:07:09 <jle`> so there are members of `Endo [a]` that don't correspond to anything in DList a
18:08:43 <codeshot> iqubic, g <- newStdGen; ls <- traverse (readIO :: String) [1..100]; let idxs = traverse (randomR . ((,) 1)) (map length ls) g; for_ idx print
18:08:52 <codeshot> you have one list at a time
18:08:57 <codeshot> just like that
18:09:10 <codeshot> I think :/
18:09:49 <codeshot> oops, messed up
18:12:57 <iqubic> what's the right way to store a collection of Ints?
18:13:27 <jle`> it depends on what you want to do with your ints
18:13:41 <jle`> and what sort of access you want
18:13:43 <iqubic> I need to be able to add and remove elements from the collection, as well as read from it.
18:13:57 <jle`> read from it how?
18:14:01 <centril> iqubic: is it a sequence or a set?
18:14:14 <iqubic> It can be a set.
18:14:19 <jle`> if you don't care about duplicates or ordering, you can use a Set
18:14:45 <iqubic> I'll be using a random generator to pick on of the Ints in this set.
18:14:52 <iqubic> That's my intention.
18:14:54 <centril> perhaps: http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-IntSet.html
18:15:54 <centril> iqubic: ^
18:16:22 <jle`> Set/IntSet isn't too bad for that, since you can get probably just pick an element at a random index
18:16:36 <iqubic> yeah, I was planning on doing that.
18:16:37 <jle`> but you might care about duplicates
18:17:29 <iqubic> I don't actually need duplicates.
18:17:38 <iqubic> It really can be a set.
18:18:02 <iqubic> Now, does Dante, for emacs, need Internet access?
18:18:39 <jaseemabid> I found this small Idirs example of constraining the allowed operations to only some constructors of a type. As in a safe partial function. Is there a Haskell way to do the same? http://lpaste.net/361517
18:19:28 <aplainzetakind> I have m :: Map String Int, I also have xs :: [String], I want to sort xs on the lookup values from the Map, which I can, but that's not quite good enough. Can I sort xs on the first value of a key k in m such that (isPrefixOf x k) (without writing it from scratch)?
18:19:34 <jaseemabid> tldr; how do you do very simple dependent pattern matching in Haskell. Do we have the machinery in place? Are there any extensions that can handle this?
18:20:19 <iqubic> jaseemabid: What does the data keyword do there?
18:20:27 <jle`> dependent pattern matching is in Haskell
18:20:58 <jle`> i think the only necessary extension is GADT
18:21:01 <jle`> *GADTs
18:21:04 <MarcelineVQ> that's not dependant anyway luckily, that's doable with GADTSyntax and DataKinds iirc
18:21:17 <jaseemabid> iqubic, The data keyword is very similar to the one in Haskell. Defines a type.
18:21:59 <iqubic> yeah I got that.
18:22:02 <jle`> jaseemabid: what you gave is already possible in Haskell even without GADTs
18:22:14 <jle`> except Car :: Natural -> Vehicle Petrol
18:22:30 <jle`> actually i think that definition might require GADTs, instead of just GADTSyntax
18:23:02 <jle`> jaseemabid: oh, i don't think haskell allows you to split a dependent pattern match over multiple definitions like that
18:23:08 <jle`> you might need to use a case statement of some kind
18:23:14 <jle`> I could be wrong
18:23:34 <jaseemabid> I understand that you can define a similar type with GADT. But can you say that the function is defined only for some branches?
18:23:36 <jle`> i am probably wrong
18:23:45 <jle`> jaseemabid: for refeul?
18:24:02 <jle`> yeah if you gave refeul a branch for Bike, it'd be a compile-time error
18:24:15 <jle`> reful k Bike = ... would be a compile-time error
18:24:21 <jaseemabid> For example, in this type signature? `refuel :: Int -> Vehicle Petrol -> Vehicle Petrol`, can we use a concrete type like 'Petrol' at all in Haskell instead of a type variable a?
18:24:26 <jle`> yes
18:24:37 <jle`> you could always do this, though
18:24:53 <jle`> [Int] -> [Int] instead of [a] -> [a], etc.
18:25:25 <jaseemabid> Ah! I'll be quite happy if I could do this. Trying out the example. brb
18:25:29 <centril> what's the progress on DependentHaskell btw?
18:26:21 <jle`> jaseemabid: you'll need a somewhat modern-ish ghc, but i think we've been able to do what you have there for several years now
18:26:41 <jle`> from at least since when i started learning haskell i believe
18:28:00 <iqubic> does Dante need internet to run?
18:28:10 <jle`> who is dante
18:28:25 <jle`> oh, emacs plugin
18:29:17 <jaseemabid> jle`, I can use any version of GHC. Not a concern at all
18:29:26 <iqubic> yeah emacs plugin for haskell development. It's an Intero replacement. Someone in here suggested it to me the other day.
18:30:44 <MarcelineVQ> jle`, jaseemabid: http://lpaste.net/361517
18:31:28 <jle`> make sure to turn on -Wall and marvel at the "totality checker" ;)
18:32:02 <iqubic> MarcelineVQ: Why did you need DataKinds and KindSignatures?
18:32:11 <iqubic> Also, how is that dependent?
18:32:15 <jle`> (that is, the fact that there's no incomplete pattern match warning for refeul
18:33:33 <iqubic> why is there no compilation error for the haskell thing?
18:33:36 <MarcelineVQ> refuel isn't incomplete though, it only accepts Vehicle Petrol and it covers the two constructors that can create Vehicle Petrol
18:33:58 <jle`> yeah, i'm saying that there should be no warning
18:34:03 <MarcelineVQ> Oh alrighty
18:34:07 <jle`> to prove that the GADT/pattern match works :)
18:34:17 <iqubic> oh I see.
18:34:45 <MarcelineVQ> iqubic: it's not dependant, KingSignatures is so you can tell Vehicle what Kind it can accept, and DataKinds is to promote Power to a Kind, and Petrol and Pedal to types
18:35:05 <jaseemabid> Finally I think I understood DataKinds. So if you have a type like `data Power = Petrol | Pedal`, you can use only `data Vehicle a where Bike :: Vehicle Power` under normal circumstances and go all the way to `data Vehicle a where Bike :: Vehicle **Petrol**` with DataKinds.
18:35:11 <jaseemabid> Am I right here?
18:36:03 <jle`> technically right, but i wouldn't really compare the two things you mentioned
18:36:15 <jle`> data Power = Petrol | Pedal makes a new kind (Power) with two new types, Petrol and Pedal
18:36:55 <jle`> it's not really directly dependent types though because the values Petrol and Pedal are unrelated to the types 'Petrol and 'Pedal
18:36:57 <jaseemabid> @MarcelineVQ, Thank you. I finally (somewhat? :)) understand data kinds and kind signatures in a very unexpected move
18:36:57 <lambdabot> Unknown command, try @list
18:37:12 <jaseemabid> MarcelineVQ, Thank you. I finally (somewhat? :)) understand data kinds and kind signatures in a very unexpected move
18:37:14 <jle`> it makes the type/value constructors, and also the unrelated kind and kind constructors
18:37:32 <MarcelineVQ> jaseemabid: in fact I didn't really grasp this until trying idris
18:37:59 <jaseemabid> Ha ha. Idris, the perfect way to learn dependent Haskell? :)
18:38:31 <jle`> idris is the perfect way to become sad about dependent haskell :)
18:39:51 <jaseemabid> True that. I started with idris because most of llvm-hs library is partial. I even managed to segfault ghc a bunch of times. If Steven Diehl could not make a nice type safe API around it, it must be a hard problem in Haskell.
18:40:27 <jaseemabid> *Stephen Diehl
18:43:14 <iqubic> I don't see why dependant haskell would be useful.
18:44:10 <glguy> It'll help to have written some programs
18:44:29 <iqubic> i have written a large part of my program.
18:44:44 <glguy> Cool, you're on your way!
18:45:00 <jaseemabid> jle`, True that. To be honest now the Kind vs Type thing feels a bit odd.
18:45:28 <jle`> jaseemabid: yes it's a big awkward
18:45:37 <jle`> the singletons library tries to solve it using a 'kindclass'
18:45:49 <jle`> and an associated type
18:46:00 <iqubic> Kinds confuse me.
18:46:21 <jaseemabid> iqubic, (I might be really wrong here) when you work with the LLVM API, almost all the operations you do are almost untyped. Its like programming with all the types Object or something. It wont look like the Haskell you kinda love.
18:47:43 <iqubic> How does that relate to kinds?
18:48:13 <jaseemabid> For example if you have a huge AST type with 100s of operations on it while all of them are partial, you lose confidence in "if it compiles it works" thing. You will end up with too many 'AST -> AST' transformation functions. I was wondering how much of those can be made more precise with better types.
18:49:01 * jaseemabid might be really wrong here, thinking aloud. 
19:02:07 * hackage dib 0.7.2 - A simple, forward build system.  https://hackage.haskell.org/package/dib-0.7.2 (blajzer)
19:02:19 <mnoonan_> jaseemabid: do you know about https://github.com/llvm-hs/llvm-hs-typed ?
19:03:04 <mnoonan_> (I haven’t tried it yet, but it seems like it could be a step in the right direction)
19:06:22 <jaseemabid>  mnoonan_ Yes. Its a new project and it was not ready when I was working with llvm-hs. I hope to closely watch it.
19:07:42 <jaseemabid> mnoonan_, That code is pretty complex though. It uses all the type machinery extensions. Will take a while to understand all of it.
19:07:53 * mnoonan_ nods
19:13:37 * hackage resourcet 1.1.11 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.1.11 (MichaelSnoyman)
19:27:37 * hackage ats-format 0.1.0.23 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.23 (vmchale)
19:52:12 <sqooq> je suid de retour
19:53:15 <dmwit> % 3
19:53:15 <yahb> dmwit: 3
19:53:20 <dmwit> % last (repeat 0)
19:53:25 <yahb> dmwit: [Timed out]
19:53:32 <dmwit> % 3
19:53:33 <yahb> dmwit: 3
19:53:37 * hackage incremental-parser 0.2.5.3 - Generic parser library capable of providing partial results from partial input.  https://hackage.haskell.org/package/incremental-parser-0.2.5.3 (MarioBlazevic)
19:57:40 <sqooq> dmwit, how do memoFix
19:57:49 <sqooq> I don't even understand it, it's not like fix
19:57:55 <dmwit> mniip: I continue to be impressed. ^C, kill -{HUP,TERM,STOP,TSTP} don't recover from that in my local ghci session. The fact that yahb can recover cleanly from that is amazing to me.
19:58:13 <sqooq> what is the extra argument, why does the function also take an extra argument?
19:58:25 <dmwit> There is no extra argument.
19:58:54 <vaibhavsagar> what is yahb?
19:58:59 <dmwit> `fix` takes a function and returns the fixpoint of that function. `memoFix` takes a function and returns the fixpoint of that function.
19:59:01 <mniip> dmwit, ah it's a tight loop that doesn't call into GC
19:59:06 <dmwit> vaibhavsagar: yet another haskell bot
19:59:14 <vaibhavsagar> cool cool
19:59:20 <vaibhavsagar> % :t 5
19:59:20 <yahb> vaibhavsagar: Num p => p
19:59:25 <vaibhavsagar> nice
19:59:33 <mniip> well [Timed out] is a little less merciful
19:59:35 <sqooq> dmwit, fix :: (a -> a) -> a
19:59:45 <sqooq> memoFix :: ((a -> b) -> a -> b) -> a -> b
19:59:59 <vaibhavsagar> % :t \f -> let x = f x in x
20:00:00 <yahb> vaibhavsagar: (t -> t) -> t
20:00:02 <dmwit> sqooq:
20:00:06 <glguy> :t fix `asTypeOf` memoFix
20:00:08 <lambdabot> Integral a => ((a -> p) -> a -> p) -> a -> p
20:00:10 <dmwit> :t fix @(B -> C)
20:00:12 <lambdabot> error:
20:00:12 <lambdabot>     Pattern syntax in expression context: fix@(B -> C)
20:00:12 <lambdabot>     Did you mean to enable TypeApplications?
20:00:16 <dmwit> ?let data B
20:00:18 <lambdabot>  Defined.
20:00:21 <dmwit> ?let data C
20:00:23 <lambdabot>  Defined.
20:00:30 <dmwit> ?let {-# LANGUAGE TypeApplications #-}
20:00:32 <lambdabot>  Defined.
20:00:38 <dmwit> :t fix @(B -> C)
20:00:38 <mniip> that last one doesn't do anything
20:00:40 <lambdabot> error:
20:00:40 <lambdabot>     Pattern syntax in expression context: fix@(B -> C)
20:00:40 <lambdabot>     Did you mean to enable TypeApplications?
20:00:44 <dmwit> mniip: oh lol
20:00:50 <glguy> dmwit: You can't turn language extensions on in the middle of a file
20:00:53 <dmwit> mniip: Ah, so [Timed out] kills and restarts the session?
20:00:57 <mniip> kind of
20:01:03 <mniip> the supervisor quits
20:01:09 <dmwit> glguy: I sort of figured ?let watched for LANGUAGE pragmas and floated them.
20:01:13 <mniip> which kills the sandboxed processes with SI_KERNEL SIGKILLs
20:01:38 <amca1> q
20:02:15 <mniip> glguy, yeah right! you can turn extensions on in the middle of a ghci session though!
20:02:30 <dmwit> mniip: Okay. So `last (repeat 0)` is the yahb equivalent of ?undefine. ;-)
20:02:35 <mniip> :q
20:02:40 <mniip> is a simpler one
20:03:05 <dmwit> sqooq: Anyway, just replace `a` in the type of `fix` with `b -> c` everywhere and see what you get. ;-)
20:03:20 <sqooq> but but but
20:03:21 <sqooq> why
20:03:40 <sqooq> and it means my thing doesn't type check anymore
20:03:49 <sqooq> because it's expecting functions instead of variables
20:03:54 <glguy> yahb: 
20:04:06 <glguy> % 
20:04:06 <yahb> glguy: ; <interactive>:2:1: error: lexical error at character '\EOT'
20:04:07 <PlasmaStar> Naughty
20:04:08 <mniip> there is not a terminal driver inbetween
20:04:20 <sqooq>  :thinking:
20:04:37 <glguy> Just trying to think o a shorter sequence than :q :)
20:04:38 <dmwit> sqooq: Yes, you need to unwrap your newtype, then memoFix, then rewrap. As we said yesterday...
20:04:53 <mniip> I wanted to add a command to forcibly kill a session
20:05:00 <mniip> because there's definitely ways to make yahb unusable
20:05:57 <sqooq> agh I don't really know what that means relevant to this problem
20:06:17 <dmwit> % :def q Prelude.return Prelude.. (":!echo " Prelude.++)
20:06:17 <yahb> dmwit:
20:06:24 <dmwit> % :q
20:06:24 <yahb> dmwit:
20:06:25 <sqooq> the fix function is summ x = fix (\w -> x +: del dt w )
20:06:34 <sqooq> x and w are both Signals which when unwrapped are functions
20:06:40 <sqooq> del returns Signal as well
20:07:04 <dmwit> What is the definition of Signal?
20:07:05 <sqooq> so how do I keep them as functions for memoFix, but also apply them to a value in order to add them together?
20:07:16 <sqooq> newtype Signal t b = Signal (t -> b)
20:07:24 <dmwit> ?let newtype Signal t b = Signal (t -> b)
20:07:26 <lambdabot>  Defined.
20:07:44 <sqooq> grab (Signal f) = f
20:08:10 <mniip> % :undef q
20:08:11 <yahb> mniip: <interactive>: ^^ Could not load 'wakeup', dependency unresolved. See top entry above.; ByteCodeLink: can't find label; During interactive linking, GHCi couldn't find the following symbol:; wakeup; This may be due to you not asking GHCi to load extra object files,; archives or DLLs needed by your current session. Restart GHCi, specifying; the missing library using the -L/path/to/object/dir and -lmi
20:08:16 <mniip> dangit
20:08:27 <mniip> this kills the crab
20:09:13 <dmwit> :t \f -> Signal (fix (coerce f)) :: (Signal a b -> Signal a b) -> Signal a b
20:09:14 <lambdabot> error:
20:09:15 <lambdabot>     • Couldn't match expected type ‘(Signal a1 b1 -> Signal a1 b1)
20:09:15 <lambdabot>                                     -> Signal a1 b1’
20:09:58 <mniip> anyway, there's this function
20:10:00 <mniip> % :t GHCi.Run.primWakeup
20:10:00 <yahb> mniip: IO ()
20:10:40 <mniip> you call it and things go awry because the supervisor is confused about when to pause the process for more input (from IRC)
20:10:56 <dmwit> :t \f g -> case f (Signal g) of Signal h -> h
20:10:59 <lambdabot> (Signal t1 b1 -> Signal t2 b2) -> (t1 -> b1) -> t2 -> b2
20:11:36 <dmwit> :t \f -> Signal (fix (\g -> case f (Signal g) of Signal h -> h))
20:11:38 <lambdabot> (Signal t b -> Signal t b) -> Signal t b
20:11:50 <dmwit> :t \f -> Signal (?memoFix (\g -> case f (Signal g) of Signal h -> h))
20:11:52 <lambdabot> (?memoFix::((t1 -> b1) -> t2 -> b2) -> t3 -> b3) => (Signal t1 b1 -> Signal t2 b2) -> Signal t3 b3
20:11:59 <dmwit> sqooq: There you go.
20:12:23 <sqooq> :whomst:
20:12:45 <glguy> dmwit: Since those are all newtypes, you could also use Data.Coerce to smash it together
20:13:03 <dmwit> glguy: Yes, but it required more type annotation than I cared to work my way through.
20:13:08 * glguy wonders if that makes a difference in the resulting generated code though
20:13:15 <sqooq> dmwit, what is this, what is going on here
20:13:16 <dmwit> And like, probably ScopedTypeVariables, which apparently I can't turn on.
20:13:20 <sqooq> is this the generic function?
20:13:25 <sqooq> to unwrap and memoize3
20:13:26 <glguy> dmwit: Sure, that's the right solution to present, I'm just pondering
20:13:36 <dmwit> sqooq: Yes, this is signalFix.
20:13:44 <sqooq> :expanded:
20:14:05 <sqooq> so my summ function memoized will be `that (summ x)`?
20:14:33 <dmwit> sqooq: You would give this a name (let's say `signalFix`). Then you would use it in place of `fix`.
20:14:50 <MarcelineVQ> sqooq: womst'd've't
20:15:48 <dmwit> glguy: I think the generated code would be slightly different. Eta expanded, mainly.
20:16:14 <dmwit> glguy: I mean, the manual-wrapping-and-unwrapping version would have an eta-expanded `f` compared to the coerce version.
20:16:23 <glguy> agreed
20:17:33 <sqooq> dmwit, it says it needs a Hasktrie instance but there's no instance for Double???
20:17:36 <mniip> hmm
20:18:11 <glguy> Not as bad as I had imagined: example :: forall a b. HasTrie a => (Signal a b -> Signal a b) -> Signal a b; example = coerce (memoFix @a @b)
20:18:34 <dmwit> Nice!
20:19:16 <sqooq> neat
20:19:32 <sqooq> how does HaskTrie have an instance for like every number type but not Double?
20:19:50 <sqooq> jk it just has it for int
20:19:55 <dmwit> 1. HasTrie 2. Haskell doesn't really have great support for accessing individual bits of Double.
20:20:08 <sqooq> well shoot, now what
20:20:22 <glguy> :t decodeFloat
20:20:24 <lambdabot> RealFloat a => a -> (Integer, Int)
20:20:33 <dmwit> AFAIK other languages that offer this sort of cheat there anyway. There's no real guarantee about what order a processor actually stores IEEE754 bits in.
20:21:00 <dmwit> (The spec explicitly differentiates between the "logical order" -- which is carefully specified -- and the "physical order" -- which is left up to the implementation entirely.)
20:21:02 <EvanR> i thought... that was one of the points of that standard
20:21:36 <glguy> (Integer, Int) has an instance of HasTrie, so whatever the hell problem we're solving, that's one route :)
20:22:05 <glguy> that or not using Double for the function argument
20:24:21 <sqooq> but but
20:24:25 <sqooq> I'm dealing with signals
20:24:41 <sqooq> o I guess I can just go full discrete
20:24:45 <sqooq> but conal would be angery
20:26:01 <dmwit> I do not understand why "but" is the right connector to go in front of "I'm dealing with signals".
20:26:05 <dmwit> What is the conflict?
20:26:19 <sqooq> Wait does the result of the function have to be an integer to?
20:26:23 <sqooq> the function of the Signal
20:26:25 <sqooq> that is
20:26:37 <glguy> Do you know how to tell?
20:27:07 <sqooq> Sorr
20:27:10 <sqooq> turns out
20:27:20 <sqooq> I did Signal a a, in my "+:" definition
20:27:26 <sqooq> So it's not letting the types be different
20:27:29 <sqooq> easy fix
20:28:38 <sqooq> glguy, and yes I clearly see memoSig :: HasTrie t => Signal t b . . .
20:30:21 <sqooq> man I don't want time to be an int. Now I have to strap my signal definitions into a certain discretization, and use "fromIntegral" everywhere.
20:30:53 <EvanR> time to pull out constructive analysis
20:31:02 <EvanR> to get a proper abstraction for "time domain"
20:31:24 <sqooq> nah
20:31:50 <EvanR> the notion of function needs to be expanded into monotone function between directed complete partial orders
20:32:01 <sqooq> :whomsted:
20:32:36 <dmwit> ?let instance Profunctor Signal where dimap f g (Signal h) = Signal (dimap f g h)
20:32:38 <lambdabot>  Defined.
20:32:40 <EvanR> time isnt a set of points its a family of intervals a < b
20:33:01 <sqooq> :ascended:
20:33:02 <EvanR> for some value of <
20:33:32 <dmwit> ?let signalFix f = Signal (fix (\g -> case f (Signal g) of Signal h -> h))
20:33:34 <EvanR> similarly for the domain
20:33:35 <lambdabot>  Defined.
20:33:42 <sqooq> wait but time can bend in spacetime, so we need to get some tensor products in there
20:34:04 <EvanR> wat no
20:34:12 <dmwit> :t lmap encodeFloat . fix . (rmap decodeFloat .)
20:34:14 <lambdabot> (RealFloat a2, RealFloat a1, Profunctor p) => (p (Int -> a1) (Integer, Int) -> p (Int -> a1) a2) -> p Integer (Integer, Int)
20:34:22 <dmwit> ouch, no
20:35:32 <mniip> it has been done
20:37:08 <MarcelineVQ> EvanR: where does that idea lead?
20:37:58 <dmwit> :t \f -> lmap decodeFloat (signalFix (lmap (uncurry encodeFloat) . f . lmap decodeFloat))
20:38:00 <lambdabot> (RealFloat a2, RealFloat b, RealFloat a1) => (Signal a2 c -> Signal b c) -> Signal a1 c
20:38:05 <dmwit> sqooq: ^^
20:39:00 <sqooq> how do you do this magic
20:39:15 <dmwit> Blame glguy, he suggested it.
20:39:48 <glguy> dmwit: There's a chance to use some lens and an iso between encodeFloat and decodeFloat there
20:39:55 <sqooq> is this memoized though?
20:39:55 <glguy> Let's use more stuff!
20:40:43 <sqooq> also where do i get lmap rmap
20:40:54 <sqooq> nvm let me try hoogle
20:41:19 <sqooq> nope that didn't help
20:42:37 <dmwit> It is memoized if signalFix is, since it uses signalFix.
20:42:51 <dmwit> lmap/rmap are from Profunctor, which I assume would be in a package named profunctors or similar.
20:43:08 <dmwit> confirmed
20:43:37 <dmwit> Hoogle does have lmap for me. Though I typically use hoogle.haskell.org which has a newer database than haskell.org/hoogle.
20:44:13 <mniip> due to unpopular demand
20:44:16 <sqooq> dmwit, ok it's saying I need a proFunctor instance for signal, sound right?
20:44:23 <mniip> %kill
20:44:23 <yahb> mniip: Done
20:44:36 <EvanR> %kill
20:44:36 <yahb> EvanR: Done
20:44:48 <MarcelineVQ> %live
20:44:58 <sqooq> or rather "Could not deduce (Profunctor Signal) arising from a use of ‘lmap’"
20:44:58 <MarcelineVQ> breathe
20:45:06 <dmwit> sqooq: Yes. I defined an example one above you can rip off if you like, or you could try using `coerce` again.
20:45:09 <mniip> which reminds me
20:45:14 <mniip> does anyone want to write an IRC bot
20:46:25 <sqooq> ok wow
20:46:26 <sqooq> it works
20:46:52 <sqooq> dmwit, let me stop you right there. I'm taking a break for like a week, I'm taking a detour. I want to become a god. How do I become a god. Is it the category theory knowledge?
20:47:17 <mniip> how to learn haskell in under 5 years
20:47:19 <dmwit> Nah. You just do programs for eight hours a day for ten years.
20:47:39 <mniip> hmm I wonder if the 5 years elapsed for me yet
20:48:10 <glguy> dmwit: Is there a way to pack those days into about a month?
20:48:35 <dmwit> =D
20:49:09 <EvanR> compress 24 hours into 12
20:49:18 <EvanR> profit
20:49:19 <glguy> Maybe MP3 could help
20:49:24 <dmwit> sqooq: The Profunctor thing wasn't even really needed. You can do the whole stupid thing with just function composition. I just found it more readable to write it that way.
20:49:47 <mniip> hmm
20:49:51 <dmwit> ...not that it came out particularly readable.
20:49:59 <mniip> I started early may 2013, or maybe late april
20:50:05 <mniip> so close to 5 years yeah
20:50:38 <glguy> Sorry mniip, there's no demi-god status at 5 years, the whole thing kicks in at 10!
20:50:55 <mniip> that's where you're wrong kiddo
20:51:18 <sqooq> I'll get to demi-god status in a couple months
20:51:23 <sqooq> if you lead me in the right direction
20:51:29 <dmwit> Supposedly 10,000 hours is enough, which you should be able to do in just shy of a year if you work hard consistently.
20:51:38 <mniip> I don't believe I've ever been led in the wrong direction
20:51:39 <sqooq> I already consider myself a mathematician
20:51:48 <sqooq> I just never explored category theory deeply
20:51:54 <sqooq> only the basic definitions and concepts
20:51:55 <mniip> still took as many years as it did
20:52:02 <mniip> and I wouldn't really say it's over, yet
20:52:09 <dmwit> same same
20:52:16 <sqooq> it's never over
20:52:18 <dmwit> Some day I'll understand the Yoneda lemma.
20:52:34 <dmwit> Supposedly it's really simple. And I've even proved it. But understand it... yikes, not yet.
20:52:36 <mniip> maybe give a couple more years or however much it takes me to start publishing some papers
20:52:41 <mniip> then maybe I could start to claim something
20:53:32 <MarcelineVQ> meanwhile 800 silent watchers wonder "if these guys don't get it, what hope is there for me"
20:54:14 <glguy> dmwit: It comes out like: over _Encoding (memoFix (under _Encoding . f . over _Encoding)); _Encoding = iso decodeFloat (uncurry encodeFloat)
20:54:25 <dmwit> MarcelineVQ: The secret is you don't have to get it to be effective.
20:54:28 <mniip> MarcelineVQ, with subjects like these you can never learn "all" of it
20:54:36 <mniip> especially when haskell flows seamlessly into math
20:54:56 <sqooq> So
20:55:00 <sqooq> Cateogry theory guys?
20:55:01 <dmwit> glguy: Honestly that doesn't really seem that much better.
20:55:24 <mniip> sqooq, are you familiar with groupoids/virtual groups?
20:55:26 <glguy> I think it's probably worse than writing it out, better than lmap
20:55:32 <sqooq> mniip, nope
20:55:40 <mniip> you called yourself a mathematician up there :(
20:55:49 <sqooq> so
20:55:55 <sqooq> there are specializations in math
20:56:02 <sqooq> I do set theory mainly
20:56:17 <sqooq> I'm not a mathematician though, I don't often prove things.
20:56:28 <sqooq> I just learn what's already been proven.
20:56:28 <mniip> how good are you at abstract algebra?
20:56:47 <sqooq> mniip, I've never studied group theory ever
20:56:53 <mniip> linear algebra?
20:57:00 <sqooq> decent
20:57:02 <mniip> topology?
20:57:06 <sqooq> decent
20:57:18 <dmwit> What's your favorite cobordism?
20:57:21 <sqooq> I've forgotten a lot of both tbh
20:57:27 <sqooq> but I took a course in topology if it means anything
20:57:27 <mniip> you need 2 of 3 or so to get a moderate understanding of CT
20:57:31 <dmwit> (I feel like these questions are getting a bit absurd, is what I'm getting at.)
20:57:52 <mniip> dmwit, no like, CT is pointless to explain if you don't know at least 4 direct products
20:58:47 <sqooq> mniip, what do you mean by "direct products"
20:58:57 <sqooq> these subjects are well analyzed with CT?
20:59:13 <mniip> cartesian product of sets,
20:59:23 <mniip> direct product of groups, monoids, rings, fields,
20:59:27 <mniip> product topology,
20:59:35 <mniip> direct sum (!) of vector spaces
20:59:39 <sqooq> o
20:59:43 <mniip> CT unifies all of those with a single definition
20:59:49 <mniip> a product object in a category
20:59:49 <sqooq> neat
21:00:25 <sqooq> alright well
21:00:35 <sqooq> i'll be gone for like a week
21:00:41 <mniip> also daily reminder that you don't need to know CT to do haskell well
21:00:45 <sqooq> learning abstract algebra
21:00:55 <sqooq> mniip, but to be a god?
21:01:09 <sqooq> Does the haskell God know CT?
21:01:17 <mniip> you bet he does
21:01:19 <sqooq> Ok
21:01:22 <sqooq> then I will learn it
21:01:56 <sqooq> and come back, doesn't really matter when I do it. I've always been one that when I understand shit at the core, or work things out rigorously (whatever that means), then I can begin to do application.
21:02:02 <mniip> many of the haskell Apostles discourage learning CT though
21:02:13 <sqooq> well i like math so
21:02:20 <sqooq> I think it's a good idea
21:02:34 <sqooq> I haven't been studying math outside Analysis in a while tbh
21:02:38 <sqooq> I need to get back into it
21:02:42 <MP2E> can't speak for them at all, but I think the idea is to push learning materials towards the more concrete, in the interest of making it easier to get going with useful programs
21:02:51 <MP2E> I think there's value in the very abstract and the concrete
21:02:53 <MP2E> learn both \o/
21:03:05 <mniip> MP2E, yeah but many people are like sqooq here
21:03:08 <sqooq> MP2E, yeah, I've been doing concrete stuff for a while and keep finding myself needing to abstract
21:03:10 <sqooq> like with memoFix
21:03:13 <mniip> "I can't do anything, it must be the category theory"
21:03:13 <sqooq> or fix...
21:03:20 <mniip> uhh
21:03:25 <mniip> memoFix has nothing to do with CT
21:03:27 <mniip> like, zilch
21:03:28 <sqooq> it doesn't
21:03:32 <sqooq> but it's abstract
21:03:36 <sqooq> from the concrete recursion
21:03:55 <sqooq> that's my only point with that analogy. And in fact I was working with recursion schemes a while ago, and that IS CT.
21:03:55 <mniip> fixpoints are studied in uhh
21:04:03 <mniip> I have no idea actually, but it's not CT
21:04:33 <mniip> actually CT does study some fixpoints
21:04:40 <mniip> but not of this kind
21:05:07 <mniip> Mu/Nu
21:09:27 <MarcelineVQ> topology ye?
21:11:25 <sqooq> hah it's so weird having this actually work
21:11:27 <sqooq> you know how long
21:11:31 <sqooq> I've been trying to do this...
21:11:41 <sqooq> it was a fun journey though
21:11:43 <woodson_> can anyone help me understand this constraint on a function (Num (a -> b), Num a) ??
21:11:50 <woodson_> what exactly does it mean
21:12:10 <woodson_> I am playing around with applicative and I am a bit confused with the <*>
21:12:17 <dmwit> It means you have used a number as if it were a function somewhere.
21:12:27 <dmwit> :t 3 ()
21:12:30 <lambdabot> Num (() -> t) => t
21:13:08 <woodson_> what is the purpose of it?
21:13:35 <dmwit> Number literals are polymorphic so that you can define your own number types above and beyond the built-in ones.
21:14:56 <kadoban> Without that or something similar, you'd end up having to convert every numeric literal to some specific type most of the time. It'd be really noisy.
21:15:21 <woodson_> well to be a bit more specific I was looking at a tutorial about reflex
21:15:26 <woodson_> and here is an example (styleMap <$> value dfsRed <*> value dfsGreen <*> value dfsBlue)
21:15:46 <woodson_> and the definition of styleMap
21:15:47 <woodson_> styleMap :: T.Text -> T.Text -> T.Text -> Map T.Text T.Text
21:16:06 <woodson_> i understand <$> and <*>
21:16:23 <woodson_> but I dont get whats happening with the chainings of the <*>
21:16:31 <woodson_> thats where I am confused
21:16:46 <woodson_> So I tried to replicate it with a List
21:17:13 <woodson_> like so (+1) <$> [1, 2] <*> id [3, 4]
21:17:26 <woodson_> but its giving me an error which I am not understanding
21:18:03 <dmwit> :t (+1) <$> [1, 2] <*> id [3, 4]
21:18:05 <lambdabot> (Num (a -> b), Num a) => [b]
21:18:11 <dmwit> :t (+) <$> [1, 2] <*> id [3, 4]
21:18:14 <lambdabot> Num b => [b]
21:18:35 <woodson_> try to execute in ghci
21:18:39 <woodson_> :t (+1) <$> [1, 2] <*> id [3, 4]
21:18:42 <lambdabot> (Num (a -> b), Num a) => [b]
21:18:48 <geekosaur> yes. the type there shows you why
21:18:48 <dmwit> woodson_: (+1) takes one argument. For it to take two, the result of (+1) x would have to be a function, meaning 1 would have to be a function.
21:18:55 <geekosaur> "Num (a -> b)"
21:19:00 <geekosaur> you need a number which si a function
21:19:07 <dmwit> > (+) <$> [1, 2] <*> id [3, 4]
21:19:11 <lambdabot>  [4,5,5,6]
21:20:51 <woodson_> so the <*> is actually chaining them?
21:20:58 <woodson_> [1, 2] <*> id [3, 4]
21:21:16 <woodson_> and the <$> applicative will require a function that needs two parameters
21:21:22 <dmwit> `[1, 2] <*> id [3, 4]` is not a subexpression of `(+) <$> [1, 2] <*> id [3, 4]`.
21:21:38 <dmwit> The parentheses go the other way.
21:21:51 <dmwit> `((+) <$> [1, 2]) <*> id [3, 4]`
21:22:47 <geekosaur> :t (+) <$> [1,2]
21:22:49 <lambdabot> Num a => [a -> a]
21:23:14 <geekosaur> :t ?f <*> id [3,4]
21:23:16 <lambdabot> (Num a, ?f::[a -> b]) => [b]
21:26:15 <woodson_> so an array containing a function
21:29:06 <geekosaur> list of functions
21:29:21 <geekosaur> don't fall into the habit of thinking of that as an array
21:29:23 <woodson_> i meant ya a list of function
21:30:56 <woodson_> oooh
21:31:27 <woodson_> dmwit: Thanks ya the brackets are going the other way ((+) <$> [1, 2])
21:31:38 <woodson_> I dont know why I didnt pick it up
21:31:52 <woodson_> so it applies the (+) to each values in the list
21:32:36 <woodson_> which turns it to [(+1), (+2)]
21:33:24 <Axman6> yep
21:33:25 <woodson_> and the last part is pretty much fmap
21:33:31 <woodson_> ok ok
21:33:34 <Axman6> well, it's ap, aka, <*>
21:34:18 <Axman6> where <*> has type [a -> b] -> [a] -> [b], and the result is the combination of applying all functions in the argument to all values in the second argument
21:35:28 <woodson_> Axman6 yes!
21:35:32 <woodson_> Thanks guys
21:35:44 <woodson_> its crazy I picking this up just now...
21:35:56 <woodson_> I'm**
21:36:17 <woodson_> I've been fooling with haskell for a few months now
21:36:28 <woodson_> and I'm getting this now lol
21:36:38 <woodson_> I dont wanna know whats still ahead lol
21:37:12 <vaibhavsagar> woodson_: it's a rabbit hole
21:37:35 <Axman6> it doesn't end, there's no end to learning when you're using Haskell. that may sund daunting but it's actually a really good thing - it's a sign that the language is powerful enough to continue abstracting on other abstractions
21:37:45 <Axman6> sound*
21:39:37 <woodson_> Axman6: One thing I find that I haven't grasp completely is how to use abstraction
21:39:37 * hackage pandoc-citeproc 0.13 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.13 (JohnMacFarlane)
21:39:46 <woodson_> or when to use abstraction..
21:41:01 <vaibhavsagar> woodson_: I find it's easier to write the simple less-abstract version first and then refactor
21:41:43 <vaibhavsagar> the danger is when you over-abstract and other people (including future you) have no idea what is going on
21:41:51 <vaibhavsagar> see: point-free style
21:42:46 <Axman6> it's not something you try to do, it's just what programming is - and in many cases it's just recognising the same patterns happening again and again, and then finding there is a name for that pattern and using that instead. Applicative is just one pattern for a really common idea; I have a function of type (a -> ... -> c -> x) and a bunh of things of type f a, f b ... f c and you want to apply that function to all those things, and get back
21:42:46 <Axman6> and an f c
21:43:14 <woodson_> vaibhavsagar: point-free style? will have a look at it!
21:43:50 <boj> that's the spirit. learn all the things, write code you will scratch your head at in a year :)
21:44:14 <vaibhavsagar> @pl \f x y -> f x (y x)
21:44:14 <lambdabot> (`ap` flip id) . ((.) .)
21:45:04 <vaibhavsagar> @pl \f g x -> f x (g x)
21:45:04 <lambdabot> ap
21:45:30 <vaibhavsagar> how good is the Reader applicative :)
21:45:36 <dibblego> S
21:45:44 <Axman6> it's S good
21:46:21 <vaibhavsagar> <*> and const, the ultimate functions
21:47:00 <vaibhavsagar> ?let id' = const <*> const
21:47:02 <lambdabot>  Defined.
21:47:07 * hackage fast-arithmetic 0.2.2.0 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.2.2.0 (vmchale)
21:47:08 <vaibhavsagar> > id' 5
21:47:11 <lambdabot>  5
21:47:16 <vaibhavsagar> :D
21:48:38 <woodson_> lol
21:49:08 <vaibhavsagar> woodson_: this is the SK calculus, which is Turing-complete
21:52:20 <woodson_> vaibhavsagar: looked it up
21:52:55 <woodson_> got the SKI combinator calculus
21:53:59 <Xal> the I is a convenience but isn't necessary
21:54:27 <vaibhavsagar> I = S K K
21:54:46 <vaibhavsagar> or in Haskell, `const <*> const`
21:55:09 <woodson_> wouldn't I be id
21:55:13 <vaibhavsagar> yes
21:55:22 <woodson_> Ix = x
21:55:43 <vaibhavsagar> but the point is that you can define id in terms of `const` and `(<*>)`
21:57:05 <woodson_> yea
21:58:04 <Axman6> :t const <*> const
21:58:05 <lambdabot> b -> b
21:58:32 <woodson_> so K would be const
21:59:07 * hackage fast-arithmetic 0.2.2.1 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.2.2.1 (vmchale)
21:59:13 <dmj`> :t const <*> id
21:59:15 <lambdabot> b -> b
21:59:16 <Axman6> yes k is const
21:59:39 <woodson_> what would S be?
21:59:51 <Axman6> ap, aka <*>, for the function applicative
22:02:46 <woodson_> Axman6: just out of curiosity <*> accepts two args
22:03:00 <woodson_> The definition states: "S is a substitution operator. It takes three arguments and then returns the first argument applied to the third, which is then applied to the result of the second argument applied to the third"
22:03:55 <vaibhavsagar> woodson_: all lambdas in the lambda calculus take one argument
22:03:56 <Xal> woodson_: yes, but you're applying it to another function
22:04:03 <Axman6> @src (<*>) ((->) a)
22:04:03 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
22:04:40 <vaibhavsagar> wow lambdabot, that's a lot of sass for an IRC bot
22:04:54 <geekosaur> @src (->) (<*>)
22:04:54 <lambdabot> (<*>) f g x = f x (g x)
22:05:16 <woodson_> ah!
22:05:18 <geekosaur> dons liked sudo's insults mmode
22:05:31 <Axman6> thanks geekosaur, it's been so long sinc I've needed to do that - I feel this sort of lambdabot knowledge is being lost to the ages
22:05:42 <Axman6> since*
22:08:31 <vaibhavsagar> @src (->) pure
22:08:31 <lambdabot> pure = const
22:09:01 <vaibhavsagar> how cool is that
22:10:54 <woodson_> wat is the mean of (->)
22:11:02 <woodson_> what* meaning**
22:12:02 <kadoban> (->) is the type constructor for functions. You usually see it as  :: a -> b     but you can also write it the other way (and in some circumstances you have to)
22:12:26 <geekosaur> like any infix, you can make it behave prefix by wrapping it in parens
22:13:22 <jle`> > 4 + 9
22:13:27 <lambdabot>  13
22:13:27 <jle`> > (+) 4 9
22:13:32 <lambdabot>  13
22:14:04 <kadoban> :t (\x -> x) :: (->) Int Int
22:14:06 <lambdabot> Int -> Int
22:14:18 <Xal> it makes me mad that H98 doesn't support infix type constructors
22:14:36 <Xal> stupid -> getting to be special
22:16:54 <woodson_> i see
22:17:35 <Xal> luckily there is the TypeOperators extension
22:18:25 * geekosaur was going to ask why you cared, then noticed that didn't change in 2010 :(
22:18:37 <kadoban> :t Right "hi" :: Int `Either` String
22:18:40 <lambdabot> Either Int String
22:18:49 <kadoban> I didn't actually know you could do that ^
22:19:13 <geekosaur> otoh there's enough people annoyed (like, on cafe) about arbitrary infix operators...
22:19:57 <woodson_> so then (->) (<*>) where is the return type?1
22:19:58 <geekosaur> pretty sure I've seen that one in use by various type level packages
22:20:05 <woodson_> oh wait i missed it
22:20:06 <woodson_> a
22:20:24 <Xal> woodson_: when you apply a type constructor to an argument you get another type, so there's no "return type"
22:21:07 <Xal> that's λ2 for ya
22:21:22 <kadoban> woodson_: That part is a little bit of just special lambdabot syntax essentially. It's just asking for the type of (<*>) in the instance for (->)
22:21:34 <kadoban> Or the source for it or whatever
22:26:19 <woodson_> gotcha
22:31:37 * hackage fast-arithmetic 0.2.2.2 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.2.2.2 (vmchale)
22:34:24 <tutti> hiya, just came across the language ETA (http://eta-lang.org/), asserting to be Java-compatible  and compilable for JVM. anyone knows if it's stable, if it fits its own description, etc?
22:37:43 <woodson_> hey guys can you guys explain something for me. I'm getting curious more and more now
22:38:01 <woodson_> how does instance Monad ((->) r) where   f >>= k = \ r -> k (f r) r
22:38:20 <woodson_> translate to instance  Monad Maybe  where  (Just x) >>= k      = k x
22:38:27 <woodson_> just look at the source code
22:38:38 <vaibhavsagar> woodson_: they are different
22:38:47 <liste> woodson_: what do you mean by "translate to" ?
22:38:48 <woodson_> you previously said (->) r gets the type
22:39:09 <vaibhavsagar> woodson_: different types have different Monad instances
22:39:40 <vaibhavsagar> there's not necessarily a relationship between them
22:40:03 <woodson_> so int the instance Monad Maybe
22:40:11 <woodson_> does (->) r == Maybe?
22:40:15 <vaibhavsagar> no
22:40:18 <woodson_> or r == Maybe?
22:40:21 <vaibhavsagar> no
22:40:24 <woodson_> ?
22:40:29 <liste> woodson_: m == Maybe
22:40:48 <woodson_> i dont see any m
22:41:01 <woodson_> instance Monad ((->) r) where   f >>= k = \ r -> k (f r) r
22:41:06 <liste> woodson_: it's in the class declaration: "class Monad m where...."
22:41:28 <liste> woodson_: the (->) and Maybe instances for Monad are unrelated
22:43:48 <woodson_> liste: ok I see it
22:43:50 <woodson_> class Applicative m => Monad m where
22:43:59 <woodson_> (>>=)       :: forall a b. m a -> (a -> m b) -> m b
22:47:07 * hackage fast-arithmetic 0.2.2.3 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.2.2.3 (vmchale)
22:49:14 <woodson_> Thanks for the clarification guys. I feel like I understand better now.
