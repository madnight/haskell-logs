00:39:26 <jle`> haskell doesn't really have a lot of maths
00:42:35 <glguy> How many does it have?
00:42:41 <cocreature> 5
00:42:53 <glguy> That's pretty many
00:43:00 <cocreature> it’s less than 6!
00:43:23 <glguy> Six seems like a more manageable number
00:52:59 <loli> 6 is 0 mod 6
00:53:06 <loli> and 5 is 5 mod 6
00:53:09 <loli> therefore 5 > 6
00:53:20 <loli> so 5 is quite scary
00:56:15 <cocreature> at least 5 is prime, non-primes are frightening. you don’t look at them for a minute and suddenly they fall apart into factors
00:56:16 <jle`> gotta love that Z_6 ordering
01:02:43 <epicallan> Hi, I have a "No instance for (IsString Char) " error while using the overloadedStrings extension. Would be appreciate any help on how to go about it. thanks  http://lpaste.net/362019
01:03:55 <cocreature> epicallan: you can’t use OverloadedStrings for chars, the instance is for String, i.e., a list of Chars
01:03:58 <Zemyla> epicallan: Char isn't an instance of IsString.
01:04:02 <Zemyla> [Char] is.
01:10:49 <epicallan> Thanks Zemyla.
01:23:06 <typetetris> does somebody can help me with ale and brittany?
01:24:11 <typetetris> I have ale and brittany installed, do I have to configure something in my vim to for it to work? How can I check wether it works?
01:50:35 <Adluc> Hello guys, does any of you use package.yaml in your project and have multiple executables? I am fighting with module naming and file naming in /app.
01:51:21 <jle`> i do
01:51:28 <Adluc> currently i am stuck in loop when it needs executable module to be named Main, but with more than one such module it needs it to be named like the file
01:51:51 <Adluc> jle`: do you have such project available on github or some other place where I could peek into?
01:52:16 <jle`> i wouldn't put your executables in modules
01:52:40 <jle`> you don't need a "module Foo where ..." for an executable
01:52:49 <jle`> all you need is main = ...
01:52:56 <cocreature> well it’s always in a module, it just defaults to Main
01:53:25 <jle`> i suppose i should say then that you don't really need an explicit module declaration for your executables
01:53:35 <Adluc> okay, will try
01:53:43 <jle`> Adluc: but, i did have an issue with package.yaml that i didn't have with cabal
01:54:06 <jle`> it automatically detected files beginning with a capital letter in my app/ folder and treated them as modules
01:54:10 <jle`> instead of as executables
01:54:15 <jle`> (treated them as library modules)
01:54:29 <jle`> and so if there wasn't an explicit module declaration, there'd be a compilation error
01:55:04 <jle`> i didn't want to treat those files as if they were library modules.  i made their names lower-case and hpack stopped auto-detecting them as library modules
01:57:49 <Adluc> jle`: oh yea :) had to name the files lower case, now its not treating them as libraries I suppose
01:57:51 <Adluc> thanks
01:58:51 <jle`> no problem :)  and yeah, i might not be 100% correct on my diagnosis, but i think if the files are uppercased, it treats them as importable modules in some sense, because if you look in the generated .cabal file, those files get listed as modules
01:59:38 <MarcelineVQ> suspicious
01:59:55 <jle`> if you're in doubt about what's going on, just look at the generated .cabal file :)
02:00:23 <jle`> yeah the auto-detection of files in hpack was one of the weirder things when i started using it unintentionally
02:00:54 <Adluc> yeah, went through cabal, but it did not raise suspicion this early in the morning, when it treated app files as library
02:02:02 <Adluc> jle`: also started using it unintentionally and quite like it so far
02:02:20 <MarcelineVQ> possibly related https://github.com/sol/hpack/issues/188
02:03:09 <MarcelineVQ> says merged in sept. though, wonder if it was only fixed for test stanza
02:04:03 <MarcelineVQ> anyway try  other-modules:   []  for your executbale and see if it does anything
02:09:19 <Adluc> MarcelineVQ: will try also that
02:10:25 <Adluc> /Users/adam/projects/pcb-tools/app/DrillMerge.hs:1:1: error:
02:10:26 <Adluc>     File name does not match module name:
02:10:26 <Adluc>     Saw: ‘Main’
02:10:26 <Adluc>     Expected: ‘DrillMerge’
02:10:42 <Adluc> with uppercase app file, with lowercase it works same as without the other-modules: []
02:12:50 <merijn> Adluc: What's your cabal file look like?
02:14:04 <Adluc> merijn: https://github.com/lucansky/pcb-tools/blob/master/pcb-tools.cabal
02:15:54 <MarcelineVQ> merijn probably means the one giving the error, if that's not the one
02:17:51 <merijn> hmmm
02:18:02 <merijn> What if you properly capitalise the files in your cabal file?
02:18:26 <merijn> Which you probably should anyway, because as written I would assume this 100% fails to build on anything that has a case-sensitive filesystem
02:20:27 <Adluc> merijn: http://lpaste.net/3920979475352780800
02:20:59 <Adluc> this is cabal with which it fails, drillmerge is uppercase, it says the error mentioned earlier
02:22:13 <Adluc> but I dont understand why executable drawgerber has DrillMerge in other-modules
02:22:52 <merijn> Ah!
02:23:01 <Adluc> setting other-moduels: [] on all executable fixes the problem, now it works also with uppercase
02:23:11 <merijn> 1) you're right, DrillMerge shouldn't be in other modules for drawgerber
02:23:19 <merijn> 2) that's the error
02:23:41 <merijn> Modules without a "module Foo where" line are treated by GHC as having "module Main(main) where"
02:24:17 <merijn> So it's trying to compile DrillMerger.hs for drawgerber and then fails, because DrillMerge.hs (which should be module DrillMerge) has module name "Main", hence the error
02:29:30 <Adluc> yeah, that makes sense. in my case it makes sense to have other-modules: [], thanks for clarifying
02:29:50 <Adluc> but its kind of trap for beginners :D
03:27:15 <merijn> Well, there's hasn't been an endless bikeshedding thread on libraries@, lemme go and fix that ;)
03:32:30 <int-e> merijn: well, you'll break  instance Foo ByteString  (which would then need TypeSynonymInstances)
03:32:38 <merijn> int-e: Ah...rats
03:33:31 <merijn> int-e: To be fair, I did qualify it as a crazy plan ;)
03:52:37 <merijn> hmmm, is there some simple globbing library?
03:54:03 <[exa]> merijn: including the directory listing or without it?
03:54:14 <merijn> Not for files, for Strings/Text
03:55:16 <cocreature> is there a way to use "dante" but still get a repl in emacs instead of using the reploid that it provides?
03:56:03 <[exa]> merijn: well, afraid not. Maybe you can succeed in tearing something out of https://hackage.haskell.org/package/MissingH-1.4.0.1/docs/src/System-Path-Glob.html#glob
03:57:04 <merijn> [exa]: Naah, easier to hard code something then for me
03:57:29 <[exa]> merijn: this is from students http://lpaste.net/362023
03:57:42 <merijn> Relatedly, efficient ways to grab the last N elements of a list? Or do I just suck it up and do "drop (length l - 2) l"?
03:59:39 <MarcelineVQ> convert it to a snoclist and use take :D
03:59:39 <[exa]> merijn: simultaneously dropping heads of (list) and (drop n list) until the second list is [] can save you from possibly large integers
03:59:42 <merijn> eh, screw it, I'll just do that
04:00:03 <merijn> Values should be small, so I'll suck it up anf fix it later :p
04:00:16 <[exa]> yeah, prototype before polishing
04:05:00 <loginoob> Ok, I have a very beginner question. It is very trivial question to you all but important to me, I think. I want to learn functional paradigm and after some searching I have decided that i should learn both Common Lisp and haskell.
04:05:26 <loginoob> But which language should i learn first is not clear to me
04:06:35 <[exa]> loginoob: running through scheme/lisp is somewhat easier for beginning, this is a pretty good material btw: https://ds26gte.github.io/tyscheme/
04:07:33 <[exa]> but you certainly don't need to get in depth, chapters <=6 are pretty good to get the functional feel
04:08:00 <loginoob> [exa]: I have almost read The little schemer book so I will not be going in details of Scheme and want to focus on Common LISp
04:08:36 <[exa]> scheme/lisp are just another dialects of the same thing
04:08:36 <loginoob> almost completed I mean
04:09:07 <loginoob> yes sir I know that. But there must be some difference in learning
04:09:56 <[exa]> learning clisp if you know scheme already is only about using different names for several things, and some differences in variable scope etc.
04:10:13 <[exa]> no problem to "learn as you go"
04:10:28 <loginoob> [exa]: So learn Lisp first then haskell?
04:10:46 <[exa]> fastforward to haskell
04:10:55 <loginoob> maybe not in great detail but familiarty to LIsp
04:11:15 <loginoob> ok
04:11:51 <loginoob> thank you for your time :)
04:12:25 <[exa]> honestly "familiarity with common lisp" sometimes sounds like "familiarity with perl" :]
04:13:43 <[exa]> loginoob: btw this is a good reading about how clisp is not quite different http://community.schemewiki.org/?scheme-vs-common-lisp
04:37:31 <pie__> are there any papers/stuff on the security of the haskell RTS?
04:37:44 <merijn> pie__: What sorta security?
04:37:59 <ph88> when do linear types land in ghc ?
04:42:35 <merijn> whoo! nothing like a segfault when writing haskell!
04:44:01 <pie__> merijn, ;_;
04:44:13 <pie__> merijn, well...the take over execution kind
04:44:17 <alp> ph88, there isn't a precise timeline yet. but the people behind that line of work have a docker image with their patched GHC, if you want to play around with it. or you could just build their branch of GHC too of course.
04:45:24 <pie__> merijn, its nice to say haskell has good langsec but that still depends on if you can find a way to hijack the rts etc
04:45:40 <pie__> (no?)
04:45:50 <merijn> pie__: I don't understand what you mean?
04:46:12 <merijn> pie__: If an attacker can control your process your fucked in any language
04:48:03 <pie__> i think you're missing the point? theoretically just because haskell the language prevents you from doing a lot of bad things doesnt mean the runtime that it runs on doesnt have bugs that could let you do bad things
04:48:43 <merijn> pie__: Haskell the language doesn't prevent shit
04:49:29 <merijn> If I wanna write a program that fiddles with arbitrary memory inside my Haskell process, nothing stops me whatsoever
04:49:31 <pie__> its like saying java doesnt let you break things with pointers but then you go do something that lets you do bad things(tm) with the JVM
04:49:55 <pie__> merijn, ...the point is to stop OTHER people from making your process do things you fdont want
04:50:22 <alp> how about when the flaw comes from the microprocessor?
04:50:38 <merijn> pie__: I think you're having/making some unstated assumptions
04:53:24 <pie__> merijn, you arent really helping to find them because i dont know what you mean
04:53:42 <pie__> alp, yeah im just gonna...keep crying in a corner about that
04:54:40 <pie__> but as long as you arent letting someone run (sandboxed) arbitrary code, maybe the probability of an explit like that approaches astronomical negligibiity ;_;
04:57:14 <loginoob> In the paper why fp matter I understand the sum (Cons n list)=n+sum list . But I am not able to understand the foldr implementation
04:57:40 <loginoob> sum = foldr (+) 0
04:59:09 <loginoob> foldr f x Nil = x and (foldr f x) (Cons a l) = = f a ((foldr f x) l)
04:59:49 <loginoob> We are not giving list to get the sum in Sum function. Only the f and 0
05:00:34 <Boomerang> loginoob: This definition of sum has been eta reduced, an equivalent way of writing is could be: sum xs = foldr (+) 0 xs
05:01:09 <Boomerang> s/is/it/
05:01:47 <alp> pie__, well, I've been working in this industry for a couple of years only, but I've already seen enough to make me think that of course neither Haskell (the language) nor its implementations are anywhere near enough for making software 100% safe. and most of the time people tend to focus on very specific attack vectors against their systems instead of just supposing there's a flaw in the RTS or what have you.
05:01:58 <merijn> argh
05:02:52 <loginoob> Boomerang: Because there is only one argument to sum,we can not write it? is this what has heppened?
05:03:13 <loginoob> we can omit* it
05:04:55 <Boomerang> loginoob: Not exactly, like in mathematics when you have an equation for example: x + 2 = y + y, you can reduce it to simply being x = y. Similarily in Haskell if you have a function: f a b c = g b a c, you can reduce it to f a b = g b a
05:05:09 <Boomerang> s/y + y/y + 2/
05:05:18 <ph88> anyone know who is behind monday morning haskell ?
05:05:24 <Boomerang> (I really should proof read before sending :/ )
05:07:38 <loginoob> sorry but how is x+2=y+y is reduced to x=y?
05:07:42 <cocreature> ph88: james bowen according to my google search :)
05:08:22 <ph88> thx
05:08:32 <Boomerang> I meant "x + 2 = y + 2", sorry for the typo :/
05:08:40 <loginoob> oh ok
05:09:21 <loginoob> i was thinkng i am so bad in maths that i cannot understand linear equation
05:10:42 <ski> Boomerang : technically, that's called "function extensionality" .. but it's related to eta-reduction, so ..
05:11:02 <hdla> why is vinyl's Storable-based accessor faster? all it does is first peek the entire value, and then read one field from the record. how can this be faster than reading one field from the record straight away? https://github.com/VinylRecords/Vinyl/blob/master/benchmarks/AccessorsBench.hs
05:11:10 <Boomerang> loginoob: So you can omit one (or several arguments) to your functions on their left hand side if these arguments are to be applied to the right hand side
05:11:11 <pie__> alp, sure but it would still be nice to get an idea of the state of things and where improvements can be made
05:11:31 <pie__> possible mitigations
05:11:51 <ski> loginoob : the idea is that if you make a function that when called with an argument, `x', calls `f' with `x' (and returns the result), then that function *behaves* the same as `f' (for all inputs), and so we could just as well say that the new function *is* (equal to) `f'
05:12:47 <pie__> halvm looks interesting
05:13:24 <alp> pie__, well, knowing about vulnerabilities would be a good start :) one of the few relevant links I could find https://www.reddit.com/r/haskell/comments/4x1lqi/ghc_from_a_software_security_perspective/
05:13:28 <ski> loginoob : in the example `sum xs = foldr (+) 0 xs', the new function is `sum', which when called with `xs', just "delegates" to calling `foldr (+) 0' with `xs'. hence `sum' and `foldr (+) 0' behaves the same, and are considered equal, and we can henceforth "abbreviate/cancel" the definition as just `sum = foldr (+) 0'
05:14:49 <Boomerang> Instead of thinking of it in terms of removing arguments, it's probably easier to think of function definitions as just an alias for what is on the right hand side. So "addFold = foldr (+)" defines a function "addFold" that still takes 2 arguments to be fully applied.
05:14:51 <loginoob> oh ok
05:15:06 <ski> (btw, notw that `foldr (+) 0 xs' is the same as `(foldr (+) 0) xs' is the same as `((foldr (+)) 0) xs'. function application brackets to the left. so if we're "matching" the expression `foldr (+) 0 xs' to our template `f x', then `f' corresponds to `foldr (+) 0' and `x' to `xs')
05:15:23 <pie__> alp, yeah i alreads skimmed over that thread :/
05:16:02 <pie__> somewhat related, found this by googling for galois stuff https://galois.com/blog/2010/06/tech-talk-towards-a-high-assurance-runtime-system-certified-garbage-collection/
05:17:12 <ski> loginoob : another way to state the first definition is `sum = \xs -> foldr (+) 0 xs', where `\xs -> foldr (+) 0 xs' is a function literal, an anonynous function, a lambda expression. it is *the* function that, when called with an input, call it `xs', returns `foldr (+) 0 xs' .. so a similar argument as above tells us that we can abbreviate this lambda expression as simply `foldr (+) 0', this is known as eta-reduction
05:17:22 <ski> (so the definition again becomes `sum = foldr (+) 0')
05:18:15 <ski> loginoob : more abstractly, function extensionality tells us that if `f x = g x' (or `f x = (...) x', with `...' an expression that doesn't depend on `x'), for *all* inputs `x', then `f = g' (or `f = ...')
05:19:02 <ski> loginoob : and eta-conversion (reduction in one direction, expansion in the other), tells us that `\x -> f x' (or `\x -> (...) x', `...' not depending on `x') is equal to `f' (or to `...')
05:19:05 <alp> pie__, well aseipp and awick (halvm author) both posted there and are people with the relevant kind of experience to talk about these things, and I'm not. you're probably better off reading their posts and maybe getting in touch or posting on reddit/haskell-cafe, with more specific questions when you have them.
05:19:36 <[exa]> alp: you should adhere to the practical parametrized definition of safety, 'safe in environment E against an attacker with N dollars in pocket'. Empirical evidence shows that without fixing the two variables you'll never get any assurance or trust.
05:20:06 <loginoob> ok , got it, not everything that you wrote but the main point
05:20:34 <[exa]> alp: (it allows you to order the vulnerabilities and solve them in a sane order, saving much time in the process)
05:21:05 <pie__> alp, hm good idea/good point
05:21:54 <ski> loginoob : the details of how to formulate it aren't as important as having heard the terms, and knowing what it means in practice
05:21:56 <pie__> [exa], thats assuming you even see any vulnerabilities? but yeah thats true
05:22:40 <ski> loginoob : as hopefully made evident, it can both be used for refactoring code, and for (otherwise) reasoning about code
05:22:44 <alp> [exa], right, I'm assuming this is how security folks proceed. OTOH this is really not my strong suit so I tend to point to knowledgeable people instead of making up too much :)
05:23:15 <alp> making too many things up*
05:23:19 <[exa]> pie__: in fact 'inability to see vulnerabilities of some kind' fits this scheme very well. But haskell solves it quite nicely
05:23:56 <pie__> [exa], not sure what you mean
05:23:57 <loginoob> thank you for explaining things in details and making them clear for me
05:25:21 <[exa]> alp: my point was that security assurance isn't a very complicated process, given you have a clear image of E the environment
05:26:11 <[exa]> pie__: "assuming you even see any vulnerabilities" -- not seeing them implies that you either don't have methods to see any (which is the vulnerability) or you have some assurance there aren't any (which is fixed vulnerability)
05:26:34 <pie__> oh well yeah, right
05:28:28 <[exa]> and haskell gives assurance about a pretty wide class of vulns, except ofcourse the lowlevel ones
05:28:43 <[exa]> which are pricey to exploit TBH
05:29:15 <[exa]> unless you're certain CPU vendor *cough*
05:30:37 <Athas> Has the Haskell RTS been audited?
05:30:45 <mrkgnao> alp: might be a long shot, but do I know you from Twitter?
05:30:48 <Athas> Has all the common libraries that use unsafe operations?
05:31:16 <Athas> Haskell clearly derives a lot of safety from being a basically memory-safe language, but it probably derives almost as much by not being targeted by anyone.
05:31:48 <[exa]> Athas: "audited by whom" comes to mind :]
05:33:05 <Athas> Anyone with a decent reputation for security auditing would be fine.
05:33:58 <alp> mrkgnao, maybe? I'm 'alpmestan' there.
05:34:33 <[exa]> Athas: btw it's not an easy target even from lowlevel point of view; usual lowlevel exploits assume that the code is written in C and uses C-style idioms and lots of statically predictable data; haskell systematically removes such stuff from runtime
05:34:43 <[exa]> s/runtime/compiled programs
05:35:01 <mrkgnao> oh, no, sorry, was thinking of someone else (although I do know you from there). don't mind me :)
05:36:13 <alp> no worries =)
05:47:43 <merijn> Oh joy! Segfaults everywhere :\
05:48:26 <merijn> How can I get GHC to emit DWARF symbols?
05:48:59 <alp> merijn, https://ghc.haskell.org/trac/ghc/wiki/DWARF
06:06:22 <merijn> ok...so anyone got any pro tips on locating segfaults, because the DWARF symbols don't seem to point to the right place (I'd expect my FFI code to be failing, but I get issues somewhere randomly in Haskell land)
06:13:10 <[exa]> merijn: what does GDB say?
06:13:20 <[exa]> the backtrace should point to the part of RTS that's causing it
06:13:43 <julius__> good morning all, experimenting with mongodb, I'm looking for a way to loop through a Document (they're [Field]), convert their values to their haskell equivalent and finally store those fields on a key-value pair structure in haskell
06:13:50 <merijn> [exa]: Points to a line of Haskell code that isn't even running when the thing crashes
06:14:17 <julius__> any pointer welcome, thanks
06:14:49 <[exa]> julius__: what's the definition of Field?
06:15:43 <julius__> exa: https://hackage.haskell.org/package/bson-0.3.2.3/docs/Data-Bson.html#t:Field
06:15:52 <loginoob> So the paper Why FP matters made me doubt myself because i was not able to understand it fully i'm thinking will i be able to get haskell
06:17:22 <Tuplanolla> How often do you understand any paper fully?
06:17:47 <Tuplanolla> That's not a common occurrence.
06:17:54 <julius__> [exa]: https://hackage.haskell.org/package/bson-0.3.2.3/docs/Data-Bson.html#t:Field
06:19:10 <[exa]> julius__: and your key-value pair structure?
06:21:44 <julius__> [exa]: a dictionary would be perfect, I just want to be able to retrieve the value using a key
06:22:42 <merijn> ugh...my life is hell :(
06:22:42 <srpx> Other than Idris, what are languages capable of serving as proof assistants implemente with Haskell? Perhaps if I can find a clean, small & fast type checker for a core with dependent types and inductive families I can use it instead
06:22:45 <julius__> [exa]: but without having to do the lookup and check etc that is needed with this bson field
06:24:29 <merijn> Isn't Agda written in Haskell
06:24:34 <merijn> srpx: ^^
06:26:01 <srpx> Merijn do you know Agda’s codebase? Perhaps if it is modular I could strip the core away, make my own ascii syntax and use just the type checker?
06:26:47 <epicallan> how can i simplify this piece of code; possibly with contaminators. http://lpaste.net/362029 Thanks
06:28:08 <cocreature> is anyone aware of changes to name resolution in TH quotes since 7.10? I’m getting a build failure with 7.10 https://travis-ci.org/llvm-hs/llvm-hs/jobs/334352382#L4424 that I’m not getting with 8.2 and I don’t understand why there is a difference.
06:28:24 <srpx> (I've asked on #agda)
06:28:28 <lyxia> epicallan: it looks fine already. And they're called "combinators".
06:29:35 <[exa]> merijn: what are you programming anyway?
06:30:03 <[exa]> julius__: there's an easy mapping from bson objects to Maps and similar dictionaries
06:32:14 <epicallan> lyxia: I was finding the lines with show a bit repetitive. I was thinking maybe there is a better way. Thanks for feedback
06:33:11 <ski> epicallan : personally .. i'd avoid the `$'s, and maybe use `concat' instead of `++' .. though in your case, `intercalate' (also cf. `intersperse') would be nicer, it seems
06:34:05 <merijn> [exa]: I ported my C based decision algorithm to Haskell vectors so I could easily use it from my haskell code, but after working fine for tons of experiments I'm now running into segfaults for some inputs, but not others and I don't know if the problem is in: 1) my SQLite C extension, 2) the persistent sqlite bindings, 3) Storable vector manipulation or 4) somewhere else entirely :\
06:34:41 <ski> @type \xs -> intercalate "/" (map show xs)
06:34:44 <lambdabot> Show a => [a] -> [Char]
06:35:00 <Tuplanolla> Are you ready for a GDB adventure, merijn?
06:35:23 <merijn> Tuplanolla: I already used GDB, but the segfault isn't producing anything useful in the core dump
06:35:46 <merijn> Tuplanolla: The position the DWARF symbols say the crash is in, is very obviously not where it is
06:35:48 <[exa]> merijn: can you retrieve the code address where it failed?
06:36:00 <epicallan> : ski thanks, let me give that shot
06:36:02 <[exa]> merijn: btw I suggest you don't use haskell debug symbols first
06:36:12 <[exa]> just a debugging version of RTS
06:36:19 <[exa]> (or your libs)
06:36:19 <merijn> [exa]: I tried without DWARF, but that' wasn't very useful either
06:36:38 <Tuplanolla> Those situations are the best.
06:36:43 <merijn> Tuplanolla: Word
06:36:47 <ski> epicallan : `map' will only work if the types of `year',`month',`day' are the same, though
06:36:59 <merijn> "Lemme just quickly start my new experiments so I can enjoy the rest of my weekend without working"
06:37:07 <merijn> 6 hours later...still debugging
06:37:08 <epicallan> ski: yeah they are the same
06:37:14 <ski> ok
06:37:18 <Tuplanolla> In an ideal world stack traces should not be corruptible by the program itself.
06:37:30 <[exa]> Tuplanolla: good point
06:39:58 <epicallan> ski: they are actually not the same
06:40:28 <merijn> Tuplanolla: THe problem is that haskell has no useful notion of stack to trace if the segfault is happening inside the haskell code
06:40:47 <ski> epicallan : you could still use `intercalate', then
06:50:00 <merijn> Tuplanolla: hmmm, my 21k element vector is getting index with index... -343090754
06:50:06 <merijn> Tuplanolla: I'm...fairly confident that's not right...
06:51:24 <Tuplanolla> Not even slightly right.
06:54:23 <[exa]> Tuplanolla: aren't you playing with string buffers somewhere around?
06:54:52 <Tuplanolla> I'm not currently doing anything, [exa].
06:55:02 <jchia_> Is there a succint way to express "Monad m => m Bool -> m Bool -> m Bool" That does short-circuit 'and' on the values returned by the two input monads?
06:55:18 <jchia_> So if the first monad returns false, the second is skipped
06:56:37 <lyxia> that's more or less (<|>) for MaybeT m ()
06:56:45 <Tuplanolla> @hackage extra -- See `Control.Monad.Extra`, jchia_.
06:56:45 <lambdabot> http://hackage.haskell.org/package/extra -- See `Control.Monad.Extra`, jchia_.
06:58:23 <jchia_> lyxia: My 'm' is IO, though.
06:59:30 <jchia_> Tuplanolla: andM?
07:00:13 <jchia_> monad-loops also has it
07:00:44 <Tuplanolla> No. Read the whole thing.
07:01:45 <merijn> Tuplanolla: Whoo! I found out how I managed to fuck myself over :)
07:01:47 <jchia_> Tuplanolla: OK, (&&^)
07:03:10 <merijn> I was going from ByteString to Storable Vector, but the code I found for that assumes that if your vector doesn't start at the start of the BS it starts at a multiple of element size (which it didn't, unless I happen by lucky accident to padd with just the right amount)
07:03:29 <merijn> And of course, also by sheer accident all my testing was done with code that happened to have the right padding through sheer luck...
07:04:36 <merijn> That's what I get for rolling this by hand >.>
07:05:19 <jchia_> merijn: Were you trying to create a Storable Vector from data in a ByteString?
07:05:49 <jchia_> The copying code makes assumptions about alignment?
07:06:30 <merijn> jchia_: I wasn't copying
07:07:22 <merijn> I was just ripping the ForeignPtr out of the ByteString's guts and wrapping it with Vector, which works fine, except the code that taught me how to do so made a bunch of unstated assumptions
07:08:06 <[exa]> Tuplanolla: oh I meant merijn with that thing above. obviously he did. :D
07:09:50 <merijn> Basically, the example code looks at "oh, this bytestring is offset N bytes wrt to the ForeignPtr" and then computes how many elements of the vector that is and offsets by that amount
07:10:21 <merijn> Which only makes sense if you vector is offset by N vector elements. But vector really only needs to be offset by a multiple of alignment to make sense
07:12:46 <jchia_> merijn: I recently had to do some Storable Vector manipulation. I make a new Storable Vector by reading from a file directly into different parts of the Storable Vector, using unsafeToForeignPtr0
07:13:25 <jchia_> I was reading from a file into a ByteString previously, but later decided to skip the ByteString.
07:13:41 <jchia_> ...and read directly into the Storable Vector.
07:14:22 <merijn> jchia_: I'm getting the vector from a database, which only has a ByteString type for marshalling, but I don't wanna copy the entire vector everytime out of the BS
07:16:18 <jchia_> merijn: I see, you don't have the option to use something like hGetBuf.
07:16:33 <merijn> jchia_: Not without reimplementing the entire database wrapper
07:18:03 <merijn> Rats...need to update GHC for the easy solution...
07:19:06 <merijn> plusForeignPtr neatly solves my problem, but is only around since 4.10 >.>
07:22:24 <merijn> I forget, where is the constructor of Int exported?
07:22:31 <merijn> GHC.Exts?
07:26:54 <mniip> many places
07:26:58 <mniip> GHC.Int for example
07:27:09 <merijn> For the people think "Wow, all this safety makes Haskell WAAAAY to boring...": http://lpaste.net/362031
07:27:19 <merijn> s/people/people who/
07:27:53 <cocreature> merijn: related https://twitter.com/cocreature/status/708347812082278401
07:28:11 <merijn> cocreature: :)
07:29:33 <merijn> cocreature: I FFI import function pointers to function I wrote in C, forcefully stuff those into SQLite to build C arrays which are returned as BLOB. Haskell DB binding gets the BLOB as ByteString, I forcibly rip out it's guts and make it a Storable Vector and tada...
07:29:48 <merijn> cocreature: To be fair, it did reduce my query runtime from about 150s to about 5s
07:30:01 <merijn> Totally worth it!
07:30:03 <cocreature> gotta go fast
07:30:39 <mniip> merijn, have you ever
07:31:10 <mniip> ffi exported a haskell function only to ffi import it on the next line as a FunPtr in order to avoid the wrapper generation  performance penalty
07:31:25 <merijn> mniip: Not yet :p
07:31:55 <[exa]> mniip: ok that is brutal :]
07:32:40 <mniip> cf https://github.com/mniip/hexchat-haskell/blob/master/HexChat/Internal.hs#L129-L130
07:35:42 <dmwit> merijn: Uh... and what happens when you upgrade your linker (or, shoot, change some of your compiler flags) and it silently and correctly puts your C functions at a different spot in memory...?
07:35:52 <dmwit> You're gonna want your 145s back at that point, I'll bet.
07:36:08 <merijn> dmwit: What does the C function address have anything to with this?
07:36:21 <dmwit> "I FFI import function pointers"
07:36:48 <dmwit> Perhaps I misunderstood. But it *sounded* like you were storing C function addresses in SQLite.
07:36:49 <merijn> dmwit: What do you think functions are from the linker's point of view?
07:36:59 <merijn> dmwit: You misunderstood
07:37:21 <dmwit> Okay. =)
07:37:39 <merijn> dmwit: My haskell code is foreign importing C function and registering (at runtime) them with SQLite (which has an interface for injecting new SQL functions at runtime)
07:38:05 <dmwit> ahhh, this is not going to persist across processes
07:39:05 <merijn> dmwit: Basically, I'm injecting an "aggregate to vector" function which lets me using SQL aggregates to build a vector and return it as a blob
07:39:37 <merijn> dmwit: So instead of looping lots of times per row to build a vector with lots of copying and overhead you just build them in place in SQLite and copy them out in one go
08:07:49 <merijn> ah...it's "how the fuck this did ever work?!" o clock >.>
08:15:23 <mniip> "You may count yourself a member of a very small club if you understand the statement “monad is a monoid in the category of endofunctors” that is chock full of mathematical abstractions."
08:15:29 <mniip> what
08:20:49 <mniip> (I am not confused about the mathematical statement, but rather by the remark that the club is very small)
08:25:48 <AndreasK> mniip: Are you really?
08:26:52 <AndreasK> I mean very small is relative, but outside of mathematicians and functional programming enthusiasts I wouldn't know why anyone would be familiar
08:27:44 <mniip> hmm
08:28:12 <mniip> realistically how many people on earth understand that?
08:28:27 <merijn> mniip: Couple of thousands, probably?
08:28:51 <mniip> huh
08:28:57 <merijn> Maybe even 10s of thousands? If we're very generous?
08:29:08 <mniip> I had a ~100K figure in mind
08:29:21 <Tesseraction_j> to be honest you'll be in an even smaller club if you count the time it was used as a satire of functional programmers
08:29:26 <merijn> Yeah, thousands is probably low end?
08:29:42 <merijn> Tesseraction_j: Well, he said "understand"
08:30:10 <geekosaur> I can understand it and I'm no CT wonk. (But I know just enough to understand what it is saying and why)
08:30:22 <Tesseraction_j> http://james-iry.blogspot.co.uk/2009/05/brief-incomplete-and-mostly-wrong.html
08:30:34 <mniip> geekosaur, okay so that's at least three of us so far :P
08:30:40 <Tesseraction_j> many good burns in this one
08:38:03 <Jikstra[m]> Tesseraction_j (IRC):
08:38:04 <Jikstra[m]> > http://james-iry.blogspot.co.uk/2009/05/brief-incomplete-and-mostly-wrong.html
08:38:04 <Jikstra[m]> Programmable Hyperlinked Pasta (PHP) :D
08:38:07 <lambdabot>  error: Variable not in scope: httperror:
08:38:07 <lambdabot>      • Data constructor not in scope:
08:38:07 <lambdabot>          (://) :: t0 -> ([Bool] -> Bool) -> t
08:38:46 <merijn> hmmm
08:50:16 <robstr> I have a problem while working through the haskellbook, i have : y:: Maybe Integer and z :: Maybe Integer and one one function tupled :: Maybe (Integer, Integer) with tupled = (,) y z which I'm only allowed to add <*>, <$> or pure
08:51:24 <mniip> robstr, what have you tried
08:51:45 <robstr> If i change tupled = pure (,) <$> y z
08:52:27 <mniip> well that's wrong because that's applying "y" to "z"
08:52:31 <[exa]> robstr: what about this:
08:52:33 <mniip> whereas "y" isn't a function
08:52:37 <[exa]> > ((+) <$> pure 3 <*> pure 4) :: Maybe Int
08:52:41 <lambdabot>  Just 7
08:52:42 <mniip> [exa], let them derive the answer...
08:53:11 <merijn> [exa]: That was...not particularly helpful in terms of learning
08:54:58 <robstr> thank you, but I'm a bit confused
08:55:43 <mniip> I can come up with 2 or 3 ways to explain how to arrive at the answer but after watching chris allen's talk (how to learn haskell in 5 years) I
08:55:48 <mniip> 'm not really sure of anything
08:56:11 <robstr> (+) <$> pure 3 is equivalent to fmap (+) (pure 3) right ?
08:56:21 <merijn> robstr: Right
08:56:31 <mniip> yeah that's a law
08:56:37 <mniip> er
08:56:42 <robstr> how can i map over +
08:56:46 <mniip> that's syntactic sugar pretty much
08:57:08 <robstr> yea i wasn't sure right know, much new syntax / concepts
08:58:46 <ph88> singleton (Put 10) :: IntState ()      singleton Get :: IntState Int          what's this ?
08:59:35 <dmwit> robstr: I suspect that your `pure (,) <$> y z` attempt was foiled by two things: 1. an unimportant misunderstanding of syntax 2. an important misunderstanding about the thing you're trying to learn.
09:00:00 <dmwit> robstr: To fix the unimportant misunderstanding, just write `(pure (,) <$> y) z` to clear up for both you and the compiler what order of applications you wanted.
09:00:19 <dmwit> robstr: Then the compiler will be able to help guide you to what you misunderstood about Applicative.
09:04:40 <robstr> dmwit: thank you really much i try to understand this and play a bit in the repl
09:04:42 <lyxia> ph88: in what context
09:49:39 <ph88> lyxia, https://blog.jle.im/entry/interpreters-a-la-carte-duet.html "Our primitives can be constructed using singleton"
09:50:41 <woodson> does one need to have ghc installed on their machine when installing stack?
09:51:03 <woodson> stack just takes care of install ghc when starting a new project?
09:53:23 <parsnip> woodson: i think that's how i've been doing it? did you install stack with the script, or package manager?
09:54:37 <woodson> I used the script
09:55:12 <woodson> parsnip: I'm just pushing a small project on github, and it just hit me
09:55:40 <parsnip> "it"? "hit"? not sure what you mean.
09:55:40 <woodson> I never thought about it, but I dont think that you need to install ghc with stack
09:56:04 <parsnip> stackage snapshots provide ghc and libraries.
09:57:00 <woodson> parsnip: Oh, perfect. So as long they got stack installed, stack will take care of the rest. Thanks alot!
09:57:18 <parsnip> hope i got that right ;)
10:01:57 <mmaruseacph2> you did
10:05:38 <lyxia> ph88: well that's just how you convert the ADT representing commands into monadic values
10:06:28 <ph88> unused values ?  there is no  =  sign
10:07:11 <lyxia> ph88: it's saying "the expression (singleton (Put 10)) has type (IntState ())"
10:07:24 <lyxia> it's not a definition, it's not a toplevel signature
10:07:31 <ph88> unused expression ?
10:07:50 <lyxia> yes it is unused
10:08:10 <lyxia> it's not part of an actual program
10:10:38 <dexterfoo> anyone know of a Haskell DSL to generate Python code?
10:31:07 <ph88> alright thx lyxia
10:31:21 <ph88> dexterfoo, what do you need ?
10:34:16 <ph88> maybe you can make a quasi quoter that takes python and then use https://hackage.haskell.org/package/language-python
10:49:12 <heptahedron> Is there any demand for a simple length-indexed vector package? I ended up just writing my own tiny implementation with elementwise applicative + Num instances and some handy patterns for 2- and 3-dimensional vectors
10:52:43 <lyxia> heptahedron: have you looked at linear
10:53:31 <heptahedron> Oh I must not have used the right keywords when I searched last, I guess vector-sized kind of handles this
10:53:39 <heptahedron> lyxia: No, I haven't heard of that either, is that the package name?
10:53:43 <lyxia> yes
10:54:25 <lyxia> Also relevant is this blogpost https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html
10:56:29 <lyxia> So there seems to be some demand for this kind of things. I don't know how well the existing packages fulfill it.
11:01:00 <heptahedron> lyxia: You're right! Those packages do accomplish pretty much everything my meager 50 lines did and more. I'm trying to get really precise results, though, so sadly even though linear looks like it would do 99% of what I need, the Fractional requirement on some of the functions looks like it'll get in the way of the cyclotomic package being used here. Hm
11:06:28 <mark721> hi guys i had a quick question so like when you make a function and you want to ensure you deal with empty lists you can do something like
11:06:36 <mark721> myThing [] = []
11:06:48 <mark721> OR myThing [] = error "no empty list allowed"
11:06:57 <mark721> but what happens when you have two parameters i.e
11:07:28 <heptahedron> mark721: You could also use a type like NonEmpty which prevents an empty list from being passed in the first place
11:07:31 <mark721> myThing thisIsAnInteger [] = error "this doesn't work even if i give it a real list it overrides my list defintion"
11:08:03 <lyxia> mark721: in what way does that not work?
11:08:21 <mark721> so if i do myThing 5 [1,2,3,4] it will ALWAYS throw the error
11:08:50 <heptahedron> mark721: How are you ordering your pattern matches?
11:08:54 <ski> is `myThing' recursive on the tail of the list ?
11:09:03 <mark721> yes
11:09:04 <int-e> > let foo x [] = error "not this error" in foo 5 [1,2,3,4]
11:09:07 <lambdabot>  *Exception: <interactive>:3:5-37: Non-exhaustive patterns in function foo
11:09:08 <ski> no wonder, then
11:09:14 <mark721> OH
11:09:15 <mark721> LOL
11:09:39 <int-e> ski: you're good
11:09:43 <ski> > let brokenSum [] = error "boom !"; brokenSum (x:xs) = x + brokenSum in brokenSum [2,3,5,7]
11:09:45 <lambdabot>  error:
11:09:45 <lambdabot>      • Occurs check: cannot construct the infinite type: p ~ [p] -> p
11:09:45 <lambdabot>      • In the expression:
11:09:52 <ski> > let brokenSum [] = error "boom !"; brokenSum (x:xs) = x + brokenSum xs in brokenSum [2,3,5,7]
11:09:55 <lambdabot>  *Exception: boom !
11:10:17 <mark721> hmm odd i would've expected it to first return a value then the exception
11:10:27 <mark721> heptahedron, tell me about NonEmpty :)
11:10:38 <mark721> or a way to overcome this then since im using recursion
11:10:55 <ski> you need some kind of base case
11:11:02 <ski> if not the empty list, then perhaps a singleton list ?
11:11:05 <mark721> so if empty return empty list
11:11:11 <mark721> sweet :)
11:11:19 <ski> but first you should figure out whether there's a sensible way to define it for the empty list
11:11:49 <heptahedron> mark721: I would still give NonEmpty a shot if, like ski suggests, there isn't a sensical way to handle the empty list for a given function
11:12:32 <heptahedron> mark721: NonEmpty has a definition almost identical to that of lists, except the nil constructor has an argument.
11:12:45 <mark721> wait do i need to import it?
11:12:58 <heptahedron> mark721: Yes, but I believe it's in base, so you shouldn't have to add any dependencies
11:13:05 <ski> mark721 : perhaps you should say what this `myThing' is supposed to compute ?
11:13:37 <mark721> I mean to be honest I wasn't concerned about getting it working as much as wondering why it wasn't working :0
11:13:40 <mark721> * :)
11:13:52 <mark721> so that was my main thing (no pun intended)
11:14:06 <mark721> Thanks ski and heptahedron
11:14:16 <ski> (so that we could give an opinion about whether it could sensibly be defined for the empty list)
11:14:20 <heptahedron> mark721: I was wrong about the definition, while what I said would have worked, they represent it as a product of some a and a list of a: https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-List-NonEmpty.html
11:14:52 <mark721> ski, i know but honestly not worth it since i think i know the sensible way to do it like u mentioned
11:15:01 <mark721> and its not using an empty list ( i wasnt sure at first but u reminded me )
11:15:11 <mark721> ty :)  & dw heptahedron ty :0
11:15:13 <mark721> :)
11:15:16 <ski> "not using" ?
11:15:54 <mark721> i shouldnt return an empty list if i get an empty list as a parameter
11:16:07 <mark721> anyway gotta run thanks ski
11:16:11 <ski> hm, i assume that you decided to return an empty list, given an empty list, and that that satisfies you, given "so if empty return empty list"
11:16:14 <ski> ok
11:16:33 <ski> mhm
11:23:18 <iamnotverysmart> I require somebody who is decent and haskell and can explain a simple problem to me
11:23:51 <cocreature> iamnotverysmart: just ask your question and stick around for a bit :)
11:26:35 <iamnotverysmart> I am trying to intialize a selfmade typeclass but am failing, because I do not understand what the error is/what haskell exactly expects, code here: https://pastebin.com/wi3iwXND
11:26:43 <iamnotverysmart> Would highly appreciate help
11:27:53 <ski> there's no typeclass, apart from `Show', mentioned in there
11:28:18 <ski> do you want to create an array ?
11:28:44 <iamnotverysmart> I mean I want to intilize bank with the clients and accounts already included
11:29:02 <ski> @type array
11:29:03 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
11:29:05 <ski> @type listArray
11:29:07 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
11:29:24 <ski> you could use any of those to make an array with the accounts
11:29:44 <ski> the pair argument is the lower&upper array bounds
11:30:12 <cocreature> leaving that aside, it might also be worth considering making bank a "Map ID Account". that way you can easily remove and add accounts and are not forced to choose ids consecutively
11:30:15 <ski> `listArray' assumes that you give the array elements in order, in the list. `array' doesn't, but then you have to pair each element up with its corresponding index
11:31:01 <ski> @type Data.Map.fromList
11:31:03 <lambdabot> Ord k => [(k, a)] -> M.Map k a
11:31:08 <iamnotverysmart> I get that, but I am failing to initilize the bank. Since [(1,acc1),(2,acc2)] doesn't work and that is my main problem
11:31:16 <iamnotverysmart> and the only one I want to fix
11:32:22 <ski> well, if you do want an array, you'll have to call something like `array' or `listArray'. merely writing down a list with your accounts doesn't create an array
11:33:51 <cocreature> iamnotverysmart: "[(1, acc1),(2,acc2)]" has type [(ID, Account)], so you need a way to convert from that to an "Array ID Account". ski has already shown you the functions that allow you to do this
11:33:53 <ski> (but as cocreature said, if you're going to change the state of the bank much, using something else than an immutable array may be better .. with an immutable array, you're going to have to copy the array everytime you want to adapt it in some way)
11:43:59 <puregreen> I want to download some files and process them; both parts of the process are going to take quite some time and I want to do them in parallel (e.g. by maintaining some kind of queue, adding downloaded files to the back of the queue and removing processed files from the front of it). What would you recommend for this task?
11:46:09 <puregreen> I imaging that I can use some kind of Chan for the queue, and run two threads (the processing one and the publishing one) in parallel. However, I'd like to limit the length of the queue. Is there already a primitive for “length-limited atomic queue” somewhere on Hackage?
11:46:25 <puregreen> (or can I do it in a simpler way and I'm just missing it?)
11:46:30 <heptahedron> puregreen: unless a more experienced person wants to chime in, I think TVars might be the solution
11:46:40 <heptahedron> puregreen: https://hackage.haskell.org/package/stm-2.4.4.1/docs/Control-Concurrent-STM-TVar.html
11:47:25 <heptahedron> puregreen: I also believe conduits is supposed to be a good package, that might be less low-level and more suitable for your needs
11:47:30 <puregreen> oh, I found Control.Concurrent.STM.TBQueue, seems perfect
11:47:59 <puregreen> heptahedron: it'd be nice if I could use conduits for that, yes, but do conduits offer the kind of parallelization I want?
11:48:10 <webstrand> If I have: f :: a -> a -> [a] and g :: [a] -> [a], can I compose them like (g . f) $ u v? It doesn't seem to work, the type of (.) is wrong, but there's conflicting information online.
11:48:20 <ski> puregreen : perhaps `QSem' or `QSemN' ?
11:48:55 <ski> webstrand : `((g .) . f) u v'
11:49:29 <ski> (don't use `$' like that)
11:50:16 <heptahedron> puregreen: I've never used any of these libraries, so I don't want to accidentally say something unfounded that makes things harder for you down the line, but I found this stackoverflow post that seems like it's right up your alley to keep talking and
11:50:27 <heptahedron> mis-paste, whoops
11:50:53 <heptahedron> puregreen: https://stackoverflow.com/questions/26742276/parallel-processing-in-conduit-flow
11:53:37 <webstrand> ski: Is there an easier notation?
11:54:23 <ski> webstrand : if you define `(.:) = (.) . (.)', you can write `(g .: f) u v'
11:54:38 <cocreature> "fmap fmap fmap g f" is obviously easier
12:02:46 <erisco> webstrand, checkout control-dotdotdot
12:03:16 * erisco fixed the build for 8.2
12:07:35 <webstrand> erisco: neat, thanks
12:09:55 <L0g4nAd4ms> i know this question is about stack and not the haskell language itself but when i try to setup stack with "stack setup" it always fails on my linux 64 device with "missing symbol pthread_setname_np .."
12:10:00 <L0g4nAd4ms> Exact output: https://paste.ee/p/zjuEm
12:14:34 <oisdk> Does anyone know what the conclusion of this thread on the libraries mailing list was? https://mail.haskell.org/pipermail/libraries/2007-August/008028.html
12:14:45 <oisdk> (Data.List.groupBy with non-transitive equality predicate)
12:22:15 <ph88> L0g4nAd4ms, looks to me you have an incompatible glibc version
12:23:12 <ph88> maybe the library can't be found
12:24:04 <ph88> L0g4nAd4ms, https://stackoverflow.com/questions/19901934/strange-linking-error-dso-missing-from-command-line
12:24:19 <ph88> try to update stack and your resolver
12:24:38 <ph88> update cabal too just in case
12:25:39 <L0g4nAd4ms> well stack is latest and cabal is not installed at all
12:27:16 <cocreature> L0g4nAd4ms: which distro are you using?
12:28:33 <L0g4nAd4ms> Solus, i know this has to be a distro specific error
12:46:04 <shapr> ha: "cabal install cabal" gives "unknown package: youProbablyWantCapitalCabal (dependency of cabal-0.0.0.0)"
12:46:08 <shapr> very funny
12:47:23 <shapr> I wish for something like rustup for GHC
12:47:23 <Tuplanolla> It's funny until someone publishes `youProbablyWantCapitalCabal` that contains malware.
12:47:32 <shapr> Tuplanolla: yeah, good point
12:47:45 <shapr> or youProbablyWantCapitalCabal could just depend on Cabal ?
12:50:26 <infiniterandombo> how can I generate an infinite list of random bools, where they depend on previous elements of the list?
12:50:56 <infiniterandombo> for example, with a 10% chance of switching, you get "streaks" like TTTTTTFFFFFTTFFFFFFFF
12:53:24 <infiniterandombo> here's working code for a finite list: http://lpaste.net/362033
12:54:47 <lyxia> use randomRs to get an infinite list of numbers between 0 and 9, then traverse it
12:55:18 <cocreature> or replace the use of IO by explicitely passing around the generator and only initialize it at the beginning
12:56:58 <lyxia> There's also lazy RandT
13:10:07 <zennist> has a tricky question regarding lens - anyone knows how 'partsOf' actually work? It takes a Traversal and gives back a Lens that does a global replacement over the structure with a supplied input output list. Conceptually I can understand how it works: 1) use the traversal to figure out the multiple targets it hits in the structure 2) run the replacement function, getting the resultant output list 3) putting the results back into the
13:10:07 <zennist> orignal target locations
13:10:30 <zennist> now 1) can be achieved with a fold but I really have no idea how 3) is done
13:11:18 <zennist> and looking at the source code I feel like I can have some help...
13:12:51 <fresheyeball> has anyone gotten hlibsass to link?
13:12:55 <lyxia> zennist: A Traversal allows you to put values back. Then the trick is to use State
13:14:19 <zennist> lyxia: so the Traversal is run multiple times then? A collect phase for getting the targets, and another phase for putting results back?
13:15:45 <zennist> I wonder if RecursiveDo could shrink that into one run i.e., when identifying the target, we allocate some IORef that we simultaneously get the result from; and later when the traversal is finished we run the input output list function and put the results back into these IOREf
13:18:26 <heptahedron> Even for length-indexed vectors, getting the length at runtime is linear right? I can't seem to see a way typeclasses could avoid this calculation
13:21:13 <cocreature> heptahedron: depends on how they are built. if you built them inductively then you definitely have linear length, if you use the "newtype with a KnownNat parameter over a vector/array" approach, then you get O(1) length
13:21:43 <lyxia> zennist: there's probably a way, I don't know whether partsOf does it already
13:23:00 <zennist> maybe not, on second thought this would require the structure to be lazy on holding these values
13:23:25 <heptahedron> cocreature: Alright thanks, that's what I figured. In theory though, this doesn't /always/ have to be the case though, correct? E.g. for vectors of compile-time known length
13:24:07 <heptahedron> cocreature: I know GHC probably doesn't have the machinery to implement this kind of thing, just curious
13:24:21 <cocreature> heptahedron: well in theory it doesn’t always have to be the case for regular lists either if you imagine an compiler that is smart enough to figure out the length of lists in certain cases
13:24:32 <cocreature> but GHC doesn’t do either of those things
13:27:28 <heptahedron> cocreature: Hmm. How does GHC handle typeclass arguments? Doesn't it like, inline them at compile time if it knows what type will be used? How does this factor in to things?
13:28:18 <cocreature> sometimes it specializes and inline things but that’s based on heuristics
13:28:34 <heptahedron> cocreature: Ah, okay. Cool! Thanks
13:28:46 <cocreature> and it won’t inline recursive definitions.
13:29:17 <n_blownapart> https://ptpb.pw/1-tw    hi real quick do the comments correctly show how the program evaluates?
13:29:41 <heptahedron> cocreature: That makes sense.
13:30:04 <n_blownapart> no sorry its wrong...
13:30:08 <lyxia> n_blownapart: you have Succ applied to two arguments and Zero applied to one...
13:33:04 <n_blownapart> lyxia: so the first line of evaluation is wrong, correct?
13:33:52 <lyxia> all of them actually
13:34:06 <n_blownapart> thanks one sec
13:40:02 <_d0t> ohai. Which freer implementation/package should I choose?
13:41:25 <lyxia> _d0t: freer-simple
13:41:25 <johnw> _d0t: I like freer-effects a lot, but it seems to be stalling in development
13:41:48 <johnw> ah
13:41:50 <johnw> nice
13:41:59 <_d0t> oh.. so there's another fork
13:42:04 <_d0t> i lost it at freer-effects
13:42:10 <_d0t> good to here somebody took over
13:42:21 <johnw> i wonder what's different
13:42:46 <lyxia> extensible-effects and extensible are also active
13:43:34 <_d0t> there's a CoC in freer-simple, for one
13:43:39 <_d0t> also ghc 8.2 is supported
13:46:12 <_d0t> extensible seems to have a more broad application, but extensible-effects looks nice
13:46:26 <johnw> CoC?
13:46:31 <_d0t> code of conduct
13:46:35 <johnw> ahh
13:46:41 <johnw> I was thinking Calculus of Constructions :)
13:46:48 <_d0t> i wish
13:47:23 <n_blownapart> lyxia: I guess there are only 2 lines: https://ptpb.pw/5frk
13:47:57 <n_blownapart> the evaluation stays in add til the termination?
13:48:39 <lyxia> You still have Succ applied to two arguments, that is ill-typed
13:49:59 <lyxia> n_blownapart: can you explain how you get the first line
13:50:17 <n_blownapart> Succ ((Succ Zero) (Succ Zero)) for the 2nd line
13:50:53 <lyxia> n_blownapart: What is the type of (Succ Zero)
13:51:11 <Welkin> Nat
13:51:23 <n_blownapart> Nat
13:51:29 <Welkin> King Cole
13:52:11 <n_blownapart> pesky gNat
13:52:15 <lyxia> n_blownapart: So that is not a function.
13:52:28 <lyxia> But (Succ Zero) (Succ Zero) applies a Nat to a Nat
13:53:10 <Welkin> Nat King Cole squared
13:54:01 <n_blownapart> please write the correct evaluation
13:54:32 <Welkin> @let data Nat = Cole | King Nat | Nat Nat
13:54:34 <lambdabot>  Defined.
13:54:39 <Welkin> > Nat King Cole
13:54:43 <lambdabot>  error:
13:54:43 <lambdabot>      • Couldn't match expected type ‘Nat -> t’ with actual type ‘Nat’
13:54:43 <lambdabot>      • The function ‘Nat’ is applied to two arguments,
13:54:52 <Welkin> > Nat (King Cole)
13:54:55 <lambdabot>  error:
13:54:56 <lambdabot>      • No instance for (Show Nat)
13:54:56 <lambdabot>          arising from a use of ‘show_M159382353606893726226568’
13:54:58 <Welkin> :(
13:55:51 <n_blownapart> dread Nat ty
13:56:13 <Welkin> @let data Nat = Cole | King Nat | Nat Nat deriving Show
13:56:15 <lambdabot>  .L.hs:173:1: error:
13:56:15 <lambdabot>      Multiple declarations of ‘Nat’
13:56:15 <lambdabot>      Declared at: .L.hs:169:1
13:56:19 <Welkin> @undefine
13:56:19 <lambdabot> Undefined.
13:56:20 <Welkin> @let data Nat = Cole | King Nat | Nat Nat deriving Show
13:56:22 <lambdabot>  Defined.
13:56:25 <Welkin> > Nat (King Cole)
13:56:30 <lambdabot>  Nat (King Cole)
13:56:32 <Welkin> :D
13:56:41 <lyxia> n_blownapart: http://lpaste.net/362034
13:56:58 <pie__> does it make any sense to try fuzzing the RTS or will that just usually break on bad input?
13:57:47 <n_blownapart> dammit
13:59:07 <lyxia> n_blownapart: actually that should be n = Zero
13:59:12 <lyxia> so I fixed it
13:59:25 <Welkin> nzuri :D
13:59:30 <Welkin> oh
13:59:34 <Welkin> write your programs in swahili
13:59:49 <Welkin> I did it once in chinese
14:00:04 <Rembane> What happened?
14:00:27 <Welkin> it worked
14:00:36 <Welkin> I just named all the functions and types in chinese
14:00:40 <Rembane> Which chinese?
14:00:47 <Welkin> simplified
14:01:03 <Welkin> swahili would be easier
14:01:10 <Welkin> it uses asciii
14:01:35 <Rembane> Cool.
14:01:46 <Welkin> the sun is going down :(
14:01:46 <Rembane> Isn't Haskell unicode compatible?
14:01:52 * Rembane hands Welkin a sun extender
14:02:03 <Welkin> yes, but constructors and types must begin with a captial letter
14:02:06 <Welkin> that was the only issue
14:02:08 <geekosaur> it is, with some caveats. Like, that
14:02:13 <Welkin> I had to prefix them
14:02:26 <Rembane> Ah. Is that a reasonable limitation or is it just there because of tradition?
14:02:41 <geekosaur> some lexical distinction is needed
14:03:02 <geekosaur> good luck finding one, or a reasonable set of them, that covers *all* the character sets in Unicode
14:03:24 <geekosaur> or a symbol that could be reasonably stolen to make a generic 'constructor marker'
14:03:40 <geekosaur> (that doesnt end up being like e.g. Prince :)
14:03:45 <Rembane> Everything that's uppercase? :)
14:04:01 <geekosaur> what's uppercase Chinese? or Arabic?
14:05:46 <n_blownapart> lyxia: I'm dealing with new syntax
14:05:54 <Welkin> > let 加= (+) in 加 2 3
14:05:57 <lambdabot>  5
14:06:00 <Welkin> :D
14:06:37 <Welkin> I am amazed I remember the character used for addition since I learned it 10 years ago
14:06:48 <n_blownapart> lyxia sorry more confused now
14:06:48 <lyxia> n_blownapart: which is?
14:07:02 <Rembane> geekosaur: I think arabic has them, but chinese, no such luck.
14:07:16 <geekosaur> arabic does not
14:07:19 <Rembane> geekosaur: I was of course wrong. :)
14:07:31 <Rembane> I need to google before I speak.
14:07:34 <simplegauss> is there already an abstraction that captures a "tagged" category that carries metadata along with composition? for (oversimplified) example: suppose I want to be able to find out if I have some long chain of isomorphisms that evaluates to the identity, then i would make "data IsoMeta = IsoMeta { name :: String, forward :: Bool }; data TaggedFun a b = TaggedFun { f :: a -> b, tag :: [Maybe IsoMeta] }", then I would make TaggedFun an
14:07:34 <simplegauss> instance of category by normal composition for a -> b and appending to the list for tag
14:07:41 <geekosaur> there is an "initial form" but initial does not mean uppercase
14:08:24 <Rembane> Indeed.
14:08:58 <simplegauss> then I could post process the list to see where i actually get identity out. of course this is easy to do by myself but i was wondering if there is already some categorical notion of this, and actually a better way to think about it (especially since i am using the free Monoid (actually semigroup i think))
14:10:54 <lyxia> simplegauss: this seems to be a product category. It's the product of (->) and the monoid [Maybe IsoMeta] (viewed as a category).
14:11:40 <rebel___> Hello!
14:12:17 <Welkin> rebel___: what a long tail you have
14:12:17 <rebel___> I'm trying to wrap my head around some functional programing terms and want to check if i have gotten the right end of the stick
14:12:31 <Welkin> the carrot, or the stick?
14:12:51 <rebel___> haha
14:12:58 <Welkin> 'cause you don't want to eat the green leafy end of the carrot
14:12:58 <rebel___> ok so
14:13:05 <Welkin> and chewing on a stick is just wrong
14:13:19 <rebel___> yeah right end of the carrot lets go with that
14:13:24 <rebel___> so
14:13:27 <rebel___> higher order functions
14:13:42 <Welkin> functions are values, just like any other value
14:13:50 <rebel___> just means that the functions can be assigned to variables and passed arround the program like variables cen
14:13:51 <rebel___> can
14:14:01 <rebel___> okay thats good
14:14:15 <Welkin> there is no assignment in haskell
14:14:16 <rebel___> monads are wrappers for other values?
14:14:27 <Welkin> monads are an interface (a typeclass)
14:14:55 <rebel___> okay i think i may still be lost with monads then
14:15:11 <Welkin> they are an interface, just like Show or Eq or Functor
14:15:16 <rebel___> Option is a monad?
14:15:22 <Welkin> there is no Option
14:15:25 <Welkin> unless you mean Maybe
14:15:27 <rebel___> ah
14:15:33 <lines> or Either
14:15:34 <Welkin> Maybe is a data type
14:15:41 <Welkin> it has an instance defined for Monad
14:15:51 <Welkin> which just means that there is a set of functions known to be defined for it
14:15:56 <Welkin> so you can use that interface with Maybe
14:16:34 <n_blownapart> lyxia: couldn't get that to compile
14:16:36 <rebel___> humm
14:17:08 <Welkin> Monad specifies a minimum of two functions that need to be defined to create an instance: `return` and `>>=`
14:17:47 <Welkin> if you haven't yet, learn about Functor first, then Monoid, then Applicative, then Monad
14:18:04 <rebel___> ah okay
14:18:05 <Welkin> these are all just interfaces
14:18:13 <rebel___> i may have been jumping the gun on that
14:18:16 <rebel___> thats interesting
14:18:34 <rebel___> so they are names for interfaces whch do things
14:19:07 <Welkin> they are typeclasses
14:19:13 <lines> I don't know - I think you can build up an intuition for Monad before dealing with all those things
14:19:15 <Welkin> you can create your own typeclasses if you want as well
14:19:42 <lines> (e.g. I used the Reader and Maybe Monads a bunch before learning about t'others properly)
14:19:45 <rebel___> ill go and look those up in order and see if it makes more sence
14:19:48 <Welkin> a typeclass is a specification for an interface (an API) that you can implement for different types
14:19:49 <lines> (and that really helped with intuition)
14:20:13 <rebel___> the way i currently think about them is they are used in streams
14:20:29 <parsnip> i see `m a`, i think, "crazy blob".
14:20:47 <Welkin> Monad is used to safely do IO and keep the language pure, but you'll get to that eventually
14:21:03 <Welkin> there is a great paper on the topic titled "Lazy Functional State Threads"
14:21:37 <rebel___> Im very early on with learning functional programing
14:21:45 <Welkin> take it slow
14:21:46 <Welkin> you have time
14:22:08 <rebel___> would you say that you can program functionally without knowing exactly what a monad is
14:22:34 <Welkin> yes
14:22:42 <Welkin> all you need to understand is how to use the interface
14:22:57 <Welkin> the word "monad" means nothing in regard to programming
14:23:14 <rebel___> i see
14:23:31 <ddellacosta> rebel___: at the risk of overwhelming you further, this is a good doc to keep in your back pocket: http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori
14:23:33 <rebel___> i think i may be getting hung up on this stuff
14:23:45 <Welkin> if you really want to get into monads now, I recoomend my favorite paper on the topic: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
14:23:52 <rebel___> im coming from a Java 8 background
14:24:07 <Welkin> the logical progression is Functor, Monoid, Applicative, then Monad
14:24:12 <rebel___> are functiors what lambdas are in java
14:24:14 <Welkin> Monoid and Applicative can be swapped if you like
14:24:20 <Welkin> no
14:24:28 <parsnip> typeclassopedia been recommended yet? it has exercises.
14:24:42 <rebel___> i have not but ill take a look
14:24:45 <kadoban> rebel___: Naw, haskell has lambdas too. Functor is totally different
14:24:53 <ddellacosta> parsnip: indirectly, it's referenced in the link I just pasted above
14:26:14 <simplegauss> lyxia: yes, that's what i was thinking, but is there more to say than what i said? is there some nice structure for "simplifications" than the manual approach i was proposing? is there a "better" choice than [Maybe IsoMeta]?
14:29:22 <lyxia> simplegauss: I don't understand the part about post processing a list
14:30:06 <lyxia> And I don't know what "nice structure" you are looking for
14:30:29 <simplegauss> lyxia: the point is to have composition with "metadata", so that for example i know if there is some long chain of isomorphisms that actually evaluates to the identity, or by reducing the metadata to some canonical form i can compare two compositions of functions for equality
14:32:12 <simplegauss> my solution feels a bit ad-hoc, i can't really say why. i think it's the best that can be done in general, but perhaps people have thought of some nicer structure that accomplishes the same thing, at least with some additional mild restrictions. it's hard to know what you don't know :)
14:33:18 <lyxia> simplegauss: Is f entirely determined by the tag
14:35:33 <simplegauss> lyxia: sometimes yes, but in my application it is typically not easy or possible to find f from the tag :)
14:36:32 <lyxia> simplegauss: Why is the tag of type [Maybe IsoMeta] rather than [IsoMeta]
14:36:53 <Welkin> I so meta?
14:36:54 <Welkin> lol
14:37:01 <lyxia> hahaha
14:37:12 <simplegauss> because a non-isomorphism starts with tag "[Nothing]" and an isomorphism starts with "[Just tag]"
14:37:53 <simplegauss> this way i can collapse sections of "Nothing" (they are a chain of non-invertible, "opaque" mappings)
14:39:29 <simplegauss> lyxia: my actual example is more complicated, so i actually have a more complicated tag type. i'm guessing you're just going to say make the tags into a category on their own, but i want the function composition as well, and that can be hard or impossible to compute from the tags alone
14:40:15 <lyxia> Okay. I don't have any more ideas then. :(
14:45:50 <jim__> is it possible to generate a random number inside a TVar?
14:46:10 <jim__> or rather generate a random number and write it to a TVar?
14:46:18 <Welkin> generate an infinite list of random values on start up
14:46:24 <Welkin> then just grab the next one off the list
14:47:55 <jim__> i thought you had to work in the STM monad
14:48:10 <jim__> and then use atomically to lift into IO
14:48:57 <woodson> Welkin: Thanks for giving me a hand last night! still not sure if the problem is actually in WAI but I will open an issue on my git about it.
14:49:22 <Welkin> woodson: glad I could help
14:49:46 <Welkin> jim__: you don't need to deal with any IO if you generate an infinite list of values up front and then just store that somewhere
14:50:29 <Welkin> :t randoms
14:50:31 <lambdabot> (RandomGen g, Random a) => g -> [a]
14:50:31 <jim__> alright I'll give it a shot
14:50:33 <jim__> thanks Welkin
14:54:14 <webstrand> I have sampled the points of some function, is there an easy way to turn those points into a continuous approximation of the real function? Even just terminology to get me started would help
14:54:51 <kebolio> hi
14:55:31 <kebolio> im looking for a sequence, container, array, list, whatever type that lets me swap elements by index
14:55:44 <kebolio> with something like swap :: Int -> Int -> [a] -> [a]
14:56:16 <simplegauss> webstrand: it is highly dependent on your problem
14:56:37 <kebolio> i'm trying to implement schneier's solitaire in haskell as a learning exercise which involves shuffling cards about
14:57:15 <Welkin> you should look at Vector
14:57:22 <Welkin> lists are not made for that
14:57:29 <Welkin> sequence isn't really made for that
14:57:36 <simplegauss> webstrand: many methods choose some set of functions to approximate your original function with (for example polynomials or complex exponentials/trig functions) and projecting onto that set by some inner product
14:57:37 <webstrand> simplegauss: I've used a ruler to sample the points from a printed graph.
14:58:47 <simplegauss> webstrand: that's still not enough information. for example, look at the graph of sin(pi * x). it is zero at every integer, but so is the zero function. both are continuous
14:59:27 <simplegauss> webstrand: you have to have some idea of what you want your function to look like
14:59:40 <kebolio> Welkin: i thought vectors were an io type but seems like im wrong. thanks
14:59:59 <exio4> hallo
15:00:07 <geekosaur> there are multiple vector types
15:00:39 <webstrand> simplegauss: If I understand correctly, I would be happy with an approximation that use a linear interpolation between points?
15:00:48 * Welkin turns on the spotlight and turns it toward geekosaur 
15:01:01 * Welkin places the needle on the record
15:01:06 <exio4> stack init is stuck on 'Updating package index Hackage (mirrored at https://s3.amazonaws.com/hackage.fpcomplete.com/) ...', any ideas?
15:01:10 <Welkin> sing it
15:01:17 * geekosaur doesn't intend to say much more
15:01:17 <Welkin> all of the vector types
15:01:50 <geekosaur> becaue I don;t use Vector much. but the mutable vector types use IO or ST
15:01:54 <simplegauss> webstrand: well then isn't it straightforward? just take your function to be the line between pairs of adjacent points?
15:01:55 <MarcelineVQ> exio4: it's a very large file, how long have you been waiting?
15:02:17 <exio4> MarcelineVQ: until it says Network.Socket.recvBuf: resource vanished (Connection reset by peer)
15:02:28 <MarcelineVQ> well that's no good ;>
15:02:41 <MarcelineVQ> maybe their cdn is glitching out
15:03:05 <exio4> MarcelineVQ: tried a few times already, my network is about 4Mbps right now (should be fine, I believe?)
15:03:19 <Welkin> exio4: that happens to me sometimes
15:03:27 <Welkin> it also happens with homebrew
15:03:31 <Welkin> sometimes it takes several minutes
15:05:59 <exio4> Welkin: I'll try a few extra times then
15:06:34 <MarcelineVQ> I'd expect any speed should be fine to not time-out with, should just take a long time the slower you are, seems likely it's an issue between you and the amazon servers. Are you just trying to make a project? You could make a stack.yaml yourself, just need to specify a resolver
15:07:17 <MarcelineVQ> dunno if it's going to do the same update issues when you go to  stack build or not
15:10:51 <kebolio> just another funny question, f . g $ x or f $ g x?
15:11:10 <hpc> they're both the same
15:11:15 <hpc> but if you add say, h
15:11:20 <MarcelineVQ> some people might say  (f . g) x
15:11:21 <hpc> the latter becomes a bit more awkward
15:11:30 <hpc> while with (.) you can do f . g . h $ x
15:11:50 <kebolio> k cheers
15:12:07 <ReinH> kebolio: do you want to think about f . g as its own thing or do you want to think about g x as its own thing?
15:12:24 <hpc> using (.) also helps for when you have to manipulate (f . g) on its own
15:12:34 <isBEKaml> If it's only one argument, the $ can be skipped entirely. As in, you could write a function: myFunction = f . g . h and it's the same as saying: myFunction x = f . g . h $ x
15:17:19 <kebolio> its only `ord . toUpper` in isolation
15:18:29 <EvanR> f . g $ x vs f $ g x, figure out how to say it without $
15:18:56 <EvanR> to save $
15:19:01 <hexagoxel> f `id` g x
15:20:24 <isBEKaml> I think $ shaving is a pointless pursuit. It's up to the developer to go with whatever's readable to them
15:20:46 <EvanR> or to be informed of conventions
15:20:52 <erisco> join the $ shave club!
15:21:04 <kebolio> what is the convention then
15:21:28 <EvanR> for simple things like f (g x)
15:21:33 <EvanR> just do that
15:21:42 <EvanR> seasame
15:22:09 <kebolio> oh ok
15:23:26 <EvanR> if that combination comes up a lot put f . g in a where clause
15:26:11 <wroathe> Is there a more idiomatic way of writing something like (i `mod` 3 == 0) || (i `mod` 5 == 0) in Haskell?
15:26:36 <Faggotry> http://whew.ga/install.html
15:27:06 <wroathe> My first attempt was something like let eq0 = (==) 0; modi = mod i; in (eq0 $ modi 3) || (eq0 $ modi 5)
15:27:17 <kebolio> wroathe: fizzbuzz?
15:27:31 <wroathe> Project Euler Problem 1
15:27:43 <jim__> alright what im trying to do is generate a new random TVar int that is between 1 and 10 higher than a given TVar
15:27:56 <jim__> the TVar is then propagated across the network
15:28:32 <wroathe> I suppose I could write a `multipleOf` function that takes a number and a list of numbers to check for multiples
15:28:35 <jim__> the given TVar in instantiated inside the IO moad
15:28:37 <jim__> monad*
15:28:41 <wroathe> multipleOf i [3, 5]
15:29:35 <exio4> is there any way to download this manually?
15:29:48 <Welkin> is Faggotry a spam bot?
15:29:50 <Welkin> @ops
15:29:50 <lambdabot> Maybe you meant: pl oeis docs
15:30:26 <Welkin> @where ops
15:30:26 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver shachaf shapr ski
15:30:29 <Welkin> there we go
15:30:57 <EvanR> wroathe: are you trying to say "divides"
15:31:01 --- mode: ChanServ set +o shapr
15:31:05 --- kick: Faggotry was kicked by shapr (Kicked by shapr)
15:31:26 <EvanR> i `divides` 3 || i `divides` 5
15:32:03 <EvanR> er
15:32:03 <wroathe> EvanR: I am indeed
15:32:07 <EvanR> 3 `divides` i
15:32:20 <EvanR> well there you go
15:32:25 <wroathe> :D thanks
15:33:52 <EvanR> i remember being ridiculed in certain programming language communities for using really small non standard functions like that to avoid repetitious stuff like x `mod` y = 0
15:34:17 <EvanR> luckily ghc does inlining
15:38:06 <kebolio> renaming imports as initials i.e Data.Vector as DV is convention right?
15:38:18 <EvanR> V for vector
15:38:58 <kebolio> ok
15:41:38 <Welkin> M is for Monad
15:41:42 <Welkin> and C is for Cookie!
15:41:47 <EvanR> M for Map
15:42:04 <kebolio> so Data.Vector.Mutable as DVM? or VM?
15:42:08 <Welkin> Map is Map!
15:42:14 <Welkin> kebolio: however you like
15:42:24 <Welkin> I usually go with MV
15:42:32 <EvanR> if youre henning thieleman then C is for class
15:42:33 <kebolio> i need confirmation dammit!!
15:42:49 <kebolio> lmao that probably came across wrong
15:43:22 <kadoban> I tend to just throw everything related together, so I'd put D.V.M in V as well, unless they conflict
15:43:22 <EvanR> the api for mutable vector doesnt collide mushc
15:43:25 <EvanR> much
15:43:47 <kebolio> oh yeah
15:45:47 <edmundnoble> You can qualified import multiple modules with the same identifier?
15:45:52 <kadoban> Yep
15:46:14 <edmundnoble> Wow, wow wow wow
15:46:21 <edmundnoble> TIL, that's awesome
15:46:54 <monochrom> http://www.vex.net/~trebla/haskell/module.xhtml#import-as
15:50:47 <puregreen> this returns []:
15:50:49 <puregreen> runConduit $ yieldMany [1,2,3,4,5] .| dropWhileC (<2) .| sinkList
15:50:56 <puregreen> I don't understand why :(
15:52:15 <puregreen> (to replicate, install conduit-combinators and then import Conduit)
15:53:26 <puregreen> oh, I found the answer! https://stackoverflow.com/questions/10834773/how-to-use-the-conduit-drop-function-in-a-pipeline/10836477#10836477
16:17:11 <EvanR> so the enumerator package is like, an iteratee library
16:17:28 <EvanR> is it old school, i only see people debating pipes vs conduit
16:18:22 <n_blownapart> > (\x -> x x) (\x -> x x)
16:18:25 <lambdabot>  error:
16:18:25 <lambdabot>      • Occurs check: cannot construct the infinite type: t0 ~ t0 -> t
16:18:25 <lambdabot>        Expected type: t0 -> t
16:19:12 <EvanR> :t (\x -> x x)
16:19:14 <geekosaur> one of the earliest, yes
16:19:14 <lambdabot> error:
16:19:14 <lambdabot>     • Occurs check: cannot construct the infinite type: t ~ t -> t1
16:19:14 <lambdabot>     • In the first argument of ‘x’, namely ‘x’
16:19:43 <n_blownapart> any interesting points about that , that are easy for a beginner to understand? I looked online but the examples were sort of complicated
16:20:07 <EvanR> see my :t command, even by itself that doesnt have a (finite) well typed type
16:20:32 <n_blownapart> yeah thanks I saw it in a video written that way for illustration I guess
16:20:35 <EvanR> :t f f
16:20:37 <lambdabot> error:
16:20:37 <lambdabot>     • Could not deduce (Show t0) arising from a use of ‘f’
16:20:37 <lambdabot>       from the context: FromExpr t
16:20:43 <EvanR> hmm
16:21:15 <EvanR> (\f -> f f) is a function which takes a function that can take an argument of its own type
16:21:35 <EvanR> so its like let T = T -> T in T
16:21:52 <EvanR> so its like let T = T -> X in T
16:21:59 <n_blownapart> cool, at least I am familiar with y-combinator
16:22:13 <EvanR> ... -> T) -> T) -> T) -> X
16:22:32 <EvanR> im wrong again!
16:22:39 <jle`> n_blownapart: it's not something that makes sense in haskell
16:22:42 <EvanR> ... -> X) -> X) -> X) -> X
16:23:02 <n_blownapart> I figured haskell did recursion differently jle`
16:23:07 <jle`> n_blownapart: so it's like trying to understand nonsense :)
16:23:11 <jle`> if we're talking about haskell
16:23:17 <Welkin> it's like reading Finnegan's Wake?
16:23:20 <EvanR> the recursion is the same
16:23:27 <n_blownapart> really?
16:23:29 <EvanR> but haskell's type system can't handle it
16:24:33 <jle`> it's not a well-typed haskell concept
16:24:43 <jle`> but it probably makes sense in some things that aren't haskell
16:24:55 <EvanR> neither can simply typed lambda calculus, which is why it doesnt have a tricky way to implement recursion
16:25:27 <EvanR> by adding a type system to untyped LC, the fixed point combinator gets excluded
16:25:36 <Hacka> hey guys
16:25:38 <Hacka> im a beginner
16:25:56 <Hacka> im trying to understand the difference between `div` and `quot`
16:26:01 <n_blownapart> cannot read Joyce . my girlfriend did Joyce for undergraduate thesis paper.
16:26:05 <Hacka> i can't seem to get a different answer between them
16:26:16 <n_blownapart> yeah the threads were talking about fixed point combinators
16:26:28 <jle`> > 4 `div` (-3)
16:26:31 <lambdabot>  -2
16:26:32 <jle`> > 4 `quot` (-3)
16:26:36 <lambdabot>  -1
16:26:59 <Hacka> ooh okay
16:27:00 <jle`> @check \x y -> (x `div` y) == (x `quot` y)
16:27:04 <lambdabot>  *** Failed! Exception: 'divide by zero' (after 1 test):
16:27:04 <lambdabot>  0 0
16:27:06 <jle`> aw
16:27:13 <Hacka> but i don't quite understand why they give different answers
16:27:15 <jle`> @check \x y -> y /= 0 ==> (x `div` y) == (x `quot` y)
16:27:15 <lambdabot>  :-1:-1:Ambiguous infix expression
16:27:20 <jle`> @check \x y -> y /= 0 ==> ((x `div` y) == (x `quot` y))
16:27:23 <lambdabot>  error:
16:27:23 <lambdabot>  • No instance for (Arbitrary Test.QuickCheck.Safe.SProperty) arising from a ...
16:27:26 <EvanR> n_blownapart: what you wrote first was a fixed point combinator in ULC
16:27:27 <jle`> hm.
16:27:57 <jle`> @check \x y -> (y /= 0) ==> ((x `div` y) == (x `quot` y))
16:28:03 <lambdabot>  *** Failed! Falsifiable (after 6 tests and 5 shrinks):
16:28:07 <lambdabot>  7 -5
16:29:15 <shapr> Is there a specific channel for amazonka questions?
16:29:15 <n_blownapart> I see thank you
16:29:29 --- mode: shapr set -o shapr
16:29:34 <monochrom> Psychologists are hired to perform @check. This is why 5 shrinks were involved. :)
16:29:55 <n_blownapart> what is the irc command for (thought) bullet ?
16:30:32 <n_blownapart> I need to clean up my act ^
16:30:48 <shapr> I'm trying to write my first amazonka code, but cabal new-repl gives me a compile error - src/Network/AWS/Env.hs:195:24: error: Variable not in scope: conduitManagerSettings :: ManagerSettings
16:31:56 <shapr> I can't tell if that's my fault or if the library has a bug
16:36:03 <Hacka> hey what about rem and mod
16:36:11 <Hacka> i know rem returns the remainder
16:36:14 <Hacka> but what is mod
16:36:51 <monochrom> If you understand quot and div, then rem pairs with quot, mod pairs with div.
16:37:28 <Hacka> ahh ok
16:45:01 <shapr> wow, amazonka-s3 takes a really long time to compile
16:46:52 <Welkin> use s3-signer
16:48:41 <MarcelineVQ> shapr: I also encounter this error with cabal new-build  on a fresh  cabal init  with just amazonka added to build-depends
16:50:29 <MarcelineVQ> shapr: https://github.com/brendanhay/amazonka/pull/441
16:50:35 <shapr> MarcelineVQ: aha, so it's not just me
16:51:25 <shapr> ah, I'll try that
16:54:01 <Hacka> what does Type: [a] -> [a] -> [a]
16:54:02 <Hacka> mean?
16:54:04 <shapr> soo, I need to bump the http-conduit minimum version, but I need to do it locally. Can I point cabal to my local checkout of amazonka?
16:54:16 <Hacka> what kind of type would that be
16:54:38 <MarcelineVQ> shapr: sure, with new-* I think you use a cabal.project file for that
16:55:21 <geekosaur> Hacka, it takes two lists with the same type of elements, and produces a list with that same type of elements
16:55:23 <MarcelineVQ> shapr: https://cabal.readthedocs.io/en/latest/nix-local-build.html#local-versus-external-packages
16:57:02 <shapr> MarcelineVQ: thanks!
16:57:37 <EvanR> referenced in the itertee paper... from 1995 paper State in Haskell... "We fear that there may be no absolutely secure system – that is, which one guarantees the Church-Rosser property – which is also expressive enough to describe the programs which systems programmers (at least) want to write..."
16:58:05 <EvanR> interesting notion of absolutely secure
17:00:06 <Welkin> airgapped, turned off
17:00:19 <Welkin> zeroed out data
17:00:33 <Welkin> in a volcano
17:02:25 <geekosaur> encased in concrete and dumped into the marianas trench
17:02:59 <hololeap> i need some help understanding something with Data.Set. i thought that the properties of a finger list would allow looking up the minimum element and the maximum element in O(1) time, but the docs say lookupMin is O(log n)
17:03:25 <monochrom> Data.Set is a balanced binary search tree.
17:03:38 <Welkin> finger list?
17:03:44 <Welkin> a finger tree?
17:03:46 <hololeap> sorry, finger treey
17:03:48 <hololeap> *tree
17:03:54 <Welkin> Data.Set used a balanced binary tree
17:03:57 <Welkin> I thought
17:04:10 <hololeap> then i was mistaken
17:04:23 <Welkin> Data.Sequence.Seq uses a finger tree
17:04:39 <kadoban> hololeap: You can make min/max O(1) if it matters with a wrapper without making anything asymptotically worse of course
17:04:42 <davean> "The implementation of Set is based on size balanced binary trees (or trees of bounded balance) as described by:
17:04:45 <davean> "
17:04:49 <davean> Right at the top of the docs
17:05:18 <davean> If you want to get into the details of the implimentation, the code is quite readable, and they link two papers
17:05:25 <hololeap> oops
17:05:43 <davean> Finger trees have very high coefficients
17:07:57 <Welkin> if you need a priority queue, there are several libraries for that
17:08:06 <davean> rather good ones too.
17:08:40 <davean> including priority search queues, an area I find sadly lacking in most language's readily available libraries
17:09:35 <kadoban> What's a priority search queue implementation? Don't you just use BSTs for those typically?
17:11:09 <EvanR> Map Rational a hehe
17:11:28 <davean> kadoban: priority search queues allow you fast access to the priority entry, and allow you to delete/update by key
17:12:04 <davean> a BST can give you a priority queue, but it takes more to make it searchable
17:12:26 <kadoban> Oh, I see
17:12:27 <EvanR> theres minView
17:12:34 <EvanR> but it involves a rebalancing
17:12:59 <kadoban> It's just the need for two different ways to index in, essentially
17:13:08 <davean> kadoban: yes
17:13:21 <davean> kadoban: Consider, for example, caching.
17:13:41 <davean> Its not the best example, but it makes the problem obvious
17:14:01 <monochrom> I use http://hackage.haskell.org/package/psqueues for priority search queue.
17:14:16 <Welkin> you can also use redis (or another key-value store) as a priority queue
17:14:21 <Welkin> for an industrial scale solution
17:14:35 <EvanR> would you say, its webscale?
17:14:47 <davean> kadoban: anyway, its a very important datastructure for the efficient implimentation of a lot of things, and often its neglected
17:14:50 <Welkin> it's internet scale
17:15:00 <kadoban> Yeah, makes sense
17:15:28 <EvanR> exactly what feature of redis gives you a priority search queue
17:15:37 <davean> EvanR: He didn't say search
17:15:39 <geekosaur> remember linux nscd? that screams for a psqueue
17:15:59 <geekosaur> but didjn't have one, so it was perpetually buggy and unreliable
17:16:04 <EvanR> +search means access to the minimum?
17:16:07 <Welkin> EvanR: not a search queue, just a priority queue
17:16:17 <davean> EvanR: search means access to *any* entry directly
17:16:18 <Welkin> like a job queue
17:16:20 <geekosaur> priority is access to the minimum. search is update/lookup by key
17:16:24 <EvanR> now im wondering what a non-search priority queue is
17:16:30 <EvanR> oh
17:17:27 <davean> EvanR: Think Data.Map, with priority on keys and fast access to the lowest priority
17:20:58 <davean> It definately makes my list of "Things I'm shocked people don't know about and really should" regularly.
17:28:55 <exio4> how do I tell stack install to only use one thread?
17:29:24 <MarcelineVQ> -j1
17:30:19 <exio4> oh, alright
17:30:36 <exio4> I feel a bit dumb now, it wasn't in the direct --help :P
17:30:44 <MarcelineVQ> yes it is :>
17:31:45 <MarcelineVQ> well fair enough, it's in stack --help
17:32:10 <exio4> yeah, I naively checked just stack install --help (and didn't read the last line)
17:32:41 <MarcelineVQ> note, because it'll come up eventually, that stack install is just  stack build --copy-bins
17:33:27 <MarcelineVQ> not too relevant here, but it will come up.  quite a few stack commands are just aliases to other commands
17:34:17 <exio4> ah, thanks for the info
17:54:35 <buhman> I saw some code doing: getSum (foldMap f things)
17:54:49 <buhman> this seems like it's probably the same thing as: sum (map f things)
17:55:11 <buhman> why would the former be preferred?
17:56:14 <EvanR> depends on what things is
17:56:29 <EvanR> a list or a non list or maybe maybe not a list
17:57:25 <geekosaur> or maybe when f is more clearly expressed as a monoid
17:57:29 <geekosaur> or more reusable
17:57:56 <EvanR> its getSum so that kind of nails down what f does
17:58:18 <srid> The empirical evidence that static typing improves code quality is thin, really? https://twitter.com/timperrett/status/957493915937943554
17:59:08 <buhman> I feel like I don't completely understand what monoids are; is there something that explains this in a way someone with an IQ of less than 160 can understand?
18:00:03 <geekosaur> they're dead simple, really. a combining operation with an identity. it's their generality that makes them interesting: there are large classes of things that can be expressed generically in terms of such operations
18:00:11 <buhman> I've seen Sum used before, but it seemed like magic to me
18:00:26 <geekosaur> addition with 0, multiplication with 1, list concatenation with [], etc.
18:00:38 <EvanR> srid: i can imagine people en mass feeling that way after being stuck in java and then the state-of-the-art-in-the-field scala for too long
18:00:52 <EvanR> or type script
18:01:34 <buhman> geekosaur: so, mempty for a Sum monoid evaluates to 0 ?
18:01:37 <EvanR> or the case of clojure, the type systems built on that, even if they work, not gaining much because clojure programmers are already good enough to be thinking about types
18:01:41 <geekosaur> and Sum kinda obscures things a bit, because numbers are (formally) based on two monoids ( ((+),0) and ((*),1) )
18:02:02 <geekosaur> so we can;t pick one and call it *the* monoid, and have to use Sum and Product wrappers instead
18:02:30 <Welkin> I don't need any reason to use haskell other than "I enjoy it"
18:02:37 <Welkin> regardless of any arguments for or against it
18:02:44 <Welkin> that is how most people are about their language of choice
18:03:03 <Welkin> you can't debate them into your point of view
18:03:53 <EvanR> essentially, youre abstaining from any language debate
18:04:21 <Digit> not as much as us lurkers.    (oops, i spoke, breaking lurk)
18:05:14 <EvanR> lets have an abstaining contest
18:05:50 <Welkin> EvanR: I'm just tired of it all
18:05:59 <Welkin> like I grew tired of religious debates
18:06:15 <Welkin> I just let it be and move on with life
18:06:46 <EvanR> one of haskells greatest strengths i think is to give us a stepping stone to the next (700?) language(s) by identifying what haskell has done wrong
18:07:50 <EvanR> at least the things well never see ghc fix
18:08:41 <Welkin> > fix error
18:08:44 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
18:09:46 <lavalike> that looks like the opposite of fixing an error
18:09:58 <EvanR> because the things popular languages have done wrong 1 probably arent considered wrong and 2 haskell fixed
18:10:49 <EvanR> so for that purpose theyre useless
18:33:17 <dugz> Hello, I've started studying Haskell. Thought I would ✓ in
18:34:35 <dugz> Right now, no questions. Mind still blown
18:35:22 <byorgey> dugz: welcome!
18:35:35 <dugz> :D
18:35:53 <byorgey> dugz: when you do have any questions this is a good place to ask.
18:36:58 <dugz> byorgey, I'm still in the larval stage with Haskell, but I am on freenode so I will keep you guys as a resource
18:39:16 <byorgey> dugz: sure, everyone has to start somewhere =)
18:39:23 <exio4> dugz: enjoy the trip, your brain will not like it at first, but it's worth it :)
18:39:51 * Digit thinks dugz passed that phase early, now on honeymoon
18:40:45 <ski> @quote head.explodes
18:40:45 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
18:44:31 <d-fish> I have a question about stack dependencies from github.
18:44:37 <d-fish> I'm trying to include hash-graph
18:44:41 <d-fish> https://github.com/patrickdoc/hash-graph/blob/master/examples/Basic.hs
18:45:01 <d-fish> My stack.yaml includes (https://imgur.com/a/EAfTE). package.cabal looks normal
18:45:18 <d-fish> But I can't import Data.HashGraph in ghci
18:48:56 <dugz> Digit, honeymoon lol, yep I drank the kool-aid
18:50:17 <jle`> d-fish: what is the error?
18:50:39 <jle`> d-fish: also, did you add hash-graph to your project dependencies?
18:50:48 <jle`> in your cabal file?
18:51:03 <jle`> your stack.yaml only specifies where to find things if you need them
18:51:11 <jle`> but it doesn't actually define what your project depends on
18:52:36 <d-fish> My setup: https://i.imgur.com/LaDyVyn.png
18:52:51 <d-fish> stack.yaml on the left, cabal on the right
18:52:57 <d-fish> shell on top
18:53:13 <jle`> try stack install or stack build first maybe?
18:53:55 <d-fish> same error
18:54:37 <d-fish> Using stack verison 1.6.3
18:59:15 <d-fish> Should the git url be in extra-deps instead of packages?
19:00:19 <MarcelineVQ> yes
19:00:31 <MarcelineVQ> https://docs.haskellstack.org/en/stable/yaml_configuration/#local-file-path
19:00:40 <nisstyre> anything extra means not managed by stack
19:00:47 <nisstyre> so a git repo by definition would not be
19:01:05 <ReinH> d-fish: I think you need extra-dep: true
19:01:34 <ReinH> Ah, MarcelineVQ is right
19:02:22 <MarcelineVQ> you can use extra-dep: true along with the '- location:'  but it's preferred to use the extra-deps section now
19:03:33 <MarcelineVQ> http://lpaste.net/362041
19:05:55 <d-fish> With that in extra-deps, do I add `hash-graph` to the cabal file?
19:06:57 <MarcelineVQ> yes, all the stack.yaml is for is letting stack know where to get things, if you want to use those things you still need to mention them in your cabal file
19:07:32 <MarcelineVQ> https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/
19:11:48 <d-fish> I'm still getting weird build errors
19:11:50 <d-fish> https://i.imgur.com/bFAXMvZ.png
19:12:05 <d-fish> I've got the extra-deps from the pastebin, added hash-graph to build-depends
19:14:08 <d-fish> lts-9.8
19:15:43 <MarcelineVQ> looks like it's saying hash-graph needs a newer base version, the only way to use a newer base version with stack is to use a newer resolver.
19:16:03 <d-fish> I'll try with 10.4
19:26:21 <d-fish> It worked! Thanks!
19:26:42 <d-fish> (10.4 took a long time to build)
19:58:34 <joe1> Any recommended ways of users (ie not developer) modifying parsers?
19:58:56 <jle`> whart sort of parsers do you mean? (and what sort of modifications?)
19:59:14 <joe1> ie I want to be able to extract some data from a line, but want the user to be able to specify how to get at the data
19:59:25 <joe1> At the moment I'm using attoparsec
19:59:49 <joe1> but am considering having a user supply a regular expression to match and extract the bit they care about
20:00:00 <jle`> usually i think you'd want to make an ADT that covers all of the ways you can modify a parser
20:00:02 <jle`> and then parse that adt
20:00:53 <joe1> thought (was worried) that might be the answer
20:01:20 <joe1> so it seems it is either monadic parsers at compile time or regular expressions at run time
20:01:32 <monochrom> Yes I would try taking a regex from the user too.
20:01:36 <joe1> unless I create my own parse descripter
20:02:11 <jle`> regex is technically a standardized parse descriptor i suppose
20:02:27 <joe1> thanks - at least users will be familiar with regexes (or be able to read plenty of docs)
20:03:23 <kadoban> For a standardized descriptor, it's not super standardized though. I seriously never guess right what syntax I'm in with regex
20:03:46 <jle`> same, i can never remember what the current parser is expecting me to escape, heh
20:03:56 <jle`> but that's probably because i jump between so many different ones so often
20:04:09 <monochrom> But you can design any language to replace regex, and you can dynamically translate it to an attoparsec parser. Afterall an attoparsec parser is a value too.
20:04:34 <joe1> I'd rather avoid it (designing a language) if I can :)
20:05:57 <jle`> when you have a haskell hammer, everything looks like a chance to design a language
20:06:04 <joe1> :)
20:06:06 <MarcelineVQ> all roads lead to rome
20:06:20 <kadoban> All roads lead to some weird EDSL
20:07:39 <monochrom> Naw, but every value looks like a value certainly.
20:08:04 <monochrom> A function is a value. An IO action is a value. A parser is a value.
20:08:28 <monochrom> And all of them look like backed by Turing-completeness.
20:08:35 <joe1> is anyone aware of a regex implementation in haskell with named groups?
20:08:46 <joe1> I've found https://stackoverflow.com/questions/3070251/regex-capturing-named-groups-in-a-language-that-doesnt-support-them-using-a-met
20:09:02 <monochrom> w00t named groups. Never thought of that.
20:09:03 <joe1> but that is 7 years old and hopefully something has evolved since then
20:23:56 * dugz can haz haskell hammer?
20:25:19 <dugz> actually, i have this python space sim, i was drooling over re-implementing the universe server in haskell
20:26:27 <dugz> lotta matrix math though
20:28:34 <dugz> but haskell could do infinite proceduraly generated stuff on the fly with built-in operations. Wow!
20:29:12 <dugz> No Mans Sky &c
20:30:42 <dugz> lazy evaluation so unused systems only update every 1k ticks or something while areas with space wars going on get the main focus. sounds good
20:31:52 <dugz> right now, the game is all about the math. there is a crude UI to test things
20:32:57 <dugz> I found that 5000 star systems was about the most Python could handle the last time I tested that.
20:33:36 <dugz> I would wager haskell could nail this
20:34:15 <kadoban> Sounds like something fun to try at least
20:34:25 <dugz> I sure do ramble on. Sorry lol
20:34:40 <kadoban> If it's anything like no man's sky sounded, it'll have to be more fun to program than it is to play
20:34:44 <dugz> kadoban, yeah I have a goal
20:35:22 <dugz> right now, the program is correct.
20:36:20 <dugz> it will run for hours or days, it never loses track of its brains unless you fly outside the range of a double
20:36:53 <dugz> never tried it actually
20:37:35 <dugz> i think the game uses meters
20:37:54 * dugz blow off the dust
20:48:47 <dugz> Anyways, we'll see.
20:59:39 <dmwit> So, there's a question on StackOverflow that I put an answer to, but I don't actually know the full story. Maybe somebody hanging around here does.
20:59:54 <dmwit> The definition of CAF mentions that there can be no free variables. What is a free variable?
21:00:03 <dmwit> In particular: is, say, Data.Map.fromList free?
21:05:16 <geekosaur> isn;t that just the formal way of saying it has no parameters?
21:06:03 <geekosaur> fromList surely is not free; it's bound in an outer scope
21:06:27 <geekosaur> (or possibly the same scope)
21:09:26 <dmwit> Aren't free variables exactly the ones you have to look up in your scope (instead of getting them by dropping under a lambda)?
21:10:56 <geekosaur> I don't think Haskell actually has "free variables" in the mathematical sense, which is why I am assuming it means parameters
21:11:22 <geekosaur> "implicit forall" might be more accurate
21:11:29 <ski> (the mathematical sense ?)
21:12:16 <dmwit> I am reviewing the definition of a supercombinator. It appears to demand that each lambda abstraction refer only to variables bound in that lambda, and never to outer ones.
21:12:50 <dmwit> This seems to rule out using e.g. fromList and still calling yourself a supercombinator.
21:13:02 <MarcelineVQ> when you ask about fromList  do you mean fromList  or  fromList x
21:13:03 <ski> i think `\x -> \y -> x' would also count as a supercombinator
21:13:13 <dmwit> But my intuition is very much that fromList [...] is suitable for use as a CAF.
21:13:21 <dmwit> ski: Yes, adjacent lambda abstractions are coalesced.
21:13:33 <ski> well, say `\x -> (x,\y -> x)', then
21:13:42 <dmwit> ski: (In the definition I'm looking at, at least.)
21:13:53 <dmwit> ski: Right, I believe that does not qualify as a supercombinator.
21:14:09 <ski> i think it does, unless i'm mistaken
21:14:16 <dmwit> At least by my reading of https://wiki.haskell.org/Super_combinator
21:14:28 <ski> it doesn't refer to any variables bound outside this expression
21:14:44 <ski> (even though it contains a lambda expression which does refer to a variable bound outside of it)
21:14:49 <dmwit> Yes, but `\y -> x` is a subexpression and not a supercombinator.
21:14:58 <ski> yes, i think that's ok
21:15:15 <dmwit> "A supercombinator is either a constant, or a combinator which contains only supercombinators as subexpressions."
21:16:10 <MarcelineVQ> then what of +
21:16:14 <dmwit> Wikipedia appears to agree on this point.
21:16:53 <MarcelineVQ> \x y -> x + y is called a supercombinator here but + isn't one of the arguments
21:17:16 <dmwit> MarcelineVQ: My question precisely.
21:18:15 <dmwit> This goes even back to SPJ's Implementation of Functional Programming Languages, which gives a CAF example with + (or maybe -, I can't recall exactly now) appearing free.
21:19:13 <ski> hm, ok. seems i was probably confusing it with the ability to turn into a supercombinator, through lambda-lifting
21:19:43 <ski> (perhaps `(+)' isn't counted, because (assuming no constrained polymorphism) it's bound at top-level)
21:21:58 <MarcelineVQ> or because it's been applied and doesn't have arguments or free variables due to that, which is why I was aking about fromList vs fromList x above
21:29:25 <ski> hm, i suppose if `fromList' is a supercombinator, then `\x -> fromList (..x..)' can be lambda-lifted to `(\f x -> f (..x..)) fromList'
21:40:52 <parsnip> i'd like to do things like fill .txt, .tex, .html templates with resume data, say from yaml. currently doing it with jinja2 and a little python scripting. i see haskell has some jinja2-likes such as gunger, but is there a haskell solution i'm not thinking of?
21:41:06 <parsnip> *ginger
21:43:33 <parsnip> if it ain't broke, don't fix it... there's a jinja2 related library for docx i can make good-enough word resumes with.
21:46:08 <parsnip> hmm, might be fun to learn to call python libraries from haskell
21:47:02 <dmj`> parsnip: there’s mustache, blaze-html, lucid, heist, maybe something in pandoc could be of use
21:47:10 <dmj`> hastache*
22:17:22 <ratzes> Hi, had a question, i'd like to develop an app and be able to pass in a lambda function as a string into the app to generate a vector field for a bunch of points of that function. What's the best way to do this?
22:18:23 <glguy> Write a parser for the language you want to accept for defining the vector fields and then use that.
22:19:08 <glguy> To use Haskell directly as your input language you could link against GHC directly, the hint package is a easier way to start there
22:19:11 <glguy> ?hackage hint
22:19:11 <lambdabot> http://hackage.haskell.org/package/hint
22:19:37 <ratzes> Yeah, i thought about that, but thought it might be nice to be able to leverage the offered functions in haskell
22:20:33 <ratzes> so i read about that, but apparently it's all done in the interpreter?
22:21:04 <jle`> ratzes: remember that haskell is a compiled language, so the only way to actually interpret a string as a haskell function is to basically carry around the entire ghc
22:21:21 <jle`> ghc compiles haskell to efficient/short c code that does only exactly what is needed
22:21:37 <jle`> but if your haskell code has to interpret haskell code, ghc basically has to include itself in what is compiled
22:21:50 <jle`> or else have ghc be a part of the runtime/program itself
22:22:44 <ratzes> are there other ways to do that? than plugins or hint?
22:22:51 <ratzes> *other than
22:23:10 <jle`> ratzes: you can actually include ghc as a library
22:23:30 <jle`> so basically compiling your program involves compiling all of ghc into your executable, plus the rest of your program
22:24:01 <jle`> but this is probably not a practical solution
22:24:24 <Cale> jle`: It's been many years since GHC was able to compile to C code (and even when it did, it didn't produce working C code, it produced stuff whose assembly output would be further mangled into working programs)
22:24:25 <ratzes> gotcha, was just going to ask if it was as slow as just emitting dynamic haskell code and compiling with stack lol
22:24:34 <jle`> this is fundamentally different from, say, javascript or python
22:25:02 <jle`> Cale: thanks for clarifying! :)
22:25:17 <jle`> ratzes: in javascript or python or ruby or another interpreted language, it's trivial to have an "eval" function
22:25:30 <jle`> since every time you are running js, you have the full js interpreter at your disposal
22:25:49 <jle`> but it's different in a compiled language, where you usually run your code without the compiler itself available
22:26:11 <Cale> (GHC targets assembly code for x86 and a bunch of other machine architectures, and also has an LLVM backend)
22:26:53 <jle`> ratzes: one thing you can do would be to interpret your code as a stack script or using ghc, as a part of a shell script, and use stdin/stdout
22:26:59 <ratzes> gotcha, now that you mention llvm, i know the accelerate library does some strange dynamic compilation to llvm
22:27:01 <jle`> if you want to avoid working with the actual GHC api
22:27:32 <Cale> Using GHC as a library via hint or something isn't necessarily totally impractical. Your executable will be a bit large, but it should work okay, and probably won't be too slow.
22:28:29 <ratzes> good to hear, ill try to take a stab at it
22:28:55 <ratzes> what if you got the function as an argument from the command line? Would template haskell help? Dont have any experience using it
22:29:03 <jle`> might be slightly overkill though depending on what you are really using it for
22:29:09 <glguy> No, Template Haskell is a compile time feature
22:29:34 <jle`> if all you're doing is rendering vector fields, you might not really want all of haskell at your disposal
22:29:34 <glguy> command line arguments are post compile time, these are values like any other
22:30:05 <ratzes> gotcha
22:31:02 <ratzes> im going through this non linear dynamics book, thought it might be cool to inject the differential equations in to the haskell accelerate-examples fluid sim
22:31:39 <ratzes> so it might be best to just write my own parser and add sin, cos etc
22:39:13 <jle`> it might actually be neat to have a library that can parse simple math things into an adt
22:42:16 <dmwit> ratzes: You might like to look at Jupyter/IHaskell or at dyre. In either case you would do an inversion of control trick: instead of asking the user for code and compiling/calling it from your executable, you provide your code as a library and let the user call it from *their* executable.
22:43:08 <dmwit> And in particular part of your library would be a top-level "render this fun vector-y thing to screen for me" function.
22:45:03 <dmwit> s/be/have/
22:59:36 <robstr> morning
23:04:22 <robstr> In haskell from first principles on page 665, is a newtype Constant a b = Constant { getConstant :: a} and I should write a functor and applicative instance. Functor was ok *i think* with instance Functor (Constant a) where fmap f (Constant x) = Constant x but on the applicative part, the pure function has shape a -> f a in this case a -> Constant e a, where the a part will be ignored , is my understanding here correct
23:04:22 <robstr>  ?
23:05:55 <ski> sounds ok
23:08:15 <kadoban> robstr: Are you sure you're supposed to write an Applicative instance? Sounds hard
23:08:54 <jle`> i mean, it's page 665
23:09:05 <jle`> so i'm assuming it's from one of the more advanced parts of the book :)
23:09:26 <kadoban> I mean, it sounds hard in the sense that it sounds impossible, but I don't like to say that in haskell because I end up wrong a lot :)
23:09:26 <jle`> fwiw it's one of my all-time favorite Applicative instances :)
23:09:34 <robstr> yes, This is the task
23:09:43 <kadoban> Unless you're supposed to have a constaint on the instance?
23:09:51 <jle`> ah yes it is not possible for all a's
23:09:53 <robstr> but I have no idea how to create this instance because i dont know the type
23:10:03 <jle`> but it's possible if you constrain a with something relevant
23:10:08 <kadoban> Oh okay
23:10:18 <robstr> i should return Constant e a - but i only new a
23:10:24 <jle`> robstr: you can start by just trying to make the types match up
23:10:30 <jle`> what should go in a 'Constant e a'?
23:10:34 <jle`> (hint: it's not an 'a')
23:12:01 <robstr> yea and this is exactly my problem, because of the definition pure :: a -> f a with F beeing already Constant a
23:12:19 <jle`> robstr: yes, you need an 'e', so this is not possible for all e's
23:12:29 <jle`> i hope the book might tell you that you need to constrain 'e' somehow
23:12:37 <ski> (`f' being `Constant e')
23:12:43 <MarcelineVQ> jle`: it does
23:12:45 <robstr> how is this possible to get it ?
23:12:49 <robstr> t all
23:12:52 <robstr> at
23:13:00 <jle`> robstr: does the book tell you any constraints on 'e' ?
23:13:12 <robstr> yes
23:13:16 <jle`> what are they, if any?
23:13:18 <robstr> it needs to be a monoid
23:13:26 <jle`> okay, so 'e' has a Monoid instance
23:13:26 <robstr> instance availible
23:13:33 <robstr> oh with mempty
23:13:37 <jle`> and what do you need to create a value of type 'Constant e a' ?
23:13:42 <jle`> you can use the Constant constructor
23:13:49 <jle`> `Constant { getConstant = ????? }`
23:13:57 <jle`> and you need to put something of type 'e' in the ?????
23:14:06 <jle`> what values of type 'e' do you have available?
23:14:16 <robstr> mempty
23:14:20 <jle`> yup, that's the only one
23:14:28 <jle`> since mempty <> mempty, etc. are all equivalent to mempty
23:14:55 <robstr> ha
23:15:13 <robstr> so the solution is: pure _ = Constant { getConstant = mempty }
23:15:30 <ski> (or just `Constant mempty', not using record notation)
23:15:39 <robstr> Its the first time i write something in the record syntax
23:15:41 <jchia> I find that "stack build" with and without '--ghc-options -j3' have almost no difference in build time for my project (<10%). Even after adding '+RTS -A2048M -RTS' to '-'j3', there's no improvement. Is my experience typical?
23:15:54 <jle`> robstr: yeah i probably wouldn't use record notation there
23:16:04 <robstr> wow, thank you
23:16:06 <jle`> i only used it to distinguish 'Constant' the data constructor from 'Constant' the type
23:16:19 <robstr> now this makes sense
23:16:24 <MarcelineVQ> jchia: -j only really matters for building dependencies afaik
23:16:28 <jle`> since they have the same letters in their name for some reason
23:16:31 <robstr> *until the next point ;P *
23:16:43 <MarcelineVQ> jchia: I should check before I say that though, sec
23:17:01 <robstr> Thank you really much
23:17:11 <glguy> Have you implemented (<*>) yet?
23:17:13 <jchia> I see that with -j3, ghc can use > 100% CPU, but there's almost no improvement in speed.
23:17:22 <robstr> no,I'm trying right know
23:20:37 <MarcelineVQ> jchia: Tough to say because I'm not sure how much of the job stack takes over, according to the manual with basic ghc --make  "If ⟨n⟩ is omitted, then it defaults to the number of processors."
23:23:20 <MarcelineVQ> not sure how related things that apply to --make and stack are at all :X
23:24:23 <robstr> @glguy: (<*>) (Constant x) _ = Constant x
23:24:23 <lambdabot> Unknown command, try @list
23:24:28 <robstr> glguy: (<*>) (Constant x) _ = Constant x
23:24:41 <robstr> whups
23:30:13 <MarcelineVQ> jchia: if it's any consolation -stack build --ghc-options -j9   built containers in 35s   and  stack build did it in 48s
23:30:36 <MarcelineVQ> so matters but I suspect you need an awful lot of modules for it to matter much
23:32:27 <MarcelineVQ> containers has 28 modules
23:35:30 <phadej> dmwit: ping
23:58:04 <glguy> robstr: that's incorrect, doesn't satisfy the laws required of applicative
23:58:19 <ertes-w> hell
