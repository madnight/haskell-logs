00:01:34 <dminuoso> epicallan: Also if you want to specifically create pairs, you might be interested in using (,) rather than []
00:04:56 <parsnip> epicallan: what is the type of head?
00:06:55 <epicallan> Thanks for the help, so far. head :: [a] -> Maybe a
00:07:13 <epicallan> I will switch to (,)
00:07:20 <parsnip> is that the standard `head`?
00:07:25 <epicallan> yes
00:08:09 <parsnip> i'm seeing http://hoogle.haskell.org/?hoogle=head
00:08:13 <dmwit> :t head
00:08:14 <lambdabot> [a] -> a
00:08:49 <parsnip> http://hoogle.haskell.org/?hoogle=%5Ba%5D+-%3E+Maybe+a&scope=set%3Astackage
00:11:01 <parsnip> epicallan: notice the error message seems to be inferring that pairUp has type [Maybe a] -> [Maybe a]. not that's it's obvious to me how to reason from there, but, it's a good habit to read through the error message.
00:12:06 <dminuoso> epicallan: Note that you can pattern match not only the head, but multiple things..
00:12:29 <dminuoso> epicallan: i.e. you can use [a,b] or (x:y:xs) to match and bind against more than just one thing.
00:29:15 <dminuoso> I've come up with: `pairUp (x:x':xs) = (:) <$> pure (x,x') <*> pairUp xs` is there a cleaner or more haskellish way to this?
00:29:47 <dminuoso> i.e. https://gist.github.com/dminuoso/056da075280084b8db2854c8f8193194
00:31:12 <Hafydd> dminuoso: why not just "pairUp (x : x' : xs) = (x, x') : pairUp xs"?
00:31:52 <parsnip> or pairUp (x:y:ys) = [x, y] : pairUp ys
00:32:18 <tdammers> parsnip: that doesn't build lists of tuples though
00:32:22 <dminuoso> Hafydd: Because I want to handle odd lists.
00:32:43 <parsnip> well, then what do you do now with odd lengthed lists?
00:32:51 <dminuoso> parsnip: I produce Nothing
00:33:06 <parsnip> ah
00:33:26 <Hafydd> dminuoso: I see; well, you can at least write it as pairUp (x : x' : xs) = ((x, x') :) <$> pairUp xs.
00:33:28 <parsnip> dminuoso: for the whole list, or just that element?
00:33:43 <dminuoso> parsnip: Think about how it recurses. ;-)
00:34:14 <parsnip> dminuoso: i mean, "Nothing" is a thing in haskell.
00:34:15 <dminuoso> Hafydd: Right, I actually played with that, but using fmap explicitly seemed a bit more readable - seems a bit more idiomatic if I look at other peoples code
00:34:32 <dminuoso> parsnip: You could do either actually
00:34:37 <parsnip> so i wasn't sure if you want [1, 2, 3] to return [(1, 2)] or Nothing.
00:34:46 <Hafydd> dminuoso: if you think it's "more idiomatic" to unnecessarily use applicative operators, I fear you've misapprehended it.
00:35:04 <dminuoso> Hafydd: Oh. :o
00:35:07 <dminuoso> Hafydd: I see
00:35:13 <parsnip> dminuoso: oops, i got you mixed up with OP.
00:35:25 <parsnip> derp
00:35:35 <dminuoso> No I just looked it and wondered how I might tackle it. :)
00:36:06 <parsnip> i think we need postgres
00:36:35 <parsnip> and a data scientist
00:38:05 <mozzarella> is haskell fast?
00:38:19 <dramforever> Short answer: yes it is
00:40:02 <mozzarella> long answer?
00:40:17 <bartavelle> mozzarella: long answer : it depends on what you mean by fast :)
00:40:30 <opqdonut> can a language be fast?
00:40:46 <opqdonut> fast at what cost?
00:40:53 <mozzarella> its implementation(s) can
00:41:14 <opqdonut> you can definitely write fast code in haskell, and ghc is pretty good at optimizing stuff
00:41:19 <opqdonut> also the profiling tools are excellent IMO
00:41:28 <bartavelle> idiomatic haskell is *usually* on par with stuff like java (perhaps a bit slower, but uses less memory in my experience)
00:41:47 <bartavelle> just like java, you can optimize it a lot, but then it doesn't look idiomatic
00:42:19 <bartavelle> sometimes idiomatic programs are really slow too :)
00:43:25 <dramforever> mozzarella: You will never see people say directly 'Haskell is slow' here, tbh. Try yourself if you're interested
00:44:03 <bartavelle> short answer : performance is good, you can optimize it a lot, you can use C libraries very easily, but like all things, you can still manage to write slow programs
00:44:26 <epicallan> @dminuoso, thanks for your help
00:44:26 <lambdabot> Unknown command, try @list
00:45:06 <dramforever> Oh yeah almost forgot
00:45:07 <ertes-w> hllo
00:45:30 <dramforever> The ffi to C is like super easy to use
00:46:57 <ertes-w> dminuoso: do you really need to know upfront whether the list was even?
00:47:32 <ertes-w> because that forces the entire list into memory
00:47:39 <dminuoso> ertes-w: Huh?
00:47:48 <ertes-w> dminuoso: about pairUp
00:49:35 <dminuoso> ertes-w: Oh it wasn't my code originally. I just explored the idea shortly.
00:49:46 <ertes-w> ah
00:55:03 <[exa]> mozzarella: most languages aren't slow by design, but you need to put some effort into performance if you really want the program to run optimally
00:56:13 <Uniaika> and/or use C++
00:57:03 <capisce> even when using C++ you need to put effort into performance
00:58:21 <ertes-w> @let import Control.Monad.Free
00:58:23 <lambdabot>  Defined.
00:58:26 <ertes-w> @let pairUp xs = foldr (\x go f -> f (go (pure ($ x))) (\x' -> Free ((x', x), go pure))) (\f -> f (Pure True) (pure (Pure False))) xs pure
00:58:28 <lambdabot>  Defined.
00:58:43 <ertes-w> > map pairUp (inits [0..])
00:58:47 <lambdabot>  [Pure True,Pure False,Free ((0,1),Pure True),Free ((0,1),Pure False),Free ((...
00:59:57 <ertes-w> > pairUp [0..]
01:00:00 <lambdabot>  Free ((0,1),Free ((2,3),Free ((4,5),Free ((6,7),Free ((8,9),Free ((10,11),Fr...
01:01:07 <ertes-w> @let pairUp' xs = foldr (\x go f -> f (go (pure ($ x))) (\x' -> Free ((x', x), go pure))) (\f -> f (Pure Nothing) (Pure . Just)) xs pure
01:01:08 <lambdabot>  Defined.
01:01:12 <ertes-w> > pairUp' [1,2,3]
01:01:14 <[exa]> Uniaika: the only performance-wise advantage of C++ is it brings the memory management a bit closer to the programmer (so being a lazy programmer and putting stuff in vectors can easily translate to cache efficiency)
01:01:15 <lambdabot>  Free ((1,2),Pure (Just 3))
01:02:05 <ertes-w> it's actually quite possible to do cache-aware programming in haskell
01:02:24 <[exa]> also, C++ has a bit less implicit allocation and pointer jumping by default
01:02:27 <ertes-w> use dense data structures and pay attention to lifetime, strictness and boxedness
01:02:29 <dminuoso> ertes-w: Down to cache color friendly algorithms?
01:03:12 <ertes-w> dminuoso: what's cache colour friendliness?
01:03:18 <[exa]> ertes-w: the problem with standard data in Haskell is that you can't ensure they are placed in a reasonable way
01:03:47 <dminuoso> ertes-w: Are you familiar with how caches work wrt to associativity?
01:04:06 <ertes-w> [exa]: not globally, though you can't really ensure that in C++ either, unless you put everything on the stack and control it meticulously – or write your own allocator
01:04:24 <[exa]> ertes-w: btw there's blelloch's paper somewhere
01:04:28 <[exa]> http://www.cs.cmu.edu/~rwh/papers/iolambda-cacm/cacm.pdf
01:04:30 <ertes-w> dminuoso: i don't think so
01:05:34 <[exa]> ertes-w: the point is that 'vector' in C++ means vectorizable and easily alignable data; which doesn't quite compare with Array
01:06:41 <ertes-w> [exa]: yeah, i think the haskell answer to that is: "use the LLVM backend"
01:07:02 <ventonegro> All kinds of memory tricks are possible in C++: Small object optimization, custom allocators, copy on write, expression templates etc.
01:07:32 <[exa]> ertes-w: also a more "distant" array type (there are vectors afaik but I don't remember them)
01:07:49 <dminuoso> ertes-w: So normally you have a small number of cache lines say 0, 1, 2 and 3. Each memory address can be cached by the line indicated by address % 4. Now more sophisticated caches have multiple "slots" called "ways" per cache line. So if you frequently use memory addresses that are all aligned to the same line, you will cause high eviction rates.
01:08:10 <ertes-w> i remember DPH, but i don't think it really went anywhere and has been replaced by vector and repa
01:08:24 <[exa]> anyway, what I wanted to say-- do not underestimate speedups from correct memory placement; if you have a bit of data it can get to hundreds-times faster
01:08:47 <dminuoso> ertes-w: So cache friendly algorithms will try to spread memory addresses in a short region of code in such a way, that it spreads across many cache lines - ensuring that no single cache line is pressured.
01:08:54 <ertes-w> if you write vector-heavy code, there is potential for huge speedups by using LLVM, and also by actually using the repa library properly, which isn't quite as easy as it sounds
01:09:47 <ertes-w> dminuoso: i see
01:12:33 <ertes-w> the way i interpret most of this is: "we need a C++ FFI" =)
01:12:55 <dminuoso> ertes-w: and when I said "address" I actually meant "index" (since semantically an address consists of [tag,index,offset], where `index % line_amount` tells you which line to cache it in, and `offset` tells you which byte in the cache line you are interested in.
01:14:25 * [exa] wants an architecture where manual cache prefetch is mandatory
01:16:04 <ertes-w> anyway, GHC-produced vector code with the LLVM backend is really good…  i see no reason to resort to C++ just to squeeze out those last 5% at the expense of a lot of careful manual engineering
01:16:16 <ertes-w> if i need that kind of speed i FFI into a highly optimised foreign library
01:18:20 <ertes-w> and that one might well be written in C/C++ by people who enjoy that kind of engineering, so they're far better than i am at this =)
01:18:59 <[exa]> ertes-w: yeah that's what I wanted to say, you can get the cache-efficiency speedup in haskell if there's not a wrong runtime standing in your way (which obviously isn't with llvm)
01:19:21 <dminuoso> [exa]: manual cache prefetch has been really instrumental to Meltdown =)
01:19:22 <[exa]> btw is this vector-friendly behavior that you're talking about documented somewhere?
01:19:55 <[exa]> dminuoso: well if programs would need to fetch their own cache in advance, there would be no meltdown nor spectre
01:21:02 <dminuoso> [exa]: Huh?
01:21:07 <JuanDaugherty> linode is force updating all their machines for that
01:21:30 <ertes-w> i have a question about meltdown/spectre, but it's highly off-topic here, so i'll ask it in #haskell-offtopic =)
01:21:30 <JuanDaugherty> they did one this morning of mine
01:22:05 <merijn> ertes-w: A C++ FFI probably won't happen unless a big company pays for it, since C++ is a fucking mess
01:22:52 <Gregor01> Hi all!
01:22:53 <merijn> ertes-w: There's like 1 language that has a C++ FFI, I think? (iirc D has a C++ FFI)
01:23:00 <merijn> Literally everything else goes through C
01:23:25 <geekosaur> rakudo has one. a few others have played with it, but it has annoying shortcomings
01:23:31 <[exa]> merijn: you don't want to FFI the arch-specific name mangling :D
01:23:40 <geekosaur> like, you have to remember what requires actual compilation towkr because of e.g. templates
01:23:43 <geekosaur> *to work
01:24:15 <merijn> [exa]: If you don't do that, you can't FFI C++
01:25:04 <Gregor01> merijn: I guess D hasn't got a full interface to C++
01:25:21 <Gregor01> Ther is limited support to call C++
01:26:03 <Gregor01> Perhaps D's support is better than usual.
01:26:35 <Gregor01> https://dlang.org/spec/cpp_interface.html
01:26:53 <Gregor01> It mentions it can interface with some limitations such as "single inheritance"
01:27:40 <Gregor01> (but I was late to the party ... sorry)
01:28:24 <[exa]> merijn: I can't ffi C++ -> *whew what a relief!*
01:28:49 <Gregor01> What are you talking about?
01:29:03 <Gregor01> You write a C wrapper for the C++ code and call that in haskell
01:29:35 <geekosaur> single inheritance, probably limited support for vtables, the template issue I mentioned (if a template expansion already exists then it will work, otherwise name resolution will fail)
01:30:04 <Gregor01> C warpper: For easy stuff (Int array ==> Int result) that are ~2 lines of C code
01:30:19 <merijn> Gregor01: Right, which is NOT the same as calling C++
01:30:31 <merijn> Gregor01: Since you lose access to constructors, RAII, etc.
01:31:03 <merijn> Anyway, there's basically no reasonable way to call C++ from *any* language other than C++ (and even then it can be brittle!)
01:31:17 <Gregor01> merijn: yes, well put!
01:31:37 * hackage ocaml-export 0.5.0.0 - Convert Haskell types in OCaml types  https://hackage.haskell.org/package/ocaml-export-0.5.0.0 (mchaver)
01:32:06 <Gregor01> My question would be.... Is there something slightly more high level than 'wrap server' for writing a toy REST service?
01:32:15 <merijn> On the upside, Haskell probably has the easiest C FFI of any language, except C++ :)
01:32:35 <Gregor01> Or is there only "yesod" server as the next higher thing?
01:33:02 <Gregor01> Basically, I need "serialized numbers in" ==> "serialized numbers out" for my rest server
01:34:09 <merijn> Gregor01: There's a whole bunch of web frameworks: Servant, scotty, yesod, etc.
01:34:16 <merijn> I haven't used any of them, though
01:35:04 <Gregor01> The general recommendation of those was (on reddit and co) to use yesod.
01:35:23 <merijn> Gregor01: That depends a lot on who's responding on reddit :p
01:35:27 <merijn> Yesod is rather polarising
01:35:52 <merijn> It uses a lot TH and is generally rather opaque and monolithical (in terms of ecosystem)
01:36:08 <merijn> Many people don't like many aspects of the design of Yesod
01:37:03 <Gregor01> The upsides are: has a book, has a guy that often responds very quicky, perhaps scales good with wrap (my guesses)
01:37:41 <danza> it's opinionated. that can be both an advantage or a disadvantage. it generally depends on the horizon of your project
01:38:16 <danza> if it's a project that has to go far, better to start from an API endpoint and a microframework
01:38:31 <danza> if it's an experiment with reduced scope, no risks in using Yesod
01:38:56 <Gregor01> it's a toy project in research. I mainly need a demo in 2 weeks.
01:40:08 <merijn> Personally I find's Yesod constraint and monad-stack mismash leads to type signatures that are incredibly opaque and hard to understand, which ruins like 70% of the reasons I use Haskell
01:40:09 <danza> if it's frontend-intensive, better use Haskell only for the API
01:43:17 <danza> the model for Yesod are web apps rendered on the server side. haven't developed a web app like that in ages
01:44:03 <danza> i don't see reasons for that. using Django one can design the data model early with the client due to the admin interface, but what does Yesod offer over a simple Postgres+WhicheverClient?
01:44:37 <danza> sorry i ment Postgrest, the database-API bridge
01:44:39 <carbolymer> jewish blessings over your code
01:44:44 <Gregor01> A good language, sane people that inplement libs?
01:45:12 <danza> yeah all of that would go into an API nowadays i think
01:45:14 <Gregor01> also scalability, I guess
01:46:07 <Gregor01> Are there any dynamically typed languages implemented in Haskell?
01:46:31 <Gregor01> The problem is my end thing will be dependently typed and I don't want currently to write dependent Haskell
01:46:31 <merijn> Gregor01: The first Perl6 implements was being written in Haskell, so yes? :p
01:46:37 * hackage mono-traversable 1.0.8.1 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-1.0.8.1 (MichaelSnoyman)
01:46:44 <merijn> Gregor01: So use Idris? ;)
01:46:46 <Gregor01> merijn: I know!! so sad that it was discontinued
01:47:14 <Gregor01> Yes, but need easy Haskell FFI. I guess Idris doesn't have that.
01:47:26 <merijn> "I know Haskell but want dependent types!" is like the literal exact target audience Idris is being designed for :)
01:47:32 <Gregor01> I was thinking about 'morte' bare bones dependently type language
01:47:57 <ertes-w> Gregor01: i'm a fan of scotty for REST stuff
01:48:08 <ertes-w> it's just the right abstraction level
01:48:12 <Gregor01> merijn: I'm a Agda user sorry ;) I really like Idris very much!!
01:48:27 <ertes-w> Gregor01: disclaimer: i haven't tried servant yet
01:49:05 <Gregor01> So on the dynamic langauge implementations in Haskell there is shonky, husk scheme and a python implementation.
01:49:16 <Gregor01> Is there any experience with those? Did I forget one?
01:49:42 <Gregor01> other wise there are typed/untyped LC (STLC...)
01:49:49 <Gregor01> https://github.com/pigworker/shonky/
01:50:05 <Gregor01> https://hackage.haskell.org/package/morte
01:50:34 <ventonegro> Gregor01: It's easy to write an Idris backend though, so you could write a Haskell one :)
01:50:36 <Gregor01> Morte seems to be a bit too low level... so my hack was to use briefly a dynamic language in haskell.
01:50:39 <ertes-w> more like: "i know haskell, but i'd prefer strict by default, and i want dependent types"
01:50:52 <ventonegro> There is even an Idris backend for Vimscript
01:51:02 <Gregor01> ventonegro: I love the way Idris does the backends.
01:51:06 <ertes-w> some find the default evaluation strategy of idris undesirable, me included =)
01:51:33 <Gregor01> I probably have custom hardware availiable and the first thing will probably be an Idris backend for that
01:52:05 <ventonegro> Gregor01: That sounds interesting... Please post the results to r/idris :)
01:52:55 <Gregor01> ventonegro: Yes, I could. Basically its a reconfigurable logic ASIC
01:53:28 <Gregor01> In theory it can do a few complex operations (such as searching in an array) in O(1)
01:53:58 <Gregor01> It will be perhaps a 60 nano meter waver design
01:55:23 <Gregor01> ventonegro: What are the next best involved people in Idris after Edwin Brady?
01:55:43 <Gregor01> I guess Edwin has limited interest because he has so many things going on.
01:56:03 <Gregor01> ventonegro: I mean for backend research...
01:56:57 <ventonegro> Gregor01: I don't know... Maybe you'll have better luck asking in #idris
01:58:06 * hackage llvm-hs-pretty 0.2.0.0 - Pretty printer for LLVM IR.  https://hackage.haskell.org/package/llvm-hs-pretty-0.2.0.0 (sdiehl)
02:03:10 <badambam> Is there a OpenGL binding for Haskell?
02:03:51 <merijn> badambam: Multiple :p
02:04:07 <merijn> badambam: I think the most complete (albeit low level) one is edwardk's "gl" package?
02:04:21 <merijn> @hackage gl
02:04:21 <lambdabot> http://hackage.haskell.org/package/gl
02:04:32 <badambam> cool
02:04:33 <badambam> thanks
02:05:00 <ertes-w> badambam: if you're looking for something higher-level check out GPipe and luminance
02:05:22 <badambam> i want to learn opengl
02:05:29 <badambam> So probably low level stuff is good for now
02:05:41 <badambam> but GPipe is interesting
02:06:15 <ertes-w> badambam: then definitely go with 'gl'…  it's the most direct mapping of the OpenGL API we have, to the point where you can follow tutorials for other languages and translate everything 1:1
02:06:33 <badambam> nice
02:06:47 <ertes-w> badambam: reason is that 'gl' isn't written by hand, but generated from the specs
02:20:37 * hackage wreq-stringless 0.5.9.0, wreq-stringless 0.5.9.1 (jkeck): https://qbin.io/d8kdmng
02:58:36 * hackage packman 0.4.0 - Serialization library for GHC  https://hackage.haskell.org/package/packman-0.4.0 (JostBerthold)
03:09:26 <kahlil29> does it make sense to replace `sequence $ Data.List.map` with `mapM` ? Would the behaviour remain the same?
03:09:34 <opqdonut> yes
03:09:41 <opqdonut> @src mapM
03:09:41 <lambdabot> mapM f as = sequence (map f as)
03:11:15 <ertes-w> kahlil29: use 'traverse' instead of 'mapM'
03:11:56 <kahlil29> ertes-w : my linter had suggested mapM. So traverse would give me the behaviour of `sequence $ map` ?
03:12:22 <ertes-w> kahlil29: 'mapM' is the historical-mistake version of 'traverse'…  they are the same function
03:12:25 <opqdonut> :D
03:12:29 <kahlil29> opqdonut: thanks
03:17:21 <kahlil29> ertes-w : thank you :)
03:22:33 <[exa]> ertes-w: is there some semantic hint that I can use to remember 'traverse' quicker than 'mapM' ?
03:37:49 <merijn> Honestly, I don't really agree with that advice anyway
03:37:55 <merijn> mapM is often more intuitive to read
03:39:15 <jchia_> What should I do if I want Eq and Ord instances for tuples of more than 16 elements?
03:39:20 <sanitymug> more intuitive maybe, but less generic… depends what you want. Anyway, use your best judgement
03:39:55 <merijn> jchia_: Either implement them by hand, or preferably reconsider wtf you're doing that requires 16 element tuples
03:39:56 <sanitymug> jchia_: tuples of more than 16? do you need that many?
03:40:00 <nullie> :t traverse (undefined :: IO)
03:40:02 <lambdabot> error:
03:40:02 <lambdabot>     • Expecting one more argument to ‘IO’
03:40:02 <lambdabot>       Expected a type, but ‘IO’ has kind ‘* -> *’
03:40:43 <jchia_> sanitymug: Some TH mechanism to workaround the lack of row polymorphism
03:41:03 <merijn> jchia_: So use an HList and implement Eq/Ord for that?
03:41:03 <jchia_> merijn: Does that mean orphaned instances?
03:42:37 <merijn> jchia_: Any row polymorphism style approach is probably better solved by HList anyway.
03:42:46 <jchia_> merijn: Not familiar with that. The haddock is broken. https://hackage.haskell.org/package/HList
03:43:00 <merijn> jchia_: I didn't necessarily mean that package
03:43:21 <merijn> jchia_: Just any heterogeneous list approach, like: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
03:43:52 <merijn> jchia_: As you can see, that one even comes with an example Show implementation you can use as inspiration for Eq/Ord :)
03:46:21 <jchia_> merjin: How do I understand the "data HList :: [*] -> *"?
03:47:13 <jchia_> You give HList a type-level list of types of kind '*' and you get back a type of kind '*'?
03:47:22 <merijn> HList is a type constructor with kind "[*] -> *" i.e. it takes a type of kind '[*]' and returns a type. The kind [*] represents a type level list of types of kind *
03:47:27 <merijn> jchia_: Right
03:47:40 <merijn> jchia_: See some of the examples on line 50 and further
03:47:42 <jchia_> What extension(s) is this?
03:47:51 <sphinxo> when using tasty-discover is it possible to set maxSuccess for quickcheck?
03:48:28 <merijn> jchia_: DataKinds lets you lift datatypes to the type level (i.e. the type level list is a DataKinds lifted version of list)
03:48:51 <merijn> jchia_: KindSignatures lets you write explicit kind signatures for types.
03:48:57 <Bish> is there are reason haskell=>js compiler projects are all pretty inactive?
03:49:01 <merijn> jchia_: And GADTs for the HList GADT, obviously
03:49:09 <merijn> Bish: ghcjs is very active?
03:49:20 <merijn> Bish: Also, UHC has 2 JS backends, afaik
03:49:27 <Bish> if i go to the github
03:49:29 <merijn> And there's work on a WebAsm backend for GHC
03:49:39 <Bish> there newest commit is a month old?
03:49:48 <Bish> and most files didn't get touched for like forever
03:50:15 <merijn> Bish: The 8.2 branch has a commit from 32 minutes ago...
03:50:35 <Bish> oh i see, it's a "fuck the master branch" repo
03:50:38 <merijn> Also, since when does "month old" mean "dead"?!
03:50:49 <Bish> quote me when i said dead
03:51:00 <merijn> ok, "inactive" then
03:51:13 <Bish> the masterbranch obviously is
03:51:31 <Bish> didn't expect it to be active elsewhere
03:51:34 <merijn> I disagree, because I don't think 1 month old commit is inactive
03:51:34 <Bish> thanks
03:51:34 <jchia_> merijn: I think I need to be able to project elements (by specifying which positions I want to extract) and fmap elements (by specifying position and the function to fmap with). Is there a library that embodies this approach that has these features?
03:51:50 <Bish> merijn: well, that was only 1 file.. and the rest hasn't been touched for 1year+
03:52:28 <merijn> jchia_: There's a couple libraries, but I forgot the names
03:53:27 <Bish> merijn: WebAsm GHC would be cool.. if actually supported by major browser + the ugly used ones
03:53:39 <Bish> like ie6 (lol)
03:55:32 <sphinxo> is it possible to define default test arguments to pass into tasty?
03:55:54 <sphinxo>  specified in the package/cabal file?
03:56:07 <merijn> sphinxo: What do you mean by that?
03:56:37 <sphinxo> like I want to default to passing in --quickcheck-tests=1000 whenever I run stack test
03:59:25 <dxtr> So I'm using persistent-postgresql and I have created a model for stuff I want in my database. This model contains a field that has a default value but is NOT set to "Maybe"
03:59:27 <jd823592> There is Control.Category in base but I cannot find any related notion of Functor, why is that?
03:59:50 <dxtr> Is that wrong? I can't seem to create an object of said model
04:00:51 <merijn> dxtr: persistent is...rather limited and rigid about what's allowed
04:02:06 <merijn> jd823592: Because 1) there already is a Functor typeclass and 2) the proper CT notion of functor apparently wasn't useful enough so far to add
04:02:43 <dxtr> merijn: Yeah, well, unless I'm doing something completely wrong there's a recursive error here. I can't put stuff there because I don't have it and I can't get it because I can't put stuff there
04:02:49 <merijn> jd823592: Despite all the FUD on the internet, if you want rigid category theory, Haskell is probably not the place to go looking for it ;)
04:03:37 <merijn> dxtr: I've only used persistent (and not even postgres) for extremely simple and trivial schemas and even there it's already limiting, so...
04:03:54 <dxtr> So what would you recommend instead?
04:04:11 <dxtr> I'll probably still stick with Persistent for this project because I'm committed now but still'
04:04:14 <cocreature> personally, I just use the *-simple family of packages
04:04:22 <dxtr> Alright
04:04:32 <cocreature> at least they let me do the things I want to do :)
04:04:33 <merijn> I don't really have any strong recommendations. I recall Cale recommending Groundhog for a more flexible mapping from SQL to haskell schema
04:05:17 <jd823592> merijn: I am aware of the functor typeclass, but that is only an endofunctor on Hask, while a functor I envision could be defined for two different instances of Category
04:05:36 <merijn> jd823592: Right, but such a class would be an utter clusterfuck to implement nicely in haskell
04:05:56 <cocreature> there is ed’s hask package but that’s definitely not something I’d recommend you use
04:06:24 <jd823592> merijn: that is exactly what I feared and what motivated my original question, are there any difficulties in particular that you know of?
04:06:51 <cocreature> if you’re interested in formalizing mathematics, take a look at something like Coq or agda
04:07:14 <merijn> jd823592: You'd end up with MultiParamTypeClasses for sure, probably fundeps to deal with the links between those, etc.
04:08:54 <jd823592> cocreature: I might check those out again, but I prefer programming in Haskell
04:10:23 <cocreature> jd823592: fair enough, just be aware that Haskell is a programming language and while we steal some things from math, they are usually drastically simplified and/or butchered and trying to express math in its full generality only leads to pain
04:15:15 <jd823592> merijn: I use MultiParamTypeClasses all the time, am I a bad person? :)
04:15:58 <merijn> jd823592: Not necessarily, but MPTC often results in either 1) ugly code or 2) tricky to resolve constraints
04:16:07 <Unhammer> I use RecordWildCards
04:16:11 <Unhammer> *hides*
04:16:20 <merijn> Unhammer: So do I :p
04:16:23 <merijn> Judiciously :)
04:16:27 <Unhammer> =D
04:17:23 <jd823592> thanks guys, at least I know I should not go looking for a more general functor in disguise, it was not needed, so it's not there.
04:24:47 <ertes-w> [exa]: yes, it traverses data structures =)
04:25:01 <ertes-w> merijn: i wouldn't mind removing mapM and renaming traverse to mapM/mapA
04:29:07 * hackage pandoc-crossref 0.3.0.1 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.0.1 (lierdakil)
04:40:42 <dminuoso> e
05:03:37 <dminuoso> How can I change the default resolver stack picks when creating a new project?
05:04:15 <quchen> dminuoso: ~/.stack/global-project/stack.yaml
05:04:38 <dminuoso> quchen: That doesn't seem to specify the resolver used in that project
05:05:47 <dminuoso> quchen: (instead that seems to just configure the resolver used for stack outside a stack directory)
05:10:39 <cocreature> I don’t think you can change the default for creating new projects
05:14:06 * hackage genvalidity 0.4.0.4, validity 0.4.0.3 (Norfair): https://qbin.io/vg1mf4oav
05:25:06 * hackage drinkery 0.1 - Boozy streaming library  https://hackage.haskell.org/package/drinkery-0.1 (FumiakiKinoshita)
05:40:55 <yaxu> Does anyone know whether the hackage stats are reliable? It shows 6772 downloads in past 30 days for tidal which seems a lot! https://hackage.haskell.org/package/tidal
05:41:37 <merijn> yaxu: There's a bunch of bits/mirrors crawling Hackage
05:41:44 <merijn> yaxu: So "no"
05:43:45 <yaxu> merijn: fair enough !
05:44:05 <ertes-w> yaxu: i mostly use github as a metric for popularity
05:44:23 * yaxu takes down the "6k+ downloads per month!" banner
05:45:37 <yaxu> It's a bit of a disadvantage of free/open source software that you are maybe a bit less clear about how many users you have
05:48:02 <merijn> yaxu: Reminds me of my brother. His company uses (used?) a JS library written by one guy. So at some point on the mailing list they author goes "So, out of curiosity, how many people are using this and how big are your projects?", he gets about 20-30 replies all boiling down to "Oh, I'm using it for this 1000 LOC personal project" and my brother ends up responding "oh, yeah, we have like 50k LOC company
05:48:08 <merijn> codebase using this..."
05:48:33 <merijn> yaxu: Which the author very obviously wasn't expecting, based on him being a bit flabberghasted in response :p
05:49:51 <ertes-w> well, you can download your po… cat videos without some weird FOSS people tracking you =)
05:53:54 <dminuoso> Is there some more elegant pattern to this: `if d ^. l then a else b` ?
05:54:02 <dminuoso> It feels like there must be some bimappish way to do this
05:56:26 <MasseR> If I have `view (foo . bar) :: ReaderT Foo Int`, what's the lensy way to convert it into `ReaderT Foo Bool`? I can do `fmap (> 0) (view (foo . bar))` and `view (foo . bar . to (> 0))` but both feel clumsy
05:57:34 <lyxia> I like the last one
05:58:02 <ertes-w> i like the first one, so there you go…  flip a coin =)
05:58:30 <MasseR> Does it affect your opinion if it's inside a `whenM`?
06:02:35 <lyxia> Maybe it looks better pointfully with "when":   do x <- view (foo . bar) ; when (x > 0) dostuff
06:03:56 <MasseR> Yeah you're probably right
06:18:36 * hackage tuple-ops 0.0.0.0 - various operations on n-ary tuples via GHC.Generics  https://hackage.haskell.org/package/tuple-ops-0.0.0.0 (JiasenWu)
06:18:39 <[exa]> MasseR: btw there's whenM
06:19:59 <[exa]> MasseR: oh you already mentioned that, sorry :]
06:20:02 <MasseR> :D
06:21:18 <sphinxo> If I have functions that are of type State (a, c) and State (b, c) () and a function of type: a -> State (b, c) ()
06:23:03 <sphinxo> how can I chain them together? so the c value of State (a, c) is used as the starting c value for the function: a -> State (b, c) ()
06:23:45 <sphinxo> and the starting b value is an empty list
06:24:29 <lyxia> what do you do with the state value at the end
06:24:54 <sphinxo> at the moment I print it?
06:25:08 <sphinxo> ( but it will be used )
06:25:34 <mnoonan> sphinxo: hoogle suggests mapStateT may be useful
06:26:02 <mnoonan> oh sorry, that doesn't change the state type
06:28:01 <lyxia> sphinxo: just use get and runState
06:29:40 <sphinxo> ok thanks, mnoonan and lyxia
06:52:07 <quchen> sphinxo: You cannot change the type of a state in a single do-block. What you *can* do is run the state and build a new one with a modified type.
06:52:21 <quchen> That’s probably what mapStateT does.
06:53:06 <quchen> The reason for this is that >>= :: m a -> (a -> m b) -> m b, and the »m« is always the same, for example »State (a,b)«.
06:53:18 <quchen> So the result of a >>= always has the same state type as what you put in.
07:06:52 <royal_screwup21> what does "do" really do?
07:07:19 <merijn> royal_screwup21: "do" doesn't do anything, it's just syntactic sugar for >>=
07:07:31 <royal_screwup21> shite
07:07:54 <royal_screwup21> so I need to learn about moands before I can really understand its internal working
07:09:47 <royal_screwup21> how long did it take y'all to understand moands?
07:10:26 <Profpatsch> royal_screwup21: Nah, you just need to look at the instance definition for the one you are using.
07:10:38 <Profpatsch> pure :: a -> m a
07:10:53 <merijn> royal_screwup21: There's not much there to understand. The hard part is learning not to overthink things
07:11:13 <Profpatsch> (>>=) :: m a -> (a -> m b) -> m b
07:13:48 <metahumor> royal_screwup21: is there a particular instance you are trying to understand?
07:13:59 <metahumor> royal_screwup21: and how do you feel about list comprehensions?
07:14:36 <byorgey> royal_screwup21: if you are trying to understand some code that does I/O, then I highly recommend reading https://www.vex.net/~trebla/haskell/IO.xhtml
07:14:56 <byorgey> which introduces I/O without talking about monads in general
07:15:08 <royal_screwup21> alrighty thanks!
07:17:17 <mbwgh> Spacemacs/Intero/Stack: Does anybody know how to transition smoothly to a new lts release, so that the editor setup still works? According to a recent thread on reddit, you just need to `stack install intero` again, however this doesn't seem to work for me. Specifically, flychecking doesn't work anymore and instead some garbage like "^[[;1m<no location info>: ..." is shown at the bottom. Things I tried:
07:17:23 <mbwgh> `stack upgrade`, `stack install [all the packages needed for a clean install of the spacemacs haskell-layer]`, `stack setup --update-cabal`, `stack install Cabal cabal-install` and probably more. Any ideas?
07:17:31 <hyperisco> gooooooood morning
07:17:50 <metahumor> hi
07:17:54 <sanitymug> hyperisco: provocateur...
07:17:59 <mbwgh> I am trying to get things to work with lts-10.3, that is, GHC-8.2.2.
07:18:14 * hyperisco *rustle*
07:22:39 <brynedwards> mbwgh: Don't use `stack install`, see here: https://github.com/commercialhaskell/intero/blob/master/TOOLING.md
07:28:42 <mbwgh> brynedwards: Huh, I haven't seen this document before. I think I did try `stack build intero` too, inside and outside of a project, but only *after* `install`ing in the global project. It didn't work, so it seems I have to undo the damage first.
07:29:33 <mbwgh> brynedwards: Of course, I did change the lts version in the global stack.yaml.
07:33:08 <brynedwards> mbwgh: `stack install` builds and copies the binaries to $HOME/.local/bin, so if you have `intero` there, delete it
07:38:30 <mbwgh> brynedwards: Ok I just tried that, unfortunately it still doesn't work.
07:40:19 <mbwgh> brynedwards: Of course it might be an issue of the spacemacs haskell-layer and not intero.
07:51:44 <metahumor> what's an idiomatic way of terminating a replicatedM "StateT s [] a"?
07:52:09 <metahumor> if I have some condition on the state s, I want to stop generating, and exit
07:52:44 <hyperisco> metahumor, empty
07:53:45 <hyperisco> slash mzero or mempty
07:56:26 <metahumor> i'm getting a nice result by doing "evalStateT (many go) ..." where my "go :: StateT s [] a" uses guard inside
07:57:12 <hyperisco> and what do you think guard returns on False? mzero
07:58:05 <metahumor> yeah =) it's just nice I don't have to explicitly mention mzero, and "many" takes care of using the Alternative / MonadPlus of StateT s [] a
07:58:30 <mnoonan> metahumor: monad-loops has lots of little combinators in this area
08:03:00 <AWizzArd> I am looking at an Enum and saw the type signature of succ and pred. It’s lying because those seem to be partial functions. So succ does not give me the next value when I have the greatest one.
08:03:18 <AWizzArd> How can I check if there is any next value left? I don’t want to run into an exception.
08:03:29 <metahumor> Int is Bounded
08:03:49 <metahumor> "if x == maxBound then Nothing else succ x"
08:03:55 <metahumor> whoops
08:04:02 <metahumor> "else Just (succ x)"
08:04:39 <metahumor> "let x' = succ x in if x' < x then Nothing else Just x'"
08:05:07 <AWizzArd> Okay that works.
08:05:09 <AWizzArd> Thx!
08:05:25 <dmwit> AWizzArd: What type are you planning to use this with?
08:05:45 <dmwit> There may be other ways that fit your needs better, depending on what type you're using.
08:06:45 <hyperisco> Enum is borked for convenience, shame
08:06:50 <metahumor> uhh my first defn will work, the latter ones will Exception on maxBound
08:06:54 <AWizzArd> dmwit: I want to walk through all timezones: https://www.stackage.org/haddock/lts-10.3/tz-0.1.3.0/Data-Time-Zones-All.html
08:07:25 <AWizzArd> dmwit: working with IANA timezone data.
08:07:43 <hyperisco> then you just take the list of timezones and map (or zip) it
08:08:08 <royal_screwup21> what's the difference between "<>" and mnconcat?
08:08:19 <geekosaur> none
08:08:29 <geekosaur> er, sorry. <> is mappend
08:08:35 <hyperisco> well, <> is alias for mappend, and mconcat is something else
08:08:36 <metahumor> AWizzArd: enumFromTo minBound maxBound :: [Timezones] ?
08:08:39 <geekosaur> mconcat folds mappend / <> across a list
08:09:09 <dmwit> AWizzArd: You might consider using `[minBound .. maxBound]` instead of calling `succ` directly.
08:09:09 <AWizzArd> metahumor: yes this works, I can get the max bound value und via fromEnum get its index too.
08:09:11 <hyperisco> and why is there not a standard defn for [minBound..maxBound]
08:09:17 <dmwit> hyperisco: see
08:09:19 <dmwit> ?hackage universe
08:09:19 <lambdabot> http://hackage.haskell.org/package/universe
08:09:24 <AWizzArd> dmwit: yes, this is much better
08:09:48 <hyperisco> a Wagner special!
08:09:52 <dmwit> hyperisco: It even works for many non-`Enum`, non-`Bounded` types. =)
08:10:14 <royal_screwup21> :t <>
08:10:16 <lambdabot> error: parse error on input ‘<>’
08:10:40 <AWizzArd> dmwit: that is a noteworth trick in general it seems. Good input!
08:10:50 <dmwit> :t (<>)
08:10:52 <lambdabot> Monoid m => m -> m -> m
08:11:13 <hyperisco> didn't go full hog using sized vectors for Finite though
08:12:21 <dmwit> no =)
08:12:53 <dmwit> I have a branch that includes `cardinality :: Finite a => proxy a -> Integer` which is occasionally handy, but I never got around to merging it with master.
08:12:56 <dmwit> I don't remember why.
08:13:01 <hyperisco> that's okay… can always define another class
08:13:41 <hyperisco> I was looking forward to  (Finite m a, Finite n b) => Finite (m * n) (a, b)  though :D
08:14:14 <metahumor> and soon we get to hyperreals
08:14:20 <royal_screwup21> is there a simpler way of expressing this newtype Product a = Product { getProduct :: a }? I'm not sure what the curly braces are for
08:14:28 <hyperisco> you get to encode finite type algebra
08:15:39 <geekosaur> royal_screwup21, that's defining it as a record with a named accessor
08:15:41 <hyperisco> royal_screwup21, the curly braces are part of record syntax and no
08:16:09 <geekosaur> newtype Product a = Product a -- "simple" but no accessor, you must pattern match
08:16:21 <hyperisco> but a more wordy way is  newtype Product a = Product a; getProduct (Product a) = a;
08:16:32 <hyperisco> and then you can't take advantage of record extensions
08:16:45 <dmwit> royal_screwup21: One could write `newtype Product a = Product a; getProduct (Product a) = a` and only a little bit would be lost. Specifically, record update, record-style construction, and record-style pattern matching would be lost.
08:17:25 <hyperisco> too many cooks
08:18:04 <geekosaur> @quote antiphony
08:18:04 <lambdabot> No quotes match. Are you on drugs?
08:18:07 <geekosaur> bah
08:18:26 <geekosaur> (I knew the "majestic stereo" version was gone...)
08:18:35 <dmwit> Well... I mean, you are, technically, though, so lambdabot's got you there.
08:18:51 <geekosaur> twice over, arguably :p\\
08:19:06 <dmwit> =D
08:19:11 <geekosaur> maybe 3 times. the warnings on one of these drugs make it look almost as dangerous as the tramadol >.>
08:30:43 <JulianG> I'd have a question...
08:30:51 <Uniaika> don't ask to ask :)
08:30:59 <JulianG> What are the most missed IDE features in Haskell
08:31:15 <JulianG> I'm doing Phd research (almost finished) on GUIs
08:31:40 <JulianG> I have a list of maybe 100 points what I would like
08:31:52 <JulianG> But what features do you miss the most for Haskell?
08:32:07 <sm> works ?
08:32:13 <Clint> i don't like IDEs
08:32:27 <tdammers> not so much features, as a set of orthogonal, standalone tools
08:32:43 <tdammers> not an IDE person myself either
08:33:31 <JulianG> What about debugging?
08:33:37 <JulianG> And debugging performance problems?
08:33:41 <srk> JulianG: there's this ghcid thingie you can run instead of an IDE that just compiles your code over and over and tells you if it's ok :)
08:33:42 <sm> 1. just works, 2. click on symbols for definition or references, 3. highlight errors and warnings
08:33:54 <hyperisco> JulianG, hard to know where to begin because there are so many possible features
08:34:14 <srk> JulianG: but also haskell-vim-now if you want more integration into your editor for example
08:34:38 <hyperisco> JulianG, disclaimer is I have not used the emacs or vim plugins, but they all use mod-ghc afaik, so experience should be roughly similar …
08:35:04 <tdammers> performance problems are notoriously tricky to debug, but this isn't a matter of lacking tools, it's a consequence of how Haskell works (which is otherwise a great productivity booster, mind you)
08:35:57 <hyperisco> JulianG, mod-ghc is really slow and doesn't understand incomplete programs that well (it seems), so getting anything useful such as inferred type or name completion is hit-and-miss
08:37:01 <hyperisco> and the integration into some editors has been as poor as to tie up the UI thread on mod-ghc calls, and the editor lags on every key press -.-
08:37:43 <infandum`> I have been stuck on Streaming.Cassava for days. This line is as far as I've gotten: https://pastebin.com/0R1901xv  As you can see, I'm stuck with matching IOException with CsvParseException.
08:37:51 <infandum`> What am I doing wrong?
08:37:53 <hyperisco> what someone or a team has to do is rebuild the whole technology from the ground up to support incremental changes and incomplete programs
08:38:00 <hyperisco> from parsing right through semantic analysis
08:39:52 <hyperisco> and I think a promising basis for that can be found as an example of conal's "Compiling to Categories" work
08:39:55 <JulianG> hyperisco: Yes, I agree that that is important
08:40:17 <ertes-w> JulianG: some form of editor-supported API exploration
08:40:18 <JulianG> hyperisco: That is not a typo?
08:40:29 <hyperisco> JulianG, is what a typo?
08:40:32 <JulianG> hyperisco: Do you have a link?
08:40:37 <ertes-w> JulianG: "for this hole give me a list of stuff i could put here that would be well-typed"
08:40:51 <mnoonan> hyperisco: I don't quite get it.. what is the C2C connection as you see it?
08:41:04 <JulianG> hyperisco: I found the link, thx.
08:41:20 <MarcelineVQ> hyperisco: quite often it's stack running ghc-mod slowing things down, actually the current issue that affects things like ghc-mod and ghcid and ghc's own ide options are that ghci is continuously eating up more and more memory when used as an ongoing process :(
08:42:02 <ertes-w> JulianG: also turning things into *temporary* holes could be easier…  i often find myself cutting a region of code out and replacing it by a hole in order to reload the module, then i undo that
08:42:06 <sm> JulianG, for debugging/profiling: 1. cost-free profiles from regular builds (no recompiling), 2. first-class effective actively-improving comprehensive toolset for time & space analysis, performance suggestions, post mortem debugging, live debugging etc.
08:42:13 <merijn> And sadly, like 80% of these tools don't support new-build
08:42:24 <merijn> And the ones that support new-build, don't support vim :\
08:42:34 <hyperisco> JulianG, a given example is giving functional programs a semantics supporting incremental change
08:42:59 <JulianG> hyperisco: good point!
08:43:08 <hyperisco> JulianG, so ostensibly you should be able to write fairly ordinary parser combinators and get a parser which supports incremental changes to the input string for free
08:43:59 <infandum`> Okay, using runExceptT makes the types agree, but I'm still getting a "*** Exception: test.csv: hGetBufSome: illegal operation (handle is closed)" error.
08:44:19 <merijn> infandum`: Because runExceptT only catches things thrown in runExceptT
08:44:27 <merijn> infandum`: This is an IOError thrown inside IO
08:44:28 <hyperisco> and so the same should follow for any semantic analysis… incremental change to the semantic model should recompute the analysis only as much as needed
08:44:54 <hyperisco> and the awesome thing is you don't really have to do much extra thinking… magic!
08:44:55 <merijn> infandum`: This is why I don't like ExceptT with an exception type. It pretends to be "checked exceptions", but doesn't actually catch everything thrown within it
08:44:57 <infandum`> merijn: That's what's causing the illegal operation? So I guess the EOF isn't caught?
08:45:20 <merijn> infandum`: I dunno what's causing that error
08:45:26 <geekosaur> that's not what EOF looks like
08:45:40 <hyperisco> another awesome example is the category for SMT solvers
08:45:50 <geekosaur> are you by any chance using this on a handle that you did hGetContents on?
08:46:07 <mnoonan> huh, I guess I glossed over the incremental computation section on my last read
08:46:11 <hyperisco> if you've used some of the awkward APIs for working with SMT solvers then this new idea seems almost too good to be true
08:46:13 <infandum`> geekosaur: No, just the line in that paste (plus runExceptT)
08:51:07 --- mode: ChanServ set +o glguy
08:51:07 --- mode: glguy set -qo clipcomp!*@* glguy
08:51:24 <infandum`> geekosaur: With that line, _ <- runResourceT . runExceptT . etc., I should note that it does print out the proper parsing (a list of strings), but at the very end after all lines are parsed it shows that exception.
08:53:44 <infandum`> Could it be a bug in the library?
08:55:22 <infandum`> This is a post kind of using it in a way here from November, so I assume they got it to work: https://www.tweag.io/posts/2017-11-01-streaming-and-foldl.html
08:55:56 <infandum`> But they don't have these errors or anything with CsvParseError at all, so I can't get their function to type check.
09:01:12 --- mode: ChanServ set +o glguy
09:01:12 --- mode: glguy set -bbbb $a:BRS-Ryan $a:Baluse $a:BernieBankenberg $a:BraunScheisse
09:01:12 --- mode: glguy set -bbbb $a:ChokoIt $a:Core3 $a:DonVitoCorleone $a:JohnBlack
09:01:12 --- mode: glguy set -bbbb $a:Kareesh $a:LLckfan $a:Maiz_en_Heces $a:MakTa
09:01:13 --- mode: glguy set -bbbb $a:Mitzelflick $a:MrDildeaux $a:MrTrump $a:MrrTrump
09:01:14 --- mode: glguy set -bbbb $a:Ndit $a:NeonJesus $a:Nigrarama $a:ParmesanCaesar
09:01:15 --- mode: glguy set -bbbb $a:Schmeidth $a:StaffAlert $a:VitamnP $a:Xochipilli
09:01:16 --- mode: glguy set -bbbo $a:b0llo $a:chaotic_good $a:fasta glguy
09:04:43 --- mode: ChanServ set +o glguy
09:04:43 --- mode: glguy set -bbbb $a:frendshipismagic $a:gavino $a:jakk $a:jdoles
09:04:43 --- mode: glguy set -bbbb $a:jimmyray $a:kyfho $a:lawful_evil $a:mike4_
09:04:43 --- mode: glguy set -bbbb $a:mrBG $a:offensive_goat $a:plates $a:roscareyes
09:04:43 --- mode: glguy set -bbbb $a:sausage2 $a:tsilamkep $a:xfce-x64 $a:yxkvast
09:07:54 --- mode: glguy set -bbbb *!*average@unaffiliated/average *!18722504@gateway/web/cgi-irc/kiwiirc.com/ip.24.114.37.4 *!~androirc@203.192.219.83 *!*@185.143.40.133
09:08:59 --- mode: glguy set -bb *!*@gateway/web/cgi-irc/kiwiirc.com/ip.80.154.24.146 $r:client-86-25-194-189*
09:30:57 <infandum`> I do want to mention that I had none of these issues with Data.ByteString.Streaming.Aeson, that was fairly straightforward
09:33:33 --- mode: glguy set -o glguy
09:40:39 <dmj`> is it possible to declare the same type signature for multiple pattern synonyms, much in the same way we do data Foo = Foo { x,y :: Int }
09:42:23 <glguy> pattern A, B :: Int
09:45:06 <dmj`> doesn’t work on 8.0.2 for me :(
09:47:06 * hackage http-client 0.5.8, http-conduit 2.3.0 (MichaelSnoyman): https://qbin.io/ptfac0u
09:55:45 <[exa]> Is there some shortcut or standard operator for (a >=> const b) ?
09:56:12 <[exa]> ie. (\x -> (a x >> b))
09:58:44 <[exa]> hm, (>>b).a ...
09:59:29 <dmwit> I don't think so.
10:00:15 <dmwit> Of the choices you proposed, I like `\x -> a x >> b` the best if it's alone, `a >=> const b` if it's in a longer `(>=>)` pipeline.
10:02:07 * hackage compactable 0.1.0.3 - A generalization for containers that can be stripped of Nothings.  https://hackage.haskell.org/package/compactable-0.1.0.3 (fresheyeball)
10:02:17 <[exa]> yeah the lambda is most readable I guess
10:02:31 <ReinH> @pl \x -> (a x >> b)
10:02:31 <lambdabot> (>> b) . a
10:02:42 <ReinH> That's... uh... not... terrible?
10:02:55 <ReinH> I don't think I'd use it.
10:05:17 <[exa]> looks like a bracket though
10:05:21 <[exa]> (a bit)
10:16:37 * hackage epub-tools 2.11 - Command line utilities for working with epub files  https://hackage.haskell.org/package/epub-tools-2.11 (DinoMorelli)
10:20:53 <shafox> How can I represent this type of data in haskell https://gist.github.com/shadow-fox/78f3e2220fa7e504e93a6713b00442ce ?
10:21:52 <Clint> shafox: use pandoc
10:23:01 <metahumor> shafox: do you want to parse that or what?
10:23:33 <shafox> metahumor: yes
10:23:50 <metahumor> use a parser like Megaparsec?
10:24:07 <dmcmint> it looks like an XML tree
10:24:09 <[exa]> shafox: plain Data.Tree is probably good for representing it
10:24:17 <dmcmint> without the markup
10:24:44 <shafox> [exa]: lemme check thanks for tip.
10:25:48 <[exa]> shafox: if you'd need parsing it, you can write a good parser by hand just by checking indentation
10:26:12 <[exa]> megaparsec recommended though, just for the practice
10:26:36 <shafox> [exa]: i will check that one too.
10:29:23 <dmwit> So, having a cabal sandbox lying around with a bunch of random packages in it is pretty handy, because I can experiment with something real quick by just going to the right directory and running `cabal exec ghci`.
10:29:59 <dmwit> What is the new-* answer to this kind of thing? Is there a way I can get a ghci session going with some random stateful collection of packages?
10:30:22 <dmwit> (stateful in the sense that I can just occasionally include an extra thing, and then it's available in ghci's started that way from then on)
10:30:35 <MarcelineVQ> I do want  cabal new-repl --package lens  like stack has
10:43:36 <byorgey> I have a cabal package that defines just an executable.  But when I 'stack build' it does not create a bin/ directory where I expect, and 'stack exec foo' (where foo is the name of the executable) gives an error.
10:43:42 <byorgey> has anyone ever seen anything like this?
10:43:49 <byorgey> 'stack clean' does not help.
10:45:12 <byorgey> in the error message, the first directory it lists among the places it looked is the bin/ directory I would expect it to make, which does not exist.  So I don't think the problem is e.g. that the executable is named something other than what I expect.
10:46:53 <byorgey> I can even explicitly write  'stack build foo:bar' and it silently succeeds but there does not seem to be a 'bar' executable anywhere.
10:46:54 <metahumor> it might not be "stack exec foo" but more like "stack exec foo-exe" or something like that
10:47:14 <metahumor> stack build will not do anything if it thinks that a build should be a noop
10:47:36 <kadoban> byorgey: So you did 'stack init' and then 'stack build' and it completes without error/warning, but then 'stack exec -- the-exe-name' doesn't work? That sounds fairly odd
10:48:10 <byorgey> kadoban: right
10:48:20 <kadoban> I know there's some cases where like if you delete the executable on some version of stack, it doesn't realize it should rebuild, and there's some weird things like it'll fail if the LICENSE file is missing because of *some reasons*, but I can't think of anything else offhand.
10:49:04 <byorgey> huh, wait, I found the executable.  It went in .stack-work/dist/x86_64-linux-nopie/Cabal-2.0.1.0/build/packagename/
10:49:22 <byorgey> but when I 'stack exec exename' it says not found, and does not list that dir among the places it looked
10:49:32 <metahumor> it's in there, under a slightly different name
10:50:11 <byorgey> no, I don't think so.
10:50:50 <byorgey> the first dir listed among the places stack exec looked is  .stack-work/install/x86_64-linux-nopie/lts-10.3/8.2.2/bin/
10:50:54 <byorgey> that directory does not exist.
10:51:16 <byorgey> whereas  .stack-work/dist/... does contain the exe I expect, with the name I expect.
10:51:20 <kadoban> Should always end up in  `stack path --local-install-root`/bin/ yeah, which looks like probably that.
10:52:03 <byorgey> yes, stack path --local-install-root gives .stack-work/install/...
10:52:37 <byorgey> incidentally I can reproduce this on two different machines.
10:52:44 <kadoban> Only thing I could think to suggest is maybe just nuke all of .stack-work/ and try again, make sure there's no warnings/errors at all. But kind of a shot in the dark, shouldn't usually make sense.
10:52:47 <kadoban> Oh, hmm.
10:52:58 <MarcelineVQ> can you share your project? interested to try and repro
10:54:10 <byorgey> well, I don't want to make it public since it is for a class and it has exams and solutions and stuff.  It also depends on an unpublished local package.  Let me see if I can make a minimal example.
11:04:38 <byorgey> hah!  I figured it out.
11:04:54 <byorgey> the problem was that my repo did not contain a LICENSE file even though the .cabal file referred to one
11:05:02 <byorgey> apparently cabal was silently failing.
11:05:43 <MarcelineVQ> gross :X
11:06:32 <kadoban> byorgey: Ugh, ya I hate that issue. There should at least be a warning about it from stack in recent versions I thought.
11:15:20 <aplainzetakind> In stack.yaml of a program I want to build, the lts version is very old (5.11), and stack refused to build because no suitable ghc for the OS. I overrode the lts version to 9.14, and added a couple of extra dependencies as per stack's suggestion. The build fails at package 62/64 with these compilation errors: https://paste.pound-python.org/show/Hd6lho99bNuHK3tSZ5MU/. How can I, or can I at all,
11:15:26 <aplainzetakind> troubleshoot this?
11:15:42 <dmwit> It is too bad that ghci history is shared across {cabal,stack} projects.
11:17:23 <AndreasK> aplainzetakind: Seems like some kind of breaking api change withing the the dependencies of your project
11:17:40 <dmwit> aplainzetakind: Do you have packages that are not coming from the resolver?
11:18:10 <dmwit> If yes, and lts-9.14 offers those packages, consider de-vendoring them.
11:18:40 <dmwit> (You may of course then need to update the code of anything that depends on those packages.)
11:18:58 <aplainzetakind> dmwit: how do I check that? sorry I'm ignorant on these matters.
11:19:02 <byorgey> kadoban: oh, so this is a known issue?  yeah, I didn't see any warning.
11:19:26 <dmwit> aplainzetakind: I don't know. There will be information about it in your stack.yaml, but I do not know that file's syntax enough to give a more explicit pointer than that.
11:19:35 <dmwit> Others here certainly will; perhaps one of them will pipe up.
11:20:07 <dmwit> byorgey: Well, he did mention it about 20 minutes before you said you figured it out. =P
11:20:39 <kadoban> byorgey: Yeah, it used to come up fairly often and it was quite silent. If there's no warning at all though in recent stack, that's probably a regression that should be looked at though :-/
11:20:40 <byorgey> dmwit: wait, really?  I missed that =P
11:20:51 <byorgey> oh, I see it now in the scrollback, doh
11:21:12 <dmwit> bummer
11:21:14 <kadoban> :)
11:21:36 <aplainzetakind> dmwit: alright. btw this is what I'm trying to build https://github.com/LuminosoInsight/wikiparsec
11:22:15 <byorgey> kadoban: the error does show up in a log file in .stack-work/logs, now that I am looking for it, but there was no warning on the commandline.
11:22:32 <kadoban> That's bad. Are you on v1.6.3 or whatever?
11:22:52 <kadoban> I'll have to see what it looks like and if it can be improved, or if some change broke that detection or whatever it's doing.
11:22:57 <byorgey> yes, 1.6.3.  I ran 'stack upgrade' literally a half hour ago.
11:23:57 <kadoban> IIRC actually totally fixing the problem is hard for some reason I never understood, but at one point it at least told you why that happened pretty prominently.
11:25:26 <byorgey> yeah, it doesn't seem like it would be hard to fix, but I can believe it.
11:25:43 <byorgey> kadoban: thanks for the help!
11:26:17 <kadoban> Ya anytime, thanks for bringing it up. I'll try to replicate it later and do a bug report or something.
11:37:56 <Franciman> Hi
11:38:15 <Franciman> Why is the ListT monad in mtl and transformers not the ListT "done right" ?
11:39:48 <amalloy> you mean, what's wrong with it? or why hasn't it been replaced with the "right" version, or what?
11:40:28 <Franciman> amalloy, the second
11:41:53 <Franciman> amalloy, also, what's wrong with it?
11:42:05 <Franciman> I mean I read that it's too strict
11:42:11 <Franciman> and it's not always a monad
11:42:24 <amalloy> i'm not really the right person to answer either of those questions, just thought you might get a better response if the question were more specific
11:42:25 <Franciman> in the sense that laws aren't respected
11:43:39 <lyxia> Franciman: https://wiki.haskell.org/ListT_done_right
11:44:22 <Franciman> lyxia, yep, read about it, but I didn't find why in transformers and mtl, there is the "wrong" version of ListT
11:46:30 <lyxia> history, I guess.
11:47:47 <amalloy> right, the "obvious" answer is that ListT was implemented wrong and included in mtl etc before people knew it was wrong. and then fixing it is disruptive to people relying on the old behavior, so instead it was left alone and a new package defined
11:47:58 <geekosaur> there are depndents that require the old one's strictness
11:49:29 <lyxia> It's also not 100% wrong.
11:49:38 <Franciman> yeah, I kinda like it
11:49:49 <Franciman> apart from the fact that it is a bit picky about m
11:52:34 <Franciman> thank you
11:52:36 <hyperisco> that's why you should prove your laws
11:52:41 <ph88> can join be explained not in terms of bind ?
11:53:03 <hyperisco> ph88, are you asking if there is a formulation of join which does not use bind?
11:53:43 <ph88> possibly a formulation ..
11:54:01 <simp__> Are there any books on Haskell that perhaps dive into some category theory and/or type theory?
11:54:01 <ph88> i have the feeling that join can be implemented with bind and bind with join
11:54:29 <ph88> simp__, category theory for programmers
11:54:42 <Franciman> ph88, it's true
11:54:45 <ph88> it's free with pdf
11:54:48 <hyperisco> you can implement join with bind and id, but not bind with just join (you also need fmap)
11:54:57 <Franciman> ah right
11:55:21 <simp__> Does that assume I know Haskell though, ph88?
11:55:33 <Franciman> ph88, category theory for programmers is the book from bartosz milewski?
11:55:52 <ph88> simp__, not for the first 3 chapters, but i wouldn't recommend it if you are totally new to programming
11:55:57 <ph88> Franciman, yes
11:56:01 <Franciman> cool
11:56:16 <ph88> i'm in a study group we are going through the book
11:57:04 <ph88> there are also videos which are also quite good (i haven't seen them, others have) but supposingly he talks slowly so people put it on 2x speed
11:57:51 <hyperisco> I put a lot of videos on 1.5x or 2x speed
11:58:42 <hyperisco> it is like living 50% or 100% longer!
12:00:48 <dmwit> ph88: https://stackoverflow.com/q/11234632/791604
12:01:45 <ph88> thx dmwit
12:09:04 <ph88> i'm just surprised by join that you can unwrap one layer in a polymorphic? way .. my instinct tells me you are losing information. Perhaps indeed information is lost (Just Just 2 is not the same as Just 2) .. but the surprising thing is that it will still make sense for that monad ..
12:09:21 <ph88> i read join kind of like "unwrap two layers for me" and "wrap it in one"
12:10:38 <ph88> i didn't see any code so far that uses join (always bind or do notation) ..  maybe that's a reason why i don't really get it
12:11:34 <mnoonan> "concat" is probably the most common join
12:12:29 <mnoonan> and you *are* losing information when you join, but that's ok!
12:12:36 <ph88> join (Right (Right a)) = Right a; join (Right (Left e)) = Left e; join (Left e) = Left e -- Either     .. here Right is dropped (on the "top-level") but Left is maintained .. so it has a preference for Left i think
12:13:38 <ph88> join: please deliver me the smallest Functor by the rules of this specific monad ??
12:13:51 <mnoonan> I can't make sense of that.
12:14:21 <ph88> if you consider (Just 2) to be smaller than (Just (Just 2))
12:14:39 <ph88> one layer of wrapping less
12:14:47 <dmwit> Just (Just 2) and Just 2 have different types.
12:14:56 <dxtr> I always use Maybe Maybe because then I can return "Just Nothing" and it makes me giggle
12:15:12 <ph88> LOL
12:15:46 <dmwit> I agree with mnoonan: "please deliver me the smallest Functor by the rules of this specific monad" is not a sensible summary.
12:16:23 <ph88> ok
12:16:53 <dmwit> The types tell exactly which functor (monad, actually) should be used for the output.
12:16:57 <mnoonan> ph88: have you worked out how to implement join in terms of (>>=) or do-notation?
12:17:06 <ph88> mnoonan, yes it was in the SO post
12:17:08 <dxtr> Maybe Either is good too. "Just Right"
12:17:20 <ph88> mv >>= v2mw = join (fmap v2mw mv)
12:17:40 <mnoonan> ph88: but have *you* worked it out? :)
12:17:56 <dmwit> ph88: Also that's implementing (>>=) in terms of join. =P
12:18:42 <ph88> mnoonan, working on it :p
12:19:08 <mnoonan> thinking it through for IO may be helpful since you can't play with any of the constructors
12:19:20 <ph88> > pure 2 :: Either Int Int
12:19:23 <lambdabot>  Right 2
12:19:26 <ph88> i find this also interesting
12:19:33 <metahumor> yes, it's biased
12:19:50 <ph88> yes the bias is there .. i have to realize that ^____^
12:20:12 <metahumor> > fmap (+1) (0,0)
12:20:17 <lambdabot>  (0,1)
12:20:39 <metahumor> ph88: Functor ((,) a) is also "biased"
12:21:54 <ph88> is there any way to quickly know the bias of each monad ? or is it just a matter of looking at the source ?
12:22:15 <Taneb> It'll be in the last type parameter
12:22:16 <ph88> i mean i haven't seen anything about it in the type signature or so .. but it's important information
12:22:35 <ph88> Taneb, what type parameter ?
12:22:53 <Taneb> (,) a b <- the b there
12:23:01 <Taneb> Similarly Either a b
12:23:02 <metahumor> similarly, Either a b
12:23:05 <metahumor> jinx
12:23:09 <Taneb> :D
12:23:19 <ph88> is that by convention or is that also following some law ?
12:23:30 <Taneb> It's mandated by the kind of Monad
12:23:38 <ph88> ok
12:23:39 <metahumor> its an outcome of currying or "partial application"
12:24:15 <ph88> hows that currying on sum types ? seems to be i can just swap the implementation around of Either (or make a new version of it)
12:24:33 <Taneb> You need to partially apply the type function until there's only one parameter left
12:25:06 <mnoonan> sure, if you do "MyEither b a = Lefty a | Righty b", you'll get biased to Righty
12:25:27 <metahumor> you could make a "HeterodoxEither a b = Right a | Left b" and make instances of Functor etc for that, it is by convention we use Either
12:25:58 <metahumor> ehh, "HxRight a | HxLeft b" to make sure you don't have collisions
12:26:43 <metahumor> you'd also be interested to read about the monad transformer version of Either
12:29:15 <ph88> alright, thanks guys !
12:39:05 <nitrix> Freaking Haskell. I spent the last months working on a model for a toy programming language. I went from not really understanding Functional Reactive Programming (Conal Elliot), to the Actor model (Carl Hewitt), to Flow Based Programming (J. Paul Morisson), to rolling my own Dataflow Pramming Language, which ended up being extremely close to Unix Pipes, and while looking at how they'd compose... I end up back at square 1 with Haskell's Arrows.
12:39:10 <nitrix> That's embarassing.
12:39:44 <ryantrinkle> nitrix :)
12:39:47 <kadoban> Sounds like you had some fun months :)
12:40:01 <nitrix> Maybe now AFRP will make more sense (:
12:40:03 <ryantrinkle> it took me quite some time to wrap my head around FRP
12:40:07 <mozzarella> who's haskell?
12:40:22 <johnw> ryantrinkle: have you written up your journey through FRP?
12:40:39 <ryantrinkle> johnw: no, but i did give a talk on it
12:40:47 <ryantrinkle> https://www.youtube.com/watch?v=92eXGvHFbzs&t=2s
12:40:51 <johnw> thanks!
12:40:59 <ryantrinkle> it was harrowing :P
12:41:01 <johnw> I was trying to push reflex at work yesterday
12:41:08 <ryantrinkle> nice! :D
12:41:10 <ryantrinkle> how'd that go?
12:41:21 <johnw> "not enough time right now, but maybe later"
12:41:39 <ryantrinkle> well, if i can ever help make the required amount of time lower, let me know :)
12:41:44 <johnw> this code where i'm talking to Z3, I'd like to build an interactive dashboard for montioring intermediate solution results, and also to interact with and changes the constraints and limits in real time
12:41:53 <ryantrinkle> oh, sweet
12:42:04 <ryantrinkle> that sounds like a lot of fun, and definitely something reflex would be good for
12:42:09 <johnw> at the moment I generate a bunch of files and some SVG graphs as the output of the whole process, with status just dumped to stdout
12:42:27 <johnw> but it seems like it would be perfect for a reflex-based API to allows introspection and live modification
12:42:43 <johnw> s/API/UI
12:42:50 <johnw> i'll watch the video!
12:42:56 <nitrix> Truth is, now I'm almost considering migrating what I've done as a Haskell DSL. Just one glorious monad.
12:44:05 <johnw> ryantrinkle: my biggest fear is ghcjs for this project
12:44:27 <conal> johnw: if you really want to understand FRP, start with denotation and the denotational homorphism principle. then there's almost nothing to invent. just solve the algebra problems. (as we discussed on friday.)
12:44:43 <johnw> conal: that's really a great idea
12:44:44 <nitrix> I'd get a type system for free and I have seen people use DSL monads to do codegen.
12:45:26 <ryantrinkle> johnw: all the reflex stuff can compile to native on mac, linux, iOS, and android
12:45:42 <ryantrinkle> and windows subsystem for linux, come to think of it
12:46:02 <johnw> ryantrinkle: if I compile to native on macOS, what does that mean? What am I interacting with?
12:46:11 <conal> johnw: the denotational/homomorphic story for FRP is spelled out in the talk "A more elegant specification for FRP" (https://github.com/conal/talk-2015-more-elegant-frp/blob/lambdajam-2015/README.md). But you may enjoy trying on your own first.
12:46:26 <ryantrinkle> johnw: you get a WebView, which native haskell communicates with to draw DOM elements
12:46:52 <johnw> ryantrinkle: do you have an example for this I can run here and play with?
12:47:09 <johnw> conal: I was there for that talk
12:47:14 <conal> johnw: without the denotational foundation, people often get mired in arbitrary operational concerns, and they don't see the semantic inconsistencies.
12:47:19 <conal> johnw: :)
12:47:33 <conal> related: https://gist.github.com/conal/d578f9b47648338e3527
12:47:37 <nitrix> conal: I always tought it was slightly too abstract. I went for a more practical approach, then experimented with what was useful and what wasn't, tried to cut things down to the minimum, then it forced me to ask questions about what should be computations, how those interracts and/or compose, and suddentely, I'm put into the very situation you recommended me to start with.
12:47:45 <nitrix> conal: Kind of funny.
12:47:58 <nitrix> Can't escape the fundamentals, huh.
12:48:59 <conal> Nope. And I question your use of "practical". I've never found it practical to ignore theory/fundamentals.
12:49:24 <conal> "there is nothing so practical as a good theory"
12:49:27 <nitrix> conal: Oh I agree. I was simply naive.
12:50:01 <conal> nitrix: It's a great path to personally internalize the value of theory!
12:51:32 <ryantrinkle> johnw: sure: git clone https://github.com/reflex-frp/reflex-platform , add the caches listed here https://github.com/reflex-frp/reflex-platform/blob/develop/notes/NixOS.md (or just suffer a fairly lengthy build) then $(nix-build reflex-platform -A ghc.reflex-todomvc --no-out-link)/bin/reflex-todomvc
12:52:56 <johnw> great, thanks ryan
12:53:00 <ryantrinkle> johnw: no problem :)
12:56:11 <ryantrinkle> nitrix: conal is certainly right about that!  without the fundamentals, things tend to go south pretty quickly
12:56:16 <ryantrinkle> especially FRP :)
12:56:52 <johnw> it query goes in a direction given by a dynamic variable
12:56:56 <johnw> s/query/quickly
12:57:11 <mnoonan> an ivory tower won't stand up unless it has sound engineering :)
13:04:20 <[exa]> nitrix: what's your programming language about anyway?
13:05:47 <[exa]> nitrix: btw. HM-style type systems can be implemented in less than around 100 lines of code
13:07:25 <nitrix> [exa]: Really?! I have a few links to System F and similar. I don't know if you have recommendations to look at?
13:08:19 <[exa]> nitrix: how complicated type system do you need btw?
13:08:40 <[exa]> SystemF can't be inferred efficiently btw
13:09:20 <[exa]> nitrix: Hindley-Milner (wiki article) is a classical starting reading (if you know that there's something like lambda calculus you'll be okay with the wikipedia article)
13:09:38 <mnoonan> ^ can't be inferred at all, isn't it?
13:09:49 <[exa]> nitrix: and also this http://web.cecs.pdx.edu/~mpj/thih/
13:10:39 <[exa]> mnoonan: the last time I checked the answer to question whether SystemF typechecking is decidable was not known.
13:10:54 <nitrix> I was thinking to have the functions be typed, but everything else inferred. There is going to be some form of parametric polymorphism, probably ADTs as well, but the value constructors/destructors (pattern matching) is a little bit less magical than Haskell.
13:11:18 <mnoonan> [exa]: hmm, I though checking was decidable but inference wasn't. digging around now..
13:11:34 <[exa]> oh I'm 20 years behind, it's undecidable.
13:11:42 <mnoonan> :)
13:12:28 <[exa]> checking is decidable with Church-style annotations, not when using unannotated system
13:13:10 <[exa]> but it works in many small non-evil cases
13:13:28 <mnoonan> yeah, it's maximally annoying: it is decidable if you stick in enough annotations, but I don't think there is much known about how much == enough except in specific cases
13:15:13 <[exa]> oh the undecidability.
13:15:44 <motbackwards> does anyone have a good resource on generating typed asts? or for that matter using references for substitution? i'm struggling to do both for a simple hm language
13:16:45 <[exa]> motbackwards: typed as in "each piece of AST has a type" ?
13:16:58 <motbackwards> specifically lambda bindings
13:17:21 <motbackwards> but if i need to do the whole tree, then i'll do the whole tree
13:17:57 <[exa]> church-style lambda allows you to quickly infer the tree around so I guess it won't be needed
13:18:08 <[exa]> why references for substitution?
13:18:18 <motbackwards> that's supposedly more efficient?
13:18:32 <motbackwards> also HMF does it and i'd like a bit better explanation of how exactly it works
13:18:50 <[exa]> hmf?
13:19:16 <motbackwards> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2007-118.pdf
13:20:27 <motbackwards> TAPL makes reference to the fact that most "real" compilers use references instead of substitutions (or some equivalent wording) but I can't seem to find a good resource on doing that
13:21:06 <[exa]> section 6.4 in the article?
13:21:31 <motbackwards> yeah, it's there
13:21:39 <motbackwards> but i'm just not getting it
13:23:36 * hackage mattermost-api 40600.0.0, mattermost-api-qc 40600.0.0, matterhorn 40600.0.0 (JonathanDaugherty): https://qbin.io/tk4lo8s
13:27:46 <[exa]> motbackwards: seems like they replace bound variables simply by pointers. I had a similar thing in one earlier project, you could check that two terms are exactly the same just by comparing the pointers
13:28:50 <[exa]> motbackwards: if you ever read about prolog implementations (warren abstract machines), you'll find something similar
13:28:58 <motbackwards> that's as far as i understand... maybe i just need to take another stab at it
13:29:33 <motbackwards> i had thought about just writing a prolog interpreter to maybe help (as maybe my understanding of unification is what's lacking)
13:29:33 <[exa]> how much code are you going to typecheck? If it's not megabytes I'd just go with plain old (as lazy as possible) substitutions
13:29:50 <motbackwards> in an ideal world all the code
13:30:05 <motbackwards> of course for a personal "toy" language practically none at all
13:30:14 <[exa]> no, like, the magnitude of the input. :D if it's not too big, don't optimize
13:31:04 <[exa]> (a reasonable implementation of substitution structure can be replaced with something better later)
13:31:33 <motbackwards> sure, i just want to fully understand this while i'm working with something small
13:31:46 <motbackwards> adding it later might be more challenging
13:32:06 <[exa]> motbackwards: anyways, difference lists make a good exercise for understanding unification
13:32:34 <[exa]> (in prolog)
13:32:48 <motbackwards> still need a good resource on annotating my lambda bindings
13:32:58 <motbackwards> i'd like to have an explicitly typed core, like haskell has
13:34:13 <[exa]> motbackwards: teaser: You have a list defined as [1,2,3|A]-A. Prolog can put an element to the _end_ of the list in O(1) by unifying A=[3]. Task: write append(+list,+list,-appendedList).
13:34:53 <SpinTensor> Hi
13:35:15 <lambdabot> Hello.
13:35:32 <SpinTensor> so i created this data type and I was able to construct an instance of Show for this type, but I fail to do the same for read.
13:35:51 <metahumor> most of the time, you don't want to actually write Show and Read instances
13:36:12 <SpinTensor> metahumor: why?
13:36:17 <metahumor> usually, deriving Show is adequate, optionally Read
13:36:29 <[exa]> motbackwards: anyway, read TypingHaskellInHaskell, section about explicitly typed bindings (it is a good model, esp. for recursion)
13:36:38 <metahumor> it's considered better to use "pretty-printing" libraries instead of show
13:36:47 <metahumor> and parsing libraries instead of read
13:36:58 <glguy> SpinTensor: the output of Show is expected to be the Haskell syntax for that particular value and Read should match
13:37:20 <motbackwards> exa: I'll take another look, I didn't think I saw what I was looking for when I glanced through before
13:37:41 <SpinTensor> so i should use my print_type and read_type functions instead of constructiong Show and Read?
13:38:04 <glguy> SpinTensor: If you're making a custom format, yes
13:38:10 <[exa]> SpinTensor: if your representation is very different from the Haskell one, it's usually better to separate it.
13:38:13 <metahumor> show and read are expected to be Haskell syntax the same way "__repr__" in Python is supposed to be Python syntax, with "__str__" not necessarily "__repr__"
13:38:33 <SpinTensor> ok. thanks.
13:39:19 <metahumor> that being said, i'm sure the pprinting and parsing libs will make your print_type and read_type functions really sleek
13:39:34 <SpinTensor> metahumor: i will have a look
13:39:48 <[exa]> SpinTensor: Anyway, there's PrettyVal (in Text.Show.Pretty) which should do something like that
13:41:54 <[exa]> motbackwards: I guess that (with exception of some decidability trouble) THIH method is easily customizable to your language, just translate each annotated lambda binding to a let-expression with a single explicit binding.
13:42:46 <[exa]> (anything that concerns typeclasses is still pretty easily removable from there)
13:51:07 * hackage hsdev 0.3.0.1 - Haskell development library  https://hackage.haskell.org/package/hsdev-0.3.0.1 (AlexandrRuchkin)
13:51:45 <motbackwards> exa: so something like (x -> exp) :=> let <fresh> = ([x], exp) in x
13:52:52 <motbackwards> i'm not 100% that's exactly what i want
14:17:07 * hackage weeder 0.1.12 - Detect dead code  https://hackage.haskell.org/package/weeder-0.1.12 (NeilMitchell)
14:41:37 <grokkingStuff> how do you list all types of a data type in a list?
14:41:46 <grokkingStuff> say i have a data type like
14:41:56 <grokkingStuff> data Monkey = Ape | Human
14:42:16 <geekosaur> derive Enum and Bounded, use [minBound .. maxBound]
14:42:28 <grokkingStuff> how do i get list = [Ape,Human] without writing it out myself?
14:42:30 <geekosaur> (this only works if all constructors take no parameters)
14:42:30 <grokkingStuff> geekosaur:
14:42:46 <grokkingStuff> :t minBound
14:42:49 <lambdabot> Bounded a => a
14:42:50 <geekosaur> you could also make a generic binding for that
14:43:01 <geekosaur> yes, and?
14:43:11 <grokkingStuff> oops, meant to say thanks :)
14:43:19 <grokkingStuff> geekosaur: thanks!
14:43:26 <grokkingStuff> ^ missed a macro
14:44:10 <geekosaur> allValues :: (Enum a, Bounded a) => [a]; allValues = [minBound .. maxBound]
14:44:31 <geekosaur> (someone asked about that earlier, iirc. no standard binding like that, but it's easy enough to write)
14:48:40 <Hafydd> > allValues :: [Int]
14:48:42 <lambdabot>  error: Variable not in scope: allValues :: [Int]
14:48:47 <Hafydd> Oh.
14:53:07 * hackage licensor 0.2.2 - A license compatibility helper  https://hackage.haskell.org/package/licensor-0.2.2 (jpvillaisaza)
14:57:54 <joec> is any function of type m a -> m a the identity by parametricity, even though its monadic?
14:59:57 <kadoban> joec: fail comes to mind
14:59:59 <mniip> you have to be more specific
15:00:18 <mniip> forall a m. Monad m => m a -> m a
15:00:19 <mniip> ?
15:00:25 <mniip> assuming common monad laws
15:00:42 <joec> mniip: yep
15:01:02 <joec> forall m a. Monad m => m a -> m a
15:01:13 <mniip> well the argument is slightly more complicated than parametricity here
15:01:22 <joec> I thought so.
15:01:45 <joec> Because it makes sense that forall a. a -> a has a unique inhabitant (id)
15:01:52 <joec> but I wasn't sure about the higher-kinded versions
15:02:46 <jle`> joec: it could be \x -> x >> x
15:02:46 <mniip> following ekmett's argument, we can't do anything with 'm a' other than apply identity morphisms to it
15:02:55 <mniip> thus we're left with
15:03:11 <jle`> :t \x -> x >> x
15:03:13 <lambdabot> Monad m => m b -> m b
15:03:24 <mniip> forall m a. (forall b. b -> m b) -> (forall d e. m d -> (d -> m e) -> m e) -> m a -> m a
15:04:06 <mniip> (plus some extra laws that dictate that some inhabitants of this type are identical)
15:04:22 <jle`> joec: but probably `forall m a. m a -> m a` could only be the identity, which is probably the higher-kinded generalization you were looking for
15:04:47 <joec> So it's the identity in an extensional sense
15:04:48 <mniip> jle`, yeah that much is true
15:05:18 <mniip> even 'forall m. m A -> m A'
15:05:27 <jle`> basically adding a typeclass constraint gives you a bunch of functions you can use to generate the result polymorphically
15:05:27 <mniip> for any A can only be identity
15:05:57 <mniip> as for Monad m => m a -> m a
15:06:06 <mniip> you can look at various expr trees generated with >>= and return
15:06:11 <jle`> like how `forall a. Semigroup a => a -> a` can give you `\x -> x <> x`, since Semigroup has things that return 'a'
15:06:27 <jle`> just look at the things that the typeclass lets you return
15:06:40 <joec> Thanks!
15:07:07 <jle`> trying to think of a common typeclass where `forall a. Foo a => a -> a` could only be id
15:07:14 <mniip> any tree that begins with (return _ >>= _)  is not interesting (has a simpler form)
15:07:31 <mniip> ditto (_ >>= return)
15:07:39 <jle`> 'Show'
15:08:03 <jle`> `forall a. Show a => a -> a` could only be id, since none of the typeclass methods let you return an 'a'
15:08:04 <mniip> jle`, anything that can't produce any 'a's
15:08:35 <jle`> yeah, trying to think of counter-examples i can bring up next time
15:08:40 <jle`> i guess Foldable falls under that too
15:08:51 <jle`> for the higher kinded case
15:08:55 <mniip> Functor
15:08:58 <mniip> under laws
15:09:02 <jle`> ah yeah
15:09:22 <jle`> Functor does return the original type, but, laws
15:10:03 <mniip> ((_ >>= _) >>= _) is also reexpressible as a (_ >>= ...)
15:10:18 <mniip> so the only interesting inhabitants are of the form (x >>= _)
15:10:25 <mniip> well
15:10:28 <mniip> \x -> (x >>= _)
15:10:46 <kadoban> :t const (fail "hi")
15:10:49 <lambdabot> Monad m => b -> m a
15:10:57 <mniip> ehh fail doesn't exist
15:11:04 <kadoban> It really does though :)
15:11:20 <jle`> but does it though
15:11:39 <kadoban> It fails to fail to exist, currently.
15:12:58 <jle`> current roadmap says ghc 8.8
15:13:50 <jle`> i've already started turning on -XMonadFailDesugaring
15:14:17 <jle`> and so should you
15:14:21 <kadoban> Ooo, 8.8, nice.
15:14:26 <kadoban> That's not super long
15:14:51 <kadoban> What happens then, anything you do a non-trivial pattern match, does that require MonadFail then?
15:14:54 <MP2E> especially since GHC releases are supposed to be 6 months apart instead of a year now! :D
15:15:43 <Axman6> kadoban: yeah I think pattern matching will require a MonadFail constraint
15:16:04 <kadoban> Interesting
15:17:33 <jle`> yeah, since it will throw fail from MonadFail
15:17:36 <jle`> instead of from Monad
15:17:45 <jle`> you can already get this behavior with -XMonadFailDesugaring
15:17:56 <jle`> i've already started incorporating MonadFail into my regular programming, it's useful :)
15:18:13 <jle`> especially with instances that obey `fail _ = empty`
15:18:37 <kadoban> I'll have to start thinking about that then
15:18:59 <jle`> Just x <- somethingThatCanReturnMaybe, instead of maybe empty return =<< somethingThatCanReturnMaybe
15:19:55 <jle`> i guess it fills a similar situation as Alternative/MonadPlus, except without <|>/mzero
15:20:25 <jle`> i've begun using it as a generic MonadMaybe class
15:30:32 <lambdaman> Anyone here have clue about the llvm-hs bindings?  I'm currently very frustrated attempting to compile a 'call' instruction with what looks like exactly the right arg and parameter types, only getting assertion about "bad signature" from within llvm.
15:33:37 * hackage servant-pandoc 0.5.0.0 - Use Pandoc to render servant API documentation  https://hackage.haskell.org/package/servant-pandoc-0.5.0.0 (IvanMiljenovic)
15:48:36 * hackage type-combinators-singletons 0.2.0.0 - Interop between /type-combinators/ and /singletons/.  https://hackage.haskell.org/package/type-combinators-singletons-0.2.0.0 (jle)
15:57:20 <dedgrant_> jle`: Does this mean that MonadFailDesugaring will backfill default case matches with "fail"? I've never looked at this.. has Haskell always done this?
15:58:03 <jle`> haskell has always desugared do block pattern matches with 'fail'
15:58:09 <dedgrant_> huh
15:58:25 <jle`> well, 'always' being, since do blocks were invented, minus some turmoil in the beginning briefly
15:58:48 <jle`> that's actually the reason why 'fail' exists in Monad in the first place
15:59:01 <jle`> to handle do block pattern match failures
15:59:14 <dedgrant_> I was never clear on that. Always interesting having a piece click into place.
15:59:27 <jle`> originally it was actually a separate typeclass, and pattern matches in do blocks required the extra constraint, but people got annoyed
15:59:31 <jle`> so they merged the typeclasses
15:59:51 <jle`> dedgrant_: mhm, that's why you see that trick people always do with MonadComprehensions
16:00:05 <Lokathor_> I'm ready to call my latest haskell irc bot a success
16:00:20 <jle`> > [ x | Right x <- [Left True, Right 'a', Left False, Left True, Right 'b', Right 'c'] ]   -- dedgrant_
16:00:23 <lambdabot>  "abc"
16:00:30 <MarcelineVQ> Lokathor_: let me know when you do it
16:01:07 <jle`> dedgrant_: where people take advantage of pattern matching in do blocks/monadic contexts to trigger fail _ = [] or fail _ = Nothing
16:01:13 <Lokathor_> MarcelineVQ, well success in this case only means "it stays connected without stalling out"
16:01:34 <dedgrant_> jle`: all new to me, does seem convenient notation-wise yes
16:01:35 <Lokathor_> So far it's lasted over a week
16:01:39 <MarcelineVQ> that's 80% of what a bot needs to do
16:02:11 <MarcelineVQ> the other 15% being to make unneccesary channel noise and the last %5 is doing something useful
16:02:16 <Welkin> Lokathor_: does it pour beer?
16:02:40 <Lokathor_> It doesn't do anything besides stay connected really. Also i can tell it to disconnect i guess
16:02:48 <jle`> that's the 'hard part'
16:02:57 <Welkin> it doesn't even dance?
16:02:58 <MarcelineVQ> so it does two things? that's pretty good
16:03:34 <jle`> bonus points if you can have it disconnect in other ways besides Ctrl+C in the terminal it's running on
16:03:51 <jle`> (manually sending SIGINT from another process doesn't count)
16:04:08 <MarcelineVQ> bonus bonus points if people who are not you can't tell it to disconnect
16:04:36 <Lokathor_> https://gitlab.com/Lokathor/ekcerto-hs/blob/master/app/Main.hs
16:04:37 <MarcelineVQ> Lokathor_: make it a storytelling robut
16:05:12 <Lokathor_> If someone named lokathor says "foxdie" in the channel #lokathor it will disconnect and shut down
16:05:23 <MarcelineVQ> you're that ninja?
16:05:53 <jle`> hard-coding in the admin, nice
16:05:56 <Lokathor_> Oh wait, i guess anyone can say foxdie :P
16:06:11 <Lokathor_> I didn't set a source on that case
16:06:28 <Lokathor_> Im sure as soon as i get home one of you will have killed it
16:06:38 <MarcelineVQ> Not me, said the dog.
16:06:49 <MarcelineVQ> But another dog who looks just like me.
16:07:12 <Lokathor_> jle` i did the foxdie thing because ctrl+c wasn't working for a while ;P
16:07:34 <jle`> i sent your bot encouraging messages
16:07:37 <jle`> instead of telling it to die
16:08:51 <MarcelineVQ> oh you made your own irc thing? that's neato. I'd try to steal glguy's efforts if I had to do irc stuff
16:10:29 <Lokathor_> Don't worry, i was suitably chided for it
16:10:59 <Lokathor_> I think it was mnipp or someone who acted as if i was quite mad for rolling my own library instead of using the existing one
16:12:36 <Welkin> what?
16:12:43 <Welkin> you didn't write your own operating system?
16:12:46 <Welkin> and your own drivers?
16:12:48 <Welkin> lazy bastard
16:12:54 <Lokathor_> Guilty
16:13:08 <Welkin> you didn't manufacture your own ICs?
16:13:48 <Lokathor_> I programmed that Main.hs by iteratively causing big bangs until the correct file was produced in a suitable universe
16:14:09 <jle`> that explains the ruckus
16:14:12 <jle`> upstairs
16:14:59 <elvishjerricco> Is it proven that `ListT` can't have a `MonadFix` instance anywhere? Specifically the `ListT m a = ListT (m (Maybe (a, ListT m a)))` version?
16:22:15 <Lokathor_> Clearly what i need next is a better logging system for the irc bot
16:26:22 <dxtr> So I just noticed something interesting. I'm using persistent-postgresql and I have a schema where a lot of fields are *NOT* set to Maybe (I.e. NOT NULL)
16:26:52 <dxtr> And now I'm joining tables without getting any result in the "right" one and I get a run-time crash because these fields are coming back as null
16:28:21 <dxtr> That's annoying
16:34:08 <Welkin> dxtr: did you set up the schema and add data to it before running queries through persistent?
16:34:30 <Welkin> put another way, do you have null data in your database?
16:34:43 <geekosaur> I was thinking from that description that it's an outer join
16:36:00 <Welkin> this is why using an ORM without knowing what's it's actually doing it a problem
16:37:36 <dxtr> It is an outer join, yes :)
16:38:26 <dxtr> And no, there's no data in that table. What I basically tried to do is "Fetch account X and also related data in table Y if it exists"
16:38:48 <dxtr> Trying to be smart and do it in one query
16:39:18 <hpc> Welkin: personally i like just writing sql, but that's a whole other conversation
16:40:30 <dxtr> Welkin: What do you mean "without know what it's actually doing"? I am A) Learning B) Watching what it is doing while it is doing it
16:41:19 <Welkin> hpc: in a recent job, I saw what it looks like when people try to write an application in stored procedures
16:41:28 <Welkin> 300+ stored procedures
16:41:37 <Welkin> each one being 20-50 lines
16:41:44 <Welkin> it wasn't pretty
16:41:51 <dxtr> hpc: I prefer writing SQL myself too but right now I'm toying with yesod and persistent and I actually feel like I've learned more Haskell yesterday and today than I did in a month or two last time I was at it
16:41:55 <dxtr> :D
16:42:00 <hpc> ah nice
16:42:09 <Welkin> dxtr: it wasn't meant as a slight against you
16:42:44 <hpc> sometimes all it takes is a comfortable frame of reference
16:42:58 <Welkin> from personal experience, I learned a lot of things the hard way
16:43:09 <Welkin> I started with yesod and used persistent with all the bells and whistles
16:43:18 <Welkin> I recommend starting by writing raw sql
16:43:40 <dxtr> It was easier for me to "get into" it with the fancy yesod-postgres stack template where I didn't have to start with learning all the stuff at once
16:43:53 <Welkin> it's the same reason I don't recommend yesod until you have a very good understanding of how to build it yourself, starting with the basics of http
16:44:42 <Welkin> you can do simple things very easily if you jump right into yesod, but as soon as you encounter a problem, or want to do something that isn't in the book, you will have a hard time
16:44:52 <Welkin> I spent a lot of time reading yesod source code
16:45:21 <dxtr> Yeah I've noticed that! So much searching today
16:45:50 <Welkin> I would start with learning Wai/warp
16:45:53 <Welkin> then move onto scotty
16:45:56 <Welkin> then finally yesod
16:46:10 <Welkin> or, if you want an api server, servant
16:46:41 <Welkin> you won't be bulding a ready-t-go application in an afternoon with wai/warp, but you can get a basic server up and running
16:47:02 <Welkin> yesod is built in wai/warp
16:47:04 <Welkin> on*
16:53:36 * hackage gauge 0.2.1 - small framework for performance measurement and analysis  https://hackage.haskell.org/package/gauge-0.2.1 (VincentHanquez)
16:59:43 <pragmaticmonkey> Hello
16:59:52 <pragmaticmonkey> If the glguy is here I am not gonna talk.
17:00:04 <pragmaticmonkey> Otherwise I am interested in learning how you can land a Haskell job.
17:01:01 <pragmaticmonkey> So how many of you use Haskell as your primary language at work?
17:01:42 <Welkin> glguy is here
17:02:03 <fosskers> Any downsides to using `Data.Sequence`? Seq seems pretty great
17:02:07 <pragmaticmonkey> Can he not be? I think that would be cool.
17:02:14 <Welkin> fosskers: Seq is awesome
17:02:33 <fosskers> like seriously, look at these numbers: https://github.com/haskell-perf/sequences
17:02:41 <Welkin> it can be used as a queue, a list, a double ended queue, a double-ended list
17:03:13 <Welkin> the value of Seq is having constant access to both ends
17:03:46 <Welkin> I have used it as a queue, specifically
17:04:05 <Welkin> although you can use two lists instead, of course
17:04:16 <Welkin> the interfae for Seq is very nice
17:12:38 <pragmaticmonkey> I invested in Haskell and now it is paying off worst than bitcoin. What a mistake!
17:13:01 <Welkin> how much money did you lose?
17:13:03 <parsnip> *worse
17:13:31 <parsnip> that's a simple calculation
17:13:55 <Welkin> each mp3 is worth $1 billion in potential losses
17:14:18 <pragmaticmonkey> Welkin: Exactly, you understand the logic.
17:14:42 <pragmaticmonkey> My every hour is worth $US 1.35 Million in potential losses.
17:15:05 <pragmaticmonkey> So I invested a lot of money.
17:15:20 <ggVGc> pragmaticmonkey: I am using haskell to trade bitcoin!
17:15:27 <ggVGc> so they are not mutually exclusive
17:17:41 <pragmaticmonkey> ggVGc: It is going down. down. down.
17:22:07 <jle`> fairfieldt: i mean, different data structures have different use cases
17:22:35 <jle`> fairfieldt: if you ask for downsides to Seq, you should qualify what use cases you are talking about :)
17:23:20 <Welkin> jle`: but can it run crysis?
17:23:21 <jle`> obv Seq is not good for things it is not meant to do, so in those situations, lists, vectors, etc. are much better
17:23:36 <jle`> there are many use cases where lists/vectors/etc. excel where Seq doesn't
17:23:43 <jle`> but there are many use cases where Seq excels too
17:24:09 <jle`> Welkin: yeah, just make it run a turing tape ;)
17:24:10 <ggVGc> pragmaticmonkey: doesn't matter when you trade it
18:19:20 <ggVGc> just another day in haskell compilation land :( https://i.imgur.com/cfMxdMr.png
18:22:24 <sm> ggVGc: where's the network trouble ?
18:25:08 <ggVGc> in my house :)
18:25:43 <sm> ok, a day in haskell compilation in ggVGc land :)
18:26:28 <ggVGc> well, also my machine isn't as fast as I'd like, and some haskell libraries take a fair while
18:26:43 <ggVGc> and I had to delete my .stack cache and rebuild 210 packages :(
18:26:56 <sm> oh, well that part's common to all of us
18:27:46 <sm> don't you wish for pre-compiled deps
19:20:45 <redrapscallion> what's with the syntax on this super weird snippet? http://lpaste.net/2375336035329507328
19:20:55 <redrapscallion> why does the module refer to itself?
19:21:35 <amalloy> redrapscallion: it's re-exporting aliases to everything in those other modules
19:22:31 <redrapscallion> amalloy: re-exporting aliases? what do you mean by that?
19:22:51 <amalloy> i mean, i don't know anything about these modules. but suppose Foundation has a function named foo
19:22:52 <glguy> import Foundation as Import; import Import.NoFoundation as Import
19:22:57 <glguy> Import is the alias
19:23:35 <amalloy> this Import module is creating an alias Import.foo that clients can use as if it were defined in Import, when really it's defined in Foundation. and it's doing that for all identifiers in those modules
19:23:49 <robertkennedy> Can you write a newtype without exposing coerce? Ie `newtype Password = PW Text`, you only export the type. Can you get to the Text through coerce?
19:24:06 * hackage ListLike 4.6 - Generic support for list-like structures  https://hackage.haskell.org/package/ListLike-4.6 (DavidFox)
19:24:16 <glguy> robertkennedy: What happened when you tried?
19:24:24 <redrapscallion> amalloy: so in other words, this is just a way to import fewer things?
19:24:46 <redrapscallion> amalloy: as in, instead of importing both Foundation and Import.Foundation, I stick them both into Import so that a person only has to import one thing (Import)?
19:26:20 <redrapscallion> err, in less broken English, is it correct to say that the snippet is just merging together imports?
19:32:39 <amalloy> yes
19:34:00 <robertkennedy> glguy: it says the constructor is not in scope. I suppose I thought that another more sophisticated coercion might exist.
19:34:15 <Welkin> robertkennedy: are you the real robert kennedy?
19:35:11 <robertkennedy> Ya
19:49:28 --- mode: ChanServ set +o glguy
19:49:29 --- mode: glguy set -bbbb $a:shouya $a:damd $a:jaarod $a:grlpx
19:49:29 --- mode: glguy set -bbbo $a:DevHC $a:tomodo $a:LunarJetman glguy
19:49:42 --- mode: ChanServ set +o glguy
19:49:43 --- mode: glguy set -qqqq $a:shouya $a:damd $a:jaarod $a:grlpx
19:49:43 --- mode: glguy set -qqqo $a:DevHC $a:tomodo $a:LunarJetman glguy
19:50:42 --- mode: ChanServ set -q $a:gio123
19:54:17 <conal> I'm looking for a Hackage package that defines functor-level Show, Eq, etc. I think the classes are called Show1, Eq1, etc. Anyone remember?
19:54:29 <glguy> That's in base now
19:54:39 <glguy> Data.Functor.Classes
19:54:46 <glguy> there was also prelude-extras
19:54:51 <conal> glguy: Thanks!!
19:55:41 --- mode: ChanServ set -q SpazSlayer!*@*
19:56:03 <dzdcnfzd> I'm trying to decipher the declaration here: https://hackage.haskell.org/package/servant-0.11/docs/Servant-Utils-Enter.html#t:Entered
19:56:44 <glguy> dzdcnfzd: What aspect of it?
19:58:02 <dzdcnfzd> Well, two things: One is that while I've read this (https://wiki.haskell.org/GHC/Type_families#What_are_type_families.3F) type families article, it doesn't seem to describe what's going on here, so I don't really understand what the type family declaration means
19:58:27 <dzdcnfzd> A second is that in the class definition below, I don't understand the syntax even. I don't know what ~ means, for instance.
19:58:42 <glguy> a ~ b  is the constraint that a and b are the same type
19:59:31 <glguy> So when you're using that class "Enter" then it must be the case that the type that (Entered m n typ) evaluates to must be equal to the type that (ret) is
19:59:58 <glguy> The 4 clauses under the type family declaration tell you how the Entered type family evaluates when applied to certain types
20:00:13 <glguy> For example (Entered m n (m a)) would evaluate to (n a)
20:00:26 <glguy> You can experiment with this in GHCi using :kind!
20:01:08 <glguy> The :kind! variation of :kind not only gives you the kind of a type, but also evaluates type families
20:02:38 <glguy> Sometimes in Haddock you will see “(~) * a b”, this extra * is hanging around due to a bug that causes implicit kind parameters to be printed like normal arguments
20:03:05 <dzdcnfzd> glguy: so Entered is sort of a type-level class
20:03:07 <glguy> it really means the constraint “(~) a b” which is “a ~ b”
20:03:12 <dzdcnfzd> with 4 associated functions
20:03:21 <glguy> it's a type-level function with 4 associated clauses
20:04:03 <glguy> What makes it different from other type level functions as potentially introduced by data or newtype is that it doesn't introduce a new type distinct from the previous ones
20:04:10 <glguy> It's more like a type synonym in this respect
20:04:33 <glguy> The difference between this and a type synonym is that a type synonym can't behave differently due to its arguments
20:04:55 <dzdcnfzd> I think I understand that, which I didn't before
20:04:57 <dzdcnfzd> that's cool
20:06:05 <dzdcnfzd> In the first instance defined under the section called "servant combinators", there's a bunch of clauses like "instance (...) => Enter ... where ..."
20:06:15 <dzdcnfzd> What are those instances of?
20:06:17 --- mode: ChanServ set +o glguy
20:06:17 --- mode: glguy set -b *!*@unaffiliated/skraito-0x71
20:07:04 <glguy> They are instances of whatever type class follows the =>
20:09:09 --- mode: glguy set -b *!*irn4l@*unaffiliated/irn4l
20:09:36 <Welkin> glguy: what happened with that monkey guy and you?
20:09:40 --- mode: glguy set -b *!*@unaffiliated/lepalestineface
20:10:32 <glguy> not much, chatted in PM shortly and he moved on
20:11:04 <dzdcnfzd> Cool! one last question: I've just upgraded my servant library, and I haven't been able to get my server compiling yet. This is the relevant code and error: http://lpaste.net/6105970196575420416
20:11:31 <dzdcnfzd> I'm not asking for it to be fixed, but i actually don't understand quite what it's telling me
20:12:32 <dzdcnfzd> It says     • Couldn't match type ‘ExceptT ServantErr IO ()’ with ‘Handler ()’ but I don't know what it expected to be a ‘ExceptT ServantErr IO ()’ and what it expected to be a ‘Handler ()’
20:13:22 <Welkin> glguy: he "moved on" to the next life?
20:14:09 --- mode: glguy set -bbbb *!*@unaffiliated/xsperry *!*auwooo@*unaffiliated/skraito-0x71 *!*redocdam@unaffiliated/redocdam *!*@unaffiliated/turtlesauce
20:14:09 --- mode: glguy set -b *!*Quix0te@unaffiliated/quix0te
20:21:37 * hackage yam-app 0.1.11 - Yam App  https://hackage.haskell.org/package/yam-app-0.1.11 (leptonyu)
20:21:54 * parsnip read backscroll of blocks
20:21:59 <parsnip> *reads
20:22:16 --- mode: glguy set -bbbb ownchooda!*@* unsafeCoerce!*@* pozic!*@* Xochipilli*!*@*
20:22:16 --- mode: glguy set -bbbb edtoast_*!*@* away_!*@* gio123!*@* kunwon*!*@*
20:22:16 --- mode: glguy set -bbbb hammond!*@* Quix0te!*@* ilikepotatostoo!*@* banisterfiend!*@*
20:22:16 --- mode: glguy set -bbbb [LINKEDINLOGSRZA!*@* vote_vis_systemd!*@* Maxuma!*@* Vbet!*@*
20:22:17 --- mode: glguy set -bbbb mark44!*@* chare!*@* jimmyray!*@* witz!*@*
20:22:18 --- mode: glguy set -bbbb spanish_horse!*@* progster!*@* circ-user-v8z6i!*@* *Malix*!*@*
20:22:19 --- mode: glguy set -bbbb leo_31*!*@* spiridondon!*@* cincoxd!*@* jolesdo!*@*
20:22:20 --- mode: glguy set -bbbb chocolaate-maan!*@* mix2011!*@* stopm!*@* yuupers!*@*
20:22:21 --- mode: glguy set -b fujisan1!*@*
20:26:57 <Welkin> a vegetable can't read!
20:30:37 * hackage yam-servant 0.1.11, yam-transaction-postgresql 0.1.11 (leptonyu): https://qbin.io/jzz6wfgbc
20:35:44 <dmwit> dzdcnfzd: I suspect that this error is saying that `enter` is expecting an argument with a type like `ReaderT Config IO :~> Handler` instead of `ReaderT Config IO :~> ExceptT ServantErr IO`. But it's tough for me to say for sure because I'm not familiar enough with servant to know what some of these pieces are (and I'm too lazy to look them up).
20:36:31 --- mode: glguy set -b *!~reinis@wikipedia/reinis
20:37:38 <glguy> For those wondering, there were a bunch of stale bans going back into 2011 filling up the list. I'm just cleaning up
20:38:37 <glguy> most of the accounts didn't even exist on nickserv any more, if you want to talk about something related to the cleanup you can join #haskell-ops
20:46:19 <dzdcnfzd> dmwit: That's right, I think. I finally fixed the errors by wrapping the ExceptT in a Handler
20:46:36 <dzdcnfzd> The question, for me, as a dev, is how I was supposed to figure that out from the error and the docs
20:47:14 <dmwit> 1. see 1000 errors
20:47:19 <dmwit> 2. fix 1000 errors
20:48:02 <dzdcnfzd> Yes, so is dev life :) But in this case, I mean specifically because there were type family things involved
20:48:06 <glguy> see 99, fix 1, see 105
20:48:09 <dmwit> I dunno. I actually find GHC error messages pretty understandable. They are generally very precise.
20:48:13 <dzdcnfzd> Given https://hackage.haskell.org/package/servant-0.11/docs/Servant-Utils-Enter.html#v:enter
20:48:19 <dmwit> I do need to take it slow, though.
20:49:02 <glguy> dzdcnfzd: One strategy is not to try and fit into much on a single line
20:49:12 <glguy> break up your definition into separately named, and understandable parts
20:49:23 --- mode: ChanServ set -o glguy
20:49:25 <dmwit> dzdcnfzd: What type family?
20:49:40 <dzdcnfzd> What I feel I have difficulty understanding is the type of the function enter
20:49:40 <dmwit> ...I don't see any type families in that error.
20:49:51 <dzdcnfzd> enter :: (m :~> n) -> typ -> ret
20:50:00 <dzdcnfzd> class (Entered m n typ ~ ret, Entered n m ret ~ typ) => Enter typ m n ret | typ m n -> ret, ret m n -> typ, ret typ m -> n, ret typ n -> m where
20:50:13 <dzdcnfzd> Where Entered is a type family
20:50:20 <dmwit> I do not believe enter has the type you just said.
20:50:29 <dzdcnfzd> https://hackage.haskell.org/package/servant-0.11/docs/Servant-Utils-Enter.html#v:enter
20:50:33 <dmwit> I expect at the very least to see a `=>` in there somewhere.
20:51:02 <dmwit> Yes, so `enter :: Enter typ m n ret => (m :~> n) -> typ -> ret` is the correct type for `enter` when not inside a class declaration `where` block.
20:52:08 <dmwit> I admit this is slightly confusing, but it would be incredibly inconvenient to have to repeat the class context on every line of a class declaration...
20:52:16 <dmwit> So it's allowed that you omit it.
20:52:45 <c_wraith> is it allowed to include it?
20:52:51 <dmwit> Let's find out!
20:53:00 <dmwit> % class Test a where test :: Test a => a
20:53:00 <yahb> dmwit:
20:53:02 <glguy> You can always add more constraints
20:53:11 <dzdcnfzd> Yes, I'm just... I understand the syntax
20:53:13 <dmwit> Yes, it's allowed!
20:53:36 <dzdcnfzd> What I'm saying is that I'm not making the instance declaration for Enter, right?
20:53:37 <c_wraith> Huh.  I didn't realize that was allowed.  Now, about why -XInstanceSigs isn't the default...
20:53:49 <dzdcnfzd> so I don't know a priori what typ and ret are
20:54:06 <dzdcnfzd> I know what m and n are, because I'm specifyin them
20:54:40 <dmwit> The class declaration says that knowing any three of `m`, `n`, `typ`, `ret` tells you the fourth.
20:55:07 * hackage ats-format 0.1.3.0 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.3.0 (vmchale)
20:55:09 <dmwit> Presumably you know what one of `typ` or `ret` is because you are either applying `enter` to a second argument whose type you know or are using the result of `enter` at a type you know.
20:55:26 <dmwit> (If neither of those hold, I would expect to see an ambiguous type error.)
20:55:34 <dmwit> (N.B. you may know a polymorphic type)
20:55:51 <dzdcnfzd> I see
20:56:19 <dzdcnfzd> Okay. I'll work on that
20:57:05 <dmwit> Right, so, in your example, you know that `ret` is `Server Api`.
21:10:03 <dzdcnfzd> thanks!
21:27:39 <allen-> hi all, what's the state of cloud haskell these days? It doesn't look like it's gotten much activity in the last year or so. Is that because it's reached the point of stability, or have people just kind of given up interest?
21:28:17 <allen-> (by "cloud haskell" I'm referring to the haskell-distributed project, not just using haskell in the cloud)
21:32:27 <c_wraith> I know there are future plans for it that require additional support in GHC.  It's possible that development has stalled waiting for those.
21:39:46 <royal_screwup21> what's the difference between "instance Num n => Monoid (Sum n) where" and "instance Monoid (Sum n) where"
21:40:06 <tolt> does anyone know why GHC.TypeLits uses integers for Nat things? Why isn't Natural used?
21:44:21 <Welkin> royal_screwup21: just what it says. n must be an instance of Num in the first case, but n can be anything in the second
21:45:36 * hackage yam-job 0.1.12, yam-job 0.1.11 (leptonyu): https://qbin.io/7f9jlzvk
21:49:59 <dmwit> tolt: Natural is new in 4.8; most of the stuff in GHC.TypeLits predates that.
21:50:13 <tolt> Ah, that's what I assumed! Thanks
21:50:28 <piyush-kurur> has anyone tried programming at the IP layer with raw sockets in Haskell
21:50:46 <piyush-kurur> I want to write some demo code that works at the IP layer like ping
21:50:55 <piyush-kurur> Would prefer to write it in Haskell than C
22:05:34 <Disavowed> Evening all. Should .stack-work/ be in my .gitignore?
22:05:48 <glguy> yes
22:05:50 <c_wraith> royal_screwup21: at the level of authoring an instance, the former allows you to use definitions that require n to be an instance of Num.  The latter does not.
22:06:31 <glguy> Disavowed: Lots of things to consider ignoring: https://github.com/glguy/irc-core/blob/v2/.gitignore
22:06:35 <c_wraith> royal_screwup21: Since that particular Monoid instance is going to be adding things and summoning zero values, it really helps to be able to use numeric functions like (+) and fromInteger
22:09:27 <Disavowed> glguy: Oh wow! This is now my Haskell .gitignore bible. Thank you so much!
22:14:36 <tolt> Disavowed: I completely agree with glguy's .gitignore but if you're looking for something in the future you might look towards https://github.com/github/gitignore for other languages
22:18:00 <Disavowed> tolt: Excellent call; appreciate it!
22:20:05 <Disavowed> I think I'm going to attempt writing an API client. Any library recommendations for HTTP requests? I'm a beginner if that helps.
22:21:31 <tolt> Disavowed: I'd recommend Wreq https://hackage.haskell.org/package/wreq but it uses lens which might get complicated if start need to do complicated things with the responses
22:22:08 <tolt> err, it kind of depends on what kind of client you are writing. If it's a simple command line thing then I'd recommend wreq
22:23:42 <Disavowed> tolt: Yes exactly that. This looks much less scary than I was expecting - thank you! Good opportunity to understand lens too.
22:24:50 <tolt> there's a nice tutorial too https://hackage.haskell.org/package/wreq
22:25:26 <tolt> Disavowed: it's worth noting that if you're going to have something like set cookies being sent to you, you should look at http://www.serpentine.com/wreq/tutorial.html#session
22:25:46 <tolt> I hope it goes well!
22:28:05 <Disavowed> tolt: Honestly I can't thank you enough - this is the perfect introduction to the language and the community. Thank you so much for your pointers - you've massively improved my evening!
22:28:22 <tolt> :) Glad to hear it.
23:24:27 <sqooq> hi
23:37:08 <MADERO> ciao
23:38:15 <sqooq> why emacs
23:38:24 <sqooq> what haskell thing to use
23:39:33 <parsnip> all of them
23:39:46 <parsnip> paper and pen
23:40:32 <Lowl3v3l> sqooq: why not emacs? its pretty epic for functional programming. Why change a working system? ;)
23:42:06 * hackage ats-format 0.1.3.1 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.3.1 (vmchale)
23:43:11 <sqooq> Lowl3v3l, because it's not unix-like, it's overloaded, it's messy, it's too much work for a silly text editor, etc.
23:44:09 <tdammers> one of the nice things about haskell is that the language is sufficiently expressive and concise so that you don't need a lot of editor support
23:44:28 <sqooq> exactly, so why use emacs?
23:44:34 <sqooq> why not leafpad
23:44:40 <tdammers> my point is, use whatever you're comfortable with
23:44:42 <sqooq> why not nano
23:44:53 <tdammers> you could
23:45:10 <Uniaika> I did, once. :(
23:45:34 <tdammers> but something a bit more powerful on the generic text editing front is going to be helpful still
23:51:49 <[exa]> can emacs automatically move indentation blocks when I type so that it changes the indentation?
23:55:05 <Lowl3v3l> i use emacs because it is way superior to "easier texteditors" in the possible customizations, the search features and the support for ide modules...
