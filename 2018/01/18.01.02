00:05:27 <osa1> is there an IRC channel for reflex/reflex-platform etc. ?
00:08:13 <geekosaur> #reflex-frp
00:09:34 <osa1> ty
00:17:22 <mniip> lyxia, no I don't think the assumption is strong enough
00:18:06 <mniip> you should upgrade it to at least
00:18:08 <mniip> get >> x = x
00:18:54 <mniip> and then mention something about the continuations in get >>= k
00:20:27 <mniip> tbqh I don't see a way to equationally describe state other than via operational semantics
00:26:14 <mniip> probably because there's non-structural equational rules
00:26:32 <mniip> I mean things like
00:26:47 <mniip> set s >> x = x >> set s, if x is free of 'get'
00:26:58 <mniip> but that's freeness is tricky to define
00:27:02 <lyxia> right
00:28:07 <lyxia> I don't see how get >> x = x makes things better for my implication though.
00:28:14 <mniip> it doesn't
00:28:24 <mniip> just saying that get >> get = get is weak af
00:29:11 <mniip> so the only way forward I see is propagation of runStateT
00:29:19 <lyxia> It doesn't seem so bad to me intuitively.
00:29:46 <lyxia> get >> get = get  implies informally that the result of the second get should be the same as the first one
00:29:54 <mniip> no
00:29:56 <lyxia> which is what my second equation makes more explicit
00:32:06 <mniip> okay maybe
00:32:33 <mniip> if we're working in a MonadState s m => m ()
00:33:25 <lyxia> I do mean (get :: m s)
00:33:57 <mniip> then we can say something like
00:35:12 <mniip> every action is either 'state f', 'lift m', or on a layer "below" StateT
00:35:53 <mniip> in particular, every non-StateT instance to MonadState is a 'lift'
00:36:15 <mniip> so for a fixed m, we have a fixed liftToState = lift . lift . ... . lift
00:36:58 <mniip> hmm, tricky
00:37:48 <mniip> it can also be a mix
00:38:06 <mniip> well only if it's composite
00:38:25 <mniip> lyxia, okay step 1 - translate mtl into transformers
00:39:12 <mniip> realize that  Mtl.get is actually lift . lift . ... . lift $ Transformers.get
00:39:27 <mniip> then use the lift homomorphity laws
00:39:55 <mniip> and then you can formulate laws in terms of 'state' and 'lift'
00:40:22 <mniip> state s >> lift x = lift x >> state s
00:40:38 <lyxia> That way I get the laws that StateT satisfies
00:41:10 <lyxia> I don't know what to think of   Mtl.get = lift . ... . lift $ get   yet
00:45:14 <mniip> okay, proof by induction that for every 'MonadState s m => m' exists a function l, such that state = l . state,
00:45:52 <mniip> and such that l (return x) = return x; l x >>= (l . k) = l (x >>= k)
00:46:01 <lyxia> l = id
00:46:05 <mniip> no
00:46:12 <mniip> I mean state = l . Transformers.state
00:48:25 <mniip> the functions for which "l (return x) = return x; l x >>= (l . k) = l (x >>= k)" make up a category
00:49:22 <mniip> with generators id and various specializations of lift
00:49:31 <mniip> well no, id wouldn't be a generator
00:49:33 <mniip> it just is
00:49:45 <lyxia> Yeah
00:51:27 <mniip> so yeah, Mtl.state always decomposes into composition of Transformers.state and a morphism from the category of elevators
00:52:13 <lyxia> And whoever writes a MonadState instance should preserve that?
01:00:30 <lysgaard[m]> I have a constrained GADT, and having problems using normal instance deriving on it. I'm not to used to these more fancy type features and I guess there is something I am missing. I've got an example of the problem here: http://lpaste.net/9030550553842679808
01:01:01 <lysgaard[m]> It requires constraints >= 0.8
01:02:52 <lyxia> what's wrong?
01:03:15 * hackage tasty-discover 4.1.3 - Test discovery for the tasty framework.  https://hackage.haskell.org/package/tasty-discover-4.1.3 (lwm)
01:03:17 <geekosaur> "You cannot use a deriving clause for a GADT; only for an ordinary data type."
01:03:44 <Cale> Yeah, you have to write instances for GADTs yourself, or write Template Haskell macros to generate them
01:03:54 <lyxia> Can't standalone deriving can generate the right code for some GADTs
01:04:02 <lysgaard[m]> Really?
01:04:39 <lysgaard[m]> From my limited experience it is hard to understand why.
01:04:48 <lyxia> I mean I thought it was possible
01:04:56 <mniip> standalone deriving requires on the adequacy of the constructors wrt inferring what constraints are required here and there
01:04:57 <geekosaur> looks like it will try, but if it breaks then you get to keep the pieces
01:05:17 <mniip> relies on*
01:05:26 <mniip> s/standalone//
01:05:29 <lyxia> well this GADT looks straightforward.
01:05:30 <geekosaur> there's been discussion of trying to make it smarter, but in the presence of GADT-induced existentials this is difficult to get right iirc
01:05:33 <lyxia> lysgaard[m]: what error do you get
01:05:39 <mniip> lyxia, to you
01:05:59 <mniip> the compiler cannot infer the disjointness of IsIn and Eq
01:06:28 * lysgaard[m] sent a long message: lysgaard[m]_2018-01-02_09:06:05.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/hcXcUYNbAOBaiSCEDCVLmviW>
01:06:50 <mniip> dammit matrix
01:07:06 <mniip> lysgaard[m], oh
01:07:09 <mniip> that's just a kind error
01:07:09 <lysgaard[m]> Sorry, does matrix mess up something?
01:07:10 <lyxia> just remove Eq l
01:07:21 <mniip> you don't need nor can have an Eq l
01:07:45 * hackage quickcheck-arbitrary-adt 0.3.0.0 - Generic typeclasses for generating arbitrary ADTs  https://hackage.haskell.org/package/quickcheck-arbitrary-adt-0.3.0.0 (mchaver)
01:08:10 <lysgaard[m]> mniip:  Ah, you're right, that works :) That was unexpected for me.
01:09:06 <Marisa_> Hi, are there any frp library that have an event for mousestroke :: Time -> Event [(Int, Int)] (Or something similar?) I tried doing it in threepenny, but cant find anyway...
01:10:41 <lyxia> lysgaard[m]: have you tried the Data Types à la Carte approach too?
01:12:22 <mniip> 1514883111 [11:51:51] <lyxia> And whoever writes a MonadState instance should preserve that?
01:12:28 <mniip> yeah or they'll get dirty looks
01:12:56 <mniip> I mean effectively MonadState has 2 base instances: StateT and RWST, and a bunch of induction instances
01:13:11 <lysgaard[m]> lyxia: no I have not. Just had a small look at it. I am building a compiler, and struggeling with different passes in the compiler needing different ASTs, and now I suddenly have to write enormous amounts of code to translate between them, or I have to accept just one monolithic data type that has a lot of unused parts all the time. Any good solution to this kind of problem would be greatly appreciated.
01:13:24 <mniip> where induction instances are just full of lifts
01:14:05 <lyxia> mniip: I see, thanks, I was missing that bit.
01:14:30 <mniip> lysgaard[m], GHC seems to parameterise its AST
01:14:38 <mniip> maybe you could have that too
01:15:31 <mniip> and I mean not necessarily using type families
01:18:29 <lyxia> Marisa_: you might have more luck at an answer directly on threepenny's issue tracker
01:19:54 <Marisa_> Yeah I already did... However HeinrichApfelmus seems to be not there :( I think I might have better luck on r/haskell..
01:21:24 <lyxia> :(
01:22:00 <MarcelineVQ> sure are lots of threepenny questions lately
01:23:17 <lysgaard[m]> mniip: you mean standard polymorphic type parameters?
01:23:42 <mniip> yes
01:24:32 <mniip> you could have 'Expr let dub a'
01:24:55 <mniip> with Let :: let -> Expr let dub a -> Var -> Expr let dub a -> Expr let dub a
01:25:17 <mniip> and then you could set let~Void to exclude Let constructors on some stage
01:25:51 <lysgaard[m]> mniip: I'm not sure that would scale, I would end up having a type parameter for each constructor in expr.
01:29:11 <mniip> well then the type family constraint is an alright replacement
01:31:50 <lysgaard[m]> mniip: Another challenge I have is this. My constructors change types during different passes. Eg. `Case :: Expr -> [(Pattern, Expr)] -> Expr` turns into `Case :: Var -> [(Pattern, Expr)] -> Expr`. The discriminator of the case becomes explicitly named.
01:32:57 <mniip> sounds like you could use a phased CaseDiscriminator constructor?
01:43:22 <asheshambasta> Hey guys, I've been reading RWH for a while now and found the book lacking for a beginner. I really like LYAH (the bit on applicatives and Monads was quite fascinating) and would like to buy the paperback (to show my appreciation and to read from a book and not a screen). However, I see that the latest edition is 2011. Is it as up-to-date as the online version? I found many issues with code snippets in RWH.
01:46:56 <vaibhavsagar> asheshambasta: have you had a look at haskellbook.com?
01:47:54 <asheshambasta> vaibhavsagar: yes, but thats again an e-book no?
01:48:24 <vaibhavsagar> hmm, you're right
01:48:37 <vaibhavsagar> I forgot that the physical copy wasn't out yet
01:48:40 <asheshambasta> I'd really want something on paper
01:49:06 <asheshambasta> what I'm doing now is combining RWH with LYAH — and thats a great combination to learn from.
01:49:07 <Marisa_> BTW, how to prove, using theorem for free, forall F . F Int -> F Bool is uninhabited? (assuming no bottom)
01:49:39 <asheshambasta> in fact — when RWH's code snippets don't work as expected, its often interesting to learn why
01:49:44 <lyxia> Marisa_: it's not inhabited
01:49:59 <Marisa_> Yep, I know, but how to prove it using theorem for free?
01:50:36 <lyxia> ah sorry I misread "uninhabited"
01:50:45 <mniip> well its parametricity theorem is that
01:50:45 <Marisa_> np :)
01:51:19 <lyxia> You don't need free theorems though. Just show a type F for which such a function may not exist.
01:51:25 <mniip> hmm
01:51:57 <mniip> I want to say, for all m :: forall a. f a -> f' a, m . f = f . m
01:54:28 <mniip> I think that's not strong enough
01:54:47 <mniip> the real statement should be stronger because f is really a profunctor
01:54:55 <mniip> but that might be inexpressible in haskell
01:55:33 <Marisa_> System F-omega :)
01:55:38 <mniip> still not
01:56:55 <Marisa_> So we can not show Lebiniz Equality of Int and Bool is uninhabited in F-omega?
01:57:15 <mniip> okay, here's an attempt
01:57:55 <mniip> suppose g :: forall f . f Int -> f Bool
01:59:07 <mniip> then for any p, q, for any m :: forall a b. (Profunctor p, Profunctor q) -> p a b -> q a b
01:59:27 <mniip> j m . g = g . j m
01:59:34 <lseactuary> hello everyone. happy new year!
01:59:46 <mniip> where j :: (p a a -> q b b) -> Join p a -> Join q b
01:59:49 <mniip> defined evidently
02:00:27 <mniip> I suspect you can just inline j into m
02:00:44 <mniip> "for any m :: forall a. (Profunctor p, Profunctor q) -> Join p a -> Join q a"
02:03:55 <mniip> now suppose p ~ Endo, q ~ Identity
02:04:02 <mniip> hrm no
02:04:17 <mniip> m needs to be parametric itself
02:05:24 <lyxia> Marisa_: can't you reason about normal forms and show that there is none of that type
02:06:21 * Marisa_ get losted trying to read mniip
02:06:29 <mniip> frankly I got lost myself
02:45:41 <Marisa_> lyxia, stuck at F :: * -> *, fint :: F Int |- _ : F Bool
03:01:27 <lyxia> Marisa_: depending on the calculus, the next step is to see that there are no compatible typing rules other than the one for variables, and there is no matching variable, therefore there is no way to complete the derivation.
03:02:06 <Marisa_> F-omega let's say
03:02:35 <Marisa_> now the next step is reducing F Bool, but it cant be done..
03:33:01 <tsahyt> when using a custom monad via natural transformations with servant, do I have to add my own ExceptT ServantErr to get back the throwing functionality?
03:33:16 <tsahyt> servant-server that is of course
03:38:45 * hackage hspec-golden-aeson 0.5.0.0 - Use tests to monitor changes in Aeson serialization  https://hackage.haskell.org/package/hspec-golden-aeson-0.5.0.0 (mchaver)
03:49:41 <Rembane> tsahyt: So you have a completely custom monad, you don't use their transformer stack as a part of your transformer stack?
03:56:24 <alp> tsahyt, if you want the ability to throw errors in your handlers, you need _some_ way to express that in your monad. A typical way is to use 'ExceptT' but with a custom, business-oriented error type (data AppError = UserNotFound UserId | ProductAlreadySold ProductId), and then do the "error translation" (from error to http status codes & responses) in the natural transformation
03:56:45 <tsahyt> Rembane: well if I add the ExceptT I have reproduced their stack
03:57:10 <tsahyt> alp: ah I didn't think of custom errors yet
03:57:22 <tsahyt> I just ended up adding ExceptT ServantErr for now
03:57:29 <Rembane> tsahyt: Indeed.
03:57:53 <Rembane> tsahyt: Out of curiosity, how come you don't add to their transformer stack?
03:58:30 <tsahyt> Rembane: I just didn't think of it when I started out last night. but it's not like the stack is anything particularly intresting, it's just ExceptT ServantErr IO
03:58:34 <alp> tsahyt, well ExceptT ServantErr is the same idea, except that 1/ the errors are more cumbersome to write from within your handlers 2/ the error translation logic is 'id'
03:58:46 <tsahyt> Rembane: when I started I was mostly thinking of getting the database aspects into my stack
03:58:52 <Rembane> tsahyt: Indeed, that's why. :)
03:59:50 <Rembane> tsahyt: Cool.
04:11:26 <holycleugh> I'm having trouble understanding a compiler warning for redundant expressions. I'm trying to match a Text against two possibilities or _, but the compiler says the latter two cases are redundant
04:11:33 <holycleugh> segment of code is at https://hastebin.com/yodebaguco.hs, I can give more context if necessary
04:11:48 <holycleugh> (userId, sender, and contacter are all Texts)
04:12:35 <wz1000> how out of date is Peyton Jones 1987 Implementation of Functional Programming Languages?
04:12:47 <mniip> holycleugh, you're matching userId against "sender" which is a pattern that always matches
04:12:52 <mniip> and binds the value to the variable "sender"
04:13:14 <holycleugh> mniip: why does it always match?
04:13:22 <mniip> for the same reason as 'x' does
04:13:50 <mniip> x = 3
04:13:51 <ane> I guess holycleugh is trying to match on the value of "sender", but that doesn't work
04:13:52 <mniip> f x = x
04:14:13 <mniip> yeah I can see what they're trying to do, just trying to explain what is going on
04:14:35 <WinterFox[m]> What does it mean when a function parameter has a type with two words like `Entity User`?
04:15:11 <mniip> WinterFox[m], Entity is a parameterised datatype
04:15:15 <mniip> User is its parameter here
04:16:06 <mniip> holycleugh, basically, patterns introduce new variables, they don't try to equate with currently existing variables in scope
04:16:07 <holycleugh> mniip: ok I think I get it now, the original sender variable is shadowed?
04:16:10 <mniip> yes
04:16:42 <holycleugh>  should I do case userId of _ | userId==sender -> ...?
04:17:00 <mniip> that's kinda verbose
04:17:10 <holycleugh> or just if statements?
04:17:19 <mniip> you could use guards on the definition of contact'
04:17:36 <mniip> let contact' | userId == sender = ... | userId == contacter = ... in ...
04:18:27 <holycleugh> oh I didn't know that was allowed
04:18:29 <holycleugh> mniip: great, thanks
04:18:44 <mniip> why wouldn't it be
04:19:29 <holycleugh> tbh I'm not too clear on the syntax regarding guards at all
04:20:30 <ane> is there a shorter way of doing this: do x <- foo; y; return x
04:20:35 <holycleugh> just checked lyah and it makes sense though
04:20:40 <mniip> ane, x <* y
04:20:45 <hpc> foo <* y
04:20:49 <mniip> err eys
04:20:51 <mniip> foo <* y
04:20:59 <ane> oh yes starships to the rescue
04:21:15 <mniip> liftA2 const foo y
04:22:36 <mniip> holycleugh, well "f x y | x == y = z" makes sense, as does "f x | x == 3 = z"
04:22:43 <mniip> so why not "f | p = z"
04:24:34 <mniip> > let x | x = x in x
04:24:36 <lambdabot>  *Exception: <<loop>>
04:24:46 * hackage wild-bind-task-x11 0.2.0.1 - Task to install and export everything you need to use WildBind in X11  https://hackage.haskell.org/package/wild-bind-task-x11-0.2.0.1 (debugito)
04:25:34 <mniip> > let x @ y | x = y in x
04:25:37 <lambdabot>  *Exception: <<loop>>
04:26:44 <holycleugh> mniip: right, it just looked a bit odd at first
04:53:36 <royal_screwup21> I've written an intermediary function that takes a list and an Int, then returns the same list with the Int appended to it as long as the Int is not equal to the last element of the list. Here's what I tried: https://thepasteb.in/p/j2hlmJEqlGWsP The compiler throws an error "parse error on input =" How do I fix this?
04:54:19 <mniip> missing a 'where'
04:54:34 <dminuoso> royal_screwup21: https://gist.github.com/dminuoso/b831ab6c9a059dbc5c0e456ef3df8a84
04:54:44 <royal_screwup21> shite
04:55:21 <dminuoso> mniip: This is something that has tripped me up quite often. Why does Haskell has such poor diagnostics on parse errors?
04:55:38 <dminuoso> So frequently I get errors like "parse error on input ..." that really don't tell me.. anything.
04:55:50 <mniip> producing useful errors is hard
04:56:09 <mniip> it tells you the first place where it couldn't make sense of it
04:56:20 <mniip> it can't magically tell at what exact point you missed a token
04:56:22 <NickHu_> Is there a way to search hoogle for constructors of kind * -> *?
04:56:50 <mniip> NickHu_, what for?
04:58:11 <NickHu_> Trying to define open type family instances for things in prelude
04:58:35 <mniip> %% :browse Prelude
04:58:36 <yahb> mniip: http://qp.mniip.com/y/37
04:58:39 <NickHu_> Things like Maybe, IO, ((->) a), ((,) a), but I want to be sure I cover them all
04:58:46 <NickHu_> Either a
04:58:56 <mniip> there isn't so much
04:59:21 <NickHu_> Well, there are all 62 sized tuples
04:59:33 <mniip> those aren't Prelude
04:59:45 <mniip> (neither is (->) or [])
04:59:54 <NickHu_> Okay, I mean base then
05:00:03 <mniip> oh that's much broader
05:00:13 <mniip> and no, I meant (->) and [] are built-in syntax
05:00:26 <mniip> not regular identifiers
05:00:56 <NickHu_> right, nonetheless I still want to provide a type instance for them because they have kind Type -> Type
05:02:29 <mniip> this is a good place to start https://hackage.haskell.org/package/invariant-0.5/docs/Data-Functor-Invariant.html
05:08:09 <NickHu_> It should be possible to use Template Haskell to generate something like type instance F ((,) _) = 'False; type instance F ((,,) _ _) = 'False for n-ary tuples right?
05:08:56 <mniip> yes
05:12:32 <mniip> gimme a minute
05:19:56 <mniip> $(traverse return [TySynInstD ''F (TySynEqn [iterate (`AppT` WildCardT) (TupleT i) !! (i - 1)] (ConT 'False)) | i <- [2..62]])
05:19:59 <mniip> should do the trick
05:20:13 <mniip> can't test it on yahb because you can't really splice declarations in ghci
05:23:53 <NickHu_> mniip: Wow, that works great! Thanks
05:24:11 <NickHu_> Can you explain the '' part? I'm not terribly familiar with TH syntax
05:24:43 <mniip> % :t ''F
05:24:43 <yahb> mniip: Name
05:24:58 <NickHu_> Also, is it considered good style to omit $() at the top level?
05:25:05 <mniip> it's taking the F type from current scope and making an expression of type Language.Haskell.TH.Name from it
05:33:28 <ongy> is there a type somewhere that's an IO channel and triggers on an FD so I can plug it into an event loop? Or do I have to build it myself?
05:49:09 <Math22232> I don't get it; what is wrong with the last line? https://pastebin.com/gR8pPBhi
05:50:11 <dminuoso> Math22232: What error do you get?
05:50:40 <Math22232> dminuoso, https://puu.sh/ySG2N/f388b1ef50.png
05:51:42 <mniip> looks like you want : not ++
05:51:59 <mniip> a is a triple, and solution _ is supposedly a list of triples
05:53:06 <dminuoso> Math22232: The error message states that `In the first argument of ‘(++)’, namely ‘a’` it `Couldn't match expected type ‘[a]’ with actual type ‘(t, t, t)’` - the type [a] was inferred because
05:53:08 <dminuoso> :t (++)
05:53:09 <lambdabot> [a] -> [a] -> [a]
05:53:29 <Math22232> mniip, why is "a" a triple? it's a list of triples, which contains all the possible solutions of "y <- [0..z^2] , x <- [0..z^2], 2*x^3 + 5*y + 2 == z^2"
05:53:38 <mniip> no
05:53:41 <mniip> you drew one
05:53:42 <mniip> with <-
05:53:47 <dminuoso> Math22232: It's a triple because of your pattern match in the list comprehension
05:53:47 <Addam> can I construct an algebra for a state monad S->(S,X) with functions alg: m x -> (x -> a) -> a ?
05:56:16 * hackage packcheck 0.1.0 - Universal build and CI testing for Haskell packages  https://hackage.haskell.org/package/packcheck-0.1.0 (harendra)
05:57:15 <dminuoso> Math22232: A list comprehension itself produces a list again, and switching to >>= syntax makes this a bit more obvious: [(x,y,z) | y <- [0..z^2] , x <- [0..z^2], 2*x^3 + 5*y + 2 == z^2] >>= (\a -> return (a ++ (solution (z+1))))
05:58:45 <Addam> (is this the right place to ask?)
06:00:56 <dminuoso> Math22232: (Also note there's some further errors and unnessary parens in there)
06:01:06 <mniip> Addam, yes
06:01:22 <mniip> Addam, might want to ask in #haskell-lens
06:01:30 <jchia_1> I'm trying to do things like convert "data Foo = Foo [Int] [Char] [Bool]" to "data Bar = Bar (UVector Int) (UVector Char) (UVector Bool)" avoiding boilerplate. I also want to do things like take a (Int, Int, Int) using each entry as an index to lookup the respective fields in Bar to get a (Int, Char, Bool) and (Int, Int) to do a lookup for (Int, Char). There are in reality ~10 fields. Can uniplate help me do this? If not, what can I use
06:01:30 <jchia_1> ? I'm not sure how long I'll take to learn Generics and generics-sop, but do I need one of those?
06:01:40 <Addam> what is that mniip?
06:01:51 <jchia_1> Addam: Another IRC channel
06:02:08 <mniip> Addam, a channel originally for lens, but also for other complicated haskelly-categorical talk
06:02:21 <mniip> be prepared to hang around for a while though
06:02:33 <Addam> is it because it is not very populated?
06:02:40 <mniip> less populated than this one
06:03:04 <Addam> ok
06:03:27 <Addam> was mine a tough question?
06:03:42 <mniip> I'd say not enough information
06:03:56 <mniip> probably someone who's familiar with all the bits could recover all the missing info
06:04:12 <Addam> what would it be something that you need to know?
06:05:10 <mniip> ok so there's the state monad and its f-algebras
06:05:22 <mniip> and you want to construct it with what?
06:05:43 <mniip> what's m?
06:06:10 <Addam> m is the monad: m x = s -> (x,s)
06:06:50 <mniip> and you want to do what?
06:07:27 <Addam> write the function alg : m x -> (x -> a) -> a where a is a set of the algebra
06:08:09 <Addam> let s be Int
06:08:13 <mniip> and x is?
06:08:23 <Addam> any set
06:08:34 <mniip> no need to monomorphise, I just can't figure out the quantifiers in your statements
06:09:14 <mniip> do you have an algebra m a -> a, and want to write m x -> (x -> a) -> a?
06:09:52 <Addam> I'm defining it from scratch
06:10:21 <Addam> I don't have an algebra m a -> a, but if I can write one and then convert it, ok
06:10:24 <dminuoso> Math22232: Your list comprehension is extensionally equivalent to this code using do-notation: https://gist.github.com/dminuoso/9b7eb640dc4d3fe3f19a3cab09265115
06:10:40 <mniip> :t \a k f -> a (f <$> k)
06:10:41 <lambdabot> Functor f => (f b -> t) -> f a -> (a -> b) -> t
06:10:54 <Math22232> :r
06:10:54 <mniip> imagine b ~ t
06:12:22 <Addam> is that for me mniip?
06:12:26 <mniip> yes
06:13:04 <Addam> what is ~ ?
06:13:06 <dminuoso> mniip: So the output of that is some (Enum t, Eq t, Num t) => t -> [(t, t, t)], so the whole thing gives you just a list of tuples of numbers =)
06:13:26 <mniip> Addam, type equality, in haskellspeak
06:14:41 <mniip> :t (\a k f -> a (f <$> k)) :: Monad m => (m a -> a) -> m x -> (x -> a) -> a
06:14:42 <lambdabot> Monad m => (m a -> a) -> m x -> (x -> a) -> a
06:15:11 <Addam> ok this is closer mniip
06:15:18 <dminuoso> Err I meant Math22232, sorry mniip.
06:17:03 <Math22232> dminuoso, I'm trying to understand it, but I still wasn't able to inteprete it, it gives me some errors
06:17:18 <dminuoso> Math22232: Sorry I made a typo, reload my gist.
06:17:19 <Math22232> https://puu.sh/ySGGI/897bf7b376.png
06:17:36 <dminuoso> Math22232: Ah, guard comes from Control.Monad
06:17:44 <Addam>  <$> is a map?
06:17:51 <mniip> <$> is infix fmap
06:17:52 <dminuoso> Addam: <$> is fmap
06:18:01 <mniip> the morphism mapping of a functor
06:18:57 <dminuoso> Math22232: wow I have no idea what happened with copy pasting there. Please check the updated gist now: https://gist.github.com/dminuoso/9b7eb640dc4d3fe3f19a3cab09265115
06:19:23 <Math22232> dminuoso, I already fixed it thanks ^
06:19:27 <dminuoso> :)
06:19:49 <dminuoso> :t guard
06:19:50 <lambdabot> Alternative f => Bool -> f ()
06:20:19 <Addam> mniip a has type (m a -> a), k (m x) and f (x -> a); for the state monad what is a?
06:20:46 <mniip> the algebra
06:21:48 <mniip> again, you did a very poor job at explaining what exactly it is that you want to do
06:22:34 <Addam> sorry mniip
06:22:42 <mniip> 'm x -> (x -> a) -> a' isn't an algebra
06:24:11 <drets> Hello, I want to build a simple server which will have 2 endpoints returning json and deploy it to heroku, what the framework better to choose?
06:24:36 <mniip> actually hold on a second, what are algebras of a state monad?
06:24:53 <Addam> a monoid built from a set B with concatenation gives an algebra for a list monad where alg [a b ..] f = concat (map f [a b ..]) mniip
06:25:20 <Addam> what I want to achieve is the same for state monads
06:25:47 <Addam> make the function alg
06:26:32 <mniip> I assume here concat=join, map=fmap?
06:26:52 <mniip> that's just concatMap
06:26:53 <mniip> aka bind
06:26:58 <mniip> and it has a different type
06:27:08 <mniip> m x -> (x -> m a) -> m a
06:27:38 <mniip> and how is the set B involved in this?
06:27:42 <Addam> yes, not bind
06:27:58 <Addam> the set B is what I called a for the state monad
06:28:10 <mniip> hmm
06:28:14 <mniip> so concat=mappend?
06:28:16 <mniip> er
06:28:18 <mniip> mconcat
06:28:23 <mniip> no, that doesn't make sense
06:28:40 <mniip> are you sure you understand exactly what is going on there with lists?
06:28:49 <Addam> (f a) ++ (f b) ++ and so on
06:29:23 <Addam> ++ is the concatenation of the monoid (the function of the monoid; take 1 as its unit)
06:29:28 <mniip> okay
06:29:38 <mniip> how do you generalize the notion of [a b ..] to state?
06:30:07 <mniip> there's this thing:
06:30:10 <mniip> :t foldMap
06:30:11 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
06:30:35 <mniip> but State is not Foldable
06:30:58 <Addam> there will not be [a b ..], but something of the form s->(s,x)
06:31:06 <mniip> right
06:31:10 <mniip> and what next
06:31:34 <mniip> how do you apply 'f' to its "elements" which you then monoidally concatenate?
06:32:11 <Addam> it does not have to be a monoid or concatenation
06:32:26 <Addam> the list monoid was an example I made
06:32:31 <mniip> do you want to make a snowman? it doesn't have to be a snowman
06:32:42 <Addam> sorry mniip
06:33:26 <mniip> no worries
06:33:41 <Addam> in full, fix a set a; what I want to do is write alg: m x -> (x->a) -> a
06:33:49 <Addam> m x = s -> (s,x)
06:35:21 <Addam> the only property I want is that alg (k >>= f) g = alg k (\v -> alg (f x) g)
06:35:28 <mniip> @djinn (s -> (s, x)) -> (x -> a) -> a
06:35:28 <lambdabot> -- f cannot be realized.
06:35:30 <mniip> no banana
06:35:45 <TMA> Addam: you cannot escape from m x in a general way
06:35:51 <i-am-the-slime> Hi, how do I create a new project on nixos?
06:36:13 <Addam> TMA if m x is the state over numbers?
06:36:26 <Addam> mniip what was it?
06:36:33 <mniip> well if you fix an arbitrary number
06:36:57 <mniip> okay, since that  alg is equivalent to a classical monad algebra anyway,
06:37:11 <mniip> and that law for bind is equivalent to the law of algebras in terms of join/return
06:37:51 <mniip> and upon looking, it seems to be that the only State-algebra is one for State ()
06:38:12 <mniip> it is possible that what you're trying to do is impossible
06:39:36 <TMA> Addam: if m x = s->(s,x) you can get as far as s->(s,a) ... in order to get the a, you need some s to pass as an argument to the s->(s,a). grabbing the second from the resulting pair is then straightforward
06:41:52 <Addam> mniip by using an initial number, the property is not necessarily verified
06:41:56 <TMA> Addam: the only other way would be for the m x = s->(s,x) to be somewhat special, so that you can peek into the s->(s,x) function -- but then you would lose generality
06:43:33 <Addam> TMA peek into it how?
06:44:41 <Addam> mniip because >>= passes the state
06:44:53 <mniip> but does alg?
06:44:58 <Addam> it doesn't
06:45:14 <mniip> I'm trying to come up with a contradiction right now
06:45:20 <TMA> Addam: say that the s->(s,x) is for example f q = (q, 1) ;; you can extract the 1 from this particular function quite easily, because you know that it does not depend on the state parameter in any way
06:45:44 <Addam> TMA if I understood suggests that it can do by passing the state to the function if m x is m a
06:45:59 <Addam> TMA yes if it does not use the state
06:46:07 <TMA> Addam: you cannot do the same for g q = (q, q+1)
06:46:56 <mniip> Addam, shouldn't there also be a law that alg (return x) g = g x
06:47:11 <Addam> mniip yes
06:47:18 <Addam> that's easy to satisfy
06:47:45 * hackage streaming-postgresql-simple 0.2.0.2 - Stream postgresql-query results using the streaming library  https://hackage.haskell.org/package/streaming-postgresql-simple-0.2.0.2 (OliverCharles)
06:48:13 <mniip> ok
06:48:16 <mniip> alg (k >>= f) g = alg k (\v -> alg (f v) g)
06:48:18 <mniip> right?
06:48:27 <Addam> yes
06:48:39 <mniip> alg (k >> l) g = alg k (\v -> alg l g)
06:50:06 <mniip> alg (k >> l) = alg k . const . alg l
06:50:12 <mniip> huh does that even typecheck?
06:51:45 <mniip> ah yes
06:51:47 <mniip> it does
06:52:01 <mniip> anyway,
06:52:35 <mniip> suppose phi z = alg (modify (+z) >> get)
06:52:54 <mniip> evidently modify (+z) >> get >> modify (+y) >> get = modify (+z+y) >> get
06:53:09 <mniip> phi (z + y) = phi z . const . phi y
06:54:48 <mniip> actually no, forget the get
06:55:15 <mniip> psi z = alg (modify (+ z))
06:55:40 <stepcut> I am trying to parse one of those terrible 90s binary file formats. One tricky parse I need to handle is a case where some variable length records are repeated an unknown number of times. All I know is the total length of those records combined. So I need a parser combinator which can count how many bytes have been consumed. It seems I can do this in trifecta -- except trifecta seems to be treating the input as utf-8 encoded, and that is a pro
06:55:40 <stepcut> blem. attoparsec does not store position information. Any suggestions?
06:55:45 <mniip> psi (z + y) = psi z . const . psi y
06:55:47 <mniip> but also
06:55:58 <mniip> psi 0 = ($ ())
06:56:24 <[exa]> stepcut: parametrize the parser function with 'bytes left' ?
06:57:47 <stepcut> [exa]: that is what I am trying to do, but I do not see a clean way to do that in attoparsec and I don't see a way to disable utf-8 in trifecta
06:58:18 <Addam> (mniip I am trying what you suggest even if not replying)
06:58:34 <mniip> hmm
06:59:50 <stepcut> perhaps I should be using megaparsec :-/
06:59:54 <[exa]> a clean way would be, say, ParserT _ _ (State Integer)
07:00:12 <Addam> so you suggest alg (modify 1) f ?
07:00:33 <kadoban> stepcut: It sounds like you're doing a parser that takes Text or String or something? That doesn't sound right when you are caring about exactly what encoding you're in. Sounds more like ByteString or [Word8] or something. Though I don't know trifecta personally, so not sure that makes sense.
07:01:10 <stepcut> my input is a ByteString but trifecta seems to assume it is a utf-8 encoded bytestring
07:01:45 * hackage strive 5.0.0, strive 4.1.0 (fozworth): https://qbin.io/1480m8q
07:02:29 <stepcut> megaparsec seems to have support for parsing binary data -- but for some reason its position information still assumes rows and columns :-/
07:03:27 <stepcut> oh.. maybe I can use, stateTokensProcessed in megaparsec
07:03:40 <[exa]> stepcut: you don't necessarily want positions, you only want offsets... If you know the exact length of variable-length thingy, why not tear it out and parse separately?
07:04:10 <Addam> not sure whether that definition works mniip
07:04:29 <stepcut> [exa]: I have considered that option as well
07:04:43 <[exa]> stepcut: prototype before optimizing :]
07:05:45 <stepcut> [exa]: well, if 'optimizing' means 'using an entirely different parser, then I might want to optimize earlier
07:06:03 <stepcut> rather than using the wrong tool for the job
07:06:51 <[exa]> stepcut: not necessarily, attoparsec looks like it should be able to do it just right; except you need to add the manual offset tracking
07:07:56 <lyxia> stepcut: with attoparsec taking the bytestring and running another parser is the easiest to do for now
07:08:10 <Addam> how would you define modify?
07:08:33 <[exa]> stepcut: also I guess that it will still be a bit faster than tracking the position by hand
07:09:13 <stepcut> lyxia: yeah, I may end up doing that since I already have a lot of this written in attoparsec before stumbling across this issue. Since attoparsec has terrible errors anyway it won't matter that I'd lose position information -- since I don't have any to start with
07:09:39 <Addam> do you mean alg k f runs k with a state, modifies that and then runs f?
07:15:32 <stepcut> I guess it bothers me to use attoparsec in such a non-streaming manner even though I am parsing everything into ram anyway
07:19:16 <Addam> not able to find anything on my side mniip
07:21:35 <Addam> (not sure if you're still connected)
07:24:17 <mniip> I'm trying to "split the variables" in the equation for alg
07:24:26 <mniip> to see either a contradiction or a definition
07:24:51 <mniip> namely I've rewritten s->(s,a) as (s->s, s->a)
07:25:37 <beauby> Any resource on how to manually create a Dynamic (reflex-frp)? For instance from some kind of loop periodically doing asynchronous fetching of data
07:26:08 <mniip> :t toDyn
07:26:09 <lambdabot> Typeable a => a -> Dynamic
07:26:29 <kadoban> Other Dynamic, not that one
07:26:33 <mniip> ah
07:27:20 <Addam> mniip ok; I came up with ad hoc solutions, but not able to find a more general one (even when the state is over numbers, which is completely ok)
07:28:05 <mniip> are you really looking for an 'exists a.'
07:28:30 <mniip> some type A for which you can define (s -> (s, x)) -> (x -> A) -> A
07:29:51 <lyxia> stepcut: I looked into it once, this makes me want to try again https://github.com/bos/attoparsec/issues/129
07:29:59 <mniip> sigh, I'm afraid I have to go
07:30:43 <mniip> lyxia, are product parsers too hard to implement in the attoparsec framework?
07:31:29 <Addam> mniip for a "for any a"
07:31:42 <mniip> Addam, well then refer to djinn
07:31:50 <mniip> well okay no
07:32:19 <mniip> Addam, I still doubt it's possible
07:32:23 <mniip> even on integers
07:32:26 <mniip> even on bools
07:32:46 <pierrot> Hi. How can I prevent hGetLine from failing if it encounters EOF? Actually that's not my question... I'd like to try hGetLine and do something if encounters EOF...
07:32:58 <Addam> can't yet find an example to prove myself it isn't possible
07:35:13 <lyxia> mniip: is "product parser" what that is called
07:35:23 <mniip> product of languages
07:35:47 <mniip> intersection mybe
07:40:24 <lyxia> I don't know actually, I keep getting confused by the CPS in attoparsec.
07:45:42 <infandum> There is a library with an algorithm in a module that isn't exposed (part of the "other-modules"). Is it possible to import that module without forking?
07:46:27 <glguy_> No
07:47:13 <glguy_> pierrot: you can catch the exception using "try"
07:48:26 <glguy_> Or check the handle ahead of time with hIsEOF
07:49:11 <pierrot> both options look nick
07:49:15 <pierrot> glguy_ thanks :)
07:49:17 <pierrot> nice *
07:49:33 <pierrot> I thought `try` was something of imperative languages
07:52:12 <kadoban> pierrot: IO *is* an imperative language
07:52:55 <dminuoso> kadoban: Is it really imperative?
07:53:23 <dminuoso> kadoban: Consider that kleisli arrows in IO are purely declarative..
07:53:44 <kadoban> IO? Sure. It's one way to write imperative programs/algorithms/whatever in a purely functional language like haskell.
07:55:50 <dminuoso> kadoban: What definition of "imperative language" do you use here
07:56:20 <dminuoso> Or is your point that IO implements an imperative DSL?
07:57:50 <Addam> mniip the only option could be a mutable state...
07:57:58 <kadoban> The one where you write statements changing state and causing effects in order to implement your program. Sure it's a DSL if you want, but you're still doing imperative programming.
07:59:23 <Addam> mniip is it possible to create a block and use the state as global maybe?
07:59:37 <Addam> was reading a paper on that
08:10:29 <beaky> hello
08:11:49 <Addam> would it be a good idea?
08:12:11 <fraktor> I'd like to determine if a word is entirely composed of ascii alpha characters. is there a better way than "all (\x -> (isAlpha x) && (isAscii x)) word"?
08:14:47 <kadoban> fraktor: Looks basically fine to me
08:14:48 <ertes> :t isAsciiAlpha
08:14:49 <lambdabot> error: Variable not in scope: isAsciiAlpha
08:15:01 <ertes> :t isAsciiLower . toLower
08:15:02 <lambdabot> Char -> Bool
08:15:15 <ertes> :t all (isAsciiLower . toLower)
08:15:16 <lambdabot> Foldable t => t Char -> Bool
08:15:30 <fraktor> That's much cleaner. Thank you.
08:16:28 <liste> > toLower '4'
08:16:30 <lambdabot>  '4'
08:16:47 <liste> oh wait, it doesn't matter
08:16:59 <kadoban> I liked the original better. It's a bit odd to me involving the concept of lowercase there.
08:17:00 <beaky> is there a way to get a dsl without executing some kind of actual ast
08:17:03 <liste> > isAsciiLower '4'
08:17:04 <lambdabot>  False
08:17:12 <shapr> > toLower 'Е'
08:17:13 <beaky> lambdabot: why not :<
08:17:14 <lambdabot>  '\1077'
08:17:51 <beaky> i just want to have a special thing outside of the io monad just for things like e.g. purely concurrency, or purely graphics effects
08:18:01 <liste> :t (&&) <|> isAscii <*> isAlpha
08:18:02 <beaky> but then 'mix' them together in the io monad in the end
08:18:03 <lambdabot> error:
08:18:03 <lambdabot>     • Couldn't match type ‘Char’ with ‘Bool’
08:18:03 <lambdabot>       Expected type: Bool -> Bool -> Bool -> Bool
08:18:16 <ertes> beaky: it depends on your definition of "AST"
08:18:30 <liste> :t (&&) <$> isAscii <*> isAlpha
08:18:31 <lambdabot> Char -> Bool
08:18:35 <liste> yes!
08:18:42 <liste> though the original was nicer imo
08:18:49 <ertes> beaky: for example free monads pretty much fit the notion of "AST" that i have, but at the same time it also fits the notion of "EDSL"
08:18:56 <beaky> ah
08:19:01 <beaky> ok ill check free monads out
08:23:07 <fraktor> kadoban: I actually realized that my data needs to filter out anything that is capitalized (searching for scrabble words in the standard /usr/share/dict dictionary.)
08:23:22 <fraktor> So it works better with just isAsciiLower.
08:25:59 <kadoban> Fair enough
08:34:14 <vaibhavsagar> when building a static executable with cabal, at what point do I need to set LD_LIBRARY_PATH?
08:34:31 <vaibhavsagar> i.e. which phase of the process does it affect?
08:34:47 <ezyang> LD_LIBRARY_PATH is irrelevant when static linking
08:34:51 <ezyang> it controls the dynamic linker
08:35:10 <vaibhavsagar> okay, then how do I fix my linker errors?
08:36:32 <vaibhavsagar> the wrinkle is that I'm trying to do this from within a nix-shell even though I've heard this is not a thing
08:37:25 <vaibhavsagar> here are the commands I've run: http://lpaste.net/2196966520267997184
08:38:09 <beaky> free monads are amazing
08:38:20 <Addam> mniip in haskell-lens nobody has replied
08:39:21 <ezyang> vaibhavsagar: You probably need to install static libraries in your nix env
08:39:34 <ezyang> I don't know how to do this but that is usually the cause of the linker failure
08:39:39 <Addam> (since when you told me to)
08:41:35 <vaibhavsagar> ezyang: when you say 'install', what environment variables need to change?
08:41:55 <ezyang> not env vars
08:42:12 <vaibhavsagar> because I think I'm adding them
08:42:14 <ezyang> like, literally install. Like 'apt install' but whatever the equivalent is in nix
08:43:33 <vaibhavsagar> to put them in my /usr/lib64 folder or something like that?
08:44:44 <beaky> (free monads are amazing but the name sounds silly.., like free money?0
08:45:24 <ertes> beaky: but they are monads for free
08:46:06 <ertes> Free takes a functor and returns a monad
08:47:06 <ertes> vaibhavsagar: you should probably just build your project using nix instead of cabal-install
08:47:20 <vaibhavsagar> ertes: I want to build a static executable
08:47:32 <vaibhavsagar> I think it should be doable with nix-shell + cabal
08:48:01 <beaky> yes they seem to do exactly what i need (reading from http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html ) tho apparently in the end you need to both store some kind of tree-like dsl and have some kind of 'interpreter' to run it?
08:48:29 <ertes> vaibhavsagar: note that there is static linking of haskell libraries and static linking in general…  those are separate with GHC
08:48:44 <int-e> beaky: I believe they were invented as Unimo (a slightly awkward universal monad) and Prompt monads, but the marketing was bad.
08:48:53 <ertes> vaibhavsagar: another option is not to build a static executable, but build it using nix and then distribute the closure
08:49:19 <vaibhavsagar> ertes: I want a static executable, not a closure
08:49:24 <vaibhavsagar> just wondering if it is doable
08:49:38 <vaibhavsagar> I already know how to build + distribute a closure
08:49:52 <vaibhavsagar> but full static linking in Nix land is a bit harder
08:50:05 <ertes> beaky: "store" is not a good term
08:51:37 <ertes> beaky: there is an EDSL and an interpreter, but in general you don't *store* expressions, much like you'd rather not store lists…  they are lists in *concept*, not necessarily in low-level realisation
08:51:44 <beaky> ah
08:52:42 <ertes> vaibhavsagar: it's a matter of telling cabal to do full static linking…  you should be able to just search online for how to do it and then do it in nix-shell
08:53:30 <dmwit> ("free" is a technical term that can be applied to many constructions, not just monads. see also https://ncatlab.org/nlab/show/free+object )
08:53:47 <beaky> so in the end its all tagless and stuff?
08:53:53 <dmwit> (...and I think the name sounds a bit less stupid with that context.)
08:54:14 <ertes> beaky: in the end it's all "i don't care how GHC represents this in memory"
08:54:19 <beaky> ah
08:55:10 <ertes> beaky: in particular if you use the church-encoded version of Free/FreeT (called F and FT resp.), you get pretty much tight loops in the end
08:55:25 <ertes> because you're basically doing the free monad-equivalent of stream fusion
08:55:30 <beaky> dmwit wow that whole website looks really nice
08:55:49 <ertes> much like the pattern (foldr _ _ (unfoldr _ _)) compiles to a tight loop
08:57:05 <beaky> wow so ghc automagically figures out how to turn it to the church-encoded ones? (or at least i can trivially switch it to those versions)
08:57:28 <ertes> the latter minus the "trivially"
08:57:41 <Cale> beaky: nLab is great, though a lot of the definitions are aimed at a group of people who already know a traditional definition or two for the things in question. It's an encyclopedia of sorts specifically aimed at the n-categorical point of view on mathematical structures.
08:58:07 <ertes> there are no rewrite rules to do this automatically as far as i'm aware, and doing it by hand does involve some thinking, because you can't translate all interpreter patterns to church encoding directly
08:58:25 <Cale> (though in this case, there's nothing too unusual about the definition that was linked)
08:58:33 <int-e> ertes: you mean this type that doesn't even need f to be a Functor? https://hackage.haskell.org/package/MonadPrompt-1.0.0.5/docs/src/Control-Monad-Prompt.html#Prompt
08:58:41 <ertes> the problem is that most interpreters are written recursively, and that explicit recursion needs to go for church encoding to work
08:58:45 <beaky> yes i dont really know what an n-category is, but at least now i know free objects (and free monads) have their origins there
08:58:46 <RunningIn90s> i tend to agree with Cale
08:58:54 <ertes> int-e: hmm?
08:59:31 <int-e> ertes: just dwelling on the fact that MonadPromp had Free Monads for Less in 2008.
08:59:38 <int-e> *MonadPrompt
08:59:40 <ertes> int-e: i think i said you need a functor first…  i'm familiar with the notion of "freer monads", but i don't really know when those things are actual monads
09:00:04 <ertes> int-e: ah, i wasn't comparing them to anything…  i was only justifying the "free" part
09:01:02 <int-e> (But anyway, bad marketing lost. It's not the case that the more obscure terminology always wins in Haskell... Applicative won over Idiom, after all.)
09:01:43 <RunningIn90s> atleast for the "free"
09:05:01 <ertes> how does MonadPrompt compare to free monads?
09:07:37 <fraktor> Let's say I have a list of letters: "AAABBCDFHII.." and a word: "APPLE". How can I determine if that word can be spelled using only the letters in that list? Basically, how can I handle "determine if each of A is in B, without counting one item in B twice"?
09:08:20 <ertes> fraktor: can APPLE be spelled from AELP or do you need AELPP?
09:08:55 <fraktor> I would need AELPP.
09:09:04 <mnoonan> use a Map Char Int as a multiset
09:09:10 <glguy> > let spell target letters = null (target \\ letters) in spell "APPLE" "AELPP"
09:09:10 <beauby> fraktor: Many possibilities, but you could build a `Map Char Int` from your list, one from your word, and make sure the counts from the word are <= those from the list
09:09:12 <lambdabot>  True
09:09:16 <glguy> > let spell target letters = null (target \\ letters) in spell "APPLE" "AELP"
09:09:17 <lambdabot>  False
09:09:25 <ertes> fraktor: turn both into a (Map Char Int), then use M.intersectionWith and see if you get any negative numbers
09:09:47 <fraktor> glguy: I actually stumbled across that and it seems to be perfect.
09:10:05 <ertes> fraktor: actually M.unionWith may be a better idea
09:10:15 <fraktor> ertes: Why is that?
09:10:24 <RunningIn90s> maybe, the most obvious way to do it is the best?
09:10:24 <glguy> because intersectionWith was wrong
09:10:55 <fraktor> glguy's solution seems to be the best. Thank you for that.
09:10:59 <glguy> The Map based solutions will scale to larger cases than the naïve version I wrote
09:11:18 <ertes> :t M.unionWith (-) (M.fromList (zip "AELP" [1,1,1,2])) (M.fromListWith (+) (map (, 1) "APPLE"))
09:11:19 <lambdabot> Num a => M.Map Char a
09:11:22 <ertes> > M.unionWith (-) (M.fromList (zip "AELP" [1,1,1,2])) (M.fromListWith (+) (map (, 1) "APPLE"))
09:11:24 <lambdabot>  fromList [('A',0),('E',0),('L',0),('P',0)]
09:11:44 <ertes> actually that's wrong, too
09:11:44 <glguy> ertes: unionWith isn't quite right for the places that don't match on the righthand side
09:11:53 <glguy> mergeWithKey
09:11:54 <ertes> > M.unionWith (+) (M.fromList (zip "AELP" [1,1,1,2])) (M.fromListWith (+) (map (, -1) "APPLE"))
09:11:56 <lambdabot>  fromList [('A',0),('E',0),('L',0),('P',0)]
09:12:05 <ertes> > M.unionWith (+) (M.fromList (zip "AEP" [1,1,2])) (M.fromListWith (+) (map (, -1) "APPLE"))
09:12:07 <lambdabot>  fromList [('A',0),('E',0),('L',-1),('P',0)]
09:12:14 <ertes> negative numbers = can't be spelled
09:12:44 <ertes> mergeWithKey works, too, yeah
09:12:46 <glguy> mergeWithKey (\_ x y -> Just (x-y)) id (fmap negate)
09:12:53 --- mode: glguy set -o glguy
09:13:05 <glguy> And then there's that whole new merging module
09:13:44 <ertes> the merging module actually has a nice advantage: you can short-circuit
09:24:41 <stevo__> how do I build with cabal in parallel if I have 6 cores/12 threads? Is it "cabal -j 6" ?
09:24:55 <stevo__> I hardly see a parallel speedup
09:25:25 <ertes> stevo__: cabal uses parallelism on the package level…  you need to use the GHC flag -j to build individual packages in parallel
09:26:36 <stevo__> Thanks ertes
09:27:53 <dminuoso> ertes: So I've been playing with the thought of trying out comonads, and its interesting how hard it is to actually find a functor that has the ability to `extract` and satisfy the comonad laws. Wasted quite a bit of time with list [] on that. :)
09:29:12 <ertes> dminuoso: yeah, there aren't many interesting comonads…  the 'comonad' package already includes most of them
09:29:32 <ertes> dminuoso: StoreT is interesting, zippers are interesting and perhaps cofree comonads
09:30:58 <c_wraith> cofree is a fun type, but I'm not sure I've ever used the comonad part of its functionality
09:31:11 <bollu_alternate> dminuoso if I may self-evangelise: comonads for cellular automata :)  http://github.com/bollu/cellularAutomata
09:31:56 <ertes> dminuoso: ^ that's one use case of StoreT
09:37:24 <edwardk> c_wraith: https://www.schoolofhaskell.com/user/edwardk/cellular-automata covers the store comonad, but also uses a form of the cofree comonad (as a moore machine) and then dives into the trace comonad for the final part
09:37:47 <beaky> are free monads the same as monad transformers?
09:37:48 <edwardk> the middle part uses the comonad on left folds / moore machines
09:37:54 <edwardk> beaky: no
09:38:05 <beaky> ah
09:39:05 <bollu_alternate> edwardk I have coq questions, would you come to #coq? :)
09:39:26 <edwardk> 'free' is a technical term having to do with adjunctions. in this case it makes a statement about how every natural transformation from 'f' to another functor 'm' that happens to be a monad, there is a monad homomorphism from free f to m and vice versa.
09:39:26 <mniip> hey edwardk
09:39:35 <mniip> I have haskell questions, would you come to #haskell
09:39:35 <edwardk> bollu_alternate: i don't write much coq these days
09:39:39 <edwardk> =)
09:39:48 <edwardk> mniip: i don't write much haskell these days
09:39:50 <edwardk> ;)
09:40:03 <mniip> it's actually a category theory question
09:40:14 <edwardk> mniip: shoot
09:41:12 <mniip> a quantified type like 'forall a. f a' is basically the end of the profunctor f : Hask^op x Hask -> Hask
09:41:21 <mniip> what happens with 'forall (f :: * -> *). h f'
09:41:58 <mniip> of course it would be wrong to say that f is a functor from End(Hask)
09:42:02 <mniip> is it a profunctor?
09:42:07 <mniip> what does h look like?
09:42:26 <edwardk> you need to be careful. forall a. f a is a slightly different beast. you don't know anything about the argument to 'f', e.g. that there is a functor either way around. so really its more like an end over |Hask| -> Hask where |.| takes a category and forgets every arrow that isn't an identity arrow.
09:42:51 <mniip> are you sure?
09:42:59 <edwardk> but you _then_ have to be careful that this isn't the right notion of an end, because parametricity isn't naturality, so everything goes pear-shaped if you look at it too closely
09:42:59 <edwardk> yes.
09:43:19 <edwardk> neil ghani wrote up this perspective on how to think about type constructors at some point
09:43:29 <mniip> I mean, isn't the definition of an end, the commutativity of the wedge diagrams basically the parametricicty theorems?
09:43:51 <edwardk> no. try to take your definition of an End there and build products as limits. You can't.
09:44:05 <mniip> limits of what
09:44:13 <edwardk> the problem is that Hask isn't Set, and that if you look at it naturality is a weaker condition than parametricity.
09:44:39 <mniip> (are limits related to ends?)
09:45:02 <mniip> how come is it weaker?
09:45:35 <edwardk> saying that you have a _family_ of morphisms phi such that given phi_a :: F a -> G a , you can commute F . phi_a = phi_a . G   is different than what parametricity says, which is that yu have one function that can be given all those types.
09:46:19 <edwardk> when you go to define products you look at taking a limit over a functor from a discrete category with two elements, then you _do different things_ depending on which of those two objects you select.
09:46:27 <mniip> right
09:46:28 <mniip> can't do that
09:46:33 <edwardk> er F f . phi_a = phi_a . G f
09:46:51 <edwardk> so when you push on parametricity and try to do anything past the basics categorically, you get stuck
09:46:59 <mniip> umm
09:47:09 <mniip> okay maybe I'm misunderstanding what parametricity is
09:47:11 <edwardk> you can define a notion of a limit, a diagonal functor, the adjunction between them, but its not good enough to do any interesting category theory
09:47:41 <mniip> I'm assuming F, G are functors?
09:47:48 <edwardk> https://dl.acm.org/citation.cfm?id=2599154
09:47:53 <mniip> so you have your profunctor Hom(F-, G-)
09:48:17 <edwardk> https://pdfs.semanticscholar.org/6b73/eab84833587c56e46a31c0a25f8ffb8df769.pdf?_ga=2.69739408.1688075566.1514915267-320458771.1511396578
09:48:38 <edwardk> that paper is the best writeup on the differences between parametricity and naturality that i know of
09:49:03 <mniip> hmm, anyway
09:49:48 <edwardk> you can define limits, ends and right kan extensions all in terms of any of the others.
09:50:24 <edwardk> anyways, a kind isn't a category.
09:50:27 <ertes> edwardk: may i ask why you don't write much haskell these days?
09:50:45 <mniip> edwardk, okay, "naturality" as in naturality of a dinatural transformation?
09:51:40 <edwardk> ertes: i mostly said it as a joke given the previous comment about coq, but i've been off playing around with building a toy compiler
09:51:54 <ertes> ah
09:52:05 <glguy> What kind of toys does it compile?
09:52:18 <mniip> this diagram http://tcpst.net/mqix.png
09:52:21 <bollu_alternate> edwardk So I /can/ ask questions :D
09:52:36 <bollu_alternate> edwardk I wish to understand how to encode "complex" proofs, tbh
09:52:37 <edwardk> mniip: anyways, my point was more that you don't get a functor from Hask^op*Hask  -> Hask out of any type constructor from * -> *. anything nominal doesn't allow you do to anything but map with ~'s which are inhabitants of |Hask|.
09:53:11 <edwardk> bollu_alternate: read benjamin's book, then read chlipala's book once you're sick of writing such proofs directly.
09:54:00 <mniip> how come you don't
09:54:27 <edwardk> consider Set. Set :: * -> *, but you can't map over it with any isomorphism
09:55:00 <edwardk> if you know a ~ b, then you can turn Set a into Set b. but thats it.
09:55:03 <mniip> you can, it's just that the functions that placed expectations on concealed structure will break
09:55:53 <mniip> sure, if you take into account the extensionality of types with hidden constructors, it gets complicated
09:56:06 <edwardk> what you are describing is the 'natural map' that is used by the notion of a free theorem, but if i give you a module for Set, you're shit out of luck writing code that needs it unless i give you access to enough detail to offer it.
09:56:15 <edwardk> mutatis mutandis for mapping over the region parameter for ST, etc.
09:57:01 <edwardk> data Foo :: * -> * where Foo :: Foo Int
09:57:11 <edwardk> map over that, i'll wait =P
09:58:00 <edwardk> the key is that if i just give you a type constructor you're not empowered to do anything with it other than map identities over its parameters
09:58:07 <mniip> sure
09:58:09 <edwardk> hence you can view it out of the box as a functor from |Hask| -> Hask
09:58:23 <mniip> hmm
09:58:38 <edwardk> and maybe you can do more with some particular choices of functor, but you can do at least that much with everything of kind * -> *
09:58:40 <mniip> then can we say that a 'forall (f :: * -> *)' really encodes an f : |Hask| -> Hask
09:59:04 <edwardk> er.. i think you have notational issues with what you said.
09:59:15 <mniip> ok
09:59:22 <mniip> 'forall (f :: * -> *). h f'
09:59:34 <mniip> really means a profunctor h : (|Hask| -> Hask)^op x (|Hask| -> Hask) -> Hask?
09:59:36 <mniip> end of it
09:59:46 <edwardk> no.
09:59:51 <edwardk> same construction one level up
10:00:18 <mniip> are you saying that the truncation happens at ground level?
10:00:45 <mniip> that h : ||Hask| -> Hask| -> Hask ?
10:00:48 <edwardk> h :: (* -> *) -> *  -- but without knowing more about h all you can do is replace its argument with another argument that is ~ to it.
10:01:06 <edwardk> now we're talking, yes.
10:01:24 <mniip> but that doesn't work for 'forall (a :: *).' or does it
10:01:39 <edwardk> forall (a :: *). f a
10:01:46 <edwardk> is how you got |Hask| -> Hask
10:01:52 <edwardk> f :: * -> *
10:02:00 <edwardk> became f : |Hask| -> Hask
10:02:15 <mniip> that sounds wrong
10:02:23 <mniip> if f is known, I can use its structure
10:02:41 <edwardk> data Foo :: * -> * where Foo :: Foo Int
10:02:44 <edwardk> i know Foo's structure.
10:02:52 <edwardk> i can't do squat about changing out its argument
10:03:20 <edwardk> GADTs mess with your intuition. the thing you are trying to say only holds for representational arguments
10:03:27 <edwardk> Foo's argument is nominal
10:03:45 <edwardk> given Foo :: Foo Int   there is nothing I can do to it to give you Foo Bool
10:03:59 <mniip> hmmm
10:04:22 <edwardk> on the other hand if you give me type Bar = Int
10:04:31 <edwardk> now I can use the fact that Int ~ Bar   and turn Foo Int into Foo Bar
10:04:50 <edwardk> i can 'map' over it with :~: 's, which are the inhabitants of |Hask|
10:04:58 <edwardk> er the morphisms of |Hask|
10:05:16 <edwardk> because nothing actually changes, the only morphisms are identity morphisms
10:05:25 <mniip> Foo a ~ (a ~ Int) => a
10:05:35 <edwardk> that doesn't parse
10:05:51 <mniip> Foo a "approxumately equals" (a ~ Int) => a
10:06:13 <mniip> actually no
10:06:15 <mniip> that's a *>
10:06:19 <edwardk> nah, (a ~ Int) => a is an actual Int. Foo a is approximately Dict (a ~ Int)
10:06:21 <mniip> or how ever do you spell it
10:06:42 <mniip> (a ~ Int) *> ()
10:06:47 <edwardk> Foo a is a proof that a ~ Int
10:06:52 <mniip> yeah
10:07:33 <mniip> so the issue is equational constraints
10:07:39 <mniip> that cannot be picked apart into dictionaries
10:07:43 <mniip> actual dictionaries
10:08:06 <mniip> Like if we had 'class Iso a b where to :: a -> b; from :: b -> a'
10:08:12 <mniip> and used 'Iso a Int'
10:08:12 <edwardk> the issue is that ~ mucks up your attempt to make kinds look like profunctors. ;)
10:08:20 <mniip> we could argue that it's just a pair of functions
10:08:26 <mniip> and invmap over it just fine
10:08:38 <mniip> and with ~ that doesn't work
10:08:50 <edwardk> you can make a data Iso a b where Iso :: (a -> b) -> (b -> a) -> Iso a b
10:08:55 <edwardk> and then talk about the category instance for Iso
10:09:26 <edwardk> there are plenty of things that are then functors from Iso to Hask.
10:09:29 <edwardk> its just not everything
10:09:30 <mniip> no like, if (~) actually had a dictionary represented by a pair of functions
10:09:49 <mniip> ooh
10:09:51 <mniip> univalence axiom
10:09:56 <edwardk> unfortunately that screws over all sorts of semantics
10:09:57 <mniip> did not expect
10:10:06 <stevo__> I tried for an hour now but I get "Run 'C-h f haskell-mode' for instruction how to setup a Haskell interaction mode.
10:10:23 <mniip> edwardk, yeah that is understandable
10:10:27 <edwardk> and, yeah, sclv has some fancy univalence compatible notion of (~) he keeps playing with
10:10:34 <mniip> I've had a glance at univalent type theory
10:10:46 <edwardk> but haskell can't have the (~) you mention above, because it destroys global instance resolution of type classes
10:10:51 <mniip> yup
10:11:31 <edwardk> my next example was going to be to start throwing class constraints on the type arguments to show how you can't have nice things
10:11:48 <mniip> how so
10:11:58 <mniip> I mean I don't think regular constraints are much of a problem
10:12:46 <edwardk> data MySet a where MySet :: Ord a => Data.Set a -> MySet a
10:12:47 <mniip> like, 'Eq a => f a' is pretty much 'EqDict a -> f a', where data EqDict a = EqDict (a -> a -> Bool) (a -> a -> Bool)
10:13:04 <edwardk> to "map" over it you now destroy the uniqueness of instance resolution for Ord
10:13:13 <mniip> hmm
10:13:16 <mniip> indeed
10:13:44 <mniip> explains why wadler avoided implicit parameters in favor of explicit
10:14:12 <robbym> Hello. I want to learn Haskell. Does anyone know what would be a good first program? (a bit more substantial than hello world)
10:14:13 <edwardk> wadler's original paper on typeclasses is super short btw, worth reading
10:14:21 <bollu_alternate> edwardk ahahaha, that is a neat summary
10:14:28 <bollu_alternate> edwardk I have been working through SF volume 2
10:14:33 <mniip> edwardk, I meant "theorems for free"
10:14:35 <bollu_alternate> edwardk he seems t work with only "simple" objects
10:14:39 <bollu_alternate> edwardk lists, functions, relations
10:14:45 <bollu_alternate> he doesn't work with, say, maps
10:14:50 <bollu_alternate> or more complex algebras
10:14:52 <bollu_alternate> or am I mistaken?
10:15:03 <edwardk> bollu_alternate: benjamin's book is pretty much the only book that goes through all the nuts and bolts of writing out super-long proofs by hand
10:15:22 <edwardk> but its because he seems to love the 'game' of theorem proving his way through all those blind alleys
10:15:23 <bollu_alternate> edwardk where does it have "super long" proofs
10:15:28 <bollu_alternate> I have not encountered them
10:15:28 <shapr> robbym: what about doing the advent of code problems?
10:15:39 <bollu_alternate> edwardk volume 1 was quite easy tbh
10:15:47 * shapr turns up the volume
10:15:51 <mniip> shapr, ehh some of those aren't handy to work out in haskell
10:16:09 <edwardk> chlipala is more about building a tactic to solve an entire problem domain, and ensuring that the gallina proof terms are small by doing as much as he can in Prop so that it gets erased
10:16:15 <metahumor> robbym: what about Euler problems?
10:16:52 <mniip> edwardk, okay but surely there is something left. I mean, what does letting f : |Hask| -> Hask  say about the "naturality" of the forall?
10:17:04 <edwardk> bollu_alternate: what i mean by that is that benjamin is willing to actually write out the proofs long hand, but thats a fairly brittle style. if you change the problem just a little bit the entire proof is shot and you gave to rewrite it.
10:17:10 <shapr> mniip: the benefit is that many solutions are available on github
10:17:12 <mniip> I think goldfire called it "irrelevance" of the quantifier
10:18:11 <Rembane> robbym: Write a guessing game, where the player gives a number and the computer should guess which and vice versa.
10:18:12 <edwardk> metahumor: one hazard of doing the project euler problems is that if you dont have a particularly mathy bent then going into haskell through that direction you tend to get the mental model that haskell is only good for doing math problems
10:18:37 <infandum> In this page: "https://hackage.haskell.org/package/sparse-linear-algebra-0.2.9.8/docs/Numeric-LinearAlgebra-Class.html#t:Magnitude", how do I convert Magnitude to Double?
10:18:48 <edwardk> i've lost track of how many people have cme up to me and commented about haskell is "that language for working with lists that they had to use in college"
10:19:24 <byorgey> infandum: that is a kind error.  Magnitude is not a type, it is a type family
10:19:30 <bollu_alternate> edwardk indeed, that is a fair point
10:19:31 <robbym> I think I'll do the guessing game. Thanks for the suggestions.
10:19:49 <mniip> no wait
10:19:52 <mniip> not relevant
10:19:55 <edwardk> mniip: an inhabitant of "forall a. f a" is an inhabitant of a limit (or end) over f :: |Hask| -> Hask.  -- in this case because |Hask| is a discrete category they do the same thing.
10:19:56 <bollu_alternate> edwardk CPDT teaches you how to write LTac right?
10:20:00 <mniip> relevant is forall vs pi
10:20:02 <bollu_alternate> edwardk It strikes as very lispy
10:20:02 <byorgey> infandum: for some particular type v you can ask how to convert Magnitude v  to Double.  But that depends on how  Magnitude v  is defined.
10:20:16 <bollu_alternate> edwardk do not solve the problem, create a DSL to solve your problem
10:20:28 <edwardk> bollu_alternate: thats the mental model i tend to like
10:20:28 <mniip> edwardk, that's remarkable
10:20:43 <amalloy> robbym: you could also do advent of code exercises
10:21:22 <edwardk> mniip: the problem is that this is the notion of a limit that comes with parametricity, not the notion that comes with naturality
10:21:37 <robbym> amalloy: someone mentioned some of them aren't handy to work out in haskell
10:21:38 <mniip> which is which once again
10:21:41 <edwardk> so there are strictly fewer inhabitants of them in a way that cuts off a ton of interesting category theory
10:21:57 <edwardk> parametricity is what you get in haskell, naturality is what you get in category theory
10:22:00 <infandum> byorgey: That's specific to this library, right? So it should provide an opinion on how to convert.
10:22:45 <bollu_alternate> edwardk There seems to be a large gap between practice and theory, though. For example, I have been trying to prove this: https://github.com/bollu/dependence-analysis-coq/blob/0b00fb86226454950ec2a285a94ec2f80a5483d2/dependence-schedule/proof.v#L223
10:22:52 <mniip> okay but while our types are profunctors those do mean the same thing, right?
10:22:59 <bollu_alternate> edwardk I have no idea how to prove this, so I have been trying to understand how to prove simple stuff with Map
10:23:05 <bollu_alternate> edwardk it's.. been painful to say the least
10:23:44 <bollu_alternate> edwardk informally I can provide a proof by intuition
10:23:54 <bollu_alternate> but I have no idea how to convince the proof assistant of that :(
10:24:25 <mniip> is it an *intuitionistic* proof xD
10:24:49 <edwardk> mniip: your argument doesn't kind check. you can think of all of the nice representational data types in haskell as admitting a natural map, but thats really more like being a functor from Core(Hask) -> Hask than Hask^op * Hask -> Hask
10:25:28 <mniip> no but like
10:25:37 <mniip> to make the free theorem about the type of map
10:25:53 <mniip> you need a nonidentity morphism of Hask
10:26:00 <mniip> err not map
10:26:08 <mniip> reverse
10:26:10 <mniip> and the like
10:26:34 <byorgey> infandum: yes, but it could be different for each v
10:26:36 <mniip> for all f :: a -> b,  map f . reverse = reverse . map f
10:26:53 <mniip> that's the naturality square of the Hom(List(-), List(-)) profunctor
10:26:59 <edwardk> there are plenty of data types for which they form a functor from Hask -> Hask or from Hask^op -> Hask or whatever, or from some other category -> Hask. but if i just tell you 'f :: * -> *' exists. the only things you can do with it out of the box is map over it with arrows in |Hask|
10:27:00 <byorgey> infandum: it simply does not make sense to ask how to convert  Magnitude v  to  Double  in general
10:27:20 <mniip> that yes
10:27:33 <byorgey> infandum: do you have something specific you are trying to do?
10:27:47 <edwardk> mniip: parametricity implies naturality, naturality doesn't imply parametricity
10:28:14 <infandum> byorgey: Find the norm2 of a sparse vector from that library.
10:28:19 <edwardk> thats sort of the point of that hermida/reddy paper i linked above
10:28:29 <mniip> I'll read it when I get a moment
10:29:16 <edwardk> both notions were designed for much the same reason, but there are some pretty significant differences between the two that more or less in richard's terms come down to the difference between his forall and pi.
10:29:16 <mniip> edwardk, so uh, I understand that || truncation for when f is unknown
10:29:41 <edwardk> Foo above gave an example where that || truncation was needed even when f was known
10:29:52 <mniip> but when it is known and representational then surely wadler's theorems for free aka profunctor end naturality still applies?
10:29:53 <edwardk> data Foo :: * -> * where Foo :: Foo Int
10:30:53 <edwardk> When f is known and representational and its implementation is exposed then sure you can define a natural 'map' that takes (a -> b) -> (b -> a) -> f a -> f b  even when the argument is in contravariant position.
10:31:04 <byorgey> infandum: do you mean Data.Sparse.SpVector.SpVector?  That does not seem to be an instance of Normed
10:31:13 <mniip> well like
10:31:23 <edwardk> but thats not profunctorial, so you need to be careful about your vocabulary
10:31:31 <mniip> is it not?
10:31:47 <mniip> I mean we don't write f with two arguments but
10:31:52 <edwardk> (a -> b) -> (c -> d) -> p b c -> p a d -- would be a profunctor
10:31:55 <infandum> byorgey: Yes. It does advertise that it can do vector norms in the readme: "Vector and matrix norms"
10:32:04 <edwardk> now lets' look at "invariant" functors instead
10:32:07 <mniip> intrinsically f is upgradable to a profunctor
10:32:11 <edwardk> there are at least 4 notions of this that come up
10:32:12 <infandum> I just figured I was missing something.
10:32:17 <mniip> we can separate co from contravariant uses
10:32:18 <edwardk> (a -> b) -> (b -> a) -> f a -> f b
10:32:19 <byorgey> infandum: there is some commented-out code with instance Normed (SpVector t) where .... which defines  type Magnitude (SpVector t) = t
10:32:37 <byorgey> infandum: so if that code was not commented-out,  norm2  of a  SpVector Double  would give you a  Double
10:32:49 <edwardk> do you require that you 'xmap f g' with f . g = id, g . f = id, neither or both?
10:32:57 <byorgey> infandum: if I were you I would email the package author to ask about it.
10:33:15 <edwardk> these give rise to 4 notions of 'invariant' functor
10:33:47 <mniip> neither
10:33:47 <edwardk> based on if you're mapping with isomorphisms, sections, retracts or just pairs of morphisms that happen to have matching endpoint types
10:33:58 <edwardk> that latter category is _not_ Hask^op * Hask though
10:34:33 <edwardk> C*D  is where your objects are choices of pairs of objects, one from C, one from D. here you're making the same choice from Hask^op and Hask
10:34:50 <infandum> byorgey: The error I'm getting is Expected type: S.SpVector Double -> Double, Actual type: S.SpVector Double -> S.Magnitude (S.SpVector Double)
10:34:53 <mniip> but but
10:34:59 <infandum> So it isn't an instance error.
10:35:22 <mniip> we do pick different objects from Hask^op and Hask when writing out the natuarlity square
10:35:25 <edwardk> the 'natural' map can be described for this latter 'pair of morphisms that happen to share the same object end-points'
10:35:32 <mniip> this diagram I linked http://tcpst.net/mqix.png
10:36:15 <mniip> in wadler's theorems, reverse . map f :: [a] -> [b]
10:36:48 <edwardk> where did you pull that diagram from?
10:36:51 <mniip> which isn't an application of the Hom(List(-), List(-)) functor as if it were unary
10:37:10 <mniip> def 2.1: https://ncatlab.org/nlab/show/end
10:37:17 <edwardk> reynold's approach is to talk about relations, which is a whole other beast
10:37:58 <edwardk> that diagram doesn't apply in any sort of simplistic direct manner with '[]' as F.
10:38:05 <mniip> not with []
10:38:17 <mniip> we're talking about reverse :: forall a. [a] -> [a]
10:38:46 <mniip> in this case our profunctor is P(a, b) = Hom([a], [b])
10:39:37 <byorgey> infandum: can you type   :kind! S.Magnitude (S.SpVector Double)  at a ghci prompt?
10:39:37 <edwardk> that part is fine
10:39:44 <mniip> with P(a, f) being (. map f), and P(f, b)  being (map f .)
10:39:58 <edwardk> i have no objections to that thing being a thing
10:40:15 * hackage MBot 0.2.4.0 - Haskell interface for controlling the mBot educational robot  https://hackage.haskell.org/package/MBot-0.2.4.0 (cfscholl)
10:40:31 <mniip> wadler's free theorem states that  map f . reverse = reverse . map f
10:40:40 <mniip> which is the same as stating that that forall type is a wedge
10:41:21 <edwardk> for this particular type, sure
10:41:26 <mniip> oops I mixed up the (. map f) and (map f .) there but no big deal
10:41:33 <hyperisco> mniip, can I enlist you to explain the finer points of the definitions in that paper to me? later though
10:41:33 <infandum> byorgey: Huh, trying it in ghci gives an instance error. Your request returns Magnitude (SpVector Double) :: * = Double
10:41:47 <hyperisco> mniip, when it gets to functions I keep getting tangled
10:42:33 <mniip> edwardk, I'm trying to place a restriction that is as strong as possible, on what an inhabitant of a forall-type can be
10:42:37 <byorgey> infandum: what?  How could it give an instance error and also result in Double?
10:43:03 <mniip> your discrete category truncation actually strengthens the restriction when the functor is quantified over,
10:43:20 <edwardk> and for that you need to know that we can care about representational vs. nominal in haskell, which was all i was trying to get at above.
10:43:21 <mniip> but not when it's in the lhs of the forall
10:43:25 <mniip> yeah
10:43:35 <edwardk> hence all the Foo, and Eq based examples
10:43:41 <stevo__> EMACS haskell-mode is broken, issue tracker full of problems. The state of the haskell tools world is soo sad.
10:43:52 <edwardk> so not every 'f' will have a nicely behaved natural map.
10:44:06 <stevo__> https://github.com/haskell/haskell-mode/issues/1496
10:44:09 <mniip> so like, if the lhs of the forall is a representational type thing
10:44:18 <mniip> then we can make a stronger statement a-la wadler's
10:44:23 <mniip> er
10:44:23 <edwardk> or rather the thigns that natural map are allowed to map with might be very restricted (down to identities)
10:44:25 <mniip> rhs of the forall
10:45:21 <mniip> hmm
10:45:22 <stevo__> https://github.com/haskell/haskell-mode/issues/1553 ghc 8.2.2. is unsupported in emacs
10:45:30 <edwardk> if it is something you quantify over, you only have the power to do things to it you give yourself through => basically.
10:46:05 <edwardk> e.g. forall f. Functor f => ... vs. forall f. ...
10:46:33 <mniip> well in that case a => is desugarable into an explicit parameter, no?
10:46:39 <mniip> ah no
10:46:44 <edwardk> https://wiki.haskell.org/Catamorphisms#Mendler_Style
10:46:47 <edwardk> for the functor example
10:46:47 <mniip> same thing with instance resolution
10:46:48 <nullie> stevo__: try intero
10:47:05 <edwardk> for functor that is the case as it is uniquely determined
10:47:14 <edwardk> but once you start passing me pairs of functions like you did, its not
10:47:47 <edwardk> given two functions f and g i can 'pingpong' an arbitrary number of times f . g . f . g . f     and you can observe that information
10:47:56 <edwardk> because in your case they aren't inverses
10:48:24 <stevo__> nullie: Thanks. Really!!!
10:48:37 <edwardk> so 'invariant' functors are less defined if you aren't mapping from Iso or Core(Hask) and allow just any old function, which you have to for this reynold's stye stuff
10:49:03 <edwardk> note that a profunctor doesn't have this problem, but 'invmap' or 'xmap' or whatever we're calling it does.
10:49:36 <edwardk> interestingly, if you require f . g = id or g . f = id you contain the damage.
10:49:51 <mniip> well in my imaginary ideal world, all parameterised types are profunctors
10:50:22 <edwardk> [] isn't a profunctor here. its an 'invariant' functor
10:50:30 <mniip> haskell's [] isn't
10:50:36 <edwardk> your Foo a b = [a] -> [b]   is a profunctor
10:50:40 <edwardk> sure it is.
10:50:53 <mniip> I swear one day I'll write out some Generic madness that upgrades haskell's ADTs to profunctors
10:51:10 <edwardk> https://hackage.haskell.org/package/invariant-0.5/docs/src/Data-Functor-Invariant.html#line-195
10:51:33 <mniip> that didn't hyperlink
10:51:55 <mniip> ah
10:51:59 <edwardk> its slow, but the relevant line is instance Invariant [] where invmap = invmapFunctor
10:52:23 <mniip> I meant the kind of thing where it separates covariant from contravariant uses of the type variable
10:52:47 <edwardk> i raise this because because of the 4 different notions of 'invariant' functor i don't bother to package up 'invariant' myself.
10:52:56 <mniip> right
10:53:02 <mniip> hence me calling them profunctors all this time
10:53:30 <edwardk> and i'm carefully distinguishing 'pro' from 'invariant' because having a name for the two similar but different concepts is useful
10:53:41 <mniip> I mean even category theorists will write End_C Hom(FC,GC)
10:53:50 <mniip> and imply that one is contravariant and the other is covariant
10:54:19 <edwardk> F and G are both covariant, its the contravariance of Hom's first argument that flips the variance there
10:54:29 <mniip> it's inferrable yes
10:54:38 <mniip> hence me saying you can do it with generics
10:55:19 <edwardk> note that they dont write End_C Hom(F(C+,C-), G(C-,C+))  -- so they still have some use for functors of one argument ;)
10:55:26 <mniip> sure
10:55:48 <mniip> if that were generic haskellian F,G:: * -> *, I would've understood precisely that
10:56:33 <mniip> list's "derived profunctor" is constant in the contravariant argument though
10:56:51 <mniip> as is any Data.Functor.Functor
10:57:02 <edwardk> i do have some generics code i wrote for trying to split out all the uses of a type variable in a type, but trying to write generics code for trying to split out the co and contravariant uses blows up because you don't know variance necessarily and because the only 'ground truth' source of contravariance is (->), which would need Generic2
10:57:25 <mniip> is that not a thing yet
10:57:37 <edwardk> not a thing
10:57:43 <mniip> how come it's 2018 and we don't have a way to lift typeclasses to higher kinds
10:57:58 <mniip> only ad-hoc stuff for a finite preallocated number of kinds
10:58:02 <edwardk> because you have yet to answer the call and writeit =P
10:58:16 <mniip> I have whined about it in #haskell-lens once
10:58:18 <mniip> with code attached
10:58:29 <mniip> admittedly it's unreadable,
10:58:35 <infandum> byorgey: One was through ghci (the error instance), the other wasn't, so maybe that error wasn't produced just yet. Either way, I just coded the norm myself :/
10:59:08 * mniip greps
10:59:30 <mniip> edwardk, http://lpaste.net/355969
10:59:35 <hyperisco> mniip, it is a big problem for type level programming because one can't reuse all their value level definitions
11:00:21 <hyperisco> just for circumstances where you don't even need a type level class, just ignoring it would suffice
11:00:41 <mniip> hyperisco, what no
11:00:45 * hackage graphmod 1.4.1 - Present the module dependencies of a program as a "dot" graph.  https://hackage.haskell.org/package/graphmod-1.4.1 (IavorDiatchki)
11:00:47 <hyperisco> what yes
11:00:51 <mniip> hyperisco, we're talking Eq/Eq1/Eq2
11:00:58 <hyperisco> and?
11:01:25 <mniip> how does it relate to type-level programming
11:01:41 <hyperisco> I must be misunderstanding your statement
11:02:13 <mniip> expressing the notion of (forall a. Eq a => Eq (F a)) in a constraint
11:02:22 <mniip> that's what Eq1 does
11:02:39 <mniip> it upgrades Eq from * -> Constraint to (* -> *) -> Constraint
11:03:14 <edwardk> technically Eq1 is stronger than that
11:03:18 <mniip> k -> ?
11:03:22 <edwardk> nah
11:03:25 <mniip> no I don't think so
11:03:26 <hyperisco> ah, okay. You've seen the paper for the proposal yes?
11:03:28 <mniip> Eq a is in place
11:03:30 <edwardk> its because you can pass the 'dictionary' as an arbitrary function
11:03:38 <mniip> yes you can
11:03:50 <mniip> hmm wait
11:04:15 <mniip> ooh
11:04:21 <mniip> we have Data.Functor.Classes in transformers
11:04:26 <edwardk> there are things that are Eq1 f,  but which aren't Functor f, etc.
11:04:28 <hyperisco> I thought you were talking about promotion, because it is also true that you cannot promote contexts, which is a big pain
11:04:28 <mniip> with eq1 :: Eq a => f a -> f a -> Bool
11:04:35 <mniip> and Data.Functor.Classes in base
11:04:41 <mniip> with liftEq :: (a -> b -> Bool) -> f a -> f b -> Bool
11:05:14 <mniip> hmm fishy
11:05:18 <edwardk> transformers' last version had the liftEq model. when ross took it from my 'prelude-extras' he sort of bikeshedded it a few times
11:05:20 <mniip> I don't like that a ~/~ b
11:05:39 <byorgey> infandum: it makes me wonder whether you have multiple versions of the package installed, one with the relevant instance and one without
11:06:22 <edwardk> its actually quite useful to allow the more general type there. it can make a rather large asymptotic difference to some code
11:06:23 <mdim> Hi everyone! I've been trying to follow a paper by Wouter Swierstra titled "Data Types A La Carte" by getting a runnable implementation of code presented in the paper. However, I got stuck at this example: "let x :: Expr (Add :+: Val) = val 30000 ⊕ val 1330 ⊕ val 7". When executed in the REPL, I get this error message: https://paste.debian.net/1003312/ Is there an available implementation that compiles?
11:06:59 <mniip> edwardk, that's assuming a type doesn't need to use == on its subparts
11:07:13 <metahumor> mdim: in your ghci session, run the following
11:07:15 <mniip> which I suppose, is fair enough,
11:07:19 <edwardk> mdim: :set -XScopedTypevariables  and :set -XTypeOperators
11:07:20 <dmwit> mdim: Does turning on the suggested extensions fix the problem?
11:07:29 <metahumor> mdim: ":set -XScopedTypeVariables" and ":set -XTypeOperators"
11:08:12 <edwardk> mniip: if those type variables are used you use the function given, if its an argument you delegate to its 'liftEq' method. the mess is you can't use it just as a dictionary lifting method.
11:09:07 <edwardk> I think Eq1, Show1, Ord1, Read1 are kind of a pain in the ass as specified because they are so much harder to write than the 'Lifting Eq' instance from constraints but they are kinda useful for improving code performance over what Lifting Eq can offer in some limited scenarios
11:09:18 <edwardk> their benefit is that you can define them in a completely haskell 98 fashion
11:09:31 <edwardk> where Lifting Eq needs some pretty heavy constraint machinery
11:09:32 <mniip> hmm I vaguely remember Lifting
11:09:43 <mniip> but it also suffers from a fixed number of kinds, deson't it
11:09:46 <mniip> doesn't it
11:09:54 <edwardk> nah, that one works polykinded
11:10:01 <edwardk> Lifting Monad    and Lifting Eq both work
11:10:08 <mdim> metahumor: edwardk: I get this: Some flags have not been recognized: -XScopedTypevariables
11:10:19 <edwardk> capital v
11:10:19 <mniip> no like
11:10:50 <stevo__> Intero is only working on very old versions of GHC such as GHC 8.0.1, GHC 7.10.3, GHC 7.10.2, and GHC 7.8.4.
11:10:58 <stevo__> Haskell mode is totally broken at the moment
11:11:00 <mniip> can I lift k -> Constraint to something more curious than (l -> k) -> Constraint
11:11:08 <edwardk> if you mean that Eq2 isn't a 'Lifting Eq', thats because of the structure of 'Eq'
11:11:14 <stevo__> Haskell and Emacs are impossible to use at the moment
11:11:17 <mniip> actually
11:11:25 <mniip> Lifting will only give (k -> k) -> Constraint
11:11:30 <edwardk> you can make a more general class that says what something gets lifted to
11:11:46 <mniip> % :k Data.Constraint.Lifting.Lifting
11:11:46 <yahb> mniip: ; <interactive>:1:1: error:; Not in scope: type constructor or class `Data.Constraint.Lifting.Lifting'; No module named `Data.Constraint.Lifting' is imported.
11:11:46 <metahumor> mdim: you have to capitalize the V in Variables
11:11:50 <mniip> damn
11:11:52 <mdim> got it
11:12:16 <metahumor> mdim: ghci should have tab-autocompletion for those -X... pragmas
11:12:21 <edwardk> class Lifting' p q f where lifting' :: p a :- q (f a) -- with explicit type applications
11:12:40 <mniip> no like I'm interested in the kind
11:13:17 <edwardk> the you can have Lifting' Eq (Lifting' Eq Eq)   or something like that -- i haven't worked it out, that isn't quite it, but its similar
11:13:49 <mniip> Lifting :: (k -> Constraint) -> (k -> k) -> Constraint
11:14:03 <mniip> consider for example Proxy
11:14:10 <edwardk> the Lifting' i just gave doesn't require the kinds to match.
11:14:16 <mniip> Proxy doesn't need Eq a, for Eq (Proxy a)
11:14:19 <edwardk> the Lifting i offer in constraints is limited to keep my sanity
11:14:20 <mniip> yeah right
11:14:31 <mniip> ah I see
11:14:35 * mniip looks
11:15:02 <mniip> that looks suspiciously similar to my paste
11:15:02 <edwardk> Lifting' :: (i -> Constraint) -> (j -> Constraint) -> (i -> j) -> Constraint
11:15:09 <mdim> Hm, now I got this far: https://paste.debian.net/1003313/
11:16:12 <mniip> I suspect if I generalized View to an arbitrary class to be lifted/entailed I'd get your Lifting'
11:16:14 <edwardk> mdim: you need to enable overlap on that instance as well. the notation for that has changed a bit since the paper was published.
11:16:40 <mdim> edwardk: how do I do that?
11:17:07 <metahumor> you could try including ":set -XOverlappingInstances"
11:17:16 <edwardk> {-# overlappable #-} and {-# overlaps #-} pragmas on the instances involved or something like that
11:17:16 <dminuoso> mdim: You just use {-# OVERLAP #-} in that instance.
11:17:23 <mniip> edwardk, so uh yeah why isn't this in base
11:17:32 <dminuoso> mniip: That extension is deprecated
11:17:35 <hyperisco> read the GHC docs, it tells you
11:18:03 <edwardk> mniip: because the thing is damn hard to use, requires 50 bzillion instances, has the banana problem, and nobody is using even the limited form we already have
11:18:05 <hyperisco> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overlapping-instances
11:18:20 <mniip> I would use it if it was more conveniently available
11:18:54 <mniip> and requires less Sub-Dict patternmatching
11:18:59 <mniip> required*
11:19:06 <edwardk> base has a fairly slow adoption pattern, and limits itself to stuff that really the rest of the ecosystem can't live without. we moved Data.Functor.Classes into base because it was necessary to support some of the other stuff we moved
11:19:29 <mniip> I see...
11:19:48 <mniip> well really I'm mostly concerned about absence of kind-unrestricted lifting *anywhere* in the ecosystem
11:19:53 <edwardk> The Sub Dict thing is the best story i have for how constraints can work today in haskell. Experimenting with that in libraries is why we have libraries ;)
11:19:55 <dminuoso> Hey edwardk, I got a question. On some of your articles I saw you mentioning articles from Bartosz Mileswki 1 or 2 times. Are you familiar with his book and his lectures?
11:20:11 <dminuoso> (On category theory)
11:20:18 <hyperisco> it is interesting that containers is not in base
11:20:35 <edwardk> dminuoso: i've spent a couple months visiting him over the last couple of years helping to work on content for them, so yeah, you can say that i'm relatively familiar ;)
11:21:10 <mniip> edwardk, is there a package that implements this variable kind/constraint sort of lifting?
11:21:29 <edwardk> hyperisco: ultimately it comes down to the fact that base doesn't need anything that is offered by containers to do what it does
11:21:54 <edwardk> mniip: nope. write one, get wild adoption figures. petition to move it into base ;)
11:22:28 <mniip> Downloads  1 total (1 in the last 30 days)
11:22:30 <mniip> :p
11:22:46 <dminuoso> edwardk: Oh I did not expect that answer.. at all. With your participation, is it sound to use his materials to start learning category theory? Im just wondering whether I should get some more books and start from scratch just to ensure I dont have a skewed or bad view of CT.
11:23:11 <edwardk> i think his materials offer a pretty good intro to category theory at this point
11:23:36 <edwardk> my materials offer a heck of a lot more skewed 'haskell-centric' perspective, so if anything its better to start with what he has written up than what i have written up ;)
11:23:52 <mniip> dminuoso, I don't remember exactly his materials but I've fallen down the trap of getting a skewed view of CT when moving from haskell onto CT
11:24:05 <dminuoso> edwardk: Alright that's great to hear. Thanks. :)
11:24:09 <edwardk> depending on where you're starting from i have some other resources i like to recommend, but i don't know your math background
11:24:23 <dminuoso> edwardk: No academic background.
11:24:52 <edwardk> then if you are very patient, i'd recommend starting with lawvere and schanuel's "conceptual mathematics"
11:25:08 <mniip> I mean, there's a lot of haskell-ct materials on the internet, I don't remember whether bartosz's are one of "slippery" ones
11:25:10 <edwardk> it has the incredibly rare property among category theory textbooks that it is very gradual in its introduction of topics
11:25:53 <edwardk> bartosz's stuff largely avoids the 'this is just x in haskell' exposition traps that most other folks who learned category theory through haskell fall into
11:26:06 <mniip> yeah right
11:26:15 <mniip> I don't remember what I was reading - probably a bunch of random crap
11:26:27 <mniip> but when I learned mac lane I realized I really know nothing
11:26:30 <mniip> er
11:26:34 <mniip> but when I opened mac lane I realized I really know nothing
11:26:40 <dminuoso> edwardk: You mean like in the sense how Functors are rapidly condensed into Endofunctors are rapidly condensed into "container type of things", because that's what Haskell is mostly concerned with?
11:26:48 <Addam> mniip do you think edwardk could help in regards to the previous question?
11:27:01 <mniip> Addam, maybe if you formulate it precisely
11:27:24 <mniip> edwardk, Addam here was having issues with algebras of the state monad or something like that
11:27:26 <edwardk> dminuoso: thats an example. the parametricity vs. naturality thing that mniip and i have been talking about for the last hour or two is another. =)
11:27:36 <edwardk> Addam: how so?
11:28:03 <mniip> (in the meantime I've manage to convince myself that they don't exist)
11:28:21 <dminuoso> edwardk: Fair enough. Well thank you for the recommendation, interestingly the book was already on my list. I guess it's time to use the book store that I happen to live above.. :-)
11:28:31 <edwardk> coalgebras for the store comonad are interesting in that they give you lenses
11:29:06 <edwardk> but when you try to turn that around to get prisms you find that its not just a matter of slapping co in front of everything  and getting state monad algebras
11:29:29 <edwardk> not sure what you're looking for in the state monad algebra world
11:32:44 <mniip> edwardk, is my suspicion correct that for any non-initial and non-terminal s, there are no State s-algebras?
11:32:54 <edwardk> no idea. never looked
11:33:34 <mniip> I mean, we're looking at a  (s -> (s, a)) -> a  type thing
11:33:43 <mdim> edwardk: metahumor: I still have problems with implementing this: https://paste.debian.net/1003316/ (the code is the upper part, the expression to evaluate and the error message are at the bottom.)
11:34:14 <mniip> if we make up an s in the algebra then it might not satisfy the diagrams for join/bind
11:34:27 <mniip> if s has multiple inhabitants
11:34:46 <edwardk> you get to know both s and 'a' here.
11:34:57 <edwardk> pick a = (s -> (s, b))
11:35:01 <mniip> ah indeed
11:35:57 <edwardk> next try to pick a = (t -> (t, b)) -- where there is some lens from t to s or s to t. haven't done it yet, but try
11:36:07 <edwardk> those are the things i'd suspect
11:36:07 <mniip> okay so I did interpret the quantifiers (exists/forall) wrong back then
11:36:42 <mniip> edwardk, anyway wrt solving problems in the ecosystem, I've recently solved (attempted) one
11:37:24 <mniip> edwardk, there had to be a package that hammers natVal with unsafeCoerce to get a nice set of singletons and/or elimination functions
11:37:43 <mniip> and so it came to be https://hackage.haskell.org/package/singleton-typelits
11:38:15 * hackage brick 0.32.1 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.32.1 (JonathanDaugherty)
11:38:17 <edwardk> did you see https://github.com/ekmett/constraints/blob/master/src/Data/Constraint/Nat.hs ?
11:38:25 <mniip> yes
11:38:28 <edwardk> k
11:38:31 <mniip> too much magic
11:38:36 * edwardk shrugs.
11:38:40 <edwardk> needed the magic =)
11:38:44 <Addam> mniip and edwardk - so only for a = s->(s,x) ?
11:39:06 <edwardk> Addam: not necessarily. i offered it up as an easy source of examples
11:39:28 <mniip> ah no
11:39:31 <mniip> magic is fine
11:39:32 <mniip> axiom is not
11:39:32 <edwardk> pick apart the state monad, look at reader and writer
11:40:02 <Addam> :t Reader
11:40:03 <lambdabot> error:
11:40:03 <lambdabot>     • Data constructor not in scope: Reader
11:40:03 <lambdabot>     • Perhaps you meant one of these:
11:40:07 <edwardk> mniip: i needed the axiom based math or i'd spend forever passing around unused knownnat calculations
11:40:24 <mniip> edwardk, but while the state functor is a composition of a reader functor and writer functor, the state monad is not
11:40:46 <edwardk> Addam: next place i'd look would be a = (s -> b)
11:40:54 <edwardk> (->) is "reader"
11:41:12 <edwardk> not saying it works. haven't bothered working it out yet
11:41:18 <edwardk> just saying where i'd look for instances
11:41:38 <edwardk> if its the wrong way around then look at StateT, etc.
11:42:04 <edwardk> then a = (), etc.
11:42:13 <mniip> edwardk, I felt like leaving deriving formal arithmetic axioms as an exercise to the reader
11:42:14 <Addam> the last one doesn't work
11:42:15 * hackage hoauth2 1.6.1 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-1.6.1 (HaishengWu)
11:42:26 <mniip> thing is, deriving them is *impossible* without at least some unsafeCoerce somewhere
11:42:32 <mniip> so I made a package with just that
11:42:37 <mniip> so that unsafeCoerce is all in one place
11:42:49 <edwardk> Addam: sure. axiom is unsafeCoerce after all ;)
11:42:54 <edwardk> er mniip
11:43:22 <mniip> I suppose,
11:43:24 <mniip> what was that package...
11:44:09 <mniip> it was jle's I think
11:44:31 <mniip> typelits-witness
11:45:13 <edwardk> i wrote that little thing into constraints, then a couple other folks wrote variations on the theme, at least one with a ghc plugin
11:45:17 <Gurkenglas> mniip, why are there two "KnownNat b"s for https://hackage.haskell.org/package/singleton-typelits-0.0.0.0/docs/GHC-TypeLits-Induction.html#v:induceBaseComp ?
11:46:12 <mniip> hmm
11:46:19 <mniip> might be an oversight but it isn't critical
11:46:53 <Gurkenglas> The "r b" argument is in order to make the type unambiguous, yes?
11:46:58 <mniip> yes
11:47:03 <mniip> you need to tell it which base
11:47:07 <mdimjasevic> Getting back to my first question, restated: is there an implementation of the "Data Types A La Carte" paper that can be used with the current GHC?
11:47:44 <Addam> edwardk not sure; been looking at this with mniip for a while now, still didn't find a way
11:48:01 <Gurkenglas> Ah, so that's what that does. Recommend "'induceTwosComp' but with custom Two" for the doc
11:48:17 <mniip> "for very high values of two"
11:49:15 * hackage pandoc-citeproc 0.12.2.3 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.12.2.3 (JohnMacFarlane)
11:49:44 <mniip> indeed it compiles just fine without that extra knownNat
11:50:27 <mniip> Gurkenglas, is this a readable piece of documentation https://hackage.haskell.org/package/singleton-typelits-0.0.0.0/docs/GHC-TypeLits-Singletons.html#t:NatBaseComp
11:50:34 <mniip> I was super unsure of what to write in these
11:50:59 <mdimjasevic> I'm trying to understand that paper so if someone can help with resolving that issue that I mentioned earlier ( https://paste.debian.net/1003316/ ), I'd be grateful.
11:52:55 <Gurkenglas> mniip, "another natural number plus a digit k in [0, b[." and also explain why p is necessary in the docs
11:53:51 <mniip> is it not evident?
11:53:58 <Gurkenglas> I had to ask
11:54:17 <mniip> is this a "docs should mention about p" or "I don't understand what p is for"
11:54:59 <Gurkenglas> I think p is for unambifying k and that the docs should include a link to where that concept is documented
11:55:12 <edwardk> gotta run
11:55:25 <edwardk> Addam: sorry if i didn't fully resolve your question
11:56:20 <Addam> no problem edwardk; do you think you might be able to help later?
11:56:46 <edwardk> well the above list are kind of where i'd start looking for them
11:57:40 <edwardk> sit down and write the laws for a monad algebra down, then check them against a bunch of data points like a = s -> s, etc.
11:57:44 <Gurkenglas> Then again, I also think http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Proxy.html# should explain why you'd ever want Proxy.
11:57:58 <edwardk> Gurkenglas: its the terminal monad
11:58:09 <edwardk> and it can be used for a bunch of other stuff
11:58:49 <Addam> edwardk for a you mean the set A?
11:59:19 <edwardk> for that matter data ProxyT m a = ProxyT -- is interesting because its the terminal monad transformer
12:02:00 <mniip> Gurkenglas, wait, p in which thing
12:02:20 <mniip> in NatBaseComp it's the type of the child singleton
12:02:23 <mniip> singleton of the digits
12:04:51 <Gurkenglas> I suppose asProxyTypeOf gives the use case. Terminal monad sure does sound like it justifies implementation, though on that basis alone it sounds like either more or less stuff belongs in base?
12:06:45 <hoon> I'm playing with GHCi, I'm stopped in a function that produces a StateT Int IO () monad. is there anyway to "get" the state value?
12:07:06 <Gurkenglas> mniip, huh? in NatBaseComp p is the (KnownNat -> {()}) that locks down k, and k is the least significant digit
12:07:26 <nullie> :t runStateT
12:07:27 <lambdabot> StateT s m a -> s -> m (a, s)
12:08:03 <Gurkenglas> :t execStateT -- gives the "state" value
12:08:04 <lambdabot> Monad m => StateT s m a -> s -> m s
12:08:17 <mniip> Gurkenglas, the digit in NatBaseComp is from the range [1, b] and needs to be represented signleton-ly too
12:08:17 <EvanR> stopped in a function? the ghci debugger?
12:09:03 <mniip> NatBaseComp is a singleton transformer
12:09:04 <hoon> Gurkenglas: nullie: right, I know how to do in normally
12:09:07 <Gurkenglas> mniip, the digit is k in [0, b[ and on the type level, so we need a proxy p to get it to the value level
12:09:14 <mniip> yeah
12:09:20 <mniip> no
12:09:23 <mniip> not a proxy
12:09:24 <hoon> but within GHCi, I'm not sure that's possible
12:09:34 <Gurkenglas> (KnownNat k, (1 + k) <= b) <- "(k >= 0, k < b)"
12:09:47 <mniip> it has to be a NatSingleton
12:09:56 <mniip> which *can* be a proxy but usually you want something else
12:09:57 <hoon> EvanR: yes, running a :trace within GHCi?
12:10:01 <mniip> such as Peano
12:10:13 <EvanR> hoon: ghci is like an IO block, not any other monad
12:10:35 <edwardk> Gurkenglas: Proxy got added to base because it was needed for the "new" API of Typeable several versions ago
12:10:51 <edwardk> so we backported Proxy out of my tagged package
12:10:56 <Gurkenglas> mniip, let's agree that your documentation does not make me think the things you think obvious :P
12:11:09 <mniip> right
12:11:23 <edwardk> arguably we could have flipped the arguments and used 'Const' as a flipped form of 'Tagged'
12:11:28 <edwardk> but its a lot harder to use
12:11:30 <hoon> EvanR: so when running with breakpoints in GHCi, everything is still within an IO monad context, not the program's local context?
12:13:42 <Gurkenglas> I've previously wanted ghci to accept the likes of "(`evalStateT` (1,5)) $ do" for changing monadic context
12:16:18 <hoon> Gurkenglas: similar to what I'm hoping to do
12:31:24 <edwardk> :t flip evalState
12:31:25 <lambdabot> s -> State s c -> c
12:31:47 <edwardk> Gurkenglas: i usually use that or evalState ?? myState $ do ...
12:31:51 <edwardk> :t (??)
12:31:52 <lambdabot> Functor f => f (a -> b) -> a -> f b
12:32:08 <edwardk> oh
12:32:10 <edwardk> derp misparsed
12:32:15 <edwardk> you mean you want ghci to have such a state
12:32:38 <Gurkenglas> More to have it change into any monad so long as I provide a way to go back to IO
12:32:58 <edwardk> i guess you could make an IORef, then make a MonadState instance that mutates it =)
12:33:40 <edwardk> instance MonadState YourState IO where
12:34:03 <Gurkenglas> If I say "void $ runListT $ do", give me nondeterminism
12:34:27 <edwardk> the problem is what do you print between steps
12:34:31 <dmwit> Gurkenglas: You might like https://stackoverflow.com/q/42425939/791604
12:34:58 <Gurkenglas> edwardk, rephrase that?
12:35:06 <edwardk> i can lift you into ContT, but i have no real belief that i can meaningfully print out the result of each step.
12:35:14 <edwardk> the REPL gives you answers
12:35:19 <edwardk> > map (+1) [1..10]
12:35:21 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
12:35:32 <edwardk> in other monads i can't necessarily do that
12:36:36 <edwardk> e.g. consider data ProxyT m a = ProxyT -- it is a monad transformer, lift works, etc. but i sure as heck ain't getting a response out of it when i do lift $ print $ map (+1) [1..10] -- or however the REPL will translate my code there.
12:37:36 <edwardk> if you just want the ability to 'change your monad' you can of course use a :{ block or something and type in the multiline expression, but i can't give you all that REPLy goodness there.
12:38:00 <Gurkenglas> Can't it just implicitly do ">>= print"?
12:38:16 <edwardk> the repl does different things based on the result type
12:38:19 <Gurkenglas> ProxyT would obviously not give anything back, ListT IO might print multiple results, etc
12:38:55 <edwardk> if its IO a then it runs the action in IO, then prints the result if its a then it prints the result directly. so the handling is already messily type directed
12:39:43 <edwardk> now consider something like Cont where the 'printing' can't even happen yet. and might happen multiple times depending on how many times through the random pachinko machine worth of continuations you go in that final chunk of code
12:40:02 <edwardk> i'm not giving you spontaneous feedback between steps there either.
12:40:22 <edwardk> its only with the well behaved reader/writer/state/either cases where this makes a modicum of sense
12:41:11 <Gurkenglas> It'd proceed as far as it is able without accessing the do block lines I haven't written yet. If your first few lines of a Cont do block are strict in the continuation, it'll have to wait with evaluating that.
12:41:50 <edwardk> how does that work? i can't just restart the computation from the first line because it might reference an IORef i introduced in a previous definition in the repl
12:42:19 <edwardk> i have no idea how to implement the magic repl you want
12:44:02 <Gurkenglas> Holding the thunk that tried to access the future until the future is the present sounds easy to me, maybe I haven't understood yet how this is actually implemented?
12:44:09 <edwardk> i could see giving you one where if you wrote something like the above with a hanging do block, it let you keep making more statements and just swallowed them all until the do block ended, and let you still do :t type stuff, but the repl would change in flavor drastically
12:45:20 <edwardk> The notion of 'the thunk' is ambigous in your ListT example or in ContT or LogicT or anything that uses any real level of non-determinism.
12:45:37 <edwardk> and everything i can think of involves some completely one-off logic per monad to even try
12:45:52 <edwardk> mostly just wanted to take your comment seriously and point out that its hard
12:51:48 <Gurkenglas> In ListT we cannot access the future, so maybe you mean ListT (ContT r IO) or ContT r (ListT IO)
12:55:40 <hoon> so...long story short; I can't do what I want :) ;)
12:55:42 <hoon> ?
12:59:35 <Gurkenglas> One of them shares the continuation and one has lots of them, but if one future needs to be waited for all of the next ones in the arbitrary order ListT prescribes will also have to wait; if one wants interleaving one will need mniip's IOT
13:00:34 <EvanR> hoon: esp if what you want doesnt make sense
13:00:59 <Gurkenglas> -future+continuation
13:02:17 <Gurkenglas> (Wait, does ListT order the monadic actions depth-first or breadth-first? If the former then ListT is less obviously suited for being a repl context)
13:02:36 <Gurkenglas> It'd be more of a backtracking device than a nondeterminism transformer
13:05:58 <hoon> EvanR: why doesn't it make sense? -- if I'm not too dense in asking
13:08:05 <hoon> I'm within a monadic context within the debugger why shouldn't I be able to query the state with get, inparticular if it's strictly evaluated
13:08:52 <Gurkenglas> Oh wait, I think I misunderstood what hoon wanted the whole time. hoon, what you want is to replace the StateT Int IO () action that is currently being computed by one that prints the current state
13:09:18 <Gurkenglas> (And then, perhaps, goes on to do its original thing)
13:09:23 <hoon> yes
13:09:57 <Gurkenglas> I don't know what I'm talking about, but this ought to be possible, and you may be able to do it with Cheat Engine if nothing else
13:10:45 <Gurkenglas> Replacing the current thunk t with "(get >>= print) >> t"
13:11:37 <Gurkenglas> *"(get >>= liftIO . print) >> t" <.<
13:12:17 <hoon> something like that
13:12:26 <hoon> and I could just update the code to do that, I guess
13:12:59 <Gurkenglas> Okay. EvanR, does wanting to directly edit a thunk while ghci is at a breakpoint make sense?
13:14:18 <Addam> mniip seems likely to me it's best to give up
13:14:23 <edwardk> you keep saying "the current thunk" but data PairT m a = PairT (m a) (m a) -- has two. and I can use either or neither or both. generalizing that ReaderT e m a = ReaderT (e -> m a) has a function space full of them, that i can probe as many times as i like.
13:14:40 <edwardk> Addam: what are you looking for these algebras for anyways?
13:15:35 <Addam> studying monads and algebras, started with the algebra for lists and tried with the state monad
13:16:10 <Gurkenglas> edwardk, you have to provide a way to turn PairT m a or ReaderT e m a back into an IO value, which seems to give a canonical way to provide a choice or order or value of e
13:16:28 <Addam> been reading some online tutorials and papers but no luck in finding how to deal with the algebra for a state monad
13:17:32 <Addam> tried some and the laws aren't always satisfied
13:17:58 <Addam> mniip tried to help me a lot and we did not find any solution
13:18:03 <Addam> might just give up now
13:18:46 * hackage websockets 0.12.3.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  https://hackage.haskell.org/package/websockets-0.12.3.0 (JasperVanDerJeugt)
13:22:39 <mniip> edwardk, that paper you liked seems like it might be a bit over my head
13:22:42 <mniip> linked*
13:23:23 <edwardk> Addam: well, let's see
13:24:00 <edwardk> let's bottle this up unnecessarily in a typeclass for now
13:24:05 <edwardk> so its easier to write instances, etc.
13:24:20 <edwardk> https://www.irccloud.com/pastebin/L3HN9RmL/
13:24:36 <edwardk> now the first obvious instance is
13:24:38 <edwardk> instance MonadAlgebra (State s) (State s a) where phi = join
13:25:02 <edwardk> but you should be able to write instance Monad m => MonadAlgebra (State s) (StateT s m a) -- hrmm.
13:25:14 <edwardk> instance Monad m => MonadAlgebra (State s) (StateT s m a) where phi m = join $ state (runState m)
13:25:15 * hackage dib 0.7.0 - A simple, forward build system.  https://hackage.haskell.org/package/dib-0.7.0 (blajzer)
13:25:26 <edwardk> that subsumes the first instance i went to write
13:25:38 <edwardk> similarly as a special case
13:25:54 <edwardk> instance MonadAlgebra (State s) (Endo s) where phi m = Endo $ \s -> case runState m s of (f, s) -> appEndo f s -- seems to typecheck in my brain
13:26:03 <edwardk> but thats the same as having State s () as an algebra of State s
13:26:12 <hoon> Gurkenglas: thanks for trying to help. It's really not important as I'm just toying around with GHCi as a learning experience
13:26:23 <kamyar> I have a couple of questions about Parallel and Concurrent programming in Haskell
13:26:41 <edwardk> now for initial/terminal 's' choices there are also the instances that mniip was suggesting
13:26:52 <hoon> I can (and did) inject exactly what I had intended to query via the debugger within the StateT code and can see the values of interest
13:27:12 <edwardk> but the StateT s m a example is probably the more compelling direction
13:27:28 <hoon> I just assumed I'd be able to do that from within the debugger by typing it at the ">" prompt while the debugger was stopped
13:27:36 <edwardk> Addam: so that gives a whole family of these things
13:28:44 <mniip> hoon, the ghci debugger is horrifying
13:29:36 <mniip> ...I wish I had the motivation to complete such a big project as teaching gdb hec/stg
13:29:58 <edwardk> so to make that complete, if we remove the fundep in the class i wrote you get
13:30:13 <edwardk> instance MonadAlgebra (State ()) a where phi = flip evalState (); instance MonadAlgebra (State Void) () where phi _ = ()
13:30:28 <hoon> haha
13:30:39 <hoon> mniip thanks for the heads-up
13:30:50 <mniip> I mean I see it's able to demangle names from DWARF2 information now
13:30:52 <edwardk> Addam: that make sense?
13:30:58 <mniip> but still no banana even for the evaluation stack
13:31:47 <edwardk> for Addam https://www.irccloud.com/pastebin/zpBU6ow9/Addam.hs
13:32:15 <mniip> edwardk, aren't you also the kind of guy who loves to hop between antipodal levels of abstractions
13:32:25 <mniip> jumping out of profunctor optics straight into assembly
13:33:06 <mniip> I don't know many people like that
13:33:25 <edwardk> Sure, I always figure one of the most important skills for a computer scientist is to be able to change your level of focus freely
13:33:54 <mniip> level of focus heh
13:33:59 <mniip> I wish motivation always followed :P
13:34:19 <Rembane> mniip: Organize a hackathon and brainwash the participants so they teach gdb hec/stg.
13:34:24 <edwardk> motivation is overrated.
13:34:26 <kamyar> What is the main function of Eval monad (rpar and rseq functions) What if I dont use them?
13:34:30 <mniip> Rembane, uhhhh
13:34:37 <Addam> looking into it now edwardk
13:34:38 <mniip> you need to know a metric ton of stuff
13:35:00 <Rembane> mniip: Oh... maybe you should start a cult instead.
13:35:06 <kamyar> As far as I understood from the book "parallel and concurrent prog..."
13:35:11 <mniip> cult of the bound variable?
13:35:19 <Rembane> Seems legit
13:35:23 <kamyar> when I have a 'do' statement
13:35:45 <kamyar> the monad makes the actions take place parallel
13:35:59 <edwardk> There is that long standing notion that a mathematician is an odd sort of tailor, making all sorts of clothing without much regard to whether anybody exists that will fit into it.
13:36:02 <kamyar> but AFAIK when I have not IO statement
13:36:02 <mniip> Rembane, like I think in this channel maybe a dozen people posess the necessary knowledge
13:36:18 <kamyar> the actions take place in parallel
13:36:23 <Rembane> kamyar: Only if you run them using rpar.
13:36:24 <kamyar> am I wrong?
13:36:57 <Rembane> mniip: Ach. That doesn't sound very promising for the start of a cult I'm afraid.
13:37:05 <kamyar> Rembane: Figure out I have several calculative statements in a do block
13:37:08 <mniip> Rembane, how many people do you know who could explain how the id function compiles to machine code?
13:37:27 <Rembane> mniip: Hm... can you do that?
13:37:32 <kamyar> Rembane: Dont they run parallel automatically without Eval moad?
13:37:39 <Rembane> kamyar: No.
13:37:48 <mniip> I vaguely remember all the running parts, but I know exactly what to consult
13:37:49 <kamyar> Rembane: So what?
13:37:53 <Rembane> kamyar: You have to run them in rpar.
13:37:56 <mniip> the ghc wiki on heap objects
13:38:03 <mniip> documents the tricks of entering various closures
13:38:13 <mniip> id's closure should just tail-enter its first and only argument
13:38:14 <mniip> or something
13:38:19 <kamyar> Rembane: And if not?
13:38:20 <Rembane> mniip: then I know of 0.5 people I guess.
13:38:27 <Rembane> kamyar: They run sequentially.
13:38:53 <kamyar> Rembane: But sometime some Haskell pro told me actions within do run sequentially only if they are IO actions
13:39:11 <Rembane> kamyar: What do they do otherwise?
13:39:20 <kadoban> kamyar: That doesn't sound quite right
13:39:33 <EvanR> "run" doesnt sound right
13:39:42 <kamyar> Rembane: You mean they run sequentially anyway?
13:40:01 <EvanR> the key action is to evaluate something to WHNF
13:40:14 <mniip> and there was like, a stack
13:40:27 <EvanR> a thread only does that one at a time
13:40:29 <Rembane> kamyar: Most often. But EvanR is using the proper terminology, and I am not. I fell down into the C pit when I was a kid and got all the terminology from there. :)
13:40:47 <mniip> and some registers have specific meanings (stack top, heap, current continuation)
13:41:05 <kamyar> EvanR: Yes I feel you are right! I must not use 'run'
13:41:31 <Addam> :t flip
13:41:32 <lambdabot> (a -> b -> c) -> b -> a -> c
13:41:32 <EvanR> it doesnt necessarily happen in the order you expect
13:41:54 <EvanR> so that might have some bearing on whether you think its sequential
13:42:22 <kamyar> EvanR: But does not happen simuletanuously either
13:42:31 <mniip> Rembane, * and then* there's this dwarf thing
13:42:46 <EvanR> not unless you specifically ask for two things to be evaluated in parallel
13:42:49 <mniip> that tells the debugger how to make sense of register values
13:42:58 <mniip> and other stuff
13:43:24 <Rembane> mniip: Does this mean that you have to have an intimate understanding of GHC, DWARF, gdb and low level machine programming?
13:43:37 <mniip> yes
13:43:50 <mniip> or well, be able to acquire it quickly
13:44:00 <kamyar> EvanR: and I can do it using forkIO and async too. Yes?
13:44:02 <mniip> with documentation
13:44:11 <Rembane> mniip: That sounds really fun and frustrating at the same time.
13:44:22 <mniip> hehe
13:44:33 <EvanR> you can use forkIO, use the threaded runtime, and increase the number of capabilities using -N
13:44:57 <kamyar> EvanR: So what is the preference of Eval moad?
13:44:58 <EvanR> then you have a chance of it running in parallel, but thats not what those are for
13:45:06 <EvanR> what is Eval moad
13:45:28 <kamyar> EvanR: I mean rpar and rseq
13:45:41 <kamyar> Eval monad
13:46:02 <EvanR> oh
13:46:07 <mniip> Evil monad
13:46:14 <EvanR> Control.Parallel is for parallel
13:46:22 <EvanR> thats how you ask for things to be evaluated in parallel
13:46:26 <mniip> ... I've written that once
13:46:43 <kamyar> EvanR: Why not forkIO?
13:46:47 <Rembane> Control.Monad.Evil?
13:46:53 <EvanR> forkIO is for concurrency
13:47:18 <EvanR> it lets you create concurrent IO threads
13:47:25 <kamyar> EvanR: I can use forkIO + RTS + -N then
13:47:40 <EvanR> for what exactly?
13:47:47 <kamyar> EvanR: Then I have a parallel program
13:47:48 * hackage cpsa 3.4.1 - Symbolic cryptographic protocol analyzer  https://hackage.haskell.org/package/cpsa-3.4.1 (mliskov)
13:47:56 <EvanR> do you have a specific question
13:48:10 <kamyar> EvanR: Yes! It is my next question
13:48:19 <EvanR> there are different tools for different things
13:49:13 <kamyar> EvanR: I am trying to write some code for http benchmarking
13:49:16 <mniip> Rembane, oh also I've debugged a bug of this level once
13:49:23 <mniip> Rembane, it was "fun"
13:49:27 <kamyar> EvanR: The problem is that when I use async/wait
13:49:48 <kamyar> EvanR: The time returns from high to low
13:49:55 <kamyar> lets see my code
13:49:57 <mniip> the performance bearings of reverse debugging combined with the footprint of ghci
13:50:22 <EvanR> http benchmarking doesnt sound like a parallel issue
13:50:33 <EvanR> since you are waiting most of the time for responses
13:50:34 <mniip> Rembane, https://ghc.haskell.org/trac/ghc/ticket/12523
13:50:39 <EvanR> you dont need parallelism
13:50:57 <Average-user> Hi! any of you know a function like nub but for Sequences?
13:51:27 <kamyar> EvanR: But I need to simuate multiple clients requesting the server
13:51:47 <EvanR> forkIO would do that even without parallelism
13:51:57 <EvanR> youre asking about concurrency
13:52:24 <kamyar> EvanR: But I guess the lazy evaluation is ruining my time measurements
13:52:32 <kamyar> http://lpaste.net/361269
13:52:53 <EvanR> theres no lazy evaluation there
13:53:06 <EvanR> you might be thinking of lazy IO, which youre not using
13:53:08 <kamyar> EvanR: Did u see my code?
13:53:25 <EvanR> yes
13:53:47 <kamyar> EvanR: But the times for each call of worker differs significantly
13:53:52 <Addam> edwardk would you mind walking me a bit through the code
13:53:59 <metahumor> Average-user: do you want to remove adjacent duplicates or all duplicates?
13:54:07 <edwardk> Addam: shoot
13:54:35 <Addam> so 15-17 aren't necessary
13:55:23 <metahumor> Average-user: "nub (x:<|y:<|xs) = if x == y then nub (x<|xs) else x <| nub xs"
13:55:40 <Addam> maybe it could be helpful if you could write an example with numbers
13:56:00 <EvanR> kamyar: well wait, first thing is Wreq's get ... this might return a response immediately
13:56:40 <kamyar> EvanR: And this is called lazy evaluation yes?
13:56:45 <EvanR> no
13:57:03 <kamyar> EvanR: When the response is getting read?
13:57:45 * hackage dib 0.7.1 - A simple, forward build system.  https://hackage.haskell.org/package/dib-0.7.1 (blajzer)
13:57:55 <EvanR> i am reading the code trying to figure that out
13:58:11 <EvanR> the docs seem to be missing the explanation
13:59:00 <kamyar> EvanR: When I call worker for the same address multiple times in lines
13:59:12 <kamyar> EvanR: The time is not almost near
13:59:36 <EvanR> why should they be
13:59:40 <edwardk> Addam: first observation: given a monad M, MA is an algebra of M, this is easy to show.
13:59:43 <EvanR> assuming were talking about real webservers
13:59:52 <edwardk> Addam: phi = join works fine
14:00:15 <edwardk> Addam: this was the statement I made about how (State s a) is a monad-algebra of State s.
14:00:26 <kamyar> EvanR: When I call the function for 10 times for example, the 10th time differs significantly with 1st time
14:00:29 <Addam> ok
14:00:47 <edwardk> phi . fmap phi = phi . join becomes join . fmap join = join . join -- which is a monad law, and id = phi . return -- becomes id = join . return  another law.
14:01:03 <edwardk> now, State s () is isomorphic to Endo s
14:01:20 <edwardk> that gives us the (State s)-monad algebra Endo s.
14:01:35 <edwardk> all i'm doing there is converting back and forth and doing the join.
14:01:57 <EvanR> kamyar: and?
14:02:15 <kamyar> EvanR: And it should not!
14:02:19 <EvanR> why do you think that
14:02:37 <EvanR> have you tried the ping utility
14:03:05 <kamyar> EvanR: Yes but ping time does not differ significantly
14:03:13 <edwardk> next observation is that i can embed via a monad monomorphism  State s    into StateT s m, and because it is a full state-monad monomorphism, everything should work the same whether i join 'inside' or outside. this is the instance Monad m => MonadAlgebra (State s) (StateT s m a)
14:03:19 <mniip> ping ehh
14:03:20 <mniip> try mtr
14:03:22 <edwardk> :t state . runState
14:03:23 <lambdabot> MonadState s m => State s a -> m a
14:03:36 <edwardk> is that monad monomorphism
14:04:00 <mniip> mtr shows all kind of statistics for all intermediate hops
14:04:08 <kamyar> EvanR: And keep in mind: the times are granually getting low from a high value
14:04:18 <EvanR> kamyar: i have a hard time believing that your hypothesis that all web requests should take around the same time is valid
14:05:07 <EvanR> also i found evidence that "get" gets the whole response body before continuing, so no lazy IO
14:05:19 <edwardk> Addam:  the last two instances observe that if you have () -> (a, ()) that is isomorphic to a, so phi is uniquely determined
14:06:05 <edwardk> and Void -> ((), Void)    is an initial morphism, so its uniquely determined so there is only one of them, and so the mapping from that to () is uniquely determined (ignoring undefined ())
14:06:59 <EvanR> and i see no reason why going from 1 core to 4 cores will make your experiment fit your expectations
14:07:05 <Addam> ok, the last thing is clear
14:08:00 <edwardk> Addam: and that is the list of all the instances i came up with during that sort of stream of consciousness braindump
14:08:08 <edwardk> i didn't prove anything about no others existing
14:08:17 <EvanR> another thing you can try is open your browsers debugger and look at the amount of time it takes to download a particular piece of the webpage. keep refreshing and see that time change
14:08:21 <edwardk> but these all felt 'right' and pretty obviously pass the laws.
14:08:25 <Rembane> mniip: That bug looks "fun" indeed.
14:12:14 <Addam> surely the last two do pass the laws
14:12:19 <Addam> working on the others
14:13:32 <Average-user> metahumor: all duplicates
14:15:52 <metahumor> Average-user: then use my "nub" above after "Seq.sort"
14:17:01 <metahumor> or if you don't care about order, you can even "Seq.unstableSort"
14:19:47 <edwardk> Addam: the State one i gave first is probably the easiest to see.
14:20:02 <edwardk> as mentioned above: phi . fmap phi = phi . join becomes join . fmap join = join . join -- which is a monad law, and id = phi . return -- becomes id = join . return  another law.
14:20:16 * hackage simpleconfig 0.0.1 - Short description of your package  https://hackage.haskell.org/package/simpleconfig-0.0.1 (AlexeyKotlyarov)
14:20:55 <edwardk> And if you believe that one then Endo s ~= s -> s ~= s -> ((),s) ~ State s ()    is another instance of the same pattern
14:35:15 * hackage bytestring-progress 1.0.8 - A library for tracking the consumption of a lazy ByteString  https://hackage.haskell.org/package/bytestring-progress-1.0.8 (AdamWick)
15:27:47 <Addam> ok edwardk, let me work on it
16:13:17 <dukedave> I just started following the HTF tutorial. I'm using Stack with lts-10.1, but I'm getting `ghc: could not execute: htfpp`. Is there something I need to do to tell stack to make `htfpp` available?
16:14:31 <Axman6> what's HTF?
16:14:47 <dukedave> @Axman6 http://hackage.haskell.org/package/HTF-0.13.2.2/docs/Test-Framework-Tutorial.html
16:14:47 <lambdabot> Unknown command, try @list
16:14:48 <Axman6> I would guess you need to run stack install <the thing that provides htfpp>
16:17:11 <MarcelineVQ> the cabal file of HTF provides the htfpp executable, so  stack install HTF  should provide htfpp  in ~/.local/bin
16:17:55 <Axman6> I've never heard of HTF before, does it offer much that tasty doesn't?
16:17:56 <MarcelineVQ> alternatively running  stack build HTF  from within your project's directory should make htfpp available to on your project's path
16:19:13 <MarcelineVQ> you can find out by writing   stack exec -- which htfpp     I think there's a better command than which as well, but I can't recall it atm
16:19:20 <MarcelineVQ> *find out if you have one and where
16:21:08 <MarcelineVQ> ah whereis
16:21:59 <noumenon> alright, time to give learning Haskell properly another go
16:22:50 <noumenon> I've gone through basic introductions like learn you a haskell, but going to go through it and others again; what are some of the resources you most recommend for a haskell beginner coming from being advanced+ in python and javascript?
16:23:40 <juri_> 1: forget everything you know. python and javascript are not advanced languages.
16:23:48 <geekosaur> LYAH is a decent grand tour but a lousy learning resource
16:23:50 * juri_ RUNS
16:23:59 <juri_> I'm totally kidding! :)
16:24:01 <geekosaur> urgh. can we not start that please
16:24:36 <noumenon> yeah, I realize the difference, was more of an indication that I'm familiar with programming in general
16:24:37 <juri_> I'd start reading others' haskell code, turning up the compiler warnings.
16:24:46 <geekosaur> the haskell wikibook is also not the greatest, but it at least includes a decent number of exercises. CIS194 online course is also useful
16:24:49 <geekosaur> @where cis194
16:24:49 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
16:25:03 <geekosaur> ...note that the later editions of that course are not as good
16:25:24 <beauby> Talking about reading others' haskell code, any recommendation of libs to look at to get a feel of how to organize code in haskell?
16:26:44 <dukedave> Thanks Axman6, the `stack install` led me to https://docs.haskellstack.org/en/stable/GUIDE/#adding-dependencies, which led me to add `HTF` to my `dependencies`, which resolved my issue.
16:27:06 <noumenon> so LYAH is not really a good learning resource, and neither is the wikibook really; I'll check out that course, but do you know any good or great learning resources?
16:27:48 <Welkin> there isn't a ton
16:27:57 <Welkin> only a few decent/okay books
16:28:08 <dukedave> Since I'm here @noumenon  I'll say that I learned it on a university course, and that learning it any other way seems like a terrifying prospect. So I'd recommend finding a free course online :)
16:28:16 * hackage simpleconfig 0.0.5 - Short description of your package  https://hackage.haskell.org/package/simpleconfig-0.0.5 (AlexeyKotlyarov)
16:28:32 <Welkin> I learned it using LYAH, this channel, the UPenn course, and just doing it
16:28:33 <noumenon> I see; I did study computer engineering for almost 5 years
16:28:44 <noumenon> no haskell there though, heh
16:28:46 <Welkin> a university course in haskell would suck
16:28:52 <EvanR> :|
16:28:53 <Welkin> it would have killed my motivation to learn it
16:28:54 <Rembane> noumenon: Have you had experience with a ML language or a Lisp or something?
16:29:12 <noumenon> negligible, mostly reading about them
16:29:18 <Welkin> noumenon: me too, computer engineering (assembly, c, HDL)
16:29:35 <Welkin> the best way to learn is to just get started with something
16:29:38 <Welkin> anyting!
16:29:42 <Welkin> there is no perfect resource
16:29:44 <noumenon> haha, right
16:29:45 <Rembane> Welkin: HDL, is that the granddad to VHDL?
16:29:58 <Rembane> noumenon: And come back here and ask all the questions! :D
16:29:58 <Welkin> it's better to start learning something than to sit around trying to gather all the best resources but not using them
16:30:04 <geekosaur> noumenon, to be honest the best book out there is Hutton's Programming in Haskell 2nd ed.
16:30:09 <hpc> Rembane: it's like in radio, the V stands for "very"
16:30:11 <Welkin> Rembane: hardware description languages in general
16:30:19 <noumenon> yeah, I'm going to use you guys for everything you're worth
16:30:23 <Rembane> Welkin: Oh. Cool.
16:30:23 <dukedave> @Axman6 I hadn't heard of tasty (I'm new to Haskell testing), but tasty has nearly 10x stars on its GH repo, so I think I might switch :)
16:30:23 <lambdabot> Unknown command, try @list
16:30:43 <Rembane> hpc: Very Hardware, Such RAM, wow!
16:31:04 <noumenon> alright, I'm noting down all the resources
16:31:25 <geekosaur> re VHDL: the V is the commercial version giving you two fingers :p
16:33:27 <MarcelineVQ> dukedave: something that confused me about tasty initially is that it's hard to tell how to use it from it's docs, but that's beacause the use of it is provided by other packages  tasty-hunit  tasty-quickcheck etc
16:42:00 <dukedave> Did you have prior experience using e.g. huit MarcelineVQ ?
16:42:17 <MarcelineVQ> not too much
16:42:24 <MarcelineVQ> moreso with quickcheck
16:59:25 <beauby> Could anybody enlighten me about Reflex? I can't figure out how to actually build an Event apart from a trivial one
17:04:01 <dalaing_> someone had a reflex question?
17:04:35 <dalaing_> (also, #reflex-frp can be pretty handy)
17:06:26 <beauby> dalaing_: Oh thanks, I didn't know about that chan
17:07:01 <dalaing_> I'll happily babble on about reflex wherever I am, but it's good to know about the channel as well I guess :)
17:07:39 <beauby> dalaing_: Cool! I'll ask the question again there then
17:07:55 * dalaing_ cracks knuckles
17:14:45 * hackage simpleconfig 0.0.7 - Short description of your package  https://hackage.haskell.org/package/simpleconfig-0.0.7 (AlexeyKotlyarov)
17:30:26 <dukedave> I'm trying to make a type by copying another code snippet, but it has a few new things to me, namely a ', and a number in the type (which GHC tells me is illegal and suggests DataKinds, which I haven't heard of): https://github.com/LumiGuide/haskell-opencv/blob/5e0037a69e0a398221350f5bceb13b033923ae8c/doc/images.hs#L50
17:31:07 <dukedave> I guess the ' comes from template Haskell?
17:49:18 <iqubic> What's a good library to use for a 2D data structure that let's me me access and update any element at will?
17:49:33 <iqubic> It's going to be a small structure 4x4.
17:50:16 * hackage simpleconfig 0.0.8 - Short description of your package  https://hackage.haskell.org/package/simpleconfig-0.0.8 (AlexeyKotlyarov)
17:52:20 <beauby> iqubic: Would `Map (Int, Int) Foo` do the trick?
17:53:46 * hackage tickle 0.0.7 - A port of @Data.Binary@  https://hackage.haskell.org/package/tickle-0.0.7 (qfpl)
17:54:41 <oo_miguel> sum $ map read  $ words  "11 1.9"
17:54:48 <oo_miguel> what is wront about this?
17:55:42 <oo_miguel> why does haskell make assumptions about the type of this expression?
17:56:04 <iqubic> beauby: Does that let me both access and update all members of the map at any time?
17:56:05 <oo_miguel> It works when I explicitly supply ::Double
17:56:37 <iqubic> > sum $ map read $ words "11 1.9"
17:56:39 <lambdabot>  *Exception: Prelude.read: no parse
17:56:53 <iqubic> > words "11 1.9"
17:56:54 <lambdabot>  ["11","1.9"]
17:57:15 <iqubic> > map read ["11","1.9"]
17:57:17 <lambdabot>  [*Exception: Prelude.read: no parse
17:57:28 <iqubic> I'm not sure why that doesn't work.
17:57:37 <oo_miguel>  map read ["11","1.9"] :: Double
17:57:44 <oo_miguel>  map read ["11","1"]
17:57:55 <oo_miguel> how do i Tell the bot to eval an expression?
17:58:10 <beauby> oo_miguel: Use a chevron (">")
17:58:25 <oo_miguel> oops thx
17:58:30 <oo_miguel> > map read ["11","1"]
17:58:31 <lambdabot>  [*Exception: Prelude.read: no parse
17:58:40 <beauby> > map (\x read x::Double) ["11", "1.9"]
17:58:41 <lambdabot>  <hint>:1:23: error: parse error on input ‘)’
17:59:01 <oo_miguel> > sum $ map read  $ words  "11 19"
17:59:03 <lambdabot>  30
17:59:10 <oo_miguel> this works on the other hand
17:59:16 <Rembane> > map read ["1", "2", "3"] :: [Int]
17:59:17 <lambdabot>  [1,2,3]
18:01:02 <oo_miguel> For me it seems inconsistent that  "1 2 3" works fine but for "1.0 2.0 3.0" i have to explicitly supply the expected type.
18:01:31 <beauby> > sum $ map (\x -> read x::Double) $ words "11 1.9"
18:01:33 <lambdabot>  12.9
18:02:21 <oo_miguel> yes
18:03:06 <oo_miguel> > sum $ map read  $ words  "1 2 3" -- but this works without explicit type
18:03:08 <lambdabot>  6
18:03:30 <oo_miguel> so for some reason haskell makes assumptions what the string contains, right?
18:03:40 <mmaruseacph2> @type 1.9
18:03:41 <lambdabot> Fractional p => p
18:03:56 <mmaruseacph2> and it doesn't default to Double
18:04:11 <mmaruseacph2> @type 3
18:04:12 <lambdabot> Num p => p
18:04:21 <oo_miguel> sum defaults to Num?
18:04:23 <mmaruseacph2> and in this case the default rule is to consider it Int
18:04:28 <mmaruseacph2> @type sum
18:04:29 <lambdabot> (Num a, Foldable t) => t a -> a
18:06:09 <iqubic`> What is going on here?
18:06:15 <iqubic`> \leave
18:06:46 <noumenon> how about this, is this a good resource for beginners in your opinion?
18:06:47 <noumenon> http://dev.stephendiehl.com/hask/
18:09:04 <mmaruseacph2> yes
18:09:52 <iqubic> Sorry, I'm just so used to LaTeX where commands start with "\"
18:09:57 <oo_miguel> ok, Num defaults to Int? if not specified otherwise?
18:10:04 <mniip> Integer
18:10:07 <Axman6> noumenon: it's a good resource once you've written some Haskell code and read a book or two - a lot of it assumes a lot prior knopwledge, it is not a tutorial
18:10:09 <oo_miguel> how do I know that?
18:10:18 <mniip> and defaulting is a very specific process
18:10:28 <iqubic> oo_miguel: That's not what's going on here.
18:10:44 <oo_miguel> ok, maybe I should read on in my haskell book. didn't come across defaulting yet
18:10:44 <iqubic> it's defaulting to Integer.
18:11:02 <mniip> oo_miguel, https://www.haskell.org/onlinereport/decls.html#sect4.3.4
18:11:07 <iqubic> oo_miguel: most haskell books don't cover defaulting.
18:11:14 <mniip> yeah you shouldn't rely on it
18:11:19 <iqubic> what book are you learning from?
18:11:27 <mniip> it's more of an awkward consequence than a feature
18:11:28 <Axman6>  > sum $ map read  $ words  "1 2 3.1415" :: Double
18:11:32 <oo_miguel> real world haskell
18:11:38 <Axman6> >> sum $ map read  $ words  "1 2 3.1415" :: Double
18:11:41 <Axman6> > sum $ map read  $ words  "1 2 3.1415" :: Double
18:11:43 <lambdabot>  6.141500000000001
18:11:56 <iqubic> that's a bit weird.
18:12:06 <Axman6> that IEEE-754
18:12:06 <iqubic> I don't like floating point numbers.
18:12:10 <Axman6> that's*
18:12:20 <iqubic> > 0.1 + 0.2 == 0.3
18:12:21 <lambdabot>  False
18:12:33 <iqubic> That is why I hate floating point numbers.
18:12:39 <oo_miguel> nice
18:12:54 <Axman6>  0.1 + 0.2 == (0.3 :: Rational)
18:13:01 <Axman6> > 0.1 + 0.2 == (0.3 :: Rational)
18:13:02 <lambdabot>  True
18:13:16 <Axman6> something weird's going on with my keyboard...
18:13:29 <mmaruseacph2> > round (1/0)
18:13:31 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
18:13:37 <mmaruseacph2> > round (1/0 :: Rational)
18:13:39 <lambdabot>  *Exception: Ratio has zero denominator
18:13:43 <iqubic> Axman6: Rational is basically the same as storing the thing as a fraction, right?
18:14:05 <iqubic> > (0.1 :: Rational)
18:14:06 <lambdabot>  1 % 10
18:14:08 <Axman6> yes
18:14:38 <iqubic> So why does that work? Is that explictly calling from intergral behind the scenes or what?
18:14:57 <iqubic> *fromIntegral
18:15:15 <Axman6> fractional literals use fromRational
18:15:26 <iqubic> > (0.3333333333333333333333333333333333333333 :: Rational)
18:15:28 <lambdabot>  3333333333333333333333333333333333333333 % 100000000000000000000000000000000...
18:15:31 <Axman6> so "0.123" begins its life at 123 % 1000
18:16:04 <iqubic> Is there a way to know how exactly Haskell will convert things like that?
18:16:22 <Axman6> yes, read the language report
18:16:25 <Axman6> @where report
18:16:25 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
18:16:37 <iqubic> I'm sure there are other cases, like what happens with overloadedStrings.
18:17:09 <Axman6> > pi :: Rational
18:17:11 <lambdabot>  error:
18:17:11 <lambdabot>      • No instance for (Floating (Ratio Integer))
18:17:11 <lambdabot>          arising from a use of ‘pi’
18:17:13 <Axman6> :(
18:17:19 <Axman6> > toRational pi
18:17:21 <lambdabot>  884279719003555 % 281474976710656
18:17:30 <iqubic> What the heck is that?
18:17:34 <mniip> pi
18:17:53 <Axman6> approximately
18:17:57 <mniip> that's the best rational approximation a Double can do
18:18:10 <iqubic> > 884279719003555 `div` 281474976710656
18:18:12 <lambdabot>  3
18:18:16 <oo_miguel> lol
18:18:20 <Axman6> > pi :: CReal
18:18:21 <lambdabot>  3.1415926535897932384626433832795028841972
18:18:26 <iqubic> That's not very acccurate.
18:18:32 <Axman6> > toRational (pi :: CReal)
18:18:34 <lambdabot>  *Exception: CReal.toRational
18:18:37 <Axman6> :(
18:18:55 <iqubic> > 884279719003555 \ 281474976710656
18:18:57 <lambdabot>  <hint>:1:17: error: parse error on input ‘\’
18:19:09 <iqubic> > 884279719003555 / 281474976710656
18:19:10 <lambdabot>  3.141592653589793
18:19:15 <iqubic> That's better.
18:19:32 <iqubic> It right up to the third 5
18:19:43 <Axman6> > 3.1415926535897932384626433832795028841972 :: Rational
18:19:45 <lambdabot>  7853981633974483096156608458198757210493 % 250000000000000000000000000000000...
18:20:36 <iqubic> Clearly rounding errors are the best. LOL
18:21:36 <Axman6> > showCReal 100 pi
18:21:37 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
18:21:48 <Axman6> > 3.1415926535897932384626433832795028841971693993751058209749445923078164062 :: Rational
18:21:50 <lambdabot>  15707963267948966192313216916397514420985846996875529104874722961539082031 %...
18:23:10 <Axman6> we have several options for accurate arithmetic, but there are performance considerations too
18:23:19 <Axman6> > pi ^ 20 :: Double
18:23:21 <lambdabot>  8.769956796082695e9
18:23:23 <Axman6> > pi ^ 20 :: CReal
18:23:25 <lambdabot>  8769956796.0826994747522555937038970660641144471954
18:27:41 <iqubic> Those are mostly the same thing.
18:28:05 <iqubic> Everything except for the last digit is the same.
18:34:24 <erisco> 3 is mostly the same thing by the same standard :P
18:35:47 <Axman6> in some spaces pi is 3
18:36:09 <erisco> in same bases pi is 1
18:44:05 * Axman6 for anyone interested in when pi is not pi, see https://www.youtube.com/watch?v=ineO1tIyPfM
18:46:15 * hackage hashmap 1.3.3 - Persistent containers Map and Set based on hashing.  https://hackage.haskell.org/package/hashmap-1.3.3 (ryanglscott)
18:55:13 <beauby> Axman6: I was hoping they would talk about how "the circumference of the circle" is poorly defined, and hence pi = circumference / diameter is shady
18:56:48 <c_wraith> eh? what's poorly defined about it?
18:57:53 <beauby> c_wraith: What's your definition of the circumference of a circle?
19:00:17 <c_wraith> the length of a curve consisting of all points in R^2 at distance r from from some point. distinguish some point on the curve to start and stop measurement.
19:01:07 <redrapscallion> whats with the weird "functionName (x:xs) = ........." notation? i can't find anything about this colon operation on hoogle
19:01:27 <Axman6> that's the list cons constructor
19:01:34 <Axman6> > 1:2:3:[]
19:01:35 <lambdabot>  [1,2,3]
19:01:41 <c_wraith> redrapscallion, it's a pattern match one on of the list constructors.
19:01:55 <Axman6> > let f (x:xs) = (x,xs) in f [1,2,3]
19:01:56 <lambdabot>  (1,[2,3])
19:02:36 <beauby> c_wraith: Right, my point is the definition of pi (circumference / diameter) we learn as kids, relies on a somewhat complex notion of curve length that most people never actually get to learn because (at least in France) it's not taught in highschool
19:03:02 <c_wraith> beauby, that's not ambiguous, it's just annoying to formalize.
19:04:26 <beauby> c_wraith: Agreed - I didn't express myself properly above. When I said "poorly defined", I meant that it relied on concepts that lots of people have never got a definition of
19:05:39 <redrapscallion> c_wraith: i'm not sure i understand how that notation is doing pattern matching.
19:05:48 <redrapscallion> wouldn't a list constructor require the :[] bit at the end?
19:06:08 <Axman6> no, it's matching on the head and the rest o fhte list
19:06:30 <beauby> redrapscallion: lists basically have two constructors, one for the empty list ([]), and one for combining an element with a list (:)
19:06:31 <Axman6> > 1:(2:(3:[]))
19:06:32 <lambdabot>  [1,2,3]
19:07:50 <Axman6> the syntax using [ and ] (ie, [1,2,3]) is syntax sugar for explicitly writing out the constructors (ie, 1:2:3:[])
19:07:53 <Axman6> @src []
19:07:53 <lambdabot> data [] a = [] | a : [a]
19:08:47 <Axman6> "A list of a is either empty (called '[]') OR the cons constructor (called ':') with two arguments: a value of type a and a list of a"
19:09:17 * hackage tickle 0.0.8 - A port of @Data.Binary@  https://hackage.haskell.org/package/tickle-0.0.8 (qfpl)
19:09:19 <c_wraith> beauby, admittedly, I'd probably try to formalize length of a curve as a path integral in a constant field, and that would only introduce more confusion...
19:09:23 <Axman6> this is exactly equivalent to data List a = Nil | Cons a (List a) but uses infix constructor names
19:10:26 <Axman6> using that definition, you would write f (Cons x xs) instead of f (x:xs), but these are exactly the same
19:11:35 <c_wraith> beauby, not the least of which is "prove (cos t, sin t) for 0 <= t < 2pi is actually a circle."
19:12:26 <redrapscallion> Axman6: so the colon operator is an infix by default?
19:13:06 <Axman6> ':' is the name of one of the list constructors, the other is called []
19:13:45 <Axman6> infix c0onstructor names must start with :, and because lists are special they get the consttructos whose name is just :
19:14:01 <glguy> operator symbols are used infix by default, of which : is one
19:15:53 <mandiblegrip> git s
19:16:08 <halogenandtoast> unknown command git
19:33:54 <dfeuer> ezyang: ping
19:34:44 <dfeuer> ezyang: you seem to have CI running for two versions of the same Cabal PR. https://travis-ci.org/haskell/cabal/pull_requests  If you don't speak up quick, I'll cancel the first one.
19:36:52 <ezyang> pong
19:36:57 <ezyang> kill it with fire!
19:37:06 <Axman6> pew pew!
19:38:05 <dfeuer> Thanks, ezyang.
19:39:52 <dfeuer> ezyang: BTW, do you know how to tell Travis to skip CI for a particular PR? Is there a way?
19:40:10 <ezyang> [ci skip]
19:40:21 <ezyang> in the commit msg
19:40:24 <dfeuer> Thanks.
19:42:02 <Zemyla> How do I set cabal to use a different temp folder temporarily? I have, right now, a USB 3.0 flash drive that I'd like it to use for all the temporary files it downloads and compiles.
20:11:25 <beauby> "a monad is a monoid object in a category of endofunctors [...] If that confuses you, it might be helpful to see a Monad as a lax functor from a terminal bicategory."
20:12:52 <johnw> beauby: that's cool, I hadn't thought of it that way yet
20:13:54 <johnw> but why lax?
20:17:09 <beauby> johnw: No idea (this was an extract from https://wiki.haskell.org/What_a_Monad_is_not)
20:18:28 <johnw> Ah: https://math.stackexchange.com/questions/1557723/why-are-lax-functors-from-the-terminal-2-category-the-same-as-monads
20:18:49 <johnw> thanks!
20:37:49 <redrapscallion> so i was looking through some code, and i realized i don't actually know how filter works
20:37:58 <redrapscallion> why does this snippet work? http://lpaste.net/8504288163819159552
20:38:24 <redrapscallion> filter's type is filter :: (a -> Bool) -> [a] -> [a], so that means its first parameter has to be a function with only one argument, no?
20:38:25 <kadoban> redrapscallion: Why wouldn't it?
20:38:42 <redrapscallion> elem has two arguments, so wouldn't that mean haskell would throw a type error?
20:38:47 <kadoban> :t (`elem` "aeiou")
20:38:48 <lambdabot> Char -> Bool
20:39:00 <kadoban> It's a section, it's the same as like ....
20:39:12 <kadoban> :t flip elem "aeiou"
20:39:13 <lambdabot> Char -> Bool
20:39:53 <kadoban> So elem takes two arguments, but then one is being applied. So it needs one more. Which fits what filter wants
20:40:09 <infinisil> `(`elem` "aeiou")` is the same as `\x -> x `elem` "aeiou"` which is the same as `\x -> elem x "aeiou"`
20:40:13 <kadoban> This is the same syntax you see in like ...
20:40:18 <kadoban> > (+ 1) 5
20:40:19 <lambdabot>  6
20:40:30 <kadoban> > map (+1) [1..3]
20:40:32 <lambdabot>  [2,3,4]
20:48:45 * hackage tickle 0.0.9 - A port of @Data.Binary@  https://hackage.haskell.org/package/tickle-0.0.9 (qfpl)
22:07:43 <Disavowed> Evening all. What's my best option for getting syntax highlighting and/or coloured output in a REPL? I'm using Stack if that makes any difference
22:09:05 <dminuoso> Disavowed: I dont know about colored output, but using REPL can be as simple as having a shell open in your stack directory and using :reload
22:09:45 <dminuoso> Disavowed: ghc-mod integration that seems to exist for any of the major editors gets you quite far already
22:09:47 <Disavowed> dminuoso: I've learned that one! I've even got it down as short as :r, which is a breeze!
22:10:25 <Disavowed> That's what I've been doing pretty much. tmux split with vim and ghci. First real day of Haskell yesterday and it was exhilarating.
22:10:28 <dminuoso> Disavowed: with vim you can use slime to kind of "fake" the integration
22:10:37 <Disavowed> Oh that sounds good. Do you recommend it?
22:10:43 <dminuoso> Disavowed: emacs if thats your thing has ghci integration
22:10:50 <Disavowed> I want to like it :(
22:10:54 <dminuoso> Disavowed: I recommend you try it and decide for yourself.
22:11:01 <Disavowed> I will. Thank you for this
22:11:03 <dminuoso> I dont presume to make editor recommandations.
22:11:18 <Disavowed> I installed Spacemacs a couple of days ago. It'll be a slow process :P
22:12:28 <dminuoso> Disavowed: https://wiki.haskell.org/IDEs
22:12:46 <dminuoso> Disavowed: Is a pretty good overview for the notable editors that offer good integration of various things.
22:13:07 <Disavowed> dminuoso: You're a saint; thank you.
22:13:12 <olligobber> I used "monad" in a word game and am now realising I have no idea what it means :'(
22:14:06 <Disavowed> olligobber: Aiui, they're just monoids in the category of endofunctors
22:14:52 <olligobber> three more words I don't know \o/
22:15:31 <Disavowed> olligobber: I'm only playing mate, I don't understand them yet either.
22:25:43 <johnw> they're part of a very common algebraic pattern, but at a level of abstraction that makes them nearly unrecognizable until you've worked with them for a while
22:47:45 * hackage pandoc-citeproc 0.12.2.4 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.12.2.4 (JohnMacFarlane)
22:54:00 <dmwit> olligobber: Monad, monad... that's a philosophy thing, right? Like a fancy word for god or something. ;-)
22:55:14 <olligobber> dmwit, I guess
22:55:49 <vaibhavsagar> someone mentioned recently that pattern matching in Haskell is implemented in terms of a FSM
22:56:01 <vaibhavsagar> is there somewhere I can read more about this?
22:58:22 <dminuoso> olligobber: A monad is just a monoid in the monoidal category of endofunctors! Im dying to play scrabble with some folks :D
22:58:48 <johnw> dmwit is referring to a much older form of the word "monad" that is unrelated
22:59:00 <dmwit> vaibhavsagar: I am not so certain. That doesn't sound right.
22:59:24 <dmwit> FSMs are much too exciting. They can do loops and stuff. No need for all that complication with pattern matching.
22:59:39 <dminuoso> vaibhavsagar: FSMs can be used to implement regular expressions though if thats what you meant.
23:00:00 <dminuoso> (Which I guess is kind of pattern matching, so it sounds a bit similar)
23:00:30 <vaibhavsagar> no, this was specifically in the context of pattern matching in Haskell
23:01:38 <dminuoso> (Or NFAs rather)
23:01:52 <dminuoso> Mmm
23:21:38 <johnw> surgeon's law: at least 10% of you really is crap
23:28:46 * hackage modern-uri 0.2.0.0 - Modern library for working with URIs  https://hackage.haskell.org/package/modern-uri-0.2.0.0 (mrkkrp)
23:29:39 <johnw> sorry, wrong channel!
23:29:49 <johnw> we were discussing sturgeon's law in #emacs :)
23:30:44 <MarcelineVQ> that's the one about the fish
23:39:16 * hackage mmark 0.0.4.3 - Strict markdown processor for writers  https://hackage.haskell.org/package/mmark-0.0.4.3 (mrkkrp)
23:42:46 <Marisa_> Hi, a very trivial question.
23:43:10 <dminuoso> johnw: Is that 10% of mass or volume?
23:43:34 <Marisa_> I have threepenny setup and running, and I have a event of type mouseStroke :: MonadIO m => m (Event [(Int, Int)])
23:44:01 <Marisa_> but at a do notation I have mouseStroke' <- mouseStroke
23:44:21 <Marisa_> Are there any better name for those two mouseStroke?
23:44:44 <EvanR> the first one is really, newMouseStroke or createMouseStroke ?
23:44:49 <Axman6> well, that depends on what they represent
23:45:01 <Axman6> or getMouseStroke
23:45:06 <EvanR> setupMouseStrokeEvent
23:45:08 <EvanR> or something
23:45:26 <Marisa_> getMouseStroke sound nice... I think it isnt setting up new mouseStroke everytime, but just getting it
23:45:38 <EvanR> nevermind me i dont know threepenny
23:45:39 <Marisa_> thx, back to coding :)
23:46:08 <Marisa_> Me neither, just know a bit about the API..
23:48:45 * hackage extensible-effects 2.4.0.0 - An Alternative to Monad Transformers  https://hackage.haskell.org/package/extensible-effects-2.4.0.0 (shergill)
23:57:29 <Marisa_> wait, wat
23:57:41 <Marisa_> why does onEvent return UI (UI ()) when UI is a monad
23:58:58 <Axman6> it probably needs to create the UI () for you to call repeatedly based on some current environment or arguments
23:59:10 <Axman6> what's the full type of onEvent?
