00:06:09 <dminuoso> Hi. Im starting out with some monads and IO. It feels a bit awkward to use, but am I generally on the right track to monad transformers? https://gist.github.com/dminuoso/e12441258e6e57fa98563d9c9c0a5f82
00:08:29 <c_wraith> dminuoso: nothing to do with monads directly, but the lensy stuff can be made a bit more direct with views https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Getter.html#v:views
00:09:09 <amalloy> dminuoso: looks reasonable to me as a non-expert. fwiw you could simplify getPasswordFor by ending it with: withEcho False getLine <* putChar '\n'
00:10:34 <dminuoso> amalloy: Ah right.
00:10:46 <amalloy> i suppose it would also simplify getLdap to replace the last four lines with: liftIO $ do {ldap <- ...; password <- ...; ldapSimpleBind ...; return ldap}
00:11:06 <amalloy> not any shorter, but you don't have to be so repetitive about what parts are doing io
00:11:20 <c_wraith> yeah, I was about to mention that - 3 lines of liftIO in a row typically tells me to factor that out
00:11:25 <dminuoso> amalloy: Ahh! That was one of the things that have been bothering me. :)
00:11:31 <dminuoso> Thanks, I just didnt know how to ask that question.
00:13:15 <amalloy> incidentally withEcho looks like it would be a bit of a problem if run concurrently from multiple threads. i don't know if that matters to you, or have an easy fix to suggest
00:14:07 <dminuoso> amalloy: That's a non issue for now. I just started getting dirty with IO, haven't read anything about concurrency mechanisms in Haskell yet.
00:16:40 <Unhammer> [exa],  you may be interested in https://github.com/chrisdone/structured-haskell-mode
00:18:18 <Unhammer> (I use evil, so never really managed to get into shm, though I really loved using paredit in lisp)
00:19:50 <dminuoso> c_wraith: Okay that's tough. Not sure how `views` would help. What would `f` be?
00:20:14 <[exa]> Unhammer: whew that looks cool
00:21:36 <ertes-w> helo
00:22:10 <c_wraith> dminuoso, oh, I think I just meant view
00:22:36 <c_wraith> yeah, I did.
00:22:46 <dminuoso> c_wraith: ^. is view, not sure what you're getting at then
00:23:04 <ktonga> hi people, i was starting with data61's fp course but when i'm following the steps described here https://github.com/data61/fp-course#running-the-tests i get tons of errors when running `cabal build`
00:23:48 <ktonga> i pasted just one example from the errors here https://paste.ubuntu.com/26403087/ since they're too many and all similar
00:24:23 <ktonga> the las line of output from cabal build is `gcc failed in phase Linker
00:24:41 <c_wraith> dminuoso, but it is binary, you can use view unary, as such: bind <- view bindDN
00:24:48 <ertes-w> dminuoso: other than what was already said you're on the right track…  you're using effect classes (MonadReader) and instantiation (line 32) correctly
00:24:50 <ktonga> it is a fresh linux install so it smells to some package missing
00:24:59 <ertes-w> dminuoso: implement abstractly, use concretely
00:25:05 <ktonga> but gooling the msg error i can't find anything useful
00:26:05 <ertes-w> ktonga: how did you install GHC/cabal-install?
00:27:17 <ktonga> downloaded the tar and make install (for ghc)
00:27:59 <ktonga> cabal-install downloaded the bin for linux and put it in ~/bin which is in my PATH
00:28:40 <ktonga> i only found  a tar for debian 9, im running kubuntu so should be similar
00:29:08 <ertes-w> ktonga: the 'cabal install cabal-install' step in that guide is dubious…  which version of cabal-install do you have?  (cabal --version)
00:29:30 <ertes-w> ktonga: if you didn't do anything manual in ~/.ghc and ~/.cabal, delete those directories
00:29:31 <ktonga> yup, i also thought that
00:29:55 <ertes-w> ktonga: (also for completeness, which GHC version? (ghc --version))
00:30:14 <ktonga> 8.0.1
00:30:28 <[exa]> Unhammer: I suppose there's nothing like that for vim?
00:30:58 <ertes-w> ktonga: ok, and which cabal-install version?  (cabal --version)
00:31:26 <Unhammer> Well, I apparantly managed to integrate it a bit with evil-mode https://github.com/chrisdone/structured-haskell-mode/issues/81#issuecomment-142914978 before I stopped using it
00:31:45 <Unhammer> I think my main issue was more that I didn't have time to retrain my muscle memory ;)
00:32:00 <ktonga> 2.0.0.1 the recommended in the web page
00:32:14 <ktonga> and cabal lib 2.0.1.1
00:32:25 <ktonga> can that be the problem?
00:32:29 <ertes-w> ktonga: ok, did you change anything manually in ~/.cabal or ~/.ghc?
00:32:42 <ktonga> nope, gone as you asked already
00:32:52 <dminuoso> ertes-w: Im curious, what do you mean by that last sentence?
00:34:08 <ertes-w> ktonga: then in the project dir run this:  cabal update && cabal sandbox init && cabal configure --enable-tests && cabal install --enable-tests --only-dependencies && cabal build
00:34:17 <ertes-w> ktonga: after that you should be able to use the 'cabal test' command
00:34:26 <dminuoso> ertes-w: (And by last sentence I meant when you said "implement abstractly, use concretely")
00:34:38 <ertes-w> dminuoso: are you somewhat familiar with lenses now?
00:34:48 <dminuoso> ertes-w: Somewhat, yes.
00:35:18 <ertes-w> @let fstL f ~(x', y) = (\x -> (x, y)) <$> f x'
00:35:21 <lambdabot>  Defined.
00:35:25 <ertes-w> :t fstL
00:35:29 <lambdabot> Functor f => (t -> f a) -> (t, b) -> f (a, b)
00:35:54 <ertes-w> dminuoso: this is a lens for the left element of a tuple…  you can see that it abstracts over 'f'
00:36:30 <ertes-w> dminuoso: then functions like (^.)/view and (%~)/over use specific 'f' to implement their functionality
00:37:24 <dminuoso> Right, which is kind of lens basics by obtaining a kind of Getter by picking Const, and a kind of Setter by picking Identity
00:37:29 <ertes-w> dminuoso: effect classes in monad transformers are used in a similar way:  you don't write a (ReaderT E IO A), you write a ((MonadReader E m, MonadIO m) => m A)
00:37:43 <ertes-w> dminuoso: and then you instantiate it at (m = ReaderT E IO A)
00:38:10 <ertes-w> at the use site (run*)
00:39:01 <ktonga> ertes-w: sandbox init failed
00:39:12 <ertes-w> ktonga: what's the error message?
00:39:38 <ktonga> pasting...
00:39:41 <dminuoso> ertes-w: Ahh I see what you are getting at. So this gives me the freedom to use getLdap with something else that has both IO and reader capabilities if I wanted so.
00:39:57 <dminuoso> ertes-w: Giving me the freedom to pick different behaviors, just like in lenses.
00:40:36 <ktonga> https://paste.ubuntu.com/26403149/
00:41:41 <dminuoso> ertes-w: Ill admit, I was about to use ReaderT until I saw some examples involving `MonadReader` and `MonadIO`, which looked interesting.
00:47:43 <ertes-w> dminuoso: there is another way to use monad transformers, which can even be mixed with the way you use them: "inline"
00:48:04 <ertes-w> dminuoso: for example rather than writing a stateful function i sometimes just fire up a StateT
00:48:20 <ertes-w> f = evalStateT go where go = …
00:48:47 <ertes-w> or embed a runMaybeT somewhere in the middle of a do-block
00:50:05 <dminuoso> ertes-w: Interesting, that could be something I was looking for. Need to play with that idea a bit.
00:55:06 * ertes-w . o ('cabal update' really needs to display a progress bar)
00:57:17 <tdammers> one of the few situation where I sometimes use flip
00:57:45 <tdammers> flip execStateT $ do ...
00:58:05 <ertes-w> ktonga: i'm getting the same error, and i can't explain why
00:58:36 <ertes-w> the cabal file looks fine to me
00:59:12 <ertes-w> ktonga: any reason you're not using tonymorris' original repo?
00:59:28 <ertes-w> ktonga: (he's here BTW, as dibblego)
00:59:38 <ktonga> ertes-w: yeah i know
01:00:01 <ktonga> i data61 is formely nicta
01:00:18 <ktonga> so same course, old one got deprecated
01:00:38 <ertes-w> ah
01:01:05 <ktonga> i thought is might be related to my super fresh env, but if you are getting same error...
01:03:21 <ertes-w> ktonga: ok, now it worked
01:03:56 <ertes-w> ktonga: try this:  cabal update && cabal install --enable-tests --only-dependencies && cabal configure --enable-tests && cabal build
01:04:08 <ertes-w> ktonga: the sandbox makes it fresh
01:04:57 <ertes-w> ktonga: looks like in sandboxes you have to install the dependencies first for some reason…  after that it worked
01:05:14 <ertes-w> but i can't explain why…  i've never seen that ordering dependency
01:05:17 <ktonga> those are the steps from the guide after removing install cabal-install right?
01:05:36 <ertes-w> ktonga: almost…  you're doing all of this in a sandbox
01:05:44 <ktonga> if i already run that step should i revert it?
01:05:52 <ertes-w> ktonga: no
01:06:21 <ktonga> so i have to run sandbox step alone first?
01:06:34 <ertes-w> ktonga: no, just run the command i gave you
01:07:32 <ertes-w> no need to revert…  if you ever want to start fresh, delete '.cabal-sandbox', 'cabal.sandbox.config' and 'dist', then run 'cabal sandbox init' again
01:09:09 <ertes-w> ktonga: (also sandboxes are on their way out…  we have a better build system called 'new-build' now, but your version of cabal-install is too old for that)
01:09:56 <ktonga> i can install any version of cabal i dont think i have a restriction to use that one
01:10:13 <ktonga> it was the one that appeared when in googled :)
01:10:37 <ktonga> can i use a newer one with that version of ghc?
01:10:38 <ertes-w> ktonga: wait, i was talking non-sense…  actually you should have new-build =)
01:11:13 <ertes-w> ktonga: i've never used it myself, so allow me to do a quick experiment
01:11:19 <ktonga> so it is still failing for me
01:11:33 <ktonga> shall i try this new thing?
01:12:34 <merijn> ktonga: Yes, you can use newer versions of cabal with old GHC
01:12:49 <ertes-w> ktonga: ok, let's switch to new-build…  it's working here
01:12:52 <merijn> Well, depending on how old :p
01:13:09 <ktonga> 8.0.1 not that old
01:13:19 <ertes-w> ktonga: delete ~/.cabal ~/.ghc PRJ/.cabal-sandbox PRJ/cabal.sandbox.config PRJ/dist
01:13:31 <merijn> I was more thinking "I'm not sure if it works with <7.4" kinds of old ;)
01:14:02 <ertes-w> ktonga: then do this in the project dir:  cabal update && cabal new-configure --enable-tests && cabal new-build
01:14:03 <merijn> ktonga, ertes-w: Relevant: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
01:14:41 <ertes-w> ktonga: after that you can run:  cabal new-test
01:15:01 <merijn> ertes-w: You don't need to new-configure with --enable-tests afaik
01:15:18 <ertes-w> merijn: tests are enabled by default?
01:15:47 <merijn> ertes-w: I thought they just got build on-demand if you run "new-test", but now I'm not sure anymore
01:15:54 <merijn> I could be wrong
01:15:57 <ertes-w> let me check
01:16:36 <ktonga> it's running
01:16:37 <ertes-w> neat, you're right
01:16:49 <ertes-w> ktonga: in other words all you really need to run is 'cabal new-test'
01:16:57 <merijn> ertes-w: \o/
01:17:01 <ertes-w> the new build system takes care of everything else =)
01:17:25 <ktonga> nope same error
01:17:45 <merijn> What was the error? (I missed it)
01:17:53 <ertes-w> merijn: https://paste.ubuntu.com/26403149/
01:17:55 <ktonga> it must be something with my bloody env
01:18:05 <ertes-w> ktonga: i doubt it
01:18:21 <merijn> Hold on
01:18:23 <ktonga> same error linker phase in gcc fails
01:18:31 <ktonga> with Kms of errors
01:18:31 <ertes-w> ktonga: oh, the linker error
01:18:38 <ertes-w> merijn: scratch that paste
01:18:39 <merijn> "rejecting: course-0.1.4:!test (constraint from config file, command line flag," <- that sounds like someone has a manual flag that should be automatic
01:18:42 <merijn> ah
01:18:46 <merijn> What's the linker error?
01:18:59 <ertes-w> ktonga: please paste the linker error you got with new-build
01:20:12 <ktonga> https://paste.ubuntu.com/26403289/
01:20:15 <ktonga> last bit
01:20:25 <ktonga> before that a lot of the same
01:21:02 <merijn> Out of curiosity, which OS?
01:21:05 <ertes-w> ktonga: did you install a binary distribution of GHC?
01:21:18 <ktonga> linux, Kubuntu 17.10
01:21:51 <merijn> That's a weird ass error for "not arch" :p
01:21:58 <merijn> ktonga: How'd you install GHC?
01:22:03 <ertes-w> haha
01:22:46 <ktonga> pasting the seteps..
01:22:57 <Hijiri> I'm looking at https://hackage.haskell.org/package/OpenGL-3.0.2.0/docs/Graphics-Rendering-OpenGL-GL-Shaders-Uniform.html#v:uniformv, which takes a Ptr a. But this looks like I can't pass an array of GLmatrix since it has no Storable instance
01:23:00 <Hijiri> Is that accurate?
01:24:13 <merijn> Hijiri: Why does it need a Storable instance?
01:24:26 <Hijiri> So I can put it in a Ptr a
01:24:30 <Hijiri> Or is there another way?
01:24:42 <Hijiri> Ptr GLmatrix I mean
01:24:52 <royal_screwup21> suppose I have 2 lists, say [1,2,3] and [4,5,6]. I want to throw them into another list to get: [ [1,2,3], [4,5,6]]. What's the easiest way to accomplish this?
01:25:07 <merijn> Hijiri: You probably "withMatrix"?
01:25:14 <ktonga> https://paste.ubuntu.com/26403326/
01:25:21 <ertes-w> Hijiri: if you have an array of those, then yes, you need a Storable instance, but i think the best answer here is: "use the 'gl' library instead"
01:25:23 <merijn> Hijiri: https://hackage.haskell.org/package/OpenGL-3.0.2.0/docs/Graphics-Rendering-OpenGL-GL-CoordTrans.html#v:withMatrix
01:25:36 <Hijiri> merijn: it looks like withMatrix gives a ptr to the elements of the matrix
01:25:47 <Hijiri> not to an array of multiple matrices
01:25:51 <Hijiri> ertes-w: Ok, I'll check it out
01:25:57 <merijn> Hijiri: But yes, I agree with ertes-w, afaik "gl" is now the best/preferred low level OpenGL binding
01:26:19 <ktonga> ertes-w merijn: ^^^ ghc install steps
01:26:35 <merijn> ktonga: ok, that looks decent, I'm wondering if it's just 8.0.1 that's broken, I recall it had quite some bugs
01:26:50 <merijn> ktonga: Have you tried using 8.0.2 or 8.2?
01:26:56 <Hijiri> the OpenGL package is / was slightly more than lowest level, is there something like that for gl?
01:27:05 <ktonga> it is kinda the default ghc at my new job
01:27:06 <ertes-w> ktonga: you can safely pick 8.2.2
01:27:11 <ktonga> that's why im installing it
01:27:18 <ertes-w> ktonga: ah, then stick with it
01:27:43 <merijn> ktonga: ah, you might wanna tell them that 8.0.1 has quite a number of bugs fixed in 8.0.2 :p
01:27:43 <ktonga> those steps are in the new starter guide
01:27:59 <ertes-w> ktonga: yeah, at least pick the latest 8.0
01:28:11 <ktonga> ok, will tell them
01:28:24 <merijn> ktonga: 8.0.2 should be pretty much identical to 8.0.1, but less bugs ;)
01:28:44 <ktonga> tomorrow, now i'm at home hoping to have my env set up for tomorrow :(
01:28:48 <merijn> ertes-w, ktonga: I'm wondering whether maybe there's something weird with the gcc setup that's breaking linking?
01:29:07 <ertes-w> merijn: i'm wondering whether GHC really wants to be installed system-wide
01:29:16 <ertes-w> it shouldn't, but i don't know
01:29:27 <merijn> ertes-w: I have installed GHC like he did for over 4 years now, no issues
01:29:40 <ktonga> that's how everybody has it installed
01:29:42 <merijn> ertes-w: GHC and cabal work as perfect as you can without systemwide install
01:29:47 <ktonga> mac and linux users
01:29:56 <ertes-w> ok
01:30:08 <merijn> ertes-w: like, if you change the path he's using it's literally how the GHC I'm using right now was installed on linux and OSX for me :p
01:30:23 <ktonga> and they have multiple and a little bit of zsh script to switch beetwen versions when needed
01:30:30 <ktonga> no system installation
01:30:46 <ertes-w> Hijiri: there is nothing on the exact level of the OpenGL package (as far as i'm aware), but there is stuff that is higher level like 'GPipe' and 'luminance'
01:31:18 <ertes-w> Hijiri: those are higher-level than OpenGL, but both are designed such that you can still fall back to lower levels for stuff they don't support
01:31:30 <merijn> ktonga, ertes-w: Having another look at the linker error it looks like the RTS in the bindist was compiled wrong
01:31:58 <merijn> It's implying the RTS was compiled with -fPIC
01:32:24 <merijn> That might either be an issue with that specific tarball, or with 8.0.1
01:32:24 <ertes-w> then i'd upgrade to the latest 8.0 first
01:32:40 <ertes-w> that might just resolve the issue
01:32:46 <ktonga> ok will try with newer ghc
01:33:12 <ktonga> but it's weird i'm the only one having this problem :(
01:33:36 <Hijiri> ertes-w: I've used GPipe before, but I'm working on an assignment and wasn't sure if it would be disallowed for being too high level
01:33:55 <Hijiri> though rendering isn't the focus of this course so I'll probably ask
01:34:01 <ertes-w> Hijiri: probably, because GPipe even abstracts away GLSL
01:34:34 <ertes-w> Hijiri: luminance is more conservative, just providing a better API for buffers, textures, framebuffers, etc.
01:34:38 <ktonga> i guess it's ok to use the debian9 tar for ubuntu
01:35:23 <ertes-w> Hijiri: (better in that you don't have to work with pointers, but storable vectors, and that there are separate types for GL objects that carry type information)
01:35:38 <Hijiri> ertes-w: I might go for luminance then
01:36:18 <merijn> Hijiri: Out of curiosity: What are you using it for?
01:36:29 <Hijiri> a computer animation course
01:39:16 <royal_screwup21> I'm trying to group same elements into a sublist. Here's what I tried: https://thepasteb.in/p/mwh1lOBqJ9Ju5 it compiles but when I try a test case the compiler throws an error: https://thepasteb.in/p/NxhV34Dk0q9SN how do I fix this?
01:39:45 <Hijiri> Can I use luminance with GL support only up to 4.2?
01:39:56 <dminuoso> Why is Haskell choking on this seemingly harmless piece of code? https://gist.github.com/dminuoso/4afaba2bd4786a68cb1297a615a0a965
01:40:10 <ertes-w> royal_screwup21: whenever you implement a function write its type signature first
01:40:11 <royal_screwup21> ah never mind
01:40:16 <dminuoso> I mean I can fix this with an explicit type annotation.. but why do I have to?
01:40:17 <Hijiri> ah, github talks about that
01:40:32 <Hijiri> I can choose between a 3.3 and 4.5 backend
01:40:48 <merijn> dminuoso: It's not choking, it's telling you your code is ambiguous
01:41:14 <dminuoso> merijn: I dont understand how it is ambiguous.
01:41:21 <dminuoso> > let f = fmap snd . find ((== "uid") . fst) in undefined
01:41:24 <lambdabot>  *Exception: Prelude.undefined
01:41:55 <merijn> dminuoso: Judging by the code "find" works on any Foldable
01:41:57 <ertes-w> Hijiri: that's what luminance itself uses…  of course you can still just access the 'gl' API directly and use whatever you need, as long as you have the profile selected for it
01:42:16 <merijn> dminuoso: but since you never use it anywhere, GHC can't decide which Foldable it should be
01:42:30 <ertes-w> Hijiri: (profile selection is done by your toolkit, e.g. sdl2 or GLFW)
01:42:34 <merijn> dminuoso: It's a case of MMR outside of the top-level
01:43:22 <merijn> dminuoso: MMR requires any value with no arguments on the left-hand side AND no type signature be monomorphised. But since you don't use it, it can't figure out what it should be monomorphised to
01:43:46 <merijn> dminuoso: Possible solutions: 1) eta expand to add an argument on LHS, 2) add a type signature, 3) actually use it
01:43:52 <dminuoso> merijn: Ahh! So finally the day comes when MMR comes knocking on my door. RWH did tell me this day would come. :-)
01:44:12 <dminuoso> merijn: Yeah, all three options make perfect sense, thank you.
01:47:33 <ktonga> ertes-w merijn: awesome guys, i installed 8.0.2 and just run cabal new-test and everything worked! (except the tests which i need to fix as part of the exercises :D )
01:47:42 <ktonga> thanks a ton for the help
01:48:49 <royal_screwup21> I'm trying to get a set out of a list elements using folds like so: https://thepasteb.in/p/lOhOEQ0NPzoFB this throws an error: "Not in scope: ‘acc’" -- is there a way to fix this without having to write a function to check if the element is the accumulator?
01:49:12 <ertes-w> ktonga: great!  have fun =)
01:49:19 <ertes-w> ktonga: and good luck with the job =)
01:49:32 <ktonga> thanks!
01:57:53 <amalloy> you need to write a function that takes in acc and x, and produces a new acc. you've written this weird non-thing with a comma in a place where it makes no sense, kinda reminiscent of a list comprehension guard
01:58:32 <amalloy> try writing that function. step :: Eq a => [a] -> a -> [a]
01:59:43 <royal_screwup21> eek yes
01:59:59 <dminuoso> ertes-w: But I must say.. lenses are so much fun. Just discovered Control.Lens.At, incredibly helpful :)
02:00:17 <dminuoso> fmap snd . find ((== "uid") . fst) seemed like a lens thing, so I dug a bit.. :-P
02:00:36 <piyush-kurur> I am curious about the recvBuf function in Network.Socket
02:00:59 <piyush-kurur> Looking at the implementation it looks like a receive of 0 will result in an ioError
02:01:09 <royal_screwup21> amalloy: I tried this: https://thepasteb.in/p/j2hlmWKqLOrIP  it compiles, but  throws an error when I do getset [31,12] https://thepasteb.in/p/JZhpwN3GAKnig
02:01:24 <piyush-kurur> https://hackage.haskell.org/package/network-2.6.3.3/docs/src/Network-Socket.html#recvBuf
02:01:47 <piyush-kurur> but then how can I do something like read till the end of the stream
02:01:59 <amalloy> put type signatures on your functions, and ghc will tell you what you've done wrong
02:02:21 <cocreature> piyush-kurur: that seems like asking for a buffer overflow tbh
02:02:32 <amalloy> ie, put is implemented incorrectly, but is a "correct" implementation of a silly function with a different type than you intended
02:02:37 <ertes-w> dminuoso: the real fun starts when you replace that Functor constraint by Applicative, and then when you replace (->) by a profunctor =)
02:02:57 <geekosaur> piyush-kurur, you don't. Network.Socket is low level, not high level
02:03:15 <cocreature> piyush-kurur: since you need to supply a pointer to the buffer, you can’t read more than you have allocated at that address
02:03:17 <dminuoso> ertes-w: You mean upgrading lenses to traversals?
02:03:28 <piyush-kurur> cocreature: I mean read a fixed amount in the buffer and process it then read the next chunk  etc etc
02:03:36 <piyush-kurur> I would need to know when to stop
02:03:42 <geekosaur> but I'd agree throwing an error is wrong for several reasons, including that nothing forces it to be a stream socket and 0-length UDP packets are valid and may be meaningful in some protocols
02:03:45 <geekosaur> and should not be errors
02:04:03 <dminuoso> ertes-w: profunctors Ive already looked at, the idea seems simple to grasp when I just look at ->, but I think the general idea is more complicated in CT.
02:04:04 <piyush-kurur> The docs says a 0 indicate a end of socket
02:04:14 <piyush-kurur> but if I read till 0 I get an error
02:04:19 <merijn> piyush-kurur: Why are you trying to use recvBuf instead of just "recv"?
02:04:37 <geekosaur> but note that it throws an EOFerror, so there is at least that
02:04:53 <merijn> Or rather, Network.Socket.ByteString.recv
02:04:56 <geekosaur> personally I think it should just return a read length of 0
02:05:01 <piyush-kurur> merijn: just for the heck of it no particular reason
02:05:13 <piyush-kurur> but I am curious of the implementation though
02:05:15 <merijn> piyush-kurur: recvBuf is for people who want to write C in Haskell
02:05:59 <piyush-kurur> merijn: whatever it is, I guess there is a unexpected behaviour in its implementation
02:06:16 <AmeliaSizwe> hi I started doing nicta fp-cource
02:06:19 <AmeliaSizwe> hi I started doing nicta fp-course
02:06:27 <merijn> I'd say "throws EOFError on EOF" is reasonably expected, since it's the same thing file operations do
02:06:51 <AmeliaSizwe> and I have problem running caball repl
02:07:12 <AmeliaSizwe> I run nix-shell inside fp-course dir
02:07:21 <AmeliaSizwe> and then cabal repl
02:07:41 <AmeliaSizwe> it says "cabal: The 'repl' command does not support multiple targets at once"
02:07:42 <piyush-kurur> merijn: which essentially means that recvBuf as a function seems unnecessarily difficult to use
02:07:54 <AmeliaSizwe> the same with emacs/ dante
02:07:58 <piyush-kurur> I mean you have to have a catchError whenever you use it
02:08:04 <merijn> piyush-kurur: Like I said, recvBuf is for people who want to write C in Haskell
02:08:11 <merijn> Also, the network API is shit anyway
02:08:23 <piyush-kurur> merijn: I agree
02:08:31 <merijn> But not shit enough for anyone to bother replacing it
02:08:39 <geekosaur> I keep thinking about it
02:09:11 <merijn> geekosaur: I offered to take over *nix maintenance, but it was met with skepticism and tons of bikeshedding
02:09:14 <geekosaur> problem is, even the current network package has remarkable portability issues on windows. I don't particularly want to have to deal witht hose
02:09:20 <merijn> So I was like "fuck it"
02:09:37 <merijn> geekosaur: Yeah, that was my problem to, I can't commit to maintaining that shit on windows
02:11:29 <geekosaur> AmeliaSizwe, I would probably do 'cabal exec ghci' instead; 'cabal repl' tries to load your project, and ghci can't load multiple 'main' functions / program entry points
02:11:38 <piyush-kurur> merijn: curiously N.S.ByteString.recv does the catch gymnastics because it is using the recvBuf
02:11:49 <piyush-kurur> https://hackage.haskell.org/package/network-2.6.3.3/docs/src/Network-Socket-ByteString.html#recv
02:12:17 <merijn> piyush-kurur: So does the regular "recv", hence why I said you should be using recv instead of recvBuf
02:12:18 <geekosaur> 'cabal exec ghci' will have your project available but won't try to load it all up front
02:12:41 <ertes-w> dminuoso: yeah, a lens is a traversal with a Functor constraint
02:12:45 <piyush-kurur> merijn: I wanted to write a blackhole server which just gobbles up the data from the client
02:13:03 <piyush-kurur> not much point in having the data
02:13:13 <merijn> piyush-kurur: Just run "recvSome" and immediately drop it
02:13:31 <merijn> piyush-kurur: How does recvBuf help? You'd still be writing it somewhere
02:13:53 <piyush-kurur> merijn: I just keep overwriting the buffer
02:14:02 <ertes-w> dminuoso: the general structure of an "optic" is (p a (f b) -> p s (f t))…  a lens is an optic with (p = (->)) and a (Functor f) constraint
02:14:19 <merijn> geekosaur: Some of the network API is actually just broken an no one seems to have noticed. One of the operations always crashes with an error, even during successful use
02:14:21 <ertes-w> dminuoso: a traversal has (p = (->)) and (Applicative f)
02:14:40 <AmeliaSizwe> @geekosaur thanks, it works
02:14:40 <lambdabot> Unknown command, try @list
02:14:50 <geekosaur> merijn, yes. I was at one point a realtively frequent flyer in network's bug tracker :)
02:14:56 <piyush-kurur> wanted to try out a demo tcp flow control using wireshark
02:15:03 <piyush-kurur> so wrote the blackhole server
02:15:10 <geekosaur> then I gave up because it was clear nobody cared and I could see enough issues that I didn't want to try to deal myself
02:15:36 <merijn> oh, seems it might've been fixed by now
02:15:59 <merijn> geekosaur: The maintainers are to busy to actively maintain it, but there's not a lot of support for people taking over
02:16:02 <geekosaur> well, actually I think I only submitted one or two, most of them died during pre-sumbission discussion when I found out nothing was going to be done anyway
02:16:45 <piyush-kurur> geeksaur, merijn you paint a sad picture of the network library
02:16:52 <geekosaur> yes
02:16:58 <geekosaur> it's a sad eorry POS
02:17:03 <geekosaur> *sorry
02:17:31 * piyush-kurur dreads the use of C socket calls
02:17:53 <merijn> piyush-kurur: network works fine if you use it as "Haskell binding for C sockets on unix"
02:18:19 <piyush-kurur> merijn: it works but I wanted to do some funky stuff like accessing the raw sockets etc
02:18:33 <piyush-kurur> seems to be impossible to do as of now
02:19:14 <merijn> What functionality are you lacking?
02:20:15 <piyush-kurur> I mean how does one do something like IP_HDRINCL (for raw sockets that is)
02:20:36 <piyush-kurur> so that you can construct things like ICMP packates
02:20:41 <piyush-kurur> *packets
02:34:58 <Barry_> @ertes-w thanks for the help on monads last friday. We talked yesterday about the solutions and I was able to follow on everything that was said. There was an other guy who helped a lot. His name started with M but I cant find him on the list
02:34:58 <lambdabot> Unknown command, try @list
02:41:32 <ertes-w> Barry_: glad it helped…  the other person was called metahumor
02:42:09 <Barry_> ah yeah
02:42:31 <Barry_> @metahumor thank you too
02:42:31 <lambdabot> Unknown command, try @list
02:43:01 <ertes-w> Barry_: lines starting with "@" are lambdabot commands =)
02:43:26 <Barry_> ertes-w: I see. My bad
02:44:27 <Barry_> Wanted to be back at the same day and thank you both, but had to go to work quickly and wasnt feeling like doing haskell afterwards ^^
02:44:36 <Barry_> so thanks again, have a nice day
02:44:38 <Barry_> bye
02:51:39 <sphinxo> how best can I pad a list with zeros, until it's a certain size
02:52:57 <dminuoso> sphinxo: Is it required? Because left padding requires to go through the entire list before you can get the first element.
02:55:26 <ocramz> hullo!
02:55:49 <dminuoso> sphinxo: But the trivial way would be `replicate (n - length l) 0 ++ l`
02:55:50 <ocramz> what's currently the best story for talking to postgres?
02:56:26 <ocramz> postgresql-simple>
02:56:26 <ocramz> ?
02:56:35 <merijn> ocramz: postgres-simple or selda/opaleye, I suppose, depending on what you want
02:57:08 <ocramz> I'd very much appreciate having a streaming interface, and I see Ollie has written one for postgres-simple
02:57:16 <typetetris> @ :t isJust
02:57:29 <typetetris> @help
02:57:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:00:41 <sphinxo> thanks dminuoso
03:01:01 <ertes-w> sphinxo: \xs -> take n (xs ++ repeat 0)
03:01:14 <ertes-w> > take 10 ([1,2,3] ++ repeat 0)
03:01:17 <lambdabot>  [1,2,3,0,0,0,0,0,0,0]
03:01:49 <sphinxo> ooh that's nice, cheers ertes-w
03:01:52 <dminuoso> Weird, I could have sworn there was a "left" mentioned.. I read it twice..
03:02:48 <dminuoso> ertes-w: Oh man, I have so many things I want to do to this nested structure, and I somehow _know_ that traversals are the right way. :D
03:03:04 <ertes-w> dminuoso: depends on what you want to do
03:03:46 <dminuoso> ertes-w: Right now I have some [Maybe (String, [String])], and I basically want to print each `String` inside that nested Array.
03:04:23 <dminuoso> I mean I could just fmap my way into there, but that doesn't feel right.
03:05:06 * hackage spake2 0.4.1 - Implementation of the SPAKE2 Password-Authenticated Key Exchange algorithm  https://hackage.haskell.org/package/spake2-0.4.1 (jml)
03:05:16 <ertes-w> dminuoso: every traversal is a function of the same shape as 'traverse'
03:05:45 <ertes-w> (traverse . traverse . _2 . traverse) print xs
03:06:35 <ertes-w> :t foldOf_
03:06:37 <lambdabot> error:
03:06:37 <lambdabot>     • Variable not in scope: foldOf_
03:06:37 <lambdabot>     • Perhaps you meant one of these:
03:06:49 <ertes-w> :t traverseOf_
03:06:54 <lambdabot> Functor f => Getting (Traversed r f) s a -> (a -> f r) -> s -> f ()
03:07:02 <ertes-w> dminuoso: ^ this is better though
03:07:14 <ertes-w> traverseOf_ (traverse . traverse . _2 . traverse) print xs
03:07:57 <ertes-w> cross the list (traverse), cross the Maybe (traverse), pick snd (_2), cross the list (traverse)
03:08:13 <ertes-w> and traverseOf_ is to traversals what traverse_/mapM_ is to traversables
03:11:50 <dminuoso> Mmm.
03:13:36 <dminuoso> ertes-w: Honestly Im quite stuck with the types you mentioned earlier. Just looking at say `type Setter s t a b = forall f. Settable f => (a -> f b) -> s -> f t`, `type Getter s a = forall f. (Contravariant f, Functor f) => (a -> f a) -> s -> f s` or `type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t` is somewhat scary.
03:25:36 * hackage magic-wormhole 0.1.0 - Interact with Magic Wormhole  https://hackage.haskell.org/package/magic-wormhole-0.1.0 (jml)
03:32:54 <dminuoso> :t traverse
03:32:57 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
03:34:35 <dminuoso> Ah, this article seems to contain the secrets related to that type http://comonad.com/reader/2012/mirrored-lenses/ =)
03:44:41 <ertes-w> dminuoso: i recommend that you do the exercises again, but this time with context
03:44:56 <ertes-w> dminuoso: you see how 'traverse' traverses the right component of a tuple?
03:45:13 <ertes-w> ("traversing" is really just "mapping with effects")
03:52:48 <mpickering> does anyone actually use haskell-ide-engine with neovim?
03:53:05 <mpickering> Are there some sensible bindings for LanguageServer-neovim for example
04:00:32 <arne> wtf does haskell not have heredoc
04:01:25 <ertes-w> arne: you can implement heredocs using quasiquotes
04:01:31 <ertes-w> should be a one-liner
04:01:44 <arne> still shouldn't this be a main feature?
04:01:58 <ertes-w> arne: that depends on who you ask =)
04:02:09 <arne> what are the options?
04:02:14 <arne> oh.. nevermind
04:02:14 <ertes-w> arne: most people think null should be a main feature
04:02:29 <arne> like.. it is with maybe isn't it?
04:02:33 <tdammers> why would heredoc be built into the language?
04:02:48 <arne> why would strings be built into the language
04:02:51 <arne> you can just write bytes.. duh?
04:02:56 <tdammers> they aren't
04:03:02 <ertes-w> strings are kinda not built-in in haskell =)
04:03:02 <tdammers> not in the core language anyway
04:03:19 <ertes-w> all we have is some syntactic sugar for what translates into library code
04:03:28 <tdammers> string *literals* are, but they are parsed as lists of Char
04:03:38 <arne> yeah point taken
04:03:42 <tdammers> Char however *is* built-in
04:04:15 <ertes-w> arne: anyway, if you're doing something that can benefit from heredocs, you should just define a QQ function
04:04:22 <ertes-w> arne: in fact i'm pretty sure it already exists on hackage
04:04:45 <arne> it does
04:04:50 <arne> found out while googling
04:05:00 <arne> i still think [something|] is not pretty code
04:05:02 <arne> but then again
04:05:07 <arne> no code is pretty with EOF in them
04:05:17 <ertes-w> arne: then rename it
04:05:21 <ertes-w> blah = something
04:05:24 <ertes-w> [blah| … |]
04:06:17 <ertes-w> you can't do anything about the brackets though…  those are built-in
04:11:16 <tdammers> heredocs sit in a spot in the design space that is rarely needed in "good" programming style
04:11:33 <tdammers> long strings are generally data, not code, and thus belong in data files, not code files
04:11:54 <merijn> tdammers: Pfft, I just link all my data files into my binaries :p
04:12:01 <tdammers> either just load the data from a file at runtime, or use something like the file-embed to pull in raw data files at compile time
04:12:13 <tdammers> merijn: sure, but you don't need heredoc for that
04:13:23 <ertes-w> yeah, all you need is some super-easy linker magic and FFI =P
04:14:16 <merijn> ertes-w: I know :)
04:15:33 <merijn> ertes-w: I'm doing the same in C(++) :p
04:16:37 <chocopuff> have a question theoretical in nature, not necessarily haskell specific. Say we wanted to write code for a quantum computer
04:17:08 <chocopuff> could we just have ghc compile quantum code instead?
04:17:31 <chocopuff> since all the mental overhead is the functional paradigm, compiler optimizes and figures out the rest
04:17:50 <chocopuff> maybe there is a problem in my question itself, i'm very new to these concepts
04:17:53 <chocopuff> sorry if its' silly
04:18:02 <merijn> chocopuff: You still have to write a compiler that actually *can* "figure out the rest"
04:18:08 <ertes-w> chocopuff: QCs would need a very different compilation scheme, but it could be done
04:18:43 <chocopuff> I mean, would the compiler be able to take advantage of the quirks of QC?
04:18:53 <merijn> chocopuff: If you program it to
04:19:02 <chocopuff> with haskell / an abstract language as it is right now?
04:19:15 <merijn> chocopuff: Well, you'd first have to figure out how to do it at all
04:19:16 <ertes-w> chocopuff: the quirks are very specific…  i don't think the compiler could really exploit them automatically
04:19:23 <chocopuff> i mean, or do we need a completely new language?
04:19:30 <chocopuff> so it would be very deliberate?
04:19:56 <ertes-w> chocopuff: compare it to parallel programming…  GHC will not parallelise your code automatically, because it would almost always get it wrong
04:20:02 <hpc> chocopuff: at the risk of giving microsoft credit for something, check out Q# sometime
04:20:29 <ertes-w> chocopuff: instead you have domain-specific languages like repa, where the implementation can make much more informed choices
04:21:45 <ertes-w> chocopuff: but with quantum effects it's even worse, because they are so specific…  GHC won't be able to figure out that it can achieve an asymptotic speedup by applying a quantum fourier transform to a state vector
04:22:05 <chocopuff> i mean, hypothetically, could it?
04:22:39 <ertes-w> hypothetically sure…  at some point GHC becomes a self-aware AI and can be creative enough to come up with quantum algorithms =)
04:23:44 <ertes-w> achieving the quantum speedup is not a mechanic process, it's a creative one
04:24:25 <chocopuff> and perhaps the creativity can be applied to the compiler! :D  ?
04:25:25 <hpc> chocopuff: i suggest trying out Q#, it's a qc assembly language with emulator
04:25:32 <hpc> chocopuff: and see if you can figure out the mechanical translation
04:25:37 <chocopuff> hpc: yeah, looking into it as of now
04:25:42 <chocopuff> well not the latter...
04:25:48 <ertes-w> chocopuff: can you imagine a compiler that looks at an implementation of insertion sort and rewrites it to mergesort?
04:25:53 <hpc> it might make it more clear just how staggeringly hard it is
04:25:54 <dminuoso> ertes-w: And it's highly domain specific. I mean QC is only advantageous for a very specific set of problems. In the general case QCs are much much slower than classical computers.
04:26:15 <ertes-w> no need to enter microsoft hell…  there are quite a few quantum DSLs with simulators for haskell
04:26:26 <hpc> ertes-w: oh? TIL
04:26:39 <dminuoso> ertes-w: Also regarding your earlier comment (I was out for lunch) - the mere reminder was enough. I mean it's obvious why and how your code works, Im currently trying to wrap my head around the types of said optics.
04:26:46 <Uniaika> Oh nice
04:27:22 <ertes-w> also implementing a quantum DSL and simulator is surprisingly easy =)
04:27:33 <ertes-w> it's basically glorified quantum brainfuck
04:28:31 <ertes-w> in fact we have more powerful computer models together with simulators built right into the base library
04:28:50 <chocopuff> as in haskell base?
04:28:53 <ertes-w> [] can simulate non-deterministic turing machines, which are far more powerful than quantum computers =)
04:29:11 <dminuoso> ertes-w: I tried my luck on this once https://quantumexperience.ng.bluemix.net/qx/editor - but its become quite clear that without extensive research in quantum physics its a pointless excercise.
04:29:40 <ertes-w> dminuoso: you don't need all of quantum physics…  all you need is the linear algebra part and complex numbers
04:30:21 <ertes-w> dminuoso: the prerequisites for learning are also surprisingly few: if you understand complex numbers (not even complex analysis) and vector spaces, you're half-way there
04:36:47 <chocopuff> ertes-w: i actually don't know, I have no knowledge of compilers :P
04:37:07 <chocopuff> ertes-w: what do you need other than complex # and linear algebra?
04:42:54 <nullie> ertes-w: isn't it impossible to implement nondeterministic Turing machine?
04:43:38 <dminuoso> nullie: We have non-deterministic computation right in the language
04:43:56 <dminuoso> So the leap to non deterministic turing machines doesn't seem far
04:50:41 <ertes-w> chocopuff: fun with math =)
04:50:58 <ertes-w> nullie: we don't know
04:51:33 <nullie> Looks like there are possible massively parallel implementations
04:51:36 <ertes-w> nullie: but yeah, NDTMs may well be in conflict with the laws of physics
04:53:16 <ertes-w> imagine a version of [] where (>>=) is exactly one computational step
04:54:17 <ertes-w> > do x <- [1..10]; y <- [1..10]; guard (x + y = 15); pure (x, y)
04:54:20 <lambdabot>  <hint>:1:45: error:
04:54:20 <lambdabot>      parse error on input ‘=’
04:54:20 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
04:54:26 <ertes-w> > do x <- [1..10]; y <- [1..10]; guard (x + y == 15); pure (x, y)
04:54:30 <lambdabot>  [(5,10),(6,9),(7,8),(8,7),(9,6),(10,5)]
04:55:44 <ertes-w> to a regular DTM the number of steps depends on the lengths of those lists…  to an NDTM it doesn't (or if it does, then only logarithmically)
04:55:57 <buglebudabey> hey guys, my sublime 2 shows my haskell syntax highlighting perfectly but sublime 3 doesn't do it very well at all. does anyone know a simple way to go about fixing this (i don't need any fancy plugins, didn't have any for sublime 2)
04:56:35 <ertes-w> in other words: an NDTM could break every cipher by brute-force =)
04:57:31 <ertes-w> not highly informed special purpose, but literal raw search-the-whole-key-space brute-force
05:04:02 <dminuoso> HS question. So far Ive specified all imports one by one at the top. Is this generally considered good style in Haskell, or does one rather just import the entire module (perhaps qualified) to avoid name clashes? https://gist.github.com/dminuoso/0e24b5f0090657cb5c03af9b8402f4dc is what I have right now.
05:04:56 <dminuoso> I mean the neat thing is that it allows me to just look at the top and immediately see all exact dependencies..
05:05:56 <dminuoso> Have tried looking for some common style guides, but there does not appear to be any "common" style guide I could use as a basis.
05:08:45 <quchen> dminuoso: Snoyman likes explicit import lists for example, I’d say it’s a valid and good style. I prefer qualified imports.
05:09:12 <merijn> dminuoso: Depends on the module
05:09:20 <sanitymug> dminuoso: I use -fwarn-missing-import-lists which forces me to do either explicit imnport lists or qualified imports
05:09:29 <tdammers> both qualified and explicit are generally considered fine
05:09:42 <sanitymug> I find it more obvious to navigate codebase and understand where the code is from
05:09:44 <tdammers> unqualified whole-module imports are a bit more controversial
05:09:45 <ertes-w> dminuoso: i import most things to the top-level, and some things (like Data.Text or Data.Map) qualified…  import lists i only use in special cases (like Data.Sequence)
05:09:50 <merijn> dminuoso: For example, modules in base that I use a lot of functions from I'll import unqualified/without import list on the assumption of "everyone knows Control.Applicative"
05:10:17 <tdammers> I like to combine qualified full-module with an alias plus selected key identifiers explicitly
05:10:32 <tdammers> e.g. import qualified Data.Text as Text; import Data.Text (Text)
05:10:49 <ertes-w> dminuoso: short version: use the style that you like…  it's highly subjective
05:11:27 <sanitymug> tdammers: We use that too, mostly for Text, ByteString and vairous maps
05:12:41 <ertes-w> dminuoso: my trade-off is: concise code in exchange for the occasional maintenance effort when something breaks
05:12:44 <tabaqui> I'm not sure, but ApplicativeDo is wrong on some cases
05:12:48 <tabaqui> dunno
05:12:55 <tabaqui> (this, next) <- liftA2 (,) ((fmap Right p <|> fmap Left q) <* s) (find <|> pure []) <|> pure (Left (), [])
05:13:03 <tabaqui> GHC wants Monad instance here
05:13:12 <tabaqui> while I declared only Alternative
05:13:29 <mrkgnao> anyone here understand Bound well? I'm trying to use it with two mutually-recursive datatypes: https://github.com/ekmett/bound/issues/69
05:13:30 <tabaqui> but there is no any monad methods here
05:13:32 <ertes-w> tabaqui: paste your code
05:14:32 <dminuoso> Mmm, thank you all for the responses. I guess ertes-w is right in the end that it's highly subjective.
05:15:32 <tabaqui> ertes-w: https://pastebin.com/WLiNrx8V
05:16:39 <ertes-w> tabaqui: in principle 'pure' has to be the top-level function on line 17, but i believe at some point GHC was patched to support ($)
05:17:00 <ertes-w> tabaqui: try: pure (either …)
05:18:05 <tabaqui> ertes-w: nope, still the same
05:18:28 <tabaqui> GHC highlights the line 16
05:19:09 <tabaqui> I have simplified this code and avoid the error, but I still use the same functions
05:19:35 <ertes-w> tabaqui: are you saying that the code you pasted actually works? ;)
05:19:59 <tabaqui> ertes-w: If I add Monad instance - it will work :)
05:21:12 <tabaqui> this code does the same job, but has no Monad instance
05:21:14 <tabaqui> https://pastebin.com/jrqAiBW4
05:23:06 <ertes-w> tabaqui: ah, of course
05:23:28 <ertes-w> tabaqui: the problem is the pattern-match…  you need to use an irrefutable pattern
05:23:41 <ertes-w> ~(this, next) <- …
05:24:26 <tabaqui> okaay
05:24:28 <tabaqui> it works
05:24:35 <tabaqui> ... where can I read about them?
05:25:09 <ertes-w> tabaqui: (do (x, y) <- c; pure f x y) ≠ fmap (uncurry f) c
05:25:23 <ertes-w> pattern-matches in do-blocks are strict by default
05:25:53 <ertes-w> and strict pattern-matches are impossible with Applicative alone
05:26:59 <merijn> "pattern matches in do-blocks are strict by default" <- eh, which pattern matches AREN'T strict by default, then?
05:27:11 <ertes-w> merijn: let
05:29:17 <tabaqui> well, thanks
05:43:54 <dminuoso> If I had a MonadReader with MonadIO and want to pass the environment from there to another monad, do I just `ask` for the environment and pass it along from there?
05:49:12 <dminuoso> In particular I have this simple function https://gist.github.com/dminuoso/1fbcc4f7cb06421d0dd270e7df6f04e4, something feels wrong about that abstract getLdap that somehow knows about what reader monad to use for getPasswordFor
05:56:18 <tabaqui> hmm, function in ApplicativeDo stile cannot be tail-recursive
05:56:21 <tabaqui> *style
05:56:50 <tabaqui> because the last call must be "return" or "pure"
05:57:05 <tabaqui> right?
05:58:53 <__monty__> I use "hoogle server --local -p 8008" the local flag replaced the file:// links up until recently, should I report this as an issue or am I overlooking something I'm doing wrong?
05:59:57 <dminuoso> Ohh nevermind! I think Im getting the hang out of this.
06:02:09 <tabaqui> well, nope, I'm wrong, do-expression will be translated in tail-recursive function
06:04:27 <smurfendrek123> hello, why does this give a parse error on case? https://paste.fedoraproject.org/paste/vnQ6KetovqfLj5jEg2JKGQ/raw
06:04:48 <dminuoso> smurfendrek123: Because you missed the `do`
06:05:05 <merijn> dminuoso: Even with the do it's an error
06:05:11 <dminuoso> merijn: Because of the indention?
06:05:15 <merijn> since the case is a line continuation of the putStrLn
06:05:32 <dminuoso> Double treachery then. :-)
06:05:39 <smurfendrek123> dminuoso, why do i need a do with case?
06:05:41 <metahumor> also you can't use "otherwise" in a case
06:06:01 <merijn> metahumor: You can
06:06:06 <tdammers> you can, but not for the right reasons
06:06:07 <dminuoso> smurfendrek123: You want to chain multiple effects together. You either need to do this explicitly with >>=/>> or using do notation.
06:06:25 <merijn> > case Nothing of Just _ -> "Just!"; otherwise -> "Nothing!"
06:06:28 <lambdabot>  "Nothing!"
06:06:40 <merijn> metahumor: otherwise is just a variable pattern there
06:06:45 <tdammers> > case Nothing of Just _ -> "Just!"; pancakes -> "Nothing!"
06:06:46 <dminuoso> :t otherwise
06:06:48 <lambdabot> Bool
06:06:49 <lambdabot>  "Nothing!"
06:06:55 <dminuoso> > print otherwise
06:06:58 <lambdabot>  <IO ()>
06:07:19 <tdammers> dminuoso: case "Hello" of otherwise -> otherwise
06:07:24 <metahumor> either you do "case (null erecord) of {True -> putStrLn ... ; otherwise -> putStr ...}" or "case erecord of {[] -> ... ; _ -> ...}"
06:07:26 <tdammers> > case "Hello" of otherwise -> otherwise
06:07:26 <[exa]> wat.
06:07:28 <dminuoso> Ohh it doesn't run aeffects right.
06:07:31 <lambdabot>  "Hello"
06:07:43 <dminuoso> > otherwise
06:07:46 <tdammers> dminuoso: lambdabot doesn't run IO actions, no
06:07:46 <lambdabot>  True
06:07:47 <dminuoso> :)
06:07:48 <merijn> metahumor: No, you can't pattern match variables like that
06:07:57 <dminuoso> tdammers: Yeah, I fell into that trap before.
06:08:01 <merijn> metahumor: You're just defining a new variable named "otherwise" in the case
06:08:12 <metahumor> right.
06:08:18 <tdammers> dminuoso: otherwise evaluated on its own is the same otherwise you'd also use in a guard; a top-level variable of type Bool
06:08:27 <merijn> metahumor: Which ends up working the same as _
06:08:38 <tdammers> dminuoso: but otherwise on the left-hand side of a case branch is a free variable in a pattern
06:08:40 <tabaqui> compiler is our friend, use -Wall -Werror
06:08:50 <tdammers> dminuoso: similar to let otherwise = "Hello" in "Hello"
06:08:54 <tabaqui> *and -fno-warn-orphans
06:09:11 <merijn> tabaqui: That last one is bad
06:09:20 <merijn> You *should* warn for orphans
06:09:21 <metahumor> so would you do "case (null erecord) of" or "case erecord of"? or even a "if (null erecord) then ... else ..."?
06:09:47 <dminuoso> smurfendrek123: Anyway.
06:09:49 <dminuoso> :t putStrLn
06:09:51 <lambdabot> String -> IO ()
06:10:14 <tabaqui> merijn: but you cannot warn for orphans and get compile error for other cases
06:10:20 <tabaqui> don't you?
06:10:30 <merijn> tabaqui: what?
06:10:30 <tabaqui> *do you?
06:10:33 <dminuoso> smurfendrek123: So putStrLn "+..." gives you an IO (), and then you want to sequence another IO () after that. You need >> for that.
06:10:47 <tabaqui> -Wall -Werror -fno-warn-orphans
06:11:03 <smurfendrek123> how would i do it with do notation dminuoso ?
06:11:09 <merijn> tabaqui: Why disable orphan warnings there?
06:11:09 <tabaqui> how can I use this options simultaneously?
06:11:30 <tabaqui> because I want to declare FromJSON for ByteStrings, for example
06:11:44 <merijn> Better of newtyping the ByteString and instancing those
06:13:23 <tabaqui> theoretically yes
06:13:52 <tabaqui> but it is so boring!
06:14:28 <ertes-w> @where iotut
06:14:28 <lambdabot> https://www.vex.net/~trebla/haskell/IO.xhtml
06:14:32 <ertes-w> smurfendrek123: ^
06:14:58 <smurfendrek123> thanks
06:15:36 <tabaqui> @where monadbasecontroltut
06:15:36 <lambdabot> I know nothing about monadbasecontroltut.
06:17:19 <metahumor> smurfendrek123: f erecord = do {putStrLn "+--------------------"; case erecord of {[] -> putStrLn "| EMPTY"; _ -> putStr (unlines (fmap show erecord))}; putStrLn "+--------------------"; return ()}
06:17:32 <smurfendrek123> thanks a lot!
06:17:44 <metahumor> smurfendrek123: now, explain what bugs got fixed
06:18:50 <ertes-w> smurfendrek123: read the tutorial anyway
06:18:53 <smurfendrek123> I will
06:19:11 <metahumor> smurfendrek123: you pretty much had some bug on each line. i fixed them, but i think it'll be clearer for you if you can explain the details
06:19:42 <smurfendrek123> i'm still reading your solution :p
06:19:50 <__monty__> Is there a way to access a Vector.Unboxed similar to ByteString's withForeignPointer?
06:21:01 <jchia_> Question about concurrency control. I have a 20-core machine. I have a program whose job scheduler concurrently has 20 Asyncs that are running. Some of these Asyncs are waiting for an external process to finish (System.Process.waitForProcess. Others are doing Haskell pure computation plus some IO. Each process is taking 100% CPU. I have a problem where the pure Haskell Asyncs seem to be taking more than 100% CPU per Async (the RTS tryin
06:21:01 <jchia_> g to optimize my pure calculations). The result is oversubscription of CPU resource and cache pressure. How can I restrict the CPU usage of the pure-Haskell Asyncs?
06:21:24 <merijn> __monty__: Don't think so, unboxed vectors aren't pinned, I think
06:21:33 <jchia_> I'm running with +RTS -threaded -N20 -RTS
06:21:36 <merijn> __monty__: Maybe you want Vector.Storable?
06:22:00 <merijn> jchia_: I had the exact issue this week and lucky you, I know the problem
06:22:15 <smurfendrek123> metahumor, can i replace the brackets with indendation?
06:22:17 <merijn> jchia_: Synchronisation of parallel GC is killing you
06:23:07 <jchia_> merijn: Did you find a solution? Should I use asyncBound to use OS threads instead of green threads?
06:23:21 <merijn> jchia_: By default -threaded does parallel GC to speed up the GC, but if you have a high thread count (32 in my case), it wastes way more time doing GC than it speeds up
06:23:24 <jchia_> my goal is for each async to take one CPU.
06:23:33 <merijn> jchia_: For me I got a dramatic speedup by just disabling parallel GC
06:23:39 <jchia_> yeah, i see that problem alot whenever I use -threaded
06:24:09 <merijn> ljchia_: Try compiling with rtsopts and then run with "+RTS -qg" that will disable parallel GC
06:24:20 <metahumor> smurfendrek123: yes, you can replace the brackets with indentation, i just wrote it in one-line style
06:24:29 <merijn> jchia_: My query stream dropped from 200s runtime to 15s
06:24:49 <metahumor> as a matter of fact, you should prefer to write do-blocks with indentation, bracket-style is hard to parse imo
06:25:14 <arguggi> I'm trying to use concurrency (and dejafu), how am I supposed to add an instance of MonadConc for my stack (newtype Stack m a = Stack { runStack :: ReaderT Env m a }  ? GND doesn't seem to work
06:25:26 <jchia_> merijn: -qg0? -qg1?
06:25:29 <merijn> jchia_: Of course you should profile to (try running with "+RTS -sstderr" first and "+RTS -sstderr -qg" second
06:25:35 <merijn> jchia_: No, no argument
06:25:39 <merijn> just "-qg"
06:26:11 <barrucadu> arguggi: I'm surprised that GND doesn't work because there is an instance for ReaderT
06:26:44 <barrucadu> Although, it wouldn't be too surprising if GND didn't like the type family stuff
06:26:54 <barrucadu> I can have a look later, I'm working currently
06:27:08 <merijn> jchia_: numeric argument to -qg says which generations to collect in parallel. Without an argument it turns of parallel GC completely
06:27:33 <smurfendrek123> metahumor, why did you change the map to fmap? Is it because you have no knowledge of whether or not erecord is a list?
06:27:42 <smurfendrek123> and if it is, can i replace it with map?
06:27:47 <jchia_> Yeah, the default being 0 doesn't mean very much. I think -qg is not the same as -qg0
06:28:05 <merijn> jchia_: -qg is not the same as -qg0, no
06:29:33 <arguggi> barrucadu, thanks, I'll paste the error message soon, maybe I'm doing something wrong
06:31:24 <jchia_> merijn: Suppose I have 19 Asyncs waiting for external process (thus taking 0% CPU but their external processes are taking 1900% CPU), and 1 Async doing pure Haskell calculation. Is there anything stopping the RTS from giving pure Haskell Async >100% to do the pure calculation in parallel on multiple threads?
06:31:47 <jchia_> This would cause the CPU to be oversubscribed.
06:32:24 <jchia_> With the -gq I'm not seeing this yet, but I want to know how the RTS decides to use allocate threads.
06:32:44 <merijn> jchia_: How would it parallelise the pure calculation?
06:32:58 <merijn> Also, what's the point in having 19 capabilities if they're gonna idle?
06:33:07 <jchia_> f x = g x + h x -- do g x and h x in parallel?
06:33:22 <merijn> jchia_: GHC never magically parallelises things
06:34:00 <jchia_> merijn: OK. So I suppose the higher-than-expected CPU utilization from before was from parallel GC.
06:34:24 <merijn> jchia_: Yes. I had it hit 1900% CPU last week
06:34:44 <merijn> jchia_: Also "-N 20" is completely useless if 19 of those are going to be idle
06:34:51 <[exa]> jchia_: btw what are you parallelizing?
06:35:04 <jchia_> merijn: Regarding the 19 "idle capabilities" -- at any one time there are 20 Asyncs, but each Async could be doing different things -- sometimes Haskell calculation, sometimes spawning external process waiting for it to finish.
06:35:09 <merijn> Hell, there's not even really a point in using the threaded RTS at all if you just have 1 compute bound haskell thread
06:35:26 <[exa]> +1 ^^
06:35:40 <merijn> jchia_: So? If there's only 1 async doing computation, then you only need 1 capability
06:35:56 <smurfendrek123> metahumor, why do i need the return()?
06:35:56 <jchia_> so, i could have 20 asyncs all busy with haskell computation or 20 asyncs all waiting for external process, on somewhere in between
06:35:59 <HaskellNoob> Okay, so here's a rather tough nut to crack. I am not even sure whether there is a 'good' way to do it. Currently we are working on some toy compiler. For that, we have a bunch of types to represent our AST. Now, we figured that we need extra information from the parser (source positions) that should annotate the AST. Is there any way to avoid adding a position field to every data type used in the AST?
06:36:28 <jchia_> when async finishes, i create a new one
06:36:47 <smurfendrek123> and metahumor for the bugs you fixed: you changed otherwise to _ because else it would print every time i think
06:37:39 <[exa]> HaskellNoob: Not everything in AST has a position (e.g. desugared constructs). Why not make a "Position" a tiny invisible object of its own in AST?
06:37:45 <arguggi> barrucadu, http://lpaste.net/7432082615261200384
06:37:47 <jchia_> exa: I'm running some machine learning jobs on market data
06:37:57 <smurfendrek123> also, my list comprehension did nothing, but could be replaced with a new one that actually called show, but your solution with map is quite elegant as well
06:38:10 <[exa]> jchia_: how much data it needs to communicate with your main process?
06:39:31 <metahumor> smurfendrek123: the "return ()" isn't necessary, i'm just trying to be explicit about the end of your do block. you can have the "putStrLn ..." be the last line
06:39:35 <smurfendrek123> and most importantly, you added the do notation, so that multiple actions could be performed, but i will read the link that ertes provided to learn more about why that is neccesary
06:39:45 <smurfendrek123> thanks a lot
06:39:53 <[exa]> HaskellNoob: pro: you only add 1 extra function variant for everything; more direct matching is solved by something like 'removePosition'
06:40:14 <HaskellNoob> @exa: Right. Not every element has positions (but many do). Point is, I would like to keep the types of the AST more or less intact (i don't want to change a lot of data type definitions).
06:40:27 <metahumor> smurfendrek123: that's right about the list comprehension, also your parens were in such a way that "putStr unlines ..." would have given you an error
06:40:42 <[exa]> HaskellNoob: what does your AST look like?
06:40:43 <metahumor> smurfendrek123: the case statement doesn't need an indentation
06:41:11 <smurfendrek123> also would you know why the | doesn't print anymore with your solution, but just PutStr "| " does print the |?
06:41:41 <smurfendrek123> Ah i know
06:41:45 <smurfendrek123> it's just not added, sorry
06:41:49 <metahumor> the "|" in "| EMPTY" does print in my soln as far as I can tell
06:41:53 <smurfendrek123> yes
06:42:06 <metahumor> oh you wanted "| item" for the non-empty case too?
06:42:09 <jchia_> exa: It just leaves a file behind
06:42:27 <metahumor> smurfendrek123: your list comprehension before also referenced an "l" that you did not have defined
06:42:33 <jchia_> 1-2GB per task
06:42:52 <[exa]> jchia_: and the amount of computation you need to do in the 'main' thread?
06:43:05 <[exa]> (with the result I guess)
06:43:13 <jchia_> 'main' thread is just a scheduler
06:43:43 <jchia_> downstream tasks take the output of upstream tasks as input
06:43:52 <HaskellNoob> @exa: http://lpaste.net/361727
06:43:53 <[exa]> I'd suggest using make instead, but I guess your data is more complicated :]
06:45:08 <[exa]> (esp. if the programs can be viewed as transformations on files/inputs/outputs and the schedule is deterministic)
06:45:59 <smurfendrek123> metahumor, yea originally i had a more correct version where the othewise was replaced by l, so when erecord was a non empty list (l), i would unpack it, and do list comprehension on it
06:46:06 <[exa]> HaskellNoob: oh no, a rich language. :]
06:46:28 <HaskellNoob> exa: It's a subset of C
06:46:39 <jchia_> i don't know whether make can understand if my target are not fixed files but results for parameters that the user can specify for each run
06:46:57 <jchia_> the dependency structure is also quite complicated
06:47:42 <[exa]> if it's dag make could cope. Input is done using just as with compilers, user creates a file 'taskID.assignment' and expects 'taskID.result'
06:48:00 <[exa]> anyway, for the original problem
06:48:10 <[exa]> if your main thread is just a scheduler, use singlethreaded haskell and polling
06:48:26 <jchia_> exa: make typically has fixed targets. In my app, the user specifies the params of the result he's trying to compute. so it's not fixed, and writing a new makefile by hand is bad UX.
06:48:27 <merijn> [exa]: Don't need to poll
06:48:27 <[exa]> that will remove the (really unnecessary) multitasking overhead
06:48:43 <merijn> [exa]: The single-threaded runtime still support green threads
06:48:49 <merijn> [exa]: They just don't run in parallel
06:48:49 <[exa]> oh, even better
06:48:50 <smurfendrek123> Can i write map (((++) "| ").show) erecord with a $ instead of a .?
06:48:55 <dminuoso> Is there a better pattern to running IO in tandem with Maybe? https://gist.github.com/dminuoso/855de3383890110aa39721fa8305bd40
06:49:02 <dminuoso> Or do I have to resort to a MaybeT?
06:49:12 <merijn> [exa]: So you can just write the "dumb blocking" code with threads and just run it with the unthreaded runtime no problem
06:50:24 <jchia_> exa: I still need "worker" threads besides the main thread to do some of the the calculation in Haskell.
06:50:38 <merijn> jchia_: What kinda calculation are we talking?
06:51:25 <[exa]> jchia_: fork them off so that they don't garbage-starve each other
06:51:34 <dminuoso> smurfendrek123: check out ShowS/shows/showString
06:52:03 <dminuoso> smurfendrek123: Its not quite what you asked for, but its what I think you might want to use. :)
06:53:12 <jchia_> Stage 1 calls an external C++ program to do generate some stats. Stage 2 in Haskell takes those stats and does some summing,sorting and ranking. Stage 3 calls an external C++ program to generate some matrices. Stage 4 calls an external python program takes those matrices to do some regression. Stage 5 calls an external C++ program to do an out-of-sample evaluation of the regression. So, Stage 2 is Haskell but the rest are not, though I
06:53:13 <jchia_> could port them to Haskell later.
06:54:05 <[exa]> smurfendrek123: show needs a parameter so it will be probably hard to get $ there, but you can minimize parentheses with something like: flip map erecord $ ("| " ++).show
06:54:21 <lyxia> dminuoso: traverse
06:54:24 <smurfendrek123> that seems more complicated
06:54:26 <lyxia> dminuoso: traverse_
06:54:40 <smurfendrek123> but thanks anyways
06:54:50 <metahumor> smurfendrek123: (("| " ++) . show) <$> erecord
06:55:08 <dminuoso> lyxia: Oh.. heh. The irony.
06:55:16 <smurfendrek123> wait what do <> do?
06:55:21 <dminuoso> lyxia: I've been using traverse all around that Maybe, but not for the Maybe itself. :-)
06:55:37 <dminuoso> lyxia: Did not realize that Maybe too is Traversable. =)
06:55:40 <dminuoso> Thanks.
06:56:08 <[exa]> smurfendrek123: it's like $ but over a Functor (in our case over the list)
06:56:09 <metahumor> smurfendrek123: (<$>) :: Functor f => (a -> b) -> f a -> f b
06:56:20 <metahumor> smurfendrek123: that is, its like infix fmap
06:56:38 <smurfendrek123> nice
06:56:56 <[exa]> smurfendrek123: . is equivalent to it here, so you can do
06:57:01 <[exa]> > ("| " ++) <$> show <$> [1,2,3]
06:57:04 <lambdabot>  ["| 1","| 2","| 3"]
06:57:14 <smurfendrek123> that's what i was looking for, that's pretty cool
06:57:43 <smurfendrek123> is this equivalent to calling 2 maps instead of having 1 map with 2 function calls?
06:57:50 <metahumor> smurfendrek123: so you'd have a line something like "putStr . unlines $ (("| " ++) . show) <$> erecord"
06:57:52 <smurfendrek123> I know it makes no final difference, but i'm just curious
06:58:05 <smurfendrek123> ncie
06:58:09 <smurfendrek123> *nice
06:58:48 <[exa]> in fact it's left-associative so it composes the prefix and show first
06:59:08 <smurfendrek123> cool
06:59:09 <[exa]> HaskellNoob: I was looking at how GHC does it
06:59:16 <metahumor> does it matter? wouldn't the strictness only kick in at "putStr"?
07:00:30 <[exa]> metahumor: afaik it produces one less list node this way (if the inliner can't chew that out)
07:00:47 <[exa]> (per element)
07:03:43 <wz1000> HaskellNoob: you might want to look at a paper called Trees that Grow
07:04:13 <HaskellNoob> wz1000: Thanks. I will look into it.
07:04:35 <metahumor> [exa]: "this way" means the two fmap way, or the one fmap way?
07:06:03 <HaskellNoob> wz1000: Judging from the abstract, that's exactly what I was looking for :-)
07:07:00 <[exa]> metahumor: two-fmap and one-fmap way is perfectly equivalent, the other way (with one extra list) would be if <$> would be infixr
07:07:52 <metahumor> gotcha, you're saying (fmap prepend (fmap show list)) would form the list twice
07:09:03 <[exa]> yeah, provided the optimizer won't simplify it
07:09:30 <metahumor> but because of how "(->) a" is a functor, we get nice "fmap f g :: f . g"
07:10:09 <metahumor> ehh "=" instead of "::"
07:10:16 <arne> why exactly do you have to give the RTS parameters when wanting multiple cores?
07:10:31 <arne> why isnt the default behaviour to use 4 threads
07:13:26 <[exa]> arne: not everyone can afford 4 threads
07:17:09 <[exa]> hm, location tracking in ghc is not overly smart, basically data Located e = L SrcSpan e
07:18:10 <merijn> What function do I want for converting from one type of Vector to another?
07:21:13 <lyxia> merijn: convert
07:21:23 <merijn> lyxia: Cheers
07:29:53 <dminuoso> Would someone be willing to take a look at my small program and give me some feedback about possibly obvious mistakes or things I should avoid/improve on? https://gist.github.com/dminuoso/e148891e7dfdf3669aa5762347c2b47c
07:49:20 <univhelp> can someone help me with this list builder ? [j|0:j:_<-tls mnr], I'm having hard times to understand what is the 2nd j and what the any match does in there
07:50:01 <cocreature> 0:j:_ matches a list with at least two elements where the first element is 0 and binds the second element to the name j
07:50:30 <cocreature> > [j|0:j_ <- [[0,1],[0,2],[0,3]]]
07:50:34 <lambdabot>  [j,j,j]
07:50:36 <cocreature> > [j|0:j:_ <- [[0,1],[0,2],[0,3]]]
07:50:43 <lambdabot>  mueval-core: Time limit exceeded
07:50:51 <cocreature> huh
07:51:28 <cocreature> % [j | 0:j:_ <- [[0,1],[0,2],[0,3]]]
07:51:29 <yahb> cocreature: [1,2,3]
07:51:33 <cocreature> ah that’s better
07:51:41 <univhelp> thanks that helped heaps
07:52:59 * hyperisco feeds the hamster
07:54:53 <hyperisco> who runs lambdabot? do they need donations?
07:55:17 <hyperisco> it has been having a lot of trouble lately
07:59:20 <dmj`> does inline-swift exist?
08:00:55 <[exa]> dmj`: afaik that would be complicated at best
08:01:08 <[exa]> hyperisco: /me joins the effort
08:02:22 <mozzarella> is "learn you a haskell" a good book?
08:02:37 <hyperisco> is mozzarella a good cheese?
08:02:41 <mozzarella> yes
08:02:54 <dminuoso> It depends on whether its buffalo mozzarella or not.
08:02:54 <Clint> when it's fresh
08:03:20 <[exa]> mozzarella: you'll need some extra motivation to invent exercises but it will reward you with graphics.
08:03:39 <cocreature> mozzarella: depends on what you are using it for. I think it’s a nice book to get you interested in Haskell and learn the very basics but it won’t get you to the point where you can write useful programs ime
08:03:40 <bartavelle> (bufala)
08:03:51 <cocreature> also it’s missing exercises
08:04:03 <byorgey> mozzarella: it is fun and cute.  It contains some good information.  I think it introduces topics in a bad order.  And as others say it has no exercises.
08:04:31 <mozzarella> can you suggest a better book/material to learn from?
08:04:32 <[exa]> certainly good if you already know programming
08:05:20 <byorgey> mozzarella: Hutton's "Programming in Haskell" and http://haskellbook.com/ are both good
08:05:55 <dmwit> go gentle or go home
08:05:57 <dmwit> ?where gentle
08:05:57 <lambdabot> http://www.haskell.org/tutorial/
08:06:27 <dmwit> Beware: many people disagree with me. But I found the direct, no-bullshit approach incredibly appealing.
08:07:28 <byorgey> Beware also that the title is a misnomer.
08:07:46 <mozzarella> June 2000
08:07:48 <mozzarella> uh
08:07:54 <byorgey> But it is reasonable if you know what you are getting into.
08:08:10 <byorgey> mozzarella: the basics of Haskell haven't changed all that much since then.  Of course there is lots more to learn beyond that.
08:08:19 <hyperisco> it is okay, the basics of the language have not changed
08:09:34 <hyperisco> that source is much less conversational. i.e. it just says what is and you have to do the work to connect the dots
08:10:11 <univhelp> can someone help me a bit with this expression (head.words.(\n o ->o:name)'-')'+' ? I'm really unsure what the lambda expression does with the '-' and '+'
08:10:53 <mpickering> Is there a way in TH to generate a fresh name?
08:11:29 <hyperisco> (head.words.(\n o ->o:name)'-')'+' ≡ (head.words.(\o->o:name))'+'  by β-reduction
08:11:38 <cocreature> mpickering: newName?
08:11:55 <hyperisco> univhelp, does that help you?
08:12:28 <univhelp> well not by much actually, should I know what a beta reduction is?
08:13:08 <hyperisco> if you're talking about lambdas it wouldn't hurt. It is just what it is called when you reduce a function application but substituting the argument for the parameter
08:13:18 <hyperisco> application by substituting*
08:13:46 <mpickering> cocreature: however if I use that name for a top level decl there are complaints about "multiple declarations of x"
08:14:58 <cocreature> mpickering: that’s annoying, sry not sure if there is something else
08:15:04 <hyperisco> univhelp, now just unfold . and you can continue β-reducing
08:15:07 <univhelp> can i basically ignore the n and '-' because its not included right of the -> ?
08:16:21 <hyperisco> you cannot ignore anything
08:17:26 <hyperisco> (\n o -> o : name) '-'  reduces to  (\o -> o : name)  by substituting  '-'  for  n  in  o : name
08:17:52 <hyperisco> well, I should say in  \o -> o : name
08:18:11 <hyperisco> Haskell lets us abbreviate  \n -> \o -> o : name  as  \n o -> o : name
08:19:16 <hyperisco> it will matter to pay attention to that if there is any variable shadowing
08:19:38 <hyperisco> though I don't think you're allowed to use the abbreviation then
08:19:43 <newtohaskell> hello everyone, I just find a algorithmic error in haskell. https://imgur.com/Lj501kh
08:19:49 <hyperisco> :t \x x -> x
08:19:52 <lambdabot> error:
08:19:52 <lambdabot>     • Conflicting definitions for ‘x’
08:19:52 <lambdabot>       Bound at: <interactive>:1:2
08:19:55 <hyperisco> :t \x -> \x -> x
08:19:59 <lambdabot> p1 -> p2 -> p2
08:20:18 <newtohaskell> Does everyone can explain why this will happend?
08:20:49 <hyperisco> if you are doing anything with floats then don't be too surprised
08:20:57 <hydraz> 2^58 - 1 is an integer, Python is using doubles?
08:21:09 <hyperisco> float operations are not accurate!
08:21:51 <hydraz> rather, the other way around, I think; Haskell is using Doubles (precision loss, because floats) and Python is using some arcane big decimal type
08:22:01 <hydraz> % round _
08:22:02 <yahb> hydraz: ; <interactive>:15:7: error:; * Found hole: _ :: Double; * In the first argument of `round', namely `_'; In the expression: round _; In an equation for `it': it = round _; * Relevant bindings include it :: b (bound at <interactive>:15:1); Valid substitutions include; magicDict :: forall a. a (imported from `GHC.Exts' (and originally defined in `GHC.Prim')); und
08:22:09 <hyperisco> :t (^)
08:22:11 <lambdabot> (Num a, Integral b) => a -> b -> a
08:22:16 <polarisiss> hello i have pirated version of learn haskell from first principle and also learn you haskell,, does learning haskell teaches basic algorithms or should I need seperate course for algorithms
08:22:28 <hyperisco> > 2^58 - 5 :: Integer
08:22:32 <lambdabot>  288230376151711739
08:22:33 <hydraz> why ask for the type of something when you can make a hole, haha
08:22:46 <hyperisco> :t round
08:22:49 <lambdabot> (Integral b, RealFrac a) => a -> b
08:22:57 <hyperisco> > 2^58 - 5 :: Double
08:23:01 <sanitymug> > 2^77232917 − 1
08:23:03 <[exa]> polarisiss: separate course is usually needed
08:23:04 <lambdabot>  mueval-core: Time limit exceeded
08:23:05 <MarcelineVQ> polarisiss: algorithms aren't usually part of learning the language itself
08:23:05 <lambdabot>  error:
08:23:05 <lambdabot>      Variable not in scope: (−) :: Integer -> Integer -> t
08:23:13 <hyperisco> > round (2^58 - 5 :: Double) :: Integer
08:23:16 <lambdabot>  288230376151711744
08:23:52 <dminuoso> dmwit: If only the gentle introduction had more depth. I mean I found it refreshingly precise, but it's mostly a rush through some theoretic concepts.
08:23:59 <hexagoxel> > round (2^58 - 5 :: Rational)
08:24:03 <lambdabot>  288230376151711739
08:24:06 <hyperisco> hydraz, why make a hole when you can just ask for the type?
08:24:21 <hydraz> hyperisco: because I thought of the hole first :p
08:24:51 <mozzarella> is this good? https://en.wikibooks.org/wiki/Haskell
08:24:52 <polarisiss> [exa]:  MarcelineVQ  so I am new to programming and my friend asked me to learn haskell first who is a programmer and he only told me about this irc,  he is busy now, So I must need algorithms to write any software ?
08:25:23 <sanitymug> > 2^61 - 1
08:25:28 <lambdabot>  2305843009213693951
08:25:40 <sanitymug> > 2^107 - 1
08:25:46 <lambdabot>  162259276829213363391578010288127
08:25:47 <hydraz> % 2^107 - 1
08:25:47 <yahb> hydraz: 162259276829213363391578010288127
08:25:50 <dminuoso> Are there advantages to using holes compared to using `undefined` and having my editor tell me types of things?
08:25:51 <hydraz> oh, mueval did it after all
08:26:09 <hydraz> dminuoso: yes; I don't need editor support for figuring out the types of things
08:26:16 <ertes-w> dminuoso: yes, you can place holes anywhere
08:26:25 <hyperisco> a hole will tell you the context as well
08:26:27 <ertes-w> dminuoso: myFunc = f x y _ z
08:26:33 <dminuoso> ertes-w: Doesn't that apply to undefined too?
08:26:46 <ertes-w> dminuoso: how do you ask for the type of the undefined value?
08:27:01 <dminuoso> ertes-w: mark and crtl+alt+t :)
08:27:06 <hyperisco> > \x -> let y = chr x in _
08:27:09 <lambdabot>  error:
08:27:10 <lambdabot>      • Found hole: _ :: t
08:27:10 <lambdabot>        Where: ‘t’ is a rigid type variable bound by
08:27:13 <sanitymug> > f x = x + (undefined :: _)
08:27:16 <lambdabot>  <hint>:1:5: error:
08:27:16 <lambdabot>      parse error on input ‘=’
08:27:16 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
08:27:25 <sanitymug> > let f x = x + (undefined :: _) in f
08:27:31 <hyperisco> well, it'd go on to tell you  x :: Int  and  y :: Char
08:27:32 <lambdabot>  mueval-core: Time limit exceeded
08:27:33 <ertes-w> dminuoso: well, if you use that, then no, there isn't much of a difference…  however, GHC warns you about holes, which you can use to make sure you've filled all of them
08:27:57 <hydraz> dminuoso: holes give you relevant values in scope, much like other type errors
08:27:58 <ertes-w> dminuoso: also it's just less to type
08:28:00 <dminuoso> ertes-w: Ah well there's that I guess. Plus perhaps the context could be useful. :)
08:28:05 <sanitymug> holes+ghcid is nice way to write code
08:28:07 <hyperisco> and this is especially helpful if you're doing any sort proof
08:28:07 <dminuoso> hydraz: I see.
08:28:09 <MarcelineVQ> polarisiss: It'd be a petty good idea to know something about them yes, you can do quite a lot just using libraries though
08:28:09 <hydraz> % let x = 1 in 2 + _
08:28:11 <yahb> hydraz: ; <interactive>:17:18: error:; * Found hole: _ :: a; Where: `a' is a rigid type variable bound by; the inferred type of it :: Num a => a; at <interactive>:17:1-18; * In the second argument of `(+)', namely `_'; In the expression: 2 + _; In the expression: let x = 1 in 2 + _; * Relevant bindings include; x :: forall p. Num p => p (bound at <
08:28:14 <hyperisco> any sort of proof*
08:28:17 <ertes-w> dminuoso: holes also provide context information
08:28:18 <hydraz> damn it, that's too long I guess
08:28:30 <sanitymug> > let f x = x + (undefined :: _)
08:28:34 <lambdabot>  <no location info>: error:
08:28:34 <lambdabot>      not an expression: ‘let f x = x + (undefined :: _)’
08:28:35 <hydraz> oh no - "Relevant bindings include; x :: forall p. Num p => pp"
08:28:42 <ertes-w> dminuoso: most often just the type of the hole can easily be guessed from context, but then having an overview of everything in scope is much more useful
08:28:46 <sanitymug> % let f x = x + (undefined :: _)
08:28:46 <yahb> sanitymug: ; <interactive>:18:29: error:; * Found type wildcard `_' standing for `w'; Where: `w' is a rigid type variable bound by; the inferred type of <expression> :: w; at <interactive>:18:29; To use the inferred type, enable PartialTypeSignatures; * In an expression type signature: _; In the second argument of `(+)', namely `(undefined :: _)'; In the e
08:29:49 <polarisiss> MarcelineVQ:  please dont mind, I didnot understand what libraries?  knowing algorithms help to use libraries?
08:33:07 <MarcelineVQ> A library is something somebody else wrote to do a specific job that you can use in your own program. In well known libraries people have put in a lot of effort to find the best data structures and algorthims to do that job which means you don't need to.
08:33:35 <mpickering> cocreature: I just made up a unique name via some other uniqueish information in the end
08:34:02 <hyperisco> polarisiss, it would be a good idea to pick up some beginner material for a programming language that sounds interesting to you (Haskell is a good choice!) and just start reading
08:35:28 <jonge> hey there, when i want to upload a package using `stack upload` and want that it will forever successfully compile, where should i fix my version numbers? in the package.cabal file or in stack.yaml?
08:35:48 <polarisiss> MarcelineVQ:  so in that case i dont have to know algoithms/data structures  if i am correct
08:35:51 <hyperisco> polarisiss, an algorithm is a high level description of how to compute the solution to a problem. For example, we have various sorting algorithms for the purpose of putting numbers into order.
08:36:02 <polarisiss> hyperisco: I have haskellbook
08:36:19 <polarisiss> hyperisco:  so they are mandatory ?
08:36:22 <MarcelineVQ> It is always useful to know algorithms and data structures, the library you need might not exist and you'll have to invent it
08:36:26 <jonge> i mean, if the resolver of the user who just enters `stack install packagename`, has a different resolver than me when i uploaded it, some packages in my cabal file might be gone already?
08:36:56 <MarcelineVQ> but you don't have to start by learning them, you can learn a language first and see if you like it
08:37:39 <sm> jonge: in the cabal file
08:38:16 <MarcelineVQ> jonge: there's no 100% gurantee but upload has an option called  --pvp-bounds   that can do the versioning, it does this by adding them to the cabal file before upload afaik
08:38:24 <hyperisco> polarisiss, then get reading! :) a library is a set of definitions which all work together to help you solve a particular problem. For example, a linear algebra library will help you work with matrices and vectors. Essentially, a library is a separately packaged program fragment that you can use to build a complete program.
08:38:36 <kadoban> polarisiss: Algorithms and data structures are usually something you pick up a bit later on. You can get by in the vast majority of software with a pretty paltry amount of knowledge anyway, so I wouldn't focus on that unless you want to.
08:38:38 <polarisiss> MarcelineVQ:  hyperisco  my friend said 1) Learn haskell
08:38:40 <polarisiss> 2) learn Algorithms  3) Solve problems in topcoder and project euler
08:39:29 <MarcelineVQ> sounds like a good order to do things in
08:41:00 <TMA> there is a "4)" ... accept that it takes a lot more to become a good programmer than the first three steps and do not give up
08:41:19 <MarcelineVQ> jonge: btw I'd be inclined to use  stack sdist  to test things out before upload
08:41:21 <hyperisco> polarisiss, a data structure is a way of organising data, and there are numerous different ways to do that which benefit different purposes. For example, a list is a common data structure (in Haskell) which puts items in a stack, like a stack of pancakes
08:42:06 <jonge> sm MarcelineVQ the concrete case is that i uploaded my package some months before, it built fine, but if someone with a "too recent" resolver wants to install my package, it does'nt work. https://gist.github.com/tfc/e2c70b1f12aa16d1b9531284f3fe2ae1
08:42:13 <hyperisco> polarisiss, algorithms and data structures go hand-in-hand because algorithms will prescribe which data structures to use (or at least features the structure must have)
08:42:41 <jonge> sm MarcelineVQ i thought "stack install" would always look into the resolver version of the stack.yaml file and then find what is requested from the cabal file.
08:43:23 <jonge> sm MarcelineVQ looks like i'm wrong and i should fix this for the next stackage resolver. but i fear setting all package versions to >= would break the code if the source of the deps changes too much. right?
08:43:43 <sm> jonge: stack isn't seeing your latest relase, you need to specify the version stack install hamtsolo-1.0.1
08:44:27 <jonge> sm: yes, i bumped the versions and resolver and uploaded version 1.0.1, but that version will suffer from the same problem in a few months
08:44:45 <polarisiss> hyperisco:  its scaring me to learn programming
08:45:06 <jonge> as soon as there is lts-20 or so, it will not know any longer some of the dependency versions from the cabal file. i thought this would never happen becasue it would try to always use the resolver from the stack.yaml - but apparently that is not happening
08:45:09 <kadoban> jonge: If you do 'stack unpack hamtsolo && cd hamtsolo* && stack install' it'll probably work, if your stack.yaml was set up correctly. It's not using the resolver your package has configured, it's using the one from the machine and just installing your thing as a hackage package like usual
08:45:29 <hyperisco> polarisiss, because this is your first time programming you will be spending a lot of time learning how to think like a programmer, i.e. how to solve problems with programs. On top of that you will also be learning a programming language. So, in the beginning, it is usual for everything to be confusing, frustrating, and difficult, but you need to stick with it.
08:45:52 <jonge> kadoban: yes this is what i observed. for the latter: is there anything i can do if i want `stack install hamtsolo` to work with every future resolver version?
08:46:01 <MarcelineVQ> I'm not sure that stack considers if a package it's pulling from hackage has a stack.yaml   if you want to get around resolver versioning issues you may need your package included on stackage
08:46:27 <hyperisco> polarisiss, well the good news is that you really cannot break anything or hurt yourself. Have at it and have fun :) If you get too frustrated then take a break and try again later.
08:46:27 <kadoban> jonge: Probably agree to maintain your package on stackage, and fix any issues that come up down the road
08:46:43 <jonge> kadoban: is there any tutorial on best practices etc. for that?
08:46:59 <sm> jonge: cabal fails to install your 1.0.0 version because "(constraint from non-upgradeable package requires installed instance)". I think allowing a greater range of "base" versions will help, but I'm not sure why  exactly
08:47:08 <polarisiss> hyperisco:  ok Thank you
08:47:19 <kadoban> jonge: Probably, but I don't know where they are
08:47:27 <ph88_> what's the difference between a Grp and a Set ?
08:47:43 <sm> oh right, cabal can only install base 4.9 if I specify ghc 8.0. I would have expected stack to figure it out though
08:47:51 <jonge> kadoban: i thought `stack upload` uploads to hackage becasue stackage automatically pulls over the availability of hackage packages to stackage.
08:48:06 <polarisiss> wait what haskell very old langugae ? I never heard before and thinking its new language
08:48:13 <MarcelineVQ> jonge: only packages people have submitted
08:48:15 <kadoban> jonge: stackage only starts including any package if someone agrees to maintain it
08:48:36 <jonge> sm: i am afraid to use >= because in some future some of the dep-packages might change so much that they are not backwards-compatible any longer..
08:48:55 <ph88_> polarisiss, yes it's from the 80ties but it only picked up steam in the 00ties
08:48:58 <sanitymug> polarisiss: younger than say fortran, but it has couple of years under its belt…
08:49:21 <polarisiss> so it can be useful  after 020?
08:49:24 <polarisiss> 2020*
08:49:26 <jonge> kadoban: so how would that happen then? i mean, next to the `stack upload` command there is no `stack upload-to-stackage-and-agree-to-maintain` function
08:49:35 <ph88_> polarisiss, it's useful now
08:49:50 <MarcelineVQ> jonge: https://github.com/fpco/stackage/blob/master/MAINTAINERS.md#adding-a-package
08:50:00 <polarisiss> I mean what if no one uses it and supports it ?
08:50:09 <ph88_> then it dies
08:50:14 <ph88_> but so far that didn't happen
08:50:38 <sm> jonge: to avoid that problem, you add an upper bound (... && < pkg-UPPER)
08:51:05 <jonge> sm: what is a good rule for the upper bounds? >= x.y.* and < (x+1) ?
08:51:15 <sm> have a look at the cabal PVP page
08:51:39 <kadoban> polarisiss: Languages don't die, they certainly don't die anywhere near that quickly. And haskell isn't going anywhere, from the little data I've seen if anything it's growing a bit.
08:51:50 <sm> https://pvp.haskell.org/
08:51:52 <kadoban> polarisiss: Plus, everything you learn will help you with your next language anyway
08:52:21 <polarisiss> got enough motivated thankQ
08:52:23 <jonge> sm: i already had, and my guess ">= x.y.* and < (x+1)" comes from the definition that the first version number indicates breaking changes
08:52:35 <jonge> sm: i am however not sure if that's already it.
08:52:46 <sm> actually x.y is the major version
08:52:47 <hyperisco> polarisiss, Haskell was invented in 1990 and is still being actively extended. There is no obvious date ahead of us at which Haskell will be obsolete, but there are now more advanced languages (or maybe we shall say "differently advanced") which could eventually compete.
08:53:14 <sm> a change in x or y signals a breaking change
08:53:42 <hyperisco> polarisiss, in terms of programming language technology, Haskell is far ahead of languages such as Java, C#, or JavaScript
08:54:01 <jonge> sm: oh, my fault. so it should be ">= x.y.z.* and < x.(y+1)"
08:54:14 <sm> eg, yes
08:54:25 <dminuoso> hyperisco: So, when will we get dependent types? :P
08:54:38 <dmwit> % :!python -c print("hi")
08:54:38 <yahb> dmwit: /bin/sh: 1: Syntax error: "(" unexpected
08:54:45 <dmwit> % :!python -c 'print("hi")'
08:54:45 <yahb> dmwit: /bin/sh: 1: python: not found
08:54:49 <dmwit> Too bad. =)
08:54:56 <kadoban> dmwit: Hah
08:54:58 <hyperisco> dminuoso, soon™
08:55:07 <polarisiss> hyperisco:  heard java and c and which languages are more advanced than haskel
08:55:09 <ph88_> % :!ls
08:55:09 <yahb> ph88_: keks; luac.out; melt; test.lua
08:55:10 <jonge> sm: then i don't see how this would help, because stack complains that my cabal script wants base 4.9.*, but this resolver wants to use base-4.10.1.0 which looks like a breaking change...
08:55:25 <hyperisco> dminuoso, though I have suggested that DTs may mark the decline of Haskell
08:55:27 <ph88_> % :!cat test.lua
08:55:27 <yahb> ph88_: print"hi"
08:55:48 <jonge> sm it says (visible in my gist link) 4.9.1.0, but then this should actually fit into 4.9.* as my cabal file says
08:56:10 <dminuoso> hyperisco: Have you seen Stephanie Weinrichs talk some months ago?
08:56:38 <sm> jonge: I think stack install doesn't automatically try resolvers older than the current LTS
08:56:42 <dmwit> % readFile "test.lua" -- seems more idiomatic
08:56:42 <yahb> dmwit: "print\"hi\"\n"
08:56:44 <sm> stack solver would do that
08:56:54 <hyperisco> polarisiss, they are more popular and more widely used, but the theory behind the design of those languages (which is what I meant by "programming language technology") is not as advanced.
08:56:55 <sm> but this should "always" work: stack install hamtsolo-1.0.0 --resolver lts-9
08:57:05 <dminuoso> hyperisco: Specifically https://www.youtube.com/watch?v=wNa3MMbhwS4
08:57:07 <byorgey> dminuoso: (there is no 'n' in 'Weirich')
08:57:15 <jonge> sm: this looks pretty depressing becasue i can't have my users guess lts versions...
08:57:33 <kadoban> jonge: Suggest the unpack thing
08:57:46 <dminuoso> byorgey: Apologies, my German heritage forced that slip of the finger. :-)
08:57:49 <kadoban> Then all you have to do is make sure your stack.yaml is correct at time of publishing
08:57:50 <sm> give them the above install command, no guessing
08:57:55 <kadoban> Or that
08:57:59 <MarcelineVQ> if your package is added to stackage they don't need to guess <_<
08:58:02 <jonge> sm: stack says: "base-4.10.1.0 from stack configuration does not match ==4.9.* (latest matching version is 4.9.1.0) " - so why doesn't 4.9.1.0 fit into 4.9.* ?
08:58:22 <sm> it's not saying that
08:58:34 <sm> it's saying 4.10.1.0 doesn't fit 4.9.*
08:58:35 <kadoban> jonge: "latest matching" is what's in hackage, not what you told it to use via the resolver
08:58:56 <ph88_> oh i've seen that one dminuoso
08:59:09 <byorgey> dminuoso: no worries. =)
08:59:18 <hyperisco> dminuoso, she is one of the principal researchers for DT in Haskell yes? know of her but did not watch the talk
08:59:36 <jonge> sm kadoban: what does "latest matching" version then mean? it looks to me that this is the "latest available" that could be used.
09:00:18 <kadoban> jonge: It is the latest one in the range it's supposed to be that comes from hackage. It won't be used though, because you told it not to (via the resolver)
09:00:28 <dminuoso> hyperisco: Also some languages like C++ make up for lack of technology by complexity. Using their template system competently requires some great care. I was so baffled when I could express things so simply in Haskell compared to what I would have done otherwise.
09:00:28 <jonge> if builds break so easily after an LTS update, i wonder what the whole point is.
09:00:38 <ph88_> http://tinyurl.com/haskcar
09:00:51 <ph88_> can we put that in the channel topic ?
09:01:02 <sm> actually, via the hamtsolo-1.0.1 package deps, which specify base-4.10
09:01:03 <hyperisco> dminuoso, the problem I foresee is that the more features Haskell adds the less optimal it becomes because of legacy. i.e. you cannot start over and do it right; you have to compromise with what exists.
09:01:43 <polarisiss> https://www.tiobe.com/tiobe-index/  haskell 44 rank
09:01:46 <kadoban> jonge: The point is to be able to build the same thing for all eternity. But this is not how you get those reproduceable builds, the stack unpack thing is one way
09:01:47 <sm> jonge: you're overreacting, you just need to learn a bit more about how it works
09:01:51 <MarcelineVQ> hyperisco: deprecate all the things, move fast, break stuff, burn the bridges and don't look back
09:01:57 <hyperisco> dminuoso, so eventually I see Haskell in a spot where it does many things, but there will be competing languages which also do these things and did so from their conception. In that world, Haskell as a language looks less appealing.
09:02:24 <hyperisco> dminuoso, but it will live for a long time still for the reason other languages do. It will still be the most known, the most used, have the most libraries, etc.
09:02:28 <jonge> sm sorry i did not mean to look overreacting. :) i just want to learn what i need to do now so that "stack install mypackage" does forever and ever work, no matter what resolver the user has currently installed.
09:02:59 <kadoban> jonge: Only way to get that exact thing to always work is to maintain your package on stackage
09:03:15 <kadoban> IMO you should pick an easier goal, unless you really want to maintain it
09:03:30 <hyperisco> dminuoso, in my opinion we already see the beginnings of this with Idris for DTs and PureScript for JavaScript interop.
09:03:32 <sm> "stack install hamtsolo-VER --resolver lts-RESOLVER" will keep working. Or, add you package to some stackage snapshot and then "stack install hamtsolo-VER" should keep working.
09:04:04 <jonge> sm: as far as i understood, stackage build the packages and offers the users the service to just dload the binary, right?
09:04:07 <sm> (or "stack install hamtsolo" to get the latest version in a stackage resolver)
09:04:45 <jonge> sm: so as soon as i added the package to the stackage servers, `stack install mypackage` defaults to the stackage-maintained version as soon as the stackage servers picked that up?
09:04:57 <sm> correct
09:05:04 <MarcelineVQ> no stackage is source
09:05:53 <kadoban> jonge: No, but if you're maintaining your package on stackage, it'll always be working with whatever resolver going forward. Because you'll be making sure that's true (fixing any problems that come up)
09:05:54 <jonge> sm: thank you. i will do that then.
09:06:07 <MarcelineVQ> stackage checks if packages build together, but what you fetch from a resolver you still build on your computer
09:06:20 <jonge> kadoban: yes that is what i want. to guarantee "this is the resolver for which i made it working, please build it with that one."
09:06:29 <hyperisco> dminuoso, on the flip side, if Haskell does not evolve at all then it become outmoded even more quickly because you will *have* to change to use the latest and greatest. There is already substantial pressure for DTs.
09:06:38 <kadoban> jonge: That's not what adding to stackage will do.
09:06:48 <kadoban> jonge: For that you should just suggest a different install command.
09:06:56 <jonge> kadoban: so then i am confused again.
09:07:01 <hyperisco> the lesson is that all things die :P
09:07:23 <MarcelineVQ> haskell is dead, long live haskell, the eternally new
09:07:30 <jonge> kadoban: so it's not really possible to provide a possibility to have `stack install x` working forever?
09:07:50 <Clint> does x have zero dependencies?
09:07:50 <sm> just add it to stackage, stackage was created for your use case
09:07:53 <MarcelineVQ> stack install x  depends on what resolver the person typing the command has in scope
09:07:53 <kadoban> jonge: There is, it involves agree to maintain it, like I said. And also technically living forever I guess, but whatever.
09:08:35 <MarcelineVQ> so if you want that to work forever, starting from now, you'd put your package on stackage
09:08:55 <MarcelineVQ> sorry that I keep echoing you kadoban hehe
09:09:02 <kadoban> Heh, it's alright
09:09:49 <jonge> kadoban: ok, 30 seconds before i thought i can agree to maintain it and then the stackage server would pick up the package code with the TLS version of my stack.yaml choice and then build it?
09:10:38 <sm> your stack.yaml is used only when someone downloads your source and runs stack in that directory
09:10:44 <kadoban> jonge: You can agree to maintain it, thereby guaranteeing that it'll build with any resolver going forward *because if it doesn't, you agreed to fix it*. You can't force everyone to always use resolver X forever to build your thing, that's not how it works. I mean you can tell people a specific command to use.
09:11:08 <kadoban> Telling people a command to use would be my suggested course of action, if that wasn't clear.
09:11:29 <kadoban> Unless you really want to maintain the thing, which would be a benefit to the community for sure if you're willing.
09:11:56 <jonge> kadoban sm: ok, thanks for clarifying that. another question: is there some kind of flag `stack install somepackage --use-resolver-from-package-stack.yaml`?
09:12:25 <jonge> apparently --help does not list something like that
09:12:39 <sm> just --resolver
09:12:42 <kadoban> jonge: I don't think so. It'd be nice if there was really, I wonder if there's a PR about that
09:12:51 <kadoban> Or an issue I mean
09:13:05 <jonge> hmhm ok, thanks. i will first do some homework and learn more about stackage-package-maintenance.
09:13:26 <sm> it's pretty easy. https://www.stackage.org/ -> Add your maintained packages to stackage
09:13:31 <MarcelineVQ> hmm, isn't there? lemme see..   --stack-yaml  ?
09:13:37 <sm> basically add a line to their build-constraints.yaml
09:14:40 <MarcelineVQ> --stack-yaml is redudant though, if you're running  stack install  from the project directory anyway iirc
09:14:51 <sm> oh right MarcelineVQ. You have to run stack --help as well as stack install --help
09:14:55 <univhelp> can someone help me figure out what ((let no n = name; in no))"No" does exactly?
09:15:08 <univhelp> like somehow it doesnt change the name variable, just shows whatever is in name
09:16:01 <cocreature> univhelp: it locally defines a function called "no" which takes one argument "n" and always returns "name". this function is then applied to "No"
09:16:16 <cocreature> it’s equivalent to (\n -> name) "No"
09:16:55 <univhelp> what does the ; in no accomplish?
09:17:37 <ph88_> univhelp, the language construct is    let  ....    in  ....   i think you need the ; if you don't put let and in on separate lines
09:17:38 <cocreature> nothing, it’s just a replacement for a line break but in this case it’s not even necessary
09:17:52 <univhelp> ok thanks
09:19:07 <MarcelineVQ> hmm what does your actual assignment look like? the way your questions are written is quite odd, it could be good to know if they're being transcribed correctly so you're getting a good response
09:28:46 <dmwit> > ((let no n = undefined; in no)) "No"
09:28:49 <lambdabot>  *Exception: Prelude.undefined
09:29:13 <dmwit> > ((let no n = undefined;; in no)) "No"
09:29:16 <lambdabot>  *Exception: Prelude.undefined
09:29:36 <dmwit> Huh. I admit to being a bit surprised. I did not realize empty declarations were allowed.
09:31:27 <glguy> > do do ;; do ;; 1 ;;
09:31:30 <lambdabot>  1
09:31:43 <glguy> (not the same thing, just making some noise)
09:31:46 <dmwit> There it is in the Report, though, clear as day: gendecl -> vars :: [context =>] type (type signature) | fixity [integer] ops (fixity declaration) | (empty declaration)
09:34:13 <glguy> > let in 10
09:34:17 <lambdabot>  10
09:34:45 <dmwit> > let in do let let do 10
09:34:49 <lambdabot>  <hint>:1:24: error:
09:34:49 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:35:15 <glguy> > do let in do 10
09:35:19 <lambdabot>  10
09:35:19 <dminuoso> Lets say I have some tree, and I want to update a field but I dont know where the field is. I just have a criterion to identify a given node. Is the monad interface the right interface to pick to "update" that particular node at an unknown position?
09:35:25 <dmwit> > let {} in do { let {}; let {}; do { 10 } }
09:35:32 <lambdabot>  mueval-core: Time limit exceeded
09:35:46 <dmwit> Yes, I can see how that would be a difficult computation to perform.
09:36:07 <glguy> dminuoso: Functor might be more specific
09:36:28 <glguy> > fmap (\x -> if even x then 0 else x) [1..6]
09:36:32 <lambdabot>  [1,0,3,0,5,0]
09:36:42 <ertes-w> dminuoso: do you recognise the field to update by value or by meta-information (like a key)?
09:43:41 <hyperisco> MarcelineVQ, apparently univhelp's prof likes constant functions
09:46:25 <[exa]> is there a type that would be both Floating, Integral, and useful for something?
09:46:34 <MarcelineVQ> for some exercises that's a good demonstration, it's the syntax that's making me wonder
09:48:19 <smurfendrek123> Is there something like case of, but where i can say if x is one of these three things, do this, else do something else?
09:48:39 <smurfendrek123> i know i can do this with an if else statement, but that seems somewhat unhaskell like
09:49:18 <amalloy> smurfendrek123: you can use a where clause
09:49:45 <MarcelineVQ> smurfendrek123: see if this fits at all  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#multi-way-if-expressions
09:49:46 <ertes-w> [exa]: if the Floating functions can somehow be generalised to make sense for integers, then yeah
09:49:47 <hyperisco> [exa], I haven't seen any complete laws for those classes, so I think the only argument is what the spirit of them is, and the spirit of Floating disagrees with the spirit of Integral.
09:49:59 <smurfendrek123> thanks, but is there anything more compact? It seems weird to write a helper function to replace an if statement
09:50:07 <ertes-w> [exa]: i can't think of examples though…  Integral pretty much means "subset of the integers"
09:50:11 <[exa]> ertes-w hyperisco: thanks
09:50:27 <amalloy> what helper function?
09:50:27 <ertes-w> [exa]: topological spaces come to mind
09:50:29 <[exa]> anyway I just realized there's an example at hand in C :]
09:50:47 <[exa]> and generally auto-casting numbers in any language
09:51:11 <amalloy> foo x = case x of {1 -> simple; 2 -> simple; 3 -> simple; other -> 10} where simple = 5 * x
09:51:12 <[exa]> (but maybe that's not useful either)
09:51:13 <smurfendrek123> amalloy: well a where is basically a helper function in this case
09:51:23 <ertes-w> [exa]: C is just magically inserting realToFrac, truncate, etc…  i wouldn't count that as a real example =)
09:51:30 <smurfendrek123> amalloy: yea but that has you copying simple 3 times, which is not very compact
09:51:36 <ertes-w> it's not an example of *one* number type that is both Integral and Floating
09:52:09 <smurfendrek123> I guess i'll do a where to check the condition
09:52:11 <smurfendrek123> thanks
09:52:20 <amalloy> smurfendrek123: do you have a specific example of what three patterns you want to match x against? if they are actually different patterns there is no way to avoid repeating a single token three times
09:52:33 <[exa]> ertes-w: yeah, but you can say that the 'float' there is both integral and floating because it posesses both interfaces
09:52:35 <amalloy> but if they are the same pattern with different guard conditions you can do it more concisely
09:52:37 <[exa]> good point though
09:52:50 <ertes-w> [exa]: you may find it interesting that the only real problem is toInteger…  all other functions work fine for floating-point types
09:53:03 <smurfendrek123> Yes, if inputstring == "ICT" || "HR" || "Cleaning" then action else ask again
09:53:29 <hyperisco> :t (||)
09:53:31 <lambdabot> Bool -> Bool -> Bool
09:53:39 <smurfendrek123> no it's pseudocode
09:53:41 <smurfendrek123> sorry
09:53:56 <smurfendrek123> bad pseudocode
09:54:03 <amalloy> then i would use an if, or a guard clause depending on context, which checks (x `elem` ["ICT"...])
09:54:19 <ertes-w> :t divMod'
09:54:19 <hyperisco> if inputstring `elemOf` ["ICT","HR","Cleaning"] then …
09:54:20 <smurfendrek123> yea, so using an if is not looked down upon?
09:54:21 <lambdabot> (Real a, Integral b) => a -> a -> (b, a)
09:54:31 <amalloy> :t elemOf
09:54:33 <lambdabot> Eq a => Getting Any s a -> a -> s -> Bool
09:54:35 <hyperisco> that's a slow way to do it
09:55:04 <hyperisco> GHC doesn't like to reduce enough to get rid of the list
09:55:06 <ertes-w> > divMod' (2*pi + 1.25) pi
09:55:10 <lambdabot>  (2,1.25)
09:55:15 <smurfendrek123> can i replace that if with guards without using where?
09:55:15 <[exa]> smurfendrek123: if you can't find any shorter/faster code, go for it :]
09:55:20 <amalloy> hyperisco: is `elemOf` better than `elem` there?
09:55:22 <ertes-w> [exa]: ^ (from Data.Fixed)
09:55:28 <amalloy> it doesn't even look like it has the right number of arguments
09:55:41 <[exa]> ertes-w: interesting, thanks!
09:55:46 <hyperisco> I thought it was called elemOf in Prelude, w/e
09:56:41 <hyperisco> and unfortunately OverloadedLists won't help you either… hrm… I know! my foldapp package! :)
09:59:07 <amalloy> smurfendrek123: as i mentioned earlier, it depends on context. you need to be in some kind of pattern-match already. for example, if you were right at the top level of a function, it would be easy to use a guard: foo x | x `elem` blah = foo; otherwise = bar
09:59:36 <amalloy> but if you're already in the middle of a function, you need an if/else, or a new pattern-matching context on which to hang that guard
09:59:45 <hyperisco> huh why didn't I put the dual of any in there…
10:02:24 <hyperisco> well, in the meantime,  let elemIn e = foldrApp (\x a -> x == e || a) False in elemIn "baz" "foo" "bar" "baz" "qux"
10:02:33 <hyperisco> True
10:02:55 <hyperisco> well, probably need a type annotation in there, but that's the gist of it ;)
10:03:14 <hyperisco> and it is perfectly efficient
10:07:24 <hyperisco> ugh, have to bump the base version
10:08:15 <hyperisco> I think that accounts for 95% of package maintenance.
10:08:34 <Clint> you might be doing it wrong
10:08:34 <Ternary> Can I put a class constraint on a phantom type with a GADT?
10:08:45 <hyperisco> and what do you do?
10:09:05 <Clint> base > 4 & <5 ?
10:09:14 <hyperisco> Ternary, you do not usually put constraints on the data type definition, but rather where it is used
10:09:42 <hyperisco> Clint, the second number marks possibly breaking changes
10:10:24 <Clint> hyperisco: i don't see your point
10:10:45 <hyperisco> you have allowed 4.* without testing 4.11 and beyond
10:11:04 <Clint> that's true, but i am within the upper-bounds-are-stupid-and-annoying camp
10:11:09 <Ternary> hyperisco: I know I can do that, but I would prefer to avoid having to put the Typeable constrain on a large number of functions
10:11:12 <hyperisco> then why did you put <5 ?
10:11:21 <Clint> iirc cabal complains otherwise
10:11:29 <hyperisco> why 5?
10:11:45 <Clint> good question, i may have to experiment
10:12:45 <hyperisco> I may be on board with that for most of my stuff too because it is annoying finding out months after the fact I needed to bump a base version
10:13:32 <hyperisco> failure to satisfy dependencies is not all that different from failure to compile…
10:16:24 <hyperisco> Clint, it would be less stupid if the package manager and compiler was able to manage multiple installed versions…
10:16:51 <hyperisco> I don't know how package management ever got so confused
10:17:03 <hyperisco> treat a different version of a package as a different package…
10:17:57 <hyperisco> but apparently base is super special and only works with a matching ghc version
10:19:30 <MarcelineVQ> Ternary: yes you can.      hyperisco: the issue with constraints on haskell98 datatypes is they make it so you require that constraint to pattern match, but gadt style declarations are different, pattern matching with them provides the context   more info here  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#declaring-data-types-with-explicit-constructor-signatures
10:21:03 <hyperisco> MarcelineVQ, I do not disagree but that is substantially different exactly in the way you said
10:22:26 <hyperisco> think of what Typeable actually gives you… it gives you typeOf
10:24:12 <MarcelineVQ> you're saying Typeable itself is the issue here?
10:25:16 <geekosaur> hyperisco, re base, have you ever noticed that every time you upgrade perl or python or ruby, you usually have to upgrade any C-based plugins? that is the exact same thing.
10:25:24 <geekosaur> (perl XS modules, etc.)
10:25:34 <hyperisco> depends on what you're doing. You might just want to keep a TypeRep.
10:26:37 <hyperisco> though I wonder if GHC is smart enough to elide storing the dict because it is inferred from the type param…
10:28:41 <hyperisco> geekosaur, I was describing a deficiency with having different versions of a package be different packages. i.e. it doesn't help you with base unless you also want to install multiple versions of ghc…
10:36:23 <hyperisco> then also consider you *have* to pattern match to get  Typeable a  in context
10:36:47 <hyperisco> so where do you want to take your lumps?
10:38:55 <MarcelineVQ> I think I understand, playing with it in ghci at the moment, my earlier tests were too simple to run into problems.
10:39:45 <MarcelineVQ> missing idris's "tell me what's in scope right here" feature just now hehe
10:39:53 <hyperisco> use a hole
10:40:46 <MarcelineVQ> oh yeah that has a relevant bindings list
10:41:22 <hyperisco> can't wait for an article titled "Programming With Holes"
10:41:57 <hyperisco> or maybe "Holey Programming"
10:41:58 <MarcelineVQ> hole driven development
10:42:36 <hyperisco> I know! "Diving Into Holes"
10:44:01 <geekosaur> the hole story
10:44:06 * Clint twitches.
10:45:07 <ph88> what's the difference between Grp and Set ?
10:45:29 <hyperisco> where is Grp defined?
10:45:37 <amalloy> i think there already are articles about "hole driven development"
10:45:47 <sqooq> I rebinded a bunch of emacs keystrokes and now it's tolerable
10:45:50 <MarcelineVQ> amalloy: a few in fact :>
10:45:51 <sqooq> what's the haskell mode people tend to use
10:45:53 <sqooq> Intero?
10:45:55 <sqooq> Dante?
10:46:10 <ph88> hyperisco, i don't know where it's defined, it's described here https://en.wikibooks.org/wiki/Haskell/Category_theory#Introduction_to_categories
10:46:45 <MarcelineVQ> sqooq: overwhelmingly just haskell-mode, if the %'s in this room are taken for gospel
10:46:45 <hyperisco> oh, so groups i.e. the algebraic structure
10:46:57 <ph88> i don't know ?
10:46:58 <Uniaika> I use Intero (but that's with neovim)
10:47:03 <hyperisco> I am telling you
10:47:53 <ph88> what is it ?
10:48:20 <hyperisco> https://en.wikipedia.org/wiki/Group_(mathematics)
11:05:04 <ph88> hyperisco, is it the inverse element that makes a group a group? do you know of a set which doesn't have an inverse element ?
11:06:03 <hyperisco> ph88, your latter question doesn't make sense to me. Set theory is just something else… groups are usually defined on set theory, though.
11:06:34 <hyperisco> ph88, what makes a group a group is the presence of all things that define a group, and inverse elements are one of the things
11:06:39 <[exa]> ph88: it's the restriction on its morphisms that must conserve the binary operation
11:07:21 <jello_raptor-rem> So, I'm trying to build a library for working with propagator networks, and it looks like I need constrained monads to create a genuinely safe interface. Does anyone here have advice on how I should construct the library for it to be as generally useful as possible? particular constrained-monad libraries, just make functions that can replace bind and the like, use some sort of alternate prelude, etc..?
11:07:26 <ph88> what's a binary operation ?
11:08:00 <[exa]> ph88: ok now you're sound kindof like the chatbot :] do you know what's the definition of group as an algebraic object?
11:08:00 <ph88> let me read wikipedia on that as well
11:08:07 <ph88> no
11:08:26 <[exa]> ok, let's read the definition
11:08:26 <geekosaur> it's going to be a long day, I think >.>
11:08:31 <kadoban> ph88: A function of type SxS -> S, or in haskell syntax I guess that'd be  :: S -> S -> S
11:08:48 <ph88> ye ok i got binary operation
11:08:51 <[exa]> ph88: distinction from plain sets should be observable right after that
11:08:55 <jello_raptor-rem> In particular I suspect edwardk will have opinions on the above.
11:09:27 <metahumor> not just binary operation, its an "endo" operation in that the output is a valid input to the operation, and all outputs and inputs are in the group
11:09:36 <geekosaur> ph88, think of it this way. have you seen the difference between Monoid and Semigroup in Haskell?
11:09:38 <ph88> if i have a set of all integers, it could also be a group .. just trying to picture a good example for a set that doesn't have this
11:09:52 <geekosaur> one of the differences between Semigroup and groups is that semigroups don't need an inverse.
11:09:58 <ph88> geekosaur, i haven't seen semigroup .. but i know it doesn't require mempty
11:10:04 <metahumor> ph88: when you say "it could be a group", you don't just define the set of elements, you also have to specify what your operation is
11:10:05 <geekosaur> there is one particular common monoid in Haskell that is also a semigroup, but is nbot a group
11:10:24 <metahumor> geekosaur: there are many =)
11:10:37 <[exa]> ph88: set {...,-4,-2,0,2,4,...} together with (+), unary - and 0 (as identity) forms a group
11:10:38 <geekosaur> ok, yes, interferently pedantic time
11:10:41 <geekosaur> never mind
11:10:51 <geekosaur> let's confuse things even more instead of trying to explain,t hat always works@
11:10:58 <[exa]> ph88: if you add {1} to that set, it's no longer a group because 1+2 is not defined in it
11:11:01 <metahumor> geekosaur: but i'm interested in which one you're thinking of
11:11:01 <ph88> so a group is a set with some operations ?
11:11:12 <Tehnix> Hmm, is there any way to serialize a function, or extract the name at runtime, with the goal of sending it over the wire?
11:11:16 <geekosaur> you inserted your confusion just at the right point to stop me
11:11:17 <[exa]> algebraically yes
11:11:30 <[exa]> geekosaur: sorry :]
11:11:52 <kadoban> ph88: It's a set with an operation that together follow certain rules, yes
11:12:06 <ph88> ah ok
11:12:07 <ph88> thanks guys
11:12:20 <metahumor> a group is defined by: 1) the set of elements (possibly infinite), 2) the group operation, 3) the identity (unique)
11:12:24 <kadoban> (and then from those rules you get quite a few other interesting properties)
11:12:34 <geekosaur> let us take lists. lists are semigroups: they have a binary operator (in Haskell, (++)). they are also monoids on that operator: there is a value [] that can be used with the operator to not change them
11:12:50 <hyperisco> geekosaur, I don't think "interferently" is a word… :P
11:12:53 <geekosaur> now: is there anything you can (++) to a list that will make it *shorter*?
11:12:54 * [exa] envisions inverse lists
11:13:18 <ph88> don't think so
11:13:20 <metahumor> 4) the inverse operation
11:13:26 <MarcWeber> Is it possible to push game state to 100.000 clients using warp ?
11:13:26 <geekosaur> this is related to the idea of inverses
11:13:36 <hyperisco> a negative list… lets think now
11:13:46 <geekosaur> for intergers, if you have 1 you also have -1, and adding -1 makes the number smaller
11:13:59 <albatross_> is there anyway I can filter out a list of item out of a list?
11:14:00 <[exa]> MarcWeber: what game tho
11:14:07 <jello_raptor-rem> I'd like to have a monadic interface for writing upwards closed functions (for things like rewrite-rules on the propagator networks) but it's looking like what I need is a FreeT over a Monad for upwards closed functions/lattice elements, but that latter is a constrained monad.
11:14:13 <jello_raptor-rem> whoops
11:14:16 <ph88> albatross_, maybe try   filter
11:14:20 <geekosaur> lists with (++), you can't do this. which means lists and (++) do not make a group, but they do make a semigroup
11:14:23 <jello_raptor-rem> that was meant for a pm
11:14:36 <MarcWeber> Game state to be pushed to client is only about 5K times x/y vx/vy values (thus 4 numbers)
11:14:40 <ph88> so a group is strongs than a semigroup
11:14:47 <albatross_> ph88 filter lets you filter one item out of a list, I want to filter out a list of items out of a list
11:14:50 <MarcWeber> its only about dots on a surface colliding and dropping through holes.
11:14:54 <geekosaur> ph88, in some ways
11:15:03 <geekosaur> "stronger" is not a linear concept
11:15:24 <MarcWeber> So 100.000 / 64 cores would yield 15.000 users / core which might be doable, but no idea about networking bottle neck.
11:15:25 <hyperisco> albatross_, so, change your filter predicate
11:15:26 <geekosaur> Applicative is stronger than Monad in some ways, weaker in others. semigroups are stronger than groups in some ways, weaker in others
11:15:35 <geekosaur> it depends on what you are trying to do
11:15:50 <ph88> albatross_,   filter (\x -> x `elem` [list])    ?
11:16:31 <ph88> geekosaur, you mean their utility ?
11:16:48 <[exa]> MarcWeber: you will probably have more synchronization issues than computing power trouble
11:17:08 <ph88> MarcWeber, not sure if haskell is the right language for what you are trying to do
11:17:12 <geekosaur> "stronger" is relative to something
11:17:17 <hyperisco> on the totem of generality, group is lower than semigroup
11:17:19 <geekosaur> you ahve to say what something
11:17:31 <ph88> more imposed restrictions
11:17:44 <[exa]> MarcWeber: but if the game state is static and you do some kernel tuning, why not
11:17:48 <hyperisco> on the totem of features, semigroup is lower than group
11:18:31 <MarcWeber> Can I sent 23 GB /sec on 64 core servers?
11:18:45 <hyperisco> a difference of whether you want to maximise what you give or minimise what you take
11:18:57 <MarcWeber> I can use compression, so it might be doable..
11:19:01 <ph88> MarcWeber, what are your hardware specs?
11:19:06 <ph88> which specific cpu
11:19:08 <MarcWeber> Whatever works.
11:19:18 <MarcWeber> I thought about using  64 core amazon v-machine.
11:19:22 <MarcWeber> Not knowing it any better.
11:19:30 <ph88> well how much can you put over the bus to your NIC ?
11:19:34 <[exa]> MarcWeber: do you have a network interface that can do 23GB/sec?
11:19:53 <[exa]> (compression will only help you marginally)
11:20:01 <MarcWeber> Most will not do it - but those machines have multiple network interfaces.
11:20:27 <albatross_> ph88, filter (\x -> x `elem` xs) still won't let me filter out say [1,2,3] out of [1,2,3,4,5] ;/
11:21:05 <hyperisco> albatross_, oh, so you're trying to remove subsequences, okay
11:21:34 <MarcWeber> [exa]: gzipping will reduce it by factor 300 .. So it should be doable.
11:21:52 <[exa]> isn't the game state empty?
11:21:57 <hyperisco> that feels like a fun problem… lets see
11:22:10 <ph88> MarcWeber, which cpu actually has 64 cores ... ?
11:22:36 <MarcWeber> https://aws.amazon.com/de/ec2/instance-types/ m4.xlarge
11:23:12 <hydraz> ph88: some xeon phis do
11:23:22 <ph88> ok so for example https://ark.intel.com/Search/FeatureFilter?productType=processors&CoreCountMin=64
11:23:27 <[exa]> MarcWeber: anyway, you'll hit a wall within linux, then you'll hit a wall in the polling implementation of warp, and then you'll hit a wall in amazon :D
11:23:37 <ph88> 1.7 Ghz okay
11:24:01 <[exa]> MarcWeber: so my best advice is to plan for horizontal scaling as soon as possible.
11:26:24 <MarcWeber> [exa]: Which polling wall do you talk about? Can't I make 64 cores push data to clients by websockets?
11:26:28 <MarcWeber> Or UDP eventually?
11:27:14 <ph88> MarcWeber, the intel xeon phi 7290 can do 35 460 MB/s on PCI-express
11:27:36 <ph88> on 36 pci-express lane
11:27:46 <[exa]> MarcWeber: the internal connection management in warp
11:28:53 <Junior__> Can anyone tell me why I am receiving the error, "parse error on input deriving"?
11:28:55 <Junior__> http://lpaste.net/361738
11:29:02 <[exa]> MarcWeber: this is a related reading about high-connection-count problems: http://libev.schmorp.de/bench.html
11:29:04 <ph88> i think this setup is mainly useful when clients need to interact with each other .. otherwise they can just stay on their own server
11:30:48 <ph88> Junior__, maybe remove  deriving
11:31:27 <Junior__> woodson: What is wrong with deriving Show?
11:33:39 <lyxia> Junior__: it's probably not syntax recognized by persistent
11:34:56 <Junior__> lyxia: I was just following the code snippet on https://www.yesodweb.com/book/persistent.  What is the difference there?
11:34:57 <geekosaur> looks like it's supposed to be
11:35:48 <geekosaur> however I note that there is no indentation in the example
11:36:15 <kadoban> Yeah, Person and that other one are all the way to the left in the example
11:36:15 <geekosaur> that is, Person and BlogPost both start at the start of the line, not indented 2 spaces like you have them
11:36:24 <geekosaur> but I don't know persistent
11:36:28 <kadoban> Nice catch, I didn't see that
11:36:56 <Gurkenglas> Why don't we have a way to get rid of the brackets in a + b (c d)?
11:37:17 <geekosaur> why should we?
11:37:35 <Gurkenglas> Because the c d term keeps being huge in my code
11:37:38 <geekosaur> what magic do you think should exist there, and why do you think it doesn't limit other things?
11:37:40 <glguy> a + do b $ c d
11:37:57 <Gurkenglas> Ooh, nice.
11:37:58 <kadoban> glguy: xD ugh
11:38:16 <kadoban> That is clever though
11:38:20 <Gurkenglas> I was thinking of a + b § c d, where § has high precedence to the left and low to the right
11:38:22 <glguy> > a + do (f :: Expr -> Expr) $ g b
11:38:25 <lambdabot>  a + f (g b)
11:39:22 <hyperisco> hmm… trying to realise the fix point  drop n [] = []  but not sure how
11:39:38 <geekosaur> there's no way to specify that last in Haskell. and I'm not sure we need something even more confusing than newcomers find ($) to be
11:39:53 <glguy> terrible code isn't going to write itself
11:40:21 <hyperisco> for example, if I repeat  drop 1  on a list, then eventually (if the list is finite) I hit the fix point
11:40:58 <hydraz> jjjj
11:41:00 <lyxia> hyperisco: test for equality
11:41:04 <hydraz> damn it, I keep missing the meta key
11:41:18 <hydraz> sorry :/
11:41:25 <Gurkenglas> afaic $ is meant to achieve "Replace the line 'a b $ c d' by 'a b (c d)'", and fails to achieve that when the left part contains operators
11:41:37 <hyperisco> but my only thought is to rewrite it to something like  drop 0 _ = Nothing; drop _ [] = Nothing; drop n (_:xs) = drop (n - 1) xs
11:41:48 <Saizan> Gurkenglas: (a +) . b $ c d
11:42:13 <Gurkenglas> Yes, that's what I usually use in that situation, but I like the do variant more
11:42:24 <hyperisco> hang on, we didn't get anything out other than Nothing :P
11:43:03 * shapr hops randomly
11:44:28 <Junior__> lyxia: I removed the deriving Show, can I get an error on line 25.  http://lpaste.net/361738.  See anything wrong there?
11:44:37 * shapr is deriving Snow in Atlanta
11:44:43 <hyperisco> well the idea was we'd signify when the output is the same as the input
11:45:45 <hyperisco> drop n (_:xs) = Just (drop (n - 1), xs)   I suppose and now this looks like StateT should be folded in
11:46:11 <metahumor> Junior__: i could be wrong, but the indentation of the closing quasiquote bracket might matter
11:48:29 <Junior__> metahuor: I'm following the code snippet on https://www.yesodweb.com/book/persistent.  Comparing my code don't see the difference.  Can you spot anything different there?
11:49:21 <geekosaur> as two people have said so far, indentation inaide the quasiquote
11:49:24 <geekosaur> *inside
11:49:37 <geekosaur> you indented it all two spaces. the example is *not* so indented
11:50:08 <prysm> Hey does (1 2) have any meaning in haskell. A function that takes Int -> Int and we use (1 2) as a parameter gives a type error but why
11:50:16 <prysm> Does it literally have 0 meaning whatsoever
11:50:37 <metahumor> prysm: ?? can you be more explicit about the function?
11:50:39 <hydraz> % :t (1 2)
11:50:39 <yahb> hydraz: (Num t1, Num (t1 -> t2)) => t2
11:51:01 <metahumor> prysm: or ar you asking if you could have some instance of the type hydraz just showed
11:51:12 <geekosaur> prysm, are you trying to pass two parameters by saying foo (1 2) instead of (foo 1 2) ?
11:51:30 <kadoban> prysm: It has meaning, but it's fairly unlikely to actually be what you mean.
11:51:33 <prysm> yeah just wondering if there is any instance of the type
11:51:40 <geekosaur> "(1 2)" can have meaning if there is a Num instance for functions in scope with the right type
11:51:55 <geekosaur> by default there is not, but there are such instances in existence
11:52:13 <hydraz> that sounds horrible
11:52:16 <prysm> interesting thank you!
11:52:36 <geekosaur> (basically Num lifted over Applicative)
11:52:51 <hydraz> ok, that sounds less horrible
11:53:22 <metahumor> still ripe for misuse, not obvious that a numerical literal is a function
11:53:26 <lyxia> Junior__: sorry I'm not familiar with persistent
11:53:31 <prysm> the exact function was just some multiplication and addition between two variables and it was k :: Int -> Int -> Int, we had to evaluate the output and i was curious to know what the meaning of k (1 2) which gave me a tpye error on execution
11:53:37 <geekosaur> yes, it can be very confusing. but it does have its uses occasionally
11:53:46 <metahumor> prysm: Ah! you just say "k 1 2"
11:54:08 <prysm> k 1 2 worked correctly as did (k 1 2) but it was more just a question as to why didn't (1 2) work
11:54:12 <metahumor> prysm: because "k 1" is of type "Int -> Int"
11:54:34 <metahumor> all functions are unary, you can think of "k :: Int -> (Int -> Int)"
11:55:14 <prysm> metahumor: I see, thank you!
11:55:25 <Welkin> is anyone running haskell on vintage hardware? like from the 1980's or earlier?
11:55:28 <metahumor> let's say that "(1 2)" did give some result
11:55:59 <metahumor> then "k (1 2)" would still be wrong
11:56:29 <smurfendrek123> Hello, how do i use case with getting input in a do block? I have tried this: https://paste.fedoraproject.org/paste/vodTmhIVgXnRVD-tVma2Zg/raw but it says last statement in a do block must be an expression
11:57:12 <kadoban> Welkin: I doubt it. Maybe using haskell to generate other code, but sure seems like it'd be hard to even run most haskell code on machines with so little RAM, let alone compile them successfully.
11:57:54 <Welkin> Junior__: your code is not the same as in the book
11:58:10 <metahumor> smurfendrek123: what is the type of "getDepartment"?
11:58:18 <Welkin> Junior__: `share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|` should be all on one line
11:58:44 <Welkin> kadoban: it would be cool to see if anyone got it working though
11:58:49 <smurfendrek123> metahumor: getDepartment :: IO () -> Department
11:59:08 <smurfendrek123> but that doesn't really seem right to me, but i don't really know what else to put
11:59:14 <Welkin> last night I found out about a whole subculture of people who run on old thinkpads from 7 years ago
11:59:18 <metahumor> I can't imagine how it would be that type
11:59:31 <Welkin> lol smurfendrek123
11:59:37 <smurfendrek123> :p
11:59:39 <Junior__> Welkin: I get the same error with `share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|` in one line.  Anything else you see different?
11:59:40 <kadoban> smurfendrek123: Looks like an expression to me. Oh, yeah that type is funky, though I'm not sure how the type would make that not an expression.
11:59:42 <Welkin> that breaks the most important rule of haskell
11:59:44 <metahumor> maybe "IO () -> IO Department", or "IO Department", or "Department"
11:59:44 <Welkin> you cannot escape IO
12:00:01 <Welkin> Junior__: what is your error?
12:00:16 <kadoban> Probably   IO Department, yeah.
12:00:16 <metahumor> in my first case, you would then have it not be an expression, in the second case, you wouldn't need "return", in the third case, it should work
12:00:43 <smurfendrek123> doesn't make a difference to the error though :(
12:00:49 <metahumor> btw, "readDepartment :: String -> Maybe Department"
12:00:54 <smurfendrek123> Yes
12:01:14 <metahumor> oh whoops, you're defining getDepartment
12:01:16 <Junior__> Welkin: Error is 'parse error on input deriving'
12:01:28 <metahumor> your typesig should be "IO Department"
12:01:37 <metahumor> and then you don't need a "return" in the latter case
12:01:37 <Welkin> Junior__: make your code *excatly* the same as in the book
12:01:41 <smurfendrek123> i replaced that at the top, but that error remains
12:01:43 <Welkin> all of the indentation, everything
12:01:47 <kadoban> Junior__: Did you fix what geekosaur suggested yet?
12:01:53 <Welkin> template haskell will give you weird errors if everything is not perfect
12:02:25 <smurfendrek123> i now have: https://paste.fedoraproject.org/paste/qVhnUTfzv9~rhvz7B5TjEg/raw
12:03:10 <smurfendrek123> yes i am terribly annoyed at haskell error messages, apart from saying what line the error is in, and thats sometimes not even where you should make the correction, they seem only usefull for putting them into google
12:03:24 <Junior__> kadoban: Suggestion of the indentation/spacing?
12:03:30 <kadoban> Junior__: Yes
12:03:35 <Welkin> this is one reason for beginners to not use yesod
12:03:52 <metahumor> smurfendrek123: you still have an extra "return" in the Nothing case
12:03:55 <Welkin> template haskell will cause a world of pain if you don't follow everything exactly (and if you don't know how it works)
12:04:36 <kadoban> I have no idea how TH works, I still managed with some yesod and persistent. But it did involve making sure I blindly followed the examples and guessed at some stuff.
12:04:41 <smurfendrek123> metahumor: should that line be like this: Nothing -> getDepartment?
12:04:48 <metahumor> smurfendrek123: GHC really trusts that you mean your typesigs. so if you wrote the typesig wrong, the errors will be "misplaced"
12:04:51 <metahumor> yeah
12:04:58 <metahumor> smurfendrek123: consider the types to the right of the arrows
12:05:05 <Welkin> me too, but I had to take a long time to learn what kind of code was produced by persistent
12:05:25 <kadoban> I never bothered, it didn't seem necessary. But maybe I just didn't get deep enough into it.
12:05:27 <Welkin> I only learned some basics of quasi quotes so it wasn't completely magic
12:05:28 <metahumor> for Just dep, dep :: Department, so "return dep :: Monad m => m Department", where your Monad m is IO
12:06:01 <Welkin> I hate "magic"
12:06:03 <metahumor> smurfendrek123: for Nothing, we still need an "IO Department". we have one! its what you're defining, getDepartment :: IO Department
12:06:06 <Welkin> but I do still use persistent
12:06:27 <electrocat> Welkin: somethimes, magic is convenient :p
12:06:28 <metahumor> smurfendrek123: "return getDepartment :: Monad m => m (IO Department)", which is not right
12:06:43 <smurfendrek123> i see
12:06:56 <Welkin> electrocat: only once you have gone through the pain of learning how it works
12:06:58 <smurfendrek123> however, the error remains :)
12:07:09 <metahumor> what error now?
12:07:11 <electrocat> Welkin: agreed
12:07:44 <smurfendrek123>     The last statement in a 'do' block must be an expression
12:07:52 <Welkin> return ()
12:08:00 <Welkin> smurfendrek123: I feel like this isn't getting you anywhere
12:08:09 <Welkin> it looks like trial-and-error programming to me
12:08:10 <Junior__> kadoban: I changed it to the indentation that I saw in the book.  http://lpaste.net/361738.  Error is now on line 18.  'Parse error or possible incorrect indentation or mismatched brackets'.  See anything wrong?
12:08:16 <electrocat> i am somewhat annoyed that yesod/persistent magic is sometimes terribly documented, when documentation is the only thing you have to go on
12:08:17 <Welkin> without any understanding
12:08:57 <smurfendrek123> Welkin: yes, but i don't know where to look to learn about how to fix The last statement in a 'do' block must be an expression errors
12:09:09 <Welkin> electrocat: yesod seriously lacks documentation, and when I used it to build production applications, I spent a lot of time reading source code and wasting days figuring out how to work within the library
12:09:39 <Welkin> it's powerful, but I don't use it for anything these days
12:09:42 <metahumor> smurfendrek123: I've written your function on my machine, and I'm not getting any syntax errors...
12:09:50 <electrocat> Welkin: what do you use now?
12:09:52 <kadoban> Junior__: Looks the same to me, not sure.
12:10:09 <kadoban> smurfendrek123: Can you paste the actual error? It's not making sense to me.
12:10:26 <Welkin> electrocat: seravnt for api servers, wai or scotty for a simple http server, react for the frontend (and preferably something like miso or reflex in the near future)
12:10:30 <Welkin> servant*
12:10:53 <smurfendrek123> kadoban: https://paste.fedoraproject.org/paste/~IYfPUM6zQf8bw2JW9QjMA/raw
12:10:55 <electrocat> yeah, thought a much
12:11:07 <electrocat> i just can't be bothered to learn something else
12:11:32 <Junior__> Welkin: See anything different from what is in the book?  http://lpaste.net/361738.  Error is now on line 18.  'Parse error or possible incorrect indentation or mismatched brackets'.
12:11:53 <Welkin> it does get tiring to endlessly learn the flavor of the week library, but I find that isn't a problem in haskell as much as it is in js
12:12:09 <Unode> I'm looking at some code that uses :!:, I can't seem to search this in hoogle. How can I find out what this operator is and where does it come from?
12:12:50 <metahumor> smurfendrek123: it looks like the code you shared with us is different, since what you shared doesn't have "department <- getLine"
12:13:16 <metahumor> Unode: if you have ghci open, you can try ":i (:!:)"
12:13:21 <electrocat> is servant that much more of a convenience to write api stuff?
12:13:22 <Welkin> Unode: search on hayoo, not hoogle
12:13:35 <smurfendrek123> I am terribly sorry
12:13:35 <Welkin> hayoo covers all of hackage, hoogle only covers base + some other libraries in the haskell platform
12:13:39 <smurfendrek123> and retarded
12:13:43 <Welkin> electrocat: yes, it is amazing
12:13:53 <smurfendrek123> i was looking at the wrong function, sorry
12:14:19 <smurfendrek123> metahumor i am sorry
12:14:24 <Unode> metahumor: I don't and am not sure how to in a way that I can access this code
12:14:44 <Welkin> @hayoo (:!:)
12:14:44 <lambdabot> Unknown command, try @list
12:14:46 <Welkin> !hayoo (:!:)
12:14:52 <Welkin> what was the command
12:15:19 <Welkin> oh well
12:15:19 <Welkin> http://hayoo.fh-wedel.de/?query=(%3A!%3A)
12:15:37 <Unode> Welkin: I tried that but the result was not enlightening
12:15:54 <Welkin> install local hoogle to search your local packages
12:17:23 <cocreature> Unode: http://hoogle.haskell.org/?hoogle=(%3A%7C%3A) also has a few results
12:18:06 <Unode> cocreature: ah seems like I missed the () around
12:18:41 <Unode> cocreature: actually it's :!: not :|: but this was helpful.
12:18:58 <cocreature> oh apparently I can’t read
12:19:13 <Unode> cocreature: font's don't blame yourself :)
12:19:20 <hyperisco> all the ways to repeatedly remove a subsequence of length n from a list…
12:19:32 <Welkin> hyperisco: kill -9
12:19:36 <Welkin> works every time
12:19:48 <hyperisco> then the list with a particular subsequence removed is the one such that the particular subsequence does not occur in the list
12:20:20 <Welkin> hyperisco: use a zipper
12:25:55 <metahumor> smurfendrek123: did you end up resolving the error?
12:26:02 <metahumor> smurfendrek123: don't be hard on yourself =)
12:26:18 <Welkin> was a sad smurf
12:26:21 <Welkin> what a*
12:26:28 <smurfendrek123> well, the function above is just not finished, but i started working on a helper function in the meantime
12:47:10 <smurfendrek123> metahumor, i fixed it :) do you want €2 on paypal?
12:48:11 <Welkin> ho much is that in bitcoins?
12:48:23 <Uniaika> Convert it in LTC first
12:49:37 <smurfendrek123> about 0.00010 - 0.00040 depending on what time of day you sell
12:50:19 <smurfendrek123> + €25 transaction fees
12:51:09 <Fobbbbb> Quick question about sublimeHaskell, I am getting the "Uncategorized: Backend error encountered during 'Checking and Linting': other error" anyone know how to resolve this?
12:51:17 <hyperisco> Welkin, hm that might be a first step… all the ways to cleft a list in twain, i.e. all the zippers
12:51:38 <hyperisco> what be a simple expression for that…
12:53:50 <Welkin> hyperisco: arrr, ye be a pirate now?
12:54:39 <Welkin> Fobbbbb: perhaps ask in a sublime channel?
12:55:09 <jgt> in Esqueleto, how do I write something like `SELECT * FROM foo WHERE bar LIKE ANY(ARRAY['spam%', 'eggs%']);`?
12:55:24 <metahumor> smurfendrek123: i'm glad it's working, what'd you end up having to fix in the end?
12:55:25 <jgt> I know I can write a single WHERE .. LIKE, but I need multiple
12:55:42 <jgt> and it can't be implicit AND clauses
12:56:11 <Welkin> jgt: once you get to a level of complexity beyond simple joins, I would use raw sql
12:56:21 <jgt> :(
12:56:32 <Welkin> use the rawSql function from persistent
12:57:01 <jgt> is there a way to chain OR clauses together?
12:57:07 <Welkin> there are other options besides persistent + esqueleto
12:57:08 <Fobbbbb> Well, I think the likelihood of an individual in #haskell using sublimeHaskell package is higher than an invidual using sublime text that also uses haskell
12:57:27 <Welkin> but you will still run into the problem of writing what you want indirectly, and perhaps not being able to do what you want to do
12:57:42 <jgt> Welkin: it doesn't have to be exactly that query, but the results should be the same
12:57:43 <Fobbbbb> Unless none of you use any sort of IDEs for Haskell
12:57:44 <Welkin> Fobbbbb: I've never touched sublime, and most in here use emacs or vim
12:58:13 <Fobbbbb> Well, here is to hoping that there exist another individual that uses sublime
12:58:47 <jgt> Welkin: I could imagine something like `WHERE foo LIKE 'a' OR foo LIKE 'b' OR ...`
12:59:16 <EvanR> it will pay for people in here to learn sublime and sublime haskell, that might be an avenue to establishing communication with more programmers
13:00:47 <smurfendrek123> well the do block in the function above was not finished yet, this is my finished, relevant code: https://paste.fedoraproject.org/paste/oPbu5QUO4QayRTiY5DyjmQ/raw
13:01:57 <smurfendrek123> In practice, it seems easier to write these kinds of things in another language, and just put computations and data processing in haskell instead of having haskell as a stand alone language
13:02:15 <Welkin> EvanR: there is no need for proprietary software in here
13:02:45 <amalloy> smurfendrek123: this looks like you are missing some higher-level pattern
13:02:54 <smurfendrek123> it works?
13:02:57 <smurfendrek123> what's wrong?
13:03:01 <Welkin> smurfendrek123: your entire program is in IO...
13:03:04 <amalloy> i mean, you're complaining about how bad the code looks
13:03:09 <smurfendrek123> yes its not the whole file
13:03:11 <Welkin> of course it is going to be terrible
13:03:15 <Welkin> you are wirint C in haskell
13:03:18 <Welkin> writing*
13:03:24 <Welkin> you are not writing proper haskell
13:03:41 <amalloy> it would be better if you figured out some way to generalize this concept you have of "a process that produces a value which may be invalid; and if it's invalid recurs until it gets something valid"
13:03:58 <amalloy> and then write these three functions in terms of that more general thing
13:04:04 <smurfendrek123> that's true, i'll try generalizing the getDepartment and getBudget
13:04:30 <Welkin> IO should be minimized and quarantined
13:04:35 <Welkin> use as many pure functions as possible
13:04:42 <Welkin> I don't see that in your program
13:05:01 <amalloy> likewise you have "print a prompt, then call a function to get a value" as a concept that could be reified in mainBase
13:05:09 <Welkin> it looks like any typical imperative program that you could have written in java
13:05:49 <smurfendrek123> this is the entire code: https://paste.fedoraproject.org/paste/NbQBzyQ8qdakCKE4nzLsyA/raw the rest is pure
13:05:56 <smurfendrek123> i agree, but it's an exercice :)
13:06:23 <smurfendrek123> i wouldn't write these kinds of things in haskell either
13:08:51 <amalloy> :t lookup
13:08:54 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
13:09:33 <amalloy> smurfendrek123: readDepartment = flip lookup [("ICT", ICT), ("HR", HR), ("Cleaning", Cleaning)]
13:09:33 <Welkin> it's a poor man's Map
13:09:41 <amalloy> Welkin: yes, just checking that i had the types right
13:09:56 <smurfendrek123> :t flip
13:09:58 <lambdabot> (a -> b -> c) -> b -> a -> c
13:10:32 <amalloy> :t readMaybe
13:10:34 <lambdabot> error: Variable not in scope: readMaybe
13:10:44 <mniip> :t reads
13:10:47 <lambdabot> Read a => ReadS a
13:10:49 <Welkin> you can talk with lambdabot in private too
13:10:54 <Welkin> Pm it
13:11:22 <amalloy> Welkin: i know. i'm trying to point things out to smurfendrek123. but maybe pm would have been a better choice if i didn't know exactly what to point out already
13:11:55 <jgt> Ok I'm going to ask the same question, but in a different way. I have some things. These things are ["a", "b", "c"]. I need to turn those things into ((f ^. FooBar `like` val "a") ||. (f ^. FooBar `like` val "b") ||. (f ^. FooBar `like` val "c")).
13:12:49 <amalloy> jgt: looks like a foldr
13:12:59 <EvanR> looks like a mconcatMap
13:13:09 <EvanR> or
13:13:16 <jgt> amalloy: yeah, that's what I thought it might be. I'm not sure how else to stick the ||. in between
13:13:19 <EvanR> :t foldMap
13:13:20 <amalloy> foldMap, you mean?
13:13:21 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
13:13:27 <amalloy> if these things are monoids, then sure
13:13:35 <jgt> EvanR: I don't know about mconcatMap or foldMap
13:13:40 <EvanR> does ||. constitute a monoid
13:14:24 <jgt> EvanR: I don't know. The Esqueleto docs don't mention monoid anywhere, so maybe I have to write my own instance?
13:14:41 <jgt> EvanR: The ||. is from here: https://hackage.haskell.org/package/esqueleto-2.5.3/docs/Database-Esqueleto.html#v:-124--124-.
13:15:21 <EvanR> (||.) :: expr (Value Bool) -> expr (Value Bool) -> expr (Value Bool)
13:15:59 <EvanR> since theres no actual type there to attach the instance to... seems like a long shot
13:16:50 <jgt> EvanR: seems like a long shot that I can write it with foldMap? Or seems like a long shot that I can do this programmatically at all?
13:17:37 <smurfendrek123> amalloy: that's a very interesting suggestion, took me a while to get it, but it's quite cool
13:17:55 <amalloy> anyway smurfendrek123, what i was trying to get around to was another implementation of readDepartment, provided you derive a Read instance for Department: readDepartment = fmap fst . listToMaybe . reads
13:18:30 <amalloy> which is nice because then you don't have to amend the implementation of readDepartment every time you add a new department
13:20:15 <amalloy> the Employee type looks very questionable as well. look at all the repetition you have for id naam and loon for every different type of employee
13:21:00 <Welkin> amalloy: I agree. The entire concept of an "employee" is problematic. It's just another form of the master-slave concept
13:21:27 <shapr> uhh
13:21:34 <amalloy> Welkin: we can continue that discussion in #haskell-socialism
13:21:36 <smurfendrek123> Yea i don't really know how to avoid that, the model solution does it as well, i could put a base data type i think to which the others add onto but that would make it a bit complicated, but this is a problem not really suited to haskell
13:21:39 <smurfendrek123> sorry
13:21:53 <amalloy> it is quite suited to haskell, it's just you're new to it
13:21:58 <smurfendrek123> ah
13:22:06 <jgt> amalloy: my problem can be solved with a fold, right? Should I try that? Or will I be wasting my time?
13:22:16 <amalloy> jgt: a fold would certainly be possible
13:23:07 <EvanR> the master-slave concept is pretty bad, we should upgrade to PCI
13:23:08 <smurfendrek123> So is making a different data type that has name and wage, and then having the more specific data types add onto that a better solution?
13:23:12 <jgt> amalloy: what would the initial value be in this case?
13:23:36 <amalloy> you could write, for example, data Employee = Employee Int String Int DepartmentalData; data DepartmentalData = ProgrammerData Int -- werkuren | HRData Int Int -- werkuren opgelosteconflicten | CleanerData Int -- aantallokalen
13:23:40 <shapr> Any US citizen good with Haskell, C++ and FPGAs interested in a job in Huntsville Alabama?
13:23:47 <amalloy> it's not perfectly clean, but it factors out the repetition you have
13:23:50 <jgt> folds are still reducing data structures in my head; I'm not sure how to do it with functions
13:24:12 <amalloy> jgt: you'd need some kind of neutral "always true" kind of clause as your initial value
13:24:13 <Rembane> shapr: I'm afraid I'm not a citizen, but I really want to read the job ad! :)
13:24:17 <Welkin> shapr: defense contracting?
13:24:24 <shapr> Welkin: how'd you guess?
13:24:25 <amalloy> er, always false, i guess
13:24:31 <Welkin> huntsville, us citizen
13:24:37 <shapr> Welkin: yeah, too easy :-)
13:24:46 <kadoban> shapr: Can it not be alabama? :(
13:24:58 <Welkin> kadoban: huntsville is nice from what I have seen and heard
13:24:59 <shapr> kadoban: no clue about remote work
13:25:03 <smurfendrek123> amalloy: that's a nice solution
13:25:07 <shapr> I used to live in Huntsville, it's not terrible.
13:25:23 <Welkin> and it's mostly scientists and engineers
13:25:27 <shapr> but I don't have much C++, and zero FPGA
13:25:39 <shapr> I guess I could ask on #clash-lang
13:25:39 <EvanR> theres that casino resort on the highway a few 100s of miles away right?
13:25:42 <kadoban> I don't know fpga very much either I guess.
13:26:10 <jgt> amalloy: so the initial value can be something like (f ^. FooBar `like` val "ThisWillNeverAppearInMyDatabase")?
13:26:14 <amalloy> smurfendrek123: it's something you can do very mechanically for any data type with repeated fields
13:26:37 <shapr> it's funny how many Haskell jobs show up in my inbox
13:26:38 <amalloy> extract the repeated fields to their own type, and add another type that discriminates the non-repeated stuff
13:26:57 <amalloy> jgt: i suppose. that seems rather unclean, but i don't know what functions you have available
13:27:02 <EvanR> jgt: dont you mean, something like "pure True"
13:27:03 <shapr> Rembane: funny thing is, I couldn't find an actual ad for the job
13:27:20 <Welkin> shapr: I never get any. Only crappy spam emails from people looking for ruby/python/java
13:27:22 <jgt> EvanR: Maybe! I don't know :)
13:27:22 <EvanR> (for the initial value)
13:27:28 <amalloy> i'm with EvanR that this looks very monoidal and it'd be a shame if the library you're using didn't provide a monoidal view of this stuff
13:27:32 <shapr> Welkin: I get a pile of those
13:28:00 <Rembane> shapr: Oh. One of those sneaky ninja jobs.
13:28:22 <shapr> Rembane: yeah, those come to me by word of mouth, and I get a bunch
13:28:41 <EvanR> i would like a haskell job
13:28:56 <Rembane> shapr: Cool. "We have another ninja opening, lets tell shapr..."
13:29:06 <shapr> it feels that way sometimes
13:29:26 <tdammers> the thing with ninja jobs is that most of the time the position is already filled, but nobody, not even the employer, has noticed yet
13:29:30 <Welkin> ninjas... that reminds me to play shadow tactics
13:29:33 <shapr> I know of one or two in Athens, GA
13:29:52 <shapr> piles of Haskell jobs in San Francisco and Boston
13:29:56 <shapr> a few in NYC
13:30:07 <EvanR> how is alabama ahead of louisiana in haskell jobs
13:30:14 <shapr> probably isn't
13:30:14 <EvanR> this is embarrassing
13:30:19 <amalloy> i have to head out for a bit, but smurfendrek123 might enjoy being shown how comparison functions form a monoid, to improve the implementation of candidateCompare in https://paste.fedoraproject.org/paste/NbQBzyQ8qdakCKE4nzLsyA/raw
13:30:26 <shapr> EvanR: but Alabama does have most of NASA and related DoD work
13:30:27 <Welkin> just because they are using haskell doesn't make it a good place to work
13:30:39 <shapr> Welkin: true that
13:31:33 <EvanR> a shrewd hiring manager or strategist will dangling haskell out there to get people to join, then surprise heres your java
13:31:43 <shapr> EvanR: I've seen a few of those too
13:31:45 <kadoban> EvanR: That would be funny
13:31:58 <smurfendrek123> amalloy: monoids seem cool, but i've never used them i think
13:31:58 <Welkin> they use agile and have scrum masters
13:32:02 <Welkin> and do sprints
13:32:02 <shapr> but there are at least ten people writing Haskell for a living in the Atlanta area
13:32:07 <shapr> oh wait, more come to mind
13:32:26 <EvanR> atlanta eh
13:32:37 <Welkin> some stupid recruiter did that to me, but with react/javascript
13:32:47 <MP2E> it's a trap!
13:32:50 <shapr> Ten jobs in Atlanta area companies, and quite a few more people doing remote Haskell work
13:32:56 <kadoban> shapr: Find me some in phoenix :(
13:33:02 <Welkin> after a lengthy phone call, they suddenly said "oh, well, they are mostly looking for someone to work on rails"
13:33:03 * shapr thinks
13:33:15 <EvanR> remote would be nice
13:33:16 <Welkin> I said "k, thanks bye"
13:33:29 <shapr> kadoban: I don't know of any in Arizona, but I haven't been looking
13:33:33 <[exa]> lol
13:33:42 <kadoban> No worries :)
13:33:55 <shapr> kadoban: I'll add it to my list of interested locations
13:34:19 <kadoban> That'd be cool if you don't mind. I've yet to see any on the usual job boards, but then I don't think they usually end up there ...
13:34:32 <Welkin> job boards are where the leftovers go to die
13:34:33 <tdammers> hmm, yeah, there's a bit of a trend there - companies advertising "Haskell" jobs that turn out to be more like "yeah, OK, it's basically all Ruby, but we think Haskell is somehow good so we put that in"
13:35:04 <tdammers> also, ye, job boards are the last resort, on both sides
13:35:21 <[exa]> thank god you've got ruby there; sometimes I think that our whole republic is coded in PHP
13:35:30 <tdammers> I don't think I've ever found a job through a job board
13:35:42 <tdammers> or a recruiter, for that matter
13:35:50 <Welkin> nope, never
13:36:02 <Welkin> I only have through mutual contacts and cold emails
13:36:04 <kadoban> I've found two internships on them, but those are easier. Companies don't seem to care if you're a moron for an internship.
13:36:15 <EvanR> i had success with a recruiter, a small recruiter
13:36:16 <metahumor> in fact, they probably assume so
13:36:28 <Welkin> also, forget about recruiters, they are useless
13:36:40 <EvanR> they are useful for their contacts
13:36:48 <metahumor> recruiters aren't useless from the business's perspective
13:36:52 <tdammers> first programming gig I got I "graduated" from a customer support role
13:36:56 <metahumor> its just a friends-paradox problem
13:36:59 <Welkin> kadoban: they want you to be a moron as an employee. you are easier to boss around and get cheap labor from
13:37:15 <kadoban> Welkin: heh, maybe
13:37:35 <shapr> sclv: have you previously read http://www.textproof.com/paper/dphil.html ?
13:37:42 <metahumor> everyone knows a recruiter that is hiring, but no one gets hired by a recruiter, for a definition of "no one ~= almost no one"
13:37:42 <tdammers> after that, it was all networking, word-of-mouth, targeted channels like forums and mailing lists, or being approached by employers
13:37:53 <kadoban> I just know my interviews were ridiculously easy in retrospect
13:38:26 <tdammers> I think the thing with recruiters is that the whole setup works for some combinations of employers and employees, but not for others
13:38:42 <tdammers> and I think the kind for whom it does work doesn't generally come here
13:38:42 <shapr> I think I have a weird approach, I look for jobs all the time, and do interviews between once a month and once a week.
13:38:52 <Welkin> the recruiters are not engineers. They don't understand what they are talking about 99% of the time
13:39:10 <shapr> That lets me stay on top of how much I'm worth to employers, and where the jobs I want are appearing.
13:39:21 <tdammers> Welkin: recruiters are axiomatically clueless - if they weren't clueless, they'd take one of the jobs they're trying to sell you on themselves
13:39:29 <shapr> yeah, I agree with tdammers
13:39:32 <kadoban> shapr: Interesting, I've always wondered if people did that. Do you change jobs pretty often, or do most of them not pan out?
13:39:37 <metahumor> Welkin: ok, now you know that, so you can express your skills in a way that you think will come across well to a non-engineer and also will be relevant to how the recruiter reports to the hiring manager
13:40:10 <Welkin> metahumor: which means making up a bunch of shit that you think sounds like buzzwords
13:40:20 <Welkin> "I have 10 years experience writing html"
13:40:24 <tdammers> considering how even a shitty dev job pays better and sucks less than being a tech recruiter
13:40:34 <EvanR> i think someone more socially uninept than a programmer would be good at recruitering
13:40:51 <Welkin> "I do the scrums and the agiles"
13:41:10 <metahumor> "uninept" i like that
13:41:19 <EvanR> ept?
13:41:22 <shapr> kadoban: that all depends on the job market and how much I'm being paid at the time. On average, I change jobs every two years. This job pays decently, and the community/culture is *amazing* but it's Python/C++/Go/Ruby/etc
13:41:29 <metahumor> "socially able"
13:41:31 <kadoban> My local job board has like way more listings than I expected that mention agile. There's like 3 or 4 that are specifically looking for a "scrum master", which I find bizarre for some reason.
13:41:47 <metahumor> "scrum master" always sounded vulgar to me
13:41:56 <EvanR> intuitionism retroactively explains peoples tendency to double negate
13:42:00 <Welkin> managers love hiring more managers
13:42:03 <metahumor> just that mix of consonants and vowel is eww
13:42:13 <Welkin> but then there is no one left to manage
13:42:20 <EvanR> but not triple negate
13:42:23 <tdammers> the funny thing is that >90% of those aren't actually looking for a scrum master, but for a project manager with a fancier job title
13:42:34 <kadoban> shapr: Interesting, thanks.
13:42:57 <kadoban> Thankfully I'm not *that* picky with language. I really like haskell, but if I have to do some C++ or python or something I'm not going to actually die.
13:43:29 <shapr> kadoban: I could go into more detail, when I get an offer from another company, I talk to my employers, say they can match it minus what the change will cost me, or I'll be off to that new place.
13:43:31 <Welkin> I just finished a job working mostly with react, but near the end of the year had to do a lot more with a massive legacy rails app, which SUCKED
13:44:18 <Welkin> it oozed with OOP
13:44:23 <smurfendrek123> kadoban: what's wrong with python, i really like python, it takes a lot from haskell i find
13:44:32 <Welkin> smurfendrek123: it has a terrible api
13:44:33 <kadoban> shapr: I've heard that that's pretty much the only way most people actually get paid what they're worth. It just never seemed that anyone was actually doing it, judging from my few friends who I would know.
13:44:37 <shapr> I've decided I don't like OOP, and I especially don't like mock objects
13:44:44 <Welkin> I used to like python many years ago when I just started programming, but now I find it unbearable
13:44:55 <Welkin> python almost made me quit programming, until I found haskell
13:45:00 <kadoban> smurfendrek123: The lack of a type system means I have to write about a billion more tests, and I still end up less convinced that software is acutally going to do what I meant it to do.
13:45:15 <smurfendrek123> that's true
13:45:21 <shapr> kadoban: just remember that businesses don't have loyalty to their employees, and you shouldn't be expected to be loyal to your company. It's *business*
13:45:26 <Welkin> so yes, the language matters, but some are more tolerable than others
13:45:33 <shapr> kadoban: so, figure out what you're worth, then make sure you get paid that much
13:45:39 <Welkin> I can work with javascript without issue if I can write it in a semi-functional style
13:45:40 <kadoban> Yeah, that's a really good point
13:46:15 <Welkin> I even enjoy low-level C and assembly
13:46:25 <Welkin> but oop languages? no way
13:46:25 <shapr> kadoban: for me, I want 1. interesting work/problems 2. good coworkers 3. good money
13:46:29 <shapr> and I'm happy to get two out of three
13:46:44 <Welkin> good coworkers is crucial
13:46:49 <Welkin> and a god boss/manager
13:46:52 <Welkin> good*
13:46:52 <shapr> This job has just over two points, and the coworkers are the best I've had
13:47:04 <kadoban> Yeah, 1 and 2 are usually good enough for me. My current situation is terrible though, right now I just need to start earning ... something.
13:47:15 <Welkin> even if the work is boring, if you have good coworkers, and you are paid well, it's great
13:47:20 <Welkin> for a limited time
13:47:26 <metahumor> i also work almost entirely with python, and its lack of support for curried functions and lazy eval is really bugging me now
13:47:27 <shapr> yeah, I'm writing C++ today, and it's not bad
13:47:28 <Welkin> eventually you need to do somethign with your life :P
13:47:47 <shapr> metahumor: doesn't functools have partial application?
13:49:23 <Welkin> trying to do functional programming in haskell is like trying to have sex with a tree
13:49:32 <Welkin> it just won't work
13:49:36 <Welkin> and it will be painful
13:49:39 <smurfendrek123> wait
13:49:39 <kadoban> Did you mean haskell there? xD
13:49:42 <smurfendrek123> what
13:49:44 <Welkin> haha
13:49:47 <kadoban> I think you might have meant python, haha.
13:49:50 <Welkin> trying to do functional programming in python is like trying to have sex with a tree
13:49:53 <Welkin> haha
13:49:55 <kadoban> There we go, lol.
13:50:27 <kadoban> I wouldn't personally go that far, but I agree that FP in python is not exactly the best idea ever, taken too far. The community and language curators just don't value/support it very well.
13:50:51 <[exa]> shapr: about c++, do you think that the industry is finally catching up with the standard? (a year ago most of the people were writing pre-c++11 code)
13:50:53 <EvanR> yeah "map and filter were a mistake"
13:51:22 <Welkin> guido is a guido
13:51:26 <metahumor> shapr: yes, but functools.partial is clunky, and the support for "flip" is bare
13:51:28 <smurfendrek123> Welkin: what do you find lacking in python's functional programming? Aren't the generators nice?
13:51:50 <metahumor> shapr: additionally, defining lambdas in a for loop needs all sorts of care if you use the loop variable in the body of the lambda
13:51:57 <Welkin> smurfendrek123: it doesn't even have first class functions. That is the bare minimum to even do anything considered functional
13:52:08 <metahumor> shapr: it has to be supplied as a "lambda ix=ix: f(ix)"
13:52:29 <Welkin> [exa]: c++18?
13:52:41 <[exa]> smurfendrek123: python is the new lisp: if you try to code something functional you will get map(filter(reduce(filter(lambda......)))))))))))))))))))
13:52:49 <metahumor> python does have lazy eval: yield. but only for iterators/generators
13:52:57 <jgt> amalloy Welkin EvanR here's the fold I tried, and the SQL it produced: https://gist.github.com/jezen/a5c16240ccfbcf8e125196fa6bd3486d
13:53:00 <smurfendrek123> Welkin: i think you can pass functions as parameters though, can't you?
13:53:06 <metahumor> and "yield from" is only in the newest python iirc
13:53:23 <jgt> it's close, but not quite right
13:53:23 <metahumor> smurfendrek123: yes, you can pass functions as arguments
13:53:27 <shapr> [exa]: I think we're using 11 for most things, and 14 for new things
13:53:28 <[exa]> Welkin: at least something that can do move semantics
13:53:41 <[exa]> shapr: ok thanks, good to hear that
13:53:47 <shapr> [exa]: but in some cases we have to use vendor SDKs that are *ancient*
13:53:53 <smurfendrek123> yes but if you're still writing in python 2 you should reconsider what you're doing
13:53:56 <[exa]> :]
13:53:57 <metahumor> smurfendrek123: but its hard to use it nicely, for example, writing "foldr" in python is bleh
13:54:18 <metahumor> proprietary libs in python2 means all my code is python2
13:54:18 <shapr> Also, we just started using Python 3 for new projects, most everything we have is Python 2
13:54:19 <Welkin> the lack of a type system is the biggest blow
13:54:29 <shapr> Welkin: type hinting in Py3.6 is meh
13:54:45 <EvanR> jgt: hmm. query optimizer might be ok with that
13:54:47 <shapr> aand we don't have py3.6 yet :-(
13:55:02 <shapr> we also have a very tiny Rust codebase, so I want to learn in that direction
13:55:12 <smurfendrek123> metahumor: there's also quite a bit of python 3 exclusive libraries though, for example django
13:55:16 <Welkin> rust looks fun
13:55:22 <metahumor> when i am proselythizing haskell at work, i mention 4 things: lazy eval, referential transparency, first class functions (w currying), and strong static typing
13:55:23 <smurfendrek123> yes i agree
13:55:37 <Welkin> I've only looked at it briefly. It's not haskell, but it looks like a cool idea for replacing c++
13:55:57 <shapr> metahumor: I've tried that, but the only time I got interest was when I showed them how Spock was so much faster than Flask
13:56:25 <jgt> EvanR: it's given me all results, so it doesn't work as a filter. I suspect this is because the first one is PersistBool True
13:56:29 <Welkin> metahumor: I imagine you strutting around like you are on the catwalk, holding up a copy of "Real World Haskell" and reciting verses from it
13:56:30 <shapr> I still don't understand why execution speed is prized above all else.
13:57:00 <[exa]> Welkin: rust has a problem with some missing features (similar to why haskell suddenly has type families etc, and why C++ had to become overcomplicated)
13:57:12 <[exa]> Welkin: but the idea is super-great
13:57:12 <Welkin> rust is still new
13:57:18 <EvanR> jgt: ah, False is the unit for a chain of ORs
13:57:21 <Welkin> it has time to grow and change
13:57:24 <shapr> [exa]: higher kinded types? what's missing?
13:57:24 <EvanR> not True
13:58:01 <shapr> I went to my first Rust class last week, it was weird to see how control flows go deep instead of broad the way Haskell does things.
13:58:26 <shapr> like "process data as close to allocation as possible to optimize your runtime"
13:59:06 <metahumor> shapr, Welkin: i'm giving a talk tomorrow on data viz (static and dynamic) in python, i'm going to show why writing DSLs in langs that have the 4 things I mentioned is great
13:59:18 <shapr> metahumor: will your talk be recorded?
13:59:19 <Welkin> one thing I don't understand is why so many people want to use rust for web servers
13:59:22 <Welkin> that is crazy
13:59:31 <shapr> metahumor: will you be demonstrating IHaskell?
13:59:31 <Welkin> that's like saying you want to write your server in c++
13:59:48 <shapr> Welkin: I think the current programmer culture is speed obsessed
14:00:00 <shapr> which is fine in HPC, but elsewhere?
14:00:08 <metahumor> shapr: nope... and I can't find a reference that I love -- about proper visualizing of "car trajectories" on a webpage, and how to simplify that. maybe someone knows what i'm referring to?
14:00:30 <Welkin> there are projects to compile rust to javascript now, too
14:00:30 <metahumor> shapr: no IHaskell, but I will show snippets of plotlyhs and chart-unit
14:00:38 <Welkin> that makes absolutely no sense
14:00:46 <EvanR> js = asm
14:00:54 <EvanR> machine code for we
14:01:10 <Welkin> metahumor: car or cdr?
14:01:15 <metahumor> shapr: i want to contrast the bureacracy of matplotlib, the "magic" of ggplot, and the expressiveness of lenses + declarative of plotlyhs
14:01:27 <metahumor> Welkin: lol
14:01:30 <shapr> sounds nifty, I wish I could see your talk
14:01:40 <metahumor> shapr: its going to be pretty rough unf =C
14:02:06 <[exa]> shapr: the worst design problem is the 'single level of safety', missing feature probably the aliasing control. And the STL from C++. :]
14:02:14 <metahumor> last minute talk at work, didn't want to actually talk about what i'm working on
14:03:15 <Welkin> metahumor: go up to give your talk, lean in to the microphone, and say "Hodor", then turn around and leave the room
14:03:17 <shapr> metahumor: I hope it goes well!
14:03:48 <wdanilo> Hi guys! I want to announce that after 2 years of working on this project, our team released Luna as Open Source project yesterday! ( http://luna-lang.org )
14:04:10 <wdanilo> It would not be possible without you. You have helped us so much a lot of time. Thank you guys very, very much for it
14:04:13 <Axman6> Luna looks pretty awesome, nice work (saw a tweet yesterday)
14:04:14 <shapr> wdanilo: yay!
14:04:32 <wdanilo> Axman6, shapr <3
14:04:39 <phadej> oh, chart-unit uses tdigest, nice
14:04:47 <Welkin> I don't get what it is
14:05:00 <phadej> for examples though, but anyway
14:05:01 <Welkin> but all of the people on that website have their arms crossed, like they are shy
14:05:10 <wdanilo> Luna is a visual / textual language (you can switch between them any time you want). It has truntime interprreter and we will soon also allow compiling Luna to Haskell Core
14:05:15 <Welkin> except for Marcin
14:05:34 <[exa]> wdanilo: great work, seriously
14:06:14 <Welkin> what is it for?
14:06:21 <Gurkenglas_> Has anyone successfully installed Luna on Windows?
14:06:35 <Welkin> or rather, who is it for?
14:06:35 <shapr> I failed to build/install Luna last night
14:07:34 <wdanilo> Welkin: Luna is a data processing language meant to revolutionize the way people are able to gather, understand and manipulate data.
14:07:49 <wdanilo> Welkin: Luna targets domains where data processing is the primary focus, including data science, machine learning, IoT, bioinformatics, computer graphics or architecture.
14:07:52 <[exa]> wdanilo: (btw since when is Krakow written as "Cracow" :] )
14:07:53 <ph88> can i allocate a mutable block of memory that will never be deallocated while the program is running ?
14:08:01 <wdanilo> Welkin, here is more in-depth explanation: https://medium.com/@luna_language/luna-the-visual-way-to-create-software-c4db520d6d1e
14:08:11 <jgt> Welkin: That's awesome. My query works perfectly. Thank you!!!
14:08:23 <jgt> [exa]: sadly it's often written Cracow :(
14:08:24 <Axman6> wdanilo: it would be good to get the macOS binaries signed, I try not to run unsigned apps if possible (yes it'll cost you $99/yr IIRC but you don't need to use the app store)
14:08:30 <[exa]> weird.
14:08:47 <jgt> it's like the damn Germans
14:08:53 <smurfendrek123> metahumor: this is foldl in python: https://paste.fedoraproject.org/paste/sF2wy08AvHwSjzY4XZu5Iw/raw it's about the same as in haskell isn't it? Although, i agree that haskell looks nicer because of pattern matching
14:08:57 <wdanilo> [exa]: Since the company behind our website thinks so :O Oh, I did not notice it, we'll fix that, thanks for cathcing it!
14:09:12 <jgt> Germans: where do you live?
14:09:14 <[exa]> wdanilo: My eyes hurt a bit :] anyways, can it crunch RDF data?
14:09:15 <jgt> Me: Gdansk
14:09:17 <amalloy> jgt: that looks basically right except your default value for an OR should be false, not true
14:09:21 <jgt> Germans: Where?
14:09:24 <jgt> Me: Danzig.
14:09:24 <wdanilo> [exa]: and thank you! We were working on it very hard and we want to make Luna the best visual language ever created
14:09:29 <jgt> Germans: Ohhhhhhh....
14:09:29 <Axman6> wdanilo:for most people the installer won't open because it's unsigned, requiring a right click and selecting open, then clicking open
14:09:39 <metahumor> smurfendrek123: yeah, that'd be foldl'
14:09:40 <amalloy> ah, i see someone already said that
14:09:44 <smurfendrek123> oh
14:09:47 <jgt> amalloy: yeah, it worked with False. Thank you :D
14:09:49 <wdanilo> So if you guys want to see it happen, I would love to ask you for heliping us a little bit. Every idea / contribution is more than important to us
14:09:59 <jgt> ok, logging off. Ciao.
14:10:00 <Welkin> what?
14:10:07 <Welkin> is jgt schizophrenic?
14:10:22 <Gurkenglas_> Welkin, read it like a play
14:10:30 <wdanilo> Axman6: the binaries would be signed. We just asked Apple to late for it and we are waiting for ages now for them to verify us :(
14:10:46 <Axman6> wdanilo: great to hear. This is pretty exciting :)
14:11:07 <Welkin> so is luna something to replace ipython/numpy/scipy?
14:11:18 <Welkin> I don't work in data science
14:11:19 <wdanilo> [exa]: You can do in Luna anythong you can o in HAskel. In fact we are just about to release an FFI binding, so you will be able to paste Haskell code to Luna nodes
14:11:29 <amalloy> smurfendrek123: createInitEmployees = flip zipWith createEmployee [1..]
14:11:53 <amalloy> hm, no
14:12:03 <amalloy> createInitEmployees = zipWith (flip createEmployee) [1..]
14:12:04 <kuribas> shapr: my idea about speed is, as long as you don't notice it, it's fine.
14:12:10 <[exa]> wdanilo: well, because we have a tremendous pile of cheminformatical data on one side, a big heap of scientists that want to do stats on that on the other side, and currently SPARQL in between (which sucks)
14:12:16 <amalloy> or you could just change the argument order for createEmployee and not need a flip at all
14:12:19 <kuribas> shapr: which makes python not fine...
14:12:32 <[exa]> wdanilo: this looks miracle-ish to them.
14:12:43 <smurfendrek123> do you find flip statements easy to read?
14:12:51 <hyperisco> okay, different idea… what is all ways to split a list into n contiguous subsequences
14:13:03 <wdanilo> Welkin: yeah something like that. But there are other use cases too, liek procedural graphics creation (parametric architecture or parametric VFX). Other use case is to create IoT devices in a visual way. If you work with data that could be visualised, you can think of Luna as a good playground for it
14:13:14 <smurfendrek123> I find it to reduce the readability, i have to think about what the function does for even simple examples, but i imagine that might not be the case for you
14:13:20 <metahumor> smurfendrek123: I use "flip evalStateT mystartingstate $ do ..." often
14:13:55 <amalloy> smurfendrek123: you sorta like...don't have to read them, generally. the compiler will tell you if you got the types wrong, so you can just assume that zipWith (flip f) xs ys will call f with the right arguments, whatever those are
14:14:10 <smurfendrek123> ah yes, that's true
14:14:10 <wdanilo> [exa]: oh, that sounds cool! Want to test how you could use Luna in this environment? We would love to help you get started and do some libraries!
14:14:45 <dmwit> hyperisco: The 1 case is easy. Otherwise select up to length-n+1 elements to go in the first subsequence, and select n-1 contiguous subsequences of the remainder.
14:14:55 <amalloy> one policy i have used for self-growth is to write code in ways that i don't have much practice with, because it's the best way to get familiar with alternative styles
14:15:08 <MarcWeber> Can I suspend gc for a some time? Is there a suspendGC -> IO() and a gcNow() -> IO() like function?
14:15:21 <hyperisco> f "123" = [["123"],["1","23"],["12","3"],["1","2","3"]]
14:15:22 <amalloy> some of those styles may turn out not to be great, but at the end you'll be able to read code written by others in that style
14:15:24 <dmwit> hyperisco: Oh. I am wrong, because I once again confused subsequence and substring.
14:15:45 <hyperisco> dmwit, contig subsequence and substr should be the same thing
14:15:56 <smurfendrek123> and i find that it increases my understanding of the language, but that might not be the case anymore for you  :à
14:15:58 <dmwit> okay
14:17:05 <hyperisco> I think if I can get that *then* I can solve the other problem… all these shaved yaks!
14:17:49 <[exa]> wdanilo: I'm currently thinking about whether to go the google-ish way, or let them run some real analyses... luna probably easily provides the second thing for almost-non-programmers, but I'll need to see if they can even put together what they want to see :]
14:18:17 <smurfendrek123> amalloy: i was thinking of unifying my getdepartment and getbudget in one function where i also pass the data type, as you would do with read, is that the right direction?
14:18:32 <hyperisco> would just call it the partitions of the list
14:18:34 <[exa]> wdanilo: I'll certainly try it out and let you know
14:18:50 <dmwit> > let sizedSubstrings n xs = go n (length xs) xs; go n _ _ | n < 1 = []; go 1 xs _ = [xs]; go n xs len = do { m <- [1..len-n+1]; let (b, e) = splitAt m xs; rest <- go (n-1) e (len-m); return (b:rest) } in sizedSubstrings 3 "abcd"
14:18:53 <lambdabot>  <hint>:1:160: error:
14:18:54 <lambdabot>      parse error on input ‘<-’
14:18:54 <lambdabot>      Perhaps this statement should be within a 'do' block?
14:19:21 <wdanilo> [exa]: sure, id be happy to help! Please keep in mind that we currently ship a very limited set of libraries, but you can connect anything from Haskell to Luna pretty easily.
14:19:37 <amalloy> smurfendrek123: that sounds good, although i wouldn't call it "passing the data type", since you're not passing types
14:19:37 <geekosaur> dmwit, braces around the embedded let in the do
14:19:47 <wdanilo> [exa]: You can always catch me on our forum/chat - links are on the website: http://luna-lang.org
14:19:53 <smurfendrek123> what's that called then?
14:19:54 <Welkin> smurfendrek123: where did you find such a dreadful "exercise" as programming a budget tracking system for eployees and departments? A book on java from the 1990's?
14:19:54 <[exa]> wdanilo: you're actually happy that you don't ship cheminformatic libs :]
14:20:16 <hyperisco> the final algorithm should be  \xs -> minimumBy (comparing length) . fmap (mconcat . filter (xs /=)) . partitions
14:20:20 <smurfendrek123> Welkin: it was my haskell exam :s
14:20:23 <[exa]> wdanilo: probably on IRC here then :]
14:20:26 <Welkin> smurfendrek123: oh my god
14:20:29 <Axman6> wdanilo: is the tutorial supposed to be using 250% CPU?
14:20:30 <amalloy> rather you would pass either readDepartment or readMaybe
14:20:33 <Welkin> what university is this?
14:20:34 <wdanilo> [exa]: Im happy I can work on a language which could help people with their work and im allowed to give it away for free <3
14:20:41 <amalloy> ie, your validator function, or your conversion function, or something
14:20:47 <smurfendrek123> Welkin: KU Leuven :p
14:21:33 <[exa]> whenever I see Leuven I actually read Duvel
14:22:04 <wdanilo> Axman6: depends. After openning Luna it compiles all the standard libraries in the background, so it takes some CPU, but it should stop after it finishes
14:22:06 <Welkin> it would make Dijsktra weep
14:22:12 <dmwit> > let sizedSubstrings n xs = go n xs (length xs); go n _ _ | n < 1 = []; go 1 xs _ = [[xs]]; go n xs len = do { m <- [1..len-n+1]; let {(b, e) = splitAt m xs}; rest <- go (n-1) e (len-m); return (b:rest) } in sizedSubstrings 3 "abcd"
14:22:15 <lambdabot>  [["a","b","cd"],["a","bc","d"],["ab","c","d"]]
14:22:23 <dmwit> geekosaur: Yeah. There were several other bugs, too.
14:22:33 <dmwit> hyperisco: ?
14:22:43 <hyperisco> which is "the minimum (concatenation of (all (partitions of ys) which are not equal to xs)) by length"
14:22:57 <wdanilo> Axman6: we do not currently cache compiled libraries, so it happens every time ou open Luna. But after the reelease, we are right now focusing only on performance, so caching compiled libraries and incremental typecheckign after adding new node will be available soon
14:22:59 <smurfendrek123> amalloy: but what do i put for the type then?
14:23:16 <smurfendrek123> just IO a?
14:23:26 <amalloy> smurfendrek123: readThing :: (String -> Maybe a) -> IO a
14:23:27 <hyperisco> dmwit, good enough
14:23:38 <dmwit> hyperisco: What would be better?
14:23:45 <hyperisco> @let sizedSubstrings n xs = go n xs (length xs); go n _ _ | n < 1 = []; go 1 xs _ = [[xs]]; go n xs len = do { m <- [1..len-n+1]; let {(b, e) = splitAt m xs}; rest <- go (n-1) e (len-m); return (b:rest) }
14:23:47 <lambdabot>  Defined.
14:23:53 <smurfendrek123> nice
14:24:15 <amalloy> you pass it a validation function for values, and it gives you back IO that produces an acceptable value
14:24:18 <hyperisco> @let partitions xs = fmap (flip sizedSubstrings xs) [1..length xs]
14:24:21 <lambdabot>  Defined.
14:24:30 <hyperisco> > partitions "123"
14:24:33 <lambdabot>  [[["123"]],[["1","23"],["12","3"]],[["1","2","3"]]]
14:24:50 <dmwit> hyperisco: Whoa, whoa. If you wanted all the different sizes I'm going to implement it differently. You said you wanted all the partitions of a given size.
14:24:54 <Axman6> wdanilo: what, you mean I installed the initial release of something and it's not perfect? I am shocked! :P The tutorial was pretty fun, but performance could definitely be improved
14:25:00 <hyperisco> dmwit, did I? I don't think I did
14:25:28 <dmwit> <hyperisco> what is all ways to split a list into n contiguous subsequences
14:25:50 <hyperisco> > (\xs -> minimumBy (comparing length) . fmap (mconcat . filter (xs /=)) . partitions) "not" "I am not not happy about this!"
14:25:55 <dmwit> If you didn't want a specific number, you shouldn't have said "n"!
14:25:55 <lambdabot>  error:
14:25:55 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
14:25:55 <lambdabot>        Expected type: [[Char]]
14:25:55 <amalloy> smurfendrek123: candidateCompare dep reqlist = comparing (Down . getMatchingPercentage dep reqlist) <> comparing (\(_,_,wage) -> wage)
14:26:10 * hyperisco is perplexed
14:26:13 <hyperisco> :t partitions
14:26:15 <lambdabot> [a] -> [[[[a]]]]
14:26:31 <dmwit> You want concatMap, not fmap.
14:26:38 <hyperisco> yup
14:26:40 <amalloy> where you have to import comparing, Down, and perhaps <>, but then you don't have to write all this cacading LT/GT/EQ stuff yourself
14:26:41 <hyperisco> @undefine
14:26:41 <lambdabot> Undefined.
14:27:43 <wdanilo> Axman6: performance is my priority number 1 starting next week. There was to many things to finish before release so we were not touching performance for the last 2 months and now we will be preparing Luna 2.0 release - performance focused one :)
14:28:02 <Axman6> Sounds good :)
14:28:06 <wdanilo> Axman6: anyway, if you like our idea and would like to help us, I'd be more than happy! :D
14:28:23 <hyperisco> > partitions "123"
14:28:30 <lambdabot>  mueval-core: Time limit exceeded
14:28:31 <wdanilo> By the way guys, if anyone likes http://luna-lang.org and would like to help us make it fly, I would be more than happy :D
14:28:31 <amalloy> anyway, simplifications like this are why i disagreed with you when you said the problem isn't suited for haskell. there's built-in machinery to do much of the tedious stuff you did by hand, you just have to know how to use it and recognize the broader patterns your code fits under
14:28:37 <hyperisco> > partitions "123"
14:28:44 <lambdabot>  [["123"],["1","23"],["12","3"],["1","2","3"]]
14:28:52 <hyperisco> > (\xs -> minimumBy (comparing length) . fmap (mconcat . filter (xs /=)) . partitions) "not" "I am not not happy about this!"
14:28:58 <lambdabot>  mueval-core: Time limit exceeded
14:29:08 <hyperisco> okay that might actually take a long time
14:29:48 <hyperisco> > (\xs -> minimumBy (comparing length) . fmap (mconcat . filter (xs /=)) . partitions) "xy" "xxyaxya"
14:29:53 <lambdabot>  "xaa"
14:30:04 <hyperisco> she lives! haha
14:31:01 <hyperisco> so… if you want to remove every occurrence of a substring, you can do so from the partitions of the string :3
14:31:30 <hyperisco> now… you can take a closer look and figure out how to optimise it
14:32:04 <smurfendrek123> amalloy:
14:32:09 <smurfendrek123> what does the <> do?
14:32:16 <hyperisco> it'd be nice to have a logical way to compute the partitions of a string too though
14:33:15 <Welkin> smurfendrek123: <> is mappend from Monoid, or append from Semigroup
14:33:27 <hyperisco> xs such that forall x in xs, the concatenation of x is equal to y  -- that's one direction
14:33:30 <Welkin> it combines two values of the same type
14:33:40 <dmwit> > let splits :: [a] -> [[[a]]]; splits [] = [[]]; splits (x:xs) = do { (b, e) <- zip (inits xs) (tails xs); rest <- splits e; return ((x:b):rest) } in splits "abcd"
14:33:44 <lambdabot>  [["a","b","c","d"],["a","b","cd"],["a","bc","d"],["a","bcd"],["ab","c","d"],...
14:33:45 <dmwit> hyperisco: ^
14:33:47 <hyperisco> but already a problem because we can't sensibly generate xs
14:34:04 <hyperisco> dmwit, cool
14:35:12 <hyperisco> btw, speaking of inits and tails…
14:35:19 <hyperisco> > (inits >=> tails) "hello sailor!"
14:35:26 <lambdabot>  mueval-core: Time limit exceeded
14:35:29 <hyperisco> > (inits >=> tails) "hello sailor!"
14:35:32 <lambdabot>  ["","h","","he","e","","hel","el","l","","hell","ell","ll","l","","hello","e...
14:35:41 <hyperisco> that is all the subsequences :3
14:35:53 <dmwit> substrings
14:36:08 <hydraz> % (inits >=> tails) "hello"
14:36:08 <yahb> hydraz: ["","h","","he","e","","hel","el","l","","hell","ell","ll","l","","hello","ello","llo","lo","o",""]
14:36:24 <hyperisco> uhh
14:37:00 <dmwit> But yes, it's very cute.
14:37:16 <hydraz> % (inits <=< tails) "hello"
14:37:16 <yahb> hydraz: ["","h","he","hel","hell","hello","","e","el","ell","ello","","l","ll","llo","","l","lo","","o",""]
14:37:28 <hyperisco> yeah, contig subsequences
14:39:09 <hyperisco> getting rid of duplicates…
14:39:16 <hyperisco> > (init . tails >=> tails . init) "hello sailor!"
14:39:21 <lambdabot>  ["hello sailor","ello sailor","llo sailor","lo sailor","o sailor"," sailor",...
14:39:28 <hyperisco> also cute :3
14:40:03 <hyperisco> whoops I think I got confuddled
14:40:13 <hyperisco> > (init . tails >=> tail . inits) "hello sailor!"
14:40:16 <lambdabot>  ["h","he","hel","hell","hello","hello ","hello s","hello sa","hello sai","he...
14:40:22 <hyperisco> that looks better!
14:41:32 <hyperisco> could write a poem with that
14:42:18 <smurfendrek123> amalloy: that mappend thing goes over my head, i have no idea what it does
14:43:11 <hyperisco> anyways, an approach I am liking to problem solving is just three steps. 1) generate a space where the solution can be found, 2) find the solution, 3) optimise
14:43:52 <hyperisco> that seems to be the tenants of logical programming (though the optimise part is for the evaluator)
14:45:26 <Gurkenglas_> I am looking for explanatory pages to link in words in terse answers to stackoverflow questions. Can you recommend one that explains that using powerful tools, archetypally recursion, leaves it to the reader to piece together whatfor code shuffles around its numbers; therefore one should use more specialized tools (such as control structures such as lists) when one can so the reader can use the understanding it
14:45:26 <Gurkenglas_> has cached for those tools.
14:45:35 <[exa]> smurfendrek123: import Data.Monoid and try: "asd" <> "qwe"
14:45:38 <hyperisco> actually, so is the generate part, i.e. for the evaluator, but hey
14:46:12 <hyperisco> to adapt to non-logical PLs that seems a reasonable approach
14:46:44 <amalloy> > sortBy (comparing fst <> comparing (Down . snd)) [(x,y) | x <- [1..3], y <- [1..3]]
14:46:46 <hyperisco> aaaand you should get a very simple and obvious solution i.e. a good understanding which should make optimisations clearer
14:46:47 <lambdabot>  [(1,3),(1,2),(1,1),(2,3),(2,2),(2,1),(3,3),(3,2),(3,1)]
14:46:57 <hyperisco> though for this particular problem the optimal solution is already quite obvious
14:47:07 <smurfendrek123> [exa]: that's nice, and i kinda get that, but i have no idea what appending compares would entail
14:47:53 <amalloy> smurfendrek123: comparison functions (those of type Eq a => a -> a -> Ordering) form a monoid, where the identity element is "any two elements are EQ", and mappend f g is "compare based on f, falling back to g if (f x) is EQ to (f y)"
14:48:02 <[exa]> smurfendrek123: it implements a lexicographical comparison.. When comparing strings "abc" and "abd" you are doing comparisons cmp 'a' 'a', cmp 'b' 'b', cmp 'c' 'd'
14:48:35 <[exa]> smurfendrek123: and instead of putting that together with a ugly piece of logic, you notice that the results compose
14:48:59 <[exa]> for example, of you have the comparison results starting with GT, you know that the overall result will be GT
14:49:06 <amalloy> so, (comparing f <> comparing g) establishes a "priority" ordering based on the two characteristic functions f and g
14:49:09 <smurfendrek123> do all monoids need an identity element?
14:49:13 <hydraz> yes
14:49:14 <[exa]> same with LT, and with EQ you need to examine the rest
14:49:15 <amalloy> :i Monoid
14:49:18 <hydraz> otherwise they'd be semigroups
14:49:22 <hydraz> % :i Monoid
14:49:22 <yahb> hydraz: class Semigroup a => Monoid a where; mempty :: a; mappend :: a -> a -> a; mconcat :: [a] -> a; {-# MINIMAL mempty #-}; -- Defined in `GHC.Base'; instance Monoid Data.ByteString.ByteString -- Defined in `Data.ByteString.Internal'; instance Monoid Data.ByteString.Lazy.ByteString -- Defined in `Data.ByteString.Lazy.Internal'; instance [safe] Applicative f => Monoid (Traversed a f) -- Defined in `C
14:49:31 <hyperisco> and you know what we think about semigroups around here
14:49:33 <[exa]> smurfendrek123: in our case: EQ <> EQ <> LT  ---> GT
14:49:37 <[exa]> oh sorry LT
14:50:10 <smurfendrek123> what's the identity element for strings? is it the empty string?
14:50:17 <amalloy> > mempty :: String
14:50:19 <hyperisco> that depends on what mappend is, smurfendrek123
14:50:19 <hydraz> % mempty :: String
14:50:19 <yahb> hydraz: ""
14:50:21 <lambdabot>  ""
14:51:04 <hyperisco> you can't say what mempty is without knowing what mappend is, since the former is stated as a property of the latter
14:51:08 <glguy> hyperisco: Do you have a Monoid instance for String in mind where mempty isn't "" ?
14:51:17 <[exa]> smurfendrek123: similar example - monoid producing functions can also behave like monoids:
14:51:28 <[exa]> > (inits <> tails) "oh hey"
14:51:32 <lambdabot>  ["","o","oh","oh ","oh h","oh he","oh hey","oh hey","h hey"," hey","hey","ey...
14:52:10 <smurfendrek123> what is a monoid producing function? is it a function that returns a monoid, like a function would return a monad?
14:52:19 <Rembane> :t (inits <> tails)
14:52:20 <hyperisco> glguy, no but the question phrasing suggested to me that this should be a sensible question for any type
14:52:20 <lambdabot> [a] -> [[a]]
14:52:32 <glguy> hyperisco: bummer!
14:52:33 <hydraz> smurfendrek123: it's the Monoid b => Monoid (a -> b) instance
14:52:46 <hyperisco> glguy, it'll keep me up at night trying to find one
14:53:00 <amalloy> [exa]: in fact we're already talking about monoid-producing functions: (comparing f) is using that Monoid instance
14:54:25 <smurfendrek123> i'm going to read about what monoids are
14:54:33 <amalloy> smurfendrek123: a good investment of time
14:54:42 <amalloy> monoids are everywhere
14:54:50 <hyperisco> well actually I can think of a Monoid instance for all types, believe it or not
14:55:02 <smurfendrek123> Is it sad that monoids weren't mentioned in my haskell course? (it was only a 6x2 hour haskell course though)
14:55:20 <[exa]> it's good you even have a haskell course.
14:55:22 <[exa]> :]
14:55:36 <hyperisco> glguy, how about undefined and lub? :)
14:55:39 <amalloy> perhaps. there's a lot to cover, especially if you're also trying to teach functional programming
14:55:53 <smurfendrek123> yes it was the first time functional programming
14:56:25 <kadoban> It's probably not *the* most important thing to teach
14:56:39 <hyperisco> that's it, all types are Monoids … tis a pointless class
14:56:42 <amalloy> i wouldn't be too sad if people who've never done functional programming could, after 12 hours, write a fully-functional hello world program and also some maps and folds
14:57:08 <hyperisco> fully functional hello world?
14:57:18 <hyperisco> what does a partially functional hello world look like?
14:57:26 <amalloy> hyperisco: like, a program with a main, rather than something you interact with via ghci
14:57:34 <[exa]> smurfendrek123: anyway, algebraic example: natural numbers form a monoid, where <> is + and 'mempty' is 0. The conditions to be a monoid are: a+0=a and (a+b)+c=a+(b+c). You can check that the same works for lists with ++ and []
14:57:42 <hyperisco> oh, I guess if you're into compiling stuff
14:57:59 <shapr> Sometimes when I'm teaching I'll hand students a main that reads the file, runs id on it, and then prints the output. Then I explain how they can write any code they want to transform the text.
14:58:26 <smurfendrek123> i found it somewhat interesting that writing a hello world program in haskell requires a quite deep understanding of the language (you need to understand monads and pure functions)
14:58:37 <amalloy> hyperisco: it's just, when i was learning haskell i knew a lot about functional programming already, and the stuff i could do in ghci seemed pretty easy, but it was a big psychological hurdle to write an "actual program"
14:58:40 <smurfendrek123> well relative to other languages
14:59:17 <hyperisco> amalloy, 95% of my Haskell is  ghci <filename>
14:59:31 <lyxia> main = print "hello world"   -- how's that worse than in other languages
15:00:05 <smurfendrek123> okay but like io and the do notations are a lot more complicated than in other languages
15:00:10 <lyxia> s/print/putStrLn/
15:00:34 <hyperisco> amalloy, the REPL is helpful for interacting with definitions in a file but a PITA to be longwinded in making definitions
15:01:10 <smurfendrek123> in python prompt is one of the first things you learn, while in my haskell course it was my 5th lesson
15:01:25 <lyxia> Well, understanding all the ins and outs of desugaring can be involved, but you can certainly use do notation with a very superficial understanding
15:01:27 <hyperisco> smurfendrek123, I would say instead that in effect they are just as complicated, but Haskell is lying less about it
15:01:56 <smurfendrek123> well, the implementation might be, but the concepts surrounding it aren't
15:02:03 <lyxia> do this; that; x <- getValue; etc x
15:02:41 <hyperisco> smurfendrek123, I mean that in the same way that in effect  1 + "str"  is just as complicated (in dynamic languages), but Haskell is lying less about it
15:03:10 <smurfendrek123> yes
15:03:13 <hyperisco> smurfendrek123, i.e. you can defer many things to be runtime issues and the perception is "easier"
15:03:23 <hyperisco> because the runtime problem *may* happen whereas the compile problem *always* happens
15:03:30 <smurfendrek123> but other languages don't need other languages for doing io
15:03:39 <hyperisco> go try Rust and you'll probably think the memory management is harder
15:03:58 <hyperisco> but, that's probably wrong. Instead, Rust *always* complains, whereas C++ *sometimes* complains
15:04:48 <smurfendrek123> i wrote a little bit of rust, and the compiler error messages are extremely helpfull, it's lovely, especially if you're messing around a little doing trial and error programming
15:06:39 <smurfendrek123> it usually offers suggestions on how to correct mistakes, which is nice
15:08:53 <ph88> can i allocate a mutable block of memory that will never be deallocated while the program is running ?
15:08:58 <hyperisco> once upon a time, back in 2000 something or other, I was writing HTML
15:09:23 <ph88> hyperisco <3
15:09:25 <[exa]> smurfendrek123: the ability to produce suggestions rapidly disappears when you start adding language expressive power.. GHC does its best imho :]
15:09:38 <hyperisco> and the thing to do was to validate your HTML using W3's online tool … people took pride in the little badge they gave you
15:09:40 <geekosaur> ph88, I can think of several ways. you might say what problem you are trying to solve first
15:09:59 <smurfendrek123> ah i was wondering if there was something fundamental as why askell couldn't do better error messages
15:10:18 <hyperisco> and at some point I got into a conversation where I implied I wrote compliant HTML the first time, usually
15:10:23 <smurfendrek123> but, i'm going to bed, i have my final haskell exam tomorrow, thanks a lot everyone for the help, and the interesting conversation, especially amalloy, metahumor and exa
15:10:38 <ph88> geekosaur, i discussing some things with MarcWeber .. it's suppose to be a game with a lot of users and the game state needs to be recalculated quickly
15:10:42 <hyperisco> and the person I was talking to was in disbelief! but, it is not *that* complicated if you just read the HTML spec
15:11:11 <hyperisco> *most* people just wrote HTML and if the browser displayed their page fine then that was good
15:11:34 <ph88> loved that badge :D
15:11:53 * [exa] mumbles about the dead semantic web
15:12:04 <geekosaur> thing is, the literal answer to the question you asked involves Foreign.Marshal.malloc, but that would usually be a bad solution if it's intended to be used in Haskell as opposed to communicating with C
15:13:03 <hyperisco> like web browsers, some PLs let you be sloppier than others, and this trains the programmer to be sloppy
15:13:12 <ph88> geekosaur, in my opinion each player could be represented by a uint32 and 6x uint16 (= 128 bytes)
15:13:36 <geekosaur> ph88, if you;re going to write it in C, write it in C. Not Haskell
15:14:04 <ph88> MarcWeber is going to write it
15:14:47 <ph88> putting some hmatrix in an IORef would that do it ?
15:14:56 <[exa]> ph88: I'm kindof afraid he wants to write it in C as well
15:15:10 <ph88> he likes haskell it seems :p
15:15:11 <hyperisco> when a programmer reads  if (isFile('foo.txt')) { h = open('foo.txt') }  some will sweat it, some will be oblivious, and others will know what is wrong but make an educated decision to keep it
15:15:18 <Welkin> hyperisco: xhtml?
15:15:56 <ph88> hyperisco, the fact that you didn't check readable permissions ? :p
15:16:08 <hyperisco> if you're the programmer who always sweats it you'll have a problem completing software which runs on a user's computer, because such environments are always dirty, but you can probably investigate a narrow problem really well
15:16:09 <ph88> or maybe that it's not atomic
15:16:12 <Welkin> memory leak
15:16:36 <[exa]> hyperisco: please don't add the missing semicolon so that it never compiles
15:16:39 <hyperisco> if you're the programmer who is oblivious your programs will work some good percentage of the time but you'll be entirely helpless when they don't work
15:17:43 <hyperisco> and if you're the programmer who makes an educated guess to keep it then congrats, you've got some engineering skill, and you can probably make software in time and on budget to run on a user's computer
15:18:11 * hyperisco tends a bit too far towards sweating…
15:18:23 <Welkin> on time and on budget, until management decides to change directions and throw away your work for no reason at all
15:18:38 <hyperisco> well, *can*, but who knows what management does to you :P
15:18:45 <Welkin> engineering/developers are a cost center
15:18:58 <Welkin> they don't care about the quality of your work
15:19:15 <Welkin> only that the company meets its objectives in the fastest, cheapest way possible
15:19:36 <Welkin> so there is a conflict there between good engineering and shipping crap
15:20:32 <Welkin> this is why the "fewer bugs, correct code" argument for haskell will never work as a reason to get copanies to adopt it, unless that is critical to their success, like NASA (or defense)
15:20:48 <hyperisco> ship now fix later
15:20:55 <Welkin> for web apps, yes
15:20:59 <Welkin> that is exactly how it works
15:21:06 <hyperisco> digital distribution was perhaps a bad idea :P
15:21:15 <Welkin> which is fine in the beginning, but if you are running a substantial organization, that is foolish
15:22:26 <Welkin> shit broke almost daily at the company I was working with that ran on some legacy, bug-riddled rails app that no one has touched in 4 years, and some garbage java server that no one understood, and many of the critical functionality lived in stored procedures in the database
15:22:30 <Welkin> it was a mess
15:22:33 <Welkin> every day was a fire drill
15:23:13 <Welkin> they spent an entire year trying to figure out a way to reduce downtime
15:23:17 <Welkin> it's staring them right in the face
15:23:38 <Welkin> but they refuse to see it because they are comfortable with how everything is broken, but in a way they are familiar with
15:24:01 <Welkin> I believe downtime went up
15:24:09 <Rembane> Sounds like a very human thing to do.
15:24:28 <Rembane> When the robot overlords take over Haskell usage will increase to over nine thousand percent.
15:24:37 <Welkin> they blamed the wrong things, because they were parts of the system that they did not work on
15:24:47 <Welkin> their precious projects could never do any wrong
15:25:04 <Welkin> even though they were 95% of the problem
15:25:09 <Welkin> but, nope
15:25:10 <Welkin> politics
15:25:29 * dogweather as a Rails developer who hates it, I'm really enjoying this conversation
15:25:34 <Welkin> haha
15:27:44 <hodapp> part of why I started using Haskell at a job was because I had a boss who was changing specifications multiple times per day, so I needed to be able to refactor *really* quickly.
15:28:00 <hodapp> and oddly enough this worked really well using Ivory for C code, and a build with Shake
15:32:59 <Welkin> hodapp: I've been looking for a chance to use Ivory
15:33:09 <Welkin> or any of the similar DSLs
15:33:39 <hodapp> Welkin: I'm not aware of *any* similar DSLs (at least nothing general-purpose like Ivory)
15:33:52 <Welkin> I thought there were a few
15:34:55 <Welkin> https://hackage.haskell.org/packages/#cat:Embedded
15:35:35 <Digit> to those of you ever involved with making haskell and ghc and ghci, in case this is not said enough: thankyou.  :)
15:36:33 <hodapp> well... Atom isn't really maintained and mostly does strongly-timed stuff; Copilot is sort of the same deal for strongly-timed data streams, SBV (not listed) does some pretty specific formally-verifiable cases that can generate C code
15:36:42 <hodapp> and Ion is just... mine :P
15:37:03 <hodapp> so what I mean is that the only one I know of that handles the general case of an EDSL that targets C is Ivory
15:37:05 <Welkin> now we just need a haskell to rust compiler
15:37:13 <hodapp> though, inline-c from fpcomplete looks neat too
15:37:19 <Welkin> so you can compile your rust to javascript
15:37:30 <hodapp> whaaaa
15:37:31 <Welkin> yeah, I was thinking inline-c as well
15:37:35 <Welkin> but that's a bit different
15:37:40 <hodapp> it is but it looks like some good work
15:37:55 <hodapp> I used Ivory to target an embedded system, but as I understand it, inline-c is more for embedding C inside the Haskell runtime
15:38:21 <hodapp> and somebody just came out with some inline LLVM thingy too, supporting quasiquoting & antiquoting
15:38:40 <Welkin> It reminds me of how you can drop assembly right into your c source code
15:39:29 <hodapp> did you have anything in particular in mind you were looking to do?
15:39:36 <Welkin> no
15:39:48 <Welkin> I just like playing with low level programming sometimes
15:40:07 <hodapp> there's the entire Lava family of EDSLs that target FPGAs
15:40:48 <hodapp> and CλaSH and Reduceron
15:41:04 <MarcelineVQ> "<hodapp> inline-c is more for embedding C inside the Haskell runtime" that sounds more like jetski   https://github.com/ambiata/jetski
15:41:28 <hodapp> Welkin: but, if you just want to mess around, SBV has excellent docs, from what I've seen
15:41:43 <hodapp> MarcelineVQ: huh, that's a new one to me
15:42:00 <MarcelineVQ> what is SBV?
15:42:32 <hodapp> MarcelineVQ: https://hackage.haskell.org/package/sbv but at this point I don't remember enough to explain it well
15:42:35 <MarcelineVQ> thank you
15:42:50 <hodapp> it also lets you extract C code from what you write, I believe
15:42:57 <hodapp> for simple but provably-correct algorithms
16:14:57 <sqooq> euterpea uses arrows mainly because it avoids space leaks, but also for efficiency
16:15:11 <sqooq> I'm ok with a some loss in efficiency, since it's not even realtime anyway
16:15:49 <sqooq> but why was he so sure that lists would be space leaky? Is there any good way to avoid this? He mentions using a proper stream type, are there good stream types out there?
16:24:53 <dmj`> @package streaming
16:24:53 <lambdabot> http://hackage.haskell.org/package/streaming
16:40:05 <cheater> hi guys, i'm trying to figure out the cursor position of the mouse on a linux desktop. I'm trying to use sdl2 and its SDL.Input.Mouse.getAbsoluteMouseLocation but that always returns P (V2 0 0), i.e. x=0, y=0. Do I need to initialize sdl somehow? I have it drawing a window so i know SDL itself is initialized, do i need to somehow tell it how to find the mouse? Is there some other thing I'm missing? ...
16:40:11 <cheater> ... Is there a simpler way to find out the mouse location? I don't need it for anything other than a random input value to use as a seed.
16:43:26 <kadoban> cheater: Sounds like a bad idea. What's it a seed for?
16:43:36 <geekosaur> I'd be using X11, not a wrapper around OpenGL
16:44:15 <kadoban> I'd be using /dev/urandom or something similar
16:44:25 <geekosaur> and if you need compatibility with Wayland, use OpenGL directly: one of the problems you get with e.g. sdl is that it abstracts the different ways that unix and windows GUIs work, which complicates things like mouse position
16:49:51 <geekosaur> https://tronche.com/gui/x/xlib/window-information/translate.html
16:51:13 <geekosaur> note that getting it for a monitor is somewhat complicated because of the way multiple monitor support works; you will need to use xrandr functions to find the monitor viewports and map the cursor position on the root window to those viewports
16:51:34 <geekosaur> that said, using cursor position to seed an RNG sounds like a bad idea
16:52:07 <kadoban> For anything that matters, it's not enough entropy. For anything that doesn't matter ... it's just too hard to bother with.
16:52:57 <geekosaur> pretty much, yes
16:55:41 <Gurkenglas> So how do you get a random-that-doesn't-matter seed without incurring a dependency?
16:56:18 <kadoban> System.Random seemed to work fine enough last I checked, and it's barely a dependency.
17:08:08 <cheater> geekosaur: what module would you suggest to use X11?
17:10:00 <cheater> https://hackage.haskell.org/package/X11-1.8/docs/Graphics-X11-Xlib-Misc.html#v:queryPointer
17:10:04 <cheater> this looks like it might do it
17:11:05 <geekosaur> yes
17:11:19 <geekosaur> ideally you'd use xhb bit it has about as much documentation as xcb does, which si to say none
17:11:46 <geekosaur> I personally got tired of having to dig through kde source to find out how to use the "new" X11 API
17:24:09 <butterthebuddha> Hey peeps, so I've finished all of CIS 194 Spring 2013, but I don't feel comfortable with Applicatives/Monads
17:24:11 <butterthebuddha> What's a good next step?
17:24:21 <butterthebuddha> To get comfortable with those
17:24:35 <cheater> geekosaur: xhb? xkb?
17:24:38 <cheater> er
17:24:42 <cheater> xhb? xcb?
17:24:52 <cheater> oh https://hackage.haskell.org/package/xhb
17:25:04 <cheater> what's xcb though?
17:25:08 <Axman6> The Data61 course has quite a lot of using Applicative and Monad - it covers a lot of what's in CIS 194 but IIRC has a more fundamental focus
17:25:15 <geekosaur> xhb is a mechanical translation of the wire X11 protocol to Haskell, just as xcb is a mechanical translation of the wire X11 protocol to C
17:25:24 <cheater> https://en.wikipedia.org/wiki/XCB
17:25:26 <cheater> gotcha
17:25:30 * Axman6 is currently in the middle of presenting the Data61 course at Data61, so may be biased)
17:25:44 <dmwit> butterthebuddha: You Could Have Invented Monads, All About Monads are my two favorites.
17:25:46 <geekosaur> xcb is the "preferred" way to interface with X11 --- but you will go insane if you don;t use a toolkit wrapper like gtk or qt/kde
17:25:58 <dmwit> ?where aam
17:25:58 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
17:26:02 <cheater> i just want the mouse position
17:26:05 <dmwit> ?google you could have invented monads
17:26:06 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
17:26:06 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
17:26:34 <butterthebuddha> Axman6: I
17:26:37 <butterthebuddha> 'll give that. shot
17:26:40 <butterthebuddha> s/./a
17:27:03 <butterthebuddha> dmwit: thanks, I'll check those out too
17:29:36 <Axman6> butterthebuddha: the Data61 course is intended to be done as a course where explanations are presented by someone, but if you've done 194 I think you'll find a hell of a lot of it familliar
17:36:32 <cheater> looks like xhb might have what i need too
17:37:11 <cheater> geekosaur: does that look like what i'm looking for? https://hackage.haskell.org/package/xhb-0.6.2015.8.1/docs/Graphics-XHB-Gen-Input.html#t:GetDeviceMotionEventsReply
17:37:39 <geekosaur> the whole Gen hierarchy looks like extensions to me
17:37:56 <geekosaur> that's the XInput extension. which might work but seems like overkill
17:39:54 <dogweather> I still haven't found an explanation of monads that I think is good ;-)
17:40:07 <dogweather> specifically for the experienced programmer
17:40:18 <sqooq> dogweather, waat
17:40:44 <dogweather> Too many are navel-gazing, hide the ball, and overly focused on implementation details
17:41:02 <sqooq> when you say "explanation of monads" what do you mean
17:41:15 <cheater> geekosaur: what would you use instead?
17:41:18 <cheater> i know 0 about X11
17:41:22 <benzrf> dogweather: there is no good explanation of monads
17:41:31 <cheater> also.. i'm getting a build error on xhb, and i don't know what to do about it :S http://lpaste.net/361744
17:41:32 <sqooq> what there are tons of good explanations
17:41:48 <benzrf> sqooq: i dont believe that anybody actually understands monads from reading explanations
17:41:54 <geekosaur> what you linked earlier: https://hackage.haskell.org/package/X11-1.8/docs/Graphics-X11-Xlib-Misc.html#v:queryPointer
17:41:57 <sqooq> here's a really good one liner
17:41:58 <sqooq> (>>=)  :: m a -> (  a -> m b) -> m b
17:42:02 <geekosaur> it's not worth trying to use rawe xcb or xhb
17:42:03 <cheater> geekosaur: you said to use xhb though
17:42:05 <benzrf> i mean
17:42:06 <cheater> ok
17:42:07 <sqooq> there you go, there's the explanation of monad
17:42:09 <benzrf> if you consider that an explanation :P
17:42:26 <geekosaur> no, I said that's what the current "wisdom" is. but then they tell you not to use those but to use gtk or qt
17:42:37 <dogweather> As an experienced dev in many languages and paradigms, I'd like to see an explanation that makes analogies to things I already know
17:42:53 <dogweather> Same goes for Functor.
17:42:54 <geekosaur> when they get around to realizing that you can;t sanely program in raw x{c,h}b because there's no documentation
17:43:12 <cheater> the doc was good enough for me it would seem
17:43:18 <sqooq> dogweather, o well I started with haskell, so I guess I can't help there.
17:43:21 <dogweather> IMO Functor should be described as "The Functional Programming equivalent of Enumerable"
17:43:25 <geekosaur> it's not
17:43:28 <cheater> but xhb doesn't build
17:43:29 <sqooq> it's not
17:43:32 <MP2E> every time I've seen a Monad tutorial and begins with an analogy to something from another programming language it usually ends up more confusing than anything
17:43:42 <MP2E> that begins with*
17:44:07 <dogweather> IMO, we need more docs for experienced devs. And each doc should start with the API, not with the implementation
17:44:20 <sqooq> I've heard and it's probably true that learning haskell is best done with a blank slate, that is, not trying to relate everything to other paradigms
17:44:42 <Clint> we'll never know
17:44:43 <cheater> hum ho
17:45:03 <jle`> dogweather: haddocks do that, don't they?
17:45:19 <dogweather> I find that most/all descriptions of monad hide how to actually recognize and use one.
17:45:36 <DigitalKiwi> I heard they are burritos
17:45:52 <dogweather> IMO, recognizing one in haskell is the hard part, because it's denoted like many things are - a letter and a space
17:45:59 <parsnip> they represent impurity </troll>
17:46:23 <jle`> dogweather: by recognizing one, do you mean seeing in the docs that it has a Monad instance?
17:46:33 <dogweather> jle`: I mean, in code
17:46:43 <sqooq> dogweather, ???
17:46:49 <sqooq> Check if there's an instance for it
17:46:50 <jle`> for example, if you go to the docs for Maybe
17:46:52 <dogweather> Just understanding a fragment, X Y Z. What is that, exactly?
17:47:04 <jle`> https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Maybe.html
17:47:09 <parsnip> check each one?
17:47:11 <jle`> you see right there -- Monad Maybe :)
17:47:15 <sqooq> Like in a type declaration?
17:47:21 <dogweather> Yeah, a type decl mostly
17:47:26 <sqooq> It's the type
17:47:28 <krobzaur> Hello haskellers. I've dipped my toes into this strange and mysterious sea for one reason: I need to write a plugin for my gitit wiki. Is anyone willing to help me work this out?
17:47:30 <sqooq> so if you want to know what it means
17:47:33 <parsnip> you might see (Monad m) =>
17:47:33 <sqooq> see how the type is defined
17:47:58 <sqooq> if you see >>= being used, you can assume it's a monad
17:48:00 <parsnip> haskell ain't much of a dip in langauge.
17:48:09 <sqooq> likewise if fmap is being used, you can assume it's a functor
17:48:12 <jle`> usually when you "use a monad", you won't see Monad m =>, or >>=
17:48:12 <krobzaur> Anyone here familiar with the inner workings of gitit and pandoc?
17:48:21 <jle`> you'll just be using Maybe, list, IO, etc.
17:48:30 <krobzaur> pasukon: Yeah I'm starting to realize this as I read and experiment a bit :)
17:48:40 <jle`> krobzaur: ask a question if you have it :)
17:48:53 <dogweather> So e.g. when using TagSoup and I see the type Tag Text ... what do those 8 characters mean?
17:49:04 <jle`> dogweather: well
17:49:06 <jle`> it's invalid haskell
17:49:09 <dogweather> Text in the Tag monad?
17:49:16 <jle`> oh, 'Tag Text'?
17:49:19 <jle`> it means the type 'Tag Text'
17:49:23 <jle`> Tag isn't necessarily a monad
17:49:27 <jle`> it's just a parmaeterized type
17:49:34 <jle`> it's something like Tag<Text> in languages like java, c++, etc.
17:49:38 <dogweather> Ah hah
17:49:39 <parsnip> monad isn't special
17:49:53 <Clint> dogweather: https://hackage.haskell.org/package/tagsoup-0.14.2/docs/Text-HTML-TagSoup.html#t:Tag
17:50:01 <sqooq> yeah, tag doesn't have a monad instance
17:50:02 <dogweather> So "IO Text" ...
17:50:12 <krobzaur> jle`: Ok, first question. I'm just trying to get a super minimal example running. But! When I try to run my program I get the following error message: .cabal/lib/x86_64-linux-ghc-7.10.3/regex-pcre-builtin-0.94.4.8.8.35-BIKRAWcSf3b5TrVwkdIXKu/libHSregex-pcre-builtin-0.94.4.8.8.35-BIKRAWcSf3b5TrVwkdIXKu.a: unhandled ELF relocation(RelA) type 42
17:50:12 <sqooq> dogweather, I think you're mixing up type constructor with monad
17:50:15 <krobzaur> gitit: gitit: unable to load package `regex-pcre-builtin-0.94.4.8.8.35'
17:50:15 <jle`> dogweather: yes, that's somewhat syntactically equivalent to IO<Text>, in languages like java and c++
17:50:23 <dogweather> Is that also parameterized type?
17:50:30 <jle`> IO is a parameterized type, yes
17:50:37 <sqooq> IO is also a monad
17:50:37 <dogweather> ok, cool
17:50:42 <jle`> and there it is parameterized by the type 'Text'
17:50:50 <dogweather> yeah, i'm having trouble just parsing haskell :-)
17:50:55 <sqooq> But not all parametrized types have an instance of monad
17:51:08 <sqooq> are an instance of monad (?)
17:51:24 <dogweather> sqooq: good q
17:51:26 <krobzaur> oh, sorry about the double lines. But anyway, I'm not really sure what to make of that message. I've checked that the regex-pcre-builtin module is installed.
17:52:09 <sqooq> dogweather, just linguistics really.
17:52:23 <sqooq> has an instance, is an instance, idk what the proper usage is.
17:52:34 <sqooq> I think both are used actually.
17:52:47 <lyxia> krobzaur: what distro are you on
17:52:50 <Clint> krobzaur: you might have a PIE/no-PIE issue there
17:52:51 <jle`> dogweather: reading an introduction to haskell usually helps with the syntax :)
17:53:13 <sqooq> dogweather, or better yet read the language specification
17:53:13 <dogweather> jle`: lol, hasn't in my case.
17:53:22 <jle`> :(
17:53:26 <dogweather> And I've been writing tons of Haskell too.
17:53:29 <krobzaur> lyxia: ubuntu 16.04
17:53:37 <dogweather> https://github.com/public-law/nevada-revised-statutes-parser
17:53:37 <krobzaur> Clint: What does that mean?
17:54:55 <geekosaur> krobzaur, some Linux distributions have switched to requiring Position-Independent Executables for security reasons. this requires that libraries and executables be built differently, including new kinds of relocation entries that older linkers can't process
17:55:17 <geekosaur> so it may be that your Haskell installation was intended for one of those, but the system you're on can't deal with it
17:55:44 <aplainzetakind> I have zero parsing experience. Which library would you recommend to learn as quickly as possible to be able to parse this: view-source:https://en.wiktionary.org/w/index.php?title=&action=raw
17:56:29 <krobzaur> geekosaur: Woah, ok thanks for the pointer I'll google around a bit
17:56:40 <cheater> nice geekosaur X11 did work
17:56:51 <sqooq> aplainzetakind, probably parsec of attoparsec
17:57:10 <cheater> thanks for the tip
17:57:12 <sqooq> aplainzetakind, if you want to have a wider understanding, learn about how applicative parsers work, there are a few good papers
17:57:16 <geekosaur> I'd see if pandoc already has a parser for it first, to be honest
17:57:46 <sqooq> dogweather, did you write brute force parser?
17:58:10 <dogweather> Clint: I looked at the TagSoup/Tag doc... but I don't see where that describes how it's parameterized
17:58:44 <Sveta> do we have #gitit users here? someone is looking for help with plugins writing for this wiki using HAppS, pandoc, and git. they're in its channel now.
17:58:47 <Clint> dogweather: "str" is the type variable you have filled with "Text"
17:59:04 <Clint> Sveta: is it krobzaur?
17:59:07 <Sveta> yes
17:59:30 <sqooq> dogweather, Idk exactly what parameterized means, but type constructors are a haskell feature, not library specific
17:59:36 <aplainzetakind> geekosaur: It seems it does. I'll see what sort of output it produces.
17:59:38 <sqooq> data Tag a = ...
18:00:54 <krobzaur> Clint: Yup!
18:01:20 <krobzaur> Wow IRC is pretty awesome
18:01:56 <leley1> How does Haskell compare to Rust?
18:02:39 <cheater> it doesn't
18:02:42 <cheater> apples and oranges
18:04:20 <leley1> Why?
18:06:41 <sqooq> leley1, it's just way different
18:08:06 <sqooq> i haven't used rust much though
18:08:25 <parsnip> rust is imperative. there, different.
18:08:56 <MP2E> Rust is lower level, in that you're working closer to assembly, and has an emphasis on zero cost abstractions. It is an imperative language first, with interesting features brought over from many other languages. Haskell is at a higher level of abstraction. It has an RTS and garbage collector, is in the family of functional programming languages, and features a different evaluation model from most programming languages (non-strict vs strict)
18:09:02 <MP2E> and that's just a flyby explanation
18:09:44 <parsnip> maverick!
18:10:10 <MP2E> They're both pretty neat, in my opinion. I like Haskell more, but.. I am hanging out in #haskell after all :P
18:10:22 <koz_> Yeah, pretty much what MP2E said, on all accounts.
18:13:25 <leley1> What about performance and avoiding crashes?
18:14:44 <sqooq> haskell is the fastest language on earth
18:14:55 <sqooq> jk
18:15:02 <MP2E> If you absolutely need realtime performance guarantees, like with a microcontroller running something mission critical, it'd be safer to go with Rust because you have a lot more direct control over the code being produced
18:15:08 <MP2E> Haskell's gc can also introduce pauses
18:15:13 <MP2E> but for most workloads? haskell is really fast
18:15:14 <MP2E> surprisingly so
18:15:22 <DigitalKiwi> insert joke about no side effects so nothing ever gets done
18:15:46 <dogweather> Clint: thanks!
18:16:13 <leley1> What do you mean with that the other language has more direct control?
18:17:17 <MP2E> Well with Rust you can directly control when memory is allocated/freed, and whether it goes on the stack or the heap. Haskell doesn't allow for that sort of fine grained memory access as far as I know. It expects you to draw up a higher level 'specification' of the program, and the garbage collector handles memory for you
18:17:40 <MP2E> For workloads the GC is great at this works perfect, but all garbage collectors have tradeoffs
18:17:50 <MP2E> so that makes haskell a bit less flexible in this regard
18:18:12 <dogweather> What do you all think of Elixir? It seems like it gives up purity of abstractions in exchange for a simpler language
18:20:53 <leley1> I don't know, and what do you think about the best language for performance (on hardware)?
18:22:37 <MP2E> probably C/C++ still, because of the sheer amount of man hours thrown into optimization so far
18:22:43 <MP2E> Not familiar with Elixir, will have to take a look
18:25:23 <leley1> Can Haskell be optimized as well?
18:26:39 <kadoban> Ya of course, you can always profile and tune. You can get pretty deep into optimization in haskell and end up with good results.
18:27:26 <sqooq> and it's likely to only get better in the future, just like C
18:27:31 <kadoban> Typically you won't end up as performant as optimized C or C++, with natural-looking haskell code, but you can get close in my somewhat limited experience.
18:27:45 <kadoban> And there's always the option of FFI
18:27:48 <geekosaur> haskell can be harder to optimize, because it encourages much higher level abstractions that C or Rust don't have
18:29:15 <leley1> Alright but let's say that with time, we could get Haskell (or Rust) optimized getting better results in performance than C or C++ right? In this situation, would it be better to choose these programming languages looking to the future?
18:29:27 <MP2E> Yeah. Currently it depends a bit on workload. I can't quite recommend Haskell for say, AAA 3D game development *yet*. But the future is bright for the language. I'm excited for the potential ability to swap out garbage collectors in GHC at some point in the future, I think that combined with the exciting research into Functional Reactive Programming, Linear Types, and Dependent Types could lead to a language that is good at everything, given enou
18:29:28 <MP2E> gh man power thrown at it
18:31:17 <MP2E> haskell as-is is already pretty awesome, but there's so much exciting stuff on the horizon
18:32:38 <Welkin> what horizon?
18:32:43 <Welkin> zero dawn?
18:32:47 <MP2E> lol
18:32:51 <Welkin> I need to continue playing that
18:33:56 <leley1> We were talking about how C and C++ are considered better in performance for optimization, while Haskell is not there yet but could be in the future if optimized
18:34:10 <ReinH> Elixir is Erlang with better syntax.
18:34:20 <hydraz> "better"
18:34:31 <Axman6> leley1: " we could get Haskell (or Rust) optimized getting better results in performance than C or C++ right" this is definitely not an unreasonable thing, it's not like either of these languages are even 10x slower
18:34:32 <ReinH> Joe Armstrong things it's better.
18:34:37 <ReinH> *thinks
18:35:07 * Axman6 spots the "defer to authority" fallacy
18:35:21 <ReinH> It's not a fallacy when the authority is relevant
18:35:25 <ReinH> It's the opposite of a fallacy
18:35:53 <Welkin> ReinH: better in what way?
18:36:02 <Welkin> people keep on saying that, but I disagree
18:36:07 <Welkin> I think elixir's syntax sucks
18:36:07 <leley1> Sorry if you're being ironic or not, I won't get it because I'm noobie
18:36:25 <Welkin> erlang is superior in so many ways
18:36:26 <sqooq> leley1, they're being straight forward.
18:36:38 <Welkin> the only thing elixir has going for it is the tooling
18:36:45 <sqooq> leley1, It's not unreasonable they're saying, because C isn't that much slower to begin with.
18:36:59 <Axman6> s/slower/faster
18:37:04 <Axman6> I assume?
18:37:23 <sqooq> aghh
18:37:23 <sqooq> yes
18:37:33 <sqooq> replace slower with faster lmao
18:37:51 <leley1> And why do you consider erlang better?
18:37:56 <sqooq> Anyone know anything about streams and space leaks
18:38:13 <Axman6> anyway, if Haskell had even one tenth of the effort we've put in as a species in optimising it as we have done done with C, I doubt there's be much difference at all. And it's been shown you can write haskell code that's as fast as C
18:38:35 <Axman6> sqooq: yes, I know at least one thing about each. Ask your question ;)
18:39:12 <sqooq> :thinking:
18:39:19 <sqooq> I guess I don't have a question
18:39:27 <sqooq> Can it be avoided?
18:39:30 <Axman6> problem solved!
18:40:10 <Axman6> yes, spaceleaks can be avoided with streaming programs
18:40:15 <MP2E> Yes. The hardest part of dealing with a space leak is finding it. Fixing it usually isn't a big deal. (and finding it isn't as scary as it's made out to be)
18:40:27 <sqooq> I'm using euterpea, an audio library that is very good, but it uses arrows because it does better with space leaks and is more efficient.
18:40:32 <sqooq> But goddamn I hate arrows
18:41:02 <Axman6> arrows are pretty painful in my experience
18:41:12 <Axman6> (which is pretty limited, to be honest)
18:41:26 <sqooq> So wondering if it's worth my time to try and do a streaming version arrow-free
18:41:46 <Axman6> they are a good abstraction for things like signal processing though
18:42:01 <leley1> So what do you think about Haskell vs Erlang?
18:42:06 <sqooq> I can do lists, and have done lists, just fine, and in the small examples I've done, they weren't too problematic, they are very slow but that's because I literally implemented everything in probably the least efficient ways possible.
18:42:16 <sqooq> (mfw I didn't even cache my sine function)
18:42:40 <Axman6> leley1: why not see what the developers of the both have to say about them? https://www.infoq.com/interviews/armstrong-peyton-jones-erlang-haskell
18:42:41 <Welkin> leley1: they are completely different languages
18:42:44 <MP2E> right after I said "fixing them usually isn't a big deal" I realized that FRP libraries greatly complicate that situation :v oops
18:43:02 <Welkin> erlang is technically general purpose, but it was only made for one use case: building fault tolerant real-time systems
18:43:07 <Axman6> but yeah, they don't have a whole lot in common in many ways
18:43:09 <Welkin> and that is really all it's good for
18:43:28 <Welkin> haskell is a general purpose language useful for many things
18:43:40 <Welkin> I use it for web dev on the backend and frontend
18:43:41 <Welkin> for games
18:43:58 <Welkin> for shell scripts
18:44:06 <Welkin> really, anything you want
18:44:39 <Welkin> erlang is a very simple language and is fun to learn
18:44:55 <Welkin> you can pick it up very quickly, maybe in a weekend
18:45:07 <leley1> Do you know the package management system of Gentoo: Portage? It's written in Python. Could it be rewritten in Haskell?
18:45:18 <Welkin> of course it could
18:45:54 <ReinH> I think Erlang is somewhere between general purpose and special purpose.
18:45:55 <sqooq> Gentoo has a package manager?
18:46:02 <ReinH> It can do a lot of things, but I wouldn't write shell scripts with it.
18:46:04 <sqooq> I thought it was all about building everythingfrom source
18:46:21 <MP2E> well yeah but the package manager orchestrates the building so you don't have to manually run all the build scripts
18:46:24 <MP2E> hehe :p
18:46:39 <MP2E> if you had to do that that would be.. quite painful
18:46:46 <ReinH> MP2E: like some sort of cave person
18:47:54 <leley1> The package manager builds from the source given the instructions
18:48:14 <leley1> It shapes programs to the hardware from zero
18:48:20 <sqooq> Axman6, what do you think about my predicament? Stick with arrows, or try and get rid of them?
18:49:11 <ReinH> sqooq: I mean, presumably they're using arrows for a reason
18:50:24 <sqooq> ReinH, I think mainly to avoid space leaks, but also for efficiency
18:50:37 <sqooq> but tbh I think efficiency can be diminished a bit and it would be worth it to avoid arrows
18:50:51 <sqooq> since euterpea is super fast but isn't even realtime so it doesn't actually matter that much
18:52:07 <ReinH> I mean, arrows are a particular abstraction of computation. You would need something that provides the expressive power that they are currently providing.
18:52:09 <sqooq> but then again, it's better to be safe for when realtime can be implemented
18:52:46 <sqooq> ReinH, well everything they're doing I can do with lists, right now.
18:55:36 <koala_man> is there a 'bracket' equivalent I can use with Parsec?
18:58:33 <ReinH> koala_man: bracket from where?
18:59:00 <sqooq> also anyone remember I was struggling with delay lines? Euterpea does f**cking unsafeIO
18:59:18 <sqooq> implementing it exactly like imperative as far as I can tell
18:59:21 <sqooq> https://hackage.haskell.org/package/Euterpea-2.0.4/docs/src/Euterpea-IO-Audio-BasicSigFuns.html#Table
18:59:34 <sqooq> search for "Buf"
18:59:44 <koala_man> ReinH: Control.Exception. I'm mostly interested in making sure a function runs whether or not a parser succeeds
19:00:21 <MarcelineVQ> unsafePerformIO isn't a dirty word, it's just intended to be uttered by people who did their homework on it
19:01:19 <Welkin> accurssedUnutterableIO?
19:01:23 <MarcelineVQ> all these worlds are yours, except unsafeInterleaveIO, attempt no landing there
19:13:44 <Axman6> Welkin: shhh! you'll wake the beast!
19:34:19 <sqooq> dangit I disconnected
19:34:35 <sqooq> MarcelineVQ, what do you mean homework on it
19:34:41 <sqooq> where do I go to learn about it so I can do it right
19:37:50 <Sebastian1> Hi! Possible ghc bug??
19:37:56 <Axman6> impossible!
19:38:01 <sqooq> possible...
19:38:08 <Sebastian1> ghc -prof -fprof-auto -rtsopts ./Main.hs && ./Main +RTS -p
19:38:20 <Sebastian1> Main: the flag -p requires the program to be built with -prof
19:38:26 <Welkin> unpossible
19:38:51 <glguy> It probably just didn't build anything because everything was already built and hadn't changed since last time
19:38:53 <Sebastian1> I'm using ghc 8.2.2
19:39:07 <Sebastian1> But I see the output that every file is rebuilt?
19:39:37 <Sebastian1> ghc -prof -fprof-auto -rtsopts -fforce-recomp ./Main.hs && ./Main +RTS -p
19:39:43 <Sebastian1> Same error!!
19:39:49 <Sebastian1> "force recomp"
19:39:58 <Sebastian1> What else should I say to ghc :)
19:40:03 <MarcelineVQ> sqooq: I'm not sure, I've not had to do that homework yet :X
19:40:28 <Sebastian1> I also searched for all .hi .o files and deleted them!
19:40:49 <sqooq> MarcelineVQ, I did exactly what they did using ST, idk how safe/unsafe ST is
19:41:08 <sqooq> ST requires a setup first though, unsafePerformIO is nice and hidden
19:41:17 <glguy> Sebastian1: You're got something else fishy going on, works fine here
19:41:19 <geekosaur> "nice"
19:41:31 <geekosaur> it also hides the fatc that it might not do the I/O
19:41:32 <MarcelineVQ> nice and hidden is a scary combo of words hehe
19:41:59 <geekosaur> because it claims to be pure, and the compiler is free to reuse an earlier result or rerun something you would have expected to be remembered
19:42:23 <geekosaur> unsafePerformIO is not an escape hatch. and it will bite you if you try to treat it as one
19:42:39 <sqooq> wait I said I did ST but that's a lie
19:43:02 <sqooq> I never figured out how to get several of these buffers going on at the same time and eventually combining into a single signal
19:45:05 <Sebastian1> glguy: I guess it is perhaps not using the profiling libs that I compiled beforehand correctly
19:45:24 <Sebastian1> Can I manually remove all the profiling libs
19:45:32 <glguy> How are you installing them?
19:45:42 <Sebastian1> or is it better to kill the ".ghc" and ".cabal" dirs
19:45:52 <Sebastian1> cabal install -p --reinstall libABC
19:46:14 <Sebastian1> (I don't use a cabal file or stack.)
19:46:32 <glguy> No, you should rarely ever delete .cabal
19:46:50 <Sebastian1> glguy: It's often advised as a last resort
19:47:07 <glguy> People certainly say to, it's just mostly a bad idea
19:47:13 <Sebastian1> Also, more importantly: Can I tell cabal to compile a single package in parallel?
19:47:26 <Sebastian1> cabal -j only compiles different packages in parallel
19:47:27 <glguy> it's not how you unregister user packages, it's how you delete preferences and the package index
19:47:34 <geekosaur> people who say remove .cabal thereby prove they don't know what is going on
19:47:42 <geekosaur> removing .cabal will ususally *break* things
19:47:54 <Welkin> just use stack
19:47:54 <Sebastian1> Why? I delete .cabal and .ghc together
19:48:02 <Welkin> let it do all the dirty work
19:48:10 <Sebastian1> stack doesn't work with newer version of GHC and cabal-install
19:48:13 <glguy> Sebastian1: maybe delete other random directories while you're at it? that's why
19:48:13 <Welkin> I used to nuke .cabal and .ghc regularly when things broke
19:48:17 <Welkin> sometimes I fixed it
19:48:26 <Welkin> using hc-pkg
19:48:30 <Sebastian1> (GHC 8.2.2. and cabal-install )
19:48:31 <Welkin> but it's easier to just start over
19:48:59 <Sebastian1> Perhaps I can use a cabal sandbox for this package that I am profiling??
19:49:13 <Welkin> Sebastian1: it doesn't?
19:49:48 <Sebastian1> Stack always tells me doesn't work with your GHC/cabal-install...
19:50:01 <Welkin> I'm still on 8.0.2
19:50:15 <Sebastian1> GHC 8.2.2. is about 25% faster
19:50:17 <Welkin> haven't tried 8.2.x yet
19:50:21 <Sebastian1> But too much trouble....
19:50:36 <Sebastian1> I was too early
19:51:55 <glguy> Sebastian1: Perhaps you can put the Main.hs file you're trying to build and then paste the terminal session contents of you building it so that we might have a chance to see what else could be wrong
19:51:56 <Welkin> I learned to not be an early adopter, unless you enjoy things being broken
19:52:01 <Welkin> but someone has to do it
19:52:10 <Welkin> we thank you for your service Sebastian1
19:52:28 <Welkin> this applies to anything, especially operating system updates
19:52:54 <glguy> going on about early adoption isn't going to help figure out how to build with profiling
19:53:43 <Sebastian1> How do I set '-p' as a default in ".cabal"?
19:54:15 <glguy> You can set library-profiling: True in ~/.cabal/config
19:54:58 <Sebastian1> anything else to make it 100% cetraint to force '-p'?
19:55:04 <Sebastian1> thanks for the help btw...
19:55:21 <glguy> This won't help with your current issue, it's justso that you always get the profiling versions of things installed
19:55:40 <Sebastian1> Sorry, but I already nuked .ghc and .cabal
19:55:47 <glguy> oops
20:02:17 <jchia> How can I efficiently read a known number of values of standard types like Int64 or Double from a file into a list or vector using standard little-endian encoding? I used binary, but it took a few seconds to read 20MB of data, which is too long.
20:03:06 <dmj`> jchia:  can you paste your code
20:04:44 <jchia> Also, I suspect it was generating a lot of garbage. http://lpaste.net/361746
20:04:50 <jchia> ^^ dmj`
20:05:00 <Sebastian01> Reading Ints or Doubles is not possible in a performant way.
20:05:28 <Sebastian01> It still takes 500 Microseconds to serialize/deserialize 10 000 Ints or Doubles in Cbor format
20:06:02 <Sebastian01> Can you change how the data is stored? then Cbor would be good; or "store" is even better at serializing
20:06:23 <Sebastian01> My CPU is a 50 degrees because of cabal install :/
20:06:31 <glguy> You can read the file as a bytestring and then convert that into a storable vector
20:06:43 <glguy> Sebastian01: get a better fan?
20:06:45 <Sebastian01> Thank god that cabal is not really mutithreaded :/
20:06:57 <Sebastian01> I'm running at 5Ghz 8700k
20:07:05 <glguy> Ah, there we go
20:07:59 <jchia> glguy: What do I use to convert from bytestring to storable vector?
20:08:54 <jchia> sebastian01: What makes cbor faster in haskell? What package do you use to read it?
20:08:56 <glguy> unsafeFromForeignPtr toForeignPtr
20:09:12 <glguy> cborg and serialise
20:09:30 <Sebastian01> Cbor is the fastest cross plattform serialization library on the planet that I could find
20:09:58 <dmj`> @package vector-binary-instances
20:09:58 <lambdabot> http://hackage.haskell.org/package/vector-binary-instances
20:10:39 <dmj`> should do it for you ^
20:10:59 <jchia> glguy: I think I know how to read a Storable vector from a pointer to a contiguous section of raw bytes. What do with the ByteString, though? It's not a contiguous section of raw bytes.
20:11:09 <Sebastian01> dmj: But this is not like Cbor for cross language things, or?
20:11:14 <glguy> jchia: Yes, that's what a bytestring is
20:12:29 <Sebastian01> I guess most ways to serialize don't really use the SIMD primitatives yet
20:12:37 <Sebastian01> maybe that could help in the future
20:12:50 <jchia> glguy: OK, but how do I get the pointer to the ByteString's data? I search for 'ptr' on the Data.ByteString haddock and find no helpful function.
20:13:08 <glguy> Data.ByteString.Internal.toForeignPtr
20:13:50 <jchia> glguy: OK, that's not on the haddock. I suppose one just has to know it, then.
20:13:58 <Sebastian01> I nuked .cabal and .ghc, same ERROR.
20:14:00 <jchia> Or be familiar with the source
20:14:05 <glguy> jchia: sounds like it
20:14:06 <Sebastian01> Will post terminal output...
20:14:41 <glguy> jchia: Or do the ForeignPtr allocation manuallyl and populate it via System.IO.hGetBuf
20:20:40 <jchia> dmj`: I think using vector-binary-instances, I'll get some complications related to endianness. I believe binary uses BE by default but my data is LE.
20:33:00 <koz_> Does anyone know the name of the paper that describes histomorphisms, if any?
20:37:26 <koz_> Never mind, found it, and the title frankly reads like Haskell humour.
20:37:39 <dmj`> jchia: can you paste your input data
20:41:34 <Sebastian1> Hi again!
20:41:47 <Sebastian1> Here is the potential GHC bug (or more likely, my error):
20:41:48 <Sebastian1> https://www.reddit.com/r/haskell/comments/7r6y9p/possible_ghc_822_bug/
20:42:08 <Sebastian1> ghc -O2 -threaded -eventlog -rtsopts -prof -fprof-auto -rtsopts -fforce-recomp ./Main.hs && ./Main +RTS -p
20:42:10 <Sebastian1> works
20:42:26 <Sebastian1> ghc -O2 -threaded -eventlog -rtsopts -prof -fprof-auto -rtsopts -fforce-recomp ./Main.hs && ./Main +RTS -p -N
20:42:29 <Sebastian1> this fails
20:49:35 <royal_screwup21> suppose I have a data structre like so: data Tree a = Leaf a -- what is "Leaf" called?
20:50:02 <MarcelineVQ> a data constuctor, sometimes called a value constructor.
20:50:28 <royal_screwup21> cool, and and the "a" -- is that termed a parameter?
20:52:06 <MarcelineVQ> yep you can call it a parameter
20:55:46 <MarcelineVQ> you'll see them called arguments as well
20:57:32 <glguy> Typically the a in data Tree a is a parameter and then when you see it used like: Tree Int somewhere, Int is the argument that Tree is being applied to
20:57:33 <ReinH> royal_screwup21: a is a type variable
20:57:37 <MarcelineVQ> specifically  https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-680004.2  calls them arguments,   a  is a type variable that is an argument to Leaf
20:59:19 <royal_screwup21> alrighty
22:08:49 <u-ou> hi
22:57:04 <dminuoso> Is there some typeclass that expresses the idea of "Searchable"? Would that be Foldable?
22:57:27 <dminuoso> (In the sense of folding some data structure into one particular element that satisfies a given constraint)
23:00:17 <ReinH> :t find
23:00:19 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
23:00:34 <ReinH> Is this what you want?
23:01:18 <dminuoso> ReinH: Can we pretend that I didn't and you didn't respond? =)
23:01:20 <mniip> :t \p -> foldMap (mfilter p . Just)
23:01:21 <lambdabot> (Monoid a, Foldable t) => (a -> Bool) -> t a -> Maybe a
23:01:22 <dminuoso> *didnt ask even!
23:01:31 <mniip> no wai
23:01:41 <mniip> :t \p -> alaf First foldMap (mfilter p . Just)
23:01:44 <lambdabot> Foldable t => (b -> Bool) -> t b -> Maybe b
23:01:50 <dminuoso> :t alaf
23:01:53 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor g, Functor f) => (Unwrapped s -> s) -> (f t -> g s) -> f (Unwrapped t) -> g (Unwrapped s)
23:01:56 <dminuoso> What deep magic
23:01:59 <ReinH> That is a silly type.
23:02:18 <mniip> :t foldMap
23:02:21 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
23:02:24 <mniip> :t alaf First foldMap
23:02:26 <lambdabot> Foldable t => (a -> Maybe b) -> t a -> Maybe b
23:02:30 <mniip> :t alaf Sum foldMap
23:02:32 <lambdabot> (Num b, Foldable t) => (a -> b) -> t a -> b
23:02:34 <mniip> et cetera
23:03:57 <dminuoso> ReinH: on the bright side, I must be on a decent path if I naturally expected this to be a Foldable thing. I was so sure that it wasnt in Foldable when I checked last.. :|
23:04:25 <mniip> hmm
23:04:45 <mniip> I think I found a large reason why I'm disappointed with haskell
23:05:32 <dminuoso> ReinH: Oh I know.. I just checked google for "foldable find haskell", and I expected to see `find` directly in the search results..
23:06:27 <mniip> when I look at a certain iteration problem
23:06:43 <mniip> I have this sort of competitive programming approach,
23:06:52 <mniip> "this takes circa 10M iterations
23:07:02 <mniip> 10M is like nothing and should finish in under 0.1s"
23:07:05 <mniip> and then haskell is like
23:07:08 <mniip> > sum [i + j | i <- [1..10000], j <- [1..1000]]
23:07:14 <lambdabot>  mueval-core: Time limit exceeded
23:08:25 <MarcelineVQ> darn that haskell
23:09:03 <mniip> okay sure
23:09:04 <capisce> mniip: took around 11s in ghci here
23:09:11 <mniip> if you add :: Int
23:09:16 <mniip> and if you *compile* it
23:09:33 <mniip> then it's decent
23:09:51 <royal_screwup21> why is Data.Map import with a qualified (like so: import qualified Data.Map as Map) and not directly (like so: import Data.Map)?
23:10:18 <mniip> I like haskell for its expressiveness especially in iteration problems,
23:10:26 <cocreature> royal_screwup21: because it uses identifiers that are also in Prelude, e.g. "map"
23:10:29 <mniip> but it's so... slow?
23:10:44 <mniip> like, why can't I have code that is both nice-looking and fast
23:11:25 <cocreature> mniip: maybe try replacing sum by a "foldl' (+) 0". the default implementation of "sum" for lists uses "foldl"
23:11:44 <ReinH> royal_screwup21: things in that module conflict with things in the Prelude. You can import it unqualified if you want, but then you have to deal with the name clashes some other way.
23:12:01 <mniip> cocreature, doesn't help
23:12:07 <royal_screwup21> hmm okay
23:12:08 <capisce> mniip: which language is better?
23:12:23 <mniip> C is excellent at this game
23:12:31 <mniip> you can pretty much tell how many clock cycles a program takes
23:12:46 <mniip> it is inexpressive though (on the fast side of my nice/fast spectrum)
23:13:04 <capisce> exactly, fast but not nice-looking
23:13:21 <capisce> especially if you want unbounded integer arithmetic
23:13:27 <mniip> nah, ints are fine
23:13:37 <mniip> this sum fits in an int
23:13:45 <capisce> Haskell doesn't know that
23:13:58 <u-ou> ah, what’s the topic?
23:14:04 <mniip> like I said, if you add ::Int it is better but not by mucj
23:14:17 <mniip> u-ou, code that is both fast and nice-looking doesn't exist
23:14:23 <mniip> haskell is nice-looking
23:14:25 <capisce> mniip: returns immediately here when compiled with -O3 and using :: Int
23:14:32 <mniip> compiled right
23:14:38 <capisce> and correct
23:14:45 <mniip> my workflow involves ghci a lot
23:14:54 <capisce> whereas C would return the wrong answer if it didn't fit within 32 bits
23:15:28 <mniip> okay right, can we get an --interactive compatible with -O and -fenable-rewrite-rules
23:15:31 <capisce> mniip: Lisp seems quite nice, you can interactively optimize functions from the REPL
23:15:39 <mniip> I don't like lisp
23:15:48 <mniip> I need my lambda calculus and types
23:16:09 <capisce> just saying, maybe GHCI could learn a few things from Lisp's REPL
23:16:13 <capisce> not saying you should switch to Lisp
23:16:30 <capisce> Lisp's interactive programming story seems to be stronger than Haskell's
23:16:45 <mniip> lisp's RTS is presumably simpler
23:16:50 <dminuoso> capisce: interactive programming seems very incompatible with declarative programming.
23:17:10 <capisce> dminuoso: Unison seems to have a nice approach
23:17:10 <dminuoso> because interaction is extremely imperative. ;-)
23:17:27 <mniip> wrap it in a monad
23:17:43 <ReinH> mniip: you don't get to complain that Haskell is slow if you're deliberately using it in extremely slow mode
23:17:59 <ReinH> GHC is a compiler. It's intended to be used to compile.
23:17:59 <mniip> get me a ghci that compiles all the way to machine code
23:18:21 <mniip> as opposed to half-assing it with BCOs
23:18:43 <ReinH> That's like complaining that a Ferrari has a low top speed but never taking it out of first gear.
23:20:32 <capisce> ReinH: that ignores the fact that GHC and GHCi have different affordances
23:21:04 <capisce> there are workflows supported by GHCi that you can't do with GHC
23:21:13 <ReinH> Yes, and they are slow.
23:21:20 <ReinH> But that's the choice you made.
23:21:25 <otulp> But reload fast :)
23:21:30 <ReinH> You decided to use the slow subset of GHC
23:21:36 <capisce> ReinH: yes, sometimes that is the better choice
23:21:39 <mniip> for lack of a better one
23:21:44 <ReinH> Yes, but then you don't get to complain that it is slow.
23:21:49 <capisce> if there was a better GHCi, this wouldn't be a problem
23:21:57 <mniip> should I state my request a third time
23:22:00 <cocreature> mniip: -fobject-code often helps
23:22:03 <capisce> ReinH: you get to complain about having to make this tradeoff though
23:22:08 <mniip> cocreature, not with interactively input terms
23:22:38 <mniip> -fobject-code compiles the imported modules
23:22:53 <cocreature> oh interesting, I thought it affected the things you type in as well
23:23:14 <u-ou> hmm
23:23:56 <mniip> where's that vacuum
23:24:19 <ReinH> Ok. Show me an interpreter that's as fast as C.
23:24:22 <mniip> is it supported
23:24:29 <ReinH> You're comparing apples to oranges.
23:25:01 <ggVGc> I'm faster than C
23:25:05 <capisce> ReinH: what? who said a REPL needs to be interpreted instead of compiled or jitted?
23:25:08 <mniip> tcc -run
23:25:21 <ReinH> capisce: No one, but it *is* interpreted.
23:25:32 <capisce> ReinH: yes, and the complaint is that no better REPL exists
23:25:56 <ReinH> Ok, I just find the complaint that GHCi is not as fast as C to be ridiculous.
23:26:27 <capisce> anyway, it also seems strange that GHCi the tool has to dictate the way it's implemented
23:27:03 <mniip> $ time tcc -run - <<< "int main(){ int p = 0; for(int i = 0; i < 10000; i++) for(int j = 0; j < 100000; j++) p += i + j; }"
23:27:03 <mniip> real	0m2.498s
23:27:22 <otulp> It is a bit hyperbolic to demand C speed, sure, but it is also not completely unreasonable to think that the repl could possibly compile some of the code. Lisp does it. It's cool and useful.
23:27:24 <capisce> mniip: that's definitely comparing apples to oranges :)
23:27:24 <mniip> this fulfills my expectation of ~1 billion iterations per second
23:28:32 <Lowl3v3l> otulp: though to be fair, not every lisp implementation or dialect does this, for some language its way harder than for others ( and i'd assume for haskell its harder than e.g. for scheme)
23:29:23 <otulp> Sure. I was thinking sbcl, lispworks, cmucl.
23:29:30 <Jeanne-Kamikaze> That program has no side effects though?
23:30:41 <vaibhavsagar> can I use libtool to turn a *.la file into a *.a file?
23:30:42 <otulp> I'm often working in a project with hundreds of modules, only one of which I'm actively mutating. Keeping all those others running "fast" while I muck around would be nice.
23:31:15 <Lowl3v3l> otulp: being an old lisper by trait i feel you, it definitely is a nice feature
23:31:24 <cocreature> otulp: isn’t that pretty much what -fobject-code gives you?
23:31:30 <otulp> Or to be quickly able to verify that the new stuff will turn out "fast enough" by running ":compile myfun" on it.
23:32:22 <Lowl3v3l> vaibhavsagar: in short : no. la files are just descriptions for libtool itself in essence, they don't contain code
23:32:23 <otulp> cocreature: Whopsie. I don't know about that. Will need to check it out. :)
23:33:42 <vaibhavsagar> Lowl3v3l: I'm trying to statically link an executable against gmp6, which doesn't seem to have a libgmp.a in this package
23:33:50 <vaibhavsagar> instead it has a libgmp.la
23:35:12 <ggVGc> man, the SHA package takes so long to build for me
23:35:18 <ggVGc> oh just finished
23:35:19 <mniip> ugh
23:35:26 <mniip> one day I'm gonna be sufficiently pissed
23:35:29 <mniip> and figure out cgroups
23:35:39 <u-ou> angry or drunk?
23:35:39 <mniip> and put ghc in one that can only eat 75% of my RAM
23:35:57 <mniip> my distro has left me without full-oom-kill sysrq...
23:36:47 <ggVGc> hey mniip, do you want type safety or system stability
23:36:54 <ggVGc> we all gotta make the choice
23:37:03 <capisce> false dichotomy
23:37:06 <mniip> not sure how that
23:37:07 <mniip> yeah
23:37:53 <capisce> it's ok to admit our tools aren't perfect
23:37:55 <Lowl3v3l> vaibhavsagar: does the package have a shared library instead?
23:39:19 <vaibhavsagar> yup
23:41:45 <Lowl3v3l> vaibhavsagar: then it obviously just doesn't contain a static build of gmp
23:42:37 <vaibhavsagar> turns out it's a build option that I had to pass :)
23:47:57 <ggVGc> I feel GHC has gotten slower in recent versions. is that just in my head?
23:49:57 <mniip> possibly not
23:50:13 <mniip> ggVGc, around the system FC/TypeInType switchover?
23:50:54 <ggVGc> mniip: not sure, but like, in the past few months?
23:57:17 <mniip> no that'd be 2 years
23:57:53 <ggVGc> oh well
23:57:59 <ggVGc> in other news, haskell-ide-engine has been pretty nice
23:58:05 <ggVGc> been using it the past months
23:58:33 <ggVGc> except it also rapes my memory usage hard sometimes
