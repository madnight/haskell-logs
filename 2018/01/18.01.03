00:00:42 <dminuoso> onEvent :: Event a -> (a -> UI void) -> UI (UI ())
00:01:04 <Marisa_> oh just look at the source code, since to be a unregister handler
00:01:30 * Marisa_ find sometimes source code is less confusing than document..
00:07:09 <Axman6> right, that also makes sense. that should be documented somewhere...
00:11:47 <dminuoso> Whats the point of calling this type variable `void` ?
00:12:10 <Axman6> basically to make it clear that its value is unused and you can't get access to it
00:12:45 <Axman6> it could have been (a -> UI b) but the name makes is clear it's unused, which not forcing to you need to supply something of type a -> UI ()
00:12:57 <Axman6> s/which/while/
00:15:14 <dminuoso> Axman6: Fair enough. Seems to be that `void` is a bit ambiguous, since it has a very different meaning when capitalized. :)
00:15:36 <Axman6> though not completely unrelated
00:16:07 <geekosaur> dminuoso, comes from similar use of Proxy / proxy, when it's not important that it actually be one
00:16:20 <geekosaur> also compare main :: IO a
00:16:30 <dminuoso> Ah, I see what you are getting at.
00:18:28 <Marisa_> wow, writing GUI feel so good, making literally visible progress with every line of code :)
00:20:45 * hackage mmark-ext 0.0.1.2 - Commonly useful extensions for MMark markdown processor  https://hackage.haskell.org/package/mmark-ext-0.0.1.2 (mrkkrp)
00:21:43 <jhu> Hello fellow haskellers. Mind if I vent a little about the state of Haskell literature?
00:23:49 <EnnuiOcclusion>  /join ##programming
00:25:01 <Marisa_> <- this nobody dont care, but why not on r/haskell if you have something new and constructive? Much greater visibility
00:28:04 <jhu> @Marisa_ : Was that response for me? :confused:
00:28:04 <lambdabot> Unknown command, try @list
00:29:19 <Marisa_> yep
00:29:43 <jhu> Marisa_: Ok, thanks.
00:38:15 <ReinH> To make the void situation worse, Agda uses () in impossible patterns, e.g. when asked to produce a Void value.
00:39:05 <ReinH> :t forever
00:39:06 <lambdabot> Applicative f => f a -> f b
00:39:26 <ReinH> This is similar to the void type variable above.
00:40:27 <ReinH> Since there’s no way to produce a f b, you know that the computation never terminates.
00:51:07 <ongy> what's a good way to read a Float literal from Text? Go to String and read?
00:58:49 <dmwit> ongy: Sure, or possibly use `float haskellDef :: ParsecT s u m Double`.
00:59:30 <dmwit> Sorry, `float haskellDef :: ParsecT String u Identity Double`. =P
00:59:45 <ongy> ah, don't feel like pulling Parsec into my dependencies at this point. Safe is fine though
00:59:47 <lyxia> there is Data.Text.Read in text, and there is a text-show package
01:00:08 <dmwit> Oh, even better.
01:02:30 <tsahyt> I'm wondering how to best represent a comment thread, it's essentially a tree so CommentThread ~ Tree Comment (from containers) would make sense. to reply to some specific comment I'll need to be able to reference individual nodes in the tree, so TreePath ~ [Int] could be a way to do that. Then I can have reply :: CommentThread -> TreePath -> Comment -> CommentThread. the downside is that I need to traverse
01:02:33 <tsahyt> the tree every time a reply happens. Does anyone have a better suggestion?
01:03:11 <ongy> oh cool
01:03:13 <tsahyt> I've thought about using a tree zipper, but in order to fetch the whole thread I'll still need to move back up to the root every time, and replying to arbitrary nodes isn't easy with a zipper either, since I need to navigate back there anyway
01:03:53 <tsahyt> actually CommentThread ~ Forest Comment, since there can be multiple roots
01:04:06 <dmwit> Use fgl, possibly.
01:04:59 <tsahyt> afaik there's nothing in fgl to disallow it becoming a DAG. I'd like to enforce the tree structure.
01:05:24 <tsahyt> not just DAG, fgl would allow any arbitrary graph
01:05:24 * dmwit shrugs
01:05:36 <dmwit> Take your pick of safe or fast.
01:06:10 <dmwit> A carefully designed module for fgl-based trees seems like it would be a pretty good tradeoff on that curve to me, but you do you.
01:07:12 <tsahyt> dmwit: I don't think it'd be prohibitively slow anyway. going for a rose tree implementation based on Seq rather than [] would make for pretty quick traversal I think
01:07:39 <tsahyt> though I'd need data on whether those trees are more wide than deep to really make that assertion
01:07:43 <MarcelineVQ> you could cut the middleman and make a fingertree yourself :O
01:08:54 <dmwit> I suppose something like `(IntMap Comment, IntMap Int)` (for the comments themselves, and their parents) would enforce your structure and navigating is very fast (nothing to do).
01:08:55 <tsahyt> MarcelineVQ: I'm not sure what that would buy me tbh
01:09:22 <dmwit> But displaying it is trickier. ;-)
01:10:12 <tsahyt> dmwit: yes I've thought of something like that, though I was thinking IntMap (Comment, Maybe Int), but that's more or less the same. but I think displaying it is really the default use case for comment threads. most users just browse afaik.
01:11:15 <EvanR> are you really thinking about an indexed set
01:11:16 <dmwit> Displaying is cheap if you also keep children pointers as `IntMap IntSet` (say). But then you've lost your structural guarantee again, so: take your pick of safe or fast.
01:11:35 <EvanR> indexes for going from parent to children, and child to parent
01:11:44 <EvanR> two sets, two indexes
01:11:50 <dmwit> I guess event `IntMap Int` loses the structural guarantee. So you don't get safe *or* fast. =P
01:11:50 <EvanR> lots of IntMaps
01:12:07 <dmwit> Oh! I have a cunning plan.
01:12:22 <dmwit> ?hackage ixset =)
01:12:22 <lambdabot> http://hackage.haskell.org/package/ixset =)
01:12:38 <EvanR> ixset is what im talking about but... uses Typeable
01:13:45 <dmwit> But yeah. I don't really think "type system guarantees tree-ness" would be important to me on this one. "Careful library design + module system guarantees tree-ness" would be enough for me, I think.
01:59:36 <luseerr> Hey! Haskell newbe here with several years of JS experience, nice to see community that big :)
02:21:15 * hackage nvim-hs 0.2.5 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-0.2.5 (saep)
02:32:07 <Younder> Is there a mathematical work on stating set theoretical reasoning in sequentential and categorical (topos, fibred categories, etc) which would save me some time
02:32:13 <Younder> ?
02:32:47 <lines> could you clarify what you're asking?
02:33:19 <jle`> luseerr: welcome to haskell! :)
02:34:00 <Younder> I have Goldblats 'Topoi'
02:34:16 <jgt> In Persistent, how do I apply filters only when values are present? i.e., I have something like this: companies <- runDB $ selectList [ CompanyDateOfCreation >=. a , CompanyDateOfCreation <=. b ] [ ]. Both `a` and `b` are `Maybe Day`. If one of them is `Nothing`, then it shouldn't be in the filter list.
02:35:43 <Younder> However I wish to clarify some issues on categorical logic and on categorical type theory. Such as the computational aspecs of implementing them ising bit sequences on a computer.
02:36:29 <Younder> ^ising^ -> using
02:38:31 <Younder> I have 'Computational category theory', but it is quite old. Is there any port 1980 vork?
02:38:53 <Younder> ^port^ -> post
02:42:36 <jgt> I posted my question to StackOverflow too: https://stackoverflow.com/questions/48075750/conditional-filters-in-persistent-query
02:42:40 <Younder> ^vork^ -> work
02:43:38 <Younder> Sorry for my sloppy typing, I am perhaps to used to a multiline text editor.
02:44:56 <Younder> IRC format feels like teletype
03:01:45 * hackage streaming-postgresql-simple 0.2.0.3 - Stream postgresql-query results using the streaming library  https://hackage.haskell.org/package/streaming-postgresql-simple-0.2.0.3 (OliverCharles)
03:36:29 <kriztw> jgt: a hacky solution is [CompanyDateOfCreation >=. a' | a' <- [a]] ++ [CompanyDateOfCreation <=. b' | b' <- [b]]
03:38:26 <jgt> kriztw: what I came up with just now is: maybe [] (\d -> [CompanyDateOfCreation >=. d]) <$> lookupGetParam "from-date"
03:38:52 <jgt> and then I create the filter with `fromDate <> toDate <> ...` etc
03:55:15 * hackage Ordinary 0.2018.1.3 - Short description of your package  https://hackage.haskell.org/package/Ordinary-0.2018.1.3 (MarisaVeryMoe)
04:03:40 <mniip> Short description of your package
04:04:26 <yoho> lel
04:05:57 <AndreasK> makes you wonder if hackage should be mutable
04:11:41 <saurabhn_> is there any way to call Aeson.encode on a value and get an empty bytestring back? Need to make a POST call with an empty payload.
04:11:54 <saurabhn_> i tred `encode ()` but that serialises to `[]`
04:14:33 <nullie> saurabhn_: empty string is invalid json
04:14:48 <nullie> saurabhn_: don't do that
04:14:48 <saurabhn_> but that's what google wants :(
04:15:03 <nullie> maybe you should post with aeson then
04:15:13 <nullie> without
04:15:25 <saurabhn_> how do I make an empty post with Wreq?
04:15:50 <saurabhn_> I tried with `()` but it can't find a Postable instance for it
04:16:16 <nullie> just post with empty string
04:16:34 <saurabhn_> doesn't work with ("" :: String) either
04:16:34 <nullie> I think
04:16:52 <saurabhn_> Could not deduce (wreq-0.5.0.1:Network.Wreq.Internal.Types.Postable String)
04:16:55 <nullie> does the request fail with []?
04:19:19 <saurabhn_> ([] :: [(BS.ByteString, BS.ByteString)]) compiled
04:19:23 <saurabhn_> trying it execute...
04:20:22 <nullie> saurabhn_: try bytesting instead of string
04:20:29 <nullie> docs say it's postable
04:20:43 <saurabhn_> where did you see in the docs?
04:20:50 <saurabhn_> btw [] worked
04:21:37 <saurabhn_> empty bytestring also worked
04:21:58 <nullie> https://hackage.haskell.org/package/wreq-0.5.2.0/docs/Network-Wreq-Types.html under Orphan instances
04:22:15 * hackage language-docker 2.0.0 - Dockerfile parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-docker-2.0.0 (lorenzo)
04:22:15 <saurabhn_> ah okay
04:22:18 <saurabhn_> thanks
04:27:19 <ccapndave> Hi everyone - I'm dabbling in Haskell and one thing I can't quite figure out is how to tell which monad a `do` block is in just by glancing at it.
04:27:27 <ccapndave> Is it the first thing on the right of a <- ?
04:28:39 <nullie> ccapndave: it's type of function
04:30:05 <ccapndave> So if I have `blah : [Int]`, then any `do` anywhere in the body will be in the List monad?
04:30:11 <nullie> I don't know if haskell can infer type based on used function
04:30:15 <nullie> ccapndave: yes
04:30:24 <ccapndave> Simple as that :)
04:30:32 <ccapndave> Is there a way to change monad inside a function?
04:30:34 <nullie> well, not quite, nested dos can use another monad
04:30:46 <ccapndave> In that case what decides their monad?
04:31:19 <nullie> again, type of that do block
04:32:10 <ccapndave> But doesn't the type of the nested do block depend on what's in it?
04:34:22 <nullie> ccapndave: yes, type can be inferred from context
04:34:48 <dminuoso> Oh ccapndave It might help if you dont write in terms of do but >>= instead.
04:34:58 <ccapndave> I think that's my confusion; assuming the type is inferred from the context, where in the do block am I supposed to look in order to figure out what monad its in
04:35:11 <jgt> anyone know how I fix this compiler error? Do I need to stick a signature in there? http://sprunge.us/hiZi
04:35:24 <ccapndave> If I write with >>= then its the type of the thing to the left of >>= right?
04:35:45 <dminuoso> :t >>=
04:35:47 <lambdabot> error: parse error on input ‘>>=’
04:35:50 <dminuoso> :t (>>=)
04:35:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:35:55 <dminuoso> ccapndave: ^- does that answer your question?
04:36:08 <ccapndave> Yup
04:36:15 <ccapndave> But how does that translate to do notation?
04:36:28 <dminuoso> ccapndave: let me show you to visually similar ways
04:37:27 <dminuoso> ccapndave: https://gist.github.com/dminuoso/d99537ab82fe39ad07976c6f62d9645e
04:38:06 <dminuoso> ccapndave: so in do notation you look on the right side of the <- arrow, because the left side is basically just the parameter of the kleisli arrow
04:38:07 <nullie> ccapndave: I thin quux translates to \() -> quux
04:38:07 <ccapndave> dminuoso: So, the type of the value to the right on <- in the do block
04:38:12 <ccapndave> Got it
04:38:24 <ccapndave> And does the first line of a do block *always* have to be a <- ?
04:38:30 <nullie> no
04:38:30 <dminuoso> ccapndave: nope
04:38:43 <dminuoso> ccapndave: <- is basically for >>=, and not using it is basically for >>
04:38:58 <dminuoso> :t (>>)
04:38:59 <lambdabot> Monad m => m a -> m b -> m b
04:39:09 <dminuoso> ccapndave: which means you have to give a monad on lines that dont use <-
04:39:28 <dminuoso> nullie: why?
04:39:38 <dminuoso> nullie: oh well, more generally yeah.
04:39:56 <jgt> oh… I fixed it
04:40:02 <dminuoso> nullie: but in this case no.
04:41:03 <ccapndave> dminuoso: >> is the same as >>= but it just does the side effect and discards the result, is that right?
04:42:00 <dminuoso> ccapndave: Yes. Thats what the type signature says.
04:42:20 <dminuoso> Since the second argument does not use any `a` it cant use it.
04:42:39 <ccapndave> Got it
04:42:44 <ccapndave> Thanks very much!
04:42:52 <dminuoso> cpallares: Its incredible how much intuition you can gain by just staring at the types. :)
04:43:21 <yoho> wrong c<tab> I think
04:43:41 <dminuoso> Oh indeed. Weechat is a bit borked I think.
04:44:17 <dminuoso> ccapndave: And thats the same thing when you just write "quux" in do-notation. Since you dont <- draw its result, you ignore it.
04:44:30 <dminuoso> So thats how not using <- is equivalent to >>
04:44:31 <ccapndave> dminuoso: Got it
04:44:54 <ccapndave> So its either the type of the monad on the first line, or the type of the monad to the right of the <- on the first line
04:45:04 <ccapndave> But its always only the first line I need to look at
04:45:10 <dminuoso> ccapndave: The last rather
04:45:13 <dminuoso> ccapndave: Because
04:45:17 <dminuoso> :t (>>=)
04:45:18 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:45:19 <dminuoso> :t (>>)
04:45:20 <lambdabot> Monad m => m a -> m b -> m b
04:45:27 <dminuoso> ccapndave: See how the result is `m b` ?
04:45:36 <ccapndave> Yes
04:46:15 <ccapndave> The type of the monad can change during the body of the do block
04:46:36 <dminuoso> nullie: So come to think of it.. no. It's not () -> quux :)
04:46:58 <dminuoso> nullie: the () is just a thing that some monadic effects happen to not convey any useful information, but thats different from say
04:47:32 <dminuoso> `a = do getLine; putStrLn "Hi"` which does run the effect of asking for input, but disregarding the result
04:47:56 <dminuoso> ccapndave: the "inner" type can yes. but the monad itself has to stay the same.
04:49:03 <brynedwards> > do _ <- Just 3; [4]
04:49:05 <lambdabot>  error:
04:49:05 <lambdabot>      • Couldn't match type ‘[]’ with ‘Maybe’
04:49:05 <lambdabot>        Expected type: Maybe b
04:50:27 <olligobber> :exf a -> [a]
04:50:27 <exferenceBot> parse error: more than one input
04:50:38 <dminuoso> nullie: In fact that would crash at runtime because it'd try pattern matching () against the actual result
04:50:43 <dminuoso> > [1] >>= \() -> [1]
04:50:45 <lambdabot>  error:
04:50:45 <lambdabot>      • Could not deduce (Num ()) arising from the literal ‘1’
04:50:45 <lambdabot>        from the context: Num b
04:50:54 <olligobber> exferenceBot doesn't like [] I guess
04:50:56 <nullie> yeah
04:51:05 <yoho> It wouldn't be a runtime crash
04:51:18 <yoho> () -> quux would require the previous thing to have a type of m ()
04:51:21 <nullie> > [1] >>= \() -> [1] :: [Int]
04:51:23 <lambdabot>  error:
04:51:23 <lambdabot>      • No instance for (Num ()) arising from the literal ‘1’
04:51:23 <lambdabot>      • In the expression: 1
04:51:32 <dminuoso> yoho: mmm,
04:51:38 <dminuoso> yoho: fair enough. my bad :)
04:51:46 <olligobber> I was curious, since pure and return will both do a -> [a], I was wondering what else would
04:52:01 <nullie> > [1] >>= \_ -> [2] :: [Int]
04:52:03 <lambdabot>  [2]
04:52:10 <dminuoso> olligobber: repeat
04:52:15 <dminuoso> olligobber: also check out hoogle
04:52:17 <olligobber> dminuoso, true
04:52:19 <nullie> I think I mean that
04:52:42 <dminuoso> olligobber: and pure/return dont do a -> [a]
04:52:53 <dminuoso> olligobber: they do (Applicative f) => a -> f a
04:53:12 <dminuoso> (The difference is that its polymorphic in the choice of the monad/applicative)
04:53:20 <olligobber> dminuoso, but [a] satisfies that
04:53:48 <osa1> `s` key in lens documentation no longer working ,any ideas why? it used to open search window
04:54:55 <dminuoso> olligobber: Nope, because its not polymorphic in the applicative choice.
04:55:00 <dminuoso> @let magic = pure "123"
04:55:01 <lambdabot>  .L.hs:163:1: error:
04:55:01 <lambdabot>      Multiple declarations of ‘magic’
04:55:01 <lambdabot>      Declared at: .L.hs:162:1
04:55:05 <dminuoso> @let magic' = pure "123"
04:55:06 <lambdabot>  Defined.
04:55:08 <dminuoso> :t magic'
04:55:09 <lambdabot> Applicative f => f [Char]
05:01:52 <olligobber> > magic' :: [[Char]]
05:01:54 <lambdabot>  ["123"]
05:02:20 <Myrl-saki> Wat
05:02:24 <Myrl-saki> :t magic'
05:02:25 <lambdabot> Applicative f => f [Char]
05:02:38 <Myrl-saki> > magic' :: Just Char
05:02:40 <lambdabot>  error:
05:02:40 <lambdabot>      • Expected a type, but ‘'Just Char’ has kind ‘Maybe *’
05:02:40 <lambdabot>      • In an expression type signature: Just Char
05:02:44 <vaibhavsagar> ezyang, ertes: I figured it out http://vaibhavsagar.com/blog/2018/01/03/static-haskell-nix/
05:02:48 <Myrl-saki> Ugh, I'm stupid.
05:02:50 <Myrl-saki> > magic' :: Maybe Char
05:02:52 <lambdabot>  error:
05:02:52 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
05:02:52 <lambdabot>        Expected type: Maybe Char
05:02:53 <olligobber> > magic' :: Maybe [Char]
05:02:55 <lambdabot>  Just "123"
05:03:02 <Myrl-saki> Oh.
05:03:09 <Myrl-saki> Welps.
05:04:40 <olligobber> @let pure' = pure :: a -> [a]
05:04:41 <lambdabot>  Defined.
05:04:55 <olligobber> > pure' 1
05:04:57 <lambdabot>  [1]
05:05:31 <AndreasK> osa1: works for me
05:05:45 <dminuoso> olligobber: And of course similar to repeat there's also replicate.
05:06:01 <dminuoso> olligobber: Beyond that nothing else could exist because of parametricity Im sure.
05:06:06 <osa1> AndreasK: `s` in this page works for you http://hackage.haskell.org/package/lens ?
05:06:09 <AndreasK> osa1: But only when already viewing a module, not in the landing page
05:06:26 <osa1> AndreasK: ah, right, it works in modules. weird.
05:07:21 <olligobber> dminuoso, there's (:[]), if you want to count that
05:07:22 <dminuoso> olligobber: Aside from some: `const [] :: a -> [a]`
05:07:41 <dminuoso> olligobber: well that's the pure instance
05:07:50 <dminuoso> *pure from the applicative instance
05:08:50 <dminuoso> olligobber: Or you could see this as just a specific case: replicate 1
05:09:00 <dminuoso> olligobber: so either you have no elements, n elements or infinite elements.
05:09:43 <dminuoso> even no elements would be covered by `replicate 0`
05:20:55 <Myrl-saki> There's a ghc for mips???
05:21:26 <Myrl-saki> Oh wait
05:21:31 <Myrl-saki> Wait, is there?
05:21:37 <Clint> yes
05:21:49 <Myrl-saki> That means I can run Haskell programs on my router!?
05:21:58 <Myrl-saki> My router claims it only has 4 MB left.
05:22:00 <Myrl-saki> on the RAM
05:22:05 <Myrl-saki> Any ideas?
05:22:13 <Myrl-saki> No swap btw.
05:23:12 <cheater> hi
05:25:41 <JuanDaugherty> yello cheater
05:37:24 <cheater> hi JuanDaugherty
05:46:02 <jw358> i have a class MyThing where method :: HashMap Text a -> some result, where in the case that a is HashMap Text Text i want to call method on that again, and then in the case it's Text, i want to call some other method from another class
05:46:32 <jw358> is there something i should read about this somewhere?
06:01:09 <JuanDaugherty> suggests distinction between Haskell type classes and OOP
06:02:14 <JuanDaugherty> https://wiki.haskell.org/OOP_vs_type_classes
06:07:27 <dminuoso> Ä2 Type classes is a sort of templates, not classes
06:07:33 <dminuoso> Mmm. That hurt. :(
06:08:09 <dminuoso> I suppose concepts would be the closer comparison
06:08:47 <[exa]> yep
06:10:43 <[exa]> though concepts are more like tests, typeclasses are in fact only tiny markers that give the compiler a hint about presence of various "features" (= overloadings)
06:11:00 <[exa]> if you meant the C++ concepts
06:11:04 <dminuoso> Yeah.
06:12:39 <dminuoso> [exa]: http://sms.cs.chalmers.se/publications/papers/2008-WGP.pdf this was a good paper on the topic.
06:20:47 <glguy_> jw358: you'll need to define a type like: data HashTree k v = Leaf v | Node (HashMap k (HashTree k v)
06:32:05 <dminuoso> Is there a general preference between fmap and second for mapping over the second part of a tuple? And equivalently, is there a non-arrow equivalent for mapping over the first part of (,) ?
06:34:06 <infinisil> dminuoso: whatever makes more sense
06:34:15 <infinisil> dminuoso: which in most cases would be second I'd think
06:34:27 <dminuoso> Oh and I just realized I should probably be using bifunctor over arrow.
06:34:33 <infinisil> Functor ((,) a) is weird anyways
06:35:17 <dminuoso> infinisil: Fair enough
06:48:49 <mnoonan> dminuoso, there is the lens option too (over _1 f)
06:49:10 <mnoonan> > over _1 (+7) (3, "hello")
06:49:12 <lambdabot>  (10,"hello")
06:49:43 <mnoonan> imo it is hard to get more expressive than that
06:52:29 <royal_screwup21> how would you rewrite this to its simpler form? newtype CoolBool = CoolBool { getCoolBool :: Bool }
06:55:40 <lyxia> is there a simpler form?
06:56:29 <nullie> newtype CoolBool = CoolBool  Bool ?
06:56:50 <nullie> no getter though
06:57:07 <dminuoso> mnoonan: Okay I havent thought of that. On that note I immediately wondered.. how does that even typecheck?
06:57:47 <mnoonan> :t over _1
06:57:48 <lambdabot> Field1 s t a b => (a -> b) -> s -> t
06:58:04 <mnoonan> heh, ok, not super clarifying :)
06:58:16 <dminuoso> Field1 seems to be the magic constraint
06:58:54 <Addam> is mniip here?
06:59:03 <dminuoso> mnoonan: Ah well it's okay. Ill just write it down on my "road to complete Haskell" list as something to tackle when I have more experience.
06:59:13 <mniip> hi
06:59:20 <Addam> hi
06:59:59 <Addam> we didn't manage to find a 'final' solution with ed, so giving up
07:00:12 <mnoonan> dminuoso: the microlens package is a bit easier to grok, and has most of the common lens goodies
07:01:02 <Addam> going over to something like a continuation monad or exception monad now
07:01:48 <nullie> :t over _1 :: (a -> b) -> (a, c) -> (b, c)
07:01:49 <lambdabot> (a -> b) -> (a, c) -> (b, c)
07:01:54 <Addam> do you think it is going to be easier with them?
07:03:38 <royal_screwup21> if I do: data Bool = True | False -- does it mean that Bool has 2 contructors?
07:04:02 <hyperisco> royal_screwup21, yes
07:05:40 <royal_screwup21> ah okay. Just to be clear, something like: data DumbTree x = Node x -- what does the "x" stand for? Is it an argument (it can't be a constructor)?
07:07:18 <lyxia> It's the type of the only field of the Node constructor.
07:07:22 <lyxia> It's also a type variable.
07:07:40 <hyperisco> royal_screwup21, it could assume various names, but typically it is a field (in this case, the type of the field)
07:08:03 <royal_screwup21> cool, thank ye folks
07:08:11 <hyperisco> royal_screwup21, that is the use on the right. The use on the left is a parameter.
07:08:41 <dminuoso> mnoonan: Ohh thats a dirty simple trick.
07:08:45 * hackage wai-middleware-rollbar 0.8.1 - Middleware that communicates to Rollbar.  https://hackage.haskell.org/package/wai-middleware-rollbar-0.8.1 (joneshf)
07:09:14 <hyperisco> Enterprise programmers hate him!
07:09:45 <dminuoso> mnoonan: The tip with microlens was really helpful. Control.Lens also has Field1 but it looks very unintuitive with all those type variables..
07:10:02 <butterthebuddha> https://gist.github.com/anonymous/e5aea3f8d2f25e4289c74ec9c671835d
07:10:04 <dminuoso> I mean `class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s where ...` is somewhat scary
07:10:20 <butterthebuddha> Can someone help me out with that?
07:12:55 <royal_screwup21> would anyone use newtype over data? I looked it up and it seems like data is slower because of the overhead in all the "wrapping and unwrapping of types" (which I'm not sure I totally understand). I'd be ever so grateful if someone explained the concept with a simple example :)
07:12:59 <royal_screwup21> why would*
07:13:38 <butterthebuddha> royal_screwup21: afaik, newtype is the exact same as data as far as type checking goes, but uses less memory
07:13:56 <dminuoso> royal_screwup21: newtype is strict.
07:14:57 <dminuoso> butterthebuddha: What type does your Parser have?
07:15:05 <butterthebuddha> Parser a?
07:15:41 <dminuoso> butterthebuddha: Ah well at any rate. f is inferred to have the type: `f :: String -> [a]`
07:16:02 <dminuoso> butterthebuddha: so under that assumption: f <$> p implies that p must be a `Parser String`
07:16:06 <dminuoso> but you claimed that its `Parser a`
07:16:07 <royal_screwup21> I mean using newtype would you mean you can define only *one* constructor, which would you have only one field. data doesn't have all of these constraints. Surely flexibility >> tiny bit of extra memory usage
07:16:34 <dminuoso> butterthebuddha: You can see this in your diagnostics at the bottom when the relevant bindings (with their inferred types) are mentioned.
07:16:45 <glguy> (data/newtype) They're just different, neither one is better
07:17:59 <dminuoso> butterthebuddha: Also you might be interested in this:
07:18:02 <dminuoso> :t many
07:18:03 <lambdabot> Alternative f => f a -> f [a]
07:18:07 <dminuoso> and for one or more:
07:18:10 <dminuoso> :t some
07:18:11 <lambdabot> Alternative f => f a -> f [a]
07:19:52 <butterthebuddha> dminuoso: I think the point of the exercise to implement thse?
07:19:54 <butterthebuddha> those*
07:20:59 <dminuoso> butterthebuddha: Are you supposed to consume input?
07:21:15 <butterthebuddha> dminuoso: Yeop
07:21:28 <butterthebuddha> s/o//
07:21:44 <glguy> dimuso: Yeop?
07:22:11 <lyxia> royal_screwup21: it's pretty cheap to change data to newtype
07:24:13 <lyxia> royal_screwup21: and I think the mindset is somewhat different. newtype is about making a distinction between a representation (e.g., Text), and a meaning (e.g., Email).
07:24:15 <glguy> royal_screwup21: Using data creates a new level of indirection and step for evaluation, matching on a data value constructor forces computation. Using newtype doesn't create a new level of indirection, no extra evaluation happens, matching on its constructor doesn't do any evaluation, newtypes can be coerced away for free
07:24:41 <dminuoso> butterthebuddha: But if you want to understand the concrete thing why this fails to typecheck:
07:24:50 <dminuoso> butterthebuddha: See how you are invoking `f z` at the end?
07:25:17 <butterthebuddha> Yeah I got that, I don't see another way of doing it tho
07:25:22 <butterthebuddha> Do I need another function?
07:25:27 <dminuoso> butterthebuddha: Well you're on a completely wrong track anyway.
07:26:08 <dminuoso> butterthebuddha: runParser is a tricky name because it kind of implies that it does things, but it doesn't. it doesnt run or "do" anything other than just unwrapping the type.
07:26:22 <dminuoso> Which means there are no effects, no input consumed.
07:26:52 <butterthebuddha> dminuoso: right, but I get the rest of the input in the Maybe
07:27:06 <lseactuary> is all functional programming in haskell?
07:27:16 <butterthebuddha> What exactly do you mean by "input consumed"?
07:27:42 <butterthebuddha> lseactuary: what do you mean by "all" functional programming?
07:27:45 <dminuoso> butterthebuddha: Are you writing monadic combinatoric parsers?
07:28:04 <butterthebuddha> dminuoso: I'm not sure what that means
07:28:05 <butterthebuddha> https://www.cis.upenn.edu/~cis194/spring13/hw/11-applicative2.pdf
07:28:10 <butterthebuddha> ^ I'm working on Ex 1 on there
07:28:55 <kadoban> lseactuary: There are many other functional programming languages (by many different definitions of FP), and you can write code in haskell in styles other than functional.
07:29:04 <mnoonan> royal_screwup21: here's a diagram showing the difference between defining values with type, newtype, and data, and what the result looks like in memory.
07:29:04 <lseactuary> in functional programming courses is the main language haskell ?
07:29:16 <mnoonan> http://lpaste.net/361280
07:29:45 <mnoonan> the arrows are pointers, so you can see the extra indirection for data
07:30:00 <kadoban> lseactuary: Hard to say, probably not at a guess.
07:30:03 <butterthebuddha> lseactuary: not necessarily
07:30:31 <lseactuary> aha
07:30:32 <dminuoso> butterthebuddha: Can you gist your parser type definition?
07:30:51 <dminuoso> butterthebuddha: (maybe with instances) - just want to know that what Im saying will line up with what Im about to say
07:30:55 <butterthebuddha> https://www.cis.upenn.edu/~cis194/spring13/extras/11-applicative2/AParser.hs
07:31:54 <dminuoso> butterthebuddha: Okay so the type: `String -> Maybe (a, String)` is your parser basically. It takes some input and produces either nothing (error case), or some result and "remaining stream" of characters that were not consumed.
07:32:25 <butterthebuddha> Yep
07:34:15 * hackage Decimal 0.5.1 - Decimal numbers with variable precision  https://hackage.haskell.org/package/Decimal-0.5.1 (PaulJohnson)
07:35:00 <dminuoso> butterthebuddha: So, look at this line: https://gist.github.com/anonymous/e5aea3f8d2f25e4289c74ec9c671835d#file-sexpr-hs-L5
07:35:08 <dminuoso> butterthebuddha: and think about what you are recursing with.
07:35:29 <dminuoso> butterthebuddha: also note that the excercise wants you to utilize the Applicative and Alternative interface from last week.
07:37:12 <dminuoso> butterthebuddha: Basically at this point you shouldnt need to unpack and poke into the parser anymore. :)
07:41:51 <dminuoso> butterthebuddha: In fact your excercise even states this quite explicitly..
07:42:14 <butterthebuddha> But I'm not unpacking the Parser, am I?
07:42:22 <dminuoso> Yes you are.
07:42:47 <dminuoso> butterthebuddha: runParser unpacks the parser, you pry it open and pattern match against its internal details.
07:43:30 <dminuoso> butterthebuddha: At this point.. just dont use `runParser` (or Parser pattern matching on the left side). You dont need it.
07:43:33 <butterthebuddha> But the hint says run it and use the result?
07:43:54 <dminuoso> butterthebuddha: Like I said "runParser" is just a somewhat confusing name. It doesn't run, it just unpacks.
07:44:07 <dminuoso> It's mostly for actually executing a constructed parser against a string.
07:44:22 <dminuoso> But thats not the point of the excercise.
07:48:24 <Myrl-saki> Holy shit
07:48:29 <Myrl-saki> Err wrong channel
07:49:16 <dminuoso> butterthebuddha: Basically with Alternative and Applicative you have build an interface to suddenly construct parsers together in powerful ways. Use their methods.
07:49:20 <shapr> Myrl-saki: compiling with categories? profunctors? what in Haskell could inspire such a comment?
07:49:30 <dminuoso> And dont use `runParser` unless you want to actually test your solution.
07:49:38 <Myrl-saki> shapr: Neither, hence wrong channel. :P
07:49:47 <shapr> aw, ok
07:50:10 <butterthebuddha> dminuoso: So I figure oneOrMore is gonna be something like "f <$> ____ <*> zeroOrMore p"
07:50:26 <butterthebuddha> I need to figure out what goes in between
07:50:31 <butterthebuddha> <$> and <*>
07:50:39 <dminuoso> butterthebuddha: You're on the right track. :)
07:50:58 <butterthebuddha> And figuring that out will help me figure out zeroorMore
07:51:29 <dminuoso> butterthebuddha: Just remember you will also need Alternative.
07:51:31 <tsahyt> does the GHC runtime perform its own scheduling when using threads or is it somehow leveraging the kernel's scheduler? (using forkIO and parallel, not forkOS)
07:51:44 <ezyang> it has its own scheduler
07:52:03 <dminuoso> butterthebuddha: If you dont understand how, it might be useful to use Applicative and Alternative on your own with some basic parsers to gain a better understanding of what they do exactly.
07:52:13 <tsahyt> ezyang: so by extension it doesn't have to context switch?
07:52:43 <ezyang> nope
07:52:51 <ezyang> or, it doesn't have to context switch in the kernel
07:52:57 <tsahyt> yes that's what I mean
07:52:59 <tsahyt> good to know :)
07:54:39 <dminuoso> butterthebuddha: Personally I upgraded to Monad, implemented zeroOrMore and oneOrMore in terms of the monad interface and then downgraded to Applicative. Was a bit easier to wrap my head around initially.
07:54:55 <butterthebuddha> I don't know what monads are yet - that's next week's topic
07:56:15 * hackage thank-you-stars 0.3.0 - Give your dependencies stars on GitHub!  https://hackage.haskell.org/package/thank-you-stars-0.3.0 (y_taka_23)
07:58:31 <ijp> \query byorgey
07:58:36 <hyperisco> I don't know about calling Monad an "upgrade" from Applicative
07:58:39 <ijp> sorry
07:59:05 <tsahyt> hyperisco: why not? you can do strictly more with monads than with applicatives, no?
07:59:09 <dminuoso> hyperisco: "upgrade" in the sense that a Monad is more powerful.
07:59:29 <dminuoso> hyperisco: Though I agree that climate wise Applicative would be an upgrade over Monad..
07:59:45 <dminuoso> Because its less constrained
08:01:58 <hyperisco> Monad gives you more, but in interest of writing programs that are more generic, that is a bad thing
08:03:23 <tsahyt> hyperisco: if you don't need what Monad gives you, you should of course not overconstrain your functions
08:04:06 <dminuoso> tsahyt: It was just helpful because visually a monad makes side effects and results a bit more explicit.
08:04:07 <hyperisco> you could upgrade to, say, [a] and get even more, or to [Int]
08:05:10 <tsahyt> dminuoso: you mean in terms of notation?
08:05:23 <dminuoso> tsahyt: Yeah.
08:05:34 <tsahyt> I suppose ApplicativeDo can help with that
08:06:11 <ongy> http://lpaste.net/361281 any good ideas what could cause this? (SIGSEGV in cleanup from what I can tell)
08:06:12 <tsahyt> for things like parsers, I find Applicative rather nice as far as notation goes. but for some FRP tasks, it can get quite daunting imo.
08:06:43 <tsahyt> unfortunately I haven't been able to use ApplicativeDo for it yet, there was some bug in GHC 8.0 that would put infer Monad constraint where none was needed iirc
08:06:48 <dminuoso> tsahyt: Oh absolutely it reads much nicer that I grokked applicative. :)
08:07:27 <tsahyt> ongy: I have no idea but "waymonad" caught my eye. what are you working on there?
08:07:31 <i-am-the-slime> What's a simple library for making some postgres queries?
08:07:44 <i-am-the-slime> Just from a local machine for diagnostics purposes.
08:07:47 <ongy> https://github.com/ongy/waymonad :)
08:08:04 <ongy> so yea, this happens after the last line in main is executed. Which isn't very much fun
08:08:31 <ongy> let's see if I can valgrind this binary... I kind of doubt it
08:08:32 <tsahyt> ongy: that's great, I've been hoping for something like this to emerge
08:10:10 <tsahyt> i-am-the-slime: I suppose this is about the simplest postgres lib https://hackage.haskell.org/package/postgresql-simple
08:10:29 <tsahyt> where simple means low level, no bells and whistles
08:10:39 <tsahyt> somewhat low level anyhow
08:11:26 <i-am-the-slime> I'm looking at Opaleye now
08:11:38 <i-am-the-slime> I couldn't find any documentation for posgres-simple
08:11:42 <tsahyt> i-am-the-slime: opaleye is built on top of postgresql-simple
08:11:49 <i-am-the-slime> Ah interesting
08:12:04 <tsahyt> this page has an almost disturbing amount of prose on it by haskell standards :P https://hackage.haskell.org/package/postgresql-simple-0.5.3.0/docs/Database-PostgreSQL-Simple.html
08:12:41 <i-am-the-slime> That's true!
08:13:07 <i-am-the-slime> I probably should have clicked on something when I was on the page with all the version numbers and dependencies.
08:13:59 <butterthebuddha> https://gist.github.com/anonymous/56c8bfcc7b7a1185abc36cf235ceab4e
08:14:14 <butterthebuddha> ^ So my implementation of oneOrMore is correct I think, but zeroOrMore is obviously incorrect
08:14:36 <tsahyt> i-am-the-slime: pretty much all experience I had with using postgres from Haskell was with persistent+esqueleto and the corresponding postgres backend though. but that imo only makes sense when your application control the schema and everything, otherwise I can imagine it to become somewhat painful.
08:15:42 <i-am-the-slime> Honestly for this I am fine writing raw SQL and having something that maps the result columns or blows up.
08:15:59 <tsahyt> i-am-the-slime: postgresql-simple looks about right then.
08:16:23 <i-am-the-slime> I just have to find out how to tell stack to use it.
08:16:58 <dminuoso> butterthebuddha: you can simplify oneOrMore
08:17:18 <dminuoso> butterthebuddha: in 2 meaningful ways. first you can replace f with just (:)
08:19:24 <tsahyt> i-am-the-slime: just put it in your cabal file as a dependency
08:20:32 <dminuoso> butterthebuddha: Also I can give you another hint and that will allow you to simplify and maybe get further: you dont need empty at all here.
08:20:51 <butterthebuddha> dminuoso: the hint wants me to run oneOrMore in zeroOrMore - that seems like that's gonna result in an infinite loop
08:20:54 <i-am-the-slime> It's downloading it now.
08:20:59 <butterthebuddha> (I htink)
08:21:02 <butterthebuddha> s/htink/think
08:21:14 <dminuoso> butterthebuddha: yeah but.. think about it.
08:22:10 <pierrot> Hi. I've written this code: https://glot.io/snippets/ex0ro9xgfh The problem is what when I want to parse, for example, "START foo", it tries first the SESSION parser and since it fails, it returns the error message. How can I fix it?
08:22:43 <tsahyt> pierrot: with parsec (and megaparsec) you need to be explicit about backtracking points
08:22:44 <pierrot> s/is what/is that/
08:22:48 <tsahyt> that's what the try combinator is for
08:23:14 <dminuoso> butterthebuddha: You should start with the other one first. :)
08:23:17 <hyperisco> is it that much of a stickler about lookahead? lol
08:23:31 <hyperisco> I am guessing it consumes the S and says "looks good to me!"
08:23:33 <dminuoso> butterthebuddha: Ignore oneOrMore for now, and just start with zeroOrMore, and write it in terms of the other!
08:23:47 <tsahyt> hyperisco: afaik yes. attoparsec just puts backtracking points everywhere on its own instead
08:23:54 <tsahyt> I suppose the clean solution would be to tokenize first
08:24:01 <dminuoso> butterthebuddha: i.e. define `oneOrMore = undefined` (allowing it to type check for now)
08:24:04 <tsahyt> so SESSION and START are two separate tokens
08:24:47 <hyperisco> you could tokenise, but it is also not inconceivable to have more lookahead for constant strings
08:25:07 <Guest24147> is there any haskell collection in codewars to help me rank up ?
08:25:48 <jchia_1> TH question: I would like to print the DecsQ for some Haskell code to get a general idea of the structure of the DecsQ I need to write. E.g. I may write some example desired generated Haskell code, put it in '[d||]' and show the DecsQ, but there's no show instance. What's the next best thing I can do?
08:26:09 <butterthebuddha> dminuoso: So it's obviously oneOrMore p <|> Something
08:26:30 <butterthebuddha> But if I can't use the Parser constructor, how do I return an empty list?
08:26:52 <jchia_1> I mean the Q has no show but the Dec does. How do I 'unwrap'?
08:26:56 <dminuoso> butterthebuddha: `empty` doesnt produce an "empty" list - check your Alternative instance.
08:27:11 <Guest24147> https://www.reddit.com/r/haskell
08:27:17 <butterthebuddha> dminuoso: Yeah that's why I can't do oneOrMore p <|> empty
08:27:18 <dminuoso> butterthebuddha: `empty` produces a parser that always errors.
08:27:38 <pierrot> tsahyt : how can I "tokenise"?
08:27:41 <butterthebuddha> and I just realized that empty is actually the identity, so the <|> empty would be meaning less anyway
08:27:53 <dminuoso> butterthebuddha: Exactly. :-)
08:27:56 <hyperisco> though it may have to do with the resumability of Parsec that they treat it this way
08:28:16 <dminuoso> butterthebuddha: So what do you know about what it has to return?
08:28:31 <butterthebuddha> A parser which returns the empty list
08:28:34 <butterthebuddha> always
08:28:43 <ongy> mhh, any good way to valgrind a GHC compiled binary without gigabytes of RAM to spare?
08:28:54 <tsahyt> pierrot: by using a lexer of some kind to transform your stream of character input into a stream of tokens
08:29:19 <tsahyt> and then you'll have to tell parsec to operate on that, which isn't all that hard
08:29:28 <butterthebuddha> https://gist.github.com/anonymous/7c7ba2d6c33612ddf96bcafb593b6978
08:29:29 <tsahyt> but I'd just add a try where necessary
08:30:03 <dminuoso> butterthebuddha: nope..
08:30:17 <mnoonan> ongy: that's kind of a terrifying thought. what are your grinding for?
08:30:22 <dminuoso> butterthebuddha: So this is the second part of Applicative.
08:30:26 <dminuoso> :t pure
08:30:27 <lambdabot> Applicative f => a -> f a
08:30:43 <dminuoso> butterthebuddha: ^- this lets you construct an Applicative out of thin air that.. doesnt do anything but magically produces a result.
08:30:53 <butterthebuddha> pure []?
08:30:56 <dminuoso> butterthebuddha: Yes.
08:31:12 <ongy> mnoonan: a segfault in RTS cleanup code. Want to figure out which of the atrocities I'm commiting is at fault
08:31:20 <i-am-the-slime> I would like to generate some random instances of certain types but for the main program, can/should I use quickcheck for this or sometihng else?
08:31:35 <dminuoso> butterthebuddha: And remember: pure is side-effect free, so it doesnt do anything, doesnt "run the effects of your applicative"
08:31:38 <dminuoso> it doesnt consume any input
08:31:43 <butterthebuddha> Okay, onto oneOrMore
08:32:01 <mnoonan> ongy: fun :)
08:32:20 <ongy> mhhm
08:32:20 <dminuoso> butterthebuddha: And in that sense your gist was wrong because it would actually run `p`
08:32:51 <pierrot> tsahyt: where can I find a simple example of that?
08:33:21 <dminuoso> butterthebuddha: oneOrMore is done too. so you're basically finished. :)
08:33:39 <butterthebuddha> Okay, it does work, but I don't see how the recursion works :(
08:34:40 <dminuoso> butterthebuddha: Id start by gaining an understanding what <*> does exactly.
08:35:00 <dminuoso> butterthebuddha: What does your definition look like?
08:35:20 <tsahyt> pierrot: of what? using try?
08:35:39 <tsahyt> pierrot: you'd just replace session on line 72 with try session
08:35:42 <hyperisco> pierrot, do you know what lookahead 1 means?
08:35:45 * hackage bdcs 0.1.0 - Tools for managing a content store of software packages  https://hackage.haskell.org/package/bdcs-0.1.0 (clumens)
08:36:04 <butterthebuddha> <*> :: f (a -> b) -> f a -> f b
08:36:22 <butterthebuddha> Well, <*> :: Applicative f => f (a -> b) -> f a -> f b
08:36:25 <dminuoso> butterthebuddha: No I meant your oneOrMore and zeroOrMore
08:36:57 <butterthebuddha> https://gist.github.com/anonymous/c1b68739f041b905a6024d8a1cc1c8e2
08:37:01 <hyperisco> it'd be nice if lambdabot had Parsec for demonstration purposes
08:37:18 <ongy> mhh, another fun question: How to properly ignore signals with GHC? I get killed (sometimes, sometimes not) when I receive SIGUSR1. Though the first thing I do starting up, is to register a signal handler that should ignore SIGUSR1
08:38:06 <pierrot> tsahyt : Thanks. I was asking about a cleanear solution like the one you suggested first (tokenizing the input)
08:38:26 <hyperisco> pierrot, make a simple parser  p = string "apple" <|> string "acorn"   and see if it accepts "acorn"
08:38:47 <pierrot> hyperisco it wont
08:38:57 <dminuoso> butterthebuddha: Basically the key is understanding what <*> does.
08:38:58 <tsahyt> pierrot: depending on how your input looks like, even just running words on it might actually already constitute a sufficient lexer step.
08:39:09 <hyperisco> what if it is  p = string "acorn" <|> string "apple"  ?
08:40:14 <tsahyt> as an added benefit you don't need to have the explicit space parsers everywhere
08:40:49 <hyperisco> then what if we try   p = (:) <$> char 'a' <*> (string "corn" <|> string "pple")  on both "apple" and "acorn" ?
08:41:46 <pierrot> but that last one lacks of "modularity"
08:41:46 <dminuoso> butterthebuddha: ^- you might be interested in that discussion too =)
08:41:58 <hyperisco> this is a reason these performance parsers are poo poo… no distributivity
08:42:55 <tsahyt> pierrot: do you have an example of your input somewhere?
08:43:33 <hyperisco> so Parsec has a backdoor called "try" which upgrades you from lookahead 1 to arbitrary lookahead
08:44:21 <hyperisco> p = try (string "apple") <|> string "acorn"   should accept "acorn", because it does arbitrary lookahead on  string "apple"
08:44:42 <pierrot> hyperisco Hmmm I see
08:45:55 <dminuoso> butterthebuddha: also it could be helpful looking at `(:) <$> p <*> zeroOrMore p` as `pure (:) <*> p <*> zeroOrMore p` (they are the same by applicative laws)
08:46:06 <ongy> valgrind and GHC are a fun combination. I can watch my memory fill up live
08:46:30 <hyperisco> what it won't do is help you any with <*>, but that's Parsec
08:46:45 * hackage conduit-extra 1.2.3.2 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.2.3.2 (MichaelSnoyman)
08:48:09 <ongy> well, I found something with valgrind, I guess that's trampling over some RTS data as well. Well, now I hate myself for doing this... wish me luck, I got my hazmat
08:52:11 <hyperisco> (try (string "aa") <|> string "a") <*> string "a"  will only accept "aaa"!
08:52:56 <cocreature> ongy: related https://twitter.com/cocreature/status/708347812082278401
08:54:45 <Addam> is it possible to prove that a definition of a morphism from a monad to another is right?
08:57:09 <ongy> cocreature: :) shut up :P
08:57:26 <ongy> but at least I got the example small enough to use valgrind and have a rough idea of what's going on
08:58:20 <i-am-the-slime> Soo...
08:58:26 <i-am-the-slime> What type should I use for strings?
08:58:47 <cocreature> Text
08:58:51 <i-am-the-slime> This was really nice in Purescript.
08:59:04 <i-am-the-slime> import qualified Data.Text.IO as IO
08:59:07 <i-am-the-slime> Like this?
08:59:09 <hyperisco> i-am-the-slime, use Peano naturals for Unicode code points, and put them in a indexed set, say IntMap
08:59:13 <sphinxo> what's the best way to make a dsl where my ast looks like this: http://lpaste.net/8735642199330390016
08:59:21 <i-am-the-slime> IO.readFile
08:59:47 <sphinxo> actually the example I've given would be wrong
08:59:57 <i-am-the-slime>     * Couldn't match type `Data.Text.Internal.Text' with `[Char]'
08:59:57 <sphinxo> where Seq [Assign 0 (BinOp BMul (Var 0) (Lit 2))]
09:00:13 <i-am-the-slime> {-# LANGUAGE OverloadedStrings #-} <- I thought that would help with that?
09:00:21 <i-am-the-slime> I guess I need to do some pack unpack stuff?
09:00:28 <sphinxo> where Seq [Assign 1 (BinOp BMul (Var 1) (Lit 2)), Assign 0 (Var 1)]
09:00:36 <hyperisco> sphinxo, well there is Alex (iirc) for tokenising, and Parsec for parsing
09:00:39 <cocreature> i-am-the-slime: I typically do something like "import Data.Text (Text)\nimport qualified Data.Text as Text\nimport qualified Data.Text.IO as Text". then you can use the type unqualified and Text.something for accessing the individual functions
09:00:47 <i-am-the-slime> Ah no, I just needed to use the right version of putStrLn
09:00:52 <sphinxo> hyperisco: I'd like to be able to write it in haskell
09:01:01 <hyperisco> sphinxo, so do you mean embedded?
09:01:06 <sphinxo> sorry yes
09:01:12 <i-am-the-slime> alright, thanks!
09:01:27 <kadoban> I do what cocreature does, except T instead of Text, save yourself some typing.
09:01:43 <hyperisco> sphinxo, are you thinking of using TH or something? I don't quite understand your example
09:02:04 <i-am-the-slime> Nice, I'll start out with Text for now.
09:02:10 <i-am-the-slime> And it even works.
09:02:19 <hyperisco> sphinxo, typically with embedded you just write ordinary expressions which construct the AST
09:02:23 <i-am-the-slime> Weird, why doesn't postgres-simple pick up the pgpass file then?
09:02:23 <sphinxo> hyperisco: no, I'd like to write a haskell expression like is shown in the paste, which results in the specified Expr
09:02:28 <sphinxo> ahh yes
09:02:51 <hyperisco> well it doesn't work like that unless you use TH. That is the only way to leverage Haskell syntax in that fashion… or a compiler extension
09:02:56 <i-am-the-slime> Ah looks like ~ doesn't work.
09:03:31 <cocreature> sphinxo: give me a minute, I’ll try to make an example
09:04:15 <sphinxo> Could I do something like type ExprM = State Int Expr or suchlike
09:04:21 <sphinxo> where the state is for fresh variables
09:04:53 <hyperisco> sphinxo, yes
09:05:00 <sphinxo> I'm just wondering how to use bind to do a Seq
09:06:57 <hyperisco> sphinxo,  type ExprM a = State (Expr, Int) a  and 'a' is the type of your expression
09:07:05 <sphinxo> ah yeah
09:07:22 <hyperisco> input :: ExprM a   or whatever
09:08:05 <hyperisco> well Expr doesn't make sense in the State I don't think
09:08:16 <hyperisco> cocreature will figure it out for you :)
09:08:23 <sphinxo> :) thanks
09:08:24 <cocreature> I’m not quite sure what you want tbh
09:09:12 <hyperisco> input :: State Int Expr; input = State (\s -> (Var s, s + 1))
09:09:25 <cocreature> right that’s the easy part
09:09:30 <hyperisco> your initial idea makes more sense
09:09:41 <sphinxo> yeah I'm struggling with the set part
09:09:42 <hyperisco> then if you want to type your Exprs you'd make a GADT definition instead
09:10:28 <cocreature> you could just have a list of assignments in your state and have "set" add an assignment to that
09:10:45 <mnoonan> sphinxo: lennart had an interesting blog post about making an edsl with rvalues and lvalues
09:10:56 <sphinxo> ahh yeah
09:11:03 <mnoonan> not totally sure if it can solve your problem, but: http://augustss.blogspot.com/2011/07/impredicative-polymorphism-use-case-in.html
09:11:18 <sphinxo> just have some top level Declaration datatype
09:11:43 <hyperisco> set :: Expr -> Expr -> State Int Expr; set (Var v) x = State (\s -> (Assign v x, s)); set _ _ = error "LHS of assignment must be a variable"
09:11:51 <mnoonan> hmm, but I guess the punchline is "you used to be able to do this, and now you can't" :)
09:12:35 <hyperisco> your design went in such a way where now you have to consider syntax errors
09:13:08 <hyperisco> or maybe you switch that to fail and use MonadFail
09:13:24 <ongy> found it...
09:13:32 <ongy> wow this is quality software design. Not even sure if I can be mad
09:13:59 <tsahyt> ongy: what was it?
09:14:10 <hyperisco> but you might have a smarter AST where you can use the type system to rule out these syntax errors
09:15:05 <cocreature> sphinxo: you can do something like http://lpaste.net/361284
09:15:11 <ongy> tsahyt: so, I'm playing with libfuse right? And since I'm a good person, I use bracket where I deem it necessary. And then I had a double free, because it was freed once by a bracket and once by the cleanup of another fuse struct (though the cleanup in the bracket was a bit unexpected to me)
09:15:14 <cocreature> whether that’s what you want I don’t know
09:15:16 <hyperisco> lets say instead  input :: State Int Identifier
09:15:47 <sphinxo> ahh wonderful, that's good
09:15:50 <tsahyt> ongy: so the issue was that libfuse is being a good citizen?
09:16:05 <hyperisco> a <- input; set a (Var a * 2); return (Var a)
09:16:24 <ongy> the issue is that they literally say "the documentation is the code" and I didn't expect this to cause a double free. But yea, essentially
09:16:26 <hyperisco> set :: Identifier -> Expr -> State Int Expr
09:16:31 <tsahyt> ongy: that sort of thing is why I dislike interfacing with C libs, especially when they're not entirely explicit about who frees what.
09:17:07 <sphinxo> the problem with having a top level Declaration Assign type is that I can't express things like if expr (set v 0) (set v 1)
09:17:09 <ongy> yea, there seem to be 3 versions of fuse, I have fuse2 installed, but the online docs is for fuse3. And fuse2 has a few very odd decisions. fuse3 seems to behave more sane
09:17:15 <hyperisco> if you take the BNF grammar of your language, the ADT definitions can follow that exactly
09:17:29 <hyperisco> and in that way you can only construct valid sentences of your language
09:17:30 <tsahyt> ongy: what do you need fuse for in a wayland compositor?
09:18:03 <hyperisco> with a possible problem of verbosity, but that is part of the game you'll have to play
09:18:12 <ongy> https://github.com/Ongy/waymonad/issues/5 it was a silly idea of mine, but tbh. I currently quite like it. The way I built it, you can remove it by removing one line, so I don't feel to bad about adding it
09:19:07 <tsahyt> ah I see
09:20:22 <cocreature> sphinxo: I think what you want is a separation of statements and expressions and then you can have an "If Expr [Statement] [Statement]" constructor
09:21:49 <sphinxo> yep that makes a lot of sense, thanks
09:24:08 <i-am-the-slime> Is there support for multiline strings somehow?
09:24:52 <i-am-the-slime> With three quotes perhaps?
09:24:54 <tsahyt> "i am a \
09:24:56 <tsahyt> \ multline string"
09:25:04 <i-am-the-slime> Anything nicer than that?
09:25:05 <tsahyt> multiline*
09:25:19 <kadoban> i-am-the-slime: There's no heredocs or anything fancy, but you can do that ^ or just    concat ["stuff", "and more stuff"], etc.
09:25:30 <ongy> tsahyt: So yea, I needed *some* IPC either way, and doing it with fuse I can be somewhat lazy on the cmdline parser for the utility. And I wanted to try fuse, which is often a reason I use things. Now that I worked with it for ~2days and ran into odd segfaults: It's nice, a bit complicated at first, but once I wrapped my head around it I quite like it
09:25:31 <tsahyt> i-am-the-slime: unlines ["line1","line2"] is somewhat popuar
09:25:33 <cocreature> sphinxo: e.g. http://lpaste.net/361285
09:25:34 <tsahyt> popular*
09:25:35 <kadoban> You can also use quasiquotes and kind of rig a thing up
09:25:50 <i-am-the-slime> I would like to just paste something with many lines
09:26:01 <i-am-the-slime> Maybe I just have to column select on its right afterwards and add some backslashes
09:26:19 <tsahyt> ongy: are you binding to it directly or are you using some existing haskell bindings?
09:26:29 <sphinxo> cocreature: thanks :)
09:28:43 <kadoban> i-am-the-slime: If you really want you can use something like https://hackage.haskell.org/package/heredoc-0.2.0.0/docs/Text-Heredoc.html (I haven't used this particular library, so check it out first).
09:28:48 <kadoban> Usually not worth it though
09:30:09 <kadoban> So it'd be like [here|Some stuff <lots of newlines, whatever> |]   probably, guessing since its docs kind of suck
09:36:02 <i-am-the-slime> Yeah, maybe not.
09:36:11 <i-am-the-slime> So how do I tell intero to import something for me?
09:36:59 <kadoban> I would assume it just uses the .cabal/package.yaml file and the stack.yaml file
09:37:14 <ongy> tsahyt: hfuse, but I dug into it a bit to make it fit my needs (it's a submodule on the git, you can see the changes I made)
09:38:53 <tsahyt> :t exitImmediately
09:38:54 <lambdabot> error: Variable not in scope: exitImmediately
09:39:21 <tsahyt> ah I see
09:39:26 <tsahyt> I was wondering what that undefined was for
09:39:45 * hackage fay 0.23.2.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  https://hackage.haskell.org/package/fay-0.23.2.0 (AdamBergmark)
09:39:48 <tsahyt> that still feels dirty though
09:39:52 <ongy> erm, being lazy for now
09:40:03 <ongy> yea, it is quite dirty. Wanted to get this right. Cleaning up comes later
09:47:45 * hackage pandoc-citeproc 0.12.2.5 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.12.2.5 (JohnMacFarlane)
09:47:57 <robbym> Can someone tell me what I am doing wrong? https://repl.it/repls/SubduedVainBandicoot
09:48:20 <robbym> (still learning haskell)
09:53:39 <cocreature> robbym: 1. you need to import Text.Read to be able to use readMaybe 2. if "return x" is supposed to have type IO Int, x needs to have type Int. in your case that means that the case expression needs to be of type Int. but you are calling putStrLn inside of it so this is going to be IO something. what you need to do here is remove the return and push it inside the leafs of the case expression, e.g. "Just a ->
09:53:40 <cocreature> return a"
09:57:27 <robbym> cocreature: Ah, I see. Fixed it. Thanks!
10:07:04 <amalloy> i was looking through parsec for something like a "fail" combinator, a parser that always fails. i didn't find one; am i supposed to use fail from Monad for that? i was under the impression everyone wished fail weren't part of Monad
10:08:06 <glguy_> empty or mzero always fail
10:11:11 <bitemyapp> amalloy: parserFail will take a string argument and fail the parser I think
10:11:12 <amalloy> :t empty
10:11:14 <lambdabot> Alternative f => f a
10:11:22 <bitemyapp> unless you want something that takes no arguments but that's kinda icky
10:11:45 <bitemyapp> https://hackage.haskell.org/package/parsec-3.1.11/docs/src/Text.Parsec.Prim.html#line-287
10:12:50 <glguy_> You'll get your helpful error messages by annotating your parsers with <?> or label
10:14:37 <sphinxo> if I have a list of [State a ()], what's the best way to fold over them with execState?
10:14:54 <metahumor> :t satisfy (False)
10:14:55 <lambdabot> error:
10:14:55 <lambdabot>     Variable not in scope: satisfy :: Bool -> t
10:15:31 <glguy_> sequence_ might be what you're looking for
10:15:49 <metahumor> amalloy: you could use "satisfy (const False)"
10:17:36 <metahumor> amalloy: Text.Megaparsec also has "failure" and "fancyFailure"
10:19:15 * hackage mulang 3.6.0 - An intermediate language designed to perform advanced code analysis  https://hackage.haskell.org/package/mulang-3.6.0 (flbulgarelli)
10:20:12 <metahumor> amalloy: as well as "unexpected" and "customFailure"
10:21:38 <sphinxo> glguy_: i'm looking to pass the resulting state to each successive state
10:22:10 <amalloy> sphinxo: that's the idea with sequence_ :: [State a ()] -> State a ()
10:23:04 <glguy_> sphinxo: I guessed as much
10:23:41 <amalloy> > execState (sequence_ (replicate 5 (modify (+2))) 5
10:23:43 <lambdabot>  <hint>:1:51: error:
10:23:43 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:23:55 <amalloy> > execState (sequence_ (replicate 5 (modify (+2)))) 5
10:23:57 <lambdabot>  15
10:24:26 <sphinxo> ahh, awesome
10:24:36 <metahumor> why not just (replicateM_ 5 (modify (+2)))
10:24:59 <amalloy> metahumor: because sphinxo already has [State a ()]
10:25:06 <metahumor> gotcha
10:25:12 <glguy_> Because that wouldn't illustrate the thing in question
10:25:20 <unclechu> hi there, about type-level arithmetics: i have my own combinator like `data (a ∷ k) ⊳ b ; infixr 5 ⊳` and some type: `type T = Foo ⊳ Bar ⊳ Baz` now I want to count all combined elements and get `3 :: Nat` in this case, but I want KnownNat to be able to convert it to a value, how I do this/
10:26:36 <unclechu> I created a type-class with type-family like this: `class (KnownNat (Cnt a) => Count a where type Cnt a :: Nat`
10:28:09 <unclechu> and some instances like `instance Count FooBarBaz where type Cnt FooBarBaz = 1` and `instance (Count a, Count b) => Count (a ⊳ b) where type Cnt (a ⊳ b) = Cnt a + Cnt b`
10:29:18 <unclechu> but i get error like: `no instance  for KnownNat (Cnt 'Foo + (Cnt 'Bar + (Cnt 'Baz)))`
10:29:38 <glguy_> If you have a question about some code you can paste it to lpaste.net along with the full error message
10:31:26 <glguy_> There should be at least 4 instances in the code you paste
10:32:19 <unclechu> glguy_: k, i'll paste simple example in few minus
10:38:03 <hyperisco> I can't see the name of your data type, but I'll say it is :+
10:40:17 <hyperisco> type family TermCount a :: Nat where x :+ y = TermCount x + TermCount y; _ = 1
10:40:38 <hyperisco> @let data a :+ b where
10:40:38 <lambdabot>  Parse failed: Parse error: EOF
10:40:50 <hyperisco> @let data X a b
10:40:51 <lambdabot>  Defined.
10:41:03 <hyperisco> @let data a :+ b
10:41:03 <lambdabot>  Defined.
10:41:14 <hyperisco> syntax is a cruel master
10:41:38 <hyperisco> @let type family TermCount a :: Nat where x :+ y = TermCount x + TermCount y; _ = 1
10:41:38 <lambdabot>  .L.hs:172:9: error: Malformed head of type or class declaration: _
10:41:39 <lambdabot>      |
10:41:39 <lambdabot>  172 |         _ = 1
10:41:55 <hyperisco> RIP, oh well
10:42:17 <hyperisco> oh, you have to restate the type family name each time don't you
10:43:01 <unclechu> here it is http://lpaste.net/361286
10:43:59 <hyperisco> :t undefined :: TermCount (Int :+ String :+ Char)
10:44:00 <lambdabot> error:
10:44:00 <lambdabot>     • Expected a type, but
10:44:00 <lambdabot>       ‘TermCount ((Int :+ String) :+ Char)’ has kind
10:44:07 <hyperisco> riight…
10:44:31 <hyperisco> :t Proxy :: Proxy (TermCount (Int :+ String :+ Char))
10:44:32 <lambdabot> Proxy 3
10:45:10 <hyperisco> this is the power of closed type families
10:46:49 <hyperisco> the KnownNat part is trivial
10:47:15 <hyperisco> > natSing :: TermCount (Int :+ String :+ Char)
10:47:17 <lambdabot>  error:
10:47:17 <lambdabot>      • Expected a type, but
10:47:17 <lambdabot>        ‘TermCount ((Int :+ String) :+ Char)’ has kind
10:47:20 <hyperisco> yeah yeah
10:47:33 <hyperisco> > natSing :: SNat (TermCount (Int :+ String :+ Char))
10:47:35 <lambdabot>  error:
10:47:35 <lambdabot>      Not in scope: type constructor or class ‘SNat’
10:47:35 <lambdabot>      Perhaps you meant ‘Nat’ (imported from GHC.TypeLits)
10:47:48 <hyperisco> where are you
10:47:54 <butterthebuddha> So, I'm trying to create a parser for S-Exps
10:47:55 <butterthebuddha> https://gist.github.com/anonymous/4300585348896d291deca9fc3b05e076
10:48:00 <butterthebuddha> ^ that's what I have so far
10:48:24 <hyperisco> @let import Data.Singletons.TypeLits
10:48:25 <lambdabot>  .L.hs:124:1: error:
10:48:25 <lambdabot>      Could not find module ‘Data.Singletons.TypeLits’
10:48:25 <lambdabot>      Use -v to see a list of the files searched for.
10:48:47 <hyperisco> @let import Data.Type.Natural
10:48:48 <lambdabot>  .L.hs:129:1: error:
10:48:48 <lambdabot>      Could not find module ‘Data.Type.Natural’
10:48:48 <lambdabot>      Use -v to see a list of the files searched for.
10:49:13 <hyperisco> @let import Data.Singletons
10:49:14 <lambdabot>  .L.hs:124:1: error:
10:49:14 <lambdabot>      Could not find module ‘Data.Singletons’
10:49:14 <lambdabot>      Use -v to see a list of the files searched for.
10:50:36 <butterthebuddha> (the last function parseSExpr is the relevant function)
10:50:45 * hackage coalpit 0.1.1.0 - Command-line options and DSV parsing and printing  https://hackage.haskell.org/package/coalpit-0.1.1.0 (defanor)
10:50:51 <metahumor> butterthebuddha: Can you have a "Comb [Comb [A ...]]"?
10:50:59 <butterthebuddha> metahumor Yep
10:51:08 <hyperisco> I don't know where it gets SNat from
10:51:33 <hyperisco> which should probably be a synonym for Sing Nat, but whatever
10:52:07 <hyperisco> it defines SNat but does not export it... wtf?
10:52:11 <metahumor> butterthebuddha: so why split the "parseAtom" out in the recursive call after "oneOrMore"? why not just "Comb <$> oneOrMore (parseSExpr)"
10:53:51 <hyperisco> > natVal (Proxy :: Proxy (TermCount (Int :+ String :+ Char)))
10:53:53 <lambdabot>  3
10:54:03 <hyperisco> why do they make these type libraries so awkward
10:55:39 <unclechu> hyperisco: i missed where was definition of `TermCount`?
10:56:02 <hyperisco> type family TermCount a :: Nat where TermCount (x :+ y) = TermCount x + TermCount y; TermCount _ = 1
10:56:17 <butterthebuddha> metahumor: parseSexpr doesn't know how to parse atoms if I don't tell it how to?
10:58:05 <metahumor> butterthebuddha: i'm suggesting a "parseSExpr = (A <$> parseAtom) <|> (char '(' *> (Comb <$> oneOrMore parseSExpr) <* char ')')
10:58:06 <hyperisco> the first thing I do is redefine absolutely everything because I can't stand the organisation and complication of it
10:59:45 <unclechu> hyperisco: i probably missed something, i'm getting `1` with this example lpaste.net/361287
11:00:33 <glguy_> unclechu: your paste didn't have any instances for the 'Foo , 'Bar , etc. types you were using
11:01:08 <glguy_> But maybe that's been addressed in the chat since you pasted
11:02:09 <hyperisco> unclechu, *shrug* I don't have Haskell here
11:02:39 <shapr> poor hyperisco
11:02:40 <tekul> Hmm. Is it just me, or do other Haskell nix users have problems with the rebase and rerebase packages on a regular basis?
11:02:41 * shapr hugs hyperisco
11:02:48 <hyperisco> thanks… *sniff*
11:02:53 <hyperisco> I should install it oO
11:03:00 <shapr> via nix?
11:03:10 <shapr> I just did that last week, it's neat
11:04:11 <unyu> Say I have a Functor Foo and an isomorphism “f : (Foo a, b) -> (a, Foo b)”. Is Foo necessarily isomorphic to “(,) T” for some type T?
11:04:16 <tekul> Oops. Mean to post that in nixos, sry :)
11:04:41 <hyperisco> I hope the msys install doesn't screw with my msys2 install…
11:06:02 <glguy_> unclechu: your second paste probably didn't work due to kinds
11:06:15 * hackage stylish-haskell 0.9.0.2 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.9.0.2 (JasperVanDerJeugt)
11:06:48 <hyperisco> you should use ' when you promote data constructors
11:06:51 <glguy_> unclechu: try adding a kind annotation to the type family's parameter
11:11:00 <hyperisco> :k TermCount
11:11:01 <lambdabot> * -> Nat
11:11:43 <amalloy> i had some trouble writing a parsec rule. i have a list of "special" characters, and i'd like to consume all characters up to, but not including, the first special character. additionally, i'd like the result of the parser to not include leading or trailing whitespace, while preserving interior spaces
11:11:48 <amalloy> i don't much care if the parser consumes leading/trailing spaces or leaves them in the stream, to be discarded by another rule. i wrote https://gist.github.com/amalloy/ac0757760d7773feb7d12f51a70dca24 which works but is obviously not efficient. am i missing something elegant, or is it simply not possible to do efficiently because it requires arbitrary lookahead?
11:12:34 <hyperisco> :k (:+)
11:12:35 <lambdabot> k1 -> k2 -> *
11:13:09 <unclechu> glguy_: that helped, thanks!
11:13:34 <metahumor> amalloy: i used Megaparsec's "skipSomeTill" in a similar case
11:13:46 <hyperisco> > natVal (Proxy :: Proxy (TermCount (1 :+ 2)))
11:13:47 * shapr skips cheerfully
11:13:48 <lambdabot>  1
11:13:51 <unclechu> here is last working example http://lpaste.net/361288
11:14:01 <unclechu> thank you guys a lot for help
11:14:21 <hyperisco> huh that is some funky stuff with polykinds that I hadn't considered
11:15:19 <hyperisco> so what happens glguy_? it doesn't match  TermCount (a :+ b) = TermCount a :+ TermCount b  because  TermCount a  is ill-typed?
11:16:01 <hyperisco> why is this not a kind error to begin with :s
11:17:25 <metahumor> amalloy: so if i have a "skipTo = skipSomeTill (oneOf [' ', '\t', '\n'])", i can do what you want like "f specials = skipTo specials"
11:17:50 <mnoonan> unyu: this doesn't answer the question and maybe you have figured it out already, but such an F must at least be both pointed and co-pointed
11:17:58 <metahumor> amalloy: which would skip the whitespacelike characters, parse and keep the non-specials, and stop right before the specials
11:17:58 <mnoonan> (I think)
11:19:24 <unyu> mnoonan: How exactly does it have to be pointed? I don't see how to produce an empty value.
11:21:14 <mnoonan> take f : (F a, b) -> (a, F b), follow it by snd, and curry to get F a -> b -> F b. this can't depend on the F a, and the rest is your point.
11:22:14 <goodguy> do I need phd in math to learn haskell?
11:22:14 <k0ral> Hello, is it possible to write a function `splitWhen :: (a -> Bool) -> Vector (p+q) a -> (Vector p a, Vector q a)` ? I gave it a try but GHC complains and I'm sensing this may not be possible at all since `p` and `q` are determined at runtime
11:22:25 <unyu> goodguy: No.
11:22:32 <hyperisco> goodguy, maybe you do but I didn't
11:22:39 <amalloy> metahumor: it seems like the most obvious way to use skipTo would involve also skipping interior whitespace, and also consuming the terminating special char, neither of which i want. but i think i see what you mean: i could write something like: foo = many1 $ try (skipSomeTill space (lookahead (oneOf specials)) *> pure []) <|> noneOf specials
11:22:58 <hyperisco> glguy_, are you still working on it? ^.^
11:23:02 <goodguy> thanks
11:23:15 <k0ral> goodguy: I got away without any math PhD :)
11:23:15 <i-am-the-slime> So I get "Not in Scope ..." how do I import with it intero?
11:23:40 <amalloy> ugh, i don't think that typechecks: returning [Char] in one case and Char in another
11:23:48 <shapr> hit and run Haskell stereotypes
11:23:56 <unyu> mnoonan: What if F is the identity functor?
11:24:24 <unyu> mnoonan: I don't think the identity functor is pointed. :-|
11:24:55 <mnoonan> unyu: it is! point :: a -> f a is easy for identity :)
11:25:17 <unyu> mnoonan: Oh, dang. I was thinking of Alternative's empty, not Applicative's pure.
11:25:20 <unyu> My bad.
11:26:01 <unyu> Okay, so, yes, it is pointed and copointed.
11:27:03 <butterthebuddha> https://gist.github.com/anonymous/6aa58f42125e81512d52f5b922aef37c
11:27:18 <butterthebuddha> ^so my parser is parsing "(bar(foo))", but not "(bar (foo))"
11:28:04 <unyu> Does Parsec still make it annoyingly hard to decouple lexer from parser?
11:28:27 <metahumor> amalloy: why not "skipSomeTill space (noneOf specials)"
11:29:23 <glguy_> unclechu: I believe that the answer is that the type family works for all kinds, but without the kind signature the first clause is not allowed to learn the kind variables, so they default to *
11:29:47 <metahumor> butterthebuddha: what happens if you put in an extra "<* spaces" like so: "(Comb <$> ...) <* spaces <* char ')'"
11:30:11 <glguy_> I'm waiting for an airplane, so my responses are going to be intermittent and then nonexistent
11:30:24 <metahumor> butterthebuddha: and symmetrically "char '(' *> spaces *> (Comb <$> ...)"
11:30:39 <amalloy> metahumor: i don't see how i could use that parser. i only want to skip trailing space, not interior space. so eg if specials is "()", i'd like (parse "abc def foo  )") to result in "abc def foo"
11:31:21 <metahumor> if I understand how skipSomeTill works, it will parse the interior spaces properly
11:31:51 <amalloy> maybe we are looking at different skipSomeTills
11:32:01 <amalloy> https://hackage.haskell.org/package/parser-combinators-0.2.0/docs/Control-Applicative-Combinators.html#v:skipSomeTill is the one i found
11:33:17 <metahumor> okay, then a "skipSomeTill (some (noneOf specials))"
11:33:25 <metahumor> eh.. nope
11:35:03 <metahumor> "skipSomeTill space ((noneOf (space ^+^ specials)) `sepBy1` space)"
11:35:14 <metahumor> where ^+^ is some way to combine space and specials
11:36:06 <butterthebuddha> metahumor: That doesn't help :(
11:36:21 <AndreasK> I usually just parsed trailing whitespace on all subparsers
11:36:30 <butterthebuddha> metahumor: That doesn't help :(
11:36:47 <metahumor> amalloy: you oculd even use `sepEndBy1` if you want the trailing whitespace parsed
11:37:06 <amalloy> hm, that looks more promising
11:38:34 <amalloy> really the skipSomeTill is not the point there: spaces *> ((noneOf ...)) would be just as good. the interesting point is how you're using noneOf, sepBy, and ^+^
11:40:10 <metahumor> except with the `sepBy1`, you'd get ["abc", "def", "foo"], not "abc def foo", idk which you prefer
11:41:23 <amalloy> yeah, i noticed. idk either
11:43:01 <metahumor> butterthebuddha: i'm installing a local megaparsec to try your problem
11:44:21 <mpickering> What is an elegant way to turn "[(a, k)]" into "[(a, [k])"
11:44:30 <dminuoso> butterthebuddha, create more intermediate parsers using your combinators.
11:44:50 <k0ral> Hello, is it possible to write a function `splitWhen :: (a -> Bool) -> Vector (p+q) a -> (Vector p a, Vector q a)` ? I gave it a try but GHC complains and I'm sensing this may not be possible at all since `p` and `q` are determined at runtime (sorry for double-asking, not sure first time was sent correctly)
11:45:18 <amalloy> mpickering: i guess it depends what you want the list of ks to be
11:45:33 <AndreasK> mpickering: i think you messed up the braces?
11:45:38 <dminuoso> butterthebuddha, create a space parser, and then use *> and/or <*  to create further parsers that skip whitespace but consume and produce text (or skip leading whitespace)
11:45:47 <mpickering> "[(a, [k])]"
11:45:59 <dminuoso> butterthebuddha, the whole point of those combiinators is that you can step by step build more complex parsers in really small steps.
11:46:01 <amalloy> in the input there's exactly one k for each a, so the obvious solution is: map (fmap pure)
11:46:16 <dminuoso> butterthebuddha, and with each step you get a parser back that parses some specific thing.
11:46:37 <mpickering> There are many ks for each a, I want to group them by the key
11:47:09 <amalloy> mpickering: then you need more than just [(a, k)]: you need at least Eq a => [(a, k)]
11:47:20 <amalloy> and preferably Ord a
11:47:27 <mpickering> yes sure
11:47:35 <mnoonan> unyu: oh, this actually is not so hard to show after all. Just specialize your f at b = () to get "F a ~ (F a, ()) ~ (a, F ())".
11:47:42 <ph88> is it possible to write a monad with a getter for additional side effects that were yielded before ?
11:48:21 <dminuoso> butterthebuddha, you could do a single top-down step and just write a parser that basically looks like atom = someIntPaser <|> someIdentParser (which directly matches your grammar)
11:49:12 <amalloy> then it seems like you are asking https://stackoverflow.com/q/12398458/625403, mpickering
11:49:44 <unyu> mnoonan: Oh, right. How stupid of me not to see it.
11:51:28 <dmwit> ph88: `StateT [m ()] m` with `yield = modify . (:)`?
11:52:35 <ph88> dmwit, not sure what that is :p but thanks for a possible implementation .. so i take that as a yes :D
11:54:43 <dmwit> % let yield :: IO () -> StateT [IO ()] IO (); yield = modify . (:) in flip runStateT $ do { yield (putStrLn "a"); yield (putStrLn "b"); liftIO (putStrLn "c"); yielded <- get; sequence_ yielded }
11:54:44 <yahb> dmwit: ; <interactive>:50:169: error:; * Couldn't match type `IO ()' with `StateT [IO ()] IO a0'; arising from a functional dependency between:; constraint `MonadState [StateT [IO ()] IO a0] (StateT [IO ()] IO)' arising from a use of `get'; instance `MonadState s (StateT s m1)' at <no location info>; * In a stmt of a 'do' block: yielded <- get; In the second argument of
11:54:52 <glguy_> For lazily yielding elements, Writer is nice
11:54:58 <dmwit> % let yield :: IO () -> StateT [IO ()] IO (); yield = modify . (:) in flip runStateT $ do { yield (putStrLn "a"); yield (putStrLn "b"); liftIO (putStrLn "c"); yielded <- get; liftIO (sequence_ yielded) }
11:54:58 <yahb> dmwit: ; <interactive>:51:1: error:; * No instance for (Show (StateT (StateT [IO ()] IO ()) m0 a0 -> m0 (a0, StateT [IO ()] IO ()))) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
11:55:13 <dmwit> glguy_: Hard to retrieve them and continue with a blank slate, though.
11:55:15 <glguy_> Unless it's attached to something like IO
11:56:18 <dmwit> % let yield :: IO () -> StateT [IO ()] IO (); yield = modify . (:) in flip runStateT [] $ do { yield (putStrLn "a"); yield (putStrLn "b"); liftIO (putStrLn "c"); yielded <- get; liftIO (sequence_ yielded) }
11:56:18 <yahb> dmwit: c; b; a
11:56:29 <metahumor> butterthebuddha: "parseSExpr = A <$> parseAtom <|> spaces *> char '(' *> spaces *> (Comb <$> oneOrMore (parseSExpr <* spaces)) <* char ')' <* spaces"
11:56:40 <metahumor> ing like IO
11:56:44 <metahumor> whoops
11:56:59 <metahumor> it works for "      ( foo   (    34    )    )      "
11:57:19 <dmwit> ph88: You'd probably also want something like `getYielded = get <* put []`, I guess.
11:57:20 <metahumor> (Comb [A (I "foo"), Comb [A (N 34)]])
12:01:45 * hackage web-routes 0.27.13 - portable, type-safe URL routing  https://hackage.haskell.org/package/web-routes-0.27.13 (JeremyShaw)
12:04:02 <infinisil> Hey there, also a question about parsers:
12:05:36 <infinisil> I'd like to parse the numbers out of strings like "foo, #10qux #20, bar"
12:05:57 <redrapscallion> so i have this snippet (question is in the paste) : http://lpaste.net/3170057791435964416
12:06:13 <infinisil> I have this: `sepBy1 (char '#' *> (read <$> many1 digit)) (many $ noneOf "#")`
12:06:43 <infinisil> But this doesn't work for when there is stuff before or after the #numbers
12:07:35 <redrapscallion> i'm trying to avoid using a helper function in my snippet, but i'm not sure if that's even a good idea
12:07:36 <infinisil> and just surrounding it with `many anyChar *> ... <* many anyChar` throws an error too
12:10:04 <amalloy> infinisil: to use a parser you generally want a more specific definition of what your data is than "some numbers in a sea of junk". a parser is about constructing meaning from an entire string
12:10:32 <ph88> dmwit, i have a parser and a structure like   data Foo = Foo Text Text  and parser code like   do { text1 <- string "foo"; text2 <- "bar"; return Foo text1 text2 }   can i make it so that i get a list of all previous results even if i don't capture them   _ <- noncapture  ?
12:11:09 <infinisil> amalloy: Hmm.. I see, I'd like to use this to parse PR numbers out of IRC messages. Would regex be suited better?
12:11:39 <amalloy> ph88: what do you mean, previous results?
12:12:04 <ph88> amalloy, what the parser has actually parsed
12:13:20 <metahumor> infinisil: "many (noneOf "#") *> (some (char '#' *> decimal <* many (noneOf "#")))"
12:14:15 <amalloy> ph88: are you asking for something like this? do {_ <- return "foo"; _ <- return "bar"; get} to produce ["foo", "bar"]?
12:14:57 <hyperisco> pi time
12:15:37 <amalloy> i think that is fundamentally impossible because it breaks the Monad laws by making (return x >> f) different from f
12:16:09 <robbym> For JSON parsing should I use `json` or `aeson`?
12:16:50 <robbym> Oh. aeson has more downloads
12:17:02 <robbym> nvm
12:17:07 <infinisil> metahumor: testing.. hold on
12:17:29 <c_wraith> aeson should be considered the default, used unless you have a use case it doesn't work for.
12:18:56 <ph88> amalloy, i thought maybe it can be put in State somehow if bind was implemented in a certain way
12:19:26 <amalloy> ph88: what i'm saying is that implementing bind in that way would be against the law
12:19:46 <ph88> ok :(
12:19:59 <kakashiA1> does anybody know this error if you try to build ghci-mod?
12:20:01 <kakashiA1> AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
12:20:17 <ph88> i miss that in OO i can access sibling parse nodes easily ..
12:20:50 <amalloy> ph88: you have to at least somehow mark a thing as "please save this", which is what dmwit was suggesting via 'yield'
12:21:03 <geekosaur> kakashiA1, you need to upgrade stack
12:21:03 <ph88> but with parsec i have to wait until the whole structure is completed
12:21:27 <ph88> amalloy, what about "please save everything" i'll use it when i need it ?
12:22:05 <amalloy> ph88: the problem is that "everything" is too broad. when you parse "foo", you don't just parse the end result of that: you may parse the character 'f', and then a () for some reason, and then the character 'o', and...
12:22:22 <infinisil> metahumor: Umm, what modules are you using for the some and decimal exactly?
12:22:23 <amalloy> the monad laws exist to guarantee that you don't have to worry about that distinction
12:22:32 <kakashiA1> geekosaur: what is the command to do that?
12:23:35 <ph88> amalloy, i read ghc only does passes after the whole tree is already constructed .. it's fast enough but it seems wasteful to me
12:24:01 <kakashiA1> geekosaur: I am doing it on my old mac, I installed haskell-stack with brew
12:24:15 <metahumor> infinisil: I'm using "some" from Control.Applicative and "decimal" from Text.Megaparsec.Char.Lexer. you could define "decimal" by "some (oneOf "0123456789")"
12:24:28 <ph88> my functional programming skills are not so strong, i'm used to be able to get access to some state
12:27:25 <infinisil> metahumor: Ah I'm using Parsec, need to import Text.Parse.Token for decimal
12:27:30 <infinisil> Parsec*
12:27:37 <kakashiA1> geekosaur: stack --version
12:27:39 <kakashiA1> Version 1.3.2, Git revision 3f675146590da4f3edf768b89355f798229da2a5 (4395 commits) x86_64 hpack-0.15.0
12:28:01 <amalloy> infinisil: you probably want digit, not decimal
12:28:23 <amalloy> read <$> many1 digit
12:28:49 <infinisil> Ah yeah that one works
12:28:59 <i-am-the-slime> I'm still fighting with the Text/String stuff.
12:33:25 <camsbury> hello
12:34:19 <infinisil> Still not entirely what I'm looking for though, I'll think some more about it
12:34:40 <infinisil> (since it prevents "# #10" from being parsed)
12:35:04 <camsbury> could someone assist with a QuickCheck/Monad question?
12:35:07 <metahumor> how would you want "# #10" parsed?
12:35:18 <infinisil> metahumor: Right [10]
12:37:13 <infinisil> e.g. "foo#]+,#10ar#20#" should parse `[10,20]`
12:37:51 <amalloy> camsbury: generally nobody will volunteer to help with an undefined problem, because you never know how hard/time-consuming it will be. but if you ask a specific question, there is usually someone who wants to answer it
12:38:06 <camsbury> fair enough!
12:38:19 <camsbury> so the problem is this
12:38:37 <ph88> if i put Arbitrary and Lens in the same file as the "business logic" does that slow down the code ?
12:39:36 <camsbury> I'm creating an Arbitrary instance for a `First'` Monoid on a `Maybe'`, working though Chris Allen's Haskell book
12:40:06 <camsbury> and I'm supposed to use the `frequency` function to do so
12:40:20 <camsbury> I have used this before, and it is pretty straightforward
12:41:05 <mekeor> how does reflex-dom compare to miso? ( https://github.com/reflex-frp/reflex-dom , https://github.com/dmjio/miso )
12:42:23 <camsbury> however, I am having trouble "lifting" (maybe the wrong term here) my (Gen a) from inside the Maybe' to wrapper type, First', for the arg to frequency
12:42:45 * hackage rss-conduit 0.4.2.1 - Streaming parser/renderer for the RSS standard.  https://hackage.haskell.org/package/rss-conduit-0.4.2.1 (koral)
12:43:16 <metahumor> infinisil: "trash = try (anyChar *> notFollowedBy digitChar) :: Parser ()"
12:43:29 <camsbury> trying to just do a basic frequency [ (1, return (First' Nada)), (1, return (First' b)) ]  -- where b is a Gen a
12:43:58 <camsbury> `frequency [ (1, return (First' Nada)), (1, return (First' b)) ]`
12:44:04 <metahumor> infinisil: "myParser = many trash *> (some (char '#' *> some digitChar <* many trash))"
12:44:05 <camsbury> to attempt to make that more clear
12:44:40 <camsbury> Nada is just Nothing, in this example...
12:44:46 <ph88> camsbury, i think the return should be outside so the thing gets wrapped in Gen automatically
12:45:03 <camsbury> well
12:45:33 <ph88> oh but that might not be your actual problem here
12:45:34 <camsbury> [(Int, Gen a)] -> Gen a
12:45:39 <camsbury> yea
12:45:50 <metahumor> infinisil: works for all of the inputs you sent previously, as well as stuff like "asdf #10 fas#asdf # ## # #20FSa"
12:45:51 <ph88> but you can use monad bind i think
12:45:58 <camsbury> yeah so I tried to do
12:46:21 <ph88> b >>= \b' -> frequency [ (1, return (First' Nada)), (1, return (First' b')) ]
12:47:11 <ph88> hhmm though that might work i think it's nicer to do something else
12:47:11 <camsbury> well
12:47:23 <camsbury> so let me try to clarify
12:47:31 <ph88> frequency [ (1, return (First' Nada)), (1, (First' <$> b)) ]
12:47:32 <camsbury> I'm doing
12:47:41 <camsbury> instance Arbitrary (First' a) where...
12:47:48 <camsbury> oh
12:48:00 <infinisil> metahumor: Sweet! Thanks a lot!
12:48:09 <camsbury> not aware of `<$>` yet
12:48:16 <infinisil> Makes sense, was trying something similar but couldn't quiet get there
12:48:28 <ph88> camsbury, <$> is fmap infix notation
12:48:36 <camsbury> ah
12:48:50 <camsbury> omg
12:48:54 <camsbury> that might be it
12:48:56 <ph88> camsbury, http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
12:49:07 <ph88> i like this page
12:50:02 <ph88> you have    fmap First' (b :: Gen a)   ==  (First' (b :: Gen a) :: Gen FirstType)
12:50:21 <ph88> dunno what you put as type name for First' data constructor
12:51:12 <camsbury> I tried
12:51:18 <metahumor> infinisil: what i've found helpful w building parsers is to try to be as explicit as possible about what I should accept, and how I should reject
12:51:24 <camsbury>   arbitrary =
12:51:24 <camsbury>     frequency [ (1, return (First' { getFirst' = Nada }))
12:51:24 <camsbury>               , (1, return (fmap First' { getFirst' = fmap Only (arbitrary :: (Gen a)) }))
12:51:26 <camsbury>               ]
12:51:32 <ph88> camsbury, what i found lacking explanation is that your data constructor is a function that can be applied .. you will have to think about this a bit because it happens in a lot of places
12:51:54 <infinisil> metahumor: Yeah I learned that too now
12:51:57 <camsbury> there is a record syntax thrown in here as well
12:52:06 <camsbury> but I figured I could ignore telling you that bit
12:52:35 <camsbury> and that link is Great!
12:52:58 <camsbury> I can totally see it as a function to be applied
12:53:20 <camsbury> and so that clicked with me hard, fmapping it into the Maybe type and the wrapper monoid type as well
12:53:33 <camsbury> but I'm still missing something
12:53:38 <hyperisco> writing erotic Haskell fiction are we?
12:53:39 <ph88> camsbury, you can use record as if it's written as   data Foo = MkFoo String String     so if you have function MkFoo and you give it a String you will have MkFooString :: String -> Foo  (need another String to make a Foo)
12:54:14 <camsbury> okay here we go
12:54:27 <ph88> First <*> Only <*> arbitrary  should be the same as   (fmap First' { getFirst' = fmap Only (arbitrary :: (Gen a)) })
12:54:28 <camsbury> newtype First' a =
12:54:28 <camsbury>   First' { getFirst' :: Optional a }
12:54:29 <camsbury>   deriving (Eq, Show)
12:54:39 <camsbury> okay
12:54:54 <camsbury> and
12:54:57 <ph88> because getFirst' is the first (and only) element that you fill
12:55:03 <camsbury> data Optional a =
12:55:03 <camsbury>     Nada
12:55:03 <camsbury>   | Only a
12:55:05 <camsbury>   deriving (Eq, Show)
12:55:10 <camsbury> yes
12:55:13 <ph88> bpaste.net
12:55:16 <ph88> lpaste.net
12:55:31 <metahumor> infinisil: "trashs = many trash; inttoken = char '#' *> some digitChar; myParser = trashs *> inttoken `sepEndBy1` trashs"
12:55:44 <metahumor> infinisil: then, it is nice and clean and succinct
12:55:47 <camsbury> thanks!
12:55:58 <camsbury> so I should be able to do
12:56:23 <camsbury> First <*> Only <*> (arbitrary :: (Gen a))
12:56:26 <camsbury> ?
12:56:41 <camsbury> I feel as though I still need to specify the type on using arbitrary
12:57:01 <camsbury> not sure how <*> compares to <$> but will look
12:57:38 <ph88> camsbury, type inference with type classes (like Arbitrary) really works magic as well. Suppose you have your type  data Foo = F String  with Arbitrary instance. You can just do    getRandomFooValue = arbitrary :: Gen Foo   and it will know which version of arbitrary to choose for you
12:58:16 <camsbury> oh right..
12:58:24 <camsbury> yeah that makes sense
12:58:28 <ph88> camsbury, so in your example the Only data constructor should be requesting some particular type of   arbitrary function  so you don't need to give it a type signature
12:58:37 <camsbury> definitely
12:58:45 <kakashiA1> if I want to build ghi-mod, I get this error:
12:58:47 <camsbury> very clear, thank you
12:58:47 <kakashiA1> AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
12:58:50 <infinisil> metahumor: Nice :D
12:58:52 <camsbury> let me try this one out
12:58:58 <infinisil> metahumor: Thanks a lot for your help
12:58:59 <kakashiA1> does anybody know what to do?
12:59:09 <ph88> eventually on your "top level" you have to specify some concrete type so that all the polymorphic functions work
12:59:47 <metahumor> infinisil: just notice that the most recent "inttoken" is Parser String, while you really want a Parser Int
13:00:11 <infinisil> metahumor: Yeah, I'm just using (read <$> many1 digit) instead
13:00:27 <camsbury> totally
13:00:36 <ph88> camsbury, <*> is for when you want to do <$> a bunch of times .   First <$> (Only <$> arbitrary)   i think it should be the same .. but check type signature in ghci with   :t (<$>)
13:00:54 <camsbury> ah sure
13:01:07 <hyperisco> but <*> cannot be defined in terms of <$>
13:01:07 <metahumor> :t \f -> (pure f <*>)
13:01:08 <lambdabot> Applicative f => (a -> b) -> f a -> f b
13:01:13 <metahumor> :t \f -> (f <$>)
13:01:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:01:33 <ph88> ah ok
13:02:10 <camsbury> lol unfortunately I'm just starting on the "algebras" chapters, and Functor, Applicative, and Monoid are following (I believe in that order)
13:02:16 <ph88> still don't quite know why that is, but i just use <*> and it works for me
13:02:21 <camsbury> so I'm pretty light on understanding those
13:02:39 <guillaum1> Is there a way in template haskell to repport in a quasi quotes with a start/end position so that GHC 8.2 new colored / caret diagnostic will know what to highlight?
13:02:46 <camsbury> anyway I tried dropping the return since mapping these to the inside should bring the `Gen` to the front?
13:02:52 <camsbury> so
13:03:00 <ph88> Applicative must be implementing something that that Functor doesn't
13:04:09 <hyperisco> yeah, pure and <*> :)
13:04:09 <ph88> camsbury, i think i made a mistake to say to get the return out when you said the type should be like  (Int, Gen a)  or something ..
13:04:46 <camsbury> yeah
13:04:47 <camsbury> frequency :: [(Int, Gen a)] -> Gen a
13:04:57 <camsbury> http://lpaste.net/361290
13:05:03 <camsbury> here is my current failing code
13:06:32 <camsbury> I think I do drop the return, because otherwise it complains about Gen (Gen a0)
13:07:05 <hyperisco> @let data Optional a = Nada | Only a
13:07:06 <lambdabot>  Defined.
13:07:16 <hyperisco> @let newtype First' a = First' { getFirst' :: Optional a }
13:07:17 <lambdabot>  Defined.
13:07:19 <ph88> camsbury, you have <*> twice
13:07:32 <hyperisco> :t (<*>) `asAppliedTo` First'
13:07:33 <lambdabot> error:
13:07:33 <lambdabot>     • Couldn't match type ‘First' a’ with ‘a1 -> b’
13:07:33 <lambdabot>       Expected type: Optional a -> a1 -> b
13:07:35 <ph88> camsbury, normally you need   1x  a <$>   and then zero or more  <*>
13:07:48 <amalloy> ph88: we don't want any <*> here
13:07:54 <camsbury> ah okay, maybe my eyes glazed over there
13:08:08 <ph88> amalloy, what do we want ?
13:08:33 <ph88> (First' . Only) <$> arbitrary   ??
13:08:39 <amalloy> yes, that looks great to me
13:08:44 <amalloy> (the parens are redundant, as well)
13:08:50 <ph88> ok
13:09:27 <ph88> (\x -> First' (Only x)) <$> arbitrary     long version i guess
13:09:28 <amalloy> the f <$> x <*> y pattern is for "lifting" a two-argument function f over two applicative values
13:09:34 <hyperisco> it is unusual to use record notation for First'
13:09:44 <amalloy> here you don't have one two-argument function, but two one-argument functions you want to compose
13:09:47 <hyperisco> if you're using record notation you usually have more than one field
13:10:02 <amalloy> hyperisco: except for all the getFoo or runFoo newtypes
13:10:03 <camsbury> yeah idk why it was set up that way
13:10:05 <butterthebuddha> https://gist.github.com/anonymous/60b3dd014ebc81f305508f22931cf863
13:10:14 <camsbury> I think he is just trying to space the repetition for record syntax
13:10:17 <camsbury> and jammed it in there
13:10:24 <camsbury> which is cool anyway
13:10:28 <butterthebuddha> ^ Can someone help me with the implementation of parseSExpr?
13:10:35 <hyperisco> amalloy, where is record notation used to construct or deconstruct them?
13:10:44 <butterthebuddha> It parses "(bar(foo))" but not "(bar (foo))"
13:10:52 <amalloy> oh, for constructing or deconstructing? i agree, that is super weird
13:11:16 <hyperisco> it is normal to define an accessor i.e. projector using record notation, yes
13:11:18 <amalloy> but it wasn't clear from your comment that you were recommending a different way of (de)constructing, rather than a different way of defining the type
13:12:11 <camsbury>     • No instance for (Arbitrary a) arising from a use of ‘arbitrary’
13:12:11 <camsbury>       Possible fix:
13:12:11 <camsbury>         add (Arbitrary a) to the context of the instance declaration
13:12:13 <camsbury>     • In the second argument of ‘(<$>)’, namely ‘arbitrary’
13:12:15 <camsbury>       In the expression: First' . Only <$> arbitrary
13:12:16 <camsbury>       In the expression: (1, First' . Only <$> arbitrary)
13:12:19 <camsbury> and now I'm getting that
13:12:39 <camsbury> once I used First' . Only <$> arbitrary
13:12:45 <hyperisco> mappend (First' Nada) y = y; mappend x _ = x;
13:13:43 <Marisa_> Hi, are there some 'very-type-safe' decision tree in haskell? By that I mean branching is just pattern matching (ignoring floating point for a second) directly on adt, so one can fit an arbitrary long list into decision tree classifier
13:14:01 <camsbury> hyperisco, thanks!
13:14:03 <Marisa_> instead of serializing everything into a giant tuple
13:14:13 <mnoonan> butterthebuddha, you defined an SExpr as a '(', some spaces, some SExprs, some more spaces (and then some *more* spaces :), and a ')'
13:14:14 <Marisa_> with tag and undefined values
13:14:14 <ph88> camsbury, not sure why that is .. your data is polymorphic so it should be ok to use arbitrary without specifying it's type also. But the error means that "i couldn't make a function to generate arbitrary values for all the possible types"
13:14:42 <camsbury> okay... I'll try specifying and see what it says
13:14:45 <amalloy> camsbury: indeed you need to specify that a must be Arbitrary
13:14:53 <mnoonan> butterthebuddha: you probably meant (zeroOrMore parseSExpr <* spaces) to be "zeroOrMore (parseSExpr <* spaces)", I'd bet
13:15:03 <camsbury> oh in the signature
13:15:08 <camsbury> ty @amalloy
13:16:14 <camsbury> how does that fit into instance declarations... I think I had problems with this before
13:16:18 <metahumor> butterthebuddha: you are missing a "spaces *>" before the "char '('"
13:16:27 <camsbury> not sure where to insert the Arbitrary a =>
13:16:38 <ph88> camsbury, did you already add it ?
13:16:40 <ph88> oh ok
13:16:57 <amalloy> camsbury: in an instance declaration, constraints go right after the word "instance", before the rest
13:17:03 <metahumor> butterthebuddha: in a pseudo syntax, you want something like "S(S-Comb[pS]-)S"
13:17:05 <ph88> try   instance Arbitrary a => Arbitrary (First' a) where
13:17:42 <metahumor> butterthebuddha: where S parses spaces, ( and ) parse the '(' and ')', p is your recursive func, and [] is oneOrMany
13:18:05 <metahumor> butterthebuddha: oneOrMany because i don't think this is a valid SExpr "(bar())"
13:18:09 <ph88> camsbury, this looks funny but it says: in order to make a random value First' with First' holding any value i must be sure that whatever the type of the value you put in that type must also implement Arbitrary (so you can generate random values for 'a' as well)
13:18:27 <metahumor> butterthebuddha: if it is, then you can use zeroOrMany
13:19:13 <ph88> camsbury, you put => on your functions if you want to use some of the functions that the type class provides. So if you want to    show a   then you must add    Show a =>
13:19:21 <camsbury> yea
13:19:37 <ph88> camsbury, with  instance you can add your functions to the type
13:19:38 <camsbury> I know to do that, but wasn't sure how to do it for typeclass instances
13:19:43 <camsbury> thanks both
13:20:07 <metahumor> butterthebuddha: if you use my defn, and zeroOrMany, the following will parse properly: "      ( foo (    bar(  ()    34   ))  )  "
13:20:28 <camsbury> wow
13:20:38 <camsbury> types check
13:20:40 <camsbury> tests pass
13:20:42 <camsbury> ty
13:20:42 <camsbury> haha
13:21:21 <camsbury> I should have known to have Arbitrary a =>, I suppose
13:21:48 <camsbury> but the idea of the type constructors being fmapped was new and nice
13:21:51 <camsbury> thanks for that
13:22:00 <ph88> yw
13:30:20 <cocreature> kakashiA1: upgrade stack
13:30:45 <kakashiA1> cocreature: not solving the problem
13:30:57 <cocreature> kakashiA1: which version are you using?
13:31:10 <kakashiA1> 1.6.3
13:31:32 <kakashiA1> cocreature: at the moment I am running stack solver
13:31:37 <cocreature> huh weird, 1.6 should have fixed that bug
13:35:08 <cocreature> kakashiA1: what’s the exact command you’re running and the full error message?
13:35:41 <kakashiA1> cocreature: https://paste.xinu.at/6Yg/bash
13:36:47 <cocreature> kakashiA1: that’s a completely different error than what you’ve been describing before?
13:36:59 <kakashiA1> cocreature: its a new error message
13:37:29 <kadoban> kakashiA1: I don't think ghc-mod works with that version of GHC yet
13:37:38 <cocreature> you need a resolver for 8.0.2
13:37:42 <kakashiA1> cocreature: its the error message if I run "stack build ghc-mod"
13:37:50 <kadoban> So, yeah make the resolver earlier
13:38:15 <kakashiA1> kadoban: I dont understand, what do you mean?
13:38:58 <kadoban> kakashiA1: ghc-mod, the problem you are trying to install, it cares what version of GHC it's on. It's very dependent on GHC. It doesn't work with GHC 8.2.2, the one that's in the resolver you're trying to use. If you want that to work, you have to choose an earlier resolver.
13:39:02 <kadoban> program*
13:39:29 <kakashiA1> kadoban: what command do I have to run to fix this?
13:40:23 <kadoban> Technically you could just 'stack install ghc-mod --resolver lts-9.21 or something. But the thing is, what are you going to be using this for? ghc-mod has to be compiled with the actual GHC version you're going to be using for the project you're using it on. So it's more likely to make sense if you change the resolver value wherever that is first.
13:41:19 <kakashiA1> kadoban: let me try "stack install ghc-mod --resolver lts-9.21"
13:41:28 <cocreature> if you use stack, you might just want to try intero instead of ghc-mod
13:42:17 <kadoban> p.s. I'd also recommend you do 'stack build --copy-compiler-tool ghc-mod' and then use 'stack exec -- ghc-mod' to run it. That makes it so ghc-mod is available for any project that's using the correct version of GHC, and only those ones. If you want it for other versions, you'll have to build again (but that's always required with ghc-mod)
13:51:52 <kakashiA1> kadoban: the command I tried (with the lts-9.21) gives me this error:
13:51:55 <kakashiA1> https://paste.xinu.at/OgT7/bash
13:52:17 <kakashiA1> kadoban: I will try now this command: stack build --copy-compiler-tool ghc-mod
13:53:30 <kadoban> Not sure what that error is, sounds like it failed installing GHC.
13:53:44 <kadoban> kakashiA1: The other command has no reason that it'll fix this.
13:54:50 <kakashiA1> kadoban: https://paste.xinu.at/WTK/bash
13:55:31 <kadoban> kakashiA1: Yes, because now we're back at the issue where it's using a resolver that ghc-mod doesn't support.
13:56:05 <kakashiA1> hmm...maybe I should delete everything and install it again?
13:56:36 <kadoban> kakashiA1: Well, the real problem above seems to be that it doesn't seem to be able to install GHC, you could retry that or try to diagnose it or something.
13:58:10 <fosskers> What's the best CI service for Haskell projects that use Nix?
13:59:26 <fraktor> I'm trying to include a second file that has a data declaration with multiple constructors. I'm trying to use it in a separate file, but it's saying "Not in scope: data constructor 'constructor'". What do I need to change?
13:59:42 <raskell> change your mind about writing haskell
13:59:45 <raskell> duh
14:00:07 <fraktor> raskell: Were you talking to me?
14:03:12 <ph88> cocreature, do you use emacs with intero ?
14:03:33 <ph88> i installed spacemacs but didn't get around to learning it yet
14:04:25 <ph88> fraktor, you need to import the type and you can choose to import all it's data constructors or just a few
14:04:59 <ph88> import Data.Maybe (Maybe(..))    import Data.Maybe (Maybe(Nothing, Just))  i think this was the syntax for it
14:06:15 * hackage hoogle 5.0.16 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.16 (NeilMitchell)
14:06:27 <dmwit> ph88: Parsec allows a user-specified state type, and you can squirrel away anything you want in there manually.
14:07:40 <dmwit> ph88: e.g. `foo <- parseWhatever; modifyState (foo:); return foo`
14:07:59 <dmwit> ph88: Then later actions will be able to see `foo` in the state list.
14:08:22 <dmwit> ph88: That said, I've never needed something like that, and I wonder whether it's possible you have made a design mistake here that's making you think you need that.
14:08:57 <ph88> ye ok .. but then i duplicate the whole tree into the state which is silly   .. By now i also found zipper data structure. Not sure what i'm going to use yet .. just exploring the space for now
14:09:16 <fraktor> ph88: Thank you! That's exactly what I needed.
14:09:32 <Tirant404> what is the main topic for this server?
14:09:39 <ph88> dmwit, i will need state for when the parsing decision depends on something found earlier
14:09:57 <ph88> Tirant404, haskell programming language for this channel, for the server go to #help
14:10:01 <Tirant404> What is the main topic of this server?
14:10:06 <rcdilorenzo> I'd love some feedback on populating a full deck of cards with functions. I'm just exploring the language and I feel that there's a more succinct way to write the last few lines of the code here: http://lpaste.net/361293.
14:10:39 <dmwit> ph88: "but then i duplicate the whole tree" sounds compatible with your request, namely, "can i make it so that i get a list of all previous results" -- not a "but", but an "great".
14:11:27 <ph88> ok ok ^^
14:11:57 <dmwit> ^_^
14:12:11 <lyxia> rcdilorenzo: liftA2 Card allRanks allSuits
14:12:27 <amalloy> rcdilorenzo: Deck $ Card <$> allRanks <*> allSuits
14:12:34 <amalloy> equivalently, what lyxia wrote
14:12:53 <dmwit> Well, Deck $ {- what lyxia wrote -}
14:12:54 <dmwit> ;-)
14:12:55 <ph88> where did concatMap go ?
14:13:08 <dmwit> ph88: Into the `liftA2` or the `(<*>)`.
14:13:09 <amalloy> ph88: it's in <*>
14:13:43 <fraktor> Is there a way for me to declare a map that is accessible from within the entire file without recomputing the map each time?
14:13:50 <rcdilorenzo> You guys are awesome. I love the "succinctness". (probably not even a word)
14:14:09 <dmwit> fraktor: Yes, sure: `myFancyMap :: Map String Property; myFancyMap = ...`
14:14:36 <fraktor> dmwit: Thanks. That's what I was doing, and it seemed to be working, but I wondered if there isn't a more functional way to do it.
14:14:53 <ph88> that would be it i think ^^
14:14:55 <ph88> :p
14:15:12 <ph88> it's not gonna recompute every time you use it
14:15:40 <fraktor> If I defined it inside a function using a where clause (since it's only actually used by one function) would it recompute every time?
14:15:45 <dmwit> I don't understand "more functional". But this way is very idiomatic.
14:15:53 <fraktor> dmwit: What's what I mean.
14:16:43 <dmwit> fraktor: It's complicated. For `foo a b = ... where ...`, the contents of the `where` clause will be recomputed each time `foo` is applied to two arguments.
14:17:04 <fraktor> dmwit: Okay. That's what I was doing before, and it seemed kinda slow.
14:17:05 <dmwit> fraktor: N.B. `let f = foo x y in f z + f z'` will not recompute the contents of the `where` clause.
14:17:52 <dmwit> fraktor: So if there can be some precomputation, it is common to transform `foo x y = ... where ...` to `foo = \x y -> ... where ...`.
14:17:56 <ph88> fraktor, you can compile your program with profiling and take a look how many times that function runs ^___^
14:18:10 <dmwit> fraktor: Sometimes the compiler will do this transformation for you when optimizations are on.
14:18:38 <fraktor> dmwit: Wow. That's really... weird to me, I guess, since I'm not doing any IO or anything. But I'll remember that if it comes up.
14:19:02 <dmwit> fraktor: (or, say, `foo x = \y -> ... where ...` to indicate that some computation can be done after applying one argument but not before both arguments)
14:19:32 <ph88> dmwit, why is that it doesn't need to recompute with 1 argument but it does with 2 ?
14:20:17 <dmwit> ph88: Your question is based on a misunderstanding. I am using two-argument functions only to illustrate the differences between `f x y = ...`, `f x = \y -> ...`, and `f = \x y -> ...`, not because two-argument or one-argument functions are special in any way.
14:21:05 <dmwit> (Also, it's worth noting that everything I say here is about GHC, not Haskell.)
14:21:31 <fraktor> dmwit: I'm using GHC, so it's relevant. But it's good to know that not every compiler will optimize this particular case.
14:22:43 <dmwit> ph88: ...specifically: the difference is between whether the argument comes before the `=` or in a lambda after it, not in the concrete number of arguments.
14:22:56 <amalloy> fraktor: usually it will not optimize that implicitly for you, because that's making a time/space tradeoff that could be wrong. if it caches, it saves computation time at the expense of more memory. the compiler doesn't necessarily know whether the computation is fast/slow or whether the result is small/large
14:23:11 <dmwit> more arguments to the left of the `=` -> more recomputation
14:24:02 <ph88> dmwit, why is it that it matters if the arguments is before or after =  ?
14:24:33 <ph88> also .. knowing this .. why wouldn't i want to put all arguments on the right now ?
14:24:34 <dmwit> No deep theoretical reason. It's just a convenient way to give the programmer some control.
14:24:56 <dmwit> Often you *can't* put some arguments to the right. Any variables to the right are not in scope inside the `where` block.
14:25:13 <ph88> AHA !
14:25:26 <fraktor> dmwit: Here's the map that I'm creating. Would it be worth it to recompute it every time to save on memory?
14:26:30 <fraktor> https://paste.ubuntu.com/26315590/
14:26:32 <dmwit> But besides that syntactic reason, there's also an operational reason, as amalloy said above: sometimes caching is undesirable.
14:26:53 <dmwit> e.g. when the value computed is cheap but large
14:27:28 <ph88> but the value still needs to be a lazy structure right? otherwise it would get allocated anyway
14:27:54 <dmwit> fraktor: I would not worry about the memory usage of this value in 99% of cases.
14:28:04 <dmwit> In the other 1% of cases I would not choose Haskell. =)
14:28:10 <fraktor> Okay. Then I'll leave it precomputed.
14:28:18 <fraktor> What is that 1% of cases then?
14:28:52 <dmwit> On some super tiny device that can't handle storing a couple hundred bytes for some reason? Like, a microcontroller or something.
14:29:08 <dmwit> Probably wouldn't even have Haskell available in the only situations I can think of where I'd want to avoid keeping that in memory.
14:29:16 <fraktor> Ah. So basically, embedded systems.
14:30:23 <amalloy> that pieceValues map shouldn't even exist if you can't afford to save it in memory, since it's just a lookup table
14:31:23 <fraktor> Also, I've got a new type SearchResult that can fail. Should I include a "Nothing" style result in my data declaration, or just wrap it in a Maybe?
14:32:33 <amalloy> fraktor: i'd wrap it in maybe personally, so you can reuse all the maybe-supporting functions that already exist
14:35:45 * hackage texbuilder 0.1.4.0 - View your latex output while editing  https://hackage.haskell.org/package/texbuilder-0.1.4.0 (xaverdh)
14:36:15 * hackage hslua 0.9.4 - A Lua language interpreter embedding in Haskell  https://hackage.haskell.org/package/hslua-0.9.4 (tarleb)
14:44:31 <robbym> What is the go to package for command line parsing?
14:44:50 <lyxia> optparse-applicative
14:44:54 <kadoban> optparse-applicative is quite popular. I forget what the other one is.
14:45:10 <robbym> cool thanks
14:48:31 <lyxia> also check out optparse-generic, it builds a very simple interface on top of it
15:13:09 <metahumor> what happens if I run groupBy on an infinite list?
15:13:46 <metahumor> can i access whatever groups there are even if no group itself is promised to be closed?
15:14:23 <amalloy> groupBy only groups consecutive matches
15:14:38 <kadoban> > groupBy (==) [1..]
15:14:39 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17]...
15:15:03 <amalloy> > groupBy (==) $ cycle [1,1,2]
15:15:05 <lambdabot>  [[1,1],[2],[1,1],[2],[1,1],[2],[1,1],[2],[1,1],[2],[1,1],[2],[1,1],[2],[1,1]...
15:15:21 <metahumor> boo
15:15:22 <kadoban> > groupBy (==) ([1..5] ++ repeat 6)
15:15:24 <lambdabot>  [[1],[2],[3],[4],[5],[6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,...
15:15:45 <kadoban> So yeah, it seems like it'll do about as much as it's possible to do with infinite lists.
15:18:25 <fraktor> if I have a function func that returns true or false, and I need to filter a set of tuples where the value I'm testing is the second part of the tuple, how can I do that? Is the best way filter (\x -> func $ snd x) ...?
15:18:46 <metahumor> :t filter (snd)
15:18:47 <lambdabot> [(a, Bool)] -> [(a, Bool)]
15:19:01 <Gurkenglas> Why doesn't hayoo find restrictKeys ?
15:19:04 <metahumor> :t \f -> filter (f . snd)
15:19:05 <lambdabot> (b -> Bool) -> [(a, b)] -> [(a, b)]
15:19:49 <metahumor> fraktor: so in your case, you use "filter (func . snd)"
15:21:11 <fraktor> Thanks.
15:23:23 <metahumor> quit
15:23:25 <metahumor> whoops
15:38:52 <Gurkenglas> Shouldn't semigroup's stimes for IntSet error on 0?
15:40:09 <kadoban> Gurkenglas: The docs seem to say it's allowed to, but doesn't seem to say it must
15:41:27 <aberrant> hi all
15:41:53 <aberrant> anyone using python (specifically, ipython) with vscode? I'd like to make ipython the default REPL, but I can't find instructions on how to do that.
15:42:03 <aberrant> er, damn, wrong channel. sorry.
15:42:16 <sqooq> hi y
15:42:19 <sqooq> hi y'all
15:42:29 <sqooq> how do I abstract away the concept of discrete delay
15:42:39 <sqooq> recursive use
15:45:14 <erisco> sqooq, what is a "discrete delay" and a "recursive use"?
15:47:21 <Boarders> I was trying to learn TypeLits and used it to write some modular arithemtic stuff using like: newtype Mod i (n :: Nat) = Mod i
15:47:53 <Boarders> at this point I want some function which if I give it f 5 3 it will give me back 3 in Z/5Z
15:47:56 <sqooq> erisco, I think I'm thinking too specifically. Are you aware of signal delay in audio processing? Do you think you can lead me in the right direction to implement that in haskell while accomodating for recursion etc.
15:48:09 <sqooq> See I guess I could do some IO magic, but trying to think about that route, I still am not sure
15:48:15 <sqooq> right now i'm using:
15:48:41 <sqooq> hold on lol
15:48:54 <Boarders> is there an easy way to do this using TypeLits
15:49:08 <erisco> audio processing is several hundred pages away in my book that just arrived
15:50:15 <sqooq> http://lpaste.net/361297
15:50:22 <erisco> Boarders, is integer division defined? I can't remember. If so, use that
15:50:28 <sqooq> this only works for single delay and is still clunky
15:51:28 <Boarders> erisco: how does integer division help me?
15:51:29 <erisco> I have no intuition for what you are working on sqooq, so probably someone else should help
15:52:06 <sqooq> :(
15:52:07 <sqooq> rip
15:52:23 <sqooq> erisco, maybe I can make it more abstract?
15:52:49 <sqooq> I think in other languages it's just a buffer
15:52:51 <Rembane> sqooq: Why doesn't it work for other kinds of delays?
15:53:04 <Rembane> sqooq: Or maybe how...
15:53:15 <sqooq> Rembane, it's single variable. I guess I could make it take a list but then I have to worry about the list implementation
15:53:20 <erisco> Boarders, you may have modulus too, I dunno, and if not you can use division to define it
15:53:22 <sqooq> either way it's already messy, that makes it messier
15:53:37 <sqooq> in other audio languages, you make your del and you send shit through it and stuff comes out
15:53:51 <sqooq> idk
15:53:54 <Rembane> sqooq: Maybe you should take a look at conduits.
15:54:12 <Rembane> sqooq: https://hackage.haskell.org/package/conduit
15:54:44 <erisco> and if not then use repeated subtraction
15:54:53 <erisco> or something smarter
15:54:59 <sqooq> repeated subtraction?
15:55:36 <erisco> been trying FF at work and now I can't remember my Chrome hotkeys =\
15:56:13 <sqooq> Rembane, this seems useful
15:56:22 <Rembane> sqooq: Good.
15:56:30 <Rembane> erisco: This means that you must change to FF instantly.
15:56:59 <erisco> lets see… docs say you get +, *, ^, <=?, and <=
15:57:11 <erisco> not even subtraction? barbaric
15:57:25 <Rembane> No negation?
15:57:42 * erisco *shrugs*
15:58:06 <Rembane> Oh
15:58:07 <kadoban> Probably because they're naturals and it wouldn't be closed under subtraction. At a guess anyway.
15:58:36 <erisco> yeah but then it can just refuse to reduce the expression, but w/e
15:58:58 <kadoban> Ah. Yeah I'm not sure how those things work at all in practice, I've only seen people talk about them here xD
16:01:04 <erisco> so  a / b  can be implemented by counting how many times we need to add  a  to itself to get a number strictly greater than b
16:01:16 <lyxia> I see subtraction https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-TypeLits.html#t:-45-
16:01:38 <erisco> but if you're doing the legwork anyways you may as well implement divMod directly
16:01:54 <erisco> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#type-level-literals
16:02:35 <erisco> docs not in sync? can't believe it
16:04:03 <EvanR> expand all the way
16:05:11 <EvanR> division and a by b is deciably either illegal because b = 0, b divides a evenly into q parts, or has a remainer strictly between 0 and b
16:05:20 <EvanR> division of*
16:05:39 <Boarders> here is the sort of thing I am trying to do: http://lpaste.net/361298
16:05:47 <Boarders> which doesn't work
16:06:38 <Boarders> where the other main function it calls is: http://lpaste.net/361299
16:07:32 <Boarders> I don't really know what I am doing with TypeLits so it is probably a bit of a mess
16:08:52 <lyxia> please explain "doesn't work"
16:09:08 <lyxia> what is the error?
16:09:54 <Boarders> get this error: http://lpaste.net/361300
16:10:58 <lyxia> line 8 should be Mod Integer n
16:11:42 <lyxia> p is a value-level variable
16:11:48 <lyxia> Mod Integer p  is a type
16:11:58 <lyxia> these are two different namespaces
16:12:16 <Boarders> god i am an idiot
16:12:20 <Boarders> thanks
16:12:38 <lyxia> yw
16:14:09 <erisco> pst go try Idris
16:14:29 <Boarders> I have tried a bit of agda
16:14:32 <erisco> you can only keep sane for so long with singletons
16:14:34 <Boarders> it is very pleasant
16:15:16 * hackage htoml-megaparsec 1.0.1.12 - Parser for TOML files  https://hackage.haskell.org/package/htoml-megaparsec-1.0.1.12 (vmchale)
16:15:36 <natrys>  /quit
16:15:46 <lyxia> Boarders: your pastes don't look too bad actually
16:16:50 <lyxia> aside from the natural awkwardness of trying to do dependently-typed Haskell
16:19:18 <erisco> actually Idris may only enable the disease
16:20:30 <ph88> if function a calls b calls c   does putting HasCallstack show a (partial) callstack if something goes wrong in c ?
16:20:49 <erisco> tias?
16:21:09 <ph88> ye i did, it didn't work .. but how is it suppose to work ?
16:21:16 <erisco> > let f x = g x; g x = h x; h
16:21:18 <lambdabot>  <hint>:1:28: error:
16:21:18 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
16:21:54 <erisco> bumped my return key… but you can type up a quick example
16:21:59 <Boarders> lyxia: thx!
16:24:41 <erisco> ph88, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#hascallstack
16:24:46 <erisco> bookmark that page
16:32:36 <ph88> erisco, when i define my own function errorWithCallStack like in the docs it works, but when i use error i don't get a callstack, but i should get one according to the docs  https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Stack.html#v:errorWithStackTrace
16:32:41 <ph88> i'm on lts-10.2
16:33:59 <geekosaur> "error" itself doesn't, you need to import and use that function (or define it yourself)
16:34:08 <erisco> where does it say you should get a callstack with error?
16:34:35 <ph88> in that link i just gave in the description it says:   Like the function error, but appends a stack trace to the error message if one is available.
16:35:11 <ph88> and then when you click on error which takes you here    https://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:error   below that you see a function   errorWithoutStackTrace    with description    A variant of error that does not produce a stack trace.
16:35:19 <erisco> ph88, what is your version of base?
16:36:05 <ph88> 4.10.1.0
16:36:05 <geekosaur> actually iirc the docs *are* a bit confusing about that. I think someone did not fully clean things up when it was decided to keep "error" not making stack traces by default
16:36:13 <geekosaur> as opposed to only doing so inside base
16:36:59 <erisco> well then Haddock has the wrong docs and sources too
16:37:05 <erisco> or Hackage does
16:37:08 <ph88> is there something i can control that enables stacktrace with error ?
16:37:32 <ph88> geekosaur, how do you know it was decided? from trac ?
16:38:03 <geekosaur> #ghc discussion iirc
16:38:51 <ph88> ok
16:39:05 <erisco> use what works for now and file a ticket if there isn't one
16:39:43 <ph88> well the docs conflict with the behaviour i'm seeing .. so i think it would warrant a ticket
16:41:06 <erisco> sounds like someone got thrown off the bridge
16:42:09 <ph88> ha ?
16:42:32 <erisco> British humour isn't for everyone
16:42:59 <hpc> if it was it would be called humor
16:43:00 * hpc ducks
16:43:15 <erisco> lol
16:43:51 <ph88> how do i get a stacktrace when i get an exception ?
16:44:21 <hpc> i vaguely remember there being a flag you need to set when building the program
16:44:26 <ezyang> in modern GHC, you can use CallStack
16:44:36 <ezyang> in older GHC, you can also recompile with profiling to get stacks
16:44:41 <hpc> but that might have been a draft iteration of the feature
16:44:45 <geekosaur> +RTS -xc
16:45:01 <ph88> ezyang, yes i like to use HasCallstack .. but that doesn't work
16:45:10 <geekosaur> may require compiling with profiling to get full stack traces
16:45:40 <ezyang> ph88: You need to propagate the constraint to each call site you want to propagate a stack from
16:45:51 <ezyang> generally, the beginning of the call stack tells you where to start
16:46:16 <geekosaur> ^ this is deliberate, as keeping a CallStack has some runtime overhead
16:46:42 <geekosaur> so you get to control where/how much, but that means you *must* specify
16:47:07 <ph88> ezyang, not sure what that means propagate the constraint to each call site  .. but i have my code like this at the moment   https://bpaste.net/show/b7b45a4045bf
16:47:37 <geekosaur> every function that you want to show up in the call stack has to have a HasCallStack constraint
16:47:43 <geekosaur> in its type
16:47:59 <ph88> geekosaur, do you know any reference of how much the overhead is? Does it come into play when no callstack was used ?
16:48:01 <EvanR> the constraint here corresponds to an actual runtime object being passed to a function
16:48:10 <geekosaur> ^
16:48:16 <geekosaur> you have ovewrhead for it, period
16:48:36 <geekosaur> the compiler can;t know ahead of time whether a callstack will be used at runtime or not
16:49:21 <geekosaur> adding the constraint means extra code is generated to manage the call stack implicit parameter
16:57:55 <fraktor> So ugly code incoming: I'd like a way to create a map that represents the layout of multipliers (e.g. double word score, double letter score etc). This is the most concise code I was able to come up with, and it's really, really, REALLY bad.
16:58:53 <fraktor> https://pastebin.com/3vxVZxYN
16:59:55 <Gurkenglas> fraktor, you might want to mention to us that this is related to the board game scrabble. As I wrote this line pastebin still hasn't responded?
17:00:15 <Axman6> same here
17:00:32 <kadoban> pastebin seems to be having problems at the moment, more than it usually does. Maybe a good idea to use a different site, lpaste.net or gist.github.com are good.
17:01:21 <fraktor> will do. And yes, this is related to scrabble.
17:02:16 <fraktor> lpaste.net/361305
17:02:24 <fraktor> Oh sorry, that's not clickable.
17:02:30 <fraktor> http://lpaste.net/361305
17:02:31 <ph88> i put HasCallstack everywhere i could how can i get a callstack with HasCallstack this way ?   https://bpaste.net/show/033d4ccb4329
17:02:57 <kadoban> fraktor: That could be a lot worse
17:05:17 <kadoban> fraktor: I'd probably change the 'n' into something else, like maybe . or - just so the actual things stick out more. laidOut could be a little less funky. You could just zip [1..]  each line and then zipWith [1..] the lines to add the other coordinate, but whatever, it works.
17:05:18 <fraktor> kadoban: But it could also be a lot better (probably, unless string parsing is the only way to go about compactly representing this.)
17:05:49 <kadoban> I'm sure there's other ways, but this has decent properties, like you can visually tell if it's super wrong immediately.
17:06:18 <kadoban> Like you could do it by formula I guess, specify which coords are the Ts and etc., but then it'll be harder to tell if you screwed up.
17:07:04 <kadoban> *shrug* maybe someone else will have a bigger problem with it, but I think it's fine in principle.
17:08:18 <fraktor> Alright. It'll be reasonably fast, especially since it's just calculating a lookup table.
17:14:38 <kadoban> Yeah, you'd have be doing something pretty weird for speed to matter.
17:19:19 <Gurkenglas> fraktor, http://lpaste.net/361305#a361306 this better?
17:22:55 <Gurkenglas> fraktor, http://lpaste.net/361305#a361306 another one
17:24:44 <fraktor> Gurkenglas: Hmm. Those look interesting (and it looks like I should be using zipWith), but the lines are becoming somewhat unwieldy.
17:25:04 <fraktor> Also, is there a function like "try" that returns pure values, rather than IO ones?
17:28:47 <Gurkenglas> fraktor, http://hackage.haskell.org/package/spoon-0.3.1/docs/Control-Spoon.html#v:teaspoon have fun with your eldritch double-edged powers
17:29:52 <geekosaur> fraktor, you should really not try to handle exceptions in pure code
17:30:17 <geekosaur> so, there shouldn;t be such a function, but "spoon" pretends for you. this will expose you to many sharp edges.
17:36:42 <fraktor> Alright. I'll find a way around it.
17:38:50 <Gurkenglas> fraktor, http://lpaste.net/361305#a361306
17:42:12 <Gurkenglas> (Oh, the indices are swapped on this one.)
17:42:38 <fraktor> Gurkenglas: Good god. That's very concise and beautiful... but I'm just learning haskell, and I don't know what half of those things are.
17:42:48 <fraktor> But I will certainly try to examine it.
17:42:54 <Gurkenglas> Welcome to lens
17:42:54 <kadoban> It's mostly just lens stuff
17:43:09 <Gurkenglas> Where everything is concise and beautiful and you don't know what half of those things are
17:43:27 <kadoban> I personally wouldn't use it unless lens is already being used heavily in your codebase, but it is quite nice.
17:44:20 <fraktor> What is lens?
17:44:29 <kadoban> A popular library
17:44:35 <Gurkenglas> A library that specializes in manipulating nested data structures
17:47:58 <mnoonan_> fraktor: imagine if field labels were a first class thing you could manipulate / compose / pass around / etc in C++ / Java / Python / whatever. that gets you a step towards lens.
17:49:19 <Gurkenglas> A lens shows how a small type can be seen as being like a record field of a big one. A prism shows how a small type can be seen as being like the argument types to a constructor of a big one. If something is a prism and a lens we call it an iso and it shows like the big type is a newtype wrapper of the small one. If something is a prism or a lens we can call it an affine traversal, which one can see as targeting
17:49:19 <Gurkenglas> 0 or 1 values of the small type within the big one. A traversal can target any number of values of the small type within the big one. An indexed traversal also carries along coordinates such as the ones you wanted here. Each of the words just introduced describes a kind of optic. Every optic can be seen as a function that turns actions on a small type into actions on a big type, where what action means depends on
17:49:19 <Gurkenglas> what sort of optic we are talking about. In fact, every optic is just exactly that function. Therefore, optics can be composed.
17:52:05 <Gurkenglas> itraversed is an indexed traversal that targets each of the values in a traversable container such as the values of type a in a value of type [a], while also carrying along indices within that list. <.> combines two indexed traversals such that treating the composition as a traversal is like composing each indexed traversal after treating them as a traversal, except that the indices are combined into a pair.
17:53:13 <Gurkenglas> to converts a function "s -> a" into an optic that can only lift actions which grant no more power than getting back a function "s -> a".
17:54:29 <Gurkenglas> _Just is a prism of the Just constructor. Since we are treating it as a traversal here, we say that it targets the a within the given Maybe a.
17:54:51 <Gurkenglas> "targets every a within the given Maybe a", you might say.
17:55:15 <fraktor> I don't understand enough to understand what you're saying.
17:55:33 <fraktor> I'm glad for the explanation, but it's wasted on me.
17:56:07 <Gurkenglas> I'm also practicing explaining this, trying to find better models along the way and perhaps also helping some other people that are reading along.
17:56:37 <Gurkenglas> And who knows, someday we may find a newbie that gets it all on the first try and keeps running past ekmett :P
17:59:00 <fraktor> Conditions short-circuit when the first and is incorrect, yes?
17:59:23 <Gurkenglas> > False && undefined
17:59:25 <lambdabot>  False
17:59:36 <Gurkenglas> yep
17:59:43 <fraktor> > False && [False, True, False] !! 6
17:59:45 <lambdabot>  False
18:00:18 <Gurkenglas> I'll want to see that code when you're done, looks improvable :P
18:00:32 <mnoonan_> @src (&&)
18:00:32 <lambdabot> True  && x = x
18:00:32 <lambdabot> False && _ = False
18:00:49 <mnoonan_> ^ only inspects the second arg if the first was False
18:01:29 <Gurkenglas> ^@.., which has lower precedence than composition, then takes line 5 and turns it into a function [[Char]] -> [((Int, Int), Multiplier)]
18:01:34 <fraktor> Gurkenglas: That's not actually what I needed to check, but it's a simpler way to reduce it down.
18:10:05 <Gurkenglas> mnoonan_, the other way round
18:10:16 <Gurkenglas> boolean blindness strikes again
18:10:24 <mnoonan_> whoops
18:11:02 <Gurkenglas> "If a sign error would defeat you, you have already lost."
18:12:14 <vaibhavsagar> hi friends, has anyone seen this error before? https://gist.github.com/bts/0f0abdef6f69b1a165181ef1d1be0360
18:12:41 <vaibhavsagar> and/or knows of a fix?
18:12:57 <vaibhavsagar> someone suggested GHC 8.2 but that didn't seem to make a difference
18:17:39 <kakashiA1> I get this error if I run "stack build" or "stack build ghc-mod":
18:17:41 <kakashiA1> https://paste.xinu.at/ktvFv/
18:19:14 <kadoban> kakashiA1: ghc-mod will not work with that version of GHC or that resolver. Use the other one.
18:19:32 <kakashiA1> kadoban: what version should I install?
18:19:58 <kadoban> The resolver that we talked about earlier seemed appropriate, too lazy to look it up again.
18:22:10 <kakashiA1> kadoban: you didnt give me a version :(
18:24:38 <kadoban> Well, if it didn't stick last time I'm sure not going to bother again then.
18:24:50 <Gurkenglas> You should be able to review your earlier conversation in the logs linked in the topic
18:25:31 <monochrom> Cloud-sourcing memory, eh?
18:30:13 <kakashiA1> kadoban: what you offered me was: stack install ghc-mod --resolver lts-9.21
18:30:47 <kadoban> That looks like a resolver to use then, AFAIK.
18:31:44 <geekosaur> vaibhavsagar, that is normally seen on Arch, and notin conjunction with nix
18:32:02 <vaibhavsagar> geekosaur: thanks, is there a fix/workaround you know of?
18:32:15 <vaibhavsagar> I'm trying to statically link a haskell binary
18:32:18 <geekosaur> none applicabee to your situation, if what I said did not tell you that
18:32:44 <geekosaur> oh. static, on a system requiring PIE? you probably lose
18:32:53 <geekosaur> don;t bet on *any* static executable working
18:32:55 <vaibhavsagar> even with GHC 8.2?
18:33:04 <geekosaur> even woith *gcc*
18:33:16 <geekosaur> PIE requires all executables be shared objects
18:33:51 <vaibhavsagar> how do other platforms do it?
18:33:57 <vaibhavsagar> e.g. Go
18:34:14 <geekosaur> do they do so on a platform configured for PIE?
18:34:23 <kadoban> kakashiA1: Sorry this is not me at my most helpful, but I mean ... we've been here before, why are we starting over at the beginning? Did you retry the GHC thing that gave an error, or figure out why that was happening by any chance?
18:34:24 <geekosaur> "position independent executables"
18:34:52 <geekosaur> usually if that is enabled, you can't *run* anything that is not a position independent executable without root setting some special flag permitting the exception
18:35:08 <geekosaur> becaue PIE is a security function
18:35:14 <mniip> not only
18:35:48 <mniip> PIE is also a convenience when your executable is a rtld or something along the lines of that
18:36:39 <geekosaur> but people who run into this are running into the OS linker defaulting to forcing PIE executables\
18:36:50 <geekosaur> or has this just become "let's play weird special cases"?
18:37:13 <vaibhavsagar> no, I just want to statically link this binary
18:37:19 <vaibhavsagar> it works for other things, but not this case
18:37:26 <mniip> geekosaur, I had an urge to nitpick
18:37:38 <vaibhavsagar> http://vaibhavsagar.com/blog/2018/01/03/static-haskell-nix/
18:37:43 <geekosaur> yes, nitpicking helps so much when there's a user question about
18:37:47 <mniip> yeah!
18:37:58 * geekosaur is done; let the nitpickers deal
18:39:08 <monochrom> Obtaining static exes on Arch is going to be a lot of work.
18:39:21 <geekosaur> this is not arch
18:39:28 <geekosaur> and arch doesn't do PIE anyway
18:39:34 <geekosaur> vaibhavsagar, the best I can do is suggest you ask someone who knows about Nix on your platform. nix's interceptor scripts often interfere with linker options, and that is probably what's happening here
18:40:02 <vaibhavsagar> cool, thanks geekosaur
18:41:45 * hackage monad-task 0.2.0 - A monad transformer that turns event processing into co-routine programming.  https://hackage.haskell.org/package/monad-task-0.2.0 (PaulLiu)
18:44:45 * hackage GLFW-task 0.3.0 - GLFW utility functions to use together with monad-task.  https://hackage.haskell.org/package/GLFW-task-0.3.0 (PaulLiu)
18:57:52 <kakashiA1> if I run this: "stack install ghc-mod --resolver lts-9.21" I get this error:
18:57:54 <kakashiA1> Warning: Installation path /Users/kakashi/.local/bin not found on the PATH environment variable.
19:00:06 <kadoban> kakashiA1: Yes, you should probably add that to your PATH. Usually in the ~/.profile file or something similar.
19:02:19 <kakashiA1> kadoban: sorry for the stupid question, but exactly do I have to put where?
19:04:01 <kadoban> kakashiA1: So, the $PATH is what your OS uses to find executables to run when you type their name. It's a list of directories for it to look in. Stack is telling you that the directory it's going to put executables you 'install' with it, is ~/.local/bin/, and that that directory isn't on your PATH. So you won't be able to run those executables, like you won't be able to type 'ghc-mod' and have it run. To fix that ... kind of depends on your OS. Are you
19:04:03 <kadoban> on a linux of some variant?
19:04:15 <kakashiA1> osx
19:04:56 <kadoban> Oh. Uhm, I'm not sure what file that usually goes in on osx, or if you even set it that way. Is there a ".profile" file in /Users/kakashi/ maybe?
19:06:01 <kakashiA1> so in the .profile, what exactly do I have to add
19:06:39 <geekosaur> OS X is likely to have a .bash_profile
19:08:45 <kadoban> kakashiA1: Near the end, add a line like:  export PATH="$HOME/.local/bin:$PATH"    possibly, something like that. And then you'll have to do something to make it take effect, or just restart the computer. On mine to make it take effect is just running "source .profile" on the command line, but YMMV.
19:09:28 <kakashiA1> kadoban: I will try:  export PATH="$HOME/.local/bin:$PATH"
19:13:57 <kakashiA1> kadoban: this is how my .bash_profile look now:
19:13:58 <kakashiA1> https://paste.xinu.at/mZC/bash
19:14:59 <kadoban> kakashiA1: That looks fairly likely to work to me
19:15:47 <kakashiA1> kadoban: let me give stack install ghc-mod --resolver lts-9.21 another try :)
19:20:42 <sqooq> HI
19:20:57 <sqooq> like
19:22:11 <JuanDaugherty> k
19:24:24 <sqooq> where'd the conduit dude go
19:24:45 * hackage hindent 5.2.5 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-5.2.5 (sighingnow)
19:27:19 <fraktor> can I do something like "type Piece = Maybe Char"?
19:28:22 <geekosaur> yes
19:29:20 <geekosaur> ...just be aware "type" creates an alias/synonym.
19:29:32 <fraktor> Yes. That's what I want.
19:30:45 * hackage unliftio-core 0.1.1.0 - The MonadUnliftIO typeclass for unlifting monads to IO  https://hackage.haskell.org/package/unliftio-core-0.1.1.0 (MichaelSnoyman)
19:32:28 <kakashiA1> kadoban: not working, I got the same error message:  https://paste.xinu.at/ktvFv/
19:32:55 <kakashiA1> I am running stack solver for more than 5 minutes
19:33:27 <infinisil> Um, this might sound stupid, but how can I make the main thread block forever? I'm using a library that spawn a background process which does the actual work
19:34:11 <infinisil> Until now I was just using `getLine` which worked fine, but now I'm running it in a systemd service where there is no stdin, so it errors immediately
19:34:50 <monochrom> base 4.10.1.0 means you're with GHC 8.2
19:38:52 <amalloy> infinisil: make the main thread wait for the result of the background process. i'm not sure there's a way to wait for a thread directly, but at worse you could create an MVar that the background thread writes to when it's done (or never, if it never finishes), while the main thread reads from that MVar before exiting
19:39:39 <infinisil> hmm that would work, I'll see if I can hook into the background process somehow
19:40:16 <fraktor> if I have a type that is binary (in my case, data Status = OnBoard | InHand), how can I turn a boolean into that value?
19:40:20 <fraktor> Concisely, I mean.
19:40:51 <sqooq> bool OnBoard = 1; bool InHand = 0
19:41:09 <sqooq> or True/False
19:41:10 <sqooq> whatever
19:41:12 <amalloy> fraktor: bool OnBoard InHand
19:41:12 <Gurkenglas> bool OnBoard InHand :: Bool -> Status
19:41:24 <Gurkenglas> :t bool
19:41:25 <lambdabot> a -> a -> Bool -> a
19:41:34 <sqooq> O woops I did it backwards
19:41:37 <sqooq> Status -> Bool
19:41:39 <fraktor> awesome. That's perfect.
19:42:21 <Gurkenglas> fraktor, False case is first, compare to "fromMaybe default" where False is morally like Nothing
19:43:16 <geekosaur> derive Enum, then I had at one point twiddle = toEnum . fromEnum. :)
19:43:17 <Gurkenglas> fraktor, if you are annoyed that you need a mnemonic, you are not alone. I recommend using constructs like Maybe where possible instead.
19:43:57 <kadoban> kakashiA1: We're back to using the wrong resolver again.
19:44:47 <Gurkenglas> (I also went through similar troubles installing the likes of ghc-mod, there should be a more beginner-friendly interface.)
19:45:06 <MarcelineVQ> I propose we call it ghci
19:45:15 <Gurkenglas> No, to installing things with stack
19:45:21 <MarcelineVQ> it could revolutionize how people think of programming with static types
19:45:52 <kadoban> Gurkenglas: stack can't really do anything about ghc-mod not working with current GHC
19:46:54 <Gurkenglas> "Versions of ghc-mod only work with corresponding versions of ghc. Press M to build the version of ghc-mod that fits with your version of ghc. Press G to use the version of ghc that fits with your version of ghc-mod."
19:47:58 <geekosaur> stack's not going to have custom code to deal with ghc-mod
19:48:00 <kadoban> Gurkenglas: M is what it's currently doing. G wouldn't make any sense, you'd be building a ghc-mod that then wouldn't work at all.
19:48:05 <geekosaur> stack's answer to ghc-mod is intero
19:48:33 <Gurkenglas> "Building ghc-mod with stack is hard. We recommend that you use intero instead."
19:48:35 <kakashiA1> kadoban: sorry, that is the correct error: https://paste.xinu.at/x0x/bash
19:48:44 <infinisil> Alright turns out the library had a callback for when the connection is closed, so I used that to write a TMVar and wait for that. cc amalloy
19:48:44 <geekosaur> (and everyone else's should probably be https://github.com/jyp/dante)
19:48:46 <kakashiA1> kadoban: same "wrong resolver" again?
19:48:53 <kadoban> kakashiA1: Yes.
19:49:09 <Gurkenglas> kakashiA1, it appears that you are expected to use intero instead of ghc-mod when you work with stack?
19:49:16 <kakashiA1> kadoban: okay, in this case I dont understand what "wrong resolver" means and how to solve it
19:50:06 <kakashiA1> Gurkenglas: my atom editor (with all the haskell magic) telling me that ghc-mod cant be found
19:51:23 <monochrom> Yes intero is much better if you use stack already.
19:51:25 <kadoban> kakashiA1: A resolver specifies what version of GHC and what versions of packages you're all using together. You have one set in ~/.stack/global-project/stack.yaml  ghc-mod does not work with that version of GHC, or a bunch of other stuff in that resolver. So if you want ghc-mod to work, you have to use a different resolver, and thus a different version of GHC.
19:53:56 <sqooq> Is it feasible to have a signal thorugh time happen value by value
19:54:17 <sqooq> as a side-question, can vectors be infinite?
19:55:59 <Gurkenglas> sqooq, https://hackage.haskell.org/package/reactive-banana-1.1.0.1/docs/Reactive-Banana-Combinators.html sounds related
19:56:29 <sqooq> kek
19:56:36 <sqooq> thanks but i'm already aware
19:56:47 <sqooq> it's not quite my question. I gave up on frp for now
19:57:16 <sqooq> I guess it would be nice to have a type that changes through time, but I guess that's just a value maybe wrapped?
19:57:28 <sqooq> sorry i suck at speaking
19:58:03 <Cale> sqooq: Well, could you clarify what you mean by "changes through time"? That sounds like an FRP Behaviour to me. But you might also just be looking for IORef?
19:58:21 <monochrom> When we say "static typing" it means no change through time (or anything during run time), so meh.
19:59:02 <monochrom> So you have to either go dynamic typing or call it a value.
19:59:25 <monochrom> or s/call/encode/
20:03:07 <sqooq> true
20:03:41 <sqooq> I guess what I should do is a weird discrete-time frp-esque thing
20:03:45 <sqooq> it won't be frp tho
20:04:19 <Gurkenglas> sqooq, Event from the linked page is the discrete-time frp-esque thing
20:06:10 <sqooq> Gurkenglas, nah that's not adequate, my discrete time goes time by time, in essence it's just a list
20:06:25 <sqooq> but I wanted to have things actually work step by step, rather than manipulating entire lists
20:06:36 <sqooq> that way I can have a nice form for delays and other buffer-like objects
20:07:13 <sqooq> if vectors could be infinite like lists, that would be nice but I don't think they can
20:07:38 <sqooq> i guess it doesn't even make sense to have an infinite vector
20:07:40 <Gurkenglas> "type Event a = [(Time,a)]" sure sounds like just a list
20:07:56 <sqooq> Gurkenglas, yes I'm just saying the Time's are redundant
20:08:18 <sqooq> because the list will *always* be [(0,_),(1,_),(3,_)]
20:08:23 <sqooq> kek Imissed "2"
20:08:25 <sqooq> you get the point
20:08:30 <sqooq> the times just go in increasing order
20:08:34 <Gurkenglas> Ah, you want a Behavior on a discrete time type
20:08:43 <sqooq> ye
20:09:00 <sqooq> but I need for the current value to be aware...I guess...
20:09:07 <sqooq> this is still kind of vague in my head
20:10:08 <sqooq> Yeah I guess it's just discrete time behaviors with a special buffer behavior :: Buf (t -> b) [b]
20:10:23 <sqooq> it's not frp though realy
20:14:37 <Gurkenglas> Haven't understood yet how it's not Behavior, can't you already have a recursively defined behavior that changes at each time step according to its previous value?
20:15:12 <sqooq> can you?
20:15:36 <sqooq> I think I'd still need a proper buffer
20:15:54 <sqooq> but for frequency modulation, what you just described might be useful
20:19:04 <alsoStevenXL> Hi everyone. Anyone here use Yesod? Where would you add a new data type so that it is available everywhere? In Foundation.hs?
20:23:53 <ezyang> straw poll: how do you debug print data structures in Haskell? Show? groom? A custom pretty-print typeclass? Something else?
20:24:23 <glguy> Either a custom typeclass or just a function that pretty-prints that particular type
20:24:27 <fraktor> Is there a function that is the opposite of bool, i.e. a -> a -> a -> Bool?
20:24:44 <Axman6> :t bool
20:24:45 <lambdabot> a -> a -> Bool -> a
20:25:00 <Axman6> I don't see how that type could do anything useful
20:25:03 <glguy> fraktor: What would you imagine that that would do?
20:25:18 <Axman6> it can literally only return True or False, without inspecting any of its arguments
20:25:38 <Axman6> @djinn  a -> a -> a -> Bool
20:25:38 <lambdabot> f _ _ _ = False
20:25:45 <fraktor> Nevermind.
20:25:56 <fraktor> I realized that what I'm looking for can be accomplished with ==...
20:26:11 <mniip> what you're looking for, but not what you said
20:26:23 <mniip> there's a big difference
20:26:46 <mniip> between a -> a -> Bool and Eq a => a -> a -> Bool
20:28:18 <Gurkenglas> fraktor, I advise you to cut out the middleman and use something like "case status of OnBoard -> whatyouwouldhavewritteninthen; InHand -> whatyouwouldhavewritteninelse"
20:28:56 <Gurkenglas> fraktor, you may even be able to cut even further and put whatyouwouldhavewritteninthen whereever you produce OnBoard, if that doesn't duplicate code
20:36:47 <ezyang> omg I asked this straw poll on twitter and I'm already at 91% 'Show'
20:36:56 <ezyang> am I the only person who loathes Show's output
20:37:09 <glguy> That's embarrassing for the Twitter community
20:37:19 <glguy> OHH
20:37:20 <glguy> wait
20:37:37 <glguy> I just misunderstood the question :)
20:37:49 <glguy> I thought you wanted to know how you pretty-printed your data structures
20:38:07 <ezyang> oh, did I misstate the question?
20:38:21 <ezyang> I wrote https://twitter.com/ezyang/status/948772693637246976
20:38:27 <ezyang> "How do you debug print data structures in Haskell?"
20:38:37 <sqooq> Gurkenglas, can you give an example of the recursive thing you were talking about. Let's say I want to add 1 behavior to the result of the last sum
20:38:49 <glguy> I didn't see the original. I use pretty-show when I have more than a line of Show output
20:39:06 <sqooq> imperatively something like sum = b1+sum, for every time valu
20:40:58 <d34df00d> Can I haz a type associated with a data record instance?
20:42:03 <ezyang> sort of, with an existential
20:42:14 <ezyang> you know what, scratch sort of.
20:42:17 <d34df00d> What I want is something like `data Foo a = Foo { makeFoo :: forall m. CoolMonad m => m a; consumeFoo :: a -> Smth }, but without exposing `a` in the type. In other words, I want to express that a function in my record can produce items of some type a, and another function knows how to consume them.
20:42:46 <ezyang> yes you want an existential type
20:43:03 <d34df00d> How do I link two different parts of the record together to express that `a` is the same?
20:43:07 <ezyang> oh, maybe records don't support it
20:43:43 <ezyang> ok yes, it is true you cannot use record selectors with existentially quantified data types
20:43:44 <mniip> they do
20:43:47 <mniip> it's awkward
20:44:06 <mniip> lemme look up the exact syntax
20:44:09 <mniip> (it's awkward)
20:46:20 <mniip> % data Foo where Foo :: { prod :: a, cons :: a -> String } -> Foo
20:46:20 <yahb> mniip:
20:46:32 <d34df00d> GADTs that is
20:46:37 <mniip> yeah
20:46:48 <mniip> curiously it's not supported by hint, so no lambdabot
20:46:48 <glguy> Or just: data Foo = forall a. Foo { prod :: a, cons :: a -> String }
20:46:49 <d34df00d> Right, thanks, I'll try throwing something reasonable up with it.
20:47:28 <d34df00d> Hmm.
20:47:52 <d34df00d> I like this latter approach since I have lots of fields and I won't have to decompose into GADT and non-GADT parts :)
20:48:11 <mniip> non-GADT parts?
20:48:17 <mniip> all non-GADTs are GADTs
20:48:26 <mniip> it's called a generalization for a reason
20:48:52 <d34df00d> Hold on.
20:48:59 <d34df00d> I realized I'm unfamiliar with this syntax you gave.
20:49:20 <d34df00d> What I know is ... where Foo :: a -> (a -> String) -> Foo
20:49:28 <glguy> I gave the sytnax using normal record declaration + ExistentialQuantification, mniip gave the one using the GADTs extension
20:49:33 <d34df00d> What's Foo :: { prod :: a, cons :: a -> String }
20:49:46 <glguy> That's the GADT record syntax
20:49:56 <d34df00d> Ah, I didn't know there is GADT record syntax.
20:50:15 <d34df00d> That is, the "record" part.
20:50:18 <kakashiA1> and editors/ides what you can recommend (easy to play with)
20:50:52 * d34df00d uses vim + ale for online syntax/semantics checking with hdevtools, hlint and ghc-mod.
20:50:58 <d34df00d> Not sure if that qualifies as "easy".
20:51:24 <mniip> vim and uh ghci
20:51:26 <mniip> sometimes ghc
20:52:08 <d34df00d> mniip: try ale, it's really awesome. I find myself almost never switching to ghci, all the errors and warnings are immediately visible.
20:52:18 <d34df00d> https://github.com/w0rp/ale
20:52:43 <d34df00d> mniip: and thanks for letting me know about gadt record syntax :)
20:53:21 <mniip> sadly I find that any editor integration breaks after enough weird trickery
20:53:23 <kakashiA1> mniip: is there a shorcut that let you execute your code right away? (I mean that passes your code to the ghci)
20:53:29 <mniip> I mean I break ghci on a regular basis
20:53:41 <mniip> kakashiA1, win-j :r
20:54:12 <mniip> or maybe :!ghci %
20:54:17 <d34df00d> Yay the impossible happened!
20:54:20 <mniip> which is usually :!<up>
20:55:05 <mniip> hmm
20:55:17 <mniip> are rtti reconstructed types still broken
20:56:42 <mniip> yup
20:57:45 <mniip> or maybe not
20:57:58 <mniip> it's as if all tyvars are skolem
20:58:02 <mniip> which might be expected
20:59:51 <srk> d34df00d: ale looks awesome!
21:01:25 <mniip> ah no
21:01:25 <mniip> broken
21:01:35 <mniip> % :print iterate
21:01:36 <yahb> mniip: iterate = (_t1::(a -> a) -> a -> [a])
21:01:39 <mniip> % :print id
21:01:39 <yahb> mniip: id = (_t2::a1 -> a1)
21:01:45 <d34df00d> srk: yeah, it's really nice!
21:01:49 <mniip> % :t _t1 _t2
21:01:49 <yahb> mniip: ; <interactive>:1:5: error:ghc: panic! (the 'impossible' happened); (GHC version 8.5.20171225 for x86_64-unknown-linux):; No skolem info:; [a_ajM0]; Call stack:; CallStack (from HasCallStack):; callStackDoc, called at compiler/utils/Outputable.hs:1150:37 in ghc:Outputable; pprPanic, called at compiler/typecheck/TcErrors.hs:2892:5 in ghc:TcErrors; Please report this as a GHC bu
21:04:03 <d34df00d> glguy: so let's say I went with your syntax and now I'm trying to update a record of type Foo using the record update syntax, doing smth like `foo { prod = (), cons = const "sup" }`.
21:04:20 <d34df00d> What I get is "Record update for insufficiently polymorphic fields: ...".
21:04:32 <glguy> Do you get a different outcome with the other syntax?
21:04:43 <d34df00d> Nope, haven't tried that one yet.
21:04:50 <d34df00d> Would you suggest trying that one?
21:04:50 <glguy> I don't expect it to be different
21:04:57 <d34df00d> Right, I take that as "no".
21:05:44 <d34df00d> So, two questions: 1. Why creating the record is any different from updating it? I'd expect either both to work or both to fail. 2. Is it possible to update a record in such a manner?
21:06:33 <mniip> updating a record doesn't change the type
21:06:58 <bphobia> hello
21:07:04 <glguy> mniip: It can
21:07:14 <d34df00d> mniip: the type of what exactly in this case?
21:07:23 <glguy> I don't really know how that interacts with ExistentialQuantification, however
21:07:47 <glguy> It doesn't look like GHC is cool with you using record update syntax on fields with that mention existentially quantified type variables
21:07:49 <mniip> > :t \x y -> x { runIdentity = y }
21:07:51 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
21:07:56 <mniip> :t \x y -> x { runIdentity = y }
21:07:57 <lambdabot> Identity a1 -> a2 -> Identity a2
21:08:03 <mniip> okay I did not know that
21:08:23 <d34df00d> glguy: can I somehow persuade ghc that it's OK?
21:08:51 <glguy> It would probably involve submitting a patch to GHC
21:09:41 <mniip> are newtype GADTs a thing?
21:09:44 <bphobia> if anyone mind helping find some great books about haskell, i started learning haskell and using ghc, but it had no information for beginners.
21:09:54 <mniip> if equational constraints have a void representation then it should work?
21:10:00 <mrkgnao> does anyone know what # means in this paper? disjointness? e.g. dom(A) # fuv(B)
21:10:02 <mrkgnao> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf
21:10:47 <d34df00d> Why do I always stumble upon some type-level issues, I just wanted to build a site with Hakyll...
21:11:03 <mrkgnao> @where haskellbook
21:11:03 <lambdabot> http://haskellbook.com
21:11:09 <mrkgnao> bphobia: ^
21:11:24 <nshepperd> mniip: how are you going to refine a type without any runtime information?
21:11:25 <bphobia> thank you very much
21:11:27 <glguy> bphobia: Hutton's Programming in Haskell is good
21:11:49 <AdituV> @d34
21:11:49 <lambdabot> Error: expected a Haskell expression or declaration
21:12:02 <AdituV> oops, ignore that :P
21:12:19 <bphobia> okay i'll try it out, thank you
21:12:31 <glguy> bphobia: Just be sure to get the recently updated 2nd ed
21:12:42 <glguy> It's both more up to date and also cheaper now
21:13:02 <mniip> d34df00d, just update it in full :D
21:13:07 <AdituV> ^
21:13:16 <mniip> I mean,
21:13:19 <mniip> templatehaskell!
21:13:20 <mniip> lenses!
21:13:37 <mniip> you could make a cool type-changing lens
21:13:44 <d34df00d> At this point that's probably an overkill :]
21:13:59 <d34df00d> I'll just refactor that stuff out into a subrecord that I'll create from scratch.
21:14:10 <d34df00d> And update the parent record's field pointing to that subrecord.
21:14:52 <AdituV> any reason why you can't just have a type parameter?
21:15:08 <nshepperd> mniip: I don't think they really have a void representation, you need to be able to distinguish between Refl and ⊥. But with data GADTs you can unpack that into the constructor
21:15:12 <AdituV> `data Foo a = Foo { prod :: a, cons :: a -> String }`
21:15:22 <d34df00d> AdituV: that's something like an implementation detail, so I don't want it exposed.
21:15:26 <nshepperd> so effectively taking zero additional space
21:15:31 <glguy> d34df00d: You could do:
21:15:42 <mniip> the constructor can be strict in the constraint
21:15:49 <glguy> data Some f = forall a. Some (f a)
21:15:59 <glguy> and then not use existential quantification with your record
21:16:17 <glguy> but use (Some Foo) where you need to hide the type parameter
21:16:19 <mniip> yeah but he has multiple fields united by an existential
21:16:31 <glguy> that's fine
21:16:32 <AdituV> or have the parametric version as an implementation detail, and expose a type synonym with e.g. `type Foo = FooImpl Int`?
21:16:39 <nshepperd> a newtype doesn't have a constructor that can hold that information
21:17:27 <d34df00d> glguy: I think of `data Foo = Foo { lots :: Lots, of :: Of, fields :: Fields, polyPart :: Poly }`, and then `data Poly = forall a. Poly { ... }`.
21:17:28 <nshepperd> unsafeCoerce = case undefined of NewtypeConstructor _ -> { id :: a -> b }
21:17:36 <d34df00d> Poly's thin, so I can afford to recreate it from scratch.
21:17:44 <d34df00d> Effectively just updating the polyPart.
21:18:26 <d34df00d> AdituV: different "objects" might have different type as their implementation detail, so fixing it won't work.
21:18:32 <d34df00d> But I'm probably overdesigning.
21:18:33 <glguy> I don't care either way, but factoring that aspect out will just make things more flexible
21:18:38 <d34df00d> But at this point it doesn't matter.
21:18:42 <mniip> % foo = setting (\f (Foo _ _) -> (Foo (fst (f ())) (snd (f ()))))
21:18:43 <yahb> mniip:
21:18:46 <mniip> % :t set foo
21:18:47 <yahb> mniip: (a, a -> String) -> Foo -> Foo
21:19:09 <glguy> \(Some foo) -> Some foo { prod = (), cons = const "" }
21:20:09 <mniip> nshepperd, hmmm
21:21:15 <nshepperd> I spose you could make your 'newtype GADT' so that pattern matching on a value would evaluate that value to whnf first
21:21:26 <nshepperd> pseq basically
21:21:54 <mniip> @let data Some f = forall a. Some (f a)
21:21:55 <lambdabot>  Defined.
21:23:12 <mniip> @let _Some = setting (\f s -> Some (f s))
21:23:13 <lambdabot>  Defined.
21:24:04 <nshepperd> pretend that the underlying value is carrying the equational constraint witness
21:24:46 * hackage madlang 4.0.0.0 - Randomized templating language DSL  https://hackage.haskell.org/package/madlang-4.0.0.0 (vmchale)
21:25:36 <mniip> ah no such a lens isn't as useful as you'd think
21:25:41 <mniip> type variables escaping scopes
21:25:50 <mniip> s/lens/setter/
22:02:15 * hackage rapid-term 0.1.2.1 - External terminal support for rapid  https://hackage.haskell.org/package/rapid-term-0.1.2.1 (esz)
22:33:49 <whiteline> what do people think about https://www.fpcomplete.com/blog/2017/07/announcing-new-unliftio-library
22:38:10 <osa1> I like it but couldn't find the chance to port my code base to it yet. I like it because (1) no wonky instances like `MonadTransControl StateT` (2) I can finally ditch `MonadBase IO m` constraints and just use `MonadIO m`
22:40:20 <osa1> also, a single package that covers most of my use case is better than using `monad-control`, `lifted-base`, `lifted-async` etc.
23:01:46 * hackage fast-arithmetic 0.1.0.0 - Fast number-theoretic functions.  https://hackage.haskell.org/package/fast-arithmetic-0.1.0.0 (vmchale)
23:22:48 <osa1> anyone know where to look for ghcjs module docs? more specifically I'm looking for GHCJS.Foreign.Callback
23:42:50 <dminuoso> Is there a reason to use mapM over traverse?
23:42:55 <dminuoso> :t mapM
23:42:56 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
23:42:56 <dminuoso> :t traverse
23:42:58 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
23:42:58 <amalloy> dminuoso: no
23:43:11 <amalloy> mapM has been around longer, is the only reason it exists
23:43:24 <dminuoso> amalloy: Ah so its kind of like `fmap` or `liftM` ?
23:43:30 <amalloy> yes
23:43:33 <dminuoso> *map or liftm
23:43:34 <dminuoso> Alright, thanks.
23:45:04 <dminuoso> amalloy: Is the reason for mapM's existence related to the fact that it has a Monad constraint from before Applicative was a superclass of Monad?
23:45:51 <dfeuer> edwardk: ping
23:45:54 <amalloy> i'm not really an expert on that history
23:46:18 <amalloy> i think there was a time when Applicative didn't exist at all, much less being a superclass of Monad, but i'm not sure
23:46:31 <edwardk> pong
23:46:47 <dfeuer> edwardk: why do you want to take sums and products of Sets?
23:46:56 <dfeuer> I still don't understand that.
23:47:05 <dfeuer> Why not represent the sum/product as a pair of sets?
23:47:44 <edwardk> https://github.com/ekmett/coda/blob/master/lib/coda-automata/Coda/Automata/NFA.hs#L68 and https://github.com/ekmett/coda/blob/master/lib/coda-automata/Coda/Automata/NFA.hs#L62
23:47:57 <amalloy> dminuoso: https://stackoverflow.com/a/6566145/625403 seems to confirm my memory that Applicative is newer
23:48:10 <edwardk> https://github.com/ekmett/coda/blob/master/lib/coda-automata/Coda/Automata/Internal.hs#L14 is the basic NFA type i used
23:48:46 <edwardk> NFA ss is fs d -- ss is the set of states, is is the set of initial states, fs is the set of accepting states, 'd' is the NFA transition function
23:49:04 <edwardk> computing intersections and unions requires me to be able to build sums and products of sets
23:49:09 <edwardk> concatenation also requires sums
23:49:36 <dfeuer> edwardk: my browser is still booting up. But why would the NFA type always need the same representation of sets?
23:50:53 <dfeuer> My goddamn browser is barking at me.
23:51:14 <dfeuer> Whew; snipped it.
23:51:20 <edwardk> in the version i'm switching to i'm using BDDs and not Data.Set, but the current version uses a lazy variant of the code from Data.Set
23:51:28 <edwardk> to make those operations faster
23:51:32 <dfeuer> I dunno what a BDD is.
23:52:10 <edwardk> https://en.wikipedia.org/wiki/Binary_decision_diagram#Variable_ordering
23:52:42 <edwardk> fancy way to represent boolean formulas/circuits
23:53:06 <edwardk> anyways, yes, i could replace the use of sets there with something completely one off and several combinators for how to glue them together
23:53:28 <dfeuer> But you want something for quick and dirty?
23:53:31 <edwardk> but then i'd need to know all the things i want to do with my NFA internals, and frankly, a set of states is the canonical model ;)
23:53:41 <edwardk> so i figured a Set was a good starting point =P
23:53:44 <dfeuer> *nod*
23:54:04 <dfeuer> I'm not *opposed* to adding those operations, but they'll definitely need proper names.
23:54:16 <edwardk> like i said, don't care at all about the names
23:54:19 <edwardk> just want the operations
23:54:31 <dfeuer> As you know, naming is the hardest part!
23:54:35 <edwardk> it actually surprised me that they were missing
23:55:28 <dfeuer> Hrmmmmm....
23:55:33 <edwardk> as far as i'm concerned they can be 'cartesianProduct' and 'disjointUnion'
23:55:49 <edwardk> as that is exactly what they are?
23:55:53 <dfeuer> Those are ... pretty good names, actually.
23:56:28 <dfeuer> In fact, they're probably good enough not to bother with the whole proposal process....
23:56:38 <edwardk> easy enough
23:57:04 <dfeuer> All right, I'll make it happen.
23:57:32 <edwardk> my current goal is to get an efficient enough BDD implementation that i can swap out the sets in that code, but i figured it was worth passing back to Data.Set the lessons learned while using it
23:57:42 <dfeuer> *nod*
23:58:00 <dfeuer> BTW, that Wikipedia diagram you linked to was not very meaningful to me....
23:58:33 <dfeuer> I'd have to try reading the actual article.
23:58:42 <edwardk> https://github.com/ekmett/coda/blob/master/lib/bdd/Data/BDD.hs is an implementation of them
23:58:49 <dfeuer> *nod*
23:59:19 <dfeuer> What is coda?
23:59:20 <edwardk> the idea of a BDD is pretty straightforward, you have a boolean function of several variables. so you represent them using nodes that provide 'if then else' branching off of the variables.
