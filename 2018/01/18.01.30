00:00:36 <phadej> you have to pass it *with* corresponding MapOps, otherwise how'd you use it?
00:01:04 <ski> in the OO-usage of existentials, you'd pass around operations bundled with the state (existentially quantified). so if you get two such bundles, you don't know that you have the same state/representation type
00:01:30 <ski> phadej : you open `MapOps k' *once*, then work in the context of the operations therein
00:01:46 <phadej> ski: so you have to open it at very top-level... bummer
00:01:55 <ski> this is the (Abstract Data Type) ADT-usage of existentials
00:01:57 <ski> yep
00:02:24 <ski> TaPL mentions this, i think
00:04:05 <phadej> I hope we agree that it isn't very practical
00:05:13 <phadej> it's like "poor's man backpack" without the benefits.
00:05:17 <ski> it's a bit awkward, yes
00:08:45 <ertes-w> helo
00:09:30 <ski>     ehlo
00:10:38 <phadej>  ehol
00:14:58 <ertes-w> where does OO begin?  if you stretch "OO" wide enough, FRP might become a form of OO
00:16:54 <ski> in this case, we're considering the equivalence between `nu s. f s' and `exists s. s * (s -> f s)', for a functor `f'
00:18:41 <ertes-w> what's nu?
00:19:14 <ski> greatest fixpoint
00:19:43 <ertes-w> ah
00:20:07 <ertes-w> what's the connection to OO?
00:20:09 <ski> (similarly, `mu r. f r' is equivalent to `forall r. (f r -> r) -> r')
00:22:09 <ski> well, consider `data ASP a b = forall s. MkASP { put :: s -> a -> s ; get :: s -> (a,s) }' (asynchronous stream processor)
00:22:40 <ski> well, actually that should be `data ASP a b = forall s. MkASP { state :: s ; put :: s -> a -> s ; get :: s -> (a,s) }'
00:22:53 <ertes-w> what's the purpose of 'b'?
00:23:10 <ski> hrm, sorry typo, that should be `get :: s -> (b,s)'
00:23:18 <ski>   putASP :: ASP a b -> a -> ASP a b
00:23:47 <ski>   putASP (MkASP s put get) a = MkASP (put s a) put get
00:24:00 <ski>   getASP :: ASP a b -> (b,ASP a b)
00:24:27 <ski>   getASP (MkASP s0 put get) = (b,MkASP s1 put get)
00:24:28 <ski>     where
00:24:41 <ski>     (b,s1) = get s0
00:25:12 <ski> so, here we rewrap the state with the methods, for each operation that updates the state (iow generates a new version of the object)
00:26:03 <ertes-w> (so far so good)
00:26:29 <ski> (the ADT-usage mode of existentials would not rewrap like this. also it wouldn't store a current state, but rather provide a way to get an initial state. but this above is the OO-usage mode of existentials)
00:27:01 <ski> anyway, instead of the above implementation, we can use the following equivalent one
00:27:45 <ski>   data ASP a b = MkASP { putASP :: a -> ASP a b ; getASP :: (b,ASP a b) }
00:29:00 <ski> iow, we partially apply every method to the state, and also recursively convert any state(s) in result types to the same record of partially-applied methods
00:30:08 <ski> (this obviously requires that all methods take exactly one state input. and that any state outputs occur covariantly in the return types)
00:31:52 <ski> the functor `f' here corresponds to the mapping from a type `s' to `(a -> s) * (a,s)', which is covariant in `s'
00:32:25 <ski> (hrm, s/(a,s)/(b,s)/)
00:32:32 <ski> `s -> (a -> s) * (b,s)' is `(s -> a -> s) * (s -> (b,s))'
00:35:08 <ski> @type ana
00:35:10 <lambdabot> Functor f => (s -> f s) -> s -> Nu f
00:35:21 <ski> @type uncurry (flip ana)
00:35:23 <lambdabot> Functor f => (s, s -> f s) -> Nu f
00:35:46 <ski>   uncurry (flip ana) :: Functor f => (exists s. (s,s -> f s)) -> Nu f
00:35:51 <ski> converts in one direction
00:37:01 <ski> the other direction would be `\n -> (n,unNu)', where `unNu :: Nu f -> f (Nu f)' is the deconstructor
00:38:19 <ski> "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf> talks about this "closure", existential-free, version of OO
00:39:13 <ski> (that in turn is a sortof follow-up to "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>)
00:39:37 <ski> (and, as i said, TaPL also mentions the above two modes of usage of existentials)
00:39:40 <ski> @where TaPL
00:39:40 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
00:43:47 <ertes-w> ski: still not quite sure what this has to do with OO…  you mean this pattern of state is considered OO?
00:45:17 <ski> it's considered one view of OO
00:46:51 <ski> one can easily explain dynamic dispatch and the heterogenous-list of widgets, using this
00:47:41 <ski> (fwiw, such an existential formulation can be useful for fusion, i think)
01:09:51 <ertes-w> ok
01:19:00 <Myrl-saki> Does it make sense to say that init is O(1) amortized?
01:21:35 <ertes-w> Myrl-saki: in a lazy language you have to ask about the run-time of queries, because non-strict functions don't have an inherent run-time
01:22:15 <Myrl-saki> ertes-w: "Runtime of queries"?
01:22:26 <ertes-w> if (head xs) is O(1), then (head (init xs)) is also O(1)
01:22:39 <Myrl-saki> ertes-w: Ah.
01:22:43 <Myrl-saki> ertes-w: Thanks.
01:28:35 <Myrl-saki> ertes-w: Just for the sake of completion, is `until ((== []) . tail) init` O(n) or O(n^2)?
01:29:35 <ertes-w> if (last xs) is O(n), then last (init (xs)) is O(n)
01:30:32 <ertes-w> wow, that was terrible
01:30:34 <Myrl-saki> ertes-w: Right, but isn't this more of `init ... init $ (xs)`
01:30:37 <ertes-w> if (last xs) is O(n), then (last (init xs)) is O(n)
01:30:41 <ertes-w> there we go =)
01:30:56 <ertes-w> > last [1..10]
01:31:00 <lambdabot>  10
01:31:01 <ertes-w> > last (init [1..10])
01:31:04 <lambdabot>  9
01:31:32 <ertes-w> each 'init' adds a constant factor
01:31:57 <Myrl-saki> until ((== []) . tail) init $ [1..1000000]
01:32:04 <Myrl-saki> Doesn't complete in 5 seconds for me.
01:32:10 <ertes-w> and constants vanish in big-O…  if you want to talk about the performance of repeated applications of 'init', you have to abstract over the number of applications
01:32:50 <ertes-w> oh, sorry…  i misread your expression
01:32:58 <ertes-w> yeah, that one will be O(n²)
01:33:02 <Myrl-saki> ertes-w: It's fine. :P It's not something you'd see in real code anyway.
01:33:14 <quchen> Time is measured in seconds, not Landau symbols.
01:33:25 <AWizzArd> Can GHC output a single binary which can be used with zero dependencies in a Docker image? That is, the Dockerfile would specify that we start it "FROM scratch" and only add the binary, resulting from GHC's compilation.
01:33:40 <quchen> My height grows like O(age) but that won’t tell you how tall I am.
01:33:42 <AWizzArd> Or: are there always some dependencies that can’t be compiled into the binary itself?
01:34:20 <merijn> AWizzArd: That's the default behaviour (modulo C dependencies)
01:34:33 <phadej> AWizzArd: yes, you can do static binaries, but that's difficult. Default of having libc6, zlib etc. dynamically linked is easier
01:35:01 <merijn> AWizzArd: GHC by default statically links all Haskell libs and dependencies, only dynamic linking C libraries. You could also statically link those C libraries, but it's a bit of a hassle
01:35:21 <phadej> (especially if you want statically link libc)
01:35:27 <ertes-w> AWizzArd: are you using nix or stack?
01:35:41 <Myrl-saki> ertes-w: I'm trying to process why this isn't O(n). I understand the underlying idea, but I feel like lazy evaluation "avoids" this.
01:36:12 <Myrl-saki> Emphasis on feel.
01:36:16 <ertes-w> Myrl-saki: it doesn't:  every 'init' adds a constant factor, because every uncons needs to process every 'init' that has been applied
01:36:43 <AWizzArd> ertes-w: stack here
01:37:06 <AWizzArd> I am just wondering what the most minimal Docker image would be from which I could start for a simple Hello-World GHC binary.
01:37:08 <ertes-w> Myrl-saki: head (init xs)  -- needs an extra step, because the 'init' might have exhausted the list
01:37:21 <ertes-w> Myrl-saki: head (init (init xs))  -- needs two extra steps
01:37:28 <phadej> AWizzArd: https://www.fpcomplete.com/blog/2015/05/haskell-web-server-in-5mb
01:37:36 <Myrl-saki> ertes-w: True.
01:38:10 <ertes-w> AWizzArd: stack can build docker images for you, as far as i know
01:38:13 <Myrl-saki> ertes-w: Thanks.
01:38:23 <phadej> I always forget that you need iconv data too
01:39:16 <AWizzArd> ertes-w: I am using stack to build my app in docker, and to run ghci inside it. But this is using a 7gb image under the hood, which contains already ghc 8.2 and tons of Haskell libs.
01:39:45 <AWizzArd> But I was thinking more of something for deployment. Something which can be started via `docker run` and being as minimal as possible.
01:40:45 <AWizzArd> This image does not need to include any Haskell lib, nor GHC. Obviously my binary should go inside, and probably some C libs too.
01:43:23 <ertes-w> AWizzArd: well, i build docker images using nix…  the resulting images are reasonably small, usually only a few MiB
01:44:00 <AWizzArd> ertes-w: this could be an option too, using nix I mean. I shall look into that.
01:44:35 <ertes-w> right now i can't explain how to do it, but i remember recording a crappy video of me dockerising a small scotty example
01:44:36 <AWizzArd> phadej: interesting article, thx. Seems the author went exactly through this.
01:44:46 <ertes-w> let me see if i can find it
01:45:20 <phadej> AWizzArd: also: https://docs.docker.com/engine/userguide/eng-image/multistage-build/
01:45:31 <ertes-w> AWizzArd: https://www.youtube.com/watch?v=sR9p_aQncRo
01:45:33 <phadej> so you can do that with one Dockerfile nowadays
01:45:41 <ertes-w> holy crap, it seems like hundreds of people have watched this shit =)
01:45:47 <AWizzArd> hr hr hr
01:46:08 <ertes-w> AWizzArd: one advantage of this approach, besides small images, is that you don't need to deal with those stupid dockerfiles or even having a docker daemon running
01:46:16 <ertes-w> which comes with the side effect that building the images is *fast*
01:47:07 <AWizzArd> ertes-w: I don’t mind writing Dockerfiles at all, and: this would be a verry short one. However: having guaranteed reproducibility via Nix is a plus.
01:48:10 <ertes-w> i hate writing those =)
01:48:32 <ertes-w> dockerfiles are the epitome of imperative programming
01:49:43 <phadej> our production dockerfile is "apt-get deps; copy binary"
01:55:07 <ertes-w> which means you have a whole apt-based OS in that container…  nix-based containers don't actually contain nix itself; in fact they don't even contain an OS, unless you give them one
01:55:45 <ertes-w> (personally i do, because sometimes it's useful to have a shell for debugging, and i generally run s6-svscan as the init process)
02:01:17 <AWizzArd> phadej: by using their small base image it would be more like "FROM fpco/haskell-scratch" and "COPY binary"
02:10:30 <merijn> ok, so is anyone aware of similar tools missing from the list of: ghc-mod, hdevtools, ghcid
02:12:58 <Uniaika> intero? merijn
02:13:21 <merijn> oh, right
02:13:34 <merijn> By I heard that leaks like crazy, so probably not that interesting
02:14:37 <raduom> Hi. Is there a style checker for Haskell available that could be setup as a git hook to validate a push?
02:15:44 <Boomerang> raduom: git-vogue
02:15:59 <Uniaika> raduom: I use stylish-haskell and hlint
02:16:52 <raduom> Uniaika: and just for my curiosity do you actually use a commit hook to check them or just have your IDE run them?
02:17:11 <Boomerang> git-vogue is a framework for pre-commit checks that uses stylish-haskell, hlint (and ghc-mod with older GHCs)
02:17:24 <tdammers> IMO blocking commits on hlint is too harsh
02:17:40 <tdammers> hlint makes suggestions, but sometimes not following them makes for better readability
02:17:41 <Uniaika> raduom: I use them from vim when I save the file on disk
02:17:46 <raduom> Boomerang: that sounds quite good. thanks.
02:18:47 <Boomerang> tdammers: You can change some of the hlint rules or disable them on a per module basis with ANN pragmas :-)
02:20:16 <kbeep> Hey, there, I'm a Haskell beginner, trying to work my way through 'Thinking Functionally'. Now at one point it describes the fact that every well-formed expression in Haskell is also well-typed. Is this by definition true, or are there exceptions?
02:21:17 <raduom> kbeep: isn't that true of all static typed languages?
02:21:53 <tdammers> kbeep: depends on your definition of "well-formed"
02:22:13 <tdammers> kbeep: from a purely syntactic point of view, finding counterexamples is trivial
02:22:20 <tdammers> > head 23
02:22:24 <lambdabot>  error:
02:22:24 <lambdabot>      • No instance for (Num [()]) arising from a use of ‘e_123’
02:22:24 <lambdabot>      • In the expression: e_123
02:23:19 <kbeep> Yes, you're hitting exactly the point that I am confused about, namely whether well-formed is meant to mean 'syntactically correct taking into account the types' or just 'syntactically plausible'
02:24:16 <tdammers> the only other definition that would make sense to me would be synonymous with well-typed
02:24:59 <jgt> How do I get the ordinal of a date when formatting a Day?
02:25:06 <ertes-w> merijn: haskell-mode has an embedded GHCi
02:25:11 <kbeep> I will go with that then, thanks for the quick response!
02:25:19 <merijn> ertes-w: That sounds like emacs, though :p
02:25:28 <ertes-w> merijn: it is emacs, yeah
02:25:47 <jgt> Doing this: `formatTime defaultTimeLocale "%B %-d, %Y" "2017-01-01"` gives me 'January 1, 2017'
02:25:58 <jgt> but I want 'January 1st, 2017'
02:26:29 <jgt> I'm not 100% sure the st/nd/rd/th part is called the "ordinal" either
02:26:59 <ertes-w> kbeep: consider that well-typedness is a property of expressions
02:27:23 <ertes-w> something like ")(" is not an expression, so the very question whether it's well-typed doesn't really make sense
02:28:44 <kbeep> Yes, so in this case everything that is legal within the expression language is well-typed - the (apparently redundant) distinction between the two terms threw me off a bit
02:29:09 <TMA> jgt: the whole 1st/2nd/3rd/4th/... is calles ordinal number 1/2/3/4/... is called cardinal number (at least in the field of linguistics); I am not sure that formatTime can do that, it looks way too similar to strftime, which cannot
02:30:31 <ertes-w> kbeep: it really depends on what they consider an "expression"…  there are ways to encode ASTs such that every AST is well-typed by definition (however, haskell isn't quite expressive enough to do that)
02:31:48 <jgt> TMA: Ah ok, thanks. Looks like I'll have to write this myself.
02:34:34 <merijn> Anyone here just fly-checking/whatever using GHC directly using environment files? If so, how did you set that up?
03:53:32 <Franciman> Hi, is there a way to make a thread sleep until a certain UTCTime date?
03:53:46 <merijn> Franciman: Not really
03:54:02 <Franciman> ok thanks
03:54:02 <merijn> Franciman: I'd recommend just calling threadDelay in a loop until the relevant UTCTime
03:54:20 <Franciman> Ok
03:54:43 <Franciman> actually I can try something else, in my case. Signal the thread that the time has expired
03:54:48 <Franciman> so I can wait on an MVar or something
03:55:58 <tdammers> mwahaha... set up a cron job that touches a file, and then use inotify to block on that
03:56:11 <Franciman> :O
03:56:31 <merijn> Franciman: Why would that be easier than looping threadDelay?
03:56:57 <Franciman> I thought it would be more efficient
03:57:20 <merijn> threadDelay is pretty efficient
03:57:22 <tdammers> it's more efficient, but not in a significant way
03:57:34 <Franciman> I have a thread refreshing a session and different threads using this session to do some downloads
03:57:35 <tdammers> depends on the precision you want though
03:57:40 <Franciman> the session contains cookies and auth stuff
03:57:40 <merijn> I'm not so confident claiming that the MVar is more efficient
03:57:43 <Franciman> that's my case
03:58:05 <Franciman> so I'm using a TVar containing the session and retry when it's not valid anymore
03:58:07 <tdammers> so you can afford, say, 10-second granularity, I assume?
03:58:32 <Franciman> yes
03:58:41 <Franciman> but, probably my design is flawed?
03:58:49 <tdammers> because if that is the case, checking a flag once every 10 seconds is completely negligible
03:58:57 <Franciman> Is it okay to design the application in such a way?
03:59:07 <Franciman> Have a shared Session among may downloaders
03:59:17 <Franciman> and the Session is refreshed by another thread
03:59:30 <Franciman> and the others access Session if it's valid or retry
03:59:43 <Franciman> among my*
04:00:13 <tdammers> idk, doesn't sound outrageous
04:02:04 <Franciman> ok thank you very much for the help, tdammers and merijn
04:14:01 <Dave_> hi, what's wrong with my concatMap?
04:14:08 <Dave_> rowToList :: String -> [String]
04:14:18 <Dave_> rowToList "" = replicate 5 ""
04:14:26 <Dave_> rowToList s = concatMap (\x -> if x == '.' then "foo" else [x]) s
04:14:59 <Dave_> I call it like: rowToList "test..."
04:16:04 <merijn> Dave_: What's the type error?
04:16:15 <merijn> oh, wait
04:16:16 <cocreature> :t concatMap
04:16:16 <merijn> duh
04:16:18 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
04:16:32 <cocreature> in your case t a = [Char] and b = Char, so the result is [Char]
04:16:35 <cocreature> but you need [[Char]]
04:16:36 <merijn> Dave_: The return type of concatMap in this case is String, not [String]
04:17:55 <Dave_> ok, I'm trying to get a list of strings
04:18:11 <Dave_> if it's empty string I return a list of 5 empty strings
04:18:11 <cocreature> maybe you’re looking for "map" instead of "concatMap"?
04:18:16 <cocreature> that would at least have the right type
04:20:10 <Dave_> if not empty string then apply a function on each char which changes the char
04:20:34 <Dave_> can I change the list with map too?
04:21:04 <cocreature> depends on what you mean by “change”. values in Haskell are immutable, neither "map" nor "concatMap" modify the original list
04:23:06 <Dave_> okay, my overall goal is to convert a string like this "1a2bc1" to a list like this ["", "a", "", "", "b", "c", ""] (digits represent count of empty strings)
04:23:36 <Dave_> (digit range from 1-9)
04:23:53 <ski> oh
04:24:10 <ski> then `concatMap' would seem to be more appropriate
04:24:12 <muzzle> could anyone tell me what hosts stack typically pulls packages/ghc etc. from?
04:24:16 <muzzle> it's not in the docs
04:24:24 <muzzle> and I need it for my company's firewall config
04:24:52 <ski>   concatMap f [a,b,c,d]  =  f a ++ f b ++ f c ++ f d
04:25:07 <ski> you need to figure out what `f' should be in your case
04:25:40 <ski> e.g. what should `f' result in, when passed a non-digit ?
04:25:47 <ski> when passed a digit ?
04:26:23 <ski> (also, what should happen if a zero digit is encountered ? should it be skipped, or copied over ?)
04:30:05 <muzzle> is there a place where I can find this documented that I didn't see?
04:30:15 <Dave_> okay, maybe I don't need a list of strings but a list of chars? would be "  a c" a list [' ', ' ', 'a', ' ', 'c'] or ['a', 'c']?
04:32:33 <Taneb> Dave_: the first one
04:32:49 <Taneb> > map show "  a c"
04:32:52 <lambdabot>  ["' '","' '","'a'","' '","'c'"]
04:33:51 <Taneb> Oh, nevermind, I don't think that that was what you were asking
04:35:28 <Dave_> ok, there are no empty chars, so I then I actually need to replace the digit with its count of spaces
04:36:32 <Dave_> "1e2a" -> [' ', 'e', ' ', ' ', 'a']
04:37:56 <Dave_> then I just need map right?
04:38:11 <Dave_> since I apply a function to each char right?
04:38:42 <cocreature> no, you need concatMap. one digit can map to multiple spaces
04:39:52 <ski> well, before you were talking about expanding digits to multiple empty strings
04:40:07 <ski> now you're talking about multiple space characters
04:40:24 <ski> either way, `concatMap', rather than `map', would be appropriate
04:44:23 <Dave_> sry, expanding string digits to space chars is the one I'm trying
04:48:10 <Dave_> I'm confusing myself ^^
04:50:59 <ertes-w> Dave_: first specify the type of your function correctly…  so String -> String is indeed correct?
04:52:38 <ertes-w> Dave_: according to what you're saying, your original function was a good template, it just had the wrong type
04:52:55 <ertes-w> > concatMap (\x -> if x == '.' then "foo" else [x]) "test..."
04:52:58 <lambdabot>  "testfoofoofoo"
04:53:11 <ertes-w> *wrong type signature
04:53:50 <Dave_> omg after hours and hours I finally made some progress (sry, I'm a total newbie to haskell)
04:54:02 <Dave_> rowToList :: [Char] -> [Char]
04:54:11 <Dave_> rowToList "" = replicate 10 ' '
04:54:25 <Dave_> rowToList s = concatMap (\x -> if isDigit x then (replicate 2 ' ') else [x]) s
04:54:51 <Dave_> now I just need to convert that char digit to it's integer and replace that 2 with it
04:58:07 <Dave_> > ord '\49'
04:58:11 <lambdabot>  49
04:59:56 <Dave_> > :t ord
05:00:00 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
05:01:49 <Dave_> oh there's digitToInt in Data.Char
05:03:22 <Dave_> my solution: rowToList s = concatMap (\x -> if isDigit x then (replicate (digitToInt x) ' ') else [x]) s
05:03:37 <Dave_> is there any way to write it "nicer"/better?
05:04:59 <cocreature> looks pretty good. the parenthesis around "replicate …" are redundant but apart from that I wouldn’t change anything
05:05:53 <ertes-w> Dave_: there is one nicer way to write it:  digit :: Char -> Maybe Int
05:06:13 <ertes-w> Dave_: you would have to write this function, but using it you can avoid an issue that is known as boolean blindness
05:07:08 <Dave_> okay thanks changed that :)
05:07:40 <ertes-w> Dave_: a very common manifestation of that issue is this particular pattern:  if p then unsafeExpression else …
05:07:54 <ertes-w> unsafeExpression is unsafe, but it's safe given p
05:09:10 <ertes-w> @let showHead xs = if not (null xs) then "head: " ++ show (head xs) else "empty list"
05:09:12 <lambdabot>  Defined.
05:09:16 <ertes-w> > showHead [1,2,3]
05:09:19 <lambdabot>  "head: 1"
05:09:22 <ertes-w> > showHead []
05:09:26 <lambdabot>  "empty list"
05:09:40 <Dave_> currently I print that string with print but is there a way to print it as list of chars?
05:10:07 <ertes-w> alright, i'll stop
05:10:41 <electrocat> hey is megaparsec considered to be totally superior to parsec, i'm considering of switching my codebase to it
05:11:46 <dstolfa> > showHead []
05:11:50 <lambdabot>  "empty list"
05:12:11 <merijn> electrocat: I'd say so
05:12:13 <dstolfa> > x <- createProcess (proc "echo foo" [])
05:12:17 <lambdabot>  <no location info>: error:
05:12:17 <lambdabot>      not an expression: ‘x <- createProcess (proc "echo foo" [])’
05:12:24 <merijn> electrocat: Parsec is not seeing any active development anymore
05:12:40 <merijn> electrocat: megaparsec started as a 1-to-1 fork of parsec and then got updated to the modern age
05:13:31 <merijn> electrocat: Parsec, for example, exports a bunch of symbols conflicting with, e.g., Alternative (such as <|>, many, some, etc.) which couldn't be replaced because the Alternative versions have slightly different precedence
05:13:33 <dstolfa> > createProcess (proc "ls" [])
05:13:37 <lambdabot>  error:
05:13:37 <lambdabot>      Variable not in scope: createProcess :: t0 -> terror:
05:13:37 <lambdabot>      Variable not in scope: proc :: [Char] -> [a0] -> t0
05:13:39 <dstolfa> :(
05:13:50 <merijn> dstolfa: lambdabot doesn't run IO for obvious reasons :)
05:14:02 <ski> @help run
05:14:02 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
05:14:04 <dstolfa> merijn: well, yeah. i was hoping for a configuration error
05:14:07 <merijn> dstolfa: It's fairly bulletproof, considering the amount of people who've tried like you ;)
05:14:11 <tdammers> if that worked, it wouldn't work anymore
05:14:31 <merijn> Well, there's the other haskell bot that allows IO but runs in a sandbox
05:14:35 <dstolfa> merijn: it's enough that the version of lambdabot running on there accidentally has import System.Process
05:14:35 <merijn> yahb or something?
05:14:39 <quchen> Lambdabot does not know the types of unsafe functions for unobvious reasons :-(
05:14:41 <quchen> :t unsafeCoerce
05:14:43 <lambdabot> error: Variable not in scope: unsafeCoerce
05:15:08 <merijn> dstolfa: Not really, as lambdabot also uses SafeHaskell to restrict what can be executed, iirc
05:15:09 <ertes-w> if you measure the time an expression needs to evaluate, you could launch a spectre attack =P
05:15:12 <dstolfa> merijn: running without IO is safer than running in a sandbox, given that most sandboxes are absolutely horrible at the moment
05:15:17 <dstolfa> merijn: ah, even better then
05:15:31 <merijn> dstolfa: Because you can actually add new imports to lambdabot
05:15:41 <merijn> iirc
05:15:47 <dstolfa> merijn: so it just filters out all the IO ones?
05:15:51 <electrocat> merijn: ok tnx, decent identation support would also be nice :p
05:16:07 <merijn> electrocat: Should be fairly trivial to migrate to megaparsec
05:16:30 <dstolfa> merijn: i wonder what level it works on
05:16:50 <dstolfa> i'd imagine it does so much lower than haskell itself (i.e. the protections are not a part of lambdabot, but a part of SafeHaskell)
05:16:55 <merijn> dstolfa: You can just look up the code :)
05:17:01 <dstolfa> merijn: i know, but i'm too lazy atm
05:17:07 * dstolfa shakes his head in shame
05:18:52 <ertes-w> dstolfa: it doesn't exactly "filter" them, it's just that there is no Show instance for IO actions
05:19:09 <phadej> > return () :: IO ()
05:19:12 <lambdabot>  <IO ()>
05:19:18 <phadej> ther is in lambdabot
05:19:34 <phadej> if argument is `Typeable` iirc
05:19:55 <phadej> > return undefined :: IO a
05:19:58 <lambdabot>  error:
05:19:58 <lambdabot>      • No instance for (Typeable a0)
05:19:58 <lambdabot>          arising from a use of ‘show_M305951446182738017823806’
05:20:03 <ertes-w> lambdabot really just 'show's the given value
05:22:13 <ertes-w> @query lambdabot
05:22:13 <lambdabot> Unknown command, try @list
05:24:10 <dstolfa> ertes-w: could you not implement your own IO monad with a different name and do instance Show MyIO where show = showMyIO?
05:24:25 <dstolfa> granted, you'd have to implement half of the stdlib for it to work
05:24:29 <merijn> dstolfa: Yeah, but that doesn't mean you can run the underlying IO :)
05:25:29 <dstolfa> merijn: yeah that's what i'm asking -- is this a restriction on the runtime level
05:25:48 <ertes-w> dstolfa: this is not really a security feature of lambdabot, but an inherent feature of haskell
05:25:49 <dstolfa> i ought to just look at the code don't i
05:26:45 <ertes-w> dstolfa: IO is an EDSL for programs, but you can't run IO actions from within haskell…  if you compile a program, it contains a 'main' action, and the RTS acts as an interpreter for that action
05:27:01 <ertes-w> think of 'main' as a recipe and of the RTS as the cook reading and executing it
05:27:55 <ski> @type System.IO.Unsafe.unsafePerformIO
05:27:57 <lambdabot> IO a -> a
05:29:06 <dstolfa> ertes-w: unfortunately i've not looked into the internals of GHC (ENOTIME), but what you're describing like IO is a special monad implemented as an EDSL, where if you override certain things in a program that have to do with the IO monad, you just can't perform any IO or implement a monad that does it yourself?
05:29:29 <ski> @quote is.not.the.cake
05:29:29 <lambdabot> ski says: <ski> `getLine :: IO String' is a recipe for how to interact with the world to acquire a `String'  <ski> the recipe is not the cake
05:30:18 <ski> what do you mean by "override certain things in a program that have to do with the IO monad" ?
05:30:47 <ertes-w> dstolfa: it's far simpler than you're imagining it:  IO is nothing special
05:31:53 <ertes-w> dstolfa: think of a value of type (IO A) as a recipe, literally a string with instructions if you will
05:32:33 <ertes-w> you can't *run* that recipe in haskell, but you can compose recipes to form larger ones (for example using do-notation)
05:33:21 <dstolfa> ertes-w: right, i get that, but what i'm asking is what an implementation of it is. for example, you can specify a syntax in a language that does a lot of fun things, but eventually will go through the compiler and map into a runtime. if the runtime code exists (and can run), there's nothing stopping you from implementing your own IO. so my question was whether or not this is the case (it sounds like not)
05:33:39 <ertes-w> dstolfa: the implementation is magic
05:33:56 <ski> uses compiler-provided operation primitives
05:34:13 <ski> (just like addition of `Int's and `Double's do)
05:34:42 <tdammers> one very important thing to remember is that "IO has something to do with real-world effects" and "IO is a Monad" are almost entirely unrelated
05:34:58 <merijn> tdammers: I think you can leave out the "almost" there
05:35:06 <dstolfa> ski: so, if i were to write lots of complicated haskell that would perform IO, i could use certain primitives that GHC provides that then compile into IR, don't get sanitised in this case and in the resulting ELF/Mach-O/CLF/... i could perform IO?
05:35:19 <ertes-w> dstolfa: it doesn't really have to be magic; the RTS could be an actual interpreter, but a magic implementation (using weird primitives) makes IO go fast
05:35:31 <ertes-w> dstolfa: the RTS reading instructions and executing them is more of a mental model
05:35:36 <merijn> ertes-w: Gotta go fast!
05:35:43 <tdammers> merijn: well, they are related in the sense that the rules for combining IO actions happen to fit the monad laws, so it makes sense to have a Monad instance for IO
05:35:55 <ertes-w> oh, do i have 50 fields today?
05:36:41 <dstolfa> tdammers: well, let's forget monads for a second. given the base language without any standard library, could i implement IO (monad or not)?
05:37:04 <dstolfa> so, could i force the compiler to map some haskell code into RTS that would then get JITted or AOT compiled into a linker file, linked together and so on that would then perform IO?
05:37:24 <cocreature> you need some kind of RTS that actually runs your DSL
05:37:37 <tdammers> dstolfa: without any primitives that allow you to access IO functionality, and given a correct implementation of the language? no.
05:38:02 <ski> perhaps one could build such an RTS, interpreting a data structure, using the FFI (starting the Haskell run-time from the other language, say C)
05:38:02 <dstolfa> tdammers: okay, so the compiler has to expose some IO primitives via the runtime?
05:38:23 <ertes-w> dstolfa: if you implement IO in haskell itself, you have to use primitives, and those primitives must cheat haskell semantics
05:38:37 <ertes-w> (that's what the real implementation looks like)
05:38:58 <dstolfa> ertes-w: okay, that makes sense. so does lambdabot use that version of ghc that exposes the primitives? if so, could you, in theory, use these primitives to do IO?
05:39:00 * ski idly wonders whether GHC will gain uniqueness types
05:39:07 <dstolfa> because you're cheating haskell semantics here
05:39:28 <ertes-w> dstolfa: it does…  if you could import something like GHC.Exts, then you could access them
05:39:30 <ertes-w> but…
05:39:35 <ertes-w> @let import GHC.Exts
05:39:37 <lambdabot>  .L.hs:135:1: error:
05:39:37 <lambdabot>      GHC.Exts: Can't be safely imported! The module itself isn't safe.
05:39:37 <lambdabot>      |
05:40:20 <merijn> ski: Why bother with uniqueness types when it's already getting linear types?
05:40:26 <dstolfa> ertes-w: okay. that makes sense. is GHC.Exts a haskell module or is it really a primitive thing that the compiler resolves internally into its own bindings for the runtime?
05:40:29 <ski> not the same thing
05:40:39 <merijn> ski: AFAIK linear types are strictly more powerful than uniqueness types?
05:41:00 <ski> linear types ensure you don't duplicate (or discard) "in the future"
05:41:11 <ski> uniqueness ensures you haven't duplicated "in the past"
05:41:34 <ski> the latter is what is needed for update-in-place
05:42:14 <lts> ski: few days back you gave me reviews on improving a simple function by replacing guards with pattern matching ; i made those changes - http://lpaste.net/diff/361966/362069 ; can this be made better, thanks in advance
05:42:35 <dstolfa> > f x y = (# x+1, y-1 #)
05:42:38 <lambdabot>  <hint>:1:7: error:
05:42:38 <lambdabot>      parse error on input ‘=’
05:42:38 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
05:42:50 <dstolfa> @let f x y = (# x+1, y-1 #)
05:42:52 <lambdabot>  Defined.
05:42:55 <dstolfa> hmm
05:42:58 <dstolfa> well, these are unboxed types
05:43:03 <dstolfa> they're GHC primitives
05:43:05 * dstolfa wonders...
05:43:11 <ertes-w> dstolfa: TBH i don't know…  i would expect GHC.Exts to be a regular module with FFI bindings, but it might as well be magic
05:44:12 <dstolfa> > f 3 4
05:44:16 <lambdabot>  error:
05:44:16 <lambdabot>      attempting to use module ‘main:M805286559324052867224027’ (/tmp/80528655...
05:44:17 <ski> lts : hm, didn't we conclude that there was a redundant defining equation in there ?
05:45:03 <ski> > case f 3 4 of (# a , b #) -> [a,b]
05:45:06 <lambdabot>  error:
05:45:07 <lambdabot>      attempting to use module ‘main:M334164454353220931624048’ (/tmp/33416445...
05:45:12 <ski> > case L.f 3 4 of (# a , b #) -> [a,b]
05:45:15 <lambdabot>  error:
05:45:15 <lambdabot>      attempting to use module ‘main:M768479731985253826724061’ (/tmp/76847973...
05:45:17 <ski> bah
05:45:34 <dstolfa> ski: something is definitely happening, but breaking when using it
05:45:46 <dstolfa> i wonder if you could run an IO primitive like this
05:46:40 <dstolfa> > raiseIO#
05:46:44 <lambdabot>  error:
05:46:44 <lambdabot>      attempting to use module ‘main:M206316950724118414724104’ (/tmp/20631695...
05:47:08 <lts> ski: ah right ; done (http://lpaste.net/diff/362069/362070) ; thanks a lot!!
05:47:10 <ski> @type map
05:47:11 <lambdabot> error: Variable not in scope: map
05:47:25 <ski> lambdabot seems confused at the moment
05:48:04 * merijn updates the sign "It's been 0 days since I last had to spend time debugging because I forgot which way filter works"
05:49:13 <dstolfa> ski: so i wonder if there could be a sanitizer for compiler keywords in lambdabot to avoid this?
05:49:21 <dstolfa> they're well defined and there's doc: https://downloads.haskell.org/~ghc/7.8.4/docs/html/libraries/ghc-prim-0.3.1.0/GHC-Prim.html
05:49:35 <cocreature> @undefine
05:49:35 <lambdabot> Undefined.
05:49:37 <cocreature> @type map
05:49:38 <ski> lts : i'm not sure about what `unbalanced' is supposed to do exactly, and also not sure whether it actually succeeds in doing that
05:49:39 <lambdabot> (a -> b) -> [a] -> [b]
05:50:33 <ski> ok, something seems to be up with `let' in lambdabot
05:51:46 <lts> ski: it works fine ; it was a part of assignment that we had to submit 3 days back ; though the version i submitted worked to, I just wanted to make it look as beautiful as possible :P
05:53:53 <ski>   unbalanced "()"  =  ""
05:54:09 <ski>   unbalanced "x(()())y"  =  "xy"
05:54:33 <ski>   unbalanced "(x)"  =  "(x)"
05:54:46 <lts> right ; so unbalanced should be given a parentheses string, and it returns the string of parentheses which needs to be removed to make it balanced
05:54:47 <ski> perhaps in the latter case, one would expect just `"x"'
05:54:54 <dstolfa> > raiseIO#
05:54:57 <lambdabot>  error: Variable not in scope: raiseIO#
05:55:15 <dstolfa> @let f x y = (# x+1, y-1 #)
05:55:17 <lambdabot>  Defined.
05:55:18 <dstolfa> > f 3 4
05:55:21 <lambdabot>  error:
05:55:21 <lambdabot>      attempting to use module ‘main:M390569759278726701224286’ (/tmp/39056975...
05:55:29 <dstolfa> @type map
05:55:31 <lambdabot> error: Variable not in scope: map
05:55:34 <dstolfa> ^ there we go
05:55:40 <merijn> Does lambdabot even have MagicHash and UnboxedTuples enabled?
05:55:43 <dstolfa> @undefine
05:55:43 <lambdabot> Undefined.
05:55:45 <dstolfa> @type map
05:55:47 <lambdabot> (a -> b) -> [a] -> [b]
05:56:05 <dstolfa> ski: i think it's because of unboxed types
05:56:09 <merijn> I think it's just unable to parse the module when you @let something with MagicHash or UnboxedTuples
05:57:21 <dstolfa> @let data MyInt = MyInt Int Int#
05:57:23 <lambdabot>  .L.hs:159:24: error:
05:57:23 <lambdabot>      Not in scope: type constructor or class ‘Int#’
05:57:23 <lambdabot>      Perhaps you meant one of these:
05:57:49 <ski> > let f x y = (# x+1, y-1 #) in case f 3 4 of (# a , b #) -> [a,b]
05:57:52 <lambdabot>  [4,3]
05:57:55 <dstolfa> @let data Foo = Foo (# Int, Int #)
05:57:58 <lambdabot>  Defined.
05:58:24 <dstolfa> > f :: (# Int, Int #) -> (# Int, Int #)
05:58:28 <lambdabot>  error:
05:58:28 <lambdabot>      attempting to use module ‘main:M415767657271046105024457’ (/tmp/41576765...
05:58:28 <dstolfa> > f x = x
05:58:31 <lambdabot>  error:
05:58:31 <lambdabot>      attempting to use module ‘main:M424882478494407506924470’ (/tmp/42488247...
05:58:34 <dstolfa> @undefine
05:58:35 <lambdabot> Undefined.
05:58:37 <dstolfa> @let data Foo = Foo (# Int, Int #)
05:58:39 <lambdabot>  Defined.
05:58:44 <dstolfa> > f :: (# Int, Int #) -> (# Int, Int #)
05:58:47 <lambdabot>  error:
05:58:47 <lambdabot>      attempting to use module ‘main:M647438702090463696824513’ (/tmp/64743870...
06:02:08 <poapoa> Hya! I'm struggling with a thingy: overlapping ADTs. I'm sure it had brought up before. `data Vegetables = Carrot | Potato; data GoodForSalad = Cucumber | Carrot`. Any ideas how to approach such a thing?
06:02:43 <Putonlalla> What would be the use of such a thing, poapoa?
06:02:50 <merijn> poapoa: Why is GoodForSalad a datatype isntead of a function?
06:02:55 <ski> seems you're looking for subtyping, or refinement types ?
06:03:03 <poapoa> because it fails in compile time
06:03:09 <poapoa> mmm
06:03:11 <poapoa> sorta
06:03:27 <poapoa> but not full subtyping because it's limited to literals
06:03:40 <metahumor> "makeSalad :: exists GoodForSalad a *> a -> IO Salad"?
06:03:42 <poapoa> like the way `4` types to `Num a => a`
06:04:01 <ski> metahumor : brackets ?
06:04:09 <dstolfa> poapoa: why isn't potato good for salad? :(
06:04:25 <metahumor> raw food movement
06:04:43 <ski> (why isn't cucumber a vegetable ?)
06:04:44 <poapoa> dstolfa: because EdibleRaw didn't pop to mind at the moment xD
06:04:47 <metahumor> ski: what do you mean? brackets as in ()?
06:04:51 <ski> yes
06:04:59 <int-e> @let data Foo = Foo (# Int, Int #)
06:05:00 <lambdabot>  .L.hs:158:17: error: Not in scope: type constructor or class ‘#’
06:05:01 <lambdabot>      |
06:05:01 <lambdabot>  158 | data Foo = Foo (# Int, Int #)
06:05:15 <ski> > let f x y = (# x+1, y-1 #) in case f 3 4 of (# a , b #) -> [a,b]
06:05:18 <lambdabot>  [4,3]
06:05:33 <metahumor> ski: as in "makeSalad :: ... -> IO ()" or surrounding some expression with brackets?
06:05:46 <dstolfa> @let f x y = (# x+1, y-1 #)
06:05:49 <lambdabot>  .L.hs:159:10: error:
06:05:49 <lambdabot>      A section must be enclosed in parentheses thus: (# x + 1)
06:05:49 <lambdabot>      |
06:05:49 <ski> wrapping the existential
06:06:06 <metahumor> ah, yeah. but in either case, not valid syntax (yet)
06:06:09 <dstolfa> seems to be fixed
06:06:13 <ski> int-e : ty
06:06:33 <metahumor> poapoa: how will you be using GoodForSalad?
06:06:42 <ski> (also, you forgot to bind the variable)
06:06:53 <metahumor> poapoa: reason we're asking is it seems you might be on the road to an antipattern
06:07:03 * ski imagines that poapoa doesn't know the answer to that question yet
06:07:11 <poapoa> not sure...
06:07:31 <poapoa> I know the arguments against subtyping
06:07:31 <int-e> dstolfa: I just disabled that (it's the best I can do on short notice... @type uses ghci which chokes on code involving unboxed tuples)
06:07:53 <poapoa> I'm more trying to implement `Carrot` to a "literal" of type `Veg a => a`
06:08:09 <int-e> @type let f x y = (# x+1, y-1 #) in f
06:08:11 <lambdabot> (Num a, Num b) => a -> b -> (# a, b #)
06:08:11 <poapoa> the same way `4` is of type `Num a => a`
06:08:40 <dstolfa> > import GHC.Prim
06:08:44 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
06:08:44 <ski> @type (GHC.Prim.+#)
06:08:45 <lambdabot> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
06:08:50 <metahumor> 4, as a literal, can be an Int, or Integer, or Double, or some weird Num instance I wrote
06:08:57 <ski> int-e : s/@type/@let/ ?
06:09:04 <metahumor> I don't expect Carrot to be much more than a Vegetable
06:09:13 <metahumor> how you use it is what is important
06:09:33 <int-e> ski: no, it's @type that ultimately chokes on loading L.hs if it contains functions that use unboxed tuples.
06:09:35 <ski> @type GHC.Prim.quotRemInt#
06:09:37 <lambdabot> GHC.Prim.Int# -> GHC.Prim.Int# -> (# GHC.Prim.Int#, GHC.Prim.Int# #)
06:09:41 <metahumor> @where existential-antipattern
06:09:41 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
06:10:00 <int-e> ski: (I admit that my description was incomplete)
06:10:09 <dstolfa> > writeWordOfAddr#
06:10:12 <lambdabot>  error: Variable not in scope: writeWordOfAddr#
06:10:15 <metahumor> poapoa: I think this link has a relevant example, where they are explaining how "Widget a => a" might not be what you want
06:10:16 <poapoa> the usage is that I have ADT types that overlap hard
06:10:17 <ski> int-e : ok. but `@run' also failed in a strange way, above
06:10:26 <metahumor> poapoa: which is similar to your "Veg a => a"
06:10:57 <poapoa> I'll take a look, but isn't the same thing applies to `4` then?
06:11:32 * ski suspects metahumor means s/=>/*>/
06:12:15 <metahumor> in my most recent "Veg a => a", I was quoting poapoa's syntax
06:12:47 <lts> I've read that foldl/foldr makes use of lazy evaluation when necessary (https://stackoverflow.com/a/38413324/5107319) ; I have two versions available for a function (finding shortest list in a list of lists): one uses recursion and another uses foldl ; am I right in concluding that foldl version should be preferred ? Or does this apply only to specific cases (like the one demonstrated in the SO answer)
06:12:47 <int-e> > let f x y = (# x+1, y-1 #) in case f 1 2 of (# _, _ #) -> () -- I guess this still doesn't work either
06:12:50 <lambdabot>  ()
06:12:56 <int-e> hmm weird
06:13:06 <metahumor> poapoa: the same thing does not apply to 4 because the literal itself is ambiguous
06:13:10 <ski> poapoa : i suppose you could make a type class `class Carrotable a where carrot :: a' with `instance Carrotable Vegetable where carrot = VegCarrot' and `instance Carrotable SaladIngredient where carrot = SaladIngrCarrot'
06:13:40 <metahumor> or a type family
06:13:43 <ski> metahumor : oh, sorry then
06:13:50 <int-e> ski: Okay there's some detail here that I'm missing... maybe about the way the expression is type-checked before it's run. But it should still come down to using unboxed tuples inside L.hs.
06:14:00 <ski> ok. fair enough
06:14:14 <metahumor> lts: for lazy, prefer foldr
06:14:21 <metahumor> lts: over foldl, I mean
06:14:31 <lts> i see
06:14:50 <metahumor> lts: reason being is that plain old lazy foldl has a space leak
06:16:13 <metahumor> lts: foldl f z as = f ( a ( f ( b ( f ( c (... f y z ) ) ) ) ) )
06:16:34 <ski> > foldl f z [a,b,c,d]
06:16:36 <lambdabot>  f (f (f (f z a) b) c) d
06:16:39 <ski> > foldr f z [a,b,c,d]
06:16:43 <lambdabot>  f a (f b (f c (f d z)))
06:16:49 <metahumor> right, typo
06:16:56 <metahumor> I meant foldr =) thanks ski
06:17:09 <quchen> The difference doesn’t really show for finite lists.
06:17:17 <lts> oh wow, that gives me a totally new perspective!!!
06:17:26 <ski> (and you had some extra, incorrect, brackets, which might be confusing lts)
06:17:36 <metahumor> yeah, apologies lts
06:17:48 <ski> @where folds
06:17:48 <lambdabot> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
06:17:51 <ski> lts ^
06:17:51 <lts> no worries, thanks for the awesome explanation
06:18:57 <ski> > foldl (**) z [a,b,c,d]
06:19:00 <lambdabot>  (((z**a)**b)**c)**d
06:19:00 <lts> oh yes ; our prof did use this diagram in slides in the class ; although at that time i didn't think that foldl can lead to a space leak
06:19:01 <ski> > foldr (-) z [a,b,c,d]
06:19:04 <lambdabot>  a - (b - (c - (d - z)))
06:19:30 <ski> (iirc, Cale made those diagrams)
06:19:32 <metahumor> what's the library being used that allows lambdabot to show the symbolic computation?
06:19:37 <quchen> Well, foldl makes it very easy to create a huge thunk on the heap that we like to call a space leak.
06:19:50 <quchen> metahumor: simple-reflect
06:20:05 <ski> @hackage simple-reflect
06:20:05 <lambdabot> http://hackage.haskell.org/package/simple-reflect
06:20:38 <lts> I wish i knew this earlier ; in both my previous assignments i used to prefer foldl over foldr (randomly :P )
06:20:48 <quchen> foldr is much more efficient: while foldl creates a heap leak that when forced creates a stack leak, foldr only leaks on the stack. ;-P
06:21:15 <quchen> foldl is close to the functional for-loop, maybe that’s why it feels more familiar to some in the beginning.
06:21:50 <quchen> foldr on the other hand often makes use of laziness, so examples tailored to it feel a bit alien. At least that’s how it was for me.
06:21:55 <lts> quchen: right ; going from left to right used to seem more intuitive earlier
06:22:06 <quchen> Both go from left to right.
06:22:07 <ski> `foldl' is bulky, while `foldr' may be incremental (if the callback is non-strict in its second argument)
06:22:16 <quchen> It’s wrong that foldr »goes from the right«.
06:22:22 <quchen> ?src foldr
06:22:22 <lambdabot> foldr f z []     = z
06:22:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:22:34 <quchen> Nowhere does this inspect the end of the list parameter.
06:22:42 <ski> `foldr' can be said to conceptually "group from/to the right"
06:22:56 <quchen> Yes, and that’s highly misleading.
06:23:02 <metahumor> lts: only one of {foldl,foldr} is valid on infinite lists -- which?
06:23:14 <lts> metahumor: foldr
06:23:18 <lts> oh wait
06:23:26 <ski> (if one starts with thinking of a list as a "flat sequence", which is strictly speaking incorrect)
06:23:57 <hask_bee_3> Getting this msg from stack: "Ignoring package.yaml in favor of cabal file. If you want to use package.yaml instead of the cabal file, then please delete the cabal file."
06:23:57 <hask_bee_3> Which do you prefer, the yaml or cabal file, and why?
06:23:59 <lts> metahumor: i think it should be foldr
06:24:08 <quchen> lts: Well, compare their sources
06:24:10 <lts> foldl will cause a space leak
06:24:14 <sbrg> hask_bee_3: i prefer package.yaml personally because it simplifies things
06:24:38 <quchen> foldr can also produce space leaks. In fact, foldr can produce foldl. :-)
06:24:42 <sbrg> don't have to repeat dependencies which are common between lib and executable in such cases, etc
06:24:53 <quchen> lts: Try looking at their definitions. What kind of recursion is foldl?
06:24:55 <quchen> ?src foldl
06:24:56 <lambdabot> foldl f z []     = z
06:24:56 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:25:04 <metahumor> hask_bee_3: the yaml file is managed ('magically') by hpack, if you want a reference to the syntax
06:25:27 <hask_bee_3> nice ok
06:25:34 * lts thinks hard about types of recursions
06:25:38 <hask_bee_3> i'll go with yaml
06:25:52 <metahumor> how often does this link get shared here: https://www.willamette.edu/~fruehr/haskell/evolution.html?
06:26:34 * quchen thinks of a helpful tail to tell lts that doesn’t spoil the solution but gives a hint
06:26:51 <lts> quchen: it's tail recursion!!
06:27:39 <quchen> Right. foldl transfers control back to itself no matter what with a one element shorter list. As a result, it has to walk the entire list before it can yield a value.
06:27:52 <quchen> For infinite lists, that takes quite a bit of time.
06:28:00 <quchen> foldr on the other hand is not tail recursive,
06:28:01 <quchen> ?src foldr
06:28:01 <lambdabot> foldr f z []     = z
06:28:02 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:28:30 <quchen> See how the foldr is nested? If »f« does not need its second argument depending on e.g. »x«, then the recursion can stop.
06:28:38 <quchen> > foldr const 1 [10..]
06:28:42 <lambdabot>  10
06:28:58 <quchen> foldr const 1 [10..] = const 1 (foldr …) = 1
06:29:10 <quchen> Eh, flipped the arguments around there. But you get the point.
06:30:16 * lts has moved into trance ; he is baffled that he has learnt so much in last 5-10 minutes ; he is never leaving #haskell again
06:30:21 <lts> thanks a lot quchen
06:30:41 <lts> it all makes total sense now!!
06:30:44 * ski smiles
06:30:47 <quchen> #haskell osmosis is awesome. I learned so many things by just idling in here and evasdropping on interesting conversations.
06:31:09 <ventonegro> *insert mind-blown meme here*
06:31:12 <quchen> lts: Try implementing map and then filter with foldr. It’s a challenge, but very rewarding.
06:31:22 * lts gets to work
06:31:32 <ski> @quote is.not.there
06:31:32 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
06:31:32 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
06:31:56 <tdammers> constants are variables, too
06:32:17 <tdammers> they just vary in a different frame of reference
06:32:31 <quchen> »Let’s take any integer, say ›n‹. Well, that’s too big, let’s say ›k‹.« :-)
06:32:48 * ski recalls getting an epiphany regarding that, many years ago
06:33:03 * quchen used »1« as a variable this weekend
06:33:16 <quchen> :->
06:33:35 <tdammers> quchen: protip: use only 1, l, I, O and 0 to name your identifiers
06:33:51 <quchen> My font renders those distinct, unfortunately
06:34:06 <tdammers> yours might, but not everyone's will
06:34:13 <merijn> @quote first.26
06:34:14 <lambdabot> alexbagel says: i find that my first 26 variables are always easy to name. after that it becomes a bit harder.
06:34:27 <tdammers> unicode syntax ftw
06:34:49 <quchen> Unicode to the rescue. None of this is ASCII, аеорсух АВЕКМНОРСТУХ.
06:35:41 <metahumor> I can easily tell its not ASCII because I read it in Russian
06:36:16 <metahumor> because of two "tells": the letter ordering, and the way the "Y/U" glyph looks like on my machine
06:36:24 * ski . o O ( `4 * 8  =  d 16 / d 2  =  ln 4 * 16')
06:37:08 <metahumor> a slightly different ordering with some glyph variations would've been obviously Greek to me
06:37:16 <tdammers> quchen: that's great, so just make all your variables combinations of a and а
06:37:24 <Putonlalla> > let x = 13 in х
06:37:27 <lambdabot>  42
06:37:51 <metahumor> ski: what is `d`?
06:37:54 <quchen> > let _'''''' = "tdammers, unary is clearly superior" in _''''''
06:37:57 <lambdabot>  "tdammers, unary is clearly superior"
06:38:07 <ski> metahumor : that's supposed to be Leibniz notation for derivatives
06:38:54 <metahumor> ski: that's what I thought, but then I got confused as to how you're d/dx'ing Zs
06:39:44 <ski> clearly, `d 2^4 / d 2  =  4 * 2^(4-1)'. also, `d 4^2 / d 2  =  d e^(ln 4 * 2) / d 2  =  ln 4 * e^(ln 4 * 2)  =  ln 4 * 4^2'
06:44:59 * metahumor shudders
07:03:49 <parsnip> any hakyll blog sites with math? i've seen exactly one, tracing it from a mailing list issue.
07:04:32 <parsnip> curious if they insert $..$ or \(..\) for math, pandoc's markdown default is $..$, but that's hakyll's templating system too.
07:05:11 <parsnip> (the mailing list results in some workaround of the templating, which i need to research, as a 2012 solution may need adaption)
07:05:56 <hyperisco> dmwit, wrt simpler, I think  Compose m (Reader x) r  is not Monad…  Compose m (Reader x) (Compose m (Reader x) r) = m (x -> m (x -> r))  goal is  m (x -> r)
07:06:02 <merijn> parsnip: Solution: Use rST since markdown is an ill-specified format anyway
07:08:34 <mnoonan> parsnip: I just hacked the markdown package for by blog to allow $ and ```latex fences
07:08:59 <hyperisco> what is a type like Either but where  Left a <|> Left b = Left (a <> b)  ?
07:09:10 <merijn> hyperisco: Validation?
07:09:21 <hyperisco> oh did I fall back onto that? :P
07:09:44 <merijn> hyperisco: Well, collecting multiple "failures" is exactly what it's for, no? ;)
07:10:13 <hyperisco> I think you pointed me to that a few days ago
07:10:23 <hyperisco> not great that I already forgot about it!
07:11:33 <hyperisco> specifically it is for collecting over choice though
07:12:44 <metahumor> Validation is the reason "either" has a large dependency graph
07:13:32 <parsnip> mnoonan: markdown package? for me that's pandoc, it can expect $, that's the default. it's that hakyll is using $ for templating.
07:13:40 <parsnip> *accept
07:13:53 <hyperisco> because I desire the Monad instance
07:14:18 <parsnip> merijn: does rst have inline math?
07:15:25 <parsnip> anyway, guess no hakyll users with math?
07:17:25 <merijn> parsnip: I've used hakyll with rST and LaTeX for math before
07:17:44 <mud> parsnip: Why does it matter what hakyll's templating character is? Are you trying to do math in a template itself? You could do $$ then for a single $. But usually the math would be in content, right?
07:18:54 <parsnip> i guess. i think i tried to use an "include" hack to include python file contents, and that made hakyll treat content as a template. i found a blog post with markdown and math though, for a sanity check.
07:19:00 <parsnip> https://github.com/ian-ross/blog/blob/master/posts/2015/02/12/data-analysis-ao1-13.markdown
07:19:13 <parsnip> got to head to work
07:21:10 <hyperisco> there are no laws I am aware of that interact between <|> and <*>
07:21:39 <hyperisco> so collecting over <|> and not <*> should avoid incompatibility with Monad
07:23:02 <hyperisco> the feels when you need just one instance to be different…
07:30:06 <hyperisco> it feels kinda dumb it doesn't do that already because…
07:30:16 <hyperisco> > empty :: Either String Int
07:30:19 <lambdabot>  Left ""
07:31:55 <infandum`> What is the most efficient way to store an fgl graph to a file?
07:32:01 <merijn> hyperisco: It's because you want the Alternative and MonadPlus instances to match
07:32:18 <merijn> infandum`: My custom, not yet publically implemented graph file format :)
07:32:39 <infandum`> There is no aeson instance and you can't store labels in dot format.
07:32:42 <merijn> infandum`: Every single existing format I've found for storing graphs is shit, so you might as well pick an arbitrary one
07:32:43 <hyperisco> merijn, well why couldn't they match?
07:33:05 <merijn> hyperisco: Because the MonadPlus instance for Either mathes Monad, i.e. early termination on first Left
07:33:20 <parsnip> i thought hakyll was eating $s on posts that i wasn't applying templating function to too though.
07:33:27 <infandum`> merijn: The easiest would be "writeFile . show", but I want non-haskell people to be able to make them as input as well.
07:33:38 <parsnip> that is, just feeding in as content/body.
07:33:43 <hyperisco> merijn, ehh… like I was saying though, the two operators are not really related… but I can see some sense in that
07:34:11 <merijn> hyperisco: They are, though
07:34:19 <hyperisco> by what law?
07:34:21 <merijn> hyperisco: MonadPlus has laws relating to Monad
07:34:29 <mud> parsnip: Hmm, I don't think so, could be wrong though somehow.
07:34:32 <merijn> mzero >>= f  =  mzero
07:34:32 <merijn> v >> mzero   =  mzero
07:34:44 <runeks> How does https://www.stackage.org/haddock/lts-9.21/base-4.9.1.0/GHC-TypeLits.html#v:someSymbolVal work?
07:35:04 <merijn> hyperisco: And obviously Alternative should match MonadPlus for sanity's sake
07:35:21 <parsnip> yes, i should experiment later, i have that other person's post now, and a few other hakyll example sites to sift through for more like that.
07:35:23 <runeks> How can an arbitrary value-level String be known to belong to the KnownSymbol class?
07:35:35 <hyperisco> merijn, gotcha
07:35:38 <runeks> (Which is a requirement for constructing a SomeSymbol)
07:35:51 <parsnip> maybe they have some site.hs magic, will read on bus.
07:36:14 <merijn> hyperisco: So, given the choice between two Applicatives for a type, the preferred one is generally the one that also supports Monad (see lists)
07:36:29 <hyperisco> merijn, I'd have to prove it but I don't immediately see a reason this alternative Left behaviour would be a problem
07:37:21 <lyxia> runeks: it's magic (internally a KnownSymbol constraint is a String parameter)
07:38:04 <runeks> lyxia: So it's not generally possible to convert a value to a type that must belong to a class?
07:38:20 <runeks> And it only works because all Strings are KnownSymbols when lifted to the type level?
07:38:50 <lyxia> runeks: there are similar tricks for any typeclass
07:39:15 <runeks> lyxia: Where can I read about that?
07:39:33 <lyxia> runeks: https://hackage.haskell.org/package/reflection has a few links
07:39:44 <runeks> Great! Thanks.
07:39:49 <metahumor> runeks: I like https://blog.jle.im/entry/introduction-to-singletons-1.html and the follow-up part-2
07:40:03 <runeks> Even better
07:54:38 <hyperisco> is it polite to make a submodule for someone else's package? :P
07:56:57 <merijn> hyperisco: For what purpose?
07:57:33 <hyperisco> it builds on their package but also has similar purpose … pretty sure I've already done this
07:58:11 <hyperisco> yeah such as here https://hackage.haskell.org/package/regex-tdfa-quasiquoter
07:58:12 <merijn> hyperisco: What does "builds on" mean? If you're just using it as a dependency, why not add it as dependency
07:58:37 <hyperisco> because it is expressly for their module specifically
07:58:42 <merijn> hyperisco: oh, you mean having modules as submodule in the hierarchy?
07:58:49 <hyperisco> yes
07:58:58 <hyperisco> because technically you are dirtying their namespace :P
07:59:14 <merijn> hyperisco: Only for people depending on your package
07:59:22 <merijn> ALthough you should try and make sure to avoid collisions
08:00:28 <AWizzArd> https://wiki.haskell.org/Monad/ST says „The ST monad provides support for strict state threads.”  – Does „strict” mean here „non-lazy”? I.e. eager evaluation?
08:02:41 <merijn> AWizzArd: Honestly that just seems wrong to my (admittedly spotty) knowledge of ST
08:03:01 <merijn> I have no clue why they're calling ST strict
08:04:05 <merijn> ok
08:04:57 <merijn> Yeah, so strict ST just means it's strict in the usage of ST operations
08:06:45 <ski> AWizzArd : perhaps see monochrom's "lazy ST example" (and followups) in 2012-(02-18,05-26),2013-03-29 at <http://lpaste.net/63925>
08:07:51 <AWizzArd> Okay, I just wanted to get this confirmed. Wasn’t totally sure about the meaning in this context.
08:08:03 <ski> (also you could compare with "control.monad.state.lazy" in 2010-11-25,2013-02-27 at <http://lpaste.net/41790>
08:12:19 <sr10> i need help
08:12:20 <sr10> if
08:12:20 <sr10> subject = ["maths","science","chemistry","french"]
08:12:20 <sr10> marks = [("john",[("science",85),("maths",55)]) , ("ron",[("chemistry",65),("maths",44)]) , ("sam",[("maths",65)])  ]
08:12:20 <sr10> i want output as
08:12:21 <sr10> [("maths",["john","ron","sam"]),("science",["john"]),("chemistry",["ron"]),("french",[])]
08:12:23 <sr10> using map.
08:14:30 <runeks> Is there a way to test, at runtime, whether a given input String lifted into a Symbol, is an instance of some class?
08:15:13 <lyxia> no
08:15:37 <metahumor> sr10: do you have to use lists of tuples, or can you use Maps?
08:15:57 <metahumor> sr10: I guess if the exercise is to use "map" then it assumes you are working on lists
08:16:22 <sr10> list of tuples
08:16:27 <metahumor> sr10: how have you gone about thinking how to tackle this exercise?
08:16:27 <ski> sr10 : done
08:16:52 <lts> I like how lambdabot works on this channel, and was thinking it'd be nice if I have something similar available on my ghci ; came across the instructions (https://wiki.haskell.org/Lambdabot#Installing) ; is proceeding to an install a good idea (as on doing cabal install i was prompted that a lot of packages might break) or is there an alternative ?
08:17:11 <metahumor> lts: do you mean the @hoogle @pf stuff?
08:18:59 <lts> hmm, i'm not familiar with those, just beginning ; I liked how members here do "?src <function-name>" and something like that on ghci would be more than enough
08:19:08 <sr10> @metahumor
08:19:08 <lambdabot> Unknown command, try @list
08:19:08 <sr10> [("maths",["john"]),("maths",["ron"]),("maths",["sam"])] im getting this output
08:19:08 <sr10> [("maths",["john"]),("maths",["ron"]),("maths",["sam"])]
08:19:30 <geekosaur> lts, note that @src is a lie
08:19:54 <ski> which list are you passing to `map' ?
08:20:02 <geekosaur> it's usually got the right idea, but rarely has the actual implementation. most of it is teaching versions cribbed from e.g. the langauge report
08:20:29 <thebnq> hmm the lambdabot instructions are a bit old, might not compile?
08:20:30 <runeks> lyxia: Can I do it at compile-time, then? That is, convert a String into a Symbol (at compile-time), and have compilation fail if I attempt to use the resulting Symbol in something that requires a Symbol that belongs to some type class, but does not?
08:21:00 * ski can imagine the answer to the question, but would like sr10 to reflect on it
08:21:05 <lts> geekosaur: oic, wasn't aware of that
08:21:27 <lyxia> runeks: no, the string has to be at type-level in the first place
08:21:41 <runeks> I see
08:21:46 <metahumor> sr10: okay, how did you produce that output? like ski asked -- what list are you "map"ing over? what function are you using in the "map"?
08:21:49 <glguy> To convert a String into a Symbol at compile time you'd use Template Haskell
08:22:17 <runeks> I'd like to avoid TH, if possible, although I'm not sure why
08:22:47 <glguy> Without template haskell it wouldn't even make sense to ask about converting a string to a symbol at compile time
08:23:17 <runeks> I think it makes sense...
08:23:27 <runeks> I hear they're the same under the hood
08:23:37 <hyperisco> in glguy we trust
08:24:37 <sr10> (concatMap (\(subjectname,marks,validsubject,validmessage)->
08:24:37 <sr10>                 if(validstudent==True && validsubject == True && subjectname=="Geography" )
08:24:37 <sr10>                    then [(subjectname,[studentname] )]
08:24:37 <sr10>                 else [] ))
08:24:56 <hyperisco> :k Symbol
08:24:58 <lambdabot> error:
08:24:58 <lambdabot>     Not in scope: type constructor or class ‘Symbol’
08:24:59 <hyperisco> I never heard of it
08:25:19 <glguy> Maybe paste some code showing what you're trying to do, and we can better understand what you're trying to accomplish.
08:25:31 <runeks> glguy: Good idea. Gimme a minute
08:25:32 <hyperisco> also you can't (or shouldn't) be testing if something is an instance of a class
08:25:33 <ski> @paste
08:25:33 <lambdabot> Haskell pastebin: http://lpaste.net/
08:26:06 <hyperisco> this is something GHC is careful about doing so it doesn't break the open world illusion
08:26:52 <hyperisco> otherwise you are liable to have incoherence
08:27:14 <metahumor> sr10 left again =C
08:27:27 * ski . o O ( "incoherence we trust" )
08:27:42 <ski> hrm
08:27:48 --- mode: ChanServ set +o ski
08:27:56 <metahumor> @tell sr10 okay that's your function, but over what will you map that?
08:27:56 <lambdabot> Consider it noted.
08:28:11 --- mode: ChanServ set -o ski
08:28:43 <ski> sr10 : don't paste large amounts of code to the channel, use a paste site (or some other way of putting your code online)
08:28:46 <ski> @paste
08:28:46 <lambdabot> Haskell pastebin: http://lpaste.net/
08:29:00 <sr10> yes okay
08:29:02 <sr10> sorry
08:29:14 <ski> Sigyn gets angry when it thinks people are spamming
08:31:45 <metahumor> sr10: okay that's your function, but over what will you map that?
08:33:08 <ski> (last happened to me, yesterday, when i was explaining something, requiring a couple of snippets that looked almost the same, but which behaved differently. however, if you've been in the channel for some while, apparently it first warns)
08:33:42 <mud> Sigyn does seem particularly jumpy in this channel for some reason, heh.
08:33:56 <ski> (metahumor : possibly that was included in the part that didn't made it to the channel)
08:34:03 <runeks> So... I have a bunch of instances of "class DataSource (MarketList (venue :: Symbol))" (https://github.com/runeksvendsen/orderbook/blob/master/src/Venues/Bitfinex.hs#L62) which allows me to fetch a "MarketList (venue :: Symbol)" using this "fetch" function: https://github.com/runeksvendsen/orderbook/blob/master/src/Lib/Fetch.hs#L20
08:34:04 <mud> I got warned when I said completely different, short things several minutes apart a few days ago
08:34:31 <sr10> i will map over marks
08:34:51 <ski> (good thing i learned how to convince her of lifting the K-line)
08:34:53 <runeks> Then, I receive a String at runtime, and would like to fetch the MarketList for the given String, lifted to a Symbol
08:35:15 <runeks> and return an error if an instance doesn't exist for the given (DataSource (MarketList symbol))
08:35:48 <metahumor> sr10: I would actually suggest mapping over your list you named "subject"
08:36:06 <metahumor> sr10: in a way that somehow uses "marks"
08:36:15 * ski would like to understand sr10's reasoning
08:36:50 <runeks> Is there a way to do that without, manually, maintaining a list of Strings that corresponds to a list of those same Strings lifted to Symbols?
08:38:20 <metahumor> runeks: could you at compile time inspect the Symbols you have and metaprogram a function of type "String -> Symbol" or the like?
08:38:32 <sr10> @metahumor yes okay
08:38:32 <lambdabot> Unknown command, try @list
08:38:51 <metahumor> then at runtime you could have a "IO (Maybe Symbol)"
08:39:10 <metahumor> sr10: what was your original reasoning to map over marks? that was ski's question
08:39:29 <ski> sr10 : fyi, it's not IRC custom to prepend `@' to people's nicknames, when addressing or otherwise referring to them. just starting the message with the nickname, continuing with a comma or a colon should be fine
08:39:35 <runeks> @metahumor I guess I want to know whether that's necessary
08:39:35 <lambdabot> Unknown command, try @list
08:39:40 <runeks> Because that's totally an option
08:39:48 <ski> runeks ^
08:39:51 <runeks> i.e. converting a String to a Maybe SomeSymbol
08:40:03 <sr10> yes okay
08:40:04 <ski> (also lambdabot gets confused)
08:40:07 <runeks> ski: Got it :)
08:40:54 <sr10> i thought that based on the subjects present inside the list it will map.
08:42:15 <shapr> I like this, but would prefer a version that uses cabal new-build: https://pbrisbin.com/posts/haskell_project_checklist/
08:42:30 <metahumor> sr10: understandable. to me, there is a direct pattern between your list of `subjects = ["maths", "science", ...]` and `answer = [("maths", [...]), ("science", [...]), ...]`
08:42:42 <metahumor> sr10: do you see what I mean? can you expand on my thought?
08:42:46 <runeks> I guess I'm looking for a way to do type-level stuff without maintaining a term-level mirror image (that the compiler can't check)
08:44:36 <merijn> runeks: Install Idris or Agda
08:44:42 <merijn> runeks: Can't be done in haskell
08:45:08 <runeks> merijn: Unless I employ template haskell?
08:45:36 <merijn> runeks: Template Haskell will only let you generate said term-level mirror images automatically at compile time
08:45:44 <merijn> runeks: Can't use that for runtime dynamic values
08:46:01 <merijn> shapr: What would you imagine a new-build based version of that needs?
08:47:03 <shapr> merijn: I'd guess change calls to stack to cabal? maybe that's it?
08:47:05 <sr10> metahumor : yes, i understood
08:47:17 <shapr> I'd also like to know if make -j8 works with that setup.
08:47:29 <lyxia> runeks: don't you know the venues statically
08:47:47 <merijn> shapr: I mean new-build is pretty much identical to whatever you'd do with cabal normally
08:47:56 <shapr> I'm sort of amazed that amazonka takes close to fifteen minutes to build on my laptop.
08:48:04 <runeks> lyxia: I do. I think I will just generate the list of SomeSymbols from a list of Strings at compile-time using TH
08:48:22 <shapr> Mind you, amazonka 1.5.0 doesn't build with cabal new-build, but I think it's getting close.
08:48:32 <merijn> shapr: I mean, pretty much 90% of that link seems to be stack specific?
08:48:52 <shapr> hm, yeah
08:49:02 <shapr> hopefully I'll have time to port that to cabal new-build this week
08:49:27 <merijn> I mean, new-build only requires something special when you wanna depend on local packages
08:49:37 <shapr> that's true, I've been fighting with that the past two days
08:50:15 <merijn> shapr: What's the problem you're having? Should be pretty straight-forward
08:50:38 <shapr> it was straight-forward once I found the documentation for the cabal.project file
08:51:07 <shapr> it was harder to find a list of all the fields for all the files than I expected
08:51:32 <merijn> shapr: I've never really needed much more than just packages/optional-packages, tbh
08:51:34 <shapr> merijn: but then I modified amazonka to fix a build error, and found more problems
08:52:13 <shapr> MarcelineVQ: did you get amazonka 1.5.0 to finish with cabal new-build?
08:52:42 <merijn> shapr: Got a link to the current repo?
08:53:20 <shapr> merijn: you mean, after my changes?
08:53:33 <merijn> shapr: Yeah
08:54:24 <shapr> this was the change I made: https://github.com/brendanhay/amazonka/issues/446
08:54:38 <shapr> credit to MarcelineVQ for finding that :-)
08:55:39 <albatross_> http://lpaste.net/362076 what do we do about the base case for foobar'??
08:57:14 <lyxia> albatross_: there is no base case, this is just a composition of functions
08:58:05 <lyxia> You only need a base case when you explicitly write pattern matching ("case") in a recursive function.
08:58:16 <albatross_> lyxia then what if we need one?
08:58:18 <mjrosenb> blah... arch doesn't appear to ship profiling libraries, and the arch-haskell channel seems dead.
08:59:34 <glguy> pacman haskell support is primarily for supporting pacman packaged binaries, not for development
09:04:14 <shapr> merijn: if you clone the amazonka repo and create a cabal.project that contains "packages: ../amazonka \n  amazonka-examples.cabal" , then cabal new-build errors on Network.AWS.Internal.HTTP
09:04:21 <runeks> Is the time complexity for toNum and toNum' here http://lpaste.net/362077 the same?
09:04:27 <shapr> sorry, the cabal.project should be in amazonka/examples/
09:04:29 <shapr> to be clear
09:04:56 <runeks> In other words, is it faster to use pattern matching, in this case, than "lookup"?
09:10:04 <albatross_> what does segmentation fault mean
09:11:44 <cocreature> it means that the program has tried to access memory that it doesn’t have access to
09:12:10 <geekosaur> if you are getting this from a haskell program, it usually means something's wrong with an FFI call
09:16:36 <albatross_> other than using div in a infix function `div`, how else can we write it?
09:17:26 <ski> > div 19 7
09:17:28 <lambdabot>  2
09:17:46 <albatross_> got it, thanks ski
09:17:56 <fr33domlover> Hello everyone! I ran stack build and HsOpenSSL complains about missing ssl and crypt libs, I installed libssl-dev but it doesn't help
09:18:01 <fr33domlover> What else can I do?
09:18:10 <fr33domlover> I never had this error before
09:18:38 <fr33domlover> (I'm on Devuan Jessie which is basically the same as Debian Jessie)
09:19:32 <albatross_> if i write f = (div) 2, how does it ean
09:19:35 <albatross_> mean*
09:19:44 <albatross_> how would haskell evaluate it?
09:19:59 <albatross_> it gives me zero whenever the number goes above 2
09:20:25 <ski> > let f = div 10 in (f 2,f 3,f 4,f 5,f 6)
09:20:28 <lambdabot>  (5,3,2,2,1)
09:21:00 <albatross_> ah, thanks ski
09:21:03 <ski> > let f = div 10 in (f 2,f 3,f 4,f 5,f 6)  :: (Expr,Expr,Expr,Expr,Expr)
09:21:07 <lambdabot>  (10 `div` 2,10 `div` 3,10 `div` 4,10 `div` 5,10 `div` 6)
09:21:18 <EvanR> > map (div 10) [1..]
09:21:21 <lambdabot>  [10,5,3,2,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
09:22:42 <albatross_> how can i write a function that take the new values as the numberator instead of the denominator
09:23:07 <ski> > let f = (10 `div`) in (f 2,f 3,f 4,f 5,f 6)
09:23:11 <lambdabot>  (5,3,2,2,1)
09:23:12 <ski> > let f = (`div` 10) in (f 2,f 3,f 4,f 5,f 6)
09:23:15 <lambdabot>  (0,0,0,0,0)
09:23:27 <ski> > let f = (`div` 3) in (f 2,f 3,f 4,f 5,f 6)
09:23:31 <lambdabot>  (0,1,1,1,2)
09:24:08 <albatross_> thanks ski
09:43:26 <hyperisco> I just thought… it would also be cool if validation gave not just a report of errors but also a report of what went right!
09:45:12 <Johulk> Hello guys
09:45:26 <hyperisco> and that can be done just with another Monoid…
09:45:34 <Johulk> Can I have some help? I'm trying to make a function that verifies if a square matrix is an upper triangle
09:45:38 <Johulk> but I get this error
09:45:39 <Johulk> http://lpaste.net/362081
09:45:52 <Johulk> and I can't find any already-done implementation to base myself off
09:45:54 <hyperisco> so this is kinda cool… one Monoid for collecting errors over choice, and another Monoid for collecting successes over binds
09:46:13 <Johulk> I have like 15 minutes before I go
09:46:15 <glguy> Johulk: remove the = before your | guards
09:46:21 <Johulk> OKay
09:46:59 <hyperisco> Johulk, make sure you have the right file loaded… reload stuff… because the error message does not match your code
09:47:06 <Johulk> uh
09:47:07 <Johulk> wierd
09:47:17 <Johulk> Well, but it did fix it
09:47:20 <Johulk> but another error now
09:47:51 <glguy> You've got the arguments to !! the wrong way around
09:48:26 <Johulk> Oh
09:48:28 <Johulk> This wont work
09:48:28 <glguy> reverse (h:y:ts) !! 2 == 0
09:48:30 <Johulk> nvm
09:48:39 <Johulk> I can't use Eq so it bugs
09:49:04 <glguy> You'll have to change "Num a" to "(Num a, Eq a)"
09:49:11 <Johulk> I can't do that
09:49:17 <Johulk> It's for an exercise
09:49:27 <Johulk> I'm bound to the Num a =>
09:49:38 <glguy> You'll have to, the exercise is probably from the past when Num implied Eq
09:49:45 <glguy> It's not possible to do this exercise without it
09:50:14 <Johulk> OKay
09:52:02 <Johulk> and Ord too?
09:52:09 <Johulk> for >=
09:57:57 <hyperisco> ah but it must be a commutative monoid…
09:58:06 <hyperisco> because of the monad commutativity law
09:58:16 <hyperisco> and when I say "commutative" I mean "associative"
09:58:31 <EvanR> it must be an associative monoid
09:58:37 <EvanR> a rare sight
09:59:32 <hyperisco> EvanR, :P neuron short…
10:14:02 <kuribas> I made a haskell ADT of our database models.  It was 155 lines and contained most of the db objects.  My coworkers were amazed by the conciseness (vs a 6000 line python file).
10:14:56 <kuribas> well, the python file contains also functionality on the objects, which makes it even more unreadable.
10:15:53 <albatross_> let f = `div` 2 in (f 2, f 3, f 6)
10:16:09 <albatross_> let f = `div` 2 in (f 2, f 3, f 6) :: (Expr, Expr, Expr)
10:16:59 <kuribas> let f = (`div` 2) in (f 2, f 3, f 6)
10:17:02 <kuribas> > let f = (`div` 2) in (f 2, f 3, f 6)
10:17:04 <lambdabot>  (1,1,3)
10:17:24 <kuribas> > let f = (`div` 2) in (f a, f b, f c)
10:17:27 <lambdabot>  (a `div` 2,b `div` 2,c `div` 2)
10:20:11 <metahumor> kuribas: model controller view separation!
10:20:43 <kuribas> metahumor: we have that
10:20:53 <kuribas> I think...
10:21:35 <kuribas> metahumor: we use sqlalchemy
10:21:39 <kuribas> anyway, offtopic
10:21:54 <metahumor> there's a funny image I'm thinking of about how MVC evolved over the past 20 years to a whole jumble
10:21:58 <metahumor> maybe someone is familiar with it
10:22:43 <ggVGc> does MVC stand for Mega Verbose Code?
10:22:51 <ggVGc> asking for a friend
10:25:15 <metahumor> ah, here we go https://vgy.me/a2cvn4.png
10:29:01 <mishugana> hello all, is this forum open to newbies as well or is there a dedicated room for that/
10:29:03 <mishugana> ?
10:31:38 <shapr> mishugana: this forum is definitely for newbies
10:31:44 <shapr> mishugana: got some questions?
10:31:51 <hyperisco> if I have a type  data X a b c = Y a | Z b c  and I want to make a prism for Z, should I have the prism project, say, (b, c) ?
10:32:26 <mishugana> shapr thanks! I don't have questions currently... but good to know! :-)
10:32:37 <pikajude> Does whnf for a String only evaluate the first element?
10:33:30 <mishugana> I am learning Haskell from Professor Hutton's "Programming in Haskell" (2nd Edition) - I like the mathematics like nature of his teaching style... currently 2/3 of the way in... has anybody else finished this book? Would love to hear their thoughts
10:33:45 <metahumor> type String = [Char], use ":sprint" to look at unevaluated thunks in ghci
10:34:02 <hyperisco> such as  bc :: Prism' (X a b c) (b, c)  ?
10:34:06 <shapr> mishugana: oh that's a good choice, I just got the 2nd edition recently.
10:34:08 <mishugana> I tried using Allen and Moronuki's book, but I find it extremely large.. maybe I can use it for more practice?
10:34:28 <shapr> Yeah, I like the homework exercises in "Haskell from First Principles"
10:34:36 <mishugana> shapr that's good to hear! :-) ... I also like that it's not too big... even though it is getting harder
10:34:59 <shapr> I've only flipped through Hutton's PiH book, but I keep meaning to spend more time with it :-)
10:35:05 <shapr> mishugana: how far have you gotten?
10:35:09 <shapr> maybe I can catch up
10:35:10 <mishugana> shapr haha!
10:35:13 <kuribas> mishugana: there is also #haskell-beginners
10:35:36 <mishugana> kuribas Hmm... thanks for that... will keep it in mind!
10:35:54 <kuribas> mishugana: but people here are friendly to beginners too :-)
10:36:12 <metahumor> pikajude: try, in ghci: "let x = [1..] :: [Int]; :sprint x; head x; :sprint x"
10:36:12 <shapr> mishugana: learning Haskell for fun? class? work?
10:36:20 <mishugana> shapr... have got stuck at chapter 12 (monads and more.. .the last part). need a break to refresh I suppose! :D
10:36:23 <kuribas> mishugana: the worst that can happen is a lengthy explanation about cathegory theory
10:36:42 <mishugana> shapr mostly for fun.. hopefully be able to do some projects after this to solidify my understanding
10:36:47 <shapr> I was playing with https://github.com/galoisinc/reopt last night, just got it building this morning, but it won't run on itself :-(
10:37:23 <mishugana> kuribas hahaha! I have been going through Bartosz Milewski's Category Theory lectures on YouTube as well... he appears to be a good teacher
10:37:25 <sqooq> `(Hashable k, MonadState (k, b) m) => `
10:37:38 <sqooq> does the Hashable k constrain the k in the monadState too?
10:38:08 <metahumor> sqooq: Yeah
10:38:17 <sqooq> hmm
10:38:25 <shapr> mishugana: do you write code for a living?
10:38:42 <shapr> mishugana: I always get frustrated when I dig into category theory, maybe one day it'll all click.
10:38:49 <sqooq> metahumor, thanks. I'm getting a stupid error and can't figure out why. Trying to use Writer State monad transformer.
10:38:55 <mishugana> shapr yeah, taking a sabbatical from work currently (after a decade in the "industry").. thought of learning something new! What about you?
10:39:04 <cocreature> sqooq: if you should us the code and the full error we might be able to help
10:39:12 <kuribas> shapr: have you tried Milewski's book?
10:39:28 <shapr> kuribas: is that his collected blog posts? I've looked at it, but not read it.
10:39:39 <mishugana> shapr Yup... so far Bartosz' explanations make sense, but I'm sure it's going to get hairy pretty soon. I wonder why they don't offer such courses in university for CS students
10:39:43 <kuribas> shapr: yeah.  It's available in dead tree form.
10:39:43 <mishugana> or maybe they do now?
10:39:52 <shapr> I have lawvere and schanuel, but it seems really ... fluffy?
10:40:10 <mishugana> kuribas how funny you should say that! Just today I downloaded the github project and built the PDF from scratch :-)
10:40:23 <mishugana> still looking at the lectures... and the maybe tackle the book!
10:40:28 <sqooq> cocreature, http://lpaste.net/362083
10:41:03 <cocreature> sqooq: the error message is actually right here. you just need to enable FlexibleContexts
10:41:10 <sqooq> what does that do
10:41:13 <kuribas> mishugana, shapr: ordered this one: https://pothi.com/pothi/book/bartosz-milewski-category-theory-programmers
10:41:48 <cocreature> it lifts some restrictions on how constraints must be formed
10:41:50 <mishugana> kuribas: is that the same as the collection from his blog posts, or is it a fresh book?
10:42:02 <kuribas> mishugana: yeah, the same
10:42:18 <sqooq> cocreature, is that bad. Why can't I not use it.
10:42:29 <mishugana> kuribas ah, okay! yeah... would be nice to have a hardcover version no doubt!
10:43:24 <geekosaur> sqooq, standard Haskell is conservative because a more compelx type system is needed to represent those. ghc has that complex type system, other Haskell implementations might not
10:43:31 <cocreature> sqooq: it’s not bad, removing those restrictions is perfectly fine which is why that extension exists. the reason why you need is is that "MonadState (k, b) m" is not a valid constraint according to Haskell98
10:44:05 <Franciman> does anybody use jhc compiler?
10:44:17 <geekosaur> it hasn;t been maintained in a couple years
10:44:24 <Franciman> ah drat, I liked its ideas
10:44:28 <Franciman> thank you
10:44:30 <sqooq> O it's MonadState(HashMap k v, b) actually
10:44:32 <mishugana> Man, right now I can barely understand some of the discussions going on in here! :D ... hopefully should stick to it enough to be able to participate like a guru someday! haha
10:44:39 <metahumor> sqooq: are you sure you mean MonadState (k,b)?
10:44:44 <metahumor> sqooq: oh okay you noticed it, good
10:45:16 <geekosaur> Franciman, iirc the author started to add proper gc support to it, then realized the whole low level needed to be redesigned to handle it properly
10:45:51 <geekosaur> (originally it didn't do gc at all but manual allocation/deallocation behind the scenes, then Boehm-style gc as an option.)
10:46:13 <Franciman> ah I see
10:51:27 <sqooq> I'm still getting errors up the butt
10:52:00 <Tuplanolla> Is that the wrong place for errors to be, sqooq?
10:52:03 <sqooq> http://lpaste.net/362083
10:52:06 <sqooq> Tuplanolla,
10:52:06 <sqooq> yes
10:52:42 <sqooq> oops
10:53:01 <sqooq> ok now click link
10:54:40 <Tuplanolla> What's the inferred type if you remove the type signature and turn on `NoMonomorphismRestriction`?
10:56:06 <kuribas> is an IntMap a good alternative for pointers in an imperative language?
10:56:45 <kuribas> I could use STRef, but that would require all functions to use the ST-monad
10:57:27 <sqooq> Tuplanolla, I updated lpaste to show full code with signatures removed
10:57:33 <sqooq> idk what the inferred type is, I still get errors
10:57:41 <metahumor> sqooq: why not write a typesig for readBuf?
10:58:10 <sqooq> metahumor, I had one
10:58:11 <cocreature> removing type signatures is a way to get worse type errors, not a way to fix things
10:58:24 <AndreasK> kuribas: Depends on what you want to do really
10:58:26 <sqooq> readBuf ::(MonadState (H.HashMap k v, b) m) => k -> m ()
10:58:41 <kuribas> AndreasK: just refer to a structure that may change.
10:58:47 <sqooq> cocreature, yes, Tuplanolla was just curious what the inferred type would be.
10:59:19 <metahumor> kuribas: State (IntMap Value) could work
10:59:37 <kuribas> yeah
10:59:39 <Tuplanolla> It can be helpful to see the most general type of an implementation you suspect to be correct.
11:00:03 <sqooq> is it supposed to result in `m v` maybe?
11:01:46 <hyperisco> Const []  is the quadratic time way to use [a] monoid isn't it oO
11:02:18 <hyperisco> > Const [1,2,3] <*> Const [4,5,6]
11:02:21 <lambdabot>  Const [1,2,3,4,5,6]
11:02:42 <hyperisco> > Const [1,2,3] <*> Const [4,5,6] <*> Const [7,8,9] -- I mean
11:02:45 <lambdabot>  Const [1,2,3,4,5,6,7,8,9]
11:02:51 <hyperisco> because <*> associates left
11:03:56 <inkbottle> > 3
11:03:58 <lambdabot>  3
11:04:26 <inkbottle> > "été" :: String
11:04:29 <lambdabot>  "\233t\233"
11:05:06 <inkbottle> How come the above result is not "\195\169t\195\169"?
11:05:47 <inkbottle> I have the same with my ghci even though localeEncoding says UTF8
11:06:02 <inkbottle> > localEncoding
11:06:03 <Tuplanolla> The representation of `Char` is not one UTF-8 code point, inkbottle.
11:06:06 <lambdabot>  error: Variable not in scope: localEncoding
11:07:19 <geekosaur> é can be encoded in UTF8 canonically as U+00E9 (\233) or U+0065,U+0301
11:07:30 <geekosaur> NFC prefers the shorter encoding
11:07:34 <inkbottle> Tuplanolla: OK, Can you tell me more, or point me toward a relevant information?
11:07:52 <inkbottle> geekosaur: OK
11:08:19 <Tuplanolla> It's either explained in the language report or in GHC user's guide.
11:08:34 <geekosaur> those just reference the Unicode technical reports without specific citations
11:08:35 <inkbottle> Tuplanolla: Tx
11:08:59 <geekosaur> I'm not sure it even specifies normal forms
11:09:51 <inkbottle> What is NFC?
11:11:04 <geekosaur> http://unicode.org/reports/tr15/#Norm_Forms
11:11:12 <inkbottle> ok, normalization form c
11:11:15 <inkbottle> thanks
11:12:38 <metahumor> writable human language was a mistake
11:15:43 <pikajude> i concur
11:16:03 <Clint> tee-hee
11:17:20 <inkbottle> > "ν" :: String
11:17:24 <lambdabot>  "\957"
11:17:32 <inkbottle> this one is strange...
11:18:19 <geekosaur> looks sensible to me
11:18:51 <geekosaur> it's not a variant "v", it's a Greek letter that happens to superficially resemble the Latin "v" to some extent
11:19:28 <sqooq> man monad transformers are hard
11:22:44 <infinisil> sqooq: i can't agree with that, either because i don't find them hard or because i haven't seen the actual hard ones
11:23:19 <infinisil> i was actually surprised how easy to use they were once i got around to learning how they worked
11:48:29 <RusselsTeapot> hey guys, do you know any good resources on elegant haskell coding? any style guides? or maybe just a few tips to organize your code?
11:48:56 <thehappycolorpro> i'm on chp 6 of haskellbook and i am so confused
11:50:23 <RusselsTeapot> i do understand the basics of haskell at this point, but i have the feeling i am writing unnecessarily ugly code
11:50:33 <metahumor> RusselsTeapot: hlint, ghc-mod might help
11:50:38 <sqooq> infinisil, maybe I just don't know how to use them but I have so many type errors. My code worked fine when I lumped everything into State. Now I'm trying to separate the Writer part away from the actual State part and I can't get it working
11:50:45 <metahumor> thehappycolorpro: what's the chpater on?
11:51:09 <thehappycolorpro> metahumor: typeclasses ahahahaha
11:51:29 <metahumor> thehappycolorpro: are you familiar with interfaces?
11:51:47 <thehappycolorpro> metahumor: no, not at all. i'm a programming beginner
11:51:51 <metahumor> ah
11:51:55 <sqooq> RusselsTeapot, Early on I did a lot of explicit recursion which was pretty ugly and pointless. Learn to use the tools available like fold, traverse, etc. That cleans up the code a lot.
11:52:02 <thehappycolorpro> i'm going to power through it and just wait for that "AHA" moment
11:52:05 <metahumor> okay!
11:52:08 <sqooq> otherwise I have messy code myself!
11:53:24 <infinisil> sqooq: Just use stuff like (State String m, Writer String m) => m () in your functions type signatures, then use `runWriterT` and `runStateT`
11:53:38 <infinisil> to get the results
11:53:45 <RusselsTeapot> i mean, the main reason to use haskell is the un-messines, so its kinda sad that there is no section to help you learn the basics of clean haskell code in the main books
11:54:10 <geekosaur> problem is, about 90% of it comes from experience
11:54:20 <RusselsTeapot> ghc-mod looks helpfull though, thanks
11:54:30 <inkbottle> geekosaur: 957 is decimal codepoint (I meant strange because not Utf8); seems it is default ghci when input is keyboard, or pasting
11:54:45 <geekosaur> inkbottle, the haskell report defines \nnn as decimal
11:55:15 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
11:55:22 <sqooq> infinisil, it wants MonadState and MonadWriter though
11:55:29 <geekosaur> and the Show instance for String is more or less what the Report quotes
11:56:06 <ski> RusselsTeapot : perhaps <https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md> has some value
11:56:35 <geekosaur> (pedantically, showList @Char)
11:56:52 <dmwit> inkbottle: `String` is a sequence of codepoints. Encodings don't enter the picture.
11:57:01 <srid> Why are there different libraries for handling with filesystem paths?
11:57:13 <geekosaur> srid, because they're not esepcially portable
11:57:21 <dmwit> inkbottle: Now, when you want to actually *do* something with a `String` (e.g. print them, or send them over the network, or similar), *then* you have to know something about encodings.
11:57:27 <geekosaur> raw POSIX is bytestrings. OS X is UTF8. Windows is UTF16.
11:57:28 <srid> `getCurrentDirectory` is in the `directory` library, and `joinPath` is from `filepath`
11:57:42 <geekosaur> and all the differences in how they construct paths
11:57:54 <kuribas> RusselsTeapot: Just show your code, and I can give sugggestions :)
11:58:06 <infinisil> sqooq: oh right sorry yeah, MonadFoo stuff instead
11:58:21 <geekosaur> "filepath" is an attempt at dealing with this. getCurrentDirectory is more low level.
11:58:22 <inkbottle> dmwit: OK, sequence of code point; that is what I was looking for; Tnaks
11:58:24 <srid> geekosaur: assuming just UNIX, what would you recommend that I use?
11:58:36 <kuribas> RusselsTeapot: In general though, use and create combinators instead of doing low level work like in other languages.
11:58:39 <inkbottle> thanks*
11:58:53 <sqooq> infinisil, I'm down to one error. I think I got this.
11:58:58 <geekosaur> (notably, getCurrentDirectory doesn;t actually know what it is returning. filepath encodes that knowlegde, per OS.)
11:59:38 <kuribas> RusselsTeapot: also, work from the types.  Write types first (possible using typed holes).
11:59:42 <sqooq> yes, no errors. Why do I doubt it will actually work though, lmao.
11:59:51 <inkbottle> geekosaur: raw POSIX; OK
12:00:35 <RusselsTeapot> kuribas, wow, thanks a lot, :) but i have no project im comfortable sharing right now. the general tip is nice though
12:00:37 <dmwit> inkbottle: The "raw POSIX" comment was not related to your exploration of String.
12:00:54 <inkbottle> OK
12:00:58 <sqooq> holy crap it worked!
12:01:02 <sqooq> ok thanks y'all
12:01:03 <kuribas> RusselsTeapot: you don't have to be comfortable ;-)
12:01:12 <kuribas> RusselsTeapot: that'll come later
12:01:35 <infinisil> sqooq: \o/
12:01:55 <infinisil> sqooq: monad transformers aren't that hard now once you get them, right?
12:02:15 <infinisil> well i just think that's how they work and how they're "supposed to be used"
12:02:25 <Owen>   Hello -- newbie Template Haskell question: I am writing a quasiquoter for custom do-notation based on the indexed-do-notation package.  It works fine for unannotated code, but the parser doesn't support type annotations, which are often necessary for my EDSL.
12:03:48 <dmwit> inkbottle: Also relevant to you: in ghci, results are printed to the screen using their Show instance by default. The Show instance for String converts the sequence of codepoints into another sequence of ASCII-clean codepoints, which are then sent to the screen with whatever your current encoding is.
12:04:17 <Owen> Any suggestions for a better parser? Or should I try to pass in the annotations with some antiquotation method?
12:04:41 <inkbottle> dmwit: ok
12:05:49 <dmwit> inkbottle: So, if the in-memory sequence of codepoints is 2000, 60, 2000, this gets converted to the sequence of codepoints 92, 50, 48, 48, 48 (for ASCII characters \, 2, 0, 0, 0), 60, 92, 50, 48, 48, 48. Then these codepoints are encoded to a sequence of bytes (in UTF-8 this does nothing for any ASCII-clean codepoints) and sent to your terminal.
12:06:36 <inkbottle> dmwit: ok
12:07:21 <dmwit> (Sorry. "does nothing" was imprecise; "produces one byte per codepoint whose value is equal to the value of the codepoint" is more precise but probably also more confusing.)
12:14:13 <sqooq> what's the best way to abstract this: do { f; incrtime; f; incrtime; f } for any amount of cycles
12:18:07 <infinisil> :t sequence
12:18:08 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:18:14 <infinisil> sqooq: ^^
12:18:36 <ski> @type replicateM_
12:18:39 <lambdabot> Applicative m => Int -> m a -> m ()
12:18:50 <infinisil> ah
12:19:08 <thehappycolorpro> hello, how would I go about writing an 'Eq instance` for the datatype: data TisAnInteger = TisAn Integer?
12:19:18 <inkbottle> dmwit: I won't make too many assumptions on what the encoding really is ("internally", etc.), for the moment, and will rather rely of functions like encodeUtf8 $ fromString ['\2000']
12:19:30 <thehappycolorpro> i've tried instance Eq TisAnInteger where   (==) TisAn Integer = True, but i don't think that's right
12:19:47 <pikajude> is there a way to force [||] splices to only refer to names that are in scope at the definition site?
12:19:49 <ski> thehappycolorpro : use real patterns to the left of `=' in the definition
12:20:02 <ski> (hint : how many arguments does `(==)' take ?)
12:20:32 <thehappycolorpro> two?
12:20:46 <thehappycolorpro> AAAaaaaaaaaaaaaaaaa
12:21:03 <metahumor> sqooq: you might also be interested in "intersperse:
12:21:13 <Tuplanolla> :t \ n ms mr -> sequence (intersperse ms (replicate n mr)) -- I was going to suggest this, metahumor.
12:21:16 <lambdabot> Monad m => Int -> m a -> m a -> m [a]
12:21:40 <pikajude> [|nonexistent function|] shouldn't really typecheck should it
12:22:01 <pikajude> or should I use the TH name-quoting syntax and interpolate those instead
12:24:53 <pikajude> wait...it does capture the name *if* it's in scope
12:24:57 <pikajude> what a strange choice
12:25:02 <thehappycolorpro> yeah, i have no idea
12:25:17 <thehappycolorpro> the examples given previously in the book look nothing like the problem i've been given
12:26:31 <metahumor> what is the problem?
12:28:27 <ski> thehappycolorpro : you've seen `data' before, right ?
12:28:54 <thehappycolorpro> yes
12:29:43 <ski> hmm .. do you have an example `data' declaration, that you think you understood ?
12:30:39 <thehappycolorpro> data DayOfWeek = Mon | Tue | Weds | Thu | Fri | Sat | Sun
12:30:43 <thehappycolorpro> was an example in the book
12:30:52 <ski> ok
12:31:09 <ski> so e.g. `Weds' is a valid expression (and also pattern) of type `DayOfWeek'
12:31:29 <thehappycolorpro> yes yes
12:31:40 <thehappycolorpro> wait i thought Weds was a type
12:31:51 <ski> nope, it's a data constructor
12:32:09 <hyperisco> if I wanted to define lens for  a -> b  would I only be able to define a Setter for  a  and a Setter for  b  ?
12:32:12 <ski> `DayOfWeek' is a type typeconstructor, which is a type
12:32:30 <ski> `DayOfWeek' lives in the type world, e.g. to the right of `::'s
12:32:31 <hyperisco> Setter looks like fmap
12:32:37 <thehappycolorpro> ahhh
12:32:45 <ski> while `Weds' lives in the data/value world, e.g. to the right (and left) of `='
12:33:08 <thehappycolorpro> right right
12:33:15 <thehappycolorpro> just like how True and False are in Bool?
12:33:17 <ski> this `data' declaration example has all data constructors being non-functions (sometimes expressed as they all being constants)
12:33:21 <ski> yes
12:33:24 <ski> @src Bool
12:33:24 <lambdabot> data Bool = False | True deriving (Eq, Ord)
12:33:45 <infinisil> whoa
12:33:56 <ski> have you seen a `data' declaration with some data constructor(s) taking arguments ?
12:34:07 <infinisil> @src fmap
12:34:07 <lambdabot> Source not found. Wrong!  You cheating scum!
12:34:13 <infinisil> goddamnit
12:34:14 <ski> @src Maybe fmap
12:34:14 <lambdabot> fmap _ Nothing  = Nothing
12:34:14 <lambdabot> fmap f (Just a) = Just (f a)
12:34:24 <thehappycolorpro> ski: something like this? instance Eq DayOfWeek where (==) Mon Mon = True (==) Tue Tue = True
12:34:30 <ski> (`fmap' is overloaded. you have to say which version of it you want)
12:34:40 <infinisil> ski: i see
12:34:53 <ski> thehappycolorpro : that'd be how one'd make an `Eq' instance for `DayOfWeek', yes
12:35:00 <ski> (but it's not what i asked about)
12:35:08 <thehappycolorpro> D:
12:35:17 <ski> <ski> have you seen a `data' declaration with some data constructor(s) taking arguments ?
12:35:59 <thehappycolorpro> i may have in the book, but unable to recognize
12:36:36 <ski> well, if you haven't i can invent an example .. i just wanted to know if you had already seen one, which we could try to walk over more closely
12:37:06 <thehappycolorpro> yes, that would be nice
12:37:21 <ski> let's take
12:37:48 <ski>   type DayHour = Int  -- expected to be between `0' and `23', inclusive
12:37:55 <ski> do you understand this ?
12:38:08 <hyperisco> guess I just don't get it
12:38:29 <hyperisco> what is the lens way to change a return type or an argument type?
12:38:42 <thehappycolorpro> no, i don't recognize what `type` is supposed to do
12:38:48 <ski> ok
12:39:04 <ski> `type' defines a type synonym, a new name, to an already existing type
12:39:13 * infinisil prays for ski
12:39:19 <ski> in this case, the type `Int' is also known under the name `DayHour'
12:39:49 <ski> the implementation will not distinguish between `DayHour' and `Int'. basically, if you type `DayHour', the implementation will pretend you had written `Int'
12:39:51 <dstolfa> ski: speaking types, when you're done explaining, has there been a discussion about dependent types outside of just the theoretical debate about undecidability in type inference and so on, but an attempt to implement them and see how it goes?
12:40:07 <thehappycolorpro> oh i see ok
12:40:50 <infinisil> dstolfa: um, dependent haskell, and idris?
12:40:58 <simplegauss> is it totally impossible (i'm guessing it is) to write a function f :: (Eq a, Eq b) => a -> b -> Bool with f u v = u == v if a ~ b and f _ _ = False otherwise?
12:41:01 <ski> the comment after the declaration in this case indicates that when we write `DayHour', which to the implementation means `Int', we *intend* that only integers between `0' and `23' are to be used. this is not something the implementation will check, so it's something that one could goof up
12:41:13 <dstolfa> infinisil: i know about idris, didn't know about dependent haskell
12:41:14 <thehappycolorpro> yes yes
12:41:21 <dstolfa> infinisil: thanks
12:41:44 <ski> (and this may be an argument for why one ought to *not* make `DayHour' a type synonym, instead defining a *new* type `DayHour', using `data' (or `newtype'))
12:41:59 <thehappycolorpro> ah yes yes
12:42:15 <ski> but let's ignore that. for the moment `DayHour' is an alias of `Int', with the understanding that we intend to only see values between `0' and `23'
12:42:22 <infinisil> dstolfa: not sure why you're asking if you know the answer already :P (yes there is an attempt and it succeeded, it's idris)
12:42:22 <geekosaur> simplegauss, there may be some horrible hacks, but they would be fragile at best
12:42:54 <dstolfa> infinisil: i thought idris wasn't really haskell, just supported some of the syntax. i know it's written in haskell, but it's essentially a different language is it not?
12:42:59 <infinisil> dstolfa: idris dependent typing is much much nicer than haskell's though (for now), since types themselves are first-class
12:43:21 <ski> thehappycolorpro : btw, since `DayHour' *is* `Int', from the perspective of the implementation, this means that one *can't* make an instance `instance Eq DayHour where ...', because there already is an `Eq Int' instance (and you can't have more than one instance for the same type class and type)
12:43:24 <infinisil> dstolfa: yeah it's a totally new language
12:43:46 <infinisil> syntacticly similar to haskell
12:43:49 <thehappycolorpro> yes yes
12:44:06 <ski> thehappycolorpro : anyway, let's continue with the example
12:44:18 <dstolfa> infinisil: and AFAIK, it has no runtime, isn't optimised and so on because things are implemented inside the language itself to deal with a proofs in the compiler (and because it's well, academic :))
12:44:27 <dstolfa> infinisil: but thanks about dependent haskell, i didn't know about htat
12:44:29 <dstolfa> that*
12:45:09 <infinisil> dstolfa: idris can indeed run, it even has javascript codegen support
12:45:12 <ski>   data TimeOfWeek = TOW DayOfWeek DayHour
12:45:34 <dstolfa> infinisil: it can run, it just doesn't have a runtime last i checked
12:45:36 <ski> thehappycolorpro : can you say how much you understand of this `data' declaration ?
12:45:48 <infinisil> dstolfa: hmm, what does a runtime entail?
12:46:28 <ski> e.g. what kind of thing is `TimeOfWeek' ?
12:46:47 <thehappycolorpro> ski: `TimeOfWeek` is a datatype right
12:47:04 <thehappycolorpro> i don't know what it means without the ||| stuff
12:47:08 <infinisil> dstolfa: hmm, maybe it would be better to discuss idris in #idris if you wish
12:47:36 <ski> thehappycolorpro : well, without a `|' to separate alternatives, it means there's just one alternative
12:47:46 <dstolfa> infinisil: well, for example, a runtime might provide you with operating system specifics, such as IO, a threading implementation and so on. suppose you have your language and one of the functions is spawn => f x y, where spawn asynchronously dispatches a task. the compiler would then identify that that's what the programmer wanted and may map it to a runtime that implements spawn in a runtime-specific
12:47:52 <dstolfa> way, it can keep a thread pool, deal with green threads or do it via pthread or something
12:48:00 <thehappycolorpro> mmmmm
12:48:20 <thehappycolorpro> so does it mean that it creates a function `TOW` that takes in two arguments
12:48:26 <ski> `TimeOfWeek' is a data type, yes. more technically, `TimeOfWeek' is a type constructor (like `DayOfWeek',`Bool',`Int',`Maybe',`IO')
12:48:34 <ski> thehappycolorpro : yes
12:48:53 <srid> Should I write this function myself, or does it already exist?
12:48:53 <srid> `Either String (Maybe a) -> String -> Either String a`
12:49:10 <ski> `TOW' is a *data* constructor (just like `Weds',`False',`Nothing',`Just',...)
12:49:13 <srid> (basically propagates the error from the inner Maybe)
12:50:00 <ski> in this case, because we have specified types after `TOW', that means that `TOW' will be a function / will take arguments (unlike `Weds',`False',`Nothing')
12:50:24 <ski> thehappycolorpro : now, you already know that `DayOfWeek' and `DayHour' are .. what ?
12:50:43 <thehappycolorpro> types?
12:50:48 <thehappycolorpro> type constructors?!?!?
12:50:52 <thehappycolorpro> I DONT KNOWWWw
12:52:32 <metahumor> srid: what happens if you pass a `Left "left"` to the function?
12:52:42 <infinisil> dstolfa: hmm, i'll ask in #idris regarding it having a runtime
12:53:04 <srid> metahumor: return it as is
12:53:16 <metahumor> srid: ah, but then the types wouldn't match
12:53:20 <srid> The String argument is returned as `Left String` if we have Nothing
12:53:56 <metahumor> srid: no, I'm asking about passing a `Left "left"` as the (Either String (Maybe a))
12:54:00 <thehappycolorpro> ok yes, they are types
12:54:24 <metahumor> srid: you have 3 cases: Left str, Right Nothing, Right a
12:54:27 <ski> thehappycolorpro : yea, types
12:54:49 <srid> +f :: String -> Either String (Maybe a) -> Either String a
12:54:49 <srid> +f err = \case
12:54:49 <srid> +  (Left e) -> Left e
12:54:49 <srid> +  (Right Nothing) -> Left err
12:54:49 <srid> +  (Right (Just a)) -> Right a
12:54:54 <srid> metahumor: ^^ that works
12:55:09 <ski> `DayOfWeek' is also a type constructor, but `DayHour' isn't, it's a type synonym .. the terminology here is nice to know, but isn't that important at this point
12:55:23 <ski> the important part is that both are types
12:55:40 <srid> I am just wondering if there is a haskell 'pattern' I can use here without having to implement the above functin.
12:55:45 <thehappycolorpro> datatypes and types are the same thing, right
12:55:45 <thehappycolorpro> ?
12:56:14 <ski> well, i think, usually by data type, we mean a type defined using `data' (or `newtype')
12:56:37 <ski> (which does not include function types)
12:56:44 <thehappycolorpro> ah
12:57:30 <ski> but i don't think we often draw that hard a line between them. functions are considered values, and i don't think it's that uncommon to regard them as some kind of data
12:58:01 <ski> anyway, consider now `TOW DayOfWeek DayHour'
12:58:03 <metahumor> srid: maybe some magic using bifunctors
12:58:06 <ski> is this a valid expression ?
12:58:23 <ski> what do you think ?
12:58:33 <infinisil> dstolfa: Alright, Idris does definitely have a runtime: https://github.com/idris-lang/Idris-dev/tree/master/rts Handles garbage collection for example
12:58:39 <thehappycolorpro> yes, i would think
12:58:50 <ski> ok. sorry the answer is no
12:58:54 <thehappycolorpro> D:
12:59:05 <metahumor> srid: there is also "leftToMaybe :: Either a b -> Maybe a" in either
12:59:08 <ski> the answer is no, because we're mixing value-level and type-level things
12:59:23 <thehappycolorpro> ah right
12:59:25 <ski> `TOW' is a data constructor (is a value, is a function) lives on the value level
12:59:41 <metahumor> srid: and a "maybeToLeft :: b -> Maybe a -> Either a b"
12:59:42 <ski> while `DayOfWeek' and `DayHour' are types, lives on the type level
12:59:49 <metahumor> srid: so some combination of those and "join"
12:59:55 <thehappycolorpro> yes yes
13:00:12 <ski> thehappycolorpro : the point is that the syntax for a data constructor with arguments, in a `data' declaration is a *template* of sorts
13:00:57 <ventonegro> dstolfa: Of course Idris has a runtime, although it's still a simple one
13:01:00 <thehappycolorpro> uh huh
13:01:18 <thehappycolorpro> so it's like the same as saying Int + Int isn't an expression
13:01:30 <ski> thehappycolorpro : so, in `data TimeOfWeek = TOW DayOfWeek DayHour', the `TOW DayOfWeek DayHour' part means that `TOW dow dh' will be a value of type `TimeOfWeek', if `dow' is a value of type `DayOfWeek' and `dh' is a value of type `DayHour' (iow of type `Int')
13:01:36 <ski> thehappycolorpro : yep
13:02:39 <thehappycolorpro> ook
13:02:59 <ski> so, the notation used here in `data' might be a little confusing at first, since the notation here mixes the type and the value levels. it's just a compact notation for specifying what types the arguments of data constructors should be (and it's meant to resemble the BNF notation for language grammars, if you've heard about that. otherwise ignore)
13:03:40 <ski> and, of course we don't have to write variables `dow' and `dh', we can write any (value) expressions (but then we may need to bracket them), as long as they are of the correct type
13:03:55 <thehappycolorpro> so for instance, type Int will have one value like 2 or 3, but "TimeOfWeek" will have two values? one for the day and one for the hour?
13:04:16 <ski> (i said "(value) expressions" because there are also expressions on the type level, type expressions. like e.g. `Int',`Int -> Int',`[(Bool,Int)]',&c.)
13:04:44 <ski> a value of type `TimeOfWeek' will contain two values, one for the day and one for the hour, yes
13:05:06 <thehappycolorpro> HMM ok please continue
13:05:09 <ski> now, can you figure out how the `Eq' instance for `TimeOfWeek' should look like ?
13:05:39 <thehappycolorpro> ok i will try, one minute please
13:06:16 <recursion-ninja> Where do the splices go when I run `stack build --ghc-options="-ddump-splices"`
13:07:58 <AndreasK> recursion-ninja: Stack logs on .stack-work I assume
13:09:14 <thehappycolorpro> ski: I can guess, but i don't know Aaaaaaaahhhh
13:09:45 <dstolfa> ventonegro: ah, when i looked it didn't really have one. it had some builtins, but not really a runtime per se
13:09:54 <recursion-ninja> AndreasK: There are only .log files in .stack-works/logs
13:09:56 <dstolfa> but granted, i looked at it a very long time ago
13:09:58 <thehappycolorpro> instance Eq TimeOfWeek where TOW == TOW = True
13:10:00 <ski> thehappycolorpro : no worry. try if you will, and we will walk over it
13:10:08 <thehappycolorpro> i think that should go in there somewhere, but i'm missing something
13:10:17 <thehappycolorpro> or i'm completely off the mark
13:10:39 <ski> yes. the arguments/operands of `==' here should be of type `TimeOfWeek', because that's the type we're declaring an `Eq' instance for
13:11:01 <thehappycolorpro> woohoo
13:11:11 <ski> (and `(==)' takes as arguments values of the type that the `Eq' instance declaring that `(==)' definition is for)
13:11:19 <ski> what type does `TOW' have ?
13:11:36 <recursion-ninja> AndreasK: Thanks for the tip I found it
13:12:10 <ski> ("yes" as in "yes, you're missing something, let's attempt to find out what")
13:12:41 <thehappycolorpro> erhm
13:12:42 <thehappycolorpro> HMM
13:12:43 <dstolfa> infinisil: yep, that is a runtime
13:12:50 <recursion-ninja> AndreasK: It was in .stack-works/dist/$PLATFORM/$CABAL/build/path/to/module.dump-splices
13:12:50 <dstolfa> my bad :)
13:12:58 <thehappycolorpro> `TOW` has the type of `TimeOfWeek`
13:13:04 <thehappycolorpro> pls dont hurt me if i'm wrong
13:13:06 <geekosaur> almost
13:13:08 <ski> not quite
13:13:26 <ski> `TOW' is a data constructor for the type (constructor) `TimeOfWeek', that much is ok
13:13:38 <AndreasK> recursion-ninja: Seems stack passes -ddump-to-file by default then. Makes sense though
13:13:45 * hyperisco went back to writing map functions
13:14:02 <ski> thehappycolorpro : if `b' is of type `Bool', what is the type of `not b' ?
13:14:22 <thehappycolorpro> Bool
13:14:25 <ski> yep
13:14:39 <ski> now, what type does that imply `not' itself has ?
13:14:48 <thehappycolorpro> Eq?
13:14:57 <_d0t> ohai. Can anyone give an example how to use Forall from constraints?
13:15:00 <geekosaur> AndreasK, yes, it collects various things from the build for itself
13:15:02 <ski> `not' is a function, so its type should be some function type
13:15:18 <ski> (function types are written using the `->' symbol)
13:15:23 <thehappycolorpro> ohhhh
13:15:27 <geekosaur> and there-s no per-type version of -ddump-to-file
13:15:35 <ski> (remember that functions are values too)
13:15:38 <geekosaur> per-dump-type version
13:15:50 <thehappycolorpro> OK `not` has (a -> Bool)
13:16:01 <ski> better, but not quite there
13:16:05 <thehappycolorpro> nOOOOOOOOOOo
13:16:13 <ski> no worry, we'll get it
13:16:54 <thehappycolorpro> OK `not` has (Bool => a -> Bool)???
13:17:00 <thehappycolorpro> or Bool -> Bool
13:17:04 <thehappycolorpro> because b is Bool type
13:17:14 <ski> yep, `Bool -> Bool' is the type of `not'
13:17:18 <ski> consider the function `digitToInt'. if you pass it a character, that is a digit, it will compute the corresponding integer for you
13:17:24 <ski> > digitToInt '0'
13:17:27 <lambdabot>  0
13:17:28 <ski> > digitToInt '7'
13:17:31 <lambdabot>  7
13:17:32 <ski> > digitToInt 'X'
13:17:34 <lambdabot>  *Exception: Char.digitToInt: not a digit 'X'
13:17:47 <thehappycolorpro> Ah
13:17:49 <dstolfa> > digitToInt '123123213'
13:17:53 <lambdabot>  <hint>:1:13: error: parse error on input ‘123123213’
13:17:55 <ski> the argument type of `digitToInt' is `Char'. the result type is `Int'
13:18:07 <ski> therefore, the type of `digitToInt' itself is `Char -> Int'
13:18:34 <ski> similarly, since `not' both takes a `Bool' as argument, and returns a `Bool', the type of `not' is `Bool -> Bool'
13:18:46 <thehappycolorpro> yes yessss
13:19:17 <ski> now, consider `(&&)'. if `b0' and `b1' are `Bool'eans, then `b0 && b1' is the conjunction (the "AND") of them, which is also a `Bool'
13:19:36 <thehappycolorpro> uh huh
13:19:45 <ski> btw, one can also write `b0 && b1' as `(&&) b0 b1', using ordinary prefix function application notation
13:20:13 <ski> now, the type of `(&&)' is `Bool -> Bool -> Bool'. the first two `Bool's are the argument types (left and right), the final `Bool' is the result type
13:20:21 <thehappycolorpro> yes yes
13:20:57 <ski> (to be pedantic, the type of `(&&)' is really `Bool -> (Bool -> Bool)', so it's a function that takes a `Bool' as input, and returns a *function*, that takes another `Bool' as input, and returns a `Bool')
13:21:55 <ski> (we say that `(&&)' is written in "curried style". for short we say that `(&&)' is a function that takes two arguments, even though strictly speaking all functions in Haskell take exactly one argument)
13:21:57 <thehappycolorpro> oh wat
13:22:31 <ski> one could think of it as "eating one argument at a time"
13:22:51 <thehappycolorpro> yes i think i understand
13:22:55 <ski> this also means that one can pass one argument, and then, at a later time, pass another
13:22:58 <ski> consider
13:23:20 <ski> > [(+) (2*3) 5, (+) (2*3) 5]
13:23:23 <lambdabot>  [11,11]
13:23:27 <ski> er, actually
13:23:29 <ski> > [(+) (2*3) 5, (+) (2*3) 7]
13:23:32 <lambdabot>  [11,13]
13:23:33 <ski> vs.
13:23:57 <ski> > let addSix = (+) (2*3) in [addSix 5, addSix 7]
13:24:00 <lambdabot>  [11,13]
13:24:46 <ski> here, we passed one argument to `(+)', and got back the function that still waits for the second argument. instead of using this function directly, we *named* it, so that we can then use it several times (here two times)
13:25:01 <ski> (this also means that that `2*3' will only be computed once, rather than twice)
13:25:21 <thehappycolorpro> does it make it faster?
13:25:46 <ski> note that `(+) (2*3) 5' is parsed as `((+) (2*3)) 5', iow first we pass one argument, then we get back another function, which we pass the other argument
13:26:05 <ski> thehappycolorpro : in general, it can, yes
13:26:42 <thehappycolorpro> yes yes, i understand
13:26:43 <[exa]> thehappycolorpro: it certainly doesn't multiply the numbers two times (but not sure if it makes a speed difference)
13:27:14 <ski> anyway, what i'm saying about curried style here isn't perhaps that important to know in detail at the moment .. but it may be nice to have *some* feel for why types of functions accepting multiple arguments are typically written using multiple `->'s
13:27:40 <thehappycolorpro> ah yes, i went through that headache in the last chapter last thursday
13:27:56 <thehappycolorpro> but i got a better understanding of it and was able to finish all the exercises
13:29:33 <thehappycolorpro> OOOOOOOOOOOOOo
13:29:38 <ski> (also it's nice to know that "in Haskell, multiple argument functions are curried" is nonsense. there are no "multiple argument functions" in Haskell. one can *encode* "multiple argument functions" however. *one* way of doing so is curried style, which i described above. *another* way is "tupled style", where we pack all the "separate arguments" into a single, compound argument. so, if we define `tupledAdd', we could call it like `tupledAdd (2*3,5)')
13:30:03 <ski> (hrm, cut off near : ".., where we pack all the \"separate arguments\" into a single, compound argument. so, if we define `tupledAdd', we could call it like `tupledAdd (2*3,5)')")
13:30:21 <[exa]> btw, is there a shortcut/name for (.).(.)? (like (.) but for two arguments in the first function in chain)
13:30:30 <Tuplanolla> It didn't actually cut off, ski. Your client might be busted.
13:30:40 <ski> [exa] : i've used `(.:)'
13:31:02 <thehappycolorpro> i seee
13:31:03 <ski> Tuplanolla : well, i'm just guessing, based on it exceeding three lines here
13:31:20 <thehappycolorpro> i think i can solve the Eq instance
13:31:20 <ski> (i don't see the cut-off, if any, on my side)
13:31:34 <ski> thehappycolorpro : so, what's the type of `TOW' ?
13:32:07 <[exa]> ski: looks like that, thanks!
13:32:59 <thehappycolorpro> (DayOfWeek -> TimeOfDay -> something)?!??
13:33:19 <ski> [exa] : the idea is (a) the number of dots is the same; (b) the number of "passed along arguments" is the number of characters in the operator symbol
13:33:35 <ski> [exa] : similarly `(.::) = (.) . (.) . (.)'
13:33:58 <[exa]> does it compose?
13:34:33 <thehappycolorpro> ski: i will return in 5-10 minutes, thank you for the help so far :D
13:34:36 <[exa]> oic it does
13:34:39 <[exa]> ski: thanks again :]
13:34:57 <metahumor> :t (.:)
13:34:59 <lambdabot> error:
13:35:00 <lambdabot>     • Variable not in scope: .:
13:35:00 <lambdabot>     • Perhaps you meant one of these:
13:35:20 <metahumor> :t let (.:) = (.) . (.) in (.:) .: (.:)
13:35:20 <ski> thehappycolorpro : `DayOfWeek -> TimeOfDay -> something' -- you're on the right track, mostly
13:35:21 <lambdabot> (b1 -> c) -> (b2 -> a1 -> b1) -> (a2 -> a3 -> b2) -> a2 -> a3 -> a1 -> c
13:36:50 <[exa]> in the sense (f :: b->a) .: (g ::c->b) .: (h :: e->d->c)
13:37:14 <ski> iirc, i usually declare these right-associative
13:37:32 <ski> (mainly because `.' already is)
13:37:42 <[exa]> yeah, so the 2 args are correctly forwarded
13:39:09 <ski> you could also have `(f . g) .: h', and one could argue that `f . g .: h' should mean that
13:39:46 <[exa]> so maybe declaring it with infixr 8 would be right
13:39:56 <ski> (but i'm not sure the parser will be happy if you mix a left-associative and a right-associative operation in a sequence, without shielding brackets. it may depend on in which order they come)
13:40:51 <[exa]> (which looks like the case in Data.Composition
13:42:01 <thehappycolorpro> OK hello
13:43:00 <ski> re thehappycolorpro
13:43:09 <thehappycolorpro> yes yes
13:43:53 <thehappycolorpro> i think the funciton of TOW should be (DayOfWeek -> HourOfDay -> Num => String)
13:43:56 <thehappycolorpro> or something like that right
13:44:50 <ski> what is the return type of `TOW' ?
13:45:19 <thehappycolorpro> i don't know, my best guess was a string that was made with numbers
13:45:32 <thehappycolorpro> cuz there are two different sets of numbers
13:45:46 <thehappycolorpro> wait that makes no sense
13:45:49 <thehappycolorpro> AAAAAAAAAAAAAAAAAAAAAAaaa
13:45:53 <ski> (btw, i defined `DayHour', not `HourOfDay', but then i realized later that it might have been more consistent to name it `HourOfDay'. so please continue referring to it under that name, if you prefer)
13:46:09 <thehappycolorpro> oh yeah, i forgot the name haha
13:46:15 <ski> <thehappycolorpro> `TOW` has the type of `TimeOfWeek`
13:46:17 <ski> <ski> `TOW' is a data constructor for the type (constructor) `TimeOfWeek', that much is ok
13:46:29 <ski> this means that the return type of `TOW' is `TimeOfWeek'
13:46:36 <thehappycolorpro> ohhhhhhhhhhhhhh
13:46:55 <thehappycolorpro> yeah that makes sense
13:47:16 <ski> (`False' is a data constructor for the type constructor `Bool'. so its "return type" is `Bool'. but there's no arguments here, so the type of `False' is simply `Bool')
13:47:19 <ski> @src Bool
13:47:19 <lambdabot> data Bool = False | True deriving (Eq, Ord)
13:47:39 <ski> so .. what is the type of `TOW' ?
13:47:40 <thehappycolorpro> yes yes yes
13:48:21 <thehappycolorpro> (DayOfWeek -> DayHour -> TimeOfWeek)
13:48:38 <ski> right
13:48:44 <ski> <thehappycolorpro> instance Eq TimeOfWeek where TOW == TOW = True
13:48:49 <ski> <thehappycolorpro> i think that should go in there somewhere, but i'm missing something
13:48:54 <ski> <ski> yes. the arguments/operands of `==' here should be of type `TimeOfWeek', because that's the type we're declaring an `Eq' instance for
13:48:58 <ski> <ski> ("yes" as in "yes, you're missing something, let's attempt to find out what")
13:49:03 <ski> <ski> (and `(==)' takes as arguments values of the type that the `Eq' instance declaring that `(==)' definition is for)
13:49:06 <ski> <ski> what type does `TOW' have ?
13:49:10 <ski> (which you just answered)
13:49:21 <thehappycolorpro> TimeOfWeek?
13:49:40 <ski> <ski> so .. what is the type of `TOW' ?
13:49:42 <ski> <thehappycolorpro> (DayOfWeek -> DayHour -> TimeOfWeek)
13:49:53 <ski> (sorry to have to remind you of what you said a mere two minutes ago)
13:49:55 <thehappycolorpro> EGAD
13:50:26 <thehappycolorpro> yes yes that is what i meant e_e
13:50:29 <ski> so .. can you see something definitely wrong with that `instance' declaration, now ?
13:50:29 <thehappycolorpro> D:
13:51:26 <thehappycolorpro> first can you tell me in yourown words what `instance` is supposed to do?
13:51:42 <thehappycolorpro> the book was either unclear or hard to read
13:51:50 <thehappycolorpro> or i read it poorly
13:53:03 <dmwit> `instance Foo Bar where ...` says: there are operations associated with the `Bar` type that fit the "shape" defined by the `Foo` class. Here they are.
13:54:11 <thehappycolorpro> it should be instance Eq TOW where TOW == TOW
13:54:39 <ski> `(==)' (and `(/=)') are overloaded operations. by giving an `Eq' instance for a type, we're telling Haskell how `(==)' should be defined for values of this type
13:55:25 <ski> thehappycolorpro : what are the argument( pattern)s of `==' in
13:55:26 <ski> <thehappycolorpro> instance Eq TimeOfWeek where TOW == TOW = True
13:55:27 <ski> ?
13:55:50 <ski> (not a trick question)
13:56:07 <thehappycolorpro> err
13:56:09 <thehappycolorpro> TOW and TOW
13:56:24 <ski> yep
13:56:34 <ski> and, keeping in mind
13:56:36 <ski> <ski> yes. the arguments/operands of `==' here should be of type `TimeOfWeek', because that's the type we're declaring an `Eq' instance for
13:56:50 <ski> what are the types of these arguments ?
13:56:59 <thehappycolorpro> oh AHHHHHHHHHHHHHHHHHHHHHHHHHH
13:57:06 <Welkin> should rename Eq to Monkey
13:57:10 <thehappycolorpro> do i have any hope T_T
13:57:30 <ski> much of programming is about keeping track of details. you'll get better at it
13:57:47 <thehappycolorpro> ok instance Eq TimeOfWeek where TimeOfWeek == TimeOfWeek = True
13:58:01 <thehappycolorpro> is that it
13:58:05 <ski> what is the type of `TimeOfWeek' ?
13:58:25 <thehappycolorpro> TimeOfWeek
13:58:26 <Welkin> and feeding your monkey
13:58:32 <Welkin> don't forget to do that
13:59:04 <ski> (also, you didn't answer my question about the type of the arguments of `==' in the `instance' declaration just before the one you just suggested)
13:59:27 <ski> sorry, the type of `TimeOfWeek' is not `TimeOfWeek'
13:59:39 <ski> in fact, "what is the type of `TimeOfWeek' ?" *was* a trick question
13:59:55 <thehappycolorpro> wOT:!?
13:59:55 <ski> `TimeOfWeek' is not a value (expression). it doesn't have a type
14:00:09 <ski> `TimeOfWeek' is a type (constructor)
14:00:44 <ski> <ski> [...] we're mixing value-level and type-level things
14:01:16 <thehappycolorpro> uhh is it like
14:01:16 <ski> the type of `False' is `Bool'. the type of `Bool' is not `Bool'. `Bool' isn't a value
14:01:30 <thehappycolorpro> ahhhhhhhhhhhhhhhh
14:01:42 <thehappycolorpro> Bool is a type, but it has no type
14:01:42 <ski> `TimeOfWeek == TimeOfWeek' is nonsense, since "we're mixing value-level and type-level things"
14:01:54 <ski> thehappycolorpro : *nod*
14:02:20 <ski> (note that `==' is a value-level thing)
14:02:25 <thehappycolorpro> OOOOOOOOOK
14:02:36 <ski> your earlier attempt was closer
14:02:44 <thehappycolorpro> (TOW DayOfWeek HourOfWeek)
14:02:47 <thehappycolorpro> is a value
14:02:55 <thehappycolorpro> of type `TimeOfWeek`
14:03:11 <dmwit> What is the type of DayOfWeek?
14:03:26 <thehappycolorpro> TimeOfWeek
14:03:36 <thehappycolorpro> WAIT
14:03:38 <thehappycolorpro> NOOOOOOOOO
14:04:14 <thehappycolorpro> DayOfWeek is a type
14:04:17 <ski> yep
14:04:23 <dmwit> right, another trick question =)
14:04:47 <thehappycolorpro> is this stuff in other programming languages
14:04:52 <dmwit> Okay, so `TOW DayOfWeek HourOfWeek` isn't right.
14:04:55 <dmwit> thehappycolorpro: Definitely yes.
14:04:59 <thehappycolorpro> ah
14:05:21 <dmwit> thehappycolorpro: e.g. in C, 3 is an int. But int isn't something that itself has a type.
14:05:26 <ski> <ski> thehappycolorpro : so, in `data TimeOfWeek = TOW DayOfWeek DayHour', the `TOW DayOfWeek DayHour' part means that `TOW dow dh' will be a value of type `TimeOfWeek', if `dow' is a value of type `DayOfWeek' and `dh' is a value of type `DayHour' (iow of type `Int')
14:05:42 <dmwit> (Or: what other languages are you familiar with? I can try to cater my examples better if I know.)
14:05:46 <ski> <ski> so, the notation used here in `data' might be a little confusing at first, since the notation here mixes the type and the value levels. it's just a compact notation for specifying what types the arguments of data constructors should be (and it's meant to resemble the BNF notation for language grammars, if you've heard about that. otherwise ignore)
14:05:56 <ski> <ski> and, of course we don't have to write variables `dow' and `dh', we can write any (value) expressions (but then we may need to bracket them), as long as they are of the correct type
14:05:57 <thehappycolorpro> dmwit: haskell is my first language
14:06:21 <dmwit> Okay. Then suffice it to say that yes, many languages distinguish between value-level and type-level termrs.
14:07:06 <Welkin> unless the language doesn't have a type system
14:07:07 <ski> thehappycolorpro : so, the mixing in `TOW DayOfWeek DayHour' is something that only appears inside a `data' declaration itself
14:07:35 <ski> thehappycolorpro : this means that you should not write `TOW DayOfWeek DayHour' in a definition of `(==)' (in an `instance' declaration, here)
14:08:34 <thehappycolorpro> i was thinking like
14:09:39 <thehappycolorpro> instance Eq TimeOfWeek where (TOW dow1 dh1) == (TOW dow2 dh2) = True
14:09:48 <thehappycolorpro> but for the `True` part
14:09:49 <ski> now we're getting somewhere :)
14:10:17 <thehappycolorpro> you put dow1 == dow 2 && dh1 == dh2!?!?!?!
14:10:41 <thehappycolorpro> so they both have to return `True` for it to be True?!?!?!1
14:10:42 <ski> you've given patterns/"shapes" for how the two arguments of `==' will look like. now you need to figure out how to compute the desired answer, in terms of that
14:10:43 <thehappycolorpro> AAAAAAAAAAAAAAAAAA
14:10:52 <ski> yep, that works :)
14:11:01 <ski> now, a syntactical matter
14:11:06 <ski> you *can* define it like
14:11:21 * dmwit offers thehappycolorpro a high five
14:11:26 <ski>   (==) (TOW dow1 dh1) (TOW dow2 dh2) = ..dow1..dh1..dow2..dh2..
14:11:56 <ski> and in this case, the brackets around the arguments are required (otherwise it looks like you're passing six separate arguments to `(==)')
14:12:18 <ski> but, if you define `==' infix, like you did above, then the brackets wrapping the arguments aren't required
14:12:23 <ski> that can be nice to know
14:12:23 <thehappycolorpro> WOOHOOOOOOO
14:12:26 <thehappycolorpro> ah
14:12:36 <thehappycolorpro> which one should i use?
14:12:45 <dmwit> aesthetic choice
14:12:47 <ski> whichever you prefer, find most readable
14:12:53 <dmwit> whichever makes you feel fuzziest inside
14:13:07 * ski usually goes for minimum amount of allowed brackets, unless there's a specific reason not to
14:13:23 <ski> @src (++)
14:13:23 <lambdabot> []     ++ ys = ys
14:13:23 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:13:23 <lambdabot> -- OR
14:13:23 <lambdabot> xs ++ ys = foldr (:) ys xs
14:14:12 <ski> in this case, the brackets wrapping the pattern `x:xs' are also required, since, because of the precedence of `:', otherwise `x:xs ++ ys' would be interpreted as `x:(xs ++ ys)', which isn't what we want there
14:15:08 <thehappycolorpro> aye i have no idea what  `:` and `foldr` are
14:15:12 <ski> (but this issue only occurs because `:' is an infix data constructor, that can "compete" with `++' for who wins the "tug-of-war" over the poor `xs' inbetwixt them)
14:15:20 <thehappycolorpro> but i trust that what you say will make sense to me much later
14:15:21 <ski> ok, never mind that, for now, then
14:15:23 <dmwit> (I suppose one could imagine ignoring precedence in the definition of an infix function, since it is syntactically clear which part is the infix function. But then there would be a weird mismatch between how you define the function and how you were allowed to call it.)
14:16:01 <dmwit> (Precedence of constructors would still matter, though.)
14:16:10 <thehappycolorpro> OK i think i understand enough to finish the practice exercises now
14:16:17 <thehappycolorpro> THANK YOU VERY MUCH
14:16:20 <ski> (dmwit : yes, and i don't like such mismatches. e.g. if you import a class and its methods qualified, then you're not allowed to qualify the method names to the left of `=' in the `instance' declaration ..)
14:17:13 <dmwit> (I agree. I think the current choice for brackets in infix function definitions is correct, and agree that the qualification issue is annoying.)
14:17:34 <ski> thehappycolorpro : now, don't forget to also include the case in the definition of `(==)' for the `Eq TisAnInteger' instance, where you return `False')
14:18:07 <ski> (i also don't really like the type application syntax much, for this reason)
14:18:44 <thehappycolorpro> ski: yes yes, something about using `_`
14:18:48 <ski> thehappycolorpro : hrm. actually, ignore that, i was thinking of `Eq DayOfWeek'
14:19:00 <thehappycolorpro> jk
14:20:11 <dmwit> ski: Yes, I was trying to write a big lambda for the result of a case statement and it was quite frustrating. (I don't remember why, or how I ended up getting where I wanted to go.)
14:20:41 <Welkin> case expression
14:20:56 * dmwit nods
14:21:12 <ski> (one ought to be able to write `id @a (x :: a) = x :: a' with the current syntax choice, but this clashes ..)
14:42:45 <nshepperd1> That's an intriguing alternative to ScopedTypeVariables
14:43:45 <ski> `PatternSignatures' ?
14:51:43 <thehappycolorpro> err, what is the difference between type and typeclass
14:53:41 <ski> `Eq' is the "class" (/ collection) of all the types that support equality checking
14:54:05 <ski> you can't have a value of type `Eq', that doesn't make sense. you can have a value of a type which is an instance of `Eq'
14:54:37 <thehappycolorpro> ah, so EVERY `instance` thing is followed by a typeclass?
14:54:51 <ski> in type signatures, type class constraints (written like `Eq Int' or `Eq a', for a type variable `a') go to the left of `=>'
14:55:10 <ski> yep, a type class, and then the particular type in question that is being declared as an instance of the type class
14:55:19 <ski> @type sort
14:55:21 <lambdabot> Ord a => [a] -> [a]
14:55:51 <thehappycolorpro> ahhhh thank you
14:55:53 <ski> this says that `sort' accepts a list of `a's, and returns a list of `a's, as long as `a' is an instance of `Ord' (iow supports ordering comparisions)
14:56:02 <thehappycolorpro> it's gonna take me the rest of this week to get thourhg this one chapter T-T
14:56:17 <ski> so, e.g. one possible type of `sort' is `[Int] -> [Int]', because `Int' is an instance of `Ord'
14:56:37 <ski> (`sort' has many types (infinitely many), its a polymorphic operation)
14:56:53 <ski> thehappycolorpro : take as long as you need
14:57:43 <thehappycolorpro> hmmm how do i write it so that i can put two or more typeclass restrictions in a type signature
14:57:46 <ski> thehappycolorpro : see <https://www.norvig.com/21-days.html>
14:58:09 <ski> thehappycolorpro : bracket them, placing a comman inbetween
14:58:18 <ski> s/comman/comma/
14:59:48 <thehappycolorpro> ah thank you, it works
15:00:00 <mud> (Nume a, Ord a, Enum b) => stuff stuff, more stuff
15:08:03 <Welkin> Numa Numa?
15:09:14 * ski . o O ( Numa Pompilius )
15:10:14 <mud> I sure can type xD
15:21:37 <sqooq> idris
15:21:42 <sqooq> should i learn idris
15:21:47 <sqooq> is it still in development
15:22:20 <jle`> it depends on what your goal is
15:22:29 <dmj`> what jle` said
15:22:50 <jle`> it's officially released, currently version 1.2
15:23:01 <wzy8L-B2[m]> Idris has strict evaluation by default right?
15:23:07 <dmj`> wzy8L-B2[m]: yea
15:23:11 <Tuplanolla> I've also been wondering whether I should look into Idris or Agda next if I basically want Haskell with better metaprogramming.
15:23:35 <mud> Idris is more haskelly
15:24:01 <jle`> yeah, idris feels like haskell designed with dependent types from the bottom
15:24:32 <jle`> *the ground up
15:28:25 <Tuplanolla> I tried to find out more about metaprogramming in Idris, but there were only articles about elaborator reflection.
15:29:27 <jle`> oh sorry
15:29:28 <mud> Oh you actually mean metaprogramming, not just fancy type system stuff. Hmm, I'm not really sure.
15:29:31 <jle`> i didn't see the last word in what you wrote
15:29:41 <jle`> heh yeah, metaprogramming, definitely different, sorry :)
15:33:30 <simplegauss> suppose i have some collection of categories A_n and another category B, along with functors F_n : A_n -> B. I can build all of this in Haskell by having a datatype representing morphisms in A_n, MA_n a b (instance of Category), and likewise for C, and a map F_n : MA_n a b -> MC a b. it turns out in my application that computing composition in C is very expensive, so i'd like to delay it as long as possible to potentially compute in
15:33:30 <simplegauss> A_n; for example, early in the program i might have the composition F_1(f) . k where k is an MC, and later left compose with F_1(g), and end up computing F_1(g . f) . k instead of computing F_1(g) . F_1(f) . k. is there some nice solution to this problem if i don't know the A_n or F_n in advance, but i know i always want to compute compositions in the A_n if possible?
15:35:24 <dmwit> I think the order that your functions get composed is going to be pretty hard to adjust at runtime unless you explicitly represent it.
15:35:40 <dmwit> You can look into rewrite rules for what can be done at compile time.
15:35:55 <dmwit> But I have no idea whether compile-time rewriting will be able to notice enough stuff for it to matter in your situation.
15:36:24 <simplegauss> to be explicit, i've been using data Comp l c r c1 c2 a b = Comp { left :: l c2 b, middle :: c c1 c2, right :: r a c1}
15:36:34 <dmwit> ("Explicitly represent it" meaning "have extra constructors in MC for the results of functorial things, and delay computing those until observation time".)
15:36:54 <Tuplanolla> This is exactly the kind of the problem I want another language for.
15:39:34 <simplegauss> this representation allows me to use a "tagged" type for the left and right ends of the composition to "remember" the functor used to construct it, and typically c is another Comp, but this gets messy, isn't too elegant, and isn't the prettiest way to think about it. it would be nicer to have a "heterogeneous list" of sorts, with pairs of MC, along with some sort of tag that tells me what category each element in the composition comes
15:39:34 <simplegauss> from and the functor used to construct it
15:40:12 <simplegauss> but (1) such lists aren't really possible in haskell (2) maps can't be compared for equality (3) i don't think types can be made into values comparable for equality.
15:40:39 <simplegauss> dmwit: but yes, the idea is to keep an explicit representation of the chain in C, so delay composition in C but do everything else as eagerly as possible.
15:41:12 <simplegauss> dmwit: the problem is the explicit representation Comp is a bit of a mess and not nice for the reasons i mentioned
15:42:48 <sqooq> idris looks like a better haskell
15:42:52 <sqooq> from what I see
15:43:00 <sqooq> but I guess it's more like a *different* haskell
15:43:08 <sqooq> Well shit, looks like I'll start getting into idris
15:43:55 <nihil> Heterogenous Lists are possible using DataKinds Extension.
15:46:14 <nkaretnikov> nihil: interesting, how would such a type signature look like?
15:46:36 <nkaretnikov> Or is it just a glorified tuple ?
15:51:04 <simplegauss> Tuplanolla: is there a name for this or an analogous problem, and a language or at least a proposed solution to it? perhaps a concrete feature missing from Haskell? i'm honestly a bit confused on how to think about this.
15:51:47 <Tuplanolla> I do not have the answers, simplegauss.
15:53:05 <Tuplanolla> As I said, I'm also looking for a Haskell with better metaprogramming.
15:54:11 <concaveirc> All right, I have a problem which I hope has a solution:
15:54:24 <sqooq> infinisil, ski, sequence isn't right. replicateM_ seems right but when I use it I get a different answer than just manually replicating. Not sure why
15:55:29 <concaveirc> I have a Behavior (Maybe String) (Behavior from reactive banana), where behavior is an applicative. I also have readFile :: String -> IO String. Is it possible to combine these to create a Behavior (Maybe String)
15:55:36 <sqooq> huh
15:55:38 <sqooq> nvm it's working
15:55:40 <sqooq> wtf
15:55:46 <concaveirc> I mean IO (Behavior (Maybe String))
15:56:51 <lyxia> simplegauss: Are all the A_n you will need known statically
15:57:32 <concaveirc> I feel like to get IO (Behavior (Maybe String)) I would either need Behavior (IO (Maybe String)) -> IO (Behavior (Maybe String))
15:57:32 <lyxia> simplegauss: in which case you could hide l and r as existential types
15:57:46 <ski> @src replicateM_
15:57:46 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
15:57:54 <concaveirc> or (String -> IO String) -> IO (String -> String)
15:58:14 <ski> that's impossible
15:59:11 <simplegauss> lyxia: no, but we can start there :) i thought if i knew the A_n statically, then the "correct" solution is to make some giant "tag" ADT a type for each of them separately, but you're suggesting something else?
15:59:37 <ski> (not sure about `Behavior (IO (Maybe String)) -> IO (Behavior (Maybe String))', but i suspect that's also impossible)
16:00:23 <simplegauss> lyxia: i could then make this giant ADT a category, then work in the product category of C and this tag category to achieve what i want. but this too seems ugly.
16:00:34 <lyxia> simplegauss: hmmm actually that's more or less equivalent, an ADT is even simpler.
16:00:50 * ski . o O ( <https://corecursive.com/006-type-driven-development-and-idris-with-edwin-brady>,<https://www.youtube.com/watch?v=X36ye-1x_HQ> )
16:00:52 <lyxia> simplegauss: you don't need to make the ADT a category though
16:02:37 <lyxia> simplegauss: Separating the tag from the morphism might help reduce some boilerplate
16:03:19 <concaveirc> ski: Oh well.
16:03:59 <ski> concaveirc : do you see why the latter, at least, is impossible ?
16:04:59 <ski> the callback, of type `String -> IO String', will first receive a `String', and then use that to determine which `IO'-action to perform (which will result in a `String' result)
16:05:01 <concaveirc> The latter is impossible intuitively, but I cannot prove that yet.
16:05:28 <simplegauss> lyxia: i think it's nice to make it a category. basically then i can then compose in the C category lazily and the tag category strictly as a product at the same time, and simplify the final composition in C by using the tag
16:05:30 <concaveirc> Oh, I see. It is semantically incorrect.
16:05:52 <ski> but you want the result computed from that callback to be of type `IO (String -> String)', which would *first* have to do all the I/O, and only when that's finished, get to look at the input `String', to compute the result `String'
16:06:17 <simplegauss> lyxia: the issue with this approach is that the ADT would be truly giant, and would have to be rewritten every time some small requirement changed, although the way I described the algorithm is completely generic over the A_n and F_n, and only uses the facts that the A_n are categories and F_n are functors
16:06:21 <ski> there's no way we can extract a single description of I/O to do, regardless of what `String' was passed, given the callback allows the I/O to depend on the input `String'
16:06:49 <lyxia> simplegauss: there are techniques to write extensible sums
16:06:59 <ski> i think something similar would hold for `Behavior (IO (Maybe String)) -> IO (Behavior (Maybe String))', considering `Behaviour a' to be roughly `Time -> a'
16:07:08 <lyxia> simplegauss: basically the dual of writing a heterogeneous list
16:07:32 <concaveirc> Ah well. Do you think there is some other way to obtain an m (Behavior (Maybe String)) from Behavior (Maybe FilePath)?
16:07:41 <ski> (also, since time is supposed to be continuous, that means the callback here would "contain" infinitely many, possibly different I/O actions. how are you even going to handle that ?)
16:08:38 <sqooq> how come sometimes fromIntegral automatically wants Integer?
16:08:44 <sqooq> even if I put Int in the signature?
16:08:56 <concaveirc> I see, IO is opaque, and Behavior must somehow deal with that.
16:08:57 <simplegauss> lyxia: where can one learn these techniques? :) are they similar to my "Comp" datatype?
16:09:09 <ski> concaveirc : well, if you had `Event FilePath', then perhaps you cuold get to `Event (IO String)', and perhaps you could execute that I/O action as soon as it arrives ?
16:09:39 <ski> concaveirc : i don't know that much about details of FRP libraries, but that sounds to me like something that might be possible
16:11:03 <sqooq> why in the world is it telling me it expects Integer
16:11:18 <sqooq> fromIntegral works on Int too
16:12:20 <ski> perhaps DMR strikes again ?
16:12:46 <ski> or maybe something else constrains it to `Integer'
16:12:47 <MarcelineVQ> perhaps code should go along with questions
16:12:53 <concaveirc> ski: There is no obvious answer to that, but I will look into that.
16:14:39 <ski> concaveirc : well, i don't think it's so much `IO' being opaque. i think if you had `State s' instead of `IO', you'd have the same problem
16:15:11 <concaveirc> ski: Actually, there is execute :: Event (MomentIO a) -> MomentIO (Event a), so with lift the problem is basically solved!
16:15:16 <lyxia> simplegauss: http://okmij.org/ftp/Haskell/extensible/ open unions
16:15:28 <EvanR> sqooq: sounds like ghc is being smarter than you, try putting more type signatures until GHC disagrees with you on something where you understand why
16:15:32 <ski> cool ! :)
16:15:39 <lyxia> simplegauss: maybe you can try to use the CoRec module in vinyl
16:18:38 <simplegauss> lyxia: thanks, i'll look into those! i still have the uneasy feeling i'm missing some cleaner way to phrase this whole thing in haskell, since the process has such a clear categorical description and is mathematically almost a triviality, but for some reason becomes ugly when i try to express it in (statically typed) code
16:22:17 <sqooq> EvanR, lol thanks. I put integer by accident way down on the last function call, but the errors were for all the previous function definitions
16:24:09 <EvanR> if you get the type sigs wrong, youre screwed
16:24:22 <ski> type error slicing would be nice
16:25:09 <sqooq> is it possible at all to make postfix functions
16:26:13 <ski> > let (!) n = product [1 .. n] in (5 !)
16:26:16 <lambdabot>  120
16:26:24 <ski> > let fact n = product [1 .. n] in (5 `fact`)
16:26:26 <lambdabot>  120
16:26:32 <EvanR> haha
16:26:50 <mud> I didn't know you could do ... either of those
16:27:14 <sqooq> woah
16:29:07 <EvanR> me neither
16:30:31 <sqooq> why can't I get it to work
16:32:06 <sqooq> ``• Non type-variable argument in the constraint: Num (t1 -> t2)
16:32:06 <sqooq>       (Use FlexibleContexts to permit this)
16:32:06 <sqooq>     • When checking the inferred type
16:32:06 <sqooq>         it :: forall t1 t2. (Num (t1 -> t2), Enum (t1 -> t2)) => t1 -> t2``
16:32:20 <geekosaur> it's an extension, if you mean the postfix thing
16:32:43 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#postfix-operators
16:32:47 <sqooq> o
16:32:57 <infinisil> That the postfix functions work makes sense if you think of (a `f`) being syntactic sugar for f a, not requiring a 2nd argument at all
16:33:13 <geekosaur> it actrually reuires a slight difference in how they are desugared, iirc
16:34:17 <infinisil> Hm
16:35:41 <geekosaur> the extension doc explains the change in desugaring, but iirc it turns out to have a small strictness impact as well
16:36:31 <geekosaur> (if I am remembering correctly, ghc used to always desugar that way but reject the surface syntax, and this turned out to change strictness semantics)
16:40:14 <MarcelineVQ> strictness or lift-able-ness?
16:40:51 <Axman6> (instance Num a => Num ((a -> b) -> b) where ... 5 fact -> 120, 20 seconds :: Seconds
16:41:15 <Welkin> ostrich?
16:42:05 <Welkin> did anyone see that article published recently about how the way dinosaurs have been protrayed for the last decade+ is totally wrong?
16:42:24 <Welkin> trex looked more like a big chicken than a lizard
16:42:49 <Welkin> this has been known for a long time, but popular media likes their lizards
16:43:24 <MarcelineVQ> 2.5 decades you mean? dinosaurs started getting feathers in the 90s. I think you've sent this to the wrong channel though
16:45:40 <Welkin> I meant last century
16:53:54 <geekosaur> that said, dino feathers likely didn't look much like bird feathers. iirc the various fine fossils we've found with feather traces suggest they looked more like heat sinks or beam antennas
17:22:33 <Digit> pre-flight lightening
17:23:54 * Digit is still trying to construe how there might be some relevant metaphor in there for Haskell
17:27:48 <pdxleif> @hoogle Int -> Double
17:27:49 <lambdabot> Extra intToDouble :: Int -> Double
17:27:49 <lambdabot> Numeric.Extra intToDouble :: Int -> Double
17:27:49 <lambdabot> Numeric.SpecFunctions factorial :: Int -> Double
17:35:20 <ski> pdxleif : `fromIntegral' ?
17:37:09 <holycleugh> Is there a checklist for publishing a library to hackage? Something like docs, run hfmt, etc
17:38:19 <MarcelineVQ> a tiny litle one here https://hackage.haskell.org/upload
17:39:12 <MarcelineVQ> which mentions cabal check being helpful as well
17:39:47 <holycleugh> MarcelineVQ: great, thanks
17:49:55 <dmj`> holycleugh: cabal check
18:09:00 <pdxleif> Does anyone know about generating the RGB triples for the colors on the rainbow, red->violet? Want the spectrum for a "heat map" display.
18:09:18 <pdxleif> I was thinking to just do some sine waves of each, a la http://www.markandey.com/2012/04/how-to-generate-rainbow-colors.html
18:09:44 <pdxleif> Though there's this "colour" library I'm trying to grok: https://wiki.haskell.org/Colour
18:13:55 <dmwit> pdxleif: It's probably easier to generate them in HSV space.
18:14:10 <dmwit> pdxleif: Pick a saturation and value, then vary the hue linearly.
18:15:02 <dmwit> https://hackage.haskell.org/package/colour-2.3.4/docs/Data-Colour-RGBSpace-HSV.html looks like it has conversions to RGB from there.
18:15:27 <EvanR> now the H and HSV doesnt generate "rainbow" colors
18:15:32 <EvanR> the H in*
18:16:07 <EvanR> ROYGBIV
18:16:30 <geekosaur> you can convert between them
18:16:41 <geekosaur> that doesn't change that some things are easier in the one, and some in the other
18:17:08 <EvanR> its a different color space
18:17:24 <EvanR> infrared and ultraviolet are in one but not the other
18:17:49 <geekosaur> it's a differentr color space, yes. do you really care about the differences?
18:17:55 <geekosaur> it's not like you have to be from mars to see hsv
18:18:40 <geekosaur> and if you;re being pedantic about human vision, you probably want cie instead of either rgb or hsv
18:26:18 <EvanR> the choice is what colors pdxleif will actually want and how to easily get it
18:26:40 <EvanR> an hsv wheel doesnt seem very rainbowy to me
18:27:02 <Welkin> but what about the ntsc color space?
18:27:06 <Welkin> or dci-p3?
18:27:32 <Welkin> rgb is just sRGB
18:27:45 <Welkin> at least if each color is 8 bits (24 bit color)
18:28:48 <geekosaur> .oO { never the same color }
18:30:00 <Welkin> isn't it strange how the NTSC color space defines colors far outside of sRGB, yet most displays can barely cover sRGB?
18:30:25 <Welkin> sRGB covers 72% of NTSC, which was defined as a standard for color television many decades ago
18:32:26 <EvanR> all these models are insensitive to tetrachromats
18:32:47 <EvanR> i demand social color justice
18:33:47 <MP2E> all CRT TVs show NTSC signals slightly differently. It has lead to lots of arguments in the NES community about what the 'true' RGB palette is, because the NES natively generates composite video
18:34:10 <Welkin> well, you do want CMYK when printing
18:34:13 <Welkin> black ink
18:34:26 <geekosaur> that was my thought bubble, which is a TV engineer in-joke about what NTSC stands for
18:34:34 <Welkin> RGB would only give you simulated black
18:35:03 <geekosaur> but the same is true of CMY which is why K was added. (CMY being of course just complement-RGB)
18:35:05 <EvanR> are you confusing RGB with backlit display
18:35:44 <Welkin> oh, cool https://en.wikipedia.org/wiki/Hexachrome
18:35:45 <EvanR> RGB CRT monitors can show black if turn the room lights off
18:36:23 <Welkin> EvanR: so can oled
18:36:50 <EvanR> i am still not convinced oled TVs are real
18:37:01 <pdxleif> I just want something that just goes from red to violent as the percentage goes from 0 to 100% - I don't need it exact.
18:37:04 <EvanR> and not yet another fake TV sales pitch
18:37:07 <pdxleif> *violet
18:37:12 <glguy> I liked violent better
18:37:15 <Welkin> haha
18:37:21 <geekosaur> that's just any FPS :p
18:37:21 <EvanR> ultraviolence?
18:37:53 <pdxleif> Know if an easy way to test this? Had trouble getting diagrams-cairo to install
18:38:11 <Welkin> "For example, although several specific color spaces are based on the RGB color model, there is no such thing as the singular RGB color space."
18:38:20 <Welkin> I suppose that makes sense
18:38:57 <Welkin> although in programming, when often use 8-bit values to represent each component of RGB, which I believe is sRGB
18:39:07 <EvanR> these are encodings
18:39:12 <EvanR> not the color space itself
18:43:44 <pdxleif> Who knew rainbows were so complicated. :/ http://tabletopwhale.com/2016/06/26/half-past-orange.html
18:43:55 <pdxleif> The calculations for an n-sided polygon were much easier.
18:46:05 <catern> hmm, question about garbage collection theory
18:46:32 <catern> rather than tracing up from registers, couldn't you instead trace down from some top-level program root?
18:46:45 <catern> are there any papers about this idea?
18:46:53 <catern> or a name for it?
18:47:34 <jle`> got a working polymorphic backprop/reverse mode AD working with unsafePerformIO
18:47:36 <jle`> feels gross
18:47:52 <jle`> but i guess edwardk does it with ad so i feel a little better about my decision
18:47:54 <EvanR> pdxleif: right...
18:53:46 <geekosaur> rainbow works by far best as frequencies, not as split components
18:54:09 <geekosaur> (or wavelengths but that's just 1/freq)
18:56:23 <Welkin> perhaps you could quantize the frequencies using a low step value and then use linear interpolation between the rgb values?
18:59:54 <d34df00d> Hi!
19:00:08 <d34df00d> Can I haz hdevtools supporting multiple ghc versions?
19:00:29 <geekosaur> only if you install separately for each one. it's accessing ghc internals which change wth every version
19:00:35 <d34df00d> I have projects with both lts-9 and lts-10, and hdevtools behaves funny (seems like not working at all) for the latter.
19:00:43 <d34df00d> geekosaur: how can I install separately?
19:01:21 <pdxleif> geekosaur: Isn't the h part of hsv color the frequency?
19:02:04 <geekosaur> with stack, easiest might be to make it a dependency of the project
19:02:11 <MarcelineVQ> if you're using stack and your edtior is stack aware it's as simple as going  stack build hdevtools  in each project you have and making sure hdevtools is not on the global path
19:02:26 <dmwit> pdxleif: It is not.
19:02:56 <dmwit> pdxleif: Indeed, the H is cyclic (360 degrees and 0 degrees are the same color), so it cannot be frequency.
19:03:29 <d34df00d> Right, I'll have to figure out if the ale plugin for vim supports that.
19:06:24 <geekosaur> pdxleif, what dmwit said. it's related to frequency to some extent, but [31 02:26:18] <EvanR> an hsv wheel doesnt seem very rainbowy to me
19:06:53 <dmwit> The HSV wheel seems pretty rainbowy to me.
19:07:04 <dmwit> It does generally go in rainbow order, then wrap around.
19:07:29 <EvanR> nah
19:07:41 <EvanR> barbie pink?
19:07:51 <geekosaur> rainbows are continuous
19:08:12 <geekosaur> ROYGBIV is humans imposing artificial structure (...incorrectly: I is an illusion)
19:08:28 <geekosaur> added because people wanted it to be 7
19:08:36 <dmwit> EvanR: So there is one region in the non-physical "wrap around" part that isn't part of the rainbow. That doesn't seem so bad.
19:08:38 <EvanR> theres also bluegreen
19:08:39 <Welkin> the faith of the seven
19:09:05 <EvanR> dmwit: its pretty ugly, and doesnt signify an extreme end of any scale
19:09:19 <Welkin> what about infrared?
19:09:22 <Welkin> and gamma rays?
19:09:32 <EvanR> gamma rays are clearly green
19:09:35 <dmwit> EvanR: And is also very easily omitted when drawing your rainbow.
19:09:37 <EvanR> incredible hulk
19:10:00 <Welkin> yeah
19:10:05 <Welkin> the gay flag only has 6 colors
19:10:55 <greymalkin> Is there a reference equality in haskell? I have several objects of which I only intend to have one each, but will need to check equality in a very tight loop.
19:11:15 <dmwit> Yes, IORef.
19:11:30 <dmwit> instance Eq (IORef a) -- N.B. does not require Eq a
19:11:50 * ski . o O ( <https://upload.wikimedia.org/wikipedia/commons/5/5b/Supernumerary_rainbow_03_contrast.jpg> )
19:11:52 <EvanR> theres also stable names, but i am skeptical that your values are so singular in the runtime
19:12:39 <greymalkin> EvanR, They better be; they represent unique and runtime-wide connections to external servers.
19:13:12 <EvanR> oh, are you creating them in IO like IORef or something
19:14:15 <greymalkin> They will be created in IO; but I'm not intending them to be mutated at any time after creation -- technically, they're created in a MomentIO, though.
19:14:28 <greymalkin> (reactive banana)
19:16:46 <geekosaur> referential transparency implies you do not get to e.g. compare addresses. you need to use something like IORef to get it
19:19:10 <ski> greymalkin : i wonder whether something like <https://hackage.haskell.org/package/ivar-simple-0.3.2/docs/Data-IVar-Simple.html> would be appropriate
19:20:42 <pdxleif> what's the rgb color code for gamma rays?
19:21:16 <pdxleif> I could use gamma rays on the gauge to indicate you've turned up the brightness too far
19:23:29 <EvanR> (0,0,0x10ffff)
19:30:41 <greymalkin> I will probably just issue them Int ids, then; most of these (IORef, IVar) complicate the pure logic further down the chain.
19:51:01 <iqubic> How are you planning on issuing Int ids?
19:52:08 <erisco> +1
19:54:14 <Axman6> > let xs = 1:xs >>= \x -> [x*2,x*2+1] in xs
19:54:17 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
20:02:25 <EvanR> if your connections are Handles you can compare those too
20:05:27 <greymalkin> iqubic: I'm going to be creating each of the objects in the same place, so I can just pull from [0..]
20:11:25 <buhman> I'm having trouble understanding why 'flip zip [1,2,3,4,5] "hello"' is valid
20:11:57 <d-fish> it's `zip "hello" [1, 2, 3, 4, 5]`
20:12:14 <d-fish> zip ['h','e','l','l','o'] [1, 2, 3, 4, 5]`
20:12:31 <buhman> yeah, I know what the result is, but I don't understand the interaction between flip and the remaining things
20:12:45 <d-fish> flip takes in a function (zip) and returns a function
20:13:02 <buhman> hmm
20:13:07 <d-fish> :t flip
20:13:08 <Welkin> buhman: function application goes left to right
20:13:09 <lambdabot> (a -> b -> c) -> b -> a -> c
20:13:28 <d-fish> :type flip
20:13:53 <Welkin> so it is the same as ((flip zip) [1,2,3,4,5]) "hello"
20:13:55 <buhman> oh, I suppose it's like saying (((flip zip) [1,2,3,4,5]) "hello")
20:14:23 <d-fish> yup!
20:14:25 <buhman> yeah
20:15:49 <buhman> is there a good visualization for the '.' function?
20:18:59 <ski>   c <-{ f }-< b <-{ g }-< a
20:19:00 <ski> ?
20:19:29 <ski> @src flip
20:19:29 <lambdabot> flip f x y = f y x
20:19:32 <ski> @src (.)
20:19:32 <lambdabot> (f . g) x = f (g x)
20:19:58 <ski>      flip zip [1,2,3,4,5] "hello"
20:20:15 <ski>   =  zip "hello" [1,2,3,4,5]
20:20:38 <ski>   =  [('h',1),('e',2),('l',3),('l',4),('o',5)]
20:21:37 <d-fish> A common visualization is to see functions as pipes with values flowing throught them. "f . g" is hooking the input part of f onto the output of g.
20:21:40 <EvanR> buhman: approximately the same good visualization for the unix pipe ?
20:21:45 <buhman> I guess (f . g) x = f (g x) is helpful, but I have a hard time seeing that in actual code I guess
20:22:15 <EvanR> if a function is a machine with an input end and output end, . will put two pipes together
20:22:36 <EvanR> which gives you ... another function with 1 input and 1 output
20:22:42 <EvanR> but hides 1 input and 1 output in the middle
20:23:15 <EvanR> when i said machine/pipe i meant pipe/machine
20:23:47 <buhman> so, f and g, unless there are other applications elsewhere, can only have 1 argument and 1 return value?
20:24:01 <buhman> each
20:25:18 <EvanR> to get . you need to ignore applications
20:25:33 <EvanR> that comes last after you finish doing .'s
20:27:19 <ReinH> :t (.)
20:27:21 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:27:37 <ReinH> @buhman Yes, (.) works on functions that take one argument. However, all functions take one argument.
20:27:37 <lambdabot> Unknown command, try @list
20:27:42 <ReinH> Ugh sorry
20:27:57 <ReinH> Some functions take one argument and give other functions
20:28:14 <ReinH> :t \f g x -> f . g x
20:28:17 <lambdabot> (b -> c) -> (t -> a -> b) -> t -> a -> c
20:28:30 <d-fish> If reeeeealy want to, you can chain functions that take more than one argument, it just looks ugly
20:28:49 <buhman> I haven't seen that, but (.) seems really popular
20:28:53 <d-fish> There's a tool "pointfree" that shows how to compose things
20:29:02 <d-fish> pointfree "f a b c = a == b + c"
20:29:06 <ReinH> buhman: (.) is popular because reasoning about composition is extremely useful
20:29:07 <d-fish> f = (. (+)) . (.) . (==)
20:29:23 <ReinH> It is one of two basic ways to reason about functions: you can reason about application or about composition.
20:29:43 <ski> @pointless f a b c = a == b + c
20:29:43 <lambdabot> f = (. (+)) . (.) . (==)
20:30:19 <ReinH> The first is "what happens when I apply functions to values?" while the second is "what happens when I build functions from other functions, that is, when I *compose* them".
20:30:36 <ski> using `.', one concentrates more on the "pipeline", and its parts, than on the data that will flow along it
20:34:55 <d-fish> Can Megaparsec parse lazily?
20:35:34 <d-fish> take 10 <$> parse intsandspaces "my test" (cycle "1 1 1 1 1 1 1 1 1 1")
20:35:47 <d-fish> this hangs, even though I only want the first 10 elements
20:36:06 <glguy> No, that can't work. It needs to keep parsing to find out if there were any parse errors
20:36:21 <d-fish> Do I have to use attoparsec?
20:36:23 <glguy> the fact that you're tossing out any of the parsed ints after 10 doesn't affect that the whole thing has to parse
20:36:27 <d-fish> if I want that functionality
20:36:28 <glguy> attoparsec doesn't help for that
20:37:19 <d-fish> What library has that kind of functionality?
20:37:25 <buhman> how do I figure out what other symbols are called like "<$>" so I can read about them?
20:37:28 <Axman6> would parse (take 10 <$> intsandspaces) ... work?
20:37:34 <Axman6> hmm, no
20:37:35 <Welkin> buhman: that is fmap
20:38:14 <buhman> yeah @src told me that, but hackage only talks about it being called 'fmap' and doesn't mention '<$>'
20:38:27 <glguy> ?hackage base
20:38:27 <lambdabot> http://hackage.haskell.org/package/base
20:38:36 <Welkin> <$> is a synonym for infix fmap
20:38:39 <glguy> buhman: Look at the [Index] link at the bottom of the modules list
20:38:45 <d-fish> hoogle
20:38:47 <glguy> you can look up operators in the index to see the documentation for them
20:38:48 <Welkin> it is the same as `fmap`
20:39:00 <d-fish> https://www.haskell.org/hoogle/?hoogle=%3C%24%3E
20:39:03 <buhman> glguy: ah that's nice
20:39:17 <buhman> d-fish: cool!
20:41:09 <glguy> d-fish: You can make a parser with megaparsec that only parses 10 ints if that's how many you want
20:42:14 <glguy> or if you don't care about error handling, take 10 . map read . words
20:42:24 <d-fish> I'm trying to write a parser for a massive, very regular text file
20:42:32 <ReinH> I think the question is whether a Parser [a] (for some a) is a good producer, and the answer is no.
20:44:42 <d-fish> and I really like megaparsec. I'm pretty sure all the stuff I use megaparsec for could be done easier with functions on Strings/Text,
20:45:54 <d-fish> but I'm of finding a situation where an actual parser is appropriate and not knowing them at all.
20:49:50 <d-fish> Are there any parsers that support lazy producing?
20:50:05 <d-fish> Or does backtracking rule that out
20:51:00 <jackdk> there's https://hackage.haskell.org/package/incremental-parser but IME it was really easy to accidentally break incremantality
20:55:27 <thezillion> Hey! Please tell me how is a language like Haskell is useful performance-wise? Like, machine performance.
20:55:46 <Welkin> it can heat up your bedroom
20:55:50 <Welkin> is that useful?
20:56:11 <thezillion> Pretty useful xD
20:56:14 <thezillion> Anything else?
20:56:16 <boj> thezillion: what kind of processing do you anticipate doing?
20:56:41 <Welkin> it depends on what you want to do
20:57:07 <Welkin> in general, it has near C level performance for most things
20:57:11 <thezillion> boj: I'm just starting out, and want to know if it's a viable option in some specific domain you know of
20:57:35 <Welkin> it is lacking in areas like numerical computations because of a lack of libraries
20:57:48 <Welkin> performance is almost never an issue
20:58:16 <Welkin> the issue is usually library support
20:58:22 <boj> thezillion: it's a general purpose language, so it tends to be decent at most things. you might run into problems if you work on large in memory data sets, or plan on doing scientific number crunching. you'll do well in typical realms like web, db, parsing, etc
20:58:33 <Welkin> but haskell has extremely good support for web servers and web development in general
20:58:44 <vaibhavsagar> does anyone have tips on migrating from haskell-src-exts 1.17 to 1.18?
20:59:16 <vaibhavsagar> it's the big change from everything being not annotated to being annotated by default that is the most painful
21:06:02 <anhj> hello there
21:17:30 <Axman6> hello anhj!
21:27:30 <dmj`> hello anhj!
21:35:10 <bsima> Does anyone know what this error means in keter? runInteractiveProcess: exec: does not exist (No such file or directory)
21:53:23 <Axman6> jle`: I just finished reading your posts on singletons, they were excellent. Now I have yet another tool to solve a problem I don't have (yet)
21:55:03 <Axman6> hmm, that came out more sarcastic than I meant, they really are fantastic!
22:49:57 <python476> hi there
22:50:04 <python476> i've been reading about rust recently
22:50:14 <python476> but I miss ml/haskell
22:50:31 <python476> still, I'm curious about linear types / linear logic in a pure FP setting
22:51:04 <python476> is the idea translatable in Haskell ? or maybe useless at the user level
22:51:24 <python476> (I suppose the compiler might have a similar linearity check at some point)
22:53:28 <ReinH> python476: https://ghc.haskell.org/trac/ghc/wiki/LinearTypes
22:54:31 <ReinH> (Although Rust technically has affine types)
23:03:27 <python476> ReinH: right, thanks
23:07:34 <cocreature> I’m sad that the linear types proposal got shot down so quickly. hopefully they’ll be able to revise it and try it again
23:10:38 <jle`> Axman6: haha, i'll take that as a compliment :)
23:10:45 <jle`> cocreature: did something happen recently?
23:11:09 <cocreature> jle`: https://github.com/ghc-proposals/ghc-proposals/pull/91
23:12:23 <cocreature> jle`: summary: exceptions make linearity tricky/impossible and there didn’t seem to be consensus on whether it should just be relaxed to affine types or if promising linearity while breaking it in the presence of exceptions is the best way forward
23:12:50 <cocreature> they did say they are going to revise it and make another proposal so I’m still hopeful something will come out of it :)
23:13:18 <jle`> :)
23:13:24 <jle`> i didn't realize this happened in three months ago
23:13:41 * jle` adds ghc-proposals to watch list
23:14:05 <jle`> a lot of people seem to be hung up on the fact that the performance gains aren't implemented yet
23:14:14 <jle`> but linear types for me was never about performance
23:14:19 <jle`> it's about helping me catch my own bugs
23:14:58 <jle`> and helping my develop my programs faster
23:15:05 <cocreature> yeah but especially for things like resource handling, you really need them to be safe in the presence of exceptions
23:15:21 <cocreature> so you need to use linear types + finalizers and that’s kind of weird
23:16:05 <jle`> that's something that could always come later right :)
23:20:18 <heptahedron> jle`: I liked your blog post about the current state of sized vectors! Came in here a couple days ago and lyxia recommended it
23:20:40 <jle`> heptahedron: thanks! i'm glad it was helpful :)
23:20:52 <jle`> it was partially a redemptive post hehe cause i felt bad for potentially spreading misinformation last time
23:21:27 <phadej> blog post where!? I want to check it out
23:22:08 <raduom> jle`: that also helped me out understanding singletons :)
23:22:14 <raduom> jle`: thanks.
23:22:38 <jle`> phadej: i think heptahedron was talking about https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html
23:22:51 <jle`> raduom: glad it could be helpful too :)
23:23:04 <heptahedron> I had already written out a 50-or-so line implementation of the typical structural Vect type, and wanted to see how far I could get without depending on another library, but sized-vector and type-combinators were good-looking candidates for times when I needed something more fleshed out
23:23:07 <jle`> hopefully can get part 3 out before it's too late, heh
23:23:21 <heptahedron> jle`: What might part 3 be about?
23:23:23 <jle`> heptahedron: yeah, it's just so much
23:23:28 <jle`> that's useful
23:23:31 <jle`> it's hard to compete
23:24:03 <jle`> one downside though is that it seems to have fallen unmaintained and PR's/issues seem to not be getting resolved, but that's sort of the nature of utility libraries i suppose
23:24:06 <phadej> jle`: nice
23:24:14 <jle`> heptahedron: about promoting functions to the type level
23:24:20 <jle`> instead of just normal values
23:24:20 <heptahedron> jle`: which one in specific? sized-vectors? I'd be surprised
23:24:25 <heptahedron> jle`: Oh god, Symbols?
23:24:27 <jle`> heptahedron: typed-combinators
23:24:42 <phadej> heptahedron: shameless self-plug, if you need structural type, use: http://hackage.haskell.org/package/vec
23:24:45 <sr10> subject = [("maths",[]),("science",[]),("chemistry",[]),("french",[])] marks = [("science","john"),("maths","john"),("chemistry","ron"),("maths","ron"),("maths","sam")]
23:24:46 <sr10> output as [("maths",["john","ron","sam"]),("science",["john"]),("chemistry",["ron"]),("french",[])]
23:24:54 <sr10> how to do this?
23:25:03 <sr10> help needed
23:25:07 <jle`> heptahedron: the hack we have to use is called defunctionalization
23:25:10 <jle`> heptahedron: but it's not too bad :)
23:25:22 <jle`> we actually only need defuncationalization if we want to partially apply our functions
23:25:40 <jle`> but if you never do, it's basically like using normal type families and functions
23:25:50 <jle`> singletons just has a lot of useful TH to auto-generate type-level versions
23:25:54 <heptahedron> jle`: Oh yeah, type-combinators did seem kind of abandoned, I didn't love its syntax for vectors but it was a good implementation nonetheless
23:26:55 <heptahedron> phadej: You know what, I actually also looked at that library! And it does look good :) admittedly I knew the whole time I was reinventing the wheel with this part of this little project but it's helped me get much more comfortable with dependent types in Haskell and I can't say I'm upset haha
23:27:35 <heptahedron> phadej: also wow, that's hilarious, I just saw that you referenced a paper about DP type theory in Haskell called Hasochism in your package desc
23:28:33 <jle`> yeah, it's just that there's so much infrastructure already built into it heh, everyhting just works together in it so well :'(
23:28:56 <infinisil> sr10: try this first: use groupBy to group entries of the same subject
23:29:11 <infinisil> :t groupBy
23:29:12 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
23:30:19 <heptahedron> jle`: I didn't grok it entirely, but the fact that everything seemed to be poly-kinded certainly told me this person knew what they were doing haha
23:30:43 <jle`> yeah i actually learned a lot from seeing how that library was implemented :)
23:30:51 <jle`> but i wonder if now is the time to grow beyond it
23:31:22 <heptahedron> jle`: Well is there anything in which that library is particularly wanting?
23:31:36 <enigma> how do your mask your ip on freenode
23:32:16 <jle`> heptahedron: well there are some small ergonomic functions i could add, and some useful combinators that i've seen around, but nothing too big really
23:32:19 <jle`> nothing enough to justify a fork
23:32:55 <sr10> infinisil : groupBy(\x y -> x == y) (sort marks)
23:33:50 <infinisil> sr10: what does this give you for your input?
23:35:22 <infinisil> sr10: it's not what you need, what this would do is group elements that have the same subject /and/ student
23:35:47 <infinisil> you only want to group elements that have the same subjects
23:36:13 <sr10> infinisil : [[("chemistry","ron")],[("maths","john")],[("maths","ron")],[("maths","sam")],[("science","john")]] i got this
23:36:37 <sr10> i want to group together students who got the same subject
23:36:42 <infinisil> sr10: hint: groupBy (\(student1, subject1) (student2, subject2) -> ???) marks
23:37:05 <heptahedron> I made use of Data.Type.Equality.:~: today for the first time in a proof necessary for something to typecheck and I'm just absurdly happy about that
23:37:21 <infinisil> sr10: um, sorry the other way around, subject is first, then student
23:37:24 <sr10> infinisil: i'l try
23:38:19 <jle`> heptahedron: it's intoxicating, isn't it? :p
23:39:03 <heptahedron> jle`: it's intoxicating as it is frustrating when I can't seem to think of the next step GHC wants me to perform lol
23:39:22 <python476> jle`: I like the linear idea as a structuring discipline and the potential efficiency
23:39:26 <heptahedron> *it's as
23:40:05 <sr10> infinisil : i may not have that subject in the marks....but still i have to show that subject with empty students
23:40:24 <jle`> heptahedron: it's something that you get better with over time :)
23:40:26 <sr10> subject = [("maths",[]),("science",[]),("chemistry",[]),("french",[])]
23:40:26 <sr10> marks = [("science","john"),("maths","john"),("chemistry","ron"),("maths","ron"),("maths","sam")]
23:40:42 <sr10> output as [("maths",["john","ron","sam"]),("science",["john"]),("chemistry",["ron"]),("french",[])]
23:41:04 <jle`> actually one thing that would be nice is to just annotate bindings with the number of times you expect to use it
23:41:08 <infinisil> sr10: yeah i know, you showed that already
23:41:25 <heptahedron> jle`: Currently trying to figure out the last branch of my Vect concat implementation, trying desperately not to resort to phadej's libraries' source
23:41:40 <jle`> `let 1!x = 2 * 3 in x + 4`  would compile maybe, but `let 1!x = 2 * 3 in 3 * 4` would not
23:41:43 <infinisil> sr10: there are lots of ways to do what you want
23:42:01 <jle`> heptahedron: Vec concat should just follow the same structure as your + type family :)
23:42:30 <jle`> Vec and Nat have an interesting coupling like that
23:42:31 <infinisil> sr10: one way is with groupBy, but we can fold over the input too
23:42:41 <jle`> Nat is basically just Vec ()
23:42:44 <infinisil> which might be nicer tbh
23:43:07 <sr10> i'll try with groupby
23:43:24 <infinisil> oh actually, groupBy doesn't work haha
23:43:41 <infinisil> somebody take my haskell advice giver badge
23:44:25 <heptahedron> jle`: No I know, I'm not sure exactly what I'm fighting with now. My `TimesNat n m` is just `AddNat m (TimesNat n' m)` in the recursive case, and I've already succesfully defined `append :: _ -> _ -> Vect (AddNat n m) a`, so right now it's just me learning how to interpret GHC's error messages
23:44:59 <jle`> ah
23:45:10 <jle`> what are you using TimesNat for?
23:45:45 <sr10> infinisil : how to go about in foldl
23:46:04 <heptahedron> Oh--we had a miscommunication earlier, my vec concat is similar in semantics to `[[a]] -> [a]`
23:46:24 <heptahedron> I'm guessing that wasn't apparent when you said it should follow the same structure as my + type family?
23:47:37 <infinisil> sr10: something like `foldl (\subjects (subject, student) -> <return subjects with new entry>) subjects marks`
23:49:11 <sr10>         nlist =(\newlist -> map (\x -> (x, map(\(namestud,subjectname)->
23:49:11 <sr10>                             if (x `elem` subject)
23:49:12 <sr10>                                  then [namestud]
23:49:12 <sr10>                                 else []        )    ) subject ) marks)
23:49:13 <heptahedron> jle`: https://ibb.co/hAqBKR
23:49:20 <sr10> sorry
23:49:48 <infinisil> sr10: you probably want to use `Data.Map String String` instead of `[(String, String)]`, to have efficient and easy insertion of the accumulator
23:50:26 <heptahedron> jle`: Trying to figure out how I would most cleanly get the predecessor of `n` from `merge` so I can use it in the type application in the recursive call there
23:51:13 <infinisil> sr10: When using Data.Map you can use this function: http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Lazy.html#v:adjust
23:51:22 <sr10> infinisil: i was trying this but it give me errors
23:53:43 <jle`> ah i see, a vector of vectors
23:59:23 <jle`> heptahedron: on line 27, watch out
23:59:27 <jle`> you use type variables m and n
23:59:38 <jle`> but you also have value variables m and n, which represent different numbers
