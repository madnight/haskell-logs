00:01:10 <anohigisavay> hi. Why is `fromRight`/`fromLeft` needing an extra argument as a fallback value while `fromJust` is not?
00:01:54 <dmwit> :t fromMaybe
00:01:56 <lambdabot> a -> Maybe a -> a
00:02:00 <dmwit> fromJust is just a mistake.
00:02:21 <anohigisavay> _(:з」∠)_ ok
00:02:36 <anohigisavay> thanks
00:08:19 <jle`> :t (^?! _Left)
00:08:20 <lambdabot> Either b c -> b
00:08:47 <dmwit> I liked anohigisavay's smiley better.
00:09:05 <jle`> you just don't get modern art
00:10:32 <anohigisavay> ╮(￣▽￣)╭
00:12:45 <jle`> i concede
00:41:46 <ReinH> I just wrote collate f = fmap f . sequenceA as collate = (<$> sequenceA) <$> (<$>) to troll someone. :D
00:44:10 <dminuoso> ReinH: Understanding how <$> relates to (.) is really cool and helped me understand make sense of (.) . (.) :)
00:45:17 <alowaniak> boobs?
00:45:34 <carbolymer> where?
00:45:51 <dmwit> ugh, let's not do that
00:46:20 <jle`> one of my favorite troll haskell tricks is saying that <$> is associative
00:46:52 <jle`> (f <$> g) <$> h    ==    f <$> (g <$> h)
00:47:27 <ReinH> > let collate = (<$> sequenceA) <$> (<$>) in getZipList $ collate product (replicate 3 (ZipList [1..10]))
00:47:31 <lambdabot>  [1,8,27,64,125,216,343,512,729,1000]
00:48:54 <dminuoso> jle`: How is that troll?
00:48:59 <ReinH> (The actual use case is data Stream a = a :< Stream a and [Stream a])
00:49:16 <jle`> dminuoso: it's not really associative in the way that people usually use the word
00:49:32 <jle`> also first reaction is usually that it's a type error :)
00:49:54 <jle`> the <$'s in the first version are different than the <$>'s in the second version
00:50:12 <ReinH> (and transpose :: f (Stream a) -> Stream (f a) instead of sequenceA because I'm not going to write a Foldable for Stream)
00:50:40 <tdammers> it becomes more obvious with prefix fmap
00:51:08 <tdammers> fmap (fmap f g) h vs. fmap f (fmap g h)
00:51:18 <ij> Why does ghci take up more memory than the same thing compiled?
00:51:33 <ij> When I load all the modules, that is.
00:52:28 <dmwit> Why would you expect ghci to take up less memory than the thing compiled?
00:53:01 <ij> I don't.
00:53:44 <dmwit> Huh. Well, that's fair enough.
00:53:44 <ReinH> @jle` I'm especially proud of https://gist.github.com/reinh/d91dc44182e7e796ace0f7ea9666dbf7#file-collate-hs-L87
00:53:45 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
00:54:03 <dmwit> ij: I guess I should have just said "I don't know" to begin with. =P
00:54:23 <ij> :P
00:55:53 <dmwit> ij: Okay, I guess there's a question here. When you say "take up more memory", what do you mean exactly? If you mean "running the interpreted version of the code uses more memory than running the compiled version", well, there's no optimizations and it's using a completely different evaluation codepath.
00:56:16 <dmwit> If you mean "ghci itself takes up more memory than the size of the compiled executable", that's a completely different question.
00:57:00 * ij was thinking more about running the interpreted version, not the ghci itself, indeed.
00:57:40 <dmwit> Oh, and there's another thing about ghci that's different from the compiled version, too, which is the existence of `it`, which may keep some surprising things un-GC'd if you have forgotten about its existence.
00:58:23 <SpinTensor> Hi, I want to write a function, that reads in a few lines from stdin, parses it and returns the result of that parsing. In order to do so i need a do block. How do I tell haskell which part of the block to return as result?
00:58:40 <dmwit> SpinTensor: Mu.
00:58:47 <ReinH> jle`: please clap
00:58:54 <SpinTensor> dmwit: ?
00:59:37 <ReinH> The last line of the do block is the result of the do block
00:59:43 <dmwit> SpinTensor: The last line of a do block determines what result is produced by a monadic action. The entire do block together is used to determine the result if you don't mean "inside the monadic action".
00:59:50 <ReinH> This can involve the use of `return`, but it doesn't have to.
00:59:58 <carbolymer> SpinTensor, https://en.wikibooks.org/wiki/Haskell/do_notation#Returning_values
00:59:59 <SpinTensor> thanks.
01:00:03 <ij> dmwit, `it`?
01:00:18 <dmwit> ij: A magical variable that always refers to the result of the last computation.
01:00:42 <dmwit> % 3
01:00:42 <yahb> dmwit: 3
01:00:42 <ij> Ah, gotcha. I've seen one in ruby's interpreter.
01:00:43 <dmwit> % it
01:00:43 <yahb> dmwit: 3
01:01:12 <ReinH> It's _ in irb.
01:01:15 <ij> Yup.
01:01:18 <ReinH> or, rather, it is.
01:01:30 <ij> :P
01:01:32 <dmwit> cute =)
01:01:37 <ReinH> please clap
01:01:39 <mniip> but what is _ in irb
01:01:55 <ij> stop it with the puns
01:02:10 <ReinH> dmwit: not as cute as https://gist.github.com/reinh/d91dc44182e7e796ace0f7ea9666dbf7#file-collate-hs-L87
01:02:18 <ij> or should've I said, stop _ with the puns
01:02:34 <ertes-w> hllo
01:02:41 <ReinH> ertes-w: o/
01:02:55 <mniip> erts
01:03:36 <ReinH> hllo rts-w
01:04:06 <dmwit> ReinH: Does that end the do block?
01:04:06 <ertes-w> hi RenH
01:04:28 <ReinH> dmwit: it does not
01:04:39 <ReinH> see the output below
01:04:53 <dmwit> The output below neither confirms nor denies that the do block has ended.
01:05:08 <ReinH> dmwit: depends on what you mean by "it"
01:05:16 <mniip> huh
01:05:17 <mniip> weird
01:05:21 <mniip> check this out
01:05:27 <mniip> % :t GHC.Exts.magicDict
01:05:27 <yahb> mniip: a
01:05:32 <mniip> % GHC.Exts.magicDict
01:05:32 <yahb> mniip: ghc: ^^ Could not load 'ghczmprim_GHCziPrim_magicDict_closure', dependency unresolved. See top entry above.; ByteCodeLink.lookupCE; During interactive linking, GHCi couldn't find the following symbol:; ghczmprim_GHCziPrim_magicDict_closure; This may be due to you not asking GHCi to load extra object files,; archives or DLLs needed by your current session. Restart GHCi, specifying; the missing libra
01:05:33 <dmwit> ReinH: Your new operator ends the do block.
01:05:39 <dmwit> (I tested, so it is now no longer a question.)
01:06:44 <ReinH> dmwit: Ah yes, it does.
01:09:47 <ReinH> Not as cool as the stuff you can do with Agda but kind of cute.
01:11:23 <mniip> ooh
01:11:38 <mniip> apparently
01:15:00 <mniip> there's a wired-in rule that turns magicDict into coercion axiom applications
01:15:20 <mniip> as such magicDict's type is not expressible in haskell but it typechecks in Core
01:17:58 <ertes-w> ReinH: {-# LANGUAGE DeriveFunctor #-}
01:18:22 <ertes-w> (… and DeriveFoldable and DeriveTraversable)
01:19:35 <ertes-w> data Stream a = (:<) { head :: a, tail :: Stream a }  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
01:22:04 <ReinH> ertes-w: Yes, I wanted to write them out for pedagogic purposes.
01:22:23 <ReinH> And I specifically didn't want to write Foldable so I couldn't write Traversable.
01:22:29 <ReinH> (or derive)
01:22:48 <SpinTensor> Me again. :) I am trying to get this https://pastebin.com/14a9cerq to work. it does not compile. could somebody tell me what I'm doing wrong?
01:23:43 <ReinH> SpinTensor: the first thing you're doing wrong is not including the compiler error.
01:23:49 <ertes-w> ReinH: then at least i'd write (<*>) first and (zip = liftA2 (,))…  it's a more natural progression than going from 'zip' to (<*>)
01:23:54 <SpinTensor> sorry. just a sec
01:24:42 <ReinH> ertes-w: No, I wanted to write <*> in terms of zip.
01:24:58 <SpinTensor> https://pastebin.com/YTd7TMRi
01:26:20 <mniip> hmm
01:26:21 <mniip> interesting
01:26:22 <dmwit> SpinTensor: You might like to read sigfpe's excellent "The IO Monad for People Who Simply Don't Care".
01:26:23 <ReinH> SpinTensor: You need to use return there and on line 26, and line 22 will throw a compiler error too.
01:27:06 <dmwit> SpinTensor: You have several operations which seem to be conflating IO actions and pure actions (or expressions and statements, in the language of the suggested article).
01:28:41 <dmwit> Besides the places ReinH mentioned, you will need to modify the way you are recursing in getAtomLines.
01:28:59 <SpinTensor> how?
01:29:09 <dmwit> ?src replicateM
01:29:09 <lambdabot> replicateM n x = sequence (replicate n x)
01:29:12 <dmwit> ?src sequence
01:29:12 <lambdabot> sequence []     = return []
01:29:12 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
01:29:12 <lambdabot> --OR
01:29:12 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
01:29:20 <dmwit> That way. =P
01:29:20 <ReinH> There are... a number of issues. To fix them, you'll need to understand how to work with IO actions, which usually means learning how to work with monads.
01:29:22 <shiona> I find it useful to write out types for as many definitions as possible. It's easier to notice where the types don't match that way
01:29:24 <SpinTensor> IO in haskell is really complicated
01:29:54 <dmwit> It isn't actually that complicated. But it does require some precision.
01:29:58 <ij> This is terrible. How can an exception slip past "catchJust Just"?
01:30:03 <MarcelineVQ> relevant reading http://www.vex.net/~trebla/haskell/IO.xhtml
01:30:05 <dmwit> More precision than most languages.
01:30:17 <ReinH> Pointers are really complixated. IO is just pretty complicated.
01:30:22 <ReinH> *complicated
01:30:41 <dmwit> ij: By being of a different type than the type you tried to catch.
01:30:58 <SpinTensor> ok. i will read about the IO monad first. thanks
01:30:59 <MarcelineVQ> ij: relevant http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
01:31:14 <ij> dmwit, How can it be different than any type?
01:31:20 <ij> :t catchJust Just
01:31:21 <dmwit> ij: There is SomeException. But it's considered quite bad practice, because it's too easy to catch things you didn't mean to catch.
01:31:22 <lambdabot> Exception b => IO a -> (b -> IO a) -> IO a
01:31:28 <ReinH> Knowing whether your Java program is going to encounter a NPE is really complicated. IO is just pretty complicated.
01:31:31 <mniip> I made something potentially bad
01:31:40 <ReinH> mniip: congrats
01:31:49 <dmwit> ij: When you call `catchJust`, it doesn't match any type. It matches some concrete type that is an instance of `Exception`.
01:31:58 <dmwit> ij: If you didn't pick which concrete type, something else chose for you.
01:32:27 <ij> Are there exceptions that aren't a part of Exception?
01:32:32 <dmwit> No.
01:32:47 <dmwit> But there are many instances of Exception.
01:33:04 <dmwit> You must call `catchJust` once for each instance you care to catch.
01:33:13 <ij> I intend to catch all.
01:33:21 <ReinH> Learning how to use IO requires learning a few rules about do notation, (>>=), and pure/return; and some practice.
01:33:24 <dmwit> Then look at SomeException.
01:33:27 <mniip> % notId = reify (\p -> reflect `asProxyTypeOf` p)
01:33:27 <yahb> mniip:
01:33:32 <mniip> % :t notId
01:33:32 <yahb> mniip: b -> b
01:33:37 <mniip> % notId 123
01:33:37 <yahb> mniip: 140618187654552
01:33:52 <ij> % notId Just 3
01:33:53 <yahb> ij: Just [Segmentation fault]
01:33:57 <dmwit> % :t asProxyTypeOf
01:33:58 <yahb> dmwit: ; <interactive>:1:1: error: Variable not in scope: asProxyTypeOf
01:34:06 <ij> % notId (Just 3)
01:34:06 <yahb> ij: ; <interactive>:2:1: error:; * Variable not in scope: notId :: Maybe Integer -> t; * Perhaps you meant `notI#' (imported from GHC.Exts)
01:34:18 <mniip> well it segfaulted and lost state
01:34:30 <mniip> % :t Data.Proxy.asProxyTypeOf
01:34:30 <yahb> mniip: a -> proxy a -> a
01:34:34 <mniip> nothing too curious here
01:34:36 <ReinH> dmwit: ij wants pokemon exception handling
01:34:57 <ij> That catcher is supposed to keep the application from crashing and should report anything other than ThreadKilled.
01:35:06 <mniip> class Reify a where reflect :: a; data WrapReify a b = WrapReify (Reify a => Proxy a -> b); reify :: (Reify a => Proxy a -> b) -> a -> b; reify f y = magicDict (WrapReify f) Proxy y
01:35:25 <mniip> magicDict comes from GHC.Exts
01:36:16 <ertes-w> ij: catch c (\(SomeException ex) -> …)
01:36:35 <ij> Okay, I now see it's catching a SomeException indeed. I had that already.
01:37:03 <ertes-w> ij: this catches *everything* though, including ThreadKilled…  for most purposes that's not a good idea
01:37:28 <ertes-w> ij: for example it also catches UserInterrupt
01:37:47 <ij> It's not the main thread, so no. And in the code I filter out "ThreadKilled"s.
01:38:23 <ij> This is what my failure to catch a ConnectionError in ghci looks like: http://sprunge.us/GdOL
01:39:01 <ij> If I ignore the output of telegramMain, there's no error at all. If the handler returns a list like telegramMain, it goes past the catcher anyway.
01:39:07 <ertes-w> ij: my usual response to "i want to catch everything to prevent the application from crashing" is: use the async library
01:40:10 <ReinH> I think wanting to catch everything is a design smell
01:40:38 <ertes-w> ij: that way you can just let threads die without catching anything and have the main thread be responsible for responding to certain exceptions
01:40:58 <ertes-w> and that one can safely use something like waitCatch
01:41:00 * ReinH .oO( Pokemon Exception Handling Considered Harmful )
01:41:22 <ij> Titles with "considered harmful" in them are considered harmful
01:42:16 <ReinH> Saying that titles with "considered harmful" in them are considered harmful is considered harmful
01:43:07 <dmwit> > fix (\s -> "\"" ++ s ++ "\" considered harmful")
01:43:12 <lambdabot>  "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\...
01:43:22 <mniip> > fix show
01:43:27 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
01:43:33 <lines> :t fix
01:43:35 <lambdabot> (a -> a) -> a
01:43:42 <dmwit> (And I think my contribution was just as useful as the other "considered harmful" contributions.)
01:44:37 <ReinH> Certainly not less useful.
01:44:37 <ertes-w> *just as considered harmful
01:44:46 <ij> Okay, suppose you all think I'm doing it wrong... It should still work.
01:44:55 <ertes-w> is considering harmful considered harmful?
01:45:04 <ReinH> I didn't say you're doing it wrong.
01:45:51 <ij> ertes-w, Yes. https://meyerweb.com/eric/comment/chech.html
01:46:08 <tdammers> ertes-w: does the set of all sets that do not contain themselves contain itself?
01:47:00 <Unhammer> harm considered harmful
01:47:20 <ij> We could answer you, if only it wasn't a proper class, which isn't a set you can comprehend over.
01:47:22 <ertes-w> ij: as far as i understand you're using threads, and you want to respond to failure properly…  that pretty much sums up why the async library exists (plus some extra features that are just a product of how the library is designed)
01:47:51 <ReinH> https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions talks about some of the issues with trying to catch all exceptions and presents a potential solution using async that is probably somewhat similar to what ertes-w had in mind
01:48:08 <ij> goddamn exceptions
01:48:25 <mniip> heck why not install a SIGSEGV handler!
01:48:54 <ReinH> mniip: I like the way you think
01:49:22 <mniip> I've had too much fun with SIGSEGV handlers last few days
01:49:31 <ReinH> what if we prevent programs from crashing through sheer force of will?
01:49:55 <mniip> I like the other idea better
01:50:00 <mniip> we just let them continue execution
01:50:00 <ventonegro> required a certified Jedi
01:50:00 <ertes-w> i used to hate exceptions in haskell…  until i had to go back to a language with simpler exception semantics =)
01:50:05 <ReinH> mniip: How are they different?
01:50:25 <ertes-w> these days i appreciate async exceptions despite their learning curve
01:51:29 <ij> Are async exceptions the reason why I can't catch this ConnectionError?
01:51:43 <dmwit> ij: I have just looked at your ghci session.
01:51:46 <mniip> ReinH, prevention vs not caring
01:51:54 <dmwit> ij: I do not think you are using `SomeException` there. Did you believe you were?
01:52:12 <ij> Yes, since I have it a handler of type SomeException -> IO ()
01:52:52 <dmwit> I do not see such a handler.
01:53:45 <ij> complainUnlessTimeout
01:54:26 <dmwit> Okay. I did not see this because I am blind, not because you did not include it.
01:55:02 <ReinH> dmwit: perhaps they are evil and used some lookalike unicode letters to confuse you
01:55:22 <dmwit> This is going to sound really dumb, but: is it possible that `complainUnlessTimeout` is throwing the exception?
01:55:45 <ij> Uhm... if you wanted to see its code you could've said so.
01:56:28 <ij> It is certainly possible, but if that happens the original exception will be simply given to the next handler?
01:57:27 <MarcelineVQ> complainUnlessTimeout is your handler type?
01:57:28 <dmwit> I'm not sure I understood that. What next handler?
01:57:44 <ij> ghci's handler
01:58:42 <ij> MarcelineVQ, Y...es...? It's the handler whose type is printed at the top of the paste. Reposting a link http://sprunge.us/GdOL
01:58:45 <MarcelineVQ> in catchJust isn't Exception e fixed by your predicate (e -> Maybe b) not your handler  (b -> IO a) ?
01:58:45 <dmwit> The original exception will be swallowed, and whatever exception `complainUnlessTimeout` threw will be given to the next handler.
01:59:07 <dmwit> MarcelineVQ: `Just` causes `e ~ b`.
01:59:22 <MarcelineVQ> alrighty, pardon the interruption
01:59:39 <ij> Ah, ok. Let's put trivial code in the handler! It's still passing by. http://sprunge.us/LEiY
02:02:05 <ertes-w> ij: what happens if you use 'catch' instead of (catchJust Just)?
02:02:35 <ertes-w> it *should* be equivalent
02:02:53 <ij> It takes around a minute or so, but… it does the same thing.
02:03:55 <dmwit> neato!
02:04:11 <dmwit> This is pretty puzzling.
02:04:14 <ertes-w> ij: which telegram library are you using?
02:04:18 <ij> telegram-api
02:05:03 <merijn> Aren't they just fucking up and using throw/error instead of throwIO inside the library and leaking exceptions that way
02:05:31 <merijn> dmwit: It's not really puzzling IFF we assume the library author fucked up and doesn't throw exceptions the "right" way
02:05:57 <merijn> Because then it's just a simple case of "exception isn't getting forced until escaped from the handler
02:06:12 <dmwit> Oh, most excellent!
02:06:18 <merijn> Wrap the body of the catch with an evaluate/deepseq?
02:06:23 <dmwit> In this case, perhaps... yes, that.
02:06:34 <ertes-w> merijn: they're using 'exceptions', so that's unlikely
02:06:42 <merijn> dmwit: It's the only explanation of symptoms that makes sense, tbh
02:07:26 <ij> "evaluate =<< telegramMain token" helped!
02:07:28 <ij> hehe
02:07:51 <merijn> Bam!
02:07:54 <merijn> Told you
02:07:59 <ertes-w> ij: ah, in that case the solution is not to use the telegram-api library, because it has just lost all of its credibility =)
02:08:03 <merijn> Differential diagnosis skills are important
02:08:14 <ij> http://sprunge.us/QbNA
02:08:22 <merijn> That and/or fix/patch telegram-api upstream
02:08:30 <ReinH> ij: what's the purpose for catching all exceptions? Is it just to run some clean up? Maybe you want finally or onException instead?
02:08:30 <ij> merijn, What do you mean by differential?
02:08:43 <ij> ReinH, To report them, but keep going.
02:09:04 <ReinH> although I'll mention that if catch doesn't work, neither will either of those, since they use catch.
02:09:05 <merijn> ij: Differential diagnosis is the concept in medicine of making a list of all symptoms and ruling out causes based on missing symptoms
02:09:29 <ReinH> You want to report a SIGKILL and keep going?
02:09:34 <merijn> ij: Symptoms in this case are "catching everything and exception not being handled" <- most logical explanation, exception isn't thrown within the handler
02:10:08 <merijn> ij: If you wanna help fix upstream, the issue is basically that "throw" and "error" will not raise their exception until their value is evaluated
02:10:38 <merijn> ij: The result is (as we saw here) that if a thunk containing one of those is returned by a body within a catch, the exception will be able to "leak" out of the handler
02:11:07 <merijn> ij: The *only* safe way to throw exceptions and handle them in a catch is to ALWAYS use throwIO (or throwM if you're using the exceptions library)
02:11:25 <merijn> throwIO/throwM make use of the monad instance to guarantee the exception is returned before the action returns
02:11:52 <ij> Ah, gotcha!
02:11:53 <merijn> ij: So if you look in the telegram-api source for uses of throw or error you'll probably find the bugs
02:12:40 <merijn> (also why evaluate fixes things, because it makes sure any thunked error/throw's are forced before the catch ends)
02:14:25 <ij> I get it completely. I'll take a look at telegram-api's source.
02:14:36 <merijn> ertes-w: It lost credibility, yeah. But sometimes fixing upstream is way less work than rebuilding things from scratch. Plus, if everyone always fixed upstream everything would be better :p
02:15:04 <ij> This also explains why voiding the result resulted in no exceptions.
02:15:19 <merijn> ij: Also, if you use new-build or sandboxes you can easily use a local fixed copy to keep working until fixes get merged upstream :)
02:15:37 <ertes-w> merijn: i'm all for fixing upstream, but if an author makes these very basic mistakes, it makes me kinda worried to make myself too dependent on such a library
02:15:49 <ij> I'm using stack.
02:16:13 <merijn> ij: You can probably do the same using stack, I just have no clue how :p
02:16:20 <ertes-w> merijn: plus it's not as bad in haskell as it is in other languages to reinvent the wheel =)
02:16:34 <dmwit> merijn++ for seeing what the rest of us were blind to
02:16:47 <ij> dmwit, That's why I was here; had no clue. :)
02:16:55 <ij> merijn's always been the boss around here
02:17:03 <merijn> dmwit: I'm gonna go bask in my own glory for a bit ;)
02:17:25 <MarcelineVQ> you'd go stack unpack telegram-api  or whatever, then you'd put that dir in your packages section in your stack.yaml  the user guide will say how if your stack.yaml didn't get created with examples
02:18:25 <tdammers> alternatively, you could also fork the upstream git repo, and point stack to your fork directly, without making a local clone
02:18:33 <MarcelineVQ> actually kadoban told me you're supposed to put the path to in your extra-deps section in your stack.yaml now, though I'm not sure what that looks like exactly
02:19:03 <ertes-w> ij: you may find this useful:  egrep -R "\<throw\>"
02:19:31 <ij> I can add changed packages via stack.yml's packages and and location.git: http://…
02:19:40 <ij> merijn, FYI ^
02:20:13 <tsahyt> is there a nice lensy way for the following? I've got a Map Foo (Set Bar), and I have a new Bar that I want to add to a set indexed by a Foo which may or may not exist. if it does not exist, I'd like to insert the singleton set containing that bar at the corresponing Foo in the Map.
02:20:48 <ij> tdammers, that sounds like what I'd do.
02:20:56 <dmwit> tsahyt: I think that's what `non` is for, but I use lens so infrequently that I won't be able to help more than giving you that name to look up in the docs.
02:21:00 <ertes-w> tsahyt: M.insertWith S.union k (S.singleton x)
02:21:13 <ertes-w> tsahyt: not lensy, but nice =)
02:21:44 <MarcelineVQ> ij: you'll want to use the  - location:\n  - path/to/telegram-api\n  extra-deps: true  pattern, to tell stack telegram is a dependency and not a component of your project
02:21:59 <tsahyt> ertes-w: now that makes me wonder how union stacks up in performance when given a singleton set, compared to a more complicated solution with insert
02:22:05 <ertes-w> also beware of the At implementation for Map and friends – it uses the lazy API, which is rarely what one actually needs
02:22:37 <MarcelineVQ> ij: https://docs.haskellstack.org/en/stable/yaml_configuration/#packages-and-extra-deps
02:22:52 <ertes-w> tsahyt: it should be around the same, maybe slightly slower
02:23:33 <tsahyt> I'm starting to think that perhaps the best way to use lenses is not to use them
02:23:39 <tsahyt> for some tasks anyhow
02:24:19 <MarcelineVQ> ij: oop, darnit they changed things, that's the old way
02:24:52 <ertes-w> > M.adjust (Just . maybe (S.singleton 5) (S.insert 5)) () M.empty
02:24:54 <ertes-w> err
02:24:55 <lambdabot>  fromList []
02:24:58 <ertes-w> > M.alter (Just . maybe (S.singleton 5) (S.insert 5)) () M.empty
02:25:04 <lambdabot>  fromList [((),fromList [5])]
02:25:10 <tsahyt> > M.insertWith S.union "foo" (S.singleton "bar")
02:25:15 <lambdabot>  <Map [Char] (Set [Char]) -> Map [Char] (Set [Char])>
02:25:18 <ertes-w> > M.alter (Just . maybe (S.singleton 5) (S.insert 5)) () (M.singleton () (S.fromList [1,2,3]))
02:25:18 <MarcelineVQ> https://www.fpcomplete.com/blog/2017/07/stacks-new-extensible-snapshots is the newer way to deal with other folders
02:25:22 <lambdabot>  fromList [((),fromList [1,2,3,5])]
02:25:25 <tsahyt> > M.insertWith S.union "foo" (S.singleton "bar") M.empty
02:25:30 <lambdabot>  fromList [("foo",fromList ["bar"])]
02:25:48 <ertes-w> tsahyt: ^ this one might perform slightly better
02:26:05 <ertes-w> but personally i'd go with the insertWith variant
02:26:47 <tsahyt> as long as the insert time doesn't exceed around 4ms that's okay
02:27:03 <tsahyt> I'm confident that Map and Set can handle that
02:27:09 <dmwit> > M.fromList [(3, "a"), (4, "b")] & at 3 . non "" %~ ('c':)
02:27:14 <lambdabot>  fromList [(3,"ca"),(4,"b")]
02:27:14 <tsahyt> since neither is growing particularly large
02:27:15 <merijn> tsahyt: Honestly, I barely use lenses and only really do when some API makes me
02:27:16 <dmwit> > M.fromList [(3, "a"), (4, "b")] & at 5 . non "" %~ ('c':)
02:27:22 <lambdabot>  mueval-core: Time limit exceeded
02:27:26 <ertes-w> tsahyt: they can – in isolation…  but then there is GC, concurrency, etc.
02:27:43 <dmwit> > M.fromList [(3, "a"), (4, "b")] & at 5 . non "" %~ ('c':)
02:27:44 <tsahyt> merijn: I've just started using them for this project because they harmonize so well with acid-state's monads, and because I have some nested records there.
02:27:48 <lambdabot>  fromList [(3,"a"),(4,"b"),(5,"c")]
02:27:56 <dmwit> tsahyt: That way looks pretty clean to me, and lensy.
02:28:01 <tsahyt> and once I add a dependency on lens I have this weird quirk of trying to shoehorn it into way too many things
02:28:09 <dmwit> tsahyt: Use Set operations instead of list ones, of course.
02:28:32 <tsahyt> mhm, so how does non actually work then? what's the "" for?
02:28:42 <ertes-w> lenses are fine, but again: beware of At/at
02:28:42 <dmwit> It is the default value for when there's no key.
02:28:49 <tsahyt> ah I see
02:28:51 <dmwit> (And when the value becomes that, the key is deleted.)
02:29:11 <tsahyt> ertes-w: does ix have the same problem?
02:29:15 <ertes-w> tsahyt: yes
02:29:47 <tsahyt> ertes-w: well, I end up consuming the values immediately after in almost all cases, so I doubt it'd make a big difference
02:30:26 <ertes-w> tsahyt: you should benchmark to make sure…  lazy inserts cause unnecessary allocations
02:30:54 <dmwit> FWIW, `non v` is not quite a lens. You must use it in a special way: you must guarantee that `Nothing` and `Just v` are "the same" for all the things you care about.
02:31:00 <ertes-w> which means you create a lot more opporunities for GC to ruin your insertion times
02:31:12 <dmwit> > Just "" & non "" %~ id
02:31:16 <lambdabot>  Nothing
02:31:46 <dmwit> (Actual lenses promise that `l %~ id` is `id`.)
02:33:43 <tsahyt> ertes-w: how would I avoid at though? I end up doing lookups like that quite a bit in other parts of the code.
02:33:56 <ertes-w> tsahyt: lookups are fine
02:34:10 <tsahyt> well I also do a bunch of insertions that way
02:34:15 <tsahyt> or hang on
02:34:19 <ertes-w> tsahyt: it's modifications via 'at' where you have to be careful
02:34:46 <ertes-w> if you make sure that the new value is evaluated, then 'at' is fine
02:35:02 <tsahyt> what I end up doing is something like foo . _at "bar" . _Just . quux %= M.insert something "something"
02:35:08 <ertes-w> x `seq` (at k .~ x) xs
02:35:13 <tsahyt> oh
02:35:16 <tsahyt> well that's an easy fix
02:35:21 <ertes-w> this is equivalent to strict (insert k x xs)
02:35:29 <ertes-w> err
02:35:32 <tsahyt> all these queries take x as a parameter, I can just add a bang pattern then
02:35:33 <ertes-w> x `seq` (at k .~ Just x) xs
02:36:39 <ertes-w> tsahyt: remember that for nested maps you need to force the new submap as well, which basically means that you need to extract, force and insert an updated submap
02:37:01 <tsahyt> that sounds terribly inconvenient
02:37:30 <ertes-w> tsahyt: one solution is to write your own At instance for a newtype wrapper around Map
02:38:53 <ertes-w> the wrapper doesn't really hurt too much…  either just use the wrapper all around, or use the Iso that lens will happily generate for you, if you ask for it
02:38:55 <tsahyt> isn't there some way to implement an at' on top of the existing at, which seqs the changes first?
02:47:12 <ertes-w> @let at' k f x = (\y -> y `seq` (at k .~ y) x) <$> (f y') where y' = view (at k) x
02:47:14 <lambdabot>  Defined.
02:47:20 <ertes-w> tsahyt: this is very ugly though
02:47:43 <ertes-w> it needs two operations
02:48:13 <ertes-w> > (at' () .~ 5) (M.singleton () 4)
02:48:18 <lambdabot>  error:
02:48:18 <lambdabot>      • No instance for (Num (Maybe Integer))
02:48:18 <lambdabot>          arising from a use of ‘e_154’
02:48:46 <ertes-w> also what the hell did i just write?
02:48:48 <ertes-w> @undef
02:48:48 <lambdabot> Undefined.
02:49:05 <ertes-w> @let at' k f x = (\y -> y `seq` (at k .~ y) x) <$> f (view (at k) x)
02:49:08 <lambdabot>  Defined.
02:49:13 <ertes-w> > (at' () .~ Just 5) (M.singleton () 4)
02:49:16 <lambdabot>  fromList [((),5)]
02:49:18 <tsahyt> so you'd be using at once in order to perform whatever operation you want to perform, then view it in order to seq it, and then put it back?
02:49:21 <ertes-w> err, still not quite right
02:49:32 <ertes-w> @undef
02:49:32 <lambdabot> Undefined.
02:50:14 <tsahyt> I'd be surprised if a newtype wrapper for strict At operations on Map didn't already exist somewhere
02:50:48 <ertes-w> @let at' k f x = maybe (at k .~ Nothing) (\y -> y `seq` (at k .~ Just y)) x <$> f (view (at k) x)
02:50:50 <lambdabot>  Defined.
02:50:54 <ertes-w> this one is correct
02:51:34 <tsahyt> now there are three ats in there
02:52:12 <ertes-w> > (at' () .~ Just undefined) (M.singleton () 4) `seq` ()
02:52:16 <lambdabot>  error:
02:52:16 <lambdabot>      • Couldn't match type ‘M.Map () Integer’
02:52:16 <lambdabot>                       with ‘Maybe (IxValue (Maybe a0))’
02:52:43 <ertes-w> :t at'
02:52:46 <lambdabot> (Index b ~ (), At b, Functor f) => () -> (Maybe (IxValue b) -> f b) -> Maybe (IxValue b) -> f b
02:53:15 <ertes-w> something is wrong with me today
02:53:28 <ertes-w> anyway, that's the idea
02:53:55 <ertes-w> how did () get there?!
02:54:45 <tsahyt> Index b ~ (). why it infers this, I don't know
02:55:16 <tsahyt> > (at' "foo" .~ Just 5) (M.singleton "foo" 4)
02:55:21 <lambdabot>  error:
02:55:21 <lambdabot>      • Couldn't match type ‘M.Map [Char] Integer’
02:55:21 <lambdabot>                       with ‘Maybe (IxValue (Maybe a))’
02:56:03 <ertes-w> i messed that one up completely
02:56:09 <ertes-w> @undef
02:56:09 <lambdabot> Undefined.
02:57:10 <ertes-w> @let at' k f x = flip (maybe (at k .~ Nothing) (\y -> y `seq` (at k .~ Just y))) x <$> f (view (at k) x)
02:57:13 <lambdabot>  Defined.
02:57:14 <ertes-w> :t at'
02:57:16 <lambdabot> (Functor f, At s) => Index s -> (Maybe (IxValue s) -> f (Maybe (IxValue s))) -> s -> f s
02:57:23 <ertes-w> ah, that's more like it
02:57:29 <ertes-w> > (at' () .~ Just undefined) (M.singleton () 4) `seq` ()
02:57:35 <lambdabot>  *Exception: Prelude.undefined
02:57:40 <ertes-w> > (at () .~ Just undefined) (M.singleton () 4) `seq` ()
02:57:44 <lambdabot>  ()
02:57:46 <ertes-w> there we go
02:59:12 <ertes-w> it's still bad though…  there is probably a better way
03:03:10 <ertes-w> hmm, no, not with the Functor constraint
03:03:29 <ertes-w> with Monad there would be a way
03:05:18 <Boarders> If I use typeNats then I have the method natVal :: forall n proxy. KnownNat n => proxy n -> Natural
03:05:31 <Boarders> which gives me back a natural from Numeric.Natural
03:05:42 <Boarders> does anyone know how I can then get an Int back
03:05:55 <phadej> fromIntegrala . natval
03:05:58 <phadej> fromIntegral . natval
03:06:07 <Boarders> that is for TypeLits I think
03:06:19 <Boarders> which returns an Integer
03:06:25 <phadej> note: Integral
03:06:28 <phadej> :t fromIntegral
03:06:30 <lambdabot> (Num b, Integral a) => a -> b
03:06:31 <Boarders> sorry
03:06:44 <Boarders> thank you
03:06:53 <phadej> you're welcome
03:18:25 <ij> I'm getting a ErrorCall (it's a String, right), which `show`s up as/contains ConnectionError. Does that mean the telegram-api code that throws it has screwed something up?
03:20:13 <mniip> ConnectionError is a constructor of ServantError
03:20:34 <mniip> which contains inside a SomeException
03:20:46 <mniip> are you sure you're not reading it backwards?
03:22:07 <ij> That's what I expected by looking at what it's printing, but look: http://sprunge.us/KObE
03:24:12 <mniip>   showsPrec _ (ErrorCallWithLocation err "") = showString err
03:24:30 <mniip> the servant code called 'error (show err)'
03:25:38 <ij> Why downgrade it into a String?
03:29:24 <mniip> what else
03:30:27 <ij> I'm assuming it had a ServantError, which implements Exception — why not throw that?
03:32:43 <mniip> hmm
03:32:49 <mniip> how are you calling it
03:32:56 <mniip> which function is throwing
03:34:23 <ij> runTelegramClient https://github.com/klappvisor/haskell-telegram-api#readme
03:35:17 <ij> It looks like I have "runClient" in my code, maybe because there's a newer version on github. https://github.com/siers/zn/blob/wip/silence-timeouts/src/Zn/Telegram.hs#L94
03:35:43 <mniip> hmm
03:36:03 <mniip> I'm seeing catchConnectionError :: IO a -> IO (Either ServantError a)
03:36:43 <ij> I have to leave for a bit, sorry. I'll look up anything you'll might've here said later.
03:36:47 <mniip> so presumably something even deeper throws
04:19:25 <centril> At it simplest, can `CoArbitrary a` be seen as a function:  :: a -> Rng -> Rng  ?
04:19:44 <centril> variant being defined as:  variant k (MkGen g) = MkGen (\r n -> g (variantQCGen k r) n)
04:36:00 <lyxia> centril: yes
04:38:40 <centril> lyxia: hmm, do you know how  `variantQCGen k r` works?
04:39:04 <centril> Trying to encode the same idea as CoArbitrary in Rust
04:46:10 <lyxia> Not exactly but I guess the idea is to map integers to a prefix-free set of paths to split a generator into many independent ones
04:49:13 <centril> lyxia: OK; thanks =)
05:50:55 <merijn> ugh...am I the only one who keeps forgetting the right extension name for quasiquoters?
05:58:10 <unclechu> Guys, if anyone have faced stack build plan constructing fails with old LTS (such as `3.x`) due to some package revision you could just explicitly set revision of a package to `extra-deps` section to fix it, e.g. `- semigroupoids-5.0.0.4@rev:0`.
05:58:10 <unclechu> But this works only in latest `stack` releases `1.6.x`, maybe in `1.5.x` too, but not in `1.4.x`.
05:58:11 <unclechu> See also: https://github.com/fpco/stackage/issues/3185
05:59:22 <ggVGc> I fail stack building at least once a month :(
05:59:34 <ggVGc> but not that particular thing
06:03:32 <Axman6> unclechu: as pointed out in the reddit discussion, LTS versions that old should be considered completely unsupported. the reasons for those breakages are mostly justifyable imo
06:06:36 <catern> are there any typed build systems?
06:07:19 <unclechu> Axman6: anyway, it's good that we could fix it right now, because there's some huge business projects that couldn't be migrated to newest lts release in day or two
06:07:32 <AWizzArd> catern: what would their purpose be? What do you have in mind?
06:07:40 <MarcelineVQ> catern: possibly shake, haven't tried it  https://hackage.haskell.org/package/shake
06:08:06 <catern> AWizzArd: I don't know, just wondering if there's anything that can be called "a typed build system" for any language
06:08:52 <AWizzArd> catern: in that case one could argue that all of them are typed.
06:09:06 <merijn> Can "lookupTypeName" only lookup public/exported types?
06:09:43 <mniip> hmm
06:09:53 <mniip> I see at least 3 IRC libraries on hackage but none of them are good enough
06:10:30 <mniip> ertes-w,
06:10:32 <catern> AWizzArd: well, I mean, make for example is definitely unityped... everything is a file
06:10:39 <mniip> I saw yours in particular
06:10:55 <geekosaur> a truly typed build system would have to own the entire toolchain, and know particulars in detail for every platform
06:11:13 <merijn> If yes, can I somehow get TH to look up a non-public type?
06:11:30 <merijn> Alternatively, I can always safely unsafeCoerce a newtype to it's original type, yes?
06:11:58 <lyxia> yes @unsafeCoerce
06:12:13 <geekosaur> merijn, http://hackage.haskell.org/package/true-name ?
06:12:26 <merijn> geekosaur: I'm using true-name
06:12:29 <mniip> merijn, do you not have the constructor in scope?
06:12:33 <AWizzArd> catern: is   CC=gcc   also considered a file?
06:12:48 <merijn> geekosaur: But I'm only able to truename unexported constructors of exported types
06:13:00 <merijn> geekosaur: I can't seem to get it to summon unexported types
06:13:11 <merijn> mniip: I have neither constructor nor type in scope
06:13:17 <geekosaur> I'm guessing those can be unavailable completely
06:13:22 <mniip> fun
06:13:38 <merijn> mniip: I'm already resorting to true-name to get the newtype I'm trying to access
06:13:51 <merijn> But now I still can't get inside the newtype
06:14:13 <merijn> Unless I unsafeCoerce, which would be more brittle than truename (since that'd at least fail at compile time if things change)
06:14:20 <geekosaur> ummmm
06:14:35 <geekosaur> is its role nominal? if not, there's Data.Coerce
06:15:17 <merijn> geekosaur: GHC doesn't derive Coercible instances for newtypes where the constructor is not in scope
06:15:26 <merijn> geekosaur: Already tried that
06:15:37 <mniip> yeah that's what my question was about
06:16:08 <geekosaur> this is sounding severely unsafe to me
06:16:23 <merijn> If I had the constructor in scope I wouldn't have to resort to truename in the first place
06:16:30 <merijn> geekosaur: Well of course, else what's the fun?
06:16:31 <geekosaur> anything you come up with will be on the same order as unsafeCoerce, and you could badly break code elsewhere
06:17:27 <merijn> geekosaur: I can either patch several levels of upstream libraries, wait for the improvements to get merged upstream, etc. OR I can just forcibly grab the pointer I want with unsafe brute force and splice in a one line code change to make things work for me
06:18:24 <ertes-w> mniip: my what?  i just reconnected
06:18:34 <mniip> 1515679769 [17:09:29] <mniip> I see at least 3 IRC libraries on hackage but none of them are good enough
06:18:51 <ertes-w> don't use mine…  currently i recommend irc-core
06:18:57 <ertes-w> by glguy
06:19:31 <merijn> geekosaur: If you have a solution that doesn't involve days/weeks of patching upstream libraries and even more weeks getting them merged, I'm all ears. But if not, severely unsafe solutions it is
06:19:44 <geekosaur> I don't. I don;t think there is one
06:20:07 <geekosaur> I am considering the reason this restriction exists in the first place, which is fun stuff like building illegal Data.Map-s
06:20:14 <geekosaur> (i.e. unsorted)
06:20:49 <geekosaur> since I have no idea what you are doing, I will just assume you know what you are doing and point ot unsafeCoerce
06:20:59 <geekosaur> because I''m pretty sure that's your only option
06:21:16 <ertes-w> i wrote fastirc almost a decade ago when the landscape of IRC libraries was even worse than today
06:21:39 <mniip> hmmm
06:21:51 <mniip> there needs to be a class for stringy datatypes
06:22:22 <ertes-w> mniip: the mono-traversable library attempts to classify listy/stringy types
06:22:30 <ertes-w> but i think it's far from ideal
06:22:41 <merijn> geekosaur: Interacting with SQLite through a library that does not export the entire SQLite API, so either I rewrite tons of Haskell code to switch to a different library, or I patch upstream, or I forcibly grab a pointer to the database, perform the API call I need via FFI and be on my way. Considering I have a paper deadline in 2 weeks, any solution requiring lots of rewriting/time is out, so hence the
06:22:41 <mniip> I mostly mean generic uncons, and fromChar
06:22:47 <merijn> horrible solution
06:23:54 <ertes-w> mniip: BTW, i think a "good enough" IRC library can't exist…  irc-core is about as close as you can get
06:23:55 <geekosaur> I'd patch upstream with an Internal module exporting the thing wanted, tbh
06:24:28 <mniip> ertes-w, tbh I'd separate reponsibilities as much as possible
06:24:35 <merijn> geekosaur: I already opened a ticket for that, but I don't wanna wait for days/weeks for upstream
06:24:36 * z0ttel sometimes learns new languages by implementing irc
06:24:44 <mniip> let one package do a simple job but do it really well
06:25:09 <ertes-w> mniip: that's what irc-core does…  as you can see it has no network dependencies, it literally only implements the protocol
06:25:15 <mniip> hmm mono-traversable doesn't seem to generalize uncons
06:25:20 <merijn> geekosaur: That's the kinda stuff I can do *after* my experiments are running
06:26:03 <ertes-w> IRC is a mess of weird extensions, network-specific protocol customisations, numerics that mean different things depending on network and context, etc.
06:26:09 <mniip> right
06:26:38 <phadej> mniip: https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Cons.html#t:Cons
06:26:50 <mniip> ooh
06:26:52 <z0ttel> irc-core looks neat.
06:26:53 <mniip> that's something
06:27:30 <mniip> phadej, now I just need a generalized character literal pattern
06:27:34 <phadej> > _Cons # ('x', _Empty # ()) :: String
06:27:38 <lambdabot>  "x"
06:27:50 <phadej> "a bit ugly"
06:28:07 <phadej> > _Cons # ('x', _Empty # ()) :: BSC.ByteString
06:28:10 <lambdabot>  error:
06:28:10 <lambdabot>      • Couldn't match type ‘Word8’ with ‘Char’
06:28:10 <lambdabot>          arising from a functional dependency between:
06:28:12 <mniip> it's less ugly than that one time I wrote a complete IRC syntax parser with bytestring
06:28:26 <phadej> :)
06:28:31 <mniip> with no view patterns
06:28:38 <mniip> just case BS.uncons of...
06:29:04 <mniip> actually that's not all
06:29:10 <mniip> I think I also need a generalized span
06:29:27 <mniip> but that's not a lawful lens if used improperly
06:29:53 <dminuoso> Im looking for something like Integer -> Integer -> [Integer] that produces a list from a starting value to an stopping value. Ive done some digging on Hoogle but came up short. What should I be looking for?
06:30:03 <mniip> dminuoso, enumFromTo
06:30:10 <dminuoso> mniip: Ahh! Thanks.
06:30:24 <mniip> [x .. y] is sugar for  enumFromTo x y
06:30:34 <ertes-w> mniip: in a new version of fastirc that i never released i dispensed with attoparsec and just used (StateT ByteString Maybe)…  it's a lot cleaner than hand-rolling the parser and at the same time faster than attoparsec
06:30:42 <dminuoso> mniip: Ohh, I actually tried (..) realizing that it must have been syntax sugar.
06:31:01 <ertes-w> i used enumerator for reading from the network, splitting into lines, truncating the lines, etc.
06:31:10 <mniip> ertes-w, irc is too simple to use a parser
06:31:28 <mniip> not only it's a DCFL,
06:31:36 <mniip> it's a regular language
06:31:42 <z0ttel> https://github.com/Zottel/Aurora/blob/master/irc.lua#L87
06:31:59 <mniip> z0ttel, let me pull out some code from 2013 real quick
06:32:05 <ertes-w> when does a protocol get "too simple"?  i draw the line where there is no choice
06:32:14 <ertes-w> (that is (<|>))
06:32:23 <ertes-w> IRC definitely has choice
06:32:57 <ertes-w> :blah PRIVMSG blubb :hello there
06:33:02 <ertes-w> :blah PRIVMSG blubb hello
06:33:06 <ertes-w> PRIVMSG blubb hello
06:33:07 <ertes-w> etc.
06:33:43 <mniip> z0ttel, https://github.com/mniip/xsBot/blob/master/xsbot.lua#L77-L92
06:33:44 <mniip> :D
06:33:47 <z0ttel> using a parser may produce more readable code anyway
06:34:02 <mniip> ertes-w, it's a linear grammar
06:34:12 <ertes-w> (StateT ByteString Maybe) is also a parser monad =)
06:34:20 <mniip> which is the same as regular language, really
06:34:36 <mniip> ertes-w, that's even worse than StateT String
06:34:58 <mniip> z0ttel, I wasn't kidding when I said 2013
06:35:38 <z0ttel> apart from a security fix, mine was from 2010 :-P
06:36:46 <ertes-w> mniip: huh?
06:39:43 <merijn> Is there an easy way get GHC to make a "Ptr CInt"? i.e. a global variable and give me pointer to that?
06:40:26 <ertes-w> merijn: same way you create a global IORef
06:40:32 <Axman6> unsafePerformIO $ malloc (sizeOf (0::CInt))?
06:40:34 <ertes-w> use unsafePerformIO + NOINLINE
06:40:49 <Axman6> yeah NOINLINE is important
06:41:33 <merijn> Actually, I just realised I have to write a tiny C wrapper anyway, so I'll just dump it in the c file
06:41:57 <merijn> Axman6: Malloc'ing static variables as awful >.<
06:43:38 <ertes-w> GHC really wants to allocate stuff dynamically…  i don't think there is a straightforward way to use the linker
06:49:36 <mniip> merijn, actually yes
06:49:41 <mniip> you can
06:50:29 <mniip> at least with functions it works, like this https://github.com/mniip/hexchat-haskell/blob/master/HexChat/Internal.hs#L129-L130
07:00:20 <infty[m]> Is f :: a -> a necessarily the identity? Here a is a type variable.
07:00:35 <ertes-w> infty[m]: if you ignore bottoms, yes
07:01:06 <ertes-w> there are three values of type (forall a. a -> a):  (\x -> x), (\_ -> undefined), undefined
07:02:02 <liste> but note that in eg. foo :: (a -> a) -> Int -> a -> a the (a -> a) may be something else than "id"
07:03:05 <mniip> yeah it's important to note the quantifications in cases like these
07:03:11 <mniip> f :: forall a. a -> a
07:03:29 <mniip> (as opposed to f :: exists a. a -> a)
07:14:38 <infty[m]> Thanks. Is this proved somewhere? or generally, what kind of formalism is used to prove such statements?
07:16:14 <merijn> infty[m]: Look up the paper "Theorems for Free!" by Wadler
07:16:53 <merijn> infty[m]: The relevant formalism here is "free theorems", which covers "what can we say about parametrically polymorphic functions based on their parametricity"
07:17:23 <Vyse007> merijn: Looks like an interesting read, thanks for the info!
07:20:28 <merijn> Vyse007: If you like that kinda thing, the paper "Fast and Loose Reasoning is Morally Correct" is also nice (although completely unrelated to free theorems, etc.)
07:21:15 <merijn> Vyse007: That paper is basically "why it's ok to pretend your haskell code is total when proving things"
07:21:34 <dminuoso> infty[m]: The case of `a -> a` is simple though. If you think about it a bit, there's only one way to implement it (ignoring bottoms)
07:21:54 <dminuoso> infty[m]: THe thing is, it has to be so general as to work with any type `a`, so it cant do anything type specific..
07:22:22 <Vyse007> merijn: Heck yes, such papers are always fun. Just finished reading through "Can programming be liberated from the Von-Neumann style" and it was quite the eye opener.
07:22:25 <merijn> Vyse007: Also, the Fast and Loose paper also means "we can get away with not saying "ignoring bottoms" everywhere when talking about haskell" :)
07:22:43 <Vyse007> merijn: The "morally correct" part makes it sound even more interesting.
07:22:45 <mniip> or alternatively,
07:22:50 <mniip> read up on profunctors and ends
07:23:42 <dminuoso> infty[m]: Also note that in `f :: a -> a` a has to be a type variable because its lowercase. :-)
07:23:52 <merijn> Vyse007: The short summary is "if you prove property X for a function F in total version of a language, then property also holds for F in a non-total version IFF none of the inputs to F are bottom"
07:27:49 <Vyse007> merijn: Thanks for that summary. There's some (from the looks of it) tough math in that paper, so I'll take probably weeks to fully understand it through.
07:28:23 <merijn> Vyse007: The exact proof is kinda tricky and sophisticated, but if you just skim the start you can get the gist of it without fully understanding the exact proof
07:30:45 <Vyse007> merijn: As all such proofs are. :). I mostly stumble around the category theory parts since I have no knowledge of it beyond hask.
07:32:10 <metahumor> proofs? who needs proofs? just draw squares with arrows
07:32:29 <mniip> those rigorously translate to rigorous proofs though
07:32:29 <metahumor> two arrows end at the same point. qed
07:32:39 <phz_> hey
07:32:46 <phz_> is there a profunctor typeclass for arr?
07:32:53 <phz_> (Profunctor p) => (a -> b) -> p a b
07:33:06 <mniip> no, there are profunctors that aren't
07:33:28 <dminuoso> metahumor: https://ro-che.info/ccc/29 =)
07:34:31 <tdammers> as long as your squares and arrows follow rigorously defined rules, you're good
07:34:43 <metahumor> dminuoso: wonderful!
07:35:08 <mniip> phz_, how would you implement such a function for the 'Forget r' profunctor
07:35:18 <mniip> it would effectively be
07:35:23 <mniip> (a -> b) -> a -> r
07:35:28 <mniip> can't do that
07:35:40 <phz_> ?
07:35:47 <phz_> Forget r a b
07:35:47 <phz_> oh
07:35:48 <phz_> right.
07:35:49 <phz_> :D
07:38:14 <mniip> hmm
07:38:38 <phz_> mniip: actually, that’s logical
07:38:38 <phz_> (Profunctor p) => dimap :: (c -> a) -> (b -> d) -> p a b -> p c d
07:38:55 <phz_> there’s no relationship between a/c and b/d
07:39:02 <phz_> so it cannot even happen
07:40:11 <mniip> imagine a system F-typed polymorphic lambda calculus without constraints
07:40:35 <mniip> we could add a primitive dimap :: (a -> b) -> (c -> d) -> p a d -> p c b
07:40:40 <mniip> forall p!
07:40:43 <mniip> without breaking parametricity
07:41:24 <mniip> no
07:41:34 <mniip> dimap :: (a -> b) -> (b -> a) -> p a -> p b
07:42:05 <mniip> which should really be named invmap then
07:47:36 <Vyse007> n
07:48:04 <Vyse007> apologies; is there a good reference book to learn more about lambda calculus?
07:48:22 <Vyse007> as in, beyond the basics of it.
07:50:13 <lyxia> @where tapl
07:50:13 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
07:54:05 <Philonous> Vyse007, Depends on what you mean by basics. I've read Hindley, Seldin - "Lambda-Calculus and Combinators", it gives a nice overview. If you want a more complete monograph there's Barendreght - "The Lambda Calculus, Its Syntax and Semantics"
07:55:26 <Philonous> Barendregt*
07:55:43 <shlevy> I'm getting a segfault with ./Setup configure for my package (when building static binaries, so not a normal env). Any tips on debugging this?
07:55:47 <Vyse007> lyxia: I've tried getting my hands on TAPL; couldn't find a copy in nearby libraries and the ones I found online are expensive.
07:56:06 <Vyse007> Philonous: Those sound interesting. Thanks for the suggestions.
07:56:28 <Philonous> Vyse007, TAPL is about type systems, not so much lambda calculus. Still can recommend it very highly
07:57:47 <ezyang_> There's also the Yellow Book (Lectures on the Curry-Howard Isomorphism)
07:58:23 <Vyse007> Philonous: Yeah it seems to be the definitive book when it comes to type systems. I wish it wasn't $70 though. :-/
07:59:10 <lyxia> Sorry to hear that :/
07:59:41 <lyxia> Printed book can be so expensive
07:59:49 <Philonous> Vyse007, Libgen has it
07:59:53 <shapr> but you get to write in the margins of printed books!
08:00:24 <Vyse007> ezyang_: Just looked at a copy online and it definitely looks interesting.
08:01:38 <Vyse007> Philonous: Yeah, if I can't find it anywhere for cheap I will have to resort to libgen. :*(
08:04:03 <Philonous> Get the 2MB verison though, the larger 12MB one is junk
08:04:07 <Philonous> version*
08:05:24 <phz_> is there such a thing as an applicative profunctor? :D
08:05:33 <Peter123> Hi all!
08:05:34 <Peter123>   Is anyone familiar with 'HaskellR' or 'inline-r' to call R code?
08:06:07 <Philonous> @ask
08:06:07 <lambdabot> Who should I ask?
08:06:57 <Philonous> @Peter123, You're better of just asking your question, it's unlikely someone will commit to helping you before they know what your problem is
08:06:58 <lambdabot> Unknown command, try @list
08:07:04 <Philonous> Darn it
08:09:03 <Peter123> I'm just looking now if I can come up with a short example.
08:09:16 <Peter123> I would help others.
08:10:46 <lyxia> phz_: that's pretty much product-profunctor and https://github.com/lysxia/profunctor-monad
08:11:20 <phz_> let me check
08:11:48 <phz_> oh yeah, it’s Biapplicative
08:12:21 <phz_> though it needs Biapplicative f and Biapplicative g
08:12:28 <phz_> which is not possible if they’re Profunctors
08:12:34 <phz_> because contravarian in the first argument
08:18:09 <mnoonan> phz_: the first answer here might be interesting; it just addresses the question of what a CoApplicative class would look like: https://cstheory.stackexchange.com/questions/16241/is-there-a-concept-of-something-like-co-applicative-functors-sitting-between-com
08:18:26 <phz_> mnoonan: I’m trying to write one as a mental excercice
08:18:27 <jason85> How do I combine every two adjacent elements in a list using a binary operator? e.g. [x1,x2,x3,x4] becomes [x1 `f` x2, x3 `f` x4]
08:19:17 <mnoonan> phz_: the tl;dr is you're going to have problems
08:23:27 <Philonous> > let frob f (x:y:zs) = f x y : frob f zs; frob _ _ = [] in frob (+) [1..7]
08:23:32 <lambdabot>  [3,7,11]
08:25:19 <jason85> thanks!
08:36:32 <michi7x7> > foldl1 (+) <$> chunksOf 2 [1..6]
08:36:36 <lambdabot>  [3,7,11]
08:39:46 <__monty__> Can you use operator syntax with functions that take more than 2 arguments?
08:40:35 <geekosaur> I would expect so, and the result would be a partially applied function
08:41:56 <pmade> Does this function exist (or a more general version of it): MaybeT m (Maybe a) -> MaybeT m a
08:42:29 <Philonous> > let twiddle a b c = a + b * c in (5 `twiddle` 2) <$> [1..4]
08:42:34 <lambdabot>  [7,9,11,13]
08:45:34 <centril> I think I have an understanding of why   (CoArbitrary a, Arbitrary b) => Arbitrary (a -> b)  does not shrink the function or the `b`  - but just in case I don't... why doesn't it?
08:47:20 <Philonous> :t maybe empty return -- Can't think of a premade function, but this is pretty short
08:47:22 <lambdabot> (Monad f, Alternative f) => Maybe a -> f a
08:48:29 <pmade> Philonous: yep, that's basically what I've been doing.
08:54:45 <__monty__> geekosaur: Yes, I expected this as well, turns out I didn't completely understand the precedence. Thank you.
08:55:21 <cheater> hi
08:55:26 <cheater> what is constant folding?
08:56:10 <glguy> https://en.wikipedia.org/wiki/Constant_folding
08:57:24 <cheater> ah yeah thanks
08:57:45 <cheater> funny i googled haskell constant folding, constant folding optimization, etc, but i didn't google just constant folding
09:05:13 <centril> Is  https://hackage.haskell.org/package/QuickCheck-2.10.1/docs/Test-QuickCheck-Gen.html#t:Gen  essentially just  ReaderT QCGen (Reader Int)  ?
09:07:17 <lyxia> yes
09:07:55 <centril> great =)
09:09:43 <ReinH> centril: https://hackage.haskell.org/package/QuickCheck-2.10.1/docs/src/Test-QuickCheck-Gen.html#Gen
09:10:18 <centril> ReinH: I know that it is a newtype over  :: QCGen -> Int -> a
09:10:20 <centril> =)
09:10:24 <ReinH> ok
09:10:39 <ReinH> @unmtl ReaderT a (Reader b) c
09:10:39 <lambdabot> a -> b -> c
09:10:58 <centril> haha, nice bot command
09:11:54 <centril> trying to port CoArbitrary over to Rust, so just checking everthing so that translation is done faithfully
09:12:10 <ReinH> Nice
09:13:08 <ReinH> geekosaur: pigworker in particular is fond of binary operators that take three arguments
09:15:22 <centril> ReinH: pigworker = Conor McBride?
09:15:27 <ReinH> yeah
09:15:32 <centril> I love that guy
09:15:38 <ReinH> samesies
09:15:44 <centril> He hates unicode in Agda, I hate unicode in Agda
09:16:25 * centril starts a new religion devoted to Conor to rival the church of emacs.
09:17:16 <parsnip> if a troll were to get people to take sides on "i prefer this web framework!", what might percentage be towards Yesod here?
09:17:20 <ReinH> I'm ok with unicode in Agda though
09:17:32 <centril> ReinH: blashemy!
09:17:41 <Philonous> He such a tease though. Wets our appetite with SHE (or is it HER in this context?) but now we have to hope for Richard Eisenberg to deliver the real thing
09:17:42 <centril> blasphemy*
09:18:03 <centril> Philonous: what's the state of dependent haskell anyways atm?
09:18:08 <parsnip> i suspect this is like how pythonistas mostly seem to use django, but some prefer the "stay out of my way" of flask.
09:18:42 <Philonous> centril, So far it's vaporware. Goldfirere anounced he'd try to implement it over the coming summer
09:19:09 <centril> cool, I thought we'd have to wait until 2020 or so
09:19:21 <Philonous> Well, with any look we won't have to.
09:19:28 <Philonous> Although 2020 isn't so far away now.
09:19:37 <centril> Philonous: heh :P
09:19:56 <centril> Philonous: We have more than dependent types to look forward to for 2020
09:19:57 <Philonous> I'd be happy if I knew for sure we'd have it by then.
09:20:15 <Philonous> Linear types too, yeah. Anything else you're thinking off?
09:20:41 <centril> Philonous: A certain someone not being a certain house that will go unnamed.
09:20:56 <Philonous> I should coax someone into writing inline-rust for haskell. I don't want to write low-level code in C.
09:21:18 <centril> Philonous: inline-rust ?
09:21:29 <glguy> inline-rust for Haskell already exists
09:21:35 <Philonous> Really?
09:21:50 <centril> Philonous: (you'll have Arbitrary for all libstd types in Rust soon btw, as well as custom deriving Arbitrary)
09:21:59 <glguy> https://github.com/harpocrates/inline-rust
09:22:01 <centril> well... all owned types in libstd
09:22:25 <centril> glguy: that is way cool
09:22:56 <Philonous> glguy, Oh wow, I was looking for that the other day and couldn't find it. The old adage still holds, the best way to get an answer on IRC is to claim something and wait for someone to correct you.
09:22:58 <centril> can we unsafePerformIO that :P
09:23:01 <Philonous> Anyway, thanks :)
09:23:41 <Philonous> centril, Is that the same Arbitrary as in Haskell's QuickCheck? That's nice.
09:23:44 <tromp> i wrote some haskell code long ago that no longer compiles. ghci now says things like  Could not find module ‘FastString’
09:23:44 <Philonous> I'm still new to rust.
09:24:14 <tromp> what's the best way to install modules on Mac Osx ?
09:24:49 <centril> Philonous: Yeah - see:  https://docs.rs/proptest/0.3.4/proptest  and  https://docs.rs/proptest-arbitrary/0.2.2/proptest_arbitrary/  and  https://github.com/Centril/proptest-derive
09:24:54 <centril> some parts are WIP
09:25:32 <centril> Philonous: hopefully you'll also be able to custom-derive recursive sum types
09:25:56 <centril> (but not corecursive types cause that's just not possible afaik)
09:26:29 <Philonous> glguy, That still requires a patched GHC and is not released on hackage let alone stackage. But I'm really happy it exists. :)
09:27:25 <lavalike> tromp: try cabal install?
09:27:34 <nshepperd> soon: a version of djinn that simply sends the claim "type X has no inhabitants" to a chat channel, and waits for someone to post a term that type checks
09:28:01 <tromp> i tried stack install but it says Unknown package: FastString
09:28:12 <Philonous> centril, Corecursive type as in codata?
09:28:30 <tromp> i think the package name may differ from Module name
09:29:07 <kadoban> tromp: Module names usually do not correspond to package names, correct. The only FastString I see is a GHC internal thing I've personally never heard of
09:29:28 <centril> Philonous: minimal failing example:  #[derive(Debug, Aribitrary)] enum Foo { A, B(Hide) }  struct Hide(Box<Foo>);
09:29:33 <tromp> how do you find what package provides a Module?
09:29:46 <geekosaur> if it's installed, ghc-pkg find-module Module
09:29:46 <kadoban> tromp: hoogle or hayoo usually
09:29:54 <centril> Philonous: no way to tell that there's a Foo inside Hide from the text of Foo
09:30:11 <tromp> @hoogle FastString
09:30:12 <lambdabot> module FastString
09:30:12 <lambdabot> FastString data FastString
09:30:12 <lambdabot> FastString FastString :: Int -> Int -> ByteString -> IORef (Maybe FastZString) -> FastString
09:30:36 <geekosaur> and I don't know FastString offhand. there's FastPackedString which is the primordial ooze version of ByteString
09:30:39 <Philonous> centril, That's isomorphic to [A], isn't it? (As I said, I'm new to rust)
09:30:44 <glguy> Philonous: not being on stackage isn't really an issue, but getting the support added to GHC for registering the object files will be important
09:31:00 <tromp> ok, running stack install ghc-8.2.2
09:31:18 <tromp> thx, geekosaur
09:32:26 <glguy> tromp: You're about to find out that doesn't work
09:32:35 <tromp> Verification error: Invalid hash for <repo>/01-index.tar.gz
09:32:39 <centril> Philonous: Yeah, think so - tho that was not the point =)  you can write:  enum List<T> { Nil, Cons(Box<T>) }  and we can derive Arbitrary for that just fine
09:33:03 <centril> Philonous: tho a word of warning: linked lists are bad.
09:33:10 <Philonous> centril, So what's the problem then? Mutual recursion?
09:33:25 <tromp> Cannot update index (update failed twice)
09:33:26 <Philonous> centril, Worse than in other languages?
09:33:26 <kadoban> tromp: Sounds like you have really old stack. But also that's not going to work. You'll have to learn a little bit about how stack works
09:33:44 <centril> Philonous: Just as bad as in C++
09:34:05 <tromp> i have stack 1.6.3
09:34:16 <kadoban> Hm, not sure what that error is then.
09:34:31 <centril> Philonous: the problem is that with mutual recursion or just hiding, you don't know about where the recursion of the Self type is
09:34:50 <glguy> Yeah, I get the stack error about indexes, too; but you also can't run the command you were trying even if the indices are working
09:34:53 <centril> anyways... afk
09:35:29 <tromp> glguy: any suggestions on what i can do?
09:35:37 <glguy> tromp: What are you trying to do?
09:36:09 <tromp> run some old code i wrote that uses modules like FastString
09:36:27 <Philonous> centril, I don't see why that would be a problem. I would have assumed that all you needed to know is that Hide implements Arbitrary. But I'll play around with it figure it out ;)
09:36:30 <glguy> tromp: If you want to use an older GHC you need to pick a different stack resolver
09:36:41 <glguy> Or the same for newer GHC
09:36:55 <kadoban> tromp: Do you know what version of GHC it worked with? Also is it a whole project with multiple files, or just a single .hs file?
09:36:56 <tromp> i want to run latest ghc and adapt my code if necessary
09:36:57 <glguy> If you want to depend on modules in the ghc package you need to add that to your .cabal file
09:37:16 <geekosaur> is that indexes thing related to http://mail.haskell.org/pipermail/haskell/2018-January/025325.html ?
09:37:24 <tromp> the code is at https://github.com/tromp/AIT
09:37:42 <tromp> just trying to run ghci BLC
09:37:48 <geekosaur> (I see a reply from snoyman saying it shouldn't be but he didn't know for cetain)
09:37:50 <centril> Philonous: Arbitrary is still WIP; so don't play around with it yet :P  but the reason it won't work is that you will blow the stack cause Rust is strict, not lazy
09:38:30 <tromp> the code is spread over a few hs and lhs files
09:38:47 <tromp> dont remember what version of ghc it used to work with
09:38:52 <Philonous> centril, Oh, of course, no codata in strict languages.
09:40:30 <kadoban> tromp: Is there a whatever.cabal file? You'll want to run "stack init" if so, and then assuming it doesn't figure it out for you, you'll have to try modifying the stack.yaml file a bit to get the right resolver and etc.
09:40:52 <kadoban> tromp: Maybe you can tell from the time period or what's in the .cabal file what version of GHC and etc.
09:41:37 <tromp> i dont remember ever making a cabal file
09:41:58 <glguy> tromp: You'll need one unless your plan is to call ghc directly
09:42:00 <kadoban> Well ... I mean there should either be one there or not, right?
09:42:45 <tromp> it used to work without. i used to be able to call ghc directly
09:43:02 <glguy> tromp: You can still call GHC directly, you just don't need stack to do that
09:43:21 <geekosaur> it's using a makefile
09:43:35 <kadoban> Oh I didn't see the link to the code
09:43:36 <geekosaur> I'm afraid to ask what ghc version this was written for originally
09:44:04 <tromp> make blc no longer works
09:44:46 <tromp> it was written before there was stack
09:46:36 <tromp> i used this interpreter to help me write http://www.ioccc.org/2012/tromp/tromp.c
10:00:33 <int-e> tromp: I think you're mixing something up there, that file contains a ghc plugin and I'm pretty sure I know who wrote that one.
10:01:00 <tromp> you did?
10:01:14 <int-e> (It's bitrotted too, doesn't work on ghc-8.2, only on ghc-8.0)
10:01:54 <tromp> ah yes, history shows its yours
10:02:35 <tromp> even atribution at top shows
10:03:00 <tromp> was too focussed on trying to make it compile to even pay attention :-(
10:03:08 <int-e> tromp: anyway, cabal sandbox init; cabal install dlist mtl; cabal sandbox exec make blc
10:03:12 <int-e> tromp: try that :)
10:05:47 <tromp> i revisited BLC because someone made a video of beta reduction on lambda diagrams
10:06:26 <tromp> see the video link on http://tromp.github.io/cl/diagrams.html
10:07:51 <Psybur> Describe applicative in one sentence. Go!
10:09:13 <mnoonan> "Applicatives are just lax monoidal enofunctors; what's the problem?"
10:10:29 <MarcelineVQ> a Type that implements a function of a -> Type a  and a function of  Type (a -> b) -> Type a -> Type b
10:10:57 <MarcelineVQ> That satifies the Applicative laws. Damn, two sentences.
10:12:02 <centril> Philonous: you can get codata in strict languages by indirection
10:12:28 <centril> but the generation of arbitrary has to end somewhere
10:13:54 <tromp> int-e: cabal: Unknown 'sandbox' subcommand: exec make blc
10:16:13 <geekosaur> cabal exec make blc
10:16:18 <geekosaur> (no "sandbox")
10:16:25 <geekosaur> which is annoyingly inconsistent...
10:19:25 <dmwit> Psybur: I usually think of Applicative as being a way to zip together two data structures. There are only a few exceptions where this intuition doesn't really work well. Ironically, lists, which are the data type used in actual `zip`, are one of the exceptions.
10:27:13 <Peter123> Hi again
10:27:52 <Peter123> I just found out today that the standard sort in R is about twice as fast as the best Haskell sorting algorithm.
10:28:13 <Peter123> With the latter I mean vector-algorithms sorting unboxed mutable vectors
10:28:27 <centril> Peter123: are both sequential?
10:28:43 <Peter123> The high performance group asked me to prepare a reddit post to discuss thing further
10:28:50 <amalloy> interesting. i haven't thought of that perspective before, dmwit, and it doesn't immediately make sense to me. it seems reasonable for something like optparse-applicative, or Maybe/Either, but many things i can think of, such as Parser, (->), and of course lists, it doesn't feel right to me
10:29:03 <Peter123> I could of course be an error by the microbenchmarking libs or so
10:29:33 <Peter123> centril: do you mean 'not in parallel'?
10:29:53 <centril> Peter123: yes, non-parallel sequential sorts
10:29:57 <Peter123> So the sorting benchmark is sorting 10 000 Int values in the range from 1 to 1000.
10:30:33 <Peter123> I did benchmark also parallel sorts in Haskell and in R and both were about the same speed or even slower
10:31:38 <Peter123> Now, I tried to call the the R sort function from Haskell
10:31:49 <Peter123> But the overhead is too much
10:31:57 <concatmap> Is it possible to get ghci to tell you the specialized type for all functions of a particular instance?
10:32:13 <Peter123> centril: Do you know any fast sorting algos in haskell (perhaps parallel ones)
10:32:16 <concatmap> Eg if I want to see the type information for all the functions of Traverseable []
10:32:38 <Peter123> Here is the code that uses the R sort in Haskell:
10:32:39 <Peter123> https://gist.github.com/stephano33/f2dcac0bbf9b817812355265d73ae36e
10:32:53 <Peter123> Can this be made faster?
10:32:58 <centril> Peter123: can't say I do - do check that they are using the same algorithm tho in Haskell & R - are both timsort for example?
10:34:09 <Peter123> Now the C++ version is even 25% faster than the R sort.
10:34:29 <Peter123> But I don't know yet how much overhead it takes to pass 10 000 values (Ints or Double) to C FFI
10:36:46 <dmwit> amalloy: Okay, let me try to convince you it makes sense for (->).
10:37:13 <glguy> Peter123: There's probably a lot going on, but do note that this ! is basically not doing anything at all: let ! list = l :: [Double]
10:37:44 <Peter123> I just wanted to evaluate that beforehand.
10:37:54 <dmwit> amalloy: I'd like you to think of `a -> b` as a data structure which stores a bunch of `b`s. Each `b` is indexed by an `a`, and you can recover the `b` you care about by providing its index. (Like a Map, or an Array.)
10:38:03 <glguy> All that ! does it evaluate the first list cons cell
10:38:19 <glguy> it doesn't have anything to do with the random number generation or the rest of the list
10:38:22 <amalloy> okay, sold
10:38:24 <dmwit> amalloy: Now the Applicative instance combines the values at corresponding keys -- "zipping" together the same positions in the two structures.
10:38:28 <dmwit> amalloy: yay =)
10:38:43 <Peter123> glguy: okay, thx
10:40:09 <mnoonan> dmwit: aw, you took the easy case. what about parsers, or anything that isn't built on a representable functor?
10:41:17 <glguy> Peter123: At a minimum you can use evaluate and force together to do what you meant to : https://hackage.haskell.org/package/deepseq-1.4.3.0/docs/Control-DeepSeq.html#v:force
10:41:29 <glguy> see the 3rd example
10:41:49 <dmwit> mnoonan: Parsers are harder, I agree.
10:43:06 <Peter123> :glguy thx. Did that; runtime stayed the same.
10:48:26 <dmwit> From the list of Applicative instances, here are ones where it makes sense to me: Maybe, IO, Last, First, Product, Sum, Identity, ZipList, Max, Min, Either e, (,) a, ST is a bit of a stretch, Compose, TMap. One can make a ZipTree, as well.
10:49:07 <metahumor> why not List?
10:49:23 <metahumor> i mean, the traditional List instance
10:49:39 <dmwit> I have the nondeterministic Applicative instances (like [] and Tree) in a separate mental category.
10:49:45 <dmwit> I don't really see a way to understand those as "zippy".
10:50:02 <metahumor> inner "product" vs outer "product"
10:50:56 <dmwit> I don't remember enough about inner product and outer product for clause to be helpful on its own, but it wouldn't surprise me if I had to have separate mental categories for those, too. =)
10:51:00 <dmwit> (I am weak.)
10:51:17 <metahumor> inner product v1 v2 = zipWith (*) v1 v2
10:52:15 <metahumor> outer product v1 v2 = [[a * b | b <- v2] | a <- v1]
10:52:39 <metahumor> ie liftA2 (*) v1 v2 without the concat at the end
10:52:41 <dmwit> Ah, right, it's transpose v1 `matrix_product` v2 vs v1 `matrix_product` transpose v2, right?
10:52:48 <dmwit> I definitely have different mental categories for those.
10:52:53 <dmwit> They have completely different dimensional behavior.
10:52:59 <mnoonan> right
10:53:05 <metahumor> right, i'm just saying that traditional Applicative for List is like the outer product, almost
10:53:14 * dmwit nods agreeably
10:53:24 <metahumor> and traditional "zipWith" for List is like the inner product, almost
10:53:25 <mnoonan> though you can get inner from outer via a trace..
10:53:39 <metahumor> yeah, because they're both operations on the exterior algebra blah blah
10:53:48 <mnoonan> I wonder if you can get ziplists as some kind of trace of lists..
10:53:59 <metahumor> you can do outer on vectors of different "dimensions" though
10:54:08 <dmwit> mnoonan: Yes, I'm finding a blog link, one moment.
10:54:15 <metahumor> you can't really do inner on Vec 3 and Vec 4
10:54:23 <ph88> where do the ghc binaries come from that stack downloads to my pc ?
10:55:52 <dmwit> mnoonan: I think the discussion of the connection between monoid structures on R and comonads on (R -> a) at the very end of this is basically what you're hoping for.
10:55:57 <dmwit> https://byorgey.wordpress.com/2011/05/09/themes-on-streams/
10:56:18 <metahumor> is there a List-like where the Applicative instance is more like zipWith?
10:56:26 <metahumor> Linear.Vs?
10:56:37 <dmwit> metahumor: Yes, ZipList
10:56:40 <metahumor> great
10:57:02 <mnoonan> dmwit: interesting, thanks!
11:12:34 <drbcladd> \whois mh2[m]
11:13:27 <eL_Bart0-> your mommy ;>
11:15:12 <MarcelineVQ> got'em
11:20:10 <Lokathor> i open up the fancy new GHC and it's spitting all sorts of bad control codes into my console :(
11:22:00 <MarcelineVQ> color codes?
11:22:10 <Lokathor> i'm assuming it's trying and failing to to color, yes
11:23:13 <MarcelineVQ> see if  -fdiagnostics-color=never  does anything    -fno-diagnostics-show-caret  is used by tooling so it may be of interest as well
11:23:58 <Lokathor> nope on the first one
11:24:18 <Lokathor> nope on the second
11:25:08 <Lokathor> does it in both the VS Code terminal (a spoofed cmd.exe basically) and actual cmd.exe
11:26:03 <MarcelineVQ> you using the vscode plugin? should check their git about it if they have one
11:54:24 <Lokathor> MarcelineVQ, I might figure this out later, but the VS Code repo thing seems to have no issues about it. However, I also managed to blend ansi-term and haskeline, so that's cool
11:54:48 <Lokathor> (but sadly you have to jump in and out of haskeline mode every step of the way)
12:15:41 <amir_> .exit
12:18:57 <mirpa> How do I catch 'read' exception?
12:19:25 <kadoban> mirpa: Use readMaybe or others instead.
12:19:32 <mirpa> like in 'read "x" :: Int"
12:19:57 <mirpa> kadoban: but how would you do it?
12:20:05 <mirpa> with exception handling
12:20:39 <kadoban> That type of error is not very sane to try to catch. IIRC there's some hacky thing that kind of works, I don't remember the details.
12:21:00 <mirpa> '((pure $ read "my error") `catch` (\(SomeException _) -> pure 0))' gives me exception
12:21:09 <kadoban> "read" is not for serious work. Anytime I want to do anything except explode in a fire when something goes wrong, I'd use sometihng else.
12:22:05 <Philonous> mirpa, Your monadic action returns a thunk that's only evaluated once you're outside the exception handler
12:22:12 <Philonous> That's why you're getting an exception.
12:22:17 <amalloy> you probably need `evaluate` or something
12:22:29 <mirpa> ah, I see
12:22:34 <Philonous> pure $! read "my error" should do the trick
12:22:55 <mirpa> oh yea $! works, thanks!
12:29:09 <centril> Is there a particular reason that it is defined this way:  instance CoArbitrary a => CoArbitrary [a] where coarbitrary [] = variant 0 ; coarbitrary (x:xs) = variant 1 . coarbitrary (x,xs) ;
12:29:26 <centril> instead of  (xs,x)
12:29:54 <centril> coarbitrary (x, y) = coarbitrary x . coarbitrary y
12:30:06 <centril> so y perturbs first, and then x
12:30:33 <us_r-1> hi all - I'm quite new to Haskell, I'm trying to use Google's OAuth2 api on a project I'm doing, and I found the hoauth2 package. I've come to the conclusion that it does not support the 'authenticate with a back end server' flow (https://developers.google.com/identity/sign-in/web/backend-auth). I've done this by reading the code and seeing that the IdToken data type isn't used anywhere. I'm new to
12:30:39 <us_r-1> Haskell so I can't make sense of much of the code. Is anybody here familiar enough with the package to either confirm or refute my claim?
12:31:29 <lyxia> centril: no
12:31:42 <centril> lyxia: so it just as well be the reverse?
12:31:48 <centril> could just*
12:31:50 <lyxia> centril: yes, you can say it's an arbitrary definition of coarbitrary
12:31:57 <centril> lyxia: haha :P
12:32:26 <centril> lyxia: good, then I'll reverse it to not blow the stack and write an iterative version of it =)
12:34:22 <shapr> centril: is your port on github?
12:34:28 <amalloy> us_r-1: it looks like IdToken is used in one place, namely as a field in the OAuth2Token type
12:34:50 <shapr> jaså: https://github.com/Centril/proptest-arbitrary
12:34:50 <centril> shapr: yeah, but it's not production ready yet
12:34:57 <shapr> centril: jättekul :-)
12:35:10 <centril> shapr: why the Swedish :P ?
12:35:13 <amalloy> and so any functions that accept an OAuth2Token may by extension use IdToken despite not directly mentioning it in their type
12:35:21 <lyxia> centril: it might be that although the generator gets passed from right to left, the seed goes through variant 1 then coarbitrary x then coarbitrary xs
12:35:35 <shapr> centril: well, your hostname says telia
12:35:43 <shapr> and it's fun to speak Swedish
12:35:45 <centril> shapr: =)
12:36:47 <centril> lyxia: hmm... but it is essentially defined as   variant 1 . coarbitrary x . coarbitrary xs
12:37:05 <centril> is the real order the reverse?
12:38:47 <us_r-1> amalloy: yes, I saw that too. I can't find any usage of the record name 'idToken' though, which is why I assume that the workflow I'm after is not supported. The two usages (normal and offline) seem to be specific to the server-side app workflow (they use auth codes)
12:39:28 <lyxia> centril: variant k g = \r n -> g (variantQCGen k r) n.   variant 1 (variant 2 g) = \r n -> variant 2 g (variantQCGen 1 r) n = \r n -> g (variantQCGen 2 (variantQCGen 1 r)) n
12:40:11 <lyxia> What I mean is that the order in which the "variants" are applied to the seed is reversed
12:41:37 <tsahyt> I noted earlier today that Set is Foldable but not Traversable. Why is that?
12:41:51 <amalloy> us_r-1: at a glance i'm inclined to agree with you that IdToken is never used. but i'm not an expert
12:42:19 <amalloy> tsahyt: because of the Ord constraint for building sets
12:42:37 <us_r-1> amalloy: thanks for your help
12:42:56 <tsahyt> oh, Traversable also has Functor as a superclass
12:43:09 <centril> lyxia: oh yeah, so in imperative code it would really be  variant(rng, 1); coarbitrary(rng, x); coarbitrary(rng, xs);
12:43:26 <tsahyt> so that'd also be a problem
12:43:30 <tsahyt> amalloy: are those two related problems?
12:43:40 <amalloy> tsahyt: yes, i think so
12:44:02 <amalloy> :t sequence_
12:44:04 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
12:44:14 <amalloy> :t sequenceA_
12:44:16 <lambdabot> (Applicative f, Foldable t) => t (f a) -> f ()
12:44:24 <amalloy> :t traverse
12:44:28 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:46:26 <amalloy> you can't do the thing traverse wants to do for a set, because you can't fmap the (a -> f b) over the Set a
12:46:42 <amalloy> and also it has to work for any b at all, not just Ord b
12:47:12 <amalloy> but you can't build a Set b without Ord b
12:51:06 <tsahyt> ah I see
12:51:09 <tsahyt> :t Data.Set.map
12:51:11 <lambdabot> Ord b => (a -> b) -> S.Set a -> S.Set b
12:51:21 <tsahyt> ah that has the extra Ord constraint on b
12:52:09 <infandum`> How does one use the Streaming.Cassava library? https://hackage.haskell.org/package/streaming-cassava-0.1.0.0/docs/Streaming-Cassava.html
12:52:26 <infandum`> I try a simple example, Streaming.Prelude.print $ (decode NoHeader (BS.readFile "./test.csv") :: (MonadResource m, MonadError CsvParseException m, MonadIO m) => Stream (Of [String]) m ())
12:53:57 <infandum`> That fails though, as "m0" is ambiguous. Unfortunately, with the IO monad it says " Couldn't match type 'GHC.IO.Exception.IOException' with 'CsvParseException". I would only be using the IO monad, though.
12:55:30 <amalloy> it wants you to use ErrorT
12:56:53 <amalloy> or you can use decodeWithErrors to handle the errors explicitly instead of monadically
13:09:25 <Math22232> is it possible to get this list: https://pastebin.com/A77ZWi5h into a function with using only the monad operation ">>" ?
13:10:46 <koala_man> without >>= ?
13:10:47 <lyxia> Math22232: it's not clear what you're asking
13:11:08 <Math22232> koala_man, yes
13:11:30 <Math22232> lyxia, I wanna transform the list into a function with using only ">>"
13:11:31 <amalloy> Math22232: "only the operation >>" is not well defined. are we allowed to, for example, use the (+) function?
13:11:40 <Math22232> amalloy, yes
13:11:42 <amalloy> transforming a list into a function is also very strange and underspecified
13:11:51 <Math22232> amalloy, but not ">>="
13:12:01 <Math22232> or do
13:12:31 <lyxia> what is that function supposed to do
13:12:51 <lyxia> and why does it have to use >>
13:12:55 <Math22232> lyxia, showing the list like solution
13:13:01 <Math22232> lyxia, for practice purposes
13:13:35 <koala_man> write it in a non-monadic way then?
13:14:02 <Math22232> koala_man, no I have to use ">>"
13:14:32 <amalloy> Math22232: write the thing you want to do, without the restriction of "using only >>", whatever that means, then go back and see if you can transform it to satisfy your restrictions
13:14:38 <koala_man> Math22232: runIdentity $ return () >> f
13:14:48 <tsahyt> amalloy: it does sound like some sort of exercise in desugaring list comprehensions
13:15:37 <metahumor> koala_man: do you understand what the "<-" and "|" syntax desugars to?
13:15:46 <metahumor> i mean, Math22232
13:16:12 <Math22232> metahumor, yes
13:18:49 <ralu> y is by >>= dependent on z, but using >> trows that info away
13:19:11 <Math22232> ralu, yes that's my issue
13:19:27 <Math22232> I have no clue how to do that
13:22:16 <jle`> it's not possible
13:22:20 <jle`> that's the point
13:22:39 <jle`> oh sorry, i gave it away ><
13:24:41 <infandum`> amalloy: The "r" value (the last part of the stream) in decodeWithError is quite big (Either (CsvParseException, ByteString m r) r) and I just can't get it to work. Have you seen any examples of its use? The only example I can find is from https://www.tweag.io/posts/2017-11-01-streaming-and-foldl.html but that is a bit more than my test case.
13:26:19 <Math22232> jle`, yeah I also think that
13:26:55 <jle`> Math22232: it's impossible to "use only >>" when the choice of your future action depends on the result of a previous action
13:27:38 <jle`> Math22232: here, the "size" and contents of your 'y' action depends on the result of the 'z' action
13:30:56 <Math22232> jle`, yeah, I had an idea about using this [0..] for an infinite loop, and counting z up, but it failed, at the counting part
13:31:03 <Math22232> anyway
13:31:30 <Math22232> I will give up, thanks to all, who tried to help me
13:40:23 <jle`> Math22232: it is possible if you use filters after-the-fact, and also if you're willing to be extra inefficient
13:40:41 <jle`> but it'd be very different
13:47:49 <Math22232> jle`, filters are a very good idea, I'm gonna mess around a bit with it
14:06:58 <fizzgig> does anyone know the right way to downgrade cabal with stack? It ignores what I've set in extra-deps (dunno why it would look there but still) and stack setup --install-cabal 1.24.2.0 fails looking for process >=1.1.0.1 && <1.5
14:07:26 <fizzgig> which is also in extra-deps as process-1.4.3.0
14:08:03 <fizzgig> I expect I'm missing some field which will let me specify dependencies for stack setup but it eludes me
14:09:01 <fizzgig> I'm doing this because my build is failing and I suspect the messages about stack not being tested with Cabal-2.0.1.0 have something to do with it
14:09:52 <lyxia> fizzgig: that sounds like an old version of stack
14:11:32 <lyxia> since 1.6 it uses Cabal 2.0 so it is a strange error message to have
14:11:49 <fizzgig> it tells me it's 1.6.3
14:15:06 <fizzgig> maybe I'm wrong about the cabal version being the problem but master on the stack github has stack solver complaining about anything above 1.24
14:15:51 <fizzgig> https://github.com/commercialhaskell/stack/blob/0d848deac8e541aa40c5ab5bc784bb9d3ec2928a/src/Stack/Solver.hs#L320
14:25:32 <fizzgig> my actual problem is that c2hs isn't finding some intermediary file, I get c2hs: x.chi not found in .stack-work/dist/x86_64-linux-tinfo6-nopie/Cabal-2.0.1.0/build
14:25:46 <fizzgig> if anyone has a solution to either that would be awesome
14:40:35 <nut> class Show (layout a) => LayoutClass layout a where
14:40:53 <nut> Does LayoutClass has two parameters?
14:40:59 <nut> layout and a?
14:41:16 <nut> or one, (layout a)
14:41:23 <pavonia> Two
14:42:33 <pavonia> It's basically the same as with function application, "f x y" has two parameters, "f (x y)" only one
14:42:57 <nut> and x itself is a function that takes a parameter, a
14:42:59 <nut> ?
14:43:01 <jle`> also the same as with function definition, foo x y = ...
14:43:21 <xs2> can I get some resources for boobs
14:43:26 <xs2> noobs
14:43:26 <nut> because (layout a) is a thing, a type
14:43:38 <jle`> nut: yes
14:43:43 <jle`> that's the 'kind inference' at work :)
14:43:55 <jle`> LayoutClass is a higher-kinded typeclass
14:44:10 <jle`> 'layout' has to have kind k -> *
14:44:14 <jle`> 'a' has to have kind 'k'
14:44:23 <nut> i see
14:44:47 <nut> because i read that multiparameter typeclass describe relationship between types
14:44:50 <jle`> whatever kind 'a' is , it has to be the same kind as whatever 'layout :: k -> *' takes
14:45:26 <nut> here i don't get that layout and a are related
14:45:40 <jle`> LayoutClass *is* the relatoinship
14:45:51 <nut> okay
14:45:55 <jle`> the fact that together, there is a LayoutClass instance, is the reulatnioship
14:46:08 <jle`> the contents of the class will probably elaborate more on what kind of relationship this is
14:47:22 <nut> thanks man
14:48:09 <xs2> where do noobs go to learn Haskell?
14:48:26 <erisco> xs2, they stay right here
14:48:49 <xs2> I'll stay for sure but I need a book or something
14:49:20 <nut> xs2: search jekor haskell from scratch in youtube
14:49:51 <xs2> I prefer books to be honest
14:49:58 <xs2> too much happening in a video
14:50:16 <nut> xs2, you can pause a video. haskell books are real pain to read
14:50:17 <jle`> there's that haskell-from-first-principles book that's been going around, but i haven't read it myself
14:50:37 <jle`> it's gotten decently popular though
14:50:47 <jle`> with good reviews in general :)
14:51:09 <xs2> I'll find something online for sure, just thought there was *the* book
14:51:15 <xs2> approved by #haskell
14:51:20 <malorie> what about 'learn you a haskell'?
14:51:56 <erisco> xs2, http://lpaste.net/3776661586295390208
14:52:08 <xs2> also might I ask in a nutshell why Haskell over <insert language of choice>?
14:52:08 <erisco> everyone annotate with your favourite books for beginners
14:52:39 <erisco> xs2, why Haskell over Haskell? well because Haskell.
14:52:39 <nut> jle`, in what circumtances do you think of using multiparameter typeclass? i mean typeclass with one parameter is quite intuitive
14:52:52 <xs2> lpaste link isn't opening for me
14:53:17 <xs2> no, seriously
14:53:18 <nut> jle`, with several it's still weird somehow. could you put it in english to describe when you consider using it?
14:53:30 <erisco> also, it looks like lpaste links got longer
14:53:43 <jle`> nut: the biggest usage in modern haskell code is probably with mtl's typeclasses
14:54:08 <jle`> nut: 'MonadState s m' is a typeclass whose instances say that 'm' has some state of type 's'
14:54:16 <erisco> one small step for a man, one giant misadventure for mankind
14:54:37 <jle`> nut: another common usage (that is a little less universally appreciated) is for conversion typeclasses
14:54:50 <xs2> can you put that in another pastebin, erisco?
14:54:57 <erisco> nope
14:55:07 <jle`> nut: like `class Convert a b where convert :: a -> b`
14:55:07 <nut> jle`, that's really vague relation between 'm' and 's'. will that help ghc type system?
14:55:10 <xs2> no worries
14:55:17 <xs2> you're just a smartass anyhow
14:55:30 <jle`> nut: yes it's actually very hard, you need something called FunctionalDependencies to mak eit practical to use
14:55:49 <jle`> that's why 'Convert' classes are not used very often, too, cause it's hard for type inference
14:55:55 <erisco> check back in some time and it will be working again. lpaste sometimes has issues.
14:55:59 <jle`> but some people like them for things like string conversions
14:56:06 <jle`> instance Convert Text String where convert = unpack
14:56:25 <jle`> nut: but MultiParamTypeclasses + FunctionalDependencies are pretty powerful
14:56:37 <erisco> if you're impatient the check out the Haskell website and wiki where you can find ample learning resources
14:56:54 <jle`> nut: the common example is like, class MonadState s m | m -> s
14:57:03 <erisco> also, lpaste uses Google Analytics, boo
14:57:15 <jle`> nut: which says that knowing 'm' uniquely determes 's'
14:57:17 <s4ke1> jle` : sometimes they can work without fundeps as well
14:57:27 <s4ke1> but i agree, with fundeps they are actually useful
14:58:25 <jle`> really though you can say the same thing as MultiParamTypeClasses + FunDeps for MonadState using normal typeclasses and Type Families
14:58:51 <jle`> with associated types
14:58:53 <nut> jle`, and type families are used to describe more complex relationship between types right?because you write type level functions
14:59:45 <nut> jle`, while functionaldependencies are just | m -> s
14:59:57 <jle`> i'm not sure if i'd say more complex, but they do open different kind of doors
15:00:04 <hololeap> i'm looking for a brief summary of the differences between conduit and pipes, both in terms of functionality and how mature the ecosystem surrounding them is. on first glance, it looks like conduit has more libraries built up around it
15:00:14 <jle`> nut: well, that's just as complex as the version using type families/associated types
15:00:18 <jle`> on one hand you have:
15:00:27 <jle`> class MonadState s m | m -> s where
15:00:28 <nut> jle`, imean functional depency only says that m uniquely determines s, but without elaborate more on how
15:00:29 <jle`> and on the other you have:
15:00:40 <jle`> nut: well, type families too, same thing
15:00:44 <jle`> the person who writes the instance gets to decide
15:01:12 <jle`> class MonadState m where type StateOf m :: *
15:01:21 <jle`> you could write an instance for 'State s'
15:01:28 <jle`> the first way it'd be:
15:01:34 <jle`> instance MonadState s (State s)
15:01:40 <jle`> the second way it'd be:
15:01:53 <jle`> instance MonadState (State s) where type StateOf (State s) = s
15:02:13 <jle`> you can kind of see how they're basically the same thing/have the same power
15:02:45 <jle`> whatever answer you put as the definition of the type family StateOf, you could just put as for the 's' parametere in the MPTC version
15:03:12 <nut> thank you again
15:03:29 <jle`> no problem!
15:04:08 <jle`> for what it's worth, both versions of mtl's typeclasses where floated, and the MPTC version won for some reason
15:04:19 <jle`> but you see the type families/associated types version here to compare https://hackage.haskell.org/package/mtl-tf-0.1/docs/Control-Monad-State-Class.html
15:04:34 <jle`> oh it looks like that version doesn't use associated types, like modern haskell would
15:05:29 <jle`> another example where mptc vs. tf played out, but type families won out, is mono-traversable
15:09:44 <erisco> hololeap, it doesn't matter which one you pick because the grass is always greener on the other side
15:12:13 <iqubic> How are my fellow haskellers?
15:14:33 <Rembane> Alive and well. I got stuck in a monad, can't get out.
15:15:14 <erisco> import Unsafe.Coerce
15:16:12 <Rembane> erisco: Thank you, that fixed my problem.
15:16:35 <Adluc> :D
15:16:48 <iqubic> Unsafe.Coerce is a weird thing?
15:17:20 <Rembane> It is totally safe as long as you don't use it.
15:17:53 <erisco> my problem is different… I tried to get into an comonad last night but they kicked me out :(
15:17:59 <Rembane> :(
15:18:11 <jle`> eitherToMaybe :: Either e a -> Maybe a; eitherToMaybe = unsafeCoerce
15:18:44 <iqubic> What is a Comonad?
15:19:02 <jle`> @hackage comonad
15:19:02 <lambdabot> http://hackage.haskell.org/package/comonad
15:19:24 <jle`> a cmonad is a monad but the arrows are reversed
15:19:40 <jle`> instead of return :: a -> m a, you have extract :: w a -> a
15:19:43 <jle`> etc.
15:19:48 <iqubic> No applicative constraint?
15:20:31 <iqubic> Also, why is that useful at all?
15:21:07 <amalloy> iqubic: a zipper is a common example of a comonad
15:21:19 <iqubic> It is? How the heck?
15:21:51 <amalloy> a zipper is a list with a focus position. extract :: [a] -> a gets you the item at the "cursor"
15:21:52 <jle`> iqubic: why are comonads useful, or why is the concept of a comonad/having a comonad typeclass useful?
15:22:18 <jle`> for the first question, comonads themselves are each useful types in and of themselves
15:22:21 <jle`> like tuples
15:22:24 <jle`> tuples are p useful
15:25:45 <iqubic> Why is the concept of Comonad useful? Other than Zippers, what comonads exist?
15:27:45 <lyxia> trees (with values on every node) and streams
15:28:06 <lyxia> spreadsheets/cellular automata
15:28:07 <amalloy> i think that the "co" in comonad means they are the categorical dual of monads. i'm not totally sure, but i believe this means that every monad has a comonad, which is a different way of working with a similar structure
15:28:55 <Logio> this is a nice example IMO: https://jaspervdj.be/posts/2014-11-27-comonads-image-processing.html
15:28:56 <iqubic> So what's the comonad of State?
15:29:10 <Rembane> Store I think
15:29:29 <Rembane> http://comonad.com/reader/2018/the-state-comonad/ :D
15:29:36 <edwardk> =)
15:42:16 <kakashiAL> why do they call a function an "application" ?
15:46:14 <yushyin> they?
15:46:47 <Rembane> kakashiAL: Do you have a context?
15:48:40 <kakashiAL> Rembane: in some articles and books I read "application" referenced to the function or if you have a function foo :: a -> b -> c  and if you call the function like this:   foo a  <---you call this "partial application"
15:51:17 <Rembane> kakashiAL: Yes, the function is applied to a value, which in this case gives you a new function.
15:51:45 <kakashiAL> Rembane: thats currying, but that not the answer to my question :)
15:52:22 <yushyin> kakashiAL: the term 'application' is most likely borrowed from lambda calculus
15:52:53 <kakashiAL> yushyin: could you tell me why the term is used here to have a better mental picture?
15:53:34 <hololeap> https://en.wikipedia.org/wiki/Function_application
15:54:39 <hololeap> wow, i didn't know $ was used that way outside of haskell
15:56:15 <amalloy> well. that's a single article that cites no sources. it might have been written by some haskell guy
15:56:23 <amalloy> so you still don't really know that
15:56:24 <yushyin> kakashiAL: because you apply arguments to a function and that’s the name for it (what Rembane said is not false at all)
15:57:23 <hololeap> amalloy: yeah, it seems like a bizarre notation just to appear outside of programming
15:57:34 <yushyin> kakashiAL: https://en.wikipedia.org/wiki/Lambda_calculus
16:01:23 <dmwit> kakashiAL: "why do they call a function an 'application'?" They don't. They call a lambda term which applies a function to a value an application. The fact that the result of this application is a function is coincidental; it would still be an application if the result were not a function.
16:01:24 <yushyin> kakashiAL: most functional programming languages are somewhat based upon lambda calculus so it’s not surprising to see similar/borrowed terms
16:02:47 <dmwit> And now I've been a bit imprecise. What I *should* have said was that they call a lambda term which applies a lambda term to another lambda term an application. Whether the former is a function; whether the latter is a value; or whether the result is a function are all immaterial.
16:04:06 <yushyin> dmwit: +1
16:29:55 <troydm> troydm
16:30:29 <troydm> anyone has any idea how to create invisible cursor using X11 package? it doesn't exposes a lot of stuff that is necessary to do that
16:30:55 <troydm> sorry messed copy/paste a bit
16:31:59 <[Leary]> Have a look at hhp, provided by xmonad-utils.
16:33:14 <troydm> [Leary]: wow, thx will take a look
16:35:52 <kakashiAL> https://paste.xinu.at/WLzI/
16:36:10 <kakashiAL> yushyin: thats what I was looking for ^  :)
16:43:15 <[Leary]> I don't think the the use of 'apply' in the context of functions has anything to do with "specialness". Applying a hammer to a nail is just using the hammer on that nail. Applying a function to an argument is using the function on that argument.
16:43:47 <[Leary]> Either way, the discussion has more to do with the English language than Haskell.
17:10:01 <u-ou> pony
18:10:19 <ryantrinkle> has anyone tried out the various bidirectional parser/pretty-printers?
18:10:32 <ryantrinkle> i'm thinking of trying out boomerang and roundtrip
18:10:40 <ryantrinkle> but i'd be interested to hear if anyone loves/hates any of the existing options
18:39:16 <mniip> hey glguy
18:41:34 <jchia> Question about file handles: Why does Data.Text.IO.readFile not close the handle it opens? Won't the handle leak? https://www.stackage.org/haddock/lts-10.3/text-1.2.2.2/src/Data.Text.IO.html#readFile
18:42:23 <jchia> Never mind, I saw that hGetContents closes the handle. That's unexpected, though.
18:47:05 <dmwit> It is consistent with hGetContents from base, which also (semi-)closes its handle.
18:52:31 <iqubic> How do you semi-close the thing?
18:53:06 <albatross_> how can I use putStr on ["ab", "cd", "e"]
18:55:30 <dmwit> % putStr . concat $ ["ab", "cd", "e"]
18:55:30 <yahb> dmwit: abcde
18:55:38 <dmwit> % mapM_ putStr ["ab", "cd", "e"]
18:55:39 <yahb> dmwit: abcde
18:57:21 <dedgrant> mapM_, or traverse_ is probably preferred these days?
18:58:37 <mniip> :t traverse_
18:58:40 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
19:01:20 <incList> I have a list of lists[["aa", "bb", "cc"], ["dd", "ee"], ["ff", "gg", "hh"]]. How could I build a list incrementally like [["aa", "bb", "cc"], ["aa", "bb", "cc", "dd", "ee"], ["aa", "bb", "cc", "dd", "ee", "ff", "gg", "hh"] with a good performance?
19:02:42 <mniip> so something like scanl1 (++)
19:02:54 <dmwit> > scanl (++) [] ["ab", "cd", "ef"]
19:02:57 <lambdabot>  ["","ab","abcd","abcdef"]
19:02:59 <dmwit> I am too slow.
19:03:08 <monochrom> Allow me to use more general/abstract notation. You have a list of lists [x, y, z] (i.e., x is a list, etc).
19:03:09 <mniip> you could do the classic endo transform for performance
19:03:34 <monochrom> First you want to map that to [(x ++), (y ++), (z ++)]
19:03:36 <mniip> :t map ($ []) . scanl1 (.) . map (++)
19:03:38 <lambdabot> [[a]] -> [[a]]
19:04:22 <monochrom> Then I think it's a scanl1 (.) that can turn that into [(x ++), (x ++) . (y ++), (x ++) . (y ++) . (z ++)]
19:04:44 <monochrom> Finally do a map ($ []) to tie up the loose ends.
19:04:59 <dmwit> Why is this better.
19:05:07 <dmwit> I know why it's usually better.
19:05:11 <dmwit> But in this case I think it is not.
19:05:38 <mniip> dmwit, ++ associated to the left haas bad performance
19:06:08 <dmwit> Yes. But this does not have good performance, either. You are still re-evaluating all the previous appends O(n) times.
19:06:31 <monochrom> I don't know why, but empirically (((x++) . ( y++)) . (z++)) [] is faster than (x++y)++z
19:06:46 <mniip> dmwit has a point here
19:06:55 <mniip> monochrom, if you have x++y as a separate thunk
19:06:59 <dmwit> monochrom: But those are not the two alternatives we are comparing.
19:07:00 <mniip> then does it even matter
19:08:24 <mniip> the performance difference would only show if you don't evaluate the entire result
19:08:34 <mniip> if you do it's quadratic both cases
19:08:50 <n_blownapart> hi this is a tautology checker I'm nearly done with. At the bottom of the file there is the func boolsR on line 63. I'm having trouble seeing how the recursion works there. so instead of 'range' in the first func bools, we have recursion. how to write it out by hand with that where statement?
19:08:52 <n_blownapart> http://lpaste.net/361564
19:08:53 <mniip> which is uhh, the best you can do since the structure takes quadratic memory
19:09:29 <monochrom> No, cubic for [x0, x0++x1, (x0++x1)++x2, ((x0++x1)++x2)++x3, ... ]
19:09:38 <mniip> no
19:09:42 <mniip> there is sharing
19:09:54 <monochrom> Ah.
19:10:27 <mniip> you're talking about time, right?
19:10:32 <monochrom> Yes
19:10:43 <mniip> yeah see that (x0++x1)++x2 is shared across all instances
19:11:01 <mniip> in fact if you evaluate the last of that list you evaluate the entire list
19:11:45 <mniip> hrmph
19:11:56 <monochrom> This begs empirical tests.
19:12:00 <mniip> there needs to be a toy haskell interpreter with a well-visualized heap
19:12:25 <dmwit> n_blownapart: I'm not sure I understand the question yet.
19:12:37 <dmwit> n_blownapart: What is the "it" that you want to write out by hand? What does "write out by hand" mean?
19:13:27 <n_blownapart> dmwit thanks ,well ..
19:13:30 <incList> Thank you so much.
19:14:16 <n_blownapart> bss is the counter, whereas in bools range is used as the counter for the mapping
19:15:09 <monochrom> ♫ The toy..... haskell interpeter is there..... inside my mind.... ♫
19:15:48 <n_blownapart> so in the case of 'boolsR 3' False: is appended to a list of lists that begins with [False, False]
19:16:13 <n_blownapart> so the first list becomes [False, False, False]
19:16:53 <n_blownapart> but I can't conceptualize the recursion, with that where statement dmwit
19:17:56 <dmwit> n_blownapart: Suppose I told you I had a list, named `bss`. I tell you that the elements of this list is the collection of all length-5 lists of `Bool`.
19:18:16 <dmwit> n_blownapart: Now I would like you to make a collection of all the length-6 lists of `Bool` using `bss`. What would you do?
19:19:12 <dmwit> n_blownapart: Here is what *I* would do: I would make two other lists, one by prepending `True` to every element of `bss`, and one by prepending `False` to every element of `bss`. Now I have a list of all the length-6 `Bool` lists that start with `True`, and a list of all the length-6 `Bool` lists that start with `False`.
19:19:37 <dmwit> n_blownapart: Putting them together I have all the length-6 `Bool` lists, since they all must either start with `True` or `False`.
19:19:49 <dmwit> n_blownapart: Sound reasonable so far?
19:20:01 <mniip> monochrom, I can visualize it inside my mind
19:20:26 <mniip> but I've once written an untyped lambda calculus interpreter in lua and it was cool as hell because it could output unevaluated thunks
19:20:35 <n_blownapart> yes, this is a book example, and that is essentially what it says. its a bit confusing but yeah we're using (++) to make the two lists to prepend (False:) and (True:) to.
19:20:37 <n_blownapart> dmwit
19:21:17 <dmwit> Okay. So you know how to extend a collection of all possible `Bool` lists of a given length to be one longer.
19:21:35 <dmwit> And you know how to make a collection of all possible length-0 `Bool` lists, since's there's only one, namely `[]`.
19:21:38 <monochrom> Oh I was just having fun with hijacking a song from Phantom of The Opera :)
19:21:52 <n_blownapart> ok
19:21:56 <dmwit> Together these two things tell you how to make collections of arbitrarily long `Bool` lists.
19:22:12 <dmwit> Just start from the length-0 collection and work your way up.
19:23:17 <dmwit> And this is what `boolsR` says: `boolsR 0 = [[]]` is the collection of length-0 `Bool` lists, and `boolsR n = extend bss where bss = boolsR (n-1)` is the way you extend a collection of short lists to a collection of slightly longer ones.
19:23:37 <mniip>  > fix (Cons 1)
19:23:37 <mniip> letrec %1 = 1# in Cons %1 ((\f -> letrec %2 = f ((\f -> %2) f) in %2) (\%2 -> Cons %1 %2))
19:23:37 <dmwit> (Okay, so we spelled `extend` with a few more details in your paste. Details, details.)
19:24:34 <jmcarthur> I've seen an encoding of untyped lambda calculus expressions as (type Expr = forall a. ((a -> a) -> a) -> (a -> a -> a) -> a), which makes sense, but it's not immediately obvious to me how to define  lam :: (Expr -> Expr) -> Expr
19:24:59 <jmcarthur> app is much easier
19:25:06 <n_blownapart> so the first case for boolsR 3, is to append False to a list of [False, False] . so that [False, False] is already built up by the recursion, I guess. dmwit
19:25:31 <n_blownapart> False: [False, False]
19:25:31 <dmwit> Sure.
19:26:21 <mniip> jmcarthur, how does that encoding work
19:26:56 <n_blownapart> so before we look at what map is doing...
19:27:21 <n_blownapart> on the False side of the (++) ...
19:27:27 <jmcarthur> mniip: I'm not sure it quite counts as a church encoding, but it looks a lot like one
19:27:34 <mniip> it isn't
19:27:39 <jmcarthur> mniip: The first argument is lambda and the second one is application
19:27:46 <mniip> ah I think I know
19:27:47 <jchia> dmwit: I meant hGetContents closing the handle is unexpected just looking at the name of the function. Not sure what it means by "semi-close", though
19:27:50 <mniip> hmm
19:28:35 <glguy> jchia: In all of the occurences of hGetHandle once you execute (hGetHandle h), then h isn't yours any more
19:28:39 <dmwit> jchia: The name hGetContents suggests that it closes the handle to me. Because hGetContents in several other libraries also closes the handle.
19:28:55 <dmwit> jchia: getContents also closes the appropriate handle.
19:28:58 <mniip> so you'd have like  S = \lam app -> lam (\f -> lam (\g -> lam (\x -> app (app f x) (app g x))))
19:29:14 <monochrom> I have left Haskell for too long. I was commenting out one line of Haskell code. First instinct: #. Second instinct: --.  >.>
19:29:30 <monochrom> Err, second instinct was // heh
19:29:32 <mniip> jmcarthur, something tells me you've set out to write the wrong function
19:29:44 <mniip> not (Expr -> Expr) -> Expr
19:32:10 <mniip> just because in the inner language any 'function' is a value
19:32:17 <mniip> doesn't mean tht haskell's functions are values
19:33:09 <jmcarthur> mniip: Well, with other final encodings of this sort it is rather straightforward to do this. I think it's the negative occurrence of Expr in the argument of lam that makes it hard somehow.
19:33:20 <mniip> s/hard/incorrect/
19:33:40 <mniip> this is a cute encoding actually
19:34:03 <mniip> can't say I understand all the implications of it but it's fairly nonstraighforward
19:34:17 <monochrom> OK guys, empirical results are in. My scheme takes linear time. I have no idea why. I'll show actual code so you can try.
19:34:30 <mniip> monochrom, linear wrt what
19:34:55 <monochrom> n, where the input list is replicate n "hello"
19:35:25 <mniip> try  replicate n [1..n]
19:35:29 <mniip> that's kind of the n I had in mind
19:35:55 <glguy> Which scheme were you testing?
19:36:07 <jmcarthur> Without it occurring in the negative position this would be easy. For example, natural numbers:  type Nat = forall a. (a -> a) -> a -> a   zero :: Nat   zero _ z = z   suc :: Nat -> Nat   suc n s z = s (n s z)
19:36:47 <monochrom> http://lpaste.net/361565
19:37:34 <mniip> jmcarthur, consider this
19:37:59 <mniip> you can come up with a way to check whether a particular Expr is well-typed in STLC, right?
19:38:02 <dmwit> monochrom: You are not consuming the entire result of `scanl`.
19:38:11 <mniip> just substitute a complicated enough type for a
19:38:12 <glguy> monochrom: Is there something different about using only the last element of scanl and foldl?
19:38:31 <monochrom> Ah OK, I need to consume all of the output list, yeah.
19:38:33 <n_blownapart> dmwit sorry, what I need to know is how we get our first list to which we append False (:) [False, False]. I get confused when I try to see how map works on that. map takes a function argument, (False:), goes through two recursions of appending False, then appends False once more when we hit [[]], right?
19:38:56 <mniip> hmm or can you
19:39:09 <amca> Hi folks: quick newbie question - how do I read in a line from a text file that begins with a specified string?
19:39:10 <monochrom> The output list has quadratic length eh
19:39:44 <n_blownapart> so we have False: False: False: [[]].
19:40:21 <mniip> jmcarthur, basically what I'm trying to prove is that you can write an (Expr -> Bool) that tests whether Expr is well-typed, and then you can upgrade it to (Expr -> Expr), and then your hypothetical 'lam' function would construct a lambda that does a thing a lambda should never be able to do
19:41:19 <dmwit> n_blownapart: No. `map` takes a function argument, `(False:)`, and its second argument goes through two recursions of extending a collection of lists of `Bool`s to longer lists of `Bool`s, producing a list which starts with `[False, False]` (but has three other elements!), then prepends `False`.
19:41:36 <dmwit> n_blownapart: Almost every part of your original description has changed.
19:43:21 <mniip> jmcarthur, here's a thing
19:43:49 <mniip> if  p :: Expr, then p (\f -> f 0) (\x y -> x + y + 1)  is the number of applications in p
19:44:28 <mniip> thus you can write a function that takes a lambda and returns a church-encoded number of applications in its argument
19:44:31 <jmcarthur> mniip: Ah, I found this https://bentnib.org/syntaxforfree.pdf
19:44:36 <mniip> but beta reduction changes the number of applciations
19:46:38 <n_blownapart> (but has three other elements!)    ... dmwit pondering that
19:46:39 <mniip> right
19:46:48 <mniip> as I said, you picked the wrong type for lam
19:47:07 <dmwit> n_blownapart: Can I suggest a small exercise?
19:47:09 <mniip> the author augments the type of closed LC terms by including not-closed LC terms too
19:47:18 <mniip> and then lam is defined on that
19:47:45 <n_blownapart> sure, I pretty much intuit how it works, but yes please
19:48:30 <n_blownapart> its probably your version of 'writing it out by hand' :)
19:48:36 <jmcarthur> Yeah
19:48:43 <dmwit> n_blownapart: I suggest you write a function. This function will take as input a collection of `Bool` lists, and I will promise that every possible `Bool` list is in that collection.
19:49:04 <dmwit> n_blownapart: Sorry, every possible `Bool` list of a specific length, I mean -- let's say, 5.
19:49:28 <dmwit> n_blownapart: As output, your function should produce a collection of `Bool` lists that are each one longer than the input lists were. The collection should again be complete for that length.
19:49:51 <dmwit> n_blownapart: This function can be written without doing any recursion (except through existing library functions).
19:51:43 <n_blownapart> ok, well the function before boolsR, that one I understand fully. int2bit is on line 44 of that paste BTW dmwit
19:52:09 <n_blownapart> that one is called bools and contains int2bit
19:52:38 * dmwit nods agreeably
19:53:04 <n_blownapart> dmwit I'll work on this tomorrow. getting kicked out of cafe. thanks dmwit !
20:05:57 <mniip> hey glguy
20:06:26 <mniip> I'm thinking of...
20:06:39 <mniip> an IRC library generalized over string types
20:08:13 <monochrom> I prefer crib sheets generalized over text. (Crib sheet means in some courses the instructor lets you bring a page of your own notes to the exam.)
20:09:19 <monochrom> Just today I told my students "no font restriction. If you want to do a microfilm thing, that's OK. If you want to use black and white pixels to do binary code that stands for ASCII code, that's OK."
20:09:43 <mniip> I've been thinking of that once
20:10:04 <mniip> you can probably print an entire book on an A4 with a hidpi printer
20:15:59 <iqubic> monochrom: What do you teach?
20:16:39 <monochrom> IRC generalized over string types. So, Morse code on IRC for example? :)
20:17:28 <mniip> I mean ByteString/Text/String
20:18:01 <monochrom> I am too crazy.
20:19:53 <mniip> tehcnically you should use bytestring everywhere on IRC
20:20:04 <mniip> but in some cases you might not want to
20:20:21 <mniip> like when chopping data at the 512 byte limit
20:20:29 <mniip> you'd rather not break utf8 sequences
20:23:41 * geekosaur wonders if anyone has claimed "stringulation" as metaphor yet
20:25:25 <glguy> I think technically IRC is a text-based protocol and using Text is more sensible than using ByteString. Originally a particular encoding was assumed and then people started assuming a different one. Channel-specific encoding is something people hack in, but it relies on assumptions about how all the encodings will play together
20:25:55 <mniip> most modern IRC servers pass higher octets as-is
20:26:15 <mniip> I think other IRC software should try to too
20:26:24 <mniip> like if your bot has an echo command
20:27:31 <iqubic> Emacs' ERC has a toggle-able module that lets you chose whether or not to have morse code translated.
20:27:51 <mniip> the problem with bringing bytestrings that deep into the code
20:27:56 <saurabhnanda> what's the difference between mtl and transformers? If I'm trying to define my own monad-transformer which package should I be using as a base?
20:27:58 <mniip> is that it's then tricky to support actual utf8
20:28:13 <mniip> saurabhnanda, mtl builds on top of transformers
20:28:29 <mniip> transformers defines the types, and some haskell98-expressible classes and other primitives
20:28:55 <mniip> mtl just builds a bunch of MPTCs to apply primitives nicely for you
20:28:58 <saurabhnanda> mniip: so I should be writing an instance of https://www.stackage.org/haddock/lts-9.0/transformers-0.5.2.0/Control-Monad-Trans-Class.html#t:MonadTrans ?
20:29:22 <mniip> definitely
20:29:35 <geekosaur> there's also an alternative to mtl: monads-tf
20:29:48 <saurabhnanda> mniip: thanks!
20:30:03 <mniip> anyway, back to strings
20:30:03 <geekosaur> (mtl uses functional dependencies to define MPTCs; monads-tf uses type families)
20:30:14 <mniip> I believe there's a problem that haskell can actually solve here
20:30:42 <mniip> when, say, parsing IRC words, or bot commands,
20:30:58 <mniip> instead of decoding bytestring into String and pattern matching on unicode strings
20:31:16 <mniip> we could pattern match on bytestrings that are encodings of the respective unicode strings
20:31:27 <geekosaur> I keep wanting encoding-tagged strings. Problem is I keep expectig it to turn into the tagged units problem (it looks easy until you start poking the details and it turns into Cthulhu)
20:31:29 <mniip> user-definable patterns could work here
20:33:07 <saurabhnanda> wow, this is hard... i have 11 instances for my AppM monad. If I need to "extend" this to a PluginM monad I have to rewrite all the 11 instances for the PluginM
20:33:27 <mniip> is AppM a newtype over mtl types?
20:33:43 <saurabhnanda> type AppM = ReaderT Env (LoggingT IO)
20:33:50 <mniip> derive every single thing using GND
20:34:01 <saurabhnanda> mniip: where can I read about that?
20:34:16 <saurabhnanda> mniip: I'm on GHC 8.0.2 -- will it work there?
20:34:21 <mniip> yes
20:34:28 <saurabhnanda> GND = Generalized Newtype Deriving?
20:34:38 <mniip> https://ocharles.org.uk/blog/guest-posts/2014-12-15-deriving.html
20:34:41 <mniip> seems like a good read
20:35:19 <saurabhnanda> that's exactly what I was going to post. that's a good reference to follow?
20:35:42 <mniip> no idea, I don't think I've ever read anything on it
20:35:46 <mniip> it was evident
20:35:53 <saurabhnanda> does this have any significant negative perf impact?
20:36:09 <saurabhnanda> so essentially all the instances are just variations of `lift`. GND will figure that out automagically?
20:36:12 <mniip> you can always dump the derived code
20:36:19 <mniip> no,
20:36:40 <mniip> GND will take the instances for the contents of the newtype
20:36:50 <mniip> and copy them with coercions on top
20:37:04 <saurabhnanda> "It can just take the existing instances and insert some (free at runtime) coercions to make them work with newtypes. This is the GeneralizedNewtypeDeriving extension."
20:37:14 <saurabhnanda> okay, let me try...
20:37:32 <saurabhnanda> wait, hang on, that might not work.
20:38:00 <saurabhnanda> the reason I'm wrapping AppM into a PluginM is because I want runPluginM to do an extra authentication check of whether the plugin is enabled for a given customer account or not.
20:38:14 <saurabhnanda> blind coercions will not allow me to do the extra auth check.
20:48:50 <mniip> check where exactly
20:59:16 <saurabhnanda> when PluginM is being "unwrapped" to AppM
21:10:00 <mniip> sounds like you're making not-quite-a-monad there
21:13:11 <saurabhnanda> hmm
21:13:23 <saurabhnanda> let me see if I can take this up to servant-auth level instead. Might be easier.
21:20:24 <saurabhnanda> how do I express something on the lines of : type instance Auth.AuthServerData (forall pi . (Plugin pi) => Auth.AuthProtect pi) = String
21:31:06 <piyush-k`> saurabhnanda: make sure that you follow the monad laws (at least verify by hand) otherwise lots of grief lies ahead
22:07:34 <iqubic> saurabhnanda: What is the forall pi thing doing there?
22:08:04 <saurabhnanda> basically I'm trying to define a servant auth thingie for anything that defines the `Plugin` typeclass
22:08:10 <iqubic> Do the GHC rewrite rules assume that the laws hold true?
22:08:20 <mniip> yes
22:10:48 <iqubic> Then I get why not following the laws leads to pain.
22:15:06 <iqubic> So if you aren't writting a law abiding monad instance, then your code might not work properly?
22:18:01 <mniip> I don't think there any rewrite rules on any of the typeclasses in prelude
22:18:19 <mniip> in part because there's a good chance they don't actually work (match) once the prgram is translated into Core
22:18:38 <mniip> due to how instance dictionary applications are floated around and so on
22:34:19 <lone_wolf> Hi
22:35:24 <boj> hi
22:38:01 <lone_wolf> how r u, @boj?
22:45:37 <dainichi> take 3 [1,2,3,4]
22:46:04 <boj> > take 3 [1..4]
22:46:07 <lambdabot>  [1,2,3]
22:46:12 <vaibhavsagar> dainichi: prefix with '>'
22:46:20 <vaibhavsagar> > take 3 [1,2,3,4]
22:46:22 <dainichi> Ty
22:46:23 <lambdabot>  [1,2,3]
22:46:48 <vaibhavsagar> hmm, this doesn't seem to work either :(
22:47:37 <dainichi> @free a -> b
22:47:37 <lambdabot> Extra stuff at end of line
22:48:36 <dainichi> @free f :: a -> b
22:48:36 <lambdabot> h . f = f . g
22:50:46 <dainichi> @free f :: [a] -> [a]
22:50:46 <lambdabot> $map g . f = f . $map g
22:51:39 <dainichi> @free f :: a -> a
22:51:39 <lambdabot> g . f = f . g
23:02:17 <amca> Does any one here know if it's possible to read in a CSV file and parse it (in my case into values of type Int and [Int]) in ghci?
23:02:49 <amca> I've got the cassava library: Data.Csv module, but my attempts to use it have so far failed...
23:03:33 <amca> Records look like: 4,17,[1,4,3,5,7]
23:04:04 <amca> If this is a stupid question, well I am pretty much a newbie!
23:04:38 <amca> Hang on... got to go; be back later, and I'll ask again.
23:04:40 <boj> amca: maybe post the error into lpaste
23:04:49 <boj> and a sample of the code
23:05:18 <amca> I'll do that when I'm back on again.  But thanks for answering!  Also, what's lpaste?
23:05:37 <boj> it's a website listed in the channel topic for sharing code
23:05:46 <boj> @where lpaste
23:05:46 <lambdabot> http://lpaste.net/
23:05:56 <amca> OK, I'll check it out - thanks!  Bye until later...
