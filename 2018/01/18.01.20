00:28:06 <Myrl-saki> Dammit. I just remembered that Float's can't multiply by undefined. :(
00:28:50 <Myrl-saki> Wait what
00:28:52 <Myrl-saki> Also Ints?
00:29:29 <Myrl-saki> I thought (*) case analyzes on the left side?
00:30:53 <Myrl-saki> > 0 * undefined :: Int
00:30:58 <lambdabot>  *Exception: Prelude.undefined
00:31:10 <Myrl-saki> Boring. :x
00:32:30 <nshepperd> nah (*) just reduces to the hardware mul operation
00:34:18 <cocreature> > 0 * undefined :: Integer
00:34:22 <lambdabot>  *Exception: Prelude.undefined
00:34:53 <cocreature> oh that has bang patterns
00:35:10 <Myrl-saki> cocreature: Ohhh makes sense.
01:15:39 <moriarty> yo, anyone here know anything about cardano?
01:18:08 <EvanR> don't ask to ask
01:18:21 <JuanDaugherty> he didn
01:18:38 <EvanR> hmm
01:21:38 <JuanDaugherty> it's a further step to require a specific query about cardano
01:24:17 <JuanDaugherty> one i would welcome but it's contrary to established policy/character
01:38:12 <asheshambasta> advice needed: where to go from next after RWH?
01:38:33 <asheshambasta> where to go next *** (sorry)
01:39:51 <JuanDaugherty> a useful project?
01:40:23 <asheshambasta> yeah – I'm considering doing the device part of an IoT project I've been working on in Haskell
01:40:52 <asheshambasta> I'd like to be careful and not drown myself under and become discouraged by the complexity of what I undertake
01:41:26 <dmj`> asheshambasta: typeclassopedia
01:41:46 <asheshambasta> basically, I'd like to write something for RPi that reacts to pin states – basically an intrusion detector
01:42:04 <JuanDaugherty> unless it's different from the typical IoT device, you'll probably be best advised to target hs as a back end
01:43:13 <asheshambasta> JuanDaugherty: by backend you mean the part of the system that receives gpio signals and acts on them?
01:44:09 <asheshambasta> dmj`: thanks! I've been reading from that as well. I was also considering the Haskell Book — it seems promising but I'm not sure of reading from a screen.
01:44:21 <JuanDaugherty> i mean the part that isn't running on RPi
01:44:33 <asheshambasta> ah okay
01:44:41 <asheshambasta> and why?
01:45:09 <JuanDaugherty> i could be wrong, find out
01:46:34 <asheshambasta> okay
01:55:49 <dmj`> asheshambasta: anything by @byorgey really
02:22:57 <somewone> asheshambasta: this might be helpful if you are willing to try Haskell on the RPi http://hackage.mobilehaskell.org/
02:31:11 <Matteo_> hi
02:32:29 <Matteo_> does anyone know any good tutorials on concurrency with mvar and frokIO ?
02:37:47 <somewone> Matteo_: http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
02:37:56 <somewone> Check for the chapter: Simple communication between threads
02:38:30 <Matteo_> somewone: I will try it thx
02:41:08 <somewone> Any way to drop the attributes of empty Arrays in ToJSON (Aeson). E.g. {data R = R { _r :: [X] }` send `{}` when _r is empty ?
02:43:41 <kuribas> why is blaze the most popular html generation language, when it's not strongly typed?
02:46:38 <alp> m
02:46:43 <alp> oops.
02:51:38 <phadej> ReinH: sry Scientific the value
02:58:21 <awesomelackware> @help
02:58:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:58:43 <awesomelackware> @type let pair x y = \z -> z x y in let x1 = \y -> pair y y in let x2 = \y -> x1 (x1 y) in let x3 = \y -> x2 (x2 y) in let x4 = \y -> x3 (x3 y) in let x5 = \y -> x4 (x4 y) in x5 (\z -> z)
02:58:58 <lambdabot> Plugin `type' failed with: <<timeout>>
02:59:17 <awesomelackware> lambdabot > idris-bot
03:01:08 <barrucadu> That is a big type
03:01:20 <awesomelackware> @type let pair x y = \z -> z x y in let x1 = \y -> pair y y in let x2 = \y -> x1 (x1 y) in let x3 = \y -> x2 (x2 y) in let x4 = \y -> x3 (x3 y) in x4 (\z -> z)
03:01:24 <lambdabot> ((((((((((((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2)
03:01:24 <lambdabot>  -> t3) -> t3) -> (((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) ->
03:01:24 <lambdabot> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> (((((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (
03:01:24 <lambdabot> p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> (((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -
03:01:24 <lambdabot> > p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> t5) -> t5) -> (((((((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p
03:01:26 <lambdabot> [32 @more lines]
03:01:28 <awesomelackware> @more
03:01:29 <lambdabot> -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> (((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -
03:01:30 <lambdabot> > (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> (((((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) ->
03:01:32 <lambdabot> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> (((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p
03:01:34 <lambdabot> -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> t5) -> t5) -> t6) -> t6) -> ((((((((((
03:01:36 <lambdabot> (((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) ->
03:01:38 <lambdabot> [27 @more lines]
03:01:39 <awesomelackware> @more
03:01:40 <lambdabot> Plugin `more' failed with: Prelude.init: empty list
03:01:46 <awesomelackware> wut?
03:01:56 <awesomelackware> C++ > lambdabot
03:02:04 <Uniaika> wtf
03:02:34 <awesomelackware> Uniaika, what?
03:04:08 <awesomelackware> @type let pair x y = \z -> z x y in let x1 = \y -> pair y y in let x2 = \y -> x1 (x1 y) in let x3 = \y -> x2 (x2 y) in let x4 = \y -> x3 (x3 y) in x4 (\z -> z)
03:04:12 <lambdabot> ((((((((((((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2)
03:04:12 <lambdabot>  -> t3) -> t3) -> (((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) ->
03:04:12 <lambdabot> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> (((((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (
03:04:12 <lambdabot> p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> (((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -
03:04:12 <lambdabot> > p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> t5) -> t5) -> (((((((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p
03:04:14 <lambdabot> [32 @more lines]
03:04:18 <awesomelackware> @more
03:04:19 <lambdabot> -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> (((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -
03:04:19 <lambdabot> > (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> (((((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) ->
03:04:20 <lambdabot> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> (((((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p
03:04:22 <lambdabot> -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> t5) -> t5) -> t6) -> t6) -> ((((((((((
03:04:24 <lambdabot> (((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> (((((p -> p) -> (p -> p) -> t1) -> t1) -> (((p -> p) -> (p -> p) -> t1) -> t1) -> t2) -> t2) -> t3) ->
03:04:26 <lambdabot> [27 @more lines]
03:04:28 <awesomelackware> @more
03:04:28 <lambdabot> Plugin `more' failed with: Prelude.init: empty list
03:04:32 <awesomelackware> wtf?
03:05:04 <awesomelackware> @pl let pair x y = \z -> z x y in let x1 = \y -> pair y y in let x2 = \y -> x1 (x1 y) in let x3 = \y -> x2 (x2 y) in let x4 = \y -> x3 (x3 y) in x4 (\z -> z)
03:05:06 <lambdabot> join (.) (join (.) ((flip =<< flip id) . (flip =<< flip id))) id
03:05:10 <awesomelackware> wow
03:05:27 <awesomelackware> @pl let pair x y = \z -> z x y in let x1 = \y -> pair y y in let x2 = \y -> x1 (x1 y) in let x3 = \y -> x2 (x2 y) in let x4 = \y -> x3 (x3 y) in let x5 = \y -> x4 (x4 y) in x5 (\z -> z)
03:05:31 <lambdabot> join (.) (join (.) (join (.) ((flip =<< flip id) . (flip =<< flip id)))) id
03:05:53 <awesomelackware> @type join (.) (join (.) (join (.) ((flip =<< flip id) . (flip =<< flip id)))) id
03:05:56 <lambdabot> error:
03:05:56 <lambdabot>     • Occurs check: cannot construct the infinite type:
03:05:56 <lambdabot>         a
03:06:03 <awesomelackware> kekeke
03:06:25 <awesomelackware> @run let pair x y = \z -> z x y in let x1 = \y -> pair y y in let x2 = \y -> x1 (x1 y) in let x3 = \y -> x2 (x2 y) in let x4 = \y -> x3 (x3 y) in let x5 = \y -> x4 (x4 y) in x5 (\z -> z)
03:06:31 <lambdabot>  mueval-core: Time limit exceeded
03:06:36 <awesomelackware> @run let pair x y = \z -> z x y in let x1 = \y -> pair y y in let x2 = \y -> x1 (x1 y) in let x3 = \y -> x2 (x2 y) in let x4 = \y -> x3 (x3 y) in x4 (\z -> z)
03:06:41 <lambdabot>  error:
03:06:41 <lambdabot>      • No instance for (Typeable p0)
03:06:41 <lambdabot>          arising from a use of ‘show_M629294661799666357920873’
03:13:23 <yoho139> awesomelackware: you can PM the bot
03:13:49 <awesomelackware> yoho139, thanks
03:16:20 <Myrl-saki> lol...
03:41:54 <Aruro> what is a good way to uninstall haskell platform on OSX?
03:42:50 <JuanDaugherty> delete the directories
03:43:48 <Aruro> why there is no unistaller ? :) how hard can it be :)
03:44:15 <Aruro> there is 5 years old script on github : https://gist.github.com/steakknife/3775443
03:45:52 <Aruro> i have ghc 8.0.2 and want to update to 8.2.2
04:18:59 <oo_miguel> I am a haskell noob and I neet to caclulate a hmac-sha256 signature. I wonder 1. how to find a library that will do that for me (if any). 2. how to elegantly include it in my "project"
04:19:05 <oo_miguel> s/neet/need
04:27:46 <oo_miguel> hmm.. I am trying: cabal install wai-middleware-hmac
04:40:21 <cocreature> oo_miguel: the defacto standard in Haskell for cryptography is the cryptonite package which provides an "hmac" function https://hackage.haskell.org/package/cryptonite-0.24/docs/Crypto-MAC-HMAC.html#v:hmac
04:40:34 <cocreature> you can choose the hash algorithm using the return type
04:40:44 <oo_miguel> cocreature: oh thank you very much
05:01:10 <oo_miguel> works like a dream! thank you once again
05:06:25 <oo_miguel> are there alos some defacto standards for parsing JSON and sending https requests (similar to curl functionality) ?
05:06:30 <oo_miguel> s/alos/also
05:07:02 <cocreature> for parsing json, the defacto standard is "aeson"
05:07:54 <cocreature> for sending https requests the situation is less clear. among the more popular options are the "req", "wreq" and "http-conduit" libraries or "http-client" but that’s more lower level (the other libs build upon it)
05:08:29 <cocreature> personally, I’ve been quite happy with "req" the last time I needed something like this and I also had good experiences with "http-conduit" in the past
05:09:52 <oo_miguel> great, I will have a look on a few of them
05:10:26 <oo_miguel> .. now the last piece in my puzzle is something for terminal output (some colors would be nice) ;)
05:10:54 <oo_miguel> System.Console.ANSI?
05:11:08 <cocreature> I’d use prettyprinter-ansi-terminal for that
05:11:23 <oo_miguel> allright! thanks a lot for all your suggestions
05:11:45 <oo_miguel> I am sure I will be back with problems and questions soon :P. But for now I have enough to play and experiment around
05:11:58 <cocreature> have fun :)
05:12:08 <oo_miguel> thanks again!
05:16:31 <darkmatterjesus[> Where would be a good place to start learning Hskell (Noob here)?
05:16:56 <oo_miguel> as a noob I can recomment : https://www.haskell.org/documentation
05:17:03 <oo_miguel> Books for Learning HAskell
05:17:10 <oo_miguel> recommend*
05:17:21 <darkmatterjesus[> Thank you so much!
05:18:00 <darkmatterjesus[> I don't even know what I would use this programming for, but it seems like it's growing in popularity. What do people ususally make with it.
05:19:16 <oo_miguel> Personally I came across haskell because my window manager (xmonad) is programmed in this language. I had to understand parts of it to tune the configuration file. Now I fell in love with it due to its functional and pure nature. Trying to learn some more
05:21:26 <ski> darkmatterjesus[ : how about here ?
05:21:38 <darkmatterjesus[> I'm studying networking and network security we use python, but my teacher mentioned Haskell.
05:22:04 * ski . o O ( Cryptol )
05:22:10 <darkmatterjesus[> Can you use it for netowrking functionality?
05:22:15 <darkmatterjesus[> networking
05:22:49 <ski> i think so (i haven't really tried)
05:25:16 <darkmatterjesus[> What can Haskell do? Probably a broad question.
05:25:45 <electrocat> darkmatterjesus[: everything, it's just a general purpose language
05:25:59 <electrocat> hm
05:26:00 <sethetter> @darkmatterjesus[ I'm no expert here, but it might be easier to drill down what things Haskell *isn't* well suited for yet.
05:26:00 <lambdabot> Unknown command, try @list
05:26:05 <electrocat> probably not systems programming though
05:28:09 <ski> Haskell might be more preferable, in case you want your programs to do what you intended them to do (aka correctness)
05:28:13 <ghc_-o_exec> haskell is strange from how other languages, it does while or for loops, just all static variables..
05:28:21 <ghc_-o_exec> it doesnt*
05:28:37 <ski> @type until
05:28:39 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
05:28:49 <ski> is a loop
05:28:55 <cocreature> ghc_-o_exec: we have quite a few loops https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html :)
05:29:01 <ski> as is `forM_'
05:29:16 <sethetter> I'm 100% sold on the language design of Haskell, but for better or worse I wish I had a little more assurance that it would grow in adoption.
05:29:20 <ghc_-o_exec> but not how while() or do is used, but i guess whats the difference, its being worked behind the scenes..
05:29:39 <sethetter> It seems like that's the direction it's going, but sometimes it's pretty tough to tell in this industry.
05:30:04 <ski> `until' is similar to a `while' loop updating state
05:30:35 <ski> @hoogle Monad m => m Bool -> m a -> m ()
05:30:36 <lambdabot> Control.Monad.Loops whileM_ :: Monad m => m Bool -> m a -> m ()
05:30:36 <lambdabot> Control.Monad.Loops untilM_ :: Monad m => m a -> m Bool -> m ()
05:30:36 <lambdabot> Control.Monad.Extra whenM :: Monad m => m Bool -> m () -> m ()
05:31:22 <ski> > until even (*2) 10
05:31:26 <lambdabot>  10
05:31:37 <ski> > until (>= 1000) (*2) 1
05:31:42 <lambdabot>  1024
05:32:46 <ghc_-o_exec> hmm...so there are loops, just not the basic way others languages declares them..
05:33:45 <cocreature> contrary to most other languages, they are not builtin syntax but rather just functions that you can define yourself
05:40:05 <exio4> in Haskell, very few things are actually mandated by the language compared to other languages :P
05:40:12 <exio4> even booleans can be defined within the language
05:42:31 <ghc_-o_exec> what does it mean that haskell is lazy, what makes it lazy..?
05:42:54 <ghc_-o_exec> is it the fact that doing something like forever = [5,10..] is not really generating all the numbers but can?
05:47:44 <ghc_-o_exec> yea maybe i answered my own question -.-
05:54:11 <electrocat> ghc_-o_exec: it means that expressions are not evaluated untill their result is required
05:56:11 <electrocat> as a consequence, you can have infinite lists, because every element is computed when it's required
05:58:29 <Matteo_> hi, could someone tell me how i can send data from my main thread to another thread created with forkIO ?
05:59:12 <electrocat> Matteo_: https://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Concurrent-MVar.html
06:01:47 <Matteo_> can you change global variable in haskell ?
06:02:12 <hpc> all definitions are immutable
06:02:40 <electrocat> technically you can, but i wouldn't recommend it
06:03:12 <hpc> mutable global variables are actually how you define unsafeCoerce in terms of unsafePerformIO
06:03:15 <electrocat> create the MVar in the main thread, and pass it to the new thread when you create it
06:03:56 <Matteo_> ill try that
06:33:42 <Matteo_> could some one give me an example on MVar's I dont realy understand it
06:38:37 <electrocat> Matteo_: i suggest reading this: http://chimera.labs.oreilly.com/books/1230000000929/ch07.html
06:41:49 <tabaqui1> @quote Edward
06:41:49 <lambdabot> shachaf says: edwardk will try to get you addicted to monoids. The first one is always free.
06:55:07 <Matteo_> is it possible to check if an MVar is empty
06:55:26 <Matteo_> without getting an IO Bool i need to use it in and if
06:55:35 <Matteo_> * an if
06:55:35 <geekosaur> @where iotut
06:55:36 <lambdabot> https://www.vex.net/~trebla/haskell/IO.xhtml
06:55:54 <geekosaur> the answe to your question is asked is and always will be no. because IO does not work that way
06:56:15 <geekosaur> read the IO tutorial I linked
06:56:41 <Matteo_> geekosaur: what link ?
06:56:57 <sethetter> The one lambdabot linked
06:56:59 <geekosaur> sorry, the one I had the bot link you.
06:57:08 <Matteo_> geekosaur: ah k
07:00:45 <Matteo_> what do they mean with: if g :: String, then g is the same string every time
07:01:09 <Matteo_> oh nvm iam retarded
07:01:18 <cawfee> just remove your g string
07:06:59 <Matteo_> what does the \ mean in haskell
07:07:17 <Matteo_> like in \s -> or \_ ->
07:08:04 <Sose> anonymous function
07:08:30 <Sose> \ looks a little bit like the small lambda symbol
07:09:22 <Matteo_> thx
07:09:56 <cawfee> does ghc support the actual lambda character though?
07:09:59 <cawfee> im lazy to test
07:10:08 <hpc> there's an extension for it
07:10:13 <hpc> UnicodeSyntax or some such
07:10:53 <cawfee> > (λx -> x) 12
07:10:57 <lambdabot>  error:
07:10:57 <lambdabot>      Pattern syntax in expression context: λx -> x
07:10:57 <geekosaur> not the actual lambda chatracter, because it's unicode letter syntax
07:20:55 <Matteo_> is there a way to use a IO Bool in and if statement
07:23:58 <hpc> Matteo_: usually you bind the result (ie, with "<-" syntax in do-notation), and use that instead
07:24:04 <eschnett> the Apply type class has laws (see e.g. https://hackage.haskell.org/package/semigroupoids-5.2.2/docs/Data-Functor-Apply.html). do these laws have names?
07:24:50 <Matteo_> hpc: ah yeah  forgot about that thx m8
07:33:10 <hpc> eschnett: i bet you could write an operator that makes it look like associativity
07:33:17 <hpc> similar to (<=<) for the Monad laws
07:35:47 <Matteo_> when i use a do block is there way of returning a instead of IO a
07:38:22 <hpc> Matteo_: no
07:38:27 <hpc> that's the purpose of the IO type
07:39:24 <Matteo_> so i have to use simulateIO instead of simulate
07:41:05 <kuribas> Matteo_: you'll want to do an IO action with the return value anyway.
07:48:25 * tpnr01d
07:53:44 <i-am-the-slime> Can somebody tell me what a ConId is?
07:54:41 <cocreature> probably a constructor name
07:55:14 <i-am-the-slime> Well actually I'm looking at these people here:
07:55:18 <i-am-the-slime> https://hackage.haskell.org/package/haskell-src-1.0.2.0/docs/Language-Haskell-Lexer.html
07:55:32 <i-am-the-slime> and I would like to understand what the abbreviations stand for
07:55:57 <i-am-the-slime> Oh, you mean 'Con = constructor' and 'Id= name'?
07:56:30 <ski> identifier
07:57:12 <cocreature> i-am-the-slime: take a look at https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-160002.2, it looks like the names are taken from the standard
07:58:12 <i-am-the-slime> cool, thank you
08:09:11 <eschnett> hpc: hmm. nice idea. i haven't seen it before, though... maybe with (,) and unurry... i'll ponder it.
08:14:19 <Matteo_> i cant import Control.lens how do i do it ?
08:14:53 <Boomerang> Matteo_: have you installed the lens library?
08:15:05 <Matteo_> I cant find it
08:15:24 <Boomerang> What are you using to build your project? cabal, stack?
08:15:28 <Boomerang> nix?
08:15:33 <Matteo_> cabal
08:16:21 <Boomerang> You need to add "lens" in your .cabal file under build-depends
08:16:51 <Matteo_> by doing cabal install lens ?
08:17:30 <Boomerang> Then you can install it. I usually do: cabal configure && cabal install --only-dependencies
08:18:25 <Boomerang> If you are starting to install many different versions of library I would suggest looking into cabal sandboxes, stack or cabal new-build (I don't know anything about that last option though)
08:19:30 <Matteo_> so how do i install lens ?
08:19:33 <Boomerang> Matteo_: doing "cabal install lens" will install the library system wide (if you are not using sandboxes). But it won't add it to your .cabal file
08:20:01 <Boomerang> Do you have a .cabal file for your project?
08:20:14 <Matteo_> Boomerang: no i dont think so
08:21:22 <Boomerang> You said you were using cabal, is that just to install your dependencies? What are you using to build your project, GHC by itself?
08:21:46 <Boomerang> You can start your cabal project whenever by doing "cabal init"
08:21:53 <Matteo_> to run them i type ghci then :l test.hs
08:23:36 <Boomerang> I see, in that case if you are just experimenting with ghci setting up a cabal project might not be necessary just yet, "cabal install lens" should be enough :)
08:26:05 <Matteo_> Boomerang: If i set up an cabal project what are the benefits of it because i am making a project for school
08:28:12 <Boomerang> Matteo_: Well ghci is good for experimenting or just running a few function at a time. If you need your program to actually run on your computer using a cabal project will make it easier to compile your source code along with your dependencies (such as lens)
08:29:43 <Boomerang> Is using lens a requirement for your school project? I would probably not use lens if it's only for a small project.
08:30:24 <Matteo_> no i used lens to test an other porject from github
08:38:52 <Matteo_>  * Couldn't match type `Simulator -> IO Simulator'                      with `IO Simulator'
08:39:10 <Matteo_> i dont know how to fix this error
08:39:21 <cocreature> without seeing your code we can’t tell you how to fix it either
08:39:22 <erisco> change your term
08:39:46 <Matteo_> update :: MVar Command -> Float -> Simulator -> IO Simulator update device seconds simulator =   do test <- isEmptyMVar(device)      if test        then (moveRobot seconds simulator)        else (moveRobot seconds simulator) update _ _ state = return state
08:39:49 <suzu> anybody know any tricks for removing overlapping typeclass instances?
08:39:58 <suzu> i have:
08:40:02 <erisco> suzu, backspace :)
08:40:10 <suzu> instance Foo () where
08:40:11 <suzu> and
08:40:13 <cocreature> Matteo_: please use some pastebin service instead of pasting multiline code samples here
08:40:18 <suzu> instance FromJSON f => Foo f where
08:40:37 <suzu> i don't want to use the FromJSON () :/
08:40:53 <Matteo_> cocreature: https://codeshare.io/50x19N
08:41:14 <erisco> suzu, you can fix this particular scenario but it is unpleasant … you probably want to consider a different design
08:41:34 <suzu> umm hm crap
08:41:39 <suzu> any ideas on other designs i can try?
08:41:49 <erisco> suzu, but you can see the method employed here https://hackage.haskell.org/package/control-dotdotdot-0.1.0.0/docs/src/Control-DotDotDot.html
08:41:55 <erisco> and thanks to glguy iirc for the idea
08:41:59 <cocreature> Matteo_: alright, now please add the full error message to this and at least the type signature of moveRobot
08:44:09 <Matteo_> cocreature: https://codeshare.io/50x19N
08:44:13 <suzu> i don't understand how this works
08:44:17 <suzu> and why it doesn't overlap
08:44:44 <suzu> i do know a bit about datakinds
08:44:51 <cocreature> Matteo_: that still doesn’t contain the error message or the type signature of moveRobot
08:45:20 <suzu> class b ~ IsFun f => DotDotDot f (b :: Bool) where
08:45:59 <suzu> so this means the only instances of DotDotDot can be: DotDotDot f 'True and DotDotDot f 'False for some f
08:46:23 <suzu> and f is either a function or a value
08:46:40 <Matteo_> cocreature: https://codeshare.io/50x19N
08:47:03 <erisco> suzu, it does not overlap because 'True does not overlap with 'False, and the type family decides whether a type maps to 'True or 'False
08:47:20 <erisco> suzu, in your example you would map () to 'True, say, and other types to 'False
08:47:28 <suzu> ohh i see
08:47:37 <cocreature> Matteo_: you’ll have to pass the MVar to "update" when you pass it as an argument to "playIO"
08:47:47 <suzu> you have an extra piece of type information here (is the argument a function or not?) and you split the instances on that parameter
08:48:06 <suzu> but the downside here is you need to deal with bookkeeping that extra argument properly
08:48:13 <suzu> hmm i think i understand
08:48:26 <phadej> erisco:
08:48:46 <suzu> i think this is exactly what i needed erisco
08:48:48 <phadej> class b ~ IsFun f => DotDotDot f (b :: Bool) | f -> b where probably won't wokr?
08:48:58 <Matteo_> cocreature: I dont realy understand what you mean with that ?
08:49:10 <suzu> i am using () to denote "Foo with no return parameter" but FromJSON f => Foo f to denote "Foo with a return value of something json-able"
08:49:23 <suzu> so i think i can define a typefamily right over that (does it have a retval or not)
08:49:40 <suzu> and.. pretty much just use this technique
08:49:58 <erisco> suzu, a way to look at it is that 'True indicates a base case and 'False indicates a recursive case
08:50:05 <cocreature> Matteo_: the last argument to "playIO", needs to be a function of type "Float -> Simulator -> IO Simulator" but your "update" function has type "MVar Command -> Float -> Simulator -> IO Simulator". If you partially apply update to an MVar, so "(update yourMVarHere)", it will have the right type
08:50:27 <suzu> yup, as you have True for * -> * and False for *
08:50:35 <suzu> i see
08:50:36 <erisco> suzu, so, in my example, I am recursing on  b  in  a -> b  until  b ~ p -> q  does not hold
08:51:11 <erisco> or I think because of precedence rules that has to be written  b ~ (p -> q)  but w/e
08:51:13 <Matteo_> cocreature: and how do i partially aplly update do an MVar ?
08:51:58 <cocreature> Matteo_: literally like I just showed you: pass "(update yourMVarHere)" to playIO instead of "update" where yourMVarHere is the name of your MVar
08:52:45 <Boomerang> (at the call site in "playIO window background ... (update yourMVarHere)")
08:53:57 <Boomerang> Also the type of "moveRobot" should probably be "Float -> Simulator -> IO Simulator" or you need to add a "return" in your update function
08:54:20 <Matteo_> it works omg yessss
08:54:27 <Matteo_> thx guys
08:54:27 <erisco> phadej, I am not sure if there would be any difference adding a fundep
09:04:55 <Matteo_> say i have created an MVar in a thread how do i acces it from another thread ?
09:05:10 <phadej> erisco: hmm, it doesn't work with GHC-8.2
09:05:24 <erisco> phadej, what doesn't?
09:05:30 <phadej> dotdotdot
09:05:43 <erisco> it doesn't compile? the base version has to be bumped
09:05:55 <cocreature> Matteo_: in the same way that you would access it from the thread that created it originally
09:06:12 <phadej> erisco: source changes are needed
09:06:28 <phadej> -type Return (_ -> b) 'True = Return b (IsFun b)
09:06:32 <phadej> +ype Return (a -> b) 'True = Return b (IsFun b)
09:06:46 <Matteo_> cocreature: but therefore i need a pointer to it no ?
09:06:56 <erisco> did they muck with things again? okay
09:08:10 <cocreature> Matteo_: sure you need a reference but you can just pass it as an additional argument to the thing that you pass to "forkIO" and then partially apply it like you did for the "update" function
09:08:15 <phadej> erisco: "Type indexes must match class instance head"
09:13:13 <Matteo_> cocreature: i get a parse error for my input from forkIO
09:13:56 <Matteo_> cocreature: ill make a codeshare link
09:15:01 <Matteo_> cocreature: https://codeshare.io/50x19N
09:16:49 <cocreature> Matteo_: you need to align the statements in a do block, in particular, "device", "forkIO" and "return" need to start in the same column
09:18:34 <Matteo_> cocreature: oh wow i would never have found that thx
09:23:39 <suzu> erisco: do you need UndecidableInstances here?
09:23:45 <erisco> suzu, yes
09:23:56 * suzu is triggered
09:24:01 <suzu> why?
09:24:07 <erisco> this is par for the course of type level programming
09:24:13 <suzu> sad
09:24:17 <suzu> okay
09:24:39 <erisco> GHC can only prove termination in limited cases
09:25:10 <erisco> -XUndecidableInstances is essentially saying "trust me", but actually GHC just tries to a depth of 1000 or w/e the default is
09:25:22 <suzu> oh i see
09:26:20 <glguy> UndecidableInstances might just fail to check, but it's all good if it does check. Something like IncoherentInstances is the one that can check and still have bad surprises
09:29:01 <suzu> ic
09:38:20 <MarcelineVQ> oh hey there's finally a https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/
09:38:34 <MarcelineVQ> and it even covers package.yaml at the same time
09:52:20 <sm> nice
10:04:06 <[exa]> Hm guys.
10:04:32 <[exa]> What's the easiest way to have a functor instance on (,) that works with the 'fst' instead of 'snd' ?
10:04:50 <hpc> bifunctor
10:05:04 <dmj`> > over both (+1) (1,1)
10:05:08 <lambdabot>  (2,2)
10:05:32 * [exa] still trying to resist the lens temptation
10:06:07 <dmj`> resistance is futile
10:06:08 <Matteo_> could some one help me with this error I have
10:06:09 <Matteo_> https://codeshare.io/50x19N
10:06:10 <[exa]> hpc: that will do, thanks :D
10:06:48 <electrocat> Matteo_: if needs an else
10:06:49 <glguy> Matteo_: You forgot the 'else' part of the if,then,else expression
10:06:50 <dmj`> Matteo_: you lack an else clause
10:06:54 <glguy> :t when
10:06:56 <lambdabot> Applicative f => Bool -> f () -> f ()
10:07:12 <Matteo_> ah
10:07:12 <glguy> Matteo_: also, return doesn't appear to mean what you had hoped
10:07:43 <Matteo_> glguy: what does it mean then ?
10:08:37 <glguy> It's not an early exit statement like in C
10:08:46 <dmj`> Matteo_: what is the type of  moveRobot, I bet it doesn’t take a tuple
10:08:54 <glguy> It makes an action that has no effects and just produces the given value as a result
10:09:17 <electrocat> :t return
10:09:19 <lambdabot> Monad m => a -> m a
10:09:24 <glguy> Matteo_: do name <- return "my name"; print name
10:09:44 <glguy> That would print, for example
10:09:45 <ertes> [exa]: you can resist the lens library, but i recommend that you learn van laarhoven optics anyway, because they are really just a generalisation of 'traverse'
10:10:17 <Matteo_> dmj`: it does take a tuple
10:10:36 <Matteo_> glguy: Is there a way to end do early \/
10:10:40 <glguy> no
10:11:07 <glguy> In this case once you have an else branch for the rest of the action, you won't need to end early
10:11:23 <[exa]> ertes: I'm usually kindof reluctant to pull the whole lens library just because one flipped tuple (I'm avoiding structured data as much as I can)
10:11:37 <ertes> [exa]: traverse :: (Applicative f) => (a -> f b) -> (c, a) -> f (c, b)  -- this maps over the snd of a tuple…  if you replace Applicative by Functor, you have a lens, which means you can also read the value, and because lenses and traversals aren't bound to type classes you can easily write a traversal for fst or even both
10:11:39 <dmj`> Matteo_: k, you don’t need parens around takeMVar(device) nor  isEmptyMVar(device)
10:12:09 <[exa]> (oh wow there's microlens)
10:12:20 <ertes> [exa]: you don't have to…  that's what i'm saying: it's just a pattern you can use without any library dependency =)
10:13:21 <electrocat> I feel like Matteo_ is trying to advanced things
10:13:24 <electrocat> too
10:13:26 <electrocat> *
10:13:45 <Matteo_> glguy: when i put it in the else i still get the error https://codeshare.io/50x19N
10:13:48 <electrocat> without having grasped the basics
10:13:50 <[exa]> ertes: that is the standard traverse from Control.Monad?
10:14:00 <ertes> [exa]: Data.Traversable
10:14:07 <glguy> Matteo_: If you want to use a do-block in the else case, you need a do
10:14:19 <[exa]> OIC ((,) c) is also traversable
10:14:21 <[exa]> gooooood
10:14:25 <[exa]> thanks
10:14:33 <ertes> [exa]: 'traverse' is a traversal, so you can use it as a setter and sometimes as a getter
10:14:41 <glguy> Matteo_: What's the type of moveRobot?
10:14:43 <ertes> > (traverse +~ 5) (10, 20)
10:14:43 <Matteo_> glguy: but then i make a new do block without ending the first do block with an expresion
10:14:47 <lambdabot>  (10,25)
10:14:58 <glguy> Matteo_: if-then-else is an expression
10:15:12 <electrocat> Matteo_: no, it's a nested to block
10:15:16 <electrocat> do block*
10:16:04 <Matteo_> i have added moveRobot to the link https://codeshare.io/50x19N
10:16:16 <glguy> Matteo_: In the updated paste moveRobot doesn't expect a tuple, so don't apply it to a tuple in the definition of update
10:16:26 <electrocat> indeed
10:16:38 <electrocat> it should be 'moveRobot seconds simulator'
10:17:04 <electrocat> function applications don't need parathesis
10:17:12 <Matteo_> oh yeah
10:18:18 <dmj`> Matteo_: told ya no tuple :)
10:18:24 <electrocat> ghc is not complaining about that yet because it's a type error
10:18:35 <electrocat> when your syntax is correct it will complain about it
10:18:37 <Matteo_> dmj`: yeah though you meant something else sorry xd
10:22:01 <dmj`> you could use a tuple if you uncurried moveRobot
10:22:23 <dmj`> :t uncurry (flip const)
10:22:25 <lambdabot> (b, c) -> c
10:22:29 * ski idly ponders uncurrying lambdabot
10:22:46 <dmj`> assuming flip const is moveRobot
10:22:53 <Wizek> Hey, what's the current easiest way to try GHC HEAD (or a commit close to head)? I'm interested in trying 96b52e63b850, or a later commit incorporating that one.
10:23:20 <[exa]> Wizek: you probably don't want to hear 'git clone and compile' ? ;]
10:23:25 <MarcelineVQ> Wizek: https://ghc.haskell.org/trac/ghc/wiki/Building
10:23:32 <MarcelineVQ> https://ghc.haskell.org/trac/ghc/wiki/Building/QuickStart
10:24:16 <dmj`> Wizek: install nix, then run “nix-shell -p ‘haskell.compiler.ghcHEAD''
10:24:36 <Wizek> dmj`: I will try that! I already have nix
10:24:51 <phadej> Wizek: or if you are on Ubuntu https://launchpad.net/~hvr/+archive/ubuntu/ghc
10:24:52 <Wizek> dmj`: do you think hydra even builds it periodically?
10:25:04 <ertes> Wizek: nix is probably the easiest:  nix-shell -p haskell.packages.ghcHEAD.ghc
10:25:30 <ertes> Wizek: if the commit is not new enough, just change it
10:26:12 <dmj`> Wizek: we can check, I’m on latest nixpkgs-unstable, the path it’s requesting is /nix/store/yzwkh1260x4c3lsy8bfmygdpy4kr3p2g-ghc-8.5.20171209
10:28:16 <Wizek> dmj`: huh, it even seems to get it from cache, cool
10:28:21 <dmj`> yea
10:28:23 <dmj`> *** Downloading ‘https://cache.nixos.org/nar/0kmg6nx6lxz1mhws5sz2ypmbl93n62jcx8pv38kc9jw13fxqh0hm.nar.xz’ (signed by ‘cache.nixos.org-1’) to ‘/nix/store/yzwkh1260x4c3lsy8bfmygdpy4kr3p2g-ghc-8.5.20171209’...
10:28:44 <Wizek> Now I go onto wondering whether this is a recent enough build containing this commit
10:28:48 <dmj`> Wizek: think of how many hours you would have wasted today :)
10:28:57 <ertes> Wizek: if not, you can override the commit
10:29:18 <ertes> Wizek: i don't know how to do it properly for GHC itself, but the fine folks at #nixos are going to tell you =)
10:29:29 <ertes> or just clone nixpkgs and change it right in the source
10:29:49 <dmj`> haskell.compiler.ghcHEAD.override { … src = fetchFromGitHub {..} } probably
10:30:13 <Wizek> dmj`: yeah, my explicit reason for asking here was in the hopes of saving those ours :)
10:30:27 <ertes> not quite that easy…  the override system for haskell packages has changed
10:31:02 <MarcelineVQ> Wizek: are you sure that's the sha of a ghc commit?
10:31:09 <MarcelineVQ> can't seem to find it
10:31:44 <Wizek> dmj`: before I would do that, I am trying to figure out how to get see the current commit hash. I know of `nix-instantiate --eval -E '(import <nixpkgs> {}).haskell.packages.ghcHEAD.ghc.version'`, and now I am trying to guess the attr name for the commit hash
10:32:14 <Wizek> MarcelineVQ: I've seen it here: https://git.haskell.org/ghc.git/commitdiff/96b52e63b850f8072b905ca232b5644efc011b37
10:32:14 <dmj`> Wizek: if you update the hash, you’ll alter the derivation, and therefore the hash, hydra won’t find it in the cache
10:32:31 <Wizek> dmj`: Of that I am aware.
10:32:32 <ertes> Wizek: src
10:32:40 <dmj`> the ghc hash*, and the store path hash*, two different hashes :)
10:32:50 <Wizek> yup
10:32:56 <MarcelineVQ> that's so weird, wonder why it's not getting picked up in my git log
10:33:12 <Wizek> MarcelineVQ: maybe you haven't fetched in a while?
10:33:24 <dmj`> Wizek: if you use nix-repl there’s a cheat to get the exact line number in nixpkgs to show you the ghc hash
10:33:48 <Wizek> dmj`: I have, tell me the chear code!
10:33:53 <Wizek> *cheat
10:34:07 <dmj`> Wizek: it’s a big cheat code in the nix ecosystem
10:34:31 <dmj`> Wizek: do you use nix-repl?
10:34:42 <Wizek> dmj`: occasionally yes
10:34:46 <Wizek> I have it running now
10:34:51 <dmj`> nix-repl ‘<nixpkgs>'
10:34:54 <dmj`> nix-repl> haskell.compiler.ghcHEAD.meta.position
10:34:54 <Wizek> yes
10:35:19 <dmj`> shows you the exact path in your nixpkgs (from the channel) to the file and line number of this derivation
10:35:29 <MarcelineVQ> oh hmm it's called  1e14fd3ecfd468c3beddb2e5f992c358e1a798de  in the ghc git tree, how confusing
10:36:17 <Wizek> dmj`: ooh, that's an interesting spell!
10:36:17 <dmj`> Wizek: the cached ghc 8.5 is rev = "b4f2afe70ddbd0576b4eba3f82ba1ddc52e9b3bd";
10:36:19 <MarcelineVQ> ah  (cherry picked from commit 1e14fd3ecfd468c3beddb2e5f992c358e1a798de)  software dev is so weird
10:36:29 <dmj`> Wizek: with great power comes great responsibility
10:36:44 <ertes> .override (args: args // { mkDerivation = expr: args.mkDerivation (expr // { src = nixos.pkgs.fetchgit { rev = "COMMIT"; sha256 = "HASH"; }; }); })
10:36:49 <ertes> this should work
10:38:17 <ertes> you can use this in haskellPackageOverrides in ~/.nixpkgs/config.nix
10:38:18 <Wizek> dmj`: Don't worry, I predominantly only work with the white arts. And only stray as dark as gray-magic goes; and even that only seldomly. ;)
10:39:35 <Wizek> ertes: thanks for that!
10:40:21 <dmj`> Wizek: yes, this is definitely blurring the lines between good and evil
10:40:26 <dmj`> Wizek: https://gist.github.com/7d92e269ffe9952e566c6c7f582ab70f
10:40:44 <ertes> of course that means nix will build GHC…  but at least you don't have to do it manually, and it will be integrated into nixpkgs
10:41:49 <nh2[m]> Wizek: but take into account that using the standard nix build will build with full optimisations, which will take > 10x longer than if you use the `quickest` build when building manually
10:42:15 <Wizek> nh2[m]: oh, that's great to know too!
10:42:37 <nh2[m]> so if you want to change anything or try a couple commits, you might be better off building manually from a normal git clone instead of via nix
10:42:37 <eschnett> i have a quickcheck property that takes too long to test. i'm using the tasty-discover plugin to discover the properties. is there a good way to reduce the problem size chosen for the properties?
10:42:39 <Wizek> I suspect that can be overridden not-too-difficultly with nix too, right?
10:42:49 <eschnett> i'm testing with lists, so using shorter lists might speed things up?
10:42:50 <ertes> you probably want GHC with optimisations =)
10:43:36 <nh2[m]> Wizek: yeah, but even if you do so, you lose incrementality, e.g. if you cherry-pick some commit or check out a close-by commit, you have high chances of the following recompile taking < 1 minute
10:43:40 <nh2[m]> with nix, it will always build from clean
10:44:03 <Wizek> eschnett: have you tried running with profiling to see where the time leak might come from?
10:44:05 <nh2[m]> ertes: depends on what is to be tested. If it's a crash or feature, `quickest` does all fine
10:44:18 <ertes> right
10:44:28 <nh2[m]> if it's some performance thing, then of course not
10:44:52 <Wizek> It is a feature indeed, so performance is of no concern at the moment
10:46:50 <Wizek> By which I mean the performance of the compiler/compiled program. I still would like if building it took less than hours though.
10:47:30 <Wizek> nh2[m]: So, just for the sake of completeness, if I were to hypothetically clone the git repo /by hand/, and want to build with `quickest`, how could I do that?
10:47:37 <Wizek> And how long would that take roughly?
10:50:11 <nh2[m]> Wizek: you clone the repo, run `git submodule update --init --recursive` after any checkout to make sure you have correct submodules. You `cp mk/build.mk.sample mk/build.mk`, and edit `mk/build.mk`, commenting-in the `BuildFlavour = quickest` line. Then you run `./boot`, `./configure` and `make -j4` or appropriate number of cores.
10:50:24 <nh2[m]> The quickest build takes 5 minutes on my i5 Haswell CPU
10:50:50 <Wizek> hmm, 5 mins is not too bad
10:51:12 <Wizek> enticing, even with all that manual setup
10:51:41 <nh2[m]> It will leave the GHC binary in `inplace/bin/ghc-stage2`. If you only need that binary (e.g. to compile a simple example file), you can build a bit faster by using `make -j4 inplace/bin/ghc-stage2`
10:52:46 <nh2[m]> another possibility to build is to use the new Hadrian build system instead of make. There the simplest way is to install stack, and then run `hadrian/build.stack.sh --configure -j --flavour=quickest` (as you see, all in one command) after simply cloning and updating submodules.
10:53:12 <nh2[m]> you may have to manually do `stack install happy alex` from the `hadrian/` subdir if you don't have the happy and alex executables already in PATH
10:53:30 <dmj`> think you can alter build.mk from nix
10:55:09 <nh2[m]> yeah I guess you could add some lines to this preConfigure script https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/compilers/ghc/head.nix#L42 when overriding the derivation
10:55:45 <Wizek> nh2[m], ertes, dmj`, MarcelineVQ (and perhaps others too) Thanks for all the info! I hope to try some of these soon.
10:55:50 <eschnett> Wizek: good idea. i will do that -- looking at the stack documentation now.
10:57:09 <dmj`> pretty sure,  pkgs.lib.overrideDerivation (pkgs.haskell.compiler.ghcHEAD) (drv: { buildMK = ''goes here''; }), would work
10:57:33 <Wizek> eschnett: Indeed, in my experience, when it comes to performance, profiling prior and after is crucial; often the leaks don't come from where I initially think they do.
10:58:41 <dmj`> seems buildMK isn’t included in GHCs past 784, on nix
10:59:35 <int-e> dmj`: there's a build.mk.sample; the workflow is to copy that to build.mk, then edit
11:00:36 <dmj`> int-e: yea, I’m just not sure where in nixpkgs, in the ghcHEAD derivation, you’d go about overriding build.mk
11:00:53 <int-e> oh hmm
11:01:24 <dmj`> Maybe here, in preConfigure, https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/compilers/ghc/head.nix#L52
11:02:07 <Welkin> what are the advantages of using shake over make?
11:02:45 <dmwit> Shake gives much finer-grained control over dependencies than make. "file" is not the primitive dependency concept.
11:02:54 <int-e> dmj`: sed 's|#BuildFlavour  = quick-cross|BuildFlavour  = perf-cross|' mk/build.mk.sample > mk/build.mk <-- this lines creates the build.mk file and chooses the perf-cross flavour; you can do something similar, maybe?
11:03:25 <dmwit> If you want to depend on build flags, you can do so. If you want to depend on a specific line in a CSV file, you can do so.
11:03:46 <dmwit> Moreover, even when you use "file" as a dependency object, the modification checking is more robust, because it uses a hash by default instead of the modification date.
11:05:00 <dmwit> (For a non-stupid example of the CSV file thing: I had a build that would consult a CSV file to decide which things to fetch from the Internet and how to proceed from there. Changing the CSV file then did not rebuild the entire thing from scratch; it only fetched and built the new or modified lines, retaining the build products from any lines that survived the change.)
11:05:06 <Welkin> I've seen examples of people using shake + pandoc to create a static site (or even a blog)
11:07:02 <Welkin> I'm wondering it it would be helpful to use to generate an html book with pandoc
11:08:12 <Welkin> has anyone added references/anchors to each heading in the output of a pandoc html book?
11:08:48 <Welkin> like the little chain link button that shows up to the left of headings on github?
11:10:29 <Welkin> I am not sure if this is possible using templates
11:10:46 <Welkin> or if I need to post-process the html (or the AST)
11:11:06 <Welkin> I'm using the pandoc executable
11:11:16 <Welkin> I suppose I would have a lot more flexibility if I used the library
11:11:44 <Welkin> it uses lua for processing I believe
11:11:50 <Welkin> the binary does
11:15:36 <Matteo_> does some one know how to do collision detection
11:21:59 <humanoyd> I just watched this introduction to propositions as types (https://www.youtube.com/watch?v=SknxggwRPzU), but I feel a little uneasy with the translation of logical disjunction (A v B) to a sum type (Either A B). What if A AND B are true? Would I just arbitrarily pick one of the two?
11:22:29 <geekosaur> humanoyd, you're thinking of it wrong
11:22:36 <geekosaur> Either A B *is* a disjunction
11:22:42 <geekosaur> the type cannot represent "and"
11:22:50 <geekosaur> it is either a Left or a Right
11:24:58 <humanoyd> geekosaur: but wouldn't then something like `data OneOf a b = Left a | Right b | Both a b` be a better fit?
11:25:17 <[exa]> humanoyd: curry-howardish way to look at it: the programs are proofs; you only need to prove one side of "or". So you just either supply a proof that proves the left type, or one that proves the right type
11:26:00 <[exa]> humanoyd: proving both by the program is in fact equivalent to proving conjunction
11:27:07 <[exa]> (and yes a&b implies a|b, which makes a nice proof btw.)
11:29:42 <humanoyd> There are only two, right? `proof1 (a, _) = Left a` and `proof2 (_, b) = Right b`
11:30:03 <[exa]> afaik yes
11:30:59 <WarzoneCommand> hmm question. I'm trying to coerce data of one type to another type, but somehow I'm not getting it to work. Some small example is at : http://lpaste.net/361821
11:31:55 <WarzoneCommand> so I guess because s may have any kind k, but 'Wrap s' has kind * it does not want to coerce Dart s into Dart (Wrap s). But I don't really see why that is a problem/how to get this to work
11:32:30 <lyxia> WarzoneCommand: what is Wrap
11:32:35 <humanoyd> another question: `not P` was translated to `P -> Void`. Does such a function exist at all?
11:32:45 <[exa]> I can't believe there's star trek in the paper
11:32:58 <WarzoneCommand> lyxia: data Wrap s = W
11:33:12 <WarzoneCommand> (the = W is just so that I don't have to enable emptyDataDecls)
11:33:19 <lyxia> WarzoneCommand: Ah I missed it
11:33:25 <WarzoneCommand> essentially, it is just a way of forcing that the type of s is not the same as Wrap s
11:38:07 <[exa]> humanoyd: yes, there's no way to construct Void
11:39:24 <[exa]> but there's much information loss in the intuitionistic negation
11:42:53 <humanoyd> [exa]: so, does `not P` in this context mean that there is no way to come up with a value of type `P` ?
11:43:31 <[exa]> humanoyd: they have a good example here: https://en.wikibooks.org/wiki/Haskell/The_Curry%E2%80%93Howard_isomorphism#Negation
11:43:33 <glguy> WarzoneCommand: You don't need EmptyDataDecls any more, that's part of Haskell2010
11:44:55 <[exa]> humanoyd: in fact, if the P contains any Void (i.e. is uninhabitable), the negation function can extract it and return it; which makes it exist and `not P` is proven
11:44:56 <humanoyd> [exa]: thanks
11:46:40 <humanoyd> what about `not (not P)`? That would be `(P -> Void) -> Void`. How is that `P`?
11:47:06 <[exa]> double negation doesn't "disappear" in intuitonistic logic
11:47:15 <lyxia> WarzoneCommand: that looks like a bug
11:47:34 <[exa]> so certainly it isn't `P`
11:49:01 <lyxia> WarzoneCommand: could you restrict s to be of kind *
11:52:10 <[exa]> humanoyd: btw see below on the same page, "Intuitionistic vs. classical logic"
11:53:16 <WarzoneCommand> hmm restricting s to kind * is kind of ugly. I'll have a look if it also gives an error with the latest GHC
11:53:33 <humanoyd> [exa]: and down the rabbit hole it is, once again :>
11:54:17 <[exa]> humanoyd: they make a kindof funny point that `catch' proves double negation theorem
12:30:44 <ertes> humanoyd: if you think of Void as absurdity, it may make more sense:  "P -> Void" can be read as: "P would imply non-sense"
12:32:22 <ertes> humanoyd: "not (not P)" does not imply P…  all it means is that "P leading to absurdity would be absurd", which doesn't magically give you a proof for P
12:32:44 <dmwit> I'm not sure that analogy helps much.
12:32:50 <dmwit> At least, it doesn't help me.
12:33:08 <dmwit> I mean, triple negation becomes double negation, and it's not clear how you could intuit that from your analogy.
12:33:13 <ertes> it did help me, so perhaps it does help some others…  it's just another perspective
12:33:16 <dmwit> s/double/single/ I mean
12:34:02 <ertes> but from triple negation you *can* prove single negation, and the way to build intuition about that is to actually read the proof term
12:35:04 <dmwit> That's what I'm saying: it isn't clear what's gone wrong between your sentence and "If it would be absurd for P leading to absurdity to be absurd, that doesn't magically give you a proof that P is absurd".
12:35:14 <dmwit> But your sentence is right, and the latter one isn't.
12:36:23 <dmwit> (...so the intuition hasn't helped, it's just made everything more verbose and twisty.)
12:37:55 <ertes> well, you could explain purely syntactically, and to some people that's the best way to learn…  but i believe thinking about Void as "absurdity" is a safe intuition
12:39:11 <ertes> after all there is no built-in notion of falsity in type theory, so to make sense of "not" actually requires some intuition for some people – i'm one of them
12:40:24 <dmwit> Okay. Perhaps I misunderstood the purpose of your proposed intuition.
12:40:59 <dmwit> I thought the purpose was to explain why double negation elimination isn't valid in intuitionistic logic, but rereading, it seems you may just be proposing it as an intuition for what `-> Void` means instead, which is a narrower thing.
12:41:34 <dmwit> That is, you're proposing a reading of the statement that double negation elimination isn't valid, not an explanation of why it's so.
12:41:52 <ertes> dmwit: yeah, that was the purpose, whereas double negation was just an example application of the intuition
12:42:13 <ertes> i could have made that clearer, sorry
12:43:08 <dmwit> Right. That's a useful thing to suggest.
12:43:30 <parsnip> hmm, lhs is best file format to work on typeclassopedia exercises? tex, org, md?
12:43:47 <parsnip> org has that thing where you can switch to the mode with C-c '
12:44:12 <parsnip> i'm in md at the moment
12:44:34 <Welkin> md sucks for writing code
12:44:51 <Welkin> if you want proper editor support for highlighting and formatting, use literate haskell
12:44:57 <ertes> parsnip: i'd recommend lhs or tex, not because they are particularly good, but because chances are your editor mode supports them
12:45:05 <parsnip> emacs
12:45:05 <Welkin> I have gone down that path already
12:45:13 <Welkin> tried org, tried md, rst, (and many others)
12:45:18 <Welkin> I even went to plain latex
12:45:24 <Welkin> and now to lhs
12:45:28 <ertes> parsnip: you can use haskell-interactive-mode with lhs and tex directly
12:45:44 <ertes> with org you realistically only get syntax highlighting and editing
12:45:48 <Welkin> latex sucks to write
12:45:58 <Welkin> lhs is my favorite of all
12:46:15 <Welkin> markdown+lhs with pandoc
12:46:31 <parsnip> hmm, will give `lhs` the old college try
12:46:34 <Welkin> where you can use markdown in your lhs
12:46:50 <ertes> parsnip: note that you can use an lhs/md polyglot format
12:46:54 <parsnip> yeah, it'd be neat to work out `lhs` into maybe a jekyll site or similar.
12:46:59 <ertes> parsnip: i do that in my tutorials
12:47:15 <Welkin> parsnip: that is supported already by pandoc (and hakyll)
12:47:19 <parsnip> interesting, will try
12:47:25 <Welkin> I am using lhs to write a book
12:47:28 <parsnip> yeah, i might have to try hakyll again soon
12:47:36 <Welkin> hakyll is best for a blog only
12:47:39 <Welkin> it is a wrapper around pandoc
12:47:55 <ertes> parsnip: https://github.com/esoeylemez/esoeylemez.github.io/blob/master/tutorial/foldr.lhs
12:48:04 <ertes> this is both md (for the homepage) and lhs (for GHCi)
12:50:32 <humanoyd> ertes: dmwit Thanks! For now, everything kind of makes sense if I'm replacing `true` with `provable` ...
12:51:55 <ertes> humanoyd: welcome to the wonderful w… niche that is constructive mathematics =)
12:53:15 <dmwit> humanoyd: Feel free to make that replacement when reading about classical logics, too.
12:53:43 <dmwit> humanoyd: (There's nothing special about intuitionistic logic or about classical logic that makes either one more obviously the authority on what is "true".)
12:53:50 <ertes> hmm…  in classical logic "provable" is stronger than "true" though
12:55:12 <dmwit> Is it? What is something which is (true but not provable) in classical logic? (What do you mean by "true"? "provable"?)
12:57:58 <hodapp> sounds like a reference to Gödel's proof and incompleteness: the notion that something can be true in a system, but not provable within the system
12:59:09 <Orbstheorem[m]> Hi, I'm trying to get started using Hakyll. I'm running nixos. When I ran stack build after running hakyll-init I got this error message: https://paste.gnugen.ch/raw/iyEV
12:59:10 <Orbstheorem[m]> Adding `nix.packages = [zlib.dev]` seems to have fixed the issue (Still building, but it went beyond the point it failed last time and it's been running for a couple of minutes). Is this a bug? If it is, is it a nixpkgs bug or a `digest` bug?
13:02:33 <dmwit> hodapp: That applies to intuitionistic logic, too, though, no?
13:03:09 <dukedave> Can anyone help me getting C++11 features enabled with Cabal
13:03:11 <dukedave> ?
13:05:35 <hodapp> dmwit: not sure
13:05:36 <dmwit> dukedave: That question sound a bit odd to me. But if you have a specific problem, the details are welcome here. No need to ask if anybody will help; instead just give the details of what you're trying to do, what you expected to happen, and where it went wrong.
13:06:42 <dmwit> dukedave: (It sounds odd because Cabal is a tool for building Haskell things, not C++ things. As far as I know, the only FFI stuff available in existing Haskell implementations goes to C (or javascript for GHCJS).)
13:07:12 <dukedave> Sure! I'm trying to build the haskell-opencv library, because I want to contribute. Unfortunately the Travis build has been broken for a long time, and I'm not too familiar with any of it. I've got an issue open here with my notes on: https://github.com/LumiGuide/haskell-opencv/issues/104
13:08:00 <geekosaur> Orbstheorem[m], have heard that before specifically about nix so I suspect it's just a nix thing
13:08:24 <geekosaur> not smart enough to add necessary C-FFI packages to haskell derivations, or something
13:08:34 <dukedave> dmwit: sorry I should have clarified, it's a library which needs to link with some C++ code. It seems to follow everything given here: https://stackoverflow.com/a/37643200/21115, but the build is failing because (AFAICT) it it needs some c++11 features enabled.
13:08:59 <ertes> dmwit: oh well, most people who use classical logics accept proof by contradiction, but then i suppose you could call that "provable"
13:09:19 <dmwit> ertes: I would indeed.
13:09:22 <Orbstheorem[m]> geekosaur: Alright, I'll ask around in #nix
13:09:25 <Welkin> proof by shouting
13:09:25 <Orbstheorem[m]> thanks!
13:09:25 <Welkin> :D
13:09:41 <Welkin> the louder you are, the more correct you are
13:09:46 <dmwit> ertes: At least, I'd call it "provable in classical logic". =)
13:10:58 <ertes> dmwit: yeah…  after all one could even question induction as a valid way to establish proof =)
13:12:24 <humanoyd> ertes: dmwit that w...niche seems to be very interesting :) See e.g. https://en.wikipedia.org/wiki/Finitism
13:12:29 <parsnip> so something like this? https://github.com/bradyt/typeclassopedia/blob/master/main.lhs
13:13:00 <ertes> humanoyd: yeah, the finitists are exactly the people who would question induction =)
13:13:41 <mnoonan_> I ended up turning the discussion on the “>>= \case” LambdaCase idiom into a reason to start blogging again. Feedback would be appreciated, my informal writing skills have noticably declined since I stopped teaching.
13:13:43 <mnoonan_> http://storm-country.com/blog/LambdaCase
13:23:38 <ertes> mnoonan_: i like it…  if i'm forced to give one nitpick, i'd point out that at some point i stopped reading and started skimming…  i think it's because the topic is rather basic, so the length really only makes the information density decline
13:25:51 <mnoonan_> ertes: fair enough! I definitely was sitting on the fence between focusing on the monadic idiom specifically vs just collecting all \case idioms I could glean from hackage, and the article probably suffers for it.
13:25:53 <Welkin> I can't seem to get pandoc to do what I want with all of the included files
13:26:00 <Welkin> I don't know why, but it looks wrong
13:26:11 <Welkin> has anyone used pandoc directly to generate a website?
13:27:51 <ertes> mnoonan_: keep in mind that i'm an experienced haskell programmer, so if your article would have introduced LambdaCase to me, i could have derived most of the article from just the introduction…  which is to say i may not be your target audience, so take it with a grain of salt =)
13:28:06 <ertes> mnoonan_: pick your information density according to your target audience
13:28:22 * mnoonan_ nods
13:29:42 <Welkin> pink himalayan rock salt?
13:30:17 <ertes> yellow himalayan black tea!
13:30:40 <parsnip> weird, all the repos i'm finding about solving typeclassopedia exercises don't have proofs.
13:31:19 <Welkin> what proofs?
13:31:42 <parsnip> the proofs you write when you solve an exercise.
13:31:53 <Welkin> where?
13:31:55 <parsnip> if you implement functor, shouldn't you prove?
13:31:58 <Welkin> I never did that
13:32:28 <parsnip> then by "you", i guess i don't mean _you_
13:33:23 <parsnip> what if you implementation is false and you don't know because you didn't prove?
13:33:33 <phadej> I had a quite large typeclassopedia.v (Coq file) but I lost it :/
13:34:27 <Welkin> as long as the compiler is happy and it works for my use cases, I don't care
13:35:42 <Welkin> it would be great if the compiler could get smarter
13:35:58 <Welkin> but I'm happy with what is available
13:36:08 <Welkin> whatever allows the least effort on my part to get something built
13:36:24 <parsnip> i didn't mean for your daily work, i meant what i assume might be considered part of the spirit of the typeclassopedia.
13:36:47 <parsnip> i'm just doing it to increase my fluency with using this stuff.
13:37:36 <parsnip> these sorts of exercises were recommended to me the last time i was faced with using monads well. like state and data structures, etc.
13:37:57 <Welkin> I never wrote any proofs related to haskell
13:38:08 <Welkin> the last time I wrote a proof was for geometry class in high school
13:38:09 <Welkin> haha
13:39:11 <parsnip> are we going there? how cool it is to not know math?
13:39:37 <parsnip> there's two kinds of people, those who say they hate math and those that say they love math. i hate both of them.
13:40:04 <parsnip> the one's that say they love it tend to start quoting ted talks.
13:40:09 <ertes> to not know math?  moss would drop his first cup after hearing this!
13:40:42 <Welkin> math is great
13:40:47 <parsnip> the ones that say they hate math seem to love how okay it is to say.
13:40:48 <Welkin> but I'm not going to write a proof to build a web app
13:41:06 <Welkin> I don't see where you are going with this parsnip
13:42:00 <parsnip> Welkin: where i'm going with what? i already said i'm not expecting you to do it for writing a web app. i'm considering it may help me build my own personal intuitions for using these constructs.
13:42:14 <Welkin> I have McLane's Algebra and Lawvere's category theory book. They don't help me one bit with haskell
13:42:38 <parsnip> i didn't say to study category theory
13:42:51 <Welkin> they are just type classes, interfaces
13:42:58 <Welkin> nothign special
13:43:08 <parsnip> if you say so
13:43:46 <Welkin> I don't think proofs will help you with intuition
13:43:57 <Welkin> just using the concepts will help you understand them
13:44:05 <Welkin> that is very sterile
13:44:13 <Welkin> like trying to learn how to fly an airplane by reading a book
13:44:21 <parsnip> why do typeclassopedia at all? just go write the web app.
13:44:32 <Welkin> I used the typeclassopedia when I started
13:44:33 <ertes> Welkin: i have to disagree about that…  so far my most efficient attempt at learning category theory was to formalise it in agda and write every single proof
13:44:34 <Welkin> it was helpful
13:44:52 <Welkin> ertes: category theory is itself an academic topic
13:44:55 <Welkin> it's not programming
13:44:55 <parsnip> and yes, i have frequently built intuition while writing proofs.
13:45:08 <parsnip> Welkin: you missed his point
13:45:14 <ertes> Welkin: it's actually both…  after that exercise my style of programming became a lot more algebraic
13:45:45 <parsnip> writing proofs can build intuition.
13:45:52 <ertes> but more importantly doing the hard work helped me build intuition
13:45:52 <dukedave> Cabal question: Will `--prog-options` be ignored if `build-type: Custom`?  https://www.haskell.org/cabal/users-guide/installing-packages.html#cmdoption-setup-configure-prog-options
13:46:01 <parsnip> you tend to find out while writing proofs why something works the way it does.
13:46:17 <parsnip> sure, i'm not saying proofs alone.
13:46:33 <parsnip> but the anathema is tedious
13:47:18 <ReinH> I think it's unsound to take a personal experience and turn it into a generalization about everyone else's experience
13:47:32 <ReinH> Learning about algebra and category theory may not have helped you. It certainly helped me.
13:48:32 <Welkin> I may give a much stronger opinion on that topic to counter-act the flood of people who believe that you *need* to learn category theory to use haskell
13:48:41 <kamyar> http://lpaste.net/6356762055772471296
13:48:47 <kamyar> plz fix my last line of code
13:48:48 <Welkin> it's useful to convince them that you do not need any at all
13:49:27 <Welkin> or involve any math whatsoever, and that monads are just an interface, etc.
13:49:51 <ReinH> I haven't seen anyone here suggest that you need to learn category theory to use haskell
13:50:05 <Welkin> I see it all the time from new people in here and elsewhere
13:50:45 <ReinH> kamyar: We can't fix it if you don't tell us what's wrong with it.
13:50:57 <Welkin> I think one of the best examples of how flexibile haskell is as a programming language is the "evolution of a haskell programmer" joke
13:51:06 <Welkin> http://www.willamette.edu/~fruehr/haskell/evolution.html
13:51:22 <Welkin> it's so flexible that you can get wildly different looking code
13:51:26 <kamyar> ReinH: I have a IO [TimeSpec] in lres
13:51:42 <Welkin> the more academic versions scare people off
13:51:48 <Welkin> give them the wrong impression
13:51:50 <kamyar> ReinH: I need to get 'nsec' of each and then avg them all
13:52:48 <parsnip> i did like how python had one way, but haskell is so expressive, with it's awesome abstractions and fewer delimiters.
13:52:53 <parsnip> *its
13:53:02 * geekosaur would like to note that "please fix xxx for me" is not ideal for this channel
13:53:22 <kamyar> ReinH: I changed the code
13:53:23 <geekosaur> we're happy to teach you how to recognize what's wrong and fix it yourself. we're not rent-a-coders
13:53:26 <kamyar> ReinH: see it
13:53:36 <kamyar> ReinH: but still buggy
13:57:05 <ertes> Welkin: my only point is that writing the proofs helped *me*
13:57:39 <ertes> and not only in programming, but also in reasoning…  the kinds of proofs you write in algebra are different from the proofs you write in, say, real analysis
13:59:03 <ertes> it's much like how the type of a polymorphic function conveys a lot more information than the type of a particular instance
13:59:14 <ertes> *instantiation
14:00:55 <Matteo_> does anyone know how to check if 2 line segments cross each other ?
14:01:16 <nut> I've seen this in xmonad code:  class Show (layout a) => LayoutClass layout a where...
14:01:27 <nut> so layout and a are two types
14:01:37 <ReinH> kamyar: If you want help, you should make an effort. For instance, including any compiler errors.
14:01:39 <Welkin> type variables
14:01:43 <nut> and (layout a) is also a type ?
14:02:02 <ertes> Matteo_: extend them into straight line equations, solve them to find the intersection point, then see if that point lies on one of the segments
14:02:07 <parsnip> Matteo_: in R^2?
14:02:12 <nut> why is (layout a) a type
14:02:41 <Matteo_> yeah that was what i was thinking but i hope that there was an easier way :(
14:02:49 <nut> Show (layout a) says that (layout a) is a type of Show typeclass
14:03:37 <ertes> Matteo_: err…  you need to check if the point lies on *both* of the segments
14:03:52 <geekosaur> nut, in xmonad a layout is a thing parameterized by a Window (but it's abstract because it was verified in agda, and we couldn't use X11 types there) that has a LayoutClass instance
14:04:08 <parsnip> Matteo_: there might be a trick where you shrink their domains and check if endpoints are on opposite sides, but that seems like more work.
14:04:13 <ertes> Matteo_: i don't think so, but it's really just two extra steps after straight line intersection: if the line in question is more vertical, see if the y coordinate lies between the line ends, otherwise check the x coordinate
14:05:12 <nut> geekosaur: so layout is a type constructor? layout takes a parameter and becomes a concrete type of (layout a)?
14:05:22 <geekosaur> layout is a type variable
14:05:39 <nut> geekosaur: what is (layout a)?
14:05:51 <geekosaur> (l a) is a type with kind *; l is a type with kind (* -> *)
14:08:58 <nut> geekosaur: so (l a) gets a type of kind *
14:08:58 <geekosaur> in xmonad, a will always be supplied as Window
14:08:58 <nut> so (l a) is type level function
14:08:58 <nut> ?
14:08:58 <Welkin> geekosaur: how would that above code work if you have MultiParamTypeClasses enabled?
14:08:58 <Welkin> would it require wrapping `layout a` in parentheses?
14:08:58 <nut> because l take a as a parameter and gets a type as a result
14:08:58 <geekosaur> nut, sort of. not a very smart type function though, only in the same sense that Functor f => f a is
14:08:58 <geekosaur> Welkin, probably. there's reasons it's done that way, that I couldn't tell you off the top of my head
14:09:22 <geekosaur> either related to layout being in the StackSet (which si why a is abstract, since StackSet is what got agdified for proof checking), or the annoying existential in XConf
14:10:03 <nut> geekosaur: so l is a type of kinds(*->*), that's the key! wow that takes some mind joggling
14:10:37 <Welkin> god damn it matrix!!
14:10:44 <Welkin> this is what I was talking about yesterday
14:10:56 <Welkin> please ban matric from #haskell
14:11:00 <Welkin> matrix*
14:11:01 <geekosaur> nut, mostly what makes it different from Functor is that we have to mebed the a, which is what I was just talking with Welkin about
14:12:16 <nut> Welkin: it is wrapped by parentheses
14:13:12 <nut> geekosaur: i understand now why you mentioned about Functor..
14:15:18 <geekosaur> the difference there is Functor is not supposed to know anything about the type it is used with, so it's left out of the class definition and it declares a class of kind * -> *
14:16:36 <geekosaur> LayoutClass needs to know about its parameter, so we have to include it --- and we need the parens for it to be valid. (iirc turning on multiparam type classes is not enough; it's not MPTC that is pthe problem, it's that you get kind errors)
14:18:14 <lyxia> Welkin: Why do you not hide join/parts?
14:18:43 <srid> Is "functional curse" the name for this condition?
14:18:45 <srid> > After years of playing with Haskell in my spare time [...] I have [..] developed a serious case of "functional curse" and can't imagine writing anything significant in a conventional language anymore (OCaml is the only other acceptable option I can think of, and even that would feel like settling)  https://www.reddit.com/r/haskell/comments/4vymzm/how_to_get_a_haskell_job/d62k6kc/
14:18:49 <lambdabot>  <hint>:1:13: error: parse error on input ‘of’
14:20:33 <dmwit> srid: I don't think if you merely said "functional curse" with no other context that I would think of that as its meaning.
14:20:38 <geekosaur> and it is not "l" or "l and a" that has the instance, it is the type identified by (l a) that has the instance, which is why this is not an MPTC
14:20:52 <dmwit> So if you want to do some clear writing, I suggest you follow that commenter's example and follow the term up immediately by its definition.
14:21:18 <Welkin> srid: no, more like experiencing a language with a rich type system and immutable-by-default workflow
14:21:33 <Welkin> I have no problem switching between haskell and low-level C
14:21:42 <Welkin> but any oop drives me nuts
14:22:50 <Welkin> also, my javascript looks more like scheme
14:22:58 <Welkin> I can't bring myself to write loops with mutation
14:23:23 <Welkin> haskell is like a black man
14:23:28 <Welkin> once you go black, you never go back
14:25:19 <Matteo_> is there a way to check if [[Maybe a]] contains any a or is all Nothing
14:25:43 <Welkin> use catMaybes
14:25:54 <dmwit> :t mapM sequence
14:25:56 <Welkin> it will filter out all of the Nothing values
14:25:57 <lambdabot> (Traversable t2, Traversable t1, Monad m) => t1 (t2 (m a)) -> m (t1 (t2 a))
14:26:07 <dmwit> Oh, no, that's all wrong.
14:26:14 <Welkin> if the result is an empty list, it was all Nothing
14:26:15 <dmwit> :t asum . map asum
14:26:17 <lambdabot> (Foldable t, Alternative f) => [t (f a)] -> f a
14:27:13 <dmwit> > asum . map asum $ [[Nothing, Nothing], [Nothing, Just 3], [Just 4, Nothing]]
14:27:15 <Welkin> > catMaybes <$> [[Just 2, Nothing, Nothing, Just 5]]
14:27:16 <lambdabot>  Just 3
14:27:19 <lambdabot>  [[2,5]]
14:27:24 <Welkin> oops... what
14:27:31 <dmwit> race condition =)
14:27:39 <Welkin> > catMaybes [Just 2, Nothing, Nothing, Just 5]
14:27:42 <lambdabot>  [2,5]
14:27:47 <Welkin> lol
14:28:04 <Welkin> how did I just Just 3 above?
14:28:11 <dmwit> You didn't. I did.
14:28:14 <Welkin> oh
14:28:15 <Welkin> hahaha
14:28:24 <Welkin> > catMaybes <$> [[Just 2, Nothing, Nothing, Just 5]]
14:28:28 <lambdabot>  [[2,5]]
14:28:33 <Welkin> okay, I still have my sanity
14:29:41 <dmwit> > concatMap (concatMap toList) [[Nothing, Nothing], [Nothing, Just 3], [Just 4, Nothing]]
14:29:45 <lambdabot>  error:
14:29:46 <lambdabot>      Ambiguous occurrence ‘toList’
14:29:46 <lambdabot>      It could refer to either ‘F.toList’,
14:29:59 <Matteo__> Welkin: so i have to use catmaybes $ map catmaybes
14:30:08 <Welkin> no
14:30:09 <dmwit> > concatMap (concatMap F.toList) [[Nothing, Nothing], [Nothing, Just 3], [Just 4, Nothing]]
14:30:12 <Welkin> :t catMaybes
14:30:13 <lambdabot>  [3,4]
14:30:14 <lambdabot> [Maybe a] -> [a]
14:30:20 <Welkin> it removesthe Maybe entirely
14:30:32 <Welkin> you just get the values that were wrapped in Just
14:30:43 <dmwit> Matteo__: No, you need catMaybes $ concatMap catMaybes. =)
14:31:01 <dmwit> oh
14:31:17 <dmwit> :t concatMap catMaybes
14:31:19 <lambdabot> Foldable t => t [Maybe b] -> [b]
14:31:24 <dmwit> Man, programming is hard.
14:31:57 <Welkin> if the end result is and empty list, then they were all Nothing
14:32:01 <Welkin> is an*
14:33:40 <Matteo__> so i have to do:     catMaybes $ concat [[Maybe a]]
14:34:21 <dmwit> That would work, assuming you put an actual term in place of that `[[Maybe a]]`.
14:34:31 <Matteo__> y ill try that
14:36:16 <parsnip> Welkin: weechat has a toggle so i can do Alt+- to see the joins temporarily. i only see the full /ignore for irssi.
14:36:41 <parsnip> same to filter nicks
14:39:37 <Matteo__> i get this error https://codeshare.io/50x19N when i try it
14:40:54 <Welkin> can you use lpaste instead?
14:40:54 <parsnip> Matteo__: import Data.Maybe (catMaybes)?
14:40:57 <Welkin> @lpaste
14:40:57 <lambdabot> Haskell pastebin: http://lpaste.net/
14:41:05 <Welkin> your link doesn't load for me
14:41:12 <Welkin> or it is just very slow
14:41:22 <Matteo__> oh wow iam retarded xd thx
14:41:27 <parsnip> it's like, for video collaboration
14:41:38 <dmwit> It's completely blank for me, too.
14:41:49 <ludat> is there a funcion like `(a -> Int -> b) -> [a] -> [b]` to map a list having the index on base?
14:42:19 <dmwit> :t \f -> zipWith f [0..]
14:42:21 <lambdabot> (Enum a, Num a) => (a -> b -> c) -> [b] -> [c]
14:42:44 <Welkin> good old zipWith [0..] is the way you get indexes for a list
14:43:35 <Welkin> Vector has a map with index function
14:43:44 <ertes> > (asum . asum) [[Nothing, Nothing], [Nothing, Just ()]]
14:43:49 <lambdabot>  Just ()
14:43:53 <ertes> > (asum . asum) [[Nothing, Nothing], [Nothing, Nothing]]
14:43:58 <lambdabot>  Nothing
14:46:15 <Matteo__> is there a way to do nothing in haskell because i have an if loop but with then I want do nothing
14:46:55 <lyxia> return ()
14:47:23 <ReinH> Matteo__: if you want to do nothing, why are you doing anything?
14:47:34 <Welkin> an if loop?
14:47:37 <Welkin> there are not loops
14:48:20 <Welkin> lyxia's suggestion only works if you are in `IO ()` pretty much
14:50:28 <ludat> thanks dmwit !
14:51:11 <parsnip> Matteo__: "if loop but with then I want to do nothing"?
14:51:55 <parsnip> Matteo__: can you rephrase? feel free to use pseudocode if it helps.
14:52:33 <parsnip> haskell, python, whatever.
14:53:02 * parsnip uses foldM and Maybe to "break loops".
14:53:35 <Welkin> you don't need to
14:53:45 <Welkin> a "loop" in haskell is often a self-recursive function
14:53:56 <Welkin> the base case if when it "breaks"
14:54:05 <Welkin> is when*
14:55:48 <parsnip> Welkin: i don't understand yet. i mean say you have an invalid value in your list that you're folding on, and to save time, you just want to "break" as soon as you hit such a value. foldM can help.
14:56:10 <parsnip> i'll pastebin two examples where i used this
14:56:20 <Welkin> foldM is a recursive function underneath
14:56:43 <Welkin> the recursion can be made more explicit, and is easier to write in more complex cases
14:56:56 <parsnip> yes, i agree with that
14:57:23 <gnesh> hello, does anyone know of a library that can parse nested query params? I'm looking for similar level of utility as https://github.com/ljharb/qs
14:57:30 <parsnip> Welkin: i don't know what you were saying "you don't need to" to.
14:57:55 <Welkin> gnesh: ganesha?
14:59:12 <Welkin> parsnip: there is no need to start with a higher-level abstraction, or involve monads at all
15:00:11 <parsnip> Welkin: recursion of folds, i don't care there. but i have the monad in there for a reason, so i'm not clear on why you disagree there.
15:00:18 <parsnip> *recursion or folds
15:00:50 <parsnip> i don't know what Matteo__ actually wants, so that can't be clarified at the moment.
15:01:16 <gnesh> Welkin: pardon? I'm just using a handle, my personal name is neither gnesh nor ganesha.
15:01:38 <ReinH> parsnip: if you have an invalid value in your list that you want to stop at, you can also use takeWhile
15:01:40 <hydraz> that is a lot of disconnects.
15:01:55 <Rembane> The whole Matrix disconnected for some reason
15:02:16 <ReinH> Matrix is a pox on irc.
15:02:27 <stphrolland> hi. By default stack is currently using lts-10.0 on my system. I wish to create a project using lts-9.14. I have not found how to do it. Do you know how to do it ?
15:02:30 <hpc> Rembane: the funny thing is, there's a Neo in this channel
15:02:52 <MarcelineVQ> stphrolland: https://docs.haskellstack.org/en/stable/GUIDE/
15:02:59 <parsnip> ReinH: ah, good point, thanks.
15:03:09 <ReinH> stphrolland: stack --help
15:03:27 <parsnip> here's my two silly uses of foldM to break early:
15:03:55 <parsnip> spoiler alert, it's nucleotideCounts and isIsogram exercises from exercism.io site: http://lpaste.net/361825
15:04:07 <Rembane> hpc: Follow the white rabbit?
15:04:11 <Welkin> stphrolland: you can just update your stack.yml file to use whatever version of stackage you want
15:04:15 <Welkin> then stack install
15:04:34 <Welkin> can someone please ban matrix
15:04:53 <Welkin> @ops
15:04:53 <lambdabot> Maybe you meant: pl oeis docs
15:04:58 <hydraz> what even is matrix
15:05:07 <Welkin> a stupid chat client
15:05:13 <MarcelineVQ> that's not a reasonable use of ops :X
15:05:21 <ReinH> hiding joins and parts makes this channel tolerable tbh
15:06:05 <gnesh> ReinH++
15:06:25 <parsnip> matrix is not a client?
15:06:38 <parsnip> matrix is some federated thing.
15:08:10 <stphrolland> seems like using --resolver lts-9.14 should do the trick, let's try
15:08:26 <parsnip> matrix has various bridges to access other chat protocols, like irc.
15:08:51 <MarcelineVQ> stphrolland: the more general option is to simply change the resolver version in your project's stack.yaml
15:12:06 <parsnip> ReinH: how does takeWhile communicate failure? i would think it's going to pass the truncated list as success.
15:12:26 <parsnip> oh, i guess that's what _i_ meant by break, i misspoke.
15:12:56 <parsnip> i just read, "do nothing", and was thinking "Nothing"
15:13:41 <ReinH> it doesn't "communicate failure". It gives prefix of the list that is not a failure.
15:14:38 <oo_miguel> Can I implement Show and Eq instances for functions?
15:14:49 <oo_miguel> to check if two functions are identical ?
15:14:54 <ReinH> Can you? Sure. Will they be useful? No.
15:15:25 <oo_miguel> I want to check if two functions are equal
15:15:30 <ReinH> You can't do that.
15:15:45 <oo_miguel> ok thank you
15:15:59 <parsnip> quickcheck?
15:15:59 <Welkin> you can check the output
15:16:26 <oo_miguel> Welkin: I would have to check the output for all possible inputs to see if they are indentical
15:16:32 <Welkin> oo_miguel: yes
15:16:33 <oo_miguel> identical
15:16:36 <ReinH> For specific functions. Not in general.
15:16:39 <Welkin> but that could satisfy your requirements
15:16:55 <Welkin> they may not need to be exactly identical in every possible case
15:18:19 <oo_miguel> allright, thanks
15:21:34 <parsnip> hmm, proving functor for trees, there's some strong induction going on there?
15:23:19 <parsnip> or maybe some abstraction of induction
15:24:38 <parsnip> oh no, i think i can expand `map` at the node's list.
15:25:19 <parsnip> no, that's just making it more explicit, still something like induction going on.
15:29:02 <ReinH> parsnip: Yes, structural induction, as with lists.
15:29:11 <newguy> Hi, I'm trying to learn how to code using catamorphisms and anamorphisms, but I'm not sure if I'm doing it right.
15:29:15 <ReinH> lists are degenerate trees
15:29:31 <parsnip> beat me to it, just found it :)
15:30:01 <newguy> I have a ~20 line toy example. Would someone be willing to look?
15:30:20 <parsnip> newguy: better to just ask the question in full.
15:30:50 <parsnip> it is the way of things on irc, in general.
15:31:30 <newguy> ok then
15:31:30 <newguy> http://lpaste.net/3943833266917736448
15:31:42 <newguy> I'm just trying as an example
15:32:29 <newguy> to write something wich converts strings separated by balanced parentheses
15:32:50 <newguy> into a C# style function type signature
15:33:33 <newguy> e.g. ("a","b")("c") -> "Func<Func<a,b>,c>"
15:34:10 <newguy> I have data PreSig a b = PValue a | PGroup [b]
15:34:31 <newguy> and type Sig a = Fix (Sig a)
15:35:01 <newguy> er
15:35:08 <newguy> Sig a = Fix (PreSig a)
15:35:51 <hpc> newguy: this doesn't directly help you out, but that type looks like (Free [])
15:40:27 <newguy> hpc I have not used Free before.
15:40:52 <newguy> is that like a functor freely generated from a data constructor?
15:40:59 <hpc> yep
15:41:18 <newguy> thats exactly what I have then, I think...
15:41:22 <hpc> iirc it's the free monad from a functor
15:41:25 <hpc> too lazy to hoogle it
15:41:35 <hpc> but yeah
15:42:52 <newguy> the issue though is that I don't see what algebra and coalgebra to write
15:44:39 <newguy> it seems like a coalgebra for sig requres me to generate a string out of no information
15:46:23 <ReinH> It's the monad freely generated from a functor
15:47:03 <ReinH> newguy: what is the type of the coalgebra for sig?
15:47:39 <newguy> b -> Sig b
15:48:44 <newguy> can I specialize b to something and still pass the coalgebra into ana?
15:48:50 <ReinH> Then why do you need to generate a string?
15:51:13 <newguy> the anamorphism should walk throught a string and insert the strings into PGroup lists
15:51:40 <ReinH> Where is the string in b -> Sig b?
15:51:54 <newguy> Sig b = Fix (PreSig String) b
15:52:21 <newguy> PreSig a b = PValue a | PGroup [b]
15:53:31 <newguy> http://lpaste.net/3943833266917736448
15:55:35 <ReinH> I know that you specialize it to String elsewhere.
15:56:22 <newguy> I think maybe I want b = PreStg (string c)
15:56:37 <newguy> *PreSig (String c)
16:10:06 <lyxia> newguy: ana mksig' :: String -> Sig String  just needs  mksig' :: Coalgebra (PreSig String) String
16:11:12 <Brian01> Hi guys!
16:11:35 <Brian01> How can I make the individual criterion benchmarks 100% independent?
16:12:01 <Brian01> I learned recently that criterion reuses some parts between benchmarks
16:12:24 <Brian01> and it was suggested to be that I should change that for accuracy
16:12:48 <Brian01> But this is not discussed in the criterion tutorial
16:14:13 <Matteo__> is there any way to cast and Int -> Float ?
16:15:04 <Brian01>  fromIntegral?
16:15:06 <ReinH> :t fromIntegral
16:15:09 <lambdabot> (Num b, Integral a) => a -> b
16:15:31 <Brian01> I guess all the criterion experts are sleeping already...
16:17:44 <Matteo__> I need to go from an Int to an Float but fromIntegral is not working
16:18:13 <lyxia> :t fromIntegral :: Int -> Float
16:18:15 <lambdabot> Int -> Float
16:18:21 <lyxia> Seems to work just fine
16:20:37 <parsnip> if you declare the type in more places in your code, it might help locate the issue better.
16:21:38 <Brian01> just write yourself a funtion  int2float :: Int -> Float
16:21:42 <newguy> thanks ReinH I figured it out
16:21:46 <Brian01> this helps in finding your problems
16:22:41 <oo_miguel> can i somehow have two data types in one file that share "field" nameS?
16:23:07 <Rembane> oo_miguel: Yes. DuplicateRecordFields is the language extension you want.
16:23:16 <ReinH> Matteo__: define "not working"
16:23:24 <oo_miguel> Rembane: ok nice, ill have a look
16:23:56 <Matteo__> yeah it was my bad i was giving it a [int] instead of [int] sorry
16:24:30 <ReinH> ...
16:25:33 <parsnip> O.O
16:42:13 <Matteo__> how do you end a thread ?
16:42:39 <hpc> Matteo__: from within the thread, or from another thread?
16:42:46 <Matteo__> another thread
16:42:54 <Matteo__> and i have no thread ID
16:43:14 <hpc> https://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Concurrent.html#v:killThread
16:43:18 <hpc> you need the id
16:43:26 <parsnip> oh, all this work to show `fmap (f . g) = fmap f . fmap g` for a tree, but we only ever need to show `fmap id = id` in haskell?
16:43:31 <Matteo__> fk me
16:44:01 <hpc> i don't know of a way to ask the runtime to give you all the threads currently running
16:44:12 <hpc> even then, you wouldn't be able to tell which thread was which
16:44:15 <parsnip> but now i'm just curious about finishing this proof.
16:44:49 <Matteo__> hpc: is it possible to open a thread with a specific threadId
16:44:54 <hpc> no
16:45:12 <iqubic> what's going on here?
16:45:16 <hpc> ThreadId is an abstract type
16:45:51 <hpc> in ghc it coincidentally has the implementation of ThreadId#, which is a pointer to the thread itself
16:45:58 <hpc> but that is documented as going away in the future
16:46:03 <ReinH> Instead of not having the thread id, try having the thread id.
16:46:30 <hpc> it's unusual that you need to kill a thread from the outside anyway
16:46:41 <WinterFox[m]> Why does virtually every Haskell program I have seen use GHC language extensions?
16:46:53 <hpc> if possible, i suggest writing your thread's logic so the computation ends when you need it to and the thread exits normally
16:47:01 <WinterFox[m]> If these are so important, why are they not in the haskell spec?
16:47:19 <hpc> WinterFox[m]: the core language is conservative for a bunch of reasons
16:47:28 <hpc> WinterFox[m]: partly it makes implementation of the standard language easier
16:47:52 <hpc> WinterFox[m]: and partly it's not always clear even for the most useful extensions if they will interact politely with things people want in the future
16:48:15 <hpc> so things don't get added until they have been thoroughly analyzed and deemed to pass that bar
16:48:17 <WinterFox[m]> Doesn't it also mean GHC is the only compiler that will work for most things?
16:48:48 <Matteo__> hpc: Iam running a game with gloss and i want to quit the game and i though a way of doing that was by closing the thread
16:49:03 <hpc> another compiler can implement the same extensions
16:49:15 <hpc> Matteo__: ah
16:50:35 <hpc> yeah, that's a good reason to use killThread
16:50:49 <iqubic> There's got to be a better way to do that thing though.
16:50:50 <hpc> although i assume you want to exit the whole program?
16:50:56 <hpc> @hoogle exit
16:50:57 <lambdabot> Graphics.UI.GLUT.Initialization exit :: MonadIO m => m ()
16:50:57 <lambdabot> Shelly exit :: Int -> Sh a
16:50:57 <lambdabot> Shelly.Lifted exit :: MonadSh m => Int -> m a
16:51:05 <hpc> @hoogle exitSuccess
16:51:05 <lambdabot> System.Exit exitSuccess :: IO a
16:51:05 <lambdabot> Foundation.IO.Terminal exitSuccess :: IO a
16:51:05 <lambdabot> System.Exit ExitSuccess :: ExitCode
16:51:37 <hpc> exiting the main thread exits all the other threads iirc
16:52:20 <Matteo__> yeah ill do that  thx
16:56:52 <jle`> WinterFox[m]: yes, that is what it means
17:21:19 <erisco> boo
17:31:06 <dmwit> v scary
18:37:04 <Guest8564> Hi Guys - I'm trying to make an IO () conform to a "Maybe a" type. Is there a good way to make this happen?
18:37:50 <Guest8564> Should the signature be "Maybe (IO () )" or "IO (Maybe () )"?
18:39:47 <pavonia> Probably the latter, but it depends on what exactly you want
18:44:13 <Guest8564> @pavonia: I think I just want to make sure that I can call "isJust" on it
18:44:13 <lambdabot> Unknown command, try @list
18:45:27 <pavonia> What are you trying to do?
18:48:32 <Xal> I have a list of headings and their depths, and I want to turn the flat list of headings into a tree
18:48:47 <Xal> so like [H 1, H 2, H 2, H 3, H 2, H 1] into [T [T [], T [T []], T []], T []]
18:48:57 <Xal> I can't quite figure out how to do my pattern matching for it
18:52:08 <lyxia> Xal: you can probably make good use of the "break" function
18:54:56 <Xal> lyxia: I see `break` but I'm not really sure how I would put it to use
18:56:01 <cupid83> git clone git://git.code.sf.net/p/bitchx/git bitchx-git
19:00:34 <sm> Xal: those are annoying.. I'll take a crack at it (spoiler warning)
19:00:48 <sm> toTrees (a:as) = [T $ toTrees subs] ++ toTrees sibs] where (subs, sibs) = span (<a) as
19:01:20 <sm> without the second ]
19:02:59 <Xal> goddamnit how am I so bad at this
19:05:04 <Xal> thanks sm, that did it
19:05:15 * sm pretends it was easy and looks modest
19:05:21 <Xal> now I'm going to throw away my three-level nested pattern matching monstrosity
19:16:30 <parsnip> it seems it might be common for people to struggle with, "Give an example of a type of kind * -> * which cannot be made an instance of Functor (without using undefined).", and i've been at it for a while, without and with sneaking at hints. i think i'm just going to try to understand other's solutions.
19:24:16 <iqubic> parsnip: Did you really think rudybot would be able to help you?
19:31:20 <parsnip> naw, even reading the solutions, i still don't quite get it.
19:31:48 <ski> > helper [] 0 [1, 2, 2, 3, 2, 1]
19:31:52 <lambdabot>  [T [T [],T [T []],T []],T []]
19:31:59 <ski> Xal ^
19:32:57 <jle`> parsnip: how about something like `data Endo a = Endo (a -> a)`
19:34:09 <jle`> parsnip: or a class, data Pred a = Pred (a -> Bool)
19:34:18 <jle`> *a classic
19:34:25 <jle`> which represents a predicate on a :)
19:34:39 <parsnip> i was reading the one like that, my own attempts to prove weren't connecting, i saw one person go in a direction i considered, where they said you couldn't construct the desired function, but it felt pretty hand-wavy, and i couldn't see how to fill it in.
19:34:47 * ski looks at sm
19:34:47 <amalloy> parsnip: any values of type a that you have in scope can be made an instance of Functor. the idea is to find a type which "needs" an a instead of "has" an a
19:34:58 <amalloy> jle` gives one example
19:35:47 <parsnip> right so say you have `fmap :: (a -> b) -> Pred a -> Pred b`
19:35:49 <ski> another example is `IORef'
19:36:17 <parsnip> so that's like, you have `a -> b` and `a -> Bool`, and someone requests the `b -> Bool`.
19:36:24 <jle`> parsnip: i don't think, for a beginner, there is a logical step-by-step direction you can take to arrive at an answer.  for someone experienced there is probably a method, but i don't think the exercise expects you to be able to logically arrive at one
19:36:33 <ski> ("needs" : `writeIORef :: IORef a -> a -> IO ()')
19:36:48 <jle`> parsnip: this is more like, there are a bunch of possible algebraic data types you can do, some of them are functors and some of them aren't
19:37:07 <parsnip> i'm squinting at it thinking, well, to make the `b -> Bool`, i'll just run over a lot of `a` values to get `b` and `Bool` values.
19:37:09 <ski> (well, even a read-only version would be an example)
19:37:09 <jle`> it's just that all of the ADT's you've seen before all happen to be functors
19:37:18 <jle`> parsnip: try writing the instance
19:37:38 <parsnip> no, intuitively, that looks like crap, but i sort of blanked on how to show it's not possible.
19:37:45 <parsnip> *now
19:38:54 <parsnip> i think i'm not fluent with the implicit logic, like where in all this, do the "for any"s and the "for some"s go.
19:39:13 <parsnip> types are still quite abstract for me
19:39:53 <jle`> it's more like a mechanical thing really
19:39:57 <jle`> if you try to write the instance
19:40:00 <parsnip> i want to say something like, "well our family of `a -> b` don't cover all the `b`, contradiction"
19:40:11 <jle`> there will be a clear situation where you will be stuck
19:40:23 <jle`> like a moment when you realize you're trying to fit a square peg into a circular hole
19:40:26 <parsnip> i did try. i did get stuck. that is not a proof to me.
19:40:27 <ski> (i wonder whether it could be proved via parametricity ..)
19:41:11 <parsnip> getting stuck means, "aha, it's either impossible, or i overlooked something!"
19:41:41 <jle`> parsnip: if you want to turn an (a -> Bool) into a (b -> Bool), that works for all 'a's and all 'b's, the only thing you can really do with an (a -> Bool) is pre-compose it, or post-compose it
19:41:59 <jle`> compose a function before the (a -> Bool), or compose one after it
19:42:19 <parsnip> you see, that is the part that is abstract for me.
19:42:31 <parsnip> "the only thing you can do"
19:43:45 <jle`> i suppose you can think of it as the part of the API of the (->) type, that lets you return a new (->)-based type
19:43:55 <jle`> just like how Int's have +, -, *, etc.
19:43:58 <jle`> (->)'s have composition
19:44:06 <amalloy> jle`: and application
19:44:24 <parsnip> see above for my vague instructions for construction, that need less vague proof to show not possible.
19:44:48 <parsnip> 19:36 <parsnip> i'm squinting at it thinking, well, to make the `b -> Bool`, i'll just run over a lot of `a` values to get `b` and `Bool` values.
19:45:12 <jle`> what 'a' values are you talking about running over?
19:45:15 <amalloy> parsnip: the trick is, you dont' *have* any a values
19:45:25 <iqubic> Are we talking about contravarient functors here?
19:45:29 <amalloy> no
19:45:50 <parsnip> it's a realted topic.
19:46:17 <parsnip> we're taking a contravariant functor trying to show it can't be a covariant functor.
19:46:29 <parsnip> iiuc
19:46:31 <iqubic> It just that whenever I see a variable in a negative position I think of contravariance.
19:46:45 <iqubic> Oh, yeah. I got you.
19:46:54 <iqubic> :k Predicate
19:46:56 <lambdabot> error:
19:46:56 <lambdabot>     Not in scope: type constructor or class ‘Predicate’
19:47:07 <iqubic> Does that not work like that?
19:47:23 <jle`> @let newtype Pred a = Pred { runPred :: a -> Bool }
19:47:27 <lambdabot>  Defined.
19:48:07 <iqubic> :k Pred
19:48:09 <lambdabot> * -> *
19:48:36 <iqubic> Alright. Cool. I get how that satisfies Parsnip's request.
19:48:42 <ski> (well, `Const c' is contravariant ..)
19:51:13 <parsnip> how do i know i'm not allowed to use all values in a to construct this b -> Z?
19:52:01 <parsnip> i feel like straightforward and clear proofs with all the dots connected are to be desired.
19:53:31 <jle`> parsnip: from a parametrically polymorphic perspective, there is no way to conjure values of 'a'
19:54:05 <jle`> so there is no way to access *any* values in 'a'
19:54:34 <parsnip> ugh, what an ugly proof :(
19:54:39 <jle`> and certaintly not 'all' of them :)
19:54:52 <jle`> parsnip: it comes from the common sentiment that there are no values of type 'forall a. a'
19:55:06 <parsnip> yeah, i'm missing something in the fundamentals
19:55:07 <jle`> this is one of the fundamental things about parametric polymorphism
19:55:18 <jle`> as soon as you need a value of type `forall a. a`, you know you're sunk
19:55:49 <parsnip> erf, feels subtle
19:57:01 <jle`> this comes from the "types encode logical statements" thing, from the curry howard isomorphism
19:57:12 <jle`> if you're familiar with that, it might help to look at it from that perspective :)
19:58:15 <pikajude> there's no value that has any type
19:58:17 <jle`> from the curry howard iso, a type represents a logical proposition/statement, and if that type can be inhabited, it means that that preposition is true
19:58:56 <jle`> the type 'forall a. a' means that any proposition is true, no matter what
19:59:10 <jle`> or well, the existence of a value of that type means that any proposition is true, no matter what
20:01:31 <parsnip> i'm worried we're just using big words.
20:01:34 <parsnip> but...
20:01:46 <parsnip> okay, how about this "for all" thing.
20:02:03 <parsnip> can't we just come up with a single convenient item where everything fails?
20:02:18 <parsnip> instead of telling me i can't make any assumptions about selecting things?
20:02:37 <jle`> yes, Pred (const False) and Pred (const True) are all valid values that typecheck
20:03:23 <jle`> so this example is maybe a bit more subtle because you 'fmap' implementations that typecheck, but don't obey the laws
20:03:44 <jle`> just like for Maybe, [], IO, etc.
20:04:17 <parsnip> fails `fmap id = id`, or `fmap (f . g) = fmap f . fmap g`?
20:04:30 <jle`> in fact, the types that *don't* have invalid-but-typechecking fmaps is kind of rare actually
20:04:39 <jle`> parsnip: nice hitn for this is that you can usually prove 'fmap id = id' only
20:04:48 <parsnip> yeah
20:04:59 <parsnip> but... i thought that typically proves the latter.
20:05:02 <jle`> fmap id = id is much easier to prove too
20:05:03 <parsnip> *implies
20:05:20 <jle`> yeah, it does, so if you prove that and only that, then you know you have a valid instance :)
20:05:50 <jle`> but yeah, 'fmap id = id' is one you can instantly see is broken
20:06:05 <jle`> if we had fmap f (Pred p) = Pred (const True)
20:06:23 <jle`> we want fmap id (Pred p) = Pred p, but (const True) is definitely different than p
20:11:25 <parsnip> hmm, did you somehow look at `a -> Bool` and decide only possible values are `const True` and `const False`?
20:17:56 <kadoban> parsnip: I'm not sure that that's what they did, but the reasoning before allows to you see something close to that at least.
20:18:53 <parsnip> if Bool is "tight", can i tighten `a` and `b`? make `a` as `Unit` perhaps?
20:19:33 <parsnip> i saw a solution on the internet that used Void and Unit, but i didn't actually understand it.
20:19:55 <kadoban> I'm not sure what that means
20:22:14 <parsnip> for `fmap :: (a -> b) -> (a -> m) -> (b -> m)`, we have above m as Bool, but other places on the internet use Int there. Bool seems like a tighter fit to prove this. maybe we can prove with tighter `a` and `b` as well.
20:22:38 <parsnip> *Bool tighter fit than Int
20:23:26 <parsnip> i guess a and b have to be fully parametric? but even proving not possible doesn't allow to tighten?
20:23:47 <ReinH> that is... not the type of fmap
20:23:59 <parsnip> er, f a, f b
20:24:16 <iqubic> that's still not the type of fmap
20:24:30 <parsnip> ugh
20:24:46 <iqubic> :t fmap
20:24:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:24:50 <parsnip> it's sort of the type we've been discussing
20:24:59 <ReinH> whatever it is, it isn't fmap
20:25:10 <parsnip> whatever
20:25:36 <ReinH> Yeah, let's not worry about trivialities like whether we can understand you or not
20:27:04 <parsnip> hmm, k, i give up
20:29:17 <ReinH> (a -> b) -> (a -> m) -> (b -> m) is not the type of fmap for any instance of Functor
20:29:23 <ReinH> @djinn (a -> b) -> (a -> m) -> (b -> m)
20:29:24 <lambdabot> -- f cannot be realized.
20:29:33 <kadoban> ReinH: Just FYI this in not the start of the conversation
20:32:16 <ReinH> The ^ is evidence that Pred doesn't have a functor instance.
20:41:47 <jle`> parsnip: i didn't say that (a -> Bool) had only (const True) and (const False), necessarily
20:41:58 <jle`> parsnip: just that const True and const False are two values you can make that typecheck
20:42:17 <parsnip> yeah, i'm not getting the logical flow really, oh well.
20:42:48 <parsnip> maybe after time i'll be more comfortable with types, parametricity, etc.
20:42:48 <jle`> parsnip: i think it was in response to 'why can't we just have `fmap f _ = Pred (const False)`?'
20:42:59 <jle`> and i was saying ' you can, but it won't be lawful'
20:43:20 <ReinH> jle`: what other values does a -> Bool have (other than bottom)?
20:43:27 <jle`> parsnip: and yes, there are definitly functions (Int -> Double) -> (Int -> Bool) -> (Double -> Bool)
20:43:54 <jle`> but your job is to make (a -> b) -> (a -> Bool) -> (b -> Bool), which works for *any* a, and *any* b, parametrically polymorphically
20:44:09 <jle`> and that's a different story
20:44:39 <jle`> ReinH: there aren't, but i was just saying that the reason why i brought up 'const False' and 'const True' is to show a different point
20:44:49 <ReinH> Ok
20:44:51 <suzu> ^ that function. you can't make it, can you?
20:44:57 <jle`> you can not, yes
20:45:11 <parsnip> sure, i was just wondering if one way to make sense of it for mortals was just to show how on limited spaces there still is no reasonable thing like fmap.
20:45:13 <ReinH> (except for bottom)
20:45:19 <suzu> is there some mechanical method to know that it can't be made?
20:45:26 <suzu> i know it can't be made by.. thinking about it
20:45:30 <jle`> suzu: that's exactly the question that parsnip is asking actually :)
20:45:34 <suzu> oh! okay :)
20:45:36 <ReinH> parsnip: no, because the whole point of parametric polymorphism is that the space is *not* limited
20:45:38 <jle`> we're trying to find a nice way to talk about it
20:45:49 <suzu> yeah i'd be interested in knowing the answer
20:45:57 <parsnip> ReinH: i won't ask you to discuss anything for the sake of intuition.
20:46:15 <parsnip> ReinH: i tried to add , "like fmap"
20:46:30 <parsnip> but clearly you love to kill conversations at imprecision
20:46:31 <jle`> parsnip: there are definitely functions you could write if you only need to handle specific a's and specific b's
20:46:55 <jle`> in fact, you could probably do something if you restrict what they can be with certain typeclass instances, as well
20:46:56 <parsnip> jle`: i mean, limiting a and b, and still managing to convey that no such fmap exists.
20:47:08 <jle`> if you limit 'a' and 'b', then such a fucntion can exist
20:47:12 <jle`> depending on how you limit
20:47:21 <parsnip> i mean...
20:47:28 <parsnip> to _aid_ in showing no fmap
20:47:37 <parsnip> "inconveniently" if you wil
20:47:45 <parsnip> f***
20:47:56 <ReinH> parsnip: If we're talking about something where precision is important, I think it's important to be precise.
20:48:07 <ReinH> And math is one such thing.
20:48:07 <parsnip> nice sentence
20:48:17 <parsnip> this ain't math
20:48:22 <ReinH> Yes it is.
20:48:34 <jle`> hm, i'm not sure how helpful that line would be, since the important thing is that we want to show the case where we are polymorphic over 'a' and 'b'
20:48:38 <jle`> parsnip: actually this is exactly math :o
20:48:46 <ReinH> This is type theory and type theory is math
20:49:09 <parsnip> i didn't see any type theory classes where i was
20:49:16 <ReinH> Ok
20:49:30 <jle`> parsnip: a simpler analogy to limiting/not limiting would be how there are no values of type `forall a. a`
20:49:36 <jle`> but there are definitely values of type `Bool`
20:49:41 <jle`> and values of type `forall a. Num a => a`
20:49:53 <jle`> and `forall a. Monoid a => a`, etc.
20:49:55 <ReinH> You can't reason by "limiting" a to some concrete type because that is exactly what polymorphism says you *can't* do.
20:50:17 <parsnip> i mean, that if it's impossible for "for all", and then you take a smaller space, and it's not possible for all of those, then it's certainly not possible for the original larger space.
20:50:46 <jle`> the problem is that it *is* possible for smaller spaces
20:50:56 <parsnip> _all_ smaller spaces?
20:50:58 <jle`> so that's kind of the opposite result :)
20:51:27 <ReinH> You can't reason about polymorphism by considering cases of concrete types
20:51:33 <parsnip> f***
20:51:40 <parsnip> can i get a direct response?
20:51:43 <jle`> parsnip: it's not impossible for all smaller spaces
20:51:50 <jle`> it's possible for some smaller spaces and not others
20:51:56 <jle`> so it's not really a strong line of reasoning
20:52:00 <parsnip> so, pick the "others
20:52:04 <parsnip> f***
20:52:09 <parsnip> sigh
20:52:35 <jle`> the ones where it's not possible, you run into the same issues for the unrestricted space
20:52:46 <jle`> the reason why it's not possible in those is because it's 'not restricted enough'
20:53:17 <parsnip> so if i pick () for a, you're saying that now fmap is possible?
20:53:24 <jle`> i'm saying that that function is possible, yes
20:53:34 <jle`> well, if you pick 'b' too
20:53:35 <parsnip> oh. Bool too?
20:53:47 <ReinH> Pick () for a for which type?
20:53:59 <parsnip> ReinH: i'll never make sense to you
20:54:00 <jle`> for `(a -> b) -> (a -> Bool) -> (b -> Bool)`
20:54:12 <jle`> such that foo id = id
20:54:31 <jle`> `foo :: (a -> b) -> (a -> Bool) -> (b -> Bool)`, s.t. foo id = id
20:54:45 <jle`> suzu: oh yeah sorry suzu, this was an important point that i didn't mention earlier
20:54:57 <jle`> suzu: it is trivially possible to write a (a -> b) -> (a -> Bool) -> (b -> Bool)
20:55:07 <jle`> it's just one where foo id = id that is tricky
20:56:07 <parsnip> anyways, i'm see the best this can possibly head, is i build some intuition for a particular case, but logic that doesn't connect with the general thought process for parametricity.
20:56:39 <parsnip> so... i think i have to temporarily resign myself to aspects of this are not clicking for me yet.
20:56:44 <jle`> i think for me, reasoning about this through parametricity wasn't the most natural thing when i started out.  but like you, i also saw that it was impossible after trying to implement it
20:56:54 <jle`> but after long time, the intuition starts building up naturally
20:57:08 <jle`> after seeing several of these situations in multiple contexts
20:57:21 <ReinH> parametricity forces you to reason about things you can do *universally* about *every* type. That's why it's 'for all a'. If you say "well, I'll take a to be ()" then you are no longer reasoning universally.
20:57:47 <ReinH> As soon as you start to reason about concrete types, you are no longer reasoning universally about all types.
20:57:58 <parsnip> yeah, maybe as i use types more as well, trying to reason with types, and type constructors, etc, is still difficult for me.
20:58:27 <ReinH> You've learned something about when a is (), but you haven't learned anything about "for all a".
20:59:18 <parsnip> right, i started to put that together, i agree.
20:59:53 <Lokathor> so, withAsync says that it cancels the async action if the inner IO action completes before the async does
21:00:05 <Lokathor> does that mean that the action as a whole will wait on the cancel effect to go though?
21:00:15 <jle`> it might actually help to think about `forall a. (a -> b) -> (a -> c) -> (b -> c)`, where the cop-out answer `const True` is not available to you
21:00:27 <jle`> parsnip: imagine the API of the (->) type
21:00:34 <jle`> parsnip: let's say you only have (.)
21:00:46 <parsnip> sure, if that were the case.
21:00:49 <jle`> parsnip: if you had to write foo f g = ????
21:01:00 <jle`> you can either write (f . g), or (g . f), maybe?
21:01:03 <parsnip> right, then i only have a few obvious things to try.
21:01:13 <jle`> but neither of those typecheck
21:01:35 <ReinH> The API of (->) is probably ($), not (.) ;)
21:01:36 <jle`> so like, of those two combinations, both are eliminated
21:01:43 <jle`> so you can rule it out by exhaustion :)
21:02:55 <ReinH> :t ($)
21:02:57 <lambdabot> (a -> b) -> a -> b
21:03:16 <ReinH> This says "you can choose any a you want and give me an a and function a -> b and I will give you a b".
21:03:26 <ReinH> It doesn't say *I* can choose any a I want.
21:04:18 <parsnip> any b too?
21:04:22 <ReinH> Yes.
21:04:39 <parsnip> right, i think i'm comfortable with general notion of "for any".
21:04:52 <parsnip> but then when considering,
21:05:18 <parsnip> (a -> b) -> (a -> Bool) -> (b -> Bool)
21:05:51 <parsnip> i imagined things like, oh, well, just iterate over all values of a.
21:06:05 <parsnip> to construct a map b -> Bool.
21:06:07 <ReinH> How can you do that if you don't know what type a is?
21:06:14 <jle`> yeah, you just can't iterate over all values of 'a', for any a
21:06:31 <lijero> just looking at that type sig, the only implementation is "ignore all inputs and return a bool", since you don't have an a or a b
21:06:32 <parsnip>  was just thinking something like that could be the instructions.
21:06:34 <jle`> if you had a specific 'a', you can iterate over all values of it, like a ~ Bool, etc.
21:06:47 <parsnip> i hoped there would be some very clear and idiot-proof proof
21:06:51 <ReinH> I, the writer of that function, don't get to choose a. The caller gets to choose a.
21:07:04 <ReinH> So I don't know what values to iterate over, because I don't know what a is when I write the function.
21:07:05 <mnoonan_> the “for any” isn’t for you, the implementor of a function. it is for the caller to pick, and they might have some really twisted little values they want to hand you
21:07:16 <parsnip> like, "oh, well you can't do that, that won't work either, look you're stuck", wasn't a very satisfying proof.
21:07:16 <MarcelineVQ> mnoonan_: the fiends
21:07:40 <parsnip> mnoonan_: yes, i'm familiary with for all. i've tutored it.
21:07:42 <lijero> there is a version of "for any" for the implementer though, "existential types"
21:08:06 <parsnip> "now i'm going to give you an epsilon, you have to cook up a delta"
21:08:16 <ReinH> what?
21:08:32 <mnoonan_> parsnip: right, exactly. so now couple that with an open-world assumption about what values and types can look like.
21:08:46 <parsnip> let epsilon be zero.
21:09:17 <parsnip> my TA said this was great at parties
21:09:22 <ReinH> I don't follow.
21:09:49 <jle`> if you understand the epsilon/delta formulation of proofs, then you have to have a decent understanding of universal quantification
21:10:00 <parsnip> yes!
21:10:00 <jle`> which is also what's going on here
21:10:11 <parsnip> but something is tripping me up
21:10:20 <jle`> but the difference is the 'parametric polymorphism', i think
21:10:25 <parsnip> for me, quantifiers were about values i think
21:10:48 <mnoonan_> oh, that’s a good point.
21:10:58 <jle`> parametric polymorphism makes this case a little different
21:11:01 <ReinH> What do you mean by "quantifiers were about values"?
21:11:13 <mnoonan_> you could read “foo :: Int -> Int” as saying “for all x of type Integer, foo x will also have type Integer”
21:11:36 <mnoonan_> but the quantification we’re talking about here is quantification over types rather than values
21:11:53 <jle`> mnoonan_: i was thinking more in the lines of, `foo :: a -> Int` as saying, 'for all choices of a, you can get a function (a -> Int)'
21:12:11 <mnoonan_> so “foo :: a -> a” is “for all *types* T, and for all values x of type T, foo x is also of type T)
21:12:28 <jle`> well, the way we're talking about universal quantification here is
21:12:34 <parsnip> ReinH: well, scalars?
21:12:35 <jle`> `foo :: forall a. a -> a`
21:12:47 <jle`> meaning, for any pick of type 'a', foo will have type a -> a
21:12:58 <jle`> so if you pick Int for 'a', foo will give you type Int -> Int
21:13:00 <parsnip> ReinH: for any epsilon > 0, there is some delta > 0 such that ...
21:13:07 <jle`> if you pick String for 'a', foo will give you type String -> String, etc.
21:13:12 <jle`> it has nothing to do with the values
21:13:13 <ReinH> parsnip: Right, so "for every epsilon > 0" means we, the proof writer, have no control over epsilon.
21:13:20 <parsnip> i get that part
21:13:37 <ReinH> forall a. (a -> Bool) means we, the implementor, have no control over *the type of* a.
21:13:44 <parsnip> i'm comfortable with that, especially in senior level math classes.
21:13:44 <ReinH> Not *the values of* a, because we don't even know what type a is.
21:14:05 <ReinH> If we have no control over the type of a, we can't choose some specific type and then reason about that.
21:14:07 <parsnip> right, here it starts to get subtle and abstract for me, in a different sense.
21:14:40 <parsnip> right, but like, i don't know, i could still, without knowing what a is, imagine i can shove instructions into the computer.
21:15:05 <parsnip> i've never reasoned about types!
21:15:09 <jle`> right, that's the API approach i was talking about earlier
21:15:09 <ReinH> Ok, but why would you expect them to type check?
21:15:21 <parsnip> huh?
21:15:23 <jle`> you only have a limited amount of functions/ways to interact with your types
21:15:36 <parsnip> jle`: how do i _know_ that?
21:15:40 <jle`> and "enumerating over all a's" is not an available part the API
21:15:51 <jle`> parsnip: that you only have a limited API?
21:15:53 <parsnip> how do i know api is ($), seems we're back at same place.
21:15:58 <jle`> that's sort of like...the principle of data structures
21:16:10 <jle`> it's a part of the definition
21:16:15 <ReinH> jle`: I almost want to talk about pi and sigma types for quantification because they bridge the reasoning about values <-> reasoning about types gap but that would just make it worse.
21:16:16 <jle`> the definition of a type will give you the API of that type
21:16:29 <jle`> when you define a type, you also give what functions will work on that type
21:16:38 <jle`> and, you just don't have an "enumerate over all a's" function
21:17:06 <parsnip> okay, so limited api for (->) is a rock solid thing?
21:17:15 <jle`> yes, it's a part of the definition of (->)
21:17:19 <jle`> you can't just make up operations on it :)
21:17:24 <ReinH> The most basic thing here is that forall a. a is uninhabited (except for bottom).
21:17:47 <ReinH> If I say "give me a value that is an inhabitant of type a, but I won't tell you what a is" you can't do it
21:17:57 <ReinH> unless you have an inhabitant of all types, which is what bottom is
21:18:38 <parsnip> that just rules out one of my ideas for a ridiculous instruction, but i don't know if other tricks lie in your type theory.
21:18:44 <ski> @let bottom = bottom
21:18:47 <lambdabot>  Defined.
21:18:55 <ReinH> I suppose we could give the production rules for the type theory
21:19:31 <jle`> parsnip: you could sysmteically enumarete all of the ways to apply the API
21:19:37 <jle`> and rule all of them out
21:19:41 <jle`> process of elimination :)
21:20:18 <parsnip> searching 2010 report
22:05:31 <dmwit> parsnip: I think you didn't get a clear answer even though there is one. That's because nobody has told you, but there is a complete set of typing rules that enumerates all ways of constructing values of any possible type.
22:05:42 <dmwit> They're complicated enough that I don't think it makes sense to try to write them down over IRC.
22:05:59 <dmwit> But there are excellent books on type theory -- I recommend Benjamin Pierce's Types and Programming Languages.
22:06:22 <tommd> "TaPL" in conversation
22:07:09 <dmwit> A common lemma in these theories is the "canonical forms" lemma which is very related to what you're asking about.
22:07:32 <Lokathor> http://lpaste.net/361839 a giant tower of bits and bytes, and it always comes back to a stupid input loop
22:07:49 <dmwit> And the proof is basically just "look at all the conclusions of the typing rules. see? that's all the ways to make a thing of that type".
22:08:59 <dmwit> Anyway for free type variables the only rule that lets you produce a value of that type are the variable rule (I have some variable in my context of the right type) and the application rule (I have some function that returns a thing of that type and a suitable argument for that function).
22:10:18 <dmwit> So, looking at `(a -> b) -> (a -> Bool) -> (b -> Bool)`, since the `a` is not the return type of any function we have and is not the type of any of the variables we have (whose types are `a -> b`, `a -> Bool`, and `b`), we can't make an `a`.
22:10:59 <dmwit> (Actually I'm fudging it a little bit because fancy calculi like Haskell have a recursion rule that can be pretty much any damn type. But infinite loops are usually uninteresting in these conversations, so...)
22:19:57 <sim590> I have a function with the signature myf :: Eq a => Int -> [a] -> Bool. When I call myf 3 [1,2,3], I get "Variable not in scope: myf :: Integer -> [Integer] -> t". It seems, like literal list of ints is considered [Integer] and not [Int]. How do I pass [Integer]???
22:20:20 <sim590> I mean how do I pass [Int].
22:20:48 <pavonia> It would report another error then. Where have you defined that function?
22:21:01 <dane_> hello!
22:21:04 <dane_> i have question
22:21:18 <dane_> i am trying to make XOR gate in haskell
22:21:35 <dane_> i have the code but it is not working. im not sure why either.
22:21:48 <dane_> nor :: Bool -> Bool -> Bool
22:21:50 <dane_> nor e1 e2 = not(e1 || e2)
22:21:53 <jle`> sim590: it looks like you might not be defining 'myf' anywhere that haskell knows about
22:22:03 <jle`> dane_: what do you mean by "not working" ?
22:22:08 <jle`> is it giving the wrong results?
22:22:20 <dane_> that is my code above . it is not giving the right output
22:22:40 <dmwit> Yes. That is because nor and xor are not the same function.
22:23:05 <jle`> dane_: it seems to give the right output for 'nor'/'not or'
22:23:09 <sim590> jle`: my whole code is http://paste.debian.net/1006220/. I do :l my file. It's in the scope, but when calling with arugments `3 [1,2,3,1,2]`, the type is mismatched.
22:23:17 <jle`> dane_: are you expecing 'nor' to be 'xor'?
22:23:22 <dane_> thats what i meant lol
22:23:24 <dane_> NOR gate
22:23:31 <jle`> dane_: or are you using it as a subfunction to help write xor
22:23:33 <jle`> ah
22:23:38 <olligobber> sim590, try declaring it as [1,2,3] :: [Int]
22:23:48 <dmwit> dane_: What is an example of an input/output pair that is not what you expected?
22:24:20 <amalloy> sim590: make sure to spell the function name right
22:24:25 <jle`> sim590: in that code, 'myf' is not defined
22:24:27 <jle`> so that might be your problem
22:24:54 <dmwit> sim590: Could not reproduce. When I `:l test.hs` and `estPeriode 3 [1,2,3,1,2]`, I get `True`.
22:25:02 <sim590> jle`: ... The function is `estPeriode`.
22:25:06 <dmwit> sim590: Perhaps check your capitalization. That's a common bug.
22:25:07 <jle`> try calling estPeriode 3 [1,2,3,1,2] instead of myf 3 [1,2,3,1,2]
22:25:21 <jle`> sim590: yes, but earlier, you said you got an error 'Variable not in scope: myf :: ..."
22:25:27 <jle`> sim590: when you were calling 'myf 3 [1,2,3]'
22:25:50 <sim590> jle`: I was just abstracting the problem so you don,t wonder about the words I use to describe my function since it is not relevant.
22:26:07 <dmwit> sim590: Copy and paste your ghci session.
22:26:15 <dmwit> Show us exactly what you did, and what happened.
22:26:19 <jle`> sim590: just trying to help find your error :)
22:26:25 <dmwit> It is better than trying to summarize and perhaps getting some of the details wrong.
22:26:26 <jle`> sim590: this happens often
22:26:50 <jle`> sim590: so are you actually calling 'estPeriod 3 [1,2,3]' then?
22:27:33 <jle`> sim590: the words used to describe your function are actually pretty relevant here, since we're talking about debugging an error when calling it
22:27:34 <amalloy> jle`: i can't tell if you've misspelt the function name on purpose or accidentally
22:27:46 <jle`> sorry, that was an accident :)
22:27:53 <amalloy> on purpose would be a good one too
22:27:56 <dmwit> IRC needs a way to edit your message.
22:29:37 <sim590> olligobber, amalloy, jle`, dmwit: I was misled by my tab completion execution. It seems, it is indeed a spelling error. Sorry for bothering.
22:30:29 <olligobber> lol
22:30:50 <jle`> sim590: no worries! this happens a lot
22:31:15 <jle`> which is why it helps to send exactly what is causing an error, like what dmwit said :)
22:33:17 <sim590> jle`: I'll do that next time. But sometimes, people ask for minimal replicating example and it sometimes helps to abstract the problem by removing semantics from some words or even translating to the language of the people helping.
22:34:30 <amalloy> sim590: yes, it's a good thing to do. but you have to be careful when doing that that you leave the bug in. make it minimal, then test that it still happens
22:34:52 <sim590> Indeed.
22:37:40 <dmwit> Thanks for trying to be helpful though! We appreciate that attitude around here. =)
22:37:43 <dmwit> sim590++
22:41:04 <sim590> :D
23:25:25 <centril> Is anyone here familiar with hedgehog who can explain what the 'shrink' function does more elaborately than the documentation?
23:26:29 <jle`> i'm not familiar with hedgehog, but if it's like other property testing libraries, shrink is used when a failing input is found.  shrink is used to 'simplify' input, so try to find simpler inputs that might also fail
23:26:48 <jle`> so if it finds a complicated item that fails the test, it'll use shrink to see if it can find a simpler version that also fails
23:27:10 <centril> jle`: Right; I understand how PBT works =) I'm only interested in how hedgehog does it specifically
23:27:13 <centril> but thanks =)
23:27:38 <jle`> are you asking about how it's implemented?
23:28:14 <centril> jle`: well... kinda, I checked the github sourced but it was spread all across the place
23:32:01 <miller> I've run into the same issue as described in https://stackoverflow.com/questions/38326381/wreq-simple-post-request , so I now have working code, but with many explicit `::ByteString`s .  Does anyone happen to see how to drop all the explicit casts?
23:32:17 <centril> shrink = shrinkGen ; shrinkGen = mapGenT . Tree.expand ; mapGenT f gen = GenT $ \size seed -> f $ runGenT size seed gen ;  expand f m = Tree $ do Node x xs <- runTree m ; pure . Node x $ fmap (expand f) xs ++ unfoldForest f x
23:36:49 <centril> So the real logic is in Tree.expand defined here: https://hackage.haskell.org/package/hedgehog-0.5.1/docs/src/Hedgehog-Internal-Tree.html#expand
23:38:28 <cocreature> miller: you could define a wrapper for ":=" that doesn’t have a polymorphic type. note that "x :: ByteString" is not a cast! it doesn’t do any conversions, it just specifies that x should be of type "ByteString". if that’s not a valid type for "x" then it will just error
23:41:56 <cocreature> miller: you could also enable the ExtendedDefaultRules extension which is enabled by default in ghci (which is why it works there) but I wouldn’t recommend this
23:48:03 <dmj`> miller: odds are your explicit casts will be dropped anyways, since user and password are set dynamically, the types of the values will be known to ghc, and the instances of FormValue won’t have to be explicitly specified.
23:49:13 <miller> Ah, so that's why people aren't just hitting this constantly...
23:50:04 <vjousse> Hi there
23:52:16 <dmj`> vjousse: Hi
23:52:28 <vjousse> I'm trying to catch some HTTP exceptions here but without any success: https://github.com/vjousse/mattermost-haskell/blob/master/src/Mattermost.hs#L24 here is the compilation error I'm getting: https://pastebin.com/HSmD9WGU
23:53:12 <vjousse> Disclaimer: I'm new to Haskell
23:53:16 <cocreature> vjousse: you need to catch "HttpException" not "HttpExceptionContent"
23:53:28 <cocreature> so your handler needs to be of type "HttpException -> IO something"
23:54:18 <cocreature> you can then pattern match on the different constructors and extract the HttpExceptionContent
23:54:51 <vjousse> I tried that at first, but I gives me:
23:54:52 <vjousse> /home/vjousse/usr/src/haskell/mattermost-haskell/src/Mattermost.hs:27:14: error:
23:54:54 <vjousse>     • Couldn't match expected type ‘HttpException’
23:54:56 <vjousse>                   with actual type ‘HttpExceptionContent’
23:55:11 <cocreature> I’m going to need to see the code for that to tell you what’s going on
23:55:51 <vjousse> here you go: https://github.com/vjousse/mattermost-haskell/blob/master/src/Mattermost.hs
23:56:39 <cocreature> StatusCodeException is a constructor of HttpExceptionContent but now that you’ve changed the type, you need to pattern match on constructors of HttpException
23:57:08 <cocreature> e.g. (HttpExceptionRequest _ (StatusCodeException s _))
23:57:34 <vjousse> Ô
23:57:43 <vjousse> I think I got it, let me try
23:59:43 <miller> cocreature: is := part of the core haskell language?  I can't seem to find it on hoogle as an operator and it's mentioned but not listed in Data.Record
